// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39877 0 0
// InitNature ;
  19: CALL 39745 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12700 0 0
// PrepareRussian ;
  40: CALL 7630 0 0
// PrepareLegion ;
  44: CALL 4684 0 0
// PreparePowell ;
  48: CALL 3218 0 0
// PrepareAmerican ;
  52: CALL 1818 0 0
// Action ;
  56: CALL 17650 0 0
// MC_Start ( ) ;
  60: CALL 42057 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 65113 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 65210 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 64552 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 64367 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 65113 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 65210 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 64367 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 64552 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64984 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 64030 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 65113 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 65210 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 64367 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 65113 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 65210 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 64259 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 65540 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64691 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64984 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64984 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 65330 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 64367 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64933 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: IFFALSE 1558
1548: PUSH
1549: LD_EXP 17
1553: PUSH
1554: LD_INT 2
1556: GREATEREQUAL
1557: AND
1558: IFFALSE 1570
1560: GO 1562
1562: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1563: LD_STRING ACH_POWELL
1565: PPUSH
1566: CALL_OW 543
1570: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1571: LD_EXP 39
1575: PUSH
1576: LD_INT 30
1578: GREATEREQUAL
1579: IFFALSE 1591
1581: GO 1583
1583: DISABLE
// SetAchievement ( ACH_PROD ) ;
1584: LD_STRING ACH_PROD
1586: PPUSH
1587: CALL_OW 543
1591: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1592: LD_INT 22
1594: PUSH
1595: LD_INT 1
1597: PUSH
1598: EMPTY
1599: LIST
1600: LIST
1601: PUSH
1602: LD_INT 21
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 2
1614: PUSH
1615: LD_INT 28
1617: PUSH
1618: LD_INT 1
1620: PUSH
1621: LD_INT 10
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: PUSH
1629: LD_INT 28
1631: PUSH
1632: LD_INT 2
1634: PUSH
1635: LD_INT 10
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_INT 3
1648: PUSH
1649: LD_INT 10
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 28
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 10
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: LIST
1682: PPUSH
1683: CALL_OW 69
1687: PUSH
1688: LD_INT 10
1690: GREATEREQUAL
1691: IFFALSE 1703
1693: GO 1695
1695: DISABLE
// SetAchievement ( ACH_EXP ) ;
1696: LD_STRING ACH_EXP
1698: PPUSH
1699: CALL_OW 543
1703: END
// every 0 0$1 trigger debug do var i , tmp ;
1704: LD_EXP 1
1708: IFFALSE 1815
1710: GO 1712
1712: DISABLE
1713: LD_INT 0
1715: PPUSH
1716: PPUSH
// begin enable ;
1717: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1718: LD_ADDR_VAR 0 2
1722: PUSH
1723: LD_INT 22
1725: PUSH
1726: LD_INT 1
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: PUSH
1733: LD_INT 3
1735: PUSH
1736: LD_INT 21
1738: PUSH
1739: LD_INT 3
1741: PUSH
1742: EMPTY
1743: LIST
1744: LIST
1745: PUSH
1746: EMPTY
1747: LIST
1748: LIST
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 24
1755: PUSH
1756: LD_INT 999
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: PUSH
1763: EMPTY
1764: LIST
1765: LIST
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: ST_TO_ADDR
// if not tmp then
1777: LD_VAR 0 2
1781: NOT
1782: IFFALSE 1786
// exit ;
1784: GO 1815
// for i in tmp do
1786: LD_ADDR_VAR 0 1
1790: PUSH
1791: LD_VAR 0 2
1795: PUSH
1796: FOR_IN
1797: IFFALSE 1813
// SetLives ( i , 1000 ) ;
1799: LD_VAR 0 1
1803: PPUSH
1804: LD_INT 1000
1806: PPUSH
1807: CALL_OW 234
1811: GO 1796
1813: POP
1814: POP
// end ; end_of_file
1815: PPOPN 2
1817: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1818: LD_INT 0
1820: PPUSH
// uc_side := 1 ;
1821: LD_ADDR_OWVAR 20
1825: PUSH
1826: LD_INT 1
1828: ST_TO_ADDR
// uc_nation := 1 ;
1829: LD_ADDR_OWVAR 21
1833: PUSH
1834: LD_INT 1
1836: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING JMM
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 14_
1853: PPUSH
1854: CALL 70939 0 3
1858: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1859: LD_EXP 4
1863: NOT
1864: IFTRUE 1881
1866: PUSH
1867: LD_EXP 4
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: PUSH
1876: LD_INT 1
1878: ARRAY
1879: NOT
1880: OR
1881: IFFALSE 1946
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1883: LD_INT 5
1885: PUSH
1886: LD_INT 5
1888: PUSH
1889: LD_INT 3
1891: PUSH
1892: LD_INT 3
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_OWVAR 67
1905: ARRAY
1906: PPUSH
1907: LD_INT 3
1909: PPUSH
1910: LD_INT 1
1912: PPUSH
1913: LD_INT 9
1915: PUSH
1916: LD_INT 9
1918: PUSH
1919: LD_INT 5
1921: PUSH
1922: LD_INT 5
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: PUSH
1931: LD_OWVAR 67
1935: ARRAY
1936: PPUSH
1937: LD_INT 100
1939: PPUSH
1940: CALL 75925 0 5
1944: GO 2005
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1946: LD_EXP 4
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PUSH
1955: LD_INT 1
1957: ARRAY
1958: PPUSH
1959: LD_EXP 4
1963: PUSH
1964: LD_INT 2
1966: ARRAY
1967: PUSH
1968: LD_INT 1
1970: ARRAY
1971: PPUSH
1972: LD_EXP 4
1976: PUSH
1977: LD_INT 3
1979: ARRAY
1980: PUSH
1981: LD_INT 1
1983: ARRAY
1984: PPUSH
1985: LD_EXP 4
1989: PUSH
1990: LD_INT 4
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PPUSH
1998: LD_INT 30
2000: PPUSH
2001: CALL 75925 0 5
// JMMNewVeh := CreateVehicle ;
2005: LD_ADDR_EXP 59
2009: PUSH
2010: CALL_OW 45
2014: ST_TO_ADDR
// if not JMMNewVeh then
2015: LD_EXP 59
2019: NOT
2020: IFFALSE 2051
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2022: LD_INT 5
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_INT 9
2033: PPUSH
2034: LD_INT 100
2036: PPUSH
2037: CALL 75925 0 5
// JMMNewVeh := CreateVehicle ;
2041: LD_ADDR_EXP 59
2045: PUSH
2046: CALL_OW 45
2050: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2051: LD_EXP 59
2055: PPUSH
2056: LD_INT 4
2058: PPUSH
2059: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2063: LD_EXP 59
2067: PPUSH
2068: LD_INT 1
2070: NEG
2071: PPUSH
2072: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2076: LD_EXP 59
2080: PPUSH
2081: LD_INT 79
2083: PPUSH
2084: LD_INT 91
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2094: LD_EXP 40
2098: PPUSH
2099: LD_EXP 59
2103: PPUSH
2104: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2108: LD_EXP 6
2112: IFFALSE 2121
2114: PUSH
2115: LD_EXP 2
2119: NOT
2120: AND
2121: IFFALSE 2379
// begin if not JMMGirlVeh then
2123: LD_EXP 5
2127: NOT
2128: IFFALSE 2151
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2130: LD_INT 3
2132: PPUSH
2133: LD_INT 3
2135: PPUSH
2136: LD_INT 1
2138: PPUSH
2139: LD_INT 9
2141: PPUSH
2142: LD_INT 100
2144: PPUSH
2145: CALL 75925 0 5
2149: GO 2210
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2151: LD_EXP 5
2155: PUSH
2156: LD_INT 1
2158: ARRAY
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PPUSH
2164: LD_EXP 5
2168: PUSH
2169: LD_INT 2
2171: ARRAY
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: PPUSH
2177: LD_EXP 5
2181: PUSH
2182: LD_INT 3
2184: ARRAY
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: LD_EXP 5
2194: PUSH
2195: LD_INT 4
2197: ARRAY
2198: PUSH
2199: LD_INT 1
2201: ARRAY
2202: PPUSH
2203: LD_INT 30
2205: PPUSH
2206: CALL 75925 0 5
// GirlNewVeh := CreateVehicle ;
2210: LD_ADDR_EXP 60
2214: PUSH
2215: CALL_OW 45
2219: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2220: LD_EXP 60
2224: PPUSH
2225: LD_INT 4
2227: PPUSH
2228: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2232: LD_EXP 60
2236: PPUSH
2237: LD_INT 82
2239: PPUSH
2240: LD_INT 96
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 48
// if JMMGirl = 1 then
2250: LD_EXP 7
2254: PUSH
2255: LD_INT 1
2257: EQUAL
2258: IFFALSE 2293
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2260: LD_ADDR_EXP 41
2264: PUSH
2265: LD_STRING Joan
2267: PPUSH
2268: LD_INT 1
2270: PPUSH
2271: LD_STRING 14_
2273: PPUSH
2274: CALL 70939 0 3
2278: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2279: LD_EXP 41
2283: PPUSH
2284: LD_EXP 60
2288: PPUSH
2289: CALL_OW 52
// end ; if JMMGirl = 2 then
2293: LD_EXP 7
2297: PUSH
2298: LD_INT 2
2300: EQUAL
2301: IFFALSE 2336
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2303: LD_ADDR_EXP 43
2307: PUSH
2308: LD_STRING Lisa
2310: PPUSH
2311: LD_INT 1
2313: PPUSH
2314: LD_STRING 14_
2316: PPUSH
2317: CALL 70939 0 3
2321: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2322: LD_EXP 43
2326: PPUSH
2327: LD_EXP 60
2331: PPUSH
2332: CALL_OW 52
// end ; if JMMGirl = 3 then
2336: LD_EXP 7
2340: PUSH
2341: LD_INT 3
2343: EQUAL
2344: IFFALSE 2379
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2346: LD_ADDR_EXP 55
2350: PUSH
2351: LD_STRING Connie
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_STRING 14_
2359: PPUSH
2360: CALL 70939 0 3
2364: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2365: LD_EXP 55
2369: PPUSH
2370: LD_EXP 60
2374: PPUSH
2375: CALL_OW 52
// end ; end ; end ;
2379: LD_VAR 0 1
2383: RET
// export function PrepareStevensSquad ; var tmp ; begin
2384: LD_INT 0
2386: PPUSH
2387: PPUSH
// uc_side := 1 ;
2388: LD_ADDR_OWVAR 20
2392: PUSH
2393: LD_INT 1
2395: ST_TO_ADDR
// uc_nation := 1 ;
2396: LD_ADDR_OWVAR 21
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// tmp := [ ] ;
2404: LD_ADDR_VAR 0 2
2408: PUSH
2409: EMPTY
2410: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2411: LD_ADDR_EXP 42
2415: PUSH
2416: LD_STRING Stevens
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13f_
2427: PPUSH
2428: CALL 70939 0 3
2432: ST_TO_ADDR
// if not Stevens then
2433: LD_EXP 42
2437: NOT
2438: IFFALSE 2552
// begin hc_name = Baker Smith ;
2440: LD_ADDR_OWVAR 26
2444: PUSH
2445: LD_STRING Baker Smith
2447: ST_TO_ADDR
// hc_gallery = us ;
2448: LD_ADDR_OWVAR 33
2452: PUSH
2453: LD_STRING us
2455: ST_TO_ADDR
// hc_face_number := 29 ;
2456: LD_ADDR_OWVAR 34
2460: PUSH
2461: LD_INT 29
2463: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2464: LD_INT 1
2466: PPUSH
2467: LD_INT 10
2469: PPUSH
2470: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2474: LD_ADDR_OWVAR 30
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 2
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2497: LD_ADDR_OWVAR 31
2501: PUSH
2502: LD_INT 4
2504: PUSH
2505: LD_INT 5
2507: PUSH
2508: LD_INT 2
2510: PUSH
2511: LD_INT 10
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: ST_TO_ADDR
// Baker := CreateHuman ;
2520: LD_ADDR_EXP 56
2524: PUSH
2525: CALL_OW 44
2529: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2530: LD_ADDR_VAR 0 2
2534: PUSH
2535: LD_VAR 0 2
2539: PUSH
2540: LD_EXP 56
2544: ADD
2545: ST_TO_ADDR
// InitHc ;
2546: CALL_OW 19
// end else
2550: GO 2568
// tmp := tmp ^ Stevens ;
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 2
2561: PUSH
2562: LD_EXP 42
2566: ADD
2567: ST_TO_ADDR
// if not Lisa then
2568: LD_EXP 43
2572: NOT
2573: IFFALSE 2619
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2575: LD_ADDR_EXP 43
2579: PUSH
2580: LD_STRING Lisa
2582: PPUSH
2583: LD_EXP 1
2587: NOT
2588: PPUSH
2589: LD_STRING 13f_
2591: PPUSH
2592: CALL 70939 0 3
2596: ST_TO_ADDR
// if Lisa then
2597: LD_EXP 43
2601: IFFALSE 2619
// tmp := tmp ^ Lisa ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_VAR 0 2
2612: PUSH
2613: LD_EXP 43
2617: ADD
2618: ST_TO_ADDR
// end ; if not Donaldson then
2619: LD_EXP 44
2623: NOT
2624: IFFALSE 2670
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2626: LD_ADDR_EXP 44
2630: PUSH
2631: LD_STRING Donaldson
2633: PPUSH
2634: LD_EXP 1
2638: NOT
2639: PPUSH
2640: LD_STRING 13f_
2642: PPUSH
2643: CALL 70939 0 3
2647: ST_TO_ADDR
// if Donaldson then
2648: LD_EXP 44
2652: IFFALSE 2670
// tmp := tmp ^ Donaldson ;
2654: LD_ADDR_VAR 0 2
2658: PUSH
2659: LD_VAR 0 2
2663: PUSH
2664: LD_EXP 44
2668: ADD
2669: ST_TO_ADDR
// end ; if not Bobby then
2670: LD_EXP 45
2674: NOT
2675: IFFALSE 2721
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2677: LD_ADDR_EXP 45
2681: PUSH
2682: LD_STRING Bobby
2684: PPUSH
2685: LD_EXP 1
2689: NOT
2690: PPUSH
2691: LD_STRING 13f_
2693: PPUSH
2694: CALL 70939 0 3
2698: ST_TO_ADDR
// if Bobby then
2699: LD_EXP 45
2703: IFFALSE 2721
// tmp := tmp ^ Bobby ;
2705: LD_ADDR_VAR 0 2
2709: PUSH
2710: LD_VAR 0 2
2714: PUSH
2715: LD_EXP 45
2719: ADD
2720: ST_TO_ADDR
// end ; if not Cyrus then
2721: LD_EXP 46
2725: NOT
2726: IFFALSE 2772
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2728: LD_ADDR_EXP 46
2732: PUSH
2733: LD_STRING Cyrus
2735: PPUSH
2736: LD_EXP 1
2740: NOT
2741: PPUSH
2742: LD_STRING 13f_
2744: PPUSH
2745: CALL 70939 0 3
2749: ST_TO_ADDR
// if Cyrus then
2750: LD_EXP 46
2754: IFFALSE 2772
// tmp := tmp ^ Cyrus ;
2756: LD_ADDR_VAR 0 2
2760: PUSH
2761: LD_VAR 0 2
2765: PUSH
2766: LD_EXP 46
2770: ADD
2771: ST_TO_ADDR
// end ; if not Brown then
2772: LD_EXP 48
2776: NOT
2777: IFFALSE 2823
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2779: LD_ADDR_EXP 48
2783: PUSH
2784: LD_STRING Brown
2786: PPUSH
2787: LD_EXP 1
2791: NOT
2792: PPUSH
2793: LD_STRING 13f_
2795: PPUSH
2796: CALL 70939 0 3
2800: ST_TO_ADDR
// if Brown then
2801: LD_EXP 48
2805: IFFALSE 2823
// tmp := tmp ^ Brown ;
2807: LD_ADDR_VAR 0 2
2811: PUSH
2812: LD_VAR 0 2
2816: PUSH
2817: LD_EXP 48
2821: ADD
2822: ST_TO_ADDR
// end ; if not Gladstone then
2823: LD_EXP 49
2827: NOT
2828: IFFALSE 2874
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2830: LD_ADDR_EXP 49
2834: PUSH
2835: LD_STRING Gladstone
2837: PPUSH
2838: LD_EXP 1
2842: NOT
2843: PPUSH
2844: LD_STRING 13f_
2846: PPUSH
2847: CALL 70939 0 3
2851: ST_TO_ADDR
// if Gladstone then
2852: LD_EXP 49
2856: IFFALSE 2874
// tmp := tmp ^ Gladstone ;
2858: LD_ADDR_VAR 0 2
2862: PUSH
2863: LD_VAR 0 2
2867: PUSH
2868: LD_EXP 49
2872: ADD
2873: ST_TO_ADDR
// end ; if not Houten then
2874: LD_EXP 50
2878: NOT
2879: IFFALSE 2925
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2881: LD_ADDR_EXP 50
2885: PUSH
2886: LD_STRING Houten
2888: PPUSH
2889: LD_EXP 1
2893: NOT
2894: PPUSH
2895: LD_STRING 13f_
2897: PPUSH
2898: CALL 70939 0 3
2902: ST_TO_ADDR
// if Houten then
2903: LD_EXP 50
2907: IFFALSE 2925
// tmp := tmp ^ Houten ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_EXP 50
2923: ADD
2924: ST_TO_ADDR
// end ; if not Cornel then
2925: LD_EXP 51
2929: NOT
2930: IFFALSE 2976
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2932: LD_ADDR_EXP 51
2936: PUSH
2937: LD_STRING Cornell
2939: PPUSH
2940: LD_EXP 1
2944: NOT
2945: PPUSH
2946: LD_STRING 13f_
2948: PPUSH
2949: CALL 70939 0 3
2953: ST_TO_ADDR
// if Cornel then
2954: LD_EXP 51
2958: IFFALSE 2976
// tmp := tmp ^ Cornel ;
2960: LD_ADDR_VAR 0 2
2964: PUSH
2965: LD_VAR 0 2
2969: PUSH
2970: LD_EXP 51
2974: ADD
2975: ST_TO_ADDR
// end ; if not Gary then
2976: LD_EXP 52
2980: NOT
2981: IFFALSE 3027
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2983: LD_ADDR_EXP 52
2987: PUSH
2988: LD_STRING Gary
2990: PPUSH
2991: LD_EXP 1
2995: NOT
2996: PPUSH
2997: LD_STRING 13f_
2999: PPUSH
3000: CALL 70939 0 3
3004: ST_TO_ADDR
// if Gary then
3005: LD_EXP 52
3009: IFFALSE 3027
// tmp := tmp ^ Gary ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_EXP 52
3025: ADD
3026: ST_TO_ADDR
// end ; if not Frank then
3027: LD_EXP 53
3031: NOT
3032: IFFALSE 3078
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3034: LD_ADDR_EXP 53
3038: PUSH
3039: LD_STRING Frank
3041: PPUSH
3042: LD_EXP 1
3046: NOT
3047: PPUSH
3048: LD_STRING 13f_
3050: PPUSH
3051: CALL 70939 0 3
3055: ST_TO_ADDR
// if Frank then
3056: LD_EXP 53
3060: IFFALSE 3078
// tmp := tmp ^ Frank ;
3062: LD_ADDR_VAR 0 2
3066: PUSH
3067: LD_VAR 0 2
3071: PUSH
3072: LD_EXP 53
3076: ADD
3077: ST_TO_ADDR
// end ; if not Kikuchi then
3078: LD_EXP 54
3082: NOT
3083: IFFALSE 3129
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3085: LD_ADDR_EXP 54
3089: PUSH
3090: LD_STRING Kikuchi
3092: PPUSH
3093: LD_EXP 1
3097: NOT
3098: PPUSH
3099: LD_STRING 13f_
3101: PPUSH
3102: CALL 70939 0 3
3106: ST_TO_ADDR
// if Kikuchi then
3107: LD_EXP 54
3111: IFFALSE 3129
// tmp := tmp ^ Kikuchi ;
3113: LD_ADDR_VAR 0 2
3117: PUSH
3118: LD_VAR 0 2
3122: PUSH
3123: LD_EXP 54
3127: ADD
3128: ST_TO_ADDR
// end ; if not DeltaDoctor then
3129: LD_EXP 58
3133: NOT
3134: IFFALSE 3180
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 58
3140: PUSH
3141: LD_STRING DeltaDoctor
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 70939 0 3
3157: ST_TO_ADDR
// if Bobby then
3158: LD_EXP 45
3162: IFFALSE 3180
// tmp := tmp ^ DeltaDoctor ;
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_VAR 0 2
3173: PUSH
3174: LD_EXP 58
3178: ADD
3179: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3180: LD_ADDR_VAR 0 2
3184: PUSH
3185: LD_VAR 0 2
3189: PUSH
3190: LD_STRING 13_other_survivors
3192: PPUSH
3193: CALL_OW 31
3197: UNION
3198: ST_TO_ADDR
// result := tmp diff 0 ;
3199: LD_ADDR_VAR 0 1
3203: PUSH
3204: LD_VAR 0 2
3208: PUSH
3209: LD_INT 0
3211: DIFF
3212: ST_TO_ADDR
// end ; end_of_file
3213: LD_VAR 0 1
3217: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3218: LD_INT 0
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
3226: PPUSH
3227: PPUSH
3228: PPUSH
3229: PPUSH
// uc_side := 4 ;
3230: LD_ADDR_OWVAR 20
3234: PUSH
3235: LD_INT 4
3237: ST_TO_ADDR
// uc_nation := 1 ;
3238: LD_ADDR_OWVAR 21
3242: PUSH
3243: LD_INT 1
3245: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3246: LD_INT 387
3248: PPUSH
3249: CALL_OW 274
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 3500
3259: PUSH
3260: LD_INT 3000
3262: PUSH
3263: LD_INT 2500
3265: PUSH
3266: LD_INT 2000
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_OWVAR 67
3279: ARRAY
3280: PPUSH
3281: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3285: LD_INT 387
3287: PPUSH
3288: CALL_OW 274
3292: PPUSH
3293: LD_INT 2
3295: PPUSH
3296: LD_INT 400
3298: PPUSH
3299: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3303: LD_INT 387
3305: PPUSH
3306: CALL_OW 274
3310: PPUSH
3311: LD_INT 3
3313: PPUSH
3314: LD_INT 10
3316: PPUSH
3317: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3321: LD_INT 387
3323: PPUSH
3324: LD_STRING sigma
3326: PPUSH
3327: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3331: LD_ADDR_EXP 61
3335: PUSH
3336: LD_STRING Powell
3338: PPUSH
3339: CALL_OW 25
3343: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3344: LD_EXP 61
3348: PPUSH
3349: LD_INT 57
3351: PPUSH
3352: LD_INT 94
3354: PPUSH
3355: LD_INT 0
3357: PPUSH
3358: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3362: LD_EXP 61
3366: PPUSH
3367: LD_INT 58
3369: PPUSH
3370: LD_INT 94
3372: PPUSH
3373: CALL_OW 118
// vip := [ ] ;
3377: LD_ADDR_EXP 62
3381: PUSH
3382: EMPTY
3383: ST_TO_ADDR
// extraSquad := [ ] ;
3384: LD_ADDR_EXP 63
3388: PUSH
3389: EMPTY
3390: ST_TO_ADDR
// tmp := [ ] ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: EMPTY
3397: ST_TO_ADDR
// if JMMGirl <> 2 then
3398: LD_EXP 7
3402: PUSH
3403: LD_INT 2
3405: NONEQUAL
3406: IFFALSE 3430
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3408: LD_ADDR_EXP 43
3412: PUSH
3413: LD_STRING Lisa
3415: PPUSH
3416: LD_EXP 1
3420: NOT
3421: PPUSH
3422: LD_STRING 13s_
3424: PPUSH
3425: CALL 70939 0 3
3429: ST_TO_ADDR
// if Lisa then
3430: LD_EXP 43
3434: IFFALSE 3452
// tmp := tmp ^ Lisa ;
3436: LD_ADDR_VAR 0 5
3440: PUSH
3441: LD_VAR 0 5
3445: PUSH
3446: LD_EXP 43
3450: ADD
3451: ST_TO_ADDR
// if JMMGirl < 3 then
3452: LD_EXP 7
3456: PUSH
3457: LD_INT 3
3459: LESS
3460: IFFALSE 3491
// begin Connie := NewCharacter ( Coonie ) ;
3462: LD_ADDR_EXP 55
3466: PUSH
3467: LD_STRING Coonie
3469: PPUSH
3470: CALL_OW 25
3474: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3475: LD_ADDR_VAR 0 5
3479: PUSH
3480: LD_VAR 0 5
3484: PUSH
3485: LD_EXP 55
3489: ADD
3490: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3491: LD_ADDR_EXP 44
3495: PUSH
3496: LD_STRING Donaldson
3498: PPUSH
3499: LD_EXP 1
3503: NOT
3504: PPUSH
3505: LD_STRING 13s_
3507: PPUSH
3508: CALL 70939 0 3
3512: ST_TO_ADDR
// if Donaldson then
3513: LD_EXP 44
3517: IFFALSE 3535
// tmp := tmp ^ Donaldson ;
3519: LD_ADDR_VAR 0 5
3523: PUSH
3524: LD_VAR 0 5
3528: PUSH
3529: LD_EXP 44
3533: ADD
3534: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3535: LD_ADDR_EXP 45
3539: PUSH
3540: LD_STRING Bobby
3542: PPUSH
3543: LD_EXP 1
3547: NOT
3548: PPUSH
3549: LD_STRING 13s_
3551: PPUSH
3552: CALL 70939 0 3
3556: ST_TO_ADDR
// if Bobby then
3557: LD_EXP 45
3561: IFFALSE 3579
// tmp := tmp ^ Bobby ;
3563: LD_ADDR_VAR 0 5
3567: PUSH
3568: LD_VAR 0 5
3572: PUSH
3573: LD_EXP 45
3577: ADD
3578: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3579: LD_ADDR_EXP 46
3583: PUSH
3584: LD_STRING Cyrus
3586: PPUSH
3587: LD_EXP 1
3591: NOT
3592: PPUSH
3593: LD_STRING 13s_
3595: PPUSH
3596: CALL 70939 0 3
3600: ST_TO_ADDR
// if Cyrus then
3601: LD_EXP 46
3605: IFFALSE 3623
// tmp := tmp ^ Cyrus ;
3607: LD_ADDR_VAR 0 5
3611: PUSH
3612: LD_VAR 0 5
3616: PUSH
3617: LD_EXP 46
3621: ADD
3622: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3623: LD_ADDR_EXP 47
3627: PUSH
3628: LD_STRING Denis
3630: PPUSH
3631: LD_EXP 1
3635: NOT
3636: PPUSH
3637: LD_STRING 13s_
3639: PPUSH
3640: CALL 70939 0 3
3644: ST_TO_ADDR
// if not Denis then
3645: LD_EXP 47
3649: NOT
3650: IFFALSE 3674
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3652: LD_ADDR_EXP 47
3656: PUSH
3657: LD_STRING Denis
3659: PPUSH
3660: LD_EXP 1
3664: NOT
3665: PPUSH
3666: LD_STRING 13f_
3668: PPUSH
3669: CALL 70939 0 3
3673: ST_TO_ADDR
// if Denis then
3674: LD_EXP 47
3678: IFFALSE 3696
// tmp := tmp ^ Denis ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: LD_EXP 47
3694: ADD
3695: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3696: LD_ADDR_EXP 48
3700: PUSH
3701: LD_STRING Brown
3703: PPUSH
3704: LD_EXP 1
3708: NOT
3709: PPUSH
3710: LD_STRING 13s_
3712: PPUSH
3713: CALL 70939 0 3
3717: ST_TO_ADDR
// if Brown then
3718: LD_EXP 48
3722: IFFALSE 3740
// tmp := tmp ^ Brown ;
3724: LD_ADDR_VAR 0 5
3728: PUSH
3729: LD_VAR 0 5
3733: PUSH
3734: LD_EXP 48
3738: ADD
3739: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3740: LD_ADDR_EXP 49
3744: PUSH
3745: LD_STRING Gladstone
3747: PPUSH
3748: LD_EXP 1
3752: NOT
3753: PPUSH
3754: LD_STRING 13s_
3756: PPUSH
3757: CALL 70939 0 3
3761: ST_TO_ADDR
// if Gladstone then
3762: LD_EXP 49
3766: IFFALSE 3784
// tmp := tmp ^ Gladstone ;
3768: LD_ADDR_VAR 0 5
3772: PUSH
3773: LD_VAR 0 5
3777: PUSH
3778: LD_EXP 49
3782: ADD
3783: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3784: LD_ADDR_EXP 50
3788: PUSH
3789: LD_STRING Houten
3791: PPUSH
3792: LD_EXP 1
3796: NOT
3797: PPUSH
3798: LD_STRING 13s_
3800: PPUSH
3801: CALL 70939 0 3
3805: ST_TO_ADDR
// if Houten then
3806: LD_EXP 50
3810: IFFALSE 3828
// tmp := tmp ^ Houten ;
3812: LD_ADDR_VAR 0 5
3816: PUSH
3817: LD_VAR 0 5
3821: PUSH
3822: LD_EXP 50
3826: ADD
3827: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3828: LD_ADDR_EXP 51
3832: PUSH
3833: LD_STRING Cornel
3835: PPUSH
3836: LD_EXP 1
3840: NOT
3841: PPUSH
3842: LD_STRING 13s_
3844: PPUSH
3845: CALL 70939 0 3
3849: ST_TO_ADDR
// if Cornel then
3850: LD_EXP 51
3854: IFFALSE 3872
// tmp := tmp ^ Cornel ;
3856: LD_ADDR_VAR 0 5
3860: PUSH
3861: LD_VAR 0 5
3865: PUSH
3866: LD_EXP 51
3870: ADD
3871: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3872: LD_ADDR_EXP 52
3876: PUSH
3877: LD_STRING Gary
3879: PPUSH
3880: LD_EXP 1
3884: NOT
3885: PPUSH
3886: LD_STRING 13s_
3888: PPUSH
3889: CALL 70939 0 3
3893: ST_TO_ADDR
// if Gary then
3894: LD_EXP 52
3898: IFFALSE 3916
// tmp := tmp ^ Gary ;
3900: LD_ADDR_VAR 0 5
3904: PUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_EXP 52
3914: ADD
3915: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3916: LD_ADDR_EXP 53
3920: PUSH
3921: LD_STRING Frank
3923: PPUSH
3924: LD_EXP 1
3928: NOT
3929: PPUSH
3930: LD_STRING 13s_
3932: PPUSH
3933: CALL 70939 0 3
3937: ST_TO_ADDR
// if Frank then
3938: LD_EXP 53
3942: IFFALSE 3960
// tmp := tmp ^ Frank ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: LD_VAR 0 5
3953: PUSH
3954: LD_EXP 53
3958: ADD
3959: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3960: LD_ADDR_EXP 54
3964: PUSH
3965: LD_STRING Kikuchi
3967: PPUSH
3968: LD_EXP 1
3972: NOT
3973: PPUSH
3974: LD_STRING 13s_
3976: PPUSH
3977: CALL 70939 0 3
3981: ST_TO_ADDR
// if Kikuchi then
3982: LD_EXP 54
3986: IFFALSE 4004
// tmp := tmp ^ Kikuchi ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: LD_VAR 0 5
3997: PUSH
3998: LD_EXP 54
4002: ADD
4003: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
4004: LD_ADDR_EXP 58
4008: PUSH
4009: LD_STRING DeltaDoctor
4011: PPUSH
4012: LD_EXP 1
4016: NOT
4017: PPUSH
4018: LD_STRING 13s_
4020: PPUSH
4021: CALL 70939 0 3
4025: ST_TO_ADDR
// if DeltaDoctor then
4026: LD_EXP 58
4030: IFFALSE 4048
// tmp := tmp ^ DeltaDoctor ;
4032: LD_ADDR_VAR 0 5
4036: PUSH
4037: LD_VAR 0 5
4041: PUSH
4042: LD_EXP 58
4046: ADD
4047: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4048: LD_ADDR_EXP 57
4052: PUSH
4053: LD_STRING Mike
4055: PPUSH
4056: LD_EXP 1
4060: NOT
4061: PPUSH
4062: LD_STRING 10c_
4064: PPUSH
4065: CALL 70939 0 3
4069: ST_TO_ADDR
// if Mike then
4070: LD_EXP 57
4074: IFFALSE 4097
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4076: LD_EXP 57
4080: PPUSH
4081: LD_INT 61
4083: PPUSH
4084: LD_INT 89
4086: PPUSH
4087: LD_INT 8
4089: PPUSH
4090: LD_INT 0
4092: PPUSH
4093: CALL_OW 50
// vip := tmp ;
4097: LD_ADDR_EXP 62
4101: PUSH
4102: LD_VAR 0 5
4106: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4107: LD_ADDR_VAR 0 5
4111: PUSH
4112: LD_VAR 0 5
4116: PUSH
4117: LD_STRING 13s_others
4119: PPUSH
4120: CALL_OW 31
4124: UNION
4125: ST_TO_ADDR
// if tmp < 18 then
4126: LD_VAR 0 5
4130: PUSH
4131: LD_INT 18
4133: LESS
4134: IFFALSE 4239
// begin InitHC_All ( ) ;
4136: CALL_OW 584
// for i = 1 to 18 - tmp do
4140: LD_ADDR_VAR 0 2
4144: PUSH
4145: DOUBLE
4146: LD_INT 1
4148: DEC
4149: ST_TO_ADDR
4150: LD_INT 18
4152: PUSH
4153: LD_VAR 0 5
4157: MINUS
4158: PUSH
4159: FOR_TO
4160: IFFALSE 4237
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4162: LD_INT 1
4164: PPUSH
4165: LD_VAR 0 2
4169: PUSH
4170: LD_INT 4
4172: MOD
4173: PUSH
4174: LD_INT 1
4176: PLUS
4177: PPUSH
4178: LD_INT 4
4180: PPUSH
4181: CALL_OW 380
// un := CreateHuman ;
4185: LD_ADDR_VAR 0 10
4189: PUSH
4190: CALL_OW 44
4194: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4195: LD_ADDR_VAR 0 5
4199: PUSH
4200: LD_VAR 0 5
4204: PPUSH
4205: LD_VAR 0 10
4209: PPUSH
4210: CALL 109095 0 2
4214: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4215: LD_ADDR_EXP 63
4219: PUSH
4220: LD_EXP 63
4224: PPUSH
4225: LD_VAR 0 10
4229: PPUSH
4230: CALL 109095 0 2
4234: ST_TO_ADDR
// end ;
4235: GO 4159
4237: POP
4238: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4239: LD_ADDR_VAR 0 6
4243: PUSH
4244: LD_INT 53
4246: PPUSH
4247: LD_INT 94
4249: PPUSH
4250: CALL_OW 428
4254: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4255: LD_ADDR_VAR 0 7
4259: PUSH
4260: LD_INT 56
4262: PPUSH
4263: LD_INT 101
4265: PPUSH
4266: CALL_OW 428
4270: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4271: LD_ADDR_VAR 0 8
4275: PUSH
4276: LD_INT 67
4278: PPUSH
4279: LD_INT 101
4281: PPUSH
4282: CALL_OW 428
4286: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4287: LD_ADDR_VAR 0 9
4291: PUSH
4292: LD_INT 54
4294: PPUSH
4295: LD_INT 85
4297: PPUSH
4298: CALL_OW 428
4302: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4303: LD_ADDR_VAR 0 3
4307: PUSH
4308: LD_VAR 0 8
4312: PUSH
4313: LD_VAR 0 6
4317: PUSH
4318: LD_VAR 0 9
4322: PUSH
4323: LD_VAR 0 7
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: LIST
4332: LIST
4333: ST_TO_ADDR
// for i in tmp do
4334: LD_ADDR_VAR 0 2
4338: PUSH
4339: LD_VAR 0 5
4343: PUSH
4344: FOR_IN
4345: IFFALSE 4540
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4347: LD_VAR 0 3
4351: PUSH
4352: LD_INT 1
4354: ARRAY
4355: PPUSH
4356: CALL_OW 266
4360: PUSH
4361: LD_INT 4
4363: DOUBLE
4364: EQUAL
4365: IFTRUE 4369
4367: GO 4384
4369: POP
// SetClass ( i , class_soldier ) ; b_depot :
4370: LD_VAR 0 2
4374: PPUSH
4375: LD_INT 1
4377: PPUSH
4378: CALL_OW 336
4382: GO 4454
4384: LD_INT 0
4386: DOUBLE
4387: EQUAL
4388: IFTRUE 4392
4390: GO 4407
4392: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4393: LD_VAR 0 2
4397: PPUSH
4398: LD_INT 2
4400: PPUSH
4401: CALL_OW 336
4405: GO 4454
4407: LD_INT 2
4409: DOUBLE
4410: EQUAL
4411: IFTRUE 4415
4413: GO 4430
4415: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4416: LD_VAR 0 2
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: CALL_OW 336
4428: GO 4454
4430: LD_INT 6
4432: DOUBLE
4433: EQUAL
4434: IFTRUE 4438
4436: GO 4453
4438: POP
// SetClass ( i , class_scientistic ) ; end ;
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_INT 4
4446: PPUSH
4447: CALL_OW 336
4451: GO 4454
4453: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4454: LD_VAR 0 3
4458: PUSH
4459: LD_INT 1
4461: ARRAY
4462: PPUSH
4463: CALL_OW 313
4467: PUSH
4468: LD_INT 6
4470: EQUAL
4471: IFFALSE 4491
// b := Delete ( b , 1 ) ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: LD_VAR 0 3
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: CALL_OW 3
4490: ST_TO_ADDR
// if b then
4491: LD_VAR 0 3
4495: IFFALSE 4517
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4497: LD_VAR 0 2
4501: PPUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_INT 1
4509: ARRAY
4510: PPUSH
4511: CALL_OW 52
4515: GO 4538
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4517: LD_VAR 0 2
4521: PPUSH
4522: LD_INT 61
4524: PPUSH
4525: LD_INT 89
4527: PPUSH
4528: LD_INT 8
4530: PPUSH
4531: LD_INT 0
4533: PPUSH
4534: CALL_OW 50
// end ;
4538: GO 4344
4540: POP
4541: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4542: LD_INT 2
4544: PPUSH
4545: LD_INT 1
4547: PPUSH
4548: LD_INT 1
4550: PPUSH
4551: LD_INT 12
4553: PPUSH
4554: LD_INT 100
4556: PPUSH
4557: CALL 75925 0 5
// veh := CreateVehicle ;
4561: LD_ADDR_VAR 0 4
4565: PUSH
4566: CALL_OW 45
4570: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4571: LD_VAR 0 4
4575: PPUSH
4576: LD_INT 4
4578: PPUSH
4579: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4583: LD_VAR 0 4
4587: PPUSH
4588: LD_INT 49
4590: PPUSH
4591: LD_INT 88
4593: PPUSH
4594: LD_INT 0
4596: PPUSH
4597: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4601: LD_VAR 0 4
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: LD_INT 100
4611: PPUSH
4612: CALL_OW 290
// uc_side := 0 ;
4616: LD_ADDR_OWVAR 20
4620: PUSH
4621: LD_INT 0
4623: ST_TO_ADDR
// uc_nation := 0 ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 0
4631: ST_TO_ADDR
// for i := 1 to 3 do
4632: LD_ADDR_VAR 0 2
4636: PUSH
4637: DOUBLE
4638: LD_INT 1
4640: DEC
4641: ST_TO_ADDR
4642: LD_INT 3
4644: PUSH
4645: FOR_TO
4646: IFFALSE 4677
// begin InitHc ;
4648: CALL_OW 19
// hc_class := class_apeman ;
4652: LD_ADDR_OWVAR 28
4656: PUSH
4657: LD_INT 12
4659: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4660: CALL_OW 44
4664: PPUSH
4665: LD_INT 13
4667: PPUSH
4668: LD_INT 0
4670: PPUSH
4671: CALL_OW 49
// end ;
4675: GO 4645
4677: POP
4678: POP
// end ; end_of_file
4679: LD_VAR 0 1
4683: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
4689: PPUSH
4690: PPUSH
// side := 8 ;
4691: LD_ADDR_VAR 0 3
4695: PUSH
4696: LD_INT 8
4698: ST_TO_ADDR
// uc_side := side ;
4699: LD_ADDR_OWVAR 20
4703: PUSH
4704: LD_VAR 0 3
4708: ST_TO_ADDR
// uc_nation := 2 ;
4709: LD_ADDR_OWVAR 21
4713: PUSH
4714: LD_INT 2
4716: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4717: LD_ADDR_VAR 0 2
4721: PUSH
4722: LD_INT 22
4724: PUSH
4725: LD_VAR 0 3
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 21
4736: PUSH
4737: LD_INT 3
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: FOR_IN
4754: IFFALSE 4770
// SetBLevel ( i , 10 ) ;
4756: LD_VAR 0 2
4760: PPUSH
4761: LD_INT 10
4763: PPUSH
4764: CALL_OW 241
4768: GO 4753
4770: POP
4771: POP
// if KurtStatus then
4772: LD_EXP 3
4776: IFFALSE 4799
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4778: LD_ADDR_EXP 64
4782: PUSH
4783: LD_STRING Kurt
4785: PPUSH
4786: LD_INT 0
4788: PPUSH
4789: LD_STRING 
4791: PPUSH
4792: CALL 70939 0 3
4796: ST_TO_ADDR
4797: GO 4821
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4799: LD_ADDR_EXP 64
4803: PUSH
4804: LD_STRING AltKurt
4806: PPUSH
4807: LD_EXP 1
4811: NOT
4812: PPUSH
4813: LD_STRING 
4815: PPUSH
4816: CALL 70939 0 3
4820: ST_TO_ADDR
// if not Kurt then
4821: LD_EXP 64
4825: NOT
4826: IFFALSE 4852
// begin InitHc ;
4828: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4832: LD_INT 1
4834: PPUSH
4835: LD_INT 10
4837: PPUSH
4838: CALL_OW 381
// Kurt := CreateHuman ;
4842: LD_ADDR_EXP 64
4846: PUSH
4847: CALL_OW 44
4851: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4852: LD_EXP 64
4856: PPUSH
4857: LD_INT 324
4859: PPUSH
4860: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4864: LD_ADDR_EXP 65
4868: PUSH
4869: LD_STRING Kozlov
4871: PPUSH
4872: LD_INT 0
4874: PPUSH
4875: LD_STRING 
4877: PPUSH
4878: CALL 70939 0 3
4882: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4883: LD_EXP 65
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_INT 8
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 23
4900: PUSH
4901: LD_INT 3
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 30
4910: PUSH
4911: LD_INT 8
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: LIST
4922: PPUSH
4923: CALL_OW 69
4927: PUSH
4928: LD_INT 1
4930: ARRAY
4931: PPUSH
4932: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4936: LD_EXP 65
4940: PPUSH
4941: LD_INT 3
4943: PPUSH
4944: LD_INT 10
4946: PPUSH
4947: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4951: LD_EXP 65
4955: PPUSH
4956: LD_INT 4
4958: PPUSH
4959: LD_INT 10
4961: PPUSH
4962: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4966: LD_ADDR_VAR 0 5
4970: PUSH
4971: LD_INT 22
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 32
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 58
4995: PUSH
4996: EMPTY
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL_OW 69
5008: ST_TO_ADDR
// for i = 1 to 10 do
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: DOUBLE
5015: LD_INT 1
5017: DEC
5018: ST_TO_ADDR
5019: LD_INT 10
5021: PUSH
5022: FOR_TO
5023: IFFALSE 5095
// begin uc_nation := nation_nature ;
5025: LD_ADDR_OWVAR 21
5029: PUSH
5030: LD_INT 0
5032: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5033: LD_ADDR_OWVAR 28
5037: PUSH
5038: LD_INT 15
5040: ST_TO_ADDR
// hc_gallery :=  ;
5041: LD_ADDR_OWVAR 33
5045: PUSH
5046: LD_STRING 
5048: ST_TO_ADDR
// hc_name :=  ;
5049: LD_ADDR_OWVAR 26
5053: PUSH
5054: LD_STRING 
5056: ST_TO_ADDR
// un := CreateHuman ;
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: CALL_OW 44
5066: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5067: LD_VAR 0 4
5071: PPUSH
5072: LD_VAR 0 5
5076: PUSH
5077: LD_VAR 0 5
5081: PUSH
5082: LD_VAR 0 2
5086: MINUS
5087: ARRAY
5088: PPUSH
5089: CALL_OW 52
// end ;
5093: GO 5022
5095: POP
5096: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5097: LD_ADDR_VAR 0 5
5101: PUSH
5102: LD_STRING 12_kurt_squad
5104: PPUSH
5105: CALL_OW 31
5109: ST_TO_ADDR
// if tmp then
5110: LD_VAR 0 5
5114: IFFALSE 5148
// for i in tmp do
5116: LD_ADDR_VAR 0 2
5120: PUSH
5121: LD_VAR 0 5
5125: PUSH
5126: FOR_IN
5127: IFFALSE 5146
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5129: LD_VAR 0 2
5133: PPUSH
5134: LD_INT 5
5136: PPUSH
5137: LD_INT 0
5139: PPUSH
5140: CALL_OW 49
5144: GO 5126
5146: POP
5147: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5148: LD_INT 324
5150: PPUSH
5151: LD_INT 5
5153: PPUSH
5154: LD_STRING 
5156: PPUSH
5157: LD_INT 8
5159: PUSH
5160: LD_INT 9
5162: PUSH
5163: LD_INT 10
5165: PUSH
5166: LD_INT 10
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_OWVAR 67
5179: ARRAY
5180: PPUSH
5181: LD_INT 3000
5183: PUSH
5184: LD_INT 500
5186: PUSH
5187: LD_INT 150
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: LIST
5194: PPUSH
5195: LD_INT 16
5197: PUSH
5198: LD_INT 6
5200: PUSH
5201: LD_INT 6
5203: PUSH
5204: LD_INT 8
5206: PUSH
5207: EMPTY
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL 79762 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5217: LD_ADDR_EXP 102
5221: PUSH
5222: LD_EXP 102
5226: PPUSH
5227: LD_INT 3
5229: PPUSH
5230: LD_INT 22
5232: PUSH
5233: LD_VAR 0 3
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 23
5244: PUSH
5245: LD_INT 2
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: PUSH
5252: LD_INT 3
5254: PUSH
5255: LD_INT 21
5257: PUSH
5258: LD_INT 2
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: PPUSH
5274: CALL_OW 69
5278: PUSH
5279: LD_EXP 64
5283: DIFF
5284: PPUSH
5285: CALL_OW 1
5289: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5290: LD_INT 1
5292: PPUSH
5293: LD_INT 7
5295: PPUSH
5296: CALL_OW 383
// hc_name := Ali Hadrach ;
5300: LD_ADDR_OWVAR 26
5304: PUSH
5305: LD_STRING Ali Hadrach
5307: ST_TO_ADDR
// hc_gallery := us ;
5308: LD_ADDR_OWVAR 33
5312: PUSH
5313: LD_STRING us
5315: ST_TO_ADDR
// hc_face_number := 31 ;
5316: LD_ADDR_OWVAR 34
5320: PUSH
5321: LD_INT 31
5323: ST_TO_ADDR
// Friend := CreateHuman ;
5324: LD_ADDR_EXP 66
5328: PUSH
5329: CALL_OW 44
5333: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5334: LD_INT 14
5336: PPUSH
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 29
5345: PPUSH
5346: LD_INT 100
5348: PPUSH
5349: CALL 75925 0 5
// powellBomb := CreateVehicle ;
5353: LD_ADDR_EXP 67
5357: PUSH
5358: CALL_OW 45
5362: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5363: LD_EXP 67
5367: PPUSH
5368: LD_INT 90
5370: PPUSH
5371: LD_INT 51
5373: PPUSH
5374: LD_INT 0
5376: PPUSH
5377: CALL_OW 48
// end ;
5381: LD_VAR 0 1
5385: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5386: LD_INT 0
5388: PPUSH
5389: PPUSH
5390: PPUSH
// if IsLive ( kozlov_fac ) then
5391: LD_INT 332
5393: PPUSH
5394: CALL_OW 300
5398: IFFALSE 5402
// exit ;
5400: GO 5969
// ComExitBuilding ( Kozlov ) ;
5402: LD_EXP 65
5406: PPUSH
5407: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5411: LD_EXP 65
5415: PPUSH
5416: CALL_OW 257
5420: PUSH
5421: LD_INT 2
5423: NONEQUAL
5424: IFFALSE 5459
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5426: LD_EXP 65
5430: PPUSH
5431: LD_INT 324
5433: PPUSH
5434: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5438: LD_EXP 65
5442: PPUSH
5443: LD_INT 2
5445: PPUSH
5446: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5450: LD_EXP 65
5454: PPUSH
5455: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5459: LD_EXP 65
5463: PPUSH
5464: LD_INT 2
5466: PPUSH
5467: LD_INT 93
5469: PPUSH
5470: LD_INT 32
5472: PPUSH
5473: LD_INT 3
5475: PPUSH
5476: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5480: LD_INT 35
5482: PPUSH
5483: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5487: LD_INT 22
5489: PUSH
5490: LD_INT 8
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 30
5499: PUSH
5500: LD_INT 3
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 3
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 57
5519: PUSH
5520: EMPTY
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL_OW 69
5533: IFFALSE 5480
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5535: LD_ADDR_VAR 0 2
5539: PUSH
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 30
5552: PUSH
5553: LD_INT 3
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 23
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 57
5572: PUSH
5573: EMPTY
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: PUSH
5587: LD_INT 1
5589: ARRAY
5590: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5591: LD_INT 22
5593: PUSH
5594: LD_INT 8
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: PUSH
5601: LD_INT 23
5603: PUSH
5604: LD_INT 3
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PUSH
5611: LD_INT 30
5613: PUSH
5614: LD_INT 21
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PUSH
5621: EMPTY
5622: LIST
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: NOT
5631: IFFALSE 5709
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5633: LD_EXP 65
5637: PPUSH
5638: LD_INT 21
5640: PPUSH
5641: LD_INT 97
5643: PPUSH
5644: LD_INT 36
5646: PPUSH
5647: LD_INT 5
5649: PPUSH
5650: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5654: LD_INT 35
5656: PPUSH
5657: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5661: LD_INT 22
5663: PUSH
5664: LD_INT 8
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 23
5673: PUSH
5674: LD_INT 3
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_INT 30
5683: PUSH
5684: LD_INT 21
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 57
5693: PUSH
5694: EMPTY
5695: LIST
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 69
5707: IFFALSE 5654
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5709: LD_INT 22
5711: PUSH
5712: LD_INT 8
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 23
5721: PUSH
5722: LD_INT 3
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 30
5731: PUSH
5732: LD_INT 18
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PPUSH
5744: CALL_OW 69
5748: NOT
5749: IFFALSE 5827
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5751: LD_EXP 65
5755: PPUSH
5756: LD_INT 18
5758: PPUSH
5759: LD_INT 89
5761: PPUSH
5762: LD_INT 32
5764: PPUSH
5765: LD_INT 1
5767: PPUSH
5768: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5772: LD_INT 35
5774: PPUSH
5775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5779: LD_INT 22
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_INT 23
5791: PUSH
5792: LD_INT 3
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: LD_INT 30
5801: PUSH
5802: LD_INT 18
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 57
5811: PUSH
5812: EMPTY
5813: LIST
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: PPUSH
5821: CALL_OW 69
5825: IFFALSE 5772
// end ; lab := kozlov_lab ;
5827: LD_ADDR_VAR 0 3
5831: PUSH
5832: LD_INT 336
5834: ST_TO_ADDR
// if not lab then
5835: LD_VAR 0 3
5839: NOT
5840: IFFALSE 5844
// exit ;
5842: GO 5969
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5844: LD_EXP 65
5848: PPUSH
5849: LD_VAR 0 3
5853: PUSH
5854: LD_INT 1
5856: ARRAY
5857: PPUSH
5858: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5862: LD_EXP 65
5866: PPUSH
5867: LD_INT 4
5869: PPUSH
5870: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 1
5881: ARRAY
5882: PPUSH
5883: LD_INT 25
5885: PPUSH
5886: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5897: LD_INT 25
5899: PPUSH
5900: LD_INT 8
5902: PPUSH
5903: CALL_OW 321
5907: PUSH
5908: LD_INT 2
5910: EQUAL
5911: IFFALSE 5890
// ComExitBuilding ( Kozlov ) ;
5913: LD_EXP 65
5917: PPUSH
5918: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5922: LD_EXP 65
5926: PPUSH
5927: LD_VAR 0 2
5931: PPUSH
5932: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5936: LD_EXP 65
5940: PPUSH
5941: LD_INT 3
5943: PPUSH
5944: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5948: LD_VAR 0 2
5952: PPUSH
5953: LD_INT 23
5955: PPUSH
5956: LD_INT 3
5958: PPUSH
5959: LD_INT 1
5961: PPUSH
5962: LD_INT 48
5964: PPUSH
5965: CALL_OW 125
// end ;
5969: LD_VAR 0 1
5973: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5974: LD_EXP 22
5978: NOT
5979: IFFALSE 5991
5981: PUSH
5982: LD_EXP 15
5986: PUSH
5987: LD_INT 6
5989: GREATEREQUAL
5990: AND
5991: IFFALSE 6072
5993: GO 5995
5995: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5996: LD_INT 3
5998: PPUSH
5999: LD_INT 3
6001: PPUSH
6002: CALL 64552 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
6006: LD_INT 3
6008: PPUSH
6009: LD_INT 14
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: LD_INT 1
6017: PUSH
6018: LD_INT 28
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_INT 14
6029: PUSH
6030: LD_INT 1
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 28
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 14
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 28
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL 64415 0 2
// end ;
6072: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6073: LD_EXP 22
6077: NOT
6078: IFFALSE 6090
6080: PUSH
6081: LD_EXP 15
6085: PUSH
6086: LD_INT 6
6088: GREATEREQUAL
6089: AND
6090: IFFALSE 6105
6092: PUSH
6093: LD_INT 3
6095: PPUSH
6096: LD_INT 1
6098: PPUSH
6099: CALL 65871 0 2
6103: NOT
6104: AND
6105: IFFALSE 7062
6107: GO 6109
6109: DISABLE
6110: LD_INT 0
6112: PPUSH
6113: PPUSH
6114: PPUSH
6115: PPUSH
// begin enable ;
6116: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6117: LD_INT 22
6119: PUSH
6120: LD_INT 8
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 23
6129: PUSH
6130: LD_INT 2
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 30
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 7062
// if Prob ( 40 ) then
6161: LD_INT 40
6163: PPUSH
6164: CALL_OW 13
6168: IFFALSE 6295
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6170: LD_INT 3
6172: PPUSH
6173: LD_INT 14
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 28
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 14
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 28
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 14
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 28
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 14
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 28
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 14
6247: PUSH
6248: LD_INT 1
6250: PUSH
6251: LD_INT 2
6253: PUSH
6254: LD_INT 28
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 14
6265: PUSH
6266: LD_INT 1
6268: PUSH
6269: LD_INT 2
6271: PUSH
6272: LD_INT 26
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL 64415 0 2
// end else
6293: GO 6502
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6295: LD_INT 3
6297: PPUSH
6298: LD_INT 14
6300: PUSH
6301: LD_INT 1
6303: PUSH
6304: LD_INT 2
6306: PUSH
6307: LD_INT 27
6309: PUSH
6310: LD_INT 26
6312: PUSH
6313: LD_INT 26
6315: PUSH
6316: LD_INT 28
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_OWVAR 67
6329: ARRAY
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 14
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 27
6348: PUSH
6349: LD_INT 26
6351: PUSH
6352: LD_INT 26
6354: PUSH
6355: LD_INT 26
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_OWVAR 67
6368: ARRAY
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 14
6378: PUSH
6379: LD_INT 1
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: LD_INT 26
6387: PUSH
6388: LD_INT 26
6390: PUSH
6391: LD_INT 29
6393: PUSH
6394: LD_INT 29
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_OWVAR 67
6407: ARRAY
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 13
6417: PUSH
6418: LD_INT 1
6420: PUSH
6421: LD_INT 2
6423: PUSH
6424: LD_INT 26
6426: PUSH
6427: LD_INT 29
6429: PUSH
6430: LD_INT 29
6432: PUSH
6433: LD_INT 29
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_OWVAR 67
6446: ARRAY
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 29
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 14
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 26
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
6502: LD_INT 4200
6504: PPUSH
6505: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6509: LD_ADDR_VAR 0 2
6513: PUSH
6514: LD_INT 22
6516: PUSH
6517: LD_INT 8
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 21
6526: PUSH
6527: LD_INT 2
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 3
6536: PUSH
6537: LD_INT 34
6539: PUSH
6540: LD_INT 31
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: LD_INT 3
6553: PUSH
6554: LD_INT 34
6556: PUSH
6557: LD_INT 32
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 34
6573: PUSH
6574: LD_INT 88
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PPUSH
6592: CALL_OW 69
6596: PUSH
6597: LD_EXP 124
6601: PUSH
6602: LD_INT 3
6604: ARRAY
6605: DIFF
6606: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6607: LD_ADDR_EXP 121
6611: PUSH
6612: LD_EXP 121
6616: PPUSH
6617: LD_INT 3
6619: PPUSH
6620: LD_EXP 121
6624: PUSH
6625: LD_INT 3
6627: ARRAY
6628: PUSH
6629: LD_VAR 0 2
6633: DIFF
6634: PPUSH
6635: CALL_OW 1
6639: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6640: LD_ADDR_VAR 0 3
6644: PUSH
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 2
6650: PPUSH
6651: CALL_OW 12
6655: ST_TO_ADDR
// if target then
6656: LD_VAR 0 3
6660: IFFALSE 6820
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6662: LD_ADDR_VAR 0 2
6666: PUSH
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 50
6674: PUSH
6675: EMPTY
6676: LIST
6677: PPUSH
6678: CALL_OW 72
6682: ST_TO_ADDR
// if not tmp then
6683: LD_VAR 0 2
6687: NOT
6688: IFFALSE 6692
// break ;
6690: GO 6818
// for i in tmp do
6692: LD_ADDR_VAR 0 1
6696: PUSH
6697: LD_VAR 0 2
6701: PUSH
6702: FOR_IN
6703: IFFALSE 6743
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6705: LD_VAR 0 1
6709: PPUSH
6710: LD_INT 89
6712: PPUSH
6713: LD_INT 71
6715: PPUSH
6716: CALL_OW 297
6720: PUSH
6721: LD_INT 9
6723: GREATER
6724: IFFALSE 6741
// ComMoveXY ( i , 89 , 71 ) ;
6726: LD_VAR 0 1
6730: PPUSH
6731: LD_INT 89
6733: PPUSH
6734: LD_INT 71
6736: PPUSH
6737: CALL_OW 111
6741: GO 6702
6743: POP
6744: POP
// wait ( 0 0$1 ) ;
6745: LD_INT 35
6747: PPUSH
6748: CALL_OW 67
// p := Inc ( p ) ;
6752: LD_ADDR_VAR 0 4
6756: PUSH
6757: LD_VAR 0 4
6761: PPUSH
6762: CALL 110468 0 1
6766: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6767: LD_VAR 0 2
6771: PPUSH
6772: LD_INT 92
6774: PUSH
6775: LD_INT 89
6777: PUSH
6778: LD_INT 71
6780: PUSH
6781: LD_INT 9
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 72
6794: PUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_INT 1
6802: MINUS
6803: GREATEREQUAL
6804: IFTRUE 6816
6806: PUSH
6807: LD_VAR 0 4
6811: PUSH
6812: LD_INT 30
6814: GREATER
6815: OR
6816: IFFALSE 6662
// end else
6818: GO 6976
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6820: LD_ADDR_VAR 0 2
6824: PUSH
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 50
6832: PUSH
6833: EMPTY
6834: LIST
6835: PPUSH
6836: CALL_OW 72
6840: ST_TO_ADDR
// if not tmp then
6841: LD_VAR 0 2
6845: NOT
6846: IFFALSE 6850
// break ;
6848: GO 6976
// for i in tmp do
6850: LD_ADDR_VAR 0 1
6854: PUSH
6855: LD_VAR 0 2
6859: PUSH
6860: FOR_IN
6861: IFFALSE 6901
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6863: LD_VAR 0 1
6867: PPUSH
6868: LD_INT 125
6870: PPUSH
6871: LD_INT 129
6873: PPUSH
6874: CALL_OW 297
6878: PUSH
6879: LD_INT 9
6881: GREATER
6882: IFFALSE 6899
// ComMoveXY ( i , 125 , 129 ) ;
6884: LD_VAR 0 1
6888: PPUSH
6889: LD_INT 125
6891: PPUSH
6892: LD_INT 129
6894: PPUSH
6895: CALL_OW 111
6899: GO 6860
6901: POP
6902: POP
// wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// p := Inc ( p ) ;
6910: LD_ADDR_VAR 0 4
6914: PUSH
6915: LD_VAR 0 4
6919: PPUSH
6920: CALL 110468 0 1
6924: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6925: LD_VAR 0 2
6929: PPUSH
6930: LD_INT 92
6932: PUSH
6933: LD_INT 125
6935: PUSH
6936: LD_INT 129
6938: PUSH
6939: LD_INT 9
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: LIST
6946: LIST
6947: PPUSH
6948: CALL_OW 72
6952: PUSH
6953: LD_VAR 0 2
6957: PUSH
6958: LD_INT 1
6960: MINUS
6961: GREATEREQUAL
6962: IFTRUE 6974
6964: PUSH
6965: LD_VAR 0 4
6969: PUSH
6970: LD_INT 30
6972: GREATER
6973: OR
6974: IFFALSE 6820
// end ; repeat wait ( 0 0$1 ) ;
6976: LD_INT 35
6978: PPUSH
6979: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6983: LD_ADDR_VAR 0 2
6987: PUSH
6988: LD_VAR 0 2
6992: PPUSH
6993: LD_INT 50
6995: PUSH
6996: EMPTY
6997: LIST
6998: PPUSH
6999: CALL_OW 72
7003: ST_TO_ADDR
// for i in tmp do
7004: LD_ADDR_VAR 0 1
7008: PUSH
7009: LD_VAR 0 2
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7053
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7017: LD_VAR 0 1
7021: PPUSH
7022: LD_INT 81
7024: PUSH
7025: LD_INT 8
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PPUSH
7032: CALL_OW 69
7036: PPUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL_OW 74
7046: PPUSH
7047: CALL_OW 115
7051: GO 7014
7053: POP
7054: POP
// until not tmp ;
7055: LD_VAR 0 2
7059: NOT
7060: IFFALSE 6976
// end ;
7062: PPOPN 4
7064: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7065: LD_EXP 22
7069: NOT
7070: IFFALSE 7082
7072: PUSH
7073: LD_EXP 15
7077: PUSH
7078: LD_INT 6
7080: GREATEREQUAL
7081: AND
7082: IFFALSE 7094
7084: PUSH
7085: LD_OWVAR 67
7089: PUSH
7090: LD_INT 1
7092: GREATER
7093: AND
7094: IFFALSE 7627
7096: GO 7098
7098: DISABLE
7099: LD_INT 0
7101: PPUSH
7102: PPUSH
7103: PPUSH
// begin enable ;
7104: ENABLE
// tmp := [ ] ;
7105: LD_ADDR_VAR 0 3
7109: PUSH
7110: EMPTY
7111: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7112: LD_ADDR_VAR 0 1
7116: PUSH
7117: DOUBLE
7118: LD_INT 1
7120: DEC
7121: ST_TO_ADDR
7122: LD_INT 4
7124: PUSH
7125: LD_INT 6
7127: PUSH
7128: LD_INT 7
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: LIST
7138: LIST
7139: PUSH
7140: LD_OWVAR 67
7144: ARRAY
7145: PUSH
7146: FOR_TO
7147: IFFALSE 7307
// begin uc_side := 8 ;
7149: LD_ADDR_OWVAR 20
7153: PUSH
7154: LD_INT 8
7156: ST_TO_ADDR
// uc_nation := 2 ;
7157: LD_ADDR_OWVAR 21
7161: PUSH
7162: LD_INT 2
7164: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7165: LD_INT 13
7167: PUSH
7168: LD_INT 14
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 1
7177: PPUSH
7178: LD_INT 2
7180: PPUSH
7181: CALL_OW 12
7185: ARRAY
7186: PPUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_INT 5
7192: PPUSH
7193: LD_INT 27
7195: PUSH
7196: LD_INT 28
7198: PUSH
7199: LD_INT 26
7201: PUSH
7202: LD_INT 25
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PUSH
7211: LD_INT 1
7213: PPUSH
7214: LD_INT 4
7216: PPUSH
7217: CALL_OW 12
7221: ARRAY
7222: PPUSH
7223: LD_INT 88
7225: PPUSH
7226: CALL 75925 0 5
// un := CreateVehicle ;
7230: LD_ADDR_VAR 0 2
7234: PUSH
7235: CALL_OW 45
7239: ST_TO_ADDR
// tmp := tmp ^ un ;
7240: LD_ADDR_VAR 0 3
7244: PUSH
7245: LD_VAR 0 3
7249: PUSH
7250: LD_VAR 0 2
7254: ADD
7255: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7256: LD_VAR 0 2
7260: PPUSH
7261: LD_INT 3
7263: PPUSH
7264: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7268: LD_VAR 0 2
7272: PPUSH
7273: LD_INT 30
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 16
7290: PPUSH
7291: LD_INT 11
7293: PPUSH
7294: CALL_OW 111
// wait ( 0 0$2 ) ;
7298: LD_INT 70
7300: PPUSH
7301: CALL_OW 67
// end ;
7305: GO 7146
7307: POP
7308: POP
// for i = 1 to Difficulty do
7309: LD_ADDR_VAR 0 1
7313: PUSH
7314: DOUBLE
7315: LD_INT 1
7317: DEC
7318: ST_TO_ADDR
7319: LD_OWVAR 67
7323: PUSH
7324: FOR_TO
7325: IFFALSE 7454
// begin uc_side := 8 ;
7327: LD_ADDR_OWVAR 20
7331: PUSH
7332: LD_INT 8
7334: ST_TO_ADDR
// uc_nation := 2 ;
7335: LD_ADDR_OWVAR 21
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7343: LD_INT 0
7345: PPUSH
7346: LD_INT 8
7348: PPUSH
7349: LD_INT 8
7351: PUSH
7352: LD_INT 8
7354: PUSH
7355: LD_INT 9
7357: PUSH
7358: LD_INT 10
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_OWVAR 67
7371: ARRAY
7372: PPUSH
7373: CALL_OW 380
// un := CreateHuman ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: CALL_OW 44
7386: ST_TO_ADDR
// tmp := tmp ^ un ;
7387: LD_ADDR_VAR 0 3
7391: PUSH
7392: LD_VAR 0 3
7396: PUSH
7397: LD_VAR 0 2
7401: ADD
7402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7403: LD_VAR 0 2
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7415: LD_VAR 0 2
7419: PPUSH
7420: LD_INT 30
7422: PPUSH
7423: LD_INT 0
7425: PPUSH
7426: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7430: LD_VAR 0 2
7434: PPUSH
7435: LD_INT 16
7437: PPUSH
7438: LD_INT 11
7440: PPUSH
7441: CALL_OW 111
// wait ( 0 0$2 ) ;
7445: LD_INT 70
7447: PPUSH
7448: CALL_OW 67
// end ;
7452: GO 7324
7454: POP
7455: POP
// repeat wait ( 0 0$1 ) ;
7456: LD_INT 35
7458: PPUSH
7459: CALL_OW 67
// if legionDestroyed then
7463: LD_EXP 22
7467: IFFALSE 7471
// exit ;
7469: GO 7627
// for i in tmp do
7471: LD_ADDR_VAR 0 1
7475: PUSH
7476: LD_VAR 0 3
7480: PUSH
7481: FOR_IN
7482: IFFALSE 7618
// begin if GetLives ( i ) > 250 then
7484: LD_VAR 0 1
7488: PPUSH
7489: CALL_OW 256
7493: PUSH
7494: LD_INT 250
7496: GREATER
7497: IFFALSE 7589
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7499: LD_INT 81
7501: PUSH
7502: LD_INT 8
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 91
7511: PUSH
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 10
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PPUSH
7529: CALL_OW 69
7533: NOT
7534: IFFALSE 7553
// ComAgressiveMove ( i , 67 , 110 ) else
7536: LD_VAR 0 1
7540: PPUSH
7541: LD_INT 67
7543: PPUSH
7544: LD_INT 110
7546: PPUSH
7547: CALL_OW 114
7551: GO 7587
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7553: LD_VAR 0 1
7557: PPUSH
7558: LD_INT 81
7560: PUSH
7561: LD_INT 8
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PPUSH
7568: CALL_OW 69
7572: PPUSH
7573: LD_VAR 0 1
7577: PPUSH
7578: CALL_OW 74
7582: PPUSH
7583: CALL_OW 115
// end else
7587: GO 7616
// if IsDead ( i ) then
7589: LD_VAR 0 1
7593: PPUSH
7594: CALL_OW 301
7598: IFFALSE 7616
// tmp := tmp diff i ;
7600: LD_ADDR_VAR 0 3
7604: PUSH
7605: LD_VAR 0 3
7609: PUSH
7610: LD_VAR 0 1
7614: DIFF
7615: ST_TO_ADDR
// end ;
7616: GO 7481
7618: POP
7619: POP
// until not tmp ;
7620: LD_VAR 0 3
7624: NOT
7625: IFFALSE 7456
// end ; end_of_file
7627: PPOPN 3
7629: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7630: LD_INT 0
7632: PPUSH
7633: PPUSH
7634: PPUSH
7635: PPUSH
7636: PPUSH
7637: PPUSH
7638: PPUSH
7639: PPUSH
7640: PPUSH
7641: PPUSH
// side := 3 ;
7642: LD_ADDR_VAR 0 6
7646: PUSH
7647: LD_INT 3
7649: ST_TO_ADDR
// uc_side := side ;
7650: LD_ADDR_OWVAR 20
7654: PUSH
7655: LD_VAR 0 6
7659: ST_TO_ADDR
// uc_nation := 3 ;
7660: LD_ADDR_OWVAR 21
7664: PUSH
7665: LD_INT 3
7667: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: LD_INT 22
7675: PUSH
7676: LD_VAR 0 6
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 21
7687: PUSH
7688: LD_INT 3
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: PPUSH
7699: CALL_OW 69
7703: PUSH
7704: FOR_IN
7705: IFFALSE 7721
// SetBLevel ( i , 10 ) ;
7707: LD_VAR 0 2
7711: PPUSH
7712: LD_INT 10
7714: PPUSH
7715: CALL_OW 241
7719: GO 7704
7721: POP
7722: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7723: LD_ADDR_VAR 0 10
7727: PUSH
7728: LD_INT 22
7730: PUSH
7731: LD_VAR 0 6
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 34
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PPUSH
7754: CALL_OW 69
7758: ST_TO_ADDR
// if teleport then
7759: LD_VAR 0 10
7763: IFFALSE 7784
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7765: LD_VAR 0 10
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_INT 123
7776: PPUSH
7777: LD_INT 122
7779: PPUSH
7780: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7784: LD_ADDR_EXP 68
7788: PUSH
7789: LD_STRING Platonov
7791: PPUSH
7792: CALL_OW 25
7796: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7797: LD_ADDR_EXP 69
7801: PUSH
7802: LD_STRING Kovalyuk
7804: PPUSH
7805: CALL_OW 25
7809: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7810: LD_ADDR_EXP 71
7814: PUSH
7815: LD_STRING Yakotich
7817: PPUSH
7818: LD_EXP 1
7822: NOT
7823: PPUSH
7824: LD_STRING 09_
7826: PPUSH
7827: CALL 70939 0 3
7831: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7832: LD_ADDR_EXP 70
7836: PUSH
7837: LD_STRING Bystrov
7839: PPUSH
7840: CALL_OW 25
7844: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7845: LD_ADDR_EXP 72
7849: PUSH
7850: LD_STRING Gleb
7852: PPUSH
7853: CALL_OW 25
7857: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7858: LD_STRING 03_Cornel
7860: PPUSH
7861: CALL_OW 28
7865: IFFALSE 7913
// begin Bierezov := NewCharacter ( Mikhail ) ;
7867: LD_ADDR_EXP 73
7871: PUSH
7872: LD_STRING Mikhail
7874: PPUSH
7875: CALL_OW 25
7879: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7880: LD_EXP 73
7884: PPUSH
7885: LD_INT 197
7887: PPUSH
7888: LD_INT 111
7890: PPUSH
7891: LD_INT 9
7893: PPUSH
7894: LD_INT 0
7896: PPUSH
7897: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7901: LD_EXP 73
7905: PPUSH
7906: LD_INT 3
7908: PPUSH
7909: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7913: LD_EXP 68
7917: PPUSH
7918: LD_INT 126
7920: PPUSH
7921: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7925: LD_EXP 69
7929: PPUSH
7930: LD_INT 134
7932: PPUSH
7933: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7937: LD_EXP 71
7941: PPUSH
7942: LD_INT 197
7944: PPUSH
7945: LD_INT 111
7947: PPUSH
7948: LD_INT 9
7950: PPUSH
7951: LD_INT 0
7953: PPUSH
7954: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7958: LD_EXP 70
7962: PPUSH
7963: LD_INT 197
7965: PPUSH
7966: LD_INT 111
7968: PPUSH
7969: LD_INT 9
7971: PPUSH
7972: LD_INT 0
7974: PPUSH
7975: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7979: LD_EXP 72
7983: PPUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 111
7989: PPUSH
7990: LD_INT 9
7992: PPUSH
7993: LD_INT 0
7995: PPUSH
7996: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
8000: LD_ADDR_VAR 0 5
8004: PUSH
8005: LD_INT 126
8007: PPUSH
8008: LD_INT 4
8010: PPUSH
8011: LD_STRING zhukov
8013: PPUSH
8014: LD_INT 9
8016: PUSH
8017: LD_INT 10
8019: PUSH
8020: LD_INT 10
8022: PUSH
8023: LD_INT 10
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: PUSH
8032: LD_OWVAR 67
8036: ARRAY
8037: PPUSH
8038: LD_INT 90000
8040: PUSH
8041: LD_INT 1000
8043: PUSH
8044: LD_INT 300
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PPUSH
8052: LD_INT 18
8054: PUSH
8055: LD_INT 8
8057: PUSH
8058: LD_INT 12
8060: PUSH
8061: LD_INT 6
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: PPUSH
8070: CALL 79762 0 6
8074: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8075: LD_ADDR_EXP 102
8079: PUSH
8080: LD_EXP 102
8084: PPUSH
8085: LD_INT 2
8087: PPUSH
8088: LD_VAR 0 5
8092: PUSH
8093: LD_EXP 71
8097: PUSH
8098: LD_EXP 70
8102: PUSH
8103: LD_EXP 72
8107: PUSH
8108: LD_EXP 73
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: LIST
8117: LIST
8118: UNION
8119: PPUSH
8120: CALL_OW 1
8124: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8125: LD_ADDR_VAR 0 4
8129: PUSH
8130: LD_INT 267
8132: PPUSH
8133: CALL_OW 274
8137: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8138: LD_VAR 0 4
8142: PPUSH
8143: LD_INT 1
8145: PPUSH
8146: LD_INT 5000
8148: PPUSH
8149: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8153: LD_VAR 0 4
8157: PPUSH
8158: LD_INT 2
8160: PPUSH
8161: LD_INT 200
8163: PPUSH
8164: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8168: LD_VAR 0 4
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 200
8178: PPUSH
8179: CALL_OW 277
// for i := 1 to 6 do
8183: LD_ADDR_VAR 0 2
8187: PUSH
8188: DOUBLE
8189: LD_INT 1
8191: DEC
8192: ST_TO_ADDR
8193: LD_INT 6
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8280
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8199: LD_INT 0
8201: PPUSH
8202: LD_INT 8
8204: PUSH
8205: LD_INT 9
8207: PUSH
8208: LD_INT 10
8210: PUSH
8211: LD_INT 10
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: PUSH
8220: LD_OWVAR 67
8224: ARRAY
8225: PPUSH
8226: CALL_OW 381
// un := CreateHuman ;
8230: LD_ADDR_VAR 0 8
8234: PUSH
8235: CALL_OW 44
8239: ST_TO_ADDR
// if i mod 2 = 0 then
8240: LD_VAR 0 2
8244: PUSH
8245: LD_INT 2
8247: MOD
8248: PUSH
8249: LD_INT 0
8251: EQUAL
8252: IFFALSE 8266
// SetClass ( un , class_bazooker ) ;
8254: LD_VAR 0 8
8258: PPUSH
8259: LD_INT 9
8261: PPUSH
8262: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8266: LD_VAR 0 8
8270: PPUSH
8271: LD_INT 460
8273: PPUSH
8274: CALL_OW 52
// end ;
8278: GO 8196
8280: POP
8281: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8282: LD_INT 21
8284: PPUSH
8285: LD_INT 3
8287: PPUSH
8288: LD_INT 3
8290: PPUSH
8291: LD_INT 52
8293: PPUSH
8294: LD_INT 100
8296: PPUSH
8297: CALL 75925 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8301: CALL_OW 45
8305: PPUSH
8306: LD_INT 259
8308: PPUSH
8309: LD_INT 145
8311: PPUSH
8312: LD_INT 3
8314: PPUSH
8315: LD_INT 0
8317: PPUSH
8318: CALL 111255 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8322: CALL_OW 45
8326: PPUSH
8327: LD_INT 245
8329: PPUSH
8330: LD_INT 139
8332: PPUSH
8333: LD_INT 3
8335: PPUSH
8336: LD_INT 0
8338: PPUSH
8339: CALL 111255 0 5
// behemoths := [ ] ;
8343: LD_ADDR_EXP 76
8347: PUSH
8348: EMPTY
8349: ST_TO_ADDR
// behemothBuilders := [ ] ;
8350: LD_ADDR_EXP 77
8354: PUSH
8355: EMPTY
8356: ST_TO_ADDR
// if Kovalyuk then
8357: LD_EXP 69
8361: IFFALSE 8383
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8363: LD_ADDR_EXP 77
8367: PUSH
8368: LD_EXP 77
8372: PPUSH
8373: LD_EXP 69
8377: PPUSH
8378: CALL 109095 0 2
8382: ST_TO_ADDR
// end ;
8383: LD_VAR 0 1
8387: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8388: LD_INT 0
8390: PPUSH
8391: PPUSH
8392: PPUSH
8393: PPUSH
8394: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8395: LD_ADDR_VAR 0 4
8399: PUSH
8400: LD_INT 221
8402: PUSH
8403: LD_INT 154
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 223
8412: PUSH
8413: LD_INT 149
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 228
8422: PUSH
8423: LD_INT 147
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: LD_INT 232
8432: PUSH
8433: LD_INT 155
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: LIST
8444: LIST
8445: ST_TO_ADDR
// if not behemothBuilders then
8446: LD_EXP 77
8450: NOT
8451: IFFALSE 8455
// exit ;
8453: GO 8586
// j := 1 ;
8455: LD_ADDR_VAR 0 3
8459: PUSH
8460: LD_INT 1
8462: ST_TO_ADDR
// for i in behemothBuilders do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_EXP 77
8472: PUSH
8473: FOR_IN
8474: IFFALSE 8584
// begin if GetClass ( i ) <> class_mechanic then
8476: LD_VAR 0 2
8480: PPUSH
8481: CALL_OW 257
8485: PUSH
8486: LD_INT 3
8488: NONEQUAL
8489: IFFALSE 8503
// SetClass ( i , class_mechanic ) ;
8491: LD_VAR 0 2
8495: PPUSH
8496: LD_INT 3
8498: PPUSH
8499: CALL_OW 336
// if IsInUnit ( i ) then
8503: LD_VAR 0 2
8507: PPUSH
8508: CALL_OW 310
8512: IFFALSE 8523
// ComExitBuilding ( i ) ;
8514: LD_VAR 0 2
8518: PPUSH
8519: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_INT 37
8530: PPUSH
8531: LD_VAR 0 4
8535: PUSH
8536: LD_VAR 0 3
8540: ARRAY
8541: PUSH
8542: LD_INT 1
8544: ARRAY
8545: PPUSH
8546: LD_VAR 0 4
8550: PUSH
8551: LD_VAR 0 3
8555: ARRAY
8556: PUSH
8557: LD_INT 2
8559: ARRAY
8560: PPUSH
8561: LD_INT 0
8563: PPUSH
8564: CALL_OW 230
// j := j + 1 ;
8568: LD_ADDR_VAR 0 3
8572: PUSH
8573: LD_VAR 0 3
8577: PUSH
8578: LD_INT 1
8580: PLUS
8581: ST_TO_ADDR
// end ;
8582: GO 8473
8584: POP
8585: POP
// end ;
8586: LD_VAR 0 1
8590: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8591: LD_INT 24
8593: PPUSH
8594: LD_INT 30
8596: PUSH
8597: LD_INT 37
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PPUSH
8604: CALL_OW 70
8608: IFFALSE 8621
8610: GO 8612
8612: DISABLE
// behemothUnderConstruct := true ;
8613: LD_ADDR_EXP 26
8617: PUSH
8618: LD_INT 1
8620: ST_TO_ADDR
8621: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8622: LD_INT 3
8624: PPUSH
8625: CALL 109156 0 1
8629: IFFALSE 8662
8631: PUSH
8632: LD_INT 22
8634: PUSH
8635: LD_INT 3
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 37
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PPUSH
8656: CALL_OW 69
8660: NOT
8661: AND
8662: IFFALSE 8852
8664: GO 8666
8666: DISABLE
8667: LD_INT 0
8669: PPUSH
8670: PPUSH
// begin enable ;
8671: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_INT 3
8679: PPUSH
8680: CALL 109156 0 1
8684: ST_TO_ADDR
// for i in tmp do
8685: LD_ADDR_VAR 0 1
8689: PUSH
8690: LD_VAR 0 2
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8850
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8698: LD_VAR 0 1
8702: PPUSH
8703: LD_INT 9
8705: PPUSH
8706: CALL_OW 308
8710: IFFALSE 8728
8712: PUSH
8713: LD_VAR 0 1
8717: PPUSH
8718: CALL_OW 110
8722: PUSH
8723: LD_INT 2
8725: EQUAL
8726: NOT
8727: AND
8728: IFFALSE 8742
// SetTag ( i , 2 ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_INT 2
8737: PPUSH
8738: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8742: LD_INT 81
8744: PUSH
8745: LD_INT 3
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PUSH
8752: LD_INT 91
8754: PUSH
8755: LD_VAR 0 1
8759: PUSH
8760: LD_INT 12
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL_OW 69
8776: NOT
8777: IFFALSE 8795
8779: PUSH
8780: LD_VAR 0 1
8784: PPUSH
8785: CALL_OW 110
8789: PUSH
8790: LD_INT 2
8792: EQUAL
8793: NOT
8794: AND
8795: IFFALSE 8814
// ComAgressiveMove ( i , 64 , 93 ) else
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_INT 64
8804: PPUSH
8805: LD_INT 93
8807: PPUSH
8808: CALL_OW 114
8812: GO 8848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8814: LD_VAR 0 1
8818: PPUSH
8819: LD_INT 81
8821: PUSH
8822: LD_INT 3
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 74
8843: PPUSH
8844: CALL_OW 115
// end ;
8848: GO 8695
8850: POP
8851: POP
// end ;
8852: PPOPN 2
8854: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8855: LD_INT 0
8857: PPUSH
8858: PPUSH
8859: PPUSH
// result := [ ] ;
8860: LD_ADDR_VAR 0 2
8864: PUSH
8865: EMPTY
8866: ST_TO_ADDR
// uc_side := 6 ;
8867: LD_ADDR_OWVAR 20
8871: PUSH
8872: LD_INT 6
8874: ST_TO_ADDR
// uc_nation := 3 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 3
8882: ST_TO_ADDR
// case strength of 1 :
8883: LD_VAR 0 1
8887: PUSH
8888: LD_INT 1
8890: DOUBLE
8891: EQUAL
8892: IFTRUE 8896
8894: GO 9038
8896: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8897: LD_ADDR_VAR 0 3
8901: PUSH
8902: DOUBLE
8903: LD_INT 1
8905: DEC
8906: ST_TO_ADDR
8907: LD_INT 4
8909: PUSH
8910: LD_INT 5
8912: PUSH
8913: LD_INT 6
8915: PUSH
8916: LD_INT 7
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_OWVAR 67
8929: ARRAY
8930: PUSH
8931: FOR_TO
8932: IFFALSE 9034
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8934: LD_INT 22
8936: PUSH
8937: LD_INT 24
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 2
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 1
8960: PUSH
8961: LD_INT 3
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: LD_INT 1
8970: PPUSH
8971: LD_INT 2
8973: PPUSH
8974: CALL_OW 12
8978: ARRAY
8979: PPUSH
8980: LD_INT 3
8982: PPUSH
8983: LD_INT 43
8985: PUSH
8986: LD_INT 44
8988: PUSH
8989: LD_INT 45
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: LIST
8996: PUSH
8997: LD_INT 1
8999: PPUSH
9000: LD_INT 3
9002: PPUSH
9003: CALL_OW 12
9007: ARRAY
9008: PPUSH
9009: LD_INT 80
9011: PPUSH
9012: CALL 75925 0 5
// result := result union CreateVehicle ;
9016: LD_ADDR_VAR 0 2
9020: PUSH
9021: LD_VAR 0 2
9025: PUSH
9026: CALL_OW 45
9030: UNION
9031: ST_TO_ADDR
// end ;
9032: GO 8931
9034: POP
9035: POP
// end ; 2 :
9036: GO 10033
9038: LD_INT 2
9040: DOUBLE
9041: EQUAL
9042: IFTRUE 9046
9044: GO 9214
9046: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9047: LD_ADDR_VAR 0 3
9051: PUSH
9052: DOUBLE
9053: LD_INT 1
9055: DEC
9056: ST_TO_ADDR
9057: LD_INT 5
9059: PUSH
9060: LD_INT 6
9062: PUSH
9063: LD_INT 7
9065: PUSH
9066: LD_INT 8
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: PUSH
9075: LD_OWVAR 67
9079: ARRAY
9080: PUSH
9081: FOR_TO
9082: IFFALSE 9210
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9084: LD_INT 22
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 24
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: PUSH
9098: LD_VAR 0 3
9102: PUSH
9103: LD_INT 3
9105: MOD
9106: PUSH
9107: LD_INT 1
9109: PLUS
9110: ARRAY
9111: PPUSH
9112: LD_INT 1
9114: PUSH
9115: LD_INT 3
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 1
9124: PPUSH
9125: LD_INT 2
9127: PPUSH
9128: CALL_OW 12
9132: ARRAY
9133: PPUSH
9134: LD_INT 3
9136: PPUSH
9137: LD_INT 43
9139: PUSH
9140: LD_INT 44
9142: PUSH
9143: LD_INT 45
9145: PUSH
9146: LD_INT 44
9148: PUSH
9149: LD_INT 46
9151: PUSH
9152: LD_INT 46
9154: PUSH
9155: LD_INT 49
9157: PUSH
9158: LD_INT 49
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: PUSH
9171: LD_VAR 0 3
9175: PUSH
9176: LD_INT 8
9178: MOD
9179: PUSH
9180: LD_INT 1
9182: PLUS
9183: ARRAY
9184: PPUSH
9185: LD_INT 80
9187: PPUSH
9188: CALL 75925 0 5
// result := result union CreateVehicle ;
9192: LD_ADDR_VAR 0 2
9196: PUSH
9197: LD_VAR 0 2
9201: PUSH
9202: CALL_OW 45
9206: UNION
9207: ST_TO_ADDR
// end ;
9208: GO 9081
9210: POP
9211: POP
// end ; 3 :
9212: GO 10033
9214: LD_INT 3
9216: DOUBLE
9217: EQUAL
9218: IFTRUE 9222
9220: GO 9394
9222: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 6
9235: PUSH
9236: LD_INT 7
9238: PUSH
9239: LD_INT 8
9241: PUSH
9242: LD_INT 9
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: PUSH
9251: LD_OWVAR 67
9255: ARRAY
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9390
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9260: LD_INT 22
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: LD_INT 24
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: LD_VAR 0 3
9278: PUSH
9279: LD_INT 3
9281: MOD
9282: PUSH
9283: LD_INT 1
9285: PLUS
9286: ARRAY
9287: PPUSH
9288: LD_INT 1
9290: PUSH
9291: LD_INT 3
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PUSH
9298: LD_INT 1
9300: PPUSH
9301: LD_INT 2
9303: PPUSH
9304: CALL_OW 12
9308: ARRAY
9309: PPUSH
9310: LD_INT 3
9312: PPUSH
9313: LD_INT 43
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: LD_INT 45
9321: PUSH
9322: LD_INT 45
9324: PUSH
9325: LD_INT 46
9327: PUSH
9328: LD_INT 46
9330: PUSH
9331: LD_INT 49
9333: PUSH
9334: LD_INT 49
9336: PUSH
9337: LD_INT 49
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 9
9358: MOD
9359: PUSH
9360: LD_INT 1
9362: PLUS
9363: ARRAY
9364: PPUSH
9365: LD_INT 80
9367: PPUSH
9368: CALL 75925 0 5
// result := result union CreateVehicle ;
9372: LD_ADDR_VAR 0 2
9376: PUSH
9377: LD_VAR 0 2
9381: PUSH
9382: CALL_OW 45
9386: UNION
9387: ST_TO_ADDR
// end ;
9388: GO 9257
9390: POP
9391: POP
// end ; 4 :
9392: GO 10033
9394: LD_INT 4
9396: DOUBLE
9397: EQUAL
9398: IFTRUE 9402
9400: GO 10032
9402: POP
// begin uc_nation := 3 ;
9403: LD_ADDR_OWVAR 21
9407: PUSH
9408: LD_INT 3
9410: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9411: LD_ADDR_VAR 0 3
9415: PUSH
9416: DOUBLE
9417: LD_INT 1
9419: DEC
9420: ST_TO_ADDR
9421: LD_INT 6
9423: PUSH
9424: LD_INT 8
9426: PUSH
9427: LD_INT 9
9429: PUSH
9430: LD_INT 10
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: PUSH
9439: LD_OWVAR 67
9443: ARRAY
9444: PUSH
9445: FOR_TO
9446: IFFALSE 9578
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9448: LD_INT 22
9450: PUSH
9451: LD_INT 24
9453: PUSH
9454: LD_INT 24
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: LIST
9461: PUSH
9462: LD_VAR 0 3
9466: PUSH
9467: LD_INT 3
9469: MOD
9470: PUSH
9471: LD_INT 1
9473: PLUS
9474: ARRAY
9475: PPUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 3
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 2
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 45
9503: PUSH
9504: LD_INT 47
9506: PUSH
9507: LD_INT 47
9509: PUSH
9510: LD_INT 45
9512: PUSH
9513: LD_INT 46
9515: PUSH
9516: LD_INT 46
9518: PUSH
9519: LD_INT 49
9521: PUSH
9522: LD_INT 49
9524: PUSH
9525: LD_INT 49
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: PUSH
9539: LD_VAR 0 3
9543: PUSH
9544: LD_INT 9
9546: MOD
9547: PUSH
9548: LD_INT 1
9550: PLUS
9551: ARRAY
9552: PPUSH
9553: LD_INT 80
9555: PPUSH
9556: CALL 75925 0 5
// result := result union CreateVehicle ;
9560: LD_ADDR_VAR 0 2
9564: PUSH
9565: LD_VAR 0 2
9569: PUSH
9570: CALL_OW 45
9574: UNION
9575: ST_TO_ADDR
// end ;
9576: GO 9445
9578: POP
9579: POP
// if not KappaStatus then
9580: LD_EXP 2
9584: NOT
9585: IFFALSE 9820
// begin uc_nation := 1 ;
9587: LD_ADDR_OWVAR 21
9591: PUSH
9592: LD_INT 1
9594: ST_TO_ADDR
// for i = 1 to 3 do
9595: LD_ADDR_VAR 0 3
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_INT 3
9607: PUSH
9608: FOR_TO
9609: IFFALSE 9745
// begin j := rand ( 0 , 1 ) ;
9611: LD_ADDR_VAR 0 4
9615: PUSH
9616: LD_INT 0
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9627: LD_INT 3
9629: PUSH
9630: LD_INT 5
9632: PUSH
9633: LD_INT 5
9635: PUSH
9636: LD_INT 4
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_VAR 0 4
9649: PUSH
9650: LD_INT 1
9652: PPUSH
9653: LD_INT 3
9655: PPUSH
9656: CALL_OW 12
9660: PLUS
9661: ARRAY
9662: PPUSH
9663: LD_INT 1
9665: PUSH
9666: LD_INT 3
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 2
9678: PPUSH
9679: CALL_OW 12
9683: ARRAY
9684: PPUSH
9685: LD_INT 3
9687: PPUSH
9688: LD_INT 9
9690: PUSH
9691: LD_INT 7
9693: PUSH
9694: LD_INT 6
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PUSH
9702: LD_VAR 0 4
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 2
9712: PPUSH
9713: CALL_OW 12
9717: PLUS
9718: ARRAY
9719: PPUSH
9720: LD_INT 85
9722: PPUSH
9723: CALL 75925 0 5
// result := result union CreateVehicle ;
9727: LD_ADDR_VAR 0 2
9731: PUSH
9732: LD_VAR 0 2
9736: PUSH
9737: CALL_OW 45
9741: UNION
9742: ST_TO_ADDR
// end ;
9743: GO 9608
9745: POP
9746: POP
// if vsevolodFirstAttack then
9747: LD_EXP 24
9751: IFFALSE 9818
// begin vsevolodFirstAttack := false ;
9753: LD_ADDR_EXP 24
9757: PUSH
9758: LD_INT 0
9760: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9761: LD_INT 5
9763: PPUSH
9764: LD_INT 3
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 100
9775: PPUSH
9776: CALL 75925 0 5
// sewiVeh := CreateVehicle ;
9780: LD_ADDR_EXP 75
9784: PUSH
9785: CALL_OW 45
9789: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9790: LD_EXP 75
9794: PPUSH
9795: LD_INT 1
9797: PPUSH
9798: CALL_OW 242
// result := result union sewiVeh ;
9802: LD_ADDR_VAR 0 2
9806: PUSH
9807: LD_VAR 0 2
9811: PUSH
9812: LD_EXP 75
9816: UNION
9817: ST_TO_ADDR
// end ; end else
9818: GO 10030
// if vsevolodFirstAttack then
9820: LD_EXP 24
9824: IFFALSE 10030
// begin vsevolodFirstAttack := false ;
9826: LD_ADDR_EXP 24
9830: PUSH
9831: LD_INT 0
9833: ST_TO_ADDR
// uc_nation := 3 ;
9834: LD_ADDR_OWVAR 21
9838: PUSH
9839: LD_INT 3
9841: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9842: LD_ADDR_VAR 0 3
9846: PUSH
9847: DOUBLE
9848: LD_INT 1
9850: DEC
9851: ST_TO_ADDR
9852: LD_INT 2
9854: PUSH
9855: LD_OWVAR 67
9859: PLUS
9860: PUSH
9861: FOR_TO
9862: IFFALSE 9970
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9864: LD_INT 22
9866: PUSH
9867: LD_INT 24
9869: PUSH
9870: LD_INT 24
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: LIST
9877: PUSH
9878: LD_VAR 0 3
9882: PUSH
9883: LD_INT 3
9885: MOD
9886: PUSH
9887: LD_INT 1
9889: PLUS
9890: ARRAY
9891: PPUSH
9892: LD_INT 1
9894: PUSH
9895: LD_INT 3
9897: PUSH
9898: EMPTY
9899: LIST
9900: LIST
9901: PUSH
9902: LD_INT 1
9904: PPUSH
9905: LD_INT 2
9907: PPUSH
9908: CALL_OW 12
9912: ARRAY
9913: PPUSH
9914: LD_INT 1
9916: PPUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 47
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: LIST
9930: PUSH
9931: LD_VAR 0 3
9935: PUSH
9936: LD_INT 3
9938: MOD
9939: PUSH
9940: LD_INT 1
9942: PLUS
9943: ARRAY
9944: PPUSH
9945: LD_INT 80
9947: PPUSH
9948: CALL 75925 0 5
// result := result union CreateVehicle ;
9952: LD_ADDR_VAR 0 2
9956: PUSH
9957: LD_VAR 0 2
9961: PUSH
9962: CALL_OW 45
9966: UNION
9967: ST_TO_ADDR
// end ;
9968: GO 9861
9970: POP
9971: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9972: LD_INT 24
9974: PPUSH
9975: LD_INT 3
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: LD_INT 47
9983: PPUSH
9984: LD_INT 100
9986: PPUSH
9987: CALL 75925 0 5
// sewiVeh := CreateVehicle ;
9991: LD_ADDR_EXP 75
9995: PUSH
9996: CALL_OW 45
10000: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
10001: LD_EXP 75
10005: PPUSH
10006: LD_INT 6
10008: NEG
10009: PPUSH
10010: CALL_OW 242
// result := result union sewiVeh ;
10014: LD_ADDR_VAR 0 2
10018: PUSH
10019: LD_VAR 0 2
10023: PUSH
10024: LD_EXP 75
10028: UNION
10029: ST_TO_ADDR
// end ; end ; end ;
10030: GO 10033
10032: POP
// end ;
10033: LD_VAR 0 2
10037: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10038: LD_EXP 16
10042: IFFALSE 10803
10044: GO 10046
10046: DISABLE
10047: LD_INT 0
10049: PPUSH
10050: PPUSH
10051: PPUSH
10052: PPUSH
10053: PPUSH
10054: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10055: LD_ADDR_VAR 0 4
10059: PUSH
10060: LD_INT 11
10062: PUSH
10063: LD_INT 12
10065: PUSH
10066: EMPTY
10067: LIST
10068: LIST
10069: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10070: LD_ADDR_VAR 0 3
10074: PUSH
10075: LD_INT 11550
10077: PUSH
10078: LD_INT 10150
10080: PUSH
10081: LD_INT 9800
10083: PUSH
10084: LD_INT 9450
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_OWVAR 67
10097: ARRAY
10098: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10099: LD_ADDR_VAR 0 6
10103: PUSH
10104: LD_INT 70
10106: PUSH
10107: LD_INT 118
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 78
10116: PUSH
10117: LD_INT 31
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: PUSH
10124: EMPTY
10125: LIST
10126: LIST
10127: ST_TO_ADDR
// repeat if missionStage = 2 then
10128: LD_EXP 15
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10147
// wait ( 1 1$30 ) else
10138: LD_INT 3150
10140: PPUSH
10141: CALL_OW 67
10145: GO 10156
// wait ( time ) ;
10147: LD_VAR 0 3
10151: PPUSH
10152: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10156: LD_EXP 15
10160: PUSH
10161: LD_INT 6
10163: EQUAL
10164: IFTRUE 10176
10166: PUSH
10167: LD_OWVAR 67
10171: PUSH
10172: LD_INT 2
10174: GREATER
10175: OR
10176: IFFALSE 10204
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10178: LD_INT 51
10180: PPUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 2
10186: PPUSH
10187: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10191: LD_INT 57
10193: PPUSH
10194: LD_INT 6
10196: PPUSH
10197: LD_INT 2
10199: PPUSH
10200: CALL_OW 322
// end ; if missionStage = 8 then
10204: LD_EXP 15
10208: PUSH
10209: LD_INT 8
10211: EQUAL
10212: IFFALSE 10240
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10214: LD_INT 52
10216: PPUSH
10217: LD_INT 6
10219: PPUSH
10220: LD_INT 2
10222: PPUSH
10223: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10227: LD_INT 58
10229: PPUSH
10230: LD_INT 6
10232: PPUSH
10233: LD_INT 2
10235: PPUSH
10236: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 4
10247: EQUAL
10248: IFTRUE 10260
10250: PUSH
10251: LD_EXP 15
10255: PUSH
10256: LD_INT 10
10258: EQUAL
10259: OR
10260: IFFALSE 10288
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10262: LD_INT 53
10264: PPUSH
10265: LD_INT 6
10267: PPUSH
10268: LD_INT 2
10270: PPUSH
10271: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10275: LD_INT 59
10277: PPUSH
10278: LD_INT 6
10280: PPUSH
10281: LD_INT 2
10283: PPUSH
10284: CALL_OW 322
// end ; if activeAttacks then
10288: LD_EXP 16
10292: IFFALSE 10797
// begin if missionStage = 2 then
10294: LD_EXP 15
10298: PUSH
10299: LD_INT 2
10301: EQUAL
10302: IFFALSE 10312
// strength := 1 ;
10304: LD_ADDR_VAR 0 5
10308: PUSH
10309: LD_INT 1
10311: ST_TO_ADDR
// if missionStage > 2 then
10312: LD_EXP 15
10316: PUSH
10317: LD_INT 2
10319: GREATER
10320: IFFALSE 10330
// strength := 2 ;
10322: LD_ADDR_VAR 0 5
10326: PUSH
10327: LD_INT 2
10329: ST_TO_ADDR
// if missionStage > 6 then
10330: LD_EXP 15
10334: PUSH
10335: LD_INT 6
10337: GREATER
10338: IFFALSE 10348
// strength := 3 ;
10340: LD_ADDR_VAR 0 5
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// if missionStage > 10 then
10348: LD_EXP 15
10352: PUSH
10353: LD_INT 10
10355: GREATER
10356: IFFALSE 10366
// strength := 4 ;
10358: LD_ADDR_VAR 0 5
10362: PUSH
10363: LD_INT 4
10365: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10366: LD_ADDR_VAR 0 2
10370: PUSH
10371: LD_VAR 0 5
10375: PPUSH
10376: CALL 8855 0 1
10380: ST_TO_ADDR
// for i in tmp do
10381: LD_ADDR_VAR 0 1
10385: PUSH
10386: LD_VAR 0 2
10390: PUSH
10391: FOR_IN
10392: IFFALSE 10666
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_VAR 0 4
10403: PUSH
10404: LD_INT 1
10406: PPUSH
10407: LD_INT 2
10409: PPUSH
10410: CALL_OW 12
10414: ARRAY
10415: PPUSH
10416: LD_INT 0
10418: PPUSH
10419: CALL_OW 49
// if i = sewiVeh then
10423: LD_VAR 0 1
10427: PUSH
10428: LD_EXP 75
10432: EQUAL
10433: IFFALSE 10486
// begin uc_side := 6 ;
10435: LD_ADDR_OWVAR 20
10439: PUSH
10440: LD_INT 6
10442: ST_TO_ADDR
// uc_nation := nation_russian ;
10443: LD_ADDR_OWVAR 21
10447: PUSH
10448: LD_INT 3
10450: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10451: LD_ADDR_EXP 74
10455: PUSH
10456: LD_STRING Vsevolod
10458: PPUSH
10459: LD_INT 0
10461: PPUSH
10462: LD_STRING 
10464: PPUSH
10465: CALL 70939 0 3
10469: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10470: LD_EXP 74
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 52
// end else
10484: GO 10567
// if GetControl ( i ) = control_manual then
10486: LD_VAR 0 1
10490: PPUSH
10491: CALL_OW 263
10495: PUSH
10496: LD_INT 1
10498: EQUAL
10499: IFFALSE 10567
// begin uc_side := 6 ;
10501: LD_ADDR_OWVAR 20
10505: PUSH
10506: LD_INT 6
10508: ST_TO_ADDR
// uc_nation := 3 ;
10509: LD_ADDR_OWVAR 21
10513: PUSH
10514: LD_INT 3
10516: ST_TO_ADDR
// hc_gallery :=  ;
10517: LD_ADDR_OWVAR 33
10521: PUSH
10522: LD_STRING 
10524: ST_TO_ADDR
// hc_name :=  ;
10525: LD_ADDR_OWVAR 26
10529: PUSH
10530: LD_STRING 
10532: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10533: LD_INT 0
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: LD_INT 10
10541: PPUSH
10542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10546: CALL_OW 44
10550: PPUSH
10551: LD_VAR 0 1
10555: PPUSH
10556: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10560: LD_INT 10
10562: PPUSH
10563: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10567: LD_INT 1
10569: PPUSH
10570: LD_INT 3
10572: PPUSH
10573: CALL_OW 12
10577: PUSH
10578: LD_INT 1
10580: DOUBLE
10581: EQUAL
10582: IFTRUE 10586
10584: GO 10604
10586: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10587: LD_VAR 0 1
10591: PPUSH
10592: LD_INT 111
10594: PPUSH
10595: LD_INT 197
10597: PPUSH
10598: CALL_OW 111
10602: GO 10657
10604: LD_INT 2
10606: DOUBLE
10607: EQUAL
10608: IFTRUE 10612
10610: GO 10630
10612: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_INT 91
10620: PPUSH
10621: LD_INT 165
10623: PPUSH
10624: CALL_OW 111
10628: GO 10657
10630: LD_INT 3
10632: DOUBLE
10633: EQUAL
10634: IFTRUE 10638
10636: GO 10656
10638: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10639: LD_VAR 0 1
10643: PPUSH
10644: LD_INT 137
10646: PPUSH
10647: LD_INT 157
10649: PPUSH
10650: CALL_OW 111
10654: GO 10657
10656: POP
// wait ( 0 0$2 ) ;
10657: LD_INT 70
10659: PPUSH
10660: CALL_OW 67
// end ;
10664: GO 10391
10666: POP
10667: POP
// repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10675: LD_ADDR_VAR 0 1
10679: PUSH
10680: LD_VAR 0 2
10684: PPUSH
10685: LD_INT 50
10687: PUSH
10688: EMPTY
10689: LIST
10690: PPUSH
10691: CALL_OW 72
10695: PUSH
10696: FOR_IN
10697: IFFALSE 10756
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10699: LD_VAR 0 1
10703: PPUSH
10704: LD_INT 108
10706: PUSH
10707: LD_INT 153
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 105
10716: PUSH
10717: LD_INT 149
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: LD_INT 85
10726: PUSH
10727: LD_INT 131
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: PUSH
10734: LD_INT 64
10736: PUSH
10737: LD_INT 105
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL 111861 0 2
10754: GO 10696
10756: POP
10757: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_INT 3
10765: PUSH
10766: LD_INT 34
10768: PUSH
10769: LD_INT 49
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: PUSH
10780: LD_INT 50
10782: PUSH
10783: EMPTY
10784: LIST
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PPUSH
10790: CALL_OW 72
10794: NOT
10795: IFFALSE 10668
// end ; until russianDestroyed ;
10797: LD_EXP 21
10801: IFFALSE 10128
// end ;
10803: PPOPN 6
10805: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10806: LD_EXP 21
10810: NOT
10811: IFFALSE 10823
10813: PUSH
10814: LD_EXP 15
10818: PUSH
10819: LD_INT 6
10821: GREATEREQUAL
10822: AND
10823: IFFALSE 11864
10825: GO 10827
10827: DISABLE
10828: LD_INT 0
10830: PPUSH
10831: PPUSH
10832: PPUSH
10833: PPUSH
10834: PPUSH
// begin enable ;
10835: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10836: LD_INT 22
10838: PUSH
10839: LD_INT 3
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 30
10848: PUSH
10849: LD_INT 3
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 69
10864: NOT
10865: IFFALSE 10869
// exit ;
10867: GO 11864
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10869: LD_ADDR_VAR 0 4
10873: PUSH
10874: LD_INT 22
10876: PUSH
10877: LD_INT 3
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PUSH
10884: LD_INT 30
10886: PUSH
10887: LD_INT 34
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PPUSH
10898: CALL_OW 69
10902: ST_TO_ADDR
// if Prob ( 40 ) then
10903: LD_INT 40
10905: PPUSH
10906: CALL_OW 13
10910: IFFALSE 11056
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10912: LD_INT 2
10914: PPUSH
10915: LD_INT 22
10917: PUSH
10918: LD_INT 3
10920: PUSH
10921: LD_INT 3
10923: PUSH
10924: LD_INT 49
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 22
10935: PUSH
10936: LD_INT 3
10938: PUSH
10939: LD_INT 3
10941: PUSH
10942: LD_INT 49
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 22
10953: PUSH
10954: LD_INT 3
10956: PUSH
10957: LD_INT 3
10959: PUSH
10960: LD_INT 49
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: PUSH
10969: LD_INT 24
10971: PUSH
10972: LD_INT 3
10974: PUSH
10975: LD_INT 3
10977: PUSH
10978: LD_INT 46
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: LIST
10985: LIST
10986: PUSH
10987: LD_INT 24
10989: PUSH
10990: LD_INT 3
10992: PUSH
10993: LD_INT 3
10995: PUSH
10996: LD_INT 46
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: PUSH
11005: LD_INT 24
11007: PUSH
11008: LD_INT 3
11010: PUSH
11011: LD_INT 3
11013: PUSH
11014: LD_INT 46
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: PUSH
11023: LD_INT 24
11025: PUSH
11026: LD_INT 3
11028: PUSH
11029: LD_INT 3
11031: PUSH
11032: LD_INT 46
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: PPUSH
11050: CALL 64415 0 2
// end else
11054: GO 11198
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11056: LD_INT 2
11058: PPUSH
11059: LD_INT 24
11061: PUSH
11062: LD_INT 3
11064: PUSH
11065: LD_INT 3
11067: PUSH
11068: LD_INT 47
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: PUSH
11077: LD_INT 24
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 3
11085: PUSH
11086: LD_INT 47
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: PUSH
11095: LD_INT 24
11097: PUSH
11098: LD_INT 3
11100: PUSH
11101: LD_INT 3
11103: PUSH
11104: LD_INT 47
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: PUSH
11113: LD_INT 24
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 3
11121: PUSH
11122: LD_INT 46
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 24
11133: PUSH
11134: LD_INT 3
11136: PUSH
11137: LD_INT 3
11139: PUSH
11140: LD_INT 46
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: LIST
11147: LIST
11148: PUSH
11149: LD_INT 24
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 46
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: PUSH
11167: LD_INT 24
11169: PUSH
11170: LD_INT 3
11172: PUSH
11173: LD_INT 3
11175: PUSH
11176: LD_INT 46
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
11198: LD_INT 4200
11200: PPUSH
11201: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11205: LD_ADDR_VAR 0 2
11209: PUSH
11210: LD_INT 22
11212: PUSH
11213: LD_INT 3
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 23
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 2
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: LD_INT 3
11242: PUSH
11243: LD_INT 34
11245: PUSH
11246: LD_INT 48
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: PUSH
11257: LD_INT 3
11259: PUSH
11260: LD_INT 34
11262: PUSH
11263: LD_INT 51
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 3
11276: PUSH
11277: LD_INT 34
11279: PUSH
11280: LD_INT 52
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: EMPTY
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: PPUSH
11299: CALL_OW 69
11303: PUSH
11304: LD_EXP 124
11308: PUSH
11309: LD_INT 2
11311: ARRAY
11312: DIFF
11313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11314: LD_ADDR_EXP 121
11318: PUSH
11319: LD_EXP 121
11323: PPUSH
11324: LD_INT 2
11326: PPUSH
11327: LD_EXP 121
11331: PUSH
11332: LD_INT 2
11334: ARRAY
11335: PUSH
11336: LD_VAR 0 2
11340: DIFF
11341: PPUSH
11342: CALL_OW 1
11346: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11347: LD_ADDR_VAR 0 3
11351: PUSH
11352: LD_INT 0
11354: PPUSH
11355: LD_INT 1
11357: PPUSH
11358: CALL_OW 12
11362: ST_TO_ADDR
// p := 0 ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// if target then
11371: LD_VAR 0 3
11375: IFFALSE 11526
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11377: LD_ADDR_VAR 0 2
11381: PUSH
11382: LD_VAR 0 2
11386: PPUSH
11387: LD_INT 50
11389: PUSH
11390: EMPTY
11391: LIST
11392: PPUSH
11393: CALL_OW 72
11397: ST_TO_ADDR
// for i in tmp do
11398: LD_ADDR_VAR 0 1
11402: PUSH
11403: LD_VAR 0 2
11407: PUSH
11408: FOR_IN
11409: IFFALSE 11449
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11411: LD_VAR 0 1
11415: PPUSH
11416: LD_INT 139
11418: PPUSH
11419: LD_INT 89
11421: PPUSH
11422: CALL_OW 297
11426: PUSH
11427: LD_INT 9
11429: GREATER
11430: IFFALSE 11447
// ComMoveXY ( i , 139 , 89 ) ;
11432: LD_VAR 0 1
11436: PPUSH
11437: LD_INT 139
11439: PPUSH
11440: LD_INT 89
11442: PPUSH
11443: CALL_OW 111
11447: GO 11408
11449: POP
11450: POP
// wait ( 0 0$1 ) ;
11451: LD_INT 35
11453: PPUSH
11454: CALL_OW 67
// p := Inc ( p ) ;
11458: LD_ADDR_VAR 0 5
11462: PUSH
11463: LD_VAR 0 5
11467: PPUSH
11468: CALL 110468 0 1
11472: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11473: LD_VAR 0 2
11477: PPUSH
11478: LD_INT 92
11480: PUSH
11481: LD_INT 139
11483: PUSH
11484: LD_INT 89
11486: PUSH
11487: LD_INT 9
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: PPUSH
11496: CALL_OW 72
11500: PUSH
11501: LD_VAR 0 2
11505: PUSH
11506: LD_INT 1
11508: MINUS
11509: GREATEREQUAL
11510: IFTRUE 11522
11512: PUSH
11513: LD_VAR 0 5
11517: PUSH
11518: LD_INT 60
11520: GREATER
11521: OR
11522: IFFALSE 11377
// end else
11524: GO 11691
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11526: LD_VAR 0 2
11530: PPUSH
11531: LD_VAR 0 4
11535: PUSH
11536: LD_INT 1
11538: ARRAY
11539: PPUSH
11540: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11544: LD_ADDR_VAR 0 2
11548: PUSH
11549: LD_VAR 0 2
11553: PPUSH
11554: LD_INT 50
11556: PUSH
11557: EMPTY
11558: LIST
11559: PPUSH
11560: CALL_OW 72
11564: ST_TO_ADDR
// for i in tmp do
11565: LD_ADDR_VAR 0 1
11569: PUSH
11570: LD_VAR 0 2
11574: PUSH
11575: FOR_IN
11576: IFFALSE 11616
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11578: LD_VAR 0 1
11582: PPUSH
11583: LD_INT 124
11585: PPUSH
11586: LD_INT 139
11588: PPUSH
11589: CALL_OW 297
11593: PUSH
11594: LD_INT 9
11596: GREATER
11597: IFFALSE 11614
// ComMoveXY ( i , 124 , 139 ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_INT 124
11606: PPUSH
11607: LD_INT 139
11609: PPUSH
11610: CALL_OW 111
11614: GO 11575
11616: POP
11617: POP
// wait ( 0 0$1 ) ;
11618: LD_INT 35
11620: PPUSH
11621: CALL_OW 67
// p := Inc ( p ) ;
11625: LD_ADDR_VAR 0 5
11629: PUSH
11630: LD_VAR 0 5
11634: PPUSH
11635: CALL 110468 0 1
11639: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11640: LD_VAR 0 2
11644: PPUSH
11645: LD_INT 92
11647: PUSH
11648: LD_INT 124
11650: PUSH
11651: LD_INT 139
11653: PUSH
11654: LD_INT 9
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: PPUSH
11663: CALL_OW 72
11667: PUSH
11668: LD_VAR 0 2
11672: PUSH
11673: LD_INT 1
11675: MINUS
11676: GREATEREQUAL
11677: IFTRUE 11689
11679: PUSH
11680: LD_VAR 0 5
11684: PUSH
11685: LD_INT 60
11687: GREATER
11688: OR
11689: IFFALSE 11544
// end ; repeat wait ( 0 0$1 ) ;
11691: LD_INT 35
11693: PPUSH
11694: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11698: LD_ADDR_VAR 0 2
11702: PUSH
11703: LD_VAR 0 2
11707: PPUSH
11708: LD_INT 50
11710: PUSH
11711: EMPTY
11712: LIST
11713: PPUSH
11714: CALL_OW 72
11718: ST_TO_ADDR
// for i in tmp do
11719: LD_ADDR_VAR 0 1
11723: PUSH
11724: LD_VAR 0 2
11728: PUSH
11729: FOR_IN
11730: IFFALSE 11855
// begin if GetWeapon ( i ) = ru_time_lapser then
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 264
11741: PUSH
11742: LD_INT 49
11744: EQUAL
11745: IFFALSE 11801
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11747: LD_VAR 0 1
11751: PPUSH
11752: LD_INT 2
11754: PUSH
11755: LD_INT 22
11757: PUSH
11758: LD_INT 1
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 22
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: LIST
11779: PPUSH
11780: CALL_OW 69
11784: PPUSH
11785: LD_VAR 0 1
11789: PPUSH
11790: CALL_OW 74
11794: PPUSH
11795: CALL_OW 112
11799: GO 11853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 22
11821: PUSH
11822: LD_INT 8
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: PPUSH
11834: CALL_OW 69
11838: PPUSH
11839: LD_VAR 0 1
11843: PPUSH
11844: CALL_OW 74
11848: PPUSH
11849: CALL_OW 115
// end ;
11853: GO 11729
11855: POP
11856: POP
// until not tmp ;
11857: LD_VAR 0 2
11861: NOT
11862: IFFALSE 11691
// end ;
11864: PPOPN 5
11866: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11867: LD_EXP 15
11871: PUSH
11872: LD_INT 7
11874: GREATEREQUAL
11875: IFFALSE 11887
11877: PUSH
11878: LD_OWVAR 67
11882: PUSH
11883: LD_INT 1
11885: GREATER
11886: AND
11887: IFFALSE 12179
11889: GO 11891
11891: DISABLE
11892: LD_INT 0
11894: PPUSH
11895: PPUSH
11896: PPUSH
// begin ruMobile := [ ] ;
11897: LD_ADDR_EXP 78
11901: PUSH
11902: EMPTY
11903: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11904: LD_ADDR_VAR 0 1
11908: PUSH
11909: DOUBLE
11910: LD_INT 1
11912: DEC
11913: ST_TO_ADDR
11914: LD_INT 4
11916: PUSH
11917: LD_INT 5
11919: PUSH
11920: LD_INT 6
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PUSH
11928: LD_OWVAR 67
11932: PUSH
11933: LD_INT 1
11935: MINUS
11936: ARRAY
11937: PUSH
11938: FOR_TO
11939: IFFALSE 12177
// begin uc_side := 3 ;
11941: LD_ADDR_OWVAR 20
11945: PUSH
11946: LD_INT 3
11948: ST_TO_ADDR
// uc_nation := 1 ;
11949: LD_ADDR_OWVAR 21
11953: PUSH
11954: LD_INT 1
11956: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11957: LD_INT 5
11959: PPUSH
11960: LD_INT 3
11962: PPUSH
11963: LD_INT 1
11965: PPUSH
11966: LD_INT 9
11968: PUSH
11969: LD_INT 7
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: LD_VAR 0 1
11980: PUSH
11981: LD_INT 2
11983: MOD
11984: PUSH
11985: LD_INT 1
11987: PLUS
11988: ARRAY
11989: PPUSH
11990: LD_INT 100
11992: PPUSH
11993: CALL 75925 0 5
// veh := CreateVehicle ;
11997: LD_ADDR_VAR 0 2
12001: PUSH
12002: CALL_OW 45
12006: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
12007: LD_VAR 0 2
12011: PPUSH
12012: LD_INT 3
12014: PPUSH
12015: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
12019: LD_VAR 0 2
12023: PPUSH
12024: LD_INT 29
12026: PPUSH
12027: LD_INT 0
12029: PPUSH
12030: CALL_OW 49
// uc_nation := 3 ;
12034: LD_ADDR_OWVAR 21
12038: PUSH
12039: LD_INT 3
12041: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12042: LD_INT 0
12044: PPUSH
12045: LD_INT 10
12047: PPUSH
12048: CALL_OW 383
// un := CreateHuman ;
12052: LD_ADDR_VAR 0 3
12056: PUSH
12057: CALL_OW 44
12061: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12062: LD_VAR 0 3
12066: PPUSH
12067: LD_INT 105
12069: PPUSH
12070: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12074: LD_VAR 0 3
12078: PPUSH
12079: LD_INT 3
12081: PPUSH
12082: CALL_OW 259
12086: PUSH
12087: LD_INT 8
12089: PUSH
12090: LD_INT 9
12092: PUSH
12093: LD_INT 10
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: LIST
12100: PUSH
12101: LD_OWVAR 67
12105: ARRAY
12106: LESS
12107: IFFALSE 12141
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12109: LD_VAR 0 3
12113: PPUSH
12114: LD_INT 3
12116: PPUSH
12117: LD_INT 8
12119: PUSH
12120: LD_INT 9
12122: PUSH
12123: LD_INT 10
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: PUSH
12131: LD_OWVAR 67
12135: ARRAY
12136: PPUSH
12137: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12141: LD_VAR 0 3
12145: PPUSH
12146: LD_VAR 0 2
12150: PPUSH
12151: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12155: LD_ADDR_EXP 78
12159: PUSH
12160: LD_EXP 78
12164: PPUSH
12165: LD_VAR 0 2
12169: PPUSH
12170: CALL 109095 0 2
12174: ST_TO_ADDR
// end ;
12175: GO 11938
12177: POP
12178: POP
// end ;
12179: PPOPN 3
12181: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12182: LD_EXP 78
12186: IFFALSE 12697
12188: GO 12190
12190: DISABLE
12191: LD_INT 0
12193: PPUSH
12194: PPUSH
12195: PPUSH
// begin enable ;
12196: ENABLE
// if not ruMobile then
12197: LD_EXP 78
12201: NOT
12202: IFFALSE 12207
// begin disable ;
12204: DISABLE
// exit ;
12205: GO 12697
// end ; for i in ruMobile do
12207: LD_ADDR_VAR 0 1
12211: PUSH
12212: LD_EXP 78
12216: PUSH
12217: FOR_IN
12218: IFFALSE 12695
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12220: LD_VAR 0 1
12224: PPUSH
12225: CALL_OW 302
12229: NOT
12230: IFTRUE 12247
12232: PUSH
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL_OW 255
12242: PUSH
12243: LD_INT 3
12245: NONEQUAL
12246: OR
12247: IFFALSE 12267
// begin ruMobile := ruMobile diff i ;
12249: LD_ADDR_EXP 78
12253: PUSH
12254: LD_EXP 78
12258: PUSH
12259: LD_VAR 0 1
12263: DIFF
12264: ST_TO_ADDR
// continue ;
12265: GO 12217
// end ; if GetTag ( i ) = 300 then
12267: LD_VAR 0 1
12271: PPUSH
12272: CALL_OW 110
12276: PUSH
12277: LD_INT 300
12279: EQUAL
12280: IFFALSE 12330
// begin ComMoveXY ( i , 160 , 81 ) ;
12282: LD_VAR 0 1
12286: PPUSH
12287: LD_INT 160
12289: PPUSH
12290: LD_INT 81
12292: PPUSH
12293: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_INT 160
12304: PPUSH
12305: LD_INT 81
12307: PPUSH
12308: CALL_OW 297
12312: PUSH
12313: LD_INT 8
12315: LESS
12316: IFFALSE 12330
// SetTag ( i , 301 ) ;
12318: LD_VAR 0 1
12322: PPUSH
12323: LD_INT 301
12325: PPUSH
12326: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12330: LD_VAR 0 1
12334: PPUSH
12335: CALL_OW 110
12339: PUSH
12340: LD_INT 301
12342: EQUAL
12343: IFFALSE 12386
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12345: LD_VAR 0 1
12349: PPUSH
12350: LD_INT 33
12352: PPUSH
12353: CALL_OW 308
12357: NOT
12358: IFFALSE 12374
// ComMoveToArea ( i , ruMobileParkingArea ) else
12360: LD_VAR 0 1
12364: PPUSH
12365: LD_INT 33
12367: PPUSH
12368: CALL_OW 113
12372: GO 12386
// SetTag ( i , 302 ) ;
12374: LD_VAR 0 1
12378: PPUSH
12379: LD_INT 302
12381: PPUSH
12382: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12386: LD_VAR 0 1
12390: PPUSH
12391: CALL_OW 110
12395: PUSH
12396: LD_INT 302
12398: EQUAL
12399: IFFALSE 12529
// begin if GetLives ( i ) < 1000 then
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 256
12410: PUSH
12411: LD_INT 1000
12413: LESS
12414: IFFALSE 12506
// begin if not IsDrivenBy ( i ) then
12416: LD_VAR 0 1
12420: PPUSH
12421: CALL_OW 311
12425: NOT
12426: IFFALSE 12430
// continue ;
12428: GO 12217
// mech := IsDrivenBy ( i ) ;
12430: LD_ADDR_VAR 0 2
12434: PUSH
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 311
12444: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12445: LD_VAR 0 2
12449: PPUSH
12450: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12454: LD_VAR 0 2
12458: PPUSH
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12468: LD_INT 35
12470: PPUSH
12471: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12475: LD_VAR 0 1
12479: PPUSH
12480: CALL_OW 256
12484: PUSH
12485: LD_INT 1000
12487: EQUAL
12488: IFFALSE 12468
// ComEnterUnit ( mech , i ) ;
12490: LD_VAR 0 2
12494: PPUSH
12495: LD_VAR 0 1
12499: PPUSH
12500: CALL_OW 120
// end else
12504: GO 12529
// if IsDrivenBy ( i ) then
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 311
12515: IFFALSE 12529
// SetTag ( i , 0 ) ;
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 0
12524: PPUSH
12525: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12529: LD_VAR 0 1
12533: PPUSH
12534: CALL_OW 110
12538: PUSH
12539: LD_INT 300
12541: LESS
12542: IFFALSE 12693
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12544: LD_ADDR_VAR 0 3
12548: PUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 81
12554: PUSH
12555: LD_INT 3
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: PPUSH
12562: CALL_OW 70
12566: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12567: LD_VAR 0 1
12571: PPUSH
12572: CALL_OW 256
12576: PUSH
12577: LD_INT 650
12579: LESS
12580: IFFALSE 12605
// begin ComStop ( i ) ;
12582: LD_VAR 0 1
12586: PPUSH
12587: CALL_OW 141
// SetTag ( i , 300 ) ;
12591: LD_VAR 0 1
12595: PPUSH
12596: LD_INT 300
12598: PPUSH
12599: CALL_OW 109
// continue ;
12603: GO 12217
// end ; if enemy then
12605: LD_VAR 0 3
12609: IFFALSE 12649
// begin if not HasTask ( i ) then
12611: LD_VAR 0 1
12615: PPUSH
12616: CALL_OW 314
12620: NOT
12621: IFFALSE 12647
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: LD_VAR 0 3
12632: PPUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 74
12642: PPUSH
12643: CALL_OW 115
// end else
12647: GO 12693
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12649: LD_VAR 0 1
12653: PPUSH
12654: LD_INT 158
12656: PUSH
12657: LD_INT 61
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PUSH
12664: LD_INT 98
12666: PUSH
12667: LD_INT 100
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PUSH
12674: LD_INT 78
12676: PUSH
12677: LD_INT 93
12679: PUSH
12680: EMPTY
12681: LIST
12682: LIST
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL 111861 0 2
// end ; end ;
12693: GO 12217
12695: POP
12696: POP
// end ; end_of_file
12697: PPOPN 3
12699: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12700: LD_INT 0
12702: PPUSH
12703: PPUSH
12704: PPUSH
12705: PPUSH
12706: PPUSH
12707: PPUSH
12708: PPUSH
// if Difficulty = 1 then
12709: LD_OWVAR 67
12713: PUSH
12714: LD_INT 1
12716: EQUAL
12717: IFFALSE 12755
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12719: LD_ADDR_VAR 0 2
12723: PUSH
12724: LD_INT 95
12726: PUSH
12727: LD_INT 34
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: PUSH
12739: FOR_IN
12740: IFFALSE 12753
// RemoveUnit ( i ) ;
12742: LD_VAR 0 2
12746: PPUSH
12747: CALL_OW 64
12751: GO 12739
12753: POP
12754: POP
// SetInvulnrability ( alien , true ) ;
12755: LD_INT 1
12757: PPUSH
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 607
// side := 7 ;
12765: LD_ADDR_VAR 0 5
12769: PUSH
12770: LD_INT 7
12772: ST_TO_ADDR
// uc_side := side ;
12773: LD_ADDR_OWVAR 20
12777: PUSH
12778: LD_VAR 0 5
12782: ST_TO_ADDR
// uc_nation := 1 ;
12783: LD_ADDR_OWVAR 21
12787: PUSH
12788: LD_INT 1
12790: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12791: LD_ADDR_VAR 0 2
12795: PUSH
12796: LD_INT 22
12798: PUSH
12799: LD_VAR 0 5
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 21
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: FOR_IN
12828: IFFALSE 12844
// SetBLevel ( i , 10 ) ;
12830: LD_VAR 0 2
12834: PPUSH
12835: LD_INT 10
12837: PPUSH
12838: CALL_OW 241
12842: GO 12827
12844: POP
12845: POP
// base := GetBase ( al_depot ) ;
12846: LD_ADDR_VAR 0 4
12850: PUSH
12851: LD_INT 2
12853: PPUSH
12854: CALL_OW 274
12858: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12859: LD_ADDR_VAR 0 6
12863: PUSH
12864: LD_INT 22
12866: PUSH
12867: LD_VAR 0 5
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 30
12878: PUSH
12879: LD_INT 34
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PPUSH
12890: CALL_OW 69
12894: ST_TO_ADDR
// if teleport then
12895: LD_VAR 0 6
12899: IFFALSE 12920
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12901: LD_VAR 0 6
12905: PUSH
12906: LD_INT 1
12908: ARRAY
12909: PPUSH
12910: LD_INT 262
12912: PPUSH
12913: LD_INT 119
12915: PPUSH
12916: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12920: LD_VAR 0 4
12924: PPUSH
12925: LD_INT 1
12927: PPUSH
12928: LD_INT 19500
12930: PPUSH
12931: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12935: LD_VAR 0 4
12939: PPUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 200
12945: PPUSH
12946: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12950: LD_VAR 0 4
12954: PPUSH
12955: LD_INT 3
12957: PPUSH
12958: LD_INT 650
12960: PPUSH
12961: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12965: LD_ADDR_EXP 79
12969: PUSH
12970: LD_STRING Roth
12972: PPUSH
12973: CALL_OW 25
12977: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12978: LD_ADDR_EXP 80
12982: PUSH
12983: LD_STRING Simms
12985: PPUSH
12986: LD_EXP 1
12990: NOT
12991: PPUSH
12992: LD_STRING 10c_
12994: PPUSH
12995: CALL 70939 0 3
12999: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
13000: LD_EXP 80
13004: PPUSH
13005: LD_INT 4
13007: PPUSH
13008: CALL_OW 336
// if not Simms then
13012: LD_EXP 80
13016: NOT
13017: IFFALSE 13047
// begin uc_nation := 1 ;
13019: LD_ADDR_OWVAR 21
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
13027: LD_INT 2
13029: PPUSH
13030: LD_INT 10
13032: PPUSH
13033: CALL_OW 384
// Simms := CreateHuman ;
13037: LD_ADDR_EXP 80
13041: PUSH
13042: CALL_OW 44
13046: ST_TO_ADDR
// end ; uc_nation := 3 ;
13047: LD_ADDR_OWVAR 21
13051: PUSH
13052: LD_INT 3
13054: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13055: LD_ADDR_EXP 81
13059: PUSH
13060: LD_STRING Kirilenkova
13062: PPUSH
13063: CALL_OW 25
13067: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13068: LD_ADDR_EXP 95
13072: PUSH
13073: LD_STRING Oblukov
13075: PPUSH
13076: CALL_OW 25
13080: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13081: LD_ADDR_EXP 82
13085: PUSH
13086: LD_STRING Dolgov
13088: PPUSH
13089: CALL_OW 25
13093: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13094: LD_ADDR_EXP 83
13098: PUSH
13099: LD_STRING Petrosyan
13101: PPUSH
13102: CALL_OW 25
13106: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13107: LD_ADDR_EXP 94
13111: PUSH
13112: LD_STRING Scholtze
13114: PPUSH
13115: CALL_OW 25
13119: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13120: LD_ADDR_EXP 93
13124: PUSH
13125: LD_STRING Kapitsova
13127: PPUSH
13128: CALL_OW 25
13132: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13133: LD_ADDR_EXP 84
13137: PUSH
13138: LD_STRING Petrovova
13140: PPUSH
13141: CALL_OW 25
13145: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13146: LD_ADDR_EXP 85
13150: PUSH
13151: LD_STRING Kuzmov
13153: PPUSH
13154: CALL_OW 25
13158: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13159: LD_ADDR_EXP 92
13163: PUSH
13164: LD_STRING Karamazov
13166: PPUSH
13167: CALL_OW 25
13171: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13172: LD_STRING 13_Lipshchin_1
13174: PPUSH
13175: LD_INT 0
13177: PPUSH
13178: CALL_OW 30
13182: IFFALSE 13197
// Lipshchin := NewCharacter ( Lipshchin ) ;
13184: LD_ADDR_EXP 86
13188: PUSH
13189: LD_STRING Lipshchin
13191: PPUSH
13192: CALL_OW 25
13196: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13197: LD_STRING 13_Titov_1
13199: PPUSH
13200: LD_INT 0
13202: PPUSH
13203: CALL_OW 30
13207: IFFALSE 13222
// Titov := NewCharacter ( Titov ) ;
13209: LD_ADDR_EXP 88
13213: PUSH
13214: LD_STRING Titov
13216: PPUSH
13217: CALL_OW 25
13221: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13222: LD_STRING 13_Gnyevko_1
13224: PPUSH
13225: LD_INT 0
13227: PPUSH
13228: CALL_OW 30
13232: IFFALSE 13247
// Gnyevko := NewCharacter ( Gnyevko ) ;
13234: LD_ADDR_EXP 87
13238: PUSH
13239: LD_STRING Gnyevko
13241: PPUSH
13242: CALL_OW 25
13246: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13247: LD_STRING 13_Xavier_1
13249: PPUSH
13250: LD_INT 0
13252: PPUSH
13253: CALL_OW 30
13257: IFFALSE 13272
// Xavier := NewCharacter ( Xavier2 ) ;
13259: LD_ADDR_EXP 89
13263: PUSH
13264: LD_STRING Xavier2
13266: PPUSH
13267: CALL_OW 25
13271: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13272: LD_STRING 13_Belkov_1
13274: PPUSH
13275: LD_INT 0
13277: PPUSH
13278: CALL_OW 30
13282: IFFALSE 13297
// Belkov := NewCharacter ( Belkov ) ;
13284: LD_ADDR_EXP 90
13288: PUSH
13289: LD_STRING Belkov
13291: PPUSH
13292: CALL_OW 25
13296: ST_TO_ADDR
// if not BurlakStatus then
13297: LD_EXP 9
13301: NOT
13302: IFFALSE 13317
// Burlak = NewCharacter ( Burlak ) ;
13304: LD_ADDR_EXP 91
13308: PUSH
13309: LD_STRING Burlak
13311: PPUSH
13312: CALL_OW 25
13316: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_EXP 79
13326: PUSH
13327: LD_EXP 81
13331: PUSH
13332: LD_EXP 95
13336: PUSH
13337: LD_EXP 82
13341: PUSH
13342: LD_EXP 83
13346: PUSH
13347: LD_EXP 94
13351: PUSH
13352: LD_EXP 93
13356: PUSH
13357: LD_EXP 84
13361: PUSH
13362: LD_EXP 85
13366: PUSH
13367: LD_EXP 92
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: ST_TO_ADDR
// if Simms then
13384: LD_EXP 80
13388: IFFALSE 13406
// tmp := tmp ^ Simms ;
13390: LD_ADDR_VAR 0 3
13394: PUSH
13395: LD_VAR 0 3
13399: PUSH
13400: LD_EXP 80
13404: ADD
13405: ST_TO_ADDR
// if Titov then
13406: LD_EXP 88
13410: IFFALSE 13428
// tmp := tmp ^ Titov ;
13412: LD_ADDR_VAR 0 3
13416: PUSH
13417: LD_VAR 0 3
13421: PUSH
13422: LD_EXP 88
13426: ADD
13427: ST_TO_ADDR
// if Lipshchin then
13428: LD_EXP 86
13432: IFFALSE 13450
// tmp := tmp ^ Lipshchin ;
13434: LD_ADDR_VAR 0 3
13438: PUSH
13439: LD_VAR 0 3
13443: PUSH
13444: LD_EXP 86
13448: ADD
13449: ST_TO_ADDR
// if Gnyevko then
13450: LD_EXP 87
13454: IFFALSE 13472
// tmp := tmp ^ Gnyevko ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_EXP 87
13470: ADD
13471: ST_TO_ADDR
// if Xavier then
13472: LD_EXP 89
13476: IFFALSE 13494
// tmp := tmp ^ Xavier ;
13478: LD_ADDR_VAR 0 3
13482: PUSH
13483: LD_VAR 0 3
13487: PUSH
13488: LD_EXP 89
13492: ADD
13493: ST_TO_ADDR
// if Belkov then
13494: LD_EXP 90
13498: IFFALSE 13516
// tmp := tmp ^ Belkov ;
13500: LD_ADDR_VAR 0 3
13504: PUSH
13505: LD_VAR 0 3
13509: PUSH
13510: LD_EXP 90
13514: ADD
13515: ST_TO_ADDR
// if Burlak then
13516: LD_EXP 91
13520: IFFALSE 13538
// tmp := tmp ^ Burlak ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_EXP 91
13536: ADD
13537: ST_TO_ADDR
// for i = 1 to 11 do
13538: LD_ADDR_VAR 0 2
13542: PUSH
13543: DOUBLE
13544: LD_INT 1
13546: DEC
13547: ST_TO_ADDR
13548: LD_INT 11
13550: PUSH
13551: FOR_TO
13552: IFFALSE 13620
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13554: LD_ADDR_OWVAR 21
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: LD_INT 3
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: LD_INT 1
13571: PPUSH
13572: LD_INT 2
13574: PPUSH
13575: CALL_OW 12
13579: ARRAY
13580: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13581: LD_INT 0
13583: PPUSH
13584: LD_INT 1
13586: PPUSH
13587: LD_INT 4
13589: PPUSH
13590: CALL_OW 12
13594: PPUSH
13595: LD_INT 10
13597: PPUSH
13598: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13602: LD_ADDR_VAR 0 3
13606: PUSH
13607: LD_VAR 0 3
13611: PUSH
13612: CALL_OW 44
13616: ADD
13617: ST_TO_ADDR
// end ;
13618: GO 13551
13620: POP
13621: POP
// for i in tmp do
13622: LD_ADDR_VAR 0 2
13626: PUSH
13627: LD_VAR 0 3
13631: PUSH
13632: FOR_IN
13633: IFFALSE 13658
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13635: LD_VAR 0 2
13639: PPUSH
13640: LD_INT 260
13642: PPUSH
13643: LD_INT 235
13645: PPUSH
13646: LD_INT 8
13648: PPUSH
13649: LD_INT 0
13651: PPUSH
13652: CALL_OW 50
13656: GO 13632
13658: POP
13659: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13660: LD_ADDR_EXP 102
13664: PUSH
13665: LD_EXP 102
13669: PPUSH
13670: LD_INT 1
13672: PPUSH
13673: LD_INT 22
13675: PUSH
13676: LD_VAR 0 5
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: LD_INT 3
13687: PUSH
13688: LD_INT 21
13690: PUSH
13691: LD_INT 2
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PPUSH
13706: CALL_OW 69
13710: PUSH
13711: LD_EXP 79
13715: PUSH
13716: LD_EXP 80
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: DIFF
13725: PPUSH
13726: CALL_OW 1
13730: ST_TO_ADDR
// uc_side := 0 ;
13731: LD_ADDR_OWVAR 20
13735: PUSH
13736: LD_INT 0
13738: ST_TO_ADDR
// uc_nation := 0 ;
13739: LD_ADDR_OWVAR 21
13743: PUSH
13744: LD_INT 0
13746: ST_TO_ADDR
// for i = 1 to 5 do
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: DOUBLE
13753: LD_INT 1
13755: DEC
13756: ST_TO_ADDR
13757: LD_INT 5
13759: PUSH
13760: FOR_TO
13761: IFFALSE 13798
// begin InitHc ;
13763: CALL_OW 19
// hc_class := class_apeman ;
13767: LD_ADDR_OWVAR 28
13771: PUSH
13772: LD_INT 12
13774: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13775: CALL_OW 44
13779: PPUSH
13780: LD_INT 299
13782: PPUSH
13783: LD_INT 229
13785: PPUSH
13786: LD_INT 10
13788: PPUSH
13789: LD_INT 0
13791: PPUSH
13792: CALL_OW 50
// end ;
13796: GO 13760
13798: POP
13799: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13800: LD_EXP 79
13804: PPUSH
13805: LD_INT 259
13807: PPUSH
13808: LD_INT 235
13810: PPUSH
13811: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13815: LD_EXP 79
13819: PPUSH
13820: LD_INT 262
13822: PPUSH
13823: LD_INT 235
13825: PPUSH
13826: CALL_OW 178
// if Simms then
13830: LD_EXP 80
13834: IFFALSE 13865
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13836: LD_EXP 80
13840: PPUSH
13841: LD_INT 262
13843: PPUSH
13844: LD_INT 235
13846: PPUSH
13847: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13851: LD_EXP 80
13855: PPUSH
13856: LD_EXP 79
13860: PPUSH
13861: CALL_OW 179
// end ; uc_side := 7 ;
13865: LD_ADDR_OWVAR 20
13869: PUSH
13870: LD_INT 7
13872: ST_TO_ADDR
// uc_nation := 1 ;
13873: LD_ADDR_OWVAR 21
13877: PUSH
13878: LD_INT 1
13880: ST_TO_ADDR
// bc_type := b_control_tower ;
13881: LD_ADDR_OWVAR 42
13885: PUSH
13886: LD_INT 36
13888: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13889: LD_ADDR_VAR 0 7
13893: PUSH
13894: LD_INT 268
13896: PPUSH
13897: LD_INT 251
13899: PPUSH
13900: LD_INT 4
13902: PPUSH
13903: CALL_OW 47
13907: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13908: LD_INT 0
13910: PPUSH
13911: LD_INT 10
13913: PPUSH
13914: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13918: CALL_OW 44
13922: PPUSH
13923: LD_VAR 0 7
13927: PPUSH
13928: CALL_OW 52
// end ;
13932: LD_VAR 0 1
13936: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13937: LD_EXP 31
13941: IFFALSE 13950
13943: PUSH
13944: LD_EXP 23
13948: NOT
13949: AND
13950: IFFALSE 13982
13952: PUSH
13953: LD_INT 22
13955: PUSH
13956: LD_INT 7
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PUSH
13963: LD_INT 30
13965: PUSH
13966: LD_INT 8
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PPUSH
13977: CALL_OW 69
13981: AND
13982: IFFALSE 14210
13984: GO 13986
13986: DISABLE
13987: LD_INT 0
13989: PPUSH
13990: PPUSH
13991: PPUSH
// begin enable ;
13992: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13993: LD_ADDR_VAR 0 2
13997: PUSH
13998: LD_INT 81
14000: PUSH
14001: LD_INT 7
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: LD_INT 2
14010: PUSH
14011: LD_INT 32
14013: PUSH
14014: LD_INT 3
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: PUSH
14021: LD_INT 30
14023: PUSH
14024: LD_INT 30
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: LD_INT 30
14033: PUSH
14034: LD_INT 28
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 34
14043: PUSH
14044: LD_INT 49
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 34
14053: PUSH
14054: LD_INT 10
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PUSH
14061: LD_INT 34
14063: PUSH
14064: LD_INT 8
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: PPUSH
14084: CALL_OW 69
14088: ST_TO_ADDR
// if not tmp then
14089: LD_VAR 0 2
14093: NOT
14094: IFFALSE 14098
// exit ;
14096: GO 14210
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_INT 34
14105: PUSH
14106: LD_INT 8
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 72
14117: IFFALSE 14150
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14119: LD_ADDR_VAR 0 3
14123: PUSH
14124: LD_VAR 0 2
14128: PPUSH
14129: LD_INT 34
14131: PUSH
14132: LD_INT 8
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 72
14143: PUSH
14144: LD_INT 1
14146: ARRAY
14147: ST_TO_ADDR
14148: GO 14174
// target := tmp [ rand ( 1 , tmp ) ] ;
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_VAR 0 2
14159: PUSH
14160: LD_INT 1
14162: PPUSH
14163: LD_VAR 0 2
14167: PPUSH
14168: CALL_OW 12
14172: ARRAY
14173: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14174: LD_VAR 0 3
14178: PPUSH
14179: CALL_OW 255
14183: PUSH
14184: LD_INT 1
14186: EQUAL
14187: IFFALSE 14198
// CenterNowOnUnits ( target ) ;
14189: LD_VAR 0 3
14193: PPUSH
14194: CALL_OW 87
// SetLives ( target , 0 ) ;
14198: LD_VAR 0 3
14202: PPUSH
14203: LD_INT 0
14205: PPUSH
14206: CALL_OW 234
// end ;
14210: PPOPN 3
14212: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14213: LD_EXP 23
14217: NOT
14218: IFFALSE 14226
14220: PUSH
14221: LD_EXP 31
14225: AND
14226: IFFALSE 14744
14228: GO 14230
14230: DISABLE
14231: LD_INT 0
14233: PPUSH
14234: PPUSH
14235: PPUSH
// begin uc_side := 7 ;
14236: LD_ADDR_OWVAR 20
14240: PUSH
14241: LD_INT 7
14243: ST_TO_ADDR
// uc_nation := 1 ;
14244: LD_ADDR_OWVAR 21
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14252: LD_ADDR_VAR 0 3
14256: PUSH
14257: LD_INT 125
14259: PUSH
14260: LD_INT 163
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: PUSH
14267: LD_INT 185
14269: PUSH
14270: LD_INT 168
14272: PUSH
14273: EMPTY
14274: LIST
14275: LIST
14276: PUSH
14277: LD_INT 111
14279: PUSH
14280: LD_INT 97
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: PUSH
14287: LD_INT 94
14289: PUSH
14290: LD_INT 114
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: PPUSH
14303: CALL 109200 0 1
14307: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14308: LD_ADDR_EXP 96
14312: PUSH
14313: EMPTY
14314: ST_TO_ADDR
// for i = 1 to Difficulty do
14315: LD_ADDR_VAR 0 1
14319: PUSH
14320: DOUBLE
14321: LD_INT 1
14323: DEC
14324: ST_TO_ADDR
14325: LD_OWVAR 67
14329: PUSH
14330: FOR_TO
14331: IFFALSE 14489
// begin InitHc ;
14333: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 8
14342: PPUSH
14343: CALL_OW 381
// un := CreateHuman ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: CALL_OW 44
14356: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14357: LD_VAR 0 2
14361: PPUSH
14362: LD_INT 258
14364: PPUSH
14365: LD_INT 267
14367: PPUSH
14368: LD_INT 4
14370: PPUSH
14371: LD_INT 0
14373: PPUSH
14374: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14378: LD_ADDR_EXP 96
14382: PUSH
14383: LD_EXP 96
14387: PUSH
14388: LD_VAR 0 2
14392: UNION
14393: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14394: LD_VAR 0 2
14398: PPUSH
14399: LD_VAR 0 3
14403: PUSH
14404: LD_VAR 0 1
14408: ARRAY
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: LD_VAR 0 3
14418: PUSH
14419: LD_VAR 0 1
14423: ARRAY
14424: PUSH
14425: LD_INT 2
14427: ARRAY
14428: PPUSH
14429: LD_INT 4
14431: PPUSH
14432: LD_INT 1
14434: PPUSH
14435: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14439: LD_VAR 0 2
14443: PPUSH
14444: LD_VAR 0 3
14448: PUSH
14449: LD_VAR 0 1
14453: ARRAY
14454: PUSH
14455: LD_INT 1
14457: ARRAY
14458: PPUSH
14459: LD_VAR 0 3
14463: PUSH
14464: LD_VAR 0 1
14468: ARRAY
14469: PUSH
14470: LD_INT 2
14472: ARRAY
14473: PPUSH
14474: CALL_OW 171
// AddComInvisible ( un ) ;
14478: LD_VAR 0 2
14482: PPUSH
14483: CALL_OW 212
// end ;
14487: GO 14330
14489: POP
14490: POP
// repeat wait ( 0 0$45 ) ;
14491: LD_INT 1575
14493: PPUSH
14494: CALL_OW 67
// for i in allianceSpecialForce do
14498: LD_ADDR_VAR 0 1
14502: PUSH
14503: LD_EXP 96
14507: PUSH
14508: FOR_IN
14509: IFFALSE 14727
// begin if IsInvisible ( i ) then
14511: LD_VAR 0 1
14515: PPUSH
14516: CALL_OW 571
14520: IFFALSE 14696
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: LD_INT 22
14529: PUSH
14530: LD_INT 1
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 50
14539: PUSH
14540: EMPTY
14541: LIST
14542: PUSH
14543: LD_INT 56
14545: PUSH
14546: EMPTY
14547: LIST
14548: PUSH
14549: LD_INT 91
14551: PUSH
14552: LD_VAR 0 1
14556: PUSH
14557: LD_INT 25
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 25
14570: PUSH
14571: LD_INT 1
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PUSH
14578: LD_INT 25
14580: PUSH
14581: LD_INT 2
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 25
14590: PUSH
14591: LD_INT 3
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: LD_INT 25
14600: PUSH
14601: LD_INT 4
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 25
14610: PUSH
14611: LD_INT 5
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 8
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: ST_TO_ADDR
// if not tmp then
14649: LD_VAR 0 3
14653: NOT
14654: IFFALSE 14658
// continue ;
14656: GO 14508
// if Prob ( 30 * Difficulty ) then
14658: LD_INT 30
14660: PUSH
14661: LD_OWVAR 67
14665: MUL
14666: PPUSH
14667: CALL_OW 13
14671: IFFALSE 14696
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14673: LD_VAR 0 3
14677: PUSH
14678: LD_INT 1
14680: PPUSH
14681: LD_VAR 0 3
14685: PPUSH
14686: CALL_OW 12
14690: ARRAY
14691: PPUSH
14692: CALL 35627 0 1
// end ; if IsDead ( i ) then
14696: LD_VAR 0 1
14700: PPUSH
14701: CALL_OW 301
14705: IFFALSE 14725
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14707: LD_ADDR_EXP 96
14711: PUSH
14712: LD_EXP 96
14716: PUSH
14717: LD_VAR 0 1
14721: DIFF
14722: ST_TO_ADDR
// continue ;
14723: GO 14508
// end ; end ;
14725: GO 14508
14727: POP
14728: POP
// until allianceDestroyed or not allianceSpecialForce ;
14729: LD_EXP 23
14733: IFTRUE 14742
14735: PUSH
14736: LD_EXP 96
14740: NOT
14741: OR
14742: IFFALSE 14491
// end ;
14744: PPOPN 3
14746: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14747: LD_EXP 31
14751: IFFALSE 14801
14753: PUSH
14754: LD_INT 22
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 2
14766: PUSH
14767: LD_INT 35
14769: PUSH
14770: LD_INT 8
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 34
14779: PUSH
14780: LD_INT 8
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: PPUSH
14796: CALL_OW 69
14800: AND
14801: IFFALSE 15201
14803: GO 14805
14805: DISABLE
14806: LD_INT 0
14808: PPUSH
14809: PPUSH
14810: PPUSH
14811: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14812: LD_ADDR_VAR 0 1
14816: PUSH
14817: DOUBLE
14818: LD_INT 1
14820: DEC
14821: ST_TO_ADDR
14822: LD_INT 6
14824: PUSH
14825: LD_INT 8
14827: PUSH
14828: LD_INT 10
14830: PUSH
14831: LD_INT 12
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: PUSH
14840: LD_OWVAR 67
14844: ARRAY
14845: PUSH
14846: FOR_TO
14847: IFFALSE 15039
// begin uc_side := 7 ;
14849: LD_ADDR_OWVAR 20
14853: PUSH
14854: LD_INT 7
14856: ST_TO_ADDR
// uc_nation := 1 ;
14857: LD_ADDR_OWVAR 21
14861: PUSH
14862: LD_INT 1
14864: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14865: LD_INT 5
14867: PPUSH
14868: LD_INT 3
14870: PPUSH
14871: LD_INT 2
14873: PUSH
14874: LD_INT 3
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 1
14883: PPUSH
14884: LD_INT 2
14886: PPUSH
14887: CALL_OW 12
14891: ARRAY
14892: PPUSH
14893: LD_INT 6
14895: PUSH
14896: LD_INT 9
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 1
14905: PPUSH
14906: LD_INT 2
14908: PPUSH
14909: CALL_OW 12
14913: ARRAY
14914: PPUSH
14915: LD_INT 100
14917: PPUSH
14918: CALL 75925 0 5
// un := CreateVehicle ;
14922: LD_ADDR_VAR 0 2
14926: PUSH
14927: CALL_OW 45
14931: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14932: LD_VAR 0 2
14936: PPUSH
14937: LD_INT 4
14939: PPUSH
14940: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14944: LD_VAR 0 2
14948: PPUSH
14949: LD_INT 307
14951: PPUSH
14952: LD_INT 219
14954: PPUSH
14955: LD_INT 6
14957: PPUSH
14958: LD_INT 0
14960: PPUSH
14961: CALL_OW 50
// if GetControl ( un ) = control_remote then
14965: LD_VAR 0 2
14969: PPUSH
14970: CALL_OW 263
14974: PUSH
14975: LD_INT 2
14977: EQUAL
14978: IFFALSE 14989
// Connect ( un ) ;
14980: LD_VAR 0 2
14984: PPUSH
14985: CALL 79407 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14989: LD_VAR 0 2
14993: PPUSH
14994: LD_INT 124
14996: PPUSH
14997: LD_INT 92
14999: PPUSH
15000: LD_INT 12
15002: PPUSH
15003: LD_INT 1
15005: PPUSH
15006: CALL_OW 483
// tmp := Join ( tmp , un ) ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_VAR 0 3
15019: PPUSH
15020: LD_VAR 0 2
15024: PPUSH
15025: CALL 109095 0 2
15029: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
15030: LD_INT 10
15032: PPUSH
15033: CALL_OW 67
// end ;
15037: GO 14846
15039: POP
15040: POP
// repeat wait ( 0 0$2 ) ;
15041: LD_INT 70
15043: PPUSH
15044: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
15048: LD_ADDR_VAR 0 4
15052: PUSH
15053: LD_INT 22
15055: PUSH
15056: LD_INT 1
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 34
15065: PUSH
15066: LD_INT 8
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PPUSH
15077: CALL_OW 69
15081: ST_TO_ADDR
// if not e then
15082: LD_VAR 0 4
15086: NOT
15087: IFFALSE 15123
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15089: LD_ADDR_VAR 0 4
15093: PUSH
15094: LD_INT 22
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 21
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PPUSH
15118: CALL_OW 69
15122: ST_TO_ADDR
// for i in tmp do
15123: LD_ADDR_VAR 0 1
15127: PUSH
15128: LD_VAR 0 3
15132: PUSH
15133: FOR_IN
15134: IFFALSE 15192
// if not IsOK ( i ) then
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 302
15145: NOT
15146: IFFALSE 15166
// tmp := tmp diff i else
15148: LD_ADDR_VAR 0 3
15152: PUSH
15153: LD_VAR 0 3
15157: PUSH
15158: LD_VAR 0 1
15162: DIFF
15163: ST_TO_ADDR
15164: GO 15190
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 4
15175: PPUSH
15176: LD_VAR 0 1
15180: PPUSH
15181: CALL_OW 74
15185: PPUSH
15186: CALL_OW 115
15190: GO 15133
15192: POP
15193: POP
// until not tmp ;
15194: LD_VAR 0 3
15198: NOT
15199: IFFALSE 15041
// end ;
15201: PPOPN 4
15203: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15204: LD_EXP 23
15208: NOT
15209: IFFALSE 15217
15211: PUSH
15212: LD_EXP 31
15216: AND
15217: IFFALSE 16295
15219: GO 15221
15221: DISABLE
15222: LD_INT 0
15224: PPUSH
15225: PPUSH
15226: PPUSH
15227: PPUSH
15228: PPUSH
// begin enable ;
15229: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15230: LD_INT 22
15232: PUSH
15233: LD_INT 7
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 30
15242: PUSH
15243: LD_INT 3
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: PPUSH
15254: CALL_OW 69
15258: NOT
15259: IFFALSE 15263
// exit ;
15261: GO 16295
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15263: LD_ADDR_VAR 0 4
15267: PUSH
15268: LD_INT 22
15270: PUSH
15271: LD_INT 7
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PUSH
15278: LD_INT 30
15280: PUSH
15281: LD_INT 34
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PPUSH
15292: CALL_OW 69
15296: ST_TO_ADDR
// if Prob ( 40 ) then
15297: LD_INT 40
15299: PPUSH
15300: CALL_OW 13
15304: IFFALSE 15450
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15306: LD_INT 1
15308: PPUSH
15309: LD_INT 5
15311: PUSH
15312: LD_INT 3
15314: PUSH
15315: LD_INT 2
15317: PUSH
15318: LD_INT 6
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PUSH
15327: LD_INT 5
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: LD_INT 2
15335: PUSH
15336: LD_INT 6
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: PUSH
15345: LD_INT 5
15347: PUSH
15348: LD_INT 3
15350: PUSH
15351: LD_INT 2
15353: PUSH
15354: LD_INT 6
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: LD_INT 5
15365: PUSH
15366: LD_INT 3
15368: PUSH
15369: LD_INT 2
15371: PUSH
15372: LD_INT 9
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 24
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: LD_INT 3
15389: PUSH
15390: LD_INT 45
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 24
15401: PUSH
15402: LD_INT 3
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: LD_INT 47
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PUSH
15417: LD_INT 24
15419: PUSH
15420: LD_INT 3
15422: PUSH
15423: LD_INT 3
15425: PUSH
15426: LD_INT 45
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL 64415 0 2
// end else
15448: GO 15592
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15450: LD_INT 1
15452: PPUSH
15453: LD_INT 24
15455: PUSH
15456: LD_INT 3
15458: PUSH
15459: LD_INT 3
15461: PUSH
15462: LD_INT 47
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: PUSH
15471: LD_INT 24
15473: PUSH
15474: LD_INT 3
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: LD_INT 47
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: PUSH
15489: LD_INT 5
15491: PUSH
15492: LD_INT 3
15494: PUSH
15495: LD_INT 2
15497: PUSH
15498: LD_INT 9
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: PUSH
15507: LD_INT 5
15509: PUSH
15510: LD_INT 3
15512: PUSH
15513: LD_INT 2
15515: PUSH
15516: LD_INT 9
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 3
15530: PUSH
15531: LD_INT 2
15533: PUSH
15534: LD_INT 9
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: PUSH
15543: LD_INT 24
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: LD_INT 45
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 24
15563: PUSH
15564: LD_INT 1
15566: PUSH
15567: LD_INT 3
15569: PUSH
15570: LD_INT 45
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: PPUSH
15588: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
15592: LD_INT 4200
15594: PPUSH
15595: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15599: LD_ADDR_VAR 0 2
15603: PUSH
15604: LD_INT 22
15606: PUSH
15607: LD_INT 7
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: LD_INT 21
15616: PUSH
15617: LD_INT 2
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PUSH
15624: LD_INT 3
15626: PUSH
15627: LD_INT 34
15629: PUSH
15630: LD_INT 13
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: PUSH
15641: LD_INT 3
15643: PUSH
15644: LD_INT 34
15646: PUSH
15647: LD_INT 12
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: PUSH
15658: LD_INT 3
15660: PUSH
15661: LD_INT 34
15663: PUSH
15664: LD_INT 51
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: PUSH
15675: LD_INT 3
15677: PUSH
15678: LD_INT 34
15680: PUSH
15681: LD_INT 52
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: PUSH
15705: LD_EXP 124
15709: PUSH
15710: LD_INT 1
15712: ARRAY
15713: DIFF
15714: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15715: LD_ADDR_EXP 121
15719: PUSH
15720: LD_EXP 121
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_EXP 121
15732: PUSH
15733: LD_INT 1
15735: ARRAY
15736: PUSH
15737: LD_VAR 0 2
15741: DIFF
15742: PPUSH
15743: CALL_OW 1
15747: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15748: LD_ADDR_VAR 0 3
15752: PUSH
15753: LD_INT 0
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: CALL_OW 12
15763: ST_TO_ADDR
// p := 0 ;
15764: LD_ADDR_VAR 0 5
15768: PUSH
15769: LD_INT 0
15771: ST_TO_ADDR
// if target then
15772: LD_VAR 0 3
15776: IFFALSE 15969
// begin for i in tmp do
15778: LD_ADDR_VAR 0 1
15782: PUSH
15783: LD_VAR 0 2
15787: PUSH
15788: FOR_IN
15789: IFFALSE 15814
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15791: LD_VAR 0 1
15795: PPUSH
15796: LD_INT 179
15798: PPUSH
15799: LD_INT 209
15801: PPUSH
15802: LD_INT 8
15804: PPUSH
15805: LD_INT 1
15807: PPUSH
15808: CALL_OW 483
15812: GO 15788
15814: POP
15815: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15816: LD_ADDR_VAR 0 2
15820: PUSH
15821: LD_VAR 0 2
15825: PPUSH
15826: LD_INT 24
15828: PUSH
15829: LD_INT 250
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PPUSH
15836: CALL_OW 72
15840: ST_TO_ADDR
// for i in tmp do
15841: LD_ADDR_VAR 0 1
15845: PUSH
15846: LD_VAR 0 2
15850: PUSH
15851: FOR_IN
15852: IFFALSE 15892
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15854: LD_VAR 0 1
15858: PPUSH
15859: LD_INT 179
15861: PPUSH
15862: LD_INT 209
15864: PPUSH
15865: CALL_OW 297
15869: PUSH
15870: LD_INT 9
15872: GREATER
15873: IFFALSE 15890
// ComMoveXY ( i , 179 , 209 ) ;
15875: LD_VAR 0 1
15879: PPUSH
15880: LD_INT 179
15882: PPUSH
15883: LD_INT 209
15885: PPUSH
15886: CALL_OW 111
15890: GO 15851
15892: POP
15893: POP
// wait ( 0 0$1 ) ;
15894: LD_INT 35
15896: PPUSH
15897: CALL_OW 67
// p := Inc ( p ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 5
15910: PPUSH
15911: CALL 110468 0 1
15915: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15916: LD_VAR 0 2
15920: PPUSH
15921: LD_INT 92
15923: PUSH
15924: LD_INT 179
15926: PUSH
15927: LD_INT 209
15929: PUSH
15930: LD_INT 9
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PUSH
15944: LD_VAR 0 2
15948: PUSH
15949: LD_INT 1
15951: MINUS
15952: GREATEREQUAL
15953: IFTRUE 15965
15955: PUSH
15956: LD_VAR 0 5
15960: PUSH
15961: LD_INT 30
15963: GREATER
15964: OR
15965: IFFALSE 15816
// end else
15967: GO 16158
// begin for i in tmp do
15969: LD_ADDR_VAR 0 1
15973: PUSH
15974: LD_VAR 0 2
15978: PUSH
15979: FOR_IN
15980: IFFALSE 16005
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 285
15989: PPUSH
15990: LD_INT 163
15992: PPUSH
15993: LD_INT 8
15995: PPUSH
15996: LD_INT 1
15998: PPUSH
15999: CALL_OW 483
16003: GO 15979
16005: POP
16006: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_VAR 0 2
16016: PPUSH
16017: LD_INT 24
16019: PUSH
16020: LD_INT 250
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 72
16031: ST_TO_ADDR
// for i in tmp do
16032: LD_ADDR_VAR 0 1
16036: PUSH
16037: LD_VAR 0 2
16041: PUSH
16042: FOR_IN
16043: IFFALSE 16083
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 285
16052: PPUSH
16053: LD_INT 163
16055: PPUSH
16056: CALL_OW 297
16060: PUSH
16061: LD_INT 9
16063: GREATER
16064: IFFALSE 16081
// ComMoveXY ( i , 285 , 163 ) ;
16066: LD_VAR 0 1
16070: PPUSH
16071: LD_INT 285
16073: PPUSH
16074: LD_INT 163
16076: PPUSH
16077: CALL_OW 111
16081: GO 16042
16083: POP
16084: POP
// wait ( 0 0$1 ) ;
16085: LD_INT 35
16087: PPUSH
16088: CALL_OW 67
// p := Inc ( p ) ;
16092: LD_ADDR_VAR 0 5
16096: PUSH
16097: LD_VAR 0 5
16101: PPUSH
16102: CALL 110468 0 1
16106: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16107: LD_VAR 0 2
16111: PPUSH
16112: LD_INT 92
16114: PUSH
16115: LD_INT 285
16117: PUSH
16118: LD_INT 163
16120: PUSH
16121: LD_INT 9
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: LIST
16128: LIST
16129: PPUSH
16130: CALL_OW 72
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: LD_INT 1
16142: MINUS
16143: GREATEREQUAL
16144: IFTRUE 16156
16146: PUSH
16147: LD_VAR 0 5
16151: PUSH
16152: LD_INT 30
16154: GREATER
16155: OR
16156: IFFALSE 16007
// end ; repeat wait ( 0 0$1 ) ;
16158: LD_INT 35
16160: PPUSH
16161: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16165: LD_ADDR_VAR 0 2
16169: PUSH
16170: LD_VAR 0 2
16174: PPUSH
16175: LD_INT 50
16177: PUSH
16178: EMPTY
16179: LIST
16180: PPUSH
16181: CALL_OW 72
16185: ST_TO_ADDR
// for i in tmp do
16186: LD_ADDR_VAR 0 1
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: FOR_IN
16197: IFFALSE 16286
// if GetWeapon ( i ) = ru_time_lapser then
16199: LD_VAR 0 1
16203: PPUSH
16204: CALL_OW 264
16208: PUSH
16209: LD_INT 49
16211: EQUAL
16212: IFFALSE 16250
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16214: LD_VAR 0 1
16218: PPUSH
16219: LD_INT 81
16221: PUSH
16222: LD_INT 7
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 69
16233: PPUSH
16234: LD_VAR 0 1
16238: PPUSH
16239: CALL_OW 74
16243: PPUSH
16244: CALL_OW 112
16248: GO 16284
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16250: LD_VAR 0 1
16254: PPUSH
16255: LD_INT 81
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PPUSH
16265: CALL_OW 69
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: CALL_OW 74
16279: PPUSH
16280: CALL_OW 115
16284: GO 16196
16286: POP
16287: POP
// until not tmp ;
16288: LD_VAR 0 2
16292: NOT
16293: IFFALSE 16158
// end ;
16295: PPOPN 5
16297: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16298: LD_EXP 31
16302: IFFALSE 16315
16304: PUSH
16305: LD_EXP 79
16309: PPUSH
16310: CALL_OW 302
16314: AND
16315: IFFALSE 16327
16317: PUSH
16318: LD_OWVAR 67
16322: PUSH
16323: LD_INT 2
16325: GREATER
16326: AND
16327: IFFALSE 16427
16329: GO 16331
16331: DISABLE
// begin enable ;
16332: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16333: LD_EXP 79
16337: PPUSH
16338: LD_INT 245
16340: PPUSH
16341: LD_INT 234
16343: PPUSH
16344: CALL_OW 297
16348: PUSH
16349: LD_INT 6
16351: GREATER
16352: IFFALSE 16371
// ComMoveXY ( Roth , 245 , 234 ) else
16354: LD_EXP 79
16358: PPUSH
16359: LD_INT 245
16361: PPUSH
16362: LD_INT 234
16364: PPUSH
16365: CALL_OW 111
16369: GO 16427
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16371: LD_EXP 79
16375: PPUSH
16376: LD_INT 259
16378: PUSH
16379: LD_INT 235
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 252
16388: PUSH
16389: LD_INT 209
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 275
16398: PUSH
16399: LD_INT 235
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: EMPTY
16407: LIST
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 1
16413: PPUSH
16414: LD_INT 3
16416: PPUSH
16417: CALL_OW 12
16421: ARRAY
16422: PPUSH
16423: CALL 113423 0 2
// end ; end_of_file
16427: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
// missionStage := 13 ;
16434: LD_ADDR_EXP 15
16438: PUSH
16439: LD_INT 13
16441: ST_TO_ADDR
// uc_side := 2 ;
16442: LD_ADDR_OWVAR 20
16446: PUSH
16447: LD_INT 2
16449: ST_TO_ADDR
// uc_nation := 2 ;
16450: LD_ADDR_OWVAR 21
16454: PUSH
16455: LD_INT 2
16457: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16458: LD_ADDR_EXP 97
16462: PUSH
16463: LD_STRING Omar
16465: PPUSH
16466: CALL_OW 25
16470: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16471: LD_EXP 97
16475: PPUSH
16476: LD_INT 4
16478: PPUSH
16479: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16483: LD_EXP 97
16487: PPUSH
16488: LD_INT 242
16490: PPUSH
16491: LD_INT 75
16493: PPUSH
16494: LD_INT 0
16496: PPUSH
16497: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16501: LD_ADDR_EXP 98
16505: PUSH
16506: LD_STRING Heike
16508: PPUSH
16509: CALL_OW 25
16513: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16514: LD_INT 14
16516: PPUSH
16517: LD_INT 3
16519: PPUSH
16520: LD_INT 1
16522: PPUSH
16523: LD_INT 27
16525: PPUSH
16526: LD_INT 100
16528: PPUSH
16529: CALL 75925 0 5
// veh := CreateVehicle ;
16533: LD_ADDR_VAR 0 3
16537: PUSH
16538: CALL_OW 45
16542: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16543: LD_VAR 0 3
16547: PPUSH
16548: LD_INT 2
16550: NEG
16551: PPUSH
16552: CALL_OW 242
// SetDir ( veh , 4 ) ;
16556: LD_VAR 0 3
16560: PPUSH
16561: LD_INT 4
16563: PPUSH
16564: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16568: LD_VAR 0 3
16572: PPUSH
16573: LD_INT 241
16575: PPUSH
16576: LD_INT 72
16578: PPUSH
16579: LD_INT 0
16581: PPUSH
16582: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16586: LD_EXP 98
16590: PPUSH
16591: LD_VAR 0 3
16595: PPUSH
16596: CALL_OW 52
// if KhatamStatus then
16600: LD_EXP 8
16604: IFFALSE 16667
// begin Khatam := NewCharacter ( Khatam ) ;
16606: LD_ADDR_EXP 99
16610: PUSH
16611: LD_STRING Khatam
16613: PPUSH
16614: CALL_OW 25
16618: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16619: LD_EXP 99
16623: PPUSH
16624: LD_INT 245
16626: PPUSH
16627: LD_INT 78
16629: PPUSH
16630: LD_INT 3
16632: PPUSH
16633: LD_INT 0
16635: PPUSH
16636: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16640: LD_EXP 99
16644: PPUSH
16645: LD_INT 4
16647: PPUSH
16648: LD_INT 10
16650: PPUSH
16651: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16655: LD_EXP 99
16659: PPUSH
16660: LD_INT 4
16662: PPUSH
16663: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16667: LD_ADDR_VAR 0 2
16671: PUSH
16672: DOUBLE
16673: LD_INT 1
16675: DEC
16676: ST_TO_ADDR
16677: LD_INT 2
16679: PUSH
16680: LD_INT 2
16682: PUSH
16683: LD_INT 3
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: PUSH
16695: LD_OWVAR 67
16699: ARRAY
16700: PUSH
16701: FOR_TO
16702: IFFALSE 16768
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16704: LD_INT 0
16706: PPUSH
16707: LD_INT 6
16709: PUSH
16710: LD_OWVAR 67
16714: PLUS
16715: PPUSH
16716: CALL_OW 384
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 4
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16730: LD_VAR 0 4
16734: PPUSH
16735: LD_INT 28
16737: PUSH
16738: LD_INT 29
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: PUSH
16745: LD_VAR 0 2
16749: PUSH
16750: LD_INT 2
16752: MOD
16753: PUSH
16754: LD_INT 1
16756: PLUS
16757: ARRAY
16758: PPUSH
16759: LD_INT 0
16761: PPUSH
16762: CALL_OW 49
// end ;
16766: GO 16701
16768: POP
16769: POP
// for i = 1 to 6 do
16770: LD_ADDR_VAR 0 2
16774: PUSH
16775: DOUBLE
16776: LD_INT 1
16778: DEC
16779: ST_TO_ADDR
16780: LD_INT 6
16782: PUSH
16783: FOR_TO
16784: IFFALSE 16829
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16786: LD_INT 0
16788: PPUSH
16789: LD_INT 6
16791: PUSH
16792: LD_OWVAR 67
16796: PLUS
16797: PPUSH
16798: CALL_OW 381
// un := CreateHuman ;
16802: LD_ADDR_VAR 0 4
16806: PUSH
16807: CALL_OW 44
16811: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16812: LD_VAR 0 4
16816: PPUSH
16817: LD_INT 32
16819: PPUSH
16820: LD_INT 0
16822: PPUSH
16823: CALL_OW 49
// end ;
16827: GO 16783
16829: POP
16830: POP
// for i = 1 to 3 do
16831: LD_ADDR_VAR 0 2
16835: PUSH
16836: DOUBLE
16837: LD_INT 1
16839: DEC
16840: ST_TO_ADDR
16841: LD_INT 3
16843: PUSH
16844: FOR_TO
16845: IFFALSE 16893
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16847: LD_INT 0
16849: PPUSH
16850: LD_INT 8
16852: PPUSH
16853: LD_INT 6
16855: PUSH
16856: LD_OWVAR 67
16860: PLUS
16861: PPUSH
16862: CALL_OW 380
// un := CreateHuman ;
16866: LD_ADDR_VAR 0 4
16870: PUSH
16871: CALL_OW 44
16875: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16876: LD_VAR 0 4
16880: PPUSH
16881: LD_INT 32
16883: PPUSH
16884: LD_INT 0
16886: PPUSH
16887: CALL_OW 49
// end ;
16891: GO 16844
16893: POP
16894: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16895: LD_ADDR_VAR 0 2
16899: PUSH
16900: DOUBLE
16901: LD_INT 1
16903: DEC
16904: ST_TO_ADDR
16905: LD_INT 2
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: LD_INT 4
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: LD_OWVAR 67
16927: ARRAY
16928: PUSH
16929: FOR_TO
16930: IFFALSE 17020
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16932: LD_INT 14
16934: PPUSH
16935: LD_INT 2
16937: PPUSH
16938: LD_INT 1
16940: PPUSH
16941: LD_INT 28
16943: PPUSH
16944: LD_INT 80
16946: PPUSH
16947: CALL 75925 0 5
// veh := CreateVehicle ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: CALL_OW 45
16960: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16961: LD_VAR 0 3
16965: PPUSH
16966: LD_INT 3
16968: PPUSH
16969: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16973: LD_VAR 0 3
16977: PPUSH
16978: LD_INT 29
16980: PPUSH
16981: LD_INT 0
16983: PPUSH
16984: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16988: LD_INT 0
16990: PPUSH
16991: LD_INT 6
16993: PUSH
16994: LD_OWVAR 67
16998: PLUS
16999: PPUSH
17000: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17004: CALL_OW 44
17008: PPUSH
17009: LD_VAR 0 3
17013: PPUSH
17014: CALL_OW 52
// end ;
17018: GO 16929
17020: POP
17021: POP
// for i = 1 to 5 + Difficulty do
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: DOUBLE
17028: LD_INT 1
17030: DEC
17031: ST_TO_ADDR
17032: LD_INT 5
17034: PUSH
17035: LD_OWVAR 67
17039: PLUS
17040: PUSH
17041: FOR_TO
17042: IFFALSE 17169
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
17044: LD_INT 14
17046: PPUSH
17047: LD_INT 1
17049: PPUSH
17050: LD_INT 3
17052: PPUSH
17053: CALL_OW 12
17057: PPUSH
17058: LD_INT 1
17060: PPUSH
17061: LD_INT 28
17063: PUSH
17064: LD_INT 26
17066: PUSH
17067: LD_INT 27
17069: PUSH
17070: LD_INT 25
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: PUSH
17079: LD_VAR 0 2
17083: PUSH
17084: LD_INT 4
17086: MOD
17087: PUSH
17088: LD_INT 1
17090: PLUS
17091: ARRAY
17092: PPUSH
17093: LD_INT 80
17095: PPUSH
17096: CALL 75925 0 5
// veh := CreateVehicle ;
17100: LD_ADDR_VAR 0 3
17104: PUSH
17105: CALL_OW 45
17109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17110: LD_VAR 0 3
17114: PPUSH
17115: LD_INT 4
17117: PPUSH
17118: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17122: LD_VAR 0 3
17126: PPUSH
17127: LD_INT 28
17129: PPUSH
17130: LD_INT 0
17132: PPUSH
17133: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17137: LD_INT 0
17139: PPUSH
17140: LD_INT 6
17142: PUSH
17143: LD_OWVAR 67
17147: PLUS
17148: PPUSH
17149: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17153: CALL_OW 44
17157: PPUSH
17158: LD_VAR 0 3
17162: PPUSH
17163: CALL_OW 52
// end ;
17167: GO 17041
17169: POP
17170: POP
// for i = 1 to Difficulty do
17171: LD_ADDR_VAR 0 2
17175: PUSH
17176: DOUBLE
17177: LD_INT 1
17179: DEC
17180: ST_TO_ADDR
17181: LD_OWVAR 67
17185: PUSH
17186: FOR_TO
17187: IFFALSE 17247
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17189: LD_INT 14
17191: PPUSH
17192: LD_INT 3
17194: PPUSH
17195: LD_INT 5
17197: PPUSH
17198: LD_INT 29
17200: PPUSH
17201: LD_INT 80
17203: PPUSH
17204: CALL 75925 0 5
// veh := CreateVehicle ;
17208: LD_ADDR_VAR 0 3
17212: PUSH
17213: CALL_OW 45
17217: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17218: LD_VAR 0 3
17222: PPUSH
17223: LD_INT 4
17225: PPUSH
17226: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17230: LD_VAR 0 3
17234: PPUSH
17235: LD_INT 28
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: CALL_OW 49
// end ;
17245: GO 17186
17247: POP
17248: POP
// end ;
17249: LD_VAR 0 1
17253: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PPUSH
17264: CALL_OW 69
17268: IFFALSE 17647
17270: GO 17272
17272: DISABLE
17273: LD_INT 0
17275: PPUSH
17276: PPUSH
17277: PPUSH
17278: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17279: LD_ADDR_VAR 0 3
17283: PUSH
17284: LD_INT 22
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PUSH
17294: LD_INT 25
17296: PUSH
17297: LD_INT 4
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PPUSH
17308: CALL_OW 69
17312: PUSH
17313: LD_EXP 99
17317: DIFF
17318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17319: LD_ADDR_VAR 0 2
17323: PUSH
17324: LD_INT 22
17326: PUSH
17327: LD_INT 2
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 69
17338: PUSH
17339: LD_EXP 99
17343: PUSH
17344: LD_VAR 0 3
17348: UNION
17349: DIFF
17350: ST_TO_ADDR
// if Khatam then
17351: LD_EXP 99
17355: IFFALSE 17372
// ComMoveXY ( Khatam , 211 , 92 ) ;
17357: LD_EXP 99
17361: PPUSH
17362: LD_INT 211
17364: PPUSH
17365: LD_INT 92
17367: PPUSH
17368: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17372: LD_INT 197
17374: PPUSH
17375: LD_INT 80
17377: PPUSH
17378: LD_INT 2
17380: PPUSH
17381: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17385: LD_INT 213
17387: PPUSH
17388: LD_INT 90
17390: PPUSH
17391: LD_INT 2
17393: PPUSH
17394: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17398: LD_INT 215
17400: PPUSH
17401: LD_INT 129
17403: PPUSH
17404: LD_INT 2
17406: PPUSH
17407: CALL_OW 441
// if sci then
17411: LD_VAR 0 3
17415: IFFALSE 17436
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17417: LD_VAR 0 3
17421: PUSH
17422: LD_INT 1
17424: ARRAY
17425: PPUSH
17426: LD_INT 197
17428: PPUSH
17429: LD_INT 80
17431: PPUSH
17432: CALL_OW 158
// if sci > 1 then
17436: LD_VAR 0 3
17440: PUSH
17441: LD_INT 1
17443: GREATER
17444: IFFALSE 17465
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17446: LD_VAR 0 3
17450: PUSH
17451: LD_INT 2
17453: ARRAY
17454: PPUSH
17455: LD_INT 213
17457: PPUSH
17458: LD_INT 90
17460: PPUSH
17461: CALL_OW 158
// if sci > 2 then
17465: LD_VAR 0 3
17469: PUSH
17470: LD_INT 2
17472: GREATER
17473: IFFALSE 17494
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17475: LD_VAR 0 3
17479: PUSH
17480: LD_INT 3
17482: ARRAY
17483: PPUSH
17484: LD_INT 215
17486: PPUSH
17487: LD_INT 129
17489: PPUSH
17490: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17494: LD_VAR 0 2
17498: PPUSH
17499: LD_INT 195
17501: PPUSH
17502: LD_INT 102
17504: PPUSH
17505: CALL_OW 114
// wait ( 0 0$5 ) ;
17509: LD_INT 175
17511: PPUSH
17512: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17516: LD_INT 70
17518: PPUSH
17519: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17523: LD_ADDR_VAR 0 4
17527: PUSH
17528: LD_INT 92
17530: PUSH
17531: LD_INT 195
17533: PUSH
17534: LD_INT 102
17536: PUSH
17537: LD_INT 36
17539: PUSH
17540: EMPTY
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: PUSH
17546: LD_INT 22
17548: PUSH
17549: LD_INT 1
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PPUSH
17560: CALL_OW 69
17564: ST_TO_ADDR
// for i in tmp do
17565: LD_ADDR_VAR 0 1
17569: PUSH
17570: LD_VAR 0 2
17574: PUSH
17575: FOR_IN
17576: IFFALSE 17627
// if enemy then
17578: LD_VAR 0 4
17582: IFFALSE 17610
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17584: LD_VAR 0 1
17588: PPUSH
17589: LD_VAR 0 4
17593: PPUSH
17594: LD_VAR 0 1
17598: PPUSH
17599: CALL_OW 74
17603: PPUSH
17604: CALL_OW 115
17608: GO 17625
// ComAgressiveMove ( i , 195 , 102 ) ;
17610: LD_VAR 0 1
17614: PPUSH
17615: LD_INT 195
17617: PPUSH
17618: LD_INT 102
17620: PPUSH
17621: CALL_OW 114
17625: GO 17575
17627: POP
17628: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17629: LD_VAR 0 2
17633: PPUSH
17634: LD_INT 50
17636: PUSH
17637: EMPTY
17638: LIST
17639: PPUSH
17640: CALL_OW 72
17644: NOT
17645: IFFALSE 17516
// end ; end_of_file
17647: PPOPN 4
17649: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad , hasSomethingToSay ; begin
17650: LD_INT 0
17652: PPUSH
17653: PPUSH
17654: PPUSH
17655: PPUSH
17656: PPUSH
17657: PPUSH
17658: PPUSH
17659: PPUSH
17660: PPUSH
17661: PPUSH
// Video ( true ) ;
17662: LD_INT 1
17664: PPUSH
17665: CALL 109067 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17669: LD_ADDR_VAR 0 5
17673: PUSH
17674: LD_INT 7
17676: PPUSH
17677: LD_INT 0
17679: PPUSH
17680: CALL_OW 517
17684: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17685: LD_ADDR_VAR 0 2
17689: PUSH
17690: DOUBLE
17691: LD_INT 1
17693: DEC
17694: ST_TO_ADDR
17695: LD_VAR 0 5
17699: PUSH
17700: LD_INT 1
17702: ARRAY
17703: PUSH
17704: FOR_TO
17705: IFFALSE 17750
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17707: LD_VAR 0 5
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: LD_VAR 0 5
17726: PUSH
17727: LD_INT 2
17729: ARRAY
17730: PUSH
17731: LD_VAR 0 2
17735: ARRAY
17736: PPUSH
17737: LD_INT 1
17739: PPUSH
17740: LD_INT 15
17742: NEG
17743: PPUSH
17744: CALL 108979 0 4
17748: GO 17704
17750: POP
17751: POP
// CenterNowOnUnits ( Powell ) ;
17752: LD_EXP 61
17756: PPUSH
17757: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17761: LD_ADDR_VAR 0 5
17765: PUSH
17766: LD_EXP 59
17770: PUSH
17771: EMPTY
17772: LIST
17773: ST_TO_ADDR
// if GirlNewVeh then
17774: LD_EXP 60
17778: IFFALSE 17796
// tmp := tmp ^ GirlNewVeh ;
17780: LD_ADDR_VAR 0 5
17784: PUSH
17785: LD_VAR 0 5
17789: PUSH
17790: LD_EXP 60
17794: ADD
17795: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17796: LD_VAR 0 5
17800: PPUSH
17801: LD_INT 60
17803: PPUSH
17804: LD_INT 109
17806: PPUSH
17807: CALL_OW 111
// if KappaStatus then
17811: LD_EXP 2
17815: IFFALSE 17867
// begin Say ( JMM , D1nT-JMM-1 ) ;
17817: LD_EXP 40
17821: PPUSH
17822: LD_STRING D1nT-JMM-1
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17829: LD_EXP 61
17833: PPUSH
17834: LD_STRING D1T-Pow-1
17836: PPUSH
17837: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17841: LD_EXP 40
17845: PPUSH
17846: LD_STRING D1T-JMM-2
17848: PPUSH
17849: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17853: LD_EXP 61
17857: PPUSH
17858: LD_STRING D1T-Pow-2
17860: PPUSH
17861: CALL_OW 88
// end else
17865: GO 18073
// if JMMGirlStatus then
17867: LD_EXP 6
17871: IFFALSE 18016
// begin Say ( JMM , D1T-JMM-1 ) ;
17873: LD_EXP 40
17877: PPUSH
17878: LD_STRING D1T-JMM-1
17880: PPUSH
17881: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17885: LD_EXP 61
17889: PPUSH
17890: LD_STRING D1T-Pow-1
17892: PPUSH
17893: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17897: LD_EXP 40
17901: PPUSH
17902: LD_STRING D1T-JMM-3
17904: PPUSH
17905: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17909: LD_EXP 61
17913: PPUSH
17914: LD_STRING D1T-Pow-3
17916: PPUSH
17917: CALL_OW 88
// if JMMGirl then
17921: LD_EXP 7
17925: IFFALSE 18014
// begin case JMMGirl of 1 :
17927: LD_EXP 7
17931: PUSH
17932: LD_INT 1
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17955
17940: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17941: LD_EXP 41
17945: PPUSH
17946: LD_STRING D1T-Joan-3
17948: PPUSH
17949: CALL_OW 88
17953: GO 18002
17955: LD_INT 2
17957: DOUBLE
17958: EQUAL
17959: IFTRUE 17963
17961: GO 17978
17963: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17964: LD_EXP 43
17968: PPUSH
17969: LD_STRING D1T-Lisa-3
17971: PPUSH
17972: CALL_OW 88
17976: GO 18002
17978: LD_INT 3
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18001
17986: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17987: LD_EXP 55
17991: PPUSH
17992: LD_STRING D1T-Con-3
17994: PPUSH
17995: CALL_OW 88
17999: GO 18002
18001: POP
// Say ( Powell , D1T-Pow-4 ) ;
18002: LD_EXP 61
18006: PPUSH
18007: LD_STRING D1T-Pow-4
18009: PPUSH
18010: CALL_OW 88
// end ; end else
18014: GO 18073
// if not FastEnd then
18016: LD_EXP 11
18020: NOT
18021: IFFALSE 18049
// begin Say ( JMM , D1T-JMM-4 ) ;
18023: LD_EXP 40
18027: PPUSH
18028: LD_STRING D1T-JMM-4
18030: PPUSH
18031: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
18035: LD_EXP 61
18039: PPUSH
18040: LD_STRING D1T-Pow-5
18042: PPUSH
18043: CALL_OW 88
// end else
18047: GO 18073
// begin Say ( JMM , D1nT-JMM-1 ) ;
18049: LD_EXP 40
18053: PPUSH
18054: LD_STRING D1nT-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18061: LD_EXP 61
18065: PPUSH
18066: LD_STRING D1nT-Pow-1
18068: PPUSH
18069: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18073: LD_INT 3
18075: PPUSH
18076: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18080: LD_EXP 59
18084: PPUSH
18085: CALL_OW 314
18089: NOT
18090: IFFALSE 18073
// ComExitVehicle ( JMM ) ;
18092: LD_EXP 40
18096: PPUSH
18097: CALL_OW 121
// repeat wait ( 3 ) ;
18101: LD_INT 3
18103: PPUSH
18104: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18108: LD_EXP 40
18112: PPUSH
18113: CALL_OW 310
18117: NOT
18118: IFFALSE 18101
// ComMoveXY ( JMM , 60 , 94 ) ;
18120: LD_EXP 40
18124: PPUSH
18125: LD_INT 60
18127: PPUSH
18128: LD_INT 94
18130: PPUSH
18131: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18135: LD_EXP 40
18139: PPUSH
18140: LD_EXP 61
18144: PPUSH
18145: CALL_OW 179
// if Joan then
18149: LD_EXP 41
18153: IFFALSE 18207
// begin ComExitVehicle ( Joan ) ;
18155: LD_EXP 41
18159: PPUSH
18160: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18164: LD_EXP 41
18168: PPUSH
18169: LD_INT 35
18171: PPUSH
18172: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18176: LD_EXP 41
18180: PPUSH
18181: LD_INT 65
18183: PPUSH
18184: LD_INT 104
18186: PPUSH
18187: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18191: LD_EXP 41
18195: PPUSH
18196: LD_EXP 40
18200: PPUSH
18201: CALL_OW 179
// end else
18205: GO 18345
// if Lisa and JMMGirl = 2 then
18207: LD_EXP 43
18211: IFFALSE 18223
18213: PUSH
18214: LD_EXP 7
18218: PUSH
18219: LD_INT 2
18221: EQUAL
18222: AND
18223: IFFALSE 18277
// begin ComExitVehicle ( Lisa ) ;
18225: LD_EXP 43
18229: PPUSH
18230: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18234: LD_EXP 43
18238: PPUSH
18239: LD_INT 35
18241: PPUSH
18242: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18246: LD_EXP 43
18250: PPUSH
18251: LD_INT 65
18253: PPUSH
18254: LD_INT 104
18256: PPUSH
18257: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18261: LD_EXP 43
18265: PPUSH
18266: LD_EXP 40
18270: PPUSH
18271: CALL_OW 179
// end else
18275: GO 18345
// if Connie and JMMGirl = 3 then
18277: LD_EXP 55
18281: IFFALSE 18293
18283: PUSH
18284: LD_EXP 7
18288: PUSH
18289: LD_INT 3
18291: EQUAL
18292: AND
18293: IFFALSE 18345
// begin ComExitVehicle ( Connie ) ;
18295: LD_EXP 55
18299: PPUSH
18300: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18304: LD_EXP 55
18308: PPUSH
18309: LD_INT 35
18311: PPUSH
18312: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18316: LD_EXP 55
18320: PPUSH
18321: LD_INT 65
18323: PPUSH
18324: LD_INT 104
18326: PPUSH
18327: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18331: LD_EXP 55
18335: PPUSH
18336: LD_EXP 40
18340: PPUSH
18341: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18345: LD_INT 35
18347: PPUSH
18348: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18352: LD_EXP 40
18356: PPUSH
18357: LD_EXP 61
18361: PPUSH
18362: CALL_OW 296
18366: PUSH
18367: LD_INT 8
18369: LESS
18370: IFFALSE 18345
// wait ( 0 0$0.5 ) ;
18372: LD_INT 18
18374: PPUSH
18375: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18379: LD_EXP 40
18383: PPUSH
18384: LD_STRING D1-JMM-1
18386: PPUSH
18387: CALL_OW 88
// async ;
18391: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18392: LD_EXP 61
18396: PPUSH
18397: LD_STRING D1-Pow-1
18399: PPUSH
18400: CALL_OW 88
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18418
// wait ( 0 0$2 ) ;
18411: LD_INT 70
18413: PPUSH
18414: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18418: LD_INT 170
18420: PPUSH
18421: LD_INT 99
18423: PPUSH
18424: LD_INT 1
18426: PPUSH
18427: LD_INT 6
18429: NEG
18430: PPUSH
18431: CALL 108979 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18435: LD_INT 174
18437: PPUSH
18438: LD_INT 115
18440: PPUSH
18441: LD_INT 1
18443: PPUSH
18444: LD_INT 6
18446: NEG
18447: PPUSH
18448: CALL 108979 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18452: LD_INT 169
18454: PPUSH
18455: LD_INT 71
18457: PPUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_INT 6
18463: NEG
18464: PPUSH
18465: CALL 108979 0 4
// if not dialogue_skipped then
18469: LD_OWVAR 59
18473: NOT
18474: IFFALSE 18493
// begin CenterOnXY ( 170 , 99 ) ;
18476: LD_INT 170
18478: PPUSH
18479: LD_INT 99
18481: PPUSH
18482: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18486: LD_INT 80
18488: PPUSH
18489: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18493: LD_INT 75
18495: PPUSH
18496: LD_INT 53
18498: PPUSH
18499: LD_INT 1
18501: PPUSH
18502: LD_INT 9
18504: NEG
18505: PPUSH
18506: CALL 108979 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18510: LD_INT 54
18512: PPUSH
18513: LD_INT 42
18515: PPUSH
18516: LD_INT 1
18518: PPUSH
18519: LD_INT 9
18521: NEG
18522: PPUSH
18523: CALL 108979 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18527: LD_INT 62
18529: PPUSH
18530: LD_INT 51
18532: PPUSH
18533: LD_INT 1
18535: PPUSH
18536: LD_INT 9
18538: NEG
18539: PPUSH
18540: CALL 108979 0 4
// if not dialogue_skipped then
18544: LD_OWVAR 59
18548: NOT
18549: IFFALSE 18568
// begin CenterOnXY ( 75 , 53 ) ;
18551: LD_INT 75
18553: PPUSH
18554: LD_INT 53
18556: PPUSH
18557: CALL_OW 84
// wait ( 0 0$4 ) ;
18561: LD_INT 140
18563: PPUSH
18564: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18568: LD_EXP 61
18572: PPUSH
18573: CALL_OW 87
// if not dialogue_skipped then
18577: LD_OWVAR 59
18581: NOT
18582: IFFALSE 18591
// wait ( 0 0$2 ) ;
18584: LD_INT 70
18586: PPUSH
18587: CALL_OW 67
// sync ;
18591: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18592: LD_EXP 40
18596: PPUSH
18597: LD_STRING D1-JMM-2
18599: PPUSH
18600: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18604: LD_EXP 61
18608: PPUSH
18609: LD_STRING D1-Pow-2
18611: PPUSH
18612: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18616: LD_EXP 40
18620: PPUSH
18621: LD_STRING D1-JMM-3
18623: PPUSH
18624: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18628: LD_EXP 61
18632: PPUSH
18633: LD_STRING D1-Pow-3
18635: PPUSH
18636: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18640: LD_EXP 40
18644: PPUSH
18645: LD_STRING D1-JMM-4
18647: PPUSH
18648: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18652: LD_EXP 61
18656: PPUSH
18657: LD_STRING D1-Pow-4
18659: PPUSH
18660: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18664: LD_EXP 40
18668: PPUSH
18669: LD_STRING D1-JMM-5
18671: PPUSH
18672: CALL_OW 88
// async ;
18676: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18677: LD_EXP 61
18681: PPUSH
18682: LD_STRING D1-Pow-5
18684: PPUSH
18685: CALL_OW 88
// if not dialogue_skipped then
18689: LD_OWVAR 59
18693: NOT
18694: IFFALSE 18703
// wait ( 0 0$3.6 ) ;
18696: LD_INT 126
18698: PPUSH
18699: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18703: LD_INT 134
18705: PPUSH
18706: LD_INT 210
18708: PPUSH
18709: LD_INT 1
18711: PPUSH
18712: LD_INT 11
18714: NEG
18715: PPUSH
18716: CALL 108979 0 4
// if not dialogue_skipped then
18720: LD_OWVAR 59
18724: NOT
18725: IFFALSE 18744
// begin CenterOnXY ( 134 , 210 ) ;
18727: LD_INT 134
18729: PPUSH
18730: LD_INT 210
18732: PPUSH
18733: CALL_OW 84
// wait ( 0 0$2 ) ;
18737: LD_INT 70
18739: PPUSH
18740: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18744: LD_INT 101
18746: PPUSH
18747: LD_INT 159
18749: PPUSH
18750: LD_INT 1
18752: PPUSH
18753: LD_INT 10
18755: NEG
18756: PPUSH
18757: CALL 108979 0 4
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18785
// begin CenterOnXY ( 101 , 159 ) ;
18768: LD_INT 101
18770: PPUSH
18771: LD_INT 159
18773: PPUSH
18774: CALL_OW 84
// wait ( 0 0$2 ) ;
18778: LD_INT 70
18780: PPUSH
18781: CALL_OW 67
// end ; sync ;
18785: SYNC
// CenterNowOnUnits ( Powell ) ;
18786: LD_EXP 61
18790: PPUSH
18791: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18795: LD_ADDR_VAR 0 6
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 3
18808: PUSH
18809: LD_INT 4
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: LD_INT 6
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: ST_TO_ADDR
// if not dialogue_skipped then
18826: LD_OWVAR 59
18830: NOT
18831: IFFALSE 19002
// begin game_speed := 4 ;
18833: LD_ADDR_OWVAR 65
18837: PUSH
18838: LD_INT 4
18840: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18841: LD_INT 210
18843: PPUSH
18844: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18848: LD_ADDR_VAR 0 7
18852: PUSH
18853: LD_STRING Q1
18855: PPUSH
18856: LD_VAR 0 6
18860: PPUSH
18861: CALL_OW 98
18865: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18866: LD_ADDR_VAR 0 7
18870: PUSH
18871: LD_STRING Q1
18873: PPUSH
18874: LD_VAR 0 6
18878: PPUSH
18879: CALL_OW 98
18883: ST_TO_ADDR
// options := options diff dec ;
18884: LD_ADDR_VAR 0 6
18888: PUSH
18889: LD_VAR 0 6
18893: PUSH
18894: LD_VAR 0 7
18898: DIFF
18899: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18900: LD_VAR 0 7
18904: PPUSH
18905: LD_VAR 0 6
18909: PPUSH
18910: CALL 20690 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18914: LD_VAR 0 7
18918: PUSH
18919: LD_INT 5
18921: PUSH
18922: LD_INT 6
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: IN
18929: IFTRUE 18941
18931: PUSH
18932: LD_VAR 0 6
18936: PUSH
18937: LD_INT 2
18939: EQUAL
18940: OR
18941: IFFALSE 18866
// if not ( dec in [ 5 , 6 ] ) then
18943: LD_VAR 0 7
18947: PUSH
18948: LD_INT 5
18950: PUSH
18951: LD_INT 6
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: IN
18958: NOT
18959: IFFALSE 19002
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18961: LD_ADDR_VAR 0 7
18965: PUSH
18966: LD_STRING Q1a
18968: PPUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 2
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PPUSH
18979: CALL_OW 98
18983: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18984: LD_VAR 0 7
18988: PUSH
18989: LD_INT 4
18991: PLUS
18992: PPUSH
18993: LD_VAR 0 6
18997: PPUSH
18998: CALL 20690 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
19002: LD_INT 81
19004: PPUSH
19005: LD_INT 127
19007: PPUSH
19008: CALL_OW 84
// amount := 8 ;
19012: LD_ADDR_VAR 0 8
19016: PUSH
19017: LD_INT 8
19019: ST_TO_ADDR
// macmilan_squad := [ ] ;
19020: LD_ADDR_VAR 0 9
19024: PUSH
19025: EMPTY
19026: ST_TO_ADDR
// if vip < amount then
19027: LD_EXP 62
19031: PUSH
19032: LD_VAR 0 8
19036: LESS
19037: IFFALSE 19092
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) else
19039: LD_ADDR_VAR 0 5
19043: PUSH
19044: LD_EXP 62
19048: PUSH
19049: LD_INT 22
19051: PUSH
19052: LD_INT 4
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 23
19061: PUSH
19062: LD_INT 1
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PUSH
19069: LD_INT 21
19071: PUSH
19072: LD_INT 1
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: PUSH
19079: EMPTY
19080: LIST
19081: LIST
19082: LIST
19083: PPUSH
19084: CALL_OW 69
19088: UNION
19089: ST_TO_ADDR
19090: GO 19102
// tmp := vip ;
19092: LD_ADDR_VAR 0 5
19096: PUSH
19097: LD_EXP 62
19101: ST_TO_ADDR
// tmp := tmp diff Powell ;
19102: LD_ADDR_VAR 0 5
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: LD_EXP 61
19116: DIFF
19117: ST_TO_ADDR
// if tmp < amount then
19118: LD_VAR 0 5
19122: PUSH
19123: LD_VAR 0 8
19127: LESS
19128: IFFALSE 19140
// amount := tmp ;
19130: LD_ADDR_VAR 0 8
19134: PUSH
19135: LD_VAR 0 5
19139: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19140: LD_VAR 0 5
19144: PUSH
19145: LD_INT 1
19147: ARRAY
19148: PPUSH
19149: CALL_OW 257
19153: PUSH
19154: LD_INT 2
19156: NONEQUAL
19157: IFFALSE 19255
// begin if IsInUnit ( tmp [ 1 ] ) then
19159: LD_VAR 0 5
19163: PUSH
19164: LD_INT 1
19166: ARRAY
19167: PPUSH
19168: CALL_OW 310
19172: IFFALSE 19187
// ComExitBuilding ( tmp [ 1 ] ) ;
19174: LD_VAR 0 5
19178: PUSH
19179: LD_INT 1
19181: ARRAY
19182: PPUSH
19183: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19187: LD_INT 387
19189: PPUSH
19190: CALL_OW 313
19194: PUSH
19195: LD_INT 6
19197: EQUAL
19198: IFFALSE 19223
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19200: LD_INT 387
19202: PPUSH
19203: CALL_OW 313
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: PPUSH
19212: CALL_OW 122
// wait ( 3 ) ;
19216: LD_INT 3
19218: PPUSH
19219: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19223: LD_VAR 0 5
19227: PUSH
19228: LD_INT 1
19230: ARRAY
19231: PPUSH
19232: LD_INT 387
19234: PPUSH
19235: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19239: LD_VAR 0 5
19243: PUSH
19244: LD_INT 1
19246: ARRAY
19247: PPUSH
19248: LD_INT 2
19250: PPUSH
19251: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19255: LD_EXP 40
19259: PPUSH
19260: LD_INT 82
19262: PPUSH
19263: LD_INT 129
19265: PPUSH
19266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19270: LD_EXP 40
19274: PPUSH
19275: LD_EXP 61
19279: PPUSH
19280: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19284: LD_INT 22
19286: PUSH
19287: LD_INT 1
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PPUSH
19294: CALL_OW 69
19298: PUSH
19299: LD_EXP 40
19303: DIFF
19304: PPUSH
19305: LD_INT 84
19307: PPUSH
19308: LD_INT 128
19310: PPUSH
19311: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19315: LD_INT 22
19317: PUSH
19318: LD_INT 1
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PPUSH
19325: CALL_OW 69
19329: PUSH
19330: LD_EXP 40
19334: DIFF
19335: PPUSH
19336: LD_EXP 40
19340: PPUSH
19341: CALL_OW 179
// for i = 1 to amount do
19345: LD_ADDR_VAR 0 2
19349: PUSH
19350: DOUBLE
19351: LD_INT 1
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 8
19359: PUSH
19360: FOR_TO
19361: IFFALSE 19531
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19363: LD_ADDR_VAR 0 9
19367: PUSH
19368: LD_VAR 0 9
19372: PUSH
19373: LD_VAR 0 5
19377: PUSH
19378: LD_VAR 0 2
19382: ARRAY
19383: ADD
19384: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19385: LD_VAR 0 5
19389: PUSH
19390: LD_VAR 0 2
19394: ARRAY
19395: PPUSH
19396: CALL_OW 310
19400: IFFALSE 19417
// AddComExitBuilding ( tmp [ i ] ) ;
19402: LD_VAR 0 5
19406: PUSH
19407: LD_VAR 0 2
19411: ARRAY
19412: PPUSH
19413: CALL_OW 182
// if i = 2 and JMMNewVeh then
19417: LD_VAR 0 2
19421: PUSH
19422: LD_INT 2
19424: EQUAL
19425: IFFALSE 19433
19427: PUSH
19428: LD_EXP 59
19432: AND
19433: IFFALSE 19491
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19435: LD_VAR 0 5
19439: PUSH
19440: LD_VAR 0 2
19444: ARRAY
19445: PPUSH
19446: LD_EXP 59
19450: PPUSH
19451: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19455: LD_VAR 0 5
19459: PUSH
19460: LD_VAR 0 2
19464: ARRAY
19465: PPUSH
19466: LD_INT 86
19468: PPUSH
19469: LD_INT 133
19471: PPUSH
19472: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19476: LD_VAR 0 5
19480: PUSH
19481: LD_VAR 0 2
19485: ARRAY
19486: PPUSH
19487: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19491: LD_VAR 0 5
19495: PUSH
19496: LD_VAR 0 2
19500: ARRAY
19501: PPUSH
19502: LD_INT 8
19504: PPUSH
19505: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19509: LD_VAR 0 5
19513: PUSH
19514: LD_VAR 0 2
19518: ARRAY
19519: PPUSH
19520: LD_EXP 40
19524: PPUSH
19525: CALL_OW 179
// end ;
19529: GO 19360
19531: POP
19532: POP
// if GirlNewVeh then
19533: LD_EXP 60
19537: IFFALSE 19551
// SetSide ( GirlNewVeh , 4 ) ;
19539: LD_EXP 60
19543: PPUSH
19544: LD_INT 4
19546: PPUSH
19547: CALL_OW 235
// if Mike then
19551: LD_EXP 57
19555: IFFALSE 19592
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19557: LD_ADDR_VAR 0 9
19561: PUSH
19562: LD_VAR 0 9
19566: PPUSH
19567: LD_EXP 57
19571: PPUSH
19572: CALL 109095 0 2
19576: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19577: LD_EXP 57
19581: PPUSH
19582: LD_INT 86
19584: PPUSH
19585: LD_INT 133
19587: PPUSH
19588: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19592: LD_INT 35
19594: PPUSH
19595: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19599: LD_VAR 0 9
19603: PPUSH
19604: LD_INT 95
19606: PUSH
19607: LD_INT 9
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: PPUSH
19614: CALL_OW 72
19618: PUSH
19619: LD_INT 0
19621: EQUAL
19622: IFFALSE 19639
19624: PUSH
19625: LD_EXP 40
19629: PPUSH
19630: LD_INT 9
19632: PPUSH
19633: CALL_OW 308
19637: NOT
19638: AND
19639: IFFALSE 19592
// wait ( 0 0$2 ) ;
19641: LD_INT 70
19643: PPUSH
19644: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19648: LD_VAR 0 9
19652: PPUSH
19653: LD_INT 1
19655: PPUSH
19656: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19660: LD_INT 21
19662: PUSH
19663: LD_INT 2
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: PUSH
19670: LD_INT 92
19672: PUSH
19673: LD_INT 83
19675: PUSH
19676: LD_INT 130
19678: PUSH
19679: LD_INT 10
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: LIST
19686: LIST
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: PPUSH
19692: CALL_OW 69
19696: PPUSH
19697: LD_INT 1
19699: PPUSH
19700: CALL_OW 235
// tick := 0 ;
19704: LD_ADDR_OWVAR 1
19708: PUSH
19709: LD_INT 0
19711: ST_TO_ADDR
// Video ( false ) ;
19712: LD_INT 0
19714: PPUSH
19715: CALL 109067 0 1
// ChangeMissionObjectives ( M1 ) ;
19719: LD_STRING M1
19721: PPUSH
19722: CALL_OW 337
// SaveForQuickRestart ;
19726: CALL_OW 22
// missionStart := true ;
19730: LD_ADDR_EXP 13
19734: PUSH
19735: LD_INT 1
19737: ST_TO_ADDR
// missionStage := 2 ;
19738: LD_ADDR_EXP 15
19742: PUSH
19743: LD_INT 2
19745: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19746: LD_INT 35
19748: PPUSH
19749: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19753: LD_ADDR_VAR 0 5
19757: PUSH
19758: LD_INT 22
19760: PUSH
19761: LD_INT 4
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: PUSH
19768: LD_INT 21
19770: PUSH
19771: LD_INT 1
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: PPUSH
19782: CALL_OW 69
19786: PUSH
19787: LD_EXP 61
19791: DIFF
19792: ST_TO_ADDR
// if not tmp then
19793: LD_VAR 0 5
19797: NOT
19798: IFFALSE 19813
// tmp := [ Powell ] ;
19800: LD_ADDR_VAR 0 5
19804: PUSH
19805: LD_EXP 61
19809: PUSH
19810: EMPTY
19811: LIST
19812: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19813: LD_ADDR_VAR 0 4
19817: PUSH
19818: LD_INT 22
19820: PUSH
19821: LD_INT 4
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: PUSH
19828: LD_INT 34
19830: PUSH
19831: LD_INT 12
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: PUSH
19847: LD_INT 1
19849: ARRAY
19850: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19851: LD_VAR 0 5
19855: PUSH
19856: LD_INT 1
19858: ARRAY
19859: PPUSH
19860: CALL_OW 310
19864: IFFALSE 19879
// ComExitBuilding ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19879: LD_VAR 0 5
19883: PUSH
19884: LD_INT 1
19886: ARRAY
19887: PPUSH
19888: LD_VAR 0 4
19892: PPUSH
19893: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19897: LD_VAR 0 5
19901: PUSH
19902: LD_INT 1
19904: ARRAY
19905: PPUSH
19906: LD_INT 80
19908: PPUSH
19909: LD_INT 136
19911: PPUSH
19912: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19916: LD_VAR 0 5
19920: PUSH
19921: LD_INT 1
19923: ARRAY
19924: PPUSH
19925: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19929: LD_VAR 0 5
19933: PUSH
19934: LD_INT 1
19936: ARRAY
19937: PPUSH
19938: LD_INT 59
19940: PPUSH
19941: LD_INT 112
19943: PPUSH
19944: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19948: LD_VAR 0 5
19952: PUSH
19953: LD_INT 1
19955: ARRAY
19956: PPUSH
19957: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 and JMMGirl = 1 then
19961: LD_EXP 41
19965: IFFALSE 19982
19967: PUSH
19968: LD_EXP 41
19972: PPUSH
19973: CALL_OW 255
19977: PUSH
19978: LD_INT 1
19980: EQUAL
19981: AND
19982: IFFALSE 19994
19984: PUSH
19985: LD_EXP 7
19989: PUSH
19990: LD_INT 1
19992: EQUAL
19993: AND
19994: IFFALSE 20020
// begin Say ( Joan , D3W-Joan-1 ) ;
19996: LD_EXP 41
20000: PPUSH
20001: LD_STRING D3W-Joan-1
20003: PPUSH
20004: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20008: LD_EXP 40
20012: PPUSH
20013: LD_STRING D3W-JMM-1
20015: PPUSH
20016: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip and JMMGirl = 2 then
20020: LD_EXP 43
20024: IFFALSE 20041
20026: PUSH
20027: LD_EXP 43
20031: PPUSH
20032: CALL_OW 255
20036: PUSH
20037: LD_INT 1
20039: EQUAL
20040: AND
20041: IFFALSE 20056
20043: PUSH
20044: LD_EXP 43
20048: PUSH
20049: LD_EXP 62
20053: IN
20054: NOT
20055: AND
20056: IFFALSE 20068
20058: PUSH
20059: LD_EXP 7
20063: PUSH
20064: LD_INT 2
20066: EQUAL
20067: AND
20068: IFFALSE 20094
// begin Say ( Lisa , D3W-Lisa-1 ) ;
20070: LD_EXP 43
20074: PPUSH
20075: LD_STRING D3W-Lisa-1
20077: PPUSH
20078: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20082: LD_EXP 40
20086: PPUSH
20087: LD_STRING D3W-JMM-1
20089: PPUSH
20090: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 and JMMGirl = 3 then
20094: LD_EXP 55
20098: IFFALSE 20115
20100: PUSH
20101: LD_EXP 55
20105: PPUSH
20106: CALL_OW 255
20110: PUSH
20111: LD_INT 1
20113: EQUAL
20114: AND
20115: IFFALSE 20127
20117: PUSH
20118: LD_EXP 7
20122: PUSH
20123: LD_INT 3
20125: EQUAL
20126: AND
20127: IFFALSE 20153
// begin Say ( Connie , D3W-Con-1 ) ;
20129: LD_EXP 55
20133: PPUSH
20134: LD_STRING D3W-Con-1
20136: PPUSH
20137: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20141: LD_EXP 40
20145: PPUSH
20146: LD_STRING D3W-JMM-1
20148: PPUSH
20149: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20153: LD_INT 18
20155: PPUSH
20156: CALL_OW 67
// hasSomethingToSay := false ;
20160: LD_ADDR_VAR 0 10
20164: PUSH
20165: LD_INT 0
20167: ST_TO_ADDR
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20168: LD_EXP 43
20172: PUSH
20173: LD_EXP 62
20177: IN
20178: IFFALSE 20195
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: CALL_OW 255
20190: PUSH
20191: LD_INT 1
20193: EQUAL
20194: AND
20195: IFFALSE 20219
// begin hasSomethingToSay := true ;
20197: LD_ADDR_VAR 0 10
20201: PUSH
20202: LD_INT 1
20204: ST_TO_ADDR
// Say ( Lisa , D3nW-Lisa-1 ) ;
20205: LD_EXP 43
20209: PPUSH
20210: LD_STRING D3nW-Lisa-1
20212: PPUSH
20213: CALL_OW 88
// end else
20217: GO 20523
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20219: LD_EXP 46
20223: PUSH
20224: LD_EXP 62
20228: IN
20229: IFFALSE 20246
20231: PUSH
20232: LD_EXP 46
20236: PPUSH
20237: CALL_OW 255
20241: PUSH
20242: LD_INT 1
20244: EQUAL
20245: AND
20246: IFFALSE 20270
// begin hasSomethingToSay := true ;
20248: LD_ADDR_VAR 0 10
20252: PUSH
20253: LD_INT 1
20255: ST_TO_ADDR
// Say ( Cyrus , D3nW-Cyrus-1 ) ;
20256: LD_EXP 46
20260: PPUSH
20261: LD_STRING D3nW-Cyrus-1
20263: PPUSH
20264: CALL_OW 88
// end else
20268: GO 20523
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20270: LD_EXP 45
20274: PUSH
20275: LD_EXP 62
20279: IN
20280: IFFALSE 20297
20282: PUSH
20283: LD_EXP 45
20287: PPUSH
20288: CALL_OW 255
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: AND
20297: IFFALSE 20321
// begin hasSomethingToSay := true ;
20299: LD_ADDR_VAR 0 10
20303: PUSH
20304: LD_INT 1
20306: ST_TO_ADDR
// Say ( Bobby , D3nW-Bobby-1 ) ;
20307: LD_EXP 45
20311: PPUSH
20312: LD_STRING D3nW-Bobby-1
20314: PPUSH
20315: CALL_OW 88
// end else
20319: GO 20523
// if Gary in vip and GetSide ( Gary ) = 1 then
20321: LD_EXP 52
20325: PUSH
20326: LD_EXP 62
20330: IN
20331: IFFALSE 20348
20333: PUSH
20334: LD_EXP 52
20338: PPUSH
20339: CALL_OW 255
20343: PUSH
20344: LD_INT 1
20346: EQUAL
20347: AND
20348: IFFALSE 20372
// begin hasSomethingToSay := true ;
20350: LD_ADDR_VAR 0 10
20354: PUSH
20355: LD_INT 1
20357: ST_TO_ADDR
// Say ( Gary , D3nW-Gary-1 ) ;
20358: LD_EXP 52
20362: PPUSH
20363: LD_STRING D3nW-Gary-1
20365: PPUSH
20366: CALL_OW 88
// end else
20370: GO 20523
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20372: LD_EXP 44
20376: PUSH
20377: LD_EXP 62
20381: IN
20382: IFFALSE 20399
20384: PUSH
20385: LD_EXP 44
20389: PPUSH
20390: CALL_OW 255
20394: PUSH
20395: LD_INT 1
20397: EQUAL
20398: AND
20399: IFFALSE 20423
// begin hasSomethingToSay := true ;
20401: LD_ADDR_VAR 0 10
20405: PUSH
20406: LD_INT 1
20408: ST_TO_ADDR
// Say ( Donaldson , D3nW-Don-1 ) ;
20409: LD_EXP 44
20413: PPUSH
20414: LD_STRING D3nW-Don-1
20416: PPUSH
20417: CALL_OW 88
// end else
20421: GO 20523
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20423: LD_EXP 51
20427: PUSH
20428: LD_EXP 62
20432: IN
20433: IFFALSE 20450
20435: PUSH
20436: LD_EXP 51
20440: PPUSH
20441: CALL_OW 255
20445: PUSH
20446: LD_INT 1
20448: EQUAL
20449: AND
20450: IFFALSE 20474
// begin hasSomethingToSay := true ;
20452: LD_ADDR_VAR 0 10
20456: PUSH
20457: LD_INT 1
20459: ST_TO_ADDR
// Say ( Cornel , D3nW-Corn-1 ) ;
20460: LD_EXP 51
20464: PPUSH
20465: LD_STRING D3nW-Corn-1
20467: PPUSH
20468: CALL_OW 88
// end else
20472: GO 20523
// if Frank in vip and GetSide ( Frank ) = 1 then
20474: LD_EXP 53
20478: PUSH
20479: LD_EXP 62
20483: IN
20484: IFFALSE 20501
20486: PUSH
20487: LD_EXP 53
20491: PPUSH
20492: CALL_OW 255
20496: PUSH
20497: LD_INT 1
20499: EQUAL
20500: AND
20501: IFFALSE 20523
// begin hasSomethingToSay := true ;
20503: LD_ADDR_VAR 0 10
20507: PUSH
20508: LD_INT 1
20510: ST_TO_ADDR
// Say ( Frank , D3nW-Frank-1 ) ;
20511: LD_EXP 53
20515: PPUSH
20516: LD_STRING D3nW-Frank-1
20518: PPUSH
20519: CALL_OW 88
// end ; if hasSomethingToSay then
20523: LD_VAR 0 10
20527: IFFALSE 20553
// begin Say ( JMM , D3nW-JMM-1 ) ;
20529: LD_EXP 40
20533: PPUSH
20534: LD_STRING D3nW-JMM-1
20536: PPUSH
20537: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20541: LD_EXP 40
20545: PPUSH
20546: LD_STRING D3nW-JMM-1a
20548: PPUSH
20549: CALL_OW 88
// end ; t := 0 0$00 ;
20553: LD_ADDR_VAR 0 3
20557: PUSH
20558: LD_INT 0
20560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20561: LD_INT 35
20563: PPUSH
20564: CALL_OW 67
// t := t + 0 0$1 ;
20568: LD_ADDR_VAR 0 3
20572: PUSH
20573: LD_VAR 0 3
20577: PUSH
20578: LD_INT 35
20580: PLUS
20581: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20582: LD_INT 59
20584: PPUSH
20585: LD_INT 112
20587: PPUSH
20588: CALL_OW 428
20592: IFTRUE 20604
20594: PUSH
20595: LD_VAR 0 3
20599: PUSH
20600: LD_INT 2100
20602: GREATER
20603: OR
20604: IFFALSE 20561
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20606: LD_ADDR_EXP 102
20610: PUSH
20611: LD_EXP 102
20615: PPUSH
20616: LD_INT 4
20618: PPUSH
20619: LD_INT 22
20621: PUSH
20622: LD_INT 4
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 23
20631: PUSH
20632: LD_INT 1
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PUSH
20639: LD_INT 3
20641: PUSH
20642: LD_INT 21
20644: PUSH
20645: LD_INT 2
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 69
20665: PUSH
20666: LD_EXP 61
20670: DIFF
20671: PPUSH
20672: CALL_OW 1
20676: ST_TO_ADDR
// activeAttacks := true ;
20677: LD_ADDR_EXP 16
20681: PUSH
20682: LD_INT 1
20684: ST_TO_ADDR
// end ;
20685: LD_VAR 0 1
20689: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20690: LD_INT 0
20692: PPUSH
// case question of 1 :
20693: LD_VAR 0 1
20697: PUSH
20698: LD_INT 1
20700: DOUBLE
20701: EQUAL
20702: IFTRUE 20706
20704: GO 20757
20706: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20707: LD_EXP 40
20711: PPUSH
20712: LD_STRING D2Mot-JMM-1
20714: PPUSH
20715: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20719: LD_EXP 61
20723: PPUSH
20724: LD_STRING D2Mot-Pow-1
20726: PPUSH
20727: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20731: LD_EXP 40
20735: PPUSH
20736: LD_STRING D2Mot-JMM-2
20738: PPUSH
20739: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20743: LD_EXP 61
20747: PPUSH
20748: LD_STRING D2Mot-Pow-2
20750: PPUSH
20751: CALL_OW 88
// end ; 2 :
20755: GO 21108
20757: LD_INT 2
20759: DOUBLE
20760: EQUAL
20761: IFTRUE 20765
20763: GO 20841
20765: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20766: LD_EXP 40
20770: PPUSH
20771: LD_STRING D2Rus-JMM-1
20773: PPUSH
20774: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20778: LD_EXP 61
20782: PPUSH
20783: LD_STRING D2Rus-Pow-1
20785: PPUSH
20786: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20790: LD_EXP 40
20794: PPUSH
20795: LD_STRING D2Rus-JMM-2
20797: PPUSH
20798: CALL_OW 88
// if not ( 3 in list_of_q ) then
20802: LD_INT 3
20804: PUSH
20805: LD_VAR 0 2
20809: IN
20810: NOT
20811: IFFALSE 20827
// Say ( Powell , D2Rus-Pow-2 ) else
20813: LD_EXP 61
20817: PPUSH
20818: LD_STRING D2Rus-Pow-2
20820: PPUSH
20821: CALL_OW 88
20825: GO 20839
// Say ( Powell , D2Rus-Pow-2a ) ;
20827: LD_EXP 61
20831: PPUSH
20832: LD_STRING D2Rus-Pow-2a
20834: PPUSH
20835: CALL_OW 88
// end ; 3 :
20839: GO 21108
20841: LD_INT 3
20843: DOUBLE
20844: EQUAL
20845: IFTRUE 20849
20847: GO 20934
20849: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20850: LD_EXP 40
20854: PPUSH
20855: LD_STRING D2Leg-JMM-1
20857: PPUSH
20858: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20862: LD_EXP 61
20866: PPUSH
20867: LD_STRING D2Leg-Pow-1
20869: PPUSH
20870: CALL_OW 88
// if 2 in list_of_q then
20874: LD_INT 2
20876: PUSH
20877: LD_VAR 0 2
20881: IN
20882: IFFALSE 20908
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20884: LD_EXP 40
20888: PPUSH
20889: LD_STRING D2Leg-JMM-2
20891: PPUSH
20892: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20896: LD_EXP 61
20900: PPUSH
20901: LD_STRING D2Leg-Pow-2
20903: PPUSH
20904: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20908: LD_EXP 40
20912: PPUSH
20913: LD_STRING D2Leg-JMM-3
20915: PPUSH
20916: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20920: LD_EXP 61
20924: PPUSH
20925: LD_STRING D2Leg-Pow-3
20927: PPUSH
20928: CALL_OW 88
// end ; 4 :
20932: GO 21108
20934: LD_INT 4
20936: DOUBLE
20937: EQUAL
20938: IFTRUE 20942
20940: GO 21017
20942: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20943: LD_EXP 40
20947: PPUSH
20948: LD_STRING D2Ar-JMM-1
20950: PPUSH
20951: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20955: LD_EXP 61
20959: PPUSH
20960: LD_STRING D2Ar-Pow-1
20962: PPUSH
20963: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20967: LD_EXP 40
20971: PPUSH
20972: LD_STRING D2Ar-JMM-2
20974: PPUSH
20975: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20979: LD_EXP 61
20983: PPUSH
20984: LD_STRING D2Ar-Pow-2
20986: PPUSH
20987: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20991: LD_EXP 40
20995: PPUSH
20996: LD_STRING D2Ar-JMM-3
20998: PPUSH
20999: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
21003: LD_EXP 61
21007: PPUSH
21008: LD_STRING D2Ar-Pow-3
21010: PPUSH
21011: CALL_OW 88
// end ; 5 :
21015: GO 21108
21017: LD_INT 5
21019: DOUBLE
21020: EQUAL
21021: IFTRUE 21025
21023: GO 21040
21025: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
21026: LD_EXP 40
21030: PPUSH
21031: LD_STRING D2Conf-JMM-1
21033: PPUSH
21034: CALL_OW 88
21038: GO 21108
21040: LD_INT 6
21042: DOUBLE
21043: EQUAL
21044: IFTRUE 21048
21046: GO 21107
21048: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
21049: LD_EXP 40
21053: PPUSH
21054: LD_STRING D2Com-JMM-1
21056: PPUSH
21057: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
21061: LD_EXP 61
21065: PPUSH
21066: LD_STRING D2Com-Pow-1
21068: PPUSH
21069: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
21073: LD_EXP 40
21077: PPUSH
21078: LD_STRING D2Com-JMM-2
21080: PPUSH
21081: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
21085: LD_EXP 61
21089: PPUSH
21090: LD_STRING D2Com-Pow-2
21092: PPUSH
21093: CALL_OW 88
// powellAngerQuery := true ;
21097: LD_ADDR_EXP 36
21101: PUSH
21102: LD_INT 1
21104: ST_TO_ADDR
// end ; end ;
21105: GO 21108
21107: POP
// end ;
21108: LD_VAR 0 3
21112: RET
// every 0 0$5 trigger missionStart do var tmp ;
21113: LD_EXP 13
21117: IFFALSE 21444
21119: GO 21121
21121: DISABLE
21122: LD_INT 0
21124: PPUSH
// begin repeat wait ( 0 0$1 ) ;
21125: LD_INT 35
21127: PPUSH
21128: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
21132: LD_INT 14
21134: PPUSH
21135: LD_INT 22
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 3
21147: PUSH
21148: LD_INT 21
21150: PUSH
21151: LD_INT 3
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: PPUSH
21166: CALL_OW 70
21170: IFFALSE 21197
21172: PUSH
21173: LD_EXP 15
21177: PUSH
21178: LD_INT 2
21180: PUSH
21181: LD_INT 3
21183: PUSH
21184: LD_INT 4
21186: PUSH
21187: LD_INT 5
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: IN
21196: AND
21197: IFFALSE 21434
// begin powellAnger := powellAnger + 1 ;
21199: LD_ADDR_EXP 17
21203: PUSH
21204: LD_EXP 17
21208: PUSH
21209: LD_INT 1
21211: PLUS
21212: ST_TO_ADDR
// Video ( true ) ;
21213: LD_INT 1
21215: PPUSH
21216: CALL 109067 0 1
// CenterNowOnUnits ( tmp ) ;
21220: LD_VAR 0 1
21224: PPUSH
21225: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21229: LD_INT 14
21231: PPUSH
21232: LD_INT 22
21234: PUSH
21235: LD_INT 1
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PPUSH
21242: CALL_OW 70
21246: PPUSH
21247: LD_INT 86
21249: PPUSH
21250: LD_INT 133
21252: PPUSH
21253: CALL_OW 111
// async ;
21257: ASYNC
// case powellAnger of 1 :
21258: LD_EXP 17
21262: PUSH
21263: LD_INT 1
21265: DOUBLE
21266: EQUAL
21267: IFTRUE 21271
21269: GO 21286
21271: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21272: LD_EXP 61
21276: PPUSH
21277: LD_STRING DBack1-Pow-1
21279: PPUSH
21280: CALL_OW 88
21284: GO 21333
21286: LD_INT 2
21288: DOUBLE
21289: EQUAL
21290: IFTRUE 21294
21292: GO 21309
21294: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21295: LD_EXP 61
21299: PPUSH
21300: LD_STRING DBack2-Pow-1
21302: PPUSH
21303: CALL_OW 88
21307: GO 21333
21309: LD_INT 3
21311: DOUBLE
21312: EQUAL
21313: IFTRUE 21317
21315: GO 21332
21317: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21318: LD_EXP 61
21322: PPUSH
21323: LD_STRING DBack3-Pow-1
21325: PPUSH
21326: CALL_OW 88
21330: GO 21333
21332: POP
// sync ;
21333: SYNC
// repeat wait ( 0 0$1 ) ;
21334: LD_INT 35
21336: PPUSH
21337: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21341: LD_INT 14
21343: PPUSH
21344: LD_INT 22
21346: PUSH
21347: LD_INT 1
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: PPUSH
21354: CALL_OW 70
21358: PPUSH
21359: LD_INT 86
21361: PPUSH
21362: LD_INT 133
21364: PPUSH
21365: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21369: LD_INT 14
21371: PPUSH
21372: LD_INT 22
21374: PUSH
21375: LD_INT 1
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PUSH
21382: LD_INT 3
21384: PUSH
21385: LD_INT 21
21387: PUSH
21388: LD_INT 3
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PPUSH
21403: CALL_OW 70
21407: NOT
21408: IFFALSE 21334
// if powellAnger >= 3 then
21410: LD_EXP 17
21414: PUSH
21415: LD_INT 3
21417: GREATEREQUAL
21418: IFFALSE 21427
// YouLost ( Dismissed ) ;
21420: LD_STRING Dismissed
21422: PPUSH
21423: CALL_OW 104
// Video ( false ) ;
21427: LD_INT 0
21429: PPUSH
21430: CALL 109067 0 1
// end ; until missionStage > 5 ;
21434: LD_EXP 15
21438: PUSH
21439: LD_INT 5
21441: GREATER
21442: IFFALSE 21125
// end ;
21444: PPOPN 1
21446: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21447: LD_EXP 13
21451: IFFALSE 21487
21453: PUSH
21454: LD_INT 22
21456: PUSH
21457: LD_INT 4
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 21
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PPUSH
21478: CALL_OW 69
21482: PUSH
21483: LD_INT 4
21485: GREATEREQUAL
21486: AND
21487: IFFALSE 21499
21489: PUSH
21490: LD_EXP 15
21494: PUSH
21495: LD_INT 2
21497: EQUAL
21498: AND
21499: IFFALSE 24127
21501: GO 21503
21503: DISABLE
21504: LD_INT 0
21506: PPUSH
21507: PPUSH
21508: PPUSH
21509: PPUSH
21510: PPUSH
21511: PPUSH
21512: PPUSH
21513: PPUSH
21514: PPUSH
21515: PPUSH
21516: PPUSH
// begin missionStage := 3 ;
21517: LD_ADDR_EXP 15
21521: PUSH
21522: LD_INT 3
21524: ST_TO_ADDR
// retreat := false ;
21525: LD_ADDR_VAR 0 4
21529: PUSH
21530: LD_INT 0
21532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21533: LD_ADDR_VAR 0 5
21537: PUSH
21538: LD_INT 22
21540: PUSH
21541: LD_INT 4
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: PUSH
21548: LD_INT 30
21550: PUSH
21551: LD_INT 4
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: PPUSH
21562: CALL_OW 69
21566: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21567: LD_ADDR_VAR 0 6
21571: PUSH
21572: LD_INT 22
21574: PUSH
21575: LD_INT 4
21577: PUSH
21578: EMPTY
21579: LIST
21580: LIST
21581: PUSH
21582: LD_INT 30
21584: PUSH
21585: LD_INT 5
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PPUSH
21596: CALL_OW 69
21600: ST_TO_ADDR
// if not bar then
21601: LD_VAR 0 6
21605: NOT
21606: IFFALSE 21659
// begin repeat wait ( 0 0$1 ) ;
21608: LD_INT 35
21610: PPUSH
21611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21615: LD_INT 22
21617: PUSH
21618: LD_INT 4
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 3
21627: PUSH
21628: LD_INT 57
21630: PUSH
21631: EMPTY
21632: LIST
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: PUSH
21638: LD_INT 30
21640: PUSH
21641: LD_INT 5
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 69
21657: IFFALSE 21608
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21659: LD_ADDR_VAR 0 6
21663: PUSH
21664: LD_INT 22
21666: PUSH
21667: LD_INT 4
21669: PUSH
21670: EMPTY
21671: LIST
21672: LIST
21673: PUSH
21674: LD_INT 30
21676: PUSH
21677: LD_INT 5
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: PPUSH
21688: CALL_OW 69
21692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21693: LD_INT 35
21695: PPUSH
21696: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21700: LD_EXP 121
21704: PUSH
21705: LD_INT 4
21707: ARRAY
21708: PUSH
21709: LD_INT 4
21711: GREATEREQUAL
21712: IFFALSE 21693
// tmp := [ ] ;
21714: LD_ADDR_VAR 0 2
21718: PUSH
21719: EMPTY
21720: ST_TO_ADDR
// tmp2 := [ ] ;
21721: LD_ADDR_VAR 0 3
21725: PUSH
21726: EMPTY
21727: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21728: LD_ADDR_VAR 0 1
21732: PUSH
21733: LD_INT 22
21735: PUSH
21736: LD_INT 4
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PUSH
21743: LD_INT 2
21745: PUSH
21746: LD_INT 25
21748: PUSH
21749: LD_INT 1
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 25
21758: PUSH
21759: LD_INT 2
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 25
21768: PUSH
21769: LD_INT 3
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: LD_INT 25
21778: PUSH
21779: LD_INT 4
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 25
21788: PUSH
21789: LD_INT 5
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: LIST
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PPUSH
21808: CALL_OW 69
21812: PUSH
21813: LD_EXP 61
21817: PUSH
21818: LD_EXP 62
21822: UNION
21823: DIFF
21824: PUSH
21825: FOR_IN
21826: IFFALSE 21888
// if not i in extraSquad then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_EXP 63
21837: IN
21838: NOT
21839: IFFALSE 21863
// tmp := Join ( tmp , i ) else
21841: LD_ADDR_VAR 0 2
21845: PUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 1
21855: PPUSH
21856: CALL 109095 0 2
21860: ST_TO_ADDR
21861: GO 21886
// tmp := Insert ( tmp , 1 , i ) ;
21863: LD_ADDR_VAR 0 2
21867: PUSH
21868: LD_VAR 0 2
21872: PPUSH
21873: LD_INT 1
21875: PPUSH
21876: LD_VAR 0 1
21880: PPUSH
21881: CALL_OW 2
21885: ST_TO_ADDR
21886: GO 21825
21888: POP
21889: POP
// tmp := tmp diff 0 ;
21890: LD_ADDR_VAR 0 2
21894: PUSH
21895: LD_VAR 0 2
21899: PUSH
21900: LD_INT 0
21902: DIFF
21903: ST_TO_ADDR
// p := 0 ;
21904: LD_ADDR_VAR 0 11
21908: PUSH
21909: LD_INT 0
21911: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21912: LD_ADDR_VAR 0 1
21916: PUSH
21917: LD_VAR 0 2
21921: PPUSH
21922: LD_INT 26
21924: PUSH
21925: LD_INT 1
21927: PUSH
21928: EMPTY
21929: LIST
21930: LIST
21931: PPUSH
21932: CALL_OW 72
21936: PUSH
21937: FOR_IN
21938: IFFALSE 21989
// begin p := Inc ( p ) ;
21940: LD_ADDR_VAR 0 11
21944: PUSH
21945: LD_VAR 0 11
21949: PPUSH
21950: CALL 110468 0 1
21954: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 3
21964: PPUSH
21965: LD_VAR 0 1
21969: PPUSH
21970: CALL 109095 0 2
21974: ST_TO_ADDR
// if p = 4 then
21975: LD_VAR 0 11
21979: PUSH
21980: LD_INT 4
21982: EQUAL
21983: IFFALSE 21987
// break ;
21985: GO 21989
// end ;
21987: GO 21937
21989: POP
21990: POP
// tmp := tmp diff tmp2 ;
21991: LD_ADDR_VAR 0 2
21995: PUSH
21996: LD_VAR 0 2
22000: PUSH
22001: LD_VAR 0 3
22005: DIFF
22006: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
22007: LD_ADDR_VAR 0 2
22011: PUSH
22012: LD_VAR 0 2
22016: PPUSH
22017: LD_INT 3
22019: PPUSH
22020: CALL 107575 0 2
22024: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
22025: LD_ADDR_VAR 0 3
22029: PUSH
22030: LD_VAR 0 3
22034: PPUSH
22035: LD_INT 3
22037: PPUSH
22038: CALL 107575 0 2
22042: ST_TO_ADDR
// for i := 1 to 4 do
22043: LD_ADDR_VAR 0 1
22047: PUSH
22048: DOUBLE
22049: LD_INT 1
22051: DEC
22052: ST_TO_ADDR
22053: LD_INT 4
22055: PUSH
22056: FOR_TO
22057: IFFALSE 22223
// begin if tmp2 then
22059: LD_VAR 0 3
22063: IFFALSE 22144
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
22065: LD_ADDR_EXP 18
22069: PUSH
22070: LD_EXP 18
22074: PPUSH
22075: LD_INT 1
22077: PPUSH
22078: LD_EXP 18
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PUSH
22087: LD_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: ARRAY
22097: ADD
22098: PPUSH
22099: CALL_OW 1
22103: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
22104: LD_VAR 0 3
22108: PUSH
22109: LD_VAR 0 3
22113: ARRAY
22114: PPUSH
22115: LD_INT 1
22117: PPUSH
22118: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
22122: LD_ADDR_VAR 0 3
22126: PUSH
22127: LD_VAR 0 3
22131: PPUSH
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 3
22141: ST_TO_ADDR
// end else
22142: GO 22221
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
22144: LD_ADDR_EXP 18
22148: PUSH
22149: LD_EXP 18
22153: PPUSH
22154: LD_INT 1
22156: PPUSH
22157: LD_EXP 18
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PUSH
22166: LD_VAR 0 2
22170: PUSH
22171: LD_VAR 0 2
22175: ARRAY
22176: ADD
22177: PPUSH
22178: CALL_OW 1
22182: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
22183: LD_VAR 0 2
22187: PUSH
22188: LD_VAR 0 2
22192: ARRAY
22193: PPUSH
22194: LD_INT 1
22196: PPUSH
22197: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22201: LD_ADDR_VAR 0 2
22205: PUSH
22206: LD_VAR 0 2
22210: PPUSH
22211: LD_VAR 0 2
22215: PPUSH
22216: CALL_OW 3
22220: ST_TO_ADDR
// end ; end ;
22221: GO 22056
22223: POP
22224: POP
// if tmp2 then
22225: LD_VAR 0 3
22229: IFFALSE 22247
// tmp := tmp union tmp2 ;
22231: LD_ADDR_VAR 0 2
22235: PUSH
22236: LD_VAR 0 2
22240: PUSH
22241: LD_VAR 0 3
22245: UNION
22246: ST_TO_ADDR
// for i := 0 to 3 do
22247: LD_ADDR_VAR 0 1
22251: PUSH
22252: DOUBLE
22253: LD_INT 0
22255: DEC
22256: ST_TO_ADDR
22257: LD_INT 3
22259: PUSH
22260: FOR_TO
22261: IFFALSE 22424
// begin if not tmp [ tmp - i ] then
22263: LD_VAR 0 2
22267: PUSH
22268: LD_VAR 0 2
22272: PUSH
22273: LD_VAR 0 1
22277: MINUS
22278: ARRAY
22279: NOT
22280: IFFALSE 22377
// begin uc_side := 4 ;
22282: LD_ADDR_OWVAR 20
22286: PUSH
22287: LD_INT 4
22289: ST_TO_ADDR
// uc_nation := 1 ;
22290: LD_ADDR_OWVAR 21
22294: PUSH
22295: LD_INT 1
22297: ST_TO_ADDR
// InitHc ;
22298: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22302: LD_INT 1
22304: PPUSH
22305: LD_INT 3
22307: PPUSH
22308: CALL_OW 381
// un := CreateHuman ;
22312: LD_ADDR_VAR 0 8
22316: PUSH
22317: CALL_OW 44
22321: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22322: LD_VAR 0 8
22326: PPUSH
22327: LD_INT 39
22329: PPUSH
22330: LD_INT 61
22332: PPUSH
22333: CALL_OW 428
22337: PPUSH
22338: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22342: LD_ADDR_EXP 18
22346: PUSH
22347: LD_EXP 18
22351: PPUSH
22352: LD_INT 2
22354: PPUSH
22355: LD_EXP 18
22359: PUSH
22360: LD_INT 2
22362: ARRAY
22363: PUSH
22364: LD_VAR 0 8
22368: ADD
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// end else
22375: GO 22422
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22377: LD_ADDR_EXP 18
22381: PUSH
22382: LD_EXP 18
22386: PPUSH
22387: LD_INT 2
22389: PPUSH
22390: LD_EXP 18
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_VAR 0 2
22408: PUSH
22409: LD_VAR 0 1
22413: MINUS
22414: ARRAY
22415: ADD
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// end ;
22422: GO 22260
22424: POP
22425: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22426: LD_ADDR_EXP 102
22430: PUSH
22431: LD_EXP 102
22435: PPUSH
22436: LD_INT 4
22438: PPUSH
22439: LD_EXP 102
22443: PUSH
22444: LD_INT 4
22446: ARRAY
22447: PUSH
22448: LD_EXP 18
22452: PUSH
22453: LD_INT 1
22455: ARRAY
22456: DIFF
22457: PPUSH
22458: CALL_OW 1
22462: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22463: LD_VAR 0 5
22467: PUSH
22468: LD_INT 1
22470: ARRAY
22471: PPUSH
22472: CALL_OW 313
22476: IFFALSE 22531
// begin for i in UnitsInside ( arm [ 1 ] ) do
22478: LD_ADDR_VAR 0 1
22482: PUSH
22483: LD_VAR 0 5
22487: PUSH
22488: LD_INT 1
22490: ARRAY
22491: PPUSH
22492: CALL_OW 313
22496: PUSH
22497: FOR_IN
22498: IFFALSE 22529
// begin ComExitBuilding ( i ) ;
22500: LD_VAR 0 1
22504: PPUSH
22505: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22509: LD_VAR 0 1
22513: PPUSH
22514: LD_VAR 0 6
22518: PUSH
22519: LD_INT 1
22521: ARRAY
22522: PPUSH
22523: CALL_OW 180
// end ;
22527: GO 22497
22529: POP
22530: POP
// end ; wait ( 0 0$5 ) ;
22531: LD_INT 175
22533: PPUSH
22534: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22538: LD_INT 35
22540: PPUSH
22541: CALL_OW 67
22545: LD_EXP 18
22549: PUSH
22550: LD_INT 1
22552: ARRAY
22553: PPUSH
22554: LD_INT 55
22556: PUSH
22557: EMPTY
22558: LIST
22559: PPUSH
22560: CALL_OW 72
22564: NOT
22565: IFFALSE 22538
// for i in powellSquadAttack [ 1 ] do
22567: LD_ADDR_VAR 0 1
22571: PUSH
22572: LD_EXP 18
22576: PUSH
22577: LD_INT 1
22579: ARRAY
22580: PUSH
22581: FOR_IN
22582: IFFALSE 22689
// begin if IsInUnit ( i ) then
22584: LD_VAR 0 1
22588: PPUSH
22589: CALL_OW 310
22593: IFFALSE 22604
// ComExitBuilding ( i ) ;
22595: LD_VAR 0 1
22599: PPUSH
22600: CALL_OW 122
// if GetClass ( i ) <> 1 then
22604: LD_VAR 0 1
22608: PPUSH
22609: CALL_OW 257
22613: PUSH
22614: LD_INT 1
22616: NONEQUAL
22617: IFFALSE 22658
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22619: LD_VAR 0 1
22623: PPUSH
22624: LD_VAR 0 5
22628: PUSH
22629: LD_INT 1
22631: ARRAY
22632: PPUSH
22633: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22637: LD_VAR 0 1
22641: PPUSH
22642: LD_INT 1
22644: PPUSH
22645: CALL_OW 183
// AddComExitBuilding ( i ) ;
22649: LD_VAR 0 1
22653: PPUSH
22654: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22658: LD_VAR 0 1
22662: PPUSH
22663: LD_INT 60
22665: PPUSH
22666: LD_INT 94
22668: PPUSH
22669: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_EXP 61
22682: PPUSH
22683: CALL_OW 179
// end ;
22687: GO 22581
22689: POP
22690: POP
// wait ( 0 0$45 ) ;
22691: LD_INT 1575
22693: PPUSH
22694: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22698: LD_EXP 61
22702: PPUSH
22703: LD_STRING D4-Pow-1
22705: PPUSH
22706: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22710: LD_ADDR_VAR 0 2
22714: PUSH
22715: LD_EXP 18
22719: PUSH
22720: LD_INT 1
22722: ARRAY
22723: PPUSH
22724: LD_INT 26
22726: PUSH
22727: LD_INT 1
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: PPUSH
22734: CALL_OW 72
22738: ST_TO_ADDR
// if tmp then
22739: LD_VAR 0 2
22743: IFFALSE 22761
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22745: LD_VAR 0 2
22749: PUSH
22750: LD_INT 1
22752: ARRAY
22753: PPUSH
22754: LD_STRING D4-Sol1-1
22756: PPUSH
22757: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22761: LD_EXP 61
22765: PPUSH
22766: LD_STRING D4-Pow-2
22768: PPUSH
22769: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22773: LD_ADDR_VAR 0 1
22777: PUSH
22778: DOUBLE
22779: LD_INT 1
22781: DEC
22782: ST_TO_ADDR
22783: LD_EXP 18
22787: PUSH
22788: LD_INT 1
22790: ARRAY
22791: PUSH
22792: FOR_TO
22793: IFFALSE 22886
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22795: LD_EXP 18
22799: PUSH
22800: LD_INT 1
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 1
22808: ARRAY
22809: PPUSH
22810: LD_EXP 121
22814: PUSH
22815: LD_INT 4
22817: ARRAY
22818: PUSH
22819: LD_INT 1
22821: ARRAY
22822: PPUSH
22823: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22827: LD_ADDR_EXP 121
22831: PUSH
22832: LD_EXP 121
22836: PPUSH
22837: LD_INT 4
22839: PPUSH
22840: LD_EXP 121
22844: PUSH
22845: LD_INT 4
22847: ARRAY
22848: PPUSH
22849: LD_INT 1
22851: PPUSH
22852: CALL_OW 3
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22862: LD_INT 8
22864: PPUSH
22865: LD_EXP 18
22869: PUSH
22870: LD_INT 1
22872: ARRAY
22873: PUSH
22874: LD_VAR 0 1
22878: ARRAY
22879: PPUSH
22880: CALL_OW 471
// end ;
22884: GO 22792
22886: POP
22887: POP
// repeat wait ( 0 0$1 ) ;
22888: LD_INT 35
22890: PPUSH
22891: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22895: LD_EXP 18
22899: PUSH
22900: LD_INT 1
22902: ARRAY
22903: PPUSH
22904: LD_INT 55
22906: PUSH
22907: EMPTY
22908: LIST
22909: PPUSH
22910: CALL_OW 72
22914: PUSH
22915: LD_INT 4
22917: GREATEREQUAL
22918: IFFALSE 22888
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22920: LD_EXP 18
22924: PUSH
22925: LD_INT 1
22927: ARRAY
22928: PPUSH
22929: LD_INT 69
22931: PPUSH
22932: LD_INT 94
22934: PPUSH
22935: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22939: LD_EXP 18
22943: PUSH
22944: LD_INT 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 82
22950: PPUSH
22951: LD_INT 83
22953: PPUSH
22954: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22958: LD_EXP 18
22962: PUSH
22963: LD_INT 1
22965: ARRAY
22966: PPUSH
22967: LD_INT 77
22969: PPUSH
22970: LD_INT 69
22972: PPUSH
22973: CALL_OW 174
// wait ( 0 0$30 ) ;
22977: LD_INT 1050
22979: PPUSH
22980: CALL_OW 67
// repeat wait ( 3 ) ;
22984: LD_INT 3
22986: PPUSH
22987: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22991: LD_ADDR_VAR 0 1
22995: PUSH
22996: LD_EXP 18
23000: PUSH
23001: LD_INT 1
23003: ARRAY
23004: PUSH
23005: FOR_IN
23006: IFFALSE 23144
// begin if GetLives ( i ) < 990 then
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 256
23017: PUSH
23018: LD_INT 990
23020: LESS
23021: IFFALSE 23035
// SetLives ( i , 1000 ) ;
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_INT 1000
23030: PPUSH
23031: CALL_OW 234
// if not IsInUnit ( i ) then
23035: LD_VAR 0 1
23039: PPUSH
23040: CALL_OW 310
23044: NOT
23045: IFFALSE 23142
// begin if not HasTask ( i ) then
23047: LD_VAR 0 1
23051: PPUSH
23052: CALL_OW 314
23056: NOT
23057: IFFALSE 23074
// ComMoveXY ( i , 64 , 93 ) ;
23059: LD_VAR 0 1
23063: PPUSH
23064: LD_INT 64
23066: PPUSH
23067: LD_INT 93
23069: PPUSH
23070: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
23074: LD_VAR 0 4
23078: NOT
23079: IFFALSE 23096
23081: PUSH
23082: LD_VAR 0 1
23086: PPUSH
23087: CALL_OW 258
23091: PUSH
23092: LD_INT 1
23094: EQUAL
23095: AND
23096: IFFALSE 23142
// begin retreat := true ;
23098: LD_ADDR_VAR 0 4
23102: PUSH
23103: LD_INT 1
23105: ST_TO_ADDR
// SetTag ( i , 2 ) ;
23106: LD_VAR 0 1
23110: PPUSH
23111: LD_INT 2
23113: PPUSH
23114: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
23118: LD_VAR 0 1
23122: PPUSH
23123: LD_STRING D4a-Sol1-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
23130: LD_EXP 61
23134: PPUSH
23135: LD_STRING D4a-Pow-1
23137: PPUSH
23138: CALL_OW 88
// end ; end ; end ;
23142: GO 23005
23144: POP
23145: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
23146: LD_EXP 18
23150: PUSH
23151: LD_INT 1
23153: ARRAY
23154: PPUSH
23155: LD_INT 95
23157: PUSH
23158: LD_INT 9
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: PUSH
23170: LD_INT 4
23172: GREATEREQUAL
23173: IFFALSE 22984
// for i in powellSquadAttack [ 1 ] do
23175: LD_ADDR_VAR 0 1
23179: PUSH
23180: LD_EXP 18
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PUSH
23189: FOR_IN
23190: IFFALSE 23326
// begin if GetTag ( i ) = 2 then
23192: LD_VAR 0 1
23196: PPUSH
23197: CALL_OW 110
23201: PUSH
23202: LD_INT 2
23204: EQUAL
23205: IFFALSE 23267
// begin ComMoveXY ( i , 60 , 94 ) ;
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_INT 60
23214: PPUSH
23215: LD_INT 94
23217: PPUSH
23218: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23222: LD_VAR 0 1
23226: PPUSH
23227: LD_EXP 61
23231: PPUSH
23232: CALL_OW 179
// wait ( 0 0$3 ) ;
23236: LD_INT 105
23238: PPUSH
23239: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23243: LD_VAR 0 1
23247: PPUSH
23248: LD_STRING D4a-Sol1-2
23250: PPUSH
23251: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23255: LD_EXP 61
23259: PPUSH
23260: LD_STRING D4a-Pow-2
23262: PPUSH
23263: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23267: LD_VAR 0 1
23271: PPUSH
23272: LD_INT 0
23274: PPUSH
23275: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23279: LD_ADDR_EXP 102
23283: PUSH
23284: LD_EXP 102
23288: PPUSH
23289: LD_INT 4
23291: PPUSH
23292: LD_EXP 102
23296: PUSH
23297: LD_INT 4
23299: ARRAY
23300: PUSH
23301: LD_VAR 0 1
23305: UNION
23306: PPUSH
23307: CALL_OW 1
23311: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23312: LD_INT 8
23314: PPUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 472
// end ;
23324: GO 23189
23326: POP
23327: POP
// wait ( 1 1$00 ) ;
23328: LD_INT 2100
23330: PPUSH
23331: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23335: LD_ADDR_VAR 0 9
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 4
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 30
23352: PUSH
23353: LD_INT 32
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: LD_INT 58
23362: PUSH
23363: EMPTY
23364: LIST
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: LIST
23370: PPUSH
23371: CALL_OW 69
23375: ST_TO_ADDR
// if tmp then
23376: LD_VAR 0 2
23380: IFFALSE 23622
// begin for i := 1 to tmp do
23382: LD_ADDR_VAR 0 1
23386: PUSH
23387: DOUBLE
23388: LD_INT 1
23390: DEC
23391: ST_TO_ADDR
23392: LD_VAR 0 2
23396: PUSH
23397: FOR_TO
23398: IFFALSE 23613
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23400: LD_ADDR_EXP 102
23404: PUSH
23405: LD_EXP 102
23409: PPUSH
23410: LD_INT 4
23412: PPUSH
23413: LD_EXP 102
23417: PUSH
23418: LD_INT 4
23420: ARRAY
23421: PUSH
23422: LD_VAR 0 2
23426: PUSH
23427: LD_VAR 0 1
23431: ARRAY
23432: DIFF
23433: PPUSH
23434: CALL_OW 1
23438: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23439: LD_ADDR_VAR 0 10
23443: PUSH
23444: LD_VAR 0 2
23448: PUSH
23449: LD_VAR 0 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 310
23459: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23460: LD_VAR 0 10
23464: IFFALSE 23481
23466: PUSH
23467: LD_VAR 0 10
23471: PPUSH
23472: CALL_OW 266
23476: PUSH
23477: LD_INT 32
23479: EQUAL
23480: AND
23481: IFFALSE 23485
// continue ;
23483: GO 23397
// if t then
23485: LD_VAR 0 10
23489: IFFALSE 23506
// ComExitBuilding ( tmp [ i ] ) ;
23491: LD_VAR 0 2
23495: PUSH
23496: LD_VAR 0 1
23500: ARRAY
23501: PPUSH
23502: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23506: LD_VAR 0 2
23510: PUSH
23511: LD_VAR 0 1
23515: ARRAY
23516: PPUSH
23517: LD_VAR 0 5
23521: PUSH
23522: LD_INT 1
23524: ARRAY
23525: PPUSH
23526: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23530: LD_VAR 0 2
23534: PUSH
23535: LD_VAR 0 1
23539: ARRAY
23540: PPUSH
23541: LD_INT 1
23543: PPUSH
23544: CALL_OW 183
// if emptyTowers then
23548: LD_VAR 0 9
23552: IFFALSE 23611
// begin AddComExitBuilding ( tmp [ i ] ) ;
23554: LD_VAR 0 2
23558: PUSH
23559: LD_VAR 0 1
23563: ARRAY
23564: PPUSH
23565: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23569: LD_VAR 0 2
23573: PUSH
23574: LD_VAR 0 1
23578: ARRAY
23579: PPUSH
23580: LD_VAR 0 9
23584: PUSH
23585: LD_INT 1
23587: ARRAY
23588: PPUSH
23589: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23593: LD_ADDR_VAR 0 9
23597: PUSH
23598: LD_VAR 0 9
23602: PPUSH
23603: LD_INT 1
23605: PPUSH
23606: CALL_OW 3
23610: ST_TO_ADDR
// end ; end ;
23611: GO 23397
23613: POP
23614: POP
// wait ( 0 0$30 ) ;
23615: LD_INT 1050
23617: PPUSH
23618: CALL_OW 67
// end ; uc_side := 6 ;
23622: LD_ADDR_OWVAR 20
23626: PUSH
23627: LD_INT 6
23629: ST_TO_ADDR
// uc_nation := 3 ;
23630: LD_ADDR_OWVAR 21
23634: PUSH
23635: LD_INT 3
23637: ST_TO_ADDR
// ru := [ ] ;
23638: LD_ADDR_VAR 0 7
23642: PUSH
23643: EMPTY
23644: ST_TO_ADDR
// for i = 1 to 5 do
23645: LD_ADDR_VAR 0 1
23649: PUSH
23650: DOUBLE
23651: LD_INT 1
23653: DEC
23654: ST_TO_ADDR
23655: LD_INT 5
23657: PUSH
23658: FOR_TO
23659: IFFALSE 23779
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23661: LD_INT 22
23663: PUSH
23664: LD_INT 23
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: LD_INT 1
23673: PPUSH
23674: LD_INT 2
23676: PPUSH
23677: CALL_OW 12
23681: ARRAY
23682: PPUSH
23683: LD_INT 1
23685: PPUSH
23686: LD_INT 3
23688: PPUSH
23689: LD_INT 43
23691: PUSH
23692: LD_INT 44
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: LD_INT 1
23701: PPUSH
23702: LD_INT 2
23704: PPUSH
23705: CALL_OW 12
23709: ARRAY
23710: PPUSH
23711: LD_INT 89
23713: PPUSH
23714: CALL 75925 0 5
// un := CreateVehicle ;
23718: LD_ADDR_VAR 0 8
23722: PUSH
23723: CALL_OW 45
23727: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23728: LD_VAR 0 8
23732: PPUSH
23733: LD_INT 4
23735: PPUSH
23736: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23740: LD_VAR 0 8
23744: PPUSH
23745: LD_INT 136
23747: PPUSH
23748: LD_INT 90
23750: PPUSH
23751: LD_INT 8
23753: PPUSH
23754: LD_INT 0
23756: PPUSH
23757: CALL_OW 50
// ru := ru ^ un ;
23761: LD_ADDR_VAR 0 7
23765: PUSH
23766: LD_VAR 0 7
23770: PUSH
23771: LD_VAR 0 8
23775: ADD
23776: ST_TO_ADDR
// end ;
23777: GO 23658
23779: POP
23780: POP
// if ru then
23781: LD_VAR 0 7
23785: IFFALSE 23802
// ComAgressiveMove ( ru , 57 , 94 ) ;
23787: LD_VAR 0 7
23791: PPUSH
23792: LD_INT 57
23794: PPUSH
23795: LD_INT 94
23797: PPUSH
23798: CALL_OW 114
// wait ( 3 3$00 ) ;
23802: LD_INT 6300
23804: PPUSH
23805: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23809: LD_ADDR_VAR 0 11
23813: PUSH
23814: LD_INT 54
23816: PPUSH
23817: LD_INT 85
23819: PPUSH
23820: CALL_OW 428
23824: PPUSH
23825: CALL_OW 313
23829: ST_TO_ADDR
// t := 0 ;
23830: LD_ADDR_VAR 0 10
23834: PUSH
23835: LD_INT 0
23837: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23838: LD_ADDR_VAR 0 1
23842: PUSH
23843: LD_INT 22
23845: PUSH
23846: LD_INT 4
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 3
23855: PUSH
23856: LD_INT 58
23858: PUSH
23859: EMPTY
23860: LIST
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 30
23868: PUSH
23869: LD_INT 32
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: LIST
23880: PPUSH
23881: CALL_OW 69
23885: PUSH
23886: FOR_IN
23887: IFFALSE 24013
// begin if p + t > 5 then
23889: LD_VAR 0 11
23893: PUSH
23894: LD_VAR 0 10
23898: PLUS
23899: PUSH
23900: LD_INT 5
23902: GREATER
23903: IFFALSE 23907
// break ;
23905: GO 24013
// un := UnitsInside ( i ) ;
23907: LD_ADDR_VAR 0 8
23911: PUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 313
23921: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23922: LD_VAR 0 8
23926: PPUSH
23927: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23931: LD_VAR 0 8
23935: PPUSH
23936: LD_INT 54
23938: PPUSH
23939: LD_INT 85
23941: PPUSH
23942: CALL_OW 428
23946: PPUSH
23947: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23951: LD_VAR 0 8
23955: PPUSH
23956: LD_INT 3
23958: PPUSH
23959: CALL_OW 183
// t := Inc ( t ) ;
23963: LD_ADDR_VAR 0 10
23967: PUSH
23968: LD_VAR 0 10
23972: PPUSH
23973: CALL 110468 0 1
23977: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23978: LD_ADDR_EXP 102
23982: PUSH
23983: LD_EXP 102
23987: PPUSH
23988: LD_INT 4
23990: PPUSH
23991: LD_EXP 102
23995: PUSH
23996: LD_INT 4
23998: ARRAY
23999: PUSH
24000: LD_VAR 0 8
24004: ADD
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// end ;
24011: GO 23886
24013: POP
24014: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24015: LD_INT 4
24017: PPUSH
24018: LD_INT 3
24020: PUSH
24021: LD_INT 1
24023: PUSH
24024: LD_INT 1
24026: PUSH
24027: LD_INT 5
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 4
24038: PUSH
24039: LD_INT 1
24041: PUSH
24042: LD_INT 1
24044: PUSH
24045: LD_INT 6
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: PUSH
24054: LD_INT 4
24056: PUSH
24057: LD_INT 1
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: LD_INT 7
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: PUSH
24072: LD_INT 3
24074: PUSH
24075: LD_INT 1
24077: PUSH
24078: LD_INT 1
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 3
24092: PUSH
24093: LD_INT 1
24095: PUSH
24096: LD_INT 1
24098: PUSH
24099: LD_INT 5
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: LIST
24112: LIST
24113: LIST
24114: PPUSH
24115: CALL 64367 0 2
// missionStage := 4 ;
24119: LD_ADDR_EXP 15
24123: PUSH
24124: LD_INT 4
24126: ST_TO_ADDR
// end ;
24127: PPOPN 11
24129: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
24130: LD_EXP 15
24134: PUSH
24135: LD_INT 4
24137: EQUAL
24138: IFFALSE 24174
24140: PUSH
24141: LD_INT 22
24143: PUSH
24144: LD_INT 4
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 21
24153: PUSH
24154: LD_INT 2
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: PPUSH
24165: CALL_OW 69
24169: PUSH
24170: LD_INT 5
24172: GREATEREQUAL
24173: AND
24174: IFFALSE 28550
24176: GO 24178
24178: DISABLE
24179: LD_INT 0
24181: PPUSH
24182: PPUSH
24183: PPUSH
24184: PPUSH
24185: PPUSH
24186: PPUSH
24187: PPUSH
24188: PPUSH
24189: PPUSH
24190: PPUSH
24191: PPUSH
24192: PPUSH
24193: PPUSH
24194: PPUSH
// begin wait ( 0 0$10 ) ;
24195: LD_INT 350
24197: PPUSH
24198: CALL_OW 67
// missionStage := 5 ;
24202: LD_ADDR_EXP 15
24206: PUSH
24207: LD_INT 5
24209: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24210: LD_ADDR_VAR 0 11
24214: PUSH
24215: LD_INT 22
24217: PUSH
24218: LD_INT 4
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 2
24227: PUSH
24228: LD_INT 30
24230: PUSH
24231: LD_INT 4
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: PUSH
24238: LD_INT 30
24240: PUSH
24241: LD_INT 5
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: LIST
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PPUSH
24257: CALL_OW 69
24261: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24262: LD_ADDR_VAR 0 6
24266: PUSH
24267: LD_INT 22
24269: PUSH
24270: LD_INT 4
24272: PUSH
24273: EMPTY
24274: LIST
24275: LIST
24276: PUSH
24277: LD_INT 21
24279: PUSH
24280: LD_INT 1
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: LD_INT 25
24292: PUSH
24293: LD_INT 16
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PUSH
24304: LD_INT 3
24306: PUSH
24307: LD_INT 25
24309: PUSH
24310: LD_INT 12
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PPUSH
24327: CALL_OW 69
24331: PUSH
24332: LD_EXP 61
24336: DIFF
24337: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24338: LD_ADDR_VAR 0 10
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_INT 4
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 30
24355: PUSH
24356: LD_INT 3
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PPUSH
24367: CALL_OW 69
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24376: LD_INT 350
24378: PPUSH
24379: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24383: LD_EXP 121
24387: PUSH
24388: LD_INT 4
24390: ARRAY
24391: PUSH
24392: LD_INT 5
24394: LESS
24395: IFFALSE 24412
24397: PUSH
24398: LD_VAR 0 10
24402: PPUSH
24403: CALL_OW 461
24407: PUSH
24408: LD_INT 2
24410: EQUAL
24411: AND
24412: IFFALSE 24442
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24414: LD_INT 4
24416: PPUSH
24417: LD_INT 3
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: LD_INT 5
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: PUSH
24435: EMPTY
24436: LIST
24437: PPUSH
24438: CALL 64415 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24442: LD_EXP 121
24446: PUSH
24447: LD_INT 4
24449: ARRAY
24450: PUSH
24451: LD_INT 5
24453: GREATEREQUAL
24454: IFFALSE 24481
24456: PUSH
24457: LD_EXP 121
24461: PUSH
24462: LD_INT 4
24464: ARRAY
24465: PPUSH
24466: LD_INT 58
24468: PUSH
24469: EMPTY
24470: LIST
24471: PPUSH
24472: CALL_OW 72
24476: PUSH
24477: LD_INT 5
24479: GREATEREQUAL
24480: AND
24481: IFFALSE 24376
// powellAllowRetreat := false ;
24483: LD_ADDR_EXP 19
24487: PUSH
24488: LD_INT 0
24490: ST_TO_ADDR
// activeAttacks := false ;
24491: LD_ADDR_EXP 16
24495: PUSH
24496: LD_INT 0
24498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24499: LD_INT 35
24501: PPUSH
24502: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24506: LD_INT 22
24508: PUSH
24509: LD_INT 6
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PPUSH
24516: CALL_OW 69
24520: PUSH
24521: LD_INT 0
24523: EQUAL
24524: IFFALSE 24499
// tmp := mc_vehicles [ 4 ] ;
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: LD_EXP 121
24535: PUSH
24536: LD_INT 4
24538: ARRAY
24539: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24540: LD_ADDR_VAR 0 1
24544: PUSH
24545: DOUBLE
24546: LD_INT 1
24548: DEC
24549: ST_TO_ADDR
24550: LD_EXP 18
24554: PUSH
24555: FOR_TO
24556: IFFALSE 24880
// begin for j in powellSquadAttack [ i ] do
24558: LD_ADDR_VAR 0 2
24562: PUSH
24563: LD_EXP 18
24567: PUSH
24568: LD_VAR 0 1
24572: ARRAY
24573: PUSH
24574: FOR_IN
24575: IFFALSE 24876
// begin if j in mc_bases [ 4 ] then
24577: LD_VAR 0 2
24581: PUSH
24582: LD_EXP 102
24586: PUSH
24587: LD_INT 4
24589: ARRAY
24590: IN
24591: IFFALSE 24626
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24593: LD_ADDR_EXP 102
24597: PUSH
24598: LD_EXP 102
24602: PPUSH
24603: LD_INT 4
24605: PPUSH
24606: LD_EXP 102
24610: PUSH
24611: LD_INT 4
24613: ARRAY
24614: PUSH
24615: LD_VAR 0 2
24619: DIFF
24620: PPUSH
24621: CALL_OW 1
24625: ST_TO_ADDR
// forces := forces diff j ;
24626: LD_ADDR_VAR 0 6
24630: PUSH
24631: LD_VAR 0 6
24635: PUSH
24636: LD_VAR 0 2
24640: DIFF
24641: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24642: LD_VAR 0 2
24646: PPUSH
24647: LD_INT 1
24649: PPUSH
24650: CALL_OW 109
// wait ( 0 0$2 ) ;
24654: LD_INT 70
24656: PPUSH
24657: CALL_OW 67
// if IsInUnit ( j ) then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 310
24670: IFFALSE 24681
// ComExitBuilding ( j ) ;
24672: LD_VAR 0 2
24676: PPUSH
24677: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24681: LD_VAR 0 2
24685: PPUSH
24686: CALL_OW 257
24690: PUSH
24691: LD_INT 1
24693: NONEQUAL
24694: IFFALSE 24708
24696: PUSH
24697: LD_VAR 0 2
24701: PPUSH
24702: CALL_OW 314
24706: NOT
24707: AND
24708: IFFALSE 24788
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24710: LD_VAR 0 11
24714: PUSH
24715: LD_INT 1
24717: ARRAY
24718: PPUSH
24719: CALL_OW 313
24723: PUSH
24724: LD_INT 5
24726: GREATEREQUAL
24727: IFFALSE 24749
// ComEnterUnit ( j , arm [ 2 ] ) else
24729: LD_VAR 0 2
24733: PPUSH
24734: LD_VAR 0 11
24738: PUSH
24739: LD_INT 2
24741: ARRAY
24742: PPUSH
24743: CALL_OW 120
24747: GO 24767
// ComEnterUnit ( j , arm [ 1 ] ) ;
24749: LD_VAR 0 2
24753: PPUSH
24754: LD_VAR 0 11
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PPUSH
24763: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24767: LD_VAR 0 2
24771: PPUSH
24772: LD_INT 1
24774: PPUSH
24775: CALL_OW 183
// AddComExitBuilding ( j ) ;
24779: LD_VAR 0 2
24783: PPUSH
24784: CALL_OW 182
// end ; if i = 2 then
24788: LD_VAR 0 1
24792: PUSH
24793: LD_INT 2
24795: EQUAL
24796: IFFALSE 24813
// AddComMoveXY ( j , 61 , 93 ) ;
24798: LD_VAR 0 2
24802: PPUSH
24803: LD_INT 61
24805: PPUSH
24806: LD_INT 93
24808: PPUSH
24809: CALL_OW 171
// if i = 1 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 1
24820: EQUAL
24821: IFFALSE 24874
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24823: LD_VAR 0 2
24827: PPUSH
24828: LD_VAR 0 3
24832: PUSH
24833: LD_INT 1
24835: ARRAY
24836: PPUSH
24837: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24841: LD_ADDR_VAR 0 3
24845: PUSH
24846: LD_VAR 0 3
24850: PPUSH
24851: LD_INT 1
24853: PPUSH
24854: CALL_OW 3
24858: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24859: LD_VAR 0 2
24863: PPUSH
24864: LD_INT 69
24866: PPUSH
24867: LD_INT 94
24869: PPUSH
24870: CALL_OW 171
// end ; end ;
24874: GO 24574
24876: POP
24877: POP
// end ;
24878: GO 24555
24880: POP
24881: POP
// wait ( 0 0$30 ) ;
24882: LD_INT 1050
24884: PPUSH
24885: CALL_OW 67
// MC_Kill ( 4 ) ;
24889: LD_INT 4
24891: PPUSH
24892: CALL 40134 0 1
// tmp := UnitsInside ( fac ) ;
24896: LD_ADDR_VAR 0 3
24900: PUSH
24901: LD_VAR 0 10
24905: PPUSH
24906: CALL_OW 313
24910: ST_TO_ADDR
// if tmp then
24911: LD_VAR 0 3
24915: IFFALSE 25036
// for i in tmp do
24917: LD_ADDR_VAR 0 1
24921: PUSH
24922: LD_VAR 0 3
24926: PUSH
24927: FOR_IN
24928: IFFALSE 25034
// begin ComExitBuilding ( i ) ;
24930: LD_VAR 0 1
24934: PPUSH
24935: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24939: LD_VAR 0 11
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 313
24952: PUSH
24953: LD_INT 6
24955: LESS
24956: IFFALSE 24978
// AddComEnterUnit ( i , arm [ 2 ] ) else
24958: LD_VAR 0 1
24962: PPUSH
24963: LD_VAR 0 11
24967: PUSH
24968: LD_INT 2
24970: ARRAY
24971: PPUSH
24972: CALL_OW 180
24976: GO 25032
// if UnitsInside ( arm [ 1 ] ) < 6 then
24978: LD_VAR 0 11
24982: PUSH
24983: LD_INT 1
24985: ARRAY
24986: PPUSH
24987: CALL_OW 313
24991: PUSH
24992: LD_INT 6
24994: LESS
24995: IFFALSE 25017
// AddComEnterUnit ( i , arm [ 1 ] ) else
24997: LD_VAR 0 1
25001: PPUSH
25002: LD_VAR 0 11
25006: PUSH
25007: LD_INT 1
25009: ARRAY
25010: PPUSH
25011: CALL_OW 180
25015: GO 25032
// AddComMoveXY ( i , 37 , 68 ) ;
25017: LD_VAR 0 1
25021: PPUSH
25022: LD_INT 37
25024: PPUSH
25025: LD_INT 68
25027: PPUSH
25028: CALL_OW 171
// end ;
25032: GO 24927
25034: POP
25035: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
25036: LD_ADDR_VAR 0 12
25040: PUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: LD_INT 26
25048: PUSH
25049: LD_INT 1
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PPUSH
25056: CALL_OW 72
25060: PUSH
25061: LD_EXP 62
25065: DIFF
25066: ST_TO_ADDR
// if not speaker then
25067: LD_VAR 0 12
25071: NOT
25072: IFFALSE 25099
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
25074: LD_ADDR_VAR 0 12
25078: PUSH
25079: LD_VAR 0 6
25083: PPUSH
25084: LD_INT 26
25086: PUSH
25087: LD_INT 1
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PPUSH
25094: CALL_OW 72
25098: ST_TO_ADDR
// if speaker then
25099: LD_VAR 0 12
25103: IFFALSE 25119
// speaker := speaker [ 1 ] ;
25105: LD_ADDR_VAR 0 12
25109: PUSH
25110: LD_VAR 0 12
25114: PUSH
25115: LD_INT 1
25117: ARRAY
25118: ST_TO_ADDR
// Video ( true ) ;
25119: LD_INT 1
25121: PPUSH
25122: CALL 109067 0 1
// CenterNowOnUnits ( Powell ) ;
25126: LD_EXP 61
25130: PPUSH
25131: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
25135: LD_ADDR_VAR 0 3
25139: PUSH
25140: LD_VAR 0 6
25144: PPUSH
25145: LD_INT 3
25147: PUSH
25148: LD_INT 25
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PPUSH
25162: CALL_OW 72
25166: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
25167: LD_ADDR_VAR 0 13
25171: PUSH
25172: LD_INT 22
25174: PUSH
25175: LD_INT 4
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 32
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: LD_INT 58
25194: PUSH
25195: EMPTY
25196: LIST
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: PPUSH
25203: CALL_OW 69
25207: ST_TO_ADDR
// t := Count ( tmp ) ;
25208: LD_ADDR_VAR 0 7
25212: PUSH
25213: LD_VAR 0 3
25217: PPUSH
25218: CALL 73163 0 1
25222: ST_TO_ADDR
// if t > 4 then
25223: LD_VAR 0 7
25227: PUSH
25228: LD_INT 4
25230: GREATER
25231: IFFALSE 25241
// t := 4 ;
25233: LD_ADDR_VAR 0 7
25237: PUSH
25238: LD_INT 4
25240: ST_TO_ADDR
// for i := 1 to t do
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: DOUBLE
25247: LD_INT 1
25249: DEC
25250: ST_TO_ADDR
25251: LD_VAR 0 7
25255: PUSH
25256: FOR_TO
25257: IFFALSE 25403
// begin if IsInUnit ( tmp [ i ] ) then
25259: LD_VAR 0 3
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: CALL_OW 310
25274: IFFALSE 25291
// ComExitBuilding ( tmp [ i ] ) ;
25276: LD_VAR 0 3
25280: PUSH
25281: LD_VAR 0 1
25285: ARRAY
25286: PPUSH
25287: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25291: LD_VAR 0 3
25295: PUSH
25296: LD_VAR 0 1
25300: ARRAY
25301: PPUSH
25302: LD_VAR 0 11
25306: PUSH
25307: LD_INT 1
25309: ARRAY
25310: PPUSH
25311: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25315: LD_VAR 0 3
25319: PUSH
25320: LD_VAR 0 1
25324: ARRAY
25325: PPUSH
25326: LD_INT 1
25328: PPUSH
25329: CALL_OW 183
// if Count ( emp_towers ) then
25333: LD_VAR 0 13
25337: PPUSH
25338: CALL 73163 0 1
25342: IFFALSE 25401
// begin AddComExitBuilding ( tmp [ i ] ) ;
25344: LD_VAR 0 3
25348: PUSH
25349: LD_VAR 0 1
25353: ARRAY
25354: PPUSH
25355: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25359: LD_VAR 0 3
25363: PUSH
25364: LD_VAR 0 1
25368: ARRAY
25369: PPUSH
25370: LD_VAR 0 13
25374: PUSH
25375: LD_INT 1
25377: ARRAY
25378: PPUSH
25379: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25383: LD_ADDR_VAR 0 13
25387: PUSH
25388: LD_VAR 0 13
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 3
25400: ST_TO_ADDR
// end ; end ;
25401: GO 25256
25403: POP
25404: POP
// wait ( 0 0$5 ) ;
25405: LD_INT 175
25407: PPUSH
25408: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25412: LD_VAR 0 3
25416: PPUSH
25417: LD_INT 3
25419: PUSH
25420: LD_INT 54
25422: PUSH
25423: EMPTY
25424: LIST
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PPUSH
25430: CALL_OW 72
25434: IFFALSE 25454
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25436: LD_VAR 0 3
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25454: LD_ADDR_VAR 0 3
25458: PUSH
25459: LD_EXP 18
25463: PUSH
25464: LD_INT 1
25466: ARRAY
25467: PUSH
25468: LD_EXP 18
25472: PUSH
25473: LD_INT 2
25475: ARRAY
25476: ADD
25477: PPUSH
25478: LD_INT 26
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25493: LD_ADDR_VAR 0 1
25497: PUSH
25498: LD_EXP 18
25502: PUSH
25503: LD_INT 2
25505: ARRAY
25506: PUSH
25507: FOR_IN
25508: IFFALSE 25526
// ComTurnUnit ( i , Powell ) ;
25510: LD_VAR 0 1
25514: PPUSH
25515: LD_EXP 61
25519: PPUSH
25520: CALL_OW 119
25524: GO 25507
25526: POP
25527: POP
// Say ( Powell , D5-Pow-1 ) ;
25528: LD_EXP 61
25532: PPUSH
25533: LD_STRING D5-Pow-1
25535: PPUSH
25536: CALL_OW 88
// if tmp then
25540: LD_VAR 0 3
25544: IFFALSE 25562
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25546: LD_VAR 0 3
25550: PUSH
25551: LD_INT 1
25553: ARRAY
25554: PPUSH
25555: LD_STRING D5-Sol2-1
25557: PPUSH
25558: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25562: LD_EXP 61
25566: PPUSH
25567: LD_STRING D5-Pow-2
25569: PPUSH
25570: CALL_OW 88
// if tmp > 1 then
25574: LD_VAR 0 3
25578: PUSH
25579: LD_INT 1
25581: GREATER
25582: IFFALSE 25600
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 2
25591: ARRAY
25592: PPUSH
25593: LD_STRING D5-Sol2-2
25595: PPUSH
25596: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25600: LD_EXP 61
25604: PPUSH
25605: LD_STRING D5-Pow-3
25607: PPUSH
25608: CALL_OW 88
// wait ( 0 0$1 ) ;
25612: LD_INT 35
25614: PPUSH
25615: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25619: LD_ADDR_VAR 0 3
25623: PUSH
25624: LD_EXP 18
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PUSH
25633: LD_EXP 18
25637: PUSH
25638: LD_INT 2
25640: ARRAY
25641: UNION
25642: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25643: LD_VAR 0 3
25647: PPUSH
25648: LD_INT 80
25650: PPUSH
25651: LD_INT 67
25653: PPUSH
25654: CALL_OW 114
// wait ( 0 0$2 ) ;
25658: LD_INT 70
25660: PPUSH
25661: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25665: LD_INT 79
25667: PPUSH
25668: LD_INT 72
25670: PPUSH
25671: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25675: LD_INT 70
25677: PPUSH
25678: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25682: LD_VAR 0 3
25686: PPUSH
25687: LD_INT 3
25689: PUSH
25690: LD_INT 24
25692: PUSH
25693: LD_INT 1000
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PPUSH
25704: CALL_OW 72
25708: IFFALSE 25675
// Say ( Powell , D5a-Pow-1 ) ;
25710: LD_EXP 61
25714: PPUSH
25715: LD_STRING D5a-Pow-1
25717: PPUSH
25718: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25722: LD_EXP 61
25726: PPUSH
25727: LD_STRING D5a-Pow-1a
25729: PPUSH
25730: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25734: LD_INT 24
25736: PPUSH
25737: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25741: LD_EXP 61
25745: PPUSH
25746: LD_STRING D5a-Pow-1b
25748: PPUSH
25749: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25753: LD_INT 10
25755: PPUSH
25756: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25760: LD_EXP 61
25764: PPUSH
25765: LD_STRING D5a-Pow-1c
25767: PPUSH
25768: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25772: LD_VAR 0 3
25776: PPUSH
25777: LD_INT 68
25779: PPUSH
25780: LD_INT 63
25782: PPUSH
25783: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25787: LD_INT 18
25789: PPUSH
25790: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25794: LD_EXP 61
25798: PPUSH
25799: LD_STRING D5a-Pow-1d
25801: PPUSH
25802: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25806: LD_INT 35
25808: PPUSH
25809: CALL_OW 67
// if not HasTask ( tmp ) then
25813: LD_VAR 0 3
25817: PPUSH
25818: CALL_OW 314
25822: NOT
25823: IFFALSE 25840
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 68
25832: PPUSH
25833: LD_INT 63
25835: PPUSH
25836: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25840: LD_VAR 0 3
25844: PPUSH
25845: LD_INT 24
25847: PUSH
25848: LD_INT 1
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PPUSH
25855: CALL_OW 72
25859: NOT
25860: IFFALSE 25806
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25862: LD_ADDR_VAR 0 3
25866: PUSH
25867: LD_INT 22
25869: PUSH
25870: LD_INT 4
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 92
25879: PUSH
25880: LD_INT 60
25882: PUSH
25883: LD_INT 93
25885: PUSH
25886: LD_INT 10
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 3
25897: PUSH
25898: LD_INT 54
25900: PUSH
25901: EMPTY
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 69
25917: PUSH
25918: LD_EXP 61
25922: DIFF
25923: ST_TO_ADDR
// if tmp then
25924: LD_VAR 0 3
25928: IFFALSE 25962
// for i in tmp do
25930: LD_ADDR_VAR 0 1
25934: PUSH
25935: LD_VAR 0 3
25939: PUSH
25940: FOR_IN
25941: IFFALSE 25960
// ComMoveXY ( i , 36 , 67 ) ;
25943: LD_VAR 0 1
25947: PPUSH
25948: LD_INT 36
25950: PPUSH
25951: LD_INT 67
25953: PPUSH
25954: CALL_OW 111
25958: GO 25940
25960: POP
25961: POP
// wait ( 0 0$3 ) ;
25962: LD_INT 105
25964: PPUSH
25965: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25969: LD_VAR 0 12
25973: PPUSH
25974: LD_STRING D6-Sol3-1
25976: PPUSH
25977: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25981: LD_EXP 61
25985: PPUSH
25986: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25990: LD_EXP 61
25994: PPUSH
25995: LD_STRING D6-Pow-1
25997: PPUSH
25998: CALL_OW 88
// tmp := [ ] ;
26002: LD_ADDR_VAR 0 3
26006: PUSH
26007: EMPTY
26008: ST_TO_ADDR
// for i = 1 to 2 do
26009: LD_ADDR_VAR 0 1
26013: PUSH
26014: DOUBLE
26015: LD_INT 1
26017: DEC
26018: ST_TO_ADDR
26019: LD_INT 2
26021: PUSH
26022: FOR_TO
26023: IFFALSE 26137
// begin uc_side := 8 ;
26025: LD_ADDR_OWVAR 20
26029: PUSH
26030: LD_INT 8
26032: ST_TO_ADDR
// uc_nation := 2 ;
26033: LD_ADDR_OWVAR 21
26037: PUSH
26038: LD_INT 2
26040: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
26041: LD_INT 14
26043: PPUSH
26044: LD_INT 3
26046: PPUSH
26047: LD_INT 2
26049: PPUSH
26050: LD_INT 29
26052: PPUSH
26053: LD_INT 100
26055: PPUSH
26056: CALL 75925 0 5
// veh := CreateVehicle ;
26060: LD_ADDR_VAR 0 14
26064: PUSH
26065: CALL_OW 45
26069: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
26070: LD_VAR 0 14
26074: PPUSH
26075: LD_INT 4
26077: PPUSH
26078: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
26082: LD_VAR 0 14
26086: PPUSH
26087: LD_INT 99
26089: PPUSH
26090: LD_INT 83
26092: PPUSH
26093: LD_INT 3
26095: PPUSH
26096: LD_INT 0
26098: PPUSH
26099: CALL_OW 50
// wait ( 3 ) ;
26103: LD_INT 3
26105: PPUSH
26106: CALL_OW 67
// Connect ( veh ) ;
26110: LD_VAR 0 14
26114: PPUSH
26115: CALL 79407 0 1
// tmp := tmp ^ veh ;
26119: LD_ADDR_VAR 0 3
26123: PUSH
26124: LD_VAR 0 3
26128: PUSH
26129: LD_VAR 0 14
26133: ADD
26134: ST_TO_ADDR
// end ;
26135: GO 26022
26137: POP
26138: POP
// wait ( 0 0$1 ) ;
26139: LD_INT 35
26141: PPUSH
26142: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
26146: LD_INT 99
26148: PPUSH
26149: LD_INT 83
26151: PPUSH
26152: LD_INT 1
26154: PPUSH
26155: LD_INT 10
26157: PPUSH
26158: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
26162: LD_INT 99
26164: PPUSH
26165: LD_INT 83
26167: PPUSH
26168: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
26172: LD_VAR 0 12
26176: PPUSH
26177: LD_STRING D6-Sol3-2
26179: PPUSH
26180: CALL_OW 88
// async ;
26184: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
26185: LD_EXP 61
26189: PPUSH
26190: LD_STRING D6-Pow-2
26192: PPUSH
26193: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
26197: LD_VAR 0 3
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: PPUSH
26206: LD_VAR 0 10
26210: PPUSH
26211: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26215: LD_VAR 0 3
26219: PUSH
26220: LD_INT 2
26222: ARRAY
26223: PPUSH
26224: LD_INT 22
26226: PUSH
26227: LD_INT 4
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 21
26236: PUSH
26237: LD_INT 3
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PPUSH
26248: CALL_OW 69
26252: PPUSH
26253: LD_VAR 0 3
26257: PUSH
26258: LD_INT 2
26260: ARRAY
26261: PPUSH
26262: CALL_OW 74
26266: PPUSH
26267: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26271: LD_EXP 61
26275: PPUSH
26276: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26280: LD_INT 99
26282: PPUSH
26283: LD_INT 83
26285: PPUSH
26286: LD_INT 1
26288: PPUSH
26289: CALL_OW 331
// repeat wait ( 4 ) ;
26293: LD_INT 4
26295: PPUSH
26296: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26300: LD_VAR 0 3
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: PPUSH
26309: CALL_OW 256
26313: PUSH
26314: LD_INT 1000
26316: LESS
26317: IFFALSE 26335
// SetLives ( tmp [ 1 ] , 1000 ) ;
26319: LD_VAR 0 3
26323: PUSH
26324: LD_INT 1
26326: ARRAY
26327: PPUSH
26328: LD_INT 1000
26330: PPUSH
26331: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26335: LD_INT 22
26337: PUSH
26338: LD_INT 4
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: LD_INT 30
26347: PUSH
26348: LD_INT 3
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PPUSH
26359: CALL_OW 69
26363: PUSH
26364: LD_INT 0
26366: EQUAL
26367: IFFALSE 26293
// skirmish := false ;
26369: LD_ADDR_EXP 100
26373: PUSH
26374: LD_INT 0
26376: ST_TO_ADDR
// sync ;
26377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26378: LD_EXP 61
26382: PPUSH
26383: LD_STRING D6a-Pow-1
26385: PPUSH
26386: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26390: LD_VAR 0 12
26394: PPUSH
26395: LD_STRING D6a-Sol3-1
26397: PPUSH
26398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26402: LD_EXP 61
26406: PPUSH
26407: LD_STRING D6a-Pow-2
26409: PPUSH
26410: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26414: LD_VAR 0 12
26418: PPUSH
26419: LD_STRING D6a-Sol3-2
26421: PPUSH
26422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26426: LD_EXP 61
26430: PPUSH
26431: LD_STRING D6a-Pow-3
26433: PPUSH
26434: CALL_OW 88
// powellCenterCameraMode := true ;
26438: LD_ADDR_EXP 20
26442: PUSH
26443: LD_INT 1
26445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26446: LD_ADDR_VAR 0 1
26450: PUSH
26451: LD_INT 22
26453: PUSH
26454: LD_INT 8
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 25
26463: PUSH
26464: LD_INT 2
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PPUSH
26475: CALL_OW 69
26479: PUSH
26480: FOR_IN
26481: IFFALSE 26536
// begin SetTag ( i , 1 ) ;
26483: LD_VAR 0 1
26487: PPUSH
26488: LD_INT 1
26490: PPUSH
26491: CALL_OW 109
// ComExitBuilding ( i ) ;
26495: LD_VAR 0 1
26499: PPUSH
26500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26504: LD_VAR 0 1
26508: PPUSH
26509: LD_INT 35
26511: PPUSH
26512: LD_INT 6
26514: PPUSH
26515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26519: LD_VAR 0 1
26523: PPUSH
26524: LD_INT 53
26526: PPUSH
26527: LD_INT 4
26529: PPUSH
26530: CALL_OW 171
// end ;
26534: GO 26480
26536: POP
26537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26538: LD_ADDR_VAR 0 3
26542: PUSH
26543: LD_INT 22
26545: PUSH
26546: LD_INT 4
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 21
26555: PUSH
26556: LD_INT 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 3
26565: PUSH
26566: LD_INT 34
26568: PUSH
26569: LD_INT 12
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: PPUSH
26585: CALL_OW 69
26589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26590: LD_EXP 61
26594: PPUSH
26595: LD_VAR 0 3
26599: PPUSH
26600: LD_EXP 61
26604: PPUSH
26605: CALL_OW 74
26609: PPUSH
26610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26614: LD_EXP 61
26618: PPUSH
26619: LD_INT 100
26621: PPUSH
26622: LD_INT 88
26624: PPUSH
26625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26629: LD_EXP 61
26633: PPUSH
26634: LD_INT 100
26636: PPUSH
26637: LD_INT 75
26639: PPUSH
26640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26644: LD_EXP 61
26648: PPUSH
26649: LD_INT 88
26651: PPUSH
26652: LD_INT 53
26654: PPUSH
26655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26659: LD_INT 8
26661: PPUSH
26662: LD_EXP 61
26666: PPUSH
26667: CALL_OW 471
// repeat wait ( 3 ) ;
26671: LD_INT 3
26673: PPUSH
26674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26678: LD_INT 22
26680: PUSH
26681: LD_INT 4
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 92
26690: PUSH
26691: LD_INT 100
26693: PUSH
26694: LD_INT 75
26696: PUSH
26697: LD_INT 6
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PPUSH
26710: CALL_OW 69
26714: IFFALSE 26671
// async ;
26716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26717: LD_EXP 61
26721: PPUSH
26722: LD_STRING D6b-Pow-1
26724: PPUSH
26725: CALL_OW 88
// repeat wait ( 3 ) ;
26729: LD_INT 3
26731: PPUSH
26732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26736: LD_EXP 61
26740: PPUSH
26741: CALL_OW 310
26745: PPUSH
26746: CALL_OW 256
26750: PUSH
26751: LD_INT 1000
26753: LESS
26754: IFFALSE 26773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26756: LD_EXP 61
26760: PPUSH
26761: CALL_OW 310
26765: PPUSH
26766: LD_INT 1000
26768: PPUSH
26769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26773: LD_EXP 61
26777: PPUSH
26778: CALL_OW 256
26782: PUSH
26783: LD_INT 1000
26785: LESS
26786: IFFALSE 26800
// SetLives ( Powell , 1000 ) ;
26788: LD_EXP 61
26792: PPUSH
26793: LD_INT 1000
26795: PPUSH
26796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26800: LD_EXP 61
26804: PPUSH
26805: LD_EXP 67
26809: PPUSH
26810: CALL_OW 296
26814: PUSH
26815: LD_INT 5
26817: LESS
26818: IFTRUE 26845
26820: PUSH
26821: LD_EXP 61
26825: PPUSH
26826: CALL_OW 310
26830: PPUSH
26831: LD_EXP 67
26835: PPUSH
26836: CALL_OW 296
26840: PUSH
26841: LD_INT 5
26843: LESS
26844: OR
26845: IFFALSE 26864
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26847: LD_EXP 61
26851: PPUSH
26852: CALL_OW 310
26856: PPUSH
26857: LD_INT 100
26859: PPUSH
26860: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26864: LD_EXP 61
26868: PPUSH
26869: CALL_OW 310
26873: NOT
26874: IFFALSE 26729
// DoNotAttack ( 8 , powellBomb ) ;
26876: LD_INT 8
26878: PPUSH
26879: LD_EXP 67
26883: PPUSH
26884: CALL_OW 471
// game_speed := 4 ;
26888: LD_ADDR_OWVAR 65
26892: PUSH
26893: LD_INT 4
26895: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26896: LD_EXP 61
26900: PPUSH
26901: LD_STRING D6b-Pow-1a
26903: PPUSH
26904: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26908: LD_EXP 61
26912: PPUSH
26913: LD_EXP 67
26917: PPUSH
26918: CALL_OW 180
// sync ;
26922: SYNC
// repeat wait ( 0 0$1 ) ;
26923: LD_INT 35
26925: PPUSH
26926: CALL_OW 67
// until IsInUnit ( Powell ) ;
26930: LD_EXP 61
26934: PPUSH
26935: CALL_OW 310
26939: IFFALSE 26923
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26941: LD_INT 8
26943: PPUSH
26944: LD_EXP 61
26948: PPUSH
26949: CALL_OW 310
26953: PPUSH
26954: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26958: LD_EXP 61
26962: PPUSH
26963: LD_INT 91
26965: PPUSH
26966: LD_INT 44
26968: PPUSH
26969: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26973: LD_EXP 61
26977: PPUSH
26978: LD_INT 96
26980: PPUSH
26981: LD_INT 44
26983: PPUSH
26984: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26988: LD_EXP 61
26992: PPUSH
26993: LD_INT 96
26995: PPUSH
26996: LD_INT 41
26998: PPUSH
26999: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27003: LD_EXP 61
27007: PPUSH
27008: LD_INT 92
27010: PPUSH
27011: LD_INT 39
27013: PPUSH
27014: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27018: LD_EXP 61
27022: PPUSH
27023: LD_INT 88
27025: PPUSH
27026: LD_INT 41
27028: PPUSH
27029: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27033: LD_EXP 61
27037: PPUSH
27038: LD_INT 91
27040: PPUSH
27041: LD_INT 44
27043: PPUSH
27044: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
27048: LD_EXP 61
27052: PPUSH
27053: LD_INT 96
27055: PPUSH
27056: LD_INT 44
27058: PPUSH
27059: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
27063: LD_EXP 61
27067: PPUSH
27068: LD_INT 96
27070: PPUSH
27071: LD_INT 41
27073: PPUSH
27074: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27078: LD_EXP 61
27082: PPUSH
27083: LD_INT 92
27085: PPUSH
27086: LD_INT 39
27088: PPUSH
27089: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27093: LD_EXP 61
27097: PPUSH
27098: LD_INT 88
27100: PPUSH
27101: LD_INT 41
27103: PPUSH
27104: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27108: LD_EXP 61
27112: PPUSH
27113: LD_INT 91
27115: PPUSH
27116: LD_INT 44
27118: PPUSH
27119: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
27123: LD_EXP 61
27127: PPUSH
27128: LD_INT 93
27130: PPUSH
27131: LD_INT 39
27133: PPUSH
27134: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
27138: LD_EXP 61
27142: PPUSH
27143: LD_INT 93
27145: PPUSH
27146: LD_INT 36
27148: PPUSH
27149: CALL_OW 171
// wait ( 0 0$3.5 ) ;
27153: LD_INT 122
27155: PPUSH
27156: CALL_OW 67
// game_speed := 4 ;
27160: LD_ADDR_OWVAR 65
27164: PUSH
27165: LD_INT 4
27167: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
27168: LD_EXP 61
27172: PPUSH
27173: LD_STRING D6b-Pow-1b
27175: PPUSH
27176: CALL_OW 88
// tmp := [ ] ;
27180: LD_ADDR_VAR 0 3
27184: PUSH
27185: EMPTY
27186: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
27187: LD_ADDR_VAR 0 5
27191: PUSH
27192: LD_INT 78
27194: PUSH
27195: LD_INT 47
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 106
27204: PUSH
27205: LD_INT 53
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27216: LD_ADDR_VAR 0 1
27220: PUSH
27221: LD_INT 22
27223: PUSH
27224: LD_INT 8
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 21
27233: PUSH
27234: LD_INT 3
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 92
27243: PUSH
27244: LD_INT 90
27246: PUSH
27247: LD_INT 52
27249: PUSH
27250: LD_INT 12
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: LIST
27257: LIST
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: PPUSH
27264: CALL_OW 69
27268: PUSH
27269: FOR_IN
27270: IFFALSE 27295
// tmp := tmp ^ UnitsInside ( i ) ;
27272: LD_ADDR_VAR 0 3
27276: PUSH
27277: LD_VAR 0 3
27281: PUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: CALL_OW 313
27291: ADD
27292: ST_TO_ADDR
27293: GO 27269
27295: POP
27296: POP
// for i in tmp do
27297: LD_ADDR_VAR 0 1
27301: PUSH
27302: LD_VAR 0 3
27306: PUSH
27307: FOR_IN
27308: IFFALSE 27470
// begin dist := 9999 ;
27310: LD_ADDR_VAR 0 9
27314: PUSH
27315: LD_INT 9999
27317: ST_TO_ADDR
// _xy := [ ] ;
27318: LD_ADDR_VAR 0 8
27322: PUSH
27323: EMPTY
27324: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: CALL_OW 109
// ComExitBuilding ( i ) ;
27337: LD_VAR 0 1
27341: PPUSH
27342: CALL_OW 122
// for j in xy do
27346: LD_ADDR_VAR 0 2
27350: PUSH
27351: LD_VAR 0 5
27355: PUSH
27356: FOR_IN
27357: IFFALSE 27439
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_VAR 0 2
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: LD_VAR 0 2
27377: PUSH
27378: LD_INT 2
27380: ARRAY
27381: PPUSH
27382: CALL_OW 297
27386: PUSH
27387: LD_VAR 0 9
27391: LESS
27392: IFFALSE 27437
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27394: LD_ADDR_VAR 0 9
27398: PUSH
27399: LD_VAR 0 1
27403: PPUSH
27404: LD_VAR 0 2
27408: PUSH
27409: LD_INT 1
27411: ARRAY
27412: PPUSH
27413: LD_VAR 0 2
27417: PUSH
27418: LD_INT 2
27420: ARRAY
27421: PPUSH
27422: CALL_OW 297
27426: ST_TO_ADDR
// _xy := j ;
27427: LD_ADDR_VAR 0 8
27431: PUSH
27432: LD_VAR 0 2
27436: ST_TO_ADDR
// end ;
27437: GO 27356
27439: POP
27440: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27441: LD_VAR 0 1
27445: PPUSH
27446: LD_VAR 0 8
27450: PUSH
27451: LD_INT 1
27453: ARRAY
27454: PPUSH
27455: LD_VAR 0 8
27459: PUSH
27460: LD_INT 2
27462: ARRAY
27463: PPUSH
27464: CALL_OW 171
// end ;
27468: GO 27307
27470: POP
27471: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27472: LD_ADDR_VAR 0 4
27476: PUSH
27477: LD_VAR 0 3
27481: PPUSH
27482: LD_INT 26
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 25
27494: PUSH
27495: LD_INT 1
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PPUSH
27506: CALL_OW 72
27510: ST_TO_ADDR
// if tmp2 < 2 then
27511: LD_VAR 0 4
27515: PUSH
27516: LD_INT 2
27518: LESS
27519: IFFALSE 27588
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27521: LD_ADDR_VAR 0 4
27525: PUSH
27526: LD_INT 22
27528: PUSH
27529: LD_INT 8
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 26
27538: PUSH
27539: LD_INT 1
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: LD_INT 25
27551: PUSH
27552: LD_INT 15
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: PPUSH
27568: CALL_OW 69
27572: PUSH
27573: LD_EXP 64
27577: PUSH
27578: LD_EXP 65
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: DIFF
27587: ST_TO_ADDR
// if tmp2 then
27588: LD_VAR 0 4
27592: IFFALSE 27610
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27594: LD_VAR 0 4
27598: PUSH
27599: LD_INT 1
27601: ARRAY
27602: PPUSH
27603: LD_STRING D6b-ArSol1-1
27605: PPUSH
27606: CALL_OW 88
// async ;
27610: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27611: LD_EXP 61
27615: PPUSH
27616: LD_STRING D6b-Pow-2
27618: PPUSH
27619: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27623: LD_INT 18
27625: PPUSH
27626: CALL_OW 67
// if tmp2 > 1 then
27630: LD_VAR 0 4
27634: PUSH
27635: LD_INT 1
27637: GREATER
27638: IFFALSE 27656
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27640: LD_VAR 0 4
27644: PUSH
27645: LD_INT 2
27647: ARRAY
27648: PPUSH
27649: LD_STRING D6b-ArSol2-1
27651: PPUSH
27652: CALL_OW 88
// sync ;
27656: SYNC
// repeat wait ( 5 ) ;
27657: LD_INT 5
27659: PPUSH
27660: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27664: LD_INT 93
27666: PPUSH
27667: LD_INT 36
27669: PPUSH
27670: CALL_OW 428
27674: PPUSH
27675: CALL_OW 255
27679: PUSH
27680: LD_INT 4
27682: EQUAL
27683: IFFALSE 27657
// DialogueOn ;
27685: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27689: LD_INT 10
27691: PPUSH
27692: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27696: LD_EXP 61
27700: PPUSH
27701: LD_STRING D6b-Pow-2a
27703: PPUSH
27704: CALL_OW 88
// DialogueOff ;
27708: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27712: LD_EXP 61
27716: PPUSH
27717: CALL_OW 310
27721: PPUSH
27722: LD_INT 332
27724: PPUSH
27725: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27729: LD_INT 93
27731: PPUSH
27732: LD_INT 35
27734: PPUSH
27735: LD_INT 1
27737: PPUSH
27738: LD_INT 6
27740: NEG
27741: PPUSH
27742: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27746: LD_INT 35
27748: PPUSH
27749: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27753: LD_INT 332
27755: PPUSH
27756: CALL_OW 256
27760: PUSH
27761: LD_INT 1000
27763: LESS
27764: IFFALSE 27775
27766: PUSH
27767: LD_INT 332
27769: PPUSH
27770: CALL_OW 300
27774: AND
27775: IFFALSE 27787
// SetLives ( kozlov_fac , 0 ) ;
27777: LD_INT 332
27779: PPUSH
27780: LD_INT 0
27782: PPUSH
27783: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27787: LD_INT 332
27789: PPUSH
27790: CALL_OW 301
27794: IFTRUE 27807
27796: PUSH
27797: LD_EXP 61
27801: PPUSH
27802: CALL_OW 301
27806: OR
27807: IFFALSE 27746
// game_speed := 4 ;
27809: LD_ADDR_OWVAR 65
27813: PUSH
27814: LD_INT 4
27816: ST_TO_ADDR
// powellCenterCameraMode := false ;
27817: LD_ADDR_EXP 20
27821: PUSH
27822: LD_INT 0
27824: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27825: LD_ADDR_VAR 0 1
27829: PUSH
27830: LD_VAR 0 3
27834: PUSH
27835: LD_INT 22
27837: PUSH
27838: LD_INT 8
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 25
27847: PUSH
27848: LD_INT 2
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PPUSH
27859: CALL_OW 69
27863: UNION
27864: PUSH
27865: FOR_IN
27866: IFFALSE 27882
// SetTag ( i , 0 ) ;
27868: LD_VAR 0 1
27872: PPUSH
27873: LD_INT 0
27875: PPUSH
27876: CALL_OW 109
27880: GO 27865
27882: POP
27883: POP
// wait ( 0 0$3 ) ;
27884: LD_INT 105
27886: PPUSH
27887: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27891: LD_INT 93
27893: PPUSH
27894: LD_INT 35
27896: PPUSH
27897: LD_INT 1
27899: PPUSH
27900: CALL_OW 331
// DialogueOn ;
27904: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27908: LD_VAR 0 12
27912: PPUSH
27913: LD_STRING D6c-Sol3-1
27915: PPUSH
27916: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27920: LD_INT 10
27922: PPUSH
27923: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27927: LD_EXP 40
27931: PPUSH
27932: LD_STRING D6c-JMM-1
27934: PPUSH
27935: CALL_OW 88
// if Cyrus then
27939: LD_EXP 46
27943: IFFALSE 27957
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27945: LD_EXP 46
27949: PPUSH
27950: LD_STRING D6c-Cyrus-1
27952: PPUSH
27953: CALL_OW 88
// if Bobby then
27957: LD_EXP 45
27961: IFFALSE 27975
// Say ( Bobby , D6c-Bobby-1 ) ;
27963: LD_EXP 45
27967: PPUSH
27968: LD_STRING D6c-Bobby-1
27970: PPUSH
27971: CALL_OW 88
// if Cornel then
27975: LD_EXP 51
27979: IFFALSE 27993
// Say ( Cornel , D6c-Corn-1 ) ;
27981: LD_EXP 51
27985: PPUSH
27986: LD_STRING D6c-Corn-1
27988: PPUSH
27989: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27993: LD_ADDR_VAR 0 4
27997: PUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 22
28003: PUSH
28004: LD_INT 1
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 22
28013: PUSH
28014: LD_INT 4
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 26
28028: PUSH
28029: LD_INT 1
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 23
28038: PUSH
28039: LD_INT 1
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: CALL_OW 69
28055: PUSH
28056: LD_VAR 0 12
28060: PUSH
28061: LD_EXP 40
28065: UNION
28066: PUSH
28067: LD_EXP 62
28071: UNION
28072: DIFF
28073: ST_TO_ADDR
// if tmp2 then
28074: LD_VAR 0 4
28078: IFFALSE 28096
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
28080: LD_VAR 0 4
28084: PUSH
28085: LD_INT 1
28087: ARRAY
28088: PPUSH
28089: LD_STRING D6c-Sol1-1
28091: PPUSH
28092: CALL_OW 88
// if Lisa then
28096: LD_EXP 43
28100: IFFALSE 28114
// Say ( Lisa , D6c-Lisa-1 ) ;
28102: LD_EXP 43
28106: PPUSH
28107: LD_STRING D6c-Lisa-1
28109: PPUSH
28110: CALL_OW 88
// if Gary then
28114: LD_EXP 52
28118: IFFALSE 28132
// Say ( Gary , D6c-Gary-1 ) ;
28120: LD_EXP 52
28124: PPUSH
28125: LD_STRING D6c-Gary-1
28127: PPUSH
28128: CALL_OW 88
// if Donaldson then
28132: LD_EXP 44
28136: IFFALSE 28150
// Say ( Donaldson , D6c-Don-1 ) ;
28138: LD_EXP 44
28142: PPUSH
28143: LD_STRING D6c-Don-1
28145: PPUSH
28146: CALL_OW 88
// if tmp2 > 1 then
28150: LD_VAR 0 4
28154: PUSH
28155: LD_INT 1
28157: GREATER
28158: IFFALSE 28176
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
28160: LD_VAR 0 4
28164: PUSH
28165: LD_INT 2
28167: ARRAY
28168: PPUSH
28169: LD_STRING D6c-Sol2-1
28171: PPUSH
28172: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
28176: LD_VAR 0 12
28180: PPUSH
28181: LD_STRING D6c-Sol3-2
28183: PPUSH
28184: CALL_OW 88
// if IsInUnit ( JMM ) then
28188: LD_EXP 40
28192: PPUSH
28193: CALL_OW 310
28197: IFFALSE 28215
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
28199: LD_EXP 40
28203: PPUSH
28204: CALL_OW 310
28208: PPUSH
28209: CALL_OW 87
28213: GO 28224
// CenterNowOnUnits ( JMM ) ;
28215: LD_EXP 40
28219: PPUSH
28220: CALL_OW 87
// dwait ( 0 0$2 ) ;
28224: LD_INT 70
28226: PPUSH
28227: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28231: LD_EXP 40
28235: PPUSH
28236: LD_STRING D6c-JMM-2
28238: PPUSH
28239: CALL_OW 88
// DialogueOff ;
28243: CALL_OW 7
// Video ( false ) ;
28247: LD_INT 0
28249: PPUSH
28250: CALL 109067 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28254: LD_INT 22
28256: PUSH
28257: LD_INT 4
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PPUSH
28264: CALL_OW 69
28268: PPUSH
28269: LD_INT 1
28271: PPUSH
28272: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28276: LD_INT 4
28278: PPUSH
28279: LD_INT 4
28281: PPUSH
28282: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28286: LD_ADDR_VAR 0 1
28290: PUSH
28291: LD_INT 4
28293: PPUSH
28294: LD_INT 1
28296: PPUSH
28297: LD_INT 2
28299: PPUSH
28300: CALL 71086 0 3
28304: PUSH
28305: FOR_IN
28306: IFFALSE 28343
// if GetTech ( i , 1 ) <> state_researched then
28308: LD_VAR 0 1
28312: PPUSH
28313: LD_INT 1
28315: PPUSH
28316: CALL_OW 321
28320: PUSH
28321: LD_INT 2
28323: NONEQUAL
28324: IFFALSE 28341
// SetTech ( i , 1 , state_researched ) ;
28326: LD_VAR 0 1
28330: PPUSH
28331: LD_INT 1
28333: PPUSH
28334: LD_INT 2
28336: PPUSH
28337: CALL_OW 322
28341: GO 28305
28343: POP
28344: POP
// missionStage := 6 ;
28345: LD_ADDR_EXP 15
28349: PUSH
28350: LD_INT 6
28352: ST_TO_ADDR
// activeAttacks := true ;
28353: LD_ADDR_EXP 16
28357: PUSH
28358: LD_INT 1
28360: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28361: LD_STRING M2
28363: PPUSH
28364: CALL_OW 337
// SaveForQuickRestart ;
28368: CALL_OW 22
// wait ( 0 0$40 ) ;
28372: LD_INT 1400
28374: PPUSH
28375: CALL_OW 67
// DialogueOn ;
28379: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28383: LD_EXP 66
28387: PPUSH
28388: LD_STRING D7-Friend-1
28390: PPUSH
28391: CALL 113340 0 2
// Say ( JMM , D7-JMM-1 ) ;
28395: LD_EXP 40
28399: PPUSH
28400: LD_STRING D7-JMM-1
28402: PPUSH
28403: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28407: LD_EXP 66
28411: PPUSH
28412: LD_STRING D7-Friend-2
28414: PPUSH
28415: CALL 113340 0 2
// Say ( JMM , D7-JMM-2 ) ;
28419: LD_EXP 40
28423: PPUSH
28424: LD_STRING D7-JMM-2
28426: PPUSH
28427: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28431: LD_EXP 66
28435: PPUSH
28436: LD_STRING D7-Friend-3
28438: PPUSH
28439: CALL 113340 0 2
// Say ( JMM , D7-JMM-3 ) ;
28443: LD_EXP 40
28447: PPUSH
28448: LD_STRING D7-JMM-3
28450: PPUSH
28451: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28455: LD_EXP 66
28459: PPUSH
28460: LD_STRING D7-Friend-4
28462: PPUSH
28463: CALL 113340 0 2
// Say ( JMM , D7-JMM-4 ) ;
28467: LD_EXP 40
28471: PPUSH
28472: LD_STRING D7-JMM-4
28474: PPUSH
28475: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28479: LD_EXP 66
28483: PPUSH
28484: LD_STRING D7-Friend-5
28486: PPUSH
28487: CALL 113340 0 2
// Say ( JMM , D7-JMM-5 ) ;
28491: LD_EXP 40
28495: PPUSH
28496: LD_STRING D7-JMM-5
28498: PPUSH
28499: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28503: LD_EXP 66
28507: PPUSH
28508: LD_STRING D7-Friend-6
28510: PPUSH
28511: CALL 113340 0 2
// Say ( JMM , D7-JMM-6 ) ;
28515: LD_EXP 40
28519: PPUSH
28520: LD_STRING D7-JMM-6
28522: PPUSH
28523: CALL_OW 88
// DialogueOff ;
28527: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28531: LD_STRING Mlegion
28533: PPUSH
28534: CALL_OW 337
// skirmish := true ;
28538: LD_ADDR_EXP 100
28542: PUSH
28543: LD_INT 1
28545: ST_TO_ADDR
// RebuildKozlovFactory ;
28546: CALL 5386 0 0
// end ;
28550: PPOPN 14
28552: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28553: LD_EXP 20
28557: IFFALSE 28570
28559: PUSH
28560: LD_EXP 61
28564: PPUSH
28565: CALL_OW 300
28569: AND
28570: IFFALSE 28612
28572: GO 28574
28574: DISABLE
// begin enable ;
28575: ENABLE
// if IsInUnit ( Powell ) then
28576: LD_EXP 61
28580: PPUSH
28581: CALL_OW 310
28585: IFFALSE 28603
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28587: LD_EXP 61
28591: PPUSH
28592: CALL_OW 310
28596: PPUSH
28597: CALL_OW 85
28601: GO 28612
// CenterOnUnits ( Powell ) ;
28603: LD_EXP 61
28607: PPUSH
28608: CALL_OW 85
// end ;
28612: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28613: LD_INT 22
28615: PUSH
28616: LD_INT 8
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 34
28625: PUSH
28626: LD_INT 48
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PPUSH
28637: CALL_OW 69
28641: IFFALSE 28917
28643: GO 28645
28645: DISABLE
28646: LD_INT 0
28648: PPUSH
28649: PPUSH
// begin if missionStage < 9 then
28650: LD_EXP 15
28654: PUSH
28655: LD_INT 9
28657: LESS
28658: IFFALSE 28668
// missionStage := 9 ;
28660: LD_ADDR_EXP 15
28664: PUSH
28665: LD_INT 9
28667: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28668: LD_ADDR_VAR 0 1
28672: PUSH
28673: LD_INT 22
28675: PUSH
28676: LD_INT 8
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 34
28685: PUSH
28686: LD_INT 48
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PPUSH
28697: CALL_OW 69
28701: PUSH
28702: LD_INT 1
28704: ARRAY
28705: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28706: LD_INT 175
28708: PPUSH
28709: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28713: LD_EXP 12
28717: IFTRUE 28736
28719: PUSH
28720: LD_EXP 3
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: IN
28735: OR
28736: IFFALSE 28759
// target := [ 68 , 108 , 1 ] else
28738: LD_ADDR_VAR 0 2
28742: PUSH
28743: LD_INT 68
28745: PUSH
28746: LD_INT 108
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: ST_TO_ADDR
28757: GO 28778
// target := [ 181 , 88 , 2 ] ;
28759: LD_ADDR_VAR 0 2
28763: PUSH
28764: LD_INT 181
28766: PUSH
28767: LD_INT 88
28769: PUSH
28770: LD_INT 2
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: LIST
28777: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28778: LD_VAR 0 1
28782: PPUSH
28783: LD_VAR 0 2
28787: PUSH
28788: LD_INT 1
28790: ARRAY
28791: PPUSH
28792: LD_VAR 0 2
28796: PUSH
28797: LD_INT 2
28799: ARRAY
28800: PPUSH
28801: CALL_OW 176
// if target [ 3 ] = 1 then
28805: LD_VAR 0 2
28809: PUSH
28810: LD_INT 3
28812: ARRAY
28813: PUSH
28814: LD_INT 1
28816: EQUAL
28817: IFFALSE 28833
// SayRadio ( Kurt , D12-Kurt-1 ) else
28819: LD_EXP 64
28823: PPUSH
28824: LD_STRING D12-Kurt-1
28826: PPUSH
28827: CALL_OW 94
28831: GO 28857
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28833: LD_EXP 64
28837: PPUSH
28838: LD_STRING D12a-Kurt-1
28840: PPUSH
28841: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28845: LD_EXP 79
28849: PPUSH
28850: LD_STRING D12a-Roth-1
28852: PPUSH
28853: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28857: LD_INT 350
28859: PPUSH
28860: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28864: LD_VAR 0 1
28868: PPUSH
28869: LD_INT 22
28871: PUSH
28872: LD_INT 8
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 23
28881: PUSH
28882: LD_INT 2
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 30
28891: PUSH
28892: LD_INT 3
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: LIST
28903: PPUSH
28904: CALL_OW 69
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: CALL_OW 228
// end ;
28917: PPOPN 2
28919: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28920: LD_EXP 64
28924: PPUSH
28925: CALL_OW 256
28929: PUSH
28930: LD_INT 999
28932: LESS
28933: IFTRUE 29001
28935: PUSH
28936: LD_INT 22
28938: PUSH
28939: LD_INT 8
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 21
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 23
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: LIST
28970: PPUSH
28971: CALL_OW 69
28975: PUSH
28976: LD_INT 9
28978: PUSH
28979: LD_INT 8
28981: PUSH
28982: LD_INT 7
28984: PUSH
28985: LD_INT 6
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: PUSH
28994: LD_OWVAR 67
28998: ARRAY
28999: LESSEQUAL
29000: OR
29001: IFFALSE 29034
29003: PUSH
29004: LD_INT 22
29006: PUSH
29007: LD_INT 8
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 34
29016: PUSH
29017: LD_INT 48
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PPUSH
29028: CALL_OW 69
29032: NOT
29033: AND
29034: IFFALSE 29047
29036: PUSH
29037: LD_EXP 64
29041: PPUSH
29042: CALL_OW 302
29046: AND
29047: IFFALSE 29068
29049: PUSH
29050: LD_INT 5
29052: PPUSH
29053: LD_INT 22
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PPUSH
29063: CALL_OW 70
29067: AND
29068: IFFALSE 29830
29070: GO 29072
29072: DISABLE
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
// begin legionDestroyed := true ;
29078: LD_ADDR_EXP 22
29082: PUSH
29083: LD_INT 1
29085: ST_TO_ADDR
// DialogueOn ;
29086: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
29090: LD_EXP 40
29094: PPUSH
29095: LD_STRING D13-JMM-1
29097: PPUSH
29098: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
29102: LD_EXP 64
29106: PPUSH
29107: LD_STRING D13-Kurt-1
29109: PPUSH
29110: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
29114: LD_EXP 40
29118: PPUSH
29119: LD_STRING D13-JMM-2
29121: PPUSH
29122: CALL_OW 88
// if FakeInfo then
29126: LD_EXP 12
29130: IFFALSE 29150
// begin Say ( Kurt , D13-Kurt-2 ) ;
29132: LD_EXP 64
29136: PPUSH
29137: LD_STRING D13-Kurt-2
29139: PPUSH
29140: CALL_OW 88
// DialogueOff ;
29144: CALL_OW 7
// exit ;
29148: GO 29830
// end ; if not KurtStatus then
29150: LD_EXP 3
29154: NOT
29155: IFFALSE 29171
// Say ( Kurt , D13-Kurt-2b ) else
29157: LD_EXP 64
29161: PPUSH
29162: LD_STRING D13-Kurt-2b
29164: PPUSH
29165: CALL_OW 88
29169: GO 29183
// Say ( Kurt , D13-Kurt-2a ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D13-Kurt-2a
29178: PPUSH
29179: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
29183: LD_EXP 40
29187: PPUSH
29188: LD_STRING D13-JMM-3
29190: PPUSH
29191: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
29195: LD_EXP 64
29199: PPUSH
29200: LD_STRING D13-Kurt-3
29202: PPUSH
29203: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
29207: LD_EXP 40
29211: PPUSH
29212: LD_STRING D13-JMM-4
29214: PPUSH
29215: CALL_OW 88
// DialogueOff ;
29219: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29223: LD_STRING MlegionOut
29225: PPUSH
29226: CALL_OW 337
// MC_Kill ( 3 ) ;
29230: LD_INT 3
29232: PPUSH
29233: CALL 40134 0 1
// KillUnit ( Kozlov ) ;
29237: LD_EXP 65
29241: PPUSH
29242: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29246: LD_ADDR_VAR 0 1
29250: PUSH
29251: LD_INT 22
29253: PUSH
29254: LD_INT 8
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 23
29263: PUSH
29264: LD_INT 3
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 3
29273: PUSH
29274: LD_INT 21
29276: PUSH
29277: LD_INT 33
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: LIST
29292: PPUSH
29293: CALL_OW 69
29297: PUSH
29298: FOR_IN
29299: IFFALSE 29312
// KillUnit ( i ) ;
29301: LD_VAR 0 1
29305: PPUSH
29306: CALL_OW 66
29310: GO 29298
29312: POP
29313: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29314: LD_ADDR_VAR 0 1
29318: PUSH
29319: LD_INT 22
29321: PUSH
29322: LD_INT 8
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 21
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PPUSH
29343: CALL_OW 69
29347: PUSH
29348: FOR_IN
29349: IFFALSE 29362
// KillUnit ( i ) ;
29351: LD_VAR 0 1
29355: PPUSH
29356: CALL_OW 66
29360: GO 29348
29362: POP
29363: POP
// wait ( 0 0$0.6 ) ;
29364: LD_INT 21
29366: PPUSH
29367: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29371: LD_INT 8
29373: PPUSH
29374: LD_INT 1
29376: PPUSH
29377: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29381: LD_ADDR_VAR 0 2
29385: PUSH
29386: LD_INT 22
29388: PUSH
29389: LD_INT 8
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 21
29398: PUSH
29399: LD_INT 1
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PPUSH
29410: CALL_OW 69
29414: PUSH
29415: LD_EXP 65
29419: PUSH
29420: LD_EXP 64
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: DIFF
29429: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29430: LD_VAR 0 2
29434: PUSH
29435: LD_INT 6
29437: PUSH
29438: LD_INT 5
29440: PUSH
29441: LD_INT 4
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: PUSH
29453: LD_OWVAR 67
29457: ARRAY
29458: GREATEREQUAL
29459: IFFALSE 29611
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29461: LD_ADDR_VAR 0 3
29465: PUSH
29466: LD_INT 6
29468: PUSH
29469: LD_INT 5
29471: PUSH
29472: LD_INT 4
29474: PUSH
29475: LD_INT 3
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: PUSH
29484: LD_OWVAR 67
29488: ARRAY
29489: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29490: LD_ADDR_VAR 0 1
29494: PUSH
29495: DOUBLE
29496: LD_VAR 0 2
29500: PUSH
29501: LD_VAR 0 3
29505: PUSH
29506: LD_INT 1
29508: PLUS
29509: MINUS
29510: INC
29511: ST_TO_ADDR
29512: LD_INT 1
29514: PUSH
29515: FOR_DOWNTO
29516: IFFALSE 29607
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29518: LD_ADDR_EXP 38
29522: PUSH
29523: LD_EXP 38
29527: PUSH
29528: LD_VAR 0 2
29532: PUSH
29533: LD_VAR 0 1
29537: ARRAY
29538: ADD
29539: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29540: LD_VAR 0 2
29544: PUSH
29545: LD_VAR 0 1
29549: ARRAY
29550: PPUSH
29551: CALL_OW 310
29555: IFFALSE 29572
// ComExit ( tmp [ i ] ) ;
29557: LD_VAR 0 2
29561: PUSH
29562: LD_VAR 0 1
29566: ARRAY
29567: PPUSH
29568: CALL 109493 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 1
29581: ARRAY
29582: PPUSH
29583: LD_INT 34
29585: PUSH
29586: LD_INT 0
29588: PPUSH
29589: LD_INT 6
29591: PPUSH
29592: CALL_OW 12
29596: PLUS
29597: PPUSH
29598: LD_INT 1
29600: PPUSH
29601: CALL_OW 171
// end ;
29605: GO 29515
29607: POP
29608: POP
// end else
29609: GO 29621
// x := tmp ;
29611: LD_ADDR_VAR 0 3
29615: PUSH
29616: LD_VAR 0 2
29620: ST_TO_ADDR
// for i := tmp downto tmp - x do
29621: LD_ADDR_VAR 0 1
29625: PUSH
29626: DOUBLE
29627: LD_VAR 0 2
29631: INC
29632: ST_TO_ADDR
29633: LD_VAR 0 2
29637: PUSH
29638: LD_VAR 0 3
29642: MINUS
29643: PUSH
29644: FOR_DOWNTO
29645: IFFALSE 29717
// begin if IsInUnit ( tmp [ i ] ) then
29647: LD_VAR 0 2
29651: PUSH
29652: LD_VAR 0 1
29656: ARRAY
29657: PPUSH
29658: CALL_OW 310
29662: IFFALSE 29679
// ComExit ( tmp [ i ] ) ;
29664: LD_VAR 0 2
29668: PUSH
29669: LD_VAR 0 1
29673: ARRAY
29674: PPUSH
29675: CALL 109493 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29679: LD_VAR 0 2
29683: PUSH
29684: LD_VAR 0 1
29688: ARRAY
29689: PPUSH
29690: LD_INT 1
29692: PPUSH
29693: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29697: LD_VAR 0 2
29701: PUSH
29702: LD_VAR 0 1
29706: ARRAY
29707: PPUSH
29708: LD_INT 1000
29710: PPUSH
29711: CALL_OW 234
// end ;
29715: GO 29644
29717: POP
29718: POP
// SetSide ( Kurt , 1 ) ;
29719: LD_EXP 64
29723: PPUSH
29724: LD_INT 1
29726: PPUSH
29727: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29731: LD_INT 22
29733: PUSH
29734: LD_INT 8
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 21
29743: PUSH
29744: LD_INT 3
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PPUSH
29755: CALL_OW 69
29759: PPUSH
29760: LD_INT 1
29762: PPUSH
29763: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29767: LD_INT 8
29769: PPUSH
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 1
29778: PPUSH
29779: CALL_OW 80
// wait ( 1 1$20 ) ;
29783: LD_INT 2800
29785: PPUSH
29786: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29790: LD_EXP 66
29794: PPUSH
29795: LD_INT 37
29797: PPUSH
29798: LD_INT 1
29800: PPUSH
29801: LD_INT 0
29803: PPUSH
29804: CALL_OW 48
// wait ( 0 0$1 ) ;
29808: LD_INT 35
29810: PPUSH
29811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29815: LD_EXP 66
29819: PPUSH
29820: LD_INT 60
29822: PPUSH
29823: LD_INT 95
29825: PPUSH
29826: CALL_OW 111
// end ;
29830: PPOPN 3
29832: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29833: LD_EXP 22
29837: NOT
29838: IFFALSE 29874
29840: PUSH
29841: LD_INT 22
29843: PUSH
29844: LD_INT 8
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 21
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 0
29872: EQUAL
29873: AND
29874: IFFALSE 29894
29876: GO 29878
29878: DISABLE
// begin legionDestroyed := true ;
29879: LD_ADDR_EXP 22
29883: PUSH
29884: LD_INT 1
29886: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29887: LD_STRING MlegionOut
29889: PPUSH
29890: CALL_OW 337
// end ;
29894: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29895: LD_EXP 38
29899: IFFALSE 29974
29901: GO 29903
29903: DISABLE
29904: LD_INT 0
29906: PPUSH
// begin enable ;
29907: ENABLE
// for i in legionEscapeUnits do
29908: LD_ADDR_VAR 0 1
29912: PUSH
29913: LD_EXP 38
29917: PUSH
29918: FOR_IN
29919: IFFALSE 29972
// begin if IsInArea ( i , legionEscapeArea ) then
29921: LD_VAR 0 1
29925: PPUSH
29926: LD_INT 31
29928: PPUSH
29929: CALL_OW 308
29933: IFFALSE 29946
// RemoveUnit ( i ) else
29935: LD_VAR 0 1
29939: PPUSH
29940: CALL_OW 64
29944: GO 29970
// if not HasTask ( i ) then
29946: LD_VAR 0 1
29950: PPUSH
29951: CALL_OW 314
29955: NOT
29956: IFFALSE 29970
// ComMoveToArea ( i , legionEscapeArea ) ;
29958: LD_VAR 0 1
29962: PPUSH
29963: LD_INT 31
29965: PPUSH
29966: CALL_OW 113
// end ;
29970: GO 29918
29972: POP
29973: POP
// end ;
29974: PPOPN 1
29976: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29977: LD_INT 1
29979: PPUSH
29980: LD_EXP 66
29984: PPUSH
29985: CALL_OW 292
29989: IFFALSE 30287
29991: GO 29993
29993: DISABLE
29994: LD_INT 0
29996: PPUSH
// begin wait ( 0 0$2 ) ;
29997: LD_INT 70
29999: PPUSH
30000: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30004: LD_EXP 66
30008: PPUSH
30009: CALL_OW 87
// DialogueOn ;
30013: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
30017: LD_EXP 40
30021: PPUSH
30022: LD_STRING D14-JMM-1
30024: PPUSH
30025: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
30029: LD_EXP 66
30033: PPUSH
30034: LD_STRING D14-Friend-1
30036: PPUSH
30037: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D14-JMM-2
30048: PPUSH
30049: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D14-Friend-2
30060: PPUSH
30061: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
30065: LD_EXP 40
30069: PPUSH
30070: LD_STRING D14-JMM-3
30072: PPUSH
30073: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
30077: LD_EXP 66
30081: PPUSH
30082: LD_STRING D14-Friend-3
30084: PPUSH
30085: CALL_OW 88
// DialogueOff ;
30089: CALL_OW 7
// dec := Query ( Q14 ) ;
30093: LD_ADDR_VAR 0 1
30097: PUSH
30098: LD_STRING Q14
30100: PPUSH
30101: CALL_OW 97
30105: ST_TO_ADDR
// if dec = 1 then
30106: LD_VAR 0 1
30110: PUSH
30111: LD_INT 1
30113: EQUAL
30114: IFFALSE 30148
// begin DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
30120: LD_EXP 40
30124: PPUSH
30125: LD_STRING D14a-JMM-1
30127: PPUSH
30128: CALL_OW 88
// DialogueOff ;
30132: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30136: LD_EXP 66
30140: PPUSH
30141: LD_INT 1
30143: PPUSH
30144: CALL_OW 235
// end ; if dec = 2 then
30148: LD_VAR 0 1
30152: PUSH
30153: LD_INT 2
30155: EQUAL
30156: IFFALSE 30209
// begin DialogueOn ;
30158: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
30162: LD_EXP 40
30166: PPUSH
30167: LD_STRING D14b-JMM-1
30169: PPUSH
30170: CALL_OW 88
// DialogueOff ;
30174: CALL_OW 7
// wait ( 0 0$1 ) ;
30178: LD_INT 35
30180: PPUSH
30181: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
30185: LD_EXP 66
30189: PPUSH
30190: LD_INT 9
30192: PPUSH
30193: LD_INT 2
30195: PPUSH
30196: CALL_OW 111
// AddComHold ( Friend ) ;
30200: LD_EXP 66
30204: PPUSH
30205: CALL_OW 200
// end ; if dec = 3 then
30209: LD_VAR 0 1
30213: PUSH
30214: LD_INT 3
30216: EQUAL
30217: IFFALSE 30287
// begin DialogueOn ;
30219: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30223: LD_EXP 40
30227: PPUSH
30228: LD_STRING D14c-JMM-1
30230: PPUSH
30231: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30235: LD_EXP 66
30239: PPUSH
30240: LD_STRING D14c-Friend-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30247: LD_EXP 40
30251: PPUSH
30252: LD_STRING D14c-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30263: LD_EXP 66
30267: PPUSH
30268: LD_INT 9
30270: PPUSH
30271: LD_INT 2
30273: PPUSH
30274: CALL_OW 111
// AddComHold ( Friend ) ;
30278: LD_EXP 66
30282: PPUSH
30283: CALL_OW 200
// end ; end ;
30287: PPOPN 1
30289: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30290: LD_INT 9
30292: PPUSH
30293: LD_INT 2
30295: PPUSH
30296: CALL_OW 428
30300: PUSH
30301: LD_EXP 66
30305: EQUAL
30306: IFFALSE 30323
30308: PUSH
30309: LD_EXP 66
30313: PPUSH
30314: CALL_OW 255
30318: PUSH
30319: LD_INT 8
30321: EQUAL
30322: AND
30323: IFFALSE 30337
30325: GO 30327
30327: DISABLE
// RemoveUnit ( Friend ) ;
30328: LD_EXP 66
30332: PPUSH
30333: CALL_OW 64
30337: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30338: LD_EXP 14
30342: PUSH
30343: LD_INT 31500
30345: GREATEREQUAL
30346: IFFALSE 30354
30348: PUSH
30349: LD_EXP 7
30353: AND
30354: IFFALSE 30362
30356: PUSH
30357: LD_EXP 2
30361: AND
30362: IFFALSE 30808
30364: GO 30366
30366: DISABLE
30367: LD_INT 0
30369: PPUSH
30370: PPUSH
30371: PPUSH
// begin missionStage := 7 ;
30372: LD_ADDR_EXP 15
30376: PUSH
30377: LD_INT 7
30379: ST_TO_ADDR
// for i := 1 to 5 do
30380: LD_ADDR_VAR 0 1
30384: PUSH
30385: DOUBLE
30386: LD_INT 1
30388: DEC
30389: ST_TO_ADDR
30390: LD_INT 5
30392: PUSH
30393: FOR_TO
30394: IFFALSE 30506
// begin uc_side = 1 ;
30396: LD_ADDR_OWVAR 20
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// uc_nation = 1 ;
30404: LD_ADDR_OWVAR 21
30408: PUSH
30409: LD_INT 1
30411: ST_TO_ADDR
// vc_engine = engine_siberite ;
30412: LD_ADDR_OWVAR 39
30416: PUSH
30417: LD_INT 3
30419: ST_TO_ADDR
// vc_control = control_computer ;
30420: LD_ADDR_OWVAR 38
30424: PUSH
30425: LD_INT 3
30427: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30428: LD_ADDR_OWVAR 37
30432: PUSH
30433: LD_INT 3
30435: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30436: LD_ADDR_OWVAR 40
30440: PUSH
30441: LD_INT 5
30443: PUSH
30444: LD_INT 9
30446: PUSH
30447: LD_INT 7
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 1
30457: PPUSH
30458: LD_INT 3
30460: PPUSH
30461: CALL_OW 12
30465: ARRAY
30466: ST_TO_ADDR
// veh = CreateVehicle ;
30467: LD_ADDR_VAR 0 2
30471: PUSH
30472: CALL_OW 45
30476: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30477: LD_VAR 0 2
30481: PPUSH
30482: LD_INT 1
30484: PPUSH
30485: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30489: LD_VAR 0 2
30493: PPUSH
30494: LD_INT 19
30496: PPUSH
30497: LD_INT 0
30499: PPUSH
30500: CALL_OW 49
// end ;
30504: GO 30393
30506: POP
30507: POP
// uc_side = 1 ;
30508: LD_ADDR_OWVAR 20
30512: PUSH
30513: LD_INT 1
30515: ST_TO_ADDR
// uc_nation = 1 ;
30516: LD_ADDR_OWVAR 21
30520: PUSH
30521: LD_INT 1
30523: ST_TO_ADDR
// vc_engine = 3 ;
30524: LD_ADDR_OWVAR 39
30528: PUSH
30529: LD_INT 3
30531: ST_TO_ADDR
// vc_control = 1 ;
30532: LD_ADDR_OWVAR 38
30536: PUSH
30537: LD_INT 1
30539: ST_TO_ADDR
// vc_chassis = 3 ;
30540: LD_ADDR_OWVAR 37
30544: PUSH
30545: LD_INT 3
30547: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30548: LD_ADDR_OWVAR 40
30552: PUSH
30553: LD_INT 5
30555: PUSH
30556: LD_INT 9
30558: PUSH
30559: LD_INT 7
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 1
30569: PPUSH
30570: LD_INT 3
30572: PPUSH
30573: CALL_OW 12
30577: ARRAY
30578: ST_TO_ADDR
// vehG = CreateVehicle ;
30579: LD_ADDR_VAR 0 3
30583: PUSH
30584: CALL_OW 45
30588: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30589: LD_VAR 0 3
30593: PPUSH
30594: LD_INT 1
30596: PPUSH
30597: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30601: LD_VAR 0 3
30605: PPUSH
30606: LD_INT 19
30608: PPUSH
30609: LD_INT 0
30611: PPUSH
30612: CALL_OW 49
// if JMMGirl = 1 then
30616: LD_EXP 7
30620: PUSH
30621: LD_INT 1
30623: EQUAL
30624: IFFALSE 30680
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30626: LD_ADDR_EXP 41
30630: PUSH
30631: LD_STRING Joan
30633: PPUSH
30634: LD_INT 1
30636: PPUSH
30637: LD_STRING 14_
30639: PPUSH
30640: CALL 70939 0 3
30644: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30645: LD_EXP 41
30649: PPUSH
30650: LD_VAR 0 3
30654: PPUSH
30655: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30659: LD_VAR 0 3
30663: PPUSH
30664: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30668: LD_EXP 41
30672: PPUSH
30673: LD_STRING D10BW-Joan-1
30675: PPUSH
30676: CALL_OW 94
// end ; if JMMGirl = 2 then
30680: LD_EXP 7
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: IFFALSE 30744
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30690: LD_ADDR_EXP 43
30694: PUSH
30695: LD_STRING Lisa
30697: PPUSH
30698: LD_INT 1
30700: PPUSH
30701: LD_STRING 14_
30703: PPUSH
30704: CALL 70939 0 3
30708: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30709: LD_EXP 43
30713: PPUSH
30714: LD_VAR 0 3
30718: PPUSH
30719: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30723: LD_VAR 0 3
30727: PPUSH
30728: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30732: LD_EXP 43
30736: PPUSH
30737: LD_STRING D10BW-Lisa-1
30739: PPUSH
30740: CALL_OW 94
// end ; if JMMGirl = 3 then
30744: LD_EXP 7
30748: PUSH
30749: LD_INT 3
30751: EQUAL
30752: IFFALSE 30808
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30754: LD_ADDR_EXP 55
30758: PUSH
30759: LD_STRING Connie
30761: PPUSH
30762: LD_INT 1
30764: PPUSH
30765: LD_STRING 14_
30767: PPUSH
30768: CALL 70939 0 3
30772: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30773: LD_EXP 55
30777: PPUSH
30778: LD_VAR 0 3
30782: PPUSH
30783: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30787: LD_VAR 0 3
30791: PPUSH
30792: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30796: LD_EXP 55
30800: PPUSH
30801: LD_STRING D10BW-Con-1
30803: PPUSH
30804: CALL_OW 94
// end ; end ;
30808: PPOPN 3
30810: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30811: LD_EXP 14
30815: PUSH
30816: LD_INT 94500
30818: GREATEREQUAL
30819: IFFALSE 31231
30821: GO 30823
30823: DISABLE
30824: LD_INT 0
30826: PPUSH
30827: PPUSH
30828: PPUSH
// begin tmp := PrepareStevensSquad ;
30829: LD_ADDR_VAR 0 3
30833: PUSH
30834: CALL 2384 0 0
30838: ST_TO_ADDR
// if not tmp then
30839: LD_VAR 0 3
30843: NOT
30844: IFFALSE 30848
// exit ;
30846: GO 31231
// uc_side := 1 ;
30848: LD_ADDR_OWVAR 20
30852: PUSH
30853: LD_INT 1
30855: ST_TO_ADDR
// uc_nation := 1 ;
30856: LD_ADDR_OWVAR 21
30860: PUSH
30861: LD_INT 1
30863: ST_TO_ADDR
// for i in tmp do
30864: LD_ADDR_VAR 0 1
30868: PUSH
30869: LD_VAR 0 3
30873: PUSH
30874: FOR_IN
30875: IFFALSE 30972
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30877: LD_INT 3
30879: PPUSH
30880: LD_INT 3
30882: PPUSH
30883: LD_INT 1
30885: PPUSH
30886: LD_INT 5
30888: PUSH
30889: LD_INT 9
30891: PUSH
30892: LD_INT 7
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 1
30902: PPUSH
30903: LD_INT 3
30905: PPUSH
30906: CALL_OW 12
30910: ARRAY
30911: PPUSH
30912: LD_INT 40
30914: PPUSH
30915: CALL 75925 0 5
// veh := CreateVehicle ;
30919: LD_ADDR_VAR 0 2
30923: PUSH
30924: CALL_OW 45
30928: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30929: LD_VAR 0 2
30933: PPUSH
30934: LD_INT 1
30936: PPUSH
30937: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30941: LD_VAR 0 2
30945: PPUSH
30946: LD_INT 19
30948: PPUSH
30949: LD_INT 0
30951: PPUSH
30952: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30956: LD_VAR 0 1
30960: PPUSH
30961: LD_VAR 0 2
30965: PPUSH
30966: CALL_OW 52
// end ;
30970: GO 30874
30972: POP
30973: POP
// missionStage := 8 ;
30974: LD_ADDR_EXP 15
30978: PUSH
30979: LD_INT 8
30981: ST_TO_ADDR
// DialogueOn ;
30982: CALL_OW 6
// if Stevens then
30986: LD_EXP 42
30990: IFFALSE 31104
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30992: LD_EXP 42
30996: PPUSH
30997: CALL_OW 310
31001: PPUSH
31002: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
31006: LD_EXP 42
31010: PPUSH
31011: LD_STRING D8-Huck-1
31013: PPUSH
31014: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
31018: LD_EXP 40
31022: PPUSH
31023: LD_STRING D8-JMM-1
31025: PPUSH
31026: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
31030: LD_EXP 42
31034: PPUSH
31035: LD_STRING D8-Huck-2
31037: PPUSH
31038: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31042: LD_EXP 40
31046: PPUSH
31047: LD_STRING D8-JMM-2
31049: PPUSH
31050: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
31054: LD_EXP 42
31058: PPUSH
31059: LD_STRING D8-Huck-3
31061: PPUSH
31062: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31066: LD_EXP 40
31070: PPUSH
31071: LD_STRING D8-JMM-3
31073: PPUSH
31074: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
31078: LD_EXP 42
31082: PPUSH
31083: LD_STRING D8-Huck-4
31085: PPUSH
31086: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31090: LD_EXP 40
31094: PPUSH
31095: LD_STRING D8-JMM-4
31097: PPUSH
31098: CALL_OW 88
// end else
31102: GO 31214
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
31104: LD_EXP 56
31108: PPUSH
31109: CALL_OW 310
31113: PPUSH
31114: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
31118: LD_EXP 56
31122: PPUSH
31123: LD_STRING D8-Huck-1
31125: PPUSH
31126: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
31130: LD_EXP 40
31134: PPUSH
31135: LD_STRING D8-JMM-1a
31137: PPUSH
31138: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
31142: LD_EXP 56
31146: PPUSH
31147: LD_STRING D8-Huck-2
31149: PPUSH
31150: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31154: LD_EXP 40
31158: PPUSH
31159: LD_STRING D8-JMM-2
31161: PPUSH
31162: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
31166: LD_EXP 56
31170: PPUSH
31171: LD_STRING D8-Huck-3
31173: PPUSH
31174: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31178: LD_EXP 40
31182: PPUSH
31183: LD_STRING D8-JMM-3
31185: PPUSH
31186: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
31190: LD_EXP 56
31194: PPUSH
31195: LD_STRING D8-Huck-4
31197: PPUSH
31198: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31202: LD_EXP 40
31206: PPUSH
31207: LD_STRING D8-JMM-4
31209: PPUSH
31210: CALL_OW 88
// end ; DialogueOff ;
31214: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
31218: LD_INT 25
31220: PPUSH
31221: LD_INT 1
31223: PPUSH
31224: LD_INT 1
31226: PPUSH
31227: CALL_OW 322
// end ;
31231: PPOPN 3
31233: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31234: LD_EXP 75
31238: PPUSH
31239: CALL_OW 302
31243: IFFALSE 31259
31245: PUSH
31246: LD_INT 1
31248: PPUSH
31249: LD_EXP 75
31253: PPUSH
31254: CALL_OW 292
31258: AND
31259: IFFALSE 31497
31261: GO 31263
31263: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31264: LD_EXP 75
31268: PPUSH
31269: CALL_OW 87
// DialogueOn ;
31273: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31277: LD_EXP 40
31281: PPUSH
31282: LD_STRING D10nB-JMM-1
31284: PPUSH
31285: CALL_OW 88
// if BurlakStatus = 1 then
31289: LD_EXP 9
31293: PUSH
31294: LD_INT 1
31296: EQUAL
31297: IFFALSE 31313
// SayRadio ( Vsevolod , D10nB-Vse-1a ) else
31299: LD_EXP 74
31303: PPUSH
31304: LD_STRING D10nB-Vse-1a
31306: PPUSH
31307: CALL_OW 94
31311: GO 31325
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31313: LD_EXP 74
31317: PPUSH
31318: LD_STRING D10nB-Vse-1
31320: PPUSH
31321: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31325: LD_EXP 40
31329: PPUSH
31330: LD_STRING D10nB-JMM-2
31332: PPUSH
31333: CALL_OW 88
// if KappaStatus then
31337: LD_EXP 2
31341: IFFALSE 31357
// SayRadio ( Vsevolod , D10nB-Vse-5a ) else
31343: LD_EXP 74
31347: PPUSH
31348: LD_STRING D10nB-Vse-5a
31350: PPUSH
31351: CALL_OW 94
31355: GO 31493
// if JMMGirlStatus = 0 then
31357: LD_EXP 6
31361: PUSH
31362: LD_INT 0
31364: EQUAL
31365: IFFALSE 31493
// begin if JMMGirl = 1 then
31367: LD_EXP 7
31371: PUSH
31372: LD_INT 1
31374: EQUAL
31375: IFFALSE 31425
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31377: LD_EXP 74
31381: PPUSH
31382: LD_STRING D10nB-Vse-2
31384: PPUSH
31385: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31389: LD_EXP 40
31393: PPUSH
31394: LD_STRING D10nB-JMM-3
31396: PPUSH
31397: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31401: LD_EXP 74
31405: PPUSH
31406: LD_STRING D10nB-Vse-3
31408: PPUSH
31409: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31413: LD_EXP 40
31417: PPUSH
31418: LD_STRING D10nB-JMM-4
31420: PPUSH
31421: CALL_OW 88
// end ; if JMMGirl = 2 then
31425: LD_EXP 7
31429: PUSH
31430: LD_INT 2
31432: EQUAL
31433: IFFALSE 31459
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31435: LD_EXP 74
31439: PPUSH
31440: LD_STRING D10nB-Vse-4
31442: PPUSH
31443: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31447: LD_EXP 40
31451: PPUSH
31452: LD_STRING D10nB-JMM-5
31454: PPUSH
31455: CALL_OW 88
// end ; if JMMGirl = 3 then
31459: LD_EXP 7
31463: PUSH
31464: LD_INT 3
31466: EQUAL
31467: IFFALSE 31493
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31469: LD_EXP 74
31473: PPUSH
31474: LD_STRING D10nB-Vse-5
31476: PPUSH
31477: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31481: LD_EXP 40
31485: PPUSH
31486: LD_STRING D10nB-JMM-6
31488: PPUSH
31489: CALL_OW 88
// end ; end ; DialogueOff ;
31493: CALL_OW 7
// end ;
31497: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31498: LD_EXP 14
31502: PUSH
31503: LD_INT 115500
31505: GREATEREQUAL
31506: IFFALSE 31519
31508: PUSH
31509: LD_EXP 69
31513: PPUSH
31514: CALL_OW 302
31518: AND
31519: IFFALSE 31530
31521: PUSH
31522: LD_INT 267
31524: PPUSH
31525: CALL_OW 302
31529: AND
31530: IFFALSE 32046
31532: GO 31534
31534: DISABLE
31535: LD_INT 0
31537: PPUSH
31538: PPUSH
31539: PPUSH
// begin missionStage := 10 ;
31540: LD_ADDR_EXP 15
31544: PUSH
31545: LD_INT 10
31547: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_INT 22
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 23
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 26
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 25
31588: PUSH
31589: LD_INT 12
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 3
31602: PUSH
31603: LD_INT 25
31605: PUSH
31606: LD_INT 16
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: PPUSH
31624: CALL_OW 69
31628: PUSH
31629: LD_EXP 40
31633: PUSH
31634: LD_EXP 64
31638: PUSH
31639: LD_EXP 42
31643: PUSH
31644: LD_EXP 56
31648: PUSH
31649: LD_EXP 43
31653: PUSH
31654: LD_EXP 44
31658: PUSH
31659: LD_EXP 45
31663: PUSH
31664: LD_EXP 46
31668: PUSH
31669: LD_EXP 47
31673: PUSH
31674: LD_EXP 48
31678: PUSH
31679: LD_EXP 49
31683: PUSH
31684: LD_EXP 50
31688: PUSH
31689: LD_EXP 51
31693: PUSH
31694: LD_EXP 52
31698: PUSH
31699: LD_EXP 53
31703: PUSH
31704: LD_EXP 54
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: DIFF
31727: ST_TO_ADDR
// if not tmp and Brown then
31728: LD_VAR 0 3
31732: NOT
31733: IFFALSE 31741
31735: PUSH
31736: LD_EXP 48
31740: AND
31741: IFFALSE 31756
// tmp := [ Brown ] ;
31743: LD_ADDR_VAR 0 3
31747: PUSH
31748: LD_EXP 48
31752: PUSH
31753: EMPTY
31754: LIST
31755: ST_TO_ADDR
// DialogueOn ;
31756: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31760: LD_VAR 0 3
31764: PUSH
31765: LD_INT 1
31767: ARRAY
31768: PPUSH
31769: LD_STRING D11-Sol1-1
31771: PPUSH
31772: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31776: LD_EXP 68
31780: PPUSH
31781: LD_STRING D11-Pla-1
31783: PPUSH
31784: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31788: LD_EXP 69
31792: PPUSH
31793: LD_STRING D11-Kov-1
31795: PPUSH
31796: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31800: LD_EXP 68
31804: PPUSH
31805: LD_STRING D11-Pla-2
31807: PPUSH
31808: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31812: LD_VAR 0 3
31816: PUSH
31817: LD_INT 1
31819: ARRAY
31820: PPUSH
31821: LD_STRING D11-Sol1-2
31823: PPUSH
31824: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31828: LD_EXP 40
31832: PPUSH
31833: LD_STRING D11-JMM-2
31835: PPUSH
31836: CALL_OW 88
// DialogueOff ;
31840: CALL_OW 7
// allowBehemothConstruct := true ;
31844: LD_ADDR_EXP 25
31848: PUSH
31849: LD_INT 1
31851: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31852: LD_STRING M4
31854: PPUSH
31855: CALL_OW 337
// j := 3 ;
31859: LD_ADDR_VAR 0 2
31863: PUSH
31864: LD_INT 3
31866: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31867: LD_ADDR_VAR 0 3
31871: PUSH
31872: LD_INT 22
31874: PUSH
31875: LD_INT 3
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 50
31884: PUSH
31885: EMPTY
31886: LIST
31887: PUSH
31888: LD_INT 3
31890: PUSH
31891: LD_INT 120
31893: PUSH
31894: LD_INT 105
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 25
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: PPUSH
31921: CALL_OW 69
31925: PUSH
31926: LD_EXP 69
31930: DIFF
31931: ST_TO_ADDR
// for i in tmp do
31932: LD_ADDR_VAR 0 1
31936: PUSH
31937: LD_VAR 0 3
31941: PUSH
31942: FOR_IN
31943: IFFALSE 31993
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31945: LD_ADDR_EXP 77
31949: PUSH
31950: LD_EXP 77
31954: PPUSH
31955: LD_VAR 0 1
31959: PPUSH
31960: CALL 109095 0 2
31964: ST_TO_ADDR
// j := j - 1 ;
31965: LD_ADDR_VAR 0 2
31969: PUSH
31970: LD_VAR 0 2
31974: PUSH
31975: LD_INT 1
31977: MINUS
31978: ST_TO_ADDR
// if j = 0 then
31979: LD_VAR 0 2
31983: PUSH
31984: LD_INT 0
31986: EQUAL
31987: IFFALSE 31991
// break ;
31989: GO 31993
// end ;
31991: GO 31942
31993: POP
31994: POP
// BuildBehemoths ;
31995: CALL 8388 0 0
// repeat wait ( 15 15$00 ) ;
31999: LD_INT 31500
32001: PPUSH
32002: CALL_OW 67
// if behemothDestroyedBeforeFinish then
32006: LD_EXP 27
32010: IFFALSE 32014
// break ;
32012: GO 32046
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
32014: LD_INT 267
32016: PPUSH
32017: CALL_OW 274
32021: PPUSH
32022: LD_INT 1
32024: PPUSH
32025: CALL_OW 275
32029: PUSH
32030: LD_INT 1000
32032: GREATEREQUAL
32033: IFFALSE 32039
// BuildBehemoths ;
32035: CALL 8388 0 0
// until not behemothBuilders ;
32039: LD_EXP 77
32043: NOT
32044: IFFALSE 31999
// end ;
32046: PPOPN 3
32048: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
32049: LD_EXP 77
32053: NOT
32054: IFFALSE 32063
32056: PUSH
32057: LD_EXP 28
32061: NOT
32062: AND
32063: IFFALSE 32071
32065: PUSH
32066: LD_EXP 25
32070: AND
32071: IFFALSE 32091
32073: GO 32075
32075: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
32076: LD_STRING M4a
32078: PPUSH
32079: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
32083: LD_ADDR_EXP 27
32087: PUSH
32088: LD_INT 1
32090: ST_TO_ADDR
// end ;
32091: END
// every 0 0$1 trigger behemothDone do
32092: LD_EXP 28
32096: IFFALSE 32108
32098: GO 32100
32100: DISABLE
// ChangeMissionObjectives ( M4b ) ;
32101: LD_STRING M4b
32103: PPUSH
32104: CALL_OW 337
32108: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
32109: LD_EXP 29
32113: NOT
32114: IFFALSE 32312
32116: GO 32118
32118: DISABLE
32119: LD_INT 0
32121: PPUSH
32122: PPUSH
// begin enable ;
32123: ENABLE
// tmp := GetBehemoths ( 3 ) ;
32124: LD_ADDR_VAR 0 1
32128: PUSH
32129: LD_INT 3
32131: PPUSH
32132: CALL 109156 0 1
32136: ST_TO_ADDR
// if not tmp and not behemothDone then
32137: LD_VAR 0 1
32141: NOT
32142: IFFALSE 32151
32144: PUSH
32145: LD_EXP 28
32149: NOT
32150: AND
32151: IFFALSE 32187
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
32153: LD_ADDR_VAR 0 1
32157: PUSH
32158: LD_INT 22
32160: PUSH
32161: LD_INT 3
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 30
32170: PUSH
32171: LD_INT 37
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PPUSH
32182: CALL_OW 69
32186: ST_TO_ADDR
// if not tmp then
32187: LD_VAR 0 1
32191: NOT
32192: IFFALSE 32196
// exit ;
32194: GO 32312
// for i in tmp do
32196: LD_ADDR_VAR 0 2
32200: PUSH
32201: LD_VAR 0 1
32205: PUSH
32206: FOR_IN
32207: IFFALSE 32310
// if See ( 1 , i ) then
32209: LD_INT 1
32211: PPUSH
32212: LD_VAR 0 2
32216: PPUSH
32217: CALL_OW 292
32221: IFFALSE 32308
// begin if GetType ( i ) = unit_building then
32223: LD_VAR 0 2
32227: PPUSH
32228: CALL_OW 247
32232: PUSH
32233: LD_INT 3
32235: EQUAL
32236: IFFALSE 32274
// begin disable ;
32238: DISABLE
// CenterNowOnUnits ( i ) ;
32239: LD_VAR 0 2
32243: PPUSH
32244: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32248: LD_EXP 40
32252: PPUSH
32253: LD_STRING D17a-JMM-1
32255: PPUSH
32256: CALL_OW 88
// seeBehemoth := true ;
32260: LD_ADDR_EXP 29
32264: PUSH
32265: LD_INT 1
32267: ST_TO_ADDR
// exit ;
32268: POP
32269: POP
32270: GO 32312
// end else
32272: GO 32308
// begin disable ;
32274: DISABLE
// CenterNowOnUnits ( i ) ;
32275: LD_VAR 0 2
32279: PPUSH
32280: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32284: LD_EXP 40
32288: PPUSH
32289: LD_STRING D17b-JMM-1
32291: PPUSH
32292: CALL_OW 88
// seeBehemoth := true ;
32296: LD_ADDR_EXP 29
32300: PUSH
32301: LD_INT 1
32303: ST_TO_ADDR
// exit ;
32304: POP
32305: POP
32306: GO 32312
// end ; end ;
32308: GO 32206
32310: POP
32311: POP
// end ;
32312: PPOPN 2
32314: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32315: LD_EXP 14
32319: PUSH
32320: LD_INT 123200
32322: GREATEREQUAL
32323: IFFALSE 33536
32325: GO 32327
32327: DISABLE
32328: LD_INT 0
32330: PPUSH
32331: PPUSH
32332: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32333: LD_INT 2
32335: PPUSH
32336: LD_INT 23
32338: PUSH
32339: LD_INT 3
32341: PUSH
32342: LD_INT 3
32344: PUSH
32345: LD_INT 48
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: PUSH
32354: EMPTY
32355: LIST
32356: PPUSH
32357: CALL 64415 0 2
// repeat wait ( 0 0$1 ) ;
32361: LD_INT 35
32363: PPUSH
32364: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32368: LD_INT 22
32370: PUSH
32371: LD_INT 3
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 34
32380: PUSH
32381: LD_INT 48
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PPUSH
32392: CALL_OW 69
32396: IFFALSE 32361
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32398: LD_ADDR_VAR 0 1
32402: PUSH
32403: LD_INT 22
32405: PUSH
32406: LD_INT 3
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 34
32415: PUSH
32416: LD_INT 48
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PPUSH
32427: CALL_OW 69
32431: PUSH
32432: LD_INT 1
32434: ARRAY
32435: ST_TO_ADDR
// missionStage := 12 ;
32436: LD_ADDR_EXP 15
32440: PUSH
32441: LD_INT 12
32443: ST_TO_ADDR
// platonovHasBomb := true ;
32444: LD_ADDR_EXP 30
32448: PUSH
32449: LD_INT 1
32451: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32452: LD_VAR 0 1
32456: PPUSH
32457: LD_INT 181
32459: PPUSH
32460: LD_INT 86
32462: PPUSH
32463: CALL_OW 171
// AddComHold ( bomb ) ;
32467: LD_VAR 0 1
32471: PPUSH
32472: CALL_OW 200
// wait ( 0 0$10 ) ;
32476: LD_INT 350
32478: PPUSH
32479: CALL_OW 67
// DialogueOn ;
32483: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32487: LD_EXP 68
32491: PPUSH
32492: LD_STRING D15-Pla-1
32494: PPUSH
32495: CALL_OW 94
// dec := Query ( Q15a ) ;
32499: LD_ADDR_VAR 0 2
32503: PUSH
32504: LD_STRING Q15a
32506: PPUSH
32507: CALL_OW 97
32511: ST_TO_ADDR
// if dec = 1 then
32512: LD_VAR 0 2
32516: PUSH
32517: LD_INT 1
32519: EQUAL
32520: IFFALSE 32543
// begin Say ( JMM , D15a-JMM-1 ) ;
32522: LD_EXP 40
32526: PPUSH
32527: LD_STRING D15a-JMM-1
32529: PPUSH
32530: CALL_OW 88
// YouLost ( Surrender ) ;
32534: LD_STRING Surrender
32536: PPUSH
32537: CALL_OW 104
// exit ;
32541: GO 33536
// end ; if dec = 2 then
32543: LD_VAR 0 2
32547: PUSH
32548: LD_INT 2
32550: EQUAL
32551: IFFALSE 32620
// begin Say ( JMM , D15b-JMM-1 ) ;
32553: LD_EXP 40
32557: PPUSH
32558: LD_STRING D15b-JMM-1
32560: PPUSH
32561: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32565: LD_EXP 68
32569: PPUSH
32570: LD_STRING D15b-Pla-1
32572: PPUSH
32573: CALL_OW 94
// DialogueOff ;
32577: CALL_OW 7
// wait ( 3 3$00 ) ;
32581: LD_INT 6300
32583: PPUSH
32584: CALL_OW 67
// DialogueOn ;
32588: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32592: LD_EXP 40
32596: PPUSH
32597: LD_STRING D15d-JMM-1a
32599: PPUSH
32600: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32604: LD_EXP 68
32608: PPUSH
32609: LD_STRING D15d-Pla-1
32611: PPUSH
32612: CALL_OW 94
// DialogueOff ;
32616: CALL_OW 7
// end ; if dec = 3 then
32620: LD_VAR 0 2
32624: PUSH
32625: LD_INT 3
32627: EQUAL
32628: IFFALSE 32682
// begin Say ( JMM , D15c-JMM-1 ) ;
32630: LD_EXP 40
32634: PPUSH
32635: LD_STRING D15c-JMM-1
32637: PPUSH
32638: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32642: LD_EXP 68
32646: PPUSH
32647: LD_STRING D15c-Pla-1
32649: PPUSH
32650: CALL_OW 94
// DialogueOff ;
32654: CALL_OW 7
// wait ( 0 0$15 ) ;
32658: LD_INT 525
32660: PPUSH
32661: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32665: LD_VAR 0 1
32669: PPUSH
32670: LD_INT 60
32672: PPUSH
32673: LD_INT 95
32675: PPUSH
32676: CALL_OW 116
// exit ;
32680: GO 33536
// end ; if dec = 4 then
32682: LD_VAR 0 2
32686: PUSH
32687: LD_INT 4
32689: EQUAL
32690: IFFALSE 32720
// begin Say ( JMM , D15d-JMM-1 ) ;
32692: LD_EXP 40
32696: PPUSH
32697: LD_STRING D15d-JMM-1
32699: PPUSH
32700: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32704: LD_EXP 68
32708: PPUSH
32709: LD_STRING D15d-Pla-1
32711: PPUSH
32712: CALL_OW 94
// DialogueOff ;
32716: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32720: LD_EXP 66
32724: PPUSH
32725: CALL_OW 302
32729: IFFALSE 32746
32731: PUSH
32732: LD_EXP 66
32736: PPUSH
32737: CALL_OW 255
32741: PUSH
32742: LD_INT 1
32744: EQUAL
32745: AND
32746: IFFALSE 32779
32748: PUSH
32749: LD_INT 22
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 34
32761: PUSH
32762: LD_INT 8
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PPUSH
32773: CALL_OW 69
32777: NOT
32778: AND
32779: IFFALSE 33428
// begin SetSide ( Friend , 8 ) ;
32781: LD_EXP 66
32785: PPUSH
32786: LD_INT 8
32788: PPUSH
32789: CALL_OW 235
// if IsInUnit ( Friend ) then
32793: LD_EXP 66
32797: PPUSH
32798: CALL_OW 310
32802: IFFALSE 32813
// ComExitBuilding ( Friend ) ;
32804: LD_EXP 66
32808: PPUSH
32809: CALL_OW 122
// if IsDriver ( Friend ) then
32813: LD_EXP 66
32817: PPUSH
32818: CALL 106675 0 1
32822: IFFALSE 32833
// ComExitVehicle ( Friend ) ;
32824: LD_EXP 66
32828: PPUSH
32829: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32833: LD_EXP 66
32837: PPUSH
32838: LD_INT 9
32840: PPUSH
32841: LD_INT 2
32843: PPUSH
32844: CALL_OW 171
// wait ( 0 0$05 ) ;
32848: LD_INT 175
32850: PPUSH
32851: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32855: LD_EXP 66
32859: PPUSH
32860: CALL_OW 87
// DialogueOn ;
32864: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32868: LD_EXP 40
32872: PPUSH
32873: LD_STRING D16-JMM-1
32875: PPUSH
32876: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32880: LD_EXP 66
32884: PPUSH
32885: LD_STRING D16-Friend-1
32887: PPUSH
32888: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32892: LD_EXP 40
32896: PPUSH
32897: LD_STRING D16-JMM-2
32899: PPUSH
32900: CALL_OW 88
// DialogueOff ;
32904: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32908: LD_EXP 66
32912: PPUSH
32913: LD_INT 1
32915: PPUSH
32916: CALL_OW 235
// ComHold ( Friend ) ;
32920: LD_EXP 66
32924: PPUSH
32925: CALL_OW 140
// wait ( 0 0$20 ) ;
32929: LD_INT 700
32931: PPUSH
32932: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32936: LD_EXP 66
32940: PPUSH
32941: LD_INT 9
32943: PPUSH
32944: LD_INT 2
32946: PPUSH
32947: CALL_OW 297
32951: PUSH
32952: LD_INT 30
32954: LESS
32955: IFFALSE 33024
// begin SetSide ( Friend , 8 ) ;
32957: LD_EXP 66
32961: PPUSH
32962: LD_INT 8
32964: PPUSH
32965: CALL_OW 235
// if IsInUnit ( Friend ) then
32969: LD_EXP 66
32973: PPUSH
32974: CALL_OW 310
32978: IFFALSE 32989
// ComExitBuilding ( Friend ) ;
32980: LD_EXP 66
32984: PPUSH
32985: CALL_OW 122
// if IsDriver ( Friend ) then
32989: LD_EXP 66
32993: PPUSH
32994: CALL 106675 0 1
32998: IFFALSE 33009
// ComExitVehicle ( Friend ) ;
33000: LD_EXP 66
33004: PPUSH
33005: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
33009: LD_EXP 66
33013: PPUSH
33014: LD_INT 9
33016: PPUSH
33017: LD_INT 2
33019: PPUSH
33020: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
33024: LD_INT 1050
33026: PPUSH
33027: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33031: LD_INT 22
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 34
33043: PUSH
33044: LD_INT 8
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PPUSH
33055: CALL_OW 69
33059: NOT
33060: IFFALSE 33406
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
33062: LD_ADDR_VAR 0 3
33066: PUSH
33067: LD_INT 22
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 26
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 3
33089: PUSH
33090: LD_INT 25
33092: PUSH
33093: LD_INT 12
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 25
33102: PUSH
33103: LD_INT 16
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: LIST
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: LIST
33119: PPUSH
33120: CALL_OW 69
33124: PUSH
33125: LD_EXP 40
33129: PUSH
33130: LD_EXP 42
33134: PUSH
33135: LD_EXP 56
33139: PUSH
33140: LD_EXP 43
33144: PUSH
33145: LD_EXP 44
33149: PUSH
33150: LD_EXP 45
33154: PUSH
33155: LD_EXP 46
33159: PUSH
33160: LD_EXP 47
33164: PUSH
33165: LD_EXP 48
33169: PUSH
33170: LD_EXP 49
33174: PUSH
33175: LD_EXP 50
33179: PUSH
33180: LD_EXP 51
33184: PUSH
33185: LD_EXP 52
33189: PUSH
33190: LD_EXP 53
33194: PUSH
33195: LD_EXP 54
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: DIFF
33217: ST_TO_ADDR
// DialogueOn ;
33218: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
33222: LD_EXP 68
33226: PPUSH
33227: LD_STRING D16a-Pla-1
33229: PPUSH
33230: CALL_OW 94
// if Stevens then
33234: LD_EXP 42
33238: IFFALSE 33254
// Say ( Stevens , D16a-Huck-1 ) else
33240: LD_EXP 42
33244: PPUSH
33245: LD_STRING D16a-Huck-1
33247: PPUSH
33248: CALL_OW 88
33252: GO 33296
// if Baker then
33254: LD_EXP 56
33258: IFFALSE 33274
// Say ( Baker , D16a-Huck-1 ) else
33260: LD_EXP 56
33264: PPUSH
33265: LD_STRING D16a-Huck-1
33267: PPUSH
33268: CALL_OW 88
33272: GO 33296
// if tmp then
33274: LD_VAR 0 3
33278: IFFALSE 33296
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33280: LD_VAR 0 3
33284: PUSH
33285: LD_INT 1
33287: ARRAY
33288: PPUSH
33289: LD_STRING D16a-Sol1-1
33291: PPUSH
33292: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33296: LD_EXP 66
33300: PPUSH
33301: CALL_OW 255
33305: PUSH
33306: LD_INT 8
33308: EQUAL
33309: IFFALSE 33325
// Say ( JMM , D16a-JMM-1 ) else
33311: LD_EXP 40
33315: PPUSH
33316: LD_STRING D16a-JMM-1
33318: PPUSH
33319: CALL_OW 88
33323: GO 33385
// begin Say ( JMM , D16a-JMM-1a ) ;
33325: LD_EXP 40
33329: PPUSH
33330: LD_STRING D16a-JMM-1a
33332: PPUSH
33333: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33337: LD_EXP 66
33341: PPUSH
33342: LD_STRING D16a-Friend-1
33344: PPUSH
33345: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33349: LD_EXP 66
33353: PPUSH
33354: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33358: LD_EXP 66
33362: PPUSH
33363: LD_INT 191
33365: PPUSH
33366: LD_INT 103
33368: PPUSH
33369: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33373: LD_EXP 66
33377: PPUSH
33378: LD_INT 3
33380: PPUSH
33381: CALL_OW 235
// end ; DialogueOff ;
33385: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33389: LD_VAR 0 1
33393: PPUSH
33394: LD_INT 60
33396: PPUSH
33397: LD_INT 95
33399: PPUSH
33400: CALL_OW 116
// end else
33404: GO 33426
// begin DialogueOn ;
33406: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33410: LD_EXP 68
33414: PPUSH
33415: LD_STRING D16c-Pla-1
33417: PPUSH
33418: CALL_OW 94
// DialogueOff ;
33422: CALL_OW 7
// end ; end else
33426: GO 33536
// begin wait ( 3 3$00 ) ;
33428: LD_INT 6300
33430: PPUSH
33431: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) and not bombExploded then
33435: LD_INT 22
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 34
33447: PUSH
33448: LD_INT 8
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PPUSH
33459: CALL_OW 69
33463: NOT
33464: IFFALSE 33473
33466: PUSH
33467: LD_EXP 37
33471: NOT
33472: AND
33473: IFFALSE 33516
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33475: LD_EXP 68
33479: PPUSH
33480: LD_STRING D16b-Pla-1
33482: PPUSH
33483: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33487: LD_EXP 40
33491: PPUSH
33492: LD_STRING D16b-JMM-1
33494: PPUSH
33495: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33499: LD_VAR 0 1
33503: PPUSH
33504: LD_INT 60
33506: PPUSH
33507: LD_INT 95
33509: PPUSH
33510: CALL_OW 116
// end else
33514: GO 33536
// begin DialogueOn ;
33516: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33520: LD_EXP 68
33524: PPUSH
33525: LD_STRING D16c-Pla-1
33527: PPUSH
33528: CALL_OW 94
// DialogueOff ;
33532: CALL_OW 7
// end ; end ; end ;
33536: PPOPN 3
33538: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33539: LD_INT 25
33541: PPUSH
33542: LD_INT 1
33544: PPUSH
33545: CALL_OW 321
33549: PUSH
33550: LD_INT 2
33552: EQUAL
33553: IFTRUE 33565
33555: PUSH
33556: LD_EXP 14
33560: PUSH
33561: LD_INT 126000
33563: GREATEREQUAL
33564: OR
33565: IFFALSE 33574
33567: PUSH
33568: LD_EXP 23
33572: NOT
33573: AND
33574: IFFALSE 33587
33576: PUSH
33577: LD_EXP 79
33581: PPUSH
33582: CALL_OW 302
33586: AND
33587: IFFALSE 33945
33589: GO 33591
33591: DISABLE
33592: LD_INT 0
33594: PPUSH
// begin missionStage := 11 ;
33595: LD_ADDR_EXP 15
33599: PUSH
33600: LD_INT 11
33602: ST_TO_ADDR
// DialogueOn ;
33603: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33607: LD_EXP 79
33611: PPUSH
33612: LD_STRING D9-Roth-1
33614: PPUSH
33615: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33619: LD_EXP 40
33623: PPUSH
33624: LD_STRING D9-JMM-1
33626: PPUSH
33627: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33631: LD_EXP 79
33635: PPUSH
33636: LD_STRING D9-Roth-2
33638: PPUSH
33639: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33643: LD_EXP 79
33647: PPUSH
33648: LD_STRING D9-Roth-2a
33650: PPUSH
33651: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33655: LD_EXP 68
33659: PPUSH
33660: LD_STRING D9-Pla-2
33662: PPUSH
33663: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33667: LD_EXP 79
33671: PPUSH
33672: LD_STRING D9-Roth-3
33674: PPUSH
33675: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33679: LD_EXP 68
33683: PPUSH
33684: LD_STRING D9-Pla-3
33686: PPUSH
33687: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33691: LD_EXP 79
33695: PPUSH
33696: LD_STRING D9-Roth-4
33698: PPUSH
33699: CALL_OW 94
// dec := Query ( Q9 ) ;
33703: LD_ADDR_VAR 0 1
33707: PUSH
33708: LD_STRING Q9
33710: PPUSH
33711: CALL_OW 97
33715: ST_TO_ADDR
// if dec = 1 then
33716: LD_VAR 0 1
33720: PUSH
33721: LD_INT 1
33723: EQUAL
33724: IFFALSE 33738
// SayRadio ( Roth , D9a-Roth-1 ) ;
33726: LD_EXP 79
33730: PPUSH
33731: LD_STRING D9a-Roth-1
33733: PPUSH
33734: CALL_OW 94
// if dec = 2 then
33738: LD_VAR 0 1
33742: PUSH
33743: LD_INT 2
33745: EQUAL
33746: IFFALSE 33772
// begin Say ( JMM , D9b-JMM-1 ) ;
33748: LD_EXP 40
33752: PPUSH
33753: LD_STRING D9b-JMM-1
33755: PPUSH
33756: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33760: LD_EXP 79
33764: PPUSH
33765: LD_STRING D9b-Roth-1
33767: PPUSH
33768: CALL_OW 94
// end ; if dec = 3 then
33772: LD_VAR 0 1
33776: PUSH
33777: LD_INT 3
33779: EQUAL
33780: IFFALSE 33842
// begin Say ( JMM , D9c-JMM-1 ) ;
33782: LD_EXP 40
33786: PPUSH
33787: LD_STRING D9c-JMM-1
33789: PPUSH
33790: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33794: LD_EXP 79
33798: PPUSH
33799: LD_STRING D9c-Roth-1
33801: PPUSH
33802: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33806: LD_EXP 40
33810: PPUSH
33811: LD_STRING D9c-JMM-2
33813: PPUSH
33814: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33818: LD_EXP 79
33822: PPUSH
33823: LD_STRING D9c-Roth-2
33825: PPUSH
33826: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33830: LD_EXP 40
33834: PPUSH
33835: LD_STRING D9c-JMM-3
33837: PPUSH
33838: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33842: LD_EXP 79
33846: PPUSH
33847: LD_STRING D9c-Roth-3
33849: PPUSH
33850: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33854: LD_EXP 79
33858: PPUSH
33859: LD_STRING D9cont-Roth-1
33861: PPUSH
33862: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33866: LD_EXP 40
33870: PPUSH
33871: LD_STRING D9cont-JMM-1
33873: PPUSH
33874: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33878: LD_EXP 79
33882: PPUSH
33883: LD_STRING D9cont-Roth-2
33885: PPUSH
33886: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33890: LD_EXP 40
33894: PPUSH
33895: LD_STRING D9cont-JMM-2
33897: PPUSH
33898: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33902: LD_EXP 79
33906: PPUSH
33907: LD_STRING D9cont-Roth-3
33909: PPUSH
33910: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33914: LD_EXP 40
33918: PPUSH
33919: LD_STRING D9cont-JMM-3
33921: PPUSH
33922: CALL_OW 88
// DialogueOff ;
33926: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33930: LD_STRING M3
33932: PPUSH
33933: CALL_OW 337
// allianceActive := true ;
33937: LD_ADDR_EXP 31
33941: PUSH
33942: LD_INT 1
33944: ST_TO_ADDR
// end ;
33945: PPOPN 1
33947: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33948: LD_INT 1
33950: PPUSH
33951: LD_INT 126
33953: PPUSH
33954: CALL_OW 292
33958: IFFALSE 33971
33960: PUSH
33961: LD_EXP 68
33965: PPUSH
33966: CALL_OW 310
33970: AND
33971: IFFALSE 34124
33973: GO 33975
33975: DISABLE
33976: LD_INT 0
33978: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33979: LD_EXP 68
33983: PPUSH
33984: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33988: LD_ADDR_VAR 0 1
33992: PUSH
33993: LD_INT 4
33995: PPUSH
33996: LD_INT 22
33998: PUSH
33999: LD_INT 1
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PPUSH
34006: CALL_OW 70
34010: PPUSH
34011: LD_EXP 68
34015: PPUSH
34016: CALL_OW 74
34020: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
34021: LD_EXP 68
34025: PPUSH
34026: LD_VAR 0 1
34030: PUSH
34031: LD_INT 1
34033: ARRAY
34034: PPUSH
34035: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
34039: LD_EXP 68
34043: PPUSH
34044: LD_STRING D18-Pla-1
34046: PPUSH
34047: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
34051: LD_INT 22
34053: PUSH
34054: LD_INT 3
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 34
34063: PUSH
34064: LD_INT 48
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PPUSH
34075: CALL_OW 69
34079: IFFALSE 34124
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
34081: LD_INT 22
34083: PUSH
34084: LD_INT 3
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 34
34093: PUSH
34094: LD_INT 48
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PPUSH
34105: CALL_OW 69
34109: PUSH
34110: LD_INT 1
34112: ARRAY
34113: PPUSH
34114: LD_INT 111
34116: PPUSH
34117: LD_INT 97
34119: PPUSH
34120: CALL_OW 116
// end ;
34124: PPOPN 1
34126: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
34127: LD_EXP 68
34131: PPUSH
34132: CALL_OW 301
34136: IFFALSE 34149
34138: PUSH
34139: LD_EXP 71
34143: PPUSH
34144: CALL_OW 301
34148: AND
34149: IFFALSE 34213
34151: PUSH
34152: LD_INT 22
34154: PUSH
34155: LD_INT 3
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 21
34164: PUSH
34165: LD_INT 1
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 50
34174: PUSH
34175: EMPTY
34176: LIST
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: LIST
34182: PPUSH
34183: CALL_OW 69
34187: PUSH
34188: LD_INT 14
34190: PUSH
34191: LD_INT 13
34193: PUSH
34194: LD_INT 12
34196: PUSH
34197: LD_INT 10
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: PUSH
34206: LD_OWVAR 67
34210: ARRAY
34211: LESS
34212: AND
34213: IFFALSE 35014
34215: GO 34217
34217: DISABLE
34218: LD_INT 0
34220: PPUSH
34221: PPUSH
34222: PPUSH
34223: PPUSH
// begin MC_Kill ( 2 ) ;
34224: LD_INT 2
34226: PPUSH
34227: CALL 40134 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
34231: LD_INT 1
34233: PPUSH
34234: LD_INT 3
34236: PPUSH
34237: LD_INT 1
34239: PPUSH
34240: LD_INT 1
34242: PPUSH
34243: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
34247: LD_ADDR_VAR 0 2
34251: PUSH
34252: LD_INT 22
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 21
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 50
34274: PUSH
34275: EMPTY
34276: LIST
34277: PUSH
34278: LD_INT 26
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: PPUSH
34294: CALL_OW 69
34298: ST_TO_ADDR
// if not tmp then
34299: LD_VAR 0 2
34303: NOT
34304: IFFALSE 34360
// begin uc_side = 3 ;
34306: LD_ADDR_OWVAR 20
34310: PUSH
34311: LD_INT 3
34313: ST_TO_ADDR
// uc_nation = 3 ;
34314: LD_ADDR_OWVAR 21
34318: PUSH
34319: LD_INT 3
34321: ST_TO_ADDR
// hc_name =  ;
34322: LD_ADDR_OWVAR 26
34326: PUSH
34327: LD_STRING 
34329: ST_TO_ADDR
// hc_gallery =  ;
34330: LD_ADDR_OWVAR 33
34334: PUSH
34335: LD_STRING 
34337: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34338: LD_INT 1
34340: PPUSH
34341: LD_INT 10
34343: PPUSH
34344: CALL_OW 381
// tmp = CreateHuman ;
34348: LD_ADDR_VAR 0 2
34352: PUSH
34353: CALL_OW 44
34357: ST_TO_ADDR
// end else
34358: GO 34374
// tmp := tmp [ 1 ] ;
34360: LD_ADDR_VAR 0 2
34364: PUSH
34365: LD_VAR 0 2
34369: PUSH
34370: LD_INT 1
34372: ARRAY
34373: ST_TO_ADDR
// DialogueOn ;
34374: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34378: LD_VAR 0 2
34382: PPUSH
34383: LD_STRING DSurrenderRussians-RSol1-1a
34385: PPUSH
34386: CALL_OW 94
// DialogueOff ;
34390: CALL_OW 7
// russianDestroyed := true ;
34394: LD_ADDR_EXP 21
34398: PUSH
34399: LD_INT 1
34401: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34402: LD_ADDR_VAR 0 1
34406: PUSH
34407: LD_INT 22
34409: PUSH
34410: LD_INT 6
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PPUSH
34417: CALL_OW 69
34421: PUSH
34422: FOR_IN
34423: IFFALSE 34436
// KillUnit ( i ) ;
34425: LD_VAR 0 1
34429: PPUSH
34430: CALL_OW 66
34434: GO 34422
34436: POP
34437: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34438: LD_INT 22
34440: PUSH
34441: LD_INT 3
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 21
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PPUSH
34462: CALL_OW 69
34466: PPUSH
34467: CALL_OW 122
// wait ( 0 0$1 ) ;
34471: LD_INT 35
34473: PPUSH
34474: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34478: LD_INT 22
34480: PUSH
34481: LD_INT 3
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 21
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PPUSH
34502: CALL_OW 69
34506: PPUSH
34507: LD_INT 25
34509: PPUSH
34510: CALL_OW 173
// wait ( 0 0$35 ) ;
34514: LD_INT 1225
34516: PPUSH
34517: CALL_OW 67
// PrepareOmarInvasion ;
34521: CALL 16428 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34525: LD_ADDR_VAR 0 2
34529: PUSH
34530: LD_EXP 97
34534: PPUSH
34535: CALL_OW 250
34539: PUSH
34540: LD_EXP 97
34544: PPUSH
34545: CALL_OW 251
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34554: LD_VAR 0 2
34558: PUSH
34559: LD_INT 1
34561: ARRAY
34562: PPUSH
34563: LD_VAR 0 2
34567: PUSH
34568: LD_INT 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: LD_INT 8
34577: NEG
34578: PPUSH
34579: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34583: LD_EXP 97
34587: PPUSH
34588: CALL_OW 87
// DialogueOn ;
34592: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34596: LD_EXP 40
34600: PPUSH
34601: LD_STRING D19-JMM-1
34603: PPUSH
34604: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34608: LD_ADDR_VAR 0 3
34612: PUSH
34613: LD_INT 22
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 26
34625: PUSH
34626: LD_INT 1
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: PUSH
34636: LD_INT 25
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 25
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 25
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 25
34668: PUSH
34669: LD_INT 4
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 25
34678: PUSH
34679: LD_INT 5
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 25
34688: PUSH
34689: LD_INT 8
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: PPUSH
34710: CALL_OW 69
34714: PUSH
34715: LD_EXP 40
34719: PUSH
34720: LD_EXP 41
34724: PUSH
34725: LD_EXP 64
34729: PUSH
34730: LD_EXP 42
34734: PUSH
34735: LD_EXP 43
34739: PUSH
34740: LD_EXP 44
34744: PUSH
34745: LD_EXP 45
34749: PUSH
34750: LD_EXP 46
34754: PUSH
34755: LD_EXP 47
34759: PUSH
34760: LD_EXP 48
34764: PUSH
34765: LD_EXP 49
34769: PUSH
34770: LD_EXP 50
34774: PUSH
34775: LD_EXP 51
34779: PUSH
34780: LD_EXP 52
34784: PUSH
34785: LD_EXP 53
34789: PUSH
34790: LD_EXP 54
34794: PUSH
34795: LD_EXP 55
34799: PUSH
34800: LD_EXP 56
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: DIFF
34825: ST_TO_ADDR
// if tmp2 then
34826: LD_VAR 0 3
34830: IFFALSE 34848
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34832: LD_VAR 0 3
34836: PUSH
34837: LD_INT 1
34839: ARRAY
34840: PPUSH
34841: LD_STRING D19-Sol1-1
34843: PPUSH
34844: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34848: LD_EXP 40
34852: PPUSH
34853: LD_STRING D19-JMM-2
34855: PPUSH
34856: CALL_OW 88
// DialogueOff ;
34860: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34864: LD_VAR 0 2
34868: PUSH
34869: LD_INT 1
34871: ARRAY
34872: PPUSH
34873: LD_VAR 0 2
34877: PUSH
34878: LD_INT 2
34880: ARRAY
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34889: LD_STRING M5
34891: PPUSH
34892: CALL_OW 337
// omarOnMotherLode := false ;
34896: LD_ADDR_VAR 0 4
34900: PUSH
34901: LD_INT 0
34903: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34904: LD_INT 35
34906: PPUSH
34907: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34911: LD_EXP 97
34915: PPUSH
34916: LD_INT 215
34918: PPUSH
34919: LD_INT 100
34921: PPUSH
34922: CALL_OW 297
34926: PUSH
34927: LD_INT 10
34929: LESS
34930: IFFALSE 34939
34932: PUSH
34933: LD_VAR 0 4
34937: NOT
34938: AND
34939: IFFALSE 34973
// begin omarOnMotherLode := true ;
34941: LD_ADDR_VAR 0 4
34945: PUSH
34946: LD_INT 1
34948: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34949: LD_EXP 40
34953: PPUSH
34954: LD_STRING D19b-JMM-1
34956: PPUSH
34957: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34961: LD_EXP 97
34965: PPUSH
34966: LD_STRING DOmarContam-Omar-1
34968: PPUSH
34969: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34973: LD_EXP 97
34977: PPUSH
34978: CALL_OW 301
34982: IFFALSE 34904
// Say ( JMM , D19a-JMM-1 ) ;
34984: LD_EXP 40
34988: PPUSH
34989: LD_STRING D19a-JMM-1
34991: PPUSH
34992: CALL_OW 88
// if Heike then
34996: LD_EXP 98
35000: IFFALSE 35014
// Say ( Heike , D19a-Hke-1 ) ;
35002: LD_EXP 98
35006: PPUSH
35007: LD_STRING D19a-Hke-1
35009: PPUSH
35010: CALL_OW 88
// end ;
35014: PPOPN 4
35016: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
35017: LD_INT 22
35019: PUSH
35020: LD_INT 3
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 21
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PPUSH
35041: CALL_OW 69
35045: IFFALSE 35053
35047: PUSH
35048: LD_EXP 21
35052: AND
35053: IFFALSE 35121
35055: GO 35057
35057: DISABLE
35058: LD_INT 0
35060: PPUSH
35061: PPUSH
// begin enable ;
35062: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
35063: LD_ADDR_VAR 0 2
35067: PUSH
35068: LD_INT 25
35070: PPUSH
35071: LD_INT 22
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PPUSH
35081: CALL_OW 70
35085: ST_TO_ADDR
// if not tmp then
35086: LD_VAR 0 2
35090: NOT
35091: IFFALSE 35095
// exit ;
35093: GO 35121
// for i in tmp do
35095: LD_ADDR_VAR 0 1
35099: PUSH
35100: LD_VAR 0 2
35104: PUSH
35105: FOR_IN
35106: IFFALSE 35119
// RemoveUnit ( i ) ;
35108: LD_VAR 0 1
35112: PPUSH
35113: CALL_OW 64
35117: GO 35105
35119: POP
35120: POP
// end ;
35121: PPOPN 2
35123: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
35124: LD_INT 22
35126: PUSH
35127: LD_INT 7
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 21
35136: PUSH
35137: LD_INT 1
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PPUSH
35148: CALL_OW 69
35152: PUSH
35153: LD_INT 6
35155: LESS
35156: IFFALSE 35624
35158: GO 35160
35160: DISABLE
35161: LD_INT 0
35163: PPUSH
35164: PPUSH
// begin MC_Kill ( 1 ) ;
35165: LD_INT 1
35167: PPUSH
35168: CALL 40134 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
35172: LD_INT 7
35174: PPUSH
35175: LD_INT 1
35177: PPUSH
35178: LD_INT 1
35180: PPUSH
35181: LD_INT 1
35183: PPUSH
35184: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
35188: LD_ADDR_VAR 0 1
35192: PUSH
35193: LD_INT 22
35195: PUSH
35196: LD_INT 7
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 26
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PPUSH
35217: CALL_OW 69
35221: PUSH
35222: LD_EXP 79
35226: DIFF
35227: ST_TO_ADDR
// if tmp then
35228: LD_VAR 0 1
35232: IFFALSE 35250
// tmp := tmp [ 1 ] else
35234: LD_ADDR_VAR 0 1
35238: PUSH
35239: LD_VAR 0 1
35243: PUSH
35244: LD_INT 1
35246: ARRAY
35247: ST_TO_ADDR
35248: GO 35286
// begin uc_side := 7 ;
35250: LD_ADDR_OWVAR 20
35254: PUSH
35255: LD_INT 7
35257: ST_TO_ADDR
// uc_nation := 1 ;
35258: LD_ADDR_OWVAR 21
35262: PUSH
35263: LD_INT 1
35265: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35266: LD_INT 1
35268: PPUSH
35269: LD_INT 8
35271: PPUSH
35272: CALL_OW 384
// tmp := CreateHuman ;
35276: LD_ADDR_VAR 0 1
35280: PUSH
35281: CALL_OW 44
35285: ST_TO_ADDR
// end ; DialogueOn ;
35286: CALL_OW 6
// if IsOK ( Roth ) then
35290: LD_EXP 79
35294: PPUSH
35295: CALL_OW 302
35299: IFFALSE 35313
// Say ( JMM , DAb-JMM-1 ) ;
35301: LD_EXP 40
35305: PPUSH
35306: LD_STRING DAb-JMM-1
35308: PPUSH
35309: CALL_OW 88
// if IsOK ( Roth ) then
35313: LD_EXP 79
35317: PPUSH
35318: CALL_OW 302
35322: IFFALSE 35346
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35324: LD_EXP 79
35328: PPUSH
35329: LD_STRING DSurrenderAlliance-Roth-1
35331: PPUSH
35332: CALL_OW 88
// RothCaptured := true ;
35336: LD_ADDR_EXP 33
35340: PUSH
35341: LD_INT 1
35343: ST_TO_ADDR
// end else
35344: GO 35358
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35346: LD_VAR 0 1
35350: PPUSH
35351: LD_STRING DSurrenderAlliance-Sci1-1
35353: PPUSH
35354: CALL_OW 88
// DialogueOff ;
35358: CALL_OW 7
// allianceDestroyed := true ;
35362: LD_ADDR_EXP 23
35366: PUSH
35367: LD_INT 1
35369: ST_TO_ADDR
// if capturedUnit = 0 then
35370: LD_EXP 34
35374: PUSH
35375: LD_INT 0
35377: EQUAL
35378: IFFALSE 35387
// SetAchievement ( ACH_ALLIANCE ) ;
35380: LD_STRING ACH_ALLIANCE
35382: PPUSH
35383: CALL_OW 543
// if trueAmericans then
35387: LD_EXP 35
35391: IFFALSE 35467
// begin if trueAmericans = 1 then
35393: LD_EXP 35
35397: PUSH
35398: LD_INT 1
35400: EQUAL
35401: IFFALSE 35417
// Say ( JMM , DAb-JMM-1a ) else
35403: LD_EXP 40
35407: PPUSH
35408: LD_STRING DAb-JMM-1a
35410: PPUSH
35411: CALL_OW 88
35415: GO 35429
// Say ( JMM , DAb-JMM-1b ) ;
35417: LD_EXP 40
35421: PPUSH
35422: LD_STRING DAb-JMM-1b
35424: PPUSH
35425: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35429: LD_EXP 35
35433: PPUSH
35434: CALL_OW 87
// for i in trueAmericans do
35438: LD_ADDR_VAR 0 2
35442: PUSH
35443: LD_EXP 35
35447: PUSH
35448: FOR_IN
35449: IFFALSE 35465
// SetSide ( i , 1 ) ;
35451: LD_VAR 0 2
35455: PPUSH
35456: LD_INT 1
35458: PPUSH
35459: CALL_OW 235
35463: GO 35448
35465: POP
35466: POP
// end ; repeat wait ( 0 0$1 ) ;
35467: LD_INT 35
35469: PPUSH
35470: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35474: LD_ADDR_VAR 0 2
35478: PUSH
35479: LD_INT 22
35481: PUSH
35482: LD_INT 7
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 21
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PPUSH
35503: CALL_OW 69
35507: PUSH
35508: FOR_IN
35509: IFFALSE 35591
// begin if IsInUnit ( i ) then
35511: LD_VAR 0 2
35515: PPUSH
35516: CALL_OW 310
35520: IFFALSE 35531
// ComExitBuilding ( i ) ;
35522: LD_VAR 0 2
35526: PPUSH
35527: CALL_OW 122
// if IsDriver ( i ) then
35531: LD_VAR 0 2
35535: PPUSH
35536: CALL 106675 0 1
35540: IFFALSE 35551
// ComExitVehicle ( i ) ;
35542: LD_VAR 0 2
35546: PPUSH
35547: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35551: LD_VAR 0 2
35555: PPUSH
35556: LD_INT 26
35558: PPUSH
35559: CALL_OW 308
35563: NOT
35564: IFFALSE 35580
// AddComMoveToArea ( i , allianceEscapeArea ) else
35566: LD_VAR 0 2
35570: PPUSH
35571: LD_INT 26
35573: PPUSH
35574: CALL_OW 173
35578: GO 35589
// RemoveUnit ( i ) ;
35580: LD_VAR 0 2
35584: PPUSH
35585: CALL_OW 64
// end ;
35589: GO 35508
35591: POP
35592: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35593: LD_INT 22
35595: PUSH
35596: LD_INT 7
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 21
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PPUSH
35617: CALL_OW 69
35621: NOT
35622: IFFALSE 35467
// end ;
35624: PPOPN 2
35626: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35627: LD_INT 0
35629: PPUSH
35630: PPUSH
// if not unit then
35631: LD_VAR 0 1
35635: NOT
35636: IFFALSE 35640
// exit ;
35638: GO 37156
// DoNotAttack ( 7 , unit ) ;
35640: LD_INT 7
35642: PPUSH
35643: LD_VAR 0 1
35647: PPUSH
35648: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35652: LD_VAR 0 1
35656: PPUSH
35657: LD_INT 260
35659: PPUSH
35660: LD_INT 235
35662: PPUSH
35663: LD_INT 3
35665: PPUSH
35666: LD_INT 1
35668: PPUSH
35669: CALL_OW 483
// SetSide ( unit , 4 ) ;
35673: LD_VAR 0 1
35677: PPUSH
35678: LD_INT 4
35680: PPUSH
35681: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35685: LD_ADDR_EXP 34
35689: PUSH
35690: LD_EXP 34
35694: PUSH
35695: LD_INT 1
35697: PLUS
35698: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35699: LD_INT 70
35701: PPUSH
35702: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35706: LD_INT 260
35708: PPUSH
35709: LD_INT 235
35711: PPUSH
35712: LD_INT 1
35714: PPUSH
35715: LD_INT 8
35717: NEG
35718: PPUSH
35719: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35723: LD_VAR 0 1
35727: PPUSH
35728: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35732: LD_VAR 0 1
35736: PPUSH
35737: LD_EXP 79
35741: PPUSH
35742: CALL_OW 119
// DialogueOn ;
35746: CALL_OW 6
// case unit of JMM :
35750: LD_VAR 0 1
35754: PUSH
35755: LD_EXP 40
35759: DOUBLE
35760: EQUAL
35761: IFTRUE 35765
35763: GO 35780
35765: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35766: LD_EXP 40
35770: PPUSH
35771: LD_STRING DA1-JMM-1
35773: PPUSH
35774: CALL_OW 91
35778: GO 36222
35780: LD_EXP 41
35784: DOUBLE
35785: EQUAL
35786: IFTRUE 35790
35788: GO 35805
35790: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35791: LD_EXP 41
35795: PPUSH
35796: LD_STRING DA1-Joan-1
35798: PPUSH
35799: CALL_OW 91
35803: GO 36222
35805: LD_EXP 43
35809: DOUBLE
35810: EQUAL
35811: IFTRUE 35815
35813: GO 35830
35815: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35816: LD_EXP 43
35820: PPUSH
35821: LD_STRING DA1-Lisa-1
35823: PPUSH
35824: CALL_OW 91
35828: GO 36222
35830: LD_EXP 44
35834: DOUBLE
35835: EQUAL
35836: IFTRUE 35840
35838: GO 35855
35840: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35841: LD_EXP 44
35845: PPUSH
35846: LD_STRING DA1-Don-1
35848: PPUSH
35849: CALL_OW 91
35853: GO 36222
35855: LD_EXP 51
35859: DOUBLE
35860: EQUAL
35861: IFTRUE 35865
35863: GO 35880
35865: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35866: LD_EXP 51
35870: PPUSH
35871: LD_STRING DA1-Corn-1
35873: PPUSH
35874: CALL_OW 91
35878: GO 36222
35880: LD_EXP 47
35884: DOUBLE
35885: EQUAL
35886: IFTRUE 35890
35888: GO 35905
35890: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35891: LD_EXP 47
35895: PPUSH
35896: LD_STRING DA1-Den-1
35898: PPUSH
35899: CALL_OW 91
35903: GO 36222
35905: LD_EXP 45
35909: DOUBLE
35910: EQUAL
35911: IFTRUE 35915
35913: GO 35930
35915: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35916: LD_EXP 45
35920: PPUSH
35921: LD_STRING DA1-Bobby-1
35923: PPUSH
35924: CALL_OW 91
35928: GO 36222
35930: LD_EXP 49
35934: DOUBLE
35935: EQUAL
35936: IFTRUE 35940
35938: GO 35955
35940: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35941: LD_EXP 49
35945: PPUSH
35946: LD_STRING DA1-Glad-1
35948: PPUSH
35949: CALL_OW 91
35953: GO 36222
35955: LD_EXP 46
35959: DOUBLE
35960: EQUAL
35961: IFTRUE 35965
35963: GO 35980
35965: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35966: LD_EXP 46
35970: PPUSH
35971: LD_STRING DA1-Cyrus-1
35973: PPUSH
35974: CALL_OW 91
35978: GO 36222
35980: LD_EXP 42
35984: DOUBLE
35985: EQUAL
35986: IFTRUE 35990
35988: GO 36005
35990: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35991: LD_EXP 42
35995: PPUSH
35996: LD_STRING DA1-Huck-1
35998: PPUSH
35999: CALL_OW 91
36003: GO 36222
36005: LD_EXP 56
36009: DOUBLE
36010: EQUAL
36011: IFTRUE 36015
36013: GO 36030
36015: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
36016: LD_EXP 56
36020: PPUSH
36021: LD_STRING DA1-Huck-1
36023: PPUSH
36024: CALL_OW 91
36028: GO 36222
36030: LD_EXP 48
36034: DOUBLE
36035: EQUAL
36036: IFTRUE 36040
36038: GO 36055
36040: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
36041: LD_EXP 48
36045: PPUSH
36046: LD_STRING DA1-Brown-1
36048: PPUSH
36049: CALL_OW 91
36053: GO 36222
36055: LD_EXP 52
36059: DOUBLE
36060: EQUAL
36061: IFTRUE 36065
36063: GO 36080
36065: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
36066: LD_EXP 52
36070: PPUSH
36071: LD_STRING DA1-Gary-1
36073: PPUSH
36074: CALL_OW 91
36078: GO 36222
36080: LD_EXP 55
36084: DOUBLE
36085: EQUAL
36086: IFTRUE 36090
36088: GO 36105
36090: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
36091: LD_EXP 55
36095: PPUSH
36096: LD_STRING DA1-Con-1
36098: PPUSH
36099: CALL_OW 91
36103: GO 36222
36105: LD_EXP 64
36109: DOUBLE
36110: EQUAL
36111: IFTRUE 36115
36113: GO 36130
36115: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
36116: LD_EXP 64
36120: PPUSH
36121: LD_STRING DA1-Kurt-1
36123: PPUSH
36124: CALL_OW 91
36128: GO 36222
36130: LD_EXP 54
36134: DOUBLE
36135: EQUAL
36136: IFTRUE 36140
36138: GO 36155
36140: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
36141: LD_EXP 54
36145: PPUSH
36146: LD_STRING DA1-Yam-1
36148: PPUSH
36149: CALL_OW 91
36153: GO 36222
36155: LD_EXP 53
36159: DOUBLE
36160: EQUAL
36161: IFTRUE 36165
36163: GO 36180
36165: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
36166: LD_EXP 53
36170: PPUSH
36171: LD_STRING DA1-Frank-1
36173: PPUSH
36174: CALL_OW 91
36178: GO 36222
36180: POP
// begin if GetSex ( unit ) = sex_male then
36181: LD_VAR 0 1
36185: PPUSH
36186: CALL_OW 258
36190: PUSH
36191: LD_INT 1
36193: EQUAL
36194: IFFALSE 36210
// ForceSay ( unit , DA1-Sol1-1 ) else
36196: LD_VAR 0 1
36200: PPUSH
36201: LD_STRING DA1-Sol1-1
36203: PPUSH
36204: CALL_OW 91
36208: GO 36222
// ForceSay ( unit , DA1-FSol1-1 ) ;
36210: LD_VAR 0 1
36214: PPUSH
36215: LD_STRING DA1-FSol1-1
36217: PPUSH
36218: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
36222: LD_EXP 79
36226: PPUSH
36227: LD_STRING DA-Roth-1
36229: PPUSH
36230: CALL_OW 88
// if capturedUnit = 1 then
36234: LD_EXP 34
36238: PUSH
36239: LD_INT 1
36241: EQUAL
36242: IFFALSE 36270
// begin Say ( Simms , DA-Sim-1 ) ;
36244: LD_EXP 80
36248: PPUSH
36249: LD_STRING DA-Sim-1
36251: PPUSH
36252: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36256: LD_EXP 79
36260: PPUSH
36261: LD_STRING DA-Roth-2
36263: PPUSH
36264: CALL_OW 88
// end else
36268: GO 36282
// Say ( Simms , DA-Sim-2 ) ;
36270: LD_EXP 80
36274: PPUSH
36275: LD_STRING DA-Sim-2
36277: PPUSH
36278: CALL_OW 88
// case unit of JMM :
36282: LD_VAR 0 1
36286: PUSH
36287: LD_EXP 40
36291: DOUBLE
36292: EQUAL
36293: IFTRUE 36297
36295: GO 36312
36297: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36298: LD_EXP 40
36302: PPUSH
36303: LD_STRING DA1-JMM-1a
36305: PPUSH
36306: CALL_OW 91
36310: GO 36829
36312: LD_EXP 41
36316: DOUBLE
36317: EQUAL
36318: IFTRUE 36322
36320: GO 36337
36322: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36323: LD_EXP 41
36327: PPUSH
36328: LD_STRING DA1-Joan-1a
36330: PPUSH
36331: CALL_OW 91
36335: GO 36829
36337: LD_EXP 43
36341: DOUBLE
36342: EQUAL
36343: IFTRUE 36347
36345: GO 36362
36347: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36348: LD_EXP 43
36352: PPUSH
36353: LD_STRING DA1-Lisa-1a
36355: PPUSH
36356: CALL_OW 91
36360: GO 36829
36362: LD_EXP 44
36366: DOUBLE
36367: EQUAL
36368: IFTRUE 36372
36370: GO 36387
36372: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36373: LD_EXP 44
36377: PPUSH
36378: LD_STRING DA1-Don-1a
36380: PPUSH
36381: CALL_OW 91
36385: GO 36829
36387: LD_EXP 51
36391: DOUBLE
36392: EQUAL
36393: IFTRUE 36397
36395: GO 36412
36397: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36398: LD_EXP 51
36402: PPUSH
36403: LD_STRING DA1-Corn-1a
36405: PPUSH
36406: CALL_OW 91
36410: GO 36829
36412: LD_EXP 47
36416: DOUBLE
36417: EQUAL
36418: IFTRUE 36422
36420: GO 36437
36422: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36423: LD_EXP 47
36427: PPUSH
36428: LD_STRING DA1-Den-1a
36430: PPUSH
36431: CALL_OW 91
36435: GO 36829
36437: LD_EXP 45
36441: DOUBLE
36442: EQUAL
36443: IFTRUE 36447
36445: GO 36462
36447: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36448: LD_EXP 45
36452: PPUSH
36453: LD_STRING DA1-Bobby-1a
36455: PPUSH
36456: CALL_OW 91
36460: GO 36829
36462: LD_EXP 49
36466: DOUBLE
36467: EQUAL
36468: IFTRUE 36472
36470: GO 36487
36472: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36473: LD_EXP 49
36477: PPUSH
36478: LD_STRING DA1-Glad-1a
36480: PPUSH
36481: CALL_OW 91
36485: GO 36829
36487: LD_EXP 46
36491: DOUBLE
36492: EQUAL
36493: IFTRUE 36497
36495: GO 36512
36497: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36498: LD_EXP 46
36502: PPUSH
36503: LD_STRING DA1-Cyrus-1a
36505: PPUSH
36506: CALL_OW 91
36510: GO 36829
36512: LD_EXP 42
36516: DOUBLE
36517: EQUAL
36518: IFTRUE 36522
36520: GO 36537
36522: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36523: LD_EXP 42
36527: PPUSH
36528: LD_STRING DA1-Huck-1a
36530: PPUSH
36531: CALL_OW 91
36535: GO 36829
36537: LD_EXP 56
36541: DOUBLE
36542: EQUAL
36543: IFTRUE 36547
36545: GO 36562
36547: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36548: LD_EXP 56
36552: PPUSH
36553: LD_STRING DA1-Huck-1a
36555: PPUSH
36556: CALL_OW 91
36560: GO 36829
36562: LD_EXP 48
36566: DOUBLE
36567: EQUAL
36568: IFTRUE 36572
36570: GO 36587
36572: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36573: LD_EXP 48
36577: PPUSH
36578: LD_STRING DA1-Brown-1a
36580: PPUSH
36581: CALL_OW 91
36585: GO 36829
36587: LD_EXP 52
36591: DOUBLE
36592: EQUAL
36593: IFTRUE 36597
36595: GO 36612
36597: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36598: LD_EXP 52
36602: PPUSH
36603: LD_STRING DA1-Gary-1a
36605: PPUSH
36606: CALL_OW 91
36610: GO 36829
36612: LD_EXP 55
36616: DOUBLE
36617: EQUAL
36618: IFTRUE 36622
36620: GO 36647
36622: POP
// if JMMGirl = 3 then
36623: LD_EXP 7
36627: PUSH
36628: LD_INT 3
36630: EQUAL
36631: IFFALSE 36645
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36633: LD_EXP 55
36637: PPUSH
36638: LD_STRING DA1-Con-1a
36640: PPUSH
36641: CALL_OW 91
36645: GO 36829
36647: LD_EXP 64
36651: DOUBLE
36652: EQUAL
36653: IFTRUE 36657
36655: GO 36672
36657: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36658: LD_EXP 64
36662: PPUSH
36663: LD_STRING DA1-Kurt-1a
36665: PPUSH
36666: CALL_OW 91
36670: GO 36829
36672: LD_EXP 54
36676: DOUBLE
36677: EQUAL
36678: IFTRUE 36682
36680: GO 36697
36682: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36683: LD_EXP 54
36687: PPUSH
36688: LD_STRING DA1-Yam-1a
36690: PPUSH
36691: CALL_OW 91
36695: GO 36829
36697: LD_EXP 53
36701: DOUBLE
36702: EQUAL
36703: IFTRUE 36707
36705: GO 36722
36707: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36708: LD_EXP 53
36712: PPUSH
36713: LD_STRING DA1-Frank-1a
36715: PPUSH
36716: CALL_OW 91
36720: GO 36829
36722: POP
// begin join := rand ( 0 , 1 ) ;
36723: LD_ADDR_VAR 0 3
36727: PUSH
36728: LD_INT 0
36730: PPUSH
36731: LD_INT 1
36733: PPUSH
36734: CALL_OW 12
36738: ST_TO_ADDR
// if join then
36739: LD_VAR 0 3
36743: IFFALSE 36788
// begin if GetSex ( unit ) = sex_male then
36745: LD_VAR 0 1
36749: PPUSH
36750: CALL_OW 258
36754: PUSH
36755: LD_INT 1
36757: EQUAL
36758: IFFALSE 36774
// ForceSay ( unit , DA1-Sol1-1b ) else
36760: LD_VAR 0 1
36764: PPUSH
36765: LD_STRING DA1-Sol1-1b
36767: PPUSH
36768: CALL_OW 91
36772: GO 36786
// ForceSay ( unit , DA1-FSol1-1b ) ;
36774: LD_VAR 0 1
36778: PPUSH
36779: LD_STRING DA1-FSol1-1b
36781: PPUSH
36782: CALL_OW 91
// end else
36786: GO 36829
// begin if GetSex ( unit ) = sex_male then
36788: LD_VAR 0 1
36792: PPUSH
36793: CALL_OW 258
36797: PUSH
36798: LD_INT 1
36800: EQUAL
36801: IFFALSE 36817
// ForceSay ( unit , DA1-Sol1-1a ) else
36803: LD_VAR 0 1
36807: PPUSH
36808: LD_STRING DA1-Sol1-1a
36810: PPUSH
36811: CALL_OW 91
36815: GO 36829
// ForceSay ( unit , DA1-FSol1-1a ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: LD_STRING DA1-FSol1-1a
36824: PPUSH
36825: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36829: LD_VAR 0 1
36833: PUSH
36834: LD_EXP 40
36838: EQUAL
36839: IFFALSE 36850
// begin YouLost ( JMMCaptured ) ;
36841: LD_STRING JMMCaptured
36843: PPUSH
36844: CALL_OW 104
// exit ;
36848: GO 37156
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36850: LD_VAR 0 1
36854: PUSH
36855: LD_EXP 44
36859: PUSH
36860: LD_EXP 47
36864: PUSH
36865: LD_EXP 45
36869: PUSH
36870: LD_EXP 42
36874: PUSH
36875: LD_EXP 56
36879: PUSH
36880: LD_EXP 48
36884: PUSH
36885: LD_EXP 54
36889: PUSH
36890: LD_EXP 58
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: IN
36905: IFTRUE 36913
36907: PUSH
36908: LD_VAR 0 3
36912: OR
36913: IFFALSE 37012
// begin Say ( Roth , DA-Roth-3 ) ;
36915: LD_EXP 79
36919: PPUSH
36920: LD_STRING DA-Roth-3
36922: PPUSH
36923: CALL_OW 88
// SetSide ( unit , 7 ) ;
36927: LD_VAR 0 1
36931: PPUSH
36932: LD_INT 7
36934: PPUSH
36935: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36939: LD_ADDR_EXP 102
36943: PUSH
36944: LD_EXP 102
36948: PPUSH
36949: LD_INT 1
36951: PPUSH
36952: LD_EXP 102
36956: PUSH
36957: LD_INT 1
36959: ARRAY
36960: PUSH
36961: LD_VAR 0 1
36965: ADD
36966: PPUSH
36967: CALL_OW 1
36971: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36972: LD_INT 260
36974: PPUSH
36975: LD_INT 235
36977: PPUSH
36978: LD_INT 1
36980: PPUSH
36981: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36985: LD_VAR 0 1
36989: PPUSH
36990: LD_INT 1000
36992: PPUSH
36993: CALL_OW 234
// DialogueOff ;
36997: CALL_OW 7
// ComFree ( unit ) ;
37001: LD_VAR 0 1
37005: PPUSH
37006: CALL_OW 139
// end else
37010: GO 37093
// begin Say ( Roth , DA-Roth-3a ) ;
37012: LD_EXP 79
37016: PPUSH
37017: LD_STRING DA-Roth-3a
37019: PPUSH
37020: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
37024: LD_ADDR_EXP 35
37028: PUSH
37029: LD_EXP 35
37033: PUSH
37034: LD_VAR 0 1
37038: ADD
37039: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
37040: LD_INT 260
37042: PPUSH
37043: LD_INT 235
37045: PPUSH
37046: LD_INT 1
37048: PPUSH
37049: CALL_OW 331
// SetLives ( unit , 1000 ) ;
37053: LD_VAR 0 1
37057: PPUSH
37058: LD_INT 1000
37060: PPUSH
37061: CALL_OW 234
// DialogueOff ;
37065: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
37069: LD_VAR 0 1
37073: PPUSH
37074: LD_INT 272
37076: PPUSH
37077: LD_INT 254
37079: PPUSH
37080: CALL_OW 111
// AddComHold ( unit ) ;
37084: LD_VAR 0 1
37088: PPUSH
37089: CALL_OW 200
// end ; if capturedUnit = 1 then
37093: LD_EXP 34
37097: PUSH
37098: LD_INT 1
37100: EQUAL
37101: IFFALSE 37156
// begin DialogueOn ;
37103: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
37107: LD_EXP 40
37111: PPUSH
37112: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
37116: LD_EXP 40
37120: PPUSH
37121: LD_STRING DAa-JMM-1
37123: PPUSH
37124: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
37128: LD_EXP 40
37132: PPUSH
37133: LD_STRING DAa-JMM-1a
37135: PPUSH
37136: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
37140: LD_EXP 40
37144: PPUSH
37145: LD_STRING DAa-JMM-1b
37147: PPUSH
37148: CALL_OW 88
// DialogueOff ;
37152: CALL_OW 7
// end ; end ;
37156: LD_VAR 0 2
37160: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
37161: LD_EXP 15
37165: PUSH
37166: LD_INT 13
37168: GREATEREQUAL
37169: IFFALSE 37205
37171: PUSH
37172: LD_INT 22
37174: PUSH
37175: LD_INT 2
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 21
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PPUSH
37196: CALL_OW 69
37200: PUSH
37201: LD_INT 0
37203: EQUAL
37204: AND
37205: IFFALSE 37259
37207: PUSH
37208: LD_INT 22
37210: PUSH
37211: LD_INT 2
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 33
37220: PUSH
37221: LD_INT 5
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 21
37230: PUSH
37231: LD_INT 2
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 50
37240: PUSH
37241: EMPTY
37242: LIST
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: PPUSH
37250: CALL_OW 69
37254: PUSH
37255: LD_INT 0
37257: EQUAL
37258: AND
37259: IFFALSE 37267
37261: PUSH
37262: LD_EXP 21
37266: AND
37267: IFFALSE 37275
37269: PUSH
37270: LD_EXP 22
37274: AND
37275: IFFALSE 37283
37277: PUSH
37278: LD_EXP 23
37282: AND
37283: IFFALSE 38064
37285: GO 37287
37287: DISABLE
37288: LD_INT 0
37290: PPUSH
37291: PPUSH
37292: PPUSH
// begin wait ( 0 0$05 ) ;
37293: LD_INT 175
37295: PPUSH
37296: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37300: LD_INT 22
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 21
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 23
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 50
37332: PUSH
37333: EMPTY
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: PPUSH
37342: CALL_OW 69
37346: PPUSH
37347: CALL 73163 0 1
37351: PUSH
37352: LD_INT 2
37354: LESS
37355: IFFALSE 37366
// begin YouLost ( LostVictory ) ;
37357: LD_STRING LostVictory
37359: PPUSH
37360: CALL_OW 104
// exit ;
37364: GO 38064
// end ; m1 := false ;
37366: LD_ADDR_VAR 0 1
37370: PUSH
37371: LD_INT 0
37373: ST_TO_ADDR
// m2 := false ;
37374: LD_ADDR_VAR 0 2
37378: PUSH
37379: LD_INT 0
37381: ST_TO_ADDR
// m3 := false ;
37382: LD_ADDR_VAR 0 3
37386: PUSH
37387: LD_INT 0
37389: ST_TO_ADDR
// if not bombExploded then
37390: LD_EXP 37
37394: NOT
37395: IFFALSE 37404
// SetAchievement ( ACH_SIBROCKET ) ;
37397: LD_STRING ACH_SIBROCKET
37399: PPUSH
37400: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37404: LD_EXP 66
37408: PPUSH
37409: CALL_OW 255
37413: PUSH
37414: LD_INT 1
37416: EQUAL
37417: IFFALSE 37430
37419: PUSH
37420: LD_EXP 66
37424: PPUSH
37425: CALL_OW 302
37429: AND
37430: IFFALSE 37446
// begin wait ( 3 ) ;
37432: LD_INT 3
37434: PPUSH
37435: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37439: LD_STRING ACH_OPO
37441: PPUSH
37442: CALL_OW 543
// end ; if tick <= 120 120$00 then
37446: LD_OWVAR 1
37450: PUSH
37451: LD_INT 252000
37453: LESSEQUAL
37454: IFFALSE 37470
// begin wait ( 3 ) ;
37456: LD_INT 3
37458: PPUSH
37459: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37463: LD_STRING ACH_ASPEED_15
37465: PPUSH
37466: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37470: LD_EXP 40
37474: PPUSH
37475: CALL_OW 87
// music_class := 5 ;
37479: LD_ADDR_OWVAR 72
37483: PUSH
37484: LD_INT 5
37486: ST_TO_ADDR
// music_nat := 5 ;
37487: LD_ADDR_OWVAR 71
37491: PUSH
37492: LD_INT 5
37494: ST_TO_ADDR
// DialogueOn ;
37495: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37499: LD_EXP 40
37503: PPUSH
37504: LD_STRING D20-JMM-1
37506: PPUSH
37507: CALL_OW 88
// if IsOK ( Joan ) then
37511: LD_EXP 41
37515: PPUSH
37516: CALL_OW 302
37520: IFFALSE 37534
// Say ( Joan , D20-Joan-1 ) ;
37522: LD_EXP 41
37526: PPUSH
37527: LD_STRING D20-Joan-1
37529: PPUSH
37530: CALL_OW 88
// if IsOk ( Lisa ) then
37534: LD_EXP 43
37538: PPUSH
37539: CALL_OW 302
37543: IFFALSE 37557
// Say ( Lisa , D20-Lisa-1 ) ;
37545: LD_EXP 43
37549: PPUSH
37550: LD_STRING D20-Lisa-1
37552: PPUSH
37553: CALL_OW 88
// if IsOk ( Donaldson ) then
37557: LD_EXP 44
37561: PPUSH
37562: CALL_OW 302
37566: IFFALSE 37580
// Say ( Donaldson , D20-Don-1 ) ;
37568: LD_EXP 44
37572: PPUSH
37573: LD_STRING D20-Don-1
37575: PPUSH
37576: CALL_OW 88
// if IsOK ( Cornel ) then
37580: LD_EXP 51
37584: PPUSH
37585: CALL_OW 302
37589: IFFALSE 37603
// Say ( Cornel , D20-Corn-1 ) ;
37591: LD_EXP 51
37595: PPUSH
37596: LD_STRING D20-Corn-1
37598: PPUSH
37599: CALL_OW 88
// if IsOk ( Denis ) then
37603: LD_EXP 47
37607: PPUSH
37608: CALL_OW 302
37612: IFFALSE 37626
// Say ( Denis , D20-Den-1 ) ;
37614: LD_EXP 47
37618: PPUSH
37619: LD_STRING D20-Den-1
37621: PPUSH
37622: CALL_OW 88
// if IsOk ( Bobby ) then
37626: LD_EXP 45
37630: PPUSH
37631: CALL_OW 302
37635: IFFALSE 37649
// Say ( Bobby , D20-Bobby-1 ) ;
37637: LD_EXP 45
37641: PPUSH
37642: LD_STRING D20-Bobby-1
37644: PPUSH
37645: CALL_OW 88
// if IsOk ( Gladstone ) then
37649: LD_EXP 49
37653: PPUSH
37654: CALL_OW 302
37658: IFFALSE 37672
// Say ( Gladstone , D20-Glad-1 ) ;
37660: LD_EXP 49
37664: PPUSH
37665: LD_STRING D20-Glad-1
37667: PPUSH
37668: CALL_OW 88
// if IsOk ( Cyrus ) then
37672: LD_EXP 46
37676: PPUSH
37677: CALL_OW 302
37681: IFFALSE 37695
// Say ( Cyrus , D20-Cyrus-1 ) ;
37683: LD_EXP 46
37687: PPUSH
37688: LD_STRING D20-Cyrus-1
37690: PPUSH
37691: CALL_OW 88
// if IsOk ( Stevens ) then
37695: LD_EXP 42
37699: PPUSH
37700: CALL_OW 302
37704: IFFALSE 37718
// Say ( Stevens , D20-Huck-1 ) ;
37706: LD_EXP 42
37710: PPUSH
37711: LD_STRING D20-Huck-1
37713: PPUSH
37714: CALL_OW 88
// if IsOk ( Brown ) then
37718: LD_EXP 48
37722: PPUSH
37723: CALL_OW 302
37727: IFFALSE 37741
// Say ( Brown , D20-Brown-1 ) ;
37729: LD_EXP 48
37733: PPUSH
37734: LD_STRING D20-Brown-1
37736: PPUSH
37737: CALL_OW 88
// if IsOk ( Gary ) then
37741: LD_EXP 52
37745: PPUSH
37746: CALL_OW 302
37750: IFFALSE 37764
// Say ( Gary , D20-Gary-1 ) ;
37752: LD_EXP 52
37756: PPUSH
37757: LD_STRING D20-Gary-1
37759: PPUSH
37760: CALL_OW 88
// if IsOk ( Connie ) then
37764: LD_EXP 55
37768: PPUSH
37769: CALL_OW 302
37773: IFFALSE 37787
// Say ( Connie , D20-Con-1 ) ;
37775: LD_EXP 55
37779: PPUSH
37780: LD_STRING D20-Con-1
37782: PPUSH
37783: CALL_OW 88
// if IsOk ( Kurt ) then
37787: LD_EXP 64
37791: PPUSH
37792: CALL_OW 302
37796: IFFALSE 37810
// Say ( Kurt , D20-Kurt-1 ) ;
37798: LD_EXP 64
37802: PPUSH
37803: LD_STRING D20-Kurt-1
37805: PPUSH
37806: CALL_OW 88
// if IsOk ( Kikuchi ) then
37810: LD_EXP 54
37814: PPUSH
37815: CALL_OW 302
37819: IFFALSE 37833
// Say ( Kikuchi , D20-Yam-1 ) ;
37821: LD_EXP 54
37825: PPUSH
37826: LD_STRING D20-Yam-1
37828: PPUSH
37829: CALL_OW 88
// if IsOk ( Frank ) then
37833: LD_EXP 53
37837: PPUSH
37838: CALL_OW 302
37842: IFFALSE 37856
// Say ( Frank , D20-Frank-1 ) ;
37844: LD_EXP 53
37848: PPUSH
37849: LD_STRING D20-Frank-1
37851: PPUSH
37852: CALL_OW 88
// DialogueOff ;
37856: CALL_OW 7
// if RothCaptured then
37860: LD_EXP 33
37864: IFFALSE 37886
// begin m1 := true ;
37866: LD_ADDR_VAR 0 1
37870: PUSH
37871: LD_INT 1
37873: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37874: LD_STRING Roth
37876: PPUSH
37877: LD_INT 1
37879: PPUSH
37880: CALL_OW 101
// end else
37884: GO 37897
// AddMedal ( Roth , - 1 ) ;
37886: LD_STRING Roth
37888: PPUSH
37889: LD_INT 1
37891: NEG
37892: PPUSH
37893: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37897: LD_EXP 25
37901: NOT
37902: IFTRUE 37910
37904: PUSH
37905: LD_EXP 27
37909: OR
37910: IFTRUE 37919
37912: PUSH
37913: LD_EXP 28
37917: NOT
37918: OR
37919: IFFALSE 37941
// begin m2 := true ;
37921: LD_ADDR_VAR 0 2
37925: PUSH
37926: LD_INT 1
37928: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37929: LD_STRING Project
37931: PPUSH
37932: LD_INT 1
37934: PPUSH
37935: CALL_OW 101
// end else
37939: GO 37952
// AddMedal ( Project , - 1 ) ;
37941: LD_STRING Project
37943: PPUSH
37944: LD_INT 1
37946: NEG
37947: PPUSH
37948: CALL_OW 101
// if lostCounter = 0 then
37952: LD_EXP 32
37956: PUSH
37957: LD_INT 0
37959: EQUAL
37960: IFFALSE 37982
// begin m3 := true ;
37962: LD_ADDR_VAR 0 3
37966: PUSH
37967: LD_INT 1
37969: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37970: LD_STRING NoLosses
37972: PPUSH
37973: LD_INT 1
37975: PPUSH
37976: CALL_OW 101
// end else
37980: GO 37993
// AddMedal ( NoLosses , - 1 ) ;
37982: LD_STRING NoLosses
37984: PPUSH
37985: LD_INT 1
37987: NEG
37988: PPUSH
37989: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37993: LD_VAR 0 1
37997: IFFALSE 38005
37999: PUSH
38000: LD_VAR 0 2
38004: AND
38005: IFFALSE 38013
38007: PUSH
38008: LD_VAR 0 3
38012: AND
38013: IFFALSE 38025
38015: PUSH
38016: LD_OWVAR 67
38020: PUSH
38021: LD_INT 3
38023: GREATEREQUAL
38024: AND
38025: IFFALSE 38037
// SetAchievementEX ( ACH_AMER , 15 ) ;
38027: LD_STRING ACH_AMER
38029: PPUSH
38030: LD_INT 15
38032: PPUSH
38033: CALL_OW 564
// GiveMedals ( MAIN ) ;
38037: LD_STRING MAIN
38039: PPUSH
38040: CALL_OW 102
// music_class := 4 ;
38044: LD_ADDR_OWVAR 72
38048: PUSH
38049: LD_INT 4
38051: ST_TO_ADDR
// music_nat := 1 ;
38052: LD_ADDR_OWVAR 71
38056: PUSH
38057: LD_INT 1
38059: ST_TO_ADDR
// YouWin ;
38060: CALL_OW 103
// end ; end_of_file
38064: PPOPN 3
38066: END
// export function CustomEvent ( event ) ; begin
38067: LD_INT 0
38069: PPUSH
// end ;
38070: LD_VAR 0 2
38074: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
38075: LD_VAR 0 1
38079: PUSH
38080: LD_INT 1
38082: EQUAL
38083: IFFALSE 38095
38085: PUSH
38086: LD_VAR 0 2
38090: PUSH
38091: LD_INT 4
38093: EQUAL
38094: AND
38095: IFFALSE 38108
38097: PUSH
38098: LD_EXP 61
38102: PPUSH
38103: CALL_OW 300
38107: AND
38108: IFFALSE 38124
// begin wait ( 0 0$2 ) ;
38110: LD_INT 70
38112: PPUSH
38113: CALL_OW 67
// YouLost ( Dismissed ) ;
38117: LD_STRING Dismissed
38119: PPUSH
38120: CALL_OW 104
// end ; end ;
38124: PPOPN 2
38126: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
38127: LD_VAR 0 2
38131: PPUSH
38132: LD_VAR 0 3
38136: PPUSH
38137: LD_INT 18
38139: PPUSH
38140: CALL_OW 309
38144: IFFALSE 38153
// YouLost ( Motherlode3 ) ;
38146: LD_STRING Motherlode3
38148: PPUSH
38149: CALL_OW 104
// end ;
38153: PPOPN 3
38155: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
38156: LD_EXP 27
38160: NOT
38161: IFFALSE 38171
// behemothDone := true ;
38163: LD_ADDR_EXP 28
38167: PUSH
38168: LD_INT 1
38170: ST_TO_ADDR
// end ;
38171: PPOPN 1
38173: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
38174: LD_VAR 0 1
38178: PPUSH
38179: CALL_OW 255
38183: PUSH
38184: LD_INT 1
38186: EQUAL
38187: IFFALSE 38197
// bombExploded := true ;
38189: LD_ADDR_EXP 37
38193: PUSH
38194: LD_INT 1
38196: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
38197: LD_VAR 0 1
38201: PPUSH
38202: CALL_OW 255
38206: PUSH
38207: LD_INT 3
38209: EQUAL
38210: IFFALSE 38240
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
38212: LD_INT 2
38214: PPUSH
38215: LD_INT 23
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: LD_INT 48
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: PPUSH
38236: CALL 64415 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
38240: LD_VAR 0 1
38244: PPUSH
38245: CALL_OW 255
38249: PUSH
38250: LD_INT 1
38252: EQUAL
38253: IFFALSE 38270
38255: PUSH
38256: LD_EXP 66
38260: PPUSH
38261: CALL_OW 255
38265: PUSH
38266: LD_INT 1
38268: EQUAL
38269: AND
38270: IFFALSE 38283
38272: PUSH
38273: LD_EXP 66
38277: PPUSH
38278: CALL_OW 302
38282: AND
38283: IFFALSE 38291
38285: PUSH
38286: LD_EXP 30
38290: AND
38291: IFFALSE 38323
38293: PUSH
38294: LD_INT 22
38296: PUSH
38297: LD_INT 3
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 34
38306: PUSH
38307: LD_INT 48
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PPUSH
38318: CALL_OW 69
38322: AND
38323: IFFALSE 38356
38325: PUSH
38326: LD_INT 22
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 34
38338: PUSH
38339: LD_INT 8
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PPUSH
38350: CALL_OW 69
38354: NOT
38355: AND
38356: IFFALSE 38408
// begin wait ( 0 0$5 ) ;
38358: LD_INT 175
38360: PPUSH
38361: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38365: LD_INT 22
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 34
38377: PUSH
38378: LD_INT 48
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PPUSH
38389: CALL_OW 69
38393: PUSH
38394: LD_INT 1
38396: ARRAY
38397: PPUSH
38398: LD_INT 60
38400: PPUSH
38401: LD_INT 95
38403: PPUSH
38404: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38408: LD_VAR 0 2
38412: PPUSH
38413: LD_VAR 0 3
38417: PPUSH
38418: LD_INT 18
38420: PPUSH
38421: CALL_OW 309
38425: IFTRUE 38446
38427: PUSH
38428: LD_VAR 0 2
38432: PPUSH
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_INT 18
38440: PPUSH
38441: CALL 113080 0 3
38445: OR
38446: IFFALSE 38493
// begin if GetSide ( unit ) = 1 then
38448: LD_VAR 0 1
38452: PPUSH
38453: CALL_OW 255
38457: PUSH
38458: LD_INT 1
38460: EQUAL
38461: IFFALSE 38479
// begin wait ( 0 0$6 ) ;
38463: LD_INT 210
38465: PPUSH
38466: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38470: LD_STRING Motherlode2
38472: PPUSH
38473: CALL_OW 104
// end else
38477: GO 38493
// begin wait ( 0 0$6 ) ;
38479: LD_INT 210
38481: PPUSH
38482: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38486: LD_STRING Motherlode1
38488: PPUSH
38489: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38493: LD_VAR 0 1
38497: PPUSH
38498: CALL_OW 255
38502: PUSH
38503: LD_INT 3
38505: EQUAL
38506: IFFALSE 38527
// begin wait ( 0 0$5 ) ;
38508: LD_INT 175
38510: PPUSH
38511: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38515: LD_EXP 68
38519: PPUSH
38520: LD_STRING D18-Pla-1
38522: PPUSH
38523: CALL_OW 94
// end ; end ;
38527: PPOPN 3
38529: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38530: LD_VAR 0 1
38534: PPUSH
38535: CALL 130528 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 22
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 21
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 23
38566: PUSH
38567: LD_INT 1
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: PPUSH
38579: CALL_OW 69
38583: IN
38584: IFFALSE 38600
// lostCounter := lostCounter + 1 ;
38586: LD_ADDR_EXP 32
38590: PUSH
38591: LD_EXP 32
38595: PUSH
38596: LD_INT 1
38598: PLUS
38599: ST_TO_ADDR
// if un in behemothBuilders then
38600: LD_VAR 0 1
38604: PUSH
38605: LD_EXP 77
38609: IN
38610: IFFALSE 38630
// begin behemothBuilders := behemothBuilders diff un ;
38612: LD_ADDR_EXP 77
38616: PUSH
38617: LD_EXP 77
38621: PUSH
38622: LD_VAR 0 1
38626: DIFF
38627: ST_TO_ADDR
// exit ;
38628: GO 38660
// end ; if un = JMM then
38630: LD_VAR 0 1
38634: PUSH
38635: LD_EXP 40
38639: EQUAL
38640: IFFALSE 38651
// begin YouLost ( JMM ) ;
38642: LD_STRING JMM
38644: PPUSH
38645: CALL_OW 104
// exit ;
38649: GO 38660
// end ; MCE_UnitDestroyed ( un ) ;
38651: LD_VAR 0 1
38655: PPUSH
38656: CALL 67921 0 1
// end ;
38660: PPOPN 1
38662: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38663: LD_VAR 0 1
38667: PPUSH
38668: LD_VAR 0 2
38672: PPUSH
38673: CALL 70275 0 2
// end ;
38677: PPOPN 2
38679: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38680: LD_VAR 0 1
38684: PPUSH
38685: CALL 69339 0 1
// end ;
38689: PPOPN 1
38691: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 22
38699: PUSH
38700: LD_INT 8
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 30
38709: PUSH
38710: LD_INT 2
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 23
38719: PUSH
38720: LD_INT 3
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: PPUSH
38732: CALL_OW 69
38736: IN
38737: IFFALSE 38764
// begin ComUpgrade ( building ) ;
38739: LD_VAR 0 1
38743: PPUSH
38744: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38748: LD_EXP 65
38752: PPUSH
38753: LD_VAR 0 1
38757: PPUSH
38758: CALL 79299 0 2
// exit ;
38762: GO 38773
// end ; MCE_BuildingComplete ( building ) ;
38764: LD_VAR 0 1
38768: PPUSH
38769: CALL 69582 0 1
// end ;
38773: PPOPN 1
38775: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38776: LD_VAR 0 1
38780: PPUSH
38781: LD_VAR 0 2
38785: PPUSH
38786: CALL 67609 0 2
// end ;
38790: PPOPN 2
38792: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38793: LD_VAR 0 1
38797: PPUSH
38798: LD_VAR 0 2
38802: PPUSH
38803: LD_VAR 0 3
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_VAR 0 5
38817: PPUSH
38818: CALL 67227 0 5
// end ;
38822: PPOPN 5
38824: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38825: LD_VAR 0 1
38829: PPUSH
38830: CALL_OW 255
38834: PUSH
38835: LD_INT 1
38837: EQUAL
38838: IFFALSE 38855
// amConstructCounter := Inc ( amConstructCounter ) ;
38840: LD_ADDR_EXP 39
38844: PUSH
38845: LD_EXP 39
38849: PPUSH
38850: CALL 110468 0 1
38854: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38855: LD_VAR 0 1
38859: PPUSH
38860: LD_VAR 0 2
38864: PPUSH
38865: CALL 130586 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38869: LD_VAR 0 1
38873: PPUSH
38874: LD_VAR 0 2
38878: PPUSH
38879: CALL 66776 0 2
// end ;
38883: PPOPN 2
38885: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38886: LD_VAR 0 1
38890: PPUSH
38891: LD_VAR 0 2
38895: PPUSH
38896: LD_VAR 0 3
38900: PPUSH
38901: LD_VAR 0 4
38905: PPUSH
38906: CALL 66608 0 4
// end ;
38910: PPOPN 4
38912: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38913: LD_VAR 0 1
38917: PPUSH
38918: LD_VAR 0 2
38922: PPUSH
38923: LD_VAR 0 3
38927: PPUSH
38928: CALL 66381 0 3
// end ;
38932: PPOPN 3
38934: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38935: LD_VAR 0 1
38939: PPUSH
38940: LD_VAR 0 2
38944: PPUSH
38945: CALL 66264 0 2
// end ;
38949: PPOPN 2
38951: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38952: LD_VAR 0 1
38956: PPUSH
38957: LD_VAR 0 2
38961: PPUSH
38962: CALL 70572 0 2
// end ;
38966: PPOPN 2
38968: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38969: LD_VAR 0 1
38973: PUSH
38974: LD_INT 460
38976: EQUAL
38977: IFFALSE 38999
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38979: LD_VAR 0 2
38983: PPUSH
38984: LD_INT 227
38986: PPUSH
38987: LD_INT 136
38989: PPUSH
38990: CALL_OW 428
38994: PPUSH
38995: CALL_OW 120
// end ;
38999: PPOPN 2
39001: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
39002: LD_VAR 0 1
39006: PPUSH
39007: CALL_OW 255
39011: PUSH
39012: LD_INT 4
39014: EQUAL
39015: IFFALSE 39033
39017: PUSH
39018: LD_VAR 0 1
39022: PUSH
39023: LD_EXP 18
39027: PUSH
39028: LD_INT 1
39030: ARRAY
39031: IN
39032: AND
39033: IFFALSE 39041
39035: PUSH
39036: LD_EXP 19
39040: AND
39041: IFFALSE 39060
// begin ComMoveXY ( driver , 61 , 93 ) ;
39043: LD_VAR 0 1
39047: PPUSH
39048: LD_INT 61
39050: PPUSH
39051: LD_INT 93
39053: PPUSH
39054: CALL_OW 111
// exit ;
39058: GO 39131
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
39060: LD_VAR 0 1
39064: PPUSH
39065: CALL_OW 255
39069: PUSH
39070: LD_INT 3
39072: EQUAL
39073: IFFALSE 39090
39075: PUSH
39076: LD_VAR 0 1
39080: PPUSH
39081: CALL_OW 110
39085: PUSH
39086: LD_INT 105
39088: EQUAL
39089: AND
39090: IFFALSE 39107
// begin ComMoveXY ( driver , 187 , 92 ) ;
39092: LD_VAR 0 1
39096: PPUSH
39097: LD_INT 187
39099: PPUSH
39100: LD_INT 92
39102: PPUSH
39103: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
39107: LD_VAR 0 1
39111: PPUSH
39112: LD_VAR 0 2
39116: PPUSH
39117: LD_VAR 0 3
39121: PPUSH
39122: LD_VAR 0 4
39126: PPUSH
39127: CALL 70796 0 4
// end ;
39131: PPOPN 4
39133: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
39134: LD_VAR 0 1
39138: PPUSH
39139: LD_VAR 0 2
39143: PPUSH
39144: CALL 66071 0 2
// end ;
39148: PPOPN 2
39150: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
39151: LD_VAR 0 1
39155: PPUSH
39156: CALL 130570 0 1
// end ; end_of_file
39160: PPOPN 1
39162: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
39163: LD_EXP 15
39167: PUSH
39168: LD_INT 2
39170: EQUAL
39171: IFFALSE 39688
39173: GO 39175
39175: DISABLE
39176: LD_INT 0
39178: PPUSH
39179: PPUSH
// begin time := 0 0$35 ;
39180: LD_ADDR_VAR 0 2
39184: PUSH
39185: LD_INT 1225
39187: ST_TO_ADDR
// repeat wait ( time ) ;
39188: LD_VAR 0 2
39192: PPUSH
39193: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
39197: LD_INT 1
39199: PPUSH
39200: LD_INT 5
39202: PPUSH
39203: CALL_OW 12
39207: PPUSH
39208: LD_INT 106
39210: PPUSH
39211: LD_INT 150
39213: PPUSH
39214: LD_INT 19
39216: PPUSH
39217: LD_INT 1
39219: PPUSH
39220: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
39224: LD_INT 455
39226: PPUSH
39227: LD_INT 770
39229: PPUSH
39230: CALL_OW 12
39234: PPUSH
39235: CALL_OW 67
// if Prob ( 50 ) then
39239: LD_INT 50
39241: PPUSH
39242: CALL_OW 13
39246: IFFALSE 39275
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
39248: LD_INT 1
39250: PPUSH
39251: LD_INT 5
39253: PPUSH
39254: CALL_OW 12
39258: PPUSH
39259: LD_INT 62
39261: PPUSH
39262: LD_INT 108
39264: PPUSH
39265: LD_INT 10
39267: PPUSH
39268: LD_INT 1
39270: PPUSH
39271: CALL_OW 56
// until missionStage > 4 ;
39275: LD_EXP 15
39279: PUSH
39280: LD_INT 4
39282: GREATER
39283: IFFALSE 39188
// repeat wait ( 0 0$1 ) ;
39285: LD_INT 35
39287: PPUSH
39288: CALL_OW 67
// until missionStage = 6 ;
39292: LD_EXP 15
39296: PUSH
39297: LD_INT 6
39299: EQUAL
39300: IFFALSE 39285
// time := 0 0$20 ;
39302: LD_ADDR_VAR 0 2
39306: PUSH
39307: LD_INT 700
39309: ST_TO_ADDR
// repeat wait ( time ) ;
39310: LD_VAR 0 2
39314: PPUSH
39315: CALL_OW 67
// if Prob ( 90 ) then
39319: LD_INT 90
39321: PPUSH
39322: CALL_OW 13
39326: IFFALSE 39369
// begin time := time + 0 0$2 ;
39328: LD_ADDR_VAR 0 2
39332: PUSH
39333: LD_VAR 0 2
39337: PUSH
39338: LD_INT 70
39340: PLUS
39341: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39342: LD_INT 1
39344: PPUSH
39345: LD_INT 5
39347: PPUSH
39348: CALL_OW 12
39352: PPUSH
39353: LD_INT 106
39355: PPUSH
39356: LD_INT 89
39358: PPUSH
39359: LD_INT 45
39361: PPUSH
39362: LD_INT 1
39364: PPUSH
39365: CALL_OW 56
// end ; if Prob ( 45 ) then
39369: LD_INT 45
39371: PPUSH
39372: CALL_OW 13
39376: IFFALSE 39432
// begin for i := 1 to 4 do
39378: LD_ADDR_VAR 0 1
39382: PUSH
39383: DOUBLE
39384: LD_INT 1
39386: DEC
39387: ST_TO_ADDR
39388: LD_INT 4
39390: PUSH
39391: FOR_TO
39392: IFFALSE 39430
// begin wait ( 0 0$5 ) ;
39394: LD_INT 175
39396: PPUSH
39397: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39401: LD_INT 1
39403: PPUSH
39404: LD_INT 5
39406: PPUSH
39407: CALL_OW 12
39411: PPUSH
39412: LD_INT 113
39414: PPUSH
39415: LD_INT 117
39417: PPUSH
39418: LD_INT 25
39420: PPUSH
39421: LD_INT 1
39423: PPUSH
39424: CALL_OW 56
// end ;
39428: GO 39391
39430: POP
39431: POP
// end ; if Prob ( 40 ) then
39432: LD_INT 40
39434: PPUSH
39435: CALL_OW 13
39439: IFFALSE 39485
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39441: LD_INT 385
39443: PPUSH
39444: LD_INT 945
39446: PPUSH
39447: CALL_OW 12
39451: PPUSH
39452: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39456: LD_INT 1
39458: PPUSH
39459: LD_INT 5
39461: PPUSH
39462: CALL_OW 12
39466: PPUSH
39467: LD_INT 21
39469: PPUSH
39470: LD_INT 26
39472: PPUSH
39473: LD_INT 12
39475: PPUSH
39476: LD_INT 1
39478: PPUSH
39479: CALL_OW 56
// end else
39483: GO 39521
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39485: LD_INT 700
39487: PPUSH
39488: LD_INT 1225
39490: PPUSH
39491: CALL_OW 12
39495: PPUSH
39496: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39500: LD_INT 1
39502: PPUSH
39503: LD_INT 5
39505: PPUSH
39506: CALL_OW 12
39510: PPUSH
39511: LD_INT 16
39513: PPUSH
39514: LD_INT 1
39516: PPUSH
39517: CALL_OW 55
// end ; if Prob ( 50 ) then
39521: LD_INT 50
39523: PPUSH
39524: CALL_OW 13
39528: IFFALSE 39574
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39530: LD_INT 700
39532: PPUSH
39533: LD_INT 1050
39535: PPUSH
39536: CALL_OW 12
39540: PPUSH
39541: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39545: LD_INT 1
39547: PPUSH
39548: LD_INT 5
39550: PPUSH
39551: CALL_OW 12
39555: PPUSH
39556: LD_INT 168
39558: PPUSH
39559: LD_INT 168
39561: PPUSH
39562: LD_INT 16
39564: PPUSH
39565: LD_INT 1
39567: PPUSH
39568: CALL_OW 56
// end else
39572: GO 39610
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39574: LD_INT 350
39576: PPUSH
39577: LD_INT 525
39579: PPUSH
39580: CALL_OW 12
39584: PPUSH
39585: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39589: LD_INT 1
39591: PPUSH
39592: LD_INT 5
39594: PPUSH
39595: CALL_OW 12
39599: PPUSH
39600: LD_INT 15
39602: PPUSH
39603: LD_INT 1
39605: PPUSH
39606: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39610: LD_INT 175
39612: PPUSH
39613: LD_INT 315
39615: PPUSH
39616: CALL_OW 12
39620: PPUSH
39621: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39625: LD_INT 1
39627: PPUSH
39628: LD_INT 5
39630: PPUSH
39631: CALL_OW 12
39635: PPUSH
39636: LD_INT 103
39638: PPUSH
39639: LD_INT 140
39641: PPUSH
39642: LD_INT 20
39644: PPUSH
39645: LD_INT 1
39647: PPUSH
39648: CALL_OW 56
// time := time + 0 0$2 ;
39652: LD_ADDR_VAR 0 2
39656: PUSH
39657: LD_VAR 0 2
39661: PUSH
39662: LD_INT 70
39664: PLUS
39665: ST_TO_ADDR
// if time > 1 1$20 then
39666: LD_VAR 0 2
39670: PUSH
39671: LD_INT 2800
39673: GREATER
39674: IFFALSE 39684
// time := 0 0$30 ;
39676: LD_ADDR_VAR 0 2
39680: PUSH
39681: LD_INT 1050
39683: ST_TO_ADDR
// until false ;
39684: LD_INT 0
39686: IFFALSE 39310
// end ; end_of_file
39688: PPOPN 2
39690: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39691: LD_EXP 13
39695: IFFALSE 39707
39697: PUSH
39698: LD_EXP 15
39702: PUSH
39703: LD_INT 6
39705: GREATEREQUAL
39706: AND
39707: IFFALSE 39744
39709: GO 39711
39711: DISABLE
// begin enable ;
39712: ENABLE
// missionTime := missionTime + 0 0$1 ;
39713: LD_ADDR_EXP 14
39717: PUSH
39718: LD_EXP 14
39722: PUSH
39723: LD_INT 35
39725: PLUS
39726: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39727: LD_ADDR_OWVAR 47
39731: PUSH
39732: LD_STRING #Am15-1
39734: PUSH
39735: LD_EXP 14
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: ST_TO_ADDR
// end ; end_of_file
39744: END
// export function InitNature ; begin
39745: LD_INT 0
39747: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39748: LD_INT 3
39750: PPUSH
39751: LD_INT 3
39753: PPUSH
39754: LD_INT 2
39756: PPUSH
39757: LD_INT 1
39759: PPUSH
39760: LD_INT 1
39762: PPUSH
39763: LD_INT 0
39765: PPUSH
39766: LD_INT 0
39768: PPUSH
39769: LD_INT 20
39771: PPUSH
39772: LD_INT 0
39774: PPUSH
39775: CALL 105746 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39779: LD_INT 2
39781: PPUSH
39782: LD_INT 1
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: LD_INT 1
39790: PPUSH
39791: LD_INT 1
39793: PPUSH
39794: LD_INT 0
39796: PPUSH
39797: LD_INT 0
39799: PPUSH
39800: LD_INT 21
39802: PPUSH
39803: LD_INT 0
39805: PPUSH
39806: CALL 105746 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39810: LD_INT 4
39812: PPUSH
39813: LD_INT 1
39815: PPUSH
39816: LD_INT 2
39818: PPUSH
39819: LD_INT 4
39821: PPUSH
39822: LD_INT 2
39824: PPUSH
39825: LD_INT 1
39827: PPUSH
39828: LD_INT 0
39830: PPUSH
39831: LD_INT 22
39833: PPUSH
39834: LD_INT 0
39836: PPUSH
39837: CALL 105746 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39841: LD_INT 0
39843: PPUSH
39844: LD_INT 0
39846: PPUSH
39847: LD_INT 0
39849: PPUSH
39850: LD_INT 0
39852: PPUSH
39853: LD_INT 0
39855: PPUSH
39856: LD_INT 0
39858: PPUSH
39859: LD_INT 9
39861: PPUSH
39862: LD_INT 0
39864: PPUSH
39865: LD_INT 23
39867: PPUSH
39868: CALL 105746 0 9
// end ; end_of_file
39872: LD_VAR 0 1
39876: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39877: LD_INT 0
39879: PPUSH
39880: PPUSH
// skirmish := false ;
39881: LD_ADDR_EXP 100
39885: PUSH
39886: LD_INT 0
39888: ST_TO_ADDR
// debug_mc := false ;
39889: LD_ADDR_EXP 101
39893: PUSH
39894: LD_INT 0
39896: ST_TO_ADDR
// mc_bases := [ ] ;
39897: LD_ADDR_EXP 102
39901: PUSH
39902: EMPTY
39903: ST_TO_ADDR
// mc_sides := [ ] ;
39904: LD_ADDR_EXP 128
39908: PUSH
39909: EMPTY
39910: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39911: LD_ADDR_EXP 103
39915: PUSH
39916: EMPTY
39917: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39918: LD_ADDR_EXP 104
39922: PUSH
39923: EMPTY
39924: ST_TO_ADDR
// mc_need_heal := [ ] ;
39925: LD_ADDR_EXP 105
39929: PUSH
39930: EMPTY
39931: ST_TO_ADDR
// mc_healers := [ ] ;
39932: LD_ADDR_EXP 106
39936: PUSH
39937: EMPTY
39938: ST_TO_ADDR
// mc_build_list := [ ] ;
39939: LD_ADDR_EXP 107
39943: PUSH
39944: EMPTY
39945: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39946: LD_ADDR_EXP 134
39950: PUSH
39951: EMPTY
39952: ST_TO_ADDR
// mc_builders := [ ] ;
39953: LD_ADDR_EXP 108
39957: PUSH
39958: EMPTY
39959: ST_TO_ADDR
// mc_construct_list := [ ] ;
39960: LD_ADDR_EXP 109
39964: PUSH
39965: EMPTY
39966: ST_TO_ADDR
// mc_turret_list := [ ] ;
39967: LD_ADDR_EXP 110
39971: PUSH
39972: EMPTY
39973: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39974: LD_ADDR_EXP 111
39978: PUSH
39979: EMPTY
39980: ST_TO_ADDR
// mc_miners := [ ] ;
39981: LD_ADDR_EXP 116
39985: PUSH
39986: EMPTY
39987: ST_TO_ADDR
// mc_mines := [ ] ;
39988: LD_ADDR_EXP 115
39992: PUSH
39993: EMPTY
39994: ST_TO_ADDR
// mc_minefields := [ ] ;
39995: LD_ADDR_EXP 117
39999: PUSH
40000: EMPTY
40001: ST_TO_ADDR
// mc_crates := [ ] ;
40002: LD_ADDR_EXP 118
40006: PUSH
40007: EMPTY
40008: ST_TO_ADDR
// mc_crates_collector := [ ] ;
40009: LD_ADDR_EXP 119
40013: PUSH
40014: EMPTY
40015: ST_TO_ADDR
// mc_crates_area := [ ] ;
40016: LD_ADDR_EXP 120
40020: PUSH
40021: EMPTY
40022: ST_TO_ADDR
// mc_vehicles := [ ] ;
40023: LD_ADDR_EXP 121
40027: PUSH
40028: EMPTY
40029: ST_TO_ADDR
// mc_attack := [ ] ;
40030: LD_ADDR_EXP 122
40034: PUSH
40035: EMPTY
40036: ST_TO_ADDR
// mc_produce := [ ] ;
40037: LD_ADDR_EXP 123
40041: PUSH
40042: EMPTY
40043: ST_TO_ADDR
// mc_defender := [ ] ;
40044: LD_ADDR_EXP 124
40048: PUSH
40049: EMPTY
40050: ST_TO_ADDR
// mc_parking := [ ] ;
40051: LD_ADDR_EXP 126
40055: PUSH
40056: EMPTY
40057: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
40058: LD_ADDR_EXP 112
40062: PUSH
40063: EMPTY
40064: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
40065: LD_ADDR_EXP 114
40069: PUSH
40070: EMPTY
40071: ST_TO_ADDR
// mc_scan := [ ] ;
40072: LD_ADDR_EXP 125
40076: PUSH
40077: EMPTY
40078: ST_TO_ADDR
// mc_scan_area := [ ] ;
40079: LD_ADDR_EXP 127
40083: PUSH
40084: EMPTY
40085: ST_TO_ADDR
// mc_tech := [ ] ;
40086: LD_ADDR_EXP 129
40090: PUSH
40091: EMPTY
40092: ST_TO_ADDR
// mc_class := [ ] ;
40093: LD_ADDR_EXP 143
40097: PUSH
40098: EMPTY
40099: ST_TO_ADDR
// mc_class_case_use := [ ] ;
40100: LD_ADDR_EXP 144
40104: PUSH
40105: EMPTY
40106: ST_TO_ADDR
// mc_is_defending := [ ] ;
40107: LD_ADDR_EXP 145
40111: PUSH
40112: EMPTY
40113: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
40114: LD_ADDR_EXP 136
40118: PUSH
40119: EMPTY
40120: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
40121: LD_ADDR_EXP 146
40125: PUSH
40126: LD_INT 0
40128: ST_TO_ADDR
// end ;
40129: LD_VAR 0 1
40133: RET
// export function MC_Kill ( base ) ; begin
40134: LD_INT 0
40136: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
40137: LD_ADDR_EXP 102
40141: PUSH
40142: LD_EXP 102
40146: PPUSH
40147: LD_VAR 0 1
40151: PPUSH
40152: EMPTY
40153: PPUSH
40154: CALL_OW 1
40158: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40159: LD_ADDR_EXP 103
40163: PUSH
40164: LD_EXP 103
40168: PPUSH
40169: LD_VAR 0 1
40173: PPUSH
40174: EMPTY
40175: PPUSH
40176: CALL_OW 1
40180: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40181: LD_ADDR_EXP 104
40185: PUSH
40186: LD_EXP 104
40190: PPUSH
40191: LD_VAR 0 1
40195: PPUSH
40196: EMPTY
40197: PPUSH
40198: CALL_OW 1
40202: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40203: LD_ADDR_EXP 105
40207: PUSH
40208: LD_EXP 105
40212: PPUSH
40213: LD_VAR 0 1
40217: PPUSH
40218: EMPTY
40219: PPUSH
40220: CALL_OW 1
40224: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40225: LD_ADDR_EXP 106
40229: PUSH
40230: LD_EXP 106
40234: PPUSH
40235: LD_VAR 0 1
40239: PPUSH
40240: EMPTY
40241: PPUSH
40242: CALL_OW 1
40246: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40247: LD_ADDR_EXP 107
40251: PUSH
40252: LD_EXP 107
40256: PPUSH
40257: LD_VAR 0 1
40261: PPUSH
40262: EMPTY
40263: PPUSH
40264: CALL_OW 1
40268: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40269: LD_ADDR_EXP 108
40273: PUSH
40274: LD_EXP 108
40278: PPUSH
40279: LD_VAR 0 1
40283: PPUSH
40284: EMPTY
40285: PPUSH
40286: CALL_OW 1
40290: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40291: LD_ADDR_EXP 109
40295: PUSH
40296: LD_EXP 109
40300: PPUSH
40301: LD_VAR 0 1
40305: PPUSH
40306: EMPTY
40307: PPUSH
40308: CALL_OW 1
40312: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40313: LD_ADDR_EXP 110
40317: PUSH
40318: LD_EXP 110
40322: PPUSH
40323: LD_VAR 0 1
40327: PPUSH
40328: EMPTY
40329: PPUSH
40330: CALL_OW 1
40334: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40335: LD_ADDR_EXP 111
40339: PUSH
40340: LD_EXP 111
40344: PPUSH
40345: LD_VAR 0 1
40349: PPUSH
40350: EMPTY
40351: PPUSH
40352: CALL_OW 1
40356: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40357: LD_ADDR_EXP 112
40361: PUSH
40362: LD_EXP 112
40366: PPUSH
40367: LD_VAR 0 1
40371: PPUSH
40372: EMPTY
40373: PPUSH
40374: CALL_OW 1
40378: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40379: LD_ADDR_EXP 113
40383: PUSH
40384: LD_EXP 113
40388: PPUSH
40389: LD_VAR 0 1
40393: PPUSH
40394: LD_INT 0
40396: PPUSH
40397: CALL_OW 1
40401: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40402: LD_ADDR_EXP 114
40406: PUSH
40407: LD_EXP 114
40411: PPUSH
40412: LD_VAR 0 1
40416: PPUSH
40417: EMPTY
40418: PPUSH
40419: CALL_OW 1
40423: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40424: LD_ADDR_EXP 115
40428: PUSH
40429: LD_EXP 115
40433: PPUSH
40434: LD_VAR 0 1
40438: PPUSH
40439: EMPTY
40440: PPUSH
40441: CALL_OW 1
40445: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40446: LD_ADDR_EXP 116
40450: PUSH
40451: LD_EXP 116
40455: PPUSH
40456: LD_VAR 0 1
40460: PPUSH
40461: EMPTY
40462: PPUSH
40463: CALL_OW 1
40467: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40468: LD_ADDR_EXP 117
40472: PUSH
40473: LD_EXP 117
40477: PPUSH
40478: LD_VAR 0 1
40482: PPUSH
40483: EMPTY
40484: PPUSH
40485: CALL_OW 1
40489: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40490: LD_ADDR_EXP 118
40494: PUSH
40495: LD_EXP 118
40499: PPUSH
40500: LD_VAR 0 1
40504: PPUSH
40505: EMPTY
40506: PPUSH
40507: CALL_OW 1
40511: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40512: LD_ADDR_EXP 119
40516: PUSH
40517: LD_EXP 119
40521: PPUSH
40522: LD_VAR 0 1
40526: PPUSH
40527: EMPTY
40528: PPUSH
40529: CALL_OW 1
40533: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40534: LD_ADDR_EXP 120
40538: PUSH
40539: LD_EXP 120
40543: PPUSH
40544: LD_VAR 0 1
40548: PPUSH
40549: EMPTY
40550: PPUSH
40551: CALL_OW 1
40555: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40556: LD_ADDR_EXP 121
40560: PUSH
40561: LD_EXP 121
40565: PPUSH
40566: LD_VAR 0 1
40570: PPUSH
40571: EMPTY
40572: PPUSH
40573: CALL_OW 1
40577: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40578: LD_ADDR_EXP 122
40582: PUSH
40583: LD_EXP 122
40587: PPUSH
40588: LD_VAR 0 1
40592: PPUSH
40593: EMPTY
40594: PPUSH
40595: CALL_OW 1
40599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40600: LD_ADDR_EXP 123
40604: PUSH
40605: LD_EXP 123
40609: PPUSH
40610: LD_VAR 0 1
40614: PPUSH
40615: EMPTY
40616: PPUSH
40617: CALL_OW 1
40621: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40622: LD_ADDR_EXP 124
40626: PUSH
40627: LD_EXP 124
40631: PPUSH
40632: LD_VAR 0 1
40636: PPUSH
40637: EMPTY
40638: PPUSH
40639: CALL_OW 1
40643: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40644: LD_ADDR_EXP 125
40648: PUSH
40649: LD_EXP 125
40653: PPUSH
40654: LD_VAR 0 1
40658: PPUSH
40659: EMPTY
40660: PPUSH
40661: CALL_OW 1
40665: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40666: LD_ADDR_EXP 126
40670: PUSH
40671: LD_EXP 126
40675: PPUSH
40676: LD_VAR 0 1
40680: PPUSH
40681: EMPTY
40682: PPUSH
40683: CALL_OW 1
40687: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40688: LD_ADDR_EXP 127
40692: PUSH
40693: LD_EXP 127
40697: PPUSH
40698: LD_VAR 0 1
40702: PPUSH
40703: EMPTY
40704: PPUSH
40705: CALL_OW 1
40709: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40710: LD_ADDR_EXP 129
40714: PUSH
40715: LD_EXP 129
40719: PPUSH
40720: LD_VAR 0 1
40724: PPUSH
40725: EMPTY
40726: PPUSH
40727: CALL_OW 1
40731: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40732: LD_ADDR_EXP 131
40736: PUSH
40737: LD_EXP 131
40741: PPUSH
40742: LD_VAR 0 1
40746: PPUSH
40747: EMPTY
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40754: LD_ADDR_EXP 132
40758: PUSH
40759: LD_EXP 132
40763: PPUSH
40764: LD_VAR 0 1
40768: PPUSH
40769: EMPTY
40770: PPUSH
40771: CALL_OW 1
40775: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40776: LD_ADDR_EXP 133
40780: PUSH
40781: LD_EXP 133
40785: PPUSH
40786: LD_VAR 0 1
40790: PPUSH
40791: EMPTY
40792: PPUSH
40793: CALL_OW 1
40797: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40798: LD_ADDR_EXP 134
40802: PUSH
40803: LD_EXP 134
40807: PPUSH
40808: LD_VAR 0 1
40812: PPUSH
40813: EMPTY
40814: PPUSH
40815: CALL_OW 1
40819: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40820: LD_ADDR_EXP 135
40824: PUSH
40825: LD_EXP 135
40829: PPUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: EMPTY
40836: PPUSH
40837: CALL_OW 1
40841: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40842: LD_ADDR_EXP 136
40846: PUSH
40847: LD_EXP 136
40851: PPUSH
40852: LD_VAR 0 1
40856: PPUSH
40857: EMPTY
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40864: LD_ADDR_EXP 137
40868: PUSH
40869: LD_EXP 137
40873: PPUSH
40874: LD_VAR 0 1
40878: PPUSH
40879: EMPTY
40880: PPUSH
40881: CALL_OW 1
40885: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40886: LD_ADDR_EXP 138
40890: PUSH
40891: LD_EXP 138
40895: PPUSH
40896: LD_VAR 0 1
40900: PPUSH
40901: EMPTY
40902: PPUSH
40903: CALL_OW 1
40907: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40908: LD_ADDR_EXP 139
40912: PUSH
40913: LD_EXP 139
40917: PPUSH
40918: LD_VAR 0 1
40922: PPUSH
40923: EMPTY
40924: PPUSH
40925: CALL_OW 1
40929: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40930: LD_ADDR_EXP 140
40934: PUSH
40935: LD_EXP 140
40939: PPUSH
40940: LD_VAR 0 1
40944: PPUSH
40945: EMPTY
40946: PPUSH
40947: CALL_OW 1
40951: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40952: LD_ADDR_EXP 141
40956: PUSH
40957: LD_EXP 141
40961: PPUSH
40962: LD_VAR 0 1
40966: PPUSH
40967: EMPTY
40968: PPUSH
40969: CALL_OW 1
40973: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40974: LD_ADDR_EXP 142
40978: PUSH
40979: LD_EXP 142
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: EMPTY
40990: PPUSH
40991: CALL_OW 1
40995: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40996: LD_ADDR_EXP 143
41000: PUSH
41001: LD_EXP 143
41005: PPUSH
41006: LD_VAR 0 1
41010: PPUSH
41011: EMPTY
41012: PPUSH
41013: CALL_OW 1
41017: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41018: LD_ADDR_EXP 144
41022: PUSH
41023: LD_EXP 144
41027: PPUSH
41028: LD_VAR 0 1
41032: PPUSH
41033: LD_INT 0
41035: PPUSH
41036: CALL_OW 1
41040: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41041: LD_ADDR_EXP 145
41045: PUSH
41046: LD_EXP 145
41050: PPUSH
41051: LD_VAR 0 1
41055: PPUSH
41056: LD_INT 0
41058: PPUSH
41059: CALL_OW 1
41063: ST_TO_ADDR
// end ;
41064: LD_VAR 0 2
41068: RET
// export function MC_Add ( side , units ) ; var base ; begin
41069: LD_INT 0
41071: PPUSH
41072: PPUSH
// base := mc_bases + 1 ;
41073: LD_ADDR_VAR 0 4
41077: PUSH
41078: LD_EXP 102
41082: PUSH
41083: LD_INT 1
41085: PLUS
41086: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
41087: LD_ADDR_EXP 128
41091: PUSH
41092: LD_EXP 128
41096: PPUSH
41097: LD_VAR 0 4
41101: PPUSH
41102: LD_VAR 0 1
41106: PPUSH
41107: CALL_OW 1
41111: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
41112: LD_ADDR_EXP 102
41116: PUSH
41117: LD_EXP 102
41121: PPUSH
41122: LD_VAR 0 4
41126: PPUSH
41127: LD_VAR 0 2
41131: PPUSH
41132: CALL_OW 1
41136: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41137: LD_ADDR_EXP 103
41141: PUSH
41142: LD_EXP 103
41146: PPUSH
41147: LD_VAR 0 4
41151: PPUSH
41152: EMPTY
41153: PPUSH
41154: CALL_OW 1
41158: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41159: LD_ADDR_EXP 104
41163: PUSH
41164: LD_EXP 104
41168: PPUSH
41169: LD_VAR 0 4
41173: PPUSH
41174: EMPTY
41175: PPUSH
41176: CALL_OW 1
41180: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41181: LD_ADDR_EXP 105
41185: PUSH
41186: LD_EXP 105
41190: PPUSH
41191: LD_VAR 0 4
41195: PPUSH
41196: EMPTY
41197: PPUSH
41198: CALL_OW 1
41202: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41203: LD_ADDR_EXP 106
41207: PUSH
41208: LD_EXP 106
41212: PPUSH
41213: LD_VAR 0 4
41217: PPUSH
41218: EMPTY
41219: PPUSH
41220: CALL_OW 1
41224: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41225: LD_ADDR_EXP 107
41229: PUSH
41230: LD_EXP 107
41234: PPUSH
41235: LD_VAR 0 4
41239: PPUSH
41240: EMPTY
41241: PPUSH
41242: CALL_OW 1
41246: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41247: LD_ADDR_EXP 108
41251: PUSH
41252: LD_EXP 108
41256: PPUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: EMPTY
41263: PPUSH
41264: CALL_OW 1
41268: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41269: LD_ADDR_EXP 109
41273: PUSH
41274: LD_EXP 109
41278: PPUSH
41279: LD_VAR 0 4
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41291: LD_ADDR_EXP 110
41295: PUSH
41296: LD_EXP 110
41300: PPUSH
41301: LD_VAR 0 4
41305: PPUSH
41306: EMPTY
41307: PPUSH
41308: CALL_OW 1
41312: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41313: LD_ADDR_EXP 111
41317: PUSH
41318: LD_EXP 111
41322: PPUSH
41323: LD_VAR 0 4
41327: PPUSH
41328: EMPTY
41329: PPUSH
41330: CALL_OW 1
41334: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41335: LD_ADDR_EXP 112
41339: PUSH
41340: LD_EXP 112
41344: PPUSH
41345: LD_VAR 0 4
41349: PPUSH
41350: EMPTY
41351: PPUSH
41352: CALL_OW 1
41356: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41357: LD_ADDR_EXP 113
41361: PUSH
41362: LD_EXP 113
41366: PPUSH
41367: LD_VAR 0 4
41371: PPUSH
41372: LD_INT 0
41374: PPUSH
41375: CALL_OW 1
41379: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41380: LD_ADDR_EXP 114
41384: PUSH
41385: LD_EXP 114
41389: PPUSH
41390: LD_VAR 0 4
41394: PPUSH
41395: EMPTY
41396: PPUSH
41397: CALL_OW 1
41401: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41402: LD_ADDR_EXP 115
41406: PUSH
41407: LD_EXP 115
41411: PPUSH
41412: LD_VAR 0 4
41416: PPUSH
41417: EMPTY
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41424: LD_ADDR_EXP 116
41428: PUSH
41429: LD_EXP 116
41433: PPUSH
41434: LD_VAR 0 4
41438: PPUSH
41439: EMPTY
41440: PPUSH
41441: CALL_OW 1
41445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41446: LD_ADDR_EXP 117
41450: PUSH
41451: LD_EXP 117
41455: PPUSH
41456: LD_VAR 0 4
41460: PPUSH
41461: EMPTY
41462: PPUSH
41463: CALL_OW 1
41467: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41468: LD_ADDR_EXP 118
41472: PUSH
41473: LD_EXP 118
41477: PPUSH
41478: LD_VAR 0 4
41482: PPUSH
41483: EMPTY
41484: PPUSH
41485: CALL_OW 1
41489: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41490: LD_ADDR_EXP 119
41494: PUSH
41495: LD_EXP 119
41499: PPUSH
41500: LD_VAR 0 4
41504: PPUSH
41505: EMPTY
41506: PPUSH
41507: CALL_OW 1
41511: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41512: LD_ADDR_EXP 120
41516: PUSH
41517: LD_EXP 120
41521: PPUSH
41522: LD_VAR 0 4
41526: PPUSH
41527: EMPTY
41528: PPUSH
41529: CALL_OW 1
41533: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41534: LD_ADDR_EXP 121
41538: PUSH
41539: LD_EXP 121
41543: PPUSH
41544: LD_VAR 0 4
41548: PPUSH
41549: EMPTY
41550: PPUSH
41551: CALL_OW 1
41555: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41556: LD_ADDR_EXP 122
41560: PUSH
41561: LD_EXP 122
41565: PPUSH
41566: LD_VAR 0 4
41570: PPUSH
41571: EMPTY
41572: PPUSH
41573: CALL_OW 1
41577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41578: LD_ADDR_EXP 123
41582: PUSH
41583: LD_EXP 123
41587: PPUSH
41588: LD_VAR 0 4
41592: PPUSH
41593: EMPTY
41594: PPUSH
41595: CALL_OW 1
41599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41600: LD_ADDR_EXP 124
41604: PUSH
41605: LD_EXP 124
41609: PPUSH
41610: LD_VAR 0 4
41614: PPUSH
41615: EMPTY
41616: PPUSH
41617: CALL_OW 1
41621: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41622: LD_ADDR_EXP 125
41626: PUSH
41627: LD_EXP 125
41631: PPUSH
41632: LD_VAR 0 4
41636: PPUSH
41637: EMPTY
41638: PPUSH
41639: CALL_OW 1
41643: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41644: LD_ADDR_EXP 126
41648: PUSH
41649: LD_EXP 126
41653: PPUSH
41654: LD_VAR 0 4
41658: PPUSH
41659: EMPTY
41660: PPUSH
41661: CALL_OW 1
41665: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41666: LD_ADDR_EXP 127
41670: PUSH
41671: LD_EXP 127
41675: PPUSH
41676: LD_VAR 0 4
41680: PPUSH
41681: EMPTY
41682: PPUSH
41683: CALL_OW 1
41687: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41688: LD_ADDR_EXP 129
41692: PUSH
41693: LD_EXP 129
41697: PPUSH
41698: LD_VAR 0 4
41702: PPUSH
41703: EMPTY
41704: PPUSH
41705: CALL_OW 1
41709: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41710: LD_ADDR_EXP 131
41714: PUSH
41715: LD_EXP 131
41719: PPUSH
41720: LD_VAR 0 4
41724: PPUSH
41725: EMPTY
41726: PPUSH
41727: CALL_OW 1
41731: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41732: LD_ADDR_EXP 132
41736: PUSH
41737: LD_EXP 132
41741: PPUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: EMPTY
41748: PPUSH
41749: CALL_OW 1
41753: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41754: LD_ADDR_EXP 133
41758: PUSH
41759: LD_EXP 133
41763: PPUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: EMPTY
41770: PPUSH
41771: CALL_OW 1
41775: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41776: LD_ADDR_EXP 134
41780: PUSH
41781: LD_EXP 134
41785: PPUSH
41786: LD_VAR 0 4
41790: PPUSH
41791: EMPTY
41792: PPUSH
41793: CALL_OW 1
41797: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41798: LD_ADDR_EXP 135
41802: PUSH
41803: LD_EXP 135
41807: PPUSH
41808: LD_VAR 0 4
41812: PPUSH
41813: EMPTY
41814: PPUSH
41815: CALL_OW 1
41819: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41820: LD_ADDR_EXP 136
41824: PUSH
41825: LD_EXP 136
41829: PPUSH
41830: LD_VAR 0 4
41834: PPUSH
41835: EMPTY
41836: PPUSH
41837: CALL_OW 1
41841: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41842: LD_ADDR_EXP 137
41846: PUSH
41847: LD_EXP 137
41851: PPUSH
41852: LD_VAR 0 4
41856: PPUSH
41857: EMPTY
41858: PPUSH
41859: CALL_OW 1
41863: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41864: LD_ADDR_EXP 138
41868: PUSH
41869: LD_EXP 138
41873: PPUSH
41874: LD_VAR 0 4
41878: PPUSH
41879: EMPTY
41880: PPUSH
41881: CALL_OW 1
41885: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41886: LD_ADDR_EXP 139
41890: PUSH
41891: LD_EXP 139
41895: PPUSH
41896: LD_VAR 0 4
41900: PPUSH
41901: EMPTY
41902: PPUSH
41903: CALL_OW 1
41907: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41908: LD_ADDR_EXP 140
41912: PUSH
41913: LD_EXP 140
41917: PPUSH
41918: LD_VAR 0 4
41922: PPUSH
41923: EMPTY
41924: PPUSH
41925: CALL_OW 1
41929: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41930: LD_ADDR_EXP 141
41934: PUSH
41935: LD_EXP 141
41939: PPUSH
41940: LD_VAR 0 4
41944: PPUSH
41945: EMPTY
41946: PPUSH
41947: CALL_OW 1
41951: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41952: LD_ADDR_EXP 142
41956: PUSH
41957: LD_EXP 142
41961: PPUSH
41962: LD_VAR 0 4
41966: PPUSH
41967: EMPTY
41968: PPUSH
41969: CALL_OW 1
41973: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41974: LD_ADDR_EXP 143
41978: PUSH
41979: LD_EXP 143
41983: PPUSH
41984: LD_VAR 0 4
41988: PPUSH
41989: EMPTY
41990: PPUSH
41991: CALL_OW 1
41995: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41996: LD_ADDR_EXP 144
42000: PUSH
42001: LD_EXP 144
42005: PPUSH
42006: LD_VAR 0 4
42010: PPUSH
42011: LD_INT 0
42013: PPUSH
42014: CALL_OW 1
42018: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
42019: LD_ADDR_EXP 145
42023: PUSH
42024: LD_EXP 145
42028: PPUSH
42029: LD_VAR 0 4
42033: PPUSH
42034: LD_INT 0
42036: PPUSH
42037: CALL_OW 1
42041: ST_TO_ADDR
// result := base ;
42042: LD_ADDR_VAR 0 3
42046: PUSH
42047: LD_VAR 0 4
42051: ST_TO_ADDR
// end ;
42052: LD_VAR 0 3
42056: RET
// export function MC_Start ( ) ; var i ; begin
42057: LD_INT 0
42059: PPUSH
42060: PPUSH
// for i = 1 to mc_bases do
42061: LD_ADDR_VAR 0 2
42065: PUSH
42066: DOUBLE
42067: LD_INT 1
42069: DEC
42070: ST_TO_ADDR
42071: LD_EXP 102
42075: PUSH
42076: FOR_TO
42077: IFFALSE 43177
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
42079: LD_ADDR_EXP 102
42083: PUSH
42084: LD_EXP 102
42088: PPUSH
42089: LD_VAR 0 2
42093: PPUSH
42094: LD_EXP 102
42098: PUSH
42099: LD_VAR 0 2
42103: ARRAY
42104: PUSH
42105: LD_INT 0
42107: DIFF
42108: PPUSH
42109: CALL_OW 1
42113: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
42114: LD_ADDR_EXP 103
42118: PUSH
42119: LD_EXP 103
42123: PPUSH
42124: LD_VAR 0 2
42128: PPUSH
42129: EMPTY
42130: PPUSH
42131: CALL_OW 1
42135: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42136: LD_ADDR_EXP 104
42140: PUSH
42141: LD_EXP 104
42145: PPUSH
42146: LD_VAR 0 2
42150: PPUSH
42151: EMPTY
42152: PPUSH
42153: CALL_OW 1
42157: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
42158: LD_ADDR_EXP 105
42162: PUSH
42163: LD_EXP 105
42167: PPUSH
42168: LD_VAR 0 2
42172: PPUSH
42173: EMPTY
42174: PPUSH
42175: CALL_OW 1
42179: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
42180: LD_ADDR_EXP 106
42184: PUSH
42185: LD_EXP 106
42189: PPUSH
42190: LD_VAR 0 2
42194: PPUSH
42195: EMPTY
42196: PUSH
42197: EMPTY
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PPUSH
42203: CALL_OW 1
42207: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
42208: LD_ADDR_EXP 107
42212: PUSH
42213: LD_EXP 107
42217: PPUSH
42218: LD_VAR 0 2
42222: PPUSH
42223: EMPTY
42224: PPUSH
42225: CALL_OW 1
42229: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
42230: LD_ADDR_EXP 134
42234: PUSH
42235: LD_EXP 134
42239: PPUSH
42240: LD_VAR 0 2
42244: PPUSH
42245: EMPTY
42246: PPUSH
42247: CALL_OW 1
42251: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
42252: LD_ADDR_EXP 108
42256: PUSH
42257: LD_EXP 108
42261: PPUSH
42262: LD_VAR 0 2
42266: PPUSH
42267: EMPTY
42268: PPUSH
42269: CALL_OW 1
42273: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
42274: LD_ADDR_EXP 109
42278: PUSH
42279: LD_EXP 109
42283: PPUSH
42284: LD_VAR 0 2
42288: PPUSH
42289: EMPTY
42290: PPUSH
42291: CALL_OW 1
42295: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
42296: LD_ADDR_EXP 110
42300: PUSH
42301: LD_EXP 110
42305: PPUSH
42306: LD_VAR 0 2
42310: PPUSH
42311: LD_EXP 102
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: PPUSH
42322: LD_INT 2
42324: PUSH
42325: LD_INT 30
42327: PUSH
42328: LD_INT 32
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 30
42337: PUSH
42338: LD_INT 33
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: PPUSH
42350: CALL_OW 72
42354: PPUSH
42355: CALL_OW 1
42359: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42360: LD_ADDR_EXP 111
42364: PUSH
42365: LD_EXP 111
42369: PPUSH
42370: LD_VAR 0 2
42374: PPUSH
42375: LD_EXP 102
42379: PUSH
42380: LD_VAR 0 2
42384: ARRAY
42385: PPUSH
42386: LD_INT 2
42388: PUSH
42389: LD_INT 30
42391: PUSH
42392: LD_INT 32
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 30
42401: PUSH
42402: LD_INT 31
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 58
42416: PUSH
42417: EMPTY
42418: LIST
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PPUSH
42424: CALL_OW 72
42428: PPUSH
42429: CALL_OW 1
42433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42434: LD_ADDR_EXP 112
42438: PUSH
42439: LD_EXP 112
42443: PPUSH
42444: LD_VAR 0 2
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL_OW 1
42455: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42456: LD_ADDR_EXP 116
42460: PUSH
42461: LD_EXP 116
42465: PPUSH
42466: LD_VAR 0 2
42470: PPUSH
42471: EMPTY
42472: PPUSH
42473: CALL_OW 1
42477: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42478: LD_ADDR_EXP 115
42482: PUSH
42483: LD_EXP 115
42487: PPUSH
42488: LD_VAR 0 2
42492: PPUSH
42493: EMPTY
42494: PPUSH
42495: CALL_OW 1
42499: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42500: LD_ADDR_EXP 117
42504: PUSH
42505: LD_EXP 117
42509: PPUSH
42510: LD_VAR 0 2
42514: PPUSH
42515: EMPTY
42516: PPUSH
42517: CALL_OW 1
42521: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42522: LD_ADDR_EXP 118
42526: PUSH
42527: LD_EXP 118
42531: PPUSH
42532: LD_VAR 0 2
42536: PPUSH
42537: EMPTY
42538: PPUSH
42539: CALL_OW 1
42543: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42544: LD_ADDR_EXP 119
42548: PUSH
42549: LD_EXP 119
42553: PPUSH
42554: LD_VAR 0 2
42558: PPUSH
42559: EMPTY
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42566: LD_ADDR_EXP 120
42570: PUSH
42571: LD_EXP 120
42575: PPUSH
42576: LD_VAR 0 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42588: LD_ADDR_EXP 121
42592: PUSH
42593: LD_EXP 121
42597: PPUSH
42598: LD_VAR 0 2
42602: PPUSH
42603: EMPTY
42604: PPUSH
42605: CALL_OW 1
42609: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42610: LD_ADDR_EXP 122
42614: PUSH
42615: LD_EXP 122
42619: PPUSH
42620: LD_VAR 0 2
42624: PPUSH
42625: EMPTY
42626: PPUSH
42627: CALL_OW 1
42631: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42632: LD_ADDR_EXP 123
42636: PUSH
42637: LD_EXP 123
42641: PPUSH
42642: LD_VAR 0 2
42646: PPUSH
42647: EMPTY
42648: PPUSH
42649: CALL_OW 1
42653: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42654: LD_ADDR_EXP 124
42658: PUSH
42659: LD_EXP 124
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: EMPTY
42670: PPUSH
42671: CALL_OW 1
42675: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42676: LD_ADDR_EXP 113
42680: PUSH
42681: LD_EXP 113
42685: PPUSH
42686: LD_VAR 0 2
42690: PPUSH
42691: LD_INT 0
42693: PPUSH
42694: CALL_OW 1
42698: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42699: LD_ADDR_EXP 126
42703: PUSH
42704: LD_EXP 126
42708: PPUSH
42709: LD_VAR 0 2
42713: PPUSH
42714: LD_INT 0
42716: PPUSH
42717: CALL_OW 1
42721: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42722: LD_ADDR_EXP 114
42726: PUSH
42727: LD_EXP 114
42731: PPUSH
42732: LD_VAR 0 2
42736: PPUSH
42737: EMPTY
42738: PPUSH
42739: CALL_OW 1
42743: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42744: LD_ADDR_EXP 125
42748: PUSH
42749: LD_EXP 125
42753: PPUSH
42754: LD_VAR 0 2
42758: PPUSH
42759: LD_INT 0
42761: PPUSH
42762: CALL_OW 1
42766: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42767: LD_ADDR_EXP 127
42771: PUSH
42772: LD_EXP 127
42776: PPUSH
42777: LD_VAR 0 2
42781: PPUSH
42782: EMPTY
42783: PPUSH
42784: CALL_OW 1
42788: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42789: LD_ADDR_EXP 130
42793: PUSH
42794: LD_EXP 130
42798: PPUSH
42799: LD_VAR 0 2
42803: PPUSH
42804: LD_INT 0
42806: PPUSH
42807: CALL_OW 1
42811: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42812: LD_ADDR_EXP 131
42816: PUSH
42817: LD_EXP 131
42821: PPUSH
42822: LD_VAR 0 2
42826: PPUSH
42827: EMPTY
42828: PPUSH
42829: CALL_OW 1
42833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42834: LD_ADDR_EXP 132
42838: PUSH
42839: LD_EXP 132
42843: PPUSH
42844: LD_VAR 0 2
42848: PPUSH
42849: EMPTY
42850: PPUSH
42851: CALL_OW 1
42855: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42856: LD_ADDR_EXP 133
42860: PUSH
42861: LD_EXP 133
42865: PPUSH
42866: LD_VAR 0 2
42870: PPUSH
42871: EMPTY
42872: PPUSH
42873: CALL_OW 1
42877: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42878: LD_ADDR_EXP 135
42882: PUSH
42883: LD_EXP 135
42887: PPUSH
42888: LD_VAR 0 2
42892: PPUSH
42893: LD_EXP 102
42897: PUSH
42898: LD_VAR 0 2
42902: ARRAY
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 6
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 7
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 30
42929: PUSH
42930: LD_INT 8
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: PPUSH
42943: CALL_OW 72
42947: PPUSH
42948: CALL_OW 1
42952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42953: LD_ADDR_EXP 136
42957: PUSH
42958: LD_EXP 136
42962: PPUSH
42963: LD_VAR 0 2
42967: PPUSH
42968: EMPTY
42969: PPUSH
42970: CALL_OW 1
42974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42975: LD_ADDR_EXP 137
42979: PUSH
42980: LD_EXP 137
42984: PPUSH
42985: LD_VAR 0 2
42989: PPUSH
42990: EMPTY
42991: PPUSH
42992: CALL_OW 1
42996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42997: LD_ADDR_EXP 138
43001: PUSH
43002: LD_EXP 138
43006: PPUSH
43007: LD_VAR 0 2
43011: PPUSH
43012: EMPTY
43013: PPUSH
43014: CALL_OW 1
43018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
43019: LD_ADDR_EXP 139
43023: PUSH
43024: LD_EXP 139
43028: PPUSH
43029: LD_VAR 0 2
43033: PPUSH
43034: EMPTY
43035: PPUSH
43036: CALL_OW 1
43040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43041: LD_ADDR_EXP 140
43045: PUSH
43046: LD_EXP 140
43050: PPUSH
43051: LD_VAR 0 2
43055: PPUSH
43056: EMPTY
43057: PPUSH
43058: CALL_OW 1
43062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
43063: LD_ADDR_EXP 141
43067: PUSH
43068: LD_EXP 141
43072: PPUSH
43073: LD_VAR 0 2
43077: PPUSH
43078: EMPTY
43079: PPUSH
43080: CALL_OW 1
43084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
43085: LD_ADDR_EXP 142
43089: PUSH
43090: LD_EXP 142
43094: PPUSH
43095: LD_VAR 0 2
43099: PPUSH
43100: EMPTY
43101: PPUSH
43102: CALL_OW 1
43106: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
43107: LD_ADDR_EXP 143
43111: PUSH
43112: LD_EXP 143
43116: PPUSH
43117: LD_VAR 0 2
43121: PPUSH
43122: EMPTY
43123: PPUSH
43124: CALL_OW 1
43128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
43129: LD_ADDR_EXP 144
43133: PUSH
43134: LD_EXP 144
43138: PPUSH
43139: LD_VAR 0 2
43143: PPUSH
43144: LD_INT 0
43146: PPUSH
43147: CALL_OW 1
43151: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
43152: LD_ADDR_EXP 145
43156: PUSH
43157: LD_EXP 145
43161: PPUSH
43162: LD_VAR 0 2
43166: PPUSH
43167: LD_INT 0
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// end ;
43175: GO 42076
43177: POP
43178: POP
// MC_InitSides ( ) ;
43179: CALL 43465 0 0
// MC_InitResearch ( ) ;
43183: CALL 43204 0 0
// CustomInitMacro ( ) ;
43187: CALL 475 0 0
// skirmish := true ;
43191: LD_ADDR_EXP 100
43195: PUSH
43196: LD_INT 1
43198: ST_TO_ADDR
// end ;
43199: LD_VAR 0 1
43203: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
43204: LD_INT 0
43206: PPUSH
43207: PPUSH
43208: PPUSH
43209: PPUSH
43210: PPUSH
43211: PPUSH
// if not mc_bases then
43212: LD_EXP 102
43216: NOT
43217: IFFALSE 43221
// exit ;
43219: GO 43460
// for i = 1 to 8 do
43221: LD_ADDR_VAR 0 2
43225: PUSH
43226: DOUBLE
43227: LD_INT 1
43229: DEC
43230: ST_TO_ADDR
43231: LD_INT 8
43233: PUSH
43234: FOR_TO
43235: IFFALSE 43261
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
43237: LD_ADDR_EXP 129
43241: PUSH
43242: LD_EXP 129
43246: PPUSH
43247: LD_VAR 0 2
43251: PPUSH
43252: EMPTY
43253: PPUSH
43254: CALL_OW 1
43258: ST_TO_ADDR
43259: GO 43234
43261: POP
43262: POP
// tmp := [ ] ;
43263: LD_ADDR_VAR 0 5
43267: PUSH
43268: EMPTY
43269: ST_TO_ADDR
// for i = 1 to mc_sides do
43270: LD_ADDR_VAR 0 2
43274: PUSH
43275: DOUBLE
43276: LD_INT 1
43278: DEC
43279: ST_TO_ADDR
43280: LD_EXP 128
43284: PUSH
43285: FOR_TO
43286: IFFALSE 43344
// if not mc_sides [ i ] in tmp then
43288: LD_EXP 128
43292: PUSH
43293: LD_VAR 0 2
43297: ARRAY
43298: PUSH
43299: LD_VAR 0 5
43303: IN
43304: NOT
43305: IFFALSE 43342
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43307: LD_ADDR_VAR 0 5
43311: PUSH
43312: LD_VAR 0 5
43316: PPUSH
43317: LD_VAR 0 5
43321: PUSH
43322: LD_INT 1
43324: PLUS
43325: PPUSH
43326: LD_EXP 128
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: PPUSH
43337: CALL_OW 2
43341: ST_TO_ADDR
43342: GO 43285
43344: POP
43345: POP
// if not tmp then
43346: LD_VAR 0 5
43350: NOT
43351: IFFALSE 43355
// exit ;
43353: GO 43460
// for j in tmp do
43355: LD_ADDR_VAR 0 3
43359: PUSH
43360: LD_VAR 0 5
43364: PUSH
43365: FOR_IN
43366: IFFALSE 43458
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43368: LD_ADDR_VAR 0 6
43372: PUSH
43373: LD_INT 22
43375: PUSH
43376: LD_VAR 0 3
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PPUSH
43385: CALL_OW 69
43389: ST_TO_ADDR
// if not un then
43390: LD_VAR 0 6
43394: NOT
43395: IFFALSE 43399
// continue ;
43397: GO 43365
// nation := GetNation ( un [ 1 ] ) ;
43399: LD_ADDR_VAR 0 4
43403: PUSH
43404: LD_VAR 0 6
43408: PUSH
43409: LD_INT 1
43411: ARRAY
43412: PPUSH
43413: CALL_OW 248
43417: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43418: LD_ADDR_EXP 129
43422: PUSH
43423: LD_EXP 129
43427: PPUSH
43428: LD_VAR 0 3
43432: PPUSH
43433: LD_VAR 0 3
43437: PPUSH
43438: LD_VAR 0 4
43442: PPUSH
43443: LD_INT 1
43445: PPUSH
43446: CALL 71086 0 3
43450: PPUSH
43451: CALL_OW 1
43455: ST_TO_ADDR
// end ;
43456: GO 43365
43458: POP
43459: POP
// end ;
43460: LD_VAR 0 1
43464: RET
// export function MC_InitSides ( ) ; var i ; begin
43465: LD_INT 0
43467: PPUSH
43468: PPUSH
// if not mc_bases then
43469: LD_EXP 102
43473: NOT
43474: IFFALSE 43478
// exit ;
43476: GO 43552
// for i = 1 to mc_bases do
43478: LD_ADDR_VAR 0 2
43482: PUSH
43483: DOUBLE
43484: LD_INT 1
43486: DEC
43487: ST_TO_ADDR
43488: LD_EXP 102
43492: PUSH
43493: FOR_TO
43494: IFFALSE 43550
// if mc_bases [ i ] then
43496: LD_EXP 102
43500: PUSH
43501: LD_VAR 0 2
43505: ARRAY
43506: IFFALSE 43548
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43508: LD_ADDR_EXP 128
43512: PUSH
43513: LD_EXP 128
43517: PPUSH
43518: LD_VAR 0 2
43522: PPUSH
43523: LD_EXP 102
43527: PUSH
43528: LD_VAR 0 2
43532: ARRAY
43533: PUSH
43534: LD_INT 1
43536: ARRAY
43537: PPUSH
43538: CALL_OW 255
43542: PPUSH
43543: CALL_OW 1
43547: ST_TO_ADDR
43548: GO 43493
43550: POP
43551: POP
// end ;
43552: LD_VAR 0 1
43556: RET
// every 0 0$03 trigger skirmish do
43557: LD_EXP 100
43561: IFFALSE 43715
43563: GO 43565
43565: DISABLE
// begin enable ;
43566: ENABLE
// MC_CheckBuildings ( ) ;
43567: CALL 48273 0 0
// MC_CheckPeopleLife ( ) ;
43571: CALL 48434 0 0
// RaiseSailEvent ( 100 ) ;
43575: LD_INT 100
43577: PPUSH
43578: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43582: LD_INT 103
43584: PPUSH
43585: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43589: LD_INT 104
43591: PPUSH
43592: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43596: LD_INT 105
43598: PPUSH
43599: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43603: LD_INT 106
43605: PPUSH
43606: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43610: LD_INT 107
43612: PPUSH
43613: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43617: LD_INT 108
43619: PPUSH
43620: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43624: LD_INT 109
43626: PPUSH
43627: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43631: LD_INT 110
43633: PPUSH
43634: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43638: LD_INT 111
43640: PPUSH
43641: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43645: LD_INT 112
43647: PPUSH
43648: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43652: LD_INT 113
43654: PPUSH
43655: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43659: LD_INT 120
43661: PPUSH
43662: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43666: LD_INT 121
43668: PPUSH
43669: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43673: LD_INT 122
43675: PPUSH
43676: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43680: LD_INT 123
43682: PPUSH
43683: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43687: LD_INT 124
43689: PPUSH
43690: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43694: LD_INT 125
43696: PPUSH
43697: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43701: LD_INT 126
43703: PPUSH
43704: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43708: LD_INT 200
43710: PPUSH
43711: CALL_OW 427
// end ;
43715: END
// on SailEvent ( event ) do begin if event < 100 then
43716: LD_VAR 0 1
43720: PUSH
43721: LD_INT 100
43723: LESS
43724: IFFALSE 43735
// CustomEvent ( event ) ;
43726: LD_VAR 0 1
43730: PPUSH
43731: CALL 38067 0 1
// if event = 100 then
43735: LD_VAR 0 1
43739: PUSH
43740: LD_INT 100
43742: EQUAL
43743: IFFALSE 43749
// MC_ClassManager ( ) ;
43745: CALL 44143 0 0
// if event = 101 then
43749: LD_VAR 0 1
43753: PUSH
43754: LD_INT 101
43756: EQUAL
43757: IFFALSE 43763
// MC_RepairBuildings ( ) ;
43759: CALL 49021 0 0
// if event = 102 then
43763: LD_VAR 0 1
43767: PUSH
43768: LD_INT 102
43770: EQUAL
43771: IFFALSE 43777
// MC_Heal ( ) ;
43773: CALL 49960 0 0
// if event = 103 then
43777: LD_VAR 0 1
43781: PUSH
43782: LD_INT 103
43784: EQUAL
43785: IFFALSE 43791
// MC_Build ( ) ;
43787: CALL 50386 0 0
// if event = 104 then
43791: LD_VAR 0 1
43795: PUSH
43796: LD_INT 104
43798: EQUAL
43799: IFFALSE 43805
// MC_TurretWeapon ( ) ;
43801: CALL 52034 0 0
// if event = 105 then
43805: LD_VAR 0 1
43809: PUSH
43810: LD_INT 105
43812: EQUAL
43813: IFFALSE 43819
// MC_BuildUpgrade ( ) ;
43815: CALL 51579 0 0
// if event = 106 then
43819: LD_VAR 0 1
43823: PUSH
43824: LD_INT 106
43826: EQUAL
43827: IFFALSE 43833
// MC_PlantMines ( ) ;
43829: CALL 52466 0 0
// if event = 107 then
43833: LD_VAR 0 1
43837: PUSH
43838: LD_INT 107
43840: EQUAL
43841: IFFALSE 43847
// MC_CollectCrates ( ) ;
43843: CALL 53276 0 0
// if event = 108 then
43847: LD_VAR 0 1
43851: PUSH
43852: LD_INT 108
43854: EQUAL
43855: IFFALSE 43861
// MC_LinkRemoteControl ( ) ;
43857: CALL 55150 0 0
// if event = 109 then
43861: LD_VAR 0 1
43865: PUSH
43866: LD_INT 109
43868: EQUAL
43869: IFFALSE 43875
// MC_ProduceVehicle ( ) ;
43871: CALL 55335 0 0
// if event = 110 then
43875: LD_VAR 0 1
43879: PUSH
43880: LD_INT 110
43882: EQUAL
43883: IFFALSE 43889
// MC_SendAttack ( ) ;
43885: CALL 55805 0 0
// if event = 111 then
43889: LD_VAR 0 1
43893: PUSH
43894: LD_INT 111
43896: EQUAL
43897: IFFALSE 43903
// MC_Defend ( ) ;
43899: CALL 55913 0 0
// if event = 112 then
43903: LD_VAR 0 1
43907: PUSH
43908: LD_INT 112
43910: EQUAL
43911: IFFALSE 43917
// MC_Research ( ) ;
43913: CALL 56813 0 0
// if event = 113 then
43917: LD_VAR 0 1
43921: PUSH
43922: LD_INT 113
43924: EQUAL
43925: IFFALSE 43931
// MC_MinesTrigger ( ) ;
43927: CALL 57953 0 0
// if event = 120 then
43931: LD_VAR 0 1
43935: PUSH
43936: LD_INT 120
43938: EQUAL
43939: IFFALSE 43945
// MC_RepairVehicle ( ) ;
43941: CALL 58054 0 0
// if event = 121 then
43945: LD_VAR 0 1
43949: PUSH
43950: LD_INT 121
43952: EQUAL
43953: IFFALSE 43959
// MC_TameApe ( ) ;
43955: CALL 58831 0 0
// if event = 122 then
43959: LD_VAR 0 1
43963: PUSH
43964: LD_INT 122
43966: EQUAL
43967: IFFALSE 43973
// MC_ChangeApeClass ( ) ;
43969: CALL 59676 0 0
// if event = 123 then
43973: LD_VAR 0 1
43977: PUSH
43978: LD_INT 123
43980: EQUAL
43981: IFFALSE 43987
// MC_Bazooka ( ) ;
43983: CALL 60332 0 0
// if event = 124 then
43987: LD_VAR 0 1
43991: PUSH
43992: LD_INT 124
43994: EQUAL
43995: IFFALSE 44001
// MC_TeleportExit ( ) ;
43997: CALL 60534 0 0
// if event = 125 then
44001: LD_VAR 0 1
44005: PUSH
44006: LD_INT 125
44008: EQUAL
44009: IFFALSE 44015
// MC_Deposits ( ) ;
44011: CALL 61191 0 0
// if event = 126 then
44015: LD_VAR 0 1
44019: PUSH
44020: LD_INT 126
44022: EQUAL
44023: IFFALSE 44029
// MC_RemoteDriver ( ) ;
44025: CALL 61824 0 0
// if event = 200 then
44029: LD_VAR 0 1
44033: PUSH
44034: LD_INT 200
44036: EQUAL
44037: IFFALSE 44043
// MC_Idle ( ) ;
44039: CALL 63759 0 0
// end ;
44043: PPOPN 1
44045: END
// export function MC_Reset ( base , tag ) ; var i ; begin
44046: LD_INT 0
44048: PPUSH
44049: PPUSH
// if not mc_bases [ base ] or not tag then
44050: LD_EXP 102
44054: PUSH
44055: LD_VAR 0 1
44059: ARRAY
44060: NOT
44061: IFTRUE 44070
44063: PUSH
44064: LD_VAR 0 2
44068: NOT
44069: OR
44070: IFFALSE 44074
// exit ;
44072: GO 44138
// for i in mc_bases [ base ] union mc_ape [ base ] do
44074: LD_ADDR_VAR 0 4
44078: PUSH
44079: LD_EXP 102
44083: PUSH
44084: LD_VAR 0 1
44088: ARRAY
44089: PUSH
44090: LD_EXP 131
44094: PUSH
44095: LD_VAR 0 1
44099: ARRAY
44100: UNION
44101: PUSH
44102: FOR_IN
44103: IFFALSE 44136
// if GetTag ( i ) = tag then
44105: LD_VAR 0 4
44109: PPUSH
44110: CALL_OW 110
44114: PUSH
44115: LD_VAR 0 2
44119: EQUAL
44120: IFFALSE 44134
// SetTag ( i , 0 ) ;
44122: LD_VAR 0 4
44126: PPUSH
44127: LD_INT 0
44129: PPUSH
44130: CALL_OW 109
44134: GO 44102
44136: POP
44137: POP
// end ;
44138: LD_VAR 0 3
44142: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
44143: LD_INT 0
44145: PPUSH
44146: PPUSH
44147: PPUSH
44148: PPUSH
44149: PPUSH
44150: PPUSH
44151: PPUSH
44152: PPUSH
// if not mc_bases then
44153: LD_EXP 102
44157: NOT
44158: IFFALSE 44162
// exit ;
44160: GO 44613
// for i = 1 to mc_bases do
44162: LD_ADDR_VAR 0 2
44166: PUSH
44167: DOUBLE
44168: LD_INT 1
44170: DEC
44171: ST_TO_ADDR
44172: LD_EXP 102
44176: PUSH
44177: FOR_TO
44178: IFFALSE 44611
// begin tmp := MC_ClassCheckReq ( i ) ;
44180: LD_ADDR_VAR 0 4
44184: PUSH
44185: LD_VAR 0 2
44189: PPUSH
44190: CALL 44618 0 1
44194: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
44195: LD_ADDR_EXP 143
44199: PUSH
44200: LD_EXP 143
44204: PPUSH
44205: LD_VAR 0 2
44209: PPUSH
44210: LD_VAR 0 4
44214: PPUSH
44215: CALL_OW 1
44219: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
44220: LD_ADDR_VAR 0 6
44224: PUSH
44225: LD_EXP 102
44229: PUSH
44230: LD_VAR 0 2
44234: ARRAY
44235: PPUSH
44236: LD_INT 2
44238: PUSH
44239: LD_INT 30
44241: PUSH
44242: LD_INT 4
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: LD_INT 30
44251: PUSH
44252: LD_INT 5
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: LIST
44263: PPUSH
44264: CALL_OW 72
44268: PUSH
44269: LD_EXP 102
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PPUSH
44280: LD_INT 2
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 30
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: LIST
44307: PPUSH
44308: CALL_OW 72
44312: PUSH
44313: LD_EXP 102
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PPUSH
44324: LD_INT 30
44326: PUSH
44327: LD_INT 3
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PPUSH
44334: CALL_OW 72
44338: PUSH
44339: LD_EXP 102
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: PPUSH
44350: LD_INT 2
44352: PUSH
44353: LD_INT 30
44355: PUSH
44356: LD_INT 6
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 30
44365: PUSH
44366: LD_INT 7
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 30
44375: PUSH
44376: LD_INT 8
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: PPUSH
44389: CALL_OW 72
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: ST_TO_ADDR
// for j := 1 to 4 do
44400: LD_ADDR_VAR 0 3
44404: PUSH
44405: DOUBLE
44406: LD_INT 1
44408: DEC
44409: ST_TO_ADDR
44410: LD_INT 4
44412: PUSH
44413: FOR_TO
44414: IFFALSE 44607
// begin if not tmp [ j ] then
44416: LD_VAR 0 4
44420: PUSH
44421: LD_VAR 0 3
44425: ARRAY
44426: NOT
44427: IFFALSE 44431
// continue ;
44429: GO 44413
// for p in tmp [ j ] do
44431: LD_ADDR_VAR 0 5
44435: PUSH
44436: LD_VAR 0 4
44440: PUSH
44441: LD_VAR 0 3
44445: ARRAY
44446: PUSH
44447: FOR_IN
44448: IFFALSE 44603
// begin if not b [ j ] then
44450: LD_VAR 0 6
44454: PUSH
44455: LD_VAR 0 3
44459: ARRAY
44460: NOT
44461: IFFALSE 44465
// break ;
44463: GO 44603
// e := 0 ;
44465: LD_ADDR_VAR 0 7
44469: PUSH
44470: LD_INT 0
44472: ST_TO_ADDR
// for k in b [ j ] do
44473: LD_ADDR_VAR 0 8
44477: PUSH
44478: LD_VAR 0 6
44482: PUSH
44483: LD_VAR 0 3
44487: ARRAY
44488: PUSH
44489: FOR_IN
44490: IFFALSE 44517
// if IsNotFull ( k ) then
44492: LD_VAR 0 8
44496: PPUSH
44497: CALL 73245 0 1
44501: IFFALSE 44515
// begin e := k ;
44503: LD_ADDR_VAR 0 7
44507: PUSH
44508: LD_VAR 0 8
44512: ST_TO_ADDR
// break ;
44513: GO 44517
// end ;
44515: GO 44489
44517: POP
44518: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44519: LD_VAR 0 7
44523: IFFALSE 44542
44525: PUSH
44526: LD_VAR 0 5
44530: PPUSH
44531: LD_VAR 0 7
44535: PPUSH
44536: CALL 107705 0 2
44540: NOT
44541: AND
44542: IFFALSE 44601
// begin if IsInUnit ( p ) then
44544: LD_VAR 0 5
44548: PPUSH
44549: CALL_OW 310
44553: IFFALSE 44564
// ComExitBuilding ( p ) ;
44555: LD_VAR 0 5
44559: PPUSH
44560: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44564: LD_VAR 0 5
44568: PPUSH
44569: LD_VAR 0 7
44573: PPUSH
44574: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44578: LD_VAR 0 5
44582: PPUSH
44583: LD_VAR 0 3
44587: PPUSH
44588: CALL_OW 183
// AddComExitBuilding ( p ) ;
44592: LD_VAR 0 5
44596: PPUSH
44597: CALL_OW 182
// end ; end ;
44601: GO 44447
44603: POP
44604: POP
// end ;
44605: GO 44413
44607: POP
44608: POP
// end ;
44609: GO 44177
44611: POP
44612: POP
// end ;
44613: LD_VAR 0 1
44617: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44618: LD_INT 0
44620: PPUSH
44621: PPUSH
44622: PPUSH
44623: PPUSH
44624: PPUSH
44625: PPUSH
44626: PPUSH
44627: PPUSH
44628: PPUSH
44629: PPUSH
44630: PPUSH
44631: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44632: LD_ADDR_VAR 0 2
44636: PUSH
44637: LD_INT 0
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 0
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44655: LD_VAR 0 1
44659: NOT
44660: IFTRUE 44675
44662: PUSH
44663: LD_EXP 102
44667: PUSH
44668: LD_VAR 0 1
44672: ARRAY
44673: NOT
44674: OR
44675: IFTRUE 44723
44677: PUSH
44678: LD_EXP 102
44682: PUSH
44683: LD_VAR 0 1
44687: ARRAY
44688: PPUSH
44689: LD_INT 2
44691: PUSH
44692: LD_INT 30
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 30
44704: PUSH
44705: LD_INT 1
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: LIST
44716: PPUSH
44717: CALL_OW 72
44721: NOT
44722: OR
44723: IFFALSE 44727
// exit ;
44725: GO 48268
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44727: LD_ADDR_VAR 0 4
44731: PUSH
44732: LD_EXP 102
44736: PUSH
44737: LD_VAR 0 1
44741: ARRAY
44742: PPUSH
44743: LD_INT 2
44745: PUSH
44746: LD_INT 25
44748: PUSH
44749: LD_INT 1
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 25
44758: PUSH
44759: LD_INT 2
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 25
44768: PUSH
44769: LD_INT 3
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 25
44778: PUSH
44779: LD_INT 4
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 25
44788: PUSH
44789: LD_INT 5
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 25
44798: PUSH
44799: LD_INT 8
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 25
44808: PUSH
44809: LD_INT 9
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: PPUSH
44826: CALL_OW 72
44830: ST_TO_ADDR
// if not tmp then
44831: LD_VAR 0 4
44835: NOT
44836: IFFALSE 44840
// exit ;
44838: GO 48268
// for i in tmp do
44840: LD_ADDR_VAR 0 3
44844: PUSH
44845: LD_VAR 0 4
44849: PUSH
44850: FOR_IN
44851: IFFALSE 44882
// if GetTag ( i ) then
44853: LD_VAR 0 3
44857: PPUSH
44858: CALL_OW 110
44862: IFFALSE 44880
// tmp := tmp diff i ;
44864: LD_ADDR_VAR 0 4
44868: PUSH
44869: LD_VAR 0 4
44873: PUSH
44874: LD_VAR 0 3
44878: DIFF
44879: ST_TO_ADDR
44880: GO 44850
44882: POP
44883: POP
// if not tmp then
44884: LD_VAR 0 4
44888: NOT
44889: IFFALSE 44893
// exit ;
44891: GO 48268
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44893: LD_ADDR_VAR 0 5
44897: PUSH
44898: LD_EXP 102
44902: PUSH
44903: LD_VAR 0 1
44907: ARRAY
44908: PPUSH
44909: LD_INT 2
44911: PUSH
44912: LD_INT 25
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 25
44924: PUSH
44925: LD_INT 5
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 25
44934: PUSH
44935: LD_INT 8
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 25
44944: PUSH
44945: LD_INT 9
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: PPUSH
44959: CALL_OW 72
44963: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44964: LD_ADDR_VAR 0 6
44968: PUSH
44969: LD_EXP 102
44973: PUSH
44974: LD_VAR 0 1
44978: ARRAY
44979: PPUSH
44980: LD_INT 25
44982: PUSH
44983: LD_INT 2
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PPUSH
44990: CALL_OW 72
44994: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44995: LD_ADDR_VAR 0 7
44999: PUSH
45000: LD_EXP 102
45004: PUSH
45005: LD_VAR 0 1
45009: ARRAY
45010: PPUSH
45011: LD_INT 25
45013: PUSH
45014: LD_INT 3
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PPUSH
45021: CALL_OW 72
45025: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
45026: LD_ADDR_VAR 0 8
45030: PUSH
45031: LD_EXP 102
45035: PUSH
45036: LD_VAR 0 1
45040: ARRAY
45041: PPUSH
45042: LD_INT 25
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 24
45054: PUSH
45055: LD_INT 251
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PPUSH
45066: CALL_OW 72
45070: ST_TO_ADDR
// if mc_is_defending [ base ] then
45071: LD_EXP 145
45075: PUSH
45076: LD_VAR 0 1
45080: ARRAY
45081: IFFALSE 45542
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
45083: LD_ADDR_EXP 144
45087: PUSH
45088: LD_EXP 144
45092: PPUSH
45093: LD_VAR 0 1
45097: PPUSH
45098: LD_INT 4
45100: PPUSH
45101: CALL_OW 1
45105: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
45106: LD_ADDR_VAR 0 12
45110: PUSH
45111: LD_EXP 102
45115: PUSH
45116: LD_VAR 0 1
45120: ARRAY
45121: PPUSH
45122: LD_INT 2
45124: PUSH
45125: LD_INT 30
45127: PUSH
45128: LD_INT 4
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 30
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: ST_TO_ADDR
// if not b then
45155: LD_VAR 0 12
45159: NOT
45160: IFFALSE 45164
// exit ;
45162: GO 48268
// p := [ ] ;
45164: LD_ADDR_VAR 0 11
45168: PUSH
45169: EMPTY
45170: ST_TO_ADDR
// if sci >= 2 then
45171: LD_VAR 0 8
45175: PUSH
45176: LD_INT 2
45178: GREATEREQUAL
45179: IFFALSE 45210
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
45181: LD_ADDR_VAR 0 8
45185: PUSH
45186: LD_VAR 0 8
45190: PUSH
45191: LD_INT 1
45193: ARRAY
45194: PUSH
45195: LD_VAR 0 8
45199: PUSH
45200: LD_INT 2
45202: ARRAY
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: ST_TO_ADDR
45208: GO 45271
// if sci = 1 then
45210: LD_VAR 0 8
45214: PUSH
45215: LD_INT 1
45217: EQUAL
45218: IFFALSE 45239
// sci := [ sci [ 1 ] ] else
45220: LD_ADDR_VAR 0 8
45224: PUSH
45225: LD_VAR 0 8
45229: PUSH
45230: LD_INT 1
45232: ARRAY
45233: PUSH
45234: EMPTY
45235: LIST
45236: ST_TO_ADDR
45237: GO 45271
// if sci = 0 then
45239: LD_VAR 0 8
45243: PUSH
45244: LD_INT 0
45246: EQUAL
45247: IFFALSE 45271
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
45249: LD_ADDR_VAR 0 11
45253: PUSH
45254: LD_VAR 0 4
45258: PPUSH
45259: LD_INT 4
45261: PPUSH
45262: CALL 107575 0 2
45266: PUSH
45267: LD_INT 1
45269: ARRAY
45270: ST_TO_ADDR
// if eng > 4 then
45271: LD_VAR 0 6
45275: PUSH
45276: LD_INT 4
45278: GREATER
45279: IFFALSE 45325
// for i = eng downto 4 do
45281: LD_ADDR_VAR 0 3
45285: PUSH
45286: DOUBLE
45287: LD_VAR 0 6
45291: INC
45292: ST_TO_ADDR
45293: LD_INT 4
45295: PUSH
45296: FOR_DOWNTO
45297: IFFALSE 45323
// eng := eng diff eng [ i ] ;
45299: LD_ADDR_VAR 0 6
45303: PUSH
45304: LD_VAR 0 6
45308: PUSH
45309: LD_VAR 0 6
45313: PUSH
45314: LD_VAR 0 3
45318: ARRAY
45319: DIFF
45320: ST_TO_ADDR
45321: GO 45296
45323: POP
45324: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45325: LD_ADDR_VAR 0 4
45329: PUSH
45330: LD_VAR 0 4
45334: PUSH
45335: LD_VAR 0 5
45339: PUSH
45340: LD_VAR 0 6
45344: UNION
45345: PUSH
45346: LD_VAR 0 7
45350: UNION
45351: PUSH
45352: LD_VAR 0 8
45356: UNION
45357: DIFF
45358: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45359: LD_ADDR_VAR 0 13
45363: PUSH
45364: LD_EXP 102
45368: PUSH
45369: LD_VAR 0 1
45373: ARRAY
45374: PPUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 30
45380: PUSH
45381: LD_INT 32
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 30
45390: PUSH
45391: LD_INT 31
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: PPUSH
45403: CALL_OW 72
45407: PUSH
45408: LD_EXP 102
45412: PUSH
45413: LD_VAR 0 1
45417: ARRAY
45418: PPUSH
45419: LD_INT 2
45421: PUSH
45422: LD_INT 30
45424: PUSH
45425: LD_INT 4
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 30
45434: PUSH
45435: LD_INT 5
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PPUSH
45447: CALL_OW 72
45451: PUSH
45452: LD_INT 6
45454: MUL
45455: PLUS
45456: ST_TO_ADDR
// if bcount < tmp then
45457: LD_VAR 0 13
45461: PUSH
45462: LD_VAR 0 4
45466: LESS
45467: IFFALSE 45513
// for i = tmp downto bcount do
45469: LD_ADDR_VAR 0 3
45473: PUSH
45474: DOUBLE
45475: LD_VAR 0 4
45479: INC
45480: ST_TO_ADDR
45481: LD_VAR 0 13
45485: PUSH
45486: FOR_DOWNTO
45487: IFFALSE 45511
// tmp := Delete ( tmp , tmp ) ;
45489: LD_ADDR_VAR 0 4
45493: PUSH
45494: LD_VAR 0 4
45498: PPUSH
45499: LD_VAR 0 4
45503: PPUSH
45504: CALL_OW 3
45508: ST_TO_ADDR
45509: GO 45486
45511: POP
45512: POP
// result := [ tmp , 0 , 0 , p ] ;
45513: LD_ADDR_VAR 0 2
45517: PUSH
45518: LD_VAR 0 4
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: LD_INT 0
45528: PUSH
45529: LD_VAR 0 11
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// exit ;
45540: GO 48268
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45542: LD_EXP 102
45546: PUSH
45547: LD_VAR 0 1
45551: ARRAY
45552: PPUSH
45553: LD_INT 2
45555: PUSH
45556: LD_INT 30
45558: PUSH
45559: LD_INT 6
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 30
45568: PUSH
45569: LD_INT 7
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 8
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: PPUSH
45592: CALL_OW 72
45596: NOT
45597: IFFALSE 45627
45599: PUSH
45600: LD_EXP 102
45604: PUSH
45605: LD_VAR 0 1
45609: ARRAY
45610: PPUSH
45611: LD_INT 30
45613: PUSH
45614: LD_INT 3
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PPUSH
45621: CALL_OW 72
45625: NOT
45626: AND
45627: IFFALSE 45699
// begin if eng = tmp then
45629: LD_VAR 0 6
45633: PUSH
45634: LD_VAR 0 4
45638: EQUAL
45639: IFFALSE 45643
// exit ;
45641: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45643: LD_ADDR_EXP 144
45647: PUSH
45648: LD_EXP 144
45652: PPUSH
45653: LD_VAR 0 1
45657: PPUSH
45658: LD_INT 1
45660: PPUSH
45661: CALL_OW 1
45665: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45666: LD_ADDR_VAR 0 2
45670: PUSH
45671: LD_INT 0
45673: PUSH
45674: LD_VAR 0 4
45678: PUSH
45679: LD_VAR 0 6
45683: DIFF
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 0
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: ST_TO_ADDR
// exit ;
45697: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45699: LD_EXP 129
45703: PUSH
45704: LD_EXP 128
45708: PUSH
45709: LD_VAR 0 1
45713: ARRAY
45714: ARRAY
45715: IFFALSE 45773
45717: PUSH
45718: LD_EXP 102
45722: PUSH
45723: LD_VAR 0 1
45727: ARRAY
45728: PPUSH
45729: LD_INT 2
45731: PUSH
45732: LD_INT 30
45734: PUSH
45735: LD_INT 6
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 30
45744: PUSH
45745: LD_INT 7
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 30
45754: PUSH
45755: LD_INT 8
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: PPUSH
45768: CALL_OW 72
45772: AND
45773: IFFALSE 45803
45775: PUSH
45776: LD_EXP 102
45780: PUSH
45781: LD_VAR 0 1
45785: ARRAY
45786: PPUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: CALL_OW 72
45801: NOT
45802: AND
45803: IFFALSE 46019
// begin if sci >= 6 then
45805: LD_VAR 0 8
45809: PUSH
45810: LD_INT 6
45812: GREATEREQUAL
45813: IFFALSE 45817
// exit ;
45815: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45817: LD_ADDR_EXP 144
45821: PUSH
45822: LD_EXP 144
45826: PPUSH
45827: LD_VAR 0 1
45831: PPUSH
45832: LD_INT 2
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45840: LD_ADDR_VAR 0 9
45844: PUSH
45845: LD_VAR 0 4
45849: PUSH
45850: LD_VAR 0 8
45854: DIFF
45855: PPUSH
45856: LD_INT 4
45858: PPUSH
45859: CALL 107575 0 2
45863: ST_TO_ADDR
// p := [ ] ;
45864: LD_ADDR_VAR 0 11
45868: PUSH
45869: EMPTY
45870: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45871: LD_VAR 0 8
45875: PUSH
45876: LD_INT 6
45878: LESS
45879: IFFALSE 45891
45881: PUSH
45882: LD_VAR 0 9
45886: PUSH
45887: LD_INT 6
45889: GREATER
45890: AND
45891: IFFALSE 45972
// begin for i = 1 to 6 - sci do
45893: LD_ADDR_VAR 0 3
45897: PUSH
45898: DOUBLE
45899: LD_INT 1
45901: DEC
45902: ST_TO_ADDR
45903: LD_INT 6
45905: PUSH
45906: LD_VAR 0 8
45910: MINUS
45911: PUSH
45912: FOR_TO
45913: IFFALSE 45968
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45915: LD_ADDR_VAR 0 11
45919: PUSH
45920: LD_VAR 0 11
45924: PPUSH
45925: LD_VAR 0 11
45929: PUSH
45930: LD_INT 1
45932: PLUS
45933: PPUSH
45934: LD_VAR 0 9
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: PPUSH
45943: CALL_OW 2
45947: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45948: LD_ADDR_VAR 0 9
45952: PUSH
45953: LD_VAR 0 9
45957: PPUSH
45958: LD_INT 1
45960: PPUSH
45961: CALL_OW 3
45965: ST_TO_ADDR
// end ;
45966: GO 45912
45968: POP
45969: POP
// end else
45970: GO 45992
// if sort then
45972: LD_VAR 0 9
45976: IFFALSE 45992
// p := sort [ 1 ] ;
45978: LD_ADDR_VAR 0 11
45982: PUSH
45983: LD_VAR 0 9
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45992: LD_ADDR_VAR 0 2
45996: PUSH
45997: LD_INT 0
45999: PUSH
46000: LD_INT 0
46002: PUSH
46003: LD_INT 0
46005: PUSH
46006: LD_VAR 0 11
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: ST_TO_ADDR
// exit ;
46017: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
46019: LD_EXP 129
46023: PUSH
46024: LD_EXP 128
46028: PUSH
46029: LD_VAR 0 1
46033: ARRAY
46034: ARRAY
46035: IFFALSE 46093
46037: PUSH
46038: LD_EXP 102
46042: PUSH
46043: LD_VAR 0 1
46047: ARRAY
46048: PPUSH
46049: LD_INT 2
46051: PUSH
46052: LD_INT 30
46054: PUSH
46055: LD_INT 6
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 30
46064: PUSH
46065: LD_INT 7
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 30
46074: PUSH
46075: LD_INT 8
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: PPUSH
46088: CALL_OW 72
46092: AND
46093: IFFALSE 46122
46095: PUSH
46096: LD_EXP 102
46100: PUSH
46101: LD_VAR 0 1
46105: ARRAY
46106: PPUSH
46107: LD_INT 30
46109: PUSH
46110: LD_INT 3
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: PPUSH
46117: CALL_OW 72
46121: AND
46122: IFFALSE 46862
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
46124: LD_ADDR_EXP 144
46128: PUSH
46129: LD_EXP 144
46133: PPUSH
46134: LD_VAR 0 1
46138: PPUSH
46139: LD_INT 3
46141: PPUSH
46142: CALL_OW 1
46146: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46147: LD_ADDR_VAR 0 2
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: LD_INT 0
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: ST_TO_ADDR
// if not eng then
46170: LD_VAR 0 6
46174: NOT
46175: IFFALSE 46238
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
46177: LD_ADDR_VAR 0 11
46181: PUSH
46182: LD_VAR 0 4
46186: PPUSH
46187: LD_INT 2
46189: PPUSH
46190: CALL 107575 0 2
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
46199: LD_ADDR_VAR 0 2
46203: PUSH
46204: LD_VAR 0 2
46208: PPUSH
46209: LD_INT 2
46211: PPUSH
46212: LD_VAR 0 11
46216: PPUSH
46217: CALL_OW 1
46221: ST_TO_ADDR
// tmp := tmp diff p ;
46222: LD_ADDR_VAR 0 4
46226: PUSH
46227: LD_VAR 0 4
46231: PUSH
46232: LD_VAR 0 11
46236: DIFF
46237: ST_TO_ADDR
// end ; if tmp and sci < 6 then
46238: LD_VAR 0 4
46242: IFFALSE 46254
46244: PUSH
46245: LD_VAR 0 8
46249: PUSH
46250: LD_INT 6
46252: LESS
46253: AND
46254: IFFALSE 46442
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
46256: LD_ADDR_VAR 0 9
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_VAR 0 8
46270: PUSH
46271: LD_VAR 0 7
46275: UNION
46276: DIFF
46277: PPUSH
46278: LD_INT 4
46280: PPUSH
46281: CALL 107575 0 2
46285: ST_TO_ADDR
// p := [ ] ;
46286: LD_ADDR_VAR 0 11
46290: PUSH
46291: EMPTY
46292: ST_TO_ADDR
// if sort then
46293: LD_VAR 0 9
46297: IFFALSE 46413
// for i = 1 to 6 - sci do
46299: LD_ADDR_VAR 0 3
46303: PUSH
46304: DOUBLE
46305: LD_INT 1
46307: DEC
46308: ST_TO_ADDR
46309: LD_INT 6
46311: PUSH
46312: LD_VAR 0 8
46316: MINUS
46317: PUSH
46318: FOR_TO
46319: IFFALSE 46411
// begin if i = sort then
46321: LD_VAR 0 3
46325: PUSH
46326: LD_VAR 0 9
46330: EQUAL
46331: IFFALSE 46335
// break ;
46333: GO 46411
// if GetClass ( i ) = 4 then
46335: LD_VAR 0 3
46339: PPUSH
46340: CALL_OW 257
46344: PUSH
46345: LD_INT 4
46347: EQUAL
46348: IFFALSE 46352
// continue ;
46350: GO 46318
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46352: LD_ADDR_VAR 0 11
46356: PUSH
46357: LD_VAR 0 11
46361: PPUSH
46362: LD_VAR 0 11
46366: PUSH
46367: LD_INT 1
46369: PLUS
46370: PPUSH
46371: LD_VAR 0 9
46375: PUSH
46376: LD_VAR 0 3
46380: ARRAY
46381: PPUSH
46382: CALL_OW 2
46386: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46387: LD_ADDR_VAR 0 4
46391: PUSH
46392: LD_VAR 0 4
46396: PUSH
46397: LD_VAR 0 9
46401: PUSH
46402: LD_VAR 0 3
46406: ARRAY
46407: DIFF
46408: ST_TO_ADDR
// end ;
46409: GO 46318
46411: POP
46412: POP
// if p then
46413: LD_VAR 0 11
46417: IFFALSE 46442
// result := Replace ( result , 4 , p ) ;
46419: LD_ADDR_VAR 0 2
46423: PUSH
46424: LD_VAR 0 2
46428: PPUSH
46429: LD_INT 4
46431: PPUSH
46432: LD_VAR 0 11
46436: PPUSH
46437: CALL_OW 1
46441: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46442: LD_VAR 0 4
46446: IFFALSE 46458
46448: PUSH
46449: LD_VAR 0 7
46453: PUSH
46454: LD_INT 6
46456: LESS
46457: AND
46458: IFFALSE 46646
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46460: LD_ADDR_VAR 0 9
46464: PUSH
46465: LD_VAR 0 4
46469: PUSH
46470: LD_VAR 0 8
46474: PUSH
46475: LD_VAR 0 7
46479: UNION
46480: DIFF
46481: PPUSH
46482: LD_INT 3
46484: PPUSH
46485: CALL 107575 0 2
46489: ST_TO_ADDR
// p := [ ] ;
46490: LD_ADDR_VAR 0 11
46494: PUSH
46495: EMPTY
46496: ST_TO_ADDR
// if sort then
46497: LD_VAR 0 9
46501: IFFALSE 46617
// for i = 1 to 6 - mech do
46503: LD_ADDR_VAR 0 3
46507: PUSH
46508: DOUBLE
46509: LD_INT 1
46511: DEC
46512: ST_TO_ADDR
46513: LD_INT 6
46515: PUSH
46516: LD_VAR 0 7
46520: MINUS
46521: PUSH
46522: FOR_TO
46523: IFFALSE 46615
// begin if i = sort then
46525: LD_VAR 0 3
46529: PUSH
46530: LD_VAR 0 9
46534: EQUAL
46535: IFFALSE 46539
// break ;
46537: GO 46615
// if GetClass ( i ) = 3 then
46539: LD_VAR 0 3
46543: PPUSH
46544: CALL_OW 257
46548: PUSH
46549: LD_INT 3
46551: EQUAL
46552: IFFALSE 46556
// continue ;
46554: GO 46522
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46556: LD_ADDR_VAR 0 11
46560: PUSH
46561: LD_VAR 0 11
46565: PPUSH
46566: LD_VAR 0 11
46570: PUSH
46571: LD_INT 1
46573: PLUS
46574: PPUSH
46575: LD_VAR 0 9
46579: PUSH
46580: LD_VAR 0 3
46584: ARRAY
46585: PPUSH
46586: CALL_OW 2
46590: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46591: LD_ADDR_VAR 0 4
46595: PUSH
46596: LD_VAR 0 4
46600: PUSH
46601: LD_VAR 0 9
46605: PUSH
46606: LD_VAR 0 3
46610: ARRAY
46611: DIFF
46612: ST_TO_ADDR
// end ;
46613: GO 46522
46615: POP
46616: POP
// if p then
46617: LD_VAR 0 11
46621: IFFALSE 46646
// result := Replace ( result , 3 , p ) ;
46623: LD_ADDR_VAR 0 2
46627: PUSH
46628: LD_VAR 0 2
46632: PPUSH
46633: LD_INT 3
46635: PPUSH
46636: LD_VAR 0 11
46640: PPUSH
46641: CALL_OW 1
46645: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46646: LD_VAR 0 4
46650: PUSH
46651: LD_INT 6
46653: GREATER
46654: IFFALSE 46666
46656: PUSH
46657: LD_VAR 0 6
46661: PUSH
46662: LD_INT 6
46664: LESS
46665: AND
46666: IFFALSE 46860
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46668: LD_ADDR_VAR 0 9
46672: PUSH
46673: LD_VAR 0 4
46677: PUSH
46678: LD_VAR 0 8
46682: PUSH
46683: LD_VAR 0 7
46687: UNION
46688: PUSH
46689: LD_VAR 0 6
46693: UNION
46694: DIFF
46695: PPUSH
46696: LD_INT 2
46698: PPUSH
46699: CALL 107575 0 2
46703: ST_TO_ADDR
// p := [ ] ;
46704: LD_ADDR_VAR 0 11
46708: PUSH
46709: EMPTY
46710: ST_TO_ADDR
// if sort then
46711: LD_VAR 0 9
46715: IFFALSE 46831
// for i = 1 to 6 - eng do
46717: LD_ADDR_VAR 0 3
46721: PUSH
46722: DOUBLE
46723: LD_INT 1
46725: DEC
46726: ST_TO_ADDR
46727: LD_INT 6
46729: PUSH
46730: LD_VAR 0 6
46734: MINUS
46735: PUSH
46736: FOR_TO
46737: IFFALSE 46829
// begin if i = sort then
46739: LD_VAR 0 3
46743: PUSH
46744: LD_VAR 0 9
46748: EQUAL
46749: IFFALSE 46753
// break ;
46751: GO 46829
// if GetClass ( i ) = 2 then
46753: LD_VAR 0 3
46757: PPUSH
46758: CALL_OW 257
46762: PUSH
46763: LD_INT 2
46765: EQUAL
46766: IFFALSE 46770
// continue ;
46768: GO 46736
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46770: LD_ADDR_VAR 0 11
46774: PUSH
46775: LD_VAR 0 11
46779: PPUSH
46780: LD_VAR 0 11
46784: PUSH
46785: LD_INT 1
46787: PLUS
46788: PPUSH
46789: LD_VAR 0 9
46793: PUSH
46794: LD_VAR 0 3
46798: ARRAY
46799: PPUSH
46800: CALL_OW 2
46804: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46805: LD_ADDR_VAR 0 4
46809: PUSH
46810: LD_VAR 0 4
46814: PUSH
46815: LD_VAR 0 9
46819: PUSH
46820: LD_VAR 0 3
46824: ARRAY
46825: DIFF
46826: ST_TO_ADDR
// end ;
46827: GO 46736
46829: POP
46830: POP
// if p then
46831: LD_VAR 0 11
46835: IFFALSE 46860
// result := Replace ( result , 2 , p ) ;
46837: LD_ADDR_VAR 0 2
46841: PUSH
46842: LD_VAR 0 2
46846: PPUSH
46847: LD_INT 2
46849: PPUSH
46850: LD_VAR 0 11
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// end ; exit ;
46860: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46862: LD_EXP 129
46866: PUSH
46867: LD_EXP 128
46871: PUSH
46872: LD_VAR 0 1
46876: ARRAY
46877: ARRAY
46878: NOT
46879: IFFALSE 46908
46881: PUSH
46882: LD_EXP 102
46886: PUSH
46887: LD_VAR 0 1
46891: ARRAY
46892: PPUSH
46893: LD_INT 30
46895: PUSH
46896: LD_INT 3
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PPUSH
46903: CALL_OW 72
46907: AND
46908: IFFALSE 46922
46910: PUSH
46911: LD_EXP 107
46915: PUSH
46916: LD_VAR 0 1
46920: ARRAY
46921: AND
46922: IFFALSE 47536
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46924: LD_ADDR_EXP 144
46928: PUSH
46929: LD_EXP 144
46933: PPUSH
46934: LD_VAR 0 1
46938: PPUSH
46939: LD_INT 5
46941: PPUSH
46942: CALL_OW 1
46946: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46947: LD_ADDR_VAR 0 2
46951: PUSH
46952: LD_INT 0
46954: PUSH
46955: LD_INT 0
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: LD_INT 0
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: ST_TO_ADDR
// if sci > 1 then
46970: LD_VAR 0 8
46974: PUSH
46975: LD_INT 1
46977: GREATER
46978: IFFALSE 47006
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46980: LD_ADDR_VAR 0 4
46984: PUSH
46985: LD_VAR 0 4
46989: PUSH
46990: LD_VAR 0 8
46994: PUSH
46995: LD_VAR 0 8
46999: PUSH
47000: LD_INT 1
47002: ARRAY
47003: DIFF
47004: DIFF
47005: ST_TO_ADDR
// if tmp and not sci then
47006: LD_VAR 0 4
47010: IFFALSE 47019
47012: PUSH
47013: LD_VAR 0 8
47017: NOT
47018: AND
47019: IFFALSE 47088
// begin sort := SortBySkill ( tmp , 4 ) ;
47021: LD_ADDR_VAR 0 9
47025: PUSH
47026: LD_VAR 0 4
47030: PPUSH
47031: LD_INT 4
47033: PPUSH
47034: CALL 107575 0 2
47038: ST_TO_ADDR
// if sort then
47039: LD_VAR 0 9
47043: IFFALSE 47059
// p := sort [ 1 ] ;
47045: LD_ADDR_VAR 0 11
47049: PUSH
47050: LD_VAR 0 9
47054: PUSH
47055: LD_INT 1
47057: ARRAY
47058: ST_TO_ADDR
// if p then
47059: LD_VAR 0 11
47063: IFFALSE 47088
// result := Replace ( result , 4 , p ) ;
47065: LD_ADDR_VAR 0 2
47069: PUSH
47070: LD_VAR 0 2
47074: PPUSH
47075: LD_INT 4
47077: PPUSH
47078: LD_VAR 0 11
47082: PPUSH
47083: CALL_OW 1
47087: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47088: LD_ADDR_VAR 0 4
47092: PUSH
47093: LD_VAR 0 4
47097: PUSH
47098: LD_VAR 0 7
47102: DIFF
47103: ST_TO_ADDR
// if tmp and mech < 6 then
47104: LD_VAR 0 4
47108: IFFALSE 47120
47110: PUSH
47111: LD_VAR 0 7
47115: PUSH
47116: LD_INT 6
47118: LESS
47119: AND
47120: IFFALSE 47308
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
47122: LD_ADDR_VAR 0 9
47126: PUSH
47127: LD_VAR 0 4
47131: PUSH
47132: LD_VAR 0 8
47136: PUSH
47137: LD_VAR 0 7
47141: UNION
47142: DIFF
47143: PPUSH
47144: LD_INT 3
47146: PPUSH
47147: CALL 107575 0 2
47151: ST_TO_ADDR
// p := [ ] ;
47152: LD_ADDR_VAR 0 11
47156: PUSH
47157: EMPTY
47158: ST_TO_ADDR
// if sort then
47159: LD_VAR 0 9
47163: IFFALSE 47279
// for i = 1 to 6 - mech do
47165: LD_ADDR_VAR 0 3
47169: PUSH
47170: DOUBLE
47171: LD_INT 1
47173: DEC
47174: ST_TO_ADDR
47175: LD_INT 6
47177: PUSH
47178: LD_VAR 0 7
47182: MINUS
47183: PUSH
47184: FOR_TO
47185: IFFALSE 47277
// begin if i = sort then
47187: LD_VAR 0 3
47191: PUSH
47192: LD_VAR 0 9
47196: EQUAL
47197: IFFALSE 47201
// break ;
47199: GO 47277
// if GetClass ( i ) = 3 then
47201: LD_VAR 0 3
47205: PPUSH
47206: CALL_OW 257
47210: PUSH
47211: LD_INT 3
47213: EQUAL
47214: IFFALSE 47218
// continue ;
47216: GO 47184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47218: LD_ADDR_VAR 0 11
47222: PUSH
47223: LD_VAR 0 11
47227: PPUSH
47228: LD_VAR 0 11
47232: PUSH
47233: LD_INT 1
47235: PLUS
47236: PPUSH
47237: LD_VAR 0 9
47241: PUSH
47242: LD_VAR 0 3
47246: ARRAY
47247: PPUSH
47248: CALL_OW 2
47252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47253: LD_ADDR_VAR 0 4
47257: PUSH
47258: LD_VAR 0 4
47262: PUSH
47263: LD_VAR 0 9
47267: PUSH
47268: LD_VAR 0 3
47272: ARRAY
47273: DIFF
47274: ST_TO_ADDR
// end ;
47275: GO 47184
47277: POP
47278: POP
// if p then
47279: LD_VAR 0 11
47283: IFFALSE 47308
// result := Replace ( result , 3 , p ) ;
47285: LD_ADDR_VAR 0 2
47289: PUSH
47290: LD_VAR 0 2
47294: PPUSH
47295: LD_INT 3
47297: PPUSH
47298: LD_VAR 0 11
47302: PPUSH
47303: CALL_OW 1
47307: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47308: LD_ADDR_VAR 0 4
47312: PUSH
47313: LD_VAR 0 4
47317: PUSH
47318: LD_VAR 0 6
47322: DIFF
47323: ST_TO_ADDR
// if tmp and eng < 6 then
47324: LD_VAR 0 4
47328: IFFALSE 47340
47330: PUSH
47331: LD_VAR 0 6
47335: PUSH
47336: LD_INT 6
47338: LESS
47339: AND
47340: IFFALSE 47534
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47342: LD_ADDR_VAR 0 9
47346: PUSH
47347: LD_VAR 0 4
47351: PUSH
47352: LD_VAR 0 8
47356: PUSH
47357: LD_VAR 0 7
47361: UNION
47362: PUSH
47363: LD_VAR 0 6
47367: UNION
47368: DIFF
47369: PPUSH
47370: LD_INT 2
47372: PPUSH
47373: CALL 107575 0 2
47377: ST_TO_ADDR
// p := [ ] ;
47378: LD_ADDR_VAR 0 11
47382: PUSH
47383: EMPTY
47384: ST_TO_ADDR
// if sort then
47385: LD_VAR 0 9
47389: IFFALSE 47505
// for i = 1 to 6 - eng do
47391: LD_ADDR_VAR 0 3
47395: PUSH
47396: DOUBLE
47397: LD_INT 1
47399: DEC
47400: ST_TO_ADDR
47401: LD_INT 6
47403: PUSH
47404: LD_VAR 0 6
47408: MINUS
47409: PUSH
47410: FOR_TO
47411: IFFALSE 47503
// begin if i = sort then
47413: LD_VAR 0 3
47417: PUSH
47418: LD_VAR 0 9
47422: EQUAL
47423: IFFALSE 47427
// break ;
47425: GO 47503
// if GetClass ( i ) = 2 then
47427: LD_VAR 0 3
47431: PPUSH
47432: CALL_OW 257
47436: PUSH
47437: LD_INT 2
47439: EQUAL
47440: IFFALSE 47444
// continue ;
47442: GO 47410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47444: LD_ADDR_VAR 0 11
47448: PUSH
47449: LD_VAR 0 11
47453: PPUSH
47454: LD_VAR 0 11
47458: PUSH
47459: LD_INT 1
47461: PLUS
47462: PPUSH
47463: LD_VAR 0 9
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: PPUSH
47474: CALL_OW 2
47478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47479: LD_ADDR_VAR 0 4
47483: PUSH
47484: LD_VAR 0 4
47488: PUSH
47489: LD_VAR 0 9
47493: PUSH
47494: LD_VAR 0 3
47498: ARRAY
47499: DIFF
47500: ST_TO_ADDR
// end ;
47501: GO 47410
47503: POP
47504: POP
// if p then
47505: LD_VAR 0 11
47509: IFFALSE 47534
// result := Replace ( result , 2 , p ) ;
47511: LD_ADDR_VAR 0 2
47515: PUSH
47516: LD_VAR 0 2
47520: PPUSH
47521: LD_INT 2
47523: PPUSH
47524: LD_VAR 0 11
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// end ; exit ;
47534: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47536: LD_EXP 129
47540: PUSH
47541: LD_EXP 128
47545: PUSH
47546: LD_VAR 0 1
47550: ARRAY
47551: ARRAY
47552: NOT
47553: IFFALSE 47582
47555: PUSH
47556: LD_EXP 102
47560: PUSH
47561: LD_VAR 0 1
47565: ARRAY
47566: PPUSH
47567: LD_INT 30
47569: PUSH
47570: LD_INT 3
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: PPUSH
47577: CALL_OW 72
47581: AND
47582: IFFALSE 47597
47584: PUSH
47585: LD_EXP 107
47589: PUSH
47590: LD_VAR 0 1
47594: ARRAY
47595: NOT
47596: AND
47597: IFFALSE 48268
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47599: LD_ADDR_EXP 144
47603: PUSH
47604: LD_EXP 144
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: LD_INT 6
47616: PPUSH
47617: CALL_OW 1
47621: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: PUSH
47630: LD_INT 0
47632: PUSH
47633: LD_INT 0
47635: PUSH
47636: LD_INT 0
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// if sci >= 1 then
47645: LD_VAR 0 8
47649: PUSH
47650: LD_INT 1
47652: GREATEREQUAL
47653: IFFALSE 47675
// tmp := tmp diff sci [ 1 ] ;
47655: LD_ADDR_VAR 0 4
47659: PUSH
47660: LD_VAR 0 4
47664: PUSH
47665: LD_VAR 0 8
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: DIFF
47674: ST_TO_ADDR
// if tmp and not sci then
47675: LD_VAR 0 4
47679: IFFALSE 47688
47681: PUSH
47682: LD_VAR 0 8
47686: NOT
47687: AND
47688: IFFALSE 47757
// begin sort := SortBySkill ( tmp , 4 ) ;
47690: LD_ADDR_VAR 0 9
47694: PUSH
47695: LD_VAR 0 4
47699: PPUSH
47700: LD_INT 4
47702: PPUSH
47703: CALL 107575 0 2
47707: ST_TO_ADDR
// if sort then
47708: LD_VAR 0 9
47712: IFFALSE 47728
// p := sort [ 1 ] ;
47714: LD_ADDR_VAR 0 11
47718: PUSH
47719: LD_VAR 0 9
47723: PUSH
47724: LD_INT 1
47726: ARRAY
47727: ST_TO_ADDR
// if p then
47728: LD_VAR 0 11
47732: IFFALSE 47757
// result := Replace ( result , 4 , p ) ;
47734: LD_ADDR_VAR 0 2
47738: PUSH
47739: LD_VAR 0 2
47743: PPUSH
47744: LD_INT 4
47746: PPUSH
47747: LD_VAR 0 11
47751: PPUSH
47752: CALL_OW 1
47756: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47757: LD_ADDR_VAR 0 4
47761: PUSH
47762: LD_VAR 0 4
47766: PUSH
47767: LD_VAR 0 7
47771: DIFF
47772: ST_TO_ADDR
// if tmp and mech < 6 then
47773: LD_VAR 0 4
47777: IFFALSE 47789
47779: PUSH
47780: LD_VAR 0 7
47784: PUSH
47785: LD_INT 6
47787: LESS
47788: AND
47789: IFFALSE 47971
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47791: LD_ADDR_VAR 0 9
47795: PUSH
47796: LD_VAR 0 4
47800: PUSH
47801: LD_VAR 0 7
47805: DIFF
47806: PPUSH
47807: LD_INT 3
47809: PPUSH
47810: CALL 107575 0 2
47814: ST_TO_ADDR
// p := [ ] ;
47815: LD_ADDR_VAR 0 11
47819: PUSH
47820: EMPTY
47821: ST_TO_ADDR
// if sort then
47822: LD_VAR 0 9
47826: IFFALSE 47942
// for i = 1 to 6 - mech do
47828: LD_ADDR_VAR 0 3
47832: PUSH
47833: DOUBLE
47834: LD_INT 1
47836: DEC
47837: ST_TO_ADDR
47838: LD_INT 6
47840: PUSH
47841: LD_VAR 0 7
47845: MINUS
47846: PUSH
47847: FOR_TO
47848: IFFALSE 47940
// begin if i = sort then
47850: LD_VAR 0 3
47854: PUSH
47855: LD_VAR 0 9
47859: EQUAL
47860: IFFALSE 47864
// break ;
47862: GO 47940
// if GetClass ( i ) = 3 then
47864: LD_VAR 0 3
47868: PPUSH
47869: CALL_OW 257
47873: PUSH
47874: LD_INT 3
47876: EQUAL
47877: IFFALSE 47881
// continue ;
47879: GO 47847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47881: LD_ADDR_VAR 0 11
47885: PUSH
47886: LD_VAR 0 11
47890: PPUSH
47891: LD_VAR 0 11
47895: PUSH
47896: LD_INT 1
47898: PLUS
47899: PPUSH
47900: LD_VAR 0 9
47904: PUSH
47905: LD_VAR 0 3
47909: ARRAY
47910: PPUSH
47911: CALL_OW 2
47915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47916: LD_ADDR_VAR 0 4
47920: PUSH
47921: LD_VAR 0 4
47925: PUSH
47926: LD_VAR 0 9
47930: PUSH
47931: LD_VAR 0 3
47935: ARRAY
47936: DIFF
47937: ST_TO_ADDR
// end ;
47938: GO 47847
47940: POP
47941: POP
// if p then
47942: LD_VAR 0 11
47946: IFFALSE 47971
// result := Replace ( result , 3 , p ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 2
47957: PPUSH
47958: LD_INT 3
47960: PPUSH
47961: LD_VAR 0 11
47965: PPUSH
47966: CALL_OW 1
47970: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47971: LD_ADDR_VAR 0 4
47975: PUSH
47976: LD_VAR 0 4
47980: PUSH
47981: LD_VAR 0 6
47985: DIFF
47986: ST_TO_ADDR
// if tmp and eng < 4 then
47987: LD_VAR 0 4
47991: IFFALSE 48003
47993: PUSH
47994: LD_VAR 0 6
47998: PUSH
47999: LD_INT 4
48001: LESS
48002: AND
48003: IFFALSE 48193
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
48005: LD_ADDR_VAR 0 9
48009: PUSH
48010: LD_VAR 0 4
48014: PUSH
48015: LD_VAR 0 7
48019: PUSH
48020: LD_VAR 0 6
48024: UNION
48025: DIFF
48026: PPUSH
48027: LD_INT 2
48029: PPUSH
48030: CALL 107575 0 2
48034: ST_TO_ADDR
// p := [ ] ;
48035: LD_ADDR_VAR 0 11
48039: PUSH
48040: EMPTY
48041: ST_TO_ADDR
// if sort then
48042: LD_VAR 0 9
48046: IFFALSE 48162
// for i = 1 to 4 - eng do
48048: LD_ADDR_VAR 0 3
48052: PUSH
48053: DOUBLE
48054: LD_INT 1
48056: DEC
48057: ST_TO_ADDR
48058: LD_INT 4
48060: PUSH
48061: LD_VAR 0 6
48065: MINUS
48066: PUSH
48067: FOR_TO
48068: IFFALSE 48160
// begin if i = sort then
48070: LD_VAR 0 3
48074: PUSH
48075: LD_VAR 0 9
48079: EQUAL
48080: IFFALSE 48084
// break ;
48082: GO 48160
// if GetClass ( i ) = 2 then
48084: LD_VAR 0 3
48088: PPUSH
48089: CALL_OW 257
48093: PUSH
48094: LD_INT 2
48096: EQUAL
48097: IFFALSE 48101
// continue ;
48099: GO 48067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48101: LD_ADDR_VAR 0 11
48105: PUSH
48106: LD_VAR 0 11
48110: PPUSH
48111: LD_VAR 0 11
48115: PUSH
48116: LD_INT 1
48118: PLUS
48119: PPUSH
48120: LD_VAR 0 9
48124: PUSH
48125: LD_VAR 0 3
48129: ARRAY
48130: PPUSH
48131: CALL_OW 2
48135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48136: LD_ADDR_VAR 0 4
48140: PUSH
48141: LD_VAR 0 4
48145: PUSH
48146: LD_VAR 0 9
48150: PUSH
48151: LD_VAR 0 3
48155: ARRAY
48156: DIFF
48157: ST_TO_ADDR
// end ;
48158: GO 48067
48160: POP
48161: POP
// if p then
48162: LD_VAR 0 11
48166: IFFALSE 48191
// result := Replace ( result , 2 , p ) ;
48168: LD_ADDR_VAR 0 2
48172: PUSH
48173: LD_VAR 0 2
48177: PPUSH
48178: LD_INT 2
48180: PPUSH
48181: LD_VAR 0 11
48185: PPUSH
48186: CALL_OW 1
48190: ST_TO_ADDR
// end else
48191: GO 48237
// for i = eng downto 5 do
48193: LD_ADDR_VAR 0 3
48197: PUSH
48198: DOUBLE
48199: LD_VAR 0 6
48203: INC
48204: ST_TO_ADDR
48205: LD_INT 5
48207: PUSH
48208: FOR_DOWNTO
48209: IFFALSE 48235
// tmp := tmp union eng [ i ] ;
48211: LD_ADDR_VAR 0 4
48215: PUSH
48216: LD_VAR 0 4
48220: PUSH
48221: LD_VAR 0 6
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: UNION
48232: ST_TO_ADDR
48233: GO 48208
48235: POP
48236: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
48237: LD_ADDR_VAR 0 2
48241: PUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: LD_INT 1
48249: PPUSH
48250: LD_VAR 0 4
48254: PUSH
48255: LD_VAR 0 5
48259: DIFF
48260: PPUSH
48261: CALL_OW 1
48265: ST_TO_ADDR
// exit ;
48266: GO 48268
// end ; end ;
48268: LD_VAR 0 2
48272: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
48273: LD_INT 0
48275: PPUSH
48276: PPUSH
48277: PPUSH
// if not mc_bases then
48278: LD_EXP 102
48282: NOT
48283: IFFALSE 48287
// exit ;
48285: GO 48429
// for i = 1 to mc_bases do
48287: LD_ADDR_VAR 0 2
48291: PUSH
48292: DOUBLE
48293: LD_INT 1
48295: DEC
48296: ST_TO_ADDR
48297: LD_EXP 102
48301: PUSH
48302: FOR_TO
48303: IFFALSE 48420
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
48305: LD_ADDR_VAR 0 3
48309: PUSH
48310: LD_EXP 102
48314: PUSH
48315: LD_VAR 0 2
48319: ARRAY
48320: PPUSH
48321: LD_INT 21
48323: PUSH
48324: LD_INT 3
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 3
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 29
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: LD_INT 30
48349: PUSH
48350: LD_INT 30
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: LIST
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 3
48368: PUSH
48369: LD_INT 24
48371: PUSH
48372: LD_INT 1000
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PPUSH
48388: CALL_OW 72
48392: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48393: LD_ADDR_EXP 103
48397: PUSH
48398: LD_EXP 103
48402: PPUSH
48403: LD_VAR 0 2
48407: PPUSH
48408: LD_VAR 0 3
48412: PPUSH
48413: CALL_OW 1
48417: ST_TO_ADDR
// end ;
48418: GO 48302
48420: POP
48421: POP
// RaiseSailEvent ( 101 ) ;
48422: LD_INT 101
48424: PPUSH
48425: CALL_OW 427
// end ;
48429: LD_VAR 0 1
48433: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48434: LD_INT 0
48436: PPUSH
48437: PPUSH
48438: PPUSH
48439: PPUSH
48440: PPUSH
48441: PPUSH
48442: PPUSH
// if not mc_bases then
48443: LD_EXP 102
48447: NOT
48448: IFFALSE 48452
// exit ;
48450: GO 49016
// for i = 1 to mc_bases do
48452: LD_ADDR_VAR 0 2
48456: PUSH
48457: DOUBLE
48458: LD_INT 1
48460: DEC
48461: ST_TO_ADDR
48462: LD_EXP 102
48466: PUSH
48467: FOR_TO
48468: IFFALSE 49007
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48470: LD_ADDR_VAR 0 5
48474: PUSH
48475: LD_EXP 102
48479: PUSH
48480: LD_VAR 0 2
48484: ARRAY
48485: PUSH
48486: LD_EXP 131
48490: PUSH
48491: LD_VAR 0 2
48495: ARRAY
48496: UNION
48497: PPUSH
48498: LD_INT 21
48500: PUSH
48501: LD_INT 1
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 1
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: LD_INT 54
48516: PUSH
48517: EMPTY
48518: LIST
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 3
48526: PUSH
48527: LD_INT 24
48529: PUSH
48530: LD_INT 1000
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: LIST
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PPUSH
48550: CALL_OW 72
48554: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48555: LD_ADDR_VAR 0 6
48559: PUSH
48560: LD_EXP 102
48564: PUSH
48565: LD_VAR 0 2
48569: ARRAY
48570: PPUSH
48571: LD_INT 21
48573: PUSH
48574: LD_INT 1
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: PUSH
48581: LD_INT 1
48583: PUSH
48584: LD_INT 3
48586: PUSH
48587: LD_INT 54
48589: PUSH
48590: EMPTY
48591: LIST
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 3
48599: PUSH
48600: LD_INT 24
48602: PUSH
48603: LD_INT 250
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: LIST
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PPUSH
48623: CALL_OW 72
48627: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48628: LD_ADDR_VAR 0 7
48632: PUSH
48633: LD_VAR 0 5
48637: PUSH
48638: LD_VAR 0 6
48642: DIFF
48643: ST_TO_ADDR
// if not need_heal_1 then
48644: LD_VAR 0 6
48648: NOT
48649: IFFALSE 48682
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48651: LD_ADDR_EXP 105
48655: PUSH
48656: LD_EXP 105
48660: PPUSH
48661: LD_VAR 0 2
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PPUSH
48673: EMPTY
48674: PPUSH
48675: CALL 76047 0 3
48679: ST_TO_ADDR
48680: GO 48752
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48682: LD_ADDR_EXP 105
48686: PUSH
48687: LD_EXP 105
48691: PPUSH
48692: LD_VAR 0 2
48696: PUSH
48697: LD_INT 1
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PPUSH
48704: LD_EXP 105
48708: PUSH
48709: LD_VAR 0 2
48713: ARRAY
48714: PUSH
48715: LD_INT 1
48717: ARRAY
48718: PPUSH
48719: LD_INT 3
48721: PUSH
48722: LD_INT 24
48724: PUSH
48725: LD_INT 1000
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PPUSH
48736: CALL_OW 72
48740: PUSH
48741: LD_VAR 0 6
48745: UNION
48746: PPUSH
48747: CALL 76047 0 3
48751: ST_TO_ADDR
// if not need_heal_2 then
48752: LD_VAR 0 7
48756: NOT
48757: IFFALSE 48790
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48759: LD_ADDR_EXP 105
48763: PUSH
48764: LD_EXP 105
48768: PPUSH
48769: LD_VAR 0 2
48773: PUSH
48774: LD_INT 2
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PPUSH
48781: EMPTY
48782: PPUSH
48783: CALL 76047 0 3
48787: ST_TO_ADDR
48788: GO 48822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48790: LD_ADDR_EXP 105
48794: PUSH
48795: LD_EXP 105
48799: PPUSH
48800: LD_VAR 0 2
48804: PUSH
48805: LD_INT 2
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PPUSH
48812: LD_VAR 0 7
48816: PPUSH
48817: CALL 76047 0 3
48821: ST_TO_ADDR
// if need_heal_2 then
48822: LD_VAR 0 7
48826: IFFALSE 48987
// for j in need_heal_2 do
48828: LD_ADDR_VAR 0 3
48832: PUSH
48833: LD_VAR 0 7
48837: PUSH
48838: FOR_IN
48839: IFFALSE 48985
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48841: LD_ADDR_VAR 0 5
48845: PUSH
48846: LD_EXP 102
48850: PUSH
48851: LD_VAR 0 2
48855: ARRAY
48856: PPUSH
48857: LD_INT 2
48859: PUSH
48860: LD_INT 30
48862: PUSH
48863: LD_INT 6
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 30
48872: PUSH
48873: LD_INT 7
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 30
48882: PUSH
48883: LD_INT 8
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 30
48892: PUSH
48893: LD_INT 0
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 30
48902: PUSH
48903: LD_INT 1
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: PPUSH
48918: CALL_OW 72
48922: ST_TO_ADDR
// if tmp then
48923: LD_VAR 0 5
48927: IFFALSE 48983
// begin k := NearestUnitToUnit ( tmp , j ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: LD_VAR 0 3
48943: PPUSH
48944: CALL_OW 74
48948: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48949: LD_VAR 0 3
48953: PPUSH
48954: LD_VAR 0 4
48958: PPUSH
48959: CALL_OW 296
48963: PUSH
48964: LD_INT 5
48966: GREATER
48967: IFFALSE 48983
// ComMoveToNearbyEntrance ( j , k ) ;
48969: LD_VAR 0 3
48973: PPUSH
48974: LD_VAR 0 4
48978: PPUSH
48979: CALL 109974 0 2
// end ; end ;
48983: GO 48838
48985: POP
48986: POP
// if not need_heal_1 and not need_heal_2 then
48987: LD_VAR 0 6
48991: NOT
48992: IFFALSE 49001
48994: PUSH
48995: LD_VAR 0 7
48999: NOT
49000: AND
49001: IFFALSE 49005
// continue ;
49003: GO 48467
// end ;
49005: GO 48467
49007: POP
49008: POP
// RaiseSailEvent ( 102 ) ;
49009: LD_INT 102
49011: PPUSH
49012: CALL_OW 427
// end ;
49016: LD_VAR 0 1
49020: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
49021: LD_INT 0
49023: PPUSH
49024: PPUSH
49025: PPUSH
49026: PPUSH
49027: PPUSH
49028: PPUSH
49029: PPUSH
49030: PPUSH
// if not mc_bases then
49031: LD_EXP 102
49035: NOT
49036: IFFALSE 49040
// exit ;
49038: GO 49955
// for i = 1 to mc_bases do
49040: LD_ADDR_VAR 0 2
49044: PUSH
49045: DOUBLE
49046: LD_INT 1
49048: DEC
49049: ST_TO_ADDR
49050: LD_EXP 102
49054: PUSH
49055: FOR_TO
49056: IFFALSE 49953
// begin if not mc_building_need_repair [ i ] then
49058: LD_EXP 103
49062: PUSH
49063: LD_VAR 0 2
49067: ARRAY
49068: NOT
49069: IFFALSE 49254
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
49071: LD_ADDR_VAR 0 6
49075: PUSH
49076: LD_EXP 121
49080: PUSH
49081: LD_VAR 0 2
49085: ARRAY
49086: PPUSH
49087: LD_INT 3
49089: PUSH
49090: LD_INT 24
49092: PUSH
49093: LD_INT 1000
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 2
49106: PUSH
49107: LD_INT 34
49109: PUSH
49110: LD_INT 13
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 34
49119: PUSH
49120: LD_INT 52
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 34
49129: PUSH
49130: LD_INT 88
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PPUSH
49147: CALL_OW 72
49151: ST_TO_ADDR
// if cranes then
49152: LD_VAR 0 6
49156: IFFALSE 49218
// for j in cranes do
49158: LD_ADDR_VAR 0 3
49162: PUSH
49163: LD_VAR 0 6
49167: PUSH
49168: FOR_IN
49169: IFFALSE 49216
// if not IsInArea ( j , mc_parking [ i ] ) then
49171: LD_VAR 0 3
49175: PPUSH
49176: LD_EXP 126
49180: PUSH
49181: LD_VAR 0 2
49185: ARRAY
49186: PPUSH
49187: CALL_OW 308
49191: NOT
49192: IFFALSE 49214
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49194: LD_VAR 0 3
49198: PPUSH
49199: LD_EXP 126
49203: PUSH
49204: LD_VAR 0 2
49208: ARRAY
49209: PPUSH
49210: CALL_OW 113
49214: GO 49168
49216: POP
49217: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49218: LD_ADDR_EXP 104
49222: PUSH
49223: LD_EXP 104
49227: PPUSH
49228: LD_VAR 0 2
49232: PPUSH
49233: EMPTY
49234: PPUSH
49235: CALL_OW 1
49239: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
49240: LD_VAR 0 2
49244: PPUSH
49245: LD_INT 101
49247: PPUSH
49248: CALL 44046 0 2
// continue ;
49252: GO 49055
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
49254: LD_ADDR_EXP 108
49258: PUSH
49259: LD_EXP 108
49263: PPUSH
49264: LD_VAR 0 2
49268: PPUSH
49269: EMPTY
49270: PPUSH
49271: CALL_OW 1
49275: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49276: LD_VAR 0 2
49280: PPUSH
49281: LD_INT 103
49283: PPUSH
49284: CALL 44046 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
49288: LD_ADDR_VAR 0 5
49292: PUSH
49293: LD_EXP 102
49297: PUSH
49298: LD_VAR 0 2
49302: ARRAY
49303: PUSH
49304: LD_EXP 131
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: UNION
49315: PPUSH
49316: LD_INT 2
49318: PUSH
49319: LD_INT 25
49321: PUSH
49322: LD_INT 2
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PUSH
49329: LD_INT 25
49331: PUSH
49332: LD_INT 16
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: LIST
49343: PUSH
49344: EMPTY
49345: LIST
49346: PPUSH
49347: CALL_OW 72
49351: ST_TO_ADDR
// if mc_need_heal [ i ] then
49352: LD_EXP 105
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: IFFALSE 49406
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49364: LD_ADDR_VAR 0 5
49368: PUSH
49369: LD_VAR 0 5
49373: PUSH
49374: LD_EXP 105
49378: PUSH
49379: LD_VAR 0 2
49383: ARRAY
49384: PUSH
49385: LD_INT 1
49387: ARRAY
49388: PUSH
49389: LD_EXP 105
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: PUSH
49400: LD_INT 2
49402: ARRAY
49403: UNION
49404: DIFF
49405: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49406: LD_ADDR_VAR 0 6
49410: PUSH
49411: LD_EXP 121
49415: PUSH
49416: LD_VAR 0 2
49420: ARRAY
49421: PPUSH
49422: LD_INT 2
49424: PUSH
49425: LD_INT 34
49427: PUSH
49428: LD_INT 13
49430: PUSH
49431: EMPTY
49432: LIST
49433: LIST
49434: PUSH
49435: LD_INT 34
49437: PUSH
49438: LD_INT 52
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 34
49447: PUSH
49448: LD_INT 88
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: PPUSH
49461: CALL_OW 72
49465: ST_TO_ADDR
// if cranes then
49466: LD_VAR 0 6
49470: IFFALSE 49642
// begin for j in cranes do
49472: LD_ADDR_VAR 0 3
49476: PUSH
49477: LD_VAR 0 6
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49640
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49485: LD_VAR 0 3
49489: PPUSH
49490: CALL_OW 256
49494: PUSH
49495: LD_INT 1000
49497: EQUAL
49498: IFFALSE 49512
49500: PUSH
49501: LD_VAR 0 3
49505: PPUSH
49506: CALL_OW 314
49510: NOT
49511: AND
49512: IFFALSE 49578
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49514: LD_ADDR_VAR 0 8
49518: PUSH
49519: LD_EXP 103
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PPUSH
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 74
49539: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49540: LD_VAR 0 8
49544: PPUSH
49545: LD_INT 16
49547: PPUSH
49548: CALL 79026 0 2
49552: PUSH
49553: LD_INT 4
49555: ARRAY
49556: PUSH
49557: LD_INT 10
49559: LESS
49560: IFFALSE 49576
// ComRepairBuilding ( j , to_repair ) ;
49562: LD_VAR 0 3
49566: PPUSH
49567: LD_VAR 0 8
49571: PPUSH
49572: CALL_OW 130
// end else
49576: GO 49638
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 256
49587: PUSH
49588: LD_INT 500
49590: LESS
49591: IFFALSE 49616
49593: PUSH
49594: LD_VAR 0 3
49598: PPUSH
49599: LD_EXP 126
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: CALL_OW 308
49614: NOT
49615: AND
49616: IFFALSE 49638
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49618: LD_VAR 0 3
49622: PPUSH
49623: LD_EXP 126
49627: PUSH
49628: LD_VAR 0 2
49632: ARRAY
49633: PPUSH
49634: CALL_OW 113
// end ;
49638: GO 49482
49640: POP
49641: POP
// end ; if tmp > 3 then
49642: LD_VAR 0 5
49646: PUSH
49647: LD_INT 3
49649: GREATER
49650: IFFALSE 49670
// tmp := ShrinkArray ( tmp , 4 ) ;
49652: LD_ADDR_VAR 0 5
49656: PUSH
49657: LD_VAR 0 5
49661: PPUSH
49662: LD_INT 4
49664: PPUSH
49665: CALL 109410 0 2
49669: ST_TO_ADDR
// if not tmp then
49670: LD_VAR 0 5
49674: NOT
49675: IFFALSE 49679
// continue ;
49677: GO 49055
// for j in tmp do
49679: LD_ADDR_VAR 0 3
49683: PUSH
49684: LD_VAR 0 5
49688: PUSH
49689: FOR_IN
49690: IFFALSE 49949
// begin if IsInUnit ( j ) then
49692: LD_VAR 0 3
49696: PPUSH
49697: CALL_OW 310
49701: IFFALSE 49712
// ComExitBuilding ( j ) ;
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49712: LD_VAR 0 3
49716: PUSH
49717: LD_EXP 104
49721: PUSH
49722: LD_VAR 0 2
49726: ARRAY
49727: IN
49728: NOT
49729: IFFALSE 49787
// begin SetTag ( j , 101 ) ;
49731: LD_VAR 0 3
49735: PPUSH
49736: LD_INT 101
49738: PPUSH
49739: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49743: LD_ADDR_EXP 104
49747: PUSH
49748: LD_EXP 104
49752: PPUSH
49753: LD_VAR 0 2
49757: PUSH
49758: LD_EXP 104
49762: PUSH
49763: LD_VAR 0 2
49767: ARRAY
49768: PUSH
49769: LD_INT 1
49771: PLUS
49772: PUSH
49773: EMPTY
49774: LIST
49775: LIST
49776: PPUSH
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL 76047 0 3
49786: ST_TO_ADDR
// end ; wait ( 1 ) ;
49787: LD_INT 1
49789: PPUSH
49790: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49794: LD_ADDR_VAR 0 7
49798: PUSH
49799: LD_EXP 103
49803: PUSH
49804: LD_VAR 0 2
49808: ARRAY
49809: ST_TO_ADDR
// if mc_scan [ i ] then
49810: LD_EXP 125
49814: PUSH
49815: LD_VAR 0 2
49819: ARRAY
49820: IFFALSE 49882
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49822: LD_ADDR_VAR 0 7
49826: PUSH
49827: LD_EXP 103
49831: PUSH
49832: LD_VAR 0 2
49836: ARRAY
49837: PPUSH
49838: LD_INT 3
49840: PUSH
49841: LD_INT 30
49843: PUSH
49844: LD_INT 32
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: PUSH
49851: LD_INT 30
49853: PUSH
49854: LD_INT 33
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: LD_INT 30
49863: PUSH
49864: LD_INT 31
49866: PUSH
49867: EMPTY
49868: LIST
49869: LIST
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: PPUSH
49877: CALL_OW 72
49881: ST_TO_ADDR
// if not to_repair_tmp then
49882: LD_VAR 0 7
49886: NOT
49887: IFFALSE 49891
// continue ;
49889: GO 49689
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49891: LD_ADDR_VAR 0 8
49895: PUSH
49896: LD_VAR 0 7
49900: PPUSH
49901: LD_VAR 0 3
49905: PPUSH
49906: CALL_OW 74
49910: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49911: LD_VAR 0 8
49915: PPUSH
49916: LD_INT 16
49918: PPUSH
49919: CALL 79026 0 2
49923: PUSH
49924: LD_INT 4
49926: ARRAY
49927: PUSH
49928: LD_INT 14
49930: LESS
49931: IFFALSE 49947
// ComRepairBuilding ( j , to_repair ) ;
49933: LD_VAR 0 3
49937: PPUSH
49938: LD_VAR 0 8
49942: PPUSH
49943: CALL_OW 130
// end ;
49947: GO 49689
49949: POP
49950: POP
// end ;
49951: GO 49055
49953: POP
49954: POP
// end ;
49955: LD_VAR 0 1
49959: RET
// export function MC_Heal ; var i , j , tmp ; begin
49960: LD_INT 0
49962: PPUSH
49963: PPUSH
49964: PPUSH
49965: PPUSH
// if not mc_bases then
49966: LD_EXP 102
49970: NOT
49971: IFFALSE 49975
// exit ;
49973: GO 50381
// for i = 1 to mc_bases do
49975: LD_ADDR_VAR 0 2
49979: PUSH
49980: DOUBLE
49981: LD_INT 1
49983: DEC
49984: ST_TO_ADDR
49985: LD_EXP 102
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50379
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49993: LD_EXP 105
49997: PUSH
49998: LD_VAR 0 2
50002: ARRAY
50003: PUSH
50004: LD_INT 1
50006: ARRAY
50007: NOT
50008: IFFALSE 50027
50010: PUSH
50011: LD_EXP 105
50015: PUSH
50016: LD_VAR 0 2
50020: ARRAY
50021: PUSH
50022: LD_INT 2
50024: ARRAY
50025: NOT
50026: AND
50027: IFFALSE 50065
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
50029: LD_ADDR_EXP 106
50033: PUSH
50034: LD_EXP 106
50038: PPUSH
50039: LD_VAR 0 2
50043: PPUSH
50044: EMPTY
50045: PPUSH
50046: CALL_OW 1
50050: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
50051: LD_VAR 0 2
50055: PPUSH
50056: LD_INT 102
50058: PPUSH
50059: CALL 44046 0 2
// continue ;
50063: GO 49990
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
50065: LD_ADDR_VAR 0 4
50069: PUSH
50070: LD_EXP 102
50074: PUSH
50075: LD_VAR 0 2
50079: ARRAY
50080: PPUSH
50081: LD_INT 25
50083: PUSH
50084: LD_INT 4
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PPUSH
50091: CALL_OW 72
50095: ST_TO_ADDR
// if not tmp then
50096: LD_VAR 0 4
50100: NOT
50101: IFFALSE 50105
// continue ;
50103: GO 49990
// if mc_taming [ i ] then
50105: LD_EXP 133
50109: PUSH
50110: LD_VAR 0 2
50114: ARRAY
50115: IFFALSE 50139
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50117: LD_ADDR_EXP 133
50121: PUSH
50122: LD_EXP 133
50126: PPUSH
50127: LD_VAR 0 2
50131: PPUSH
50132: EMPTY
50133: PPUSH
50134: CALL_OW 1
50138: ST_TO_ADDR
// for j in tmp do
50139: LD_ADDR_VAR 0 3
50143: PUSH
50144: LD_VAR 0 4
50148: PUSH
50149: FOR_IN
50150: IFFALSE 50375
// begin if IsInUnit ( j ) then
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 310
50161: IFFALSE 50172
// ComExitBuilding ( j ) ;
50163: LD_VAR 0 3
50167: PPUSH
50168: CALL_OW 122
// if not j in mc_healers [ i ] then
50172: LD_VAR 0 3
50176: PUSH
50177: LD_EXP 106
50181: PUSH
50182: LD_VAR 0 2
50186: ARRAY
50187: IN
50188: NOT
50189: IFFALSE 50235
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
50191: LD_ADDR_EXP 106
50195: PUSH
50196: LD_EXP 106
50200: PPUSH
50201: LD_VAR 0 2
50205: PUSH
50206: LD_EXP 106
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: PUSH
50217: LD_INT 1
50219: PLUS
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PPUSH
50225: LD_VAR 0 3
50229: PPUSH
50230: CALL 76047 0 3
50234: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 110
50244: PUSH
50245: LD_INT 102
50247: NONEQUAL
50248: IFFALSE 50262
// SetTag ( j , 102 ) ;
50250: LD_VAR 0 3
50254: PPUSH
50255: LD_INT 102
50257: PPUSH
50258: CALL_OW 109
// Wait ( 3 ) ;
50262: LD_INT 3
50264: PPUSH
50265: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
50269: LD_EXP 105
50273: PUSH
50274: LD_VAR 0 2
50278: ARRAY
50279: PUSH
50280: LD_INT 1
50282: ARRAY
50283: IFFALSE 50315
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
50285: LD_VAR 0 3
50289: PPUSH
50290: LD_EXP 105
50294: PUSH
50295: LD_VAR 0 2
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PPUSH
50309: CALL_OW 128
50313: GO 50373
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
50315: LD_VAR 0 3
50319: PPUSH
50320: CALL_OW 314
50324: NOT
50325: IFFALSE 50343
50327: PUSH
50328: LD_EXP 105
50332: PUSH
50333: LD_VAR 0 2
50337: ARRAY
50338: PUSH
50339: LD_INT 2
50341: ARRAY
50342: AND
50343: IFFALSE 50373
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
50345: LD_VAR 0 3
50349: PPUSH
50350: LD_EXP 105
50354: PUSH
50355: LD_VAR 0 2
50359: ARRAY
50360: PUSH
50361: LD_INT 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PPUSH
50369: CALL_OW 128
// end ;
50373: GO 50149
50375: POP
50376: POP
// end ;
50377: GO 49990
50379: POP
50380: POP
// end ;
50381: LD_VAR 0 1
50385: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50386: LD_INT 0
50388: PPUSH
50389: PPUSH
50390: PPUSH
50391: PPUSH
50392: PPUSH
50393: PPUSH
// if not mc_bases then
50394: LD_EXP 102
50398: NOT
50399: IFFALSE 50403
// exit ;
50401: GO 51574
// for i = 1 to mc_bases do
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: DOUBLE
50409: LD_INT 1
50411: DEC
50412: ST_TO_ADDR
50413: LD_EXP 102
50417: PUSH
50418: FOR_TO
50419: IFFALSE 51572
// begin if mc_scan [ i ] then
50421: LD_EXP 125
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: IFFALSE 50435
// continue ;
50433: GO 50418
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50435: LD_EXP 107
50439: PUSH
50440: LD_VAR 0 2
50444: ARRAY
50445: NOT
50446: IFFALSE 50461
50448: PUSH
50449: LD_EXP 109
50453: PUSH
50454: LD_VAR 0 2
50458: ARRAY
50459: NOT
50460: AND
50461: IFFALSE 50475
50463: PUSH
50464: LD_EXP 108
50468: PUSH
50469: LD_VAR 0 2
50473: ARRAY
50474: AND
50475: IFFALSE 50513
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50477: LD_ADDR_EXP 108
50481: PUSH
50482: LD_EXP 108
50486: PPUSH
50487: LD_VAR 0 2
50491: PPUSH
50492: EMPTY
50493: PPUSH
50494: CALL_OW 1
50498: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50499: LD_VAR 0 2
50503: PPUSH
50504: LD_INT 103
50506: PPUSH
50507: CALL 44046 0 2
// continue ;
50511: GO 50418
// end ; if mc_construct_list [ i ] then
50513: LD_EXP 109
50517: PUSH
50518: LD_VAR 0 2
50522: ARRAY
50523: IFFALSE 50743
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50525: LD_ADDR_VAR 0 5
50529: PUSH
50530: LD_EXP 102
50534: PUSH
50535: LD_VAR 0 2
50539: ARRAY
50540: PPUSH
50541: LD_INT 25
50543: PUSH
50544: LD_INT 2
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PPUSH
50551: CALL_OW 72
50555: PUSH
50556: LD_EXP 104
50560: PUSH
50561: LD_VAR 0 2
50565: ARRAY
50566: DIFF
50567: ST_TO_ADDR
// if not tmp then
50568: LD_VAR 0 5
50572: NOT
50573: IFFALSE 50577
// continue ;
50575: GO 50418
// for j in tmp do
50577: LD_ADDR_VAR 0 3
50581: PUSH
50582: LD_VAR 0 5
50586: PUSH
50587: FOR_IN
50588: IFFALSE 50739
// begin if not mc_builders [ i ] then
50590: LD_EXP 108
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: NOT
50601: IFFALSE 50659
// begin SetTag ( j , 103 ) ;
50603: LD_VAR 0 3
50607: PPUSH
50608: LD_INT 103
50610: PPUSH
50611: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50615: LD_ADDR_EXP 108
50619: PUSH
50620: LD_EXP 108
50624: PPUSH
50625: LD_VAR 0 2
50629: PUSH
50630: LD_EXP 108
50634: PUSH
50635: LD_VAR 0 2
50639: ARRAY
50640: PUSH
50641: LD_INT 1
50643: PLUS
50644: PUSH
50645: EMPTY
50646: LIST
50647: LIST
50648: PPUSH
50649: LD_VAR 0 3
50653: PPUSH
50654: CALL 76047 0 3
50658: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50659: LD_VAR 0 3
50663: PPUSH
50664: CALL_OW 310
50668: IFFALSE 50679
// ComExitBuilding ( j ) ;
50670: LD_VAR 0 3
50674: PPUSH
50675: CALL_OW 122
// wait ( 3 ) ;
50679: LD_INT 3
50681: PPUSH
50682: CALL_OW 67
// if not mc_construct_list [ i ] then
50686: LD_EXP 109
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: NOT
50697: IFFALSE 50701
// break ;
50699: GO 50739
// if not HasTask ( j ) then
50701: LD_VAR 0 3
50705: PPUSH
50706: CALL_OW 314
50710: NOT
50711: IFFALSE 50737
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50713: LD_VAR 0 3
50717: PPUSH
50718: LD_EXP 109
50722: PUSH
50723: LD_VAR 0 2
50727: ARRAY
50728: PUSH
50729: LD_INT 1
50731: ARRAY
50732: PPUSH
50733: CALL 79299 0 2
// end ;
50737: GO 50587
50739: POP
50740: POP
// end else
50741: GO 51570
// if mc_build_list [ i ] then
50743: LD_EXP 107
50747: PUSH
50748: LD_VAR 0 2
50752: ARRAY
50753: IFFALSE 51570
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50755: LD_EXP 107
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: PUSH
50766: LD_INT 1
50768: ARRAY
50769: PUSH
50770: LD_INT 1
50772: ARRAY
50773: PPUSH
50774: CALL 79123 0 1
50778: IFFALSE 50826
50780: PUSH
50781: LD_EXP 102
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: PPUSH
50792: LD_INT 2
50794: PUSH
50795: LD_INT 30
50797: PUSH
50798: LD_INT 2
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: LD_INT 30
50807: PUSH
50808: LD_INT 3
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: LIST
50819: PPUSH
50820: CALL_OW 72
50824: NOT
50825: AND
50826: IFFALSE 50931
// begin for j = 1 to mc_build_list [ i ] do
50828: LD_ADDR_VAR 0 3
50832: PUSH
50833: DOUBLE
50834: LD_INT 1
50836: DEC
50837: ST_TO_ADDR
50838: LD_EXP 107
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: FOR_TO
50850: IFFALSE 50929
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50852: LD_EXP 107
50856: PUSH
50857: LD_VAR 0 2
50861: ARRAY
50862: PUSH
50863: LD_VAR 0 3
50867: ARRAY
50868: PUSH
50869: LD_INT 1
50871: ARRAY
50872: PUSH
50873: LD_INT 2
50875: EQUAL
50876: IFFALSE 50927
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50878: LD_ADDR_EXP 107
50882: PUSH
50883: LD_EXP 107
50887: PPUSH
50888: LD_VAR 0 2
50892: PPUSH
50893: LD_EXP 107
50897: PUSH
50898: LD_VAR 0 2
50902: ARRAY
50903: PPUSH
50904: LD_VAR 0 3
50908: PPUSH
50909: LD_INT 1
50911: PPUSH
50912: LD_INT 0
50914: PPUSH
50915: CALL 75455 0 4
50919: PPUSH
50920: CALL_OW 1
50924: ST_TO_ADDR
// break ;
50925: GO 50929
// end ;
50927: GO 50849
50929: POP
50930: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50931: LD_ADDR_VAR 0 6
50935: PUSH
50936: LD_EXP 102
50940: PUSH
50941: LD_VAR 0 2
50945: ARRAY
50946: PPUSH
50947: LD_INT 2
50949: PUSH
50950: LD_INT 30
50952: PUSH
50953: LD_INT 0
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 30
50962: PUSH
50963: LD_INT 1
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: LIST
50974: PPUSH
50975: CALL_OW 72
50979: ST_TO_ADDR
// for k := 1 to depot do
50980: LD_ADDR_VAR 0 4
50984: PUSH
50985: DOUBLE
50986: LD_INT 1
50988: DEC
50989: ST_TO_ADDR
50990: LD_VAR 0 6
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51568
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50998: LD_EXP 107
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PUSH
51013: LD_INT 1
51015: ARRAY
51016: PUSH
51017: LD_INT 0
51019: EQUAL
51020: IFTRUE 51115
51022: PUSH
51023: LD_VAR 0 6
51027: PUSH
51028: LD_VAR 0 4
51032: ARRAY
51033: PPUSH
51034: LD_EXP 107
51038: PUSH
51039: LD_VAR 0 2
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: LD_EXP 107
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_INT 1
51066: ARRAY
51067: PUSH
51068: LD_INT 2
51070: ARRAY
51071: PPUSH
51072: LD_EXP 107
51076: PUSH
51077: LD_VAR 0 2
51081: ARRAY
51082: PUSH
51083: LD_INT 1
51085: ARRAY
51086: PUSH
51087: LD_INT 3
51089: ARRAY
51090: PPUSH
51091: LD_EXP 107
51095: PUSH
51096: LD_VAR 0 2
51100: ARRAY
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 4
51108: ARRAY
51109: PPUSH
51110: CALL 84603 0 5
51114: OR
51115: IFFALSE 51396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51117: LD_ADDR_VAR 0 5
51121: PUSH
51122: LD_EXP 102
51126: PUSH
51127: LD_VAR 0 2
51131: ARRAY
51132: PPUSH
51133: LD_INT 25
51135: PUSH
51136: LD_INT 2
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PPUSH
51143: CALL_OW 72
51147: PUSH
51148: LD_EXP 104
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: DIFF
51159: ST_TO_ADDR
// if not tmp then
51160: LD_VAR 0 5
51164: NOT
51165: IFFALSE 51169
// continue ;
51167: GO 50995
// for j in tmp do
51169: LD_ADDR_VAR 0 3
51173: PUSH
51174: LD_VAR 0 5
51178: PUSH
51179: FOR_IN
51180: IFFALSE 51392
// begin if not mc_builders [ i ] then
51182: LD_EXP 108
51186: PUSH
51187: LD_VAR 0 2
51191: ARRAY
51192: NOT
51193: IFFALSE 51251
// begin SetTag ( j , 103 ) ;
51195: LD_VAR 0 3
51199: PPUSH
51200: LD_INT 103
51202: PPUSH
51203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
51207: LD_ADDR_EXP 108
51211: PUSH
51212: LD_EXP 108
51216: PPUSH
51217: LD_VAR 0 2
51221: PUSH
51222: LD_EXP 108
51226: PUSH
51227: LD_VAR 0 2
51231: ARRAY
51232: PUSH
51233: LD_INT 1
51235: PLUS
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PPUSH
51241: LD_VAR 0 3
51245: PPUSH
51246: CALL 76047 0 3
51250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
51251: LD_VAR 0 3
51255: PPUSH
51256: CALL_OW 310
51260: IFFALSE 51271
// ComExitBuilding ( j ) ;
51262: LD_VAR 0 3
51266: PPUSH
51267: CALL_OW 122
// wait ( 3 ) ;
51271: LD_INT 3
51273: PPUSH
51274: CALL_OW 67
// if not mc_build_list [ i ] then
51278: LD_EXP 107
51282: PUSH
51283: LD_VAR 0 2
51287: ARRAY
51288: NOT
51289: IFFALSE 51293
// break ;
51291: GO 51392
// if not HasTask ( j ) then
51293: LD_VAR 0 3
51297: PPUSH
51298: CALL_OW 314
51302: NOT
51303: IFFALSE 51390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
51305: LD_VAR 0 3
51309: PPUSH
51310: LD_EXP 107
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PUSH
51321: LD_INT 1
51323: ARRAY
51324: PUSH
51325: LD_INT 1
51327: ARRAY
51328: PPUSH
51329: LD_EXP 107
51333: PUSH
51334: LD_VAR 0 2
51338: ARRAY
51339: PUSH
51340: LD_INT 1
51342: ARRAY
51343: PUSH
51344: LD_INT 2
51346: ARRAY
51347: PPUSH
51348: LD_EXP 107
51352: PUSH
51353: LD_VAR 0 2
51357: ARRAY
51358: PUSH
51359: LD_INT 1
51361: ARRAY
51362: PUSH
51363: LD_INT 3
51365: ARRAY
51366: PPUSH
51367: LD_EXP 107
51371: PUSH
51372: LD_VAR 0 2
51376: ARRAY
51377: PUSH
51378: LD_INT 1
51380: ARRAY
51381: PUSH
51382: LD_INT 4
51384: ARRAY
51385: PPUSH
51386: CALL_OW 145
// end ;
51390: GO 51179
51392: POP
51393: POP
// end else
51394: GO 51566
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51396: LD_EXP 102
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PPUSH
51407: LD_EXP 107
51411: PUSH
51412: LD_VAR 0 2
51416: ARRAY
51417: PUSH
51418: LD_INT 1
51420: ARRAY
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PPUSH
51426: LD_EXP 107
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: PUSH
51437: LD_INT 1
51439: ARRAY
51440: PUSH
51441: LD_INT 2
51443: ARRAY
51444: PPUSH
51445: LD_EXP 107
51449: PUSH
51450: LD_VAR 0 2
51454: ARRAY
51455: PUSH
51456: LD_INT 1
51458: ARRAY
51459: PUSH
51460: LD_INT 3
51462: ARRAY
51463: PPUSH
51464: LD_EXP 107
51468: PUSH
51469: LD_VAR 0 2
51473: ARRAY
51474: PUSH
51475: LD_INT 1
51477: ARRAY
51478: PUSH
51479: LD_INT 4
51481: ARRAY
51482: PPUSH
51483: LD_EXP 102
51487: PUSH
51488: LD_VAR 0 2
51492: ARRAY
51493: PPUSH
51494: LD_INT 21
51496: PUSH
51497: LD_INT 3
51499: PUSH
51500: EMPTY
51501: LIST
51502: LIST
51503: PPUSH
51504: CALL_OW 72
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL 83339 0 7
51515: NOT
51516: IFFALSE 51566
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51518: LD_ADDR_EXP 107
51522: PUSH
51523: LD_EXP 107
51527: PPUSH
51528: LD_VAR 0 2
51532: PPUSH
51533: LD_EXP 107
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: PPUSH
51544: LD_INT 1
51546: PPUSH
51547: LD_INT 1
51549: NEG
51550: PPUSH
51551: LD_INT 0
51553: PPUSH
51554: CALL 75455 0 4
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// continue ;
51564: GO 50995
// end ; end ;
51566: GO 50995
51568: POP
51569: POP
// end ; end ;
51570: GO 50418
51572: POP
51573: POP
// end ;
51574: LD_VAR 0 1
51578: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51579: LD_INT 0
51581: PPUSH
51582: PPUSH
51583: PPUSH
51584: PPUSH
51585: PPUSH
51586: PPUSH
// if not mc_bases then
51587: LD_EXP 102
51591: NOT
51592: IFFALSE 51596
// exit ;
51594: GO 52029
// for i = 1 to mc_bases do
51596: LD_ADDR_VAR 0 2
51600: PUSH
51601: DOUBLE
51602: LD_INT 1
51604: DEC
51605: ST_TO_ADDR
51606: LD_EXP 102
51610: PUSH
51611: FOR_TO
51612: IFFALSE 52027
// begin tmp := mc_build_upgrade [ i ] ;
51614: LD_ADDR_VAR 0 4
51618: PUSH
51619: LD_EXP 134
51623: PUSH
51624: LD_VAR 0 2
51628: ARRAY
51629: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51630: LD_ADDR_VAR 0 6
51634: PUSH
51635: LD_EXP 135
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PPUSH
51646: LD_INT 2
51648: PUSH
51649: LD_INT 30
51651: PUSH
51652: LD_INT 6
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: PUSH
51659: LD_INT 30
51661: PUSH
51662: LD_INT 7
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: LIST
51673: PPUSH
51674: CALL_OW 72
51678: ST_TO_ADDR
// if not tmp and not lab then
51679: LD_VAR 0 4
51683: NOT
51684: IFFALSE 51693
51686: PUSH
51687: LD_VAR 0 6
51691: NOT
51692: AND
51693: IFFALSE 51697
// continue ;
51695: GO 51611
// if tmp then
51697: LD_VAR 0 4
51701: IFFALSE 51821
// for j in tmp do
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_VAR 0 4
51712: PUSH
51713: FOR_IN
51714: IFFALSE 51819
// begin if UpgradeCost ( j ) then
51716: LD_VAR 0 3
51720: PPUSH
51721: CALL 82991 0 1
51725: IFFALSE 51817
// begin ComUpgrade ( j ) ;
51727: LD_VAR 0 3
51731: PPUSH
51732: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51736: LD_ADDR_EXP 134
51740: PUSH
51741: LD_EXP 134
51745: PPUSH
51746: LD_VAR 0 2
51750: PPUSH
51751: LD_EXP 134
51755: PUSH
51756: LD_VAR 0 2
51760: ARRAY
51761: PUSH
51762: LD_VAR 0 3
51766: DIFF
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51773: LD_ADDR_EXP 109
51777: PUSH
51778: LD_EXP 109
51782: PPUSH
51783: LD_VAR 0 2
51787: PUSH
51788: LD_EXP 109
51792: PUSH
51793: LD_VAR 0 2
51797: ARRAY
51798: PUSH
51799: LD_INT 1
51801: PLUS
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PPUSH
51807: LD_VAR 0 3
51811: PPUSH
51812: CALL 76047 0 3
51816: ST_TO_ADDR
// end ; end ;
51817: GO 51713
51819: POP
51820: POP
// if not lab or not mc_lab_upgrade [ i ] then
51821: LD_VAR 0 6
51825: NOT
51826: IFTRUE 51841
51828: PUSH
51829: LD_EXP 136
51833: PUSH
51834: LD_VAR 0 2
51838: ARRAY
51839: NOT
51840: OR
51841: IFFALSE 51845
// continue ;
51843: GO 51611
// for j in lab do
51845: LD_ADDR_VAR 0 3
51849: PUSH
51850: LD_VAR 0 6
51854: PUSH
51855: FOR_IN
51856: IFFALSE 52023
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51858: LD_VAR 0 3
51862: PPUSH
51863: CALL_OW 266
51867: PUSH
51868: LD_INT 6
51870: PUSH
51871: LD_INT 7
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: IN
51878: IFFALSE 51895
51880: PUSH
51881: LD_VAR 0 3
51885: PPUSH
51886: CALL_OW 461
51890: PUSH
51891: LD_INT 1
51893: NONEQUAL
51894: AND
51895: IFFALSE 52021
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51897: LD_VAR 0 3
51901: PPUSH
51902: LD_EXP 136
51906: PUSH
51907: LD_VAR 0 2
51911: ARRAY
51912: PUSH
51913: LD_INT 1
51915: ARRAY
51916: PPUSH
51917: CALL 83200 0 2
51921: IFFALSE 52021
// begin ComCancel ( j ) ;
51923: LD_VAR 0 3
51927: PPUSH
51928: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51932: LD_VAR 0 3
51936: PPUSH
51937: LD_EXP 136
51941: PUSH
51942: LD_VAR 0 2
51946: ARRAY
51947: PUSH
51948: LD_INT 1
51950: ARRAY
51951: PPUSH
51952: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51956: LD_VAR 0 3
51960: PUSH
51961: LD_EXP 109
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: IN
51972: NOT
51973: IFFALSE 52019
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51975: LD_ADDR_EXP 109
51979: PUSH
51980: LD_EXP 109
51984: PPUSH
51985: LD_VAR 0 2
51989: PUSH
51990: LD_EXP 109
51994: PUSH
51995: LD_VAR 0 2
51999: ARRAY
52000: PUSH
52001: LD_INT 1
52003: PLUS
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PPUSH
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL 76047 0 3
52018: ST_TO_ADDR
// break ;
52019: GO 52023
// end ; end ; end ;
52021: GO 51855
52023: POP
52024: POP
// end ;
52025: GO 51611
52027: POP
52028: POP
// end ;
52029: LD_VAR 0 1
52033: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
52034: LD_INT 0
52036: PPUSH
52037: PPUSH
52038: PPUSH
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
52044: PPUSH
// if not mc_bases then
52045: LD_EXP 102
52049: NOT
52050: IFFALSE 52054
// exit ;
52052: GO 52461
// for i = 1 to mc_bases do
52054: LD_ADDR_VAR 0 2
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_EXP 102
52068: PUSH
52069: FOR_TO
52070: IFFALSE 52459
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
52072: LD_EXP 110
52076: PUSH
52077: LD_VAR 0 2
52081: ARRAY
52082: NOT
52083: IFTRUE 52113
52085: PUSH
52086: LD_EXP 102
52090: PUSH
52091: LD_VAR 0 2
52095: ARRAY
52096: PPUSH
52097: LD_INT 30
52099: PUSH
52100: LD_INT 3
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PPUSH
52107: CALL_OW 72
52111: NOT
52112: OR
52113: IFFALSE 52117
// continue ;
52115: GO 52069
// busy := false ;
52117: LD_ADDR_VAR 0 8
52121: PUSH
52122: LD_INT 0
52124: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52125: LD_ADDR_VAR 0 4
52129: PUSH
52130: LD_EXP 102
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PPUSH
52141: LD_INT 30
52143: PUSH
52144: LD_INT 3
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: PPUSH
52151: CALL_OW 72
52155: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
52156: LD_ADDR_VAR 0 6
52160: PUSH
52161: LD_EXP 110
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PPUSH
52172: LD_INT 2
52174: PUSH
52175: LD_INT 30
52177: PUSH
52178: LD_INT 32
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: PUSH
52185: LD_INT 30
52187: PUSH
52188: LD_INT 33
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: LIST
52199: PPUSH
52200: CALL_OW 72
52204: ST_TO_ADDR
// if not t then
52205: LD_VAR 0 6
52209: NOT
52210: IFFALSE 52214
// continue ;
52212: GO 52069
// for j in tmp do
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_VAR 0 4
52223: PUSH
52224: FOR_IN
52225: IFFALSE 52255
// if not BuildingStatus ( j ) = bs_idle then
52227: LD_VAR 0 3
52231: PPUSH
52232: CALL_OW 461
52236: PUSH
52237: LD_INT 2
52239: EQUAL
52240: NOT
52241: IFFALSE 52253
// begin busy := true ;
52243: LD_ADDR_VAR 0 8
52247: PUSH
52248: LD_INT 1
52250: ST_TO_ADDR
// break ;
52251: GO 52255
// end ;
52253: GO 52224
52255: POP
52256: POP
// if busy then
52257: LD_VAR 0 8
52261: IFFALSE 52265
// continue ;
52263: GO 52069
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
52265: LD_ADDR_VAR 0 7
52269: PUSH
52270: LD_VAR 0 6
52274: PPUSH
52275: LD_INT 35
52277: PUSH
52278: LD_INT 0
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PPUSH
52285: CALL_OW 72
52289: ST_TO_ADDR
// if tw then
52290: LD_VAR 0 7
52294: IFFALSE 52371
// begin tw := tw [ 1 ] ;
52296: LD_ADDR_VAR 0 7
52300: PUSH
52301: LD_VAR 0 7
52305: PUSH
52306: LD_INT 1
52308: ARRAY
52309: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
52310: LD_ADDR_VAR 0 9
52314: PUSH
52315: LD_VAR 0 7
52319: PPUSH
52320: LD_EXP 127
52324: PUSH
52325: LD_VAR 0 2
52329: ARRAY
52330: PPUSH
52331: CALL 81454 0 2
52335: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
52336: LD_EXP 141
52340: PUSH
52341: LD_VAR 0 2
52345: ARRAY
52346: IFFALSE 52369
// if not weapon in mc_allowed_tower_weapons [ i ] then
52348: LD_VAR 0 9
52352: PUSH
52353: LD_EXP 141
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: IN
52364: NOT
52365: IFFALSE 52369
// continue ;
52367: GO 52069
// end else
52369: GO 52434
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
52371: LD_ADDR_VAR 0 5
52375: PUSH
52376: LD_EXP 110
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: PPUSH
52387: LD_VAR 0 4
52391: PPUSH
52392: CALL 108639 0 2
52396: ST_TO_ADDR
// if not tmp2 then
52397: LD_VAR 0 5
52401: NOT
52402: IFFALSE 52406
// continue ;
52404: GO 52069
// tw := tmp2 [ 1 ] ;
52406: LD_ADDR_VAR 0 7
52410: PUSH
52411: LD_VAR 0 5
52415: PUSH
52416: LD_INT 1
52418: ARRAY
52419: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52420: LD_ADDR_VAR 0 9
52424: PUSH
52425: LD_VAR 0 5
52429: PUSH
52430: LD_INT 2
52432: ARRAY
52433: ST_TO_ADDR
// end ; if not weapon then
52434: LD_VAR 0 9
52438: NOT
52439: IFFALSE 52443
// continue ;
52441: GO 52069
// ComPlaceWeapon ( tw , weapon ) ;
52443: LD_VAR 0 7
52447: PPUSH
52448: LD_VAR 0 9
52452: PPUSH
52453: CALL_OW 148
// end ;
52457: GO 52069
52459: POP
52460: POP
// end ;
52461: LD_VAR 0 1
52465: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52466: LD_INT 0
52468: PPUSH
52469: PPUSH
52470: PPUSH
52471: PPUSH
52472: PPUSH
52473: PPUSH
52474: PPUSH
// if not mc_bases then
52475: LD_EXP 102
52479: NOT
52480: IFFALSE 52484
// exit ;
52482: GO 53271
// for i = 1 to mc_bases do
52484: LD_ADDR_VAR 0 2
52488: PUSH
52489: DOUBLE
52490: LD_INT 1
52492: DEC
52493: ST_TO_ADDR
52494: LD_EXP 102
52498: PUSH
52499: FOR_TO
52500: IFFALSE 53269
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52502: LD_EXP 115
52506: PUSH
52507: LD_VAR 0 2
52511: ARRAY
52512: NOT
52513: IFTRUE 52539
52515: PUSH
52516: LD_EXP 115
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: PUSH
52527: LD_EXP 116
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: EQUAL
52538: OR
52539: IFTRUE 52553
52541: PUSH
52542: LD_EXP 125
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: OR
52553: IFFALSE 52557
// continue ;
52555: GO 52499
// if mc_miners [ i ] then
52557: LD_EXP 116
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: IFFALSE 52954
// begin for j = mc_miners [ i ] downto 1 do
52569: LD_ADDR_VAR 0 3
52573: PUSH
52574: DOUBLE
52575: LD_EXP 116
52579: PUSH
52580: LD_VAR 0 2
52584: ARRAY
52585: INC
52586: ST_TO_ADDR
52587: LD_INT 1
52589: PUSH
52590: FOR_DOWNTO
52591: IFFALSE 52952
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52593: LD_EXP 116
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: PUSH
52604: LD_VAR 0 3
52608: ARRAY
52609: PPUSH
52610: CALL_OW 301
52614: IFTRUE 52643
52616: PUSH
52617: LD_EXP 116
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: PUSH
52628: LD_VAR 0 3
52632: ARRAY
52633: PPUSH
52634: CALL_OW 257
52638: PUSH
52639: LD_INT 1
52641: NONEQUAL
52642: OR
52643: IFFALSE 52706
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52645: LD_ADDR_VAR 0 5
52649: PUSH
52650: LD_EXP 116
52654: PUSH
52655: LD_VAR 0 2
52659: ARRAY
52660: PUSH
52661: LD_EXP 116
52665: PUSH
52666: LD_VAR 0 2
52670: ARRAY
52671: PUSH
52672: LD_VAR 0 3
52676: ARRAY
52677: DIFF
52678: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52679: LD_ADDR_EXP 116
52683: PUSH
52684: LD_EXP 116
52688: PPUSH
52689: LD_VAR 0 2
52693: PPUSH
52694: LD_VAR 0 5
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// continue ;
52704: GO 52590
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52706: LD_EXP 116
52710: PUSH
52711: LD_VAR 0 2
52715: ARRAY
52716: PUSH
52717: LD_VAR 0 3
52721: ARRAY
52722: PPUSH
52723: CALL_OW 257
52727: PUSH
52728: LD_INT 1
52730: EQUAL
52731: IFFALSE 52757
52733: PUSH
52734: LD_EXP 116
52738: PUSH
52739: LD_VAR 0 2
52743: ARRAY
52744: PUSH
52745: LD_VAR 0 3
52749: ARRAY
52750: PPUSH
52751: CALL_OW 459
52755: NOT
52756: AND
52757: IFFALSE 52783
52759: PUSH
52760: LD_EXP 116
52764: PUSH
52765: LD_VAR 0 2
52769: ARRAY
52770: PUSH
52771: LD_VAR 0 3
52775: ARRAY
52776: PPUSH
52777: CALL_OW 314
52781: NOT
52782: AND
52783: IFFALSE 52950
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52785: LD_EXP 116
52789: PUSH
52790: LD_VAR 0 2
52794: ARRAY
52795: PUSH
52796: LD_VAR 0 3
52800: ARRAY
52801: PPUSH
52802: CALL_OW 310
52806: IFFALSE 52829
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52808: LD_EXP 116
52812: PUSH
52813: LD_VAR 0 2
52817: ARRAY
52818: PUSH
52819: LD_VAR 0 3
52823: ARRAY
52824: PPUSH
52825: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52829: LD_EXP 116
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: PUSH
52840: LD_VAR 0 3
52844: ARRAY
52845: PPUSH
52846: CALL_OW 314
52850: NOT
52851: IFFALSE 52950
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 3
52862: PUSH
52863: LD_EXP 115
52867: PUSH
52868: LD_VAR 0 2
52872: ARRAY
52873: PPUSH
52874: CALL 73163 0 1
52878: MOD
52879: PUSH
52880: LD_INT 1
52882: PLUS
52883: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52884: LD_EXP 116
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_VAR 0 3
52899: ARRAY
52900: PPUSH
52901: LD_EXP 115
52905: PUSH
52906: LD_VAR 0 2
52910: ARRAY
52911: PUSH
52912: LD_VAR 0 7
52916: ARRAY
52917: PUSH
52918: LD_INT 1
52920: ARRAY
52921: PPUSH
52922: LD_EXP 115
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_VAR 0 7
52937: ARRAY
52938: PUSH
52939: LD_INT 2
52941: ARRAY
52942: PPUSH
52943: LD_INT 0
52945: PPUSH
52946: CALL_OW 193
// end ; end ; end ;
52950: GO 52590
52952: POP
52953: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52954: LD_ADDR_VAR 0 5
52958: PUSH
52959: LD_EXP 102
52963: PUSH
52964: LD_VAR 0 2
52968: ARRAY
52969: PPUSH
52970: LD_INT 2
52972: PUSH
52973: LD_INT 30
52975: PUSH
52976: LD_INT 4
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: LD_INT 30
52985: PUSH
52986: LD_INT 5
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: PUSH
52993: LD_INT 30
52995: PUSH
52996: LD_INT 32
52998: PUSH
52999: EMPTY
53000: LIST
53001: LIST
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: LIST
53007: LIST
53008: PPUSH
53009: CALL_OW 72
53013: ST_TO_ADDR
// if not tmp then
53014: LD_VAR 0 5
53018: NOT
53019: IFFALSE 53023
// continue ;
53021: GO 52499
// list := [ ] ;
53023: LD_ADDR_VAR 0 6
53027: PUSH
53028: EMPTY
53029: ST_TO_ADDR
// for j in tmp do
53030: LD_ADDR_VAR 0 3
53034: PUSH
53035: LD_VAR 0 5
53039: PUSH
53040: FOR_IN
53041: IFFALSE 53112
// begin for k in UnitsInside ( j ) do
53043: LD_ADDR_VAR 0 4
53047: PUSH
53048: LD_VAR 0 3
53052: PPUSH
53053: CALL_OW 313
53057: PUSH
53058: FOR_IN
53059: IFFALSE 53108
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
53061: LD_VAR 0 4
53065: PPUSH
53066: CALL_OW 257
53070: PUSH
53071: LD_INT 1
53073: EQUAL
53074: IFFALSE 53088
53076: PUSH
53077: LD_VAR 0 4
53081: PPUSH
53082: CALL_OW 459
53086: NOT
53087: AND
53088: IFFALSE 53106
// list := list ^ k ;
53090: LD_ADDR_VAR 0 6
53094: PUSH
53095: LD_VAR 0 6
53099: PUSH
53100: LD_VAR 0 4
53104: ADD
53105: ST_TO_ADDR
53106: GO 53058
53108: POP
53109: POP
// end ;
53110: GO 53040
53112: POP
53113: POP
// list := list diff mc_miners [ i ] ;
53114: LD_ADDR_VAR 0 6
53118: PUSH
53119: LD_VAR 0 6
53123: PUSH
53124: LD_EXP 116
53128: PUSH
53129: LD_VAR 0 2
53133: ARRAY
53134: DIFF
53135: ST_TO_ADDR
// if not list then
53136: LD_VAR 0 6
53140: NOT
53141: IFFALSE 53145
// continue ;
53143: GO 52499
// k := mc_mines [ i ] - mc_miners [ i ] ;
53145: LD_ADDR_VAR 0 4
53149: PUSH
53150: LD_EXP 115
53154: PUSH
53155: LD_VAR 0 2
53159: ARRAY
53160: PUSH
53161: LD_EXP 116
53165: PUSH
53166: LD_VAR 0 2
53170: ARRAY
53171: MINUS
53172: ST_TO_ADDR
// if k > list then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 6
53182: GREATER
53183: IFFALSE 53195
// k := list ;
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 6
53194: ST_TO_ADDR
// for j = 1 to k do
53195: LD_ADDR_VAR 0 3
53199: PUSH
53200: DOUBLE
53201: LD_INT 1
53203: DEC
53204: ST_TO_ADDR
53205: LD_VAR 0 4
53209: PUSH
53210: FOR_TO
53211: IFFALSE 53265
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
53213: LD_ADDR_EXP 116
53217: PUSH
53218: LD_EXP 116
53222: PPUSH
53223: LD_VAR 0 2
53227: PUSH
53228: LD_EXP 116
53232: PUSH
53233: LD_VAR 0 2
53237: ARRAY
53238: PUSH
53239: LD_INT 1
53241: PLUS
53242: PUSH
53243: EMPTY
53244: LIST
53245: LIST
53246: PPUSH
53247: LD_VAR 0 6
53251: PUSH
53252: LD_VAR 0 3
53256: ARRAY
53257: PPUSH
53258: CALL 76047 0 3
53262: ST_TO_ADDR
53263: GO 53210
53265: POP
53266: POP
// end ;
53267: GO 52499
53269: POP
53270: POP
// end ;
53271: LD_VAR 0 1
53275: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
53276: LD_INT 0
53278: PPUSH
53279: PPUSH
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
53287: PPUSH
53288: PPUSH
// if not mc_bases then
53289: LD_EXP 102
53293: NOT
53294: IFFALSE 53298
// exit ;
53296: GO 55145
// for i = 1 to mc_bases do
53298: LD_ADDR_VAR 0 2
53302: PUSH
53303: DOUBLE
53304: LD_INT 1
53306: DEC
53307: ST_TO_ADDR
53308: LD_EXP 102
53312: PUSH
53313: FOR_TO
53314: IFFALSE 55143
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
53316: LD_EXP 102
53320: PUSH
53321: LD_VAR 0 2
53325: ARRAY
53326: NOT
53327: IFTRUE 53341
53329: PUSH
53330: LD_EXP 109
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: OR
53341: IFFALSE 53345
// continue ;
53343: GO 53313
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
53345: LD_EXP 118
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: NOT
53356: IFFALSE 53370
53358: PUSH
53359: LD_EXP 119
53363: PUSH
53364: LD_VAR 0 2
53368: ARRAY
53369: AND
53370: IFFALSE 53408
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53372: LD_ADDR_EXP 119
53376: PUSH
53377: LD_EXP 119
53381: PPUSH
53382: LD_VAR 0 2
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53394: LD_VAR 0 2
53398: PPUSH
53399: LD_INT 107
53401: PPUSH
53402: CALL 44046 0 2
// continue ;
53406: GO 53313
// end ; target := [ ] ;
53408: LD_ADDR_VAR 0 7
53412: PUSH
53413: EMPTY
53414: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53415: LD_ADDR_VAR 0 6
53419: PUSH
53420: LD_EXP 102
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: PUSH
53431: LD_INT 1
53433: ARRAY
53434: PPUSH
53435: CALL_OW 255
53439: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53440: LD_ADDR_VAR 0 9
53444: PUSH
53445: LD_EXP 102
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PPUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 30
53461: PUSH
53462: LD_INT 0
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PUSH
53469: LD_INT 30
53471: PUSH
53472: LD_INT 1
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 72
53488: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: DOUBLE
53495: LD_EXP 118
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: INC
53506: ST_TO_ADDR
53507: LD_INT 1
53509: PUSH
53510: FOR_DOWNTO
53511: IFFALSE 53758
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53513: LD_EXP 118
53517: PUSH
53518: LD_VAR 0 2
53522: ARRAY
53523: PUSH
53524: LD_VAR 0 3
53528: ARRAY
53529: PUSH
53530: LD_INT 2
53532: ARRAY
53533: PPUSH
53534: LD_EXP 118
53538: PUSH
53539: LD_VAR 0 2
53543: ARRAY
53544: PUSH
53545: LD_VAR 0 3
53549: ARRAY
53550: PUSH
53551: LD_INT 3
53553: ARRAY
53554: PPUSH
53555: CALL_OW 488
53559: IFFALSE 53613
53561: PUSH
53562: LD_EXP 118
53566: PUSH
53567: LD_VAR 0 2
53571: ARRAY
53572: PUSH
53573: LD_VAR 0 3
53577: ARRAY
53578: PUSH
53579: LD_INT 2
53581: ARRAY
53582: PPUSH
53583: LD_EXP 118
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: PUSH
53594: LD_VAR 0 3
53598: ARRAY
53599: PUSH
53600: LD_INT 3
53602: ARRAY
53603: PPUSH
53604: CALL_OW 284
53608: PUSH
53609: LD_INT 0
53611: EQUAL
53612: AND
53613: IFFALSE 53668
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: LD_EXP 118
53624: PUSH
53625: LD_VAR 0 2
53629: ARRAY
53630: PPUSH
53631: LD_VAR 0 3
53635: PPUSH
53636: CALL_OW 3
53640: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53641: LD_ADDR_EXP 118
53645: PUSH
53646: LD_EXP 118
53650: PPUSH
53651: LD_VAR 0 2
53655: PPUSH
53656: LD_VAR 0 5
53660: PPUSH
53661: CALL_OW 1
53665: ST_TO_ADDR
// continue ;
53666: GO 53510
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53668: LD_VAR 0 6
53672: PPUSH
53673: LD_EXP 118
53677: PUSH
53678: LD_VAR 0 2
53682: ARRAY
53683: PUSH
53684: LD_VAR 0 3
53688: ARRAY
53689: PUSH
53690: LD_INT 2
53692: ARRAY
53693: PPUSH
53694: LD_EXP 118
53698: PUSH
53699: LD_VAR 0 2
53703: ARRAY
53704: PUSH
53705: LD_VAR 0 3
53709: ARRAY
53710: PUSH
53711: LD_INT 3
53713: ARRAY
53714: PPUSH
53715: LD_INT 30
53717: PPUSH
53718: CALL 77317 0 4
53722: PUSH
53723: LD_INT 4
53725: ARRAY
53726: PUSH
53727: LD_INT 0
53729: EQUAL
53730: IFFALSE 53756
// begin target := mc_crates [ i ] [ j ] ;
53732: LD_ADDR_VAR 0 7
53736: PUSH
53737: LD_EXP 118
53741: PUSH
53742: LD_VAR 0 2
53746: ARRAY
53747: PUSH
53748: LD_VAR 0 3
53752: ARRAY
53753: ST_TO_ADDR
// break ;
53754: GO 53758
// end ; end ;
53756: GO 53510
53758: POP
53759: POP
// if not target then
53760: LD_VAR 0 7
53764: NOT
53765: IFFALSE 53769
// continue ;
53767: GO 53313
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53769: LD_ADDR_VAR 0 8
53773: PUSH
53774: LD_EXP 121
53778: PUSH
53779: LD_VAR 0 2
53783: ARRAY
53784: PPUSH
53785: LD_INT 2
53787: PUSH
53788: LD_INT 3
53790: PUSH
53791: LD_INT 58
53793: PUSH
53794: EMPTY
53795: LIST
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 61
53803: PUSH
53804: EMPTY
53805: LIST
53806: PUSH
53807: LD_INT 33
53809: PUSH
53810: LD_INT 5
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PUSH
53817: LD_INT 33
53819: PUSH
53820: LD_INT 3
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: LIST
53833: PUSH
53834: LD_INT 2
53836: PUSH
53837: LD_INT 34
53839: PUSH
53840: LD_INT 32
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: PUSH
53847: LD_INT 34
53849: PUSH
53850: LD_INT 51
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: PUSH
53857: LD_INT 34
53859: PUSH
53860: LD_INT 12
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PPUSH
53877: CALL_OW 72
53881: ST_TO_ADDR
// if not cargo then
53882: LD_VAR 0 8
53886: NOT
53887: IFFALSE 54601
// begin if mc_crates_collector [ i ] < 5 then
53889: LD_EXP 119
53893: PUSH
53894: LD_VAR 0 2
53898: ARRAY
53899: PUSH
53900: LD_INT 5
53902: LESS
53903: IFFALSE 54273
// begin if mc_ape [ i ] then
53905: LD_EXP 131
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: IFFALSE 53962
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53917: LD_ADDR_VAR 0 5
53921: PUSH
53922: LD_EXP 131
53926: PUSH
53927: LD_VAR 0 2
53931: ARRAY
53932: PPUSH
53933: LD_INT 25
53935: PUSH
53936: LD_INT 16
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PUSH
53943: LD_INT 24
53945: PUSH
53946: LD_INT 750
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PPUSH
53957: CALL_OW 72
53961: ST_TO_ADDR
// if not tmp then
53962: LD_VAR 0 5
53966: NOT
53967: IFFALSE 54014
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53969: LD_ADDR_VAR 0 5
53973: PUSH
53974: LD_EXP 102
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 25
53987: PUSH
53988: LD_INT 2
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PUSH
53995: LD_INT 24
53997: PUSH
53998: LD_INT 750
54000: PUSH
54001: EMPTY
54002: LIST
54003: LIST
54004: PUSH
54005: EMPTY
54006: LIST
54007: LIST
54008: PPUSH
54009: CALL_OW 72
54013: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
54014: LD_EXP 131
54018: PUSH
54019: LD_VAR 0 2
54023: ARRAY
54024: IFFALSE 54067
54026: PUSH
54027: LD_EXP 102
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PPUSH
54038: LD_INT 25
54040: PUSH
54041: LD_INT 2
54043: PUSH
54044: EMPTY
54045: LIST
54046: LIST
54047: PUSH
54048: LD_INT 24
54050: PUSH
54051: LD_INT 750
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: PUSH
54058: EMPTY
54059: LIST
54060: LIST
54061: PPUSH
54062: CALL_OW 72
54066: AND
54067: IFFALSE 54079
54069: PUSH
54070: LD_VAR 0 5
54074: PUSH
54075: LD_INT 5
54077: LESS
54078: AND
54079: IFFALSE 54161
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
54081: LD_ADDR_VAR 0 3
54085: PUSH
54086: LD_EXP 102
54090: PUSH
54091: LD_VAR 0 2
54095: ARRAY
54096: PPUSH
54097: LD_INT 25
54099: PUSH
54100: LD_INT 2
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: LD_INT 24
54109: PUSH
54110: LD_INT 750
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PPUSH
54121: CALL_OW 72
54125: PUSH
54126: FOR_IN
54127: IFFALSE 54159
// begin tmp := tmp union j ;
54129: LD_ADDR_VAR 0 5
54133: PUSH
54134: LD_VAR 0 5
54138: PUSH
54139: LD_VAR 0 3
54143: UNION
54144: ST_TO_ADDR
// if tmp >= 5 then
54145: LD_VAR 0 5
54149: PUSH
54150: LD_INT 5
54152: GREATEREQUAL
54153: IFFALSE 54157
// break ;
54155: GO 54159
// end ;
54157: GO 54126
54159: POP
54160: POP
// end ; if not tmp then
54161: LD_VAR 0 5
54165: NOT
54166: IFFALSE 54170
// continue ;
54168: GO 53313
// for j in tmp do
54170: LD_ADDR_VAR 0 3
54174: PUSH
54175: LD_VAR 0 5
54179: PUSH
54180: FOR_IN
54181: IFFALSE 54271
// if not GetTag ( j ) then
54183: LD_VAR 0 3
54187: PPUSH
54188: CALL_OW 110
54192: NOT
54193: IFFALSE 54269
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
54195: LD_ADDR_EXP 119
54199: PUSH
54200: LD_EXP 119
54204: PPUSH
54205: LD_VAR 0 2
54209: PUSH
54210: LD_EXP 119
54214: PUSH
54215: LD_VAR 0 2
54219: ARRAY
54220: PUSH
54221: LD_INT 1
54223: PLUS
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: LD_VAR 0 3
54233: PPUSH
54234: CALL 76047 0 3
54238: ST_TO_ADDR
// SetTag ( j , 107 ) ;
54239: LD_VAR 0 3
54243: PPUSH
54244: LD_INT 107
54246: PPUSH
54247: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
54251: LD_EXP 119
54255: PUSH
54256: LD_VAR 0 2
54260: ARRAY
54261: PUSH
54262: LD_INT 5
54264: GREATEREQUAL
54265: IFFALSE 54269
// break ;
54267: GO 54271
// end ;
54269: GO 54180
54271: POP
54272: POP
// end ; if mc_crates_collector [ i ] and target then
54273: LD_EXP 119
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: IFFALSE 54291
54285: PUSH
54286: LD_VAR 0 7
54290: AND
54291: IFFALSE 54599
// begin if mc_crates_collector [ i ] < target [ 1 ] then
54293: LD_EXP 119
54297: PUSH
54298: LD_VAR 0 2
54302: ARRAY
54303: PUSH
54304: LD_VAR 0 7
54308: PUSH
54309: LD_INT 1
54311: ARRAY
54312: LESS
54313: IFFALSE 54333
// tmp := mc_crates_collector [ i ] else
54315: LD_ADDR_VAR 0 5
54319: PUSH
54320: LD_EXP 119
54324: PUSH
54325: LD_VAR 0 2
54329: ARRAY
54330: ST_TO_ADDR
54331: GO 54347
// tmp := target [ 1 ] ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: LD_VAR 0 7
54342: PUSH
54343: LD_INT 1
54345: ARRAY
54346: ST_TO_ADDR
// k := 0 ;
54347: LD_ADDR_VAR 0 4
54351: PUSH
54352: LD_INT 0
54354: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
54355: LD_ADDR_VAR 0 3
54359: PUSH
54360: LD_EXP 119
54364: PUSH
54365: LD_VAR 0 2
54369: ARRAY
54370: PUSH
54371: FOR_IN
54372: IFFALSE 54597
// begin k := k + 1 ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 4
54383: PUSH
54384: LD_INT 1
54386: PLUS
54387: ST_TO_ADDR
// if k > tmp then
54388: LD_VAR 0 4
54392: PUSH
54393: LD_VAR 0 5
54397: GREATER
54398: IFFALSE 54402
// break ;
54400: GO 54597
// if not GetClass ( j ) in [ 2 , 16 ] then
54402: LD_VAR 0 3
54406: PPUSH
54407: CALL_OW 257
54411: PUSH
54412: LD_INT 2
54414: PUSH
54415: LD_INT 16
54417: PUSH
54418: EMPTY
54419: LIST
54420: LIST
54421: IN
54422: NOT
54423: IFFALSE 54476
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54425: LD_ADDR_EXP 119
54429: PUSH
54430: LD_EXP 119
54434: PPUSH
54435: LD_VAR 0 2
54439: PPUSH
54440: LD_EXP 119
54444: PUSH
54445: LD_VAR 0 2
54449: ARRAY
54450: PUSH
54451: LD_VAR 0 3
54455: DIFF
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54462: LD_VAR 0 3
54466: PPUSH
54467: LD_INT 0
54469: PPUSH
54470: CALL_OW 109
// continue ;
54474: GO 54371
// end ; if IsInUnit ( j ) then
54476: LD_VAR 0 3
54480: PPUSH
54481: CALL_OW 310
54485: IFFALSE 54496
// ComExitBuilding ( j ) ;
54487: LD_VAR 0 3
54491: PPUSH
54492: CALL_OW 122
// wait ( 3 ) ;
54496: LD_INT 3
54498: PPUSH
54499: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54503: LD_VAR 0 3
54507: PPUSH
54508: CALL_OW 314
54512: IFFALSE 54550
54514: PUSH
54515: LD_VAR 0 6
54519: PPUSH
54520: LD_VAR 0 7
54524: PUSH
54525: LD_INT 2
54527: ARRAY
54528: PPUSH
54529: LD_VAR 0 7
54533: PUSH
54534: LD_INT 3
54536: ARRAY
54537: PPUSH
54538: LD_INT 30
54540: PPUSH
54541: CALL 77317 0 4
54545: PUSH
54546: LD_INT 4
54548: ARRAY
54549: AND
54550: IFFALSE 54568
// ComStandNearbyBuilding ( j , depot ) else
54552: LD_VAR 0 3
54556: PPUSH
54557: LD_VAR 0 9
54561: PPUSH
54562: CALL 72623 0 2
54566: GO 54595
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54568: LD_VAR 0 3
54572: PPUSH
54573: LD_VAR 0 7
54577: PUSH
54578: LD_INT 2
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 7
54586: PUSH
54587: LD_INT 3
54589: ARRAY
54590: PPUSH
54591: CALL_OW 117
// end ;
54595: GO 54371
54597: POP
54598: POP
// end ; end else
54599: GO 55141
// begin for j in cargo do
54601: LD_ADDR_VAR 0 3
54605: PUSH
54606: LD_VAR 0 8
54610: PUSH
54611: FOR_IN
54612: IFFALSE 55139
// begin if GetTag ( j ) <> 0 then
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 110
54623: PUSH
54624: LD_INT 0
54626: NONEQUAL
54627: IFFALSE 54631
// continue ;
54629: GO 54611
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54631: LD_VAR 0 3
54635: PPUSH
54636: CALL_OW 256
54640: PUSH
54641: LD_INT 1000
54643: LESS
54644: IFFALSE 54669
54646: PUSH
54647: LD_VAR 0 3
54651: PPUSH
54652: LD_EXP 126
54656: PUSH
54657: LD_VAR 0 2
54661: ARRAY
54662: PPUSH
54663: CALL_OW 308
54667: NOT
54668: AND
54669: IFFALSE 54691
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54671: LD_VAR 0 3
54675: PPUSH
54676: LD_EXP 126
54680: PUSH
54681: LD_VAR 0 2
54685: ARRAY
54686: PPUSH
54687: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54691: LD_VAR 0 3
54695: PPUSH
54696: CALL_OW 256
54700: PUSH
54701: LD_INT 1000
54703: LESS
54704: IFFALSE 54728
54706: PUSH
54707: LD_VAR 0 3
54711: PPUSH
54712: LD_EXP 126
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PPUSH
54723: CALL_OW 308
54727: AND
54728: IFFALSE 54732
// continue ;
54730: GO 54611
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54732: LD_VAR 0 3
54736: PPUSH
54737: CALL_OW 262
54741: PUSH
54742: LD_INT 2
54744: EQUAL
54745: IFFALSE 54762
54747: PUSH
54748: LD_VAR 0 3
54752: PPUSH
54753: CALL_OW 261
54757: PUSH
54758: LD_INT 15
54760: LESS
54761: AND
54762: IFFALSE 54766
// continue ;
54764: GO 54611
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54766: LD_VAR 0 3
54770: PPUSH
54771: CALL_OW 262
54775: PUSH
54776: LD_INT 1
54778: EQUAL
54779: IFFALSE 54796
54781: PUSH
54782: LD_VAR 0 3
54786: PPUSH
54787: CALL_OW 261
54791: PUSH
54792: LD_INT 10
54794: LESS
54795: AND
54796: IFFALSE 55076
// begin if not depot then
54798: LD_VAR 0 9
54802: NOT
54803: IFFALSE 54807
// continue ;
54805: GO 54611
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54807: LD_VAR 0 3
54811: PPUSH
54812: LD_VAR 0 9
54816: PPUSH
54817: LD_VAR 0 3
54821: PPUSH
54822: CALL_OW 74
54826: PPUSH
54827: CALL_OW 296
54831: PUSH
54832: LD_INT 6
54834: LESS
54835: IFFALSE 54851
// SetFuel ( j , 100 ) else
54837: LD_VAR 0 3
54841: PPUSH
54842: LD_INT 100
54844: PPUSH
54845: CALL_OW 240
54849: GO 55076
// if GetFuel ( j ) = 0 then
54851: LD_VAR 0 3
54855: PPUSH
54856: CALL_OW 261
54860: PUSH
54861: LD_INT 0
54863: EQUAL
54864: IFFALSE 55076
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54866: LD_ADDR_EXP 121
54870: PUSH
54871: LD_EXP 121
54875: PPUSH
54876: LD_VAR 0 2
54880: PPUSH
54881: LD_EXP 121
54885: PUSH
54886: LD_VAR 0 2
54890: ARRAY
54891: PUSH
54892: LD_VAR 0 3
54896: DIFF
54897: PPUSH
54898: CALL_OW 1
54902: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54903: LD_VAR 0 3
54907: PPUSH
54908: CALL_OW 263
54912: PUSH
54913: LD_INT 1
54915: EQUAL
54916: IFFALSE 54932
// ComExitVehicle ( IsInUnit ( j ) ) ;
54918: LD_VAR 0 3
54922: PPUSH
54923: CALL_OW 310
54927: PPUSH
54928: CALL_OW 121
// if GetControl ( j ) = control_remote then
54932: LD_VAR 0 3
54936: PPUSH
54937: CALL_OW 263
54941: PUSH
54942: LD_INT 2
54944: EQUAL
54945: IFFALSE 54956
// ComUnlink ( j ) ;
54947: LD_VAR 0 3
54951: PPUSH
54952: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54956: LD_ADDR_VAR 0 10
54960: PUSH
54961: LD_VAR 0 2
54965: PPUSH
54966: LD_INT 3
54968: PPUSH
54969: CALL 64870 0 2
54973: ST_TO_ADDR
// if fac then
54974: LD_VAR 0 10
54978: IFFALSE 55074
// begin for k in fac do
54980: LD_ADDR_VAR 0 4
54984: PUSH
54985: LD_VAR 0 10
54989: PUSH
54990: FOR_IN
54991: IFFALSE 55072
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54993: LD_ADDR_VAR 0 11
54997: PUSH
54998: LD_VAR 0 10
55002: PPUSH
55003: LD_VAR 0 3
55007: PPUSH
55008: CALL_OW 265
55012: PPUSH
55013: LD_VAR 0 3
55017: PPUSH
55018: CALL_OW 262
55022: PPUSH
55023: LD_VAR 0 3
55027: PPUSH
55028: CALL_OW 263
55032: PPUSH
55033: LD_VAR 0 3
55037: PPUSH
55038: CALL_OW 264
55042: PPUSH
55043: CALL 73521 0 5
55047: ST_TO_ADDR
// if components then
55048: LD_VAR 0 11
55052: IFFALSE 55070
// begin MC_InsertProduceList ( i , components ) ;
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 11
55063: PPUSH
55064: CALL 64415 0 2
// break ;
55068: GO 55072
// end ; end ;
55070: GO 54990
55072: POP
55073: POP
// end ; continue ;
55074: GO 54611
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
55076: LD_VAR 0 3
55080: PPUSH
55081: LD_INT 1
55083: PPUSH
55084: CALL_OW 289
55088: PUSH
55089: LD_INT 100
55091: LESS
55092: IFFALSE 55106
55094: PUSH
55095: LD_VAR 0 3
55099: PPUSH
55100: CALL_OW 314
55104: NOT
55105: AND
55106: IFFALSE 55135
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55108: LD_VAR 0 3
55112: PPUSH
55113: LD_VAR 0 7
55117: PUSH
55118: LD_INT 2
55120: ARRAY
55121: PPUSH
55122: LD_VAR 0 7
55126: PUSH
55127: LD_INT 3
55129: ARRAY
55130: PPUSH
55131: CALL_OW 117
// break ;
55135: GO 55139
// end ;
55137: GO 54611
55139: POP
55140: POP
// end ; end ;
55141: GO 53313
55143: POP
55144: POP
// end ;
55145: LD_VAR 0 1
55149: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
55150: LD_INT 0
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
// if not mc_bases then
55156: LD_EXP 102
55160: NOT
55161: IFFALSE 55165
// exit ;
55163: GO 55330
// for i = 1 to mc_bases do
55165: LD_ADDR_VAR 0 2
55169: PUSH
55170: DOUBLE
55171: LD_INT 1
55173: DEC
55174: ST_TO_ADDR
55175: LD_EXP 102
55179: PUSH
55180: FOR_TO
55181: IFFALSE 55328
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
55183: LD_ADDR_VAR 0 4
55187: PUSH
55188: LD_EXP 121
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PUSH
55199: LD_EXP 124
55203: PUSH
55204: LD_VAR 0 2
55208: ARRAY
55209: UNION
55210: PPUSH
55211: LD_INT 33
55213: PUSH
55214: LD_INT 2
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: PPUSH
55221: CALL_OW 72
55225: ST_TO_ADDR
// if tmp then
55226: LD_VAR 0 4
55230: IFFALSE 55326
// for j in tmp do
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_VAR 0 4
55241: PUSH
55242: FOR_IN
55243: IFFALSE 55324
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
55245: LD_VAR 0 3
55249: PPUSH
55250: CALL_OW 312
55254: NOT
55255: IFFALSE 55272
55257: PUSH
55258: LD_VAR 0 3
55262: PPUSH
55263: CALL_OW 256
55267: PUSH
55268: LD_INT 250
55270: GREATEREQUAL
55271: AND
55272: IFFALSE 55285
// Connect ( j ) else
55274: LD_VAR 0 3
55278: PPUSH
55279: CALL 79407 0 1
55283: GO 55322
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
55285: LD_VAR 0 3
55289: PPUSH
55290: CALL_OW 256
55294: PUSH
55295: LD_INT 250
55297: LESS
55298: IFFALSE 55311
55300: PUSH
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 312
55310: AND
55311: IFFALSE 55322
// ComUnlink ( j ) ;
55313: LD_VAR 0 3
55317: PPUSH
55318: CALL_OW 136
55322: GO 55242
55324: POP
55325: POP
// end ;
55326: GO 55180
55328: POP
55329: POP
// end ;
55330: LD_VAR 0 1
55334: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
55335: LD_INT 0
55337: PPUSH
55338: PPUSH
55339: PPUSH
55340: PPUSH
55341: PPUSH
// if not mc_bases then
55342: LD_EXP 102
55346: NOT
55347: IFFALSE 55351
// exit ;
55349: GO 55800
// for i = 1 to mc_bases do
55351: LD_ADDR_VAR 0 2
55355: PUSH
55356: DOUBLE
55357: LD_INT 1
55359: DEC
55360: ST_TO_ADDR
55361: LD_EXP 102
55365: PUSH
55366: FOR_TO
55367: IFFALSE 55798
// begin if not mc_produce [ i ] then
55369: LD_EXP 123
55373: PUSH
55374: LD_VAR 0 2
55378: ARRAY
55379: NOT
55380: IFFALSE 55384
// continue ;
55382: GO 55366
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55384: LD_ADDR_VAR 0 5
55388: PUSH
55389: LD_EXP 102
55393: PUSH
55394: LD_VAR 0 2
55398: ARRAY
55399: PPUSH
55400: LD_INT 30
55402: PUSH
55403: LD_INT 3
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PPUSH
55410: CALL_OW 72
55414: ST_TO_ADDR
// if not fac then
55415: LD_VAR 0 5
55419: NOT
55420: IFFALSE 55424
// continue ;
55422: GO 55366
// for j in fac do
55424: LD_ADDR_VAR 0 3
55428: PUSH
55429: LD_VAR 0 5
55433: PUSH
55434: FOR_IN
55435: IFFALSE 55794
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55437: LD_VAR 0 3
55441: PPUSH
55442: CALL_OW 461
55446: PUSH
55447: LD_INT 2
55449: NONEQUAL
55450: IFTRUE 55470
55452: PUSH
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_INT 15
55460: PPUSH
55461: CALL 79026 0 2
55465: PUSH
55466: LD_INT 4
55468: ARRAY
55469: OR
55470: IFFALSE 55474
// continue ;
55472: GO 55434
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55474: LD_VAR 0 3
55478: PPUSH
55479: LD_EXP 123
55483: PUSH
55484: LD_VAR 0 2
55488: ARRAY
55489: PUSH
55490: LD_INT 1
55492: ARRAY
55493: PUSH
55494: LD_INT 1
55496: ARRAY
55497: PPUSH
55498: LD_EXP 123
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: PUSH
55509: LD_INT 1
55511: ARRAY
55512: PUSH
55513: LD_INT 2
55515: ARRAY
55516: PPUSH
55517: LD_EXP 123
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PUSH
55528: LD_INT 1
55530: ARRAY
55531: PUSH
55532: LD_INT 3
55534: ARRAY
55535: PPUSH
55536: LD_EXP 123
55540: PUSH
55541: LD_VAR 0 2
55545: ARRAY
55546: PUSH
55547: LD_INT 1
55549: ARRAY
55550: PUSH
55551: LD_INT 4
55553: ARRAY
55554: PPUSH
55555: CALL_OW 448
55559: IFFALSE 55654
55561: PUSH
55562: LD_VAR 0 3
55566: PPUSH
55567: LD_EXP 123
55571: PUSH
55572: LD_VAR 0 2
55576: ARRAY
55577: PUSH
55578: LD_INT 1
55580: ARRAY
55581: PUSH
55582: LD_INT 1
55584: ARRAY
55585: PUSH
55586: LD_EXP 123
55590: PUSH
55591: LD_VAR 0 2
55595: ARRAY
55596: PUSH
55597: LD_INT 1
55599: ARRAY
55600: PUSH
55601: LD_INT 2
55603: ARRAY
55604: PUSH
55605: LD_EXP 123
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: PUSH
55616: LD_INT 1
55618: ARRAY
55619: PUSH
55620: LD_INT 3
55622: ARRAY
55623: PUSH
55624: LD_EXP 123
55628: PUSH
55629: LD_VAR 0 2
55633: ARRAY
55634: PUSH
55635: LD_INT 1
55637: ARRAY
55638: PUSH
55639: LD_INT 4
55641: ARRAY
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL 82840 0 2
55653: AND
55654: IFFALSE 55792
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55656: LD_VAR 0 3
55660: PPUSH
55661: LD_EXP 123
55665: PUSH
55666: LD_VAR 0 2
55670: ARRAY
55671: PUSH
55672: LD_INT 1
55674: ARRAY
55675: PUSH
55676: LD_INT 1
55678: ARRAY
55679: PPUSH
55680: LD_EXP 123
55684: PUSH
55685: LD_VAR 0 2
55689: ARRAY
55690: PUSH
55691: LD_INT 1
55693: ARRAY
55694: PUSH
55695: LD_INT 2
55697: ARRAY
55698: PPUSH
55699: LD_EXP 123
55703: PUSH
55704: LD_VAR 0 2
55708: ARRAY
55709: PUSH
55710: LD_INT 1
55712: ARRAY
55713: PUSH
55714: LD_INT 3
55716: ARRAY
55717: PPUSH
55718: LD_EXP 123
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: ARRAY
55732: PUSH
55733: LD_INT 4
55735: ARRAY
55736: PPUSH
55737: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55741: LD_ADDR_VAR 0 4
55745: PUSH
55746: LD_EXP 123
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 1
55759: PPUSH
55760: CALL_OW 3
55764: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55765: LD_ADDR_EXP 123
55769: PUSH
55770: LD_EXP 123
55774: PPUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_VAR 0 4
55784: PPUSH
55785: CALL_OW 1
55789: ST_TO_ADDR
// break ;
55790: GO 55794
// end ; end ;
55792: GO 55434
55794: POP
55795: POP
// end ;
55796: GO 55366
55798: POP
55799: POP
// end ;
55800: LD_VAR 0 1
55804: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55805: LD_INT 0
55807: PPUSH
55808: PPUSH
55809: PPUSH
// if not mc_bases then
55810: LD_EXP 102
55814: NOT
55815: IFFALSE 55819
// exit ;
55817: GO 55908
// for i = 1 to mc_bases do
55819: LD_ADDR_VAR 0 2
55823: PUSH
55824: DOUBLE
55825: LD_INT 1
55827: DEC
55828: ST_TO_ADDR
55829: LD_EXP 102
55833: PUSH
55834: FOR_TO
55835: IFFALSE 55906
// begin if mc_attack [ i ] then
55837: LD_EXP 122
55841: PUSH
55842: LD_VAR 0 2
55846: ARRAY
55847: IFFALSE 55904
// begin tmp := mc_attack [ i ] [ 1 ] ;
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: LD_EXP 122
55858: PUSH
55859: LD_VAR 0 2
55863: ARRAY
55864: PUSH
55865: LD_INT 1
55867: ARRAY
55868: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55869: LD_ADDR_EXP 122
55873: PUSH
55874: LD_EXP 122
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// Attack ( tmp ) ;
55891: LD_VAR 0 3
55895: PPUSH
55896: CALL 136731 0 1
// exit ;
55900: POP
55901: POP
55902: GO 55908
// end ; end ;
55904: GO 55834
55906: POP
55907: POP
// end ;
55908: LD_VAR 0 1
55912: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55913: LD_INT 0
55915: PPUSH
55916: PPUSH
55917: PPUSH
55918: PPUSH
55919: PPUSH
55920: PPUSH
55921: PPUSH
// if not mc_bases then
55922: LD_EXP 102
55926: NOT
55927: IFFALSE 55931
// exit ;
55929: GO 56808
// for i = 1 to mc_bases do
55931: LD_ADDR_VAR 0 2
55935: PUSH
55936: DOUBLE
55937: LD_INT 1
55939: DEC
55940: ST_TO_ADDR
55941: LD_EXP 102
55945: PUSH
55946: FOR_TO
55947: IFFALSE 56806
// begin if not mc_bases [ i ] then
55949: LD_EXP 102
55953: PUSH
55954: LD_VAR 0 2
55958: ARRAY
55959: NOT
55960: IFFALSE 55964
// continue ;
55962: GO 55946
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55964: LD_ADDR_VAR 0 7
55968: PUSH
55969: LD_EXP 102
55973: PUSH
55974: LD_VAR 0 2
55978: ARRAY
55979: PUSH
55980: LD_INT 1
55982: ARRAY
55983: PPUSH
55984: CALL 72847 0 1
55988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55989: LD_ADDR_EXP 125
55993: PUSH
55994: LD_EXP 125
55998: PPUSH
55999: LD_VAR 0 2
56003: PPUSH
56004: LD_EXP 102
56008: PUSH
56009: LD_VAR 0 2
56013: ARRAY
56014: PUSH
56015: LD_INT 1
56017: ARRAY
56018: PPUSH
56019: CALL_OW 255
56023: PPUSH
56024: LD_EXP 127
56028: PUSH
56029: LD_VAR 0 2
56033: ARRAY
56034: PPUSH
56035: CALL 72812 0 2
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// if not mc_scan [ i ] then
56045: LD_EXP 125
56049: PUSH
56050: LD_VAR 0 2
56054: ARRAY
56055: NOT
56056: IFFALSE 56240
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56058: LD_ADDR_EXP 145
56062: PUSH
56063: LD_EXP 145
56067: PPUSH
56068: LD_VAR 0 2
56072: PPUSH
56073: LD_INT 0
56075: PPUSH
56076: CALL_OW 1
56080: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56081: LD_ADDR_VAR 0 4
56085: PUSH
56086: LD_EXP 102
56090: PUSH
56091: LD_VAR 0 2
56095: ARRAY
56096: PPUSH
56097: LD_INT 2
56099: PUSH
56100: LD_INT 25
56102: PUSH
56103: LD_INT 5
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: LD_INT 25
56112: PUSH
56113: LD_INT 8
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 25
56122: PUSH
56123: LD_INT 9
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: LIST
56134: LIST
56135: PPUSH
56136: CALL_OW 72
56140: ST_TO_ADDR
// if not tmp then
56141: LD_VAR 0 4
56145: NOT
56146: IFFALSE 56150
// continue ;
56148: GO 55946
// for j in tmp do
56150: LD_ADDR_VAR 0 3
56154: PUSH
56155: LD_VAR 0 4
56159: PUSH
56160: FOR_IN
56161: IFFALSE 56238
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
56163: LD_VAR 0 3
56167: PPUSH
56168: CALL_OW 310
56172: PPUSH
56173: CALL_OW 266
56177: PUSH
56178: LD_INT 5
56180: EQUAL
56181: IFFALSE 56198
56183: PUSH
56184: LD_VAR 0 3
56188: PPUSH
56189: CALL_OW 257
56193: PUSH
56194: LD_INT 1
56196: EQUAL
56197: AND
56198: IFFALSE 56212
56200: PUSH
56201: LD_VAR 0 3
56205: PPUSH
56206: CALL_OW 459
56210: NOT
56211: AND
56212: IFFALSE 56220
56214: PUSH
56215: LD_VAR 0 7
56219: AND
56220: IFFALSE 56236
// ComChangeProfession ( j , class ) ;
56222: LD_VAR 0 3
56226: PPUSH
56227: LD_VAR 0 7
56231: PPUSH
56232: CALL_OW 123
56236: GO 56160
56238: POP
56239: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
56240: LD_EXP 125
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: IFFALSE 56265
56252: PUSH
56253: LD_EXP 145
56257: PUSH
56258: LD_VAR 0 2
56262: ARRAY
56263: NOT
56264: AND
56265: IFFALSE 56280
56267: PUSH
56268: LD_EXP 124
56272: PUSH
56273: LD_VAR 0 2
56277: ARRAY
56278: NOT
56279: AND
56280: IFFALSE 56431
56282: PUSH
56283: LD_EXP 102
56287: PUSH
56288: LD_VAR 0 2
56292: ARRAY
56293: PPUSH
56294: LD_INT 50
56296: PUSH
56297: EMPTY
56298: LIST
56299: PUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 30
56305: PUSH
56306: LD_INT 32
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 30
56315: PUSH
56316: LD_INT 33
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 30
56325: PUSH
56326: LD_INT 4
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 30
56335: PUSH
56336: LD_INT 5
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: LIST
56347: LIST
56348: LIST
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PPUSH
56354: CALL_OW 72
56358: PUSH
56359: LD_INT 4
56361: LESS
56362: IFTRUE 56430
56364: PUSH
56365: LD_EXP 102
56369: PUSH
56370: LD_VAR 0 2
56374: ARRAY
56375: PPUSH
56376: LD_INT 3
56378: PUSH
56379: LD_INT 24
56381: PUSH
56382: LD_INT 1000
56384: PUSH
56385: EMPTY
56386: LIST
56387: LIST
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PUSH
56393: LD_INT 2
56395: PUSH
56396: LD_INT 30
56398: PUSH
56399: LD_INT 0
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: LD_INT 30
56408: PUSH
56409: LD_INT 1
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: LIST
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: PPUSH
56425: CALL_OW 72
56429: OR
56430: AND
56431: IFFALSE 56684
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56433: LD_ADDR_EXP 145
56437: PUSH
56438: LD_EXP 145
56442: PPUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: LD_INT 1
56450: PPUSH
56451: CALL_OW 1
56455: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56456: LD_ADDR_VAR 0 4
56460: PUSH
56461: LD_EXP 102
56465: PUSH
56466: LD_VAR 0 2
56470: ARRAY
56471: PPUSH
56472: LD_INT 2
56474: PUSH
56475: LD_INT 25
56477: PUSH
56478: LD_INT 1
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: PUSH
56485: LD_INT 25
56487: PUSH
56488: LD_INT 5
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: PUSH
56495: LD_INT 25
56497: PUSH
56498: LD_INT 8
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: PUSH
56505: LD_INT 25
56507: PUSH
56508: LD_INT 9
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: EMPTY
56516: LIST
56517: LIST
56518: LIST
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56527: LD_ADDR_VAR 0 4
56531: PUSH
56532: LD_VAR 0 4
56536: PUSH
56537: LD_VAR 0 4
56541: PPUSH
56542: LD_INT 18
56544: PPUSH
56545: CALL 106640 0 2
56549: DIFF
56550: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56551: LD_VAR 0 4
56555: NOT
56556: IFFALSE 56604
56558: PUSH
56559: LD_EXP 102
56563: PUSH
56564: LD_VAR 0 2
56568: ARRAY
56569: PPUSH
56570: LD_INT 2
56572: PUSH
56573: LD_INT 30
56575: PUSH
56576: LD_INT 4
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: LD_INT 30
56585: PUSH
56586: LD_INT 5
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: PUSH
56593: EMPTY
56594: LIST
56595: LIST
56596: LIST
56597: PPUSH
56598: CALL_OW 72
56602: NOT
56603: AND
56604: IFFALSE 56666
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56606: LD_ADDR_VAR 0 4
56610: PUSH
56611: LD_EXP 102
56615: PUSH
56616: LD_VAR 0 2
56620: ARRAY
56621: PPUSH
56622: LD_INT 2
56624: PUSH
56625: LD_INT 25
56627: PUSH
56628: LD_INT 2
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: PUSH
56635: LD_INT 25
56637: PUSH
56638: LD_INT 3
56640: PUSH
56641: EMPTY
56642: LIST
56643: LIST
56644: PUSH
56645: LD_INT 25
56647: PUSH
56648: LD_INT 4
56650: PUSH
56651: EMPTY
56652: LIST
56653: LIST
56654: PUSH
56655: EMPTY
56656: LIST
56657: LIST
56658: LIST
56659: LIST
56660: PPUSH
56661: CALL_OW 72
56665: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56666: LD_VAR 0 2
56670: PPUSH
56671: LD_VAR 0 4
56675: PPUSH
56676: CALL 141500 0 2
// exit ;
56680: POP
56681: POP
56682: GO 56808
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56684: LD_EXP 125
56688: PUSH
56689: LD_VAR 0 2
56693: ARRAY
56694: IFFALSE 56709
56696: PUSH
56697: LD_EXP 145
56701: PUSH
56702: LD_VAR 0 2
56706: ARRAY
56707: NOT
56708: AND
56709: IFFALSE 56723
56711: PUSH
56712: LD_EXP 124
56716: PUSH
56717: LD_VAR 0 2
56721: ARRAY
56722: AND
56723: IFFALSE 56804
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56725: LD_ADDR_EXP 145
56729: PUSH
56730: LD_EXP 145
56734: PPUSH
56735: LD_VAR 0 2
56739: PPUSH
56740: LD_INT 1
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56748: LD_ADDR_VAR 0 4
56752: PUSH
56753: LD_EXP 124
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56764: LD_ADDR_EXP 124
56768: PUSH
56769: LD_EXP 124
56773: PPUSH
56774: LD_VAR 0 2
56778: PPUSH
56779: EMPTY
56780: PPUSH
56781: CALL_OW 1
56785: ST_TO_ADDR
// Defend ( i , tmp ) ;
56786: LD_VAR 0 2
56790: PPUSH
56791: LD_VAR 0 4
56795: PPUSH
56796: CALL 142104 0 2
// exit ;
56800: POP
56801: POP
56802: GO 56808
// end ; end ;
56804: GO 55946
56806: POP
56807: POP
// end ;
56808: LD_VAR 0 1
56812: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56813: LD_INT 0
56815: PPUSH
56816: PPUSH
56817: PPUSH
56818: PPUSH
56819: PPUSH
56820: PPUSH
56821: PPUSH
56822: PPUSH
56823: PPUSH
56824: PPUSH
56825: PPUSH
// if not mc_bases then
56826: LD_EXP 102
56830: NOT
56831: IFFALSE 56835
// exit ;
56833: GO 57948
// for i = 1 to mc_bases do
56835: LD_ADDR_VAR 0 2
56839: PUSH
56840: DOUBLE
56841: LD_INT 1
56843: DEC
56844: ST_TO_ADDR
56845: LD_EXP 102
56849: PUSH
56850: FOR_TO
56851: IFFALSE 57946
// begin tmp := mc_lab [ i ] ;
56853: LD_ADDR_VAR 0 6
56857: PUSH
56858: LD_EXP 135
56862: PUSH
56863: LD_VAR 0 2
56867: ARRAY
56868: ST_TO_ADDR
// if not tmp then
56869: LD_VAR 0 6
56873: NOT
56874: IFFALSE 56878
// continue ;
56876: GO 56850
// idle_lab := 0 ;
56878: LD_ADDR_VAR 0 11
56882: PUSH
56883: LD_INT 0
56885: ST_TO_ADDR
// for j in tmp do
56886: LD_ADDR_VAR 0 3
56890: PUSH
56891: LD_VAR 0 6
56895: PUSH
56896: FOR_IN
56897: IFFALSE 57942
// begin researching := false ;
56899: LD_ADDR_VAR 0 10
56903: PUSH
56904: LD_INT 0
56906: ST_TO_ADDR
// side := GetSide ( j ) ;
56907: LD_ADDR_VAR 0 4
56911: PUSH
56912: LD_VAR 0 3
56916: PPUSH
56917: CALL_OW 255
56921: ST_TO_ADDR
// if not mc_tech [ side ] then
56922: LD_EXP 129
56926: PUSH
56927: LD_VAR 0 4
56931: ARRAY
56932: NOT
56933: IFFALSE 56937
// continue ;
56935: GO 56896
// if BuildingStatus ( j ) = bs_idle then
56937: LD_VAR 0 3
56941: PPUSH
56942: CALL_OW 461
56946: PUSH
56947: LD_INT 2
56949: EQUAL
56950: IFFALSE 57142
// begin if idle_lab and UnitsInside ( j ) < 6 then
56952: LD_VAR 0 11
56956: IFFALSE 56973
56958: PUSH
56959: LD_VAR 0 3
56963: PPUSH
56964: CALL_OW 313
56968: PUSH
56969: LD_INT 6
56971: LESS
56972: AND
56973: IFFALSE 57044
// begin tmp2 := UnitsInside ( idle_lab ) ;
56975: LD_ADDR_VAR 0 9
56979: PUSH
56980: LD_VAR 0 11
56984: PPUSH
56985: CALL_OW 313
56989: ST_TO_ADDR
// if tmp2 then
56990: LD_VAR 0 9
56994: IFFALSE 57036
// for x in tmp2 do
56996: LD_ADDR_VAR 0 7
57000: PUSH
57001: LD_VAR 0 9
57005: PUSH
57006: FOR_IN
57007: IFFALSE 57034
// begin ComExitBuilding ( x ) ;
57009: LD_VAR 0 7
57013: PPUSH
57014: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57018: LD_VAR 0 7
57022: PPUSH
57023: LD_VAR 0 3
57027: PPUSH
57028: CALL_OW 180
// end ;
57032: GO 57006
57034: POP
57035: POP
// idle_lab := 0 ;
57036: LD_ADDR_VAR 0 11
57040: PUSH
57041: LD_INT 0
57043: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
57044: LD_ADDR_VAR 0 5
57048: PUSH
57049: LD_EXP 129
57053: PUSH
57054: LD_VAR 0 4
57058: ARRAY
57059: PUSH
57060: FOR_IN
57061: IFFALSE 57123
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
57063: LD_VAR 0 3
57067: PPUSH
57068: LD_VAR 0 5
57072: PPUSH
57073: CALL_OW 430
57077: IFFALSE 57095
57079: PUSH
57080: LD_VAR 0 4
57084: PPUSH
57085: LD_VAR 0 5
57089: PPUSH
57090: CALL 71907 0 2
57094: AND
57095: IFFALSE 57121
// begin researching := true ;
57097: LD_ADDR_VAR 0 10
57101: PUSH
57102: LD_INT 1
57104: ST_TO_ADDR
// ComResearch ( j , t ) ;
57105: LD_VAR 0 3
57109: PPUSH
57110: LD_VAR 0 5
57114: PPUSH
57115: CALL_OW 124
// break ;
57119: GO 57123
// end ;
57121: GO 57060
57123: POP
57124: POP
// if not researching then
57125: LD_VAR 0 10
57129: NOT
57130: IFFALSE 57142
// idle_lab := j ;
57132: LD_ADDR_VAR 0 11
57136: PUSH
57137: LD_VAR 0 3
57141: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
57142: LD_VAR 0 3
57146: PPUSH
57147: CALL_OW 461
57151: PUSH
57152: LD_INT 10
57154: EQUAL
57155: IFFALSE 57761
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
57157: LD_EXP 131
57161: PUSH
57162: LD_VAR 0 2
57166: ARRAY
57167: NOT
57168: IFFALSE 57183
57170: PUSH
57171: LD_EXP 132
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: NOT
57182: AND
57183: IFFALSE 57201
57185: PUSH
57186: LD_EXP 129
57190: PUSH
57191: LD_VAR 0 4
57195: ARRAY
57196: PUSH
57197: LD_INT 1
57199: GREATER
57200: AND
57201: IFFALSE 57332
// begin ComCancel ( j ) ;
57203: LD_VAR 0 3
57207: PPUSH
57208: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
57212: LD_ADDR_EXP 129
57216: PUSH
57217: LD_EXP 129
57221: PPUSH
57222: LD_VAR 0 4
57226: PPUSH
57227: LD_EXP 129
57231: PUSH
57232: LD_VAR 0 4
57236: ARRAY
57237: PPUSH
57238: LD_EXP 129
57242: PUSH
57243: LD_VAR 0 4
57247: ARRAY
57248: PUSH
57249: LD_INT 1
57251: MINUS
57252: PPUSH
57253: LD_EXP 129
57257: PUSH
57258: LD_VAR 0 4
57262: ARRAY
57263: PPUSH
57264: LD_INT 0
57266: PPUSH
57267: CALL 75455 0 4
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
57277: LD_ADDR_EXP 129
57281: PUSH
57282: LD_EXP 129
57286: PPUSH
57287: LD_VAR 0 4
57291: PPUSH
57292: LD_EXP 129
57296: PUSH
57297: LD_VAR 0 4
57301: ARRAY
57302: PPUSH
57303: LD_EXP 129
57307: PUSH
57308: LD_VAR 0 4
57312: ARRAY
57313: PPUSH
57314: LD_INT 1
57316: PPUSH
57317: LD_INT 0
57319: PPUSH
57320: CALL 75455 0 4
57324: PPUSH
57325: CALL_OW 1
57329: ST_TO_ADDR
// continue ;
57330: GO 56896
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
57332: LD_EXP 131
57336: PUSH
57337: LD_VAR 0 2
57341: ARRAY
57342: IFFALSE 57357
57344: PUSH
57345: LD_EXP 132
57349: PUSH
57350: LD_VAR 0 2
57354: ARRAY
57355: NOT
57356: AND
57357: IFFALSE 57484
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
57359: LD_ADDR_EXP 132
57363: PUSH
57364: LD_EXP 132
57368: PPUSH
57369: LD_VAR 0 2
57373: PUSH
57374: LD_EXP 132
57378: PUSH
57379: LD_VAR 0 2
57383: ARRAY
57384: PUSH
57385: LD_INT 1
57387: PLUS
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PPUSH
57393: LD_EXP 131
57397: PUSH
57398: LD_VAR 0 2
57402: ARRAY
57403: PUSH
57404: LD_INT 1
57406: ARRAY
57407: PPUSH
57408: CALL 76047 0 3
57412: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
57413: LD_EXP 131
57417: PUSH
57418: LD_VAR 0 2
57422: ARRAY
57423: PUSH
57424: LD_INT 1
57426: ARRAY
57427: PPUSH
57428: LD_INT 112
57430: PPUSH
57431: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
57435: LD_ADDR_VAR 0 9
57439: PUSH
57440: LD_EXP 131
57444: PUSH
57445: LD_VAR 0 2
57449: ARRAY
57450: PPUSH
57451: LD_INT 1
57453: PPUSH
57454: CALL_OW 3
57458: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57459: LD_ADDR_EXP 131
57463: PUSH
57464: LD_EXP 131
57468: PPUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: LD_VAR 0 9
57478: PPUSH
57479: CALL_OW 1
57483: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57484: LD_EXP 131
57488: PUSH
57489: LD_VAR 0 2
57493: ARRAY
57494: IFFALSE 57508
57496: PUSH
57497: LD_EXP 132
57501: PUSH
57502: LD_VAR 0 2
57506: ARRAY
57507: AND
57508: IFFALSE 57532
57510: PUSH
57511: LD_EXP 132
57515: PUSH
57516: LD_VAR 0 2
57520: ARRAY
57521: PUSH
57522: LD_INT 1
57524: ARRAY
57525: PPUSH
57526: CALL_OW 310
57530: NOT
57531: AND
57532: IFFALSE 57549
57534: PUSH
57535: LD_VAR 0 3
57539: PPUSH
57540: CALL_OW 313
57544: PUSH
57545: LD_INT 6
57547: EQUAL
57548: AND
57549: IFFALSE 57605
// begin tmp2 := UnitsInside ( j ) ;
57551: LD_ADDR_VAR 0 9
57555: PUSH
57556: LD_VAR 0 3
57560: PPUSH
57561: CALL_OW 313
57565: ST_TO_ADDR
// if tmp2 = 6 then
57566: LD_VAR 0 9
57570: PUSH
57571: LD_INT 6
57573: EQUAL
57574: IFFALSE 57605
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57576: LD_VAR 0 9
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: PPUSH
57585: LD_INT 112
57587: PPUSH
57588: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57592: LD_VAR 0 9
57596: PUSH
57597: LD_INT 1
57599: ARRAY
57600: PPUSH
57601: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57605: LD_EXP 132
57609: PUSH
57610: LD_VAR 0 2
57614: ARRAY
57615: IFFALSE 57639
57617: PUSH
57618: LD_EXP 132
57622: PUSH
57623: LD_VAR 0 2
57627: ARRAY
57628: PUSH
57629: LD_INT 1
57631: ARRAY
57632: PPUSH
57633: CALL_OW 314
57637: NOT
57638: AND
57639: IFFALSE 57663
57641: PUSH
57642: LD_EXP 132
57646: PUSH
57647: LD_VAR 0 2
57651: ARRAY
57652: PUSH
57653: LD_INT 1
57655: ARRAY
57656: PPUSH
57657: CALL_OW 310
57661: NOT
57662: AND
57663: IFFALSE 57689
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57665: LD_EXP 132
57669: PUSH
57670: LD_VAR 0 2
57674: ARRAY
57675: PUSH
57676: LD_INT 1
57678: ARRAY
57679: PPUSH
57680: LD_VAR 0 3
57684: PPUSH
57685: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57689: LD_EXP 132
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PUSH
57700: LD_INT 1
57702: ARRAY
57703: PPUSH
57704: CALL_OW 310
57708: IFFALSE 57740
57710: PUSH
57711: LD_EXP 132
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_INT 1
57724: ARRAY
57725: PPUSH
57726: CALL_OW 310
57730: PPUSH
57731: CALL_OW 461
57735: PUSH
57736: LD_INT 3
57738: NONEQUAL
57739: AND
57740: IFFALSE 57761
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57742: LD_EXP 132
57746: PUSH
57747: LD_VAR 0 2
57751: ARRAY
57752: PUSH
57753: LD_INT 1
57755: ARRAY
57756: PPUSH
57757: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57761: LD_VAR 0 3
57765: PPUSH
57766: CALL_OW 461
57770: PUSH
57771: LD_INT 6
57773: EQUAL
57774: IFFALSE 57786
57776: PUSH
57777: LD_VAR 0 6
57781: PUSH
57782: LD_INT 1
57784: GREATER
57785: AND
57786: IFFALSE 57940
// begin sci := [ ] ;
57788: LD_ADDR_VAR 0 8
57792: PUSH
57793: EMPTY
57794: ST_TO_ADDR
// for x in ( tmp diff j ) do
57795: LD_ADDR_VAR 0 7
57799: PUSH
57800: LD_VAR 0 6
57804: PUSH
57805: LD_VAR 0 3
57809: DIFF
57810: PUSH
57811: FOR_IN
57812: IFFALSE 57864
// begin if sci = 6 then
57814: LD_VAR 0 8
57818: PUSH
57819: LD_INT 6
57821: EQUAL
57822: IFFALSE 57826
// break ;
57824: GO 57864
// if BuildingStatus ( x ) = bs_idle then
57826: LD_VAR 0 7
57830: PPUSH
57831: CALL_OW 461
57835: PUSH
57836: LD_INT 2
57838: EQUAL
57839: IFFALSE 57862
// sci := sci ^ UnitsInside ( x ) ;
57841: LD_ADDR_VAR 0 8
57845: PUSH
57846: LD_VAR 0 8
57850: PUSH
57851: LD_VAR 0 7
57855: PPUSH
57856: CALL_OW 313
57860: ADD
57861: ST_TO_ADDR
// end ;
57862: GO 57811
57864: POP
57865: POP
// if not sci then
57866: LD_VAR 0 8
57870: NOT
57871: IFFALSE 57875
// continue ;
57873: GO 56896
// for x in sci do
57875: LD_ADDR_VAR 0 7
57879: PUSH
57880: LD_VAR 0 8
57884: PUSH
57885: FOR_IN
57886: IFFALSE 57938
// if IsInUnit ( x ) and not HasTask ( x ) then
57888: LD_VAR 0 7
57892: PPUSH
57893: CALL_OW 310
57897: IFFALSE 57911
57899: PUSH
57900: LD_VAR 0 7
57904: PPUSH
57905: CALL_OW 314
57909: NOT
57910: AND
57911: IFFALSE 57936
// begin ComExitBuilding ( x ) ;
57913: LD_VAR 0 7
57917: PPUSH
57918: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57922: LD_VAR 0 7
57926: PPUSH
57927: LD_VAR 0 3
57931: PPUSH
57932: CALL_OW 180
// end ;
57936: GO 57885
57938: POP
57939: POP
// end ; end ;
57940: GO 56896
57942: POP
57943: POP
// end ;
57944: GO 56850
57946: POP
57947: POP
// end ;
57948: LD_VAR 0 1
57952: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57953: LD_INT 0
57955: PPUSH
57956: PPUSH
// if not mc_bases then
57957: LD_EXP 102
57961: NOT
57962: IFFALSE 57966
// exit ;
57964: GO 58049
// for i = 1 to mc_bases do
57966: LD_ADDR_VAR 0 2
57970: PUSH
57971: DOUBLE
57972: LD_INT 1
57974: DEC
57975: ST_TO_ADDR
57976: LD_EXP 102
57980: PUSH
57981: FOR_TO
57982: IFFALSE 58047
// if mc_mines [ i ] and mc_miners [ i ] then
57984: LD_EXP 115
57988: PUSH
57989: LD_VAR 0 2
57993: ARRAY
57994: IFFALSE 58008
57996: PUSH
57997: LD_EXP 116
58001: PUSH
58002: LD_VAR 0 2
58006: ARRAY
58007: AND
58008: IFFALSE 58045
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58010: LD_EXP 116
58014: PUSH
58015: LD_VAR 0 2
58019: ARRAY
58020: PUSH
58021: LD_INT 1
58023: ARRAY
58024: PPUSH
58025: CALL_OW 255
58029: PPUSH
58030: LD_EXP 115
58034: PUSH
58035: LD_VAR 0 2
58039: ARRAY
58040: PPUSH
58041: CALL 73000 0 2
58045: GO 57981
58047: POP
58048: POP
// end ;
58049: LD_VAR 0 1
58053: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
58054: LD_INT 0
58056: PPUSH
58057: PPUSH
58058: PPUSH
58059: PPUSH
58060: PPUSH
58061: PPUSH
58062: PPUSH
58063: PPUSH
// if not mc_bases or not mc_parking then
58064: LD_EXP 102
58068: NOT
58069: IFTRUE 58078
58071: PUSH
58072: LD_EXP 126
58076: NOT
58077: OR
58078: IFFALSE 58082
// exit ;
58080: GO 58826
// for i = 1 to mc_bases do
58082: LD_ADDR_VAR 0 2
58086: PUSH
58087: DOUBLE
58088: LD_INT 1
58090: DEC
58091: ST_TO_ADDR
58092: LD_EXP 102
58096: PUSH
58097: FOR_TO
58098: IFFALSE 58824
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
58100: LD_EXP 102
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: NOT
58111: IFTRUE 58126
58113: PUSH
58114: LD_EXP 126
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: NOT
58125: OR
58126: IFFALSE 58130
// continue ;
58128: GO 58097
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
58130: LD_ADDR_VAR 0 5
58134: PUSH
58135: LD_EXP 102
58139: PUSH
58140: LD_VAR 0 2
58144: ARRAY
58145: PUSH
58146: LD_INT 1
58148: ARRAY
58149: PPUSH
58150: CALL_OW 255
58154: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58155: LD_ADDR_VAR 0 6
58159: PUSH
58160: LD_EXP 102
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: PPUSH
58171: LD_INT 30
58173: PUSH
58174: LD_INT 3
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: PPUSH
58181: CALL_OW 72
58185: ST_TO_ADDR
// if not fac then
58186: LD_VAR 0 6
58190: NOT
58191: IFFALSE 58242
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58193: LD_ADDR_VAR 0 6
58197: PUSH
58198: LD_EXP 102
58202: PUSH
58203: LD_VAR 0 2
58207: ARRAY
58208: PPUSH
58209: LD_INT 2
58211: PUSH
58212: LD_INT 30
58214: PUSH
58215: LD_INT 0
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 30
58224: PUSH
58225: LD_INT 1
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: PPUSH
58237: CALL_OW 72
58241: ST_TO_ADDR
// if not fac then
58242: LD_VAR 0 6
58246: NOT
58247: IFFALSE 58251
// continue ;
58249: GO 58097
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58251: LD_ADDR_VAR 0 7
58255: PUSH
58256: LD_EXP 126
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: PPUSH
58267: LD_INT 22
58269: PUSH
58270: LD_VAR 0 5
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: LD_INT 21
58281: PUSH
58282: LD_INT 2
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: LD_INT 3
58291: PUSH
58292: LD_INT 60
58294: PUSH
58295: EMPTY
58296: LIST
58297: PUSH
58298: EMPTY
58299: LIST
58300: LIST
58301: PUSH
58302: LD_INT 3
58304: PUSH
58305: LD_INT 24
58307: PUSH
58308: LD_INT 1000
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: LIST
58323: LIST
58324: PPUSH
58325: CALL_OW 70
58329: ST_TO_ADDR
// for j in fac do
58330: LD_ADDR_VAR 0 3
58334: PUSH
58335: LD_VAR 0 6
58339: PUSH
58340: FOR_IN
58341: IFFALSE 58436
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58343: LD_ADDR_VAR 0 7
58347: PUSH
58348: LD_VAR 0 7
58352: PUSH
58353: LD_INT 22
58355: PUSH
58356: LD_VAR 0 5
58360: PUSH
58361: EMPTY
58362: LIST
58363: LIST
58364: PUSH
58365: LD_INT 91
58367: PUSH
58368: LD_VAR 0 3
58372: PUSH
58373: LD_INT 15
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 21
58383: PUSH
58384: LD_INT 2
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: LD_INT 3
58393: PUSH
58394: LD_INT 60
58396: PUSH
58397: EMPTY
58398: LIST
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 3
58406: PUSH
58407: LD_INT 24
58409: PUSH
58410: LD_INT 1000
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: LIST
58425: LIST
58426: LIST
58427: PPUSH
58428: CALL_OW 69
58432: UNION
58433: ST_TO_ADDR
58434: GO 58340
58436: POP
58437: POP
// if not vehs then
58438: LD_VAR 0 7
58442: NOT
58443: IFFALSE 58469
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58445: LD_ADDR_EXP 114
58449: PUSH
58450: LD_EXP 114
58454: PPUSH
58455: LD_VAR 0 2
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// continue ;
58467: GO 58097
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58469: LD_ADDR_VAR 0 8
58473: PUSH
58474: LD_EXP 102
58478: PUSH
58479: LD_VAR 0 2
58483: ARRAY
58484: PPUSH
58485: LD_INT 30
58487: PUSH
58488: LD_INT 3
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PPUSH
58495: CALL_OW 72
58499: ST_TO_ADDR
// if tmp then
58500: LD_VAR 0 8
58504: IFFALSE 58607
// begin for j in tmp do
58506: LD_ADDR_VAR 0 3
58510: PUSH
58511: LD_VAR 0 8
58515: PUSH
58516: FOR_IN
58517: IFFALSE 58605
// for k in UnitsInside ( j ) do
58519: LD_ADDR_VAR 0 4
58523: PUSH
58524: LD_VAR 0 3
58528: PPUSH
58529: CALL_OW 313
58533: PUSH
58534: FOR_IN
58535: IFFALSE 58601
// if k then
58537: LD_VAR 0 4
58541: IFFALSE 58599
// if not k in mc_repair_vehicle [ i ] then
58543: LD_VAR 0 4
58547: PUSH
58548: LD_EXP 114
58552: PUSH
58553: LD_VAR 0 2
58557: ARRAY
58558: IN
58559: NOT
58560: IFFALSE 58599
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58562: LD_ADDR_EXP 114
58566: PUSH
58567: LD_EXP 114
58571: PPUSH
58572: LD_VAR 0 2
58576: PPUSH
58577: LD_EXP 114
58581: PUSH
58582: LD_VAR 0 2
58586: ARRAY
58587: PUSH
58588: LD_VAR 0 4
58592: UNION
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
58599: GO 58534
58601: POP
58602: POP
58603: GO 58516
58605: POP
58606: POP
// end ; if not mc_repair_vehicle [ i ] then
58607: LD_EXP 114
58611: PUSH
58612: LD_VAR 0 2
58616: ARRAY
58617: NOT
58618: IFFALSE 58622
// continue ;
58620: GO 58097
// for j in mc_repair_vehicle [ i ] do
58622: LD_ADDR_VAR 0 3
58626: PUSH
58627: LD_EXP 114
58631: PUSH
58632: LD_VAR 0 2
58636: ARRAY
58637: PUSH
58638: FOR_IN
58639: IFFALSE 58820
// begin if GetClass ( j ) <> 3 then
58641: LD_VAR 0 3
58645: PPUSH
58646: CALL_OW 257
58650: PUSH
58651: LD_INT 3
58653: NONEQUAL
58654: IFFALSE 58695
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58656: LD_ADDR_EXP 114
58660: PUSH
58661: LD_EXP 114
58665: PPUSH
58666: LD_VAR 0 2
58670: PPUSH
58671: LD_EXP 114
58675: PUSH
58676: LD_VAR 0 2
58680: ARRAY
58681: PUSH
58682: LD_VAR 0 3
58686: DIFF
58687: PPUSH
58688: CALL_OW 1
58692: ST_TO_ADDR
// continue ;
58693: GO 58638
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58695: LD_VAR 0 3
58699: PPUSH
58700: CALL_OW 311
58704: NOT
58705: IFFALSE 58730
58707: PUSH
58708: LD_VAR 0 3
58712: PUSH
58713: LD_EXP 105
58717: PUSH
58718: LD_VAR 0 2
58722: ARRAY
58723: PUSH
58724: LD_INT 1
58726: ARRAY
58727: IN
58728: NOT
58729: AND
58730: IFFALSE 58755
58732: PUSH
58733: LD_VAR 0 3
58737: PUSH
58738: LD_EXP 105
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PUSH
58749: LD_INT 2
58751: ARRAY
58752: IN
58753: NOT
58754: AND
58755: IFFALSE 58818
// begin if IsInUnit ( j ) then
58757: LD_VAR 0 3
58761: PPUSH
58762: CALL_OW 310
58766: IFFALSE 58779
// ComExitBuilding ( j ) else
58768: LD_VAR 0 3
58772: PPUSH
58773: CALL_OW 122
58777: GO 58818
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58779: LD_VAR 0 3
58783: PPUSH
58784: LD_VAR 0 7
58788: PUSH
58789: LD_INT 1
58791: ARRAY
58792: PPUSH
58793: CALL 111178 0 2
58797: NOT
58798: IFFALSE 58818
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58800: LD_VAR 0 3
58804: PPUSH
58805: LD_VAR 0 7
58809: PUSH
58810: LD_INT 1
58812: ARRAY
58813: PPUSH
58814: CALL_OW 129
// end ; end ;
58818: GO 58638
58820: POP
58821: POP
// end ;
58822: GO 58097
58824: POP
58825: POP
// end ;
58826: LD_VAR 0 1
58830: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58831: LD_INT 0
58833: PPUSH
58834: PPUSH
58835: PPUSH
58836: PPUSH
58837: PPUSH
58838: PPUSH
58839: PPUSH
58840: PPUSH
58841: PPUSH
58842: PPUSH
58843: PPUSH
// if not mc_bases then
58844: LD_EXP 102
58848: NOT
58849: IFFALSE 58853
// exit ;
58851: GO 59671
// for i = 1 to mc_bases do
58853: LD_ADDR_VAR 0 2
58857: PUSH
58858: DOUBLE
58859: LD_INT 1
58861: DEC
58862: ST_TO_ADDR
58863: LD_EXP 102
58867: PUSH
58868: FOR_TO
58869: IFFALSE 59669
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58871: LD_EXP 130
58875: PUSH
58876: LD_VAR 0 2
58880: ARRAY
58881: NOT
58882: IFTRUE 58900
58884: PUSH
58885: LD_EXP 105
58889: PUSH
58890: LD_VAR 0 2
58894: ARRAY
58895: PUSH
58896: LD_INT 1
58898: ARRAY
58899: OR
58900: IFTRUE 58918
58902: PUSH
58903: LD_EXP 105
58907: PUSH
58908: LD_VAR 0 2
58912: ARRAY
58913: PUSH
58914: LD_INT 2
58916: ARRAY
58917: OR
58918: IFTRUE 58941
58920: PUSH
58921: LD_EXP 128
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: PPUSH
58932: LD_INT 1
58934: PPUSH
58935: CALL_OW 325
58939: NOT
58940: OR
58941: IFTRUE 58955
58943: PUSH
58944: LD_EXP 125
58948: PUSH
58949: LD_VAR 0 2
58953: ARRAY
58954: OR
58955: IFFALSE 58959
// continue ;
58957: GO 58868
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58959: LD_ADDR_VAR 0 8
58963: PUSH
58964: LD_EXP 102
58968: PUSH
58969: LD_VAR 0 2
58973: ARRAY
58974: PPUSH
58975: LD_INT 25
58977: PUSH
58978: LD_INT 4
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: LD_INT 50
58987: PUSH
58988: EMPTY
58989: LIST
58990: PUSH
58991: LD_INT 3
58993: PUSH
58994: LD_INT 60
58996: PUSH
58997: EMPTY
58998: LIST
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: LIST
59008: PPUSH
59009: CALL_OW 72
59013: PUSH
59014: LD_EXP 106
59018: PUSH
59019: LD_VAR 0 2
59023: ARRAY
59024: DIFF
59025: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59026: LD_ADDR_VAR 0 9
59030: PUSH
59031: LD_EXP 102
59035: PUSH
59036: LD_VAR 0 2
59040: ARRAY
59041: PPUSH
59042: LD_INT 2
59044: PUSH
59045: LD_INT 30
59047: PUSH
59048: LD_INT 0
59050: PUSH
59051: EMPTY
59052: LIST
59053: LIST
59054: PUSH
59055: LD_INT 30
59057: PUSH
59058: LD_INT 1
59060: PUSH
59061: EMPTY
59062: LIST
59063: LIST
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: PPUSH
59070: CALL_OW 72
59074: ST_TO_ADDR
// if not tmp or not dep then
59075: LD_VAR 0 8
59079: NOT
59080: IFTRUE 59089
59082: PUSH
59083: LD_VAR 0 9
59087: NOT
59088: OR
59089: IFFALSE 59093
// continue ;
59091: GO 58868
// side := GetSide ( tmp [ 1 ] ) ;
59093: LD_ADDR_VAR 0 11
59097: PUSH
59098: LD_VAR 0 8
59102: PUSH
59103: LD_INT 1
59105: ARRAY
59106: PPUSH
59107: CALL_OW 255
59111: ST_TO_ADDR
// dep := dep [ 1 ] ;
59112: LD_ADDR_VAR 0 9
59116: PUSH
59117: LD_VAR 0 9
59121: PUSH
59122: LD_INT 1
59124: ARRAY
59125: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
59126: LD_ADDR_VAR 0 7
59130: PUSH
59131: LD_EXP 130
59135: PUSH
59136: LD_VAR 0 2
59140: ARRAY
59141: PPUSH
59142: LD_INT 22
59144: PUSH
59145: LD_INT 0
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PUSH
59152: LD_INT 25
59154: PUSH
59155: LD_INT 12
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PPUSH
59166: CALL_OW 70
59170: PUSH
59171: LD_INT 22
59173: PUSH
59174: LD_INT 0
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 25
59183: PUSH
59184: LD_INT 12
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PUSH
59191: LD_INT 91
59193: PUSH
59194: LD_VAR 0 9
59198: PUSH
59199: LD_INT 20
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 69
59216: UNION
59217: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
59218: LD_ADDR_VAR 0 10
59222: PUSH
59223: LD_EXP 130
59227: PUSH
59228: LD_VAR 0 2
59232: ARRAY
59233: PPUSH
59234: LD_INT 81
59236: PUSH
59237: LD_VAR 0 11
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PPUSH
59246: CALL_OW 70
59250: ST_TO_ADDR
// if not apes or danger_at_area then
59251: LD_VAR 0 7
59255: NOT
59256: IFTRUE 59264
59258: PUSH
59259: LD_VAR 0 10
59263: OR
59264: IFFALSE 59314
// begin if mc_taming [ i ] then
59266: LD_EXP 133
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: IFFALSE 59312
// begin MC_Reset ( i , 121 ) ;
59278: LD_VAR 0 2
59282: PPUSH
59283: LD_INT 121
59285: PPUSH
59286: CALL 44046 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59290: LD_ADDR_EXP 133
59294: PUSH
59295: LD_EXP 133
59299: PPUSH
59300: LD_VAR 0 2
59304: PPUSH
59305: EMPTY
59306: PPUSH
59307: CALL_OW 1
59311: ST_TO_ADDR
// end ; continue ;
59312: GO 58868
// end ; for j in tmp do
59314: LD_ADDR_VAR 0 3
59318: PUSH
59319: LD_VAR 0 8
59323: PUSH
59324: FOR_IN
59325: IFFALSE 59665
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
59327: LD_VAR 0 3
59331: PUSH
59332: LD_EXP 133
59336: PUSH
59337: LD_VAR 0 2
59341: ARRAY
59342: IN
59343: NOT
59344: IFFALSE 59362
59346: PUSH
59347: LD_EXP 133
59351: PUSH
59352: LD_VAR 0 2
59356: ARRAY
59357: PUSH
59358: LD_INT 3
59360: LESS
59361: AND
59362: IFFALSE 59420
// begin SetTag ( j , 121 ) ;
59364: LD_VAR 0 3
59368: PPUSH
59369: LD_INT 121
59371: PPUSH
59372: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
59376: LD_ADDR_EXP 133
59380: PUSH
59381: LD_EXP 133
59385: PPUSH
59386: LD_VAR 0 2
59390: PUSH
59391: LD_EXP 133
59395: PUSH
59396: LD_VAR 0 2
59400: ARRAY
59401: PUSH
59402: LD_INT 1
59404: PLUS
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PPUSH
59410: LD_VAR 0 3
59414: PPUSH
59415: CALL 76047 0 3
59419: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
59420: LD_VAR 0 3
59424: PUSH
59425: LD_EXP 133
59429: PUSH
59430: LD_VAR 0 2
59434: ARRAY
59435: IN
59436: IFFALSE 59663
// begin if GetClass ( j ) <> 4 then
59438: LD_VAR 0 3
59442: PPUSH
59443: CALL_OW 257
59447: PUSH
59448: LD_INT 4
59450: NONEQUAL
59451: IFFALSE 59504
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
59453: LD_ADDR_EXP 133
59457: PUSH
59458: LD_EXP 133
59462: PPUSH
59463: LD_VAR 0 2
59467: PPUSH
59468: LD_EXP 133
59472: PUSH
59473: LD_VAR 0 2
59477: ARRAY
59478: PUSH
59479: LD_VAR 0 3
59483: DIFF
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59490: LD_VAR 0 3
59494: PPUSH
59495: LD_INT 0
59497: PPUSH
59498: CALL_OW 109
// continue ;
59502: GO 59324
// end ; if IsInUnit ( j ) then
59504: LD_VAR 0 3
59508: PPUSH
59509: CALL_OW 310
59513: IFFALSE 59524
// ComExitBuilding ( j ) ;
59515: LD_VAR 0 3
59519: PPUSH
59520: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59524: LD_ADDR_VAR 0 6
59528: PUSH
59529: LD_VAR 0 7
59533: PPUSH
59534: LD_VAR 0 3
59538: PPUSH
59539: CALL_OW 74
59543: ST_TO_ADDR
// if not ape then
59544: LD_VAR 0 6
59548: NOT
59549: IFFALSE 59553
// break ;
59551: GO 59665
// x := GetX ( ape ) ;
59553: LD_ADDR_VAR 0 4
59557: PUSH
59558: LD_VAR 0 6
59562: PPUSH
59563: CALL_OW 250
59567: ST_TO_ADDR
// y := GetY ( ape ) ;
59568: LD_ADDR_VAR 0 5
59572: PUSH
59573: LD_VAR 0 6
59577: PPUSH
59578: CALL_OW 251
59582: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59583: LD_VAR 0 4
59587: PPUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: CALL_OW 488
59597: NOT
59598: IFTRUE 59628
59600: PUSH
59601: LD_VAR 0 11
59605: PPUSH
59606: LD_VAR 0 4
59610: PPUSH
59611: LD_VAR 0 5
59615: PPUSH
59616: LD_INT 20
59618: PPUSH
59619: CALL 77317 0 4
59623: PUSH
59624: LD_INT 4
59626: ARRAY
59627: OR
59628: IFFALSE 59632
// break ;
59630: GO 59665
// if not HasTask ( j ) then
59632: LD_VAR 0 3
59636: PPUSH
59637: CALL_OW 314
59641: NOT
59642: IFFALSE 59663
// ComTameXY ( j , x , y ) ;
59644: LD_VAR 0 3
59648: PPUSH
59649: LD_VAR 0 4
59653: PPUSH
59654: LD_VAR 0 5
59658: PPUSH
59659: CALL_OW 131
// end ; end ;
59663: GO 59324
59665: POP
59666: POP
// end ;
59667: GO 58868
59669: POP
59670: POP
// end ;
59671: LD_VAR 0 1
59675: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59676: LD_INT 0
59678: PPUSH
59679: PPUSH
59680: PPUSH
59681: PPUSH
59682: PPUSH
59683: PPUSH
59684: PPUSH
59685: PPUSH
// if not mc_bases then
59686: LD_EXP 102
59690: NOT
59691: IFFALSE 59695
// exit ;
59693: GO 60327
// for i = 1 to mc_bases do
59695: LD_ADDR_VAR 0 2
59699: PUSH
59700: DOUBLE
59701: LD_INT 1
59703: DEC
59704: ST_TO_ADDR
59705: LD_EXP 102
59709: PUSH
59710: FOR_TO
59711: IFFALSE 60325
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59713: LD_EXP 131
59717: PUSH
59718: LD_VAR 0 2
59722: ARRAY
59723: NOT
59724: IFTRUE 59754
59726: PUSH
59727: LD_EXP 131
59731: PUSH
59732: LD_VAR 0 2
59736: ARRAY
59737: PPUSH
59738: LD_INT 25
59740: PUSH
59741: LD_INT 12
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PPUSH
59748: CALL_OW 72
59752: NOT
59753: OR
59754: IFFALSE 59758
// continue ;
59756: GO 59710
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59758: LD_ADDR_VAR 0 5
59762: PUSH
59763: LD_EXP 131
59767: PUSH
59768: LD_VAR 0 2
59772: ARRAY
59773: PUSH
59774: LD_INT 1
59776: ARRAY
59777: PPUSH
59778: CALL_OW 255
59782: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59783: LD_VAR 0 5
59787: PPUSH
59788: LD_INT 2
59790: PPUSH
59791: CALL_OW 325
59795: IFFALSE 60048
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59797: LD_ADDR_VAR 0 4
59801: PUSH
59802: LD_EXP 131
59806: PUSH
59807: LD_VAR 0 2
59811: ARRAY
59812: PPUSH
59813: LD_INT 25
59815: PUSH
59816: LD_INT 16
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PPUSH
59823: CALL_OW 72
59827: ST_TO_ADDR
// if tmp < 6 then
59828: LD_VAR 0 4
59832: PUSH
59833: LD_INT 6
59835: LESS
59836: IFFALSE 60048
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59838: LD_ADDR_VAR 0 6
59842: PUSH
59843: LD_EXP 102
59847: PUSH
59848: LD_VAR 0 2
59852: ARRAY
59853: PPUSH
59854: LD_INT 2
59856: PUSH
59857: LD_INT 30
59859: PUSH
59860: LD_INT 0
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: PUSH
59867: LD_INT 30
59869: PUSH
59870: LD_INT 1
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: PPUSH
59882: CALL_OW 72
59886: ST_TO_ADDR
// if depot then
59887: LD_VAR 0 6
59891: IFFALSE 60048
// begin selected := 0 ;
59893: LD_ADDR_VAR 0 7
59897: PUSH
59898: LD_INT 0
59900: ST_TO_ADDR
// for j in depot do
59901: LD_ADDR_VAR 0 3
59905: PUSH
59906: LD_VAR 0 6
59910: PUSH
59911: FOR_IN
59912: IFFALSE 59943
// begin if UnitsInside ( j ) < 6 then
59914: LD_VAR 0 3
59918: PPUSH
59919: CALL_OW 313
59923: PUSH
59924: LD_INT 6
59926: LESS
59927: IFFALSE 59941
// begin selected := j ;
59929: LD_ADDR_VAR 0 7
59933: PUSH
59934: LD_VAR 0 3
59938: ST_TO_ADDR
// break ;
59939: GO 59943
// end ; end ;
59941: GO 59911
59943: POP
59944: POP
// if selected then
59945: LD_VAR 0 7
59949: IFFALSE 60048
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59951: LD_ADDR_VAR 0 3
59955: PUSH
59956: LD_EXP 131
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: PPUSH
59967: LD_INT 25
59969: PUSH
59970: LD_INT 12
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PPUSH
59977: CALL_OW 72
59981: PUSH
59982: FOR_IN
59983: IFFALSE 60046
// if not HasTask ( j ) then
59985: LD_VAR 0 3
59989: PPUSH
59990: CALL_OW 314
59994: NOT
59995: IFFALSE 60044
// begin if not IsInUnit ( j ) then
59997: LD_VAR 0 3
60001: PPUSH
60002: CALL_OW 310
60006: NOT
60007: IFFALSE 60023
// ComEnterUnit ( j , selected ) ;
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_VAR 0 7
60018: PPUSH
60019: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60023: LD_VAR 0 3
60027: PPUSH
60028: LD_INT 16
60030: PPUSH
60031: CALL_OW 183
// AddComExitBuilding ( j ) ;
60035: LD_VAR 0 3
60039: PPUSH
60040: CALL_OW 182
// end ;
60044: GO 59982
60046: POP
60047: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_INT 11
60055: PPUSH
60056: CALL_OW 325
60060: IFFALSE 60323
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60062: LD_ADDR_VAR 0 4
60066: PUSH
60067: LD_EXP 131
60071: PUSH
60072: LD_VAR 0 2
60076: ARRAY
60077: PPUSH
60078: LD_INT 25
60080: PUSH
60081: LD_INT 16
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PPUSH
60088: CALL_OW 72
60092: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60093: LD_VAR 0 4
60097: PUSH
60098: LD_INT 6
60100: GREATEREQUAL
60101: IFTRUE 60118
60103: PUSH
60104: LD_VAR 0 5
60108: PPUSH
60109: LD_INT 2
60111: PPUSH
60112: CALL_OW 325
60116: NOT
60117: OR
60118: IFFALSE 60323
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60120: LD_ADDR_VAR 0 8
60124: PUSH
60125: LD_EXP 102
60129: PUSH
60130: LD_VAR 0 2
60134: ARRAY
60135: PPUSH
60136: LD_INT 2
60138: PUSH
60139: LD_INT 30
60141: PUSH
60142: LD_INT 4
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 30
60151: PUSH
60152: LD_INT 5
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: LIST
60163: PPUSH
60164: CALL_OW 72
60168: ST_TO_ADDR
// if barracks then
60169: LD_VAR 0 8
60173: IFFALSE 60323
// begin selected := 0 ;
60175: LD_ADDR_VAR 0 7
60179: PUSH
60180: LD_INT 0
60182: ST_TO_ADDR
// for j in barracks do
60183: LD_ADDR_VAR 0 3
60187: PUSH
60188: LD_VAR 0 8
60192: PUSH
60193: FOR_IN
60194: IFFALSE 60225
// begin if UnitsInside ( j ) < 6 then
60196: LD_VAR 0 3
60200: PPUSH
60201: CALL_OW 313
60205: PUSH
60206: LD_INT 6
60208: LESS
60209: IFFALSE 60223
// begin selected := j ;
60211: LD_ADDR_VAR 0 7
60215: PUSH
60216: LD_VAR 0 3
60220: ST_TO_ADDR
// break ;
60221: GO 60225
// end ; end ;
60223: GO 60193
60225: POP
60226: POP
// if selected then
60227: LD_VAR 0 7
60231: IFFALSE 60323
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60233: LD_ADDR_VAR 0 3
60237: PUSH
60238: LD_EXP 131
60242: PUSH
60243: LD_VAR 0 2
60247: ARRAY
60248: PPUSH
60249: LD_INT 25
60251: PUSH
60252: LD_INT 12
60254: PUSH
60255: EMPTY
60256: LIST
60257: LIST
60258: PPUSH
60259: CALL_OW 72
60263: PUSH
60264: FOR_IN
60265: IFFALSE 60321
// if not IsInUnit ( j ) and not HasTask ( j ) then
60267: LD_VAR 0 3
60271: PPUSH
60272: CALL_OW 310
60276: NOT
60277: IFFALSE 60291
60279: PUSH
60280: LD_VAR 0 3
60284: PPUSH
60285: CALL_OW 314
60289: NOT
60290: AND
60291: IFFALSE 60319
// begin ComEnterUnit ( j , selected ) ;
60293: LD_VAR 0 3
60297: PPUSH
60298: LD_VAR 0 7
60302: PPUSH
60303: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
60307: LD_VAR 0 3
60311: PPUSH
60312: LD_INT 15
60314: PPUSH
60315: CALL_OW 183
// end ;
60319: GO 60264
60321: POP
60322: POP
// end ; end ; end ; end ; end ;
60323: GO 59710
60325: POP
60326: POP
// end ;
60327: LD_VAR 0 1
60331: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
60332: LD_INT 0
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
// if not mc_bases then
60338: LD_EXP 102
60342: NOT
60343: IFFALSE 60347
// exit ;
60345: GO 60529
// for i = 1 to mc_bases do
60347: LD_ADDR_VAR 0 2
60351: PUSH
60352: DOUBLE
60353: LD_INT 1
60355: DEC
60356: ST_TO_ADDR
60357: LD_EXP 102
60361: PUSH
60362: FOR_TO
60363: IFFALSE 60527
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
60365: LD_ADDR_VAR 0 4
60369: PUSH
60370: LD_EXP 102
60374: PUSH
60375: LD_VAR 0 2
60379: ARRAY
60380: PPUSH
60381: LD_INT 25
60383: PUSH
60384: LD_INT 9
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PPUSH
60391: CALL_OW 72
60395: ST_TO_ADDR
// if not tmp then
60396: LD_VAR 0 4
60400: NOT
60401: IFFALSE 60405
// continue ;
60403: GO 60362
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
60405: LD_EXP 128
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PPUSH
60416: LD_INT 29
60418: PPUSH
60419: CALL_OW 325
60423: NOT
60424: IFFALSE 60447
60426: PUSH
60427: LD_EXP 128
60431: PUSH
60432: LD_VAR 0 2
60436: ARRAY
60437: PPUSH
60438: LD_INT 28
60440: PPUSH
60441: CALL_OW 325
60445: NOT
60446: AND
60447: IFFALSE 60451
// continue ;
60449: GO 60362
// for j in tmp do
60451: LD_ADDR_VAR 0 3
60455: PUSH
60456: LD_VAR 0 4
60460: PUSH
60461: FOR_IN
60462: IFFALSE 60523
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
60464: LD_VAR 0 3
60468: PUSH
60469: LD_EXP 105
60473: PUSH
60474: LD_VAR 0 2
60478: ARRAY
60479: PUSH
60480: LD_INT 1
60482: ARRAY
60483: IN
60484: NOT
60485: IFFALSE 60510
60487: PUSH
60488: LD_VAR 0 3
60492: PUSH
60493: LD_EXP 105
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PUSH
60504: LD_INT 2
60506: ARRAY
60507: IN
60508: NOT
60509: AND
60510: IFFALSE 60521
// ComSpaceTimeShoot ( j ) ;
60512: LD_VAR 0 3
60516: PPUSH
60517: CALL 71998 0 1
60521: GO 60461
60523: POP
60524: POP
// end ;
60525: GO 60362
60527: POP
60528: POP
// end ;
60529: LD_VAR 0 1
60533: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
60538: PPUSH
60539: PPUSH
60540: PPUSH
60541: PPUSH
60542: PPUSH
60543: PPUSH
60544: PPUSH
// if not mc_bases then
60545: LD_EXP 102
60549: NOT
60550: IFFALSE 60554
// exit ;
60552: GO 61186
// for i = 1 to mc_bases do
60554: LD_ADDR_VAR 0 2
60558: PUSH
60559: DOUBLE
60560: LD_INT 1
60562: DEC
60563: ST_TO_ADDR
60564: LD_EXP 102
60568: PUSH
60569: FOR_TO
60570: IFFALSE 61184
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60572: LD_EXP 137
60576: PUSH
60577: LD_VAR 0 2
60581: ARRAY
60582: NOT
60583: IFTRUE 60609
60585: PUSH
60586: LD_INT 38
60588: PPUSH
60589: LD_EXP 128
60593: PUSH
60594: LD_VAR 0 2
60598: ARRAY
60599: PPUSH
60600: CALL_OW 321
60604: PUSH
60605: LD_INT 2
60607: NONEQUAL
60608: OR
60609: IFFALSE 60613
// continue ;
60611: GO 60569
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60613: LD_ADDR_VAR 0 8
60617: PUSH
60618: LD_EXP 102
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PPUSH
60629: LD_INT 30
60631: PUSH
60632: LD_INT 34
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PPUSH
60639: CALL_OW 72
60643: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60644: LD_ADDR_VAR 0 9
60648: PUSH
60649: LD_EXP 102
60653: PUSH
60654: LD_VAR 0 2
60658: ARRAY
60659: PPUSH
60660: LD_INT 25
60662: PUSH
60663: LD_INT 4
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PPUSH
60670: CALL_OW 72
60674: PPUSH
60675: LD_INT 0
60677: PPUSH
60678: CALL 106640 0 2
60682: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60683: LD_VAR 0 9
60687: NOT
60688: IFTRUE 60697
60690: PUSH
60691: LD_VAR 0 8
60695: NOT
60696: OR
60697: IFTRUE 60719
60699: PUSH
60700: LD_EXP 102
60704: PUSH
60705: LD_VAR 0 2
60709: ARRAY
60710: PPUSH
60711: LD_INT 124
60713: PPUSH
60714: CALL 106640 0 2
60718: OR
60719: IFFALSE 60723
// continue ;
60721: GO 60569
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60723: LD_EXP 138
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: PUSH
60734: LD_EXP 137
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: LESS
60745: IFFALSE 60765
60747: PUSH
60748: LD_EXP 138
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PUSH
60759: LD_VAR 0 8
60763: LESS
60764: AND
60765: IFFALSE 61182
// begin tmp := sci [ 1 ] ;
60767: LD_ADDR_VAR 0 7
60771: PUSH
60772: LD_VAR 0 9
60776: PUSH
60777: LD_INT 1
60779: ARRAY
60780: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60781: LD_VAR 0 7
60785: PPUSH
60786: LD_INT 124
60788: PPUSH
60789: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60793: LD_ADDR_VAR 0 3
60797: PUSH
60798: DOUBLE
60799: LD_EXP 137
60803: PUSH
60804: LD_VAR 0 2
60808: ARRAY
60809: INC
60810: ST_TO_ADDR
60811: LD_EXP 137
60815: PUSH
60816: LD_VAR 0 2
60820: ARRAY
60821: PUSH
60822: FOR_DOWNTO
60823: IFFALSE 61168
// begin if IsInUnit ( tmp ) then
60825: LD_VAR 0 7
60829: PPUSH
60830: CALL_OW 310
60834: IFFALSE 60845
// ComExitBuilding ( tmp ) ;
60836: LD_VAR 0 7
60840: PPUSH
60841: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60845: LD_INT 35
60847: PPUSH
60848: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60852: LD_VAR 0 7
60856: PPUSH
60857: CALL_OW 310
60861: NOT
60862: IFFALSE 60876
60864: PUSH
60865: LD_VAR 0 7
60869: PPUSH
60870: CALL_OW 314
60874: NOT
60875: AND
60876: IFFALSE 60845
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60878: LD_ADDR_VAR 0 6
60882: PUSH
60883: LD_VAR 0 7
60887: PPUSH
60888: CALL_OW 250
60892: PUSH
60893: LD_VAR 0 7
60897: PPUSH
60898: CALL_OW 251
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60907: LD_INT 35
60909: PPUSH
60910: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60914: LD_ADDR_VAR 0 4
60918: PUSH
60919: LD_EXP 137
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: PUSH
60930: LD_VAR 0 3
60934: ARRAY
60935: PUSH
60936: LD_INT 1
60938: ARRAY
60939: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60940: LD_ADDR_VAR 0 5
60944: PUSH
60945: LD_EXP 137
60949: PUSH
60950: LD_VAR 0 2
60954: ARRAY
60955: PUSH
60956: LD_VAR 0 3
60960: ARRAY
60961: PUSH
60962: LD_INT 2
60964: ARRAY
60965: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60966: LD_VAR 0 7
60970: PPUSH
60971: LD_INT 10
60973: PPUSH
60974: CALL 79026 0 2
60978: PUSH
60979: LD_INT 4
60981: ARRAY
60982: IFFALSE 61020
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60984: LD_VAR 0 7
60988: PPUSH
60989: LD_VAR 0 6
60993: PUSH
60994: LD_INT 1
60996: ARRAY
60997: PPUSH
60998: LD_VAR 0 6
61002: PUSH
61003: LD_INT 2
61005: ARRAY
61006: PPUSH
61007: CALL_OW 111
// wait ( 0 0$10 ) ;
61011: LD_INT 350
61013: PPUSH
61014: CALL_OW 67
// end else
61018: GO 61046
// begin ComMoveXY ( tmp , x , y ) ;
61020: LD_VAR 0 7
61024: PPUSH
61025: LD_VAR 0 4
61029: PPUSH
61030: LD_VAR 0 5
61034: PPUSH
61035: CALL_OW 111
// wait ( 0 0$3 ) ;
61039: LD_INT 105
61041: PPUSH
61042: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61046: LD_VAR 0 7
61050: PPUSH
61051: LD_VAR 0 4
61055: PPUSH
61056: LD_VAR 0 5
61060: PPUSH
61061: CALL_OW 307
61065: IFFALSE 60907
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61067: LD_VAR 0 7
61071: PPUSH
61072: LD_VAR 0 4
61076: PPUSH
61077: LD_VAR 0 5
61081: PPUSH
61082: LD_VAR 0 8
61086: PUSH
61087: LD_VAR 0 3
61091: ARRAY
61092: PPUSH
61093: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61097: LD_INT 35
61099: PPUSH
61100: CALL_OW 67
// until not HasTask ( tmp ) ;
61104: LD_VAR 0 7
61108: PPUSH
61109: CALL_OW 314
61113: NOT
61114: IFFALSE 61097
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
61116: LD_ADDR_EXP 138
61120: PUSH
61121: LD_EXP 138
61125: PPUSH
61126: LD_VAR 0 2
61130: PUSH
61131: LD_EXP 138
61135: PUSH
61136: LD_VAR 0 2
61140: ARRAY
61141: PUSH
61142: LD_INT 1
61144: PLUS
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: LD_VAR 0 8
61154: PUSH
61155: LD_VAR 0 3
61159: ARRAY
61160: PPUSH
61161: CALL 76047 0 3
61165: ST_TO_ADDR
// end ;
61166: GO 60822
61168: POP
61169: POP
// MC_Reset ( i , 124 ) ;
61170: LD_VAR 0 2
61174: PPUSH
61175: LD_INT 124
61177: PPUSH
61178: CALL 44046 0 2
// end ; end ;
61182: GO 60569
61184: POP
61185: POP
// end ;
61186: LD_VAR 0 1
61190: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
61191: LD_INT 0
61193: PPUSH
61194: PPUSH
61195: PPUSH
// if not mc_bases then
61196: LD_EXP 102
61200: NOT
61201: IFFALSE 61205
// exit ;
61203: GO 61819
// for i = 1 to mc_bases do
61205: LD_ADDR_VAR 0 2
61209: PUSH
61210: DOUBLE
61211: LD_INT 1
61213: DEC
61214: ST_TO_ADDR
61215: LD_EXP 102
61219: PUSH
61220: FOR_TO
61221: IFFALSE 61817
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61223: LD_ADDR_VAR 0 3
61227: PUSH
61228: LD_EXP 102
61232: PUSH
61233: LD_VAR 0 2
61237: ARRAY
61238: PPUSH
61239: LD_INT 25
61241: PUSH
61242: LD_INT 4
61244: PUSH
61245: EMPTY
61246: LIST
61247: LIST
61248: PPUSH
61249: CALL_OW 72
61253: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61254: LD_VAR 0 3
61258: NOT
61259: IFTRUE 61274
61261: PUSH
61262: LD_EXP 139
61266: PUSH
61267: LD_VAR 0 2
61271: ARRAY
61272: NOT
61273: OR
61274: IFTRUE 61322
61276: PUSH
61277: LD_EXP 102
61281: PUSH
61282: LD_VAR 0 2
61286: ARRAY
61287: PPUSH
61288: LD_INT 2
61290: PUSH
61291: LD_INT 30
61293: PUSH
61294: LD_INT 0
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 1
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: PPUSH
61316: CALL_OW 72
61320: NOT
61321: OR
61322: IFFALSE 61372
// begin if mc_deposits_finder [ i ] then
61324: LD_EXP 140
61328: PUSH
61329: LD_VAR 0 2
61333: ARRAY
61334: IFFALSE 61370
// begin MC_Reset ( i , 125 ) ;
61336: LD_VAR 0 2
61340: PPUSH
61341: LD_INT 125
61343: PPUSH
61344: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61348: LD_ADDR_EXP 140
61352: PUSH
61353: LD_EXP 140
61357: PPUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: EMPTY
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// end ; continue ;
61370: GO 61220
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
61372: LD_EXP 139
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PUSH
61383: LD_INT 1
61385: ARRAY
61386: PUSH
61387: LD_INT 3
61389: ARRAY
61390: PUSH
61391: LD_INT 1
61393: EQUAL
61394: IFFALSE 61420
61396: PUSH
61397: LD_INT 20
61399: PPUSH
61400: LD_EXP 128
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: PPUSH
61411: CALL_OW 321
61415: PUSH
61416: LD_INT 2
61418: NONEQUAL
61419: AND
61420: IFFALSE 61470
// begin if mc_deposits_finder [ i ] then
61422: LD_EXP 140
61426: PUSH
61427: LD_VAR 0 2
61431: ARRAY
61432: IFFALSE 61468
// begin MC_Reset ( i , 125 ) ;
61434: LD_VAR 0 2
61438: PPUSH
61439: LD_INT 125
61441: PPUSH
61442: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61446: LD_ADDR_EXP 140
61450: PUSH
61451: LD_EXP 140
61455: PPUSH
61456: LD_VAR 0 2
61460: PPUSH
61461: EMPTY
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// end ; continue ;
61468: GO 61220
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
61470: LD_EXP 139
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: ARRAY
61484: PUSH
61485: LD_INT 1
61487: ARRAY
61488: PPUSH
61489: LD_EXP 139
61493: PUSH
61494: LD_VAR 0 2
61498: ARRAY
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: PUSH
61504: LD_INT 2
61506: ARRAY
61507: PPUSH
61508: LD_EXP 128
61512: PUSH
61513: LD_VAR 0 2
61517: ARRAY
61518: PPUSH
61519: CALL_OW 440
61523: IFFALSE 61566
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61525: LD_ADDR_EXP 139
61529: PUSH
61530: LD_EXP 139
61534: PPUSH
61535: LD_VAR 0 2
61539: PPUSH
61540: LD_EXP 139
61544: PUSH
61545: LD_VAR 0 2
61549: ARRAY
61550: PPUSH
61551: LD_INT 1
61553: PPUSH
61554: CALL_OW 3
61558: PPUSH
61559: CALL_OW 1
61563: ST_TO_ADDR
61564: GO 61815
// begin if not mc_deposits_finder [ i ] then
61566: LD_EXP 140
61570: PUSH
61571: LD_VAR 0 2
61575: ARRAY
61576: NOT
61577: IFFALSE 61629
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61579: LD_ADDR_EXP 140
61583: PUSH
61584: LD_EXP 140
61588: PPUSH
61589: LD_VAR 0 2
61593: PPUSH
61594: LD_VAR 0 3
61598: PUSH
61599: LD_INT 1
61601: ARRAY
61602: PUSH
61603: EMPTY
61604: LIST
61605: PPUSH
61606: CALL_OW 1
61610: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61611: LD_VAR 0 3
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: LD_INT 125
61622: PPUSH
61623: CALL_OW 109
// end else
61627: GO 61815
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61629: LD_EXP 140
61633: PUSH
61634: LD_VAR 0 2
61638: ARRAY
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: CALL_OW 310
61648: IFFALSE 61671
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61650: LD_EXP 140
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: PPUSH
61665: CALL_OW 122
61669: GO 61815
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61671: LD_EXP 140
61675: PUSH
61676: LD_VAR 0 2
61680: ARRAY
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: PPUSH
61686: CALL_OW 314
61690: NOT
61691: IFFALSE 61756
61693: PUSH
61694: LD_EXP 140
61698: PUSH
61699: LD_VAR 0 2
61703: ARRAY
61704: PUSH
61705: LD_INT 1
61707: ARRAY
61708: PPUSH
61709: LD_EXP 139
61713: PUSH
61714: LD_VAR 0 2
61718: ARRAY
61719: PUSH
61720: LD_INT 1
61722: ARRAY
61723: PUSH
61724: LD_INT 1
61726: ARRAY
61727: PPUSH
61728: LD_EXP 139
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: PUSH
61743: LD_INT 2
61745: ARRAY
61746: PPUSH
61747: CALL_OW 297
61751: PUSH
61752: LD_INT 6
61754: GREATER
61755: AND
61756: IFFALSE 61815
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61758: LD_EXP 140
61762: PUSH
61763: LD_VAR 0 2
61767: ARRAY
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: PPUSH
61773: LD_EXP 139
61777: PUSH
61778: LD_VAR 0 2
61782: ARRAY
61783: PUSH
61784: LD_INT 1
61786: ARRAY
61787: PUSH
61788: LD_INT 1
61790: ARRAY
61791: PPUSH
61792: LD_EXP 139
61796: PUSH
61797: LD_VAR 0 2
61801: ARRAY
61802: PUSH
61803: LD_INT 1
61805: ARRAY
61806: PUSH
61807: LD_INT 2
61809: ARRAY
61810: PPUSH
61811: CALL_OW 111
// end ; end ; end ;
61815: GO 61220
61817: POP
61818: POP
// end ;
61819: LD_VAR 0 1
61823: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61824: LD_INT 0
61826: PPUSH
61827: PPUSH
61828: PPUSH
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
61836: PPUSH
// if not mc_bases then
61837: LD_EXP 102
61841: NOT
61842: IFFALSE 61846
// exit ;
61844: GO 62806
// for i = 1 to mc_bases do
61846: LD_ADDR_VAR 0 2
61850: PUSH
61851: DOUBLE
61852: LD_INT 1
61854: DEC
61855: ST_TO_ADDR
61856: LD_EXP 102
61860: PUSH
61861: FOR_TO
61862: IFFALSE 62804
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61864: LD_EXP 102
61868: PUSH
61869: LD_VAR 0 2
61873: ARRAY
61874: NOT
61875: IFTRUE 61889
61877: PUSH
61878: LD_EXP 125
61882: PUSH
61883: LD_VAR 0 2
61887: ARRAY
61888: OR
61889: IFFALSE 61893
// continue ;
61891: GO 61861
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61893: LD_ADDR_VAR 0 7
61897: PUSH
61898: LD_EXP 102
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: PUSH
61909: LD_INT 1
61911: ARRAY
61912: PPUSH
61913: CALL_OW 248
61917: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61918: LD_VAR 0 7
61922: PUSH
61923: LD_INT 3
61925: EQUAL
61926: IFTRUE 61968
61928: PUSH
61929: LD_EXP 121
61933: PUSH
61934: LD_VAR 0 2
61938: ARRAY
61939: PUSH
61940: LD_EXP 124
61944: PUSH
61945: LD_VAR 0 2
61949: ARRAY
61950: UNION
61951: PPUSH
61952: LD_INT 33
61954: PUSH
61955: LD_INT 2
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL_OW 72
61966: NOT
61967: OR
61968: IFFALSE 61972
// continue ;
61970: GO 61861
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61972: LD_ADDR_VAR 0 9
61976: PUSH
61977: LD_EXP 102
61981: PUSH
61982: LD_VAR 0 2
61986: ARRAY
61987: PPUSH
61988: LD_INT 30
61990: PUSH
61991: LD_INT 36
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PPUSH
61998: CALL_OW 72
62002: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62003: LD_ADDR_VAR 0 10
62007: PUSH
62008: LD_EXP 121
62012: PUSH
62013: LD_VAR 0 2
62017: ARRAY
62018: PPUSH
62019: LD_INT 34
62021: PUSH
62022: LD_INT 31
62024: PUSH
62025: EMPTY
62026: LIST
62027: LIST
62028: PPUSH
62029: CALL_OW 72
62033: ST_TO_ADDR
// if not cts and not mcts then
62034: LD_VAR 0 9
62038: NOT
62039: IFFALSE 62048
62041: PUSH
62042: LD_VAR 0 10
62046: NOT
62047: AND
62048: IFFALSE 62052
// continue ;
62050: GO 61861
// x := cts ;
62052: LD_ADDR_VAR 0 11
62056: PUSH
62057: LD_VAR 0 9
62061: ST_TO_ADDR
// if not x then
62062: LD_VAR 0 11
62066: NOT
62067: IFFALSE 62079
// x := mcts ;
62069: LD_ADDR_VAR 0 11
62073: PUSH
62074: LD_VAR 0 10
62078: ST_TO_ADDR
// if not x then
62079: LD_VAR 0 11
62083: NOT
62084: IFFALSE 62088
// continue ;
62086: GO 61861
// if mc_remote_driver [ i ] then
62088: LD_EXP 142
62092: PUSH
62093: LD_VAR 0 2
62097: ARRAY
62098: IFFALSE 62497
// for j in mc_remote_driver [ i ] do
62100: LD_ADDR_VAR 0 3
62104: PUSH
62105: LD_EXP 142
62109: PUSH
62110: LD_VAR 0 2
62114: ARRAY
62115: PUSH
62116: FOR_IN
62117: IFFALSE 62495
// begin if GetClass ( j ) <> 3 then
62119: LD_VAR 0 3
62123: PPUSH
62124: CALL_OW 257
62128: PUSH
62129: LD_INT 3
62131: NONEQUAL
62132: IFFALSE 62185
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
62134: LD_ADDR_EXP 142
62138: PUSH
62139: LD_EXP 142
62143: PPUSH
62144: LD_VAR 0 2
62148: PPUSH
62149: LD_EXP 142
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: PUSH
62160: LD_VAR 0 3
62164: DIFF
62165: PPUSH
62166: CALL_OW 1
62170: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62171: LD_VAR 0 3
62175: PPUSH
62176: LD_INT 0
62178: PPUSH
62179: CALL_OW 109
// continue ;
62183: GO 62116
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
62185: LD_EXP 121
62189: PUSH
62190: LD_VAR 0 2
62194: ARRAY
62195: PPUSH
62196: LD_INT 34
62198: PUSH
62199: LD_INT 31
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PUSH
62206: LD_INT 58
62208: PUSH
62209: EMPTY
62210: LIST
62211: PUSH
62212: EMPTY
62213: LIST
62214: LIST
62215: PPUSH
62216: CALL_OW 72
62220: IFFALSE 62234
62222: PUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: CALL 106675 0 1
62232: NOT
62233: AND
62234: IFFALSE 62305
// begin if IsInUnit ( j ) then
62236: LD_VAR 0 3
62240: PPUSH
62241: CALL_OW 310
62245: IFFALSE 62256
// ComExitBuilding ( j ) ;
62247: LD_VAR 0 3
62251: PPUSH
62252: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
62256: LD_VAR 0 3
62260: PPUSH
62261: LD_EXP 121
62265: PUSH
62266: LD_VAR 0 2
62270: ARRAY
62271: PPUSH
62272: LD_INT 34
62274: PUSH
62275: LD_INT 31
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 58
62284: PUSH
62285: EMPTY
62286: LIST
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PPUSH
62292: CALL_OW 72
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: PPUSH
62301: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
62305: LD_VAR 0 3
62309: PPUSH
62310: CALL_OW 310
62314: NOT
62315: IFTRUE 62351
62317: PUSH
62318: LD_VAR 0 3
62322: PPUSH
62323: CALL_OW 310
62327: PPUSH
62328: CALL_OW 266
62332: PUSH
62333: LD_INT 36
62335: NONEQUAL
62336: IFFALSE 62350
62338: PUSH
62339: LD_VAR 0 3
62343: PPUSH
62344: CALL 106675 0 1
62348: NOT
62349: AND
62350: OR
62351: IFFALSE 62493
// begin if IsInUnit ( j ) then
62353: LD_VAR 0 3
62357: PPUSH
62358: CALL_OW 310
62362: IFFALSE 62373
// ComExitBuilding ( j ) ;
62364: LD_VAR 0 3
62368: PPUSH
62369: CALL_OW 122
// ct := 0 ;
62373: LD_ADDR_VAR 0 8
62377: PUSH
62378: LD_INT 0
62380: ST_TO_ADDR
// for k in x do
62381: LD_ADDR_VAR 0 4
62385: PUSH
62386: LD_VAR 0 11
62390: PUSH
62391: FOR_IN
62392: IFFALSE 62471
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
62394: LD_VAR 0 4
62398: PPUSH
62399: CALL_OW 264
62403: PUSH
62404: LD_INT 31
62406: EQUAL
62407: IFFALSE 62421
62409: PUSH
62410: LD_VAR 0 4
62414: PPUSH
62415: CALL_OW 311
62419: NOT
62420: AND
62421: IFTRUE 62455
62423: PUSH
62424: LD_VAR 0 4
62428: PPUSH
62429: CALL_OW 266
62433: PUSH
62434: LD_INT 36
62436: EQUAL
62437: IFFALSE 62454
62439: PUSH
62440: LD_VAR 0 4
62444: PPUSH
62445: CALL_OW 313
62449: PUSH
62450: LD_INT 3
62452: LESS
62453: AND
62454: OR
62455: IFFALSE 62469
// begin ct := k ;
62457: LD_ADDR_VAR 0 8
62461: PUSH
62462: LD_VAR 0 4
62466: ST_TO_ADDR
// break ;
62467: GO 62471
// end ;
62469: GO 62391
62471: POP
62472: POP
// if ct then
62473: LD_VAR 0 8
62477: IFFALSE 62493
// ComEnterUnit ( j , ct ) ;
62479: LD_VAR 0 3
62483: PPUSH
62484: LD_VAR 0 8
62488: PPUSH
62489: CALL_OW 120
// end ; end ;
62493: GO 62116
62495: POP
62496: POP
// places := 0 ;
62497: LD_ADDR_VAR 0 5
62501: PUSH
62502: LD_INT 0
62504: ST_TO_ADDR
// for j = 1 to x do
62505: LD_ADDR_VAR 0 3
62509: PUSH
62510: DOUBLE
62511: LD_INT 1
62513: DEC
62514: ST_TO_ADDR
62515: LD_VAR 0 11
62519: PUSH
62520: FOR_TO
62521: IFFALSE 62597
// if GetWeapon ( x [ j ] ) = ar_control_tower then
62523: LD_VAR 0 11
62527: PUSH
62528: LD_VAR 0 3
62532: ARRAY
62533: PPUSH
62534: CALL_OW 264
62538: PUSH
62539: LD_INT 31
62541: EQUAL
62542: IFFALSE 62560
// places := places + 1 else
62544: LD_ADDR_VAR 0 5
62548: PUSH
62549: LD_VAR 0 5
62553: PUSH
62554: LD_INT 1
62556: PLUS
62557: ST_TO_ADDR
62558: GO 62595
// if GetBType ( x [ j ] ) = b_control_tower then
62560: LD_VAR 0 11
62564: PUSH
62565: LD_VAR 0 3
62569: ARRAY
62570: PPUSH
62571: CALL_OW 266
62575: PUSH
62576: LD_INT 36
62578: EQUAL
62579: IFFALSE 62595
// places := places + 3 ;
62581: LD_ADDR_VAR 0 5
62585: PUSH
62586: LD_VAR 0 5
62590: PUSH
62591: LD_INT 3
62593: PLUS
62594: ST_TO_ADDR
62595: GO 62520
62597: POP
62598: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62599: LD_VAR 0 5
62603: PUSH
62604: LD_INT 0
62606: EQUAL
62607: IFTRUE 62627
62609: PUSH
62610: LD_VAR 0 5
62614: PUSH
62615: LD_EXP 142
62619: PUSH
62620: LD_VAR 0 2
62624: ARRAY
62625: LESSEQUAL
62626: OR
62627: IFFALSE 62631
// continue ;
62629: GO 61861
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62631: LD_ADDR_VAR 0 6
62635: PUSH
62636: LD_EXP 102
62640: PUSH
62641: LD_VAR 0 2
62645: ARRAY
62646: PPUSH
62647: LD_INT 25
62649: PUSH
62650: LD_INT 3
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PPUSH
62657: CALL_OW 72
62661: PUSH
62662: LD_EXP 142
62666: PUSH
62667: LD_VAR 0 2
62671: ARRAY
62672: DIFF
62673: PPUSH
62674: LD_INT 3
62676: PPUSH
62677: CALL 107575 0 2
62681: ST_TO_ADDR
// for j in tmp do
62682: LD_ADDR_VAR 0 3
62686: PUSH
62687: LD_VAR 0 6
62691: PUSH
62692: FOR_IN
62693: IFFALSE 62728
// if GetTag ( j ) > 0 then
62695: LD_VAR 0 3
62699: PPUSH
62700: CALL_OW 110
62704: PUSH
62705: LD_INT 0
62707: GREATER
62708: IFFALSE 62726
// tmp := tmp diff j ;
62710: LD_ADDR_VAR 0 6
62714: PUSH
62715: LD_VAR 0 6
62719: PUSH
62720: LD_VAR 0 3
62724: DIFF
62725: ST_TO_ADDR
62726: GO 62692
62728: POP
62729: POP
// if not tmp then
62730: LD_VAR 0 6
62734: NOT
62735: IFFALSE 62739
// continue ;
62737: GO 61861
// if places then
62739: LD_VAR 0 5
62743: IFFALSE 62802
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62745: LD_ADDR_EXP 142
62749: PUSH
62750: LD_EXP 142
62754: PPUSH
62755: LD_VAR 0 2
62759: PPUSH
62760: LD_EXP 142
62764: PUSH
62765: LD_VAR 0 2
62769: ARRAY
62770: PUSH
62771: LD_VAR 0 6
62775: PUSH
62776: LD_INT 1
62778: ARRAY
62779: UNION
62780: PPUSH
62781: CALL_OW 1
62785: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62786: LD_VAR 0 6
62790: PUSH
62791: LD_INT 1
62793: ARRAY
62794: PPUSH
62795: LD_INT 126
62797: PPUSH
62798: CALL_OW 109
// end ; end ;
62802: GO 61861
62804: POP
62805: POP
// end ;
62806: LD_VAR 0 1
62810: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62811: LD_INT 0
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62819: LD_VAR 0 1
62823: NOT
62824: IFTRUE 62833
62826: PUSH
62827: LD_VAR 0 2
62831: NOT
62832: OR
62833: IFTRUE 62842
62835: PUSH
62836: LD_VAR 0 3
62840: NOT
62841: OR
62842: IFTRUE 62890
62844: PUSH
62845: LD_VAR 0 4
62849: PUSH
62850: LD_INT 1
62852: PUSH
62853: LD_INT 2
62855: PUSH
62856: LD_INT 3
62858: PUSH
62859: LD_INT 4
62861: PUSH
62862: LD_INT 5
62864: PUSH
62865: LD_INT 8
62867: PUSH
62868: LD_INT 9
62870: PUSH
62871: LD_INT 15
62873: PUSH
62874: LD_INT 16
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: LIST
62886: LIST
62887: IN
62888: NOT
62889: OR
62890: IFFALSE 62894
// exit ;
62892: GO 63754
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: LD_VAR 0 2
62903: PPUSH
62904: LD_INT 21
62906: PUSH
62907: LD_INT 3
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 24
62916: PUSH
62917: LD_INT 250
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PPUSH
62928: CALL_OW 72
62932: ST_TO_ADDR
// case class of 1 , 15 :
62933: LD_VAR 0 4
62937: PUSH
62938: LD_INT 1
62940: DOUBLE
62941: EQUAL
62942: IFTRUE 62952
62944: LD_INT 15
62946: DOUBLE
62947: EQUAL
62948: IFTRUE 62952
62950: GO 63037
62952: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62953: LD_ADDR_VAR 0 8
62957: PUSH
62958: LD_VAR 0 2
62962: PPUSH
62963: LD_INT 2
62965: PUSH
62966: LD_INT 30
62968: PUSH
62969: LD_INT 32
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 30
62978: PUSH
62979: LD_INT 31
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: LIST
62990: PPUSH
62991: CALL_OW 72
62995: PUSH
62996: LD_VAR 0 2
63000: PPUSH
63001: LD_INT 2
63003: PUSH
63004: LD_INT 30
63006: PUSH
63007: LD_INT 4
63009: PUSH
63010: EMPTY
63011: LIST
63012: LIST
63013: PUSH
63014: LD_INT 30
63016: PUSH
63017: LD_INT 5
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: LIST
63028: PPUSH
63029: CALL_OW 72
63033: ADD
63034: ST_TO_ADDR
63035: GO 63283
63037: LD_INT 2
63039: DOUBLE
63040: EQUAL
63041: IFTRUE 63051
63043: LD_INT 16
63045: DOUBLE
63046: EQUAL
63047: IFTRUE 63051
63049: GO 63097
63051: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63052: LD_ADDR_VAR 0 8
63056: PUSH
63057: LD_VAR 0 2
63061: PPUSH
63062: LD_INT 2
63064: PUSH
63065: LD_INT 30
63067: PUSH
63068: LD_INT 0
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 30
63077: PUSH
63078: LD_INT 1
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: LIST
63089: PPUSH
63090: CALL_OW 72
63094: ST_TO_ADDR
63095: GO 63283
63097: LD_INT 3
63099: DOUBLE
63100: EQUAL
63101: IFTRUE 63105
63103: GO 63151
63105: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63106: LD_ADDR_VAR 0 8
63110: PUSH
63111: LD_VAR 0 2
63115: PPUSH
63116: LD_INT 2
63118: PUSH
63119: LD_INT 30
63121: PUSH
63122: LD_INT 2
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 30
63131: PUSH
63132: LD_INT 3
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: LIST
63143: PPUSH
63144: CALL_OW 72
63148: ST_TO_ADDR
63149: GO 63283
63151: LD_INT 4
63153: DOUBLE
63154: EQUAL
63155: IFTRUE 63159
63157: GO 63216
63159: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
63160: LD_ADDR_VAR 0 8
63164: PUSH
63165: LD_VAR 0 2
63169: PPUSH
63170: LD_INT 2
63172: PUSH
63173: LD_INT 30
63175: PUSH
63176: LD_INT 6
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 30
63185: PUSH
63186: LD_INT 7
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 30
63195: PUSH
63196: LD_INT 8
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: PPUSH
63209: CALL_OW 72
63213: ST_TO_ADDR
63214: GO 63283
63216: LD_INT 5
63218: DOUBLE
63219: EQUAL
63220: IFTRUE 63236
63222: LD_INT 8
63224: DOUBLE
63225: EQUAL
63226: IFTRUE 63236
63228: LD_INT 9
63230: DOUBLE
63231: EQUAL
63232: IFTRUE 63236
63234: GO 63282
63236: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
63237: LD_ADDR_VAR 0 8
63241: PUSH
63242: LD_VAR 0 2
63246: PPUSH
63247: LD_INT 2
63249: PUSH
63250: LD_INT 30
63252: PUSH
63253: LD_INT 4
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 30
63262: PUSH
63263: LD_INT 5
63265: PUSH
63266: EMPTY
63267: LIST
63268: LIST
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: LIST
63274: PPUSH
63275: CALL_OW 72
63279: ST_TO_ADDR
63280: GO 63283
63282: POP
// if not tmp then
63283: LD_VAR 0 8
63287: NOT
63288: IFFALSE 63292
// exit ;
63290: GO 63754
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
63292: LD_VAR 0 4
63296: PUSH
63297: LD_INT 1
63299: PUSH
63300: LD_INT 15
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: IN
63307: IFFALSE 63321
63309: PUSH
63310: LD_EXP 111
63314: PUSH
63315: LD_VAR 0 1
63319: ARRAY
63320: AND
63321: IFFALSE 63477
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
63323: LD_ADDR_VAR 0 9
63327: PUSH
63328: LD_EXP 111
63332: PUSH
63333: LD_VAR 0 1
63337: ARRAY
63338: PUSH
63339: LD_INT 1
63341: ARRAY
63342: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
63343: LD_VAR 0 9
63347: PUSH
63348: LD_EXP 112
63352: PUSH
63353: LD_VAR 0 1
63357: ARRAY
63358: IN
63359: NOT
63360: IFFALSE 63475
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
63362: LD_ADDR_EXP 112
63366: PUSH
63367: LD_EXP 112
63371: PPUSH
63372: LD_VAR 0 1
63376: PUSH
63377: LD_EXP 112
63381: PUSH
63382: LD_VAR 0 1
63386: ARRAY
63387: PUSH
63388: LD_INT 1
63390: PLUS
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PPUSH
63396: LD_VAR 0 9
63400: PPUSH
63401: CALL 76047 0 3
63405: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
63406: LD_ADDR_EXP 111
63410: PUSH
63411: LD_EXP 111
63415: PPUSH
63416: LD_VAR 0 1
63420: PPUSH
63421: LD_EXP 111
63425: PUSH
63426: LD_VAR 0 1
63430: ARRAY
63431: PUSH
63432: LD_VAR 0 9
63436: DIFF
63437: PPUSH
63438: CALL_OW 1
63442: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
63443: LD_VAR 0 3
63447: PPUSH
63448: LD_EXP 112
63452: PUSH
63453: LD_VAR 0 1
63457: ARRAY
63458: PUSH
63459: LD_EXP 112
63463: PUSH
63464: LD_VAR 0 1
63468: ARRAY
63469: ARRAY
63470: PPUSH
63471: CALL_OW 120
// end ; exit ;
63475: GO 63754
// end ; if tmp > 1 then
63477: LD_VAR 0 8
63481: PUSH
63482: LD_INT 1
63484: GREATER
63485: IFFALSE 63589
// for i = 2 to tmp do
63487: LD_ADDR_VAR 0 6
63491: PUSH
63492: DOUBLE
63493: LD_INT 2
63495: DEC
63496: ST_TO_ADDR
63497: LD_VAR 0 8
63501: PUSH
63502: FOR_TO
63503: IFFALSE 63587
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
63505: LD_VAR 0 8
63509: PUSH
63510: LD_VAR 0 6
63514: ARRAY
63515: PPUSH
63516: CALL_OW 461
63520: PUSH
63521: LD_INT 6
63523: EQUAL
63524: IFFALSE 63585
// begin x := tmp [ i ] ;
63526: LD_ADDR_VAR 0 9
63530: PUSH
63531: LD_VAR 0 8
63535: PUSH
63536: LD_VAR 0 6
63540: ARRAY
63541: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
63542: LD_ADDR_VAR 0 8
63546: PUSH
63547: LD_VAR 0 8
63551: PPUSH
63552: LD_VAR 0 6
63556: PPUSH
63557: CALL_OW 3
63561: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63562: LD_ADDR_VAR 0 8
63566: PUSH
63567: LD_VAR 0 8
63571: PPUSH
63572: LD_INT 1
63574: PPUSH
63575: LD_VAR 0 9
63579: PPUSH
63580: CALL_OW 2
63584: ST_TO_ADDR
// end ;
63585: GO 63502
63587: POP
63588: POP
// for i in tmp do
63589: LD_ADDR_VAR 0 6
63593: PUSH
63594: LD_VAR 0 8
63598: PUSH
63599: FOR_IN
63600: IFFALSE 63627
// begin if IsNotFull ( i ) then
63602: LD_VAR 0 6
63606: PPUSH
63607: CALL 73245 0 1
63611: IFFALSE 63625
// begin j := i ;
63613: LD_ADDR_VAR 0 7
63617: PUSH
63618: LD_VAR 0 6
63622: ST_TO_ADDR
// break ;
63623: GO 63627
// end ; end ;
63625: GO 63599
63627: POP
63628: POP
// if j then
63629: LD_VAR 0 7
63633: IFFALSE 63651
// ComEnterUnit ( unit , j ) else
63635: LD_VAR 0 3
63639: PPUSH
63640: LD_VAR 0 7
63644: PPUSH
63645: CALL_OW 120
63649: GO 63754
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63651: LD_ADDR_VAR 0 10
63655: PUSH
63656: LD_VAR 0 2
63660: PPUSH
63661: LD_INT 2
63663: PUSH
63664: LD_INT 30
63666: PUSH
63667: LD_INT 0
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 30
63676: PUSH
63677: LD_INT 1
63679: PUSH
63680: EMPTY
63681: LIST
63682: LIST
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: LIST
63688: PPUSH
63689: CALL_OW 72
63693: ST_TO_ADDR
// if depot then
63694: LD_VAR 0 10
63698: IFFALSE 63754
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63700: LD_ADDR_VAR 0 10
63704: PUSH
63705: LD_VAR 0 10
63709: PPUSH
63710: LD_VAR 0 3
63714: PPUSH
63715: CALL_OW 74
63719: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63720: LD_VAR 0 3
63724: PPUSH
63725: LD_VAR 0 10
63729: PPUSH
63730: CALL_OW 296
63734: PUSH
63735: LD_INT 10
63737: GREATER
63738: IFFALSE 63754
// ComStandNearbyBuilding ( unit , depot ) ;
63740: LD_VAR 0 3
63744: PPUSH
63745: LD_VAR 0 10
63749: PPUSH
63750: CALL 72623 0 2
// end ; end ; end ;
63754: LD_VAR 0 5
63758: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63759: LD_INT 0
63761: PPUSH
63762: PPUSH
63763: PPUSH
63764: PPUSH
// if not mc_bases then
63765: LD_EXP 102
63769: NOT
63770: IFFALSE 63774
// exit ;
63772: GO 64025
// for i = 1 to mc_bases do
63774: LD_ADDR_VAR 0 2
63778: PUSH
63779: DOUBLE
63780: LD_INT 1
63782: DEC
63783: ST_TO_ADDR
63784: LD_EXP 102
63788: PUSH
63789: FOR_TO
63790: IFFALSE 64023
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63792: LD_ADDR_VAR 0 4
63796: PUSH
63797: LD_EXP 102
63801: PUSH
63802: LD_VAR 0 2
63806: ARRAY
63807: PPUSH
63808: LD_INT 21
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PPUSH
63818: CALL_OW 72
63822: PUSH
63823: LD_EXP 131
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: UNION
63834: ST_TO_ADDR
// if not tmp then
63835: LD_VAR 0 4
63839: NOT
63840: IFFALSE 63844
// continue ;
63842: GO 63789
// for j in tmp do
63844: LD_ADDR_VAR 0 3
63848: PUSH
63849: LD_VAR 0 4
63853: PUSH
63854: FOR_IN
63855: IFFALSE 64019
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63857: LD_VAR 0 3
63861: PPUSH
63862: CALL_OW 110
63866: NOT
63867: IFFALSE 63881
63869: PUSH
63870: LD_VAR 0 3
63874: PPUSH
63875: CALL_OW 314
63879: NOT
63880: AND
63881: IFFALSE 63895
63883: PUSH
63884: LD_VAR 0 3
63888: PPUSH
63889: CALL_OW 311
63893: NOT
63894: AND
63895: IFFALSE 63909
63897: PUSH
63898: LD_VAR 0 3
63902: PPUSH
63903: CALL_OW 310
63907: NOT
63908: AND
63909: IFFALSE 63934
63911: PUSH
63912: LD_VAR 0 3
63916: PUSH
63917: LD_EXP 105
63921: PUSH
63922: LD_VAR 0 2
63926: ARRAY
63927: PUSH
63928: LD_INT 1
63930: ARRAY
63931: IN
63932: NOT
63933: AND
63934: IFFALSE 63959
63936: PUSH
63937: LD_VAR 0 3
63941: PUSH
63942: LD_EXP 105
63946: PUSH
63947: LD_VAR 0 2
63951: ARRAY
63952: PUSH
63953: LD_INT 2
63955: ARRAY
63956: IN
63957: NOT
63958: AND
63959: IFFALSE 63980
63961: PUSH
63962: LD_VAR 0 3
63966: PUSH
63967: LD_EXP 114
63971: PUSH
63972: LD_VAR 0 2
63976: ARRAY
63977: IN
63978: NOT
63979: AND
63980: IFFALSE 64017
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63982: LD_VAR 0 2
63986: PPUSH
63987: LD_EXP 102
63991: PUSH
63992: LD_VAR 0 2
63996: ARRAY
63997: PPUSH
63998: LD_VAR 0 3
64002: PPUSH
64003: LD_VAR 0 3
64007: PPUSH
64008: CALL_OW 257
64012: PPUSH
64013: CALL 62811 0 4
// end ;
64017: GO 63854
64019: POP
64020: POP
// end ;
64021: GO 63789
64023: POP
64024: POP
// end ;
64025: LD_VAR 0 1
64029: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
64030: LD_INT 0
64032: PPUSH
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
64037: PPUSH
// if not mc_bases [ base ] then
64038: LD_EXP 102
64042: PUSH
64043: LD_VAR 0 1
64047: ARRAY
64048: NOT
64049: IFFALSE 64053
// exit ;
64051: GO 64254
// tmp := [ ] ;
64053: LD_ADDR_VAR 0 6
64057: PUSH
64058: EMPTY
64059: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64060: LD_ADDR_VAR 0 7
64064: PUSH
64065: LD_VAR 0 3
64069: PPUSH
64070: LD_INT 0
64072: PPUSH
64073: CALL_OW 517
64077: ST_TO_ADDR
// if not list then
64078: LD_VAR 0 7
64082: NOT
64083: IFFALSE 64087
// exit ;
64085: GO 64254
// c := Count ( list [ 1 ] ) ;
64087: LD_ADDR_VAR 0 9
64091: PUSH
64092: LD_VAR 0 7
64096: PUSH
64097: LD_INT 1
64099: ARRAY
64100: PPUSH
64101: CALL 73163 0 1
64105: ST_TO_ADDR
// if amount > c then
64106: LD_VAR 0 2
64110: PUSH
64111: LD_VAR 0 9
64115: GREATER
64116: IFFALSE 64128
// amount := c ;
64118: LD_ADDR_VAR 0 2
64122: PUSH
64123: LD_VAR 0 9
64127: ST_TO_ADDR
// for i := 1 to amount do
64128: LD_ADDR_VAR 0 5
64132: PUSH
64133: DOUBLE
64134: LD_INT 1
64136: DEC
64137: ST_TO_ADDR
64138: LD_VAR 0 2
64142: PUSH
64143: FOR_TO
64144: IFFALSE 64202
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
64146: LD_ADDR_VAR 0 6
64150: PUSH
64151: LD_VAR 0 6
64155: PPUSH
64156: LD_VAR 0 5
64160: PPUSH
64161: LD_VAR 0 7
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: PUSH
64170: LD_VAR 0 5
64174: ARRAY
64175: PUSH
64176: LD_VAR 0 7
64180: PUSH
64181: LD_INT 2
64183: ARRAY
64184: PUSH
64185: LD_VAR 0 5
64189: ARRAY
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PPUSH
64195: CALL_OW 1
64199: ST_TO_ADDR
64200: GO 64143
64202: POP
64203: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
64204: LD_ADDR_EXP 115
64208: PUSH
64209: LD_EXP 115
64213: PPUSH
64214: LD_VAR 0 1
64218: PPUSH
64219: LD_VAR 0 6
64223: PPUSH
64224: CALL_OW 1
64228: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
64229: LD_ADDR_EXP 117
64233: PUSH
64234: LD_EXP 117
64238: PPUSH
64239: LD_VAR 0 1
64243: PPUSH
64244: LD_VAR 0 3
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// end ;
64254: LD_VAR 0 4
64258: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
64259: LD_INT 0
64261: PPUSH
// if not mc_bases [ base ] then
64262: LD_EXP 102
64266: PUSH
64267: LD_VAR 0 1
64271: ARRAY
64272: NOT
64273: IFFALSE 64277
// exit ;
64275: GO 64302
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
64277: LD_ADDR_EXP 107
64281: PUSH
64282: LD_EXP 107
64286: PPUSH
64287: LD_VAR 0 1
64291: PPUSH
64292: LD_VAR 0 2
64296: PPUSH
64297: CALL_OW 1
64301: ST_TO_ADDR
// end ;
64302: LD_VAR 0 3
64306: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
64307: LD_INT 0
64309: PPUSH
// if not mc_bases [ base ] then
64310: LD_EXP 102
64314: PUSH
64315: LD_VAR 0 1
64319: ARRAY
64320: NOT
64321: IFFALSE 64325
// exit ;
64323: GO 64362
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
64325: LD_ADDR_EXP 107
64329: PUSH
64330: LD_EXP 107
64334: PPUSH
64335: LD_VAR 0 1
64339: PPUSH
64340: LD_EXP 107
64344: PUSH
64345: LD_VAR 0 1
64349: ARRAY
64350: PUSH
64351: LD_VAR 0 2
64355: UNION
64356: PPUSH
64357: CALL_OW 1
64361: ST_TO_ADDR
// end ;
64362: LD_VAR 0 3
64366: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
64367: LD_INT 0
64369: PPUSH
// if not mc_bases [ base ] then
64370: LD_EXP 102
64374: PUSH
64375: LD_VAR 0 1
64379: ARRAY
64380: NOT
64381: IFFALSE 64385
// exit ;
64383: GO 64410
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
64385: LD_ADDR_EXP 123
64389: PUSH
64390: LD_EXP 123
64394: PPUSH
64395: LD_VAR 0 1
64399: PPUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: CALL_OW 1
64409: ST_TO_ADDR
// end ;
64410: LD_VAR 0 3
64414: RET
// export function MC_InsertProduceList ( base , components ) ; begin
64415: LD_INT 0
64417: PPUSH
// if not mc_bases [ base ] then
64418: LD_EXP 102
64422: PUSH
64423: LD_VAR 0 1
64427: ARRAY
64428: NOT
64429: IFFALSE 64433
// exit ;
64431: GO 64470
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
64433: LD_ADDR_EXP 123
64437: PUSH
64438: LD_EXP 123
64442: PPUSH
64443: LD_VAR 0 1
64447: PPUSH
64448: LD_EXP 123
64452: PUSH
64453: LD_VAR 0 1
64457: ARRAY
64458: PUSH
64459: LD_VAR 0 2
64463: ADD
64464: PPUSH
64465: CALL_OW 1
64469: ST_TO_ADDR
// end ;
64470: LD_VAR 0 3
64474: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
64475: LD_INT 0
64477: PPUSH
// if not mc_bases [ base ] then
64478: LD_EXP 102
64482: PUSH
64483: LD_VAR 0 1
64487: ARRAY
64488: NOT
64489: IFFALSE 64493
// exit ;
64491: GO 64547
// mc_defender := Replace ( mc_defender , base , deflist ) ;
64493: LD_ADDR_EXP 124
64497: PUSH
64498: LD_EXP 124
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: LD_VAR 0 2
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
64518: LD_ADDR_EXP 113
64522: PUSH
64523: LD_EXP 113
64527: PPUSH
64528: LD_VAR 0 1
64532: PPUSH
64533: LD_VAR 0 2
64537: PUSH
64538: LD_INT 0
64540: PLUS
64541: PPUSH
64542: CALL_OW 1
64546: ST_TO_ADDR
// end ;
64547: LD_VAR 0 3
64551: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
64552: LD_INT 0
64554: PPUSH
// if not mc_bases [ base ] then
64555: LD_EXP 102
64559: PUSH
64560: LD_VAR 0 1
64564: ARRAY
64565: NOT
64566: IFFALSE 64570
// exit ;
64568: GO 64595
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64570: LD_ADDR_EXP 113
64574: PUSH
64575: LD_EXP 113
64579: PPUSH
64580: LD_VAR 0 1
64584: PPUSH
64585: LD_VAR 0 2
64589: PPUSH
64590: CALL_OW 1
64594: ST_TO_ADDR
// end ;
64595: LD_VAR 0 3
64599: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64600: LD_INT 0
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
// if not mc_bases [ base ] then
64606: LD_EXP 102
64610: PUSH
64611: LD_VAR 0 1
64615: ARRAY
64616: NOT
64617: IFFALSE 64621
// exit ;
64619: GO 64686
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64621: LD_ADDR_EXP 122
64625: PUSH
64626: LD_EXP 122
64630: PPUSH
64631: LD_VAR 0 1
64635: PUSH
64636: LD_EXP 122
64640: PUSH
64641: LD_VAR 0 1
64645: ARRAY
64646: PUSH
64647: LD_INT 1
64649: PLUS
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PPUSH
64655: LD_VAR 0 1
64659: PUSH
64660: LD_VAR 0 2
64664: PUSH
64665: LD_VAR 0 3
64669: PUSH
64670: LD_VAR 0 4
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: PPUSH
64681: CALL 76047 0 3
64685: ST_TO_ADDR
// end ;
64686: LD_VAR 0 5
64690: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64691: LD_INT 0
64693: PPUSH
// if not mc_bases [ base ] then
64694: LD_EXP 102
64698: PUSH
64699: LD_VAR 0 1
64703: ARRAY
64704: NOT
64705: IFFALSE 64709
// exit ;
64707: GO 64734
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64709: LD_ADDR_EXP 139
64713: PUSH
64714: LD_EXP 139
64718: PPUSH
64719: LD_VAR 0 1
64723: PPUSH
64724: LD_VAR 0 2
64728: PPUSH
64729: CALL_OW 1
64733: ST_TO_ADDR
// end ;
64734: LD_VAR 0 3
64738: RET
// export function MC_GetMinesField ( base ) ; begin
64739: LD_INT 0
64741: PPUSH
// result := mc_mines [ base ] ;
64742: LD_ADDR_VAR 0 2
64746: PUSH
64747: LD_EXP 115
64751: PUSH
64752: LD_VAR 0 1
64756: ARRAY
64757: ST_TO_ADDR
// end ;
64758: LD_VAR 0 2
64762: RET
// export function MC_GetProduceList ( base ) ; begin
64763: LD_INT 0
64765: PPUSH
// result := mc_produce [ base ] ;
64766: LD_ADDR_VAR 0 2
64770: PUSH
64771: LD_EXP 123
64775: PUSH
64776: LD_VAR 0 1
64780: ARRAY
64781: ST_TO_ADDR
// end ;
64782: LD_VAR 0 2
64786: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64787: LD_INT 0
64789: PPUSH
64790: PPUSH
// if not mc_bases then
64791: LD_EXP 102
64795: NOT
64796: IFFALSE 64800
// exit ;
64798: GO 64865
// if mc_bases [ base ] then
64800: LD_EXP 102
64804: PUSH
64805: LD_VAR 0 1
64809: ARRAY
64810: IFFALSE 64865
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64812: LD_ADDR_VAR 0 3
64816: PUSH
64817: LD_EXP 102
64821: PUSH
64822: LD_VAR 0 1
64826: ARRAY
64827: PPUSH
64828: LD_INT 30
64830: PUSH
64831: LD_VAR 0 2
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PPUSH
64840: CALL_OW 72
64844: ST_TO_ADDR
// if result then
64845: LD_VAR 0 3
64849: IFFALSE 64865
// result := result [ 1 ] ;
64851: LD_ADDR_VAR 0 3
64855: PUSH
64856: LD_VAR 0 3
64860: PUSH
64861: LD_INT 1
64863: ARRAY
64864: ST_TO_ADDR
// end ; end ;
64865: LD_VAR 0 3
64869: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64870: LD_INT 0
64872: PPUSH
64873: PPUSH
// if not mc_bases then
64874: LD_EXP 102
64878: NOT
64879: IFFALSE 64883
// exit ;
64881: GO 64928
// if mc_bases [ base ] then
64883: LD_EXP 102
64887: PUSH
64888: LD_VAR 0 1
64892: ARRAY
64893: IFFALSE 64928
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64895: LD_ADDR_VAR 0 3
64899: PUSH
64900: LD_EXP 102
64904: PUSH
64905: LD_VAR 0 1
64909: ARRAY
64910: PPUSH
64911: LD_INT 30
64913: PUSH
64914: LD_VAR 0 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PPUSH
64923: CALL_OW 72
64927: ST_TO_ADDR
// end ;
64928: LD_VAR 0 3
64932: RET
// export function MC_SetTame ( base , area ) ; begin
64933: LD_INT 0
64935: PPUSH
// if not mc_bases or not base then
64936: LD_EXP 102
64940: NOT
64941: IFTRUE 64950
64943: PUSH
64944: LD_VAR 0 1
64948: NOT
64949: OR
64950: IFFALSE 64954
// exit ;
64952: GO 64979
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64954: LD_ADDR_EXP 130
64958: PUSH
64959: LD_EXP 130
64963: PPUSH
64964: LD_VAR 0 1
64968: PPUSH
64969: LD_VAR 0 2
64973: PPUSH
64974: CALL_OW 1
64978: ST_TO_ADDR
// end ;
64979: LD_VAR 0 3
64983: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64984: LD_INT 0
64986: PPUSH
64987: PPUSH
// if not mc_bases or not base then
64988: LD_EXP 102
64992: NOT
64993: IFTRUE 65002
64995: PUSH
64996: LD_VAR 0 1
65000: NOT
65001: OR
65002: IFFALSE 65006
// exit ;
65004: GO 65108
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65006: LD_ADDR_VAR 0 4
65010: PUSH
65011: LD_EXP 102
65015: PUSH
65016: LD_VAR 0 1
65020: ARRAY
65021: PPUSH
65022: LD_INT 30
65024: PUSH
65025: LD_VAR 0 2
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PPUSH
65034: CALL_OW 72
65038: ST_TO_ADDR
// if not tmp then
65039: LD_VAR 0 4
65043: NOT
65044: IFFALSE 65048
// exit ;
65046: GO 65108
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65048: LD_ADDR_EXP 134
65052: PUSH
65053: LD_EXP 134
65057: PPUSH
65058: LD_VAR 0 1
65062: PPUSH
65063: LD_EXP 134
65067: PUSH
65068: LD_VAR 0 1
65072: ARRAY
65073: PPUSH
65074: LD_EXP 134
65078: PUSH
65079: LD_VAR 0 1
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: PLUS
65088: PPUSH
65089: LD_VAR 0 4
65093: PUSH
65094: LD_INT 1
65096: ARRAY
65097: PPUSH
65098: CALL_OW 2
65102: PPUSH
65103: CALL_OW 1
65107: ST_TO_ADDR
// end ;
65108: LD_VAR 0 3
65112: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65113: LD_INT 0
65115: PPUSH
65116: PPUSH
// if not mc_bases or not base or not kinds then
65117: LD_EXP 102
65121: NOT
65122: IFTRUE 65131
65124: PUSH
65125: LD_VAR 0 1
65129: NOT
65130: OR
65131: IFTRUE 65140
65133: PUSH
65134: LD_VAR 0 2
65138: NOT
65139: OR
65140: IFFALSE 65144
// exit ;
65142: GO 65205
// for i in kinds do
65144: LD_ADDR_VAR 0 4
65148: PUSH
65149: LD_VAR 0 2
65153: PUSH
65154: FOR_IN
65155: IFFALSE 65203
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
65157: LD_ADDR_EXP 136
65161: PUSH
65162: LD_EXP 136
65166: PPUSH
65167: LD_VAR 0 1
65171: PUSH
65172: LD_EXP 136
65176: PUSH
65177: LD_VAR 0 1
65181: ARRAY
65182: PUSH
65183: LD_INT 1
65185: PLUS
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PPUSH
65191: LD_VAR 0 4
65195: PPUSH
65196: CALL 76047 0 3
65200: ST_TO_ADDR
65201: GO 65154
65203: POP
65204: POP
// end ;
65205: LD_VAR 0 3
65209: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
65210: LD_INT 0
65212: PPUSH
// if not mc_bases or not base or not areas then
65213: LD_EXP 102
65217: NOT
65218: IFTRUE 65227
65220: PUSH
65221: LD_VAR 0 1
65225: NOT
65226: OR
65227: IFTRUE 65236
65229: PUSH
65230: LD_VAR 0 2
65234: NOT
65235: OR
65236: IFFALSE 65240
// exit ;
65238: GO 65265
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
65240: LD_ADDR_EXP 120
65244: PUSH
65245: LD_EXP 120
65249: PPUSH
65250: LD_VAR 0 1
65254: PPUSH
65255: LD_VAR 0 2
65259: PPUSH
65260: CALL_OW 1
65264: ST_TO_ADDR
// end ;
65265: LD_VAR 0 3
65269: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
65270: LD_INT 0
65272: PPUSH
// if not mc_bases or not base or not teleports_exit then
65273: LD_EXP 102
65277: NOT
65278: IFTRUE 65287
65280: PUSH
65281: LD_VAR 0 1
65285: NOT
65286: OR
65287: IFTRUE 65296
65289: PUSH
65290: LD_VAR 0 2
65294: NOT
65295: OR
65296: IFFALSE 65300
// exit ;
65298: GO 65325
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
65300: LD_ADDR_EXP 137
65304: PUSH
65305: LD_EXP 137
65309: PPUSH
65310: LD_VAR 0 1
65314: PPUSH
65315: LD_VAR 0 2
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// end ;
65325: LD_VAR 0 3
65329: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
65330: LD_INT 0
65332: PPUSH
65333: PPUSH
65334: PPUSH
// if not mc_bases or not base or not ext_list then
65335: LD_EXP 102
65339: NOT
65340: IFTRUE 65349
65342: PUSH
65343: LD_VAR 0 1
65347: NOT
65348: OR
65349: IFTRUE 65358
65351: PUSH
65352: LD_VAR 0 5
65356: NOT
65357: OR
65358: IFFALSE 65362
// exit ;
65360: GO 65535
// tmp := GetFacExtXYD ( x , y , d ) ;
65362: LD_ADDR_VAR 0 8
65366: PUSH
65367: LD_VAR 0 2
65371: PPUSH
65372: LD_VAR 0 3
65376: PPUSH
65377: LD_VAR 0 4
65381: PPUSH
65382: CALL 106705 0 3
65386: ST_TO_ADDR
// if not tmp then
65387: LD_VAR 0 8
65391: NOT
65392: IFFALSE 65396
// exit ;
65394: GO 65535
// for i in tmp do
65396: LD_ADDR_VAR 0 7
65400: PUSH
65401: LD_VAR 0 8
65405: PUSH
65406: FOR_IN
65407: IFFALSE 65533
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
65409: LD_ADDR_EXP 107
65413: PUSH
65414: LD_EXP 107
65418: PPUSH
65419: LD_VAR 0 1
65423: PPUSH
65424: LD_EXP 107
65428: PUSH
65429: LD_VAR 0 1
65433: ARRAY
65434: PPUSH
65435: LD_EXP 107
65439: PUSH
65440: LD_VAR 0 1
65444: ARRAY
65445: PUSH
65446: LD_INT 1
65448: PLUS
65449: PPUSH
65450: LD_VAR 0 5
65454: PUSH
65455: LD_INT 1
65457: ARRAY
65458: PUSH
65459: LD_VAR 0 7
65463: PUSH
65464: LD_INT 1
65466: ARRAY
65467: PUSH
65468: LD_VAR 0 7
65472: PUSH
65473: LD_INT 2
65475: ARRAY
65476: PUSH
65477: LD_VAR 0 7
65481: PUSH
65482: LD_INT 3
65484: ARRAY
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: CALL_OW 2
65496: PPUSH
65497: CALL_OW 1
65501: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
65502: LD_ADDR_VAR 0 5
65506: PUSH
65507: LD_VAR 0 5
65511: PPUSH
65512: LD_INT 1
65514: PPUSH
65515: CALL_OW 3
65519: ST_TO_ADDR
// if not ext_list then
65520: LD_VAR 0 5
65524: NOT
65525: IFFALSE 65531
// exit ;
65527: POP
65528: POP
65529: GO 65535
// end ;
65531: GO 65406
65533: POP
65534: POP
// end ;
65535: LD_VAR 0 6
65539: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
65540: LD_INT 0
65542: PPUSH
// if not mc_bases or not base or not weapon_list then
65543: LD_EXP 102
65547: NOT
65548: IFTRUE 65557
65550: PUSH
65551: LD_VAR 0 1
65555: NOT
65556: OR
65557: IFTRUE 65566
65559: PUSH
65560: LD_VAR 0 2
65564: NOT
65565: OR
65566: IFFALSE 65570
// exit ;
65568: GO 65595
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
65570: LD_ADDR_EXP 141
65574: PUSH
65575: LD_EXP 141
65579: PPUSH
65580: LD_VAR 0 1
65584: PPUSH
65585: LD_VAR 0 2
65589: PPUSH
65590: CALL_OW 1
65594: ST_TO_ADDR
// end ;
65595: LD_VAR 0 3
65599: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65600: LD_INT 0
65602: PPUSH
// if not mc_bases or not base or not tech_list then
65603: LD_EXP 102
65607: NOT
65608: IFTRUE 65617
65610: PUSH
65611: LD_VAR 0 1
65615: NOT
65616: OR
65617: IFTRUE 65626
65619: PUSH
65620: LD_VAR 0 2
65624: NOT
65625: OR
65626: IFFALSE 65630
// exit ;
65628: GO 65655
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65630: LD_ADDR_EXP 129
65634: PUSH
65635: LD_EXP 129
65639: PPUSH
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 2
65649: PPUSH
65650: CALL_OW 1
65654: ST_TO_ADDR
// end ;
65655: LD_VAR 0 3
65659: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65660: LD_INT 0
65662: PPUSH
// if not mc_bases or not parking_area or not base then
65663: LD_EXP 102
65667: NOT
65668: IFTRUE 65677
65670: PUSH
65671: LD_VAR 0 2
65675: NOT
65676: OR
65677: IFTRUE 65686
65679: PUSH
65680: LD_VAR 0 1
65684: NOT
65685: OR
65686: IFFALSE 65690
// exit ;
65688: GO 65715
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65690: LD_ADDR_EXP 126
65694: PUSH
65695: LD_EXP 126
65699: PPUSH
65700: LD_VAR 0 1
65704: PPUSH
65705: LD_VAR 0 2
65709: PPUSH
65710: CALL_OW 1
65714: ST_TO_ADDR
// end ;
65715: LD_VAR 0 3
65719: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65720: LD_INT 0
65722: PPUSH
// if not mc_bases or not base or not scan_area then
65723: LD_EXP 102
65727: NOT
65728: IFTRUE 65737
65730: PUSH
65731: LD_VAR 0 1
65735: NOT
65736: OR
65737: IFTRUE 65746
65739: PUSH
65740: LD_VAR 0 2
65744: NOT
65745: OR
65746: IFFALSE 65750
// exit ;
65748: GO 65775
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65750: LD_ADDR_EXP 127
65754: PUSH
65755: LD_EXP 127
65759: PPUSH
65760: LD_VAR 0 1
65764: PPUSH
65765: LD_VAR 0 2
65769: PPUSH
65770: CALL_OW 1
65774: ST_TO_ADDR
// end ;
65775: LD_VAR 0 3
65779: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65780: LD_INT 0
65782: PPUSH
65783: PPUSH
// if not mc_bases or not base then
65784: LD_EXP 102
65788: NOT
65789: IFTRUE 65798
65791: PUSH
65792: LD_VAR 0 1
65796: NOT
65797: OR
65798: IFFALSE 65802
// exit ;
65800: GO 65866
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65802: LD_ADDR_VAR 0 3
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 3
65815: PUSH
65816: LD_INT 4
65818: PUSH
65819: LD_INT 11
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65829: LD_ADDR_EXP 129
65833: PUSH
65834: LD_EXP 129
65838: PPUSH
65839: LD_VAR 0 1
65843: PPUSH
65844: LD_EXP 129
65848: PUSH
65849: LD_VAR 0 1
65853: ARRAY
65854: PUSH
65855: LD_VAR 0 3
65859: DIFF
65860: PPUSH
65861: CALL_OW 1
65865: ST_TO_ADDR
// end ;
65866: LD_VAR 0 2
65870: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65871: LD_INT 0
65873: PPUSH
// result := mc_vehicles [ base ] ;
65874: LD_ADDR_VAR 0 3
65878: PUSH
65879: LD_EXP 121
65883: PUSH
65884: LD_VAR 0 1
65888: ARRAY
65889: ST_TO_ADDR
// if onlyCombat then
65890: LD_VAR 0 2
65894: IFFALSE 66066
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65896: LD_ADDR_VAR 0 3
65900: PUSH
65901: LD_VAR 0 3
65905: PUSH
65906: LD_VAR 0 3
65910: PPUSH
65911: LD_INT 2
65913: PUSH
65914: LD_INT 34
65916: PUSH
65917: LD_INT 12
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 34
65926: PUSH
65927: LD_INT 51
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 34
65936: PUSH
65937: LD_INT 89
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 34
65946: PUSH
65947: LD_INT 32
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 34
65956: PUSH
65957: LD_INT 13
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 34
65966: PUSH
65967: LD_INT 52
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 34
65976: PUSH
65977: LD_INT 88
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 34
65986: PUSH
65987: LD_INT 14
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 34
65996: PUSH
65997: LD_INT 53
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 34
66006: PUSH
66007: LD_INT 98
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 34
66016: PUSH
66017: LD_INT 31
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 34
66026: PUSH
66027: LD_INT 48
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 34
66036: PUSH
66037: LD_INT 8
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: PPUSH
66060: CALL_OW 72
66064: DIFF
66065: ST_TO_ADDR
// end ; end_of_file
66066: LD_VAR 0 3
66070: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66071: LD_INT 0
66073: PPUSH
66074: PPUSH
66075: PPUSH
// if not mc_bases or not skirmish then
66076: LD_EXP 102
66080: NOT
66081: IFTRUE 66090
66083: PUSH
66084: LD_EXP 100
66088: NOT
66089: OR
66090: IFFALSE 66094
// exit ;
66092: GO 66259
// for i = 1 to mc_bases do
66094: LD_ADDR_VAR 0 4
66098: PUSH
66099: DOUBLE
66100: LD_INT 1
66102: DEC
66103: ST_TO_ADDR
66104: LD_EXP 102
66108: PUSH
66109: FOR_TO
66110: IFFALSE 66257
// begin if sci in mc_bases [ i ] then
66112: LD_VAR 0 2
66116: PUSH
66117: LD_EXP 102
66121: PUSH
66122: LD_VAR 0 4
66126: ARRAY
66127: IN
66128: IFFALSE 66255
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66130: LD_ADDR_EXP 131
66134: PUSH
66135: LD_EXP 131
66139: PPUSH
66140: LD_VAR 0 4
66144: PUSH
66145: LD_EXP 131
66149: PUSH
66150: LD_VAR 0 4
66154: ARRAY
66155: PUSH
66156: LD_INT 1
66158: PLUS
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PPUSH
66164: LD_VAR 0 1
66168: PPUSH
66169: CALL 76047 0 3
66173: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
66174: LD_ADDR_VAR 0 5
66178: PUSH
66179: LD_EXP 102
66183: PUSH
66184: LD_VAR 0 4
66188: ARRAY
66189: PPUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 30
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 30
66205: PUSH
66206: LD_INT 1
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: LIST
66217: PPUSH
66218: CALL_OW 72
66222: PPUSH
66223: LD_VAR 0 1
66227: PPUSH
66228: CALL_OW 74
66232: ST_TO_ADDR
// if tmp then
66233: LD_VAR 0 5
66237: IFFALSE 66253
// ComStandNearbyBuilding ( ape , tmp ) ;
66239: LD_VAR 0 1
66243: PPUSH
66244: LD_VAR 0 5
66248: PPUSH
66249: CALL 72623 0 2
// break ;
66253: GO 66257
// end ; end ;
66255: GO 66109
66257: POP
66258: POP
// end ;
66259: LD_VAR 0 3
66263: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
66264: LD_INT 0
66266: PPUSH
66267: PPUSH
66268: PPUSH
// if not mc_bases or not skirmish then
66269: LD_EXP 102
66273: NOT
66274: IFTRUE 66283
66276: PUSH
66277: LD_EXP 100
66281: NOT
66282: OR
66283: IFFALSE 66287
// exit ;
66285: GO 66376
// for i = 1 to mc_bases do
66287: LD_ADDR_VAR 0 4
66291: PUSH
66292: DOUBLE
66293: LD_INT 1
66295: DEC
66296: ST_TO_ADDR
66297: LD_EXP 102
66301: PUSH
66302: FOR_TO
66303: IFFALSE 66374
// begin if building in mc_busy_turret_list [ i ] then
66305: LD_VAR 0 1
66309: PUSH
66310: LD_EXP 112
66314: PUSH
66315: LD_VAR 0 4
66319: ARRAY
66320: IN
66321: IFFALSE 66372
// begin tmp := mc_busy_turret_list [ i ] diff building ;
66323: LD_ADDR_VAR 0 5
66327: PUSH
66328: LD_EXP 112
66332: PUSH
66333: LD_VAR 0 4
66337: ARRAY
66338: PUSH
66339: LD_VAR 0 1
66343: DIFF
66344: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
66345: LD_ADDR_EXP 112
66349: PUSH
66350: LD_EXP 112
66354: PPUSH
66355: LD_VAR 0 4
66359: PPUSH
66360: LD_VAR 0 5
66364: PPUSH
66365: CALL_OW 1
66369: ST_TO_ADDR
// break ;
66370: GO 66374
// end ; end ;
66372: GO 66302
66374: POP
66375: POP
// end ;
66376: LD_VAR 0 3
66380: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
66381: LD_INT 0
66383: PPUSH
66384: PPUSH
66385: PPUSH
// if not mc_bases or not skirmish then
66386: LD_EXP 102
66390: NOT
66391: IFTRUE 66400
66393: PUSH
66394: LD_EXP 100
66398: NOT
66399: OR
66400: IFFALSE 66404
// exit ;
66402: GO 66603
// for i = 1 to mc_bases do
66404: LD_ADDR_VAR 0 5
66408: PUSH
66409: DOUBLE
66410: LD_INT 1
66412: DEC
66413: ST_TO_ADDR
66414: LD_EXP 102
66418: PUSH
66419: FOR_TO
66420: IFFALSE 66601
// if building in mc_bases [ i ] then
66422: LD_VAR 0 1
66426: PUSH
66427: LD_EXP 102
66431: PUSH
66432: LD_VAR 0 5
66436: ARRAY
66437: IN
66438: IFFALSE 66599
// begin tmp := mc_bases [ i ] diff building ;
66440: LD_ADDR_VAR 0 6
66444: PUSH
66445: LD_EXP 102
66449: PUSH
66450: LD_VAR 0 5
66454: ARRAY
66455: PUSH
66456: LD_VAR 0 1
66460: DIFF
66461: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
66462: LD_ADDR_EXP 102
66466: PUSH
66467: LD_EXP 102
66471: PPUSH
66472: LD_VAR 0 5
66476: PPUSH
66477: LD_VAR 0 6
66481: PPUSH
66482: CALL_OW 1
66486: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
66487: LD_VAR 0 1
66491: PUSH
66492: LD_EXP 110
66496: PUSH
66497: LD_VAR 0 5
66501: ARRAY
66502: IN
66503: IFFALSE 66542
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
66505: LD_ADDR_EXP 110
66509: PUSH
66510: LD_EXP 110
66514: PPUSH
66515: LD_VAR 0 5
66519: PPUSH
66520: LD_EXP 110
66524: PUSH
66525: LD_VAR 0 5
66529: ARRAY
66530: PUSH
66531: LD_VAR 0 1
66535: DIFF
66536: PPUSH
66537: CALL_OW 1
66541: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
66542: LD_VAR 0 1
66546: PUSH
66547: LD_EXP 111
66551: PUSH
66552: LD_VAR 0 5
66556: ARRAY
66557: IN
66558: IFFALSE 66597
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
66560: LD_ADDR_EXP 111
66564: PUSH
66565: LD_EXP 111
66569: PPUSH
66570: LD_VAR 0 5
66574: PPUSH
66575: LD_EXP 111
66579: PUSH
66580: LD_VAR 0 5
66584: ARRAY
66585: PUSH
66586: LD_VAR 0 1
66590: DIFF
66591: PPUSH
66592: CALL_OW 1
66596: ST_TO_ADDR
// break ;
66597: GO 66601
// end ;
66599: GO 66419
66601: POP
66602: POP
// end ;
66603: LD_VAR 0 4
66607: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66608: LD_INT 0
66610: PPUSH
66611: PPUSH
66612: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66613: LD_EXP 102
66617: NOT
66618: IFTRUE 66627
66620: PUSH
66621: LD_EXP 100
66625: NOT
66626: OR
66627: IFTRUE 66642
66629: PUSH
66630: LD_VAR 0 3
66634: PUSH
66635: LD_EXP 128
66639: IN
66640: NOT
66641: OR
66642: IFFALSE 66646
// exit ;
66644: GO 66771
// for i = 1 to mc_vehicles do
66646: LD_ADDR_VAR 0 6
66650: PUSH
66651: DOUBLE
66652: LD_INT 1
66654: DEC
66655: ST_TO_ADDR
66656: LD_EXP 121
66660: PUSH
66661: FOR_TO
66662: IFFALSE 66769
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66664: LD_VAR 0 2
66668: PUSH
66669: LD_EXP 121
66673: PUSH
66674: LD_VAR 0 6
66678: ARRAY
66679: IN
66680: IFTRUE 66700
66682: PUSH
66683: LD_VAR 0 1
66687: PUSH
66688: LD_EXP 121
66692: PUSH
66693: LD_VAR 0 6
66697: ARRAY
66698: IN
66699: OR
66700: IFFALSE 66767
// begin tmp := mc_vehicles [ i ] diff old ;
66702: LD_ADDR_VAR 0 7
66706: PUSH
66707: LD_EXP 121
66711: PUSH
66712: LD_VAR 0 6
66716: ARRAY
66717: PUSH
66718: LD_VAR 0 2
66722: DIFF
66723: ST_TO_ADDR
// tmp := tmp diff new ;
66724: LD_ADDR_VAR 0 7
66728: PUSH
66729: LD_VAR 0 7
66733: PUSH
66734: LD_VAR 0 1
66738: DIFF
66739: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66740: LD_ADDR_EXP 121
66744: PUSH
66745: LD_EXP 121
66749: PPUSH
66750: LD_VAR 0 6
66754: PPUSH
66755: LD_VAR 0 7
66759: PPUSH
66760: CALL_OW 1
66764: ST_TO_ADDR
// break ;
66765: GO 66769
// end ;
66767: GO 66661
66769: POP
66770: POP
// end ;
66771: LD_VAR 0 5
66775: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66776: LD_INT 0
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
// if not mc_bases or not skirmish then
66782: LD_EXP 102
66786: NOT
66787: IFTRUE 66796
66789: PUSH
66790: LD_EXP 100
66794: NOT
66795: OR
66796: IFFALSE 66800
// exit ;
66798: GO 67222
// repeat wait ( 0 0$1 ) ;
66800: LD_INT 35
66802: PPUSH
66803: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66807: LD_EXP 146
66811: NOT
66812: IFFALSE 66800
// mc_block_vehicle_constructed_thread := true ;
66814: LD_ADDR_EXP 146
66818: PUSH
66819: LD_INT 1
66821: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66822: LD_ADDR_VAR 0 5
66826: PUSH
66827: LD_VAR 0 1
66831: PPUSH
66832: CALL_OW 255
66836: ST_TO_ADDR
// for i = 1 to mc_bases do
66837: LD_ADDR_VAR 0 4
66841: PUSH
66842: DOUBLE
66843: LD_INT 1
66845: DEC
66846: ST_TO_ADDR
66847: LD_EXP 102
66851: PUSH
66852: FOR_TO
66853: IFFALSE 67212
// begin if factory in mc_bases [ i ] then
66855: LD_VAR 0 2
66859: PUSH
66860: LD_EXP 102
66864: PUSH
66865: LD_VAR 0 4
66869: ARRAY
66870: IN
66871: IFFALSE 67210
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66873: LD_EXP 124
66877: PUSH
66878: LD_VAR 0 4
66882: ARRAY
66883: PUSH
66884: LD_EXP 113
66888: PUSH
66889: LD_VAR 0 4
66893: ARRAY
66894: LESS
66895: IFFALSE 66984
66897: PUSH
66898: LD_VAR 0 1
66902: PPUSH
66903: CALL_OW 264
66907: PUSH
66908: LD_INT 31
66910: PUSH
66911: LD_INT 32
66913: PUSH
66914: LD_INT 51
66916: PUSH
66917: LD_INT 89
66919: PUSH
66920: LD_INT 12
66922: PUSH
66923: LD_INT 30
66925: PUSH
66926: LD_INT 98
66928: PUSH
66929: LD_INT 11
66931: PUSH
66932: LD_INT 53
66934: PUSH
66935: LD_INT 14
66937: PUSH
66938: LD_INT 91
66940: PUSH
66941: LD_INT 29
66943: PUSH
66944: LD_INT 99
66946: PUSH
66947: LD_INT 13
66949: PUSH
66950: LD_INT 52
66952: PUSH
66953: LD_INT 88
66955: PUSH
66956: LD_INT 48
66958: PUSH
66959: LD_INT 8
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: LIST
66979: LIST
66980: LIST
66981: IN
66982: NOT
66983: AND
66984: IFFALSE 67032
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66986: LD_ADDR_EXP 124
66990: PUSH
66991: LD_EXP 124
66995: PPUSH
66996: LD_VAR 0 4
67000: PUSH
67001: LD_EXP 124
67005: PUSH
67006: LD_VAR 0 4
67010: ARRAY
67011: PUSH
67012: LD_INT 1
67014: PLUS
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PPUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL 76047 0 3
67029: ST_TO_ADDR
67030: GO 67076
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67032: LD_ADDR_EXP 121
67036: PUSH
67037: LD_EXP 121
67041: PPUSH
67042: LD_VAR 0 4
67046: PUSH
67047: LD_EXP 121
67051: PUSH
67052: LD_VAR 0 4
67056: ARRAY
67057: PUSH
67058: LD_INT 1
67060: PLUS
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PPUSH
67066: LD_VAR 0 1
67070: PPUSH
67071: CALL 76047 0 3
67075: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
67076: LD_ADDR_EXP 146
67080: PUSH
67081: LD_INT 0
67083: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67084: LD_VAR 0 1
67088: PPUSH
67089: CALL_OW 263
67093: PUSH
67094: LD_INT 2
67096: EQUAL
67097: IFFALSE 67126
// begin repeat wait ( 0 0$3 ) ;
67099: LD_INT 105
67101: PPUSH
67102: CALL_OW 67
// Connect ( vehicle ) ;
67106: LD_VAR 0 1
67110: PPUSH
67111: CALL 79407 0 1
// until IsControledBy ( vehicle ) ;
67115: LD_VAR 0 1
67119: PPUSH
67120: CALL_OW 312
67124: IFFALSE 67099
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67126: LD_VAR 0 1
67130: PPUSH
67131: LD_EXP 126
67135: PUSH
67136: LD_VAR 0 4
67140: ARRAY
67141: PPUSH
67142: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67146: LD_VAR 0 1
67150: PPUSH
67151: CALL_OW 263
67155: PUSH
67156: LD_INT 1
67158: NONEQUAL
67159: IFFALSE 67163
// break ;
67161: GO 67212
// repeat wait ( 0 0$1 ) ;
67163: LD_INT 35
67165: PPUSH
67166: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67170: LD_VAR 0 1
67174: PPUSH
67175: LD_EXP 126
67179: PUSH
67180: LD_VAR 0 4
67184: ARRAY
67185: PPUSH
67186: CALL_OW 308
67190: IFFALSE 67163
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67192: LD_VAR 0 1
67196: PPUSH
67197: CALL_OW 311
67201: PPUSH
67202: CALL_OW 121
// exit ;
67206: POP
67207: POP
67208: GO 67222
// end ; end ;
67210: GO 66852
67212: POP
67213: POP
// mc_block_vehicle_constructed_thread := false ;
67214: LD_ADDR_EXP 146
67218: PUSH
67219: LD_INT 0
67221: ST_TO_ADDR
// end ;
67222: LD_VAR 0 3
67226: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
67227: LD_INT 0
67229: PPUSH
67230: PPUSH
67231: PPUSH
67232: PPUSH
// if not mc_bases or not skirmish then
67233: LD_EXP 102
67237: NOT
67238: IFTRUE 67247
67240: PUSH
67241: LD_EXP 100
67245: NOT
67246: OR
67247: IFFALSE 67251
// exit ;
67249: GO 67604
// repeat wait ( 0 0$1 ) ;
67251: LD_INT 35
67253: PPUSH
67254: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
67258: LD_VAR 0 2
67262: PPUSH
67263: LD_VAR 0 3
67267: PPUSH
67268: CALL_OW 284
67272: IFFALSE 67251
// if GetResourceTypeXY ( x , y ) = mat_artefact then
67274: LD_VAR 0 2
67278: PPUSH
67279: LD_VAR 0 3
67283: PPUSH
67284: CALL_OW 283
67288: PUSH
67289: LD_INT 4
67291: EQUAL
67292: IFFALSE 67296
// exit ;
67294: GO 67604
// for i = 1 to mc_bases do
67296: LD_ADDR_VAR 0 7
67300: PUSH
67301: DOUBLE
67302: LD_INT 1
67304: DEC
67305: ST_TO_ADDR
67306: LD_EXP 102
67310: PUSH
67311: FOR_TO
67312: IFFALSE 67602
// begin if mc_crates_area [ i ] then
67314: LD_EXP 120
67318: PUSH
67319: LD_VAR 0 7
67323: ARRAY
67324: IFFALSE 67435
// for j in mc_crates_area [ i ] do
67326: LD_ADDR_VAR 0 8
67330: PUSH
67331: LD_EXP 120
67335: PUSH
67336: LD_VAR 0 7
67340: ARRAY
67341: PUSH
67342: FOR_IN
67343: IFFALSE 67433
// if InArea ( x , y , j ) then
67345: LD_VAR 0 2
67349: PPUSH
67350: LD_VAR 0 3
67354: PPUSH
67355: LD_VAR 0 8
67359: PPUSH
67360: CALL_OW 309
67364: IFFALSE 67431
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67366: LD_ADDR_EXP 118
67370: PUSH
67371: LD_EXP 118
67375: PPUSH
67376: LD_VAR 0 7
67380: PUSH
67381: LD_EXP 118
67385: PUSH
67386: LD_VAR 0 7
67390: ARRAY
67391: PUSH
67392: LD_INT 1
67394: PLUS
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PPUSH
67400: LD_VAR 0 4
67404: PUSH
67405: LD_VAR 0 2
67409: PUSH
67410: LD_VAR 0 3
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: LIST
67419: PPUSH
67420: CALL 76047 0 3
67424: ST_TO_ADDR
// exit ;
67425: POP
67426: POP
67427: POP
67428: POP
67429: GO 67604
// end ;
67431: GO 67342
67433: POP
67434: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67435: LD_ADDR_VAR 0 9
67439: PUSH
67440: LD_EXP 102
67444: PUSH
67445: LD_VAR 0 7
67449: ARRAY
67450: PPUSH
67451: LD_INT 2
67453: PUSH
67454: LD_INT 30
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 30
67466: PUSH
67467: LD_INT 1
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: LIST
67478: PPUSH
67479: CALL_OW 72
67483: ST_TO_ADDR
// if not depot then
67484: LD_VAR 0 9
67488: NOT
67489: IFFALSE 67493
// continue ;
67491: GO 67311
// for j in depot do
67493: LD_ADDR_VAR 0 8
67497: PUSH
67498: LD_VAR 0 9
67502: PUSH
67503: FOR_IN
67504: IFFALSE 67598
// if GetDistUnitXY ( j , x , y ) < 30 then
67506: LD_VAR 0 8
67510: PPUSH
67511: LD_VAR 0 2
67515: PPUSH
67516: LD_VAR 0 3
67520: PPUSH
67521: CALL_OW 297
67525: PUSH
67526: LD_INT 30
67528: LESS
67529: IFFALSE 67596
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67531: LD_ADDR_EXP 118
67535: PUSH
67536: LD_EXP 118
67540: PPUSH
67541: LD_VAR 0 7
67545: PUSH
67546: LD_EXP 118
67550: PUSH
67551: LD_VAR 0 7
67555: ARRAY
67556: PUSH
67557: LD_INT 1
67559: PLUS
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PPUSH
67565: LD_VAR 0 4
67569: PUSH
67570: LD_VAR 0 2
67574: PUSH
67575: LD_VAR 0 3
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: LIST
67584: PPUSH
67585: CALL 76047 0 3
67589: ST_TO_ADDR
// exit ;
67590: POP
67591: POP
67592: POP
67593: POP
67594: GO 67604
// end ;
67596: GO 67503
67598: POP
67599: POP
// end ;
67600: GO 67311
67602: POP
67603: POP
// end ;
67604: LD_VAR 0 6
67608: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
67609: LD_INT 0
67611: PPUSH
67612: PPUSH
67613: PPUSH
67614: PPUSH
// if not mc_bases or not skirmish then
67615: LD_EXP 102
67619: NOT
67620: IFTRUE 67629
67622: PUSH
67623: LD_EXP 100
67627: NOT
67628: OR
67629: IFFALSE 67633
// exit ;
67631: GO 67916
// side := GetSide ( lab ) ;
67633: LD_ADDR_VAR 0 4
67637: PUSH
67638: LD_VAR 0 2
67642: PPUSH
67643: CALL_OW 255
67647: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67648: LD_VAR 0 4
67652: PUSH
67653: LD_EXP 128
67657: IN
67658: NOT
67659: IFTRUE 67668
67661: PUSH
67662: LD_EXP 129
67666: NOT
67667: OR
67668: IFTRUE 67677
67670: PUSH
67671: LD_EXP 102
67675: NOT
67676: OR
67677: IFFALSE 67681
// exit ;
67679: GO 67916
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67681: LD_ADDR_EXP 129
67685: PUSH
67686: LD_EXP 129
67690: PPUSH
67691: LD_VAR 0 4
67695: PPUSH
67696: LD_EXP 129
67700: PUSH
67701: LD_VAR 0 4
67705: ARRAY
67706: PUSH
67707: LD_VAR 0 1
67711: DIFF
67712: PPUSH
67713: CALL_OW 1
67717: ST_TO_ADDR
// for i = 1 to mc_bases do
67718: LD_ADDR_VAR 0 5
67722: PUSH
67723: DOUBLE
67724: LD_INT 1
67726: DEC
67727: ST_TO_ADDR
67728: LD_EXP 102
67732: PUSH
67733: FOR_TO
67734: IFFALSE 67914
// begin if lab in mc_bases [ i ] then
67736: LD_VAR 0 2
67740: PUSH
67741: LD_EXP 102
67745: PUSH
67746: LD_VAR 0 5
67750: ARRAY
67751: IN
67752: IFFALSE 67912
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67754: LD_VAR 0 1
67758: PUSH
67759: LD_INT 11
67761: PUSH
67762: LD_INT 4
67764: PUSH
67765: LD_INT 3
67767: PUSH
67768: LD_INT 2
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: IN
67777: IFFALSE 67791
67779: PUSH
67780: LD_EXP 132
67784: PUSH
67785: LD_VAR 0 5
67789: ARRAY
67790: AND
67791: IFFALSE 67912
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67793: LD_ADDR_VAR 0 6
67797: PUSH
67798: LD_EXP 132
67802: PUSH
67803: LD_VAR 0 5
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67813: LD_ADDR_EXP 132
67817: PUSH
67818: LD_EXP 132
67822: PPUSH
67823: LD_VAR 0 5
67827: PPUSH
67828: EMPTY
67829: PPUSH
67830: CALL_OW 1
67834: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67835: LD_VAR 0 6
67839: PPUSH
67840: LD_INT 0
67842: PPUSH
67843: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67847: LD_VAR 0 6
67851: PPUSH
67852: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67856: LD_ADDR_EXP 131
67860: PUSH
67861: LD_EXP 131
67865: PPUSH
67866: LD_VAR 0 5
67870: PPUSH
67871: LD_EXP 131
67875: PUSH
67876: LD_VAR 0 5
67880: ARRAY
67881: PPUSH
67882: LD_INT 1
67884: PPUSH
67885: LD_VAR 0 6
67889: PPUSH
67890: CALL_OW 2
67894: PPUSH
67895: CALL_OW 1
67899: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67900: LD_VAR 0 5
67904: PPUSH
67905: LD_INT 112
67907: PPUSH
67908: CALL 44046 0 2
// end ; end ; end ;
67912: GO 67733
67914: POP
67915: POP
// end ;
67916: LD_VAR 0 3
67920: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67921: LD_INT 0
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
67928: PPUSH
67929: PPUSH
67930: PPUSH
// if not mc_bases or not skirmish then
67931: LD_EXP 102
67935: NOT
67936: IFTRUE 67945
67938: PUSH
67939: LD_EXP 100
67943: NOT
67944: OR
67945: IFFALSE 67949
// exit ;
67947: GO 69334
// for i = 1 to mc_bases do
67949: LD_ADDR_VAR 0 3
67953: PUSH
67954: DOUBLE
67955: LD_INT 1
67957: DEC
67958: ST_TO_ADDR
67959: LD_EXP 102
67963: PUSH
67964: FOR_TO
67965: IFFALSE 69332
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67967: LD_VAR 0 1
67971: PUSH
67972: LD_EXP 102
67976: PUSH
67977: LD_VAR 0 3
67981: ARRAY
67982: IN
67983: IFTRUE 68003
67985: PUSH
67986: LD_VAR 0 1
67990: PUSH
67991: LD_EXP 109
67995: PUSH
67996: LD_VAR 0 3
68000: ARRAY
68001: IN
68002: OR
68003: IFTRUE 68023
68005: PUSH
68006: LD_VAR 0 1
68010: PUSH
68011: LD_EXP 124
68015: PUSH
68016: LD_VAR 0 3
68020: ARRAY
68021: IN
68022: OR
68023: IFTRUE 68043
68025: PUSH
68026: LD_VAR 0 1
68030: PUSH
68031: LD_EXP 121
68035: PUSH
68036: LD_VAR 0 3
68040: ARRAY
68041: IN
68042: OR
68043: IFTRUE 68063
68045: PUSH
68046: LD_VAR 0 1
68050: PUSH
68051: LD_EXP 131
68055: PUSH
68056: LD_VAR 0 3
68060: ARRAY
68061: IN
68062: OR
68063: IFTRUE 68083
68065: PUSH
68066: LD_VAR 0 1
68070: PUSH
68071: LD_EXP 132
68075: PUSH
68076: LD_VAR 0 3
68080: ARRAY
68081: IN
68082: OR
68083: IFFALSE 69330
// begin if un in mc_ape [ i ] then
68085: LD_VAR 0 1
68089: PUSH
68090: LD_EXP 131
68094: PUSH
68095: LD_VAR 0 3
68099: ARRAY
68100: IN
68101: IFFALSE 68140
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68103: LD_ADDR_EXP 131
68107: PUSH
68108: LD_EXP 131
68112: PPUSH
68113: LD_VAR 0 3
68117: PPUSH
68118: LD_EXP 131
68122: PUSH
68123: LD_VAR 0 3
68127: ARRAY
68128: PUSH
68129: LD_VAR 0 1
68133: DIFF
68134: PPUSH
68135: CALL_OW 1
68139: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68140: LD_VAR 0 1
68144: PUSH
68145: LD_EXP 132
68149: PUSH
68150: LD_VAR 0 3
68154: ARRAY
68155: IN
68156: IFFALSE 68180
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68158: LD_ADDR_EXP 132
68162: PUSH
68163: LD_EXP 132
68167: PPUSH
68168: LD_VAR 0 3
68172: PPUSH
68173: EMPTY
68174: PPUSH
68175: CALL_OW 1
68179: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68180: LD_VAR 0 1
68184: PPUSH
68185: CALL_OW 247
68189: PUSH
68190: LD_INT 2
68192: EQUAL
68193: IFFALSE 68274
68195: PUSH
68196: LD_VAR 0 1
68200: PPUSH
68201: CALL_OW 110
68205: PUSH
68206: LD_INT 20
68208: EQUAL
68209: IFTRUE 68229
68211: PUSH
68212: LD_VAR 0 1
68216: PUSH
68217: LD_EXP 124
68221: PUSH
68222: LD_VAR 0 3
68226: ARRAY
68227: IN
68228: OR
68229: IFTRUE 68273
68231: PUSH
68232: LD_VAR 0 1
68236: PPUSH
68237: CALL_OW 264
68241: PUSH
68242: LD_INT 12
68244: PUSH
68245: LD_INT 51
68247: PUSH
68248: LD_INT 89
68250: PUSH
68251: LD_INT 32
68253: PUSH
68254: LD_INT 13
68256: PUSH
68257: LD_INT 52
68259: PUSH
68260: LD_INT 31
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: IN
68272: OR
68273: AND
68274: IFFALSE 68582
// begin if un in mc_defender [ i ] then
68276: LD_VAR 0 1
68280: PUSH
68281: LD_EXP 124
68285: PUSH
68286: LD_VAR 0 3
68290: ARRAY
68291: IN
68292: IFFALSE 68331
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68294: LD_ADDR_EXP 124
68298: PUSH
68299: LD_EXP 124
68303: PPUSH
68304: LD_VAR 0 3
68308: PPUSH
68309: LD_EXP 124
68313: PUSH
68314: LD_VAR 0 3
68318: ARRAY
68319: PUSH
68320: LD_VAR 0 1
68324: DIFF
68325: PPUSH
68326: CALL_OW 1
68330: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
68331: LD_ADDR_VAR 0 8
68335: PUSH
68336: LD_VAR 0 3
68340: PPUSH
68341: LD_INT 3
68343: PPUSH
68344: CALL 64870 0 2
68348: ST_TO_ADDR
// if fac then
68349: LD_VAR 0 8
68353: IFFALSE 68582
// begin for j in fac do
68355: LD_ADDR_VAR 0 4
68359: PUSH
68360: LD_VAR 0 8
68364: PUSH
68365: FOR_IN
68366: IFFALSE 68580
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
68368: LD_ADDR_VAR 0 9
68372: PUSH
68373: LD_VAR 0 8
68377: PPUSH
68378: LD_VAR 0 1
68382: PPUSH
68383: CALL_OW 265
68387: PPUSH
68388: LD_VAR 0 1
68392: PPUSH
68393: CALL_OW 262
68397: PPUSH
68398: LD_VAR 0 1
68402: PPUSH
68403: CALL_OW 263
68407: PPUSH
68408: LD_VAR 0 1
68412: PPUSH
68413: CALL_OW 264
68417: PPUSH
68418: CALL 73521 0 5
68422: ST_TO_ADDR
// if components then
68423: LD_VAR 0 9
68427: IFFALSE 68578
// begin if GetWeapon ( un ) = ar_control_tower then
68429: LD_VAR 0 1
68433: PPUSH
68434: CALL_OW 264
68438: PUSH
68439: LD_INT 31
68441: EQUAL
68442: IFFALSE 68559
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
68444: LD_VAR 0 1
68448: PPUSH
68449: CALL_OW 311
68453: PPUSH
68454: LD_INT 0
68456: PPUSH
68457: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
68461: LD_ADDR_EXP 142
68465: PUSH
68466: LD_EXP 142
68470: PPUSH
68471: LD_VAR 0 3
68475: PPUSH
68476: LD_EXP 142
68480: PUSH
68481: LD_VAR 0 3
68485: ARRAY
68486: PUSH
68487: LD_VAR 0 1
68491: PPUSH
68492: CALL_OW 311
68496: DIFF
68497: PPUSH
68498: CALL_OW 1
68502: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
68503: LD_ADDR_VAR 0 7
68507: PUSH
68508: LD_EXP 123
68512: PUSH
68513: LD_VAR 0 3
68517: ARRAY
68518: PPUSH
68519: LD_INT 1
68521: PPUSH
68522: LD_VAR 0 9
68526: PPUSH
68527: CALL_OW 2
68531: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68532: LD_ADDR_EXP 123
68536: PUSH
68537: LD_EXP 123
68541: PPUSH
68542: LD_VAR 0 3
68546: PPUSH
68547: LD_VAR 0 7
68551: PPUSH
68552: CALL_OW 1
68556: ST_TO_ADDR
// end else
68557: GO 68576
// MC_InsertProduceList ( i , [ components ] ) ;
68559: LD_VAR 0 3
68563: PPUSH
68564: LD_VAR 0 9
68568: PUSH
68569: EMPTY
68570: LIST
68571: PPUSH
68572: CALL 64415 0 2
// break ;
68576: GO 68580
// end ; end ;
68578: GO 68365
68580: POP
68581: POP
// end ; end ; if GetType ( un ) = unit_building then
68582: LD_VAR 0 1
68586: PPUSH
68587: CALL_OW 247
68591: PUSH
68592: LD_INT 3
68594: EQUAL
68595: IFFALSE 68998
// begin btype := GetBType ( un ) ;
68597: LD_ADDR_VAR 0 5
68601: PUSH
68602: LD_VAR 0 1
68606: PPUSH
68607: CALL_OW 266
68611: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
68612: LD_VAR 0 5
68616: PUSH
68617: LD_INT 29
68619: PUSH
68620: LD_INT 30
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: IN
68627: IFFALSE 68700
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
68629: LD_VAR 0 1
68633: PPUSH
68634: CALL_OW 250
68638: PPUSH
68639: LD_VAR 0 1
68643: PPUSH
68644: CALL_OW 251
68648: PPUSH
68649: LD_VAR 0 1
68653: PPUSH
68654: CALL_OW 255
68658: PPUSH
68659: CALL_OW 440
68663: NOT
68664: IFFALSE 68700
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68666: LD_VAR 0 1
68670: PPUSH
68671: CALL_OW 250
68675: PPUSH
68676: LD_VAR 0 1
68680: PPUSH
68681: CALL_OW 251
68685: PPUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: CALL_OW 255
68695: PPUSH
68696: CALL_OW 441
// end ; if btype = b_warehouse then
68700: LD_VAR 0 5
68704: PUSH
68705: LD_INT 1
68707: EQUAL
68708: IFFALSE 68726
// begin btype := b_depot ;
68710: LD_ADDR_VAR 0 5
68714: PUSH
68715: LD_INT 0
68717: ST_TO_ADDR
// pos := 1 ;
68718: LD_ADDR_VAR 0 6
68722: PUSH
68723: LD_INT 1
68725: ST_TO_ADDR
// end ; if btype = b_factory then
68726: LD_VAR 0 5
68730: PUSH
68731: LD_INT 3
68733: EQUAL
68734: IFFALSE 68752
// begin btype := b_workshop ;
68736: LD_ADDR_VAR 0 5
68740: PUSH
68741: LD_INT 2
68743: ST_TO_ADDR
// pos := 1 ;
68744: LD_ADDR_VAR 0 6
68748: PUSH
68749: LD_INT 1
68751: ST_TO_ADDR
// end ; if btype = b_barracks then
68752: LD_VAR 0 5
68756: PUSH
68757: LD_INT 5
68759: EQUAL
68760: IFFALSE 68770
// btype := b_armoury ;
68762: LD_ADDR_VAR 0 5
68766: PUSH
68767: LD_INT 4
68769: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68770: LD_VAR 0 5
68774: PUSH
68775: LD_INT 7
68777: PUSH
68778: LD_INT 8
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: IN
68785: IFFALSE 68795
// btype := b_lab ;
68787: LD_ADDR_VAR 0 5
68791: PUSH
68792: LD_INT 6
68794: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68795: LD_ADDR_EXP 107
68799: PUSH
68800: LD_EXP 107
68804: PPUSH
68805: LD_VAR 0 3
68809: PUSH
68810: LD_EXP 107
68814: PUSH
68815: LD_VAR 0 3
68819: ARRAY
68820: PUSH
68821: LD_INT 1
68823: PLUS
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PPUSH
68829: LD_VAR 0 5
68833: PUSH
68834: LD_VAR 0 1
68838: PPUSH
68839: CALL_OW 250
68843: PUSH
68844: LD_VAR 0 1
68848: PPUSH
68849: CALL_OW 251
68853: PUSH
68854: LD_VAR 0 1
68858: PPUSH
68859: CALL_OW 254
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: PPUSH
68870: CALL 76047 0 3
68874: ST_TO_ADDR
// if pos = 1 then
68875: LD_VAR 0 6
68879: PUSH
68880: LD_INT 1
68882: EQUAL
68883: IFFALSE 68998
// begin tmp := mc_build_list [ i ] ;
68885: LD_ADDR_VAR 0 7
68889: PUSH
68890: LD_EXP 107
68894: PUSH
68895: LD_VAR 0 3
68899: ARRAY
68900: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68901: LD_VAR 0 7
68905: PPUSH
68906: LD_INT 2
68908: PUSH
68909: LD_INT 30
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 30
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: PPUSH
68934: CALL_OW 72
68938: IFFALSE 68948
// pos := 2 ;
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: LD_INT 2
68947: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68948: LD_ADDR_VAR 0 7
68952: PUSH
68953: LD_VAR 0 7
68957: PPUSH
68958: LD_VAR 0 6
68962: PPUSH
68963: LD_VAR 0 7
68967: PPUSH
68968: CALL 76373 0 3
68972: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68973: LD_ADDR_EXP 107
68977: PUSH
68978: LD_EXP 107
68982: PPUSH
68983: LD_VAR 0 3
68987: PPUSH
68988: LD_VAR 0 7
68992: PPUSH
68993: CALL_OW 1
68997: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68998: LD_VAR 0 1
69002: PUSH
69003: LD_EXP 102
69007: PUSH
69008: LD_VAR 0 3
69012: ARRAY
69013: IN
69014: IFFALSE 69053
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69016: LD_ADDR_EXP 102
69020: PUSH
69021: LD_EXP 102
69025: PPUSH
69026: LD_VAR 0 3
69030: PPUSH
69031: LD_EXP 102
69035: PUSH
69036: LD_VAR 0 3
69040: ARRAY
69041: PUSH
69042: LD_VAR 0 1
69046: DIFF
69047: PPUSH
69048: CALL_OW 1
69052: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69053: LD_VAR 0 1
69057: PUSH
69058: LD_EXP 109
69062: PUSH
69063: LD_VAR 0 3
69067: ARRAY
69068: IN
69069: IFFALSE 69108
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69071: LD_ADDR_EXP 109
69075: PUSH
69076: LD_EXP 109
69080: PPUSH
69081: LD_VAR 0 3
69085: PPUSH
69086: LD_EXP 109
69090: PUSH
69091: LD_VAR 0 3
69095: ARRAY
69096: PUSH
69097: LD_VAR 0 1
69101: DIFF
69102: PPUSH
69103: CALL_OW 1
69107: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69108: LD_VAR 0 1
69112: PUSH
69113: LD_EXP 121
69117: PUSH
69118: LD_VAR 0 3
69122: ARRAY
69123: IN
69124: IFFALSE 69163
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69126: LD_ADDR_EXP 121
69130: PUSH
69131: LD_EXP 121
69135: PPUSH
69136: LD_VAR 0 3
69140: PPUSH
69141: LD_EXP 121
69145: PUSH
69146: LD_VAR 0 3
69150: ARRAY
69151: PUSH
69152: LD_VAR 0 1
69156: DIFF
69157: PPUSH
69158: CALL_OW 1
69162: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69163: LD_VAR 0 1
69167: PUSH
69168: LD_EXP 124
69172: PUSH
69173: LD_VAR 0 3
69177: ARRAY
69178: IN
69179: IFFALSE 69218
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69181: LD_ADDR_EXP 124
69185: PUSH
69186: LD_EXP 124
69190: PPUSH
69191: LD_VAR 0 3
69195: PPUSH
69196: LD_EXP 124
69200: PUSH
69201: LD_VAR 0 3
69205: ARRAY
69206: PUSH
69207: LD_VAR 0 1
69211: DIFF
69212: PPUSH
69213: CALL_OW 1
69217: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69218: LD_VAR 0 1
69222: PUSH
69223: LD_EXP 111
69227: PUSH
69228: LD_VAR 0 3
69232: ARRAY
69233: IN
69234: IFFALSE 69273
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69236: LD_ADDR_EXP 111
69240: PUSH
69241: LD_EXP 111
69245: PPUSH
69246: LD_VAR 0 3
69250: PPUSH
69251: LD_EXP 111
69255: PUSH
69256: LD_VAR 0 3
69260: ARRAY
69261: PUSH
69262: LD_VAR 0 1
69266: DIFF
69267: PPUSH
69268: CALL_OW 1
69272: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
69273: LD_VAR 0 1
69277: PUSH
69278: LD_EXP 110
69282: PUSH
69283: LD_VAR 0 3
69287: ARRAY
69288: IN
69289: IFFALSE 69328
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
69291: LD_ADDR_EXP 110
69295: PUSH
69296: LD_EXP 110
69300: PPUSH
69301: LD_VAR 0 3
69305: PPUSH
69306: LD_EXP 110
69310: PUSH
69311: LD_VAR 0 3
69315: ARRAY
69316: PUSH
69317: LD_VAR 0 1
69321: DIFF
69322: PPUSH
69323: CALL_OW 1
69327: ST_TO_ADDR
// end ; break ;
69328: GO 69332
// end ;
69330: GO 67964
69332: POP
69333: POP
// end ;
69334: LD_VAR 0 2
69338: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
69339: LD_INT 0
69341: PPUSH
69342: PPUSH
69343: PPUSH
// if not mc_bases or not skirmish then
69344: LD_EXP 102
69348: NOT
69349: IFTRUE 69358
69351: PUSH
69352: LD_EXP 100
69356: NOT
69357: OR
69358: IFFALSE 69362
// exit ;
69360: GO 69577
// for i = 1 to mc_bases do
69362: LD_ADDR_VAR 0 3
69366: PUSH
69367: DOUBLE
69368: LD_INT 1
69370: DEC
69371: ST_TO_ADDR
69372: LD_EXP 102
69376: PUSH
69377: FOR_TO
69378: IFFALSE 69575
// begin if building in mc_construct_list [ i ] then
69380: LD_VAR 0 1
69384: PUSH
69385: LD_EXP 109
69389: PUSH
69390: LD_VAR 0 3
69394: ARRAY
69395: IN
69396: IFFALSE 69573
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69398: LD_ADDR_EXP 109
69402: PUSH
69403: LD_EXP 109
69407: PPUSH
69408: LD_VAR 0 3
69412: PPUSH
69413: LD_EXP 109
69417: PUSH
69418: LD_VAR 0 3
69422: ARRAY
69423: PUSH
69424: LD_VAR 0 1
69428: DIFF
69429: PPUSH
69430: CALL_OW 1
69434: ST_TO_ADDR
// if building in mc_lab [ i ] then
69435: LD_VAR 0 1
69439: PUSH
69440: LD_EXP 135
69444: PUSH
69445: LD_VAR 0 3
69449: ARRAY
69450: IN
69451: IFFALSE 69506
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
69453: LD_ADDR_EXP 136
69457: PUSH
69458: LD_EXP 136
69462: PPUSH
69463: LD_VAR 0 3
69467: PPUSH
69468: LD_EXP 136
69472: PUSH
69473: LD_VAR 0 3
69477: ARRAY
69478: PPUSH
69479: LD_INT 1
69481: PPUSH
69482: LD_EXP 136
69486: PUSH
69487: LD_VAR 0 3
69491: ARRAY
69492: PPUSH
69493: LD_INT 0
69495: PPUSH
69496: CALL 75455 0 4
69500: PPUSH
69501: CALL_OW 1
69505: ST_TO_ADDR
// if not building in mc_bases [ i ] then
69506: LD_VAR 0 1
69510: PUSH
69511: LD_EXP 102
69515: PUSH
69516: LD_VAR 0 3
69520: ARRAY
69521: IN
69522: NOT
69523: IFFALSE 69569
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69525: LD_ADDR_EXP 102
69529: PUSH
69530: LD_EXP 102
69534: PPUSH
69535: LD_VAR 0 3
69539: PUSH
69540: LD_EXP 102
69544: PUSH
69545: LD_VAR 0 3
69549: ARRAY
69550: PUSH
69551: LD_INT 1
69553: PLUS
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PPUSH
69559: LD_VAR 0 1
69563: PPUSH
69564: CALL 76047 0 3
69568: ST_TO_ADDR
// exit ;
69569: POP
69570: POP
69571: GO 69577
// end ; end ;
69573: GO 69377
69575: POP
69576: POP
// end ;
69577: LD_VAR 0 2
69581: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
69582: LD_INT 0
69584: PPUSH
69585: PPUSH
69586: PPUSH
69587: PPUSH
69588: PPUSH
69589: PPUSH
69590: PPUSH
// if not mc_bases or not skirmish then
69591: LD_EXP 102
69595: NOT
69596: IFTRUE 69605
69598: PUSH
69599: LD_EXP 100
69603: NOT
69604: OR
69605: IFFALSE 69609
// exit ;
69607: GO 70270
// for i = 1 to mc_bases do
69609: LD_ADDR_VAR 0 3
69613: PUSH
69614: DOUBLE
69615: LD_INT 1
69617: DEC
69618: ST_TO_ADDR
69619: LD_EXP 102
69623: PUSH
69624: FOR_TO
69625: IFFALSE 70268
// begin if building in mc_construct_list [ i ] then
69627: LD_VAR 0 1
69631: PUSH
69632: LD_EXP 109
69636: PUSH
69637: LD_VAR 0 3
69641: ARRAY
69642: IN
69643: IFFALSE 70266
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69645: LD_ADDR_EXP 109
69649: PUSH
69650: LD_EXP 109
69654: PPUSH
69655: LD_VAR 0 3
69659: PPUSH
69660: LD_EXP 109
69664: PUSH
69665: LD_VAR 0 3
69669: ARRAY
69670: PUSH
69671: LD_VAR 0 1
69675: DIFF
69676: PPUSH
69677: CALL_OW 1
69681: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69682: LD_ADDR_EXP 102
69686: PUSH
69687: LD_EXP 102
69691: PPUSH
69692: LD_VAR 0 3
69696: PUSH
69697: LD_EXP 102
69701: PUSH
69702: LD_VAR 0 3
69706: ARRAY
69707: PUSH
69708: LD_INT 1
69710: PLUS
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PPUSH
69716: LD_VAR 0 1
69720: PPUSH
69721: CALL 76047 0 3
69725: ST_TO_ADDR
// btype := GetBType ( building ) ;
69726: LD_ADDR_VAR 0 5
69730: PUSH
69731: LD_VAR 0 1
69735: PPUSH
69736: CALL_OW 266
69740: ST_TO_ADDR
// side := GetSide ( building ) ;
69741: LD_ADDR_VAR 0 8
69745: PUSH
69746: LD_VAR 0 1
69750: PPUSH
69751: CALL_OW 255
69755: ST_TO_ADDR
// if btype = b_lab then
69756: LD_VAR 0 5
69760: PUSH
69761: LD_INT 6
69763: EQUAL
69764: IFFALSE 69814
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69766: LD_ADDR_EXP 135
69770: PUSH
69771: LD_EXP 135
69775: PPUSH
69776: LD_VAR 0 3
69780: PUSH
69781: LD_EXP 135
69785: PUSH
69786: LD_VAR 0 3
69790: ARRAY
69791: PUSH
69792: LD_INT 1
69794: PLUS
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PPUSH
69800: LD_VAR 0 1
69804: PPUSH
69805: CALL 76047 0 3
69809: ST_TO_ADDR
// exit ;
69810: POP
69811: POP
69812: GO 70270
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69814: LD_VAR 0 5
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 2
69824: PUSH
69825: LD_INT 4
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: IN
69833: IFFALSE 69957
// begin if btype = b_armoury then
69835: LD_VAR 0 5
69839: PUSH
69840: LD_INT 4
69842: EQUAL
69843: IFFALSE 69853
// btype := b_barracks ;
69845: LD_ADDR_VAR 0 5
69849: PUSH
69850: LD_INT 5
69852: ST_TO_ADDR
// if btype = b_depot then
69853: LD_VAR 0 5
69857: PUSH
69858: LD_INT 0
69860: EQUAL
69861: IFFALSE 69871
// btype := b_warehouse ;
69863: LD_ADDR_VAR 0 5
69867: PUSH
69868: LD_INT 1
69870: ST_TO_ADDR
// if btype = b_workshop then
69871: LD_VAR 0 5
69875: PUSH
69876: LD_INT 2
69878: EQUAL
69879: IFFALSE 69889
// btype := b_factory ;
69881: LD_ADDR_VAR 0 5
69885: PUSH
69886: LD_INT 3
69888: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69889: LD_VAR 0 5
69893: PPUSH
69894: LD_VAR 0 8
69898: PPUSH
69899: CALL_OW 323
69903: PUSH
69904: LD_INT 1
69906: EQUAL
69907: IFFALSE 69953
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69909: LD_ADDR_EXP 134
69913: PUSH
69914: LD_EXP 134
69918: PPUSH
69919: LD_VAR 0 3
69923: PUSH
69924: LD_EXP 134
69928: PUSH
69929: LD_VAR 0 3
69933: ARRAY
69934: PUSH
69935: LD_INT 1
69937: PLUS
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PPUSH
69943: LD_VAR 0 1
69947: PPUSH
69948: CALL 76047 0 3
69952: ST_TO_ADDR
// exit ;
69953: POP
69954: POP
69955: GO 70270
// end ; if btype in [ b_bunker , b_turret ] then
69957: LD_VAR 0 5
69961: PUSH
69962: LD_INT 32
69964: PUSH
69965: LD_INT 33
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: IN
69972: IFFALSE 70262
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69974: LD_ADDR_EXP 110
69978: PUSH
69979: LD_EXP 110
69983: PPUSH
69984: LD_VAR 0 3
69988: PUSH
69989: LD_EXP 110
69993: PUSH
69994: LD_VAR 0 3
69998: ARRAY
69999: PUSH
70000: LD_INT 1
70002: PLUS
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PPUSH
70008: LD_VAR 0 1
70012: PPUSH
70013: CALL 76047 0 3
70017: ST_TO_ADDR
// if btype = b_bunker then
70018: LD_VAR 0 5
70022: PUSH
70023: LD_INT 32
70025: EQUAL
70026: IFFALSE 70262
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70028: LD_ADDR_EXP 111
70032: PUSH
70033: LD_EXP 111
70037: PPUSH
70038: LD_VAR 0 3
70042: PUSH
70043: LD_EXP 111
70047: PUSH
70048: LD_VAR 0 3
70052: ARRAY
70053: PUSH
70054: LD_INT 1
70056: PLUS
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PPUSH
70062: LD_VAR 0 1
70066: PPUSH
70067: CALL 76047 0 3
70071: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70072: LD_ADDR_VAR 0 6
70076: PUSH
70077: LD_EXP 102
70081: PUSH
70082: LD_VAR 0 3
70086: ARRAY
70087: PPUSH
70088: LD_INT 25
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 3
70100: PUSH
70101: LD_INT 54
70103: PUSH
70104: EMPTY
70105: LIST
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PPUSH
70115: CALL_OW 72
70119: ST_TO_ADDR
// if tmp then
70120: LD_VAR 0 6
70124: IFFALSE 70130
// exit ;
70126: POP
70127: POP
70128: GO 70270
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70130: LD_ADDR_VAR 0 6
70134: PUSH
70135: LD_EXP 102
70139: PUSH
70140: LD_VAR 0 3
70144: ARRAY
70145: PPUSH
70146: LD_INT 2
70148: PUSH
70149: LD_INT 30
70151: PUSH
70152: LD_INT 4
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 30
70161: PUSH
70162: LD_INT 5
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: LIST
70173: PPUSH
70174: CALL_OW 72
70178: ST_TO_ADDR
// if not tmp then
70179: LD_VAR 0 6
70183: NOT
70184: IFFALSE 70190
// exit ;
70186: POP
70187: POP
70188: GO 70270
// for j in tmp do
70190: LD_ADDR_VAR 0 4
70194: PUSH
70195: LD_VAR 0 6
70199: PUSH
70200: FOR_IN
70201: IFFALSE 70260
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70203: LD_ADDR_VAR 0 7
70207: PUSH
70208: LD_VAR 0 4
70212: PPUSH
70213: CALL_OW 313
70217: PPUSH
70218: LD_INT 25
70220: PUSH
70221: LD_INT 1
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PPUSH
70228: CALL_OW 72
70232: ST_TO_ADDR
// if units then
70233: LD_VAR 0 7
70237: IFFALSE 70258
// begin ComExitBuilding ( units [ 1 ] ) ;
70239: LD_VAR 0 7
70243: PUSH
70244: LD_INT 1
70246: ARRAY
70247: PPUSH
70248: CALL_OW 122
// exit ;
70252: POP
70253: POP
70254: POP
70255: POP
70256: GO 70270
// end ; end ;
70258: GO 70200
70260: POP
70261: POP
// end ; end ; exit ;
70262: POP
70263: POP
70264: GO 70270
// end ; end ;
70266: GO 69624
70268: POP
70269: POP
// end ;
70270: LD_VAR 0 2
70274: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
70275: LD_INT 0
70277: PPUSH
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
// if not mc_bases or not skirmish then
70284: LD_EXP 102
70288: NOT
70289: IFTRUE 70298
70291: PUSH
70292: LD_EXP 100
70296: NOT
70297: OR
70298: IFFALSE 70302
// exit ;
70300: GO 70567
// btype := GetBType ( building ) ;
70302: LD_ADDR_VAR 0 6
70306: PUSH
70307: LD_VAR 0 1
70311: PPUSH
70312: CALL_OW 266
70316: ST_TO_ADDR
// x := GetX ( building ) ;
70317: LD_ADDR_VAR 0 7
70321: PUSH
70322: LD_VAR 0 1
70326: PPUSH
70327: CALL_OW 250
70331: ST_TO_ADDR
// y := GetY ( building ) ;
70332: LD_ADDR_VAR 0 8
70336: PUSH
70337: LD_VAR 0 1
70341: PPUSH
70342: CALL_OW 251
70346: ST_TO_ADDR
// d := GetDir ( building ) ;
70347: LD_ADDR_VAR 0 9
70351: PUSH
70352: LD_VAR 0 1
70356: PPUSH
70357: CALL_OW 254
70361: ST_TO_ADDR
// for i = 1 to mc_bases do
70362: LD_ADDR_VAR 0 4
70366: PUSH
70367: DOUBLE
70368: LD_INT 1
70370: DEC
70371: ST_TO_ADDR
70372: LD_EXP 102
70376: PUSH
70377: FOR_TO
70378: IFFALSE 70565
// begin if not mc_build_list [ i ] then
70380: LD_EXP 107
70384: PUSH
70385: LD_VAR 0 4
70389: ARRAY
70390: NOT
70391: IFFALSE 70395
// continue ;
70393: GO 70377
// for j := 1 to mc_build_list [ i ] do
70395: LD_ADDR_VAR 0 5
70399: PUSH
70400: DOUBLE
70401: LD_INT 1
70403: DEC
70404: ST_TO_ADDR
70405: LD_EXP 107
70409: PUSH
70410: LD_VAR 0 4
70414: ARRAY
70415: PUSH
70416: FOR_TO
70417: IFFALSE 70561
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
70419: LD_VAR 0 6
70423: PUSH
70424: LD_VAR 0 7
70428: PUSH
70429: LD_VAR 0 8
70433: PUSH
70434: LD_VAR 0 9
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: PPUSH
70445: LD_EXP 107
70449: PUSH
70450: LD_VAR 0 4
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 5
70460: ARRAY
70461: PPUSH
70462: CALL 82654 0 2
70466: IFFALSE 70559
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
70468: LD_ADDR_EXP 107
70472: PUSH
70473: LD_EXP 107
70477: PPUSH
70478: LD_VAR 0 4
70482: PPUSH
70483: LD_EXP 107
70487: PUSH
70488: LD_VAR 0 4
70492: ARRAY
70493: PPUSH
70494: LD_VAR 0 5
70498: PPUSH
70499: CALL_OW 3
70503: PPUSH
70504: CALL_OW 1
70508: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
70509: LD_ADDR_EXP 109
70513: PUSH
70514: LD_EXP 109
70518: PPUSH
70519: LD_VAR 0 4
70523: PUSH
70524: LD_EXP 109
70528: PUSH
70529: LD_VAR 0 4
70533: ARRAY
70534: PUSH
70535: LD_INT 1
70537: PLUS
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PPUSH
70543: LD_VAR 0 1
70547: PPUSH
70548: CALL 76047 0 3
70552: ST_TO_ADDR
// exit ;
70553: POP
70554: POP
70555: POP
70556: POP
70557: GO 70567
// end ;
70559: GO 70416
70561: POP
70562: POP
// end ;
70563: GO 70377
70565: POP
70566: POP
// end ;
70567: LD_VAR 0 3
70571: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
70572: LD_INT 0
70574: PPUSH
70575: PPUSH
70576: PPUSH
// if not mc_bases or not skirmish then
70577: LD_EXP 102
70581: NOT
70582: IFTRUE 70591
70584: PUSH
70585: LD_EXP 100
70589: NOT
70590: OR
70591: IFFALSE 70595
// exit ;
70593: GO 70791
// for i = 1 to mc_bases do
70595: LD_ADDR_VAR 0 4
70599: PUSH
70600: DOUBLE
70601: LD_INT 1
70603: DEC
70604: ST_TO_ADDR
70605: LD_EXP 102
70609: PUSH
70610: FOR_TO
70611: IFFALSE 70700
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
70613: LD_VAR 0 1
70617: PUSH
70618: LD_EXP 110
70622: PUSH
70623: LD_VAR 0 4
70627: ARRAY
70628: IN
70629: IFFALSE 70650
70631: PUSH
70632: LD_VAR 0 1
70636: PUSH
70637: LD_EXP 111
70641: PUSH
70642: LD_VAR 0 4
70646: ARRAY
70647: IN
70648: NOT
70649: AND
70650: IFFALSE 70698
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70652: LD_ADDR_EXP 111
70656: PUSH
70657: LD_EXP 111
70661: PPUSH
70662: LD_VAR 0 4
70666: PUSH
70667: LD_EXP 111
70671: PUSH
70672: LD_VAR 0 4
70676: ARRAY
70677: PUSH
70678: LD_INT 1
70680: PLUS
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PPUSH
70686: LD_VAR 0 1
70690: PPUSH
70691: CALL 76047 0 3
70695: ST_TO_ADDR
// break ;
70696: GO 70700
// end ; end ;
70698: GO 70610
70700: POP
70701: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70702: LD_VAR 0 1
70706: PPUSH
70707: CALL_OW 257
70711: PUSH
70712: LD_EXP 128
70716: IN
70717: IFFALSE 70734
70719: PUSH
70720: LD_VAR 0 1
70724: PPUSH
70725: CALL_OW 266
70729: PUSH
70730: LD_INT 5
70732: EQUAL
70733: AND
70734: IFFALSE 70751
70736: PUSH
70737: LD_VAR 0 2
70741: PPUSH
70742: CALL_OW 110
70746: PUSH
70747: LD_INT 18
70749: NONEQUAL
70750: AND
70751: IFFALSE 70791
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70753: LD_VAR 0 2
70757: PPUSH
70758: CALL_OW 257
70762: PUSH
70763: LD_INT 5
70765: PUSH
70766: LD_INT 8
70768: PUSH
70769: LD_INT 9
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: LIST
70776: IN
70777: IFFALSE 70791
// SetClass ( unit , 1 ) ;
70779: LD_VAR 0 2
70783: PPUSH
70784: LD_INT 1
70786: PPUSH
70787: CALL_OW 336
// end ;
70791: LD_VAR 0 3
70795: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70796: LD_INT 0
70798: PPUSH
70799: PPUSH
// if not mc_bases or not skirmish then
70800: LD_EXP 102
70804: NOT
70805: IFTRUE 70814
70807: PUSH
70808: LD_EXP 100
70812: NOT
70813: OR
70814: IFFALSE 70818
// exit ;
70816: GO 70934
// if GetLives ( abandoned_vehicle ) > 250 then
70818: LD_VAR 0 2
70822: PPUSH
70823: CALL_OW 256
70827: PUSH
70828: LD_INT 250
70830: GREATER
70831: IFFALSE 70835
// exit ;
70833: GO 70934
// for i = 1 to mc_bases do
70835: LD_ADDR_VAR 0 6
70839: PUSH
70840: DOUBLE
70841: LD_INT 1
70843: DEC
70844: ST_TO_ADDR
70845: LD_EXP 102
70849: PUSH
70850: FOR_TO
70851: IFFALSE 70932
// begin if driver in mc_bases [ i ] then
70853: LD_VAR 0 1
70857: PUSH
70858: LD_EXP 102
70862: PUSH
70863: LD_VAR 0 6
70867: ARRAY
70868: IN
70869: IFFALSE 70930
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70871: LD_VAR 0 1
70875: PPUSH
70876: LD_EXP 102
70880: PUSH
70881: LD_VAR 0 6
70885: ARRAY
70886: PPUSH
70887: LD_INT 2
70889: PUSH
70890: LD_INT 30
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 30
70902: PUSH
70903: LD_INT 1
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: PPUSH
70915: CALL_OW 72
70919: PUSH
70920: LD_INT 1
70922: ARRAY
70923: PPUSH
70924: CALL 109974 0 2
// break ;
70928: GO 70932
// end ; end ;
70930: GO 70850
70932: POP
70933: POP
// end ; end_of_file
70934: LD_VAR 0 5
70938: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70939: LD_INT 0
70941: PPUSH
70942: PPUSH
// if exist_mode then
70943: LD_VAR 0 2
70947: IFFALSE 70993
// begin unit := CreateCharacter ( prefix & ident ) ;
70949: LD_ADDR_VAR 0 5
70953: PUSH
70954: LD_VAR 0 3
70958: PUSH
70959: LD_VAR 0 1
70963: STR
70964: PPUSH
70965: CALL_OW 34
70969: ST_TO_ADDR
// if unit then
70970: LD_VAR 0 5
70974: IFFALSE 70991
// DeleteCharacters ( prefix & ident ) ;
70976: LD_VAR 0 3
70980: PUSH
70981: LD_VAR 0 1
70985: STR
70986: PPUSH
70987: CALL_OW 40
// end else
70991: GO 71008
// unit := NewCharacter ( ident ) ;
70993: LD_ADDR_VAR 0 5
70997: PUSH
70998: LD_VAR 0 1
71002: PPUSH
71003: CALL_OW 25
71007: ST_TO_ADDR
// result := unit ;
71008: LD_ADDR_VAR 0 4
71012: PUSH
71013: LD_VAR 0 5
71017: ST_TO_ADDR
// end ;
71018: LD_VAR 0 4
71022: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
71023: LD_INT 0
71025: PPUSH
71026: PPUSH
// if exist_mode then
71027: LD_VAR 0 2
71031: IFFALSE 71056
// unit := CreateCharacter ( prefix & ident ) else
71033: LD_ADDR_VAR 0 5
71037: PUSH
71038: LD_VAR 0 3
71042: PUSH
71043: LD_VAR 0 1
71047: STR
71048: PPUSH
71049: CALL_OW 34
71053: ST_TO_ADDR
71054: GO 71071
// unit := NewCharacter ( ident ) ;
71056: LD_ADDR_VAR 0 5
71060: PUSH
71061: LD_VAR 0 1
71065: PPUSH
71066: CALL_OW 25
71070: ST_TO_ADDR
// result := unit ;
71071: LD_ADDR_VAR 0 4
71075: PUSH
71076: LD_VAR 0 5
71080: ST_TO_ADDR
// end ;
71081: LD_VAR 0 4
71085: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
71086: LD_INT 0
71088: PPUSH
71089: PPUSH
// if not side or not nation then
71090: LD_VAR 0 1
71094: NOT
71095: IFTRUE 71104
71097: PUSH
71098: LD_VAR 0 2
71102: NOT
71103: OR
71104: IFFALSE 71108
// exit ;
71106: GO 71902
// case nation of nation_american :
71108: LD_VAR 0 2
71112: PUSH
71113: LD_INT 1
71115: DOUBLE
71116: EQUAL
71117: IFTRUE 71121
71119: GO 71343
71121: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
71122: LD_ADDR_VAR 0 4
71126: PUSH
71127: LD_INT 35
71129: PUSH
71130: LD_INT 45
71132: PUSH
71133: LD_INT 46
71135: PUSH
71136: LD_INT 47
71138: PUSH
71139: LD_INT 82
71141: PUSH
71142: LD_INT 83
71144: PUSH
71145: LD_INT 84
71147: PUSH
71148: LD_INT 85
71150: PUSH
71151: LD_INT 86
71153: PUSH
71154: LD_INT 1
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: LD_INT 6
71162: PUSH
71163: LD_INT 15
71165: PUSH
71166: LD_INT 16
71168: PUSH
71169: LD_INT 7
71171: PUSH
71172: LD_INT 12
71174: PUSH
71175: LD_INT 13
71177: PUSH
71178: LD_INT 10
71180: PUSH
71181: LD_INT 14
71183: PUSH
71184: LD_INT 20
71186: PUSH
71187: LD_INT 21
71189: PUSH
71190: LD_INT 22
71192: PUSH
71193: LD_INT 25
71195: PUSH
71196: LD_INT 32
71198: PUSH
71199: LD_INT 27
71201: PUSH
71202: LD_INT 36
71204: PUSH
71205: LD_INT 69
71207: PUSH
71208: LD_INT 39
71210: PUSH
71211: LD_INT 34
71213: PUSH
71214: LD_INT 40
71216: PUSH
71217: LD_INT 48
71219: PUSH
71220: LD_INT 49
71222: PUSH
71223: LD_INT 50
71225: PUSH
71226: LD_INT 51
71228: PUSH
71229: LD_INT 52
71231: PUSH
71232: LD_INT 53
71234: PUSH
71235: LD_INT 54
71237: PUSH
71238: LD_INT 55
71240: PUSH
71241: LD_INT 56
71243: PUSH
71244: LD_INT 57
71246: PUSH
71247: LD_INT 58
71249: PUSH
71250: LD_INT 59
71252: PUSH
71253: LD_INT 60
71255: PUSH
71256: LD_INT 61
71258: PUSH
71259: LD_INT 62
71261: PUSH
71262: LD_INT 80
71264: PUSH
71265: LD_INT 82
71267: PUSH
71268: LD_INT 83
71270: PUSH
71271: LD_INT 84
71273: PUSH
71274: LD_INT 85
71276: PUSH
71277: LD_INT 86
71279: PUSH
71280: LD_INT 90
71282: PUSH
71283: LD_INT 93
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: ST_TO_ADDR
71341: GO 71824
71343: LD_INT 2
71345: DOUBLE
71346: EQUAL
71347: IFTRUE 71351
71349: GO 71585
71351: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
71352: LD_ADDR_VAR 0 4
71356: PUSH
71357: LD_INT 35
71359: PUSH
71360: LD_INT 45
71362: PUSH
71363: LD_INT 46
71365: PUSH
71366: LD_INT 47
71368: PUSH
71369: LD_INT 82
71371: PUSH
71372: LD_INT 83
71374: PUSH
71375: LD_INT 84
71377: PUSH
71378: LD_INT 85
71380: PUSH
71381: LD_INT 87
71383: PUSH
71384: LD_INT 70
71386: PUSH
71387: LD_INT 1
71389: PUSH
71390: LD_INT 11
71392: PUSH
71393: LD_INT 3
71395: PUSH
71396: LD_INT 4
71398: PUSH
71399: LD_INT 5
71401: PUSH
71402: LD_INT 6
71404: PUSH
71405: LD_INT 15
71407: PUSH
71408: LD_INT 18
71410: PUSH
71411: LD_INT 7
71413: PUSH
71414: LD_INT 17
71416: PUSH
71417: LD_INT 8
71419: PUSH
71420: LD_INT 20
71422: PUSH
71423: LD_INT 21
71425: PUSH
71426: LD_INT 22
71428: PUSH
71429: LD_INT 72
71431: PUSH
71432: LD_INT 26
71434: PUSH
71435: LD_INT 69
71437: PUSH
71438: LD_INT 39
71440: PUSH
71441: LD_INT 40
71443: PUSH
71444: LD_INT 41
71446: PUSH
71447: LD_INT 42
71449: PUSH
71450: LD_INT 43
71452: PUSH
71453: LD_INT 48
71455: PUSH
71456: LD_INT 49
71458: PUSH
71459: LD_INT 50
71461: PUSH
71462: LD_INT 51
71464: PUSH
71465: LD_INT 52
71467: PUSH
71468: LD_INT 53
71470: PUSH
71471: LD_INT 54
71473: PUSH
71474: LD_INT 55
71476: PUSH
71477: LD_INT 56
71479: PUSH
71480: LD_INT 60
71482: PUSH
71483: LD_INT 61
71485: PUSH
71486: LD_INT 62
71488: PUSH
71489: LD_INT 66
71491: PUSH
71492: LD_INT 67
71494: PUSH
71495: LD_INT 68
71497: PUSH
71498: LD_INT 81
71500: PUSH
71501: LD_INT 82
71503: PUSH
71504: LD_INT 83
71506: PUSH
71507: LD_INT 84
71509: PUSH
71510: LD_INT 85
71512: PUSH
71513: LD_INT 87
71515: PUSH
71516: LD_INT 88
71518: PUSH
71519: LD_INT 92
71521: PUSH
71522: LD_INT 94
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: LIST
71562: LIST
71563: LIST
71564: LIST
71565: LIST
71566: LIST
71567: LIST
71568: LIST
71569: LIST
71570: LIST
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: ST_TO_ADDR
71583: GO 71824
71585: LD_INT 3
71587: DOUBLE
71588: EQUAL
71589: IFTRUE 71593
71591: GO 71823
71593: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
71594: LD_ADDR_VAR 0 4
71598: PUSH
71599: LD_INT 46
71601: PUSH
71602: LD_INT 47
71604: PUSH
71605: LD_INT 1
71607: PUSH
71608: LD_INT 2
71610: PUSH
71611: LD_INT 82
71613: PUSH
71614: LD_INT 83
71616: PUSH
71617: LD_INT 84
71619: PUSH
71620: LD_INT 85
71622: PUSH
71623: LD_INT 86
71625: PUSH
71626: LD_INT 11
71628: PUSH
71629: LD_INT 9
71631: PUSH
71632: LD_INT 20
71634: PUSH
71635: LD_INT 19
71637: PUSH
71638: LD_INT 21
71640: PUSH
71641: LD_INT 24
71643: PUSH
71644: LD_INT 22
71646: PUSH
71647: LD_INT 25
71649: PUSH
71650: LD_INT 28
71652: PUSH
71653: LD_INT 29
71655: PUSH
71656: LD_INT 30
71658: PUSH
71659: LD_INT 31
71661: PUSH
71662: LD_INT 37
71664: PUSH
71665: LD_INT 38
71667: PUSH
71668: LD_INT 32
71670: PUSH
71671: LD_INT 27
71673: PUSH
71674: LD_INT 33
71676: PUSH
71677: LD_INT 69
71679: PUSH
71680: LD_INT 39
71682: PUSH
71683: LD_INT 34
71685: PUSH
71686: LD_INT 40
71688: PUSH
71689: LD_INT 71
71691: PUSH
71692: LD_INT 23
71694: PUSH
71695: LD_INT 44
71697: PUSH
71698: LD_INT 48
71700: PUSH
71701: LD_INT 49
71703: PUSH
71704: LD_INT 50
71706: PUSH
71707: LD_INT 51
71709: PUSH
71710: LD_INT 52
71712: PUSH
71713: LD_INT 53
71715: PUSH
71716: LD_INT 54
71718: PUSH
71719: LD_INT 55
71721: PUSH
71722: LD_INT 56
71724: PUSH
71725: LD_INT 57
71727: PUSH
71728: LD_INT 58
71730: PUSH
71731: LD_INT 59
71733: PUSH
71734: LD_INT 63
71736: PUSH
71737: LD_INT 64
71739: PUSH
71740: LD_INT 65
71742: PUSH
71743: LD_INT 82
71745: PUSH
71746: LD_INT 83
71748: PUSH
71749: LD_INT 84
71751: PUSH
71752: LD_INT 85
71754: PUSH
71755: LD_INT 86
71757: PUSH
71758: LD_INT 89
71760: PUSH
71761: LD_INT 91
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: ST_TO_ADDR
71821: GO 71824
71823: POP
// if state > - 1 and state < 3 then
71824: LD_VAR 0 3
71828: PUSH
71829: LD_INT 1
71831: NEG
71832: GREATER
71833: IFFALSE 71845
71835: PUSH
71836: LD_VAR 0 3
71840: PUSH
71841: LD_INT 3
71843: LESS
71844: AND
71845: IFFALSE 71902
// for i in result do
71847: LD_ADDR_VAR 0 5
71851: PUSH
71852: LD_VAR 0 4
71856: PUSH
71857: FOR_IN
71858: IFFALSE 71900
// if GetTech ( i , side ) <> state then
71860: LD_VAR 0 5
71864: PPUSH
71865: LD_VAR 0 1
71869: PPUSH
71870: CALL_OW 321
71874: PUSH
71875: LD_VAR 0 3
71879: NONEQUAL
71880: IFFALSE 71898
// result := result diff i ;
71882: LD_ADDR_VAR 0 4
71886: PUSH
71887: LD_VAR 0 4
71891: PUSH
71892: LD_VAR 0 5
71896: DIFF
71897: ST_TO_ADDR
71898: GO 71857
71900: POP
71901: POP
// end ;
71902: LD_VAR 0 4
71906: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71907: LD_INT 0
71909: PPUSH
71910: PPUSH
71911: PPUSH
// result := true ;
71912: LD_ADDR_VAR 0 3
71916: PUSH
71917: LD_INT 1
71919: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71920: LD_ADDR_VAR 0 5
71924: PUSH
71925: LD_VAR 0 2
71929: PPUSH
71930: CALL_OW 480
71934: ST_TO_ADDR
// if not tmp then
71935: LD_VAR 0 5
71939: NOT
71940: IFFALSE 71944
// exit ;
71942: GO 71993
// for i in tmp do
71944: LD_ADDR_VAR 0 4
71948: PUSH
71949: LD_VAR 0 5
71953: PUSH
71954: FOR_IN
71955: IFFALSE 71991
// if GetTech ( i , side ) <> state_researched then
71957: LD_VAR 0 4
71961: PPUSH
71962: LD_VAR 0 1
71966: PPUSH
71967: CALL_OW 321
71971: PUSH
71972: LD_INT 2
71974: NONEQUAL
71975: IFFALSE 71989
// begin result := false ;
71977: LD_ADDR_VAR 0 3
71981: PUSH
71982: LD_INT 0
71984: ST_TO_ADDR
// exit ;
71985: POP
71986: POP
71987: GO 71993
// end ;
71989: GO 71954
71991: POP
71992: POP
// end ;
71993: LD_VAR 0 3
71997: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71998: LD_INT 0
72000: PPUSH
72001: PPUSH
72002: PPUSH
72003: PPUSH
72004: PPUSH
72005: PPUSH
72006: PPUSH
72007: PPUSH
72008: PPUSH
72009: PPUSH
72010: PPUSH
72011: PPUSH
72012: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
72013: LD_VAR 0 1
72017: NOT
72018: IFTRUE 72035
72020: PUSH
72021: LD_VAR 0 1
72025: PPUSH
72026: CALL_OW 257
72030: PUSH
72031: LD_INT 9
72033: NONEQUAL
72034: OR
72035: IFFALSE 72039
// exit ;
72037: GO 72618
// side := GetSide ( unit ) ;
72039: LD_ADDR_VAR 0 9
72043: PUSH
72044: LD_VAR 0 1
72048: PPUSH
72049: CALL_OW 255
72053: ST_TO_ADDR
// tech_space := tech_spacanom ;
72054: LD_ADDR_VAR 0 12
72058: PUSH
72059: LD_INT 29
72061: ST_TO_ADDR
// tech_time := tech_taurad ;
72062: LD_ADDR_VAR 0 13
72066: PUSH
72067: LD_INT 28
72069: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
72070: LD_ADDR_VAR 0 11
72074: PUSH
72075: LD_VAR 0 1
72079: PPUSH
72080: CALL_OW 310
72084: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
72085: LD_VAR 0 11
72089: PPUSH
72090: CALL_OW 247
72094: PUSH
72095: LD_INT 2
72097: EQUAL
72098: IFFALSE 72102
// exit ;
72100: GO 72618
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72102: LD_ADDR_VAR 0 8
72106: PUSH
72107: LD_INT 81
72109: PUSH
72110: LD_VAR 0 9
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 3
72121: PUSH
72122: LD_INT 21
72124: PUSH
72125: LD_INT 3
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PPUSH
72140: CALL_OW 69
72144: ST_TO_ADDR
// if not tmp then
72145: LD_VAR 0 8
72149: NOT
72150: IFFALSE 72154
// exit ;
72152: GO 72618
// if in_unit then
72154: LD_VAR 0 11
72158: IFFALSE 72182
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
72160: LD_ADDR_VAR 0 10
72164: PUSH
72165: LD_VAR 0 8
72169: PPUSH
72170: LD_VAR 0 11
72174: PPUSH
72175: CALL_OW 74
72179: ST_TO_ADDR
72180: GO 72202
// enemy := NearestUnitToUnit ( tmp , unit ) ;
72182: LD_ADDR_VAR 0 10
72186: PUSH
72187: LD_VAR 0 8
72191: PPUSH
72192: LD_VAR 0 1
72196: PPUSH
72197: CALL_OW 74
72201: ST_TO_ADDR
// if not enemy then
72202: LD_VAR 0 10
72206: NOT
72207: IFFALSE 72211
// exit ;
72209: GO 72618
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
72211: LD_VAR 0 11
72215: IFFALSE 72237
72217: PUSH
72218: LD_VAR 0 11
72222: PPUSH
72223: LD_VAR 0 10
72227: PPUSH
72228: CALL_OW 296
72232: PUSH
72233: LD_INT 13
72235: GREATER
72236: AND
72237: IFTRUE 72259
72239: PUSH
72240: LD_VAR 0 1
72244: PPUSH
72245: LD_VAR 0 10
72249: PPUSH
72250: CALL_OW 296
72254: PUSH
72255: LD_INT 12
72257: GREATER
72258: OR
72259: IFFALSE 72263
// exit ;
72261: GO 72618
// missile := [ 1 ] ;
72263: LD_ADDR_VAR 0 14
72267: PUSH
72268: LD_INT 1
72270: PUSH
72271: EMPTY
72272: LIST
72273: ST_TO_ADDR
// if Researched ( side , tech_space ) then
72274: LD_VAR 0 9
72278: PPUSH
72279: LD_VAR 0 12
72283: PPUSH
72284: CALL_OW 325
72288: IFFALSE 72317
// missile := Replace ( missile , missile + 1 , 2 ) ;
72290: LD_ADDR_VAR 0 14
72294: PUSH
72295: LD_VAR 0 14
72299: PPUSH
72300: LD_VAR 0 14
72304: PUSH
72305: LD_INT 1
72307: PLUS
72308: PPUSH
72309: LD_INT 2
72311: PPUSH
72312: CALL_OW 1
72316: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
72317: LD_VAR 0 9
72321: PPUSH
72322: LD_VAR 0 13
72326: PPUSH
72327: CALL_OW 325
72331: IFFALSE 72355
72333: PUSH
72334: LD_VAR 0 10
72338: PPUSH
72339: CALL_OW 255
72343: PPUSH
72344: LD_VAR 0 13
72348: PPUSH
72349: CALL_OW 325
72353: NOT
72354: AND
72355: IFFALSE 72384
// missile := Replace ( missile , missile + 1 , 3 ) ;
72357: LD_ADDR_VAR 0 14
72361: PUSH
72362: LD_VAR 0 14
72366: PPUSH
72367: LD_VAR 0 14
72371: PUSH
72372: LD_INT 1
72374: PLUS
72375: PPUSH
72376: LD_INT 3
72378: PPUSH
72379: CALL_OW 1
72383: ST_TO_ADDR
// if missile < 2 then
72384: LD_VAR 0 14
72388: PUSH
72389: LD_INT 2
72391: LESS
72392: IFFALSE 72396
// exit ;
72394: GO 72618
// x := GetX ( enemy ) ;
72396: LD_ADDR_VAR 0 4
72400: PUSH
72401: LD_VAR 0 10
72405: PPUSH
72406: CALL_OW 250
72410: ST_TO_ADDR
// y := GetY ( enemy ) ;
72411: LD_ADDR_VAR 0 5
72415: PUSH
72416: LD_VAR 0 10
72420: PPUSH
72421: CALL_OW 251
72425: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
72426: LD_ADDR_VAR 0 6
72430: PUSH
72431: LD_VAR 0 4
72435: PUSH
72436: LD_INT 1
72438: NEG
72439: PPUSH
72440: LD_INT 1
72442: PPUSH
72443: CALL_OW 12
72447: PLUS
72448: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
72449: LD_ADDR_VAR 0 7
72453: PUSH
72454: LD_VAR 0 5
72458: PUSH
72459: LD_INT 1
72461: NEG
72462: PPUSH
72463: LD_INT 1
72465: PPUSH
72466: CALL_OW 12
72470: PLUS
72471: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72472: LD_VAR 0 6
72476: PPUSH
72477: LD_VAR 0 7
72481: PPUSH
72482: CALL_OW 488
72486: NOT
72487: IFFALSE 72509
// begin _x := x ;
72489: LD_ADDR_VAR 0 6
72493: PUSH
72494: LD_VAR 0 4
72498: ST_TO_ADDR
// _y := y ;
72499: LD_ADDR_VAR 0 7
72503: PUSH
72504: LD_VAR 0 5
72508: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
72509: LD_ADDR_VAR 0 3
72513: PUSH
72514: LD_INT 1
72516: PPUSH
72517: LD_VAR 0 14
72521: PPUSH
72522: CALL_OW 12
72526: ST_TO_ADDR
// case i of 1 :
72527: LD_VAR 0 3
72531: PUSH
72532: LD_INT 1
72534: DOUBLE
72535: EQUAL
72536: IFTRUE 72540
72538: GO 72557
72540: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
72541: LD_VAR 0 1
72545: PPUSH
72546: LD_VAR 0 10
72550: PPUSH
72551: CALL_OW 115
72555: GO 72618
72557: LD_INT 2
72559: DOUBLE
72560: EQUAL
72561: IFTRUE 72565
72563: GO 72587
72565: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
72566: LD_VAR 0 1
72570: PPUSH
72571: LD_VAR 0 6
72575: PPUSH
72576: LD_VAR 0 7
72580: PPUSH
72581: CALL_OW 153
72585: GO 72618
72587: LD_INT 3
72589: DOUBLE
72590: EQUAL
72591: IFTRUE 72595
72593: GO 72617
72595: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
72596: LD_VAR 0 1
72600: PPUSH
72601: LD_VAR 0 6
72605: PPUSH
72606: LD_VAR 0 7
72610: PPUSH
72611: CALL_OW 154
72615: GO 72618
72617: POP
// end ;
72618: LD_VAR 0 2
72622: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
72623: LD_INT 0
72625: PPUSH
72626: PPUSH
72627: PPUSH
72628: PPUSH
72629: PPUSH
72630: PPUSH
// if not unit or not building then
72631: LD_VAR 0 1
72635: NOT
72636: IFTRUE 72645
72638: PUSH
72639: LD_VAR 0 2
72643: NOT
72644: OR
72645: IFFALSE 72649
// exit ;
72647: GO 72807
// x := GetX ( building ) ;
72649: LD_ADDR_VAR 0 5
72653: PUSH
72654: LD_VAR 0 2
72658: PPUSH
72659: CALL_OW 250
72663: ST_TO_ADDR
// y := GetY ( building ) ;
72664: LD_ADDR_VAR 0 6
72668: PUSH
72669: LD_VAR 0 2
72673: PPUSH
72674: CALL_OW 251
72678: ST_TO_ADDR
// for i := 0 to 5 do
72679: LD_ADDR_VAR 0 4
72683: PUSH
72684: DOUBLE
72685: LD_INT 0
72687: DEC
72688: ST_TO_ADDR
72689: LD_INT 5
72691: PUSH
72692: FOR_TO
72693: IFFALSE 72805
// begin _x := ShiftX ( x , i , 3 ) ;
72695: LD_ADDR_VAR 0 7
72699: PUSH
72700: LD_VAR 0 5
72704: PPUSH
72705: LD_VAR 0 4
72709: PPUSH
72710: LD_INT 3
72712: PPUSH
72713: CALL_OW 272
72717: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
72718: LD_ADDR_VAR 0 8
72722: PUSH
72723: LD_VAR 0 6
72727: PPUSH
72728: LD_VAR 0 4
72732: PPUSH
72733: LD_INT 3
72735: PPUSH
72736: CALL_OW 273
72740: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72741: LD_VAR 0 7
72745: PPUSH
72746: LD_VAR 0 8
72750: PPUSH
72751: CALL_OW 488
72755: NOT
72756: IFFALSE 72760
// continue ;
72758: GO 72692
// if HexInfo ( _x , _y ) = 0 then
72760: LD_VAR 0 7
72764: PPUSH
72765: LD_VAR 0 8
72769: PPUSH
72770: CALL_OW 428
72774: PUSH
72775: LD_INT 0
72777: EQUAL
72778: IFFALSE 72803
// begin ComMoveXY ( unit , _x , _y ) ;
72780: LD_VAR 0 1
72784: PPUSH
72785: LD_VAR 0 7
72789: PPUSH
72790: LD_VAR 0 8
72794: PPUSH
72795: CALL_OW 111
// exit ;
72799: POP
72800: POP
72801: GO 72807
// end ; end ;
72803: GO 72692
72805: POP
72806: POP
// end ;
72807: LD_VAR 0 3
72811: RET
// export function ScanBase ( side , base_area ) ; begin
72812: LD_INT 0
72814: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72815: LD_ADDR_VAR 0 3
72819: PUSH
72820: LD_VAR 0 2
72824: PPUSH
72825: LD_INT 81
72827: PUSH
72828: LD_VAR 0 1
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PPUSH
72837: CALL_OW 70
72841: ST_TO_ADDR
// end ;
72842: LD_VAR 0 3
72846: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72847: LD_INT 0
72849: PPUSH
72850: PPUSH
72851: PPUSH
72852: PPUSH
// result := false ;
72853: LD_ADDR_VAR 0 2
72857: PUSH
72858: LD_INT 0
72860: ST_TO_ADDR
// side := GetSide ( unit ) ;
72861: LD_ADDR_VAR 0 3
72865: PUSH
72866: LD_VAR 0 1
72870: PPUSH
72871: CALL_OW 255
72875: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72876: LD_ADDR_VAR 0 4
72880: PUSH
72881: LD_VAR 0 1
72885: PPUSH
72886: CALL_OW 248
72890: ST_TO_ADDR
// case nat of 1 :
72891: LD_VAR 0 4
72895: PUSH
72896: LD_INT 1
72898: DOUBLE
72899: EQUAL
72900: IFTRUE 72904
72902: GO 72915
72904: POP
// tech := tech_lassight ; 2 :
72905: LD_ADDR_VAR 0 5
72909: PUSH
72910: LD_INT 12
72912: ST_TO_ADDR
72913: GO 72954
72915: LD_INT 2
72917: DOUBLE
72918: EQUAL
72919: IFTRUE 72923
72921: GO 72934
72923: POP
// tech := tech_mortar ; 3 :
72924: LD_ADDR_VAR 0 5
72928: PUSH
72929: LD_INT 41
72931: ST_TO_ADDR
72932: GO 72954
72934: LD_INT 3
72936: DOUBLE
72937: EQUAL
72938: IFTRUE 72942
72940: GO 72953
72942: POP
// tech := tech_bazooka ; end ;
72943: LD_ADDR_VAR 0 5
72947: PUSH
72948: LD_INT 44
72950: ST_TO_ADDR
72951: GO 72954
72953: POP
// if Researched ( side , tech ) then
72954: LD_VAR 0 3
72958: PPUSH
72959: LD_VAR 0 5
72963: PPUSH
72964: CALL_OW 325
72968: IFFALSE 72995
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72970: LD_ADDR_VAR 0 2
72974: PUSH
72975: LD_INT 5
72977: PUSH
72978: LD_INT 8
72980: PUSH
72981: LD_INT 9
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: LIST
72988: PUSH
72989: LD_VAR 0 4
72993: ARRAY
72994: ST_TO_ADDR
// end ;
72995: LD_VAR 0 2
72999: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
73000: LD_INT 0
73002: PPUSH
73003: PPUSH
73004: PPUSH
// if not mines then
73005: LD_VAR 0 2
73009: NOT
73010: IFFALSE 73014
// exit ;
73012: GO 73158
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73014: LD_ADDR_VAR 0 5
73018: PUSH
73019: LD_INT 81
73021: PUSH
73022: LD_VAR 0 1
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 3
73033: PUSH
73034: LD_INT 21
73036: PUSH
73037: LD_INT 3
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PPUSH
73052: CALL_OW 69
73056: ST_TO_ADDR
// for i in mines do
73057: LD_ADDR_VAR 0 4
73061: PUSH
73062: LD_VAR 0 2
73066: PUSH
73067: FOR_IN
73068: IFFALSE 73156
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
73070: LD_VAR 0 4
73074: PUSH
73075: LD_INT 1
73077: ARRAY
73078: PPUSH
73079: LD_VAR 0 4
73083: PUSH
73084: LD_INT 2
73086: ARRAY
73087: PPUSH
73088: CALL_OW 458
73092: NOT
73093: IFFALSE 73097
// continue ;
73095: GO 73067
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
73097: LD_VAR 0 4
73101: PUSH
73102: LD_INT 1
73104: ARRAY
73105: PPUSH
73106: LD_VAR 0 4
73110: PUSH
73111: LD_INT 2
73113: ARRAY
73114: PPUSH
73115: CALL_OW 428
73119: PUSH
73120: LD_VAR 0 5
73124: IN
73125: IFFALSE 73154
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
73127: LD_VAR 0 4
73131: PUSH
73132: LD_INT 1
73134: ARRAY
73135: PPUSH
73136: LD_VAR 0 4
73140: PUSH
73141: LD_INT 2
73143: ARRAY
73144: PPUSH
73145: LD_VAR 0 1
73149: PPUSH
73150: CALL_OW 456
// end ;
73154: GO 73067
73156: POP
73157: POP
// end ;
73158: LD_VAR 0 3
73162: RET
// export function Count ( array ) ; begin
73163: LD_INT 0
73165: PPUSH
// result := array + 0 ;
73166: LD_ADDR_VAR 0 2
73170: PUSH
73171: LD_VAR 0 1
73175: PUSH
73176: LD_INT 0
73178: PLUS
73179: ST_TO_ADDR
// end ;
73180: LD_VAR 0 2
73184: RET
// export function IsEmpty ( building ) ; begin
73185: LD_INT 0
73187: PPUSH
// if not building then
73188: LD_VAR 0 1
73192: NOT
73193: IFFALSE 73197
// exit ;
73195: GO 73240
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
73197: LD_ADDR_VAR 0 2
73201: PUSH
73202: LD_VAR 0 1
73206: PUSH
73207: LD_INT 22
73209: PUSH
73210: LD_VAR 0 1
73214: PPUSH
73215: CALL_OW 255
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 58
73226: PUSH
73227: EMPTY
73228: LIST
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PPUSH
73234: CALL_OW 69
73238: IN
73239: ST_TO_ADDR
// end ;
73240: LD_VAR 0 2
73244: RET
// export function IsNotFull ( building ) ; var places ; begin
73245: LD_INT 0
73247: PPUSH
73248: PPUSH
// if not building then
73249: LD_VAR 0 1
73253: NOT
73254: IFFALSE 73258
// exit ;
73256: GO 73286
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
73258: LD_ADDR_VAR 0 2
73262: PUSH
73263: LD_VAR 0 1
73267: PPUSH
73268: LD_INT 3
73270: PUSH
73271: LD_INT 62
73273: PUSH
73274: EMPTY
73275: LIST
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 72
73285: ST_TO_ADDR
// end ;
73286: LD_VAR 0 2
73290: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
73291: LD_INT 0
73293: PPUSH
73294: PPUSH
73295: PPUSH
73296: PPUSH
// tmp := [ ] ;
73297: LD_ADDR_VAR 0 3
73301: PUSH
73302: EMPTY
73303: ST_TO_ADDR
// list := [ ] ;
73304: LD_ADDR_VAR 0 5
73308: PUSH
73309: EMPTY
73310: ST_TO_ADDR
// for i = 16 to 25 do
73311: LD_ADDR_VAR 0 4
73315: PUSH
73316: DOUBLE
73317: LD_INT 16
73319: DEC
73320: ST_TO_ADDR
73321: LD_INT 25
73323: PUSH
73324: FOR_TO
73325: IFFALSE 73398
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
73327: LD_ADDR_VAR 0 3
73331: PUSH
73332: LD_VAR 0 3
73336: PUSH
73337: LD_INT 22
73339: PUSH
73340: LD_VAR 0 1
73344: PPUSH
73345: CALL_OW 255
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 91
73356: PUSH
73357: LD_VAR 0 1
73361: PUSH
73362: LD_INT 6
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 30
73372: PUSH
73373: LD_VAR 0 4
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: LIST
73386: PUSH
73387: EMPTY
73388: LIST
73389: PPUSH
73390: CALL_OW 69
73394: ADD
73395: ST_TO_ADDR
73396: GO 73324
73398: POP
73399: POP
// for i = 1 to tmp do
73400: LD_ADDR_VAR 0 4
73404: PUSH
73405: DOUBLE
73406: LD_INT 1
73408: DEC
73409: ST_TO_ADDR
73410: LD_VAR 0 3
73414: PUSH
73415: FOR_TO
73416: IFFALSE 73504
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
73418: LD_ADDR_VAR 0 5
73422: PUSH
73423: LD_VAR 0 5
73427: PUSH
73428: LD_VAR 0 3
73432: PUSH
73433: LD_VAR 0 4
73437: ARRAY
73438: PPUSH
73439: CALL_OW 266
73443: PUSH
73444: LD_VAR 0 3
73448: PUSH
73449: LD_VAR 0 4
73453: ARRAY
73454: PPUSH
73455: CALL_OW 250
73459: PUSH
73460: LD_VAR 0 3
73464: PUSH
73465: LD_VAR 0 4
73469: ARRAY
73470: PPUSH
73471: CALL_OW 251
73475: PUSH
73476: LD_VAR 0 3
73480: PUSH
73481: LD_VAR 0 4
73485: ARRAY
73486: PPUSH
73487: CALL_OW 254
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: ADD
73501: ST_TO_ADDR
73502: GO 73415
73504: POP
73505: POP
// result := list ;
73506: LD_ADDR_VAR 0 2
73510: PUSH
73511: LD_VAR 0 5
73515: ST_TO_ADDR
// end ;
73516: LD_VAR 0 2
73520: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
73521: LD_INT 0
73523: PPUSH
73524: PPUSH
73525: PPUSH
73526: PPUSH
73527: PPUSH
73528: PPUSH
73529: PPUSH
// if not factory then
73530: LD_VAR 0 1
73534: NOT
73535: IFFALSE 73539
// exit ;
73537: GO 74142
// if control = control_apeman then
73539: LD_VAR 0 4
73543: PUSH
73544: LD_INT 5
73546: EQUAL
73547: IFFALSE 73656
// begin tmp := UnitsInside ( factory ) ;
73549: LD_ADDR_VAR 0 8
73553: PUSH
73554: LD_VAR 0 1
73558: PPUSH
73559: CALL_OW 313
73563: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
73564: LD_VAR 0 8
73568: PPUSH
73569: LD_INT 25
73571: PUSH
73572: LD_INT 12
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PPUSH
73579: CALL_OW 72
73583: NOT
73584: IFFALSE 73594
// control := control_manual ;
73586: LD_ADDR_VAR 0 4
73590: PUSH
73591: LD_INT 1
73593: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
73594: LD_ADDR_VAR 0 8
73598: PUSH
73599: LD_VAR 0 1
73603: PPUSH
73604: CALL 73291 0 1
73608: ST_TO_ADDR
// if tmp then
73609: LD_VAR 0 8
73613: IFFALSE 73656
// begin for i in tmp do
73615: LD_ADDR_VAR 0 7
73619: PUSH
73620: LD_VAR 0 8
73624: PUSH
73625: FOR_IN
73626: IFFALSE 73654
// if i [ 1 ] = b_ext_radio then
73628: LD_VAR 0 7
73632: PUSH
73633: LD_INT 1
73635: ARRAY
73636: PUSH
73637: LD_INT 22
73639: EQUAL
73640: IFFALSE 73652
// begin control := control_remote ;
73642: LD_ADDR_VAR 0 4
73646: PUSH
73647: LD_INT 2
73649: ST_TO_ADDR
// break ;
73650: GO 73654
// end ;
73652: GO 73625
73654: POP
73655: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73656: LD_VAR 0 1
73660: PPUSH
73661: LD_VAR 0 2
73665: PPUSH
73666: LD_VAR 0 3
73670: PPUSH
73671: LD_VAR 0 4
73675: PPUSH
73676: LD_VAR 0 5
73680: PPUSH
73681: CALL_OW 448
73685: IFFALSE 73720
// begin result := [ chassis , engine , control , weapon ] ;
73687: LD_ADDR_VAR 0 6
73691: PUSH
73692: LD_VAR 0 2
73696: PUSH
73697: LD_VAR 0 3
73701: PUSH
73702: LD_VAR 0 4
73706: PUSH
73707: LD_VAR 0 5
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: ST_TO_ADDR
// exit ;
73718: GO 74142
// end ; _chassis := AvailableChassisList ( factory ) ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_VAR 0 1
73729: PPUSH
73730: CALL_OW 475
73734: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
73735: LD_ADDR_VAR 0 11
73739: PUSH
73740: LD_VAR 0 1
73744: PPUSH
73745: CALL_OW 476
73749: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
73750: LD_ADDR_VAR 0 12
73754: PUSH
73755: LD_VAR 0 1
73759: PPUSH
73760: CALL_OW 477
73764: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
73765: LD_ADDR_VAR 0 10
73769: PUSH
73770: LD_VAR 0 1
73774: PPUSH
73775: CALL_OW 478
73779: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73780: LD_VAR 0 9
73784: NOT
73785: IFTRUE 73794
73787: PUSH
73788: LD_VAR 0 11
73792: NOT
73793: OR
73794: IFTRUE 73803
73796: PUSH
73797: LD_VAR 0 12
73801: NOT
73802: OR
73803: IFTRUE 73812
73805: PUSH
73806: LD_VAR 0 10
73810: NOT
73811: OR
73812: IFFALSE 73847
// begin result := [ chassis , engine , control , weapon ] ;
73814: LD_ADDR_VAR 0 6
73818: PUSH
73819: LD_VAR 0 2
73823: PUSH
73824: LD_VAR 0 3
73828: PUSH
73829: LD_VAR 0 4
73833: PUSH
73834: LD_VAR 0 5
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// exit ;
73845: GO 74142
// end ; if not chassis in _chassis then
73847: LD_VAR 0 2
73851: PUSH
73852: LD_VAR 0 9
73856: IN
73857: NOT
73858: IFFALSE 73884
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73860: LD_ADDR_VAR 0 2
73864: PUSH
73865: LD_VAR 0 9
73869: PUSH
73870: LD_INT 1
73872: PPUSH
73873: LD_VAR 0 9
73877: PPUSH
73878: CALL_OW 12
73882: ARRAY
73883: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73884: LD_VAR 0 2
73888: PPUSH
73889: LD_VAR 0 3
73893: PPUSH
73894: CALL 74147 0 2
73898: NOT
73899: IFFALSE 73960
// repeat engine := _engine [ 1 ] ;
73901: LD_ADDR_VAR 0 3
73905: PUSH
73906: LD_VAR 0 11
73910: PUSH
73911: LD_INT 1
73913: ARRAY
73914: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73915: LD_ADDR_VAR 0 11
73919: PUSH
73920: LD_VAR 0 11
73924: PPUSH
73925: LD_INT 1
73927: PPUSH
73928: CALL_OW 3
73932: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73933: LD_VAR 0 2
73937: PPUSH
73938: LD_VAR 0 3
73942: PPUSH
73943: CALL 74147 0 2
73947: IFTRUE 73958
73949: PUSH
73950: LD_VAR 0 11
73954: PUSH
73955: EMPTY
73956: EQUAL
73957: OR
73958: IFFALSE 73901
// if not control in _control then
73960: LD_VAR 0 4
73964: PUSH
73965: LD_VAR 0 12
73969: IN
73970: NOT
73971: IFFALSE 73997
// control := _control [ rand ( 1 , _control ) ] ;
73973: LD_ADDR_VAR 0 4
73977: PUSH
73978: LD_VAR 0 12
73982: PUSH
73983: LD_INT 1
73985: PPUSH
73986: LD_VAR 0 12
73990: PPUSH
73991: CALL_OW 12
73995: ARRAY
73996: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73997: LD_VAR 0 2
74001: PPUSH
74002: LD_VAR 0 5
74006: PPUSH
74007: CALL 74369 0 2
74011: NOT
74012: IFFALSE 74073
// repeat weapon := _weapon [ 1 ] ;
74014: LD_ADDR_VAR 0 5
74018: PUSH
74019: LD_VAR 0 10
74023: PUSH
74024: LD_INT 1
74026: ARRAY
74027: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
74028: LD_ADDR_VAR 0 10
74032: PUSH
74033: LD_VAR 0 10
74037: PPUSH
74038: LD_INT 1
74040: PPUSH
74041: CALL_OW 3
74045: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
74046: LD_VAR 0 2
74050: PPUSH
74051: LD_VAR 0 5
74055: PPUSH
74056: CALL 74369 0 2
74060: IFTRUE 74071
74062: PUSH
74063: LD_VAR 0 10
74067: PUSH
74068: EMPTY
74069: EQUAL
74070: OR
74071: IFFALSE 74014
// result := [ ] ;
74073: LD_ADDR_VAR 0 6
74077: PUSH
74078: EMPTY
74079: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
74080: LD_VAR 0 1
74084: PPUSH
74085: LD_VAR 0 2
74089: PPUSH
74090: LD_VAR 0 3
74094: PPUSH
74095: LD_VAR 0 4
74099: PPUSH
74100: LD_VAR 0 5
74104: PPUSH
74105: CALL_OW 448
74109: IFFALSE 74142
// result := [ chassis , engine , control , weapon ] ;
74111: LD_ADDR_VAR 0 6
74115: PUSH
74116: LD_VAR 0 2
74120: PUSH
74121: LD_VAR 0 3
74125: PUSH
74126: LD_VAR 0 4
74130: PUSH
74131: LD_VAR 0 5
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: ST_TO_ADDR
// end ;
74142: LD_VAR 0 6
74146: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
74147: LD_INT 0
74149: PPUSH
// if not chassis or not engine then
74150: LD_VAR 0 1
74154: NOT
74155: IFTRUE 74164
74157: PUSH
74158: LD_VAR 0 2
74162: NOT
74163: OR
74164: IFFALSE 74168
// exit ;
74166: GO 74364
// case engine of engine_solar :
74168: LD_VAR 0 2
74172: PUSH
74173: LD_INT 2
74175: DOUBLE
74176: EQUAL
74177: IFTRUE 74181
74179: GO 74219
74181: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
74182: LD_ADDR_VAR 0 3
74186: PUSH
74187: LD_INT 11
74189: PUSH
74190: LD_INT 12
74192: PUSH
74193: LD_INT 13
74195: PUSH
74196: LD_INT 14
74198: PUSH
74199: LD_INT 1
74201: PUSH
74202: LD_INT 2
74204: PUSH
74205: LD_INT 3
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: ST_TO_ADDR
74217: GO 74348
74219: LD_INT 1
74221: DOUBLE
74222: EQUAL
74223: IFTRUE 74227
74225: GO 74289
74227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
74228: LD_ADDR_VAR 0 3
74232: PUSH
74233: LD_INT 11
74235: PUSH
74236: LD_INT 12
74238: PUSH
74239: LD_INT 13
74241: PUSH
74242: LD_INT 14
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: LD_INT 2
74250: PUSH
74251: LD_INT 3
74253: PUSH
74254: LD_INT 4
74256: PUSH
74257: LD_INT 5
74259: PUSH
74260: LD_INT 21
74262: PUSH
74263: LD_INT 23
74265: PUSH
74266: LD_INT 22
74268: PUSH
74269: LD_INT 24
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: ST_TO_ADDR
74287: GO 74348
74289: LD_INT 3
74291: DOUBLE
74292: EQUAL
74293: IFTRUE 74297
74295: GO 74347
74297: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74298: LD_ADDR_VAR 0 3
74302: PUSH
74303: LD_INT 13
74305: PUSH
74306: LD_INT 14
74308: PUSH
74309: LD_INT 2
74311: PUSH
74312: LD_INT 3
74314: PUSH
74315: LD_INT 4
74317: PUSH
74318: LD_INT 5
74320: PUSH
74321: LD_INT 21
74323: PUSH
74324: LD_INT 22
74326: PUSH
74327: LD_INT 23
74329: PUSH
74330: LD_INT 24
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: ST_TO_ADDR
74345: GO 74348
74347: POP
// result := ( chassis in result ) ;
74348: LD_ADDR_VAR 0 3
74352: PUSH
74353: LD_VAR 0 1
74357: PUSH
74358: LD_VAR 0 3
74362: IN
74363: ST_TO_ADDR
// end ;
74364: LD_VAR 0 3
74368: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
74369: LD_INT 0
74371: PPUSH
// if not chassis or not weapon then
74372: LD_VAR 0 1
74376: NOT
74377: IFTRUE 74386
74379: PUSH
74380: LD_VAR 0 2
74384: NOT
74385: OR
74386: IFFALSE 74390
// exit ;
74388: GO 75450
// case weapon of us_machine_gun :
74390: LD_VAR 0 2
74394: PUSH
74395: LD_INT 2
74397: DOUBLE
74398: EQUAL
74399: IFTRUE 74403
74401: GO 74433
74403: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
74404: LD_ADDR_VAR 0 3
74408: PUSH
74409: LD_INT 1
74411: PUSH
74412: LD_INT 2
74414: PUSH
74415: LD_INT 3
74417: PUSH
74418: LD_INT 4
74420: PUSH
74421: LD_INT 5
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: ST_TO_ADDR
74431: GO 75434
74433: LD_INT 3
74435: DOUBLE
74436: EQUAL
74437: IFTRUE 74441
74439: GO 74471
74441: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
74442: LD_ADDR_VAR 0 3
74446: PUSH
74447: LD_INT 1
74449: PUSH
74450: LD_INT 2
74452: PUSH
74453: LD_INT 3
74455: PUSH
74456: LD_INT 4
74458: PUSH
74459: LD_INT 5
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: ST_TO_ADDR
74469: GO 75434
74471: LD_INT 11
74473: DOUBLE
74474: EQUAL
74475: IFTRUE 74479
74477: GO 74509
74479: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
74480: LD_ADDR_VAR 0 3
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: LD_INT 2
74490: PUSH
74491: LD_INT 3
74493: PUSH
74494: LD_INT 4
74496: PUSH
74497: LD_INT 5
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: ST_TO_ADDR
74507: GO 75434
74509: LD_INT 4
74511: DOUBLE
74512: EQUAL
74513: IFTRUE 74517
74515: GO 74543
74517: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
74518: LD_ADDR_VAR 0 3
74522: PUSH
74523: LD_INT 2
74525: PUSH
74526: LD_INT 3
74528: PUSH
74529: LD_INT 4
74531: PUSH
74532: LD_INT 5
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: LIST
74539: LIST
74540: ST_TO_ADDR
74541: GO 75434
74543: LD_INT 5
74545: DOUBLE
74546: EQUAL
74547: IFTRUE 74551
74549: GO 74577
74551: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
74552: LD_ADDR_VAR 0 3
74556: PUSH
74557: LD_INT 2
74559: PUSH
74560: LD_INT 3
74562: PUSH
74563: LD_INT 4
74565: PUSH
74566: LD_INT 5
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: ST_TO_ADDR
74575: GO 75434
74577: LD_INT 9
74579: DOUBLE
74580: EQUAL
74581: IFTRUE 74585
74583: GO 74611
74585: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
74586: LD_ADDR_VAR 0 3
74590: PUSH
74591: LD_INT 2
74593: PUSH
74594: LD_INT 3
74596: PUSH
74597: LD_INT 4
74599: PUSH
74600: LD_INT 5
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: ST_TO_ADDR
74609: GO 75434
74611: LD_INT 7
74613: DOUBLE
74614: EQUAL
74615: IFTRUE 74619
74617: GO 74645
74619: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
74620: LD_ADDR_VAR 0 3
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: LD_INT 3
74630: PUSH
74631: LD_INT 4
74633: PUSH
74634: LD_INT 5
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: ST_TO_ADDR
74643: GO 75434
74645: LD_INT 12
74647: DOUBLE
74648: EQUAL
74649: IFTRUE 74653
74651: GO 74679
74653: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
74654: LD_ADDR_VAR 0 3
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: LD_INT 3
74664: PUSH
74665: LD_INT 4
74667: PUSH
74668: LD_INT 5
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: ST_TO_ADDR
74677: GO 75434
74679: LD_INT 13
74681: DOUBLE
74682: EQUAL
74683: IFTRUE 74687
74685: GO 74713
74687: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
74688: LD_ADDR_VAR 0 3
74692: PUSH
74693: LD_INT 2
74695: PUSH
74696: LD_INT 3
74698: PUSH
74699: LD_INT 4
74701: PUSH
74702: LD_INT 5
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: LIST
74709: LIST
74710: ST_TO_ADDR
74711: GO 75434
74713: LD_INT 14
74715: DOUBLE
74716: EQUAL
74717: IFTRUE 74721
74719: GO 74739
74721: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
74722: LD_ADDR_VAR 0 3
74726: PUSH
74727: LD_INT 4
74729: PUSH
74730: LD_INT 5
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: ST_TO_ADDR
74737: GO 75434
74739: LD_INT 6
74741: DOUBLE
74742: EQUAL
74743: IFTRUE 74747
74745: GO 74765
74747: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
74748: LD_ADDR_VAR 0 3
74752: PUSH
74753: LD_INT 4
74755: PUSH
74756: LD_INT 5
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: ST_TO_ADDR
74763: GO 75434
74765: LD_INT 10
74767: DOUBLE
74768: EQUAL
74769: IFTRUE 74773
74771: GO 74791
74773: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
74774: LD_ADDR_VAR 0 3
74778: PUSH
74779: LD_INT 4
74781: PUSH
74782: LD_INT 5
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: ST_TO_ADDR
74789: GO 75434
74791: LD_INT 22
74793: DOUBLE
74794: EQUAL
74795: IFTRUE 74799
74797: GO 74825
74799: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74800: LD_ADDR_VAR 0 3
74804: PUSH
74805: LD_INT 11
74807: PUSH
74808: LD_INT 12
74810: PUSH
74811: LD_INT 13
74813: PUSH
74814: LD_INT 14
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: LIST
74821: LIST
74822: ST_TO_ADDR
74823: GO 75434
74825: LD_INT 23
74827: DOUBLE
74828: EQUAL
74829: IFTRUE 74833
74831: GO 74859
74833: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74834: LD_ADDR_VAR 0 3
74838: PUSH
74839: LD_INT 11
74841: PUSH
74842: LD_INT 12
74844: PUSH
74845: LD_INT 13
74847: PUSH
74848: LD_INT 14
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: ST_TO_ADDR
74857: GO 75434
74859: LD_INT 24
74861: DOUBLE
74862: EQUAL
74863: IFTRUE 74867
74865: GO 74893
74867: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74868: LD_ADDR_VAR 0 3
74872: PUSH
74873: LD_INT 11
74875: PUSH
74876: LD_INT 12
74878: PUSH
74879: LD_INT 13
74881: PUSH
74882: LD_INT 14
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: LIST
74889: LIST
74890: ST_TO_ADDR
74891: GO 75434
74893: LD_INT 30
74895: DOUBLE
74896: EQUAL
74897: IFTRUE 74901
74899: GO 74927
74901: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74902: LD_ADDR_VAR 0 3
74906: PUSH
74907: LD_INT 11
74909: PUSH
74910: LD_INT 12
74912: PUSH
74913: LD_INT 13
74915: PUSH
74916: LD_INT 14
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: ST_TO_ADDR
74925: GO 75434
74927: LD_INT 25
74929: DOUBLE
74930: EQUAL
74931: IFTRUE 74935
74933: GO 74953
74935: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74936: LD_ADDR_VAR 0 3
74940: PUSH
74941: LD_INT 13
74943: PUSH
74944: LD_INT 14
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: ST_TO_ADDR
74951: GO 75434
74953: LD_INT 27
74955: DOUBLE
74956: EQUAL
74957: IFTRUE 74961
74959: GO 74979
74961: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74962: LD_ADDR_VAR 0 3
74966: PUSH
74967: LD_INT 13
74969: PUSH
74970: LD_INT 14
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: ST_TO_ADDR
74977: GO 75434
74979: LD_INT 92
74981: DOUBLE
74982: EQUAL
74983: IFTRUE 74987
74985: GO 75013
74987: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74988: LD_ADDR_VAR 0 3
74992: PUSH
74993: LD_INT 11
74995: PUSH
74996: LD_INT 12
74998: PUSH
74999: LD_INT 13
75001: PUSH
75002: LD_INT 14
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
75011: GO 75434
75013: LD_INT 28
75015: DOUBLE
75016: EQUAL
75017: IFTRUE 75021
75019: GO 75039
75021: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
75022: LD_ADDR_VAR 0 3
75026: PUSH
75027: LD_INT 13
75029: PUSH
75030: LD_INT 14
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: ST_TO_ADDR
75037: GO 75434
75039: LD_INT 29
75041: DOUBLE
75042: EQUAL
75043: IFTRUE 75047
75045: GO 75065
75047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
75048: LD_ADDR_VAR 0 3
75052: PUSH
75053: LD_INT 13
75055: PUSH
75056: LD_INT 14
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: ST_TO_ADDR
75063: GO 75434
75065: LD_INT 31
75067: DOUBLE
75068: EQUAL
75069: IFTRUE 75073
75071: GO 75091
75073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
75074: LD_ADDR_VAR 0 3
75078: PUSH
75079: LD_INT 13
75081: PUSH
75082: LD_INT 14
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: ST_TO_ADDR
75089: GO 75434
75091: LD_INT 26
75093: DOUBLE
75094: EQUAL
75095: IFTRUE 75099
75097: GO 75117
75099: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
75100: LD_ADDR_VAR 0 3
75104: PUSH
75105: LD_INT 13
75107: PUSH
75108: LD_INT 14
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: ST_TO_ADDR
75115: GO 75434
75117: LD_INT 42
75119: DOUBLE
75120: EQUAL
75121: IFTRUE 75125
75123: GO 75151
75125: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
75126: LD_ADDR_VAR 0 3
75130: PUSH
75131: LD_INT 21
75133: PUSH
75134: LD_INT 22
75136: PUSH
75137: LD_INT 23
75139: PUSH
75140: LD_INT 24
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: ST_TO_ADDR
75149: GO 75434
75151: LD_INT 43
75153: DOUBLE
75154: EQUAL
75155: IFTRUE 75159
75157: GO 75185
75159: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
75160: LD_ADDR_VAR 0 3
75164: PUSH
75165: LD_INT 21
75167: PUSH
75168: LD_INT 22
75170: PUSH
75171: LD_INT 23
75173: PUSH
75174: LD_INT 24
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: ST_TO_ADDR
75183: GO 75434
75185: LD_INT 44
75187: DOUBLE
75188: EQUAL
75189: IFTRUE 75193
75191: GO 75219
75193: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
75194: LD_ADDR_VAR 0 3
75198: PUSH
75199: LD_INT 21
75201: PUSH
75202: LD_INT 22
75204: PUSH
75205: LD_INT 23
75207: PUSH
75208: LD_INT 24
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: ST_TO_ADDR
75217: GO 75434
75219: LD_INT 45
75221: DOUBLE
75222: EQUAL
75223: IFTRUE 75227
75225: GO 75253
75227: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
75228: LD_ADDR_VAR 0 3
75232: PUSH
75233: LD_INT 21
75235: PUSH
75236: LD_INT 22
75238: PUSH
75239: LD_INT 23
75241: PUSH
75242: LD_INT 24
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: LIST
75249: LIST
75250: ST_TO_ADDR
75251: GO 75434
75253: LD_INT 49
75255: DOUBLE
75256: EQUAL
75257: IFTRUE 75261
75259: GO 75287
75261: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
75262: LD_ADDR_VAR 0 3
75266: PUSH
75267: LD_INT 21
75269: PUSH
75270: LD_INT 22
75272: PUSH
75273: LD_INT 23
75275: PUSH
75276: LD_INT 24
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: ST_TO_ADDR
75285: GO 75434
75287: LD_INT 51
75289: DOUBLE
75290: EQUAL
75291: IFTRUE 75295
75293: GO 75321
75295: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
75296: LD_ADDR_VAR 0 3
75300: PUSH
75301: LD_INT 21
75303: PUSH
75304: LD_INT 22
75306: PUSH
75307: LD_INT 23
75309: PUSH
75310: LD_INT 24
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: ST_TO_ADDR
75319: GO 75434
75321: LD_INT 52
75323: DOUBLE
75324: EQUAL
75325: IFTRUE 75329
75327: GO 75355
75329: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
75330: LD_ADDR_VAR 0 3
75334: PUSH
75335: LD_INT 21
75337: PUSH
75338: LD_INT 22
75340: PUSH
75341: LD_INT 23
75343: PUSH
75344: LD_INT 24
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: ST_TO_ADDR
75353: GO 75434
75355: LD_INT 53
75357: DOUBLE
75358: EQUAL
75359: IFTRUE 75363
75361: GO 75381
75363: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
75364: LD_ADDR_VAR 0 3
75368: PUSH
75369: LD_INT 23
75371: PUSH
75372: LD_INT 24
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: ST_TO_ADDR
75379: GO 75434
75381: LD_INT 46
75383: DOUBLE
75384: EQUAL
75385: IFTRUE 75389
75387: GO 75407
75389: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
75390: LD_ADDR_VAR 0 3
75394: PUSH
75395: LD_INT 23
75397: PUSH
75398: LD_INT 24
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: ST_TO_ADDR
75405: GO 75434
75407: LD_INT 47
75409: DOUBLE
75410: EQUAL
75411: IFTRUE 75415
75413: GO 75433
75415: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
75416: LD_ADDR_VAR 0 3
75420: PUSH
75421: LD_INT 23
75423: PUSH
75424: LD_INT 24
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: ST_TO_ADDR
75431: GO 75434
75433: POP
// result := ( chassis in result ) ;
75434: LD_ADDR_VAR 0 3
75438: PUSH
75439: LD_VAR 0 1
75443: PUSH
75444: LD_VAR 0 3
75448: IN
75449: ST_TO_ADDR
// end ;
75450: LD_VAR 0 3
75454: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
75455: LD_INT 0
75457: PPUSH
75458: PPUSH
75459: PPUSH
75460: PPUSH
75461: PPUSH
75462: PPUSH
75463: PPUSH
// result := array ;
75464: LD_ADDR_VAR 0 5
75468: PUSH
75469: LD_VAR 0 1
75473: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
75474: LD_VAR 0 1
75478: NOT
75479: IFTRUE 75488
75481: PUSH
75482: LD_VAR 0 2
75486: NOT
75487: OR
75488: IFTRUE 75497
75490: PUSH
75491: LD_VAR 0 3
75495: NOT
75496: OR
75497: IFTRUE 75511
75499: PUSH
75500: LD_VAR 0 2
75504: PUSH
75505: LD_VAR 0 1
75509: GREATER
75510: OR
75511: IFTRUE 75525
75513: PUSH
75514: LD_VAR 0 3
75518: PUSH
75519: LD_VAR 0 1
75523: GREATER
75524: OR
75525: IFFALSE 75529
// exit ;
75527: GO 75825
// if direction then
75529: LD_VAR 0 4
75533: IFFALSE 75597
// begin d := 1 ;
75535: LD_ADDR_VAR 0 9
75539: PUSH
75540: LD_INT 1
75542: ST_TO_ADDR
// if i_from > i_to then
75543: LD_VAR 0 2
75547: PUSH
75548: LD_VAR 0 3
75552: GREATER
75553: IFFALSE 75579
// length := ( array - i_from ) + i_to else
75555: LD_ADDR_VAR 0 11
75559: PUSH
75560: LD_VAR 0 1
75564: PUSH
75565: LD_VAR 0 2
75569: MINUS
75570: PUSH
75571: LD_VAR 0 3
75575: PLUS
75576: ST_TO_ADDR
75577: GO 75595
// length := i_to - i_from ;
75579: LD_ADDR_VAR 0 11
75583: PUSH
75584: LD_VAR 0 3
75588: PUSH
75589: LD_VAR 0 2
75593: MINUS
75594: ST_TO_ADDR
// end else
75595: GO 75658
// begin d := - 1 ;
75597: LD_ADDR_VAR 0 9
75601: PUSH
75602: LD_INT 1
75604: NEG
75605: ST_TO_ADDR
// if i_from > i_to then
75606: LD_VAR 0 2
75610: PUSH
75611: LD_VAR 0 3
75615: GREATER
75616: IFFALSE 75636
// length := i_from - i_to else
75618: LD_ADDR_VAR 0 11
75622: PUSH
75623: LD_VAR 0 2
75627: PUSH
75628: LD_VAR 0 3
75632: MINUS
75633: ST_TO_ADDR
75634: GO 75658
// length := ( array - i_to ) + i_from ;
75636: LD_ADDR_VAR 0 11
75640: PUSH
75641: LD_VAR 0 1
75645: PUSH
75646: LD_VAR 0 3
75650: MINUS
75651: PUSH
75652: LD_VAR 0 2
75656: PLUS
75657: ST_TO_ADDR
// end ; if not length then
75658: LD_VAR 0 11
75662: NOT
75663: IFFALSE 75667
// exit ;
75665: GO 75825
// tmp := array ;
75667: LD_ADDR_VAR 0 10
75671: PUSH
75672: LD_VAR 0 1
75676: ST_TO_ADDR
// for i = 1 to length do
75677: LD_ADDR_VAR 0 6
75681: PUSH
75682: DOUBLE
75683: LD_INT 1
75685: DEC
75686: ST_TO_ADDR
75687: LD_VAR 0 11
75691: PUSH
75692: FOR_TO
75693: IFFALSE 75813
// begin for j = 1 to array do
75695: LD_ADDR_VAR 0 7
75699: PUSH
75700: DOUBLE
75701: LD_INT 1
75703: DEC
75704: ST_TO_ADDR
75705: LD_VAR 0 1
75709: PUSH
75710: FOR_TO
75711: IFFALSE 75799
// begin k := j + d ;
75713: LD_ADDR_VAR 0 8
75717: PUSH
75718: LD_VAR 0 7
75722: PUSH
75723: LD_VAR 0 9
75727: PLUS
75728: ST_TO_ADDR
// if k > array then
75729: LD_VAR 0 8
75733: PUSH
75734: LD_VAR 0 1
75738: GREATER
75739: IFFALSE 75749
// k := 1 ;
75741: LD_ADDR_VAR 0 8
75745: PUSH
75746: LD_INT 1
75748: ST_TO_ADDR
// if not k then
75749: LD_VAR 0 8
75753: NOT
75754: IFFALSE 75766
// k := array ;
75756: LD_ADDR_VAR 0 8
75760: PUSH
75761: LD_VAR 0 1
75765: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
75766: LD_ADDR_VAR 0 10
75770: PUSH
75771: LD_VAR 0 10
75775: PPUSH
75776: LD_VAR 0 8
75780: PPUSH
75781: LD_VAR 0 1
75785: PUSH
75786: LD_VAR 0 7
75790: ARRAY
75791: PPUSH
75792: CALL_OW 1
75796: ST_TO_ADDR
// end ;
75797: GO 75710
75799: POP
75800: POP
// array := tmp ;
75801: LD_ADDR_VAR 0 1
75805: PUSH
75806: LD_VAR 0 10
75810: ST_TO_ADDR
// end ;
75811: GO 75692
75813: POP
75814: POP
// result := array ;
75815: LD_ADDR_VAR 0 5
75819: PUSH
75820: LD_VAR 0 1
75824: ST_TO_ADDR
// end ;
75825: LD_VAR 0 5
75829: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75830: LD_INT 0
75832: PPUSH
75833: PPUSH
// result := 0 ;
75834: LD_ADDR_VAR 0 3
75838: PUSH
75839: LD_INT 0
75841: ST_TO_ADDR
// if not array or not value in array then
75842: LD_VAR 0 1
75846: NOT
75847: IFTRUE 75862
75849: PUSH
75850: LD_VAR 0 2
75854: PUSH
75855: LD_VAR 0 1
75859: IN
75860: NOT
75861: OR
75862: IFFALSE 75866
// exit ;
75864: GO 75920
// for i = 1 to array do
75866: LD_ADDR_VAR 0 4
75870: PUSH
75871: DOUBLE
75872: LD_INT 1
75874: DEC
75875: ST_TO_ADDR
75876: LD_VAR 0 1
75880: PUSH
75881: FOR_TO
75882: IFFALSE 75918
// if value = array [ i ] then
75884: LD_VAR 0 2
75888: PUSH
75889: LD_VAR 0 1
75893: PUSH
75894: LD_VAR 0 4
75898: ARRAY
75899: EQUAL
75900: IFFALSE 75916
// begin result := i ;
75902: LD_ADDR_VAR 0 3
75906: PUSH
75907: LD_VAR 0 4
75911: ST_TO_ADDR
// exit ;
75912: POP
75913: POP
75914: GO 75920
// end ;
75916: GO 75881
75918: POP
75919: POP
// end ;
75920: LD_VAR 0 3
75924: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75925: LD_INT 0
75927: PPUSH
// vc_chassis := chassis ;
75928: LD_ADDR_OWVAR 37
75932: PUSH
75933: LD_VAR 0 1
75937: ST_TO_ADDR
// vc_engine := engine ;
75938: LD_ADDR_OWVAR 39
75942: PUSH
75943: LD_VAR 0 2
75947: ST_TO_ADDR
// vc_control := control ;
75948: LD_ADDR_OWVAR 38
75952: PUSH
75953: LD_VAR 0 3
75957: ST_TO_ADDR
// vc_weapon := weapon ;
75958: LD_ADDR_OWVAR 40
75962: PUSH
75963: LD_VAR 0 4
75967: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75968: LD_ADDR_OWVAR 41
75972: PUSH
75973: LD_VAR 0 5
75977: ST_TO_ADDR
// end ;
75978: LD_VAR 0 6
75982: RET
// export function WantPlant ( unit ) ; var task ; begin
75983: LD_INT 0
75985: PPUSH
75986: PPUSH
// result := false ;
75987: LD_ADDR_VAR 0 2
75991: PUSH
75992: LD_INT 0
75994: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75995: LD_ADDR_VAR 0 3
75999: PUSH
76000: LD_VAR 0 1
76004: PPUSH
76005: CALL_OW 437
76009: ST_TO_ADDR
// if task then
76010: LD_VAR 0 3
76014: IFFALSE 76042
// if task [ 1 ] [ 1 ] = p then
76016: LD_VAR 0 3
76020: PUSH
76021: LD_INT 1
76023: ARRAY
76024: PUSH
76025: LD_INT 1
76027: ARRAY
76028: PUSH
76029: LD_STRING p
76031: EQUAL
76032: IFFALSE 76042
// result := true ;
76034: LD_ADDR_VAR 0 2
76038: PUSH
76039: LD_INT 1
76041: ST_TO_ADDR
// end ;
76042: LD_VAR 0 2
76046: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
76047: LD_INT 0
76049: PPUSH
76050: PPUSH
76051: PPUSH
76052: PPUSH
// if pos < 1 then
76053: LD_VAR 0 2
76057: PUSH
76058: LD_INT 1
76060: LESS
76061: IFFALSE 76065
// exit ;
76063: GO 76368
// if pos = 1 then
76065: LD_VAR 0 2
76069: PUSH
76070: LD_INT 1
76072: EQUAL
76073: IFFALSE 76106
// result := Replace ( arr , pos [ 1 ] , value ) else
76075: LD_ADDR_VAR 0 4
76079: PUSH
76080: LD_VAR 0 1
76084: PPUSH
76085: LD_VAR 0 2
76089: PUSH
76090: LD_INT 1
76092: ARRAY
76093: PPUSH
76094: LD_VAR 0 3
76098: PPUSH
76099: CALL_OW 1
76103: ST_TO_ADDR
76104: GO 76368
// begin tmp := arr ;
76106: LD_ADDR_VAR 0 6
76110: PUSH
76111: LD_VAR 0 1
76115: ST_TO_ADDR
// s_arr := [ tmp ] ;
76116: LD_ADDR_VAR 0 7
76120: PUSH
76121: LD_VAR 0 6
76125: PUSH
76126: EMPTY
76127: LIST
76128: ST_TO_ADDR
// for i = 1 to pos - 1 do
76129: LD_ADDR_VAR 0 5
76133: PUSH
76134: DOUBLE
76135: LD_INT 1
76137: DEC
76138: ST_TO_ADDR
76139: LD_VAR 0 2
76143: PUSH
76144: LD_INT 1
76146: MINUS
76147: PUSH
76148: FOR_TO
76149: IFFALSE 76194
// begin tmp := tmp [ pos [ i ] ] ;
76151: LD_ADDR_VAR 0 6
76155: PUSH
76156: LD_VAR 0 6
76160: PUSH
76161: LD_VAR 0 2
76165: PUSH
76166: LD_VAR 0 5
76170: ARRAY
76171: ARRAY
76172: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
76173: LD_ADDR_VAR 0 7
76177: PUSH
76178: LD_VAR 0 7
76182: PUSH
76183: LD_VAR 0 6
76187: PUSH
76188: EMPTY
76189: LIST
76190: ADD
76191: ST_TO_ADDR
// end ;
76192: GO 76148
76194: POP
76195: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
76196: LD_ADDR_VAR 0 6
76200: PUSH
76201: LD_VAR 0 6
76205: PPUSH
76206: LD_VAR 0 2
76210: PUSH
76211: LD_VAR 0 2
76215: ARRAY
76216: PPUSH
76217: LD_VAR 0 3
76221: PPUSH
76222: CALL_OW 1
76226: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
76227: LD_ADDR_VAR 0 7
76231: PUSH
76232: LD_VAR 0 7
76236: PPUSH
76237: LD_VAR 0 7
76241: PPUSH
76242: LD_VAR 0 6
76246: PPUSH
76247: CALL_OW 1
76251: ST_TO_ADDR
// for i = s_arr downto 2 do
76252: LD_ADDR_VAR 0 5
76256: PUSH
76257: DOUBLE
76258: LD_VAR 0 7
76262: INC
76263: ST_TO_ADDR
76264: LD_INT 2
76266: PUSH
76267: FOR_DOWNTO
76268: IFFALSE 76352
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
76270: LD_ADDR_VAR 0 6
76274: PUSH
76275: LD_VAR 0 7
76279: PUSH
76280: LD_VAR 0 5
76284: PUSH
76285: LD_INT 1
76287: MINUS
76288: ARRAY
76289: PPUSH
76290: LD_VAR 0 2
76294: PUSH
76295: LD_VAR 0 5
76299: PUSH
76300: LD_INT 1
76302: MINUS
76303: ARRAY
76304: PPUSH
76305: LD_VAR 0 7
76309: PUSH
76310: LD_VAR 0 5
76314: ARRAY
76315: PPUSH
76316: CALL_OW 1
76320: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
76321: LD_ADDR_VAR 0 7
76325: PUSH
76326: LD_VAR 0 7
76330: PPUSH
76331: LD_VAR 0 5
76335: PUSH
76336: LD_INT 1
76338: MINUS
76339: PPUSH
76340: LD_VAR 0 6
76344: PPUSH
76345: CALL_OW 1
76349: ST_TO_ADDR
// end ;
76350: GO 76267
76352: POP
76353: POP
// result := s_arr [ 1 ] ;
76354: LD_ADDR_VAR 0 4
76358: PUSH
76359: LD_VAR 0 7
76363: PUSH
76364: LD_INT 1
76366: ARRAY
76367: ST_TO_ADDR
// end ; end ;
76368: LD_VAR 0 4
76372: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
76373: LD_INT 0
76375: PPUSH
76376: PPUSH
// if not list then
76377: LD_VAR 0 1
76381: NOT
76382: IFFALSE 76386
// exit ;
76384: GO 76477
// i := list [ pos1 ] ;
76386: LD_ADDR_VAR 0 5
76390: PUSH
76391: LD_VAR 0 1
76395: PUSH
76396: LD_VAR 0 2
76400: ARRAY
76401: ST_TO_ADDR
// if not i then
76402: LD_VAR 0 5
76406: NOT
76407: IFFALSE 76411
// exit ;
76409: GO 76477
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
76411: LD_ADDR_VAR 0 1
76415: PUSH
76416: LD_VAR 0 1
76420: PPUSH
76421: LD_VAR 0 2
76425: PPUSH
76426: LD_VAR 0 1
76430: PUSH
76431: LD_VAR 0 3
76435: ARRAY
76436: PPUSH
76437: CALL_OW 1
76441: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
76442: LD_ADDR_VAR 0 1
76446: PUSH
76447: LD_VAR 0 1
76451: PPUSH
76452: LD_VAR 0 3
76456: PPUSH
76457: LD_VAR 0 5
76461: PPUSH
76462: CALL_OW 1
76466: ST_TO_ADDR
// result := list ;
76467: LD_ADDR_VAR 0 4
76471: PUSH
76472: LD_VAR 0 1
76476: ST_TO_ADDR
// end ;
76477: LD_VAR 0 4
76481: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
76482: LD_INT 0
76484: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
76485: LD_ADDR_VAR 0 5
76489: PUSH
76490: LD_VAR 0 1
76494: PPUSH
76495: CALL_OW 250
76499: PPUSH
76500: LD_VAR 0 1
76504: PPUSH
76505: CALL_OW 251
76509: PPUSH
76510: LD_VAR 0 2
76514: PPUSH
76515: LD_VAR 0 3
76519: PPUSH
76520: LD_VAR 0 4
76524: PPUSH
76525: CALL 76907 0 5
76529: ST_TO_ADDR
// end ;
76530: LD_VAR 0 5
76534: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
76535: LD_INT 0
76537: PPUSH
76538: PPUSH
76539: PPUSH
76540: PPUSH
// if not list or not unit then
76541: LD_VAR 0 2
76545: NOT
76546: IFTRUE 76555
76548: PUSH
76549: LD_VAR 0 1
76553: NOT
76554: OR
76555: IFFALSE 76559
// exit ;
76557: GO 76902
// result := [ ] ;
76559: LD_ADDR_VAR 0 5
76563: PUSH
76564: EMPTY
76565: ST_TO_ADDR
// for i in list do
76566: LD_ADDR_VAR 0 6
76570: PUSH
76571: LD_VAR 0 2
76575: PUSH
76576: FOR_IN
76577: IFFALSE 76795
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
76579: LD_ADDR_VAR 0 8
76583: PUSH
76584: LD_VAR 0 1
76588: PPUSH
76589: LD_VAR 0 6
76593: PUSH
76594: LD_INT 1
76596: ARRAY
76597: PPUSH
76598: LD_VAR 0 6
76602: PUSH
76603: LD_INT 2
76605: ARRAY
76606: PPUSH
76607: CALL_OW 297
76611: ST_TO_ADDR
// if not Count ( result ) then
76612: LD_VAR 0 5
76616: PPUSH
76617: CALL 73163 0 1
76621: NOT
76622: IFFALSE 76655
// begin result := Join ( result , [ i , tmp ] ) ;
76624: LD_ADDR_VAR 0 5
76628: PUSH
76629: LD_VAR 0 5
76633: PPUSH
76634: LD_VAR 0 6
76638: PUSH
76639: LD_VAR 0 8
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PPUSH
76648: CALL 109095 0 2
76652: ST_TO_ADDR
// continue ;
76653: GO 76576
// end ; if result [ result ] [ 2 ] <= tmp then
76655: LD_VAR 0 5
76659: PUSH
76660: LD_VAR 0 5
76664: ARRAY
76665: PUSH
76666: LD_INT 2
76668: ARRAY
76669: PUSH
76670: LD_VAR 0 8
76674: LESSEQUAL
76675: IFFALSE 76708
// result := Join ( result , [ i , tmp ] ) else
76677: LD_ADDR_VAR 0 5
76681: PUSH
76682: LD_VAR 0 5
76686: PPUSH
76687: LD_VAR 0 6
76691: PUSH
76692: LD_VAR 0 8
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PPUSH
76701: CALL 109095 0 2
76705: ST_TO_ADDR
76706: GO 76793
// begin for j := 1 to Count ( result ) do
76708: LD_ADDR_VAR 0 7
76712: PUSH
76713: DOUBLE
76714: LD_INT 1
76716: DEC
76717: ST_TO_ADDR
76718: LD_VAR 0 5
76722: PPUSH
76723: CALL 73163 0 1
76727: PUSH
76728: FOR_TO
76729: IFFALSE 76791
// begin if tmp < result [ j ] [ 2 ] then
76731: LD_VAR 0 8
76735: PUSH
76736: LD_VAR 0 5
76740: PUSH
76741: LD_VAR 0 7
76745: ARRAY
76746: PUSH
76747: LD_INT 2
76749: ARRAY
76750: LESS
76751: IFFALSE 76789
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76753: LD_ADDR_VAR 0 5
76757: PUSH
76758: LD_VAR 0 5
76762: PPUSH
76763: LD_VAR 0 7
76767: PPUSH
76768: LD_VAR 0 6
76772: PUSH
76773: LD_VAR 0 8
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PPUSH
76782: CALL_OW 2
76786: ST_TO_ADDR
// break ;
76787: GO 76791
// end ; end ;
76789: GO 76728
76791: POP
76792: POP
// end ; end ;
76793: GO 76576
76795: POP
76796: POP
// if result and not asc then
76797: LD_VAR 0 5
76801: IFFALSE 76810
76803: PUSH
76804: LD_VAR 0 3
76808: NOT
76809: AND
76810: IFFALSE 76827
// result := ReverseArray ( result ) ;
76812: LD_ADDR_VAR 0 5
76816: PUSH
76817: LD_VAR 0 5
76821: PPUSH
76822: CALL 104185 0 1
76826: ST_TO_ADDR
// tmp := [ ] ;
76827: LD_ADDR_VAR 0 8
76831: PUSH
76832: EMPTY
76833: ST_TO_ADDR
// if mode then
76834: LD_VAR 0 4
76838: IFFALSE 76902
// begin for i := 1 to result do
76840: LD_ADDR_VAR 0 6
76844: PUSH
76845: DOUBLE
76846: LD_INT 1
76848: DEC
76849: ST_TO_ADDR
76850: LD_VAR 0 5
76854: PUSH
76855: FOR_TO
76856: IFFALSE 76890
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76858: LD_ADDR_VAR 0 8
76862: PUSH
76863: LD_VAR 0 8
76867: PPUSH
76868: LD_VAR 0 5
76872: PUSH
76873: LD_VAR 0 6
76877: ARRAY
76878: PUSH
76879: LD_INT 1
76881: ARRAY
76882: PPUSH
76883: CALL 109095 0 2
76887: ST_TO_ADDR
76888: GO 76855
76890: POP
76891: POP
// result := tmp ;
76892: LD_ADDR_VAR 0 5
76896: PUSH
76897: LD_VAR 0 8
76901: ST_TO_ADDR
// end ; end ;
76902: LD_VAR 0 5
76906: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76907: LD_INT 0
76909: PPUSH
76910: PPUSH
76911: PPUSH
76912: PPUSH
// if not list then
76913: LD_VAR 0 3
76917: NOT
76918: IFFALSE 76922
// exit ;
76920: GO 77312
// result := [ ] ;
76922: LD_ADDR_VAR 0 6
76926: PUSH
76927: EMPTY
76928: ST_TO_ADDR
// for i in list do
76929: LD_ADDR_VAR 0 7
76933: PUSH
76934: LD_VAR 0 3
76938: PUSH
76939: FOR_IN
76940: IFFALSE 77142
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76942: LD_ADDR_VAR 0 9
76946: PUSH
76947: LD_VAR 0 7
76951: PPUSH
76952: LD_VAR 0 1
76956: PPUSH
76957: LD_VAR 0 2
76961: PPUSH
76962: CALL_OW 297
76966: ST_TO_ADDR
// if not result then
76967: LD_VAR 0 6
76971: NOT
76972: IFFALSE 76998
// result := [ [ i , tmp ] ] else
76974: LD_ADDR_VAR 0 6
76978: PUSH
76979: LD_VAR 0 7
76983: PUSH
76984: LD_VAR 0 9
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: EMPTY
76994: LIST
76995: ST_TO_ADDR
76996: GO 77140
// begin if result [ result ] [ 2 ] <= tmp then
76998: LD_VAR 0 6
77002: PUSH
77003: LD_VAR 0 6
77007: ARRAY
77008: PUSH
77009: LD_INT 2
77011: ARRAY
77012: PUSH
77013: LD_VAR 0 9
77017: LESSEQUAL
77018: IFFALSE 77060
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
77020: LD_ADDR_VAR 0 6
77024: PUSH
77025: LD_VAR 0 6
77029: PPUSH
77030: LD_VAR 0 6
77034: PUSH
77035: LD_INT 1
77037: PLUS
77038: PPUSH
77039: LD_VAR 0 7
77043: PUSH
77044: LD_VAR 0 9
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PPUSH
77053: CALL_OW 2
77057: ST_TO_ADDR
77058: GO 77140
// for j := 1 to result do
77060: LD_ADDR_VAR 0 8
77064: PUSH
77065: DOUBLE
77066: LD_INT 1
77068: DEC
77069: ST_TO_ADDR
77070: LD_VAR 0 6
77074: PUSH
77075: FOR_TO
77076: IFFALSE 77138
// begin if tmp < result [ j ] [ 2 ] then
77078: LD_VAR 0 9
77082: PUSH
77083: LD_VAR 0 6
77087: PUSH
77088: LD_VAR 0 8
77092: ARRAY
77093: PUSH
77094: LD_INT 2
77096: ARRAY
77097: LESS
77098: IFFALSE 77136
// begin result := Insert ( result , j , [ i , tmp ] ) ;
77100: LD_ADDR_VAR 0 6
77104: PUSH
77105: LD_VAR 0 6
77109: PPUSH
77110: LD_VAR 0 8
77114: PPUSH
77115: LD_VAR 0 7
77119: PUSH
77120: LD_VAR 0 9
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PPUSH
77129: CALL_OW 2
77133: ST_TO_ADDR
// break ;
77134: GO 77138
// end ; end ;
77136: GO 77075
77138: POP
77139: POP
// end ; end ;
77140: GO 76939
77142: POP
77143: POP
// if result and not asc then
77144: LD_VAR 0 6
77148: IFFALSE 77157
77150: PUSH
77151: LD_VAR 0 4
77155: NOT
77156: AND
77157: IFFALSE 77232
// begin tmp := result ;
77159: LD_ADDR_VAR 0 9
77163: PUSH
77164: LD_VAR 0 6
77168: ST_TO_ADDR
// for i = tmp downto 1 do
77169: LD_ADDR_VAR 0 7
77173: PUSH
77174: DOUBLE
77175: LD_VAR 0 9
77179: INC
77180: ST_TO_ADDR
77181: LD_INT 1
77183: PUSH
77184: FOR_DOWNTO
77185: IFFALSE 77230
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
77187: LD_ADDR_VAR 0 6
77191: PUSH
77192: LD_VAR 0 6
77196: PPUSH
77197: LD_VAR 0 9
77201: PUSH
77202: LD_VAR 0 7
77206: MINUS
77207: PUSH
77208: LD_INT 1
77210: PLUS
77211: PPUSH
77212: LD_VAR 0 9
77216: PUSH
77217: LD_VAR 0 7
77221: ARRAY
77222: PPUSH
77223: CALL_OW 1
77227: ST_TO_ADDR
77228: GO 77184
77230: POP
77231: POP
// end ; tmp := [ ] ;
77232: LD_ADDR_VAR 0 9
77236: PUSH
77237: EMPTY
77238: ST_TO_ADDR
// if mode then
77239: LD_VAR 0 5
77243: IFFALSE 77312
// begin for i = 1 to result do
77245: LD_ADDR_VAR 0 7
77249: PUSH
77250: DOUBLE
77251: LD_INT 1
77253: DEC
77254: ST_TO_ADDR
77255: LD_VAR 0 6
77259: PUSH
77260: FOR_TO
77261: IFFALSE 77300
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
77263: LD_ADDR_VAR 0 9
77267: PUSH
77268: LD_VAR 0 9
77272: PPUSH
77273: LD_VAR 0 7
77277: PPUSH
77278: LD_VAR 0 6
77282: PUSH
77283: LD_VAR 0 7
77287: ARRAY
77288: PUSH
77289: LD_INT 1
77291: ARRAY
77292: PPUSH
77293: CALL_OW 1
77297: ST_TO_ADDR
77298: GO 77260
77300: POP
77301: POP
// result := tmp ;
77302: LD_ADDR_VAR 0 6
77306: PUSH
77307: LD_VAR 0 9
77311: ST_TO_ADDR
// end ; end ;
77312: LD_VAR 0 6
77316: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
77317: LD_INT 0
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
77325: LD_ADDR_VAR 0 5
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: LD_INT 0
77335: PUSH
77336: LD_INT 0
77338: PUSH
77339: EMPTY
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: ST_TO_ADDR
// if not x or not y then
77347: LD_VAR 0 2
77351: NOT
77352: IFTRUE 77361
77354: PUSH
77355: LD_VAR 0 3
77359: NOT
77360: OR
77361: IFFALSE 77365
// exit ;
77363: GO 79021
// if not range then
77365: LD_VAR 0 4
77369: NOT
77370: IFFALSE 77380
// range := 10 ;
77372: LD_ADDR_VAR 0 4
77376: PUSH
77377: LD_INT 10
77379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
77380: LD_ADDR_VAR 0 8
77384: PUSH
77385: LD_INT 81
77387: PUSH
77388: LD_VAR 0 1
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 92
77399: PUSH
77400: LD_VAR 0 2
77404: PUSH
77405: LD_VAR 0 3
77409: PUSH
77410: LD_VAR 0 4
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 3
77423: PUSH
77424: LD_INT 21
77426: PUSH
77427: LD_INT 3
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: LIST
77442: PPUSH
77443: CALL_OW 69
77447: ST_TO_ADDR
// if not tmp then
77448: LD_VAR 0 8
77452: NOT
77453: IFFALSE 77457
// exit ;
77455: GO 79021
// for i in tmp do
77457: LD_ADDR_VAR 0 6
77461: PUSH
77462: LD_VAR 0 8
77466: PUSH
77467: FOR_IN
77468: IFFALSE 78996
// begin points := [ 0 , 0 , 0 ] ;
77470: LD_ADDR_VAR 0 9
77474: PUSH
77475: LD_INT 0
77477: PUSH
77478: LD_INT 0
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: LIST
77488: ST_TO_ADDR
// bpoints := 1 ;
77489: LD_ADDR_VAR 0 10
77493: PUSH
77494: LD_INT 1
77496: ST_TO_ADDR
// case GetType ( i ) of unit_human :
77497: LD_VAR 0 6
77501: PPUSH
77502: CALL_OW 247
77506: PUSH
77507: LD_INT 1
77509: DOUBLE
77510: EQUAL
77511: IFTRUE 77515
77513: GO 78097
77515: POP
// begin if GetClass ( i ) = 1 then
77516: LD_VAR 0 6
77520: PPUSH
77521: CALL_OW 257
77525: PUSH
77526: LD_INT 1
77528: EQUAL
77529: IFFALSE 77550
// points := [ 10 , 5 , 3 ] ;
77531: LD_ADDR_VAR 0 9
77535: PUSH
77536: LD_INT 10
77538: PUSH
77539: LD_INT 5
77541: PUSH
77542: LD_INT 3
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
77550: LD_VAR 0 6
77554: PPUSH
77555: CALL_OW 257
77559: PUSH
77560: LD_INT 2
77562: PUSH
77563: LD_INT 3
77565: PUSH
77566: LD_INT 4
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: LIST
77573: IN
77574: IFFALSE 77595
// points := [ 3 , 2 , 1 ] ;
77576: LD_ADDR_VAR 0 9
77580: PUSH
77581: LD_INT 3
77583: PUSH
77584: LD_INT 2
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: LIST
77594: ST_TO_ADDR
// if GetClass ( i ) = 5 then
77595: LD_VAR 0 6
77599: PPUSH
77600: CALL_OW 257
77604: PUSH
77605: LD_INT 5
77607: EQUAL
77608: IFFALSE 77629
// points := [ 130 , 5 , 2 ] ;
77610: LD_ADDR_VAR 0 9
77614: PUSH
77615: LD_INT 130
77617: PUSH
77618: LD_INT 5
77620: PUSH
77621: LD_INT 2
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: LIST
77628: ST_TO_ADDR
// if GetClass ( i ) = 8 then
77629: LD_VAR 0 6
77633: PPUSH
77634: CALL_OW 257
77638: PUSH
77639: LD_INT 8
77641: EQUAL
77642: IFFALSE 77663
// points := [ 35 , 35 , 30 ] ;
77644: LD_ADDR_VAR 0 9
77648: PUSH
77649: LD_INT 35
77651: PUSH
77652: LD_INT 35
77654: PUSH
77655: LD_INT 30
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: ST_TO_ADDR
// if GetClass ( i ) = 9 then
77663: LD_VAR 0 6
77667: PPUSH
77668: CALL_OW 257
77672: PUSH
77673: LD_INT 9
77675: EQUAL
77676: IFFALSE 77697
// points := [ 20 , 55 , 40 ] ;
77678: LD_ADDR_VAR 0 9
77682: PUSH
77683: LD_INT 20
77685: PUSH
77686: LD_INT 55
77688: PUSH
77689: LD_INT 40
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: LIST
77696: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
77697: LD_VAR 0 6
77701: PPUSH
77702: CALL_OW 257
77706: PUSH
77707: LD_INT 12
77709: PUSH
77710: LD_INT 16
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: IN
77717: IFFALSE 77738
// points := [ 5 , 3 , 2 ] ;
77719: LD_ADDR_VAR 0 9
77723: PUSH
77724: LD_INT 5
77726: PUSH
77727: LD_INT 3
77729: PUSH
77730: LD_INT 2
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: LIST
77737: ST_TO_ADDR
// if GetClass ( i ) = 17 then
77738: LD_VAR 0 6
77742: PPUSH
77743: CALL_OW 257
77747: PUSH
77748: LD_INT 17
77750: EQUAL
77751: IFFALSE 77772
// points := [ 100 , 50 , 75 ] ;
77753: LD_ADDR_VAR 0 9
77757: PUSH
77758: LD_INT 100
77760: PUSH
77761: LD_INT 50
77763: PUSH
77764: LD_INT 75
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: LIST
77771: ST_TO_ADDR
// if GetClass ( i ) = 15 then
77772: LD_VAR 0 6
77776: PPUSH
77777: CALL_OW 257
77781: PUSH
77782: LD_INT 15
77784: EQUAL
77785: IFFALSE 77806
// points := [ 10 , 5 , 3 ] ;
77787: LD_ADDR_VAR 0 9
77791: PUSH
77792: LD_INT 10
77794: PUSH
77795: LD_INT 5
77797: PUSH
77798: LD_INT 3
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: LIST
77805: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77806: LD_VAR 0 6
77810: PPUSH
77811: CALL_OW 257
77815: PUSH
77816: LD_INT 14
77818: EQUAL
77819: IFFALSE 77840
// points := [ 10 , 0 , 0 ] ;
77821: LD_ADDR_VAR 0 9
77825: PUSH
77826: LD_INT 10
77828: PUSH
77829: LD_INT 0
77831: PUSH
77832: LD_INT 0
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: LIST
77839: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77840: LD_VAR 0 6
77844: PPUSH
77845: CALL_OW 257
77849: PUSH
77850: LD_INT 11
77852: EQUAL
77853: IFFALSE 77874
// points := [ 30 , 10 , 5 ] ;
77855: LD_ADDR_VAR 0 9
77859: PUSH
77860: LD_INT 30
77862: PUSH
77863: LD_INT 10
77865: PUSH
77866: LD_INT 5
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77874: LD_VAR 0 1
77878: PPUSH
77879: LD_INT 5
77881: PPUSH
77882: CALL_OW 321
77886: PUSH
77887: LD_INT 2
77889: EQUAL
77890: IFFALSE 77907
// bpoints := bpoints * 1.8 ;
77892: LD_ADDR_VAR 0 10
77896: PUSH
77897: LD_VAR 0 10
77901: PUSH
77902: LD_REAL  1.80000000000000E+0000
77905: MUL
77906: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77907: LD_VAR 0 6
77911: PPUSH
77912: CALL_OW 257
77916: PUSH
77917: LD_INT 1
77919: PUSH
77920: LD_INT 2
77922: PUSH
77923: LD_INT 3
77925: PUSH
77926: LD_INT 4
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: IN
77935: IFFALSE 77955
77937: PUSH
77938: LD_VAR 0 1
77942: PPUSH
77943: LD_INT 51
77945: PPUSH
77946: CALL_OW 321
77950: PUSH
77951: LD_INT 2
77953: EQUAL
77954: AND
77955: IFFALSE 77972
// bpoints := bpoints * 1.2 ;
77957: LD_ADDR_VAR 0 10
77961: PUSH
77962: LD_VAR 0 10
77966: PUSH
77967: LD_REAL  1.20000000000000E+0000
77970: MUL
77971: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77972: LD_VAR 0 6
77976: PPUSH
77977: CALL_OW 257
77981: PUSH
77982: LD_INT 5
77984: PUSH
77985: LD_INT 7
77987: PUSH
77988: LD_INT 9
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: LIST
77995: IN
77996: IFFALSE 78016
77998: PUSH
77999: LD_VAR 0 1
78003: PPUSH
78004: LD_INT 52
78006: PPUSH
78007: CALL_OW 321
78011: PUSH
78012: LD_INT 2
78014: EQUAL
78015: AND
78016: IFFALSE 78033
// bpoints := bpoints * 1.5 ;
78018: LD_ADDR_VAR 0 10
78022: PUSH
78023: LD_VAR 0 10
78027: PUSH
78028: LD_REAL  1.50000000000000E+0000
78031: MUL
78032: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
78033: LD_VAR 0 1
78037: PPUSH
78038: LD_INT 66
78040: PPUSH
78041: CALL_OW 321
78045: PUSH
78046: LD_INT 2
78048: EQUAL
78049: IFFALSE 78066
// bpoints := bpoints * 1.1 ;
78051: LD_ADDR_VAR 0 10
78055: PUSH
78056: LD_VAR 0 10
78060: PUSH
78061: LD_REAL  1.10000000000000E+0000
78064: MUL
78065: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
78066: LD_ADDR_VAR 0 10
78070: PUSH
78071: LD_VAR 0 10
78075: PUSH
78076: LD_VAR 0 6
78080: PPUSH
78081: LD_INT 1
78083: PPUSH
78084: CALL_OW 259
78088: PUSH
78089: LD_REAL  1.15000000000000E+0000
78092: MUL
78093: MUL
78094: ST_TO_ADDR
// end ; unit_vehicle :
78095: GO 78925
78097: LD_INT 2
78099: DOUBLE
78100: EQUAL
78101: IFTRUE 78105
78103: GO 78913
78105: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
78106: LD_VAR 0 6
78110: PPUSH
78111: CALL_OW 264
78115: PUSH
78116: LD_INT 2
78118: PUSH
78119: LD_INT 42
78121: PUSH
78122: LD_INT 24
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: IN
78130: IFFALSE 78151
// points := [ 25 , 5 , 3 ] ;
78132: LD_ADDR_VAR 0 9
78136: PUSH
78137: LD_INT 25
78139: PUSH
78140: LD_INT 5
78142: PUSH
78143: LD_INT 3
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: LIST
78150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
78151: LD_VAR 0 6
78155: PPUSH
78156: CALL_OW 264
78160: PUSH
78161: LD_INT 4
78163: PUSH
78164: LD_INT 43
78166: PUSH
78167: LD_INT 25
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: LIST
78174: IN
78175: IFFALSE 78196
// points := [ 40 , 15 , 5 ] ;
78177: LD_ADDR_VAR 0 9
78181: PUSH
78182: LD_INT 40
78184: PUSH
78185: LD_INT 15
78187: PUSH
78188: LD_INT 5
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: LIST
78195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
78196: LD_VAR 0 6
78200: PPUSH
78201: CALL_OW 264
78205: PUSH
78206: LD_INT 3
78208: PUSH
78209: LD_INT 23
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: IN
78216: IFFALSE 78237
// points := [ 7 , 25 , 8 ] ;
78218: LD_ADDR_VAR 0 9
78222: PUSH
78223: LD_INT 7
78225: PUSH
78226: LD_INT 25
78228: PUSH
78229: LD_INT 8
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: LIST
78236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
78237: LD_VAR 0 6
78241: PPUSH
78242: CALL_OW 264
78246: PUSH
78247: LD_INT 5
78249: PUSH
78250: LD_INT 27
78252: PUSH
78253: LD_INT 44
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: LIST
78260: IN
78261: IFFALSE 78282
// points := [ 14 , 50 , 16 ] ;
78263: LD_ADDR_VAR 0 9
78267: PUSH
78268: LD_INT 14
78270: PUSH
78271: LD_INT 50
78273: PUSH
78274: LD_INT 16
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: LIST
78281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
78282: LD_VAR 0 6
78286: PPUSH
78287: CALL_OW 264
78291: PUSH
78292: LD_INT 6
78294: PUSH
78295: LD_INT 46
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: IN
78302: IFFALSE 78323
// points := [ 32 , 120 , 70 ] ;
78304: LD_ADDR_VAR 0 9
78308: PUSH
78309: LD_INT 32
78311: PUSH
78312: LD_INT 120
78314: PUSH
78315: LD_INT 70
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: LIST
78322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
78323: LD_VAR 0 6
78327: PPUSH
78328: CALL_OW 264
78332: PUSH
78333: LD_INT 7
78335: PUSH
78336: LD_INT 28
78338: PUSH
78339: LD_INT 45
78341: PUSH
78342: LD_INT 92
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: IN
78351: IFFALSE 78372
// points := [ 35 , 20 , 45 ] ;
78353: LD_ADDR_VAR 0 9
78357: PUSH
78358: LD_INT 35
78360: PUSH
78361: LD_INT 20
78363: PUSH
78364: LD_INT 45
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: LIST
78371: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
78372: LD_VAR 0 6
78376: PPUSH
78377: CALL_OW 264
78381: PUSH
78382: LD_INT 47
78384: PUSH
78385: EMPTY
78386: LIST
78387: IN
78388: IFFALSE 78409
// points := [ 67 , 45 , 75 ] ;
78390: LD_ADDR_VAR 0 9
78394: PUSH
78395: LD_INT 67
78397: PUSH
78398: LD_INT 45
78400: PUSH
78401: LD_INT 75
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: LIST
78408: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
78409: LD_VAR 0 6
78413: PPUSH
78414: CALL_OW 264
78418: PUSH
78419: LD_INT 26
78421: PUSH
78422: EMPTY
78423: LIST
78424: IN
78425: IFFALSE 78446
// points := [ 120 , 30 , 80 ] ;
78427: LD_ADDR_VAR 0 9
78431: PUSH
78432: LD_INT 120
78434: PUSH
78435: LD_INT 30
78437: PUSH
78438: LD_INT 80
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: LIST
78445: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
78446: LD_VAR 0 6
78450: PPUSH
78451: CALL_OW 264
78455: PUSH
78456: LD_INT 22
78458: PUSH
78459: EMPTY
78460: LIST
78461: IN
78462: IFFALSE 78483
// points := [ 40 , 1 , 1 ] ;
78464: LD_ADDR_VAR 0 9
78468: PUSH
78469: LD_INT 40
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: LD_INT 1
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: LIST
78482: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
78483: LD_VAR 0 6
78487: PPUSH
78488: CALL_OW 264
78492: PUSH
78493: LD_INT 29
78495: PUSH
78496: EMPTY
78497: LIST
78498: IN
78499: IFFALSE 78520
// points := [ 70 , 200 , 400 ] ;
78501: LD_ADDR_VAR 0 9
78505: PUSH
78506: LD_INT 70
78508: PUSH
78509: LD_INT 200
78511: PUSH
78512: LD_INT 400
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: LIST
78519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
78520: LD_VAR 0 6
78524: PPUSH
78525: CALL_OW 264
78529: PUSH
78530: LD_INT 14
78532: PUSH
78533: LD_INT 53
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: IN
78540: IFFALSE 78561
// points := [ 40 , 10 , 20 ] ;
78542: LD_ADDR_VAR 0 9
78546: PUSH
78547: LD_INT 40
78549: PUSH
78550: LD_INT 10
78552: PUSH
78553: LD_INT 20
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
78561: LD_VAR 0 6
78565: PPUSH
78566: CALL_OW 264
78570: PUSH
78571: LD_INT 9
78573: PUSH
78574: EMPTY
78575: LIST
78576: IN
78577: IFFALSE 78598
// points := [ 5 , 70 , 20 ] ;
78579: LD_ADDR_VAR 0 9
78583: PUSH
78584: LD_INT 5
78586: PUSH
78587: LD_INT 70
78589: PUSH
78590: LD_INT 20
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: LIST
78597: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
78598: LD_VAR 0 6
78602: PPUSH
78603: CALL_OW 264
78607: PUSH
78608: LD_INT 10
78610: PUSH
78611: EMPTY
78612: LIST
78613: IN
78614: IFFALSE 78635
// points := [ 35 , 110 , 70 ] ;
78616: LD_ADDR_VAR 0 9
78620: PUSH
78621: LD_INT 35
78623: PUSH
78624: LD_INT 110
78626: PUSH
78627: LD_INT 70
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: LIST
78634: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
78635: LD_VAR 0 6
78639: PPUSH
78640: CALL_OW 265
78644: PUSH
78645: LD_INT 25
78647: EQUAL
78648: IFFALSE 78669
// points := [ 80 , 65 , 100 ] ;
78650: LD_ADDR_VAR 0 9
78654: PUSH
78655: LD_INT 80
78657: PUSH
78658: LD_INT 65
78660: PUSH
78661: LD_INT 100
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
78669: LD_VAR 0 6
78673: PPUSH
78674: CALL_OW 263
78678: PUSH
78679: LD_INT 1
78681: EQUAL
78682: IFFALSE 78717
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
78684: LD_ADDR_VAR 0 10
78688: PUSH
78689: LD_VAR 0 10
78693: PUSH
78694: LD_VAR 0 6
78698: PPUSH
78699: CALL_OW 311
78703: PPUSH
78704: LD_INT 3
78706: PPUSH
78707: CALL_OW 259
78711: PUSH
78712: LD_INT 4
78714: MUL
78715: MUL
78716: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
78717: LD_VAR 0 6
78721: PPUSH
78722: CALL_OW 263
78726: PUSH
78727: LD_INT 2
78729: EQUAL
78730: IFFALSE 78781
// begin j := IsControledBy ( i ) ;
78732: LD_ADDR_VAR 0 7
78736: PUSH
78737: LD_VAR 0 6
78741: PPUSH
78742: CALL_OW 312
78746: ST_TO_ADDR
// if j then
78747: LD_VAR 0 7
78751: IFFALSE 78781
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
78753: LD_ADDR_VAR 0 10
78757: PUSH
78758: LD_VAR 0 10
78762: PUSH
78763: LD_VAR 0 7
78767: PPUSH
78768: LD_INT 3
78770: PPUSH
78771: CALL_OW 259
78775: PUSH
78776: LD_INT 3
78778: MUL
78779: MUL
78780: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
78781: LD_VAR 0 6
78785: PPUSH
78786: CALL_OW 264
78790: PUSH
78791: LD_INT 5
78793: PUSH
78794: LD_INT 6
78796: PUSH
78797: LD_INT 46
78799: PUSH
78800: LD_INT 44
78802: PUSH
78803: LD_INT 47
78805: PUSH
78806: LD_INT 45
78808: PUSH
78809: LD_INT 28
78811: PUSH
78812: LD_INT 7
78814: PUSH
78815: LD_INT 27
78817: PUSH
78818: LD_INT 29
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: IN
78833: IFFALSE 78853
78835: PUSH
78836: LD_VAR 0 1
78840: PPUSH
78841: LD_INT 52
78843: PPUSH
78844: CALL_OW 321
78848: PUSH
78849: LD_INT 2
78851: EQUAL
78852: AND
78853: IFFALSE 78870
// bpoints := bpoints * 1.2 ;
78855: LD_ADDR_VAR 0 10
78859: PUSH
78860: LD_VAR 0 10
78864: PUSH
78865: LD_REAL  1.20000000000000E+0000
78868: MUL
78869: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78870: LD_VAR 0 6
78874: PPUSH
78875: CALL_OW 264
78879: PUSH
78880: LD_INT 6
78882: PUSH
78883: LD_INT 46
78885: PUSH
78886: LD_INT 47
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: LIST
78893: IN
78894: IFFALSE 78911
// bpoints := bpoints * 1.2 ;
78896: LD_ADDR_VAR 0 10
78900: PUSH
78901: LD_VAR 0 10
78905: PUSH
78906: LD_REAL  1.20000000000000E+0000
78909: MUL
78910: ST_TO_ADDR
// end ; unit_building :
78911: GO 78925
78913: LD_INT 3
78915: DOUBLE
78916: EQUAL
78917: IFTRUE 78921
78919: GO 78924
78921: POP
// ; end ;
78922: GO 78925
78924: POP
// for j = 1 to 3 do
78925: LD_ADDR_VAR 0 7
78929: PUSH
78930: DOUBLE
78931: LD_INT 1
78933: DEC
78934: ST_TO_ADDR
78935: LD_INT 3
78937: PUSH
78938: FOR_TO
78939: IFFALSE 78992
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78941: LD_ADDR_VAR 0 5
78945: PUSH
78946: LD_VAR 0 5
78950: PPUSH
78951: LD_VAR 0 7
78955: PPUSH
78956: LD_VAR 0 5
78960: PUSH
78961: LD_VAR 0 7
78965: ARRAY
78966: PUSH
78967: LD_VAR 0 9
78971: PUSH
78972: LD_VAR 0 7
78976: ARRAY
78977: PUSH
78978: LD_VAR 0 10
78982: MUL
78983: PLUS
78984: PPUSH
78985: CALL_OW 1
78989: ST_TO_ADDR
78990: GO 78938
78992: POP
78993: POP
// end ;
78994: GO 77467
78996: POP
78997: POP
// result := Replace ( result , 4 , tmp ) ;
78998: LD_ADDR_VAR 0 5
79002: PUSH
79003: LD_VAR 0 5
79007: PPUSH
79008: LD_INT 4
79010: PPUSH
79011: LD_VAR 0 8
79015: PPUSH
79016: CALL_OW 1
79020: ST_TO_ADDR
// end ;
79021: LD_VAR 0 5
79025: RET
// export function DangerAtRange ( unit , range ) ; begin
79026: LD_INT 0
79028: PPUSH
// if not unit then
79029: LD_VAR 0 1
79033: NOT
79034: IFFALSE 79038
// exit ;
79036: GO 79083
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
79038: LD_ADDR_VAR 0 3
79042: PUSH
79043: LD_VAR 0 1
79047: PPUSH
79048: CALL_OW 255
79052: PPUSH
79053: LD_VAR 0 1
79057: PPUSH
79058: CALL_OW 250
79062: PPUSH
79063: LD_VAR 0 1
79067: PPUSH
79068: CALL_OW 251
79072: PPUSH
79073: LD_VAR 0 2
79077: PPUSH
79078: CALL 77317 0 4
79082: ST_TO_ADDR
// end ;
79083: LD_VAR 0 3
79087: RET
// export function DangerInArea ( side , area ) ; begin
79088: LD_INT 0
79090: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
79091: LD_ADDR_VAR 0 3
79095: PUSH
79096: LD_VAR 0 2
79100: PPUSH
79101: LD_INT 81
79103: PUSH
79104: LD_VAR 0 1
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PPUSH
79113: CALL_OW 70
79117: ST_TO_ADDR
// end ;
79118: LD_VAR 0 3
79122: RET
// export function IsExtension ( b ) ; begin
79123: LD_INT 0
79125: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
79126: LD_ADDR_VAR 0 2
79130: PUSH
79131: LD_VAR 0 1
79135: PUSH
79136: LD_INT 23
79138: PUSH
79139: LD_INT 20
79141: PUSH
79142: LD_INT 22
79144: PUSH
79145: LD_INT 17
79147: PUSH
79148: LD_INT 24
79150: PUSH
79151: LD_INT 21
79153: PUSH
79154: LD_INT 19
79156: PUSH
79157: LD_INT 16
79159: PUSH
79160: LD_INT 25
79162: PUSH
79163: LD_INT 18
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: IN
79178: ST_TO_ADDR
// end ;
79179: LD_VAR 0 2
79183: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
79184: LD_INT 0
79186: PPUSH
79187: PPUSH
79188: PPUSH
// result := [ ] ;
79189: LD_ADDR_VAR 0 4
79193: PUSH
79194: EMPTY
79195: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
79196: LD_ADDR_VAR 0 5
79200: PUSH
79201: LD_VAR 0 2
79205: PPUSH
79206: LD_INT 21
79208: PUSH
79209: LD_INT 3
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PPUSH
79216: CALL_OW 70
79220: ST_TO_ADDR
// if not tmp then
79221: LD_VAR 0 5
79225: NOT
79226: IFFALSE 79230
// exit ;
79228: GO 79294
// if checkLink then
79230: LD_VAR 0 3
79234: IFFALSE 79284
// begin for i in tmp do
79236: LD_ADDR_VAR 0 6
79240: PUSH
79241: LD_VAR 0 5
79245: PUSH
79246: FOR_IN
79247: IFFALSE 79282
// if GetBase ( i ) <> base then
79249: LD_VAR 0 6
79253: PPUSH
79254: CALL_OW 274
79258: PUSH
79259: LD_VAR 0 1
79263: NONEQUAL
79264: IFFALSE 79280
// ComLinkToBase ( base , i ) ;
79266: LD_VAR 0 1
79270: PPUSH
79271: LD_VAR 0 6
79275: PPUSH
79276: CALL_OW 169
79280: GO 79246
79282: POP
79283: POP
// end ; result := tmp ;
79284: LD_ADDR_VAR 0 4
79288: PUSH
79289: LD_VAR 0 5
79293: ST_TO_ADDR
// end ;
79294: LD_VAR 0 4
79298: RET
// export function ComComplete ( units , b ) ; var i ; begin
79299: LD_INT 0
79301: PPUSH
79302: PPUSH
// if not units then
79303: LD_VAR 0 1
79307: NOT
79308: IFFALSE 79312
// exit ;
79310: GO 79402
// for i in units do
79312: LD_ADDR_VAR 0 4
79316: PUSH
79317: LD_VAR 0 1
79321: PUSH
79322: FOR_IN
79323: IFFALSE 79400
// if BuildingStatus ( b ) = bs_build then
79325: LD_VAR 0 2
79329: PPUSH
79330: CALL_OW 461
79334: PUSH
79335: LD_INT 1
79337: EQUAL
79338: IFFALSE 79398
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
79340: LD_VAR 0 4
79344: PPUSH
79345: LD_STRING h
79347: PUSH
79348: LD_VAR 0 2
79352: PPUSH
79353: CALL_OW 250
79357: PUSH
79358: LD_VAR 0 2
79362: PPUSH
79363: CALL_OW 251
79367: PUSH
79368: LD_VAR 0 2
79372: PUSH
79373: LD_INT 0
79375: PUSH
79376: LD_INT 0
79378: PUSH
79379: LD_INT 0
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: PUSH
79391: EMPTY
79392: LIST
79393: PPUSH
79394: CALL_OW 446
79398: GO 79322
79400: POP
79401: POP
// end ;
79402: LD_VAR 0 3
79406: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
79407: LD_INT 0
79409: PPUSH
79410: PPUSH
79411: PPUSH
79412: PPUSH
79413: PPUSH
79414: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
79415: LD_VAR 0 1
79419: NOT
79420: IFTRUE 79437
79422: PUSH
79423: LD_VAR 0 1
79427: PPUSH
79428: CALL_OW 263
79432: PUSH
79433: LD_INT 2
79435: NONEQUAL
79436: OR
79437: IFFALSE 79441
// exit ;
79439: GO 79757
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
79441: LD_ADDR_VAR 0 6
79445: PUSH
79446: LD_INT 22
79448: PUSH
79449: LD_VAR 0 1
79453: PPUSH
79454: CALL_OW 255
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: LD_INT 30
79468: PUSH
79469: LD_INT 36
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 34
79478: PUSH
79479: LD_INT 31
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: LIST
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PPUSH
79495: CALL_OW 69
79499: ST_TO_ADDR
// if not tmp then
79500: LD_VAR 0 6
79504: NOT
79505: IFFALSE 79509
// exit ;
79507: GO 79757
// result := [ ] ;
79509: LD_ADDR_VAR 0 2
79513: PUSH
79514: EMPTY
79515: ST_TO_ADDR
// for i in tmp do
79516: LD_ADDR_VAR 0 3
79520: PUSH
79521: LD_VAR 0 6
79525: PUSH
79526: FOR_IN
79527: IFFALSE 79598
// begin t := UnitsInside ( i ) ;
79529: LD_ADDR_VAR 0 4
79533: PUSH
79534: LD_VAR 0 3
79538: PPUSH
79539: CALL_OW 313
79543: ST_TO_ADDR
// if t then
79544: LD_VAR 0 4
79548: IFFALSE 79596
// for j in t do
79550: LD_ADDR_VAR 0 7
79554: PUSH
79555: LD_VAR 0 4
79559: PUSH
79560: FOR_IN
79561: IFFALSE 79594
// result := Replace ( result , result + 1 , j ) ;
79563: LD_ADDR_VAR 0 2
79567: PUSH
79568: LD_VAR 0 2
79572: PPUSH
79573: LD_VAR 0 2
79577: PUSH
79578: LD_INT 1
79580: PLUS
79581: PPUSH
79582: LD_VAR 0 7
79586: PPUSH
79587: CALL_OW 1
79591: ST_TO_ADDR
79592: GO 79560
79594: POP
79595: POP
// end ;
79596: GO 79526
79598: POP
79599: POP
// if not result then
79600: LD_VAR 0 2
79604: NOT
79605: IFFALSE 79609
// exit ;
79607: GO 79757
// mech := result [ 1 ] ;
79609: LD_ADDR_VAR 0 5
79613: PUSH
79614: LD_VAR 0 2
79618: PUSH
79619: LD_INT 1
79621: ARRAY
79622: ST_TO_ADDR
// if result > 1 then
79623: LD_VAR 0 2
79627: PUSH
79628: LD_INT 1
79630: GREATER
79631: IFFALSE 79743
// begin for i = 2 to result do
79633: LD_ADDR_VAR 0 3
79637: PUSH
79638: DOUBLE
79639: LD_INT 2
79641: DEC
79642: ST_TO_ADDR
79643: LD_VAR 0 2
79647: PUSH
79648: FOR_TO
79649: IFFALSE 79741
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
79651: LD_ADDR_VAR 0 4
79655: PUSH
79656: LD_VAR 0 2
79660: PUSH
79661: LD_VAR 0 3
79665: ARRAY
79666: PPUSH
79667: LD_INT 3
79669: PPUSH
79670: CALL_OW 259
79674: PUSH
79675: LD_VAR 0 2
79679: PUSH
79680: LD_VAR 0 3
79684: ARRAY
79685: PPUSH
79686: CALL_OW 432
79690: MINUS
79691: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
79692: LD_VAR 0 4
79696: PUSH
79697: LD_VAR 0 5
79701: PPUSH
79702: LD_INT 3
79704: PPUSH
79705: CALL_OW 259
79709: PUSH
79710: LD_VAR 0 5
79714: PPUSH
79715: CALL_OW 432
79719: MINUS
79720: GREATEREQUAL
79721: IFFALSE 79739
// mech := result [ i ] ;
79723: LD_ADDR_VAR 0 5
79727: PUSH
79728: LD_VAR 0 2
79732: PUSH
79733: LD_VAR 0 3
79737: ARRAY
79738: ST_TO_ADDR
// end ;
79739: GO 79648
79741: POP
79742: POP
// end ; ComLinkTo ( vehicle , mech ) ;
79743: LD_VAR 0 1
79747: PPUSH
79748: LD_VAR 0 5
79752: PPUSH
79753: CALL_OW 135
// end ;
79757: LD_VAR 0 2
79761: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
79762: LD_INT 0
79764: PPUSH
79765: PPUSH
79766: PPUSH
79767: PPUSH
79768: PPUSH
79769: PPUSH
79770: PPUSH
79771: PPUSH
79772: PPUSH
79773: PPUSH
79774: PPUSH
79775: PPUSH
79776: PPUSH
// result := [ ] ;
79777: LD_ADDR_VAR 0 7
79781: PUSH
79782: EMPTY
79783: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
79784: LD_VAR 0 1
79788: PPUSH
79789: CALL_OW 266
79793: PUSH
79794: LD_INT 0
79796: PUSH
79797: LD_INT 1
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: IN
79804: NOT
79805: IFFALSE 79809
// exit ;
79807: GO 81449
// if name then
79809: LD_VAR 0 3
79813: IFFALSE 79829
// SetBName ( base_dep , name ) ;
79815: LD_VAR 0 1
79819: PPUSH
79820: LD_VAR 0 3
79824: PPUSH
79825: CALL_OW 500
// base := GetBase ( base_dep ) ;
79829: LD_ADDR_VAR 0 15
79833: PUSH
79834: LD_VAR 0 1
79838: PPUSH
79839: CALL_OW 274
79843: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79844: LD_ADDR_VAR 0 16
79848: PUSH
79849: LD_VAR 0 1
79853: PPUSH
79854: CALL_OW 255
79858: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79859: LD_ADDR_VAR 0 17
79863: PUSH
79864: LD_VAR 0 1
79868: PPUSH
79869: CALL_OW 248
79873: ST_TO_ADDR
// if sources then
79874: LD_VAR 0 5
79878: IFFALSE 79925
// for i = 1 to 3 do
79880: LD_ADDR_VAR 0 8
79884: PUSH
79885: DOUBLE
79886: LD_INT 1
79888: DEC
79889: ST_TO_ADDR
79890: LD_INT 3
79892: PUSH
79893: FOR_TO
79894: IFFALSE 79923
// AddResourceType ( base , i , sources [ i ] ) ;
79896: LD_VAR 0 15
79900: PPUSH
79901: LD_VAR 0 8
79905: PPUSH
79906: LD_VAR 0 5
79910: PUSH
79911: LD_VAR 0 8
79915: ARRAY
79916: PPUSH
79917: CALL_OW 276
79921: GO 79893
79923: POP
79924: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79925: LD_ADDR_VAR 0 18
79929: PUSH
79930: LD_VAR 0 15
79934: PPUSH
79935: LD_VAR 0 2
79939: PPUSH
79940: LD_INT 1
79942: PPUSH
79943: CALL 79184 0 3
79947: ST_TO_ADDR
// InitHc ;
79948: CALL_OW 19
// InitUc ;
79952: CALL_OW 18
// uc_side := side ;
79956: LD_ADDR_OWVAR 20
79960: PUSH
79961: LD_VAR 0 16
79965: ST_TO_ADDR
// uc_nation := nation ;
79966: LD_ADDR_OWVAR 21
79970: PUSH
79971: LD_VAR 0 17
79975: ST_TO_ADDR
// if buildings then
79976: LD_VAR 0 18
79980: IFFALSE 81308
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79982: LD_ADDR_VAR 0 19
79986: PUSH
79987: LD_VAR 0 18
79991: PPUSH
79992: LD_INT 2
79994: PUSH
79995: LD_INT 30
79997: PUSH
79998: LD_INT 29
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 30
80007: PUSH
80008: LD_INT 30
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: LIST
80019: PPUSH
80020: CALL_OW 72
80024: ST_TO_ADDR
// if tmp then
80025: LD_VAR 0 19
80029: IFFALSE 80077
// for i in tmp do
80031: LD_ADDR_VAR 0 8
80035: PUSH
80036: LD_VAR 0 19
80040: PUSH
80041: FOR_IN
80042: IFFALSE 80075
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
80044: LD_VAR 0 8
80048: PPUSH
80049: CALL_OW 250
80053: PPUSH
80054: LD_VAR 0 8
80058: PPUSH
80059: CALL_OW 251
80063: PPUSH
80064: LD_VAR 0 16
80068: PPUSH
80069: CALL_OW 441
80073: GO 80041
80075: POP
80076: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
80077: LD_VAR 0 18
80081: PPUSH
80082: LD_INT 2
80084: PUSH
80085: LD_INT 30
80087: PUSH
80088: LD_INT 32
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 30
80097: PUSH
80098: LD_INT 33
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: LIST
80109: PPUSH
80110: CALL_OW 72
80114: IFFALSE 80202
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
80116: LD_ADDR_VAR 0 8
80120: PUSH
80121: LD_VAR 0 18
80125: PPUSH
80126: LD_INT 2
80128: PUSH
80129: LD_INT 30
80131: PUSH
80132: LD_INT 32
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 30
80141: PUSH
80142: LD_INT 33
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: LIST
80153: PPUSH
80154: CALL_OW 72
80158: PUSH
80159: FOR_IN
80160: IFFALSE 80200
// begin if not GetBWeapon ( i ) then
80162: LD_VAR 0 8
80166: PPUSH
80167: CALL_OW 269
80171: NOT
80172: IFFALSE 80198
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
80174: LD_VAR 0 8
80178: PPUSH
80179: LD_VAR 0 8
80183: PPUSH
80184: LD_VAR 0 2
80188: PPUSH
80189: CALL 81454 0 2
80193: PPUSH
80194: CALL_OW 431
// end ;
80198: GO 80159
80200: POP
80201: POP
// end ; for i = 1 to personel do
80202: LD_ADDR_VAR 0 8
80206: PUSH
80207: DOUBLE
80208: LD_INT 1
80210: DEC
80211: ST_TO_ADDR
80212: LD_VAR 0 6
80216: PUSH
80217: FOR_TO
80218: IFFALSE 81288
// begin if i > 4 then
80220: LD_VAR 0 8
80224: PUSH
80225: LD_INT 4
80227: GREATER
80228: IFFALSE 80232
// break ;
80230: GO 81288
// case i of 1 :
80232: LD_VAR 0 8
80236: PUSH
80237: LD_INT 1
80239: DOUBLE
80240: EQUAL
80241: IFTRUE 80245
80243: GO 80325
80245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
80246: LD_ADDR_VAR 0 12
80250: PUSH
80251: LD_VAR 0 18
80255: PPUSH
80256: LD_INT 22
80258: PUSH
80259: LD_VAR 0 16
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 58
80270: PUSH
80271: EMPTY
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: PUSH
80277: LD_INT 30
80279: PUSH
80280: LD_INT 32
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 30
80289: PUSH
80290: LD_INT 4
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 30
80299: PUSH
80300: LD_INT 5
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: LIST
80317: PPUSH
80318: CALL_OW 72
80322: ST_TO_ADDR
80323: GO 80547
80325: LD_INT 2
80327: DOUBLE
80328: EQUAL
80329: IFTRUE 80333
80331: GO 80395
80333: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
80334: LD_ADDR_VAR 0 12
80338: PUSH
80339: LD_VAR 0 18
80343: PPUSH
80344: LD_INT 22
80346: PUSH
80347: LD_VAR 0 16
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 2
80358: PUSH
80359: LD_INT 30
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 30
80371: PUSH
80372: LD_INT 1
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: LIST
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PPUSH
80388: CALL_OW 72
80392: ST_TO_ADDR
80393: GO 80547
80395: LD_INT 3
80397: DOUBLE
80398: EQUAL
80399: IFTRUE 80403
80401: GO 80465
80403: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
80404: LD_ADDR_VAR 0 12
80408: PUSH
80409: LD_VAR 0 18
80413: PPUSH
80414: LD_INT 22
80416: PUSH
80417: LD_VAR 0 16
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 2
80428: PUSH
80429: LD_INT 30
80431: PUSH
80432: LD_INT 2
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 30
80441: PUSH
80442: LD_INT 3
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: LIST
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PPUSH
80458: CALL_OW 72
80462: ST_TO_ADDR
80463: GO 80547
80465: LD_INT 4
80467: DOUBLE
80468: EQUAL
80469: IFTRUE 80473
80471: GO 80546
80473: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
80474: LD_ADDR_VAR 0 12
80478: PUSH
80479: LD_VAR 0 18
80483: PPUSH
80484: LD_INT 22
80486: PUSH
80487: LD_VAR 0 16
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 2
80498: PUSH
80499: LD_INT 30
80501: PUSH
80502: LD_INT 6
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 30
80511: PUSH
80512: LD_INT 7
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 30
80521: PUSH
80522: LD_INT 8
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PPUSH
80539: CALL_OW 72
80543: ST_TO_ADDR
80544: GO 80547
80546: POP
// if i = 1 then
80547: LD_VAR 0 8
80551: PUSH
80552: LD_INT 1
80554: EQUAL
80555: IFFALSE 80666
// begin tmp := [ ] ;
80557: LD_ADDR_VAR 0 19
80561: PUSH
80562: EMPTY
80563: ST_TO_ADDR
// for j in f do
80564: LD_ADDR_VAR 0 9
80568: PUSH
80569: LD_VAR 0 12
80573: PUSH
80574: FOR_IN
80575: IFFALSE 80648
// if GetBType ( j ) = b_bunker then
80577: LD_VAR 0 9
80581: PPUSH
80582: CALL_OW 266
80586: PUSH
80587: LD_INT 32
80589: EQUAL
80590: IFFALSE 80617
// tmp := Insert ( tmp , 1 , j ) else
80592: LD_ADDR_VAR 0 19
80596: PUSH
80597: LD_VAR 0 19
80601: PPUSH
80602: LD_INT 1
80604: PPUSH
80605: LD_VAR 0 9
80609: PPUSH
80610: CALL_OW 2
80614: ST_TO_ADDR
80615: GO 80646
// tmp := Insert ( tmp , tmp + 1 , j ) ;
80617: LD_ADDR_VAR 0 19
80621: PUSH
80622: LD_VAR 0 19
80626: PPUSH
80627: LD_VAR 0 19
80631: PUSH
80632: LD_INT 1
80634: PLUS
80635: PPUSH
80636: LD_VAR 0 9
80640: PPUSH
80641: CALL_OW 2
80645: ST_TO_ADDR
80646: GO 80574
80648: POP
80649: POP
// if tmp then
80650: LD_VAR 0 19
80654: IFFALSE 80666
// f := tmp ;
80656: LD_ADDR_VAR 0 12
80660: PUSH
80661: LD_VAR 0 19
80665: ST_TO_ADDR
// end ; x := personel [ i ] ;
80666: LD_ADDR_VAR 0 13
80670: PUSH
80671: LD_VAR 0 6
80675: PUSH
80676: LD_VAR 0 8
80680: ARRAY
80681: ST_TO_ADDR
// if x = - 1 then
80682: LD_VAR 0 13
80686: PUSH
80687: LD_INT 1
80689: NEG
80690: EQUAL
80691: IFFALSE 80902
// begin for j in f do
80693: LD_ADDR_VAR 0 9
80697: PUSH
80698: LD_VAR 0 12
80702: PUSH
80703: FOR_IN
80704: IFFALSE 80898
// repeat InitHc ;
80706: CALL_OW 19
// if GetBType ( j ) = b_barracks then
80710: LD_VAR 0 9
80714: PPUSH
80715: CALL_OW 266
80719: PUSH
80720: LD_INT 5
80722: EQUAL
80723: IFFALSE 80793
// begin if UnitsInside ( j ) < 3 then
80725: LD_VAR 0 9
80729: PPUSH
80730: CALL_OW 313
80734: PUSH
80735: LD_INT 3
80737: LESS
80738: IFFALSE 80774
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80740: LD_INT 0
80742: PPUSH
80743: LD_INT 5
80745: PUSH
80746: LD_INT 8
80748: PUSH
80749: LD_INT 9
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: LIST
80756: PUSH
80757: LD_VAR 0 17
80761: ARRAY
80762: PPUSH
80763: LD_VAR 0 4
80767: PPUSH
80768: CALL_OW 380
80772: GO 80791
// PrepareHuman ( false , i , skill ) ;
80774: LD_INT 0
80776: PPUSH
80777: LD_VAR 0 8
80781: PPUSH
80782: LD_VAR 0 4
80786: PPUSH
80787: CALL_OW 380
// end else
80791: GO 80810
// PrepareHuman ( false , i , skill ) ;
80793: LD_INT 0
80795: PPUSH
80796: LD_VAR 0 8
80800: PPUSH
80801: LD_VAR 0 4
80805: PPUSH
80806: CALL_OW 380
// un := CreateHuman ;
80810: LD_ADDR_VAR 0 14
80814: PUSH
80815: CALL_OW 44
80819: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80820: LD_ADDR_VAR 0 7
80824: PUSH
80825: LD_VAR 0 7
80829: PPUSH
80830: LD_INT 1
80832: PPUSH
80833: LD_VAR 0 14
80837: PPUSH
80838: CALL_OW 2
80842: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80843: LD_VAR 0 14
80847: PPUSH
80848: LD_VAR 0 9
80852: PPUSH
80853: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80857: LD_VAR 0 9
80861: PPUSH
80862: CALL_OW 313
80866: PUSH
80867: LD_INT 6
80869: EQUAL
80870: IFTRUE 80894
80872: PUSH
80873: LD_VAR 0 9
80877: PPUSH
80878: CALL_OW 266
80882: PUSH
80883: LD_INT 32
80885: PUSH
80886: LD_INT 31
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: IN
80893: OR
80894: IFFALSE 80706
80896: GO 80703
80898: POP
80899: POP
// end else
80900: GO 81286
// for j = 1 to x do
80902: LD_ADDR_VAR 0 9
80906: PUSH
80907: DOUBLE
80908: LD_INT 1
80910: DEC
80911: ST_TO_ADDR
80912: LD_VAR 0 13
80916: PUSH
80917: FOR_TO
80918: IFFALSE 81284
// begin InitHc ;
80920: CALL_OW 19
// if not f then
80924: LD_VAR 0 12
80928: NOT
80929: IFFALSE 81018
// begin PrepareHuman ( false , i , skill ) ;
80931: LD_INT 0
80933: PPUSH
80934: LD_VAR 0 8
80938: PPUSH
80939: LD_VAR 0 4
80943: PPUSH
80944: CALL_OW 380
// un := CreateHuman ;
80948: LD_ADDR_VAR 0 14
80952: PUSH
80953: CALL_OW 44
80957: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80958: LD_ADDR_VAR 0 7
80962: PUSH
80963: LD_VAR 0 7
80967: PPUSH
80968: LD_INT 1
80970: PPUSH
80971: LD_VAR 0 14
80975: PPUSH
80976: CALL_OW 2
80980: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80981: LD_VAR 0 14
80985: PPUSH
80986: LD_VAR 0 1
80990: PPUSH
80991: CALL_OW 250
80995: PPUSH
80996: LD_VAR 0 1
81000: PPUSH
81001: CALL_OW 251
81005: PPUSH
81006: LD_INT 10
81008: PPUSH
81009: LD_INT 0
81011: PPUSH
81012: CALL_OW 50
// continue ;
81016: GO 80917
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
81018: LD_VAR 0 12
81022: PUSH
81023: LD_INT 1
81025: ARRAY
81026: PPUSH
81027: CALL_OW 313
81031: IFFALSE 81059
81033: PUSH
81034: LD_VAR 0 12
81038: PUSH
81039: LD_INT 1
81041: ARRAY
81042: PPUSH
81043: CALL_OW 266
81047: PUSH
81048: LD_INT 32
81050: PUSH
81051: LD_INT 31
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: IN
81058: AND
81059: IFTRUE 81080
81061: PUSH
81062: LD_VAR 0 12
81066: PUSH
81067: LD_INT 1
81069: ARRAY
81070: PPUSH
81071: CALL_OW 313
81075: PUSH
81076: LD_INT 6
81078: EQUAL
81079: OR
81080: IFFALSE 81100
// f := Delete ( f , 1 ) ;
81082: LD_ADDR_VAR 0 12
81086: PUSH
81087: LD_VAR 0 12
81091: PPUSH
81092: LD_INT 1
81094: PPUSH
81095: CALL_OW 3
81099: ST_TO_ADDR
// if not f then
81100: LD_VAR 0 12
81104: NOT
81105: IFFALSE 81123
// begin x := x + 2 ;
81107: LD_ADDR_VAR 0 13
81111: PUSH
81112: LD_VAR 0 13
81116: PUSH
81117: LD_INT 2
81119: PLUS
81120: ST_TO_ADDR
// continue ;
81121: GO 80917
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
81123: LD_VAR 0 12
81127: PUSH
81128: LD_INT 1
81130: ARRAY
81131: PPUSH
81132: CALL_OW 266
81136: PUSH
81137: LD_INT 5
81139: EQUAL
81140: IFFALSE 81214
// begin if UnitsInside ( f [ 1 ] ) < 3 then
81142: LD_VAR 0 12
81146: PUSH
81147: LD_INT 1
81149: ARRAY
81150: PPUSH
81151: CALL_OW 313
81155: PUSH
81156: LD_INT 3
81158: LESS
81159: IFFALSE 81195
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
81161: LD_INT 0
81163: PPUSH
81164: LD_INT 5
81166: PUSH
81167: LD_INT 8
81169: PUSH
81170: LD_INT 9
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: PUSH
81178: LD_VAR 0 17
81182: ARRAY
81183: PPUSH
81184: LD_VAR 0 4
81188: PPUSH
81189: CALL_OW 380
81193: GO 81212
// PrepareHuman ( false , i , skill ) ;
81195: LD_INT 0
81197: PPUSH
81198: LD_VAR 0 8
81202: PPUSH
81203: LD_VAR 0 4
81207: PPUSH
81208: CALL_OW 380
// end else
81212: GO 81231
// PrepareHuman ( false , i , skill ) ;
81214: LD_INT 0
81216: PPUSH
81217: LD_VAR 0 8
81221: PPUSH
81222: LD_VAR 0 4
81226: PPUSH
81227: CALL_OW 380
// un := CreateHuman ;
81231: LD_ADDR_VAR 0 14
81235: PUSH
81236: CALL_OW 44
81240: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
81241: LD_ADDR_VAR 0 7
81245: PUSH
81246: LD_VAR 0 7
81250: PPUSH
81251: LD_INT 1
81253: PPUSH
81254: LD_VAR 0 14
81258: PPUSH
81259: CALL_OW 2
81263: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
81264: LD_VAR 0 14
81268: PPUSH
81269: LD_VAR 0 12
81273: PUSH
81274: LD_INT 1
81276: ARRAY
81277: PPUSH
81278: CALL_OW 52
// end ;
81282: GO 80917
81284: POP
81285: POP
// end ;
81286: GO 80217
81288: POP
81289: POP
// result := result ^ buildings ;
81290: LD_ADDR_VAR 0 7
81294: PUSH
81295: LD_VAR 0 7
81299: PUSH
81300: LD_VAR 0 18
81304: ADD
81305: ST_TO_ADDR
// end else
81306: GO 81449
// begin for i = 1 to personel do
81308: LD_ADDR_VAR 0 8
81312: PUSH
81313: DOUBLE
81314: LD_INT 1
81316: DEC
81317: ST_TO_ADDR
81318: LD_VAR 0 6
81322: PUSH
81323: FOR_TO
81324: IFFALSE 81447
// begin if i > 4 then
81326: LD_VAR 0 8
81330: PUSH
81331: LD_INT 4
81333: GREATER
81334: IFFALSE 81338
// break ;
81336: GO 81447
// x := personel [ i ] ;
81338: LD_ADDR_VAR 0 13
81342: PUSH
81343: LD_VAR 0 6
81347: PUSH
81348: LD_VAR 0 8
81352: ARRAY
81353: ST_TO_ADDR
// if x = - 1 then
81354: LD_VAR 0 13
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: EQUAL
81363: IFFALSE 81367
// continue ;
81365: GO 81323
// PrepareHuman ( false , i , skill ) ;
81367: LD_INT 0
81369: PPUSH
81370: LD_VAR 0 8
81374: PPUSH
81375: LD_VAR 0 4
81379: PPUSH
81380: CALL_OW 380
// un := CreateHuman ;
81384: LD_ADDR_VAR 0 14
81388: PUSH
81389: CALL_OW 44
81393: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
81394: LD_VAR 0 14
81398: PPUSH
81399: LD_VAR 0 1
81403: PPUSH
81404: CALL_OW 250
81408: PPUSH
81409: LD_VAR 0 1
81413: PPUSH
81414: CALL_OW 251
81418: PPUSH
81419: LD_INT 10
81421: PPUSH
81422: LD_INT 0
81424: PPUSH
81425: CALL_OW 50
// result := result ^ un ;
81429: LD_ADDR_VAR 0 7
81433: PUSH
81434: LD_VAR 0 7
81438: PUSH
81439: LD_VAR 0 14
81443: ADD
81444: ST_TO_ADDR
// end ;
81445: GO 81323
81447: POP
81448: POP
// end ; end ;
81449: LD_VAR 0 7
81453: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
81454: LD_INT 0
81456: PPUSH
81457: PPUSH
81458: PPUSH
81459: PPUSH
81460: PPUSH
81461: PPUSH
81462: PPUSH
81463: PPUSH
81464: PPUSH
81465: PPUSH
81466: PPUSH
81467: PPUSH
81468: PPUSH
81469: PPUSH
81470: PPUSH
81471: PPUSH
// result := false ;
81472: LD_ADDR_VAR 0 3
81476: PUSH
81477: LD_INT 0
81479: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
81480: LD_VAR 0 1
81484: NOT
81485: IFTRUE 81510
81487: PUSH
81488: LD_VAR 0 1
81492: PPUSH
81493: CALL_OW 266
81497: PUSH
81498: LD_INT 32
81500: PUSH
81501: LD_INT 33
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: IN
81508: NOT
81509: OR
81510: IFFALSE 81514
// exit ;
81512: GO 82649
// nat := GetNation ( tower ) ;
81514: LD_ADDR_VAR 0 12
81518: PUSH
81519: LD_VAR 0 1
81523: PPUSH
81524: CALL_OW 248
81528: ST_TO_ADDR
// side := GetSide ( tower ) ;
81529: LD_ADDR_VAR 0 16
81533: PUSH
81534: LD_VAR 0 1
81538: PPUSH
81539: CALL_OW 255
81543: ST_TO_ADDR
// x := GetX ( tower ) ;
81544: LD_ADDR_VAR 0 10
81548: PUSH
81549: LD_VAR 0 1
81553: PPUSH
81554: CALL_OW 250
81558: ST_TO_ADDR
// y := GetY ( tower ) ;
81559: LD_ADDR_VAR 0 11
81563: PUSH
81564: LD_VAR 0 1
81568: PPUSH
81569: CALL_OW 251
81573: ST_TO_ADDR
// if not x or not y then
81574: LD_VAR 0 10
81578: NOT
81579: IFTRUE 81588
81581: PUSH
81582: LD_VAR 0 11
81586: NOT
81587: OR
81588: IFFALSE 81592
// exit ;
81590: GO 82649
// weapon := 0 ;
81592: LD_ADDR_VAR 0 18
81596: PUSH
81597: LD_INT 0
81599: ST_TO_ADDR
// fac_list := [ ] ;
81600: LD_ADDR_VAR 0 17
81604: PUSH
81605: EMPTY
81606: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
81607: LD_ADDR_VAR 0 6
81611: PUSH
81612: LD_VAR 0 1
81616: PPUSH
81617: CALL_OW 274
81621: PPUSH
81622: LD_VAR 0 2
81626: PPUSH
81627: LD_INT 0
81629: PPUSH
81630: CALL 79184 0 3
81634: PPUSH
81635: LD_INT 30
81637: PUSH
81638: LD_INT 3
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PPUSH
81645: CALL_OW 72
81649: ST_TO_ADDR
// if not factories then
81650: LD_VAR 0 6
81654: NOT
81655: IFFALSE 81659
// exit ;
81657: GO 82649
// for i in factories do
81659: LD_ADDR_VAR 0 8
81663: PUSH
81664: LD_VAR 0 6
81668: PUSH
81669: FOR_IN
81670: IFFALSE 81695
// fac_list := fac_list union AvailableWeaponList ( i ) ;
81672: LD_ADDR_VAR 0 17
81676: PUSH
81677: LD_VAR 0 17
81681: PUSH
81682: LD_VAR 0 8
81686: PPUSH
81687: CALL_OW 478
81691: UNION
81692: ST_TO_ADDR
81693: GO 81669
81695: POP
81696: POP
// if not fac_list then
81697: LD_VAR 0 17
81701: NOT
81702: IFFALSE 81706
// exit ;
81704: GO 82649
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
81706: LD_ADDR_VAR 0 5
81710: PUSH
81711: LD_INT 4
81713: PUSH
81714: LD_INT 5
81716: PUSH
81717: LD_INT 9
81719: PUSH
81720: LD_INT 10
81722: PUSH
81723: LD_INT 6
81725: PUSH
81726: LD_INT 7
81728: PUSH
81729: LD_INT 11
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 27
81743: PUSH
81744: LD_INT 28
81746: PUSH
81747: LD_INT 26
81749: PUSH
81750: LD_INT 30
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 43
81761: PUSH
81762: LD_INT 44
81764: PUSH
81765: LD_INT 46
81767: PUSH
81768: LD_INT 45
81770: PUSH
81771: LD_INT 47
81773: PUSH
81774: LD_INT 49
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: LIST
81789: PUSH
81790: LD_VAR 0 12
81794: ARRAY
81795: ST_TO_ADDR
// list := list isect fac_list ;
81796: LD_ADDR_VAR 0 5
81800: PUSH
81801: LD_VAR 0 5
81805: PUSH
81806: LD_VAR 0 17
81810: ISECT
81811: ST_TO_ADDR
// if not list then
81812: LD_VAR 0 5
81816: NOT
81817: IFFALSE 81821
// exit ;
81819: GO 82649
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81821: LD_VAR 0 12
81825: PUSH
81826: LD_INT 3
81828: EQUAL
81829: IFFALSE 81841
81831: PUSH
81832: LD_INT 49
81834: PUSH
81835: LD_VAR 0 5
81839: IN
81840: AND
81841: IFFALSE 81861
81843: PUSH
81844: LD_INT 31
81846: PPUSH
81847: LD_VAR 0 16
81851: PPUSH
81852: CALL_OW 321
81856: PUSH
81857: LD_INT 2
81859: EQUAL
81860: AND
81861: IFFALSE 81921
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81863: LD_INT 22
81865: PUSH
81866: LD_VAR 0 16
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 35
81877: PUSH
81878: LD_INT 49
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 91
81887: PUSH
81888: LD_VAR 0 1
81892: PUSH
81893: LD_INT 10
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: LIST
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: LIST
81905: PPUSH
81906: CALL_OW 69
81910: NOT
81911: IFFALSE 81921
// weapon := ru_time_lapser ;
81913: LD_ADDR_VAR 0 18
81917: PUSH
81918: LD_INT 49
81920: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81921: LD_VAR 0 12
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: LD_INT 2
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: IN
81936: IFFALSE 81960
81938: PUSH
81939: LD_INT 11
81941: PUSH
81942: LD_VAR 0 5
81946: IN
81947: IFTRUE 81959
81949: PUSH
81950: LD_INT 30
81952: PUSH
81953: LD_VAR 0 5
81957: IN
81958: OR
81959: AND
81960: IFFALSE 81980
81962: PUSH
81963: LD_INT 6
81965: PPUSH
81966: LD_VAR 0 16
81970: PPUSH
81971: CALL_OW 321
81975: PUSH
81976: LD_INT 2
81978: EQUAL
81979: AND
81980: IFFALSE 82147
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81982: LD_INT 22
81984: PUSH
81985: LD_VAR 0 16
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 2
81996: PUSH
81997: LD_INT 35
81999: PUSH
82000: LD_INT 11
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 35
82009: PUSH
82010: LD_INT 30
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 91
82024: PUSH
82025: LD_VAR 0 1
82029: PUSH
82030: LD_INT 18
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: LIST
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: LIST
82042: PPUSH
82043: CALL_OW 69
82047: NOT
82048: IFFALSE 82124
82050: PUSH
82051: LD_INT 22
82053: PUSH
82054: LD_VAR 0 16
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 2
82065: PUSH
82066: LD_INT 30
82068: PUSH
82069: LD_INT 32
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 30
82078: PUSH
82079: LD_INT 33
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 91
82093: PUSH
82094: LD_VAR 0 1
82098: PUSH
82099: LD_INT 12
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: LIST
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: LIST
82111: PUSH
82112: EMPTY
82113: LIST
82114: PPUSH
82115: CALL_OW 69
82119: PUSH
82120: LD_INT 2
82122: GREATER
82123: AND
82124: IFFALSE 82147
// weapon := [ us_radar , ar_radar ] [ nat ] ;
82126: LD_ADDR_VAR 0 18
82130: PUSH
82131: LD_INT 11
82133: PUSH
82134: LD_INT 30
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_VAR 0 12
82145: ARRAY
82146: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
82147: LD_VAR 0 18
82151: NOT
82152: IFFALSE 82172
82154: PUSH
82155: LD_INT 40
82157: PPUSH
82158: LD_VAR 0 16
82162: PPUSH
82163: CALL_OW 321
82167: PUSH
82168: LD_INT 2
82170: EQUAL
82171: AND
82172: IFFALSE 82208
82174: PUSH
82175: LD_INT 7
82177: PUSH
82178: LD_VAR 0 5
82182: IN
82183: IFTRUE 82195
82185: PUSH
82186: LD_INT 28
82188: PUSH
82189: LD_VAR 0 5
82193: IN
82194: OR
82195: IFTRUE 82207
82197: PUSH
82198: LD_INT 45
82200: PUSH
82201: LD_VAR 0 5
82205: IN
82206: OR
82207: AND
82208: IFFALSE 82462
// begin hex := GetHexInfo ( x , y ) ;
82210: LD_ADDR_VAR 0 4
82214: PUSH
82215: LD_VAR 0 10
82219: PPUSH
82220: LD_VAR 0 11
82224: PPUSH
82225: CALL_OW 546
82229: ST_TO_ADDR
// if hex [ 1 ] then
82230: LD_VAR 0 4
82234: PUSH
82235: LD_INT 1
82237: ARRAY
82238: IFFALSE 82242
// exit ;
82240: GO 82649
// height := hex [ 2 ] ;
82242: LD_ADDR_VAR 0 15
82246: PUSH
82247: LD_VAR 0 4
82251: PUSH
82252: LD_INT 2
82254: ARRAY
82255: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
82256: LD_ADDR_VAR 0 14
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: LD_INT 2
82266: PUSH
82267: LD_INT 3
82269: PUSH
82270: LD_INT 5
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: ST_TO_ADDR
// for i in tmp do
82279: LD_ADDR_VAR 0 8
82283: PUSH
82284: LD_VAR 0 14
82288: PUSH
82289: FOR_IN
82290: IFFALSE 82460
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
82292: LD_ADDR_VAR 0 9
82296: PUSH
82297: LD_VAR 0 10
82301: PPUSH
82302: LD_VAR 0 8
82306: PPUSH
82307: LD_INT 5
82309: PPUSH
82310: CALL_OW 272
82314: PUSH
82315: LD_VAR 0 11
82319: PPUSH
82320: LD_VAR 0 8
82324: PPUSH
82325: LD_INT 5
82327: PPUSH
82328: CALL_OW 273
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82337: LD_VAR 0 9
82341: PUSH
82342: LD_INT 1
82344: ARRAY
82345: PPUSH
82346: LD_VAR 0 9
82350: PUSH
82351: LD_INT 2
82353: ARRAY
82354: PPUSH
82355: CALL_OW 488
82359: IFFALSE 82458
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
82361: LD_ADDR_VAR 0 4
82365: PUSH
82366: LD_VAR 0 9
82370: PUSH
82371: LD_INT 1
82373: ARRAY
82374: PPUSH
82375: LD_VAR 0 9
82379: PUSH
82380: LD_INT 2
82382: ARRAY
82383: PPUSH
82384: CALL_OW 546
82388: ST_TO_ADDR
// if hex [ 1 ] then
82389: LD_VAR 0 4
82393: PUSH
82394: LD_INT 1
82396: ARRAY
82397: IFFALSE 82401
// continue ;
82399: GO 82289
// h := hex [ 2 ] ;
82401: LD_ADDR_VAR 0 13
82405: PUSH
82406: LD_VAR 0 4
82410: PUSH
82411: LD_INT 2
82413: ARRAY
82414: ST_TO_ADDR
// if h + 7 < height then
82415: LD_VAR 0 13
82419: PUSH
82420: LD_INT 7
82422: PLUS
82423: PUSH
82424: LD_VAR 0 15
82428: LESS
82429: IFFALSE 82458
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
82431: LD_ADDR_VAR 0 18
82435: PUSH
82436: LD_INT 7
82438: PUSH
82439: LD_INT 28
82441: PUSH
82442: LD_INT 45
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: LIST
82449: PUSH
82450: LD_VAR 0 12
82454: ARRAY
82455: ST_TO_ADDR
// break ;
82456: GO 82460
// end ; end ; end ;
82458: GO 82289
82460: POP
82461: POP
// end ; if not weapon then
82462: LD_VAR 0 18
82466: NOT
82467: IFFALSE 82527
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
82469: LD_ADDR_VAR 0 5
82473: PUSH
82474: LD_VAR 0 5
82478: PUSH
82479: LD_INT 11
82481: PUSH
82482: LD_INT 30
82484: PUSH
82485: LD_INT 49
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: LIST
82492: DIFF
82493: ST_TO_ADDR
// if not list then
82494: LD_VAR 0 5
82498: NOT
82499: IFFALSE 82503
// exit ;
82501: GO 82649
// weapon := list [ rand ( 1 , list ) ] ;
82503: LD_ADDR_VAR 0 18
82507: PUSH
82508: LD_VAR 0 5
82512: PUSH
82513: LD_INT 1
82515: PPUSH
82516: LD_VAR 0 5
82520: PPUSH
82521: CALL_OW 12
82525: ARRAY
82526: ST_TO_ADDR
// end ; if weapon then
82527: LD_VAR 0 18
82531: IFFALSE 82649
// begin tmp := CostOfWeapon ( weapon ) ;
82533: LD_ADDR_VAR 0 14
82537: PUSH
82538: LD_VAR 0 18
82542: PPUSH
82543: CALL_OW 451
82547: ST_TO_ADDR
// j := GetBase ( tower ) ;
82548: LD_ADDR_VAR 0 9
82552: PUSH
82553: LD_VAR 0 1
82557: PPUSH
82558: CALL_OW 274
82562: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
82563: LD_VAR 0 9
82567: PPUSH
82568: LD_INT 1
82570: PPUSH
82571: CALL_OW 275
82575: PUSH
82576: LD_VAR 0 14
82580: PUSH
82581: LD_INT 1
82583: ARRAY
82584: GREATEREQUAL
82585: IFFALSE 82611
82587: PUSH
82588: LD_VAR 0 9
82592: PPUSH
82593: LD_INT 2
82595: PPUSH
82596: CALL_OW 275
82600: PUSH
82601: LD_VAR 0 14
82605: PUSH
82606: LD_INT 2
82608: ARRAY
82609: GREATEREQUAL
82610: AND
82611: IFFALSE 82637
82613: PUSH
82614: LD_VAR 0 9
82618: PPUSH
82619: LD_INT 3
82621: PPUSH
82622: CALL_OW 275
82626: PUSH
82627: LD_VAR 0 14
82631: PUSH
82632: LD_INT 3
82634: ARRAY
82635: GREATEREQUAL
82636: AND
82637: IFFALSE 82649
// result := weapon ;
82639: LD_ADDR_VAR 0 3
82643: PUSH
82644: LD_VAR 0 18
82648: ST_TO_ADDR
// end ; end ;
82649: LD_VAR 0 3
82653: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
82654: LD_INT 0
82656: PPUSH
82657: PPUSH
// result := true ;
82658: LD_ADDR_VAR 0 3
82662: PUSH
82663: LD_INT 1
82665: ST_TO_ADDR
// if array1 = array2 then
82666: LD_VAR 0 1
82670: PUSH
82671: LD_VAR 0 2
82675: EQUAL
82676: IFFALSE 82736
// begin for i = 1 to array1 do
82678: LD_ADDR_VAR 0 4
82682: PUSH
82683: DOUBLE
82684: LD_INT 1
82686: DEC
82687: ST_TO_ADDR
82688: LD_VAR 0 1
82692: PUSH
82693: FOR_TO
82694: IFFALSE 82732
// if array1 [ i ] <> array2 [ i ] then
82696: LD_VAR 0 1
82700: PUSH
82701: LD_VAR 0 4
82705: ARRAY
82706: PUSH
82707: LD_VAR 0 2
82711: PUSH
82712: LD_VAR 0 4
82716: ARRAY
82717: NONEQUAL
82718: IFFALSE 82730
// begin result := false ;
82720: LD_ADDR_VAR 0 3
82724: PUSH
82725: LD_INT 0
82727: ST_TO_ADDR
// break ;
82728: GO 82732
// end ;
82730: GO 82693
82732: POP
82733: POP
// end else
82734: GO 82744
// result := false ;
82736: LD_ADDR_VAR 0 3
82740: PUSH
82741: LD_INT 0
82743: ST_TO_ADDR
// end ;
82744: LD_VAR 0 3
82748: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
82749: LD_INT 0
82751: PPUSH
82752: PPUSH
// if not array1 or not array2 then
82753: LD_VAR 0 1
82757: NOT
82758: IFTRUE 82767
82760: PUSH
82761: LD_VAR 0 2
82765: NOT
82766: OR
82767: IFFALSE 82771
// exit ;
82769: GO 82835
// result := true ;
82771: LD_ADDR_VAR 0 3
82775: PUSH
82776: LD_INT 1
82778: ST_TO_ADDR
// for i = 1 to array1 do
82779: LD_ADDR_VAR 0 4
82783: PUSH
82784: DOUBLE
82785: LD_INT 1
82787: DEC
82788: ST_TO_ADDR
82789: LD_VAR 0 1
82793: PUSH
82794: FOR_TO
82795: IFFALSE 82833
// if array1 [ i ] <> array2 [ i ] then
82797: LD_VAR 0 1
82801: PUSH
82802: LD_VAR 0 4
82806: ARRAY
82807: PUSH
82808: LD_VAR 0 2
82812: PUSH
82813: LD_VAR 0 4
82817: ARRAY
82818: NONEQUAL
82819: IFFALSE 82831
// begin result := false ;
82821: LD_ADDR_VAR 0 3
82825: PUSH
82826: LD_INT 0
82828: ST_TO_ADDR
// break ;
82829: GO 82833
// end ;
82831: GO 82794
82833: POP
82834: POP
// end ;
82835: LD_VAR 0 3
82839: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
82840: LD_INT 0
82842: PPUSH
82843: PPUSH
82844: PPUSH
// pom := GetBase ( fac ) ;
82845: LD_ADDR_VAR 0 5
82849: PUSH
82850: LD_VAR 0 1
82854: PPUSH
82855: CALL_OW 274
82859: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82860: LD_ADDR_VAR 0 4
82864: PUSH
82865: LD_VAR 0 2
82869: PUSH
82870: LD_INT 1
82872: ARRAY
82873: PPUSH
82874: LD_VAR 0 2
82878: PUSH
82879: LD_INT 2
82881: ARRAY
82882: PPUSH
82883: LD_VAR 0 2
82887: PUSH
82888: LD_INT 3
82890: ARRAY
82891: PPUSH
82892: LD_VAR 0 2
82896: PUSH
82897: LD_INT 4
82899: ARRAY
82900: PPUSH
82901: CALL_OW 449
82905: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82906: LD_ADDR_VAR 0 3
82910: PUSH
82911: LD_VAR 0 5
82915: PPUSH
82916: LD_INT 1
82918: PPUSH
82919: CALL_OW 275
82923: PUSH
82924: LD_VAR 0 4
82928: PUSH
82929: LD_INT 1
82931: ARRAY
82932: GREATEREQUAL
82933: IFFALSE 82959
82935: PUSH
82936: LD_VAR 0 5
82940: PPUSH
82941: LD_INT 2
82943: PPUSH
82944: CALL_OW 275
82948: PUSH
82949: LD_VAR 0 4
82953: PUSH
82954: LD_INT 2
82956: ARRAY
82957: GREATEREQUAL
82958: AND
82959: IFFALSE 82985
82961: PUSH
82962: LD_VAR 0 5
82966: PPUSH
82967: LD_INT 3
82969: PPUSH
82970: CALL_OW 275
82974: PUSH
82975: LD_VAR 0 4
82979: PUSH
82980: LD_INT 3
82982: ARRAY
82983: GREATEREQUAL
82984: AND
82985: ST_TO_ADDR
// end ;
82986: LD_VAR 0 3
82990: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82991: LD_INT 0
82993: PPUSH
82994: PPUSH
82995: PPUSH
82996: PPUSH
// pom := GetBase ( building ) ;
82997: LD_ADDR_VAR 0 3
83001: PUSH
83002: LD_VAR 0 1
83006: PPUSH
83007: CALL_OW 274
83011: ST_TO_ADDR
// if not pom then
83012: LD_VAR 0 3
83016: NOT
83017: IFFALSE 83021
// exit ;
83019: GO 83195
// btype := GetBType ( building ) ;
83021: LD_ADDR_VAR 0 5
83025: PUSH
83026: LD_VAR 0 1
83030: PPUSH
83031: CALL_OW 266
83035: ST_TO_ADDR
// if btype = b_armoury then
83036: LD_VAR 0 5
83040: PUSH
83041: LD_INT 4
83043: EQUAL
83044: IFFALSE 83054
// btype := b_barracks ;
83046: LD_ADDR_VAR 0 5
83050: PUSH
83051: LD_INT 5
83053: ST_TO_ADDR
// if btype = b_depot then
83054: LD_VAR 0 5
83058: PUSH
83059: LD_INT 0
83061: EQUAL
83062: IFFALSE 83072
// btype := b_warehouse ;
83064: LD_ADDR_VAR 0 5
83068: PUSH
83069: LD_INT 1
83071: ST_TO_ADDR
// if btype = b_workshop then
83072: LD_VAR 0 5
83076: PUSH
83077: LD_INT 2
83079: EQUAL
83080: IFFALSE 83090
// btype := b_factory ;
83082: LD_ADDR_VAR 0 5
83086: PUSH
83087: LD_INT 3
83089: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83090: LD_ADDR_VAR 0 4
83094: PUSH
83095: LD_VAR 0 5
83099: PPUSH
83100: LD_VAR 0 1
83104: PPUSH
83105: CALL_OW 248
83109: PPUSH
83110: CALL_OW 450
83114: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83115: LD_ADDR_VAR 0 2
83119: PUSH
83120: LD_VAR 0 3
83124: PPUSH
83125: LD_INT 1
83127: PPUSH
83128: CALL_OW 275
83132: PUSH
83133: LD_VAR 0 4
83137: PUSH
83138: LD_INT 1
83140: ARRAY
83141: GREATEREQUAL
83142: IFFALSE 83168
83144: PUSH
83145: LD_VAR 0 3
83149: PPUSH
83150: LD_INT 2
83152: PPUSH
83153: CALL_OW 275
83157: PUSH
83158: LD_VAR 0 4
83162: PUSH
83163: LD_INT 2
83165: ARRAY
83166: GREATEREQUAL
83167: AND
83168: IFFALSE 83194
83170: PUSH
83171: LD_VAR 0 3
83175: PPUSH
83176: LD_INT 3
83178: PPUSH
83179: CALL_OW 275
83183: PUSH
83184: LD_VAR 0 4
83188: PUSH
83189: LD_INT 3
83191: ARRAY
83192: GREATEREQUAL
83193: AND
83194: ST_TO_ADDR
// end ;
83195: LD_VAR 0 2
83199: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
83200: LD_INT 0
83202: PPUSH
83203: PPUSH
83204: PPUSH
// pom := GetBase ( building ) ;
83205: LD_ADDR_VAR 0 4
83209: PUSH
83210: LD_VAR 0 1
83214: PPUSH
83215: CALL_OW 274
83219: ST_TO_ADDR
// if not pom then
83220: LD_VAR 0 4
83224: NOT
83225: IFFALSE 83229
// exit ;
83227: GO 83334
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83229: LD_ADDR_VAR 0 5
83233: PUSH
83234: LD_VAR 0 2
83238: PPUSH
83239: LD_VAR 0 1
83243: PPUSH
83244: CALL_OW 248
83248: PPUSH
83249: CALL_OW 450
83253: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83254: LD_ADDR_VAR 0 3
83258: PUSH
83259: LD_VAR 0 4
83263: PPUSH
83264: LD_INT 1
83266: PPUSH
83267: CALL_OW 275
83271: PUSH
83272: LD_VAR 0 5
83276: PUSH
83277: LD_INT 1
83279: ARRAY
83280: GREATEREQUAL
83281: IFFALSE 83307
83283: PUSH
83284: LD_VAR 0 4
83288: PPUSH
83289: LD_INT 2
83291: PPUSH
83292: CALL_OW 275
83296: PUSH
83297: LD_VAR 0 5
83301: PUSH
83302: LD_INT 2
83304: ARRAY
83305: GREATEREQUAL
83306: AND
83307: IFFALSE 83333
83309: PUSH
83310: LD_VAR 0 4
83314: PPUSH
83315: LD_INT 3
83317: PPUSH
83318: CALL_OW 275
83322: PUSH
83323: LD_VAR 0 5
83327: PUSH
83328: LD_INT 3
83330: ARRAY
83331: GREATEREQUAL
83332: AND
83333: ST_TO_ADDR
// end ;
83334: LD_VAR 0 3
83338: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
83339: LD_INT 0
83341: PPUSH
83342: PPUSH
83343: PPUSH
83344: PPUSH
83345: PPUSH
83346: PPUSH
83347: PPUSH
83348: PPUSH
83349: PPUSH
83350: PPUSH
83351: PPUSH
// result := false ;
83352: LD_ADDR_VAR 0 8
83356: PUSH
83357: LD_INT 0
83359: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
83360: LD_VAR 0 5
83364: NOT
83365: IFTRUE 83374
83367: PUSH
83368: LD_VAR 0 1
83372: NOT
83373: OR
83374: IFTRUE 83383
83376: PUSH
83377: LD_VAR 0 2
83381: NOT
83382: OR
83383: IFTRUE 83392
83385: PUSH
83386: LD_VAR 0 3
83390: NOT
83391: OR
83392: IFFALSE 83396
// exit ;
83394: GO 84222
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
83396: LD_ADDR_VAR 0 14
83400: PUSH
83401: LD_VAR 0 1
83405: PPUSH
83406: LD_VAR 0 2
83410: PPUSH
83411: LD_VAR 0 3
83415: PPUSH
83416: LD_VAR 0 4
83420: PPUSH
83421: LD_VAR 0 5
83425: PUSH
83426: LD_INT 1
83428: ARRAY
83429: PPUSH
83430: CALL_OW 248
83434: PPUSH
83435: LD_INT 0
83437: PPUSH
83438: CALL 85503 0 6
83442: ST_TO_ADDR
// if not hexes then
83443: LD_VAR 0 14
83447: NOT
83448: IFFALSE 83452
// exit ;
83450: GO 84222
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
83452: LD_ADDR_VAR 0 17
83456: PUSH
83457: LD_VAR 0 5
83461: PPUSH
83462: LD_INT 22
83464: PUSH
83465: LD_VAR 0 13
83469: PPUSH
83470: CALL_OW 255
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 2
83481: PUSH
83482: LD_INT 30
83484: PUSH
83485: LD_INT 0
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PUSH
83492: LD_INT 30
83494: PUSH
83495: LD_INT 1
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: LIST
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PPUSH
83511: CALL_OW 72
83515: ST_TO_ADDR
// for i = 1 to hexes do
83516: LD_ADDR_VAR 0 9
83520: PUSH
83521: DOUBLE
83522: LD_INT 1
83524: DEC
83525: ST_TO_ADDR
83526: LD_VAR 0 14
83530: PUSH
83531: FOR_TO
83532: IFFALSE 84220
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83534: LD_ADDR_VAR 0 13
83538: PUSH
83539: LD_VAR 0 14
83543: PUSH
83544: LD_VAR 0 9
83548: ARRAY
83549: PUSH
83550: LD_INT 1
83552: ARRAY
83553: PPUSH
83554: LD_VAR 0 14
83558: PUSH
83559: LD_VAR 0 9
83563: ARRAY
83564: PUSH
83565: LD_INT 2
83567: ARRAY
83568: PPUSH
83569: CALL_OW 428
83573: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
83574: LD_VAR 0 14
83578: PUSH
83579: LD_VAR 0 9
83583: ARRAY
83584: PUSH
83585: LD_INT 1
83587: ARRAY
83588: PPUSH
83589: LD_VAR 0 14
83593: PUSH
83594: LD_VAR 0 9
83598: ARRAY
83599: PUSH
83600: LD_INT 2
83602: ARRAY
83603: PPUSH
83604: CALL_OW 351
83608: IFTRUE 83647
83610: PUSH
83611: LD_VAR 0 14
83615: PUSH
83616: LD_VAR 0 9
83620: ARRAY
83621: PUSH
83622: LD_INT 1
83624: ARRAY
83625: PPUSH
83626: LD_VAR 0 14
83630: PUSH
83631: LD_VAR 0 9
83635: ARRAY
83636: PUSH
83637: LD_INT 2
83639: ARRAY
83640: PPUSH
83641: CALL_OW 488
83645: NOT
83646: OR
83647: IFTRUE 83664
83649: PUSH
83650: LD_VAR 0 13
83654: PPUSH
83655: CALL_OW 247
83659: PUSH
83660: LD_INT 3
83662: EQUAL
83663: OR
83664: IFFALSE 83670
// exit ;
83666: POP
83667: POP
83668: GO 84222
// if not tmp then
83670: LD_VAR 0 13
83674: NOT
83675: IFFALSE 83679
// continue ;
83677: GO 83531
// result := true ;
83679: LD_ADDR_VAR 0 8
83683: PUSH
83684: LD_INT 1
83686: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
83687: LD_VAR 0 6
83691: IFFALSE 83708
83693: PUSH
83694: LD_VAR 0 13
83698: PPUSH
83699: CALL_OW 247
83703: PUSH
83704: LD_INT 2
83706: EQUAL
83707: AND
83708: IFFALSE 83725
83710: PUSH
83711: LD_VAR 0 13
83715: PPUSH
83716: CALL_OW 263
83720: PUSH
83721: LD_INT 1
83723: EQUAL
83724: AND
83725: IFFALSE 83889
// begin if IsDrivenBy ( tmp ) then
83727: LD_VAR 0 13
83731: PPUSH
83732: CALL_OW 311
83736: IFFALSE 83740
// continue ;
83738: GO 83531
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
83740: LD_VAR 0 6
83744: PPUSH
83745: LD_INT 3
83747: PUSH
83748: LD_INT 60
83750: PUSH
83751: EMPTY
83752: LIST
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 3
83760: PUSH
83761: LD_INT 55
83763: PUSH
83764: EMPTY
83765: LIST
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PPUSH
83775: CALL_OW 72
83779: IFFALSE 83887
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
83781: LD_ADDR_VAR 0 18
83785: PUSH
83786: LD_VAR 0 6
83790: PPUSH
83791: LD_INT 3
83793: PUSH
83794: LD_INT 60
83796: PUSH
83797: EMPTY
83798: LIST
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 3
83806: PUSH
83807: LD_INT 55
83809: PUSH
83810: EMPTY
83811: LIST
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PPUSH
83821: CALL_OW 72
83825: PUSH
83826: LD_INT 1
83828: ARRAY
83829: ST_TO_ADDR
// if IsInUnit ( driver ) then
83830: LD_VAR 0 18
83834: PPUSH
83835: CALL_OW 310
83839: IFFALSE 83850
// ComExit ( driver ) ;
83841: LD_VAR 0 18
83845: PPUSH
83846: CALL 109493 0 1
// AddComEnterUnit ( driver , tmp ) ;
83850: LD_VAR 0 18
83854: PPUSH
83855: LD_VAR 0 13
83859: PPUSH
83860: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
83864: LD_VAR 0 18
83868: PPUSH
83869: LD_VAR 0 7
83873: PPUSH
83874: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83878: LD_VAR 0 18
83882: PPUSH
83883: CALL_OW 181
// end ; continue ;
83887: GO 83531
// end ; if not cleaners or not tmp in cleaners then
83889: LD_VAR 0 6
83893: NOT
83894: IFTRUE 83909
83896: PUSH
83897: LD_VAR 0 13
83901: PUSH
83902: LD_VAR 0 6
83906: IN
83907: NOT
83908: OR
83909: IFFALSE 84218
// begin if dep then
83911: LD_VAR 0 17
83915: IFFALSE 84051
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83917: LD_ADDR_VAR 0 16
83921: PUSH
83922: LD_VAR 0 17
83926: PUSH
83927: LD_INT 1
83929: ARRAY
83930: PPUSH
83931: CALL_OW 250
83935: PPUSH
83936: LD_VAR 0 17
83940: PUSH
83941: LD_INT 1
83943: ARRAY
83944: PPUSH
83945: CALL_OW 254
83949: PPUSH
83950: LD_INT 5
83952: PPUSH
83953: CALL_OW 272
83957: PUSH
83958: LD_VAR 0 17
83962: PUSH
83963: LD_INT 1
83965: ARRAY
83966: PPUSH
83967: CALL_OW 251
83971: PPUSH
83972: LD_VAR 0 17
83976: PUSH
83977: LD_INT 1
83979: ARRAY
83980: PPUSH
83981: CALL_OW 254
83985: PPUSH
83986: LD_INT 5
83988: PPUSH
83989: CALL_OW 273
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83998: LD_VAR 0 16
84002: PUSH
84003: LD_INT 1
84005: ARRAY
84006: PPUSH
84007: LD_VAR 0 16
84011: PUSH
84012: LD_INT 2
84014: ARRAY
84015: PPUSH
84016: CALL_OW 488
84020: IFFALSE 84051
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
84022: LD_VAR 0 13
84026: PPUSH
84027: LD_VAR 0 16
84031: PUSH
84032: LD_INT 1
84034: ARRAY
84035: PPUSH
84036: LD_VAR 0 16
84040: PUSH
84041: LD_INT 2
84043: ARRAY
84044: PPUSH
84045: CALL_OW 111
// continue ;
84049: GO 83531
// end ; end ; r := GetDir ( tmp ) ;
84051: LD_ADDR_VAR 0 15
84055: PUSH
84056: LD_VAR 0 13
84060: PPUSH
84061: CALL_OW 254
84065: ST_TO_ADDR
// if r = 5 then
84066: LD_VAR 0 15
84070: PUSH
84071: LD_INT 5
84073: EQUAL
84074: IFFALSE 84084
// r := 0 ;
84076: LD_ADDR_VAR 0 15
84080: PUSH
84081: LD_INT 0
84083: ST_TO_ADDR
// for j = r to 5 do
84084: LD_ADDR_VAR 0 10
84088: PUSH
84089: DOUBLE
84090: LD_VAR 0 15
84094: DEC
84095: ST_TO_ADDR
84096: LD_INT 5
84098: PUSH
84099: FOR_TO
84100: IFFALSE 84216
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
84102: LD_ADDR_VAR 0 11
84106: PUSH
84107: LD_VAR 0 13
84111: PPUSH
84112: CALL_OW 250
84116: PPUSH
84117: LD_VAR 0 10
84121: PPUSH
84122: LD_INT 2
84124: PPUSH
84125: CALL_OW 272
84129: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
84130: LD_ADDR_VAR 0 12
84134: PUSH
84135: LD_VAR 0 13
84139: PPUSH
84140: CALL_OW 251
84144: PPUSH
84145: LD_VAR 0 10
84149: PPUSH
84150: LD_INT 2
84152: PPUSH
84153: CALL_OW 273
84157: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
84158: LD_VAR 0 11
84162: PPUSH
84163: LD_VAR 0 12
84167: PPUSH
84168: CALL_OW 488
84172: IFFALSE 84191
84174: PUSH
84175: LD_VAR 0 11
84179: PPUSH
84180: LD_VAR 0 12
84184: PPUSH
84185: CALL_OW 428
84189: NOT
84190: AND
84191: IFFALSE 84214
// begin ComMoveXY ( tmp , _x , _y ) ;
84193: LD_VAR 0 13
84197: PPUSH
84198: LD_VAR 0 11
84202: PPUSH
84203: LD_VAR 0 12
84207: PPUSH
84208: CALL_OW 111
// break ;
84212: GO 84216
// end ; end ;
84214: GO 84099
84216: POP
84217: POP
// end ; end ;
84218: GO 83531
84220: POP
84221: POP
// end ;
84222: LD_VAR 0 8
84226: RET
// export function BuildingTechInvented ( side , btype ) ; begin
84227: LD_INT 0
84229: PPUSH
// result := true ;
84230: LD_ADDR_VAR 0 3
84234: PUSH
84235: LD_INT 1
84237: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
84238: LD_VAR 0 2
84242: PUSH
84243: LD_INT 24
84245: DOUBLE
84246: EQUAL
84247: IFTRUE 84257
84249: LD_INT 33
84251: DOUBLE
84252: EQUAL
84253: IFTRUE 84257
84255: GO 84282
84257: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
84258: LD_ADDR_VAR 0 3
84262: PUSH
84263: LD_INT 32
84265: PPUSH
84266: LD_VAR 0 1
84270: PPUSH
84271: CALL_OW 321
84275: PUSH
84276: LD_INT 2
84278: EQUAL
84279: ST_TO_ADDR
84280: GO 84598
84282: LD_INT 20
84284: DOUBLE
84285: EQUAL
84286: IFTRUE 84290
84288: GO 84315
84290: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
84291: LD_ADDR_VAR 0 3
84295: PUSH
84296: LD_INT 6
84298: PPUSH
84299: LD_VAR 0 1
84303: PPUSH
84304: CALL_OW 321
84308: PUSH
84309: LD_INT 2
84311: EQUAL
84312: ST_TO_ADDR
84313: GO 84598
84315: LD_INT 22
84317: DOUBLE
84318: EQUAL
84319: IFTRUE 84329
84321: LD_INT 36
84323: DOUBLE
84324: EQUAL
84325: IFTRUE 84329
84327: GO 84354
84329: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
84330: LD_ADDR_VAR 0 3
84334: PUSH
84335: LD_INT 15
84337: PPUSH
84338: LD_VAR 0 1
84342: PPUSH
84343: CALL_OW 321
84347: PUSH
84348: LD_INT 2
84350: EQUAL
84351: ST_TO_ADDR
84352: GO 84598
84354: LD_INT 30
84356: DOUBLE
84357: EQUAL
84358: IFTRUE 84362
84360: GO 84387
84362: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
84363: LD_ADDR_VAR 0 3
84367: PUSH
84368: LD_INT 20
84370: PPUSH
84371: LD_VAR 0 1
84375: PPUSH
84376: CALL_OW 321
84380: PUSH
84381: LD_INT 2
84383: EQUAL
84384: ST_TO_ADDR
84385: GO 84598
84387: LD_INT 28
84389: DOUBLE
84390: EQUAL
84391: IFTRUE 84401
84393: LD_INT 21
84395: DOUBLE
84396: EQUAL
84397: IFTRUE 84401
84399: GO 84426
84401: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
84402: LD_ADDR_VAR 0 3
84406: PUSH
84407: LD_INT 21
84409: PPUSH
84410: LD_VAR 0 1
84414: PPUSH
84415: CALL_OW 321
84419: PUSH
84420: LD_INT 2
84422: EQUAL
84423: ST_TO_ADDR
84424: GO 84598
84426: LD_INT 16
84428: DOUBLE
84429: EQUAL
84430: IFTRUE 84434
84432: GO 84459
84434: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
84435: LD_ADDR_VAR 0 3
84439: PUSH
84440: LD_INT 84
84442: PPUSH
84443: LD_VAR 0 1
84447: PPUSH
84448: CALL_OW 321
84452: PUSH
84453: LD_INT 2
84455: EQUAL
84456: ST_TO_ADDR
84457: GO 84598
84459: LD_INT 19
84461: DOUBLE
84462: EQUAL
84463: IFTRUE 84473
84465: LD_INT 23
84467: DOUBLE
84468: EQUAL
84469: IFTRUE 84473
84471: GO 84498
84473: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
84474: LD_ADDR_VAR 0 3
84478: PUSH
84479: LD_INT 83
84481: PPUSH
84482: LD_VAR 0 1
84486: PPUSH
84487: CALL_OW 321
84491: PUSH
84492: LD_INT 2
84494: EQUAL
84495: ST_TO_ADDR
84496: GO 84598
84498: LD_INT 17
84500: DOUBLE
84501: EQUAL
84502: IFTRUE 84506
84504: GO 84531
84506: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
84507: LD_ADDR_VAR 0 3
84511: PUSH
84512: LD_INT 39
84514: PPUSH
84515: LD_VAR 0 1
84519: PPUSH
84520: CALL_OW 321
84524: PUSH
84525: LD_INT 2
84527: EQUAL
84528: ST_TO_ADDR
84529: GO 84598
84531: LD_INT 18
84533: DOUBLE
84534: EQUAL
84535: IFTRUE 84539
84537: GO 84564
84539: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
84540: LD_ADDR_VAR 0 3
84544: PUSH
84545: LD_INT 40
84547: PPUSH
84548: LD_VAR 0 1
84552: PPUSH
84553: CALL_OW 321
84557: PUSH
84558: LD_INT 2
84560: EQUAL
84561: ST_TO_ADDR
84562: GO 84598
84564: LD_INT 27
84566: DOUBLE
84567: EQUAL
84568: IFTRUE 84572
84570: GO 84597
84572: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
84573: LD_ADDR_VAR 0 3
84577: PUSH
84578: LD_INT 35
84580: PPUSH
84581: LD_VAR 0 1
84585: PPUSH
84586: CALL_OW 321
84590: PUSH
84591: LD_INT 2
84593: EQUAL
84594: ST_TO_ADDR
84595: GO 84598
84597: POP
// end ;
84598: LD_VAR 0 3
84602: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
84603: LD_INT 0
84605: PPUSH
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
// result := false ;
84616: LD_ADDR_VAR 0 6
84620: PUSH
84621: LD_INT 0
84623: ST_TO_ADDR
// if btype = b_depot then
84624: LD_VAR 0 2
84628: PUSH
84629: LD_INT 0
84631: EQUAL
84632: IFFALSE 84644
// begin result := true ;
84634: LD_ADDR_VAR 0 6
84638: PUSH
84639: LD_INT 1
84641: ST_TO_ADDR
// exit ;
84642: GO 85498
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
84644: LD_VAR 0 1
84648: NOT
84649: IFTRUE 84674
84651: PUSH
84652: LD_VAR 0 1
84656: PPUSH
84657: CALL_OW 266
84661: PUSH
84662: LD_INT 0
84664: PUSH
84665: LD_INT 1
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: IN
84672: NOT
84673: OR
84674: IFTRUE 84683
84676: PUSH
84677: LD_VAR 0 2
84681: NOT
84682: OR
84683: IFTRUE 84719
84685: PUSH
84686: LD_VAR 0 5
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: LD_INT 1
84696: PUSH
84697: LD_INT 2
84699: PUSH
84700: LD_INT 3
84702: PUSH
84703: LD_INT 4
84705: PUSH
84706: LD_INT 5
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: IN
84717: NOT
84718: OR
84719: IFTRUE 84738
84721: PUSH
84722: LD_VAR 0 3
84726: PPUSH
84727: LD_VAR 0 4
84731: PPUSH
84732: CALL_OW 488
84736: NOT
84737: OR
84738: IFFALSE 84742
// exit ;
84740: GO 85498
// side := GetSide ( depot ) ;
84742: LD_ADDR_VAR 0 9
84746: PUSH
84747: LD_VAR 0 1
84751: PPUSH
84752: CALL_OW 255
84756: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
84757: LD_VAR 0 9
84761: PPUSH
84762: LD_VAR 0 2
84766: PPUSH
84767: CALL 84227 0 2
84771: NOT
84772: IFFALSE 84776
// exit ;
84774: GO 85498
// pom := GetBase ( depot ) ;
84776: LD_ADDR_VAR 0 10
84780: PUSH
84781: LD_VAR 0 1
84785: PPUSH
84786: CALL_OW 274
84790: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
84791: LD_ADDR_VAR 0 11
84795: PUSH
84796: LD_VAR 0 2
84800: PPUSH
84801: LD_VAR 0 1
84805: PPUSH
84806: CALL_OW 248
84810: PPUSH
84811: CALL_OW 450
84815: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
84816: LD_VAR 0 10
84820: PPUSH
84821: LD_INT 1
84823: PPUSH
84824: CALL_OW 275
84828: PUSH
84829: LD_VAR 0 11
84833: PUSH
84834: LD_INT 1
84836: ARRAY
84837: GREATEREQUAL
84838: IFFALSE 84864
84840: PUSH
84841: LD_VAR 0 10
84845: PPUSH
84846: LD_INT 2
84848: PPUSH
84849: CALL_OW 275
84853: PUSH
84854: LD_VAR 0 11
84858: PUSH
84859: LD_INT 2
84861: ARRAY
84862: GREATEREQUAL
84863: AND
84864: IFFALSE 84890
84866: PUSH
84867: LD_VAR 0 10
84871: PPUSH
84872: LD_INT 3
84874: PPUSH
84875: CALL_OW 275
84879: PUSH
84880: LD_VAR 0 11
84884: PUSH
84885: LD_INT 3
84887: ARRAY
84888: GREATEREQUAL
84889: AND
84890: NOT
84891: IFFALSE 84895
// exit ;
84893: GO 85498
// if GetBType ( depot ) = b_depot then
84895: LD_VAR 0 1
84899: PPUSH
84900: CALL_OW 266
84904: PUSH
84905: LD_INT 0
84907: EQUAL
84908: IFFALSE 84920
// dist := 28 else
84910: LD_ADDR_VAR 0 14
84914: PUSH
84915: LD_INT 28
84917: ST_TO_ADDR
84918: GO 84928
// dist := 36 ;
84920: LD_ADDR_VAR 0 14
84924: PUSH
84925: LD_INT 36
84927: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84928: LD_VAR 0 1
84932: PPUSH
84933: LD_VAR 0 3
84937: PPUSH
84938: LD_VAR 0 4
84942: PPUSH
84943: CALL_OW 297
84947: PUSH
84948: LD_VAR 0 14
84952: GREATER
84953: IFFALSE 84957
// exit ;
84955: GO 85498
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84957: LD_ADDR_VAR 0 12
84961: PUSH
84962: LD_VAR 0 2
84966: PPUSH
84967: LD_VAR 0 3
84971: PPUSH
84972: LD_VAR 0 4
84976: PPUSH
84977: LD_VAR 0 5
84981: PPUSH
84982: LD_VAR 0 1
84986: PPUSH
84987: CALL_OW 248
84991: PPUSH
84992: LD_INT 0
84994: PPUSH
84995: CALL 85503 0 6
84999: ST_TO_ADDR
// if not hexes then
85000: LD_VAR 0 12
85004: NOT
85005: IFFALSE 85009
// exit ;
85007: GO 85498
// hex := GetHexInfo ( x , y ) ;
85009: LD_ADDR_VAR 0 15
85013: PUSH
85014: LD_VAR 0 3
85018: PPUSH
85019: LD_VAR 0 4
85023: PPUSH
85024: CALL_OW 546
85028: ST_TO_ADDR
// if hex [ 1 ] then
85029: LD_VAR 0 15
85033: PUSH
85034: LD_INT 1
85036: ARRAY
85037: IFFALSE 85041
// exit ;
85039: GO 85498
// height := hex [ 2 ] ;
85041: LD_ADDR_VAR 0 13
85045: PUSH
85046: LD_VAR 0 15
85050: PUSH
85051: LD_INT 2
85053: ARRAY
85054: ST_TO_ADDR
// for i = 1 to hexes do
85055: LD_ADDR_VAR 0 7
85059: PUSH
85060: DOUBLE
85061: LD_INT 1
85063: DEC
85064: ST_TO_ADDR
85065: LD_VAR 0 12
85069: PUSH
85070: FOR_TO
85071: IFFALSE 85415
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
85073: LD_VAR 0 12
85077: PUSH
85078: LD_VAR 0 7
85082: ARRAY
85083: PUSH
85084: LD_INT 1
85086: ARRAY
85087: PPUSH
85088: LD_VAR 0 12
85092: PUSH
85093: LD_VAR 0 7
85097: ARRAY
85098: PUSH
85099: LD_INT 2
85101: ARRAY
85102: PPUSH
85103: CALL_OW 488
85107: NOT
85108: IFTRUE 85150
85110: PUSH
85111: LD_VAR 0 12
85115: PUSH
85116: LD_VAR 0 7
85120: ARRAY
85121: PUSH
85122: LD_INT 1
85124: ARRAY
85125: PPUSH
85126: LD_VAR 0 12
85130: PUSH
85131: LD_VAR 0 7
85135: ARRAY
85136: PUSH
85137: LD_INT 2
85139: ARRAY
85140: PPUSH
85141: CALL_OW 428
85145: PUSH
85146: LD_INT 0
85148: GREATER
85149: OR
85150: IFTRUE 85188
85152: PUSH
85153: LD_VAR 0 12
85157: PUSH
85158: LD_VAR 0 7
85162: ARRAY
85163: PUSH
85164: LD_INT 1
85166: ARRAY
85167: PPUSH
85168: LD_VAR 0 12
85172: PUSH
85173: LD_VAR 0 7
85177: ARRAY
85178: PUSH
85179: LD_INT 2
85181: ARRAY
85182: PPUSH
85183: CALL_OW 351
85187: OR
85188: IFFALSE 85194
// exit ;
85190: POP
85191: POP
85192: GO 85498
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85194: LD_ADDR_VAR 0 8
85198: PUSH
85199: LD_VAR 0 12
85203: PUSH
85204: LD_VAR 0 7
85208: ARRAY
85209: PUSH
85210: LD_INT 1
85212: ARRAY
85213: PPUSH
85214: LD_VAR 0 12
85218: PUSH
85219: LD_VAR 0 7
85223: ARRAY
85224: PUSH
85225: LD_INT 2
85227: ARRAY
85228: PPUSH
85229: CALL_OW 546
85233: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
85234: LD_VAR 0 8
85238: PUSH
85239: LD_INT 1
85241: ARRAY
85242: IFTRUE 85264
85244: PUSH
85245: LD_VAR 0 8
85249: PUSH
85250: LD_INT 2
85252: ARRAY
85253: PUSH
85254: LD_VAR 0 13
85258: PUSH
85259: LD_INT 2
85261: PLUS
85262: GREATER
85263: OR
85264: IFTRUE 85286
85266: PUSH
85267: LD_VAR 0 8
85271: PUSH
85272: LD_INT 2
85274: ARRAY
85275: PUSH
85276: LD_VAR 0 13
85280: PUSH
85281: LD_INT 2
85283: MINUS
85284: LESS
85285: OR
85286: IFTRUE 85354
85288: PUSH
85289: LD_VAR 0 8
85293: PUSH
85294: LD_INT 3
85296: ARRAY
85297: PUSH
85298: LD_INT 0
85300: PUSH
85301: LD_INT 8
85303: PUSH
85304: LD_INT 9
85306: PUSH
85307: LD_INT 10
85309: PUSH
85310: LD_INT 11
85312: PUSH
85313: LD_INT 12
85315: PUSH
85316: LD_INT 13
85318: PUSH
85319: LD_INT 16
85321: PUSH
85322: LD_INT 17
85324: PUSH
85325: LD_INT 18
85327: PUSH
85328: LD_INT 19
85330: PUSH
85331: LD_INT 20
85333: PUSH
85334: LD_INT 21
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: IN
85352: NOT
85353: OR
85354: IFTRUE 85367
85356: PUSH
85357: LD_VAR 0 8
85361: PUSH
85362: LD_INT 5
85364: ARRAY
85365: NOT
85366: OR
85367: IFTRUE 85407
85369: PUSH
85370: LD_VAR 0 8
85374: PUSH
85375: LD_INT 6
85377: ARRAY
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: LD_INT 2
85384: PUSH
85385: LD_INT 7
85387: PUSH
85388: LD_INT 9
85390: PUSH
85391: LD_INT 10
85393: PUSH
85394: LD_INT 11
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: IN
85405: NOT
85406: OR
85407: IFFALSE 85413
// exit ;
85409: POP
85410: POP
85411: GO 85498
// end ;
85413: GO 85070
85415: POP
85416: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
85417: LD_VAR 0 9
85421: PPUSH
85422: LD_VAR 0 3
85426: PPUSH
85427: LD_VAR 0 4
85431: PPUSH
85432: LD_INT 20
85434: PPUSH
85435: CALL 77317 0 4
85439: PUSH
85440: LD_INT 4
85442: ARRAY
85443: IFFALSE 85447
// exit ;
85445: GO 85498
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
85447: LD_VAR 0 2
85451: PUSH
85452: LD_INT 29
85454: PUSH
85455: LD_INT 30
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: IN
85462: IFFALSE 85486
85464: PUSH
85465: LD_VAR 0 3
85469: PPUSH
85470: LD_VAR 0 4
85474: PPUSH
85475: LD_VAR 0 9
85479: PPUSH
85480: CALL_OW 440
85484: NOT
85485: AND
85486: IFFALSE 85490
// exit ;
85488: GO 85498
// result := true ;
85490: LD_ADDR_VAR 0 6
85494: PUSH
85495: LD_INT 1
85497: ST_TO_ADDR
// end ;
85498: LD_VAR 0 6
85502: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
85503: LD_INT 0
85505: PPUSH
85506: PPUSH
85507: PPUSH
85508: PPUSH
85509: PPUSH
85510: PPUSH
85511: PPUSH
85512: PPUSH
85513: PPUSH
85514: PPUSH
85515: PPUSH
85516: PPUSH
85517: PPUSH
85518: PPUSH
85519: PPUSH
85520: PPUSH
85521: PPUSH
85522: PPUSH
85523: PPUSH
85524: PPUSH
85525: PPUSH
85526: PPUSH
85527: PPUSH
85528: PPUSH
85529: PPUSH
85530: PPUSH
85531: PPUSH
85532: PPUSH
85533: PPUSH
85534: PPUSH
85535: PPUSH
85536: PPUSH
85537: PPUSH
85538: PPUSH
85539: PPUSH
85540: PPUSH
85541: PPUSH
85542: PPUSH
85543: PPUSH
85544: PPUSH
85545: PPUSH
85546: PPUSH
85547: PPUSH
85548: PPUSH
85549: PPUSH
85550: PPUSH
85551: PPUSH
85552: PPUSH
85553: PPUSH
85554: PPUSH
85555: PPUSH
85556: PPUSH
85557: PPUSH
85558: PPUSH
85559: PPUSH
85560: PPUSH
85561: PPUSH
85562: PPUSH
// result = [ ] ;
85563: LD_ADDR_VAR 0 7
85567: PUSH
85568: EMPTY
85569: ST_TO_ADDR
// temp_list = [ ] ;
85570: LD_ADDR_VAR 0 9
85574: PUSH
85575: EMPTY
85576: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
85577: LD_VAR 0 4
85581: PUSH
85582: LD_INT 0
85584: PUSH
85585: LD_INT 1
85587: PUSH
85588: LD_INT 2
85590: PUSH
85591: LD_INT 3
85593: PUSH
85594: LD_INT 4
85596: PUSH
85597: LD_INT 5
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: IN
85608: NOT
85609: IFTRUE 85652
85611: PUSH
85612: LD_VAR 0 1
85616: PUSH
85617: LD_INT 0
85619: PUSH
85620: LD_INT 1
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: IN
85627: IFFALSE 85651
85629: PUSH
85630: LD_VAR 0 5
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: LD_INT 2
85640: PUSH
85641: LD_INT 3
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: LIST
85648: IN
85649: NOT
85650: AND
85651: OR
85652: IFFALSE 85656
// exit ;
85654: GO 104055
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
85656: LD_VAR 0 1
85660: PUSH
85661: LD_INT 6
85663: PUSH
85664: LD_INT 7
85666: PUSH
85667: LD_INT 8
85669: PUSH
85670: LD_INT 13
85672: PUSH
85673: LD_INT 12
85675: PUSH
85676: LD_INT 15
85678: PUSH
85679: LD_INT 11
85681: PUSH
85682: LD_INT 14
85684: PUSH
85685: LD_INT 10
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: IN
85699: IFFALSE 85709
// btype = b_lab ;
85701: LD_ADDR_VAR 0 1
85705: PUSH
85706: LD_INT 6
85708: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
85709: LD_VAR 0 6
85713: PUSH
85714: LD_INT 0
85716: PUSH
85717: LD_INT 1
85719: PUSH
85720: LD_INT 2
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: LIST
85727: IN
85728: NOT
85729: IFTRUE 85797
85731: PUSH
85732: LD_VAR 0 1
85736: PUSH
85737: LD_INT 0
85739: PUSH
85740: LD_INT 1
85742: PUSH
85743: LD_INT 2
85745: PUSH
85746: LD_INT 3
85748: PUSH
85749: LD_INT 6
85751: PUSH
85752: LD_INT 36
85754: PUSH
85755: LD_INT 4
85757: PUSH
85758: LD_INT 5
85760: PUSH
85761: LD_INT 31
85763: PUSH
85764: LD_INT 32
85766: PUSH
85767: LD_INT 33
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: IN
85783: NOT
85784: IFFALSE 85796
85786: PUSH
85787: LD_VAR 0 6
85791: PUSH
85792: LD_INT 1
85794: EQUAL
85795: AND
85796: OR
85797: IFTRUE 85829
85799: PUSH
85800: LD_VAR 0 1
85804: PUSH
85805: LD_INT 2
85807: PUSH
85808: LD_INT 3
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: IN
85815: NOT
85816: IFFALSE 85828
85818: PUSH
85819: LD_VAR 0 6
85823: PUSH
85824: LD_INT 2
85826: EQUAL
85827: AND
85828: OR
85829: IFFALSE 85839
// mode = 0 ;
85831: LD_ADDR_VAR 0 6
85835: PUSH
85836: LD_INT 0
85838: ST_TO_ADDR
// case mode of 0 :
85839: LD_VAR 0 6
85843: PUSH
85844: LD_INT 0
85846: DOUBLE
85847: EQUAL
85848: IFTRUE 85852
85850: GO 97305
85852: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85853: LD_ADDR_VAR 0 11
85857: PUSH
85858: LD_INT 0
85860: PUSH
85861: LD_INT 0
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 0
85870: PUSH
85871: LD_INT 1
85873: NEG
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 1
85881: PUSH
85882: LD_INT 0
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: PUSH
85892: LD_INT 1
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: NEG
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 1
85934: NEG
85935: PUSH
85936: LD_INT 2
85938: NEG
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 0
85946: PUSH
85947: LD_INT 2
85949: NEG
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 1
85957: PUSH
85958: LD_INT 1
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 1
85968: PUSH
85969: LD_INT 2
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 0
85978: PUSH
85979: LD_INT 2
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 1
85988: NEG
85989: PUSH
85990: LD_INT 1
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: LD_INT 1
85999: PUSH
86000: LD_INT 3
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 0
86009: PUSH
86010: LD_INT 3
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 1
86019: NEG
86020: PUSH
86021: LD_INT 2
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86046: LD_ADDR_VAR 0 12
86050: PUSH
86051: LD_INT 0
86053: PUSH
86054: LD_INT 0
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 0
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 1
86074: PUSH
86075: LD_INT 0
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: LD_INT 0
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 1
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 2
86138: PUSH
86139: LD_INT 0
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: LD_INT 2
86148: PUSH
86149: LD_INT 1
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 1
86158: NEG
86159: PUSH
86160: LD_INT 1
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 2
86169: NEG
86170: PUSH
86171: LD_INT 0
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 2
86180: NEG
86181: PUSH
86182: LD_INT 1
86184: NEG
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 2
86192: NEG
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 3
86203: NEG
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 3
86214: NEG
86215: PUSH
86216: LD_INT 1
86218: NEG
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86242: LD_ADDR_VAR 0 13
86246: PUSH
86247: LD_INT 0
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 0
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: PUSH
86281: LD_INT 1
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 0
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 1
86300: NEG
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 1
86323: NEG
86324: PUSH
86325: LD_INT 2
86327: NEG
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 2
86335: PUSH
86336: LD_INT 1
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 2
86345: PUSH
86346: LD_INT 2
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: PUSH
86356: LD_INT 2
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 2
86365: NEG
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 2
86377: NEG
86378: PUSH
86379: LD_INT 2
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 2
86389: NEG
86390: PUSH
86391: LD_INT 3
86393: NEG
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 3
86401: NEG
86402: PUSH
86403: LD_INT 2
86405: NEG
86406: PUSH
86407: EMPTY
86408: LIST
86409: LIST
86410: PUSH
86411: LD_INT 3
86413: NEG
86414: PUSH
86415: LD_INT 3
86417: NEG
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86441: LD_ADDR_VAR 0 14
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: LD_INT 0
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 1
86461: NEG
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 1
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 0
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 1
86499: NEG
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 1
86510: NEG
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: LD_INT 2
86526: NEG
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 0
86534: PUSH
86535: LD_INT 2
86537: NEG
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: LD_INT 2
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: LD_INT 2
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 1
86576: NEG
86577: PUSH
86578: LD_INT 1
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 1
86587: NEG
86588: PUSH
86589: LD_INT 3
86591: NEG
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 0
86599: PUSH
86600: LD_INT 3
86602: NEG
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 1
86610: PUSH
86611: LD_INT 2
86613: NEG
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86637: LD_ADDR_VAR 0 15
86641: PUSH
86642: LD_INT 0
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 1
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: PUSH
86676: LD_INT 1
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 0
86685: PUSH
86686: LD_INT 1
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: NEG
86696: PUSH
86697: LD_INT 0
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 1
86706: NEG
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: LD_INT 1
86721: NEG
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 2
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 2
86739: PUSH
86740: LD_INT 1
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 1
86749: NEG
86750: PUSH
86751: LD_INT 1
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 2
86760: NEG
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 2
86771: NEG
86772: PUSH
86773: LD_INT 1
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 2
86783: PUSH
86784: LD_INT 1
86786: NEG
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 3
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 3
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: LIST
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86830: LD_ADDR_VAR 0 16
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 1
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 0
86878: PUSH
86879: LD_INT 1
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: LD_INT 0
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 1
86899: NEG
86900: PUSH
86901: LD_INT 1
86903: NEG
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 1
86911: NEG
86912: PUSH
86913: LD_INT 2
86915: NEG
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 2
86923: PUSH
86924: LD_INT 1
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 2
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 1
86943: PUSH
86944: LD_INT 2
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 2
86953: NEG
86954: PUSH
86955: LD_INT 1
86957: NEG
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: LD_INT 2
86969: NEG
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 3
86977: PUSH
86978: LD_INT 2
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 3
86987: PUSH
86988: LD_INT 3
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 2
86997: PUSH
86998: LD_INT 3
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87023: LD_ADDR_VAR 0 17
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 0
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: LD_INT 1
87043: NEG
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 0
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 1
87081: NEG
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: NEG
87093: PUSH
87094: LD_INT 1
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: LD_INT 2
87108: NEG
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 2
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: LD_INT 1
87130: NEG
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 2
87138: PUSH
87139: LD_INT 0
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 2
87148: PUSH
87149: LD_INT 1
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 2
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 1
87168: PUSH
87169: LD_INT 2
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: PUSH
87176: LD_INT 0
87178: PUSH
87179: LD_INT 2
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 1
87188: NEG
87189: PUSH
87190: LD_INT 1
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 2
87199: NEG
87200: PUSH
87201: LD_INT 0
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 2
87210: NEG
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 2
87222: NEG
87223: PUSH
87224: LD_INT 2
87226: NEG
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87253: LD_ADDR_VAR 0 18
87257: PUSH
87258: LD_INT 0
87260: PUSH
87261: LD_INT 0
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 0
87270: PUSH
87271: LD_INT 1
87273: NEG
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 1
87281: PUSH
87282: LD_INT 0
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: PUSH
87289: LD_INT 1
87291: PUSH
87292: LD_INT 1
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: LD_INT 1
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: LD_INT 0
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 1
87322: NEG
87323: PUSH
87324: LD_INT 1
87326: NEG
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: NEG
87335: PUSH
87336: LD_INT 2
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 0
87346: PUSH
87347: LD_INT 2
87349: NEG
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: PUSH
87355: LD_INT 1
87357: PUSH
87358: LD_INT 1
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 2
87368: PUSH
87369: LD_INT 0
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PUSH
87376: LD_INT 2
87378: PUSH
87379: LD_INT 1
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 2
87388: PUSH
87389: LD_INT 2
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: LD_INT 2
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: LD_INT 2
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 2
87429: NEG
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 2
87440: NEG
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 2
87452: NEG
87453: PUSH
87454: LD_INT 2
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87483: LD_ADDR_VAR 0 19
87487: PUSH
87488: LD_INT 0
87490: PUSH
87491: LD_INT 0
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 0
87500: PUSH
87501: LD_INT 1
87503: NEG
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: LD_INT 0
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: LD_INT 1
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 0
87531: PUSH
87532: LD_INT 1
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 1
87541: NEG
87542: PUSH
87543: LD_INT 0
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 1
87552: NEG
87553: PUSH
87554: LD_INT 1
87556: NEG
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: LD_INT 2
87568: NEG
87569: PUSH
87570: EMPTY
87571: LIST
87572: LIST
87573: PUSH
87574: LD_INT 0
87576: PUSH
87577: LD_INT 2
87579: NEG
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 1
87587: PUSH
87588: LD_INT 1
87590: NEG
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: LD_INT 1
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 2
87618: PUSH
87619: LD_INT 2
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 1
87628: PUSH
87629: LD_INT 2
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: LD_INT 2
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: LD_INT 1
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 2
87659: NEG
87660: PUSH
87661: LD_INT 0
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: LD_INT 2
87670: NEG
87671: PUSH
87672: LD_INT 1
87674: NEG
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 2
87682: NEG
87683: PUSH
87684: LD_INT 2
87686: NEG
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87713: LD_ADDR_VAR 0 20
87717: PUSH
87718: LD_INT 0
87720: PUSH
87721: LD_INT 0
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 0
87730: PUSH
87731: LD_INT 1
87733: NEG
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 1
87741: PUSH
87742: LD_INT 0
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: LD_INT 1
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 1
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 1
87771: NEG
87772: PUSH
87773: LD_INT 0
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: NEG
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 1
87794: NEG
87795: PUSH
87796: LD_INT 2
87798: NEG
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 0
87806: PUSH
87807: LD_INT 2
87809: NEG
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: LD_INT 1
87820: NEG
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: LD_INT 2
87828: PUSH
87829: LD_INT 0
87831: PUSH
87832: EMPTY
87833: LIST
87834: LIST
87835: PUSH
87836: LD_INT 2
87838: PUSH
87839: LD_INT 1
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 2
87848: PUSH
87849: LD_INT 2
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 1
87858: PUSH
87859: LD_INT 2
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 0
87868: PUSH
87869: LD_INT 2
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 1
87878: NEG
87879: PUSH
87880: LD_INT 1
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 2
87889: NEG
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 2
87900: NEG
87901: PUSH
87902: LD_INT 1
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 2
87912: NEG
87913: PUSH
87914: LD_INT 2
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87943: LD_ADDR_VAR 0 21
87947: PUSH
87948: LD_INT 0
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 0
87960: PUSH
87961: LD_INT 1
87963: NEG
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 1
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 1
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 0
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 1
88001: NEG
88002: PUSH
88003: LD_INT 0
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 1
88012: NEG
88013: PUSH
88014: LD_INT 1
88016: NEG
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 1
88024: NEG
88025: PUSH
88026: LD_INT 2
88028: NEG
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 0
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 1
88047: PUSH
88048: LD_INT 1
88050: NEG
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 2
88058: PUSH
88059: LD_INT 0
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 2
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 2
88078: PUSH
88079: LD_INT 2
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: LD_INT 1
88088: PUSH
88089: LD_INT 2
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 0
88098: PUSH
88099: LD_INT 2
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 1
88108: NEG
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 2
88119: NEG
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 2
88130: NEG
88131: PUSH
88132: LD_INT 1
88134: NEG
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 2
88142: NEG
88143: PUSH
88144: LD_INT 2
88146: NEG
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88173: LD_ADDR_VAR 0 22
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: NEG
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: LD_INT 2
88258: NEG
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 0
88266: PUSH
88267: LD_INT 2
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 2
88288: PUSH
88289: LD_INT 0
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 2
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 2
88308: PUSH
88309: LD_INT 2
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: LD_INT 2
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 0
88328: PUSH
88329: LD_INT 2
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 1
88338: NEG
88339: PUSH
88340: LD_INT 1
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 2
88349: NEG
88350: PUSH
88351: LD_INT 0
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 2
88360: NEG
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 2
88372: NEG
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88403: LD_ADDR_VAR 0 23
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: LD_INT 0
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 0
88420: PUSH
88421: LD_INT 1
88423: NEG
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 1
88431: PUSH
88432: LD_INT 0
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 1
88441: PUSH
88442: LD_INT 1
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 0
88451: PUSH
88452: LD_INT 1
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 1
88461: NEG
88462: PUSH
88463: LD_INT 0
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 1
88472: NEG
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 1
88484: NEG
88485: PUSH
88486: LD_INT 2
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 0
88496: PUSH
88497: LD_INT 2
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: LD_INT 1
88510: NEG
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 2
88518: PUSH
88519: LD_INT 0
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 2
88528: PUSH
88529: LD_INT 1
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 2
88538: PUSH
88539: LD_INT 2
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: LD_INT 2
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 0
88558: PUSH
88559: LD_INT 2
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 1
88568: NEG
88569: PUSH
88570: LD_INT 1
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: NEG
88580: PUSH
88581: LD_INT 0
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: LD_INT 1
88594: NEG
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 2
88602: NEG
88603: PUSH
88604: LD_INT 2
88606: NEG
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: PUSH
88612: LD_INT 2
88614: NEG
88615: PUSH
88616: LD_INT 3
88618: NEG
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 1
88626: NEG
88627: PUSH
88628: LD_INT 3
88630: NEG
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 1
88638: PUSH
88639: LD_INT 2
88641: NEG
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: LD_INT 1
88652: NEG
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
88683: LD_ADDR_VAR 0 24
88687: PUSH
88688: LD_INT 0
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_INT 1
88703: NEG
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: PUSH
88712: LD_INT 0
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: LD_INT 1
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 0
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: NEG
88742: PUSH
88743: LD_INT 0
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 1
88764: NEG
88765: PUSH
88766: LD_INT 2
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: LD_INT 2
88779: NEG
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 1
88787: PUSH
88788: LD_INT 1
88790: NEG
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 2
88798: PUSH
88799: LD_INT 0
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 2
88808: PUSH
88809: LD_INT 1
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: LD_INT 2
88818: PUSH
88819: LD_INT 2
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 1
88828: PUSH
88829: LD_INT 2
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 0
88838: PUSH
88839: LD_INT 2
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 1
88848: NEG
88849: PUSH
88850: LD_INT 1
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 2
88859: NEG
88860: PUSH
88861: LD_INT 0
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 2
88870: NEG
88871: PUSH
88872: LD_INT 1
88874: NEG
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 2
88882: NEG
88883: PUSH
88884: LD_INT 2
88886: NEG
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 1
88894: PUSH
88895: LD_INT 2
88897: NEG
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 2
88905: PUSH
88906: LD_INT 1
88908: NEG
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 3
88916: PUSH
88917: LD_INT 1
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 3
88926: PUSH
88927: LD_INT 2
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88959: LD_ADDR_VAR 0 25
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: LD_INT 0
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: LD_INT 1
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 1
88987: PUSH
88988: LD_INT 0
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 1
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 1
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 1
89028: NEG
89029: PUSH
89030: LD_INT 1
89032: NEG
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: LD_INT 2
89044: NEG
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: LD_INT 2
89055: NEG
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 1
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 2
89074: PUSH
89075: LD_INT 0
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 2
89084: PUSH
89085: LD_INT 1
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PUSH
89092: LD_INT 2
89094: PUSH
89095: LD_INT 2
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 1
89104: PUSH
89105: LD_INT 2
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 0
89114: PUSH
89115: LD_INT 2
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 1
89124: NEG
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 2
89135: NEG
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 2
89146: NEG
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 2
89158: NEG
89159: PUSH
89160: LD_INT 2
89162: NEG
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 3
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 3
89180: PUSH
89181: LD_INT 2
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 2
89190: PUSH
89191: LD_INT 3
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 1
89200: PUSH
89201: LD_INT 3
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89233: LD_ADDR_VAR 0 26
89237: PUSH
89238: LD_INT 0
89240: PUSH
89241: LD_INT 0
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 0
89250: PUSH
89251: LD_INT 1
89253: NEG
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 1
89261: PUSH
89262: LD_INT 0
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 1
89271: PUSH
89272: LD_INT 1
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 0
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: LD_INT 0
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 1
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: LD_INT 2
89318: NEG
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: LD_INT 2
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 2
89348: PUSH
89349: LD_INT 0
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 2
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 2
89368: PUSH
89369: LD_INT 2
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 1
89378: PUSH
89379: LD_INT 2
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 0
89388: PUSH
89389: LD_INT 2
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 1
89398: NEG
89399: PUSH
89400: LD_INT 1
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PUSH
89407: LD_INT 2
89409: NEG
89410: PUSH
89411: LD_INT 0
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 2
89420: NEG
89421: PUSH
89422: LD_INT 1
89424: NEG
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 2
89432: NEG
89433: PUSH
89434: LD_INT 2
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 2
89444: PUSH
89445: LD_INT 3
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 1
89454: PUSH
89455: LD_INT 3
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 1
89464: NEG
89465: PUSH
89466: LD_INT 2
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 2
89475: NEG
89476: PUSH
89477: LD_INT 1
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89509: LD_ADDR_VAR 0 27
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: LD_INT 0
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: PUSH
89524: LD_INT 0
89526: PUSH
89527: LD_INT 1
89529: NEG
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: LD_INT 0
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 1
89547: PUSH
89548: LD_INT 1
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 0
89557: PUSH
89558: LD_INT 1
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: LD_INT 0
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 1
89578: NEG
89579: PUSH
89580: LD_INT 1
89582: NEG
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 1
89590: NEG
89591: PUSH
89592: LD_INT 2
89594: NEG
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 0
89602: PUSH
89603: LD_INT 2
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 2
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 2
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 2
89644: PUSH
89645: LD_INT 2
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: PUSH
89655: LD_INT 2
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: LD_INT 2
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 2
89685: NEG
89686: PUSH
89687: LD_INT 0
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 2
89696: NEG
89697: PUSH
89698: LD_INT 1
89700: NEG
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 2
89708: NEG
89709: PUSH
89710: LD_INT 2
89712: NEG
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 1
89720: NEG
89721: PUSH
89722: LD_INT 2
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 2
89731: NEG
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 3
89742: NEG
89743: PUSH
89744: LD_INT 1
89746: NEG
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 3
89754: NEG
89755: PUSH
89756: LD_INT 2
89758: NEG
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89789: LD_ADDR_VAR 0 28
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 0
89806: PUSH
89807: LD_INT 1
89809: NEG
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 1
89817: PUSH
89818: LD_INT 0
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 1
89827: PUSH
89828: LD_INT 1
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 0
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 1
89847: NEG
89848: PUSH
89849: LD_INT 0
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 1
89858: NEG
89859: PUSH
89860: LD_INT 1
89862: NEG
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 0
89882: PUSH
89883: LD_INT 2
89885: NEG
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 1
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 2
89904: PUSH
89905: LD_INT 0
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 2
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 2
89924: PUSH
89925: LD_INT 2
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 1
89934: PUSH
89935: LD_INT 2
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: PUSH
89942: LD_INT 0
89944: PUSH
89945: LD_INT 2
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: LD_INT 1
89954: NEG
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 2
89965: NEG
89966: PUSH
89967: LD_INT 0
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 2
89976: NEG
89977: PUSH
89978: LD_INT 1
89980: NEG
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 2
89988: NEG
89989: PUSH
89990: LD_INT 2
89992: NEG
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: LD_INT 2
90000: NEG
90001: PUSH
90002: LD_INT 3
90004: NEG
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: NEG
90013: PUSH
90014: LD_INT 3
90016: NEG
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 3
90024: NEG
90025: PUSH
90026: LD_INT 1
90028: NEG
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 3
90036: NEG
90037: PUSH
90038: LD_INT 2
90040: NEG
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90071: LD_ADDR_VAR 0 29
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: LD_INT 0
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 0
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 1
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 1
90109: PUSH
90110: LD_INT 1
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 0
90119: PUSH
90120: LD_INT 1
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 1
90129: NEG
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 1
90140: NEG
90141: PUSH
90142: LD_INT 1
90144: NEG
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 1
90152: NEG
90153: PUSH
90154: LD_INT 2
90156: NEG
90157: PUSH
90158: EMPTY
90159: LIST
90160: LIST
90161: PUSH
90162: LD_INT 0
90164: PUSH
90165: LD_INT 2
90167: NEG
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 1
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 2
90186: PUSH
90187: LD_INT 0
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: LD_INT 1
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 1
90206: PUSH
90207: LD_INT 2
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 0
90216: PUSH
90217: LD_INT 2
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 1
90226: NEG
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 2
90237: NEG
90238: PUSH
90239: LD_INT 1
90241: NEG
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: LD_INT 2
90249: NEG
90250: PUSH
90251: LD_INT 2
90253: NEG
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 2
90261: NEG
90262: PUSH
90263: LD_INT 3
90265: NEG
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 2
90273: PUSH
90274: LD_INT 1
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 3
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 1
90294: PUSH
90295: LD_INT 3
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 1
90304: NEG
90305: PUSH
90306: LD_INT 2
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 3
90315: NEG
90316: PUSH
90317: LD_INT 2
90319: NEG
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90350: LD_ADDR_VAR 0 30
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: LD_INT 0
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: PUSH
90365: LD_INT 0
90367: PUSH
90368: LD_INT 1
90370: NEG
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 1
90378: PUSH
90379: LD_INT 0
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 1
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: LD_INT 1
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: LD_INT 0
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 1
90419: NEG
90420: PUSH
90421: LD_INT 1
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 1
90431: NEG
90432: PUSH
90433: LD_INT 2
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 0
90443: PUSH
90444: LD_INT 2
90446: NEG
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 2
90465: PUSH
90466: LD_INT 0
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 2
90475: PUSH
90476: LD_INT 1
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 2
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 2
90516: NEG
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 2
90527: NEG
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 1
90539: NEG
90540: PUSH
90541: LD_INT 3
90543: NEG
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 1
90551: PUSH
90552: LD_INT 2
90554: NEG
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 3
90562: PUSH
90563: LD_INT 2
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 2
90572: PUSH
90573: LD_INT 3
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 2
90582: NEG
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 3
90593: NEG
90594: PUSH
90595: LD_INT 1
90597: NEG
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90628: LD_ADDR_VAR 0 31
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: LD_INT 0
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PUSH
90643: LD_INT 0
90645: PUSH
90646: LD_INT 1
90648: NEG
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 0
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 1
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 0
90676: PUSH
90677: LD_INT 1
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 1
90686: NEG
90687: PUSH
90688: LD_INT 0
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 1
90697: NEG
90698: PUSH
90699: LD_INT 1
90701: NEG
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: LD_INT 2
90713: NEG
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 1
90721: PUSH
90722: LD_INT 1
90724: NEG
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 2
90732: PUSH
90733: LD_INT 0
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 2
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 2
90752: PUSH
90753: LD_INT 2
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: LD_INT 1
90762: PUSH
90763: LD_INT 2
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 0
90772: PUSH
90773: LD_INT 2
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 1
90782: NEG
90783: PUSH
90784: LD_INT 1
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 2
90793: NEG
90794: PUSH
90795: LD_INT 1
90797: NEG
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 2
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 2
90817: NEG
90818: PUSH
90819: LD_INT 3
90821: NEG
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 2
90829: PUSH
90830: LD_INT 1
90832: NEG
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 3
90840: PUSH
90841: LD_INT 1
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: PUSH
90851: LD_INT 3
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 1
90860: NEG
90861: PUSH
90862: LD_INT 2
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 3
90871: NEG
90872: PUSH
90873: LD_INT 2
90875: NEG
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: LIST
90905: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90906: LD_ADDR_VAR 0 32
90910: PUSH
90911: LD_INT 0
90913: PUSH
90914: LD_INT 0
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: LD_INT 1
90926: NEG
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 1
90934: PUSH
90935: LD_INT 0
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 1
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 1
90964: NEG
90965: PUSH
90966: LD_INT 0
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 1
90975: NEG
90976: PUSH
90977: LD_INT 1
90979: NEG
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 1
90987: NEG
90988: PUSH
90989: LD_INT 2
90991: NEG
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 0
90999: PUSH
91000: LD_INT 2
91002: NEG
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 1
91010: PUSH
91011: LD_INT 1
91013: NEG
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 2
91021: PUSH
91022: LD_INT 1
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 2
91031: PUSH
91032: LD_INT 2
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 1
91041: PUSH
91042: LD_INT 2
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 2
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 1
91061: NEG
91062: PUSH
91063: LD_INT 1
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 2
91072: NEG
91073: PUSH
91074: LD_INT 0
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 2
91083: NEG
91084: PUSH
91085: LD_INT 1
91087: NEG
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 1
91095: NEG
91096: PUSH
91097: LD_INT 3
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 1
91107: PUSH
91108: LD_INT 2
91110: NEG
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 3
91118: PUSH
91119: LD_INT 2
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: LD_INT 3
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: LD_INT 2
91138: NEG
91139: PUSH
91140: LD_INT 1
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 3
91149: NEG
91150: PUSH
91151: LD_INT 1
91153: NEG
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
91184: LD_ADDR_VAR 0 33
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 0
91201: PUSH
91202: LD_INT 1
91204: NEG
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: LD_INT 0
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 1
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 0
91232: PUSH
91233: LD_INT 1
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: NEG
91243: PUSH
91244: LD_INT 0
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 1
91253: NEG
91254: PUSH
91255: LD_INT 1
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 1
91265: NEG
91266: PUSH
91267: LD_INT 2
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 1
91277: PUSH
91278: LD_INT 1
91280: NEG
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 2
91288: PUSH
91289: LD_INT 0
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 2
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: LD_INT 2
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 0
91318: PUSH
91319: LD_INT 2
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 1
91328: NEG
91329: PUSH
91330: LD_INT 1
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 2
91339: NEG
91340: PUSH
91341: LD_INT 0
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 2
91350: NEG
91351: PUSH
91352: LD_INT 1
91354: NEG
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 2
91362: NEG
91363: PUSH
91364: LD_INT 2
91366: NEG
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 2
91374: NEG
91375: PUSH
91376: LD_INT 3
91378: NEG
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 2
91386: PUSH
91387: LD_INT 1
91389: NEG
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 3
91397: PUSH
91398: LD_INT 1
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: LD_INT 3
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 1
91417: NEG
91418: PUSH
91419: LD_INT 2
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 3
91428: NEG
91429: PUSH
91430: LD_INT 2
91432: NEG
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91463: LD_ADDR_VAR 0 34
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: LD_INT 0
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: LD_INT 1
91483: NEG
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: LD_INT 0
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: PUSH
91502: LD_INT 1
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 0
91511: PUSH
91512: LD_INT 1
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 1
91521: NEG
91522: PUSH
91523: LD_INT 0
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 1
91532: NEG
91533: PUSH
91534: LD_INT 1
91536: NEG
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: PUSH
91542: LD_INT 1
91544: NEG
91545: PUSH
91546: LD_INT 2
91548: NEG
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 0
91556: PUSH
91557: LD_INT 2
91559: NEG
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: PUSH
91565: LD_INT 1
91567: PUSH
91568: LD_INT 1
91570: NEG
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 2
91578: PUSH
91579: LD_INT 1
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 2
91588: PUSH
91589: LD_INT 2
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 1
91598: PUSH
91599: LD_INT 2
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: LD_INT 1
91608: NEG
91609: PUSH
91610: LD_INT 1
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 2
91619: NEG
91620: PUSH
91621: LD_INT 0
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 2
91630: NEG
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 2
91642: NEG
91643: PUSH
91644: LD_INT 2
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 1
91654: NEG
91655: PUSH
91656: LD_INT 3
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 1
91666: PUSH
91667: LD_INT 2
91669: NEG
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: PUSH
91675: LD_INT 3
91677: PUSH
91678: LD_INT 2
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 2
91687: PUSH
91688: LD_INT 3
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: LD_INT 2
91697: NEG
91698: PUSH
91699: LD_INT 1
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 3
91708: NEG
91709: PUSH
91710: LD_INT 1
91712: NEG
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91743: LD_ADDR_VAR 0 35
91747: PUSH
91748: LD_INT 0
91750: PUSH
91751: LD_INT 0
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: LD_INT 1
91763: NEG
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 1
91771: PUSH
91772: LD_INT 0
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: LD_INT 1
91781: PUSH
91782: LD_INT 1
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 0
91791: PUSH
91792: LD_INT 1
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 1
91801: NEG
91802: PUSH
91803: LD_INT 0
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 1
91812: NEG
91813: PUSH
91814: LD_INT 1
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 2
91824: PUSH
91825: LD_INT 1
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 2
91834: NEG
91835: PUSH
91836: LD_INT 1
91838: NEG
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: EMPTY
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91855: LD_ADDR_VAR 0 36
91859: PUSH
91860: LD_INT 0
91862: PUSH
91863: LD_INT 0
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 0
91872: PUSH
91873: LD_INT 1
91875: NEG
91876: PUSH
91877: EMPTY
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 1
91883: PUSH
91884: LD_INT 0
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: LD_INT 1
91893: PUSH
91894: LD_INT 1
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 0
91903: PUSH
91904: LD_INT 1
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 1
91913: NEG
91914: PUSH
91915: LD_INT 0
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 1
91924: NEG
91925: PUSH
91926: LD_INT 1
91928: NEG
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PUSH
91934: LD_INT 1
91936: NEG
91937: PUSH
91938: LD_INT 2
91940: NEG
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 1
91948: PUSH
91949: LD_INT 2
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: EMPTY
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91967: LD_ADDR_VAR 0 37
91971: PUSH
91972: LD_INT 0
91974: PUSH
91975: LD_INT 0
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 0
91984: PUSH
91985: LD_INT 1
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 1
91995: PUSH
91996: LD_INT 0
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 1
92005: PUSH
92006: LD_INT 1
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 1
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: NEG
92026: PUSH
92027: LD_INT 0
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PUSH
92034: LD_INT 1
92036: NEG
92037: PUSH
92038: LD_INT 1
92040: NEG
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 1
92048: PUSH
92049: LD_INT 1
92051: NEG
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 1
92059: NEG
92060: PUSH
92061: LD_INT 1
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
92079: LD_ADDR_VAR 0 38
92083: PUSH
92084: LD_INT 0
92086: PUSH
92087: LD_INT 0
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 0
92096: PUSH
92097: LD_INT 1
92099: NEG
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 1
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 1
92117: PUSH
92118: LD_INT 1
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 0
92127: PUSH
92128: LD_INT 1
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: LD_INT 0
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PUSH
92146: LD_INT 1
92148: NEG
92149: PUSH
92150: LD_INT 1
92152: NEG
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 2
92160: PUSH
92161: LD_INT 1
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: LD_INT 2
92170: NEG
92171: PUSH
92172: LD_INT 1
92174: NEG
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
92191: LD_ADDR_VAR 0 39
92195: PUSH
92196: LD_INT 0
92198: PUSH
92199: LD_INT 0
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 0
92208: PUSH
92209: LD_INT 1
92211: NEG
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 1
92219: PUSH
92220: LD_INT 0
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 1
92229: PUSH
92230: LD_INT 1
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 0
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 1
92249: NEG
92250: PUSH
92251: LD_INT 0
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 1
92260: NEG
92261: PUSH
92262: LD_INT 1
92264: NEG
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: LD_INT 1
92272: NEG
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 1
92284: PUSH
92285: LD_INT 2
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
92303: LD_ADDR_VAR 0 40
92307: PUSH
92308: LD_INT 0
92310: PUSH
92311: LD_INT 0
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 0
92320: PUSH
92321: LD_INT 1
92323: NEG
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 1
92331: PUSH
92332: LD_INT 0
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 1
92341: PUSH
92342: LD_INT 1
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: PUSH
92349: LD_INT 0
92351: PUSH
92352: LD_INT 1
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 1
92361: NEG
92362: PUSH
92363: LD_INT 0
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: LD_INT 1
92372: NEG
92373: PUSH
92374: LD_INT 1
92376: NEG
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: LD_INT 1
92384: PUSH
92385: LD_INT 1
92387: NEG
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 1
92395: NEG
92396: PUSH
92397: LD_INT 1
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92415: LD_ADDR_VAR 0 41
92419: PUSH
92420: LD_INT 0
92422: PUSH
92423: LD_INT 0
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: LD_INT 0
92432: PUSH
92433: LD_INT 1
92435: NEG
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 1
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 1
92453: PUSH
92454: LD_INT 1
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 0
92463: PUSH
92464: LD_INT 1
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 1
92473: NEG
92474: PUSH
92475: LD_INT 0
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 1
92484: NEG
92485: PUSH
92486: LD_INT 1
92488: NEG
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 1
92496: NEG
92497: PUSH
92498: LD_INT 2
92500: NEG
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 1
92508: PUSH
92509: LD_INT 1
92511: NEG
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 2
92519: PUSH
92520: LD_INT 0
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 2
92529: PUSH
92530: LD_INT 1
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 2
92539: PUSH
92540: LD_INT 2
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 1
92549: PUSH
92550: LD_INT 2
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 1
92559: NEG
92560: PUSH
92561: LD_INT 1
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 2
92570: NEG
92571: PUSH
92572: LD_INT 0
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PUSH
92579: LD_INT 2
92581: NEG
92582: PUSH
92583: LD_INT 1
92585: NEG
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 2
92593: NEG
92594: PUSH
92595: LD_INT 2
92597: NEG
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 2
92605: NEG
92606: PUSH
92607: LD_INT 3
92609: NEG
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 2
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 3
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 3
92638: PUSH
92639: LD_INT 1
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 3
92648: PUSH
92649: LD_INT 2
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 3
92658: PUSH
92659: LD_INT 3
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 2
92668: PUSH
92669: LD_INT 3
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 2
92678: NEG
92679: PUSH
92680: LD_INT 1
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 3
92689: NEG
92690: PUSH
92691: LD_INT 0
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 3
92700: NEG
92701: PUSH
92702: LD_INT 1
92704: NEG
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 3
92712: NEG
92713: PUSH
92714: LD_INT 2
92716: NEG
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 3
92724: NEG
92725: PUSH
92726: LD_INT 3
92728: NEG
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92765: LD_ADDR_VAR 0 42
92769: PUSH
92770: LD_INT 0
92772: PUSH
92773: LD_INT 0
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 0
92782: PUSH
92783: LD_INT 1
92785: NEG
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 1
92793: PUSH
92794: LD_INT 0
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: LD_INT 1
92803: PUSH
92804: LD_INT 1
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 0
92813: PUSH
92814: LD_INT 1
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 1
92823: NEG
92824: PUSH
92825: LD_INT 0
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 1
92834: NEG
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: PUSH
92844: LD_INT 1
92846: NEG
92847: PUSH
92848: LD_INT 2
92850: NEG
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: PUSH
92856: LD_INT 0
92858: PUSH
92859: LD_INT 2
92861: NEG
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 1
92869: PUSH
92870: LD_INT 1
92872: NEG
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 2
92880: PUSH
92881: LD_INT 1
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 2
92890: PUSH
92891: LD_INT 2
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: LD_INT 1
92900: PUSH
92901: LD_INT 2
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 0
92910: PUSH
92911: LD_INT 2
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 1
92920: NEG
92921: PUSH
92922: LD_INT 1
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 2
92931: NEG
92932: PUSH
92933: LD_INT 1
92935: NEG
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 2
92943: NEG
92944: PUSH
92945: LD_INT 2
92947: NEG
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 2
92955: NEG
92956: PUSH
92957: LD_INT 3
92959: NEG
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 1
92967: NEG
92968: PUSH
92969: LD_INT 3
92971: NEG
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 0
92979: PUSH
92980: LD_INT 3
92982: NEG
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: LD_INT 2
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 3
93001: PUSH
93002: LD_INT 2
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PUSH
93009: LD_INT 3
93011: PUSH
93012: LD_INT 3
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: PUSH
93022: LD_INT 3
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 1
93031: PUSH
93032: LD_INT 3
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 0
93041: PUSH
93042: LD_INT 3
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 1
93051: NEG
93052: PUSH
93053: LD_INT 2
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 3
93062: NEG
93063: PUSH
93064: LD_INT 2
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 3
93074: NEG
93075: PUSH
93076: LD_INT 3
93078: NEG
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: LIST
93104: LIST
93105: LIST
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93115: LD_ADDR_VAR 0 43
93119: PUSH
93120: LD_INT 0
93122: PUSH
93123: LD_INT 0
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 0
93132: PUSH
93133: LD_INT 1
93135: NEG
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PUSH
93141: LD_INT 1
93143: PUSH
93144: LD_INT 0
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 1
93153: PUSH
93154: LD_INT 1
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 0
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 1
93173: NEG
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 1
93184: NEG
93185: PUSH
93186: LD_INT 1
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 1
93196: NEG
93197: PUSH
93198: LD_INT 2
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 0
93208: PUSH
93209: LD_INT 2
93211: NEG
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 1
93219: PUSH
93220: LD_INT 1
93222: NEG
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: PUSH
93228: LD_INT 2
93230: PUSH
93231: LD_INT 0
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 2
93240: PUSH
93241: LD_INT 1
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 1
93250: PUSH
93251: LD_INT 2
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 0
93260: PUSH
93261: LD_INT 2
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 1
93270: NEG
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 2
93281: NEG
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 2
93292: NEG
93293: PUSH
93294: LD_INT 1
93296: NEG
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: NEG
93305: PUSH
93306: LD_INT 3
93308: NEG
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 0
93316: PUSH
93317: LD_INT 3
93319: NEG
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 1
93327: PUSH
93328: LD_INT 2
93330: NEG
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 2
93338: PUSH
93339: LD_INT 1
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 3
93349: PUSH
93350: LD_INT 0
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: LD_INT 3
93359: PUSH
93360: LD_INT 1
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: PUSH
93367: LD_INT 1
93369: PUSH
93370: LD_INT 3
93372: PUSH
93373: EMPTY
93374: LIST
93375: LIST
93376: PUSH
93377: LD_INT 0
93379: PUSH
93380: LD_INT 3
93382: PUSH
93383: EMPTY
93384: LIST
93385: LIST
93386: PUSH
93387: LD_INT 1
93389: NEG
93390: PUSH
93391: LD_INT 2
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 2
93400: NEG
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 3
93411: NEG
93412: PUSH
93413: LD_INT 0
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 3
93422: NEG
93423: PUSH
93424: LD_INT 1
93426: NEG
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93463: LD_ADDR_VAR 0 44
93467: PUSH
93468: LD_INT 0
93470: PUSH
93471: LD_INT 0
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 0
93480: PUSH
93481: LD_INT 1
93483: NEG
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 1
93491: PUSH
93492: LD_INT 0
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PUSH
93499: LD_INT 1
93501: PUSH
93502: LD_INT 1
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: LD_INT 0
93511: PUSH
93512: LD_INT 1
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: PUSH
93519: LD_INT 1
93521: NEG
93522: PUSH
93523: LD_INT 0
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 1
93532: NEG
93533: PUSH
93534: LD_INT 1
93536: NEG
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 1
93544: NEG
93545: PUSH
93546: LD_INT 2
93548: NEG
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 1
93556: PUSH
93557: LD_INT 1
93559: NEG
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: LD_INT 2
93567: PUSH
93568: LD_INT 0
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 2
93577: PUSH
93578: LD_INT 1
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 2
93587: PUSH
93588: LD_INT 2
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 1
93597: PUSH
93598: LD_INT 2
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 1
93607: NEG
93608: PUSH
93609: LD_INT 1
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 2
93618: NEG
93619: PUSH
93620: LD_INT 0
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 2
93629: NEG
93630: PUSH
93631: LD_INT 1
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 2
93641: NEG
93642: PUSH
93643: LD_INT 2
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 2
93653: NEG
93654: PUSH
93655: LD_INT 3
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 2
93665: PUSH
93666: LD_INT 1
93668: NEG
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 3
93676: PUSH
93677: LD_INT 0
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 3
93686: PUSH
93687: LD_INT 1
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 3
93696: PUSH
93697: LD_INT 2
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 3
93706: PUSH
93707: LD_INT 3
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 2
93716: PUSH
93717: LD_INT 3
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 2
93726: NEG
93727: PUSH
93728: LD_INT 1
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PUSH
93735: LD_INT 3
93737: NEG
93738: PUSH
93739: LD_INT 0
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PUSH
93746: LD_INT 3
93748: NEG
93749: PUSH
93750: LD_INT 1
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 3
93760: NEG
93761: PUSH
93762: LD_INT 2
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 3
93772: NEG
93773: PUSH
93774: LD_INT 3
93776: NEG
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93813: LD_ADDR_VAR 0 45
93817: PUSH
93818: LD_INT 0
93820: PUSH
93821: LD_INT 0
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: PUSH
93828: LD_INT 0
93830: PUSH
93831: LD_INT 1
93833: NEG
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 1
93841: PUSH
93842: LD_INT 0
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 1
93851: PUSH
93852: LD_INT 1
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 0
93861: PUSH
93862: LD_INT 1
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: LD_INT 1
93871: NEG
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 1
93882: NEG
93883: PUSH
93884: LD_INT 1
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 1
93894: NEG
93895: PUSH
93896: LD_INT 2
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 1
93917: PUSH
93918: LD_INT 1
93920: NEG
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 2
93928: PUSH
93929: LD_INT 1
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 2
93938: PUSH
93939: LD_INT 2
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 1
93948: PUSH
93949: LD_INT 2
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 0
93958: PUSH
93959: LD_INT 2
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 1
93968: NEG
93969: PUSH
93970: LD_INT 1
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 2
93979: NEG
93980: PUSH
93981: LD_INT 1
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 2
93991: NEG
93992: PUSH
93993: LD_INT 2
93995: NEG
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 2
94003: NEG
94004: PUSH
94005: LD_INT 3
94007: NEG
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 1
94015: NEG
94016: PUSH
94017: LD_INT 3
94019: NEG
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: LD_INT 0
94027: PUSH
94028: LD_INT 3
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 1
94038: PUSH
94039: LD_INT 2
94041: NEG
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 3
94049: PUSH
94050: LD_INT 2
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 3
94059: PUSH
94060: LD_INT 3
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: LD_INT 2
94069: PUSH
94070: LD_INT 3
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 1
94079: PUSH
94080: LD_INT 3
94082: PUSH
94083: EMPTY
94084: LIST
94085: LIST
94086: PUSH
94087: LD_INT 0
94089: PUSH
94090: LD_INT 3
94092: PUSH
94093: EMPTY
94094: LIST
94095: LIST
94096: PUSH
94097: LD_INT 1
94099: NEG
94100: PUSH
94101: LD_INT 2
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 3
94110: NEG
94111: PUSH
94112: LD_INT 2
94114: NEG
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: LD_INT 3
94126: NEG
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94163: LD_ADDR_VAR 0 46
94167: PUSH
94168: LD_INT 0
94170: PUSH
94171: LD_INT 0
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 0
94180: PUSH
94181: LD_INT 1
94183: NEG
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: LD_INT 0
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 1
94201: PUSH
94202: LD_INT 1
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 0
94211: PUSH
94212: LD_INT 1
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: NEG
94222: PUSH
94223: LD_INT 0
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 1
94232: NEG
94233: PUSH
94234: LD_INT 1
94236: NEG
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 1
94244: NEG
94245: PUSH
94246: LD_INT 2
94248: NEG
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 0
94256: PUSH
94257: LD_INT 2
94259: NEG
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 1
94267: PUSH
94268: LD_INT 1
94270: NEG
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 2
94278: PUSH
94279: LD_INT 0
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 2
94288: PUSH
94289: LD_INT 1
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 1
94298: PUSH
94299: LD_INT 2
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 0
94308: PUSH
94309: LD_INT 2
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: LD_INT 1
94318: NEG
94319: PUSH
94320: LD_INT 1
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 2
94329: NEG
94330: PUSH
94331: LD_INT 0
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 2
94340: NEG
94341: PUSH
94342: LD_INT 1
94344: NEG
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 1
94352: NEG
94353: PUSH
94354: LD_INT 3
94356: NEG
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 0
94364: PUSH
94365: LD_INT 3
94367: NEG
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: LD_INT 2
94378: NEG
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 2
94386: PUSH
94387: LD_INT 1
94389: NEG
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 3
94397: PUSH
94398: LD_INT 0
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 3
94407: PUSH
94408: LD_INT 1
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: LD_INT 3
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: LD_INT 3
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 1
94437: NEG
94438: PUSH
94439: LD_INT 2
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 2
94448: NEG
94449: PUSH
94450: LD_INT 1
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 3
94459: NEG
94460: PUSH
94461: LD_INT 0
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 3
94470: NEG
94471: PUSH
94472: LD_INT 1
94474: NEG
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94511: LD_ADDR_VAR 0 47
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: LD_INT 0
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 0
94528: PUSH
94529: LD_INT 1
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 1
94539: PUSH
94540: LD_INT 0
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 1
94549: PUSH
94550: LD_INT 1
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 0
94559: PUSH
94560: LD_INT 1
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 1
94569: NEG
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 1
94580: NEG
94581: PUSH
94582: LD_INT 1
94584: NEG
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 1
94592: NEG
94593: PUSH
94594: LD_INT 2
94596: NEG
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 0
94604: PUSH
94605: LD_INT 2
94607: NEG
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 1
94615: PUSH
94616: LD_INT 1
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 2
94626: NEG
94627: PUSH
94628: LD_INT 1
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 2
94638: NEG
94639: PUSH
94640: LD_INT 2
94642: NEG
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94662: LD_ADDR_VAR 0 48
94666: PUSH
94667: LD_INT 0
94669: PUSH
94670: LD_INT 0
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 0
94679: PUSH
94680: LD_INT 1
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 1
94690: PUSH
94691: LD_INT 0
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: LD_INT 1
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 0
94710: PUSH
94711: LD_INT 1
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 1
94720: NEG
94721: PUSH
94722: LD_INT 0
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: LD_INT 1
94731: NEG
94732: PUSH
94733: LD_INT 1
94735: NEG
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 1
94743: NEG
94744: PUSH
94745: LD_INT 2
94747: NEG
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 0
94755: PUSH
94756: LD_INT 2
94758: NEG
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 1
94766: PUSH
94767: LD_INT 1
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 2
94777: PUSH
94778: LD_INT 0
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 2
94787: PUSH
94788: LD_INT 1
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94809: LD_ADDR_VAR 0 49
94813: PUSH
94814: LD_INT 0
94816: PUSH
94817: LD_INT 0
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 0
94826: PUSH
94827: LD_INT 1
94829: NEG
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 1
94837: PUSH
94838: LD_INT 0
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 1
94847: PUSH
94848: LD_INT 1
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 0
94857: PUSH
94858: LD_INT 1
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 1
94867: NEG
94868: PUSH
94869: LD_INT 0
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 1
94878: NEG
94879: PUSH
94880: LD_INT 1
94882: NEG
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 1
94890: PUSH
94891: LD_INT 1
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 2
94901: PUSH
94902: LD_INT 0
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 2
94911: PUSH
94912: LD_INT 1
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 2
94921: PUSH
94922: LD_INT 2
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 1
94931: PUSH
94932: LD_INT 2
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94953: LD_ADDR_VAR 0 50
94957: PUSH
94958: LD_INT 0
94960: PUSH
94961: LD_INT 0
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: PUSH
94968: LD_INT 0
94970: PUSH
94971: LD_INT 1
94973: NEG
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: LD_INT 1
94981: PUSH
94982: LD_INT 0
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 1
94991: PUSH
94992: LD_INT 1
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 0
95001: PUSH
95002: LD_INT 1
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: PUSH
95009: LD_INT 1
95011: NEG
95012: PUSH
95013: LD_INT 0
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 1
95022: NEG
95023: PUSH
95024: LD_INT 1
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 2
95034: PUSH
95035: LD_INT 1
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: PUSH
95042: LD_INT 2
95044: PUSH
95045: LD_INT 2
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 1
95054: PUSH
95055: LD_INT 2
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 0
95064: PUSH
95065: LD_INT 2
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 1
95074: NEG
95075: PUSH
95076: LD_INT 1
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95097: LD_ADDR_VAR 0 51
95101: PUSH
95102: LD_INT 0
95104: PUSH
95105: LD_INT 0
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 0
95114: PUSH
95115: LD_INT 1
95117: NEG
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 1
95125: PUSH
95126: LD_INT 0
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 1
95135: PUSH
95136: LD_INT 1
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 0
95145: PUSH
95146: LD_INT 1
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 1
95155: NEG
95156: PUSH
95157: LD_INT 0
95159: PUSH
95160: EMPTY
95161: LIST
95162: LIST
95163: PUSH
95164: LD_INT 1
95166: NEG
95167: PUSH
95168: LD_INT 1
95170: NEG
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: LD_INT 1
95178: PUSH
95179: LD_INT 2
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 0
95188: PUSH
95189: LD_INT 2
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 1
95198: NEG
95199: PUSH
95200: LD_INT 1
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 2
95209: NEG
95210: PUSH
95211: LD_INT 0
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PUSH
95218: LD_INT 2
95220: NEG
95221: PUSH
95222: LD_INT 1
95224: NEG
95225: PUSH
95226: EMPTY
95227: LIST
95228: LIST
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95244: LD_ADDR_VAR 0 52
95248: PUSH
95249: LD_INT 0
95251: PUSH
95252: LD_INT 0
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 0
95261: PUSH
95262: LD_INT 1
95264: NEG
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PUSH
95270: LD_INT 1
95272: PUSH
95273: LD_INT 0
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 1
95282: PUSH
95283: LD_INT 1
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 0
95292: PUSH
95293: LD_INT 1
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 1
95302: NEG
95303: PUSH
95304: LD_INT 0
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: PUSH
95311: LD_INT 1
95313: NEG
95314: PUSH
95315: LD_INT 1
95317: NEG
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 1
95325: NEG
95326: PUSH
95327: LD_INT 2
95329: NEG
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 1
95337: NEG
95338: PUSH
95339: LD_INT 1
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 2
95348: NEG
95349: PUSH
95350: LD_INT 0
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 2
95359: NEG
95360: PUSH
95361: LD_INT 1
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 2
95371: NEG
95372: PUSH
95373: LD_INT 2
95375: NEG
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95395: LD_ADDR_VAR 0 53
95399: PUSH
95400: LD_INT 0
95402: PUSH
95403: LD_INT 0
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 0
95412: PUSH
95413: LD_INT 1
95415: NEG
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 1
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 1
95433: PUSH
95434: LD_INT 1
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 0
95443: PUSH
95444: LD_INT 1
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 1
95453: NEG
95454: PUSH
95455: LD_INT 0
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 1
95464: NEG
95465: PUSH
95466: LD_INT 1
95468: NEG
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 1
95476: NEG
95477: PUSH
95478: LD_INT 2
95480: NEG
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 0
95488: PUSH
95489: LD_INT 2
95491: NEG
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 1
95499: PUSH
95500: LD_INT 1
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 2
95510: PUSH
95511: LD_INT 0
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 2
95520: PUSH
95521: LD_INT 1
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: LD_INT 2
95530: PUSH
95531: LD_INT 2
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: LD_INT 1
95540: PUSH
95541: LD_INT 2
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 0
95550: PUSH
95551: LD_INT 2
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: PUSH
95558: LD_INT 1
95560: NEG
95561: PUSH
95562: LD_INT 1
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 2
95571: NEG
95572: PUSH
95573: LD_INT 0
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 2
95582: NEG
95583: PUSH
95584: LD_INT 1
95586: NEG
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 2
95594: NEG
95595: PUSH
95596: LD_INT 2
95598: NEG
95599: PUSH
95600: EMPTY
95601: LIST
95602: LIST
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95625: LD_ADDR_VAR 0 54
95629: PUSH
95630: LD_INT 0
95632: PUSH
95633: LD_INT 0
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 0
95642: PUSH
95643: LD_INT 1
95645: NEG
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 1
95653: PUSH
95654: LD_INT 0
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 1
95663: PUSH
95664: LD_INT 1
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 0
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PUSH
95681: LD_INT 1
95683: NEG
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: LD_INT 1
95694: NEG
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 1
95706: NEG
95707: PUSH
95708: LD_INT 2
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 0
95718: PUSH
95719: LD_INT 2
95721: NEG
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 1
95729: PUSH
95730: LD_INT 1
95732: NEG
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: PUSH
95738: LD_INT 2
95740: PUSH
95741: LD_INT 0
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 2
95750: PUSH
95751: LD_INT 1
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 2
95760: PUSH
95761: LD_INT 2
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 1
95770: PUSH
95771: LD_INT 2
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 0
95780: PUSH
95781: LD_INT 2
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 1
95790: NEG
95791: PUSH
95792: LD_INT 1
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 2
95801: NEG
95802: PUSH
95803: LD_INT 0
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: LD_INT 2
95812: NEG
95813: PUSH
95814: LD_INT 1
95816: NEG
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 2
95824: NEG
95825: PUSH
95826: LD_INT 2
95828: NEG
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95855: LD_ADDR_VAR 0 55
95859: PUSH
95860: LD_INT 0
95862: PUSH
95863: LD_INT 0
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 0
95872: PUSH
95873: LD_INT 1
95875: NEG
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 1
95883: PUSH
95884: LD_INT 0
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 1
95893: PUSH
95894: LD_INT 1
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: LD_INT 0
95903: PUSH
95904: LD_INT 1
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 1
95913: NEG
95914: PUSH
95915: LD_INT 0
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 1
95924: NEG
95925: PUSH
95926: LD_INT 1
95928: NEG
95929: PUSH
95930: EMPTY
95931: LIST
95932: LIST
95933: PUSH
95934: LD_INT 1
95936: NEG
95937: PUSH
95938: LD_INT 2
95940: NEG
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: LD_INT 0
95948: PUSH
95949: LD_INT 2
95951: NEG
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: LD_INT 1
95959: PUSH
95960: LD_INT 1
95962: NEG
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 2
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 2
95980: PUSH
95981: LD_INT 1
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 2
95990: PUSH
95991: LD_INT 2
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 1
96000: PUSH
96001: LD_INT 2
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 0
96010: PUSH
96011: LD_INT 2
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 1
96020: NEG
96021: PUSH
96022: LD_INT 1
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 2
96031: NEG
96032: PUSH
96033: LD_INT 0
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 2
96042: NEG
96043: PUSH
96044: LD_INT 1
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 2
96054: NEG
96055: PUSH
96056: LD_INT 2
96058: NEG
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: EMPTY
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96085: LD_ADDR_VAR 0 56
96089: PUSH
96090: LD_INT 0
96092: PUSH
96093: LD_INT 0
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 0
96102: PUSH
96103: LD_INT 1
96105: NEG
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: LD_INT 1
96113: PUSH
96114: LD_INT 0
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 1
96123: PUSH
96124: LD_INT 1
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: PUSH
96131: LD_INT 0
96133: PUSH
96134: LD_INT 1
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 1
96143: NEG
96144: PUSH
96145: LD_INT 0
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 1
96154: NEG
96155: PUSH
96156: LD_INT 1
96158: NEG
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 1
96166: NEG
96167: PUSH
96168: LD_INT 2
96170: NEG
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 0
96178: PUSH
96179: LD_INT 2
96181: NEG
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: LD_INT 1
96189: PUSH
96190: LD_INT 1
96192: NEG
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: LD_INT 2
96200: PUSH
96201: LD_INT 0
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: LD_INT 1
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 2
96220: PUSH
96221: LD_INT 2
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 1
96230: PUSH
96231: LD_INT 2
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 0
96240: PUSH
96241: LD_INT 2
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 1
96250: NEG
96251: PUSH
96252: LD_INT 1
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 2
96261: NEG
96262: PUSH
96263: LD_INT 0
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 2
96272: NEG
96273: PUSH
96274: LD_INT 1
96276: NEG
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 2
96284: NEG
96285: PUSH
96286: LD_INT 2
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96315: LD_ADDR_VAR 0 57
96319: PUSH
96320: LD_INT 0
96322: PUSH
96323: LD_INT 0
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: PUSH
96330: LD_INT 0
96332: PUSH
96333: LD_INT 1
96335: NEG
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 1
96343: PUSH
96344: LD_INT 0
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 1
96353: PUSH
96354: LD_INT 1
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 0
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 1
96373: NEG
96374: PUSH
96375: LD_INT 0
96377: PUSH
96378: EMPTY
96379: LIST
96380: LIST
96381: PUSH
96382: LD_INT 1
96384: NEG
96385: PUSH
96386: LD_INT 1
96388: NEG
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 1
96396: NEG
96397: PUSH
96398: LD_INT 2
96400: NEG
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 0
96408: PUSH
96409: LD_INT 2
96411: NEG
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: LD_INT 1
96419: PUSH
96420: LD_INT 1
96422: NEG
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: LD_INT 0
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 2
96440: PUSH
96441: LD_INT 1
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 2
96450: PUSH
96451: LD_INT 2
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 1
96460: PUSH
96461: LD_INT 2
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 0
96470: PUSH
96471: LD_INT 2
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: LD_INT 1
96480: NEG
96481: PUSH
96482: LD_INT 1
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: LD_INT 2
96491: NEG
96492: PUSH
96493: LD_INT 0
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: LD_INT 2
96502: NEG
96503: PUSH
96504: LD_INT 1
96506: NEG
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: PUSH
96512: LD_INT 2
96514: NEG
96515: PUSH
96516: LD_INT 2
96518: NEG
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96545: LD_ADDR_VAR 0 58
96549: PUSH
96550: LD_INT 0
96552: PUSH
96553: LD_INT 0
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 0
96562: PUSH
96563: LD_INT 1
96565: NEG
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: LD_INT 1
96573: PUSH
96574: LD_INT 0
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 1
96583: PUSH
96584: LD_INT 1
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 0
96593: PUSH
96594: LD_INT 1
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: LD_INT 1
96603: NEG
96604: PUSH
96605: LD_INT 0
96607: PUSH
96608: EMPTY
96609: LIST
96610: LIST
96611: PUSH
96612: LD_INT 1
96614: NEG
96615: PUSH
96616: LD_INT 1
96618: NEG
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 1
96626: NEG
96627: PUSH
96628: LD_INT 2
96630: NEG
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 0
96638: PUSH
96639: LD_INT 2
96641: NEG
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: PUSH
96647: LD_INT 1
96649: PUSH
96650: LD_INT 1
96652: NEG
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 2
96660: PUSH
96661: LD_INT 0
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 2
96670: PUSH
96671: LD_INT 1
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 2
96680: PUSH
96681: LD_INT 2
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 1
96690: PUSH
96691: LD_INT 2
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: PUSH
96698: LD_INT 0
96700: PUSH
96701: LD_INT 2
96703: PUSH
96704: EMPTY
96705: LIST
96706: LIST
96707: PUSH
96708: LD_INT 1
96710: NEG
96711: PUSH
96712: LD_INT 1
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: PUSH
96719: LD_INT 2
96721: NEG
96722: PUSH
96723: LD_INT 0
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 2
96732: NEG
96733: PUSH
96734: LD_INT 1
96736: NEG
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: PUSH
96742: LD_INT 2
96744: NEG
96745: PUSH
96746: LD_INT 2
96748: NEG
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96775: LD_ADDR_VAR 0 59
96779: PUSH
96780: LD_INT 0
96782: PUSH
96783: LD_INT 0
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PUSH
96790: LD_INT 0
96792: PUSH
96793: LD_INT 1
96795: NEG
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 1
96803: PUSH
96804: LD_INT 0
96806: PUSH
96807: EMPTY
96808: LIST
96809: LIST
96810: PUSH
96811: LD_INT 1
96813: PUSH
96814: LD_INT 1
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 0
96823: PUSH
96824: LD_INT 1
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 1
96833: NEG
96834: PUSH
96835: LD_INT 0
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: PUSH
96842: LD_INT 1
96844: NEG
96845: PUSH
96846: LD_INT 1
96848: NEG
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96863: LD_ADDR_VAR 0 60
96867: PUSH
96868: LD_INT 0
96870: PUSH
96871: LD_INT 0
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 0
96880: PUSH
96881: LD_INT 1
96883: NEG
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 1
96891: PUSH
96892: LD_INT 0
96894: PUSH
96895: EMPTY
96896: LIST
96897: LIST
96898: PUSH
96899: LD_INT 1
96901: PUSH
96902: LD_INT 1
96904: PUSH
96905: EMPTY
96906: LIST
96907: LIST
96908: PUSH
96909: LD_INT 0
96911: PUSH
96912: LD_INT 1
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 1
96921: NEG
96922: PUSH
96923: LD_INT 0
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PUSH
96930: LD_INT 1
96932: NEG
96933: PUSH
96934: LD_INT 1
96936: NEG
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96951: LD_ADDR_VAR 0 61
96955: PUSH
96956: LD_INT 0
96958: PUSH
96959: LD_INT 0
96961: PUSH
96962: EMPTY
96963: LIST
96964: LIST
96965: PUSH
96966: LD_INT 0
96968: PUSH
96969: LD_INT 1
96971: NEG
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PUSH
96977: LD_INT 1
96979: PUSH
96980: LD_INT 0
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: PUSH
96987: LD_INT 1
96989: PUSH
96990: LD_INT 1
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 0
96999: PUSH
97000: LD_INT 1
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 1
97009: NEG
97010: PUSH
97011: LD_INT 0
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PUSH
97018: LD_INT 1
97020: NEG
97021: PUSH
97022: LD_INT 1
97024: NEG
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97039: LD_ADDR_VAR 0 62
97043: PUSH
97044: LD_INT 0
97046: PUSH
97047: LD_INT 0
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: PUSH
97054: LD_INT 0
97056: PUSH
97057: LD_INT 1
97059: NEG
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: PUSH
97065: LD_INT 1
97067: PUSH
97068: LD_INT 0
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 1
97077: PUSH
97078: LD_INT 1
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 0
97087: PUSH
97088: LD_INT 1
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 1
97097: NEG
97098: PUSH
97099: LD_INT 0
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 1
97108: NEG
97109: PUSH
97110: LD_INT 1
97112: NEG
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97127: LD_ADDR_VAR 0 63
97131: PUSH
97132: LD_INT 0
97134: PUSH
97135: LD_INT 0
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: LD_INT 0
97144: PUSH
97145: LD_INT 1
97147: NEG
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: PUSH
97153: LD_INT 1
97155: PUSH
97156: LD_INT 0
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: PUSH
97163: LD_INT 1
97165: PUSH
97166: LD_INT 1
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: PUSH
97173: LD_INT 0
97175: PUSH
97176: LD_INT 1
97178: PUSH
97179: EMPTY
97180: LIST
97181: LIST
97182: PUSH
97183: LD_INT 1
97185: NEG
97186: PUSH
97187: LD_INT 0
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: LD_INT 1
97196: NEG
97197: PUSH
97198: LD_INT 1
97200: NEG
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97215: LD_ADDR_VAR 0 64
97219: PUSH
97220: LD_INT 0
97222: PUSH
97223: LD_INT 0
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 0
97232: PUSH
97233: LD_INT 1
97235: NEG
97236: PUSH
97237: EMPTY
97238: LIST
97239: LIST
97240: PUSH
97241: LD_INT 1
97243: PUSH
97244: LD_INT 0
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: PUSH
97251: LD_INT 1
97253: PUSH
97254: LD_INT 1
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 0
97263: PUSH
97264: LD_INT 1
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 1
97273: NEG
97274: PUSH
97275: LD_INT 0
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PUSH
97282: LD_INT 1
97284: NEG
97285: PUSH
97286: LD_INT 1
97288: NEG
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: ST_TO_ADDR
// end ; 1 :
97303: GO 103200
97305: LD_INT 1
97307: DOUBLE
97308: EQUAL
97309: IFTRUE 97313
97311: GO 99936
97313: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97314: LD_ADDR_VAR 0 11
97318: PUSH
97319: LD_INT 1
97321: NEG
97322: PUSH
97323: LD_INT 3
97325: NEG
97326: PUSH
97327: EMPTY
97328: LIST
97329: LIST
97330: PUSH
97331: LD_INT 0
97333: PUSH
97334: LD_INT 3
97336: NEG
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: PUSH
97342: LD_INT 1
97344: PUSH
97345: LD_INT 2
97347: NEG
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: LIST
97357: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97358: LD_ADDR_VAR 0 12
97362: PUSH
97363: LD_INT 2
97365: PUSH
97366: LD_INT 1
97368: NEG
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 3
97376: PUSH
97377: LD_INT 0
97379: PUSH
97380: EMPTY
97381: LIST
97382: LIST
97383: PUSH
97384: LD_INT 3
97386: PUSH
97387: LD_INT 1
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: LIST
97398: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97399: LD_ADDR_VAR 0 13
97403: PUSH
97404: LD_INT 3
97406: PUSH
97407: LD_INT 2
97409: PUSH
97410: EMPTY
97411: LIST
97412: LIST
97413: PUSH
97414: LD_INT 3
97416: PUSH
97417: LD_INT 3
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 2
97426: PUSH
97427: LD_INT 3
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: LIST
97438: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97439: LD_ADDR_VAR 0 14
97443: PUSH
97444: LD_INT 1
97446: PUSH
97447: LD_INT 3
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PUSH
97454: LD_INT 0
97456: PUSH
97457: LD_INT 3
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: PUSH
97464: LD_INT 1
97466: NEG
97467: PUSH
97468: LD_INT 2
97470: PUSH
97471: EMPTY
97472: LIST
97473: LIST
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: LIST
97479: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97480: LD_ADDR_VAR 0 15
97484: PUSH
97485: LD_INT 2
97487: NEG
97488: PUSH
97489: LD_INT 1
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_INT 3
97498: NEG
97499: PUSH
97500: LD_INT 0
97502: PUSH
97503: EMPTY
97504: LIST
97505: LIST
97506: PUSH
97507: LD_INT 3
97509: NEG
97510: PUSH
97511: LD_INT 1
97513: NEG
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: LIST
97523: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97524: LD_ADDR_VAR 0 16
97528: PUSH
97529: LD_INT 2
97531: NEG
97532: PUSH
97533: LD_INT 3
97535: NEG
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 3
97543: NEG
97544: PUSH
97545: LD_INT 2
97547: NEG
97548: PUSH
97549: EMPTY
97550: LIST
97551: LIST
97552: PUSH
97553: LD_INT 3
97555: NEG
97556: PUSH
97557: LD_INT 3
97559: NEG
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: EMPTY
97566: LIST
97567: LIST
97568: LIST
97569: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97570: LD_ADDR_VAR 0 17
97574: PUSH
97575: LD_INT 1
97577: NEG
97578: PUSH
97579: LD_INT 3
97581: NEG
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: LD_INT 0
97589: PUSH
97590: LD_INT 3
97592: NEG
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: LD_INT 1
97600: PUSH
97601: LD_INT 2
97603: NEG
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: EMPTY
97610: LIST
97611: LIST
97612: LIST
97613: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97614: LD_ADDR_VAR 0 18
97618: PUSH
97619: LD_INT 2
97621: PUSH
97622: LD_INT 1
97624: NEG
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 3
97632: PUSH
97633: LD_INT 0
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 3
97642: PUSH
97643: LD_INT 1
97645: PUSH
97646: EMPTY
97647: LIST
97648: LIST
97649: PUSH
97650: EMPTY
97651: LIST
97652: LIST
97653: LIST
97654: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97655: LD_ADDR_VAR 0 19
97659: PUSH
97660: LD_INT 3
97662: PUSH
97663: LD_INT 2
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: PUSH
97670: LD_INT 3
97672: PUSH
97673: LD_INT 3
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: PUSH
97680: LD_INT 2
97682: PUSH
97683: LD_INT 3
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: LIST
97694: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97695: LD_ADDR_VAR 0 20
97699: PUSH
97700: LD_INT 1
97702: PUSH
97703: LD_INT 3
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: LD_INT 0
97712: PUSH
97713: LD_INT 3
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: LD_INT 1
97722: NEG
97723: PUSH
97724: LD_INT 2
97726: PUSH
97727: EMPTY
97728: LIST
97729: LIST
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: LIST
97735: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97736: LD_ADDR_VAR 0 21
97740: PUSH
97741: LD_INT 2
97743: NEG
97744: PUSH
97745: LD_INT 1
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PUSH
97752: LD_INT 3
97754: NEG
97755: PUSH
97756: LD_INT 0
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: PUSH
97763: LD_INT 3
97765: NEG
97766: PUSH
97767: LD_INT 1
97769: NEG
97770: PUSH
97771: EMPTY
97772: LIST
97773: LIST
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: LIST
97779: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97780: LD_ADDR_VAR 0 22
97784: PUSH
97785: LD_INT 2
97787: NEG
97788: PUSH
97789: LD_INT 3
97791: NEG
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 3
97799: NEG
97800: PUSH
97801: LD_INT 2
97803: NEG
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 3
97811: NEG
97812: PUSH
97813: LD_INT 3
97815: NEG
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: EMPTY
97822: LIST
97823: LIST
97824: LIST
97825: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
97826: LD_ADDR_VAR 0 23
97830: PUSH
97831: LD_INT 0
97833: PUSH
97834: LD_INT 3
97836: NEG
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 1
97844: NEG
97845: PUSH
97846: LD_INT 4
97848: NEG
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: PUSH
97854: LD_INT 1
97856: PUSH
97857: LD_INT 3
97859: NEG
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: LIST
97869: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
97870: LD_ADDR_VAR 0 24
97874: PUSH
97875: LD_INT 3
97877: PUSH
97878: LD_INT 0
97880: PUSH
97881: EMPTY
97882: LIST
97883: LIST
97884: PUSH
97885: LD_INT 3
97887: PUSH
97888: LD_INT 1
97890: NEG
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: LD_INT 4
97898: PUSH
97899: LD_INT 1
97901: PUSH
97902: EMPTY
97903: LIST
97904: LIST
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: LIST
97910: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
97911: LD_ADDR_VAR 0 25
97915: PUSH
97916: LD_INT 3
97918: PUSH
97919: LD_INT 3
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: PUSH
97926: LD_INT 4
97928: PUSH
97929: LD_INT 3
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PUSH
97936: LD_INT 3
97938: PUSH
97939: LD_INT 4
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: LIST
97950: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97951: LD_ADDR_VAR 0 26
97955: PUSH
97956: LD_INT 0
97958: PUSH
97959: LD_INT 3
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 1
97968: PUSH
97969: LD_INT 4
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: LD_INT 1
97978: NEG
97979: PUSH
97980: LD_INT 3
97982: PUSH
97983: EMPTY
97984: LIST
97985: LIST
97986: PUSH
97987: EMPTY
97988: LIST
97989: LIST
97990: LIST
97991: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97992: LD_ADDR_VAR 0 27
97996: PUSH
97997: LD_INT 3
97999: NEG
98000: PUSH
98001: LD_INT 0
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: LD_INT 3
98010: NEG
98011: PUSH
98012: LD_INT 1
98014: PUSH
98015: EMPTY
98016: LIST
98017: LIST
98018: PUSH
98019: LD_INT 4
98021: NEG
98022: PUSH
98023: LD_INT 1
98025: NEG
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: LIST
98035: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
98036: LD_ADDR_VAR 0 28
98040: PUSH
98041: LD_INT 3
98043: NEG
98044: PUSH
98045: LD_INT 3
98047: NEG
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: LD_INT 3
98055: NEG
98056: PUSH
98057: LD_INT 4
98059: NEG
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: LD_INT 4
98067: NEG
98068: PUSH
98069: LD_INT 3
98071: NEG
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: LIST
98081: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
98082: LD_ADDR_VAR 0 29
98086: PUSH
98087: LD_INT 1
98089: NEG
98090: PUSH
98091: LD_INT 3
98093: NEG
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 0
98101: PUSH
98102: LD_INT 3
98104: NEG
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: PUSH
98110: LD_INT 1
98112: PUSH
98113: LD_INT 2
98115: NEG
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: PUSH
98121: LD_INT 1
98123: NEG
98124: PUSH
98125: LD_INT 4
98127: NEG
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PUSH
98133: LD_INT 0
98135: PUSH
98136: LD_INT 4
98138: NEG
98139: PUSH
98140: EMPTY
98141: LIST
98142: LIST
98143: PUSH
98144: LD_INT 1
98146: PUSH
98147: LD_INT 3
98149: NEG
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 1
98157: NEG
98158: PUSH
98159: LD_INT 5
98161: NEG
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: PUSH
98167: LD_INT 0
98169: PUSH
98170: LD_INT 5
98172: NEG
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: LD_INT 1
98180: PUSH
98181: LD_INT 4
98183: NEG
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: PUSH
98189: LD_INT 1
98191: NEG
98192: PUSH
98193: LD_INT 6
98195: NEG
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 0
98203: PUSH
98204: LD_INT 6
98206: NEG
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 1
98214: PUSH
98215: LD_INT 5
98217: NEG
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
98237: LD_ADDR_VAR 0 30
98241: PUSH
98242: LD_INT 2
98244: PUSH
98245: LD_INT 1
98247: NEG
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: PUSH
98253: LD_INT 3
98255: PUSH
98256: LD_INT 0
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 3
98265: PUSH
98266: LD_INT 1
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PUSH
98273: LD_INT 3
98275: PUSH
98276: LD_INT 1
98278: NEG
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: PUSH
98284: LD_INT 4
98286: PUSH
98287: LD_INT 0
98289: PUSH
98290: EMPTY
98291: LIST
98292: LIST
98293: PUSH
98294: LD_INT 4
98296: PUSH
98297: LD_INT 1
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PUSH
98304: LD_INT 4
98306: PUSH
98307: LD_INT 1
98309: NEG
98310: PUSH
98311: EMPTY
98312: LIST
98313: LIST
98314: PUSH
98315: LD_INT 5
98317: PUSH
98318: LD_INT 0
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: PUSH
98325: LD_INT 5
98327: PUSH
98328: LD_INT 1
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 5
98337: PUSH
98338: LD_INT 1
98340: NEG
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 6
98348: PUSH
98349: LD_INT 0
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: LD_INT 6
98358: PUSH
98359: LD_INT 1
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
98380: LD_ADDR_VAR 0 31
98384: PUSH
98385: LD_INT 3
98387: PUSH
98388: LD_INT 2
98390: PUSH
98391: EMPTY
98392: LIST
98393: LIST
98394: PUSH
98395: LD_INT 3
98397: PUSH
98398: LD_INT 3
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: PUSH
98405: LD_INT 2
98407: PUSH
98408: LD_INT 3
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: PUSH
98415: LD_INT 4
98417: PUSH
98418: LD_INT 3
98420: PUSH
98421: EMPTY
98422: LIST
98423: LIST
98424: PUSH
98425: LD_INT 4
98427: PUSH
98428: LD_INT 4
98430: PUSH
98431: EMPTY
98432: LIST
98433: LIST
98434: PUSH
98435: LD_INT 3
98437: PUSH
98438: LD_INT 4
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: PUSH
98445: LD_INT 5
98447: PUSH
98448: LD_INT 4
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: PUSH
98455: LD_INT 5
98457: PUSH
98458: LD_INT 5
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: PUSH
98465: LD_INT 4
98467: PUSH
98468: LD_INT 5
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: PUSH
98475: LD_INT 6
98477: PUSH
98478: LD_INT 5
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PUSH
98485: LD_INT 6
98487: PUSH
98488: LD_INT 6
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PUSH
98495: LD_INT 5
98497: PUSH
98498: LD_INT 6
98500: PUSH
98501: EMPTY
98502: LIST
98503: LIST
98504: PUSH
98505: EMPTY
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
98519: LD_ADDR_VAR 0 32
98523: PUSH
98524: LD_INT 1
98526: PUSH
98527: LD_INT 3
98529: PUSH
98530: EMPTY
98531: LIST
98532: LIST
98533: PUSH
98534: LD_INT 0
98536: PUSH
98537: LD_INT 3
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: PUSH
98544: LD_INT 1
98546: NEG
98547: PUSH
98548: LD_INT 2
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: PUSH
98555: LD_INT 1
98557: PUSH
98558: LD_INT 4
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: PUSH
98565: LD_INT 0
98567: PUSH
98568: LD_INT 4
98570: PUSH
98571: EMPTY
98572: LIST
98573: LIST
98574: PUSH
98575: LD_INT 1
98577: NEG
98578: PUSH
98579: LD_INT 3
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: PUSH
98586: LD_INT 1
98588: PUSH
98589: LD_INT 5
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: PUSH
98596: LD_INT 0
98598: PUSH
98599: LD_INT 5
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: PUSH
98606: LD_INT 1
98608: NEG
98609: PUSH
98610: LD_INT 4
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PUSH
98617: LD_INT 1
98619: PUSH
98620: LD_INT 6
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: PUSH
98627: LD_INT 0
98629: PUSH
98630: LD_INT 6
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_INT 1
98639: NEG
98640: PUSH
98641: LD_INT 5
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
98662: LD_ADDR_VAR 0 33
98666: PUSH
98667: LD_INT 2
98669: NEG
98670: PUSH
98671: LD_INT 1
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 3
98680: NEG
98681: PUSH
98682: LD_INT 0
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: LD_INT 3
98691: NEG
98692: PUSH
98693: LD_INT 1
98695: NEG
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: PUSH
98701: LD_INT 3
98703: NEG
98704: PUSH
98705: LD_INT 1
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 4
98714: NEG
98715: PUSH
98716: LD_INT 0
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: LD_INT 4
98725: NEG
98726: PUSH
98727: LD_INT 1
98729: NEG
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 4
98737: NEG
98738: PUSH
98739: LD_INT 1
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: PUSH
98746: LD_INT 5
98748: NEG
98749: PUSH
98750: LD_INT 0
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PUSH
98757: LD_INT 5
98759: NEG
98760: PUSH
98761: LD_INT 1
98763: NEG
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 5
98771: NEG
98772: PUSH
98773: LD_INT 1
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 6
98782: NEG
98783: PUSH
98784: LD_INT 0
98786: PUSH
98787: EMPTY
98788: LIST
98789: LIST
98790: PUSH
98791: LD_INT 6
98793: NEG
98794: PUSH
98795: LD_INT 1
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
98817: LD_ADDR_VAR 0 34
98821: PUSH
98822: LD_INT 2
98824: NEG
98825: PUSH
98826: LD_INT 3
98828: NEG
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 3
98836: NEG
98837: PUSH
98838: LD_INT 2
98840: NEG
98841: PUSH
98842: EMPTY
98843: LIST
98844: LIST
98845: PUSH
98846: LD_INT 3
98848: NEG
98849: PUSH
98850: LD_INT 3
98852: NEG
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: LD_INT 3
98860: NEG
98861: PUSH
98862: LD_INT 4
98864: NEG
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: LD_INT 4
98872: NEG
98873: PUSH
98874: LD_INT 3
98876: NEG
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: LD_INT 4
98884: NEG
98885: PUSH
98886: LD_INT 4
98888: NEG
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PUSH
98894: LD_INT 4
98896: NEG
98897: PUSH
98898: LD_INT 5
98900: NEG
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: LD_INT 5
98908: NEG
98909: PUSH
98910: LD_INT 4
98912: NEG
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PUSH
98918: LD_INT 5
98920: NEG
98921: PUSH
98922: LD_INT 5
98924: NEG
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: PUSH
98930: LD_INT 5
98932: NEG
98933: PUSH
98934: LD_INT 6
98936: NEG
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: PUSH
98942: LD_INT 6
98944: NEG
98945: PUSH
98946: LD_INT 5
98948: NEG
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: PUSH
98954: LD_INT 6
98956: NEG
98957: PUSH
98958: LD_INT 6
98960: NEG
98961: PUSH
98962: EMPTY
98963: LIST
98964: LIST
98965: PUSH
98966: EMPTY
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98980: LD_ADDR_VAR 0 41
98984: PUSH
98985: LD_INT 0
98987: PUSH
98988: LD_INT 2
98990: NEG
98991: PUSH
98992: EMPTY
98993: LIST
98994: LIST
98995: PUSH
98996: LD_INT 1
98998: NEG
98999: PUSH
99000: LD_INT 3
99002: NEG
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: LD_INT 1
99010: PUSH
99011: LD_INT 2
99013: NEG
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: LIST
99023: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
99024: LD_ADDR_VAR 0 42
99028: PUSH
99029: LD_INT 2
99031: PUSH
99032: LD_INT 0
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PUSH
99039: LD_INT 2
99041: PUSH
99042: LD_INT 1
99044: NEG
99045: PUSH
99046: EMPTY
99047: LIST
99048: LIST
99049: PUSH
99050: LD_INT 3
99052: PUSH
99053: LD_INT 1
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: LIST
99064: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
99065: LD_ADDR_VAR 0 43
99069: PUSH
99070: LD_INT 2
99072: PUSH
99073: LD_INT 2
99075: PUSH
99076: EMPTY
99077: LIST
99078: LIST
99079: PUSH
99080: LD_INT 3
99082: PUSH
99083: LD_INT 2
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: PUSH
99090: LD_INT 2
99092: PUSH
99093: LD_INT 3
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: EMPTY
99101: LIST
99102: LIST
99103: LIST
99104: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
99105: LD_ADDR_VAR 0 44
99109: PUSH
99110: LD_INT 0
99112: PUSH
99113: LD_INT 2
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: PUSH
99120: LD_INT 1
99122: PUSH
99123: LD_INT 3
99125: PUSH
99126: EMPTY
99127: LIST
99128: LIST
99129: PUSH
99130: LD_INT 1
99132: NEG
99133: PUSH
99134: LD_INT 2
99136: PUSH
99137: EMPTY
99138: LIST
99139: LIST
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: LIST
99145: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
99146: LD_ADDR_VAR 0 45
99150: PUSH
99151: LD_INT 2
99153: NEG
99154: PUSH
99155: LD_INT 0
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: PUSH
99162: LD_INT 2
99164: NEG
99165: PUSH
99166: LD_INT 1
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PUSH
99173: LD_INT 3
99175: NEG
99176: PUSH
99177: LD_INT 1
99179: NEG
99180: PUSH
99181: EMPTY
99182: LIST
99183: LIST
99184: PUSH
99185: EMPTY
99186: LIST
99187: LIST
99188: LIST
99189: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
99190: LD_ADDR_VAR 0 46
99194: PUSH
99195: LD_INT 2
99197: NEG
99198: PUSH
99199: LD_INT 2
99201: NEG
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: PUSH
99207: LD_INT 2
99209: NEG
99210: PUSH
99211: LD_INT 3
99213: NEG
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: LD_INT 3
99221: NEG
99222: PUSH
99223: LD_INT 2
99225: NEG
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: LIST
99235: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
99236: LD_ADDR_VAR 0 47
99240: PUSH
99241: LD_INT 2
99243: NEG
99244: PUSH
99245: LD_INT 3
99247: NEG
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: LD_INT 1
99255: NEG
99256: PUSH
99257: LD_INT 3
99259: NEG
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
99269: LD_ADDR_VAR 0 48
99273: PUSH
99274: LD_INT 1
99276: PUSH
99277: LD_INT 2
99279: NEG
99280: PUSH
99281: EMPTY
99282: LIST
99283: LIST
99284: PUSH
99285: LD_INT 2
99287: PUSH
99288: LD_INT 1
99290: NEG
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
99300: LD_ADDR_VAR 0 49
99304: PUSH
99305: LD_INT 3
99307: PUSH
99308: LD_INT 1
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: PUSH
99315: LD_INT 3
99317: PUSH
99318: LD_INT 2
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
99329: LD_ADDR_VAR 0 50
99333: PUSH
99334: LD_INT 2
99336: PUSH
99337: LD_INT 3
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 1
99346: PUSH
99347: LD_INT 3
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PUSH
99354: EMPTY
99355: LIST
99356: LIST
99357: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
99358: LD_ADDR_VAR 0 51
99362: PUSH
99363: LD_INT 1
99365: NEG
99366: PUSH
99367: LD_INT 2
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: PUSH
99374: LD_INT 2
99376: NEG
99377: PUSH
99378: LD_INT 1
99380: PUSH
99381: EMPTY
99382: LIST
99383: LIST
99384: PUSH
99385: EMPTY
99386: LIST
99387: LIST
99388: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
99389: LD_ADDR_VAR 0 52
99393: PUSH
99394: LD_INT 3
99396: NEG
99397: PUSH
99398: LD_INT 1
99400: NEG
99401: PUSH
99402: EMPTY
99403: LIST
99404: LIST
99405: PUSH
99406: LD_INT 3
99408: NEG
99409: PUSH
99410: LD_INT 2
99412: NEG
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: PUSH
99418: EMPTY
99419: LIST
99420: LIST
99421: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
99422: LD_ADDR_VAR 0 53
99426: PUSH
99427: LD_INT 1
99429: NEG
99430: PUSH
99431: LD_INT 3
99433: NEG
99434: PUSH
99435: EMPTY
99436: LIST
99437: LIST
99438: PUSH
99439: LD_INT 0
99441: PUSH
99442: LD_INT 3
99444: NEG
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: LD_INT 1
99452: PUSH
99453: LD_INT 2
99455: NEG
99456: PUSH
99457: EMPTY
99458: LIST
99459: LIST
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: LIST
99465: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
99466: LD_ADDR_VAR 0 54
99470: PUSH
99471: LD_INT 2
99473: PUSH
99474: LD_INT 1
99476: NEG
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: PUSH
99482: LD_INT 3
99484: PUSH
99485: LD_INT 0
99487: PUSH
99488: EMPTY
99489: LIST
99490: LIST
99491: PUSH
99492: LD_INT 3
99494: PUSH
99495: LD_INT 1
99497: PUSH
99498: EMPTY
99499: LIST
99500: LIST
99501: PUSH
99502: EMPTY
99503: LIST
99504: LIST
99505: LIST
99506: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
99507: LD_ADDR_VAR 0 55
99511: PUSH
99512: LD_INT 3
99514: PUSH
99515: LD_INT 2
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: LD_INT 3
99524: PUSH
99525: LD_INT 3
99527: PUSH
99528: EMPTY
99529: LIST
99530: LIST
99531: PUSH
99532: LD_INT 2
99534: PUSH
99535: LD_INT 3
99537: PUSH
99538: EMPTY
99539: LIST
99540: LIST
99541: PUSH
99542: EMPTY
99543: LIST
99544: LIST
99545: LIST
99546: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
99547: LD_ADDR_VAR 0 56
99551: PUSH
99552: LD_INT 1
99554: PUSH
99555: LD_INT 3
99557: PUSH
99558: EMPTY
99559: LIST
99560: LIST
99561: PUSH
99562: LD_INT 0
99564: PUSH
99565: LD_INT 3
99567: PUSH
99568: EMPTY
99569: LIST
99570: LIST
99571: PUSH
99572: LD_INT 1
99574: NEG
99575: PUSH
99576: LD_INT 2
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: PUSH
99583: EMPTY
99584: LIST
99585: LIST
99586: LIST
99587: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
99588: LD_ADDR_VAR 0 57
99592: PUSH
99593: LD_INT 2
99595: NEG
99596: PUSH
99597: LD_INT 1
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: PUSH
99604: LD_INT 3
99606: NEG
99607: PUSH
99608: LD_INT 0
99610: PUSH
99611: EMPTY
99612: LIST
99613: LIST
99614: PUSH
99615: LD_INT 3
99617: NEG
99618: PUSH
99619: LD_INT 1
99621: NEG
99622: PUSH
99623: EMPTY
99624: LIST
99625: LIST
99626: PUSH
99627: EMPTY
99628: LIST
99629: LIST
99630: LIST
99631: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
99632: LD_ADDR_VAR 0 58
99636: PUSH
99637: LD_INT 2
99639: NEG
99640: PUSH
99641: LD_INT 3
99643: NEG
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: PUSH
99649: LD_INT 3
99651: NEG
99652: PUSH
99653: LD_INT 2
99655: NEG
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: PUSH
99661: LD_INT 3
99663: NEG
99664: PUSH
99665: LD_INT 3
99667: NEG
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: PUSH
99673: EMPTY
99674: LIST
99675: LIST
99676: LIST
99677: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
99678: LD_ADDR_VAR 0 59
99682: PUSH
99683: LD_INT 1
99685: NEG
99686: PUSH
99687: LD_INT 2
99689: NEG
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: PUSH
99695: LD_INT 0
99697: PUSH
99698: LD_INT 2
99700: NEG
99701: PUSH
99702: EMPTY
99703: LIST
99704: LIST
99705: PUSH
99706: LD_INT 1
99708: PUSH
99709: LD_INT 1
99711: NEG
99712: PUSH
99713: EMPTY
99714: LIST
99715: LIST
99716: PUSH
99717: EMPTY
99718: LIST
99719: LIST
99720: LIST
99721: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
99722: LD_ADDR_VAR 0 60
99726: PUSH
99727: LD_INT 1
99729: PUSH
99730: LD_INT 1
99732: NEG
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PUSH
99738: LD_INT 2
99740: PUSH
99741: LD_INT 0
99743: PUSH
99744: EMPTY
99745: LIST
99746: LIST
99747: PUSH
99748: LD_INT 2
99750: PUSH
99751: LD_INT 1
99753: PUSH
99754: EMPTY
99755: LIST
99756: LIST
99757: PUSH
99758: EMPTY
99759: LIST
99760: LIST
99761: LIST
99762: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
99763: LD_ADDR_VAR 0 61
99767: PUSH
99768: LD_INT 2
99770: PUSH
99771: LD_INT 1
99773: PUSH
99774: EMPTY
99775: LIST
99776: LIST
99777: PUSH
99778: LD_INT 2
99780: PUSH
99781: LD_INT 2
99783: PUSH
99784: EMPTY
99785: LIST
99786: LIST
99787: PUSH
99788: LD_INT 1
99790: PUSH
99791: LD_INT 2
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: LIST
99802: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
99803: LD_ADDR_VAR 0 62
99807: PUSH
99808: LD_INT 1
99810: PUSH
99811: LD_INT 2
99813: PUSH
99814: EMPTY
99815: LIST
99816: LIST
99817: PUSH
99818: LD_INT 0
99820: PUSH
99821: LD_INT 2
99823: PUSH
99824: EMPTY
99825: LIST
99826: LIST
99827: PUSH
99828: LD_INT 1
99830: NEG
99831: PUSH
99832: LD_INT 1
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PUSH
99839: EMPTY
99840: LIST
99841: LIST
99842: LIST
99843: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
99844: LD_ADDR_VAR 0 63
99848: PUSH
99849: LD_INT 1
99851: NEG
99852: PUSH
99853: LD_INT 1
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PUSH
99860: LD_INT 2
99862: NEG
99863: PUSH
99864: LD_INT 0
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: PUSH
99871: LD_INT 2
99873: NEG
99874: PUSH
99875: LD_INT 1
99877: NEG
99878: PUSH
99879: EMPTY
99880: LIST
99881: LIST
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: LIST
99887: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
99888: LD_ADDR_VAR 0 64
99892: PUSH
99893: LD_INT 1
99895: NEG
99896: PUSH
99897: LD_INT 2
99899: NEG
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PUSH
99905: LD_INT 2
99907: NEG
99908: PUSH
99909: LD_INT 1
99911: NEG
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: PUSH
99917: LD_INT 2
99919: NEG
99920: PUSH
99921: LD_INT 2
99923: NEG
99924: PUSH
99925: EMPTY
99926: LIST
99927: LIST
99928: PUSH
99929: EMPTY
99930: LIST
99931: LIST
99932: LIST
99933: ST_TO_ADDR
// end ; 2 :
99934: GO 103200
99936: LD_INT 2
99938: DOUBLE
99939: EQUAL
99940: IFTRUE 99944
99942: GO 103199
99944: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99945: LD_ADDR_VAR 0 29
99949: PUSH
99950: LD_INT 4
99952: PUSH
99953: LD_INT 0
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: PUSH
99960: LD_INT 4
99962: PUSH
99963: LD_INT 1
99965: NEG
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: PUSH
99971: LD_INT 5
99973: PUSH
99974: LD_INT 0
99976: PUSH
99977: EMPTY
99978: LIST
99979: LIST
99980: PUSH
99981: LD_INT 5
99983: PUSH
99984: LD_INT 1
99986: PUSH
99987: EMPTY
99988: LIST
99989: LIST
99990: PUSH
99991: LD_INT 4
99993: PUSH
99994: LD_INT 1
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: LD_INT 3
100003: PUSH
100004: LD_INT 0
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: LD_INT 3
100013: PUSH
100014: LD_INT 1
100016: NEG
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: PUSH
100022: LD_INT 3
100024: PUSH
100025: LD_INT 2
100027: NEG
100028: PUSH
100029: EMPTY
100030: LIST
100031: LIST
100032: PUSH
100033: LD_INT 5
100035: PUSH
100036: LD_INT 2
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 3
100045: PUSH
100046: LD_INT 3
100048: PUSH
100049: EMPTY
100050: LIST
100051: LIST
100052: PUSH
100053: LD_INT 3
100055: PUSH
100056: LD_INT 2
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: PUSH
100063: LD_INT 4
100065: PUSH
100066: LD_INT 3
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: PUSH
100073: LD_INT 4
100075: PUSH
100076: LD_INT 4
100078: PUSH
100079: EMPTY
100080: LIST
100081: LIST
100082: PUSH
100083: LD_INT 3
100085: PUSH
100086: LD_INT 4
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: PUSH
100093: LD_INT 2
100095: PUSH
100096: LD_INT 3
100098: PUSH
100099: EMPTY
100100: LIST
100101: LIST
100102: PUSH
100103: LD_INT 2
100105: PUSH
100106: LD_INT 2
100108: PUSH
100109: EMPTY
100110: LIST
100111: LIST
100112: PUSH
100113: LD_INT 4
100115: PUSH
100116: LD_INT 2
100118: PUSH
100119: EMPTY
100120: LIST
100121: LIST
100122: PUSH
100123: LD_INT 2
100125: PUSH
100126: LD_INT 4
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PUSH
100133: LD_INT 0
100135: PUSH
100136: LD_INT 4
100138: PUSH
100139: EMPTY
100140: LIST
100141: LIST
100142: PUSH
100143: LD_INT 0
100145: PUSH
100146: LD_INT 3
100148: PUSH
100149: EMPTY
100150: LIST
100151: LIST
100152: PUSH
100153: LD_INT 1
100155: PUSH
100156: LD_INT 4
100158: PUSH
100159: EMPTY
100160: LIST
100161: LIST
100162: PUSH
100163: LD_INT 1
100165: PUSH
100166: LD_INT 5
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: PUSH
100173: LD_INT 0
100175: PUSH
100176: LD_INT 5
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: PUSH
100183: LD_INT 1
100185: NEG
100186: PUSH
100187: LD_INT 4
100189: PUSH
100190: EMPTY
100191: LIST
100192: LIST
100193: PUSH
100194: LD_INT 1
100196: NEG
100197: PUSH
100198: LD_INT 3
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: PUSH
100205: LD_INT 2
100207: PUSH
100208: LD_INT 5
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: PUSH
100215: LD_INT 2
100217: NEG
100218: PUSH
100219: LD_INT 3
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: PUSH
100226: LD_INT 3
100228: NEG
100229: PUSH
100230: LD_INT 0
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PUSH
100237: LD_INT 3
100239: NEG
100240: PUSH
100241: LD_INT 1
100243: NEG
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PUSH
100249: LD_INT 2
100251: NEG
100252: PUSH
100253: LD_INT 0
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: PUSH
100260: LD_INT 2
100262: NEG
100263: PUSH
100264: LD_INT 1
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 3
100273: NEG
100274: PUSH
100275: LD_INT 1
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: PUSH
100282: LD_INT 4
100284: NEG
100285: PUSH
100286: LD_INT 0
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: LD_INT 4
100295: NEG
100296: PUSH
100297: LD_INT 1
100299: NEG
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 4
100307: NEG
100308: PUSH
100309: LD_INT 2
100311: NEG
100312: PUSH
100313: EMPTY
100314: LIST
100315: LIST
100316: PUSH
100317: LD_INT 2
100319: NEG
100320: PUSH
100321: LD_INT 2
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 4
100330: NEG
100331: PUSH
100332: LD_INT 4
100334: NEG
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: LD_INT 4
100342: NEG
100343: PUSH
100344: LD_INT 5
100346: NEG
100347: PUSH
100348: EMPTY
100349: LIST
100350: LIST
100351: PUSH
100352: LD_INT 3
100354: NEG
100355: PUSH
100356: LD_INT 4
100358: NEG
100359: PUSH
100360: EMPTY
100361: LIST
100362: LIST
100363: PUSH
100364: LD_INT 3
100366: NEG
100367: PUSH
100368: LD_INT 3
100370: NEG
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 4
100378: NEG
100379: PUSH
100380: LD_INT 3
100382: NEG
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: PUSH
100388: LD_INT 5
100390: NEG
100391: PUSH
100392: LD_INT 4
100394: NEG
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PUSH
100400: LD_INT 5
100402: NEG
100403: PUSH
100404: LD_INT 5
100406: NEG
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: PUSH
100412: LD_INT 3
100414: NEG
100415: PUSH
100416: LD_INT 5
100418: NEG
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: LD_INT 5
100426: NEG
100427: PUSH
100428: LD_INT 3
100430: NEG
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: PUSH
100436: EMPTY
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
100483: LD_ADDR_VAR 0 30
100487: PUSH
100488: LD_INT 4
100490: PUSH
100491: LD_INT 4
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: PUSH
100498: LD_INT 4
100500: PUSH
100501: LD_INT 3
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PUSH
100508: LD_INT 5
100510: PUSH
100511: LD_INT 4
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PUSH
100518: LD_INT 5
100520: PUSH
100521: LD_INT 5
100523: PUSH
100524: EMPTY
100525: LIST
100526: LIST
100527: PUSH
100528: LD_INT 4
100530: PUSH
100531: LD_INT 5
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: PUSH
100538: LD_INT 3
100540: PUSH
100541: LD_INT 4
100543: PUSH
100544: EMPTY
100545: LIST
100546: LIST
100547: PUSH
100548: LD_INT 3
100550: PUSH
100551: LD_INT 3
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: PUSH
100558: LD_INT 5
100560: PUSH
100561: LD_INT 3
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: LD_INT 3
100570: PUSH
100571: LD_INT 5
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: LD_INT 0
100580: PUSH
100581: LD_INT 3
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 0
100590: PUSH
100591: LD_INT 2
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: LD_INT 1
100600: PUSH
100601: LD_INT 3
100603: PUSH
100604: EMPTY
100605: LIST
100606: LIST
100607: PUSH
100608: LD_INT 1
100610: PUSH
100611: LD_INT 4
100613: PUSH
100614: EMPTY
100615: LIST
100616: LIST
100617: PUSH
100618: LD_INT 0
100620: PUSH
100621: LD_INT 4
100623: PUSH
100624: EMPTY
100625: LIST
100626: LIST
100627: PUSH
100628: LD_INT 1
100630: NEG
100631: PUSH
100632: LD_INT 3
100634: PUSH
100635: EMPTY
100636: LIST
100637: LIST
100638: PUSH
100639: LD_INT 1
100641: NEG
100642: PUSH
100643: LD_INT 2
100645: PUSH
100646: EMPTY
100647: LIST
100648: LIST
100649: PUSH
100650: LD_INT 2
100652: PUSH
100653: LD_INT 4
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PUSH
100660: LD_INT 2
100662: NEG
100663: PUSH
100664: LD_INT 2
100666: PUSH
100667: EMPTY
100668: LIST
100669: LIST
100670: PUSH
100671: LD_INT 4
100673: NEG
100674: PUSH
100675: LD_INT 0
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PUSH
100682: LD_INT 4
100684: NEG
100685: PUSH
100686: LD_INT 1
100688: NEG
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 3
100696: NEG
100697: PUSH
100698: LD_INT 0
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: PUSH
100705: LD_INT 3
100707: NEG
100708: PUSH
100709: LD_INT 1
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: LD_INT 4
100718: NEG
100719: PUSH
100720: LD_INT 1
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 5
100729: NEG
100730: PUSH
100731: LD_INT 0
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PUSH
100738: LD_INT 5
100740: NEG
100741: PUSH
100742: LD_INT 1
100744: NEG
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 5
100752: NEG
100753: PUSH
100754: LD_INT 2
100756: NEG
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: PUSH
100762: LD_INT 3
100764: NEG
100765: PUSH
100766: LD_INT 2
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 3
100775: NEG
100776: PUSH
100777: LD_INT 3
100779: NEG
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 3
100787: NEG
100788: PUSH
100789: LD_INT 4
100791: NEG
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 2
100799: NEG
100800: PUSH
100801: LD_INT 3
100803: NEG
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 2
100811: NEG
100812: PUSH
100813: LD_INT 2
100815: NEG
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PUSH
100821: LD_INT 3
100823: NEG
100824: PUSH
100825: LD_INT 2
100827: NEG
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 4
100835: NEG
100836: PUSH
100837: LD_INT 3
100839: NEG
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: PUSH
100845: LD_INT 4
100847: NEG
100848: PUSH
100849: LD_INT 4
100851: NEG
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: PUSH
100857: LD_INT 2
100859: NEG
100860: PUSH
100861: LD_INT 4
100863: NEG
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: PUSH
100869: LD_INT 4
100871: NEG
100872: PUSH
100873: LD_INT 2
100875: NEG
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: PUSH
100881: LD_INT 0
100883: PUSH
100884: LD_INT 4
100886: NEG
100887: PUSH
100888: EMPTY
100889: LIST
100890: LIST
100891: PUSH
100892: LD_INT 0
100894: PUSH
100895: LD_INT 5
100897: NEG
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 1
100905: PUSH
100906: LD_INT 4
100908: NEG
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 1
100916: PUSH
100917: LD_INT 3
100919: NEG
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PUSH
100925: LD_INT 0
100927: PUSH
100928: LD_INT 3
100930: NEG
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PUSH
100936: LD_INT 1
100938: NEG
100939: PUSH
100940: LD_INT 4
100942: NEG
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: PUSH
100948: LD_INT 1
100950: NEG
100951: PUSH
100952: LD_INT 5
100954: NEG
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: PUSH
100960: LD_INT 2
100962: PUSH
100963: LD_INT 3
100965: NEG
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: PUSH
100971: LD_INT 2
100973: NEG
100974: PUSH
100975: LD_INT 5
100977: NEG
100978: PUSH
100979: EMPTY
100980: LIST
100981: LIST
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: LIST
100994: LIST
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: LIST
101002: LIST
101003: LIST
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
101030: LD_ADDR_VAR 0 31
101034: PUSH
101035: LD_INT 0
101037: PUSH
101038: LD_INT 4
101040: PUSH
101041: EMPTY
101042: LIST
101043: LIST
101044: PUSH
101045: LD_INT 0
101047: PUSH
101048: LD_INT 3
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: PUSH
101055: LD_INT 1
101057: PUSH
101058: LD_INT 4
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: PUSH
101065: LD_INT 1
101067: PUSH
101068: LD_INT 5
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: PUSH
101075: LD_INT 0
101077: PUSH
101078: LD_INT 5
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: PUSH
101085: LD_INT 1
101087: NEG
101088: PUSH
101089: LD_INT 4
101091: PUSH
101092: EMPTY
101093: LIST
101094: LIST
101095: PUSH
101096: LD_INT 1
101098: NEG
101099: PUSH
101100: LD_INT 3
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: PUSH
101107: LD_INT 2
101109: PUSH
101110: LD_INT 5
101112: PUSH
101113: EMPTY
101114: LIST
101115: LIST
101116: PUSH
101117: LD_INT 2
101119: NEG
101120: PUSH
101121: LD_INT 3
101123: PUSH
101124: EMPTY
101125: LIST
101126: LIST
101127: PUSH
101128: LD_INT 3
101130: NEG
101131: PUSH
101132: LD_INT 0
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PUSH
101139: LD_INT 3
101141: NEG
101142: PUSH
101143: LD_INT 1
101145: NEG
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PUSH
101151: LD_INT 2
101153: NEG
101154: PUSH
101155: LD_INT 0
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PUSH
101162: LD_INT 2
101164: NEG
101165: PUSH
101166: LD_INT 1
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: LD_INT 3
101175: NEG
101176: PUSH
101177: LD_INT 1
101179: PUSH
101180: EMPTY
101181: LIST
101182: LIST
101183: PUSH
101184: LD_INT 4
101186: NEG
101187: PUSH
101188: LD_INT 0
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PUSH
101195: LD_INT 4
101197: NEG
101198: PUSH
101199: LD_INT 1
101201: NEG
101202: PUSH
101203: EMPTY
101204: LIST
101205: LIST
101206: PUSH
101207: LD_INT 4
101209: NEG
101210: PUSH
101211: LD_INT 2
101213: NEG
101214: PUSH
101215: EMPTY
101216: LIST
101217: LIST
101218: PUSH
101219: LD_INT 2
101221: NEG
101222: PUSH
101223: LD_INT 2
101225: PUSH
101226: EMPTY
101227: LIST
101228: LIST
101229: PUSH
101230: LD_INT 4
101232: NEG
101233: PUSH
101234: LD_INT 4
101236: NEG
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: PUSH
101242: LD_INT 4
101244: NEG
101245: PUSH
101246: LD_INT 5
101248: NEG
101249: PUSH
101250: EMPTY
101251: LIST
101252: LIST
101253: PUSH
101254: LD_INT 3
101256: NEG
101257: PUSH
101258: LD_INT 4
101260: NEG
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: LD_INT 3
101268: NEG
101269: PUSH
101270: LD_INT 3
101272: NEG
101273: PUSH
101274: EMPTY
101275: LIST
101276: LIST
101277: PUSH
101278: LD_INT 4
101280: NEG
101281: PUSH
101282: LD_INT 3
101284: NEG
101285: PUSH
101286: EMPTY
101287: LIST
101288: LIST
101289: PUSH
101290: LD_INT 5
101292: NEG
101293: PUSH
101294: LD_INT 4
101296: NEG
101297: PUSH
101298: EMPTY
101299: LIST
101300: LIST
101301: PUSH
101302: LD_INT 5
101304: NEG
101305: PUSH
101306: LD_INT 5
101308: NEG
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 3
101316: NEG
101317: PUSH
101318: LD_INT 5
101320: NEG
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 5
101328: NEG
101329: PUSH
101330: LD_INT 3
101332: NEG
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: LD_INT 0
101340: PUSH
101341: LD_INT 3
101343: NEG
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PUSH
101349: LD_INT 0
101351: PUSH
101352: LD_INT 4
101354: NEG
101355: PUSH
101356: EMPTY
101357: LIST
101358: LIST
101359: PUSH
101360: LD_INT 1
101362: PUSH
101363: LD_INT 3
101365: NEG
101366: PUSH
101367: EMPTY
101368: LIST
101369: LIST
101370: PUSH
101371: LD_INT 1
101373: PUSH
101374: LD_INT 2
101376: NEG
101377: PUSH
101378: EMPTY
101379: LIST
101380: LIST
101381: PUSH
101382: LD_INT 0
101384: PUSH
101385: LD_INT 2
101387: NEG
101388: PUSH
101389: EMPTY
101390: LIST
101391: LIST
101392: PUSH
101393: LD_INT 1
101395: NEG
101396: PUSH
101397: LD_INT 3
101399: NEG
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 1
101407: NEG
101408: PUSH
101409: LD_INT 4
101411: NEG
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PUSH
101417: LD_INT 2
101419: PUSH
101420: LD_INT 2
101422: NEG
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 2
101430: NEG
101431: PUSH
101432: LD_INT 4
101434: NEG
101435: PUSH
101436: EMPTY
101437: LIST
101438: LIST
101439: PUSH
101440: LD_INT 4
101442: PUSH
101443: LD_INT 0
101445: PUSH
101446: EMPTY
101447: LIST
101448: LIST
101449: PUSH
101450: LD_INT 4
101452: PUSH
101453: LD_INT 1
101455: NEG
101456: PUSH
101457: EMPTY
101458: LIST
101459: LIST
101460: PUSH
101461: LD_INT 5
101463: PUSH
101464: LD_INT 0
101466: PUSH
101467: EMPTY
101468: LIST
101469: LIST
101470: PUSH
101471: LD_INT 5
101473: PUSH
101474: LD_INT 1
101476: PUSH
101477: EMPTY
101478: LIST
101479: LIST
101480: PUSH
101481: LD_INT 4
101483: PUSH
101484: LD_INT 1
101486: PUSH
101487: EMPTY
101488: LIST
101489: LIST
101490: PUSH
101491: LD_INT 3
101493: PUSH
101494: LD_INT 0
101496: PUSH
101497: EMPTY
101498: LIST
101499: LIST
101500: PUSH
101501: LD_INT 3
101503: PUSH
101504: LD_INT 1
101506: NEG
101507: PUSH
101508: EMPTY
101509: LIST
101510: LIST
101511: PUSH
101512: LD_INT 3
101514: PUSH
101515: LD_INT 2
101517: NEG
101518: PUSH
101519: EMPTY
101520: LIST
101521: LIST
101522: PUSH
101523: LD_INT 5
101525: PUSH
101526: LD_INT 2
101528: PUSH
101529: EMPTY
101530: LIST
101531: LIST
101532: PUSH
101533: EMPTY
101534: LIST
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: LIST
101547: LIST
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: LIST
101564: LIST
101565: LIST
101566: LIST
101567: LIST
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: LIST
101578: LIST
101579: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
101580: LD_ADDR_VAR 0 32
101584: PUSH
101585: LD_INT 4
101587: NEG
101588: PUSH
101589: LD_INT 0
101591: PUSH
101592: EMPTY
101593: LIST
101594: LIST
101595: PUSH
101596: LD_INT 4
101598: NEG
101599: PUSH
101600: LD_INT 1
101602: NEG
101603: PUSH
101604: EMPTY
101605: LIST
101606: LIST
101607: PUSH
101608: LD_INT 3
101610: NEG
101611: PUSH
101612: LD_INT 0
101614: PUSH
101615: EMPTY
101616: LIST
101617: LIST
101618: PUSH
101619: LD_INT 3
101621: NEG
101622: PUSH
101623: LD_INT 1
101625: PUSH
101626: EMPTY
101627: LIST
101628: LIST
101629: PUSH
101630: LD_INT 4
101632: NEG
101633: PUSH
101634: LD_INT 1
101636: PUSH
101637: EMPTY
101638: LIST
101639: LIST
101640: PUSH
101641: LD_INT 5
101643: NEG
101644: PUSH
101645: LD_INT 0
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: PUSH
101652: LD_INT 5
101654: NEG
101655: PUSH
101656: LD_INT 1
101658: NEG
101659: PUSH
101660: EMPTY
101661: LIST
101662: LIST
101663: PUSH
101664: LD_INT 5
101666: NEG
101667: PUSH
101668: LD_INT 2
101670: NEG
101671: PUSH
101672: EMPTY
101673: LIST
101674: LIST
101675: PUSH
101676: LD_INT 3
101678: NEG
101679: PUSH
101680: LD_INT 2
101682: PUSH
101683: EMPTY
101684: LIST
101685: LIST
101686: PUSH
101687: LD_INT 3
101689: NEG
101690: PUSH
101691: LD_INT 3
101693: NEG
101694: PUSH
101695: EMPTY
101696: LIST
101697: LIST
101698: PUSH
101699: LD_INT 3
101701: NEG
101702: PUSH
101703: LD_INT 4
101705: NEG
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: PUSH
101711: LD_INT 2
101713: NEG
101714: PUSH
101715: LD_INT 3
101717: NEG
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: PUSH
101723: LD_INT 2
101725: NEG
101726: PUSH
101727: LD_INT 2
101729: NEG
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: LD_INT 3
101737: NEG
101738: PUSH
101739: LD_INT 2
101741: NEG
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: LD_INT 4
101749: NEG
101750: PUSH
101751: LD_INT 3
101753: NEG
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: LD_INT 4
101761: NEG
101762: PUSH
101763: LD_INT 4
101765: NEG
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PUSH
101771: LD_INT 2
101773: NEG
101774: PUSH
101775: LD_INT 4
101777: NEG
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: PUSH
101783: LD_INT 4
101785: NEG
101786: PUSH
101787: LD_INT 2
101789: NEG
101790: PUSH
101791: EMPTY
101792: LIST
101793: LIST
101794: PUSH
101795: LD_INT 0
101797: PUSH
101798: LD_INT 4
101800: NEG
101801: PUSH
101802: EMPTY
101803: LIST
101804: LIST
101805: PUSH
101806: LD_INT 0
101808: PUSH
101809: LD_INT 5
101811: NEG
101812: PUSH
101813: EMPTY
101814: LIST
101815: LIST
101816: PUSH
101817: LD_INT 1
101819: PUSH
101820: LD_INT 4
101822: NEG
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: LD_INT 1
101830: PUSH
101831: LD_INT 3
101833: NEG
101834: PUSH
101835: EMPTY
101836: LIST
101837: LIST
101838: PUSH
101839: LD_INT 0
101841: PUSH
101842: LD_INT 3
101844: NEG
101845: PUSH
101846: EMPTY
101847: LIST
101848: LIST
101849: PUSH
101850: LD_INT 1
101852: NEG
101853: PUSH
101854: LD_INT 4
101856: NEG
101857: PUSH
101858: EMPTY
101859: LIST
101860: LIST
101861: PUSH
101862: LD_INT 1
101864: NEG
101865: PUSH
101866: LD_INT 5
101868: NEG
101869: PUSH
101870: EMPTY
101871: LIST
101872: LIST
101873: PUSH
101874: LD_INT 2
101876: PUSH
101877: LD_INT 3
101879: NEG
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: PUSH
101885: LD_INT 2
101887: NEG
101888: PUSH
101889: LD_INT 5
101891: NEG
101892: PUSH
101893: EMPTY
101894: LIST
101895: LIST
101896: PUSH
101897: LD_INT 3
101899: PUSH
101900: LD_INT 0
101902: PUSH
101903: EMPTY
101904: LIST
101905: LIST
101906: PUSH
101907: LD_INT 3
101909: PUSH
101910: LD_INT 1
101912: NEG
101913: PUSH
101914: EMPTY
101915: LIST
101916: LIST
101917: PUSH
101918: LD_INT 4
101920: PUSH
101921: LD_INT 0
101923: PUSH
101924: EMPTY
101925: LIST
101926: LIST
101927: PUSH
101928: LD_INT 4
101930: PUSH
101931: LD_INT 1
101933: PUSH
101934: EMPTY
101935: LIST
101936: LIST
101937: PUSH
101938: LD_INT 3
101940: PUSH
101941: LD_INT 1
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: PUSH
101948: LD_INT 2
101950: PUSH
101951: LD_INT 0
101953: PUSH
101954: EMPTY
101955: LIST
101956: LIST
101957: PUSH
101958: LD_INT 2
101960: PUSH
101961: LD_INT 1
101963: NEG
101964: PUSH
101965: EMPTY
101966: LIST
101967: LIST
101968: PUSH
101969: LD_INT 2
101971: PUSH
101972: LD_INT 2
101974: NEG
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: PUSH
101980: LD_INT 4
101982: PUSH
101983: LD_INT 2
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: PUSH
101990: LD_INT 4
101992: PUSH
101993: LD_INT 4
101995: PUSH
101996: EMPTY
101997: LIST
101998: LIST
101999: PUSH
102000: LD_INT 4
102002: PUSH
102003: LD_INT 3
102005: PUSH
102006: EMPTY
102007: LIST
102008: LIST
102009: PUSH
102010: LD_INT 5
102012: PUSH
102013: LD_INT 4
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: PUSH
102020: LD_INT 5
102022: PUSH
102023: LD_INT 5
102025: PUSH
102026: EMPTY
102027: LIST
102028: LIST
102029: PUSH
102030: LD_INT 4
102032: PUSH
102033: LD_INT 5
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: PUSH
102040: LD_INT 3
102042: PUSH
102043: LD_INT 4
102045: PUSH
102046: EMPTY
102047: LIST
102048: LIST
102049: PUSH
102050: LD_INT 3
102052: PUSH
102053: LD_INT 3
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: PUSH
102060: LD_INT 5
102062: PUSH
102063: LD_INT 3
102065: PUSH
102066: EMPTY
102067: LIST
102068: LIST
102069: PUSH
102070: LD_INT 3
102072: PUSH
102073: LD_INT 5
102075: PUSH
102076: EMPTY
102077: LIST
102078: LIST
102079: PUSH
102080: EMPTY
102081: LIST
102082: LIST
102083: LIST
102084: LIST
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: LIST
102097: LIST
102098: LIST
102099: LIST
102100: LIST
102101: LIST
102102: LIST
102103: LIST
102104: LIST
102105: LIST
102106: LIST
102107: LIST
102108: LIST
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: LIST
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
102127: LD_ADDR_VAR 0 33
102131: PUSH
102132: LD_INT 4
102134: NEG
102135: PUSH
102136: LD_INT 4
102138: NEG
102139: PUSH
102140: EMPTY
102141: LIST
102142: LIST
102143: PUSH
102144: LD_INT 4
102146: NEG
102147: PUSH
102148: LD_INT 5
102150: NEG
102151: PUSH
102152: EMPTY
102153: LIST
102154: LIST
102155: PUSH
102156: LD_INT 3
102158: NEG
102159: PUSH
102160: LD_INT 4
102162: NEG
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 3
102170: NEG
102171: PUSH
102172: LD_INT 3
102174: NEG
102175: PUSH
102176: EMPTY
102177: LIST
102178: LIST
102179: PUSH
102180: LD_INT 4
102182: NEG
102183: PUSH
102184: LD_INT 3
102186: NEG
102187: PUSH
102188: EMPTY
102189: LIST
102190: LIST
102191: PUSH
102192: LD_INT 5
102194: NEG
102195: PUSH
102196: LD_INT 4
102198: NEG
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 5
102206: NEG
102207: PUSH
102208: LD_INT 5
102210: NEG
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PUSH
102216: LD_INT 3
102218: NEG
102219: PUSH
102220: LD_INT 5
102222: NEG
102223: PUSH
102224: EMPTY
102225: LIST
102226: LIST
102227: PUSH
102228: LD_INT 5
102230: NEG
102231: PUSH
102232: LD_INT 3
102234: NEG
102235: PUSH
102236: EMPTY
102237: LIST
102238: LIST
102239: PUSH
102240: LD_INT 0
102242: PUSH
102243: LD_INT 3
102245: NEG
102246: PUSH
102247: EMPTY
102248: LIST
102249: LIST
102250: PUSH
102251: LD_INT 0
102253: PUSH
102254: LD_INT 4
102256: NEG
102257: PUSH
102258: EMPTY
102259: LIST
102260: LIST
102261: PUSH
102262: LD_INT 1
102264: PUSH
102265: LD_INT 3
102267: NEG
102268: PUSH
102269: EMPTY
102270: LIST
102271: LIST
102272: PUSH
102273: LD_INT 1
102275: PUSH
102276: LD_INT 2
102278: NEG
102279: PUSH
102280: EMPTY
102281: LIST
102282: LIST
102283: PUSH
102284: LD_INT 0
102286: PUSH
102287: LD_INT 2
102289: NEG
102290: PUSH
102291: EMPTY
102292: LIST
102293: LIST
102294: PUSH
102295: LD_INT 1
102297: NEG
102298: PUSH
102299: LD_INT 3
102301: NEG
102302: PUSH
102303: EMPTY
102304: LIST
102305: LIST
102306: PUSH
102307: LD_INT 1
102309: NEG
102310: PUSH
102311: LD_INT 4
102313: NEG
102314: PUSH
102315: EMPTY
102316: LIST
102317: LIST
102318: PUSH
102319: LD_INT 2
102321: PUSH
102322: LD_INT 2
102324: NEG
102325: PUSH
102326: EMPTY
102327: LIST
102328: LIST
102329: PUSH
102330: LD_INT 2
102332: NEG
102333: PUSH
102334: LD_INT 4
102336: NEG
102337: PUSH
102338: EMPTY
102339: LIST
102340: LIST
102341: PUSH
102342: LD_INT 4
102344: PUSH
102345: LD_INT 0
102347: PUSH
102348: EMPTY
102349: LIST
102350: LIST
102351: PUSH
102352: LD_INT 4
102354: PUSH
102355: LD_INT 1
102357: NEG
102358: PUSH
102359: EMPTY
102360: LIST
102361: LIST
102362: PUSH
102363: LD_INT 5
102365: PUSH
102366: LD_INT 0
102368: PUSH
102369: EMPTY
102370: LIST
102371: LIST
102372: PUSH
102373: LD_INT 5
102375: PUSH
102376: LD_INT 1
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: PUSH
102383: LD_INT 4
102385: PUSH
102386: LD_INT 1
102388: PUSH
102389: EMPTY
102390: LIST
102391: LIST
102392: PUSH
102393: LD_INT 3
102395: PUSH
102396: LD_INT 0
102398: PUSH
102399: EMPTY
102400: LIST
102401: LIST
102402: PUSH
102403: LD_INT 3
102405: PUSH
102406: LD_INT 1
102408: NEG
102409: PUSH
102410: EMPTY
102411: LIST
102412: LIST
102413: PUSH
102414: LD_INT 3
102416: PUSH
102417: LD_INT 2
102419: NEG
102420: PUSH
102421: EMPTY
102422: LIST
102423: LIST
102424: PUSH
102425: LD_INT 5
102427: PUSH
102428: LD_INT 2
102430: PUSH
102431: EMPTY
102432: LIST
102433: LIST
102434: PUSH
102435: LD_INT 3
102437: PUSH
102438: LD_INT 3
102440: PUSH
102441: EMPTY
102442: LIST
102443: LIST
102444: PUSH
102445: LD_INT 3
102447: PUSH
102448: LD_INT 2
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PUSH
102455: LD_INT 4
102457: PUSH
102458: LD_INT 3
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PUSH
102465: LD_INT 4
102467: PUSH
102468: LD_INT 4
102470: PUSH
102471: EMPTY
102472: LIST
102473: LIST
102474: PUSH
102475: LD_INT 3
102477: PUSH
102478: LD_INT 4
102480: PUSH
102481: EMPTY
102482: LIST
102483: LIST
102484: PUSH
102485: LD_INT 2
102487: PUSH
102488: LD_INT 3
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PUSH
102495: LD_INT 2
102497: PUSH
102498: LD_INT 2
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: PUSH
102505: LD_INT 4
102507: PUSH
102508: LD_INT 2
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: LD_INT 2
102517: PUSH
102518: LD_INT 4
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: PUSH
102525: LD_INT 0
102527: PUSH
102528: LD_INT 4
102530: PUSH
102531: EMPTY
102532: LIST
102533: LIST
102534: PUSH
102535: LD_INT 0
102537: PUSH
102538: LD_INT 3
102540: PUSH
102541: EMPTY
102542: LIST
102543: LIST
102544: PUSH
102545: LD_INT 1
102547: PUSH
102548: LD_INT 4
102550: PUSH
102551: EMPTY
102552: LIST
102553: LIST
102554: PUSH
102555: LD_INT 1
102557: PUSH
102558: LD_INT 5
102560: PUSH
102561: EMPTY
102562: LIST
102563: LIST
102564: PUSH
102565: LD_INT 0
102567: PUSH
102568: LD_INT 5
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: PUSH
102575: LD_INT 1
102577: NEG
102578: PUSH
102579: LD_INT 4
102581: PUSH
102582: EMPTY
102583: LIST
102584: LIST
102585: PUSH
102586: LD_INT 1
102588: NEG
102589: PUSH
102590: LD_INT 3
102592: PUSH
102593: EMPTY
102594: LIST
102595: LIST
102596: PUSH
102597: LD_INT 2
102599: PUSH
102600: LD_INT 5
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: PUSH
102607: LD_INT 2
102609: NEG
102610: PUSH
102611: LD_INT 3
102613: PUSH
102614: EMPTY
102615: LIST
102616: LIST
102617: PUSH
102618: EMPTY
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: LIST
102624: LIST
102625: LIST
102626: LIST
102627: LIST
102628: LIST
102629: LIST
102630: LIST
102631: LIST
102632: LIST
102633: LIST
102634: LIST
102635: LIST
102636: LIST
102637: LIST
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: LIST
102643: LIST
102644: LIST
102645: LIST
102646: LIST
102647: LIST
102648: LIST
102649: LIST
102650: LIST
102651: LIST
102652: LIST
102653: LIST
102654: LIST
102655: LIST
102656: LIST
102657: LIST
102658: LIST
102659: LIST
102660: LIST
102661: LIST
102662: LIST
102663: LIST
102664: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
102665: LD_ADDR_VAR 0 34
102669: PUSH
102670: LD_INT 0
102672: PUSH
102673: LD_INT 4
102675: NEG
102676: PUSH
102677: EMPTY
102678: LIST
102679: LIST
102680: PUSH
102681: LD_INT 0
102683: PUSH
102684: LD_INT 5
102686: NEG
102687: PUSH
102688: EMPTY
102689: LIST
102690: LIST
102691: PUSH
102692: LD_INT 1
102694: PUSH
102695: LD_INT 4
102697: NEG
102698: PUSH
102699: EMPTY
102700: LIST
102701: LIST
102702: PUSH
102703: LD_INT 1
102705: PUSH
102706: LD_INT 3
102708: NEG
102709: PUSH
102710: EMPTY
102711: LIST
102712: LIST
102713: PUSH
102714: LD_INT 0
102716: PUSH
102717: LD_INT 3
102719: NEG
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 1
102727: NEG
102728: PUSH
102729: LD_INT 4
102731: NEG
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: PUSH
102737: LD_INT 1
102739: NEG
102740: PUSH
102741: LD_INT 5
102743: NEG
102744: PUSH
102745: EMPTY
102746: LIST
102747: LIST
102748: PUSH
102749: LD_INT 2
102751: PUSH
102752: LD_INT 3
102754: NEG
102755: PUSH
102756: EMPTY
102757: LIST
102758: LIST
102759: PUSH
102760: LD_INT 2
102762: NEG
102763: PUSH
102764: LD_INT 5
102766: NEG
102767: PUSH
102768: EMPTY
102769: LIST
102770: LIST
102771: PUSH
102772: LD_INT 3
102774: PUSH
102775: LD_INT 0
102777: PUSH
102778: EMPTY
102779: LIST
102780: LIST
102781: PUSH
102782: LD_INT 3
102784: PUSH
102785: LD_INT 1
102787: NEG
102788: PUSH
102789: EMPTY
102790: LIST
102791: LIST
102792: PUSH
102793: LD_INT 4
102795: PUSH
102796: LD_INT 0
102798: PUSH
102799: EMPTY
102800: LIST
102801: LIST
102802: PUSH
102803: LD_INT 4
102805: PUSH
102806: LD_INT 1
102808: PUSH
102809: EMPTY
102810: LIST
102811: LIST
102812: PUSH
102813: LD_INT 3
102815: PUSH
102816: LD_INT 1
102818: PUSH
102819: EMPTY
102820: LIST
102821: LIST
102822: PUSH
102823: LD_INT 2
102825: PUSH
102826: LD_INT 0
102828: PUSH
102829: EMPTY
102830: LIST
102831: LIST
102832: PUSH
102833: LD_INT 2
102835: PUSH
102836: LD_INT 1
102838: NEG
102839: PUSH
102840: EMPTY
102841: LIST
102842: LIST
102843: PUSH
102844: LD_INT 2
102846: PUSH
102847: LD_INT 2
102849: NEG
102850: PUSH
102851: EMPTY
102852: LIST
102853: LIST
102854: PUSH
102855: LD_INT 4
102857: PUSH
102858: LD_INT 2
102860: PUSH
102861: EMPTY
102862: LIST
102863: LIST
102864: PUSH
102865: LD_INT 4
102867: PUSH
102868: LD_INT 4
102870: PUSH
102871: EMPTY
102872: LIST
102873: LIST
102874: PUSH
102875: LD_INT 4
102877: PUSH
102878: LD_INT 3
102880: PUSH
102881: EMPTY
102882: LIST
102883: LIST
102884: PUSH
102885: LD_INT 5
102887: PUSH
102888: LD_INT 4
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: PUSH
102895: LD_INT 5
102897: PUSH
102898: LD_INT 5
102900: PUSH
102901: EMPTY
102902: LIST
102903: LIST
102904: PUSH
102905: LD_INT 4
102907: PUSH
102908: LD_INT 5
102910: PUSH
102911: EMPTY
102912: LIST
102913: LIST
102914: PUSH
102915: LD_INT 3
102917: PUSH
102918: LD_INT 4
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: PUSH
102925: LD_INT 3
102927: PUSH
102928: LD_INT 3
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: PUSH
102935: LD_INT 5
102937: PUSH
102938: LD_INT 3
102940: PUSH
102941: EMPTY
102942: LIST
102943: LIST
102944: PUSH
102945: LD_INT 3
102947: PUSH
102948: LD_INT 5
102950: PUSH
102951: EMPTY
102952: LIST
102953: LIST
102954: PUSH
102955: LD_INT 0
102957: PUSH
102958: LD_INT 3
102960: PUSH
102961: EMPTY
102962: LIST
102963: LIST
102964: PUSH
102965: LD_INT 0
102967: PUSH
102968: LD_INT 2
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: PUSH
102975: LD_INT 1
102977: PUSH
102978: LD_INT 3
102980: PUSH
102981: EMPTY
102982: LIST
102983: LIST
102984: PUSH
102985: LD_INT 1
102987: PUSH
102988: LD_INT 4
102990: PUSH
102991: EMPTY
102992: LIST
102993: LIST
102994: PUSH
102995: LD_INT 0
102997: PUSH
102998: LD_INT 4
103000: PUSH
103001: EMPTY
103002: LIST
103003: LIST
103004: PUSH
103005: LD_INT 1
103007: NEG
103008: PUSH
103009: LD_INT 3
103011: PUSH
103012: EMPTY
103013: LIST
103014: LIST
103015: PUSH
103016: LD_INT 1
103018: NEG
103019: PUSH
103020: LD_INT 2
103022: PUSH
103023: EMPTY
103024: LIST
103025: LIST
103026: PUSH
103027: LD_INT 2
103029: PUSH
103030: LD_INT 4
103032: PUSH
103033: EMPTY
103034: LIST
103035: LIST
103036: PUSH
103037: LD_INT 2
103039: NEG
103040: PUSH
103041: LD_INT 2
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: LD_INT 4
103050: NEG
103051: PUSH
103052: LD_INT 0
103054: PUSH
103055: EMPTY
103056: LIST
103057: LIST
103058: PUSH
103059: LD_INT 4
103061: NEG
103062: PUSH
103063: LD_INT 1
103065: NEG
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PUSH
103071: LD_INT 3
103073: NEG
103074: PUSH
103075: LD_INT 0
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: PUSH
103082: LD_INT 3
103084: NEG
103085: PUSH
103086: LD_INT 1
103088: PUSH
103089: EMPTY
103090: LIST
103091: LIST
103092: PUSH
103093: LD_INT 4
103095: NEG
103096: PUSH
103097: LD_INT 1
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: PUSH
103104: LD_INT 5
103106: NEG
103107: PUSH
103108: LD_INT 0
103110: PUSH
103111: EMPTY
103112: LIST
103113: LIST
103114: PUSH
103115: LD_INT 5
103117: NEG
103118: PUSH
103119: LD_INT 1
103121: NEG
103122: PUSH
103123: EMPTY
103124: LIST
103125: LIST
103126: PUSH
103127: LD_INT 5
103129: NEG
103130: PUSH
103131: LD_INT 2
103133: NEG
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: PUSH
103139: LD_INT 3
103141: NEG
103142: PUSH
103143: LD_INT 2
103145: PUSH
103146: EMPTY
103147: LIST
103148: LIST
103149: PUSH
103150: EMPTY
103151: LIST
103152: LIST
103153: LIST
103154: LIST
103155: LIST
103156: LIST
103157: LIST
103158: LIST
103159: LIST
103160: LIST
103161: LIST
103162: LIST
103163: LIST
103164: LIST
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: LIST
103173: LIST
103174: LIST
103175: LIST
103176: LIST
103177: LIST
103178: LIST
103179: LIST
103180: LIST
103181: LIST
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: LIST
103194: LIST
103195: LIST
103196: ST_TO_ADDR
// end ; end ;
103197: GO 103200
103199: POP
// case btype of b_depot , b_warehouse :
103200: LD_VAR 0 1
103204: PUSH
103205: LD_INT 0
103207: DOUBLE
103208: EQUAL
103209: IFTRUE 103219
103211: LD_INT 1
103213: DOUBLE
103214: EQUAL
103215: IFTRUE 103219
103217: GO 103420
103219: POP
// case nation of nation_american :
103220: LD_VAR 0 5
103224: PUSH
103225: LD_INT 1
103227: DOUBLE
103228: EQUAL
103229: IFTRUE 103233
103231: GO 103289
103233: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
103234: LD_ADDR_VAR 0 9
103238: PUSH
103239: LD_VAR 0 11
103243: PUSH
103244: LD_VAR 0 12
103248: PUSH
103249: LD_VAR 0 13
103253: PUSH
103254: LD_VAR 0 14
103258: PUSH
103259: LD_VAR 0 15
103263: PUSH
103264: LD_VAR 0 16
103268: PUSH
103269: EMPTY
103270: LIST
103271: LIST
103272: LIST
103273: LIST
103274: LIST
103275: LIST
103276: PUSH
103277: LD_VAR 0 4
103281: PUSH
103282: LD_INT 1
103284: PLUS
103285: ARRAY
103286: ST_TO_ADDR
103287: GO 103418
103289: LD_INT 2
103291: DOUBLE
103292: EQUAL
103293: IFTRUE 103297
103295: GO 103353
103297: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
103298: LD_ADDR_VAR 0 9
103302: PUSH
103303: LD_VAR 0 17
103307: PUSH
103308: LD_VAR 0 18
103312: PUSH
103313: LD_VAR 0 19
103317: PUSH
103318: LD_VAR 0 20
103322: PUSH
103323: LD_VAR 0 21
103327: PUSH
103328: LD_VAR 0 22
103332: PUSH
103333: EMPTY
103334: LIST
103335: LIST
103336: LIST
103337: LIST
103338: LIST
103339: LIST
103340: PUSH
103341: LD_VAR 0 4
103345: PUSH
103346: LD_INT 1
103348: PLUS
103349: ARRAY
103350: ST_TO_ADDR
103351: GO 103418
103353: LD_INT 3
103355: DOUBLE
103356: EQUAL
103357: IFTRUE 103361
103359: GO 103417
103361: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
103362: LD_ADDR_VAR 0 9
103366: PUSH
103367: LD_VAR 0 23
103371: PUSH
103372: LD_VAR 0 24
103376: PUSH
103377: LD_VAR 0 25
103381: PUSH
103382: LD_VAR 0 26
103386: PUSH
103387: LD_VAR 0 27
103391: PUSH
103392: LD_VAR 0 28
103396: PUSH
103397: EMPTY
103398: LIST
103399: LIST
103400: LIST
103401: LIST
103402: LIST
103403: LIST
103404: PUSH
103405: LD_VAR 0 4
103409: PUSH
103410: LD_INT 1
103412: PLUS
103413: ARRAY
103414: ST_TO_ADDR
103415: GO 103418
103417: POP
103418: GO 103973
103420: LD_INT 2
103422: DOUBLE
103423: EQUAL
103424: IFTRUE 103434
103426: LD_INT 3
103428: DOUBLE
103429: EQUAL
103430: IFTRUE 103434
103432: GO 103490
103434: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
103435: LD_ADDR_VAR 0 9
103439: PUSH
103440: LD_VAR 0 29
103444: PUSH
103445: LD_VAR 0 30
103449: PUSH
103450: LD_VAR 0 31
103454: PUSH
103455: LD_VAR 0 32
103459: PUSH
103460: LD_VAR 0 33
103464: PUSH
103465: LD_VAR 0 34
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: LIST
103474: LIST
103475: LIST
103476: LIST
103477: PUSH
103478: LD_VAR 0 4
103482: PUSH
103483: LD_INT 1
103485: PLUS
103486: ARRAY
103487: ST_TO_ADDR
103488: GO 103973
103490: LD_INT 16
103492: DOUBLE
103493: EQUAL
103494: IFTRUE 103552
103496: LD_INT 17
103498: DOUBLE
103499: EQUAL
103500: IFTRUE 103552
103502: LD_INT 18
103504: DOUBLE
103505: EQUAL
103506: IFTRUE 103552
103508: LD_INT 19
103510: DOUBLE
103511: EQUAL
103512: IFTRUE 103552
103514: LD_INT 22
103516: DOUBLE
103517: EQUAL
103518: IFTRUE 103552
103520: LD_INT 20
103522: DOUBLE
103523: EQUAL
103524: IFTRUE 103552
103526: LD_INT 21
103528: DOUBLE
103529: EQUAL
103530: IFTRUE 103552
103532: LD_INT 23
103534: DOUBLE
103535: EQUAL
103536: IFTRUE 103552
103538: LD_INT 24
103540: DOUBLE
103541: EQUAL
103542: IFTRUE 103552
103544: LD_INT 25
103546: DOUBLE
103547: EQUAL
103548: IFTRUE 103552
103550: GO 103608
103552: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
103553: LD_ADDR_VAR 0 9
103557: PUSH
103558: LD_VAR 0 35
103562: PUSH
103563: LD_VAR 0 36
103567: PUSH
103568: LD_VAR 0 37
103572: PUSH
103573: LD_VAR 0 38
103577: PUSH
103578: LD_VAR 0 39
103582: PUSH
103583: LD_VAR 0 40
103587: PUSH
103588: EMPTY
103589: LIST
103590: LIST
103591: LIST
103592: LIST
103593: LIST
103594: LIST
103595: PUSH
103596: LD_VAR 0 4
103600: PUSH
103601: LD_INT 1
103603: PLUS
103604: ARRAY
103605: ST_TO_ADDR
103606: GO 103973
103608: LD_INT 6
103610: DOUBLE
103611: EQUAL
103612: IFTRUE 103664
103614: LD_INT 7
103616: DOUBLE
103617: EQUAL
103618: IFTRUE 103664
103620: LD_INT 8
103622: DOUBLE
103623: EQUAL
103624: IFTRUE 103664
103626: LD_INT 13
103628: DOUBLE
103629: EQUAL
103630: IFTRUE 103664
103632: LD_INT 12
103634: DOUBLE
103635: EQUAL
103636: IFTRUE 103664
103638: LD_INT 15
103640: DOUBLE
103641: EQUAL
103642: IFTRUE 103664
103644: LD_INT 11
103646: DOUBLE
103647: EQUAL
103648: IFTRUE 103664
103650: LD_INT 14
103652: DOUBLE
103653: EQUAL
103654: IFTRUE 103664
103656: LD_INT 10
103658: DOUBLE
103659: EQUAL
103660: IFTRUE 103664
103662: GO 103720
103664: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
103665: LD_ADDR_VAR 0 9
103669: PUSH
103670: LD_VAR 0 41
103674: PUSH
103675: LD_VAR 0 42
103679: PUSH
103680: LD_VAR 0 43
103684: PUSH
103685: LD_VAR 0 44
103689: PUSH
103690: LD_VAR 0 45
103694: PUSH
103695: LD_VAR 0 46
103699: PUSH
103700: EMPTY
103701: LIST
103702: LIST
103703: LIST
103704: LIST
103705: LIST
103706: LIST
103707: PUSH
103708: LD_VAR 0 4
103712: PUSH
103713: LD_INT 1
103715: PLUS
103716: ARRAY
103717: ST_TO_ADDR
103718: GO 103973
103720: LD_INT 36
103722: DOUBLE
103723: EQUAL
103724: IFTRUE 103728
103726: GO 103784
103728: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
103729: LD_ADDR_VAR 0 9
103733: PUSH
103734: LD_VAR 0 47
103738: PUSH
103739: LD_VAR 0 48
103743: PUSH
103744: LD_VAR 0 49
103748: PUSH
103749: LD_VAR 0 50
103753: PUSH
103754: LD_VAR 0 51
103758: PUSH
103759: LD_VAR 0 52
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: LIST
103771: PUSH
103772: LD_VAR 0 4
103776: PUSH
103777: LD_INT 1
103779: PLUS
103780: ARRAY
103781: ST_TO_ADDR
103782: GO 103973
103784: LD_INT 4
103786: DOUBLE
103787: EQUAL
103788: IFTRUE 103810
103790: LD_INT 5
103792: DOUBLE
103793: EQUAL
103794: IFTRUE 103810
103796: LD_INT 34
103798: DOUBLE
103799: EQUAL
103800: IFTRUE 103810
103802: LD_INT 37
103804: DOUBLE
103805: EQUAL
103806: IFTRUE 103810
103808: GO 103866
103810: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
103811: LD_ADDR_VAR 0 9
103815: PUSH
103816: LD_VAR 0 53
103820: PUSH
103821: LD_VAR 0 54
103825: PUSH
103826: LD_VAR 0 55
103830: PUSH
103831: LD_VAR 0 56
103835: PUSH
103836: LD_VAR 0 57
103840: PUSH
103841: LD_VAR 0 58
103845: PUSH
103846: EMPTY
103847: LIST
103848: LIST
103849: LIST
103850: LIST
103851: LIST
103852: LIST
103853: PUSH
103854: LD_VAR 0 4
103858: PUSH
103859: LD_INT 1
103861: PLUS
103862: ARRAY
103863: ST_TO_ADDR
103864: GO 103973
103866: LD_INT 31
103868: DOUBLE
103869: EQUAL
103870: IFTRUE 103916
103872: LD_INT 32
103874: DOUBLE
103875: EQUAL
103876: IFTRUE 103916
103878: LD_INT 33
103880: DOUBLE
103881: EQUAL
103882: IFTRUE 103916
103884: LD_INT 27
103886: DOUBLE
103887: EQUAL
103888: IFTRUE 103916
103890: LD_INT 26
103892: DOUBLE
103893: EQUAL
103894: IFTRUE 103916
103896: LD_INT 28
103898: DOUBLE
103899: EQUAL
103900: IFTRUE 103916
103902: LD_INT 29
103904: DOUBLE
103905: EQUAL
103906: IFTRUE 103916
103908: LD_INT 30
103910: DOUBLE
103911: EQUAL
103912: IFTRUE 103916
103914: GO 103972
103916: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103917: LD_ADDR_VAR 0 9
103921: PUSH
103922: LD_VAR 0 59
103926: PUSH
103927: LD_VAR 0 60
103931: PUSH
103932: LD_VAR 0 61
103936: PUSH
103937: LD_VAR 0 62
103941: PUSH
103942: LD_VAR 0 63
103946: PUSH
103947: LD_VAR 0 64
103951: PUSH
103952: EMPTY
103953: LIST
103954: LIST
103955: LIST
103956: LIST
103957: LIST
103958: LIST
103959: PUSH
103960: LD_VAR 0 4
103964: PUSH
103965: LD_INT 1
103967: PLUS
103968: ARRAY
103969: ST_TO_ADDR
103970: GO 103973
103972: POP
// temp_list2 = [ ] ;
103973: LD_ADDR_VAR 0 10
103977: PUSH
103978: EMPTY
103979: ST_TO_ADDR
// for i in temp_list do
103980: LD_ADDR_VAR 0 8
103984: PUSH
103985: LD_VAR 0 9
103989: PUSH
103990: FOR_IN
103991: IFFALSE 104043
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103993: LD_ADDR_VAR 0 10
103997: PUSH
103998: LD_VAR 0 10
104002: PUSH
104003: LD_VAR 0 8
104007: PUSH
104008: LD_INT 1
104010: ARRAY
104011: PUSH
104012: LD_VAR 0 2
104016: PLUS
104017: PUSH
104018: LD_VAR 0 8
104022: PUSH
104023: LD_INT 2
104025: ARRAY
104026: PUSH
104027: LD_VAR 0 3
104031: PLUS
104032: PUSH
104033: EMPTY
104034: LIST
104035: LIST
104036: PUSH
104037: EMPTY
104038: LIST
104039: ADD
104040: ST_TO_ADDR
104041: GO 103990
104043: POP
104044: POP
// result = temp_list2 ;
104045: LD_ADDR_VAR 0 7
104049: PUSH
104050: LD_VAR 0 10
104054: ST_TO_ADDR
// end ;
104055: LD_VAR 0 7
104059: RET
// export function EnemyInRange ( unit , dist ) ; begin
104060: LD_INT 0
104062: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
104063: LD_ADDR_VAR 0 3
104067: PUSH
104068: LD_VAR 0 1
104072: PPUSH
104073: CALL_OW 255
104077: PPUSH
104078: LD_VAR 0 1
104082: PPUSH
104083: CALL_OW 250
104087: PPUSH
104088: LD_VAR 0 1
104092: PPUSH
104093: CALL_OW 251
104097: PPUSH
104098: LD_VAR 0 2
104102: PPUSH
104103: CALL 77317 0 4
104107: PUSH
104108: LD_INT 4
104110: ARRAY
104111: ST_TO_ADDR
// end ;
104112: LD_VAR 0 3
104116: RET
// export function PlayerSeeMe ( unit ) ; begin
104117: LD_INT 0
104119: PPUSH
// result := See ( your_side , unit ) ;
104120: LD_ADDR_VAR 0 2
104124: PUSH
104125: LD_OWVAR 2
104129: PPUSH
104130: LD_VAR 0 1
104134: PPUSH
104135: CALL_OW 292
104139: ST_TO_ADDR
// end ;
104140: LD_VAR 0 2
104144: RET
// export function ReverseDir ( unit ) ; begin
104145: LD_INT 0
104147: PPUSH
// if not unit then
104148: LD_VAR 0 1
104152: NOT
104153: IFFALSE 104157
// exit ;
104155: GO 104180
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
104157: LD_ADDR_VAR 0 2
104161: PUSH
104162: LD_VAR 0 1
104166: PPUSH
104167: CALL_OW 254
104171: PUSH
104172: LD_INT 3
104174: PLUS
104175: PUSH
104176: LD_INT 6
104178: MOD
104179: ST_TO_ADDR
// end ;
104180: LD_VAR 0 2
104184: RET
// export function ReverseArray ( array ) ; var i ; begin
104185: LD_INT 0
104187: PPUSH
104188: PPUSH
// if not array then
104189: LD_VAR 0 1
104193: NOT
104194: IFFALSE 104198
// exit ;
104196: GO 104253
// result := [ ] ;
104198: LD_ADDR_VAR 0 2
104202: PUSH
104203: EMPTY
104204: ST_TO_ADDR
// for i := array downto 1 do
104205: LD_ADDR_VAR 0 3
104209: PUSH
104210: DOUBLE
104211: LD_VAR 0 1
104215: INC
104216: ST_TO_ADDR
104217: LD_INT 1
104219: PUSH
104220: FOR_DOWNTO
104221: IFFALSE 104251
// result := Join ( result , array [ i ] ) ;
104223: LD_ADDR_VAR 0 2
104227: PUSH
104228: LD_VAR 0 2
104232: PPUSH
104233: LD_VAR 0 1
104237: PUSH
104238: LD_VAR 0 3
104242: ARRAY
104243: PPUSH
104244: CALL 109095 0 2
104248: ST_TO_ADDR
104249: GO 104220
104251: POP
104252: POP
// end ;
104253: LD_VAR 0 2
104257: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
104258: LD_INT 0
104260: PPUSH
104261: PPUSH
104262: PPUSH
104263: PPUSH
104264: PPUSH
104265: PPUSH
// if not unit or not hexes then
104266: LD_VAR 0 1
104270: NOT
104271: IFTRUE 104280
104273: PUSH
104274: LD_VAR 0 2
104278: NOT
104279: OR
104280: IFFALSE 104284
// exit ;
104282: GO 104407
// dist := 9999 ;
104284: LD_ADDR_VAR 0 5
104288: PUSH
104289: LD_INT 9999
104291: ST_TO_ADDR
// for i = 1 to hexes do
104292: LD_ADDR_VAR 0 4
104296: PUSH
104297: DOUBLE
104298: LD_INT 1
104300: DEC
104301: ST_TO_ADDR
104302: LD_VAR 0 2
104306: PUSH
104307: FOR_TO
104308: IFFALSE 104395
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
104310: LD_ADDR_VAR 0 6
104314: PUSH
104315: LD_VAR 0 1
104319: PPUSH
104320: LD_VAR 0 2
104324: PUSH
104325: LD_VAR 0 4
104329: ARRAY
104330: PUSH
104331: LD_INT 1
104333: ARRAY
104334: PPUSH
104335: LD_VAR 0 2
104339: PUSH
104340: LD_VAR 0 4
104344: ARRAY
104345: PUSH
104346: LD_INT 2
104348: ARRAY
104349: PPUSH
104350: CALL_OW 297
104354: ST_TO_ADDR
// if tdist < dist then
104355: LD_VAR 0 6
104359: PUSH
104360: LD_VAR 0 5
104364: LESS
104365: IFFALSE 104393
// begin hex := hexes [ i ] ;
104367: LD_ADDR_VAR 0 8
104371: PUSH
104372: LD_VAR 0 2
104376: PUSH
104377: LD_VAR 0 4
104381: ARRAY
104382: ST_TO_ADDR
// dist := tdist ;
104383: LD_ADDR_VAR 0 5
104387: PUSH
104388: LD_VAR 0 6
104392: ST_TO_ADDR
// end ; end ;
104393: GO 104307
104395: POP
104396: POP
// result := hex ;
104397: LD_ADDR_VAR 0 3
104401: PUSH
104402: LD_VAR 0 8
104406: ST_TO_ADDR
// end ;
104407: LD_VAR 0 3
104411: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
104412: LD_INT 0
104414: PPUSH
104415: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104416: LD_VAR 0 1
104420: NOT
104421: IFTRUE 104460
104423: PUSH
104424: LD_VAR 0 1
104428: PUSH
104429: LD_INT 21
104431: PUSH
104432: LD_INT 2
104434: PUSH
104435: EMPTY
104436: LIST
104437: LIST
104438: PUSH
104439: LD_INT 23
104441: PUSH
104442: LD_INT 2
104444: PUSH
104445: EMPTY
104446: LIST
104447: LIST
104448: PUSH
104449: EMPTY
104450: LIST
104451: LIST
104452: PPUSH
104453: CALL_OW 69
104457: IN
104458: NOT
104459: OR
104460: IFFALSE 104464
// exit ;
104462: GO 104511
// for i = 1 to 3 do
104464: LD_ADDR_VAR 0 3
104468: PUSH
104469: DOUBLE
104470: LD_INT 1
104472: DEC
104473: ST_TO_ADDR
104474: LD_INT 3
104476: PUSH
104477: FOR_TO
104478: IFFALSE 104509
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
104480: LD_VAR 0 1
104484: PPUSH
104485: CALL_OW 250
104489: PPUSH
104490: LD_VAR 0 1
104494: PPUSH
104495: CALL_OW 251
104499: PPUSH
104500: LD_INT 1
104502: PPUSH
104503: CALL_OW 453
104507: GO 104477
104509: POP
104510: POP
// end ;
104511: LD_VAR 0 2
104515: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
104516: LD_INT 0
104518: PPUSH
104519: PPUSH
104520: PPUSH
104521: PPUSH
104522: PPUSH
104523: PPUSH
// if not unit or not enemy_unit then
104524: LD_VAR 0 1
104528: NOT
104529: IFTRUE 104538
104531: PUSH
104532: LD_VAR 0 2
104536: NOT
104537: OR
104538: IFFALSE 104542
// exit ;
104540: GO 105013
// if GetLives ( i ) < 250 then
104542: LD_VAR 0 4
104546: PPUSH
104547: CALL_OW 256
104551: PUSH
104552: LD_INT 250
104554: LESS
104555: IFFALSE 104568
// begin ComAutodestruct ( i ) ;
104557: LD_VAR 0 4
104561: PPUSH
104562: CALL 104412 0 1
// exit ;
104566: GO 105013
// end ; x := GetX ( enemy_unit ) ;
104568: LD_ADDR_VAR 0 7
104572: PUSH
104573: LD_VAR 0 2
104577: PPUSH
104578: CALL_OW 250
104582: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
104583: LD_ADDR_VAR 0 8
104587: PUSH
104588: LD_VAR 0 2
104592: PPUSH
104593: CALL_OW 251
104597: ST_TO_ADDR
// if not x or not y then
104598: LD_VAR 0 7
104602: NOT
104603: IFTRUE 104612
104605: PUSH
104606: LD_VAR 0 8
104610: NOT
104611: OR
104612: IFFALSE 104616
// exit ;
104614: GO 105013
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
104616: LD_ADDR_VAR 0 6
104620: PUSH
104621: LD_VAR 0 7
104625: PPUSH
104626: LD_INT 0
104628: PPUSH
104629: LD_INT 4
104631: PPUSH
104632: CALL_OW 272
104636: PUSH
104637: LD_VAR 0 8
104641: PPUSH
104642: LD_INT 0
104644: PPUSH
104645: LD_INT 4
104647: PPUSH
104648: CALL_OW 273
104652: PUSH
104653: EMPTY
104654: LIST
104655: LIST
104656: PUSH
104657: LD_VAR 0 7
104661: PPUSH
104662: LD_INT 1
104664: PPUSH
104665: LD_INT 4
104667: PPUSH
104668: CALL_OW 272
104672: PUSH
104673: LD_VAR 0 8
104677: PPUSH
104678: LD_INT 1
104680: PPUSH
104681: LD_INT 4
104683: PPUSH
104684: CALL_OW 273
104688: PUSH
104689: EMPTY
104690: LIST
104691: LIST
104692: PUSH
104693: LD_VAR 0 7
104697: PPUSH
104698: LD_INT 2
104700: PPUSH
104701: LD_INT 4
104703: PPUSH
104704: CALL_OW 272
104708: PUSH
104709: LD_VAR 0 8
104713: PPUSH
104714: LD_INT 2
104716: PPUSH
104717: LD_INT 4
104719: PPUSH
104720: CALL_OW 273
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: PUSH
104729: LD_VAR 0 7
104733: PPUSH
104734: LD_INT 3
104736: PPUSH
104737: LD_INT 4
104739: PPUSH
104740: CALL_OW 272
104744: PUSH
104745: LD_VAR 0 8
104749: PPUSH
104750: LD_INT 3
104752: PPUSH
104753: LD_INT 4
104755: PPUSH
104756: CALL_OW 273
104760: PUSH
104761: EMPTY
104762: LIST
104763: LIST
104764: PUSH
104765: LD_VAR 0 7
104769: PPUSH
104770: LD_INT 4
104772: PPUSH
104773: LD_INT 4
104775: PPUSH
104776: CALL_OW 272
104780: PUSH
104781: LD_VAR 0 8
104785: PPUSH
104786: LD_INT 4
104788: PPUSH
104789: LD_INT 4
104791: PPUSH
104792: CALL_OW 273
104796: PUSH
104797: EMPTY
104798: LIST
104799: LIST
104800: PUSH
104801: LD_VAR 0 7
104805: PPUSH
104806: LD_INT 5
104808: PPUSH
104809: LD_INT 4
104811: PPUSH
104812: CALL_OW 272
104816: PUSH
104817: LD_VAR 0 8
104821: PPUSH
104822: LD_INT 5
104824: PPUSH
104825: LD_INT 4
104827: PPUSH
104828: CALL_OW 273
104832: PUSH
104833: EMPTY
104834: LIST
104835: LIST
104836: PUSH
104837: EMPTY
104838: LIST
104839: LIST
104840: LIST
104841: LIST
104842: LIST
104843: LIST
104844: ST_TO_ADDR
// for i = tmp downto 1 do
104845: LD_ADDR_VAR 0 4
104849: PUSH
104850: DOUBLE
104851: LD_VAR 0 6
104855: INC
104856: ST_TO_ADDR
104857: LD_INT 1
104859: PUSH
104860: FOR_DOWNTO
104861: IFFALSE 104964
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
104863: LD_VAR 0 6
104867: PUSH
104868: LD_VAR 0 4
104872: ARRAY
104873: PUSH
104874: LD_INT 1
104876: ARRAY
104877: PPUSH
104878: LD_VAR 0 6
104882: PUSH
104883: LD_VAR 0 4
104887: ARRAY
104888: PUSH
104889: LD_INT 2
104891: ARRAY
104892: PPUSH
104893: CALL_OW 488
104897: NOT
104898: IFTRUE 104940
104900: PUSH
104901: LD_VAR 0 6
104905: PUSH
104906: LD_VAR 0 4
104910: ARRAY
104911: PUSH
104912: LD_INT 1
104914: ARRAY
104915: PPUSH
104916: LD_VAR 0 6
104920: PUSH
104921: LD_VAR 0 4
104925: ARRAY
104926: PUSH
104927: LD_INT 2
104929: ARRAY
104930: PPUSH
104931: CALL_OW 428
104935: PUSH
104936: LD_INT 0
104938: NONEQUAL
104939: OR
104940: IFFALSE 104962
// tmp := Delete ( tmp , i ) ;
104942: LD_ADDR_VAR 0 6
104946: PUSH
104947: LD_VAR 0 6
104951: PPUSH
104952: LD_VAR 0 4
104956: PPUSH
104957: CALL_OW 3
104961: ST_TO_ADDR
104962: GO 104860
104964: POP
104965: POP
// j := GetClosestHex ( unit , tmp ) ;
104966: LD_ADDR_VAR 0 5
104970: PUSH
104971: LD_VAR 0 1
104975: PPUSH
104976: LD_VAR 0 6
104980: PPUSH
104981: CALL 104258 0 2
104985: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104986: LD_VAR 0 1
104990: PPUSH
104991: LD_VAR 0 5
104995: PUSH
104996: LD_INT 1
104998: ARRAY
104999: PPUSH
105000: LD_VAR 0 5
105004: PUSH
105005: LD_INT 2
105007: ARRAY
105008: PPUSH
105009: CALL_OW 111
// end ;
105013: LD_VAR 0 3
105017: RET
// export function PrepareApemanSoldier ( ) ; begin
105018: LD_INT 0
105020: PPUSH
// uc_nation := 0 ;
105021: LD_ADDR_OWVAR 21
105025: PUSH
105026: LD_INT 0
105028: ST_TO_ADDR
// hc_sex := sex_male ;
105029: LD_ADDR_OWVAR 27
105033: PUSH
105034: LD_INT 1
105036: ST_TO_ADDR
// hc_name :=  ;
105037: LD_ADDR_OWVAR 26
105041: PUSH
105042: LD_STRING 
105044: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
105045: LD_ADDR_OWVAR 28
105049: PUSH
105050: LD_INT 15
105052: ST_TO_ADDR
// hc_gallery :=  ;
105053: LD_ADDR_OWVAR 33
105057: PUSH
105058: LD_STRING 
105060: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105061: LD_ADDR_OWVAR 31
105065: PUSH
105066: LD_INT 0
105068: PPUSH
105069: LD_INT 3
105071: PPUSH
105072: CALL_OW 12
105076: PUSH
105077: LD_INT 0
105079: PPUSH
105080: LD_INT 3
105082: PPUSH
105083: CALL_OW 12
105087: PUSH
105088: LD_INT 0
105090: PUSH
105091: LD_INT 0
105093: PUSH
105094: EMPTY
105095: LIST
105096: LIST
105097: LIST
105098: LIST
105099: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105100: LD_ADDR_OWVAR 29
105104: PUSH
105105: LD_INT 12
105107: PUSH
105108: LD_INT 12
105110: PUSH
105111: EMPTY
105112: LIST
105113: LIST
105114: ST_TO_ADDR
// end ;
105115: LD_VAR 0 1
105119: RET
// export function PrepareApemanEngineer ( ) ; begin
105120: LD_INT 0
105122: PPUSH
// uc_nation := 0 ;
105123: LD_ADDR_OWVAR 21
105127: PUSH
105128: LD_INT 0
105130: ST_TO_ADDR
// hc_sex := sex_male ;
105131: LD_ADDR_OWVAR 27
105135: PUSH
105136: LD_INT 1
105138: ST_TO_ADDR
// hc_name :=  ;
105139: LD_ADDR_OWVAR 26
105143: PUSH
105144: LD_STRING 
105146: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
105147: LD_ADDR_OWVAR 28
105151: PUSH
105152: LD_INT 16
105154: ST_TO_ADDR
// hc_gallery :=  ;
105155: LD_ADDR_OWVAR 33
105159: PUSH
105160: LD_STRING 
105162: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105163: LD_ADDR_OWVAR 31
105167: PUSH
105168: LD_INT 0
105170: PPUSH
105171: LD_INT 3
105173: PPUSH
105174: CALL_OW 12
105178: PUSH
105179: LD_INT 0
105181: PPUSH
105182: LD_INT 3
105184: PPUSH
105185: CALL_OW 12
105189: PUSH
105190: LD_INT 0
105192: PUSH
105193: LD_INT 0
105195: PUSH
105196: EMPTY
105197: LIST
105198: LIST
105199: LIST
105200: LIST
105201: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105202: LD_ADDR_OWVAR 29
105206: PUSH
105207: LD_INT 12
105209: PUSH
105210: LD_INT 12
105212: PUSH
105213: EMPTY
105214: LIST
105215: LIST
105216: ST_TO_ADDR
// end ;
105217: LD_VAR 0 1
105221: RET
// export function PrepareApeman ( agressivity ) ; begin
105222: LD_INT 0
105224: PPUSH
// uc_side := 0 ;
105225: LD_ADDR_OWVAR 20
105229: PUSH
105230: LD_INT 0
105232: ST_TO_ADDR
// uc_nation := 0 ;
105233: LD_ADDR_OWVAR 21
105237: PUSH
105238: LD_INT 0
105240: ST_TO_ADDR
// hc_sex := sex_male ;
105241: LD_ADDR_OWVAR 27
105245: PUSH
105246: LD_INT 1
105248: ST_TO_ADDR
// hc_class := class_apeman ;
105249: LD_ADDR_OWVAR 28
105253: PUSH
105254: LD_INT 12
105256: ST_TO_ADDR
// hc_gallery :=  ;
105257: LD_ADDR_OWVAR 33
105261: PUSH
105262: LD_STRING 
105264: ST_TO_ADDR
// hc_name :=  ;
105265: LD_ADDR_OWVAR 26
105269: PUSH
105270: LD_STRING 
105272: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105273: LD_ADDR_OWVAR 29
105277: PUSH
105278: LD_INT 12
105280: PUSH
105281: LD_INT 12
105283: PUSH
105284: EMPTY
105285: LIST
105286: LIST
105287: ST_TO_ADDR
// if agressivity = 0 then
105288: LD_VAR 0 1
105292: PUSH
105293: LD_INT 0
105295: EQUAL
105296: IFFALSE 105308
// hc_agressivity := 0 else
105298: LD_ADDR_OWVAR 35
105302: PUSH
105303: LD_INT 0
105305: ST_TO_ADDR
105306: GO 105329
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105308: LD_ADDR_OWVAR 35
105312: PUSH
105313: LD_VAR 0 1
105317: NEG
105318: PPUSH
105319: LD_VAR 0 1
105323: PPUSH
105324: CALL_OW 12
105328: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105329: LD_ADDR_OWVAR 31
105333: PUSH
105334: LD_INT 0
105336: PPUSH
105337: LD_INT 3
105339: PPUSH
105340: CALL_OW 12
105344: PUSH
105345: LD_INT 0
105347: PPUSH
105348: LD_INT 3
105350: PPUSH
105351: CALL_OW 12
105355: PUSH
105356: LD_INT 0
105358: PUSH
105359: LD_INT 0
105361: PUSH
105362: EMPTY
105363: LIST
105364: LIST
105365: LIST
105366: LIST
105367: ST_TO_ADDR
// end ;
105368: LD_VAR 0 2
105372: RET
// export function PrepareTiger ( agressivity ) ; begin
105373: LD_INT 0
105375: PPUSH
// uc_side := 0 ;
105376: LD_ADDR_OWVAR 20
105380: PUSH
105381: LD_INT 0
105383: ST_TO_ADDR
// uc_nation := 0 ;
105384: LD_ADDR_OWVAR 21
105388: PUSH
105389: LD_INT 0
105391: ST_TO_ADDR
// InitHc ;
105392: CALL_OW 19
// hc_class := class_tiger ;
105396: LD_ADDR_OWVAR 28
105400: PUSH
105401: LD_INT 14
105403: ST_TO_ADDR
// hc_gallery :=  ;
105404: LD_ADDR_OWVAR 33
105408: PUSH
105409: LD_STRING 
105411: ST_TO_ADDR
// hc_name :=  ;
105412: LD_ADDR_OWVAR 26
105416: PUSH
105417: LD_STRING 
105419: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105420: LD_ADDR_OWVAR 35
105424: PUSH
105425: LD_VAR 0 1
105429: NEG
105430: PPUSH
105431: LD_VAR 0 1
105435: PPUSH
105436: CALL_OW 12
105440: ST_TO_ADDR
// end ;
105441: LD_VAR 0 2
105445: RET
// export function PrepareEnchidna ( ) ; begin
105446: LD_INT 0
105448: PPUSH
// uc_side := 0 ;
105449: LD_ADDR_OWVAR 20
105453: PUSH
105454: LD_INT 0
105456: ST_TO_ADDR
// uc_nation := 0 ;
105457: LD_ADDR_OWVAR 21
105461: PUSH
105462: LD_INT 0
105464: ST_TO_ADDR
// InitHc ;
105465: CALL_OW 19
// hc_class := class_baggie ;
105469: LD_ADDR_OWVAR 28
105473: PUSH
105474: LD_INT 13
105476: ST_TO_ADDR
// hc_gallery :=  ;
105477: LD_ADDR_OWVAR 33
105481: PUSH
105482: LD_STRING 
105484: ST_TO_ADDR
// hc_name :=  ;
105485: LD_ADDR_OWVAR 26
105489: PUSH
105490: LD_STRING 
105492: ST_TO_ADDR
// end ;
105493: LD_VAR 0 1
105497: RET
// export function PrepareFrog ( ) ; begin
105498: LD_INT 0
105500: PPUSH
// uc_side := 0 ;
105501: LD_ADDR_OWVAR 20
105505: PUSH
105506: LD_INT 0
105508: ST_TO_ADDR
// uc_nation := 0 ;
105509: LD_ADDR_OWVAR 21
105513: PUSH
105514: LD_INT 0
105516: ST_TO_ADDR
// InitHc ;
105517: CALL_OW 19
// hc_class := class_frog ;
105521: LD_ADDR_OWVAR 28
105525: PUSH
105526: LD_INT 19
105528: ST_TO_ADDR
// hc_gallery :=  ;
105529: LD_ADDR_OWVAR 33
105533: PUSH
105534: LD_STRING 
105536: ST_TO_ADDR
// hc_name :=  ;
105537: LD_ADDR_OWVAR 26
105541: PUSH
105542: LD_STRING 
105544: ST_TO_ADDR
// end ;
105545: LD_VAR 0 1
105549: RET
// export function PrepareFish ( ) ; begin
105550: LD_INT 0
105552: PPUSH
// uc_side := 0 ;
105553: LD_ADDR_OWVAR 20
105557: PUSH
105558: LD_INT 0
105560: ST_TO_ADDR
// uc_nation := 0 ;
105561: LD_ADDR_OWVAR 21
105565: PUSH
105566: LD_INT 0
105568: ST_TO_ADDR
// InitHc ;
105569: CALL_OW 19
// hc_class := class_fish ;
105573: LD_ADDR_OWVAR 28
105577: PUSH
105578: LD_INT 20
105580: ST_TO_ADDR
// hc_gallery :=  ;
105581: LD_ADDR_OWVAR 33
105585: PUSH
105586: LD_STRING 
105588: ST_TO_ADDR
// hc_name :=  ;
105589: LD_ADDR_OWVAR 26
105593: PUSH
105594: LD_STRING 
105596: ST_TO_ADDR
// end ;
105597: LD_VAR 0 1
105601: RET
// export function PrepareBird ( ) ; begin
105602: LD_INT 0
105604: PPUSH
// uc_side := 0 ;
105605: LD_ADDR_OWVAR 20
105609: PUSH
105610: LD_INT 0
105612: ST_TO_ADDR
// uc_nation := 0 ;
105613: LD_ADDR_OWVAR 21
105617: PUSH
105618: LD_INT 0
105620: ST_TO_ADDR
// InitHc ;
105621: CALL_OW 19
// hc_class := class_phororhacos ;
105625: LD_ADDR_OWVAR 28
105629: PUSH
105630: LD_INT 18
105632: ST_TO_ADDR
// hc_gallery :=  ;
105633: LD_ADDR_OWVAR 33
105637: PUSH
105638: LD_STRING 
105640: ST_TO_ADDR
// hc_name :=  ;
105641: LD_ADDR_OWVAR 26
105645: PUSH
105646: LD_STRING 
105648: ST_TO_ADDR
// end ;
105649: LD_VAR 0 1
105653: RET
// export function PrepareHorse ( ) ; begin
105654: LD_INT 0
105656: PPUSH
// uc_side := 0 ;
105657: LD_ADDR_OWVAR 20
105661: PUSH
105662: LD_INT 0
105664: ST_TO_ADDR
// uc_nation := 0 ;
105665: LD_ADDR_OWVAR 21
105669: PUSH
105670: LD_INT 0
105672: ST_TO_ADDR
// InitHc ;
105673: CALL_OW 19
// hc_class := class_horse ;
105677: LD_ADDR_OWVAR 28
105681: PUSH
105682: LD_INT 21
105684: ST_TO_ADDR
// hc_gallery :=  ;
105685: LD_ADDR_OWVAR 33
105689: PUSH
105690: LD_STRING 
105692: ST_TO_ADDR
// hc_name :=  ;
105693: LD_ADDR_OWVAR 26
105697: PUSH
105698: LD_STRING 
105700: ST_TO_ADDR
// end ;
105701: LD_VAR 0 1
105705: RET
// export function PrepareMastodont ( ) ; begin
105706: LD_INT 0
105708: PPUSH
// uc_side := 0 ;
105709: LD_ADDR_OWVAR 20
105713: PUSH
105714: LD_INT 0
105716: ST_TO_ADDR
// uc_nation := 0 ;
105717: LD_ADDR_OWVAR 21
105721: PUSH
105722: LD_INT 0
105724: ST_TO_ADDR
// vc_chassis := class_mastodont ;
105725: LD_ADDR_OWVAR 37
105729: PUSH
105730: LD_INT 31
105732: ST_TO_ADDR
// vc_control := control_rider ;
105733: LD_ADDR_OWVAR 38
105737: PUSH
105738: LD_INT 4
105740: ST_TO_ADDR
// end ;
105741: LD_VAR 0 1
105745: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
105746: LD_INT 0
105748: PPUSH
105749: PPUSH
105750: PPUSH
// uc_side = 0 ;
105751: LD_ADDR_OWVAR 20
105755: PUSH
105756: LD_INT 0
105758: ST_TO_ADDR
// uc_nation = 0 ;
105759: LD_ADDR_OWVAR 21
105763: PUSH
105764: LD_INT 0
105766: ST_TO_ADDR
// InitHc_All ( ) ;
105767: CALL_OW 584
// InitVc ;
105771: CALL_OW 20
// if mastodonts then
105775: LD_VAR 0 6
105779: IFFALSE 105846
// for i = 1 to mastodonts do
105781: LD_ADDR_VAR 0 11
105785: PUSH
105786: DOUBLE
105787: LD_INT 1
105789: DEC
105790: ST_TO_ADDR
105791: LD_VAR 0 6
105795: PUSH
105796: FOR_TO
105797: IFFALSE 105844
// begin vc_chassis := 31 ;
105799: LD_ADDR_OWVAR 37
105803: PUSH
105804: LD_INT 31
105806: ST_TO_ADDR
// vc_control := control_rider ;
105807: LD_ADDR_OWVAR 38
105811: PUSH
105812: LD_INT 4
105814: ST_TO_ADDR
// animal := CreateVehicle ;
105815: LD_ADDR_VAR 0 12
105819: PUSH
105820: CALL_OW 45
105824: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105825: LD_VAR 0 12
105829: PPUSH
105830: LD_VAR 0 8
105834: PPUSH
105835: LD_INT 0
105837: PPUSH
105838: CALL 107988 0 3
// end ;
105842: GO 105796
105844: POP
105845: POP
// if horses then
105846: LD_VAR 0 5
105850: IFFALSE 105917
// for i = 1 to horses do
105852: LD_ADDR_VAR 0 11
105856: PUSH
105857: DOUBLE
105858: LD_INT 1
105860: DEC
105861: ST_TO_ADDR
105862: LD_VAR 0 5
105866: PUSH
105867: FOR_TO
105868: IFFALSE 105915
// begin hc_class := 21 ;
105870: LD_ADDR_OWVAR 28
105874: PUSH
105875: LD_INT 21
105877: ST_TO_ADDR
// hc_gallery :=  ;
105878: LD_ADDR_OWVAR 33
105882: PUSH
105883: LD_STRING 
105885: ST_TO_ADDR
// animal := CreateHuman ;
105886: LD_ADDR_VAR 0 12
105890: PUSH
105891: CALL_OW 44
105895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105896: LD_VAR 0 12
105900: PPUSH
105901: LD_VAR 0 8
105905: PPUSH
105906: LD_INT 0
105908: PPUSH
105909: CALL 107988 0 3
// end ;
105913: GO 105867
105915: POP
105916: POP
// if birds then
105917: LD_VAR 0 1
105921: IFFALSE 105988
// for i = 1 to birds do
105923: LD_ADDR_VAR 0 11
105927: PUSH
105928: DOUBLE
105929: LD_INT 1
105931: DEC
105932: ST_TO_ADDR
105933: LD_VAR 0 1
105937: PUSH
105938: FOR_TO
105939: IFFALSE 105986
// begin hc_class := 18 ;
105941: LD_ADDR_OWVAR 28
105945: PUSH
105946: LD_INT 18
105948: ST_TO_ADDR
// hc_gallery =  ;
105949: LD_ADDR_OWVAR 33
105953: PUSH
105954: LD_STRING 
105956: ST_TO_ADDR
// animal := CreateHuman ;
105957: LD_ADDR_VAR 0 12
105961: PUSH
105962: CALL_OW 44
105966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105967: LD_VAR 0 12
105971: PPUSH
105972: LD_VAR 0 8
105976: PPUSH
105977: LD_INT 0
105979: PPUSH
105980: CALL 107988 0 3
// end ;
105984: GO 105938
105986: POP
105987: POP
// if tigers then
105988: LD_VAR 0 2
105992: IFFALSE 106076
// for i = 1 to tigers do
105994: LD_ADDR_VAR 0 11
105998: PUSH
105999: DOUBLE
106000: LD_INT 1
106002: DEC
106003: ST_TO_ADDR
106004: LD_VAR 0 2
106008: PUSH
106009: FOR_TO
106010: IFFALSE 106074
// begin hc_class = class_tiger ;
106012: LD_ADDR_OWVAR 28
106016: PUSH
106017: LD_INT 14
106019: ST_TO_ADDR
// hc_gallery =  ;
106020: LD_ADDR_OWVAR 33
106024: PUSH
106025: LD_STRING 
106027: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
106028: LD_ADDR_OWVAR 35
106032: PUSH
106033: LD_INT 7
106035: NEG
106036: PPUSH
106037: LD_INT 7
106039: PPUSH
106040: CALL_OW 12
106044: ST_TO_ADDR
// animal := CreateHuman ;
106045: LD_ADDR_VAR 0 12
106049: PUSH
106050: CALL_OW 44
106054: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106055: LD_VAR 0 12
106059: PPUSH
106060: LD_VAR 0 8
106064: PPUSH
106065: LD_INT 0
106067: PPUSH
106068: CALL 107988 0 3
// end ;
106072: GO 106009
106074: POP
106075: POP
// if apemans then
106076: LD_VAR 0 3
106080: IFFALSE 106203
// for i = 1 to apemans do
106082: LD_ADDR_VAR 0 11
106086: PUSH
106087: DOUBLE
106088: LD_INT 1
106090: DEC
106091: ST_TO_ADDR
106092: LD_VAR 0 3
106096: PUSH
106097: FOR_TO
106098: IFFALSE 106201
// begin hc_class = class_apeman ;
106100: LD_ADDR_OWVAR 28
106104: PUSH
106105: LD_INT 12
106107: ST_TO_ADDR
// hc_gallery =  ;
106108: LD_ADDR_OWVAR 33
106112: PUSH
106113: LD_STRING 
106115: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
106116: LD_ADDR_OWVAR 35
106120: PUSH
106121: LD_INT 2
106123: NEG
106124: PPUSH
106125: LD_INT 2
106127: PPUSH
106128: CALL_OW 12
106132: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
106133: LD_ADDR_OWVAR 31
106137: PUSH
106138: LD_INT 1
106140: PPUSH
106141: LD_INT 3
106143: PPUSH
106144: CALL_OW 12
106148: PUSH
106149: LD_INT 1
106151: PPUSH
106152: LD_INT 3
106154: PPUSH
106155: CALL_OW 12
106159: PUSH
106160: LD_INT 0
106162: PUSH
106163: LD_INT 0
106165: PUSH
106166: EMPTY
106167: LIST
106168: LIST
106169: LIST
106170: LIST
106171: ST_TO_ADDR
// animal := CreateHuman ;
106172: LD_ADDR_VAR 0 12
106176: PUSH
106177: CALL_OW 44
106181: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106182: LD_VAR 0 12
106186: PPUSH
106187: LD_VAR 0 8
106191: PPUSH
106192: LD_INT 0
106194: PPUSH
106195: CALL 107988 0 3
// end ;
106199: GO 106097
106201: POP
106202: POP
// if enchidnas then
106203: LD_VAR 0 4
106207: IFFALSE 106274
// for i = 1 to enchidnas do
106209: LD_ADDR_VAR 0 11
106213: PUSH
106214: DOUBLE
106215: LD_INT 1
106217: DEC
106218: ST_TO_ADDR
106219: LD_VAR 0 4
106223: PUSH
106224: FOR_TO
106225: IFFALSE 106272
// begin hc_class = 13 ;
106227: LD_ADDR_OWVAR 28
106231: PUSH
106232: LD_INT 13
106234: ST_TO_ADDR
// hc_gallery =  ;
106235: LD_ADDR_OWVAR 33
106239: PUSH
106240: LD_STRING 
106242: ST_TO_ADDR
// animal := CreateHuman ;
106243: LD_ADDR_VAR 0 12
106247: PUSH
106248: CALL_OW 44
106252: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106253: LD_VAR 0 12
106257: PPUSH
106258: LD_VAR 0 8
106262: PPUSH
106263: LD_INT 0
106265: PPUSH
106266: CALL 107988 0 3
// end ;
106270: GO 106224
106272: POP
106273: POP
// if fishes then
106274: LD_VAR 0 7
106278: IFFALSE 106345
// for i = 1 to fishes do
106280: LD_ADDR_VAR 0 11
106284: PUSH
106285: DOUBLE
106286: LD_INT 1
106288: DEC
106289: ST_TO_ADDR
106290: LD_VAR 0 7
106294: PUSH
106295: FOR_TO
106296: IFFALSE 106343
// begin hc_class = 20 ;
106298: LD_ADDR_OWVAR 28
106302: PUSH
106303: LD_INT 20
106305: ST_TO_ADDR
// hc_gallery =  ;
106306: LD_ADDR_OWVAR 33
106310: PUSH
106311: LD_STRING 
106313: ST_TO_ADDR
// animal := CreateHuman ;
106314: LD_ADDR_VAR 0 12
106318: PUSH
106319: CALL_OW 44
106323: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
106324: LD_VAR 0 12
106328: PPUSH
106329: LD_VAR 0 9
106333: PPUSH
106334: LD_INT 0
106336: PPUSH
106337: CALL 107988 0 3
// end ;
106341: GO 106295
106343: POP
106344: POP
// end ;
106345: LD_VAR 0 10
106349: RET
// export function WantHeal ( sci , unit ) ; begin
106350: LD_INT 0
106352: PPUSH
// if GetTaskList ( sci ) > 0 then
106353: LD_VAR 0 1
106357: PPUSH
106358: CALL_OW 437
106362: PUSH
106363: LD_INT 0
106365: GREATER
106366: IFFALSE 106438
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
106368: LD_VAR 0 1
106372: PPUSH
106373: CALL_OW 437
106377: PUSH
106378: LD_INT 1
106380: ARRAY
106381: PUSH
106382: LD_INT 1
106384: ARRAY
106385: PUSH
106386: LD_STRING l
106388: EQUAL
106389: IFFALSE 106416
106391: PUSH
106392: LD_VAR 0 1
106396: PPUSH
106397: CALL_OW 437
106401: PUSH
106402: LD_INT 1
106404: ARRAY
106405: PUSH
106406: LD_INT 4
106408: ARRAY
106409: PUSH
106410: LD_VAR 0 2
106414: EQUAL
106415: AND
106416: IFFALSE 106428
// result := true else
106418: LD_ADDR_VAR 0 3
106422: PUSH
106423: LD_INT 1
106425: ST_TO_ADDR
106426: GO 106436
// result := false ;
106428: LD_ADDR_VAR 0 3
106432: PUSH
106433: LD_INT 0
106435: ST_TO_ADDR
// end else
106436: GO 106446
// result := false ;
106438: LD_ADDR_VAR 0 3
106442: PUSH
106443: LD_INT 0
106445: ST_TO_ADDR
// end ;
106446: LD_VAR 0 3
106450: RET
// export function HealTarget ( sci ) ; begin
106451: LD_INT 0
106453: PPUSH
// if not sci then
106454: LD_VAR 0 1
106458: NOT
106459: IFFALSE 106463
// exit ;
106461: GO 106528
// result := 0 ;
106463: LD_ADDR_VAR 0 2
106467: PUSH
106468: LD_INT 0
106470: ST_TO_ADDR
// if GetTaskList ( sci ) then
106471: LD_VAR 0 1
106475: PPUSH
106476: CALL_OW 437
106480: IFFALSE 106528
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
106482: LD_VAR 0 1
106486: PPUSH
106487: CALL_OW 437
106491: PUSH
106492: LD_INT 1
106494: ARRAY
106495: PUSH
106496: LD_INT 1
106498: ARRAY
106499: PUSH
106500: LD_STRING l
106502: EQUAL
106503: IFFALSE 106528
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
106505: LD_ADDR_VAR 0 2
106509: PUSH
106510: LD_VAR 0 1
106514: PPUSH
106515: CALL_OW 437
106519: PUSH
106520: LD_INT 1
106522: ARRAY
106523: PUSH
106524: LD_INT 4
106526: ARRAY
106527: ST_TO_ADDR
// end ;
106528: LD_VAR 0 2
106532: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
106533: LD_INT 0
106535: PPUSH
106536: PPUSH
106537: PPUSH
106538: PPUSH
// if not base_units then
106539: LD_VAR 0 1
106543: NOT
106544: IFFALSE 106548
// exit ;
106546: GO 106635
// result := false ;
106548: LD_ADDR_VAR 0 2
106552: PUSH
106553: LD_INT 0
106555: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
106556: LD_ADDR_VAR 0 5
106560: PUSH
106561: LD_VAR 0 1
106565: PPUSH
106566: LD_INT 21
106568: PUSH
106569: LD_INT 3
106571: PUSH
106572: EMPTY
106573: LIST
106574: LIST
106575: PPUSH
106576: CALL_OW 72
106580: ST_TO_ADDR
// if not tmp then
106581: LD_VAR 0 5
106585: NOT
106586: IFFALSE 106590
// exit ;
106588: GO 106635
// for i in tmp do
106590: LD_ADDR_VAR 0 3
106594: PUSH
106595: LD_VAR 0 5
106599: PUSH
106600: FOR_IN
106601: IFFALSE 106633
// begin result := EnemyInRange ( i , 22 ) ;
106603: LD_ADDR_VAR 0 2
106607: PUSH
106608: LD_VAR 0 3
106612: PPUSH
106613: LD_INT 22
106615: PPUSH
106616: CALL 104060 0 2
106620: ST_TO_ADDR
// if result then
106621: LD_VAR 0 2
106625: IFFALSE 106631
// exit ;
106627: POP
106628: POP
106629: GO 106635
// end ;
106631: GO 106600
106633: POP
106634: POP
// end ;
106635: LD_VAR 0 2
106639: RET
// export function FilterByTag ( units , tag ) ; begin
106640: LD_INT 0
106642: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
106643: LD_ADDR_VAR 0 3
106647: PUSH
106648: LD_VAR 0 1
106652: PPUSH
106653: LD_INT 120
106655: PUSH
106656: LD_VAR 0 2
106660: PUSH
106661: EMPTY
106662: LIST
106663: LIST
106664: PPUSH
106665: CALL_OW 72
106669: ST_TO_ADDR
// end ;
106670: LD_VAR 0 3
106674: RET
// export function IsDriver ( un ) ; begin
106675: LD_INT 0
106677: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
106678: LD_ADDR_VAR 0 2
106682: PUSH
106683: LD_VAR 0 1
106687: PUSH
106688: LD_INT 55
106690: PUSH
106691: EMPTY
106692: LIST
106693: PPUSH
106694: CALL_OW 69
106698: IN
106699: ST_TO_ADDR
// end ;
106700: LD_VAR 0 2
106704: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
106705: LD_INT 0
106707: PPUSH
106708: PPUSH
// list := [ ] ;
106709: LD_ADDR_VAR 0 5
106713: PUSH
106714: EMPTY
106715: ST_TO_ADDR
// case d of 0 :
106716: LD_VAR 0 3
106720: PUSH
106721: LD_INT 0
106723: DOUBLE
106724: EQUAL
106725: IFTRUE 106729
106727: GO 106862
106729: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
106730: LD_ADDR_VAR 0 5
106734: PUSH
106735: LD_VAR 0 1
106739: PUSH
106740: LD_INT 4
106742: MINUS
106743: PUSH
106744: LD_VAR 0 2
106748: PUSH
106749: LD_INT 4
106751: MINUS
106752: PUSH
106753: LD_INT 2
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: LIST
106760: PUSH
106761: LD_VAR 0 1
106765: PUSH
106766: LD_INT 3
106768: MINUS
106769: PUSH
106770: LD_VAR 0 2
106774: PUSH
106775: LD_INT 1
106777: PUSH
106778: EMPTY
106779: LIST
106780: LIST
106781: LIST
106782: PUSH
106783: LD_VAR 0 1
106787: PUSH
106788: LD_INT 4
106790: PLUS
106791: PUSH
106792: LD_VAR 0 2
106796: PUSH
106797: LD_INT 4
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: LIST
106804: PUSH
106805: LD_VAR 0 1
106809: PUSH
106810: LD_INT 3
106812: PLUS
106813: PUSH
106814: LD_VAR 0 2
106818: PUSH
106819: LD_INT 3
106821: PLUS
106822: PUSH
106823: LD_INT 5
106825: PUSH
106826: EMPTY
106827: LIST
106828: LIST
106829: LIST
106830: PUSH
106831: LD_VAR 0 1
106835: PUSH
106836: LD_VAR 0 2
106840: PUSH
106841: LD_INT 4
106843: PLUS
106844: PUSH
106845: LD_INT 0
106847: PUSH
106848: EMPTY
106849: LIST
106850: LIST
106851: LIST
106852: PUSH
106853: EMPTY
106854: LIST
106855: LIST
106856: LIST
106857: LIST
106858: LIST
106859: ST_TO_ADDR
// end ; 1 :
106860: GO 107560
106862: LD_INT 1
106864: DOUBLE
106865: EQUAL
106866: IFTRUE 106870
106868: GO 107003
106870: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
106871: LD_ADDR_VAR 0 5
106875: PUSH
106876: LD_VAR 0 1
106880: PUSH
106881: LD_VAR 0 2
106885: PUSH
106886: LD_INT 4
106888: MINUS
106889: PUSH
106890: LD_INT 3
106892: PUSH
106893: EMPTY
106894: LIST
106895: LIST
106896: LIST
106897: PUSH
106898: LD_VAR 0 1
106902: PUSH
106903: LD_INT 3
106905: MINUS
106906: PUSH
106907: LD_VAR 0 2
106911: PUSH
106912: LD_INT 3
106914: MINUS
106915: PUSH
106916: LD_INT 2
106918: PUSH
106919: EMPTY
106920: LIST
106921: LIST
106922: LIST
106923: PUSH
106924: LD_VAR 0 1
106928: PUSH
106929: LD_INT 4
106931: MINUS
106932: PUSH
106933: LD_VAR 0 2
106937: PUSH
106938: LD_INT 1
106940: PUSH
106941: EMPTY
106942: LIST
106943: LIST
106944: LIST
106945: PUSH
106946: LD_VAR 0 1
106950: PUSH
106951: LD_VAR 0 2
106955: PUSH
106956: LD_INT 3
106958: PLUS
106959: PUSH
106960: LD_INT 0
106962: PUSH
106963: EMPTY
106964: LIST
106965: LIST
106966: LIST
106967: PUSH
106968: LD_VAR 0 1
106972: PUSH
106973: LD_INT 4
106975: PLUS
106976: PUSH
106977: LD_VAR 0 2
106981: PUSH
106982: LD_INT 4
106984: PLUS
106985: PUSH
106986: LD_INT 5
106988: PUSH
106989: EMPTY
106990: LIST
106991: LIST
106992: LIST
106993: PUSH
106994: EMPTY
106995: LIST
106996: LIST
106997: LIST
106998: LIST
106999: LIST
107000: ST_TO_ADDR
// end ; 2 :
107001: GO 107560
107003: LD_INT 2
107005: DOUBLE
107006: EQUAL
107007: IFTRUE 107011
107009: GO 107140
107011: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
107012: LD_ADDR_VAR 0 5
107016: PUSH
107017: LD_VAR 0 1
107021: PUSH
107022: LD_VAR 0 2
107026: PUSH
107027: LD_INT 3
107029: MINUS
107030: PUSH
107031: LD_INT 3
107033: PUSH
107034: EMPTY
107035: LIST
107036: LIST
107037: LIST
107038: PUSH
107039: LD_VAR 0 1
107043: PUSH
107044: LD_INT 4
107046: PLUS
107047: PUSH
107048: LD_VAR 0 2
107052: PUSH
107053: LD_INT 4
107055: PUSH
107056: EMPTY
107057: LIST
107058: LIST
107059: LIST
107060: PUSH
107061: LD_VAR 0 1
107065: PUSH
107066: LD_VAR 0 2
107070: PUSH
107071: LD_INT 4
107073: PLUS
107074: PUSH
107075: LD_INT 0
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: LIST
107082: PUSH
107083: LD_VAR 0 1
107087: PUSH
107088: LD_INT 3
107090: MINUS
107091: PUSH
107092: LD_VAR 0 2
107096: PUSH
107097: LD_INT 1
107099: PUSH
107100: EMPTY
107101: LIST
107102: LIST
107103: LIST
107104: PUSH
107105: LD_VAR 0 1
107109: PUSH
107110: LD_INT 4
107112: MINUS
107113: PUSH
107114: LD_VAR 0 2
107118: PUSH
107119: LD_INT 4
107121: MINUS
107122: PUSH
107123: LD_INT 2
107125: PUSH
107126: EMPTY
107127: LIST
107128: LIST
107129: LIST
107130: PUSH
107131: EMPTY
107132: LIST
107133: LIST
107134: LIST
107135: LIST
107136: LIST
107137: ST_TO_ADDR
// end ; 3 :
107138: GO 107560
107140: LD_INT 3
107142: DOUBLE
107143: EQUAL
107144: IFTRUE 107148
107146: GO 107281
107148: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
107149: LD_ADDR_VAR 0 5
107153: PUSH
107154: LD_VAR 0 1
107158: PUSH
107159: LD_INT 3
107161: PLUS
107162: PUSH
107163: LD_VAR 0 2
107167: PUSH
107168: LD_INT 4
107170: PUSH
107171: EMPTY
107172: LIST
107173: LIST
107174: LIST
107175: PUSH
107176: LD_VAR 0 1
107180: PUSH
107181: LD_INT 4
107183: PLUS
107184: PUSH
107185: LD_VAR 0 2
107189: PUSH
107190: LD_INT 4
107192: PLUS
107193: PUSH
107194: LD_INT 5
107196: PUSH
107197: EMPTY
107198: LIST
107199: LIST
107200: LIST
107201: PUSH
107202: LD_VAR 0 1
107206: PUSH
107207: LD_INT 4
107209: MINUS
107210: PUSH
107211: LD_VAR 0 2
107215: PUSH
107216: LD_INT 1
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: LIST
107223: PUSH
107224: LD_VAR 0 1
107228: PUSH
107229: LD_VAR 0 2
107233: PUSH
107234: LD_INT 4
107236: MINUS
107237: PUSH
107238: LD_INT 3
107240: PUSH
107241: EMPTY
107242: LIST
107243: LIST
107244: LIST
107245: PUSH
107246: LD_VAR 0 1
107250: PUSH
107251: LD_INT 3
107253: MINUS
107254: PUSH
107255: LD_VAR 0 2
107259: PUSH
107260: LD_INT 3
107262: MINUS
107263: PUSH
107264: LD_INT 2
107266: PUSH
107267: EMPTY
107268: LIST
107269: LIST
107270: LIST
107271: PUSH
107272: EMPTY
107273: LIST
107274: LIST
107275: LIST
107276: LIST
107277: LIST
107278: ST_TO_ADDR
// end ; 4 :
107279: GO 107560
107281: LD_INT 4
107283: DOUBLE
107284: EQUAL
107285: IFTRUE 107289
107287: GO 107422
107289: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
107290: LD_ADDR_VAR 0 5
107294: PUSH
107295: LD_VAR 0 1
107299: PUSH
107300: LD_VAR 0 2
107304: PUSH
107305: LD_INT 4
107307: PLUS
107308: PUSH
107309: LD_INT 0
107311: PUSH
107312: EMPTY
107313: LIST
107314: LIST
107315: LIST
107316: PUSH
107317: LD_VAR 0 1
107321: PUSH
107322: LD_INT 3
107324: PLUS
107325: PUSH
107326: LD_VAR 0 2
107330: PUSH
107331: LD_INT 3
107333: PLUS
107334: PUSH
107335: LD_INT 5
107337: PUSH
107338: EMPTY
107339: LIST
107340: LIST
107341: LIST
107342: PUSH
107343: LD_VAR 0 1
107347: PUSH
107348: LD_INT 4
107350: PLUS
107351: PUSH
107352: LD_VAR 0 2
107356: PUSH
107357: LD_INT 4
107359: PUSH
107360: EMPTY
107361: LIST
107362: LIST
107363: LIST
107364: PUSH
107365: LD_VAR 0 1
107369: PUSH
107370: LD_VAR 0 2
107374: PUSH
107375: LD_INT 3
107377: MINUS
107378: PUSH
107379: LD_INT 3
107381: PUSH
107382: EMPTY
107383: LIST
107384: LIST
107385: LIST
107386: PUSH
107387: LD_VAR 0 1
107391: PUSH
107392: LD_INT 4
107394: MINUS
107395: PUSH
107396: LD_VAR 0 2
107400: PUSH
107401: LD_INT 4
107403: MINUS
107404: PUSH
107405: LD_INT 2
107407: PUSH
107408: EMPTY
107409: LIST
107410: LIST
107411: LIST
107412: PUSH
107413: EMPTY
107414: LIST
107415: LIST
107416: LIST
107417: LIST
107418: LIST
107419: ST_TO_ADDR
// end ; 5 :
107420: GO 107560
107422: LD_INT 5
107424: DOUBLE
107425: EQUAL
107426: IFTRUE 107430
107428: GO 107559
107430: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
107431: LD_ADDR_VAR 0 5
107435: PUSH
107436: LD_VAR 0 1
107440: PUSH
107441: LD_INT 4
107443: MINUS
107444: PUSH
107445: LD_VAR 0 2
107449: PUSH
107450: LD_INT 1
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: LIST
107457: PUSH
107458: LD_VAR 0 1
107462: PUSH
107463: LD_VAR 0 2
107467: PUSH
107468: LD_INT 4
107470: MINUS
107471: PUSH
107472: LD_INT 3
107474: PUSH
107475: EMPTY
107476: LIST
107477: LIST
107478: LIST
107479: PUSH
107480: LD_VAR 0 1
107484: PUSH
107485: LD_INT 4
107487: PLUS
107488: PUSH
107489: LD_VAR 0 2
107493: PUSH
107494: LD_INT 4
107496: PLUS
107497: PUSH
107498: LD_INT 5
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: LIST
107505: PUSH
107506: LD_VAR 0 1
107510: PUSH
107511: LD_INT 3
107513: PLUS
107514: PUSH
107515: LD_VAR 0 2
107519: PUSH
107520: LD_INT 4
107522: PUSH
107523: EMPTY
107524: LIST
107525: LIST
107526: LIST
107527: PUSH
107528: LD_VAR 0 1
107532: PUSH
107533: LD_VAR 0 2
107537: PUSH
107538: LD_INT 3
107540: PLUS
107541: PUSH
107542: LD_INT 0
107544: PUSH
107545: EMPTY
107546: LIST
107547: LIST
107548: LIST
107549: PUSH
107550: EMPTY
107551: LIST
107552: LIST
107553: LIST
107554: LIST
107555: LIST
107556: ST_TO_ADDR
// end ; end ;
107557: GO 107560
107559: POP
// result := list ;
107560: LD_ADDR_VAR 0 4
107564: PUSH
107565: LD_VAR 0 5
107569: ST_TO_ADDR
// end ;
107570: LD_VAR 0 4
107574: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
107575: LD_INT 0
107577: PPUSH
107578: PPUSH
107579: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
107580: LD_VAR 0 1
107584: NOT
107585: IFTRUE 107613
107587: PUSH
107588: LD_VAR 0 2
107592: PUSH
107593: LD_INT 1
107595: PUSH
107596: LD_INT 2
107598: PUSH
107599: LD_INT 3
107601: PUSH
107602: LD_INT 4
107604: PUSH
107605: EMPTY
107606: LIST
107607: LIST
107608: LIST
107609: LIST
107610: IN
107611: NOT
107612: OR
107613: IFFALSE 107617
// exit ;
107615: GO 107700
// tmp := [ ] ;
107617: LD_ADDR_VAR 0 5
107621: PUSH
107622: EMPTY
107623: ST_TO_ADDR
// for i in units do
107624: LD_ADDR_VAR 0 4
107628: PUSH
107629: LD_VAR 0 1
107633: PUSH
107634: FOR_IN
107635: IFFALSE 107669
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
107637: LD_ADDR_VAR 0 5
107641: PUSH
107642: LD_VAR 0 5
107646: PPUSH
107647: LD_VAR 0 4
107651: PPUSH
107652: LD_VAR 0 2
107656: PPUSH
107657: CALL_OW 259
107661: PPUSH
107662: CALL 109095 0 2
107666: ST_TO_ADDR
107667: GO 107634
107669: POP
107670: POP
// if not tmp then
107671: LD_VAR 0 5
107675: NOT
107676: IFFALSE 107680
// exit ;
107678: GO 107700
// result := SortListByListDesc ( units , tmp ) ;
107680: LD_ADDR_VAR 0 3
107684: PUSH
107685: LD_VAR 0 1
107689: PPUSH
107690: LD_VAR 0 5
107694: PPUSH
107695: CALL_OW 77
107699: ST_TO_ADDR
// end ;
107700: LD_VAR 0 3
107704: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
107705: LD_INT 0
107707: PPUSH
107708: PPUSH
107709: PPUSH
// result := false ;
107710: LD_ADDR_VAR 0 3
107714: PUSH
107715: LD_INT 0
107717: ST_TO_ADDR
// if not building then
107718: LD_VAR 0 2
107722: NOT
107723: IFFALSE 107727
// exit ;
107725: GO 107871
// x := GetX ( building ) ;
107727: LD_ADDR_VAR 0 4
107731: PUSH
107732: LD_VAR 0 2
107736: PPUSH
107737: CALL_OW 250
107741: ST_TO_ADDR
// y := GetY ( building ) ;
107742: LD_ADDR_VAR 0 5
107746: PUSH
107747: LD_VAR 0 2
107751: PPUSH
107752: CALL_OW 251
107756: ST_TO_ADDR
// if not x or not y then
107757: LD_VAR 0 4
107761: NOT
107762: IFTRUE 107771
107764: PUSH
107765: LD_VAR 0 5
107769: NOT
107770: OR
107771: IFFALSE 107775
// exit ;
107773: GO 107871
// if GetTaskList ( unit ) then
107775: LD_VAR 0 1
107779: PPUSH
107780: CALL_OW 437
107784: IFFALSE 107871
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107786: LD_STRING e
107788: PUSH
107789: LD_VAR 0 1
107793: PPUSH
107794: CALL_OW 437
107798: PUSH
107799: LD_INT 1
107801: ARRAY
107802: PUSH
107803: LD_INT 1
107805: ARRAY
107806: EQUAL
107807: IFFALSE 107834
107809: PUSH
107810: LD_VAR 0 4
107814: PUSH
107815: LD_VAR 0 1
107819: PPUSH
107820: CALL_OW 437
107824: PUSH
107825: LD_INT 1
107827: ARRAY
107828: PUSH
107829: LD_INT 2
107831: ARRAY
107832: EQUAL
107833: AND
107834: IFFALSE 107861
107836: PUSH
107837: LD_VAR 0 5
107841: PUSH
107842: LD_VAR 0 1
107846: PPUSH
107847: CALL_OW 437
107851: PUSH
107852: LD_INT 1
107854: ARRAY
107855: PUSH
107856: LD_INT 3
107858: ARRAY
107859: EQUAL
107860: AND
107861: IFFALSE 107871
// result := true end ;
107863: LD_ADDR_VAR 0 3
107867: PUSH
107868: LD_INT 1
107870: ST_TO_ADDR
// end ;
107871: LD_VAR 0 3
107875: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
107876: LD_INT 0
107878: PPUSH
// result := false ;
107879: LD_ADDR_VAR 0 4
107883: PUSH
107884: LD_INT 0
107886: ST_TO_ADDR
// if GetTaskList ( unit ) then
107887: LD_VAR 0 1
107891: PPUSH
107892: CALL_OW 437
107896: IFFALSE 107983
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107898: LD_STRING M
107900: PUSH
107901: LD_VAR 0 1
107905: PPUSH
107906: CALL_OW 437
107910: PUSH
107911: LD_INT 1
107913: ARRAY
107914: PUSH
107915: LD_INT 1
107917: ARRAY
107918: EQUAL
107919: IFFALSE 107946
107921: PUSH
107922: LD_VAR 0 2
107926: PUSH
107927: LD_VAR 0 1
107931: PPUSH
107932: CALL_OW 437
107936: PUSH
107937: LD_INT 1
107939: ARRAY
107940: PUSH
107941: LD_INT 2
107943: ARRAY
107944: EQUAL
107945: AND
107946: IFFALSE 107973
107948: PUSH
107949: LD_VAR 0 3
107953: PUSH
107954: LD_VAR 0 1
107958: PPUSH
107959: CALL_OW 437
107963: PUSH
107964: LD_INT 1
107966: ARRAY
107967: PUSH
107968: LD_INT 3
107970: ARRAY
107971: EQUAL
107972: AND
107973: IFFALSE 107983
// result := true ;
107975: LD_ADDR_VAR 0 4
107979: PUSH
107980: LD_INT 1
107982: ST_TO_ADDR
// end ; end ;
107983: LD_VAR 0 4
107987: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
107988: LD_INT 0
107990: PPUSH
107991: PPUSH
107992: PPUSH
107993: PPUSH
// if not unit or not area then
107994: LD_VAR 0 1
107998: NOT
107999: IFTRUE 108008
108001: PUSH
108002: LD_VAR 0 2
108006: NOT
108007: OR
108008: IFFALSE 108012
// exit ;
108010: GO 108188
// tmp := AreaToList ( area , i ) ;
108012: LD_ADDR_VAR 0 6
108016: PUSH
108017: LD_VAR 0 2
108021: PPUSH
108022: LD_VAR 0 5
108026: PPUSH
108027: CALL_OW 517
108031: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
108032: LD_ADDR_VAR 0 5
108036: PUSH
108037: DOUBLE
108038: LD_INT 1
108040: DEC
108041: ST_TO_ADDR
108042: LD_VAR 0 6
108046: PUSH
108047: LD_INT 1
108049: ARRAY
108050: PUSH
108051: FOR_TO
108052: IFFALSE 108186
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
108054: LD_ADDR_VAR 0 7
108058: PUSH
108059: LD_VAR 0 6
108063: PUSH
108064: LD_INT 1
108066: ARRAY
108067: PUSH
108068: LD_VAR 0 5
108072: ARRAY
108073: PUSH
108074: LD_VAR 0 6
108078: PUSH
108079: LD_INT 2
108081: ARRAY
108082: PUSH
108083: LD_VAR 0 5
108087: ARRAY
108088: PUSH
108089: EMPTY
108090: LIST
108091: LIST
108092: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
108093: LD_INT 92
108095: PUSH
108096: LD_VAR 0 7
108100: PUSH
108101: LD_INT 1
108103: ARRAY
108104: PUSH
108105: LD_VAR 0 7
108109: PUSH
108110: LD_INT 2
108112: ARRAY
108113: PUSH
108114: LD_INT 2
108116: PUSH
108117: EMPTY
108118: LIST
108119: LIST
108120: LIST
108121: LIST
108122: PPUSH
108123: CALL_OW 69
108127: PUSH
108128: LD_INT 0
108130: EQUAL
108131: IFFALSE 108184
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
108133: LD_VAR 0 1
108137: PPUSH
108138: LD_VAR 0 7
108142: PUSH
108143: LD_INT 1
108145: ARRAY
108146: PPUSH
108147: LD_VAR 0 7
108151: PUSH
108152: LD_INT 2
108154: ARRAY
108155: PPUSH
108156: LD_VAR 0 3
108160: PPUSH
108161: CALL_OW 48
// result := IsPlaced ( unit ) ;
108165: LD_ADDR_VAR 0 4
108169: PUSH
108170: LD_VAR 0 1
108174: PPUSH
108175: CALL_OW 305
108179: ST_TO_ADDR
// exit ;
108180: POP
108181: POP
108182: GO 108188
// end ; end ;
108184: GO 108051
108186: POP
108187: POP
// end ;
108188: LD_VAR 0 4
108192: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
108193: LD_INT 0
108195: PPUSH
108196: PPUSH
108197: PPUSH
// if not side or side > 8 then
108198: LD_VAR 0 1
108202: NOT
108203: IFTRUE 108215
108205: PUSH
108206: LD_VAR 0 1
108210: PUSH
108211: LD_INT 8
108213: GREATER
108214: OR
108215: IFFALSE 108219
// exit ;
108217: GO 108406
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
108219: LD_ADDR_VAR 0 4
108223: PUSH
108224: LD_INT 22
108226: PUSH
108227: LD_VAR 0 1
108231: PUSH
108232: EMPTY
108233: LIST
108234: LIST
108235: PUSH
108236: LD_INT 21
108238: PUSH
108239: LD_INT 3
108241: PUSH
108242: EMPTY
108243: LIST
108244: LIST
108245: PUSH
108246: EMPTY
108247: LIST
108248: LIST
108249: PPUSH
108250: CALL_OW 69
108254: ST_TO_ADDR
// if not tmp then
108255: LD_VAR 0 4
108259: NOT
108260: IFFALSE 108264
// exit ;
108262: GO 108406
// enable_addtolog := true ;
108264: LD_ADDR_OWVAR 81
108268: PUSH
108269: LD_INT 1
108271: ST_TO_ADDR
// AddToLog ( [ ) ;
108272: LD_STRING [
108274: PPUSH
108275: CALL_OW 561
// for i in tmp do
108279: LD_ADDR_VAR 0 3
108283: PUSH
108284: LD_VAR 0 4
108288: PUSH
108289: FOR_IN
108290: IFFALSE 108397
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
108292: LD_STRING [
108294: PUSH
108295: LD_VAR 0 3
108299: PPUSH
108300: CALL_OW 266
108304: STR
108305: PUSH
108306: LD_STRING , 
108308: STR
108309: PUSH
108310: LD_VAR 0 3
108314: PPUSH
108315: CALL_OW 250
108319: STR
108320: PUSH
108321: LD_STRING , 
108323: STR
108324: PUSH
108325: LD_VAR 0 3
108329: PPUSH
108330: CALL_OW 251
108334: STR
108335: PUSH
108336: LD_STRING , 
108338: STR
108339: PUSH
108340: LD_VAR 0 3
108344: PPUSH
108345: CALL_OW 254
108349: STR
108350: PUSH
108351: LD_STRING , 
108353: STR
108354: PUSH
108355: LD_VAR 0 3
108359: PPUSH
108360: LD_INT 1
108362: PPUSH
108363: CALL_OW 268
108367: STR
108368: PUSH
108369: LD_STRING , 
108371: STR
108372: PUSH
108373: LD_VAR 0 3
108377: PPUSH
108378: LD_INT 2
108380: PPUSH
108381: CALL_OW 268
108385: STR
108386: PUSH
108387: LD_STRING ],
108389: STR
108390: PPUSH
108391: CALL_OW 561
// end ;
108395: GO 108289
108397: POP
108398: POP
// AddToLog ( ]; ) ;
108399: LD_STRING ];
108401: PPUSH
108402: CALL_OW 561
// end ;
108406: LD_VAR 0 2
108410: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
108411: LD_INT 0
108413: PPUSH
108414: PPUSH
108415: PPUSH
108416: PPUSH
108417: PPUSH
// if not area or not rate or not max then
108418: LD_VAR 0 1
108422: NOT
108423: IFTRUE 108432
108425: PUSH
108426: LD_VAR 0 2
108430: NOT
108431: OR
108432: IFTRUE 108441
108434: PUSH
108435: LD_VAR 0 4
108439: NOT
108440: OR
108441: IFFALSE 108445
// exit ;
108443: GO 108634
// while 1 do
108445: LD_INT 1
108447: IFFALSE 108634
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
108449: LD_ADDR_VAR 0 9
108453: PUSH
108454: LD_VAR 0 1
108458: PPUSH
108459: LD_INT 1
108461: PPUSH
108462: CALL_OW 287
108466: PUSH
108467: LD_INT 10
108469: MUL
108470: ST_TO_ADDR
// r := rate / 10 ;
108471: LD_ADDR_VAR 0 7
108475: PUSH
108476: LD_VAR 0 2
108480: PUSH
108481: LD_INT 10
108483: DIVREAL
108484: ST_TO_ADDR
// time := 1 1$00 ;
108485: LD_ADDR_VAR 0 8
108489: PUSH
108490: LD_INT 2100
108492: ST_TO_ADDR
// if amount < min then
108493: LD_VAR 0 9
108497: PUSH
108498: LD_VAR 0 3
108502: LESS
108503: IFFALSE 108521
// r := r * 2 else
108505: LD_ADDR_VAR 0 7
108509: PUSH
108510: LD_VAR 0 7
108514: PUSH
108515: LD_INT 2
108517: MUL
108518: ST_TO_ADDR
108519: GO 108547
// if amount > max then
108521: LD_VAR 0 9
108525: PUSH
108526: LD_VAR 0 4
108530: GREATER
108531: IFFALSE 108547
// r := r / 2 ;
108533: LD_ADDR_VAR 0 7
108537: PUSH
108538: LD_VAR 0 7
108542: PUSH
108543: LD_INT 2
108545: DIVREAL
108546: ST_TO_ADDR
// time := time / r ;
108547: LD_ADDR_VAR 0 8
108551: PUSH
108552: LD_VAR 0 8
108556: PUSH
108557: LD_VAR 0 7
108561: DIVREAL
108562: ST_TO_ADDR
// if time < 0 then
108563: LD_VAR 0 8
108567: PUSH
108568: LD_INT 0
108570: LESS
108571: IFFALSE 108588
// time := time * - 1 ;
108573: LD_ADDR_VAR 0 8
108577: PUSH
108578: LD_VAR 0 8
108582: PUSH
108583: LD_INT 1
108585: NEG
108586: MUL
108587: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
108588: LD_VAR 0 8
108592: PUSH
108593: LD_INT 35
108595: PPUSH
108596: LD_INT 875
108598: PPUSH
108599: CALL_OW 12
108603: PLUS
108604: PPUSH
108605: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
108609: LD_INT 1
108611: PPUSH
108612: LD_INT 5
108614: PPUSH
108615: CALL_OW 12
108619: PPUSH
108620: LD_VAR 0 1
108624: PPUSH
108625: LD_INT 1
108627: PPUSH
108628: CALL_OW 55
// end ;
108632: GO 108445
// end ;
108634: LD_VAR 0 5
108638: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
108639: LD_INT 0
108641: PPUSH
108642: PPUSH
108643: PPUSH
108644: PPUSH
108645: PPUSH
108646: PPUSH
108647: PPUSH
108648: PPUSH
// if not turrets or not factories then
108649: LD_VAR 0 1
108653: NOT
108654: IFTRUE 108663
108656: PUSH
108657: LD_VAR 0 2
108661: NOT
108662: OR
108663: IFFALSE 108667
// exit ;
108665: GO 108974
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
108667: LD_ADDR_VAR 0 10
108671: PUSH
108672: LD_INT 5
108674: PUSH
108675: LD_INT 6
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: PUSH
108682: LD_INT 2
108684: PUSH
108685: LD_INT 4
108687: PUSH
108688: EMPTY
108689: LIST
108690: LIST
108691: PUSH
108692: LD_INT 3
108694: PUSH
108695: LD_INT 5
108697: PUSH
108698: EMPTY
108699: LIST
108700: LIST
108701: PUSH
108702: EMPTY
108703: LIST
108704: LIST
108705: LIST
108706: PUSH
108707: LD_INT 24
108709: PUSH
108710: LD_INT 25
108712: PUSH
108713: EMPTY
108714: LIST
108715: LIST
108716: PUSH
108717: LD_INT 23
108719: PUSH
108720: LD_INT 27
108722: PUSH
108723: EMPTY
108724: LIST
108725: LIST
108726: PUSH
108727: EMPTY
108728: LIST
108729: LIST
108730: PUSH
108731: LD_INT 42
108733: PUSH
108734: LD_INT 43
108736: PUSH
108737: EMPTY
108738: LIST
108739: LIST
108740: PUSH
108741: LD_INT 44
108743: PUSH
108744: LD_INT 46
108746: PUSH
108747: EMPTY
108748: LIST
108749: LIST
108750: PUSH
108751: LD_INT 45
108753: PUSH
108754: LD_INT 47
108756: PUSH
108757: EMPTY
108758: LIST
108759: LIST
108760: PUSH
108761: EMPTY
108762: LIST
108763: LIST
108764: LIST
108765: PUSH
108766: EMPTY
108767: LIST
108768: LIST
108769: LIST
108770: ST_TO_ADDR
// result := [ ] ;
108771: LD_ADDR_VAR 0 3
108775: PUSH
108776: EMPTY
108777: ST_TO_ADDR
// for i in turrets do
108778: LD_ADDR_VAR 0 4
108782: PUSH
108783: LD_VAR 0 1
108787: PUSH
108788: FOR_IN
108789: IFFALSE 108972
// begin nat := GetNation ( i ) ;
108791: LD_ADDR_VAR 0 7
108795: PUSH
108796: LD_VAR 0 4
108800: PPUSH
108801: CALL_OW 248
108805: ST_TO_ADDR
// weapon := 0 ;
108806: LD_ADDR_VAR 0 8
108810: PUSH
108811: LD_INT 0
108813: ST_TO_ADDR
// if not nat then
108814: LD_VAR 0 7
108818: NOT
108819: IFFALSE 108823
// continue ;
108821: GO 108788
// for j in list [ nat ] do
108823: LD_ADDR_VAR 0 5
108827: PUSH
108828: LD_VAR 0 10
108832: PUSH
108833: LD_VAR 0 7
108837: ARRAY
108838: PUSH
108839: FOR_IN
108840: IFFALSE 108881
// if GetBWeapon ( i ) = j [ 1 ] then
108842: LD_VAR 0 4
108846: PPUSH
108847: CALL_OW 269
108851: PUSH
108852: LD_VAR 0 5
108856: PUSH
108857: LD_INT 1
108859: ARRAY
108860: EQUAL
108861: IFFALSE 108879
// begin weapon := j [ 2 ] ;
108863: LD_ADDR_VAR 0 8
108867: PUSH
108868: LD_VAR 0 5
108872: PUSH
108873: LD_INT 2
108875: ARRAY
108876: ST_TO_ADDR
// break ;
108877: GO 108881
// end ;
108879: GO 108839
108881: POP
108882: POP
// if not weapon then
108883: LD_VAR 0 8
108887: NOT
108888: IFFALSE 108892
// continue ;
108890: GO 108788
// for k in factories do
108892: LD_ADDR_VAR 0 6
108896: PUSH
108897: LD_VAR 0 2
108901: PUSH
108902: FOR_IN
108903: IFFALSE 108968
// begin weapons := AvailableWeaponList ( k ) ;
108905: LD_ADDR_VAR 0 9
108909: PUSH
108910: LD_VAR 0 6
108914: PPUSH
108915: CALL_OW 478
108919: ST_TO_ADDR
// if not weapons then
108920: LD_VAR 0 9
108924: NOT
108925: IFFALSE 108929
// continue ;
108927: GO 108902
// if weapon in weapons then
108929: LD_VAR 0 8
108933: PUSH
108934: LD_VAR 0 9
108938: IN
108939: IFFALSE 108966
// begin result := [ i , weapon ] ;
108941: LD_ADDR_VAR 0 3
108945: PUSH
108946: LD_VAR 0 4
108950: PUSH
108951: LD_VAR 0 8
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: ST_TO_ADDR
// exit ;
108960: POP
108961: POP
108962: POP
108963: POP
108964: GO 108974
// end ; end ;
108966: GO 108902
108968: POP
108969: POP
// end ;
108970: GO 108788
108972: POP
108973: POP
// end ;
108974: LD_VAR 0 3
108978: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
108979: LD_INT 0
108981: PPUSH
// if not side or side > 8 then
108982: LD_VAR 0 3
108986: NOT
108987: IFTRUE 108999
108989: PUSH
108990: LD_VAR 0 3
108994: PUSH
108995: LD_INT 8
108997: GREATER
108998: OR
108999: IFFALSE 109003
// exit ;
109001: GO 109062
// if not range then
109003: LD_VAR 0 4
109007: NOT
109008: IFFALSE 109019
// range := - 12 ;
109010: LD_ADDR_VAR 0 4
109014: PUSH
109015: LD_INT 12
109017: NEG
109018: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
109019: LD_VAR 0 1
109023: PPUSH
109024: LD_VAR 0 2
109028: PPUSH
109029: LD_VAR 0 3
109033: PPUSH
109034: LD_VAR 0 4
109038: PPUSH
109039: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
109043: LD_VAR 0 1
109047: PPUSH
109048: LD_VAR 0 2
109052: PPUSH
109053: LD_VAR 0 3
109057: PPUSH
109058: CALL_OW 331
// end ;
109062: LD_VAR 0 5
109066: RET
// export function Video ( mode ) ; begin
109067: LD_INT 0
109069: PPUSH
// ingame_video = mode ;
109070: LD_ADDR_OWVAR 52
109074: PUSH
109075: LD_VAR 0 1
109079: ST_TO_ADDR
// interface_hidden = mode ;
109080: LD_ADDR_OWVAR 54
109084: PUSH
109085: LD_VAR 0 1
109089: ST_TO_ADDR
// end ;
109090: LD_VAR 0 2
109094: RET
// export function Join ( array , element ) ; begin
109095: LD_INT 0
109097: PPUSH
// result := Replace ( array , array + 1 , element ) ;
109098: LD_ADDR_VAR 0 3
109102: PUSH
109103: LD_VAR 0 1
109107: PPUSH
109108: LD_VAR 0 1
109112: PUSH
109113: LD_INT 1
109115: PLUS
109116: PPUSH
109117: LD_VAR 0 2
109121: PPUSH
109122: CALL_OW 1
109126: ST_TO_ADDR
// end ;
109127: LD_VAR 0 3
109131: RET
// export function JoinUnion ( array , element ) ; begin
109132: LD_INT 0
109134: PPUSH
// result := array union element ;
109135: LD_ADDR_VAR 0 3
109139: PUSH
109140: LD_VAR 0 1
109144: PUSH
109145: LD_VAR 0 2
109149: UNION
109150: ST_TO_ADDR
// end ;
109151: LD_VAR 0 3
109155: RET
// export function GetBehemoths ( side ) ; begin
109156: LD_INT 0
109158: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
109159: LD_ADDR_VAR 0 2
109163: PUSH
109164: LD_INT 22
109166: PUSH
109167: LD_VAR 0 1
109171: PUSH
109172: EMPTY
109173: LIST
109174: LIST
109175: PUSH
109176: LD_INT 31
109178: PUSH
109179: LD_INT 25
109181: PUSH
109182: EMPTY
109183: LIST
109184: LIST
109185: PUSH
109186: EMPTY
109187: LIST
109188: LIST
109189: PPUSH
109190: CALL_OW 69
109194: ST_TO_ADDR
// end ;
109195: LD_VAR 0 2
109199: RET
// export function Shuffle ( array ) ; var i , index ; begin
109200: LD_INT 0
109202: PPUSH
109203: PPUSH
109204: PPUSH
// result := [ ] ;
109205: LD_ADDR_VAR 0 2
109209: PUSH
109210: EMPTY
109211: ST_TO_ADDR
// if not array then
109212: LD_VAR 0 1
109216: NOT
109217: IFFALSE 109221
// exit ;
109219: GO 109320
// Randomize ;
109221: CALL_OW 10
// for i = array downto 1 do
109225: LD_ADDR_VAR 0 3
109229: PUSH
109230: DOUBLE
109231: LD_VAR 0 1
109235: INC
109236: ST_TO_ADDR
109237: LD_INT 1
109239: PUSH
109240: FOR_DOWNTO
109241: IFFALSE 109318
// begin index := rand ( 1 , array ) ;
109243: LD_ADDR_VAR 0 4
109247: PUSH
109248: LD_INT 1
109250: PPUSH
109251: LD_VAR 0 1
109255: PPUSH
109256: CALL_OW 12
109260: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
109261: LD_ADDR_VAR 0 2
109265: PUSH
109266: LD_VAR 0 2
109270: PPUSH
109271: LD_VAR 0 2
109275: PUSH
109276: LD_INT 1
109278: PLUS
109279: PPUSH
109280: LD_VAR 0 1
109284: PUSH
109285: LD_VAR 0 4
109289: ARRAY
109290: PPUSH
109291: CALL_OW 2
109295: ST_TO_ADDR
// array := Delete ( array , index ) ;
109296: LD_ADDR_VAR 0 1
109300: PUSH
109301: LD_VAR 0 1
109305: PPUSH
109306: LD_VAR 0 4
109310: PPUSH
109311: CALL_OW 3
109315: ST_TO_ADDR
// end ;
109316: GO 109240
109318: POP
109319: POP
// end ;
109320: LD_VAR 0 2
109324: RET
// export function GetBaseMaterials ( base ) ; begin
109325: LD_INT 0
109327: PPUSH
// result := [ 0 , 0 , 0 ] ;
109328: LD_ADDR_VAR 0 2
109332: PUSH
109333: LD_INT 0
109335: PUSH
109336: LD_INT 0
109338: PUSH
109339: LD_INT 0
109341: PUSH
109342: EMPTY
109343: LIST
109344: LIST
109345: LIST
109346: ST_TO_ADDR
// if not base then
109347: LD_VAR 0 1
109351: NOT
109352: IFFALSE 109356
// exit ;
109354: GO 109405
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
109356: LD_ADDR_VAR 0 2
109360: PUSH
109361: LD_VAR 0 1
109365: PPUSH
109366: LD_INT 1
109368: PPUSH
109369: CALL_OW 275
109373: PUSH
109374: LD_VAR 0 1
109378: PPUSH
109379: LD_INT 2
109381: PPUSH
109382: CALL_OW 275
109386: PUSH
109387: LD_VAR 0 1
109391: PPUSH
109392: LD_INT 3
109394: PPUSH
109395: CALL_OW 275
109399: PUSH
109400: EMPTY
109401: LIST
109402: LIST
109403: LIST
109404: ST_TO_ADDR
// end ;
109405: LD_VAR 0 2
109409: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
109410: LD_INT 0
109412: PPUSH
109413: PPUSH
// result := array ;
109414: LD_ADDR_VAR 0 3
109418: PUSH
109419: LD_VAR 0 1
109423: ST_TO_ADDR
// if size >= result then
109424: LD_VAR 0 2
109428: PUSH
109429: LD_VAR 0 3
109433: GREATEREQUAL
109434: IFFALSE 109438
// exit ;
109436: GO 109488
// if size then
109438: LD_VAR 0 2
109442: IFFALSE 109488
// for i := array downto size do
109444: LD_ADDR_VAR 0 4
109448: PUSH
109449: DOUBLE
109450: LD_VAR 0 1
109454: INC
109455: ST_TO_ADDR
109456: LD_VAR 0 2
109460: PUSH
109461: FOR_DOWNTO
109462: IFFALSE 109486
// result := Delete ( result , result ) ;
109464: LD_ADDR_VAR 0 3
109468: PUSH
109469: LD_VAR 0 3
109473: PPUSH
109474: LD_VAR 0 3
109478: PPUSH
109479: CALL_OW 3
109483: ST_TO_ADDR
109484: GO 109461
109486: POP
109487: POP
// end ;
109488: LD_VAR 0 3
109492: RET
// export function ComExit ( unit ) ; var tmp ; begin
109493: LD_INT 0
109495: PPUSH
109496: PPUSH
// if not IsInUnit ( unit ) then
109497: LD_VAR 0 1
109501: PPUSH
109502: CALL_OW 310
109506: NOT
109507: IFFALSE 109511
// exit ;
109509: GO 109571
// tmp := IsInUnit ( unit ) ;
109511: LD_ADDR_VAR 0 3
109515: PUSH
109516: LD_VAR 0 1
109520: PPUSH
109521: CALL_OW 310
109525: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
109526: LD_VAR 0 3
109530: PPUSH
109531: CALL_OW 247
109535: PUSH
109536: LD_INT 2
109538: EQUAL
109539: IFFALSE 109552
// ComExitVehicle ( unit ) else
109541: LD_VAR 0 1
109545: PPUSH
109546: CALL_OW 121
109550: GO 109561
// ComExitBuilding ( unit ) ;
109552: LD_VAR 0 1
109556: PPUSH
109557: CALL_OW 122
// result := tmp ;
109561: LD_ADDR_VAR 0 2
109565: PUSH
109566: LD_VAR 0 3
109570: ST_TO_ADDR
// end ;
109571: LD_VAR 0 2
109575: RET
// export function ComExitAll ( units ) ; var i ; begin
109576: LD_INT 0
109578: PPUSH
109579: PPUSH
// if not units then
109580: LD_VAR 0 1
109584: NOT
109585: IFFALSE 109589
// exit ;
109587: GO 109615
// for i in units do
109589: LD_ADDR_VAR 0 3
109593: PUSH
109594: LD_VAR 0 1
109598: PUSH
109599: FOR_IN
109600: IFFALSE 109613
// ComExit ( i ) ;
109602: LD_VAR 0 3
109606: PPUSH
109607: CALL 109493 0 1
109611: GO 109599
109613: POP
109614: POP
// end ;
109615: LD_VAR 0 2
109619: RET
// export function ResetHc ; begin
109620: LD_INT 0
109622: PPUSH
// InitHc ;
109623: CALL_OW 19
// hc_importance := 0 ;
109627: LD_ADDR_OWVAR 32
109631: PUSH
109632: LD_INT 0
109634: ST_TO_ADDR
// end ;
109635: LD_VAR 0 1
109639: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
109640: LD_INT 0
109642: PPUSH
109643: PPUSH
109644: PPUSH
// _x := ( x1 + x2 ) div 2 ;
109645: LD_ADDR_VAR 0 6
109649: PUSH
109650: LD_VAR 0 1
109654: PUSH
109655: LD_VAR 0 3
109659: PLUS
109660: PUSH
109661: LD_INT 2
109663: DIV
109664: ST_TO_ADDR
// if _x < 0 then
109665: LD_VAR 0 6
109669: PUSH
109670: LD_INT 0
109672: LESS
109673: IFFALSE 109690
// _x := _x * - 1 ;
109675: LD_ADDR_VAR 0 6
109679: PUSH
109680: LD_VAR 0 6
109684: PUSH
109685: LD_INT 1
109687: NEG
109688: MUL
109689: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
109690: LD_ADDR_VAR 0 7
109694: PUSH
109695: LD_VAR 0 2
109699: PUSH
109700: LD_VAR 0 4
109704: PLUS
109705: PUSH
109706: LD_INT 2
109708: DIV
109709: ST_TO_ADDR
// if _y < 0 then
109710: LD_VAR 0 7
109714: PUSH
109715: LD_INT 0
109717: LESS
109718: IFFALSE 109735
// _y := _y * - 1 ;
109720: LD_ADDR_VAR 0 7
109724: PUSH
109725: LD_VAR 0 7
109729: PUSH
109730: LD_INT 1
109732: NEG
109733: MUL
109734: ST_TO_ADDR
// result := [ _x , _y ] ;
109735: LD_ADDR_VAR 0 5
109739: PUSH
109740: LD_VAR 0 6
109744: PUSH
109745: LD_VAR 0 7
109749: PUSH
109750: EMPTY
109751: LIST
109752: LIST
109753: ST_TO_ADDR
// end ;
109754: LD_VAR 0 5
109758: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
109759: LD_INT 0
109761: PPUSH
109762: PPUSH
109763: PPUSH
109764: PPUSH
// task := GetTaskList ( unit ) ;
109765: LD_ADDR_VAR 0 7
109769: PUSH
109770: LD_VAR 0 1
109774: PPUSH
109775: CALL_OW 437
109779: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
109780: LD_VAR 0 7
109784: NOT
109785: IFFALSE 109804
109787: PUSH
109788: LD_VAR 0 1
109792: PPUSH
109793: LD_VAR 0 2
109797: PPUSH
109798: CALL_OW 308
109802: NOT
109803: AND
109804: IFFALSE 109808
// exit ;
109806: GO 109926
// if IsInArea ( unit , area ) then
109808: LD_VAR 0 1
109812: PPUSH
109813: LD_VAR 0 2
109817: PPUSH
109818: CALL_OW 308
109822: IFFALSE 109840
// begin ComMoveToArea ( unit , goAway ) ;
109824: LD_VAR 0 1
109828: PPUSH
109829: LD_VAR 0 3
109833: PPUSH
109834: CALL_OW 113
// exit ;
109838: GO 109926
// end ; if task [ 1 ] [ 1 ] <> M then
109840: LD_VAR 0 7
109844: PUSH
109845: LD_INT 1
109847: ARRAY
109848: PUSH
109849: LD_INT 1
109851: ARRAY
109852: PUSH
109853: LD_STRING M
109855: NONEQUAL
109856: IFFALSE 109860
// exit ;
109858: GO 109926
// x := task [ 1 ] [ 2 ] ;
109860: LD_ADDR_VAR 0 5
109864: PUSH
109865: LD_VAR 0 7
109869: PUSH
109870: LD_INT 1
109872: ARRAY
109873: PUSH
109874: LD_INT 2
109876: ARRAY
109877: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
109878: LD_ADDR_VAR 0 6
109882: PUSH
109883: LD_VAR 0 7
109887: PUSH
109888: LD_INT 1
109890: ARRAY
109891: PUSH
109892: LD_INT 3
109894: ARRAY
109895: ST_TO_ADDR
// if InArea ( x , y , area ) then
109896: LD_VAR 0 5
109900: PPUSH
109901: LD_VAR 0 6
109905: PPUSH
109906: LD_VAR 0 2
109910: PPUSH
109911: CALL_OW 309
109915: IFFALSE 109926
// ComStop ( unit ) ;
109917: LD_VAR 0 1
109921: PPUSH
109922: CALL_OW 141
// end ;
109926: LD_VAR 0 4
109930: RET
// export function Abs ( value ) ; begin
109931: LD_INT 0
109933: PPUSH
// result := value ;
109934: LD_ADDR_VAR 0 2
109938: PUSH
109939: LD_VAR 0 1
109943: ST_TO_ADDR
// if value < 0 then
109944: LD_VAR 0 1
109948: PUSH
109949: LD_INT 0
109951: LESS
109952: IFFALSE 109969
// result := value * - 1 ;
109954: LD_ADDR_VAR 0 2
109958: PUSH
109959: LD_VAR 0 1
109963: PUSH
109964: LD_INT 1
109966: NEG
109967: MUL
109968: ST_TO_ADDR
// end ;
109969: LD_VAR 0 2
109973: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
109974: LD_INT 0
109976: PPUSH
109977: PPUSH
109978: PPUSH
109979: PPUSH
109980: PPUSH
109981: PPUSH
109982: PPUSH
109983: PPUSH
// if not unit or not building then
109984: LD_VAR 0 1
109988: NOT
109989: IFTRUE 109998
109991: PUSH
109992: LD_VAR 0 2
109996: NOT
109997: OR
109998: IFFALSE 110002
// exit ;
110000: GO 110230
// x := GetX ( building ) ;
110002: LD_ADDR_VAR 0 4
110006: PUSH
110007: LD_VAR 0 2
110011: PPUSH
110012: CALL_OW 250
110016: ST_TO_ADDR
// y := GetY ( building ) ;
110017: LD_ADDR_VAR 0 6
110021: PUSH
110022: LD_VAR 0 2
110026: PPUSH
110027: CALL_OW 251
110031: ST_TO_ADDR
// d := GetDir ( building ) ;
110032: LD_ADDR_VAR 0 8
110036: PUSH
110037: LD_VAR 0 2
110041: PPUSH
110042: CALL_OW 254
110046: ST_TO_ADDR
// r := 4 ;
110047: LD_ADDR_VAR 0 9
110051: PUSH
110052: LD_INT 4
110054: ST_TO_ADDR
// for i := 1 to 5 do
110055: LD_ADDR_VAR 0 10
110059: PUSH
110060: DOUBLE
110061: LD_INT 1
110063: DEC
110064: ST_TO_ADDR
110065: LD_INT 5
110067: PUSH
110068: FOR_TO
110069: IFFALSE 110228
// begin _x := ShiftX ( x , d , r + i ) ;
110071: LD_ADDR_VAR 0 5
110075: PUSH
110076: LD_VAR 0 4
110080: PPUSH
110081: LD_VAR 0 8
110085: PPUSH
110086: LD_VAR 0 9
110090: PUSH
110091: LD_VAR 0 10
110095: PLUS
110096: PPUSH
110097: CALL_OW 272
110101: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
110102: LD_ADDR_VAR 0 7
110106: PUSH
110107: LD_VAR 0 6
110111: PPUSH
110112: LD_VAR 0 8
110116: PPUSH
110117: LD_VAR 0 9
110121: PUSH
110122: LD_VAR 0 10
110126: PLUS
110127: PPUSH
110128: CALL_OW 273
110132: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
110133: LD_VAR 0 5
110137: PPUSH
110138: LD_VAR 0 7
110142: PPUSH
110143: CALL_OW 488
110147: IFFALSE 110182
110149: PUSH
110150: LD_VAR 0 5
110154: PPUSH
110155: LD_VAR 0 7
110159: PPUSH
110160: CALL_OW 428
110164: PPUSH
110165: CALL_OW 247
110169: PUSH
110170: LD_INT 3
110172: PUSH
110173: LD_INT 2
110175: PUSH
110176: EMPTY
110177: LIST
110178: LIST
110179: IN
110180: NOT
110181: AND
110182: IFFALSE 110226
// begin ComMoveXY ( unit , _x , _y ) ;
110184: LD_VAR 0 1
110188: PPUSH
110189: LD_VAR 0 5
110193: PPUSH
110194: LD_VAR 0 7
110198: PPUSH
110199: CALL_OW 111
// result := [ _x , _y ] ;
110203: LD_ADDR_VAR 0 3
110207: PUSH
110208: LD_VAR 0 5
110212: PUSH
110213: LD_VAR 0 7
110217: PUSH
110218: EMPTY
110219: LIST
110220: LIST
110221: ST_TO_ADDR
// exit ;
110222: POP
110223: POP
110224: GO 110230
// end ; end ;
110226: GO 110068
110228: POP
110229: POP
// end ;
110230: LD_VAR 0 3
110234: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
110235: LD_INT 0
110237: PPUSH
110238: PPUSH
110239: PPUSH
// result := 0 ;
110240: LD_ADDR_VAR 0 3
110244: PUSH
110245: LD_INT 0
110247: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
110248: LD_VAR 0 1
110252: PUSH
110253: LD_INT 0
110255: LESS
110256: IFTRUE 110268
110258: PUSH
110259: LD_VAR 0 1
110263: PUSH
110264: LD_INT 8
110266: GREATER
110267: OR
110268: IFTRUE 110280
110270: PUSH
110271: LD_VAR 0 2
110275: PUSH
110276: LD_INT 0
110278: LESS
110279: OR
110280: IFTRUE 110292
110282: PUSH
110283: LD_VAR 0 2
110287: PUSH
110288: LD_INT 8
110290: GREATER
110291: OR
110292: IFFALSE 110296
// exit ;
110294: GO 110371
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
110296: LD_ADDR_VAR 0 4
110300: PUSH
110301: LD_INT 22
110303: PUSH
110304: LD_VAR 0 2
110308: PUSH
110309: EMPTY
110310: LIST
110311: LIST
110312: PPUSH
110313: CALL_OW 69
110317: PUSH
110318: FOR_IN
110319: IFFALSE 110369
// begin un := UnitShoot ( i ) ;
110321: LD_ADDR_VAR 0 5
110325: PUSH
110326: LD_VAR 0 4
110330: PPUSH
110331: CALL_OW 504
110335: ST_TO_ADDR
// if GetSide ( un ) = side1 then
110336: LD_VAR 0 5
110340: PPUSH
110341: CALL_OW 255
110345: PUSH
110346: LD_VAR 0 1
110350: EQUAL
110351: IFFALSE 110367
// begin result := un ;
110353: LD_ADDR_VAR 0 3
110357: PUSH
110358: LD_VAR 0 5
110362: ST_TO_ADDR
// exit ;
110363: POP
110364: POP
110365: GO 110371
// end ; end ;
110367: GO 110318
110369: POP
110370: POP
// end ;
110371: LD_VAR 0 3
110375: RET
// export function GetCargoBay ( units ) ; begin
110376: LD_INT 0
110378: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
110379: LD_ADDR_VAR 0 2
110383: PUSH
110384: LD_VAR 0 1
110388: PPUSH
110389: LD_INT 2
110391: PUSH
110392: LD_INT 34
110394: PUSH
110395: LD_INT 12
110397: PUSH
110398: EMPTY
110399: LIST
110400: LIST
110401: PUSH
110402: LD_INT 34
110404: PUSH
110405: LD_INT 51
110407: PUSH
110408: EMPTY
110409: LIST
110410: LIST
110411: PUSH
110412: LD_INT 34
110414: PUSH
110415: LD_INT 32
110417: PUSH
110418: EMPTY
110419: LIST
110420: LIST
110421: PUSH
110422: LD_INT 34
110424: PUSH
110425: LD_INT 89
110427: PUSH
110428: EMPTY
110429: LIST
110430: LIST
110431: PUSH
110432: EMPTY
110433: LIST
110434: LIST
110435: LIST
110436: LIST
110437: LIST
110438: PPUSH
110439: CALL_OW 72
110443: ST_TO_ADDR
// end ;
110444: LD_VAR 0 2
110448: RET
// export function Negate ( value ) ; begin
110449: LD_INT 0
110451: PPUSH
// result := not value ;
110452: LD_ADDR_VAR 0 2
110456: PUSH
110457: LD_VAR 0 1
110461: NOT
110462: ST_TO_ADDR
// end ;
110463: LD_VAR 0 2
110467: RET
// export function Inc ( value ) ; begin
110468: LD_INT 0
110470: PPUSH
// result := value + 1 ;
110471: LD_ADDR_VAR 0 2
110475: PUSH
110476: LD_VAR 0 1
110480: PUSH
110481: LD_INT 1
110483: PLUS
110484: ST_TO_ADDR
// end ;
110485: LD_VAR 0 2
110489: RET
// export function Dec ( value ) ; begin
110490: LD_INT 0
110492: PPUSH
// result := value - 1 ;
110493: LD_ADDR_VAR 0 2
110497: PUSH
110498: LD_VAR 0 1
110502: PUSH
110503: LD_INT 1
110505: MINUS
110506: ST_TO_ADDR
// end ;
110507: LD_VAR 0 2
110511: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
110512: LD_INT 0
110514: PPUSH
110515: PPUSH
110516: PPUSH
110517: PPUSH
110518: PPUSH
110519: PPUSH
110520: PPUSH
110521: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
110522: LD_VAR 0 1
110526: PPUSH
110527: LD_VAR 0 2
110531: PPUSH
110532: CALL_OW 488
110536: NOT
110537: IFTRUE 110556
110539: PUSH
110540: LD_VAR 0 3
110544: PPUSH
110545: LD_VAR 0 4
110549: PPUSH
110550: CALL_OW 488
110554: NOT
110555: OR
110556: IFFALSE 110569
// begin result := - 1 ;
110558: LD_ADDR_VAR 0 5
110562: PUSH
110563: LD_INT 1
110565: NEG
110566: ST_TO_ADDR
// exit ;
110567: GO 110804
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
110569: LD_ADDR_VAR 0 12
110573: PUSH
110574: LD_VAR 0 1
110578: PPUSH
110579: LD_VAR 0 2
110583: PPUSH
110584: LD_VAR 0 3
110588: PPUSH
110589: LD_VAR 0 4
110593: PPUSH
110594: CALL 109640 0 4
110598: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
110599: LD_ADDR_VAR 0 11
110603: PUSH
110604: LD_VAR 0 1
110608: PPUSH
110609: LD_VAR 0 2
110613: PPUSH
110614: LD_VAR 0 12
110618: PUSH
110619: LD_INT 1
110621: ARRAY
110622: PPUSH
110623: LD_VAR 0 12
110627: PUSH
110628: LD_INT 2
110630: ARRAY
110631: PPUSH
110632: CALL_OW 298
110636: ST_TO_ADDR
// distance := 9999 ;
110637: LD_ADDR_VAR 0 10
110641: PUSH
110642: LD_INT 9999
110644: ST_TO_ADDR
// for i := 0 to 5 do
110645: LD_ADDR_VAR 0 6
110649: PUSH
110650: DOUBLE
110651: LD_INT 0
110653: DEC
110654: ST_TO_ADDR
110655: LD_INT 5
110657: PUSH
110658: FOR_TO
110659: IFFALSE 110802
// begin _x := ShiftX ( x1 , i , centerDist ) ;
110661: LD_ADDR_VAR 0 7
110665: PUSH
110666: LD_VAR 0 1
110670: PPUSH
110671: LD_VAR 0 6
110675: PPUSH
110676: LD_VAR 0 11
110680: PPUSH
110681: CALL_OW 272
110685: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
110686: LD_ADDR_VAR 0 8
110690: PUSH
110691: LD_VAR 0 2
110695: PPUSH
110696: LD_VAR 0 6
110700: PPUSH
110701: LD_VAR 0 11
110705: PPUSH
110706: CALL_OW 273
110710: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110711: LD_VAR 0 7
110715: PPUSH
110716: LD_VAR 0 8
110720: PPUSH
110721: CALL_OW 488
110725: NOT
110726: IFFALSE 110730
// continue ;
110728: GO 110658
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
110730: LD_ADDR_VAR 0 9
110734: PUSH
110735: LD_VAR 0 12
110739: PUSH
110740: LD_INT 1
110742: ARRAY
110743: PPUSH
110744: LD_VAR 0 12
110748: PUSH
110749: LD_INT 2
110751: ARRAY
110752: PPUSH
110753: LD_VAR 0 7
110757: PPUSH
110758: LD_VAR 0 8
110762: PPUSH
110763: CALL_OW 298
110767: ST_TO_ADDR
// if tmp < distance then
110768: LD_VAR 0 9
110772: PUSH
110773: LD_VAR 0 10
110777: LESS
110778: IFFALSE 110800
// begin result := i ;
110780: LD_ADDR_VAR 0 5
110784: PUSH
110785: LD_VAR 0 6
110789: ST_TO_ADDR
// distance := tmp ;
110790: LD_ADDR_VAR 0 10
110794: PUSH
110795: LD_VAR 0 9
110799: ST_TO_ADDR
// end ; end ;
110800: GO 110658
110802: POP
110803: POP
// end ;
110804: LD_VAR 0 5
110808: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110809: LD_INT 0
110811: PPUSH
110812: PPUSH
// if not driver or not IsInUnit ( driver ) then
110813: LD_VAR 0 1
110817: NOT
110818: IFTRUE 110832
110820: PUSH
110821: LD_VAR 0 1
110825: PPUSH
110826: CALL_OW 310
110830: NOT
110831: OR
110832: IFFALSE 110836
// exit ;
110834: GO 110926
// vehicle := IsInUnit ( driver ) ;
110836: LD_ADDR_VAR 0 3
110840: PUSH
110841: LD_VAR 0 1
110845: PPUSH
110846: CALL_OW 310
110850: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
110851: LD_VAR 0 1
110855: PPUSH
110856: LD_STRING \
110858: PUSH
110859: LD_INT 0
110861: PUSH
110862: LD_INT 0
110864: PUSH
110865: LD_INT 0
110867: PUSH
110868: LD_INT 0
110870: PUSH
110871: LD_INT 0
110873: PUSH
110874: LD_INT 0
110876: PUSH
110877: EMPTY
110878: LIST
110879: LIST
110880: LIST
110881: LIST
110882: LIST
110883: LIST
110884: LIST
110885: PUSH
110886: LD_STRING E
110888: PUSH
110889: LD_INT 0
110891: PUSH
110892: LD_INT 0
110894: PUSH
110895: LD_VAR 0 3
110899: PUSH
110900: LD_INT 0
110902: PUSH
110903: LD_INT 0
110905: PUSH
110906: LD_INT 0
110908: PUSH
110909: EMPTY
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: PUSH
110918: EMPTY
110919: LIST
110920: LIST
110921: PPUSH
110922: CALL_OW 446
// end ;
110926: LD_VAR 0 2
110930: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110931: LD_INT 0
110933: PPUSH
110934: PPUSH
// if not driver or not IsInUnit ( driver ) then
110935: LD_VAR 0 1
110939: NOT
110940: IFTRUE 110954
110942: PUSH
110943: LD_VAR 0 1
110947: PPUSH
110948: CALL_OW 310
110952: NOT
110953: OR
110954: IFFALSE 110958
// exit ;
110956: GO 111048
// vehicle := IsInUnit ( driver ) ;
110958: LD_ADDR_VAR 0 3
110962: PUSH
110963: LD_VAR 0 1
110967: PPUSH
110968: CALL_OW 310
110972: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
110973: LD_VAR 0 1
110977: PPUSH
110978: LD_STRING \
110980: PUSH
110981: LD_INT 0
110983: PUSH
110984: LD_INT 0
110986: PUSH
110987: LD_INT 0
110989: PUSH
110990: LD_INT 0
110992: PUSH
110993: LD_INT 0
110995: PUSH
110996: LD_INT 0
110998: PUSH
110999: EMPTY
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: LIST
111005: LIST
111006: LIST
111007: PUSH
111008: LD_STRING E
111010: PUSH
111011: LD_INT 0
111013: PUSH
111014: LD_INT 0
111016: PUSH
111017: LD_VAR 0 3
111021: PUSH
111022: LD_INT 0
111024: PUSH
111025: LD_INT 0
111027: PUSH
111028: LD_INT 0
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: LIST
111035: LIST
111036: LIST
111037: LIST
111038: LIST
111039: PUSH
111040: EMPTY
111041: LIST
111042: LIST
111043: PPUSH
111044: CALL_OW 447
// end ;
111048: LD_VAR 0 2
111052: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
111053: LD_INT 0
111055: PPUSH
111056: PPUSH
111057: PPUSH
// tmp := [ ] ;
111058: LD_ADDR_VAR 0 5
111062: PUSH
111063: EMPTY
111064: ST_TO_ADDR
// for i in units do
111065: LD_ADDR_VAR 0 4
111069: PUSH
111070: LD_VAR 0 1
111074: PUSH
111075: FOR_IN
111076: IFFALSE 111114
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
111078: LD_ADDR_VAR 0 5
111082: PUSH
111083: LD_VAR 0 5
111087: PPUSH
111088: LD_VAR 0 5
111092: PUSH
111093: LD_INT 1
111095: PLUS
111096: PPUSH
111097: LD_VAR 0 4
111101: PPUSH
111102: CALL_OW 256
111106: PPUSH
111107: CALL_OW 2
111111: ST_TO_ADDR
111112: GO 111075
111114: POP
111115: POP
// if not tmp then
111116: LD_VAR 0 5
111120: NOT
111121: IFFALSE 111125
// exit ;
111123: GO 111173
// if asc then
111125: LD_VAR 0 2
111129: IFFALSE 111153
// result := SortListByListAsc ( units , tmp ) else
111131: LD_ADDR_VAR 0 3
111135: PUSH
111136: LD_VAR 0 1
111140: PPUSH
111141: LD_VAR 0 5
111145: PPUSH
111146: CALL_OW 76
111150: ST_TO_ADDR
111151: GO 111173
// result := SortListByListDesc ( units , tmp ) ;
111153: LD_ADDR_VAR 0 3
111157: PUSH
111158: LD_VAR 0 1
111162: PPUSH
111163: LD_VAR 0 5
111167: PPUSH
111168: CALL_OW 77
111172: ST_TO_ADDR
// end ;
111173: LD_VAR 0 3
111177: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
111178: LD_INT 0
111180: PPUSH
111181: PPUSH
// task := GetTaskList ( mech ) ;
111182: LD_ADDR_VAR 0 4
111186: PUSH
111187: LD_VAR 0 1
111191: PPUSH
111192: CALL_OW 437
111196: ST_TO_ADDR
// if not task then
111197: LD_VAR 0 4
111201: NOT
111202: IFFALSE 111206
// exit ;
111204: GO 111250
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
111206: LD_ADDR_VAR 0 3
111210: PUSH
111211: LD_VAR 0 4
111215: PUSH
111216: LD_INT 1
111218: ARRAY
111219: PUSH
111220: LD_INT 1
111222: ARRAY
111223: PUSH
111224: LD_STRING r
111226: EQUAL
111227: IFFALSE 111249
111229: PUSH
111230: LD_VAR 0 4
111234: PUSH
111235: LD_INT 1
111237: ARRAY
111238: PUSH
111239: LD_INT 4
111241: ARRAY
111242: PUSH
111243: LD_VAR 0 2
111247: EQUAL
111248: AND
111249: ST_TO_ADDR
// end ;
111250: LD_VAR 0 3
111254: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
111255: LD_INT 0
111257: PPUSH
// SetDir ( unit , d ) ;
111258: LD_VAR 0 1
111262: PPUSH
111263: LD_VAR 0 4
111267: PPUSH
111268: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
111272: LD_ADDR_VAR 0 6
111276: PUSH
111277: LD_VAR 0 1
111281: PPUSH
111282: LD_VAR 0 2
111286: PPUSH
111287: LD_VAR 0 3
111291: PPUSH
111292: LD_VAR 0 5
111296: PPUSH
111297: CALL_OW 48
111301: ST_TO_ADDR
// end ;
111302: LD_VAR 0 6
111306: RET
// export function ToNaturalNumber ( number ) ; begin
111307: LD_INT 0
111309: PPUSH
// result := number div 1 ;
111310: LD_ADDR_VAR 0 2
111314: PUSH
111315: LD_VAR 0 1
111319: PUSH
111320: LD_INT 1
111322: DIV
111323: ST_TO_ADDR
// if number < 0 then
111324: LD_VAR 0 1
111328: PUSH
111329: LD_INT 0
111331: LESS
111332: IFFALSE 111342
// result := 0 ;
111334: LD_ADDR_VAR 0 2
111338: PUSH
111339: LD_INT 0
111341: ST_TO_ADDR
// end ;
111342: LD_VAR 0 2
111346: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
111347: LD_INT 0
111349: PPUSH
111350: PPUSH
111351: PPUSH
// if not buildings then
111352: LD_VAR 0 1
111356: NOT
111357: IFFALSE 111361
// exit ;
111359: GO 111476
// tmp := [ ] ;
111361: LD_ADDR_VAR 0 5
111365: PUSH
111366: EMPTY
111367: ST_TO_ADDR
// for b in buildings do
111368: LD_ADDR_VAR 0 4
111372: PUSH
111373: LD_VAR 0 1
111377: PUSH
111378: FOR_IN
111379: IFFALSE 111417
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
111381: LD_ADDR_VAR 0 5
111385: PUSH
111386: LD_VAR 0 5
111390: PPUSH
111391: LD_VAR 0 5
111395: PUSH
111396: LD_INT 1
111398: PLUS
111399: PPUSH
111400: LD_VAR 0 4
111404: PPUSH
111405: CALL_OW 266
111409: PPUSH
111410: CALL_OW 1
111414: ST_TO_ADDR
111415: GO 111378
111417: POP
111418: POP
// if not tmp then
111419: LD_VAR 0 5
111423: NOT
111424: IFFALSE 111428
// exit ;
111426: GO 111476
// if asc then
111428: LD_VAR 0 2
111432: IFFALSE 111456
// result := SortListByListAsc ( buildings , tmp ) else
111434: LD_ADDR_VAR 0 3
111438: PUSH
111439: LD_VAR 0 1
111443: PPUSH
111444: LD_VAR 0 5
111448: PPUSH
111449: CALL_OW 76
111453: ST_TO_ADDR
111454: GO 111476
// result := SortListByListDesc ( buildings , tmp ) ;
111456: LD_ADDR_VAR 0 3
111460: PUSH
111461: LD_VAR 0 1
111465: PPUSH
111466: LD_VAR 0 5
111470: PPUSH
111471: CALL_OW 77
111475: ST_TO_ADDR
// end ;
111476: LD_VAR 0 3
111480: RET
// export function SortByClass ( units , class ) ; var un ; begin
111481: LD_INT 0
111483: PPUSH
111484: PPUSH
// if not units or not class then
111485: LD_VAR 0 1
111489: NOT
111490: IFTRUE 111499
111492: PUSH
111493: LD_VAR 0 2
111497: NOT
111498: OR
111499: IFFALSE 111503
// exit ;
111501: GO 111598
// result := [ ] ;
111503: LD_ADDR_VAR 0 3
111507: PUSH
111508: EMPTY
111509: ST_TO_ADDR
// for un in units do
111510: LD_ADDR_VAR 0 4
111514: PUSH
111515: LD_VAR 0 1
111519: PUSH
111520: FOR_IN
111521: IFFALSE 111596
// if GetClass ( un ) = class then
111523: LD_VAR 0 4
111527: PPUSH
111528: CALL_OW 257
111532: PUSH
111533: LD_VAR 0 2
111537: EQUAL
111538: IFFALSE 111565
// result := Insert ( result , 1 , un ) else
111540: LD_ADDR_VAR 0 3
111544: PUSH
111545: LD_VAR 0 3
111549: PPUSH
111550: LD_INT 1
111552: PPUSH
111553: LD_VAR 0 4
111557: PPUSH
111558: CALL_OW 2
111562: ST_TO_ADDR
111563: GO 111594
// result := Replace ( result , result + 1 , un ) ;
111565: LD_ADDR_VAR 0 3
111569: PUSH
111570: LD_VAR 0 3
111574: PPUSH
111575: LD_VAR 0 3
111579: PUSH
111580: LD_INT 1
111582: PLUS
111583: PPUSH
111584: LD_VAR 0 4
111588: PPUSH
111589: CALL_OW 1
111593: ST_TO_ADDR
111594: GO 111520
111596: POP
111597: POP
// end ;
111598: LD_VAR 0 3
111602: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
111603: LD_INT 0
111605: PPUSH
111606: PPUSH
111607: PPUSH
111608: PPUSH
111609: PPUSH
111610: PPUSH
111611: PPUSH
// result := [ ] ;
111612: LD_ADDR_VAR 0 4
111616: PUSH
111617: EMPTY
111618: ST_TO_ADDR
// if x - r < 0 then
111619: LD_VAR 0 1
111623: PUSH
111624: LD_VAR 0 3
111628: MINUS
111629: PUSH
111630: LD_INT 0
111632: LESS
111633: IFFALSE 111645
// min_x := 0 else
111635: LD_ADDR_VAR 0 8
111639: PUSH
111640: LD_INT 0
111642: ST_TO_ADDR
111643: GO 111661
// min_x := x - r ;
111645: LD_ADDR_VAR 0 8
111649: PUSH
111650: LD_VAR 0 1
111654: PUSH
111655: LD_VAR 0 3
111659: MINUS
111660: ST_TO_ADDR
// if y - r < 0 then
111661: LD_VAR 0 2
111665: PUSH
111666: LD_VAR 0 3
111670: MINUS
111671: PUSH
111672: LD_INT 0
111674: LESS
111675: IFFALSE 111687
// min_y := 0 else
111677: LD_ADDR_VAR 0 7
111681: PUSH
111682: LD_INT 0
111684: ST_TO_ADDR
111685: GO 111703
// min_y := y - r ;
111687: LD_ADDR_VAR 0 7
111691: PUSH
111692: LD_VAR 0 2
111696: PUSH
111697: LD_VAR 0 3
111701: MINUS
111702: ST_TO_ADDR
// max_x := x + r ;
111703: LD_ADDR_VAR 0 9
111707: PUSH
111708: LD_VAR 0 1
111712: PUSH
111713: LD_VAR 0 3
111717: PLUS
111718: ST_TO_ADDR
// max_y := y + r ;
111719: LD_ADDR_VAR 0 10
111723: PUSH
111724: LD_VAR 0 2
111728: PUSH
111729: LD_VAR 0 3
111733: PLUS
111734: ST_TO_ADDR
// for _x = min_x to max_x do
111735: LD_ADDR_VAR 0 5
111739: PUSH
111740: DOUBLE
111741: LD_VAR 0 8
111745: DEC
111746: ST_TO_ADDR
111747: LD_VAR 0 9
111751: PUSH
111752: FOR_TO
111753: IFFALSE 111854
// for _y = min_y to max_y do
111755: LD_ADDR_VAR 0 6
111759: PUSH
111760: DOUBLE
111761: LD_VAR 0 7
111765: DEC
111766: ST_TO_ADDR
111767: LD_VAR 0 10
111771: PUSH
111772: FOR_TO
111773: IFFALSE 111850
// begin if not ValidHex ( _x , _y ) then
111775: LD_VAR 0 5
111779: PPUSH
111780: LD_VAR 0 6
111784: PPUSH
111785: CALL_OW 488
111789: NOT
111790: IFFALSE 111794
// continue ;
111792: GO 111772
// if GetResourceTypeXY ( _x , _y ) then
111794: LD_VAR 0 5
111798: PPUSH
111799: LD_VAR 0 6
111803: PPUSH
111804: CALL_OW 283
111808: IFFALSE 111848
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
111810: LD_ADDR_VAR 0 4
111814: PUSH
111815: LD_VAR 0 4
111819: PPUSH
111820: LD_VAR 0 4
111824: PUSH
111825: LD_INT 1
111827: PLUS
111828: PPUSH
111829: LD_VAR 0 5
111833: PUSH
111834: LD_VAR 0 6
111838: PUSH
111839: EMPTY
111840: LIST
111841: LIST
111842: PPUSH
111843: CALL_OW 1
111847: ST_TO_ADDR
// end ;
111848: GO 111772
111850: POP
111851: POP
111852: GO 111752
111854: POP
111855: POP
// end ;
111856: LD_VAR 0 4
111860: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
111861: LD_INT 0
111863: PPUSH
111864: PPUSH
111865: PPUSH
111866: PPUSH
111867: PPUSH
111868: PPUSH
111869: PPUSH
111870: PPUSH
// if not units then
111871: LD_VAR 0 1
111875: NOT
111876: IFFALSE 111880
// exit ;
111878: GO 112412
// result := UnitFilter ( units , [ f_ok ] ) ;
111880: LD_ADDR_VAR 0 3
111884: PUSH
111885: LD_VAR 0 1
111889: PPUSH
111890: LD_INT 50
111892: PUSH
111893: EMPTY
111894: LIST
111895: PPUSH
111896: CALL_OW 72
111900: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
111901: LD_ADDR_VAR 0 8
111905: PUSH
111906: LD_VAR 0 1
111910: PUSH
111911: LD_INT 1
111913: ARRAY
111914: PPUSH
111915: CALL_OW 255
111919: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
111920: LD_ADDR_VAR 0 10
111924: PUSH
111925: LD_INT 29
111927: PUSH
111928: LD_INT 91
111930: PUSH
111931: LD_INT 49
111933: PUSH
111934: EMPTY
111935: LIST
111936: LIST
111937: LIST
111938: ST_TO_ADDR
// if not result then
111939: LD_VAR 0 3
111943: NOT
111944: IFFALSE 111948
// exit ;
111946: GO 112412
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
111948: LD_ADDR_VAR 0 5
111952: PUSH
111953: LD_INT 81
111955: PUSH
111956: LD_VAR 0 8
111960: PUSH
111961: EMPTY
111962: LIST
111963: LIST
111964: PPUSH
111965: CALL_OW 69
111969: ST_TO_ADDR
// for i in result do
111970: LD_ADDR_VAR 0 4
111974: PUSH
111975: LD_VAR 0 3
111979: PUSH
111980: FOR_IN
111981: IFFALSE 112410
// begin tag := GetTag ( i ) + 1 ;
111983: LD_ADDR_VAR 0 9
111987: PUSH
111988: LD_VAR 0 4
111992: PPUSH
111993: CALL_OW 110
111997: PUSH
111998: LD_INT 1
112000: PLUS
112001: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
112002: LD_ADDR_VAR 0 7
112006: PUSH
112007: LD_VAR 0 4
112011: PPUSH
112012: CALL_OW 250
112016: PPUSH
112017: LD_VAR 0 4
112021: PPUSH
112022: CALL_OW 251
112026: PPUSH
112027: LD_INT 4
112029: PPUSH
112030: CALL 111603 0 3
112034: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
112035: LD_VAR 0 4
112039: PPUSH
112040: CALL_OW 247
112044: PUSH
112045: LD_INT 2
112047: EQUAL
112048: IFFALSE 112060
112050: PUSH
112051: LD_VAR 0 7
112055: PUSH
112056: LD_INT 2
112058: GREATER
112059: AND
112060: IFFALSE 112080
112062: PUSH
112063: LD_VAR 0 4
112067: PPUSH
112068: CALL_OW 264
112072: PUSH
112073: LD_VAR 0 10
112077: IN
112078: NOT
112079: AND
112080: IFFALSE 112119
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
112082: LD_VAR 0 4
112086: PPUSH
112087: LD_VAR 0 7
112091: PUSH
112092: LD_INT 1
112094: ARRAY
112095: PUSH
112096: LD_INT 1
112098: ARRAY
112099: PPUSH
112100: LD_VAR 0 7
112104: PUSH
112105: LD_INT 1
112107: ARRAY
112108: PUSH
112109: LD_INT 2
112111: ARRAY
112112: PPUSH
112113: CALL_OW 116
112117: GO 112408
// if path > tag then
112119: LD_VAR 0 2
112123: PUSH
112124: LD_VAR 0 9
112128: GREATER
112129: IFFALSE 112337
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
112131: LD_ADDR_VAR 0 6
112135: PUSH
112136: LD_VAR 0 5
112140: PPUSH
112141: LD_INT 91
112143: PUSH
112144: LD_VAR 0 4
112148: PUSH
112149: LD_INT 8
112151: PUSH
112152: EMPTY
112153: LIST
112154: LIST
112155: LIST
112156: PPUSH
112157: CALL_OW 72
112161: ST_TO_ADDR
// if nearEnemy then
112162: LD_VAR 0 6
112166: IFFALSE 112235
// begin if GetWeapon ( i ) = ru_time_lapser then
112168: LD_VAR 0 4
112172: PPUSH
112173: CALL_OW 264
112177: PUSH
112178: LD_INT 49
112180: EQUAL
112181: IFFALSE 112209
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
112183: LD_VAR 0 4
112187: PPUSH
112188: LD_VAR 0 6
112192: PPUSH
112193: LD_VAR 0 4
112197: PPUSH
112198: CALL_OW 74
112202: PPUSH
112203: CALL_OW 112
112207: GO 112233
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
112209: LD_VAR 0 4
112213: PPUSH
112214: LD_VAR 0 6
112218: PPUSH
112219: LD_VAR 0 4
112223: PPUSH
112224: CALL_OW 74
112228: PPUSH
112229: CALL 113493 0 2
// end else
112233: GO 112335
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
112235: LD_VAR 0 4
112239: PPUSH
112240: LD_VAR 0 2
112244: PUSH
112245: LD_VAR 0 9
112249: ARRAY
112250: PUSH
112251: LD_INT 1
112253: ARRAY
112254: PPUSH
112255: LD_VAR 0 2
112259: PUSH
112260: LD_VAR 0 9
112264: ARRAY
112265: PUSH
112266: LD_INT 2
112268: ARRAY
112269: PPUSH
112270: CALL_OW 297
112274: PUSH
112275: LD_INT 6
112277: GREATER
112278: IFFALSE 112321
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
112280: LD_VAR 0 4
112284: PPUSH
112285: LD_VAR 0 2
112289: PUSH
112290: LD_VAR 0 9
112294: ARRAY
112295: PUSH
112296: LD_INT 1
112298: ARRAY
112299: PPUSH
112300: LD_VAR 0 2
112304: PUSH
112305: LD_VAR 0 9
112309: ARRAY
112310: PUSH
112311: LD_INT 2
112313: ARRAY
112314: PPUSH
112315: CALL_OW 114
112319: GO 112335
// SetTag ( i , tag ) ;
112321: LD_VAR 0 4
112325: PPUSH
112326: LD_VAR 0 9
112330: PPUSH
112331: CALL_OW 109
// end else
112335: GO 112408
// if enemy then
112337: LD_VAR 0 5
112341: IFFALSE 112408
// begin if GetWeapon ( i ) = ru_time_lapser then
112343: LD_VAR 0 4
112347: PPUSH
112348: CALL_OW 264
112352: PUSH
112353: LD_INT 49
112355: EQUAL
112356: IFFALSE 112384
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
112358: LD_VAR 0 4
112362: PPUSH
112363: LD_VAR 0 5
112367: PPUSH
112368: LD_VAR 0 4
112372: PPUSH
112373: CALL_OW 74
112377: PPUSH
112378: CALL_OW 112
112382: GO 112408
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
112384: LD_VAR 0 4
112388: PPUSH
112389: LD_VAR 0 5
112393: PPUSH
112394: LD_VAR 0 4
112398: PPUSH
112399: CALL_OW 74
112403: PPUSH
112404: CALL 113493 0 2
// end ; end ;
112408: GO 111980
112410: POP
112411: POP
// end ;
112412: LD_VAR 0 3
112416: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
112417: LD_INT 0
112419: PPUSH
112420: PPUSH
112421: PPUSH
// if not unit or IsInUnit ( unit ) then
112422: LD_VAR 0 1
112426: NOT
112427: IFTRUE 112440
112429: PUSH
112430: LD_VAR 0 1
112434: PPUSH
112435: CALL_OW 310
112439: OR
112440: IFFALSE 112444
// exit ;
112442: GO 112535
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
112444: LD_ADDR_VAR 0 4
112448: PUSH
112449: LD_VAR 0 1
112453: PPUSH
112454: CALL_OW 250
112458: PPUSH
112459: LD_VAR 0 2
112463: PPUSH
112464: LD_INT 1
112466: PPUSH
112467: CALL_OW 272
112471: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
112472: LD_ADDR_VAR 0 5
112476: PUSH
112477: LD_VAR 0 1
112481: PPUSH
112482: CALL_OW 251
112486: PPUSH
112487: LD_VAR 0 2
112491: PPUSH
112492: LD_INT 1
112494: PPUSH
112495: CALL_OW 273
112499: ST_TO_ADDR
// if ValidHex ( x , y ) then
112500: LD_VAR 0 4
112504: PPUSH
112505: LD_VAR 0 5
112509: PPUSH
112510: CALL_OW 488
112514: IFFALSE 112535
// ComTurnXY ( unit , x , y ) ;
112516: LD_VAR 0 1
112520: PPUSH
112521: LD_VAR 0 4
112525: PPUSH
112526: LD_VAR 0 5
112530: PPUSH
112531: CALL_OW 118
// end ;
112535: LD_VAR 0 3
112539: RET
// export function SeeUnits ( side , units ) ; var i ; begin
112540: LD_INT 0
112542: PPUSH
112543: PPUSH
// result := false ;
112544: LD_ADDR_VAR 0 3
112548: PUSH
112549: LD_INT 0
112551: ST_TO_ADDR
// if not units then
112552: LD_VAR 0 2
112556: NOT
112557: IFFALSE 112561
// exit ;
112559: GO 112606
// for i in units do
112561: LD_ADDR_VAR 0 4
112565: PUSH
112566: LD_VAR 0 2
112570: PUSH
112571: FOR_IN
112572: IFFALSE 112604
// if See ( side , i ) then
112574: LD_VAR 0 1
112578: PPUSH
112579: LD_VAR 0 4
112583: PPUSH
112584: CALL_OW 292
112588: IFFALSE 112602
// begin result := true ;
112590: LD_ADDR_VAR 0 3
112594: PUSH
112595: LD_INT 1
112597: ST_TO_ADDR
// exit ;
112598: POP
112599: POP
112600: GO 112606
// end ;
112602: GO 112571
112604: POP
112605: POP
// end ;
112606: LD_VAR 0 3
112610: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
112611: LD_INT 0
112613: PPUSH
112614: PPUSH
112615: PPUSH
112616: PPUSH
// if not unit or not points then
112617: LD_VAR 0 1
112621: NOT
112622: IFTRUE 112631
112624: PUSH
112625: LD_VAR 0 2
112629: NOT
112630: OR
112631: IFFALSE 112635
// exit ;
112633: GO 112725
// dist := 99999 ;
112635: LD_ADDR_VAR 0 5
112639: PUSH
112640: LD_INT 99999
112642: ST_TO_ADDR
// for i in points do
112643: LD_ADDR_VAR 0 4
112647: PUSH
112648: LD_VAR 0 2
112652: PUSH
112653: FOR_IN
112654: IFFALSE 112723
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
112656: LD_ADDR_VAR 0 6
112660: PUSH
112661: LD_VAR 0 1
112665: PPUSH
112666: LD_VAR 0 4
112670: PUSH
112671: LD_INT 1
112673: ARRAY
112674: PPUSH
112675: LD_VAR 0 4
112679: PUSH
112680: LD_INT 2
112682: ARRAY
112683: PPUSH
112684: CALL_OW 297
112688: ST_TO_ADDR
// if tmpDist < dist then
112689: LD_VAR 0 6
112693: PUSH
112694: LD_VAR 0 5
112698: LESS
112699: IFFALSE 112721
// begin result := i ;
112701: LD_ADDR_VAR 0 3
112705: PUSH
112706: LD_VAR 0 4
112710: ST_TO_ADDR
// dist := tmpDist ;
112711: LD_ADDR_VAR 0 5
112715: PUSH
112716: LD_VAR 0 6
112720: ST_TO_ADDR
// end ; end ;
112721: GO 112653
112723: POP
112724: POP
// end ;
112725: LD_VAR 0 3
112729: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
112730: LD_INT 0
112732: PPUSH
// uc_side := side ;
112733: LD_ADDR_OWVAR 20
112737: PUSH
112738: LD_VAR 0 1
112742: ST_TO_ADDR
// uc_nation := 3 ;
112743: LD_ADDR_OWVAR 21
112747: PUSH
112748: LD_INT 3
112750: ST_TO_ADDR
// vc_chassis := 25 ;
112751: LD_ADDR_OWVAR 37
112755: PUSH
112756: LD_INT 25
112758: ST_TO_ADDR
// vc_engine := engine_siberite ;
112759: LD_ADDR_OWVAR 39
112763: PUSH
112764: LD_INT 3
112766: ST_TO_ADDR
// vc_control := control_computer ;
112767: LD_ADDR_OWVAR 38
112771: PUSH
112772: LD_INT 3
112774: ST_TO_ADDR
// vc_weapon := 59 ;
112775: LD_ADDR_OWVAR 40
112779: PUSH
112780: LD_INT 59
112782: ST_TO_ADDR
// result := CreateVehicle ;
112783: LD_ADDR_VAR 0 5
112787: PUSH
112788: CALL_OW 45
112792: ST_TO_ADDR
// SetDir ( result , d ) ;
112793: LD_VAR 0 5
112797: PPUSH
112798: LD_VAR 0 4
112802: PPUSH
112803: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
112807: LD_VAR 0 5
112811: PPUSH
112812: LD_VAR 0 2
112816: PPUSH
112817: LD_VAR 0 3
112821: PPUSH
112822: LD_INT 0
112824: PPUSH
112825: CALL_OW 48
// end ;
112829: LD_VAR 0 5
112833: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
112834: LD_INT 0
112836: PPUSH
112837: PPUSH
112838: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
112839: LD_ADDR_VAR 0 2
112843: PUSH
112844: LD_INT 0
112846: PUSH
112847: LD_INT 0
112849: PUSH
112850: LD_INT 0
112852: PUSH
112853: LD_INT 0
112855: PUSH
112856: EMPTY
112857: LIST
112858: LIST
112859: LIST
112860: LIST
112861: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
112862: LD_VAR 0 1
112866: NOT
112867: IFTRUE 112900
112869: PUSH
112870: LD_VAR 0 1
112874: PPUSH
112875: CALL_OW 264
112879: PUSH
112880: LD_INT 12
112882: PUSH
112883: LD_INT 51
112885: PUSH
112886: LD_INT 32
112888: PUSH
112889: LD_INT 89
112891: PUSH
112892: EMPTY
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: IN
112898: NOT
112899: OR
112900: IFFALSE 112904
// exit ;
112902: GO 113002
// for i := 1 to 3 do
112904: LD_ADDR_VAR 0 3
112908: PUSH
112909: DOUBLE
112910: LD_INT 1
112912: DEC
112913: ST_TO_ADDR
112914: LD_INT 3
112916: PUSH
112917: FOR_TO
112918: IFFALSE 113000
// begin tmp := GetCargo ( cargo , i ) ;
112920: LD_ADDR_VAR 0 4
112924: PUSH
112925: LD_VAR 0 1
112929: PPUSH
112930: LD_VAR 0 3
112934: PPUSH
112935: CALL_OW 289
112939: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
112940: LD_ADDR_VAR 0 2
112944: PUSH
112945: LD_VAR 0 2
112949: PPUSH
112950: LD_VAR 0 3
112954: PPUSH
112955: LD_VAR 0 4
112959: PPUSH
112960: CALL_OW 1
112964: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
112965: LD_ADDR_VAR 0 2
112969: PUSH
112970: LD_VAR 0 2
112974: PPUSH
112975: LD_INT 4
112977: PPUSH
112978: LD_VAR 0 2
112982: PUSH
112983: LD_INT 4
112985: ARRAY
112986: PUSH
112987: LD_VAR 0 4
112991: PLUS
112992: PPUSH
112993: CALL_OW 1
112997: ST_TO_ADDR
// end ;
112998: GO 112917
113000: POP
113001: POP
// end ;
113002: LD_VAR 0 2
113006: RET
// export function Length ( array ) ; begin
113007: LD_INT 0
113009: PPUSH
// result := array + 0 ;
113010: LD_ADDR_VAR 0 2
113014: PUSH
113015: LD_VAR 0 1
113019: PUSH
113020: LD_INT 0
113022: PLUS
113023: ST_TO_ADDR
// end ;
113024: LD_VAR 0 2
113028: RET
// export function PrepareArray ( array ) ; begin
113029: LD_INT 0
113031: PPUSH
// result := array diff 0 ;
113032: LD_ADDR_VAR 0 2
113036: PUSH
113037: LD_VAR 0 1
113041: PUSH
113042: LD_INT 0
113044: DIFF
113045: ST_TO_ADDR
// if not result [ 1 ] then
113046: LD_VAR 0 2
113050: PUSH
113051: LD_INT 1
113053: ARRAY
113054: NOT
113055: IFFALSE 113075
// result := Delete ( result , 1 ) ;
113057: LD_ADDR_VAR 0 2
113061: PUSH
113062: LD_VAR 0 2
113066: PPUSH
113067: LD_INT 1
113069: PPUSH
113070: CALL_OW 3
113074: ST_TO_ADDR
// end ;
113075: LD_VAR 0 2
113079: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
113080: LD_INT 0
113082: PPUSH
113083: PPUSH
113084: PPUSH
113085: PPUSH
// sibRocketRange := 25 ;
113086: LD_ADDR_VAR 0 6
113090: PUSH
113091: LD_INT 25
113093: ST_TO_ADDR
// result := false ;
113094: LD_ADDR_VAR 0 4
113098: PUSH
113099: LD_INT 0
113101: ST_TO_ADDR
// for i := 0 to 5 do
113102: LD_ADDR_VAR 0 5
113106: PUSH
113107: DOUBLE
113108: LD_INT 0
113110: DEC
113111: ST_TO_ADDR
113112: LD_INT 5
113114: PUSH
113115: FOR_TO
113116: IFFALSE 113183
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
113118: LD_VAR 0 1
113122: PPUSH
113123: LD_VAR 0 5
113127: PPUSH
113128: LD_VAR 0 6
113132: PPUSH
113133: CALL_OW 272
113137: PPUSH
113138: LD_VAR 0 2
113142: PPUSH
113143: LD_VAR 0 5
113147: PPUSH
113148: LD_VAR 0 6
113152: PPUSH
113153: CALL_OW 273
113157: PPUSH
113158: LD_VAR 0 3
113162: PPUSH
113163: CALL_OW 309
113167: IFFALSE 113181
// begin result := true ;
113169: LD_ADDR_VAR 0 4
113173: PUSH
113174: LD_INT 1
113176: ST_TO_ADDR
// exit ;
113177: POP
113178: POP
113179: GO 113185
// end ;
113181: GO 113115
113183: POP
113184: POP
// end ;
113185: LD_VAR 0 4
113189: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
113190: LD_INT 0
113192: PPUSH
113193: PPUSH
113194: PPUSH
// if btype = b_depot then
113195: LD_VAR 0 2
113199: PUSH
113200: LD_INT 0
113202: EQUAL
113203: IFFALSE 113215
// begin result := true ;
113205: LD_ADDR_VAR 0 3
113209: PUSH
113210: LD_INT 1
113212: ST_TO_ADDR
// exit ;
113213: GO 113335
// end ; pom := GetBase ( depot ) ;
113215: LD_ADDR_VAR 0 4
113219: PUSH
113220: LD_VAR 0 1
113224: PPUSH
113225: CALL_OW 274
113229: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
113230: LD_ADDR_VAR 0 5
113234: PUSH
113235: LD_VAR 0 2
113239: PPUSH
113240: LD_VAR 0 1
113244: PPUSH
113245: CALL_OW 248
113249: PPUSH
113250: CALL_OW 450
113254: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
113255: LD_ADDR_VAR 0 3
113259: PUSH
113260: LD_VAR 0 4
113264: PPUSH
113265: LD_INT 1
113267: PPUSH
113268: CALL_OW 275
113272: PUSH
113273: LD_VAR 0 5
113277: PUSH
113278: LD_INT 1
113280: ARRAY
113281: GREATEREQUAL
113282: IFFALSE 113308
113284: PUSH
113285: LD_VAR 0 4
113289: PPUSH
113290: LD_INT 2
113292: PPUSH
113293: CALL_OW 275
113297: PUSH
113298: LD_VAR 0 5
113302: PUSH
113303: LD_INT 2
113305: ARRAY
113306: GREATEREQUAL
113307: AND
113308: IFFALSE 113334
113310: PUSH
113311: LD_VAR 0 4
113315: PPUSH
113316: LD_INT 3
113318: PPUSH
113319: CALL_OW 275
113323: PUSH
113324: LD_VAR 0 5
113328: PUSH
113329: LD_INT 3
113331: ARRAY
113332: GREATEREQUAL
113333: AND
113334: ST_TO_ADDR
// end ;
113335: LD_VAR 0 3
113339: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
113340: LD_INT 0
113342: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
113343: LD_VAR 0 1
113347: PPUSH
113348: LD_VAR 0 2
113352: PPUSH
113353: LD_INT 0
113355: PPUSH
113356: LD_INT 0
113358: PPUSH
113359: LD_INT 1
113361: PPUSH
113362: LD_INT 0
113364: PPUSH
113365: CALL_OW 587
// end ;
113369: LD_VAR 0 3
113373: RET
// export function CenterOnNow ( unit ) ; begin
113374: LD_INT 0
113376: PPUSH
// result := IsInUnit ( unit ) ;
113377: LD_ADDR_VAR 0 2
113381: PUSH
113382: LD_VAR 0 1
113386: PPUSH
113387: CALL_OW 310
113391: ST_TO_ADDR
// if not result then
113392: LD_VAR 0 2
113396: NOT
113397: IFFALSE 113409
// result := unit ;
113399: LD_ADDR_VAR 0 2
113403: PUSH
113404: LD_VAR 0 1
113408: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
113409: LD_VAR 0 1
113413: PPUSH
113414: CALL_OW 87
// end ;
113418: LD_VAR 0 2
113422: RET
// export function ComMoveHex ( unit , hex ) ; begin
113423: LD_INT 0
113425: PPUSH
// if not hex then
113426: LD_VAR 0 2
113430: NOT
113431: IFFALSE 113435
// exit ;
113433: GO 113488
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
113435: LD_VAR 0 2
113439: PUSH
113440: LD_INT 1
113442: ARRAY
113443: PPUSH
113444: LD_VAR 0 2
113448: PUSH
113449: LD_INT 2
113451: ARRAY
113452: PPUSH
113453: CALL_OW 428
113457: IFFALSE 113461
// exit ;
113459: GO 113488
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
113461: LD_VAR 0 1
113465: PPUSH
113466: LD_VAR 0 2
113470: PUSH
113471: LD_INT 1
113473: ARRAY
113474: PPUSH
113475: LD_VAR 0 2
113479: PUSH
113480: LD_INT 2
113482: ARRAY
113483: PPUSH
113484: CALL_OW 111
// end ;
113488: LD_VAR 0 3
113492: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
113493: LD_INT 0
113495: PPUSH
113496: PPUSH
113497: PPUSH
// if not unit or not enemy then
113498: LD_VAR 0 1
113502: NOT
113503: IFTRUE 113512
113505: PUSH
113506: LD_VAR 0 2
113510: NOT
113511: OR
113512: IFFALSE 113516
// exit ;
113514: GO 113642
// x := GetX ( enemy ) ;
113516: LD_ADDR_VAR 0 4
113520: PUSH
113521: LD_VAR 0 2
113525: PPUSH
113526: CALL_OW 250
113530: ST_TO_ADDR
// y := GetY ( enemy ) ;
113531: LD_ADDR_VAR 0 5
113535: PUSH
113536: LD_VAR 0 2
113540: PPUSH
113541: CALL_OW 251
113545: ST_TO_ADDR
// if ValidHex ( x , y ) then
113546: LD_VAR 0 4
113550: PPUSH
113551: LD_VAR 0 5
113555: PPUSH
113556: CALL_OW 488
113560: IFFALSE 113642
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
113562: LD_VAR 0 2
113566: PPUSH
113567: CALL_OW 247
113571: PUSH
113572: LD_INT 3
113574: PUSH
113575: LD_INT 2
113577: PUSH
113578: EMPTY
113579: LIST
113580: LIST
113581: IN
113582: IFTRUE 113605
113584: PUSH
113585: LD_VAR 0 1
113589: PPUSH
113590: CALL_OW 255
113594: PPUSH
113595: LD_VAR 0 2
113599: PPUSH
113600: CALL_OW 292
113604: OR
113605: IFFALSE 113623
// ComAttackUnit ( unit , enemy ) else
113607: LD_VAR 0 1
113611: PPUSH
113612: LD_VAR 0 2
113616: PPUSH
113617: CALL_OW 115
113621: GO 113642
// ComAgressiveMove ( unit , x , y ) ;
113623: LD_VAR 0 1
113627: PPUSH
113628: LD_VAR 0 4
113632: PPUSH
113633: LD_VAR 0 5
113637: PPUSH
113638: CALL_OW 114
// end ;
113642: LD_VAR 0 3
113646: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
113647: LD_INT 0
113649: PPUSH
113650: PPUSH
113651: PPUSH
// list := AreaToList ( area , 0 ) ;
113652: LD_ADDR_VAR 0 5
113656: PUSH
113657: LD_VAR 0 1
113661: PPUSH
113662: LD_INT 0
113664: PPUSH
113665: CALL_OW 517
113669: ST_TO_ADDR
// if not list then
113670: LD_VAR 0 5
113674: NOT
113675: IFFALSE 113679
// exit ;
113677: GO 113809
// if all then
113679: LD_VAR 0 2
113683: IFFALSE 113771
// begin for i := 1 to list [ 1 ] do
113685: LD_ADDR_VAR 0 4
113689: PUSH
113690: DOUBLE
113691: LD_INT 1
113693: DEC
113694: ST_TO_ADDR
113695: LD_VAR 0 5
113699: PUSH
113700: LD_INT 1
113702: ARRAY
113703: PUSH
113704: FOR_TO
113705: IFFALSE 113767
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
113707: LD_ADDR_VAR 0 3
113711: PUSH
113712: LD_VAR 0 3
113716: PPUSH
113717: LD_VAR 0 3
113721: PUSH
113722: LD_INT 1
113724: PLUS
113725: PPUSH
113726: LD_VAR 0 5
113730: PUSH
113731: LD_INT 1
113733: ARRAY
113734: PUSH
113735: LD_VAR 0 4
113739: ARRAY
113740: PUSH
113741: LD_VAR 0 5
113745: PUSH
113746: LD_INT 2
113748: ARRAY
113749: PUSH
113750: LD_VAR 0 4
113754: ARRAY
113755: PUSH
113756: EMPTY
113757: LIST
113758: LIST
113759: PPUSH
113760: CALL_OW 1
113764: ST_TO_ADDR
113765: GO 113704
113767: POP
113768: POP
// exit ;
113769: GO 113809
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
113771: LD_ADDR_VAR 0 3
113775: PUSH
113776: LD_VAR 0 5
113780: PUSH
113781: LD_INT 1
113783: ARRAY
113784: PUSH
113785: LD_INT 1
113787: ARRAY
113788: PUSH
113789: LD_VAR 0 5
113793: PUSH
113794: LD_INT 2
113796: ARRAY
113797: PUSH
113798: LD_INT 1
113800: ARRAY
113801: PUSH
113802: EMPTY
113803: LIST
113804: LIST
113805: PUSH
113806: EMPTY
113807: LIST
113808: ST_TO_ADDR
// end ;
113809: LD_VAR 0 3
113813: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
113814: LD_INT 0
113816: PPUSH
113817: PPUSH
// list := AreaToList ( area , 0 ) ;
113818: LD_ADDR_VAR 0 4
113822: PUSH
113823: LD_VAR 0 1
113827: PPUSH
113828: LD_INT 0
113830: PPUSH
113831: CALL_OW 517
113835: ST_TO_ADDR
// if not list then
113836: LD_VAR 0 4
113840: NOT
113841: IFFALSE 113845
// exit ;
113843: GO 113886
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
113845: LD_ADDR_VAR 0 3
113849: PUSH
113850: LD_VAR 0 4
113854: PUSH
113855: LD_INT 1
113857: ARRAY
113858: PUSH
113859: LD_INT 1
113861: ARRAY
113862: PUSH
113863: LD_VAR 0 4
113867: PUSH
113868: LD_INT 2
113870: ARRAY
113871: PUSH
113872: LD_INT 1
113874: ARRAY
113875: PUSH
113876: LD_VAR 0 2
113880: PUSH
113881: EMPTY
113882: LIST
113883: LIST
113884: LIST
113885: ST_TO_ADDR
// end ;
113886: LD_VAR 0 3
113890: RET
// export function First ( array ) ; begin
113891: LD_INT 0
113893: PPUSH
// if not array then
113894: LD_VAR 0 1
113898: NOT
113899: IFFALSE 113903
// exit ;
113901: GO 113917
// result := array [ 1 ] ;
113903: LD_ADDR_VAR 0 2
113907: PUSH
113908: LD_VAR 0 1
113912: PUSH
113913: LD_INT 1
113915: ARRAY
113916: ST_TO_ADDR
// end ;
113917: LD_VAR 0 2
113921: RET
// export function Last ( array ) ; begin
113922: LD_INT 0
113924: PPUSH
// if not array then
113925: LD_VAR 0 1
113929: NOT
113930: IFFALSE 113934
// exit ;
113932: GO 113950
// result := array [ array ] ;
113934: LD_ADDR_VAR 0 2
113938: PUSH
113939: LD_VAR 0 1
113943: PUSH
113944: LD_VAR 0 1
113948: ARRAY
113949: ST_TO_ADDR
// end ;
113950: LD_VAR 0 2
113954: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
113955: LD_INT 0
113957: PPUSH
113958: PPUSH
// result := [ ] ;
113959: LD_ADDR_VAR 0 5
113963: PUSH
113964: EMPTY
113965: ST_TO_ADDR
// if not array then
113966: LD_VAR 0 1
113970: NOT
113971: IFFALSE 113975
// exit ;
113973: GO 114087
// for i := 1 to array do
113975: LD_ADDR_VAR 0 6
113979: PUSH
113980: DOUBLE
113981: LD_INT 1
113983: DEC
113984: ST_TO_ADDR
113985: LD_VAR 0 1
113989: PUSH
113990: FOR_TO
113991: IFFALSE 114085
// if array [ i ] [ index ] = value then
113993: LD_VAR 0 1
113997: PUSH
113998: LD_VAR 0 6
114002: ARRAY
114003: PUSH
114004: LD_VAR 0 2
114008: ARRAY
114009: PUSH
114010: LD_VAR 0 3
114014: EQUAL
114015: IFFALSE 114083
// begin if indexColumn then
114017: LD_VAR 0 4
114021: IFFALSE 114057
// result := Join ( result , array [ i ] [ indexColumn ] ) else
114023: LD_ADDR_VAR 0 5
114027: PUSH
114028: LD_VAR 0 5
114032: PPUSH
114033: LD_VAR 0 1
114037: PUSH
114038: LD_VAR 0 6
114042: ARRAY
114043: PUSH
114044: LD_VAR 0 4
114048: ARRAY
114049: PPUSH
114050: CALL 109095 0 2
114054: ST_TO_ADDR
114055: GO 114083
// result := Join ( result , array [ i ] ) ;
114057: LD_ADDR_VAR 0 5
114061: PUSH
114062: LD_VAR 0 5
114066: PPUSH
114067: LD_VAR 0 1
114071: PUSH
114072: LD_VAR 0 6
114076: ARRAY
114077: PPUSH
114078: CALL 109095 0 2
114082: ST_TO_ADDR
// end ;
114083: GO 113990
114085: POP
114086: POP
// end ;
114087: LD_VAR 0 5
114091: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
114092: LD_INT 0
114094: PPUSH
// if not vehicles or not parkingPoint then
114095: LD_VAR 0 1
114099: NOT
114100: IFTRUE 114109
114102: PUSH
114103: LD_VAR 0 2
114107: NOT
114108: OR
114109: IFFALSE 114113
// exit ;
114111: GO 114211
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
114113: LD_ADDR_VAR 0 1
114117: PUSH
114118: LD_VAR 0 1
114122: PPUSH
114123: LD_INT 50
114125: PUSH
114126: EMPTY
114127: LIST
114128: PUSH
114129: LD_INT 3
114131: PUSH
114132: LD_INT 92
114134: PUSH
114135: LD_VAR 0 2
114139: PUSH
114140: LD_INT 1
114142: ARRAY
114143: PUSH
114144: LD_VAR 0 2
114148: PUSH
114149: LD_INT 2
114151: ARRAY
114152: PUSH
114153: LD_INT 8
114155: PUSH
114156: EMPTY
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: PUSH
114162: EMPTY
114163: LIST
114164: LIST
114165: PUSH
114166: EMPTY
114167: LIST
114168: LIST
114169: PPUSH
114170: CALL_OW 72
114174: ST_TO_ADDR
// if not vehicles then
114175: LD_VAR 0 1
114179: NOT
114180: IFFALSE 114184
// exit ;
114182: GO 114211
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
114184: LD_VAR 0 1
114188: PPUSH
114189: LD_VAR 0 2
114193: PUSH
114194: LD_INT 1
114196: ARRAY
114197: PPUSH
114198: LD_VAR 0 2
114202: PUSH
114203: LD_INT 2
114205: ARRAY
114206: PPUSH
114207: CALL_OW 111
// end ;
114211: LD_VAR 0 3
114215: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
114216: LD_INT 0
114218: PPUSH
114219: PPUSH
114220: PPUSH
// if not side or not area then
114221: LD_VAR 0 1
114225: NOT
114226: IFTRUE 114235
114228: PUSH
114229: LD_VAR 0 2
114233: NOT
114234: OR
114235: IFFALSE 114239
// exit ;
114237: GO 114358
// tmp := AreaToList ( area , 0 ) ;
114239: LD_ADDR_VAR 0 5
114243: PUSH
114244: LD_VAR 0 2
114248: PPUSH
114249: LD_INT 0
114251: PPUSH
114252: CALL_OW 517
114256: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
114257: LD_ADDR_VAR 0 4
114261: PUSH
114262: DOUBLE
114263: LD_INT 1
114265: DEC
114266: ST_TO_ADDR
114267: LD_VAR 0 5
114271: PUSH
114272: LD_INT 1
114274: ARRAY
114275: PUSH
114276: FOR_TO
114277: IFFALSE 114356
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
114279: LD_VAR 0 5
114283: PUSH
114284: LD_INT 1
114286: ARRAY
114287: PUSH
114288: LD_VAR 0 4
114292: ARRAY
114293: PPUSH
114294: LD_VAR 0 5
114298: PUSH
114299: LD_INT 2
114301: ARRAY
114302: PUSH
114303: LD_VAR 0 4
114307: ARRAY
114308: PPUSH
114309: CALL_OW 351
114313: IFFALSE 114354
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
114315: LD_VAR 0 5
114319: PUSH
114320: LD_INT 1
114322: ARRAY
114323: PUSH
114324: LD_VAR 0 4
114328: ARRAY
114329: PPUSH
114330: LD_VAR 0 5
114334: PUSH
114335: LD_INT 2
114337: ARRAY
114338: PUSH
114339: LD_VAR 0 4
114343: ARRAY
114344: PPUSH
114345: LD_VAR 0 1
114349: PPUSH
114350: CALL_OW 244
// end ;
114354: GO 114276
114356: POP
114357: POP
// end ;
114358: LD_VAR 0 3
114362: RET
// export function UniqueArray ( array ) ; var i ; begin
114363: LD_INT 0
114365: PPUSH
114366: PPUSH
// result := [ ] ;
114367: LD_ADDR_VAR 0 2
114371: PUSH
114372: EMPTY
114373: ST_TO_ADDR
// if not array then
114374: LD_VAR 0 1
114378: NOT
114379: IFFALSE 114383
// exit ;
114381: GO 114444
// for i := 1 to array do
114383: LD_ADDR_VAR 0 3
114387: PUSH
114388: DOUBLE
114389: LD_INT 1
114391: DEC
114392: ST_TO_ADDR
114393: LD_VAR 0 1
114397: PUSH
114398: FOR_TO
114399: IFFALSE 114442
// if not array [ i ] in result then
114401: LD_VAR 0 1
114405: PUSH
114406: LD_VAR 0 3
114410: ARRAY
114411: PUSH
114412: LD_VAR 0 2
114416: IN
114417: NOT
114418: IFFALSE 114440
// result := Join ( result , i ) ;
114420: LD_ADDR_VAR 0 2
114424: PUSH
114425: LD_VAR 0 2
114429: PPUSH
114430: LD_VAR 0 3
114434: PPUSH
114435: CALL 109095 0 2
114439: ST_TO_ADDR
114440: GO 114398
114442: POP
114443: POP
// end ; end_of_file end_of_file
114444: LD_VAR 0 2
114448: RET
// export globalGameSaveCounter ; every 0 0$1 do
114449: GO 114451
114451: DISABLE
// begin enable ;
114452: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
114453: LD_STRING updateTimer(
114455: PUSH
114456: LD_OWVAR 1
114460: STR
114461: PUSH
114462: LD_STRING );
114464: STR
114465: PPUSH
114466: CALL_OW 559
// end ;
114470: END
// every 0 0$1 do
114471: GO 114473
114473: DISABLE
// begin globalGameSaveCounter := 0 ;
114474: LD_ADDR_EXP 147
114478: PUSH
114479: LD_INT 0
114481: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
114482: LD_STRING setGameSaveCounter(0)
114484: PPUSH
114485: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
114489: LD_STRING initStreamRollete();
114491: PPUSH
114492: CALL_OW 559
// InitStreamMode ;
114496: CALL 115841 0 0
// DefineStreamItems ( false ) ;
114500: LD_INT 0
114502: PPUSH
114503: CALL 116305 0 1
// end ;
114507: END
// export function SOS_MapStart ( ) ; begin
114508: LD_INT 0
114510: PPUSH
// if streamModeActive then
114511: LD_EXP 148
114515: IFFALSE 114524
// DefineStreamItems ( true ) ;
114517: LD_INT 1
114519: PPUSH
114520: CALL 116305 0 1
// UpdateLuaVariables ( ) ;
114524: CALL 114541 0 0
// UpdateFactoryWaypoints ( ) ;
114528: CALL 129427 0 0
// UpdateWarehouseGatheringPoints ( ) ;
114532: CALL 129679 0 0
// end ;
114536: LD_VAR 0 1
114540: RET
// function UpdateLuaVariables ( ) ; begin
114541: LD_INT 0
114543: PPUSH
// if globalGameSaveCounter then
114544: LD_EXP 147
114548: IFFALSE 114582
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
114550: LD_ADDR_EXP 147
114554: PUSH
114555: LD_EXP 147
114559: PPUSH
114560: CALL 110468 0 1
114564: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114565: LD_STRING setGameSaveCounter(
114567: PUSH
114568: LD_EXP 147
114572: STR
114573: PUSH
114574: LD_STRING )
114576: STR
114577: PPUSH
114578: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
114582: LD_STRING setGameDifficulty(
114584: PUSH
114585: LD_OWVAR 67
114589: STR
114590: PUSH
114591: LD_STRING )
114593: STR
114594: PPUSH
114595: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
114599: LD_STRING displayDifficulty(
114601: PUSH
114602: LD_OWVAR 67
114606: STR
114607: PUSH
114608: LD_STRING )
114610: STR
114611: PPUSH
114612: CALL_OW 559
// end ;
114616: LD_VAR 0 1
114620: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
114621: LD_INT 0
114623: PPUSH
// if p2 = stream_mode then
114624: LD_VAR 0 2
114628: PUSH
114629: LD_INT 100
114631: EQUAL
114632: IFFALSE 115635
// begin if not StreamModeActive then
114634: LD_EXP 148
114638: NOT
114639: IFFALSE 114649
// StreamModeActive := true ;
114641: LD_ADDR_EXP 148
114645: PUSH
114646: LD_INT 1
114648: ST_TO_ADDR
// if p3 = 0 then
114649: LD_VAR 0 3
114653: PUSH
114654: LD_INT 0
114656: EQUAL
114657: IFFALSE 114663
// InitStreamMode ;
114659: CALL 115841 0 0
// if p3 = 1 then
114663: LD_VAR 0 3
114667: PUSH
114668: LD_INT 1
114670: EQUAL
114671: IFFALSE 114681
// sRocket := true ;
114673: LD_ADDR_EXP 153
114677: PUSH
114678: LD_INT 1
114680: ST_TO_ADDR
// if p3 = 2 then
114681: LD_VAR 0 3
114685: PUSH
114686: LD_INT 2
114688: EQUAL
114689: IFFALSE 114699
// sSpeed := true ;
114691: LD_ADDR_EXP 152
114695: PUSH
114696: LD_INT 1
114698: ST_TO_ADDR
// if p3 = 3 then
114699: LD_VAR 0 3
114703: PUSH
114704: LD_INT 3
114706: EQUAL
114707: IFFALSE 114717
// sEngine := true ;
114709: LD_ADDR_EXP 154
114713: PUSH
114714: LD_INT 1
114716: ST_TO_ADDR
// if p3 = 4 then
114717: LD_VAR 0 3
114721: PUSH
114722: LD_INT 4
114724: EQUAL
114725: IFFALSE 114735
// sSpec := true ;
114727: LD_ADDR_EXP 151
114731: PUSH
114732: LD_INT 1
114734: ST_TO_ADDR
// if p3 = 5 then
114735: LD_VAR 0 3
114739: PUSH
114740: LD_INT 5
114742: EQUAL
114743: IFFALSE 114753
// sLevel := true ;
114745: LD_ADDR_EXP 155
114749: PUSH
114750: LD_INT 1
114752: ST_TO_ADDR
// if p3 = 6 then
114753: LD_VAR 0 3
114757: PUSH
114758: LD_INT 6
114760: EQUAL
114761: IFFALSE 114771
// sArmoury := true ;
114763: LD_ADDR_EXP 156
114767: PUSH
114768: LD_INT 1
114770: ST_TO_ADDR
// if p3 = 7 then
114771: LD_VAR 0 3
114775: PUSH
114776: LD_INT 7
114778: EQUAL
114779: IFFALSE 114789
// sRadar := true ;
114781: LD_ADDR_EXP 157
114785: PUSH
114786: LD_INT 1
114788: ST_TO_ADDR
// if p3 = 8 then
114789: LD_VAR 0 3
114793: PUSH
114794: LD_INT 8
114796: EQUAL
114797: IFFALSE 114807
// sBunker := true ;
114799: LD_ADDR_EXP 158
114803: PUSH
114804: LD_INT 1
114806: ST_TO_ADDR
// if p3 = 9 then
114807: LD_VAR 0 3
114811: PUSH
114812: LD_INT 9
114814: EQUAL
114815: IFFALSE 114825
// sHack := true ;
114817: LD_ADDR_EXP 159
114821: PUSH
114822: LD_INT 1
114824: ST_TO_ADDR
// if p3 = 10 then
114825: LD_VAR 0 3
114829: PUSH
114830: LD_INT 10
114832: EQUAL
114833: IFFALSE 114843
// sFire := true ;
114835: LD_ADDR_EXP 160
114839: PUSH
114840: LD_INT 1
114842: ST_TO_ADDR
// if p3 = 11 then
114843: LD_VAR 0 3
114847: PUSH
114848: LD_INT 11
114850: EQUAL
114851: IFFALSE 114861
// sRefresh := true ;
114853: LD_ADDR_EXP 161
114857: PUSH
114858: LD_INT 1
114860: ST_TO_ADDR
// if p3 = 12 then
114861: LD_VAR 0 3
114865: PUSH
114866: LD_INT 12
114868: EQUAL
114869: IFFALSE 114879
// sExp := true ;
114871: LD_ADDR_EXP 162
114875: PUSH
114876: LD_INT 1
114878: ST_TO_ADDR
// if p3 = 13 then
114879: LD_VAR 0 3
114883: PUSH
114884: LD_INT 13
114886: EQUAL
114887: IFFALSE 114897
// sDepot := true ;
114889: LD_ADDR_EXP 163
114893: PUSH
114894: LD_INT 1
114896: ST_TO_ADDR
// if p3 = 14 then
114897: LD_VAR 0 3
114901: PUSH
114902: LD_INT 14
114904: EQUAL
114905: IFFALSE 114915
// sFlag := true ;
114907: LD_ADDR_EXP 164
114911: PUSH
114912: LD_INT 1
114914: ST_TO_ADDR
// if p3 = 15 then
114915: LD_VAR 0 3
114919: PUSH
114920: LD_INT 15
114922: EQUAL
114923: IFFALSE 114933
// sKamikadze := true ;
114925: LD_ADDR_EXP 172
114929: PUSH
114930: LD_INT 1
114932: ST_TO_ADDR
// if p3 = 16 then
114933: LD_VAR 0 3
114937: PUSH
114938: LD_INT 16
114940: EQUAL
114941: IFFALSE 114951
// sTroll := true ;
114943: LD_ADDR_EXP 173
114947: PUSH
114948: LD_INT 1
114950: ST_TO_ADDR
// if p3 = 17 then
114951: LD_VAR 0 3
114955: PUSH
114956: LD_INT 17
114958: EQUAL
114959: IFFALSE 114969
// sSlow := true ;
114961: LD_ADDR_EXP 174
114965: PUSH
114966: LD_INT 1
114968: ST_TO_ADDR
// if p3 = 18 then
114969: LD_VAR 0 3
114973: PUSH
114974: LD_INT 18
114976: EQUAL
114977: IFFALSE 114987
// sLack := true ;
114979: LD_ADDR_EXP 175
114983: PUSH
114984: LD_INT 1
114986: ST_TO_ADDR
// if p3 = 19 then
114987: LD_VAR 0 3
114991: PUSH
114992: LD_INT 19
114994: EQUAL
114995: IFFALSE 115005
// sTank := true ;
114997: LD_ADDR_EXP 177
115001: PUSH
115002: LD_INT 1
115004: ST_TO_ADDR
// if p3 = 20 then
115005: LD_VAR 0 3
115009: PUSH
115010: LD_INT 20
115012: EQUAL
115013: IFFALSE 115023
// sRemote := true ;
115015: LD_ADDR_EXP 178
115019: PUSH
115020: LD_INT 1
115022: ST_TO_ADDR
// if p3 = 21 then
115023: LD_VAR 0 3
115027: PUSH
115028: LD_INT 21
115030: EQUAL
115031: IFFALSE 115041
// sPowell := true ;
115033: LD_ADDR_EXP 179
115037: PUSH
115038: LD_INT 1
115040: ST_TO_ADDR
// if p3 = 22 then
115041: LD_VAR 0 3
115045: PUSH
115046: LD_INT 22
115048: EQUAL
115049: IFFALSE 115059
// sTeleport := true ;
115051: LD_ADDR_EXP 182
115055: PUSH
115056: LD_INT 1
115058: ST_TO_ADDR
// if p3 = 23 then
115059: LD_VAR 0 3
115063: PUSH
115064: LD_INT 23
115066: EQUAL
115067: IFFALSE 115077
// sOilTower := true ;
115069: LD_ADDR_EXP 184
115073: PUSH
115074: LD_INT 1
115076: ST_TO_ADDR
// if p3 = 24 then
115077: LD_VAR 0 3
115081: PUSH
115082: LD_INT 24
115084: EQUAL
115085: IFFALSE 115095
// sShovel := true ;
115087: LD_ADDR_EXP 185
115091: PUSH
115092: LD_INT 1
115094: ST_TO_ADDR
// if p3 = 25 then
115095: LD_VAR 0 3
115099: PUSH
115100: LD_INT 25
115102: EQUAL
115103: IFFALSE 115113
// sSheik := true ;
115105: LD_ADDR_EXP 186
115109: PUSH
115110: LD_INT 1
115112: ST_TO_ADDR
// if p3 = 26 then
115113: LD_VAR 0 3
115117: PUSH
115118: LD_INT 26
115120: EQUAL
115121: IFFALSE 115131
// sEarthquake := true ;
115123: LD_ADDR_EXP 188
115127: PUSH
115128: LD_INT 1
115130: ST_TO_ADDR
// if p3 = 27 then
115131: LD_VAR 0 3
115135: PUSH
115136: LD_INT 27
115138: EQUAL
115139: IFFALSE 115149
// sAI := true ;
115141: LD_ADDR_EXP 189
115145: PUSH
115146: LD_INT 1
115148: ST_TO_ADDR
// if p3 = 28 then
115149: LD_VAR 0 3
115153: PUSH
115154: LD_INT 28
115156: EQUAL
115157: IFFALSE 115167
// sCargo := true ;
115159: LD_ADDR_EXP 192
115163: PUSH
115164: LD_INT 1
115166: ST_TO_ADDR
// if p3 = 29 then
115167: LD_VAR 0 3
115171: PUSH
115172: LD_INT 29
115174: EQUAL
115175: IFFALSE 115185
// sDLaser := true ;
115177: LD_ADDR_EXP 193
115181: PUSH
115182: LD_INT 1
115184: ST_TO_ADDR
// if p3 = 30 then
115185: LD_VAR 0 3
115189: PUSH
115190: LD_INT 30
115192: EQUAL
115193: IFFALSE 115203
// sExchange := true ;
115195: LD_ADDR_EXP 194
115199: PUSH
115200: LD_INT 1
115202: ST_TO_ADDR
// if p3 = 31 then
115203: LD_VAR 0 3
115207: PUSH
115208: LD_INT 31
115210: EQUAL
115211: IFFALSE 115221
// sFac := true ;
115213: LD_ADDR_EXP 195
115217: PUSH
115218: LD_INT 1
115220: ST_TO_ADDR
// if p3 = 32 then
115221: LD_VAR 0 3
115225: PUSH
115226: LD_INT 32
115228: EQUAL
115229: IFFALSE 115239
// sPower := true ;
115231: LD_ADDR_EXP 196
115235: PUSH
115236: LD_INT 1
115238: ST_TO_ADDR
// if p3 = 33 then
115239: LD_VAR 0 3
115243: PUSH
115244: LD_INT 33
115246: EQUAL
115247: IFFALSE 115257
// sRandom := true ;
115249: LD_ADDR_EXP 197
115253: PUSH
115254: LD_INT 1
115256: ST_TO_ADDR
// if p3 = 34 then
115257: LD_VAR 0 3
115261: PUSH
115262: LD_INT 34
115264: EQUAL
115265: IFFALSE 115275
// sShield := true ;
115267: LD_ADDR_EXP 198
115271: PUSH
115272: LD_INT 1
115274: ST_TO_ADDR
// if p3 = 35 then
115275: LD_VAR 0 3
115279: PUSH
115280: LD_INT 35
115282: EQUAL
115283: IFFALSE 115293
// sTime := true ;
115285: LD_ADDR_EXP 199
115289: PUSH
115290: LD_INT 1
115292: ST_TO_ADDR
// if p3 = 36 then
115293: LD_VAR 0 3
115297: PUSH
115298: LD_INT 36
115300: EQUAL
115301: IFFALSE 115311
// sTools := true ;
115303: LD_ADDR_EXP 200
115307: PUSH
115308: LD_INT 1
115310: ST_TO_ADDR
// if p3 = 101 then
115311: LD_VAR 0 3
115315: PUSH
115316: LD_INT 101
115318: EQUAL
115319: IFFALSE 115329
// sSold := true ;
115321: LD_ADDR_EXP 165
115325: PUSH
115326: LD_INT 1
115328: ST_TO_ADDR
// if p3 = 102 then
115329: LD_VAR 0 3
115333: PUSH
115334: LD_INT 102
115336: EQUAL
115337: IFFALSE 115347
// sDiff := true ;
115339: LD_ADDR_EXP 166
115343: PUSH
115344: LD_INT 1
115346: ST_TO_ADDR
// if p3 = 103 then
115347: LD_VAR 0 3
115351: PUSH
115352: LD_INT 103
115354: EQUAL
115355: IFFALSE 115365
// sFog := true ;
115357: LD_ADDR_EXP 169
115361: PUSH
115362: LD_INT 1
115364: ST_TO_ADDR
// if p3 = 104 then
115365: LD_VAR 0 3
115369: PUSH
115370: LD_INT 104
115372: EQUAL
115373: IFFALSE 115383
// sReset := true ;
115375: LD_ADDR_EXP 170
115379: PUSH
115380: LD_INT 1
115382: ST_TO_ADDR
// if p3 = 105 then
115383: LD_VAR 0 3
115387: PUSH
115388: LD_INT 105
115390: EQUAL
115391: IFFALSE 115401
// sSun := true ;
115393: LD_ADDR_EXP 171
115397: PUSH
115398: LD_INT 1
115400: ST_TO_ADDR
// if p3 = 106 then
115401: LD_VAR 0 3
115405: PUSH
115406: LD_INT 106
115408: EQUAL
115409: IFFALSE 115419
// sTiger := true ;
115411: LD_ADDR_EXP 167
115415: PUSH
115416: LD_INT 1
115418: ST_TO_ADDR
// if p3 = 107 then
115419: LD_VAR 0 3
115423: PUSH
115424: LD_INT 107
115426: EQUAL
115427: IFFALSE 115437
// sBomb := true ;
115429: LD_ADDR_EXP 168
115433: PUSH
115434: LD_INT 1
115436: ST_TO_ADDR
// if p3 = 108 then
115437: LD_VAR 0 3
115441: PUSH
115442: LD_INT 108
115444: EQUAL
115445: IFFALSE 115455
// sWound := true ;
115447: LD_ADDR_EXP 176
115451: PUSH
115452: LD_INT 1
115454: ST_TO_ADDR
// if p3 = 109 then
115455: LD_VAR 0 3
115459: PUSH
115460: LD_INT 109
115462: EQUAL
115463: IFFALSE 115473
// sBetray := true ;
115465: LD_ADDR_EXP 180
115469: PUSH
115470: LD_INT 1
115472: ST_TO_ADDR
// if p3 = 110 then
115473: LD_VAR 0 3
115477: PUSH
115478: LD_INT 110
115480: EQUAL
115481: IFFALSE 115491
// sContamin := true ;
115483: LD_ADDR_EXP 181
115487: PUSH
115488: LD_INT 1
115490: ST_TO_ADDR
// if p3 = 111 then
115491: LD_VAR 0 3
115495: PUSH
115496: LD_INT 111
115498: EQUAL
115499: IFFALSE 115509
// sOil := true ;
115501: LD_ADDR_EXP 183
115505: PUSH
115506: LD_INT 1
115508: ST_TO_ADDR
// if p3 = 112 then
115509: LD_VAR 0 3
115513: PUSH
115514: LD_INT 112
115516: EQUAL
115517: IFFALSE 115527
// sStu := true ;
115519: LD_ADDR_EXP 187
115523: PUSH
115524: LD_INT 1
115526: ST_TO_ADDR
// if p3 = 113 then
115527: LD_VAR 0 3
115531: PUSH
115532: LD_INT 113
115534: EQUAL
115535: IFFALSE 115545
// sBazooka := true ;
115537: LD_ADDR_EXP 190
115541: PUSH
115542: LD_INT 1
115544: ST_TO_ADDR
// if p3 = 114 then
115545: LD_VAR 0 3
115549: PUSH
115550: LD_INT 114
115552: EQUAL
115553: IFFALSE 115563
// sMortar := true ;
115555: LD_ADDR_EXP 191
115559: PUSH
115560: LD_INT 1
115562: ST_TO_ADDR
// if p3 = 115 then
115563: LD_VAR 0 3
115567: PUSH
115568: LD_INT 115
115570: EQUAL
115571: IFFALSE 115581
// sRanger := true ;
115573: LD_ADDR_EXP 201
115577: PUSH
115578: LD_INT 1
115580: ST_TO_ADDR
// if p3 = 116 then
115581: LD_VAR 0 3
115585: PUSH
115586: LD_INT 116
115588: EQUAL
115589: IFFALSE 115599
// sComputer := true ;
115591: LD_ADDR_EXP 202
115595: PUSH
115596: LD_INT 1
115598: ST_TO_ADDR
// if p3 = 117 then
115599: LD_VAR 0 3
115603: PUSH
115604: LD_INT 117
115606: EQUAL
115607: IFFALSE 115617
// s30 := true ;
115609: LD_ADDR_EXP 203
115613: PUSH
115614: LD_INT 1
115616: ST_TO_ADDR
// if p3 = 118 then
115617: LD_VAR 0 3
115621: PUSH
115622: LD_INT 118
115624: EQUAL
115625: IFFALSE 115635
// s60 := true ;
115627: LD_ADDR_EXP 204
115631: PUSH
115632: LD_INT 1
115634: ST_TO_ADDR
// end ; if p2 = hack_mode then
115635: LD_VAR 0 2
115639: PUSH
115640: LD_INT 101
115642: EQUAL
115643: IFFALSE 115771
// begin case p3 of 1 :
115645: LD_VAR 0 3
115649: PUSH
115650: LD_INT 1
115652: DOUBLE
115653: EQUAL
115654: IFTRUE 115658
115656: GO 115665
115658: POP
// hHackUnlimitedResources ; 2 :
115659: CALL 128034 0 0
115663: GO 115771
115665: LD_INT 2
115667: DOUBLE
115668: EQUAL
115669: IFTRUE 115673
115671: GO 115680
115673: POP
// hHackSetLevel10 ; 3 :
115674: CALL 128167 0 0
115678: GO 115771
115680: LD_INT 3
115682: DOUBLE
115683: EQUAL
115684: IFTRUE 115688
115686: GO 115695
115688: POP
// hHackSetLevel10YourUnits ; 4 :
115689: CALL 128252 0 0
115693: GO 115771
115695: LD_INT 4
115697: DOUBLE
115698: EQUAL
115699: IFTRUE 115703
115701: GO 115710
115703: POP
// hHackInvincible ; 5 :
115704: CALL 128700 0 0
115708: GO 115771
115710: LD_INT 5
115712: DOUBLE
115713: EQUAL
115714: IFTRUE 115718
115716: GO 115725
115718: POP
// hHackInvisible ; 6 :
115719: CALL 128811 0 0
115723: GO 115771
115725: LD_INT 6
115727: DOUBLE
115728: EQUAL
115729: IFTRUE 115733
115731: GO 115740
115733: POP
// hHackChangeYourSide ; 7 :
115734: CALL 128868 0 0
115738: GO 115771
115740: LD_INT 7
115742: DOUBLE
115743: EQUAL
115744: IFTRUE 115748
115746: GO 115755
115748: POP
// hHackChangeUnitSide ; 8 :
115749: CALL 128910 0 0
115753: GO 115771
115755: LD_INT 8
115757: DOUBLE
115758: EQUAL
115759: IFTRUE 115763
115761: GO 115770
115763: POP
// hHackFog ; end ;
115764: CALL 129011 0 0
115768: GO 115771
115770: POP
// end ; if p2 = game_save_mode then
115771: LD_VAR 0 2
115775: PUSH
115776: LD_INT 102
115778: EQUAL
115779: IFFALSE 115836
// begin if p3 = 1 then
115781: LD_VAR 0 3
115785: PUSH
115786: LD_INT 1
115788: EQUAL
115789: IFFALSE 115801
// globalGameSaveCounter := p4 ;
115791: LD_ADDR_EXP 147
115795: PUSH
115796: LD_VAR 0 4
115800: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
115801: LD_VAR 0 3
115805: PUSH
115806: LD_INT 2
115808: EQUAL
115809: IFFALSE 115817
115811: PUSH
115812: LD_EXP 147
115816: AND
115817: IFFALSE 115836
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
115819: LD_STRING setGameSaveCounter(
115821: PUSH
115822: LD_EXP 147
115826: STR
115827: PUSH
115828: LD_STRING )
115830: STR
115831: PPUSH
115832: CALL_OW 559
// end ; end ;
115836: LD_VAR 0 7
115840: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
115841: LD_INT 0
115843: PPUSH
// streamModeActive := false ;
115844: LD_ADDR_EXP 148
115848: PUSH
115849: LD_INT 0
115851: ST_TO_ADDR
// normalCounter := 36 ;
115852: LD_ADDR_EXP 149
115856: PUSH
115857: LD_INT 36
115859: ST_TO_ADDR
// hardcoreCounter := 18 ;
115860: LD_ADDR_EXP 150
115864: PUSH
115865: LD_INT 18
115867: ST_TO_ADDR
// sRocket := false ;
115868: LD_ADDR_EXP 153
115872: PUSH
115873: LD_INT 0
115875: ST_TO_ADDR
// sSpeed := false ;
115876: LD_ADDR_EXP 152
115880: PUSH
115881: LD_INT 0
115883: ST_TO_ADDR
// sEngine := false ;
115884: LD_ADDR_EXP 154
115888: PUSH
115889: LD_INT 0
115891: ST_TO_ADDR
// sSpec := false ;
115892: LD_ADDR_EXP 151
115896: PUSH
115897: LD_INT 0
115899: ST_TO_ADDR
// sLevel := false ;
115900: LD_ADDR_EXP 155
115904: PUSH
115905: LD_INT 0
115907: ST_TO_ADDR
// sArmoury := false ;
115908: LD_ADDR_EXP 156
115912: PUSH
115913: LD_INT 0
115915: ST_TO_ADDR
// sRadar := false ;
115916: LD_ADDR_EXP 157
115920: PUSH
115921: LD_INT 0
115923: ST_TO_ADDR
// sBunker := false ;
115924: LD_ADDR_EXP 158
115928: PUSH
115929: LD_INT 0
115931: ST_TO_ADDR
// sHack := false ;
115932: LD_ADDR_EXP 159
115936: PUSH
115937: LD_INT 0
115939: ST_TO_ADDR
// sFire := false ;
115940: LD_ADDR_EXP 160
115944: PUSH
115945: LD_INT 0
115947: ST_TO_ADDR
// sRefresh := false ;
115948: LD_ADDR_EXP 161
115952: PUSH
115953: LD_INT 0
115955: ST_TO_ADDR
// sExp := false ;
115956: LD_ADDR_EXP 162
115960: PUSH
115961: LD_INT 0
115963: ST_TO_ADDR
// sDepot := false ;
115964: LD_ADDR_EXP 163
115968: PUSH
115969: LD_INT 0
115971: ST_TO_ADDR
// sFlag := false ;
115972: LD_ADDR_EXP 164
115976: PUSH
115977: LD_INT 0
115979: ST_TO_ADDR
// sKamikadze := false ;
115980: LD_ADDR_EXP 172
115984: PUSH
115985: LD_INT 0
115987: ST_TO_ADDR
// sTroll := false ;
115988: LD_ADDR_EXP 173
115992: PUSH
115993: LD_INT 0
115995: ST_TO_ADDR
// sSlow := false ;
115996: LD_ADDR_EXP 174
116000: PUSH
116001: LD_INT 0
116003: ST_TO_ADDR
// sLack := false ;
116004: LD_ADDR_EXP 175
116008: PUSH
116009: LD_INT 0
116011: ST_TO_ADDR
// sTank := false ;
116012: LD_ADDR_EXP 177
116016: PUSH
116017: LD_INT 0
116019: ST_TO_ADDR
// sRemote := false ;
116020: LD_ADDR_EXP 178
116024: PUSH
116025: LD_INT 0
116027: ST_TO_ADDR
// sPowell := false ;
116028: LD_ADDR_EXP 179
116032: PUSH
116033: LD_INT 0
116035: ST_TO_ADDR
// sTeleport := false ;
116036: LD_ADDR_EXP 182
116040: PUSH
116041: LD_INT 0
116043: ST_TO_ADDR
// sOilTower := false ;
116044: LD_ADDR_EXP 184
116048: PUSH
116049: LD_INT 0
116051: ST_TO_ADDR
// sShovel := false ;
116052: LD_ADDR_EXP 185
116056: PUSH
116057: LD_INT 0
116059: ST_TO_ADDR
// sSheik := false ;
116060: LD_ADDR_EXP 186
116064: PUSH
116065: LD_INT 0
116067: ST_TO_ADDR
// sEarthquake := false ;
116068: LD_ADDR_EXP 188
116072: PUSH
116073: LD_INT 0
116075: ST_TO_ADDR
// sAI := false ;
116076: LD_ADDR_EXP 189
116080: PUSH
116081: LD_INT 0
116083: ST_TO_ADDR
// sCargo := false ;
116084: LD_ADDR_EXP 192
116088: PUSH
116089: LD_INT 0
116091: ST_TO_ADDR
// sDLaser := false ;
116092: LD_ADDR_EXP 193
116096: PUSH
116097: LD_INT 0
116099: ST_TO_ADDR
// sExchange := false ;
116100: LD_ADDR_EXP 194
116104: PUSH
116105: LD_INT 0
116107: ST_TO_ADDR
// sFac := false ;
116108: LD_ADDR_EXP 195
116112: PUSH
116113: LD_INT 0
116115: ST_TO_ADDR
// sPower := false ;
116116: LD_ADDR_EXP 196
116120: PUSH
116121: LD_INT 0
116123: ST_TO_ADDR
// sRandom := false ;
116124: LD_ADDR_EXP 197
116128: PUSH
116129: LD_INT 0
116131: ST_TO_ADDR
// sShield := false ;
116132: LD_ADDR_EXP 198
116136: PUSH
116137: LD_INT 0
116139: ST_TO_ADDR
// sTime := false ;
116140: LD_ADDR_EXP 199
116144: PUSH
116145: LD_INT 0
116147: ST_TO_ADDR
// sTools := false ;
116148: LD_ADDR_EXP 200
116152: PUSH
116153: LD_INT 0
116155: ST_TO_ADDR
// sSold := false ;
116156: LD_ADDR_EXP 165
116160: PUSH
116161: LD_INT 0
116163: ST_TO_ADDR
// sDiff := false ;
116164: LD_ADDR_EXP 166
116168: PUSH
116169: LD_INT 0
116171: ST_TO_ADDR
// sFog := false ;
116172: LD_ADDR_EXP 169
116176: PUSH
116177: LD_INT 0
116179: ST_TO_ADDR
// sReset := false ;
116180: LD_ADDR_EXP 170
116184: PUSH
116185: LD_INT 0
116187: ST_TO_ADDR
// sSun := false ;
116188: LD_ADDR_EXP 171
116192: PUSH
116193: LD_INT 0
116195: ST_TO_ADDR
// sTiger := false ;
116196: LD_ADDR_EXP 167
116200: PUSH
116201: LD_INT 0
116203: ST_TO_ADDR
// sBomb := false ;
116204: LD_ADDR_EXP 168
116208: PUSH
116209: LD_INT 0
116211: ST_TO_ADDR
// sWound := false ;
116212: LD_ADDR_EXP 176
116216: PUSH
116217: LD_INT 0
116219: ST_TO_ADDR
// sBetray := false ;
116220: LD_ADDR_EXP 180
116224: PUSH
116225: LD_INT 0
116227: ST_TO_ADDR
// sContamin := false ;
116228: LD_ADDR_EXP 181
116232: PUSH
116233: LD_INT 0
116235: ST_TO_ADDR
// sOil := false ;
116236: LD_ADDR_EXP 183
116240: PUSH
116241: LD_INT 0
116243: ST_TO_ADDR
// sStu := false ;
116244: LD_ADDR_EXP 187
116248: PUSH
116249: LD_INT 0
116251: ST_TO_ADDR
// sBazooka := false ;
116252: LD_ADDR_EXP 190
116256: PUSH
116257: LD_INT 0
116259: ST_TO_ADDR
// sMortar := false ;
116260: LD_ADDR_EXP 191
116264: PUSH
116265: LD_INT 0
116267: ST_TO_ADDR
// sRanger := false ;
116268: LD_ADDR_EXP 201
116272: PUSH
116273: LD_INT 0
116275: ST_TO_ADDR
// sComputer := false ;
116276: LD_ADDR_EXP 202
116280: PUSH
116281: LD_INT 0
116283: ST_TO_ADDR
// s30 := false ;
116284: LD_ADDR_EXP 203
116288: PUSH
116289: LD_INT 0
116291: ST_TO_ADDR
// s60 := false ;
116292: LD_ADDR_EXP 204
116296: PUSH
116297: LD_INT 0
116299: ST_TO_ADDR
// end ;
116300: LD_VAR 0 1
116304: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
116305: LD_INT 0
116307: PPUSH
116308: PPUSH
116309: PPUSH
116310: PPUSH
116311: PPUSH
116312: PPUSH
116313: PPUSH
// result := [ ] ;
116314: LD_ADDR_VAR 0 2
116318: PUSH
116319: EMPTY
116320: ST_TO_ADDR
// if campaign_id = 1 then
116321: LD_OWVAR 69
116325: PUSH
116326: LD_INT 1
116328: EQUAL
116329: IFFALSE 119495
// begin case mission_number of 1 :
116331: LD_OWVAR 70
116335: PUSH
116336: LD_INT 1
116338: DOUBLE
116339: EQUAL
116340: IFTRUE 116344
116342: GO 116420
116344: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
116345: LD_ADDR_VAR 0 2
116349: PUSH
116350: LD_INT 2
116352: PUSH
116353: LD_INT 4
116355: PUSH
116356: LD_INT 11
116358: PUSH
116359: LD_INT 12
116361: PUSH
116362: LD_INT 15
116364: PUSH
116365: LD_INT 16
116367: PUSH
116368: LD_INT 22
116370: PUSH
116371: LD_INT 23
116373: PUSH
116374: LD_INT 26
116376: PUSH
116377: EMPTY
116378: LIST
116379: LIST
116380: LIST
116381: LIST
116382: LIST
116383: LIST
116384: LIST
116385: LIST
116386: LIST
116387: PUSH
116388: LD_INT 101
116390: PUSH
116391: LD_INT 102
116393: PUSH
116394: LD_INT 106
116396: PUSH
116397: LD_INT 116
116399: PUSH
116400: LD_INT 117
116402: PUSH
116403: LD_INT 118
116405: PUSH
116406: EMPTY
116407: LIST
116408: LIST
116409: LIST
116410: LIST
116411: LIST
116412: LIST
116413: PUSH
116414: EMPTY
116415: LIST
116416: LIST
116417: ST_TO_ADDR
116418: GO 119493
116420: LD_INT 2
116422: DOUBLE
116423: EQUAL
116424: IFTRUE 116428
116426: GO 116512
116428: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
116429: LD_ADDR_VAR 0 2
116433: PUSH
116434: LD_INT 2
116436: PUSH
116437: LD_INT 4
116439: PUSH
116440: LD_INT 11
116442: PUSH
116443: LD_INT 12
116445: PUSH
116446: LD_INT 15
116448: PUSH
116449: LD_INT 16
116451: PUSH
116452: LD_INT 22
116454: PUSH
116455: LD_INT 23
116457: PUSH
116458: LD_INT 26
116460: PUSH
116461: EMPTY
116462: LIST
116463: LIST
116464: LIST
116465: LIST
116466: LIST
116467: LIST
116468: LIST
116469: LIST
116470: LIST
116471: PUSH
116472: LD_INT 101
116474: PUSH
116475: LD_INT 102
116477: PUSH
116478: LD_INT 105
116480: PUSH
116481: LD_INT 106
116483: PUSH
116484: LD_INT 108
116486: PUSH
116487: LD_INT 116
116489: PUSH
116490: LD_INT 117
116492: PUSH
116493: LD_INT 118
116495: PUSH
116496: EMPTY
116497: LIST
116498: LIST
116499: LIST
116500: LIST
116501: LIST
116502: LIST
116503: LIST
116504: LIST
116505: PUSH
116506: EMPTY
116507: LIST
116508: LIST
116509: ST_TO_ADDR
116510: GO 119493
116512: LD_INT 3
116514: DOUBLE
116515: EQUAL
116516: IFTRUE 116520
116518: GO 116608
116520: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
116521: LD_ADDR_VAR 0 2
116525: PUSH
116526: LD_INT 2
116528: PUSH
116529: LD_INT 4
116531: PUSH
116532: LD_INT 5
116534: PUSH
116535: LD_INT 11
116537: PUSH
116538: LD_INT 12
116540: PUSH
116541: LD_INT 15
116543: PUSH
116544: LD_INT 16
116546: PUSH
116547: LD_INT 22
116549: PUSH
116550: LD_INT 26
116552: PUSH
116553: LD_INT 36
116555: PUSH
116556: EMPTY
116557: LIST
116558: LIST
116559: LIST
116560: LIST
116561: LIST
116562: LIST
116563: LIST
116564: LIST
116565: LIST
116566: LIST
116567: PUSH
116568: LD_INT 101
116570: PUSH
116571: LD_INT 102
116573: PUSH
116574: LD_INT 105
116576: PUSH
116577: LD_INT 106
116579: PUSH
116580: LD_INT 108
116582: PUSH
116583: LD_INT 116
116585: PUSH
116586: LD_INT 117
116588: PUSH
116589: LD_INT 118
116591: PUSH
116592: EMPTY
116593: LIST
116594: LIST
116595: LIST
116596: LIST
116597: LIST
116598: LIST
116599: LIST
116600: LIST
116601: PUSH
116602: EMPTY
116603: LIST
116604: LIST
116605: ST_TO_ADDR
116606: GO 119493
116608: LD_INT 4
116610: DOUBLE
116611: EQUAL
116612: IFTRUE 116616
116614: GO 116712
116616: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
116617: LD_ADDR_VAR 0 2
116621: PUSH
116622: LD_INT 2
116624: PUSH
116625: LD_INT 4
116627: PUSH
116628: LD_INT 5
116630: PUSH
116631: LD_INT 8
116633: PUSH
116634: LD_INT 11
116636: PUSH
116637: LD_INT 12
116639: PUSH
116640: LD_INT 15
116642: PUSH
116643: LD_INT 16
116645: PUSH
116646: LD_INT 22
116648: PUSH
116649: LD_INT 23
116651: PUSH
116652: LD_INT 26
116654: PUSH
116655: LD_INT 36
116657: PUSH
116658: EMPTY
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: PUSH
116672: LD_INT 101
116674: PUSH
116675: LD_INT 102
116677: PUSH
116678: LD_INT 105
116680: PUSH
116681: LD_INT 106
116683: PUSH
116684: LD_INT 108
116686: PUSH
116687: LD_INT 116
116689: PUSH
116690: LD_INT 117
116692: PUSH
116693: LD_INT 118
116695: PUSH
116696: EMPTY
116697: LIST
116698: LIST
116699: LIST
116700: LIST
116701: LIST
116702: LIST
116703: LIST
116704: LIST
116705: PUSH
116706: EMPTY
116707: LIST
116708: LIST
116709: ST_TO_ADDR
116710: GO 119493
116712: LD_INT 5
116714: DOUBLE
116715: EQUAL
116716: IFTRUE 116720
116718: GO 116832
116720: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
116721: LD_ADDR_VAR 0 2
116725: PUSH
116726: LD_INT 2
116728: PUSH
116729: LD_INT 4
116731: PUSH
116732: LD_INT 5
116734: PUSH
116735: LD_INT 6
116737: PUSH
116738: LD_INT 8
116740: PUSH
116741: LD_INT 11
116743: PUSH
116744: LD_INT 12
116746: PUSH
116747: LD_INT 15
116749: PUSH
116750: LD_INT 16
116752: PUSH
116753: LD_INT 22
116755: PUSH
116756: LD_INT 23
116758: PUSH
116759: LD_INT 25
116761: PUSH
116762: LD_INT 26
116764: PUSH
116765: LD_INT 36
116767: PUSH
116768: EMPTY
116769: LIST
116770: LIST
116771: LIST
116772: LIST
116773: LIST
116774: LIST
116775: LIST
116776: LIST
116777: LIST
116778: LIST
116779: LIST
116780: LIST
116781: LIST
116782: LIST
116783: PUSH
116784: LD_INT 101
116786: PUSH
116787: LD_INT 102
116789: PUSH
116790: LD_INT 105
116792: PUSH
116793: LD_INT 106
116795: PUSH
116796: LD_INT 108
116798: PUSH
116799: LD_INT 109
116801: PUSH
116802: LD_INT 112
116804: PUSH
116805: LD_INT 116
116807: PUSH
116808: LD_INT 117
116810: PUSH
116811: LD_INT 118
116813: PUSH
116814: EMPTY
116815: LIST
116816: LIST
116817: LIST
116818: LIST
116819: LIST
116820: LIST
116821: LIST
116822: LIST
116823: LIST
116824: LIST
116825: PUSH
116826: EMPTY
116827: LIST
116828: LIST
116829: ST_TO_ADDR
116830: GO 119493
116832: LD_INT 6
116834: DOUBLE
116835: EQUAL
116836: IFTRUE 116840
116838: GO 116972
116840: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
116841: LD_ADDR_VAR 0 2
116845: PUSH
116846: LD_INT 2
116848: PUSH
116849: LD_INT 4
116851: PUSH
116852: LD_INT 5
116854: PUSH
116855: LD_INT 6
116857: PUSH
116858: LD_INT 8
116860: PUSH
116861: LD_INT 11
116863: PUSH
116864: LD_INT 12
116866: PUSH
116867: LD_INT 15
116869: PUSH
116870: LD_INT 16
116872: PUSH
116873: LD_INT 20
116875: PUSH
116876: LD_INT 21
116878: PUSH
116879: LD_INT 22
116881: PUSH
116882: LD_INT 23
116884: PUSH
116885: LD_INT 25
116887: PUSH
116888: LD_INT 26
116890: PUSH
116891: LD_INT 30
116893: PUSH
116894: LD_INT 31
116896: PUSH
116897: LD_INT 32
116899: PUSH
116900: LD_INT 36
116902: PUSH
116903: EMPTY
116904: LIST
116905: LIST
116906: LIST
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: LIST
116912: LIST
116913: LIST
116914: LIST
116915: LIST
116916: LIST
116917: LIST
116918: LIST
116919: LIST
116920: LIST
116921: LIST
116922: LIST
116923: PUSH
116924: LD_INT 101
116926: PUSH
116927: LD_INT 102
116929: PUSH
116930: LD_INT 105
116932: PUSH
116933: LD_INT 106
116935: PUSH
116936: LD_INT 108
116938: PUSH
116939: LD_INT 109
116941: PUSH
116942: LD_INT 112
116944: PUSH
116945: LD_INT 116
116947: PUSH
116948: LD_INT 117
116950: PUSH
116951: LD_INT 118
116953: PUSH
116954: EMPTY
116955: LIST
116956: LIST
116957: LIST
116958: LIST
116959: LIST
116960: LIST
116961: LIST
116962: LIST
116963: LIST
116964: LIST
116965: PUSH
116966: EMPTY
116967: LIST
116968: LIST
116969: ST_TO_ADDR
116970: GO 119493
116972: LD_INT 7
116974: DOUBLE
116975: EQUAL
116976: IFTRUE 116980
116978: GO 117092
116980: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
116981: LD_ADDR_VAR 0 2
116985: PUSH
116986: LD_INT 2
116988: PUSH
116989: LD_INT 4
116991: PUSH
116992: LD_INT 5
116994: PUSH
116995: LD_INT 7
116997: PUSH
116998: LD_INT 11
117000: PUSH
117001: LD_INT 12
117003: PUSH
117004: LD_INT 15
117006: PUSH
117007: LD_INT 16
117009: PUSH
117010: LD_INT 20
117012: PUSH
117013: LD_INT 21
117015: PUSH
117016: LD_INT 22
117018: PUSH
117019: LD_INT 23
117021: PUSH
117022: LD_INT 25
117024: PUSH
117025: LD_INT 26
117027: PUSH
117028: EMPTY
117029: LIST
117030: LIST
117031: LIST
117032: LIST
117033: LIST
117034: LIST
117035: LIST
117036: LIST
117037: LIST
117038: LIST
117039: LIST
117040: LIST
117041: LIST
117042: LIST
117043: PUSH
117044: LD_INT 101
117046: PUSH
117047: LD_INT 102
117049: PUSH
117050: LD_INT 103
117052: PUSH
117053: LD_INT 105
117055: PUSH
117056: LD_INT 106
117058: PUSH
117059: LD_INT 108
117061: PUSH
117062: LD_INT 112
117064: PUSH
117065: LD_INT 116
117067: PUSH
117068: LD_INT 117
117070: PUSH
117071: LD_INT 118
117073: PUSH
117074: EMPTY
117075: LIST
117076: LIST
117077: LIST
117078: LIST
117079: LIST
117080: LIST
117081: LIST
117082: LIST
117083: LIST
117084: LIST
117085: PUSH
117086: EMPTY
117087: LIST
117088: LIST
117089: ST_TO_ADDR
117090: GO 119493
117092: LD_INT 8
117094: DOUBLE
117095: EQUAL
117096: IFTRUE 117100
117098: GO 117240
117100: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
117101: LD_ADDR_VAR 0 2
117105: PUSH
117106: LD_INT 2
117108: PUSH
117109: LD_INT 4
117111: PUSH
117112: LD_INT 5
117114: PUSH
117115: LD_INT 6
117117: PUSH
117118: LD_INT 7
117120: PUSH
117121: LD_INT 8
117123: PUSH
117124: LD_INT 11
117126: PUSH
117127: LD_INT 12
117129: PUSH
117130: LD_INT 15
117132: PUSH
117133: LD_INT 16
117135: PUSH
117136: LD_INT 20
117138: PUSH
117139: LD_INT 21
117141: PUSH
117142: LD_INT 22
117144: PUSH
117145: LD_INT 23
117147: PUSH
117148: LD_INT 25
117150: PUSH
117151: LD_INT 26
117153: PUSH
117154: LD_INT 30
117156: PUSH
117157: LD_INT 31
117159: PUSH
117160: LD_INT 32
117162: PUSH
117163: LD_INT 36
117165: PUSH
117166: EMPTY
117167: LIST
117168: LIST
117169: LIST
117170: LIST
117171: LIST
117172: LIST
117173: LIST
117174: LIST
117175: LIST
117176: LIST
117177: LIST
117178: LIST
117179: LIST
117180: LIST
117181: LIST
117182: LIST
117183: LIST
117184: LIST
117185: LIST
117186: LIST
117187: PUSH
117188: LD_INT 101
117190: PUSH
117191: LD_INT 102
117193: PUSH
117194: LD_INT 103
117196: PUSH
117197: LD_INT 105
117199: PUSH
117200: LD_INT 106
117202: PUSH
117203: LD_INT 108
117205: PUSH
117206: LD_INT 109
117208: PUSH
117209: LD_INT 112
117211: PUSH
117212: LD_INT 116
117214: PUSH
117215: LD_INT 117
117217: PUSH
117218: LD_INT 118
117220: PUSH
117221: EMPTY
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: PUSH
117234: EMPTY
117235: LIST
117236: LIST
117237: ST_TO_ADDR
117238: GO 119493
117240: LD_INT 9
117242: DOUBLE
117243: EQUAL
117244: IFTRUE 117248
117246: GO 117396
117248: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
117249: LD_ADDR_VAR 0 2
117253: PUSH
117254: LD_INT 2
117256: PUSH
117257: LD_INT 4
117259: PUSH
117260: LD_INT 5
117262: PUSH
117263: LD_INT 6
117265: PUSH
117266: LD_INT 7
117268: PUSH
117269: LD_INT 8
117271: PUSH
117272: LD_INT 11
117274: PUSH
117275: LD_INT 12
117277: PUSH
117278: LD_INT 15
117280: PUSH
117281: LD_INT 16
117283: PUSH
117284: LD_INT 20
117286: PUSH
117287: LD_INT 21
117289: PUSH
117290: LD_INT 22
117292: PUSH
117293: LD_INT 23
117295: PUSH
117296: LD_INT 25
117298: PUSH
117299: LD_INT 26
117301: PUSH
117302: LD_INT 28
117304: PUSH
117305: LD_INT 30
117307: PUSH
117308: LD_INT 31
117310: PUSH
117311: LD_INT 32
117313: PUSH
117314: LD_INT 36
117316: PUSH
117317: EMPTY
117318: LIST
117319: LIST
117320: LIST
117321: LIST
117322: LIST
117323: LIST
117324: LIST
117325: LIST
117326: LIST
117327: LIST
117328: LIST
117329: LIST
117330: LIST
117331: LIST
117332: LIST
117333: LIST
117334: LIST
117335: LIST
117336: LIST
117337: LIST
117338: LIST
117339: PUSH
117340: LD_INT 101
117342: PUSH
117343: LD_INT 102
117345: PUSH
117346: LD_INT 103
117348: PUSH
117349: LD_INT 105
117351: PUSH
117352: LD_INT 106
117354: PUSH
117355: LD_INT 108
117357: PUSH
117358: LD_INT 109
117360: PUSH
117361: LD_INT 112
117363: PUSH
117364: LD_INT 114
117366: PUSH
117367: LD_INT 116
117369: PUSH
117370: LD_INT 117
117372: PUSH
117373: LD_INT 118
117375: PUSH
117376: EMPTY
117377: LIST
117378: LIST
117379: LIST
117380: LIST
117381: LIST
117382: LIST
117383: LIST
117384: LIST
117385: LIST
117386: LIST
117387: LIST
117388: LIST
117389: PUSH
117390: EMPTY
117391: LIST
117392: LIST
117393: ST_TO_ADDR
117394: GO 119493
117396: LD_INT 10
117398: DOUBLE
117399: EQUAL
117400: IFTRUE 117404
117402: GO 117600
117404: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
117405: LD_ADDR_VAR 0 2
117409: PUSH
117410: LD_INT 2
117412: PUSH
117413: LD_INT 4
117415: PUSH
117416: LD_INT 5
117418: PUSH
117419: LD_INT 6
117421: PUSH
117422: LD_INT 7
117424: PUSH
117425: LD_INT 8
117427: PUSH
117428: LD_INT 9
117430: PUSH
117431: LD_INT 10
117433: PUSH
117434: LD_INT 11
117436: PUSH
117437: LD_INT 12
117439: PUSH
117440: LD_INT 13
117442: PUSH
117443: LD_INT 14
117445: PUSH
117446: LD_INT 15
117448: PUSH
117449: LD_INT 16
117451: PUSH
117452: LD_INT 17
117454: PUSH
117455: LD_INT 18
117457: PUSH
117458: LD_INT 19
117460: PUSH
117461: LD_INT 20
117463: PUSH
117464: LD_INT 21
117466: PUSH
117467: LD_INT 22
117469: PUSH
117470: LD_INT 23
117472: PUSH
117473: LD_INT 24
117475: PUSH
117476: LD_INT 25
117478: PUSH
117479: LD_INT 26
117481: PUSH
117482: LD_INT 28
117484: PUSH
117485: LD_INT 30
117487: PUSH
117488: LD_INT 31
117490: PUSH
117491: LD_INT 32
117493: PUSH
117494: LD_INT 36
117496: PUSH
117497: EMPTY
117498: LIST
117499: LIST
117500: LIST
117501: LIST
117502: LIST
117503: LIST
117504: LIST
117505: LIST
117506: LIST
117507: LIST
117508: LIST
117509: LIST
117510: LIST
117511: LIST
117512: LIST
117513: LIST
117514: LIST
117515: LIST
117516: LIST
117517: LIST
117518: LIST
117519: LIST
117520: LIST
117521: LIST
117522: LIST
117523: LIST
117524: LIST
117525: LIST
117526: LIST
117527: PUSH
117528: LD_INT 101
117530: PUSH
117531: LD_INT 102
117533: PUSH
117534: LD_INT 103
117536: PUSH
117537: LD_INT 104
117539: PUSH
117540: LD_INT 105
117542: PUSH
117543: LD_INT 106
117545: PUSH
117546: LD_INT 107
117548: PUSH
117549: LD_INT 108
117551: PUSH
117552: LD_INT 109
117554: PUSH
117555: LD_INT 110
117557: PUSH
117558: LD_INT 111
117560: PUSH
117561: LD_INT 112
117563: PUSH
117564: LD_INT 114
117566: PUSH
117567: LD_INT 116
117569: PUSH
117570: LD_INT 117
117572: PUSH
117573: LD_INT 118
117575: PUSH
117576: EMPTY
117577: LIST
117578: LIST
117579: LIST
117580: LIST
117581: LIST
117582: LIST
117583: LIST
117584: LIST
117585: LIST
117586: LIST
117587: LIST
117588: LIST
117589: LIST
117590: LIST
117591: LIST
117592: LIST
117593: PUSH
117594: EMPTY
117595: LIST
117596: LIST
117597: ST_TO_ADDR
117598: GO 119493
117600: LD_INT 11
117602: DOUBLE
117603: EQUAL
117604: IFTRUE 117608
117606: GO 117812
117608: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
117609: LD_ADDR_VAR 0 2
117613: PUSH
117614: LD_INT 2
117616: PUSH
117617: LD_INT 3
117619: PUSH
117620: LD_INT 4
117622: PUSH
117623: LD_INT 5
117625: PUSH
117626: LD_INT 6
117628: PUSH
117629: LD_INT 7
117631: PUSH
117632: LD_INT 8
117634: PUSH
117635: LD_INT 9
117637: PUSH
117638: LD_INT 10
117640: PUSH
117641: LD_INT 11
117643: PUSH
117644: LD_INT 12
117646: PUSH
117647: LD_INT 13
117649: PUSH
117650: LD_INT 14
117652: PUSH
117653: LD_INT 15
117655: PUSH
117656: LD_INT 16
117658: PUSH
117659: LD_INT 17
117661: PUSH
117662: LD_INT 18
117664: PUSH
117665: LD_INT 19
117667: PUSH
117668: LD_INT 20
117670: PUSH
117671: LD_INT 21
117673: PUSH
117674: LD_INT 22
117676: PUSH
117677: LD_INT 23
117679: PUSH
117680: LD_INT 24
117682: PUSH
117683: LD_INT 25
117685: PUSH
117686: LD_INT 26
117688: PUSH
117689: LD_INT 28
117691: PUSH
117692: LD_INT 30
117694: PUSH
117695: LD_INT 31
117697: PUSH
117698: LD_INT 32
117700: PUSH
117701: LD_INT 34
117703: PUSH
117704: LD_INT 36
117706: PUSH
117707: EMPTY
117708: LIST
117709: LIST
117710: LIST
117711: LIST
117712: LIST
117713: LIST
117714: LIST
117715: LIST
117716: LIST
117717: LIST
117718: LIST
117719: LIST
117720: LIST
117721: LIST
117722: LIST
117723: LIST
117724: LIST
117725: LIST
117726: LIST
117727: LIST
117728: LIST
117729: LIST
117730: LIST
117731: LIST
117732: LIST
117733: LIST
117734: LIST
117735: LIST
117736: LIST
117737: LIST
117738: LIST
117739: PUSH
117740: LD_INT 101
117742: PUSH
117743: LD_INT 102
117745: PUSH
117746: LD_INT 103
117748: PUSH
117749: LD_INT 104
117751: PUSH
117752: LD_INT 105
117754: PUSH
117755: LD_INT 106
117757: PUSH
117758: LD_INT 107
117760: PUSH
117761: LD_INT 108
117763: PUSH
117764: LD_INT 109
117766: PUSH
117767: LD_INT 110
117769: PUSH
117770: LD_INT 111
117772: PUSH
117773: LD_INT 112
117775: PUSH
117776: LD_INT 114
117778: PUSH
117779: LD_INT 116
117781: PUSH
117782: LD_INT 117
117784: PUSH
117785: LD_INT 118
117787: PUSH
117788: EMPTY
117789: LIST
117790: LIST
117791: LIST
117792: LIST
117793: LIST
117794: LIST
117795: LIST
117796: LIST
117797: LIST
117798: LIST
117799: LIST
117800: LIST
117801: LIST
117802: LIST
117803: LIST
117804: LIST
117805: PUSH
117806: EMPTY
117807: LIST
117808: LIST
117809: ST_TO_ADDR
117810: GO 119493
117812: LD_INT 12
117814: DOUBLE
117815: EQUAL
117816: IFTRUE 117820
117818: GO 118040
117820: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
117821: LD_ADDR_VAR 0 2
117825: PUSH
117826: LD_INT 1
117828: PUSH
117829: LD_INT 2
117831: PUSH
117832: LD_INT 3
117834: PUSH
117835: LD_INT 4
117837: PUSH
117838: LD_INT 5
117840: PUSH
117841: LD_INT 6
117843: PUSH
117844: LD_INT 7
117846: PUSH
117847: LD_INT 8
117849: PUSH
117850: LD_INT 9
117852: PUSH
117853: LD_INT 10
117855: PUSH
117856: LD_INT 11
117858: PUSH
117859: LD_INT 12
117861: PUSH
117862: LD_INT 13
117864: PUSH
117865: LD_INT 14
117867: PUSH
117868: LD_INT 15
117870: PUSH
117871: LD_INT 16
117873: PUSH
117874: LD_INT 17
117876: PUSH
117877: LD_INT 18
117879: PUSH
117880: LD_INT 19
117882: PUSH
117883: LD_INT 20
117885: PUSH
117886: LD_INT 21
117888: PUSH
117889: LD_INT 22
117891: PUSH
117892: LD_INT 23
117894: PUSH
117895: LD_INT 24
117897: PUSH
117898: LD_INT 25
117900: PUSH
117901: LD_INT 26
117903: PUSH
117904: LD_INT 27
117906: PUSH
117907: LD_INT 28
117909: PUSH
117910: LD_INT 30
117912: PUSH
117913: LD_INT 31
117915: PUSH
117916: LD_INT 32
117918: PUSH
117919: LD_INT 33
117921: PUSH
117922: LD_INT 34
117924: PUSH
117925: LD_INT 36
117927: PUSH
117928: EMPTY
117929: LIST
117930: LIST
117931: LIST
117932: LIST
117933: LIST
117934: LIST
117935: LIST
117936: LIST
117937: LIST
117938: LIST
117939: LIST
117940: LIST
117941: LIST
117942: LIST
117943: LIST
117944: LIST
117945: LIST
117946: LIST
117947: LIST
117948: LIST
117949: LIST
117950: LIST
117951: LIST
117952: LIST
117953: LIST
117954: LIST
117955: LIST
117956: LIST
117957: LIST
117958: LIST
117959: LIST
117960: LIST
117961: LIST
117962: LIST
117963: PUSH
117964: LD_INT 101
117966: PUSH
117967: LD_INT 102
117969: PUSH
117970: LD_INT 103
117972: PUSH
117973: LD_INT 104
117975: PUSH
117976: LD_INT 105
117978: PUSH
117979: LD_INT 106
117981: PUSH
117982: LD_INT 107
117984: PUSH
117985: LD_INT 108
117987: PUSH
117988: LD_INT 109
117990: PUSH
117991: LD_INT 110
117993: PUSH
117994: LD_INT 111
117996: PUSH
117997: LD_INT 112
117999: PUSH
118000: LD_INT 113
118002: PUSH
118003: LD_INT 114
118005: PUSH
118006: LD_INT 116
118008: PUSH
118009: LD_INT 117
118011: PUSH
118012: LD_INT 118
118014: PUSH
118015: EMPTY
118016: LIST
118017: LIST
118018: LIST
118019: LIST
118020: LIST
118021: LIST
118022: LIST
118023: LIST
118024: LIST
118025: LIST
118026: LIST
118027: LIST
118028: LIST
118029: LIST
118030: LIST
118031: LIST
118032: LIST
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: ST_TO_ADDR
118038: GO 119493
118040: LD_INT 13
118042: DOUBLE
118043: EQUAL
118044: IFTRUE 118048
118046: GO 118256
118048: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
118049: LD_ADDR_VAR 0 2
118053: PUSH
118054: LD_INT 1
118056: PUSH
118057: LD_INT 2
118059: PUSH
118060: LD_INT 3
118062: PUSH
118063: LD_INT 4
118065: PUSH
118066: LD_INT 5
118068: PUSH
118069: LD_INT 8
118071: PUSH
118072: LD_INT 9
118074: PUSH
118075: LD_INT 10
118077: PUSH
118078: LD_INT 11
118080: PUSH
118081: LD_INT 12
118083: PUSH
118084: LD_INT 14
118086: PUSH
118087: LD_INT 15
118089: PUSH
118090: LD_INT 16
118092: PUSH
118093: LD_INT 17
118095: PUSH
118096: LD_INT 18
118098: PUSH
118099: LD_INT 19
118101: PUSH
118102: LD_INT 20
118104: PUSH
118105: LD_INT 21
118107: PUSH
118108: LD_INT 22
118110: PUSH
118111: LD_INT 23
118113: PUSH
118114: LD_INT 24
118116: PUSH
118117: LD_INT 25
118119: PUSH
118120: LD_INT 26
118122: PUSH
118123: LD_INT 27
118125: PUSH
118126: LD_INT 28
118128: PUSH
118129: LD_INT 30
118131: PUSH
118132: LD_INT 31
118134: PUSH
118135: LD_INT 32
118137: PUSH
118138: LD_INT 33
118140: PUSH
118141: LD_INT 34
118143: PUSH
118144: LD_INT 36
118146: PUSH
118147: EMPTY
118148: LIST
118149: LIST
118150: LIST
118151: LIST
118152: LIST
118153: LIST
118154: LIST
118155: LIST
118156: LIST
118157: LIST
118158: LIST
118159: LIST
118160: LIST
118161: LIST
118162: LIST
118163: LIST
118164: LIST
118165: LIST
118166: LIST
118167: LIST
118168: LIST
118169: LIST
118170: LIST
118171: LIST
118172: LIST
118173: LIST
118174: LIST
118175: LIST
118176: LIST
118177: LIST
118178: LIST
118179: PUSH
118180: LD_INT 101
118182: PUSH
118183: LD_INT 102
118185: PUSH
118186: LD_INT 103
118188: PUSH
118189: LD_INT 104
118191: PUSH
118192: LD_INT 105
118194: PUSH
118195: LD_INT 106
118197: PUSH
118198: LD_INT 107
118200: PUSH
118201: LD_INT 108
118203: PUSH
118204: LD_INT 109
118206: PUSH
118207: LD_INT 110
118209: PUSH
118210: LD_INT 111
118212: PUSH
118213: LD_INT 112
118215: PUSH
118216: LD_INT 113
118218: PUSH
118219: LD_INT 114
118221: PUSH
118222: LD_INT 116
118224: PUSH
118225: LD_INT 117
118227: PUSH
118228: LD_INT 118
118230: PUSH
118231: EMPTY
118232: LIST
118233: LIST
118234: LIST
118235: LIST
118236: LIST
118237: LIST
118238: LIST
118239: LIST
118240: LIST
118241: LIST
118242: LIST
118243: LIST
118244: LIST
118245: LIST
118246: LIST
118247: LIST
118248: LIST
118249: PUSH
118250: EMPTY
118251: LIST
118252: LIST
118253: ST_TO_ADDR
118254: GO 119493
118256: LD_INT 14
118258: DOUBLE
118259: EQUAL
118260: IFTRUE 118264
118262: GO 118488
118264: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
118265: LD_ADDR_VAR 0 2
118269: PUSH
118270: LD_INT 1
118272: PUSH
118273: LD_INT 2
118275: PUSH
118276: LD_INT 3
118278: PUSH
118279: LD_INT 4
118281: PUSH
118282: LD_INT 5
118284: PUSH
118285: LD_INT 6
118287: PUSH
118288: LD_INT 7
118290: PUSH
118291: LD_INT 8
118293: PUSH
118294: LD_INT 9
118296: PUSH
118297: LD_INT 10
118299: PUSH
118300: LD_INT 11
118302: PUSH
118303: LD_INT 12
118305: PUSH
118306: LD_INT 13
118308: PUSH
118309: LD_INT 14
118311: PUSH
118312: LD_INT 15
118314: PUSH
118315: LD_INT 16
118317: PUSH
118318: LD_INT 17
118320: PUSH
118321: LD_INT 18
118323: PUSH
118324: LD_INT 19
118326: PUSH
118327: LD_INT 20
118329: PUSH
118330: LD_INT 21
118332: PUSH
118333: LD_INT 22
118335: PUSH
118336: LD_INT 23
118338: PUSH
118339: LD_INT 24
118341: PUSH
118342: LD_INT 25
118344: PUSH
118345: LD_INT 26
118347: PUSH
118348: LD_INT 27
118350: PUSH
118351: LD_INT 28
118353: PUSH
118354: LD_INT 29
118356: PUSH
118357: LD_INT 30
118359: PUSH
118360: LD_INT 31
118362: PUSH
118363: LD_INT 32
118365: PUSH
118366: LD_INT 33
118368: PUSH
118369: LD_INT 34
118371: PUSH
118372: LD_INT 36
118374: PUSH
118375: EMPTY
118376: LIST
118377: LIST
118378: LIST
118379: LIST
118380: LIST
118381: LIST
118382: LIST
118383: LIST
118384: LIST
118385: LIST
118386: LIST
118387: LIST
118388: LIST
118389: LIST
118390: LIST
118391: LIST
118392: LIST
118393: LIST
118394: LIST
118395: LIST
118396: LIST
118397: LIST
118398: LIST
118399: LIST
118400: LIST
118401: LIST
118402: LIST
118403: LIST
118404: LIST
118405: LIST
118406: LIST
118407: LIST
118408: LIST
118409: LIST
118410: LIST
118411: PUSH
118412: LD_INT 101
118414: PUSH
118415: LD_INT 102
118417: PUSH
118418: LD_INT 103
118420: PUSH
118421: LD_INT 104
118423: PUSH
118424: LD_INT 105
118426: PUSH
118427: LD_INT 106
118429: PUSH
118430: LD_INT 107
118432: PUSH
118433: LD_INT 108
118435: PUSH
118436: LD_INT 109
118438: PUSH
118439: LD_INT 110
118441: PUSH
118442: LD_INT 111
118444: PUSH
118445: LD_INT 112
118447: PUSH
118448: LD_INT 113
118450: PUSH
118451: LD_INT 114
118453: PUSH
118454: LD_INT 116
118456: PUSH
118457: LD_INT 117
118459: PUSH
118460: LD_INT 118
118462: PUSH
118463: EMPTY
118464: LIST
118465: LIST
118466: LIST
118467: LIST
118468: LIST
118469: LIST
118470: LIST
118471: LIST
118472: LIST
118473: LIST
118474: LIST
118475: LIST
118476: LIST
118477: LIST
118478: LIST
118479: LIST
118480: LIST
118481: PUSH
118482: EMPTY
118483: LIST
118484: LIST
118485: ST_TO_ADDR
118486: GO 119493
118488: LD_INT 15
118490: DOUBLE
118491: EQUAL
118492: IFTRUE 118496
118494: GO 118720
118496: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
118497: LD_ADDR_VAR 0 2
118501: PUSH
118502: LD_INT 1
118504: PUSH
118505: LD_INT 2
118507: PUSH
118508: LD_INT 3
118510: PUSH
118511: LD_INT 4
118513: PUSH
118514: LD_INT 5
118516: PUSH
118517: LD_INT 6
118519: PUSH
118520: LD_INT 7
118522: PUSH
118523: LD_INT 8
118525: PUSH
118526: LD_INT 9
118528: PUSH
118529: LD_INT 10
118531: PUSH
118532: LD_INT 11
118534: PUSH
118535: LD_INT 12
118537: PUSH
118538: LD_INT 13
118540: PUSH
118541: LD_INT 14
118543: PUSH
118544: LD_INT 15
118546: PUSH
118547: LD_INT 16
118549: PUSH
118550: LD_INT 17
118552: PUSH
118553: LD_INT 18
118555: PUSH
118556: LD_INT 19
118558: PUSH
118559: LD_INT 20
118561: PUSH
118562: LD_INT 21
118564: PUSH
118565: LD_INT 22
118567: PUSH
118568: LD_INT 23
118570: PUSH
118571: LD_INT 24
118573: PUSH
118574: LD_INT 25
118576: PUSH
118577: LD_INT 26
118579: PUSH
118580: LD_INT 27
118582: PUSH
118583: LD_INT 28
118585: PUSH
118586: LD_INT 29
118588: PUSH
118589: LD_INT 30
118591: PUSH
118592: LD_INT 31
118594: PUSH
118595: LD_INT 32
118597: PUSH
118598: LD_INT 33
118600: PUSH
118601: LD_INT 34
118603: PUSH
118604: LD_INT 36
118606: PUSH
118607: EMPTY
118608: LIST
118609: LIST
118610: LIST
118611: LIST
118612: LIST
118613: LIST
118614: LIST
118615: LIST
118616: LIST
118617: LIST
118618: LIST
118619: LIST
118620: LIST
118621: LIST
118622: LIST
118623: LIST
118624: LIST
118625: LIST
118626: LIST
118627: LIST
118628: LIST
118629: LIST
118630: LIST
118631: LIST
118632: LIST
118633: LIST
118634: LIST
118635: LIST
118636: LIST
118637: LIST
118638: LIST
118639: LIST
118640: LIST
118641: LIST
118642: LIST
118643: PUSH
118644: LD_INT 101
118646: PUSH
118647: LD_INT 102
118649: PUSH
118650: LD_INT 103
118652: PUSH
118653: LD_INT 104
118655: PUSH
118656: LD_INT 105
118658: PUSH
118659: LD_INT 106
118661: PUSH
118662: LD_INT 107
118664: PUSH
118665: LD_INT 108
118667: PUSH
118668: LD_INT 109
118670: PUSH
118671: LD_INT 110
118673: PUSH
118674: LD_INT 111
118676: PUSH
118677: LD_INT 112
118679: PUSH
118680: LD_INT 113
118682: PUSH
118683: LD_INT 114
118685: PUSH
118686: LD_INT 116
118688: PUSH
118689: LD_INT 117
118691: PUSH
118692: LD_INT 118
118694: PUSH
118695: EMPTY
118696: LIST
118697: LIST
118698: LIST
118699: LIST
118700: LIST
118701: LIST
118702: LIST
118703: LIST
118704: LIST
118705: LIST
118706: LIST
118707: LIST
118708: LIST
118709: LIST
118710: LIST
118711: LIST
118712: LIST
118713: PUSH
118714: EMPTY
118715: LIST
118716: LIST
118717: ST_TO_ADDR
118718: GO 119493
118720: LD_INT 16
118722: DOUBLE
118723: EQUAL
118724: IFTRUE 118728
118726: GO 118864
118728: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
118729: LD_ADDR_VAR 0 2
118733: PUSH
118734: LD_INT 2
118736: PUSH
118737: LD_INT 4
118739: PUSH
118740: LD_INT 5
118742: PUSH
118743: LD_INT 7
118745: PUSH
118746: LD_INT 11
118748: PUSH
118749: LD_INT 12
118751: PUSH
118752: LD_INT 15
118754: PUSH
118755: LD_INT 16
118757: PUSH
118758: LD_INT 20
118760: PUSH
118761: LD_INT 21
118763: PUSH
118764: LD_INT 22
118766: PUSH
118767: LD_INT 23
118769: PUSH
118770: LD_INT 25
118772: PUSH
118773: LD_INT 26
118775: PUSH
118776: LD_INT 30
118778: PUSH
118779: LD_INT 31
118781: PUSH
118782: LD_INT 32
118784: PUSH
118785: LD_INT 33
118787: PUSH
118788: LD_INT 34
118790: PUSH
118791: EMPTY
118792: LIST
118793: LIST
118794: LIST
118795: LIST
118796: LIST
118797: LIST
118798: LIST
118799: LIST
118800: LIST
118801: LIST
118802: LIST
118803: LIST
118804: LIST
118805: LIST
118806: LIST
118807: LIST
118808: LIST
118809: LIST
118810: LIST
118811: PUSH
118812: LD_INT 101
118814: PUSH
118815: LD_INT 102
118817: PUSH
118818: LD_INT 103
118820: PUSH
118821: LD_INT 106
118823: PUSH
118824: LD_INT 108
118826: PUSH
118827: LD_INT 112
118829: PUSH
118830: LD_INT 113
118832: PUSH
118833: LD_INT 114
118835: PUSH
118836: LD_INT 116
118838: PUSH
118839: LD_INT 117
118841: PUSH
118842: LD_INT 118
118844: PUSH
118845: EMPTY
118846: LIST
118847: LIST
118848: LIST
118849: LIST
118850: LIST
118851: LIST
118852: LIST
118853: LIST
118854: LIST
118855: LIST
118856: LIST
118857: PUSH
118858: EMPTY
118859: LIST
118860: LIST
118861: ST_TO_ADDR
118862: GO 119493
118864: LD_INT 17
118866: DOUBLE
118867: EQUAL
118868: IFTRUE 118872
118870: GO 119096
118872: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
118873: LD_ADDR_VAR 0 2
118877: PUSH
118878: LD_INT 1
118880: PUSH
118881: LD_INT 2
118883: PUSH
118884: LD_INT 3
118886: PUSH
118887: LD_INT 4
118889: PUSH
118890: LD_INT 5
118892: PUSH
118893: LD_INT 6
118895: PUSH
118896: LD_INT 7
118898: PUSH
118899: LD_INT 8
118901: PUSH
118902: LD_INT 9
118904: PUSH
118905: LD_INT 10
118907: PUSH
118908: LD_INT 11
118910: PUSH
118911: LD_INT 12
118913: PUSH
118914: LD_INT 13
118916: PUSH
118917: LD_INT 14
118919: PUSH
118920: LD_INT 15
118922: PUSH
118923: LD_INT 16
118925: PUSH
118926: LD_INT 17
118928: PUSH
118929: LD_INT 18
118931: PUSH
118932: LD_INT 19
118934: PUSH
118935: LD_INT 20
118937: PUSH
118938: LD_INT 21
118940: PUSH
118941: LD_INT 22
118943: PUSH
118944: LD_INT 23
118946: PUSH
118947: LD_INT 24
118949: PUSH
118950: LD_INT 25
118952: PUSH
118953: LD_INT 26
118955: PUSH
118956: LD_INT 27
118958: PUSH
118959: LD_INT 28
118961: PUSH
118962: LD_INT 29
118964: PUSH
118965: LD_INT 30
118967: PUSH
118968: LD_INT 31
118970: PUSH
118971: LD_INT 32
118973: PUSH
118974: LD_INT 33
118976: PUSH
118977: LD_INT 34
118979: PUSH
118980: LD_INT 36
118982: PUSH
118983: EMPTY
118984: LIST
118985: LIST
118986: LIST
118987: LIST
118988: LIST
118989: LIST
118990: LIST
118991: LIST
118992: LIST
118993: LIST
118994: LIST
118995: LIST
118996: LIST
118997: LIST
118998: LIST
118999: LIST
119000: LIST
119001: LIST
119002: LIST
119003: LIST
119004: LIST
119005: LIST
119006: LIST
119007: LIST
119008: LIST
119009: LIST
119010: LIST
119011: LIST
119012: LIST
119013: LIST
119014: LIST
119015: LIST
119016: LIST
119017: LIST
119018: LIST
119019: PUSH
119020: LD_INT 101
119022: PUSH
119023: LD_INT 102
119025: PUSH
119026: LD_INT 103
119028: PUSH
119029: LD_INT 104
119031: PUSH
119032: LD_INT 105
119034: PUSH
119035: LD_INT 106
119037: PUSH
119038: LD_INT 107
119040: PUSH
119041: LD_INT 108
119043: PUSH
119044: LD_INT 109
119046: PUSH
119047: LD_INT 110
119049: PUSH
119050: LD_INT 111
119052: PUSH
119053: LD_INT 112
119055: PUSH
119056: LD_INT 113
119058: PUSH
119059: LD_INT 114
119061: PUSH
119062: LD_INT 116
119064: PUSH
119065: LD_INT 117
119067: PUSH
119068: LD_INT 118
119070: PUSH
119071: EMPTY
119072: LIST
119073: LIST
119074: LIST
119075: LIST
119076: LIST
119077: LIST
119078: LIST
119079: LIST
119080: LIST
119081: LIST
119082: LIST
119083: LIST
119084: LIST
119085: LIST
119086: LIST
119087: LIST
119088: LIST
119089: PUSH
119090: EMPTY
119091: LIST
119092: LIST
119093: ST_TO_ADDR
119094: GO 119493
119096: LD_INT 18
119098: DOUBLE
119099: EQUAL
119100: IFTRUE 119104
119102: GO 119252
119104: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
119105: LD_ADDR_VAR 0 2
119109: PUSH
119110: LD_INT 2
119112: PUSH
119113: LD_INT 4
119115: PUSH
119116: LD_INT 5
119118: PUSH
119119: LD_INT 7
119121: PUSH
119122: LD_INT 11
119124: PUSH
119125: LD_INT 12
119127: PUSH
119128: LD_INT 15
119130: PUSH
119131: LD_INT 16
119133: PUSH
119134: LD_INT 20
119136: PUSH
119137: LD_INT 21
119139: PUSH
119140: LD_INT 22
119142: PUSH
119143: LD_INT 23
119145: PUSH
119146: LD_INT 25
119148: PUSH
119149: LD_INT 26
119151: PUSH
119152: LD_INT 30
119154: PUSH
119155: LD_INT 31
119157: PUSH
119158: LD_INT 32
119160: PUSH
119161: LD_INT 33
119163: PUSH
119164: LD_INT 34
119166: PUSH
119167: LD_INT 35
119169: PUSH
119170: LD_INT 36
119172: PUSH
119173: EMPTY
119174: LIST
119175: LIST
119176: LIST
119177: LIST
119178: LIST
119179: LIST
119180: LIST
119181: LIST
119182: LIST
119183: LIST
119184: LIST
119185: LIST
119186: LIST
119187: LIST
119188: LIST
119189: LIST
119190: LIST
119191: LIST
119192: LIST
119193: LIST
119194: LIST
119195: PUSH
119196: LD_INT 101
119198: PUSH
119199: LD_INT 102
119201: PUSH
119202: LD_INT 103
119204: PUSH
119205: LD_INT 106
119207: PUSH
119208: LD_INT 108
119210: PUSH
119211: LD_INT 112
119213: PUSH
119214: LD_INT 113
119216: PUSH
119217: LD_INT 114
119219: PUSH
119220: LD_INT 115
119222: PUSH
119223: LD_INT 116
119225: PUSH
119226: LD_INT 117
119228: PUSH
119229: LD_INT 118
119231: PUSH
119232: EMPTY
119233: LIST
119234: LIST
119235: LIST
119236: LIST
119237: LIST
119238: LIST
119239: LIST
119240: LIST
119241: LIST
119242: LIST
119243: LIST
119244: LIST
119245: PUSH
119246: EMPTY
119247: LIST
119248: LIST
119249: ST_TO_ADDR
119250: GO 119493
119252: LD_INT 19
119254: DOUBLE
119255: EQUAL
119256: IFTRUE 119260
119258: GO 119492
119260: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
119261: LD_ADDR_VAR 0 2
119265: PUSH
119266: LD_INT 1
119268: PUSH
119269: LD_INT 2
119271: PUSH
119272: LD_INT 3
119274: PUSH
119275: LD_INT 4
119277: PUSH
119278: LD_INT 5
119280: PUSH
119281: LD_INT 6
119283: PUSH
119284: LD_INT 7
119286: PUSH
119287: LD_INT 8
119289: PUSH
119290: LD_INT 9
119292: PUSH
119293: LD_INT 10
119295: PUSH
119296: LD_INT 11
119298: PUSH
119299: LD_INT 12
119301: PUSH
119302: LD_INT 13
119304: PUSH
119305: LD_INT 14
119307: PUSH
119308: LD_INT 15
119310: PUSH
119311: LD_INT 16
119313: PUSH
119314: LD_INT 17
119316: PUSH
119317: LD_INT 18
119319: PUSH
119320: LD_INT 19
119322: PUSH
119323: LD_INT 20
119325: PUSH
119326: LD_INT 21
119328: PUSH
119329: LD_INT 22
119331: PUSH
119332: LD_INT 23
119334: PUSH
119335: LD_INT 24
119337: PUSH
119338: LD_INT 25
119340: PUSH
119341: LD_INT 26
119343: PUSH
119344: LD_INT 27
119346: PUSH
119347: LD_INT 28
119349: PUSH
119350: LD_INT 29
119352: PUSH
119353: LD_INT 30
119355: PUSH
119356: LD_INT 31
119358: PUSH
119359: LD_INT 32
119361: PUSH
119362: LD_INT 33
119364: PUSH
119365: LD_INT 34
119367: PUSH
119368: LD_INT 35
119370: PUSH
119371: LD_INT 36
119373: PUSH
119374: EMPTY
119375: LIST
119376: LIST
119377: LIST
119378: LIST
119379: LIST
119380: LIST
119381: LIST
119382: LIST
119383: LIST
119384: LIST
119385: LIST
119386: LIST
119387: LIST
119388: LIST
119389: LIST
119390: LIST
119391: LIST
119392: LIST
119393: LIST
119394: LIST
119395: LIST
119396: LIST
119397: LIST
119398: LIST
119399: LIST
119400: LIST
119401: LIST
119402: LIST
119403: LIST
119404: LIST
119405: LIST
119406: LIST
119407: LIST
119408: LIST
119409: LIST
119410: LIST
119411: PUSH
119412: LD_INT 101
119414: PUSH
119415: LD_INT 102
119417: PUSH
119418: LD_INT 103
119420: PUSH
119421: LD_INT 104
119423: PUSH
119424: LD_INT 105
119426: PUSH
119427: LD_INT 106
119429: PUSH
119430: LD_INT 107
119432: PUSH
119433: LD_INT 108
119435: PUSH
119436: LD_INT 109
119438: PUSH
119439: LD_INT 110
119441: PUSH
119442: LD_INT 111
119444: PUSH
119445: LD_INT 112
119447: PUSH
119448: LD_INT 113
119450: PUSH
119451: LD_INT 114
119453: PUSH
119454: LD_INT 115
119456: PUSH
119457: LD_INT 116
119459: PUSH
119460: LD_INT 117
119462: PUSH
119463: LD_INT 118
119465: PUSH
119466: EMPTY
119467: LIST
119468: LIST
119469: LIST
119470: LIST
119471: LIST
119472: LIST
119473: LIST
119474: LIST
119475: LIST
119476: LIST
119477: LIST
119478: LIST
119479: LIST
119480: LIST
119481: LIST
119482: LIST
119483: LIST
119484: LIST
119485: PUSH
119486: EMPTY
119487: LIST
119488: LIST
119489: ST_TO_ADDR
119490: GO 119493
119492: POP
// end else
119493: GO 119724
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
119495: LD_ADDR_VAR 0 2
119499: PUSH
119500: LD_INT 1
119502: PUSH
119503: LD_INT 2
119505: PUSH
119506: LD_INT 3
119508: PUSH
119509: LD_INT 4
119511: PUSH
119512: LD_INT 5
119514: PUSH
119515: LD_INT 6
119517: PUSH
119518: LD_INT 7
119520: PUSH
119521: LD_INT 8
119523: PUSH
119524: LD_INT 9
119526: PUSH
119527: LD_INT 10
119529: PUSH
119530: LD_INT 11
119532: PUSH
119533: LD_INT 12
119535: PUSH
119536: LD_INT 13
119538: PUSH
119539: LD_INT 14
119541: PUSH
119542: LD_INT 15
119544: PUSH
119545: LD_INT 16
119547: PUSH
119548: LD_INT 17
119550: PUSH
119551: LD_INT 18
119553: PUSH
119554: LD_INT 19
119556: PUSH
119557: LD_INT 20
119559: PUSH
119560: LD_INT 21
119562: PUSH
119563: LD_INT 22
119565: PUSH
119566: LD_INT 23
119568: PUSH
119569: LD_INT 24
119571: PUSH
119572: LD_INT 25
119574: PUSH
119575: LD_INT 26
119577: PUSH
119578: LD_INT 27
119580: PUSH
119581: LD_INT 28
119583: PUSH
119584: LD_INT 29
119586: PUSH
119587: LD_INT 30
119589: PUSH
119590: LD_INT 31
119592: PUSH
119593: LD_INT 32
119595: PUSH
119596: LD_INT 33
119598: PUSH
119599: LD_INT 34
119601: PUSH
119602: LD_INT 35
119604: PUSH
119605: LD_INT 36
119607: PUSH
119608: EMPTY
119609: LIST
119610: LIST
119611: LIST
119612: LIST
119613: LIST
119614: LIST
119615: LIST
119616: LIST
119617: LIST
119618: LIST
119619: LIST
119620: LIST
119621: LIST
119622: LIST
119623: LIST
119624: LIST
119625: LIST
119626: LIST
119627: LIST
119628: LIST
119629: LIST
119630: LIST
119631: LIST
119632: LIST
119633: LIST
119634: LIST
119635: LIST
119636: LIST
119637: LIST
119638: LIST
119639: LIST
119640: LIST
119641: LIST
119642: LIST
119643: LIST
119644: LIST
119645: PUSH
119646: LD_INT 101
119648: PUSH
119649: LD_INT 102
119651: PUSH
119652: LD_INT 103
119654: PUSH
119655: LD_INT 104
119657: PUSH
119658: LD_INT 105
119660: PUSH
119661: LD_INT 106
119663: PUSH
119664: LD_INT 107
119666: PUSH
119667: LD_INT 108
119669: PUSH
119670: LD_INT 109
119672: PUSH
119673: LD_INT 110
119675: PUSH
119676: LD_INT 111
119678: PUSH
119679: LD_INT 112
119681: PUSH
119682: LD_INT 113
119684: PUSH
119685: LD_INT 114
119687: PUSH
119688: LD_INT 115
119690: PUSH
119691: LD_INT 116
119693: PUSH
119694: LD_INT 117
119696: PUSH
119697: LD_INT 118
119699: PUSH
119700: EMPTY
119701: LIST
119702: LIST
119703: LIST
119704: LIST
119705: LIST
119706: LIST
119707: LIST
119708: LIST
119709: LIST
119710: LIST
119711: LIST
119712: LIST
119713: LIST
119714: LIST
119715: LIST
119716: LIST
119717: LIST
119718: LIST
119719: PUSH
119720: EMPTY
119721: LIST
119722: LIST
119723: ST_TO_ADDR
// if result then
119724: LD_VAR 0 2
119728: IFFALSE 120514
// begin normal :=  ;
119730: LD_ADDR_VAR 0 5
119734: PUSH
119735: LD_STRING 
119737: ST_TO_ADDR
// hardcore :=  ;
119738: LD_ADDR_VAR 0 6
119742: PUSH
119743: LD_STRING 
119745: ST_TO_ADDR
// active :=  ;
119746: LD_ADDR_VAR 0 7
119750: PUSH
119751: LD_STRING 
119753: ST_TO_ADDR
// for i = 1 to normalCounter do
119754: LD_ADDR_VAR 0 8
119758: PUSH
119759: DOUBLE
119760: LD_INT 1
119762: DEC
119763: ST_TO_ADDR
119764: LD_EXP 149
119768: PUSH
119769: FOR_TO
119770: IFFALSE 119871
// begin tmp := 0 ;
119772: LD_ADDR_VAR 0 3
119776: PUSH
119777: LD_STRING 0
119779: ST_TO_ADDR
// if result [ 1 ] then
119780: LD_VAR 0 2
119784: PUSH
119785: LD_INT 1
119787: ARRAY
119788: IFFALSE 119853
// if result [ 1 ] [ 1 ] = i then
119790: LD_VAR 0 2
119794: PUSH
119795: LD_INT 1
119797: ARRAY
119798: PUSH
119799: LD_INT 1
119801: ARRAY
119802: PUSH
119803: LD_VAR 0 8
119807: EQUAL
119808: IFFALSE 119853
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
119810: LD_ADDR_VAR 0 2
119814: PUSH
119815: LD_VAR 0 2
119819: PPUSH
119820: LD_INT 1
119822: PPUSH
119823: LD_VAR 0 2
119827: PUSH
119828: LD_INT 1
119830: ARRAY
119831: PPUSH
119832: LD_INT 1
119834: PPUSH
119835: CALL_OW 3
119839: PPUSH
119840: CALL_OW 1
119844: ST_TO_ADDR
// tmp := 1 ;
119845: LD_ADDR_VAR 0 3
119849: PUSH
119850: LD_STRING 1
119852: ST_TO_ADDR
// end ; normal := normal & tmp ;
119853: LD_ADDR_VAR 0 5
119857: PUSH
119858: LD_VAR 0 5
119862: PUSH
119863: LD_VAR 0 3
119867: STR
119868: ST_TO_ADDR
// end ;
119869: GO 119769
119871: POP
119872: POP
// for i = 1 to hardcoreCounter do
119873: LD_ADDR_VAR 0 8
119877: PUSH
119878: DOUBLE
119879: LD_INT 1
119881: DEC
119882: ST_TO_ADDR
119883: LD_EXP 150
119887: PUSH
119888: FOR_TO
119889: IFFALSE 119994
// begin tmp := 0 ;
119891: LD_ADDR_VAR 0 3
119895: PUSH
119896: LD_STRING 0
119898: ST_TO_ADDR
// if result [ 2 ] then
119899: LD_VAR 0 2
119903: PUSH
119904: LD_INT 2
119906: ARRAY
119907: IFFALSE 119976
// if result [ 2 ] [ 1 ] = 100 + i then
119909: LD_VAR 0 2
119913: PUSH
119914: LD_INT 2
119916: ARRAY
119917: PUSH
119918: LD_INT 1
119920: ARRAY
119921: PUSH
119922: LD_INT 100
119924: PUSH
119925: LD_VAR 0 8
119929: PLUS
119930: EQUAL
119931: IFFALSE 119976
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
119933: LD_ADDR_VAR 0 2
119937: PUSH
119938: LD_VAR 0 2
119942: PPUSH
119943: LD_INT 2
119945: PPUSH
119946: LD_VAR 0 2
119950: PUSH
119951: LD_INT 2
119953: ARRAY
119954: PPUSH
119955: LD_INT 1
119957: PPUSH
119958: CALL_OW 3
119962: PPUSH
119963: CALL_OW 1
119967: ST_TO_ADDR
// tmp := 1 ;
119968: LD_ADDR_VAR 0 3
119972: PUSH
119973: LD_STRING 1
119975: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
119976: LD_ADDR_VAR 0 6
119980: PUSH
119981: LD_VAR 0 6
119985: PUSH
119986: LD_VAR 0 3
119990: STR
119991: ST_TO_ADDR
// end ;
119992: GO 119888
119994: POP
119995: POP
// if isGameLoad then
119996: LD_VAR 0 1
120000: IFFALSE 120475
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
120002: LD_ADDR_VAR 0 4
120006: PUSH
120007: LD_EXP 153
120011: PUSH
120012: LD_EXP 152
120016: PUSH
120017: LD_EXP 154
120021: PUSH
120022: LD_EXP 151
120026: PUSH
120027: LD_EXP 155
120031: PUSH
120032: LD_EXP 156
120036: PUSH
120037: LD_EXP 157
120041: PUSH
120042: LD_EXP 158
120046: PUSH
120047: LD_EXP 159
120051: PUSH
120052: LD_EXP 160
120056: PUSH
120057: LD_EXP 161
120061: PUSH
120062: LD_EXP 162
120066: PUSH
120067: LD_EXP 163
120071: PUSH
120072: LD_EXP 164
120076: PUSH
120077: LD_EXP 172
120081: PUSH
120082: LD_EXP 173
120086: PUSH
120087: LD_EXP 174
120091: PUSH
120092: LD_EXP 175
120096: PUSH
120097: LD_EXP 177
120101: PUSH
120102: LD_EXP 178
120106: PUSH
120107: LD_EXP 179
120111: PUSH
120112: LD_EXP 182
120116: PUSH
120117: LD_EXP 184
120121: PUSH
120122: LD_EXP 185
120126: PUSH
120127: LD_EXP 186
120131: PUSH
120132: LD_EXP 188
120136: PUSH
120137: LD_EXP 189
120141: PUSH
120142: LD_EXP 192
120146: PUSH
120147: LD_EXP 193
120151: PUSH
120152: LD_EXP 194
120156: PUSH
120157: LD_EXP 195
120161: PUSH
120162: LD_EXP 196
120166: PUSH
120167: LD_EXP 197
120171: PUSH
120172: LD_EXP 198
120176: PUSH
120177: LD_EXP 199
120181: PUSH
120182: LD_EXP 200
120186: PUSH
120187: LD_EXP 165
120191: PUSH
120192: LD_EXP 166
120196: PUSH
120197: LD_EXP 169
120201: PUSH
120202: LD_EXP 170
120206: PUSH
120207: LD_EXP 171
120211: PUSH
120212: LD_EXP 167
120216: PUSH
120217: LD_EXP 168
120221: PUSH
120222: LD_EXP 176
120226: PUSH
120227: LD_EXP 180
120231: PUSH
120232: LD_EXP 181
120236: PUSH
120237: LD_EXP 183
120241: PUSH
120242: LD_EXP 187
120246: PUSH
120247: LD_EXP 190
120251: PUSH
120252: LD_EXP 191
120256: PUSH
120257: LD_EXP 201
120261: PUSH
120262: LD_EXP 202
120266: PUSH
120267: LD_EXP 203
120271: PUSH
120272: LD_EXP 204
120276: PUSH
120277: EMPTY
120278: LIST
120279: LIST
120280: LIST
120281: LIST
120282: LIST
120283: LIST
120284: LIST
120285: LIST
120286: LIST
120287: LIST
120288: LIST
120289: LIST
120290: LIST
120291: LIST
120292: LIST
120293: LIST
120294: LIST
120295: LIST
120296: LIST
120297: LIST
120298: LIST
120299: LIST
120300: LIST
120301: LIST
120302: LIST
120303: LIST
120304: LIST
120305: LIST
120306: LIST
120307: LIST
120308: LIST
120309: LIST
120310: LIST
120311: LIST
120312: LIST
120313: LIST
120314: LIST
120315: LIST
120316: LIST
120317: LIST
120318: LIST
120319: LIST
120320: LIST
120321: LIST
120322: LIST
120323: LIST
120324: LIST
120325: LIST
120326: LIST
120327: LIST
120328: LIST
120329: LIST
120330: LIST
120331: LIST
120332: ST_TO_ADDR
// tmp :=  ;
120333: LD_ADDR_VAR 0 3
120337: PUSH
120338: LD_STRING 
120340: ST_TO_ADDR
// for i = 1 to normalCounter do
120341: LD_ADDR_VAR 0 8
120345: PUSH
120346: DOUBLE
120347: LD_INT 1
120349: DEC
120350: ST_TO_ADDR
120351: LD_EXP 149
120355: PUSH
120356: FOR_TO
120357: IFFALSE 120393
// begin if flags [ i ] then
120359: LD_VAR 0 4
120363: PUSH
120364: LD_VAR 0 8
120368: ARRAY
120369: IFFALSE 120391
// tmp := tmp & i & ; ;
120371: LD_ADDR_VAR 0 3
120375: PUSH
120376: LD_VAR 0 3
120380: PUSH
120381: LD_VAR 0 8
120385: STR
120386: PUSH
120387: LD_STRING ;
120389: STR
120390: ST_TO_ADDR
// end ;
120391: GO 120356
120393: POP
120394: POP
// for i = 1 to hardcoreCounter do
120395: LD_ADDR_VAR 0 8
120399: PUSH
120400: DOUBLE
120401: LD_INT 1
120403: DEC
120404: ST_TO_ADDR
120405: LD_EXP 150
120409: PUSH
120410: FOR_TO
120411: IFFALSE 120457
// begin if flags [ normalCounter + i ] then
120413: LD_VAR 0 4
120417: PUSH
120418: LD_EXP 149
120422: PUSH
120423: LD_VAR 0 8
120427: PLUS
120428: ARRAY
120429: IFFALSE 120455
// tmp := tmp & ( 100 + i ) & ; ;
120431: LD_ADDR_VAR 0 3
120435: PUSH
120436: LD_VAR 0 3
120440: PUSH
120441: LD_INT 100
120443: PUSH
120444: LD_VAR 0 8
120448: PLUS
120449: STR
120450: PUSH
120451: LD_STRING ;
120453: STR
120454: ST_TO_ADDR
// end ;
120455: GO 120410
120457: POP
120458: POP
// if tmp then
120459: LD_VAR 0 3
120463: IFFALSE 120475
// active := tmp ;
120465: LD_ADDR_VAR 0 7
120469: PUSH
120470: LD_VAR 0 3
120474: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
120475: LD_STRING getStreamItemsFromMission("
120477: PUSH
120478: LD_VAR 0 5
120482: STR
120483: PUSH
120484: LD_STRING ","
120486: STR
120487: PUSH
120488: LD_VAR 0 6
120492: STR
120493: PUSH
120494: LD_STRING ","
120496: STR
120497: PUSH
120498: LD_VAR 0 7
120502: STR
120503: PUSH
120504: LD_STRING ")
120506: STR
120507: PPUSH
120508: CALL_OW 559
// end else
120512: GO 120521
// ToLua ( getStreamItemsFromMission("","","") ) ;
120514: LD_STRING getStreamItemsFromMission("","","")
120516: PPUSH
120517: CALL_OW 559
// end ;
120521: LD_VAR 0 2
120525: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
120526: LD_EXP 148
120530: IFFALSE 120538
120532: PUSH
120533: LD_EXP 153
120537: AND
120538: IFFALSE 120662
120540: GO 120542
120542: DISABLE
120543: LD_INT 0
120545: PPUSH
120546: PPUSH
// begin enable ;
120547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
120548: LD_ADDR_VAR 0 2
120552: PUSH
120553: LD_INT 22
120555: PUSH
120556: LD_OWVAR 2
120560: PUSH
120561: EMPTY
120562: LIST
120563: LIST
120564: PUSH
120565: LD_INT 2
120567: PUSH
120568: LD_INT 34
120570: PUSH
120571: LD_INT 7
120573: PUSH
120574: EMPTY
120575: LIST
120576: LIST
120577: PUSH
120578: LD_INT 34
120580: PUSH
120581: LD_INT 45
120583: PUSH
120584: EMPTY
120585: LIST
120586: LIST
120587: PUSH
120588: LD_INT 34
120590: PUSH
120591: LD_INT 28
120593: PUSH
120594: EMPTY
120595: LIST
120596: LIST
120597: PUSH
120598: LD_INT 34
120600: PUSH
120601: LD_INT 47
120603: PUSH
120604: EMPTY
120605: LIST
120606: LIST
120607: PUSH
120608: EMPTY
120609: LIST
120610: LIST
120611: LIST
120612: LIST
120613: LIST
120614: PUSH
120615: EMPTY
120616: LIST
120617: LIST
120618: PPUSH
120619: CALL_OW 69
120623: ST_TO_ADDR
// if not tmp then
120624: LD_VAR 0 2
120628: NOT
120629: IFFALSE 120633
// exit ;
120631: GO 120662
// for i in tmp do
120633: LD_ADDR_VAR 0 1
120637: PUSH
120638: LD_VAR 0 2
120642: PUSH
120643: FOR_IN
120644: IFFALSE 120660
// begin SetLives ( i , 0 ) ;
120646: LD_VAR 0 1
120650: PPUSH
120651: LD_INT 0
120653: PPUSH
120654: CALL_OW 234
// end ;
120658: GO 120643
120660: POP
120661: POP
// end ;
120662: PPOPN 2
120664: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
120665: LD_EXP 148
120669: IFFALSE 120677
120671: PUSH
120672: LD_EXP 154
120676: AND
120677: IFFALSE 120761
120679: GO 120681
120681: DISABLE
120682: LD_INT 0
120684: PPUSH
120685: PPUSH
// begin enable ;
120686: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
120687: LD_ADDR_VAR 0 2
120691: PUSH
120692: LD_INT 22
120694: PUSH
120695: LD_OWVAR 2
120699: PUSH
120700: EMPTY
120701: LIST
120702: LIST
120703: PUSH
120704: LD_INT 32
120706: PUSH
120707: LD_INT 3
120709: PUSH
120710: EMPTY
120711: LIST
120712: LIST
120713: PUSH
120714: EMPTY
120715: LIST
120716: LIST
120717: PPUSH
120718: CALL_OW 69
120722: ST_TO_ADDR
// if not tmp then
120723: LD_VAR 0 2
120727: NOT
120728: IFFALSE 120732
// exit ;
120730: GO 120761
// for i in tmp do
120732: LD_ADDR_VAR 0 1
120736: PUSH
120737: LD_VAR 0 2
120741: PUSH
120742: FOR_IN
120743: IFFALSE 120759
// begin SetLives ( i , 0 ) ;
120745: LD_VAR 0 1
120749: PPUSH
120750: LD_INT 0
120752: PPUSH
120753: CALL_OW 234
// end ;
120757: GO 120742
120759: POP
120760: POP
// end ;
120761: PPOPN 2
120763: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
120764: LD_EXP 148
120768: IFFALSE 120776
120770: PUSH
120771: LD_EXP 151
120775: AND
120776: IFFALSE 120869
120778: GO 120780
120780: DISABLE
120781: LD_INT 0
120783: PPUSH
// begin enable ;
120784: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
120785: LD_ADDR_VAR 0 1
120789: PUSH
120790: LD_INT 22
120792: PUSH
120793: LD_OWVAR 2
120797: PUSH
120798: EMPTY
120799: LIST
120800: LIST
120801: PUSH
120802: LD_INT 2
120804: PUSH
120805: LD_INT 25
120807: PUSH
120808: LD_INT 5
120810: PUSH
120811: EMPTY
120812: LIST
120813: LIST
120814: PUSH
120815: LD_INT 25
120817: PUSH
120818: LD_INT 9
120820: PUSH
120821: EMPTY
120822: LIST
120823: LIST
120824: PUSH
120825: LD_INT 25
120827: PUSH
120828: LD_INT 8
120830: PUSH
120831: EMPTY
120832: LIST
120833: LIST
120834: PUSH
120835: EMPTY
120836: LIST
120837: LIST
120838: LIST
120839: LIST
120840: PUSH
120841: EMPTY
120842: LIST
120843: LIST
120844: PPUSH
120845: CALL_OW 69
120849: PUSH
120850: FOR_IN
120851: IFFALSE 120867
// begin SetClass ( i , 1 ) ;
120853: LD_VAR 0 1
120857: PPUSH
120858: LD_INT 1
120860: PPUSH
120861: CALL_OW 336
// end ;
120865: GO 120850
120867: POP
120868: POP
// end ;
120869: PPOPN 1
120871: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
120872: LD_EXP 148
120876: IFFALSE 120884
120878: PUSH
120879: LD_EXP 152
120883: AND
120884: IFFALSE 120896
120886: PUSH
120887: LD_OWVAR 65
120891: PUSH
120892: LD_INT 7
120894: LESS
120895: AND
120896: IFFALSE 120910
120898: GO 120900
120900: DISABLE
// begin enable ;
120901: ENABLE
// game_speed := 7 ;
120902: LD_ADDR_OWVAR 65
120906: PUSH
120907: LD_INT 7
120909: ST_TO_ADDR
// end ;
120910: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
120911: LD_EXP 148
120915: IFFALSE 120923
120917: PUSH
120918: LD_EXP 155
120922: AND
120923: IFFALSE 121125
120925: GO 120927
120927: DISABLE
120928: LD_INT 0
120930: PPUSH
120931: PPUSH
120932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120933: LD_ADDR_VAR 0 3
120937: PUSH
120938: LD_INT 81
120940: PUSH
120941: LD_OWVAR 2
120945: PUSH
120946: EMPTY
120947: LIST
120948: LIST
120949: PUSH
120950: LD_INT 21
120952: PUSH
120953: LD_INT 1
120955: PUSH
120956: EMPTY
120957: LIST
120958: LIST
120959: PUSH
120960: EMPTY
120961: LIST
120962: LIST
120963: PPUSH
120964: CALL_OW 69
120968: ST_TO_ADDR
// if not tmp then
120969: LD_VAR 0 3
120973: NOT
120974: IFFALSE 120978
// exit ;
120976: GO 121125
// if tmp > 5 then
120978: LD_VAR 0 3
120982: PUSH
120983: LD_INT 5
120985: GREATER
120986: IFFALSE 120998
// k := 5 else
120988: LD_ADDR_VAR 0 2
120992: PUSH
120993: LD_INT 5
120995: ST_TO_ADDR
120996: GO 121008
// k := tmp ;
120998: LD_ADDR_VAR 0 2
121002: PUSH
121003: LD_VAR 0 3
121007: ST_TO_ADDR
// for i := 1 to k do
121008: LD_ADDR_VAR 0 1
121012: PUSH
121013: DOUBLE
121014: LD_INT 1
121016: DEC
121017: ST_TO_ADDR
121018: LD_VAR 0 2
121022: PUSH
121023: FOR_TO
121024: IFFALSE 121123
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
121026: LD_VAR 0 3
121030: PUSH
121031: LD_VAR 0 1
121035: ARRAY
121036: PPUSH
121037: LD_VAR 0 1
121041: PUSH
121042: LD_INT 4
121044: MOD
121045: PUSH
121046: LD_INT 1
121048: PLUS
121049: PPUSH
121050: CALL_OW 259
121054: PUSH
121055: LD_INT 10
121057: LESS
121058: IFFALSE 121121
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
121060: LD_VAR 0 3
121064: PUSH
121065: LD_VAR 0 1
121069: ARRAY
121070: PPUSH
121071: LD_VAR 0 1
121075: PUSH
121076: LD_INT 4
121078: MOD
121079: PUSH
121080: LD_INT 1
121082: PLUS
121083: PPUSH
121084: LD_VAR 0 3
121088: PUSH
121089: LD_VAR 0 1
121093: ARRAY
121094: PPUSH
121095: LD_VAR 0 1
121099: PUSH
121100: LD_INT 4
121102: MOD
121103: PUSH
121104: LD_INT 1
121106: PLUS
121107: PPUSH
121108: CALL_OW 259
121112: PUSH
121113: LD_INT 1
121115: PLUS
121116: PPUSH
121117: CALL_OW 237
121121: GO 121023
121123: POP
121124: POP
// end ;
121125: PPOPN 3
121127: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
121128: LD_EXP 148
121132: IFFALSE 121140
121134: PUSH
121135: LD_EXP 156
121139: AND
121140: IFFALSE 121160
121142: GO 121144
121144: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
121145: LD_INT 4
121147: PPUSH
121148: LD_OWVAR 2
121152: PPUSH
121153: LD_INT 0
121155: PPUSH
121156: CALL_OW 324
121160: END
// every 0 0$1 trigger StreamModeActive and sShovel do
121161: LD_EXP 148
121165: IFFALSE 121173
121167: PUSH
121168: LD_EXP 185
121172: AND
121173: IFFALSE 121193
121175: GO 121177
121177: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
121178: LD_INT 19
121180: PPUSH
121181: LD_OWVAR 2
121185: PPUSH
121186: LD_INT 0
121188: PPUSH
121189: CALL_OW 324
121193: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
121194: LD_EXP 148
121198: IFFALSE 121206
121200: PUSH
121201: LD_EXP 157
121205: AND
121206: IFFALSE 121308
121208: GO 121210
121210: DISABLE
121211: LD_INT 0
121213: PPUSH
121214: PPUSH
// begin enable ;
121215: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
121216: LD_ADDR_VAR 0 2
121220: PUSH
121221: LD_INT 22
121223: PUSH
121224: LD_OWVAR 2
121228: PUSH
121229: EMPTY
121230: LIST
121231: LIST
121232: PUSH
121233: LD_INT 2
121235: PUSH
121236: LD_INT 34
121238: PUSH
121239: LD_INT 11
121241: PUSH
121242: EMPTY
121243: LIST
121244: LIST
121245: PUSH
121246: LD_INT 34
121248: PUSH
121249: LD_INT 30
121251: PUSH
121252: EMPTY
121253: LIST
121254: LIST
121255: PUSH
121256: EMPTY
121257: LIST
121258: LIST
121259: LIST
121260: PUSH
121261: EMPTY
121262: LIST
121263: LIST
121264: PPUSH
121265: CALL_OW 69
121269: ST_TO_ADDR
// if not tmp then
121270: LD_VAR 0 2
121274: NOT
121275: IFFALSE 121279
// exit ;
121277: GO 121308
// for i in tmp do
121279: LD_ADDR_VAR 0 1
121283: PUSH
121284: LD_VAR 0 2
121288: PUSH
121289: FOR_IN
121290: IFFALSE 121306
// begin SetLives ( i , 0 ) ;
121292: LD_VAR 0 1
121296: PPUSH
121297: LD_INT 0
121299: PPUSH
121300: CALL_OW 234
// end ;
121304: GO 121289
121306: POP
121307: POP
// end ;
121308: PPOPN 2
121310: END
// every 0 0$1 trigger StreamModeActive and sBunker do
121311: LD_EXP 148
121315: IFFALSE 121323
121317: PUSH
121318: LD_EXP 158
121322: AND
121323: IFFALSE 121343
121325: GO 121327
121327: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
121328: LD_INT 32
121330: PPUSH
121331: LD_OWVAR 2
121335: PPUSH
121336: LD_INT 0
121338: PPUSH
121339: CALL_OW 324
121343: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
121344: LD_EXP 148
121348: IFFALSE 121356
121350: PUSH
121351: LD_EXP 159
121355: AND
121356: IFFALSE 121539
121358: GO 121360
121360: DISABLE
121361: LD_INT 0
121363: PPUSH
121364: PPUSH
121365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
121366: LD_ADDR_VAR 0 2
121370: PUSH
121371: LD_INT 22
121373: PUSH
121374: LD_OWVAR 2
121378: PUSH
121379: EMPTY
121380: LIST
121381: LIST
121382: PUSH
121383: LD_INT 33
121385: PUSH
121386: LD_INT 3
121388: PUSH
121389: EMPTY
121390: LIST
121391: LIST
121392: PUSH
121393: EMPTY
121394: LIST
121395: LIST
121396: PPUSH
121397: CALL_OW 69
121401: ST_TO_ADDR
// if not tmp then
121402: LD_VAR 0 2
121406: NOT
121407: IFFALSE 121411
// exit ;
121409: GO 121539
// side := 0 ;
121411: LD_ADDR_VAR 0 3
121415: PUSH
121416: LD_INT 0
121418: ST_TO_ADDR
// for i := 1 to 8 do
121419: LD_ADDR_VAR 0 1
121423: PUSH
121424: DOUBLE
121425: LD_INT 1
121427: DEC
121428: ST_TO_ADDR
121429: LD_INT 8
121431: PUSH
121432: FOR_TO
121433: IFFALSE 121483
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
121435: LD_OWVAR 2
121439: PUSH
121440: LD_VAR 0 1
121444: NONEQUAL
121445: IFFALSE 121467
121447: PUSH
121448: LD_OWVAR 2
121452: PPUSH
121453: LD_VAR 0 1
121457: PPUSH
121458: CALL_OW 81
121462: PUSH
121463: LD_INT 2
121465: EQUAL
121466: AND
121467: IFFALSE 121481
// begin side := i ;
121469: LD_ADDR_VAR 0 3
121473: PUSH
121474: LD_VAR 0 1
121478: ST_TO_ADDR
// break ;
121479: GO 121483
// end ;
121481: GO 121432
121483: POP
121484: POP
// if not side then
121485: LD_VAR 0 3
121489: NOT
121490: IFFALSE 121494
// exit ;
121492: GO 121539
// for i := 1 to tmp do
121494: LD_ADDR_VAR 0 1
121498: PUSH
121499: DOUBLE
121500: LD_INT 1
121502: DEC
121503: ST_TO_ADDR
121504: LD_VAR 0 2
121508: PUSH
121509: FOR_TO
121510: IFFALSE 121537
// if Prob ( 60 ) then
121512: LD_INT 60
121514: PPUSH
121515: CALL_OW 13
121519: IFFALSE 121535
// SetSide ( i , side ) ;
121521: LD_VAR 0 1
121525: PPUSH
121526: LD_VAR 0 3
121530: PPUSH
121531: CALL_OW 235
121535: GO 121509
121537: POP
121538: POP
// end ;
121539: PPOPN 3
121541: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
121542: LD_EXP 148
121546: IFFALSE 121554
121548: PUSH
121549: LD_EXP 161
121553: AND
121554: IFFALSE 121673
121556: GO 121558
121558: DISABLE
121559: LD_INT 0
121561: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
121562: LD_ADDR_VAR 0 1
121566: PUSH
121567: LD_INT 22
121569: PUSH
121570: LD_OWVAR 2
121574: PUSH
121575: EMPTY
121576: LIST
121577: LIST
121578: PUSH
121579: LD_INT 21
121581: PUSH
121582: LD_INT 1
121584: PUSH
121585: EMPTY
121586: LIST
121587: LIST
121588: PUSH
121589: LD_INT 3
121591: PUSH
121592: LD_INT 23
121594: PUSH
121595: LD_INT 0
121597: PUSH
121598: EMPTY
121599: LIST
121600: LIST
121601: PUSH
121602: EMPTY
121603: LIST
121604: LIST
121605: PUSH
121606: EMPTY
121607: LIST
121608: LIST
121609: LIST
121610: PPUSH
121611: CALL_OW 69
121615: PUSH
121616: FOR_IN
121617: IFFALSE 121671
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
121619: LD_VAR 0 1
121623: PPUSH
121624: CALL_OW 257
121628: PUSH
121629: LD_INT 1
121631: PUSH
121632: LD_INT 2
121634: PUSH
121635: LD_INT 3
121637: PUSH
121638: LD_INT 4
121640: PUSH
121641: EMPTY
121642: LIST
121643: LIST
121644: LIST
121645: LIST
121646: IN
121647: IFFALSE 121669
// SetClass ( un , rand ( 1 , 4 ) ) ;
121649: LD_VAR 0 1
121653: PPUSH
121654: LD_INT 1
121656: PPUSH
121657: LD_INT 4
121659: PPUSH
121660: CALL_OW 12
121664: PPUSH
121665: CALL_OW 336
121669: GO 121616
121671: POP
121672: POP
// end ;
121673: PPOPN 1
121675: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
121676: LD_EXP 148
121680: IFFALSE 121688
121682: PUSH
121683: LD_EXP 160
121687: AND
121688: IFFALSE 121767
121690: GO 121692
121692: DISABLE
121693: LD_INT 0
121695: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121696: LD_ADDR_VAR 0 1
121700: PUSH
121701: LD_INT 22
121703: PUSH
121704: LD_OWVAR 2
121708: PUSH
121709: EMPTY
121710: LIST
121711: LIST
121712: PUSH
121713: LD_INT 21
121715: PUSH
121716: LD_INT 3
121718: PUSH
121719: EMPTY
121720: LIST
121721: LIST
121722: PUSH
121723: EMPTY
121724: LIST
121725: LIST
121726: PPUSH
121727: CALL_OW 69
121731: ST_TO_ADDR
// if not tmp then
121732: LD_VAR 0 1
121736: NOT
121737: IFFALSE 121741
// exit ;
121739: GO 121767
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
121741: LD_VAR 0 1
121745: PUSH
121746: LD_INT 1
121748: PPUSH
121749: LD_VAR 0 1
121753: PPUSH
121754: CALL_OW 12
121758: ARRAY
121759: PPUSH
121760: LD_INT 100
121762: PPUSH
121763: CALL_OW 234
// end ;
121767: PPOPN 1
121769: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
121770: LD_EXP 148
121774: IFFALSE 121782
121776: PUSH
121777: LD_EXP 162
121781: AND
121782: IFFALSE 121880
121784: GO 121786
121786: DISABLE
121787: LD_INT 0
121789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121790: LD_ADDR_VAR 0 1
121794: PUSH
121795: LD_INT 22
121797: PUSH
121798: LD_OWVAR 2
121802: PUSH
121803: EMPTY
121804: LIST
121805: LIST
121806: PUSH
121807: LD_INT 21
121809: PUSH
121810: LD_INT 1
121812: PUSH
121813: EMPTY
121814: LIST
121815: LIST
121816: PUSH
121817: EMPTY
121818: LIST
121819: LIST
121820: PPUSH
121821: CALL_OW 69
121825: ST_TO_ADDR
// if not tmp then
121826: LD_VAR 0 1
121830: NOT
121831: IFFALSE 121835
// exit ;
121833: GO 121880
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
121835: LD_VAR 0 1
121839: PUSH
121840: LD_INT 1
121842: PPUSH
121843: LD_VAR 0 1
121847: PPUSH
121848: CALL_OW 12
121852: ARRAY
121853: PPUSH
121854: LD_INT 1
121856: PPUSH
121857: LD_INT 4
121859: PPUSH
121860: CALL_OW 12
121864: PPUSH
121865: LD_INT 3000
121867: PPUSH
121868: LD_INT 9000
121870: PPUSH
121871: CALL_OW 12
121875: PPUSH
121876: CALL_OW 492
// end ;
121880: PPOPN 1
121882: END
// every 0 0$1 trigger StreamModeActive and sDepot do
121883: LD_EXP 148
121887: IFFALSE 121895
121889: PUSH
121890: LD_EXP 163
121894: AND
121895: IFFALSE 121915
121897: GO 121899
121899: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
121900: LD_INT 1
121902: PPUSH
121903: LD_OWVAR 2
121907: PPUSH
121908: LD_INT 0
121910: PPUSH
121911: CALL_OW 324
121915: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
121916: LD_EXP 148
121920: IFFALSE 121928
121922: PUSH
121923: LD_EXP 164
121927: AND
121928: IFFALSE 122011
121930: GO 121932
121932: DISABLE
121933: LD_INT 0
121935: PPUSH
121936: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121937: LD_ADDR_VAR 0 2
121941: PUSH
121942: LD_INT 22
121944: PUSH
121945: LD_OWVAR 2
121949: PUSH
121950: EMPTY
121951: LIST
121952: LIST
121953: PUSH
121954: LD_INT 21
121956: PUSH
121957: LD_INT 3
121959: PUSH
121960: EMPTY
121961: LIST
121962: LIST
121963: PUSH
121964: EMPTY
121965: LIST
121966: LIST
121967: PPUSH
121968: CALL_OW 69
121972: ST_TO_ADDR
// if not tmp then
121973: LD_VAR 0 2
121977: NOT
121978: IFFALSE 121982
// exit ;
121980: GO 122011
// for i in tmp do
121982: LD_ADDR_VAR 0 1
121986: PUSH
121987: LD_VAR 0 2
121991: PUSH
121992: FOR_IN
121993: IFFALSE 122009
// SetBLevel ( i , 10 ) ;
121995: LD_VAR 0 1
121999: PPUSH
122000: LD_INT 10
122002: PPUSH
122003: CALL_OW 241
122007: GO 121992
122009: POP
122010: POP
// end ;
122011: PPOPN 2
122013: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
122014: LD_EXP 148
122018: IFFALSE 122026
122020: PUSH
122021: LD_EXP 165
122025: AND
122026: IFFALSE 122137
122028: GO 122030
122030: DISABLE
122031: LD_INT 0
122033: PPUSH
122034: PPUSH
122035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122036: LD_ADDR_VAR 0 3
122040: PUSH
122041: LD_INT 22
122043: PUSH
122044: LD_OWVAR 2
122048: PUSH
122049: EMPTY
122050: LIST
122051: LIST
122052: PUSH
122053: LD_INT 25
122055: PUSH
122056: LD_INT 1
122058: PUSH
122059: EMPTY
122060: LIST
122061: LIST
122062: PUSH
122063: EMPTY
122064: LIST
122065: LIST
122066: PPUSH
122067: CALL_OW 69
122071: ST_TO_ADDR
// if not tmp then
122072: LD_VAR 0 3
122076: NOT
122077: IFFALSE 122081
// exit ;
122079: GO 122137
// un := tmp [ rand ( 1 , tmp ) ] ;
122081: LD_ADDR_VAR 0 2
122085: PUSH
122086: LD_VAR 0 3
122090: PUSH
122091: LD_INT 1
122093: PPUSH
122094: LD_VAR 0 3
122098: PPUSH
122099: CALL_OW 12
122103: ARRAY
122104: ST_TO_ADDR
// if Crawls ( un ) then
122105: LD_VAR 0 2
122109: PPUSH
122110: CALL_OW 318
122114: IFFALSE 122125
// ComWalk ( un ) ;
122116: LD_VAR 0 2
122120: PPUSH
122121: CALL_OW 138
// SetClass ( un , class_sniper ) ;
122125: LD_VAR 0 2
122129: PPUSH
122130: LD_INT 5
122132: PPUSH
122133: CALL_OW 336
// end ;
122137: PPOPN 3
122139: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
122140: LD_EXP 148
122144: IFFALSE 122152
122146: PUSH
122147: LD_EXP 166
122151: AND
122152: IFFALSE 122164
122154: PUSH
122155: LD_OWVAR 67
122159: PUSH
122160: LD_INT 4
122162: LESS
122163: AND
122164: IFFALSE 122183
122166: GO 122168
122168: DISABLE
// begin Difficulty := Difficulty + 1 ;
122169: LD_ADDR_OWVAR 67
122173: PUSH
122174: LD_OWVAR 67
122178: PUSH
122179: LD_INT 1
122181: PLUS
122182: ST_TO_ADDR
// end ;
122183: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
122184: LD_EXP 148
122188: IFFALSE 122196
122190: PUSH
122191: LD_EXP 167
122195: AND
122196: IFFALSE 122299
122198: GO 122200
122200: DISABLE
122201: LD_INT 0
122203: PPUSH
// begin for i := 1 to 5 do
122204: LD_ADDR_VAR 0 1
122208: PUSH
122209: DOUBLE
122210: LD_INT 1
122212: DEC
122213: ST_TO_ADDR
122214: LD_INT 5
122216: PUSH
122217: FOR_TO
122218: IFFALSE 122297
// begin uc_nation := nation_nature ;
122220: LD_ADDR_OWVAR 21
122224: PUSH
122225: LD_INT 0
122227: ST_TO_ADDR
// uc_side := 0 ;
122228: LD_ADDR_OWVAR 20
122232: PUSH
122233: LD_INT 0
122235: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122236: LD_ADDR_OWVAR 29
122240: PUSH
122241: LD_INT 12
122243: PUSH
122244: LD_INT 12
122246: PUSH
122247: EMPTY
122248: LIST
122249: LIST
122250: ST_TO_ADDR
// hc_agressivity := 20 ;
122251: LD_ADDR_OWVAR 35
122255: PUSH
122256: LD_INT 20
122258: ST_TO_ADDR
// hc_class := class_tiger ;
122259: LD_ADDR_OWVAR 28
122263: PUSH
122264: LD_INT 14
122266: ST_TO_ADDR
// hc_gallery :=  ;
122267: LD_ADDR_OWVAR 33
122271: PUSH
122272: LD_STRING 
122274: ST_TO_ADDR
// hc_name :=  ;
122275: LD_ADDR_OWVAR 26
122279: PUSH
122280: LD_STRING 
122282: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
122283: CALL_OW 44
122287: PPUSH
122288: LD_INT 0
122290: PPUSH
122291: CALL_OW 51
// end ;
122295: GO 122217
122297: POP
122298: POP
// end ;
122299: PPOPN 1
122301: END
// every 0 0$1 trigger StreamModeActive and sBomb do
122302: LD_EXP 148
122306: IFFALSE 122314
122308: PUSH
122309: LD_EXP 168
122313: AND
122314: IFFALSE 122323
122316: GO 122318
122318: DISABLE
// StreamSibBomb ;
122319: CALL 122324 0 0
122323: END
// export function StreamSibBomb ; var i , x , y ; begin
122324: LD_INT 0
122326: PPUSH
122327: PPUSH
122328: PPUSH
122329: PPUSH
// result := false ;
122330: LD_ADDR_VAR 0 1
122334: PUSH
122335: LD_INT 0
122337: ST_TO_ADDR
// for i := 1 to 16 do
122338: LD_ADDR_VAR 0 2
122342: PUSH
122343: DOUBLE
122344: LD_INT 1
122346: DEC
122347: ST_TO_ADDR
122348: LD_INT 16
122350: PUSH
122351: FOR_TO
122352: IFFALSE 122551
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122354: LD_ADDR_VAR 0 3
122358: PUSH
122359: LD_INT 10
122361: PUSH
122362: LD_INT 20
122364: PUSH
122365: LD_INT 30
122367: PUSH
122368: LD_INT 40
122370: PUSH
122371: LD_INT 50
122373: PUSH
122374: LD_INT 60
122376: PUSH
122377: LD_INT 70
122379: PUSH
122380: LD_INT 80
122382: PUSH
122383: LD_INT 90
122385: PUSH
122386: LD_INT 100
122388: PUSH
122389: LD_INT 110
122391: PUSH
122392: LD_INT 120
122394: PUSH
122395: LD_INT 130
122397: PUSH
122398: LD_INT 140
122400: PUSH
122401: LD_INT 150
122403: PUSH
122404: EMPTY
122405: LIST
122406: LIST
122407: LIST
122408: LIST
122409: LIST
122410: LIST
122411: LIST
122412: LIST
122413: LIST
122414: LIST
122415: LIST
122416: LIST
122417: LIST
122418: LIST
122419: LIST
122420: PUSH
122421: LD_INT 1
122423: PPUSH
122424: LD_INT 15
122426: PPUSH
122427: CALL_OW 12
122431: ARRAY
122432: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122433: LD_ADDR_VAR 0 4
122437: PUSH
122438: LD_INT 10
122440: PUSH
122441: LD_INT 20
122443: PUSH
122444: LD_INT 30
122446: PUSH
122447: LD_INT 40
122449: PUSH
122450: LD_INT 50
122452: PUSH
122453: LD_INT 60
122455: PUSH
122456: LD_INT 70
122458: PUSH
122459: LD_INT 80
122461: PUSH
122462: LD_INT 90
122464: PUSH
122465: LD_INT 100
122467: PUSH
122468: LD_INT 110
122470: PUSH
122471: LD_INT 120
122473: PUSH
122474: LD_INT 130
122476: PUSH
122477: LD_INT 140
122479: PUSH
122480: LD_INT 150
122482: PUSH
122483: EMPTY
122484: LIST
122485: LIST
122486: LIST
122487: LIST
122488: LIST
122489: LIST
122490: LIST
122491: LIST
122492: LIST
122493: LIST
122494: LIST
122495: LIST
122496: LIST
122497: LIST
122498: LIST
122499: PUSH
122500: LD_INT 1
122502: PPUSH
122503: LD_INT 15
122505: PPUSH
122506: CALL_OW 12
122510: ARRAY
122511: ST_TO_ADDR
// if ValidHex ( x , y ) then
122512: LD_VAR 0 3
122516: PPUSH
122517: LD_VAR 0 4
122521: PPUSH
122522: CALL_OW 488
122526: IFFALSE 122549
// begin result := [ x , y ] ;
122528: LD_ADDR_VAR 0 1
122532: PUSH
122533: LD_VAR 0 3
122537: PUSH
122538: LD_VAR 0 4
122542: PUSH
122543: EMPTY
122544: LIST
122545: LIST
122546: ST_TO_ADDR
// break ;
122547: GO 122551
// end ; end ;
122549: GO 122351
122551: POP
122552: POP
// if result then
122553: LD_VAR 0 1
122557: IFFALSE 122617
// begin ToLua ( playSibBomb() ) ;
122559: LD_STRING playSibBomb()
122561: PPUSH
122562: CALL_OW 559
// wait ( 0 0$14 ) ;
122566: LD_INT 490
122568: PPUSH
122569: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
122573: LD_VAR 0 1
122577: PUSH
122578: LD_INT 1
122580: ARRAY
122581: PPUSH
122582: LD_VAR 0 1
122586: PUSH
122587: LD_INT 2
122589: ARRAY
122590: PPUSH
122591: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
122595: LD_VAR 0 1
122599: PUSH
122600: LD_INT 1
122602: ARRAY
122603: PPUSH
122604: LD_VAR 0 1
122608: PUSH
122609: LD_INT 2
122611: ARRAY
122612: PPUSH
122613: CALL_OW 429
// end ; end ;
122617: LD_VAR 0 1
122621: RET
// every 0 0$1 trigger StreamModeActive and sReset do
122622: LD_EXP 148
122626: IFFALSE 122634
122628: PUSH
122629: LD_EXP 170
122633: AND
122634: IFFALSE 122646
122636: GO 122638
122638: DISABLE
// YouLost (  ) ;
122639: LD_STRING 
122641: PPUSH
122642: CALL_OW 104
122646: END
// every 0 0$1 trigger StreamModeActive and sFog do
122647: LD_EXP 148
122651: IFFALSE 122659
122653: PUSH
122654: LD_EXP 169
122658: AND
122659: IFFALSE 122673
122661: GO 122663
122663: DISABLE
// FogOff ( your_side ) ;
122664: LD_OWVAR 2
122668: PPUSH
122669: CALL_OW 344
122673: END
// every 0 0$1 trigger StreamModeActive and sSun do
122674: LD_EXP 148
122678: IFFALSE 122686
122680: PUSH
122681: LD_EXP 171
122685: AND
122686: IFFALSE 122714
122688: GO 122690
122690: DISABLE
// begin solar_recharge_percent := 0 ;
122691: LD_ADDR_OWVAR 79
122695: PUSH
122696: LD_INT 0
122698: ST_TO_ADDR
// wait ( 5 5$00 ) ;
122699: LD_INT 10500
122701: PPUSH
122702: CALL_OW 67
// solar_recharge_percent := 100 ;
122706: LD_ADDR_OWVAR 79
122710: PUSH
122711: LD_INT 100
122713: ST_TO_ADDR
// end ;
122714: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
122715: LD_EXP 148
122719: IFFALSE 122727
122721: PUSH
122722: LD_EXP 172
122726: AND
122727: IFFALSE 122966
122729: GO 122731
122731: DISABLE
122732: LD_INT 0
122734: PPUSH
122735: PPUSH
122736: PPUSH
// begin tmp := [ ] ;
122737: LD_ADDR_VAR 0 3
122741: PUSH
122742: EMPTY
122743: ST_TO_ADDR
// for i := 1 to 6 do
122744: LD_ADDR_VAR 0 1
122748: PUSH
122749: DOUBLE
122750: LD_INT 1
122752: DEC
122753: ST_TO_ADDR
122754: LD_INT 6
122756: PUSH
122757: FOR_TO
122758: IFFALSE 122863
// begin uc_nation := nation_nature ;
122760: LD_ADDR_OWVAR 21
122764: PUSH
122765: LD_INT 0
122767: ST_TO_ADDR
// uc_side := 0 ;
122768: LD_ADDR_OWVAR 20
122772: PUSH
122773: LD_INT 0
122775: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122776: LD_ADDR_OWVAR 29
122780: PUSH
122781: LD_INT 12
122783: PUSH
122784: LD_INT 12
122786: PUSH
122787: EMPTY
122788: LIST
122789: LIST
122790: ST_TO_ADDR
// hc_agressivity := 20 ;
122791: LD_ADDR_OWVAR 35
122795: PUSH
122796: LD_INT 20
122798: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
122799: LD_ADDR_OWVAR 28
122803: PUSH
122804: LD_INT 17
122806: ST_TO_ADDR
// hc_gallery :=  ;
122807: LD_ADDR_OWVAR 33
122811: PUSH
122812: LD_STRING 
122814: ST_TO_ADDR
// hc_name :=  ;
122815: LD_ADDR_OWVAR 26
122819: PUSH
122820: LD_STRING 
122822: ST_TO_ADDR
// un := CreateHuman ;
122823: LD_ADDR_VAR 0 2
122827: PUSH
122828: CALL_OW 44
122832: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
122833: LD_VAR 0 2
122837: PPUSH
122838: LD_INT 1
122840: PPUSH
122841: CALL_OW 51
// tmp := tmp ^ un ;
122845: LD_ADDR_VAR 0 3
122849: PUSH
122850: LD_VAR 0 3
122854: PUSH
122855: LD_VAR 0 2
122859: ADD
122860: ST_TO_ADDR
// end ;
122861: GO 122757
122863: POP
122864: POP
// repeat wait ( 0 0$1 ) ;
122865: LD_INT 35
122867: PPUSH
122868: CALL_OW 67
// for un in tmp do
122872: LD_ADDR_VAR 0 2
122876: PUSH
122877: LD_VAR 0 3
122881: PUSH
122882: FOR_IN
122883: IFFALSE 122957
// begin if IsDead ( un ) then
122885: LD_VAR 0 2
122889: PPUSH
122890: CALL_OW 301
122894: IFFALSE 122914
// begin tmp := tmp diff un ;
122896: LD_ADDR_VAR 0 3
122900: PUSH
122901: LD_VAR 0 3
122905: PUSH
122906: LD_VAR 0 2
122910: DIFF
122911: ST_TO_ADDR
// continue ;
122912: GO 122882
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
122914: LD_VAR 0 2
122918: PPUSH
122919: LD_INT 3
122921: PUSH
122922: LD_INT 22
122924: PUSH
122925: LD_INT 0
122927: PUSH
122928: EMPTY
122929: LIST
122930: LIST
122931: PUSH
122932: EMPTY
122933: LIST
122934: LIST
122935: PPUSH
122936: CALL_OW 69
122940: PPUSH
122941: LD_VAR 0 2
122945: PPUSH
122946: CALL_OW 74
122950: PPUSH
122951: CALL_OW 115
// end ;
122955: GO 122882
122957: POP
122958: POP
// until not tmp ;
122959: LD_VAR 0 3
122963: NOT
122964: IFFALSE 122865
// end ;
122966: PPOPN 3
122968: END
// every 0 0$1 trigger StreamModeActive and sTroll do
122969: LD_EXP 148
122973: IFFALSE 122981
122975: PUSH
122976: LD_EXP 173
122980: AND
122981: IFFALSE 123035
122983: GO 122985
122985: DISABLE
// begin ToLua ( displayTroll(); ) ;
122986: LD_STRING displayTroll();
122988: PPUSH
122989: CALL_OW 559
// wait ( 3 3$00 ) ;
122993: LD_INT 6300
122995: PPUSH
122996: CALL_OW 67
// ToLua ( hideTroll(); ) ;
123000: LD_STRING hideTroll();
123002: PPUSH
123003: CALL_OW 559
// wait ( 1 1$00 ) ;
123007: LD_INT 2100
123009: PPUSH
123010: CALL_OW 67
// ToLua ( displayTroll(); ) ;
123014: LD_STRING displayTroll();
123016: PPUSH
123017: CALL_OW 559
// wait ( 1 1$00 ) ;
123021: LD_INT 2100
123023: PPUSH
123024: CALL_OW 67
// ToLua ( hideTroll(); ) ;
123028: LD_STRING hideTroll();
123030: PPUSH
123031: CALL_OW 559
// end ;
123035: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
123036: LD_EXP 148
123040: IFFALSE 123048
123042: PUSH
123043: LD_EXP 174
123047: AND
123048: IFFALSE 123111
123050: GO 123052
123052: DISABLE
123053: LD_INT 0
123055: PPUSH
// begin p := 0 ;
123056: LD_ADDR_VAR 0 1
123060: PUSH
123061: LD_INT 0
123063: ST_TO_ADDR
// repeat game_speed := 1 ;
123064: LD_ADDR_OWVAR 65
123068: PUSH
123069: LD_INT 1
123071: ST_TO_ADDR
// wait ( 0 0$1 ) ;
123072: LD_INT 35
123074: PPUSH
123075: CALL_OW 67
// p := p + 1 ;
123079: LD_ADDR_VAR 0 1
123083: PUSH
123084: LD_VAR 0 1
123088: PUSH
123089: LD_INT 1
123091: PLUS
123092: ST_TO_ADDR
// until p >= 60 ;
123093: LD_VAR 0 1
123097: PUSH
123098: LD_INT 60
123100: GREATEREQUAL
123101: IFFALSE 123064
// game_speed := 4 ;
123103: LD_ADDR_OWVAR 65
123107: PUSH
123108: LD_INT 4
123110: ST_TO_ADDR
// end ;
123111: PPOPN 1
123113: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
123114: LD_EXP 148
123118: IFFALSE 123126
123120: PUSH
123121: LD_EXP 175
123125: AND
123126: IFFALSE 123272
123128: GO 123130
123130: DISABLE
123131: LD_INT 0
123133: PPUSH
123134: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123135: LD_ADDR_VAR 0 1
123139: PUSH
123140: LD_INT 22
123142: PUSH
123143: LD_OWVAR 2
123147: PUSH
123148: EMPTY
123149: LIST
123150: LIST
123151: PUSH
123152: LD_INT 2
123154: PUSH
123155: LD_INT 30
123157: PUSH
123158: LD_INT 0
123160: PUSH
123161: EMPTY
123162: LIST
123163: LIST
123164: PUSH
123165: LD_INT 30
123167: PUSH
123168: LD_INT 1
123170: PUSH
123171: EMPTY
123172: LIST
123173: LIST
123174: PUSH
123175: EMPTY
123176: LIST
123177: LIST
123178: LIST
123179: PUSH
123180: EMPTY
123181: LIST
123182: LIST
123183: PPUSH
123184: CALL_OW 69
123188: ST_TO_ADDR
// if not depot then
123189: LD_VAR 0 1
123193: NOT
123194: IFFALSE 123198
// exit ;
123196: GO 123272
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
123198: LD_ADDR_VAR 0 2
123202: PUSH
123203: LD_VAR 0 1
123207: PUSH
123208: LD_INT 1
123210: PPUSH
123211: LD_VAR 0 1
123215: PPUSH
123216: CALL_OW 12
123220: ARRAY
123221: PPUSH
123222: CALL_OW 274
123226: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
123227: LD_VAR 0 2
123231: PPUSH
123232: LD_INT 1
123234: PPUSH
123235: LD_INT 0
123237: PPUSH
123238: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
123242: LD_VAR 0 2
123246: PPUSH
123247: LD_INT 2
123249: PPUSH
123250: LD_INT 0
123252: PPUSH
123253: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
123257: LD_VAR 0 2
123261: PPUSH
123262: LD_INT 3
123264: PPUSH
123265: LD_INT 0
123267: PPUSH
123268: CALL_OW 277
// end ;
123272: PPOPN 2
123274: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
123275: LD_EXP 148
123279: IFFALSE 123287
123281: PUSH
123282: LD_EXP 176
123286: AND
123287: IFFALSE 123384
123289: GO 123291
123291: DISABLE
123292: LD_INT 0
123294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123295: LD_ADDR_VAR 0 1
123299: PUSH
123300: LD_INT 22
123302: PUSH
123303: LD_OWVAR 2
123307: PUSH
123308: EMPTY
123309: LIST
123310: LIST
123311: PUSH
123312: LD_INT 21
123314: PUSH
123315: LD_INT 1
123317: PUSH
123318: EMPTY
123319: LIST
123320: LIST
123321: PUSH
123322: LD_INT 3
123324: PUSH
123325: LD_INT 23
123327: PUSH
123328: LD_INT 0
123330: PUSH
123331: EMPTY
123332: LIST
123333: LIST
123334: PUSH
123335: EMPTY
123336: LIST
123337: LIST
123338: PUSH
123339: EMPTY
123340: LIST
123341: LIST
123342: LIST
123343: PPUSH
123344: CALL_OW 69
123348: ST_TO_ADDR
// if not tmp then
123349: LD_VAR 0 1
123353: NOT
123354: IFFALSE 123358
// exit ;
123356: GO 123384
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
123358: LD_VAR 0 1
123362: PUSH
123363: LD_INT 1
123365: PPUSH
123366: LD_VAR 0 1
123370: PPUSH
123371: CALL_OW 12
123375: ARRAY
123376: PPUSH
123377: LD_INT 200
123379: PPUSH
123380: CALL_OW 234
// end ;
123384: PPOPN 1
123386: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
123387: LD_EXP 148
123391: IFFALSE 123399
123393: PUSH
123394: LD_EXP 177
123398: AND
123399: IFFALSE 123478
123401: GO 123403
123403: DISABLE
123404: LD_INT 0
123406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
123407: LD_ADDR_VAR 0 1
123411: PUSH
123412: LD_INT 22
123414: PUSH
123415: LD_OWVAR 2
123419: PUSH
123420: EMPTY
123421: LIST
123422: LIST
123423: PUSH
123424: LD_INT 21
123426: PUSH
123427: LD_INT 2
123429: PUSH
123430: EMPTY
123431: LIST
123432: LIST
123433: PUSH
123434: EMPTY
123435: LIST
123436: LIST
123437: PPUSH
123438: CALL_OW 69
123442: ST_TO_ADDR
// if not tmp then
123443: LD_VAR 0 1
123447: NOT
123448: IFFALSE 123452
// exit ;
123450: GO 123478
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
123452: LD_VAR 0 1
123456: PUSH
123457: LD_INT 1
123459: PPUSH
123460: LD_VAR 0 1
123464: PPUSH
123465: CALL_OW 12
123469: ARRAY
123470: PPUSH
123471: LD_INT 60
123473: PPUSH
123474: CALL_OW 234
// end ;
123478: PPOPN 1
123480: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
123481: LD_EXP 148
123485: IFFALSE 123493
123487: PUSH
123488: LD_EXP 178
123492: AND
123493: IFFALSE 123592
123495: GO 123497
123497: DISABLE
123498: LD_INT 0
123500: PPUSH
123501: PPUSH
// begin enable ;
123502: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
123503: LD_ADDR_VAR 0 1
123507: PUSH
123508: LD_INT 22
123510: PUSH
123511: LD_OWVAR 2
123515: PUSH
123516: EMPTY
123517: LIST
123518: LIST
123519: PUSH
123520: LD_INT 61
123522: PUSH
123523: EMPTY
123524: LIST
123525: PUSH
123526: LD_INT 33
123528: PUSH
123529: LD_INT 2
123531: PUSH
123532: EMPTY
123533: LIST
123534: LIST
123535: PUSH
123536: EMPTY
123537: LIST
123538: LIST
123539: LIST
123540: PPUSH
123541: CALL_OW 69
123545: ST_TO_ADDR
// if not tmp then
123546: LD_VAR 0 1
123550: NOT
123551: IFFALSE 123555
// exit ;
123553: GO 123592
// for i in tmp do
123555: LD_ADDR_VAR 0 2
123559: PUSH
123560: LD_VAR 0 1
123564: PUSH
123565: FOR_IN
123566: IFFALSE 123590
// if IsControledBy ( i ) then
123568: LD_VAR 0 2
123572: PPUSH
123573: CALL_OW 312
123577: IFFALSE 123588
// ComUnlink ( i ) ;
123579: LD_VAR 0 2
123583: PPUSH
123584: CALL_OW 136
123588: GO 123565
123590: POP
123591: POP
// end ;
123592: PPOPN 2
123594: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
123595: LD_EXP 148
123599: IFFALSE 123607
123601: PUSH
123602: LD_EXP 179
123606: AND
123607: IFFALSE 123747
123609: GO 123611
123611: DISABLE
123612: LD_INT 0
123614: PPUSH
123615: PPUSH
// begin ToLua ( displayPowell(); ) ;
123616: LD_STRING displayPowell();
123618: PPUSH
123619: CALL_OW 559
// uc_side := 0 ;
123623: LD_ADDR_OWVAR 20
123627: PUSH
123628: LD_INT 0
123630: ST_TO_ADDR
// uc_nation := 2 ;
123631: LD_ADDR_OWVAR 21
123635: PUSH
123636: LD_INT 2
123638: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
123639: LD_ADDR_OWVAR 37
123643: PUSH
123644: LD_INT 14
123646: ST_TO_ADDR
// vc_engine := engine_siberite ;
123647: LD_ADDR_OWVAR 39
123651: PUSH
123652: LD_INT 3
123654: ST_TO_ADDR
// vc_control := control_apeman ;
123655: LD_ADDR_OWVAR 38
123659: PUSH
123660: LD_INT 5
123662: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
123663: LD_ADDR_OWVAR 40
123667: PUSH
123668: LD_INT 29
123670: ST_TO_ADDR
// un := CreateVehicle ;
123671: LD_ADDR_VAR 0 2
123675: PUSH
123676: CALL_OW 45
123680: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123681: LD_VAR 0 2
123685: PPUSH
123686: LD_INT 1
123688: PPUSH
123689: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123693: LD_INT 35
123695: PPUSH
123696: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123700: LD_VAR 0 2
123704: PPUSH
123705: LD_INT 22
123707: PUSH
123708: LD_OWVAR 2
123712: PUSH
123713: EMPTY
123714: LIST
123715: LIST
123716: PPUSH
123717: CALL_OW 69
123721: PPUSH
123722: LD_VAR 0 2
123726: PPUSH
123727: CALL_OW 74
123731: PPUSH
123732: CALL_OW 115
// until IsDead ( un ) ;
123736: LD_VAR 0 2
123740: PPUSH
123741: CALL_OW 301
123745: IFFALSE 123693
// end ;
123747: PPOPN 2
123749: END
// every 0 0$1 trigger StreamModeActive and sStu do
123750: LD_EXP 148
123754: IFFALSE 123762
123756: PUSH
123757: LD_EXP 187
123761: AND
123762: IFFALSE 123778
123764: GO 123766
123766: DISABLE
// begin ToLua ( displayStucuk(); ) ;
123767: LD_STRING displayStucuk();
123769: PPUSH
123770: CALL_OW 559
// ResetFog ;
123774: CALL_OW 335
// end ;
123778: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
123779: LD_EXP 148
123783: IFFALSE 123791
123785: PUSH
123786: LD_EXP 180
123790: AND
123791: IFFALSE 123932
123793: GO 123795
123795: DISABLE
123796: LD_INT 0
123798: PPUSH
123799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
123800: LD_ADDR_VAR 0 2
123804: PUSH
123805: LD_INT 22
123807: PUSH
123808: LD_OWVAR 2
123812: PUSH
123813: EMPTY
123814: LIST
123815: LIST
123816: PUSH
123817: LD_INT 21
123819: PUSH
123820: LD_INT 1
123822: PUSH
123823: EMPTY
123824: LIST
123825: LIST
123826: PUSH
123827: EMPTY
123828: LIST
123829: LIST
123830: PPUSH
123831: CALL_OW 69
123835: ST_TO_ADDR
// if not tmp then
123836: LD_VAR 0 2
123840: NOT
123841: IFFALSE 123845
// exit ;
123843: GO 123932
// un := tmp [ rand ( 1 , tmp ) ] ;
123845: LD_ADDR_VAR 0 1
123849: PUSH
123850: LD_VAR 0 2
123854: PUSH
123855: LD_INT 1
123857: PPUSH
123858: LD_VAR 0 2
123862: PPUSH
123863: CALL_OW 12
123867: ARRAY
123868: ST_TO_ADDR
// SetSide ( un , 0 ) ;
123869: LD_VAR 0 1
123873: PPUSH
123874: LD_INT 0
123876: PPUSH
123877: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
123881: LD_VAR 0 1
123885: PPUSH
123886: LD_OWVAR 3
123890: PUSH
123891: LD_VAR 0 1
123895: DIFF
123896: PPUSH
123897: LD_VAR 0 1
123901: PPUSH
123902: CALL_OW 74
123906: PPUSH
123907: CALL_OW 115
// wait ( 0 0$20 ) ;
123911: LD_INT 700
123913: PPUSH
123914: CALL_OW 67
// SetSide ( un , your_side ) ;
123918: LD_VAR 0 1
123922: PPUSH
123923: LD_OWVAR 2
123927: PPUSH
123928: CALL_OW 235
// end ;
123932: PPOPN 2
123934: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
123935: LD_EXP 148
123939: IFFALSE 123947
123941: PUSH
123942: LD_EXP 181
123946: AND
123947: IFFALSE 124053
123949: GO 123951
123951: DISABLE
123952: LD_INT 0
123954: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123955: LD_ADDR_VAR 0 1
123959: PUSH
123960: LD_INT 22
123962: PUSH
123963: LD_OWVAR 2
123967: PUSH
123968: EMPTY
123969: LIST
123970: LIST
123971: PUSH
123972: LD_INT 2
123974: PUSH
123975: LD_INT 30
123977: PUSH
123978: LD_INT 0
123980: PUSH
123981: EMPTY
123982: LIST
123983: LIST
123984: PUSH
123985: LD_INT 30
123987: PUSH
123988: LD_INT 1
123990: PUSH
123991: EMPTY
123992: LIST
123993: LIST
123994: PUSH
123995: EMPTY
123996: LIST
123997: LIST
123998: LIST
123999: PUSH
124000: EMPTY
124001: LIST
124002: LIST
124003: PPUSH
124004: CALL_OW 69
124008: ST_TO_ADDR
// if not depot then
124009: LD_VAR 0 1
124013: NOT
124014: IFFALSE 124018
// exit ;
124016: GO 124053
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
124018: LD_VAR 0 1
124022: PUSH
124023: LD_INT 1
124025: ARRAY
124026: PPUSH
124027: CALL_OW 250
124031: PPUSH
124032: LD_VAR 0 1
124036: PUSH
124037: LD_INT 1
124039: ARRAY
124040: PPUSH
124041: CALL_OW 251
124045: PPUSH
124046: LD_INT 70
124048: PPUSH
124049: CALL_OW 495
// end ;
124053: PPOPN 1
124055: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
124056: LD_EXP 148
124060: IFFALSE 124068
124062: PUSH
124063: LD_EXP 182
124067: AND
124068: IFFALSE 124279
124070: GO 124072
124072: DISABLE
124073: LD_INT 0
124075: PPUSH
124076: PPUSH
124077: PPUSH
124078: PPUSH
124079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
124080: LD_ADDR_VAR 0 5
124084: PUSH
124085: LD_INT 22
124087: PUSH
124088: LD_OWVAR 2
124092: PUSH
124093: EMPTY
124094: LIST
124095: LIST
124096: PUSH
124097: LD_INT 21
124099: PUSH
124100: LD_INT 1
124102: PUSH
124103: EMPTY
124104: LIST
124105: LIST
124106: PUSH
124107: EMPTY
124108: LIST
124109: LIST
124110: PPUSH
124111: CALL_OW 69
124115: ST_TO_ADDR
// if not tmp then
124116: LD_VAR 0 5
124120: NOT
124121: IFFALSE 124125
// exit ;
124123: GO 124279
// for i in tmp do
124125: LD_ADDR_VAR 0 1
124129: PUSH
124130: LD_VAR 0 5
124134: PUSH
124135: FOR_IN
124136: IFFALSE 124277
// begin d := rand ( 0 , 5 ) ;
124138: LD_ADDR_VAR 0 4
124142: PUSH
124143: LD_INT 0
124145: PPUSH
124146: LD_INT 5
124148: PPUSH
124149: CALL_OW 12
124153: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
124154: LD_ADDR_VAR 0 2
124158: PUSH
124159: LD_VAR 0 1
124163: PPUSH
124164: CALL_OW 250
124168: PPUSH
124169: LD_VAR 0 4
124173: PPUSH
124174: LD_INT 3
124176: PPUSH
124177: LD_INT 12
124179: PPUSH
124180: CALL_OW 12
124184: PPUSH
124185: CALL_OW 272
124189: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
124190: LD_ADDR_VAR 0 3
124194: PUSH
124195: LD_VAR 0 1
124199: PPUSH
124200: CALL_OW 251
124204: PPUSH
124205: LD_VAR 0 4
124209: PPUSH
124210: LD_INT 3
124212: PPUSH
124213: LD_INT 12
124215: PPUSH
124216: CALL_OW 12
124220: PPUSH
124221: CALL_OW 273
124225: ST_TO_ADDR
// if ValidHex ( x , y ) then
124226: LD_VAR 0 2
124230: PPUSH
124231: LD_VAR 0 3
124235: PPUSH
124236: CALL_OW 488
124240: IFFALSE 124275
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
124242: LD_VAR 0 1
124246: PPUSH
124247: LD_VAR 0 2
124251: PPUSH
124252: LD_VAR 0 3
124256: PPUSH
124257: LD_INT 3
124259: PPUSH
124260: LD_INT 6
124262: PPUSH
124263: CALL_OW 12
124267: PPUSH
124268: LD_INT 1
124270: PPUSH
124271: CALL_OW 483
// end ;
124275: GO 124135
124277: POP
124278: POP
// end ;
124279: PPOPN 5
124281: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
124282: LD_EXP 148
124286: IFFALSE 124294
124288: PUSH
124289: LD_EXP 183
124293: AND
124294: IFFALSE 124388
124296: GO 124298
124298: DISABLE
124299: LD_INT 0
124301: PPUSH
124302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
124303: LD_ADDR_VAR 0 2
124307: PUSH
124308: LD_INT 22
124310: PUSH
124311: LD_OWVAR 2
124315: PUSH
124316: EMPTY
124317: LIST
124318: LIST
124319: PUSH
124320: LD_INT 32
124322: PUSH
124323: LD_INT 1
124325: PUSH
124326: EMPTY
124327: LIST
124328: LIST
124329: PUSH
124330: LD_INT 21
124332: PUSH
124333: LD_INT 2
124335: PUSH
124336: EMPTY
124337: LIST
124338: LIST
124339: PUSH
124340: EMPTY
124341: LIST
124342: LIST
124343: LIST
124344: PPUSH
124345: CALL_OW 69
124349: ST_TO_ADDR
// if not tmp then
124350: LD_VAR 0 2
124354: NOT
124355: IFFALSE 124359
// exit ;
124357: GO 124388
// for i in tmp do
124359: LD_ADDR_VAR 0 1
124363: PUSH
124364: LD_VAR 0 2
124368: PUSH
124369: FOR_IN
124370: IFFALSE 124386
// SetFuel ( i , 0 ) ;
124372: LD_VAR 0 1
124376: PPUSH
124377: LD_INT 0
124379: PPUSH
124380: CALL_OW 240
124384: GO 124369
124386: POP
124387: POP
// end ;
124388: PPOPN 2
124390: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
124391: LD_EXP 148
124395: IFFALSE 124403
124397: PUSH
124398: LD_EXP 184
124402: AND
124403: IFFALSE 124469
124405: GO 124407
124407: DISABLE
124408: LD_INT 0
124410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124411: LD_ADDR_VAR 0 1
124415: PUSH
124416: LD_INT 22
124418: PUSH
124419: LD_OWVAR 2
124423: PUSH
124424: EMPTY
124425: LIST
124426: LIST
124427: PUSH
124428: LD_INT 30
124430: PUSH
124431: LD_INT 29
124433: PUSH
124434: EMPTY
124435: LIST
124436: LIST
124437: PUSH
124438: EMPTY
124439: LIST
124440: LIST
124441: PPUSH
124442: CALL_OW 69
124446: ST_TO_ADDR
// if not tmp then
124447: LD_VAR 0 1
124451: NOT
124452: IFFALSE 124456
// exit ;
124454: GO 124469
// DestroyUnit ( tmp [ 1 ] ) ;
124456: LD_VAR 0 1
124460: PUSH
124461: LD_INT 1
124463: ARRAY
124464: PPUSH
124465: CALL_OW 65
// end ;
124469: PPOPN 1
124471: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
124472: LD_EXP 148
124476: IFFALSE 124484
124478: PUSH
124479: LD_EXP 186
124483: AND
124484: IFFALSE 124613
124486: GO 124488
124488: DISABLE
124489: LD_INT 0
124491: PPUSH
// begin uc_side := 0 ;
124492: LD_ADDR_OWVAR 20
124496: PUSH
124497: LD_INT 0
124499: ST_TO_ADDR
// uc_nation := nation_arabian ;
124500: LD_ADDR_OWVAR 21
124504: PUSH
124505: LD_INT 2
124507: ST_TO_ADDR
// hc_gallery :=  ;
124508: LD_ADDR_OWVAR 33
124512: PUSH
124513: LD_STRING 
124515: ST_TO_ADDR
// hc_name :=  ;
124516: LD_ADDR_OWVAR 26
124520: PUSH
124521: LD_STRING 
124523: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
124524: LD_INT 1
124526: PPUSH
124527: LD_INT 11
124529: PPUSH
124530: LD_INT 10
124532: PPUSH
124533: CALL_OW 380
// un := CreateHuman ;
124537: LD_ADDR_VAR 0 1
124541: PUSH
124542: CALL_OW 44
124546: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124547: LD_VAR 0 1
124551: PPUSH
124552: LD_INT 1
124554: PPUSH
124555: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
124559: LD_INT 35
124561: PPUSH
124562: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
124566: LD_VAR 0 1
124570: PPUSH
124571: LD_INT 22
124573: PUSH
124574: LD_OWVAR 2
124578: PUSH
124579: EMPTY
124580: LIST
124581: LIST
124582: PPUSH
124583: CALL_OW 69
124587: PPUSH
124588: LD_VAR 0 1
124592: PPUSH
124593: CALL_OW 74
124597: PPUSH
124598: CALL_OW 115
// until IsDead ( un ) ;
124602: LD_VAR 0 1
124606: PPUSH
124607: CALL_OW 301
124611: IFFALSE 124559
// end ;
124613: PPOPN 1
124615: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
124616: LD_EXP 148
124620: IFFALSE 124628
124622: PUSH
124623: LD_EXP 188
124627: AND
124628: IFFALSE 124640
124630: GO 124632
124632: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
124633: LD_STRING earthquake(getX(game), 0, 32)
124635: PPUSH
124636: CALL_OW 559
124640: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
124641: LD_EXP 148
124645: IFFALSE 124653
124647: PUSH
124648: LD_EXP 189
124652: AND
124653: IFFALSE 124744
124655: GO 124657
124657: DISABLE
124658: LD_INT 0
124660: PPUSH
// begin enable ;
124661: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
124662: LD_ADDR_VAR 0 1
124666: PUSH
124667: LD_INT 22
124669: PUSH
124670: LD_OWVAR 2
124674: PUSH
124675: EMPTY
124676: LIST
124677: LIST
124678: PUSH
124679: LD_INT 21
124681: PUSH
124682: LD_INT 2
124684: PUSH
124685: EMPTY
124686: LIST
124687: LIST
124688: PUSH
124689: LD_INT 33
124691: PUSH
124692: LD_INT 3
124694: PUSH
124695: EMPTY
124696: LIST
124697: LIST
124698: PUSH
124699: EMPTY
124700: LIST
124701: LIST
124702: LIST
124703: PPUSH
124704: CALL_OW 69
124708: ST_TO_ADDR
// if not tmp then
124709: LD_VAR 0 1
124713: NOT
124714: IFFALSE 124718
// exit ;
124716: GO 124744
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124718: LD_VAR 0 1
124722: PUSH
124723: LD_INT 1
124725: PPUSH
124726: LD_VAR 0 1
124730: PPUSH
124731: CALL_OW 12
124735: ARRAY
124736: PPUSH
124737: LD_INT 1
124739: PPUSH
124740: CALL_OW 234
// end ;
124744: PPOPN 1
124746: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
124747: LD_EXP 148
124751: IFFALSE 124759
124753: PUSH
124754: LD_EXP 190
124758: AND
124759: IFFALSE 124900
124761: GO 124763
124763: DISABLE
124764: LD_INT 0
124766: PPUSH
124767: PPUSH
124768: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124769: LD_ADDR_VAR 0 3
124773: PUSH
124774: LD_INT 22
124776: PUSH
124777: LD_OWVAR 2
124781: PUSH
124782: EMPTY
124783: LIST
124784: LIST
124785: PUSH
124786: LD_INT 25
124788: PUSH
124789: LD_INT 1
124791: PUSH
124792: EMPTY
124793: LIST
124794: LIST
124795: PUSH
124796: EMPTY
124797: LIST
124798: LIST
124799: PPUSH
124800: CALL_OW 69
124804: ST_TO_ADDR
// if not tmp then
124805: LD_VAR 0 3
124809: NOT
124810: IFFALSE 124814
// exit ;
124812: GO 124900
// un := tmp [ rand ( 1 , tmp ) ] ;
124814: LD_ADDR_VAR 0 2
124818: PUSH
124819: LD_VAR 0 3
124823: PUSH
124824: LD_INT 1
124826: PPUSH
124827: LD_VAR 0 3
124831: PPUSH
124832: CALL_OW 12
124836: ARRAY
124837: ST_TO_ADDR
// if Crawls ( un ) then
124838: LD_VAR 0 2
124842: PPUSH
124843: CALL_OW 318
124847: IFFALSE 124858
// ComWalk ( un ) ;
124849: LD_VAR 0 2
124853: PPUSH
124854: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
124858: LD_VAR 0 2
124862: PPUSH
124863: LD_INT 9
124865: PPUSH
124866: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
124870: LD_INT 28
124872: PPUSH
124873: LD_OWVAR 2
124877: PPUSH
124878: LD_INT 2
124880: PPUSH
124881: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
124885: LD_INT 29
124887: PPUSH
124888: LD_OWVAR 2
124892: PPUSH
124893: LD_INT 2
124895: PPUSH
124896: CALL_OW 322
// end ;
124900: PPOPN 3
124902: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
124903: LD_EXP 148
124907: IFFALSE 124915
124909: PUSH
124910: LD_EXP 191
124914: AND
124915: IFFALSE 125026
124917: GO 124919
124919: DISABLE
124920: LD_INT 0
124922: PPUSH
124923: PPUSH
124924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124925: LD_ADDR_VAR 0 3
124929: PUSH
124930: LD_INT 22
124932: PUSH
124933: LD_OWVAR 2
124937: PUSH
124938: EMPTY
124939: LIST
124940: LIST
124941: PUSH
124942: LD_INT 25
124944: PUSH
124945: LD_INT 1
124947: PUSH
124948: EMPTY
124949: LIST
124950: LIST
124951: PUSH
124952: EMPTY
124953: LIST
124954: LIST
124955: PPUSH
124956: CALL_OW 69
124960: ST_TO_ADDR
// if not tmp then
124961: LD_VAR 0 3
124965: NOT
124966: IFFALSE 124970
// exit ;
124968: GO 125026
// un := tmp [ rand ( 1 , tmp ) ] ;
124970: LD_ADDR_VAR 0 2
124974: PUSH
124975: LD_VAR 0 3
124979: PUSH
124980: LD_INT 1
124982: PPUSH
124983: LD_VAR 0 3
124987: PPUSH
124988: CALL_OW 12
124992: ARRAY
124993: ST_TO_ADDR
// if Crawls ( un ) then
124994: LD_VAR 0 2
124998: PPUSH
124999: CALL_OW 318
125003: IFFALSE 125014
// ComWalk ( un ) ;
125005: LD_VAR 0 2
125009: PPUSH
125010: CALL_OW 138
// SetClass ( un , class_mortar ) ;
125014: LD_VAR 0 2
125018: PPUSH
125019: LD_INT 8
125021: PPUSH
125022: CALL_OW 336
// end ;
125026: PPOPN 3
125028: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
125029: LD_EXP 148
125033: IFFALSE 125041
125035: PUSH
125036: LD_EXP 192
125040: AND
125041: IFFALSE 125185
125043: GO 125045
125045: DISABLE
125046: LD_INT 0
125048: PPUSH
125049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
125050: LD_ADDR_VAR 0 2
125054: PUSH
125055: LD_INT 22
125057: PUSH
125058: LD_OWVAR 2
125062: PUSH
125063: EMPTY
125064: LIST
125065: LIST
125066: PUSH
125067: LD_INT 21
125069: PUSH
125070: LD_INT 2
125072: PUSH
125073: EMPTY
125074: LIST
125075: LIST
125076: PUSH
125077: LD_INT 2
125079: PUSH
125080: LD_INT 34
125082: PUSH
125083: LD_INT 12
125085: PUSH
125086: EMPTY
125087: LIST
125088: LIST
125089: PUSH
125090: LD_INT 34
125092: PUSH
125093: LD_INT 51
125095: PUSH
125096: EMPTY
125097: LIST
125098: LIST
125099: PUSH
125100: LD_INT 34
125102: PUSH
125103: LD_INT 32
125105: PUSH
125106: EMPTY
125107: LIST
125108: LIST
125109: PUSH
125110: EMPTY
125111: LIST
125112: LIST
125113: LIST
125114: LIST
125115: PUSH
125116: EMPTY
125117: LIST
125118: LIST
125119: LIST
125120: PPUSH
125121: CALL_OW 69
125125: ST_TO_ADDR
// if not tmp then
125126: LD_VAR 0 2
125130: NOT
125131: IFFALSE 125135
// exit ;
125133: GO 125185
// for i in tmp do
125135: LD_ADDR_VAR 0 1
125139: PUSH
125140: LD_VAR 0 2
125144: PUSH
125145: FOR_IN
125146: IFFALSE 125183
// if GetCargo ( i , mat_artifact ) = 0 then
125148: LD_VAR 0 1
125152: PPUSH
125153: LD_INT 4
125155: PPUSH
125156: CALL_OW 289
125160: PUSH
125161: LD_INT 0
125163: EQUAL
125164: IFFALSE 125181
// SetCargo ( i , mat_siberit , 100 ) ;
125166: LD_VAR 0 1
125170: PPUSH
125171: LD_INT 3
125173: PPUSH
125174: LD_INT 100
125176: PPUSH
125177: CALL_OW 290
125181: GO 125145
125183: POP
125184: POP
// end ;
125185: PPOPN 2
125187: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
125188: LD_EXP 148
125192: IFFALSE 125200
125194: PUSH
125195: LD_EXP 193
125199: AND
125200: IFFALSE 125383
125202: GO 125204
125204: DISABLE
125205: LD_INT 0
125207: PPUSH
125208: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125209: LD_ADDR_VAR 0 2
125213: PUSH
125214: LD_INT 22
125216: PUSH
125217: LD_OWVAR 2
125221: PUSH
125222: EMPTY
125223: LIST
125224: LIST
125225: PPUSH
125226: CALL_OW 69
125230: ST_TO_ADDR
// if not tmp then
125231: LD_VAR 0 2
125235: NOT
125236: IFFALSE 125240
// exit ;
125238: GO 125383
// for i := 1 to 2 do
125240: LD_ADDR_VAR 0 1
125244: PUSH
125245: DOUBLE
125246: LD_INT 1
125248: DEC
125249: ST_TO_ADDR
125250: LD_INT 2
125252: PUSH
125253: FOR_TO
125254: IFFALSE 125381
// begin uc_side := your_side ;
125256: LD_ADDR_OWVAR 20
125260: PUSH
125261: LD_OWVAR 2
125265: ST_TO_ADDR
// uc_nation := nation_american ;
125266: LD_ADDR_OWVAR 21
125270: PUSH
125271: LD_INT 1
125273: ST_TO_ADDR
// vc_chassis := us_morphling ;
125274: LD_ADDR_OWVAR 37
125278: PUSH
125279: LD_INT 5
125281: ST_TO_ADDR
// vc_engine := engine_siberite ;
125282: LD_ADDR_OWVAR 39
125286: PUSH
125287: LD_INT 3
125289: ST_TO_ADDR
// vc_control := control_computer ;
125290: LD_ADDR_OWVAR 38
125294: PUSH
125295: LD_INT 3
125297: ST_TO_ADDR
// vc_weapon := us_double_laser ;
125298: LD_ADDR_OWVAR 40
125302: PUSH
125303: LD_INT 10
125305: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
125306: LD_VAR 0 2
125310: PUSH
125311: LD_INT 1
125313: ARRAY
125314: PPUSH
125315: CALL_OW 310
125319: NOT
125320: IFFALSE 125367
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
125322: CALL_OW 45
125326: PPUSH
125327: LD_VAR 0 2
125331: PUSH
125332: LD_INT 1
125334: ARRAY
125335: PPUSH
125336: CALL_OW 250
125340: PPUSH
125341: LD_VAR 0 2
125345: PUSH
125346: LD_INT 1
125348: ARRAY
125349: PPUSH
125350: CALL_OW 251
125354: PPUSH
125355: LD_INT 12
125357: PPUSH
125358: LD_INT 1
125360: PPUSH
125361: CALL_OW 50
125365: GO 125379
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
125367: CALL_OW 45
125371: PPUSH
125372: LD_INT 1
125374: PPUSH
125375: CALL_OW 51
// end ;
125379: GO 125253
125381: POP
125382: POP
// end ;
125383: PPOPN 2
125385: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
125386: LD_EXP 148
125390: IFFALSE 125398
125392: PUSH
125393: LD_EXP 194
125397: AND
125398: IFFALSE 125620
125400: GO 125402
125402: DISABLE
125403: LD_INT 0
125405: PPUSH
125406: PPUSH
125407: PPUSH
125408: PPUSH
125409: PPUSH
125410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
125411: LD_ADDR_VAR 0 6
125415: PUSH
125416: LD_INT 22
125418: PUSH
125419: LD_OWVAR 2
125423: PUSH
125424: EMPTY
125425: LIST
125426: LIST
125427: PUSH
125428: LD_INT 21
125430: PUSH
125431: LD_INT 1
125433: PUSH
125434: EMPTY
125435: LIST
125436: LIST
125437: PUSH
125438: LD_INT 3
125440: PUSH
125441: LD_INT 23
125443: PUSH
125444: LD_INT 0
125446: PUSH
125447: EMPTY
125448: LIST
125449: LIST
125450: PUSH
125451: EMPTY
125452: LIST
125453: LIST
125454: PUSH
125455: EMPTY
125456: LIST
125457: LIST
125458: LIST
125459: PPUSH
125460: CALL_OW 69
125464: ST_TO_ADDR
// if not tmp then
125465: LD_VAR 0 6
125469: NOT
125470: IFFALSE 125474
// exit ;
125472: GO 125620
// s1 := rand ( 1 , 4 ) ;
125474: LD_ADDR_VAR 0 2
125478: PUSH
125479: LD_INT 1
125481: PPUSH
125482: LD_INT 4
125484: PPUSH
125485: CALL_OW 12
125489: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
125490: LD_ADDR_VAR 0 4
125494: PUSH
125495: LD_VAR 0 6
125499: PUSH
125500: LD_INT 1
125502: ARRAY
125503: PPUSH
125504: LD_VAR 0 2
125508: PPUSH
125509: CALL_OW 259
125513: ST_TO_ADDR
// if s1 = 1 then
125514: LD_VAR 0 2
125518: PUSH
125519: LD_INT 1
125521: EQUAL
125522: IFFALSE 125542
// s2 := rand ( 2 , 4 ) else
125524: LD_ADDR_VAR 0 3
125528: PUSH
125529: LD_INT 2
125531: PPUSH
125532: LD_INT 4
125534: PPUSH
125535: CALL_OW 12
125539: ST_TO_ADDR
125540: GO 125550
// s2 := 1 ;
125542: LD_ADDR_VAR 0 3
125546: PUSH
125547: LD_INT 1
125549: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
125550: LD_ADDR_VAR 0 5
125554: PUSH
125555: LD_VAR 0 6
125559: PUSH
125560: LD_INT 1
125562: ARRAY
125563: PPUSH
125564: LD_VAR 0 3
125568: PPUSH
125569: CALL_OW 259
125573: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
125574: LD_VAR 0 6
125578: PUSH
125579: LD_INT 1
125581: ARRAY
125582: PPUSH
125583: LD_VAR 0 2
125587: PPUSH
125588: LD_VAR 0 5
125592: PPUSH
125593: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
125597: LD_VAR 0 6
125601: PUSH
125602: LD_INT 1
125604: ARRAY
125605: PPUSH
125606: LD_VAR 0 3
125610: PPUSH
125611: LD_VAR 0 4
125615: PPUSH
125616: CALL_OW 237
// end ;
125620: PPOPN 6
125622: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
125623: LD_EXP 148
125627: IFFALSE 125635
125629: PUSH
125630: LD_EXP 195
125634: AND
125635: IFFALSE 125714
125637: GO 125639
125639: DISABLE
125640: LD_INT 0
125642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
125643: LD_ADDR_VAR 0 1
125647: PUSH
125648: LD_INT 22
125650: PUSH
125651: LD_OWVAR 2
125655: PUSH
125656: EMPTY
125657: LIST
125658: LIST
125659: PUSH
125660: LD_INT 30
125662: PUSH
125663: LD_INT 3
125665: PUSH
125666: EMPTY
125667: LIST
125668: LIST
125669: PUSH
125670: EMPTY
125671: LIST
125672: LIST
125673: PPUSH
125674: CALL_OW 69
125678: ST_TO_ADDR
// if not tmp then
125679: LD_VAR 0 1
125683: NOT
125684: IFFALSE 125688
// exit ;
125686: GO 125714
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
125688: LD_VAR 0 1
125692: PUSH
125693: LD_INT 1
125695: PPUSH
125696: LD_VAR 0 1
125700: PPUSH
125701: CALL_OW 12
125705: ARRAY
125706: PPUSH
125707: LD_INT 1
125709: PPUSH
125710: CALL_OW 234
// end ;
125714: PPOPN 1
125716: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
125717: LD_EXP 148
125721: IFFALSE 125729
125723: PUSH
125724: LD_EXP 196
125728: AND
125729: IFFALSE 125841
125731: GO 125733
125733: DISABLE
125734: LD_INT 0
125736: PPUSH
125737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
125738: LD_ADDR_VAR 0 2
125742: PUSH
125743: LD_INT 22
125745: PUSH
125746: LD_OWVAR 2
125750: PUSH
125751: EMPTY
125752: LIST
125753: LIST
125754: PUSH
125755: LD_INT 2
125757: PUSH
125758: LD_INT 30
125760: PUSH
125761: LD_INT 27
125763: PUSH
125764: EMPTY
125765: LIST
125766: LIST
125767: PUSH
125768: LD_INT 30
125770: PUSH
125771: LD_INT 26
125773: PUSH
125774: EMPTY
125775: LIST
125776: LIST
125777: PUSH
125778: LD_INT 30
125780: PUSH
125781: LD_INT 28
125783: PUSH
125784: EMPTY
125785: LIST
125786: LIST
125787: PUSH
125788: EMPTY
125789: LIST
125790: LIST
125791: LIST
125792: LIST
125793: PUSH
125794: EMPTY
125795: LIST
125796: LIST
125797: PPUSH
125798: CALL_OW 69
125802: ST_TO_ADDR
// if not tmp then
125803: LD_VAR 0 2
125807: NOT
125808: IFFALSE 125812
// exit ;
125810: GO 125841
// for i in tmp do
125812: LD_ADDR_VAR 0 1
125816: PUSH
125817: LD_VAR 0 2
125821: PUSH
125822: FOR_IN
125823: IFFALSE 125839
// SetLives ( i , 1 ) ;
125825: LD_VAR 0 1
125829: PPUSH
125830: LD_INT 1
125832: PPUSH
125833: CALL_OW 234
125837: GO 125822
125839: POP
125840: POP
// end ;
125841: PPOPN 2
125843: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
125844: LD_EXP 148
125848: IFFALSE 125856
125850: PUSH
125851: LD_EXP 197
125855: AND
125856: IFFALSE 126143
125858: GO 125860
125860: DISABLE
125861: LD_INT 0
125863: PPUSH
125864: PPUSH
125865: PPUSH
// begin i := rand ( 1 , 7 ) ;
125866: LD_ADDR_VAR 0 1
125870: PUSH
125871: LD_INT 1
125873: PPUSH
125874: LD_INT 7
125876: PPUSH
125877: CALL_OW 12
125881: ST_TO_ADDR
// case i of 1 :
125882: LD_VAR 0 1
125886: PUSH
125887: LD_INT 1
125889: DOUBLE
125890: EQUAL
125891: IFTRUE 125895
125893: GO 125905
125895: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
125896: LD_STRING earthquake(getX(game), 0, 32)
125898: PPUSH
125899: CALL_OW 559
125903: GO 126143
125905: LD_INT 2
125907: DOUBLE
125908: EQUAL
125909: IFTRUE 125913
125911: GO 125927
125913: POP
// begin ToLua ( displayStucuk(); ) ;
125914: LD_STRING displayStucuk();
125916: PPUSH
125917: CALL_OW 559
// ResetFog ;
125921: CALL_OW 335
// end ; 3 :
125925: GO 126143
125927: LD_INT 3
125929: DOUBLE
125930: EQUAL
125931: IFTRUE 125935
125933: GO 126039
125935: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
125936: LD_ADDR_VAR 0 2
125940: PUSH
125941: LD_INT 22
125943: PUSH
125944: LD_OWVAR 2
125948: PUSH
125949: EMPTY
125950: LIST
125951: LIST
125952: PUSH
125953: LD_INT 25
125955: PUSH
125956: LD_INT 1
125958: PUSH
125959: EMPTY
125960: LIST
125961: LIST
125962: PUSH
125963: EMPTY
125964: LIST
125965: LIST
125966: PPUSH
125967: CALL_OW 69
125971: ST_TO_ADDR
// if not tmp then
125972: LD_VAR 0 2
125976: NOT
125977: IFFALSE 125981
// exit ;
125979: GO 126143
// un := tmp [ rand ( 1 , tmp ) ] ;
125981: LD_ADDR_VAR 0 3
125985: PUSH
125986: LD_VAR 0 2
125990: PUSH
125991: LD_INT 1
125993: PPUSH
125994: LD_VAR 0 2
125998: PPUSH
125999: CALL_OW 12
126003: ARRAY
126004: ST_TO_ADDR
// if Crawls ( un ) then
126005: LD_VAR 0 3
126009: PPUSH
126010: CALL_OW 318
126014: IFFALSE 126025
// ComWalk ( un ) ;
126016: LD_VAR 0 3
126020: PPUSH
126021: CALL_OW 138
// SetClass ( un , class_mortar ) ;
126025: LD_VAR 0 3
126029: PPUSH
126030: LD_INT 8
126032: PPUSH
126033: CALL_OW 336
// end ; 4 :
126037: GO 126143
126039: LD_INT 4
126041: DOUBLE
126042: EQUAL
126043: IFTRUE 126047
126045: GO 126121
126047: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
126048: LD_ADDR_VAR 0 2
126052: PUSH
126053: LD_INT 22
126055: PUSH
126056: LD_OWVAR 2
126060: PUSH
126061: EMPTY
126062: LIST
126063: LIST
126064: PUSH
126065: LD_INT 30
126067: PUSH
126068: LD_INT 29
126070: PUSH
126071: EMPTY
126072: LIST
126073: LIST
126074: PUSH
126075: EMPTY
126076: LIST
126077: LIST
126078: PPUSH
126079: CALL_OW 69
126083: ST_TO_ADDR
// if not tmp then
126084: LD_VAR 0 2
126088: NOT
126089: IFFALSE 126093
// exit ;
126091: GO 126143
// CenterNowOnUnits ( tmp [ 1 ] ) ;
126093: LD_VAR 0 2
126097: PUSH
126098: LD_INT 1
126100: ARRAY
126101: PPUSH
126102: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
126106: LD_VAR 0 2
126110: PUSH
126111: LD_INT 1
126113: ARRAY
126114: PPUSH
126115: CALL_OW 65
// end ; 5 .. 7 :
126119: GO 126143
126121: LD_INT 5
126123: DOUBLE
126124: GREATEREQUAL
126125: IFFALSE 126133
126127: LD_INT 7
126129: DOUBLE
126130: LESSEQUAL
126131: IFTRUE 126135
126133: GO 126142
126135: POP
// StreamSibBomb ; end ;
126136: CALL 122324 0 0
126140: GO 126143
126142: POP
// end ;
126143: PPOPN 3
126145: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
126146: LD_EXP 148
126150: IFFALSE 126158
126152: PUSH
126153: LD_EXP 198
126157: AND
126158: IFFALSE 126314
126160: GO 126162
126162: DISABLE
126163: LD_INT 0
126165: PPUSH
126166: PPUSH
126167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
126168: LD_ADDR_VAR 0 2
126172: PUSH
126173: LD_INT 81
126175: PUSH
126176: LD_OWVAR 2
126180: PUSH
126181: EMPTY
126182: LIST
126183: LIST
126184: PUSH
126185: LD_INT 2
126187: PUSH
126188: LD_INT 21
126190: PUSH
126191: LD_INT 1
126193: PUSH
126194: EMPTY
126195: LIST
126196: LIST
126197: PUSH
126198: LD_INT 21
126200: PUSH
126201: LD_INT 2
126203: PUSH
126204: EMPTY
126205: LIST
126206: LIST
126207: PUSH
126208: EMPTY
126209: LIST
126210: LIST
126211: LIST
126212: PUSH
126213: EMPTY
126214: LIST
126215: LIST
126216: PPUSH
126217: CALL_OW 69
126221: ST_TO_ADDR
// if not tmp then
126222: LD_VAR 0 2
126226: NOT
126227: IFFALSE 126231
// exit ;
126229: GO 126314
// p := 0 ;
126231: LD_ADDR_VAR 0 3
126235: PUSH
126236: LD_INT 0
126238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126239: LD_INT 35
126241: PPUSH
126242: CALL_OW 67
// p := p + 1 ;
126246: LD_ADDR_VAR 0 3
126250: PUSH
126251: LD_VAR 0 3
126255: PUSH
126256: LD_INT 1
126258: PLUS
126259: ST_TO_ADDR
// for i in tmp do
126260: LD_ADDR_VAR 0 1
126264: PUSH
126265: LD_VAR 0 2
126269: PUSH
126270: FOR_IN
126271: IFFALSE 126302
// if GetLives ( i ) < 1000 then
126273: LD_VAR 0 1
126277: PPUSH
126278: CALL_OW 256
126282: PUSH
126283: LD_INT 1000
126285: LESS
126286: IFFALSE 126300
// SetLives ( i , 1000 ) ;
126288: LD_VAR 0 1
126292: PPUSH
126293: LD_INT 1000
126295: PPUSH
126296: CALL_OW 234
126300: GO 126270
126302: POP
126303: POP
// until p > 20 ;
126304: LD_VAR 0 3
126308: PUSH
126309: LD_INT 20
126311: GREATER
126312: IFFALSE 126239
// end ;
126314: PPOPN 3
126316: END
// every 0 0$1 trigger StreamModeActive and sTime do
126317: LD_EXP 148
126321: IFFALSE 126329
126323: PUSH
126324: LD_EXP 199
126328: AND
126329: IFFALSE 126364
126331: GO 126333
126333: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
126334: LD_INT 28
126336: PPUSH
126337: LD_OWVAR 2
126341: PPUSH
126342: LD_INT 2
126344: PPUSH
126345: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
126349: LD_INT 30
126351: PPUSH
126352: LD_OWVAR 2
126356: PPUSH
126357: LD_INT 2
126359: PPUSH
126360: CALL_OW 322
// end ;
126364: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
126365: LD_EXP 148
126369: IFFALSE 126377
126371: PUSH
126372: LD_EXP 200
126376: AND
126377: IFFALSE 126498
126379: GO 126381
126381: DISABLE
126382: LD_INT 0
126384: PPUSH
126385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
126386: LD_ADDR_VAR 0 2
126390: PUSH
126391: LD_INT 22
126393: PUSH
126394: LD_OWVAR 2
126398: PUSH
126399: EMPTY
126400: LIST
126401: LIST
126402: PUSH
126403: LD_INT 21
126405: PUSH
126406: LD_INT 1
126408: PUSH
126409: EMPTY
126410: LIST
126411: LIST
126412: PUSH
126413: LD_INT 3
126415: PUSH
126416: LD_INT 23
126418: PUSH
126419: LD_INT 0
126421: PUSH
126422: EMPTY
126423: LIST
126424: LIST
126425: PUSH
126426: EMPTY
126427: LIST
126428: LIST
126429: PUSH
126430: EMPTY
126431: LIST
126432: LIST
126433: LIST
126434: PPUSH
126435: CALL_OW 69
126439: ST_TO_ADDR
// if not tmp then
126440: LD_VAR 0 2
126444: NOT
126445: IFFALSE 126449
// exit ;
126447: GO 126498
// for i in tmp do
126449: LD_ADDR_VAR 0 1
126453: PUSH
126454: LD_VAR 0 2
126458: PUSH
126459: FOR_IN
126460: IFFALSE 126496
// begin if Crawls ( i ) then
126462: LD_VAR 0 1
126466: PPUSH
126467: CALL_OW 318
126471: IFFALSE 126482
// ComWalk ( i ) ;
126473: LD_VAR 0 1
126477: PPUSH
126478: CALL_OW 138
// SetClass ( i , 2 ) ;
126482: LD_VAR 0 1
126486: PPUSH
126487: LD_INT 2
126489: PPUSH
126490: CALL_OW 336
// end ;
126494: GO 126459
126496: POP
126497: POP
// end ;
126498: PPOPN 2
126500: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
126501: LD_EXP 148
126505: IFFALSE 126513
126507: PUSH
126508: LD_EXP 201
126512: AND
126513: IFFALSE 126803
126515: GO 126517
126517: DISABLE
126518: LD_INT 0
126520: PPUSH
126521: PPUSH
126522: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
126523: LD_OWVAR 2
126527: PPUSH
126528: LD_INT 9
126530: PPUSH
126531: LD_INT 1
126533: PPUSH
126534: LD_INT 1
126536: PPUSH
126537: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
126541: LD_INT 9
126543: PPUSH
126544: LD_OWVAR 2
126548: PPUSH
126549: CALL_OW 343
// uc_side := 9 ;
126553: LD_ADDR_OWVAR 20
126557: PUSH
126558: LD_INT 9
126560: ST_TO_ADDR
// uc_nation := 2 ;
126561: LD_ADDR_OWVAR 21
126565: PUSH
126566: LD_INT 2
126568: ST_TO_ADDR
// hc_name := Dark Warrior ;
126569: LD_ADDR_OWVAR 26
126573: PUSH
126574: LD_STRING Dark Warrior
126576: ST_TO_ADDR
// hc_gallery :=  ;
126577: LD_ADDR_OWVAR 33
126581: PUSH
126582: LD_STRING 
126584: ST_TO_ADDR
// hc_noskilllimit := true ;
126585: LD_ADDR_OWVAR 76
126589: PUSH
126590: LD_INT 1
126592: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
126593: LD_ADDR_OWVAR 31
126597: PUSH
126598: LD_INT 30
126600: PUSH
126601: LD_INT 30
126603: PUSH
126604: LD_INT 30
126606: PUSH
126607: LD_INT 30
126609: PUSH
126610: EMPTY
126611: LIST
126612: LIST
126613: LIST
126614: LIST
126615: ST_TO_ADDR
// un := CreateHuman ;
126616: LD_ADDR_VAR 0 3
126620: PUSH
126621: CALL_OW 44
126625: ST_TO_ADDR
// hc_noskilllimit := false ;
126626: LD_ADDR_OWVAR 76
126630: PUSH
126631: LD_INT 0
126633: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
126634: LD_VAR 0 3
126638: PPUSH
126639: LD_INT 1
126641: PPUSH
126642: CALL_OW 51
// ToLua ( playRanger() ) ;
126646: LD_STRING playRanger()
126648: PPUSH
126649: CALL_OW 559
// p := 0 ;
126653: LD_ADDR_VAR 0 2
126657: PUSH
126658: LD_INT 0
126660: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126661: LD_INT 35
126663: PPUSH
126664: CALL_OW 67
// p := p + 1 ;
126668: LD_ADDR_VAR 0 2
126672: PUSH
126673: LD_VAR 0 2
126677: PUSH
126678: LD_INT 1
126680: PLUS
126681: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
126682: LD_VAR 0 3
126686: PPUSH
126687: CALL_OW 256
126691: PUSH
126692: LD_INT 1000
126694: LESS
126695: IFFALSE 126709
// SetLives ( un , 1000 ) ;
126697: LD_VAR 0 3
126701: PPUSH
126702: LD_INT 1000
126704: PPUSH
126705: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
126709: LD_VAR 0 3
126713: PPUSH
126714: LD_INT 81
126716: PUSH
126717: LD_OWVAR 2
126721: PUSH
126722: EMPTY
126723: LIST
126724: LIST
126725: PUSH
126726: LD_INT 91
126728: PUSH
126729: LD_VAR 0 3
126733: PUSH
126734: LD_INT 30
126736: PUSH
126737: EMPTY
126738: LIST
126739: LIST
126740: LIST
126741: PUSH
126742: EMPTY
126743: LIST
126744: LIST
126745: PPUSH
126746: CALL_OW 69
126750: PPUSH
126751: LD_VAR 0 3
126755: PPUSH
126756: CALL_OW 74
126760: PPUSH
126761: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
126765: LD_VAR 0 2
126769: PUSH
126770: LD_INT 80
126772: GREATER
126773: IFTRUE 126786
126775: PUSH
126776: LD_VAR 0 3
126780: PPUSH
126781: CALL_OW 301
126785: OR
126786: IFFALSE 126661
// if un then
126788: LD_VAR 0 3
126792: IFFALSE 126803
// RemoveUnit ( un ) ;
126794: LD_VAR 0 3
126798: PPUSH
126799: CALL_OW 64
// end ;
126803: PPOPN 3
126805: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
126806: LD_EXP 202
126810: IFFALSE 126926
126812: GO 126814
126814: DISABLE
126815: LD_INT 0
126817: PPUSH
126818: PPUSH
126819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
126820: LD_ADDR_VAR 0 2
126824: PUSH
126825: LD_INT 81
126827: PUSH
126828: LD_OWVAR 2
126832: PUSH
126833: EMPTY
126834: LIST
126835: LIST
126836: PUSH
126837: LD_INT 21
126839: PUSH
126840: LD_INT 1
126842: PUSH
126843: EMPTY
126844: LIST
126845: LIST
126846: PUSH
126847: EMPTY
126848: LIST
126849: LIST
126850: PPUSH
126851: CALL_OW 69
126855: ST_TO_ADDR
// ToLua ( playComputer() ) ;
126856: LD_STRING playComputer()
126858: PPUSH
126859: CALL_OW 559
// if not tmp then
126863: LD_VAR 0 2
126867: NOT
126868: IFFALSE 126872
// exit ;
126870: GO 126926
// for i in tmp do
126872: LD_ADDR_VAR 0 1
126876: PUSH
126877: LD_VAR 0 2
126881: PUSH
126882: FOR_IN
126883: IFFALSE 126924
// for j := 1 to 4 do
126885: LD_ADDR_VAR 0 3
126889: PUSH
126890: DOUBLE
126891: LD_INT 1
126893: DEC
126894: ST_TO_ADDR
126895: LD_INT 4
126897: PUSH
126898: FOR_TO
126899: IFFALSE 126920
// SetSkill ( i , j , 10 ) ;
126901: LD_VAR 0 1
126905: PPUSH
126906: LD_VAR 0 3
126910: PPUSH
126911: LD_INT 10
126913: PPUSH
126914: CALL_OW 237
126918: GO 126898
126920: POP
126921: POP
126922: GO 126882
126924: POP
126925: POP
// end ;
126926: PPOPN 3
126928: END
// every 0 0$1 trigger s30 do var i , tmp ;
126929: LD_EXP 203
126933: IFFALSE 127002
126935: GO 126937
126937: DISABLE
126938: LD_INT 0
126940: PPUSH
126941: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
126942: LD_ADDR_VAR 0 2
126946: PUSH
126947: LD_INT 22
126949: PUSH
126950: LD_OWVAR 2
126954: PUSH
126955: EMPTY
126956: LIST
126957: LIST
126958: PPUSH
126959: CALL_OW 69
126963: ST_TO_ADDR
// if not tmp then
126964: LD_VAR 0 2
126968: NOT
126969: IFFALSE 126973
// exit ;
126971: GO 127002
// for i in tmp do
126973: LD_ADDR_VAR 0 1
126977: PUSH
126978: LD_VAR 0 2
126982: PUSH
126983: FOR_IN
126984: IFFALSE 127000
// SetLives ( i , 300 ) ;
126986: LD_VAR 0 1
126990: PPUSH
126991: LD_INT 300
126993: PPUSH
126994: CALL_OW 234
126998: GO 126983
127000: POP
127001: POP
// end ;
127002: PPOPN 2
127004: END
// every 0 0$1 trigger s60 do var i , tmp ;
127005: LD_EXP 204
127009: IFFALSE 127078
127011: GO 127013
127013: DISABLE
127014: LD_INT 0
127016: PPUSH
127017: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
127018: LD_ADDR_VAR 0 2
127022: PUSH
127023: LD_INT 22
127025: PUSH
127026: LD_OWVAR 2
127030: PUSH
127031: EMPTY
127032: LIST
127033: LIST
127034: PPUSH
127035: CALL_OW 69
127039: ST_TO_ADDR
// if not tmp then
127040: LD_VAR 0 2
127044: NOT
127045: IFFALSE 127049
// exit ;
127047: GO 127078
// for i in tmp do
127049: LD_ADDR_VAR 0 1
127053: PUSH
127054: LD_VAR 0 2
127058: PUSH
127059: FOR_IN
127060: IFFALSE 127076
// SetLives ( i , 600 ) ;
127062: LD_VAR 0 1
127066: PPUSH
127067: LD_INT 600
127069: PPUSH
127070: CALL_OW 234
127074: GO 127059
127076: POP
127077: POP
// end ;
127078: PPOPN 2
127080: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
127081: LD_INT 0
127083: PPUSH
// case cmd of 301 :
127084: LD_VAR 0 1
127088: PUSH
127089: LD_INT 301
127091: DOUBLE
127092: EQUAL
127093: IFTRUE 127097
127095: GO 127129
127097: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
127098: LD_VAR 0 6
127102: PPUSH
127103: LD_VAR 0 7
127107: PPUSH
127108: LD_VAR 0 8
127112: PPUSH
127113: LD_VAR 0 4
127117: PPUSH
127118: LD_VAR 0 5
127122: PPUSH
127123: CALL 128342 0 5
127127: GO 127250
127129: LD_INT 302
127131: DOUBLE
127132: EQUAL
127133: IFTRUE 127137
127135: GO 127174
127137: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
127138: LD_VAR 0 6
127142: PPUSH
127143: LD_VAR 0 7
127147: PPUSH
127148: LD_VAR 0 8
127152: PPUSH
127153: LD_VAR 0 9
127157: PPUSH
127158: LD_VAR 0 4
127162: PPUSH
127163: LD_VAR 0 5
127167: PPUSH
127168: CALL 128433 0 6
127172: GO 127250
127174: LD_INT 303
127176: DOUBLE
127177: EQUAL
127178: IFTRUE 127182
127180: GO 127219
127182: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
127183: LD_VAR 0 6
127187: PPUSH
127188: LD_VAR 0 7
127192: PPUSH
127193: LD_VAR 0 8
127197: PPUSH
127198: LD_VAR 0 9
127202: PPUSH
127203: LD_VAR 0 4
127207: PPUSH
127208: LD_VAR 0 5
127212: PPUSH
127213: CALL 127255 0 6
127217: GO 127250
127219: LD_INT 304
127221: DOUBLE
127222: EQUAL
127223: IFTRUE 127227
127225: GO 127249
127227: POP
// hHackTeleport ( unit , x , y ) ; end ;
127228: LD_VAR 0 2
127232: PPUSH
127233: LD_VAR 0 4
127237: PPUSH
127238: LD_VAR 0 5
127242: PPUSH
127243: CALL 129026 0 3
127247: GO 127250
127249: POP
// end ;
127250: LD_VAR 0 12
127254: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
127255: LD_INT 0
127257: PPUSH
127258: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
127259: LD_VAR 0 1
127263: PUSH
127264: LD_INT 1
127266: LESS
127267: IFTRUE 127279
127269: PUSH
127270: LD_VAR 0 1
127274: PUSH
127275: LD_INT 3
127277: GREATER
127278: OR
127279: IFTRUE 127297
127281: PUSH
127282: LD_VAR 0 5
127286: PPUSH
127287: LD_VAR 0 6
127291: PPUSH
127292: CALL_OW 428
127296: OR
127297: IFFALSE 127301
// exit ;
127299: GO 128029
// uc_side := your_side ;
127301: LD_ADDR_OWVAR 20
127305: PUSH
127306: LD_OWVAR 2
127310: ST_TO_ADDR
// uc_nation := nation ;
127311: LD_ADDR_OWVAR 21
127315: PUSH
127316: LD_VAR 0 1
127320: ST_TO_ADDR
// bc_level = 1 ;
127321: LD_ADDR_OWVAR 43
127325: PUSH
127326: LD_INT 1
127328: ST_TO_ADDR
// case btype of 1 :
127329: LD_VAR 0 2
127333: PUSH
127334: LD_INT 1
127336: DOUBLE
127337: EQUAL
127338: IFTRUE 127342
127340: GO 127353
127342: POP
// bc_type := b_depot ; 2 :
127343: LD_ADDR_OWVAR 42
127347: PUSH
127348: LD_INT 0
127350: ST_TO_ADDR
127351: GO 127973
127353: LD_INT 2
127355: DOUBLE
127356: EQUAL
127357: IFTRUE 127361
127359: GO 127372
127361: POP
// bc_type := b_warehouse ; 3 :
127362: LD_ADDR_OWVAR 42
127366: PUSH
127367: LD_INT 1
127369: ST_TO_ADDR
127370: GO 127973
127372: LD_INT 3
127374: DOUBLE
127375: EQUAL
127376: IFTRUE 127380
127378: GO 127391
127380: POP
// bc_type := b_lab ; 4 .. 9 :
127381: LD_ADDR_OWVAR 42
127385: PUSH
127386: LD_INT 6
127388: ST_TO_ADDR
127389: GO 127973
127391: LD_INT 4
127393: DOUBLE
127394: GREATEREQUAL
127395: IFFALSE 127403
127397: LD_INT 9
127399: DOUBLE
127400: LESSEQUAL
127401: IFTRUE 127405
127403: GO 127465
127405: POP
// begin bc_type := b_lab_half ;
127406: LD_ADDR_OWVAR 42
127410: PUSH
127411: LD_INT 7
127413: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
127414: LD_ADDR_OWVAR 44
127418: PUSH
127419: LD_INT 10
127421: PUSH
127422: LD_INT 11
127424: PUSH
127425: LD_INT 12
127427: PUSH
127428: LD_INT 15
127430: PUSH
127431: LD_INT 14
127433: PUSH
127434: LD_INT 13
127436: PUSH
127437: EMPTY
127438: LIST
127439: LIST
127440: LIST
127441: LIST
127442: LIST
127443: LIST
127444: PUSH
127445: LD_VAR 0 2
127449: PUSH
127450: LD_INT 3
127452: MINUS
127453: ARRAY
127454: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
127455: LD_ADDR_OWVAR 45
127459: PUSH
127460: LD_INT 9
127462: ST_TO_ADDR
// end ; 10 .. 13 :
127463: GO 127973
127465: LD_INT 10
127467: DOUBLE
127468: GREATEREQUAL
127469: IFFALSE 127477
127471: LD_INT 13
127473: DOUBLE
127474: LESSEQUAL
127475: IFTRUE 127479
127477: GO 127556
127479: POP
// begin bc_type := b_lab_full ;
127480: LD_ADDR_OWVAR 42
127484: PUSH
127485: LD_INT 8
127487: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
127488: LD_ADDR_OWVAR 44
127492: PUSH
127493: LD_INT 10
127495: PUSH
127496: LD_INT 12
127498: PUSH
127499: LD_INT 14
127501: PUSH
127502: LD_INT 13
127504: PUSH
127505: EMPTY
127506: LIST
127507: LIST
127508: LIST
127509: LIST
127510: PUSH
127511: LD_VAR 0 2
127515: PUSH
127516: LD_INT 9
127518: MINUS
127519: ARRAY
127520: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
127521: LD_ADDR_OWVAR 45
127525: PUSH
127526: LD_INT 11
127528: PUSH
127529: LD_INT 15
127531: PUSH
127532: LD_INT 12
127534: PUSH
127535: LD_INT 15
127537: PUSH
127538: EMPTY
127539: LIST
127540: LIST
127541: LIST
127542: LIST
127543: PUSH
127544: LD_VAR 0 2
127548: PUSH
127549: LD_INT 9
127551: MINUS
127552: ARRAY
127553: ST_TO_ADDR
// end ; 14 :
127554: GO 127973
127556: LD_INT 14
127558: DOUBLE
127559: EQUAL
127560: IFTRUE 127564
127562: GO 127575
127564: POP
// bc_type := b_workshop ; 15 :
127565: LD_ADDR_OWVAR 42
127569: PUSH
127570: LD_INT 2
127572: ST_TO_ADDR
127573: GO 127973
127575: LD_INT 15
127577: DOUBLE
127578: EQUAL
127579: IFTRUE 127583
127581: GO 127594
127583: POP
// bc_type := b_factory ; 16 :
127584: LD_ADDR_OWVAR 42
127588: PUSH
127589: LD_INT 3
127591: ST_TO_ADDR
127592: GO 127973
127594: LD_INT 16
127596: DOUBLE
127597: EQUAL
127598: IFTRUE 127602
127600: GO 127613
127602: POP
// bc_type := b_ext_gun ; 17 :
127603: LD_ADDR_OWVAR 42
127607: PUSH
127608: LD_INT 17
127610: ST_TO_ADDR
127611: GO 127973
127613: LD_INT 17
127615: DOUBLE
127616: EQUAL
127617: IFTRUE 127621
127619: GO 127649
127621: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
127622: LD_ADDR_OWVAR 42
127626: PUSH
127627: LD_INT 19
127629: PUSH
127630: LD_INT 23
127632: PUSH
127633: LD_INT 19
127635: PUSH
127636: EMPTY
127637: LIST
127638: LIST
127639: LIST
127640: PUSH
127641: LD_VAR 0 1
127645: ARRAY
127646: ST_TO_ADDR
127647: GO 127973
127649: LD_INT 18
127651: DOUBLE
127652: EQUAL
127653: IFTRUE 127657
127655: GO 127668
127657: POP
// bc_type := b_ext_radar ; 19 :
127658: LD_ADDR_OWVAR 42
127662: PUSH
127663: LD_INT 20
127665: ST_TO_ADDR
127666: GO 127973
127668: LD_INT 19
127670: DOUBLE
127671: EQUAL
127672: IFTRUE 127676
127674: GO 127687
127676: POP
// bc_type := b_ext_radio ; 20 :
127677: LD_ADDR_OWVAR 42
127681: PUSH
127682: LD_INT 22
127684: ST_TO_ADDR
127685: GO 127973
127687: LD_INT 20
127689: DOUBLE
127690: EQUAL
127691: IFTRUE 127695
127693: GO 127706
127695: POP
// bc_type := b_ext_siberium ; 21 :
127696: LD_ADDR_OWVAR 42
127700: PUSH
127701: LD_INT 21
127703: ST_TO_ADDR
127704: GO 127973
127706: LD_INT 21
127708: DOUBLE
127709: EQUAL
127710: IFTRUE 127714
127712: GO 127725
127714: POP
// bc_type := b_ext_computer ; 22 :
127715: LD_ADDR_OWVAR 42
127719: PUSH
127720: LD_INT 24
127722: ST_TO_ADDR
127723: GO 127973
127725: LD_INT 22
127727: DOUBLE
127728: EQUAL
127729: IFTRUE 127733
127731: GO 127744
127733: POP
// bc_type := b_ext_track ; 23 :
127734: LD_ADDR_OWVAR 42
127738: PUSH
127739: LD_INT 16
127741: ST_TO_ADDR
127742: GO 127973
127744: LD_INT 23
127746: DOUBLE
127747: EQUAL
127748: IFTRUE 127752
127750: GO 127763
127752: POP
// bc_type := b_ext_laser ; 24 :
127753: LD_ADDR_OWVAR 42
127757: PUSH
127758: LD_INT 25
127760: ST_TO_ADDR
127761: GO 127973
127763: LD_INT 24
127765: DOUBLE
127766: EQUAL
127767: IFTRUE 127771
127769: GO 127782
127771: POP
// bc_type := b_control_tower ; 25 :
127772: LD_ADDR_OWVAR 42
127776: PUSH
127777: LD_INT 36
127779: ST_TO_ADDR
127780: GO 127973
127782: LD_INT 25
127784: DOUBLE
127785: EQUAL
127786: IFTRUE 127790
127788: GO 127801
127790: POP
// bc_type := b_breastwork ; 26 :
127791: LD_ADDR_OWVAR 42
127795: PUSH
127796: LD_INT 31
127798: ST_TO_ADDR
127799: GO 127973
127801: LD_INT 26
127803: DOUBLE
127804: EQUAL
127805: IFTRUE 127809
127807: GO 127820
127809: POP
// bc_type := b_bunker ; 27 :
127810: LD_ADDR_OWVAR 42
127814: PUSH
127815: LD_INT 32
127817: ST_TO_ADDR
127818: GO 127973
127820: LD_INT 27
127822: DOUBLE
127823: EQUAL
127824: IFTRUE 127828
127826: GO 127839
127828: POP
// bc_type := b_turret ; 28 :
127829: LD_ADDR_OWVAR 42
127833: PUSH
127834: LD_INT 33
127836: ST_TO_ADDR
127837: GO 127973
127839: LD_INT 28
127841: DOUBLE
127842: EQUAL
127843: IFTRUE 127847
127845: GO 127858
127847: POP
// bc_type := b_armoury ; 29 :
127848: LD_ADDR_OWVAR 42
127852: PUSH
127853: LD_INT 4
127855: ST_TO_ADDR
127856: GO 127973
127858: LD_INT 29
127860: DOUBLE
127861: EQUAL
127862: IFTRUE 127866
127864: GO 127877
127866: POP
// bc_type := b_barracks ; 30 :
127867: LD_ADDR_OWVAR 42
127871: PUSH
127872: LD_INT 5
127874: ST_TO_ADDR
127875: GO 127973
127877: LD_INT 30
127879: DOUBLE
127880: EQUAL
127881: IFTRUE 127885
127883: GO 127896
127885: POP
// bc_type := b_solar_power ; 31 :
127886: LD_ADDR_OWVAR 42
127890: PUSH
127891: LD_INT 27
127893: ST_TO_ADDR
127894: GO 127973
127896: LD_INT 31
127898: DOUBLE
127899: EQUAL
127900: IFTRUE 127904
127902: GO 127915
127904: POP
// bc_type := b_oil_power ; 32 :
127905: LD_ADDR_OWVAR 42
127909: PUSH
127910: LD_INT 26
127912: ST_TO_ADDR
127913: GO 127973
127915: LD_INT 32
127917: DOUBLE
127918: EQUAL
127919: IFTRUE 127923
127921: GO 127934
127923: POP
// bc_type := b_siberite_power ; 33 :
127924: LD_ADDR_OWVAR 42
127928: PUSH
127929: LD_INT 28
127931: ST_TO_ADDR
127932: GO 127973
127934: LD_INT 33
127936: DOUBLE
127937: EQUAL
127938: IFTRUE 127942
127940: GO 127953
127942: POP
// bc_type := b_oil_mine ; 34 :
127943: LD_ADDR_OWVAR 42
127947: PUSH
127948: LD_INT 29
127950: ST_TO_ADDR
127951: GO 127973
127953: LD_INT 34
127955: DOUBLE
127956: EQUAL
127957: IFTRUE 127961
127959: GO 127972
127961: POP
// bc_type := b_siberite_mine ; end ;
127962: LD_ADDR_OWVAR 42
127966: PUSH
127967: LD_INT 30
127969: ST_TO_ADDR
127970: GO 127973
127972: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
127973: LD_ADDR_VAR 0 8
127977: PUSH
127978: LD_VAR 0 5
127982: PPUSH
127983: LD_VAR 0 6
127987: PPUSH
127988: LD_VAR 0 3
127992: PPUSH
127993: CALL_OW 47
127997: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
127998: LD_OWVAR 42
128002: PUSH
128003: LD_INT 32
128005: PUSH
128006: LD_INT 33
128008: PUSH
128009: EMPTY
128010: LIST
128011: LIST
128012: IN
128013: IFFALSE 128029
// PlaceWeaponTurret ( b , weapon ) ;
128015: LD_VAR 0 8
128019: PPUSH
128020: LD_VAR 0 4
128024: PPUSH
128025: CALL_OW 431
// end ;
128029: LD_VAR 0 7
128033: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
128034: LD_INT 0
128036: PPUSH
128037: PPUSH
128038: PPUSH
128039: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
128040: LD_ADDR_VAR 0 4
128044: PUSH
128045: LD_INT 22
128047: PUSH
128048: LD_OWVAR 2
128052: PUSH
128053: EMPTY
128054: LIST
128055: LIST
128056: PUSH
128057: LD_INT 2
128059: PUSH
128060: LD_INT 30
128062: PUSH
128063: LD_INT 0
128065: PUSH
128066: EMPTY
128067: LIST
128068: LIST
128069: PUSH
128070: LD_INT 30
128072: PUSH
128073: LD_INT 1
128075: PUSH
128076: EMPTY
128077: LIST
128078: LIST
128079: PUSH
128080: EMPTY
128081: LIST
128082: LIST
128083: LIST
128084: PUSH
128085: EMPTY
128086: LIST
128087: LIST
128088: PPUSH
128089: CALL_OW 69
128093: ST_TO_ADDR
// if not tmp then
128094: LD_VAR 0 4
128098: NOT
128099: IFFALSE 128103
// exit ;
128101: GO 128162
// for i in tmp do
128103: LD_ADDR_VAR 0 2
128107: PUSH
128108: LD_VAR 0 4
128112: PUSH
128113: FOR_IN
128114: IFFALSE 128160
// for j = 1 to 3 do
128116: LD_ADDR_VAR 0 3
128120: PUSH
128121: DOUBLE
128122: LD_INT 1
128124: DEC
128125: ST_TO_ADDR
128126: LD_INT 3
128128: PUSH
128129: FOR_TO
128130: IFFALSE 128156
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
128132: LD_VAR 0 2
128136: PPUSH
128137: CALL_OW 274
128141: PPUSH
128142: LD_VAR 0 3
128146: PPUSH
128147: LD_INT 99999
128149: PPUSH
128150: CALL_OW 277
128154: GO 128129
128156: POP
128157: POP
128158: GO 128113
128160: POP
128161: POP
// end ;
128162: LD_VAR 0 1
128166: RET
// export function hHackSetLevel10 ; var i , j ; begin
128167: LD_INT 0
128169: PPUSH
128170: PPUSH
128171: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128172: LD_ADDR_VAR 0 2
128176: PUSH
128177: LD_INT 21
128179: PUSH
128180: LD_INT 1
128182: PUSH
128183: EMPTY
128184: LIST
128185: LIST
128186: PPUSH
128187: CALL_OW 69
128191: PUSH
128192: FOR_IN
128193: IFFALSE 128245
// if IsSelected ( i ) then
128195: LD_VAR 0 2
128199: PPUSH
128200: CALL_OW 306
128204: IFFALSE 128243
// begin for j := 1 to 4 do
128206: LD_ADDR_VAR 0 3
128210: PUSH
128211: DOUBLE
128212: LD_INT 1
128214: DEC
128215: ST_TO_ADDR
128216: LD_INT 4
128218: PUSH
128219: FOR_TO
128220: IFFALSE 128241
// SetSkill ( i , j , 10 ) ;
128222: LD_VAR 0 2
128226: PPUSH
128227: LD_VAR 0 3
128231: PPUSH
128232: LD_INT 10
128234: PPUSH
128235: CALL_OW 237
128239: GO 128219
128241: POP
128242: POP
// end ;
128243: GO 128192
128245: POP
128246: POP
// end ;
128247: LD_VAR 0 1
128251: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
128252: LD_INT 0
128254: PPUSH
128255: PPUSH
128256: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
128257: LD_ADDR_VAR 0 2
128261: PUSH
128262: LD_INT 22
128264: PUSH
128265: LD_OWVAR 2
128269: PUSH
128270: EMPTY
128271: LIST
128272: LIST
128273: PUSH
128274: LD_INT 21
128276: PUSH
128277: LD_INT 1
128279: PUSH
128280: EMPTY
128281: LIST
128282: LIST
128283: PUSH
128284: EMPTY
128285: LIST
128286: LIST
128287: PPUSH
128288: CALL_OW 69
128292: PUSH
128293: FOR_IN
128294: IFFALSE 128335
// begin for j := 1 to 4 do
128296: LD_ADDR_VAR 0 3
128300: PUSH
128301: DOUBLE
128302: LD_INT 1
128304: DEC
128305: ST_TO_ADDR
128306: LD_INT 4
128308: PUSH
128309: FOR_TO
128310: IFFALSE 128331
// SetSkill ( i , j , 10 ) ;
128312: LD_VAR 0 2
128316: PPUSH
128317: LD_VAR 0 3
128321: PPUSH
128322: LD_INT 10
128324: PPUSH
128325: CALL_OW 237
128329: GO 128309
128331: POP
128332: POP
// end ;
128333: GO 128293
128335: POP
128336: POP
// end ;
128337: LD_VAR 0 1
128341: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
128342: LD_INT 0
128344: PPUSH
// uc_side := your_side ;
128345: LD_ADDR_OWVAR 20
128349: PUSH
128350: LD_OWVAR 2
128354: ST_TO_ADDR
// uc_nation := nation ;
128355: LD_ADDR_OWVAR 21
128359: PUSH
128360: LD_VAR 0 1
128364: ST_TO_ADDR
// InitHc ;
128365: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
128369: LD_INT 0
128371: PPUSH
128372: LD_VAR 0 2
128376: PPUSH
128377: LD_VAR 0 3
128381: PPUSH
128382: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
128386: LD_VAR 0 4
128390: PPUSH
128391: LD_VAR 0 5
128395: PPUSH
128396: CALL_OW 428
128400: PUSH
128401: LD_INT 0
128403: EQUAL
128404: IFFALSE 128428
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
128406: CALL_OW 44
128410: PPUSH
128411: LD_VAR 0 4
128415: PPUSH
128416: LD_VAR 0 5
128420: PPUSH
128421: LD_INT 1
128423: PPUSH
128424: CALL_OW 48
// end ;
128428: LD_VAR 0 6
128432: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
128433: LD_INT 0
128435: PPUSH
128436: PPUSH
// uc_side := your_side ;
128437: LD_ADDR_OWVAR 20
128441: PUSH
128442: LD_OWVAR 2
128446: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
128447: LD_VAR 0 1
128451: PUSH
128452: LD_INT 1
128454: PUSH
128455: LD_INT 2
128457: PUSH
128458: LD_INT 3
128460: PUSH
128461: LD_INT 4
128463: PUSH
128464: LD_INT 5
128466: PUSH
128467: EMPTY
128468: LIST
128469: LIST
128470: LIST
128471: LIST
128472: LIST
128473: IN
128474: IFFALSE 128486
// uc_nation := nation_american else
128476: LD_ADDR_OWVAR 21
128480: PUSH
128481: LD_INT 1
128483: ST_TO_ADDR
128484: GO 128529
// if chassis in [ 11 , 12 , 13 , 14 ] then
128486: LD_VAR 0 1
128490: PUSH
128491: LD_INT 11
128493: PUSH
128494: LD_INT 12
128496: PUSH
128497: LD_INT 13
128499: PUSH
128500: LD_INT 14
128502: PUSH
128503: EMPTY
128504: LIST
128505: LIST
128506: LIST
128507: LIST
128508: IN
128509: IFFALSE 128521
// uc_nation := nation_arabian else
128511: LD_ADDR_OWVAR 21
128515: PUSH
128516: LD_INT 2
128518: ST_TO_ADDR
128519: GO 128529
// uc_nation := nation_russian ;
128521: LD_ADDR_OWVAR 21
128525: PUSH
128526: LD_INT 3
128528: ST_TO_ADDR
// vc_chassis := chassis ;
128529: LD_ADDR_OWVAR 37
128533: PUSH
128534: LD_VAR 0 1
128538: ST_TO_ADDR
// vc_engine := engine ;
128539: LD_ADDR_OWVAR 39
128543: PUSH
128544: LD_VAR 0 2
128548: ST_TO_ADDR
// vc_control := control ;
128549: LD_ADDR_OWVAR 38
128553: PUSH
128554: LD_VAR 0 3
128558: ST_TO_ADDR
// vc_weapon := weapon ;
128559: LD_ADDR_OWVAR 40
128563: PUSH
128564: LD_VAR 0 4
128568: ST_TO_ADDR
// un := CreateVehicle ;
128569: LD_ADDR_VAR 0 8
128573: PUSH
128574: CALL_OW 45
128578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
128579: LD_VAR 0 8
128583: PPUSH
128584: LD_INT 0
128586: PPUSH
128587: LD_INT 5
128589: PPUSH
128590: CALL_OW 12
128594: PPUSH
128595: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
128599: LD_VAR 0 8
128603: PPUSH
128604: LD_VAR 0 5
128608: PPUSH
128609: LD_VAR 0 6
128613: PPUSH
128614: LD_INT 1
128616: PPUSH
128617: CALL_OW 48
// end ;
128621: LD_VAR 0 7
128625: RET
// export hInvincible ; every 1 do
128626: GO 128628
128628: DISABLE
// hInvincible := [ ] ;
128629: LD_ADDR_EXP 205
128633: PUSH
128634: EMPTY
128635: ST_TO_ADDR
128636: END
// every 10 do var i ;
128637: GO 128639
128639: DISABLE
128640: LD_INT 0
128642: PPUSH
// begin enable ;
128643: ENABLE
// if not hInvincible then
128644: LD_EXP 205
128648: NOT
128649: IFFALSE 128653
// exit ;
128651: GO 128697
// for i in hInvincible do
128653: LD_ADDR_VAR 0 1
128657: PUSH
128658: LD_EXP 205
128662: PUSH
128663: FOR_IN
128664: IFFALSE 128695
// if GetLives ( i ) < 1000 then
128666: LD_VAR 0 1
128670: PPUSH
128671: CALL_OW 256
128675: PUSH
128676: LD_INT 1000
128678: LESS
128679: IFFALSE 128693
// SetLives ( i , 1000 ) ;
128681: LD_VAR 0 1
128685: PPUSH
128686: LD_INT 1000
128688: PPUSH
128689: CALL_OW 234
128693: GO 128663
128695: POP
128696: POP
// end ;
128697: PPOPN 1
128699: END
// export function hHackInvincible ; var i ; begin
128700: LD_INT 0
128702: PPUSH
128703: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
128704: LD_ADDR_VAR 0 2
128708: PUSH
128709: LD_INT 2
128711: PUSH
128712: LD_INT 21
128714: PUSH
128715: LD_INT 1
128717: PUSH
128718: EMPTY
128719: LIST
128720: LIST
128721: PUSH
128722: LD_INT 21
128724: PUSH
128725: LD_INT 2
128727: PUSH
128728: EMPTY
128729: LIST
128730: LIST
128731: PUSH
128732: EMPTY
128733: LIST
128734: LIST
128735: LIST
128736: PPUSH
128737: CALL_OW 69
128741: PUSH
128742: FOR_IN
128743: IFFALSE 128804
// if IsSelected ( i ) then
128745: LD_VAR 0 2
128749: PPUSH
128750: CALL_OW 306
128754: IFFALSE 128802
// begin if i in hInvincible then
128756: LD_VAR 0 2
128760: PUSH
128761: LD_EXP 205
128765: IN
128766: IFFALSE 128786
// hInvincible := hInvincible diff i else
128768: LD_ADDR_EXP 205
128772: PUSH
128773: LD_EXP 205
128777: PUSH
128778: LD_VAR 0 2
128782: DIFF
128783: ST_TO_ADDR
128784: GO 128802
// hInvincible := hInvincible union i ;
128786: LD_ADDR_EXP 205
128790: PUSH
128791: LD_EXP 205
128795: PUSH
128796: LD_VAR 0 2
128800: UNION
128801: ST_TO_ADDR
// end ;
128802: GO 128742
128804: POP
128805: POP
// end ;
128806: LD_VAR 0 1
128810: RET
// export function hHackInvisible ; var i , j ; begin
128811: LD_INT 0
128813: PPUSH
128814: PPUSH
128815: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128816: LD_ADDR_VAR 0 2
128820: PUSH
128821: LD_INT 21
128823: PUSH
128824: LD_INT 1
128826: PUSH
128827: EMPTY
128828: LIST
128829: LIST
128830: PPUSH
128831: CALL_OW 69
128835: PUSH
128836: FOR_IN
128837: IFFALSE 128861
// if IsSelected ( i ) then
128839: LD_VAR 0 2
128843: PPUSH
128844: CALL_OW 306
128848: IFFALSE 128859
// ComForceInvisible ( i ) ;
128850: LD_VAR 0 2
128854: PPUSH
128855: CALL_OW 496
128859: GO 128836
128861: POP
128862: POP
// end ;
128863: LD_VAR 0 1
128867: RET
// export function hHackChangeYourSide ; begin
128868: LD_INT 0
128870: PPUSH
// if your_side = 8 then
128871: LD_OWVAR 2
128875: PUSH
128876: LD_INT 8
128878: EQUAL
128879: IFFALSE 128891
// your_side := 0 else
128881: LD_ADDR_OWVAR 2
128885: PUSH
128886: LD_INT 0
128888: ST_TO_ADDR
128889: GO 128905
// your_side := your_side + 1 ;
128891: LD_ADDR_OWVAR 2
128895: PUSH
128896: LD_OWVAR 2
128900: PUSH
128901: LD_INT 1
128903: PLUS
128904: ST_TO_ADDR
// end ;
128905: LD_VAR 0 1
128909: RET
// export function hHackChangeUnitSide ; var i , j ; begin
128910: LD_INT 0
128912: PPUSH
128913: PPUSH
128914: PPUSH
// for i in all_units do
128915: LD_ADDR_VAR 0 2
128919: PUSH
128920: LD_OWVAR 3
128924: PUSH
128925: FOR_IN
128926: IFFALSE 129004
// if IsSelected ( i ) then
128928: LD_VAR 0 2
128932: PPUSH
128933: CALL_OW 306
128937: IFFALSE 129002
// begin j := GetSide ( i ) ;
128939: LD_ADDR_VAR 0 3
128943: PUSH
128944: LD_VAR 0 2
128948: PPUSH
128949: CALL_OW 255
128953: ST_TO_ADDR
// if j = 8 then
128954: LD_VAR 0 3
128958: PUSH
128959: LD_INT 8
128961: EQUAL
128962: IFFALSE 128974
// j := 0 else
128964: LD_ADDR_VAR 0 3
128968: PUSH
128969: LD_INT 0
128971: ST_TO_ADDR
128972: GO 128988
// j := j + 1 ;
128974: LD_ADDR_VAR 0 3
128978: PUSH
128979: LD_VAR 0 3
128983: PUSH
128984: LD_INT 1
128986: PLUS
128987: ST_TO_ADDR
// SetSide ( i , j ) ;
128988: LD_VAR 0 2
128992: PPUSH
128993: LD_VAR 0 3
128997: PPUSH
128998: CALL_OW 235
// end ;
129002: GO 128925
129004: POP
129005: POP
// end ;
129006: LD_VAR 0 1
129010: RET
// export function hHackFog ; begin
129011: LD_INT 0
129013: PPUSH
// FogOff ( true ) ;
129014: LD_INT 1
129016: PPUSH
129017: CALL_OW 344
// end ;
129021: LD_VAR 0 1
129025: RET
// export function hHackTeleport ( unit , x , y ) ; begin
129026: LD_INT 0
129028: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
129029: LD_VAR 0 1
129033: PPUSH
129034: LD_VAR 0 2
129038: PPUSH
129039: LD_VAR 0 3
129043: PPUSH
129044: LD_INT 1
129046: PPUSH
129047: LD_INT 1
129049: PPUSH
129050: CALL_OW 483
// CenterOnXY ( x , y ) ;
129054: LD_VAR 0 2
129058: PPUSH
129059: LD_VAR 0 3
129063: PPUSH
129064: CALL_OW 84
// end ;
129068: LD_VAR 0 4
129072: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
129073: LD_INT 0
129075: PPUSH
129076: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
129077: LD_VAR 0 1
129081: NOT
129082: IFTRUE 129101
129084: PUSH
129085: LD_VAR 0 2
129089: PPUSH
129090: LD_VAR 0 3
129094: PPUSH
129095: CALL_OW 488
129099: NOT
129100: OR
129101: IFTRUE 129136
129103: PUSH
129104: LD_VAR 0 1
129108: PPUSH
129109: CALL_OW 266
129113: PUSH
129114: LD_INT 3
129116: NONEQUAL
129117: IFFALSE 129135
129119: PUSH
129120: LD_VAR 0 1
129124: PPUSH
129125: CALL_OW 247
129129: PUSH
129130: LD_INT 1
129132: EQUAL
129133: NOT
129134: AND
129135: OR
129136: IFFALSE 129140
// exit ;
129138: GO 129422
// if GetType ( factory ) = unit_human then
129140: LD_VAR 0 1
129144: PPUSH
129145: CALL_OW 247
129149: PUSH
129150: LD_INT 1
129152: EQUAL
129153: IFFALSE 129170
// factory := IsInUnit ( factory ) ;
129155: LD_ADDR_VAR 0 1
129159: PUSH
129160: LD_VAR 0 1
129164: PPUSH
129165: CALL_OW 310
129169: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
129170: LD_VAR 0 1
129174: PPUSH
129175: CALL_OW 266
129179: PUSH
129180: LD_INT 3
129182: NONEQUAL
129183: IFFALSE 129187
// exit ;
129185: GO 129422
// for i := 1 to Count ( factoryWaypoints ) do
129187: LD_ADDR_VAR 0 5
129191: PUSH
129192: DOUBLE
129193: LD_INT 1
129195: DEC
129196: ST_TO_ADDR
129197: LD_EXP 206
129201: PPUSH
129202: CALL 73163 0 1
129206: PUSH
129207: FOR_TO
129208: IFFALSE 129370
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
129210: LD_VAR 0 2
129214: PPUSH
129215: LD_VAR 0 3
129219: PPUSH
129220: CALL_OW 428
129224: PUSH
129225: LD_EXP 206
129229: PUSH
129230: LD_VAR 0 5
129234: ARRAY
129235: PUSH
129236: LD_INT 2
129238: ARRAY
129239: EQUAL
129240: IFFALSE 129272
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129242: LD_ADDR_EXP 206
129246: PUSH
129247: LD_EXP 206
129251: PPUSH
129252: LD_VAR 0 5
129256: PPUSH
129257: CALL_OW 3
129261: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129262: CALL 129427 0 0
// exit ;
129266: POP
129267: POP
129268: GO 129422
// end else
129270: GO 129368
// if factory = factoryWaypoints [ i ] [ 2 ] then
129272: LD_VAR 0 1
129276: PUSH
129277: LD_EXP 206
129281: PUSH
129282: LD_VAR 0 5
129286: ARRAY
129287: PUSH
129288: LD_INT 2
129290: ARRAY
129291: EQUAL
129292: IFFALSE 129368
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129294: LD_ADDR_EXP 206
129298: PUSH
129299: LD_EXP 206
129303: PPUSH
129304: LD_VAR 0 5
129308: PPUSH
129309: CALL_OW 3
129313: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129314: LD_ADDR_EXP 206
129318: PUSH
129319: LD_EXP 206
129323: PPUSH
129324: LD_VAR 0 1
129328: PPUSH
129329: CALL_OW 255
129333: PUSH
129334: LD_VAR 0 1
129338: PUSH
129339: LD_VAR 0 2
129343: PUSH
129344: LD_VAR 0 3
129348: PUSH
129349: EMPTY
129350: LIST
129351: LIST
129352: LIST
129353: LIST
129354: PPUSH
129355: CALL 109095 0 2
129359: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129360: CALL 129427 0 0
// exit ;
129364: POP
129365: POP
129366: GO 129422
// end ; end ;
129368: GO 129207
129370: POP
129371: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129372: LD_ADDR_EXP 206
129376: PUSH
129377: LD_EXP 206
129381: PPUSH
129382: LD_VAR 0 1
129386: PPUSH
129387: CALL_OW 255
129391: PUSH
129392: LD_VAR 0 1
129396: PUSH
129397: LD_VAR 0 2
129401: PUSH
129402: LD_VAR 0 3
129406: PUSH
129407: EMPTY
129408: LIST
129409: LIST
129410: LIST
129411: LIST
129412: PPUSH
129413: CALL 109095 0 2
129417: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129418: CALL 129427 0 0
// end ;
129422: LD_VAR 0 4
129426: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
129427: LD_INT 0
129429: PPUSH
129430: PPUSH
129431: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
129432: LD_STRING resetFactoryWaypoint();
129434: PPUSH
129435: CALL_OW 559
// if factoryWaypoints then
129439: LD_EXP 206
129443: IFFALSE 129564
// begin list := factoryWaypoints ;
129445: LD_ADDR_VAR 0 3
129449: PUSH
129450: LD_EXP 206
129454: ST_TO_ADDR
// for i := 1 to list do
129455: LD_ADDR_VAR 0 2
129459: PUSH
129460: DOUBLE
129461: LD_INT 1
129463: DEC
129464: ST_TO_ADDR
129465: LD_VAR 0 3
129469: PUSH
129470: FOR_TO
129471: IFFALSE 129562
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129473: LD_STRING setFactoryWaypointXY(
129475: PUSH
129476: LD_VAR 0 3
129480: PUSH
129481: LD_VAR 0 2
129485: ARRAY
129486: PUSH
129487: LD_INT 1
129489: ARRAY
129490: STR
129491: PUSH
129492: LD_STRING ,
129494: STR
129495: PUSH
129496: LD_VAR 0 3
129500: PUSH
129501: LD_VAR 0 2
129505: ARRAY
129506: PUSH
129507: LD_INT 2
129509: ARRAY
129510: STR
129511: PUSH
129512: LD_STRING ,
129514: STR
129515: PUSH
129516: LD_VAR 0 3
129520: PUSH
129521: LD_VAR 0 2
129525: ARRAY
129526: PUSH
129527: LD_INT 3
129529: ARRAY
129530: STR
129531: PUSH
129532: LD_STRING ,
129534: STR
129535: PUSH
129536: LD_VAR 0 3
129540: PUSH
129541: LD_VAR 0 2
129545: ARRAY
129546: PUSH
129547: LD_INT 4
129549: ARRAY
129550: STR
129551: PUSH
129552: LD_STRING )
129554: STR
129555: PPUSH
129556: CALL_OW 559
129560: GO 129470
129562: POP
129563: POP
// end ; end ;
129564: LD_VAR 0 1
129568: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
129569: LD_INT 0
129571: PPUSH
// if HexInfo ( x , y ) = warehouse then
129572: LD_VAR 0 2
129576: PPUSH
129577: LD_VAR 0 3
129581: PPUSH
129582: CALL_OW 428
129586: PUSH
129587: LD_VAR 0 1
129591: EQUAL
129592: IFFALSE 129619
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
129594: LD_ADDR_EXP 208
129598: PUSH
129599: LD_EXP 208
129603: PPUSH
129604: LD_VAR 0 1
129608: PPUSH
129609: LD_INT 0
129611: PPUSH
129612: CALL_OW 1
129616: ST_TO_ADDR
129617: GO 129670
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
129619: LD_ADDR_EXP 208
129623: PUSH
129624: LD_EXP 208
129628: PPUSH
129629: LD_VAR 0 1
129633: PPUSH
129634: LD_VAR 0 1
129638: PPUSH
129639: CALL_OW 255
129643: PUSH
129644: LD_VAR 0 1
129648: PUSH
129649: LD_VAR 0 2
129653: PUSH
129654: LD_VAR 0 3
129658: PUSH
129659: EMPTY
129660: LIST
129661: LIST
129662: LIST
129663: LIST
129664: PPUSH
129665: CALL_OW 1
129669: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
129670: CALL 129679 0 0
// end ;
129674: LD_VAR 0 4
129678: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
129679: LD_INT 0
129681: PPUSH
129682: PPUSH
129683: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
129684: LD_STRING resetWarehouseGatheringPoints();
129686: PPUSH
129687: CALL_OW 559
// if warehouseGatheringPoints then
129691: LD_EXP 208
129695: IFFALSE 129821
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
129697: LD_ADDR_VAR 0 3
129701: PUSH
129702: LD_EXP 208
129706: PPUSH
129707: CALL 113029 0 1
129711: ST_TO_ADDR
// for i := 1 to list do
129712: LD_ADDR_VAR 0 2
129716: PUSH
129717: DOUBLE
129718: LD_INT 1
129720: DEC
129721: ST_TO_ADDR
129722: LD_VAR 0 3
129726: PUSH
129727: FOR_TO
129728: IFFALSE 129819
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129730: LD_STRING setWarehouseGatheringPointXY(
129732: PUSH
129733: LD_VAR 0 3
129737: PUSH
129738: LD_VAR 0 2
129742: ARRAY
129743: PUSH
129744: LD_INT 1
129746: ARRAY
129747: STR
129748: PUSH
129749: LD_STRING ,
129751: STR
129752: PUSH
129753: LD_VAR 0 3
129757: PUSH
129758: LD_VAR 0 2
129762: ARRAY
129763: PUSH
129764: LD_INT 2
129766: ARRAY
129767: STR
129768: PUSH
129769: LD_STRING ,
129771: STR
129772: PUSH
129773: LD_VAR 0 3
129777: PUSH
129778: LD_VAR 0 2
129782: ARRAY
129783: PUSH
129784: LD_INT 3
129786: ARRAY
129787: STR
129788: PUSH
129789: LD_STRING ,
129791: STR
129792: PUSH
129793: LD_VAR 0 3
129797: PUSH
129798: LD_VAR 0 2
129802: ARRAY
129803: PUSH
129804: LD_INT 4
129806: ARRAY
129807: STR
129808: PUSH
129809: LD_STRING )
129811: STR
129812: PPUSH
129813: CALL_OW 559
129817: GO 129727
129819: POP
129820: POP
// end ; end ;
129821: LD_VAR 0 1
129825: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
129826: LD_EXP 208
129830: IFFALSE 130525
129832: GO 129834
129834: DISABLE
129835: LD_INT 0
129837: PPUSH
129838: PPUSH
129839: PPUSH
129840: PPUSH
129841: PPUSH
129842: PPUSH
129843: PPUSH
129844: PPUSH
129845: PPUSH
// begin enable ;
129846: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
129847: LD_ADDR_VAR 0 3
129851: PUSH
129852: LD_EXP 208
129856: PPUSH
129857: CALL 113029 0 1
129861: ST_TO_ADDR
// if not list then
129862: LD_VAR 0 3
129866: NOT
129867: IFFALSE 129871
// exit ;
129869: GO 130525
// for i := 1 to list do
129871: LD_ADDR_VAR 0 1
129875: PUSH
129876: DOUBLE
129877: LD_INT 1
129879: DEC
129880: ST_TO_ADDR
129881: LD_VAR 0 3
129885: PUSH
129886: FOR_TO
129887: IFFALSE 130523
// begin depot := list [ i ] [ 2 ] ;
129889: LD_ADDR_VAR 0 8
129893: PUSH
129894: LD_VAR 0 3
129898: PUSH
129899: LD_VAR 0 1
129903: ARRAY
129904: PUSH
129905: LD_INT 2
129907: ARRAY
129908: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
129909: LD_ADDR_VAR 0 5
129913: PUSH
129914: LD_VAR 0 3
129918: PUSH
129919: LD_VAR 0 1
129923: ARRAY
129924: PUSH
129925: LD_INT 1
129927: ARRAY
129928: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
129929: LD_VAR 0 8
129933: PPUSH
129934: CALL_OW 301
129938: IFTRUE 129957
129940: PUSH
129941: LD_VAR 0 5
129945: PUSH
129946: LD_VAR 0 8
129950: PPUSH
129951: CALL_OW 255
129955: NONEQUAL
129956: OR
129957: IFFALSE 129986
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
129959: LD_ADDR_EXP 208
129963: PUSH
129964: LD_EXP 208
129968: PPUSH
129969: LD_VAR 0 8
129973: PPUSH
129974: LD_INT 0
129976: PPUSH
129977: CALL_OW 1
129981: ST_TO_ADDR
// exit ;
129982: POP
129983: POP
129984: GO 130525
// end ; x := list [ i ] [ 3 ] ;
129986: LD_ADDR_VAR 0 6
129990: PUSH
129991: LD_VAR 0 3
129995: PUSH
129996: LD_VAR 0 1
130000: ARRAY
130001: PUSH
130002: LD_INT 3
130004: ARRAY
130005: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
130006: LD_ADDR_VAR 0 7
130010: PUSH
130011: LD_VAR 0 3
130015: PUSH
130016: LD_VAR 0 1
130020: ARRAY
130021: PUSH
130022: LD_INT 4
130024: ARRAY
130025: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
130026: LD_ADDR_VAR 0 9
130030: PUSH
130031: LD_VAR 0 6
130035: PPUSH
130036: LD_VAR 0 7
130040: PPUSH
130041: LD_INT 16
130043: PPUSH
130044: CALL 111603 0 3
130048: ST_TO_ADDR
// if not cratesNearbyPoint then
130049: LD_VAR 0 9
130053: NOT
130054: IFFALSE 130060
// exit ;
130056: POP
130057: POP
130058: GO 130525
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
130060: LD_ADDR_VAR 0 4
130064: PUSH
130065: LD_INT 22
130067: PUSH
130068: LD_VAR 0 5
130072: PUSH
130073: EMPTY
130074: LIST
130075: LIST
130076: PUSH
130077: LD_INT 3
130079: PUSH
130080: LD_INT 60
130082: PUSH
130083: EMPTY
130084: LIST
130085: PUSH
130086: EMPTY
130087: LIST
130088: LIST
130089: PUSH
130090: LD_INT 91
130092: PUSH
130093: LD_VAR 0 8
130097: PUSH
130098: LD_INT 6
130100: PUSH
130101: EMPTY
130102: LIST
130103: LIST
130104: LIST
130105: PUSH
130106: LD_INT 2
130108: PUSH
130109: LD_INT 25
130111: PUSH
130112: LD_INT 2
130114: PUSH
130115: EMPTY
130116: LIST
130117: LIST
130118: PUSH
130119: LD_INT 25
130121: PUSH
130122: LD_INT 16
130124: PUSH
130125: EMPTY
130126: LIST
130127: LIST
130128: PUSH
130129: EMPTY
130130: LIST
130131: LIST
130132: LIST
130133: PUSH
130134: EMPTY
130135: LIST
130136: LIST
130137: LIST
130138: LIST
130139: PPUSH
130140: CALL_OW 69
130144: PUSH
130145: LD_VAR 0 8
130149: PPUSH
130150: CALL_OW 313
130154: PPUSH
130155: LD_INT 3
130157: PUSH
130158: LD_INT 60
130160: PUSH
130161: EMPTY
130162: LIST
130163: PUSH
130164: EMPTY
130165: LIST
130166: LIST
130167: PUSH
130168: LD_INT 2
130170: PUSH
130171: LD_INT 25
130173: PUSH
130174: LD_INT 2
130176: PUSH
130177: EMPTY
130178: LIST
130179: LIST
130180: PUSH
130181: LD_INT 25
130183: PUSH
130184: LD_INT 16
130186: PUSH
130187: EMPTY
130188: LIST
130189: LIST
130190: PUSH
130191: EMPTY
130192: LIST
130193: LIST
130194: LIST
130195: PUSH
130196: EMPTY
130197: LIST
130198: LIST
130199: PPUSH
130200: CALL_OW 72
130204: UNION
130205: ST_TO_ADDR
// if tmp then
130206: LD_VAR 0 4
130210: IFFALSE 130290
// begin tmp := ShrinkArray ( tmp , 3 ) ;
130212: LD_ADDR_VAR 0 4
130216: PUSH
130217: LD_VAR 0 4
130221: PPUSH
130222: LD_INT 3
130224: PPUSH
130225: CALL 109410 0 2
130229: ST_TO_ADDR
// for j in tmp do
130230: LD_ADDR_VAR 0 2
130234: PUSH
130235: LD_VAR 0 4
130239: PUSH
130240: FOR_IN
130241: IFFALSE 130284
// begin if IsInUnit ( j ) then
130243: LD_VAR 0 2
130247: PPUSH
130248: CALL_OW 310
130252: IFFALSE 130263
// ComExit ( j ) ;
130254: LD_VAR 0 2
130258: PPUSH
130259: CALL 109493 0 1
// AddComCollect ( j , x , y ) ;
130263: LD_VAR 0 2
130267: PPUSH
130268: LD_VAR 0 6
130272: PPUSH
130273: LD_VAR 0 7
130277: PPUSH
130278: CALL_OW 177
// end ;
130282: GO 130240
130284: POP
130285: POP
// exit ;
130286: POP
130287: POP
130288: GO 130525
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
130290: LD_ADDR_VAR 0 4
130294: PUSH
130295: LD_INT 22
130297: PUSH
130298: LD_VAR 0 5
130302: PUSH
130303: EMPTY
130304: LIST
130305: LIST
130306: PUSH
130307: LD_INT 91
130309: PUSH
130310: LD_VAR 0 8
130314: PUSH
130315: LD_INT 8
130317: PUSH
130318: EMPTY
130319: LIST
130320: LIST
130321: LIST
130322: PUSH
130323: LD_INT 2
130325: PUSH
130326: LD_INT 34
130328: PUSH
130329: LD_INT 12
130331: PUSH
130332: EMPTY
130333: LIST
130334: LIST
130335: PUSH
130336: LD_INT 34
130338: PUSH
130339: LD_INT 51
130341: PUSH
130342: EMPTY
130343: LIST
130344: LIST
130345: PUSH
130346: LD_INT 34
130348: PUSH
130349: LD_INT 32
130351: PUSH
130352: EMPTY
130353: LIST
130354: LIST
130355: PUSH
130356: LD_INT 34
130358: PUSH
130359: LD_INT 89
130361: PUSH
130362: EMPTY
130363: LIST
130364: LIST
130365: PUSH
130366: EMPTY
130367: LIST
130368: LIST
130369: LIST
130370: LIST
130371: LIST
130372: PUSH
130373: EMPTY
130374: LIST
130375: LIST
130376: LIST
130377: PPUSH
130378: CALL_OW 69
130382: ST_TO_ADDR
// if tmp then
130383: LD_VAR 0 4
130387: IFFALSE 130521
// begin for j in tmp do
130389: LD_ADDR_VAR 0 2
130393: PUSH
130394: LD_VAR 0 4
130398: PUSH
130399: FOR_IN
130400: IFFALSE 130519
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
130402: LD_VAR 0 2
130406: PPUSH
130407: CALL_OW 262
130411: PUSH
130412: LD_INT 3
130414: EQUAL
130415: IFTRUE 130432
130417: PUSH
130418: LD_VAR 0 2
130422: PPUSH
130423: CALL_OW 261
130427: PUSH
130428: LD_INT 20
130430: GREATER
130431: OR
130432: IFFALSE 130446
130434: PUSH
130435: LD_VAR 0 2
130439: PPUSH
130440: CALL_OW 314
130444: NOT
130445: AND
130446: IFFALSE 130476
130448: PUSH
130449: LD_VAR 0 2
130453: PPUSH
130454: CALL_OW 263
130458: PUSH
130459: LD_INT 1
130461: NONEQUAL
130462: IFTRUE 130475
130464: PUSH
130465: LD_VAR 0 2
130469: PPUSH
130470: CALL_OW 311
130474: OR
130475: AND
130476: IFFALSE 130517
// begin ComCollect ( j , x , y ) ;
130478: LD_VAR 0 2
130482: PPUSH
130483: LD_VAR 0 6
130487: PPUSH
130488: LD_VAR 0 7
130492: PPUSH
130493: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
130497: LD_VAR 0 2
130501: PPUSH
130502: LD_VAR 0 8
130506: PPUSH
130507: CALL_OW 172
// exit ;
130511: POP
130512: POP
130513: POP
130514: POP
130515: GO 130525
// end ;
130517: GO 130399
130519: POP
130520: POP
// end ; end ;
130521: GO 129886
130523: POP
130524: POP
// end ; end_of_file
130525: PPOPN 9
130527: END
// export function SOS_UnitDestroyed ( un ) ; begin
130528: LD_INT 0
130530: PPUSH
// ComRadiation ( un ) ;
130531: LD_VAR 0 1
130535: PPUSH
130536: CALL 131617 0 1
// end ;
130540: LD_VAR 0 2
130544: RET
// export function SOS_UnitKamikazed ( un ) ; begin
130545: LD_INT 0
130547: PPUSH
// ComRadiation ( un ) ;
130548: LD_VAR 0 1
130552: PPUSH
130553: CALL 131617 0 1
// end ;
130557: LD_VAR 0 2
130561: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
130562: LD_INT 0
130564: PPUSH
// end ;
130565: LD_VAR 0 4
130569: RET
// export function SOS_Command ( cmd ) ; begin
130570: LD_INT 0
130572: PPUSH
// end ;
130573: LD_VAR 0 2
130577: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
130578: LD_INT 0
130580: PPUSH
// end ;
130581: LD_VAR 0 6
130585: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
130586: LD_INT 0
130588: PPUSH
130589: PPUSH
130590: PPUSH
130591: PPUSH
// if not vehicle or not factory then
130592: LD_VAR 0 1
130596: NOT
130597: IFTRUE 130606
130599: PUSH
130600: LD_VAR 0 2
130604: NOT
130605: OR
130606: IFFALSE 130610
// exit ;
130608: GO 131192
// if not factoryWaypoints then
130610: LD_EXP 206
130614: NOT
130615: IFFALSE 130619
// exit ;
130617: GO 131192
// for i := 1 to Count ( factoryWaypoints ) do
130619: LD_ADDR_VAR 0 4
130623: PUSH
130624: DOUBLE
130625: LD_INT 1
130627: DEC
130628: ST_TO_ADDR
130629: LD_EXP 206
130633: PPUSH
130634: CALL 73163 0 1
130638: PUSH
130639: FOR_TO
130640: IFFALSE 131190
// if factoryWaypoints [ i ] [ 2 ] = factory then
130642: LD_EXP 206
130646: PUSH
130647: LD_VAR 0 4
130651: ARRAY
130652: PUSH
130653: LD_INT 2
130655: ARRAY
130656: PUSH
130657: LD_VAR 0 2
130661: EQUAL
130662: IFFALSE 131188
// begin if GetControl ( vehicle ) = control_manual then
130664: LD_VAR 0 1
130668: PPUSH
130669: CALL_OW 263
130673: PUSH
130674: LD_INT 1
130676: EQUAL
130677: IFFALSE 131041
// begin driver := IsDrivenBy ( vehicle ) ;
130679: LD_ADDR_VAR 0 5
130683: PUSH
130684: LD_VAR 0 1
130688: PPUSH
130689: CALL_OW 311
130693: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
130694: LD_VAR 0 5
130698: PUSH
130699: LD_EXP 207
130703: IN
130704: IFTRUE 130718
130706: PUSH
130707: LD_VAR 0 1
130711: PUSH
130712: LD_EXP 207
130716: IN
130717: OR
130718: IFFALSE 130724
// exit ;
130720: POP
130721: POP
130722: GO 131192
// if not HasTask ( driver ) then
130724: LD_VAR 0 5
130728: PPUSH
130729: CALL_OW 314
130733: NOT
130734: IFFALSE 131039
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
130736: LD_ADDR_EXP 207
130740: PUSH
130741: LD_EXP 207
130745: PPUSH
130746: LD_VAR 0 5
130750: PPUSH
130751: CALL 109095 0 2
130755: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
130756: LD_ADDR_EXP 207
130760: PUSH
130761: LD_EXP 207
130765: PPUSH
130766: LD_VAR 0 1
130770: PPUSH
130771: CALL 109095 0 2
130775: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130776: LD_ADDR_VAR 0 6
130780: PUSH
130781: LD_EXP 206
130785: PUSH
130786: LD_VAR 0 4
130790: ARRAY
130791: PUSH
130792: LD_INT 3
130794: ARRAY
130795: PPUSH
130796: LD_EXP 206
130800: PUSH
130801: LD_VAR 0 4
130805: ARRAY
130806: PUSH
130807: LD_INT 4
130809: ARRAY
130810: PPUSH
130811: CALL_OW 428
130815: ST_TO_ADDR
// if hex then
130816: LD_VAR 0 6
130820: IFFALSE 130838
// ComMoveUnit ( driver , hex ) else
130822: LD_VAR 0 5
130826: PPUSH
130827: LD_VAR 0 6
130831: PPUSH
130832: CALL_OW 112
130836: GO 130922
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
130838: LD_VAR 0 1
130842: PPUSH
130843: LD_EXP 206
130847: PUSH
130848: LD_VAR 0 4
130852: ARRAY
130853: PUSH
130854: LD_INT 3
130856: ARRAY
130857: PPUSH
130858: LD_EXP 206
130862: PUSH
130863: LD_VAR 0 4
130867: ARRAY
130868: PUSH
130869: LD_INT 4
130871: ARRAY
130872: PPUSH
130873: CALL_OW 297
130877: PUSH
130878: LD_INT 0
130880: GREATER
130881: IFFALSE 130922
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130883: LD_VAR 0 5
130887: PPUSH
130888: LD_EXP 206
130892: PUSH
130893: LD_VAR 0 4
130897: ARRAY
130898: PUSH
130899: LD_INT 3
130901: ARRAY
130902: PPUSH
130903: LD_EXP 206
130907: PUSH
130908: LD_VAR 0 4
130912: ARRAY
130913: PUSH
130914: LD_INT 4
130916: ARRAY
130917: PPUSH
130918: CALL_OW 111
// AddComExitVehicle ( driver ) ;
130922: LD_VAR 0 5
130926: PPUSH
130927: CALL_OW 181
// if Multiplayer then
130931: LD_OWVAR 4
130935: IFFALSE 130984
// begin repeat wait ( 10 ) ;
130937: LD_INT 10
130939: PPUSH
130940: CALL_OW 67
// until not IsInUnit ( driver ) ;
130944: LD_VAR 0 5
130948: PPUSH
130949: CALL_OW 310
130953: NOT
130954: IFFALSE 130937
// if not HasTask ( driver ) then
130956: LD_VAR 0 5
130960: PPUSH
130961: CALL_OW 314
130965: NOT
130966: IFFALSE 130982
// ComEnterUnit ( driver , factory ) ;
130968: LD_VAR 0 5
130972: PPUSH
130973: LD_VAR 0 2
130977: PPUSH
130978: CALL_OW 120
// end else
130982: GO 130998
// AddComEnterUnit ( driver , factory ) ;
130984: LD_VAR 0 5
130988: PPUSH
130989: LD_VAR 0 2
130993: PPUSH
130994: CALL_OW 180
// wait ( 0 0$1 ) ;
130998: LD_INT 35
131000: PPUSH
131001: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
131005: LD_ADDR_EXP 207
131009: PUSH
131010: LD_EXP 207
131014: PUSH
131015: LD_VAR 0 5
131019: DIFF
131020: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
131021: LD_ADDR_EXP 207
131025: PUSH
131026: LD_EXP 207
131030: PUSH
131031: LD_VAR 0 1
131035: DIFF
131036: ST_TO_ADDR
// break ;
131037: GO 131190
// end ; end else
131039: GO 131188
// if GetControl ( vehicle ) = control_remote then
131041: LD_VAR 0 1
131045: PPUSH
131046: CALL_OW 263
131050: PUSH
131051: LD_INT 2
131053: EQUAL
131054: IFFALSE 131140
// begin wait ( 0 0$2 ) ;
131056: LD_INT 70
131058: PPUSH
131059: CALL_OW 67
// repeat wait ( 10 ) ;
131063: LD_INT 10
131065: PPUSH
131066: CALL_OW 67
// Connect ( vehicle ) ;
131070: LD_VAR 0 1
131074: PPUSH
131075: CALL 79407 0 1
// until IsControledBy ( vehicle ) ;
131079: LD_VAR 0 1
131083: PPUSH
131084: CALL_OW 312
131088: IFFALSE 131063
// wait ( 10 ) ;
131090: LD_INT 10
131092: PPUSH
131093: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131097: LD_VAR 0 1
131101: PPUSH
131102: LD_EXP 206
131106: PUSH
131107: LD_VAR 0 4
131111: ARRAY
131112: PUSH
131113: LD_INT 3
131115: ARRAY
131116: PPUSH
131117: LD_EXP 206
131121: PUSH
131122: LD_VAR 0 4
131126: ARRAY
131127: PUSH
131128: LD_INT 4
131130: ARRAY
131131: PPUSH
131132: CALL_OW 111
// break ;
131136: GO 131190
// end else
131138: GO 131188
// begin wait ( 0 0$3 ) ;
131140: LD_INT 105
131142: PPUSH
131143: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131147: LD_VAR 0 1
131151: PPUSH
131152: LD_EXP 206
131156: PUSH
131157: LD_VAR 0 4
131161: ARRAY
131162: PUSH
131163: LD_INT 3
131165: ARRAY
131166: PPUSH
131167: LD_EXP 206
131171: PUSH
131172: LD_VAR 0 4
131176: ARRAY
131177: PUSH
131178: LD_INT 4
131180: ARRAY
131181: PPUSH
131182: CALL_OW 111
// break ;
131186: GO 131190
// end ; end ;
131188: GO 130639
131190: POP
131191: POP
// end ;
131192: LD_VAR 0 3
131196: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
131197: LD_INT 0
131199: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
131200: LD_VAR 0 1
131204: PUSH
131205: LD_INT 250
131207: EQUAL
131208: IFFALSE 131225
131210: PUSH
131211: LD_VAR 0 2
131215: PPUSH
131216: CALL_OW 264
131220: PUSH
131221: LD_INT 81
131223: EQUAL
131224: AND
131225: IFFALSE 131246
// MinerPlaceMine ( unit , x , y ) ;
131227: LD_VAR 0 2
131231: PPUSH
131232: LD_VAR 0 4
131236: PPUSH
131237: LD_VAR 0 5
131241: PPUSH
131242: CALL 134378 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
131246: LD_VAR 0 1
131250: PUSH
131251: LD_INT 251
131253: EQUAL
131254: IFFALSE 131271
131256: PUSH
131257: LD_VAR 0 2
131261: PPUSH
131262: CALL_OW 264
131266: PUSH
131267: LD_INT 81
131269: EQUAL
131270: AND
131271: IFFALSE 131292
// MinerDetonateMine ( unit , x , y ) ;
131273: LD_VAR 0 2
131277: PPUSH
131278: LD_VAR 0 4
131282: PPUSH
131283: LD_VAR 0 5
131287: PPUSH
131288: CALL 134657 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
131292: LD_VAR 0 1
131296: PUSH
131297: LD_INT 252
131299: EQUAL
131300: IFFALSE 131317
131302: PUSH
131303: LD_VAR 0 2
131307: PPUSH
131308: CALL_OW 264
131312: PUSH
131313: LD_INT 81
131315: EQUAL
131316: AND
131317: IFFALSE 131338
// MinerCreateMinefield ( unit , x , y ) ;
131319: LD_VAR 0 2
131323: PPUSH
131324: LD_VAR 0 4
131328: PPUSH
131329: LD_VAR 0 5
131333: PPUSH
131334: CALL 135076 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
131338: LD_VAR 0 1
131342: PUSH
131343: LD_INT 253
131345: EQUAL
131346: IFFALSE 131363
131348: PUSH
131349: LD_VAR 0 2
131353: PPUSH
131354: CALL_OW 257
131358: PUSH
131359: LD_INT 5
131361: EQUAL
131362: AND
131363: IFFALSE 131384
// ComBinocular ( unit , x , y ) ;
131365: LD_VAR 0 2
131369: PPUSH
131370: LD_VAR 0 4
131374: PPUSH
131375: LD_VAR 0 5
131379: PPUSH
131380: CALL 135451 0 3
// if selectedUnit then
131384: LD_VAR 0 3
131388: IFFALSE 131448
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
131390: LD_VAR 0 1
131394: PUSH
131395: LD_INT 254
131397: EQUAL
131398: IFFALSE 131415
131400: PUSH
131401: LD_VAR 0 2
131405: PPUSH
131406: CALL_OW 264
131410: PUSH
131411: LD_INT 99
131413: EQUAL
131414: AND
131415: IFFALSE 131432
131417: PUSH
131418: LD_VAR 0 3
131422: PPUSH
131423: CALL_OW 263
131427: PUSH
131428: LD_INT 3
131430: EQUAL
131431: AND
131432: IFFALSE 131448
// HackDestroyVehicle ( unit , selectedUnit ) ;
131434: LD_VAR 0 2
131438: PPUSH
131439: LD_VAR 0 3
131443: PPUSH
131444: CALL 133738 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
131448: LD_VAR 0 1
131452: PUSH
131453: LD_INT 255
131455: EQUAL
131456: IFFALSE 131480
131458: PUSH
131459: LD_VAR 0 2
131463: PPUSH
131464: CALL_OW 264
131468: PUSH
131469: LD_INT 14
131471: PUSH
131472: LD_INT 53
131474: PUSH
131475: EMPTY
131476: LIST
131477: LIST
131478: IN
131479: AND
131480: IFFALSE 131498
131482: PUSH
131483: LD_VAR 0 4
131487: PPUSH
131488: LD_VAR 0 5
131492: PPUSH
131493: CALL_OW 488
131497: AND
131498: IFFALSE 131522
// CutTreeXYR ( unit , x , y , 12 ) ;
131500: LD_VAR 0 2
131504: PPUSH
131505: LD_VAR 0 4
131509: PPUSH
131510: LD_VAR 0 5
131514: PPUSH
131515: LD_INT 12
131517: PPUSH
131518: CALL 131713 0 4
// if cmd = 256 then
131522: LD_VAR 0 1
131526: PUSH
131527: LD_INT 256
131529: EQUAL
131530: IFFALSE 131551
// SetFactoryWaypoint ( unit , x , y ) ;
131532: LD_VAR 0 2
131536: PPUSH
131537: LD_VAR 0 4
131541: PPUSH
131542: LD_VAR 0 5
131546: PPUSH
131547: CALL 129073 0 3
// if cmd = 257 then
131551: LD_VAR 0 1
131555: PUSH
131556: LD_INT 257
131558: EQUAL
131559: IFFALSE 131580
// SetWarehouseGatheringPoint ( unit , x , y ) ;
131561: LD_VAR 0 2
131565: PPUSH
131566: LD_VAR 0 4
131570: PPUSH
131571: LD_VAR 0 5
131575: PPUSH
131576: CALL 129569 0 3
// if cmd = 258 then
131580: LD_VAR 0 1
131584: PUSH
131585: LD_INT 258
131587: EQUAL
131588: IFFALSE 131612
// BurnTreeXYR ( unit , x , y , 8 ) ;
131590: LD_VAR 0 2
131594: PPUSH
131595: LD_VAR 0 4
131599: PPUSH
131600: LD_VAR 0 5
131604: PPUSH
131605: LD_INT 8
131607: PPUSH
131608: CALL 132113 0 4
// end ;
131612: LD_VAR 0 6
131616: RET
// export function ComRadiation ( un ) ; var eff ; begin
131617: LD_INT 0
131619: PPUSH
131620: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
131621: LD_VAR 0 1
131625: PPUSH
131626: CALL_OW 264
131630: PUSH
131631: LD_INT 91
131633: NONEQUAL
131634: IFFALSE 131638
// exit ;
131636: GO 131708
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
131638: LD_INT 68
131640: PPUSH
131641: LD_VAR 0 1
131645: PPUSH
131646: CALL_OW 255
131650: PPUSH
131651: CALL_OW 321
131655: PUSH
131656: LD_INT 2
131658: EQUAL
131659: IFFALSE 131671
// eff := 50 else
131661: LD_ADDR_VAR 0 3
131665: PUSH
131666: LD_INT 50
131668: ST_TO_ADDR
131669: GO 131679
// eff := 25 ;
131671: LD_ADDR_VAR 0 3
131675: PUSH
131676: LD_INT 25
131678: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
131679: LD_VAR 0 1
131683: PPUSH
131684: CALL_OW 250
131688: PPUSH
131689: LD_VAR 0 1
131693: PPUSH
131694: CALL_OW 251
131698: PPUSH
131699: LD_VAR 0 3
131703: PPUSH
131704: CALL_OW 495
// end ;
131708: LD_VAR 0 2
131712: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
131713: LD_INT 0
131715: PPUSH
131716: PPUSH
131717: PPUSH
131718: PPUSH
131719: PPUSH
131720: PPUSH
131721: PPUSH
131722: PPUSH
131723: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
131724: LD_VAR 0 1
131728: PPUSH
131729: CALL_OW 302
131733: NOT
131734: IFTRUE 131753
131736: PUSH
131737: LD_VAR 0 2
131741: PPUSH
131742: LD_VAR 0 3
131746: PPUSH
131747: CALL_OW 488
131751: NOT
131752: OR
131753: IFTRUE 131762
131755: PUSH
131756: LD_VAR 0 4
131760: NOT
131761: OR
131762: IFFALSE 131766
// exit ;
131764: GO 132108
// list := [ ] ;
131766: LD_ADDR_VAR 0 13
131770: PUSH
131771: EMPTY
131772: ST_TO_ADDR
// if x - r < 0 then
131773: LD_VAR 0 2
131777: PUSH
131778: LD_VAR 0 4
131782: MINUS
131783: PUSH
131784: LD_INT 0
131786: LESS
131787: IFFALSE 131799
// min_x := 0 else
131789: LD_ADDR_VAR 0 7
131793: PUSH
131794: LD_INT 0
131796: ST_TO_ADDR
131797: GO 131815
// min_x := x - r ;
131799: LD_ADDR_VAR 0 7
131803: PUSH
131804: LD_VAR 0 2
131808: PUSH
131809: LD_VAR 0 4
131813: MINUS
131814: ST_TO_ADDR
// if y - r < 0 then
131815: LD_VAR 0 3
131819: PUSH
131820: LD_VAR 0 4
131824: MINUS
131825: PUSH
131826: LD_INT 0
131828: LESS
131829: IFFALSE 131841
// min_y := 0 else
131831: LD_ADDR_VAR 0 8
131835: PUSH
131836: LD_INT 0
131838: ST_TO_ADDR
131839: GO 131857
// min_y := y - r ;
131841: LD_ADDR_VAR 0 8
131845: PUSH
131846: LD_VAR 0 3
131850: PUSH
131851: LD_VAR 0 4
131855: MINUS
131856: ST_TO_ADDR
// max_x := x + r ;
131857: LD_ADDR_VAR 0 9
131861: PUSH
131862: LD_VAR 0 2
131866: PUSH
131867: LD_VAR 0 4
131871: PLUS
131872: ST_TO_ADDR
// max_y := y + r ;
131873: LD_ADDR_VAR 0 10
131877: PUSH
131878: LD_VAR 0 3
131882: PUSH
131883: LD_VAR 0 4
131887: PLUS
131888: ST_TO_ADDR
// for _x = min_x to max_x do
131889: LD_ADDR_VAR 0 11
131893: PUSH
131894: DOUBLE
131895: LD_VAR 0 7
131899: DEC
131900: ST_TO_ADDR
131901: LD_VAR 0 9
131905: PUSH
131906: FOR_TO
131907: IFFALSE 132026
// for _y = min_y to max_y do
131909: LD_ADDR_VAR 0 12
131913: PUSH
131914: DOUBLE
131915: LD_VAR 0 8
131919: DEC
131920: ST_TO_ADDR
131921: LD_VAR 0 10
131925: PUSH
131926: FOR_TO
131927: IFFALSE 132022
// begin if not ValidHex ( _x , _y ) then
131929: LD_VAR 0 11
131933: PPUSH
131934: LD_VAR 0 12
131938: PPUSH
131939: CALL_OW 488
131943: NOT
131944: IFFALSE 131948
// continue ;
131946: GO 131926
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
131948: LD_VAR 0 11
131952: PPUSH
131953: LD_VAR 0 12
131957: PPUSH
131958: CALL_OW 351
131962: IFFALSE 131980
131964: PUSH
131965: LD_VAR 0 11
131969: PPUSH
131970: LD_VAR 0 12
131974: PPUSH
131975: CALL_OW 554
131979: AND
131980: IFFALSE 132020
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
131982: LD_ADDR_VAR 0 13
131986: PUSH
131987: LD_VAR 0 13
131991: PPUSH
131992: LD_VAR 0 13
131996: PUSH
131997: LD_INT 1
131999: PLUS
132000: PPUSH
132001: LD_VAR 0 11
132005: PUSH
132006: LD_VAR 0 12
132010: PUSH
132011: EMPTY
132012: LIST
132013: LIST
132014: PPUSH
132015: CALL_OW 2
132019: ST_TO_ADDR
// end ;
132020: GO 131926
132022: POP
132023: POP
132024: GO 131906
132026: POP
132027: POP
// if not list then
132028: LD_VAR 0 13
132032: NOT
132033: IFFALSE 132037
// exit ;
132035: GO 132108
// for i in list do
132037: LD_ADDR_VAR 0 6
132041: PUSH
132042: LD_VAR 0 13
132046: PUSH
132047: FOR_IN
132048: IFFALSE 132106
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
132050: LD_VAR 0 1
132054: PPUSH
132055: LD_STRING M
132057: PUSH
132058: LD_VAR 0 6
132062: PUSH
132063: LD_INT 1
132065: ARRAY
132066: PUSH
132067: LD_VAR 0 6
132071: PUSH
132072: LD_INT 2
132074: ARRAY
132075: PUSH
132076: LD_INT 0
132078: PUSH
132079: LD_INT 0
132081: PUSH
132082: LD_INT 0
132084: PUSH
132085: LD_INT 0
132087: PUSH
132088: EMPTY
132089: LIST
132090: LIST
132091: LIST
132092: LIST
132093: LIST
132094: LIST
132095: LIST
132096: PUSH
132097: EMPTY
132098: LIST
132099: PPUSH
132100: CALL_OW 447
132104: GO 132047
132106: POP
132107: POP
// end ;
132108: LD_VAR 0 5
132112: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
132113: LD_INT 0
132115: PPUSH
132116: PPUSH
132117: PPUSH
132118: PPUSH
132119: PPUSH
132120: PPUSH
132121: PPUSH
132122: PPUSH
132123: PPUSH
132124: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
132125: LD_VAR 0 1
132129: PPUSH
132130: CALL_OW 302
132134: NOT
132135: IFTRUE 132154
132137: PUSH
132138: LD_VAR 0 2
132142: PPUSH
132143: LD_VAR 0 3
132147: PPUSH
132148: CALL_OW 488
132152: NOT
132153: OR
132154: IFTRUE 132163
132156: PUSH
132157: LD_VAR 0 4
132161: NOT
132162: OR
132163: IFFALSE 132167
// exit ;
132165: GO 132684
// list := [ ] ;
132167: LD_ADDR_VAR 0 13
132171: PUSH
132172: EMPTY
132173: ST_TO_ADDR
// if x - r < 0 then
132174: LD_VAR 0 2
132178: PUSH
132179: LD_VAR 0 4
132183: MINUS
132184: PUSH
132185: LD_INT 0
132187: LESS
132188: IFFALSE 132200
// min_x := 0 else
132190: LD_ADDR_VAR 0 7
132194: PUSH
132195: LD_INT 0
132197: ST_TO_ADDR
132198: GO 132216
// min_x := x - r ;
132200: LD_ADDR_VAR 0 7
132204: PUSH
132205: LD_VAR 0 2
132209: PUSH
132210: LD_VAR 0 4
132214: MINUS
132215: ST_TO_ADDR
// if y - r < 0 then
132216: LD_VAR 0 3
132220: PUSH
132221: LD_VAR 0 4
132225: MINUS
132226: PUSH
132227: LD_INT 0
132229: LESS
132230: IFFALSE 132242
// min_y := 0 else
132232: LD_ADDR_VAR 0 8
132236: PUSH
132237: LD_INT 0
132239: ST_TO_ADDR
132240: GO 132258
// min_y := y - r ;
132242: LD_ADDR_VAR 0 8
132246: PUSH
132247: LD_VAR 0 3
132251: PUSH
132252: LD_VAR 0 4
132256: MINUS
132257: ST_TO_ADDR
// max_x := x + r ;
132258: LD_ADDR_VAR 0 9
132262: PUSH
132263: LD_VAR 0 2
132267: PUSH
132268: LD_VAR 0 4
132272: PLUS
132273: ST_TO_ADDR
// max_y := y + r ;
132274: LD_ADDR_VAR 0 10
132278: PUSH
132279: LD_VAR 0 3
132283: PUSH
132284: LD_VAR 0 4
132288: PLUS
132289: ST_TO_ADDR
// for _x = min_x to max_x do
132290: LD_ADDR_VAR 0 11
132294: PUSH
132295: DOUBLE
132296: LD_VAR 0 7
132300: DEC
132301: ST_TO_ADDR
132302: LD_VAR 0 9
132306: PUSH
132307: FOR_TO
132308: IFFALSE 132427
// for _y = min_y to max_y do
132310: LD_ADDR_VAR 0 12
132314: PUSH
132315: DOUBLE
132316: LD_VAR 0 8
132320: DEC
132321: ST_TO_ADDR
132322: LD_VAR 0 10
132326: PUSH
132327: FOR_TO
132328: IFFALSE 132423
// begin if not ValidHex ( _x , _y ) then
132330: LD_VAR 0 11
132334: PPUSH
132335: LD_VAR 0 12
132339: PPUSH
132340: CALL_OW 488
132344: NOT
132345: IFFALSE 132349
// continue ;
132347: GO 132327
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
132349: LD_VAR 0 11
132353: PPUSH
132354: LD_VAR 0 12
132358: PPUSH
132359: CALL_OW 351
132363: IFFALSE 132381
132365: PUSH
132366: LD_VAR 0 11
132370: PPUSH
132371: LD_VAR 0 12
132375: PPUSH
132376: CALL_OW 554
132380: AND
132381: IFFALSE 132421
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
132383: LD_ADDR_VAR 0 13
132387: PUSH
132388: LD_VAR 0 13
132392: PPUSH
132393: LD_VAR 0 13
132397: PUSH
132398: LD_INT 1
132400: PLUS
132401: PPUSH
132402: LD_VAR 0 11
132406: PUSH
132407: LD_VAR 0 12
132411: PUSH
132412: EMPTY
132413: LIST
132414: LIST
132415: PPUSH
132416: CALL_OW 2
132420: ST_TO_ADDR
// end ;
132421: GO 132327
132423: POP
132424: POP
132425: GO 132307
132427: POP
132428: POP
// if not list then
132429: LD_VAR 0 13
132433: NOT
132434: IFFALSE 132438
// exit ;
132436: GO 132684
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
132438: LD_ADDR_VAR 0 13
132442: PUSH
132443: LD_VAR 0 1
132447: PPUSH
132448: LD_VAR 0 13
132452: PPUSH
132453: LD_INT 1
132455: PPUSH
132456: LD_INT 1
132458: PPUSH
132459: CALL 76535 0 4
132463: ST_TO_ADDR
// ComStop ( flame ) ;
132464: LD_VAR 0 1
132468: PPUSH
132469: CALL_OW 141
// for i in list do
132473: LD_ADDR_VAR 0 6
132477: PUSH
132478: LD_VAR 0 13
132482: PUSH
132483: FOR_IN
132484: IFFALSE 132515
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
132486: LD_VAR 0 1
132490: PPUSH
132491: LD_VAR 0 6
132495: PUSH
132496: LD_INT 1
132498: ARRAY
132499: PPUSH
132500: LD_VAR 0 6
132504: PUSH
132505: LD_INT 2
132507: ARRAY
132508: PPUSH
132509: CALL_OW 176
132513: GO 132483
132515: POP
132516: POP
// repeat wait ( 0 0$1 ) ;
132517: LD_INT 35
132519: PPUSH
132520: CALL_OW 67
// task := GetTaskList ( flame ) ;
132524: LD_ADDR_VAR 0 14
132528: PUSH
132529: LD_VAR 0 1
132533: PPUSH
132534: CALL_OW 437
132538: ST_TO_ADDR
// if not task then
132539: LD_VAR 0 14
132543: NOT
132544: IFFALSE 132548
// exit ;
132546: GO 132684
// if task [ 1 ] [ 1 ] <> | then
132548: LD_VAR 0 14
132552: PUSH
132553: LD_INT 1
132555: ARRAY
132556: PUSH
132557: LD_INT 1
132559: ARRAY
132560: PUSH
132561: LD_STRING |
132563: NONEQUAL
132564: IFFALSE 132568
// exit ;
132566: GO 132684
// _x := task [ 1 ] [ 2 ] ;
132568: LD_ADDR_VAR 0 11
132572: PUSH
132573: LD_VAR 0 14
132577: PUSH
132578: LD_INT 1
132580: ARRAY
132581: PUSH
132582: LD_INT 2
132584: ARRAY
132585: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
132586: LD_ADDR_VAR 0 12
132590: PUSH
132591: LD_VAR 0 14
132595: PUSH
132596: LD_INT 1
132598: ARRAY
132599: PUSH
132600: LD_INT 3
132602: ARRAY
132603: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
132604: LD_VAR 0 11
132608: PPUSH
132609: LD_VAR 0 12
132613: PPUSH
132614: CALL_OW 351
132618: NOT
132619: IFTRUE 132638
132621: PUSH
132622: LD_VAR 0 11
132626: PPUSH
132627: LD_VAR 0 12
132631: PPUSH
132632: CALL_OW 554
132636: NOT
132637: OR
132638: IFFALSE 132672
// begin task := Delete ( task , 1 ) ;
132640: LD_ADDR_VAR 0 14
132644: PUSH
132645: LD_VAR 0 14
132649: PPUSH
132650: LD_INT 1
132652: PPUSH
132653: CALL_OW 3
132657: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
132658: LD_VAR 0 1
132662: PPUSH
132663: LD_VAR 0 14
132667: PPUSH
132668: CALL_OW 446
// end ; until not HasTask ( flame ) ;
132672: LD_VAR 0 1
132676: PPUSH
132677: CALL_OW 314
132681: NOT
132682: IFFALSE 132517
// end ;
132684: LD_VAR 0 5
132688: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
132689: LD_EXP 210
132693: NOT
132694: IFFALSE 132744
132696: GO 132698
132698: DISABLE
// begin initHack := true ;
132699: LD_ADDR_EXP 210
132703: PUSH
132704: LD_INT 1
132706: ST_TO_ADDR
// hackTanks := [ ] ;
132707: LD_ADDR_EXP 211
132711: PUSH
132712: EMPTY
132713: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
132714: LD_ADDR_EXP 212
132718: PUSH
132719: EMPTY
132720: ST_TO_ADDR
// hackLimit := 3 ;
132721: LD_ADDR_EXP 213
132725: PUSH
132726: LD_INT 3
132728: ST_TO_ADDR
// hackDist := 12 ;
132729: LD_ADDR_EXP 214
132733: PUSH
132734: LD_INT 12
132736: ST_TO_ADDR
// hackCounter := [ ] ;
132737: LD_ADDR_EXP 215
132741: PUSH
132742: EMPTY
132743: ST_TO_ADDR
// end ;
132744: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
132745: LD_EXP 210
132749: IFFALSE 132767
132751: PUSH
132752: LD_INT 34
132754: PUSH
132755: LD_INT 99
132757: PUSH
132758: EMPTY
132759: LIST
132760: LIST
132761: PPUSH
132762: CALL_OW 69
132766: AND
132767: IFFALSE 133020
132769: GO 132771
132771: DISABLE
132772: LD_INT 0
132774: PPUSH
132775: PPUSH
// begin enable ;
132776: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
132777: LD_ADDR_VAR 0 1
132781: PUSH
132782: LD_INT 34
132784: PUSH
132785: LD_INT 99
132787: PUSH
132788: EMPTY
132789: LIST
132790: LIST
132791: PPUSH
132792: CALL_OW 69
132796: PUSH
132797: FOR_IN
132798: IFFALSE 133018
// begin if not i in hackTanks then
132800: LD_VAR 0 1
132804: PUSH
132805: LD_EXP 211
132809: IN
132810: NOT
132811: IFFALSE 132894
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
132813: LD_ADDR_EXP 211
132817: PUSH
132818: LD_EXP 211
132822: PPUSH
132823: LD_EXP 211
132827: PUSH
132828: LD_INT 1
132830: PLUS
132831: PPUSH
132832: LD_VAR 0 1
132836: PPUSH
132837: CALL_OW 1
132841: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
132842: LD_ADDR_EXP 212
132846: PUSH
132847: LD_EXP 212
132851: PPUSH
132852: LD_EXP 212
132856: PUSH
132857: LD_INT 1
132859: PLUS
132860: PPUSH
132861: EMPTY
132862: PPUSH
132863: CALL_OW 1
132867: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
132868: LD_ADDR_EXP 215
132872: PUSH
132873: LD_EXP 215
132877: PPUSH
132878: LD_EXP 215
132882: PUSH
132883: LD_INT 1
132885: PLUS
132886: PPUSH
132887: EMPTY
132888: PPUSH
132889: CALL_OW 1
132893: ST_TO_ADDR
// end ; if not IsOk ( i ) then
132894: LD_VAR 0 1
132898: PPUSH
132899: CALL_OW 302
132903: NOT
132904: IFFALSE 132917
// begin HackUnlinkAll ( i ) ;
132906: LD_VAR 0 1
132910: PPUSH
132911: CALL 133023 0 1
// continue ;
132915: GO 132797
// end ; HackCheckCapturedStatus ( i ) ;
132917: LD_VAR 0 1
132921: PPUSH
132922: CALL 133468 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
132926: LD_ADDR_VAR 0 2
132930: PUSH
132931: LD_INT 81
132933: PUSH
132934: LD_VAR 0 1
132938: PPUSH
132939: CALL_OW 255
132943: PUSH
132944: EMPTY
132945: LIST
132946: LIST
132947: PUSH
132948: LD_INT 33
132950: PUSH
132951: LD_INT 3
132953: PUSH
132954: EMPTY
132955: LIST
132956: LIST
132957: PUSH
132958: LD_INT 91
132960: PUSH
132961: LD_VAR 0 1
132965: PUSH
132966: LD_EXP 214
132970: PUSH
132971: EMPTY
132972: LIST
132973: LIST
132974: LIST
132975: PUSH
132976: LD_INT 50
132978: PUSH
132979: EMPTY
132980: LIST
132981: PUSH
132982: EMPTY
132983: LIST
132984: LIST
132985: LIST
132986: LIST
132987: PPUSH
132988: CALL_OW 69
132992: ST_TO_ADDR
// if not tmp then
132993: LD_VAR 0 2
132997: NOT
132998: IFFALSE 133002
// continue ;
133000: GO 132797
// HackLink ( i , tmp ) ;
133002: LD_VAR 0 1
133006: PPUSH
133007: LD_VAR 0 2
133011: PPUSH
133012: CALL 133159 0 2
// end ;
133016: GO 132797
133018: POP
133019: POP
// end ;
133020: PPOPN 2
133022: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
133023: LD_INT 0
133025: PPUSH
133026: PPUSH
133027: PPUSH
// if not hack in hackTanks then
133028: LD_VAR 0 1
133032: PUSH
133033: LD_EXP 211
133037: IN
133038: NOT
133039: IFFALSE 133043
// exit ;
133041: GO 133154
// index := GetElementIndex ( hackTanks , hack ) ;
133043: LD_ADDR_VAR 0 4
133047: PUSH
133048: LD_EXP 211
133052: PPUSH
133053: LD_VAR 0 1
133057: PPUSH
133058: CALL 75830 0 2
133062: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
133063: LD_EXP 212
133067: PUSH
133068: LD_VAR 0 4
133072: ARRAY
133073: IFFALSE 133154
// begin for i in hackTanksCaptured [ index ] do
133075: LD_ADDR_VAR 0 3
133079: PUSH
133080: LD_EXP 212
133084: PUSH
133085: LD_VAR 0 4
133089: ARRAY
133090: PUSH
133091: FOR_IN
133092: IFFALSE 133118
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
133094: LD_VAR 0 3
133098: PUSH
133099: LD_INT 1
133101: ARRAY
133102: PPUSH
133103: LD_VAR 0 3
133107: PUSH
133108: LD_INT 2
133110: ARRAY
133111: PPUSH
133112: CALL_OW 235
133116: GO 133091
133118: POP
133119: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
133120: LD_ADDR_EXP 212
133124: PUSH
133125: LD_EXP 212
133129: PPUSH
133130: LD_VAR 0 4
133134: PPUSH
133135: EMPTY
133136: PPUSH
133137: CALL_OW 1
133141: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
133142: LD_VAR 0 1
133146: PPUSH
133147: LD_INT 0
133149: PPUSH
133150: CALL_OW 505
// end ; end ;
133154: LD_VAR 0 2
133158: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
133159: LD_INT 0
133161: PPUSH
133162: PPUSH
133163: PPUSH
// if not hack in hackTanks or not vehicles then
133164: LD_VAR 0 1
133168: PUSH
133169: LD_EXP 211
133173: IN
133174: NOT
133175: IFTRUE 133184
133177: PUSH
133178: LD_VAR 0 2
133182: NOT
133183: OR
133184: IFFALSE 133188
// exit ;
133186: GO 133463
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
133188: LD_ADDR_VAR 0 2
133192: PUSH
133193: LD_VAR 0 1
133197: PPUSH
133198: LD_VAR 0 2
133202: PPUSH
133203: LD_INT 1
133205: PPUSH
133206: LD_INT 1
133208: PPUSH
133209: CALL 76482 0 4
133213: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
133214: LD_ADDR_VAR 0 5
133218: PUSH
133219: LD_EXP 211
133223: PPUSH
133224: LD_VAR 0 1
133228: PPUSH
133229: CALL 75830 0 2
133233: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
133234: LD_EXP 212
133238: PUSH
133239: LD_VAR 0 5
133243: ARRAY
133244: PUSH
133245: LD_EXP 213
133249: LESS
133250: IFFALSE 133439
// begin for i := 1 to vehicles do
133252: LD_ADDR_VAR 0 4
133256: PUSH
133257: DOUBLE
133258: LD_INT 1
133260: DEC
133261: ST_TO_ADDR
133262: LD_VAR 0 2
133266: PUSH
133267: FOR_TO
133268: IFFALSE 133437
// begin if hackTanksCaptured [ index ] = hackLimit then
133270: LD_EXP 212
133274: PUSH
133275: LD_VAR 0 5
133279: ARRAY
133280: PUSH
133281: LD_EXP 213
133285: EQUAL
133286: IFFALSE 133290
// break ;
133288: GO 133437
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
133290: LD_ADDR_EXP 215
133294: PUSH
133295: LD_EXP 215
133299: PPUSH
133300: LD_VAR 0 5
133304: PPUSH
133305: LD_EXP 215
133309: PUSH
133310: LD_VAR 0 5
133314: ARRAY
133315: PUSH
133316: LD_INT 1
133318: PLUS
133319: PPUSH
133320: CALL_OW 1
133324: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
133325: LD_ADDR_EXP 212
133329: PUSH
133330: LD_EXP 212
133334: PPUSH
133335: LD_VAR 0 5
133339: PUSH
133340: LD_EXP 212
133344: PUSH
133345: LD_VAR 0 5
133349: ARRAY
133350: PUSH
133351: LD_INT 1
133353: PLUS
133354: PUSH
133355: EMPTY
133356: LIST
133357: LIST
133358: PPUSH
133359: LD_VAR 0 2
133363: PUSH
133364: LD_VAR 0 4
133368: ARRAY
133369: PUSH
133370: LD_VAR 0 2
133374: PUSH
133375: LD_VAR 0 4
133379: ARRAY
133380: PPUSH
133381: CALL_OW 255
133385: PUSH
133386: EMPTY
133387: LIST
133388: LIST
133389: PPUSH
133390: CALL 76047 0 3
133394: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
133395: LD_VAR 0 2
133399: PUSH
133400: LD_VAR 0 4
133404: ARRAY
133405: PPUSH
133406: LD_VAR 0 1
133410: PPUSH
133411: CALL_OW 255
133415: PPUSH
133416: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
133420: LD_VAR 0 2
133424: PUSH
133425: LD_VAR 0 4
133429: ARRAY
133430: PPUSH
133431: CALL_OW 141
// end ;
133435: GO 133267
133437: POP
133438: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133439: LD_VAR 0 1
133443: PPUSH
133444: LD_EXP 212
133448: PUSH
133449: LD_VAR 0 5
133453: ARRAY
133454: PUSH
133455: LD_INT 0
133457: PLUS
133458: PPUSH
133459: CALL_OW 505
// end ;
133463: LD_VAR 0 3
133467: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
133468: LD_INT 0
133470: PPUSH
133471: PPUSH
133472: PPUSH
133473: PPUSH
// if not hack in hackTanks then
133474: LD_VAR 0 1
133478: PUSH
133479: LD_EXP 211
133483: IN
133484: NOT
133485: IFFALSE 133489
// exit ;
133487: GO 133733
// index := GetElementIndex ( hackTanks , hack ) ;
133489: LD_ADDR_VAR 0 4
133493: PUSH
133494: LD_EXP 211
133498: PPUSH
133499: LD_VAR 0 1
133503: PPUSH
133504: CALL 75830 0 2
133508: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
133509: LD_ADDR_VAR 0 3
133513: PUSH
133514: DOUBLE
133515: LD_EXP 212
133519: PUSH
133520: LD_VAR 0 4
133524: ARRAY
133525: INC
133526: ST_TO_ADDR
133527: LD_INT 1
133529: PUSH
133530: FOR_DOWNTO
133531: IFFALSE 133707
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
133533: LD_ADDR_VAR 0 5
133537: PUSH
133538: LD_EXP 212
133542: PUSH
133543: LD_VAR 0 4
133547: ARRAY
133548: PUSH
133549: LD_VAR 0 3
133553: ARRAY
133554: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
133555: LD_VAR 0 5
133559: PUSH
133560: LD_INT 1
133562: ARRAY
133563: PPUSH
133564: CALL_OW 302
133568: NOT
133569: IFTRUE 133597
133571: PUSH
133572: LD_VAR 0 5
133576: PUSH
133577: LD_INT 1
133579: ARRAY
133580: PPUSH
133581: CALL_OW 255
133585: PUSH
133586: LD_VAR 0 1
133590: PPUSH
133591: CALL_OW 255
133595: NONEQUAL
133596: OR
133597: IFFALSE 133705
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
133599: LD_VAR 0 5
133603: PUSH
133604: LD_INT 1
133606: ARRAY
133607: PPUSH
133608: CALL_OW 305
133612: IFFALSE 133640
133614: PUSH
133615: LD_VAR 0 5
133619: PUSH
133620: LD_INT 1
133622: ARRAY
133623: PPUSH
133624: CALL_OW 255
133628: PUSH
133629: LD_VAR 0 1
133633: PPUSH
133634: CALL_OW 255
133638: EQUAL
133639: AND
133640: IFFALSE 133664
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
133642: LD_VAR 0 5
133646: PUSH
133647: LD_INT 1
133649: ARRAY
133650: PPUSH
133651: LD_VAR 0 5
133655: PUSH
133656: LD_INT 2
133658: ARRAY
133659: PPUSH
133660: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
133664: LD_ADDR_EXP 212
133668: PUSH
133669: LD_EXP 212
133673: PPUSH
133674: LD_VAR 0 4
133678: PPUSH
133679: LD_EXP 212
133683: PUSH
133684: LD_VAR 0 4
133688: ARRAY
133689: PPUSH
133690: LD_VAR 0 3
133694: PPUSH
133695: CALL_OW 3
133699: PPUSH
133700: CALL_OW 1
133704: ST_TO_ADDR
// end ; end ;
133705: GO 133530
133707: POP
133708: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133709: LD_VAR 0 1
133713: PPUSH
133714: LD_EXP 212
133718: PUSH
133719: LD_VAR 0 4
133723: ARRAY
133724: PUSH
133725: LD_INT 0
133727: PLUS
133728: PPUSH
133729: CALL_OW 505
// end ;
133733: LD_VAR 0 2
133737: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
133738: LD_INT 0
133740: PPUSH
133741: PPUSH
133742: PPUSH
133743: PPUSH
// if not hack in hackTanks then
133744: LD_VAR 0 1
133748: PUSH
133749: LD_EXP 211
133753: IN
133754: NOT
133755: IFFALSE 133759
// exit ;
133757: GO 133844
// index := GetElementIndex ( hackTanks , hack ) ;
133759: LD_ADDR_VAR 0 5
133763: PUSH
133764: LD_EXP 211
133768: PPUSH
133769: LD_VAR 0 1
133773: PPUSH
133774: CALL 75830 0 2
133778: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
133779: LD_ADDR_VAR 0 4
133783: PUSH
133784: DOUBLE
133785: LD_INT 1
133787: DEC
133788: ST_TO_ADDR
133789: LD_EXP 212
133793: PUSH
133794: LD_VAR 0 5
133798: ARRAY
133799: PUSH
133800: FOR_TO
133801: IFFALSE 133842
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
133803: LD_EXP 212
133807: PUSH
133808: LD_VAR 0 5
133812: ARRAY
133813: PUSH
133814: LD_VAR 0 4
133818: ARRAY
133819: PUSH
133820: LD_INT 1
133822: ARRAY
133823: PUSH
133824: LD_VAR 0 2
133828: EQUAL
133829: IFFALSE 133840
// KillUnit ( vehicle ) ;
133831: LD_VAR 0 2
133835: PPUSH
133836: CALL_OW 66
133840: GO 133800
133842: POP
133843: POP
// end ;
133844: LD_VAR 0 3
133848: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
133849: LD_EXP 216
133853: NOT
133854: IFFALSE 133889
133856: GO 133858
133858: DISABLE
// begin initMiner := true ;
133859: LD_ADDR_EXP 216
133863: PUSH
133864: LD_INT 1
133866: ST_TO_ADDR
// minersList := [ ] ;
133867: LD_ADDR_EXP 217
133871: PUSH
133872: EMPTY
133873: ST_TO_ADDR
// minerMinesList := [ ] ;
133874: LD_ADDR_EXP 218
133878: PUSH
133879: EMPTY
133880: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
133881: LD_ADDR_EXP 219
133885: PUSH
133886: LD_INT 5
133888: ST_TO_ADDR
// end ;
133889: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
133890: LD_EXP 216
133894: IFFALSE 133912
133896: PUSH
133897: LD_INT 34
133899: PUSH
133900: LD_INT 81
133902: PUSH
133903: EMPTY
133904: LIST
133905: LIST
133906: PPUSH
133907: CALL_OW 69
133911: AND
133912: IFFALSE 134375
133914: GO 133916
133916: DISABLE
133917: LD_INT 0
133919: PPUSH
133920: PPUSH
133921: PPUSH
133922: PPUSH
// begin enable ;
133923: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
133924: LD_ADDR_VAR 0 1
133928: PUSH
133929: LD_INT 34
133931: PUSH
133932: LD_INT 81
133934: PUSH
133935: EMPTY
133936: LIST
133937: LIST
133938: PPUSH
133939: CALL_OW 69
133943: PUSH
133944: FOR_IN
133945: IFFALSE 134017
// begin if not i in minersList then
133947: LD_VAR 0 1
133951: PUSH
133952: LD_EXP 217
133956: IN
133957: NOT
133958: IFFALSE 134015
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
133960: LD_ADDR_EXP 217
133964: PUSH
133965: LD_EXP 217
133969: PPUSH
133970: LD_EXP 217
133974: PUSH
133975: LD_INT 1
133977: PLUS
133978: PPUSH
133979: LD_VAR 0 1
133983: PPUSH
133984: CALL_OW 1
133988: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
133989: LD_ADDR_EXP 218
133993: PUSH
133994: LD_EXP 218
133998: PPUSH
133999: LD_EXP 218
134003: PUSH
134004: LD_INT 1
134006: PLUS
134007: PPUSH
134008: EMPTY
134009: PPUSH
134010: CALL_OW 1
134014: ST_TO_ADDR
// end end ;
134015: GO 133944
134017: POP
134018: POP
// for i := minerMinesList downto 1 do
134019: LD_ADDR_VAR 0 1
134023: PUSH
134024: DOUBLE
134025: LD_EXP 218
134029: INC
134030: ST_TO_ADDR
134031: LD_INT 1
134033: PUSH
134034: FOR_DOWNTO
134035: IFFALSE 134373
// begin if IsLive ( minersList [ i ] ) then
134037: LD_EXP 217
134041: PUSH
134042: LD_VAR 0 1
134046: ARRAY
134047: PPUSH
134048: CALL_OW 300
134052: IFFALSE 134080
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
134054: LD_EXP 217
134058: PUSH
134059: LD_VAR 0 1
134063: ARRAY
134064: PPUSH
134065: LD_EXP 218
134069: PUSH
134070: LD_VAR 0 1
134074: ARRAY
134075: PPUSH
134076: CALL_OW 505
// if not minerMinesList [ i ] then
134080: LD_EXP 218
134084: PUSH
134085: LD_VAR 0 1
134089: ARRAY
134090: NOT
134091: IFFALSE 134095
// continue ;
134093: GO 134034
// for j := minerMinesList [ i ] downto 1 do
134095: LD_ADDR_VAR 0 2
134099: PUSH
134100: DOUBLE
134101: LD_EXP 218
134105: PUSH
134106: LD_VAR 0 1
134110: ARRAY
134111: INC
134112: ST_TO_ADDR
134113: LD_INT 1
134115: PUSH
134116: FOR_DOWNTO
134117: IFFALSE 134369
// begin side := GetSide ( minersList [ i ] ) ;
134119: LD_ADDR_VAR 0 3
134123: PUSH
134124: LD_EXP 217
134128: PUSH
134129: LD_VAR 0 1
134133: ARRAY
134134: PPUSH
134135: CALL_OW 255
134139: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
134140: LD_ADDR_VAR 0 4
134144: PUSH
134145: LD_EXP 218
134149: PUSH
134150: LD_VAR 0 1
134154: ARRAY
134155: PUSH
134156: LD_VAR 0 2
134160: ARRAY
134161: PUSH
134162: LD_INT 1
134164: ARRAY
134165: PPUSH
134166: LD_EXP 218
134170: PUSH
134171: LD_VAR 0 1
134175: ARRAY
134176: PUSH
134177: LD_VAR 0 2
134181: ARRAY
134182: PUSH
134183: LD_INT 2
134185: ARRAY
134186: PPUSH
134187: CALL_OW 428
134191: ST_TO_ADDR
// if not tmp then
134192: LD_VAR 0 4
134196: NOT
134197: IFFALSE 134201
// continue ;
134199: GO 134116
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
134201: LD_VAR 0 4
134205: PUSH
134206: LD_INT 81
134208: PUSH
134209: LD_VAR 0 3
134213: PUSH
134214: EMPTY
134215: LIST
134216: LIST
134217: PPUSH
134218: CALL_OW 69
134222: IN
134223: IFFALSE 134273
134225: PUSH
134226: LD_EXP 218
134230: PUSH
134231: LD_VAR 0 1
134235: ARRAY
134236: PUSH
134237: LD_VAR 0 2
134241: ARRAY
134242: PUSH
134243: LD_INT 1
134245: ARRAY
134246: PPUSH
134247: LD_EXP 218
134251: PUSH
134252: LD_VAR 0 1
134256: ARRAY
134257: PUSH
134258: LD_VAR 0 2
134262: ARRAY
134263: PUSH
134264: LD_INT 2
134266: ARRAY
134267: PPUSH
134268: CALL_OW 458
134272: AND
134273: IFFALSE 134367
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
134275: LD_EXP 218
134279: PUSH
134280: LD_VAR 0 1
134284: ARRAY
134285: PUSH
134286: LD_VAR 0 2
134290: ARRAY
134291: PUSH
134292: LD_INT 1
134294: ARRAY
134295: PPUSH
134296: LD_EXP 218
134300: PUSH
134301: LD_VAR 0 1
134305: ARRAY
134306: PUSH
134307: LD_VAR 0 2
134311: ARRAY
134312: PUSH
134313: LD_INT 2
134315: ARRAY
134316: PPUSH
134317: LD_VAR 0 3
134321: PPUSH
134322: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
134326: LD_ADDR_EXP 218
134330: PUSH
134331: LD_EXP 218
134335: PPUSH
134336: LD_VAR 0 1
134340: PPUSH
134341: LD_EXP 218
134345: PUSH
134346: LD_VAR 0 1
134350: ARRAY
134351: PPUSH
134352: LD_VAR 0 2
134356: PPUSH
134357: CALL_OW 3
134361: PPUSH
134362: CALL_OW 1
134366: ST_TO_ADDR
// end ; end ;
134367: GO 134116
134369: POP
134370: POP
// end ;
134371: GO 134034
134373: POP
134374: POP
// end ;
134375: PPOPN 4
134377: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
134378: LD_INT 0
134380: PPUSH
134381: PPUSH
// result := false ;
134382: LD_ADDR_VAR 0 4
134386: PUSH
134387: LD_INT 0
134389: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
134390: LD_VAR 0 1
134394: PPUSH
134395: CALL_OW 264
134399: PUSH
134400: LD_INT 81
134402: EQUAL
134403: NOT
134404: IFFALSE 134408
// exit ;
134406: GO 134652
// index := GetElementIndex ( minersList , unit ) ;
134408: LD_ADDR_VAR 0 5
134412: PUSH
134413: LD_EXP 217
134417: PPUSH
134418: LD_VAR 0 1
134422: PPUSH
134423: CALL 75830 0 2
134427: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
134428: LD_EXP 218
134432: PUSH
134433: LD_VAR 0 5
134437: ARRAY
134438: PUSH
134439: LD_EXP 219
134443: GREATEREQUAL
134444: IFFALSE 134448
// exit ;
134446: GO 134652
// ComMoveXY ( unit , x , y ) ;
134448: LD_VAR 0 1
134452: PPUSH
134453: LD_VAR 0 2
134457: PPUSH
134458: LD_VAR 0 3
134462: PPUSH
134463: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
134467: LD_INT 35
134469: PPUSH
134470: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
134474: LD_VAR 0 1
134478: PPUSH
134479: LD_VAR 0 2
134483: PPUSH
134484: LD_VAR 0 3
134488: PPUSH
134489: CALL 107876 0 3
134493: NOT
134494: IFFALSE 134507
134496: PUSH
134497: LD_VAR 0 1
134501: PPUSH
134502: CALL_OW 314
134506: AND
134507: IFFALSE 134511
// exit ;
134509: GO 134652
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
134511: LD_VAR 0 2
134515: PPUSH
134516: LD_VAR 0 3
134520: PPUSH
134521: CALL_OW 428
134525: PUSH
134526: LD_VAR 0 1
134530: EQUAL
134531: IFFALSE 134545
134533: PUSH
134534: LD_VAR 0 1
134538: PPUSH
134539: CALL_OW 314
134543: NOT
134544: AND
134545: IFFALSE 134467
// PlaySoundXY ( x , y , PlantMine ) ;
134547: LD_VAR 0 2
134551: PPUSH
134552: LD_VAR 0 3
134556: PPUSH
134557: LD_STRING PlantMine
134559: PPUSH
134560: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
134564: LD_VAR 0 2
134568: PPUSH
134569: LD_VAR 0 3
134573: PPUSH
134574: LD_VAR 0 1
134578: PPUSH
134579: CALL_OW 255
134583: PPUSH
134584: LD_INT 0
134586: PPUSH
134587: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
134591: LD_ADDR_EXP 218
134595: PUSH
134596: LD_EXP 218
134600: PPUSH
134601: LD_VAR 0 5
134605: PUSH
134606: LD_EXP 218
134610: PUSH
134611: LD_VAR 0 5
134615: ARRAY
134616: PUSH
134617: LD_INT 1
134619: PLUS
134620: PUSH
134621: EMPTY
134622: LIST
134623: LIST
134624: PPUSH
134625: LD_VAR 0 2
134629: PUSH
134630: LD_VAR 0 3
134634: PUSH
134635: EMPTY
134636: LIST
134637: LIST
134638: PPUSH
134639: CALL 76047 0 3
134643: ST_TO_ADDR
// result := true ;
134644: LD_ADDR_VAR 0 4
134648: PUSH
134649: LD_INT 1
134651: ST_TO_ADDR
// end ;
134652: LD_VAR 0 4
134656: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
134657: LD_INT 0
134659: PPUSH
134660: PPUSH
134661: PPUSH
// if not unit in minersList then
134662: LD_VAR 0 1
134666: PUSH
134667: LD_EXP 217
134671: IN
134672: NOT
134673: IFFALSE 134677
// exit ;
134675: GO 135071
// index := GetElementIndex ( minersList , unit ) ;
134677: LD_ADDR_VAR 0 6
134681: PUSH
134682: LD_EXP 217
134686: PPUSH
134687: LD_VAR 0 1
134691: PPUSH
134692: CALL 75830 0 2
134696: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
134697: LD_ADDR_VAR 0 5
134701: PUSH
134702: DOUBLE
134703: LD_EXP 218
134707: PUSH
134708: LD_VAR 0 6
134712: ARRAY
134713: INC
134714: ST_TO_ADDR
134715: LD_INT 1
134717: PUSH
134718: FOR_DOWNTO
134719: IFFALSE 134882
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
134721: LD_EXP 218
134725: PUSH
134726: LD_VAR 0 6
134730: ARRAY
134731: PUSH
134732: LD_VAR 0 5
134736: ARRAY
134737: PUSH
134738: LD_INT 1
134740: ARRAY
134741: PUSH
134742: LD_VAR 0 2
134746: EQUAL
134747: IFFALSE 134777
134749: PUSH
134750: LD_EXP 218
134754: PUSH
134755: LD_VAR 0 6
134759: ARRAY
134760: PUSH
134761: LD_VAR 0 5
134765: ARRAY
134766: PUSH
134767: LD_INT 2
134769: ARRAY
134770: PUSH
134771: LD_VAR 0 3
134775: EQUAL
134776: AND
134777: IFFALSE 134880
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
134779: LD_EXP 218
134783: PUSH
134784: LD_VAR 0 6
134788: ARRAY
134789: PUSH
134790: LD_VAR 0 5
134794: ARRAY
134795: PUSH
134796: LD_INT 1
134798: ARRAY
134799: PPUSH
134800: LD_EXP 218
134804: PUSH
134805: LD_VAR 0 6
134809: ARRAY
134810: PUSH
134811: LD_VAR 0 5
134815: ARRAY
134816: PUSH
134817: LD_INT 2
134819: ARRAY
134820: PPUSH
134821: LD_VAR 0 1
134825: PPUSH
134826: CALL_OW 255
134830: PPUSH
134831: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
134835: LD_ADDR_EXP 218
134839: PUSH
134840: LD_EXP 218
134844: PPUSH
134845: LD_VAR 0 6
134849: PPUSH
134850: LD_EXP 218
134854: PUSH
134855: LD_VAR 0 6
134859: ARRAY
134860: PPUSH
134861: LD_VAR 0 5
134865: PPUSH
134866: CALL_OW 3
134870: PPUSH
134871: CALL_OW 1
134875: ST_TO_ADDR
// exit ;
134876: POP
134877: POP
134878: GO 135071
// end ; end ;
134880: GO 134718
134882: POP
134883: POP
// for i := minerMinesList [ index ] downto 1 do
134884: LD_ADDR_VAR 0 5
134888: PUSH
134889: DOUBLE
134890: LD_EXP 218
134894: PUSH
134895: LD_VAR 0 6
134899: ARRAY
134900: INC
134901: ST_TO_ADDR
134902: LD_INT 1
134904: PUSH
134905: FOR_DOWNTO
134906: IFFALSE 135069
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
134908: LD_EXP 218
134912: PUSH
134913: LD_VAR 0 6
134917: ARRAY
134918: PUSH
134919: LD_VAR 0 5
134923: ARRAY
134924: PUSH
134925: LD_INT 1
134927: ARRAY
134928: PPUSH
134929: LD_EXP 218
134933: PUSH
134934: LD_VAR 0 6
134938: ARRAY
134939: PUSH
134940: LD_VAR 0 5
134944: ARRAY
134945: PUSH
134946: LD_INT 2
134948: ARRAY
134949: PPUSH
134950: LD_VAR 0 2
134954: PPUSH
134955: LD_VAR 0 3
134959: PPUSH
134960: CALL_OW 298
134964: PUSH
134965: LD_INT 6
134967: LESS
134968: IFFALSE 135067
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
134970: LD_EXP 218
134974: PUSH
134975: LD_VAR 0 6
134979: ARRAY
134980: PUSH
134981: LD_VAR 0 5
134985: ARRAY
134986: PUSH
134987: LD_INT 1
134989: ARRAY
134990: PPUSH
134991: LD_EXP 218
134995: PUSH
134996: LD_VAR 0 6
135000: ARRAY
135001: PUSH
135002: LD_VAR 0 5
135006: ARRAY
135007: PUSH
135008: LD_INT 2
135010: ARRAY
135011: PPUSH
135012: LD_VAR 0 1
135016: PPUSH
135017: CALL_OW 255
135021: PPUSH
135022: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
135026: LD_ADDR_EXP 218
135030: PUSH
135031: LD_EXP 218
135035: PPUSH
135036: LD_VAR 0 6
135040: PPUSH
135041: LD_EXP 218
135045: PUSH
135046: LD_VAR 0 6
135050: ARRAY
135051: PPUSH
135052: LD_VAR 0 5
135056: PPUSH
135057: CALL_OW 3
135061: PPUSH
135062: CALL_OW 1
135066: ST_TO_ADDR
// end ; end ;
135067: GO 134905
135069: POP
135070: POP
// end ;
135071: LD_VAR 0 4
135075: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
135076: LD_INT 0
135078: PPUSH
135079: PPUSH
135080: PPUSH
135081: PPUSH
135082: PPUSH
135083: PPUSH
135084: PPUSH
135085: PPUSH
135086: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
135087: LD_VAR 0 1
135091: PPUSH
135092: CALL_OW 264
135096: PUSH
135097: LD_INT 81
135099: EQUAL
135100: NOT
135101: IFTRUE 135116
135103: PUSH
135104: LD_VAR 0 1
135108: PUSH
135109: LD_EXP 217
135113: IN
135114: NOT
135115: OR
135116: IFFALSE 135120
// exit ;
135118: GO 135446
// index := GetElementIndex ( minersList , unit ) ;
135120: LD_ADDR_VAR 0 6
135124: PUSH
135125: LD_EXP 217
135129: PPUSH
135130: LD_VAR 0 1
135134: PPUSH
135135: CALL 75830 0 2
135139: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
135140: LD_ADDR_VAR 0 8
135144: PUSH
135145: LD_EXP 219
135149: PUSH
135150: LD_EXP 218
135154: PUSH
135155: LD_VAR 0 6
135159: ARRAY
135160: MINUS
135161: ST_TO_ADDR
// if not minesFreeAmount then
135162: LD_VAR 0 8
135166: NOT
135167: IFFALSE 135171
// exit ;
135169: GO 135446
// tmp := [ ] ;
135171: LD_ADDR_VAR 0 7
135175: PUSH
135176: EMPTY
135177: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
135178: LD_ADDR_VAR 0 5
135182: PUSH
135183: DOUBLE
135184: LD_INT 1
135186: DEC
135187: ST_TO_ADDR
135188: LD_VAR 0 8
135192: PUSH
135193: FOR_TO
135194: IFFALSE 135393
// begin _d := rand ( 0 , 5 ) ;
135196: LD_ADDR_VAR 0 11
135200: PUSH
135201: LD_INT 0
135203: PPUSH
135204: LD_INT 5
135206: PPUSH
135207: CALL_OW 12
135211: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
135212: LD_ADDR_VAR 0 12
135216: PUSH
135217: LD_INT 2
135219: PPUSH
135220: LD_INT 6
135222: PPUSH
135223: CALL_OW 12
135227: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
135228: LD_ADDR_VAR 0 9
135232: PUSH
135233: LD_VAR 0 2
135237: PPUSH
135238: LD_VAR 0 11
135242: PPUSH
135243: LD_VAR 0 12
135247: PPUSH
135248: CALL_OW 272
135252: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
135253: LD_ADDR_VAR 0 10
135257: PUSH
135258: LD_VAR 0 3
135262: PPUSH
135263: LD_VAR 0 11
135267: PPUSH
135268: LD_VAR 0 12
135272: PPUSH
135273: CALL_OW 273
135277: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
135278: LD_VAR 0 9
135282: PPUSH
135283: LD_VAR 0 10
135287: PPUSH
135288: CALL_OW 488
135292: IFFALSE 135316
135294: PUSH
135295: LD_VAR 0 9
135299: PUSH
135300: LD_VAR 0 10
135304: PUSH
135305: EMPTY
135306: LIST
135307: LIST
135308: PUSH
135309: LD_VAR 0 7
135313: IN
135314: NOT
135315: AND
135316: IFFALSE 135335
135318: PUSH
135319: LD_VAR 0 9
135323: PPUSH
135324: LD_VAR 0 10
135328: PPUSH
135329: CALL_OW 458
135333: NOT
135334: AND
135335: IFFALSE 135377
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
135337: LD_ADDR_VAR 0 7
135341: PUSH
135342: LD_VAR 0 7
135346: PPUSH
135347: LD_VAR 0 7
135351: PUSH
135352: LD_INT 1
135354: PLUS
135355: PPUSH
135356: LD_VAR 0 9
135360: PUSH
135361: LD_VAR 0 10
135365: PUSH
135366: EMPTY
135367: LIST
135368: LIST
135369: PPUSH
135370: CALL_OW 1
135374: ST_TO_ADDR
135375: GO 135391
// i := i - 1 ;
135377: LD_ADDR_VAR 0 5
135381: PUSH
135382: LD_VAR 0 5
135386: PUSH
135387: LD_INT 1
135389: MINUS
135390: ST_TO_ADDR
// end ;
135391: GO 135193
135393: POP
135394: POP
// for i in tmp do
135395: LD_ADDR_VAR 0 5
135399: PUSH
135400: LD_VAR 0 7
135404: PUSH
135405: FOR_IN
135406: IFFALSE 135444
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
135408: LD_VAR 0 1
135412: PPUSH
135413: LD_VAR 0 5
135417: PUSH
135418: LD_INT 1
135420: ARRAY
135421: PPUSH
135422: LD_VAR 0 5
135426: PUSH
135427: LD_INT 2
135429: ARRAY
135430: PPUSH
135431: CALL 134378 0 3
135435: NOT
135436: IFFALSE 135442
// exit ;
135438: POP
135439: POP
135440: GO 135446
135442: GO 135405
135444: POP
135445: POP
// end ;
135446: LD_VAR 0 4
135450: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
135451: LD_INT 0
135453: PPUSH
135454: PPUSH
135455: PPUSH
135456: PPUSH
135457: PPUSH
135458: PPUSH
135459: PPUSH
135460: PPUSH
135461: PPUSH
// if GetClass ( unit ) <> class_sniper then
135462: LD_VAR 0 1
135466: PPUSH
135467: CALL_OW 257
135471: PUSH
135472: LD_INT 5
135474: NONEQUAL
135475: IFFALSE 135479
// exit ;
135477: GO 135949
// dist := 8 ;
135479: LD_ADDR_VAR 0 5
135483: PUSH
135484: LD_INT 8
135486: ST_TO_ADDR
// viewRange := 12 ;
135487: LD_ADDR_VAR 0 8
135491: PUSH
135492: LD_INT 12
135494: ST_TO_ADDR
// side := GetSide ( unit ) ;
135495: LD_ADDR_VAR 0 6
135499: PUSH
135500: LD_VAR 0 1
135504: PPUSH
135505: CALL_OW 255
135509: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
135510: LD_INT 61
135512: PPUSH
135513: LD_VAR 0 6
135517: PPUSH
135518: CALL_OW 321
135522: PUSH
135523: LD_INT 2
135525: EQUAL
135526: IFFALSE 135536
// viewRange := 16 ;
135528: LD_ADDR_VAR 0 8
135532: PUSH
135533: LD_INT 16
135535: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
135536: LD_VAR 0 1
135540: PPUSH
135541: LD_VAR 0 2
135545: PPUSH
135546: LD_VAR 0 3
135550: PPUSH
135551: CALL_OW 297
135555: PUSH
135556: LD_VAR 0 5
135560: GREATER
135561: IFFALSE 135640
// begin ComMoveXY ( unit , x , y ) ;
135563: LD_VAR 0 1
135567: PPUSH
135568: LD_VAR 0 2
135572: PPUSH
135573: LD_VAR 0 3
135577: PPUSH
135578: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
135582: LD_INT 35
135584: PPUSH
135585: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
135589: LD_VAR 0 1
135593: PPUSH
135594: LD_VAR 0 2
135598: PPUSH
135599: LD_VAR 0 3
135603: PPUSH
135604: CALL 107876 0 3
135608: NOT
135609: IFFALSE 135613
// exit ;
135611: GO 135949
// until GetDistUnitXY ( unit , x , y ) < dist ;
135613: LD_VAR 0 1
135617: PPUSH
135618: LD_VAR 0 2
135622: PPUSH
135623: LD_VAR 0 3
135627: PPUSH
135628: CALL_OW 297
135632: PUSH
135633: LD_VAR 0 5
135637: LESS
135638: IFFALSE 135582
// end ; ComTurnXY ( unit , x , y ) ;
135640: LD_VAR 0 1
135644: PPUSH
135645: LD_VAR 0 2
135649: PPUSH
135650: LD_VAR 0 3
135654: PPUSH
135655: CALL_OW 118
// repeat if Multiplayer then
135659: LD_OWVAR 4
135663: IFFALSE 135674
// wait ( 35 ) else
135665: LD_INT 35
135667: PPUSH
135668: CALL_OW 67
135672: GO 135681
// wait ( 5 ) ;
135674: LD_INT 5
135676: PPUSH
135677: CALL_OW 67
// _d := GetDir ( unit ) ;
135681: LD_ADDR_VAR 0 11
135685: PUSH
135686: LD_VAR 0 1
135690: PPUSH
135691: CALL_OW 254
135695: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
135696: LD_ADDR_VAR 0 7
135700: PUSH
135701: LD_VAR 0 1
135705: PPUSH
135706: CALL_OW 250
135710: PPUSH
135711: LD_VAR 0 1
135715: PPUSH
135716: CALL_OW 251
135720: PPUSH
135721: LD_VAR 0 2
135725: PPUSH
135726: LD_VAR 0 3
135730: PPUSH
135731: CALL 110512 0 4
135735: ST_TO_ADDR
// until dir = _d ;
135736: LD_VAR 0 7
135740: PUSH
135741: LD_VAR 0 11
135745: EQUAL
135746: IFFALSE 135659
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
135748: LD_ADDR_VAR 0 9
135752: PUSH
135753: LD_VAR 0 1
135757: PPUSH
135758: CALL_OW 250
135762: PPUSH
135763: LD_VAR 0 7
135767: PPUSH
135768: LD_VAR 0 5
135772: PPUSH
135773: CALL_OW 272
135777: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
135778: LD_ADDR_VAR 0 10
135782: PUSH
135783: LD_VAR 0 1
135787: PPUSH
135788: CALL_OW 251
135792: PPUSH
135793: LD_VAR 0 7
135797: PPUSH
135798: LD_VAR 0 5
135802: PPUSH
135803: CALL_OW 273
135807: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
135808: LD_VAR 0 9
135812: PPUSH
135813: LD_VAR 0 10
135817: PPUSH
135818: CALL_OW 488
135822: NOT
135823: IFFALSE 135827
// exit ;
135825: GO 135949
// ComAnimCustom ( unit , 1 ) ;
135827: LD_VAR 0 1
135831: PPUSH
135832: LD_INT 1
135834: PPUSH
135835: CALL_OW 592
// p := 0 ;
135839: LD_ADDR_VAR 0 12
135843: PUSH
135844: LD_INT 0
135846: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
135847: LD_VAR 0 9
135851: PPUSH
135852: LD_VAR 0 10
135856: PPUSH
135857: LD_VAR 0 6
135861: PPUSH
135862: LD_VAR 0 8
135866: PPUSH
135867: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
135871: LD_INT 35
135873: PPUSH
135874: CALL_OW 67
// p := Inc ( p ) ;
135878: LD_ADDR_VAR 0 12
135882: PUSH
135883: LD_VAR 0 12
135887: PPUSH
135888: CALL 110468 0 1
135892: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
135893: LD_VAR 0 12
135897: PUSH
135898: LD_INT 3
135900: EQUAL
135901: IFTRUE 135915
135903: PUSH
135904: LD_VAR 0 1
135908: PPUSH
135909: CALL_OW 302
135913: NOT
135914: OR
135915: IFTRUE 135928
135917: PUSH
135918: LD_VAR 0 1
135922: PPUSH
135923: CALL_OW 301
135927: OR
135928: IFFALSE 135871
// RemoveSeeing ( _x , _y , side ) ;
135930: LD_VAR 0 9
135934: PPUSH
135935: LD_VAR 0 10
135939: PPUSH
135940: LD_VAR 0 6
135944: PPUSH
135945: CALL_OW 331
// end ;
135949: LD_VAR 0 4
135953: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
135954: LD_INT 0
135956: PPUSH
135957: PPUSH
135958: PPUSH
135959: PPUSH
135960: PPUSH
135961: PPUSH
135962: PPUSH
135963: PPUSH
135964: PPUSH
135965: PPUSH
135966: PPUSH
// if not unit then
135967: LD_VAR 0 1
135971: NOT
135972: IFFALSE 135976
// exit ;
135974: GO 136247
// side := GetSide ( unit ) ;
135976: LD_ADDR_VAR 0 3
135980: PUSH
135981: LD_VAR 0 1
135985: PPUSH
135986: CALL_OW 255
135990: ST_TO_ADDR
// x := GetX ( unit ) ;
135991: LD_ADDR_VAR 0 5
135995: PUSH
135996: LD_VAR 0 1
136000: PPUSH
136001: CALL_OW 250
136005: ST_TO_ADDR
// y := GetY ( unit ) ;
136006: LD_ADDR_VAR 0 6
136010: PUSH
136011: LD_VAR 0 1
136015: PPUSH
136016: CALL_OW 251
136020: ST_TO_ADDR
// r := 8 ;
136021: LD_ADDR_VAR 0 4
136025: PUSH
136026: LD_INT 8
136028: ST_TO_ADDR
// if x - r < 0 then
136029: LD_VAR 0 5
136033: PUSH
136034: LD_VAR 0 4
136038: MINUS
136039: PUSH
136040: LD_INT 0
136042: LESS
136043: IFFALSE 136055
// min_x := 0 else
136045: LD_ADDR_VAR 0 7
136049: PUSH
136050: LD_INT 0
136052: ST_TO_ADDR
136053: GO 136071
// min_x := x - r ;
136055: LD_ADDR_VAR 0 7
136059: PUSH
136060: LD_VAR 0 5
136064: PUSH
136065: LD_VAR 0 4
136069: MINUS
136070: ST_TO_ADDR
// if y - r < 0 then
136071: LD_VAR 0 6
136075: PUSH
136076: LD_VAR 0 4
136080: MINUS
136081: PUSH
136082: LD_INT 0
136084: LESS
136085: IFFALSE 136097
// min_y := 0 else
136087: LD_ADDR_VAR 0 8
136091: PUSH
136092: LD_INT 0
136094: ST_TO_ADDR
136095: GO 136113
// min_y := y - r ;
136097: LD_ADDR_VAR 0 8
136101: PUSH
136102: LD_VAR 0 6
136106: PUSH
136107: LD_VAR 0 4
136111: MINUS
136112: ST_TO_ADDR
// max_x := x + r ;
136113: LD_ADDR_VAR 0 9
136117: PUSH
136118: LD_VAR 0 5
136122: PUSH
136123: LD_VAR 0 4
136127: PLUS
136128: ST_TO_ADDR
// max_y := y + r ;
136129: LD_ADDR_VAR 0 10
136133: PUSH
136134: LD_VAR 0 6
136138: PUSH
136139: LD_VAR 0 4
136143: PLUS
136144: ST_TO_ADDR
// for _x = min_x to max_x do
136145: LD_ADDR_VAR 0 11
136149: PUSH
136150: DOUBLE
136151: LD_VAR 0 7
136155: DEC
136156: ST_TO_ADDR
136157: LD_VAR 0 9
136161: PUSH
136162: FOR_TO
136163: IFFALSE 136245
// for _y = min_y to max_y do
136165: LD_ADDR_VAR 0 12
136169: PUSH
136170: DOUBLE
136171: LD_VAR 0 8
136175: DEC
136176: ST_TO_ADDR
136177: LD_VAR 0 10
136181: PUSH
136182: FOR_TO
136183: IFFALSE 136241
// begin if not ValidHex ( _x , _y ) then
136185: LD_VAR 0 11
136189: PPUSH
136190: LD_VAR 0 12
136194: PPUSH
136195: CALL_OW 488
136199: NOT
136200: IFFALSE 136204
// continue ;
136202: GO 136182
// if MineAtPos ( _x , _y ) then
136204: LD_VAR 0 11
136208: PPUSH
136209: LD_VAR 0 12
136213: PPUSH
136214: CALL_OW 458
136218: IFFALSE 136239
// ViewMineAtPos ( _x , _y , side ) ;
136220: LD_VAR 0 11
136224: PPUSH
136225: LD_VAR 0 12
136229: PPUSH
136230: LD_VAR 0 3
136234: PPUSH
136235: CALL_OW 457
// end ;
136239: GO 136182
136241: POP
136242: POP
136243: GO 136162
136245: POP
136246: POP
// end ;
136247: LD_VAR 0 2
136251: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
136252: LD_INT 0
136254: PPUSH
136255: PPUSH
136256: PPUSH
136257: PPUSH
136258: PPUSH
136259: PPUSH
// if not units then
136260: LD_VAR 0 1
136264: NOT
136265: IFFALSE 136269
// exit ;
136267: GO 136699
// scaners := [ ] ;
136269: LD_ADDR_VAR 0 6
136273: PUSH
136274: EMPTY
136275: ST_TO_ADDR
// for i in units do
136276: LD_ADDR_VAR 0 3
136280: PUSH
136281: LD_VAR 0 1
136285: PUSH
136286: FOR_IN
136287: IFFALSE 136444
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
136289: LD_VAR 0 3
136293: PPUSH
136294: CALL_OW 264
136298: PUSH
136299: LD_INT 11
136301: NONEQUAL
136302: IFTRUE 136316
136304: PUSH
136305: LD_VAR 0 3
136309: PPUSH
136310: CALL_OW 302
136314: NOT
136315: OR
136316: IFTRUE 136333
136318: PUSH
136319: LD_VAR 0 3
136323: PPUSH
136324: CALL_OW 110
136328: PUSH
136329: LD_INT 502
136331: EQUAL
136332: OR
136333: IFFALSE 136337
// continue ;
136335: GO 136286
// ComStop ( i ) ;
136337: LD_VAR 0 3
136341: PPUSH
136342: CALL_OW 141
// x := GetX ( i ) ;
136346: LD_ADDR_VAR 0 4
136350: PUSH
136351: LD_VAR 0 3
136355: PPUSH
136356: CALL_OW 250
136360: ST_TO_ADDR
// y := GetY ( i ) ;
136361: LD_ADDR_VAR 0 5
136365: PUSH
136366: LD_VAR 0 3
136370: PPUSH
136371: CALL_OW 251
136375: ST_TO_ADDR
// if GetSide ( i ) = your_side then
136376: LD_VAR 0 3
136380: PPUSH
136381: CALL_OW 255
136385: PUSH
136386: LD_OWVAR 2
136390: EQUAL
136391: IFFALSE 136410
// PlaySoundXY ( x , y , mineDetector ) ;
136393: LD_VAR 0 4
136397: PPUSH
136398: LD_VAR 0 5
136402: PPUSH
136403: LD_STRING mineDetector
136405: PPUSH
136406: CALL_OW 366
// scaners := Join ( scaners , i ) ;
136410: LD_ADDR_VAR 0 6
136414: PUSH
136415: LD_VAR 0 6
136419: PPUSH
136420: LD_VAR 0 3
136424: PPUSH
136425: CALL 109095 0 2
136429: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
136430: LD_VAR 0 3
136434: PPUSH
136435: LD_INT 502
136437: PPUSH
136438: CALL_OW 109
// end ;
136442: GO 136286
136444: POP
136445: POP
// if not scaners then
136446: LD_VAR 0 6
136450: NOT
136451: IFFALSE 136455
// exit ;
136453: GO 136699
// wait ( 3 ) ;
136455: LD_INT 3
136457: PPUSH
136458: CALL_OW 67
// timer := 6 ;
136462: LD_ADDR_VAR 0 7
136466: PUSH
136467: LD_INT 6
136469: ST_TO_ADDR
// repeat for i in scaners do
136470: LD_ADDR_VAR 0 3
136474: PUSH
136475: LD_VAR 0 6
136479: PUSH
136480: FOR_IN
136481: IFFALSE 136597
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
136483: LD_VAR 0 3
136487: PPUSH
136488: CALL_OW 302
136492: NOT
136493: IFTRUE 136506
136495: PUSH
136496: LD_VAR 0 3
136500: PPUSH
136501: CALL_OW 314
136505: OR
136506: IFTRUE 136537
136508: PUSH
136509: LD_VAR 0 3
136513: PPUSH
136514: CALL_OW 263
136518: PUSH
136519: LD_INT 1
136521: EQUAL
136522: IFFALSE 136536
136524: PUSH
136525: LD_VAR 0 3
136529: PPUSH
136530: CALL_OW 311
136534: NOT
136535: AND
136536: OR
136537: IFFALSE 136581
// begin SetUnitDisplayNumber ( i , 0 ) ;
136539: LD_VAR 0 3
136543: PPUSH
136544: LD_INT 0
136546: PPUSH
136547: CALL_OW 505
// SetTag ( i , 0 ) ;
136551: LD_VAR 0 3
136555: PPUSH
136556: LD_INT 0
136558: PPUSH
136559: CALL_OW 109
// scaners := scaners diff i ;
136563: LD_ADDR_VAR 0 6
136567: PUSH
136568: LD_VAR 0 6
136572: PUSH
136573: LD_VAR 0 3
136577: DIFF
136578: ST_TO_ADDR
// continue ;
136579: GO 136480
// end ; SetUnitDisplayNumber ( i , timer ) ;
136581: LD_VAR 0 3
136585: PPUSH
136586: LD_VAR 0 7
136590: PPUSH
136591: CALL_OW 505
// end ;
136595: GO 136480
136597: POP
136598: POP
// if not scaners then
136599: LD_VAR 0 6
136603: NOT
136604: IFFALSE 136608
// exit ;
136606: GO 136699
// timer := Dec ( timer ) ;
136608: LD_ADDR_VAR 0 7
136612: PUSH
136613: LD_VAR 0 7
136617: PPUSH
136618: CALL 110490 0 1
136622: ST_TO_ADDR
// wait ( 0 0$1 ) ;
136623: LD_INT 35
136625: PPUSH
136626: CALL_OW 67
// until timer = 0 ;
136630: LD_VAR 0 7
136634: PUSH
136635: LD_INT 0
136637: EQUAL
136638: IFFALSE 136470
// if not scaners then
136640: LD_VAR 0 6
136644: NOT
136645: IFFALSE 136649
// exit ;
136647: GO 136699
// for i in scaners do
136649: LD_ADDR_VAR 0 3
136653: PUSH
136654: LD_VAR 0 6
136658: PUSH
136659: FOR_IN
136660: IFFALSE 136697
// begin SetUnitDisplayNumber ( i , 0 ) ;
136662: LD_VAR 0 3
136666: PPUSH
136667: LD_INT 0
136669: PPUSH
136670: CALL_OW 505
// SetTag ( i , 0 ) ;
136674: LD_VAR 0 3
136678: PPUSH
136679: LD_INT 0
136681: PPUSH
136682: CALL_OW 109
// RevealDetectorMine ( i ) ;
136686: LD_VAR 0 3
136690: PPUSH
136691: CALL 135954 0 1
// end ;
136695: GO 136659
136697: POP
136698: POP
// end ;
136699: LD_VAR 0 2
136703: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
136704: LD_INT 0
136706: PPUSH
// if p1 = mine_detector_mode then
136707: LD_VAR 0 2
136711: PUSH
136712: LD_INT 103
136714: EQUAL
136715: IFFALSE 136726
// DetectMine ( units ) ;
136717: LD_VAR 0 1
136721: PPUSH
136722: CALL 136252 0 1
// end ; end_of_file
136726: LD_VAR 0 7
136730: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
136731: LD_INT 0
136733: PPUSH
136734: PPUSH
136735: PPUSH
136736: PPUSH
136737: PPUSH
136738: PPUSH
136739: PPUSH
136740: PPUSH
136741: PPUSH
136742: PPUSH
136743: PPUSH
136744: PPUSH
136745: PPUSH
136746: PPUSH
136747: PPUSH
136748: PPUSH
136749: PPUSH
136750: PPUSH
136751: PPUSH
136752: PPUSH
136753: PPUSH
136754: PPUSH
136755: PPUSH
136756: PPUSH
136757: PPUSH
136758: PPUSH
136759: PPUSH
136760: PPUSH
136761: PPUSH
136762: PPUSH
136763: PPUSH
136764: PPUSH
136765: PPUSH
136766: PPUSH
// if not list then
136767: LD_VAR 0 1
136771: NOT
136772: IFFALSE 136776
// exit ;
136774: GO 141495
// base := list [ 1 ] ;
136776: LD_ADDR_VAR 0 3
136780: PUSH
136781: LD_VAR 0 1
136785: PUSH
136786: LD_INT 1
136788: ARRAY
136789: ST_TO_ADDR
// group := list [ 2 ] ;
136790: LD_ADDR_VAR 0 4
136794: PUSH
136795: LD_VAR 0 1
136799: PUSH
136800: LD_INT 2
136802: ARRAY
136803: ST_TO_ADDR
// path := list [ 3 ] ;
136804: LD_ADDR_VAR 0 5
136808: PUSH
136809: LD_VAR 0 1
136813: PUSH
136814: LD_INT 3
136816: ARRAY
136817: ST_TO_ADDR
// flags := list [ 4 ] ;
136818: LD_ADDR_VAR 0 6
136822: PUSH
136823: LD_VAR 0 1
136827: PUSH
136828: LD_INT 4
136830: ARRAY
136831: ST_TO_ADDR
// mined := [ ] ;
136832: LD_ADDR_VAR 0 27
136836: PUSH
136837: EMPTY
136838: ST_TO_ADDR
// bombed := [ ] ;
136839: LD_ADDR_VAR 0 28
136843: PUSH
136844: EMPTY
136845: ST_TO_ADDR
// healers := [ ] ;
136846: LD_ADDR_VAR 0 31
136850: PUSH
136851: EMPTY
136852: ST_TO_ADDR
// to_heal := [ ] ;
136853: LD_ADDR_VAR 0 30
136857: PUSH
136858: EMPTY
136859: ST_TO_ADDR
// repairs := [ ] ;
136860: LD_ADDR_VAR 0 33
136864: PUSH
136865: EMPTY
136866: ST_TO_ADDR
// to_repair := [ ] ;
136867: LD_ADDR_VAR 0 32
136871: PUSH
136872: EMPTY
136873: ST_TO_ADDR
// if not group or not path then
136874: LD_VAR 0 4
136878: NOT
136879: IFTRUE 136888
136881: PUSH
136882: LD_VAR 0 5
136886: NOT
136887: OR
136888: IFFALSE 136892
// exit ;
136890: GO 141495
// side := GetSide ( group [ 1 ] ) ;
136892: LD_ADDR_VAR 0 35
136896: PUSH
136897: LD_VAR 0 4
136901: PUSH
136902: LD_INT 1
136904: ARRAY
136905: PPUSH
136906: CALL_OW 255
136910: ST_TO_ADDR
// if flags then
136911: LD_VAR 0 6
136915: IFFALSE 137059
// begin f_ignore_area := flags [ 1 ] ;
136917: LD_ADDR_VAR 0 17
136921: PUSH
136922: LD_VAR 0 6
136926: PUSH
136927: LD_INT 1
136929: ARRAY
136930: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
136931: LD_ADDR_VAR 0 18
136935: PUSH
136936: LD_VAR 0 6
136940: PUSH
136941: LD_INT 2
136943: ARRAY
136944: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
136945: LD_ADDR_VAR 0 19
136949: PUSH
136950: LD_VAR 0 6
136954: PUSH
136955: LD_INT 3
136957: ARRAY
136958: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
136959: LD_ADDR_VAR 0 20
136963: PUSH
136964: LD_VAR 0 6
136968: PUSH
136969: LD_INT 4
136971: ARRAY
136972: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
136973: LD_ADDR_VAR 0 21
136977: PUSH
136978: LD_VAR 0 6
136982: PUSH
136983: LD_INT 5
136985: ARRAY
136986: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
136987: LD_ADDR_VAR 0 22
136991: PUSH
136992: LD_VAR 0 6
136996: PUSH
136997: LD_INT 6
136999: ARRAY
137000: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
137001: LD_ADDR_VAR 0 23
137005: PUSH
137006: LD_VAR 0 6
137010: PUSH
137011: LD_INT 7
137013: ARRAY
137014: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
137015: LD_ADDR_VAR 0 24
137019: PUSH
137020: LD_VAR 0 6
137024: PUSH
137025: LD_INT 8
137027: ARRAY
137028: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
137029: LD_ADDR_VAR 0 25
137033: PUSH
137034: LD_VAR 0 6
137038: PUSH
137039: LD_INT 9
137041: ARRAY
137042: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
137043: LD_ADDR_VAR 0 26
137047: PUSH
137048: LD_VAR 0 6
137052: PUSH
137053: LD_INT 10
137055: ARRAY
137056: ST_TO_ADDR
// end else
137057: GO 137139
// begin f_ignore_area := false ;
137059: LD_ADDR_VAR 0 17
137063: PUSH
137064: LD_INT 0
137066: ST_TO_ADDR
// f_capture := false ;
137067: LD_ADDR_VAR 0 18
137071: PUSH
137072: LD_INT 0
137074: ST_TO_ADDR
// f_ignore_civ := false ;
137075: LD_ADDR_VAR 0 19
137079: PUSH
137080: LD_INT 0
137082: ST_TO_ADDR
// f_murder := false ;
137083: LD_ADDR_VAR 0 20
137087: PUSH
137088: LD_INT 0
137090: ST_TO_ADDR
// f_mines := false ;
137091: LD_ADDR_VAR 0 21
137095: PUSH
137096: LD_INT 0
137098: ST_TO_ADDR
// f_repair := false ;
137099: LD_ADDR_VAR 0 22
137103: PUSH
137104: LD_INT 0
137106: ST_TO_ADDR
// f_heal := false ;
137107: LD_ADDR_VAR 0 23
137111: PUSH
137112: LD_INT 0
137114: ST_TO_ADDR
// f_spacetime := false ;
137115: LD_ADDR_VAR 0 24
137119: PUSH
137120: LD_INT 0
137122: ST_TO_ADDR
// f_attack_depot := false ;
137123: LD_ADDR_VAR 0 25
137127: PUSH
137128: LD_INT 0
137130: ST_TO_ADDR
// f_crawl := false ;
137131: LD_ADDR_VAR 0 26
137135: PUSH
137136: LD_INT 0
137138: ST_TO_ADDR
// end ; if f_heal then
137139: LD_VAR 0 23
137143: IFFALSE 137170
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
137145: LD_ADDR_VAR 0 31
137149: PUSH
137150: LD_VAR 0 4
137154: PPUSH
137155: LD_INT 25
137157: PUSH
137158: LD_INT 4
137160: PUSH
137161: EMPTY
137162: LIST
137163: LIST
137164: PPUSH
137165: CALL_OW 72
137169: ST_TO_ADDR
// if f_repair then
137170: LD_VAR 0 22
137174: IFFALSE 137201
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
137176: LD_ADDR_VAR 0 33
137180: PUSH
137181: LD_VAR 0 4
137185: PPUSH
137186: LD_INT 25
137188: PUSH
137189: LD_INT 3
137191: PUSH
137192: EMPTY
137193: LIST
137194: LIST
137195: PPUSH
137196: CALL_OW 72
137200: ST_TO_ADDR
// units_path := [ ] ;
137201: LD_ADDR_VAR 0 16
137205: PUSH
137206: EMPTY
137207: ST_TO_ADDR
// for i = 1 to group do
137208: LD_ADDR_VAR 0 7
137212: PUSH
137213: DOUBLE
137214: LD_INT 1
137216: DEC
137217: ST_TO_ADDR
137218: LD_VAR 0 4
137222: PUSH
137223: FOR_TO
137224: IFFALSE 137253
// units_path := Replace ( units_path , i , path ) ;
137226: LD_ADDR_VAR 0 16
137230: PUSH
137231: LD_VAR 0 16
137235: PPUSH
137236: LD_VAR 0 7
137240: PPUSH
137241: LD_VAR 0 5
137245: PPUSH
137246: CALL_OW 1
137250: ST_TO_ADDR
137251: GO 137223
137253: POP
137254: POP
// repeat for i = group downto 1 do
137255: LD_ADDR_VAR 0 7
137259: PUSH
137260: DOUBLE
137261: LD_VAR 0 4
137265: INC
137266: ST_TO_ADDR
137267: LD_INT 1
137269: PUSH
137270: FOR_DOWNTO
137271: IFFALSE 141447
// begin wait ( 5 ) ;
137273: LD_INT 5
137275: PPUSH
137276: CALL_OW 67
// tmp := [ ] ;
137280: LD_ADDR_VAR 0 14
137284: PUSH
137285: EMPTY
137286: ST_TO_ADDR
// attacking := false ;
137287: LD_ADDR_VAR 0 29
137291: PUSH
137292: LD_INT 0
137294: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
137295: LD_VAR 0 4
137299: PUSH
137300: LD_VAR 0 7
137304: ARRAY
137305: PPUSH
137306: CALL_OW 301
137310: IFTRUE 137325
137312: PUSH
137313: LD_VAR 0 4
137317: PUSH
137318: LD_VAR 0 7
137322: ARRAY
137323: NOT
137324: OR
137325: IFFALSE 137434
// begin if GetType ( group [ i ] ) = unit_human then
137327: LD_VAR 0 4
137331: PUSH
137332: LD_VAR 0 7
137336: ARRAY
137337: PPUSH
137338: CALL_OW 247
137342: PUSH
137343: LD_INT 1
137345: EQUAL
137346: IFFALSE 137392
// begin to_heal := to_heal diff group [ i ] ;
137348: LD_ADDR_VAR 0 30
137352: PUSH
137353: LD_VAR 0 30
137357: PUSH
137358: LD_VAR 0 4
137362: PUSH
137363: LD_VAR 0 7
137367: ARRAY
137368: DIFF
137369: ST_TO_ADDR
// healers := healers diff group [ i ] ;
137370: LD_ADDR_VAR 0 31
137374: PUSH
137375: LD_VAR 0 31
137379: PUSH
137380: LD_VAR 0 4
137384: PUSH
137385: LD_VAR 0 7
137389: ARRAY
137390: DIFF
137391: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
137392: LD_ADDR_VAR 0 4
137396: PUSH
137397: LD_VAR 0 4
137401: PPUSH
137402: LD_VAR 0 7
137406: PPUSH
137407: CALL_OW 3
137411: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
137412: LD_ADDR_VAR 0 16
137416: PUSH
137417: LD_VAR 0 16
137421: PPUSH
137422: LD_VAR 0 7
137426: PPUSH
137427: CALL_OW 3
137431: ST_TO_ADDR
// continue ;
137432: GO 137270
// end ; if f_repair then
137434: LD_VAR 0 22
137438: IFFALSE 137935
// begin if GetType ( group [ i ] ) = unit_vehicle then
137440: LD_VAR 0 4
137444: PUSH
137445: LD_VAR 0 7
137449: ARRAY
137450: PPUSH
137451: CALL_OW 247
137455: PUSH
137456: LD_INT 2
137458: EQUAL
137459: IFFALSE 137653
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
137461: LD_VAR 0 4
137465: PUSH
137466: LD_VAR 0 7
137470: ARRAY
137471: PPUSH
137472: CALL_OW 256
137476: PUSH
137477: LD_INT 700
137479: LESS
137480: IFFALSE 137501
137482: PUSH
137483: LD_VAR 0 4
137487: PUSH
137488: LD_VAR 0 7
137492: ARRAY
137493: PUSH
137494: LD_VAR 0 32
137498: IN
137499: NOT
137500: AND
137501: IFFALSE 137525
// to_repair := to_repair union group [ i ] ;
137503: LD_ADDR_VAR 0 32
137507: PUSH
137508: LD_VAR 0 32
137512: PUSH
137513: LD_VAR 0 4
137517: PUSH
137518: LD_VAR 0 7
137522: ARRAY
137523: UNION
137524: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
137525: LD_VAR 0 4
137529: PUSH
137530: LD_VAR 0 7
137534: ARRAY
137535: PPUSH
137536: CALL_OW 256
137540: PUSH
137541: LD_INT 1000
137543: EQUAL
137544: IFFALSE 137564
137546: PUSH
137547: LD_VAR 0 4
137551: PUSH
137552: LD_VAR 0 7
137556: ARRAY
137557: PUSH
137558: LD_VAR 0 32
137562: IN
137563: AND
137564: IFFALSE 137588
// to_repair := to_repair diff group [ i ] ;
137566: LD_ADDR_VAR 0 32
137570: PUSH
137571: LD_VAR 0 32
137575: PUSH
137576: LD_VAR 0 4
137580: PUSH
137581: LD_VAR 0 7
137585: ARRAY
137586: DIFF
137587: ST_TO_ADDR
// if group [ i ] in to_repair then
137588: LD_VAR 0 4
137592: PUSH
137593: LD_VAR 0 7
137597: ARRAY
137598: PUSH
137599: LD_VAR 0 32
137603: IN
137604: IFFALSE 137651
// begin if not IsInArea ( group [ i ] , f_repair ) then
137606: LD_VAR 0 4
137610: PUSH
137611: LD_VAR 0 7
137615: ARRAY
137616: PPUSH
137617: LD_VAR 0 22
137621: PPUSH
137622: CALL_OW 308
137626: NOT
137627: IFFALSE 137649
// ComMoveToArea ( group [ i ] , f_repair ) ;
137629: LD_VAR 0 4
137633: PUSH
137634: LD_VAR 0 7
137638: ARRAY
137639: PPUSH
137640: LD_VAR 0 22
137644: PPUSH
137645: CALL_OW 113
// continue ;
137649: GO 137270
// end ; end else
137651: GO 137935
// if group [ i ] in repairs then
137653: LD_VAR 0 4
137657: PUSH
137658: LD_VAR 0 7
137662: ARRAY
137663: PUSH
137664: LD_VAR 0 33
137668: IN
137669: IFFALSE 137935
// begin if IsInUnit ( group [ i ] ) then
137671: LD_VAR 0 4
137675: PUSH
137676: LD_VAR 0 7
137680: ARRAY
137681: PPUSH
137682: CALL_OW 310
137686: IFFALSE 137756
// begin z := IsInUnit ( group [ i ] ) ;
137688: LD_ADDR_VAR 0 13
137692: PUSH
137693: LD_VAR 0 4
137697: PUSH
137698: LD_VAR 0 7
137702: ARRAY
137703: PPUSH
137704: CALL_OW 310
137708: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
137709: LD_VAR 0 13
137713: PUSH
137714: LD_VAR 0 32
137718: IN
137719: IFFALSE 137737
137721: PUSH
137722: LD_VAR 0 13
137726: PPUSH
137727: LD_VAR 0 22
137731: PPUSH
137732: CALL_OW 308
137736: AND
137737: IFFALSE 137754
// ComExitVehicle ( group [ i ] ) ;
137739: LD_VAR 0 4
137743: PUSH
137744: LD_VAR 0 7
137748: ARRAY
137749: PPUSH
137750: CALL_OW 121
// end else
137754: GO 137935
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
137756: LD_ADDR_VAR 0 13
137760: PUSH
137761: LD_VAR 0 4
137765: PPUSH
137766: LD_INT 95
137768: PUSH
137769: LD_VAR 0 22
137773: PUSH
137774: EMPTY
137775: LIST
137776: LIST
137777: PUSH
137778: LD_INT 58
137780: PUSH
137781: EMPTY
137782: LIST
137783: PUSH
137784: EMPTY
137785: LIST
137786: LIST
137787: PPUSH
137788: CALL_OW 72
137792: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
137793: LD_VAR 0 4
137797: PUSH
137798: LD_VAR 0 7
137802: ARRAY
137803: PPUSH
137804: CALL_OW 314
137808: NOT
137809: IFFALSE 137933
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
137811: LD_ADDR_VAR 0 10
137815: PUSH
137816: LD_VAR 0 13
137820: PPUSH
137821: LD_VAR 0 4
137825: PUSH
137826: LD_VAR 0 7
137830: ARRAY
137831: PPUSH
137832: CALL_OW 74
137836: ST_TO_ADDR
// if not x then
137837: LD_VAR 0 10
137841: NOT
137842: IFFALSE 137846
// continue ;
137844: GO 137270
// if GetLives ( x ) < 1000 then
137846: LD_VAR 0 10
137850: PPUSH
137851: CALL_OW 256
137855: PUSH
137856: LD_INT 1000
137858: LESS
137859: IFFALSE 137883
// ComRepairVehicle ( group [ i ] , x ) else
137861: LD_VAR 0 4
137865: PUSH
137866: LD_VAR 0 7
137870: ARRAY
137871: PPUSH
137872: LD_VAR 0 10
137876: PPUSH
137877: CALL_OW 129
137881: GO 137933
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
137883: LD_VAR 0 23
137887: IFFALSE 137910
137889: PUSH
137890: LD_VAR 0 4
137894: PUSH
137895: LD_VAR 0 7
137899: ARRAY
137900: PPUSH
137901: CALL_OW 256
137905: PUSH
137906: LD_INT 1000
137908: LESS
137909: AND
137910: NOT
137911: IFFALSE 137933
// ComEnterUnit ( group [ i ] , x ) ;
137913: LD_VAR 0 4
137917: PUSH
137918: LD_VAR 0 7
137922: ARRAY
137923: PPUSH
137924: LD_VAR 0 10
137928: PPUSH
137929: CALL_OW 120
// end ; continue ;
137933: GO 137270
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
137935: LD_VAR 0 23
137939: IFFALSE 137962
137941: PUSH
137942: LD_VAR 0 4
137946: PUSH
137947: LD_VAR 0 7
137951: ARRAY
137952: PPUSH
137953: CALL_OW 247
137957: PUSH
137958: LD_INT 1
137960: EQUAL
137961: AND
137962: IFFALSE 138446
// begin if group [ i ] in healers then
137964: LD_VAR 0 4
137968: PUSH
137969: LD_VAR 0 7
137973: ARRAY
137974: PUSH
137975: LD_VAR 0 31
137979: IN
137980: IFFALSE 138257
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
137982: LD_VAR 0 4
137986: PUSH
137987: LD_VAR 0 7
137991: ARRAY
137992: PPUSH
137993: LD_VAR 0 23
137997: PPUSH
137998: CALL_OW 308
138002: NOT
138003: IFFALSE 138023
138005: PUSH
138006: LD_VAR 0 4
138010: PUSH
138011: LD_VAR 0 7
138015: ARRAY
138016: PPUSH
138017: CALL_OW 314
138021: NOT
138022: AND
138023: IFFALSE 138047
// ComMoveToArea ( group [ i ] , f_heal ) else
138025: LD_VAR 0 4
138029: PUSH
138030: LD_VAR 0 7
138034: ARRAY
138035: PPUSH
138036: LD_VAR 0 23
138040: PPUSH
138041: CALL_OW 113
138045: GO 138255
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
138047: LD_VAR 0 4
138051: PUSH
138052: LD_VAR 0 7
138056: ARRAY
138057: PPUSH
138058: CALL 106451 0 1
138062: PPUSH
138063: CALL_OW 256
138067: PUSH
138068: LD_INT 1000
138070: EQUAL
138071: IFFALSE 138090
// ComStop ( group [ i ] ) else
138073: LD_VAR 0 4
138077: PUSH
138078: LD_VAR 0 7
138082: ARRAY
138083: PPUSH
138084: CALL_OW 141
138088: GO 138255
// if not HasTask ( group [ i ] ) and to_heal then
138090: LD_VAR 0 4
138094: PUSH
138095: LD_VAR 0 7
138099: ARRAY
138100: PPUSH
138101: CALL_OW 314
138105: NOT
138106: IFFALSE 138114
138108: PUSH
138109: LD_VAR 0 30
138113: AND
138114: IFFALSE 138255
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
138116: LD_ADDR_VAR 0 13
138120: PUSH
138121: LD_VAR 0 30
138125: PPUSH
138126: LD_INT 3
138128: PUSH
138129: LD_INT 54
138131: PUSH
138132: EMPTY
138133: LIST
138134: PUSH
138135: EMPTY
138136: LIST
138137: LIST
138138: PPUSH
138139: CALL_OW 72
138143: PPUSH
138144: LD_VAR 0 4
138148: PUSH
138149: LD_VAR 0 7
138153: ARRAY
138154: PPUSH
138155: CALL_OW 74
138159: ST_TO_ADDR
// if z then
138160: LD_VAR 0 13
138164: IFFALSE 138255
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
138166: LD_INT 91
138168: PUSH
138169: LD_VAR 0 13
138173: PUSH
138174: LD_INT 10
138176: PUSH
138177: EMPTY
138178: LIST
138179: LIST
138180: LIST
138181: PUSH
138182: LD_INT 81
138184: PUSH
138185: LD_VAR 0 13
138189: PPUSH
138190: CALL_OW 255
138194: PUSH
138195: EMPTY
138196: LIST
138197: LIST
138198: PUSH
138199: EMPTY
138200: LIST
138201: LIST
138202: PPUSH
138203: CALL_OW 69
138207: PUSH
138208: LD_INT 0
138210: EQUAL
138211: IFFALSE 138235
// ComHeal ( group [ i ] , z ) else
138213: LD_VAR 0 4
138217: PUSH
138218: LD_VAR 0 7
138222: ARRAY
138223: PPUSH
138224: LD_VAR 0 13
138228: PPUSH
138229: CALL_OW 128
138233: GO 138255
// ComMoveToArea ( group [ i ] , f_heal ) ;
138235: LD_VAR 0 4
138239: PUSH
138240: LD_VAR 0 7
138244: ARRAY
138245: PPUSH
138246: LD_VAR 0 23
138250: PPUSH
138251: CALL_OW 113
// end ; continue ;
138255: GO 137270
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
138257: LD_VAR 0 4
138261: PUSH
138262: LD_VAR 0 7
138266: ARRAY
138267: PPUSH
138268: CALL_OW 256
138272: PUSH
138273: LD_INT 700
138275: LESS
138276: IFFALSE 138297
138278: PUSH
138279: LD_VAR 0 4
138283: PUSH
138284: LD_VAR 0 7
138288: ARRAY
138289: PUSH
138290: LD_VAR 0 30
138294: IN
138295: NOT
138296: AND
138297: IFFALSE 138321
// to_heal := to_heal union group [ i ] ;
138299: LD_ADDR_VAR 0 30
138303: PUSH
138304: LD_VAR 0 30
138308: PUSH
138309: LD_VAR 0 4
138313: PUSH
138314: LD_VAR 0 7
138318: ARRAY
138319: UNION
138320: ST_TO_ADDR
// if group [ i ] in to_heal then
138321: LD_VAR 0 4
138325: PUSH
138326: LD_VAR 0 7
138330: ARRAY
138331: PUSH
138332: LD_VAR 0 30
138336: IN
138337: IFFALSE 138446
// begin if GetLives ( group [ i ] ) = 1000 then
138339: LD_VAR 0 4
138343: PUSH
138344: LD_VAR 0 7
138348: ARRAY
138349: PPUSH
138350: CALL_OW 256
138354: PUSH
138355: LD_INT 1000
138357: EQUAL
138358: IFFALSE 138384
// to_heal := to_heal diff group [ i ] else
138360: LD_ADDR_VAR 0 30
138364: PUSH
138365: LD_VAR 0 30
138369: PUSH
138370: LD_VAR 0 4
138374: PUSH
138375: LD_VAR 0 7
138379: ARRAY
138380: DIFF
138381: ST_TO_ADDR
138382: GO 138446
// begin if not IsInArea ( group [ i ] , to_heal ) then
138384: LD_VAR 0 4
138388: PUSH
138389: LD_VAR 0 7
138393: ARRAY
138394: PPUSH
138395: LD_VAR 0 30
138399: PPUSH
138400: CALL_OW 308
138404: NOT
138405: IFFALSE 138429
// ComMoveToArea ( group [ i ] , f_heal ) else
138407: LD_VAR 0 4
138411: PUSH
138412: LD_VAR 0 7
138416: ARRAY
138417: PPUSH
138418: LD_VAR 0 23
138422: PPUSH
138423: CALL_OW 113
138427: GO 138444
// ComHold ( group [ i ] ) ;
138429: LD_VAR 0 4
138433: PUSH
138434: LD_VAR 0 7
138438: ARRAY
138439: PPUSH
138440: CALL_OW 140
// continue ;
138444: GO 137270
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
138446: LD_VAR 0 4
138450: PUSH
138451: LD_VAR 0 7
138455: ARRAY
138456: PPUSH
138457: LD_INT 10
138459: PPUSH
138460: CALL 104060 0 2
138464: NOT
138465: IFFALSE 138483
138467: PUSH
138468: LD_VAR 0 16
138472: PUSH
138473: LD_VAR 0 7
138477: ARRAY
138478: PUSH
138479: EMPTY
138480: EQUAL
138481: NOT
138482: AND
138483: IFFALSE 138749
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
138485: LD_VAR 0 4
138489: PUSH
138490: LD_VAR 0 7
138494: ARRAY
138495: PPUSH
138496: CALL_OW 262
138500: PUSH
138501: LD_INT 1
138503: PUSH
138504: LD_INT 2
138506: PUSH
138507: EMPTY
138508: LIST
138509: LIST
138510: IN
138511: IFFALSE 138552
// if GetFuel ( group [ i ] ) < 10 then
138513: LD_VAR 0 4
138517: PUSH
138518: LD_VAR 0 7
138522: ARRAY
138523: PPUSH
138524: CALL_OW 261
138528: PUSH
138529: LD_INT 10
138531: LESS
138532: IFFALSE 138552
// SetFuel ( group [ i ] , 12 ) ;
138534: LD_VAR 0 4
138538: PUSH
138539: LD_VAR 0 7
138543: ARRAY
138544: PPUSH
138545: LD_INT 12
138547: PPUSH
138548: CALL_OW 240
// if units_path [ i ] then
138552: LD_VAR 0 16
138556: PUSH
138557: LD_VAR 0 7
138561: ARRAY
138562: IFFALSE 138747
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
138564: LD_VAR 0 4
138568: PUSH
138569: LD_VAR 0 7
138573: ARRAY
138574: PPUSH
138575: LD_VAR 0 16
138579: PUSH
138580: LD_VAR 0 7
138584: ARRAY
138585: PUSH
138586: LD_INT 1
138588: ARRAY
138589: PUSH
138590: LD_INT 1
138592: ARRAY
138593: PPUSH
138594: LD_VAR 0 16
138598: PUSH
138599: LD_VAR 0 7
138603: ARRAY
138604: PUSH
138605: LD_INT 1
138607: ARRAY
138608: PUSH
138609: LD_INT 2
138611: ARRAY
138612: PPUSH
138613: CALL_OW 297
138617: PUSH
138618: LD_INT 6
138620: GREATER
138621: IFFALSE 138696
// begin if not HasTask ( group [ i ] ) then
138623: LD_VAR 0 4
138627: PUSH
138628: LD_VAR 0 7
138632: ARRAY
138633: PPUSH
138634: CALL_OW 314
138638: NOT
138639: IFFALSE 138694
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
138641: LD_VAR 0 4
138645: PUSH
138646: LD_VAR 0 7
138650: ARRAY
138651: PPUSH
138652: LD_VAR 0 16
138656: PUSH
138657: LD_VAR 0 7
138661: ARRAY
138662: PUSH
138663: LD_INT 1
138665: ARRAY
138666: PUSH
138667: LD_INT 1
138669: ARRAY
138670: PPUSH
138671: LD_VAR 0 16
138675: PUSH
138676: LD_VAR 0 7
138680: ARRAY
138681: PUSH
138682: LD_INT 1
138684: ARRAY
138685: PUSH
138686: LD_INT 2
138688: ARRAY
138689: PPUSH
138690: CALL_OW 114
// end else
138694: GO 138747
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
138696: LD_ADDR_VAR 0 15
138700: PUSH
138701: LD_VAR 0 16
138705: PUSH
138706: LD_VAR 0 7
138710: ARRAY
138711: PPUSH
138712: LD_INT 1
138714: PPUSH
138715: CALL_OW 3
138719: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
138720: LD_ADDR_VAR 0 16
138724: PUSH
138725: LD_VAR 0 16
138729: PPUSH
138730: LD_VAR 0 7
138734: PPUSH
138735: LD_VAR 0 15
138739: PPUSH
138740: CALL_OW 1
138744: ST_TO_ADDR
// continue ;
138745: GO 137270
// end ; end ; end else
138747: GO 141445
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
138749: LD_ADDR_VAR 0 14
138753: PUSH
138754: LD_INT 81
138756: PUSH
138757: LD_VAR 0 4
138761: PUSH
138762: LD_VAR 0 7
138766: ARRAY
138767: PPUSH
138768: CALL_OW 255
138772: PUSH
138773: EMPTY
138774: LIST
138775: LIST
138776: PPUSH
138777: CALL_OW 69
138781: ST_TO_ADDR
// if not tmp then
138782: LD_VAR 0 14
138786: NOT
138787: IFFALSE 138791
// continue ;
138789: GO 137270
// if f_ignore_area then
138791: LD_VAR 0 17
138795: IFFALSE 138883
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
138797: LD_ADDR_VAR 0 15
138801: PUSH
138802: LD_VAR 0 14
138806: PPUSH
138807: LD_INT 3
138809: PUSH
138810: LD_INT 92
138812: PUSH
138813: LD_VAR 0 17
138817: PUSH
138818: LD_INT 1
138820: ARRAY
138821: PUSH
138822: LD_VAR 0 17
138826: PUSH
138827: LD_INT 2
138829: ARRAY
138830: PUSH
138831: LD_VAR 0 17
138835: PUSH
138836: LD_INT 3
138838: ARRAY
138839: PUSH
138840: EMPTY
138841: LIST
138842: LIST
138843: LIST
138844: LIST
138845: PUSH
138846: EMPTY
138847: LIST
138848: LIST
138849: PPUSH
138850: CALL_OW 72
138854: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
138855: LD_VAR 0 14
138859: PUSH
138860: LD_VAR 0 15
138864: DIFF
138865: IFFALSE 138883
// tmp := tmp diff tmp2 ;
138867: LD_ADDR_VAR 0 14
138871: PUSH
138872: LD_VAR 0 14
138876: PUSH
138877: LD_VAR 0 15
138881: DIFF
138882: ST_TO_ADDR
// end ; if not f_murder then
138883: LD_VAR 0 20
138887: NOT
138888: IFFALSE 138946
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
138890: LD_ADDR_VAR 0 15
138894: PUSH
138895: LD_VAR 0 14
138899: PPUSH
138900: LD_INT 3
138902: PUSH
138903: LD_INT 50
138905: PUSH
138906: EMPTY
138907: LIST
138908: PUSH
138909: EMPTY
138910: LIST
138911: LIST
138912: PPUSH
138913: CALL_OW 72
138917: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
138918: LD_VAR 0 14
138922: PUSH
138923: LD_VAR 0 15
138927: DIFF
138928: IFFALSE 138946
// tmp := tmp diff tmp2 ;
138930: LD_ADDR_VAR 0 14
138934: PUSH
138935: LD_VAR 0 14
138939: PUSH
138940: LD_VAR 0 15
138944: DIFF
138945: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
138946: LD_ADDR_VAR 0 14
138950: PUSH
138951: LD_VAR 0 4
138955: PUSH
138956: LD_VAR 0 7
138960: ARRAY
138961: PPUSH
138962: LD_VAR 0 14
138966: PPUSH
138967: LD_INT 1
138969: PPUSH
138970: LD_INT 1
138972: PPUSH
138973: CALL 76482 0 4
138977: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
138978: LD_VAR 0 4
138982: PUSH
138983: LD_VAR 0 7
138987: ARRAY
138988: PPUSH
138989: CALL_OW 257
138993: PUSH
138994: LD_INT 1
138996: EQUAL
138997: IFFALSE 139457
// begin if WantPlant ( group [ i ] ) then
138999: LD_VAR 0 4
139003: PUSH
139004: LD_VAR 0 7
139008: ARRAY
139009: PPUSH
139010: CALL 75983 0 1
139014: IFFALSE 139018
// continue ;
139016: GO 137270
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
139018: LD_VAR 0 18
139022: IFFALSE 139042
139024: PUSH
139025: LD_VAR 0 4
139029: PUSH
139030: LD_VAR 0 7
139034: ARRAY
139035: PPUSH
139036: CALL_OW 310
139040: NOT
139041: AND
139042: IFFALSE 139085
139044: PUSH
139045: LD_VAR 0 14
139049: PUSH
139050: LD_INT 1
139052: ARRAY
139053: PUSH
139054: LD_VAR 0 14
139058: PPUSH
139059: LD_INT 21
139061: PUSH
139062: LD_INT 2
139064: PUSH
139065: EMPTY
139066: LIST
139067: LIST
139068: PUSH
139069: LD_INT 58
139071: PUSH
139072: EMPTY
139073: LIST
139074: PUSH
139075: EMPTY
139076: LIST
139077: LIST
139078: PPUSH
139079: CALL_OW 72
139083: IN
139084: AND
139085: IFFALSE 139121
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
139087: LD_VAR 0 4
139091: PUSH
139092: LD_VAR 0 7
139096: ARRAY
139097: PPUSH
139098: LD_VAR 0 14
139102: PUSH
139103: LD_INT 1
139105: ARRAY
139106: PPUSH
139107: CALL_OW 120
// attacking := true ;
139111: LD_ADDR_VAR 0 29
139115: PUSH
139116: LD_INT 1
139118: ST_TO_ADDR
// continue ;
139119: GO 137270
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
139121: LD_VAR 0 26
139125: IFFALSE 139148
139127: PUSH
139128: LD_VAR 0 4
139132: PUSH
139133: LD_VAR 0 7
139137: ARRAY
139138: PPUSH
139139: CALL_OW 257
139143: PUSH
139144: LD_INT 1
139146: EQUAL
139147: AND
139148: IFFALSE 139171
139150: PUSH
139151: LD_VAR 0 4
139155: PUSH
139156: LD_VAR 0 7
139160: ARRAY
139161: PPUSH
139162: CALL_OW 256
139166: PUSH
139167: LD_INT 800
139169: LESS
139170: AND
139171: IFFALSE 139191
139173: PUSH
139174: LD_VAR 0 4
139178: PUSH
139179: LD_VAR 0 7
139183: ARRAY
139184: PPUSH
139185: CALL_OW 318
139189: NOT
139190: AND
139191: IFFALSE 139208
// ComCrawl ( group [ i ] ) ;
139193: LD_VAR 0 4
139197: PUSH
139198: LD_VAR 0 7
139202: ARRAY
139203: PPUSH
139204: CALL_OW 137
// if f_mines then
139208: LD_VAR 0 21
139212: IFFALSE 139457
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
139214: LD_VAR 0 14
139218: PUSH
139219: LD_INT 1
139221: ARRAY
139222: PPUSH
139223: CALL_OW 247
139227: PUSH
139228: LD_INT 3
139230: EQUAL
139231: IFFALSE 139250
139233: PUSH
139234: LD_VAR 0 14
139238: PUSH
139239: LD_INT 1
139241: ARRAY
139242: PUSH
139243: LD_VAR 0 27
139247: IN
139248: NOT
139249: AND
139250: IFFALSE 139457
// begin x := GetX ( tmp [ 1 ] ) ;
139252: LD_ADDR_VAR 0 10
139256: PUSH
139257: LD_VAR 0 14
139261: PUSH
139262: LD_INT 1
139264: ARRAY
139265: PPUSH
139266: CALL_OW 250
139270: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
139271: LD_ADDR_VAR 0 11
139275: PUSH
139276: LD_VAR 0 14
139280: PUSH
139281: LD_INT 1
139283: ARRAY
139284: PPUSH
139285: CALL_OW 251
139289: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
139290: LD_ADDR_VAR 0 12
139294: PUSH
139295: LD_VAR 0 4
139299: PUSH
139300: LD_VAR 0 7
139304: ARRAY
139305: PPUSH
139306: CALL 104145 0 1
139310: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
139311: LD_VAR 0 4
139315: PUSH
139316: LD_VAR 0 7
139320: ARRAY
139321: PPUSH
139322: LD_VAR 0 10
139326: PPUSH
139327: LD_VAR 0 11
139331: PPUSH
139332: LD_VAR 0 14
139336: PUSH
139337: LD_INT 1
139339: ARRAY
139340: PPUSH
139341: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
139345: LD_VAR 0 4
139349: PUSH
139350: LD_VAR 0 7
139354: ARRAY
139355: PPUSH
139356: LD_VAR 0 10
139360: PPUSH
139361: LD_VAR 0 12
139365: PPUSH
139366: LD_INT 7
139368: PPUSH
139369: CALL_OW 272
139373: PPUSH
139374: LD_VAR 0 11
139378: PPUSH
139379: LD_VAR 0 12
139383: PPUSH
139384: LD_INT 7
139386: PPUSH
139387: CALL_OW 273
139391: PPUSH
139392: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
139396: LD_VAR 0 4
139400: PUSH
139401: LD_VAR 0 7
139405: ARRAY
139406: PPUSH
139407: LD_INT 71
139409: PPUSH
139410: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
139414: LD_ADDR_VAR 0 27
139418: PUSH
139419: LD_VAR 0 27
139423: PPUSH
139424: LD_VAR 0 27
139428: PUSH
139429: LD_INT 1
139431: PLUS
139432: PPUSH
139433: LD_VAR 0 14
139437: PUSH
139438: LD_INT 1
139440: ARRAY
139441: PPUSH
139442: CALL_OW 1
139446: ST_TO_ADDR
// attacking := true ;
139447: LD_ADDR_VAR 0 29
139451: PUSH
139452: LD_INT 1
139454: ST_TO_ADDR
// continue ;
139455: GO 137270
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
139457: LD_VAR 0 4
139461: PUSH
139462: LD_VAR 0 7
139466: ARRAY
139467: PPUSH
139468: CALL_OW 257
139472: PUSH
139473: LD_INT 17
139475: EQUAL
139476: IFFALSE 139500
139478: PUSH
139479: LD_VAR 0 4
139483: PUSH
139484: LD_VAR 0 7
139488: ARRAY
139489: PPUSH
139490: CALL_OW 110
139494: PUSH
139495: LD_INT 71
139497: EQUAL
139498: NOT
139499: AND
139500: IFFALSE 139646
// begin attacking := false ;
139502: LD_ADDR_VAR 0 29
139506: PUSH
139507: LD_INT 0
139509: ST_TO_ADDR
// k := 5 ;
139510: LD_ADDR_VAR 0 9
139514: PUSH
139515: LD_INT 5
139517: ST_TO_ADDR
// if tmp < k then
139518: LD_VAR 0 14
139522: PUSH
139523: LD_VAR 0 9
139527: LESS
139528: IFFALSE 139540
// k := tmp ;
139530: LD_ADDR_VAR 0 9
139534: PUSH
139535: LD_VAR 0 14
139539: ST_TO_ADDR
// for j = 1 to k do
139540: LD_ADDR_VAR 0 8
139544: PUSH
139545: DOUBLE
139546: LD_INT 1
139548: DEC
139549: ST_TO_ADDR
139550: LD_VAR 0 9
139554: PUSH
139555: FOR_TO
139556: IFFALSE 139644
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
139558: LD_VAR 0 14
139562: PUSH
139563: LD_VAR 0 8
139567: ARRAY
139568: PUSH
139569: LD_VAR 0 14
139573: PPUSH
139574: LD_INT 58
139576: PUSH
139577: EMPTY
139578: LIST
139579: PPUSH
139580: CALL_OW 72
139584: IN
139585: NOT
139586: IFFALSE 139642
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
139588: LD_VAR 0 4
139592: PUSH
139593: LD_VAR 0 7
139597: ARRAY
139598: PPUSH
139599: LD_VAR 0 14
139603: PUSH
139604: LD_VAR 0 8
139608: ARRAY
139609: PPUSH
139610: CALL_OW 115
// attacking := true ;
139614: LD_ADDR_VAR 0 29
139618: PUSH
139619: LD_INT 1
139621: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
139622: LD_VAR 0 4
139626: PUSH
139627: LD_VAR 0 7
139631: ARRAY
139632: PPUSH
139633: LD_INT 71
139635: PPUSH
139636: CALL_OW 109
// continue ;
139640: GO 139555
// end ; end ;
139642: GO 139555
139644: POP
139645: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
139646: LD_VAR 0 4
139650: PUSH
139651: LD_VAR 0 7
139655: ARRAY
139656: PPUSH
139657: CALL_OW 257
139661: PUSH
139662: LD_INT 8
139664: EQUAL
139665: IFTRUE 139703
139667: PUSH
139668: LD_VAR 0 4
139672: PUSH
139673: LD_VAR 0 7
139677: ARRAY
139678: PPUSH
139679: CALL_OW 264
139683: PUSH
139684: LD_INT 28
139686: PUSH
139687: LD_INT 45
139689: PUSH
139690: LD_INT 7
139692: PUSH
139693: LD_INT 47
139695: PUSH
139696: EMPTY
139697: LIST
139698: LIST
139699: LIST
139700: LIST
139701: IN
139702: OR
139703: IFFALSE 139959
// begin attacking := false ;
139705: LD_ADDR_VAR 0 29
139709: PUSH
139710: LD_INT 0
139712: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
139713: LD_VAR 0 14
139717: PUSH
139718: LD_INT 1
139720: ARRAY
139721: PPUSH
139722: CALL_OW 266
139726: PUSH
139727: LD_INT 32
139729: PUSH
139730: LD_INT 31
139732: PUSH
139733: LD_INT 33
139735: PUSH
139736: LD_INT 4
139738: PUSH
139739: LD_INT 5
139741: PUSH
139742: EMPTY
139743: LIST
139744: LIST
139745: LIST
139746: LIST
139747: LIST
139748: IN
139749: IFFALSE 139935
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
139751: LD_ADDR_VAR 0 9
139755: PUSH
139756: LD_VAR 0 14
139760: PUSH
139761: LD_INT 1
139763: ARRAY
139764: PPUSH
139765: CALL_OW 266
139769: PPUSH
139770: LD_VAR 0 14
139774: PUSH
139775: LD_INT 1
139777: ARRAY
139778: PPUSH
139779: CALL_OW 250
139783: PPUSH
139784: LD_VAR 0 14
139788: PUSH
139789: LD_INT 1
139791: ARRAY
139792: PPUSH
139793: CALL_OW 251
139797: PPUSH
139798: LD_VAR 0 14
139802: PUSH
139803: LD_INT 1
139805: ARRAY
139806: PPUSH
139807: CALL_OW 254
139811: PPUSH
139812: LD_VAR 0 14
139816: PUSH
139817: LD_INT 1
139819: ARRAY
139820: PPUSH
139821: CALL_OW 248
139825: PPUSH
139826: LD_INT 0
139828: PPUSH
139829: CALL 85503 0 6
139833: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
139834: LD_ADDR_VAR 0 8
139838: PUSH
139839: LD_VAR 0 4
139843: PUSH
139844: LD_VAR 0 7
139848: ARRAY
139849: PPUSH
139850: LD_VAR 0 9
139854: PPUSH
139855: CALL 104258 0 2
139859: ST_TO_ADDR
// if j then
139860: LD_VAR 0 8
139864: IFFALSE 139933
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
139866: LD_VAR 0 8
139870: PUSH
139871: LD_INT 1
139873: ARRAY
139874: PPUSH
139875: LD_VAR 0 8
139879: PUSH
139880: LD_INT 2
139882: ARRAY
139883: PPUSH
139884: CALL_OW 488
139888: IFFALSE 139933
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
139890: LD_VAR 0 4
139894: PUSH
139895: LD_VAR 0 7
139899: ARRAY
139900: PPUSH
139901: LD_VAR 0 8
139905: PUSH
139906: LD_INT 1
139908: ARRAY
139909: PPUSH
139910: LD_VAR 0 8
139914: PUSH
139915: LD_INT 2
139917: ARRAY
139918: PPUSH
139919: CALL_OW 116
// attacking := true ;
139923: LD_ADDR_VAR 0 29
139927: PUSH
139928: LD_INT 1
139930: ST_TO_ADDR
// continue ;
139931: GO 137270
// end ; end else
139933: GO 139959
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139935: LD_VAR 0 4
139939: PUSH
139940: LD_VAR 0 7
139944: ARRAY
139945: PPUSH
139946: LD_VAR 0 14
139950: PUSH
139951: LD_INT 1
139953: ARRAY
139954: PPUSH
139955: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
139959: LD_VAR 0 4
139963: PUSH
139964: LD_VAR 0 7
139968: ARRAY
139969: PPUSH
139970: CALL_OW 265
139974: PUSH
139975: LD_INT 11
139977: EQUAL
139978: IFFALSE 140256
// begin k := 10 ;
139980: LD_ADDR_VAR 0 9
139984: PUSH
139985: LD_INT 10
139987: ST_TO_ADDR
// x := 0 ;
139988: LD_ADDR_VAR 0 10
139992: PUSH
139993: LD_INT 0
139995: ST_TO_ADDR
// if tmp < k then
139996: LD_VAR 0 14
140000: PUSH
140001: LD_VAR 0 9
140005: LESS
140006: IFFALSE 140018
// k := tmp ;
140008: LD_ADDR_VAR 0 9
140012: PUSH
140013: LD_VAR 0 14
140017: ST_TO_ADDR
// for j = k downto 1 do
140018: LD_ADDR_VAR 0 8
140022: PUSH
140023: DOUBLE
140024: LD_VAR 0 9
140028: INC
140029: ST_TO_ADDR
140030: LD_INT 1
140032: PUSH
140033: FOR_DOWNTO
140034: IFFALSE 140109
// begin if GetType ( tmp [ j ] ) = unit_human then
140036: LD_VAR 0 14
140040: PUSH
140041: LD_VAR 0 8
140045: ARRAY
140046: PPUSH
140047: CALL_OW 247
140051: PUSH
140052: LD_INT 1
140054: EQUAL
140055: IFFALSE 140107
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
140057: LD_VAR 0 4
140061: PUSH
140062: LD_VAR 0 7
140066: ARRAY
140067: PPUSH
140068: LD_VAR 0 14
140072: PUSH
140073: LD_VAR 0 8
140077: ARRAY
140078: PPUSH
140079: CALL 104516 0 2
// x := tmp [ j ] ;
140083: LD_ADDR_VAR 0 10
140087: PUSH
140088: LD_VAR 0 14
140092: PUSH
140093: LD_VAR 0 8
140097: ARRAY
140098: ST_TO_ADDR
// attacking := true ;
140099: LD_ADDR_VAR 0 29
140103: PUSH
140104: LD_INT 1
140106: ST_TO_ADDR
// end ; end ;
140107: GO 140033
140109: POP
140110: POP
// if not x then
140111: LD_VAR 0 10
140115: NOT
140116: IFFALSE 140256
// begin attacking := true ;
140118: LD_ADDR_VAR 0 29
140122: PUSH
140123: LD_INT 1
140125: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
140126: LD_VAR 0 4
140130: PUSH
140131: LD_VAR 0 7
140135: ARRAY
140136: PPUSH
140137: CALL_OW 250
140141: PPUSH
140142: LD_VAR 0 4
140146: PUSH
140147: LD_VAR 0 7
140151: ARRAY
140152: PPUSH
140153: CALL_OW 251
140157: PPUSH
140158: CALL_OW 546
140162: PUSH
140163: LD_INT 2
140165: ARRAY
140166: PUSH
140167: LD_VAR 0 14
140171: PUSH
140172: LD_INT 1
140174: ARRAY
140175: PPUSH
140176: CALL_OW 250
140180: PPUSH
140181: LD_VAR 0 14
140185: PUSH
140186: LD_INT 1
140188: ARRAY
140189: PPUSH
140190: CALL_OW 251
140194: PPUSH
140195: CALL_OW 546
140199: PUSH
140200: LD_INT 2
140202: ARRAY
140203: EQUAL
140204: IFFALSE 140232
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
140206: LD_VAR 0 4
140210: PUSH
140211: LD_VAR 0 7
140215: ARRAY
140216: PPUSH
140217: LD_VAR 0 14
140221: PUSH
140222: LD_INT 1
140224: ARRAY
140225: PPUSH
140226: CALL 104516 0 2
140230: GO 140256
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140232: LD_VAR 0 4
140236: PUSH
140237: LD_VAR 0 7
140241: ARRAY
140242: PPUSH
140243: LD_VAR 0 14
140247: PUSH
140248: LD_INT 1
140250: ARRAY
140251: PPUSH
140252: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
140256: LD_VAR 0 4
140260: PUSH
140261: LD_VAR 0 7
140265: ARRAY
140266: PPUSH
140267: CALL_OW 264
140271: PUSH
140272: LD_INT 29
140274: EQUAL
140275: IFFALSE 140645
// begin if WantsToAttack ( group [ i ] ) in bombed then
140277: LD_VAR 0 4
140281: PUSH
140282: LD_VAR 0 7
140286: ARRAY
140287: PPUSH
140288: CALL_OW 319
140292: PUSH
140293: LD_VAR 0 28
140297: IN
140298: IFFALSE 140302
// continue ;
140300: GO 137270
// k := 8 ;
140302: LD_ADDR_VAR 0 9
140306: PUSH
140307: LD_INT 8
140309: ST_TO_ADDR
// x := 0 ;
140310: LD_ADDR_VAR 0 10
140314: PUSH
140315: LD_INT 0
140317: ST_TO_ADDR
// if tmp < k then
140318: LD_VAR 0 14
140322: PUSH
140323: LD_VAR 0 9
140327: LESS
140328: IFFALSE 140340
// k := tmp ;
140330: LD_ADDR_VAR 0 9
140334: PUSH
140335: LD_VAR 0 14
140339: ST_TO_ADDR
// for j = 1 to k do
140340: LD_ADDR_VAR 0 8
140344: PUSH
140345: DOUBLE
140346: LD_INT 1
140348: DEC
140349: ST_TO_ADDR
140350: LD_VAR 0 9
140354: PUSH
140355: FOR_TO
140356: IFFALSE 140490
// begin if GetType ( tmp [ j ] ) = unit_building then
140358: LD_VAR 0 14
140362: PUSH
140363: LD_VAR 0 8
140367: ARRAY
140368: PPUSH
140369: CALL_OW 247
140373: PUSH
140374: LD_INT 3
140376: EQUAL
140377: IFFALSE 140488
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
140379: LD_VAR 0 14
140383: PUSH
140384: LD_VAR 0 8
140388: ARRAY
140389: PUSH
140390: LD_VAR 0 28
140394: IN
140395: NOT
140396: IFFALSE 140415
140398: PUSH
140399: LD_VAR 0 14
140403: PUSH
140404: LD_VAR 0 8
140408: ARRAY
140409: PPUSH
140410: CALL_OW 313
140414: AND
140415: IFFALSE 140488
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
140417: LD_VAR 0 4
140421: PUSH
140422: LD_VAR 0 7
140426: ARRAY
140427: PPUSH
140428: LD_VAR 0 14
140432: PUSH
140433: LD_VAR 0 8
140437: ARRAY
140438: PPUSH
140439: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
140443: LD_ADDR_VAR 0 28
140447: PUSH
140448: LD_VAR 0 28
140452: PPUSH
140453: LD_VAR 0 28
140457: PUSH
140458: LD_INT 1
140460: PLUS
140461: PPUSH
140462: LD_VAR 0 14
140466: PUSH
140467: LD_VAR 0 8
140471: ARRAY
140472: PPUSH
140473: CALL_OW 1
140477: ST_TO_ADDR
// attacking := true ;
140478: LD_ADDR_VAR 0 29
140482: PUSH
140483: LD_INT 1
140485: ST_TO_ADDR
// break ;
140486: GO 140490
// end ; end ;
140488: GO 140355
140490: POP
140491: POP
// if not attacking and f_attack_depot then
140492: LD_VAR 0 29
140496: NOT
140497: IFFALSE 140505
140499: PUSH
140500: LD_VAR 0 25
140504: AND
140505: IFFALSE 140600
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
140507: LD_ADDR_VAR 0 13
140511: PUSH
140512: LD_VAR 0 14
140516: PPUSH
140517: LD_INT 2
140519: PUSH
140520: LD_INT 30
140522: PUSH
140523: LD_INT 0
140525: PUSH
140526: EMPTY
140527: LIST
140528: LIST
140529: PUSH
140530: LD_INT 30
140532: PUSH
140533: LD_INT 1
140535: PUSH
140536: EMPTY
140537: LIST
140538: LIST
140539: PUSH
140540: EMPTY
140541: LIST
140542: LIST
140543: LIST
140544: PPUSH
140545: CALL_OW 72
140549: ST_TO_ADDR
// if z then
140550: LD_VAR 0 13
140554: IFFALSE 140600
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
140556: LD_VAR 0 4
140560: PUSH
140561: LD_VAR 0 7
140565: ARRAY
140566: PPUSH
140567: LD_VAR 0 13
140571: PPUSH
140572: LD_VAR 0 4
140576: PUSH
140577: LD_VAR 0 7
140581: ARRAY
140582: PPUSH
140583: CALL_OW 74
140587: PPUSH
140588: CALL_OW 115
// attacking := true ;
140592: LD_ADDR_VAR 0 29
140596: PUSH
140597: LD_INT 1
140599: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
140600: LD_VAR 0 4
140604: PUSH
140605: LD_VAR 0 7
140609: ARRAY
140610: PPUSH
140611: CALL_OW 256
140615: PUSH
140616: LD_INT 500
140618: LESS
140619: IFFALSE 140645
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140621: LD_VAR 0 4
140625: PUSH
140626: LD_VAR 0 7
140630: ARRAY
140631: PPUSH
140632: LD_VAR 0 14
140636: PUSH
140637: LD_INT 1
140639: ARRAY
140640: PPUSH
140641: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
140645: LD_VAR 0 4
140649: PUSH
140650: LD_VAR 0 7
140654: ARRAY
140655: PPUSH
140656: CALL_OW 264
140660: PUSH
140661: LD_INT 49
140663: EQUAL
140664: IFFALSE 140785
// begin if not HasTask ( group [ i ] ) then
140666: LD_VAR 0 4
140670: PUSH
140671: LD_VAR 0 7
140675: ARRAY
140676: PPUSH
140677: CALL_OW 314
140681: NOT
140682: IFFALSE 140785
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
140684: LD_ADDR_VAR 0 9
140688: PUSH
140689: LD_INT 81
140691: PUSH
140692: LD_VAR 0 4
140696: PUSH
140697: LD_VAR 0 7
140701: ARRAY
140702: PPUSH
140703: CALL_OW 255
140707: PUSH
140708: EMPTY
140709: LIST
140710: LIST
140711: PPUSH
140712: CALL_OW 69
140716: PPUSH
140717: LD_VAR 0 4
140721: PUSH
140722: LD_VAR 0 7
140726: ARRAY
140727: PPUSH
140728: CALL_OW 74
140732: ST_TO_ADDR
// if k then
140733: LD_VAR 0 9
140737: IFFALSE 140785
// if GetDistUnits ( group [ i ] , k ) > 10 then
140739: LD_VAR 0 4
140743: PUSH
140744: LD_VAR 0 7
140748: ARRAY
140749: PPUSH
140750: LD_VAR 0 9
140754: PPUSH
140755: CALL_OW 296
140759: PUSH
140760: LD_INT 10
140762: GREATER
140763: IFFALSE 140785
// ComMoveUnit ( group [ i ] , k ) ;
140765: LD_VAR 0 4
140769: PUSH
140770: LD_VAR 0 7
140774: ARRAY
140775: PPUSH
140776: LD_VAR 0 9
140780: PPUSH
140781: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
140785: LD_VAR 0 4
140789: PUSH
140790: LD_VAR 0 7
140794: ARRAY
140795: PPUSH
140796: CALL_OW 256
140800: PUSH
140801: LD_INT 250
140803: LESS
140804: IFFALSE 140848
140806: PUSH
140807: LD_VAR 0 4
140811: PUSH
140812: LD_VAR 0 7
140816: ARRAY
140817: PUSH
140818: LD_INT 21
140820: PUSH
140821: LD_INT 2
140823: PUSH
140824: EMPTY
140825: LIST
140826: LIST
140827: PUSH
140828: LD_INT 23
140830: PUSH
140831: LD_INT 2
140833: PUSH
140834: EMPTY
140835: LIST
140836: LIST
140837: PUSH
140838: EMPTY
140839: LIST
140840: LIST
140841: PPUSH
140842: CALL_OW 69
140846: IN
140847: AND
140848: IFFALSE 140975
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
140850: LD_ADDR_VAR 0 9
140854: PUSH
140855: LD_OWVAR 3
140859: PUSH
140860: LD_VAR 0 4
140864: PUSH
140865: LD_VAR 0 7
140869: ARRAY
140870: DIFF
140871: PPUSH
140872: LD_VAR 0 4
140876: PUSH
140877: LD_VAR 0 7
140881: ARRAY
140882: PPUSH
140883: CALL_OW 74
140887: ST_TO_ADDR
// if not k then
140888: LD_VAR 0 9
140892: NOT
140893: IFFALSE 140897
// continue ;
140895: GO 137270
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
140897: LD_VAR 0 9
140901: PUSH
140902: LD_INT 81
140904: PUSH
140905: LD_VAR 0 4
140909: PUSH
140910: LD_VAR 0 7
140914: ARRAY
140915: PPUSH
140916: CALL_OW 255
140920: PUSH
140921: EMPTY
140922: LIST
140923: LIST
140924: PPUSH
140925: CALL_OW 69
140929: IN
140930: IFFALSE 140958
140932: PUSH
140933: LD_VAR 0 9
140937: PPUSH
140938: LD_VAR 0 4
140942: PUSH
140943: LD_VAR 0 7
140947: ARRAY
140948: PPUSH
140949: CALL_OW 296
140953: PUSH
140954: LD_INT 5
140956: LESS
140957: AND
140958: IFFALSE 140975
// ComAutodestruct ( group [ i ] ) ;
140960: LD_VAR 0 4
140964: PUSH
140965: LD_VAR 0 7
140969: ARRAY
140970: PPUSH
140971: CALL 104412 0 1
// end ; if f_attack_depot then
140975: LD_VAR 0 25
140979: IFFALSE 141091
// begin k := 6 ;
140981: LD_ADDR_VAR 0 9
140985: PUSH
140986: LD_INT 6
140988: ST_TO_ADDR
// if tmp < k then
140989: LD_VAR 0 14
140993: PUSH
140994: LD_VAR 0 9
140998: LESS
140999: IFFALSE 141011
// k := tmp ;
141001: LD_ADDR_VAR 0 9
141005: PUSH
141006: LD_VAR 0 14
141010: ST_TO_ADDR
// for j = 1 to k do
141011: LD_ADDR_VAR 0 8
141015: PUSH
141016: DOUBLE
141017: LD_INT 1
141019: DEC
141020: ST_TO_ADDR
141021: LD_VAR 0 9
141025: PUSH
141026: FOR_TO
141027: IFFALSE 141089
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
141029: LD_VAR 0 8
141033: PPUSH
141034: CALL_OW 266
141038: PUSH
141039: LD_INT 0
141041: PUSH
141042: LD_INT 1
141044: PUSH
141045: EMPTY
141046: LIST
141047: LIST
141048: IN
141049: IFFALSE 141087
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
141051: LD_VAR 0 4
141055: PUSH
141056: LD_VAR 0 7
141060: ARRAY
141061: PPUSH
141062: LD_VAR 0 14
141066: PUSH
141067: LD_VAR 0 8
141071: ARRAY
141072: PPUSH
141073: CALL_OW 115
// attacking := true ;
141077: LD_ADDR_VAR 0 29
141081: PUSH
141082: LD_INT 1
141084: ST_TO_ADDR
// break ;
141085: GO 141089
// end ;
141087: GO 141026
141089: POP
141090: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
141091: LD_VAR 0 4
141095: PUSH
141096: LD_VAR 0 7
141100: ARRAY
141101: PPUSH
141102: CALL_OW 302
141106: IFFALSE 141115
141108: PUSH
141109: LD_VAR 0 29
141113: NOT
141114: AND
141115: IFFALSE 141445
// begin if GetTag ( group [ i ] ) = 71 then
141117: LD_VAR 0 4
141121: PUSH
141122: LD_VAR 0 7
141126: ARRAY
141127: PPUSH
141128: CALL_OW 110
141132: PUSH
141133: LD_INT 71
141135: EQUAL
141136: IFFALSE 141177
// begin if HasTask ( group [ i ] ) then
141138: LD_VAR 0 4
141142: PUSH
141143: LD_VAR 0 7
141147: ARRAY
141148: PPUSH
141149: CALL_OW 314
141153: IFFALSE 141159
// continue else
141155: GO 137270
141157: GO 141177
// SetTag ( group [ i ] , 0 ) ;
141159: LD_VAR 0 4
141163: PUSH
141164: LD_VAR 0 7
141168: ARRAY
141169: PPUSH
141170: LD_INT 0
141172: PPUSH
141173: CALL_OW 109
// end ; k := 8 ;
141177: LD_ADDR_VAR 0 9
141181: PUSH
141182: LD_INT 8
141184: ST_TO_ADDR
// x := 0 ;
141185: LD_ADDR_VAR 0 10
141189: PUSH
141190: LD_INT 0
141192: ST_TO_ADDR
// if tmp < k then
141193: LD_VAR 0 14
141197: PUSH
141198: LD_VAR 0 9
141202: LESS
141203: IFFALSE 141215
// k := tmp ;
141205: LD_ADDR_VAR 0 9
141209: PUSH
141210: LD_VAR 0 14
141214: ST_TO_ADDR
// for j = 1 to k do
141215: LD_ADDR_VAR 0 8
141219: PUSH
141220: DOUBLE
141221: LD_INT 1
141223: DEC
141224: ST_TO_ADDR
141225: LD_VAR 0 9
141229: PUSH
141230: FOR_TO
141231: IFFALSE 141337
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
141233: LD_VAR 0 14
141237: PUSH
141238: LD_VAR 0 8
141242: ARRAY
141243: PPUSH
141244: CALL_OW 247
141248: PUSH
141249: LD_INT 1
141251: EQUAL
141252: IFFALSE 141315
141254: PUSH
141255: LD_VAR 0 14
141259: PUSH
141260: LD_VAR 0 8
141264: ARRAY
141265: PPUSH
141266: CALL_OW 256
141270: PUSH
141271: LD_INT 250
141273: LESS
141274: IFFALSE 141282
141276: PUSH
141277: LD_VAR 0 20
141281: AND
141282: IFTRUE 141314
141284: PUSH
141285: LD_VAR 0 20
141289: NOT
141290: IFFALSE 141313
141292: PUSH
141293: LD_VAR 0 14
141297: PUSH
141298: LD_VAR 0 8
141302: ARRAY
141303: PPUSH
141304: CALL_OW 256
141308: PUSH
141309: LD_INT 250
141311: GREATEREQUAL
141312: AND
141313: OR
141314: AND
141315: IFFALSE 141335
// begin x := tmp [ j ] ;
141317: LD_ADDR_VAR 0 10
141321: PUSH
141322: LD_VAR 0 14
141326: PUSH
141327: LD_VAR 0 8
141331: ARRAY
141332: ST_TO_ADDR
// break ;
141333: GO 141337
// end ;
141335: GO 141230
141337: POP
141338: POP
// if x then
141339: LD_VAR 0 10
141343: IFFALSE 141367
// ComAttackUnit ( group [ i ] , x ) else
141345: LD_VAR 0 4
141349: PUSH
141350: LD_VAR 0 7
141354: ARRAY
141355: PPUSH
141356: LD_VAR 0 10
141360: PPUSH
141361: CALL_OW 115
141365: GO 141391
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
141367: LD_VAR 0 4
141371: PUSH
141372: LD_VAR 0 7
141376: ARRAY
141377: PPUSH
141378: LD_VAR 0 14
141382: PUSH
141383: LD_INT 1
141385: ARRAY
141386: PPUSH
141387: CALL_OW 115
// if not HasTask ( group [ i ] ) then
141391: LD_VAR 0 4
141395: PUSH
141396: LD_VAR 0 7
141400: ARRAY
141401: PPUSH
141402: CALL_OW 314
141406: NOT
141407: IFFALSE 141445
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
141409: LD_VAR 0 4
141413: PUSH
141414: LD_VAR 0 7
141418: ARRAY
141419: PPUSH
141420: LD_VAR 0 14
141424: PPUSH
141425: LD_VAR 0 4
141429: PUSH
141430: LD_VAR 0 7
141434: ARRAY
141435: PPUSH
141436: CALL_OW 74
141440: PPUSH
141441: CALL_OW 115
// end ; end ; end ;
141445: GO 137270
141447: POP
141448: POP
// wait ( 0 0$2 ) ;
141449: LD_INT 70
141451: PPUSH
141452: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
141456: LD_VAR 0 4
141460: NOT
141461: IFTRUE 141472
141463: PUSH
141464: LD_VAR 0 4
141468: PUSH
141469: EMPTY
141470: EQUAL
141471: OR
141472: IFTRUE 141493
141474: PUSH
141475: LD_INT 81
141477: PUSH
141478: LD_VAR 0 35
141482: PUSH
141483: EMPTY
141484: LIST
141485: LIST
141486: PPUSH
141487: CALL_OW 69
141491: NOT
141492: OR
141493: IFFALSE 137255
// end ;
141495: LD_VAR 0 2
141499: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
141500: LD_INT 0
141502: PPUSH
141503: PPUSH
141504: PPUSH
141505: PPUSH
141506: PPUSH
141507: PPUSH
// if not base or not mc_bases [ base ] or not solds then
141508: LD_VAR 0 1
141512: NOT
141513: IFTRUE 141528
141515: PUSH
141516: LD_EXP 102
141520: PUSH
141521: LD_VAR 0 1
141525: ARRAY
141526: NOT
141527: OR
141528: IFTRUE 141537
141530: PUSH
141531: LD_VAR 0 2
141535: NOT
141536: OR
141537: IFFALSE 141541
// exit ;
141539: GO 142099
// side := mc_sides [ base ] ;
141541: LD_ADDR_VAR 0 6
141545: PUSH
141546: LD_EXP 128
141550: PUSH
141551: LD_VAR 0 1
141555: ARRAY
141556: ST_TO_ADDR
// if not side then
141557: LD_VAR 0 6
141561: NOT
141562: IFFALSE 141566
// exit ;
141564: GO 142099
// for i in solds do
141566: LD_ADDR_VAR 0 7
141570: PUSH
141571: LD_VAR 0 2
141575: PUSH
141576: FOR_IN
141577: IFFALSE 141638
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
141579: LD_VAR 0 7
141583: PPUSH
141584: CALL_OW 310
141588: PPUSH
141589: CALL_OW 266
141593: PUSH
141594: LD_INT 32
141596: PUSH
141597: LD_INT 31
141599: PUSH
141600: EMPTY
141601: LIST
141602: LIST
141603: IN
141604: IFFALSE 141624
// solds := solds diff i else
141606: LD_ADDR_VAR 0 2
141610: PUSH
141611: LD_VAR 0 2
141615: PUSH
141616: LD_VAR 0 7
141620: DIFF
141621: ST_TO_ADDR
141622: GO 141636
// SetTag ( i , 18 ) ;
141624: LD_VAR 0 7
141628: PPUSH
141629: LD_INT 18
141631: PPUSH
141632: CALL_OW 109
141636: GO 141576
141638: POP
141639: POP
// if not solds then
141640: LD_VAR 0 2
141644: NOT
141645: IFFALSE 141649
// exit ;
141647: GO 142099
// repeat wait ( 0 0$2 ) ;
141649: LD_INT 70
141651: PPUSH
141652: CALL_OW 67
// enemy := mc_scan [ base ] ;
141656: LD_ADDR_VAR 0 4
141660: PUSH
141661: LD_EXP 125
141665: PUSH
141666: LD_VAR 0 1
141670: ARRAY
141671: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141672: LD_EXP 102
141676: PUSH
141677: LD_VAR 0 1
141681: ARRAY
141682: NOT
141683: IFTRUE 141700
141685: PUSH
141686: LD_EXP 102
141690: PUSH
141691: LD_VAR 0 1
141695: ARRAY
141696: PUSH
141697: EMPTY
141698: EQUAL
141699: OR
141700: IFFALSE 141737
// begin for i in solds do
141702: LD_ADDR_VAR 0 7
141706: PUSH
141707: LD_VAR 0 2
141711: PUSH
141712: FOR_IN
141713: IFFALSE 141726
// ComStop ( i ) ;
141715: LD_VAR 0 7
141719: PPUSH
141720: CALL_OW 141
141724: GO 141712
141726: POP
141727: POP
// solds := [ ] ;
141728: LD_ADDR_VAR 0 2
141732: PUSH
141733: EMPTY
141734: ST_TO_ADDR
// exit ;
141735: GO 142099
// end ; for i in solds do
141737: LD_ADDR_VAR 0 7
141741: PUSH
141742: LD_VAR 0 2
141746: PUSH
141747: FOR_IN
141748: IFFALSE 142069
// begin if IsInUnit ( i ) then
141750: LD_VAR 0 7
141754: PPUSH
141755: CALL_OW 310
141759: IFFALSE 141770
// ComExitBuilding ( i ) ;
141761: LD_VAR 0 7
141765: PPUSH
141766: CALL_OW 122
// if GetLives ( i ) > 500 then
141770: LD_VAR 0 7
141774: PPUSH
141775: CALL_OW 256
141779: PUSH
141780: LD_INT 500
141782: GREATER
141783: IFFALSE 141836
// begin e := NearestUnitToUnit ( enemy , i ) ;
141785: LD_ADDR_VAR 0 5
141789: PUSH
141790: LD_VAR 0 4
141794: PPUSH
141795: LD_VAR 0 7
141799: PPUSH
141800: CALL_OW 74
141804: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
141805: LD_VAR 0 7
141809: PPUSH
141810: LD_VAR 0 5
141814: PPUSH
141815: CALL_OW 250
141819: PPUSH
141820: LD_VAR 0 5
141824: PPUSH
141825: CALL_OW 251
141829: PPUSH
141830: CALL_OW 114
// end else
141834: GO 142067
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
141836: LD_VAR 0 7
141840: PPUSH
141841: LD_EXP 102
141845: PUSH
141846: LD_VAR 0 1
141850: ARRAY
141851: PPUSH
141852: LD_INT 2
141854: PUSH
141855: LD_INT 30
141857: PUSH
141858: LD_INT 0
141860: PUSH
141861: EMPTY
141862: LIST
141863: LIST
141864: PUSH
141865: LD_INT 30
141867: PUSH
141868: LD_INT 1
141870: PUSH
141871: EMPTY
141872: LIST
141873: LIST
141874: PUSH
141875: LD_INT 30
141877: PUSH
141878: LD_INT 6
141880: PUSH
141881: EMPTY
141882: LIST
141883: LIST
141884: PUSH
141885: EMPTY
141886: LIST
141887: LIST
141888: LIST
141889: LIST
141890: PPUSH
141891: CALL_OW 72
141895: PPUSH
141896: LD_VAR 0 7
141900: PPUSH
141901: CALL_OW 74
141905: PPUSH
141906: CALL_OW 296
141910: PUSH
141911: LD_INT 10
141913: GREATER
141914: IFFALSE 142067
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
141916: LD_ADDR_VAR 0 8
141920: PUSH
141921: LD_EXP 102
141925: PUSH
141926: LD_VAR 0 1
141930: ARRAY
141931: PPUSH
141932: LD_INT 2
141934: PUSH
141935: LD_INT 30
141937: PUSH
141938: LD_INT 0
141940: PUSH
141941: EMPTY
141942: LIST
141943: LIST
141944: PUSH
141945: LD_INT 30
141947: PUSH
141948: LD_INT 1
141950: PUSH
141951: EMPTY
141952: LIST
141953: LIST
141954: PUSH
141955: LD_INT 30
141957: PUSH
141958: LD_INT 6
141960: PUSH
141961: EMPTY
141962: LIST
141963: LIST
141964: PUSH
141965: EMPTY
141966: LIST
141967: LIST
141968: LIST
141969: LIST
141970: PPUSH
141971: CALL_OW 72
141975: PPUSH
141976: LD_VAR 0 7
141980: PPUSH
141981: CALL_OW 74
141985: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
141986: LD_VAR 0 7
141990: PPUSH
141991: LD_VAR 0 8
141995: PPUSH
141996: CALL_OW 250
142000: PPUSH
142001: LD_INT 3
142003: PPUSH
142004: LD_INT 5
142006: PPUSH
142007: CALL_OW 272
142011: PPUSH
142012: LD_VAR 0 8
142016: PPUSH
142017: CALL_OW 251
142021: PPUSH
142022: LD_INT 3
142024: PPUSH
142025: LD_INT 5
142027: PPUSH
142028: CALL_OW 273
142032: PPUSH
142033: CALL_OW 111
// SetTag ( i , 0 ) ;
142037: LD_VAR 0 7
142041: PPUSH
142042: LD_INT 0
142044: PPUSH
142045: CALL_OW 109
// solds := solds diff i ;
142049: LD_ADDR_VAR 0 2
142053: PUSH
142054: LD_VAR 0 2
142058: PUSH
142059: LD_VAR 0 7
142063: DIFF
142064: ST_TO_ADDR
// continue ;
142065: GO 141747
// end ; end ;
142067: GO 141747
142069: POP
142070: POP
// until not solds or not enemy ;
142071: LD_VAR 0 2
142075: NOT
142076: IFTRUE 142085
142078: PUSH
142079: LD_VAR 0 4
142083: NOT
142084: OR
142085: IFFALSE 141649
// MC_Reset ( base , 18 ) ;
142087: LD_VAR 0 1
142091: PPUSH
142092: LD_INT 18
142094: PPUSH
142095: CALL 44046 0 2
// end ;
142099: LD_VAR 0 3
142103: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
142104: LD_INT 0
142106: PPUSH
142107: PPUSH
142108: PPUSH
142109: PPUSH
142110: PPUSH
142111: PPUSH
142112: PPUSH
142113: PPUSH
142114: PPUSH
142115: PPUSH
142116: PPUSH
142117: PPUSH
142118: PPUSH
142119: PPUSH
142120: PPUSH
142121: PPUSH
142122: PPUSH
142123: PPUSH
142124: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
142125: LD_ADDR_VAR 0 12
142129: PUSH
142130: LD_EXP 102
142134: PUSH
142135: LD_VAR 0 1
142139: ARRAY
142140: PPUSH
142141: LD_INT 25
142143: PUSH
142144: LD_INT 3
142146: PUSH
142147: EMPTY
142148: LIST
142149: LIST
142150: PPUSH
142151: CALL_OW 72
142155: ST_TO_ADDR
// if mc_remote_driver [ base ] then
142156: LD_EXP 142
142160: PUSH
142161: LD_VAR 0 1
142165: ARRAY
142166: IFFALSE 142190
// mechs := mechs diff mc_remote_driver [ base ] ;
142168: LD_ADDR_VAR 0 12
142172: PUSH
142173: LD_VAR 0 12
142177: PUSH
142178: LD_EXP 142
142182: PUSH
142183: LD_VAR 0 1
142187: ARRAY
142188: DIFF
142189: ST_TO_ADDR
// for i in mechs do
142190: LD_ADDR_VAR 0 4
142194: PUSH
142195: LD_VAR 0 12
142199: PUSH
142200: FOR_IN
142201: IFFALSE 142236
// if GetTag ( i ) > 0 then
142203: LD_VAR 0 4
142207: PPUSH
142208: CALL_OW 110
142212: PUSH
142213: LD_INT 0
142215: GREATER
142216: IFFALSE 142234
// mechs := mechs diff i ;
142218: LD_ADDR_VAR 0 12
142222: PUSH
142223: LD_VAR 0 12
142227: PUSH
142228: LD_VAR 0 4
142232: DIFF
142233: ST_TO_ADDR
142234: GO 142200
142236: POP
142237: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
142238: LD_ADDR_VAR 0 8
142242: PUSH
142243: LD_EXP 102
142247: PUSH
142248: LD_VAR 0 1
142252: ARRAY
142253: PPUSH
142254: LD_INT 2
142256: PUSH
142257: LD_INT 25
142259: PUSH
142260: LD_INT 1
142262: PUSH
142263: EMPTY
142264: LIST
142265: LIST
142266: PUSH
142267: LD_INT 25
142269: PUSH
142270: LD_INT 5
142272: PUSH
142273: EMPTY
142274: LIST
142275: LIST
142276: PUSH
142277: LD_INT 25
142279: PUSH
142280: LD_INT 8
142282: PUSH
142283: EMPTY
142284: LIST
142285: LIST
142286: PUSH
142287: LD_INT 25
142289: PUSH
142290: LD_INT 9
142292: PUSH
142293: EMPTY
142294: LIST
142295: LIST
142296: PUSH
142297: EMPTY
142298: LIST
142299: LIST
142300: LIST
142301: LIST
142302: LIST
142303: PPUSH
142304: CALL_OW 72
142308: ST_TO_ADDR
// if not defenders and not solds then
142309: LD_VAR 0 2
142313: NOT
142314: IFFALSE 142323
142316: PUSH
142317: LD_VAR 0 8
142321: NOT
142322: AND
142323: IFFALSE 142327
// exit ;
142325: GO 144149
// depot_under_attack := false ;
142327: LD_ADDR_VAR 0 16
142331: PUSH
142332: LD_INT 0
142334: ST_TO_ADDR
// sold_defenders := [ ] ;
142335: LD_ADDR_VAR 0 17
142339: PUSH
142340: EMPTY
142341: ST_TO_ADDR
// if mechs then
142342: LD_VAR 0 12
142346: IFFALSE 142501
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
142348: LD_ADDR_VAR 0 4
142352: PUSH
142353: LD_VAR 0 2
142357: PPUSH
142358: LD_INT 21
142360: PUSH
142361: LD_INT 2
142363: PUSH
142364: EMPTY
142365: LIST
142366: LIST
142367: PPUSH
142368: CALL_OW 72
142372: PUSH
142373: FOR_IN
142374: IFFALSE 142499
// begin if GetTag ( i ) <> 20 then
142376: LD_VAR 0 4
142380: PPUSH
142381: CALL_OW 110
142385: PUSH
142386: LD_INT 20
142388: NONEQUAL
142389: IFFALSE 142403
// SetTag ( i , 20 ) ;
142391: LD_VAR 0 4
142395: PPUSH
142396: LD_INT 20
142398: PPUSH
142399: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
142403: LD_VAR 0 4
142407: PPUSH
142408: CALL_OW 263
142412: PUSH
142413: LD_INT 1
142415: EQUAL
142416: IFFALSE 142430
142418: PUSH
142419: LD_VAR 0 4
142423: PPUSH
142424: CALL_OW 311
142428: NOT
142429: AND
142430: IFFALSE 142497
// begin un := mechs [ 1 ] ;
142432: LD_ADDR_VAR 0 10
142436: PUSH
142437: LD_VAR 0 12
142441: PUSH
142442: LD_INT 1
142444: ARRAY
142445: ST_TO_ADDR
// ComExit ( un ) ;
142446: LD_VAR 0 10
142450: PPUSH
142451: CALL 109493 0 1
// AddComEnterUnit ( un , i ) ;
142455: LD_VAR 0 10
142459: PPUSH
142460: LD_VAR 0 4
142464: PPUSH
142465: CALL_OW 180
// SetTag ( un , 19 ) ;
142469: LD_VAR 0 10
142473: PPUSH
142474: LD_INT 19
142476: PPUSH
142477: CALL_OW 109
// mechs := mechs diff un ;
142481: LD_ADDR_VAR 0 12
142485: PUSH
142486: LD_VAR 0 12
142490: PUSH
142491: LD_VAR 0 10
142495: DIFF
142496: ST_TO_ADDR
// end ; end ;
142497: GO 142373
142499: POP
142500: POP
// if solds then
142501: LD_VAR 0 8
142505: IFFALSE 142564
// for i in solds do
142507: LD_ADDR_VAR 0 4
142511: PUSH
142512: LD_VAR 0 8
142516: PUSH
142517: FOR_IN
142518: IFFALSE 142562
// if not GetTag ( i ) then
142520: LD_VAR 0 4
142524: PPUSH
142525: CALL_OW 110
142529: NOT
142530: IFFALSE 142560
// begin defenders := defenders union i ;
142532: LD_ADDR_VAR 0 2
142536: PUSH
142537: LD_VAR 0 2
142541: PUSH
142542: LD_VAR 0 4
142546: UNION
142547: ST_TO_ADDR
// SetTag ( i , 18 ) ;
142548: LD_VAR 0 4
142552: PPUSH
142553: LD_INT 18
142555: PPUSH
142556: CALL_OW 109
// end ;
142560: GO 142517
142562: POP
142563: POP
// repeat wait ( 0 0$2 ) ;
142564: LD_INT 70
142566: PPUSH
142567: CALL_OW 67
// enemy := mc_scan [ base ] ;
142571: LD_ADDR_VAR 0 21
142575: PUSH
142576: LD_EXP 125
142580: PUSH
142581: LD_VAR 0 1
142585: ARRAY
142586: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
142587: LD_EXP 102
142591: PUSH
142592: LD_VAR 0 1
142596: ARRAY
142597: NOT
142598: IFTRUE 142615
142600: PUSH
142601: LD_EXP 102
142605: PUSH
142606: LD_VAR 0 1
142610: ARRAY
142611: PUSH
142612: EMPTY
142613: EQUAL
142614: OR
142615: IFFALSE 142652
// begin for i in defenders do
142617: LD_ADDR_VAR 0 4
142621: PUSH
142622: LD_VAR 0 2
142626: PUSH
142627: FOR_IN
142628: IFFALSE 142641
// ComStop ( i ) ;
142630: LD_VAR 0 4
142634: PPUSH
142635: CALL_OW 141
142639: GO 142627
142641: POP
142642: POP
// defenders := [ ] ;
142643: LD_ADDR_VAR 0 2
142647: PUSH
142648: EMPTY
142649: ST_TO_ADDR
// exit ;
142650: GO 144149
// end ; for i in defenders do
142652: LD_ADDR_VAR 0 4
142656: PUSH
142657: LD_VAR 0 2
142661: PUSH
142662: FOR_IN
142663: IFFALSE 143597
// begin e := NearestUnitToUnit ( enemy , i ) ;
142665: LD_ADDR_VAR 0 13
142669: PUSH
142670: LD_VAR 0 21
142674: PPUSH
142675: LD_VAR 0 4
142679: PPUSH
142680: CALL_OW 74
142684: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
142685: LD_ADDR_VAR 0 7
142689: PUSH
142690: LD_EXP 102
142694: PUSH
142695: LD_VAR 0 1
142699: ARRAY
142700: PPUSH
142701: LD_INT 2
142703: PUSH
142704: LD_INT 30
142706: PUSH
142707: LD_INT 0
142709: PUSH
142710: EMPTY
142711: LIST
142712: LIST
142713: PUSH
142714: LD_INT 30
142716: PUSH
142717: LD_INT 1
142719: PUSH
142720: EMPTY
142721: LIST
142722: LIST
142723: PUSH
142724: EMPTY
142725: LIST
142726: LIST
142727: LIST
142728: PPUSH
142729: CALL_OW 72
142733: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
142734: LD_ADDR_VAR 0 16
142738: PUSH
142739: LD_VAR 0 7
142743: NOT
142744: IFTRUE 142774
142746: PUSH
142747: LD_VAR 0 7
142751: PPUSH
142752: LD_INT 3
142754: PUSH
142755: LD_INT 24
142757: PUSH
142758: LD_INT 600
142760: PUSH
142761: EMPTY
142762: LIST
142763: LIST
142764: PUSH
142765: EMPTY
142766: LIST
142767: LIST
142768: PPUSH
142769: CALL_OW 72
142773: OR
142774: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
142775: LD_VAR 0 4
142779: PPUSH
142780: CALL_OW 247
142784: PUSH
142785: LD_INT 2
142787: DOUBLE
142788: EQUAL
142789: IFTRUE 142793
142791: GO 143209
142793: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
142794: LD_VAR 0 4
142798: PPUSH
142799: CALL_OW 256
142803: PUSH
142804: LD_INT 1000
142806: EQUAL
142807: IFFALSE 142853
142809: PUSH
142810: LD_VAR 0 4
142814: PPUSH
142815: LD_VAR 0 13
142819: PPUSH
142820: CALL_OW 296
142824: PUSH
142825: LD_INT 40
142827: LESS
142828: IFTRUE 142852
142830: PUSH
142831: LD_VAR 0 13
142835: PPUSH
142836: LD_EXP 127
142840: PUSH
142841: LD_VAR 0 1
142845: ARRAY
142846: PPUSH
142847: CALL_OW 308
142851: OR
142852: AND
142853: IFFALSE 142979
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
142855: LD_VAR 0 4
142859: PPUSH
142860: CALL_OW 262
142864: PUSH
142865: LD_INT 1
142867: EQUAL
142868: IFFALSE 142885
142870: PUSH
142871: LD_VAR 0 4
142875: PPUSH
142876: CALL_OW 261
142880: PUSH
142881: LD_INT 30
142883: LESS
142884: AND
142885: IFFALSE 142893
142887: PUSH
142888: LD_VAR 0 7
142892: AND
142893: IFFALSE 142963
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
142895: LD_VAR 0 4
142899: PPUSH
142900: LD_VAR 0 7
142904: PPUSH
142905: LD_VAR 0 4
142909: PPUSH
142910: CALL_OW 74
142914: PPUSH
142915: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
142919: LD_VAR 0 4
142923: PPUSH
142924: LD_VAR 0 7
142928: PPUSH
142929: LD_VAR 0 4
142933: PPUSH
142934: CALL_OW 74
142938: PPUSH
142939: CALL_OW 296
142943: PUSH
142944: LD_INT 6
142946: LESS
142947: IFFALSE 142961
// SetFuel ( i , 100 ) ;
142949: LD_VAR 0 4
142953: PPUSH
142954: LD_INT 100
142956: PPUSH
142957: CALL_OW 240
// end else
142961: GO 142977
// ComAttackUnit ( i , e ) ;
142963: LD_VAR 0 4
142967: PPUSH
142968: LD_VAR 0 13
142972: PPUSH
142973: CALL_OW 115
// end else
142977: GO 143086
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
142979: LD_VAR 0 13
142983: PPUSH
142984: LD_EXP 127
142988: PUSH
142989: LD_VAR 0 1
142993: ARRAY
142994: PPUSH
142995: CALL_OW 308
142999: NOT
143000: IFFALSE 143022
143002: PUSH
143003: LD_VAR 0 4
143007: PPUSH
143008: LD_VAR 0 13
143012: PPUSH
143013: CALL_OW 296
143017: PUSH
143018: LD_INT 40
143020: GREATEREQUAL
143021: AND
143022: IFTRUE 143039
143024: PUSH
143025: LD_VAR 0 4
143029: PPUSH
143030: CALL_OW 256
143034: PUSH
143035: LD_INT 650
143037: LESSEQUAL
143038: OR
143039: IFFALSE 143064
143041: PUSH
143042: LD_VAR 0 4
143046: PPUSH
143047: LD_EXP 126
143051: PUSH
143052: LD_VAR 0 1
143056: ARRAY
143057: PPUSH
143058: CALL_OW 308
143062: NOT
143063: AND
143064: IFFALSE 143086
// ComMoveToArea ( i , mc_parking [ base ] ) ;
143066: LD_VAR 0 4
143070: PPUSH
143071: LD_EXP 126
143075: PUSH
143076: LD_VAR 0 1
143080: ARRAY
143081: PPUSH
143082: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
143086: LD_VAR 0 4
143090: PPUSH
143091: CALL_OW 256
143095: PUSH
143096: LD_INT 1000
143098: LESS
143099: IFFALSE 143116
143101: PUSH
143102: LD_VAR 0 4
143106: PPUSH
143107: CALL_OW 263
143111: PUSH
143112: LD_INT 1
143114: EQUAL
143115: AND
143116: IFFALSE 143129
143118: PUSH
143119: LD_VAR 0 4
143123: PPUSH
143124: CALL_OW 311
143128: AND
143129: IFFALSE 143153
143131: PUSH
143132: LD_VAR 0 4
143136: PPUSH
143137: LD_EXP 126
143141: PUSH
143142: LD_VAR 0 1
143146: ARRAY
143147: PPUSH
143148: CALL_OW 308
143152: AND
143153: IFFALSE 143207
// begin mech := IsDrivenBy ( i ) ;
143155: LD_ADDR_VAR 0 9
143159: PUSH
143160: LD_VAR 0 4
143164: PPUSH
143165: CALL_OW 311
143169: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
143170: LD_VAR 0 9
143174: PPUSH
143175: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
143179: LD_VAR 0 9
143183: PPUSH
143184: LD_VAR 0 4
143188: PPUSH
143189: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
143193: LD_VAR 0 9
143197: PPUSH
143198: LD_VAR 0 4
143202: PPUSH
143203: CALL_OW 180
// end ; end ; unit_human :
143207: GO 143568
143209: LD_INT 1
143211: DOUBLE
143212: EQUAL
143213: IFTRUE 143217
143215: GO 143567
143217: POP
// begin b := IsInUnit ( i ) ;
143218: LD_ADDR_VAR 0 18
143222: PUSH
143223: LD_VAR 0 4
143227: PPUSH
143228: CALL_OW 310
143232: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
143233: LD_ADDR_VAR 0 19
143237: PUSH
143238: LD_VAR 0 18
143242: NOT
143243: IFTRUE 143267
143245: PUSH
143246: LD_VAR 0 18
143250: PPUSH
143251: CALL_OW 266
143255: PUSH
143256: LD_INT 32
143258: PUSH
143259: LD_INT 31
143261: PUSH
143262: EMPTY
143263: LIST
143264: LIST
143265: IN
143266: OR
143267: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
143268: LD_VAR 0 18
143272: PPUSH
143273: CALL_OW 266
143277: PUSH
143278: LD_INT 5
143280: EQUAL
143281: IFFALSE 143313
143283: PUSH
143284: LD_VAR 0 4
143288: PPUSH
143289: CALL_OW 257
143293: PUSH
143294: LD_INT 1
143296: PUSH
143297: LD_INT 2
143299: PUSH
143300: LD_INT 3
143302: PUSH
143303: LD_INT 4
143305: PUSH
143306: EMPTY
143307: LIST
143308: LIST
143309: LIST
143310: LIST
143311: IN
143312: AND
143313: IFFALSE 143350
// begin class := AllowSpecClass ( i ) ;
143315: LD_ADDR_VAR 0 20
143319: PUSH
143320: LD_VAR 0 4
143324: PPUSH
143325: CALL 72847 0 1
143329: ST_TO_ADDR
// if class then
143330: LD_VAR 0 20
143334: IFFALSE 143350
// ComChangeProfession ( i , class ) ;
143336: LD_VAR 0 4
143340: PPUSH
143341: LD_VAR 0 20
143345: PPUSH
143346: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
143350: LD_VAR 0 16
143354: IFTRUE 143381
143356: PUSH
143357: LD_VAR 0 2
143361: PPUSH
143362: LD_INT 21
143364: PUSH
143365: LD_INT 2
143367: PUSH
143368: EMPTY
143369: LIST
143370: LIST
143371: PPUSH
143372: CALL_OW 72
143376: PUSH
143377: LD_INT 1
143379: LESSEQUAL
143380: OR
143381: IFFALSE 143389
143383: PUSH
143384: LD_VAR 0 19
143388: AND
143389: IFFALSE 143404
143391: PUSH
143392: LD_VAR 0 4
143396: PUSH
143397: LD_VAR 0 17
143401: IN
143402: NOT
143403: AND
143404: IFFALSE 143499
// begin if b then
143406: LD_VAR 0 18
143410: IFFALSE 143461
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
143412: LD_VAR 0 18
143416: PPUSH
143417: LD_VAR 0 21
143421: PPUSH
143422: LD_VAR 0 18
143426: PPUSH
143427: CALL_OW 74
143431: PPUSH
143432: CALL_OW 296
143436: PUSH
143437: LD_INT 10
143439: LESS
143440: IFFALSE 143457
143442: PUSH
143443: LD_VAR 0 18
143447: PPUSH
143448: CALL_OW 461
143452: PUSH
143453: LD_INT 7
143455: NONEQUAL
143456: AND
143457: IFFALSE 143461
// continue ;
143459: GO 142662
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
143461: LD_ADDR_VAR 0 17
143465: PUSH
143466: LD_VAR 0 17
143470: PPUSH
143471: LD_VAR 0 17
143475: PUSH
143476: LD_INT 1
143478: PLUS
143479: PPUSH
143480: LD_VAR 0 4
143484: PPUSH
143485: CALL_OW 1
143489: ST_TO_ADDR
// ComExitBuilding ( i ) ;
143490: LD_VAR 0 4
143494: PPUSH
143495: CALL_OW 122
// end ; if sold_defenders then
143499: LD_VAR 0 17
143503: IFFALSE 143565
// if i in sold_defenders then
143505: LD_VAR 0 4
143509: PUSH
143510: LD_VAR 0 17
143514: IN
143515: IFFALSE 143565
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
143517: LD_VAR 0 4
143521: PPUSH
143522: CALL_OW 314
143526: NOT
143527: IFFALSE 143549
143529: PUSH
143530: LD_VAR 0 4
143534: PPUSH
143535: LD_VAR 0 13
143539: PPUSH
143540: CALL_OW 296
143544: PUSH
143545: LD_INT 30
143547: LESS
143548: AND
143549: IFFALSE 143565
// ComAttackUnit ( i , e ) ;
143551: LD_VAR 0 4
143555: PPUSH
143556: LD_VAR 0 13
143560: PPUSH
143561: CALL_OW 115
// end ; end ; end ;
143565: GO 143568
143567: POP
// if IsDead ( i ) then
143568: LD_VAR 0 4
143572: PPUSH
143573: CALL_OW 301
143577: IFFALSE 143595
// defenders := defenders diff i ;
143579: LD_ADDR_VAR 0 2
143583: PUSH
143584: LD_VAR 0 2
143588: PUSH
143589: LD_VAR 0 4
143593: DIFF
143594: ST_TO_ADDR
// end ;
143595: GO 142662
143597: POP
143598: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
143599: LD_VAR 0 21
143603: NOT
143604: IFTRUE 143613
143606: PUSH
143607: LD_VAR 0 2
143611: NOT
143612: OR
143613: IFTRUE 143628
143615: PUSH
143616: LD_EXP 102
143620: PUSH
143621: LD_VAR 0 1
143625: ARRAY
143626: NOT
143627: OR
143628: IFFALSE 142564
// MC_Reset ( base , 18 ) ;
143630: LD_VAR 0 1
143634: PPUSH
143635: LD_INT 18
143637: PPUSH
143638: CALL 44046 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
143642: LD_ADDR_VAR 0 2
143646: PUSH
143647: LD_VAR 0 2
143651: PUSH
143652: LD_VAR 0 2
143656: PPUSH
143657: LD_INT 2
143659: PUSH
143660: LD_INT 25
143662: PUSH
143663: LD_INT 1
143665: PUSH
143666: EMPTY
143667: LIST
143668: LIST
143669: PUSH
143670: LD_INT 25
143672: PUSH
143673: LD_INT 5
143675: PUSH
143676: EMPTY
143677: LIST
143678: LIST
143679: PUSH
143680: LD_INT 25
143682: PUSH
143683: LD_INT 8
143685: PUSH
143686: EMPTY
143687: LIST
143688: LIST
143689: PUSH
143690: LD_INT 25
143692: PUSH
143693: LD_INT 9
143695: PUSH
143696: EMPTY
143697: LIST
143698: LIST
143699: PUSH
143700: EMPTY
143701: LIST
143702: LIST
143703: LIST
143704: LIST
143705: LIST
143706: PPUSH
143707: CALL_OW 72
143711: DIFF
143712: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
143713: LD_VAR 0 21
143717: NOT
143718: IFFALSE 143741
143720: PUSH
143721: LD_VAR 0 2
143725: PPUSH
143726: LD_INT 21
143728: PUSH
143729: LD_INT 2
143731: PUSH
143732: EMPTY
143733: LIST
143734: LIST
143735: PPUSH
143736: CALL_OW 72
143740: AND
143741: IFFALSE 144085
// begin tmp := FilterByTag ( defenders , 19 ) ;
143743: LD_ADDR_VAR 0 11
143747: PUSH
143748: LD_VAR 0 2
143752: PPUSH
143753: LD_INT 19
143755: PPUSH
143756: CALL 106640 0 2
143760: ST_TO_ADDR
// if tmp then
143761: LD_VAR 0 11
143765: IFFALSE 143835
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
143767: LD_ADDR_VAR 0 11
143771: PUSH
143772: LD_VAR 0 11
143776: PPUSH
143777: LD_INT 25
143779: PUSH
143780: LD_INT 3
143782: PUSH
143783: EMPTY
143784: LIST
143785: LIST
143786: PPUSH
143787: CALL_OW 72
143791: ST_TO_ADDR
// if tmp then
143792: LD_VAR 0 11
143796: IFFALSE 143835
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
143798: LD_ADDR_EXP 114
143802: PUSH
143803: LD_EXP 114
143807: PPUSH
143808: LD_VAR 0 1
143812: PPUSH
143813: LD_EXP 114
143817: PUSH
143818: LD_VAR 0 1
143822: ARRAY
143823: PUSH
143824: LD_VAR 0 11
143828: UNION
143829: PPUSH
143830: CALL_OW 1
143834: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
143835: LD_VAR 0 1
143839: PPUSH
143840: LD_INT 19
143842: PPUSH
143843: CALL 44046 0 2
// repeat wait ( 0 0$1 ) ;
143847: LD_INT 35
143849: PPUSH
143850: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
143854: LD_EXP 102
143858: PUSH
143859: LD_VAR 0 1
143863: ARRAY
143864: NOT
143865: IFTRUE 143882
143867: PUSH
143868: LD_EXP 102
143872: PUSH
143873: LD_VAR 0 1
143877: ARRAY
143878: PUSH
143879: EMPTY
143880: EQUAL
143881: OR
143882: IFFALSE 143919
// begin for i in defenders do
143884: LD_ADDR_VAR 0 4
143888: PUSH
143889: LD_VAR 0 2
143893: PUSH
143894: FOR_IN
143895: IFFALSE 143908
// ComStop ( i ) ;
143897: LD_VAR 0 4
143901: PPUSH
143902: CALL_OW 141
143906: GO 143894
143908: POP
143909: POP
// defenders := [ ] ;
143910: LD_ADDR_VAR 0 2
143914: PUSH
143915: EMPTY
143916: ST_TO_ADDR
// exit ;
143917: GO 144149
// end ; for i in defenders do
143919: LD_ADDR_VAR 0 4
143923: PUSH
143924: LD_VAR 0 2
143928: PUSH
143929: FOR_IN
143930: IFFALSE 144019
// begin if not IsInArea ( i , mc_parking [ base ] ) then
143932: LD_VAR 0 4
143936: PPUSH
143937: LD_EXP 126
143941: PUSH
143942: LD_VAR 0 1
143946: ARRAY
143947: PPUSH
143948: CALL_OW 308
143952: NOT
143953: IFFALSE 143977
// ComMoveToArea ( i , mc_parking [ base ] ) else
143955: LD_VAR 0 4
143959: PPUSH
143960: LD_EXP 126
143964: PUSH
143965: LD_VAR 0 1
143969: ARRAY
143970: PPUSH
143971: CALL_OW 113
143975: GO 144017
// if GetControl ( i ) = control_manual then
143977: LD_VAR 0 4
143981: PPUSH
143982: CALL_OW 263
143986: PUSH
143987: LD_INT 1
143989: EQUAL
143990: IFFALSE 144017
// if IsDrivenBy ( i ) then
143992: LD_VAR 0 4
143996: PPUSH
143997: CALL_OW 311
144001: IFFALSE 144017
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
144003: LD_VAR 0 4
144007: PPUSH
144008: CALL_OW 311
144012: PPUSH
144013: CALL_OW 121
// end ;
144017: GO 143929
144019: POP
144020: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
144021: LD_VAR 0 2
144025: PPUSH
144026: LD_INT 95
144028: PUSH
144029: LD_EXP 126
144033: PUSH
144034: LD_VAR 0 1
144038: ARRAY
144039: PUSH
144040: EMPTY
144041: LIST
144042: LIST
144043: PPUSH
144044: CALL_OW 72
144048: PUSH
144049: LD_VAR 0 2
144053: EQUAL
144054: IFTRUE 144068
144056: PUSH
144057: LD_EXP 125
144061: PUSH
144062: LD_VAR 0 1
144066: ARRAY
144067: OR
144068: IFTRUE 144083
144070: PUSH
144071: LD_EXP 102
144075: PUSH
144076: LD_VAR 0 1
144080: ARRAY
144081: NOT
144082: OR
144083: IFFALSE 143847
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
144085: LD_ADDR_EXP 124
144089: PUSH
144090: LD_EXP 124
144094: PPUSH
144095: LD_VAR 0 1
144099: PPUSH
144100: LD_VAR 0 2
144104: PPUSH
144105: LD_INT 21
144107: PUSH
144108: LD_INT 2
144110: PUSH
144111: EMPTY
144112: LIST
144113: LIST
144114: PPUSH
144115: CALL_OW 72
144119: PPUSH
144120: CALL_OW 1
144124: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
144125: LD_VAR 0 1
144129: PPUSH
144130: LD_INT 19
144132: PPUSH
144133: CALL 44046 0 2
// MC_Reset ( base , 20 ) ;
144137: LD_VAR 0 1
144141: PPUSH
144142: LD_INT 20
144144: PPUSH
144145: CALL 44046 0 2
// end ; end_of_file
144149: LD_VAR 0 3
144153: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
144154: LD_VAR 0 1
144158: PUSH
144159: LD_INT 200
144161: DOUBLE
144162: GREATEREQUAL
144163: IFFALSE 144171
144165: LD_INT 299
144167: DOUBLE
144168: LESSEQUAL
144169: IFTRUE 144173
144171: GO 144205
144173: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
144174: LD_VAR 0 1
144178: PPUSH
144179: LD_VAR 0 2
144183: PPUSH
144184: LD_VAR 0 3
144188: PPUSH
144189: LD_VAR 0 4
144193: PPUSH
144194: LD_VAR 0 5
144198: PPUSH
144199: CALL 131197 0 5
144203: GO 144282
144205: LD_INT 300
144207: DOUBLE
144208: GREATEREQUAL
144209: IFFALSE 144217
144211: LD_INT 399
144213: DOUBLE
144214: LESSEQUAL
144215: IFTRUE 144219
144217: GO 144281
144219: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
144220: LD_VAR 0 1
144224: PPUSH
144225: LD_VAR 0 2
144229: PPUSH
144230: LD_VAR 0 3
144234: PPUSH
144235: LD_VAR 0 4
144239: PPUSH
144240: LD_VAR 0 5
144244: PPUSH
144245: LD_VAR 0 6
144249: PPUSH
144250: LD_VAR 0 7
144254: PPUSH
144255: LD_VAR 0 8
144259: PPUSH
144260: LD_VAR 0 9
144264: PPUSH
144265: LD_VAR 0 10
144269: PPUSH
144270: LD_VAR 0 11
144274: PPUSH
144275: CALL 127081 0 11
144279: GO 144282
144281: POP
// end ;
144282: PPOPN 11
144284: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
144285: LD_VAR 0 1
144289: PPUSH
144290: LD_VAR 0 2
144294: PPUSH
144295: LD_VAR 0 3
144299: PPUSH
144300: LD_VAR 0 4
144304: PPUSH
144305: LD_VAR 0 5
144309: PPUSH
144310: CALL 130578 0 5
// end ; end_of_file
144314: PPOPN 5
144316: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
144317: LD_VAR 0 1
144321: PPUSH
144322: LD_VAR 0 2
144326: PPUSH
144327: LD_VAR 0 3
144331: PPUSH
144332: LD_VAR 0 4
144336: PPUSH
144337: LD_VAR 0 5
144341: PPUSH
144342: LD_VAR 0 6
144346: PPUSH
144347: CALL 114621 0 6
// end ;
144351: PPOPN 6
144353: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
144354: LD_INT 0
144356: PPUSH
// begin if not units then
144357: LD_VAR 0 1
144361: NOT
144362: IFFALSE 144366
// exit ;
144364: GO 144400
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
144366: LD_VAR 0 1
144370: PPUSH
144371: LD_VAR 0 2
144375: PPUSH
144376: LD_VAR 0 3
144380: PPUSH
144381: LD_VAR 0 4
144385: PPUSH
144386: LD_VAR 0 5
144390: PPUSH
144391: LD_VAR 0 6
144395: PPUSH
144396: CALL 136704 0 6
// end ;
144400: PPOPN 7
144402: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
144403: CALL 114508 0 0
// end ;
144407: PPOPN 1
144409: END
