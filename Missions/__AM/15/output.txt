// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 61 0 0
// InitMacro ;
  15: CALL 34707 0 0
// InitNature ;
  19: CALL 34531 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10946 0 0
// PrepareRussian ;
  40: CALL 6920 0 0
// PrepareLegion ;
  44: CALL 4160 0 0
// PreparePowell ;
  48: CALL 2914 0 0
// PrepareAmerican ;
  52: CALL 1686 0 0
// MC_Start ( ) ;
  56: CALL 36819 0 0
// end ;
  60: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  61: LD_INT 0
  63: PPUSH
// debug := 1 ;
  64: LD_ADDR_EXP 1
  68: PUSH
  69: LD_INT 1
  71: ST_TO_ADDR
// missionStart := false ;
  72: LD_ADDR_EXP 13
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionTime := 0 0$00 ;
  80: LD_ADDR_EXP 14
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionStage := 1 ;
  88: LD_ADDR_EXP 15
  92: PUSH
  93: LD_INT 1
  95: ST_TO_ADDR
// activeAttacks := false ;
  96: LD_ADDR_EXP 16
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// powellAnger := 0 ;
 104: LD_ADDR_EXP 17
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAngerQuery := false ;
 112: LD_ADDR_EXP 36
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAllowRetreat := true ;
 120: LD_ADDR_EXP 19
 124: PUSH
 125: LD_INT 1
 127: ST_TO_ADDR
// powellCenterCameraMode := false ;
 128: LD_ADDR_EXP 20
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 136: LD_ADDR_EXP 18
 140: PUSH
 141: EMPTY
 142: PUSH
 143: EMPTY
 144: PUSH
 145: EMPTY
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// russianDestroyed := false ;
 149: LD_ADDR_EXP 21
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// legionDestroyed := false ;
 157: LD_ADDR_EXP 22
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// allianceDestroyed := false ;
 165: LD_ADDR_EXP 23
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 173: LD_ADDR_EXP 2
 177: PUSH
 178: LD_STRING 14_KappaStatus_1
 180: PPUSH
 181: LD_INT 0
 183: PPUSH
 184: CALL_OW 30
 188: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 189: LD_ADDR_EXP 3
 193: PUSH
 194: LD_STRING 06_KurtStatus_1
 196: PPUSH
 197: LD_INT 0
 199: PPUSH
 200: CALL_OW 30
 204: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 205: LD_ADDR_EXP 4
 209: PUSH
 210: LD_STRING 14_JMMVeh_1
 212: PPUSH
 213: LD_INT 0
 215: PPUSH
 216: CALL_OW 30
 220: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 221: LD_ADDR_EXP 5
 225: PUSH
 226: LD_STRING 14_JMMGirlVeh_1
 228: PPUSH
 229: LD_INT 0
 231: PPUSH
 232: CALL_OW 30
 236: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 237: LD_ADDR_EXP 7
 241: PUSH
 242: LD_STRING 14_JMMGirl_1
 244: PPUSH
 245: LD_INT 0
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 253: LD_ADDR_EXP 6
 257: PUSH
 258: LD_STRING 14_JMMGirlStatus_1
 260: PPUSH
 261: LD_INT 0
 263: PPUSH
 264: CALL_OW 30
 268: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 269: LD_ADDR_EXP 8
 273: PUSH
 274: LD_STRING 10_KhatamStatus_1
 276: PPUSH
 277: LD_INT 0
 279: PPUSH
 280: CALL_OW 30
 284: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 285: LD_ADDR_EXP 9
 289: PUSH
 290: LD_STRING 13_BurlakStatus_1
 292: PPUSH
 293: LD_INT 0
 295: PPUSH
 296: CALL_OW 30
 300: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 301: LD_ADDR_EXP 10
 305: PUSH
 306: LD_STRING 13_StevensStatus_1
 308: PPUSH
 309: LD_INT 0
 311: PPUSH
 312: CALL_OW 30
 316: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 317: LD_ADDR_EXP 11
 321: PUSH
 322: LD_STRING 14_FastEnd_1
 324: PPUSH
 325: LD_INT 0
 327: PPUSH
 328: CALL_OW 30
 332: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 333: LD_ADDR_EXP 12
 337: PUSH
 338: LD_STRING 12_MainDepositFake_1
 340: PPUSH
 341: LD_INT 0
 343: PPUSH
 344: CALL_OW 30
 348: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 349: LD_ADDR_EXP 24
 353: PUSH
 354: LD_INT 1
 356: ST_TO_ADDR
// behemothUnderConstruct := false ;
 357: LD_ADDR_EXP 26
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 365: LD_ADDR_EXP 27
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDone := false ;
 373: LD_ADDR_EXP 28
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// allowBehemothConstruct := false ;
 381: LD_ADDR_EXP 25
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// seeBehemoth := false ;
 389: LD_ADDR_EXP 29
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// platonovHasBomb := false ;
 397: LD_ADDR_EXP 30
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// allianceActive := false ;
 405: LD_ADDR_EXP 31
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// rothCaptured := false ;
 413: LD_ADDR_EXP 33
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// lostCounter := 0 ;
 421: LD_ADDR_EXP 32
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// capturedUnit := [ ] ;
 429: LD_ADDR_EXP 34
 433: PUSH
 434: EMPTY
 435: ST_TO_ADDR
// trueAmericans := [ ] ;
 436: LD_ADDR_EXP 35
 440: PUSH
 441: EMPTY
 442: ST_TO_ADDR
// bombExploded := false ;
 443: LD_ADDR_EXP 37
 447: PUSH
 448: LD_INT 0
 450: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 451: LD_ADDR_EXP 38
 455: PUSH
 456: EMPTY
 457: ST_TO_ADDR
// end ;
 458: LD_VAR 0 1
 462: RET
// export function CustomInitMacro ( ) ; begin
 463: LD_INT 0
 465: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 466: LD_ADDR_EXP 126
 470: PUSH
 471: LD_INT 2
 473: PUSH
 474: LD_INT 3
 476: PUSH
 477: LD_INT 6
 479: PUSH
 480: LD_INT 10
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 489: LD_ADDR_EXP 127
 493: PUSH
 494: LD_INT 1
 496: PUSH
 497: LD_INT 4
 499: PUSH
 500: LD_INT 5
 502: PUSH
 503: LD_INT 9
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 512: LD_INT 1
 514: PPUSH
 515: LD_INT 10
 517: PUSH
 518: LD_INT 11
 520: PUSH
 521: LD_INT 12
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PPUSH
 529: CALL 59096 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 533: LD_INT 1
 535: PPUSH
 536: LD_INT 17
 538: PUSH
 539: EMPTY
 540: LIST
 541: PPUSH
 542: CALL 59189 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 546: LD_INT 1
 548: PPUSH
 549: LD_INT 5
 551: PPUSH
 552: CALL 58539 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 556: LD_INT 1
 558: PPUSH
 559: LD_INT 24
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 3
 567: PUSH
 568: LD_INT 47
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 24
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 47
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: LD_INT 24
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 47
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 24
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 1
 621: PUSH
 622: LD_INT 47
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 24
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 1
 639: PUSH
 640: LD_INT 47
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PPUSH
 656: CALL 58354 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 660: LD_INT 2
 662: PPUSH
 663: LD_INT 10
 665: PUSH
 666: LD_INT 11
 668: PUSH
 669: LD_INT 12
 671: PUSH
 672: LD_INT 14
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 59096 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 16
 690: PUSH
 691: EMPTY
 692: LIST
 693: PPUSH
 694: CALL 59189 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 698: LD_INT 2
 700: PPUSH
 701: LD_INT 21
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 3
 709: PUSH
 710: LD_INT 51
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: LIST
 717: LIST
 718: PUSH
 719: LD_INT 22
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 3
 727: PUSH
 728: LD_INT 52
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: LIST
 735: LIST
 736: PUSH
 737: LD_INT 22
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 3
 745: PUSH
 746: LD_INT 52
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: PUSH
 755: LD_INT 24
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 3
 763: PUSH
 764: LD_INT 47
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: PUSH
 773: LD_INT 24
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 3
 781: PUSH
 782: LD_INT 47
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PUSH
 791: LD_INT 24
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: LD_INT 47
 802: PUSH
 803: EMPTY
 804: LIST
 805: LIST
 806: LIST
 807: LIST
 808: PUSH
 809: LD_INT 24
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: LD_INT 47
 820: PUSH
 821: EMPTY
 822: LIST
 823: LIST
 824: LIST
 825: LIST
 826: PUSH
 827: LD_INT 24
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: LD_INT 47
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: PPUSH
 855: CALL 58354 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 859: LD_INT 2
 861: PPUSH
 862: LD_INT 5
 864: PPUSH
 865: CALL 58539 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 869: LD_INT 2
 871: PPUSH
 872: LD_INT 0
 874: PPUSH
 875: CALL 58969 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 879: LD_INT 3
 881: PPUSH
 882: LD_INT 10
 884: PUSH
 885: LD_INT 12
 887: PUSH
 888: LD_INT 15
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: PUSH
 896: LD_OWVAR 67
 900: ARRAY
 901: PPUSH
 902: LD_INT 27
 904: PPUSH
 905: CALL 58036 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 909: LD_INT 3
 911: PPUSH
 912: LD_INT 10
 914: PUSH
 915: LD_INT 11
 917: PUSH
 918: LD_INT 13
 920: PUSH
 921: LD_INT 15
 923: PUSH
 924: EMPTY
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PPUSH
 930: CALL 59096 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 934: LD_INT 3
 936: PPUSH
 937: LD_INT 15
 939: PUSH
 940: EMPTY
 941: LIST
 942: PPUSH
 943: CALL 59189 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 947: LD_ADDR_EXP 131
 951: PUSH
 952: LD_EXP 131
 956: PPUSH
 957: LD_INT 3
 959: PPUSH
 960: LD_INT 22
 962: PUSH
 963: LD_INT 8
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 25
 972: PUSH
 973: LD_INT 15
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL_OW 69
 988: PPUSH
 989: CALL_OW 1
 993: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 994: LD_INT 3
 996: PPUSH
 997: LD_INT 13
 999: PUSH
1000: LD_INT 2
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 31
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 13
1017: PUSH
1018: LD_INT 2
1020: PUSH
1021: LD_INT 1
1023: PUSH
1024: LD_INT 31
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_INT 13
1035: PUSH
1036: LD_INT 3
1038: PUSH
1039: LD_INT 2
1041: PUSH
1042: LD_INT 32
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: PPUSH
1056: CALL 58354 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1060: LD_INT 4
1062: PPUSH
1063: LD_INT 10
1065: PUSH
1066: LD_INT 12
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 59096 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 9
1082: PUSH
1083: EMPTY
1084: LIST
1085: PPUSH
1086: CALL 59189 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 26
1095: PUSH
1096: LD_INT 74
1098: PUSH
1099: LD_INT 107
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: PUSH
1111: LD_INT 32
1113: PUSH
1114: LD_INT 77
1116: PUSH
1117: LD_INT 101
1119: PUSH
1120: LD_INT 4
1122: PUSH
1123: EMPTY
1124: LIST
1125: LIST
1126: LIST
1127: LIST
1128: PUSH
1129: LD_INT 32
1131: PUSH
1132: LD_INT 69
1134: PUSH
1135: LD_INT 86
1137: PUSH
1138: LD_INT 4
1140: PUSH
1141: EMPTY
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: PUSH
1147: LD_INT 27
1149: PUSH
1150: LD_INT 77
1152: PUSH
1153: LD_INT 110
1155: PUSH
1156: LD_INT 3
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: PUSH
1165: LD_INT 27
1167: PUSH
1168: LD_INT 42
1170: PUSH
1171: LD_INT 79
1173: PUSH
1174: LD_INT 5
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 29
1185: PUSH
1186: LD_INT 86
1188: PUSH
1189: LD_INT 105
1191: PUSH
1192: LD_INT 2
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 30
1203: PUSH
1204: LD_INT 40
1206: PUSH
1207: LD_INT 75
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 32
1221: PUSH
1222: LD_INT 80
1224: PUSH
1225: LD_INT 106
1227: PUSH
1228: LD_INT 4
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 32
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 114
1245: PUSH
1246: LD_INT 5
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 32
1257: PUSH
1258: LD_INT 82
1260: PUSH
1261: LD_INT 110
1263: PUSH
1264: LD_INT 5
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: LD_INT 32
1275: PUSH
1276: LD_INT 62
1278: PUSH
1279: LD_INT 78
1281: PUSH
1282: LD_INT 4
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PUSH
1291: LD_INT 4
1293: PUSH
1294: LD_INT 39
1296: PUSH
1297: LD_INT 61
1299: PUSH
1300: LD_INT 3
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: PPUSH
1323: CALL 58246 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1327: LD_INT 4
1329: PPUSH
1330: LD_INT 5
1332: PUSH
1333: LD_INT 6
1335: PUSH
1336: LD_INT 7
1338: PUSH
1339: LD_INT 9
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: PPUSH
1348: CALL 59507 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1352: LD_INT 4
1354: PPUSH
1355: LD_INT 40
1357: PUSH
1358: LD_INT 75
1360: PUSH
1361: LD_INT 1
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: PUSH
1369: LD_INT 86
1371: PUSH
1372: LD_INT 105
1374: PUSH
1375: LD_INT 0
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PPUSH
1387: CALL 58678 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1391: LD_INT 4
1393: PPUSH
1394: LD_INT 2
1396: PPUSH
1397: CALL 58969 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1401: LD_INT 4
1403: PPUSH
1404: LD_INT 0
1406: PPUSH
1407: CALL 58969 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1411: LD_INT 4
1413: PPUSH
1414: LD_INT 54
1416: PPUSH
1417: LD_INT 85
1419: PPUSH
1420: LD_INT 2
1422: PPUSH
1423: LD_INT 19
1425: PUSH
1426: LD_INT 16
1428: PUSH
1429: LD_INT 17
1431: PUSH
1432: LD_INT 18
1434: PUSH
1435: EMPTY
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: PPUSH
1441: CALL 59301 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1445: LD_INT 4
1447: PPUSH
1448: LD_INT 3
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 1
1456: PUSH
1457: LD_INT 5
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: PUSH
1466: LD_INT 4
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 6
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PUSH
1484: LD_INT 4
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 7
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: LIST
1500: LIST
1501: PUSH
1502: LD_INT 4
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 1
1510: PUSH
1511: LD_INT 6
1513: PUSH
1514: EMPTY
1515: LIST
1516: LIST
1517: LIST
1518: LIST
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: PPUSH
1526: CALL 58354 0 2
// MC_SetTame ( 4 , powellApe ) ;
1530: LD_INT 4
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: CALL 58920 0 2
// end ;
1540: LD_VAR 0 1
1544: RET
// every 0 0$1 trigger debug do var i , tmp ;
1545: LD_EXP 1
1549: IFFALSE 1656
1551: GO 1553
1553: DISABLE
1554: LD_INT 0
1556: PPUSH
1557: PPUSH
// begin enable ;
1558: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1559: LD_ADDR_VAR 0 2
1563: PUSH
1564: LD_INT 22
1566: PUSH
1567: LD_INT 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 3
1576: PUSH
1577: LD_INT 21
1579: PUSH
1580: LD_INT 3
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: PUSH
1591: LD_INT 3
1593: PUSH
1594: LD_INT 24
1596: PUSH
1597: LD_INT 999
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: LIST
1612: PPUSH
1613: CALL_OW 69
1617: ST_TO_ADDR
// if not tmp then
1618: LD_VAR 0 2
1622: NOT
1623: IFFALSE 1627
// exit ;
1625: GO 1656
// for i in tmp do
1627: LD_ADDR_VAR 0 1
1631: PUSH
1632: LD_VAR 0 2
1636: PUSH
1637: FOR_IN
1638: IFFALSE 1654
// SetLives ( i , 1000 ) ;
1640: LD_VAR 0 1
1644: PPUSH
1645: LD_INT 1000
1647: PPUSH
1648: CALL_OW 234
1652: GO 1637
1654: POP
1655: POP
// end ;
1656: PPOPN 2
1658: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1659: LD_EXP 36
1663: PUSH
1664: LD_EXP 17
1668: PUSH
1669: LD_INT 2
1671: GREATEREQUAL
1672: AND
1673: IFFALSE 1685
1675: GO 1677
1677: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1678: LD_STRING ACH_POWELL
1680: PPUSH
1681: CALL_OW 543
1685: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1686: LD_INT 0
1688: PPUSH
// uc_side := 1 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 1
1696: ST_TO_ADDR
// uc_nation := 1 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 1
1704: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1705: LD_ADDR_EXP 39
1709: PUSH
1710: LD_STRING JMM
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 14_
1721: PPUSH
1722: CALL 64746 0 3
1726: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1727: LD_EXP 4
1731: NOT
1732: PUSH
1733: LD_EXP 4
1737: PUSH
1738: LD_INT 1
1740: ARRAY
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: NOT
1746: OR
1747: IFFALSE 1770
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1749: LD_INT 5
1751: PPUSH
1752: LD_INT 3
1754: PPUSH
1755: LD_INT 1
1757: PPUSH
1758: LD_INT 9
1760: PPUSH
1761: LD_INT 100
1763: PPUSH
1764: CALL 71861 0 5
1768: GO 1829
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1770: LD_EXP 4
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PPUSH
1783: LD_EXP 4
1787: PUSH
1788: LD_INT 2
1790: ARRAY
1791: PUSH
1792: LD_INT 1
1794: ARRAY
1795: PPUSH
1796: LD_EXP 4
1800: PUSH
1801: LD_INT 3
1803: ARRAY
1804: PUSH
1805: LD_INT 1
1807: ARRAY
1808: PPUSH
1809: LD_EXP 4
1813: PUSH
1814: LD_INT 4
1816: ARRAY
1817: PUSH
1818: LD_INT 1
1820: ARRAY
1821: PPUSH
1822: LD_INT 30
1824: PPUSH
1825: CALL 71861 0 5
// JMMNewVeh := CreateVehicle ;
1829: LD_ADDR_EXP 56
1833: PUSH
1834: CALL_OW 45
1838: ST_TO_ADDR
// if not JMMNewVeh then
1839: LD_EXP 56
1843: NOT
1844: IFFALSE 1875
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1846: LD_INT 5
1848: PPUSH
1849: LD_INT 3
1851: PPUSH
1852: LD_INT 1
1854: PPUSH
1855: LD_INT 9
1857: PPUSH
1858: LD_INT 100
1860: PPUSH
1861: CALL 71861 0 5
// JMMNewVeh := CreateVehicle ;
1865: LD_ADDR_EXP 56
1869: PUSH
1870: CALL_OW 45
1874: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1875: LD_EXP 56
1879: PPUSH
1880: LD_INT 4
1882: PPUSH
1883: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1887: LD_EXP 56
1891: PPUSH
1892: LD_INT 79
1894: PPUSH
1895: LD_INT 91
1897: PPUSH
1898: LD_INT 0
1900: PPUSH
1901: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1905: LD_EXP 39
1909: PPUSH
1910: LD_EXP 56
1914: PPUSH
1915: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1919: LD_EXP 6
1923: PUSH
1924: LD_EXP 2
1928: NOT
1929: AND
1930: IFFALSE 2188
// begin if not JMMGirlVeh then
1932: LD_EXP 5
1936: NOT
1937: IFFALSE 1960
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 3
1944: PPUSH
1945: LD_INT 1
1947: PPUSH
1948: LD_INT 9
1950: PPUSH
1951: LD_INT 100
1953: PPUSH
1954: CALL 71861 0 5
1958: GO 2019
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1960: LD_EXP 5
1964: PUSH
1965: LD_INT 1
1967: ARRAY
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PPUSH
1973: LD_EXP 5
1977: PUSH
1978: LD_INT 2
1980: ARRAY
1981: PUSH
1982: LD_INT 1
1984: ARRAY
1985: PPUSH
1986: LD_EXP 5
1990: PUSH
1991: LD_INT 3
1993: ARRAY
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_EXP 5
2003: PUSH
2004: LD_INT 4
2006: ARRAY
2007: PUSH
2008: LD_INT 1
2010: ARRAY
2011: PPUSH
2012: LD_INT 30
2014: PPUSH
2015: CALL 71861 0 5
// GirlNewVeh := CreateVehicle ;
2019: LD_ADDR_EXP 57
2023: PUSH
2024: CALL_OW 45
2028: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2029: LD_EXP 57
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2041: LD_EXP 57
2045: PPUSH
2046: LD_INT 82
2048: PPUSH
2049: LD_INT 96
2051: PPUSH
2052: LD_INT 0
2054: PPUSH
2055: CALL_OW 48
// if JMMGirl = 1 then
2059: LD_EXP 7
2063: PUSH
2064: LD_INT 1
2066: EQUAL
2067: IFFALSE 2102
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2069: LD_ADDR_EXP 40
2073: PUSH
2074: LD_STRING Joan
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: LD_STRING 14_
2082: PPUSH
2083: CALL 64746 0 3
2087: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2088: LD_EXP 40
2092: PPUSH
2093: LD_EXP 57
2097: PPUSH
2098: CALL_OW 52
// end ; if JMMGirl = 2 then
2102: LD_EXP 7
2106: PUSH
2107: LD_INT 2
2109: EQUAL
2110: IFFALSE 2145
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2112: LD_ADDR_EXP 42
2116: PUSH
2117: LD_STRING Lisa
2119: PPUSH
2120: LD_INT 1
2122: PPUSH
2123: LD_STRING 14_
2125: PPUSH
2126: CALL 64746 0 3
2130: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2131: LD_EXP 42
2135: PPUSH
2136: LD_EXP 57
2140: PPUSH
2141: CALL_OW 52
// end ; if JMMGirl = 3 then
2145: LD_EXP 7
2149: PUSH
2150: LD_INT 3
2152: EQUAL
2153: IFFALSE 2188
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2155: LD_ADDR_EXP 54
2159: PUSH
2160: LD_STRING Connie
2162: PPUSH
2163: LD_INT 1
2165: PPUSH
2166: LD_STRING 14_
2168: PPUSH
2169: CALL 64746 0 3
2173: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2174: LD_EXP 54
2178: PPUSH
2179: LD_EXP 57
2183: PPUSH
2184: CALL_OW 52
// end ; end ; end ;
2188: LD_VAR 0 1
2192: RET
// export function PrepareStevensSquad ; var tmp ; begin
2193: LD_INT 0
2195: PPUSH
2196: PPUSH
// uc_side := 1 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 1
2204: ST_TO_ADDR
// uc_nation := 1 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 1
2212: ST_TO_ADDR
// tmp := [ ] ;
2213: LD_ADDR_VAR 0 2
2217: PUSH
2218: EMPTY
2219: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2220: LD_ADDR_EXP 41
2224: PUSH
2225: LD_STRING Stevens
2227: PPUSH
2228: LD_EXP 1
2232: NOT
2233: PPUSH
2234: LD_STRING 13f_
2236: PPUSH
2237: CALL 64746 0 3
2241: ST_TO_ADDR
// if not Stevens then
2242: LD_EXP 41
2246: NOT
2247: IFFALSE 2303
// begin hc_name = Baker Smith ;
2249: LD_ADDR_OWVAR 26
2253: PUSH
2254: LD_STRING Baker Smith
2256: ST_TO_ADDR
// hc_gallery =  ;
2257: LD_ADDR_OWVAR 33
2261: PUSH
2262: LD_STRING 
2264: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 10
2270: PPUSH
2271: CALL_OW 384
// Baker = CreateHuman ;
2275: LD_ADDR_EXP 55
2279: PUSH
2280: CALL_OW 44
2284: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: LD_VAR 0 2
2294: PUSH
2295: LD_EXP 55
2299: ADD
2300: ST_TO_ADDR
// end else
2301: GO 2319
// tmp := tmp ^ Stevens ;
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 2
2312: PUSH
2313: LD_EXP 41
2317: ADD
2318: ST_TO_ADDR
// if not Lisa then
2319: LD_EXP 42
2323: NOT
2324: IFFALSE 2370
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2326: LD_ADDR_EXP 42
2330: PUSH
2331: LD_STRING Lisa
2333: PPUSH
2334: LD_EXP 1
2338: NOT
2339: PPUSH
2340: LD_STRING 13f_
2342: PPUSH
2343: CALL 64746 0 3
2347: ST_TO_ADDR
// if Lisa then
2348: LD_EXP 42
2352: IFFALSE 2370
// tmp := tmp ^ Lisa ;
2354: LD_ADDR_VAR 0 2
2358: PUSH
2359: LD_VAR 0 2
2363: PUSH
2364: LD_EXP 42
2368: ADD
2369: ST_TO_ADDR
// end ; if not Donaldson then
2370: LD_EXP 43
2374: NOT
2375: IFFALSE 2421
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2377: LD_ADDR_EXP 43
2381: PUSH
2382: LD_STRING Donaldson
2384: PPUSH
2385: LD_EXP 1
2389: NOT
2390: PPUSH
2391: LD_STRING 13f_
2393: PPUSH
2394: CALL 64746 0 3
2398: ST_TO_ADDR
// if Donaldson then
2399: LD_EXP 43
2403: IFFALSE 2421
// tmp := tmp ^ Donaldson ;
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_VAR 0 2
2414: PUSH
2415: LD_EXP 43
2419: ADD
2420: ST_TO_ADDR
// end ; if not Bobby then
2421: LD_EXP 44
2425: NOT
2426: IFFALSE 2472
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2428: LD_ADDR_EXP 44
2432: PUSH
2433: LD_STRING Bobby
2435: PPUSH
2436: LD_EXP 1
2440: NOT
2441: PPUSH
2442: LD_STRING 13f_
2444: PPUSH
2445: CALL 64746 0 3
2449: ST_TO_ADDR
// if Bobby then
2450: LD_EXP 44
2454: IFFALSE 2472
// tmp := tmp ^ Bobby ;
2456: LD_ADDR_VAR 0 2
2460: PUSH
2461: LD_VAR 0 2
2465: PUSH
2466: LD_EXP 44
2470: ADD
2471: ST_TO_ADDR
// end ; if not Cyrus then
2472: LD_EXP 45
2476: NOT
2477: IFFALSE 2523
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2479: LD_ADDR_EXP 45
2483: PUSH
2484: LD_STRING Cyrus
2486: PPUSH
2487: LD_EXP 1
2491: NOT
2492: PPUSH
2493: LD_STRING 13f_
2495: PPUSH
2496: CALL 64746 0 3
2500: ST_TO_ADDR
// if Cyrus then
2501: LD_EXP 45
2505: IFFALSE 2523
// tmp := tmp ^ Cyrus ;
2507: LD_ADDR_VAR 0 2
2511: PUSH
2512: LD_VAR 0 2
2516: PUSH
2517: LD_EXP 45
2521: ADD
2522: ST_TO_ADDR
// end ; if not Brown then
2523: LD_EXP 47
2527: NOT
2528: IFFALSE 2574
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2530: LD_ADDR_EXP 47
2534: PUSH
2535: LD_STRING Brown
2537: PPUSH
2538: LD_EXP 1
2542: NOT
2543: PPUSH
2544: LD_STRING 13f_
2546: PPUSH
2547: CALL 64746 0 3
2551: ST_TO_ADDR
// if Brown then
2552: LD_EXP 47
2556: IFFALSE 2574
// tmp := tmp ^ Brown ;
2558: LD_ADDR_VAR 0 2
2562: PUSH
2563: LD_VAR 0 2
2567: PUSH
2568: LD_EXP 47
2572: ADD
2573: ST_TO_ADDR
// end ; if not Gladstone then
2574: LD_EXP 48
2578: NOT
2579: IFFALSE 2625
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2581: LD_ADDR_EXP 48
2585: PUSH
2586: LD_STRING Gladstone
2588: PPUSH
2589: LD_EXP 1
2593: NOT
2594: PPUSH
2595: LD_STRING 13f_
2597: PPUSH
2598: CALL 64746 0 3
2602: ST_TO_ADDR
// if Gladstone then
2603: LD_EXP 48
2607: IFFALSE 2625
// tmp := tmp ^ Gladstone ;
2609: LD_ADDR_VAR 0 2
2613: PUSH
2614: LD_VAR 0 2
2618: PUSH
2619: LD_EXP 48
2623: ADD
2624: ST_TO_ADDR
// end ; if not Houten then
2625: LD_EXP 49
2629: NOT
2630: IFFALSE 2676
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2632: LD_ADDR_EXP 49
2636: PUSH
2637: LD_STRING Houten
2639: PPUSH
2640: LD_EXP 1
2644: NOT
2645: PPUSH
2646: LD_STRING 13f_
2648: PPUSH
2649: CALL 64746 0 3
2653: ST_TO_ADDR
// if Houten then
2654: LD_EXP 49
2658: IFFALSE 2676
// tmp := tmp ^ Houten ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 2
2669: PUSH
2670: LD_EXP 49
2674: ADD
2675: ST_TO_ADDR
// end ; if not Cornel then
2676: LD_EXP 50
2680: NOT
2681: IFFALSE 2727
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2683: LD_ADDR_EXP 50
2687: PUSH
2688: LD_STRING Cornell
2690: PPUSH
2691: LD_EXP 1
2695: NOT
2696: PPUSH
2697: LD_STRING 13f_
2699: PPUSH
2700: CALL 64746 0 3
2704: ST_TO_ADDR
// if Cornel then
2705: LD_EXP 50
2709: IFFALSE 2727
// tmp := tmp ^ Cornel ;
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_VAR 0 2
2720: PUSH
2721: LD_EXP 50
2725: ADD
2726: ST_TO_ADDR
// end ; if not Gary then
2727: LD_EXP 51
2731: NOT
2732: IFFALSE 2778
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2734: LD_ADDR_EXP 51
2738: PUSH
2739: LD_STRING Gary
2741: PPUSH
2742: LD_EXP 1
2746: NOT
2747: PPUSH
2748: LD_STRING 13f_
2750: PPUSH
2751: CALL 64746 0 3
2755: ST_TO_ADDR
// if Gary then
2756: LD_EXP 51
2760: IFFALSE 2778
// tmp := tmp ^ Gary ;
2762: LD_ADDR_VAR 0 2
2766: PUSH
2767: LD_VAR 0 2
2771: PUSH
2772: LD_EXP 51
2776: ADD
2777: ST_TO_ADDR
// end ; if not Frank then
2778: LD_EXP 52
2782: NOT
2783: IFFALSE 2829
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2785: LD_ADDR_EXP 52
2789: PUSH
2790: LD_STRING Frank
2792: PPUSH
2793: LD_EXP 1
2797: NOT
2798: PPUSH
2799: LD_STRING 13f_
2801: PPUSH
2802: CALL 64746 0 3
2806: ST_TO_ADDR
// if Frank then
2807: LD_EXP 52
2811: IFFALSE 2829
// tmp := tmp ^ Frank ;
2813: LD_ADDR_VAR 0 2
2817: PUSH
2818: LD_VAR 0 2
2822: PUSH
2823: LD_EXP 52
2827: ADD
2828: ST_TO_ADDR
// end ; if not Kikuchi then
2829: LD_EXP 53
2833: NOT
2834: IFFALSE 2880
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2836: LD_ADDR_EXP 53
2840: PUSH
2841: LD_STRING Kikuchi
2843: PPUSH
2844: LD_EXP 1
2848: NOT
2849: PPUSH
2850: LD_STRING 13f_
2852: PPUSH
2853: CALL 64746 0 3
2857: ST_TO_ADDR
// if Kikuchi then
2858: LD_EXP 53
2862: IFFALSE 2880
// tmp := tmp ^ Kikuchi ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_VAR 0 2
2873: PUSH
2874: LD_EXP 53
2878: ADD
2879: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2880: LD_ADDR_VAR 0 2
2884: PUSH
2885: LD_VAR 0 2
2889: PUSH
2890: LD_STRING 13_other_survivors
2892: PPUSH
2893: CALL_OW 31
2897: UNION
2898: ST_TO_ADDR
// result := tmp ;
2899: LD_ADDR_VAR 0 1
2903: PUSH
2904: LD_VAR 0 2
2908: ST_TO_ADDR
// end ; end_of_file
2909: LD_VAR 0 1
2913: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2914: LD_INT 0
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
// uc_side := 4 ;
2926: LD_ADDR_OWVAR 20
2930: PUSH
2931: LD_INT 4
2933: ST_TO_ADDR
// uc_nation := 1 ;
2934: LD_ADDR_OWVAR 21
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2942: LD_INT 387
2944: PPUSH
2945: CALL_OW 274
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: LD_INT 2500
2955: PPUSH
2956: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2960: LD_INT 387
2962: PPUSH
2963: CALL_OW 274
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: LD_INT 400
2973: PPUSH
2974: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2978: LD_INT 387
2980: PPUSH
2981: CALL_OW 274
2985: PPUSH
2986: LD_INT 3
2988: PPUSH
2989: LD_INT 10
2991: PPUSH
2992: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2996: LD_ADDR_EXP 58
3000: PUSH
3001: LD_STRING Powell
3003: PPUSH
3004: CALL_OW 25
3008: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3009: LD_EXP 58
3013: PPUSH
3014: LD_INT 57
3016: PPUSH
3017: LD_INT 94
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3027: LD_EXP 58
3031: PPUSH
3032: LD_INT 58
3034: PPUSH
3035: LD_INT 94
3037: PPUSH
3038: CALL_OW 118
// vip := [ ] ;
3042: LD_ADDR_EXP 59
3046: PUSH
3047: EMPTY
3048: ST_TO_ADDR
// tmp := [ ] ;
3049: LD_ADDR_VAR 0 6
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// if JMMGirl <> 2 then
3056: LD_EXP 7
3060: PUSH
3061: LD_INT 2
3063: NONEQUAL
3064: IFFALSE 3088
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3066: LD_ADDR_EXP 42
3070: PUSH
3071: LD_STRING Lisa
3073: PPUSH
3074: LD_EXP 1
3078: NOT
3079: PPUSH
3080: LD_STRING 13s_
3082: PPUSH
3083: CALL 64746 0 3
3087: ST_TO_ADDR
// if Lisa then
3088: LD_EXP 42
3092: IFFALSE 3110
// tmp := tmp ^ Lisa ;
3094: LD_ADDR_VAR 0 6
3098: PUSH
3099: LD_VAR 0 6
3103: PUSH
3104: LD_EXP 42
3108: ADD
3109: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3110: LD_ADDR_EXP 43
3114: PUSH
3115: LD_STRING Donaldson
3117: PPUSH
3118: LD_EXP 1
3122: NOT
3123: PPUSH
3124: LD_STRING 13s_
3126: PPUSH
3127: CALL 64746 0 3
3131: ST_TO_ADDR
// if Donaldson then
3132: LD_EXP 43
3136: IFFALSE 3154
// tmp := tmp ^ Donaldson ;
3138: LD_ADDR_VAR 0 6
3142: PUSH
3143: LD_VAR 0 6
3147: PUSH
3148: LD_EXP 43
3152: ADD
3153: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3154: LD_ADDR_EXP 44
3158: PUSH
3159: LD_STRING Bobby
3161: PPUSH
3162: LD_EXP 1
3166: NOT
3167: PPUSH
3168: LD_STRING 13s_
3170: PPUSH
3171: CALL 64746 0 3
3175: ST_TO_ADDR
// if Bobby then
3176: LD_EXP 44
3180: IFFALSE 3198
// tmp := tmp ^ Bobby ;
3182: LD_ADDR_VAR 0 6
3186: PUSH
3187: LD_VAR 0 6
3191: PUSH
3192: LD_EXP 44
3196: ADD
3197: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3198: LD_ADDR_EXP 45
3202: PUSH
3203: LD_STRING Cyrus
3205: PPUSH
3206: LD_EXP 1
3210: NOT
3211: PPUSH
3212: LD_STRING 13s_
3214: PPUSH
3215: CALL 64746 0 3
3219: ST_TO_ADDR
// if Cyrus then
3220: LD_EXP 45
3224: IFFALSE 3242
// tmp := tmp ^ Cyrus ;
3226: LD_ADDR_VAR 0 6
3230: PUSH
3231: LD_VAR 0 6
3235: PUSH
3236: LD_EXP 45
3240: ADD
3241: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3242: LD_ADDR_EXP 46
3246: PUSH
3247: LD_STRING Denis
3249: PPUSH
3250: LD_EXP 1
3254: NOT
3255: PPUSH
3256: LD_STRING 13s_
3258: PPUSH
3259: CALL 64746 0 3
3263: ST_TO_ADDR
// if not Denis then
3264: LD_EXP 46
3268: NOT
3269: IFFALSE 3293
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3271: LD_ADDR_EXP 46
3275: PUSH
3276: LD_STRING Denis
3278: PPUSH
3279: LD_EXP 1
3283: NOT
3284: PPUSH
3285: LD_STRING 13f_
3287: PPUSH
3288: CALL 64746 0 3
3292: ST_TO_ADDR
// if Denis then
3293: LD_EXP 46
3297: IFFALSE 3315
// tmp := tmp ^ Denis ;
3299: LD_ADDR_VAR 0 6
3303: PUSH
3304: LD_VAR 0 6
3308: PUSH
3309: LD_EXP 46
3313: ADD
3314: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3315: LD_ADDR_EXP 47
3319: PUSH
3320: LD_STRING Brown
3322: PPUSH
3323: LD_EXP 1
3327: NOT
3328: PPUSH
3329: LD_STRING 13s_
3331: PPUSH
3332: CALL 64746 0 3
3336: ST_TO_ADDR
// if Brown then
3337: LD_EXP 47
3341: IFFALSE 3359
// tmp := tmp ^ Brown ;
3343: LD_ADDR_VAR 0 6
3347: PUSH
3348: LD_VAR 0 6
3352: PUSH
3353: LD_EXP 47
3357: ADD
3358: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3359: LD_ADDR_EXP 48
3363: PUSH
3364: LD_STRING Gladstone
3366: PPUSH
3367: LD_EXP 1
3371: NOT
3372: PPUSH
3373: LD_STRING 13s_
3375: PPUSH
3376: CALL 64746 0 3
3380: ST_TO_ADDR
// if Gladstone then
3381: LD_EXP 48
3385: IFFALSE 3403
// tmp := tmp ^ Gladstone ;
3387: LD_ADDR_VAR 0 6
3391: PUSH
3392: LD_VAR 0 6
3396: PUSH
3397: LD_EXP 48
3401: ADD
3402: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3403: LD_ADDR_EXP 49
3407: PUSH
3408: LD_STRING Houten
3410: PPUSH
3411: LD_EXP 1
3415: NOT
3416: PPUSH
3417: LD_STRING 13s_
3419: PPUSH
3420: CALL 64746 0 3
3424: ST_TO_ADDR
// if Houten then
3425: LD_EXP 49
3429: IFFALSE 3447
// tmp := tmp ^ Houten ;
3431: LD_ADDR_VAR 0 6
3435: PUSH
3436: LD_VAR 0 6
3440: PUSH
3441: LD_EXP 49
3445: ADD
3446: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3447: LD_ADDR_EXP 50
3451: PUSH
3452: LD_STRING Cornel
3454: PPUSH
3455: LD_EXP 1
3459: NOT
3460: PPUSH
3461: LD_STRING 13s_
3463: PPUSH
3464: CALL 64746 0 3
3468: ST_TO_ADDR
// if Cornel then
3469: LD_EXP 50
3473: IFFALSE 3491
// tmp := tmp ^ Cornel ;
3475: LD_ADDR_VAR 0 6
3479: PUSH
3480: LD_VAR 0 6
3484: PUSH
3485: LD_EXP 50
3489: ADD
3490: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3491: LD_ADDR_EXP 51
3495: PUSH
3496: LD_STRING Gary
3498: PPUSH
3499: LD_EXP 1
3503: NOT
3504: PPUSH
3505: LD_STRING 13s_
3507: PPUSH
3508: CALL 64746 0 3
3512: ST_TO_ADDR
// if Gary then
3513: LD_EXP 51
3517: IFFALSE 3535
// tmp := tmp ^ Gary ;
3519: LD_ADDR_VAR 0 6
3523: PUSH
3524: LD_VAR 0 6
3528: PUSH
3529: LD_EXP 51
3533: ADD
3534: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3535: LD_ADDR_EXP 52
3539: PUSH
3540: LD_STRING Frank
3542: PPUSH
3543: LD_EXP 1
3547: NOT
3548: PPUSH
3549: LD_STRING 13s_
3551: PPUSH
3552: CALL 64746 0 3
3556: ST_TO_ADDR
// if Frank then
3557: LD_EXP 52
3561: IFFALSE 3579
// tmp := tmp ^ Frank ;
3563: LD_ADDR_VAR 0 6
3567: PUSH
3568: LD_VAR 0 6
3572: PUSH
3573: LD_EXP 52
3577: ADD
3578: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3579: LD_ADDR_EXP 53
3583: PUSH
3584: LD_STRING Kikuchi
3586: PPUSH
3587: LD_EXP 1
3591: NOT
3592: PPUSH
3593: LD_STRING 13s_
3595: PPUSH
3596: CALL 64746 0 3
3600: ST_TO_ADDR
// if Kikuchi then
3601: LD_EXP 53
3605: IFFALSE 3623
// tmp := tmp ^ Kikuchi ;
3607: LD_ADDR_VAR 0 6
3611: PUSH
3612: LD_VAR 0 6
3616: PUSH
3617: LD_EXP 53
3621: ADD
3622: ST_TO_ADDR
// vip := tmp ;
3623: LD_ADDR_EXP 59
3627: PUSH
3628: LD_VAR 0 6
3632: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_VAR 0 6
3642: PUSH
3643: LD_STRING 13s_others
3645: PPUSH
3646: CALL_OW 31
3650: UNION
3651: ST_TO_ADDR
// if tmp < 20 then
3652: LD_VAR 0 6
3656: PUSH
3657: LD_INT 20
3659: LESS
3660: IFFALSE 3727
// for i = 1 to 20 - tmp do
3662: LD_ADDR_VAR 0 2
3666: PUSH
3667: DOUBLE
3668: LD_INT 1
3670: DEC
3671: ST_TO_ADDR
3672: LD_INT 20
3674: PUSH
3675: LD_VAR 0 6
3679: MINUS
3680: PUSH
3681: FOR_TO
3682: IFFALSE 3725
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3684: LD_INT 1
3686: PPUSH
3687: LD_VAR 0 2
3691: PUSH
3692: LD_INT 4
3694: MOD
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_INT 5
3702: PPUSH
3703: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3707: LD_ADDR_VAR 0 6
3711: PUSH
3712: LD_VAR 0 6
3716: PUSH
3717: CALL_OW 44
3721: ADD
3722: ST_TO_ADDR
// end ;
3723: GO 3681
3725: POP
3726: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3727: LD_ADDR_VAR 0 7
3731: PUSH
3732: LD_INT 22
3734: PUSH
3735: LD_INT 4
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 30
3744: PUSH
3745: LD_INT 0
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 69
3760: PUSH
3761: LD_INT 1
3763: ARRAY
3764: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3765: LD_ADDR_VAR 0 8
3769: PUSH
3770: LD_INT 22
3772: PUSH
3773: LD_INT 4
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 30
3782: PUSH
3783: LD_INT 6
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3803: LD_ADDR_VAR 0 9
3807: PUSH
3808: LD_INT 22
3810: PUSH
3811: LD_INT 4
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: PUSH
3818: LD_INT 30
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PPUSH
3832: CALL_OW 69
3836: PUSH
3837: LD_INT 1
3839: ARRAY
3840: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3841: LD_ADDR_VAR 0 10
3845: PUSH
3846: LD_INT 22
3848: PUSH
3849: LD_INT 4
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 30
3858: PUSH
3859: LD_INT 2
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PPUSH
3870: CALL_OW 69
3874: PUSH
3875: LD_INT 1
3877: ARRAY
3878: ST_TO_ADDR
// for i in tmp do
3879: LD_ADDR_VAR 0 2
3883: PUSH
3884: LD_VAR 0 6
3888: PUSH
3889: FOR_IN
3890: IFFALSE 4016
// begin cl := GetClass ( i ) ;
3892: LD_ADDR_VAR 0 5
3896: PUSH
3897: LD_VAR 0 2
3901: PPUSH
3902: CALL_OW 257
3906: ST_TO_ADDR
// if cl > 4 then
3907: LD_VAR 0 5
3911: PUSH
3912: LD_INT 4
3914: GREATER
3915: IFFALSE 3925
// cl := 1 ;
3917: LD_ADDR_VAR 0 5
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3925: LD_ADDR_VAR 0 3
3929: PUSH
3930: LD_VAR 0 9
3934: PUSH
3935: LD_VAR 0 7
3939: PUSH
3940: LD_VAR 0 10
3944: PUSH
3945: LD_VAR 0 8
3949: PUSH
3950: EMPTY
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: PUSH
3956: LD_VAR 0 5
3960: ARRAY
3961: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3962: LD_VAR 0 3
3966: PPUSH
3967: CALL_OW 313
3971: PUSH
3972: LD_INT 5
3974: LESS
3975: IFFALSE 3993
// PlaceHumanInUnit ( i , b ) else
3977: LD_VAR 0 2
3981: PPUSH
3982: LD_VAR 0 3
3986: PPUSH
3987: CALL_OW 52
3991: GO 4014
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3993: LD_VAR 0 2
3997: PPUSH
3998: LD_INT 58
4000: PPUSH
4001: LD_INT 91
4003: PPUSH
4004: LD_INT 6
4006: PPUSH
4007: LD_INT 0
4009: PPUSH
4010: CALL_OW 50
// end ;
4014: GO 3889
4016: POP
4017: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4018: LD_INT 2
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 12
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 71861 0 5
// veh := CreateVehicle ;
4037: LD_ADDR_VAR 0 4
4041: PUSH
4042: CALL_OW 45
4046: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4047: LD_VAR 0 4
4051: PPUSH
4052: LD_INT 4
4054: PPUSH
4055: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4059: LD_VAR 0 4
4063: PPUSH
4064: LD_INT 49
4066: PPUSH
4067: LD_INT 88
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4077: LD_VAR 0 4
4081: PPUSH
4082: LD_INT 1
4084: PPUSH
4085: LD_INT 100
4087: PPUSH
4088: CALL_OW 290
// uc_side := 0 ;
4092: LD_ADDR_OWVAR 20
4096: PUSH
4097: LD_INT 0
4099: ST_TO_ADDR
// uc_nation := 0 ;
4100: LD_ADDR_OWVAR 21
4104: PUSH
4105: LD_INT 0
4107: ST_TO_ADDR
// for i = 1 to 4 do
4108: LD_ADDR_VAR 0 2
4112: PUSH
4113: DOUBLE
4114: LD_INT 1
4116: DEC
4117: ST_TO_ADDR
4118: LD_INT 4
4120: PUSH
4121: FOR_TO
4122: IFFALSE 4153
// begin InitHc ;
4124: CALL_OW 19
// hc_class := class_apeman ;
4128: LD_ADDR_OWVAR 28
4132: PUSH
4133: LD_INT 12
4135: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4136: CALL_OW 44
4140: PPUSH
4141: LD_INT 13
4143: PPUSH
4144: LD_INT 0
4146: PPUSH
4147: CALL_OW 49
// end ;
4151: GO 4121
4153: POP
4154: POP
// end ; end_of_file
4155: LD_VAR 0 1
4159: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4160: LD_INT 0
4162: PPUSH
4163: PPUSH
4164: PPUSH
4165: PPUSH
4166: PPUSH
// side := 8 ;
4167: LD_ADDR_VAR 0 3
4171: PUSH
4172: LD_INT 8
4174: ST_TO_ADDR
// uc_side := side ;
4175: LD_ADDR_OWVAR 20
4179: PUSH
4180: LD_VAR 0 3
4184: ST_TO_ADDR
// uc_nation := 2 ;
4185: LD_ADDR_OWVAR 21
4189: PUSH
4190: LD_INT 2
4192: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: LD_INT 22
4200: PUSH
4201: LD_VAR 0 3
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 21
4212: PUSH
4213: LD_INT 3
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PPUSH
4224: CALL_OW 69
4228: PUSH
4229: FOR_IN
4230: IFFALSE 4246
// SetBLevel ( i , 10 ) ;
4232: LD_VAR 0 2
4236: PPUSH
4237: LD_INT 10
4239: PPUSH
4240: CALL_OW 241
4244: GO 4229
4246: POP
4247: POP
// if KurtStatus then
4248: LD_EXP 3
4252: IFFALSE 4275
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4254: LD_ADDR_EXP 60
4258: PUSH
4259: LD_STRING Kurt
4261: PPUSH
4262: LD_INT 0
4264: PPUSH
4265: LD_STRING 
4267: PPUSH
4268: CALL 64746 0 3
4272: ST_TO_ADDR
4273: GO 4297
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING AltKurt
4282: PPUSH
4283: LD_EXP 1
4287: NOT
4288: PPUSH
4289: LD_STRING 
4291: PPUSH
4292: CALL 64746 0 3
4296: ST_TO_ADDR
// if not Kurt then
4297: LD_EXP 60
4301: NOT
4302: IFFALSE 4328
// begin InitHc ;
4304: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4308: LD_INT 1
4310: PPUSH
4311: LD_INT 10
4313: PPUSH
4314: CALL_OW 381
// Kurt := CreateHuman ;
4318: LD_ADDR_EXP 60
4322: PUSH
4323: CALL_OW 44
4327: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4328: LD_EXP 60
4332: PPUSH
4333: LD_INT 324
4335: PPUSH
4336: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4340: LD_ADDR_EXP 61
4344: PUSH
4345: LD_STRING Kozlov
4347: PPUSH
4348: LD_INT 0
4350: PPUSH
4351: LD_STRING 
4353: PPUSH
4354: CALL 64746 0 3
4358: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4359: LD_EXP 61
4363: PPUSH
4364: LD_INT 22
4366: PUSH
4367: LD_INT 8
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 23
4376: PUSH
4377: LD_INT 3
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 30
4386: PUSH
4387: LD_INT 8
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: PPUSH
4399: CALL_OW 69
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4412: LD_EXP 61
4416: PPUSH
4417: LD_INT 3
4419: PPUSH
4420: LD_INT 10
4422: PPUSH
4423: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4427: LD_ADDR_VAR 0 5
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: LD_VAR 0 3
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 30
4446: PUSH
4447: LD_INT 32
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 58
4456: PUSH
4457: EMPTY
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: PPUSH
4465: CALL_OW 69
4469: ST_TO_ADDR
// for i = 1 to 10 do
4470: LD_ADDR_VAR 0 2
4474: PUSH
4475: DOUBLE
4476: LD_INT 1
4478: DEC
4479: ST_TO_ADDR
4480: LD_INT 10
4482: PUSH
4483: FOR_TO
4484: IFFALSE 4556
// begin uc_nation := nation_nature ;
4486: LD_ADDR_OWVAR 21
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4494: LD_ADDR_OWVAR 28
4498: PUSH
4499: LD_INT 15
4501: ST_TO_ADDR
// hc_gallery :=  ;
4502: LD_ADDR_OWVAR 33
4506: PUSH
4507: LD_STRING 
4509: ST_TO_ADDR
// hc_name :=  ;
4510: LD_ADDR_OWVAR 26
4514: PUSH
4515: LD_STRING 
4517: ST_TO_ADDR
// un := CreateHuman ;
4518: LD_ADDR_VAR 0 4
4522: PUSH
4523: CALL_OW 44
4527: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4528: LD_VAR 0 4
4532: PPUSH
4533: LD_VAR 0 5
4537: PUSH
4538: LD_VAR 0 5
4542: PUSH
4543: LD_VAR 0 2
4547: MINUS
4548: ARRAY
4549: PPUSH
4550: CALL_OW 52
// end ;
4554: GO 4483
4556: POP
4557: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4558: LD_ADDR_VAR 0 5
4562: PUSH
4563: LD_STRING 12_kurt_squad
4565: PPUSH
4566: CALL_OW 31
4570: ST_TO_ADDR
// if tmp then
4571: LD_VAR 0 5
4575: IFFALSE 4609
// for i in tmp do
4577: LD_ADDR_VAR 0 2
4581: PUSH
4582: LD_VAR 0 5
4586: PUSH
4587: FOR_IN
4588: IFFALSE 4607
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4590: LD_VAR 0 2
4594: PPUSH
4595: LD_INT 5
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 49
4605: GO 4587
4607: POP
4608: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4609: LD_INT 324
4611: PPUSH
4612: LD_INT 5
4614: PPUSH
4615: LD_STRING 
4617: PPUSH
4618: LD_INT 8
4620: PUSH
4621: LD_INT 9
4623: PUSH
4624: LD_INT 10
4626: PUSH
4627: EMPTY
4628: LIST
4629: LIST
4630: LIST
4631: PUSH
4632: LD_OWVAR 67
4636: ARRAY
4637: PPUSH
4638: LD_INT 3000
4640: PUSH
4641: LD_INT 500
4643: PUSH
4644: LD_INT 150
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PPUSH
4652: LD_INT 16
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 6
4660: PUSH
4661: LD_INT 8
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: PPUSH
4670: CALL 75270 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4674: LD_ADDR_EXP 102
4678: PUSH
4679: LD_EXP 102
4683: PPUSH
4684: LD_INT 3
4686: PPUSH
4687: LD_INT 22
4689: PUSH
4690: LD_VAR 0 3
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 23
4701: PUSH
4702: LD_INT 2
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 3
4711: PUSH
4712: LD_INT 21
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL_OW 69
4735: PUSH
4736: LD_EXP 60
4740: DIFF
4741: PPUSH
4742: CALL_OW 1
4746: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4747: LD_INT 1
4749: PPUSH
4750: LD_INT 7
4752: PPUSH
4753: CALL_OW 383
// Friend := CreateHuman ;
4757: LD_ADDR_EXP 62
4761: PUSH
4762: CALL_OW 44
4766: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4767: LD_INT 14
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 29
4778: PPUSH
4779: LD_INT 100
4781: PPUSH
4782: CALL 71861 0 5
// powellBomb := CreateVehicle ;
4786: LD_ADDR_EXP 63
4790: PUSH
4791: CALL_OW 45
4795: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4796: LD_EXP 63
4800: PPUSH
4801: LD_INT 90
4803: PPUSH
4804: LD_INT 51
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: CALL_OW 48
// end ;
4814: LD_VAR 0 1
4818: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
// if IsLive ( kozlov_fac ) then
4824: LD_INT 332
4826: PPUSH
4827: CALL_OW 300
4831: IFFALSE 4835
// exit ;
4833: GO 5402
// ComExitBuilding ( Kozlov ) ;
4835: LD_EXP 61
4839: PPUSH
4840: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4844: LD_EXP 61
4848: PPUSH
4849: CALL_OW 257
4853: PUSH
4854: LD_INT 2
4856: NONEQUAL
4857: IFFALSE 4892
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4859: LD_EXP 61
4863: PPUSH
4864: LD_INT 324
4866: PPUSH
4867: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4871: LD_EXP 61
4875: PPUSH
4876: LD_INT 2
4878: PPUSH
4879: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4883: LD_EXP 61
4887: PPUSH
4888: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: LD_INT 93
4902: PPUSH
4903: LD_INT 32
4905: PPUSH
4906: LD_INT 3
4908: PPUSH
4909: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4913: LD_INT 35
4915: PPUSH
4916: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4920: LD_INT 22
4922: PUSH
4923: LD_INT 8
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 30
4932: PUSH
4933: LD_INT 3
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: LD_INT 23
4942: PUSH
4943: LD_INT 3
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: LD_INT 57
4952: PUSH
4953: EMPTY
4954: LIST
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PPUSH
4962: CALL_OW 69
4966: IFFALSE 4913
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: LD_INT 22
4975: PUSH
4976: LD_INT 8
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 3
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 23
4995: PUSH
4996: LD_INT 3
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 57
5005: PUSH
5006: EMPTY
5007: LIST
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: PPUSH
5015: CALL_OW 69
5019: PUSH
5020: LD_INT 1
5022: ARRAY
5023: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5024: LD_INT 22
5026: PUSH
5027: LD_INT 8
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: PUSH
5034: LD_INT 23
5036: PUSH
5037: LD_INT 3
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 21
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: LIST
5058: PPUSH
5059: CALL_OW 69
5063: NOT
5064: IFFALSE 5142
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5066: LD_EXP 61
5070: PPUSH
5071: LD_INT 21
5073: PPUSH
5074: LD_INT 97
5076: PPUSH
5077: LD_INT 36
5079: PPUSH
5080: LD_INT 5
5082: PPUSH
5083: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5087: LD_INT 35
5089: PPUSH
5090: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5094: LD_INT 22
5096: PUSH
5097: LD_INT 8
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 23
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 21
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 57
5126: PUSH
5127: EMPTY
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: PPUSH
5136: CALL_OW 69
5140: IFFALSE 5087
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5142: LD_INT 22
5144: PUSH
5145: LD_INT 8
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: LD_INT 23
5154: PUSH
5155: LD_INT 3
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: PUSH
5162: LD_INT 30
5164: PUSH
5165: LD_INT 18
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: LIST
5176: PPUSH
5177: CALL_OW 69
5181: NOT
5182: IFFALSE 5260
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5184: LD_EXP 61
5188: PPUSH
5189: LD_INT 18
5191: PPUSH
5192: LD_INT 89
5194: PPUSH
5195: LD_INT 32
5197: PPUSH
5198: LD_INT 1
5200: PPUSH
5201: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5205: LD_INT 35
5207: PPUSH
5208: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5212: LD_INT 22
5214: PUSH
5215: LD_INT 8
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 23
5224: PUSH
5225: LD_INT 3
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: PUSH
5232: LD_INT 30
5234: PUSH
5235: LD_INT 18
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 57
5244: PUSH
5245: EMPTY
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: IFFALSE 5205
// end ; lab := kozlov_lab ;
5260: LD_ADDR_VAR 0 3
5264: PUSH
5265: LD_INT 336
5267: ST_TO_ADDR
// if not lab then
5268: LD_VAR 0 3
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5402
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5277: LD_EXP 61
5281: PPUSH
5282: LD_VAR 0 3
5286: PUSH
5287: LD_INT 1
5289: ARRAY
5290: PPUSH
5291: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5295: LD_EXP 61
5299: PPUSH
5300: LD_INT 4
5302: PPUSH
5303: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5307: LD_VAR 0 3
5311: PUSH
5312: LD_INT 1
5314: ARRAY
5315: PPUSH
5316: LD_INT 25
5318: PPUSH
5319: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5323: LD_INT 35
5325: PPUSH
5326: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5330: LD_INT 25
5332: PPUSH
5333: LD_INT 8
5335: PPUSH
5336: CALL_OW 321
5340: PUSH
5341: LD_INT 2
5343: EQUAL
5344: IFFALSE 5323
// ComExitBuilding ( Kozlov ) ;
5346: LD_EXP 61
5350: PPUSH
5351: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5355: LD_EXP 61
5359: PPUSH
5360: LD_VAR 0 2
5364: PPUSH
5365: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5369: LD_EXP 61
5373: PPUSH
5374: LD_INT 3
5376: PPUSH
5377: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5381: LD_VAR 0 2
5385: PPUSH
5386: LD_INT 23
5388: PPUSH
5389: LD_INT 3
5391: PPUSH
5392: LD_INT 1
5394: PPUSH
5395: LD_INT 48
5397: PPUSH
5398: CALL_OW 125
// end ;
5402: LD_VAR 0 1
5406: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5407: LD_EXP 22
5411: NOT
5412: PUSH
5413: LD_EXP 15
5417: PUSH
5418: LD_INT 6
5420: GREATEREQUAL
5421: AND
5422: IFFALSE 5503
5424: GO 5426
5426: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5427: LD_INT 3
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: CALL 58539 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5437: LD_INT 3
5439: PPUSH
5440: LD_INT 14
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 1
5448: PUSH
5449: LD_INT 28
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: LIST
5456: LIST
5457: PUSH
5458: LD_INT 14
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 28
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL 58402 0 2
// end ;
5503: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5504: LD_EXP 22
5508: NOT
5509: PUSH
5510: LD_EXP 15
5514: PUSH
5515: LD_INT 6
5517: GREATEREQUAL
5518: AND
5519: PUSH
5520: LD_INT 3
5522: PPUSH
5523: LD_INT 1
5525: PPUSH
5526: CALL 59820 0 2
5530: NOT
5531: AND
5532: IFFALSE 6372
5534: GO 5536
5536: DISABLE
5537: LD_INT 0
5539: PPUSH
5540: PPUSH
5541: PPUSH
// begin enable ;
5542: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5543: LD_INT 22
5545: PUSH
5546: LD_INT 8
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PUSH
5553: LD_INT 23
5555: PUSH
5556: LD_INT 2
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PUSH
5563: LD_INT 30
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: LIST
5577: PPUSH
5578: CALL_OW 69
5582: NOT
5583: IFFALSE 5587
// exit ;
5585: GO 6372
// if Prob ( 40 ) then
5587: LD_INT 40
5589: PPUSH
5590: CALL_OW 13
5594: IFFALSE 5721
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5596: LD_INT 3
5598: PPUSH
5599: LD_INT 14
5601: PUSH
5602: LD_INT 1
5604: PUSH
5605: LD_INT 2
5607: PUSH
5608: LD_INT 28
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 14
5619: PUSH
5620: LD_INT 1
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: LD_INT 28
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: PUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 26
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: PPUSH
5715: CALL 58402 0 2
// end else
5719: GO 5912
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5721: LD_INT 3
5723: PPUSH
5724: LD_INT 14
5726: PUSH
5727: LD_INT 1
5729: PUSH
5730: LD_INT 2
5732: PUSH
5733: LD_INT 27
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: LD_INT 26
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_OWVAR 67
5751: ARRAY
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 14
5761: PUSH
5762: LD_INT 1
5764: PUSH
5765: LD_INT 2
5767: PUSH
5768: LD_INT 27
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: LD_INT 26
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: PUSH
5782: LD_OWVAR 67
5786: ARRAY
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: LIST
5793: PUSH
5794: LD_INT 14
5796: PUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 2
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 26
5808: PUSH
5809: LD_INT 29
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: PUSH
5817: LD_OWVAR 67
5821: ARRAY
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 13
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 26
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: LD_INT 29
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 13
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 29
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 14
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: LD_INT 2
5890: PUSH
5891: LD_INT 26
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: PPUSH
5908: CALL 58402 0 2
// end ; repeat wait ( 0 0$1 ) ;
5912: LD_INT 35
5914: PPUSH
5915: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5919: LD_INT 3
5921: PPUSH
5922: LD_INT 1
5924: PPUSH
5925: CALL 59820 0 2
5929: PUSH
5930: LD_INT 6
5932: GREATEREQUAL
5933: IFFALSE 5912
// wait ( 0 0$30 ) ;
5935: LD_INT 1050
5937: PPUSH
5938: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5942: LD_ADDR_VAR 0 2
5946: PUSH
5947: LD_INT 3
5949: PPUSH
5950: LD_INT 1
5952: PPUSH
5953: CALL 59820 0 2
5957: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5958: LD_ADDR_EXP 121
5962: PUSH
5963: LD_EXP 121
5967: PPUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_EXP 121
5975: PUSH
5976: LD_INT 3
5978: ARRAY
5979: PUSH
5980: LD_VAR 0 2
5984: DIFF
5985: PPUSH
5986: CALL_OW 1
5990: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5991: LD_ADDR_VAR 0 3
5995: PUSH
5996: LD_INT 0
5998: PPUSH
5999: LD_INT 2
6001: PPUSH
6002: CALL_OW 12
6006: ST_TO_ADDR
// if target then
6007: LD_VAR 0 3
6011: IFFALSE 6139
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6013: LD_ADDR_VAR 0 2
6017: PUSH
6018: LD_VAR 0 2
6022: PPUSH
6023: LD_INT 24
6025: PUSH
6026: LD_INT 250
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 72
6037: ST_TO_ADDR
// for i in tmp do
6038: LD_ADDR_VAR 0 1
6042: PUSH
6043: LD_VAR 0 2
6047: PUSH
6048: FOR_IN
6049: IFFALSE 6089
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6051: LD_VAR 0 1
6055: PPUSH
6056: LD_INT 89
6058: PPUSH
6059: LD_INT 71
6061: PPUSH
6062: CALL_OW 297
6066: PUSH
6067: LD_INT 9
6069: GREATER
6070: IFFALSE 6087
// ComMoveXY ( i , 89 , 71 ) ;
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 111
6087: GO 6048
6089: POP
6090: POP
// wait ( 0 0$1 ) ;
6091: LD_INT 35
6093: PPUSH
6094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 92
6105: PUSH
6106: LD_INT 89
6108: PUSH
6109: LD_INT 71
6111: PUSH
6112: LD_INT 9
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: PPUSH
6121: CALL_OW 72
6125: PUSH
6126: LD_VAR 0 2
6130: PUSH
6131: LD_INT 1
6133: MINUS
6134: GREATEREQUAL
6135: IFFALSE 6013
// end else
6137: GO 6263
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6139: LD_ADDR_VAR 0 2
6143: PUSH
6144: LD_VAR 0 2
6148: PPUSH
6149: LD_INT 24
6151: PUSH
6152: LD_INT 250
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 72
6163: ST_TO_ADDR
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 125
6184: PPUSH
6185: LD_INT 129
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 125 , 129 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 125
6234: PUSH
6235: LD_INT 129
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6139
// end ; repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// for i in tmp do
6270: LD_ADDR_VAR 0 1
6274: PUSH
6275: LD_VAR 0 2
6279: PUSH
6280: FOR_IN
6281: IFFALSE 6363
// begin if GetLives ( i ) > 251 then
6283: LD_VAR 0 1
6287: PPUSH
6288: CALL_OW 256
6292: PUSH
6293: LD_INT 251
6295: GREATER
6296: IFFALSE 6334
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6298: LD_VAR 0 1
6302: PPUSH
6303: LD_INT 81
6305: PUSH
6306: LD_INT 8
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: PPUSH
6313: CALL_OW 69
6317: PPUSH
6318: LD_VAR 0 1
6322: PPUSH
6323: CALL_OW 74
6327: PPUSH
6328: CALL_OW 115
6332: GO 6361
// if IsDead ( i ) then
6334: LD_VAR 0 1
6338: PPUSH
6339: CALL_OW 301
6343: IFFALSE 6361
// tmp := tmp diff i ;
6345: LD_ADDR_VAR 0 2
6349: PUSH
6350: LD_VAR 0 2
6354: PUSH
6355: LD_VAR 0 1
6359: DIFF
6360: ST_TO_ADDR
// end ;
6361: GO 6280
6363: POP
6364: POP
// until not tmp ;
6365: LD_VAR 0 2
6369: NOT
6370: IFFALSE 6263
// end ;
6372: PPOPN 3
6374: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6375: LD_EXP 22
6379: NOT
6380: PUSH
6381: LD_EXP 15
6385: PUSH
6386: LD_INT 6
6388: GREATEREQUAL
6389: AND
6390: PUSH
6391: LD_OWVAR 67
6395: PUSH
6396: LD_INT 1
6398: GREATER
6399: AND
6400: IFFALSE 6917
6402: GO 6404
6404: DISABLE
6405: LD_INT 0
6407: PPUSH
6408: PPUSH
6409: PPUSH
// begin enable ;
6410: ENABLE
// tmp := [ ] ;
6411: LD_ADDR_VAR 0 3
6415: PUSH
6416: EMPTY
6417: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6418: LD_ADDR_VAR 0 1
6422: PUSH
6423: DOUBLE
6424: LD_INT 1
6426: DEC
6427: ST_TO_ADDR
6428: LD_INT 4
6430: PUSH
6431: LD_INT 6
6433: PUSH
6434: LD_INT 7
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_OWVAR 67
6446: ARRAY
6447: PUSH
6448: FOR_TO
6449: IFFALSE 6609
// begin uc_side := 8 ;
6451: LD_ADDR_OWVAR 20
6455: PUSH
6456: LD_INT 8
6458: ST_TO_ADDR
// uc_nation := 2 ;
6459: LD_ADDR_OWVAR 21
6463: PUSH
6464: LD_INT 2
6466: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6467: LD_INT 13
6469: PUSH
6470: LD_INT 14
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 1
6479: PPUSH
6480: LD_INT 2
6482: PPUSH
6483: CALL_OW 12
6487: ARRAY
6488: PPUSH
6489: LD_INT 1
6491: PPUSH
6492: LD_INT 5
6494: PPUSH
6495: LD_INT 27
6497: PUSH
6498: LD_INT 28
6500: PUSH
6501: LD_INT 26
6503: PUSH
6504: LD_INT 25
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 88
6527: PPUSH
6528: CALL 71861 0 5
// un := CreateVehicle ;
6532: LD_ADDR_VAR 0 2
6536: PUSH
6537: CALL_OW 45
6541: ST_TO_ADDR
// tmp := tmp ^ un ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: LD_VAR 0 3
6551: PUSH
6552: LD_VAR 0 2
6556: ADD
6557: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6558: LD_VAR 0 2
6562: PPUSH
6563: LD_INT 3
6565: PPUSH
6566: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6570: LD_VAR 0 2
6574: PPUSH
6575: LD_INT 30
6577: PPUSH
6578: LD_INT 0
6580: PPUSH
6581: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6585: LD_VAR 0 2
6589: PPUSH
6590: LD_INT 16
6592: PPUSH
6593: LD_INT 11
6595: PPUSH
6596: CALL_OW 111
// wait ( 0 0$2 ) ;
6600: LD_INT 70
6602: PPUSH
6603: CALL_OW 67
// end ;
6607: GO 6448
6609: POP
6610: POP
// for i = 1 to Difficulty do
6611: LD_ADDR_VAR 0 1
6615: PUSH
6616: DOUBLE
6617: LD_INT 1
6619: DEC
6620: ST_TO_ADDR
6621: LD_OWVAR 67
6625: PUSH
6626: FOR_TO
6627: IFFALSE 6752
// begin uc_side := 8 ;
6629: LD_ADDR_OWVAR 20
6633: PUSH
6634: LD_INT 8
6636: ST_TO_ADDR
// uc_nation := 2 ;
6637: LD_ADDR_OWVAR 21
6641: PUSH
6642: LD_INT 2
6644: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 8
6650: PPUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 8
6656: PUSH
6657: LD_INT 9
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: LIST
6664: PUSH
6665: LD_OWVAR 67
6669: ARRAY
6670: PPUSH
6671: CALL_OW 380
// un := CreateHuman ;
6675: LD_ADDR_VAR 0 2
6679: PUSH
6680: CALL_OW 44
6684: ST_TO_ADDR
// tmp := tmp ^ un ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_VAR 0 3
6694: PUSH
6695: LD_VAR 0 2
6699: ADD
6700: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6701: LD_VAR 0 2
6705: PPUSH
6706: LD_INT 3
6708: PPUSH
6709: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6713: LD_VAR 0 2
6717: PPUSH
6718: LD_INT 30
6720: PPUSH
6721: LD_INT 0
6723: PPUSH
6724: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6728: LD_VAR 0 2
6732: PPUSH
6733: LD_INT 16
6735: PPUSH
6736: LD_INT 11
6738: PPUSH
6739: CALL_OW 111
// wait ( 0 0$2 ) ;
6743: LD_INT 70
6745: PPUSH
6746: CALL_OW 67
// end ;
6750: GO 6626
6752: POP
6753: POP
// repeat wait ( 0 0$1 ) ;
6754: LD_INT 35
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 1
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6908
// begin if GetLives ( i ) > 250 then
6774: LD_VAR 0 1
6778: PPUSH
6779: CALL_OW 256
6783: PUSH
6784: LD_INT 250
6786: GREATER
6787: IFFALSE 6879
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6789: LD_INT 81
6791: PUSH
6792: LD_INT 8
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: LD_INT 91
6801: PUSH
6802: LD_VAR 0 1
6806: PUSH
6807: LD_INT 10
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PPUSH
6819: CALL_OW 69
6823: NOT
6824: IFFALSE 6843
// ComAgressiveMove ( i , 67 , 110 ) else
6826: LD_VAR 0 1
6830: PPUSH
6831: LD_INT 67
6833: PPUSH
6834: LD_INT 110
6836: PPUSH
6837: CALL_OW 114
6841: GO 6877
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6843: LD_VAR 0 1
6847: PPUSH
6848: LD_INT 81
6850: PUSH
6851: LD_INT 8
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PPUSH
6858: CALL_OW 69
6862: PPUSH
6863: LD_VAR 0 1
6867: PPUSH
6868: CALL_OW 74
6872: PPUSH
6873: CALL_OW 115
// end else
6877: GO 6906
// if IsDead ( i ) then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 301
6888: IFFALSE 6906
// tmp := tmp diff i ;
6890: LD_ADDR_VAR 0 3
6894: PUSH
6895: LD_VAR 0 3
6899: PUSH
6900: LD_VAR 0 1
6904: DIFF
6905: ST_TO_ADDR
// end ;
6906: GO 6771
6908: POP
6909: POP
// until not tmp ;
6910: LD_VAR 0 3
6914: NOT
6915: IFFALSE 6754
// end ; end_of_file
6917: PPOPN 3
6919: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6920: LD_INT 0
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
// side := 3 ;
6931: LD_ADDR_VAR 0 6
6935: PUSH
6936: LD_INT 3
6938: ST_TO_ADDR
// uc_side := side ;
6939: LD_ADDR_OWVAR 20
6943: PUSH
6944: LD_VAR 0 6
6948: ST_TO_ADDR
// uc_nation := 3 ;
6949: LD_ADDR_OWVAR 21
6953: PUSH
6954: LD_INT 3
6956: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6957: LD_ADDR_VAR 0 2
6961: PUSH
6962: LD_INT 22
6964: PUSH
6965: LD_VAR 0 6
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 21
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: PUSH
6993: FOR_IN
6994: IFFALSE 7010
// SetBLevel ( i , 10 ) ;
6996: LD_VAR 0 2
7000: PPUSH
7001: LD_INT 10
7003: PPUSH
7004: CALL_OW 241
7008: GO 6993
7010: POP
7011: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7012: LD_ADDR_VAR 0 9
7016: PUSH
7017: LD_INT 22
7019: PUSH
7020: LD_VAR 0 6
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 30
7031: PUSH
7032: LD_INT 34
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PPUSH
7043: CALL_OW 69
7047: ST_TO_ADDR
// if teleport then
7048: LD_VAR 0 9
7052: IFFALSE 7073
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7054: LD_VAR 0 9
7058: PUSH
7059: LD_INT 1
7061: ARRAY
7062: PPUSH
7063: LD_INT 123
7065: PPUSH
7066: LD_INT 122
7068: PPUSH
7069: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7073: LD_ADDR_EXP 64
7077: PUSH
7078: LD_STRING Platonov
7080: PPUSH
7081: CALL_OW 25
7085: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7086: LD_ADDR_EXP 65
7090: PUSH
7091: LD_STRING Kovalyuk
7093: PPUSH
7094: CALL_OW 25
7098: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7099: LD_ADDR_EXP 67
7103: PUSH
7104: LD_STRING Yakotich
7106: PPUSH
7107: LD_EXP 1
7111: NOT
7112: PPUSH
7113: LD_STRING 09_
7115: PPUSH
7116: CALL 64746 0 3
7120: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7121: LD_ADDR_EXP 66
7125: PUSH
7126: LD_STRING Bystrov
7128: PPUSH
7129: CALL_OW 25
7133: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7134: LD_ADDR_EXP 68
7138: PUSH
7139: LD_STRING Gleb
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7147: LD_STRING 03_Cornel
7149: PPUSH
7150: CALL_OW 28
7154: IFFALSE 7202
// begin Bierezov := NewCharacter ( Mikhail ) ;
7156: LD_ADDR_EXP 69
7160: PUSH
7161: LD_STRING Mikhail
7163: PPUSH
7164: CALL_OW 25
7168: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7169: LD_EXP 69
7173: PPUSH
7174: LD_INT 197
7176: PPUSH
7177: LD_INT 111
7179: PPUSH
7180: LD_INT 9
7182: PPUSH
7183: LD_INT 0
7185: PPUSH
7186: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 3
7197: PPUSH
7198: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 126
7209: PPUSH
7210: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7214: LD_EXP 65
7218: PPUSH
7219: LD_INT 134
7221: PPUSH
7222: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7226: LD_EXP 67
7230: PPUSH
7231: LD_INT 197
7233: PPUSH
7234: LD_INT 111
7236: PPUSH
7237: LD_INT 9
7239: PPUSH
7240: LD_INT 0
7242: PPUSH
7243: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7247: LD_EXP 66
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7268: LD_EXP 68
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7289: LD_ADDR_VAR 0 5
7293: PUSH
7294: LD_INT 126
7296: PPUSH
7297: LD_INT 4
7299: PPUSH
7300: LD_STRING zhukov
7302: PPUSH
7303: LD_INT 9
7305: PUSH
7306: LD_INT 10
7308: PUSH
7309: LD_INT 10
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: LIST
7316: PUSH
7317: LD_OWVAR 67
7321: ARRAY
7322: PPUSH
7323: LD_INT 90000
7325: PUSH
7326: LD_INT 1000
7328: PUSH
7329: LD_INT 300
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: LIST
7336: PPUSH
7337: LD_INT 21
7339: PUSH
7340: LD_INT 8
7342: PUSH
7343: LD_INT 13
7345: PUSH
7346: LD_INT 8
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL 75270 0 6
7359: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7360: LD_ADDR_VAR 0 4
7364: PUSH
7365: LD_INT 267
7367: PPUSH
7368: CALL_OW 274
7372: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7373: LD_VAR 0 4
7377: PPUSH
7378: LD_INT 1
7380: PPUSH
7381: LD_INT 5000
7383: PPUSH
7384: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7388: LD_VAR 0 4
7392: PPUSH
7393: LD_INT 2
7395: PPUSH
7396: LD_INT 200
7398: PPUSH
7399: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7403: LD_VAR 0 4
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: LD_INT 200
7413: PPUSH
7414: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7418: LD_ADDR_EXP 102
7422: PUSH
7423: LD_EXP 102
7427: PPUSH
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 5
7435: PUSH
7436: LD_INT 22
7438: PUSH
7439: LD_VAR 0 6
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 21
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PPUSH
7469: CALL_OW 69
7473: UNION
7474: PUSH
7475: LD_EXP 64
7479: DIFF
7480: PPUSH
7481: CALL_OW 1
7485: ST_TO_ADDR
// behemoths := [ ] ;
7486: LD_ADDR_EXP 72
7490: PUSH
7491: EMPTY
7492: ST_TO_ADDR
// behemothBuilders := [ ] ;
7493: LD_ADDR_EXP 73
7497: PUSH
7498: EMPTY
7499: ST_TO_ADDR
// if Kovalyuk then
7500: LD_EXP 65
7504: IFFALSE 7526
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7506: LD_ADDR_EXP 73
7510: PUSH
7511: LD_EXP 73
7515: PPUSH
7516: LD_EXP 65
7520: PPUSH
7521: CALL 107609 0 2
7525: ST_TO_ADDR
// j := 3 ;
7526: LD_ADDR_VAR 0 3
7530: PUSH
7531: LD_INT 3
7533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7534: LD_ADDR_VAR 0 2
7538: PUSH
7539: LD_INT 22
7541: PUSH
7542: LD_INT 3
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 25
7551: PUSH
7552: LD_INT 3
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: PPUSH
7563: CALL_OW 69
7567: PUSH
7568: LD_EXP 65
7572: DIFF
7573: PUSH
7574: FOR_IN
7575: IFFALSE 7625
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7577: LD_ADDR_EXP 73
7581: PUSH
7582: LD_EXP 73
7586: PPUSH
7587: LD_VAR 0 2
7591: PPUSH
7592: CALL 107609 0 2
7596: ST_TO_ADDR
// j := j - 1 ;
7597: LD_ADDR_VAR 0 3
7601: PUSH
7602: LD_VAR 0 3
7606: PUSH
7607: LD_INT 1
7609: MINUS
7610: ST_TO_ADDR
// if j = 0 then
7611: LD_VAR 0 3
7615: PUSH
7616: LD_INT 0
7618: EQUAL
7619: IFFALSE 7623
// break ;
7621: GO 7625
// end ;
7623: GO 7574
7625: POP
7626: POP
// end ;
7627: LD_VAR 0 1
7631: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7632: LD_INT 0
7634: PPUSH
7635: PPUSH
7636: PPUSH
7637: PPUSH
7638: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7639: LD_ADDR_VAR 0 4
7643: PUSH
7644: LD_INT 209
7646: PUSH
7647: LD_INT 149
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: LD_INT 219
7656: PUSH
7657: LD_INT 154
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PUSH
7664: LD_INT 223
7666: PUSH
7667: LD_INT 149
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 232
7676: PUSH
7677: LD_INT 155
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: LIST
7688: LIST
7689: ST_TO_ADDR
// if not behemothBuilders then
7690: LD_EXP 73
7694: NOT
7695: IFFALSE 7699
// exit ;
7697: GO 7803
// j := 1 ;
7699: LD_ADDR_VAR 0 3
7703: PUSH
7704: LD_INT 1
7706: ST_TO_ADDR
// for i in behemothBuilders do
7707: LD_ADDR_VAR 0 2
7711: PUSH
7712: LD_EXP 73
7716: PUSH
7717: FOR_IN
7718: IFFALSE 7801
// begin if IsInUnit ( i ) then
7720: LD_VAR 0 2
7724: PPUSH
7725: CALL_OW 310
7729: IFFALSE 7740
// ComExitBuilding ( i ) ;
7731: LD_VAR 0 2
7735: PPUSH
7736: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7740: LD_VAR 0 2
7744: PPUSH
7745: LD_INT 37
7747: PPUSH
7748: LD_VAR 0 4
7752: PUSH
7753: LD_VAR 0 3
7757: ARRAY
7758: PUSH
7759: LD_INT 1
7761: ARRAY
7762: PPUSH
7763: LD_VAR 0 4
7767: PUSH
7768: LD_VAR 0 3
7772: ARRAY
7773: PUSH
7774: LD_INT 2
7776: ARRAY
7777: PPUSH
7778: LD_INT 0
7780: PPUSH
7781: CALL_OW 230
// j := j + 1 ;
7785: LD_ADDR_VAR 0 3
7789: PUSH
7790: LD_VAR 0 3
7794: PUSH
7795: LD_INT 1
7797: PLUS
7798: ST_TO_ADDR
// end ;
7799: GO 7717
7801: POP
7802: POP
// end ;
7803: LD_VAR 0 1
7807: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7808: LD_INT 24
7810: PPUSH
7811: LD_INT 30
7813: PUSH
7814: LD_INT 37
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PPUSH
7821: CALL_OW 70
7825: IFFALSE 7838
7827: GO 7829
7829: DISABLE
// behemothUnderConstruct := true ;
7830: LD_ADDR_EXP 26
7834: PUSH
7835: LD_INT 1
7837: ST_TO_ADDR
7838: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7839: LD_INT 3
7841: PPUSH
7842: CALL 107657 0 1
7846: PUSH
7847: LD_INT 22
7849: PUSH
7850: LD_INT 3
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: LD_INT 30
7859: PUSH
7860: LD_INT 37
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: PPUSH
7871: CALL_OW 69
7875: NOT
7876: AND
7877: IFFALSE 8063
7879: GO 7881
7881: DISABLE
7882: LD_INT 0
7884: PPUSH
7885: PPUSH
// begin enable ;
7886: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7887: LD_ADDR_VAR 0 2
7891: PUSH
7892: LD_INT 3
7894: PPUSH
7895: CALL 107657 0 1
7899: ST_TO_ADDR
// for i in tmp do
7900: LD_ADDR_VAR 0 1
7904: PUSH
7905: LD_VAR 0 2
7909: PUSH
7910: FOR_IN
7911: IFFALSE 8061
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7913: LD_VAR 0 1
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 308
7925: PUSH
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 110
7935: PUSH
7936: LD_INT 2
7938: EQUAL
7939: NOT
7940: AND
7941: IFFALSE 7955
// SetTag ( i , 2 ) ;
7943: LD_VAR 0 1
7947: PPUSH
7948: LD_INT 2
7950: PPUSH
7951: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7955: LD_INT 81
7957: PUSH
7958: LD_INT 3
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PUSH
7965: LD_INT 91
7967: PUSH
7968: LD_VAR 0 1
7972: PUSH
7973: LD_INT 12
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: NOT
7990: PUSH
7991: LD_VAR 0 1
7995: PPUSH
7996: CALL_OW 110
8000: PUSH
8001: LD_INT 2
8003: EQUAL
8004: NOT
8005: AND
8006: IFFALSE 8025
// ComAgressiveMove ( i , 64 , 93 ) else
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_INT 64
8015: PPUSH
8016: LD_INT 93
8018: PPUSH
8019: CALL_OW 114
8023: GO 8059
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8025: LD_VAR 0 1
8029: PPUSH
8030: LD_INT 81
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: PPUSH
8040: CALL_OW 69
8044: PPUSH
8045: LD_VAR 0 1
8049: PPUSH
8050: CALL_OW 74
8054: PPUSH
8055: CALL_OW 115
// end ;
8059: GO 7910
8061: POP
8062: POP
// end ;
8063: PPOPN 2
8065: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8066: LD_INT 0
8068: PPUSH
8069: PPUSH
8070: PPUSH
// result := [ ] ;
8071: LD_ADDR_VAR 0 2
8075: PUSH
8076: EMPTY
8077: ST_TO_ADDR
// uc_side := 6 ;
8078: LD_ADDR_OWVAR 20
8082: PUSH
8083: LD_INT 6
8085: ST_TO_ADDR
// uc_nation := 3 ;
8086: LD_ADDR_OWVAR 21
8090: PUSH
8091: LD_INT 3
8093: ST_TO_ADDR
// case strength of 1 :
8094: LD_VAR 0 1
8098: PUSH
8099: LD_INT 1
8101: DOUBLE
8102: EQUAL
8103: IFTRUE 8107
8105: GO 8245
8107: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8108: LD_ADDR_VAR 0 3
8112: PUSH
8113: DOUBLE
8114: LD_INT 1
8116: DEC
8117: ST_TO_ADDR
8118: LD_INT 4
8120: PUSH
8121: LD_INT 5
8123: PUSH
8124: LD_INT 6
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: PUSH
8132: LD_OWVAR 67
8136: ARRAY
8137: PUSH
8138: FOR_TO
8139: IFFALSE 8241
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8141: LD_INT 22
8143: PUSH
8144: LD_INT 24
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_VAR 0 3
8155: PUSH
8156: LD_INT 2
8158: MOD
8159: PUSH
8160: LD_INT 1
8162: PLUS
8163: ARRAY
8164: PPUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: PUSH
8175: LD_INT 1
8177: PPUSH
8178: LD_INT 2
8180: PPUSH
8181: CALL_OW 12
8185: ARRAY
8186: PPUSH
8187: LD_INT 3
8189: PPUSH
8190: LD_INT 43
8192: PUSH
8193: LD_INT 44
8195: PUSH
8196: LD_INT 45
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 1
8206: PPUSH
8207: LD_INT 3
8209: PPUSH
8210: CALL_OW 12
8214: ARRAY
8215: PPUSH
8216: LD_INT 80
8218: PPUSH
8219: CALL 71861 0 5
// result := result union CreateVehicle ;
8223: LD_ADDR_VAR 0 2
8227: PUSH
8228: LD_VAR 0 2
8232: PUSH
8233: CALL_OW 45
8237: UNION
8238: ST_TO_ADDR
// end ;
8239: GO 8138
8241: POP
8242: POP
// end ; 2 :
8243: GO 9189
8245: LD_INT 2
8247: DOUBLE
8248: EQUAL
8249: IFTRUE 8253
8251: GO 8409
8253: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8254: LD_ADDR_VAR 0 3
8258: PUSH
8259: DOUBLE
8260: LD_INT 1
8262: DEC
8263: ST_TO_ADDR
8264: LD_INT 5
8266: PUSH
8267: LD_INT 6
8269: PUSH
8270: LD_INT 7
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: LIST
8277: PUSH
8278: LD_OWVAR 67
8282: ARRAY
8283: PUSH
8284: FOR_TO
8285: IFFALSE 8405
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8287: LD_INT 22
8289: PUSH
8290: LD_INT 24
8292: PUSH
8293: LD_INT 24
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: LIST
8300: PUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_INT 3
8308: MOD
8309: PUSH
8310: LD_INT 1
8312: PLUS
8313: ARRAY
8314: PPUSH
8315: LD_INT 1
8317: PUSH
8318: LD_INT 3
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_INT 2
8330: PPUSH
8331: CALL_OW 12
8335: ARRAY
8336: PPUSH
8337: LD_INT 3
8339: PPUSH
8340: LD_INT 43
8342: PUSH
8343: LD_INT 44
8345: PUSH
8346: LD_INT 45
8348: PUSH
8349: LD_INT 44
8351: PUSH
8352: LD_INT 46
8354: PUSH
8355: LD_INT 46
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: PUSH
8366: LD_VAR 0 3
8370: PUSH
8371: LD_INT 6
8373: MOD
8374: PUSH
8375: LD_INT 1
8377: PLUS
8378: ARRAY
8379: PPUSH
8380: LD_INT 80
8382: PPUSH
8383: CALL 71861 0 5
// result := result union CreateVehicle ;
8387: LD_ADDR_VAR 0 2
8391: PUSH
8392: LD_VAR 0 2
8396: PUSH
8397: CALL_OW 45
8401: UNION
8402: ST_TO_ADDR
// end ;
8403: GO 8284
8405: POP
8406: POP
// end ; 3 :
8407: GO 9189
8409: LD_INT 3
8411: DOUBLE
8412: EQUAL
8413: IFTRUE 8417
8415: GO 8573
8417: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8418: LD_ADDR_VAR 0 3
8422: PUSH
8423: DOUBLE
8424: LD_INT 1
8426: DEC
8427: ST_TO_ADDR
8428: LD_INT 5
8430: PUSH
8431: LD_INT 7
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_OWVAR 67
8446: ARRAY
8447: PUSH
8448: FOR_TO
8449: IFFALSE 8569
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8451: LD_INT 22
8453: PUSH
8454: LD_INT 24
8456: PUSH
8457: LD_INT 24
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: LIST
8464: PUSH
8465: LD_VAR 0 3
8469: PUSH
8470: LD_INT 3
8472: MOD
8473: PUSH
8474: LD_INT 1
8476: PLUS
8477: ARRAY
8478: PPUSH
8479: LD_INT 1
8481: PUSH
8482: LD_INT 3
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PUSH
8489: LD_INT 1
8491: PPUSH
8492: LD_INT 2
8494: PPUSH
8495: CALL_OW 12
8499: ARRAY
8500: PPUSH
8501: LD_INT 3
8503: PPUSH
8504: LD_INT 43
8506: PUSH
8507: LD_INT 47
8509: PUSH
8510: LD_INT 45
8512: PUSH
8513: LD_INT 45
8515: PUSH
8516: LD_INT 46
8518: PUSH
8519: LD_INT 46
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: PUSH
8530: LD_VAR 0 3
8534: PUSH
8535: LD_INT 6
8537: MOD
8538: PUSH
8539: LD_INT 1
8541: PLUS
8542: ARRAY
8543: PPUSH
8544: LD_INT 80
8546: PPUSH
8547: CALL 71861 0 5
// result := result union CreateVehicle ;
8551: LD_ADDR_VAR 0 2
8555: PUSH
8556: LD_VAR 0 2
8560: PUSH
8561: CALL_OW 45
8565: UNION
8566: ST_TO_ADDR
// end ;
8567: GO 8448
8569: POP
8570: POP
// end ; 4 :
8571: GO 9189
8573: LD_INT 4
8575: DOUBLE
8576: EQUAL
8577: IFTRUE 8581
8579: GO 9188
8581: POP
// begin uc_nation := 3 ;
8582: LD_ADDR_OWVAR 21
8586: PUSH
8587: LD_INT 3
8589: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8590: LD_ADDR_VAR 0 3
8594: PUSH
8595: DOUBLE
8596: LD_INT 1
8598: DEC
8599: ST_TO_ADDR
8600: LD_INT 6
8602: PUSH
8603: LD_INT 8
8605: PUSH
8606: LD_INT 9
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: LIST
8613: PUSH
8614: LD_OWVAR 67
8618: ARRAY
8619: PUSH
8620: FOR_TO
8621: IFFALSE 8741
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8623: LD_INT 22
8625: PUSH
8626: LD_INT 24
8628: PUSH
8629: LD_INT 24
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: LIST
8636: PUSH
8637: LD_VAR 0 3
8641: PUSH
8642: LD_INT 3
8644: MOD
8645: PUSH
8646: LD_INT 1
8648: PLUS
8649: ARRAY
8650: PPUSH
8651: LD_INT 1
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 1
8663: PPUSH
8664: LD_INT 2
8666: PPUSH
8667: CALL_OW 12
8671: ARRAY
8672: PPUSH
8673: LD_INT 3
8675: PPUSH
8676: LD_INT 45
8678: PUSH
8679: LD_INT 47
8681: PUSH
8682: LD_INT 47
8684: PUSH
8685: LD_INT 45
8687: PUSH
8688: LD_INT 46
8690: PUSH
8691: LD_INT 46
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_VAR 0 3
8706: PUSH
8707: LD_INT 6
8709: MOD
8710: PUSH
8711: LD_INT 1
8713: PLUS
8714: ARRAY
8715: PPUSH
8716: LD_INT 80
8718: PPUSH
8719: CALL 71861 0 5
// result := result union CreateVehicle ;
8723: LD_ADDR_VAR 0 2
8727: PUSH
8728: LD_VAR 0 2
8732: PUSH
8733: CALL_OW 45
8737: UNION
8738: ST_TO_ADDR
// end ;
8739: GO 8620
8741: POP
8742: POP
// if not KappaStatus then
8743: LD_EXP 2
8747: NOT
8748: IFFALSE 8983
// begin uc_nation := 1 ;
8750: LD_ADDR_OWVAR 21
8754: PUSH
8755: LD_INT 1
8757: ST_TO_ADDR
// for i = 1 to 3 do
8758: LD_ADDR_VAR 0 3
8762: PUSH
8763: DOUBLE
8764: LD_INT 1
8766: DEC
8767: ST_TO_ADDR
8768: LD_INT 3
8770: PUSH
8771: FOR_TO
8772: IFFALSE 8908
// begin j := rand ( 0 , 1 ) ;
8774: LD_ADDR_VAR 0 4
8778: PUSH
8779: LD_INT 0
8781: PPUSH
8782: LD_INT 1
8784: PPUSH
8785: CALL_OW 12
8789: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8790: LD_INT 3
8792: PUSH
8793: LD_INT 5
8795: PUSH
8796: LD_INT 5
8798: PUSH
8799: LD_INT 4
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: PUSH
8808: LD_VAR 0 4
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 3
8818: PPUSH
8819: CALL_OW 12
8823: PLUS
8824: ARRAY
8825: PPUSH
8826: LD_INT 1
8828: PUSH
8829: LD_INT 3
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 1
8838: PPUSH
8839: LD_INT 2
8841: PPUSH
8842: CALL_OW 12
8846: ARRAY
8847: PPUSH
8848: LD_INT 3
8850: PPUSH
8851: LD_INT 9
8853: PUSH
8854: LD_INT 7
8856: PUSH
8857: LD_INT 6
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: LIST
8864: PUSH
8865: LD_VAR 0 4
8869: PUSH
8870: LD_INT 1
8872: PPUSH
8873: LD_INT 2
8875: PPUSH
8876: CALL_OW 12
8880: PLUS
8881: ARRAY
8882: PPUSH
8883: LD_INT 85
8885: PPUSH
8886: CALL 71861 0 5
// result := result union CreateVehicle ;
8890: LD_ADDR_VAR 0 2
8894: PUSH
8895: LD_VAR 0 2
8899: PUSH
8900: CALL_OW 45
8904: UNION
8905: ST_TO_ADDR
// end ;
8906: GO 8771
8908: POP
8909: POP
// if vsevolodFirstAttack then
8910: LD_EXP 24
8914: IFFALSE 8981
// begin vsevolodFirstAttack := false ;
8916: LD_ADDR_EXP 24
8920: PUSH
8921: LD_INT 0
8923: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8924: LD_INT 5
8926: PPUSH
8927: LD_INT 3
8929: PPUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 6
8935: PPUSH
8936: LD_INT 100
8938: PPUSH
8939: CALL 71861 0 5
// sewiVeh := CreateVehicle ;
8943: LD_ADDR_EXP 71
8947: PUSH
8948: CALL_OW 45
8952: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8953: LD_EXP 71
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: CALL_OW 242
// result := result union sewiVeh ;
8965: LD_ADDR_VAR 0 2
8969: PUSH
8970: LD_VAR 0 2
8974: PUSH
8975: LD_EXP 71
8979: UNION
8980: ST_TO_ADDR
// end ; end else
8981: GO 9186
// if vsevolodFirstAttack then
8983: LD_EXP 24
8987: IFFALSE 9186
// begin vsevolodFirstAttack := false ;
8989: LD_ADDR_EXP 24
8993: PUSH
8994: LD_INT 0
8996: ST_TO_ADDR
// uc_nation := 3 ;
8997: LD_ADDR_OWVAR 21
9001: PUSH
9002: LD_INT 3
9004: ST_TO_ADDR
// for i = 1 to 3 do
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: DOUBLE
9011: LD_INT 1
9013: DEC
9014: ST_TO_ADDR
9015: LD_INT 3
9017: PUSH
9018: FOR_TO
9019: IFFALSE 9127
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9021: LD_INT 22
9023: PUSH
9024: LD_INT 24
9026: PUSH
9027: LD_INT 24
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PUSH
9035: LD_VAR 0 3
9039: PUSH
9040: LD_INT 3
9042: MOD
9043: PUSH
9044: LD_INT 1
9046: PLUS
9047: ARRAY
9048: PPUSH
9049: LD_INT 1
9051: PUSH
9052: LD_INT 3
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: PUSH
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 2
9064: PPUSH
9065: CALL_OW 12
9069: ARRAY
9070: PPUSH
9071: LD_INT 3
9073: PPUSH
9074: LD_INT 45
9076: PUSH
9077: LD_INT 47
9079: PUSH
9080: LD_INT 47
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PUSH
9088: LD_VAR 0 3
9092: PUSH
9093: LD_INT 3
9095: MOD
9096: PUSH
9097: LD_INT 1
9099: PLUS
9100: ARRAY
9101: PPUSH
9102: LD_INT 80
9104: PPUSH
9105: CALL 71861 0 5
// result := result union CreateVehicle ;
9109: LD_ADDR_VAR 0 2
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: CALL_OW 45
9123: UNION
9124: ST_TO_ADDR
// end ;
9125: GO 9018
9127: POP
9128: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9129: LD_INT 24
9131: PPUSH
9132: LD_INT 3
9134: PPUSH
9135: LD_INT 1
9137: PPUSH
9138: LD_INT 47
9140: PPUSH
9141: LD_INT 100
9143: PPUSH
9144: CALL 71861 0 5
// sewiVeh := CreateVehicle ;
9148: LD_ADDR_EXP 71
9152: PUSH
9153: CALL_OW 45
9157: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9158: LD_EXP 71
9162: PPUSH
9163: LD_INT 1
9165: PPUSH
9166: CALL_OW 242
// result := result union sewiVeh ;
9170: LD_ADDR_VAR 0 2
9174: PUSH
9175: LD_VAR 0 2
9179: PUSH
9180: LD_EXP 71
9184: UNION
9185: ST_TO_ADDR
// end ; end ; end ;
9186: GO 9189
9188: POP
// end ;
9189: LD_VAR 0 2
9193: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9194: LD_EXP 16
9198: IFFALSE 9956
9200: GO 9202
9202: DISABLE
9203: LD_INT 0
9205: PPUSH
9206: PPUSH
9207: PPUSH
9208: PPUSH
9209: PPUSH
9210: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9211: LD_ADDR_VAR 0 4
9215: PUSH
9216: LD_INT 11
9218: PUSH
9219: LD_INT 12
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$40 , 4 4$10 ] [ Difficulty ] ;
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: LD_INT 11550
9233: PUSH
9234: LD_INT 9800
9236: PUSH
9237: LD_INT 8750
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: PUSH
9245: LD_OWVAR 67
9249: ARRAY
9250: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9251: LD_ADDR_VAR 0 6
9255: PUSH
9256: LD_INT 70
9258: PUSH
9259: LD_INT 118
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: PUSH
9266: LD_INT 78
9268: PUSH
9269: LD_INT 31
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: ST_TO_ADDR
// repeat if missionStage = 2 then
9280: LD_EXP 15
9284: PUSH
9285: LD_INT 2
9287: EQUAL
9288: IFFALSE 9299
// wait ( 1 1$30 ) else
9290: LD_INT 3150
9292: PPUSH
9293: CALL_OW 67
9297: GO 9308
// wait ( time ) ;
9299: LD_VAR 0 3
9303: PPUSH
9304: CALL_OW 67
// if missionStage = 6 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 6
9315: EQUAL
9316: IFFALSE 9344
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9318: LD_INT 51
9320: PPUSH
9321: LD_INT 6
9323: PPUSH
9324: LD_INT 2
9326: PPUSH
9327: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9331: LD_INT 57
9333: PPUSH
9334: LD_INT 6
9336: PPUSH
9337: LD_INT 2
9339: PPUSH
9340: CALL_OW 322
// end ; if missionStage = 8 then
9344: LD_EXP 15
9348: PUSH
9349: LD_INT 8
9351: EQUAL
9352: IFFALSE 9380
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9354: LD_INT 52
9356: PPUSH
9357: LD_INT 6
9359: PPUSH
9360: LD_INT 2
9362: PPUSH
9363: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9367: LD_INT 58
9369: PPUSH
9370: LD_INT 6
9372: PPUSH
9373: LD_INT 2
9375: PPUSH
9376: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9380: LD_EXP 15
9384: PUSH
9385: LD_INT 10
9387: EQUAL
9388: PUSH
9389: LD_OWVAR 67
9393: PUSH
9394: LD_INT 1
9396: GREATER
9397: AND
9398: IFFALSE 9426
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9400: LD_INT 53
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 2
9408: PPUSH
9409: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9413: LD_INT 59
9415: PPUSH
9416: LD_INT 6
9418: PPUSH
9419: LD_INT 2
9421: PPUSH
9422: CALL_OW 322
// end ; if activeAttacks then
9426: LD_EXP 16
9430: IFFALSE 9950
// begin if missionStage = 2 then
9432: LD_EXP 15
9436: PUSH
9437: LD_INT 2
9439: EQUAL
9440: IFFALSE 9450
// strength := 1 ;
9442: LD_ADDR_VAR 0 5
9446: PUSH
9447: LD_INT 1
9449: ST_TO_ADDR
// if missionStage > 2 then
9450: LD_EXP 15
9454: PUSH
9455: LD_INT 2
9457: GREATER
9458: IFFALSE 9468
// strength := 2 ;
9460: LD_ADDR_VAR 0 5
9464: PUSH
9465: LD_INT 2
9467: ST_TO_ADDR
// if missionStage > 6 then
9468: LD_EXP 15
9472: PUSH
9473: LD_INT 6
9475: GREATER
9476: IFFALSE 9486
// strength := 3 ;
9478: LD_ADDR_VAR 0 5
9482: PUSH
9483: LD_INT 3
9485: ST_TO_ADDR
// if missionStage > 10 then
9486: LD_EXP 15
9490: PUSH
9491: LD_INT 10
9493: GREATER
9494: IFFALSE 9504
// strength := 4 ;
9496: LD_ADDR_VAR 0 5
9500: PUSH
9501: LD_INT 4
9503: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9504: LD_ADDR_VAR 0 2
9508: PUSH
9509: LD_VAR 0 5
9513: PPUSH
9514: CALL 8066 0 1
9518: ST_TO_ADDR
// for i in tmp do
9519: LD_ADDR_VAR 0 1
9523: PUSH
9524: LD_VAR 0 2
9528: PUSH
9529: FOR_IN
9530: IFFALSE 9630
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: LD_VAR 0 4
9541: PUSH
9542: LD_INT 1
9544: PPUSH
9545: LD_INT 2
9547: PPUSH
9548: CALL_OW 12
9552: ARRAY
9553: PPUSH
9554: LD_INT 0
9556: PPUSH
9557: CALL_OW 49
// if i = sewiVeh then
9561: LD_VAR 0 1
9565: PUSH
9566: LD_EXP 71
9570: EQUAL
9571: IFFALSE 9606
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9573: LD_ADDR_EXP 70
9577: PUSH
9578: LD_STRING Vsevolod
9580: PPUSH
9581: LD_INT 0
9583: PPUSH
9584: LD_STRING 
9586: PPUSH
9587: CALL 64746 0 3
9591: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9592: LD_EXP 70
9596: PPUSH
9597: LD_VAR 0 1
9601: PPUSH
9602: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9606: LD_VAR 0 1
9610: PPUSH
9611: LD_INT 111
9613: PPUSH
9614: LD_INT 197
9616: PPUSH
9617: CALL_OW 111
// wait ( 0 0$2 ) ;
9621: LD_INT 70
9623: PPUSH
9624: CALL_OW 67
// end ;
9628: GO 9529
9630: POP
9631: POP
// repeat wait ( 0 0$1 ) ;
9632: LD_INT 35
9634: PPUSH
9635: CALL_OW 67
// for i in tmp do
9639: LD_ADDR_VAR 0 1
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: FOR_IN
9650: IFFALSE 9931
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9652: LD_INT 81
9654: PUSH
9655: LD_INT 6
9657: PUSH
9658: EMPTY
9659: LIST
9660: LIST
9661: PUSH
9662: LD_INT 91
9664: PUSH
9665: LD_VAR 0 1
9669: PUSH
9670: LD_INT 12
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: LIST
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: PPUSH
9682: CALL_OW 69
9686: IFFALSE 9744
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9688: LD_VAR 0 1
9692: PPUSH
9693: LD_INT 81
9695: PUSH
9696: LD_INT 6
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: PUSH
9703: LD_INT 91
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_INT 12
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: PPUSH
9723: CALL_OW 69
9727: PPUSH
9728: LD_VAR 0 1
9732: PPUSH
9733: CALL_OW 74
9737: PPUSH
9738: CALL_OW 115
9742: GO 9929
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9744: LD_INT 9
9746: PPUSH
9747: LD_INT 81
9749: PUSH
9750: LD_INT 6
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PPUSH
9757: CALL_OW 70
9761: IFFALSE 9895
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: LD_VAR 0 6
9772: PUSH
9773: LD_INT 1
9775: ARRAY
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PPUSH
9781: LD_VAR 0 6
9785: PUSH
9786: LD_INT 1
9788: ARRAY
9789: PUSH
9790: LD_INT 2
9792: ARRAY
9793: PPUSH
9794: CALL_OW 297
9798: PUSH
9799: LD_INT 10
9801: GREATER
9802: PUSH
9803: LD_VAR 0 1
9807: PPUSH
9808: LD_INT 9
9810: PPUSH
9811: CALL_OW 308
9815: NOT
9816: AND
9817: IFFALSE 9856
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9819: LD_VAR 0 1
9823: PPUSH
9824: LD_VAR 0 6
9828: PUSH
9829: LD_INT 1
9831: ARRAY
9832: PUSH
9833: LD_INT 1
9835: ARRAY
9836: PPUSH
9837: LD_VAR 0 6
9841: PUSH
9842: LD_INT 1
9844: ARRAY
9845: PUSH
9846: LD_INT 2
9848: ARRAY
9849: PPUSH
9850: CALL_OW 114
9854: GO 9893
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9856: LD_VAR 0 1
9860: PPUSH
9861: LD_INT 9
9863: PPUSH
9864: LD_INT 81
9866: PUSH
9867: LD_INT 6
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 70
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
// end else
9893: GO 9929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9895: LD_VAR 0 1
9899: PPUSH
9900: LD_INT 81
9902: PUSH
9903: LD_INT 6
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: PPUSH
9910: CALL_OW 69
9914: PPUSH
9915: LD_VAR 0 1
9919: PPUSH
9920: CALL_OW 74
9924: PPUSH
9925: CALL_OW 115
// end ;
9929: GO 9649
9931: POP
9932: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9933: LD_INT 22
9935: PUSH
9936: LD_INT 6
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PPUSH
9943: CALL_OW 69
9947: NOT
9948: IFFALSE 9632
// end ; until russianDestroyed ;
9950: LD_EXP 21
9954: IFFALSE 9280
// end ;
9956: PPOPN 6
9958: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9959: LD_EXP 21
9963: NOT
9964: PUSH
9965: LD_EXP 15
9969: PUSH
9970: LD_INT 6
9972: GREATEREQUAL
9973: AND
9974: PUSH
9975: LD_INT 2
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: CALL 59820 0 2
9985: NOT
9986: AND
9987: IFFALSE 10943
9989: GO 9991
9991: DISABLE
9992: LD_INT 0
9994: PPUSH
9995: PPUSH
9996: PPUSH
9997: PPUSH
// begin enable ;
9998: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9999: LD_INT 22
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 30
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 69
10027: NOT
10028: IFFALSE 10032
// exit ;
10030: GO 10943
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10032: LD_ADDR_VAR 0 4
10036: PUSH
10037: LD_INT 22
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 34
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: ST_TO_ADDR
// if Prob ( 40 ) then
10066: LD_INT 40
10068: PPUSH
10069: CALL_OW 13
10073: IFFALSE 10200
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10075: LD_INT 2
10077: PPUSH
10078: LD_INT 22
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 49
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: LD_INT 22
10098: PUSH
10099: LD_INT 3
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 49
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 22
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 49
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 24
10134: PUSH
10135: LD_INT 3
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 46
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: PUSH
10150: LD_INT 24
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: LD_INT 3
10158: PUSH
10159: LD_INT 46
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: PUSH
10168: LD_INT 24
10170: PUSH
10171: LD_INT 3
10173: PUSH
10174: LD_INT 3
10176: PUSH
10177: LD_INT 46
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL 58402 0 2
// end else
10198: GO 10323
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10200: LD_INT 2
10202: PPUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 47
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 24
10223: PUSH
10224: LD_INT 3
10226: PUSH
10227: LD_INT 3
10229: PUSH
10230: LD_INT 47
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: LIST
10238: PUSH
10239: LD_INT 24
10241: PUSH
10242: LD_INT 3
10244: PUSH
10245: LD_INT 3
10247: PUSH
10248: LD_INT 47
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: PUSH
10257: LD_INT 24
10259: PUSH
10260: LD_INT 3
10262: PUSH
10263: LD_INT 3
10265: PUSH
10266: LD_INT 46
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 24
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: LD_INT 3
10283: PUSH
10284: LD_INT 46
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 24
10295: PUSH
10296: LD_INT 3
10298: PUSH
10299: LD_INT 3
10301: PUSH
10302: LD_INT 46
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PPUSH
10319: CALL 58402 0 2
// end ; if Difficulty > 1 then
10323: LD_OWVAR 67
10327: PUSH
10328: LD_INT 1
10330: GREATER
10331: IFFALSE 10361
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10333: LD_INT 2
10335: PPUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 47
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: PPUSH
10357: CALL 58402 0 2
// repeat wait ( 0 0$1 ) ;
10361: LD_INT 35
10363: PPUSH
10364: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10368: LD_INT 2
10370: PPUSH
10371: LD_INT 1
10373: PPUSH
10374: CALL 59820 0 2
10378: PUSH
10379: LD_INT 6
10381: PUSH
10382: LD_INT 7
10384: PUSH
10385: LD_INT 7
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: LIST
10392: PUSH
10393: LD_OWVAR 67
10397: ARRAY
10398: GREATEREQUAL
10399: IFFALSE 10361
// wait ( 0 0$30 ) ;
10401: LD_INT 1050
10403: PPUSH
10404: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10408: LD_ADDR_VAR 0 2
10412: PUSH
10413: LD_INT 2
10415: PPUSH
10416: LD_INT 1
10418: PPUSH
10419: CALL 59820 0 2
10423: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10424: LD_ADDR_EXP 121
10428: PUSH
10429: LD_EXP 121
10433: PPUSH
10434: LD_INT 2
10436: PPUSH
10437: LD_EXP 121
10441: PUSH
10442: LD_INT 2
10444: ARRAY
10445: PUSH
10446: LD_VAR 0 2
10450: DIFF
10451: PPUSH
10452: CALL_OW 1
10456: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10457: LD_ADDR_VAR 0 3
10461: PUSH
10462: LD_INT 0
10464: PPUSH
10465: LD_INT 1
10467: PPUSH
10468: CALL_OW 12
10472: ST_TO_ADDR
// if target then
10473: LD_VAR 0 3
10477: IFFALSE 10605
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10479: LD_ADDR_VAR 0 2
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 24
10491: PUSH
10492: LD_INT 250
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PPUSH
10499: CALL_OW 72
10503: ST_TO_ADDR
// for i in tmp do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_VAR 0 2
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10555
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 139
10524: PPUSH
10525: LD_INT 89
10527: PPUSH
10528: CALL_OW 297
10532: PUSH
10533: LD_INT 9
10535: GREATER
10536: IFFALSE 10553
// ComMoveXY ( i , 139 , 89 ) ;
10538: LD_VAR 0 1
10542: PPUSH
10543: LD_INT 139
10545: PPUSH
10546: LD_INT 89
10548: PPUSH
10549: CALL_OW 111
10553: GO 10514
10555: POP
10556: POP
// wait ( 0 0$1 ) ;
10557: LD_INT 35
10559: PPUSH
10560: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10564: LD_VAR 0 2
10568: PPUSH
10569: LD_INT 92
10571: PUSH
10572: LD_INT 139
10574: PUSH
10575: LD_INT 89
10577: PUSH
10578: LD_INT 9
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: PPUSH
10587: CALL_OW 72
10591: PUSH
10592: LD_VAR 0 2
10596: PUSH
10597: LD_INT 1
10599: MINUS
10600: GREATEREQUAL
10601: IFFALSE 10479
// end else
10603: GO 10747
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10605: LD_VAR 0 2
10609: PPUSH
10610: LD_VAR 0 4
10614: PUSH
10615: LD_INT 1
10617: ARRAY
10618: PPUSH
10619: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10623: LD_ADDR_VAR 0 2
10627: PUSH
10628: LD_VAR 0 2
10632: PPUSH
10633: LD_INT 24
10635: PUSH
10636: LD_INT 250
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 72
10647: ST_TO_ADDR
// for i in tmp do
10648: LD_ADDR_VAR 0 1
10652: PUSH
10653: LD_VAR 0 2
10657: PUSH
10658: FOR_IN
10659: IFFALSE 10699
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10661: LD_VAR 0 1
10665: PPUSH
10666: LD_INT 124
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: CALL_OW 297
10676: PUSH
10677: LD_INT 9
10679: GREATER
10680: IFFALSE 10697
// ComMoveXY ( i , 124 , 139 ) ;
10682: LD_VAR 0 1
10686: PPUSH
10687: LD_INT 124
10689: PPUSH
10690: LD_INT 139
10692: PPUSH
10693: CALL_OW 111
10697: GO 10658
10699: POP
10700: POP
// wait ( 0 0$1 ) ;
10701: LD_INT 35
10703: PPUSH
10704: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10708: LD_VAR 0 2
10712: PPUSH
10713: LD_INT 92
10715: PUSH
10716: LD_INT 124
10718: PUSH
10719: LD_INT 139
10721: PUSH
10722: LD_INT 9
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: PPUSH
10731: CALL_OW 72
10735: PUSH
10736: LD_VAR 0 2
10740: PUSH
10741: LD_INT 1
10743: MINUS
10744: GREATEREQUAL
10745: IFFALSE 10623
// end ; repeat wait ( 0 0$1 ) ;
10747: LD_INT 35
10749: PPUSH
10750: CALL_OW 67
// for i in tmp do
10754: LD_ADDR_VAR 0 1
10758: PUSH
10759: LD_VAR 0 2
10763: PUSH
10764: FOR_IN
10765: IFFALSE 10934
// begin if GetLives ( i ) > 251 then
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 256
10776: PUSH
10777: LD_INT 251
10779: GREATER
10780: IFFALSE 10905
// begin if GetWeapon ( i ) = ru_time_lapser then
10782: LD_VAR 0 1
10786: PPUSH
10787: CALL_OW 264
10791: PUSH
10792: LD_INT 49
10794: EQUAL
10795: IFFALSE 10851
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10797: LD_VAR 0 1
10801: PPUSH
10802: LD_INT 2
10804: PUSH
10805: LD_INT 22
10807: PUSH
10808: LD_INT 1
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: PUSH
10815: LD_INT 22
10817: PUSH
10818: LD_INT 8
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: LIST
10829: PPUSH
10830: CALL_OW 69
10834: PPUSH
10835: LD_VAR 0 1
10839: PPUSH
10840: CALL_OW 74
10844: PPUSH
10845: CALL_OW 112
10849: GO 10903
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10851: LD_VAR 0 1
10855: PPUSH
10856: LD_INT 2
10858: PUSH
10859: LD_INT 22
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 22
10871: PUSH
10872: LD_INT 8
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PPUSH
10889: LD_VAR 0 1
10893: PPUSH
10894: CALL_OW 74
10898: PPUSH
10899: CALL_OW 115
// end else
10903: GO 10932
// if IsDead ( i ) then
10905: LD_VAR 0 1
10909: PPUSH
10910: CALL_OW 301
10914: IFFALSE 10932
// tmp := tmp diff i ;
10916: LD_ADDR_VAR 0 2
10920: PUSH
10921: LD_VAR 0 2
10925: PUSH
10926: LD_VAR 0 1
10930: DIFF
10931: ST_TO_ADDR
// end ;
10932: GO 10764
10934: POP
10935: POP
// until not tmp ;
10936: LD_VAR 0 2
10940: NOT
10941: IFFALSE 10747
// end ; end_of_file
10943: PPOPN 4
10945: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10946: LD_INT 0
10948: PPUSH
10949: PPUSH
10950: PPUSH
10951: PPUSH
10952: PPUSH
10953: PPUSH
// side := 7 ;
10954: LD_ADDR_VAR 0 5
10958: PUSH
10959: LD_INT 7
10961: ST_TO_ADDR
// uc_side := side ;
10962: LD_ADDR_OWVAR 20
10966: PUSH
10967: LD_VAR 0 5
10971: ST_TO_ADDR
// uc_nation := 1 ;
10972: LD_ADDR_OWVAR 21
10976: PUSH
10977: LD_INT 1
10979: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10980: LD_ADDR_VAR 0 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_VAR 0 5
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 21
10999: PUSH
11000: LD_INT 3
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL_OW 69
11015: PUSH
11016: FOR_IN
11017: IFFALSE 11033
// SetBLevel ( i , 10 ) ;
11019: LD_VAR 0 2
11023: PPUSH
11024: LD_INT 10
11026: PPUSH
11027: CALL_OW 241
11031: GO 11016
11033: POP
11034: POP
// base := GetBase ( al_depot ) ;
11035: LD_ADDR_VAR 0 4
11039: PUSH
11040: LD_INT 2
11042: PPUSH
11043: CALL_OW 274
11047: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11048: LD_ADDR_VAR 0 6
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 5
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 30
11067: PUSH
11068: LD_INT 34
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: ST_TO_ADDR
// if teleport then
11084: LD_VAR 0 6
11088: IFFALSE 11109
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11090: LD_VAR 0 6
11094: PUSH
11095: LD_INT 1
11097: ARRAY
11098: PPUSH
11099: LD_INT 262
11101: PPUSH
11102: LD_INT 119
11104: PPUSH
11105: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11109: LD_VAR 0 4
11113: PPUSH
11114: LD_INT 1
11116: PPUSH
11117: LD_INT 19500
11119: PPUSH
11120: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11124: LD_VAR 0 4
11128: PPUSH
11129: LD_INT 2
11131: PPUSH
11132: LD_INT 200
11134: PPUSH
11135: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11139: LD_VAR 0 4
11143: PPUSH
11144: LD_INT 3
11146: PPUSH
11147: LD_INT 650
11149: PPUSH
11150: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11154: LD_ADDR_EXP 74
11158: PUSH
11159: LD_STRING Roth
11161: PPUSH
11162: CALL_OW 25
11166: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11167: LD_ADDR_EXP 75
11171: PUSH
11172: LD_STRING Simms
11174: PPUSH
11175: LD_EXP 1
11179: NOT
11180: PPUSH
11181: LD_STRING 10c_
11183: PPUSH
11184: CALL 64746 0 3
11188: ST_TO_ADDR
// if not Simms then
11189: LD_EXP 75
11193: NOT
11194: IFFALSE 11224
// begin uc_nation := 1 ;
11196: LD_ADDR_OWVAR 21
11200: PUSH
11201: LD_INT 1
11203: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11204: LD_INT 2
11206: PPUSH
11207: LD_INT 10
11209: PPUSH
11210: CALL_OW 384
// Simms := CreateHuman ;
11214: LD_ADDR_EXP 75
11218: PUSH
11219: CALL_OW 44
11223: ST_TO_ADDR
// end ; uc_nation := 3 ;
11224: LD_ADDR_OWVAR 21
11228: PUSH
11229: LD_INT 3
11231: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11232: LD_ADDR_EXP 76
11236: PUSH
11237: LD_STRING Kirilenkova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11245: LD_ADDR_EXP 90
11249: PUSH
11250: LD_STRING Oblukov
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Dolgov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11271: LD_ADDR_EXP 78
11275: PUSH
11276: LD_STRING Petrosyan
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11284: LD_ADDR_EXP 89
11288: PUSH
11289: LD_STRING Scholtze
11291: PPUSH
11292: CALL_OW 25
11296: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11297: LD_ADDR_EXP 88
11301: PUSH
11302: LD_STRING Kapitsova
11304: PPUSH
11305: CALL_OW 25
11309: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11310: LD_ADDR_EXP 79
11314: PUSH
11315: LD_STRING Petrovova
11317: PPUSH
11318: CALL_OW 25
11322: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11323: LD_ADDR_EXP 80
11327: PUSH
11328: LD_STRING Kuzmov
11330: PPUSH
11331: CALL_OW 25
11335: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11336: LD_ADDR_EXP 87
11340: PUSH
11341: LD_STRING Karamazov
11343: PPUSH
11344: CALL_OW 25
11348: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11349: LD_STRING 13_Lipshchin_1
11351: PPUSH
11352: LD_INT 0
11354: PPUSH
11355: CALL_OW 30
11359: IFFALSE 11374
// Lipshchin := NewCharacter ( Lipshchin ) ;
11361: LD_ADDR_EXP 81
11365: PUSH
11366: LD_STRING Lipshchin
11368: PPUSH
11369: CALL_OW 25
11373: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11374: LD_STRING 13_Titov_1
11376: PPUSH
11377: LD_INT 0
11379: PPUSH
11380: CALL_OW 30
11384: IFFALSE 11399
// Titov := NewCharacter ( Titov ) ;
11386: LD_ADDR_EXP 83
11390: PUSH
11391: LD_STRING Titov
11393: PPUSH
11394: CALL_OW 25
11398: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11399: LD_STRING 13_Gnyevko_1
11401: PPUSH
11402: LD_INT 0
11404: PPUSH
11405: CALL_OW 30
11409: IFFALSE 11424
// Gnyevko := NewCharacter ( Gnyevko ) ;
11411: LD_ADDR_EXP 82
11415: PUSH
11416: LD_STRING Gnyevko
11418: PPUSH
11419: CALL_OW 25
11423: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11424: LD_STRING 13_Xavier_1
11426: PPUSH
11427: LD_INT 0
11429: PPUSH
11430: CALL_OW 30
11434: IFFALSE 11449
// Xavier := NewCharacter ( Xavier2 ) ;
11436: LD_ADDR_EXP 84
11440: PUSH
11441: LD_STRING Xavier2
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11449: LD_STRING 13_Belkov_1
11451: PPUSH
11452: LD_INT 0
11454: PPUSH
11455: CALL_OW 30
11459: IFFALSE 11474
// Belkov := NewCharacter ( Belkov ) ;
11461: LD_ADDR_EXP 85
11465: PUSH
11466: LD_STRING Belkov
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// if not BurlakStatus then
11474: LD_EXP 9
11478: NOT
11479: IFFALSE 11494
// Burlak = NewCharacter ( Burlak ) ;
11481: LD_ADDR_EXP 86
11485: PUSH
11486: LD_STRING Burlak
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11494: LD_ADDR_VAR 0 3
11498: PUSH
11499: LD_EXP 74
11503: PUSH
11504: LD_EXP 76
11508: PUSH
11509: LD_EXP 90
11513: PUSH
11514: LD_EXP 77
11518: PUSH
11519: LD_EXP 78
11523: PUSH
11524: LD_EXP 89
11528: PUSH
11529: LD_EXP 88
11533: PUSH
11534: LD_EXP 79
11538: PUSH
11539: LD_EXP 80
11543: PUSH
11544: LD_EXP 87
11548: PUSH
11549: EMPTY
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: ST_TO_ADDR
// if Simms then
11561: LD_EXP 75
11565: IFFALSE 11583
// tmp := tmp ^ Simms ;
11567: LD_ADDR_VAR 0 3
11571: PUSH
11572: LD_VAR 0 3
11576: PUSH
11577: LD_EXP 75
11581: ADD
11582: ST_TO_ADDR
// if Titov then
11583: LD_EXP 83
11587: IFFALSE 11605
// tmp := tmp ^ Titov ;
11589: LD_ADDR_VAR 0 3
11593: PUSH
11594: LD_VAR 0 3
11598: PUSH
11599: LD_EXP 83
11603: ADD
11604: ST_TO_ADDR
// if Lipshchin then
11605: LD_EXP 81
11609: IFFALSE 11627
// tmp := tmp ^ Lipshchin ;
11611: LD_ADDR_VAR 0 3
11615: PUSH
11616: LD_VAR 0 3
11620: PUSH
11621: LD_EXP 81
11625: ADD
11626: ST_TO_ADDR
// if Gnyevko then
11627: LD_EXP 82
11631: IFFALSE 11649
// tmp := tmp ^ Gnyevko ;
11633: LD_ADDR_VAR 0 3
11637: PUSH
11638: LD_VAR 0 3
11642: PUSH
11643: LD_EXP 82
11647: ADD
11648: ST_TO_ADDR
// if Xavier then
11649: LD_EXP 84
11653: IFFALSE 11671
// tmp := tmp ^ Xavier ;
11655: LD_ADDR_VAR 0 3
11659: PUSH
11660: LD_VAR 0 3
11664: PUSH
11665: LD_EXP 84
11669: ADD
11670: ST_TO_ADDR
// if Belkov then
11671: LD_EXP 85
11675: IFFALSE 11693
// tmp := tmp ^ Belkov ;
11677: LD_ADDR_VAR 0 3
11681: PUSH
11682: LD_VAR 0 3
11686: PUSH
11687: LD_EXP 85
11691: ADD
11692: ST_TO_ADDR
// if Burlak then
11693: LD_EXP 86
11697: IFFALSE 11715
// tmp := tmp ^ Burlak ;
11699: LD_ADDR_VAR 0 3
11703: PUSH
11704: LD_VAR 0 3
11708: PUSH
11709: LD_EXP 86
11713: ADD
11714: ST_TO_ADDR
// for i = 1 to 11 do
11715: LD_ADDR_VAR 0 2
11719: PUSH
11720: DOUBLE
11721: LD_INT 1
11723: DEC
11724: ST_TO_ADDR
11725: LD_INT 11
11727: PUSH
11728: FOR_TO
11729: IFFALSE 11795
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11731: LD_ADDR_OWVAR 21
11735: PUSH
11736: LD_INT 1
11738: PUSH
11739: LD_INT 3
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: PUSH
11746: LD_INT 1
11748: PPUSH
11749: LD_INT 2
11751: PPUSH
11752: CALL_OW 12
11756: ARRAY
11757: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11758: LD_INT 0
11760: PPUSH
11761: LD_VAR 0 2
11765: PUSH
11766: LD_INT 2
11768: DIV
11769: PPUSH
11770: LD_INT 10
11772: PPUSH
11773: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11777: LD_ADDR_VAR 0 3
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: CALL_OW 44
11791: ADD
11792: ST_TO_ADDR
// end ;
11793: GO 11728
11795: POP
11796: POP
// for i in tmp do
11797: LD_ADDR_VAR 0 2
11801: PUSH
11802: LD_VAR 0 3
11806: PUSH
11807: FOR_IN
11808: IFFALSE 11833
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11810: LD_VAR 0 2
11814: PPUSH
11815: LD_INT 260
11817: PPUSH
11818: LD_INT 235
11820: PPUSH
11821: LD_INT 8
11823: PPUSH
11824: LD_INT 0
11826: PPUSH
11827: CALL_OW 50
11831: GO 11807
11833: POP
11834: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11835: LD_ADDR_EXP 102
11839: PUSH
11840: LD_EXP 102
11844: PPUSH
11845: LD_INT 1
11847: PPUSH
11848: LD_INT 22
11850: PUSH
11851: LD_VAR 0 5
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 3
11862: PUSH
11863: LD_INT 21
11865: PUSH
11866: LD_INT 2
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 74
11890: PUSH
11891: LD_EXP 75
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: DIFF
11900: PPUSH
11901: CALL_OW 1
11905: ST_TO_ADDR
// uc_side := 0 ;
11906: LD_ADDR_OWVAR 20
11910: PUSH
11911: LD_INT 0
11913: ST_TO_ADDR
// uc_nation := 0 ;
11914: LD_ADDR_OWVAR 21
11918: PUSH
11919: LD_INT 0
11921: ST_TO_ADDR
// for i = 1 to 5 do
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: DOUBLE
11928: LD_INT 1
11930: DEC
11931: ST_TO_ADDR
11932: LD_INT 5
11934: PUSH
11935: FOR_TO
11936: IFFALSE 11973
// begin InitHc ;
11938: CALL_OW 19
// hc_class := class_apeman ;
11942: LD_ADDR_OWVAR 28
11946: PUSH
11947: LD_INT 12
11949: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11950: CALL_OW 44
11954: PPUSH
11955: LD_INT 299
11957: PPUSH
11958: LD_INT 229
11960: PPUSH
11961: LD_INT 10
11963: PPUSH
11964: LD_INT 0
11966: PPUSH
11967: CALL_OW 50
// end ;
11971: GO 11935
11973: POP
11974: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11975: LD_EXP 74
11979: PPUSH
11980: LD_INT 259
11982: PPUSH
11983: LD_INT 235
11985: PPUSH
11986: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11990: LD_EXP 74
11994: PPUSH
11995: LD_INT 262
11997: PPUSH
11998: LD_INT 235
12000: PPUSH
12001: CALL_OW 178
// if Simms then
12005: LD_EXP 75
12009: IFFALSE 12040
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12011: LD_EXP 75
12015: PPUSH
12016: LD_INT 262
12018: PPUSH
12019: LD_INT 235
12021: PPUSH
12022: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12026: LD_EXP 75
12030: PPUSH
12031: LD_EXP 74
12035: PPUSH
12036: CALL_OW 179
// end ; end ;
12040: LD_VAR 0 1
12044: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12045: LD_EXP 31
12049: PUSH
12050: LD_EXP 23
12054: NOT
12055: AND
12056: IFFALSE 12232
12058: GO 12060
12060: DISABLE
12061: LD_INT 0
12063: PPUSH
12064: PPUSH
12065: PPUSH
// begin enable ;
12066: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 81
12074: PUSH
12075: LD_INT 7
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 2
12084: PUSH
12085: LD_INT 32
12087: PUSH
12088: LD_INT 3
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 30
12097: PUSH
12098: LD_INT 30
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 30
12107: PUSH
12108: LD_INT 28
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: LD_INT 34
12117: PUSH
12118: LD_INT 49
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: PUSH
12125: LD_INT 34
12127: PUSH
12128: LD_INT 10
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 34
12137: PUSH
12138: LD_INT 8
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL_OW 69
12162: ST_TO_ADDR
// if not tmp then
12163: LD_VAR 0 2
12167: NOT
12168: IFFALSE 12172
// exit ;
12170: GO 12232
// target := tmp [ rand ( 1 , tmp ) ] ;
12172: LD_ADDR_VAR 0 3
12176: PUSH
12177: LD_VAR 0 2
12181: PUSH
12182: LD_INT 1
12184: PPUSH
12185: LD_VAR 0 2
12189: PPUSH
12190: CALL_OW 12
12194: ARRAY
12195: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12196: LD_VAR 0 3
12200: PPUSH
12201: CALL_OW 255
12205: PUSH
12206: LD_INT 1
12208: EQUAL
12209: IFFALSE 12220
// CenterNowOnUnits ( target ) ;
12211: LD_VAR 0 3
12215: PPUSH
12216: CALL_OW 87
// SetLives ( target , 0 ) ;
12220: LD_VAR 0 3
12224: PPUSH
12225: LD_INT 0
12227: PPUSH
12228: CALL_OW 234
// end ;
12232: PPOPN 3
12234: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12235: LD_EXP 23
12239: NOT
12240: PUSH
12241: LD_EXP 31
12245: AND
12246: IFFALSE 12768
12248: GO 12250
12250: DISABLE
12251: LD_INT 0
12253: PPUSH
12254: PPUSH
12255: PPUSH
// begin uc_side := 7 ;
12256: LD_ADDR_OWVAR 20
12260: PUSH
12261: LD_INT 7
12263: ST_TO_ADDR
// uc_nation := 1 ;
12264: LD_ADDR_OWVAR 21
12268: PUSH
12269: LD_INT 1
12271: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12272: LD_ADDR_VAR 0 3
12276: PUSH
12277: LD_INT 125
12279: PUSH
12280: LD_INT 163
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: LD_INT 185
12289: PUSH
12290: LD_INT 168
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: LD_INT 111
12299: PUSH
12300: LD_INT 97
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: LIST
12311: PPUSH
12312: CALL 107701 0 1
12316: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12317: LD_ADDR_EXP 91
12321: PUSH
12322: EMPTY
12323: ST_TO_ADDR
// for i = 1 to Difficulty do
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: DOUBLE
12330: LD_INT 1
12332: DEC
12333: ST_TO_ADDR
12334: LD_OWVAR 67
12338: PUSH
12339: FOR_TO
12340: IFFALSE 12498
// begin InitHc ;
12342: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12346: LD_INT 0
12348: PPUSH
12349: LD_INT 8
12351: PPUSH
12352: CALL_OW 381
// un := CreateHuman ;
12356: LD_ADDR_VAR 0 2
12360: PUSH
12361: CALL_OW 44
12365: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12366: LD_VAR 0 2
12370: PPUSH
12371: LD_INT 258
12373: PPUSH
12374: LD_INT 267
12376: PPUSH
12377: LD_INT 4
12379: PPUSH
12380: LD_INT 0
12382: PPUSH
12383: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12387: LD_ADDR_EXP 91
12391: PUSH
12392: LD_EXP 91
12396: PUSH
12397: LD_VAR 0 2
12401: UNION
12402: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12403: LD_VAR 0 2
12407: PPUSH
12408: LD_VAR 0 3
12412: PUSH
12413: LD_VAR 0 1
12417: ARRAY
12418: PUSH
12419: LD_INT 1
12421: ARRAY
12422: PPUSH
12423: LD_VAR 0 3
12427: PUSH
12428: LD_VAR 0 1
12432: ARRAY
12433: PUSH
12434: LD_INT 2
12436: ARRAY
12437: PPUSH
12438: LD_INT 4
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12448: LD_VAR 0 2
12452: PPUSH
12453: LD_VAR 0 3
12457: PUSH
12458: LD_VAR 0 1
12462: ARRAY
12463: PUSH
12464: LD_INT 1
12466: ARRAY
12467: PPUSH
12468: LD_VAR 0 3
12472: PUSH
12473: LD_VAR 0 1
12477: ARRAY
12478: PUSH
12479: LD_INT 2
12481: ARRAY
12482: PPUSH
12483: CALL_OW 171
// AddComInvisible ( un ) ;
12487: LD_VAR 0 2
12491: PPUSH
12492: CALL_OW 212
// end ;
12496: GO 12339
12498: POP
12499: POP
// repeat wait ( 0 0$20 ) ;
12500: LD_INT 700
12502: PPUSH
12503: CALL_OW 67
// for i in allianceSpecialForce do
12507: LD_ADDR_VAR 0 1
12511: PUSH
12512: LD_EXP 91
12516: PUSH
12517: FOR_IN
12518: IFFALSE 12753
// begin if IsInvisible ( i ) then
12520: LD_VAR 0 1
12524: PPUSH
12525: CALL_OW 571
12529: IFFALSE 12722
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12531: LD_ADDR_VAR 0 3
12535: PUSH
12536: LD_INT 22
12538: PUSH
12539: LD_INT 1
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 50
12548: PUSH
12549: EMPTY
12550: LIST
12551: PUSH
12552: LD_INT 56
12554: PUSH
12555: EMPTY
12556: LIST
12557: PUSH
12558: LD_INT 91
12560: PUSH
12561: LD_VAR 0 1
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 30
12571: PUSH
12572: LD_INT 35
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: LIST
12579: PUSH
12580: LD_OWVAR 67
12584: ARRAY
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: LD_INT 2
12593: PUSH
12594: LD_INT 25
12596: PUSH
12597: LD_INT 1
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PUSH
12604: LD_INT 25
12606: PUSH
12607: LD_INT 2
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: PUSH
12614: LD_INT 25
12616: PUSH
12617: LD_INT 3
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 25
12626: PUSH
12627: LD_INT 4
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 25
12636: PUSH
12637: LD_INT 5
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 25
12646: PUSH
12647: LD_INT 8
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: LIST
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: LIST
12667: LIST
12668: LIST
12669: PPUSH
12670: CALL_OW 69
12674: ST_TO_ADDR
// if not tmp then
12675: LD_VAR 0 3
12679: NOT
12680: IFFALSE 12684
// continue ;
12682: GO 12517
// if Prob ( 30 * Difficulty ) then
12684: LD_INT 30
12686: PUSH
12687: LD_OWVAR 67
12691: MUL
12692: PPUSH
12693: CALL_OW 13
12697: IFFALSE 12722
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12699: LD_VAR 0 3
12703: PUSH
12704: LD_INT 1
12706: PPUSH
12707: LD_VAR 0 3
12711: PPUSH
12712: CALL_OW 12
12716: ARRAY
12717: PPUSH
12718: CALL 30852 0 1
// end ; if IsDead ( i ) then
12722: LD_VAR 0 1
12726: PPUSH
12727: CALL_OW 301
12731: IFFALSE 12751
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12733: LD_ADDR_EXP 91
12737: PUSH
12738: LD_EXP 91
12742: PUSH
12743: LD_VAR 0 1
12747: DIFF
12748: ST_TO_ADDR
// continue ;
12749: GO 12517
// end ; end ;
12751: GO 12517
12753: POP
12754: POP
// until allianceDestroyed or not allianceSpecialForce ;
12755: LD_EXP 23
12759: PUSH
12760: LD_EXP 91
12764: NOT
12765: OR
12766: IFFALSE 12500
// end ;
12768: PPOPN 3
12770: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12771: LD_EXP 23
12775: NOT
12776: PUSH
12777: LD_EXP 31
12781: AND
12782: IFFALSE 13749
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
12790: PPUSH
12791: PPUSH
12792: PPUSH
// begin enable ;
12793: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12794: LD_INT 22
12796: PUSH
12797: LD_INT 7
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 30
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PPUSH
12818: CALL_OW 69
12822: NOT
12823: IFFALSE 12827
// exit ;
12825: GO 13749
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12827: LD_ADDR_VAR 0 4
12831: PUSH
12832: LD_INT 22
12834: PUSH
12835: LD_INT 7
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: LD_INT 30
12844: PUSH
12845: LD_INT 34
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PPUSH
12856: CALL_OW 69
12860: ST_TO_ADDR
// if Prob ( 40 ) then
12861: LD_INT 40
12863: PPUSH
12864: CALL_OW 13
12868: IFFALSE 12995
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12870: LD_INT 1
12872: PPUSH
12873: LD_INT 5
12875: PUSH
12876: LD_INT 3
12878: PUSH
12879: LD_INT 2
12881: PUSH
12882: LD_INT 6
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: PUSH
12891: LD_INT 5
12893: PUSH
12894: LD_INT 3
12896: PUSH
12897: LD_INT 2
12899: PUSH
12900: LD_INT 6
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: LIST
12908: PUSH
12909: LD_INT 5
12911: PUSH
12912: LD_INT 3
12914: PUSH
12915: LD_INT 2
12917: PUSH
12918: LD_INT 6
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 24
12929: PUSH
12930: LD_INT 3
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: LD_INT 45
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: PUSH
12945: LD_INT 24
12947: PUSH
12948: LD_INT 3
12950: PUSH
12951: LD_INT 3
12953: PUSH
12954: LD_INT 47
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_INT 24
12965: PUSH
12966: LD_INT 3
12968: PUSH
12969: LD_INT 3
12971: PUSH
12972: LD_INT 45
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: PPUSH
12989: CALL 58402 0 2
// end else
12993: GO 13118
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12995: LD_INT 1
12997: PPUSH
12998: LD_INT 24
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: LD_INT 3
13006: PUSH
13007: LD_INT 47
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: PUSH
13016: LD_INT 24
13018: PUSH
13019: LD_INT 3
13021: PUSH
13022: LD_INT 3
13024: PUSH
13025: LD_INT 47
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: PUSH
13034: LD_INT 5
13036: PUSH
13037: LD_INT 3
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 9
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: PUSH
13052: LD_INT 5
13054: PUSH
13055: LD_INT 3
13057: PUSH
13058: LD_INT 2
13060: PUSH
13061: LD_INT 9
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: PUSH
13070: LD_INT 24
13072: PUSH
13073: LD_INT 1
13075: PUSH
13076: LD_INT 3
13078: PUSH
13079: LD_INT 45
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 24
13090: PUSH
13091: LD_INT 1
13093: PUSH
13094: LD_INT 3
13096: PUSH
13097: LD_INT 45
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PUSH
13106: EMPTY
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PPUSH
13114: CALL 58402 0 2
// end ; if Difficulty > 1 then
13118: LD_OWVAR 67
13122: PUSH
13123: LD_INT 1
13125: GREATER
13126: IFFALSE 13156
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13128: LD_INT 1
13130: PPUSH
13131: LD_INT 24
13133: PUSH
13134: LD_INT 3
13136: PUSH
13137: LD_INT 3
13139: PUSH
13140: LD_INT 47
13142: PUSH
13143: EMPTY
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: PUSH
13149: EMPTY
13150: LIST
13151: PPUSH
13152: CALL 58402 0 2
// repeat wait ( 0 0$1 ) ;
13156: LD_INT 35
13158: PPUSH
13159: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13163: LD_INT 1
13165: PPUSH
13166: LD_INT 1
13168: PPUSH
13169: CALL 59820 0 2
13173: PUSH
13174: LD_INT 6
13176: PUSH
13177: LD_INT 7
13179: PUSH
13180: LD_INT 7
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: LIST
13187: PUSH
13188: LD_OWVAR 67
13192: ARRAY
13193: GREATEREQUAL
13194: IFFALSE 13156
// wait ( 0 0$40 ) ;
13196: LD_INT 1400
13198: PPUSH
13199: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13203: LD_ADDR_VAR 0 2
13207: PUSH
13208: LD_INT 1
13210: PPUSH
13211: LD_INT 1
13213: PPUSH
13214: CALL 59820 0 2
13218: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13219: LD_ADDR_EXP 121
13223: PUSH
13224: LD_EXP 121
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: LD_EXP 121
13236: PUSH
13237: LD_INT 1
13239: ARRAY
13240: PUSH
13241: LD_VAR 0 2
13245: DIFF
13246: PPUSH
13247: CALL_OW 1
13251: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13252: LD_ADDR_VAR 0 3
13256: PUSH
13257: LD_INT 0
13259: PPUSH
13260: LD_INT 1
13262: PPUSH
13263: CALL_OW 12
13267: ST_TO_ADDR
// if target then
13268: LD_VAR 0 3
13272: IFFALSE 13438
// begin for i in tmp do
13274: LD_ADDR_VAR 0 1
13278: PUSH
13279: LD_VAR 0 2
13283: PUSH
13284: FOR_IN
13285: IFFALSE 13310
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13287: LD_VAR 0 1
13291: PPUSH
13292: LD_INT 179
13294: PPUSH
13295: LD_INT 209
13297: PPUSH
13298: LD_INT 8
13300: PPUSH
13301: LD_INT 1
13303: PPUSH
13304: CALL_OW 483
13308: GO 13284
13310: POP
13311: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 2
13321: PPUSH
13322: LD_INT 24
13324: PUSH
13325: LD_INT 250
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: ST_TO_ADDR
// for i in tmp do
13337: LD_ADDR_VAR 0 1
13341: PUSH
13342: LD_VAR 0 2
13346: PUSH
13347: FOR_IN
13348: IFFALSE 13388
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13350: LD_VAR 0 1
13354: PPUSH
13355: LD_INT 179
13357: PPUSH
13358: LD_INT 209
13360: PPUSH
13361: CALL_OW 297
13365: PUSH
13366: LD_INT 9
13368: GREATER
13369: IFFALSE 13386
// ComMoveXY ( i , 179 , 209 ) ;
13371: LD_VAR 0 1
13375: PPUSH
13376: LD_INT 179
13378: PPUSH
13379: LD_INT 209
13381: PPUSH
13382: CALL_OW 111
13386: GO 13347
13388: POP
13389: POP
// wait ( 0 0$1 ) ;
13390: LD_INT 35
13392: PPUSH
13393: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13397: LD_VAR 0 2
13401: PPUSH
13402: LD_INT 92
13404: PUSH
13405: LD_INT 179
13407: PUSH
13408: LD_INT 209
13410: PUSH
13411: LD_INT 9
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 72
13424: PUSH
13425: LD_VAR 0 2
13429: PUSH
13430: LD_INT 1
13432: MINUS
13433: GREATEREQUAL
13434: IFFALSE 13312
// end else
13436: GO 13600
// begin for i in tmp do
13438: LD_ADDR_VAR 0 1
13442: PUSH
13443: LD_VAR 0 2
13447: PUSH
13448: FOR_IN
13449: IFFALSE 13474
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13451: LD_VAR 0 1
13455: PPUSH
13456: LD_INT 285
13458: PPUSH
13459: LD_INT 163
13461: PPUSH
13462: LD_INT 8
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 483
13472: GO 13448
13474: POP
13475: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13476: LD_ADDR_VAR 0 2
13480: PUSH
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_INT 24
13488: PUSH
13489: LD_INT 250
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PPUSH
13496: CALL_OW 72
13500: ST_TO_ADDR
// for i in tmp do
13501: LD_ADDR_VAR 0 1
13505: PUSH
13506: LD_VAR 0 2
13510: PUSH
13511: FOR_IN
13512: IFFALSE 13552
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13514: LD_VAR 0 1
13518: PPUSH
13519: LD_INT 285
13521: PPUSH
13522: LD_INT 163
13524: PPUSH
13525: CALL_OW 297
13529: PUSH
13530: LD_INT 9
13532: GREATER
13533: IFFALSE 13550
// ComMoveXY ( i , 285 , 163 ) ;
13535: LD_VAR 0 1
13539: PPUSH
13540: LD_INT 285
13542: PPUSH
13543: LD_INT 163
13545: PPUSH
13546: CALL_OW 111
13550: GO 13511
13552: POP
13553: POP
// wait ( 0 0$1 ) ;
13554: LD_INT 35
13556: PPUSH
13557: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13561: LD_VAR 0 2
13565: PPUSH
13566: LD_INT 92
13568: PUSH
13569: LD_INT 285
13571: PUSH
13572: LD_INT 163
13574: PUSH
13575: LD_INT 9
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: PPUSH
13584: CALL_OW 72
13588: PUSH
13589: LD_VAR 0 2
13593: PUSH
13594: LD_INT 1
13596: MINUS
13597: GREATEREQUAL
13598: IFFALSE 13476
// end ; repeat wait ( 0 0$1 ) ;
13600: LD_INT 35
13602: PPUSH
13603: CALL_OW 67
// for i in tmp do
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: LD_VAR 0 2
13616: PUSH
13617: FOR_IN
13618: IFFALSE 13740
// if GetLives ( i ) > 251 then
13620: LD_VAR 0 1
13624: PPUSH
13625: CALL_OW 256
13629: PUSH
13630: LD_INT 251
13632: GREATER
13633: IFFALSE 13722
// begin if GetWeapon ( i ) = ru_time_lapser then
13635: LD_VAR 0 1
13639: PPUSH
13640: CALL_OW 264
13644: PUSH
13645: LD_INT 49
13647: EQUAL
13648: IFFALSE 13686
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13650: LD_VAR 0 1
13654: PPUSH
13655: LD_INT 81
13657: PUSH
13658: LD_INT 7
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PPUSH
13665: CALL_OW 69
13669: PPUSH
13670: LD_VAR 0 1
13674: PPUSH
13675: CALL_OW 74
13679: PPUSH
13680: CALL_OW 112
13684: GO 13720
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 81
13693: PUSH
13694: LD_INT 7
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: PPUSH
13701: CALL_OW 69
13705: PPUSH
13706: LD_VAR 0 1
13710: PPUSH
13711: CALL_OW 74
13715: PPUSH
13716: CALL_OW 115
// end else
13720: GO 13738
// tmp := tmp diff i ;
13722: LD_ADDR_VAR 0 2
13726: PUSH
13727: LD_VAR 0 2
13731: PUSH
13732: LD_VAR 0 1
13736: DIFF
13737: ST_TO_ADDR
13738: GO 13617
13740: POP
13741: POP
// until not tmp ;
13742: LD_VAR 0 2
13746: NOT
13747: IFFALSE 13600
// end ; end_of_file
13749: PPOPN 4
13751: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13752: LD_INT 0
13754: PPUSH
13755: PPUSH
13756: PPUSH
13757: PPUSH
// missionStage := 13 ;
13758: LD_ADDR_EXP 15
13762: PUSH
13763: LD_INT 13
13765: ST_TO_ADDR
// uc_side := 2 ;
13766: LD_ADDR_OWVAR 20
13770: PUSH
13771: LD_INT 2
13773: ST_TO_ADDR
// uc_nation := 2 ;
13774: LD_ADDR_OWVAR 21
13778: PUSH
13779: LD_INT 2
13781: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13782: LD_ADDR_EXP 92
13786: PUSH
13787: LD_STRING Omar
13789: PPUSH
13790: CALL_OW 25
13794: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13795: LD_EXP 92
13799: PPUSH
13800: LD_INT 4
13802: PPUSH
13803: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13807: LD_EXP 92
13811: PPUSH
13812: LD_INT 242
13814: PPUSH
13815: LD_INT 75
13817: PPUSH
13818: LD_INT 0
13820: PPUSH
13821: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13825: LD_ADDR_EXP 93
13829: PUSH
13830: LD_STRING Heike
13832: PPUSH
13833: CALL_OW 25
13837: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13838: LD_INT 14
13840: PPUSH
13841: LD_INT 3
13843: PPUSH
13844: LD_INT 1
13846: PPUSH
13847: LD_INT 27
13849: PPUSH
13850: LD_INT 100
13852: PPUSH
13853: CALL 71861 0 5
// veh := CreateVehicle ;
13857: LD_ADDR_VAR 0 3
13861: PUSH
13862: CALL_OW 45
13866: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13867: LD_VAR 0 3
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: CALL_OW 242
// SetDir ( veh , 4 ) ;
13879: LD_VAR 0 3
13883: PPUSH
13884: LD_INT 4
13886: PPUSH
13887: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13891: LD_VAR 0 3
13895: PPUSH
13896: LD_INT 241
13898: PPUSH
13899: LD_INT 72
13901: PPUSH
13902: LD_INT 0
13904: PPUSH
13905: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13909: LD_EXP 93
13913: PPUSH
13914: LD_VAR 0 3
13918: PPUSH
13919: CALL_OW 52
// if KhatamStatus then
13923: LD_EXP 8
13927: IFFALSE 13978
// begin Khatam := NewCharacter ( Khatam ) ;
13929: LD_ADDR_EXP 94
13933: PUSH
13934: LD_STRING Khatam
13936: PPUSH
13937: CALL_OW 25
13941: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13942: LD_EXP 94
13946: PPUSH
13947: LD_INT 245
13949: PPUSH
13950: LD_INT 78
13952: PPUSH
13953: LD_INT 3
13955: PPUSH
13956: LD_INT 0
13958: PPUSH
13959: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13963: LD_EXP 94
13967: PPUSH
13968: LD_INT 4
13970: PPUSH
13971: LD_INT 10
13973: PPUSH
13974: CALL_OW 237
// end ; for i = 1 to Difficulty do
13978: LD_ADDR_VAR 0 2
13982: PUSH
13983: DOUBLE
13984: LD_INT 1
13986: DEC
13987: ST_TO_ADDR
13988: LD_OWVAR 67
13992: PUSH
13993: FOR_TO
13994: IFFALSE 14060
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13996: LD_INT 0
13998: PPUSH
13999: LD_INT 7
14001: PUSH
14002: LD_OWVAR 67
14006: PLUS
14007: PPUSH
14008: CALL_OW 384
// un := CreateHuman ;
14012: LD_ADDR_VAR 0 4
14016: PUSH
14017: CALL_OW 44
14021: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14022: LD_VAR 0 4
14026: PPUSH
14027: LD_INT 28
14029: PUSH
14030: LD_INT 29
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: LD_VAR 0 2
14041: PUSH
14042: LD_INT 2
14044: MOD
14045: PUSH
14046: LD_INT 1
14048: PLUS
14049: ARRAY
14050: PPUSH
14051: LD_INT 0
14053: PPUSH
14054: CALL_OW 49
// end ;
14058: GO 13993
14060: POP
14061: POP
// for i = 1 to 6 do
14062: LD_ADDR_VAR 0 2
14066: PUSH
14067: DOUBLE
14068: LD_INT 1
14070: DEC
14071: ST_TO_ADDR
14072: LD_INT 6
14074: PUSH
14075: FOR_TO
14076: IFFALSE 14121
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14078: LD_INT 0
14080: PPUSH
14081: LD_INT 7
14083: PUSH
14084: LD_OWVAR 67
14088: PLUS
14089: PPUSH
14090: CALL_OW 381
// un := CreateHuman ;
14094: LD_ADDR_VAR 0 4
14098: PUSH
14099: CALL_OW 44
14103: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14104: LD_VAR 0 4
14108: PPUSH
14109: LD_INT 28
14111: PPUSH
14112: LD_INT 0
14114: PPUSH
14115: CALL_OW 49
// end ;
14119: GO 14075
14121: POP
14122: POP
// for i = 1 to 3 do
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: DOUBLE
14129: LD_INT 1
14131: DEC
14132: ST_TO_ADDR
14133: LD_INT 3
14135: PUSH
14136: FOR_TO
14137: IFFALSE 14185
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14139: LD_INT 0
14141: PPUSH
14142: LD_INT 8
14144: PPUSH
14145: LD_INT 7
14147: PUSH
14148: LD_OWVAR 67
14152: PLUS
14153: PPUSH
14154: CALL_OW 380
// un := CreateHuman ;
14158: LD_ADDR_VAR 0 4
14162: PUSH
14163: CALL_OW 44
14167: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14168: LD_VAR 0 4
14172: PPUSH
14173: LD_INT 28
14175: PPUSH
14176: LD_INT 0
14178: PPUSH
14179: CALL_OW 49
// end ;
14183: GO 14136
14185: POP
14186: POP
// for i = 1 to 3 do
14187: LD_ADDR_VAR 0 2
14191: PUSH
14192: DOUBLE
14193: LD_INT 1
14195: DEC
14196: ST_TO_ADDR
14197: LD_INT 3
14199: PUSH
14200: FOR_TO
14201: IFFALSE 14291
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14203: LD_INT 14
14205: PPUSH
14206: LD_INT 2
14208: PPUSH
14209: LD_INT 1
14211: PPUSH
14212: LD_INT 28
14214: PPUSH
14215: LD_INT 80
14217: PPUSH
14218: CALL 71861 0 5
// veh := CreateVehicle ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: CALL_OW 45
14231: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14232: LD_VAR 0 3
14236: PPUSH
14237: LD_INT 3
14239: PPUSH
14240: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14244: LD_VAR 0 3
14248: PPUSH
14249: LD_INT 29
14251: PPUSH
14252: LD_INT 0
14254: PPUSH
14255: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14259: LD_INT 0
14261: PPUSH
14262: LD_INT 7
14264: PUSH
14265: LD_OWVAR 67
14269: PLUS
14270: PPUSH
14271: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_VAR 0 3
14284: PPUSH
14285: CALL_OW 52
// end ;
14289: GO 14200
14291: POP
14292: POP
// for i = 1 to 5 + Difficulty do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_INT 5
14305: PUSH
14306: LD_OWVAR 67
14310: PLUS
14311: PUSH
14312: FOR_TO
14313: IFFALSE 14440
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14315: LD_INT 14
14317: PPUSH
14318: LD_INT 1
14320: PPUSH
14321: LD_INT 3
14323: PPUSH
14324: CALL_OW 12
14328: PPUSH
14329: LD_INT 1
14331: PPUSH
14332: LD_INT 28
14334: PUSH
14335: LD_INT 26
14337: PUSH
14338: LD_INT 27
14340: PUSH
14341: LD_INT 25
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: PUSH
14350: LD_VAR 0 2
14354: PUSH
14355: LD_INT 4
14357: MOD
14358: PUSH
14359: LD_INT 1
14361: PLUS
14362: ARRAY
14363: PPUSH
14364: LD_INT 80
14366: PPUSH
14367: CALL 71861 0 5
// veh := CreateVehicle ;
14371: LD_ADDR_VAR 0 3
14375: PUSH
14376: CALL_OW 45
14380: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14381: LD_VAR 0 3
14385: PPUSH
14386: LD_INT 4
14388: PPUSH
14389: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14393: LD_VAR 0 3
14397: PPUSH
14398: LD_INT 28
14400: PPUSH
14401: LD_INT 0
14403: PPUSH
14404: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14408: LD_INT 0
14410: PPUSH
14411: LD_INT 7
14413: PUSH
14414: LD_OWVAR 67
14418: PLUS
14419: PPUSH
14420: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14424: CALL_OW 44
14428: PPUSH
14429: LD_VAR 0 3
14433: PPUSH
14434: CALL_OW 52
// end ;
14438: GO 14312
14440: POP
14441: POP
// for i = 1 to 3 do
14442: LD_ADDR_VAR 0 2
14446: PUSH
14447: DOUBLE
14448: LD_INT 1
14450: DEC
14451: ST_TO_ADDR
14452: LD_INT 3
14454: PUSH
14455: FOR_TO
14456: IFFALSE 14516
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14458: LD_INT 14
14460: PPUSH
14461: LD_INT 3
14463: PPUSH
14464: LD_INT 5
14466: PPUSH
14467: LD_INT 29
14469: PPUSH
14470: LD_INT 80
14472: PPUSH
14473: CALL 71861 0 5
// veh := CreateVehicle ;
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: CALL_OW 45
14486: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14487: LD_VAR 0 3
14491: PPUSH
14492: LD_INT 4
14494: PPUSH
14495: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14499: LD_VAR 0 3
14503: PPUSH
14504: LD_INT 28
14506: PPUSH
14507: LD_INT 0
14509: PPUSH
14510: CALL_OW 49
// end ;
14514: GO 14455
14516: POP
14517: POP
// end ;
14518: LD_VAR 0 1
14522: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14523: LD_INT 22
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PPUSH
14533: CALL_OW 69
14537: IFFALSE 14837
14539: GO 14541
14541: DISABLE
14542: LD_INT 0
14544: PPUSH
14545: PPUSH
14546: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14547: LD_ADDR_VAR 0 3
14551: PUSH
14552: LD_INT 22
14554: PUSH
14555: LD_INT 2
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 4
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: PPUSH
14576: CALL_OW 69
14580: PUSH
14581: LD_EXP 94
14585: DIFF
14586: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_INT 22
14594: PUSH
14595: LD_INT 2
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PPUSH
14602: CALL_OW 69
14606: PUSH
14607: LD_EXP 94
14611: PUSH
14612: LD_VAR 0 3
14616: UNION
14617: DIFF
14618: ST_TO_ADDR
// if Khatam then
14619: LD_EXP 94
14623: IFFALSE 14640
// ComMoveXY ( Khatam , 211 , 92 ) ;
14625: LD_EXP 94
14629: PPUSH
14630: LD_INT 211
14632: PPUSH
14633: LD_INT 92
14635: PPUSH
14636: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14640: LD_INT 197
14642: PPUSH
14643: LD_INT 80
14645: PPUSH
14646: LD_INT 2
14648: PPUSH
14649: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14653: LD_INT 213
14655: PPUSH
14656: LD_INT 90
14658: PPUSH
14659: LD_INT 2
14661: PPUSH
14662: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14666: LD_INT 215
14668: PPUSH
14669: LD_INT 129
14671: PPUSH
14672: LD_INT 2
14674: PPUSH
14675: CALL_OW 441
// if sci then
14679: LD_VAR 0 3
14683: IFFALSE 14704
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14685: LD_VAR 0 3
14689: PUSH
14690: LD_INT 1
14692: ARRAY
14693: PPUSH
14694: LD_INT 197
14696: PPUSH
14697: LD_INT 80
14699: PPUSH
14700: CALL_OW 158
// if sci > 1 then
14704: LD_VAR 0 3
14708: PUSH
14709: LD_INT 1
14711: GREATER
14712: IFFALSE 14733
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14714: LD_VAR 0 3
14718: PUSH
14719: LD_INT 2
14721: ARRAY
14722: PPUSH
14723: LD_INT 213
14725: PPUSH
14726: LD_INT 90
14728: PPUSH
14729: CALL_OW 158
// if sci > 2 then
14733: LD_VAR 0 3
14737: PUSH
14738: LD_INT 2
14740: GREATER
14741: IFFALSE 14762
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14743: LD_VAR 0 3
14747: PUSH
14748: LD_INT 3
14750: ARRAY
14751: PPUSH
14752: LD_INT 215
14754: PPUSH
14755: LD_INT 129
14757: PPUSH
14758: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14762: LD_INT 35
14764: PPUSH
14765: CALL_OW 67
// for i in tmp do
14769: LD_ADDR_VAR 0 1
14773: PUSH
14774: LD_VAR 0 2
14778: PUSH
14779: FOR_IN
14780: IFFALSE 14818
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_INT 81
14789: PUSH
14790: LD_INT 2
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: PPUSH
14797: CALL_OW 69
14801: PPUSH
14802: LD_VAR 0 1
14806: PPUSH
14807: CALL_OW 74
14811: PPUSH
14812: CALL_OW 115
14816: GO 14779
14818: POP
14819: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14820: LD_INT 22
14822: PUSH
14823: LD_INT 2
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 69
14834: NOT
14835: IFFALSE 14762
// end ; end_of_file
14837: PPOPN 3
14839: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14840: LD_INT 0
14842: PPUSH
14843: PPUSH
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
// Video ( true ) ;
14851: LD_INT 1
14853: PPUSH
14854: CALL 107581 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14858: LD_ADDR_VAR 0 5
14862: PUSH
14863: LD_INT 7
14865: PPUSH
14866: LD_INT 0
14868: PPUSH
14869: CALL_OW 517
14873: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14874: LD_ADDR_VAR 0 2
14878: PUSH
14879: DOUBLE
14880: LD_INT 1
14882: DEC
14883: ST_TO_ADDR
14884: LD_VAR 0 5
14888: PUSH
14889: LD_INT 1
14891: ARRAY
14892: PUSH
14893: FOR_TO
14894: IFFALSE 14939
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14896: LD_VAR 0 5
14900: PUSH
14901: LD_INT 1
14903: ARRAY
14904: PUSH
14905: LD_VAR 0 2
14909: ARRAY
14910: PPUSH
14911: LD_VAR 0 5
14915: PUSH
14916: LD_INT 2
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 2
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: LD_INT 15
14931: NEG
14932: PPUSH
14933: CALL 107495 0 4
14937: GO 14893
14939: POP
14940: POP
// CenterNowOnUnits ( Powell ) ;
14941: LD_EXP 58
14945: PPUSH
14946: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_EXP 56
14959: PUSH
14960: EMPTY
14961: LIST
14962: ST_TO_ADDR
// if GirlNewVeh then
14963: LD_EXP 57
14967: IFFALSE 14985
// tmp := tmp ^ GirlNewVeh ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_VAR 0 5
14978: PUSH
14979: LD_EXP 57
14983: ADD
14984: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14985: LD_VAR 0 5
14989: PPUSH
14990: LD_INT 60
14992: PPUSH
14993: LD_INT 109
14995: PPUSH
14996: CALL_OW 111
// if KappaStatus then
15000: LD_EXP 2
15004: IFFALSE 15056
// begin Say ( JMM , D1nT-JMM-1 ) ;
15006: LD_EXP 39
15010: PPUSH
15011: LD_STRING D1nT-JMM-1
15013: PPUSH
15014: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15018: LD_EXP 58
15022: PPUSH
15023: LD_STRING D1T-Pow-1
15025: PPUSH
15026: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15030: LD_EXP 39
15034: PPUSH
15035: LD_STRING D1T-JMM-2
15037: PPUSH
15038: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15042: LD_EXP 58
15046: PPUSH
15047: LD_STRING D1T-Pow-2
15049: PPUSH
15050: CALL_OW 88
// end else
15054: GO 15262
// if JMMGirlStatus then
15056: LD_EXP 6
15060: IFFALSE 15205
// begin Say ( JMM , D1T-JMM-1 ) ;
15062: LD_EXP 39
15066: PPUSH
15067: LD_STRING D1T-JMM-1
15069: PPUSH
15070: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15074: LD_EXP 58
15078: PPUSH
15079: LD_STRING D1T-Pow-1
15081: PPUSH
15082: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15086: LD_EXP 39
15090: PPUSH
15091: LD_STRING D1T-JMM-3
15093: PPUSH
15094: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15098: LD_EXP 58
15102: PPUSH
15103: LD_STRING D1T-Pow-3
15105: PPUSH
15106: CALL_OW 88
// if JMMGirl then
15110: LD_EXP 7
15114: IFFALSE 15203
// begin case JMMGirl of 1 :
15116: LD_EXP 7
15120: PUSH
15121: LD_INT 1
15123: DOUBLE
15124: EQUAL
15125: IFTRUE 15129
15127: GO 15144
15129: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15130: LD_EXP 40
15134: PPUSH
15135: LD_STRING D1T-Joan-3
15137: PPUSH
15138: CALL_OW 88
15142: GO 15191
15144: LD_INT 2
15146: DOUBLE
15147: EQUAL
15148: IFTRUE 15152
15150: GO 15167
15152: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15153: LD_EXP 42
15157: PPUSH
15158: LD_STRING D1T-Lisa-3
15160: PPUSH
15161: CALL_OW 88
15165: GO 15191
15167: LD_INT 3
15169: DOUBLE
15170: EQUAL
15171: IFTRUE 15175
15173: GO 15190
15175: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15176: LD_EXP 54
15180: PPUSH
15181: LD_STRING D1T-Con-3
15183: PPUSH
15184: CALL_OW 88
15188: GO 15191
15190: POP
// Say ( Powell , D1T-Pow-4 ) ;
15191: LD_EXP 58
15195: PPUSH
15196: LD_STRING D1T-Pow-4
15198: PPUSH
15199: CALL_OW 88
// end ; end else
15203: GO 15262
// if not FastEnd then
15205: LD_EXP 11
15209: NOT
15210: IFFALSE 15238
// begin Say ( JMM , D1T-JMM-4 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-4
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-5
15231: PPUSH
15232: CALL_OW 88
// end else
15236: GO 15262
// begin Say ( JMM , D1nT-JMM-1 ) ;
15238: LD_EXP 39
15242: PPUSH
15243: LD_STRING D1nT-JMM-1
15245: PPUSH
15246: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15250: LD_EXP 58
15254: PPUSH
15255: LD_STRING D1nT-Pow-1
15257: PPUSH
15258: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15262: LD_INT 35
15264: PPUSH
15265: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15269: LD_EXP 56
15273: PPUSH
15274: CALL_OW 314
15278: NOT
15279: IFFALSE 15262
// ComExitVehicle ( JMM ) ;
15281: LD_EXP 39
15285: PPUSH
15286: CALL_OW 121
// wait ( 3 ) ;
15290: LD_INT 3
15292: PPUSH
15293: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15297: LD_EXP 39
15301: PPUSH
15302: LD_INT 60
15304: PPUSH
15305: LD_INT 94
15307: PPUSH
15308: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15312: LD_EXP 39
15316: PPUSH
15317: LD_EXP 58
15321: PPUSH
15322: CALL_OW 179
// if Joan then
15326: LD_EXP 40
15330: IFFALSE 15384
// begin ComExitVehicle ( Joan ) ;
15332: LD_EXP 40
15336: PPUSH
15337: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15341: LD_EXP 40
15345: PPUSH
15346: LD_INT 35
15348: PPUSH
15349: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15353: LD_EXP 40
15357: PPUSH
15358: LD_INT 65
15360: PPUSH
15361: LD_INT 104
15363: PPUSH
15364: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15368: LD_EXP 40
15372: PPUSH
15373: LD_EXP 39
15377: PPUSH
15378: CALL_OW 179
// end else
15382: GO 15518
// if Lisa and JMMGirl = 2 then
15384: LD_EXP 42
15388: PUSH
15389: LD_EXP 7
15393: PUSH
15394: LD_INT 2
15396: EQUAL
15397: AND
15398: IFFALSE 15452
// begin ComExitVehicle ( Lisa ) ;
15400: LD_EXP 42
15404: PPUSH
15405: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15409: LD_EXP 42
15413: PPUSH
15414: LD_INT 35
15416: PPUSH
15417: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15421: LD_EXP 42
15425: PPUSH
15426: LD_INT 65
15428: PPUSH
15429: LD_INT 104
15431: PPUSH
15432: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15436: LD_EXP 42
15440: PPUSH
15441: LD_EXP 39
15445: PPUSH
15446: CALL_OW 179
// end else
15450: GO 15518
// if Connie and JMMGirl = 3 then
15452: LD_EXP 54
15456: PUSH
15457: LD_EXP 7
15461: PUSH
15462: LD_INT 3
15464: EQUAL
15465: AND
15466: IFFALSE 15518
// begin ComExitVehicle ( Connie ) ;
15468: LD_EXP 54
15472: PPUSH
15473: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15477: LD_EXP 54
15481: PPUSH
15482: LD_INT 35
15484: PPUSH
15485: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15489: LD_EXP 54
15493: PPUSH
15494: LD_INT 65
15496: PPUSH
15497: LD_INT 104
15499: PPUSH
15500: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15504: LD_EXP 54
15508: PPUSH
15509: LD_EXP 39
15513: PPUSH
15514: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15518: LD_INT 35
15520: PPUSH
15521: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15525: LD_EXP 39
15529: PPUSH
15530: LD_EXP 58
15534: PPUSH
15535: CALL_OW 296
15539: PUSH
15540: LD_INT 6
15542: LESS
15543: IFFALSE 15518
// wait ( 0 0$0.5 ) ;
15545: LD_INT 18
15547: PPUSH
15548: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15552: LD_EXP 39
15556: PPUSH
15557: LD_STRING D1-JMM-1
15559: PPUSH
15560: CALL_OW 88
// async ;
15564: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15565: LD_EXP 58
15569: PPUSH
15570: LD_STRING D1-Pow-1
15572: PPUSH
15573: CALL_OW 88
// if not dialogue_skipped then
15577: LD_OWVAR 59
15581: NOT
15582: IFFALSE 15591
// wait ( 0 0$2 ) ;
15584: LD_INT 70
15586: PPUSH
15587: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15591: LD_INT 170
15593: PPUSH
15594: LD_INT 99
15596: PPUSH
15597: LD_INT 1
15599: PPUSH
15600: LD_INT 6
15602: NEG
15603: PPUSH
15604: CALL 107495 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15608: LD_INT 174
15610: PPUSH
15611: LD_INT 115
15613: PPUSH
15614: LD_INT 1
15616: PPUSH
15617: LD_INT 6
15619: NEG
15620: PPUSH
15621: CALL 107495 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15625: LD_INT 169
15627: PPUSH
15628: LD_INT 71
15630: PPUSH
15631: LD_INT 1
15633: PPUSH
15634: LD_INT 6
15636: NEG
15637: PPUSH
15638: CALL 107495 0 4
// if not dialogue_skipped then
15642: LD_OWVAR 59
15646: NOT
15647: IFFALSE 15666
// begin CenterOnXY ( 170 , 99 ) ;
15649: LD_INT 170
15651: PPUSH
15652: LD_INT 99
15654: PPUSH
15655: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15659: LD_INT 80
15661: PPUSH
15662: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15666: LD_INT 75
15668: PPUSH
15669: LD_INT 53
15671: PPUSH
15672: LD_INT 1
15674: PPUSH
15675: LD_INT 9
15677: NEG
15678: PPUSH
15679: CALL 107495 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15683: LD_INT 54
15685: PPUSH
15686: LD_INT 42
15688: PPUSH
15689: LD_INT 1
15691: PPUSH
15692: LD_INT 9
15694: NEG
15695: PPUSH
15696: CALL 107495 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15700: LD_INT 62
15702: PPUSH
15703: LD_INT 51
15705: PPUSH
15706: LD_INT 1
15708: PPUSH
15709: LD_INT 9
15711: NEG
15712: PPUSH
15713: CALL 107495 0 4
// if not dialogue_skipped then
15717: LD_OWVAR 59
15721: NOT
15722: IFFALSE 15741
// begin CenterOnXY ( 75 , 53 ) ;
15724: LD_INT 75
15726: PPUSH
15727: LD_INT 53
15729: PPUSH
15730: CALL_OW 84
// wait ( 0 0$4 ) ;
15734: LD_INT 140
15736: PPUSH
15737: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15741: LD_EXP 58
15745: PPUSH
15746: CALL_OW 87
// if not dialogue_skipped then
15750: LD_OWVAR 59
15754: NOT
15755: IFFALSE 15764
// wait ( 0 0$2 ) ;
15757: LD_INT 70
15759: PPUSH
15760: CALL_OW 67
// sync ;
15764: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15765: LD_EXP 39
15769: PPUSH
15770: LD_STRING D1-JMM-2
15772: PPUSH
15773: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15777: LD_EXP 58
15781: PPUSH
15782: LD_STRING D1-Pow-2
15784: PPUSH
15785: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15789: LD_EXP 39
15793: PPUSH
15794: LD_STRING D1-JMM-3
15796: PPUSH
15797: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15801: LD_EXP 58
15805: PPUSH
15806: LD_STRING D1-Pow-3
15808: PPUSH
15809: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15813: LD_EXP 39
15817: PPUSH
15818: LD_STRING D1-JMM-4
15820: PPUSH
15821: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15825: LD_EXP 58
15829: PPUSH
15830: LD_STRING D1-Pow-4
15832: PPUSH
15833: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15837: LD_EXP 39
15841: PPUSH
15842: LD_STRING D1-JMM-5
15844: PPUSH
15845: CALL_OW 88
// async ;
15849: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15850: LD_EXP 58
15854: PPUSH
15855: LD_STRING D1-Pow-5
15857: PPUSH
15858: CALL_OW 88
// if not dialogue_skipped then
15862: LD_OWVAR 59
15866: NOT
15867: IFFALSE 15876
// wait ( 0 0$3.6 ) ;
15869: LD_INT 126
15871: PPUSH
15872: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15876: LD_INT 134
15878: PPUSH
15879: LD_INT 210
15881: PPUSH
15882: LD_INT 1
15884: PPUSH
15885: LD_INT 11
15887: NEG
15888: PPUSH
15889: CALL 107495 0 4
// if not dialogue_skipped then
15893: LD_OWVAR 59
15897: NOT
15898: IFFALSE 15917
// begin CenterOnXY ( 134 , 210 ) ;
15900: LD_INT 134
15902: PPUSH
15903: LD_INT 210
15905: PPUSH
15906: CALL_OW 84
// wait ( 0 0$2 ) ;
15910: LD_INT 70
15912: PPUSH
15913: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15917: LD_INT 101
15919: PPUSH
15920: LD_INT 159
15922: PPUSH
15923: LD_INT 1
15925: PPUSH
15926: LD_INT 10
15928: NEG
15929: PPUSH
15930: CALL 107495 0 4
// if not dialogue_skipped then
15934: LD_OWVAR 59
15938: NOT
15939: IFFALSE 15958
// begin CenterOnXY ( 101 , 159 ) ;
15941: LD_INT 101
15943: PPUSH
15944: LD_INT 159
15946: PPUSH
15947: CALL_OW 84
// wait ( 0 0$2 ) ;
15951: LD_INT 70
15953: PPUSH
15954: CALL_OW 67
// end ; sync ;
15958: SYNC
// CenterNowOnUnits ( Powell ) ;
15959: LD_EXP 58
15963: PPUSH
15964: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15968: LD_ADDR_VAR 0 6
15972: PUSH
15973: LD_INT 1
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: LD_INT 3
15981: PUSH
15982: LD_INT 4
15984: PUSH
15985: LD_INT 5
15987: PUSH
15988: LD_INT 6
15990: PUSH
15991: EMPTY
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: ST_TO_ADDR
// if not dialogue_skipped then
15999: LD_OWVAR 59
16003: NOT
16004: IFFALSE 16173
// begin game_speed := 4 ;
16006: LD_ADDR_OWVAR 65
16010: PUSH
16011: LD_INT 4
16013: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16021: LD_ADDR_VAR 0 7
16025: PUSH
16026: LD_STRING Q1
16028: PPUSH
16029: LD_VAR 0 6
16033: PPUSH
16034: CALL_OW 98
16038: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16039: LD_ADDR_VAR 0 7
16043: PUSH
16044: LD_STRING Q1
16046: PPUSH
16047: LD_VAR 0 6
16051: PPUSH
16052: CALL_OW 98
16056: ST_TO_ADDR
// options = options diff dec ;
16057: LD_ADDR_VAR 0 6
16061: PUSH
16062: LD_VAR 0 6
16066: PUSH
16067: LD_VAR 0 7
16071: DIFF
16072: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16073: LD_VAR 0 7
16077: PPUSH
16078: LD_VAR 0 6
16082: PPUSH
16083: CALL 17645 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16087: LD_VAR 0 7
16091: PUSH
16092: LD_INT 5
16094: PUSH
16095: LD_INT 6
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: IN
16102: PUSH
16103: LD_VAR 0 6
16107: PUSH
16108: LD_INT 2
16110: EQUAL
16111: OR
16112: IFFALSE 16039
// if not ( dec in [ 5 , 6 ] ) then
16114: LD_VAR 0 7
16118: PUSH
16119: LD_INT 5
16121: PUSH
16122: LD_INT 6
16124: PUSH
16125: EMPTY
16126: LIST
16127: LIST
16128: IN
16129: NOT
16130: IFFALSE 16173
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1a
16139: PPUSH
16140: LD_INT 1
16142: PUSH
16143: LD_INT 2
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PPUSH
16150: CALL_OW 98
16154: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16155: LD_VAR 0 7
16159: PUSH
16160: LD_INT 4
16162: PLUS
16163: PPUSH
16164: LD_VAR 0 6
16168: PPUSH
16169: CALL 17645 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16173: LD_INT 81
16175: PPUSH
16176: LD_INT 127
16178: PPUSH
16179: CALL_OW 84
// amount := 5 ;
16183: LD_ADDR_VAR 0 8
16187: PUSH
16188: LD_INT 5
16190: ST_TO_ADDR
// macmilan_squad := [ ] ;
16191: LD_ADDR_VAR 0 9
16195: PUSH
16196: EMPTY
16197: ST_TO_ADDR
// if vip < amount then
16198: LD_EXP 59
16202: PUSH
16203: LD_VAR 0 8
16207: LESS
16208: IFFALSE 16252
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_EXP 59
16219: PUSH
16220: LD_INT 22
16222: PUSH
16223: LD_INT 4
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 21
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: PPUSH
16244: CALL_OW 69
16248: UNION
16249: ST_TO_ADDR
16250: GO 16262
// tmp := vip ;
16252: LD_ADDR_VAR 0 5
16256: PUSH
16257: LD_EXP 59
16261: ST_TO_ADDR
// tmp := tmp diff Powell ;
16262: LD_ADDR_VAR 0 5
16266: PUSH
16267: LD_VAR 0 5
16271: PUSH
16272: LD_EXP 58
16276: DIFF
16277: ST_TO_ADDR
// if tmp < amount then
16278: LD_VAR 0 5
16282: PUSH
16283: LD_VAR 0 8
16287: LESS
16288: IFFALSE 16300
// amount := tmp ;
16290: LD_ADDR_VAR 0 8
16294: PUSH
16295: LD_VAR 0 5
16299: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16300: LD_VAR 0 5
16304: PUSH
16305: LD_INT 1
16307: ARRAY
16308: PPUSH
16309: CALL_OW 257
16313: PUSH
16314: LD_INT 2
16316: NONEQUAL
16317: IFFALSE 16379
// begin if IsInUnit ( tmp [ 1 ] ) then
16319: LD_VAR 0 5
16323: PUSH
16324: LD_INT 1
16326: ARRAY
16327: PPUSH
16328: CALL_OW 310
16332: IFFALSE 16347
// ComExitBuilding ( tmp [ 1 ] ) ;
16334: LD_VAR 0 5
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16347: LD_VAR 0 5
16351: PUSH
16352: LD_INT 1
16354: ARRAY
16355: PPUSH
16356: LD_INT 387
16358: PPUSH
16359: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16363: LD_VAR 0 5
16367: PUSH
16368: LD_INT 1
16370: ARRAY
16371: PPUSH
16372: LD_INT 2
16374: PPUSH
16375: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16379: LD_EXP 39
16383: PPUSH
16384: LD_INT 82
16386: PPUSH
16387: LD_INT 129
16389: PPUSH
16390: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16394: LD_EXP 39
16398: PPUSH
16399: LD_EXP 58
16403: PPUSH
16404: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16408: LD_INT 22
16410: PUSH
16411: LD_INT 1
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PPUSH
16418: CALL_OW 69
16422: PUSH
16423: LD_EXP 39
16427: DIFF
16428: PPUSH
16429: LD_INT 84
16431: PPUSH
16432: LD_INT 128
16434: PPUSH
16435: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16439: LD_INT 22
16441: PUSH
16442: LD_INT 1
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: PPUSH
16449: CALL_OW 69
16453: PUSH
16454: LD_EXP 39
16458: DIFF
16459: PPUSH
16460: LD_EXP 39
16464: PPUSH
16465: CALL_OW 179
// for i = 1 to amount do
16469: LD_ADDR_VAR 0 2
16473: PUSH
16474: DOUBLE
16475: LD_INT 1
16477: DEC
16478: ST_TO_ADDR
16479: LD_VAR 0 8
16483: PUSH
16484: FOR_TO
16485: IFFALSE 16653
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16487: LD_ADDR_VAR 0 9
16491: PUSH
16492: LD_VAR 0 9
16496: PUSH
16497: LD_VAR 0 5
16501: PUSH
16502: LD_VAR 0 2
16506: ARRAY
16507: ADD
16508: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16509: LD_VAR 0 5
16513: PUSH
16514: LD_VAR 0 2
16518: ARRAY
16519: PPUSH
16520: CALL_OW 310
16524: IFFALSE 16541
// AddComExitBuilding ( tmp [ i ] ) ;
16526: LD_VAR 0 5
16530: PUSH
16531: LD_VAR 0 2
16535: ARRAY
16536: PPUSH
16537: CALL_OW 182
// if i = 2 and JMMNewVeh then
16541: LD_VAR 0 2
16545: PUSH
16546: LD_INT 2
16548: EQUAL
16549: PUSH
16550: LD_EXP 56
16554: AND
16555: IFFALSE 16613
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16557: LD_VAR 0 5
16561: PUSH
16562: LD_VAR 0 2
16566: ARRAY
16567: PPUSH
16568: LD_EXP 56
16572: PPUSH
16573: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16577: LD_VAR 0 5
16581: PUSH
16582: LD_VAR 0 2
16586: ARRAY
16587: PPUSH
16588: LD_INT 86
16590: PPUSH
16591: LD_INT 133
16593: PPUSH
16594: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16598: LD_VAR 0 5
16602: PUSH
16603: LD_VAR 0 2
16607: ARRAY
16608: PPUSH
16609: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16613: LD_VAR 0 5
16617: PUSH
16618: LD_VAR 0 2
16622: ARRAY
16623: PPUSH
16624: LD_INT 8
16626: PPUSH
16627: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16631: LD_VAR 0 5
16635: PUSH
16636: LD_VAR 0 2
16640: ARRAY
16641: PPUSH
16642: LD_EXP 39
16646: PPUSH
16647: CALL_OW 179
// end ;
16651: GO 16484
16653: POP
16654: POP
// if GirlNewVeh then
16655: LD_EXP 57
16659: IFFALSE 16673
// SetSide ( GirlNewVeh , 4 ) ;
16661: LD_EXP 57
16665: PPUSH
16666: LD_INT 4
16668: PPUSH
16669: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16673: LD_INT 35
16675: PPUSH
16676: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16680: LD_VAR 0 9
16684: PPUSH
16685: LD_INT 95
16687: PUSH
16688: LD_INT 9
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL_OW 72
16699: PUSH
16700: LD_INT 0
16702: EQUAL
16703: PUSH
16704: LD_EXP 39
16708: PPUSH
16709: LD_INT 9
16711: PPUSH
16712: CALL_OW 308
16716: NOT
16717: AND
16718: IFFALSE 16673
// wait ( 0 0$2 ) ;
16720: LD_INT 70
16722: PPUSH
16723: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16727: LD_VAR 0 9
16731: PPUSH
16732: LD_INT 1
16734: PPUSH
16735: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16739: LD_INT 21
16741: PUSH
16742: LD_INT 2
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PUSH
16749: LD_INT 92
16751: PUSH
16752: LD_INT 83
16754: PUSH
16755: LD_INT 130
16757: PUSH
16758: LD_INT 10
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: PPUSH
16771: CALL_OW 69
16775: PPUSH
16776: LD_INT 1
16778: PPUSH
16779: CALL_OW 235
// Video ( false ) ;
16783: LD_INT 0
16785: PPUSH
16786: CALL 107581 0 1
// ChangeMissionObjectives ( M1 ) ;
16790: LD_STRING M1
16792: PPUSH
16793: CALL_OW 337
// SaveForQuickRestart ;
16797: CALL_OW 22
// missionStart := true ;
16801: LD_ADDR_EXP 13
16805: PUSH
16806: LD_INT 1
16808: ST_TO_ADDR
// missionStage := 2 ;
16809: LD_ADDR_EXP 15
16813: PUSH
16814: LD_INT 2
16816: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16817: LD_INT 105
16819: PPUSH
16820: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16824: LD_ADDR_VAR 0 5
16828: PUSH
16829: LD_INT 22
16831: PUSH
16832: LD_INT 4
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: LD_INT 21
16841: PUSH
16842: LD_INT 1
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 69
16857: PUSH
16858: LD_EXP 58
16862: DIFF
16863: ST_TO_ADDR
// if not tmp then
16864: LD_VAR 0 5
16868: NOT
16869: IFFALSE 16884
// tmp := [ Powell ] ;
16871: LD_ADDR_VAR 0 5
16875: PUSH
16876: LD_EXP 58
16880: PUSH
16881: EMPTY
16882: LIST
16883: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16884: LD_ADDR_EXP 102
16888: PUSH
16889: LD_EXP 102
16893: PPUSH
16894: LD_INT 4
16896: PPUSH
16897: LD_INT 22
16899: PUSH
16900: LD_INT 4
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: LD_INT 23
16909: PUSH
16910: LD_INT 1
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: PUSH
16917: LD_INT 3
16919: PUSH
16920: LD_INT 21
16922: PUSH
16923: LD_INT 2
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: LIST
16938: PPUSH
16939: CALL_OW 69
16943: PUSH
16944: LD_EXP 58
16948: DIFF
16949: PPUSH
16950: CALL_OW 1
16954: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16955: LD_ADDR_VAR 0 4
16959: PUSH
16960: LD_INT 22
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: LD_INT 34
16972: PUSH
16973: LD_INT 12
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PPUSH
16984: CALL_OW 69
16988: PUSH
16989: LD_INT 1
16991: ARRAY
16992: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16993: LD_VAR 0 5
16997: PUSH
16998: LD_INT 1
17000: ARRAY
17001: PPUSH
17002: CALL_OW 310
17006: IFFALSE 17021
// ComExitBuilding ( tmp [ 1 ] ) ;
17008: LD_VAR 0 5
17012: PUSH
17013: LD_INT 1
17015: ARRAY
17016: PPUSH
17017: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17021: LD_VAR 0 5
17025: PUSH
17026: LD_INT 1
17028: ARRAY
17029: PPUSH
17030: LD_VAR 0 4
17034: PPUSH
17035: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17039: LD_VAR 0 5
17043: PUSH
17044: LD_INT 1
17046: ARRAY
17047: PPUSH
17048: LD_INT 80
17050: PPUSH
17051: LD_INT 136
17053: PPUSH
17054: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17058: LD_VAR 0 5
17062: PUSH
17063: LD_INT 1
17065: ARRAY
17066: PPUSH
17067: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17071: LD_VAR 0 5
17075: PUSH
17076: LD_INT 1
17078: ARRAY
17079: PPUSH
17080: LD_INT 59
17082: PPUSH
17083: LD_INT 112
17085: PPUSH
17086: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17090: LD_VAR 0 5
17094: PUSH
17095: LD_INT 1
17097: ARRAY
17098: PPUSH
17099: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17103: LD_EXP 40
17107: PUSH
17108: LD_EXP 40
17112: PPUSH
17113: CALL_OW 255
17117: PUSH
17118: LD_INT 1
17120: EQUAL
17121: AND
17122: IFFALSE 17148
// begin Say ( Joan , D3W-Joan-1 ) ;
17124: LD_EXP 40
17128: PPUSH
17129: LD_STRING D3W-Joan-1
17131: PPUSH
17132: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17136: LD_EXP 39
17140: PPUSH
17141: LD_STRING D3W-JMM-1
17143: PPUSH
17144: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17148: LD_EXP 42
17152: PUSH
17153: LD_EXP 42
17157: PPUSH
17158: CALL_OW 255
17162: PUSH
17163: LD_INT 1
17165: EQUAL
17166: AND
17167: PUSH
17168: LD_EXP 42
17172: PUSH
17173: LD_EXP 59
17177: IN
17178: NOT
17179: AND
17180: IFFALSE 17206
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17182: LD_EXP 42
17186: PPUSH
17187: LD_STRING D3W-Lisa-1
17189: PPUSH
17190: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17194: LD_EXP 39
17198: PPUSH
17199: LD_STRING D3W-JMM-1
17201: PPUSH
17202: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17206: LD_EXP 54
17210: PUSH
17211: LD_EXP 54
17215: PPUSH
17216: CALL_OW 255
17220: PUSH
17221: LD_INT 1
17223: EQUAL
17224: AND
17225: IFFALSE 17251
// begin Say ( Connie , D3W-Con-1 ) ;
17227: LD_EXP 54
17231: PPUSH
17232: LD_STRING D3W-Con-1
17234: PPUSH
17235: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17239: LD_EXP 39
17243: PPUSH
17244: LD_STRING D3W-JMM-1
17246: PPUSH
17247: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17251: LD_EXP 42
17255: PUSH
17256: LD_EXP 59
17260: IN
17261: PUSH
17262: LD_EXP 42
17266: PPUSH
17267: CALL_OW 255
17271: PUSH
17272: LD_INT 1
17274: EQUAL
17275: AND
17276: IFFALSE 17292
// Say ( Lisa , D3nW-Lisa-1 ) else
17278: LD_EXP 42
17282: PPUSH
17283: LD_STRING D3nW-Lisa-1
17285: PPUSH
17286: CALL_OW 88
17290: GO 17536
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17292: LD_EXP 45
17296: PUSH
17297: LD_EXP 59
17301: IN
17302: PUSH
17303: LD_EXP 45
17307: PPUSH
17308: CALL_OW 255
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: AND
17317: IFFALSE 17333
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17319: LD_EXP 45
17323: PPUSH
17324: LD_STRING D3nW-Cyrus-1
17326: PPUSH
17327: CALL_OW 88
17331: GO 17536
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17333: LD_EXP 44
17337: PUSH
17338: LD_EXP 59
17342: IN
17343: PUSH
17344: LD_EXP 44
17348: PPUSH
17349: CALL_OW 255
17353: PUSH
17354: LD_INT 1
17356: EQUAL
17357: AND
17358: IFFALSE 17374
// Say ( Bobby , D3nW-Bobby-1 ) else
17360: LD_EXP 44
17364: PPUSH
17365: LD_STRING D3nW-Bobby-1
17367: PPUSH
17368: CALL_OW 88
17372: GO 17536
// if Gary in vip and GetSide ( Gary ) = 1 then
17374: LD_EXP 51
17378: PUSH
17379: LD_EXP 59
17383: IN
17384: PUSH
17385: LD_EXP 51
17389: PPUSH
17390: CALL_OW 255
17394: PUSH
17395: LD_INT 1
17397: EQUAL
17398: AND
17399: IFFALSE 17415
// Say ( Gary , D3nW-Gary-1 ) else
17401: LD_EXP 51
17405: PPUSH
17406: LD_STRING D3nW-Gary-1
17408: PPUSH
17409: CALL_OW 88
17413: GO 17536
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17415: LD_EXP 43
17419: PUSH
17420: LD_EXP 59
17424: IN
17425: PUSH
17426: LD_EXP 43
17430: PPUSH
17431: CALL_OW 255
17435: PUSH
17436: LD_INT 1
17438: EQUAL
17439: AND
17440: IFFALSE 17456
// Say ( Donaldson , D3nW-Don-1 ) else
17442: LD_EXP 43
17446: PPUSH
17447: LD_STRING D3nW-Don-1
17449: PPUSH
17450: CALL_OW 88
17454: GO 17536
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17456: LD_EXP 50
17460: PUSH
17461: LD_EXP 59
17465: IN
17466: PUSH
17467: LD_EXP 50
17471: PPUSH
17472: CALL_OW 255
17476: PUSH
17477: LD_INT 1
17479: EQUAL
17480: AND
17481: IFFALSE 17497
// Say ( Cornel , D3nW-Corn-1 ) else
17483: LD_EXP 50
17487: PPUSH
17488: LD_STRING D3nW-Corn-1
17490: PPUSH
17491: CALL_OW 88
17495: GO 17536
// if Frank in vip and GetSide ( Frank ) = 1 then
17497: LD_EXP 52
17501: PUSH
17502: LD_EXP 59
17506: IN
17507: PUSH
17508: LD_EXP 52
17512: PPUSH
17513: CALL_OW 255
17517: PUSH
17518: LD_INT 1
17520: EQUAL
17521: AND
17522: IFFALSE 17536
// Say ( Frank , D3nW-Frank-1 ) ;
17524: LD_EXP 52
17528: PPUSH
17529: LD_STRING D3nW-Frank-1
17531: PPUSH
17532: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17536: LD_EXP 59
17540: PPUSH
17541: LD_INT 22
17543: PUSH
17544: LD_INT 1
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PPUSH
17551: CALL_OW 72
17555: IFFALSE 17581
// begin Say ( JMM , D3nW-JMM-1 ) ;
17557: LD_EXP 39
17561: PPUSH
17562: LD_STRING D3nW-JMM-1
17564: PPUSH
17565: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17569: LD_EXP 39
17573: PPUSH
17574: LD_STRING D3nW-JMM-1a
17576: PPUSH
17577: CALL_OW 88
// end ; t := 0 0$00 ;
17581: LD_ADDR_VAR 0 3
17585: PUSH
17586: LD_INT 0
17588: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17589: LD_INT 35
17591: PPUSH
17592: CALL_OW 67
// t := t + 0 0$1 ;
17596: LD_ADDR_VAR 0 3
17600: PUSH
17601: LD_VAR 0 3
17605: PUSH
17606: LD_INT 35
17608: PLUS
17609: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17610: LD_INT 59
17612: PPUSH
17613: LD_INT 112
17615: PPUSH
17616: CALL_OW 428
17620: PUSH
17621: LD_VAR 0 3
17625: PUSH
17626: LD_INT 2100
17628: GREATER
17629: OR
17630: IFFALSE 17589
// activeAttacks := true ;
17632: LD_ADDR_EXP 16
17636: PUSH
17637: LD_INT 1
17639: ST_TO_ADDR
// end ;
17640: LD_VAR 0 1
17644: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17645: LD_INT 0
17647: PPUSH
// case question of 1 :
17648: LD_VAR 0 1
17652: PUSH
17653: LD_INT 1
17655: DOUBLE
17656: EQUAL
17657: IFTRUE 17661
17659: GO 17712
17661: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17662: LD_EXP 39
17666: PPUSH
17667: LD_STRING D2Mot-JMM-1
17669: PPUSH
17670: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17674: LD_EXP 58
17678: PPUSH
17679: LD_STRING D2Mot-Pow-1
17681: PPUSH
17682: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17686: LD_EXP 39
17690: PPUSH
17691: LD_STRING D2Mot-JMM-2
17693: PPUSH
17694: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17698: LD_EXP 58
17702: PPUSH
17703: LD_STRING D2Mot-Pow-2
17705: PPUSH
17706: CALL_OW 88
// end ; 2 :
17710: GO 18063
17712: LD_INT 2
17714: DOUBLE
17715: EQUAL
17716: IFTRUE 17720
17718: GO 17796
17720: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17721: LD_EXP 39
17725: PPUSH
17726: LD_STRING D2Rus-JMM-1
17728: PPUSH
17729: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17733: LD_EXP 58
17737: PPUSH
17738: LD_STRING D2Rus-Pow-1
17740: PPUSH
17741: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17745: LD_EXP 39
17749: PPUSH
17750: LD_STRING D2Rus-JMM-2
17752: PPUSH
17753: CALL_OW 88
// if not ( 3 in list_of_q ) then
17757: LD_INT 3
17759: PUSH
17760: LD_VAR 0 2
17764: IN
17765: NOT
17766: IFFALSE 17782
// Say ( Powell , D2Rus-Pow-2 ) else
17768: LD_EXP 58
17772: PPUSH
17773: LD_STRING D2Rus-Pow-2
17775: PPUSH
17776: CALL_OW 88
17780: GO 17794
// Say ( Powell , D2Rus-Pow-2a ) ;
17782: LD_EXP 58
17786: PPUSH
17787: LD_STRING D2Rus-Pow-2a
17789: PPUSH
17790: CALL_OW 88
// end ; 3 :
17794: GO 18063
17796: LD_INT 3
17798: DOUBLE
17799: EQUAL
17800: IFTRUE 17804
17802: GO 17889
17804: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17805: LD_EXP 39
17809: PPUSH
17810: LD_STRING D2Leg-JMM-1
17812: PPUSH
17813: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17817: LD_EXP 58
17821: PPUSH
17822: LD_STRING D2Leg-Pow-1
17824: PPUSH
17825: CALL_OW 88
// if 2 in list_of_q then
17829: LD_INT 2
17831: PUSH
17832: LD_VAR 0 2
17836: IN
17837: IFFALSE 17863
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17839: LD_EXP 39
17843: PPUSH
17844: LD_STRING D2Leg-JMM-2
17846: PPUSH
17847: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17851: LD_EXP 58
17855: PPUSH
17856: LD_STRING D2Leg-Pow-2
17858: PPUSH
17859: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17863: LD_EXP 39
17867: PPUSH
17868: LD_STRING D2Leg-JMM-3
17870: PPUSH
17871: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17875: LD_EXP 58
17879: PPUSH
17880: LD_STRING D2Leg-Pow-3
17882: PPUSH
17883: CALL_OW 88
// end ; 4 :
17887: GO 18063
17889: LD_INT 4
17891: DOUBLE
17892: EQUAL
17893: IFTRUE 17897
17895: GO 17972
17897: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17898: LD_EXP 39
17902: PPUSH
17903: LD_STRING D2Ar-JMM-1
17905: PPUSH
17906: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17910: LD_EXP 58
17914: PPUSH
17915: LD_STRING D2Ar-Pow-1
17917: PPUSH
17918: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17922: LD_EXP 39
17926: PPUSH
17927: LD_STRING D2Ar-JMM-2
17929: PPUSH
17930: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17934: LD_EXP 58
17938: PPUSH
17939: LD_STRING D2Ar-Pow-2
17941: PPUSH
17942: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17946: LD_EXP 39
17950: PPUSH
17951: LD_STRING D2Ar-JMM-3
17953: PPUSH
17954: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17958: LD_EXP 58
17962: PPUSH
17963: LD_STRING D2Ar-Pow-3
17965: PPUSH
17966: CALL_OW 88
// end ; 5 :
17970: GO 18063
17972: LD_INT 5
17974: DOUBLE
17975: EQUAL
17976: IFTRUE 17980
17978: GO 17995
17980: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17981: LD_EXP 39
17985: PPUSH
17986: LD_STRING D2Conf-JMM-1
17988: PPUSH
17989: CALL_OW 88
17993: GO 18063
17995: LD_INT 6
17997: DOUBLE
17998: EQUAL
17999: IFTRUE 18003
18001: GO 18062
18003: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18004: LD_EXP 39
18008: PPUSH
18009: LD_STRING D2Com-JMM-1
18011: PPUSH
18012: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18016: LD_EXP 58
18020: PPUSH
18021: LD_STRING D2Com-Pow-1
18023: PPUSH
18024: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18028: LD_EXP 39
18032: PPUSH
18033: LD_STRING D2Com-JMM-2
18035: PPUSH
18036: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18040: LD_EXP 58
18044: PPUSH
18045: LD_STRING D2Com-Pow-2
18047: PPUSH
18048: CALL_OW 88
// powellAngerQuery := true ;
18052: LD_ADDR_EXP 36
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// end ; end ;
18060: GO 18063
18062: POP
// end ;
18063: LD_VAR 0 3
18067: RET
// every 0 0$5 trigger missionStart do var tmp ;
18068: LD_EXP 13
18072: IFFALSE 18355
18074: GO 18076
18076: DISABLE
18077: LD_INT 0
18079: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18080: LD_INT 35
18082: PPUSH
18083: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18087: LD_INT 14
18089: PPUSH
18090: LD_INT 22
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PPUSH
18100: CALL_OW 70
18104: PUSH
18105: LD_EXP 15
18109: PUSH
18110: LD_INT 2
18112: PUSH
18113: LD_INT 3
18115: PUSH
18116: LD_INT 4
18118: PUSH
18119: LD_INT 5
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: IN
18128: AND
18129: IFFALSE 18345
// begin powellAnger := powellAnger + 1 ;
18131: LD_ADDR_EXP 17
18135: PUSH
18136: LD_EXP 17
18140: PUSH
18141: LD_INT 1
18143: PLUS
18144: ST_TO_ADDR
// Video ( true ) ;
18145: LD_INT 1
18147: PPUSH
18148: CALL 107581 0 1
// CenterNowOnUnits ( tmp ) ;
18152: LD_VAR 0 1
18156: PPUSH
18157: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18161: LD_INT 14
18163: PPUSH
18164: LD_INT 22
18166: PUSH
18167: LD_INT 1
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: PPUSH
18174: CALL_OW 70
18178: PPUSH
18179: LD_INT 86
18181: PPUSH
18182: LD_INT 133
18184: PPUSH
18185: CALL_OW 111
// async ;
18189: ASYNC
// case powellAnger of 1 :
18190: LD_EXP 17
18194: PUSH
18195: LD_INT 1
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18218
18203: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18204: LD_EXP 58
18208: PPUSH
18209: LD_STRING DBack1-Pow-1
18211: PPUSH
18212: CALL_OW 88
18216: GO 18265
18218: LD_INT 2
18220: DOUBLE
18221: EQUAL
18222: IFTRUE 18226
18224: GO 18241
18226: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18227: LD_EXP 58
18231: PPUSH
18232: LD_STRING DBack2-Pow-1
18234: PPUSH
18235: CALL_OW 88
18239: GO 18265
18241: LD_INT 3
18243: DOUBLE
18244: EQUAL
18245: IFTRUE 18249
18247: GO 18264
18249: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18250: LD_EXP 58
18254: PPUSH
18255: LD_STRING DBack3-Pow-1
18257: PPUSH
18258: CALL_OW 88
18262: GO 18265
18264: POP
// sync ;
18265: SYNC
// repeat wait ( 0 0$1 ) ;
18266: LD_INT 35
18268: PPUSH
18269: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18273: LD_INT 14
18275: PPUSH
18276: LD_INT 22
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: PPUSH
18286: CALL_OW 70
18290: PPUSH
18291: LD_INT 86
18293: PPUSH
18294: LD_INT 133
18296: PPUSH
18297: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18301: LD_INT 14
18303: PPUSH
18304: LD_INT 22
18306: PUSH
18307: LD_INT 1
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: PPUSH
18314: CALL_OW 70
18318: NOT
18319: IFFALSE 18266
// if powellAnger >= 3 then
18321: LD_EXP 17
18325: PUSH
18326: LD_INT 3
18328: GREATEREQUAL
18329: IFFALSE 18338
// YouLost ( Dismissed ) ;
18331: LD_STRING Dismissed
18333: PPUSH
18334: CALL_OW 104
// Video ( false ) ;
18338: LD_INT 0
18340: PPUSH
18341: CALL 107581 0 1
// end ; until missionStage > 5 ;
18345: LD_EXP 15
18349: PUSH
18350: LD_INT 5
18352: GREATER
18353: IFFALSE 18080
// end ;
18355: PPOPN 1
18357: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18358: LD_EXP 13
18362: PUSH
18363: LD_INT 22
18365: PUSH
18366: LD_INT 4
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 21
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PPUSH
18387: CALL_OW 69
18391: PUSH
18392: LD_INT 4
18394: GREATEREQUAL
18395: AND
18396: PUSH
18397: LD_EXP 15
18401: PUSH
18402: LD_INT 2
18404: EQUAL
18405: AND
18406: IFFALSE 20229
18408: GO 18410
18410: DISABLE
18411: LD_INT 0
18413: PPUSH
18414: PPUSH
18415: PPUSH
18416: PPUSH
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
// begin missionStage := 3 ;
18421: LD_ADDR_EXP 15
18425: PUSH
18426: LD_INT 3
18428: ST_TO_ADDR
// retreat := false ;
18429: LD_ADDR_VAR 0 4
18433: PUSH
18434: LD_INT 0
18436: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18437: LD_ADDR_VAR 0 5
18441: PUSH
18442: LD_INT 22
18444: PUSH
18445: LD_INT 4
18447: PUSH
18448: EMPTY
18449: LIST
18450: LIST
18451: PUSH
18452: LD_INT 30
18454: PUSH
18455: LD_INT 4
18457: PUSH
18458: EMPTY
18459: LIST
18460: LIST
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PPUSH
18466: CALL_OW 69
18470: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18471: LD_ADDR_VAR 0 6
18475: PUSH
18476: LD_INT 22
18478: PUSH
18479: LD_INT 4
18481: PUSH
18482: EMPTY
18483: LIST
18484: LIST
18485: PUSH
18486: LD_INT 30
18488: PUSH
18489: LD_INT 5
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: PPUSH
18500: CALL_OW 69
18504: ST_TO_ADDR
// if not bar then
18505: LD_VAR 0 6
18509: NOT
18510: IFFALSE 18563
// begin repeat wait ( 0 0$1 ) ;
18512: LD_INT 35
18514: PPUSH
18515: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18519: LD_INT 22
18521: PUSH
18522: LD_INT 4
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: PUSH
18529: LD_INT 3
18531: PUSH
18532: LD_INT 57
18534: PUSH
18535: EMPTY
18536: LIST
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: PUSH
18542: LD_INT 30
18544: PUSH
18545: LD_INT 5
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: LIST
18556: PPUSH
18557: CALL_OW 69
18561: IFFALSE 18512
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18563: LD_ADDR_VAR 0 6
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 5
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18597: LD_INT 35
18599: PPUSH
18600: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18604: LD_EXP 121
18608: PUSH
18609: LD_INT 4
18611: ARRAY
18612: PUSH
18613: LD_INT 4
18615: GREATEREQUAL
18616: IFFALSE 18597
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18618: LD_ADDR_VAR 0 2
18622: PUSH
18623: LD_INT 22
18625: PUSH
18626: LD_INT 4
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 2
18635: PUSH
18636: LD_INT 25
18638: PUSH
18639: LD_INT 1
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 25
18648: PUSH
18649: LD_INT 2
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PUSH
18656: LD_INT 25
18658: PUSH
18659: LD_INT 3
18661: PUSH
18662: EMPTY
18663: LIST
18664: LIST
18665: PUSH
18666: LD_INT 25
18668: PUSH
18669: LD_INT 4
18671: PUSH
18672: EMPTY
18673: LIST
18674: LIST
18675: PUSH
18676: LD_INT 25
18678: PUSH
18679: LD_INT 5
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: PPUSH
18698: CALL_OW 69
18702: PUSH
18703: LD_EXP 58
18707: PUSH
18708: LD_EXP 59
18712: ADD
18713: DIFF
18714: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18715: LD_ADDR_VAR 0 3
18719: PUSH
18720: LD_VAR 0 2
18724: PPUSH
18725: LD_INT 26
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL_OW 72
18739: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18740: LD_ADDR_VAR 0 2
18744: PUSH
18745: LD_VAR 0 2
18749: PUSH
18750: LD_VAR 0 3
18754: DIFF
18755: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18756: LD_ADDR_VAR 0 2
18760: PUSH
18761: LD_VAR 0 2
18765: PPUSH
18766: LD_INT 1
18768: PPUSH
18769: CALL 106234 0 2
18773: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18774: LD_ADDR_VAR 0 3
18778: PUSH
18779: LD_VAR 0 3
18783: PPUSH
18784: LD_INT 1
18786: PPUSH
18787: CALL 106234 0 2
18791: ST_TO_ADDR
// for i = 1 to 4 do
18792: LD_ADDR_VAR 0 1
18796: PUSH
18797: DOUBLE
18798: LD_INT 1
18800: DEC
18801: ST_TO_ADDR
18802: LD_INT 4
18804: PUSH
18805: FOR_TO
18806: IFFALSE 18972
// begin if tmp2 then
18808: LD_VAR 0 3
18812: IFFALSE 18893
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18814: LD_ADDR_EXP 18
18818: PUSH
18819: LD_EXP 18
18823: PPUSH
18824: LD_INT 1
18826: PPUSH
18827: LD_EXP 18
18831: PUSH
18832: LD_INT 1
18834: ARRAY
18835: PUSH
18836: LD_VAR 0 3
18840: PUSH
18841: LD_VAR 0 3
18845: ARRAY
18846: ADD
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18853: LD_VAR 0 3
18857: PUSH
18858: LD_VAR 0 3
18862: ARRAY
18863: PPUSH
18864: LD_INT 1
18866: PPUSH
18867: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18871: LD_ADDR_VAR 0 3
18875: PUSH
18876: LD_VAR 0 3
18880: PPUSH
18881: LD_VAR 0 3
18885: PPUSH
18886: CALL_OW 3
18890: ST_TO_ADDR
// end else
18891: GO 18970
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18893: LD_ADDR_EXP 18
18897: PUSH
18898: LD_EXP 18
18902: PPUSH
18903: LD_INT 1
18905: PPUSH
18906: LD_EXP 18
18910: PUSH
18911: LD_INT 1
18913: ARRAY
18914: PUSH
18915: LD_VAR 0 2
18919: PUSH
18920: LD_VAR 0 2
18924: ARRAY
18925: ADD
18926: PPUSH
18927: CALL_OW 1
18931: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18932: LD_VAR 0 2
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: PPUSH
18943: LD_INT 1
18945: PPUSH
18946: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18950: LD_ADDR_VAR 0 2
18954: PUSH
18955: LD_VAR 0 2
18959: PPUSH
18960: LD_VAR 0 2
18964: PPUSH
18965: CALL_OW 3
18969: ST_TO_ADDR
// end ; end ;
18970: GO 18805
18972: POP
18973: POP
// if tmp2 then
18974: LD_VAR 0 3
18978: IFFALSE 18996
// tmp := tmp union tmp2 ;
18980: LD_ADDR_VAR 0 2
18984: PUSH
18985: LD_VAR 0 2
18989: PUSH
18990: LD_VAR 0 3
18994: UNION
18995: ST_TO_ADDR
// for i = 1 to 4 do
18996: LD_ADDR_VAR 0 1
19000: PUSH
19001: DOUBLE
19002: LD_INT 1
19004: DEC
19005: ST_TO_ADDR
19006: LD_INT 4
19008: PUSH
19009: FOR_TO
19010: IFFALSE 19059
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19012: LD_ADDR_EXP 18
19016: PUSH
19017: LD_EXP 18
19021: PPUSH
19022: LD_INT 2
19024: PPUSH
19025: LD_EXP 18
19029: PUSH
19030: LD_INT 2
19032: ARRAY
19033: PUSH
19034: LD_VAR 0 2
19038: PUSH
19039: LD_VAR 0 2
19043: PUSH
19044: LD_VAR 0 1
19048: MINUS
19049: ARRAY
19050: ADD
19051: PPUSH
19052: CALL_OW 1
19056: ST_TO_ADDR
19057: GO 19009
19059: POP
19060: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19061: LD_ADDR_EXP 102
19065: PUSH
19066: LD_EXP 102
19070: PPUSH
19071: LD_INT 4
19073: PPUSH
19074: LD_EXP 102
19078: PUSH
19079: LD_INT 4
19081: ARRAY
19082: PUSH
19083: LD_EXP 18
19087: PUSH
19088: LD_INT 1
19090: ARRAY
19091: DIFF
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19098: LD_VAR 0 5
19102: PUSH
19103: LD_INT 1
19105: ARRAY
19106: PPUSH
19107: CALL_OW 313
19111: IFFALSE 19166
// begin for i in UnitsInside ( arm [ 1 ] ) do
19113: LD_ADDR_VAR 0 1
19117: PUSH
19118: LD_VAR 0 5
19122: PUSH
19123: LD_INT 1
19125: ARRAY
19126: PPUSH
19127: CALL_OW 313
19131: PUSH
19132: FOR_IN
19133: IFFALSE 19164
// begin ComExitBuilding ( i ) ;
19135: LD_VAR 0 1
19139: PPUSH
19140: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_VAR 0 6
19153: PUSH
19154: LD_INT 1
19156: ARRAY
19157: PPUSH
19158: CALL_OW 180
// end ;
19162: GO 19132
19164: POP
19165: POP
// end ; wait ( 0 0$3 ) ;
19166: LD_INT 105
19168: PPUSH
19169: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19173: LD_ADDR_VAR 0 1
19177: PUSH
19178: LD_EXP 18
19182: PUSH
19183: LD_INT 1
19185: ARRAY
19186: PUSH
19187: FOR_IN
19188: IFFALSE 19295
// begin if IsInUnit ( i ) then
19190: LD_VAR 0 1
19194: PPUSH
19195: CALL_OW 310
19199: IFFALSE 19210
// ComExitBuilding ( i ) ;
19201: LD_VAR 0 1
19205: PPUSH
19206: CALL_OW 122
// if GetClass ( i ) <> 1 then
19210: LD_VAR 0 1
19214: PPUSH
19215: CALL_OW 257
19219: PUSH
19220: LD_INT 1
19222: NONEQUAL
19223: IFFALSE 19264
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19225: LD_VAR 0 1
19229: PPUSH
19230: LD_VAR 0 5
19234: PUSH
19235: LD_INT 1
19237: ARRAY
19238: PPUSH
19239: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19243: LD_VAR 0 1
19247: PPUSH
19248: LD_INT 1
19250: PPUSH
19251: CALL_OW 183
// AddComExitBuilding ( i ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19264: LD_VAR 0 1
19268: PPUSH
19269: LD_INT 60
19271: PPUSH
19272: LD_INT 94
19274: PPUSH
19275: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19279: LD_VAR 0 1
19283: PPUSH
19284: LD_EXP 58
19288: PPUSH
19289: CALL_OW 179
// end ;
19293: GO 19187
19295: POP
19296: POP
// wait ( 0 0$15 ) ;
19297: LD_INT 525
19299: PPUSH
19300: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19304: LD_EXP 58
19308: PPUSH
19309: LD_STRING D4-Pow-1
19311: PPUSH
19312: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19316: LD_ADDR_VAR 0 2
19320: PUSH
19321: LD_EXP 18
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: PPUSH
19330: LD_INT 26
19332: PUSH
19333: LD_INT 1
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 72
19344: ST_TO_ADDR
// if tmp then
19345: LD_VAR 0 2
19349: IFFALSE 19367
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19351: LD_VAR 0 2
19355: PUSH
19356: LD_INT 1
19358: ARRAY
19359: PPUSH
19360: LD_STRING D4-Sol1-1
19362: PPUSH
19363: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19367: LD_EXP 58
19371: PPUSH
19372: LD_STRING D4-Pow-2
19374: PPUSH
19375: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19379: LD_ADDR_VAR 0 1
19383: PUSH
19384: DOUBLE
19385: LD_INT 1
19387: DEC
19388: ST_TO_ADDR
19389: LD_EXP 18
19393: PUSH
19394: LD_INT 1
19396: ARRAY
19397: PUSH
19398: FOR_TO
19399: IFFALSE 19492
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19401: LD_EXP 18
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PUSH
19410: LD_VAR 0 1
19414: ARRAY
19415: PPUSH
19416: LD_EXP 121
19420: PUSH
19421: LD_INT 4
19423: ARRAY
19424: PUSH
19425: LD_INT 1
19427: ARRAY
19428: PPUSH
19429: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19433: LD_ADDR_EXP 121
19437: PUSH
19438: LD_EXP 121
19442: PPUSH
19443: LD_INT 4
19445: PPUSH
19446: LD_EXP 121
19450: PUSH
19451: LD_INT 4
19453: ARRAY
19454: PPUSH
19455: LD_INT 1
19457: PPUSH
19458: CALL_OW 3
19462: PPUSH
19463: CALL_OW 1
19467: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19468: LD_INT 8
19470: PPUSH
19471: LD_EXP 18
19475: PUSH
19476: LD_INT 1
19478: ARRAY
19479: PUSH
19480: LD_VAR 0 1
19484: ARRAY
19485: PPUSH
19486: CALL_OW 471
// end ;
19490: GO 19398
19492: POP
19493: POP
// repeat wait ( 0 0$1 ) ;
19494: LD_INT 35
19496: PPUSH
19497: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19501: LD_EXP 18
19505: PUSH
19506: LD_INT 1
19508: ARRAY
19509: PPUSH
19510: LD_INT 55
19512: PUSH
19513: EMPTY
19514: LIST
19515: PPUSH
19516: CALL_OW 72
19520: PUSH
19521: LD_INT 4
19523: GREATEREQUAL
19524: IFFALSE 19494
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19526: LD_EXP 18
19530: PUSH
19531: LD_INT 1
19533: ARRAY
19534: PPUSH
19535: LD_INT 69
19537: PPUSH
19538: LD_INT 94
19540: PPUSH
19541: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19545: LD_EXP 18
19549: PUSH
19550: LD_INT 1
19552: ARRAY
19553: PPUSH
19554: LD_INT 82
19556: PPUSH
19557: LD_INT 83
19559: PPUSH
19560: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19564: LD_EXP 18
19568: PUSH
19569: LD_INT 1
19571: ARRAY
19572: PPUSH
19573: LD_INT 77
19575: PPUSH
19576: LD_INT 69
19578: PPUSH
19579: CALL_OW 174
// repeat wait ( 3 ) ;
19583: LD_INT 3
19585: PPUSH
19586: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19590: LD_ADDR_VAR 0 1
19594: PUSH
19595: LD_EXP 18
19599: PUSH
19600: LD_INT 1
19602: ARRAY
19603: PUSH
19604: FOR_IN
19605: IFFALSE 19741
// begin if GetLives ( i ) < 990 then
19607: LD_VAR 0 1
19611: PPUSH
19612: CALL_OW 256
19616: PUSH
19617: LD_INT 990
19619: LESS
19620: IFFALSE 19634
// SetLives ( i , 1000 ) ;
19622: LD_VAR 0 1
19626: PPUSH
19627: LD_INT 1000
19629: PPUSH
19630: CALL_OW 234
// if not IsInUnit ( i ) then
19634: LD_VAR 0 1
19638: PPUSH
19639: CALL_OW 310
19643: NOT
19644: IFFALSE 19739
// begin if not HasTask ( i ) then
19646: LD_VAR 0 1
19650: PPUSH
19651: CALL_OW 314
19655: NOT
19656: IFFALSE 19673
// ComMoveXY ( i , 64 , 93 ) ;
19658: LD_VAR 0 1
19662: PPUSH
19663: LD_INT 64
19665: PPUSH
19666: LD_INT 93
19668: PPUSH
19669: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19673: LD_VAR 0 4
19677: NOT
19678: PUSH
19679: LD_VAR 0 1
19683: PPUSH
19684: CALL_OW 258
19688: PUSH
19689: LD_INT 1
19691: EQUAL
19692: AND
19693: IFFALSE 19739
// begin retreat := true ;
19695: LD_ADDR_VAR 0 4
19699: PUSH
19700: LD_INT 1
19702: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19703: LD_VAR 0 1
19707: PPUSH
19708: LD_INT 2
19710: PPUSH
19711: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19715: LD_VAR 0 1
19719: PPUSH
19720: LD_STRING D4a-Sol1-1
19722: PPUSH
19723: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19727: LD_EXP 58
19731: PPUSH
19732: LD_STRING D4a-Pow-1
19734: PPUSH
19735: CALL_OW 88
// end ; end ; end ;
19739: GO 19604
19741: POP
19742: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19743: LD_EXP 18
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: LD_INT 95
19754: PUSH
19755: LD_INT 9
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: LD_INT 3
19764: PUSH
19765: LD_INT 55
19767: PUSH
19768: EMPTY
19769: LIST
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PPUSH
19779: CALL_OW 72
19783: PUSH
19784: LD_INT 4
19786: GREATEREQUAL
19787: IFFALSE 19583
// for i in powellSquadAttack [ 1 ] do
19789: LD_ADDR_VAR 0 1
19793: PUSH
19794: LD_EXP 18
19798: PUSH
19799: LD_INT 1
19801: ARRAY
19802: PUSH
19803: FOR_IN
19804: IFFALSE 19940
// begin if GetTag ( i ) = 2 then
19806: LD_VAR 0 1
19810: PPUSH
19811: CALL_OW 110
19815: PUSH
19816: LD_INT 2
19818: EQUAL
19819: IFFALSE 19881
// begin ComMoveXY ( i , 60 , 94 ) ;
19821: LD_VAR 0 1
19825: PPUSH
19826: LD_INT 60
19828: PPUSH
19829: LD_INT 94
19831: PPUSH
19832: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19836: LD_VAR 0 1
19840: PPUSH
19841: LD_EXP 58
19845: PPUSH
19846: CALL_OW 179
// wait ( 0 0$3 ) ;
19850: LD_INT 105
19852: PPUSH
19853: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19857: LD_VAR 0 1
19861: PPUSH
19862: LD_STRING D4a-Sol1-2
19864: PPUSH
19865: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19869: LD_EXP 58
19873: PPUSH
19874: LD_STRING D4a-Pow-2
19876: PPUSH
19877: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19881: LD_VAR 0 1
19885: PPUSH
19886: LD_INT 0
19888: PPUSH
19889: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19893: LD_ADDR_EXP 102
19897: PUSH
19898: LD_EXP 102
19902: PPUSH
19903: LD_INT 4
19905: PPUSH
19906: LD_EXP 102
19910: PUSH
19911: LD_INT 4
19913: ARRAY
19914: PUSH
19915: LD_VAR 0 1
19919: UNION
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19926: LD_INT 8
19928: PPUSH
19929: LD_VAR 0 1
19933: PPUSH
19934: CALL_OW 472
// end ;
19938: GO 19803
19940: POP
19941: POP
// wait ( 4 4$00 ) ;
19942: LD_INT 8400
19944: PPUSH
19945: CALL_OW 67
// uc_side := 6 ;
19949: LD_ADDR_OWVAR 20
19953: PUSH
19954: LD_INT 6
19956: ST_TO_ADDR
// uc_nation := 3 ;
19957: LD_ADDR_OWVAR 21
19961: PUSH
19962: LD_INT 3
19964: ST_TO_ADDR
// ru := [ ] ;
19965: LD_ADDR_VAR 0 7
19969: PUSH
19970: EMPTY
19971: ST_TO_ADDR
// for i = 1 to 4 do
19972: LD_ADDR_VAR 0 1
19976: PUSH
19977: DOUBLE
19978: LD_INT 1
19980: DEC
19981: ST_TO_ADDR
19982: LD_INT 4
19984: PUSH
19985: FOR_TO
19986: IFFALSE 20087
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19988: LD_INT 22
19990: PPUSH
19991: LD_INT 1
19993: PPUSH
19994: LD_INT 3
19996: PPUSH
19997: LD_INT 43
19999: PUSH
20000: LD_INT 44
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PUSH
20007: LD_INT 1
20009: PPUSH
20010: LD_INT 2
20012: PPUSH
20013: CALL_OW 12
20017: ARRAY
20018: PPUSH
20019: LD_INT 89
20021: PPUSH
20022: CALL 71861 0 5
// un := CreateVehicle ;
20026: LD_ADDR_VAR 0 8
20030: PUSH
20031: CALL_OW 45
20035: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20036: LD_VAR 0 8
20040: PPUSH
20041: LD_INT 4
20043: PPUSH
20044: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20048: LD_VAR 0 8
20052: PPUSH
20053: LD_INT 136
20055: PPUSH
20056: LD_INT 90
20058: PPUSH
20059: LD_INT 8
20061: PPUSH
20062: LD_INT 0
20064: PPUSH
20065: CALL_OW 50
// ru := ru ^ un ;
20069: LD_ADDR_VAR 0 7
20073: PUSH
20074: LD_VAR 0 7
20078: PUSH
20079: LD_VAR 0 8
20083: ADD
20084: ST_TO_ADDR
// end ;
20085: GO 19985
20087: POP
20088: POP
// if ru then
20089: LD_VAR 0 7
20093: IFFALSE 20110
// ComAgressiveMove ( ru , 80 , 92 ) ;
20095: LD_VAR 0 7
20099: PPUSH
20100: LD_INT 80
20102: PPUSH
20103: LD_INT 92
20105: PPUSH
20106: CALL_OW 114
// wait ( 8 8$00 ) ;
20110: LD_INT 16800
20112: PPUSH
20113: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20117: LD_INT 4
20119: PPUSH
20120: LD_INT 3
20122: PUSH
20123: LD_INT 1
20125: PUSH
20126: LD_INT 1
20128: PUSH
20129: LD_INT 5
20131: PUSH
20132: EMPTY
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 4
20140: PUSH
20141: LD_INT 1
20143: PUSH
20144: LD_INT 1
20146: PUSH
20147: LD_INT 6
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: PUSH
20156: LD_INT 4
20158: PUSH
20159: LD_INT 1
20161: PUSH
20162: LD_INT 1
20164: PUSH
20165: LD_INT 7
20167: PUSH
20168: EMPTY
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: LD_INT 3
20176: PUSH
20177: LD_INT 1
20179: PUSH
20180: LD_INT 1
20182: PUSH
20183: LD_INT 7
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: PUSH
20192: LD_INT 3
20194: PUSH
20195: LD_INT 1
20197: PUSH
20198: LD_INT 1
20200: PUSH
20201: LD_INT 5
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: PUSH
20210: EMPTY
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: PPUSH
20217: CALL 58354 0 2
// missionStage := 4 ;
20221: LD_ADDR_EXP 15
20225: PUSH
20226: LD_INT 4
20228: ST_TO_ADDR
// end ;
20229: PPOPN 8
20231: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20232: LD_EXP 15
20236: PUSH
20237: LD_INT 4
20239: EQUAL
20240: PUSH
20241: LD_INT 22
20243: PUSH
20244: LD_INT 4
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 21
20253: PUSH
20254: LD_INT 2
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PPUSH
20265: CALL_OW 69
20269: PUSH
20270: LD_INT 5
20272: GREATEREQUAL
20273: AND
20274: IFFALSE 24379
20276: GO 20278
20278: DISABLE
20279: LD_INT 0
20281: PPUSH
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
// begin missionStage := 5 ;
20294: LD_ADDR_EXP 15
20298: PUSH
20299: LD_INT 5
20301: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20302: LD_ADDR_VAR 0 10
20306: PUSH
20307: LD_INT 22
20309: PUSH
20310: LD_INT 4
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 2
20319: PUSH
20320: LD_INT 30
20322: PUSH
20323: LD_INT 4
20325: PUSH
20326: EMPTY
20327: LIST
20328: LIST
20329: PUSH
20330: LD_INT 30
20332: PUSH
20333: LD_INT 5
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: LIST
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PPUSH
20349: CALL_OW 69
20353: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20354: LD_ADDR_VAR 0 6
20358: PUSH
20359: LD_INT 22
20361: PUSH
20362: LD_INT 4
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 21
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 3
20381: PUSH
20382: LD_INT 25
20384: PUSH
20385: LD_INT 16
20387: PUSH
20388: EMPTY
20389: LIST
20390: LIST
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 25
20401: PUSH
20402: LD_INT 12
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: PPUSH
20419: CALL_OW 69
20423: PUSH
20424: LD_EXP 58
20428: DIFF
20429: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20430: LD_ADDR_VAR 0 9
20434: PUSH
20435: LD_INT 22
20437: PUSH
20438: LD_INT 4
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 30
20447: PUSH
20448: LD_INT 3
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PPUSH
20459: CALL_OW 69
20463: PUSH
20464: LD_INT 1
20466: ARRAY
20467: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20468: LD_INT 35
20470: PPUSH
20471: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20475: LD_EXP 121
20479: PUSH
20480: LD_INT 4
20482: ARRAY
20483: PUSH
20484: LD_INT 5
20486: GREATEREQUAL
20487: PUSH
20488: LD_EXP 121
20492: PUSH
20493: LD_INT 4
20495: ARRAY
20496: PPUSH
20497: LD_INT 58
20499: PUSH
20500: EMPTY
20501: LIST
20502: PPUSH
20503: CALL_OW 72
20507: PUSH
20508: LD_INT 5
20510: GREATEREQUAL
20511: AND
20512: IFFALSE 20468
// powellAllowRetreat := false ;
20514: LD_ADDR_EXP 19
20518: PUSH
20519: LD_INT 0
20521: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20522: LD_INT 700
20524: PPUSH
20525: CALL_OW 67
// activeAttacks := false ;
20529: LD_ADDR_EXP 16
20533: PUSH
20534: LD_INT 0
20536: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20537: LD_INT 35
20539: PPUSH
20540: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20544: LD_INT 22
20546: PUSH
20547: LD_INT 6
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: PPUSH
20554: CALL_OW 69
20558: PUSH
20559: LD_INT 0
20561: EQUAL
20562: IFFALSE 20537
// tmp := mc_vehicles [ 4 ] ;
20564: LD_ADDR_VAR 0 3
20568: PUSH
20569: LD_EXP 121
20573: PUSH
20574: LD_INT 4
20576: ARRAY
20577: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20578: LD_ADDR_VAR 0 1
20582: PUSH
20583: DOUBLE
20584: LD_INT 1
20586: DEC
20587: ST_TO_ADDR
20588: LD_EXP 18
20592: PUSH
20593: FOR_TO
20594: IFFALSE 20855
// begin for j in powellSquadAttack [ i ] do
20596: LD_ADDR_VAR 0 2
20600: PUSH
20601: LD_EXP 18
20605: PUSH
20606: LD_VAR 0 1
20610: ARRAY
20611: PUSH
20612: FOR_IN
20613: IFFALSE 20851
// begin forces := forces diff j ;
20615: LD_ADDR_VAR 0 6
20619: PUSH
20620: LD_VAR 0 6
20624: PUSH
20625: LD_VAR 0 2
20629: DIFF
20630: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20631: LD_VAR 0 2
20635: PPUSH
20636: LD_INT 1
20638: PPUSH
20639: CALL_OW 109
// wait ( 0 0$2 ) ;
20643: LD_INT 70
20645: PPUSH
20646: CALL_OW 67
// if IsInUnit ( j ) then
20650: LD_VAR 0 2
20654: PPUSH
20655: CALL_OW 310
20659: IFFALSE 20670
// ComExitBuilding ( j ) ;
20661: LD_VAR 0 2
20665: PPUSH
20666: CALL_OW 122
// if GetClass ( j ) <> 1 then
20670: LD_VAR 0 2
20674: PPUSH
20675: CALL_OW 257
20679: PUSH
20680: LD_INT 1
20682: NONEQUAL
20683: IFFALSE 20763
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 1
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 5
20701: GREATEREQUAL
20702: IFFALSE 20724
// AddComEnterUnit ( j , arm [ 2 ] ) else
20704: LD_VAR 0 2
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20742
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20724: LD_VAR 0 2
20728: PPUSH
20729: LD_VAR 0 10
20733: PUSH
20734: LD_INT 1
20736: ARRAY
20737: PPUSH
20738: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 183
// AddComExitBuilding ( j ) ;
20754: LD_VAR 0 2
20758: PPUSH
20759: CALL_OW 182
// end ; if i = 2 then
20763: LD_VAR 0 1
20767: PUSH
20768: LD_INT 2
20770: EQUAL
20771: IFFALSE 20788
// AddComMoveXY ( j , 61 , 93 ) ;
20773: LD_VAR 0 2
20777: PPUSH
20778: LD_INT 61
20780: PPUSH
20781: LD_INT 93
20783: PPUSH
20784: CALL_OW 171
// if i = 1 then
20788: LD_VAR 0 1
20792: PUSH
20793: LD_INT 1
20795: EQUAL
20796: IFFALSE 20849
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20798: LD_VAR 0 2
20802: PPUSH
20803: LD_VAR 0 3
20807: PUSH
20808: LD_INT 1
20810: ARRAY
20811: PPUSH
20812: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20816: LD_ADDR_VAR 0 3
20820: PUSH
20821: LD_VAR 0 3
20825: PPUSH
20826: LD_INT 1
20828: PPUSH
20829: CALL_OW 3
20833: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20834: LD_VAR 0 2
20838: PPUSH
20839: LD_INT 69
20841: PPUSH
20842: LD_INT 94
20844: PPUSH
20845: CALL_OW 171
// end ; end ;
20849: GO 20612
20851: POP
20852: POP
// end ;
20853: GO 20593
20855: POP
20856: POP
// wait ( 0 0$55 ) ;
20857: LD_INT 1925
20859: PPUSH
20860: CALL_OW 67
// MC_Kill ( 4 ) ;
20864: LD_INT 4
20866: PPUSH
20867: CALL 34942 0 1
// tmp := UnitsInside ( fac ) ;
20871: LD_ADDR_VAR 0 3
20875: PUSH
20876: LD_VAR 0 9
20880: PPUSH
20881: CALL_OW 313
20885: ST_TO_ADDR
// if tmp then
20886: LD_VAR 0 3
20890: IFFALSE 21011
// for i in tmp do
20892: LD_ADDR_VAR 0 1
20896: PUSH
20897: LD_VAR 0 3
20901: PUSH
20902: FOR_IN
20903: IFFALSE 21009
// begin ComExitBuilding ( i ) ;
20905: LD_VAR 0 1
20909: PPUSH
20910: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20914: LD_VAR 0 10
20918: PUSH
20919: LD_INT 2
20921: ARRAY
20922: PPUSH
20923: CALL_OW 313
20927: PUSH
20928: LD_INT 6
20930: LESS
20931: IFFALSE 20953
// AddComEnterUnit ( i , arm [ 2 ] ) else
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 10
20942: PUSH
20943: LD_INT 2
20945: ARRAY
20946: PPUSH
20947: CALL_OW 180
20951: GO 21007
// if UnitsInside ( arm [ 1 ] ) < 6 then
20953: LD_VAR 0 10
20957: PUSH
20958: LD_INT 1
20960: ARRAY
20961: PPUSH
20962: CALL_OW 313
20966: PUSH
20967: LD_INT 6
20969: LESS
20970: IFFALSE 20992
// AddComEnterUnit ( i , arm [ 1 ] ) else
20972: LD_VAR 0 1
20976: PPUSH
20977: LD_VAR 0 10
20981: PUSH
20982: LD_INT 1
20984: ARRAY
20985: PPUSH
20986: CALL_OW 180
20990: GO 21007
// AddComMoveXY ( i , 37 , 68 ) ;
20992: LD_VAR 0 1
20996: PPUSH
20997: LD_INT 37
20999: PPUSH
21000: LD_INT 68
21002: PPUSH
21003: CALL_OW 171
// end ;
21007: GO 20902
21009: POP
21010: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21011: LD_ADDR_VAR 0 11
21015: PUSH
21016: LD_VAR 0 6
21020: PPUSH
21021: LD_INT 26
21023: PUSH
21024: LD_INT 1
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: PPUSH
21031: CALL_OW 72
21035: PUSH
21036: LD_EXP 59
21040: DIFF
21041: ST_TO_ADDR
// if not speaker then
21042: LD_VAR 0 11
21046: NOT
21047: IFFALSE 21074
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21049: LD_ADDR_VAR 0 11
21053: PUSH
21054: LD_VAR 0 6
21058: PPUSH
21059: LD_INT 26
21061: PUSH
21062: LD_INT 1
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PPUSH
21069: CALL_OW 72
21073: ST_TO_ADDR
// if speaker then
21074: LD_VAR 0 11
21078: IFFALSE 21094
// speaker := speaker [ 1 ] ;
21080: LD_ADDR_VAR 0 11
21084: PUSH
21085: LD_VAR 0 11
21089: PUSH
21090: LD_INT 1
21092: ARRAY
21093: ST_TO_ADDR
// Video ( true ) ;
21094: LD_INT 1
21096: PPUSH
21097: CALL 107581 0 1
// CenterNowOnUnits ( Powell ) ;
21101: LD_EXP 58
21105: PPUSH
21106: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21110: LD_ADDR_VAR 0 3
21114: PUSH
21115: LD_VAR 0 6
21119: PPUSH
21120: LD_INT 3
21122: PUSH
21123: LD_INT 25
21125: PUSH
21126: LD_INT 1
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PPUSH
21137: CALL_OW 72
21141: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21142: LD_ADDR_VAR 0 12
21146: PUSH
21147: LD_INT 22
21149: PUSH
21150: LD_INT 4
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PUSH
21157: LD_INT 30
21159: PUSH
21160: LD_INT 32
21162: PUSH
21163: EMPTY
21164: LIST
21165: LIST
21166: PUSH
21167: LD_INT 58
21169: PUSH
21170: EMPTY
21171: LIST
21172: PUSH
21173: EMPTY
21174: LIST
21175: LIST
21176: LIST
21177: PPUSH
21178: CALL_OW 69
21182: ST_TO_ADDR
// for i = 1 to 6 do
21183: LD_ADDR_VAR 0 1
21187: PUSH
21188: DOUBLE
21189: LD_INT 1
21191: DEC
21192: ST_TO_ADDR
21193: LD_INT 6
21195: PUSH
21196: FOR_TO
21197: IFFALSE 21338
// begin if IsInUnit ( tmp [ i ] ) then
21199: LD_VAR 0 3
21203: PUSH
21204: LD_VAR 0 1
21208: ARRAY
21209: PPUSH
21210: CALL_OW 310
21214: IFFALSE 21231
// ComExitBuilding ( tmp [ i ] ) ;
21216: LD_VAR 0 3
21220: PUSH
21221: LD_VAR 0 1
21225: ARRAY
21226: PPUSH
21227: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21231: LD_VAR 0 3
21235: PUSH
21236: LD_VAR 0 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 10
21246: PUSH
21247: LD_INT 1
21249: ARRAY
21250: PPUSH
21251: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21255: LD_VAR 0 3
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: PPUSH
21266: LD_INT 1
21268: PPUSH
21269: CALL_OW 183
// if emp_towers then
21273: LD_VAR 0 12
21277: IFFALSE 21336
// begin AddComExitBuilding ( tmp [ i ] ) ;
21279: LD_VAR 0 3
21283: PUSH
21284: LD_VAR 0 1
21288: ARRAY
21289: PPUSH
21290: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21294: LD_VAR 0 3
21298: PUSH
21299: LD_VAR 0 1
21303: ARRAY
21304: PPUSH
21305: LD_VAR 0 12
21309: PUSH
21310: LD_INT 1
21312: ARRAY
21313: PPUSH
21314: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21318: LD_ADDR_VAR 0 12
21322: PUSH
21323: LD_VAR 0 12
21327: PPUSH
21328: LD_INT 1
21330: PPUSH
21331: CALL_OW 3
21335: ST_TO_ADDR
// end ; end ;
21336: GO 21196
21338: POP
21339: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21340: LD_ADDR_VAR 0 3
21344: PUSH
21345: LD_EXP 18
21349: PUSH
21350: LD_INT 1
21352: ARRAY
21353: PUSH
21354: LD_EXP 18
21358: PUSH
21359: LD_INT 2
21361: ARRAY
21362: ADD
21363: PPUSH
21364: LD_INT 26
21366: PUSH
21367: LD_INT 1
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: PPUSH
21374: CALL_OW 72
21378: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21379: LD_ADDR_VAR 0 1
21383: PUSH
21384: LD_EXP 18
21388: PUSH
21389: LD_INT 2
21391: ARRAY
21392: PUSH
21393: FOR_IN
21394: IFFALSE 21412
// ComTurnUnit ( i , Powell ) ;
21396: LD_VAR 0 1
21400: PPUSH
21401: LD_EXP 58
21405: PPUSH
21406: CALL_OW 119
21410: GO 21393
21412: POP
21413: POP
// Say ( Powell , D5-Pow-1 ) ;
21414: LD_EXP 58
21418: PPUSH
21419: LD_STRING D5-Pow-1
21421: PPUSH
21422: CALL_OW 88
// if tmp then
21426: LD_VAR 0 3
21430: IFFALSE 21448
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21432: LD_VAR 0 3
21436: PUSH
21437: LD_INT 1
21439: ARRAY
21440: PPUSH
21441: LD_STRING D5-Sol2-1
21443: PPUSH
21444: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21448: LD_EXP 58
21452: PPUSH
21453: LD_STRING D5-Pow-2
21455: PPUSH
21456: CALL_OW 88
// if tmp > 1 then
21460: LD_VAR 0 3
21464: PUSH
21465: LD_INT 1
21467: GREATER
21468: IFFALSE 21486
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21470: LD_VAR 0 3
21474: PUSH
21475: LD_INT 2
21477: ARRAY
21478: PPUSH
21479: LD_STRING D5-Sol2-2
21481: PPUSH
21482: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21486: LD_EXP 58
21490: PPUSH
21491: LD_STRING D5-Pow-3
21493: PPUSH
21494: CALL_OW 88
// wait ( 0 0$1 ) ;
21498: LD_INT 35
21500: PPUSH
21501: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21505: LD_ADDR_VAR 0 3
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 1
21517: ARRAY
21518: PUSH
21519: LD_EXP 18
21523: PUSH
21524: LD_INT 2
21526: ARRAY
21527: UNION
21528: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21529: LD_VAR 0 3
21533: PPUSH
21534: LD_INT 80
21536: PPUSH
21537: LD_INT 67
21539: PPUSH
21540: CALL_OW 114
// wait ( 0 0$2 ) ;
21544: LD_INT 70
21546: PPUSH
21547: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21551: LD_INT 79
21553: PPUSH
21554: LD_INT 72
21556: PPUSH
21557: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21561: LD_INT 35
21563: PPUSH
21564: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21568: LD_VAR 0 3
21572: PPUSH
21573: LD_INT 3
21575: PUSH
21576: LD_INT 24
21578: PUSH
21579: LD_INT 1000
21581: PUSH
21582: EMPTY
21583: LIST
21584: LIST
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PPUSH
21590: CALL_OW 72
21594: IFFALSE 21561
// Say ( Powell , D5a-Pow-1 ) ;
21596: LD_EXP 58
21600: PPUSH
21601: LD_STRING D5a-Pow-1
21603: PPUSH
21604: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21608: LD_EXP 58
21612: PPUSH
21613: LD_STRING D5a-Pow-1a
21615: PPUSH
21616: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21620: LD_INT 10
21622: PPUSH
21623: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21627: LD_EXP 58
21631: PPUSH
21632: LD_STRING D5a-Pow-1b
21634: PPUSH
21635: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21639: LD_EXP 58
21643: PPUSH
21644: LD_STRING D5a-Pow-1c
21646: PPUSH
21647: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21651: LD_EXP 58
21655: PPUSH
21656: LD_STRING D5a-Pow-1d
21658: PPUSH
21659: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21663: LD_INT 35
21665: PPUSH
21666: CALL_OW 67
// if not HasTask ( tmp ) then
21670: LD_VAR 0 3
21674: PPUSH
21675: CALL_OW 314
21679: NOT
21680: IFFALSE 21697
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21682: LD_VAR 0 3
21686: PPUSH
21687: LD_INT 80
21689: PPUSH
21690: LD_INT 67
21692: PPUSH
21693: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21697: LD_VAR 0 3
21701: PPUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PPUSH
21712: CALL_OW 72
21716: NOT
21717: IFFALSE 21663
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21719: LD_ADDR_VAR 0 3
21723: PUSH
21724: LD_INT 22
21726: PUSH
21727: LD_INT 4
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: LD_INT 92
21736: PUSH
21737: LD_INT 60
21739: PUSH
21740: LD_INT 93
21742: PUSH
21743: LD_INT 10
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: PUSH
21752: LD_INT 3
21754: PUSH
21755: LD_INT 54
21757: PUSH
21758: EMPTY
21759: LIST
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: LIST
21769: PPUSH
21770: CALL_OW 69
21774: PUSH
21775: LD_EXP 58
21779: DIFF
21780: ST_TO_ADDR
// if tmp then
21781: LD_VAR 0 3
21785: IFFALSE 21819
// for i in tmp do
21787: LD_ADDR_VAR 0 1
21791: PUSH
21792: LD_VAR 0 3
21796: PUSH
21797: FOR_IN
21798: IFFALSE 21817
// ComMoveXY ( i , 36 , 67 ) ;
21800: LD_VAR 0 1
21804: PPUSH
21805: LD_INT 36
21807: PPUSH
21808: LD_INT 67
21810: PPUSH
21811: CALL_OW 111
21815: GO 21797
21817: POP
21818: POP
// wait ( 0 0$3 ) ;
21819: LD_INT 105
21821: PPUSH
21822: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21826: LD_VAR 0 11
21830: PPUSH
21831: LD_STRING D6-Sol3-1
21833: PPUSH
21834: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21838: LD_EXP 58
21842: PPUSH
21843: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21847: LD_EXP 58
21851: PPUSH
21852: LD_STRING D6-Pow-1
21854: PPUSH
21855: CALL_OW 88
// tmp := [ ] ;
21859: LD_ADDR_VAR 0 3
21863: PUSH
21864: EMPTY
21865: ST_TO_ADDR
// for i = 1 to 2 do
21866: LD_ADDR_VAR 0 1
21870: PUSH
21871: DOUBLE
21872: LD_INT 1
21874: DEC
21875: ST_TO_ADDR
21876: LD_INT 2
21878: PUSH
21879: FOR_TO
21880: IFFALSE 21994
// begin uc_side := 8 ;
21882: LD_ADDR_OWVAR 20
21886: PUSH
21887: LD_INT 8
21889: ST_TO_ADDR
// uc_nation := 2 ;
21890: LD_ADDR_OWVAR 21
21894: PUSH
21895: LD_INT 2
21897: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21898: LD_INT 14
21900: PPUSH
21901: LD_INT 3
21903: PPUSH
21904: LD_INT 2
21906: PPUSH
21907: LD_INT 29
21909: PPUSH
21910: LD_INT 100
21912: PPUSH
21913: CALL 71861 0 5
// veh := CreateVehicle ;
21917: LD_ADDR_VAR 0 13
21921: PUSH
21922: CALL_OW 45
21926: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21927: LD_VAR 0 13
21931: PPUSH
21932: LD_INT 4
21934: PPUSH
21935: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21939: LD_VAR 0 13
21943: PPUSH
21944: LD_INT 99
21946: PPUSH
21947: LD_INT 83
21949: PPUSH
21950: LD_INT 6
21952: PPUSH
21953: LD_INT 0
21955: PPUSH
21956: CALL_OW 50
// wait ( 3 ) ;
21960: LD_INT 3
21962: PPUSH
21963: CALL_OW 67
// Connect ( veh ) ;
21967: LD_VAR 0 13
21971: PPUSH
21972: CALL 74916 0 1
// tmp := tmp ^ veh ;
21976: LD_ADDR_VAR 0 3
21980: PUSH
21981: LD_VAR 0 3
21985: PUSH
21986: LD_VAR 0 13
21990: ADD
21991: ST_TO_ADDR
// end ;
21992: GO 21879
21994: POP
21995: POP
// wait ( 0 0$1 ) ;
21996: LD_INT 35
21998: PPUSH
21999: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22003: LD_INT 99
22005: PPUSH
22006: LD_INT 83
22008: PPUSH
22009: LD_INT 1
22011: PPUSH
22012: LD_INT 10
22014: PPUSH
22015: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22019: LD_INT 99
22021: PPUSH
22022: LD_INT 83
22024: PPUSH
22025: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22029: LD_VAR 0 11
22033: PPUSH
22034: LD_STRING D6-Sol3-2
22036: PPUSH
22037: CALL_OW 88
// async ;
22041: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22042: LD_EXP 58
22046: PPUSH
22047: LD_STRING D6-Pow-2
22049: PPUSH
22050: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22054: LD_VAR 0 3
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PPUSH
22063: LD_VAR 0 9
22067: PPUSH
22068: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22072: LD_VAR 0 3
22076: PUSH
22077: LD_INT 2
22079: ARRAY
22080: PPUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 4
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 21
22093: PUSH
22094: LD_INT 3
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PPUSH
22105: CALL_OW 69
22109: PPUSH
22110: LD_VAR 0 3
22114: PUSH
22115: LD_INT 2
22117: ARRAY
22118: PPUSH
22119: CALL_OW 74
22123: PPUSH
22124: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22128: LD_EXP 58
22132: PPUSH
22133: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22137: LD_INT 99
22139: PPUSH
22140: LD_INT 83
22142: PPUSH
22143: LD_INT 1
22145: PPUSH
22146: CALL_OW 331
// repeat wait ( 4 ) ;
22150: LD_INT 4
22152: PPUSH
22153: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22157: LD_VAR 0 3
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PPUSH
22166: CALL_OW 256
22170: PUSH
22171: LD_INT 1000
22173: LESS
22174: IFFALSE 22192
// SetLives ( tmp [ 1 ] , 1000 ) ;
22176: LD_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ARRAY
22184: PPUSH
22185: LD_INT 1000
22187: PPUSH
22188: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 30
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PUSH
22221: LD_INT 0
22223: EQUAL
22224: IFFALSE 22150
// sync ;
22226: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22227: LD_EXP 58
22231: PPUSH
22232: LD_STRING D6a-Pow-1
22234: PPUSH
22235: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22239: LD_VAR 0 11
22243: PPUSH
22244: LD_STRING D6a-Sol3-1
22246: PPUSH
22247: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22251: LD_EXP 58
22255: PPUSH
22256: LD_STRING D6a-Pow-2
22258: PPUSH
22259: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22263: LD_VAR 0 11
22267: PPUSH
22268: LD_STRING D6a-Sol3-2
22270: PPUSH
22271: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22275: LD_EXP 58
22279: PPUSH
22280: LD_STRING D6a-Pow-3
22282: PPUSH
22283: CALL_OW 88
// powellCenterCameraMode := true ;
22287: LD_ADDR_EXP 20
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22295: LD_ADDR_VAR 0 1
22299: PUSH
22300: LD_INT 22
22302: PUSH
22303: LD_INT 8
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: LD_INT 25
22312: PUSH
22313: LD_INT 2
22315: PUSH
22316: EMPTY
22317: LIST
22318: LIST
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PPUSH
22324: CALL_OW 69
22328: PUSH
22329: FOR_IN
22330: IFFALSE 22385
// begin SetTag ( i , 1 ) ;
22332: LD_VAR 0 1
22336: PPUSH
22337: LD_INT 1
22339: PPUSH
22340: CALL_OW 109
// ComExitBuilding ( i ) ;
22344: LD_VAR 0 1
22348: PPUSH
22349: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22353: LD_VAR 0 1
22357: PPUSH
22358: LD_INT 35
22360: PPUSH
22361: LD_INT 6
22363: PPUSH
22364: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22368: LD_VAR 0 1
22372: PPUSH
22373: LD_INT 53
22375: PPUSH
22376: LD_INT 4
22378: PPUSH
22379: CALL_OW 171
// end ;
22383: GO 22329
22385: POP
22386: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22387: LD_ADDR_VAR 0 3
22391: PUSH
22392: LD_INT 22
22394: PUSH
22395: LD_INT 4
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PUSH
22402: LD_INT 21
22404: PUSH
22405: LD_INT 2
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: LD_INT 3
22414: PUSH
22415: LD_INT 34
22417: PUSH
22418: LD_INT 12
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: PPUSH
22434: CALL_OW 69
22438: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22439: LD_EXP 58
22443: PPUSH
22444: LD_VAR 0 3
22448: PPUSH
22449: LD_EXP 58
22453: PPUSH
22454: CALL_OW 74
22458: PPUSH
22459: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22463: LD_EXP 58
22467: PPUSH
22468: LD_INT 100
22470: PPUSH
22471: LD_INT 88
22473: PPUSH
22474: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22478: LD_EXP 58
22482: PPUSH
22483: LD_INT 100
22485: PPUSH
22486: LD_INT 75
22488: PPUSH
22489: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22493: LD_EXP 58
22497: PPUSH
22498: LD_INT 88
22500: PPUSH
22501: LD_INT 53
22503: PPUSH
22504: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22508: LD_INT 8
22510: PPUSH
22511: LD_EXP 58
22515: PPUSH
22516: CALL_OW 471
// repeat wait ( 3 ) ;
22520: LD_INT 3
22522: PPUSH
22523: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22527: LD_INT 22
22529: PUSH
22530: LD_INT 4
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PUSH
22537: LD_INT 92
22539: PUSH
22540: LD_INT 100
22542: PUSH
22543: LD_INT 75
22545: PUSH
22546: LD_INT 6
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PPUSH
22559: CALL_OW 69
22563: IFFALSE 22520
// async ;
22565: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22566: LD_EXP 58
22570: PPUSH
22571: LD_STRING D6b-Pow-1
22573: PPUSH
22574: CALL_OW 88
// repeat wait ( 3 ) ;
22578: LD_INT 3
22580: PPUSH
22581: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22585: LD_EXP 58
22589: PPUSH
22590: CALL_OW 310
22594: PPUSH
22595: CALL_OW 256
22599: PUSH
22600: LD_INT 1000
22602: LESS
22603: IFFALSE 22622
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22605: LD_EXP 58
22609: PPUSH
22610: CALL_OW 310
22614: PPUSH
22615: LD_INT 1000
22617: PPUSH
22618: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 256
22631: PUSH
22632: LD_INT 1000
22634: LESS
22635: IFFALSE 22649
// SetLives ( Powell , 1000 ) ;
22637: LD_EXP 58
22641: PPUSH
22642: LD_INT 1000
22644: PPUSH
22645: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22649: LD_EXP 58
22653: PPUSH
22654: LD_EXP 63
22658: PPUSH
22659: CALL_OW 296
22663: PUSH
22664: LD_INT 5
22666: LESS
22667: PUSH
22668: LD_EXP 58
22672: PPUSH
22673: CALL_OW 310
22677: PPUSH
22678: LD_EXP 63
22682: PPUSH
22683: CALL_OW 296
22687: PUSH
22688: LD_INT 5
22690: LESS
22691: OR
22692: IFFALSE 22711
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22694: LD_EXP 58
22698: PPUSH
22699: CALL_OW 310
22703: PPUSH
22704: LD_INT 100
22706: PPUSH
22707: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: NOT
22721: IFFALSE 22578
// DoNotAttack ( 8 , powellBomb ) ;
22723: LD_INT 8
22725: PPUSH
22726: LD_EXP 63
22730: PPUSH
22731: CALL_OW 471
// game_speed := 4 ;
22735: LD_ADDR_OWVAR 65
22739: PUSH
22740: LD_INT 4
22742: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22743: LD_EXP 58
22747: PPUSH
22748: LD_STRING D6b-Pow-1a
22750: PPUSH
22751: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22755: LD_EXP 58
22759: PPUSH
22760: LD_EXP 63
22764: PPUSH
22765: CALL_OW 180
// sync ;
22769: SYNC
// repeat wait ( 0 0$1 ) ;
22770: LD_INT 35
22772: PPUSH
22773: CALL_OW 67
// until IsInUnit ( Powell ) ;
22777: LD_EXP 58
22781: PPUSH
22782: CALL_OW 310
22786: IFFALSE 22770
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22788: LD_INT 8
22790: PPUSH
22791: LD_EXP 58
22795: PPUSH
22796: CALL_OW 310
22800: PPUSH
22801: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: LD_INT 91
22812: PPUSH
22813: LD_INT 44
22815: PPUSH
22816: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: LD_INT 96
22827: PPUSH
22828: LD_INT 44
22830: PPUSH
22831: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22835: LD_EXP 58
22839: PPUSH
22840: LD_INT 96
22842: PPUSH
22843: LD_INT 41
22845: PPUSH
22846: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22850: LD_EXP 58
22854: PPUSH
22855: LD_INT 92
22857: PPUSH
22858: LD_INT 39
22860: PPUSH
22861: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22865: LD_EXP 58
22869: PPUSH
22870: LD_INT 88
22872: PPUSH
22873: LD_INT 41
22875: PPUSH
22876: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22880: LD_EXP 58
22884: PPUSH
22885: LD_INT 91
22887: PPUSH
22888: LD_INT 44
22890: PPUSH
22891: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22895: LD_EXP 58
22899: PPUSH
22900: LD_INT 96
22902: PPUSH
22903: LD_INT 44
22905: PPUSH
22906: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22910: LD_EXP 58
22914: PPUSH
22915: LD_INT 96
22917: PPUSH
22918: LD_INT 41
22920: PPUSH
22921: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22925: LD_EXP 58
22929: PPUSH
22930: LD_INT 92
22932: PPUSH
22933: LD_INT 39
22935: PPUSH
22936: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22940: LD_EXP 58
22944: PPUSH
22945: LD_INT 88
22947: PPUSH
22948: LD_INT 41
22950: PPUSH
22951: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22955: LD_EXP 58
22959: PPUSH
22960: LD_INT 91
22962: PPUSH
22963: LD_INT 44
22965: PPUSH
22966: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22970: LD_EXP 58
22974: PPUSH
22975: LD_INT 93
22977: PPUSH
22978: LD_INT 39
22980: PPUSH
22981: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22985: LD_EXP 58
22989: PPUSH
22990: LD_INT 93
22992: PPUSH
22993: LD_INT 36
22995: PPUSH
22996: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23000: LD_INT 122
23002: PPUSH
23003: CALL_OW 67
// game_speed := 4 ;
23007: LD_ADDR_OWVAR 65
23011: PUSH
23012: LD_INT 4
23014: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23015: LD_EXP 58
23019: PPUSH
23020: LD_STRING D6b-Pow-1b
23022: PPUSH
23023: CALL_OW 88
// tmp := [ ] ;
23027: LD_ADDR_VAR 0 3
23031: PUSH
23032: EMPTY
23033: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23034: LD_ADDR_VAR 0 5
23038: PUSH
23039: LD_INT 78
23041: PUSH
23042: LD_INT 47
23044: PUSH
23045: EMPTY
23046: LIST
23047: LIST
23048: PUSH
23049: LD_INT 106
23051: PUSH
23052: LD_INT 53
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: PUSH
23059: EMPTY
23060: LIST
23061: LIST
23062: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23063: LD_ADDR_VAR 0 1
23067: PUSH
23068: LD_INT 22
23070: PUSH
23071: LD_INT 8
23073: PUSH
23074: EMPTY
23075: LIST
23076: LIST
23077: PUSH
23078: LD_INT 21
23080: PUSH
23081: LD_INT 3
23083: PUSH
23084: EMPTY
23085: LIST
23086: LIST
23087: PUSH
23088: LD_INT 92
23090: PUSH
23091: LD_INT 90
23093: PUSH
23094: LD_INT 52
23096: PUSH
23097: LD_INT 12
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: LIST
23110: PPUSH
23111: CALL_OW 69
23115: PUSH
23116: FOR_IN
23117: IFFALSE 23142
// tmp := tmp ^ UnitsInside ( i ) ;
23119: LD_ADDR_VAR 0 3
23123: PUSH
23124: LD_VAR 0 3
23128: PUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: CALL_OW 313
23138: ADD
23139: ST_TO_ADDR
23140: GO 23116
23142: POP
23143: POP
// for i in tmp do
23144: LD_ADDR_VAR 0 1
23148: PUSH
23149: LD_VAR 0 3
23153: PUSH
23154: FOR_IN
23155: IFFALSE 23317
// begin dist := 9999 ;
23157: LD_ADDR_VAR 0 8
23161: PUSH
23162: LD_INT 9999
23164: ST_TO_ADDR
// _xy := [ ] ;
23165: LD_ADDR_VAR 0 7
23169: PUSH
23170: EMPTY
23171: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23172: LD_VAR 0 1
23176: PPUSH
23177: LD_INT 1
23179: PPUSH
23180: CALL_OW 109
// ComExitBuilding ( i ) ;
23184: LD_VAR 0 1
23188: PPUSH
23189: CALL_OW 122
// for j in xy do
23193: LD_ADDR_VAR 0 2
23197: PUSH
23198: LD_VAR 0 5
23202: PUSH
23203: FOR_IN
23204: IFFALSE 23286
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23206: LD_VAR 0 1
23210: PPUSH
23211: LD_VAR 0 2
23215: PUSH
23216: LD_INT 1
23218: ARRAY
23219: PPUSH
23220: LD_VAR 0 2
23224: PUSH
23225: LD_INT 2
23227: ARRAY
23228: PPUSH
23229: CALL_OW 297
23233: PUSH
23234: LD_VAR 0 8
23238: LESS
23239: IFFALSE 23284
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23241: LD_ADDR_VAR 0 8
23245: PUSH
23246: LD_VAR 0 1
23250: PPUSH
23251: LD_VAR 0 2
23255: PUSH
23256: LD_INT 1
23258: ARRAY
23259: PPUSH
23260: LD_VAR 0 2
23264: PUSH
23265: LD_INT 2
23267: ARRAY
23268: PPUSH
23269: CALL_OW 297
23273: ST_TO_ADDR
// _xy := j ;
23274: LD_ADDR_VAR 0 7
23278: PUSH
23279: LD_VAR 0 2
23283: ST_TO_ADDR
// end ;
23284: GO 23203
23286: POP
23287: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23288: LD_VAR 0 1
23292: PPUSH
23293: LD_VAR 0 7
23297: PUSH
23298: LD_INT 1
23300: ARRAY
23301: PPUSH
23302: LD_VAR 0 7
23306: PUSH
23307: LD_INT 2
23309: ARRAY
23310: PPUSH
23311: CALL_OW 171
// end ;
23315: GO 23154
23317: POP
23318: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23319: LD_ADDR_VAR 0 4
23323: PUSH
23324: LD_VAR 0 3
23328: PPUSH
23329: LD_INT 26
23331: PUSH
23332: LD_INT 1
23334: PUSH
23335: EMPTY
23336: LIST
23337: LIST
23338: PUSH
23339: LD_INT 25
23341: PUSH
23342: LD_INT 1
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PPUSH
23353: CALL_OW 72
23357: ST_TO_ADDR
// if tmp2 < 2 then
23358: LD_VAR 0 4
23362: PUSH
23363: LD_INT 2
23365: LESS
23366: IFFALSE 23435
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23368: LD_ADDR_VAR 0 4
23372: PUSH
23373: LD_INT 22
23375: PUSH
23376: LD_INT 8
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PUSH
23383: LD_INT 26
23385: PUSH
23386: LD_INT 1
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PUSH
23393: LD_INT 3
23395: PUSH
23396: LD_INT 25
23398: PUSH
23399: LD_INT 15
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: LIST
23414: PPUSH
23415: CALL_OW 69
23419: PUSH
23420: LD_EXP 60
23424: PUSH
23425: LD_EXP 61
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: DIFF
23434: ST_TO_ADDR
// if tmp2 then
23435: LD_VAR 0 4
23439: IFFALSE 23457
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23441: LD_VAR 0 4
23445: PUSH
23446: LD_INT 1
23448: ARRAY
23449: PPUSH
23450: LD_STRING D6b-ArSol1-1
23452: PPUSH
23453: CALL_OW 88
// async ;
23457: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23458: LD_EXP 58
23462: PPUSH
23463: LD_STRING D6b-Pow-2
23465: PPUSH
23466: CALL_OW 88
// wait ( 0 0$1 ) ;
23470: LD_INT 35
23472: PPUSH
23473: CALL_OW 67
// if tmp2 > 1 then
23477: LD_VAR 0 4
23481: PUSH
23482: LD_INT 1
23484: GREATER
23485: IFFALSE 23503
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23487: LD_VAR 0 4
23491: PUSH
23492: LD_INT 2
23494: ARRAY
23495: PPUSH
23496: LD_STRING D6b-ArSol2-1
23498: PPUSH
23499: CALL_OW 88
// sync ;
23503: SYNC
// repeat wait ( 5 ) ;
23504: LD_INT 5
23506: PPUSH
23507: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23511: LD_INT 93
23513: PPUSH
23514: LD_INT 36
23516: PPUSH
23517: CALL_OW 428
23521: PPUSH
23522: CALL_OW 255
23526: PUSH
23527: LD_INT 4
23529: EQUAL
23530: IFFALSE 23504
// DialogueOn ;
23532: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23536: LD_INT 10
23538: PPUSH
23539: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23543: LD_EXP 58
23547: PPUSH
23548: LD_STRING D6b-Pow-2a
23550: PPUSH
23551: CALL_OW 88
// DialogueOff ;
23555: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23559: LD_EXP 58
23563: PPUSH
23564: CALL_OW 310
23568: PPUSH
23569: LD_INT 332
23571: PPUSH
23572: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23576: LD_INT 93
23578: PPUSH
23579: LD_INT 35
23581: PPUSH
23582: LD_INT 1
23584: PPUSH
23585: LD_INT 6
23587: NEG
23588: PPUSH
23589: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23593: LD_INT 35
23595: PPUSH
23596: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23600: LD_INT 332
23602: PPUSH
23603: CALL_OW 256
23607: PUSH
23608: LD_INT 1000
23610: LESS
23611: PUSH
23612: LD_INT 332
23614: PPUSH
23615: CALL_OW 300
23619: AND
23620: IFFALSE 23632
// SetLives ( kozlov_fac , 0 ) ;
23622: LD_INT 332
23624: PPUSH
23625: LD_INT 0
23627: PPUSH
23628: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23632: LD_INT 332
23634: PPUSH
23635: CALL_OW 301
23639: PUSH
23640: LD_EXP 58
23644: PPUSH
23645: CALL_OW 301
23649: OR
23650: IFFALSE 23593
// game_speed := 4 ;
23652: LD_ADDR_OWVAR 65
23656: PUSH
23657: LD_INT 4
23659: ST_TO_ADDR
// powellCenterCameraMode := false ;
23660: LD_ADDR_EXP 20
23664: PUSH
23665: LD_INT 0
23667: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23668: LD_ADDR_VAR 0 1
23672: PUSH
23673: LD_VAR 0 3
23677: PUSH
23678: LD_INT 22
23680: PUSH
23681: LD_INT 8
23683: PUSH
23684: EMPTY
23685: LIST
23686: LIST
23687: PUSH
23688: LD_INT 25
23690: PUSH
23691: LD_INT 2
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 69
23706: UNION
23707: PUSH
23708: FOR_IN
23709: IFFALSE 23725
// SetTag ( i , 0 ) ;
23711: LD_VAR 0 1
23715: PPUSH
23716: LD_INT 0
23718: PPUSH
23719: CALL_OW 109
23723: GO 23708
23725: POP
23726: POP
// wait ( 0 0$3 ) ;
23727: LD_INT 105
23729: PPUSH
23730: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23734: LD_INT 93
23736: PPUSH
23737: LD_INT 35
23739: PPUSH
23740: LD_INT 1
23742: PPUSH
23743: CALL_OW 331
// DialogueOn ;
23747: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23751: LD_VAR 0 11
23755: PPUSH
23756: LD_STRING D6c-Sol3-1
23758: PPUSH
23759: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23763: LD_INT 10
23765: PPUSH
23766: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23770: LD_EXP 39
23774: PPUSH
23775: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23779: LD_EXP 39
23783: PPUSH
23784: LD_STRING D6c-JMM-1
23786: PPUSH
23787: CALL_OW 88
// if Cyrus then
23791: LD_EXP 45
23795: IFFALSE 23809
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23797: LD_EXP 45
23801: PPUSH
23802: LD_STRING D6c-Cyrus-1
23804: PPUSH
23805: CALL_OW 88
// if Bobby then
23809: LD_EXP 44
23813: IFFALSE 23827
// Say ( Bobby , D6c-Bobby-1 ) ;
23815: LD_EXP 44
23819: PPUSH
23820: LD_STRING D6c-Bobby-1
23822: PPUSH
23823: CALL_OW 88
// if Cornel then
23827: LD_EXP 50
23831: IFFALSE 23845
// Say ( Cornel , D6c-Corn-1 ) ;
23833: LD_EXP 50
23837: PPUSH
23838: LD_STRING D6c-Corn-1
23840: PPUSH
23841: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23845: LD_ADDR_VAR 0 4
23849: PUSH
23850: LD_INT 2
23852: PUSH
23853: LD_INT 22
23855: PUSH
23856: LD_INT 1
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: PUSH
23863: LD_INT 22
23865: PUSH
23866: LD_INT 4
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: LIST
23877: PUSH
23878: LD_INT 26
23880: PUSH
23881: LD_INT 1
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 3
23890: PUSH
23891: LD_INT 25
23893: PUSH
23894: LD_INT 16
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: PUSH
23901: LD_INT 25
23903: PUSH
23904: LD_INT 12
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: LIST
23920: PPUSH
23921: CALL_OW 69
23925: PUSH
23926: LD_VAR 0 11
23930: PUSH
23931: LD_EXP 39
23935: UNION
23936: PUSH
23937: LD_EXP 59
23941: UNION
23942: PUSH
23943: EMPTY
23944: LIST
23945: DIFF
23946: ST_TO_ADDR
// if tmp2 then
23947: LD_VAR 0 4
23951: IFFALSE 23969
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23953: LD_VAR 0 4
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: PPUSH
23962: LD_STRING D6c-Sol1-1
23964: PPUSH
23965: CALL_OW 88
// if Lisa then
23969: LD_EXP 42
23973: IFFALSE 23987
// Say ( Lisa , D6c-Lisa-1 ) ;
23975: LD_EXP 42
23979: PPUSH
23980: LD_STRING D6c-Lisa-1
23982: PPUSH
23983: CALL_OW 88
// if Gary then
23987: LD_EXP 51
23991: IFFALSE 24005
// Say ( Gary , D6c-Gary-1 ) ;
23993: LD_EXP 51
23997: PPUSH
23998: LD_STRING D6c-Gary-1
24000: PPUSH
24001: CALL_OW 88
// if Donaldson then
24005: LD_EXP 43
24009: IFFALSE 24023
// Say ( Donaldson , D6c-Don-1 ) ;
24011: LD_EXP 43
24015: PPUSH
24016: LD_STRING D6c-Don-1
24018: PPUSH
24019: CALL_OW 88
// if tmp2 > 1 then
24023: LD_VAR 0 4
24027: PUSH
24028: LD_INT 1
24030: GREATER
24031: IFFALSE 24049
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24033: LD_VAR 0 4
24037: PUSH
24038: LD_INT 2
24040: ARRAY
24041: PPUSH
24042: LD_STRING D6c-Sol2-1
24044: PPUSH
24045: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24049: LD_VAR 0 11
24053: PPUSH
24054: LD_STRING D6c-Sol3-2
24056: PPUSH
24057: CALL_OW 88
// dwait ( 0 0$1 ) ;
24061: LD_INT 35
24063: PPUSH
24064: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24068: LD_EXP 39
24072: PPUSH
24073: LD_STRING D6c-JMM-2
24075: PPUSH
24076: CALL_OW 88
// DialogueOff ;
24080: CALL_OW 7
// Video ( false ) ;
24084: LD_INT 0
24086: PPUSH
24087: CALL 107581 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24091: LD_INT 22
24093: PUSH
24094: LD_INT 4
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PPUSH
24101: CALL_OW 69
24105: PPUSH
24106: LD_INT 1
24108: PPUSH
24109: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24113: LD_INT 4
24115: PPUSH
24116: LD_INT 4
24118: PPUSH
24119: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24123: LD_ADDR_VAR 0 1
24127: PUSH
24128: LD_INT 4
24130: PPUSH
24131: LD_INT 1
24133: PPUSH
24134: LD_INT 2
24136: PPUSH
24137: CALL 64809 0 3
24141: PUSH
24142: FOR_IN
24143: IFFALSE 24180
// if GetTech ( i , 1 ) <> state_researched then
24145: LD_VAR 0 1
24149: PPUSH
24150: LD_INT 1
24152: PPUSH
24153: CALL_OW 321
24157: PUSH
24158: LD_INT 2
24160: NONEQUAL
24161: IFFALSE 24178
// SetTech ( i , 1 , state_researched ) ;
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: LD_INT 2
24173: PPUSH
24174: CALL_OW 322
24178: GO 24142
24180: POP
24181: POP
// missionStage := 6 ;
24182: LD_ADDR_EXP 15
24186: PUSH
24187: LD_INT 6
24189: ST_TO_ADDR
// activeAttacks := true ;
24190: LD_ADDR_EXP 16
24194: PUSH
24195: LD_INT 1
24197: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24198: LD_STRING M2
24200: PPUSH
24201: CALL_OW 337
// SaveForQuickRestart ;
24205: CALL_OW 22
// wait ( 0 0$40 ) ;
24209: LD_INT 1400
24211: PPUSH
24212: CALL_OW 67
// DialogueOn ;
24216: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24220: LD_EXP 62
24224: PPUSH
24225: LD_STRING D7-Friend-1
24227: PPUSH
24228: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24232: LD_EXP 39
24236: PPUSH
24237: LD_STRING D7-JMM-1
24239: PPUSH
24240: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24244: LD_EXP 62
24248: PPUSH
24249: LD_STRING D7-Friend-2
24251: PPUSH
24252: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24256: LD_EXP 39
24260: PPUSH
24261: LD_STRING D7-JMM-2
24263: PPUSH
24264: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24268: LD_EXP 62
24272: PPUSH
24273: LD_STRING D7-Friend-3
24275: PPUSH
24276: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24280: LD_EXP 39
24284: PPUSH
24285: LD_STRING D7-JMM-3
24287: PPUSH
24288: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24292: LD_EXP 62
24296: PPUSH
24297: LD_STRING D7-Friend-4
24299: PPUSH
24300: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24304: LD_EXP 39
24308: PPUSH
24309: LD_STRING D7-JMM-4
24311: PPUSH
24312: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24316: LD_EXP 62
24320: PPUSH
24321: LD_STRING D7-Friend-5
24323: PPUSH
24324: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24328: LD_EXP 39
24332: PPUSH
24333: LD_STRING D7-JMM-5
24335: PPUSH
24336: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24340: LD_EXP 62
24344: PPUSH
24345: LD_STRING D7-Friend-6
24347: PPUSH
24348: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24352: LD_EXP 39
24356: PPUSH
24357: LD_STRING D7-JMM-6
24359: PPUSH
24360: CALL_OW 88
// DialogueOff ;
24364: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24368: LD_STRING Mlegion
24370: PPUSH
24371: CALL_OW 337
// RebuildKozlovFactory ;
24375: CALL 4819 0 0
// end ;
24379: PPOPN 13
24381: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24382: LD_EXP 20
24386: PUSH
24387: LD_EXP 58
24391: PPUSH
24392: CALL_OW 300
24396: AND
24397: IFFALSE 24439
24399: GO 24401
24401: DISABLE
// begin enable ;
24402: ENABLE
// if IsInUnit ( Powell ) then
24403: LD_EXP 58
24407: PPUSH
24408: CALL_OW 310
24412: IFFALSE 24430
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24414: LD_EXP 58
24418: PPUSH
24419: CALL_OW 310
24423: PPUSH
24424: CALL_OW 85
24428: GO 24439
// CenterOnUnits ( Powell ) ;
24430: LD_EXP 58
24434: PPUSH
24435: CALL_OW 85
// end ;
24439: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24440: LD_INT 22
24442: PUSH
24443: LD_INT 8
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: LD_INT 34
24452: PUSH
24453: LD_INT 48
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PPUSH
24464: CALL_OW 69
24468: IFFALSE 24742
24470: GO 24472
24472: DISABLE
24473: LD_INT 0
24475: PPUSH
24476: PPUSH
// begin if missionStage < 9 then
24477: LD_EXP 15
24481: PUSH
24482: LD_INT 9
24484: LESS
24485: IFFALSE 24495
// missionStage := 9 ;
24487: LD_ADDR_EXP 15
24491: PUSH
24492: LD_INT 9
24494: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24495: LD_ADDR_VAR 0 1
24499: PUSH
24500: LD_INT 22
24502: PUSH
24503: LD_INT 8
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: LD_INT 34
24512: PUSH
24513: LD_INT 48
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PPUSH
24524: CALL_OW 69
24528: PUSH
24529: LD_INT 1
24531: ARRAY
24532: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24533: LD_INT 175
24535: PPUSH
24536: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24540: LD_EXP 12
24544: PUSH
24545: LD_EXP 3
24549: PUSH
24550: LD_INT 0
24552: PUSH
24553: LD_INT 2
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: IN
24560: OR
24561: IFFALSE 24584
// target := [ 68 , 108 , 1 ] else
24563: LD_ADDR_VAR 0 2
24567: PUSH
24568: LD_INT 68
24570: PUSH
24571: LD_INT 108
24573: PUSH
24574: LD_INT 1
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: LIST
24581: ST_TO_ADDR
24582: GO 24603
// target := [ 181 , 88 , 2 ] ;
24584: LD_ADDR_VAR 0 2
24588: PUSH
24589: LD_INT 181
24591: PUSH
24592: LD_INT 88
24594: PUSH
24595: LD_INT 2
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: LIST
24602: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24603: LD_VAR 0 1
24607: PPUSH
24608: LD_VAR 0 2
24612: PUSH
24613: LD_INT 1
24615: ARRAY
24616: PPUSH
24617: LD_VAR 0 2
24621: PUSH
24622: LD_INT 2
24624: ARRAY
24625: PPUSH
24626: CALL_OW 176
// if target [ 3 ] = 1 then
24630: LD_VAR 0 2
24634: PUSH
24635: LD_INT 3
24637: ARRAY
24638: PUSH
24639: LD_INT 1
24641: EQUAL
24642: IFFALSE 24658
// SayRadio ( Kurt , D12-Kurt-1 ) else
24644: LD_EXP 60
24648: PPUSH
24649: LD_STRING D12-Kurt-1
24651: PPUSH
24652: CALL_OW 94
24656: GO 24682
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24658: LD_EXP 60
24662: PPUSH
24663: LD_STRING D12a-Kurt-1
24665: PPUSH
24666: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24670: LD_EXP 74
24674: PPUSH
24675: LD_STRING D12a-Roth-1
24677: PPUSH
24678: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24682: LD_INT 350
24684: PPUSH
24685: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24689: LD_VAR 0 1
24693: PPUSH
24694: LD_INT 22
24696: PUSH
24697: LD_INT 8
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 23
24706: PUSH
24707: LD_INT 2
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 30
24716: PUSH
24717: LD_INT 3
24719: PUSH
24720: EMPTY
24721: LIST
24722: LIST
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: PPUSH
24729: CALL_OW 69
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: CALL_OW 228
// end ;
24742: PPOPN 2
24744: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24745: LD_EXP 60
24749: PPUSH
24750: CALL_OW 256
24754: PUSH
24755: LD_INT 999
24757: LESS
24758: PUSH
24759: LD_INT 22
24761: PUSH
24762: LD_INT 8
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 21
24771: PUSH
24772: LD_INT 1
24774: PUSH
24775: EMPTY
24776: LIST
24777: LIST
24778: PUSH
24779: LD_INT 23
24781: PUSH
24782: LD_INT 2
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: LIST
24793: PPUSH
24794: CALL_OW 69
24798: PUSH
24799: LD_INT 9
24801: PUSH
24802: LD_INT 8
24804: PUSH
24805: LD_INT 7
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: LIST
24812: PUSH
24813: LD_OWVAR 67
24817: ARRAY
24818: LESSEQUAL
24819: OR
24820: PUSH
24821: LD_INT 22
24823: PUSH
24824: LD_INT 8
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 34
24833: PUSH
24834: LD_INT 48
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PPUSH
24845: CALL_OW 69
24849: NOT
24850: AND
24851: PUSH
24852: LD_EXP 60
24856: PPUSH
24857: CALL_OW 302
24861: AND
24862: PUSH
24863: LD_INT 5
24865: PPUSH
24866: LD_INT 22
24868: PUSH
24869: LD_INT 1
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PPUSH
24876: CALL_OW 70
24880: AND
24881: IFFALSE 25518
24883: GO 24885
24885: DISABLE
24886: LD_INT 0
24888: PPUSH
24889: PPUSH
24890: PPUSH
// begin DialogueOn ;
24891: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24895: LD_EXP 39
24899: PPUSH
24900: LD_STRING D13-JMM-1
24902: PPUSH
24903: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24907: LD_EXP 60
24911: PPUSH
24912: LD_STRING D13-Kurt-1
24914: PPUSH
24915: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24919: LD_EXP 39
24923: PPUSH
24924: LD_STRING D13-JMM-2
24926: PPUSH
24927: CALL_OW 88
// if FakeInfo then
24931: LD_EXP 12
24935: IFFALSE 24955
// begin Say ( Kurt , D13-Kurt-2 ) ;
24937: LD_EXP 60
24941: PPUSH
24942: LD_STRING D13-Kurt-2
24944: PPUSH
24945: CALL_OW 88
// DialogueOff ;
24949: CALL_OW 7
// exit ;
24953: GO 25518
// end ; if not KurtStatus then
24955: LD_EXP 3
24959: NOT
24960: IFFALSE 24976
// Say ( Kurt , D13-Kurt-2b ) else
24962: LD_EXP 60
24966: PPUSH
24967: LD_STRING D13-Kurt-2b
24969: PPUSH
24970: CALL_OW 88
24974: GO 24988
// Say ( Kurt , D13-Kurt-2a ) ;
24976: LD_EXP 60
24980: PPUSH
24981: LD_STRING D13-Kurt-2a
24983: PPUSH
24984: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24988: LD_EXP 39
24992: PPUSH
24993: LD_STRING D13-JMM-3
24995: PPUSH
24996: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25000: LD_EXP 60
25004: PPUSH
25005: LD_STRING D13-Kurt-3
25007: PPUSH
25008: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25012: LD_EXP 39
25016: PPUSH
25017: LD_STRING D13-JMM-4
25019: PPUSH
25020: CALL_OW 88
// DialogueOff ;
25024: CALL_OW 7
// MC_Kill ( 3 ) ;
25028: LD_INT 3
25030: PPUSH
25031: CALL 34942 0 1
// KillUnit ( Kozlov ) ;
25035: LD_EXP 61
25039: PPUSH
25040: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25044: LD_INT 22
25046: PUSH
25047: LD_INT 8
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: LD_INT 21
25056: PUSH
25057: LD_INT 3
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 23
25066: PUSH
25067: LD_INT 3
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 30
25076: PUSH
25077: LD_INT 3
25079: PUSH
25080: EMPTY
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: LIST
25088: LIST
25089: PPUSH
25090: CALL_OW 69
25094: PUSH
25095: LD_INT 1
25097: ARRAY
25098: PPUSH
25099: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25103: LD_INT 8
25105: PPUSH
25106: LD_INT 1
25108: PPUSH
25109: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25113: LD_ADDR_VAR 0 2
25117: PUSH
25118: LD_INT 22
25120: PUSH
25121: LD_INT 8
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 21
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PPUSH
25142: CALL_OW 69
25146: PUSH
25147: LD_EXP 61
25151: PUSH
25152: LD_EXP 60
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: DIFF
25161: ST_TO_ADDR
// if tmp >= [ 9 , 8 , 7 ] [ Difficulty ] then
25162: LD_VAR 0 2
25166: PUSH
25167: LD_INT 9
25169: PUSH
25170: LD_INT 8
25172: PUSH
25173: LD_INT 7
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PUSH
25181: LD_OWVAR 67
25185: ARRAY
25186: GREATEREQUAL
25187: IFFALSE 25349
// begin x := [ 9 , 8 , 7 ] [ Difficulty ] ;
25189: LD_ADDR_VAR 0 3
25193: PUSH
25194: LD_INT 9
25196: PUSH
25197: LD_INT 8
25199: PUSH
25200: LD_INT 7
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_OWVAR 67
25212: ARRAY
25213: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25214: LD_ADDR_VAR 0 1
25218: PUSH
25219: DOUBLE
25220: LD_VAR 0 2
25224: PUSH
25225: LD_VAR 0 3
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: MINUS
25234: INC
25235: ST_TO_ADDR
25236: LD_INT 1
25238: PUSH
25239: FOR_DOWNTO
25240: IFFALSE 25345
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25242: LD_ADDR_EXP 38
25246: PUSH
25247: LD_EXP 38
25251: PUSH
25252: LD_VAR 0 2
25256: PUSH
25257: LD_VAR 0 1
25261: ARRAY
25262: ADD
25263: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 1
25273: ARRAY
25274: PPUSH
25275: CALL_OW 310
25279: IFFALSE 25296
// ComExitBuilding ( tmp [ i ] ) ;
25281: LD_VAR 0 2
25285: PUSH
25286: LD_VAR 0 1
25290: ARRAY
25291: PPUSH
25292: CALL_OW 122
// if IsInUnit ( i ) then
25296: LD_VAR 0 1
25300: PPUSH
25301: CALL_OW 310
25305: IFFALSE 25322
// ComExitVehicle ( tmp [ i ] ) ;
25307: LD_VAR 0 2
25311: PUSH
25312: LD_VAR 0 1
25316: ARRAY
25317: PPUSH
25318: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 37 , 1 ) ;
25322: LD_VAR 0 2
25326: PUSH
25327: LD_VAR 0 1
25331: ARRAY
25332: PPUSH
25333: LD_INT 37
25335: PPUSH
25336: LD_INT 1
25338: PPUSH
25339: CALL_OW 171
// end ;
25343: GO 25239
25345: POP
25346: POP
// end else
25347: GO 25359
// x := tmp ;
25349: LD_ADDR_VAR 0 3
25353: PUSH
25354: LD_VAR 0 2
25358: ST_TO_ADDR
// for i := tmp downto tmp - x do
25359: LD_ADDR_VAR 0 1
25363: PUSH
25364: DOUBLE
25365: LD_VAR 0 2
25369: INC
25370: ST_TO_ADDR
25371: LD_VAR 0 2
25375: PUSH
25376: LD_VAR 0 3
25380: MINUS
25381: PUSH
25382: FOR_DOWNTO
25383: IFFALSE 25405
// SetSide ( tmp [ i ] , 1 ) ;
25385: LD_VAR 0 2
25389: PUSH
25390: LD_VAR 0 1
25394: ARRAY
25395: PPUSH
25396: LD_INT 1
25398: PPUSH
25399: CALL_OW 235
25403: GO 25382
25405: POP
25406: POP
// SetSide ( Kurt , 1 ) ;
25407: LD_EXP 60
25411: PPUSH
25412: LD_INT 1
25414: PPUSH
25415: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25419: LD_INT 22
25421: PUSH
25422: LD_INT 8
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 21
25431: PUSH
25432: LD_INT 3
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PPUSH
25443: CALL_OW 69
25447: PPUSH
25448: LD_INT 1
25450: PPUSH
25451: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25455: LD_INT 8
25457: PPUSH
25458: LD_INT 1
25460: PPUSH
25461: LD_INT 1
25463: PPUSH
25464: LD_INT 1
25466: PPUSH
25467: CALL_OW 80
// wait ( 0 0$40 ) ;
25471: LD_INT 1400
25473: PPUSH
25474: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25478: LD_EXP 62
25482: PPUSH
25483: LD_INT 37
25485: PPUSH
25486: LD_INT 1
25488: PPUSH
25489: LD_INT 0
25491: PPUSH
25492: CALL_OW 48
// wait ( 0 0$1 ) ;
25496: LD_INT 35
25498: PPUSH
25499: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25503: LD_EXP 62
25507: PPUSH
25508: LD_INT 60
25510: PPUSH
25511: LD_INT 95
25513: PPUSH
25514: CALL_OW 111
// end ;
25518: PPOPN 3
25520: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25521: LD_EXP 38
25525: IFFALSE 25600
25527: GO 25529
25529: DISABLE
25530: LD_INT 0
25532: PPUSH
// begin enable ;
25533: ENABLE
// for i in legionEscapeUnits do
25534: LD_ADDR_VAR 0 1
25538: PUSH
25539: LD_EXP 38
25543: PUSH
25544: FOR_IN
25545: IFFALSE 25598
// begin if IsInArea ( i , legionEscapeArea ) then
25547: LD_VAR 0 1
25551: PPUSH
25552: LD_INT 31
25554: PPUSH
25555: CALL_OW 308
25559: IFFALSE 25572
// RemoveUnit ( i ) else
25561: LD_VAR 0 1
25565: PPUSH
25566: CALL_OW 64
25570: GO 25596
// if not HasTask ( i ) then
25572: LD_VAR 0 1
25576: PPUSH
25577: CALL_OW 314
25581: NOT
25582: IFFALSE 25596
// ComMoveToArea ( i , legionEscapeArea ) ;
25584: LD_VAR 0 1
25588: PPUSH
25589: LD_INT 31
25591: PPUSH
25592: CALL_OW 113
// end ;
25596: GO 25544
25598: POP
25599: POP
// end ;
25600: PPOPN 1
25602: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25603: LD_INT 22
25605: PUSH
25606: LD_INT 8
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 21
25615: PUSH
25616: LD_INT 1
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PPUSH
25627: CALL_OW 69
25631: PUSH
25632: LD_INT 0
25634: EQUAL
25635: IFFALSE 25655
25637: GO 25639
25639: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25640: LD_STRING MlegionOut
25642: PPUSH
25643: CALL_OW 337
// legionDestroyed := true ;
25647: LD_ADDR_EXP 22
25651: PUSH
25652: LD_INT 1
25654: ST_TO_ADDR
// end ;
25655: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25656: LD_INT 1
25658: PPUSH
25659: LD_EXP 62
25663: PPUSH
25664: CALL_OW 292
25668: IFFALSE 25982
25670: GO 25672
25672: DISABLE
25673: LD_INT 0
25675: PPUSH
// begin wait ( 0 0$2 ) ;
25676: LD_INT 70
25678: PPUSH
25679: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25683: LD_EXP 62
25687: PPUSH
25688: CALL_OW 87
// DialogueOn ;
25692: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25696: LD_EXP 39
25700: PPUSH
25701: LD_STRING D14-JMM-1
25703: PPUSH
25704: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25708: LD_EXP 62
25712: PPUSH
25713: LD_STRING D14-Friend-1
25715: PPUSH
25716: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25720: LD_EXP 39
25724: PPUSH
25725: LD_STRING D14-JMM-2
25727: PPUSH
25728: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25732: LD_EXP 62
25736: PPUSH
25737: LD_STRING D14-Friend-2
25739: PPUSH
25740: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25744: LD_EXP 39
25748: PPUSH
25749: LD_STRING D14-JMM-3
25751: PPUSH
25752: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25756: LD_EXP 62
25760: PPUSH
25761: LD_STRING D14-Friend-3
25763: PPUSH
25764: CALL_OW 88
// DialogueOff ;
25768: CALL_OW 7
// dec = Query ( Q14 ) ;
25772: LD_ADDR_VAR 0 1
25776: PUSH
25777: LD_STRING Q14
25779: PPUSH
25780: CALL_OW 97
25784: ST_TO_ADDR
// if dec = 1 then
25785: LD_VAR 0 1
25789: PUSH
25790: LD_INT 1
25792: EQUAL
25793: IFFALSE 25827
// begin DialogueOn ;
25795: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25799: LD_EXP 39
25803: PPUSH
25804: LD_STRING D14a-JMM-1
25806: PPUSH
25807: CALL_OW 88
// DialogueOff ;
25811: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25815: LD_EXP 62
25819: PPUSH
25820: LD_INT 1
25822: PPUSH
25823: CALL_OW 235
// end ; if dec = 2 then
25827: LD_VAR 0 1
25831: PUSH
25832: LD_INT 2
25834: EQUAL
25835: IFFALSE 25888
// begin DialogueOn ;
25837: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25841: LD_EXP 39
25845: PPUSH
25846: LD_STRING D14b-JMM-1
25848: PPUSH
25849: CALL_OW 88
// DialogueOff ;
25853: CALL_OW 7
// wait ( 0 0$1 ) ;
25857: LD_INT 35
25859: PPUSH
25860: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25864: LD_EXP 62
25868: PPUSH
25869: LD_INT 9
25871: PPUSH
25872: LD_INT 2
25874: PPUSH
25875: CALL_OW 111
// AddComHold ( Friend ) ;
25879: LD_EXP 62
25883: PPUSH
25884: CALL_OW 200
// end ; if dec = 3 then
25888: LD_VAR 0 1
25892: PUSH
25893: LD_INT 3
25895: EQUAL
25896: IFFALSE 25982
// begin DialogueOn ;
25898: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25902: LD_EXP 39
25906: PPUSH
25907: LD_STRING D14c-JMM-1
25909: PPUSH
25910: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25914: LD_EXP 62
25918: PPUSH
25919: LD_STRING D14c-Friend-1
25921: PPUSH
25922: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25926: LD_EXP 39
25930: PPUSH
25931: LD_STRING D14c-JMM-2
25933: PPUSH
25934: CALL_OW 88
// DialogueOff ;
25938: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25942: LD_INT 8
25944: PPUSH
25945: LD_INT 1
25947: PPUSH
25948: LD_INT 2
25950: PPUSH
25951: LD_INT 1
25953: PPUSH
25954: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_INT 9
25965: PPUSH
25966: LD_INT 2
25968: PPUSH
25969: CALL_OW 111
// AddComHold ( Friend ) ;
25973: LD_EXP 62
25977: PPUSH
25978: CALL_OW 200
// end ; end ;
25982: PPOPN 1
25984: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25985: LD_INT 9
25987: PPUSH
25988: LD_INT 2
25990: PPUSH
25991: CALL_OW 428
25995: PUSH
25996: LD_EXP 62
26000: EQUAL
26001: PUSH
26002: LD_EXP 62
26006: PPUSH
26007: CALL_OW 255
26011: PUSH
26012: LD_INT 8
26014: EQUAL
26015: AND
26016: IFFALSE 26030
26018: GO 26020
26020: DISABLE
// RemoveUnit ( Friend ) ;
26021: LD_EXP 62
26025: PPUSH
26026: CALL_OW 64
26030: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26031: LD_EXP 14
26035: PUSH
26036: LD_INT 31500
26038: GREATEREQUAL
26039: PUSH
26040: LD_EXP 7
26044: AND
26045: PUSH
26046: LD_EXP 2
26050: AND
26051: IFFALSE 26481
26053: GO 26055
26055: DISABLE
26056: LD_INT 0
26058: PPUSH
26059: PPUSH
26060: PPUSH
// begin missionStage := 7 ;
26061: LD_ADDR_EXP 15
26065: PUSH
26066: LD_INT 7
26068: ST_TO_ADDR
// uc_side = 1 ;
26069: LD_ADDR_OWVAR 20
26073: PUSH
26074: LD_INT 1
26076: ST_TO_ADDR
// uc_nation = 1 ;
26077: LD_ADDR_OWVAR 21
26081: PUSH
26082: LD_INT 1
26084: ST_TO_ADDR
// for i = 1 to 5 do
26085: LD_ADDR_VAR 0 1
26089: PUSH
26090: DOUBLE
26091: LD_INT 1
26093: DEC
26094: ST_TO_ADDR
26095: LD_INT 5
26097: PUSH
26098: FOR_TO
26099: IFFALSE 26195
// begin vc_engine = 3 ;
26101: LD_ADDR_OWVAR 39
26105: PUSH
26106: LD_INT 3
26108: ST_TO_ADDR
// vc_control = 3 ;
26109: LD_ADDR_OWVAR 38
26113: PUSH
26114: LD_INT 3
26116: ST_TO_ADDR
// vc_chassis = 3 ;
26117: LD_ADDR_OWVAR 37
26121: PUSH
26122: LD_INT 3
26124: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26125: LD_ADDR_OWVAR 40
26129: PUSH
26130: LD_INT 5
26132: PUSH
26133: LD_INT 9
26135: PUSH
26136: LD_INT 7
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: LIST
26143: PUSH
26144: LD_INT 1
26146: PPUSH
26147: LD_INT 3
26149: PPUSH
26150: CALL_OW 12
26154: ARRAY
26155: ST_TO_ADDR
// veh = CreateVehicle ;
26156: LD_ADDR_VAR 0 2
26160: PUSH
26161: CALL_OW 45
26165: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26166: LD_VAR 0 2
26170: PPUSH
26171: LD_INT 1
26173: PPUSH
26174: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26178: LD_VAR 0 2
26182: PPUSH
26183: LD_INT 19
26185: PPUSH
26186: LD_INT 0
26188: PPUSH
26189: CALL_OW 49
// end ;
26193: GO 26098
26195: POP
26196: POP
// vc_engine = 3 ;
26197: LD_ADDR_OWVAR 39
26201: PUSH
26202: LD_INT 3
26204: ST_TO_ADDR
// vc_control = 1 ;
26205: LD_ADDR_OWVAR 38
26209: PUSH
26210: LD_INT 1
26212: ST_TO_ADDR
// vc_chassis = 3 ;
26213: LD_ADDR_OWVAR 37
26217: PUSH
26218: LD_INT 3
26220: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26221: LD_ADDR_OWVAR 40
26225: PUSH
26226: LD_INT 5
26228: PUSH
26229: LD_INT 9
26231: PUSH
26232: LD_INT 7
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: LIST
26239: PUSH
26240: LD_INT 1
26242: PPUSH
26243: LD_INT 3
26245: PPUSH
26246: CALL_OW 12
26250: ARRAY
26251: ST_TO_ADDR
// vehG = CreateVehicle ;
26252: LD_ADDR_VAR 0 3
26256: PUSH
26257: CALL_OW 45
26261: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26262: LD_VAR 0 3
26266: PPUSH
26267: LD_INT 1
26269: PPUSH
26270: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26274: LD_VAR 0 3
26278: PPUSH
26279: LD_INT 19
26281: PPUSH
26282: LD_INT 0
26284: PPUSH
26285: CALL_OW 49
// if JMMGirl = 1 then
26289: LD_EXP 7
26293: PUSH
26294: LD_INT 1
26296: EQUAL
26297: IFFALSE 26353
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26299: LD_ADDR_EXP 40
26303: PUSH
26304: LD_STRING Joan
26306: PPUSH
26307: LD_INT 1
26309: PPUSH
26310: LD_STRING 14_
26312: PPUSH
26313: CALL 64746 0 3
26317: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26318: LD_EXP 40
26322: PPUSH
26323: LD_VAR 0 3
26327: PPUSH
26328: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26332: LD_VAR 0 3
26336: PPUSH
26337: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26341: LD_EXP 40
26345: PPUSH
26346: LD_STRING D10BW-Joan-1
26348: PPUSH
26349: CALL_OW 94
// end ; if JMMGirl = 2 then
26353: LD_EXP 7
26357: PUSH
26358: LD_INT 2
26360: EQUAL
26361: IFFALSE 26417
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26363: LD_ADDR_EXP 42
26367: PUSH
26368: LD_STRING Lisa
26370: PPUSH
26371: LD_INT 1
26373: PPUSH
26374: LD_STRING 14_
26376: PPUSH
26377: CALL 64746 0 3
26381: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26382: LD_EXP 42
26386: PPUSH
26387: LD_VAR 0 3
26391: PPUSH
26392: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26396: LD_VAR 0 3
26400: PPUSH
26401: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26405: LD_EXP 42
26409: PPUSH
26410: LD_STRING D10BW-Lisa-1
26412: PPUSH
26413: CALL_OW 94
// end ; if JMMGirl = 3 then
26417: LD_EXP 7
26421: PUSH
26422: LD_INT 3
26424: EQUAL
26425: IFFALSE 26481
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26427: LD_ADDR_EXP 54
26431: PUSH
26432: LD_STRING Connie
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: LD_STRING 14_
26440: PPUSH
26441: CALL 64746 0 3
26445: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26446: LD_EXP 54
26450: PPUSH
26451: LD_VAR 0 3
26455: PPUSH
26456: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26460: LD_VAR 0 3
26464: PPUSH
26465: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26469: LD_EXP 54
26473: PPUSH
26474: LD_STRING D10BW-Con-1
26476: PPUSH
26477: CALL_OW 94
// end ; end ;
26481: PPOPN 3
26483: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26484: LD_EXP 14
26488: PUSH
26489: LD_INT 94500
26491: GREATEREQUAL
26492: IFFALSE 26904
26494: GO 26496
26496: DISABLE
26497: LD_INT 0
26499: PPUSH
26500: PPUSH
26501: PPUSH
// begin tmp := PrepareStevensSquad ;
26502: LD_ADDR_VAR 0 3
26506: PUSH
26507: CALL 2193 0 0
26511: ST_TO_ADDR
// if not tmp then
26512: LD_VAR 0 3
26516: NOT
26517: IFFALSE 26521
// exit ;
26519: GO 26904
// uc_side := 1 ;
26521: LD_ADDR_OWVAR 20
26525: PUSH
26526: LD_INT 1
26528: ST_TO_ADDR
// uc_nation := 1 ;
26529: LD_ADDR_OWVAR 21
26533: PUSH
26534: LD_INT 1
26536: ST_TO_ADDR
// for i in tmp do
26537: LD_ADDR_VAR 0 1
26541: PUSH
26542: LD_VAR 0 3
26546: PUSH
26547: FOR_IN
26548: IFFALSE 26645
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26550: LD_INT 3
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_INT 5
26561: PUSH
26562: LD_INT 9
26564: PUSH
26565: LD_INT 7
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 1
26575: PPUSH
26576: LD_INT 3
26578: PPUSH
26579: CALL_OW 12
26583: ARRAY
26584: PPUSH
26585: LD_INT 40
26587: PPUSH
26588: CALL 71861 0 5
// veh := CreateVehicle ;
26592: LD_ADDR_VAR 0 2
26596: PUSH
26597: CALL_OW 45
26601: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26602: LD_VAR 0 2
26606: PPUSH
26607: LD_INT 1
26609: PPUSH
26610: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26614: LD_VAR 0 2
26618: PPUSH
26619: LD_INT 19
26621: PPUSH
26622: LD_INT 0
26624: PPUSH
26625: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26629: LD_VAR 0 1
26633: PPUSH
26634: LD_VAR 0 2
26638: PPUSH
26639: CALL_OW 52
// end ;
26643: GO 26547
26645: POP
26646: POP
// missionStage := 8 ;
26647: LD_ADDR_EXP 15
26651: PUSH
26652: LD_INT 8
26654: ST_TO_ADDR
// DialogueOn ;
26655: CALL_OW 6
// if Stevens then
26659: LD_EXP 41
26663: IFFALSE 26777
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26665: LD_EXP 41
26669: PPUSH
26670: CALL_OW 310
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26679: LD_EXP 41
26683: PPUSH
26684: LD_STRING D8-Huck-1
26686: PPUSH
26687: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26691: LD_EXP 39
26695: PPUSH
26696: LD_STRING D8-JMM-1
26698: PPUSH
26699: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26703: LD_EXP 41
26707: PPUSH
26708: LD_STRING D8-Huck-2
26710: PPUSH
26711: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26715: LD_EXP 39
26719: PPUSH
26720: LD_STRING D8-JMM-2
26722: PPUSH
26723: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26727: LD_EXP 41
26731: PPUSH
26732: LD_STRING D8-Huck-3
26734: PPUSH
26735: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26739: LD_EXP 39
26743: PPUSH
26744: LD_STRING D8-JMM-3
26746: PPUSH
26747: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26751: LD_EXP 41
26755: PPUSH
26756: LD_STRING D8-Huck-4
26758: PPUSH
26759: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26763: LD_EXP 39
26767: PPUSH
26768: LD_STRING D8-JMM-4
26770: PPUSH
26771: CALL_OW 88
// end else
26775: GO 26887
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26777: LD_EXP 55
26781: PPUSH
26782: CALL_OW 310
26786: PPUSH
26787: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26791: LD_EXP 55
26795: PPUSH
26796: LD_STRING D8-Huck-1
26798: PPUSH
26799: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26803: LD_EXP 39
26807: PPUSH
26808: LD_STRING D8-JMM-1a
26810: PPUSH
26811: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26815: LD_EXP 55
26819: PPUSH
26820: LD_STRING D8-Huck-2
26822: PPUSH
26823: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26827: LD_EXP 39
26831: PPUSH
26832: LD_STRING D8-JMM-2
26834: PPUSH
26835: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26839: LD_EXP 55
26843: PPUSH
26844: LD_STRING D8-Huck-3
26846: PPUSH
26847: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26851: LD_EXP 39
26855: PPUSH
26856: LD_STRING D8-JMM-3
26858: PPUSH
26859: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26863: LD_EXP 55
26867: PPUSH
26868: LD_STRING D8-Huck-4
26870: PPUSH
26871: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26875: LD_EXP 39
26879: PPUSH
26880: LD_STRING D8-JMM-4
26882: PPUSH
26883: CALL_OW 88
// end ; DialogueOff ;
26887: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26891: LD_INT 25
26893: PPUSH
26894: LD_INT 1
26896: PPUSH
26897: LD_INT 1
26899: PPUSH
26900: CALL_OW 322
// end ;
26904: PPOPN 3
26906: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26907: LD_INT 1
26909: PPUSH
26910: LD_EXP 71
26914: PPUSH
26915: CALL_OW 292
26919: IFFALSE 27170
26921: GO 26923
26923: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26924: LD_EXP 71
26928: PPUSH
26929: CALL_OW 87
// DialogueOn ;
26933: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26937: LD_EXP 39
26941: PPUSH
26942: LD_STRING D10nB-JMM-1
26944: PPUSH
26945: CALL_OW 88
// if BurlakStatus = 1 then
26949: LD_EXP 9
26953: PUSH
26954: LD_INT 1
26956: EQUAL
26957: IFFALSE 26971
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26959: LD_EXP 70
26963: PPUSH
26964: LD_STRING D10nB-Vse-1a
26966: PPUSH
26967: CALL_OW 94
// end ; if BurlakStatus = 0 then
26971: LD_EXP 9
26975: PUSH
26976: LD_INT 0
26978: EQUAL
26979: IFFALSE 26993
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26981: LD_EXP 70
26985: PPUSH
26986: LD_STRING D10nB-Vse-1
26988: PPUSH
26989: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26993: LD_EXP 39
26997: PPUSH
26998: LD_STRING D10nB-JMM-2
27000: PPUSH
27001: CALL_OW 88
// if KappaStatus then
27005: LD_EXP 2
27009: IFFALSE 27023
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27011: LD_EXP 70
27015: PPUSH
27016: LD_STRING D10nB-Vse-5a
27018: PPUSH
27019: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27023: LD_EXP 2
27027: NOT
27028: PUSH
27029: LD_EXP 6
27033: PUSH
27034: LD_INT 0
27036: EQUAL
27037: AND
27038: IFFALSE 27166
// begin if JMMGirl = 1 then
27040: LD_EXP 7
27044: PUSH
27045: LD_INT 1
27047: EQUAL
27048: IFFALSE 27098
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27050: LD_EXP 70
27054: PPUSH
27055: LD_STRING D10nB-Vse-2
27057: PPUSH
27058: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27062: LD_EXP 39
27066: PPUSH
27067: LD_STRING D10nB-JMM-3
27069: PPUSH
27070: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27074: LD_EXP 70
27078: PPUSH
27079: LD_STRING D10nB-Vse-3
27081: PPUSH
27082: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27086: LD_EXP 39
27090: PPUSH
27091: LD_STRING D10nB-JMM-4
27093: PPUSH
27094: CALL_OW 88
// end ; if JMMGirl = 2 then
27098: LD_EXP 7
27102: PUSH
27103: LD_INT 2
27105: EQUAL
27106: IFFALSE 27132
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27108: LD_EXP 70
27112: PPUSH
27113: LD_STRING D10nB-Vse-4
27115: PPUSH
27116: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27120: LD_EXP 39
27124: PPUSH
27125: LD_STRING D10nB-JMM-5
27127: PPUSH
27128: CALL_OW 88
// end ; if JMMGirl = 3 then
27132: LD_EXP 7
27136: PUSH
27137: LD_INT 3
27139: EQUAL
27140: IFFALSE 27166
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27142: LD_EXP 70
27146: PPUSH
27147: LD_STRING D10nB-Vse-5
27149: PPUSH
27150: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27154: LD_EXP 39
27158: PPUSH
27159: LD_STRING D10nB-JMM-6
27161: PPUSH
27162: CALL_OW 88
// end ; end ; DialogueOff ;
27166: CALL_OW 7
// end ;
27170: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27171: LD_EXP 14
27175: PUSH
27176: LD_INT 115500
27178: GREATEREQUAL
27179: IFFALSE 27555
27181: GO 27183
27183: DISABLE
27184: LD_INT 0
27186: PPUSH
// begin missionStage := 10 ;
27187: LD_ADDR_EXP 15
27191: PUSH
27192: LD_INT 10
27194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27195: LD_ADDR_VAR 0 1
27199: PUSH
27200: LD_INT 22
27202: PUSH
27203: LD_INT 1
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 23
27212: PUSH
27213: LD_INT 1
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: LD_INT 26
27222: PUSH
27223: LD_INT 1
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 3
27232: PUSH
27233: LD_INT 25
27235: PUSH
27236: LD_INT 12
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: LD_INT 3
27249: PUSH
27250: LD_INT 25
27252: PUSH
27253: LD_INT 16
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: PPUSH
27271: CALL_OW 69
27275: PUSH
27276: LD_EXP 39
27280: PUSH
27281: LD_EXP 60
27285: PUSH
27286: LD_EXP 41
27290: PUSH
27291: LD_EXP 55
27295: PUSH
27296: LD_EXP 42
27300: PUSH
27301: LD_EXP 43
27305: PUSH
27306: LD_EXP 44
27310: PUSH
27311: LD_EXP 45
27315: PUSH
27316: LD_EXP 46
27320: PUSH
27321: LD_EXP 47
27325: PUSH
27326: LD_EXP 48
27330: PUSH
27331: LD_EXP 49
27335: PUSH
27336: LD_EXP 50
27340: PUSH
27341: LD_EXP 51
27345: PUSH
27346: LD_EXP 52
27350: PUSH
27351: LD_EXP 53
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: DIFF
27374: ST_TO_ADDR
// if not tmp and Brown then
27375: LD_VAR 0 1
27379: NOT
27380: PUSH
27381: LD_EXP 47
27385: AND
27386: IFFALSE 27401
// tmp := [ Brown ] ;
27388: LD_ADDR_VAR 0 1
27392: PUSH
27393: LD_EXP 47
27397: PUSH
27398: EMPTY
27399: LIST
27400: ST_TO_ADDR
// DialogueOn ;
27401: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27405: LD_VAR 0 1
27409: PUSH
27410: LD_INT 1
27412: ARRAY
27413: PPUSH
27414: LD_STRING D11-Sol1-1
27416: PPUSH
27417: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27421: LD_EXP 64
27425: PPUSH
27426: LD_STRING D11-Pla-1
27428: PPUSH
27429: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27433: LD_EXP 65
27437: PPUSH
27438: LD_STRING D11-Kov-1
27440: PPUSH
27441: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27445: LD_EXP 64
27449: PPUSH
27450: LD_STRING D11-Pla-2
27452: PPUSH
27453: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27457: LD_VAR 0 1
27461: PUSH
27462: LD_INT 1
27464: ARRAY
27465: PPUSH
27466: LD_STRING D11-Sol1-2
27468: PPUSH
27469: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27473: LD_EXP 39
27477: PPUSH
27478: LD_STRING D11-JMM-2
27480: PPUSH
27481: CALL_OW 88
// DialogueOff ;
27485: CALL_OW 7
// allowBehemothConstruct := true ;
27489: LD_ADDR_EXP 25
27493: PUSH
27494: LD_INT 1
27496: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27497: LD_STRING M4
27499: PPUSH
27500: CALL_OW 337
// BuildBehemoths ;
27504: CALL 7632 0 0
// repeat wait ( 15 15$00 ) ;
27508: LD_INT 31500
27510: PPUSH
27511: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27515: LD_EXP 27
27519: IFFALSE 27523
// break ;
27521: GO 27555
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27523: LD_INT 267
27525: PPUSH
27526: CALL_OW 274
27530: PPUSH
27531: LD_INT 1
27533: PPUSH
27534: CALL_OW 275
27538: PUSH
27539: LD_INT 1000
27541: GREATEREQUAL
27542: IFFALSE 27548
// BuildBehemoths ;
27544: CALL 7632 0 0
// until not behemothBuilders ;
27548: LD_EXP 73
27552: NOT
27553: IFFALSE 27508
// end ;
27555: PPOPN 1
27557: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27558: LD_EXP 73
27562: NOT
27563: PUSH
27564: LD_EXP 28
27568: NOT
27569: AND
27570: PUSH
27571: LD_EXP 25
27575: AND
27576: IFFALSE 27596
27578: GO 27580
27580: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27581: LD_STRING M4a
27583: PPUSH
27584: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27588: LD_ADDR_EXP 27
27592: PUSH
27593: LD_INT 1
27595: ST_TO_ADDR
// end ;
27596: END
// every 0 0$1 trigger behemothDone do
27597: LD_EXP 28
27601: IFFALSE 27613
27603: GO 27605
27605: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27606: LD_STRING M4b
27608: PPUSH
27609: CALL_OW 337
27613: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27614: LD_EXP 29
27618: NOT
27619: IFFALSE 27815
27621: GO 27623
27623: DISABLE
27624: LD_INT 0
27626: PPUSH
27627: PPUSH
// begin enable ;
27628: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27629: LD_ADDR_VAR 0 1
27633: PUSH
27634: LD_INT 3
27636: PPUSH
27637: CALL 107657 0 1
27641: ST_TO_ADDR
// if not tmp and not behemothDone then
27642: LD_VAR 0 1
27646: NOT
27647: PUSH
27648: LD_EXP 28
27652: NOT
27653: AND
27654: IFFALSE 27690
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27656: LD_ADDR_VAR 0 1
27660: PUSH
27661: LD_INT 22
27663: PUSH
27664: LD_INT 3
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PUSH
27671: LD_INT 30
27673: PUSH
27674: LD_INT 37
27676: PUSH
27677: EMPTY
27678: LIST
27679: LIST
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PPUSH
27685: CALL_OW 69
27689: ST_TO_ADDR
// if not tmp then
27690: LD_VAR 0 1
27694: NOT
27695: IFFALSE 27699
// exit ;
27697: GO 27815
// for i in tmp do
27699: LD_ADDR_VAR 0 2
27703: PUSH
27704: LD_VAR 0 1
27708: PUSH
27709: FOR_IN
27710: IFFALSE 27813
// if See ( 1 , i ) then
27712: LD_INT 1
27714: PPUSH
27715: LD_VAR 0 2
27719: PPUSH
27720: CALL_OW 292
27724: IFFALSE 27811
// begin if GetType ( i ) = unit_building then
27726: LD_VAR 0 2
27730: PPUSH
27731: CALL_OW 247
27735: PUSH
27736: LD_INT 3
27738: EQUAL
27739: IFFALSE 27777
// begin CenterNowOnUnits ( i ) ;
27741: LD_VAR 0 2
27745: PPUSH
27746: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27750: LD_EXP 39
27754: PPUSH
27755: LD_STRING D17a-JMM-1
27757: PPUSH
27758: CALL_OW 88
// seeBehemoth := true ;
27762: LD_ADDR_EXP 29
27766: PUSH
27767: LD_INT 1
27769: ST_TO_ADDR
// disable ;
27770: DISABLE
// exit ;
27771: POP
27772: POP
27773: GO 27815
// end else
27775: GO 27811
// begin CenterNowOnUnits ( i ) ;
27777: LD_VAR 0 2
27781: PPUSH
27782: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27786: LD_EXP 39
27790: PPUSH
27791: LD_STRING D17b-JMM-1
27793: PPUSH
27794: CALL_OW 88
// seeBehemoth := true ;
27798: LD_ADDR_EXP 29
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// disable ;
27806: DISABLE
// exit ;
27807: POP
27808: POP
27809: GO 27815
// end ; end ;
27811: GO 27709
27813: POP
27814: POP
// end ;
27815: PPOPN 2
27817: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27818: LD_EXP 14
27822: PUSH
27823: LD_INT 116550
27825: GREATEREQUAL
27826: IFFALSE 29002
27828: GO 27830
27830: DISABLE
27831: LD_INT 0
27833: PPUSH
27834: PPUSH
27835: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27836: LD_INT 2
27838: PPUSH
27839: LD_INT 23
27841: PUSH
27842: LD_INT 3
27844: PUSH
27845: LD_INT 3
27847: PUSH
27848: LD_INT 48
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: LIST
27855: LIST
27856: PUSH
27857: EMPTY
27858: LIST
27859: PPUSH
27860: CALL 58402 0 2
// repeat wait ( 0 0$1 ) ;
27864: LD_INT 35
27866: PPUSH
27867: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 34
27883: PUSH
27884: LD_INT 48
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: IFFALSE 27864
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27901: LD_ADDR_VAR 0 1
27905: PUSH
27906: LD_INT 22
27908: PUSH
27909: LD_INT 3
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 34
27918: PUSH
27919: LD_INT 48
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PPUSH
27930: CALL_OW 69
27934: PUSH
27935: LD_INT 1
27937: ARRAY
27938: ST_TO_ADDR
// missionStage := 12 ;
27939: LD_ADDR_EXP 15
27943: PUSH
27944: LD_INT 12
27946: ST_TO_ADDR
// platonovHasBomb := true ;
27947: LD_ADDR_EXP 30
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27955: LD_VAR 0 1
27959: PPUSH
27960: LD_INT 181
27962: PPUSH
27963: LD_INT 86
27965: PPUSH
27966: CALL_OW 171
// AddComHold ( bomb ) ;
27970: LD_VAR 0 1
27974: PPUSH
27975: CALL_OW 200
// wait ( 0 0$10 ) ;
27979: LD_INT 350
27981: PPUSH
27982: CALL_OW 67
// DialogueOn ;
27986: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27990: LD_EXP 64
27994: PPUSH
27995: LD_STRING D15-Pla-1
27997: PPUSH
27998: CALL_OW 94
// dec = Query ( Q15a ) ;
28002: LD_ADDR_VAR 0 2
28006: PUSH
28007: LD_STRING Q15a
28009: PPUSH
28010: CALL_OW 97
28014: ST_TO_ADDR
// if dec = 1 then
28015: LD_VAR 0 2
28019: PUSH
28020: LD_INT 1
28022: EQUAL
28023: IFFALSE 28046
// begin Say ( JMM , D15a-JMM-1 ) ;
28025: LD_EXP 39
28029: PPUSH
28030: LD_STRING D15a-JMM-1
28032: PPUSH
28033: CALL_OW 88
// YouLost ( Surrender ) ;
28037: LD_STRING Surrender
28039: PPUSH
28040: CALL_OW 104
// exit ;
28044: GO 29002
// end ; if dec = 2 then
28046: LD_VAR 0 2
28050: PUSH
28051: LD_INT 2
28053: EQUAL
28054: IFFALSE 28123
// begin Say ( JMM , D15b-JMM-1 ) ;
28056: LD_EXP 39
28060: PPUSH
28061: LD_STRING D15b-JMM-1
28063: PPUSH
28064: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28068: LD_EXP 64
28072: PPUSH
28073: LD_STRING D15b-Pla-1
28075: PPUSH
28076: CALL_OW 94
// DialogueOff ;
28080: CALL_OW 7
// wait ( 3 3$00 ) ;
28084: LD_INT 6300
28086: PPUSH
28087: CALL_OW 67
// DialogueOn ;
28091: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28095: LD_EXP 39
28099: PPUSH
28100: LD_STRING D15d-JMM-1a
28102: PPUSH
28103: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28107: LD_EXP 64
28111: PPUSH
28112: LD_STRING D15d-Pla-1
28114: PPUSH
28115: CALL_OW 94
// DialogueOff ;
28119: CALL_OW 7
// end ; if dec = 3 then
28123: LD_VAR 0 2
28127: PUSH
28128: LD_INT 3
28130: EQUAL
28131: IFFALSE 28185
// begin Say ( JMM , D15c-JMM-1 ) ;
28133: LD_EXP 39
28137: PPUSH
28138: LD_STRING D15c-JMM-1
28140: PPUSH
28141: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28145: LD_EXP 64
28149: PPUSH
28150: LD_STRING D15c-Pla-1
28152: PPUSH
28153: CALL_OW 94
// DialogueOff ;
28157: CALL_OW 7
// wait ( 0 0$15 ) ;
28161: LD_INT 525
28163: PPUSH
28164: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28168: LD_VAR 0 1
28172: PPUSH
28173: LD_INT 60
28175: PPUSH
28176: LD_INT 95
28178: PPUSH
28179: CALL_OW 116
// exit ;
28183: GO 29002
// end ; if dec = 4 then
28185: LD_VAR 0 2
28189: PUSH
28190: LD_INT 4
28192: EQUAL
28193: IFFALSE 28223
// begin Say ( JMM , D15d-JMM-1 ) ;
28195: LD_EXP 39
28199: PPUSH
28200: LD_STRING D15d-JMM-1
28202: PPUSH
28203: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28207: LD_EXP 64
28211: PPUSH
28212: LD_STRING D15d-Pla-1
28214: PPUSH
28215: CALL_OW 94
// DialogueOff ;
28219: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28223: LD_EXP 62
28227: PPUSH
28228: CALL_OW 302
28232: PUSH
28233: LD_EXP 62
28237: PPUSH
28238: CALL_OW 255
28242: PUSH
28243: LD_INT 1
28245: EQUAL
28246: AND
28247: PUSH
28248: LD_INT 22
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 34
28260: PUSH
28261: LD_INT 8
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: EMPTY
28269: LIST
28270: LIST
28271: PPUSH
28272: CALL_OW 69
28276: NOT
28277: AND
28278: IFFALSE 28903
// begin SetSide ( Friend , 8 ) ;
28280: LD_EXP 62
28284: PPUSH
28285: LD_INT 8
28287: PPUSH
28288: CALL_OW 235
// if IsInUnit ( Friend ) then
28292: LD_EXP 62
28296: PPUSH
28297: CALL_OW 310
28301: IFFALSE 28312
// ComExitBuilding ( Friend ) ;
28303: LD_EXP 62
28307: PPUSH
28308: CALL_OW 122
// if IsDriver ( Friend ) then
28312: LD_EXP 62
28316: PPUSH
28317: CALL 105334 0 1
28321: IFFALSE 28332
// ComExitVehicle ( Friend ) ;
28323: LD_EXP 62
28327: PPUSH
28328: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28332: LD_EXP 62
28336: PPUSH
28337: LD_INT 9
28339: PPUSH
28340: LD_INT 2
28342: PPUSH
28343: CALL_OW 171
// wait ( 0 0$05 ) ;
28347: LD_INT 175
28349: PPUSH
28350: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28354: LD_EXP 62
28358: PPUSH
28359: CALL_OW 87
// DialogueOn ;
28363: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28367: LD_EXP 39
28371: PPUSH
28372: LD_STRING D16-JMM-1
28374: PPUSH
28375: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28379: LD_EXP 62
28383: PPUSH
28384: LD_STRING D16-Friend-1
28386: PPUSH
28387: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28391: LD_EXP 39
28395: PPUSH
28396: LD_STRING D16-JMM-2
28398: PPUSH
28399: CALL_OW 88
// DialogueOff ;
28403: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28407: LD_EXP 62
28411: PPUSH
28412: LD_INT 1
28414: PPUSH
28415: CALL_OW 235
// ComHold ( Friend ) ;
28419: LD_EXP 62
28423: PPUSH
28424: CALL_OW 140
// wait ( 0 0$20 ) ;
28428: LD_INT 700
28430: PPUSH
28431: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28435: LD_EXP 62
28439: PPUSH
28440: LD_INT 9
28442: PPUSH
28443: LD_INT 2
28445: PPUSH
28446: CALL_OW 297
28450: PUSH
28451: LD_INT 30
28453: LESS
28454: IFFALSE 28523
// begin SetSide ( Friend , 8 ) ;
28456: LD_EXP 62
28460: PPUSH
28461: LD_INT 8
28463: PPUSH
28464: CALL_OW 235
// if IsInUnit ( Friend ) then
28468: LD_EXP 62
28472: PPUSH
28473: CALL_OW 310
28477: IFFALSE 28488
// ComExitBuilding ( Friend ) ;
28479: LD_EXP 62
28483: PPUSH
28484: CALL_OW 122
// if IsDriver ( Friend ) then
28488: LD_EXP 62
28492: PPUSH
28493: CALL 105334 0 1
28497: IFFALSE 28508
// ComExitVehicle ( Friend ) ;
28499: LD_EXP 62
28503: PPUSH
28504: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28508: LD_EXP 62
28512: PPUSH
28513: LD_INT 9
28515: PPUSH
28516: LD_INT 2
28518: PPUSH
28519: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28523: LD_INT 1050
28525: PPUSH
28526: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28530: LD_INT 22
28532: PUSH
28533: LD_INT 1
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PUSH
28540: LD_INT 34
28542: PUSH
28543: LD_INT 8
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PPUSH
28554: CALL_OW 69
28558: NOT
28559: IFFALSE 28881
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28561: LD_ADDR_VAR 0 3
28565: PUSH
28566: LD_INT 22
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 26
28578: PUSH
28579: LD_INT 1
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 3
28588: PUSH
28589: LD_INT 25
28591: PUSH
28592: LD_INT 12
28594: PUSH
28595: EMPTY
28596: LIST
28597: LIST
28598: PUSH
28599: LD_INT 25
28601: PUSH
28602: LD_INT 16
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: LIST
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: LIST
28618: PPUSH
28619: CALL_OW 69
28623: PUSH
28624: LD_EXP 39
28628: PUSH
28629: LD_EXP 41
28633: PUSH
28634: LD_EXP 55
28638: PUSH
28639: LD_EXP 42
28643: PUSH
28644: LD_EXP 43
28648: PUSH
28649: LD_EXP 44
28653: PUSH
28654: LD_EXP 45
28658: PUSH
28659: LD_EXP 46
28663: PUSH
28664: LD_EXP 47
28668: PUSH
28669: LD_EXP 48
28673: PUSH
28674: LD_EXP 49
28678: PUSH
28679: LD_EXP 50
28683: PUSH
28684: LD_EXP 51
28688: PUSH
28689: LD_EXP 52
28693: PUSH
28694: LD_EXP 53
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: DIFF
28716: ST_TO_ADDR
// DialogueOn ;
28717: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28721: LD_EXP 64
28725: PPUSH
28726: LD_STRING D16a-Pla-1
28728: PPUSH
28729: CALL_OW 94
// if Stevens then
28733: LD_EXP 41
28737: IFFALSE 28753
// Say ( Stevens , D16a-Huck-1 ) else
28739: LD_EXP 41
28743: PPUSH
28744: LD_STRING D16a-Huck-1
28746: PPUSH
28747: CALL_OW 88
28751: GO 28795
// if Baker then
28753: LD_EXP 55
28757: IFFALSE 28773
// Say ( Baker , D16a-Huck-1 ) else
28759: LD_EXP 55
28763: PPUSH
28764: LD_STRING D16a-Huck-1
28766: PPUSH
28767: CALL_OW 88
28771: GO 28795
// if tmp then
28773: LD_VAR 0 3
28777: IFFALSE 28795
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28779: LD_VAR 0 3
28783: PUSH
28784: LD_INT 1
28786: ARRAY
28787: PPUSH
28788: LD_STRING D16a-Sol1-1
28790: PPUSH
28791: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28795: LD_EXP 62
28799: PPUSH
28800: CALL_OW 255
28804: PUSH
28805: LD_INT 8
28807: EQUAL
28808: IFFALSE 28824
// Say ( JMM , D16a-JMM-1 ) else
28810: LD_EXP 39
28814: PPUSH
28815: LD_STRING D16a-JMM-1
28817: PPUSH
28818: CALL_OW 88
28822: GO 28860
// begin Say ( JMM , D16a-JMM-1a ) ;
28824: LD_EXP 39
28828: PPUSH
28829: LD_STRING D16a-JMM-1a
28831: PPUSH
28832: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28836: LD_EXP 62
28840: PPUSH
28841: LD_STRING D16a-Friend-1
28843: PPUSH
28844: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28848: LD_EXP 62
28852: PPUSH
28853: LD_INT 3
28855: PPUSH
28856: CALL_OW 235
// end ; DialogueOff ;
28860: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28864: LD_VAR 0 1
28868: PPUSH
28869: LD_INT 60
28871: PPUSH
28872: LD_INT 95
28874: PPUSH
28875: CALL_OW 116
// end else
28879: GO 28901
// begin DialogueOn ;
28881: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28885: LD_EXP 64
28889: PPUSH
28890: LD_STRING D16c-Pla-
28892: PPUSH
28893: CALL_OW 94
// DialogueOff ;
28897: CALL_OW 7
// end ; end else
28901: GO 29002
// begin wait ( 3 3$00 ) ;
28903: LD_INT 6300
28905: PPUSH
28906: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28910: LD_INT 22
28912: PUSH
28913: LD_INT 1
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 34
28922: PUSH
28923: LD_INT 8
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PPUSH
28934: CALL_OW 69
28938: NOT
28939: IFFALSE 28982
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28941: LD_EXP 64
28945: PPUSH
28946: LD_STRING D16b-Pla-1
28948: PPUSH
28949: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28953: LD_EXP 39
28957: PPUSH
28958: LD_STRING D16b-JMM-
28960: PPUSH
28961: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28965: LD_VAR 0 1
28969: PPUSH
28970: LD_INT 60
28972: PPUSH
28973: LD_INT 95
28975: PPUSH
28976: CALL_OW 116
// end else
28980: GO 29002
// begin DialogueOn ;
28982: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28986: LD_EXP 64
28990: PPUSH
28991: LD_STRING D16c-Pla-
28993: PPUSH
28994: CALL_OW 94
// DialogueOff ;
28998: CALL_OW 7
// end ; end ; end ;
29002: PPOPN 3
29004: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29005: LD_EXP 14
29009: PUSH
29010: LD_INT 126000
29012: GREATEREQUAL
29013: PUSH
29014: LD_EXP 23
29018: NOT
29019: AND
29020: PUSH
29021: LD_EXP 74
29025: PPUSH
29026: CALL_OW 302
29030: AND
29031: IFFALSE 29389
29033: GO 29035
29035: DISABLE
29036: LD_INT 0
29038: PPUSH
// begin missionStage = 11 ;
29039: LD_ADDR_EXP 15
29043: PUSH
29044: LD_INT 11
29046: ST_TO_ADDR
// DialogueOn ;
29047: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29051: LD_EXP 74
29055: PPUSH
29056: LD_STRING D9-Roth-1
29058: PPUSH
29059: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29063: LD_EXP 39
29067: PPUSH
29068: LD_STRING D9-JMM-1
29070: PPUSH
29071: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29075: LD_EXP 74
29079: PPUSH
29080: LD_STRING D9-Roth-2
29082: PPUSH
29083: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29087: LD_EXP 74
29091: PPUSH
29092: LD_STRING D9-Roth-2a
29094: PPUSH
29095: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29099: LD_EXP 64
29103: PPUSH
29104: LD_STRING D9-Pla-2
29106: PPUSH
29107: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29111: LD_EXP 74
29115: PPUSH
29116: LD_STRING D9-Roth-3
29118: PPUSH
29119: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29123: LD_EXP 64
29127: PPUSH
29128: LD_STRING D9-Pla-3
29130: PPUSH
29131: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29135: LD_EXP 74
29139: PPUSH
29140: LD_STRING D9-Roth-4
29142: PPUSH
29143: CALL_OW 94
// dec = Query ( Q9 ) ;
29147: LD_ADDR_VAR 0 1
29151: PUSH
29152: LD_STRING Q9
29154: PPUSH
29155: CALL_OW 97
29159: ST_TO_ADDR
// if dec = 1 then
29160: LD_VAR 0 1
29164: PUSH
29165: LD_INT 1
29167: EQUAL
29168: IFFALSE 29182
// SayRadio ( Roth , D9a-Roth-1 ) ;
29170: LD_EXP 74
29174: PPUSH
29175: LD_STRING D9a-Roth-1
29177: PPUSH
29178: CALL_OW 94
// if dec = 2 then
29182: LD_VAR 0 1
29186: PUSH
29187: LD_INT 2
29189: EQUAL
29190: IFFALSE 29216
// begin Say ( JMM , D9b-JMM-1 ) ;
29192: LD_EXP 39
29196: PPUSH
29197: LD_STRING D9b-JMM-1
29199: PPUSH
29200: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29204: LD_EXP 74
29208: PPUSH
29209: LD_STRING D9b-Roth-1
29211: PPUSH
29212: CALL_OW 94
// end ; if dec = 3 then
29216: LD_VAR 0 1
29220: PUSH
29221: LD_INT 3
29223: EQUAL
29224: IFFALSE 29286
// begin Say ( JMM , D9c-JMM-1 ) ;
29226: LD_EXP 39
29230: PPUSH
29231: LD_STRING D9c-JMM-1
29233: PPUSH
29234: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29238: LD_EXP 74
29242: PPUSH
29243: LD_STRING D9c-Roth-1
29245: PPUSH
29246: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29250: LD_EXP 39
29254: PPUSH
29255: LD_STRING D9c-JMM-2
29257: PPUSH
29258: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29262: LD_EXP 74
29266: PPUSH
29267: LD_STRING D9c-Roth-2
29269: PPUSH
29270: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29274: LD_EXP 39
29278: PPUSH
29279: LD_STRING D9c-JMM-3
29281: PPUSH
29282: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29286: LD_EXP 74
29290: PPUSH
29291: LD_STRING D9c-Roth-3
29293: PPUSH
29294: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29298: LD_EXP 74
29302: PPUSH
29303: LD_STRING D9cont-Roth-1
29305: PPUSH
29306: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29310: LD_EXP 39
29314: PPUSH
29315: LD_STRING D9cont-JMM-1
29317: PPUSH
29318: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29322: LD_EXP 74
29326: PPUSH
29327: LD_STRING D9cont-Roth-2
29329: PPUSH
29330: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29334: LD_EXP 39
29338: PPUSH
29339: LD_STRING D9cont-JMM-2
29341: PPUSH
29342: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29346: LD_EXP 74
29350: PPUSH
29351: LD_STRING D9cont-Roth-3
29353: PPUSH
29354: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29358: LD_EXP 39
29362: PPUSH
29363: LD_STRING D9cont-JMM-3
29365: PPUSH
29366: CALL_OW 88
// DialogueOff ;
29370: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29374: LD_STRING M3
29376: PPUSH
29377: CALL_OW 337
// allianceActive := true ;
29381: LD_ADDR_EXP 31
29385: PUSH
29386: LD_INT 1
29388: ST_TO_ADDR
// end ;
29389: PPOPN 1
29391: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29392: LD_EXP 64
29396: PPUSH
29397: CALL_OW 301
29401: PUSH
29402: LD_EXP 67
29406: PPUSH
29407: CALL_OW 301
29411: AND
29412: PUSH
29413: LD_INT 22
29415: PUSH
29416: LD_INT 3
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 21
29425: PUSH
29426: LD_INT 1
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: PUSH
29433: LD_INT 50
29435: PUSH
29436: EMPTY
29437: LIST
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: LIST
29443: PPUSH
29444: CALL_OW 69
29448: PUSH
29449: LD_INT 7
29451: PUSH
29452: LD_INT 8
29454: PUSH
29455: LD_INT 9
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: LIST
29462: PUSH
29463: LD_OWVAR 67
29467: ARRAY
29468: LESS
29469: AND
29470: IFFALSE 30241
29472: GO 29474
29474: DISABLE
29475: LD_INT 0
29477: PPUSH
29478: PPUSH
29479: PPUSH
29480: PPUSH
// begin MC_Kill ( 1 ) ;
29481: LD_INT 1
29483: PPUSH
29484: CALL 34942 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29488: LD_INT 1
29490: PPUSH
29491: LD_INT 3
29493: PPUSH
29494: LD_INT 1
29496: PPUSH
29497: LD_INT 1
29499: PPUSH
29500: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29504: LD_ADDR_VAR 0 1
29508: PUSH
29509: LD_INT 22
29511: PUSH
29512: LD_INT 3
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 21
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 24
29531: PUSH
29532: LD_INT 900
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: PPUSH
29544: CALL_OW 69
29548: PUSH
29549: FOR_IN
29550: IFFALSE 29581
// if GetSex ( i ) = sex_male then
29552: LD_VAR 0 1
29556: PPUSH
29557: CALL_OW 258
29561: PUSH
29562: LD_INT 1
29564: EQUAL
29565: IFFALSE 29579
// begin tmp = i ;
29567: LD_ADDR_VAR 0 2
29571: PUSH
29572: LD_VAR 0 1
29576: ST_TO_ADDR
// break ;
29577: GO 29581
// end ;
29579: GO 29549
29581: POP
29582: POP
// if tmp = 0 then
29583: LD_VAR 0 2
29587: PUSH
29588: LD_INT 0
29590: EQUAL
29591: IFFALSE 29645
// begin uc_side = 3 ;
29593: LD_ADDR_OWVAR 20
29597: PUSH
29598: LD_INT 3
29600: ST_TO_ADDR
// uc_nation = 3 ;
29601: LD_ADDR_OWVAR 21
29605: PUSH
29606: LD_INT 3
29608: ST_TO_ADDR
// hc_name =  ;
29609: LD_ADDR_OWVAR 26
29613: PUSH
29614: LD_STRING 
29616: ST_TO_ADDR
// hc_gallery =  ;
29617: LD_ADDR_OWVAR 33
29621: PUSH
29622: LD_STRING 
29624: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29625: LD_INT 1
29627: PPUSH
29628: LD_INT 10
29630: PPUSH
29631: CALL_OW 381
// tmp = CreateHuman ;
29635: LD_ADDR_VAR 0 2
29639: PUSH
29640: CALL_OW 44
29644: ST_TO_ADDR
// end ; DialogueOn ;
29645: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29649: LD_VAR 0 2
29653: PPUSH
29654: LD_STRING DSurrenderRussians-RSol1-1a
29656: PPUSH
29657: CALL_OW 94
// DialogueOff ;
29661: CALL_OW 7
// russianDestroyed := true ;
29665: LD_ADDR_EXP 21
29669: PUSH
29670: LD_INT 1
29672: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29673: LD_INT 22
29675: PUSH
29676: LD_INT 3
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 21
29685: PUSH
29686: LD_INT 1
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PPUSH
29697: CALL_OW 69
29701: PPUSH
29702: CALL_OW 122
// wait ( 0 0$1 ) ;
29706: LD_INT 35
29708: PPUSH
29709: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29713: LD_INT 22
29715: PUSH
29716: LD_INT 3
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 21
29725: PUSH
29726: LD_INT 1
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PPUSH
29737: CALL_OW 69
29741: PPUSH
29742: LD_INT 25
29744: PPUSH
29745: CALL_OW 173
// wait ( 0 0$10 ) ;
29749: LD_INT 350
29751: PPUSH
29752: CALL_OW 67
// PrepareOmarInvasion ;
29756: CALL 13752 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29760: LD_ADDR_VAR 0 2
29764: PUSH
29765: LD_EXP 92
29769: PPUSH
29770: CALL_OW 250
29774: PUSH
29775: LD_EXP 92
29779: PPUSH
29780: CALL_OW 251
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29789: LD_VAR 0 2
29793: PUSH
29794: LD_INT 1
29796: ARRAY
29797: PPUSH
29798: LD_VAR 0 2
29802: PUSH
29803: LD_INT 2
29805: ARRAY
29806: PPUSH
29807: LD_INT 1
29809: PPUSH
29810: LD_INT 8
29812: NEG
29813: PPUSH
29814: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29818: LD_EXP 92
29822: PPUSH
29823: CALL_OW 87
// DialogueOn ;
29827: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29831: LD_EXP 39
29835: PPUSH
29836: LD_STRING D19-JMM-1
29838: PPUSH
29839: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29843: LD_ADDR_VAR 0 3
29847: PUSH
29848: LD_INT 22
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 26
29860: PUSH
29861: LD_INT 1
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: PUSH
29871: LD_INT 25
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 25
29883: PUSH
29884: LD_INT 2
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 25
29893: PUSH
29894: LD_INT 3
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 25
29903: PUSH
29904: LD_INT 4
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 25
29913: PUSH
29914: LD_INT 5
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 25
29923: PUSH
29924: LD_INT 8
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: LIST
29944: PPUSH
29945: CALL_OW 69
29949: PUSH
29950: LD_EXP 39
29954: PUSH
29955: LD_EXP 40
29959: PUSH
29960: LD_EXP 41
29964: PUSH
29965: LD_EXP 42
29969: PUSH
29970: LD_EXP 43
29974: PUSH
29975: LD_EXP 44
29979: PUSH
29980: LD_EXP 45
29984: PUSH
29985: LD_EXP 46
29989: PUSH
29990: LD_EXP 47
29994: PUSH
29995: LD_EXP 48
29999: PUSH
30000: LD_EXP 49
30004: PUSH
30005: LD_EXP 50
30009: PUSH
30010: LD_EXP 51
30014: PUSH
30015: LD_EXP 52
30019: PUSH
30020: LD_EXP 53
30024: PUSH
30025: LD_EXP 54
30029: PUSH
30030: LD_EXP 55
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: DIFF
30054: ST_TO_ADDR
// if tmp2 then
30055: LD_VAR 0 3
30059: IFFALSE 30077
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30061: LD_VAR 0 3
30065: PUSH
30066: LD_INT 1
30068: ARRAY
30069: PPUSH
30070: LD_STRING D19-Sol1-1
30072: PPUSH
30073: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30077: LD_EXP 39
30081: PPUSH
30082: LD_STRING D19-JMM-2
30084: PPUSH
30085: CALL_OW 88
// DialogueOff ;
30089: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30093: LD_VAR 0 2
30097: PUSH
30098: LD_INT 1
30100: ARRAY
30101: PPUSH
30102: LD_VAR 0 2
30106: PUSH
30107: LD_INT 2
30109: ARRAY
30110: PPUSH
30111: LD_INT 1
30113: PPUSH
30114: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30118: LD_STRING M5
30120: PPUSH
30121: CALL_OW 337
// omarOnMotherLode := false ;
30125: LD_ADDR_VAR 0 4
30129: PUSH
30130: LD_INT 0
30132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30133: LD_INT 35
30135: PPUSH
30136: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30140: LD_EXP 92
30144: PPUSH
30145: LD_INT 215
30147: PPUSH
30148: LD_INT 100
30150: PPUSH
30151: CALL_OW 297
30155: PUSH
30156: LD_INT 10
30158: LESS
30159: PUSH
30160: LD_VAR 0 4
30164: NOT
30165: AND
30166: IFFALSE 30200
// begin omarOnMotherLode := true ;
30168: LD_ADDR_VAR 0 4
30172: PUSH
30173: LD_INT 1
30175: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30176: LD_EXP 39
30180: PPUSH
30181: LD_STRING D19b-JMM-1
30183: PPUSH
30184: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30188: LD_EXP 92
30192: PPUSH
30193: LD_STRING DOmarContam-Omar-1
30195: PPUSH
30196: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30200: LD_EXP 92
30204: PPUSH
30205: CALL_OW 301
30209: IFFALSE 30133
// Say ( JMM , D19a-JMM-1 ) ;
30211: LD_EXP 39
30215: PPUSH
30216: LD_STRING D19a-JMM-1
30218: PPUSH
30219: CALL_OW 88
// if Heike then
30223: LD_EXP 93
30227: IFFALSE 30241
// Say ( Heike , D19a-Hke-1 ) ;
30229: LD_EXP 93
30233: PPUSH
30234: LD_STRING D19a-Hke-1
30236: PPUSH
30237: CALL_OW 88
// end ;
30241: PPOPN 4
30243: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30244: LD_INT 22
30246: PUSH
30247: LD_INT 3
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 21
30256: PUSH
30257: LD_INT 1
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PPUSH
30268: CALL_OW 69
30272: PUSH
30273: LD_EXP 21
30277: AND
30278: IFFALSE 30346
30280: GO 30282
30282: DISABLE
30283: LD_INT 0
30285: PPUSH
30286: PPUSH
// begin enable ;
30287: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30288: LD_ADDR_VAR 0 2
30292: PUSH
30293: LD_INT 25
30295: PPUSH
30296: LD_INT 22
30298: PUSH
30299: LD_INT 3
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PPUSH
30306: CALL_OW 70
30310: ST_TO_ADDR
// if not tmp then
30311: LD_VAR 0 2
30315: NOT
30316: IFFALSE 30320
// exit ;
30318: GO 30346
// for i in tmp do
30320: LD_ADDR_VAR 0 1
30324: PUSH
30325: LD_VAR 0 2
30329: PUSH
30330: FOR_IN
30331: IFFALSE 30344
// RemoveUnit ( i ) ;
30333: LD_VAR 0 1
30337: PPUSH
30338: CALL_OW 64
30342: GO 30330
30344: POP
30345: POP
// end ;
30346: PPOPN 2
30348: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30349: LD_INT 22
30351: PUSH
30352: LD_INT 7
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 21
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PPUSH
30373: CALL_OW 69
30377: PUSH
30378: LD_INT 6
30380: LESS
30381: IFFALSE 30849
30383: GO 30385
30385: DISABLE
30386: LD_INT 0
30388: PPUSH
30389: PPUSH
// begin MC_Kill ( 1 ) ;
30390: LD_INT 1
30392: PPUSH
30393: CALL 34942 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30397: LD_INT 7
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: LD_INT 1
30405: PPUSH
30406: LD_INT 1
30408: PPUSH
30409: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30413: LD_ADDR_VAR 0 1
30417: PUSH
30418: LD_INT 22
30420: PUSH
30421: LD_INT 7
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 26
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PPUSH
30442: CALL_OW 69
30446: PUSH
30447: LD_EXP 74
30451: DIFF
30452: ST_TO_ADDR
// if tmp then
30453: LD_VAR 0 1
30457: IFFALSE 30475
// tmp := tmp [ 1 ] else
30459: LD_ADDR_VAR 0 1
30463: PUSH
30464: LD_VAR 0 1
30468: PUSH
30469: LD_INT 1
30471: ARRAY
30472: ST_TO_ADDR
30473: GO 30511
// begin uc_side := 7 ;
30475: LD_ADDR_OWVAR 20
30479: PUSH
30480: LD_INT 7
30482: ST_TO_ADDR
// uc_nation := 1 ;
30483: LD_ADDR_OWVAR 21
30487: PUSH
30488: LD_INT 1
30490: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30491: LD_INT 1
30493: PPUSH
30494: LD_INT 8
30496: PPUSH
30497: CALL_OW 384
// tmp := CreateHuman ;
30501: LD_ADDR_VAR 0 1
30505: PUSH
30506: CALL_OW 44
30510: ST_TO_ADDR
// end ; DialogueOn ;
30511: CALL_OW 6
// if IsOK ( Roth ) then
30515: LD_EXP 74
30519: PPUSH
30520: CALL_OW 302
30524: IFFALSE 30538
// Say ( JMM , DAb-JMM-1 ) ;
30526: LD_EXP 39
30530: PPUSH
30531: LD_STRING DAb-JMM-1
30533: PPUSH
30534: CALL_OW 88
// if IsOK ( Roth ) then
30538: LD_EXP 74
30542: PPUSH
30543: CALL_OW 302
30547: IFFALSE 30571
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30549: LD_EXP 74
30553: PPUSH
30554: LD_STRING DSurrenderAlliance-Roth-1
30556: PPUSH
30557: CALL_OW 88
// RothCaptured := true ;
30561: LD_ADDR_EXP 33
30565: PUSH
30566: LD_INT 1
30568: ST_TO_ADDR
// end else
30569: GO 30583
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30571: LD_VAR 0 1
30575: PPUSH
30576: LD_STRING DSurrenderAlliance-Sci1-1
30578: PPUSH
30579: CALL_OW 88
// DialogueOff ;
30583: CALL_OW 7
// allianceDestroyed := true ;
30587: LD_ADDR_EXP 23
30591: PUSH
30592: LD_INT 1
30594: ST_TO_ADDR
// if capturedUnit = 0 then
30595: LD_EXP 34
30599: PUSH
30600: LD_INT 0
30602: EQUAL
30603: IFFALSE 30612
// SetAchievement ( ACH_ALLIANCE ) ;
30605: LD_STRING ACH_ALLIANCE
30607: PPUSH
30608: CALL_OW 543
// if trueAmericans then
30612: LD_EXP 35
30616: IFFALSE 30692
// begin if trueAmericans = 1 then
30618: LD_EXP 35
30622: PUSH
30623: LD_INT 1
30625: EQUAL
30626: IFFALSE 30642
// Say ( JMM , DAb-JMM-1a ) else
30628: LD_EXP 39
30632: PPUSH
30633: LD_STRING DAb-JMM-1a
30635: PPUSH
30636: CALL_OW 88
30640: GO 30654
// Say ( JMM , DAb-JMM-1b ) ;
30642: LD_EXP 39
30646: PPUSH
30647: LD_STRING DAb-JMM-1b
30649: PPUSH
30650: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30654: LD_EXP 35
30658: PPUSH
30659: CALL_OW 87
// for i in trueAmericans do
30663: LD_ADDR_VAR 0 2
30667: PUSH
30668: LD_EXP 35
30672: PUSH
30673: FOR_IN
30674: IFFALSE 30690
// SetSide ( i , 1 ) ;
30676: LD_VAR 0 2
30680: PPUSH
30681: LD_INT 1
30683: PPUSH
30684: CALL_OW 235
30688: GO 30673
30690: POP
30691: POP
// end ; repeat wait ( 0 0$1 ) ;
30692: LD_INT 35
30694: PPUSH
30695: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30699: LD_ADDR_VAR 0 2
30703: PUSH
30704: LD_INT 22
30706: PUSH
30707: LD_INT 7
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 21
30716: PUSH
30717: LD_INT 1
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PPUSH
30728: CALL_OW 69
30732: PUSH
30733: FOR_IN
30734: IFFALSE 30816
// begin if IsInUnit ( i ) then
30736: LD_VAR 0 2
30740: PPUSH
30741: CALL_OW 310
30745: IFFALSE 30756
// ComExitBuilding ( i ) ;
30747: LD_VAR 0 2
30751: PPUSH
30752: CALL_OW 122
// if IsDriver ( i ) then
30756: LD_VAR 0 2
30760: PPUSH
30761: CALL 105334 0 1
30765: IFFALSE 30776
// ComExitVehicle ( i ) ;
30767: LD_VAR 0 2
30771: PPUSH
30772: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30776: LD_VAR 0 2
30780: PPUSH
30781: LD_INT 26
30783: PPUSH
30784: CALL_OW 308
30788: NOT
30789: IFFALSE 30805
// AddComMoveToArea ( i , allianceEscapeArea ) else
30791: LD_VAR 0 2
30795: PPUSH
30796: LD_INT 26
30798: PPUSH
30799: CALL_OW 173
30803: GO 30814
// RemoveUnit ( i ) ;
30805: LD_VAR 0 2
30809: PPUSH
30810: CALL_OW 64
// end ;
30814: GO 30733
30816: POP
30817: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30818: LD_INT 22
30820: PUSH
30821: LD_INT 7
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: LD_INT 21
30830: PUSH
30831: LD_INT 1
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PPUSH
30842: CALL_OW 69
30846: NOT
30847: IFFALSE 30692
// end ;
30849: PPOPN 2
30851: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30852: LD_INT 0
30854: PPUSH
30855: PPUSH
// if not unit then
30856: LD_VAR 0 1
30860: NOT
30861: IFFALSE 30865
// exit ;
30863: GO 32363
// DoNotAttack ( 7 , unit ) ;
30865: LD_INT 7
30867: PPUSH
30868: LD_VAR 0 1
30872: PPUSH
30873: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30877: LD_VAR 0 1
30881: PPUSH
30882: LD_INT 260
30884: PPUSH
30885: LD_INT 235
30887: PPUSH
30888: LD_INT 3
30890: PPUSH
30891: LD_INT 1
30893: PPUSH
30894: CALL_OW 483
// SetSide ( unit , 4 ) ;
30898: LD_VAR 0 1
30902: PPUSH
30903: LD_INT 4
30905: PPUSH
30906: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30910: LD_ADDR_EXP 34
30914: PUSH
30915: LD_EXP 34
30919: PUSH
30920: LD_INT 1
30922: PLUS
30923: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30924: LD_INT 70
30926: PPUSH
30927: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30931: LD_INT 260
30933: PPUSH
30934: LD_INT 235
30936: PPUSH
30937: LD_INT 1
30939: PPUSH
30940: LD_INT 8
30942: NEG
30943: PPUSH
30944: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30948: LD_VAR 0 1
30952: PPUSH
30953: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30957: LD_VAR 0 1
30961: PPUSH
30962: LD_EXP 74
30966: PPUSH
30967: CALL_OW 119
// DialogueOn ;
30971: CALL_OW 6
// case unit of JMM :
30975: LD_VAR 0 1
30979: PUSH
30980: LD_EXP 39
30984: DOUBLE
30985: EQUAL
30986: IFTRUE 30990
30988: GO 31005
30990: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30991: LD_EXP 39
30995: PPUSH
30996: LD_STRING DA1-JMM-1
30998: PPUSH
30999: CALL_OW 91
31003: GO 31447
31005: LD_EXP 40
31009: DOUBLE
31010: EQUAL
31011: IFTRUE 31015
31013: GO 31030
31015: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31016: LD_EXP 40
31020: PPUSH
31021: LD_STRING DA1-Joan-1
31023: PPUSH
31024: CALL_OW 91
31028: GO 31447
31030: LD_EXP 42
31034: DOUBLE
31035: EQUAL
31036: IFTRUE 31040
31038: GO 31055
31040: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31041: LD_EXP 42
31045: PPUSH
31046: LD_STRING DA1-Lisa-1
31048: PPUSH
31049: CALL_OW 91
31053: GO 31447
31055: LD_EXP 43
31059: DOUBLE
31060: EQUAL
31061: IFTRUE 31065
31063: GO 31080
31065: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31066: LD_EXP 43
31070: PPUSH
31071: LD_STRING DA1-Don-1
31073: PPUSH
31074: CALL_OW 91
31078: GO 31447
31080: LD_EXP 50
31084: DOUBLE
31085: EQUAL
31086: IFTRUE 31090
31088: GO 31105
31090: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31091: LD_EXP 50
31095: PPUSH
31096: LD_STRING DA1-Corn-1
31098: PPUSH
31099: CALL_OW 91
31103: GO 31447
31105: LD_EXP 46
31109: DOUBLE
31110: EQUAL
31111: IFTRUE 31115
31113: GO 31130
31115: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31116: LD_EXP 46
31120: PPUSH
31121: LD_STRING DA1-Den-1
31123: PPUSH
31124: CALL_OW 91
31128: GO 31447
31130: LD_EXP 44
31134: DOUBLE
31135: EQUAL
31136: IFTRUE 31140
31138: GO 31155
31140: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31141: LD_EXP 44
31145: PPUSH
31146: LD_STRING DA1-Bobby-1
31148: PPUSH
31149: CALL_OW 91
31153: GO 31447
31155: LD_EXP 48
31159: DOUBLE
31160: EQUAL
31161: IFTRUE 31165
31163: GO 31180
31165: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31166: LD_EXP 48
31170: PPUSH
31171: LD_STRING DA1-Glad-1
31173: PPUSH
31174: CALL_OW 91
31178: GO 31447
31180: LD_EXP 45
31184: DOUBLE
31185: EQUAL
31186: IFTRUE 31190
31188: GO 31205
31190: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31191: LD_EXP 45
31195: PPUSH
31196: LD_STRING DA1-Cyrus-1
31198: PPUSH
31199: CALL_OW 91
31203: GO 31447
31205: LD_EXP 41
31209: DOUBLE
31210: EQUAL
31211: IFTRUE 31215
31213: GO 31230
31215: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31216: LD_EXP 41
31220: PPUSH
31221: LD_STRING DA1-Huck-1
31223: PPUSH
31224: CALL_OW 91
31228: GO 31447
31230: LD_EXP 55
31234: DOUBLE
31235: EQUAL
31236: IFTRUE 31240
31238: GO 31255
31240: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31241: LD_EXP 55
31245: PPUSH
31246: LD_STRING DA1-Huck-1
31248: PPUSH
31249: CALL_OW 91
31253: GO 31447
31255: LD_EXP 47
31259: DOUBLE
31260: EQUAL
31261: IFTRUE 31265
31263: GO 31280
31265: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31266: LD_EXP 47
31270: PPUSH
31271: LD_STRING DA1-Brown-1
31273: PPUSH
31274: CALL_OW 91
31278: GO 31447
31280: LD_EXP 51
31284: DOUBLE
31285: EQUAL
31286: IFTRUE 31290
31288: GO 31305
31290: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31291: LD_EXP 51
31295: PPUSH
31296: LD_STRING DA1-Gary-1
31298: PPUSH
31299: CALL_OW 91
31303: GO 31447
31305: LD_EXP 54
31309: DOUBLE
31310: EQUAL
31311: IFTRUE 31315
31313: GO 31330
31315: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31316: LD_EXP 54
31320: PPUSH
31321: LD_STRING DA1-Con-1
31323: PPUSH
31324: CALL_OW 91
31328: GO 31447
31330: LD_EXP 60
31334: DOUBLE
31335: EQUAL
31336: IFTRUE 31340
31338: GO 31355
31340: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31341: LD_EXP 60
31345: PPUSH
31346: LD_STRING DA1-Kurt-1
31348: PPUSH
31349: CALL_OW 91
31353: GO 31447
31355: LD_EXP 53
31359: DOUBLE
31360: EQUAL
31361: IFTRUE 31365
31363: GO 31380
31365: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31366: LD_EXP 53
31370: PPUSH
31371: LD_STRING DA1-Yam-1
31373: PPUSH
31374: CALL_OW 91
31378: GO 31447
31380: LD_EXP 52
31384: DOUBLE
31385: EQUAL
31386: IFTRUE 31390
31388: GO 31405
31390: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31391: LD_EXP 52
31395: PPUSH
31396: LD_STRING DA1-Frank-1
31398: PPUSH
31399: CALL_OW 91
31403: GO 31447
31405: POP
// begin if GetSex ( unit ) = sex_male then
31406: LD_VAR 0 1
31410: PPUSH
31411: CALL_OW 258
31415: PUSH
31416: LD_INT 1
31418: EQUAL
31419: IFFALSE 31435
// ForceSay ( unit , DA1-Sol1-1 ) else
31421: LD_VAR 0 1
31425: PPUSH
31426: LD_STRING DA1-Sol1-1
31428: PPUSH
31429: CALL_OW 91
31433: GO 31447
// ForceSay ( unit , DA1-FSol1-1 ) ;
31435: LD_VAR 0 1
31439: PPUSH
31440: LD_STRING DA1-FSol1-1
31442: PPUSH
31443: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31447: LD_EXP 74
31451: PPUSH
31452: LD_STRING DA-Roth-1
31454: PPUSH
31455: CALL_OW 88
// if capturedUnit = 1 then
31459: LD_EXP 34
31463: PUSH
31464: LD_INT 1
31466: EQUAL
31467: IFFALSE 31495
// begin Say ( Simms , DA-Sim-1 ) ;
31469: LD_EXP 75
31473: PPUSH
31474: LD_STRING DA-Sim-1
31476: PPUSH
31477: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31481: LD_EXP 74
31485: PPUSH
31486: LD_STRING DA-Roth-2
31488: PPUSH
31489: CALL_OW 88
// end else
31493: GO 31507
// Say ( Simms , DA-Sim-2 ) ;
31495: LD_EXP 75
31499: PPUSH
31500: LD_STRING DA-Sim-2
31502: PPUSH
31503: CALL_OW 88
// case unit of JMM :
31507: LD_VAR 0 1
31511: PUSH
31512: LD_EXP 39
31516: DOUBLE
31517: EQUAL
31518: IFTRUE 31522
31520: GO 31537
31522: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31523: LD_EXP 39
31527: PPUSH
31528: LD_STRING DA1-JMM-1a
31530: PPUSH
31531: CALL_OW 91
31535: GO 32044
31537: LD_EXP 40
31541: DOUBLE
31542: EQUAL
31543: IFTRUE 31547
31545: GO 31562
31547: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31548: LD_EXP 40
31552: PPUSH
31553: LD_STRING DA1-Joan-1a
31555: PPUSH
31556: CALL_OW 91
31560: GO 32044
31562: LD_EXP 42
31566: DOUBLE
31567: EQUAL
31568: IFTRUE 31572
31570: GO 31587
31572: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31573: LD_EXP 42
31577: PPUSH
31578: LD_STRING DA1-Lisa-1a
31580: PPUSH
31581: CALL_OW 91
31585: GO 32044
31587: LD_EXP 43
31591: DOUBLE
31592: EQUAL
31593: IFTRUE 31597
31595: GO 31612
31597: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31598: LD_EXP 43
31602: PPUSH
31603: LD_STRING DA1-Don-1a
31605: PPUSH
31606: CALL_OW 91
31610: GO 32044
31612: LD_EXP 50
31616: DOUBLE
31617: EQUAL
31618: IFTRUE 31622
31620: GO 31637
31622: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31623: LD_EXP 50
31627: PPUSH
31628: LD_STRING DA1-Corn-1a
31630: PPUSH
31631: CALL_OW 91
31635: GO 32044
31637: LD_EXP 46
31641: DOUBLE
31642: EQUAL
31643: IFTRUE 31647
31645: GO 31662
31647: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31648: LD_EXP 46
31652: PPUSH
31653: LD_STRING DA1-Den-1a
31655: PPUSH
31656: CALL_OW 91
31660: GO 32044
31662: LD_EXP 44
31666: DOUBLE
31667: EQUAL
31668: IFTRUE 31672
31670: GO 31687
31672: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31673: LD_EXP 44
31677: PPUSH
31678: LD_STRING DA1-Bobby-1a
31680: PPUSH
31681: CALL_OW 91
31685: GO 32044
31687: LD_EXP 48
31691: DOUBLE
31692: EQUAL
31693: IFTRUE 31697
31695: GO 31712
31697: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31698: LD_EXP 48
31702: PPUSH
31703: LD_STRING DA1-Glad-1a
31705: PPUSH
31706: CALL_OW 91
31710: GO 32044
31712: LD_EXP 45
31716: DOUBLE
31717: EQUAL
31718: IFTRUE 31722
31720: GO 31737
31722: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31723: LD_EXP 45
31727: PPUSH
31728: LD_STRING DA1-Cyrus-1a
31730: PPUSH
31731: CALL_OW 91
31735: GO 32044
31737: LD_EXP 41
31741: DOUBLE
31742: EQUAL
31743: IFTRUE 31747
31745: GO 31762
31747: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31748: LD_EXP 41
31752: PPUSH
31753: LD_STRING DA1-Huck-1a
31755: PPUSH
31756: CALL_OW 91
31760: GO 32044
31762: LD_EXP 55
31766: DOUBLE
31767: EQUAL
31768: IFTRUE 31772
31770: GO 31787
31772: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31773: LD_EXP 55
31777: PPUSH
31778: LD_STRING DA1-Huck-1a
31780: PPUSH
31781: CALL_OW 91
31785: GO 32044
31787: LD_EXP 47
31791: DOUBLE
31792: EQUAL
31793: IFTRUE 31797
31795: GO 31812
31797: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31798: LD_EXP 47
31802: PPUSH
31803: LD_STRING DA1-Brown-1a
31805: PPUSH
31806: CALL_OW 91
31810: GO 32044
31812: LD_EXP 51
31816: DOUBLE
31817: EQUAL
31818: IFTRUE 31822
31820: GO 31837
31822: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31823: LD_EXP 51
31827: PPUSH
31828: LD_STRING DA1-Gary-1a
31830: PPUSH
31831: CALL_OW 91
31835: GO 32044
31837: LD_EXP 54
31841: DOUBLE
31842: EQUAL
31843: IFTRUE 31847
31845: GO 31862
31847: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31848: LD_EXP 54
31852: PPUSH
31853: LD_STRING DA1-Con-1a
31855: PPUSH
31856: CALL_OW 91
31860: GO 32044
31862: LD_EXP 60
31866: DOUBLE
31867: EQUAL
31868: IFTRUE 31872
31870: GO 31887
31872: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31873: LD_EXP 60
31877: PPUSH
31878: LD_STRING DA1-Kurt-1a
31880: PPUSH
31881: CALL_OW 91
31885: GO 32044
31887: LD_EXP 53
31891: DOUBLE
31892: EQUAL
31893: IFTRUE 31897
31895: GO 31912
31897: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31898: LD_EXP 53
31902: PPUSH
31903: LD_STRING DA1-Yam-1a
31905: PPUSH
31906: CALL_OW 91
31910: GO 32044
31912: LD_EXP 52
31916: DOUBLE
31917: EQUAL
31918: IFTRUE 31922
31920: GO 31937
31922: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31923: LD_EXP 52
31927: PPUSH
31928: LD_STRING DA1-Frank-1a
31930: PPUSH
31931: CALL_OW 91
31935: GO 32044
31937: POP
// begin join := rand ( 0 , 1 ) ;
31938: LD_ADDR_VAR 0 3
31942: PUSH
31943: LD_INT 0
31945: PPUSH
31946: LD_INT 1
31948: PPUSH
31949: CALL_OW 12
31953: ST_TO_ADDR
// if join then
31954: LD_VAR 0 3
31958: IFFALSE 32003
// begin if GetSex ( unit ) = sex_male then
31960: LD_VAR 0 1
31964: PPUSH
31965: CALL_OW 258
31969: PUSH
31970: LD_INT 1
31972: EQUAL
31973: IFFALSE 31989
// ForceSay ( unit , DA1-Sol1-1b ) else
31975: LD_VAR 0 1
31979: PPUSH
31980: LD_STRING DA1-Sol1-1b
31982: PPUSH
31983: CALL_OW 91
31987: GO 32001
// ForceSay ( unit , DA1-FSol1-1b ) ;
31989: LD_VAR 0 1
31993: PPUSH
31994: LD_STRING DA1-FSol1-1b
31996: PPUSH
31997: CALL_OW 91
// end else
32001: GO 32044
// begin if GetSex ( unit ) = sex_male then
32003: LD_VAR 0 1
32007: PPUSH
32008: CALL_OW 258
32012: PUSH
32013: LD_INT 1
32015: EQUAL
32016: IFFALSE 32032
// ForceSay ( unit , DA1-Sol1-1a ) else
32018: LD_VAR 0 1
32022: PPUSH
32023: LD_STRING DA1-Sol1-1a
32025: PPUSH
32026: CALL_OW 91
32030: GO 32044
// ForceSay ( unit , DA1-FSol1-1a ) ;
32032: LD_VAR 0 1
32036: PPUSH
32037: LD_STRING DA1-FSol1-1a
32039: PPUSH
32040: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32044: LD_VAR 0 1
32048: PUSH
32049: LD_EXP 39
32053: EQUAL
32054: IFFALSE 32065
// begin YouLost ( JMMCaptured ) ;
32056: LD_STRING JMMCaptured
32058: PPUSH
32059: CALL_OW 104
// exit ;
32063: GO 32363
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32065: LD_VAR 0 1
32069: PUSH
32070: LD_EXP 43
32074: PUSH
32075: LD_EXP 46
32079: PUSH
32080: LD_EXP 44
32084: PUSH
32085: LD_EXP 41
32089: PUSH
32090: LD_EXP 55
32094: PUSH
32095: LD_EXP 47
32099: PUSH
32100: LD_EXP 53
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: IN
32114: PUSH
32115: LD_VAR 0 3
32119: OR
32120: IFFALSE 32219
// begin Say ( Roth , DA-Roth-3 ) ;
32122: LD_EXP 74
32126: PPUSH
32127: LD_STRING DA-Roth-3
32129: PPUSH
32130: CALL_OW 88
// SetSide ( unit , 7 ) ;
32134: LD_VAR 0 1
32138: PPUSH
32139: LD_INT 7
32141: PPUSH
32142: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32146: LD_ADDR_EXP 102
32150: PUSH
32151: LD_EXP 102
32155: PPUSH
32156: LD_INT 1
32158: PPUSH
32159: LD_EXP 102
32163: PUSH
32164: LD_INT 1
32166: ARRAY
32167: PUSH
32168: LD_VAR 0 1
32172: ADD
32173: PPUSH
32174: CALL_OW 1
32178: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32179: LD_INT 260
32181: PPUSH
32182: LD_INT 235
32184: PPUSH
32185: LD_INT 1
32187: PPUSH
32188: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32192: LD_VAR 0 1
32196: PPUSH
32197: LD_INT 1000
32199: PPUSH
32200: CALL_OW 234
// DialogueOff ;
32204: CALL_OW 7
// ComFree ( unit ) ;
32208: LD_VAR 0 1
32212: PPUSH
32213: CALL_OW 139
// end else
32217: GO 32300
// begin Say ( Roth , DA-Roth-3a ) ;
32219: LD_EXP 74
32223: PPUSH
32224: LD_STRING DA-Roth-3a
32226: PPUSH
32227: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32231: LD_ADDR_EXP 35
32235: PUSH
32236: LD_EXP 35
32240: PUSH
32241: LD_VAR 0 1
32245: ADD
32246: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32247: LD_INT 260
32249: PPUSH
32250: LD_INT 235
32252: PPUSH
32253: LD_INT 1
32255: PPUSH
32256: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32260: LD_VAR 0 1
32264: PPUSH
32265: LD_INT 1000
32267: PPUSH
32268: CALL_OW 234
// DialogueOff ;
32272: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32276: LD_VAR 0 1
32280: PPUSH
32281: LD_INT 272
32283: PPUSH
32284: LD_INT 254
32286: PPUSH
32287: CALL_OW 111
// AddComHold ( unit ) ;
32291: LD_VAR 0 1
32295: PPUSH
32296: CALL_OW 200
// end ; if capturedUnit = 1 then
32300: LD_EXP 34
32304: PUSH
32305: LD_INT 1
32307: EQUAL
32308: IFFALSE 32363
// begin DialogueOn ;
32310: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32314: LD_EXP 39
32318: PPUSH
32319: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32323: LD_EXP 39
32327: PPUSH
32328: LD_STRING DAa-JMM-1
32330: PPUSH
32331: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32335: LD_EXP 39
32339: PPUSH
32340: LD_STRING DAa-JMM-1a
32342: PPUSH
32343: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32347: LD_EXP 39
32351: PPUSH
32352: LD_STRING DAa-JMM-1b
32354: PPUSH
32355: CALL_OW 88
// DialogueOff ;
32359: CALL_OW 7
// end ; end ;
32363: LD_VAR 0 2
32367: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32368: LD_EXP 15
32372: PUSH
32373: LD_INT 13
32375: GREATEREQUAL
32376: PUSH
32377: LD_INT 22
32379: PUSH
32380: LD_INT 2
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 21
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PPUSH
32401: CALL_OW 69
32405: PUSH
32406: LD_INT 0
32408: EQUAL
32409: AND
32410: PUSH
32411: LD_INT 22
32413: PUSH
32414: LD_INT 2
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 21
32423: PUSH
32424: LD_INT 2
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 50
32433: PUSH
32434: EMPTY
32435: LIST
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: LIST
32441: PPUSH
32442: CALL_OW 69
32446: PUSH
32447: LD_INT 0
32449: EQUAL
32450: AND
32451: PUSH
32452: LD_EXP 21
32456: AND
32457: PUSH
32458: LD_EXP 22
32462: AND
32463: PUSH
32464: LD_EXP 23
32468: AND
32469: IFFALSE 33111
32471: GO 32473
32473: DISABLE
32474: LD_INT 0
32476: PPUSH
32477: PPUSH
32478: PPUSH
// begin m1 := false ;
32479: LD_ADDR_VAR 0 1
32483: PUSH
32484: LD_INT 0
32486: ST_TO_ADDR
// m2 := false ;
32487: LD_ADDR_VAR 0 2
32491: PUSH
32492: LD_INT 0
32494: ST_TO_ADDR
// m3 := false ;
32495: LD_ADDR_VAR 0 3
32499: PUSH
32500: LD_INT 0
32502: ST_TO_ADDR
// if not bombExploded then
32503: LD_EXP 37
32507: NOT
32508: IFFALSE 32517
// SetAchievement ( ACH_SIBROCKET ) ;
32510: LD_STRING ACH_SIBROCKET
32512: PPUSH
32513: CALL_OW 543
// if tick <= 120 120$00 then
32517: LD_OWVAR 1
32521: PUSH
32522: LD_INT 252000
32524: LESSEQUAL
32525: IFFALSE 32541
// begin wait ( 3 ) ;
32527: LD_INT 3
32529: PPUSH
32530: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32534: LD_STRING ACH_ASPEED_15
32536: PPUSH
32537: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32541: LD_EXP 39
32545: PPUSH
32546: CALL_OW 87
// music_class := 5 ;
32550: LD_ADDR_OWVAR 72
32554: PUSH
32555: LD_INT 5
32557: ST_TO_ADDR
// music_nat := 5 ;
32558: LD_ADDR_OWVAR 71
32562: PUSH
32563: LD_INT 5
32565: ST_TO_ADDR
// DialogueOn ;
32566: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32570: LD_EXP 39
32574: PPUSH
32575: LD_STRING D20-JMM-1
32577: PPUSH
32578: CALL_OW 88
// if IsOK ( Joan ) then
32582: LD_EXP 40
32586: PPUSH
32587: CALL_OW 302
32591: IFFALSE 32605
// Say ( Joan , D20-Joan-1 ) ;
32593: LD_EXP 40
32597: PPUSH
32598: LD_STRING D20-Joan-1
32600: PPUSH
32601: CALL_OW 88
// if IsOk ( Lisa ) then
32605: LD_EXP 42
32609: PPUSH
32610: CALL_OW 302
32614: IFFALSE 32628
// Say ( Lisa , D20-Lisa-1 ) ;
32616: LD_EXP 42
32620: PPUSH
32621: LD_STRING D20-Lisa-1
32623: PPUSH
32624: CALL_OW 88
// if IsOk ( Donaldson ) then
32628: LD_EXP 43
32632: PPUSH
32633: CALL_OW 302
32637: IFFALSE 32651
// Say ( Donaldson , D20-Don-1 ) ;
32639: LD_EXP 43
32643: PPUSH
32644: LD_STRING D20-Don-1
32646: PPUSH
32647: CALL_OW 88
// if IsOK ( Cornel ) then
32651: LD_EXP 50
32655: PPUSH
32656: CALL_OW 302
32660: IFFALSE 32674
// Say ( Cornel , D20-Corn-1 ) ;
32662: LD_EXP 50
32666: PPUSH
32667: LD_STRING D20-Corn-1
32669: PPUSH
32670: CALL_OW 88
// if IsOk ( Denis ) then
32674: LD_EXP 46
32678: PPUSH
32679: CALL_OW 302
32683: IFFALSE 32697
// Say ( Denis , D20-Den-1 ) ;
32685: LD_EXP 46
32689: PPUSH
32690: LD_STRING D20-Den-1
32692: PPUSH
32693: CALL_OW 88
// if IsOk ( Bobby ) then
32697: LD_EXP 44
32701: PPUSH
32702: CALL_OW 302
32706: IFFALSE 32720
// Say ( Bobby , D20-Bobby-1 ) ;
32708: LD_EXP 44
32712: PPUSH
32713: LD_STRING D20-Bobby-1
32715: PPUSH
32716: CALL_OW 88
// if IsOk ( Gladstone ) then
32720: LD_EXP 48
32724: PPUSH
32725: CALL_OW 302
32729: IFFALSE 32743
// Say ( Gladstone , D20-Glad-1 ) ;
32731: LD_EXP 48
32735: PPUSH
32736: LD_STRING D20-Glad-1
32738: PPUSH
32739: CALL_OW 88
// if IsOk ( Cyrus ) then
32743: LD_EXP 45
32747: PPUSH
32748: CALL_OW 302
32752: IFFALSE 32766
// Say ( Cyrus , D20-Cyrus-1 ) ;
32754: LD_EXP 45
32758: PPUSH
32759: LD_STRING D20-Cyrus-1
32761: PPUSH
32762: CALL_OW 88
// if IsOk ( Stevens ) then
32766: LD_EXP 41
32770: PPUSH
32771: CALL_OW 302
32775: IFFALSE 32789
// Say ( Stevens , D20-Huck-1 ) ;
32777: LD_EXP 41
32781: PPUSH
32782: LD_STRING D20-Huck-1
32784: PPUSH
32785: CALL_OW 88
// if IsOk ( Brown ) then
32789: LD_EXP 47
32793: PPUSH
32794: CALL_OW 302
32798: IFFALSE 32812
// Say ( Brown , D20-Brown-1 ) ;
32800: LD_EXP 47
32804: PPUSH
32805: LD_STRING D20-Brown-1
32807: PPUSH
32808: CALL_OW 88
// if IsOk ( Gary ) then
32812: LD_EXP 51
32816: PPUSH
32817: CALL_OW 302
32821: IFFALSE 32835
// Say ( Gary , D20-Gary-1 ) ;
32823: LD_EXP 51
32827: PPUSH
32828: LD_STRING D20-Gary-1
32830: PPUSH
32831: CALL_OW 88
// if IsOk ( Connie ) then
32835: LD_EXP 54
32839: PPUSH
32840: CALL_OW 302
32844: IFFALSE 32858
// Say ( Connie , D20-Con-1 ) ;
32846: LD_EXP 54
32850: PPUSH
32851: LD_STRING D20-Con-1
32853: PPUSH
32854: CALL_OW 88
// if IsOk ( Kurt ) then
32858: LD_EXP 60
32862: PPUSH
32863: CALL_OW 302
32867: IFFALSE 32881
// Say ( Kurt , D20-Kurt-1 ) ;
32869: LD_EXP 60
32873: PPUSH
32874: LD_STRING D20-Kurt-1
32876: PPUSH
32877: CALL_OW 88
// if IsOk ( Kikuchi ) then
32881: LD_EXP 53
32885: PPUSH
32886: CALL_OW 302
32890: IFFALSE 32904
// Say ( Kikuchi , D20-Yam-1 ) ;
32892: LD_EXP 53
32896: PPUSH
32897: LD_STRING D20-Yam-1
32899: PPUSH
32900: CALL_OW 88
// if IsOk ( Frank ) then
32904: LD_EXP 52
32908: PPUSH
32909: CALL_OW 302
32913: IFFALSE 32927
// Say ( Frank , D20-Frank-1 ) ;
32915: LD_EXP 52
32919: PPUSH
32920: LD_STRING D20-Frank-1
32922: PPUSH
32923: CALL_OW 88
// DialogueOff ;
32927: CALL_OW 7
// if RothCaptured then
32931: LD_EXP 33
32935: IFFALSE 32957
// begin m1 := true ;
32937: LD_ADDR_VAR 0 1
32941: PUSH
32942: LD_INT 1
32944: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32945: LD_STRING Roth
32947: PPUSH
32948: LD_INT 1
32950: PPUSH
32951: CALL_OW 101
// end else
32955: GO 32968
// AddMedal ( Roth , - 1 ) ;
32957: LD_STRING Roth
32959: PPUSH
32960: LD_INT 1
32962: NEG
32963: PPUSH
32964: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32968: LD_EXP 27
32972: IFFALSE 32994
// begin m2 := true ;
32974: LD_ADDR_VAR 0 2
32978: PUSH
32979: LD_INT 1
32981: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32982: LD_STRING Project
32984: PPUSH
32985: LD_INT 1
32987: PPUSH
32988: CALL_OW 101
// end else
32992: GO 33005
// AddMedal ( Project , - 1 ) ;
32994: LD_STRING Project
32996: PPUSH
32997: LD_INT 1
32999: NEG
33000: PPUSH
33001: CALL_OW 101
// if lostCounter = 0 then
33005: LD_EXP 32
33009: PUSH
33010: LD_INT 0
33012: EQUAL
33013: IFFALSE 33035
// begin m3 := true ;
33015: LD_ADDR_VAR 0 3
33019: PUSH
33020: LD_INT 1
33022: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33023: LD_STRING NoLosses
33025: PPUSH
33026: LD_INT 1
33028: PPUSH
33029: CALL_OW 101
// end else
33033: GO 33046
// AddMedal ( NoLosses , - 1 ) ;
33035: LD_STRING NoLosses
33037: PPUSH
33038: LD_INT 1
33040: NEG
33041: PPUSH
33042: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33046: LD_VAR 0 1
33050: PUSH
33051: LD_VAR 0 2
33055: AND
33056: PUSH
33057: LD_VAR 0 3
33061: AND
33062: PUSH
33063: LD_OWVAR 67
33067: PUSH
33068: LD_INT 3
33070: EQUAL
33071: AND
33072: IFFALSE 33084
// SetAchievementEX ( ACH_AMER , 15 ) ;
33074: LD_STRING ACH_AMER
33076: PPUSH
33077: LD_INT 15
33079: PPUSH
33080: CALL_OW 564
// GiveMedals ( MAIN ) ;
33084: LD_STRING MAIN
33086: PPUSH
33087: CALL_OW 102
// music_class := 4 ;
33091: LD_ADDR_OWVAR 72
33095: PUSH
33096: LD_INT 4
33098: ST_TO_ADDR
// music_nat := 1 ;
33099: LD_ADDR_OWVAR 71
33103: PUSH
33104: LD_INT 1
33106: ST_TO_ADDR
// YouWin ;
33107: CALL_OW 103
// end ; end_of_file
33111: PPOPN 3
33113: END
// export function CustomEvent ( event ) ; begin
33114: LD_INT 0
33116: PPUSH
// end ;
33117: LD_VAR 0 2
33121: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33122: LD_VAR 0 1
33126: PUSH
33127: LD_INT 1
33129: EQUAL
33130: PUSH
33131: LD_VAR 0 2
33135: PUSH
33136: LD_INT 4
33138: EQUAL
33139: AND
33140: PUSH
33141: LD_EXP 58
33145: PPUSH
33146: CALL_OW 300
33150: AND
33151: IFFALSE 33167
// begin wait ( 0 0$2 ) ;
33153: LD_INT 70
33155: PPUSH
33156: CALL_OW 67
// YouLost ( Dismissed ) ;
33160: LD_STRING Dismissed
33162: PPUSH
33163: CALL_OW 104
// end ; end ;
33167: PPOPN 2
33169: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33170: LD_VAR 0 2
33174: PPUSH
33175: LD_VAR 0 3
33179: PPUSH
33180: LD_INT 18
33182: PPUSH
33183: CALL_OW 309
33187: IFFALSE 33196
// YouLost ( Motherlode3 ) ;
33189: LD_STRING Motherlode3
33191: PPUSH
33192: CALL_OW 104
// end ;
33196: PPOPN 3
33198: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33199: LD_EXP 27
33203: NOT
33204: IFFALSE 33214
// behemothDone := true ;
33206: LD_ADDR_EXP 28
33210: PUSH
33211: LD_INT 1
33213: ST_TO_ADDR
// end ;
33214: PPOPN 1
33216: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33217: LD_VAR 0 1
33221: PPUSH
33222: CALL_OW 255
33226: PUSH
33227: LD_INT 1
33229: EQUAL
33230: IFFALSE 33240
// bombExploded := true ;
33232: LD_ADDR_EXP 37
33236: PUSH
33237: LD_INT 1
33239: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33240: LD_VAR 0 1
33244: PPUSH
33245: CALL_OW 255
33249: PUSH
33250: LD_INT 1
33252: EQUAL
33253: PUSH
33254: LD_EXP 30
33258: AND
33259: PUSH
33260: LD_INT 22
33262: PUSH
33263: LD_INT 3
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 34
33272: PUSH
33273: LD_INT 48
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PPUSH
33284: CALL_OW 69
33288: AND
33289: PUSH
33290: LD_INT 22
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 34
33302: PUSH
33303: LD_INT 8
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PPUSH
33314: CALL_OW 69
33318: NOT
33319: AND
33320: IFFALSE 33372
// begin wait ( 0 0$5 ) ;
33322: LD_INT 175
33324: PPUSH
33325: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33329: LD_INT 22
33331: PUSH
33332: LD_INT 3
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 34
33341: PUSH
33342: LD_INT 48
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PPUSH
33353: CALL_OW 69
33357: PUSH
33358: LD_INT 1
33360: ARRAY
33361: PPUSH
33362: LD_INT 60
33364: PPUSH
33365: LD_INT 95
33367: PPUSH
33368: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33372: LD_VAR 0 2
33376: PPUSH
33377: LD_VAR 0 3
33381: PPUSH
33382: LD_INT 18
33384: PPUSH
33385: CALL_OW 309
33389: IFFALSE 33449
// begin if GetSide ( unit ) = 1 then
33391: LD_VAR 0 1
33395: PPUSH
33396: CALL_OW 255
33400: PUSH
33401: LD_INT 1
33403: EQUAL
33404: IFFALSE 33420
// begin wait ( 0 0$6 ) ;
33406: LD_INT 210
33408: PPUSH
33409: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33413: LD_STRING Motherlode2
33415: PPUSH
33416: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33420: LD_VAR 0 1
33424: PPUSH
33425: CALL_OW 255
33429: PUSH
33430: LD_INT 8
33432: EQUAL
33433: IFFALSE 33449
// begin wait ( 0 0$6 ) ;
33435: LD_INT 210
33437: PPUSH
33438: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33442: LD_STRING Motherlode1
33444: PPUSH
33445: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33449: LD_VAR 0 1
33453: PPUSH
33454: CALL_OW 255
33458: PUSH
33459: LD_INT 3
33461: EQUAL
33462: IFFALSE 33483
// begin wait ( 0 0$5 ) ;
33464: LD_INT 175
33466: PPUSH
33467: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33471: LD_EXP 64
33475: PPUSH
33476: LD_STRING D18-Pla-1
33478: PPUSH
33479: CALL_OW 94
// end ; end ;
33483: PPOPN 3
33485: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33486: LD_VAR 0 1
33490: PUSH
33491: LD_EXP 73
33495: IN
33496: IFFALSE 33516
// begin behemothBuilders := behemothBuilders diff un ;
33498: LD_ADDR_EXP 73
33502: PUSH
33503: LD_EXP 73
33507: PUSH
33508: LD_VAR 0 1
33512: DIFF
33513: ST_TO_ADDR
// exit ;
33514: GO 33614
// end ; if un = JMM then
33516: LD_VAR 0 1
33520: PUSH
33521: LD_EXP 39
33525: EQUAL
33526: IFFALSE 33537
// begin YouLost ( JMM ) ;
33528: LD_STRING JMM
33530: PPUSH
33531: CALL_OW 104
// exit ;
33535: GO 33614
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33537: LD_VAR 0 1
33541: PUSH
33542: LD_INT 22
33544: PUSH
33545: LD_INT 1
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: LD_INT 25
33557: PUSH
33558: LD_INT 16
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 25
33567: PUSH
33568: LD_INT 12
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: LIST
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PPUSH
33584: CALL_OW 69
33588: IN
33589: IFFALSE 33605
// lostCounter := lostCounter + 1 ;
33591: LD_ADDR_EXP 32
33595: PUSH
33596: LD_EXP 32
33600: PUSH
33601: LD_INT 1
33603: PLUS
33604: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33605: LD_VAR 0 1
33609: PPUSH
33610: CALL 61794 0 1
// end ;
33614: PPOPN 1
33616: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33617: LD_VAR 0 1
33621: PPUSH
33622: LD_VAR 0 2
33626: PPUSH
33627: CALL 64128 0 2
// end ;
33631: PPOPN 2
33633: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33634: LD_VAR 0 1
33638: PPUSH
33639: CALL 63196 0 1
// end ;
33643: PPOPN 1
33645: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33646: LD_VAR 0 1
33650: PUSH
33651: LD_INT 22
33653: PUSH
33654: LD_INT 8
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 30
33663: PUSH
33664: LD_INT 2
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 23
33673: PUSH
33674: LD_INT 3
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: LIST
33685: PPUSH
33686: CALL_OW 69
33690: IN
33691: IFFALSE 33718
// begin ComUpgrade ( building ) ;
33693: LD_VAR 0 1
33697: PPUSH
33698: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33702: LD_EXP 61
33706: PPUSH
33707: LD_VAR 0 1
33711: PPUSH
33712: CALL 74834 0 2
// exit ;
33716: GO 33727
// end ; MCE_BuildingComplete ( building ) ;
33718: LD_VAR 0 1
33722: PPUSH
33723: CALL 63437 0 1
// end ;
33727: PPOPN 1
33729: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33730: LD_VAR 0 1
33734: PPUSH
33735: LD_VAR 0 2
33739: PPUSH
33740: CALL 61490 0 2
// end ;
33744: PPOPN 2
33746: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33747: LD_VAR 0 1
33751: PPUSH
33752: LD_VAR 0 2
33756: PPUSH
33757: LD_VAR 0 3
33761: PPUSH
33762: LD_VAR 0 4
33766: PPUSH
33767: LD_VAR 0 5
33771: PPUSH
33772: CALL 61110 0 5
// end ;
33776: PPOPN 5
33778: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33779: LD_VAR 0 1
33783: PPUSH
33784: LD_VAR 0 2
33788: PPUSH
33789: CALL 60706 0 2
// end ;
33793: PPOPN 2
33795: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33796: LD_VAR 0 1
33800: PPUSH
33801: LD_VAR 0 2
33805: PPUSH
33806: LD_VAR 0 3
33810: PPUSH
33811: LD_VAR 0 4
33815: PPUSH
33816: CALL 60544 0 4
// end ;
33820: PPOPN 4
33822: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33823: LD_VAR 0 1
33827: PPUSH
33828: LD_VAR 0 2
33832: PPUSH
33833: LD_VAR 0 3
33837: PPUSH
33838: CALL 60319 0 3
// end ;
33842: PPOPN 3
33844: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33845: LD_VAR 0 1
33849: PPUSH
33850: LD_VAR 0 2
33854: PPUSH
33855: CALL 60204 0 2
// end ;
33859: PPOPN 2
33861: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33862: LD_VAR 0 1
33866: PPUSH
33867: LD_VAR 0 2
33871: PPUSH
33872: CALL 64389 0 2
// end ;
33876: PPOPN 2
33878: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33879: LD_VAR 0 1
33883: PPUSH
33884: CALL_OW 255
33888: PUSH
33889: LD_INT 4
33891: EQUAL
33892: PUSH
33893: LD_VAR 0 1
33897: PUSH
33898: LD_EXP 18
33902: PUSH
33903: LD_INT 1
33905: ARRAY
33906: IN
33907: AND
33908: PUSH
33909: LD_EXP 19
33913: AND
33914: IFFALSE 33933
// begin ComMoveXY ( driver , 61 , 93 ) ;
33916: LD_VAR 0 1
33920: PPUSH
33921: LD_INT 61
33923: PPUSH
33924: LD_INT 93
33926: PPUSH
33927: CALL_OW 111
// exit ;
33931: GO 33957
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33933: LD_VAR 0 1
33937: PPUSH
33938: LD_VAR 0 2
33942: PPUSH
33943: LD_VAR 0 3
33947: PPUSH
33948: LD_VAR 0 4
33952: PPUSH
33953: CALL 64605 0 4
// end ;
33957: PPOPN 4
33959: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33960: LD_VAR 0 1
33964: PPUSH
33965: LD_VAR 0 2
33969: PPUSH
33970: CALL 60013 0 2
// end ;
33974: PPOPN 2
33976: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33977: LD_VAR 0 1
33981: PPUSH
33982: CALL 108009 0 1
// end ; end_of_file
33986: PPOPN 1
33988: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33989: LD_EXP 15
33993: PUSH
33994: LD_INT 2
33996: EQUAL
33997: IFFALSE 34476
33999: GO 34001
34001: DISABLE
34002: LD_INT 0
34004: PPUSH
// begin time := 0 0$40 ;
34005: LD_ADDR_VAR 0 1
34009: PUSH
34010: LD_INT 1400
34012: ST_TO_ADDR
// repeat wait ( time ) ;
34013: LD_VAR 0 1
34017: PPUSH
34018: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34022: LD_INT 1
34024: PPUSH
34025: LD_INT 5
34027: PPUSH
34028: CALL_OW 12
34032: PPUSH
34033: LD_INT 106
34035: PPUSH
34036: LD_INT 150
34038: PPUSH
34039: LD_INT 19
34041: PPUSH
34042: LD_INT 1
34044: PPUSH
34045: CALL_OW 56
// time := time + 0 0$9 ;
34049: LD_ADDR_VAR 0 1
34053: PUSH
34054: LD_VAR 0 1
34058: PUSH
34059: LD_INT 315
34061: PLUS
34062: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34063: LD_INT 455
34065: PPUSH
34066: LD_INT 840
34068: PPUSH
34069: CALL_OW 12
34073: PPUSH
34074: CALL_OW 67
// if Prob ( 50 ) then
34078: LD_INT 50
34080: PPUSH
34081: CALL_OW 13
34085: IFFALSE 34114
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34087: LD_INT 1
34089: PPUSH
34090: LD_INT 5
34092: PPUSH
34093: CALL_OW 12
34097: PPUSH
34098: LD_INT 62
34100: PPUSH
34101: LD_INT 108
34103: PPUSH
34104: LD_INT 10
34106: PPUSH
34107: LD_INT 1
34109: PPUSH
34110: CALL_OW 56
// until missionStage > 4 ;
34114: LD_EXP 15
34118: PUSH
34119: LD_INT 4
34121: GREATER
34122: IFFALSE 34013
// repeat wait ( 0 0$1 ) ;
34124: LD_INT 35
34126: PPUSH
34127: CALL_OW 67
// until missionStage = 6 ;
34131: LD_EXP 15
34135: PUSH
34136: LD_INT 6
34138: EQUAL
34139: IFFALSE 34124
// time := 0 0$50 ;
34141: LD_ADDR_VAR 0 1
34145: PUSH
34146: LD_INT 1750
34148: ST_TO_ADDR
// repeat wait ( time ) ;
34149: LD_VAR 0 1
34153: PPUSH
34154: CALL_OW 67
// if Prob ( 50 ) then
34158: LD_INT 50
34160: PPUSH
34161: CALL_OW 13
34165: IFFALSE 34194
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34167: LD_INT 1
34169: PPUSH
34170: LD_INT 5
34172: PPUSH
34173: CALL_OW 12
34177: PPUSH
34178: LD_INT 106
34180: PPUSH
34181: LD_INT 89
34183: PPUSH
34184: LD_INT 45
34186: PPUSH
34187: LD_INT 1
34189: PPUSH
34190: CALL_OW 56
// time := time + 0 0$3 ;
34194: LD_ADDR_VAR 0 1
34198: PUSH
34199: LD_VAR 0 1
34203: PUSH
34204: LD_INT 105
34206: PLUS
34207: ST_TO_ADDR
// if Prob ( 30 ) then
34208: LD_INT 30
34210: PPUSH
34211: CALL_OW 13
34215: IFFALSE 34261
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
34217: LD_INT 525
34219: PPUSH
34220: LD_INT 735
34222: PPUSH
34223: CALL_OW 12
34227: PPUSH
34228: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34232: LD_INT 1
34234: PPUSH
34235: LD_INT 5
34237: PPUSH
34238: CALL_OW 12
34242: PPUSH
34243: LD_INT 21
34245: PPUSH
34246: LD_INT 26
34248: PPUSH
34249: LD_INT 12
34251: PPUSH
34252: LD_INT 1
34254: PPUSH
34255: CALL_OW 56
// end else
34259: GO 34297
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34261: LD_INT 700
34263: PPUSH
34264: LD_INT 1225
34266: PPUSH
34267: CALL_OW 12
34271: PPUSH
34272: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34276: LD_INT 1
34278: PPUSH
34279: LD_INT 5
34281: PPUSH
34282: CALL_OW 12
34286: PPUSH
34287: LD_INT 16
34289: PPUSH
34290: LD_INT 1
34292: PPUSH
34293: CALL_OW 55
// end ; if Prob ( 50 ) then
34297: LD_INT 50
34299: PPUSH
34300: CALL_OW 13
34304: IFFALSE 34350
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34306: LD_INT 700
34308: PPUSH
34309: LD_INT 1050
34311: PPUSH
34312: CALL_OW 12
34316: PPUSH
34317: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34321: LD_INT 1
34323: PPUSH
34324: LD_INT 5
34326: PPUSH
34327: CALL_OW 12
34331: PPUSH
34332: LD_INT 181
34334: PPUSH
34335: LD_INT 218
34337: PPUSH
34338: LD_INT 16
34340: PPUSH
34341: LD_INT 1
34343: PPUSH
34344: CALL_OW 56
// end else
34348: GO 34386
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34350: LD_INT 350
34352: PPUSH
34353: LD_INT 525
34355: PPUSH
34356: CALL_OW 12
34360: PPUSH
34361: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34365: LD_INT 1
34367: PPUSH
34368: LD_INT 5
34370: PPUSH
34371: CALL_OW 12
34375: PPUSH
34376: LD_INT 15
34378: PPUSH
34379: LD_INT 1
34381: PPUSH
34382: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34386: LD_INT 45
34388: PUSH
34389: LD_INT 32
34391: PUSH
34392: LD_INT 25
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: LIST
34399: PUSH
34400: LD_OWVAR 67
34404: ARRAY
34405: PPUSH
34406: CALL_OW 13
34410: IFFALSE 34454
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
34412: LD_INT 525
34414: PPUSH
34415: LD_INT 875
34417: PPUSH
34418: CALL_OW 12
34422: PPUSH
34423: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34427: LD_INT 1
34429: PPUSH
34430: LD_INT 5
34432: PPUSH
34433: CALL_OW 12
34437: PPUSH
34438: LD_INT 103
34440: PPUSH
34441: LD_INT 140
34443: PPUSH
34444: LD_INT 20
34446: PPUSH
34447: LD_INT 1
34449: PPUSH
34450: CALL_OW 56
// end ; if time > 1 1$40 then
34454: LD_VAR 0 1
34458: PUSH
34459: LD_INT 3500
34461: GREATER
34462: IFFALSE 34472
// time := 0 0$50 ;
34464: LD_ADDR_VAR 0 1
34468: PUSH
34469: LD_INT 1750
34471: ST_TO_ADDR
// until false ;
34472: LD_INT 0
34474: IFFALSE 34149
// end ; end_of_file
34476: PPOPN 1
34478: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34479: LD_EXP 13
34483: PUSH
34484: LD_EXP 15
34488: PUSH
34489: LD_INT 6
34491: GREATEREQUAL
34492: AND
34493: IFFALSE 34530
34495: GO 34497
34497: DISABLE
// begin enable ;
34498: ENABLE
// missionTime := missionTime + 0 0$1 ;
34499: LD_ADDR_EXP 14
34503: PUSH
34504: LD_EXP 14
34508: PUSH
34509: LD_INT 35
34511: PLUS
34512: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34513: LD_ADDR_OWVAR 47
34517: PUSH
34518: LD_STRING #Am15-1
34520: PUSH
34521: LD_EXP 14
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: ST_TO_ADDR
// end ; end_of_file
34530: END
// export function InitNature ; begin
34531: LD_INT 0
34533: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34534: LD_INT 3
34536: PPUSH
34537: LD_INT 3
34539: PPUSH
34540: LD_INT 2
34542: PPUSH
34543: LD_INT 1
34545: PPUSH
34546: LD_INT 1
34548: PPUSH
34549: LD_INT 0
34551: PPUSH
34552: LD_INT 0
34554: PPUSH
34555: LD_INT 20
34557: PPUSH
34558: LD_INT 0
34560: PPUSH
34561: CALL 99652 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34565: LD_INT 2
34567: PPUSH
34568: LD_INT 1
34570: PPUSH
34571: LD_INT 1
34573: PPUSH
34574: LD_INT 1
34576: PPUSH
34577: LD_INT 1
34579: PPUSH
34580: LD_INT 0
34582: PPUSH
34583: LD_INT 0
34585: PPUSH
34586: LD_INT 21
34588: PPUSH
34589: LD_INT 0
34591: PPUSH
34592: CALL 99652 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34596: LD_INT 4
34598: PPUSH
34599: LD_INT 1
34601: PPUSH
34602: LD_INT 2
34604: PPUSH
34605: LD_INT 4
34607: PPUSH
34608: LD_INT 2
34610: PPUSH
34611: LD_INT 1
34613: PPUSH
34614: LD_INT 0
34616: PPUSH
34617: LD_INT 22
34619: PPUSH
34620: LD_INT 0
34622: PPUSH
34623: CALL 99652 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34627: LD_INT 0
34629: PPUSH
34630: LD_INT 0
34632: PPUSH
34633: LD_INT 0
34635: PPUSH
34636: LD_INT 0
34638: PPUSH
34639: LD_INT 0
34641: PPUSH
34642: LD_INT 0
34644: PPUSH
34645: LD_INT 9
34647: PPUSH
34648: LD_INT 0
34650: PPUSH
34651: LD_INT 23
34653: PPUSH
34654: CALL 99652 0 9
// end ; end_of_file
34658: LD_VAR 0 1
34662: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34663: GO 34665
34665: DISABLE
// begin ru_radar := 98 ;
34666: LD_ADDR_EXP 95
34670: PUSH
34671: LD_INT 98
34673: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34674: LD_ADDR_EXP 96
34678: PUSH
34679: LD_INT 89
34681: ST_TO_ADDR
// us_hack := 99 ;
34682: LD_ADDR_EXP 97
34686: PUSH
34687: LD_INT 99
34689: ST_TO_ADDR
// us_artillery := 97 ;
34690: LD_ADDR_EXP 98
34694: PUSH
34695: LD_INT 97
34697: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34698: LD_ADDR_EXP 99
34702: PUSH
34703: LD_INT 91
34705: ST_TO_ADDR
// end ; end_of_file
34706: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34707: LD_INT 0
34709: PPUSH
34710: PPUSH
// skirmish := false ;
34711: LD_ADDR_EXP 100
34715: PUSH
34716: LD_INT 0
34718: ST_TO_ADDR
// debug_mc := false ;
34719: LD_ADDR_EXP 101
34723: PUSH
34724: LD_INT 0
34726: ST_TO_ADDR
// mc_bases := [ ] ;
34727: LD_ADDR_EXP 102
34731: PUSH
34732: EMPTY
34733: ST_TO_ADDR
// mc_sides := [ ] ;
34734: LD_ADDR_EXP 128
34738: PUSH
34739: EMPTY
34740: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34741: LD_ADDR_EXP 103
34745: PUSH
34746: EMPTY
34747: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34748: LD_ADDR_EXP 104
34752: PUSH
34753: EMPTY
34754: ST_TO_ADDR
// mc_need_heal := [ ] ;
34755: LD_ADDR_EXP 105
34759: PUSH
34760: EMPTY
34761: ST_TO_ADDR
// mc_healers := [ ] ;
34762: LD_ADDR_EXP 106
34766: PUSH
34767: EMPTY
34768: ST_TO_ADDR
// mc_build_list := [ ] ;
34769: LD_ADDR_EXP 107
34773: PUSH
34774: EMPTY
34775: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34776: LD_ADDR_EXP 134
34780: PUSH
34781: EMPTY
34782: ST_TO_ADDR
// mc_builders := [ ] ;
34783: LD_ADDR_EXP 108
34787: PUSH
34788: EMPTY
34789: ST_TO_ADDR
// mc_construct_list := [ ] ;
34790: LD_ADDR_EXP 109
34794: PUSH
34795: EMPTY
34796: ST_TO_ADDR
// mc_turret_list := [ ] ;
34797: LD_ADDR_EXP 110
34801: PUSH
34802: EMPTY
34803: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34804: LD_ADDR_EXP 111
34808: PUSH
34809: EMPTY
34810: ST_TO_ADDR
// mc_miners := [ ] ;
34811: LD_ADDR_EXP 116
34815: PUSH
34816: EMPTY
34817: ST_TO_ADDR
// mc_mines := [ ] ;
34818: LD_ADDR_EXP 115
34822: PUSH
34823: EMPTY
34824: ST_TO_ADDR
// mc_minefields := [ ] ;
34825: LD_ADDR_EXP 117
34829: PUSH
34830: EMPTY
34831: ST_TO_ADDR
// mc_crates := [ ] ;
34832: LD_ADDR_EXP 118
34836: PUSH
34837: EMPTY
34838: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34839: LD_ADDR_EXP 119
34843: PUSH
34844: EMPTY
34845: ST_TO_ADDR
// mc_crates_area := [ ] ;
34846: LD_ADDR_EXP 120
34850: PUSH
34851: EMPTY
34852: ST_TO_ADDR
// mc_vehicles := [ ] ;
34853: LD_ADDR_EXP 121
34857: PUSH
34858: EMPTY
34859: ST_TO_ADDR
// mc_attack := [ ] ;
34860: LD_ADDR_EXP 122
34864: PUSH
34865: EMPTY
34866: ST_TO_ADDR
// mc_produce := [ ] ;
34867: LD_ADDR_EXP 123
34871: PUSH
34872: EMPTY
34873: ST_TO_ADDR
// mc_defender := [ ] ;
34874: LD_ADDR_EXP 124
34878: PUSH
34879: EMPTY
34880: ST_TO_ADDR
// mc_parking := [ ] ;
34881: LD_ADDR_EXP 126
34885: PUSH
34886: EMPTY
34887: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34888: LD_ADDR_EXP 112
34892: PUSH
34893: EMPTY
34894: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34895: LD_ADDR_EXP 114
34899: PUSH
34900: EMPTY
34901: ST_TO_ADDR
// mc_scan := [ ] ;
34902: LD_ADDR_EXP 125
34906: PUSH
34907: EMPTY
34908: ST_TO_ADDR
// mc_scan_area := [ ] ;
34909: LD_ADDR_EXP 127
34913: PUSH
34914: EMPTY
34915: ST_TO_ADDR
// mc_tech := [ ] ;
34916: LD_ADDR_EXP 129
34920: PUSH
34921: EMPTY
34922: ST_TO_ADDR
// mc_class := [ ] ;
34923: LD_ADDR_EXP 143
34927: PUSH
34928: EMPTY
34929: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34930: LD_ADDR_EXP 144
34934: PUSH
34935: EMPTY
34936: ST_TO_ADDR
// end ;
34937: LD_VAR 0 1
34941: RET
// export function MC_Kill ( base ) ; begin
34942: LD_INT 0
34944: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34945: LD_ADDR_EXP 102
34949: PUSH
34950: LD_EXP 102
34954: PPUSH
34955: LD_VAR 0 1
34959: PPUSH
34960: EMPTY
34961: PPUSH
34962: CALL_OW 1
34966: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34967: LD_ADDR_EXP 103
34971: PUSH
34972: LD_EXP 103
34976: PPUSH
34977: LD_VAR 0 1
34981: PPUSH
34982: EMPTY
34983: PPUSH
34984: CALL_OW 1
34988: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34989: LD_ADDR_EXP 104
34993: PUSH
34994: LD_EXP 104
34998: PPUSH
34999: LD_VAR 0 1
35003: PPUSH
35004: EMPTY
35005: PPUSH
35006: CALL_OW 1
35010: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35011: LD_ADDR_EXP 105
35015: PUSH
35016: LD_EXP 105
35020: PPUSH
35021: LD_VAR 0 1
35025: PPUSH
35026: EMPTY
35027: PPUSH
35028: CALL_OW 1
35032: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35033: LD_ADDR_EXP 106
35037: PUSH
35038: LD_EXP 106
35042: PPUSH
35043: LD_VAR 0 1
35047: PPUSH
35048: EMPTY
35049: PPUSH
35050: CALL_OW 1
35054: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35055: LD_ADDR_EXP 107
35059: PUSH
35060: LD_EXP 107
35064: PPUSH
35065: LD_VAR 0 1
35069: PPUSH
35070: EMPTY
35071: PPUSH
35072: CALL_OW 1
35076: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35077: LD_ADDR_EXP 108
35081: PUSH
35082: LD_EXP 108
35086: PPUSH
35087: LD_VAR 0 1
35091: PPUSH
35092: EMPTY
35093: PPUSH
35094: CALL_OW 1
35098: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35099: LD_ADDR_EXP 109
35103: PUSH
35104: LD_EXP 109
35108: PPUSH
35109: LD_VAR 0 1
35113: PPUSH
35114: EMPTY
35115: PPUSH
35116: CALL_OW 1
35120: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35121: LD_ADDR_EXP 110
35125: PUSH
35126: LD_EXP 110
35130: PPUSH
35131: LD_VAR 0 1
35135: PPUSH
35136: EMPTY
35137: PPUSH
35138: CALL_OW 1
35142: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35143: LD_ADDR_EXP 111
35147: PUSH
35148: LD_EXP 111
35152: PPUSH
35153: LD_VAR 0 1
35157: PPUSH
35158: EMPTY
35159: PPUSH
35160: CALL_OW 1
35164: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35165: LD_ADDR_EXP 112
35169: PUSH
35170: LD_EXP 112
35174: PPUSH
35175: LD_VAR 0 1
35179: PPUSH
35180: EMPTY
35181: PPUSH
35182: CALL_OW 1
35186: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35187: LD_ADDR_EXP 113
35191: PUSH
35192: LD_EXP 113
35196: PPUSH
35197: LD_VAR 0 1
35201: PPUSH
35202: LD_INT 0
35204: PPUSH
35205: CALL_OW 1
35209: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35210: LD_ADDR_EXP 114
35214: PUSH
35215: LD_EXP 114
35219: PPUSH
35220: LD_VAR 0 1
35224: PPUSH
35225: EMPTY
35226: PPUSH
35227: CALL_OW 1
35231: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35232: LD_ADDR_EXP 115
35236: PUSH
35237: LD_EXP 115
35241: PPUSH
35242: LD_VAR 0 1
35246: PPUSH
35247: EMPTY
35248: PPUSH
35249: CALL_OW 1
35253: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35254: LD_ADDR_EXP 116
35258: PUSH
35259: LD_EXP 116
35263: PPUSH
35264: LD_VAR 0 1
35268: PPUSH
35269: EMPTY
35270: PPUSH
35271: CALL_OW 1
35275: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35276: LD_ADDR_EXP 117
35280: PUSH
35281: LD_EXP 117
35285: PPUSH
35286: LD_VAR 0 1
35290: PPUSH
35291: EMPTY
35292: PPUSH
35293: CALL_OW 1
35297: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35298: LD_ADDR_EXP 118
35302: PUSH
35303: LD_EXP 118
35307: PPUSH
35308: LD_VAR 0 1
35312: PPUSH
35313: EMPTY
35314: PPUSH
35315: CALL_OW 1
35319: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35320: LD_ADDR_EXP 119
35324: PUSH
35325: LD_EXP 119
35329: PPUSH
35330: LD_VAR 0 1
35334: PPUSH
35335: EMPTY
35336: PPUSH
35337: CALL_OW 1
35341: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35342: LD_ADDR_EXP 120
35346: PUSH
35347: LD_EXP 120
35351: PPUSH
35352: LD_VAR 0 1
35356: PPUSH
35357: EMPTY
35358: PPUSH
35359: CALL_OW 1
35363: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35364: LD_ADDR_EXP 121
35368: PUSH
35369: LD_EXP 121
35373: PPUSH
35374: LD_VAR 0 1
35378: PPUSH
35379: EMPTY
35380: PPUSH
35381: CALL_OW 1
35385: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35386: LD_ADDR_EXP 122
35390: PUSH
35391: LD_EXP 122
35395: PPUSH
35396: LD_VAR 0 1
35400: PPUSH
35401: EMPTY
35402: PPUSH
35403: CALL_OW 1
35407: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35408: LD_ADDR_EXP 123
35412: PUSH
35413: LD_EXP 123
35417: PPUSH
35418: LD_VAR 0 1
35422: PPUSH
35423: EMPTY
35424: PPUSH
35425: CALL_OW 1
35429: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35430: LD_ADDR_EXP 124
35434: PUSH
35435: LD_EXP 124
35439: PPUSH
35440: LD_VAR 0 1
35444: PPUSH
35445: EMPTY
35446: PPUSH
35447: CALL_OW 1
35451: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35452: LD_ADDR_EXP 125
35456: PUSH
35457: LD_EXP 125
35461: PPUSH
35462: LD_VAR 0 1
35466: PPUSH
35467: EMPTY
35468: PPUSH
35469: CALL_OW 1
35473: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35474: LD_ADDR_EXP 126
35478: PUSH
35479: LD_EXP 126
35483: PPUSH
35484: LD_VAR 0 1
35488: PPUSH
35489: EMPTY
35490: PPUSH
35491: CALL_OW 1
35495: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35496: LD_ADDR_EXP 127
35500: PUSH
35501: LD_EXP 127
35505: PPUSH
35506: LD_VAR 0 1
35510: PPUSH
35511: EMPTY
35512: PPUSH
35513: CALL_OW 1
35517: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35518: LD_ADDR_EXP 129
35522: PUSH
35523: LD_EXP 129
35527: PPUSH
35528: LD_VAR 0 1
35532: PPUSH
35533: EMPTY
35534: PPUSH
35535: CALL_OW 1
35539: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35540: LD_ADDR_EXP 131
35544: PUSH
35545: LD_EXP 131
35549: PPUSH
35550: LD_VAR 0 1
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35562: LD_ADDR_EXP 132
35566: PUSH
35567: LD_EXP 132
35571: PPUSH
35572: LD_VAR 0 1
35576: PPUSH
35577: EMPTY
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35584: LD_ADDR_EXP 133
35588: PUSH
35589: LD_EXP 133
35593: PPUSH
35594: LD_VAR 0 1
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35606: LD_ADDR_EXP 134
35610: PUSH
35611: LD_EXP 134
35615: PPUSH
35616: LD_VAR 0 1
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35628: LD_ADDR_EXP 135
35632: PUSH
35633: LD_EXP 135
35637: PPUSH
35638: LD_VAR 0 1
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35650: LD_ADDR_EXP 136
35654: PUSH
35655: LD_EXP 136
35659: PPUSH
35660: LD_VAR 0 1
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35672: LD_ADDR_EXP 137
35676: PUSH
35677: LD_EXP 137
35681: PPUSH
35682: LD_VAR 0 1
35686: PPUSH
35687: EMPTY
35688: PPUSH
35689: CALL_OW 1
35693: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35694: LD_ADDR_EXP 138
35698: PUSH
35699: LD_EXP 138
35703: PPUSH
35704: LD_VAR 0 1
35708: PPUSH
35709: EMPTY
35710: PPUSH
35711: CALL_OW 1
35715: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35716: LD_ADDR_EXP 139
35720: PUSH
35721: LD_EXP 139
35725: PPUSH
35726: LD_VAR 0 1
35730: PPUSH
35731: EMPTY
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35738: LD_ADDR_EXP 140
35742: PUSH
35743: LD_EXP 140
35747: PPUSH
35748: LD_VAR 0 1
35752: PPUSH
35753: EMPTY
35754: PPUSH
35755: CALL_OW 1
35759: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35760: LD_ADDR_EXP 141
35764: PUSH
35765: LD_EXP 141
35769: PPUSH
35770: LD_VAR 0 1
35774: PPUSH
35775: EMPTY
35776: PPUSH
35777: CALL_OW 1
35781: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35782: LD_ADDR_EXP 142
35786: PUSH
35787: LD_EXP 142
35791: PPUSH
35792: LD_VAR 0 1
35796: PPUSH
35797: EMPTY
35798: PPUSH
35799: CALL_OW 1
35803: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35804: LD_ADDR_EXP 143
35808: PUSH
35809: LD_EXP 143
35813: PPUSH
35814: LD_VAR 0 1
35818: PPUSH
35819: EMPTY
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35826: LD_ADDR_EXP 144
35830: PUSH
35831: LD_EXP 144
35835: PPUSH
35836: LD_VAR 0 1
35840: PPUSH
35841: LD_INT 0
35843: PPUSH
35844: CALL_OW 1
35848: ST_TO_ADDR
// end ;
35849: LD_VAR 0 2
35853: RET
// export function MC_Add ( side , units ) ; var base ; begin
35854: LD_INT 0
35856: PPUSH
35857: PPUSH
// base := mc_bases + 1 ;
35858: LD_ADDR_VAR 0 4
35862: PUSH
35863: LD_EXP 102
35867: PUSH
35868: LD_INT 1
35870: PLUS
35871: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35872: LD_ADDR_EXP 128
35876: PUSH
35877: LD_EXP 128
35881: PPUSH
35882: LD_VAR 0 4
35886: PPUSH
35887: LD_VAR 0 1
35891: PPUSH
35892: CALL_OW 1
35896: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35897: LD_ADDR_EXP 102
35901: PUSH
35902: LD_EXP 102
35906: PPUSH
35907: LD_VAR 0 4
35911: PPUSH
35912: LD_VAR 0 2
35916: PPUSH
35917: CALL_OW 1
35921: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35922: LD_ADDR_EXP 103
35926: PUSH
35927: LD_EXP 103
35931: PPUSH
35932: LD_VAR 0 4
35936: PPUSH
35937: EMPTY
35938: PPUSH
35939: CALL_OW 1
35943: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35944: LD_ADDR_EXP 104
35948: PUSH
35949: LD_EXP 104
35953: PPUSH
35954: LD_VAR 0 4
35958: PPUSH
35959: EMPTY
35960: PPUSH
35961: CALL_OW 1
35965: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35966: LD_ADDR_EXP 105
35970: PUSH
35971: LD_EXP 105
35975: PPUSH
35976: LD_VAR 0 4
35980: PPUSH
35981: EMPTY
35982: PPUSH
35983: CALL_OW 1
35987: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35988: LD_ADDR_EXP 106
35992: PUSH
35993: LD_EXP 106
35997: PPUSH
35998: LD_VAR 0 4
36002: PPUSH
36003: EMPTY
36004: PPUSH
36005: CALL_OW 1
36009: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36010: LD_ADDR_EXP 107
36014: PUSH
36015: LD_EXP 107
36019: PPUSH
36020: LD_VAR 0 4
36024: PPUSH
36025: EMPTY
36026: PPUSH
36027: CALL_OW 1
36031: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36032: LD_ADDR_EXP 108
36036: PUSH
36037: LD_EXP 108
36041: PPUSH
36042: LD_VAR 0 4
36046: PPUSH
36047: EMPTY
36048: PPUSH
36049: CALL_OW 1
36053: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36054: LD_ADDR_EXP 109
36058: PUSH
36059: LD_EXP 109
36063: PPUSH
36064: LD_VAR 0 4
36068: PPUSH
36069: EMPTY
36070: PPUSH
36071: CALL_OW 1
36075: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36076: LD_ADDR_EXP 110
36080: PUSH
36081: LD_EXP 110
36085: PPUSH
36086: LD_VAR 0 4
36090: PPUSH
36091: EMPTY
36092: PPUSH
36093: CALL_OW 1
36097: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36098: LD_ADDR_EXP 111
36102: PUSH
36103: LD_EXP 111
36107: PPUSH
36108: LD_VAR 0 4
36112: PPUSH
36113: EMPTY
36114: PPUSH
36115: CALL_OW 1
36119: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36120: LD_ADDR_EXP 112
36124: PUSH
36125: LD_EXP 112
36129: PPUSH
36130: LD_VAR 0 4
36134: PPUSH
36135: EMPTY
36136: PPUSH
36137: CALL_OW 1
36141: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36142: LD_ADDR_EXP 113
36146: PUSH
36147: LD_EXP 113
36151: PPUSH
36152: LD_VAR 0 4
36156: PPUSH
36157: LD_INT 0
36159: PPUSH
36160: CALL_OW 1
36164: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36165: LD_ADDR_EXP 114
36169: PUSH
36170: LD_EXP 114
36174: PPUSH
36175: LD_VAR 0 4
36179: PPUSH
36180: EMPTY
36181: PPUSH
36182: CALL_OW 1
36186: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36187: LD_ADDR_EXP 115
36191: PUSH
36192: LD_EXP 115
36196: PPUSH
36197: LD_VAR 0 4
36201: PPUSH
36202: EMPTY
36203: PPUSH
36204: CALL_OW 1
36208: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36209: LD_ADDR_EXP 116
36213: PUSH
36214: LD_EXP 116
36218: PPUSH
36219: LD_VAR 0 4
36223: PPUSH
36224: EMPTY
36225: PPUSH
36226: CALL_OW 1
36230: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36231: LD_ADDR_EXP 117
36235: PUSH
36236: LD_EXP 117
36240: PPUSH
36241: LD_VAR 0 4
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL_OW 1
36252: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36253: LD_ADDR_EXP 118
36257: PUSH
36258: LD_EXP 118
36262: PPUSH
36263: LD_VAR 0 4
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL_OW 1
36274: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36275: LD_ADDR_EXP 119
36279: PUSH
36280: LD_EXP 119
36284: PPUSH
36285: LD_VAR 0 4
36289: PPUSH
36290: EMPTY
36291: PPUSH
36292: CALL_OW 1
36296: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36297: LD_ADDR_EXP 120
36301: PUSH
36302: LD_EXP 120
36306: PPUSH
36307: LD_VAR 0 4
36311: PPUSH
36312: EMPTY
36313: PPUSH
36314: CALL_OW 1
36318: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36319: LD_ADDR_EXP 121
36323: PUSH
36324: LD_EXP 121
36328: PPUSH
36329: LD_VAR 0 4
36333: PPUSH
36334: EMPTY
36335: PPUSH
36336: CALL_OW 1
36340: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36341: LD_ADDR_EXP 122
36345: PUSH
36346: LD_EXP 122
36350: PPUSH
36351: LD_VAR 0 4
36355: PPUSH
36356: EMPTY
36357: PPUSH
36358: CALL_OW 1
36362: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36363: LD_ADDR_EXP 123
36367: PUSH
36368: LD_EXP 123
36372: PPUSH
36373: LD_VAR 0 4
36377: PPUSH
36378: EMPTY
36379: PPUSH
36380: CALL_OW 1
36384: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36385: LD_ADDR_EXP 124
36389: PUSH
36390: LD_EXP 124
36394: PPUSH
36395: LD_VAR 0 4
36399: PPUSH
36400: EMPTY
36401: PPUSH
36402: CALL_OW 1
36406: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36407: LD_ADDR_EXP 125
36411: PUSH
36412: LD_EXP 125
36416: PPUSH
36417: LD_VAR 0 4
36421: PPUSH
36422: EMPTY
36423: PPUSH
36424: CALL_OW 1
36428: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36429: LD_ADDR_EXP 126
36433: PUSH
36434: LD_EXP 126
36438: PPUSH
36439: LD_VAR 0 4
36443: PPUSH
36444: EMPTY
36445: PPUSH
36446: CALL_OW 1
36450: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36451: LD_ADDR_EXP 127
36455: PUSH
36456: LD_EXP 127
36460: PPUSH
36461: LD_VAR 0 4
36465: PPUSH
36466: EMPTY
36467: PPUSH
36468: CALL_OW 1
36472: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36473: LD_ADDR_EXP 129
36477: PUSH
36478: LD_EXP 129
36482: PPUSH
36483: LD_VAR 0 4
36487: PPUSH
36488: EMPTY
36489: PPUSH
36490: CALL_OW 1
36494: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36495: LD_ADDR_EXP 131
36499: PUSH
36500: LD_EXP 131
36504: PPUSH
36505: LD_VAR 0 4
36509: PPUSH
36510: EMPTY
36511: PPUSH
36512: CALL_OW 1
36516: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36517: LD_ADDR_EXP 132
36521: PUSH
36522: LD_EXP 132
36526: PPUSH
36527: LD_VAR 0 4
36531: PPUSH
36532: EMPTY
36533: PPUSH
36534: CALL_OW 1
36538: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36539: LD_ADDR_EXP 133
36543: PUSH
36544: LD_EXP 133
36548: PPUSH
36549: LD_VAR 0 4
36553: PPUSH
36554: EMPTY
36555: PPUSH
36556: CALL_OW 1
36560: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36561: LD_ADDR_EXP 134
36565: PUSH
36566: LD_EXP 134
36570: PPUSH
36571: LD_VAR 0 4
36575: PPUSH
36576: EMPTY
36577: PPUSH
36578: CALL_OW 1
36582: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36583: LD_ADDR_EXP 135
36587: PUSH
36588: LD_EXP 135
36592: PPUSH
36593: LD_VAR 0 4
36597: PPUSH
36598: EMPTY
36599: PPUSH
36600: CALL_OW 1
36604: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36605: LD_ADDR_EXP 136
36609: PUSH
36610: LD_EXP 136
36614: PPUSH
36615: LD_VAR 0 4
36619: PPUSH
36620: EMPTY
36621: PPUSH
36622: CALL_OW 1
36626: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36627: LD_ADDR_EXP 137
36631: PUSH
36632: LD_EXP 137
36636: PPUSH
36637: LD_VAR 0 4
36641: PPUSH
36642: EMPTY
36643: PPUSH
36644: CALL_OW 1
36648: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36649: LD_ADDR_EXP 138
36653: PUSH
36654: LD_EXP 138
36658: PPUSH
36659: LD_VAR 0 4
36663: PPUSH
36664: EMPTY
36665: PPUSH
36666: CALL_OW 1
36670: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36671: LD_ADDR_EXP 139
36675: PUSH
36676: LD_EXP 139
36680: PPUSH
36681: LD_VAR 0 4
36685: PPUSH
36686: EMPTY
36687: PPUSH
36688: CALL_OW 1
36692: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36693: LD_ADDR_EXP 140
36697: PUSH
36698: LD_EXP 140
36702: PPUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: EMPTY
36709: PPUSH
36710: CALL_OW 1
36714: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36715: LD_ADDR_EXP 141
36719: PUSH
36720: LD_EXP 141
36724: PPUSH
36725: LD_VAR 0 4
36729: PPUSH
36730: EMPTY
36731: PPUSH
36732: CALL_OW 1
36736: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36737: LD_ADDR_EXP 142
36741: PUSH
36742: LD_EXP 142
36746: PPUSH
36747: LD_VAR 0 4
36751: PPUSH
36752: EMPTY
36753: PPUSH
36754: CALL_OW 1
36758: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36759: LD_ADDR_EXP 143
36763: PUSH
36764: LD_EXP 143
36768: PPUSH
36769: LD_VAR 0 4
36773: PPUSH
36774: EMPTY
36775: PPUSH
36776: CALL_OW 1
36780: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36781: LD_ADDR_EXP 144
36785: PUSH
36786: LD_EXP 144
36790: PPUSH
36791: LD_VAR 0 4
36795: PPUSH
36796: LD_INT 0
36798: PPUSH
36799: CALL_OW 1
36803: ST_TO_ADDR
// result := base ;
36804: LD_ADDR_VAR 0 3
36808: PUSH
36809: LD_VAR 0 4
36813: ST_TO_ADDR
// end ;
36814: LD_VAR 0 3
36818: RET
// export function MC_Start ( ) ; var i ; begin
36819: LD_INT 0
36821: PPUSH
36822: PPUSH
// for i = 1 to mc_bases do
36823: LD_ADDR_VAR 0 2
36827: PUSH
36828: DOUBLE
36829: LD_INT 1
36831: DEC
36832: ST_TO_ADDR
36833: LD_EXP 102
36837: PUSH
36838: FOR_TO
36839: IFFALSE 37916
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36841: LD_ADDR_EXP 102
36845: PUSH
36846: LD_EXP 102
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: LD_EXP 102
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: PUSH
36867: LD_INT 0
36869: DIFF
36870: PPUSH
36871: CALL_OW 1
36875: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36876: LD_ADDR_EXP 103
36880: PUSH
36881: LD_EXP 103
36885: PPUSH
36886: LD_VAR 0 2
36890: PPUSH
36891: EMPTY
36892: PPUSH
36893: CALL_OW 1
36897: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36898: LD_ADDR_EXP 104
36902: PUSH
36903: LD_EXP 104
36907: PPUSH
36908: LD_VAR 0 2
36912: PPUSH
36913: EMPTY
36914: PPUSH
36915: CALL_OW 1
36919: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36920: LD_ADDR_EXP 105
36924: PUSH
36925: LD_EXP 105
36929: PPUSH
36930: LD_VAR 0 2
36934: PPUSH
36935: EMPTY
36936: PPUSH
36937: CALL_OW 1
36941: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36942: LD_ADDR_EXP 106
36946: PUSH
36947: LD_EXP 106
36951: PPUSH
36952: LD_VAR 0 2
36956: PPUSH
36957: EMPTY
36958: PUSH
36959: EMPTY
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PPUSH
36965: CALL_OW 1
36969: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36970: LD_ADDR_EXP 107
36974: PUSH
36975: LD_EXP 107
36979: PPUSH
36980: LD_VAR 0 2
36984: PPUSH
36985: EMPTY
36986: PPUSH
36987: CALL_OW 1
36991: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36992: LD_ADDR_EXP 134
36996: PUSH
36997: LD_EXP 134
37001: PPUSH
37002: LD_VAR 0 2
37006: PPUSH
37007: EMPTY
37008: PPUSH
37009: CALL_OW 1
37013: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37014: LD_ADDR_EXP 108
37018: PUSH
37019: LD_EXP 108
37023: PPUSH
37024: LD_VAR 0 2
37028: PPUSH
37029: EMPTY
37030: PPUSH
37031: CALL_OW 1
37035: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37036: LD_ADDR_EXP 109
37040: PUSH
37041: LD_EXP 109
37045: PPUSH
37046: LD_VAR 0 2
37050: PPUSH
37051: EMPTY
37052: PPUSH
37053: CALL_OW 1
37057: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37058: LD_ADDR_EXP 110
37062: PUSH
37063: LD_EXP 110
37067: PPUSH
37068: LD_VAR 0 2
37072: PPUSH
37073: LD_EXP 102
37077: PUSH
37078: LD_VAR 0 2
37082: ARRAY
37083: PPUSH
37084: LD_INT 2
37086: PUSH
37087: LD_INT 30
37089: PUSH
37090: LD_INT 32
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 30
37099: PUSH
37100: LD_INT 33
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: LIST
37111: PPUSH
37112: CALL_OW 72
37116: PPUSH
37117: CALL_OW 1
37121: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37122: LD_ADDR_EXP 111
37126: PUSH
37127: LD_EXP 111
37131: PPUSH
37132: LD_VAR 0 2
37136: PPUSH
37137: LD_EXP 102
37141: PUSH
37142: LD_VAR 0 2
37146: ARRAY
37147: PPUSH
37148: LD_INT 2
37150: PUSH
37151: LD_INT 30
37153: PUSH
37154: LD_INT 32
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 30
37163: PUSH
37164: LD_INT 31
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 58
37178: PUSH
37179: EMPTY
37180: LIST
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PPUSH
37186: CALL_OW 72
37190: PPUSH
37191: CALL_OW 1
37195: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37196: LD_ADDR_EXP 112
37200: PUSH
37201: LD_EXP 112
37205: PPUSH
37206: LD_VAR 0 2
37210: PPUSH
37211: EMPTY
37212: PPUSH
37213: CALL_OW 1
37217: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37218: LD_ADDR_EXP 116
37222: PUSH
37223: LD_EXP 116
37227: PPUSH
37228: LD_VAR 0 2
37232: PPUSH
37233: EMPTY
37234: PPUSH
37235: CALL_OW 1
37239: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37240: LD_ADDR_EXP 115
37244: PUSH
37245: LD_EXP 115
37249: PPUSH
37250: LD_VAR 0 2
37254: PPUSH
37255: EMPTY
37256: PPUSH
37257: CALL_OW 1
37261: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37262: LD_ADDR_EXP 117
37266: PUSH
37267: LD_EXP 117
37271: PPUSH
37272: LD_VAR 0 2
37276: PPUSH
37277: EMPTY
37278: PPUSH
37279: CALL_OW 1
37283: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37284: LD_ADDR_EXP 118
37288: PUSH
37289: LD_EXP 118
37293: PPUSH
37294: LD_VAR 0 2
37298: PPUSH
37299: EMPTY
37300: PPUSH
37301: CALL_OW 1
37305: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37306: LD_ADDR_EXP 119
37310: PUSH
37311: LD_EXP 119
37315: PPUSH
37316: LD_VAR 0 2
37320: PPUSH
37321: EMPTY
37322: PPUSH
37323: CALL_OW 1
37327: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37328: LD_ADDR_EXP 120
37332: PUSH
37333: LD_EXP 120
37337: PPUSH
37338: LD_VAR 0 2
37342: PPUSH
37343: EMPTY
37344: PPUSH
37345: CALL_OW 1
37349: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37350: LD_ADDR_EXP 121
37354: PUSH
37355: LD_EXP 121
37359: PPUSH
37360: LD_VAR 0 2
37364: PPUSH
37365: EMPTY
37366: PPUSH
37367: CALL_OW 1
37371: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37372: LD_ADDR_EXP 122
37376: PUSH
37377: LD_EXP 122
37381: PPUSH
37382: LD_VAR 0 2
37386: PPUSH
37387: EMPTY
37388: PPUSH
37389: CALL_OW 1
37393: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37394: LD_ADDR_EXP 123
37398: PUSH
37399: LD_EXP 123
37403: PPUSH
37404: LD_VAR 0 2
37408: PPUSH
37409: EMPTY
37410: PPUSH
37411: CALL_OW 1
37415: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37416: LD_ADDR_EXP 124
37420: PUSH
37421: LD_EXP 124
37425: PPUSH
37426: LD_VAR 0 2
37430: PPUSH
37431: EMPTY
37432: PPUSH
37433: CALL_OW 1
37437: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37438: LD_ADDR_EXP 113
37442: PUSH
37443: LD_EXP 113
37447: PPUSH
37448: LD_VAR 0 2
37452: PPUSH
37453: LD_INT 0
37455: PPUSH
37456: CALL_OW 1
37460: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37461: LD_ADDR_EXP 126
37465: PUSH
37466: LD_EXP 126
37470: PPUSH
37471: LD_VAR 0 2
37475: PPUSH
37476: LD_INT 0
37478: PPUSH
37479: CALL_OW 1
37483: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37484: LD_ADDR_EXP 114
37488: PUSH
37489: LD_EXP 114
37493: PPUSH
37494: LD_VAR 0 2
37498: PPUSH
37499: EMPTY
37500: PPUSH
37501: CALL_OW 1
37505: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37506: LD_ADDR_EXP 125
37510: PUSH
37511: LD_EXP 125
37515: PPUSH
37516: LD_VAR 0 2
37520: PPUSH
37521: LD_INT 0
37523: PPUSH
37524: CALL_OW 1
37528: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37529: LD_ADDR_EXP 127
37533: PUSH
37534: LD_EXP 127
37538: PPUSH
37539: LD_VAR 0 2
37543: PPUSH
37544: EMPTY
37545: PPUSH
37546: CALL_OW 1
37550: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37551: LD_ADDR_EXP 130
37555: PUSH
37556: LD_EXP 130
37560: PPUSH
37561: LD_VAR 0 2
37565: PPUSH
37566: LD_INT 0
37568: PPUSH
37569: CALL_OW 1
37573: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37574: LD_ADDR_EXP 131
37578: PUSH
37579: LD_EXP 131
37583: PPUSH
37584: LD_VAR 0 2
37588: PPUSH
37589: EMPTY
37590: PPUSH
37591: CALL_OW 1
37595: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37596: LD_ADDR_EXP 132
37600: PUSH
37601: LD_EXP 132
37605: PPUSH
37606: LD_VAR 0 2
37610: PPUSH
37611: EMPTY
37612: PPUSH
37613: CALL_OW 1
37617: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37618: LD_ADDR_EXP 133
37622: PUSH
37623: LD_EXP 133
37627: PPUSH
37628: LD_VAR 0 2
37632: PPUSH
37633: EMPTY
37634: PPUSH
37635: CALL_OW 1
37639: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37640: LD_ADDR_EXP 135
37644: PUSH
37645: LD_EXP 135
37649: PPUSH
37650: LD_VAR 0 2
37654: PPUSH
37655: LD_EXP 102
37659: PUSH
37660: LD_VAR 0 2
37664: ARRAY
37665: PPUSH
37666: LD_INT 2
37668: PUSH
37669: LD_INT 30
37671: PUSH
37672: LD_INT 6
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 30
37681: PUSH
37682: LD_INT 7
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 30
37691: PUSH
37692: LD_INT 8
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: PPUSH
37705: CALL_OW 72
37709: PPUSH
37710: CALL_OW 1
37714: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37715: LD_ADDR_EXP 136
37719: PUSH
37720: LD_EXP 136
37724: PPUSH
37725: LD_VAR 0 2
37729: PPUSH
37730: EMPTY
37731: PPUSH
37732: CALL_OW 1
37736: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37737: LD_ADDR_EXP 137
37741: PUSH
37742: LD_EXP 137
37746: PPUSH
37747: LD_VAR 0 2
37751: PPUSH
37752: EMPTY
37753: PPUSH
37754: CALL_OW 1
37758: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37759: LD_ADDR_EXP 138
37763: PUSH
37764: LD_EXP 138
37768: PPUSH
37769: LD_VAR 0 2
37773: PPUSH
37774: EMPTY
37775: PPUSH
37776: CALL_OW 1
37780: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37781: LD_ADDR_EXP 139
37785: PUSH
37786: LD_EXP 139
37790: PPUSH
37791: LD_VAR 0 2
37795: PPUSH
37796: EMPTY
37797: PPUSH
37798: CALL_OW 1
37802: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37803: LD_ADDR_EXP 140
37807: PUSH
37808: LD_EXP 140
37812: PPUSH
37813: LD_VAR 0 2
37817: PPUSH
37818: EMPTY
37819: PPUSH
37820: CALL_OW 1
37824: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37825: LD_ADDR_EXP 141
37829: PUSH
37830: LD_EXP 141
37834: PPUSH
37835: LD_VAR 0 2
37839: PPUSH
37840: EMPTY
37841: PPUSH
37842: CALL_OW 1
37846: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37847: LD_ADDR_EXP 142
37851: PUSH
37852: LD_EXP 142
37856: PPUSH
37857: LD_VAR 0 2
37861: PPUSH
37862: EMPTY
37863: PPUSH
37864: CALL_OW 1
37868: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37869: LD_ADDR_EXP 143
37873: PUSH
37874: LD_EXP 143
37878: PPUSH
37879: LD_VAR 0 2
37883: PPUSH
37884: EMPTY
37885: PPUSH
37886: CALL_OW 1
37890: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37891: LD_ADDR_EXP 144
37895: PUSH
37896: LD_EXP 144
37900: PPUSH
37901: LD_VAR 0 2
37905: PPUSH
37906: LD_INT 0
37908: PPUSH
37909: CALL_OW 1
37913: ST_TO_ADDR
// end ;
37914: GO 36838
37916: POP
37917: POP
// MC_InitSides ( ) ;
37918: CALL 38204 0 0
// MC_InitResearch ( ) ;
37922: CALL 37943 0 0
// CustomInitMacro ( ) ;
37926: CALL 463 0 0
// skirmish := true ;
37930: LD_ADDR_EXP 100
37934: PUSH
37935: LD_INT 1
37937: ST_TO_ADDR
// end ;
37938: LD_VAR 0 1
37942: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37943: LD_INT 0
37945: PPUSH
37946: PPUSH
37947: PPUSH
37948: PPUSH
37949: PPUSH
37950: PPUSH
// if not mc_bases then
37951: LD_EXP 102
37955: NOT
37956: IFFALSE 37960
// exit ;
37958: GO 38199
// for i = 1 to 8 do
37960: LD_ADDR_VAR 0 2
37964: PUSH
37965: DOUBLE
37966: LD_INT 1
37968: DEC
37969: ST_TO_ADDR
37970: LD_INT 8
37972: PUSH
37973: FOR_TO
37974: IFFALSE 38000
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37976: LD_ADDR_EXP 129
37980: PUSH
37981: LD_EXP 129
37985: PPUSH
37986: LD_VAR 0 2
37990: PPUSH
37991: EMPTY
37992: PPUSH
37993: CALL_OW 1
37997: ST_TO_ADDR
37998: GO 37973
38000: POP
38001: POP
// tmp := [ ] ;
38002: LD_ADDR_VAR 0 5
38006: PUSH
38007: EMPTY
38008: ST_TO_ADDR
// for i = 1 to mc_sides do
38009: LD_ADDR_VAR 0 2
38013: PUSH
38014: DOUBLE
38015: LD_INT 1
38017: DEC
38018: ST_TO_ADDR
38019: LD_EXP 128
38023: PUSH
38024: FOR_TO
38025: IFFALSE 38083
// if not mc_sides [ i ] in tmp then
38027: LD_EXP 128
38031: PUSH
38032: LD_VAR 0 2
38036: ARRAY
38037: PUSH
38038: LD_VAR 0 5
38042: IN
38043: NOT
38044: IFFALSE 38081
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38046: LD_ADDR_VAR 0 5
38050: PUSH
38051: LD_VAR 0 5
38055: PPUSH
38056: LD_VAR 0 5
38060: PUSH
38061: LD_INT 1
38063: PLUS
38064: PPUSH
38065: LD_EXP 128
38069: PUSH
38070: LD_VAR 0 2
38074: ARRAY
38075: PPUSH
38076: CALL_OW 2
38080: ST_TO_ADDR
38081: GO 38024
38083: POP
38084: POP
// if not tmp then
38085: LD_VAR 0 5
38089: NOT
38090: IFFALSE 38094
// exit ;
38092: GO 38199
// for j in tmp do
38094: LD_ADDR_VAR 0 3
38098: PUSH
38099: LD_VAR 0 5
38103: PUSH
38104: FOR_IN
38105: IFFALSE 38197
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38107: LD_ADDR_VAR 0 6
38111: PUSH
38112: LD_INT 22
38114: PUSH
38115: LD_VAR 0 3
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PPUSH
38124: CALL_OW 69
38128: ST_TO_ADDR
// if not un then
38129: LD_VAR 0 6
38133: NOT
38134: IFFALSE 38138
// continue ;
38136: GO 38104
// nation := GetNation ( un [ 1 ] ) ;
38138: LD_ADDR_VAR 0 4
38142: PUSH
38143: LD_VAR 0 6
38147: PUSH
38148: LD_INT 1
38150: ARRAY
38151: PPUSH
38152: CALL_OW 248
38156: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38157: LD_ADDR_EXP 129
38161: PUSH
38162: LD_EXP 129
38166: PPUSH
38167: LD_VAR 0 3
38171: PPUSH
38172: LD_VAR 0 3
38176: PPUSH
38177: LD_VAR 0 4
38181: PPUSH
38182: LD_INT 1
38184: PPUSH
38185: CALL 64809 0 3
38189: PPUSH
38190: CALL_OW 1
38194: ST_TO_ADDR
// end ;
38195: GO 38104
38197: POP
38198: POP
// end ;
38199: LD_VAR 0 1
38203: RET
// export function MC_InitSides ( ) ; var i ; begin
38204: LD_INT 0
38206: PPUSH
38207: PPUSH
// if not mc_bases then
38208: LD_EXP 102
38212: NOT
38213: IFFALSE 38217
// exit ;
38215: GO 38291
// for i = 1 to mc_bases do
38217: LD_ADDR_VAR 0 2
38221: PUSH
38222: DOUBLE
38223: LD_INT 1
38225: DEC
38226: ST_TO_ADDR
38227: LD_EXP 102
38231: PUSH
38232: FOR_TO
38233: IFFALSE 38289
// if mc_bases [ i ] then
38235: LD_EXP 102
38239: PUSH
38240: LD_VAR 0 2
38244: ARRAY
38245: IFFALSE 38287
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38247: LD_ADDR_EXP 128
38251: PUSH
38252: LD_EXP 128
38256: PPUSH
38257: LD_VAR 0 2
38261: PPUSH
38262: LD_EXP 102
38266: PUSH
38267: LD_VAR 0 2
38271: ARRAY
38272: PUSH
38273: LD_INT 1
38275: ARRAY
38276: PPUSH
38277: CALL_OW 255
38281: PPUSH
38282: CALL_OW 1
38286: ST_TO_ADDR
38287: GO 38232
38289: POP
38290: POP
// end ;
38291: LD_VAR 0 1
38295: RET
// every 0 0$01 trigger skirmish do
38296: LD_EXP 100
38300: IFFALSE 38454
38302: GO 38304
38304: DISABLE
// begin enable ;
38305: ENABLE
// MC_CheckBuildings ( ) ;
38306: CALL 42952 0 0
// MC_CheckPeopleLife ( ) ;
38310: CALL 43077 0 0
// RaiseSailEvent ( 100 ) ;
38314: LD_INT 100
38316: PPUSH
38317: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38321: LD_INT 103
38323: PPUSH
38324: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38328: LD_INT 104
38330: PPUSH
38331: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38335: LD_INT 105
38337: PPUSH
38338: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38342: LD_INT 106
38344: PPUSH
38345: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38349: LD_INT 107
38351: PPUSH
38352: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38356: LD_INT 108
38358: PPUSH
38359: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38363: LD_INT 109
38365: PPUSH
38366: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38370: LD_INT 110
38372: PPUSH
38373: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38377: LD_INT 111
38379: PPUSH
38380: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38384: LD_INT 112
38386: PPUSH
38387: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38391: LD_INT 113
38393: PPUSH
38394: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38398: LD_INT 120
38400: PPUSH
38401: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38405: LD_INT 121
38407: PPUSH
38408: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38412: LD_INT 122
38414: PPUSH
38415: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38419: LD_INT 123
38421: PPUSH
38422: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38426: LD_INT 124
38428: PPUSH
38429: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38433: LD_INT 125
38435: PPUSH
38436: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38440: LD_INT 126
38442: PPUSH
38443: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38447: LD_INT 200
38449: PPUSH
38450: CALL_OW 427
// end ;
38454: END
// on SailEvent ( event ) do begin if event < 100 then
38455: LD_VAR 0 1
38459: PUSH
38460: LD_INT 100
38462: LESS
38463: IFFALSE 38474
// CustomEvent ( event ) ;
38465: LD_VAR 0 1
38469: PPUSH
38470: CALL 33114 0 1
// if event = 100 then
38474: LD_VAR 0 1
38478: PUSH
38479: LD_INT 100
38481: EQUAL
38482: IFFALSE 38488
// MC_ClassManager ( ) ;
38484: CALL 38880 0 0
// if event = 101 then
38488: LD_VAR 0 1
38492: PUSH
38493: LD_INT 101
38495: EQUAL
38496: IFFALSE 38502
// MC_RepairBuildings ( ) ;
38498: CALL 43673 0 0
// if event = 102 then
38502: LD_VAR 0 1
38506: PUSH
38507: LD_INT 102
38509: EQUAL
38510: IFFALSE 38516
// MC_Heal ( ) ;
38512: CALL 44537 0 0
// if event = 103 then
38516: LD_VAR 0 1
38520: PUSH
38521: LD_INT 103
38523: EQUAL
38524: IFFALSE 38530
// MC_Build ( ) ;
38526: CALL 44959 0 0
// if event = 104 then
38530: LD_VAR 0 1
38534: PUSH
38535: LD_INT 104
38537: EQUAL
38538: IFFALSE 38544
// MC_TurretWeapon ( ) ;
38540: CALL 46572 0 0
// if event = 105 then
38544: LD_VAR 0 1
38548: PUSH
38549: LD_INT 105
38551: EQUAL
38552: IFFALSE 38558
// MC_BuildUpgrade ( ) ;
38554: CALL 46123 0 0
// if event = 106 then
38558: LD_VAR 0 1
38562: PUSH
38563: LD_INT 106
38565: EQUAL
38566: IFFALSE 38572
// MC_PlantMines ( ) ;
38568: CALL 47002 0 0
// if event = 107 then
38572: LD_VAR 0 1
38576: PUSH
38577: LD_INT 107
38579: EQUAL
38580: IFFALSE 38586
// MC_CollectCrates ( ) ;
38582: CALL 47800 0 0
// if event = 108 then
38586: LD_VAR 0 1
38590: PUSH
38591: LD_INT 108
38593: EQUAL
38594: IFFALSE 38600
// MC_LinkRemoteControl ( ) ;
38596: CALL 49576 0 0
// if event = 109 then
38600: LD_VAR 0 1
38604: PUSH
38605: LD_INT 109
38607: EQUAL
38608: IFFALSE 38614
// MC_ProduceVehicle ( ) ;
38610: CALL 49757 0 0
// if event = 110 then
38614: LD_VAR 0 1
38618: PUSH
38619: LD_INT 110
38621: EQUAL
38622: IFFALSE 38628
// MC_SendAttack ( ) ;
38624: CALL 50223 0 0
// if event = 111 then
38628: LD_VAR 0 1
38632: PUSH
38633: LD_INT 111
38635: EQUAL
38636: IFFALSE 38642
// MC_Defend ( ) ;
38638: CALL 50331 0 0
// if event = 112 then
38642: LD_VAR 0 1
38646: PUSH
38647: LD_INT 112
38649: EQUAL
38650: IFFALSE 38656
// MC_Research ( ) ;
38652: CALL 50936 0 0
// if event = 113 then
38656: LD_VAR 0 1
38660: PUSH
38661: LD_INT 113
38663: EQUAL
38664: IFFALSE 38670
// MC_MinesTrigger ( ) ;
38666: CALL 52050 0 0
// if event = 120 then
38670: LD_VAR 0 1
38674: PUSH
38675: LD_INT 120
38677: EQUAL
38678: IFFALSE 38684
// MC_RepairVehicle ( ) ;
38680: CALL 52149 0 0
// if event = 121 then
38684: LD_VAR 0 1
38688: PUSH
38689: LD_INT 121
38691: EQUAL
38692: IFFALSE 38698
// MC_TameApe ( ) ;
38694: CALL 52879 0 0
// if event = 122 then
38698: LD_VAR 0 1
38702: PUSH
38703: LD_INT 122
38705: EQUAL
38706: IFFALSE 38712
// MC_ChangeApeClass ( ) ;
38708: CALL 53708 0 0
// if event = 123 then
38712: LD_VAR 0 1
38716: PUSH
38717: LD_INT 123
38719: EQUAL
38720: IFFALSE 38726
// MC_Bazooka ( ) ;
38722: CALL 54358 0 0
// if event = 124 then
38726: LD_VAR 0 1
38730: PUSH
38731: LD_INT 124
38733: EQUAL
38734: IFFALSE 38740
// MC_TeleportExit ( ) ;
38736: CALL 54556 0 0
// if event = 125 then
38740: LD_VAR 0 1
38744: PUSH
38745: LD_INT 125
38747: EQUAL
38748: IFFALSE 38754
// MC_Deposits ( ) ;
38750: CALL 55203 0 0
// if event = 126 then
38754: LD_VAR 0 1
38758: PUSH
38759: LD_INT 126
38761: EQUAL
38762: IFFALSE 38768
// MC_RemoteDriver ( ) ;
38764: CALL 55828 0 0
// if event = 200 then
38768: LD_VAR 0 1
38772: PUSH
38773: LD_INT 200
38775: EQUAL
38776: IFFALSE 38782
// MC_Idle ( ) ;
38778: CALL 57777 0 0
// end ;
38782: PPOPN 1
38784: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38785: LD_INT 0
38787: PPUSH
38788: PPUSH
// if not mc_bases [ base ] or not tag then
38789: LD_EXP 102
38793: PUSH
38794: LD_VAR 0 1
38798: ARRAY
38799: NOT
38800: PUSH
38801: LD_VAR 0 2
38805: NOT
38806: OR
38807: IFFALSE 38811
// exit ;
38809: GO 38875
// for i in mc_bases [ base ] union mc_ape [ base ] do
38811: LD_ADDR_VAR 0 4
38815: PUSH
38816: LD_EXP 102
38820: PUSH
38821: LD_VAR 0 1
38825: ARRAY
38826: PUSH
38827: LD_EXP 131
38831: PUSH
38832: LD_VAR 0 1
38836: ARRAY
38837: UNION
38838: PUSH
38839: FOR_IN
38840: IFFALSE 38873
// if GetTag ( i ) = tag then
38842: LD_VAR 0 4
38846: PPUSH
38847: CALL_OW 110
38851: PUSH
38852: LD_VAR 0 2
38856: EQUAL
38857: IFFALSE 38871
// SetTag ( i , 0 ) ;
38859: LD_VAR 0 4
38863: PPUSH
38864: LD_INT 0
38866: PPUSH
38867: CALL_OW 109
38871: GO 38839
38873: POP
38874: POP
// end ;
38875: LD_VAR 0 3
38879: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38880: LD_INT 0
38882: PPUSH
38883: PPUSH
38884: PPUSH
38885: PPUSH
38886: PPUSH
38887: PPUSH
38888: PPUSH
38889: PPUSH
// if not mc_bases then
38890: LD_EXP 102
38894: NOT
38895: IFFALSE 38899
// exit ;
38897: GO 39357
// for i = 1 to mc_bases do
38899: LD_ADDR_VAR 0 2
38903: PUSH
38904: DOUBLE
38905: LD_INT 1
38907: DEC
38908: ST_TO_ADDR
38909: LD_EXP 102
38913: PUSH
38914: FOR_TO
38915: IFFALSE 39355
// begin tmp := MC_ClassCheckReq ( i ) ;
38917: LD_ADDR_VAR 0 4
38921: PUSH
38922: LD_VAR 0 2
38926: PPUSH
38927: CALL 39362 0 1
38931: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38932: LD_ADDR_EXP 143
38936: PUSH
38937: LD_EXP 143
38941: PPUSH
38942: LD_VAR 0 2
38946: PPUSH
38947: LD_VAR 0 4
38951: PPUSH
38952: CALL_OW 1
38956: ST_TO_ADDR
// if not tmp then
38957: LD_VAR 0 4
38961: NOT
38962: IFFALSE 38966
// continue ;
38964: GO 38914
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38966: LD_ADDR_VAR 0 6
38970: PUSH
38971: LD_EXP 102
38975: PUSH
38976: LD_VAR 0 2
38980: ARRAY
38981: PPUSH
38982: LD_INT 2
38984: PUSH
38985: LD_INT 30
38987: PUSH
38988: LD_INT 4
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 30
38997: PUSH
38998: LD_INT 5
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: LIST
39009: PPUSH
39010: CALL_OW 72
39014: PUSH
39015: LD_EXP 102
39019: PUSH
39020: LD_VAR 0 2
39024: ARRAY
39025: PPUSH
39026: LD_INT 2
39028: PUSH
39029: LD_INT 30
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 30
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: LIST
39053: PPUSH
39054: CALL_OW 72
39058: PUSH
39059: LD_EXP 102
39063: PUSH
39064: LD_VAR 0 2
39068: ARRAY
39069: PPUSH
39070: LD_INT 30
39072: PUSH
39073: LD_INT 3
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PPUSH
39080: CALL_OW 72
39084: PUSH
39085: LD_EXP 102
39089: PUSH
39090: LD_VAR 0 2
39094: ARRAY
39095: PPUSH
39096: LD_INT 2
39098: PUSH
39099: LD_INT 30
39101: PUSH
39102: LD_INT 6
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 30
39111: PUSH
39112: LD_INT 7
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 30
39121: PUSH
39122: LD_INT 8
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: LIST
39133: LIST
39134: PPUSH
39135: CALL_OW 72
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: LIST
39144: LIST
39145: ST_TO_ADDR
// for j = 1 to 4 do
39146: LD_ADDR_VAR 0 3
39150: PUSH
39151: DOUBLE
39152: LD_INT 1
39154: DEC
39155: ST_TO_ADDR
39156: LD_INT 4
39158: PUSH
39159: FOR_TO
39160: IFFALSE 39351
// begin if not tmp [ j ] then
39162: LD_VAR 0 4
39166: PUSH
39167: LD_VAR 0 3
39171: ARRAY
39172: NOT
39173: IFFALSE 39177
// continue ;
39175: GO 39159
// for p in tmp [ j ] do
39177: LD_ADDR_VAR 0 5
39181: PUSH
39182: LD_VAR 0 4
39186: PUSH
39187: LD_VAR 0 3
39191: ARRAY
39192: PUSH
39193: FOR_IN
39194: IFFALSE 39347
// begin if not b [ j ] then
39196: LD_VAR 0 6
39200: PUSH
39201: LD_VAR 0 3
39205: ARRAY
39206: NOT
39207: IFFALSE 39211
// break ;
39209: GO 39347
// e := 0 ;
39211: LD_ADDR_VAR 0 7
39215: PUSH
39216: LD_INT 0
39218: ST_TO_ADDR
// for k in b [ j ] do
39219: LD_ADDR_VAR 0 8
39223: PUSH
39224: LD_VAR 0 6
39228: PUSH
39229: LD_VAR 0 3
39233: ARRAY
39234: PUSH
39235: FOR_IN
39236: IFFALSE 39263
// if IsNotFull ( k ) then
39238: LD_VAR 0 8
39242: PPUSH
39243: CALL 69249 0 1
39247: IFFALSE 39261
// begin e := k ;
39249: LD_ADDR_VAR 0 7
39253: PUSH
39254: LD_VAR 0 8
39258: ST_TO_ADDR
// break ;
39259: GO 39263
// end ;
39261: GO 39235
39263: POP
39264: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39265: LD_VAR 0 7
39269: PUSH
39270: LD_VAR 0 5
39274: PPUSH
39275: LD_VAR 0 7
39279: PPUSH
39280: CALL 106371 0 2
39284: NOT
39285: AND
39286: IFFALSE 39345
// begin if IsInUnit ( p ) then
39288: LD_VAR 0 5
39292: PPUSH
39293: CALL_OW 310
39297: IFFALSE 39308
// ComExitBuilding ( p ) ;
39299: LD_VAR 0 5
39303: PPUSH
39304: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39308: LD_VAR 0 5
39312: PPUSH
39313: LD_VAR 0 7
39317: PPUSH
39318: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39322: LD_VAR 0 5
39326: PPUSH
39327: LD_VAR 0 3
39331: PPUSH
39332: CALL_OW 183
// AddComExitBuilding ( p ) ;
39336: LD_VAR 0 5
39340: PPUSH
39341: CALL_OW 182
// end ; end ;
39345: GO 39193
39347: POP
39348: POP
// end ;
39349: GO 39159
39351: POP
39352: POP
// end ;
39353: GO 38914
39355: POP
39356: POP
// end ;
39357: LD_VAR 0 1
39361: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39362: LD_INT 0
39364: PPUSH
39365: PPUSH
39366: PPUSH
39367: PPUSH
39368: PPUSH
39369: PPUSH
39370: PPUSH
39371: PPUSH
39372: PPUSH
39373: PPUSH
39374: PPUSH
39375: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39376: LD_VAR 0 1
39380: NOT
39381: PUSH
39382: LD_EXP 102
39386: PUSH
39387: LD_VAR 0 1
39391: ARRAY
39392: NOT
39393: OR
39394: PUSH
39395: LD_EXP 102
39399: PUSH
39400: LD_VAR 0 1
39404: ARRAY
39405: PPUSH
39406: LD_INT 2
39408: PUSH
39409: LD_INT 30
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 30
39421: PUSH
39422: LD_INT 1
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: LIST
39433: PPUSH
39434: CALL_OW 72
39438: NOT
39439: OR
39440: IFFALSE 39444
// exit ;
39442: GO 42947
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39444: LD_ADDR_VAR 0 4
39448: PUSH
39449: LD_EXP 102
39453: PUSH
39454: LD_VAR 0 1
39458: ARRAY
39459: PPUSH
39460: LD_INT 2
39462: PUSH
39463: LD_INT 25
39465: PUSH
39466: LD_INT 1
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 25
39475: PUSH
39476: LD_INT 2
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 25
39485: PUSH
39486: LD_INT 3
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 25
39495: PUSH
39496: LD_INT 4
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 25
39505: PUSH
39506: LD_INT 5
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 25
39515: PUSH
39516: LD_INT 8
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 25
39525: PUSH
39526: LD_INT 9
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: PPUSH
39543: CALL_OW 72
39547: ST_TO_ADDR
// if not tmp then
39548: LD_VAR 0 4
39552: NOT
39553: IFFALSE 39557
// exit ;
39555: GO 42947
// for i in tmp do
39557: LD_ADDR_VAR 0 3
39561: PUSH
39562: LD_VAR 0 4
39566: PUSH
39567: FOR_IN
39568: IFFALSE 39599
// if GetTag ( i ) then
39570: LD_VAR 0 3
39574: PPUSH
39575: CALL_OW 110
39579: IFFALSE 39597
// tmp := tmp diff i ;
39581: LD_ADDR_VAR 0 4
39585: PUSH
39586: LD_VAR 0 4
39590: PUSH
39591: LD_VAR 0 3
39595: DIFF
39596: ST_TO_ADDR
39597: GO 39567
39599: POP
39600: POP
// if not tmp then
39601: LD_VAR 0 4
39605: NOT
39606: IFFALSE 39610
// exit ;
39608: GO 42947
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39610: LD_ADDR_VAR 0 5
39614: PUSH
39615: LD_EXP 102
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: LD_INT 2
39628: PUSH
39629: LD_INT 25
39631: PUSH
39632: LD_INT 1
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 25
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 25
39651: PUSH
39652: LD_INT 8
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 25
39661: PUSH
39662: LD_INT 9
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: LIST
39675: PPUSH
39676: CALL_OW 72
39680: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39681: LD_ADDR_VAR 0 6
39685: PUSH
39686: LD_EXP 102
39690: PUSH
39691: LD_VAR 0 1
39695: ARRAY
39696: PPUSH
39697: LD_INT 25
39699: PUSH
39700: LD_INT 2
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PPUSH
39707: CALL_OW 72
39711: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39712: LD_ADDR_VAR 0 7
39716: PUSH
39717: LD_EXP 102
39721: PUSH
39722: LD_VAR 0 1
39726: ARRAY
39727: PPUSH
39728: LD_INT 25
39730: PUSH
39731: LD_INT 3
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PPUSH
39738: CALL_OW 72
39742: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39743: LD_ADDR_VAR 0 8
39747: PUSH
39748: LD_EXP 102
39752: PUSH
39753: LD_VAR 0 1
39757: ARRAY
39758: PPUSH
39759: LD_INT 25
39761: PUSH
39762: LD_INT 4
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 24
39771: PUSH
39772: LD_INT 251
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PPUSH
39783: CALL_OW 72
39787: ST_TO_ADDR
// if mc_scan [ base ] then
39788: LD_EXP 125
39792: PUSH
39793: LD_VAR 0 1
39797: ARRAY
39798: IFFALSE 40259
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39800: LD_ADDR_EXP 144
39804: PUSH
39805: LD_EXP 144
39809: PPUSH
39810: LD_VAR 0 1
39814: PPUSH
39815: LD_INT 4
39817: PPUSH
39818: CALL_OW 1
39822: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39823: LD_ADDR_VAR 0 12
39827: PUSH
39828: LD_EXP 102
39832: PUSH
39833: LD_VAR 0 1
39837: ARRAY
39838: PPUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 30
39844: PUSH
39845: LD_INT 4
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 30
39854: PUSH
39855: LD_INT 5
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: LIST
39866: PPUSH
39867: CALL_OW 72
39871: ST_TO_ADDR
// if not b then
39872: LD_VAR 0 12
39876: NOT
39877: IFFALSE 39881
// exit ;
39879: GO 42947
// p := [ ] ;
39881: LD_ADDR_VAR 0 11
39885: PUSH
39886: EMPTY
39887: ST_TO_ADDR
// if sci >= 2 then
39888: LD_VAR 0 8
39892: PUSH
39893: LD_INT 2
39895: GREATEREQUAL
39896: IFFALSE 39927
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39898: LD_ADDR_VAR 0 8
39902: PUSH
39903: LD_VAR 0 8
39907: PUSH
39908: LD_INT 1
39910: ARRAY
39911: PUSH
39912: LD_VAR 0 8
39916: PUSH
39917: LD_INT 2
39919: ARRAY
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: ST_TO_ADDR
39925: GO 39988
// if sci = 1 then
39927: LD_VAR 0 8
39931: PUSH
39932: LD_INT 1
39934: EQUAL
39935: IFFALSE 39956
// sci := [ sci [ 1 ] ] else
39937: LD_ADDR_VAR 0 8
39941: PUSH
39942: LD_VAR 0 8
39946: PUSH
39947: LD_INT 1
39949: ARRAY
39950: PUSH
39951: EMPTY
39952: LIST
39953: ST_TO_ADDR
39954: GO 39988
// if sci = 0 then
39956: LD_VAR 0 8
39960: PUSH
39961: LD_INT 0
39963: EQUAL
39964: IFFALSE 39988
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39966: LD_ADDR_VAR 0 11
39970: PUSH
39971: LD_VAR 0 4
39975: PPUSH
39976: LD_INT 4
39978: PPUSH
39979: CALL 106234 0 2
39983: PUSH
39984: LD_INT 1
39986: ARRAY
39987: ST_TO_ADDR
// if eng > 4 then
39988: LD_VAR 0 6
39992: PUSH
39993: LD_INT 4
39995: GREATER
39996: IFFALSE 40042
// for i = eng downto 4 do
39998: LD_ADDR_VAR 0 3
40002: PUSH
40003: DOUBLE
40004: LD_VAR 0 6
40008: INC
40009: ST_TO_ADDR
40010: LD_INT 4
40012: PUSH
40013: FOR_DOWNTO
40014: IFFALSE 40040
// eng := eng diff eng [ i ] ;
40016: LD_ADDR_VAR 0 6
40020: PUSH
40021: LD_VAR 0 6
40025: PUSH
40026: LD_VAR 0 6
40030: PUSH
40031: LD_VAR 0 3
40035: ARRAY
40036: DIFF
40037: ST_TO_ADDR
40038: GO 40013
40040: POP
40041: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40042: LD_ADDR_VAR 0 4
40046: PUSH
40047: LD_VAR 0 4
40051: PUSH
40052: LD_VAR 0 5
40056: PUSH
40057: LD_VAR 0 6
40061: UNION
40062: PUSH
40063: LD_VAR 0 7
40067: UNION
40068: PUSH
40069: LD_VAR 0 8
40073: UNION
40074: DIFF
40075: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40076: LD_ADDR_VAR 0 13
40080: PUSH
40081: LD_EXP 102
40085: PUSH
40086: LD_VAR 0 1
40090: ARRAY
40091: PPUSH
40092: LD_INT 2
40094: PUSH
40095: LD_INT 30
40097: PUSH
40098: LD_INT 32
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 30
40107: PUSH
40108: LD_INT 31
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: LIST
40119: PPUSH
40120: CALL_OW 72
40124: PUSH
40125: LD_EXP 102
40129: PUSH
40130: LD_VAR 0 1
40134: ARRAY
40135: PPUSH
40136: LD_INT 2
40138: PUSH
40139: LD_INT 30
40141: PUSH
40142: LD_INT 4
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 30
40151: PUSH
40152: LD_INT 5
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: LIST
40163: PPUSH
40164: CALL_OW 72
40168: PUSH
40169: LD_INT 6
40171: MUL
40172: PLUS
40173: ST_TO_ADDR
// if bcount < tmp then
40174: LD_VAR 0 13
40178: PUSH
40179: LD_VAR 0 4
40183: LESS
40184: IFFALSE 40230
// for i = tmp downto bcount do
40186: LD_ADDR_VAR 0 3
40190: PUSH
40191: DOUBLE
40192: LD_VAR 0 4
40196: INC
40197: ST_TO_ADDR
40198: LD_VAR 0 13
40202: PUSH
40203: FOR_DOWNTO
40204: IFFALSE 40228
// tmp := Delete ( tmp , tmp ) ;
40206: LD_ADDR_VAR 0 4
40210: PUSH
40211: LD_VAR 0 4
40215: PPUSH
40216: LD_VAR 0 4
40220: PPUSH
40221: CALL_OW 3
40225: ST_TO_ADDR
40226: GO 40203
40228: POP
40229: POP
// result := [ tmp , 0 , 0 , p ] ;
40230: LD_ADDR_VAR 0 2
40234: PUSH
40235: LD_VAR 0 4
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: LD_INT 0
40245: PUSH
40246: LD_VAR 0 11
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: ST_TO_ADDR
// exit ;
40257: GO 42947
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40259: LD_EXP 102
40263: PUSH
40264: LD_VAR 0 1
40268: ARRAY
40269: PPUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 30
40275: PUSH
40276: LD_INT 6
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 30
40285: PUSH
40286: LD_INT 7
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: PUSH
40293: LD_INT 30
40295: PUSH
40296: LD_INT 8
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: PPUSH
40309: CALL_OW 72
40313: NOT
40314: PUSH
40315: LD_EXP 102
40319: PUSH
40320: LD_VAR 0 1
40324: ARRAY
40325: PPUSH
40326: LD_INT 30
40328: PUSH
40329: LD_INT 3
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PPUSH
40336: CALL_OW 72
40340: NOT
40341: AND
40342: IFFALSE 40414
// begin if eng = tmp then
40344: LD_VAR 0 6
40348: PUSH
40349: LD_VAR 0 4
40353: EQUAL
40354: IFFALSE 40358
// exit ;
40356: GO 42947
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40358: LD_ADDR_EXP 144
40362: PUSH
40363: LD_EXP 144
40367: PPUSH
40368: LD_VAR 0 1
40372: PPUSH
40373: LD_INT 1
40375: PPUSH
40376: CALL_OW 1
40380: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40381: LD_ADDR_VAR 0 2
40385: PUSH
40386: LD_INT 0
40388: PUSH
40389: LD_VAR 0 4
40393: PUSH
40394: LD_VAR 0 6
40398: DIFF
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: LD_INT 0
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: ST_TO_ADDR
// exit ;
40412: GO 42947
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40414: LD_EXP 129
40418: PUSH
40419: LD_EXP 128
40423: PUSH
40424: LD_VAR 0 1
40428: ARRAY
40429: ARRAY
40430: PUSH
40431: LD_EXP 102
40435: PUSH
40436: LD_VAR 0 1
40440: ARRAY
40441: PPUSH
40442: LD_INT 2
40444: PUSH
40445: LD_INT 30
40447: PUSH
40448: LD_INT 6
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 7
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 30
40467: PUSH
40468: LD_INT 8
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: PPUSH
40481: CALL_OW 72
40485: AND
40486: PUSH
40487: LD_EXP 102
40491: PUSH
40492: LD_VAR 0 1
40496: ARRAY
40497: PPUSH
40498: LD_INT 30
40500: PUSH
40501: LD_INT 3
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PPUSH
40508: CALL_OW 72
40512: NOT
40513: AND
40514: IFFALSE 40728
// begin if sci >= 6 then
40516: LD_VAR 0 8
40520: PUSH
40521: LD_INT 6
40523: GREATEREQUAL
40524: IFFALSE 40528
// exit ;
40526: GO 42947
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40528: LD_ADDR_EXP 144
40532: PUSH
40533: LD_EXP 144
40537: PPUSH
40538: LD_VAR 0 1
40542: PPUSH
40543: LD_INT 2
40545: PPUSH
40546: CALL_OW 1
40550: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40551: LD_ADDR_VAR 0 9
40555: PUSH
40556: LD_VAR 0 4
40560: PUSH
40561: LD_VAR 0 8
40565: DIFF
40566: PPUSH
40567: LD_INT 4
40569: PPUSH
40570: CALL 106234 0 2
40574: ST_TO_ADDR
// p := [ ] ;
40575: LD_ADDR_VAR 0 11
40579: PUSH
40580: EMPTY
40581: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40582: LD_VAR 0 8
40586: PUSH
40587: LD_INT 6
40589: LESS
40590: PUSH
40591: LD_VAR 0 9
40595: PUSH
40596: LD_INT 6
40598: GREATER
40599: AND
40600: IFFALSE 40681
// begin for i = 1 to 6 - sci do
40602: LD_ADDR_VAR 0 3
40606: PUSH
40607: DOUBLE
40608: LD_INT 1
40610: DEC
40611: ST_TO_ADDR
40612: LD_INT 6
40614: PUSH
40615: LD_VAR 0 8
40619: MINUS
40620: PUSH
40621: FOR_TO
40622: IFFALSE 40677
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40624: LD_ADDR_VAR 0 11
40628: PUSH
40629: LD_VAR 0 11
40633: PPUSH
40634: LD_VAR 0 11
40638: PUSH
40639: LD_INT 1
40641: PLUS
40642: PPUSH
40643: LD_VAR 0 9
40647: PUSH
40648: LD_INT 1
40650: ARRAY
40651: PPUSH
40652: CALL_OW 2
40656: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40657: LD_ADDR_VAR 0 9
40661: PUSH
40662: LD_VAR 0 9
40666: PPUSH
40667: LD_INT 1
40669: PPUSH
40670: CALL_OW 3
40674: ST_TO_ADDR
// end ;
40675: GO 40621
40677: POP
40678: POP
// end else
40679: GO 40701
// if sort then
40681: LD_VAR 0 9
40685: IFFALSE 40701
// p := sort [ 1 ] ;
40687: LD_ADDR_VAR 0 11
40691: PUSH
40692: LD_VAR 0 9
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40701: LD_ADDR_VAR 0 2
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: LD_INT 0
40711: PUSH
40712: LD_INT 0
40714: PUSH
40715: LD_VAR 0 11
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: ST_TO_ADDR
// exit ;
40726: GO 42947
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40728: LD_EXP 129
40732: PUSH
40733: LD_EXP 128
40737: PUSH
40738: LD_VAR 0 1
40742: ARRAY
40743: ARRAY
40744: PUSH
40745: LD_EXP 102
40749: PUSH
40750: LD_VAR 0 1
40754: ARRAY
40755: PPUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 30
40761: PUSH
40762: LD_INT 6
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 30
40771: PUSH
40772: LD_INT 7
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 30
40781: PUSH
40782: LD_INT 8
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: LIST
40793: LIST
40794: PPUSH
40795: CALL_OW 72
40799: AND
40800: PUSH
40801: LD_EXP 102
40805: PUSH
40806: LD_VAR 0 1
40810: ARRAY
40811: PPUSH
40812: LD_INT 30
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PPUSH
40822: CALL_OW 72
40826: AND
40827: IFFALSE 41561
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40829: LD_ADDR_EXP 144
40833: PUSH
40834: LD_EXP 144
40838: PPUSH
40839: LD_VAR 0 1
40843: PPUSH
40844: LD_INT 3
40846: PPUSH
40847: CALL_OW 1
40851: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40852: LD_ADDR_VAR 0 2
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_INT 0
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: ST_TO_ADDR
// if not eng then
40875: LD_VAR 0 6
40879: NOT
40880: IFFALSE 40943
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40882: LD_ADDR_VAR 0 11
40886: PUSH
40887: LD_VAR 0 4
40891: PPUSH
40892: LD_INT 2
40894: PPUSH
40895: CALL 106234 0 2
40899: PUSH
40900: LD_INT 1
40902: ARRAY
40903: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40904: LD_ADDR_VAR 0 2
40908: PUSH
40909: LD_VAR 0 2
40913: PPUSH
40914: LD_INT 2
40916: PPUSH
40917: LD_VAR 0 11
40921: PPUSH
40922: CALL_OW 1
40926: ST_TO_ADDR
// tmp := tmp diff p ;
40927: LD_ADDR_VAR 0 4
40931: PUSH
40932: LD_VAR 0 4
40936: PUSH
40937: LD_VAR 0 11
40941: DIFF
40942: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40943: LD_VAR 0 4
40947: PUSH
40948: LD_VAR 0 8
40952: PUSH
40953: LD_INT 6
40955: LESS
40956: AND
40957: IFFALSE 41145
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40959: LD_ADDR_VAR 0 9
40963: PUSH
40964: LD_VAR 0 4
40968: PUSH
40969: LD_VAR 0 8
40973: PUSH
40974: LD_VAR 0 7
40978: UNION
40979: DIFF
40980: PPUSH
40981: LD_INT 4
40983: PPUSH
40984: CALL 106234 0 2
40988: ST_TO_ADDR
// p := [ ] ;
40989: LD_ADDR_VAR 0 11
40993: PUSH
40994: EMPTY
40995: ST_TO_ADDR
// if sort then
40996: LD_VAR 0 9
41000: IFFALSE 41116
// for i = 1 to 6 - sci do
41002: LD_ADDR_VAR 0 3
41006: PUSH
41007: DOUBLE
41008: LD_INT 1
41010: DEC
41011: ST_TO_ADDR
41012: LD_INT 6
41014: PUSH
41015: LD_VAR 0 8
41019: MINUS
41020: PUSH
41021: FOR_TO
41022: IFFALSE 41114
// begin if i = sort then
41024: LD_VAR 0 3
41028: PUSH
41029: LD_VAR 0 9
41033: EQUAL
41034: IFFALSE 41038
// break ;
41036: GO 41114
// if GetClass ( i ) = 4 then
41038: LD_VAR 0 3
41042: PPUSH
41043: CALL_OW 257
41047: PUSH
41048: LD_INT 4
41050: EQUAL
41051: IFFALSE 41055
// continue ;
41053: GO 41021
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41055: LD_ADDR_VAR 0 11
41059: PUSH
41060: LD_VAR 0 11
41064: PPUSH
41065: LD_VAR 0 11
41069: PUSH
41070: LD_INT 1
41072: PLUS
41073: PPUSH
41074: LD_VAR 0 9
41078: PUSH
41079: LD_VAR 0 3
41083: ARRAY
41084: PPUSH
41085: CALL_OW 2
41089: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41090: LD_ADDR_VAR 0 4
41094: PUSH
41095: LD_VAR 0 4
41099: PUSH
41100: LD_VAR 0 9
41104: PUSH
41105: LD_VAR 0 3
41109: ARRAY
41110: DIFF
41111: ST_TO_ADDR
// end ;
41112: GO 41021
41114: POP
41115: POP
// if p then
41116: LD_VAR 0 11
41120: IFFALSE 41145
// result := Replace ( result , 4 , p ) ;
41122: LD_ADDR_VAR 0 2
41126: PUSH
41127: LD_VAR 0 2
41131: PPUSH
41132: LD_INT 4
41134: PPUSH
41135: LD_VAR 0 11
41139: PPUSH
41140: CALL_OW 1
41144: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41145: LD_VAR 0 4
41149: PUSH
41150: LD_VAR 0 7
41154: PUSH
41155: LD_INT 6
41157: LESS
41158: AND
41159: IFFALSE 41347
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41161: LD_ADDR_VAR 0 9
41165: PUSH
41166: LD_VAR 0 4
41170: PUSH
41171: LD_VAR 0 8
41175: PUSH
41176: LD_VAR 0 7
41180: UNION
41181: DIFF
41182: PPUSH
41183: LD_INT 3
41185: PPUSH
41186: CALL 106234 0 2
41190: ST_TO_ADDR
// p := [ ] ;
41191: LD_ADDR_VAR 0 11
41195: PUSH
41196: EMPTY
41197: ST_TO_ADDR
// if sort then
41198: LD_VAR 0 9
41202: IFFALSE 41318
// for i = 1 to 6 - mech do
41204: LD_ADDR_VAR 0 3
41208: PUSH
41209: DOUBLE
41210: LD_INT 1
41212: DEC
41213: ST_TO_ADDR
41214: LD_INT 6
41216: PUSH
41217: LD_VAR 0 7
41221: MINUS
41222: PUSH
41223: FOR_TO
41224: IFFALSE 41316
// begin if i = sort then
41226: LD_VAR 0 3
41230: PUSH
41231: LD_VAR 0 9
41235: EQUAL
41236: IFFALSE 41240
// break ;
41238: GO 41316
// if GetClass ( i ) = 3 then
41240: LD_VAR 0 3
41244: PPUSH
41245: CALL_OW 257
41249: PUSH
41250: LD_INT 3
41252: EQUAL
41253: IFFALSE 41257
// continue ;
41255: GO 41223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41257: LD_ADDR_VAR 0 11
41261: PUSH
41262: LD_VAR 0 11
41266: PPUSH
41267: LD_VAR 0 11
41271: PUSH
41272: LD_INT 1
41274: PLUS
41275: PPUSH
41276: LD_VAR 0 9
41280: PUSH
41281: LD_VAR 0 3
41285: ARRAY
41286: PPUSH
41287: CALL_OW 2
41291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41292: LD_ADDR_VAR 0 4
41296: PUSH
41297: LD_VAR 0 4
41301: PUSH
41302: LD_VAR 0 9
41306: PUSH
41307: LD_VAR 0 3
41311: ARRAY
41312: DIFF
41313: ST_TO_ADDR
// end ;
41314: GO 41223
41316: POP
41317: POP
// if p then
41318: LD_VAR 0 11
41322: IFFALSE 41347
// result := Replace ( result , 3 , p ) ;
41324: LD_ADDR_VAR 0 2
41328: PUSH
41329: LD_VAR 0 2
41333: PPUSH
41334: LD_INT 3
41336: PPUSH
41337: LD_VAR 0 11
41341: PPUSH
41342: CALL_OW 1
41346: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41347: LD_VAR 0 4
41351: PUSH
41352: LD_INT 6
41354: GREATER
41355: PUSH
41356: LD_VAR 0 6
41360: PUSH
41361: LD_INT 6
41363: LESS
41364: AND
41365: IFFALSE 41559
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41367: LD_ADDR_VAR 0 9
41371: PUSH
41372: LD_VAR 0 4
41376: PUSH
41377: LD_VAR 0 8
41381: PUSH
41382: LD_VAR 0 7
41386: UNION
41387: PUSH
41388: LD_VAR 0 6
41392: UNION
41393: DIFF
41394: PPUSH
41395: LD_INT 2
41397: PPUSH
41398: CALL 106234 0 2
41402: ST_TO_ADDR
// p := [ ] ;
41403: LD_ADDR_VAR 0 11
41407: PUSH
41408: EMPTY
41409: ST_TO_ADDR
// if sort then
41410: LD_VAR 0 9
41414: IFFALSE 41530
// for i = 1 to 6 - eng do
41416: LD_ADDR_VAR 0 3
41420: PUSH
41421: DOUBLE
41422: LD_INT 1
41424: DEC
41425: ST_TO_ADDR
41426: LD_INT 6
41428: PUSH
41429: LD_VAR 0 6
41433: MINUS
41434: PUSH
41435: FOR_TO
41436: IFFALSE 41528
// begin if i = sort then
41438: LD_VAR 0 3
41442: PUSH
41443: LD_VAR 0 9
41447: EQUAL
41448: IFFALSE 41452
// break ;
41450: GO 41528
// if GetClass ( i ) = 2 then
41452: LD_VAR 0 3
41456: PPUSH
41457: CALL_OW 257
41461: PUSH
41462: LD_INT 2
41464: EQUAL
41465: IFFALSE 41469
// continue ;
41467: GO 41435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41469: LD_ADDR_VAR 0 11
41473: PUSH
41474: LD_VAR 0 11
41478: PPUSH
41479: LD_VAR 0 11
41483: PUSH
41484: LD_INT 1
41486: PLUS
41487: PPUSH
41488: LD_VAR 0 9
41492: PUSH
41493: LD_VAR 0 3
41497: ARRAY
41498: PPUSH
41499: CALL_OW 2
41503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41504: LD_ADDR_VAR 0 4
41508: PUSH
41509: LD_VAR 0 4
41513: PUSH
41514: LD_VAR 0 9
41518: PUSH
41519: LD_VAR 0 3
41523: ARRAY
41524: DIFF
41525: ST_TO_ADDR
// end ;
41526: GO 41435
41528: POP
41529: POP
// if p then
41530: LD_VAR 0 11
41534: IFFALSE 41559
// result := Replace ( result , 2 , p ) ;
41536: LD_ADDR_VAR 0 2
41540: PUSH
41541: LD_VAR 0 2
41545: PPUSH
41546: LD_INT 2
41548: PPUSH
41549: LD_VAR 0 11
41553: PPUSH
41554: CALL_OW 1
41558: ST_TO_ADDR
// end ; exit ;
41559: GO 42947
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41561: LD_EXP 129
41565: PUSH
41566: LD_EXP 128
41570: PUSH
41571: LD_VAR 0 1
41575: ARRAY
41576: ARRAY
41577: NOT
41578: PUSH
41579: LD_EXP 102
41583: PUSH
41584: LD_VAR 0 1
41588: ARRAY
41589: PPUSH
41590: LD_INT 30
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PPUSH
41600: CALL_OW 72
41604: AND
41605: PUSH
41606: LD_EXP 107
41610: PUSH
41611: LD_VAR 0 1
41615: ARRAY
41616: AND
41617: IFFALSE 42225
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41619: LD_ADDR_EXP 144
41623: PUSH
41624: LD_EXP 144
41628: PPUSH
41629: LD_VAR 0 1
41633: PPUSH
41634: LD_INT 5
41636: PPUSH
41637: CALL_OW 1
41641: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41642: LD_ADDR_VAR 0 2
41646: PUSH
41647: LD_INT 0
41649: PUSH
41650: LD_INT 0
41652: PUSH
41653: LD_INT 0
41655: PUSH
41656: LD_INT 0
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: ST_TO_ADDR
// if sci > 1 then
41665: LD_VAR 0 8
41669: PUSH
41670: LD_INT 1
41672: GREATER
41673: IFFALSE 41701
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41675: LD_ADDR_VAR 0 4
41679: PUSH
41680: LD_VAR 0 4
41684: PUSH
41685: LD_VAR 0 8
41689: PUSH
41690: LD_VAR 0 8
41694: PUSH
41695: LD_INT 1
41697: ARRAY
41698: DIFF
41699: DIFF
41700: ST_TO_ADDR
// if tmp and not sci then
41701: LD_VAR 0 4
41705: PUSH
41706: LD_VAR 0 8
41710: NOT
41711: AND
41712: IFFALSE 41781
// begin sort := SortBySkill ( tmp , 4 ) ;
41714: LD_ADDR_VAR 0 9
41718: PUSH
41719: LD_VAR 0 4
41723: PPUSH
41724: LD_INT 4
41726: PPUSH
41727: CALL 106234 0 2
41731: ST_TO_ADDR
// if sort then
41732: LD_VAR 0 9
41736: IFFALSE 41752
// p := sort [ 1 ] ;
41738: LD_ADDR_VAR 0 11
41742: PUSH
41743: LD_VAR 0 9
41747: PUSH
41748: LD_INT 1
41750: ARRAY
41751: ST_TO_ADDR
// if p then
41752: LD_VAR 0 11
41756: IFFALSE 41781
// result := Replace ( result , 4 , p ) ;
41758: LD_ADDR_VAR 0 2
41762: PUSH
41763: LD_VAR 0 2
41767: PPUSH
41768: LD_INT 4
41770: PPUSH
41771: LD_VAR 0 11
41775: PPUSH
41776: CALL_OW 1
41780: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41781: LD_ADDR_VAR 0 4
41785: PUSH
41786: LD_VAR 0 4
41790: PUSH
41791: LD_VAR 0 7
41795: DIFF
41796: ST_TO_ADDR
// if tmp and mech < 6 then
41797: LD_VAR 0 4
41801: PUSH
41802: LD_VAR 0 7
41806: PUSH
41807: LD_INT 6
41809: LESS
41810: AND
41811: IFFALSE 41999
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41813: LD_ADDR_VAR 0 9
41817: PUSH
41818: LD_VAR 0 4
41822: PUSH
41823: LD_VAR 0 8
41827: PUSH
41828: LD_VAR 0 7
41832: UNION
41833: DIFF
41834: PPUSH
41835: LD_INT 3
41837: PPUSH
41838: CALL 106234 0 2
41842: ST_TO_ADDR
// p := [ ] ;
41843: LD_ADDR_VAR 0 11
41847: PUSH
41848: EMPTY
41849: ST_TO_ADDR
// if sort then
41850: LD_VAR 0 9
41854: IFFALSE 41970
// for i = 1 to 6 - mech do
41856: LD_ADDR_VAR 0 3
41860: PUSH
41861: DOUBLE
41862: LD_INT 1
41864: DEC
41865: ST_TO_ADDR
41866: LD_INT 6
41868: PUSH
41869: LD_VAR 0 7
41873: MINUS
41874: PUSH
41875: FOR_TO
41876: IFFALSE 41968
// begin if i = sort then
41878: LD_VAR 0 3
41882: PUSH
41883: LD_VAR 0 9
41887: EQUAL
41888: IFFALSE 41892
// break ;
41890: GO 41968
// if GetClass ( i ) = 3 then
41892: LD_VAR 0 3
41896: PPUSH
41897: CALL_OW 257
41901: PUSH
41902: LD_INT 3
41904: EQUAL
41905: IFFALSE 41909
// continue ;
41907: GO 41875
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41909: LD_ADDR_VAR 0 11
41913: PUSH
41914: LD_VAR 0 11
41918: PPUSH
41919: LD_VAR 0 11
41923: PUSH
41924: LD_INT 1
41926: PLUS
41927: PPUSH
41928: LD_VAR 0 9
41932: PUSH
41933: LD_VAR 0 3
41937: ARRAY
41938: PPUSH
41939: CALL_OW 2
41943: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41944: LD_ADDR_VAR 0 4
41948: PUSH
41949: LD_VAR 0 4
41953: PUSH
41954: LD_VAR 0 9
41958: PUSH
41959: LD_VAR 0 3
41963: ARRAY
41964: DIFF
41965: ST_TO_ADDR
// end ;
41966: GO 41875
41968: POP
41969: POP
// if p then
41970: LD_VAR 0 11
41974: IFFALSE 41999
// result := Replace ( result , 3 , p ) ;
41976: LD_ADDR_VAR 0 2
41980: PUSH
41981: LD_VAR 0 2
41985: PPUSH
41986: LD_INT 3
41988: PPUSH
41989: LD_VAR 0 11
41993: PPUSH
41994: CALL_OW 1
41998: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41999: LD_ADDR_VAR 0 4
42003: PUSH
42004: LD_VAR 0 4
42008: PUSH
42009: LD_VAR 0 6
42013: DIFF
42014: ST_TO_ADDR
// if tmp and eng < 6 then
42015: LD_VAR 0 4
42019: PUSH
42020: LD_VAR 0 6
42024: PUSH
42025: LD_INT 6
42027: LESS
42028: AND
42029: IFFALSE 42223
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42031: LD_ADDR_VAR 0 9
42035: PUSH
42036: LD_VAR 0 4
42040: PUSH
42041: LD_VAR 0 8
42045: PUSH
42046: LD_VAR 0 7
42050: UNION
42051: PUSH
42052: LD_VAR 0 6
42056: UNION
42057: DIFF
42058: PPUSH
42059: LD_INT 2
42061: PPUSH
42062: CALL 106234 0 2
42066: ST_TO_ADDR
// p := [ ] ;
42067: LD_ADDR_VAR 0 11
42071: PUSH
42072: EMPTY
42073: ST_TO_ADDR
// if sort then
42074: LD_VAR 0 9
42078: IFFALSE 42194
// for i = 1 to 6 - eng do
42080: LD_ADDR_VAR 0 3
42084: PUSH
42085: DOUBLE
42086: LD_INT 1
42088: DEC
42089: ST_TO_ADDR
42090: LD_INT 6
42092: PUSH
42093: LD_VAR 0 6
42097: MINUS
42098: PUSH
42099: FOR_TO
42100: IFFALSE 42192
// begin if i = sort then
42102: LD_VAR 0 3
42106: PUSH
42107: LD_VAR 0 9
42111: EQUAL
42112: IFFALSE 42116
// break ;
42114: GO 42192
// if GetClass ( i ) = 2 then
42116: LD_VAR 0 3
42120: PPUSH
42121: CALL_OW 257
42125: PUSH
42126: LD_INT 2
42128: EQUAL
42129: IFFALSE 42133
// continue ;
42131: GO 42099
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42133: LD_ADDR_VAR 0 11
42137: PUSH
42138: LD_VAR 0 11
42142: PPUSH
42143: LD_VAR 0 11
42147: PUSH
42148: LD_INT 1
42150: PLUS
42151: PPUSH
42152: LD_VAR 0 9
42156: PUSH
42157: LD_VAR 0 3
42161: ARRAY
42162: PPUSH
42163: CALL_OW 2
42167: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42168: LD_ADDR_VAR 0 4
42172: PUSH
42173: LD_VAR 0 4
42177: PUSH
42178: LD_VAR 0 9
42182: PUSH
42183: LD_VAR 0 3
42187: ARRAY
42188: DIFF
42189: ST_TO_ADDR
// end ;
42190: GO 42099
42192: POP
42193: POP
// if p then
42194: LD_VAR 0 11
42198: IFFALSE 42223
// result := Replace ( result , 2 , p ) ;
42200: LD_ADDR_VAR 0 2
42204: PUSH
42205: LD_VAR 0 2
42209: PPUSH
42210: LD_INT 2
42212: PPUSH
42213: LD_VAR 0 11
42217: PPUSH
42218: CALL_OW 1
42222: ST_TO_ADDR
// end ; exit ;
42223: GO 42947
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42225: LD_EXP 129
42229: PUSH
42230: LD_EXP 128
42234: PUSH
42235: LD_VAR 0 1
42239: ARRAY
42240: ARRAY
42241: NOT
42242: PUSH
42243: LD_EXP 102
42247: PUSH
42248: LD_VAR 0 1
42252: ARRAY
42253: PPUSH
42254: LD_INT 30
42256: PUSH
42257: LD_INT 3
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PPUSH
42264: CALL_OW 72
42268: AND
42269: PUSH
42270: LD_EXP 107
42274: PUSH
42275: LD_VAR 0 1
42279: ARRAY
42280: NOT
42281: AND
42282: IFFALSE 42947
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42284: LD_ADDR_EXP 144
42288: PUSH
42289: LD_EXP 144
42293: PPUSH
42294: LD_VAR 0 1
42298: PPUSH
42299: LD_INT 6
42301: PPUSH
42302: CALL_OW 1
42306: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42307: LD_ADDR_VAR 0 2
42311: PUSH
42312: LD_INT 0
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: LD_INT 0
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: ST_TO_ADDR
// if sci >= 1 then
42330: LD_VAR 0 8
42334: PUSH
42335: LD_INT 1
42337: GREATEREQUAL
42338: IFFALSE 42360
// tmp := tmp diff sci [ 1 ] ;
42340: LD_ADDR_VAR 0 4
42344: PUSH
42345: LD_VAR 0 4
42349: PUSH
42350: LD_VAR 0 8
42354: PUSH
42355: LD_INT 1
42357: ARRAY
42358: DIFF
42359: ST_TO_ADDR
// if tmp and not sci then
42360: LD_VAR 0 4
42364: PUSH
42365: LD_VAR 0 8
42369: NOT
42370: AND
42371: IFFALSE 42440
// begin sort := SortBySkill ( tmp , 4 ) ;
42373: LD_ADDR_VAR 0 9
42377: PUSH
42378: LD_VAR 0 4
42382: PPUSH
42383: LD_INT 4
42385: PPUSH
42386: CALL 106234 0 2
42390: ST_TO_ADDR
// if sort then
42391: LD_VAR 0 9
42395: IFFALSE 42411
// p := sort [ 1 ] ;
42397: LD_ADDR_VAR 0 11
42401: PUSH
42402: LD_VAR 0 9
42406: PUSH
42407: LD_INT 1
42409: ARRAY
42410: ST_TO_ADDR
// if p then
42411: LD_VAR 0 11
42415: IFFALSE 42440
// result := Replace ( result , 4 , p ) ;
42417: LD_ADDR_VAR 0 2
42421: PUSH
42422: LD_VAR 0 2
42426: PPUSH
42427: LD_INT 4
42429: PPUSH
42430: LD_VAR 0 11
42434: PPUSH
42435: CALL_OW 1
42439: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42440: LD_ADDR_VAR 0 4
42444: PUSH
42445: LD_VAR 0 4
42449: PUSH
42450: LD_VAR 0 7
42454: DIFF
42455: ST_TO_ADDR
// if tmp and mech < 6 then
42456: LD_VAR 0 4
42460: PUSH
42461: LD_VAR 0 7
42465: PUSH
42466: LD_INT 6
42468: LESS
42469: AND
42470: IFFALSE 42652
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42472: LD_ADDR_VAR 0 9
42476: PUSH
42477: LD_VAR 0 4
42481: PUSH
42482: LD_VAR 0 7
42486: DIFF
42487: PPUSH
42488: LD_INT 3
42490: PPUSH
42491: CALL 106234 0 2
42495: ST_TO_ADDR
// p := [ ] ;
42496: LD_ADDR_VAR 0 11
42500: PUSH
42501: EMPTY
42502: ST_TO_ADDR
// if sort then
42503: LD_VAR 0 9
42507: IFFALSE 42623
// for i = 1 to 6 - mech do
42509: LD_ADDR_VAR 0 3
42513: PUSH
42514: DOUBLE
42515: LD_INT 1
42517: DEC
42518: ST_TO_ADDR
42519: LD_INT 6
42521: PUSH
42522: LD_VAR 0 7
42526: MINUS
42527: PUSH
42528: FOR_TO
42529: IFFALSE 42621
// begin if i = sort then
42531: LD_VAR 0 3
42535: PUSH
42536: LD_VAR 0 9
42540: EQUAL
42541: IFFALSE 42545
// break ;
42543: GO 42621
// if GetClass ( i ) = 3 then
42545: LD_VAR 0 3
42549: PPUSH
42550: CALL_OW 257
42554: PUSH
42555: LD_INT 3
42557: EQUAL
42558: IFFALSE 42562
// continue ;
42560: GO 42528
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42562: LD_ADDR_VAR 0 11
42566: PUSH
42567: LD_VAR 0 11
42571: PPUSH
42572: LD_VAR 0 11
42576: PUSH
42577: LD_INT 1
42579: PLUS
42580: PPUSH
42581: LD_VAR 0 9
42585: PUSH
42586: LD_VAR 0 3
42590: ARRAY
42591: PPUSH
42592: CALL_OW 2
42596: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42597: LD_ADDR_VAR 0 4
42601: PUSH
42602: LD_VAR 0 4
42606: PUSH
42607: LD_VAR 0 9
42611: PUSH
42612: LD_VAR 0 3
42616: ARRAY
42617: DIFF
42618: ST_TO_ADDR
// end ;
42619: GO 42528
42621: POP
42622: POP
// if p then
42623: LD_VAR 0 11
42627: IFFALSE 42652
// result := Replace ( result , 3 , p ) ;
42629: LD_ADDR_VAR 0 2
42633: PUSH
42634: LD_VAR 0 2
42638: PPUSH
42639: LD_INT 3
42641: PPUSH
42642: LD_VAR 0 11
42646: PPUSH
42647: CALL_OW 1
42651: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42652: LD_ADDR_VAR 0 4
42656: PUSH
42657: LD_VAR 0 4
42661: PUSH
42662: LD_VAR 0 6
42666: DIFF
42667: ST_TO_ADDR
// if tmp and eng < 4 then
42668: LD_VAR 0 4
42672: PUSH
42673: LD_VAR 0 6
42677: PUSH
42678: LD_INT 4
42680: LESS
42681: AND
42682: IFFALSE 42872
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42684: LD_ADDR_VAR 0 9
42688: PUSH
42689: LD_VAR 0 4
42693: PUSH
42694: LD_VAR 0 7
42698: PUSH
42699: LD_VAR 0 6
42703: UNION
42704: DIFF
42705: PPUSH
42706: LD_INT 2
42708: PPUSH
42709: CALL 106234 0 2
42713: ST_TO_ADDR
// p := [ ] ;
42714: LD_ADDR_VAR 0 11
42718: PUSH
42719: EMPTY
42720: ST_TO_ADDR
// if sort then
42721: LD_VAR 0 9
42725: IFFALSE 42841
// for i = 1 to 4 - eng do
42727: LD_ADDR_VAR 0 3
42731: PUSH
42732: DOUBLE
42733: LD_INT 1
42735: DEC
42736: ST_TO_ADDR
42737: LD_INT 4
42739: PUSH
42740: LD_VAR 0 6
42744: MINUS
42745: PUSH
42746: FOR_TO
42747: IFFALSE 42839
// begin if i = sort then
42749: LD_VAR 0 3
42753: PUSH
42754: LD_VAR 0 9
42758: EQUAL
42759: IFFALSE 42763
// break ;
42761: GO 42839
// if GetClass ( i ) = 2 then
42763: LD_VAR 0 3
42767: PPUSH
42768: CALL_OW 257
42772: PUSH
42773: LD_INT 2
42775: EQUAL
42776: IFFALSE 42780
// continue ;
42778: GO 42746
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42780: LD_ADDR_VAR 0 11
42784: PUSH
42785: LD_VAR 0 11
42789: PPUSH
42790: LD_VAR 0 11
42794: PUSH
42795: LD_INT 1
42797: PLUS
42798: PPUSH
42799: LD_VAR 0 9
42803: PUSH
42804: LD_VAR 0 3
42808: ARRAY
42809: PPUSH
42810: CALL_OW 2
42814: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42815: LD_ADDR_VAR 0 4
42819: PUSH
42820: LD_VAR 0 4
42824: PUSH
42825: LD_VAR 0 9
42829: PUSH
42830: LD_VAR 0 3
42834: ARRAY
42835: DIFF
42836: ST_TO_ADDR
// end ;
42837: GO 42746
42839: POP
42840: POP
// if p then
42841: LD_VAR 0 11
42845: IFFALSE 42870
// result := Replace ( result , 2 , p ) ;
42847: LD_ADDR_VAR 0 2
42851: PUSH
42852: LD_VAR 0 2
42856: PPUSH
42857: LD_INT 2
42859: PPUSH
42860: LD_VAR 0 11
42864: PPUSH
42865: CALL_OW 1
42869: ST_TO_ADDR
// end else
42870: GO 42916
// for i = eng downto 5 do
42872: LD_ADDR_VAR 0 3
42876: PUSH
42877: DOUBLE
42878: LD_VAR 0 6
42882: INC
42883: ST_TO_ADDR
42884: LD_INT 5
42886: PUSH
42887: FOR_DOWNTO
42888: IFFALSE 42914
// tmp := tmp union eng [ i ] ;
42890: LD_ADDR_VAR 0 4
42894: PUSH
42895: LD_VAR 0 4
42899: PUSH
42900: LD_VAR 0 6
42904: PUSH
42905: LD_VAR 0 3
42909: ARRAY
42910: UNION
42911: ST_TO_ADDR
42912: GO 42887
42914: POP
42915: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42916: LD_ADDR_VAR 0 2
42920: PUSH
42921: LD_VAR 0 2
42925: PPUSH
42926: LD_INT 1
42928: PPUSH
42929: LD_VAR 0 4
42933: PUSH
42934: LD_VAR 0 5
42938: DIFF
42939: PPUSH
42940: CALL_OW 1
42944: ST_TO_ADDR
// exit ;
42945: GO 42947
// end ; end ;
42947: LD_VAR 0 2
42951: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42952: LD_INT 0
42954: PPUSH
42955: PPUSH
42956: PPUSH
// if not mc_bases then
42957: LD_EXP 102
42961: NOT
42962: IFFALSE 42966
// exit ;
42964: GO 43072
// for i = 1 to mc_bases do
42966: LD_ADDR_VAR 0 2
42970: PUSH
42971: DOUBLE
42972: LD_INT 1
42974: DEC
42975: ST_TO_ADDR
42976: LD_EXP 102
42980: PUSH
42981: FOR_TO
42982: IFFALSE 43063
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42984: LD_ADDR_VAR 0 3
42988: PUSH
42989: LD_EXP 102
42993: PUSH
42994: LD_VAR 0 2
42998: ARRAY
42999: PPUSH
43000: LD_INT 21
43002: PUSH
43003: LD_INT 3
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 3
43012: PUSH
43013: LD_INT 24
43015: PUSH
43016: LD_INT 1000
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PPUSH
43031: CALL_OW 72
43035: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43036: LD_ADDR_EXP 103
43040: PUSH
43041: LD_EXP 103
43045: PPUSH
43046: LD_VAR 0 2
43050: PPUSH
43051: LD_VAR 0 3
43055: PPUSH
43056: CALL_OW 1
43060: ST_TO_ADDR
// end ;
43061: GO 42981
43063: POP
43064: POP
// RaiseSailEvent ( 101 ) ;
43065: LD_INT 101
43067: PPUSH
43068: CALL_OW 427
// end ;
43072: LD_VAR 0 1
43076: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43077: LD_INT 0
43079: PPUSH
43080: PPUSH
43081: PPUSH
43082: PPUSH
43083: PPUSH
43084: PPUSH
43085: PPUSH
// if not mc_bases then
43086: LD_EXP 102
43090: NOT
43091: IFFALSE 43095
// exit ;
43093: GO 43668
// for i = 1 to mc_bases do
43095: LD_ADDR_VAR 0 2
43099: PUSH
43100: DOUBLE
43101: LD_INT 1
43103: DEC
43104: ST_TO_ADDR
43105: LD_EXP 102
43109: PUSH
43110: FOR_TO
43111: IFFALSE 43659
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43113: LD_ADDR_VAR 0 5
43117: PUSH
43118: LD_EXP 102
43122: PUSH
43123: LD_VAR 0 2
43127: ARRAY
43128: PUSH
43129: LD_EXP 131
43133: PUSH
43134: LD_VAR 0 2
43138: ARRAY
43139: UNION
43140: PPUSH
43141: LD_INT 21
43143: PUSH
43144: LD_INT 1
43146: PUSH
43147: EMPTY
43148: LIST
43149: LIST
43150: PUSH
43151: LD_INT 1
43153: PUSH
43154: LD_INT 3
43156: PUSH
43157: LD_INT 54
43159: PUSH
43160: EMPTY
43161: LIST
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: PUSH
43170: LD_INT 24
43172: PUSH
43173: LD_INT 800
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PPUSH
43193: CALL_OW 72
43197: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43198: LD_ADDR_VAR 0 6
43202: PUSH
43203: LD_EXP 102
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: PPUSH
43214: LD_INT 21
43216: PUSH
43217: LD_INT 1
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 1
43226: PUSH
43227: LD_INT 3
43229: PUSH
43230: LD_INT 54
43232: PUSH
43233: EMPTY
43234: LIST
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 3
43242: PUSH
43243: LD_INT 24
43245: PUSH
43246: LD_INT 250
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PPUSH
43266: CALL_OW 72
43270: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43271: LD_ADDR_VAR 0 7
43275: PUSH
43276: LD_VAR 0 5
43280: PUSH
43281: LD_VAR 0 6
43285: DIFF
43286: ST_TO_ADDR
// if not need_heal_1 then
43287: LD_VAR 0 6
43291: NOT
43292: IFFALSE 43325
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43294: LD_ADDR_EXP 105
43298: PUSH
43299: LD_EXP 105
43303: PPUSH
43304: LD_VAR 0 2
43308: PUSH
43309: LD_INT 1
43311: PUSH
43312: EMPTY
43313: LIST
43314: LIST
43315: PPUSH
43316: EMPTY
43317: PPUSH
43318: CALL 71983 0 3
43322: ST_TO_ADDR
43323: GO 43395
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43325: LD_ADDR_EXP 105
43329: PUSH
43330: LD_EXP 105
43334: PPUSH
43335: LD_VAR 0 2
43339: PUSH
43340: LD_INT 1
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PPUSH
43347: LD_EXP 105
43351: PUSH
43352: LD_VAR 0 2
43356: ARRAY
43357: PUSH
43358: LD_INT 1
43360: ARRAY
43361: PPUSH
43362: LD_INT 3
43364: PUSH
43365: LD_INT 24
43367: PUSH
43368: LD_INT 1000
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PPUSH
43379: CALL_OW 72
43383: PUSH
43384: LD_VAR 0 6
43388: UNION
43389: PPUSH
43390: CALL 71983 0 3
43394: ST_TO_ADDR
// if not need_heal_2 then
43395: LD_VAR 0 7
43399: NOT
43400: IFFALSE 43433
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43402: LD_ADDR_EXP 105
43406: PUSH
43407: LD_EXP 105
43411: PPUSH
43412: LD_VAR 0 2
43416: PUSH
43417: LD_INT 2
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PPUSH
43424: EMPTY
43425: PPUSH
43426: CALL 71983 0 3
43430: ST_TO_ADDR
43431: GO 43465
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43433: LD_ADDR_EXP 105
43437: PUSH
43438: LD_EXP 105
43442: PPUSH
43443: LD_VAR 0 2
43447: PUSH
43448: LD_INT 2
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PPUSH
43455: LD_VAR 0 7
43459: PPUSH
43460: CALL 71983 0 3
43464: ST_TO_ADDR
// if need_heal_2 then
43465: LD_VAR 0 7
43469: IFFALSE 43641
// for j in need_heal_2 do
43471: LD_ADDR_VAR 0 3
43475: PUSH
43476: LD_VAR 0 7
43480: PUSH
43481: FOR_IN
43482: IFFALSE 43639
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43484: LD_ADDR_VAR 0 5
43488: PUSH
43489: LD_EXP 102
43493: PUSH
43494: LD_VAR 0 2
43498: ARRAY
43499: PPUSH
43500: LD_INT 2
43502: PUSH
43503: LD_INT 30
43505: PUSH
43506: LD_INT 6
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 30
43515: PUSH
43516: LD_INT 7
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 30
43525: PUSH
43526: LD_INT 8
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 30
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 30
43545: PUSH
43546: LD_INT 1
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 25
43555: PUSH
43556: LD_INT 4
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: PPUSH
43572: CALL_OW 72
43576: ST_TO_ADDR
// if tmp then
43577: LD_VAR 0 5
43581: IFFALSE 43637
// begin k := NearestUnitToUnit ( tmp , j ) ;
43583: LD_ADDR_VAR 0 4
43587: PUSH
43588: LD_VAR 0 5
43592: PPUSH
43593: LD_VAR 0 3
43597: PPUSH
43598: CALL_OW 74
43602: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43603: LD_VAR 0 3
43607: PPUSH
43608: LD_VAR 0 4
43612: PPUSH
43613: CALL_OW 296
43617: PUSH
43618: LD_INT 7
43620: GREATER
43621: IFFALSE 43637
// ComMoveUnit ( j , k ) ;
43623: LD_VAR 0 3
43627: PPUSH
43628: LD_VAR 0 4
43632: PPUSH
43633: CALL_OW 112
// end ; end ;
43637: GO 43481
43639: POP
43640: POP
// if not need_heal_1 and not need_heal_2 then
43641: LD_VAR 0 6
43645: NOT
43646: PUSH
43647: LD_VAR 0 7
43651: NOT
43652: AND
43653: IFFALSE 43657
// continue ;
43655: GO 43110
// end ;
43657: GO 43110
43659: POP
43660: POP
// RaiseSailEvent ( 102 ) ;
43661: LD_INT 102
43663: PPUSH
43664: CALL_OW 427
// end ;
43668: LD_VAR 0 1
43672: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43673: LD_INT 0
43675: PPUSH
43676: PPUSH
43677: PPUSH
43678: PPUSH
43679: PPUSH
43680: PPUSH
43681: PPUSH
43682: PPUSH
// if not mc_bases then
43683: LD_EXP 102
43687: NOT
43688: IFFALSE 43692
// exit ;
43690: GO 44532
// for i = 1 to mc_bases do
43692: LD_ADDR_VAR 0 2
43696: PUSH
43697: DOUBLE
43698: LD_INT 1
43700: DEC
43701: ST_TO_ADDR
43702: LD_EXP 102
43706: PUSH
43707: FOR_TO
43708: IFFALSE 44530
// begin if not mc_building_need_repair [ i ] then
43710: LD_EXP 103
43714: PUSH
43715: LD_VAR 0 2
43719: ARRAY
43720: NOT
43721: IFFALSE 43895
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43723: LD_ADDR_VAR 0 6
43727: PUSH
43728: LD_EXP 121
43732: PUSH
43733: LD_VAR 0 2
43737: ARRAY
43738: PPUSH
43739: LD_INT 3
43741: PUSH
43742: LD_INT 24
43744: PUSH
43745: LD_INT 1000
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: EMPTY
43753: LIST
43754: LIST
43755: PUSH
43756: LD_INT 2
43758: PUSH
43759: LD_INT 34
43761: PUSH
43762: LD_INT 13
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 34
43771: PUSH
43772: LD_INT 52
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: LIST
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PPUSH
43788: CALL_OW 72
43792: ST_TO_ADDR
// if cranes then
43793: LD_VAR 0 6
43797: IFFALSE 43859
// for j in cranes do
43799: LD_ADDR_VAR 0 3
43803: PUSH
43804: LD_VAR 0 6
43808: PUSH
43809: FOR_IN
43810: IFFALSE 43857
// if not IsInArea ( j , mc_parking [ i ] ) then
43812: LD_VAR 0 3
43816: PPUSH
43817: LD_EXP 126
43821: PUSH
43822: LD_VAR 0 2
43826: ARRAY
43827: PPUSH
43828: CALL_OW 308
43832: NOT
43833: IFFALSE 43855
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43835: LD_VAR 0 3
43839: PPUSH
43840: LD_EXP 126
43844: PUSH
43845: LD_VAR 0 2
43849: ARRAY
43850: PPUSH
43851: CALL_OW 113
43855: GO 43809
43857: POP
43858: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43859: LD_ADDR_EXP 104
43863: PUSH
43864: LD_EXP 104
43868: PPUSH
43869: LD_VAR 0 2
43873: PPUSH
43874: EMPTY
43875: PPUSH
43876: CALL_OW 1
43880: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43881: LD_VAR 0 2
43885: PPUSH
43886: LD_INT 101
43888: PPUSH
43889: CALL 38785 0 2
// continue ;
43893: GO 43707
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43895: LD_ADDR_EXP 108
43899: PUSH
43900: LD_EXP 108
43904: PPUSH
43905: LD_VAR 0 2
43909: PPUSH
43910: EMPTY
43911: PPUSH
43912: CALL_OW 1
43916: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43917: LD_VAR 0 2
43921: PPUSH
43922: LD_INT 103
43924: PPUSH
43925: CALL 38785 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43929: LD_ADDR_VAR 0 5
43933: PUSH
43934: LD_EXP 102
43938: PUSH
43939: LD_VAR 0 2
43943: ARRAY
43944: PUSH
43945: LD_EXP 131
43949: PUSH
43950: LD_VAR 0 2
43954: ARRAY
43955: UNION
43956: PPUSH
43957: LD_INT 2
43959: PUSH
43960: LD_INT 25
43962: PUSH
43963: LD_INT 2
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 25
43972: PUSH
43973: LD_INT 16
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: LIST
43984: PUSH
43985: EMPTY
43986: LIST
43987: PPUSH
43988: CALL_OW 72
43992: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43993: LD_ADDR_VAR 0 6
43997: PUSH
43998: LD_EXP 121
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PPUSH
44009: LD_INT 2
44011: PUSH
44012: LD_INT 34
44014: PUSH
44015: LD_INT 13
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: LD_INT 34
44024: PUSH
44025: LD_INT 52
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: LIST
44036: PPUSH
44037: CALL_OW 72
44041: ST_TO_ADDR
// if cranes then
44042: LD_VAR 0 6
44046: IFFALSE 44182
// begin for j in cranes do
44048: LD_ADDR_VAR 0 3
44052: PUSH
44053: LD_VAR 0 6
44057: PUSH
44058: FOR_IN
44059: IFFALSE 44180
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44061: LD_VAR 0 3
44065: PPUSH
44066: CALL_OW 256
44070: PUSH
44071: LD_INT 500
44073: GREATEREQUAL
44074: PUSH
44075: LD_VAR 0 3
44079: PPUSH
44080: CALL_OW 314
44084: NOT
44085: AND
44086: IFFALSE 44120
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44088: LD_VAR 0 3
44092: PPUSH
44093: LD_EXP 103
44097: PUSH
44098: LD_VAR 0 2
44102: ARRAY
44103: PPUSH
44104: LD_VAR 0 3
44108: PPUSH
44109: CALL_OW 74
44113: PPUSH
44114: CALL_OW 130
44118: GO 44178
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44120: LD_VAR 0 3
44124: PPUSH
44125: CALL_OW 256
44129: PUSH
44130: LD_INT 500
44132: LESS
44133: PUSH
44134: LD_VAR 0 3
44138: PPUSH
44139: LD_EXP 126
44143: PUSH
44144: LD_VAR 0 2
44148: ARRAY
44149: PPUSH
44150: CALL_OW 308
44154: NOT
44155: AND
44156: IFFALSE 44178
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44158: LD_VAR 0 3
44162: PPUSH
44163: LD_EXP 126
44167: PUSH
44168: LD_VAR 0 2
44172: ARRAY
44173: PPUSH
44174: CALL_OW 113
44178: GO 44058
44180: POP
44181: POP
// end ; if not tmp then
44182: LD_VAR 0 5
44186: NOT
44187: IFFALSE 44191
// continue ;
44189: GO 43707
// for j in tmp do
44191: LD_ADDR_VAR 0 3
44195: PUSH
44196: LD_VAR 0 5
44200: PUSH
44201: FOR_IN
44202: IFFALSE 44526
// begin if mc_need_heal [ i ] then
44204: LD_EXP 105
44208: PUSH
44209: LD_VAR 0 2
44213: ARRAY
44214: IFFALSE 44262
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44216: LD_VAR 0 3
44220: PUSH
44221: LD_EXP 105
44225: PUSH
44226: LD_VAR 0 2
44230: ARRAY
44231: PUSH
44232: LD_INT 1
44234: ARRAY
44235: IN
44236: PUSH
44237: LD_VAR 0 3
44241: PUSH
44242: LD_EXP 105
44246: PUSH
44247: LD_VAR 0 2
44251: ARRAY
44252: PUSH
44253: LD_INT 2
44255: ARRAY
44256: IN
44257: OR
44258: IFFALSE 44262
// continue ;
44260: GO 44201
// if IsInUnit ( j ) then
44262: LD_VAR 0 3
44266: PPUSH
44267: CALL_OW 310
44271: IFFALSE 44282
// ComExitBuilding ( j ) ;
44273: LD_VAR 0 3
44277: PPUSH
44278: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44282: LD_VAR 0 3
44286: PUSH
44287: LD_EXP 104
44291: PUSH
44292: LD_VAR 0 2
44296: ARRAY
44297: IN
44298: NOT
44299: IFFALSE 44357
// begin SetTag ( j , 101 ) ;
44301: LD_VAR 0 3
44305: PPUSH
44306: LD_INT 101
44308: PPUSH
44309: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44313: LD_ADDR_EXP 104
44317: PUSH
44318: LD_EXP 104
44322: PPUSH
44323: LD_VAR 0 2
44327: PUSH
44328: LD_EXP 104
44332: PUSH
44333: LD_VAR 0 2
44337: ARRAY
44338: PUSH
44339: LD_INT 1
44341: PLUS
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PPUSH
44347: LD_VAR 0 3
44351: PPUSH
44352: CALL 71983 0 3
44356: ST_TO_ADDR
// end ; wait ( 1 ) ;
44357: LD_INT 1
44359: PPUSH
44360: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44364: LD_ADDR_VAR 0 7
44368: PUSH
44369: LD_EXP 103
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: ST_TO_ADDR
// if mc_scan [ i ] then
44380: LD_EXP 125
44384: PUSH
44385: LD_VAR 0 2
44389: ARRAY
44390: IFFALSE 44459
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44392: LD_ADDR_VAR 0 7
44396: PUSH
44397: LD_EXP 103
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: LD_INT 3
44410: PUSH
44411: LD_INT 2
44413: PUSH
44414: LD_INT 30
44416: PUSH
44417: LD_INT 32
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 30
44426: PUSH
44427: LD_INT 33
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 30
44436: PUSH
44437: LD_INT 31
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PPUSH
44454: CALL_OW 72
44458: ST_TO_ADDR
// if not to_repair_tmp then
44459: LD_VAR 0 7
44463: NOT
44464: IFFALSE 44468
// continue ;
44466: GO 44201
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44468: LD_ADDR_VAR 0 8
44472: PUSH
44473: LD_VAR 0 7
44477: PPUSH
44478: LD_VAR 0 3
44482: PPUSH
44483: CALL_OW 74
44487: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44488: LD_VAR 0 8
44492: PPUSH
44493: LD_INT 14
44495: PPUSH
44496: CALL 74576 0 2
44500: PUSH
44501: LD_INT 4
44503: ARRAY
44504: PUSH
44505: LD_INT 5
44507: LESS
44508: IFFALSE 44524
// ComRepairBuilding ( j , to_repair ) ;
44510: LD_VAR 0 3
44514: PPUSH
44515: LD_VAR 0 8
44519: PPUSH
44520: CALL_OW 130
// end ;
44524: GO 44201
44526: POP
44527: POP
// end ;
44528: GO 43707
44530: POP
44531: POP
// end ;
44532: LD_VAR 0 1
44536: RET
// export function MC_Heal ; var i , j , tmp ; begin
44537: LD_INT 0
44539: PPUSH
44540: PPUSH
44541: PPUSH
44542: PPUSH
// if not mc_bases then
44543: LD_EXP 102
44547: NOT
44548: IFFALSE 44552
// exit ;
44550: GO 44954
// for i = 1 to mc_bases do
44552: LD_ADDR_VAR 0 2
44556: PUSH
44557: DOUBLE
44558: LD_INT 1
44560: DEC
44561: ST_TO_ADDR
44562: LD_EXP 102
44566: PUSH
44567: FOR_TO
44568: IFFALSE 44952
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44570: LD_EXP 105
44574: PUSH
44575: LD_VAR 0 2
44579: ARRAY
44580: PUSH
44581: LD_INT 1
44583: ARRAY
44584: NOT
44585: PUSH
44586: LD_EXP 105
44590: PUSH
44591: LD_VAR 0 2
44595: ARRAY
44596: PUSH
44597: LD_INT 2
44599: ARRAY
44600: NOT
44601: AND
44602: IFFALSE 44640
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44604: LD_ADDR_EXP 106
44608: PUSH
44609: LD_EXP 106
44613: PPUSH
44614: LD_VAR 0 2
44618: PPUSH
44619: EMPTY
44620: PPUSH
44621: CALL_OW 1
44625: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44626: LD_VAR 0 2
44630: PPUSH
44631: LD_INT 102
44633: PPUSH
44634: CALL 38785 0 2
// continue ;
44638: GO 44567
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44640: LD_ADDR_VAR 0 4
44644: PUSH
44645: LD_EXP 102
44649: PUSH
44650: LD_VAR 0 2
44654: ARRAY
44655: PPUSH
44656: LD_INT 25
44658: PUSH
44659: LD_INT 4
44661: PUSH
44662: EMPTY
44663: LIST
44664: LIST
44665: PPUSH
44666: CALL_OW 72
44670: ST_TO_ADDR
// if not tmp then
44671: LD_VAR 0 4
44675: NOT
44676: IFFALSE 44680
// continue ;
44678: GO 44567
// if mc_taming [ i ] then
44680: LD_EXP 133
44684: PUSH
44685: LD_VAR 0 2
44689: ARRAY
44690: IFFALSE 44714
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44692: LD_ADDR_EXP 133
44696: PUSH
44697: LD_EXP 133
44701: PPUSH
44702: LD_VAR 0 2
44706: PPUSH
44707: EMPTY
44708: PPUSH
44709: CALL_OW 1
44713: ST_TO_ADDR
// for j in tmp do
44714: LD_ADDR_VAR 0 3
44718: PUSH
44719: LD_VAR 0 4
44723: PUSH
44724: FOR_IN
44725: IFFALSE 44948
// begin if IsInUnit ( j ) then
44727: LD_VAR 0 3
44731: PPUSH
44732: CALL_OW 310
44736: IFFALSE 44747
// ComExitBuilding ( j ) ;
44738: LD_VAR 0 3
44742: PPUSH
44743: CALL_OW 122
// if not j in mc_healers [ i ] then
44747: LD_VAR 0 3
44751: PUSH
44752: LD_EXP 106
44756: PUSH
44757: LD_VAR 0 2
44761: ARRAY
44762: IN
44763: NOT
44764: IFFALSE 44810
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44766: LD_ADDR_EXP 106
44770: PUSH
44771: LD_EXP 106
44775: PPUSH
44776: LD_VAR 0 2
44780: PUSH
44781: LD_EXP 106
44785: PUSH
44786: LD_VAR 0 2
44790: ARRAY
44791: PUSH
44792: LD_INT 1
44794: PLUS
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PPUSH
44800: LD_VAR 0 3
44804: PPUSH
44805: CALL 71983 0 3
44809: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44810: LD_VAR 0 3
44814: PPUSH
44815: CALL_OW 110
44819: PUSH
44820: LD_INT 102
44822: NONEQUAL
44823: IFFALSE 44837
// SetTag ( j , 102 ) ;
44825: LD_VAR 0 3
44829: PPUSH
44830: LD_INT 102
44832: PPUSH
44833: CALL_OW 109
// Wait ( 3 ) ;
44837: LD_INT 3
44839: PPUSH
44840: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44844: LD_EXP 105
44848: PUSH
44849: LD_VAR 0 2
44853: ARRAY
44854: PUSH
44855: LD_INT 1
44857: ARRAY
44858: IFFALSE 44890
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44860: LD_VAR 0 3
44864: PPUSH
44865: LD_EXP 105
44869: PUSH
44870: LD_VAR 0 2
44874: ARRAY
44875: PUSH
44876: LD_INT 1
44878: ARRAY
44879: PUSH
44880: LD_INT 1
44882: ARRAY
44883: PPUSH
44884: CALL_OW 128
44888: GO 44946
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44890: LD_VAR 0 3
44894: PPUSH
44895: CALL_OW 314
44899: NOT
44900: PUSH
44901: LD_EXP 105
44905: PUSH
44906: LD_VAR 0 2
44910: ARRAY
44911: PUSH
44912: LD_INT 2
44914: ARRAY
44915: AND
44916: IFFALSE 44946
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44918: LD_VAR 0 3
44922: PPUSH
44923: LD_EXP 105
44927: PUSH
44928: LD_VAR 0 2
44932: ARRAY
44933: PUSH
44934: LD_INT 2
44936: ARRAY
44937: PUSH
44938: LD_INT 1
44940: ARRAY
44941: PPUSH
44942: CALL_OW 128
// end ;
44946: GO 44724
44948: POP
44949: POP
// end ;
44950: GO 44567
44952: POP
44953: POP
// end ;
44954: LD_VAR 0 1
44958: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44959: LD_INT 0
44961: PPUSH
44962: PPUSH
44963: PPUSH
44964: PPUSH
44965: PPUSH
// if not mc_bases then
44966: LD_EXP 102
44970: NOT
44971: IFFALSE 44975
// exit ;
44973: GO 46118
// for i = 1 to mc_bases do
44975: LD_ADDR_VAR 0 2
44979: PUSH
44980: DOUBLE
44981: LD_INT 1
44983: DEC
44984: ST_TO_ADDR
44985: LD_EXP 102
44989: PUSH
44990: FOR_TO
44991: IFFALSE 46116
// begin if mc_scan [ i ] then
44993: LD_EXP 125
44997: PUSH
44998: LD_VAR 0 2
45002: ARRAY
45003: IFFALSE 45007
// continue ;
45005: GO 44990
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45007: LD_EXP 107
45011: PUSH
45012: LD_VAR 0 2
45016: ARRAY
45017: NOT
45018: PUSH
45019: LD_EXP 109
45023: PUSH
45024: LD_VAR 0 2
45028: ARRAY
45029: NOT
45030: AND
45031: PUSH
45032: LD_EXP 108
45036: PUSH
45037: LD_VAR 0 2
45041: ARRAY
45042: AND
45043: IFFALSE 45081
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45045: LD_ADDR_EXP 108
45049: PUSH
45050: LD_EXP 108
45054: PPUSH
45055: LD_VAR 0 2
45059: PPUSH
45060: EMPTY
45061: PPUSH
45062: CALL_OW 1
45066: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45067: LD_VAR 0 2
45071: PPUSH
45072: LD_INT 103
45074: PPUSH
45075: CALL 38785 0 2
// continue ;
45079: GO 44990
// end ; if mc_construct_list [ i ] then
45081: LD_EXP 109
45085: PUSH
45086: LD_VAR 0 2
45090: ARRAY
45091: IFFALSE 45311
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45093: LD_ADDR_VAR 0 4
45097: PUSH
45098: LD_EXP 102
45102: PUSH
45103: LD_VAR 0 2
45107: ARRAY
45108: PPUSH
45109: LD_INT 25
45111: PUSH
45112: LD_INT 2
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PPUSH
45119: CALL_OW 72
45123: PUSH
45124: LD_EXP 104
45128: PUSH
45129: LD_VAR 0 2
45133: ARRAY
45134: DIFF
45135: ST_TO_ADDR
// if not tmp then
45136: LD_VAR 0 4
45140: NOT
45141: IFFALSE 45145
// continue ;
45143: GO 44990
// for j in tmp do
45145: LD_ADDR_VAR 0 3
45149: PUSH
45150: LD_VAR 0 4
45154: PUSH
45155: FOR_IN
45156: IFFALSE 45307
// begin if not mc_builders [ i ] then
45158: LD_EXP 108
45162: PUSH
45163: LD_VAR 0 2
45167: ARRAY
45168: NOT
45169: IFFALSE 45227
// begin SetTag ( j , 103 ) ;
45171: LD_VAR 0 3
45175: PPUSH
45176: LD_INT 103
45178: PPUSH
45179: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45183: LD_ADDR_EXP 108
45187: PUSH
45188: LD_EXP 108
45192: PPUSH
45193: LD_VAR 0 2
45197: PUSH
45198: LD_EXP 108
45202: PUSH
45203: LD_VAR 0 2
45207: ARRAY
45208: PUSH
45209: LD_INT 1
45211: PLUS
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PPUSH
45217: LD_VAR 0 3
45221: PPUSH
45222: CALL 71983 0 3
45226: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45227: LD_VAR 0 3
45231: PPUSH
45232: CALL_OW 310
45236: IFFALSE 45247
// ComExitBuilding ( j ) ;
45238: LD_VAR 0 3
45242: PPUSH
45243: CALL_OW 122
// wait ( 3 ) ;
45247: LD_INT 3
45249: PPUSH
45250: CALL_OW 67
// if not mc_construct_list [ i ] then
45254: LD_EXP 109
45258: PUSH
45259: LD_VAR 0 2
45263: ARRAY
45264: NOT
45265: IFFALSE 45269
// break ;
45267: GO 45307
// if not HasTask ( j ) then
45269: LD_VAR 0 3
45273: PPUSH
45274: CALL_OW 314
45278: NOT
45279: IFFALSE 45305
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45281: LD_VAR 0 3
45285: PPUSH
45286: LD_EXP 109
45290: PUSH
45291: LD_VAR 0 2
45295: ARRAY
45296: PUSH
45297: LD_INT 1
45299: ARRAY
45300: PPUSH
45301: CALL 74834 0 2
// end ;
45305: GO 45155
45307: POP
45308: POP
// end else
45309: GO 46114
// if mc_build_list [ i ] then
45311: LD_EXP 107
45315: PUSH
45316: LD_VAR 0 2
45320: ARRAY
45321: IFFALSE 46114
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45323: LD_ADDR_VAR 0 5
45327: PUSH
45328: LD_EXP 102
45332: PUSH
45333: LD_VAR 0 2
45337: ARRAY
45338: PPUSH
45339: LD_INT 2
45341: PUSH
45342: LD_INT 30
45344: PUSH
45345: LD_INT 0
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 30
45354: PUSH
45355: LD_INT 1
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: LIST
45366: PPUSH
45367: CALL_OW 72
45371: ST_TO_ADDR
// if depot then
45372: LD_VAR 0 5
45376: IFFALSE 45394
// depot := depot [ 1 ] else
45378: LD_ADDR_VAR 0 5
45382: PUSH
45383: LD_VAR 0 5
45387: PUSH
45388: LD_INT 1
45390: ARRAY
45391: ST_TO_ADDR
45392: GO 45402
// depot := 0 ;
45394: LD_ADDR_VAR 0 5
45398: PUSH
45399: LD_INT 0
45401: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45402: LD_EXP 107
45406: PUSH
45407: LD_VAR 0 2
45411: ARRAY
45412: PUSH
45413: LD_INT 1
45415: ARRAY
45416: PUSH
45417: LD_INT 1
45419: ARRAY
45420: PPUSH
45421: CALL 74664 0 1
45425: PUSH
45426: LD_EXP 102
45430: PUSH
45431: LD_VAR 0 2
45435: ARRAY
45436: PPUSH
45437: LD_INT 2
45439: PUSH
45440: LD_INT 30
45442: PUSH
45443: LD_INT 2
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 30
45452: PUSH
45453: LD_INT 3
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: LIST
45464: PPUSH
45465: CALL_OW 72
45469: NOT
45470: AND
45471: IFFALSE 45576
// begin for j = 1 to mc_build_list [ i ] do
45473: LD_ADDR_VAR 0 3
45477: PUSH
45478: DOUBLE
45479: LD_INT 1
45481: DEC
45482: ST_TO_ADDR
45483: LD_EXP 107
45487: PUSH
45488: LD_VAR 0 2
45492: ARRAY
45493: PUSH
45494: FOR_TO
45495: IFFALSE 45574
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45497: LD_EXP 107
45501: PUSH
45502: LD_VAR 0 2
45506: ARRAY
45507: PUSH
45508: LD_VAR 0 3
45512: ARRAY
45513: PUSH
45514: LD_INT 1
45516: ARRAY
45517: PUSH
45518: LD_INT 2
45520: EQUAL
45521: IFFALSE 45572
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45523: LD_ADDR_EXP 107
45527: PUSH
45528: LD_EXP 107
45532: PPUSH
45533: LD_VAR 0 2
45537: PPUSH
45538: LD_EXP 107
45542: PUSH
45543: LD_VAR 0 2
45547: ARRAY
45548: PPUSH
45549: LD_VAR 0 3
45553: PPUSH
45554: LD_INT 1
45556: PPUSH
45557: LD_INT 0
45559: PPUSH
45560: CALL 71401 0 4
45564: PPUSH
45565: CALL_OW 1
45569: ST_TO_ADDR
// break ;
45570: GO 45574
// end ;
45572: GO 45494
45574: POP
45575: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45576: LD_EXP 107
45580: PUSH
45581: LD_VAR 0 2
45585: ARRAY
45586: PUSH
45587: LD_INT 1
45589: ARRAY
45590: PUSH
45591: LD_INT 1
45593: ARRAY
45594: PUSH
45595: LD_INT 0
45597: EQUAL
45598: PUSH
45599: LD_VAR 0 5
45603: PUSH
45604: LD_VAR 0 5
45608: PPUSH
45609: LD_EXP 107
45613: PUSH
45614: LD_VAR 0 2
45618: ARRAY
45619: PUSH
45620: LD_INT 1
45622: ARRAY
45623: PUSH
45624: LD_INT 1
45626: ARRAY
45627: PPUSH
45628: LD_EXP 107
45632: PUSH
45633: LD_VAR 0 2
45637: ARRAY
45638: PUSH
45639: LD_INT 1
45641: ARRAY
45642: PUSH
45643: LD_INT 2
45645: ARRAY
45646: PPUSH
45647: LD_EXP 107
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: PUSH
45658: LD_INT 1
45660: ARRAY
45661: PUSH
45662: LD_INT 3
45664: ARRAY
45665: PPUSH
45666: LD_EXP 107
45670: PUSH
45671: LD_VAR 0 2
45675: ARRAY
45676: PUSH
45677: LD_INT 1
45679: ARRAY
45680: PUSH
45681: LD_INT 4
45683: ARRAY
45684: PPUSH
45685: CALL 79398 0 5
45689: AND
45690: OR
45691: IFFALSE 45972
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45693: LD_ADDR_VAR 0 4
45697: PUSH
45698: LD_EXP 102
45702: PUSH
45703: LD_VAR 0 2
45707: ARRAY
45708: PPUSH
45709: LD_INT 25
45711: PUSH
45712: LD_INT 2
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: PPUSH
45719: CALL_OW 72
45723: PUSH
45724: LD_EXP 104
45728: PUSH
45729: LD_VAR 0 2
45733: ARRAY
45734: DIFF
45735: ST_TO_ADDR
// if not tmp then
45736: LD_VAR 0 4
45740: NOT
45741: IFFALSE 45745
// continue ;
45743: GO 44990
// for j in tmp do
45745: LD_ADDR_VAR 0 3
45749: PUSH
45750: LD_VAR 0 4
45754: PUSH
45755: FOR_IN
45756: IFFALSE 45968
// begin if not mc_builders [ i ] then
45758: LD_EXP 108
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: NOT
45769: IFFALSE 45827
// begin SetTag ( j , 103 ) ;
45771: LD_VAR 0 3
45775: PPUSH
45776: LD_INT 103
45778: PPUSH
45779: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45783: LD_ADDR_EXP 108
45787: PUSH
45788: LD_EXP 108
45792: PPUSH
45793: LD_VAR 0 2
45797: PUSH
45798: LD_EXP 108
45802: PUSH
45803: LD_VAR 0 2
45807: ARRAY
45808: PUSH
45809: LD_INT 1
45811: PLUS
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PPUSH
45817: LD_VAR 0 3
45821: PPUSH
45822: CALL 71983 0 3
45826: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45827: LD_VAR 0 3
45831: PPUSH
45832: CALL_OW 310
45836: IFFALSE 45847
// ComExitBuilding ( j ) ;
45838: LD_VAR 0 3
45842: PPUSH
45843: CALL_OW 122
// wait ( 3 ) ;
45847: LD_INT 3
45849: PPUSH
45850: CALL_OW 67
// if not mc_build_list [ i ] then
45854: LD_EXP 107
45858: PUSH
45859: LD_VAR 0 2
45863: ARRAY
45864: NOT
45865: IFFALSE 45869
// break ;
45867: GO 45968
// if not HasTask ( j ) then
45869: LD_VAR 0 3
45873: PPUSH
45874: CALL_OW 314
45878: NOT
45879: IFFALSE 45966
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45881: LD_VAR 0 3
45885: PPUSH
45886: LD_EXP 107
45890: PUSH
45891: LD_VAR 0 2
45895: ARRAY
45896: PUSH
45897: LD_INT 1
45899: ARRAY
45900: PUSH
45901: LD_INT 1
45903: ARRAY
45904: PPUSH
45905: LD_EXP 107
45909: PUSH
45910: LD_VAR 0 2
45914: ARRAY
45915: PUSH
45916: LD_INT 1
45918: ARRAY
45919: PUSH
45920: LD_INT 2
45922: ARRAY
45923: PPUSH
45924: LD_EXP 107
45928: PUSH
45929: LD_VAR 0 2
45933: ARRAY
45934: PUSH
45935: LD_INT 1
45937: ARRAY
45938: PUSH
45939: LD_INT 3
45941: ARRAY
45942: PPUSH
45943: LD_EXP 107
45947: PUSH
45948: LD_VAR 0 2
45952: ARRAY
45953: PUSH
45954: LD_INT 1
45956: ARRAY
45957: PUSH
45958: LD_INT 4
45960: ARRAY
45961: PPUSH
45962: CALL_OW 145
// end ;
45966: GO 45755
45968: POP
45969: POP
// end else
45970: GO 46114
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45972: LD_EXP 102
45976: PUSH
45977: LD_VAR 0 2
45981: ARRAY
45982: PPUSH
45983: LD_EXP 107
45987: PUSH
45988: LD_VAR 0 2
45992: ARRAY
45993: PUSH
45994: LD_INT 1
45996: ARRAY
45997: PUSH
45998: LD_INT 1
46000: ARRAY
46001: PPUSH
46002: LD_EXP 107
46006: PUSH
46007: LD_VAR 0 2
46011: ARRAY
46012: PUSH
46013: LD_INT 1
46015: ARRAY
46016: PUSH
46017: LD_INT 2
46019: ARRAY
46020: PPUSH
46021: LD_EXP 107
46025: PUSH
46026: LD_VAR 0 2
46030: ARRAY
46031: PUSH
46032: LD_INT 1
46034: ARRAY
46035: PUSH
46036: LD_INT 3
46038: ARRAY
46039: PPUSH
46040: LD_EXP 107
46044: PUSH
46045: LD_VAR 0 2
46049: ARRAY
46050: PUSH
46051: LD_INT 1
46053: ARRAY
46054: PUSH
46055: LD_INT 4
46057: ARRAY
46058: PPUSH
46059: CALL 78734 0 5
46063: NOT
46064: IFFALSE 46114
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46066: LD_ADDR_EXP 107
46070: PUSH
46071: LD_EXP 107
46075: PPUSH
46076: LD_VAR 0 2
46080: PPUSH
46081: LD_EXP 107
46085: PUSH
46086: LD_VAR 0 2
46090: ARRAY
46091: PPUSH
46092: LD_INT 1
46094: PPUSH
46095: LD_INT 1
46097: NEG
46098: PPUSH
46099: LD_INT 0
46101: PPUSH
46102: CALL 71401 0 4
46106: PPUSH
46107: CALL_OW 1
46111: ST_TO_ADDR
// continue ;
46112: GO 44990
// end ; end ; end ;
46114: GO 44990
46116: POP
46117: POP
// end ;
46118: LD_VAR 0 1
46122: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46123: LD_INT 0
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
// if not mc_bases then
46131: LD_EXP 102
46135: NOT
46136: IFFALSE 46140
// exit ;
46138: GO 46567
// for i = 1 to mc_bases do
46140: LD_ADDR_VAR 0 2
46144: PUSH
46145: DOUBLE
46146: LD_INT 1
46148: DEC
46149: ST_TO_ADDR
46150: LD_EXP 102
46154: PUSH
46155: FOR_TO
46156: IFFALSE 46565
// begin tmp := mc_build_upgrade [ i ] ;
46158: LD_ADDR_VAR 0 4
46162: PUSH
46163: LD_EXP 134
46167: PUSH
46168: LD_VAR 0 2
46172: ARRAY
46173: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46174: LD_ADDR_VAR 0 6
46178: PUSH
46179: LD_EXP 135
46183: PUSH
46184: LD_VAR 0 2
46188: ARRAY
46189: PPUSH
46190: LD_INT 2
46192: PUSH
46193: LD_INT 30
46195: PUSH
46196: LD_INT 6
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 30
46205: PUSH
46206: LD_INT 7
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: LIST
46217: PPUSH
46218: CALL_OW 72
46222: ST_TO_ADDR
// if not tmp and not lab then
46223: LD_VAR 0 4
46227: NOT
46228: PUSH
46229: LD_VAR 0 6
46233: NOT
46234: AND
46235: IFFALSE 46239
// continue ;
46237: GO 46155
// if tmp then
46239: LD_VAR 0 4
46243: IFFALSE 46363
// for j in tmp do
46245: LD_ADDR_VAR 0 3
46249: PUSH
46250: LD_VAR 0 4
46254: PUSH
46255: FOR_IN
46256: IFFALSE 46361
// begin if UpgradeCost ( j ) then
46258: LD_VAR 0 3
46262: PPUSH
46263: CALL 78394 0 1
46267: IFFALSE 46359
// begin ComUpgrade ( j ) ;
46269: LD_VAR 0 3
46273: PPUSH
46274: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46278: LD_ADDR_EXP 134
46282: PUSH
46283: LD_EXP 134
46287: PPUSH
46288: LD_VAR 0 2
46292: PPUSH
46293: LD_EXP 134
46297: PUSH
46298: LD_VAR 0 2
46302: ARRAY
46303: PUSH
46304: LD_VAR 0 3
46308: DIFF
46309: PPUSH
46310: CALL_OW 1
46314: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46315: LD_ADDR_EXP 109
46319: PUSH
46320: LD_EXP 109
46324: PPUSH
46325: LD_VAR 0 2
46329: PUSH
46330: LD_EXP 109
46334: PUSH
46335: LD_VAR 0 2
46339: ARRAY
46340: PUSH
46341: LD_INT 1
46343: PLUS
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PPUSH
46349: LD_VAR 0 3
46353: PPUSH
46354: CALL 71983 0 3
46358: ST_TO_ADDR
// end ; end ;
46359: GO 46255
46361: POP
46362: POP
// if not lab or not mc_lab_upgrade [ i ] then
46363: LD_VAR 0 6
46367: NOT
46368: PUSH
46369: LD_EXP 136
46373: PUSH
46374: LD_VAR 0 2
46378: ARRAY
46379: NOT
46380: OR
46381: IFFALSE 46385
// continue ;
46383: GO 46155
// for j in lab do
46385: LD_ADDR_VAR 0 3
46389: PUSH
46390: LD_VAR 0 6
46394: PUSH
46395: FOR_IN
46396: IFFALSE 46561
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46398: LD_VAR 0 3
46402: PPUSH
46403: CALL_OW 266
46407: PUSH
46408: LD_INT 6
46410: PUSH
46411: LD_INT 7
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: IN
46418: PUSH
46419: LD_VAR 0 3
46423: PPUSH
46424: CALL_OW 461
46428: PUSH
46429: LD_INT 1
46431: NONEQUAL
46432: AND
46433: IFFALSE 46559
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46435: LD_VAR 0 3
46439: PPUSH
46440: LD_EXP 136
46444: PUSH
46445: LD_VAR 0 2
46449: ARRAY
46450: PUSH
46451: LD_INT 1
46453: ARRAY
46454: PPUSH
46455: CALL 78599 0 2
46459: IFFALSE 46559
// begin ComCancel ( j ) ;
46461: LD_VAR 0 3
46465: PPUSH
46466: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46470: LD_VAR 0 3
46474: PPUSH
46475: LD_EXP 136
46479: PUSH
46480: LD_VAR 0 2
46484: ARRAY
46485: PUSH
46486: LD_INT 1
46488: ARRAY
46489: PPUSH
46490: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46494: LD_VAR 0 3
46498: PUSH
46499: LD_EXP 109
46503: PUSH
46504: LD_VAR 0 2
46508: ARRAY
46509: IN
46510: NOT
46511: IFFALSE 46557
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46513: LD_ADDR_EXP 109
46517: PUSH
46518: LD_EXP 109
46522: PPUSH
46523: LD_VAR 0 2
46527: PUSH
46528: LD_EXP 109
46532: PUSH
46533: LD_VAR 0 2
46537: ARRAY
46538: PUSH
46539: LD_INT 1
46541: PLUS
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PPUSH
46547: LD_VAR 0 3
46551: PPUSH
46552: CALL 71983 0 3
46556: ST_TO_ADDR
// break ;
46557: GO 46561
// end ; end ; end ;
46559: GO 46395
46561: POP
46562: POP
// end ;
46563: GO 46155
46565: POP
46566: POP
// end ;
46567: LD_VAR 0 1
46571: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46572: LD_INT 0
46574: PPUSH
46575: PPUSH
46576: PPUSH
46577: PPUSH
46578: PPUSH
46579: PPUSH
46580: PPUSH
46581: PPUSH
46582: PPUSH
// if not mc_bases then
46583: LD_EXP 102
46587: NOT
46588: IFFALSE 46592
// exit ;
46590: GO 46997
// for i = 1 to mc_bases do
46592: LD_ADDR_VAR 0 2
46596: PUSH
46597: DOUBLE
46598: LD_INT 1
46600: DEC
46601: ST_TO_ADDR
46602: LD_EXP 102
46606: PUSH
46607: FOR_TO
46608: IFFALSE 46995
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46610: LD_EXP 110
46614: PUSH
46615: LD_VAR 0 2
46619: ARRAY
46620: NOT
46621: PUSH
46622: LD_EXP 102
46626: PUSH
46627: LD_VAR 0 2
46631: ARRAY
46632: PPUSH
46633: LD_INT 30
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PPUSH
46643: CALL_OW 72
46647: NOT
46648: OR
46649: IFFALSE 46653
// continue ;
46651: GO 46607
// busy := false ;
46653: LD_ADDR_VAR 0 8
46657: PUSH
46658: LD_INT 0
46660: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46661: LD_ADDR_VAR 0 4
46665: PUSH
46666: LD_EXP 102
46670: PUSH
46671: LD_VAR 0 2
46675: ARRAY
46676: PPUSH
46677: LD_INT 30
46679: PUSH
46680: LD_INT 3
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PPUSH
46687: CALL_OW 72
46691: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46692: LD_ADDR_VAR 0 6
46696: PUSH
46697: LD_EXP 110
46701: PUSH
46702: LD_VAR 0 2
46706: ARRAY
46707: PPUSH
46708: LD_INT 2
46710: PUSH
46711: LD_INT 30
46713: PUSH
46714: LD_INT 32
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 30
46723: PUSH
46724: LD_INT 33
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: LIST
46735: PPUSH
46736: CALL_OW 72
46740: ST_TO_ADDR
// if not t then
46741: LD_VAR 0 6
46745: NOT
46746: IFFALSE 46750
// continue ;
46748: GO 46607
// for j in tmp do
46750: LD_ADDR_VAR 0 3
46754: PUSH
46755: LD_VAR 0 4
46759: PUSH
46760: FOR_IN
46761: IFFALSE 46791
// if not BuildingStatus ( j ) = bs_idle then
46763: LD_VAR 0 3
46767: PPUSH
46768: CALL_OW 461
46772: PUSH
46773: LD_INT 2
46775: EQUAL
46776: NOT
46777: IFFALSE 46789
// begin busy := true ;
46779: LD_ADDR_VAR 0 8
46783: PUSH
46784: LD_INT 1
46786: ST_TO_ADDR
// break ;
46787: GO 46791
// end ;
46789: GO 46760
46791: POP
46792: POP
// if busy then
46793: LD_VAR 0 8
46797: IFFALSE 46801
// continue ;
46799: GO 46607
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46801: LD_ADDR_VAR 0 7
46805: PUSH
46806: LD_VAR 0 6
46810: PPUSH
46811: LD_INT 35
46813: PUSH
46814: LD_INT 0
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PPUSH
46821: CALL_OW 72
46825: ST_TO_ADDR
// if tw then
46826: LD_VAR 0 7
46830: IFFALSE 46907
// begin tw := tw [ 1 ] ;
46832: LD_ADDR_VAR 0 7
46836: PUSH
46837: LD_VAR 0 7
46841: PUSH
46842: LD_INT 1
46844: ARRAY
46845: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46846: LD_ADDR_VAR 0 9
46850: PUSH
46851: LD_VAR 0 7
46855: PPUSH
46856: LD_EXP 127
46860: PUSH
46861: LD_VAR 0 2
46865: ARRAY
46866: PPUSH
46867: CALL 76953 0 2
46871: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46872: LD_EXP 141
46876: PUSH
46877: LD_VAR 0 2
46881: ARRAY
46882: IFFALSE 46905
// if not weapon in mc_allowed_tower_weapons [ i ] then
46884: LD_VAR 0 9
46888: PUSH
46889: LD_EXP 141
46893: PUSH
46894: LD_VAR 0 2
46898: ARRAY
46899: IN
46900: NOT
46901: IFFALSE 46905
// continue ;
46903: GO 46607
// end else
46905: GO 46970
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46907: LD_ADDR_VAR 0 5
46911: PUSH
46912: LD_EXP 110
46916: PUSH
46917: LD_VAR 0 2
46921: ARRAY
46922: PPUSH
46923: LD_VAR 0 4
46927: PPUSH
46928: CALL 107157 0 2
46932: ST_TO_ADDR
// if not tmp2 then
46933: LD_VAR 0 5
46937: NOT
46938: IFFALSE 46942
// continue ;
46940: GO 46607
// tw := tmp2 [ 1 ] ;
46942: LD_ADDR_VAR 0 7
46946: PUSH
46947: LD_VAR 0 5
46951: PUSH
46952: LD_INT 1
46954: ARRAY
46955: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46956: LD_ADDR_VAR 0 9
46960: PUSH
46961: LD_VAR 0 5
46965: PUSH
46966: LD_INT 2
46968: ARRAY
46969: ST_TO_ADDR
// end ; if not weapon then
46970: LD_VAR 0 9
46974: NOT
46975: IFFALSE 46979
// continue ;
46977: GO 46607
// ComPlaceWeapon ( tw , weapon ) ;
46979: LD_VAR 0 7
46983: PPUSH
46984: LD_VAR 0 9
46988: PPUSH
46989: CALL_OW 148
// end ;
46993: GO 46607
46995: POP
46996: POP
// end ;
46997: LD_VAR 0 1
47001: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47002: LD_INT 0
47004: PPUSH
47005: PPUSH
47006: PPUSH
47007: PPUSH
47008: PPUSH
47009: PPUSH
// if not mc_bases then
47010: LD_EXP 102
47014: NOT
47015: IFFALSE 47019
// exit ;
47017: GO 47795
// for i = 1 to mc_bases do
47019: LD_ADDR_VAR 0 2
47023: PUSH
47024: DOUBLE
47025: LD_INT 1
47027: DEC
47028: ST_TO_ADDR
47029: LD_EXP 102
47033: PUSH
47034: FOR_TO
47035: IFFALSE 47793
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47037: LD_EXP 115
47041: PUSH
47042: LD_VAR 0 2
47046: ARRAY
47047: NOT
47048: PUSH
47049: LD_EXP 115
47053: PUSH
47054: LD_VAR 0 2
47058: ARRAY
47059: PUSH
47060: LD_EXP 116
47064: PUSH
47065: LD_VAR 0 2
47069: ARRAY
47070: EQUAL
47071: OR
47072: PUSH
47073: LD_EXP 125
47077: PUSH
47078: LD_VAR 0 2
47082: ARRAY
47083: OR
47084: IFFALSE 47088
// continue ;
47086: GO 47034
// if mc_miners [ i ] then
47088: LD_EXP 116
47092: PUSH
47093: LD_VAR 0 2
47097: ARRAY
47098: IFFALSE 47480
// begin for j = mc_miners [ i ] downto 1 do
47100: LD_ADDR_VAR 0 3
47104: PUSH
47105: DOUBLE
47106: LD_EXP 116
47110: PUSH
47111: LD_VAR 0 2
47115: ARRAY
47116: INC
47117: ST_TO_ADDR
47118: LD_INT 1
47120: PUSH
47121: FOR_DOWNTO
47122: IFFALSE 47478
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47124: LD_EXP 116
47128: PUSH
47129: LD_VAR 0 2
47133: ARRAY
47134: PUSH
47135: LD_VAR 0 3
47139: ARRAY
47140: PPUSH
47141: CALL_OW 301
47145: PUSH
47146: LD_EXP 116
47150: PUSH
47151: LD_VAR 0 2
47155: ARRAY
47156: PUSH
47157: LD_VAR 0 3
47161: ARRAY
47162: PPUSH
47163: CALL_OW 257
47167: PUSH
47168: LD_INT 1
47170: NONEQUAL
47171: OR
47172: IFFALSE 47235
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47174: LD_ADDR_VAR 0 5
47178: PUSH
47179: LD_EXP 116
47183: PUSH
47184: LD_VAR 0 2
47188: ARRAY
47189: PUSH
47190: LD_EXP 116
47194: PUSH
47195: LD_VAR 0 2
47199: ARRAY
47200: PUSH
47201: LD_VAR 0 3
47205: ARRAY
47206: DIFF
47207: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47208: LD_ADDR_EXP 116
47212: PUSH
47213: LD_EXP 116
47217: PPUSH
47218: LD_VAR 0 2
47222: PPUSH
47223: LD_VAR 0 5
47227: PPUSH
47228: CALL_OW 1
47232: ST_TO_ADDR
// continue ;
47233: GO 47121
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47235: LD_EXP 116
47239: PUSH
47240: LD_VAR 0 2
47244: ARRAY
47245: PUSH
47246: LD_VAR 0 3
47250: ARRAY
47251: PPUSH
47252: CALL_OW 257
47256: PUSH
47257: LD_INT 1
47259: EQUAL
47260: PUSH
47261: LD_EXP 116
47265: PUSH
47266: LD_VAR 0 2
47270: ARRAY
47271: PUSH
47272: LD_VAR 0 3
47276: ARRAY
47277: PPUSH
47278: CALL_OW 459
47282: NOT
47283: AND
47284: PUSH
47285: LD_EXP 116
47289: PUSH
47290: LD_VAR 0 2
47294: ARRAY
47295: PUSH
47296: LD_VAR 0 3
47300: ARRAY
47301: PPUSH
47302: CALL_OW 314
47306: NOT
47307: AND
47308: IFFALSE 47476
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47310: LD_EXP 116
47314: PUSH
47315: LD_VAR 0 2
47319: ARRAY
47320: PUSH
47321: LD_VAR 0 3
47325: ARRAY
47326: PPUSH
47327: CALL_OW 310
47331: IFFALSE 47354
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47333: LD_EXP 116
47337: PUSH
47338: LD_VAR 0 2
47342: ARRAY
47343: PUSH
47344: LD_VAR 0 3
47348: ARRAY
47349: PPUSH
47350: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47354: LD_EXP 116
47358: PUSH
47359: LD_VAR 0 2
47363: ARRAY
47364: PUSH
47365: LD_VAR 0 3
47369: ARRAY
47370: PPUSH
47371: CALL_OW 314
47375: NOT
47376: IFFALSE 47476
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47378: LD_EXP 116
47382: PUSH
47383: LD_VAR 0 2
47387: ARRAY
47388: PUSH
47389: LD_VAR 0 3
47393: ARRAY
47394: PPUSH
47395: LD_EXP 115
47399: PUSH
47400: LD_VAR 0 2
47404: ARRAY
47405: PUSH
47406: LD_VAR 0 3
47410: PUSH
47411: LD_EXP 115
47415: PUSH
47416: LD_VAR 0 2
47420: ARRAY
47421: MOD
47422: PUSH
47423: LD_INT 1
47425: PLUS
47426: ARRAY
47427: PUSH
47428: LD_INT 1
47430: ARRAY
47431: PPUSH
47432: LD_EXP 115
47436: PUSH
47437: LD_VAR 0 2
47441: ARRAY
47442: PUSH
47443: LD_VAR 0 3
47447: PUSH
47448: LD_EXP 115
47452: PUSH
47453: LD_VAR 0 2
47457: ARRAY
47458: MOD
47459: PUSH
47460: LD_INT 1
47462: PLUS
47463: ARRAY
47464: PUSH
47465: LD_INT 2
47467: ARRAY
47468: PPUSH
47469: LD_INT 0
47471: PPUSH
47472: CALL_OW 193
// end ; end ;
47476: GO 47121
47478: POP
47479: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47480: LD_ADDR_VAR 0 5
47484: PUSH
47485: LD_EXP 102
47489: PUSH
47490: LD_VAR 0 2
47494: ARRAY
47495: PPUSH
47496: LD_INT 2
47498: PUSH
47499: LD_INT 30
47501: PUSH
47502: LD_INT 4
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 30
47511: PUSH
47512: LD_INT 5
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: PUSH
47519: LD_INT 30
47521: PUSH
47522: LD_INT 32
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: LIST
47533: LIST
47534: PPUSH
47535: CALL_OW 72
47539: ST_TO_ADDR
// if not tmp then
47540: LD_VAR 0 5
47544: NOT
47545: IFFALSE 47549
// continue ;
47547: GO 47034
// list := [ ] ;
47549: LD_ADDR_VAR 0 6
47553: PUSH
47554: EMPTY
47555: ST_TO_ADDR
// for j in tmp do
47556: LD_ADDR_VAR 0 3
47560: PUSH
47561: LD_VAR 0 5
47565: PUSH
47566: FOR_IN
47567: IFFALSE 47636
// begin for k in UnitsInside ( j ) do
47569: LD_ADDR_VAR 0 4
47573: PUSH
47574: LD_VAR 0 3
47578: PPUSH
47579: CALL_OW 313
47583: PUSH
47584: FOR_IN
47585: IFFALSE 47632
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47587: LD_VAR 0 4
47591: PPUSH
47592: CALL_OW 257
47596: PUSH
47597: LD_INT 1
47599: EQUAL
47600: PUSH
47601: LD_VAR 0 4
47605: PPUSH
47606: CALL_OW 459
47610: NOT
47611: AND
47612: IFFALSE 47630
// list := list ^ k ;
47614: LD_ADDR_VAR 0 6
47618: PUSH
47619: LD_VAR 0 6
47623: PUSH
47624: LD_VAR 0 4
47628: ADD
47629: ST_TO_ADDR
47630: GO 47584
47632: POP
47633: POP
// end ;
47634: GO 47566
47636: POP
47637: POP
// list := list diff mc_miners [ i ] ;
47638: LD_ADDR_VAR 0 6
47642: PUSH
47643: LD_VAR 0 6
47647: PUSH
47648: LD_EXP 116
47652: PUSH
47653: LD_VAR 0 2
47657: ARRAY
47658: DIFF
47659: ST_TO_ADDR
// if not list then
47660: LD_VAR 0 6
47664: NOT
47665: IFFALSE 47669
// continue ;
47667: GO 47034
// k := mc_mines [ i ] - mc_miners [ i ] ;
47669: LD_ADDR_VAR 0 4
47673: PUSH
47674: LD_EXP 115
47678: PUSH
47679: LD_VAR 0 2
47683: ARRAY
47684: PUSH
47685: LD_EXP 116
47689: PUSH
47690: LD_VAR 0 2
47694: ARRAY
47695: MINUS
47696: ST_TO_ADDR
// if k > list then
47697: LD_VAR 0 4
47701: PUSH
47702: LD_VAR 0 6
47706: GREATER
47707: IFFALSE 47719
// k := list ;
47709: LD_ADDR_VAR 0 4
47713: PUSH
47714: LD_VAR 0 6
47718: ST_TO_ADDR
// for j = 1 to k do
47719: LD_ADDR_VAR 0 3
47723: PUSH
47724: DOUBLE
47725: LD_INT 1
47727: DEC
47728: ST_TO_ADDR
47729: LD_VAR 0 4
47733: PUSH
47734: FOR_TO
47735: IFFALSE 47789
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47737: LD_ADDR_EXP 116
47741: PUSH
47742: LD_EXP 116
47746: PPUSH
47747: LD_VAR 0 2
47751: PUSH
47752: LD_EXP 116
47756: PUSH
47757: LD_VAR 0 2
47761: ARRAY
47762: PUSH
47763: LD_INT 1
47765: PLUS
47766: PUSH
47767: EMPTY
47768: LIST
47769: LIST
47770: PPUSH
47771: LD_VAR 0 6
47775: PUSH
47776: LD_VAR 0 3
47780: ARRAY
47781: PPUSH
47782: CALL 71983 0 3
47786: ST_TO_ADDR
47787: GO 47734
47789: POP
47790: POP
// end ;
47791: GO 47034
47793: POP
47794: POP
// end ;
47795: LD_VAR 0 1
47799: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47800: LD_INT 0
47802: PPUSH
47803: PPUSH
47804: PPUSH
47805: PPUSH
47806: PPUSH
47807: PPUSH
47808: PPUSH
47809: PPUSH
47810: PPUSH
47811: PPUSH
// if not mc_bases then
47812: LD_EXP 102
47816: NOT
47817: IFFALSE 47821
// exit ;
47819: GO 49571
// for i = 1 to mc_bases do
47821: LD_ADDR_VAR 0 2
47825: PUSH
47826: DOUBLE
47827: LD_INT 1
47829: DEC
47830: ST_TO_ADDR
47831: LD_EXP 102
47835: PUSH
47836: FOR_TO
47837: IFFALSE 49569
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47839: LD_EXP 102
47843: PUSH
47844: LD_VAR 0 2
47848: ARRAY
47849: NOT
47850: PUSH
47851: LD_EXP 109
47855: PUSH
47856: LD_VAR 0 2
47860: ARRAY
47861: OR
47862: IFFALSE 47866
// continue ;
47864: GO 47836
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47866: LD_EXP 118
47870: PUSH
47871: LD_VAR 0 2
47875: ARRAY
47876: NOT
47877: PUSH
47878: LD_EXP 119
47882: PUSH
47883: LD_VAR 0 2
47887: ARRAY
47888: AND
47889: IFFALSE 47927
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47891: LD_ADDR_EXP 119
47895: PUSH
47896: LD_EXP 119
47900: PPUSH
47901: LD_VAR 0 2
47905: PPUSH
47906: EMPTY
47907: PPUSH
47908: CALL_OW 1
47912: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47913: LD_VAR 0 2
47917: PPUSH
47918: LD_INT 107
47920: PPUSH
47921: CALL 38785 0 2
// continue ;
47925: GO 47836
// end ; target := [ ] ;
47927: LD_ADDR_VAR 0 6
47931: PUSH
47932: EMPTY
47933: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47934: LD_ADDR_VAR 0 3
47938: PUSH
47939: DOUBLE
47940: LD_EXP 118
47944: PUSH
47945: LD_VAR 0 2
47949: ARRAY
47950: INC
47951: ST_TO_ADDR
47952: LD_INT 1
47954: PUSH
47955: FOR_DOWNTO
47956: IFFALSE 48216
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47958: LD_EXP 118
47962: PUSH
47963: LD_VAR 0 2
47967: ARRAY
47968: PUSH
47969: LD_VAR 0 3
47973: ARRAY
47974: PUSH
47975: LD_INT 2
47977: ARRAY
47978: PPUSH
47979: LD_EXP 118
47983: PUSH
47984: LD_VAR 0 2
47988: ARRAY
47989: PUSH
47990: LD_VAR 0 3
47994: ARRAY
47995: PUSH
47996: LD_INT 3
47998: ARRAY
47999: PPUSH
48000: CALL_OW 488
48004: PUSH
48005: LD_EXP 118
48009: PUSH
48010: LD_VAR 0 2
48014: ARRAY
48015: PUSH
48016: LD_VAR 0 3
48020: ARRAY
48021: PUSH
48022: LD_INT 2
48024: ARRAY
48025: PPUSH
48026: LD_EXP 118
48030: PUSH
48031: LD_VAR 0 2
48035: ARRAY
48036: PUSH
48037: LD_VAR 0 3
48041: ARRAY
48042: PUSH
48043: LD_INT 3
48045: ARRAY
48046: PPUSH
48047: CALL_OW 284
48051: PUSH
48052: LD_INT 0
48054: EQUAL
48055: AND
48056: IFFALSE 48111
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48058: LD_ADDR_VAR 0 5
48062: PUSH
48063: LD_EXP 118
48067: PUSH
48068: LD_VAR 0 2
48072: ARRAY
48073: PPUSH
48074: LD_VAR 0 3
48078: PPUSH
48079: CALL_OW 3
48083: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48084: LD_ADDR_EXP 118
48088: PUSH
48089: LD_EXP 118
48093: PPUSH
48094: LD_VAR 0 2
48098: PPUSH
48099: LD_VAR 0 5
48103: PPUSH
48104: CALL_OW 1
48108: ST_TO_ADDR
// continue ;
48109: GO 47955
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48111: LD_EXP 102
48115: PUSH
48116: LD_VAR 0 2
48120: ARRAY
48121: PUSH
48122: LD_INT 1
48124: ARRAY
48125: PPUSH
48126: CALL_OW 255
48130: PPUSH
48131: LD_EXP 118
48135: PUSH
48136: LD_VAR 0 2
48140: ARRAY
48141: PUSH
48142: LD_VAR 0 3
48146: ARRAY
48147: PUSH
48148: LD_INT 2
48150: ARRAY
48151: PPUSH
48152: LD_EXP 118
48156: PUSH
48157: LD_VAR 0 2
48161: ARRAY
48162: PUSH
48163: LD_VAR 0 3
48167: ARRAY
48168: PUSH
48169: LD_INT 3
48171: ARRAY
48172: PPUSH
48173: LD_INT 30
48175: PPUSH
48176: CALL 72879 0 4
48180: PUSH
48181: LD_INT 4
48183: ARRAY
48184: PUSH
48185: LD_INT 0
48187: EQUAL
48188: IFFALSE 48214
// begin target := mc_crates [ i ] [ j ] ;
48190: LD_ADDR_VAR 0 6
48194: PUSH
48195: LD_EXP 118
48199: PUSH
48200: LD_VAR 0 2
48204: ARRAY
48205: PUSH
48206: LD_VAR 0 3
48210: ARRAY
48211: ST_TO_ADDR
// break ;
48212: GO 48216
// end ; end ;
48214: GO 47955
48216: POP
48217: POP
// if not target then
48218: LD_VAR 0 6
48222: NOT
48223: IFFALSE 48227
// continue ;
48225: GO 47836
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48227: LD_ADDR_VAR 0 7
48231: PUSH
48232: LD_EXP 121
48236: PUSH
48237: LD_VAR 0 2
48241: ARRAY
48242: PPUSH
48243: LD_INT 2
48245: PUSH
48246: LD_INT 3
48248: PUSH
48249: LD_INT 58
48251: PUSH
48252: EMPTY
48253: LIST
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: PUSH
48259: LD_INT 61
48261: PUSH
48262: EMPTY
48263: LIST
48264: PUSH
48265: LD_INT 33
48267: PUSH
48268: LD_INT 5
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: PUSH
48275: LD_INT 33
48277: PUSH
48278: LD_INT 3
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: PUSH
48292: LD_INT 2
48294: PUSH
48295: LD_INT 34
48297: PUSH
48298: LD_INT 32
48300: PUSH
48301: EMPTY
48302: LIST
48303: LIST
48304: PUSH
48305: LD_INT 34
48307: PUSH
48308: LD_INT 51
48310: PUSH
48311: EMPTY
48312: LIST
48313: LIST
48314: PUSH
48315: LD_INT 34
48317: PUSH
48318: LD_INT 12
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: PUSH
48325: EMPTY
48326: LIST
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PPUSH
48335: CALL_OW 72
48339: ST_TO_ADDR
// if not cargo then
48340: LD_VAR 0 7
48344: NOT
48345: IFFALSE 48988
// begin if mc_crates_collector [ i ] < 5 then
48347: LD_EXP 119
48351: PUSH
48352: LD_VAR 0 2
48356: ARRAY
48357: PUSH
48358: LD_INT 5
48360: LESS
48361: IFFALSE 48727
// begin if mc_ape [ i ] then
48363: LD_EXP 131
48367: PUSH
48368: LD_VAR 0 2
48372: ARRAY
48373: IFFALSE 48420
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48375: LD_ADDR_VAR 0 5
48379: PUSH
48380: LD_EXP 131
48384: PUSH
48385: LD_VAR 0 2
48389: ARRAY
48390: PPUSH
48391: LD_INT 25
48393: PUSH
48394: LD_INT 16
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: LD_INT 24
48403: PUSH
48404: LD_INT 750
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PPUSH
48415: CALL_OW 72
48419: ST_TO_ADDR
// if not tmp then
48420: LD_VAR 0 5
48424: NOT
48425: IFFALSE 48472
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48427: LD_ADDR_VAR 0 5
48431: PUSH
48432: LD_EXP 102
48436: PUSH
48437: LD_VAR 0 2
48441: ARRAY
48442: PPUSH
48443: LD_INT 25
48445: PUSH
48446: LD_INT 2
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 24
48455: PUSH
48456: LD_INT 750
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: EMPTY
48464: LIST
48465: LIST
48466: PPUSH
48467: CALL_OW 72
48471: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48472: LD_EXP 131
48476: PUSH
48477: LD_VAR 0 2
48481: ARRAY
48482: PUSH
48483: LD_EXP 102
48487: PUSH
48488: LD_VAR 0 2
48492: ARRAY
48493: PPUSH
48494: LD_INT 25
48496: PUSH
48497: LD_INT 2
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PUSH
48504: LD_INT 24
48506: PUSH
48507: LD_INT 750
48509: PUSH
48510: EMPTY
48511: LIST
48512: LIST
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PPUSH
48518: CALL_OW 72
48522: AND
48523: PUSH
48524: LD_VAR 0 5
48528: PUSH
48529: LD_INT 5
48531: LESS
48532: AND
48533: IFFALSE 48615
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48535: LD_ADDR_VAR 0 3
48539: PUSH
48540: LD_EXP 102
48544: PUSH
48545: LD_VAR 0 2
48549: ARRAY
48550: PPUSH
48551: LD_INT 25
48553: PUSH
48554: LD_INT 2
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PUSH
48561: LD_INT 24
48563: PUSH
48564: LD_INT 750
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PPUSH
48575: CALL_OW 72
48579: PUSH
48580: FOR_IN
48581: IFFALSE 48613
// begin tmp := tmp union j ;
48583: LD_ADDR_VAR 0 5
48587: PUSH
48588: LD_VAR 0 5
48592: PUSH
48593: LD_VAR 0 3
48597: UNION
48598: ST_TO_ADDR
// if tmp >= 5 then
48599: LD_VAR 0 5
48603: PUSH
48604: LD_INT 5
48606: GREATEREQUAL
48607: IFFALSE 48611
// break ;
48609: GO 48613
// end ;
48611: GO 48580
48613: POP
48614: POP
// end ; if not tmp then
48615: LD_VAR 0 5
48619: NOT
48620: IFFALSE 48624
// continue ;
48622: GO 47836
// for j in tmp do
48624: LD_ADDR_VAR 0 3
48628: PUSH
48629: LD_VAR 0 5
48633: PUSH
48634: FOR_IN
48635: IFFALSE 48725
// if not GetTag ( j ) then
48637: LD_VAR 0 3
48641: PPUSH
48642: CALL_OW 110
48646: NOT
48647: IFFALSE 48723
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48649: LD_ADDR_EXP 119
48653: PUSH
48654: LD_EXP 119
48658: PPUSH
48659: LD_VAR 0 2
48663: PUSH
48664: LD_EXP 119
48668: PUSH
48669: LD_VAR 0 2
48673: ARRAY
48674: PUSH
48675: LD_INT 1
48677: PLUS
48678: PUSH
48679: EMPTY
48680: LIST
48681: LIST
48682: PPUSH
48683: LD_VAR 0 3
48687: PPUSH
48688: CALL 71983 0 3
48692: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48693: LD_VAR 0 3
48697: PPUSH
48698: LD_INT 107
48700: PPUSH
48701: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48705: LD_EXP 119
48709: PUSH
48710: LD_VAR 0 2
48714: ARRAY
48715: PUSH
48716: LD_INT 5
48718: GREATEREQUAL
48719: IFFALSE 48723
// break ;
48721: GO 48725
// end ;
48723: GO 48634
48725: POP
48726: POP
// end ; if mc_crates_collector [ i ] and target then
48727: LD_EXP 119
48731: PUSH
48732: LD_VAR 0 2
48736: ARRAY
48737: PUSH
48738: LD_VAR 0 6
48742: AND
48743: IFFALSE 48986
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48745: LD_EXP 119
48749: PUSH
48750: LD_VAR 0 2
48754: ARRAY
48755: PUSH
48756: LD_VAR 0 6
48760: PUSH
48761: LD_INT 1
48763: ARRAY
48764: LESS
48765: IFFALSE 48785
// tmp := mc_crates_collector [ i ] else
48767: LD_ADDR_VAR 0 5
48771: PUSH
48772: LD_EXP 119
48776: PUSH
48777: LD_VAR 0 2
48781: ARRAY
48782: ST_TO_ADDR
48783: GO 48799
// tmp := target [ 1 ] ;
48785: LD_ADDR_VAR 0 5
48789: PUSH
48790: LD_VAR 0 6
48794: PUSH
48795: LD_INT 1
48797: ARRAY
48798: ST_TO_ADDR
// k := 0 ;
48799: LD_ADDR_VAR 0 4
48803: PUSH
48804: LD_INT 0
48806: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48807: LD_ADDR_VAR 0 3
48811: PUSH
48812: LD_EXP 119
48816: PUSH
48817: LD_VAR 0 2
48821: ARRAY
48822: PUSH
48823: FOR_IN
48824: IFFALSE 48984
// begin k := k + 1 ;
48826: LD_ADDR_VAR 0 4
48830: PUSH
48831: LD_VAR 0 4
48835: PUSH
48836: LD_INT 1
48838: PLUS
48839: ST_TO_ADDR
// if k > tmp then
48840: LD_VAR 0 4
48844: PUSH
48845: LD_VAR 0 5
48849: GREATER
48850: IFFALSE 48854
// break ;
48852: GO 48984
// if not GetClass ( j ) in [ 2 , 16 ] then
48854: LD_VAR 0 3
48858: PPUSH
48859: CALL_OW 257
48863: PUSH
48864: LD_INT 2
48866: PUSH
48867: LD_INT 16
48869: PUSH
48870: EMPTY
48871: LIST
48872: LIST
48873: IN
48874: NOT
48875: IFFALSE 48928
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48877: LD_ADDR_EXP 119
48881: PUSH
48882: LD_EXP 119
48886: PPUSH
48887: LD_VAR 0 2
48891: PPUSH
48892: LD_EXP 119
48896: PUSH
48897: LD_VAR 0 2
48901: ARRAY
48902: PUSH
48903: LD_VAR 0 3
48907: DIFF
48908: PPUSH
48909: CALL_OW 1
48913: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48914: LD_VAR 0 3
48918: PPUSH
48919: LD_INT 0
48921: PPUSH
48922: CALL_OW 109
// continue ;
48926: GO 48823
// end ; if IsInUnit ( j ) then
48928: LD_VAR 0 3
48932: PPUSH
48933: CALL_OW 310
48937: IFFALSE 48948
// ComExitBuilding ( j ) ;
48939: LD_VAR 0 3
48943: PPUSH
48944: CALL_OW 122
// wait ( 3 ) ;
48948: LD_INT 3
48950: PPUSH
48951: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48955: LD_VAR 0 3
48959: PPUSH
48960: LD_VAR 0 6
48964: PUSH
48965: LD_INT 2
48967: ARRAY
48968: PPUSH
48969: LD_VAR 0 6
48973: PUSH
48974: LD_INT 3
48976: ARRAY
48977: PPUSH
48978: CALL_OW 117
// end ;
48982: GO 48823
48984: POP
48985: POP
// end ; end else
48986: GO 49567
// begin for j in cargo do
48988: LD_ADDR_VAR 0 3
48992: PUSH
48993: LD_VAR 0 7
48997: PUSH
48998: FOR_IN
48999: IFFALSE 49565
// begin if GetTag ( j ) <> 0 then
49001: LD_VAR 0 3
49005: PPUSH
49006: CALL_OW 110
49010: PUSH
49011: LD_INT 0
49013: NONEQUAL
49014: IFFALSE 49018
// continue ;
49016: GO 48998
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49018: LD_VAR 0 3
49022: PPUSH
49023: CALL_OW 256
49027: PUSH
49028: LD_INT 1000
49030: LESS
49031: PUSH
49032: LD_VAR 0 3
49036: PPUSH
49037: LD_EXP 126
49041: PUSH
49042: LD_VAR 0 2
49046: ARRAY
49047: PPUSH
49048: CALL_OW 308
49052: NOT
49053: AND
49054: IFFALSE 49076
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49056: LD_VAR 0 3
49060: PPUSH
49061: LD_EXP 126
49065: PUSH
49066: LD_VAR 0 2
49070: ARRAY
49071: PPUSH
49072: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49076: LD_VAR 0 3
49080: PPUSH
49081: CALL_OW 256
49085: PUSH
49086: LD_INT 1000
49088: LESS
49089: PUSH
49090: LD_VAR 0 3
49094: PPUSH
49095: LD_EXP 126
49099: PUSH
49100: LD_VAR 0 2
49104: ARRAY
49105: PPUSH
49106: CALL_OW 308
49110: AND
49111: IFFALSE 49115
// continue ;
49113: GO 48998
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49115: LD_VAR 0 3
49119: PPUSH
49120: CALL_OW 262
49124: PUSH
49125: LD_INT 2
49127: EQUAL
49128: PUSH
49129: LD_VAR 0 3
49133: PPUSH
49134: CALL_OW 261
49138: PUSH
49139: LD_INT 15
49141: LESS
49142: AND
49143: IFFALSE 49147
// continue ;
49145: GO 48998
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49147: LD_VAR 0 3
49151: PPUSH
49152: CALL_OW 262
49156: PUSH
49157: LD_INT 1
49159: EQUAL
49160: PUSH
49161: LD_VAR 0 3
49165: PPUSH
49166: CALL_OW 261
49170: PUSH
49171: LD_INT 10
49173: LESS
49174: AND
49175: IFFALSE 49504
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49177: LD_ADDR_VAR 0 8
49181: PUSH
49182: LD_EXP 102
49186: PUSH
49187: LD_VAR 0 2
49191: ARRAY
49192: PPUSH
49193: LD_INT 2
49195: PUSH
49196: LD_INT 30
49198: PUSH
49199: LD_INT 0
49201: PUSH
49202: EMPTY
49203: LIST
49204: LIST
49205: PUSH
49206: LD_INT 30
49208: PUSH
49209: LD_INT 1
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: LIST
49220: PPUSH
49221: CALL_OW 72
49225: ST_TO_ADDR
// if not depot then
49226: LD_VAR 0 8
49230: NOT
49231: IFFALSE 49235
// continue ;
49233: GO 48998
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49235: LD_VAR 0 3
49239: PPUSH
49240: LD_VAR 0 8
49244: PPUSH
49245: LD_VAR 0 3
49249: PPUSH
49250: CALL_OW 74
49254: PPUSH
49255: CALL_OW 296
49259: PUSH
49260: LD_INT 6
49262: LESS
49263: IFFALSE 49279
// SetFuel ( j , 100 ) else
49265: LD_VAR 0 3
49269: PPUSH
49270: LD_INT 100
49272: PPUSH
49273: CALL_OW 240
49277: GO 49504
// if GetFuel ( j ) = 0 then
49279: LD_VAR 0 3
49283: PPUSH
49284: CALL_OW 261
49288: PUSH
49289: LD_INT 0
49291: EQUAL
49292: IFFALSE 49504
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49294: LD_ADDR_EXP 121
49298: PUSH
49299: LD_EXP 121
49303: PPUSH
49304: LD_VAR 0 2
49308: PPUSH
49309: LD_EXP 121
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 3
49324: DIFF
49325: PPUSH
49326: CALL_OW 1
49330: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49331: LD_VAR 0 3
49335: PPUSH
49336: CALL_OW 263
49340: PUSH
49341: LD_INT 1
49343: EQUAL
49344: IFFALSE 49360
// ComExitVehicle ( IsInUnit ( j ) ) ;
49346: LD_VAR 0 3
49350: PPUSH
49351: CALL_OW 310
49355: PPUSH
49356: CALL_OW 121
// if GetControl ( j ) = control_remote then
49360: LD_VAR 0 3
49364: PPUSH
49365: CALL_OW 263
49369: PUSH
49370: LD_INT 2
49372: EQUAL
49373: IFFALSE 49384
// ComUnlink ( j ) ;
49375: LD_VAR 0 3
49379: PPUSH
49380: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49384: LD_ADDR_VAR 0 9
49388: PUSH
49389: LD_VAR 0 2
49393: PPUSH
49394: LD_INT 3
49396: PPUSH
49397: CALL 58857 0 2
49401: ST_TO_ADDR
// if fac then
49402: LD_VAR 0 9
49406: IFFALSE 49502
// begin for k in fac do
49408: LD_ADDR_VAR 0 4
49412: PUSH
49413: LD_VAR 0 9
49417: PUSH
49418: FOR_IN
49419: IFFALSE 49500
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49421: LD_ADDR_VAR 0 10
49425: PUSH
49426: LD_VAR 0 9
49430: PPUSH
49431: LD_VAR 0 3
49435: PPUSH
49436: CALL_OW 265
49440: PPUSH
49441: LD_VAR 0 3
49445: PPUSH
49446: CALL_OW 262
49450: PPUSH
49451: LD_VAR 0 3
49455: PPUSH
49456: CALL_OW 263
49460: PPUSH
49461: LD_VAR 0 3
49465: PPUSH
49466: CALL_OW 264
49470: PPUSH
49471: CALL 69515 0 5
49475: ST_TO_ADDR
// if components then
49476: LD_VAR 0 10
49480: IFFALSE 49498
// begin MC_InsertProduceList ( i , components ) ;
49482: LD_VAR 0 2
49486: PPUSH
49487: LD_VAR 0 10
49491: PPUSH
49492: CALL 58402 0 2
// break ;
49496: GO 49500
// end ; end ;
49498: GO 49418
49500: POP
49501: POP
// end ; continue ;
49502: GO 48998
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49504: LD_VAR 0 3
49508: PPUSH
49509: LD_INT 1
49511: PPUSH
49512: CALL_OW 289
49516: PUSH
49517: LD_INT 100
49519: LESS
49520: PUSH
49521: LD_VAR 0 3
49525: PPUSH
49526: CALL_OW 314
49530: NOT
49531: AND
49532: IFFALSE 49561
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49534: LD_VAR 0 3
49538: PPUSH
49539: LD_VAR 0 6
49543: PUSH
49544: LD_INT 2
49546: ARRAY
49547: PPUSH
49548: LD_VAR 0 6
49552: PUSH
49553: LD_INT 3
49555: ARRAY
49556: PPUSH
49557: CALL_OW 117
// break ;
49561: GO 49565
// end ;
49563: GO 48998
49565: POP
49566: POP
// end ; end ;
49567: GO 47836
49569: POP
49570: POP
// end ;
49571: LD_VAR 0 1
49575: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49576: LD_INT 0
49578: PPUSH
49579: PPUSH
49580: PPUSH
49581: PPUSH
// if not mc_bases then
49582: LD_EXP 102
49586: NOT
49587: IFFALSE 49591
// exit ;
49589: GO 49752
// for i = 1 to mc_bases do
49591: LD_ADDR_VAR 0 2
49595: PUSH
49596: DOUBLE
49597: LD_INT 1
49599: DEC
49600: ST_TO_ADDR
49601: LD_EXP 102
49605: PUSH
49606: FOR_TO
49607: IFFALSE 49750
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49609: LD_ADDR_VAR 0 4
49613: PUSH
49614: LD_EXP 121
49618: PUSH
49619: LD_VAR 0 2
49623: ARRAY
49624: PUSH
49625: LD_EXP 124
49629: PUSH
49630: LD_VAR 0 2
49634: ARRAY
49635: UNION
49636: PPUSH
49637: LD_INT 33
49639: PUSH
49640: LD_INT 2
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: PPUSH
49647: CALL_OW 72
49651: ST_TO_ADDR
// if tmp then
49652: LD_VAR 0 4
49656: IFFALSE 49748
// for j in tmp do
49658: LD_ADDR_VAR 0 3
49662: PUSH
49663: LD_VAR 0 4
49667: PUSH
49668: FOR_IN
49669: IFFALSE 49746
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49671: LD_VAR 0 3
49675: PPUSH
49676: CALL_OW 312
49680: NOT
49681: PUSH
49682: LD_VAR 0 3
49686: PPUSH
49687: CALL_OW 256
49691: PUSH
49692: LD_INT 250
49694: GREATEREQUAL
49695: AND
49696: IFFALSE 49709
// Connect ( j ) else
49698: LD_VAR 0 3
49702: PPUSH
49703: CALL 74916 0 1
49707: GO 49744
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49709: LD_VAR 0 3
49713: PPUSH
49714: CALL_OW 256
49718: PUSH
49719: LD_INT 250
49721: LESS
49722: PUSH
49723: LD_VAR 0 3
49727: PPUSH
49728: CALL_OW 312
49732: AND
49733: IFFALSE 49744
// ComUnlink ( j ) ;
49735: LD_VAR 0 3
49739: PPUSH
49740: CALL_OW 136
49744: GO 49668
49746: POP
49747: POP
// end ;
49748: GO 49606
49750: POP
49751: POP
// end ;
49752: LD_VAR 0 1
49756: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49757: LD_INT 0
49759: PPUSH
49760: PPUSH
49761: PPUSH
49762: PPUSH
49763: PPUSH
// if not mc_bases then
49764: LD_EXP 102
49768: NOT
49769: IFFALSE 49773
// exit ;
49771: GO 50218
// for i = 1 to mc_bases do
49773: LD_ADDR_VAR 0 2
49777: PUSH
49778: DOUBLE
49779: LD_INT 1
49781: DEC
49782: ST_TO_ADDR
49783: LD_EXP 102
49787: PUSH
49788: FOR_TO
49789: IFFALSE 50216
// begin if not mc_produce [ i ] then
49791: LD_EXP 123
49795: PUSH
49796: LD_VAR 0 2
49800: ARRAY
49801: NOT
49802: IFFALSE 49806
// continue ;
49804: GO 49788
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49806: LD_ADDR_VAR 0 5
49810: PUSH
49811: LD_EXP 102
49815: PUSH
49816: LD_VAR 0 2
49820: ARRAY
49821: PPUSH
49822: LD_INT 30
49824: PUSH
49825: LD_INT 3
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PPUSH
49832: CALL_OW 72
49836: ST_TO_ADDR
// if not fac then
49837: LD_VAR 0 5
49841: NOT
49842: IFFALSE 49846
// continue ;
49844: GO 49788
// for j in fac do
49846: LD_ADDR_VAR 0 3
49850: PUSH
49851: LD_VAR 0 5
49855: PUSH
49856: FOR_IN
49857: IFFALSE 50212
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49859: LD_VAR 0 3
49863: PPUSH
49864: CALL_OW 461
49868: PUSH
49869: LD_INT 2
49871: NONEQUAL
49872: PUSH
49873: LD_VAR 0 3
49877: PPUSH
49878: LD_INT 15
49880: PPUSH
49881: CALL 74576 0 2
49885: PUSH
49886: LD_INT 4
49888: ARRAY
49889: OR
49890: IFFALSE 49894
// continue ;
49892: GO 49856
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49894: LD_VAR 0 3
49898: PPUSH
49899: LD_EXP 123
49903: PUSH
49904: LD_VAR 0 2
49908: ARRAY
49909: PUSH
49910: LD_INT 1
49912: ARRAY
49913: PUSH
49914: LD_INT 1
49916: ARRAY
49917: PPUSH
49918: LD_EXP 123
49922: PUSH
49923: LD_VAR 0 2
49927: ARRAY
49928: PUSH
49929: LD_INT 1
49931: ARRAY
49932: PUSH
49933: LD_INT 2
49935: ARRAY
49936: PPUSH
49937: LD_EXP 123
49941: PUSH
49942: LD_VAR 0 2
49946: ARRAY
49947: PUSH
49948: LD_INT 1
49950: ARRAY
49951: PUSH
49952: LD_INT 3
49954: ARRAY
49955: PPUSH
49956: LD_EXP 123
49960: PUSH
49961: LD_VAR 0 2
49965: ARRAY
49966: PUSH
49967: LD_INT 1
49969: ARRAY
49970: PUSH
49971: LD_INT 4
49973: ARRAY
49974: PPUSH
49975: CALL_OW 448
49979: PUSH
49980: LD_VAR 0 3
49984: PPUSH
49985: LD_EXP 123
49989: PUSH
49990: LD_VAR 0 2
49994: ARRAY
49995: PUSH
49996: LD_INT 1
49998: ARRAY
49999: PUSH
50000: LD_INT 1
50002: ARRAY
50003: PUSH
50004: LD_EXP 123
50008: PUSH
50009: LD_VAR 0 2
50013: ARRAY
50014: PUSH
50015: LD_INT 1
50017: ARRAY
50018: PUSH
50019: LD_INT 2
50021: ARRAY
50022: PUSH
50023: LD_EXP 123
50027: PUSH
50028: LD_VAR 0 2
50032: ARRAY
50033: PUSH
50034: LD_INT 1
50036: ARRAY
50037: PUSH
50038: LD_INT 3
50040: ARRAY
50041: PUSH
50042: LD_EXP 123
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: PUSH
50057: LD_INT 4
50059: ARRAY
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: LIST
50065: LIST
50066: PPUSH
50067: CALL 78247 0 2
50071: AND
50072: IFFALSE 50210
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50074: LD_VAR 0 3
50078: PPUSH
50079: LD_EXP 123
50083: PUSH
50084: LD_VAR 0 2
50088: ARRAY
50089: PUSH
50090: LD_INT 1
50092: ARRAY
50093: PUSH
50094: LD_INT 1
50096: ARRAY
50097: PPUSH
50098: LD_EXP 123
50102: PUSH
50103: LD_VAR 0 2
50107: ARRAY
50108: PUSH
50109: LD_INT 1
50111: ARRAY
50112: PUSH
50113: LD_INT 2
50115: ARRAY
50116: PPUSH
50117: LD_EXP 123
50121: PUSH
50122: LD_VAR 0 2
50126: ARRAY
50127: PUSH
50128: LD_INT 1
50130: ARRAY
50131: PUSH
50132: LD_INT 3
50134: ARRAY
50135: PPUSH
50136: LD_EXP 123
50140: PUSH
50141: LD_VAR 0 2
50145: ARRAY
50146: PUSH
50147: LD_INT 1
50149: ARRAY
50150: PUSH
50151: LD_INT 4
50153: ARRAY
50154: PPUSH
50155: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50159: LD_ADDR_VAR 0 4
50163: PUSH
50164: LD_EXP 123
50168: PUSH
50169: LD_VAR 0 2
50173: ARRAY
50174: PPUSH
50175: LD_INT 1
50177: PPUSH
50178: CALL_OW 3
50182: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50183: LD_ADDR_EXP 123
50187: PUSH
50188: LD_EXP 123
50192: PPUSH
50193: LD_VAR 0 2
50197: PPUSH
50198: LD_VAR 0 4
50202: PPUSH
50203: CALL_OW 1
50207: ST_TO_ADDR
// break ;
50208: GO 50212
// end ; end ;
50210: GO 49856
50212: POP
50213: POP
// end ;
50214: GO 49788
50216: POP
50217: POP
// end ;
50218: LD_VAR 0 1
50222: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50223: LD_INT 0
50225: PPUSH
50226: PPUSH
50227: PPUSH
// if not mc_bases then
50228: LD_EXP 102
50232: NOT
50233: IFFALSE 50237
// exit ;
50235: GO 50326
// for i = 1 to mc_bases do
50237: LD_ADDR_VAR 0 2
50241: PUSH
50242: DOUBLE
50243: LD_INT 1
50245: DEC
50246: ST_TO_ADDR
50247: LD_EXP 102
50251: PUSH
50252: FOR_TO
50253: IFFALSE 50324
// begin if mc_attack [ i ] then
50255: LD_EXP 122
50259: PUSH
50260: LD_VAR 0 2
50264: ARRAY
50265: IFFALSE 50322
// begin tmp := mc_attack [ i ] [ 1 ] ;
50267: LD_ADDR_VAR 0 3
50271: PUSH
50272: LD_EXP 122
50276: PUSH
50277: LD_VAR 0 2
50281: ARRAY
50282: PUSH
50283: LD_INT 1
50285: ARRAY
50286: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50287: LD_ADDR_EXP 122
50291: PUSH
50292: LD_EXP 122
50296: PPUSH
50297: LD_VAR 0 2
50301: PPUSH
50302: EMPTY
50303: PPUSH
50304: CALL_OW 1
50308: ST_TO_ADDR
// Attack ( tmp ) ;
50309: LD_VAR 0 3
50313: PPUSH
50314: CALL 100437 0 1
// exit ;
50318: POP
50319: POP
50320: GO 50326
// end ; end ;
50322: GO 50252
50324: POP
50325: POP
// end ;
50326: LD_VAR 0 1
50330: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50331: LD_INT 0
50333: PPUSH
50334: PPUSH
50335: PPUSH
50336: PPUSH
50337: PPUSH
50338: PPUSH
50339: PPUSH
// if not mc_bases then
50340: LD_EXP 102
50344: NOT
50345: IFFALSE 50349
// exit ;
50347: GO 50931
// for i = 1 to mc_bases do
50349: LD_ADDR_VAR 0 2
50353: PUSH
50354: DOUBLE
50355: LD_INT 1
50357: DEC
50358: ST_TO_ADDR
50359: LD_EXP 102
50363: PUSH
50364: FOR_TO
50365: IFFALSE 50929
// begin if not mc_bases [ i ] then
50367: LD_EXP 102
50371: PUSH
50372: LD_VAR 0 2
50376: ARRAY
50377: NOT
50378: IFFALSE 50382
// continue ;
50380: GO 50364
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50382: LD_ADDR_VAR 0 7
50386: PUSH
50387: LD_EXP 102
50391: PUSH
50392: LD_VAR 0 2
50396: ARRAY
50397: PUSH
50398: LD_INT 1
50400: ARRAY
50401: PPUSH
50402: CALL 68819 0 1
50406: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50407: LD_ADDR_EXP 125
50411: PUSH
50412: LD_EXP 125
50416: PPUSH
50417: LD_VAR 0 2
50421: PPUSH
50422: LD_EXP 102
50426: PUSH
50427: LD_VAR 0 2
50431: ARRAY
50432: PUSH
50433: LD_INT 1
50435: ARRAY
50436: PPUSH
50437: CALL_OW 255
50441: PPUSH
50442: LD_EXP 127
50446: PUSH
50447: LD_VAR 0 2
50451: ARRAY
50452: PPUSH
50453: CALL 66373 0 2
50457: PPUSH
50458: CALL_OW 1
50462: ST_TO_ADDR
// if not mc_scan [ i ] then
50463: LD_EXP 125
50467: PUSH
50468: LD_VAR 0 2
50472: ARRAY
50473: NOT
50474: IFFALSE 50629
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50476: LD_ADDR_VAR 0 4
50480: PUSH
50481: LD_EXP 102
50485: PUSH
50486: LD_VAR 0 2
50490: ARRAY
50491: PPUSH
50492: LD_INT 2
50494: PUSH
50495: LD_INT 25
50497: PUSH
50498: LD_INT 5
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: PUSH
50505: LD_INT 25
50507: PUSH
50508: LD_INT 8
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 25
50517: PUSH
50518: LD_INT 9
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: EMPTY
50526: LIST
50527: LIST
50528: LIST
50529: LIST
50530: PPUSH
50531: CALL_OW 72
50535: ST_TO_ADDR
// if not tmp then
50536: LD_VAR 0 4
50540: NOT
50541: IFFALSE 50545
// continue ;
50543: GO 50364
// for j in tmp do
50545: LD_ADDR_VAR 0 3
50549: PUSH
50550: LD_VAR 0 4
50554: PUSH
50555: FOR_IN
50556: IFFALSE 50627
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50558: LD_VAR 0 3
50562: PPUSH
50563: CALL_OW 310
50567: PPUSH
50568: CALL_OW 266
50572: PUSH
50573: LD_INT 5
50575: EQUAL
50576: PUSH
50577: LD_VAR 0 3
50581: PPUSH
50582: CALL_OW 257
50586: PUSH
50587: LD_INT 1
50589: EQUAL
50590: AND
50591: PUSH
50592: LD_VAR 0 3
50596: PPUSH
50597: CALL_OW 459
50601: NOT
50602: AND
50603: PUSH
50604: LD_VAR 0 7
50608: AND
50609: IFFALSE 50625
// ComChangeProfession ( j , class ) ;
50611: LD_VAR 0 3
50615: PPUSH
50616: LD_VAR 0 7
50620: PPUSH
50621: CALL_OW 123
50625: GO 50555
50627: POP
50628: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50629: LD_EXP 125
50633: PUSH
50634: LD_VAR 0 2
50638: ARRAY
50639: PUSH
50640: LD_EXP 124
50644: PUSH
50645: LD_VAR 0 2
50649: ARRAY
50650: NOT
50651: AND
50652: PUSH
50653: LD_EXP 102
50657: PUSH
50658: LD_VAR 0 2
50662: ARRAY
50663: PPUSH
50664: LD_INT 30
50666: PUSH
50667: LD_INT 32
50669: PUSH
50670: EMPTY
50671: LIST
50672: LIST
50673: PPUSH
50674: CALL_OW 72
50678: NOT
50679: AND
50680: PUSH
50681: LD_EXP 102
50685: PUSH
50686: LD_VAR 0 2
50690: ARRAY
50691: PPUSH
50692: LD_INT 2
50694: PUSH
50695: LD_INT 30
50697: PUSH
50698: LD_INT 4
50700: PUSH
50701: EMPTY
50702: LIST
50703: LIST
50704: PUSH
50705: LD_INT 30
50707: PUSH
50708: LD_INT 5
50710: PUSH
50711: EMPTY
50712: LIST
50713: LIST
50714: PUSH
50715: EMPTY
50716: LIST
50717: LIST
50718: LIST
50719: PPUSH
50720: CALL_OW 72
50724: NOT
50725: AND
50726: IFFALSE 50858
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50728: LD_ADDR_VAR 0 4
50732: PUSH
50733: LD_EXP 102
50737: PUSH
50738: LD_VAR 0 2
50742: ARRAY
50743: PPUSH
50744: LD_INT 2
50746: PUSH
50747: LD_INT 25
50749: PUSH
50750: LD_INT 1
50752: PUSH
50753: EMPTY
50754: LIST
50755: LIST
50756: PUSH
50757: LD_INT 25
50759: PUSH
50760: LD_INT 5
50762: PUSH
50763: EMPTY
50764: LIST
50765: LIST
50766: PUSH
50767: LD_INT 25
50769: PUSH
50770: LD_INT 8
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PUSH
50777: LD_INT 25
50779: PUSH
50780: LD_INT 9
50782: PUSH
50783: EMPTY
50784: LIST
50785: LIST
50786: PUSH
50787: EMPTY
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: PPUSH
50794: CALL_OW 72
50798: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50799: LD_ADDR_VAR 0 4
50803: PUSH
50804: LD_VAR 0 4
50808: PUSH
50809: LD_VAR 0 4
50813: PPUSH
50814: LD_INT 18
50816: PPUSH
50817: CALL 105246 0 2
50821: DIFF
50822: ST_TO_ADDR
// if tmp then
50823: LD_VAR 0 4
50827: IFFALSE 50858
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50829: LD_VAR 0 2
50833: PPUSH
50834: LD_VAR 0 4
50838: PPUSH
50839: LD_EXP 127
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PPUSH
50850: CALL 66408 0 3
// exit ;
50854: POP
50855: POP
50856: GO 50931
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50858: LD_EXP 125
50862: PUSH
50863: LD_VAR 0 2
50867: ARRAY
50868: PUSH
50869: LD_EXP 124
50873: PUSH
50874: LD_VAR 0 2
50878: ARRAY
50879: AND
50880: IFFALSE 50927
// begin tmp := mc_defender [ i ] ;
50882: LD_ADDR_VAR 0 4
50886: PUSH
50887: LD_EXP 124
50891: PUSH
50892: LD_VAR 0 2
50896: ARRAY
50897: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50898: LD_VAR 0 2
50902: PPUSH
50903: LD_VAR 0 4
50907: PPUSH
50908: LD_EXP 125
50912: PUSH
50913: LD_VAR 0 2
50917: ARRAY
50918: PPUSH
50919: CALL 66969 0 3
// exit ;
50923: POP
50924: POP
50925: GO 50931
// end ; end ;
50927: GO 50364
50929: POP
50930: POP
// end ;
50931: LD_VAR 0 1
50935: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50936: LD_INT 0
50938: PPUSH
50939: PPUSH
50940: PPUSH
50941: PPUSH
50942: PPUSH
50943: PPUSH
50944: PPUSH
50945: PPUSH
50946: PPUSH
50947: PPUSH
50948: PPUSH
// if not mc_bases then
50949: LD_EXP 102
50953: NOT
50954: IFFALSE 50958
// exit ;
50956: GO 52045
// for i = 1 to mc_bases do
50958: LD_ADDR_VAR 0 2
50962: PUSH
50963: DOUBLE
50964: LD_INT 1
50966: DEC
50967: ST_TO_ADDR
50968: LD_EXP 102
50972: PUSH
50973: FOR_TO
50974: IFFALSE 52043
// begin tmp := mc_lab [ i ] ;
50976: LD_ADDR_VAR 0 6
50980: PUSH
50981: LD_EXP 135
50985: PUSH
50986: LD_VAR 0 2
50990: ARRAY
50991: ST_TO_ADDR
// if not tmp then
50992: LD_VAR 0 6
50996: NOT
50997: IFFALSE 51001
// continue ;
50999: GO 50973
// idle_lab := 0 ;
51001: LD_ADDR_VAR 0 11
51005: PUSH
51006: LD_INT 0
51008: ST_TO_ADDR
// for j in tmp do
51009: LD_ADDR_VAR 0 3
51013: PUSH
51014: LD_VAR 0 6
51018: PUSH
51019: FOR_IN
51020: IFFALSE 52039
// begin researching := false ;
51022: LD_ADDR_VAR 0 10
51026: PUSH
51027: LD_INT 0
51029: ST_TO_ADDR
// side := GetSide ( j ) ;
51030: LD_ADDR_VAR 0 4
51034: PUSH
51035: LD_VAR 0 3
51039: PPUSH
51040: CALL_OW 255
51044: ST_TO_ADDR
// if not mc_tech [ side ] then
51045: LD_EXP 129
51049: PUSH
51050: LD_VAR 0 4
51054: ARRAY
51055: NOT
51056: IFFALSE 51060
// continue ;
51058: GO 51019
// if BuildingStatus ( j ) = bs_idle then
51060: LD_VAR 0 3
51064: PPUSH
51065: CALL_OW 461
51069: PUSH
51070: LD_INT 2
51072: EQUAL
51073: IFFALSE 51261
// begin if idle_lab and UnitsInside ( j ) < 6 then
51075: LD_VAR 0 11
51079: PUSH
51080: LD_VAR 0 3
51084: PPUSH
51085: CALL_OW 313
51089: PUSH
51090: LD_INT 6
51092: LESS
51093: AND
51094: IFFALSE 51165
// begin tmp2 := UnitsInside ( idle_lab ) ;
51096: LD_ADDR_VAR 0 9
51100: PUSH
51101: LD_VAR 0 11
51105: PPUSH
51106: CALL_OW 313
51110: ST_TO_ADDR
// if tmp2 then
51111: LD_VAR 0 9
51115: IFFALSE 51157
// for x in tmp2 do
51117: LD_ADDR_VAR 0 7
51121: PUSH
51122: LD_VAR 0 9
51126: PUSH
51127: FOR_IN
51128: IFFALSE 51155
// begin ComExitBuilding ( x ) ;
51130: LD_VAR 0 7
51134: PPUSH
51135: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51139: LD_VAR 0 7
51143: PPUSH
51144: LD_VAR 0 3
51148: PPUSH
51149: CALL_OW 180
// end ;
51153: GO 51127
51155: POP
51156: POP
// idle_lab := 0 ;
51157: LD_ADDR_VAR 0 11
51161: PUSH
51162: LD_INT 0
51164: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51165: LD_ADDR_VAR 0 5
51169: PUSH
51170: LD_EXP 129
51174: PUSH
51175: LD_VAR 0 4
51179: ARRAY
51180: PUSH
51181: FOR_IN
51182: IFFALSE 51242
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51184: LD_VAR 0 3
51188: PPUSH
51189: LD_VAR 0 5
51193: PPUSH
51194: CALL_OW 430
51198: PUSH
51199: LD_VAR 0 4
51203: PPUSH
51204: LD_VAR 0 5
51208: PPUSH
51209: CALL 65478 0 2
51213: AND
51214: IFFALSE 51240
// begin researching := true ;
51216: LD_ADDR_VAR 0 10
51220: PUSH
51221: LD_INT 1
51223: ST_TO_ADDR
// ComResearch ( j , t ) ;
51224: LD_VAR 0 3
51228: PPUSH
51229: LD_VAR 0 5
51233: PPUSH
51234: CALL_OW 124
// break ;
51238: GO 51242
// end ;
51240: GO 51181
51242: POP
51243: POP
// if not researching then
51244: LD_VAR 0 10
51248: NOT
51249: IFFALSE 51261
// idle_lab := j ;
51251: LD_ADDR_VAR 0 11
51255: PUSH
51256: LD_VAR 0 3
51260: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51261: LD_VAR 0 3
51265: PPUSH
51266: CALL_OW 461
51270: PUSH
51271: LD_INT 10
51273: EQUAL
51274: IFFALSE 51862
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51276: LD_EXP 131
51280: PUSH
51281: LD_VAR 0 2
51285: ARRAY
51286: NOT
51287: PUSH
51288: LD_EXP 132
51292: PUSH
51293: LD_VAR 0 2
51297: ARRAY
51298: NOT
51299: AND
51300: PUSH
51301: LD_EXP 129
51305: PUSH
51306: LD_VAR 0 4
51310: ARRAY
51311: PUSH
51312: LD_INT 1
51314: GREATER
51315: AND
51316: IFFALSE 51447
// begin ComCancel ( j ) ;
51318: LD_VAR 0 3
51322: PPUSH
51323: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51327: LD_ADDR_EXP 129
51331: PUSH
51332: LD_EXP 129
51336: PPUSH
51337: LD_VAR 0 4
51341: PPUSH
51342: LD_EXP 129
51346: PUSH
51347: LD_VAR 0 4
51351: ARRAY
51352: PPUSH
51353: LD_EXP 129
51357: PUSH
51358: LD_VAR 0 4
51362: ARRAY
51363: PUSH
51364: LD_INT 1
51366: MINUS
51367: PPUSH
51368: LD_EXP 129
51372: PUSH
51373: LD_VAR 0 4
51377: ARRAY
51378: PPUSH
51379: LD_INT 0
51381: PPUSH
51382: CALL 71401 0 4
51386: PPUSH
51387: CALL_OW 1
51391: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51392: LD_ADDR_EXP 129
51396: PUSH
51397: LD_EXP 129
51401: PPUSH
51402: LD_VAR 0 4
51406: PPUSH
51407: LD_EXP 129
51411: PUSH
51412: LD_VAR 0 4
51416: ARRAY
51417: PPUSH
51418: LD_EXP 129
51422: PUSH
51423: LD_VAR 0 4
51427: ARRAY
51428: PPUSH
51429: LD_INT 1
51431: PPUSH
51432: LD_INT 0
51434: PPUSH
51435: CALL 71401 0 4
51439: PPUSH
51440: CALL_OW 1
51444: ST_TO_ADDR
// continue ;
51445: GO 51019
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51447: LD_EXP 131
51451: PUSH
51452: LD_VAR 0 2
51456: ARRAY
51457: PUSH
51458: LD_EXP 132
51462: PUSH
51463: LD_VAR 0 2
51467: ARRAY
51468: NOT
51469: AND
51470: IFFALSE 51597
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51472: LD_ADDR_EXP 132
51476: PUSH
51477: LD_EXP 132
51481: PPUSH
51482: LD_VAR 0 2
51486: PUSH
51487: LD_EXP 132
51491: PUSH
51492: LD_VAR 0 2
51496: ARRAY
51497: PUSH
51498: LD_INT 1
51500: PLUS
51501: PUSH
51502: EMPTY
51503: LIST
51504: LIST
51505: PPUSH
51506: LD_EXP 131
51510: PUSH
51511: LD_VAR 0 2
51515: ARRAY
51516: PUSH
51517: LD_INT 1
51519: ARRAY
51520: PPUSH
51521: CALL 71983 0 3
51525: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51526: LD_EXP 131
51530: PUSH
51531: LD_VAR 0 2
51535: ARRAY
51536: PUSH
51537: LD_INT 1
51539: ARRAY
51540: PPUSH
51541: LD_INT 112
51543: PPUSH
51544: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51548: LD_ADDR_VAR 0 9
51552: PUSH
51553: LD_EXP 131
51557: PUSH
51558: LD_VAR 0 2
51562: ARRAY
51563: PPUSH
51564: LD_INT 1
51566: PPUSH
51567: CALL_OW 3
51571: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51572: LD_ADDR_EXP 131
51576: PUSH
51577: LD_EXP 131
51581: PPUSH
51582: LD_VAR 0 2
51586: PPUSH
51587: LD_VAR 0 9
51591: PPUSH
51592: CALL_OW 1
51596: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51597: LD_EXP 131
51601: PUSH
51602: LD_VAR 0 2
51606: ARRAY
51607: PUSH
51608: LD_EXP 132
51612: PUSH
51613: LD_VAR 0 2
51617: ARRAY
51618: AND
51619: PUSH
51620: LD_EXP 132
51624: PUSH
51625: LD_VAR 0 2
51629: ARRAY
51630: PUSH
51631: LD_INT 1
51633: ARRAY
51634: PPUSH
51635: CALL_OW 310
51639: NOT
51640: AND
51641: PUSH
51642: LD_VAR 0 3
51646: PPUSH
51647: CALL_OW 313
51651: PUSH
51652: LD_INT 6
51654: EQUAL
51655: AND
51656: IFFALSE 51712
// begin tmp2 := UnitsInside ( j ) ;
51658: LD_ADDR_VAR 0 9
51662: PUSH
51663: LD_VAR 0 3
51667: PPUSH
51668: CALL_OW 313
51672: ST_TO_ADDR
// if tmp2 = 6 then
51673: LD_VAR 0 9
51677: PUSH
51678: LD_INT 6
51680: EQUAL
51681: IFFALSE 51712
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51683: LD_VAR 0 9
51687: PUSH
51688: LD_INT 1
51690: ARRAY
51691: PPUSH
51692: LD_INT 112
51694: PPUSH
51695: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51699: LD_VAR 0 9
51703: PUSH
51704: LD_INT 1
51706: ARRAY
51707: PPUSH
51708: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51712: LD_EXP 132
51716: PUSH
51717: LD_VAR 0 2
51721: ARRAY
51722: PUSH
51723: LD_EXP 132
51727: PUSH
51728: LD_VAR 0 2
51732: ARRAY
51733: PUSH
51734: LD_INT 1
51736: ARRAY
51737: PPUSH
51738: CALL_OW 314
51742: NOT
51743: AND
51744: PUSH
51745: LD_EXP 132
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PUSH
51756: LD_INT 1
51758: ARRAY
51759: PPUSH
51760: CALL_OW 310
51764: NOT
51765: AND
51766: IFFALSE 51792
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51768: LD_EXP 132
51772: PUSH
51773: LD_VAR 0 2
51777: ARRAY
51778: PUSH
51779: LD_INT 1
51781: ARRAY
51782: PPUSH
51783: LD_VAR 0 3
51787: PPUSH
51788: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51792: LD_EXP 132
51796: PUSH
51797: LD_VAR 0 2
51801: ARRAY
51802: PUSH
51803: LD_INT 1
51805: ARRAY
51806: PPUSH
51807: CALL_OW 310
51811: PUSH
51812: LD_EXP 132
51816: PUSH
51817: LD_VAR 0 2
51821: ARRAY
51822: PUSH
51823: LD_INT 1
51825: ARRAY
51826: PPUSH
51827: CALL_OW 310
51831: PPUSH
51832: CALL_OW 461
51836: PUSH
51837: LD_INT 3
51839: NONEQUAL
51840: AND
51841: IFFALSE 51862
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51843: LD_EXP 132
51847: PUSH
51848: LD_VAR 0 2
51852: ARRAY
51853: PUSH
51854: LD_INT 1
51856: ARRAY
51857: PPUSH
51858: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51862: LD_VAR 0 3
51866: PPUSH
51867: CALL_OW 461
51871: PUSH
51872: LD_INT 6
51874: EQUAL
51875: PUSH
51876: LD_VAR 0 6
51880: PUSH
51881: LD_INT 1
51883: GREATER
51884: AND
51885: IFFALSE 52037
// begin sci := [ ] ;
51887: LD_ADDR_VAR 0 8
51891: PUSH
51892: EMPTY
51893: ST_TO_ADDR
// for x in ( tmp diff j ) do
51894: LD_ADDR_VAR 0 7
51898: PUSH
51899: LD_VAR 0 6
51903: PUSH
51904: LD_VAR 0 3
51908: DIFF
51909: PUSH
51910: FOR_IN
51911: IFFALSE 51963
// begin if sci = 6 then
51913: LD_VAR 0 8
51917: PUSH
51918: LD_INT 6
51920: EQUAL
51921: IFFALSE 51925
// break ;
51923: GO 51963
// if BuildingStatus ( x ) = bs_idle then
51925: LD_VAR 0 7
51929: PPUSH
51930: CALL_OW 461
51934: PUSH
51935: LD_INT 2
51937: EQUAL
51938: IFFALSE 51961
// sci := sci ^ UnitsInside ( x ) ;
51940: LD_ADDR_VAR 0 8
51944: PUSH
51945: LD_VAR 0 8
51949: PUSH
51950: LD_VAR 0 7
51954: PPUSH
51955: CALL_OW 313
51959: ADD
51960: ST_TO_ADDR
// end ;
51961: GO 51910
51963: POP
51964: POP
// if not sci then
51965: LD_VAR 0 8
51969: NOT
51970: IFFALSE 51974
// continue ;
51972: GO 51019
// for x in sci do
51974: LD_ADDR_VAR 0 7
51978: PUSH
51979: LD_VAR 0 8
51983: PUSH
51984: FOR_IN
51985: IFFALSE 52035
// if IsInUnit ( x ) and not HasTask ( x ) then
51987: LD_VAR 0 7
51991: PPUSH
51992: CALL_OW 310
51996: PUSH
51997: LD_VAR 0 7
52001: PPUSH
52002: CALL_OW 314
52006: NOT
52007: AND
52008: IFFALSE 52033
// begin ComExitBuilding ( x ) ;
52010: LD_VAR 0 7
52014: PPUSH
52015: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52019: LD_VAR 0 7
52023: PPUSH
52024: LD_VAR 0 3
52028: PPUSH
52029: CALL_OW 180
// end ;
52033: GO 51984
52035: POP
52036: POP
// end ; end ;
52037: GO 51019
52039: POP
52040: POP
// end ;
52041: GO 50973
52043: POP
52044: POP
// end ;
52045: LD_VAR 0 1
52049: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52050: LD_INT 0
52052: PPUSH
52053: PPUSH
// if not mc_bases then
52054: LD_EXP 102
52058: NOT
52059: IFFALSE 52063
// exit ;
52061: GO 52144
// for i = 1 to mc_bases do
52063: LD_ADDR_VAR 0 2
52067: PUSH
52068: DOUBLE
52069: LD_INT 1
52071: DEC
52072: ST_TO_ADDR
52073: LD_EXP 102
52077: PUSH
52078: FOR_TO
52079: IFFALSE 52142
// if mc_mines [ i ] and mc_miners [ i ] then
52081: LD_EXP 115
52085: PUSH
52086: LD_VAR 0 2
52090: ARRAY
52091: PUSH
52092: LD_EXP 116
52096: PUSH
52097: LD_VAR 0 2
52101: ARRAY
52102: AND
52103: IFFALSE 52140
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52105: LD_EXP 116
52109: PUSH
52110: LD_VAR 0 2
52114: ARRAY
52115: PUSH
52116: LD_INT 1
52118: ARRAY
52119: PPUSH
52120: CALL_OW 255
52124: PPUSH
52125: LD_EXP 115
52129: PUSH
52130: LD_VAR 0 2
52134: ARRAY
52135: PPUSH
52136: CALL 68972 0 2
52140: GO 52078
52142: POP
52143: POP
// end ;
52144: LD_VAR 0 1
52148: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52149: LD_INT 0
52151: PPUSH
52152: PPUSH
52153: PPUSH
52154: PPUSH
52155: PPUSH
52156: PPUSH
52157: PPUSH
52158: PPUSH
// if not mc_bases or not mc_parking then
52159: LD_EXP 102
52163: NOT
52164: PUSH
52165: LD_EXP 126
52169: NOT
52170: OR
52171: IFFALSE 52175
// exit ;
52173: GO 52874
// for i = 1 to mc_bases do
52175: LD_ADDR_VAR 0 2
52179: PUSH
52180: DOUBLE
52181: LD_INT 1
52183: DEC
52184: ST_TO_ADDR
52185: LD_EXP 102
52189: PUSH
52190: FOR_TO
52191: IFFALSE 52872
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52193: LD_EXP 102
52197: PUSH
52198: LD_VAR 0 2
52202: ARRAY
52203: NOT
52204: PUSH
52205: LD_EXP 126
52209: PUSH
52210: LD_VAR 0 2
52214: ARRAY
52215: NOT
52216: OR
52217: IFFALSE 52221
// continue ;
52219: GO 52190
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52221: LD_ADDR_VAR 0 5
52225: PUSH
52226: LD_EXP 102
52230: PUSH
52231: LD_VAR 0 2
52235: ARRAY
52236: PUSH
52237: LD_INT 1
52239: ARRAY
52240: PPUSH
52241: CALL_OW 255
52245: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52246: LD_ADDR_VAR 0 6
52250: PUSH
52251: LD_EXP 102
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PPUSH
52262: LD_INT 30
52264: PUSH
52265: LD_INT 3
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PPUSH
52272: CALL_OW 72
52276: ST_TO_ADDR
// if not fac then
52277: LD_VAR 0 6
52281: NOT
52282: IFFALSE 52333
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52284: LD_ADDR_VAR 0 6
52288: PUSH
52289: LD_EXP 102
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: PPUSH
52300: LD_INT 2
52302: PUSH
52303: LD_INT 30
52305: PUSH
52306: LD_INT 0
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: PUSH
52313: LD_INT 30
52315: PUSH
52316: LD_INT 1
52318: PUSH
52319: EMPTY
52320: LIST
52321: LIST
52322: PUSH
52323: EMPTY
52324: LIST
52325: LIST
52326: LIST
52327: PPUSH
52328: CALL_OW 72
52332: ST_TO_ADDR
// if not fac then
52333: LD_VAR 0 6
52337: NOT
52338: IFFALSE 52342
// continue ;
52340: GO 52190
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52342: LD_ADDR_VAR 0 7
52346: PUSH
52347: LD_EXP 126
52351: PUSH
52352: LD_VAR 0 2
52356: ARRAY
52357: PPUSH
52358: LD_INT 22
52360: PUSH
52361: LD_VAR 0 5
52365: PUSH
52366: EMPTY
52367: LIST
52368: LIST
52369: PUSH
52370: LD_INT 21
52372: PUSH
52373: LD_INT 2
52375: PUSH
52376: EMPTY
52377: LIST
52378: LIST
52379: PUSH
52380: LD_INT 3
52382: PUSH
52383: LD_INT 24
52385: PUSH
52386: LD_INT 1000
52388: PUSH
52389: EMPTY
52390: LIST
52391: LIST
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: LIST
52401: PPUSH
52402: CALL_OW 70
52406: ST_TO_ADDR
// for j in fac do
52407: LD_ADDR_VAR 0 3
52411: PUSH
52412: LD_VAR 0 6
52416: PUSH
52417: FOR_IN
52418: IFFALSE 52499
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52420: LD_ADDR_VAR 0 7
52424: PUSH
52425: LD_VAR 0 7
52429: PUSH
52430: LD_INT 22
52432: PUSH
52433: LD_VAR 0 5
52437: PUSH
52438: EMPTY
52439: LIST
52440: LIST
52441: PUSH
52442: LD_INT 91
52444: PUSH
52445: LD_VAR 0 3
52449: PUSH
52450: LD_INT 15
52452: PUSH
52453: EMPTY
52454: LIST
52455: LIST
52456: LIST
52457: PUSH
52458: LD_INT 21
52460: PUSH
52461: LD_INT 2
52463: PUSH
52464: EMPTY
52465: LIST
52466: LIST
52467: PUSH
52468: LD_INT 3
52470: PUSH
52471: LD_INT 24
52473: PUSH
52474: LD_INT 1000
52476: PUSH
52477: EMPTY
52478: LIST
52479: LIST
52480: PUSH
52481: EMPTY
52482: LIST
52483: LIST
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: LIST
52489: LIST
52490: PPUSH
52491: CALL_OW 69
52495: UNION
52496: ST_TO_ADDR
52497: GO 52417
52499: POP
52500: POP
// if not vehs then
52501: LD_VAR 0 7
52505: NOT
52506: IFFALSE 52532
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52508: LD_ADDR_EXP 114
52512: PUSH
52513: LD_EXP 114
52517: PPUSH
52518: LD_VAR 0 2
52522: PPUSH
52523: EMPTY
52524: PPUSH
52525: CALL_OW 1
52529: ST_TO_ADDR
// continue ;
52530: GO 52190
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52532: LD_ADDR_VAR 0 8
52536: PUSH
52537: LD_EXP 102
52541: PUSH
52542: LD_VAR 0 2
52546: ARRAY
52547: PPUSH
52548: LD_INT 30
52550: PUSH
52551: LD_INT 3
52553: PUSH
52554: EMPTY
52555: LIST
52556: LIST
52557: PPUSH
52558: CALL_OW 72
52562: ST_TO_ADDR
// if tmp then
52563: LD_VAR 0 8
52567: IFFALSE 52670
// begin for j in tmp do
52569: LD_ADDR_VAR 0 3
52573: PUSH
52574: LD_VAR 0 8
52578: PUSH
52579: FOR_IN
52580: IFFALSE 52668
// for k in UnitsInside ( j ) do
52582: LD_ADDR_VAR 0 4
52586: PUSH
52587: LD_VAR 0 3
52591: PPUSH
52592: CALL_OW 313
52596: PUSH
52597: FOR_IN
52598: IFFALSE 52664
// if k then
52600: LD_VAR 0 4
52604: IFFALSE 52662
// if not k in mc_repair_vehicle [ i ] then
52606: LD_VAR 0 4
52610: PUSH
52611: LD_EXP 114
52615: PUSH
52616: LD_VAR 0 2
52620: ARRAY
52621: IN
52622: NOT
52623: IFFALSE 52662
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52625: LD_ADDR_EXP 114
52629: PUSH
52630: LD_EXP 114
52634: PPUSH
52635: LD_VAR 0 2
52639: PPUSH
52640: LD_EXP 114
52644: PUSH
52645: LD_VAR 0 2
52649: ARRAY
52650: PUSH
52651: LD_VAR 0 4
52655: UNION
52656: PPUSH
52657: CALL_OW 1
52661: ST_TO_ADDR
52662: GO 52597
52664: POP
52665: POP
52666: GO 52579
52668: POP
52669: POP
// end ; if not mc_repair_vehicle [ i ] then
52670: LD_EXP 114
52674: PUSH
52675: LD_VAR 0 2
52679: ARRAY
52680: NOT
52681: IFFALSE 52685
// continue ;
52683: GO 52190
// for j in mc_repair_vehicle [ i ] do
52685: LD_ADDR_VAR 0 3
52689: PUSH
52690: LD_EXP 114
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PUSH
52701: FOR_IN
52702: IFFALSE 52868
// begin if GetClass ( j ) <> 3 then
52704: LD_VAR 0 3
52708: PPUSH
52709: CALL_OW 257
52713: PUSH
52714: LD_INT 3
52716: NONEQUAL
52717: IFFALSE 52758
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52719: LD_ADDR_EXP 114
52723: PUSH
52724: LD_EXP 114
52728: PPUSH
52729: LD_VAR 0 2
52733: PPUSH
52734: LD_EXP 114
52738: PUSH
52739: LD_VAR 0 2
52743: ARRAY
52744: PUSH
52745: LD_VAR 0 3
52749: DIFF
52750: PPUSH
52751: CALL_OW 1
52755: ST_TO_ADDR
// continue ;
52756: GO 52701
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52758: LD_VAR 0 3
52762: PPUSH
52763: CALL_OW 311
52767: NOT
52768: PUSH
52769: LD_VAR 0 3
52773: PUSH
52774: LD_EXP 105
52778: PUSH
52779: LD_VAR 0 2
52783: ARRAY
52784: PUSH
52785: LD_INT 1
52787: ARRAY
52788: IN
52789: NOT
52790: AND
52791: PUSH
52792: LD_VAR 0 3
52796: PUSH
52797: LD_EXP 105
52801: PUSH
52802: LD_VAR 0 2
52806: ARRAY
52807: PUSH
52808: LD_INT 2
52810: ARRAY
52811: IN
52812: NOT
52813: AND
52814: IFFALSE 52866
// begin if IsInUnit ( j ) then
52816: LD_VAR 0 3
52820: PPUSH
52821: CALL_OW 310
52825: IFFALSE 52836
// ComExitBuilding ( j ) ;
52827: LD_VAR 0 3
52831: PPUSH
52832: CALL_OW 122
// if not HasTask ( j ) then
52836: LD_VAR 0 3
52840: PPUSH
52841: CALL_OW 314
52845: NOT
52846: IFFALSE 52866
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52848: LD_VAR 0 3
52852: PPUSH
52853: LD_VAR 0 7
52857: PUSH
52858: LD_INT 1
52860: ARRAY
52861: PPUSH
52862: CALL_OW 189
// end ; end ;
52866: GO 52701
52868: POP
52869: POP
// end ;
52870: GO 52190
52872: POP
52873: POP
// end ;
52874: LD_VAR 0 1
52878: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52879: LD_INT 0
52881: PPUSH
52882: PPUSH
52883: PPUSH
52884: PPUSH
52885: PPUSH
52886: PPUSH
52887: PPUSH
52888: PPUSH
52889: PPUSH
52890: PPUSH
52891: PPUSH
// if not mc_bases then
52892: LD_EXP 102
52896: NOT
52897: IFFALSE 52901
// exit ;
52899: GO 53703
// for i = 1 to mc_bases do
52901: LD_ADDR_VAR 0 2
52905: PUSH
52906: DOUBLE
52907: LD_INT 1
52909: DEC
52910: ST_TO_ADDR
52911: LD_EXP 102
52915: PUSH
52916: FOR_TO
52917: IFFALSE 53701
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52919: LD_EXP 130
52923: PUSH
52924: LD_VAR 0 2
52928: ARRAY
52929: NOT
52930: PUSH
52931: LD_EXP 105
52935: PUSH
52936: LD_VAR 0 2
52940: ARRAY
52941: PUSH
52942: LD_INT 1
52944: ARRAY
52945: OR
52946: PUSH
52947: LD_EXP 105
52951: PUSH
52952: LD_VAR 0 2
52956: ARRAY
52957: PUSH
52958: LD_INT 2
52960: ARRAY
52961: OR
52962: PUSH
52963: LD_EXP 128
52967: PUSH
52968: LD_VAR 0 2
52972: ARRAY
52973: PPUSH
52974: LD_INT 1
52976: PPUSH
52977: CALL_OW 325
52981: NOT
52982: OR
52983: PUSH
52984: LD_EXP 125
52988: PUSH
52989: LD_VAR 0 2
52993: ARRAY
52994: OR
52995: IFFALSE 52999
// continue ;
52997: GO 52916
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52999: LD_ADDR_VAR 0 8
53003: PUSH
53004: LD_EXP 102
53008: PUSH
53009: LD_VAR 0 2
53013: ARRAY
53014: PPUSH
53015: LD_INT 25
53017: PUSH
53018: LD_INT 4
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: PUSH
53025: LD_INT 50
53027: PUSH
53028: EMPTY
53029: LIST
53030: PUSH
53031: LD_INT 3
53033: PUSH
53034: LD_INT 60
53036: PUSH
53037: EMPTY
53038: LIST
53039: PUSH
53040: EMPTY
53041: LIST
53042: LIST
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: LIST
53048: PPUSH
53049: CALL_OW 72
53053: PUSH
53054: LD_EXP 106
53058: PUSH
53059: LD_VAR 0 2
53063: ARRAY
53064: DIFF
53065: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53066: LD_ADDR_VAR 0 9
53070: PUSH
53071: LD_EXP 102
53075: PUSH
53076: LD_VAR 0 2
53080: ARRAY
53081: PPUSH
53082: LD_INT 2
53084: PUSH
53085: LD_INT 30
53087: PUSH
53088: LD_INT 0
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: PUSH
53095: LD_INT 30
53097: PUSH
53098: LD_INT 1
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: LIST
53109: PPUSH
53110: CALL_OW 72
53114: ST_TO_ADDR
// if not tmp or not dep then
53115: LD_VAR 0 8
53119: NOT
53120: PUSH
53121: LD_VAR 0 9
53125: NOT
53126: OR
53127: IFFALSE 53131
// continue ;
53129: GO 52916
// side := GetSide ( tmp [ 1 ] ) ;
53131: LD_ADDR_VAR 0 11
53135: PUSH
53136: LD_VAR 0 8
53140: PUSH
53141: LD_INT 1
53143: ARRAY
53144: PPUSH
53145: CALL_OW 255
53149: ST_TO_ADDR
// dep := dep [ 1 ] ;
53150: LD_ADDR_VAR 0 9
53154: PUSH
53155: LD_VAR 0 9
53159: PUSH
53160: LD_INT 1
53162: ARRAY
53163: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53164: LD_ADDR_VAR 0 7
53168: PUSH
53169: LD_EXP 130
53173: PUSH
53174: LD_VAR 0 2
53178: ARRAY
53179: PPUSH
53180: LD_INT 22
53182: PUSH
53183: LD_INT 0
53185: PUSH
53186: EMPTY
53187: LIST
53188: LIST
53189: PUSH
53190: LD_INT 25
53192: PUSH
53193: LD_INT 12
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PUSH
53200: EMPTY
53201: LIST
53202: LIST
53203: PPUSH
53204: CALL_OW 70
53208: PUSH
53209: LD_INT 22
53211: PUSH
53212: LD_INT 0
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: PUSH
53219: LD_INT 25
53221: PUSH
53222: LD_INT 12
53224: PUSH
53225: EMPTY
53226: LIST
53227: LIST
53228: PUSH
53229: LD_INT 91
53231: PUSH
53232: LD_VAR 0 9
53236: PUSH
53237: LD_INT 20
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: LIST
53244: PUSH
53245: EMPTY
53246: LIST
53247: LIST
53248: LIST
53249: PPUSH
53250: CALL_OW 69
53254: UNION
53255: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53256: LD_ADDR_VAR 0 10
53260: PUSH
53261: LD_EXP 130
53265: PUSH
53266: LD_VAR 0 2
53270: ARRAY
53271: PPUSH
53272: LD_INT 81
53274: PUSH
53275: LD_VAR 0 11
53279: PUSH
53280: EMPTY
53281: LIST
53282: LIST
53283: PPUSH
53284: CALL_OW 70
53288: ST_TO_ADDR
// if not apes or danger_at_area then
53289: LD_VAR 0 7
53293: NOT
53294: PUSH
53295: LD_VAR 0 10
53299: OR
53300: IFFALSE 53350
// begin if mc_taming [ i ] then
53302: LD_EXP 133
53306: PUSH
53307: LD_VAR 0 2
53311: ARRAY
53312: IFFALSE 53348
// begin MC_Reset ( i , 121 ) ;
53314: LD_VAR 0 2
53318: PPUSH
53319: LD_INT 121
53321: PPUSH
53322: CALL 38785 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53326: LD_ADDR_EXP 133
53330: PUSH
53331: LD_EXP 133
53335: PPUSH
53336: LD_VAR 0 2
53340: PPUSH
53341: EMPTY
53342: PPUSH
53343: CALL_OW 1
53347: ST_TO_ADDR
// end ; continue ;
53348: GO 52916
// end ; for j in tmp do
53350: LD_ADDR_VAR 0 3
53354: PUSH
53355: LD_VAR 0 8
53359: PUSH
53360: FOR_IN
53361: IFFALSE 53697
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53363: LD_VAR 0 3
53367: PUSH
53368: LD_EXP 133
53372: PUSH
53373: LD_VAR 0 2
53377: ARRAY
53378: IN
53379: NOT
53380: PUSH
53381: LD_EXP 133
53385: PUSH
53386: LD_VAR 0 2
53390: ARRAY
53391: PUSH
53392: LD_INT 3
53394: LESS
53395: AND
53396: IFFALSE 53454
// begin SetTag ( j , 121 ) ;
53398: LD_VAR 0 3
53402: PPUSH
53403: LD_INT 121
53405: PPUSH
53406: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53410: LD_ADDR_EXP 133
53414: PUSH
53415: LD_EXP 133
53419: PPUSH
53420: LD_VAR 0 2
53424: PUSH
53425: LD_EXP 133
53429: PUSH
53430: LD_VAR 0 2
53434: ARRAY
53435: PUSH
53436: LD_INT 1
53438: PLUS
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: PPUSH
53444: LD_VAR 0 3
53448: PPUSH
53449: CALL 71983 0 3
53453: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53454: LD_VAR 0 3
53458: PUSH
53459: LD_EXP 133
53463: PUSH
53464: LD_VAR 0 2
53468: ARRAY
53469: IN
53470: IFFALSE 53695
// begin if GetClass ( j ) <> 4 then
53472: LD_VAR 0 3
53476: PPUSH
53477: CALL_OW 257
53481: PUSH
53482: LD_INT 4
53484: NONEQUAL
53485: IFFALSE 53538
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53487: LD_ADDR_EXP 133
53491: PUSH
53492: LD_EXP 133
53496: PPUSH
53497: LD_VAR 0 2
53501: PPUSH
53502: LD_EXP 133
53506: PUSH
53507: LD_VAR 0 2
53511: ARRAY
53512: PUSH
53513: LD_VAR 0 3
53517: DIFF
53518: PPUSH
53519: CALL_OW 1
53523: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53524: LD_VAR 0 3
53528: PPUSH
53529: LD_INT 0
53531: PPUSH
53532: CALL_OW 109
// continue ;
53536: GO 53360
// end ; if IsInUnit ( j ) then
53538: LD_VAR 0 3
53542: PPUSH
53543: CALL_OW 310
53547: IFFALSE 53558
// ComExitBuilding ( j ) ;
53549: LD_VAR 0 3
53553: PPUSH
53554: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53558: LD_ADDR_VAR 0 6
53562: PUSH
53563: LD_VAR 0 7
53567: PPUSH
53568: LD_VAR 0 3
53572: PPUSH
53573: CALL_OW 74
53577: ST_TO_ADDR
// if not ape then
53578: LD_VAR 0 6
53582: NOT
53583: IFFALSE 53587
// break ;
53585: GO 53697
// x := GetX ( ape ) ;
53587: LD_ADDR_VAR 0 4
53591: PUSH
53592: LD_VAR 0 6
53596: PPUSH
53597: CALL_OW 250
53601: ST_TO_ADDR
// y := GetY ( ape ) ;
53602: LD_ADDR_VAR 0 5
53606: PUSH
53607: LD_VAR 0 6
53611: PPUSH
53612: CALL_OW 251
53616: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53617: LD_VAR 0 4
53621: PPUSH
53622: LD_VAR 0 5
53626: PPUSH
53627: CALL_OW 488
53631: NOT
53632: PUSH
53633: LD_VAR 0 11
53637: PPUSH
53638: LD_VAR 0 4
53642: PPUSH
53643: LD_VAR 0 5
53647: PPUSH
53648: LD_INT 20
53650: PPUSH
53651: CALL 72879 0 4
53655: PUSH
53656: LD_INT 4
53658: ARRAY
53659: OR
53660: IFFALSE 53664
// break ;
53662: GO 53697
// if not HasTask ( j ) then
53664: LD_VAR 0 3
53668: PPUSH
53669: CALL_OW 314
53673: NOT
53674: IFFALSE 53695
// ComTameXY ( j , x , y ) ;
53676: LD_VAR 0 3
53680: PPUSH
53681: LD_VAR 0 4
53685: PPUSH
53686: LD_VAR 0 5
53690: PPUSH
53691: CALL_OW 131
// end ; end ;
53695: GO 53360
53697: POP
53698: POP
// end ;
53699: GO 52916
53701: POP
53702: POP
// end ;
53703: LD_VAR 0 1
53707: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53708: LD_INT 0
53710: PPUSH
53711: PPUSH
53712: PPUSH
53713: PPUSH
53714: PPUSH
53715: PPUSH
53716: PPUSH
53717: PPUSH
// if not mc_bases then
53718: LD_EXP 102
53722: NOT
53723: IFFALSE 53727
// exit ;
53725: GO 54353
// for i = 1 to mc_bases do
53727: LD_ADDR_VAR 0 2
53731: PUSH
53732: DOUBLE
53733: LD_INT 1
53735: DEC
53736: ST_TO_ADDR
53737: LD_EXP 102
53741: PUSH
53742: FOR_TO
53743: IFFALSE 54351
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53745: LD_EXP 131
53749: PUSH
53750: LD_VAR 0 2
53754: ARRAY
53755: NOT
53756: PUSH
53757: LD_EXP 131
53761: PUSH
53762: LD_VAR 0 2
53766: ARRAY
53767: PPUSH
53768: LD_INT 25
53770: PUSH
53771: LD_INT 12
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: PPUSH
53778: CALL_OW 72
53782: NOT
53783: OR
53784: IFFALSE 53788
// continue ;
53786: GO 53742
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53788: LD_ADDR_VAR 0 5
53792: PUSH
53793: LD_EXP 131
53797: PUSH
53798: LD_VAR 0 2
53802: ARRAY
53803: PUSH
53804: LD_INT 1
53806: ARRAY
53807: PPUSH
53808: CALL_OW 255
53812: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53813: LD_VAR 0 5
53817: PPUSH
53818: LD_INT 2
53820: PPUSH
53821: CALL_OW 325
53825: IFFALSE 54078
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53827: LD_ADDR_VAR 0 4
53831: PUSH
53832: LD_EXP 131
53836: PUSH
53837: LD_VAR 0 2
53841: ARRAY
53842: PPUSH
53843: LD_INT 25
53845: PUSH
53846: LD_INT 16
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: PPUSH
53853: CALL_OW 72
53857: ST_TO_ADDR
// if tmp < 6 then
53858: LD_VAR 0 4
53862: PUSH
53863: LD_INT 6
53865: LESS
53866: IFFALSE 54078
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53868: LD_ADDR_VAR 0 6
53872: PUSH
53873: LD_EXP 102
53877: PUSH
53878: LD_VAR 0 2
53882: ARRAY
53883: PPUSH
53884: LD_INT 2
53886: PUSH
53887: LD_INT 30
53889: PUSH
53890: LD_INT 0
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: PUSH
53897: LD_INT 30
53899: PUSH
53900: LD_INT 1
53902: PUSH
53903: EMPTY
53904: LIST
53905: LIST
53906: PUSH
53907: EMPTY
53908: LIST
53909: LIST
53910: LIST
53911: PPUSH
53912: CALL_OW 72
53916: ST_TO_ADDR
// if depot then
53917: LD_VAR 0 6
53921: IFFALSE 54078
// begin selected := 0 ;
53923: LD_ADDR_VAR 0 7
53927: PUSH
53928: LD_INT 0
53930: ST_TO_ADDR
// for j in depot do
53931: LD_ADDR_VAR 0 3
53935: PUSH
53936: LD_VAR 0 6
53940: PUSH
53941: FOR_IN
53942: IFFALSE 53973
// begin if UnitsInside ( j ) < 6 then
53944: LD_VAR 0 3
53948: PPUSH
53949: CALL_OW 313
53953: PUSH
53954: LD_INT 6
53956: LESS
53957: IFFALSE 53971
// begin selected := j ;
53959: LD_ADDR_VAR 0 7
53963: PUSH
53964: LD_VAR 0 3
53968: ST_TO_ADDR
// break ;
53969: GO 53973
// end ; end ;
53971: GO 53941
53973: POP
53974: POP
// if selected then
53975: LD_VAR 0 7
53979: IFFALSE 54078
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53981: LD_ADDR_VAR 0 3
53985: PUSH
53986: LD_EXP 131
53990: PUSH
53991: LD_VAR 0 2
53995: ARRAY
53996: PPUSH
53997: LD_INT 25
53999: PUSH
54000: LD_INT 12
54002: PUSH
54003: EMPTY
54004: LIST
54005: LIST
54006: PPUSH
54007: CALL_OW 72
54011: PUSH
54012: FOR_IN
54013: IFFALSE 54076
// if not HasTask ( j ) then
54015: LD_VAR 0 3
54019: PPUSH
54020: CALL_OW 314
54024: NOT
54025: IFFALSE 54074
// begin if not IsInUnit ( j ) then
54027: LD_VAR 0 3
54031: PPUSH
54032: CALL_OW 310
54036: NOT
54037: IFFALSE 54053
// ComEnterUnit ( j , selected ) ;
54039: LD_VAR 0 3
54043: PPUSH
54044: LD_VAR 0 7
54048: PPUSH
54049: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54053: LD_VAR 0 3
54057: PPUSH
54058: LD_INT 16
54060: PPUSH
54061: CALL_OW 183
// AddComExitBuilding ( j ) ;
54065: LD_VAR 0 3
54069: PPUSH
54070: CALL_OW 182
// end ;
54074: GO 54012
54076: POP
54077: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54078: LD_VAR 0 5
54082: PPUSH
54083: LD_INT 11
54085: PPUSH
54086: CALL_OW 325
54090: IFFALSE 54349
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54092: LD_ADDR_VAR 0 4
54096: PUSH
54097: LD_EXP 131
54101: PUSH
54102: LD_VAR 0 2
54106: ARRAY
54107: PPUSH
54108: LD_INT 25
54110: PUSH
54111: LD_INT 16
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: PPUSH
54118: CALL_OW 72
54122: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54123: LD_VAR 0 4
54127: PUSH
54128: LD_INT 6
54130: GREATEREQUAL
54131: PUSH
54132: LD_VAR 0 5
54136: PPUSH
54137: LD_INT 2
54139: PPUSH
54140: CALL_OW 325
54144: NOT
54145: OR
54146: IFFALSE 54349
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54148: LD_ADDR_VAR 0 8
54152: PUSH
54153: LD_EXP 102
54157: PUSH
54158: LD_VAR 0 2
54162: ARRAY
54163: PPUSH
54164: LD_INT 2
54166: PUSH
54167: LD_INT 30
54169: PUSH
54170: LD_INT 4
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: PUSH
54177: LD_INT 30
54179: PUSH
54180: LD_INT 5
54182: PUSH
54183: EMPTY
54184: LIST
54185: LIST
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: LIST
54191: PPUSH
54192: CALL_OW 72
54196: ST_TO_ADDR
// if barracks then
54197: LD_VAR 0 8
54201: IFFALSE 54349
// begin selected := 0 ;
54203: LD_ADDR_VAR 0 7
54207: PUSH
54208: LD_INT 0
54210: ST_TO_ADDR
// for j in barracks do
54211: LD_ADDR_VAR 0 3
54215: PUSH
54216: LD_VAR 0 8
54220: PUSH
54221: FOR_IN
54222: IFFALSE 54253
// begin if UnitsInside ( j ) < 6 then
54224: LD_VAR 0 3
54228: PPUSH
54229: CALL_OW 313
54233: PUSH
54234: LD_INT 6
54236: LESS
54237: IFFALSE 54251
// begin selected := j ;
54239: LD_ADDR_VAR 0 7
54243: PUSH
54244: LD_VAR 0 3
54248: ST_TO_ADDR
// break ;
54249: GO 54253
// end ; end ;
54251: GO 54221
54253: POP
54254: POP
// if selected then
54255: LD_VAR 0 7
54259: IFFALSE 54349
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54261: LD_ADDR_VAR 0 3
54265: PUSH
54266: LD_EXP 131
54270: PUSH
54271: LD_VAR 0 2
54275: ARRAY
54276: PPUSH
54277: LD_INT 25
54279: PUSH
54280: LD_INT 12
54282: PUSH
54283: EMPTY
54284: LIST
54285: LIST
54286: PPUSH
54287: CALL_OW 72
54291: PUSH
54292: FOR_IN
54293: IFFALSE 54347
// if not IsInUnit ( j ) and not HasTask ( j ) then
54295: LD_VAR 0 3
54299: PPUSH
54300: CALL_OW 310
54304: NOT
54305: PUSH
54306: LD_VAR 0 3
54310: PPUSH
54311: CALL_OW 314
54315: NOT
54316: AND
54317: IFFALSE 54345
// begin ComEnterUnit ( j , selected ) ;
54319: LD_VAR 0 3
54323: PPUSH
54324: LD_VAR 0 7
54328: PPUSH
54329: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54333: LD_VAR 0 3
54337: PPUSH
54338: LD_INT 15
54340: PPUSH
54341: CALL_OW 183
// end ;
54345: GO 54292
54347: POP
54348: POP
// end ; end ; end ; end ; end ;
54349: GO 53742
54351: POP
54352: POP
// end ;
54353: LD_VAR 0 1
54357: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54358: LD_INT 0
54360: PPUSH
54361: PPUSH
54362: PPUSH
54363: PPUSH
// if not mc_bases then
54364: LD_EXP 102
54368: NOT
54369: IFFALSE 54373
// exit ;
54371: GO 54551
// for i = 1 to mc_bases do
54373: LD_ADDR_VAR 0 2
54377: PUSH
54378: DOUBLE
54379: LD_INT 1
54381: DEC
54382: ST_TO_ADDR
54383: LD_EXP 102
54387: PUSH
54388: FOR_TO
54389: IFFALSE 54549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54391: LD_ADDR_VAR 0 4
54395: PUSH
54396: LD_EXP 102
54400: PUSH
54401: LD_VAR 0 2
54405: ARRAY
54406: PPUSH
54407: LD_INT 25
54409: PUSH
54410: LD_INT 9
54412: PUSH
54413: EMPTY
54414: LIST
54415: LIST
54416: PPUSH
54417: CALL_OW 72
54421: ST_TO_ADDR
// if not tmp then
54422: LD_VAR 0 4
54426: NOT
54427: IFFALSE 54431
// continue ;
54429: GO 54388
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54431: LD_EXP 128
54435: PUSH
54436: LD_VAR 0 2
54440: ARRAY
54441: PPUSH
54442: LD_INT 29
54444: PPUSH
54445: CALL_OW 325
54449: NOT
54450: PUSH
54451: LD_EXP 128
54455: PUSH
54456: LD_VAR 0 2
54460: ARRAY
54461: PPUSH
54462: LD_INT 28
54464: PPUSH
54465: CALL_OW 325
54469: NOT
54470: AND
54471: IFFALSE 54475
// continue ;
54473: GO 54388
// for j in tmp do
54475: LD_ADDR_VAR 0 3
54479: PUSH
54480: LD_VAR 0 4
54484: PUSH
54485: FOR_IN
54486: IFFALSE 54545
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54488: LD_VAR 0 3
54492: PUSH
54493: LD_EXP 105
54497: PUSH
54498: LD_VAR 0 2
54502: ARRAY
54503: PUSH
54504: LD_INT 1
54506: ARRAY
54507: IN
54508: NOT
54509: PUSH
54510: LD_VAR 0 3
54514: PUSH
54515: LD_EXP 105
54519: PUSH
54520: LD_VAR 0 2
54524: ARRAY
54525: PUSH
54526: LD_INT 2
54528: ARRAY
54529: IN
54530: NOT
54531: AND
54532: IFFALSE 54543
// ComSpaceTimeShoot ( j ) ;
54534: LD_VAR 0 3
54538: PPUSH
54539: CALL 65569 0 1
54543: GO 54485
54545: POP
54546: POP
// end ;
54547: GO 54388
54549: POP
54550: POP
// end ;
54551: LD_VAR 0 1
54555: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54556: LD_INT 0
54558: PPUSH
54559: PPUSH
54560: PPUSH
54561: PPUSH
54562: PPUSH
54563: PPUSH
54564: PPUSH
54565: PPUSH
54566: PPUSH
// if not mc_bases then
54567: LD_EXP 102
54571: NOT
54572: IFFALSE 54576
// exit ;
54574: GO 55198
// for i = 1 to mc_bases do
54576: LD_ADDR_VAR 0 2
54580: PUSH
54581: DOUBLE
54582: LD_INT 1
54584: DEC
54585: ST_TO_ADDR
54586: LD_EXP 102
54590: PUSH
54591: FOR_TO
54592: IFFALSE 55196
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54594: LD_EXP 137
54598: PUSH
54599: LD_VAR 0 2
54603: ARRAY
54604: NOT
54605: PUSH
54606: LD_INT 38
54608: PPUSH
54609: LD_EXP 128
54613: PUSH
54614: LD_VAR 0 2
54618: ARRAY
54619: PPUSH
54620: CALL_OW 321
54624: PUSH
54625: LD_INT 2
54627: NONEQUAL
54628: OR
54629: IFFALSE 54633
// continue ;
54631: GO 54591
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54633: LD_ADDR_VAR 0 8
54637: PUSH
54638: LD_EXP 102
54642: PUSH
54643: LD_VAR 0 2
54647: ARRAY
54648: PPUSH
54649: LD_INT 30
54651: PUSH
54652: LD_INT 34
54654: PUSH
54655: EMPTY
54656: LIST
54657: LIST
54658: PPUSH
54659: CALL_OW 72
54663: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54664: LD_ADDR_VAR 0 9
54668: PUSH
54669: LD_EXP 102
54673: PUSH
54674: LD_VAR 0 2
54678: ARRAY
54679: PPUSH
54680: LD_INT 25
54682: PUSH
54683: LD_INT 4
54685: PUSH
54686: EMPTY
54687: LIST
54688: LIST
54689: PPUSH
54690: CALL_OW 72
54694: PPUSH
54695: LD_INT 0
54697: PPUSH
54698: CALL 105246 0 2
54702: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54703: LD_VAR 0 9
54707: NOT
54708: PUSH
54709: LD_VAR 0 8
54713: NOT
54714: OR
54715: PUSH
54716: LD_EXP 102
54720: PUSH
54721: LD_VAR 0 2
54725: ARRAY
54726: PPUSH
54727: LD_INT 124
54729: PPUSH
54730: CALL 105246 0 2
54734: OR
54735: IFFALSE 54739
// continue ;
54737: GO 54591
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54739: LD_EXP 138
54743: PUSH
54744: LD_VAR 0 2
54748: ARRAY
54749: PUSH
54750: LD_EXP 137
54754: PUSH
54755: LD_VAR 0 2
54759: ARRAY
54760: LESS
54761: PUSH
54762: LD_EXP 138
54766: PUSH
54767: LD_VAR 0 2
54771: ARRAY
54772: PUSH
54773: LD_VAR 0 8
54777: LESS
54778: AND
54779: IFFALSE 55194
// begin tmp := sci [ 1 ] ;
54781: LD_ADDR_VAR 0 7
54785: PUSH
54786: LD_VAR 0 9
54790: PUSH
54791: LD_INT 1
54793: ARRAY
54794: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54795: LD_VAR 0 7
54799: PPUSH
54800: LD_INT 124
54802: PPUSH
54803: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54807: LD_ADDR_VAR 0 3
54811: PUSH
54812: DOUBLE
54813: LD_EXP 137
54817: PUSH
54818: LD_VAR 0 2
54822: ARRAY
54823: INC
54824: ST_TO_ADDR
54825: LD_EXP 137
54829: PUSH
54830: LD_VAR 0 2
54834: ARRAY
54835: PUSH
54836: FOR_DOWNTO
54837: IFFALSE 55180
// begin if IsInUnit ( tmp ) then
54839: LD_VAR 0 7
54843: PPUSH
54844: CALL_OW 310
54848: IFFALSE 54859
// ComExitBuilding ( tmp ) ;
54850: LD_VAR 0 7
54854: PPUSH
54855: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54859: LD_INT 35
54861: PPUSH
54862: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54866: LD_VAR 0 7
54870: PPUSH
54871: CALL_OW 310
54875: NOT
54876: PUSH
54877: LD_VAR 0 7
54881: PPUSH
54882: CALL_OW 314
54886: NOT
54887: AND
54888: IFFALSE 54859
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54890: LD_ADDR_VAR 0 6
54894: PUSH
54895: LD_VAR 0 7
54899: PPUSH
54900: CALL_OW 250
54904: PUSH
54905: LD_VAR 0 7
54909: PPUSH
54910: CALL_OW 251
54914: PUSH
54915: EMPTY
54916: LIST
54917: LIST
54918: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54919: LD_INT 35
54921: PPUSH
54922: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54926: LD_ADDR_VAR 0 4
54930: PUSH
54931: LD_EXP 137
54935: PUSH
54936: LD_VAR 0 2
54940: ARRAY
54941: PUSH
54942: LD_VAR 0 3
54946: ARRAY
54947: PUSH
54948: LD_INT 1
54950: ARRAY
54951: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54952: LD_ADDR_VAR 0 5
54956: PUSH
54957: LD_EXP 137
54961: PUSH
54962: LD_VAR 0 2
54966: ARRAY
54967: PUSH
54968: LD_VAR 0 3
54972: ARRAY
54973: PUSH
54974: LD_INT 2
54976: ARRAY
54977: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54978: LD_VAR 0 7
54982: PPUSH
54983: LD_INT 10
54985: PPUSH
54986: CALL 74576 0 2
54990: PUSH
54991: LD_INT 4
54993: ARRAY
54994: IFFALSE 55032
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54996: LD_VAR 0 7
55000: PPUSH
55001: LD_VAR 0 6
55005: PUSH
55006: LD_INT 1
55008: ARRAY
55009: PPUSH
55010: LD_VAR 0 6
55014: PUSH
55015: LD_INT 2
55017: ARRAY
55018: PPUSH
55019: CALL_OW 111
// wait ( 0 0$10 ) ;
55023: LD_INT 350
55025: PPUSH
55026: CALL_OW 67
// end else
55030: GO 55058
// begin ComMoveXY ( tmp , x , y ) ;
55032: LD_VAR 0 7
55036: PPUSH
55037: LD_VAR 0 4
55041: PPUSH
55042: LD_VAR 0 5
55046: PPUSH
55047: CALL_OW 111
// wait ( 0 0$3 ) ;
55051: LD_INT 105
55053: PPUSH
55054: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55058: LD_VAR 0 7
55062: PPUSH
55063: LD_VAR 0 4
55067: PPUSH
55068: LD_VAR 0 5
55072: PPUSH
55073: CALL_OW 307
55077: IFFALSE 54919
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55079: LD_VAR 0 7
55083: PPUSH
55084: LD_VAR 0 4
55088: PPUSH
55089: LD_VAR 0 5
55093: PPUSH
55094: LD_VAR 0 8
55098: PUSH
55099: LD_VAR 0 3
55103: ARRAY
55104: PPUSH
55105: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55109: LD_INT 35
55111: PPUSH
55112: CALL_OW 67
// until not HasTask ( tmp ) ;
55116: LD_VAR 0 7
55120: PPUSH
55121: CALL_OW 314
55125: NOT
55126: IFFALSE 55109
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55128: LD_ADDR_EXP 138
55132: PUSH
55133: LD_EXP 138
55137: PPUSH
55138: LD_VAR 0 2
55142: PUSH
55143: LD_EXP 138
55147: PUSH
55148: LD_VAR 0 2
55152: ARRAY
55153: PUSH
55154: LD_INT 1
55156: PLUS
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: PPUSH
55162: LD_VAR 0 8
55166: PUSH
55167: LD_VAR 0 3
55171: ARRAY
55172: PPUSH
55173: CALL 71983 0 3
55177: ST_TO_ADDR
// end ;
55178: GO 54836
55180: POP
55181: POP
// MC_Reset ( i , 124 ) ;
55182: LD_VAR 0 2
55186: PPUSH
55187: LD_INT 124
55189: PPUSH
55190: CALL 38785 0 2
// end ; end ;
55194: GO 54591
55196: POP
55197: POP
// end ;
55198: LD_VAR 0 1
55202: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55203: LD_INT 0
55205: PPUSH
55206: PPUSH
55207: PPUSH
// if not mc_bases then
55208: LD_EXP 102
55212: NOT
55213: IFFALSE 55217
// exit ;
55215: GO 55823
// for i = 1 to mc_bases do
55217: LD_ADDR_VAR 0 2
55221: PUSH
55222: DOUBLE
55223: LD_INT 1
55225: DEC
55226: ST_TO_ADDR
55227: LD_EXP 102
55231: PUSH
55232: FOR_TO
55233: IFFALSE 55821
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_EXP 102
55244: PUSH
55245: LD_VAR 0 2
55249: ARRAY
55250: PPUSH
55251: LD_INT 25
55253: PUSH
55254: LD_INT 4
55256: PUSH
55257: EMPTY
55258: LIST
55259: LIST
55260: PPUSH
55261: CALL_OW 72
55265: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55266: LD_VAR 0 3
55270: NOT
55271: PUSH
55272: LD_EXP 139
55276: PUSH
55277: LD_VAR 0 2
55281: ARRAY
55282: NOT
55283: OR
55284: PUSH
55285: LD_EXP 102
55289: PUSH
55290: LD_VAR 0 2
55294: ARRAY
55295: PPUSH
55296: LD_INT 2
55298: PUSH
55299: LD_INT 30
55301: PUSH
55302: LD_INT 0
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: PUSH
55309: LD_INT 30
55311: PUSH
55312: LD_INT 1
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: PUSH
55319: EMPTY
55320: LIST
55321: LIST
55322: LIST
55323: PPUSH
55324: CALL_OW 72
55328: NOT
55329: OR
55330: IFFALSE 55380
// begin if mc_deposits_finder [ i ] then
55332: LD_EXP 140
55336: PUSH
55337: LD_VAR 0 2
55341: ARRAY
55342: IFFALSE 55378
// begin MC_Reset ( i , 125 ) ;
55344: LD_VAR 0 2
55348: PPUSH
55349: LD_INT 125
55351: PPUSH
55352: CALL 38785 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55356: LD_ADDR_EXP 140
55360: PUSH
55361: LD_EXP 140
55365: PPUSH
55366: LD_VAR 0 2
55370: PPUSH
55371: EMPTY
55372: PPUSH
55373: CALL_OW 1
55377: ST_TO_ADDR
// end ; continue ;
55378: GO 55232
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55380: LD_EXP 139
55384: PUSH
55385: LD_VAR 0 2
55389: ARRAY
55390: PUSH
55391: LD_INT 1
55393: ARRAY
55394: PUSH
55395: LD_INT 3
55397: ARRAY
55398: PUSH
55399: LD_INT 1
55401: EQUAL
55402: PUSH
55403: LD_INT 20
55405: PPUSH
55406: LD_EXP 128
55410: PUSH
55411: LD_VAR 0 2
55415: ARRAY
55416: PPUSH
55417: CALL_OW 321
55421: PUSH
55422: LD_INT 2
55424: NONEQUAL
55425: AND
55426: IFFALSE 55476
// begin if mc_deposits_finder [ i ] then
55428: LD_EXP 140
55432: PUSH
55433: LD_VAR 0 2
55437: ARRAY
55438: IFFALSE 55474
// begin MC_Reset ( i , 125 ) ;
55440: LD_VAR 0 2
55444: PPUSH
55445: LD_INT 125
55447: PPUSH
55448: CALL 38785 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55452: LD_ADDR_EXP 140
55456: PUSH
55457: LD_EXP 140
55461: PPUSH
55462: LD_VAR 0 2
55466: PPUSH
55467: EMPTY
55468: PPUSH
55469: CALL_OW 1
55473: ST_TO_ADDR
// end ; continue ;
55474: GO 55232
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55476: LD_EXP 139
55480: PUSH
55481: LD_VAR 0 2
55485: ARRAY
55486: PUSH
55487: LD_INT 1
55489: ARRAY
55490: PUSH
55491: LD_INT 1
55493: ARRAY
55494: PPUSH
55495: LD_EXP 139
55499: PUSH
55500: LD_VAR 0 2
55504: ARRAY
55505: PUSH
55506: LD_INT 1
55508: ARRAY
55509: PUSH
55510: LD_INT 2
55512: ARRAY
55513: PPUSH
55514: LD_EXP 128
55518: PUSH
55519: LD_VAR 0 2
55523: ARRAY
55524: PPUSH
55525: CALL_OW 440
55529: IFFALSE 55572
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55531: LD_ADDR_EXP 139
55535: PUSH
55536: LD_EXP 139
55540: PPUSH
55541: LD_VAR 0 2
55545: PPUSH
55546: LD_EXP 139
55550: PUSH
55551: LD_VAR 0 2
55555: ARRAY
55556: PPUSH
55557: LD_INT 1
55559: PPUSH
55560: CALL_OW 3
55564: PPUSH
55565: CALL_OW 1
55569: ST_TO_ADDR
55570: GO 55819
// begin if not mc_deposits_finder [ i ] then
55572: LD_EXP 140
55576: PUSH
55577: LD_VAR 0 2
55581: ARRAY
55582: NOT
55583: IFFALSE 55635
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55585: LD_ADDR_EXP 140
55589: PUSH
55590: LD_EXP 140
55594: PPUSH
55595: LD_VAR 0 2
55599: PPUSH
55600: LD_VAR 0 3
55604: PUSH
55605: LD_INT 1
55607: ARRAY
55608: PUSH
55609: EMPTY
55610: LIST
55611: PPUSH
55612: CALL_OW 1
55616: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55617: LD_VAR 0 3
55621: PUSH
55622: LD_INT 1
55624: ARRAY
55625: PPUSH
55626: LD_INT 125
55628: PPUSH
55629: CALL_OW 109
// end else
55633: GO 55819
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55635: LD_EXP 140
55639: PUSH
55640: LD_VAR 0 2
55644: ARRAY
55645: PUSH
55646: LD_INT 1
55648: ARRAY
55649: PPUSH
55650: CALL_OW 310
55654: IFFALSE 55677
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55656: LD_EXP 140
55660: PUSH
55661: LD_VAR 0 2
55665: ARRAY
55666: PUSH
55667: LD_INT 1
55669: ARRAY
55670: PPUSH
55671: CALL_OW 122
55675: GO 55819
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55677: LD_EXP 140
55681: PUSH
55682: LD_VAR 0 2
55686: ARRAY
55687: PUSH
55688: LD_INT 1
55690: ARRAY
55691: PPUSH
55692: CALL_OW 314
55696: NOT
55697: PUSH
55698: LD_EXP 140
55702: PUSH
55703: LD_VAR 0 2
55707: ARRAY
55708: PUSH
55709: LD_INT 1
55711: ARRAY
55712: PPUSH
55713: LD_EXP 139
55717: PUSH
55718: LD_VAR 0 2
55722: ARRAY
55723: PUSH
55724: LD_INT 1
55726: ARRAY
55727: PUSH
55728: LD_INT 1
55730: ARRAY
55731: PPUSH
55732: LD_EXP 139
55736: PUSH
55737: LD_VAR 0 2
55741: ARRAY
55742: PUSH
55743: LD_INT 1
55745: ARRAY
55746: PUSH
55747: LD_INT 2
55749: ARRAY
55750: PPUSH
55751: CALL_OW 297
55755: PUSH
55756: LD_INT 6
55758: GREATER
55759: AND
55760: IFFALSE 55819
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55762: LD_EXP 140
55766: PUSH
55767: LD_VAR 0 2
55771: ARRAY
55772: PUSH
55773: LD_INT 1
55775: ARRAY
55776: PPUSH
55777: LD_EXP 139
55781: PUSH
55782: LD_VAR 0 2
55786: ARRAY
55787: PUSH
55788: LD_INT 1
55790: ARRAY
55791: PUSH
55792: LD_INT 1
55794: ARRAY
55795: PPUSH
55796: LD_EXP 139
55800: PUSH
55801: LD_VAR 0 2
55805: ARRAY
55806: PUSH
55807: LD_INT 1
55809: ARRAY
55810: PUSH
55811: LD_INT 2
55813: ARRAY
55814: PPUSH
55815: CALL_OW 111
// end ; end ; end ;
55819: GO 55232
55821: POP
55822: POP
// end ;
55823: LD_VAR 0 1
55827: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55828: LD_INT 0
55830: PPUSH
55831: PPUSH
55832: PPUSH
55833: PPUSH
55834: PPUSH
55835: PPUSH
55836: PPUSH
55837: PPUSH
55838: PPUSH
55839: PPUSH
55840: PPUSH
// if not mc_bases then
55841: LD_EXP 102
55845: NOT
55846: IFFALSE 55850
// exit ;
55848: GO 56790
// for i = 1 to mc_bases do
55850: LD_ADDR_VAR 0 2
55854: PUSH
55855: DOUBLE
55856: LD_INT 1
55858: DEC
55859: ST_TO_ADDR
55860: LD_EXP 102
55864: PUSH
55865: FOR_TO
55866: IFFALSE 56788
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55868: LD_EXP 102
55872: PUSH
55873: LD_VAR 0 2
55877: ARRAY
55878: NOT
55879: PUSH
55880: LD_EXP 125
55884: PUSH
55885: LD_VAR 0 2
55889: ARRAY
55890: OR
55891: IFFALSE 55895
// continue ;
55893: GO 55865
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55895: LD_ADDR_VAR 0 7
55899: PUSH
55900: LD_EXP 102
55904: PUSH
55905: LD_VAR 0 2
55909: ARRAY
55910: PUSH
55911: LD_INT 1
55913: ARRAY
55914: PPUSH
55915: CALL_OW 248
55919: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55920: LD_VAR 0 7
55924: PUSH
55925: LD_INT 3
55927: EQUAL
55928: PUSH
55929: LD_EXP 121
55933: PUSH
55934: LD_VAR 0 2
55938: ARRAY
55939: PUSH
55940: LD_EXP 124
55944: PUSH
55945: LD_VAR 0 2
55949: ARRAY
55950: UNION
55951: PPUSH
55952: LD_INT 33
55954: PUSH
55955: LD_INT 2
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: PPUSH
55962: CALL_OW 72
55966: NOT
55967: OR
55968: IFFALSE 55972
// continue ;
55970: GO 55865
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55972: LD_ADDR_VAR 0 9
55976: PUSH
55977: LD_EXP 102
55981: PUSH
55982: LD_VAR 0 2
55986: ARRAY
55987: PPUSH
55988: LD_INT 30
55990: PUSH
55991: LD_INT 36
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: PPUSH
55998: CALL_OW 72
56002: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56003: LD_ADDR_VAR 0 10
56007: PUSH
56008: LD_EXP 121
56012: PUSH
56013: LD_VAR 0 2
56017: ARRAY
56018: PPUSH
56019: LD_INT 34
56021: PUSH
56022: LD_INT 31
56024: PUSH
56025: EMPTY
56026: LIST
56027: LIST
56028: PPUSH
56029: CALL_OW 72
56033: ST_TO_ADDR
// if not cts and not mcts then
56034: LD_VAR 0 9
56038: NOT
56039: PUSH
56040: LD_VAR 0 10
56044: NOT
56045: AND
56046: IFFALSE 56050
// continue ;
56048: GO 55865
// x := cts ;
56050: LD_ADDR_VAR 0 11
56054: PUSH
56055: LD_VAR 0 9
56059: ST_TO_ADDR
// if not x then
56060: LD_VAR 0 11
56064: NOT
56065: IFFALSE 56077
// x := mcts ;
56067: LD_ADDR_VAR 0 11
56071: PUSH
56072: LD_VAR 0 10
56076: ST_TO_ADDR
// if not x then
56077: LD_VAR 0 11
56081: NOT
56082: IFFALSE 56086
// continue ;
56084: GO 55865
// if mc_remote_driver [ i ] then
56086: LD_EXP 142
56090: PUSH
56091: LD_VAR 0 2
56095: ARRAY
56096: IFFALSE 56483
// for j in mc_remote_driver [ i ] do
56098: LD_ADDR_VAR 0 3
56102: PUSH
56103: LD_EXP 142
56107: PUSH
56108: LD_VAR 0 2
56112: ARRAY
56113: PUSH
56114: FOR_IN
56115: IFFALSE 56481
// begin if GetClass ( j ) <> 3 then
56117: LD_VAR 0 3
56121: PPUSH
56122: CALL_OW 257
56126: PUSH
56127: LD_INT 3
56129: NONEQUAL
56130: IFFALSE 56183
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56132: LD_ADDR_EXP 142
56136: PUSH
56137: LD_EXP 142
56141: PPUSH
56142: LD_VAR 0 2
56146: PPUSH
56147: LD_EXP 142
56151: PUSH
56152: LD_VAR 0 2
56156: ARRAY
56157: PUSH
56158: LD_VAR 0 3
56162: DIFF
56163: PPUSH
56164: CALL_OW 1
56168: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56169: LD_VAR 0 3
56173: PPUSH
56174: LD_INT 0
56176: PPUSH
56177: CALL_OW 109
// continue ;
56181: GO 56114
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56183: LD_EXP 121
56187: PUSH
56188: LD_VAR 0 2
56192: ARRAY
56193: PPUSH
56194: LD_INT 34
56196: PUSH
56197: LD_INT 31
56199: PUSH
56200: EMPTY
56201: LIST
56202: LIST
56203: PUSH
56204: LD_INT 58
56206: PUSH
56207: EMPTY
56208: LIST
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PPUSH
56214: CALL_OW 72
56218: PUSH
56219: LD_VAR 0 3
56223: PPUSH
56224: CALL 105334 0 1
56228: NOT
56229: AND
56230: IFFALSE 56301
// begin if IsInUnit ( j ) then
56232: LD_VAR 0 3
56236: PPUSH
56237: CALL_OW 310
56241: IFFALSE 56252
// ComExitBuilding ( j ) ;
56243: LD_VAR 0 3
56247: PPUSH
56248: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56252: LD_VAR 0 3
56256: PPUSH
56257: LD_EXP 121
56261: PUSH
56262: LD_VAR 0 2
56266: ARRAY
56267: PPUSH
56268: LD_INT 34
56270: PUSH
56271: LD_INT 31
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: PUSH
56278: LD_INT 58
56280: PUSH
56281: EMPTY
56282: LIST
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: PPUSH
56288: CALL_OW 72
56292: PUSH
56293: LD_INT 1
56295: ARRAY
56296: PPUSH
56297: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56301: LD_VAR 0 3
56305: PPUSH
56306: CALL_OW 310
56310: NOT
56311: PUSH
56312: LD_VAR 0 3
56316: PPUSH
56317: CALL_OW 310
56321: PPUSH
56322: CALL_OW 266
56326: PUSH
56327: LD_INT 36
56329: NONEQUAL
56330: PUSH
56331: LD_VAR 0 3
56335: PPUSH
56336: CALL 105334 0 1
56340: NOT
56341: AND
56342: OR
56343: IFFALSE 56479
// begin if IsInUnit ( j ) then
56345: LD_VAR 0 3
56349: PPUSH
56350: CALL_OW 310
56354: IFFALSE 56365
// ComExitBuilding ( j ) ;
56356: LD_VAR 0 3
56360: PPUSH
56361: CALL_OW 122
// ct := 0 ;
56365: LD_ADDR_VAR 0 8
56369: PUSH
56370: LD_INT 0
56372: ST_TO_ADDR
// for k in x do
56373: LD_ADDR_VAR 0 4
56377: PUSH
56378: LD_VAR 0 11
56382: PUSH
56383: FOR_IN
56384: IFFALSE 56457
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56386: LD_VAR 0 4
56390: PPUSH
56391: CALL_OW 264
56395: PUSH
56396: LD_INT 31
56398: EQUAL
56399: PUSH
56400: LD_VAR 0 4
56404: PPUSH
56405: CALL_OW 311
56409: NOT
56410: AND
56411: PUSH
56412: LD_VAR 0 4
56416: PPUSH
56417: CALL_OW 266
56421: PUSH
56422: LD_INT 36
56424: EQUAL
56425: PUSH
56426: LD_VAR 0 4
56430: PPUSH
56431: CALL_OW 313
56435: PUSH
56436: LD_INT 3
56438: LESS
56439: AND
56440: OR
56441: IFFALSE 56455
// begin ct := k ;
56443: LD_ADDR_VAR 0 8
56447: PUSH
56448: LD_VAR 0 4
56452: ST_TO_ADDR
// break ;
56453: GO 56457
// end ;
56455: GO 56383
56457: POP
56458: POP
// if ct then
56459: LD_VAR 0 8
56463: IFFALSE 56479
// ComEnterUnit ( j , ct ) ;
56465: LD_VAR 0 3
56469: PPUSH
56470: LD_VAR 0 8
56474: PPUSH
56475: CALL_OW 120
// end ; end ;
56479: GO 56114
56481: POP
56482: POP
// places := 0 ;
56483: LD_ADDR_VAR 0 5
56487: PUSH
56488: LD_INT 0
56490: ST_TO_ADDR
// for j = 1 to x do
56491: LD_ADDR_VAR 0 3
56495: PUSH
56496: DOUBLE
56497: LD_INT 1
56499: DEC
56500: ST_TO_ADDR
56501: LD_VAR 0 11
56505: PUSH
56506: FOR_TO
56507: IFFALSE 56583
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56509: LD_VAR 0 11
56513: PUSH
56514: LD_VAR 0 3
56518: ARRAY
56519: PPUSH
56520: CALL_OW 264
56524: PUSH
56525: LD_INT 31
56527: EQUAL
56528: IFFALSE 56546
// places := places + 1 else
56530: LD_ADDR_VAR 0 5
56534: PUSH
56535: LD_VAR 0 5
56539: PUSH
56540: LD_INT 1
56542: PLUS
56543: ST_TO_ADDR
56544: GO 56581
// if GetBType ( x [ j ] ) = b_control_tower then
56546: LD_VAR 0 11
56550: PUSH
56551: LD_VAR 0 3
56555: ARRAY
56556: PPUSH
56557: CALL_OW 266
56561: PUSH
56562: LD_INT 36
56564: EQUAL
56565: IFFALSE 56581
// places := places + 3 ;
56567: LD_ADDR_VAR 0 5
56571: PUSH
56572: LD_VAR 0 5
56576: PUSH
56577: LD_INT 3
56579: PLUS
56580: ST_TO_ADDR
56581: GO 56506
56583: POP
56584: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56585: LD_VAR 0 5
56589: PUSH
56590: LD_INT 0
56592: EQUAL
56593: PUSH
56594: LD_VAR 0 5
56598: PUSH
56599: LD_EXP 142
56603: PUSH
56604: LD_VAR 0 2
56608: ARRAY
56609: LESSEQUAL
56610: OR
56611: IFFALSE 56615
// continue ;
56613: GO 55865
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56615: LD_ADDR_VAR 0 6
56619: PUSH
56620: LD_EXP 102
56624: PUSH
56625: LD_VAR 0 2
56629: ARRAY
56630: PPUSH
56631: LD_INT 25
56633: PUSH
56634: LD_INT 3
56636: PUSH
56637: EMPTY
56638: LIST
56639: LIST
56640: PPUSH
56641: CALL_OW 72
56645: PUSH
56646: LD_EXP 142
56650: PUSH
56651: LD_VAR 0 2
56655: ARRAY
56656: DIFF
56657: PPUSH
56658: LD_INT 3
56660: PPUSH
56661: CALL 106234 0 2
56665: ST_TO_ADDR
// for j in tmp do
56666: LD_ADDR_VAR 0 3
56670: PUSH
56671: LD_VAR 0 6
56675: PUSH
56676: FOR_IN
56677: IFFALSE 56712
// if GetTag ( j ) > 0 then
56679: LD_VAR 0 3
56683: PPUSH
56684: CALL_OW 110
56688: PUSH
56689: LD_INT 0
56691: GREATER
56692: IFFALSE 56710
// tmp := tmp diff j ;
56694: LD_ADDR_VAR 0 6
56698: PUSH
56699: LD_VAR 0 6
56703: PUSH
56704: LD_VAR 0 3
56708: DIFF
56709: ST_TO_ADDR
56710: GO 56676
56712: POP
56713: POP
// if not tmp then
56714: LD_VAR 0 6
56718: NOT
56719: IFFALSE 56723
// continue ;
56721: GO 55865
// if places then
56723: LD_VAR 0 5
56727: IFFALSE 56786
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56729: LD_ADDR_EXP 142
56733: PUSH
56734: LD_EXP 142
56738: PPUSH
56739: LD_VAR 0 2
56743: PPUSH
56744: LD_EXP 142
56748: PUSH
56749: LD_VAR 0 2
56753: ARRAY
56754: PUSH
56755: LD_VAR 0 6
56759: PUSH
56760: LD_INT 1
56762: ARRAY
56763: UNION
56764: PPUSH
56765: CALL_OW 1
56769: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56770: LD_VAR 0 6
56774: PUSH
56775: LD_INT 1
56777: ARRAY
56778: PPUSH
56779: LD_INT 126
56781: PPUSH
56782: CALL_OW 109
// end ; end ;
56786: GO 55865
56788: POP
56789: POP
// end ;
56790: LD_VAR 0 1
56794: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56795: LD_INT 0
56797: PPUSH
56798: PPUSH
56799: PPUSH
56800: PPUSH
56801: PPUSH
56802: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56803: LD_VAR 0 1
56807: NOT
56808: PUSH
56809: LD_VAR 0 2
56813: NOT
56814: OR
56815: PUSH
56816: LD_VAR 0 3
56820: NOT
56821: OR
56822: PUSH
56823: LD_VAR 0 4
56827: PUSH
56828: LD_INT 1
56830: PUSH
56831: LD_INT 2
56833: PUSH
56834: LD_INT 3
56836: PUSH
56837: LD_INT 4
56839: PUSH
56840: LD_INT 5
56842: PUSH
56843: LD_INT 8
56845: PUSH
56846: LD_INT 9
56848: PUSH
56849: LD_INT 15
56851: PUSH
56852: LD_INT 16
56854: PUSH
56855: EMPTY
56856: LIST
56857: LIST
56858: LIST
56859: LIST
56860: LIST
56861: LIST
56862: LIST
56863: LIST
56864: LIST
56865: IN
56866: NOT
56867: OR
56868: IFFALSE 56872
// exit ;
56870: GO 57772
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56872: LD_ADDR_VAR 0 2
56876: PUSH
56877: LD_VAR 0 2
56881: PPUSH
56882: LD_INT 21
56884: PUSH
56885: LD_INT 3
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: PUSH
56892: LD_INT 24
56894: PUSH
56895: LD_INT 250
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: PPUSH
56906: CALL_OW 72
56910: ST_TO_ADDR
// case class of 1 , 15 :
56911: LD_VAR 0 4
56915: PUSH
56916: LD_INT 1
56918: DOUBLE
56919: EQUAL
56920: IFTRUE 56930
56922: LD_INT 15
56924: DOUBLE
56925: EQUAL
56926: IFTRUE 56930
56928: GO 57015
56930: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56931: LD_ADDR_VAR 0 8
56935: PUSH
56936: LD_VAR 0 2
56940: PPUSH
56941: LD_INT 2
56943: PUSH
56944: LD_INT 30
56946: PUSH
56947: LD_INT 32
56949: PUSH
56950: EMPTY
56951: LIST
56952: LIST
56953: PUSH
56954: LD_INT 30
56956: PUSH
56957: LD_INT 31
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: LIST
56968: PPUSH
56969: CALL_OW 72
56973: PUSH
56974: LD_VAR 0 2
56978: PPUSH
56979: LD_INT 2
56981: PUSH
56982: LD_INT 30
56984: PUSH
56985: LD_INT 4
56987: PUSH
56988: EMPTY
56989: LIST
56990: LIST
56991: PUSH
56992: LD_INT 30
56994: PUSH
56995: LD_INT 5
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: LIST
57006: PPUSH
57007: CALL_OW 72
57011: ADD
57012: ST_TO_ADDR
57013: GO 57261
57015: LD_INT 2
57017: DOUBLE
57018: EQUAL
57019: IFTRUE 57029
57021: LD_INT 16
57023: DOUBLE
57024: EQUAL
57025: IFTRUE 57029
57027: GO 57075
57029: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57030: LD_ADDR_VAR 0 8
57034: PUSH
57035: LD_VAR 0 2
57039: PPUSH
57040: LD_INT 2
57042: PUSH
57043: LD_INT 30
57045: PUSH
57046: LD_INT 0
57048: PUSH
57049: EMPTY
57050: LIST
57051: LIST
57052: PUSH
57053: LD_INT 30
57055: PUSH
57056: LD_INT 1
57058: PUSH
57059: EMPTY
57060: LIST
57061: LIST
57062: PUSH
57063: EMPTY
57064: LIST
57065: LIST
57066: LIST
57067: PPUSH
57068: CALL_OW 72
57072: ST_TO_ADDR
57073: GO 57261
57075: LD_INT 3
57077: DOUBLE
57078: EQUAL
57079: IFTRUE 57083
57081: GO 57129
57083: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57084: LD_ADDR_VAR 0 8
57088: PUSH
57089: LD_VAR 0 2
57093: PPUSH
57094: LD_INT 2
57096: PUSH
57097: LD_INT 30
57099: PUSH
57100: LD_INT 2
57102: PUSH
57103: EMPTY
57104: LIST
57105: LIST
57106: PUSH
57107: LD_INT 30
57109: PUSH
57110: LD_INT 3
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PUSH
57117: EMPTY
57118: LIST
57119: LIST
57120: LIST
57121: PPUSH
57122: CALL_OW 72
57126: ST_TO_ADDR
57127: GO 57261
57129: LD_INT 4
57131: DOUBLE
57132: EQUAL
57133: IFTRUE 57137
57135: GO 57194
57137: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57138: LD_ADDR_VAR 0 8
57142: PUSH
57143: LD_VAR 0 2
57147: PPUSH
57148: LD_INT 2
57150: PUSH
57151: LD_INT 30
57153: PUSH
57154: LD_INT 6
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PUSH
57161: LD_INT 30
57163: PUSH
57164: LD_INT 7
57166: PUSH
57167: EMPTY
57168: LIST
57169: LIST
57170: PUSH
57171: LD_INT 30
57173: PUSH
57174: LD_INT 8
57176: PUSH
57177: EMPTY
57178: LIST
57179: LIST
57180: PUSH
57181: EMPTY
57182: LIST
57183: LIST
57184: LIST
57185: LIST
57186: PPUSH
57187: CALL_OW 72
57191: ST_TO_ADDR
57192: GO 57261
57194: LD_INT 5
57196: DOUBLE
57197: EQUAL
57198: IFTRUE 57214
57200: LD_INT 8
57202: DOUBLE
57203: EQUAL
57204: IFTRUE 57214
57206: LD_INT 9
57208: DOUBLE
57209: EQUAL
57210: IFTRUE 57214
57212: GO 57260
57214: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57215: LD_ADDR_VAR 0 8
57219: PUSH
57220: LD_VAR 0 2
57224: PPUSH
57225: LD_INT 2
57227: PUSH
57228: LD_INT 30
57230: PUSH
57231: LD_INT 4
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 30
57240: PUSH
57241: LD_INT 5
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: LIST
57252: PPUSH
57253: CALL_OW 72
57257: ST_TO_ADDR
57258: GO 57261
57260: POP
// if not tmp then
57261: LD_VAR 0 8
57265: NOT
57266: IFFALSE 57270
// exit ;
57268: GO 57772
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57270: LD_VAR 0 4
57274: PUSH
57275: LD_INT 1
57277: PUSH
57278: LD_INT 15
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: IN
57285: PUSH
57286: LD_EXP 111
57290: PUSH
57291: LD_VAR 0 1
57295: ARRAY
57296: AND
57297: IFFALSE 57453
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57299: LD_ADDR_VAR 0 9
57303: PUSH
57304: LD_EXP 111
57308: PUSH
57309: LD_VAR 0 1
57313: ARRAY
57314: PUSH
57315: LD_INT 1
57317: ARRAY
57318: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57319: LD_VAR 0 9
57323: PUSH
57324: LD_EXP 112
57328: PUSH
57329: LD_VAR 0 1
57333: ARRAY
57334: IN
57335: NOT
57336: IFFALSE 57451
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57338: LD_ADDR_EXP 112
57342: PUSH
57343: LD_EXP 112
57347: PPUSH
57348: LD_VAR 0 1
57352: PUSH
57353: LD_EXP 112
57357: PUSH
57358: LD_VAR 0 1
57362: ARRAY
57363: PUSH
57364: LD_INT 1
57366: PLUS
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: PPUSH
57372: LD_VAR 0 9
57376: PPUSH
57377: CALL 71983 0 3
57381: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57382: LD_ADDR_EXP 111
57386: PUSH
57387: LD_EXP 111
57391: PPUSH
57392: LD_VAR 0 1
57396: PPUSH
57397: LD_EXP 111
57401: PUSH
57402: LD_VAR 0 1
57406: ARRAY
57407: PUSH
57408: LD_VAR 0 9
57412: DIFF
57413: PPUSH
57414: CALL_OW 1
57418: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57419: LD_VAR 0 3
57423: PPUSH
57424: LD_EXP 112
57428: PUSH
57429: LD_VAR 0 1
57433: ARRAY
57434: PUSH
57435: LD_EXP 112
57439: PUSH
57440: LD_VAR 0 1
57444: ARRAY
57445: ARRAY
57446: PPUSH
57447: CALL_OW 120
// end ; exit ;
57451: GO 57772
// end ; if tmp > 1 then
57453: LD_VAR 0 8
57457: PUSH
57458: LD_INT 1
57460: GREATER
57461: IFFALSE 57565
// for i = 2 to tmp do
57463: LD_ADDR_VAR 0 6
57467: PUSH
57468: DOUBLE
57469: LD_INT 2
57471: DEC
57472: ST_TO_ADDR
57473: LD_VAR 0 8
57477: PUSH
57478: FOR_TO
57479: IFFALSE 57563
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57481: LD_VAR 0 8
57485: PUSH
57486: LD_VAR 0 6
57490: ARRAY
57491: PPUSH
57492: CALL_OW 461
57496: PUSH
57497: LD_INT 6
57499: EQUAL
57500: IFFALSE 57561
// begin x := tmp [ i ] ;
57502: LD_ADDR_VAR 0 9
57506: PUSH
57507: LD_VAR 0 8
57511: PUSH
57512: LD_VAR 0 6
57516: ARRAY
57517: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57518: LD_ADDR_VAR 0 8
57522: PUSH
57523: LD_VAR 0 8
57527: PPUSH
57528: LD_VAR 0 6
57532: PPUSH
57533: CALL_OW 3
57537: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57538: LD_ADDR_VAR 0 8
57542: PUSH
57543: LD_VAR 0 8
57547: PPUSH
57548: LD_INT 1
57550: PPUSH
57551: LD_VAR 0 9
57555: PPUSH
57556: CALL_OW 2
57560: ST_TO_ADDR
// end ;
57561: GO 57478
57563: POP
57564: POP
// for i in tmp do
57565: LD_ADDR_VAR 0 6
57569: PUSH
57570: LD_VAR 0 8
57574: PUSH
57575: FOR_IN
57576: IFFALSE 57645
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57578: LD_VAR 0 6
57582: PPUSH
57583: CALL_OW 313
57587: PUSH
57588: LD_INT 6
57590: LESS
57591: PUSH
57592: LD_VAR 0 6
57596: PPUSH
57597: CALL_OW 266
57601: PUSH
57602: LD_INT 31
57604: PUSH
57605: LD_INT 32
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: IN
57612: NOT
57613: AND
57614: PUSH
57615: LD_VAR 0 6
57619: PPUSH
57620: CALL_OW 313
57624: PUSH
57625: LD_INT 0
57627: EQUAL
57628: OR
57629: IFFALSE 57643
// begin j := i ;
57631: LD_ADDR_VAR 0 7
57635: PUSH
57636: LD_VAR 0 6
57640: ST_TO_ADDR
// break ;
57641: GO 57645
// end ; end ;
57643: GO 57575
57645: POP
57646: POP
// if j then
57647: LD_VAR 0 7
57651: IFFALSE 57669
// ComEnterUnit ( unit , j ) else
57653: LD_VAR 0 3
57657: PPUSH
57658: LD_VAR 0 7
57662: PPUSH
57663: CALL_OW 120
57667: GO 57772
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57669: LD_ADDR_VAR 0 10
57673: PUSH
57674: LD_VAR 0 2
57678: PPUSH
57679: LD_INT 2
57681: PUSH
57682: LD_INT 30
57684: PUSH
57685: LD_INT 0
57687: PUSH
57688: EMPTY
57689: LIST
57690: LIST
57691: PUSH
57692: LD_INT 30
57694: PUSH
57695: LD_INT 1
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: PUSH
57702: EMPTY
57703: LIST
57704: LIST
57705: LIST
57706: PPUSH
57707: CALL_OW 72
57711: ST_TO_ADDR
// if depot then
57712: LD_VAR 0 10
57716: IFFALSE 57772
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57718: LD_ADDR_VAR 0 10
57722: PUSH
57723: LD_VAR 0 10
57727: PPUSH
57728: LD_VAR 0 3
57732: PPUSH
57733: CALL_OW 74
57737: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57738: LD_VAR 0 3
57742: PPUSH
57743: LD_VAR 0 10
57747: PPUSH
57748: CALL_OW 296
57752: PUSH
57753: LD_INT 10
57755: GREATER
57756: IFFALSE 57772
// ComStandNearbyBuilding ( unit , depot ) ;
57758: LD_VAR 0 3
57762: PPUSH
57763: LD_VAR 0 10
57767: PPUSH
57768: CALL 66186 0 2
// end ; end ; end ;
57772: LD_VAR 0 5
57776: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57777: LD_INT 0
57779: PPUSH
57780: PPUSH
57781: PPUSH
57782: PPUSH
// if not mc_bases then
57783: LD_EXP 102
57787: NOT
57788: IFFALSE 57792
// exit ;
57790: GO 58031
// for i = 1 to mc_bases do
57792: LD_ADDR_VAR 0 2
57796: PUSH
57797: DOUBLE
57798: LD_INT 1
57800: DEC
57801: ST_TO_ADDR
57802: LD_EXP 102
57806: PUSH
57807: FOR_TO
57808: IFFALSE 58029
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57810: LD_ADDR_VAR 0 4
57814: PUSH
57815: LD_EXP 102
57819: PUSH
57820: LD_VAR 0 2
57824: ARRAY
57825: PPUSH
57826: LD_INT 21
57828: PUSH
57829: LD_INT 1
57831: PUSH
57832: EMPTY
57833: LIST
57834: LIST
57835: PPUSH
57836: CALL_OW 72
57840: PUSH
57841: LD_EXP 131
57845: PUSH
57846: LD_VAR 0 2
57850: ARRAY
57851: UNION
57852: ST_TO_ADDR
// if not tmp then
57853: LD_VAR 0 4
57857: NOT
57858: IFFALSE 57862
// continue ;
57860: GO 57807
// for j in tmp do
57862: LD_ADDR_VAR 0 3
57866: PUSH
57867: LD_VAR 0 4
57871: PUSH
57872: FOR_IN
57873: IFFALSE 58025
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57875: LD_VAR 0 3
57879: PPUSH
57880: CALL_OW 110
57884: NOT
57885: PUSH
57886: LD_VAR 0 3
57890: PPUSH
57891: CALL_OW 314
57895: NOT
57896: AND
57897: PUSH
57898: LD_VAR 0 3
57902: PPUSH
57903: CALL_OW 311
57907: NOT
57908: AND
57909: PUSH
57910: LD_VAR 0 3
57914: PPUSH
57915: CALL_OW 310
57919: NOT
57920: AND
57921: PUSH
57922: LD_VAR 0 3
57926: PUSH
57927: LD_EXP 105
57931: PUSH
57932: LD_VAR 0 2
57936: ARRAY
57937: PUSH
57938: LD_INT 1
57940: ARRAY
57941: IN
57942: NOT
57943: AND
57944: PUSH
57945: LD_VAR 0 3
57949: PUSH
57950: LD_EXP 105
57954: PUSH
57955: LD_VAR 0 2
57959: ARRAY
57960: PUSH
57961: LD_INT 2
57963: ARRAY
57964: IN
57965: NOT
57966: AND
57967: PUSH
57968: LD_VAR 0 3
57972: PUSH
57973: LD_EXP 114
57977: PUSH
57978: LD_VAR 0 2
57982: ARRAY
57983: IN
57984: NOT
57985: AND
57986: IFFALSE 58023
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57988: LD_VAR 0 2
57992: PPUSH
57993: LD_EXP 102
57997: PUSH
57998: LD_VAR 0 2
58002: ARRAY
58003: PPUSH
58004: LD_VAR 0 3
58008: PPUSH
58009: LD_VAR 0 3
58013: PPUSH
58014: CALL_OW 257
58018: PPUSH
58019: CALL 56795 0 4
// end ;
58023: GO 57872
58025: POP
58026: POP
// end ;
58027: GO 57807
58029: POP
58030: POP
// end ;
58031: LD_VAR 0 1
58035: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58036: LD_INT 0
58038: PPUSH
58039: PPUSH
58040: PPUSH
58041: PPUSH
58042: PPUSH
58043: PPUSH
// if not mc_bases [ base ] then
58044: LD_EXP 102
58048: PUSH
58049: LD_VAR 0 1
58053: ARRAY
58054: NOT
58055: IFFALSE 58059
// exit ;
58057: GO 58241
// tmp := [ ] ;
58059: LD_ADDR_VAR 0 6
58063: PUSH
58064: EMPTY
58065: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58066: LD_ADDR_VAR 0 7
58070: PUSH
58071: LD_VAR 0 3
58075: PPUSH
58076: LD_INT 0
58078: PPUSH
58079: CALL_OW 517
58083: ST_TO_ADDR
// if not list then
58084: LD_VAR 0 7
58088: NOT
58089: IFFALSE 58093
// exit ;
58091: GO 58241
// for i = 1 to amount do
58093: LD_ADDR_VAR 0 5
58097: PUSH
58098: DOUBLE
58099: LD_INT 1
58101: DEC
58102: ST_TO_ADDR
58103: LD_VAR 0 2
58107: PUSH
58108: FOR_TO
58109: IFFALSE 58189
// begin x := rand ( 1 , list [ 1 ] ) ;
58111: LD_ADDR_VAR 0 8
58115: PUSH
58116: LD_INT 1
58118: PPUSH
58119: LD_VAR 0 7
58123: PUSH
58124: LD_INT 1
58126: ARRAY
58127: PPUSH
58128: CALL_OW 12
58132: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58133: LD_ADDR_VAR 0 6
58137: PUSH
58138: LD_VAR 0 6
58142: PPUSH
58143: LD_VAR 0 5
58147: PPUSH
58148: LD_VAR 0 7
58152: PUSH
58153: LD_INT 1
58155: ARRAY
58156: PUSH
58157: LD_VAR 0 8
58161: ARRAY
58162: PUSH
58163: LD_VAR 0 7
58167: PUSH
58168: LD_INT 2
58170: ARRAY
58171: PUSH
58172: LD_VAR 0 8
58176: ARRAY
58177: PUSH
58178: EMPTY
58179: LIST
58180: LIST
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// end ;
58187: GO 58108
58189: POP
58190: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58191: LD_ADDR_EXP 115
58195: PUSH
58196: LD_EXP 115
58200: PPUSH
58201: LD_VAR 0 1
58205: PPUSH
58206: LD_VAR 0 6
58210: PPUSH
58211: CALL_OW 1
58215: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58216: LD_ADDR_EXP 117
58220: PUSH
58221: LD_EXP 117
58225: PPUSH
58226: LD_VAR 0 1
58230: PPUSH
58231: LD_VAR 0 3
58235: PPUSH
58236: CALL_OW 1
58240: ST_TO_ADDR
// end ;
58241: LD_VAR 0 4
58245: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58246: LD_INT 0
58248: PPUSH
// if not mc_bases [ base ] then
58249: LD_EXP 102
58253: PUSH
58254: LD_VAR 0 1
58258: ARRAY
58259: NOT
58260: IFFALSE 58264
// exit ;
58262: GO 58289
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58264: LD_ADDR_EXP 107
58268: PUSH
58269: LD_EXP 107
58273: PPUSH
58274: LD_VAR 0 1
58278: PPUSH
58279: LD_VAR 0 2
58283: PPUSH
58284: CALL_OW 1
58288: ST_TO_ADDR
// end ;
58289: LD_VAR 0 3
58293: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58294: LD_INT 0
58296: PPUSH
// if not mc_bases [ base ] then
58297: LD_EXP 102
58301: PUSH
58302: LD_VAR 0 1
58306: ARRAY
58307: NOT
58308: IFFALSE 58312
// exit ;
58310: GO 58349
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58312: LD_ADDR_EXP 107
58316: PUSH
58317: LD_EXP 107
58321: PPUSH
58322: LD_VAR 0 1
58326: PPUSH
58327: LD_EXP 107
58331: PUSH
58332: LD_VAR 0 1
58336: ARRAY
58337: PUSH
58338: LD_VAR 0 2
58342: UNION
58343: PPUSH
58344: CALL_OW 1
58348: ST_TO_ADDR
// end ;
58349: LD_VAR 0 3
58353: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58354: LD_INT 0
58356: PPUSH
// if not mc_bases [ base ] then
58357: LD_EXP 102
58361: PUSH
58362: LD_VAR 0 1
58366: ARRAY
58367: NOT
58368: IFFALSE 58372
// exit ;
58370: GO 58397
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58372: LD_ADDR_EXP 123
58376: PUSH
58377: LD_EXP 123
58381: PPUSH
58382: LD_VAR 0 1
58386: PPUSH
58387: LD_VAR 0 2
58391: PPUSH
58392: CALL_OW 1
58396: ST_TO_ADDR
// end ;
58397: LD_VAR 0 3
58401: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58402: LD_INT 0
58404: PPUSH
// if not mc_bases [ base ] then
58405: LD_EXP 102
58409: PUSH
58410: LD_VAR 0 1
58414: ARRAY
58415: NOT
58416: IFFALSE 58420
// exit ;
58418: GO 58457
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58420: LD_ADDR_EXP 123
58424: PUSH
58425: LD_EXP 123
58429: PPUSH
58430: LD_VAR 0 1
58434: PPUSH
58435: LD_EXP 123
58439: PUSH
58440: LD_VAR 0 1
58444: ARRAY
58445: PUSH
58446: LD_VAR 0 2
58450: ADD
58451: PPUSH
58452: CALL_OW 1
58456: ST_TO_ADDR
// end ;
58457: LD_VAR 0 3
58461: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58462: LD_INT 0
58464: PPUSH
// if not mc_bases [ base ] then
58465: LD_EXP 102
58469: PUSH
58470: LD_VAR 0 1
58474: ARRAY
58475: NOT
58476: IFFALSE 58480
// exit ;
58478: GO 58534
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58480: LD_ADDR_EXP 124
58484: PUSH
58485: LD_EXP 124
58489: PPUSH
58490: LD_VAR 0 1
58494: PPUSH
58495: LD_VAR 0 2
58499: PPUSH
58500: CALL_OW 1
58504: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58505: LD_ADDR_EXP 113
58509: PUSH
58510: LD_EXP 113
58514: PPUSH
58515: LD_VAR 0 1
58519: PPUSH
58520: LD_VAR 0 2
58524: PUSH
58525: LD_INT 0
58527: PLUS
58528: PPUSH
58529: CALL_OW 1
58533: ST_TO_ADDR
// end ;
58534: LD_VAR 0 3
58538: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58539: LD_INT 0
58541: PPUSH
// if not mc_bases [ base ] then
58542: LD_EXP 102
58546: PUSH
58547: LD_VAR 0 1
58551: ARRAY
58552: NOT
58553: IFFALSE 58557
// exit ;
58555: GO 58582
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58557: LD_ADDR_EXP 113
58561: PUSH
58562: LD_EXP 113
58566: PPUSH
58567: LD_VAR 0 1
58571: PPUSH
58572: LD_VAR 0 2
58576: PPUSH
58577: CALL_OW 1
58581: ST_TO_ADDR
// end ;
58582: LD_VAR 0 3
58586: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58587: LD_INT 0
58589: PPUSH
58590: PPUSH
58591: PPUSH
58592: PPUSH
// if not mc_bases [ base ] then
58593: LD_EXP 102
58597: PUSH
58598: LD_VAR 0 1
58602: ARRAY
58603: NOT
58604: IFFALSE 58608
// exit ;
58606: GO 58673
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58608: LD_ADDR_EXP 122
58612: PUSH
58613: LD_EXP 122
58617: PPUSH
58618: LD_VAR 0 1
58622: PUSH
58623: LD_EXP 122
58627: PUSH
58628: LD_VAR 0 1
58632: ARRAY
58633: PUSH
58634: LD_INT 1
58636: PLUS
58637: PUSH
58638: EMPTY
58639: LIST
58640: LIST
58641: PPUSH
58642: LD_VAR 0 1
58646: PUSH
58647: LD_VAR 0 2
58651: PUSH
58652: LD_VAR 0 3
58656: PUSH
58657: LD_VAR 0 4
58661: PUSH
58662: EMPTY
58663: LIST
58664: LIST
58665: LIST
58666: LIST
58667: PPUSH
58668: CALL 71983 0 3
58672: ST_TO_ADDR
// end ;
58673: LD_VAR 0 5
58677: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58678: LD_INT 0
58680: PPUSH
// if not mc_bases [ base ] then
58681: LD_EXP 102
58685: PUSH
58686: LD_VAR 0 1
58690: ARRAY
58691: NOT
58692: IFFALSE 58696
// exit ;
58694: GO 58721
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58696: LD_ADDR_EXP 139
58700: PUSH
58701: LD_EXP 139
58705: PPUSH
58706: LD_VAR 0 1
58710: PPUSH
58711: LD_VAR 0 2
58715: PPUSH
58716: CALL_OW 1
58720: ST_TO_ADDR
// end ;
58721: LD_VAR 0 3
58725: RET
// export function MC_GetMinesField ( base ) ; begin
58726: LD_INT 0
58728: PPUSH
// result := mc_mines [ base ] ;
58729: LD_ADDR_VAR 0 2
58733: PUSH
58734: LD_EXP 115
58738: PUSH
58739: LD_VAR 0 1
58743: ARRAY
58744: ST_TO_ADDR
// end ;
58745: LD_VAR 0 2
58749: RET
// export function MC_GetProduceList ( base ) ; begin
58750: LD_INT 0
58752: PPUSH
// result := mc_produce [ base ] ;
58753: LD_ADDR_VAR 0 2
58757: PUSH
58758: LD_EXP 123
58762: PUSH
58763: LD_VAR 0 1
58767: ARRAY
58768: ST_TO_ADDR
// end ;
58769: LD_VAR 0 2
58773: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58774: LD_INT 0
58776: PPUSH
58777: PPUSH
// if not mc_bases then
58778: LD_EXP 102
58782: NOT
58783: IFFALSE 58787
// exit ;
58785: GO 58852
// if mc_bases [ base ] then
58787: LD_EXP 102
58791: PUSH
58792: LD_VAR 0 1
58796: ARRAY
58797: IFFALSE 58852
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58799: LD_ADDR_VAR 0 3
58803: PUSH
58804: LD_EXP 102
58808: PUSH
58809: LD_VAR 0 1
58813: ARRAY
58814: PPUSH
58815: LD_INT 30
58817: PUSH
58818: LD_VAR 0 2
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: PPUSH
58827: CALL_OW 72
58831: ST_TO_ADDR
// if result then
58832: LD_VAR 0 3
58836: IFFALSE 58852
// result := result [ 1 ] ;
58838: LD_ADDR_VAR 0 3
58842: PUSH
58843: LD_VAR 0 3
58847: PUSH
58848: LD_INT 1
58850: ARRAY
58851: ST_TO_ADDR
// end ; end ;
58852: LD_VAR 0 3
58856: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58857: LD_INT 0
58859: PPUSH
58860: PPUSH
// if not mc_bases then
58861: LD_EXP 102
58865: NOT
58866: IFFALSE 58870
// exit ;
58868: GO 58915
// if mc_bases [ base ] then
58870: LD_EXP 102
58874: PUSH
58875: LD_VAR 0 1
58879: ARRAY
58880: IFFALSE 58915
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58882: LD_ADDR_VAR 0 3
58886: PUSH
58887: LD_EXP 102
58891: PUSH
58892: LD_VAR 0 1
58896: ARRAY
58897: PPUSH
58898: LD_INT 30
58900: PUSH
58901: LD_VAR 0 2
58905: PUSH
58906: EMPTY
58907: LIST
58908: LIST
58909: PPUSH
58910: CALL_OW 72
58914: ST_TO_ADDR
// end ;
58915: LD_VAR 0 3
58919: RET
// export function MC_SetTame ( base , area ) ; begin
58920: LD_INT 0
58922: PPUSH
// if not mc_bases or not base then
58923: LD_EXP 102
58927: NOT
58928: PUSH
58929: LD_VAR 0 1
58933: NOT
58934: OR
58935: IFFALSE 58939
// exit ;
58937: GO 58964
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58939: LD_ADDR_EXP 130
58943: PUSH
58944: LD_EXP 130
58948: PPUSH
58949: LD_VAR 0 1
58953: PPUSH
58954: LD_VAR 0 2
58958: PPUSH
58959: CALL_OW 1
58963: ST_TO_ADDR
// end ;
58964: LD_VAR 0 3
58968: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58969: LD_INT 0
58971: PPUSH
58972: PPUSH
// if not mc_bases or not base then
58973: LD_EXP 102
58977: NOT
58978: PUSH
58979: LD_VAR 0 1
58983: NOT
58984: OR
58985: IFFALSE 58989
// exit ;
58987: GO 59091
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58989: LD_ADDR_VAR 0 4
58993: PUSH
58994: LD_EXP 102
58998: PUSH
58999: LD_VAR 0 1
59003: ARRAY
59004: PPUSH
59005: LD_INT 30
59007: PUSH
59008: LD_VAR 0 2
59012: PUSH
59013: EMPTY
59014: LIST
59015: LIST
59016: PPUSH
59017: CALL_OW 72
59021: ST_TO_ADDR
// if not tmp then
59022: LD_VAR 0 4
59026: NOT
59027: IFFALSE 59031
// exit ;
59029: GO 59091
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59031: LD_ADDR_EXP 134
59035: PUSH
59036: LD_EXP 134
59040: PPUSH
59041: LD_VAR 0 1
59045: PPUSH
59046: LD_EXP 134
59050: PUSH
59051: LD_VAR 0 1
59055: ARRAY
59056: PPUSH
59057: LD_EXP 134
59061: PUSH
59062: LD_VAR 0 1
59066: ARRAY
59067: PUSH
59068: LD_INT 1
59070: PLUS
59071: PPUSH
59072: LD_VAR 0 4
59076: PUSH
59077: LD_INT 1
59079: ARRAY
59080: PPUSH
59081: CALL_OW 2
59085: PPUSH
59086: CALL_OW 1
59090: ST_TO_ADDR
// end ;
59091: LD_VAR 0 3
59095: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59096: LD_INT 0
59098: PPUSH
59099: PPUSH
// if not mc_bases or not base or not kinds then
59100: LD_EXP 102
59104: NOT
59105: PUSH
59106: LD_VAR 0 1
59110: NOT
59111: OR
59112: PUSH
59113: LD_VAR 0 2
59117: NOT
59118: OR
59119: IFFALSE 59123
// exit ;
59121: GO 59184
// for i in kinds do
59123: LD_ADDR_VAR 0 4
59127: PUSH
59128: LD_VAR 0 2
59132: PUSH
59133: FOR_IN
59134: IFFALSE 59182
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59136: LD_ADDR_EXP 136
59140: PUSH
59141: LD_EXP 136
59145: PPUSH
59146: LD_VAR 0 1
59150: PUSH
59151: LD_EXP 136
59155: PUSH
59156: LD_VAR 0 1
59160: ARRAY
59161: PUSH
59162: LD_INT 1
59164: PLUS
59165: PUSH
59166: EMPTY
59167: LIST
59168: LIST
59169: PPUSH
59170: LD_VAR 0 4
59174: PPUSH
59175: CALL 71983 0 3
59179: ST_TO_ADDR
59180: GO 59133
59182: POP
59183: POP
// end ;
59184: LD_VAR 0 3
59188: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59189: LD_INT 0
59191: PPUSH
// if not mc_bases or not base or not areas then
59192: LD_EXP 102
59196: NOT
59197: PUSH
59198: LD_VAR 0 1
59202: NOT
59203: OR
59204: PUSH
59205: LD_VAR 0 2
59209: NOT
59210: OR
59211: IFFALSE 59215
// exit ;
59213: GO 59240
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59215: LD_ADDR_EXP 120
59219: PUSH
59220: LD_EXP 120
59224: PPUSH
59225: LD_VAR 0 1
59229: PPUSH
59230: LD_VAR 0 2
59234: PPUSH
59235: CALL_OW 1
59239: ST_TO_ADDR
// end ;
59240: LD_VAR 0 3
59244: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59245: LD_INT 0
59247: PPUSH
// if not mc_bases or not base or not teleports_exit then
59248: LD_EXP 102
59252: NOT
59253: PUSH
59254: LD_VAR 0 1
59258: NOT
59259: OR
59260: PUSH
59261: LD_VAR 0 2
59265: NOT
59266: OR
59267: IFFALSE 59271
// exit ;
59269: GO 59296
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59271: LD_ADDR_EXP 137
59275: PUSH
59276: LD_EXP 137
59280: PPUSH
59281: LD_VAR 0 1
59285: PPUSH
59286: LD_VAR 0 2
59290: PPUSH
59291: CALL_OW 1
59295: ST_TO_ADDR
// end ;
59296: LD_VAR 0 3
59300: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59301: LD_INT 0
59303: PPUSH
59304: PPUSH
59305: PPUSH
// if not mc_bases or not base or not ext_list then
59306: LD_EXP 102
59310: NOT
59311: PUSH
59312: LD_VAR 0 1
59316: NOT
59317: OR
59318: PUSH
59319: LD_VAR 0 5
59323: NOT
59324: OR
59325: IFFALSE 59329
// exit ;
59327: GO 59502
// tmp := GetFacExtXYD ( x , y , d ) ;
59329: LD_ADDR_VAR 0 8
59333: PUSH
59334: LD_VAR 0 2
59338: PPUSH
59339: LD_VAR 0 3
59343: PPUSH
59344: LD_VAR 0 4
59348: PPUSH
59349: CALL 105364 0 3
59353: ST_TO_ADDR
// if not tmp then
59354: LD_VAR 0 8
59358: NOT
59359: IFFALSE 59363
// exit ;
59361: GO 59502
// for i in tmp do
59363: LD_ADDR_VAR 0 7
59367: PUSH
59368: LD_VAR 0 8
59372: PUSH
59373: FOR_IN
59374: IFFALSE 59500
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59376: LD_ADDR_EXP 107
59380: PUSH
59381: LD_EXP 107
59385: PPUSH
59386: LD_VAR 0 1
59390: PPUSH
59391: LD_EXP 107
59395: PUSH
59396: LD_VAR 0 1
59400: ARRAY
59401: PPUSH
59402: LD_EXP 107
59406: PUSH
59407: LD_VAR 0 1
59411: ARRAY
59412: PUSH
59413: LD_INT 1
59415: PLUS
59416: PPUSH
59417: LD_VAR 0 5
59421: PUSH
59422: LD_INT 1
59424: ARRAY
59425: PUSH
59426: LD_VAR 0 7
59430: PUSH
59431: LD_INT 1
59433: ARRAY
59434: PUSH
59435: LD_VAR 0 7
59439: PUSH
59440: LD_INT 2
59442: ARRAY
59443: PUSH
59444: LD_VAR 0 7
59448: PUSH
59449: LD_INT 3
59451: ARRAY
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: LIST
59457: LIST
59458: PPUSH
59459: CALL_OW 2
59463: PPUSH
59464: CALL_OW 1
59468: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59469: LD_ADDR_VAR 0 5
59473: PUSH
59474: LD_VAR 0 5
59478: PPUSH
59479: LD_INT 1
59481: PPUSH
59482: CALL_OW 3
59486: ST_TO_ADDR
// if not ext_list then
59487: LD_VAR 0 5
59491: NOT
59492: IFFALSE 59498
// exit ;
59494: POP
59495: POP
59496: GO 59502
// end ;
59498: GO 59373
59500: POP
59501: POP
// end ;
59502: LD_VAR 0 6
59506: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59507: LD_INT 0
59509: PPUSH
// if not mc_bases or not base or not weapon_list then
59510: LD_EXP 102
59514: NOT
59515: PUSH
59516: LD_VAR 0 1
59520: NOT
59521: OR
59522: PUSH
59523: LD_VAR 0 2
59527: NOT
59528: OR
59529: IFFALSE 59533
// exit ;
59531: GO 59558
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59533: LD_ADDR_EXP 141
59537: PUSH
59538: LD_EXP 141
59542: PPUSH
59543: LD_VAR 0 1
59547: PPUSH
59548: LD_VAR 0 2
59552: PPUSH
59553: CALL_OW 1
59557: ST_TO_ADDR
// end ;
59558: LD_VAR 0 3
59562: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59563: LD_INT 0
59565: PPUSH
// if not mc_bases or not base or not tech_list then
59566: LD_EXP 102
59570: NOT
59571: PUSH
59572: LD_VAR 0 1
59576: NOT
59577: OR
59578: PUSH
59579: LD_VAR 0 2
59583: NOT
59584: OR
59585: IFFALSE 59589
// exit ;
59587: GO 59614
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59589: LD_ADDR_EXP 129
59593: PUSH
59594: LD_EXP 129
59598: PPUSH
59599: LD_VAR 0 1
59603: PPUSH
59604: LD_VAR 0 2
59608: PPUSH
59609: CALL_OW 1
59613: ST_TO_ADDR
// end ;
59614: LD_VAR 0 3
59618: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59619: LD_INT 0
59621: PPUSH
// if not mc_bases or not parking_area or not base then
59622: LD_EXP 102
59626: NOT
59627: PUSH
59628: LD_VAR 0 2
59632: NOT
59633: OR
59634: PUSH
59635: LD_VAR 0 1
59639: NOT
59640: OR
59641: IFFALSE 59645
// exit ;
59643: GO 59670
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59645: LD_ADDR_EXP 126
59649: PUSH
59650: LD_EXP 126
59654: PPUSH
59655: LD_VAR 0 1
59659: PPUSH
59660: LD_VAR 0 2
59664: PPUSH
59665: CALL_OW 1
59669: ST_TO_ADDR
// end ;
59670: LD_VAR 0 3
59674: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59675: LD_INT 0
59677: PPUSH
// if not mc_bases or not base or not scan_area then
59678: LD_EXP 102
59682: NOT
59683: PUSH
59684: LD_VAR 0 1
59688: NOT
59689: OR
59690: PUSH
59691: LD_VAR 0 2
59695: NOT
59696: OR
59697: IFFALSE 59701
// exit ;
59699: GO 59726
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59701: LD_ADDR_EXP 127
59705: PUSH
59706: LD_EXP 127
59710: PPUSH
59711: LD_VAR 0 1
59715: PPUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: CALL_OW 1
59725: ST_TO_ADDR
// end ;
59726: LD_VAR 0 3
59730: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59731: LD_INT 0
59733: PPUSH
59734: PPUSH
// if not mc_bases or not base then
59735: LD_EXP 102
59739: NOT
59740: PUSH
59741: LD_VAR 0 1
59745: NOT
59746: OR
59747: IFFALSE 59751
// exit ;
59749: GO 59815
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59751: LD_ADDR_VAR 0 3
59755: PUSH
59756: LD_INT 1
59758: PUSH
59759: LD_INT 2
59761: PUSH
59762: LD_INT 3
59764: PUSH
59765: LD_INT 4
59767: PUSH
59768: LD_INT 11
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59778: LD_ADDR_EXP 129
59782: PUSH
59783: LD_EXP 129
59787: PPUSH
59788: LD_VAR 0 1
59792: PPUSH
59793: LD_EXP 129
59797: PUSH
59798: LD_VAR 0 1
59802: ARRAY
59803: PUSH
59804: LD_VAR 0 3
59808: DIFF
59809: PPUSH
59810: CALL_OW 1
59814: ST_TO_ADDR
// end ;
59815: LD_VAR 0 2
59819: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59820: LD_INT 0
59822: PPUSH
// result := mc_vehicles [ base ] ;
59823: LD_ADDR_VAR 0 3
59827: PUSH
59828: LD_EXP 121
59832: PUSH
59833: LD_VAR 0 1
59837: ARRAY
59838: ST_TO_ADDR
// if onlyCombat then
59839: LD_VAR 0 2
59843: IFFALSE 60008
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59845: LD_ADDR_VAR 0 3
59849: PUSH
59850: LD_VAR 0 3
59854: PUSH
59855: LD_VAR 0 3
59859: PPUSH
59860: LD_INT 2
59862: PUSH
59863: LD_INT 34
59865: PUSH
59866: LD_INT 12
59868: PUSH
59869: EMPTY
59870: LIST
59871: LIST
59872: PUSH
59873: LD_INT 34
59875: PUSH
59876: LD_INT 51
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: PUSH
59883: LD_INT 34
59885: PUSH
59886: LD_EXP 96
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: PUSH
59895: LD_INT 34
59897: PUSH
59898: LD_INT 32
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PUSH
59905: LD_INT 34
59907: PUSH
59908: LD_INT 13
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 34
59917: PUSH
59918: LD_INT 52
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 34
59927: PUSH
59928: LD_INT 14
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 34
59937: PUSH
59938: LD_INT 53
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PUSH
59945: LD_INT 34
59947: PUSH
59948: LD_EXP 95
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PUSH
59957: LD_INT 34
59959: PUSH
59960: LD_INT 31
59962: PUSH
59963: EMPTY
59964: LIST
59965: LIST
59966: PUSH
59967: LD_INT 34
59969: PUSH
59970: LD_INT 48
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PUSH
59977: LD_INT 34
59979: PUSH
59980: LD_INT 8
59982: PUSH
59983: EMPTY
59984: LIST
59985: LIST
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: LIST
59991: LIST
59992: LIST
59993: LIST
59994: LIST
59995: LIST
59996: LIST
59997: LIST
59998: LIST
59999: LIST
60000: LIST
60001: PPUSH
60002: CALL_OW 72
60006: DIFF
60007: ST_TO_ADDR
// end ; end_of_file
60008: LD_VAR 0 3
60012: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60013: LD_INT 0
60015: PPUSH
60016: PPUSH
60017: PPUSH
// if not mc_bases or not skirmish then
60018: LD_EXP 102
60022: NOT
60023: PUSH
60024: LD_EXP 100
60028: NOT
60029: OR
60030: IFFALSE 60034
// exit ;
60032: GO 60199
// for i = 1 to mc_bases do
60034: LD_ADDR_VAR 0 4
60038: PUSH
60039: DOUBLE
60040: LD_INT 1
60042: DEC
60043: ST_TO_ADDR
60044: LD_EXP 102
60048: PUSH
60049: FOR_TO
60050: IFFALSE 60197
// begin if sci in mc_bases [ i ] then
60052: LD_VAR 0 2
60056: PUSH
60057: LD_EXP 102
60061: PUSH
60062: LD_VAR 0 4
60066: ARRAY
60067: IN
60068: IFFALSE 60195
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60070: LD_ADDR_EXP 131
60074: PUSH
60075: LD_EXP 131
60079: PPUSH
60080: LD_VAR 0 4
60084: PUSH
60085: LD_EXP 131
60089: PUSH
60090: LD_VAR 0 4
60094: ARRAY
60095: PUSH
60096: LD_INT 1
60098: PLUS
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PPUSH
60104: LD_VAR 0 1
60108: PPUSH
60109: CALL 71983 0 3
60113: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60114: LD_ADDR_VAR 0 5
60118: PUSH
60119: LD_EXP 102
60123: PUSH
60124: LD_VAR 0 4
60128: ARRAY
60129: PPUSH
60130: LD_INT 2
60132: PUSH
60133: LD_INT 30
60135: PUSH
60136: LD_INT 0
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: PUSH
60143: LD_INT 30
60145: PUSH
60146: LD_INT 1
60148: PUSH
60149: EMPTY
60150: LIST
60151: LIST
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: LIST
60157: PPUSH
60158: CALL_OW 72
60162: PPUSH
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL_OW 74
60172: ST_TO_ADDR
// if tmp then
60173: LD_VAR 0 5
60177: IFFALSE 60193
// ComStandNearbyBuilding ( ape , tmp ) ;
60179: LD_VAR 0 1
60183: PPUSH
60184: LD_VAR 0 5
60188: PPUSH
60189: CALL 66186 0 2
// break ;
60193: GO 60197
// end ; end ;
60195: GO 60049
60197: POP
60198: POP
// end ;
60199: LD_VAR 0 3
60203: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60204: LD_INT 0
60206: PPUSH
60207: PPUSH
60208: PPUSH
// if not mc_bases or not skirmish then
60209: LD_EXP 102
60213: NOT
60214: PUSH
60215: LD_EXP 100
60219: NOT
60220: OR
60221: IFFALSE 60225
// exit ;
60223: GO 60314
// for i = 1 to mc_bases do
60225: LD_ADDR_VAR 0 4
60229: PUSH
60230: DOUBLE
60231: LD_INT 1
60233: DEC
60234: ST_TO_ADDR
60235: LD_EXP 102
60239: PUSH
60240: FOR_TO
60241: IFFALSE 60312
// begin if building in mc_busy_turret_list [ i ] then
60243: LD_VAR 0 1
60247: PUSH
60248: LD_EXP 112
60252: PUSH
60253: LD_VAR 0 4
60257: ARRAY
60258: IN
60259: IFFALSE 60310
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60261: LD_ADDR_VAR 0 5
60265: PUSH
60266: LD_EXP 112
60270: PUSH
60271: LD_VAR 0 4
60275: ARRAY
60276: PUSH
60277: LD_VAR 0 1
60281: DIFF
60282: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60283: LD_ADDR_EXP 112
60287: PUSH
60288: LD_EXP 112
60292: PPUSH
60293: LD_VAR 0 4
60297: PPUSH
60298: LD_VAR 0 5
60302: PPUSH
60303: CALL_OW 1
60307: ST_TO_ADDR
// break ;
60308: GO 60312
// end ; end ;
60310: GO 60240
60312: POP
60313: POP
// end ;
60314: LD_VAR 0 3
60318: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60319: LD_INT 0
60321: PPUSH
60322: PPUSH
60323: PPUSH
// if not mc_bases or not skirmish then
60324: LD_EXP 102
60328: NOT
60329: PUSH
60330: LD_EXP 100
60334: NOT
60335: OR
60336: IFFALSE 60340
// exit ;
60338: GO 60539
// for i = 1 to mc_bases do
60340: LD_ADDR_VAR 0 5
60344: PUSH
60345: DOUBLE
60346: LD_INT 1
60348: DEC
60349: ST_TO_ADDR
60350: LD_EXP 102
60354: PUSH
60355: FOR_TO
60356: IFFALSE 60537
// if building in mc_bases [ i ] then
60358: LD_VAR 0 1
60362: PUSH
60363: LD_EXP 102
60367: PUSH
60368: LD_VAR 0 5
60372: ARRAY
60373: IN
60374: IFFALSE 60535
// begin tmp := mc_bases [ i ] diff building ;
60376: LD_ADDR_VAR 0 6
60380: PUSH
60381: LD_EXP 102
60385: PUSH
60386: LD_VAR 0 5
60390: ARRAY
60391: PUSH
60392: LD_VAR 0 1
60396: DIFF
60397: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60398: LD_ADDR_EXP 102
60402: PUSH
60403: LD_EXP 102
60407: PPUSH
60408: LD_VAR 0 5
60412: PPUSH
60413: LD_VAR 0 6
60417: PPUSH
60418: CALL_OW 1
60422: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60423: LD_VAR 0 1
60427: PUSH
60428: LD_EXP 110
60432: PUSH
60433: LD_VAR 0 5
60437: ARRAY
60438: IN
60439: IFFALSE 60478
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60441: LD_ADDR_EXP 110
60445: PUSH
60446: LD_EXP 110
60450: PPUSH
60451: LD_VAR 0 5
60455: PPUSH
60456: LD_EXP 110
60460: PUSH
60461: LD_VAR 0 5
60465: ARRAY
60466: PUSH
60467: LD_VAR 0 1
60471: DIFF
60472: PPUSH
60473: CALL_OW 1
60477: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60478: LD_VAR 0 1
60482: PUSH
60483: LD_EXP 111
60487: PUSH
60488: LD_VAR 0 5
60492: ARRAY
60493: IN
60494: IFFALSE 60533
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60496: LD_ADDR_EXP 111
60500: PUSH
60501: LD_EXP 111
60505: PPUSH
60506: LD_VAR 0 5
60510: PPUSH
60511: LD_EXP 111
60515: PUSH
60516: LD_VAR 0 5
60520: ARRAY
60521: PUSH
60522: LD_VAR 0 1
60526: DIFF
60527: PPUSH
60528: CALL_OW 1
60532: ST_TO_ADDR
// break ;
60533: GO 60537
// end ;
60535: GO 60355
60537: POP
60538: POP
// end ;
60539: LD_VAR 0 4
60543: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60544: LD_INT 0
60546: PPUSH
60547: PPUSH
60548: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60549: LD_EXP 102
60553: NOT
60554: PUSH
60555: LD_EXP 100
60559: NOT
60560: OR
60561: PUSH
60562: LD_VAR 0 3
60566: PUSH
60567: LD_EXP 128
60571: IN
60572: NOT
60573: OR
60574: IFFALSE 60578
// exit ;
60576: GO 60701
// for i = 1 to mc_vehicles do
60578: LD_ADDR_VAR 0 6
60582: PUSH
60583: DOUBLE
60584: LD_INT 1
60586: DEC
60587: ST_TO_ADDR
60588: LD_EXP 121
60592: PUSH
60593: FOR_TO
60594: IFFALSE 60699
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60596: LD_VAR 0 2
60600: PUSH
60601: LD_EXP 121
60605: PUSH
60606: LD_VAR 0 6
60610: ARRAY
60611: IN
60612: PUSH
60613: LD_VAR 0 1
60617: PUSH
60618: LD_EXP 121
60622: PUSH
60623: LD_VAR 0 6
60627: ARRAY
60628: IN
60629: OR
60630: IFFALSE 60697
// begin tmp := mc_vehicles [ i ] diff old ;
60632: LD_ADDR_VAR 0 7
60636: PUSH
60637: LD_EXP 121
60641: PUSH
60642: LD_VAR 0 6
60646: ARRAY
60647: PUSH
60648: LD_VAR 0 2
60652: DIFF
60653: ST_TO_ADDR
// tmp := tmp diff new ;
60654: LD_ADDR_VAR 0 7
60658: PUSH
60659: LD_VAR 0 7
60663: PUSH
60664: LD_VAR 0 1
60668: DIFF
60669: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60670: LD_ADDR_EXP 121
60674: PUSH
60675: LD_EXP 121
60679: PPUSH
60680: LD_VAR 0 6
60684: PPUSH
60685: LD_VAR 0 7
60689: PPUSH
60690: CALL_OW 1
60694: ST_TO_ADDR
// break ;
60695: GO 60699
// end ;
60697: GO 60593
60699: POP
60700: POP
// end ;
60701: LD_VAR 0 5
60705: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60706: LD_INT 0
60708: PPUSH
60709: PPUSH
60710: PPUSH
60711: PPUSH
// if not mc_bases or not skirmish then
60712: LD_EXP 102
60716: NOT
60717: PUSH
60718: LD_EXP 100
60722: NOT
60723: OR
60724: IFFALSE 60728
// exit ;
60726: GO 61105
// side := GetSide ( vehicle ) ;
60728: LD_ADDR_VAR 0 5
60732: PUSH
60733: LD_VAR 0 1
60737: PPUSH
60738: CALL_OW 255
60742: ST_TO_ADDR
// for i = 1 to mc_bases do
60743: LD_ADDR_VAR 0 4
60747: PUSH
60748: DOUBLE
60749: LD_INT 1
60751: DEC
60752: ST_TO_ADDR
60753: LD_EXP 102
60757: PUSH
60758: FOR_TO
60759: IFFALSE 61103
// begin if factory in mc_bases [ i ] then
60761: LD_VAR 0 2
60765: PUSH
60766: LD_EXP 102
60770: PUSH
60771: LD_VAR 0 4
60775: ARRAY
60776: IN
60777: IFFALSE 61101
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60779: LD_EXP 124
60783: PUSH
60784: LD_VAR 0 4
60788: ARRAY
60789: PUSH
60790: LD_EXP 113
60794: PUSH
60795: LD_VAR 0 4
60799: ARRAY
60800: LESS
60801: PUSH
60802: LD_VAR 0 1
60806: PPUSH
60807: CALL_OW 264
60811: PUSH
60812: LD_INT 31
60814: PUSH
60815: LD_INT 32
60817: PUSH
60818: LD_INT 51
60820: PUSH
60821: LD_EXP 96
60825: PUSH
60826: LD_INT 12
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_EXP 95
60836: PUSH
60837: LD_INT 11
60839: PUSH
60840: LD_INT 53
60842: PUSH
60843: LD_INT 14
60845: PUSH
60846: LD_EXP 99
60850: PUSH
60851: LD_INT 29
60853: PUSH
60854: LD_EXP 97
60858: PUSH
60859: LD_INT 13
60861: PUSH
60862: LD_INT 52
60864: PUSH
60865: LD_INT 48
60867: PUSH
60868: LD_INT 8
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: LIST
60875: LIST
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: IN
60890: NOT
60891: AND
60892: IFFALSE 60940
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60894: LD_ADDR_EXP 124
60898: PUSH
60899: LD_EXP 124
60903: PPUSH
60904: LD_VAR 0 4
60908: PUSH
60909: LD_EXP 124
60913: PUSH
60914: LD_VAR 0 4
60918: ARRAY
60919: PUSH
60920: LD_INT 1
60922: PLUS
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: PPUSH
60928: LD_VAR 0 1
60932: PPUSH
60933: CALL 71983 0 3
60937: ST_TO_ADDR
60938: GO 60984
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60940: LD_ADDR_EXP 121
60944: PUSH
60945: LD_EXP 121
60949: PPUSH
60950: LD_VAR 0 4
60954: PUSH
60955: LD_EXP 121
60959: PUSH
60960: LD_VAR 0 4
60964: ARRAY
60965: PUSH
60966: LD_INT 1
60968: PLUS
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PPUSH
60974: LD_VAR 0 1
60978: PPUSH
60979: CALL 71983 0 3
60983: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60984: LD_VAR 0 1
60988: PPUSH
60989: CALL_OW 263
60993: PUSH
60994: LD_INT 2
60996: EQUAL
60997: IFFALSE 61017
// begin repeat wait ( 0 0$1 ) ;
60999: LD_INT 35
61001: PPUSH
61002: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61006: LD_VAR 0 1
61010: PPUSH
61011: CALL_OW 312
61015: IFFALSE 60999
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61017: LD_VAR 0 1
61021: PPUSH
61022: LD_EXP 126
61026: PUSH
61027: LD_VAR 0 4
61031: ARRAY
61032: PPUSH
61033: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61037: LD_VAR 0 1
61041: PPUSH
61042: CALL_OW 263
61046: PUSH
61047: LD_INT 1
61049: NONEQUAL
61050: IFFALSE 61054
// break ;
61052: GO 61103
// repeat wait ( 0 0$1 ) ;
61054: LD_INT 35
61056: PPUSH
61057: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61061: LD_VAR 0 1
61065: PPUSH
61066: LD_EXP 126
61070: PUSH
61071: LD_VAR 0 4
61075: ARRAY
61076: PPUSH
61077: CALL_OW 308
61081: IFFALSE 61054
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61083: LD_VAR 0 1
61087: PPUSH
61088: CALL_OW 311
61092: PPUSH
61093: CALL_OW 121
// exit ;
61097: POP
61098: POP
61099: GO 61105
// end ; end ;
61101: GO 60758
61103: POP
61104: POP
// end ;
61105: LD_VAR 0 3
61109: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61110: LD_INT 0
61112: PPUSH
61113: PPUSH
61114: PPUSH
61115: PPUSH
// if not mc_bases or not skirmish then
61116: LD_EXP 102
61120: NOT
61121: PUSH
61122: LD_EXP 100
61126: NOT
61127: OR
61128: IFFALSE 61132
// exit ;
61130: GO 61485
// repeat wait ( 0 0$1 ) ;
61132: LD_INT 35
61134: PPUSH
61135: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61139: LD_VAR 0 2
61143: PPUSH
61144: LD_VAR 0 3
61148: PPUSH
61149: CALL_OW 284
61153: IFFALSE 61132
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61155: LD_VAR 0 2
61159: PPUSH
61160: LD_VAR 0 3
61164: PPUSH
61165: CALL_OW 283
61169: PUSH
61170: LD_INT 4
61172: EQUAL
61173: IFFALSE 61177
// exit ;
61175: GO 61485
// for i = 1 to mc_bases do
61177: LD_ADDR_VAR 0 7
61181: PUSH
61182: DOUBLE
61183: LD_INT 1
61185: DEC
61186: ST_TO_ADDR
61187: LD_EXP 102
61191: PUSH
61192: FOR_TO
61193: IFFALSE 61483
// begin if mc_crates_area [ i ] then
61195: LD_EXP 120
61199: PUSH
61200: LD_VAR 0 7
61204: ARRAY
61205: IFFALSE 61316
// for j in mc_crates_area [ i ] do
61207: LD_ADDR_VAR 0 8
61211: PUSH
61212: LD_EXP 120
61216: PUSH
61217: LD_VAR 0 7
61221: ARRAY
61222: PUSH
61223: FOR_IN
61224: IFFALSE 61314
// if InArea ( x , y , j ) then
61226: LD_VAR 0 2
61230: PPUSH
61231: LD_VAR 0 3
61235: PPUSH
61236: LD_VAR 0 8
61240: PPUSH
61241: CALL_OW 309
61245: IFFALSE 61312
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61247: LD_ADDR_EXP 118
61251: PUSH
61252: LD_EXP 118
61256: PPUSH
61257: LD_VAR 0 7
61261: PUSH
61262: LD_EXP 118
61266: PUSH
61267: LD_VAR 0 7
61271: ARRAY
61272: PUSH
61273: LD_INT 1
61275: PLUS
61276: PUSH
61277: EMPTY
61278: LIST
61279: LIST
61280: PPUSH
61281: LD_VAR 0 4
61285: PUSH
61286: LD_VAR 0 2
61290: PUSH
61291: LD_VAR 0 3
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: LIST
61300: PPUSH
61301: CALL 71983 0 3
61305: ST_TO_ADDR
// exit ;
61306: POP
61307: POP
61308: POP
61309: POP
61310: GO 61485
// end ;
61312: GO 61223
61314: POP
61315: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61316: LD_ADDR_VAR 0 9
61320: PUSH
61321: LD_EXP 102
61325: PUSH
61326: LD_VAR 0 7
61330: ARRAY
61331: PPUSH
61332: LD_INT 2
61334: PUSH
61335: LD_INT 30
61337: PUSH
61338: LD_INT 0
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: LD_INT 30
61347: PUSH
61348: LD_INT 1
61350: PUSH
61351: EMPTY
61352: LIST
61353: LIST
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: LIST
61359: PPUSH
61360: CALL_OW 72
61364: ST_TO_ADDR
// if not depot then
61365: LD_VAR 0 9
61369: NOT
61370: IFFALSE 61374
// continue ;
61372: GO 61192
// for j in depot do
61374: LD_ADDR_VAR 0 8
61378: PUSH
61379: LD_VAR 0 9
61383: PUSH
61384: FOR_IN
61385: IFFALSE 61479
// if GetDistUnitXY ( j , x , y ) < 30 then
61387: LD_VAR 0 8
61391: PPUSH
61392: LD_VAR 0 2
61396: PPUSH
61397: LD_VAR 0 3
61401: PPUSH
61402: CALL_OW 297
61406: PUSH
61407: LD_INT 30
61409: LESS
61410: IFFALSE 61477
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61412: LD_ADDR_EXP 118
61416: PUSH
61417: LD_EXP 118
61421: PPUSH
61422: LD_VAR 0 7
61426: PUSH
61427: LD_EXP 118
61431: PUSH
61432: LD_VAR 0 7
61436: ARRAY
61437: PUSH
61438: LD_INT 1
61440: PLUS
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PPUSH
61446: LD_VAR 0 4
61450: PUSH
61451: LD_VAR 0 2
61455: PUSH
61456: LD_VAR 0 3
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: LIST
61465: PPUSH
61466: CALL 71983 0 3
61470: ST_TO_ADDR
// exit ;
61471: POP
61472: POP
61473: POP
61474: POP
61475: GO 61485
// end ;
61477: GO 61384
61479: POP
61480: POP
// end ;
61481: GO 61192
61483: POP
61484: POP
// end ;
61485: LD_VAR 0 6
61489: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61490: LD_INT 0
61492: PPUSH
61493: PPUSH
61494: PPUSH
61495: PPUSH
// if not mc_bases or not skirmish then
61496: LD_EXP 102
61500: NOT
61501: PUSH
61502: LD_EXP 100
61506: NOT
61507: OR
61508: IFFALSE 61512
// exit ;
61510: GO 61789
// side := GetSide ( lab ) ;
61512: LD_ADDR_VAR 0 4
61516: PUSH
61517: LD_VAR 0 2
61521: PPUSH
61522: CALL_OW 255
61526: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61527: LD_VAR 0 4
61531: PUSH
61532: LD_EXP 128
61536: IN
61537: NOT
61538: PUSH
61539: LD_EXP 129
61543: NOT
61544: OR
61545: PUSH
61546: LD_EXP 102
61550: NOT
61551: OR
61552: IFFALSE 61556
// exit ;
61554: GO 61789
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61556: LD_ADDR_EXP 129
61560: PUSH
61561: LD_EXP 129
61565: PPUSH
61566: LD_VAR 0 4
61570: PPUSH
61571: LD_EXP 129
61575: PUSH
61576: LD_VAR 0 4
61580: ARRAY
61581: PUSH
61582: LD_VAR 0 1
61586: DIFF
61587: PPUSH
61588: CALL_OW 1
61592: ST_TO_ADDR
// for i = 1 to mc_bases do
61593: LD_ADDR_VAR 0 5
61597: PUSH
61598: DOUBLE
61599: LD_INT 1
61601: DEC
61602: ST_TO_ADDR
61603: LD_EXP 102
61607: PUSH
61608: FOR_TO
61609: IFFALSE 61787
// begin if lab in mc_bases [ i ] then
61611: LD_VAR 0 2
61615: PUSH
61616: LD_EXP 102
61620: PUSH
61621: LD_VAR 0 5
61625: ARRAY
61626: IN
61627: IFFALSE 61785
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61629: LD_VAR 0 1
61633: PUSH
61634: LD_INT 11
61636: PUSH
61637: LD_INT 4
61639: PUSH
61640: LD_INT 3
61642: PUSH
61643: LD_INT 2
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: IN
61652: PUSH
61653: LD_EXP 132
61657: PUSH
61658: LD_VAR 0 5
61662: ARRAY
61663: AND
61664: IFFALSE 61785
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61666: LD_ADDR_VAR 0 6
61670: PUSH
61671: LD_EXP 132
61675: PUSH
61676: LD_VAR 0 5
61680: ARRAY
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61686: LD_ADDR_EXP 132
61690: PUSH
61691: LD_EXP 132
61695: PPUSH
61696: LD_VAR 0 5
61700: PPUSH
61701: EMPTY
61702: PPUSH
61703: CALL_OW 1
61707: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61708: LD_VAR 0 6
61712: PPUSH
61713: LD_INT 0
61715: PPUSH
61716: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61720: LD_VAR 0 6
61724: PPUSH
61725: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61729: LD_ADDR_EXP 131
61733: PUSH
61734: LD_EXP 131
61738: PPUSH
61739: LD_VAR 0 5
61743: PPUSH
61744: LD_EXP 131
61748: PUSH
61749: LD_VAR 0 5
61753: ARRAY
61754: PPUSH
61755: LD_INT 1
61757: PPUSH
61758: LD_VAR 0 6
61762: PPUSH
61763: CALL_OW 2
61767: PPUSH
61768: CALL_OW 1
61772: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61773: LD_VAR 0 5
61777: PPUSH
61778: LD_INT 112
61780: PPUSH
61781: CALL 38785 0 2
// end ; end ; end ;
61785: GO 61608
61787: POP
61788: POP
// end ;
61789: LD_VAR 0 3
61793: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61794: LD_INT 0
61796: PPUSH
61797: PPUSH
61798: PPUSH
61799: PPUSH
61800: PPUSH
61801: PPUSH
61802: PPUSH
61803: PPUSH
// if not mc_bases or not skirmish then
61804: LD_EXP 102
61808: NOT
61809: PUSH
61810: LD_EXP 100
61814: NOT
61815: OR
61816: IFFALSE 61820
// exit ;
61818: GO 63191
// for i = 1 to mc_bases do
61820: LD_ADDR_VAR 0 3
61824: PUSH
61825: DOUBLE
61826: LD_INT 1
61828: DEC
61829: ST_TO_ADDR
61830: LD_EXP 102
61834: PUSH
61835: FOR_TO
61836: IFFALSE 63189
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61838: LD_VAR 0 1
61842: PUSH
61843: LD_EXP 102
61847: PUSH
61848: LD_VAR 0 3
61852: ARRAY
61853: IN
61854: PUSH
61855: LD_VAR 0 1
61859: PUSH
61860: LD_EXP 109
61864: PUSH
61865: LD_VAR 0 3
61869: ARRAY
61870: IN
61871: OR
61872: PUSH
61873: LD_VAR 0 1
61877: PUSH
61878: LD_EXP 124
61882: PUSH
61883: LD_VAR 0 3
61887: ARRAY
61888: IN
61889: OR
61890: PUSH
61891: LD_VAR 0 1
61895: PUSH
61896: LD_EXP 121
61900: PUSH
61901: LD_VAR 0 3
61905: ARRAY
61906: IN
61907: OR
61908: PUSH
61909: LD_VAR 0 1
61913: PUSH
61914: LD_EXP 131
61918: PUSH
61919: LD_VAR 0 3
61923: ARRAY
61924: IN
61925: OR
61926: PUSH
61927: LD_VAR 0 1
61931: PUSH
61932: LD_EXP 132
61936: PUSH
61937: LD_VAR 0 3
61941: ARRAY
61942: IN
61943: OR
61944: IFFALSE 63187
// begin if un in mc_ape [ i ] then
61946: LD_VAR 0 1
61950: PUSH
61951: LD_EXP 131
61955: PUSH
61956: LD_VAR 0 3
61960: ARRAY
61961: IN
61962: IFFALSE 62001
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61964: LD_ADDR_EXP 131
61968: PUSH
61969: LD_EXP 131
61973: PPUSH
61974: LD_VAR 0 3
61978: PPUSH
61979: LD_EXP 131
61983: PUSH
61984: LD_VAR 0 3
61988: ARRAY
61989: PUSH
61990: LD_VAR 0 1
61994: DIFF
61995: PPUSH
61996: CALL_OW 1
62000: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62001: LD_VAR 0 1
62005: PUSH
62006: LD_EXP 132
62010: PUSH
62011: LD_VAR 0 3
62015: ARRAY
62016: IN
62017: IFFALSE 62041
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62019: LD_ADDR_EXP 132
62023: PUSH
62024: LD_EXP 132
62028: PPUSH
62029: LD_VAR 0 3
62033: PPUSH
62034: EMPTY
62035: PPUSH
62036: CALL_OW 1
62040: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62041: LD_VAR 0 1
62045: PPUSH
62046: CALL_OW 247
62050: PUSH
62051: LD_INT 2
62053: EQUAL
62054: PUSH
62055: LD_VAR 0 1
62059: PPUSH
62060: CALL_OW 110
62064: PUSH
62065: LD_INT 20
62067: EQUAL
62068: PUSH
62069: LD_VAR 0 1
62073: PUSH
62074: LD_EXP 124
62078: PUSH
62079: LD_VAR 0 3
62083: ARRAY
62084: IN
62085: OR
62086: PUSH
62087: LD_VAR 0 1
62091: PPUSH
62092: CALL_OW 264
62096: PUSH
62097: LD_INT 12
62099: PUSH
62100: LD_INT 51
62102: PUSH
62103: LD_EXP 96
62107: PUSH
62108: LD_INT 32
62110: PUSH
62111: LD_INT 13
62113: PUSH
62114: LD_INT 52
62116: PUSH
62117: LD_INT 31
62119: PUSH
62120: EMPTY
62121: LIST
62122: LIST
62123: LIST
62124: LIST
62125: LIST
62126: LIST
62127: LIST
62128: IN
62129: OR
62130: AND
62131: IFFALSE 62439
// begin if un in mc_defender [ i ] then
62133: LD_VAR 0 1
62137: PUSH
62138: LD_EXP 124
62142: PUSH
62143: LD_VAR 0 3
62147: ARRAY
62148: IN
62149: IFFALSE 62188
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62151: LD_ADDR_EXP 124
62155: PUSH
62156: LD_EXP 124
62160: PPUSH
62161: LD_VAR 0 3
62165: PPUSH
62166: LD_EXP 124
62170: PUSH
62171: LD_VAR 0 3
62175: ARRAY
62176: PUSH
62177: LD_VAR 0 1
62181: DIFF
62182: PPUSH
62183: CALL_OW 1
62187: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62188: LD_ADDR_VAR 0 8
62192: PUSH
62193: LD_VAR 0 3
62197: PPUSH
62198: LD_INT 3
62200: PPUSH
62201: CALL 58857 0 2
62205: ST_TO_ADDR
// if fac then
62206: LD_VAR 0 8
62210: IFFALSE 62439
// begin for j in fac do
62212: LD_ADDR_VAR 0 4
62216: PUSH
62217: LD_VAR 0 8
62221: PUSH
62222: FOR_IN
62223: IFFALSE 62437
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62225: LD_ADDR_VAR 0 9
62229: PUSH
62230: LD_VAR 0 8
62234: PPUSH
62235: LD_VAR 0 1
62239: PPUSH
62240: CALL_OW 265
62244: PPUSH
62245: LD_VAR 0 1
62249: PPUSH
62250: CALL_OW 262
62254: PPUSH
62255: LD_VAR 0 1
62259: PPUSH
62260: CALL_OW 263
62264: PPUSH
62265: LD_VAR 0 1
62269: PPUSH
62270: CALL_OW 264
62274: PPUSH
62275: CALL 69515 0 5
62279: ST_TO_ADDR
// if components then
62280: LD_VAR 0 9
62284: IFFALSE 62435
// begin if GetWeapon ( un ) = ar_control_tower then
62286: LD_VAR 0 1
62290: PPUSH
62291: CALL_OW 264
62295: PUSH
62296: LD_INT 31
62298: EQUAL
62299: IFFALSE 62416
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62301: LD_VAR 0 1
62305: PPUSH
62306: CALL_OW 311
62310: PPUSH
62311: LD_INT 0
62313: PPUSH
62314: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62318: LD_ADDR_EXP 142
62322: PUSH
62323: LD_EXP 142
62327: PPUSH
62328: LD_VAR 0 3
62332: PPUSH
62333: LD_EXP 142
62337: PUSH
62338: LD_VAR 0 3
62342: ARRAY
62343: PUSH
62344: LD_VAR 0 1
62348: PPUSH
62349: CALL_OW 311
62353: DIFF
62354: PPUSH
62355: CALL_OW 1
62359: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62360: LD_ADDR_VAR 0 7
62364: PUSH
62365: LD_EXP 123
62369: PUSH
62370: LD_VAR 0 3
62374: ARRAY
62375: PPUSH
62376: LD_INT 1
62378: PPUSH
62379: LD_VAR 0 9
62383: PPUSH
62384: CALL_OW 2
62388: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62389: LD_ADDR_EXP 123
62393: PUSH
62394: LD_EXP 123
62398: PPUSH
62399: LD_VAR 0 3
62403: PPUSH
62404: LD_VAR 0 7
62408: PPUSH
62409: CALL_OW 1
62413: ST_TO_ADDR
// end else
62414: GO 62433
// MC_InsertProduceList ( i , [ components ] ) ;
62416: LD_VAR 0 3
62420: PPUSH
62421: LD_VAR 0 9
62425: PUSH
62426: EMPTY
62427: LIST
62428: PPUSH
62429: CALL 58402 0 2
// break ;
62433: GO 62437
// end ; end ;
62435: GO 62222
62437: POP
62438: POP
// end ; end ; if GetType ( un ) = unit_building then
62439: LD_VAR 0 1
62443: PPUSH
62444: CALL_OW 247
62448: PUSH
62449: LD_INT 3
62451: EQUAL
62452: IFFALSE 62855
// begin btype := GetBType ( un ) ;
62454: LD_ADDR_VAR 0 5
62458: PUSH
62459: LD_VAR 0 1
62463: PPUSH
62464: CALL_OW 266
62468: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62469: LD_VAR 0 5
62473: PUSH
62474: LD_INT 29
62476: PUSH
62477: LD_INT 30
62479: PUSH
62480: EMPTY
62481: LIST
62482: LIST
62483: IN
62484: IFFALSE 62557
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62486: LD_VAR 0 1
62490: PPUSH
62491: CALL_OW 250
62495: PPUSH
62496: LD_VAR 0 1
62500: PPUSH
62501: CALL_OW 251
62505: PPUSH
62506: LD_VAR 0 1
62510: PPUSH
62511: CALL_OW 255
62515: PPUSH
62516: CALL_OW 440
62520: NOT
62521: IFFALSE 62557
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62523: LD_VAR 0 1
62527: PPUSH
62528: CALL_OW 250
62532: PPUSH
62533: LD_VAR 0 1
62537: PPUSH
62538: CALL_OW 251
62542: PPUSH
62543: LD_VAR 0 1
62547: PPUSH
62548: CALL_OW 255
62552: PPUSH
62553: CALL_OW 441
// end ; if btype = b_warehouse then
62557: LD_VAR 0 5
62561: PUSH
62562: LD_INT 1
62564: EQUAL
62565: IFFALSE 62583
// begin btype := b_depot ;
62567: LD_ADDR_VAR 0 5
62571: PUSH
62572: LD_INT 0
62574: ST_TO_ADDR
// pos := 1 ;
62575: LD_ADDR_VAR 0 6
62579: PUSH
62580: LD_INT 1
62582: ST_TO_ADDR
// end ; if btype = b_factory then
62583: LD_VAR 0 5
62587: PUSH
62588: LD_INT 3
62590: EQUAL
62591: IFFALSE 62609
// begin btype := b_workshop ;
62593: LD_ADDR_VAR 0 5
62597: PUSH
62598: LD_INT 2
62600: ST_TO_ADDR
// pos := 1 ;
62601: LD_ADDR_VAR 0 6
62605: PUSH
62606: LD_INT 1
62608: ST_TO_ADDR
// end ; if btype = b_barracks then
62609: LD_VAR 0 5
62613: PUSH
62614: LD_INT 5
62616: EQUAL
62617: IFFALSE 62627
// btype := b_armoury ;
62619: LD_ADDR_VAR 0 5
62623: PUSH
62624: LD_INT 4
62626: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62627: LD_VAR 0 5
62631: PUSH
62632: LD_INT 7
62634: PUSH
62635: LD_INT 8
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: IN
62642: IFFALSE 62652
// btype := b_lab ;
62644: LD_ADDR_VAR 0 5
62648: PUSH
62649: LD_INT 6
62651: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62652: LD_ADDR_EXP 107
62656: PUSH
62657: LD_EXP 107
62661: PPUSH
62662: LD_VAR 0 3
62666: PUSH
62667: LD_EXP 107
62671: PUSH
62672: LD_VAR 0 3
62676: ARRAY
62677: PUSH
62678: LD_INT 1
62680: PLUS
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: PPUSH
62686: LD_VAR 0 5
62690: PUSH
62691: LD_VAR 0 1
62695: PPUSH
62696: CALL_OW 250
62700: PUSH
62701: LD_VAR 0 1
62705: PPUSH
62706: CALL_OW 251
62710: PUSH
62711: LD_VAR 0 1
62715: PPUSH
62716: CALL_OW 254
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: PPUSH
62727: CALL 71983 0 3
62731: ST_TO_ADDR
// if pos = 1 then
62732: LD_VAR 0 6
62736: PUSH
62737: LD_INT 1
62739: EQUAL
62740: IFFALSE 62855
// begin tmp := mc_build_list [ i ] ;
62742: LD_ADDR_VAR 0 7
62746: PUSH
62747: LD_EXP 107
62751: PUSH
62752: LD_VAR 0 3
62756: ARRAY
62757: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62758: LD_VAR 0 7
62762: PPUSH
62763: LD_INT 2
62765: PUSH
62766: LD_INT 30
62768: PUSH
62769: LD_INT 0
62771: PUSH
62772: EMPTY
62773: LIST
62774: LIST
62775: PUSH
62776: LD_INT 30
62778: PUSH
62779: LD_INT 1
62781: PUSH
62782: EMPTY
62783: LIST
62784: LIST
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: LIST
62790: PPUSH
62791: CALL_OW 72
62795: IFFALSE 62805
// pos := 2 ;
62797: LD_ADDR_VAR 0 6
62801: PUSH
62802: LD_INT 2
62804: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62805: LD_ADDR_VAR 0 7
62809: PUSH
62810: LD_VAR 0 7
62814: PPUSH
62815: LD_VAR 0 6
62819: PPUSH
62820: LD_VAR 0 7
62824: PPUSH
62825: CALL 72309 0 3
62829: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62830: LD_ADDR_EXP 107
62834: PUSH
62835: LD_EXP 107
62839: PPUSH
62840: LD_VAR 0 3
62844: PPUSH
62845: LD_VAR 0 7
62849: PPUSH
62850: CALL_OW 1
62854: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62855: LD_VAR 0 1
62859: PUSH
62860: LD_EXP 102
62864: PUSH
62865: LD_VAR 0 3
62869: ARRAY
62870: IN
62871: IFFALSE 62910
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62873: LD_ADDR_EXP 102
62877: PUSH
62878: LD_EXP 102
62882: PPUSH
62883: LD_VAR 0 3
62887: PPUSH
62888: LD_EXP 102
62892: PUSH
62893: LD_VAR 0 3
62897: ARRAY
62898: PUSH
62899: LD_VAR 0 1
62903: DIFF
62904: PPUSH
62905: CALL_OW 1
62909: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62910: LD_VAR 0 1
62914: PUSH
62915: LD_EXP 109
62919: PUSH
62920: LD_VAR 0 3
62924: ARRAY
62925: IN
62926: IFFALSE 62965
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62928: LD_ADDR_EXP 109
62932: PUSH
62933: LD_EXP 109
62937: PPUSH
62938: LD_VAR 0 3
62942: PPUSH
62943: LD_EXP 109
62947: PUSH
62948: LD_VAR 0 3
62952: ARRAY
62953: PUSH
62954: LD_VAR 0 1
62958: DIFF
62959: PPUSH
62960: CALL_OW 1
62964: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62965: LD_VAR 0 1
62969: PUSH
62970: LD_EXP 121
62974: PUSH
62975: LD_VAR 0 3
62979: ARRAY
62980: IN
62981: IFFALSE 63020
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62983: LD_ADDR_EXP 121
62987: PUSH
62988: LD_EXP 121
62992: PPUSH
62993: LD_VAR 0 3
62997: PPUSH
62998: LD_EXP 121
63002: PUSH
63003: LD_VAR 0 3
63007: ARRAY
63008: PUSH
63009: LD_VAR 0 1
63013: DIFF
63014: PPUSH
63015: CALL_OW 1
63019: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63020: LD_VAR 0 1
63024: PUSH
63025: LD_EXP 124
63029: PUSH
63030: LD_VAR 0 3
63034: ARRAY
63035: IN
63036: IFFALSE 63075
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63038: LD_ADDR_EXP 124
63042: PUSH
63043: LD_EXP 124
63047: PPUSH
63048: LD_VAR 0 3
63052: PPUSH
63053: LD_EXP 124
63057: PUSH
63058: LD_VAR 0 3
63062: ARRAY
63063: PUSH
63064: LD_VAR 0 1
63068: DIFF
63069: PPUSH
63070: CALL_OW 1
63074: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63075: LD_VAR 0 1
63079: PUSH
63080: LD_EXP 111
63084: PUSH
63085: LD_VAR 0 3
63089: ARRAY
63090: IN
63091: IFFALSE 63130
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63093: LD_ADDR_EXP 111
63097: PUSH
63098: LD_EXP 111
63102: PPUSH
63103: LD_VAR 0 3
63107: PPUSH
63108: LD_EXP 111
63112: PUSH
63113: LD_VAR 0 3
63117: ARRAY
63118: PUSH
63119: LD_VAR 0 1
63123: DIFF
63124: PPUSH
63125: CALL_OW 1
63129: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63130: LD_VAR 0 1
63134: PUSH
63135: LD_EXP 110
63139: PUSH
63140: LD_VAR 0 3
63144: ARRAY
63145: IN
63146: IFFALSE 63185
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63148: LD_ADDR_EXP 110
63152: PUSH
63153: LD_EXP 110
63157: PPUSH
63158: LD_VAR 0 3
63162: PPUSH
63163: LD_EXP 110
63167: PUSH
63168: LD_VAR 0 3
63172: ARRAY
63173: PUSH
63174: LD_VAR 0 1
63178: DIFF
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// end ; break ;
63185: GO 63189
// end ;
63187: GO 61835
63189: POP
63190: POP
// end ;
63191: LD_VAR 0 2
63195: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63196: LD_INT 0
63198: PPUSH
63199: PPUSH
63200: PPUSH
// if not mc_bases or not skirmish then
63201: LD_EXP 102
63205: NOT
63206: PUSH
63207: LD_EXP 100
63211: NOT
63212: OR
63213: IFFALSE 63217
// exit ;
63215: GO 63432
// for i = 1 to mc_bases do
63217: LD_ADDR_VAR 0 3
63221: PUSH
63222: DOUBLE
63223: LD_INT 1
63225: DEC
63226: ST_TO_ADDR
63227: LD_EXP 102
63231: PUSH
63232: FOR_TO
63233: IFFALSE 63430
// begin if building in mc_construct_list [ i ] then
63235: LD_VAR 0 1
63239: PUSH
63240: LD_EXP 109
63244: PUSH
63245: LD_VAR 0 3
63249: ARRAY
63250: IN
63251: IFFALSE 63428
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63253: LD_ADDR_EXP 109
63257: PUSH
63258: LD_EXP 109
63262: PPUSH
63263: LD_VAR 0 3
63267: PPUSH
63268: LD_EXP 109
63272: PUSH
63273: LD_VAR 0 3
63277: ARRAY
63278: PUSH
63279: LD_VAR 0 1
63283: DIFF
63284: PPUSH
63285: CALL_OW 1
63289: ST_TO_ADDR
// if building in mc_lab [ i ] then
63290: LD_VAR 0 1
63294: PUSH
63295: LD_EXP 135
63299: PUSH
63300: LD_VAR 0 3
63304: ARRAY
63305: IN
63306: IFFALSE 63361
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63308: LD_ADDR_EXP 136
63312: PUSH
63313: LD_EXP 136
63317: PPUSH
63318: LD_VAR 0 3
63322: PPUSH
63323: LD_EXP 136
63327: PUSH
63328: LD_VAR 0 3
63332: ARRAY
63333: PPUSH
63334: LD_INT 1
63336: PPUSH
63337: LD_EXP 136
63341: PUSH
63342: LD_VAR 0 3
63346: ARRAY
63347: PPUSH
63348: LD_INT 0
63350: PPUSH
63351: CALL 71401 0 4
63355: PPUSH
63356: CALL_OW 1
63360: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63361: LD_VAR 0 1
63365: PUSH
63366: LD_EXP 102
63370: PUSH
63371: LD_VAR 0 3
63375: ARRAY
63376: IN
63377: NOT
63378: IFFALSE 63424
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63380: LD_ADDR_EXP 102
63384: PUSH
63385: LD_EXP 102
63389: PPUSH
63390: LD_VAR 0 3
63394: PUSH
63395: LD_EXP 102
63399: PUSH
63400: LD_VAR 0 3
63404: ARRAY
63405: PUSH
63406: LD_INT 1
63408: PLUS
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: PPUSH
63414: LD_VAR 0 1
63418: PPUSH
63419: CALL 71983 0 3
63423: ST_TO_ADDR
// exit ;
63424: POP
63425: POP
63426: GO 63432
// end ; end ;
63428: GO 63232
63430: POP
63431: POP
// end ;
63432: LD_VAR 0 2
63436: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63437: LD_INT 0
63439: PPUSH
63440: PPUSH
63441: PPUSH
63442: PPUSH
63443: PPUSH
63444: PPUSH
63445: PPUSH
// if not mc_bases or not skirmish then
63446: LD_EXP 102
63450: NOT
63451: PUSH
63452: LD_EXP 100
63456: NOT
63457: OR
63458: IFFALSE 63462
// exit ;
63460: GO 64123
// for i = 1 to mc_bases do
63462: LD_ADDR_VAR 0 3
63466: PUSH
63467: DOUBLE
63468: LD_INT 1
63470: DEC
63471: ST_TO_ADDR
63472: LD_EXP 102
63476: PUSH
63477: FOR_TO
63478: IFFALSE 64121
// begin if building in mc_construct_list [ i ] then
63480: LD_VAR 0 1
63484: PUSH
63485: LD_EXP 109
63489: PUSH
63490: LD_VAR 0 3
63494: ARRAY
63495: IN
63496: IFFALSE 64119
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63498: LD_ADDR_EXP 109
63502: PUSH
63503: LD_EXP 109
63507: PPUSH
63508: LD_VAR 0 3
63512: PPUSH
63513: LD_EXP 109
63517: PUSH
63518: LD_VAR 0 3
63522: ARRAY
63523: PUSH
63524: LD_VAR 0 1
63528: DIFF
63529: PPUSH
63530: CALL_OW 1
63534: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63535: LD_ADDR_EXP 102
63539: PUSH
63540: LD_EXP 102
63544: PPUSH
63545: LD_VAR 0 3
63549: PUSH
63550: LD_EXP 102
63554: PUSH
63555: LD_VAR 0 3
63559: ARRAY
63560: PUSH
63561: LD_INT 1
63563: PLUS
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PPUSH
63569: LD_VAR 0 1
63573: PPUSH
63574: CALL 71983 0 3
63578: ST_TO_ADDR
// btype := GetBType ( building ) ;
63579: LD_ADDR_VAR 0 5
63583: PUSH
63584: LD_VAR 0 1
63588: PPUSH
63589: CALL_OW 266
63593: ST_TO_ADDR
// side := GetSide ( building ) ;
63594: LD_ADDR_VAR 0 8
63598: PUSH
63599: LD_VAR 0 1
63603: PPUSH
63604: CALL_OW 255
63608: ST_TO_ADDR
// if btype = b_lab then
63609: LD_VAR 0 5
63613: PUSH
63614: LD_INT 6
63616: EQUAL
63617: IFFALSE 63667
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63619: LD_ADDR_EXP 135
63623: PUSH
63624: LD_EXP 135
63628: PPUSH
63629: LD_VAR 0 3
63633: PUSH
63634: LD_EXP 135
63638: PUSH
63639: LD_VAR 0 3
63643: ARRAY
63644: PUSH
63645: LD_INT 1
63647: PLUS
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: PPUSH
63653: LD_VAR 0 1
63657: PPUSH
63658: CALL 71983 0 3
63662: ST_TO_ADDR
// exit ;
63663: POP
63664: POP
63665: GO 64123
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63667: LD_VAR 0 5
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: LD_INT 2
63677: PUSH
63678: LD_INT 4
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: LIST
63685: IN
63686: IFFALSE 63810
// begin if btype = b_armoury then
63688: LD_VAR 0 5
63692: PUSH
63693: LD_INT 4
63695: EQUAL
63696: IFFALSE 63706
// btype := b_barracks ;
63698: LD_ADDR_VAR 0 5
63702: PUSH
63703: LD_INT 5
63705: ST_TO_ADDR
// if btype = b_depot then
63706: LD_VAR 0 5
63710: PUSH
63711: LD_INT 0
63713: EQUAL
63714: IFFALSE 63724
// btype := b_warehouse ;
63716: LD_ADDR_VAR 0 5
63720: PUSH
63721: LD_INT 1
63723: ST_TO_ADDR
// if btype = b_workshop then
63724: LD_VAR 0 5
63728: PUSH
63729: LD_INT 2
63731: EQUAL
63732: IFFALSE 63742
// btype := b_factory ;
63734: LD_ADDR_VAR 0 5
63738: PUSH
63739: LD_INT 3
63741: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63742: LD_VAR 0 5
63746: PPUSH
63747: LD_VAR 0 8
63751: PPUSH
63752: CALL_OW 323
63756: PUSH
63757: LD_INT 1
63759: EQUAL
63760: IFFALSE 63806
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63762: LD_ADDR_EXP 134
63766: PUSH
63767: LD_EXP 134
63771: PPUSH
63772: LD_VAR 0 3
63776: PUSH
63777: LD_EXP 134
63781: PUSH
63782: LD_VAR 0 3
63786: ARRAY
63787: PUSH
63788: LD_INT 1
63790: PLUS
63791: PUSH
63792: EMPTY
63793: LIST
63794: LIST
63795: PPUSH
63796: LD_VAR 0 1
63800: PPUSH
63801: CALL 71983 0 3
63805: ST_TO_ADDR
// exit ;
63806: POP
63807: POP
63808: GO 64123
// end ; if btype in [ b_bunker , b_turret ] then
63810: LD_VAR 0 5
63814: PUSH
63815: LD_INT 32
63817: PUSH
63818: LD_INT 33
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: IN
63825: IFFALSE 64115
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63827: LD_ADDR_EXP 110
63831: PUSH
63832: LD_EXP 110
63836: PPUSH
63837: LD_VAR 0 3
63841: PUSH
63842: LD_EXP 110
63846: PUSH
63847: LD_VAR 0 3
63851: ARRAY
63852: PUSH
63853: LD_INT 1
63855: PLUS
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PPUSH
63861: LD_VAR 0 1
63865: PPUSH
63866: CALL 71983 0 3
63870: ST_TO_ADDR
// if btype = b_bunker then
63871: LD_VAR 0 5
63875: PUSH
63876: LD_INT 32
63878: EQUAL
63879: IFFALSE 64115
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63881: LD_ADDR_EXP 111
63885: PUSH
63886: LD_EXP 111
63890: PPUSH
63891: LD_VAR 0 3
63895: PUSH
63896: LD_EXP 111
63900: PUSH
63901: LD_VAR 0 3
63905: ARRAY
63906: PUSH
63907: LD_INT 1
63909: PLUS
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PPUSH
63915: LD_VAR 0 1
63919: PPUSH
63920: CALL 71983 0 3
63924: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63925: LD_ADDR_VAR 0 6
63929: PUSH
63930: LD_EXP 102
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: PPUSH
63941: LD_INT 25
63943: PUSH
63944: LD_INT 1
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 3
63953: PUSH
63954: LD_INT 54
63956: PUSH
63957: EMPTY
63958: LIST
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PPUSH
63968: CALL_OW 72
63972: ST_TO_ADDR
// if tmp then
63973: LD_VAR 0 6
63977: IFFALSE 63983
// exit ;
63979: POP
63980: POP
63981: GO 64123
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63983: LD_ADDR_VAR 0 6
63987: PUSH
63988: LD_EXP 102
63992: PUSH
63993: LD_VAR 0 3
63997: ARRAY
63998: PPUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 4
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 30
64014: PUSH
64015: LD_INT 5
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: LIST
64026: PPUSH
64027: CALL_OW 72
64031: ST_TO_ADDR
// if not tmp then
64032: LD_VAR 0 6
64036: NOT
64037: IFFALSE 64043
// exit ;
64039: POP
64040: POP
64041: GO 64123
// for j in tmp do
64043: LD_ADDR_VAR 0 4
64047: PUSH
64048: LD_VAR 0 6
64052: PUSH
64053: FOR_IN
64054: IFFALSE 64113
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64056: LD_ADDR_VAR 0 7
64060: PUSH
64061: LD_VAR 0 4
64065: PPUSH
64066: CALL_OW 313
64070: PPUSH
64071: LD_INT 25
64073: PUSH
64074: LD_INT 1
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: PPUSH
64081: CALL_OW 72
64085: ST_TO_ADDR
// if units then
64086: LD_VAR 0 7
64090: IFFALSE 64111
// begin ComExitBuilding ( units [ 1 ] ) ;
64092: LD_VAR 0 7
64096: PUSH
64097: LD_INT 1
64099: ARRAY
64100: PPUSH
64101: CALL_OW 122
// exit ;
64105: POP
64106: POP
64107: POP
64108: POP
64109: GO 64123
// end ; end ;
64111: GO 64053
64113: POP
64114: POP
// end ; end ; exit ;
64115: POP
64116: POP
64117: GO 64123
// end ; end ;
64119: GO 63477
64121: POP
64122: POP
// end ;
64123: LD_VAR 0 2
64127: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64128: LD_INT 0
64130: PPUSH
64131: PPUSH
64132: PPUSH
64133: PPUSH
64134: PPUSH
64135: PPUSH
64136: PPUSH
// if not mc_bases or not skirmish then
64137: LD_EXP 102
64141: NOT
64142: PUSH
64143: LD_EXP 100
64147: NOT
64148: OR
64149: IFFALSE 64153
// exit ;
64151: GO 64384
// btype := GetBType ( building ) ;
64153: LD_ADDR_VAR 0 6
64157: PUSH
64158: LD_VAR 0 1
64162: PPUSH
64163: CALL_OW 266
64167: ST_TO_ADDR
// x := GetX ( building ) ;
64168: LD_ADDR_VAR 0 7
64172: PUSH
64173: LD_VAR 0 1
64177: PPUSH
64178: CALL_OW 250
64182: ST_TO_ADDR
// y := GetY ( building ) ;
64183: LD_ADDR_VAR 0 8
64187: PUSH
64188: LD_VAR 0 1
64192: PPUSH
64193: CALL_OW 251
64197: ST_TO_ADDR
// d := GetDir ( building ) ;
64198: LD_ADDR_VAR 0 9
64202: PUSH
64203: LD_VAR 0 1
64207: PPUSH
64208: CALL_OW 254
64212: ST_TO_ADDR
// for i = 1 to mc_bases do
64213: LD_ADDR_VAR 0 4
64217: PUSH
64218: DOUBLE
64219: LD_INT 1
64221: DEC
64222: ST_TO_ADDR
64223: LD_EXP 102
64227: PUSH
64228: FOR_TO
64229: IFFALSE 64382
// begin if not mc_build_list [ i ] then
64231: LD_EXP 107
64235: PUSH
64236: LD_VAR 0 4
64240: ARRAY
64241: NOT
64242: IFFALSE 64246
// continue ;
64244: GO 64228
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64246: LD_VAR 0 6
64250: PUSH
64251: LD_VAR 0 7
64255: PUSH
64256: LD_VAR 0 8
64260: PUSH
64261: LD_VAR 0 9
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: LIST
64270: LIST
64271: PPUSH
64272: LD_EXP 107
64276: PUSH
64277: LD_VAR 0 4
64281: ARRAY
64282: PUSH
64283: LD_INT 1
64285: ARRAY
64286: PPUSH
64287: CALL 78152 0 2
64291: IFFALSE 64380
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64293: LD_ADDR_EXP 107
64297: PUSH
64298: LD_EXP 107
64302: PPUSH
64303: LD_VAR 0 4
64307: PPUSH
64308: LD_EXP 107
64312: PUSH
64313: LD_VAR 0 4
64317: ARRAY
64318: PPUSH
64319: LD_INT 1
64321: PPUSH
64322: CALL_OW 3
64326: PPUSH
64327: CALL_OW 1
64331: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64332: LD_ADDR_EXP 109
64336: PUSH
64337: LD_EXP 109
64341: PPUSH
64342: LD_VAR 0 4
64346: PUSH
64347: LD_EXP 109
64351: PUSH
64352: LD_VAR 0 4
64356: ARRAY
64357: PUSH
64358: LD_INT 1
64360: PLUS
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PPUSH
64366: LD_VAR 0 1
64370: PPUSH
64371: CALL 71983 0 3
64375: ST_TO_ADDR
// exit ;
64376: POP
64377: POP
64378: GO 64384
// end ; end ;
64380: GO 64228
64382: POP
64383: POP
// end ;
64384: LD_VAR 0 3
64388: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64389: LD_INT 0
64391: PPUSH
64392: PPUSH
64393: PPUSH
// if not mc_bases or not skirmish then
64394: LD_EXP 102
64398: NOT
64399: PUSH
64400: LD_EXP 100
64404: NOT
64405: OR
64406: IFFALSE 64410
// exit ;
64408: GO 64600
// for i = 1 to mc_bases do
64410: LD_ADDR_VAR 0 4
64414: PUSH
64415: DOUBLE
64416: LD_INT 1
64418: DEC
64419: ST_TO_ADDR
64420: LD_EXP 102
64424: PUSH
64425: FOR_TO
64426: IFFALSE 64513
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64428: LD_VAR 0 1
64432: PUSH
64433: LD_EXP 110
64437: PUSH
64438: LD_VAR 0 4
64442: ARRAY
64443: IN
64444: PUSH
64445: LD_VAR 0 1
64449: PUSH
64450: LD_EXP 111
64454: PUSH
64455: LD_VAR 0 4
64459: ARRAY
64460: IN
64461: NOT
64462: AND
64463: IFFALSE 64511
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64465: LD_ADDR_EXP 111
64469: PUSH
64470: LD_EXP 111
64474: PPUSH
64475: LD_VAR 0 4
64479: PUSH
64480: LD_EXP 111
64484: PUSH
64485: LD_VAR 0 4
64489: ARRAY
64490: PUSH
64491: LD_INT 1
64493: PLUS
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PPUSH
64499: LD_VAR 0 1
64503: PPUSH
64504: CALL 71983 0 3
64508: ST_TO_ADDR
// break ;
64509: GO 64513
// end ; end ;
64511: GO 64425
64513: POP
64514: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64515: LD_VAR 0 1
64519: PPUSH
64520: CALL_OW 257
64524: PUSH
64525: LD_EXP 128
64529: IN
64530: PUSH
64531: LD_VAR 0 1
64535: PPUSH
64536: CALL_OW 266
64540: PUSH
64541: LD_INT 5
64543: EQUAL
64544: AND
64545: PUSH
64546: LD_VAR 0 2
64550: PPUSH
64551: CALL_OW 110
64555: PUSH
64556: LD_INT 18
64558: NONEQUAL
64559: AND
64560: IFFALSE 64600
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64562: LD_VAR 0 2
64566: PPUSH
64567: CALL_OW 257
64571: PUSH
64572: LD_INT 5
64574: PUSH
64575: LD_INT 8
64577: PUSH
64578: LD_INT 9
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: LIST
64585: IN
64586: IFFALSE 64600
// SetClass ( unit , 1 ) ;
64588: LD_VAR 0 2
64592: PPUSH
64593: LD_INT 1
64595: PPUSH
64596: CALL_OW 336
// end ;
64600: LD_VAR 0 3
64604: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64605: LD_INT 0
64607: PPUSH
64608: PPUSH
// if not mc_bases or not skirmish then
64609: LD_EXP 102
64613: NOT
64614: PUSH
64615: LD_EXP 100
64619: NOT
64620: OR
64621: IFFALSE 64625
// exit ;
64623: GO 64741
// if GetLives ( abandoned_vehicle ) > 250 then
64625: LD_VAR 0 2
64629: PPUSH
64630: CALL_OW 256
64634: PUSH
64635: LD_INT 250
64637: GREATER
64638: IFFALSE 64642
// exit ;
64640: GO 64741
// for i = 1 to mc_bases do
64642: LD_ADDR_VAR 0 6
64646: PUSH
64647: DOUBLE
64648: LD_INT 1
64650: DEC
64651: ST_TO_ADDR
64652: LD_EXP 102
64656: PUSH
64657: FOR_TO
64658: IFFALSE 64739
// begin if driver in mc_bases [ i ] then
64660: LD_VAR 0 1
64664: PUSH
64665: LD_EXP 102
64669: PUSH
64670: LD_VAR 0 6
64674: ARRAY
64675: IN
64676: IFFALSE 64737
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64678: LD_VAR 0 1
64682: PPUSH
64683: LD_EXP 102
64687: PUSH
64688: LD_VAR 0 6
64692: ARRAY
64693: PPUSH
64694: LD_INT 2
64696: PUSH
64697: LD_INT 30
64699: PUSH
64700: LD_INT 0
64702: PUSH
64703: EMPTY
64704: LIST
64705: LIST
64706: PUSH
64707: LD_INT 30
64709: PUSH
64710: LD_INT 1
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: LIST
64721: PPUSH
64722: CALL_OW 72
64726: PUSH
64727: LD_INT 1
64729: ARRAY
64730: PPUSH
64731: CALL_OW 112
// break ;
64735: GO 64739
// end ; end ;
64737: GO 64657
64739: POP
64740: POP
// end ; end_of_file
64741: LD_VAR 0 5
64745: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64746: LD_INT 0
64748: PPUSH
64749: PPUSH
// if exist_mode then
64750: LD_VAR 0 2
64754: IFFALSE 64779
// unit := CreateCharacter ( prefix & ident ) else
64756: LD_ADDR_VAR 0 5
64760: PUSH
64761: LD_VAR 0 3
64765: PUSH
64766: LD_VAR 0 1
64770: STR
64771: PPUSH
64772: CALL_OW 34
64776: ST_TO_ADDR
64777: GO 64794
// unit := NewCharacter ( ident ) ;
64779: LD_ADDR_VAR 0 5
64783: PUSH
64784: LD_VAR 0 1
64788: PPUSH
64789: CALL_OW 25
64793: ST_TO_ADDR
// result := unit ;
64794: LD_ADDR_VAR 0 4
64798: PUSH
64799: LD_VAR 0 5
64803: ST_TO_ADDR
// end ;
64804: LD_VAR 0 4
64808: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64809: LD_INT 0
64811: PPUSH
64812: PPUSH
// if not side or not nation then
64813: LD_VAR 0 1
64817: NOT
64818: PUSH
64819: LD_VAR 0 2
64823: NOT
64824: OR
64825: IFFALSE 64829
// exit ;
64827: GO 65473
// case nation of nation_american :
64829: LD_VAR 0 2
64833: PUSH
64834: LD_INT 1
64836: DOUBLE
64837: EQUAL
64838: IFTRUE 64842
64840: GO 65016
64842: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64843: LD_ADDR_VAR 0 4
64847: PUSH
64848: LD_INT 35
64850: PUSH
64851: LD_INT 45
64853: PUSH
64854: LD_INT 46
64856: PUSH
64857: LD_INT 47
64859: PUSH
64860: LD_INT 1
64862: PUSH
64863: LD_INT 2
64865: PUSH
64866: LD_INT 6
64868: PUSH
64869: LD_INT 15
64871: PUSH
64872: LD_INT 16
64874: PUSH
64875: LD_INT 7
64877: PUSH
64878: LD_INT 12
64880: PUSH
64881: LD_INT 13
64883: PUSH
64884: LD_INT 10
64886: PUSH
64887: LD_INT 14
64889: PUSH
64890: LD_INT 20
64892: PUSH
64893: LD_INT 21
64895: PUSH
64896: LD_INT 22
64898: PUSH
64899: LD_INT 25
64901: PUSH
64902: LD_INT 32
64904: PUSH
64905: LD_INT 27
64907: PUSH
64908: LD_INT 36
64910: PUSH
64911: LD_INT 69
64913: PUSH
64914: LD_INT 39
64916: PUSH
64917: LD_INT 34
64919: PUSH
64920: LD_INT 40
64922: PUSH
64923: LD_INT 48
64925: PUSH
64926: LD_INT 49
64928: PUSH
64929: LD_INT 50
64931: PUSH
64932: LD_INT 51
64934: PUSH
64935: LD_INT 52
64937: PUSH
64938: LD_INT 53
64940: PUSH
64941: LD_INT 54
64943: PUSH
64944: LD_INT 55
64946: PUSH
64947: LD_INT 56
64949: PUSH
64950: LD_INT 57
64952: PUSH
64953: LD_INT 58
64955: PUSH
64956: LD_INT 59
64958: PUSH
64959: LD_INT 60
64961: PUSH
64962: LD_INT 61
64964: PUSH
64965: LD_INT 62
64967: PUSH
64968: LD_INT 80
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: ST_TO_ADDR
65014: GO 65397
65016: LD_INT 2
65018: DOUBLE
65019: EQUAL
65020: IFTRUE 65024
65022: GO 65206
65024: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65025: LD_ADDR_VAR 0 4
65029: PUSH
65030: LD_INT 35
65032: PUSH
65033: LD_INT 45
65035: PUSH
65036: LD_INT 46
65038: PUSH
65039: LD_INT 47
65041: PUSH
65042: LD_INT 70
65044: PUSH
65045: LD_INT 1
65047: PUSH
65048: LD_INT 11
65050: PUSH
65051: LD_INT 3
65053: PUSH
65054: LD_INT 4
65056: PUSH
65057: LD_INT 5
65059: PUSH
65060: LD_INT 6
65062: PUSH
65063: LD_INT 15
65065: PUSH
65066: LD_INT 18
65068: PUSH
65069: LD_INT 7
65071: PUSH
65072: LD_INT 17
65074: PUSH
65075: LD_INT 8
65077: PUSH
65078: LD_INT 20
65080: PUSH
65081: LD_INT 21
65083: PUSH
65084: LD_INT 22
65086: PUSH
65087: LD_INT 72
65089: PUSH
65090: LD_INT 26
65092: PUSH
65093: LD_INT 69
65095: PUSH
65096: LD_INT 39
65098: PUSH
65099: LD_INT 40
65101: PUSH
65102: LD_INT 41
65104: PUSH
65105: LD_INT 42
65107: PUSH
65108: LD_INT 43
65110: PUSH
65111: LD_INT 48
65113: PUSH
65114: LD_INT 49
65116: PUSH
65117: LD_INT 50
65119: PUSH
65120: LD_INT 51
65122: PUSH
65123: LD_INT 52
65125: PUSH
65126: LD_INT 53
65128: PUSH
65129: LD_INT 54
65131: PUSH
65132: LD_INT 55
65134: PUSH
65135: LD_INT 56
65137: PUSH
65138: LD_INT 60
65140: PUSH
65141: LD_INT 61
65143: PUSH
65144: LD_INT 62
65146: PUSH
65147: LD_INT 66
65149: PUSH
65150: LD_INT 67
65152: PUSH
65153: LD_INT 68
65155: PUSH
65156: LD_INT 81
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: LIST
65185: LIST
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: ST_TO_ADDR
65204: GO 65397
65206: LD_INT 3
65208: DOUBLE
65209: EQUAL
65210: IFTRUE 65214
65212: GO 65396
65214: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65215: LD_ADDR_VAR 0 4
65219: PUSH
65220: LD_INT 46
65222: PUSH
65223: LD_INT 47
65225: PUSH
65226: LD_INT 1
65228: PUSH
65229: LD_INT 2
65231: PUSH
65232: LD_INT 11
65234: PUSH
65235: LD_INT 9
65237: PUSH
65238: LD_INT 20
65240: PUSH
65241: LD_INT 19
65243: PUSH
65244: LD_INT 21
65246: PUSH
65247: LD_INT 24
65249: PUSH
65250: LD_INT 22
65252: PUSH
65253: LD_INT 25
65255: PUSH
65256: LD_INT 28
65258: PUSH
65259: LD_INT 29
65261: PUSH
65262: LD_INT 30
65264: PUSH
65265: LD_INT 31
65267: PUSH
65268: LD_INT 37
65270: PUSH
65271: LD_INT 38
65273: PUSH
65274: LD_INT 32
65276: PUSH
65277: LD_INT 27
65279: PUSH
65280: LD_INT 33
65282: PUSH
65283: LD_INT 69
65285: PUSH
65286: LD_INT 39
65288: PUSH
65289: LD_INT 34
65291: PUSH
65292: LD_INT 40
65294: PUSH
65295: LD_INT 71
65297: PUSH
65298: LD_INT 23
65300: PUSH
65301: LD_INT 44
65303: PUSH
65304: LD_INT 48
65306: PUSH
65307: LD_INT 49
65309: PUSH
65310: LD_INT 50
65312: PUSH
65313: LD_INT 51
65315: PUSH
65316: LD_INT 52
65318: PUSH
65319: LD_INT 53
65321: PUSH
65322: LD_INT 54
65324: PUSH
65325: LD_INT 55
65327: PUSH
65328: LD_INT 56
65330: PUSH
65331: LD_INT 57
65333: PUSH
65334: LD_INT 58
65336: PUSH
65337: LD_INT 59
65339: PUSH
65340: LD_INT 63
65342: PUSH
65343: LD_INT 64
65345: PUSH
65346: LD_INT 65
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: ST_TO_ADDR
65394: GO 65397
65396: POP
// if state > - 1 and state < 3 then
65397: LD_VAR 0 3
65401: PUSH
65402: LD_INT 1
65404: NEG
65405: GREATER
65406: PUSH
65407: LD_VAR 0 3
65411: PUSH
65412: LD_INT 3
65414: LESS
65415: AND
65416: IFFALSE 65473
// for i in result do
65418: LD_ADDR_VAR 0 5
65422: PUSH
65423: LD_VAR 0 4
65427: PUSH
65428: FOR_IN
65429: IFFALSE 65471
// if GetTech ( i , side ) <> state then
65431: LD_VAR 0 5
65435: PPUSH
65436: LD_VAR 0 1
65440: PPUSH
65441: CALL_OW 321
65445: PUSH
65446: LD_VAR 0 3
65450: NONEQUAL
65451: IFFALSE 65469
// result := result diff i ;
65453: LD_ADDR_VAR 0 4
65457: PUSH
65458: LD_VAR 0 4
65462: PUSH
65463: LD_VAR 0 5
65467: DIFF
65468: ST_TO_ADDR
65469: GO 65428
65471: POP
65472: POP
// end ;
65473: LD_VAR 0 4
65477: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65478: LD_INT 0
65480: PPUSH
65481: PPUSH
65482: PPUSH
// result := true ;
65483: LD_ADDR_VAR 0 3
65487: PUSH
65488: LD_INT 1
65490: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65491: LD_ADDR_VAR 0 5
65495: PUSH
65496: LD_VAR 0 2
65500: PPUSH
65501: CALL_OW 480
65505: ST_TO_ADDR
// if not tmp then
65506: LD_VAR 0 5
65510: NOT
65511: IFFALSE 65515
// exit ;
65513: GO 65564
// for i in tmp do
65515: LD_ADDR_VAR 0 4
65519: PUSH
65520: LD_VAR 0 5
65524: PUSH
65525: FOR_IN
65526: IFFALSE 65562
// if GetTech ( i , side ) <> state_researched then
65528: LD_VAR 0 4
65532: PPUSH
65533: LD_VAR 0 1
65537: PPUSH
65538: CALL_OW 321
65542: PUSH
65543: LD_INT 2
65545: NONEQUAL
65546: IFFALSE 65560
// begin result := false ;
65548: LD_ADDR_VAR 0 3
65552: PUSH
65553: LD_INT 0
65555: ST_TO_ADDR
// exit ;
65556: POP
65557: POP
65558: GO 65564
// end ;
65560: GO 65525
65562: POP
65563: POP
// end ;
65564: LD_VAR 0 3
65568: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65569: LD_INT 0
65571: PPUSH
65572: PPUSH
65573: PPUSH
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
65579: PPUSH
65580: PPUSH
65581: PPUSH
65582: PPUSH
65583: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65584: LD_VAR 0 1
65588: NOT
65589: PUSH
65590: LD_VAR 0 1
65594: PPUSH
65595: CALL_OW 257
65599: PUSH
65600: LD_INT 9
65602: NONEQUAL
65603: OR
65604: IFFALSE 65608
// exit ;
65606: GO 66181
// side := GetSide ( unit ) ;
65608: LD_ADDR_VAR 0 9
65612: PUSH
65613: LD_VAR 0 1
65617: PPUSH
65618: CALL_OW 255
65622: ST_TO_ADDR
// tech_space := tech_spacanom ;
65623: LD_ADDR_VAR 0 12
65627: PUSH
65628: LD_INT 29
65630: ST_TO_ADDR
// tech_time := tech_taurad ;
65631: LD_ADDR_VAR 0 13
65635: PUSH
65636: LD_INT 28
65638: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65639: LD_ADDR_VAR 0 11
65643: PUSH
65644: LD_VAR 0 1
65648: PPUSH
65649: CALL_OW 310
65653: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65654: LD_VAR 0 11
65658: PPUSH
65659: CALL_OW 247
65663: PUSH
65664: LD_INT 2
65666: EQUAL
65667: IFFALSE 65671
// exit ;
65669: GO 66181
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65671: LD_ADDR_VAR 0 8
65675: PUSH
65676: LD_INT 81
65678: PUSH
65679: LD_VAR 0 9
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: LD_INT 3
65690: PUSH
65691: LD_INT 21
65693: PUSH
65694: LD_INT 3
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PPUSH
65709: CALL_OW 69
65713: ST_TO_ADDR
// if not tmp then
65714: LD_VAR 0 8
65718: NOT
65719: IFFALSE 65723
// exit ;
65721: GO 66181
// if in_unit then
65723: LD_VAR 0 11
65727: IFFALSE 65751
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65729: LD_ADDR_VAR 0 10
65733: PUSH
65734: LD_VAR 0 8
65738: PPUSH
65739: LD_VAR 0 11
65743: PPUSH
65744: CALL_OW 74
65748: ST_TO_ADDR
65749: GO 65771
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65751: LD_ADDR_VAR 0 10
65755: PUSH
65756: LD_VAR 0 8
65760: PPUSH
65761: LD_VAR 0 1
65765: PPUSH
65766: CALL_OW 74
65770: ST_TO_ADDR
// if not enemy then
65771: LD_VAR 0 10
65775: NOT
65776: IFFALSE 65780
// exit ;
65778: GO 66181
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65780: LD_VAR 0 11
65784: PUSH
65785: LD_VAR 0 11
65789: PPUSH
65790: LD_VAR 0 10
65794: PPUSH
65795: CALL_OW 296
65799: PUSH
65800: LD_INT 13
65802: GREATER
65803: AND
65804: PUSH
65805: LD_VAR 0 1
65809: PPUSH
65810: LD_VAR 0 10
65814: PPUSH
65815: CALL_OW 296
65819: PUSH
65820: LD_INT 12
65822: GREATER
65823: OR
65824: IFFALSE 65828
// exit ;
65826: GO 66181
// missile := [ 1 ] ;
65828: LD_ADDR_VAR 0 14
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: EMPTY
65837: LIST
65838: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65839: LD_VAR 0 9
65843: PPUSH
65844: LD_VAR 0 12
65848: PPUSH
65849: CALL_OW 325
65853: IFFALSE 65882
// missile := Insert ( missile , missile + 1 , 2 ) ;
65855: LD_ADDR_VAR 0 14
65859: PUSH
65860: LD_VAR 0 14
65864: PPUSH
65865: LD_VAR 0 14
65869: PUSH
65870: LD_INT 1
65872: PLUS
65873: PPUSH
65874: LD_INT 2
65876: PPUSH
65877: CALL_OW 2
65881: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65882: LD_VAR 0 9
65886: PPUSH
65887: LD_VAR 0 13
65891: PPUSH
65892: CALL_OW 325
65896: PUSH
65897: LD_VAR 0 10
65901: PPUSH
65902: CALL_OW 255
65906: PPUSH
65907: LD_VAR 0 13
65911: PPUSH
65912: CALL_OW 325
65916: NOT
65917: AND
65918: IFFALSE 65947
// missile := Insert ( missile , missile + 1 , 3 ) ;
65920: LD_ADDR_VAR 0 14
65924: PUSH
65925: LD_VAR 0 14
65929: PPUSH
65930: LD_VAR 0 14
65934: PUSH
65935: LD_INT 1
65937: PLUS
65938: PPUSH
65939: LD_INT 3
65941: PPUSH
65942: CALL_OW 2
65946: ST_TO_ADDR
// if missile < 2 then
65947: LD_VAR 0 14
65951: PUSH
65952: LD_INT 2
65954: LESS
65955: IFFALSE 65959
// exit ;
65957: GO 66181
// x := GetX ( enemy ) ;
65959: LD_ADDR_VAR 0 4
65963: PUSH
65964: LD_VAR 0 10
65968: PPUSH
65969: CALL_OW 250
65973: ST_TO_ADDR
// y := GetY ( enemy ) ;
65974: LD_ADDR_VAR 0 5
65978: PUSH
65979: LD_VAR 0 10
65983: PPUSH
65984: CALL_OW 251
65988: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65989: LD_ADDR_VAR 0 6
65993: PUSH
65994: LD_VAR 0 4
65998: PUSH
65999: LD_INT 1
66001: NEG
66002: PPUSH
66003: LD_INT 1
66005: PPUSH
66006: CALL_OW 12
66010: PLUS
66011: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66012: LD_ADDR_VAR 0 7
66016: PUSH
66017: LD_VAR 0 5
66021: PUSH
66022: LD_INT 1
66024: NEG
66025: PPUSH
66026: LD_INT 1
66028: PPUSH
66029: CALL_OW 12
66033: PLUS
66034: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66035: LD_VAR 0 6
66039: PPUSH
66040: LD_VAR 0 7
66044: PPUSH
66045: CALL_OW 488
66049: NOT
66050: IFFALSE 66072
// begin _x := x ;
66052: LD_ADDR_VAR 0 6
66056: PUSH
66057: LD_VAR 0 4
66061: ST_TO_ADDR
// _y := y ;
66062: LD_ADDR_VAR 0 7
66066: PUSH
66067: LD_VAR 0 5
66071: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66072: LD_ADDR_VAR 0 3
66076: PUSH
66077: LD_INT 1
66079: PPUSH
66080: LD_VAR 0 14
66084: PPUSH
66085: CALL_OW 12
66089: ST_TO_ADDR
// case i of 1 :
66090: LD_VAR 0 3
66094: PUSH
66095: LD_INT 1
66097: DOUBLE
66098: EQUAL
66099: IFTRUE 66103
66101: GO 66120
66103: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66104: LD_VAR 0 1
66108: PPUSH
66109: LD_VAR 0 10
66113: PPUSH
66114: CALL_OW 115
66118: GO 66181
66120: LD_INT 2
66122: DOUBLE
66123: EQUAL
66124: IFTRUE 66128
66126: GO 66150
66128: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66129: LD_VAR 0 1
66133: PPUSH
66134: LD_VAR 0 6
66138: PPUSH
66139: LD_VAR 0 7
66143: PPUSH
66144: CALL_OW 153
66148: GO 66181
66150: LD_INT 3
66152: DOUBLE
66153: EQUAL
66154: IFTRUE 66158
66156: GO 66180
66158: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66159: LD_VAR 0 1
66163: PPUSH
66164: LD_VAR 0 6
66168: PPUSH
66169: LD_VAR 0 7
66173: PPUSH
66174: CALL_OW 154
66178: GO 66181
66180: POP
// end ;
66181: LD_VAR 0 2
66185: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66186: LD_INT 0
66188: PPUSH
66189: PPUSH
66190: PPUSH
66191: PPUSH
66192: PPUSH
66193: PPUSH
// if not unit or not building then
66194: LD_VAR 0 1
66198: NOT
66199: PUSH
66200: LD_VAR 0 2
66204: NOT
66205: OR
66206: IFFALSE 66210
// exit ;
66208: GO 66368
// x := GetX ( building ) ;
66210: LD_ADDR_VAR 0 5
66214: PUSH
66215: LD_VAR 0 2
66219: PPUSH
66220: CALL_OW 250
66224: ST_TO_ADDR
// y := GetY ( building ) ;
66225: LD_ADDR_VAR 0 6
66229: PUSH
66230: LD_VAR 0 2
66234: PPUSH
66235: CALL_OW 251
66239: ST_TO_ADDR
// for i = 0 to 5 do
66240: LD_ADDR_VAR 0 4
66244: PUSH
66245: DOUBLE
66246: LD_INT 0
66248: DEC
66249: ST_TO_ADDR
66250: LD_INT 5
66252: PUSH
66253: FOR_TO
66254: IFFALSE 66366
// begin _x := ShiftX ( x , i , 3 ) ;
66256: LD_ADDR_VAR 0 7
66260: PUSH
66261: LD_VAR 0 5
66265: PPUSH
66266: LD_VAR 0 4
66270: PPUSH
66271: LD_INT 3
66273: PPUSH
66274: CALL_OW 272
66278: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66279: LD_ADDR_VAR 0 8
66283: PUSH
66284: LD_VAR 0 6
66288: PPUSH
66289: LD_VAR 0 4
66293: PPUSH
66294: LD_INT 3
66296: PPUSH
66297: CALL_OW 273
66301: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66302: LD_VAR 0 7
66306: PPUSH
66307: LD_VAR 0 8
66311: PPUSH
66312: CALL_OW 488
66316: NOT
66317: IFFALSE 66321
// continue ;
66319: GO 66253
// if HexInfo ( _x , _y ) = 0 then
66321: LD_VAR 0 7
66325: PPUSH
66326: LD_VAR 0 8
66330: PPUSH
66331: CALL_OW 428
66335: PUSH
66336: LD_INT 0
66338: EQUAL
66339: IFFALSE 66364
// begin ComMoveXY ( unit , _x , _y ) ;
66341: LD_VAR 0 1
66345: PPUSH
66346: LD_VAR 0 7
66350: PPUSH
66351: LD_VAR 0 8
66355: PPUSH
66356: CALL_OW 111
// exit ;
66360: POP
66361: POP
66362: GO 66368
// end ; end ;
66364: GO 66253
66366: POP
66367: POP
// end ;
66368: LD_VAR 0 3
66372: RET
// export function ScanBase ( side , base_area ) ; begin
66373: LD_INT 0
66375: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66376: LD_ADDR_VAR 0 3
66380: PUSH
66381: LD_VAR 0 2
66385: PPUSH
66386: LD_INT 81
66388: PUSH
66389: LD_VAR 0 1
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PPUSH
66398: CALL_OW 70
66402: ST_TO_ADDR
// end ;
66403: LD_VAR 0 3
66407: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66408: LD_INT 0
66410: PPUSH
66411: PPUSH
66412: PPUSH
66413: PPUSH
66414: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66415: LD_VAR 0 1
66419: NOT
66420: PUSH
66421: LD_EXP 102
66425: PUSH
66426: LD_VAR 0 1
66430: ARRAY
66431: NOT
66432: OR
66433: PUSH
66434: LD_VAR 0 2
66438: NOT
66439: OR
66440: PUSH
66441: LD_VAR 0 3
66445: NOT
66446: OR
66447: IFFALSE 66451
// exit ;
66449: GO 66964
// side := mc_sides [ base ] ;
66451: LD_ADDR_VAR 0 6
66455: PUSH
66456: LD_EXP 128
66460: PUSH
66461: LD_VAR 0 1
66465: ARRAY
66466: ST_TO_ADDR
// if not side then
66467: LD_VAR 0 6
66471: NOT
66472: IFFALSE 66476
// exit ;
66474: GO 66964
// for i in solds do
66476: LD_ADDR_VAR 0 7
66480: PUSH
66481: LD_VAR 0 2
66485: PUSH
66486: FOR_IN
66487: IFFALSE 66548
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66489: LD_VAR 0 7
66493: PPUSH
66494: CALL_OW 310
66498: PPUSH
66499: CALL_OW 266
66503: PUSH
66504: LD_INT 32
66506: PUSH
66507: LD_INT 31
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: IN
66514: IFFALSE 66534
// solds := solds diff i else
66516: LD_ADDR_VAR 0 2
66520: PUSH
66521: LD_VAR 0 2
66525: PUSH
66526: LD_VAR 0 7
66530: DIFF
66531: ST_TO_ADDR
66532: GO 66546
// SetTag ( i , 18 ) ;
66534: LD_VAR 0 7
66538: PPUSH
66539: LD_INT 18
66541: PPUSH
66542: CALL_OW 109
66546: GO 66486
66548: POP
66549: POP
// if not solds then
66550: LD_VAR 0 2
66554: NOT
66555: IFFALSE 66559
// exit ;
66557: GO 66964
// repeat wait ( 0 0$1 ) ;
66559: LD_INT 35
66561: PPUSH
66562: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66566: LD_ADDR_VAR 0 5
66570: PUSH
66571: LD_VAR 0 6
66575: PPUSH
66576: LD_VAR 0 3
66580: PPUSH
66581: CALL 66373 0 2
66585: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66586: LD_EXP 102
66590: PUSH
66591: LD_VAR 0 1
66595: ARRAY
66596: NOT
66597: PUSH
66598: LD_EXP 102
66602: PUSH
66603: LD_VAR 0 1
66607: ARRAY
66608: PUSH
66609: EMPTY
66610: EQUAL
66611: OR
66612: IFFALSE 66649
// begin for i in solds do
66614: LD_ADDR_VAR 0 7
66618: PUSH
66619: LD_VAR 0 2
66623: PUSH
66624: FOR_IN
66625: IFFALSE 66638
// ComStop ( i ) ;
66627: LD_VAR 0 7
66631: PPUSH
66632: CALL_OW 141
66636: GO 66624
66638: POP
66639: POP
// solds := [ ] ;
66640: LD_ADDR_VAR 0 2
66644: PUSH
66645: EMPTY
66646: ST_TO_ADDR
// exit ;
66647: GO 66964
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66649: LD_VAR 0 5
66653: NOT
66654: PUSH
66655: LD_VAR 0 5
66659: PUSH
66660: LD_INT 3
66662: GREATER
66663: OR
66664: PUSH
66665: LD_EXP 124
66669: PUSH
66670: LD_VAR 0 1
66674: ARRAY
66675: OR
66676: IFFALSE 66717
// begin for i in solds do
66678: LD_ADDR_VAR 0 7
66682: PUSH
66683: LD_VAR 0 2
66687: PUSH
66688: FOR_IN
66689: IFFALSE 66713
// if HasTask ( i ) then
66691: LD_VAR 0 7
66695: PPUSH
66696: CALL_OW 314
66700: IFFALSE 66711
// ComStop ( i ) ;
66702: LD_VAR 0 7
66706: PPUSH
66707: CALL_OW 141
66711: GO 66688
66713: POP
66714: POP
// break ;
66715: GO 66952
// end ; for i in solds do
66717: LD_ADDR_VAR 0 7
66721: PUSH
66722: LD_VAR 0 2
66726: PUSH
66727: FOR_IN
66728: IFFALSE 66944
// begin if IsInUnit ( i ) then
66730: LD_VAR 0 7
66734: PPUSH
66735: CALL_OW 310
66739: IFFALSE 66750
// ComExitBuilding ( i ) ;
66741: LD_VAR 0 7
66745: PPUSH
66746: CALL_OW 122
// if GetLives ( i ) > 333 then
66750: LD_VAR 0 7
66754: PPUSH
66755: CALL_OW 256
66759: PUSH
66760: LD_INT 333
66762: GREATER
66763: IFFALSE 66791
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66765: LD_VAR 0 7
66769: PPUSH
66770: LD_VAR 0 5
66774: PPUSH
66775: LD_VAR 0 7
66779: PPUSH
66780: CALL_OW 74
66784: PPUSH
66785: CALL_OW 115
66789: GO 66942
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66791: LD_ADDR_VAR 0 8
66795: PUSH
66796: LD_EXP 102
66800: PUSH
66801: LD_VAR 0 1
66805: ARRAY
66806: PPUSH
66807: LD_INT 2
66809: PUSH
66810: LD_INT 30
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 30
66822: PUSH
66823: LD_INT 1
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 30
66832: PUSH
66833: LD_INT 6
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: PPUSH
66846: CALL_OW 72
66850: PPUSH
66851: LD_VAR 0 7
66855: PPUSH
66856: CALL_OW 74
66860: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66861: LD_VAR 0 7
66865: PPUSH
66866: LD_VAR 0 8
66870: PPUSH
66871: CALL_OW 250
66875: PPUSH
66876: LD_INT 3
66878: PPUSH
66879: LD_INT 5
66881: PPUSH
66882: CALL_OW 272
66886: PPUSH
66887: LD_VAR 0 8
66891: PPUSH
66892: CALL_OW 251
66896: PPUSH
66897: LD_INT 3
66899: PPUSH
66900: LD_INT 5
66902: PPUSH
66903: CALL_OW 273
66907: PPUSH
66908: CALL_OW 111
// SetTag ( i , 0 ) ;
66912: LD_VAR 0 7
66916: PPUSH
66917: LD_INT 0
66919: PPUSH
66920: CALL_OW 109
// solds := solds diff i ;
66924: LD_ADDR_VAR 0 2
66928: PUSH
66929: LD_VAR 0 2
66933: PUSH
66934: LD_VAR 0 7
66938: DIFF
66939: ST_TO_ADDR
// continue ;
66940: GO 66727
// end ; end ;
66942: GO 66727
66944: POP
66945: POP
// until solds ;
66946: LD_VAR 0 2
66950: IFFALSE 66559
// MC_Reset ( base , 18 ) ;
66952: LD_VAR 0 1
66956: PPUSH
66957: LD_INT 18
66959: PPUSH
66960: CALL 38785 0 2
// end ;
66964: LD_VAR 0 4
66968: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66969: LD_INT 0
66971: PPUSH
66972: PPUSH
66973: PPUSH
66974: PPUSH
66975: PPUSH
66976: PPUSH
66977: PPUSH
66978: PPUSH
66979: PPUSH
66980: PPUSH
66981: PPUSH
66982: PPUSH
66983: PPUSH
66984: PPUSH
66985: PPUSH
66986: PPUSH
66987: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66988: LD_ADDR_VAR 0 13
66992: PUSH
66993: LD_EXP 102
66997: PUSH
66998: LD_VAR 0 1
67002: ARRAY
67003: PPUSH
67004: LD_INT 25
67006: PUSH
67007: LD_INT 3
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PPUSH
67014: CALL_OW 72
67018: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67019: LD_EXP 142
67023: PUSH
67024: LD_VAR 0 1
67028: ARRAY
67029: IFFALSE 67053
// mechs := mechs diff mc_remote_driver [ base ] ;
67031: LD_ADDR_VAR 0 13
67035: PUSH
67036: LD_VAR 0 13
67040: PUSH
67041: LD_EXP 142
67045: PUSH
67046: LD_VAR 0 1
67050: ARRAY
67051: DIFF
67052: ST_TO_ADDR
// for i in mechs do
67053: LD_ADDR_VAR 0 5
67057: PUSH
67058: LD_VAR 0 13
67062: PUSH
67063: FOR_IN
67064: IFFALSE 67099
// if GetTag ( i ) > 0 then
67066: LD_VAR 0 5
67070: PPUSH
67071: CALL_OW 110
67075: PUSH
67076: LD_INT 0
67078: GREATER
67079: IFFALSE 67097
// mechs := mechs diff i ;
67081: LD_ADDR_VAR 0 13
67085: PUSH
67086: LD_VAR 0 13
67090: PUSH
67091: LD_VAR 0 5
67095: DIFF
67096: ST_TO_ADDR
67097: GO 67063
67099: POP
67100: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67101: LD_ADDR_VAR 0 9
67105: PUSH
67106: LD_EXP 102
67110: PUSH
67111: LD_VAR 0 1
67115: ARRAY
67116: PPUSH
67117: LD_INT 2
67119: PUSH
67120: LD_INT 25
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 25
67132: PUSH
67133: LD_INT 5
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 25
67142: PUSH
67143: LD_INT 8
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 25
67152: PUSH
67153: LD_INT 9
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: PPUSH
67167: CALL_OW 72
67171: ST_TO_ADDR
// if not defenders and not solds then
67172: LD_VAR 0 2
67176: NOT
67177: PUSH
67178: LD_VAR 0 9
67182: NOT
67183: AND
67184: IFFALSE 67188
// exit ;
67186: GO 68814
// depot_under_attack := false ;
67188: LD_ADDR_VAR 0 17
67192: PUSH
67193: LD_INT 0
67195: ST_TO_ADDR
// sold_defenders := [ ] ;
67196: LD_ADDR_VAR 0 18
67200: PUSH
67201: EMPTY
67202: ST_TO_ADDR
// if mechs then
67203: LD_VAR 0 13
67207: IFFALSE 67336
// for i in defenders do
67209: LD_ADDR_VAR 0 5
67213: PUSH
67214: LD_VAR 0 2
67218: PUSH
67219: FOR_IN
67220: IFFALSE 67334
// begin SetTag ( i , 20 ) ;
67222: LD_VAR 0 5
67226: PPUSH
67227: LD_INT 20
67229: PPUSH
67230: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67234: LD_VAR 0 5
67238: PPUSH
67239: CALL_OW 263
67243: PUSH
67244: LD_INT 1
67246: EQUAL
67247: PUSH
67248: LD_VAR 0 5
67252: PPUSH
67253: CALL_OW 311
67257: NOT
67258: AND
67259: PUSH
67260: LD_VAR 0 13
67264: AND
67265: IFFALSE 67332
// begin un := mechs [ 1 ] ;
67267: LD_ADDR_VAR 0 11
67271: PUSH
67272: LD_VAR 0 13
67276: PUSH
67277: LD_INT 1
67279: ARRAY
67280: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67281: LD_VAR 0 11
67285: PPUSH
67286: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67290: LD_VAR 0 11
67294: PPUSH
67295: LD_VAR 0 5
67299: PPUSH
67300: CALL_OW 180
// SetTag ( un , 19 ) ;
67304: LD_VAR 0 11
67308: PPUSH
67309: LD_INT 19
67311: PPUSH
67312: CALL_OW 109
// mechs := mechs diff un ;
67316: LD_ADDR_VAR 0 13
67320: PUSH
67321: LD_VAR 0 13
67325: PUSH
67326: LD_VAR 0 11
67330: DIFF
67331: ST_TO_ADDR
// end ; end ;
67332: GO 67219
67334: POP
67335: POP
// if solds then
67336: LD_VAR 0 9
67340: IFFALSE 67399
// for i in solds do
67342: LD_ADDR_VAR 0 5
67346: PUSH
67347: LD_VAR 0 9
67351: PUSH
67352: FOR_IN
67353: IFFALSE 67397
// if not GetTag ( i ) then
67355: LD_VAR 0 5
67359: PPUSH
67360: CALL_OW 110
67364: NOT
67365: IFFALSE 67395
// begin defenders := defenders union i ;
67367: LD_ADDR_VAR 0 2
67371: PUSH
67372: LD_VAR 0 2
67376: PUSH
67377: LD_VAR 0 5
67381: UNION
67382: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67383: LD_VAR 0 5
67387: PPUSH
67388: LD_INT 18
67390: PPUSH
67391: CALL_OW 109
// end ;
67395: GO 67352
67397: POP
67398: POP
// repeat wait ( 0 0$1 ) ;
67399: LD_INT 35
67401: PPUSH
67402: CALL_OW 67
// enemy := mc_scan [ base ] ;
67406: LD_ADDR_VAR 0 3
67410: PUSH
67411: LD_EXP 125
67415: PUSH
67416: LD_VAR 0 1
67420: ARRAY
67421: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67422: LD_EXP 102
67426: PUSH
67427: LD_VAR 0 1
67431: ARRAY
67432: NOT
67433: PUSH
67434: LD_EXP 102
67438: PUSH
67439: LD_VAR 0 1
67443: ARRAY
67444: PUSH
67445: EMPTY
67446: EQUAL
67447: OR
67448: IFFALSE 67485
// begin for i in defenders do
67450: LD_ADDR_VAR 0 5
67454: PUSH
67455: LD_VAR 0 2
67459: PUSH
67460: FOR_IN
67461: IFFALSE 67474
// ComStop ( i ) ;
67463: LD_VAR 0 5
67467: PPUSH
67468: CALL_OW 141
67472: GO 67460
67474: POP
67475: POP
// defenders := [ ] ;
67476: LD_ADDR_VAR 0 2
67480: PUSH
67481: EMPTY
67482: ST_TO_ADDR
// exit ;
67483: GO 68814
// end ; for i in defenders do
67485: LD_ADDR_VAR 0 5
67489: PUSH
67490: LD_VAR 0 2
67494: PUSH
67495: FOR_IN
67496: IFFALSE 68314
// begin e := NearestUnitToUnit ( enemy , i ) ;
67498: LD_ADDR_VAR 0 14
67502: PUSH
67503: LD_VAR 0 3
67507: PPUSH
67508: LD_VAR 0 5
67512: PPUSH
67513: CALL_OW 74
67517: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67518: LD_ADDR_VAR 0 8
67522: PUSH
67523: LD_EXP 102
67527: PUSH
67528: LD_VAR 0 1
67532: ARRAY
67533: PPUSH
67534: LD_INT 2
67536: PUSH
67537: LD_INT 30
67539: PUSH
67540: LD_INT 0
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 30
67549: PUSH
67550: LD_INT 1
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: LIST
67561: PPUSH
67562: CALL_OW 72
67566: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67567: LD_ADDR_VAR 0 17
67571: PUSH
67572: LD_VAR 0 8
67576: NOT
67577: PUSH
67578: LD_VAR 0 8
67582: PPUSH
67583: LD_INT 3
67585: PUSH
67586: LD_INT 24
67588: PUSH
67589: LD_INT 600
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PPUSH
67600: CALL_OW 72
67604: OR
67605: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67606: LD_VAR 0 5
67610: PPUSH
67611: CALL_OW 247
67615: PUSH
67616: LD_INT 2
67618: DOUBLE
67619: EQUAL
67620: IFTRUE 67624
67622: GO 68020
67624: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67625: LD_VAR 0 5
67629: PPUSH
67630: CALL_OW 256
67634: PUSH
67635: LD_INT 650
67637: GREATER
67638: PUSH
67639: LD_VAR 0 5
67643: PPUSH
67644: LD_VAR 0 14
67648: PPUSH
67649: CALL_OW 296
67653: PUSH
67654: LD_INT 40
67656: LESS
67657: PUSH
67658: LD_VAR 0 14
67662: PPUSH
67663: LD_EXP 127
67667: PUSH
67668: LD_VAR 0 1
67672: ARRAY
67673: PPUSH
67674: CALL_OW 308
67678: OR
67679: AND
67680: IFFALSE 67802
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67682: LD_VAR 0 5
67686: PPUSH
67687: CALL_OW 262
67691: PUSH
67692: LD_INT 1
67694: EQUAL
67695: PUSH
67696: LD_VAR 0 5
67700: PPUSH
67701: CALL_OW 261
67705: PUSH
67706: LD_INT 30
67708: LESS
67709: AND
67710: PUSH
67711: LD_VAR 0 8
67715: AND
67716: IFFALSE 67786
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67718: LD_VAR 0 5
67722: PPUSH
67723: LD_VAR 0 8
67727: PPUSH
67728: LD_VAR 0 5
67732: PPUSH
67733: CALL_OW 74
67737: PPUSH
67738: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67742: LD_VAR 0 5
67746: PPUSH
67747: LD_VAR 0 8
67751: PPUSH
67752: LD_VAR 0 5
67756: PPUSH
67757: CALL_OW 74
67761: PPUSH
67762: CALL_OW 296
67766: PUSH
67767: LD_INT 6
67769: LESS
67770: IFFALSE 67784
// SetFuel ( i , 100 ) ;
67772: LD_VAR 0 5
67776: PPUSH
67777: LD_INT 100
67779: PPUSH
67780: CALL_OW 240
// end else
67784: GO 67800
// ComAttackUnit ( i , e ) ;
67786: LD_VAR 0 5
67790: PPUSH
67791: LD_VAR 0 14
67795: PPUSH
67796: CALL_OW 115
// end else
67800: GO 67903
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67802: LD_VAR 0 14
67806: PPUSH
67807: LD_EXP 127
67811: PUSH
67812: LD_VAR 0 1
67816: ARRAY
67817: PPUSH
67818: CALL_OW 308
67822: NOT
67823: PUSH
67824: LD_VAR 0 5
67828: PPUSH
67829: LD_VAR 0 14
67833: PPUSH
67834: CALL_OW 296
67838: PUSH
67839: LD_INT 40
67841: GREATEREQUAL
67842: AND
67843: PUSH
67844: LD_VAR 0 5
67848: PPUSH
67849: CALL_OW 256
67853: PUSH
67854: LD_INT 650
67856: LESSEQUAL
67857: OR
67858: PUSH
67859: LD_VAR 0 5
67863: PPUSH
67864: LD_EXP 126
67868: PUSH
67869: LD_VAR 0 1
67873: ARRAY
67874: PPUSH
67875: CALL_OW 308
67879: NOT
67880: AND
67881: IFFALSE 67903
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67883: LD_VAR 0 5
67887: PPUSH
67888: LD_EXP 126
67892: PUSH
67893: LD_VAR 0 1
67897: ARRAY
67898: PPUSH
67899: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67903: LD_VAR 0 5
67907: PPUSH
67908: CALL_OW 256
67912: PUSH
67913: LD_INT 998
67915: LESS
67916: PUSH
67917: LD_VAR 0 5
67921: PPUSH
67922: CALL_OW 263
67926: PUSH
67927: LD_INT 1
67929: EQUAL
67930: AND
67931: PUSH
67932: LD_VAR 0 5
67936: PPUSH
67937: CALL_OW 311
67941: AND
67942: PUSH
67943: LD_VAR 0 5
67947: PPUSH
67948: LD_EXP 126
67952: PUSH
67953: LD_VAR 0 1
67957: ARRAY
67958: PPUSH
67959: CALL_OW 308
67963: AND
67964: IFFALSE 68018
// begin mech := IsDrivenBy ( i ) ;
67966: LD_ADDR_VAR 0 10
67970: PUSH
67971: LD_VAR 0 5
67975: PPUSH
67976: CALL_OW 311
67980: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67981: LD_VAR 0 10
67985: PPUSH
67986: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67990: LD_VAR 0 10
67994: PPUSH
67995: LD_VAR 0 5
67999: PPUSH
68000: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68004: LD_VAR 0 10
68008: PPUSH
68009: LD_VAR 0 5
68013: PPUSH
68014: CALL_OW 180
// end ; end ; unit_human :
68018: GO 68285
68020: LD_INT 1
68022: DOUBLE
68023: EQUAL
68024: IFTRUE 68028
68026: GO 68284
68028: POP
// begin b := IsInUnit ( i ) ;
68029: LD_ADDR_VAR 0 19
68033: PUSH
68034: LD_VAR 0 5
68038: PPUSH
68039: CALL_OW 310
68043: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68044: LD_ADDR_VAR 0 20
68048: PUSH
68049: LD_VAR 0 19
68053: NOT
68054: PUSH
68055: LD_VAR 0 19
68059: PPUSH
68060: CALL_OW 266
68064: PUSH
68065: LD_INT 32
68067: PUSH
68068: LD_INT 31
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: IN
68075: OR
68076: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68077: LD_VAR 0 17
68081: PUSH
68082: LD_VAR 0 2
68086: PPUSH
68087: LD_INT 21
68089: PUSH
68090: LD_INT 2
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PPUSH
68097: CALL_OW 72
68101: PUSH
68102: LD_INT 1
68104: LESSEQUAL
68105: OR
68106: PUSH
68107: LD_VAR 0 20
68111: AND
68112: PUSH
68113: LD_VAR 0 5
68117: PUSH
68118: LD_VAR 0 18
68122: IN
68123: NOT
68124: AND
68125: IFFALSE 68218
// begin if b then
68127: LD_VAR 0 19
68131: IFFALSE 68180
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68133: LD_VAR 0 19
68137: PPUSH
68138: LD_VAR 0 3
68142: PPUSH
68143: LD_VAR 0 19
68147: PPUSH
68148: CALL_OW 74
68152: PPUSH
68153: CALL_OW 296
68157: PUSH
68158: LD_INT 10
68160: LESS
68161: PUSH
68162: LD_VAR 0 19
68166: PPUSH
68167: CALL_OW 461
68171: PUSH
68172: LD_INT 7
68174: NONEQUAL
68175: AND
68176: IFFALSE 68180
// continue ;
68178: GO 67495
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68180: LD_ADDR_VAR 0 18
68184: PUSH
68185: LD_VAR 0 18
68189: PPUSH
68190: LD_VAR 0 18
68194: PUSH
68195: LD_INT 1
68197: PLUS
68198: PPUSH
68199: LD_VAR 0 5
68203: PPUSH
68204: CALL_OW 1
68208: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68209: LD_VAR 0 5
68213: PPUSH
68214: CALL_OW 122
// end ; if sold_defenders then
68218: LD_VAR 0 18
68222: IFFALSE 68282
// if i in sold_defenders then
68224: LD_VAR 0 5
68228: PUSH
68229: LD_VAR 0 18
68233: IN
68234: IFFALSE 68282
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68236: LD_VAR 0 5
68240: PPUSH
68241: CALL_OW 314
68245: NOT
68246: PUSH
68247: LD_VAR 0 5
68251: PPUSH
68252: LD_VAR 0 14
68256: PPUSH
68257: CALL_OW 296
68261: PUSH
68262: LD_INT 30
68264: LESS
68265: AND
68266: IFFALSE 68282
// ComAttackUnit ( i , e ) ;
68268: LD_VAR 0 5
68272: PPUSH
68273: LD_VAR 0 14
68277: PPUSH
68278: CALL_OW 115
// end ; end ; end ;
68282: GO 68285
68284: POP
// if IsDead ( i ) then
68285: LD_VAR 0 5
68289: PPUSH
68290: CALL_OW 301
68294: IFFALSE 68312
// defenders := defenders diff i ;
68296: LD_ADDR_VAR 0 2
68300: PUSH
68301: LD_VAR 0 2
68305: PUSH
68306: LD_VAR 0 5
68310: DIFF
68311: ST_TO_ADDR
// end ;
68312: GO 67495
68314: POP
68315: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68316: LD_VAR 0 3
68320: NOT
68321: PUSH
68322: LD_VAR 0 2
68326: NOT
68327: OR
68328: PUSH
68329: LD_EXP 102
68333: PUSH
68334: LD_VAR 0 1
68338: ARRAY
68339: NOT
68340: OR
68341: IFFALSE 67399
// MC_Reset ( base , 18 ) ;
68343: LD_VAR 0 1
68347: PPUSH
68348: LD_INT 18
68350: PPUSH
68351: CALL 38785 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68355: LD_ADDR_VAR 0 2
68359: PUSH
68360: LD_VAR 0 2
68364: PUSH
68365: LD_VAR 0 2
68369: PPUSH
68370: LD_INT 2
68372: PUSH
68373: LD_INT 25
68375: PUSH
68376: LD_INT 1
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: LD_INT 25
68385: PUSH
68386: LD_INT 5
68388: PUSH
68389: EMPTY
68390: LIST
68391: LIST
68392: PUSH
68393: LD_INT 25
68395: PUSH
68396: LD_INT 8
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 25
68405: PUSH
68406: LD_INT 9
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: PPUSH
68420: CALL_OW 72
68424: DIFF
68425: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68426: LD_VAR 0 3
68430: NOT
68431: PUSH
68432: LD_VAR 0 2
68436: PPUSH
68437: LD_INT 21
68439: PUSH
68440: LD_INT 2
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PPUSH
68447: CALL_OW 72
68451: AND
68452: IFFALSE 68790
// begin tmp := FilterByTag ( defenders , 19 ) ;
68454: LD_ADDR_VAR 0 12
68458: PUSH
68459: LD_VAR 0 2
68463: PPUSH
68464: LD_INT 19
68466: PPUSH
68467: CALL 105246 0 2
68471: ST_TO_ADDR
// if tmp then
68472: LD_VAR 0 12
68476: IFFALSE 68546
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68478: LD_ADDR_VAR 0 12
68482: PUSH
68483: LD_VAR 0 12
68487: PPUSH
68488: LD_INT 25
68490: PUSH
68491: LD_INT 3
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PPUSH
68498: CALL_OW 72
68502: ST_TO_ADDR
// if tmp then
68503: LD_VAR 0 12
68507: IFFALSE 68546
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68509: LD_ADDR_EXP 114
68513: PUSH
68514: LD_EXP 114
68518: PPUSH
68519: LD_VAR 0 1
68523: PPUSH
68524: LD_EXP 114
68528: PUSH
68529: LD_VAR 0 1
68533: ARRAY
68534: PUSH
68535: LD_VAR 0 12
68539: UNION
68540: PPUSH
68541: CALL_OW 1
68545: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68546: LD_VAR 0 1
68550: PPUSH
68551: LD_INT 19
68553: PPUSH
68554: CALL 38785 0 2
// repeat wait ( 0 0$1 ) ;
68558: LD_INT 35
68560: PPUSH
68561: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68565: LD_EXP 102
68569: PUSH
68570: LD_VAR 0 1
68574: ARRAY
68575: NOT
68576: PUSH
68577: LD_EXP 102
68581: PUSH
68582: LD_VAR 0 1
68586: ARRAY
68587: PUSH
68588: EMPTY
68589: EQUAL
68590: OR
68591: IFFALSE 68628
// begin for i in defenders do
68593: LD_ADDR_VAR 0 5
68597: PUSH
68598: LD_VAR 0 2
68602: PUSH
68603: FOR_IN
68604: IFFALSE 68617
// ComStop ( i ) ;
68606: LD_VAR 0 5
68610: PPUSH
68611: CALL_OW 141
68615: GO 68603
68617: POP
68618: POP
// defenders := [ ] ;
68619: LD_ADDR_VAR 0 2
68623: PUSH
68624: EMPTY
68625: ST_TO_ADDR
// exit ;
68626: GO 68814
// end ; for i in defenders do
68628: LD_ADDR_VAR 0 5
68632: PUSH
68633: LD_VAR 0 2
68637: PUSH
68638: FOR_IN
68639: IFFALSE 68728
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68641: LD_VAR 0 5
68645: PPUSH
68646: LD_EXP 126
68650: PUSH
68651: LD_VAR 0 1
68655: ARRAY
68656: PPUSH
68657: CALL_OW 308
68661: NOT
68662: IFFALSE 68686
// ComMoveToArea ( i , mc_parking [ base ] ) else
68664: LD_VAR 0 5
68668: PPUSH
68669: LD_EXP 126
68673: PUSH
68674: LD_VAR 0 1
68678: ARRAY
68679: PPUSH
68680: CALL_OW 113
68684: GO 68726
// if GetControl ( i ) = control_manual then
68686: LD_VAR 0 5
68690: PPUSH
68691: CALL_OW 263
68695: PUSH
68696: LD_INT 1
68698: EQUAL
68699: IFFALSE 68726
// if IsDrivenBy ( i ) then
68701: LD_VAR 0 5
68705: PPUSH
68706: CALL_OW 311
68710: IFFALSE 68726
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68712: LD_VAR 0 5
68716: PPUSH
68717: CALL_OW 311
68721: PPUSH
68722: CALL_OW 121
// end ;
68726: GO 68638
68728: POP
68729: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68730: LD_VAR 0 2
68734: PPUSH
68735: LD_INT 95
68737: PUSH
68738: LD_EXP 126
68742: PUSH
68743: LD_VAR 0 1
68747: ARRAY
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PPUSH
68753: CALL_OW 72
68757: PUSH
68758: LD_VAR 0 2
68762: EQUAL
68763: PUSH
68764: LD_EXP 125
68768: PUSH
68769: LD_VAR 0 1
68773: ARRAY
68774: OR
68775: PUSH
68776: LD_EXP 102
68780: PUSH
68781: LD_VAR 0 1
68785: ARRAY
68786: NOT
68787: OR
68788: IFFALSE 68558
// end ; MC_Reset ( base , 19 ) ;
68790: LD_VAR 0 1
68794: PPUSH
68795: LD_INT 19
68797: PPUSH
68798: CALL 38785 0 2
// MC_Reset ( base , 20 ) ;
68802: LD_VAR 0 1
68806: PPUSH
68807: LD_INT 20
68809: PPUSH
68810: CALL 38785 0 2
// end ;
68814: LD_VAR 0 4
68818: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68819: LD_INT 0
68821: PPUSH
68822: PPUSH
68823: PPUSH
68824: PPUSH
// result := false ;
68825: LD_ADDR_VAR 0 2
68829: PUSH
68830: LD_INT 0
68832: ST_TO_ADDR
// side := GetSide ( unit ) ;
68833: LD_ADDR_VAR 0 3
68837: PUSH
68838: LD_VAR 0 1
68842: PPUSH
68843: CALL_OW 255
68847: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68848: LD_ADDR_VAR 0 4
68852: PUSH
68853: LD_VAR 0 1
68857: PPUSH
68858: CALL_OW 248
68862: ST_TO_ADDR
// case nat of 1 :
68863: LD_VAR 0 4
68867: PUSH
68868: LD_INT 1
68870: DOUBLE
68871: EQUAL
68872: IFTRUE 68876
68874: GO 68887
68876: POP
// tech := tech_lassight ; 2 :
68877: LD_ADDR_VAR 0 5
68881: PUSH
68882: LD_INT 12
68884: ST_TO_ADDR
68885: GO 68926
68887: LD_INT 2
68889: DOUBLE
68890: EQUAL
68891: IFTRUE 68895
68893: GO 68906
68895: POP
// tech := tech_mortar ; 3 :
68896: LD_ADDR_VAR 0 5
68900: PUSH
68901: LD_INT 41
68903: ST_TO_ADDR
68904: GO 68926
68906: LD_INT 3
68908: DOUBLE
68909: EQUAL
68910: IFTRUE 68914
68912: GO 68925
68914: POP
// tech := tech_bazooka ; end ;
68915: LD_ADDR_VAR 0 5
68919: PUSH
68920: LD_INT 44
68922: ST_TO_ADDR
68923: GO 68926
68925: POP
// if Researched ( side , tech ) then
68926: LD_VAR 0 3
68930: PPUSH
68931: LD_VAR 0 5
68935: PPUSH
68936: CALL_OW 325
68940: IFFALSE 68967
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68942: LD_ADDR_VAR 0 2
68946: PUSH
68947: LD_INT 5
68949: PUSH
68950: LD_INT 8
68952: PUSH
68953: LD_INT 9
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: LIST
68960: PUSH
68961: LD_VAR 0 4
68965: ARRAY
68966: ST_TO_ADDR
// end ;
68967: LD_VAR 0 2
68971: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68972: LD_INT 0
68974: PPUSH
68975: PPUSH
68976: PPUSH
// if not mines then
68977: LD_VAR 0 2
68981: NOT
68982: IFFALSE 68986
// exit ;
68984: GO 69130
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68986: LD_ADDR_VAR 0 5
68990: PUSH
68991: LD_INT 81
68993: PUSH
68994: LD_VAR 0 1
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 3
69005: PUSH
69006: LD_INT 21
69008: PUSH
69009: LD_INT 3
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PPUSH
69024: CALL_OW 69
69028: ST_TO_ADDR
// for i in mines do
69029: LD_ADDR_VAR 0 4
69033: PUSH
69034: LD_VAR 0 2
69038: PUSH
69039: FOR_IN
69040: IFFALSE 69128
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69042: LD_VAR 0 4
69046: PUSH
69047: LD_INT 1
69049: ARRAY
69050: PPUSH
69051: LD_VAR 0 4
69055: PUSH
69056: LD_INT 2
69058: ARRAY
69059: PPUSH
69060: CALL_OW 458
69064: NOT
69065: IFFALSE 69069
// continue ;
69067: GO 69039
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69069: LD_VAR 0 4
69073: PUSH
69074: LD_INT 1
69076: ARRAY
69077: PPUSH
69078: LD_VAR 0 4
69082: PUSH
69083: LD_INT 2
69085: ARRAY
69086: PPUSH
69087: CALL_OW 428
69091: PUSH
69092: LD_VAR 0 5
69096: IN
69097: IFFALSE 69126
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69099: LD_VAR 0 4
69103: PUSH
69104: LD_INT 1
69106: ARRAY
69107: PPUSH
69108: LD_VAR 0 4
69112: PUSH
69113: LD_INT 2
69115: ARRAY
69116: PPUSH
69117: LD_VAR 0 1
69121: PPUSH
69122: CALL_OW 456
// end ;
69126: GO 69039
69128: POP
69129: POP
// end ;
69130: LD_VAR 0 3
69134: RET
// export function Count ( array ) ; var i ; begin
69135: LD_INT 0
69137: PPUSH
69138: PPUSH
// result := 0 ;
69139: LD_ADDR_VAR 0 2
69143: PUSH
69144: LD_INT 0
69146: ST_TO_ADDR
// for i in array do
69147: LD_ADDR_VAR 0 3
69151: PUSH
69152: LD_VAR 0 1
69156: PUSH
69157: FOR_IN
69158: IFFALSE 69182
// if i then
69160: LD_VAR 0 3
69164: IFFALSE 69180
// result := result + 1 ;
69166: LD_ADDR_VAR 0 2
69170: PUSH
69171: LD_VAR 0 2
69175: PUSH
69176: LD_INT 1
69178: PLUS
69179: ST_TO_ADDR
69180: GO 69157
69182: POP
69183: POP
// end ;
69184: LD_VAR 0 2
69188: RET
// export function IsEmpty ( building ) ; begin
69189: LD_INT 0
69191: PPUSH
// if not building then
69192: LD_VAR 0 1
69196: NOT
69197: IFFALSE 69201
// exit ;
69199: GO 69244
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69201: LD_ADDR_VAR 0 2
69205: PUSH
69206: LD_VAR 0 1
69210: PUSH
69211: LD_INT 22
69213: PUSH
69214: LD_VAR 0 1
69218: PPUSH
69219: CALL_OW 255
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 58
69230: PUSH
69231: EMPTY
69232: LIST
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PPUSH
69238: CALL_OW 69
69242: IN
69243: ST_TO_ADDR
// end ;
69244: LD_VAR 0 2
69248: RET
// export function IsNotFull ( building ) ; begin
69249: LD_INT 0
69251: PPUSH
// if not building then
69252: LD_VAR 0 1
69256: NOT
69257: IFFALSE 69261
// exit ;
69259: GO 69280
// result := UnitsInside ( building ) < 6 ;
69261: LD_ADDR_VAR 0 2
69265: PUSH
69266: LD_VAR 0 1
69270: PPUSH
69271: CALL_OW 313
69275: PUSH
69276: LD_INT 6
69278: LESS
69279: ST_TO_ADDR
// end ;
69280: LD_VAR 0 2
69284: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69285: LD_INT 0
69287: PPUSH
69288: PPUSH
69289: PPUSH
69290: PPUSH
// tmp := [ ] ;
69291: LD_ADDR_VAR 0 3
69295: PUSH
69296: EMPTY
69297: ST_TO_ADDR
// list := [ ] ;
69298: LD_ADDR_VAR 0 5
69302: PUSH
69303: EMPTY
69304: ST_TO_ADDR
// for i = 16 to 25 do
69305: LD_ADDR_VAR 0 4
69309: PUSH
69310: DOUBLE
69311: LD_INT 16
69313: DEC
69314: ST_TO_ADDR
69315: LD_INT 25
69317: PUSH
69318: FOR_TO
69319: IFFALSE 69392
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69321: LD_ADDR_VAR 0 3
69325: PUSH
69326: LD_VAR 0 3
69330: PUSH
69331: LD_INT 22
69333: PUSH
69334: LD_VAR 0 1
69338: PPUSH
69339: CALL_OW 255
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 91
69350: PUSH
69351: LD_VAR 0 1
69355: PUSH
69356: LD_INT 6
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 30
69366: PUSH
69367: LD_VAR 0 4
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: LIST
69380: PUSH
69381: EMPTY
69382: LIST
69383: PPUSH
69384: CALL_OW 69
69388: ADD
69389: ST_TO_ADDR
69390: GO 69318
69392: POP
69393: POP
// for i = 1 to tmp do
69394: LD_ADDR_VAR 0 4
69398: PUSH
69399: DOUBLE
69400: LD_INT 1
69402: DEC
69403: ST_TO_ADDR
69404: LD_VAR 0 3
69408: PUSH
69409: FOR_TO
69410: IFFALSE 69498
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69412: LD_ADDR_VAR 0 5
69416: PUSH
69417: LD_VAR 0 5
69421: PUSH
69422: LD_VAR 0 3
69426: PUSH
69427: LD_VAR 0 4
69431: ARRAY
69432: PPUSH
69433: CALL_OW 266
69437: PUSH
69438: LD_VAR 0 3
69442: PUSH
69443: LD_VAR 0 4
69447: ARRAY
69448: PPUSH
69449: CALL_OW 250
69453: PUSH
69454: LD_VAR 0 3
69458: PUSH
69459: LD_VAR 0 4
69463: ARRAY
69464: PPUSH
69465: CALL_OW 251
69469: PUSH
69470: LD_VAR 0 3
69474: PUSH
69475: LD_VAR 0 4
69479: ARRAY
69480: PPUSH
69481: CALL_OW 254
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: PUSH
69492: EMPTY
69493: LIST
69494: ADD
69495: ST_TO_ADDR
69496: GO 69409
69498: POP
69499: POP
// result := list ;
69500: LD_ADDR_VAR 0 2
69504: PUSH
69505: LD_VAR 0 5
69509: ST_TO_ADDR
// end ;
69510: LD_VAR 0 2
69514: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69515: LD_INT 0
69517: PPUSH
69518: PPUSH
69519: PPUSH
69520: PPUSH
69521: PPUSH
69522: PPUSH
69523: PPUSH
// if not factory then
69524: LD_VAR 0 1
69528: NOT
69529: IFFALSE 69533
// exit ;
69531: GO 70126
// if control = control_apeman then
69533: LD_VAR 0 4
69537: PUSH
69538: LD_INT 5
69540: EQUAL
69541: IFFALSE 69650
// begin tmp := UnitsInside ( factory ) ;
69543: LD_ADDR_VAR 0 8
69547: PUSH
69548: LD_VAR 0 1
69552: PPUSH
69553: CALL_OW 313
69557: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69558: LD_VAR 0 8
69562: PPUSH
69563: LD_INT 25
69565: PUSH
69566: LD_INT 12
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PPUSH
69573: CALL_OW 72
69577: NOT
69578: IFFALSE 69588
// control := control_manual ;
69580: LD_ADDR_VAR 0 4
69584: PUSH
69585: LD_INT 1
69587: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69588: LD_ADDR_VAR 0 8
69592: PUSH
69593: LD_VAR 0 1
69597: PPUSH
69598: CALL 69285 0 1
69602: ST_TO_ADDR
// if tmp then
69603: LD_VAR 0 8
69607: IFFALSE 69650
// begin for i in tmp do
69609: LD_ADDR_VAR 0 7
69613: PUSH
69614: LD_VAR 0 8
69618: PUSH
69619: FOR_IN
69620: IFFALSE 69648
// if i [ 1 ] = b_ext_radio then
69622: LD_VAR 0 7
69626: PUSH
69627: LD_INT 1
69629: ARRAY
69630: PUSH
69631: LD_INT 22
69633: EQUAL
69634: IFFALSE 69646
// begin control := control_remote ;
69636: LD_ADDR_VAR 0 4
69640: PUSH
69641: LD_INT 2
69643: ST_TO_ADDR
// break ;
69644: GO 69648
// end ;
69646: GO 69619
69648: POP
69649: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69650: LD_VAR 0 1
69654: PPUSH
69655: LD_VAR 0 2
69659: PPUSH
69660: LD_VAR 0 3
69664: PPUSH
69665: LD_VAR 0 4
69669: PPUSH
69670: LD_VAR 0 5
69674: PPUSH
69675: CALL_OW 448
69679: IFFALSE 69714
// begin result := [ chassis , engine , control , weapon ] ;
69681: LD_ADDR_VAR 0 6
69685: PUSH
69686: LD_VAR 0 2
69690: PUSH
69691: LD_VAR 0 3
69695: PUSH
69696: LD_VAR 0 4
69700: PUSH
69701: LD_VAR 0 5
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: ST_TO_ADDR
// exit ;
69712: GO 70126
// end ; _chassis := AvailableChassisList ( factory ) ;
69714: LD_ADDR_VAR 0 9
69718: PUSH
69719: LD_VAR 0 1
69723: PPUSH
69724: CALL_OW 475
69728: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69729: LD_ADDR_VAR 0 11
69733: PUSH
69734: LD_VAR 0 1
69738: PPUSH
69739: CALL_OW 476
69743: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69744: LD_ADDR_VAR 0 12
69748: PUSH
69749: LD_VAR 0 1
69753: PPUSH
69754: CALL_OW 477
69758: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69759: LD_ADDR_VAR 0 10
69763: PUSH
69764: LD_VAR 0 1
69768: PPUSH
69769: CALL_OW 478
69773: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69774: LD_VAR 0 9
69778: NOT
69779: PUSH
69780: LD_VAR 0 11
69784: NOT
69785: OR
69786: PUSH
69787: LD_VAR 0 12
69791: NOT
69792: OR
69793: PUSH
69794: LD_VAR 0 10
69798: NOT
69799: OR
69800: IFFALSE 69835
// begin result := [ chassis , engine , control , weapon ] ;
69802: LD_ADDR_VAR 0 6
69806: PUSH
69807: LD_VAR 0 2
69811: PUSH
69812: LD_VAR 0 3
69816: PUSH
69817: LD_VAR 0 4
69821: PUSH
69822: LD_VAR 0 5
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: ST_TO_ADDR
// exit ;
69833: GO 70126
// end ; if not chassis in _chassis then
69835: LD_VAR 0 2
69839: PUSH
69840: LD_VAR 0 9
69844: IN
69845: NOT
69846: IFFALSE 69872
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69848: LD_ADDR_VAR 0 2
69852: PUSH
69853: LD_VAR 0 9
69857: PUSH
69858: LD_INT 1
69860: PPUSH
69861: LD_VAR 0 9
69865: PPUSH
69866: CALL_OW 12
69870: ARRAY
69871: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69872: LD_VAR 0 2
69876: PPUSH
69877: LD_VAR 0 3
69881: PPUSH
69882: CALL 70131 0 2
69886: NOT
69887: IFFALSE 69946
// repeat engine := _engine [ 1 ] ;
69889: LD_ADDR_VAR 0 3
69893: PUSH
69894: LD_VAR 0 11
69898: PUSH
69899: LD_INT 1
69901: ARRAY
69902: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69903: LD_ADDR_VAR 0 11
69907: PUSH
69908: LD_VAR 0 11
69912: PPUSH
69913: LD_INT 1
69915: PPUSH
69916: CALL_OW 3
69920: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69921: LD_VAR 0 2
69925: PPUSH
69926: LD_VAR 0 3
69930: PPUSH
69931: CALL 70131 0 2
69935: PUSH
69936: LD_VAR 0 11
69940: PUSH
69941: EMPTY
69942: EQUAL
69943: OR
69944: IFFALSE 69889
// if not control in _control then
69946: LD_VAR 0 4
69950: PUSH
69951: LD_VAR 0 12
69955: IN
69956: NOT
69957: IFFALSE 69983
// control := _control [ rand ( 1 , _control ) ] ;
69959: LD_ADDR_VAR 0 4
69963: PUSH
69964: LD_VAR 0 12
69968: PUSH
69969: LD_INT 1
69971: PPUSH
69972: LD_VAR 0 12
69976: PPUSH
69977: CALL_OW 12
69981: ARRAY
69982: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69983: LD_VAR 0 2
69987: PPUSH
69988: LD_VAR 0 5
69992: PPUSH
69993: CALL 70351 0 2
69997: NOT
69998: IFFALSE 70057
// repeat weapon := _weapon [ 1 ] ;
70000: LD_ADDR_VAR 0 5
70004: PUSH
70005: LD_VAR 0 10
70009: PUSH
70010: LD_INT 1
70012: ARRAY
70013: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70014: LD_ADDR_VAR 0 10
70018: PUSH
70019: LD_VAR 0 10
70023: PPUSH
70024: LD_INT 1
70026: PPUSH
70027: CALL_OW 3
70031: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70032: LD_VAR 0 2
70036: PPUSH
70037: LD_VAR 0 5
70041: PPUSH
70042: CALL 70351 0 2
70046: PUSH
70047: LD_VAR 0 10
70051: PUSH
70052: EMPTY
70053: EQUAL
70054: OR
70055: IFFALSE 70000
// result := [ ] ;
70057: LD_ADDR_VAR 0 6
70061: PUSH
70062: EMPTY
70063: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70064: LD_VAR 0 1
70068: PPUSH
70069: LD_VAR 0 2
70073: PPUSH
70074: LD_VAR 0 3
70078: PPUSH
70079: LD_VAR 0 4
70083: PPUSH
70084: LD_VAR 0 5
70088: PPUSH
70089: CALL_OW 448
70093: IFFALSE 70126
// result := [ chassis , engine , control , weapon ] ;
70095: LD_ADDR_VAR 0 6
70099: PUSH
70100: LD_VAR 0 2
70104: PUSH
70105: LD_VAR 0 3
70109: PUSH
70110: LD_VAR 0 4
70114: PUSH
70115: LD_VAR 0 5
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: ST_TO_ADDR
// end ;
70126: LD_VAR 0 6
70130: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70131: LD_INT 0
70133: PPUSH
// if not chassis or not engine then
70134: LD_VAR 0 1
70138: NOT
70139: PUSH
70140: LD_VAR 0 2
70144: NOT
70145: OR
70146: IFFALSE 70150
// exit ;
70148: GO 70346
// case engine of engine_solar :
70150: LD_VAR 0 2
70154: PUSH
70155: LD_INT 2
70157: DOUBLE
70158: EQUAL
70159: IFTRUE 70163
70161: GO 70201
70163: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70164: LD_ADDR_VAR 0 3
70168: PUSH
70169: LD_INT 11
70171: PUSH
70172: LD_INT 12
70174: PUSH
70175: LD_INT 13
70177: PUSH
70178: LD_INT 14
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: LD_INT 2
70186: PUSH
70187: LD_INT 3
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: ST_TO_ADDR
70199: GO 70330
70201: LD_INT 1
70203: DOUBLE
70204: EQUAL
70205: IFTRUE 70209
70207: GO 70271
70209: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70210: LD_ADDR_VAR 0 3
70214: PUSH
70215: LD_INT 11
70217: PUSH
70218: LD_INT 12
70220: PUSH
70221: LD_INT 13
70223: PUSH
70224: LD_INT 14
70226: PUSH
70227: LD_INT 1
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 3
70235: PUSH
70236: LD_INT 4
70238: PUSH
70239: LD_INT 5
70241: PUSH
70242: LD_INT 21
70244: PUSH
70245: LD_INT 23
70247: PUSH
70248: LD_INT 22
70250: PUSH
70251: LD_INT 24
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: LIST
70268: ST_TO_ADDR
70269: GO 70330
70271: LD_INT 3
70273: DOUBLE
70274: EQUAL
70275: IFTRUE 70279
70277: GO 70329
70279: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70280: LD_ADDR_VAR 0 3
70284: PUSH
70285: LD_INT 13
70287: PUSH
70288: LD_INT 14
70290: PUSH
70291: LD_INT 2
70293: PUSH
70294: LD_INT 3
70296: PUSH
70297: LD_INT 4
70299: PUSH
70300: LD_INT 5
70302: PUSH
70303: LD_INT 21
70305: PUSH
70306: LD_INT 22
70308: PUSH
70309: LD_INT 23
70311: PUSH
70312: LD_INT 24
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: ST_TO_ADDR
70327: GO 70330
70329: POP
// result := ( chassis in result ) ;
70330: LD_ADDR_VAR 0 3
70334: PUSH
70335: LD_VAR 0 1
70339: PUSH
70340: LD_VAR 0 3
70344: IN
70345: ST_TO_ADDR
// end ;
70346: LD_VAR 0 3
70350: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70351: LD_INT 0
70353: PPUSH
// if not chassis or not weapon then
70354: LD_VAR 0 1
70358: NOT
70359: PUSH
70360: LD_VAR 0 2
70364: NOT
70365: OR
70366: IFFALSE 70370
// exit ;
70368: GO 71396
// case weapon of us_machine_gun :
70370: LD_VAR 0 2
70374: PUSH
70375: LD_INT 2
70377: DOUBLE
70378: EQUAL
70379: IFTRUE 70383
70381: GO 70413
70383: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70384: LD_ADDR_VAR 0 3
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: LD_INT 3
70397: PUSH
70398: LD_INT 4
70400: PUSH
70401: LD_INT 5
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: ST_TO_ADDR
70411: GO 71380
70413: LD_INT 3
70415: DOUBLE
70416: EQUAL
70417: IFTRUE 70421
70419: GO 70451
70421: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70422: LD_ADDR_VAR 0 3
70426: PUSH
70427: LD_INT 1
70429: PUSH
70430: LD_INT 2
70432: PUSH
70433: LD_INT 3
70435: PUSH
70436: LD_INT 4
70438: PUSH
70439: LD_INT 5
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: ST_TO_ADDR
70449: GO 71380
70451: LD_INT 11
70453: DOUBLE
70454: EQUAL
70455: IFTRUE 70459
70457: GO 70489
70459: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70460: LD_ADDR_VAR 0 3
70464: PUSH
70465: LD_INT 1
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: LD_INT 3
70473: PUSH
70474: LD_INT 4
70476: PUSH
70477: LD_INT 5
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: ST_TO_ADDR
70487: GO 71380
70489: LD_INT 4
70491: DOUBLE
70492: EQUAL
70493: IFTRUE 70497
70495: GO 70523
70497: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70498: LD_ADDR_VAR 0 3
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: LD_INT 3
70508: PUSH
70509: LD_INT 4
70511: PUSH
70512: LD_INT 5
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: ST_TO_ADDR
70521: GO 71380
70523: LD_INT 5
70525: DOUBLE
70526: EQUAL
70527: IFTRUE 70531
70529: GO 70557
70531: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70532: LD_ADDR_VAR 0 3
70536: PUSH
70537: LD_INT 2
70539: PUSH
70540: LD_INT 3
70542: PUSH
70543: LD_INT 4
70545: PUSH
70546: LD_INT 5
70548: PUSH
70549: EMPTY
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: ST_TO_ADDR
70555: GO 71380
70557: LD_INT 9
70559: DOUBLE
70560: EQUAL
70561: IFTRUE 70565
70563: GO 70591
70565: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70566: LD_ADDR_VAR 0 3
70570: PUSH
70571: LD_INT 2
70573: PUSH
70574: LD_INT 3
70576: PUSH
70577: LD_INT 4
70579: PUSH
70580: LD_INT 5
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: ST_TO_ADDR
70589: GO 71380
70591: LD_INT 7
70593: DOUBLE
70594: EQUAL
70595: IFTRUE 70599
70597: GO 70625
70599: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70600: LD_ADDR_VAR 0 3
70604: PUSH
70605: LD_INT 2
70607: PUSH
70608: LD_INT 3
70610: PUSH
70611: LD_INT 4
70613: PUSH
70614: LD_INT 5
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: ST_TO_ADDR
70623: GO 71380
70625: LD_INT 12
70627: DOUBLE
70628: EQUAL
70629: IFTRUE 70633
70631: GO 70659
70633: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70634: LD_ADDR_VAR 0 3
70638: PUSH
70639: LD_INT 2
70641: PUSH
70642: LD_INT 3
70644: PUSH
70645: LD_INT 4
70647: PUSH
70648: LD_INT 5
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: ST_TO_ADDR
70657: GO 71380
70659: LD_INT 13
70661: DOUBLE
70662: EQUAL
70663: IFTRUE 70667
70665: GO 70693
70667: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70668: LD_ADDR_VAR 0 3
70672: PUSH
70673: LD_INT 2
70675: PUSH
70676: LD_INT 3
70678: PUSH
70679: LD_INT 4
70681: PUSH
70682: LD_INT 5
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: ST_TO_ADDR
70691: GO 71380
70693: LD_INT 14
70695: DOUBLE
70696: EQUAL
70697: IFTRUE 70701
70699: GO 70719
70701: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70702: LD_ADDR_VAR 0 3
70706: PUSH
70707: LD_INT 4
70709: PUSH
70710: LD_INT 5
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: ST_TO_ADDR
70717: GO 71380
70719: LD_INT 6
70721: DOUBLE
70722: EQUAL
70723: IFTRUE 70727
70725: GO 70745
70727: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70728: LD_ADDR_VAR 0 3
70732: PUSH
70733: LD_INT 4
70735: PUSH
70736: LD_INT 5
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: ST_TO_ADDR
70743: GO 71380
70745: LD_INT 10
70747: DOUBLE
70748: EQUAL
70749: IFTRUE 70753
70751: GO 70771
70753: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70754: LD_ADDR_VAR 0 3
70758: PUSH
70759: LD_INT 4
70761: PUSH
70762: LD_INT 5
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: ST_TO_ADDR
70769: GO 71380
70771: LD_INT 22
70773: DOUBLE
70774: EQUAL
70775: IFTRUE 70779
70777: GO 70805
70779: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70780: LD_ADDR_VAR 0 3
70784: PUSH
70785: LD_INT 11
70787: PUSH
70788: LD_INT 12
70790: PUSH
70791: LD_INT 13
70793: PUSH
70794: LD_INT 14
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: ST_TO_ADDR
70803: GO 71380
70805: LD_INT 23
70807: DOUBLE
70808: EQUAL
70809: IFTRUE 70813
70811: GO 70839
70813: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70814: LD_ADDR_VAR 0 3
70818: PUSH
70819: LD_INT 11
70821: PUSH
70822: LD_INT 12
70824: PUSH
70825: LD_INT 13
70827: PUSH
70828: LD_INT 14
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: LIST
70835: LIST
70836: ST_TO_ADDR
70837: GO 71380
70839: LD_INT 24
70841: DOUBLE
70842: EQUAL
70843: IFTRUE 70847
70845: GO 70873
70847: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70848: LD_ADDR_VAR 0 3
70852: PUSH
70853: LD_INT 11
70855: PUSH
70856: LD_INT 12
70858: PUSH
70859: LD_INT 13
70861: PUSH
70862: LD_INT 14
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: ST_TO_ADDR
70871: GO 71380
70873: LD_INT 30
70875: DOUBLE
70876: EQUAL
70877: IFTRUE 70881
70879: GO 70907
70881: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70882: LD_ADDR_VAR 0 3
70886: PUSH
70887: LD_INT 11
70889: PUSH
70890: LD_INT 12
70892: PUSH
70893: LD_INT 13
70895: PUSH
70896: LD_INT 14
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: ST_TO_ADDR
70905: GO 71380
70907: LD_INT 25
70909: DOUBLE
70910: EQUAL
70911: IFTRUE 70915
70913: GO 70933
70915: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70916: LD_ADDR_VAR 0 3
70920: PUSH
70921: LD_INT 13
70923: PUSH
70924: LD_INT 14
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: ST_TO_ADDR
70931: GO 71380
70933: LD_INT 27
70935: DOUBLE
70936: EQUAL
70937: IFTRUE 70941
70939: GO 70959
70941: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70942: LD_ADDR_VAR 0 3
70946: PUSH
70947: LD_INT 13
70949: PUSH
70950: LD_INT 14
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: ST_TO_ADDR
70957: GO 71380
70959: LD_INT 28
70961: DOUBLE
70962: EQUAL
70963: IFTRUE 70967
70965: GO 70985
70967: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70968: LD_ADDR_VAR 0 3
70972: PUSH
70973: LD_INT 13
70975: PUSH
70976: LD_INT 14
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: ST_TO_ADDR
70983: GO 71380
70985: LD_INT 29
70987: DOUBLE
70988: EQUAL
70989: IFTRUE 70993
70991: GO 71011
70993: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70994: LD_ADDR_VAR 0 3
70998: PUSH
70999: LD_INT 13
71001: PUSH
71002: LD_INT 14
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: ST_TO_ADDR
71009: GO 71380
71011: LD_INT 31
71013: DOUBLE
71014: EQUAL
71015: IFTRUE 71019
71017: GO 71037
71019: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71020: LD_ADDR_VAR 0 3
71024: PUSH
71025: LD_INT 13
71027: PUSH
71028: LD_INT 14
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: ST_TO_ADDR
71035: GO 71380
71037: LD_INT 26
71039: DOUBLE
71040: EQUAL
71041: IFTRUE 71045
71043: GO 71063
71045: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71046: LD_ADDR_VAR 0 3
71050: PUSH
71051: LD_INT 13
71053: PUSH
71054: LD_INT 14
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: ST_TO_ADDR
71061: GO 71380
71063: LD_INT 42
71065: DOUBLE
71066: EQUAL
71067: IFTRUE 71071
71069: GO 71097
71071: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71072: LD_ADDR_VAR 0 3
71076: PUSH
71077: LD_INT 21
71079: PUSH
71080: LD_INT 22
71082: PUSH
71083: LD_INT 23
71085: PUSH
71086: LD_INT 24
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: ST_TO_ADDR
71095: GO 71380
71097: LD_INT 43
71099: DOUBLE
71100: EQUAL
71101: IFTRUE 71105
71103: GO 71131
71105: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71106: LD_ADDR_VAR 0 3
71110: PUSH
71111: LD_INT 21
71113: PUSH
71114: LD_INT 22
71116: PUSH
71117: LD_INT 23
71119: PUSH
71120: LD_INT 24
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: ST_TO_ADDR
71129: GO 71380
71131: LD_INT 44
71133: DOUBLE
71134: EQUAL
71135: IFTRUE 71139
71137: GO 71165
71139: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71140: LD_ADDR_VAR 0 3
71144: PUSH
71145: LD_INT 21
71147: PUSH
71148: LD_INT 22
71150: PUSH
71151: LD_INT 23
71153: PUSH
71154: LD_INT 24
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: ST_TO_ADDR
71163: GO 71380
71165: LD_INT 45
71167: DOUBLE
71168: EQUAL
71169: IFTRUE 71173
71171: GO 71199
71173: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71174: LD_ADDR_VAR 0 3
71178: PUSH
71179: LD_INT 21
71181: PUSH
71182: LD_INT 22
71184: PUSH
71185: LD_INT 23
71187: PUSH
71188: LD_INT 24
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: LIST
71195: LIST
71196: ST_TO_ADDR
71197: GO 71380
71199: LD_INT 49
71201: DOUBLE
71202: EQUAL
71203: IFTRUE 71207
71205: GO 71233
71207: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71208: LD_ADDR_VAR 0 3
71212: PUSH
71213: LD_INT 21
71215: PUSH
71216: LD_INT 22
71218: PUSH
71219: LD_INT 23
71221: PUSH
71222: LD_INT 24
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: ST_TO_ADDR
71231: GO 71380
71233: LD_INT 51
71235: DOUBLE
71236: EQUAL
71237: IFTRUE 71241
71239: GO 71267
71241: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71242: LD_ADDR_VAR 0 3
71246: PUSH
71247: LD_INT 21
71249: PUSH
71250: LD_INT 22
71252: PUSH
71253: LD_INT 23
71255: PUSH
71256: LD_INT 24
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: ST_TO_ADDR
71265: GO 71380
71267: LD_INT 52
71269: DOUBLE
71270: EQUAL
71271: IFTRUE 71275
71273: GO 71301
71275: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71276: LD_ADDR_VAR 0 3
71280: PUSH
71281: LD_INT 21
71283: PUSH
71284: LD_INT 22
71286: PUSH
71287: LD_INT 23
71289: PUSH
71290: LD_INT 24
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: ST_TO_ADDR
71299: GO 71380
71301: LD_INT 53
71303: DOUBLE
71304: EQUAL
71305: IFTRUE 71309
71307: GO 71327
71309: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71310: LD_ADDR_VAR 0 3
71314: PUSH
71315: LD_INT 23
71317: PUSH
71318: LD_INT 24
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: ST_TO_ADDR
71325: GO 71380
71327: LD_INT 46
71329: DOUBLE
71330: EQUAL
71331: IFTRUE 71335
71333: GO 71353
71335: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71336: LD_ADDR_VAR 0 3
71340: PUSH
71341: LD_INT 23
71343: PUSH
71344: LD_INT 24
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: ST_TO_ADDR
71351: GO 71380
71353: LD_INT 47
71355: DOUBLE
71356: EQUAL
71357: IFTRUE 71361
71359: GO 71379
71361: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71362: LD_ADDR_VAR 0 3
71366: PUSH
71367: LD_INT 23
71369: PUSH
71370: LD_INT 24
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: ST_TO_ADDR
71377: GO 71380
71379: POP
// result := ( chassis in result ) ;
71380: LD_ADDR_VAR 0 3
71384: PUSH
71385: LD_VAR 0 1
71389: PUSH
71390: LD_VAR 0 3
71394: IN
71395: ST_TO_ADDR
// end ;
71396: LD_VAR 0 3
71400: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71401: LD_INT 0
71403: PPUSH
71404: PPUSH
71405: PPUSH
71406: PPUSH
71407: PPUSH
71408: PPUSH
71409: PPUSH
// result := array ;
71410: LD_ADDR_VAR 0 5
71414: PUSH
71415: LD_VAR 0 1
71419: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71420: LD_VAR 0 1
71424: NOT
71425: PUSH
71426: LD_VAR 0 2
71430: NOT
71431: OR
71432: PUSH
71433: LD_VAR 0 3
71437: NOT
71438: OR
71439: PUSH
71440: LD_VAR 0 2
71444: PUSH
71445: LD_VAR 0 1
71449: GREATER
71450: OR
71451: PUSH
71452: LD_VAR 0 3
71456: PUSH
71457: LD_VAR 0 1
71461: GREATER
71462: OR
71463: IFFALSE 71467
// exit ;
71465: GO 71763
// if direction then
71467: LD_VAR 0 4
71471: IFFALSE 71535
// begin d := 1 ;
71473: LD_ADDR_VAR 0 9
71477: PUSH
71478: LD_INT 1
71480: ST_TO_ADDR
// if i_from > i_to then
71481: LD_VAR 0 2
71485: PUSH
71486: LD_VAR 0 3
71490: GREATER
71491: IFFALSE 71517
// length := ( array - i_from ) + i_to else
71493: LD_ADDR_VAR 0 11
71497: PUSH
71498: LD_VAR 0 1
71502: PUSH
71503: LD_VAR 0 2
71507: MINUS
71508: PUSH
71509: LD_VAR 0 3
71513: PLUS
71514: ST_TO_ADDR
71515: GO 71533
// length := i_to - i_from ;
71517: LD_ADDR_VAR 0 11
71521: PUSH
71522: LD_VAR 0 3
71526: PUSH
71527: LD_VAR 0 2
71531: MINUS
71532: ST_TO_ADDR
// end else
71533: GO 71596
// begin d := - 1 ;
71535: LD_ADDR_VAR 0 9
71539: PUSH
71540: LD_INT 1
71542: NEG
71543: ST_TO_ADDR
// if i_from > i_to then
71544: LD_VAR 0 2
71548: PUSH
71549: LD_VAR 0 3
71553: GREATER
71554: IFFALSE 71574
// length := i_from - i_to else
71556: LD_ADDR_VAR 0 11
71560: PUSH
71561: LD_VAR 0 2
71565: PUSH
71566: LD_VAR 0 3
71570: MINUS
71571: ST_TO_ADDR
71572: GO 71596
// length := ( array - i_to ) + i_from ;
71574: LD_ADDR_VAR 0 11
71578: PUSH
71579: LD_VAR 0 1
71583: PUSH
71584: LD_VAR 0 3
71588: MINUS
71589: PUSH
71590: LD_VAR 0 2
71594: PLUS
71595: ST_TO_ADDR
// end ; if not length then
71596: LD_VAR 0 11
71600: NOT
71601: IFFALSE 71605
// exit ;
71603: GO 71763
// tmp := array ;
71605: LD_ADDR_VAR 0 10
71609: PUSH
71610: LD_VAR 0 1
71614: ST_TO_ADDR
// for i = 1 to length do
71615: LD_ADDR_VAR 0 6
71619: PUSH
71620: DOUBLE
71621: LD_INT 1
71623: DEC
71624: ST_TO_ADDR
71625: LD_VAR 0 11
71629: PUSH
71630: FOR_TO
71631: IFFALSE 71751
// begin for j = 1 to array do
71633: LD_ADDR_VAR 0 7
71637: PUSH
71638: DOUBLE
71639: LD_INT 1
71641: DEC
71642: ST_TO_ADDR
71643: LD_VAR 0 1
71647: PUSH
71648: FOR_TO
71649: IFFALSE 71737
// begin k := j + d ;
71651: LD_ADDR_VAR 0 8
71655: PUSH
71656: LD_VAR 0 7
71660: PUSH
71661: LD_VAR 0 9
71665: PLUS
71666: ST_TO_ADDR
// if k > array then
71667: LD_VAR 0 8
71671: PUSH
71672: LD_VAR 0 1
71676: GREATER
71677: IFFALSE 71687
// k := 1 ;
71679: LD_ADDR_VAR 0 8
71683: PUSH
71684: LD_INT 1
71686: ST_TO_ADDR
// if not k then
71687: LD_VAR 0 8
71691: NOT
71692: IFFALSE 71704
// k := array ;
71694: LD_ADDR_VAR 0 8
71698: PUSH
71699: LD_VAR 0 1
71703: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71704: LD_ADDR_VAR 0 10
71708: PUSH
71709: LD_VAR 0 10
71713: PPUSH
71714: LD_VAR 0 8
71718: PPUSH
71719: LD_VAR 0 1
71723: PUSH
71724: LD_VAR 0 7
71728: ARRAY
71729: PPUSH
71730: CALL_OW 1
71734: ST_TO_ADDR
// end ;
71735: GO 71648
71737: POP
71738: POP
// array := tmp ;
71739: LD_ADDR_VAR 0 1
71743: PUSH
71744: LD_VAR 0 10
71748: ST_TO_ADDR
// end ;
71749: GO 71630
71751: POP
71752: POP
// result := array ;
71753: LD_ADDR_VAR 0 5
71757: PUSH
71758: LD_VAR 0 1
71762: ST_TO_ADDR
// end ;
71763: LD_VAR 0 5
71767: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71768: LD_INT 0
71770: PPUSH
71771: PPUSH
// result := 0 ;
71772: LD_ADDR_VAR 0 3
71776: PUSH
71777: LD_INT 0
71779: ST_TO_ADDR
// if not array or not value in array then
71780: LD_VAR 0 1
71784: NOT
71785: PUSH
71786: LD_VAR 0 2
71790: PUSH
71791: LD_VAR 0 1
71795: IN
71796: NOT
71797: OR
71798: IFFALSE 71802
// exit ;
71800: GO 71856
// for i = 1 to array do
71802: LD_ADDR_VAR 0 4
71806: PUSH
71807: DOUBLE
71808: LD_INT 1
71810: DEC
71811: ST_TO_ADDR
71812: LD_VAR 0 1
71816: PUSH
71817: FOR_TO
71818: IFFALSE 71854
// if value = array [ i ] then
71820: LD_VAR 0 2
71824: PUSH
71825: LD_VAR 0 1
71829: PUSH
71830: LD_VAR 0 4
71834: ARRAY
71835: EQUAL
71836: IFFALSE 71852
// begin result := i ;
71838: LD_ADDR_VAR 0 3
71842: PUSH
71843: LD_VAR 0 4
71847: ST_TO_ADDR
// exit ;
71848: POP
71849: POP
71850: GO 71856
// end ;
71852: GO 71817
71854: POP
71855: POP
// end ;
71856: LD_VAR 0 3
71860: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71861: LD_INT 0
71863: PPUSH
// vc_chassis := chassis ;
71864: LD_ADDR_OWVAR 37
71868: PUSH
71869: LD_VAR 0 1
71873: ST_TO_ADDR
// vc_engine := engine ;
71874: LD_ADDR_OWVAR 39
71878: PUSH
71879: LD_VAR 0 2
71883: ST_TO_ADDR
// vc_control := control ;
71884: LD_ADDR_OWVAR 38
71888: PUSH
71889: LD_VAR 0 3
71893: ST_TO_ADDR
// vc_weapon := weapon ;
71894: LD_ADDR_OWVAR 40
71898: PUSH
71899: LD_VAR 0 4
71903: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71904: LD_ADDR_OWVAR 41
71908: PUSH
71909: LD_VAR 0 5
71913: ST_TO_ADDR
// end ;
71914: LD_VAR 0 6
71918: RET
// export function WantPlant ( unit ) ; var task ; begin
71919: LD_INT 0
71921: PPUSH
71922: PPUSH
// result := false ;
71923: LD_ADDR_VAR 0 2
71927: PUSH
71928: LD_INT 0
71930: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71931: LD_ADDR_VAR 0 3
71935: PUSH
71936: LD_VAR 0 1
71940: PPUSH
71941: CALL_OW 437
71945: ST_TO_ADDR
// if task then
71946: LD_VAR 0 3
71950: IFFALSE 71978
// if task [ 1 ] [ 1 ] = p then
71952: LD_VAR 0 3
71956: PUSH
71957: LD_INT 1
71959: ARRAY
71960: PUSH
71961: LD_INT 1
71963: ARRAY
71964: PUSH
71965: LD_STRING p
71967: EQUAL
71968: IFFALSE 71978
// result := true ;
71970: LD_ADDR_VAR 0 2
71974: PUSH
71975: LD_INT 1
71977: ST_TO_ADDR
// end ;
71978: LD_VAR 0 2
71982: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71983: LD_INT 0
71985: PPUSH
71986: PPUSH
71987: PPUSH
71988: PPUSH
// if pos < 1 then
71989: LD_VAR 0 2
71993: PUSH
71994: LD_INT 1
71996: LESS
71997: IFFALSE 72001
// exit ;
71999: GO 72304
// if pos = 1 then
72001: LD_VAR 0 2
72005: PUSH
72006: LD_INT 1
72008: EQUAL
72009: IFFALSE 72042
// result := Replace ( arr , pos [ 1 ] , value ) else
72011: LD_ADDR_VAR 0 4
72015: PUSH
72016: LD_VAR 0 1
72020: PPUSH
72021: LD_VAR 0 2
72025: PUSH
72026: LD_INT 1
72028: ARRAY
72029: PPUSH
72030: LD_VAR 0 3
72034: PPUSH
72035: CALL_OW 1
72039: ST_TO_ADDR
72040: GO 72304
// begin tmp := arr ;
72042: LD_ADDR_VAR 0 6
72046: PUSH
72047: LD_VAR 0 1
72051: ST_TO_ADDR
// s_arr := [ tmp ] ;
72052: LD_ADDR_VAR 0 7
72056: PUSH
72057: LD_VAR 0 6
72061: PUSH
72062: EMPTY
72063: LIST
72064: ST_TO_ADDR
// for i = 1 to pos - 1 do
72065: LD_ADDR_VAR 0 5
72069: PUSH
72070: DOUBLE
72071: LD_INT 1
72073: DEC
72074: ST_TO_ADDR
72075: LD_VAR 0 2
72079: PUSH
72080: LD_INT 1
72082: MINUS
72083: PUSH
72084: FOR_TO
72085: IFFALSE 72130
// begin tmp := tmp [ pos [ i ] ] ;
72087: LD_ADDR_VAR 0 6
72091: PUSH
72092: LD_VAR 0 6
72096: PUSH
72097: LD_VAR 0 2
72101: PUSH
72102: LD_VAR 0 5
72106: ARRAY
72107: ARRAY
72108: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72109: LD_ADDR_VAR 0 7
72113: PUSH
72114: LD_VAR 0 7
72118: PUSH
72119: LD_VAR 0 6
72123: PUSH
72124: EMPTY
72125: LIST
72126: ADD
72127: ST_TO_ADDR
// end ;
72128: GO 72084
72130: POP
72131: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72132: LD_ADDR_VAR 0 6
72136: PUSH
72137: LD_VAR 0 6
72141: PPUSH
72142: LD_VAR 0 2
72146: PUSH
72147: LD_VAR 0 2
72151: ARRAY
72152: PPUSH
72153: LD_VAR 0 3
72157: PPUSH
72158: CALL_OW 1
72162: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72163: LD_ADDR_VAR 0 7
72167: PUSH
72168: LD_VAR 0 7
72172: PPUSH
72173: LD_VAR 0 7
72177: PPUSH
72178: LD_VAR 0 6
72182: PPUSH
72183: CALL_OW 1
72187: ST_TO_ADDR
// for i = s_arr downto 2 do
72188: LD_ADDR_VAR 0 5
72192: PUSH
72193: DOUBLE
72194: LD_VAR 0 7
72198: INC
72199: ST_TO_ADDR
72200: LD_INT 2
72202: PUSH
72203: FOR_DOWNTO
72204: IFFALSE 72288
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72206: LD_ADDR_VAR 0 6
72210: PUSH
72211: LD_VAR 0 7
72215: PUSH
72216: LD_VAR 0 5
72220: PUSH
72221: LD_INT 1
72223: MINUS
72224: ARRAY
72225: PPUSH
72226: LD_VAR 0 2
72230: PUSH
72231: LD_VAR 0 5
72235: PUSH
72236: LD_INT 1
72238: MINUS
72239: ARRAY
72240: PPUSH
72241: LD_VAR 0 7
72245: PUSH
72246: LD_VAR 0 5
72250: ARRAY
72251: PPUSH
72252: CALL_OW 1
72256: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72257: LD_ADDR_VAR 0 7
72261: PUSH
72262: LD_VAR 0 7
72266: PPUSH
72267: LD_VAR 0 5
72271: PUSH
72272: LD_INT 1
72274: MINUS
72275: PPUSH
72276: LD_VAR 0 6
72280: PPUSH
72281: CALL_OW 1
72285: ST_TO_ADDR
// end ;
72286: GO 72203
72288: POP
72289: POP
// result := s_arr [ 1 ] ;
72290: LD_ADDR_VAR 0 4
72294: PUSH
72295: LD_VAR 0 7
72299: PUSH
72300: LD_INT 1
72302: ARRAY
72303: ST_TO_ADDR
// end ; end ;
72304: LD_VAR 0 4
72308: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72309: LD_INT 0
72311: PPUSH
72312: PPUSH
// if not list then
72313: LD_VAR 0 1
72317: NOT
72318: IFFALSE 72322
// exit ;
72320: GO 72413
// i := list [ pos1 ] ;
72322: LD_ADDR_VAR 0 5
72326: PUSH
72327: LD_VAR 0 1
72331: PUSH
72332: LD_VAR 0 2
72336: ARRAY
72337: ST_TO_ADDR
// if not i then
72338: LD_VAR 0 5
72342: NOT
72343: IFFALSE 72347
// exit ;
72345: GO 72413
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72347: LD_ADDR_VAR 0 1
72351: PUSH
72352: LD_VAR 0 1
72356: PPUSH
72357: LD_VAR 0 2
72361: PPUSH
72362: LD_VAR 0 1
72366: PUSH
72367: LD_VAR 0 3
72371: ARRAY
72372: PPUSH
72373: CALL_OW 1
72377: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72378: LD_ADDR_VAR 0 1
72382: PUSH
72383: LD_VAR 0 1
72387: PPUSH
72388: LD_VAR 0 3
72392: PPUSH
72393: LD_VAR 0 5
72397: PPUSH
72398: CALL_OW 1
72402: ST_TO_ADDR
// result := list ;
72403: LD_ADDR_VAR 0 4
72407: PUSH
72408: LD_VAR 0 1
72412: ST_TO_ADDR
// end ;
72413: LD_VAR 0 4
72417: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72418: LD_INT 0
72420: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72421: LD_ADDR_VAR 0 5
72425: PUSH
72426: LD_VAR 0 1
72430: PPUSH
72431: CALL_OW 250
72435: PPUSH
72436: LD_VAR 0 1
72440: PPUSH
72441: CALL_OW 251
72445: PPUSH
72446: LD_VAR 0 2
72450: PPUSH
72451: LD_VAR 0 3
72455: PPUSH
72456: LD_VAR 0 4
72460: PPUSH
72461: CALL 72471 0 5
72465: ST_TO_ADDR
// end ;
72466: LD_VAR 0 5
72470: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72471: LD_INT 0
72473: PPUSH
72474: PPUSH
72475: PPUSH
72476: PPUSH
// if not list then
72477: LD_VAR 0 3
72481: NOT
72482: IFFALSE 72486
// exit ;
72484: GO 72874
// result := [ ] ;
72486: LD_ADDR_VAR 0 6
72490: PUSH
72491: EMPTY
72492: ST_TO_ADDR
// for i in list do
72493: LD_ADDR_VAR 0 7
72497: PUSH
72498: LD_VAR 0 3
72502: PUSH
72503: FOR_IN
72504: IFFALSE 72706
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72506: LD_ADDR_VAR 0 9
72510: PUSH
72511: LD_VAR 0 7
72515: PPUSH
72516: LD_VAR 0 1
72520: PPUSH
72521: LD_VAR 0 2
72525: PPUSH
72526: CALL_OW 297
72530: ST_TO_ADDR
// if not result then
72531: LD_VAR 0 6
72535: NOT
72536: IFFALSE 72562
// result := [ [ i , tmp ] ] else
72538: LD_ADDR_VAR 0 6
72542: PUSH
72543: LD_VAR 0 7
72547: PUSH
72548: LD_VAR 0 9
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: EMPTY
72558: LIST
72559: ST_TO_ADDR
72560: GO 72704
// begin if result [ result ] [ 2 ] < tmp then
72562: LD_VAR 0 6
72566: PUSH
72567: LD_VAR 0 6
72571: ARRAY
72572: PUSH
72573: LD_INT 2
72575: ARRAY
72576: PUSH
72577: LD_VAR 0 9
72581: LESS
72582: IFFALSE 72624
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72584: LD_ADDR_VAR 0 6
72588: PUSH
72589: LD_VAR 0 6
72593: PPUSH
72594: LD_VAR 0 6
72598: PUSH
72599: LD_INT 1
72601: PLUS
72602: PPUSH
72603: LD_VAR 0 7
72607: PUSH
72608: LD_VAR 0 9
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PPUSH
72617: CALL_OW 2
72621: ST_TO_ADDR
72622: GO 72704
// for j = 1 to result do
72624: LD_ADDR_VAR 0 8
72628: PUSH
72629: DOUBLE
72630: LD_INT 1
72632: DEC
72633: ST_TO_ADDR
72634: LD_VAR 0 6
72638: PUSH
72639: FOR_TO
72640: IFFALSE 72702
// begin if tmp < result [ j ] [ 2 ] then
72642: LD_VAR 0 9
72646: PUSH
72647: LD_VAR 0 6
72651: PUSH
72652: LD_VAR 0 8
72656: ARRAY
72657: PUSH
72658: LD_INT 2
72660: ARRAY
72661: LESS
72662: IFFALSE 72700
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72664: LD_ADDR_VAR 0 6
72668: PUSH
72669: LD_VAR 0 6
72673: PPUSH
72674: LD_VAR 0 8
72678: PPUSH
72679: LD_VAR 0 7
72683: PUSH
72684: LD_VAR 0 9
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PPUSH
72693: CALL_OW 2
72697: ST_TO_ADDR
// break ;
72698: GO 72702
// end ; end ;
72700: GO 72639
72702: POP
72703: POP
// end ; end ;
72704: GO 72503
72706: POP
72707: POP
// if result and not asc then
72708: LD_VAR 0 6
72712: PUSH
72713: LD_VAR 0 4
72717: NOT
72718: AND
72719: IFFALSE 72794
// begin tmp := result ;
72721: LD_ADDR_VAR 0 9
72725: PUSH
72726: LD_VAR 0 6
72730: ST_TO_ADDR
// for i = tmp downto 1 do
72731: LD_ADDR_VAR 0 7
72735: PUSH
72736: DOUBLE
72737: LD_VAR 0 9
72741: INC
72742: ST_TO_ADDR
72743: LD_INT 1
72745: PUSH
72746: FOR_DOWNTO
72747: IFFALSE 72792
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72749: LD_ADDR_VAR 0 6
72753: PUSH
72754: LD_VAR 0 6
72758: PPUSH
72759: LD_VAR 0 9
72763: PUSH
72764: LD_VAR 0 7
72768: MINUS
72769: PUSH
72770: LD_INT 1
72772: PLUS
72773: PPUSH
72774: LD_VAR 0 9
72778: PUSH
72779: LD_VAR 0 7
72783: ARRAY
72784: PPUSH
72785: CALL_OW 1
72789: ST_TO_ADDR
72790: GO 72746
72792: POP
72793: POP
// end ; tmp := [ ] ;
72794: LD_ADDR_VAR 0 9
72798: PUSH
72799: EMPTY
72800: ST_TO_ADDR
// if mode then
72801: LD_VAR 0 5
72805: IFFALSE 72874
// begin for i = 1 to result do
72807: LD_ADDR_VAR 0 7
72811: PUSH
72812: DOUBLE
72813: LD_INT 1
72815: DEC
72816: ST_TO_ADDR
72817: LD_VAR 0 6
72821: PUSH
72822: FOR_TO
72823: IFFALSE 72862
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72825: LD_ADDR_VAR 0 9
72829: PUSH
72830: LD_VAR 0 9
72834: PPUSH
72835: LD_VAR 0 7
72839: PPUSH
72840: LD_VAR 0 6
72844: PUSH
72845: LD_VAR 0 7
72849: ARRAY
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: PPUSH
72855: CALL_OW 1
72859: ST_TO_ADDR
72860: GO 72822
72862: POP
72863: POP
// result := tmp ;
72864: LD_ADDR_VAR 0 6
72868: PUSH
72869: LD_VAR 0 9
72873: ST_TO_ADDR
// end ; end ;
72874: LD_VAR 0 6
72878: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72879: LD_INT 0
72881: PPUSH
72882: PPUSH
72883: PPUSH
72884: PPUSH
72885: PPUSH
72886: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72887: LD_ADDR_VAR 0 5
72891: PUSH
72892: LD_INT 0
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: EMPTY
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: ST_TO_ADDR
// if not x or not y then
72909: LD_VAR 0 2
72913: NOT
72914: PUSH
72915: LD_VAR 0 3
72919: NOT
72920: OR
72921: IFFALSE 72925
// exit ;
72923: GO 74571
// if not range then
72925: LD_VAR 0 4
72929: NOT
72930: IFFALSE 72940
// range := 10 ;
72932: LD_ADDR_VAR 0 4
72936: PUSH
72937: LD_INT 10
72939: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72940: LD_ADDR_VAR 0 8
72944: PUSH
72945: LD_INT 81
72947: PUSH
72948: LD_VAR 0 1
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 92
72959: PUSH
72960: LD_VAR 0 2
72964: PUSH
72965: LD_VAR 0 3
72969: PUSH
72970: LD_VAR 0 4
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 3
72983: PUSH
72984: LD_INT 21
72986: PUSH
72987: LD_INT 3
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: PPUSH
73003: CALL_OW 69
73007: ST_TO_ADDR
// if not tmp then
73008: LD_VAR 0 8
73012: NOT
73013: IFFALSE 73017
// exit ;
73015: GO 74571
// for i in tmp do
73017: LD_ADDR_VAR 0 6
73021: PUSH
73022: LD_VAR 0 8
73026: PUSH
73027: FOR_IN
73028: IFFALSE 74546
// begin points := [ 0 , 0 , 0 ] ;
73030: LD_ADDR_VAR 0 9
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: LIST
73048: ST_TO_ADDR
// bpoints := 1 ;
73049: LD_ADDR_VAR 0 10
73053: PUSH
73054: LD_INT 1
73056: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73057: LD_VAR 0 6
73061: PPUSH
73062: CALL_OW 247
73066: PUSH
73067: LD_INT 1
73069: DOUBLE
73070: EQUAL
73071: IFTRUE 73075
73073: GO 73653
73075: POP
// begin if GetClass ( i ) = 1 then
73076: LD_VAR 0 6
73080: PPUSH
73081: CALL_OW 257
73085: PUSH
73086: LD_INT 1
73088: EQUAL
73089: IFFALSE 73110
// points := [ 10 , 5 , 3 ] ;
73091: LD_ADDR_VAR 0 9
73095: PUSH
73096: LD_INT 10
73098: PUSH
73099: LD_INT 5
73101: PUSH
73102: LD_INT 3
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: LIST
73109: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73110: LD_VAR 0 6
73114: PPUSH
73115: CALL_OW 257
73119: PUSH
73120: LD_INT 2
73122: PUSH
73123: LD_INT 3
73125: PUSH
73126: LD_INT 4
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: LIST
73133: IN
73134: IFFALSE 73155
// points := [ 3 , 2 , 1 ] ;
73136: LD_ADDR_VAR 0 9
73140: PUSH
73141: LD_INT 3
73143: PUSH
73144: LD_INT 2
73146: PUSH
73147: LD_INT 1
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: LIST
73154: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73155: LD_VAR 0 6
73159: PPUSH
73160: CALL_OW 257
73164: PUSH
73165: LD_INT 5
73167: EQUAL
73168: IFFALSE 73189
// points := [ 130 , 5 , 2 ] ;
73170: LD_ADDR_VAR 0 9
73174: PUSH
73175: LD_INT 130
73177: PUSH
73178: LD_INT 5
73180: PUSH
73181: LD_INT 2
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: LIST
73188: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73189: LD_VAR 0 6
73193: PPUSH
73194: CALL_OW 257
73198: PUSH
73199: LD_INT 8
73201: EQUAL
73202: IFFALSE 73223
// points := [ 35 , 35 , 30 ] ;
73204: LD_ADDR_VAR 0 9
73208: PUSH
73209: LD_INT 35
73211: PUSH
73212: LD_INT 35
73214: PUSH
73215: LD_INT 30
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: LIST
73222: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73223: LD_VAR 0 6
73227: PPUSH
73228: CALL_OW 257
73232: PUSH
73233: LD_INT 9
73235: EQUAL
73236: IFFALSE 73257
// points := [ 20 , 55 , 40 ] ;
73238: LD_ADDR_VAR 0 9
73242: PUSH
73243: LD_INT 20
73245: PUSH
73246: LD_INT 55
73248: PUSH
73249: LD_INT 40
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: LIST
73256: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73257: LD_VAR 0 6
73261: PPUSH
73262: CALL_OW 257
73266: PUSH
73267: LD_INT 12
73269: PUSH
73270: LD_INT 16
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: IN
73277: IFFALSE 73298
// points := [ 5 , 3 , 2 ] ;
73279: LD_ADDR_VAR 0 9
73283: PUSH
73284: LD_INT 5
73286: PUSH
73287: LD_INT 3
73289: PUSH
73290: LD_INT 2
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73298: LD_VAR 0 6
73302: PPUSH
73303: CALL_OW 257
73307: PUSH
73308: LD_INT 17
73310: EQUAL
73311: IFFALSE 73332
// points := [ 100 , 50 , 75 ] ;
73313: LD_ADDR_VAR 0 9
73317: PUSH
73318: LD_INT 100
73320: PUSH
73321: LD_INT 50
73323: PUSH
73324: LD_INT 75
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: LIST
73331: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73332: LD_VAR 0 6
73336: PPUSH
73337: CALL_OW 257
73341: PUSH
73342: LD_INT 15
73344: EQUAL
73345: IFFALSE 73366
// points := [ 10 , 5 , 3 ] ;
73347: LD_ADDR_VAR 0 9
73351: PUSH
73352: LD_INT 10
73354: PUSH
73355: LD_INT 5
73357: PUSH
73358: LD_INT 3
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: LIST
73365: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73366: LD_VAR 0 6
73370: PPUSH
73371: CALL_OW 257
73375: PUSH
73376: LD_INT 14
73378: EQUAL
73379: IFFALSE 73400
// points := [ 10 , 0 , 0 ] ;
73381: LD_ADDR_VAR 0 9
73385: PUSH
73386: LD_INT 10
73388: PUSH
73389: LD_INT 0
73391: PUSH
73392: LD_INT 0
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: LIST
73399: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73400: LD_VAR 0 6
73404: PPUSH
73405: CALL_OW 257
73409: PUSH
73410: LD_INT 11
73412: EQUAL
73413: IFFALSE 73434
// points := [ 30 , 10 , 5 ] ;
73415: LD_ADDR_VAR 0 9
73419: PUSH
73420: LD_INT 30
73422: PUSH
73423: LD_INT 10
73425: PUSH
73426: LD_INT 5
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: LIST
73433: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73434: LD_VAR 0 1
73438: PPUSH
73439: LD_INT 5
73441: PPUSH
73442: CALL_OW 321
73446: PUSH
73447: LD_INT 2
73449: EQUAL
73450: IFFALSE 73467
// bpoints := bpoints * 1.8 ;
73452: LD_ADDR_VAR 0 10
73456: PUSH
73457: LD_VAR 0 10
73461: PUSH
73462: LD_REAL  1.80000000000000E+0000
73465: MUL
73466: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73467: LD_VAR 0 6
73471: PPUSH
73472: CALL_OW 257
73476: PUSH
73477: LD_INT 1
73479: PUSH
73480: LD_INT 2
73482: PUSH
73483: LD_INT 3
73485: PUSH
73486: LD_INT 4
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: IN
73495: PUSH
73496: LD_VAR 0 1
73500: PPUSH
73501: LD_INT 51
73503: PPUSH
73504: CALL_OW 321
73508: PUSH
73509: LD_INT 2
73511: EQUAL
73512: AND
73513: IFFALSE 73530
// bpoints := bpoints * 1.2 ;
73515: LD_ADDR_VAR 0 10
73519: PUSH
73520: LD_VAR 0 10
73524: PUSH
73525: LD_REAL  1.20000000000000E+0000
73528: MUL
73529: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73530: LD_VAR 0 6
73534: PPUSH
73535: CALL_OW 257
73539: PUSH
73540: LD_INT 5
73542: PUSH
73543: LD_INT 7
73545: PUSH
73546: LD_INT 9
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: LIST
73553: IN
73554: PUSH
73555: LD_VAR 0 1
73559: PPUSH
73560: LD_INT 52
73562: PPUSH
73563: CALL_OW 321
73567: PUSH
73568: LD_INT 2
73570: EQUAL
73571: AND
73572: IFFALSE 73589
// bpoints := bpoints * 1.5 ;
73574: LD_ADDR_VAR 0 10
73578: PUSH
73579: LD_VAR 0 10
73583: PUSH
73584: LD_REAL  1.50000000000000E+0000
73587: MUL
73588: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73589: LD_VAR 0 1
73593: PPUSH
73594: LD_INT 66
73596: PPUSH
73597: CALL_OW 321
73601: PUSH
73602: LD_INT 2
73604: EQUAL
73605: IFFALSE 73622
// bpoints := bpoints * 1.1 ;
73607: LD_ADDR_VAR 0 10
73611: PUSH
73612: LD_VAR 0 10
73616: PUSH
73617: LD_REAL  1.10000000000000E+0000
73620: MUL
73621: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73622: LD_ADDR_VAR 0 10
73626: PUSH
73627: LD_VAR 0 10
73631: PUSH
73632: LD_VAR 0 6
73636: PPUSH
73637: LD_INT 1
73639: PPUSH
73640: CALL_OW 259
73644: PUSH
73645: LD_REAL  1.15000000000000E+0000
73648: MUL
73649: MUL
73650: ST_TO_ADDR
// end ; unit_vehicle :
73651: GO 74475
73653: LD_INT 2
73655: DOUBLE
73656: EQUAL
73657: IFTRUE 73661
73659: GO 74463
73661: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73662: LD_VAR 0 6
73666: PPUSH
73667: CALL_OW 264
73671: PUSH
73672: LD_INT 2
73674: PUSH
73675: LD_INT 42
73677: PUSH
73678: LD_INT 24
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: LIST
73685: IN
73686: IFFALSE 73707
// points := [ 25 , 5 , 3 ] ;
73688: LD_ADDR_VAR 0 9
73692: PUSH
73693: LD_INT 25
73695: PUSH
73696: LD_INT 5
73698: PUSH
73699: LD_INT 3
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: LIST
73706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73707: LD_VAR 0 6
73711: PPUSH
73712: CALL_OW 264
73716: PUSH
73717: LD_INT 4
73719: PUSH
73720: LD_INT 43
73722: PUSH
73723: LD_INT 25
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: LIST
73730: IN
73731: IFFALSE 73752
// points := [ 40 , 15 , 5 ] ;
73733: LD_ADDR_VAR 0 9
73737: PUSH
73738: LD_INT 40
73740: PUSH
73741: LD_INT 15
73743: PUSH
73744: LD_INT 5
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: LIST
73751: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73752: LD_VAR 0 6
73756: PPUSH
73757: CALL_OW 264
73761: PUSH
73762: LD_INT 3
73764: PUSH
73765: LD_INT 23
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: IN
73772: IFFALSE 73793
// points := [ 7 , 25 , 8 ] ;
73774: LD_ADDR_VAR 0 9
73778: PUSH
73779: LD_INT 7
73781: PUSH
73782: LD_INT 25
73784: PUSH
73785: LD_INT 8
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: LIST
73792: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73793: LD_VAR 0 6
73797: PPUSH
73798: CALL_OW 264
73802: PUSH
73803: LD_INT 5
73805: PUSH
73806: LD_INT 27
73808: PUSH
73809: LD_INT 44
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: LIST
73816: IN
73817: IFFALSE 73838
// points := [ 14 , 50 , 16 ] ;
73819: LD_ADDR_VAR 0 9
73823: PUSH
73824: LD_INT 14
73826: PUSH
73827: LD_INT 50
73829: PUSH
73830: LD_INT 16
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: LIST
73837: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73838: LD_VAR 0 6
73842: PPUSH
73843: CALL_OW 264
73847: PUSH
73848: LD_INT 6
73850: PUSH
73851: LD_INT 46
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: IN
73858: IFFALSE 73879
// points := [ 32 , 120 , 70 ] ;
73860: LD_ADDR_VAR 0 9
73864: PUSH
73865: LD_INT 32
73867: PUSH
73868: LD_INT 120
73870: PUSH
73871: LD_INT 70
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73879: LD_VAR 0 6
73883: PPUSH
73884: CALL_OW 264
73888: PUSH
73889: LD_INT 7
73891: PUSH
73892: LD_INT 28
73894: PUSH
73895: LD_INT 45
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: LIST
73902: IN
73903: IFFALSE 73924
// points := [ 35 , 20 , 45 ] ;
73905: LD_ADDR_VAR 0 9
73909: PUSH
73910: LD_INT 35
73912: PUSH
73913: LD_INT 20
73915: PUSH
73916: LD_INT 45
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: LIST
73923: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73924: LD_VAR 0 6
73928: PPUSH
73929: CALL_OW 264
73933: PUSH
73934: LD_INT 47
73936: PUSH
73937: EMPTY
73938: LIST
73939: IN
73940: IFFALSE 73961
// points := [ 67 , 45 , 75 ] ;
73942: LD_ADDR_VAR 0 9
73946: PUSH
73947: LD_INT 67
73949: PUSH
73950: LD_INT 45
73952: PUSH
73953: LD_INT 75
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: LIST
73960: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73961: LD_VAR 0 6
73965: PPUSH
73966: CALL_OW 264
73970: PUSH
73971: LD_INT 26
73973: PUSH
73974: EMPTY
73975: LIST
73976: IN
73977: IFFALSE 73998
// points := [ 120 , 30 , 80 ] ;
73979: LD_ADDR_VAR 0 9
73983: PUSH
73984: LD_INT 120
73986: PUSH
73987: LD_INT 30
73989: PUSH
73990: LD_INT 80
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: LIST
73997: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73998: LD_VAR 0 6
74002: PPUSH
74003: CALL_OW 264
74007: PUSH
74008: LD_INT 22
74010: PUSH
74011: EMPTY
74012: LIST
74013: IN
74014: IFFALSE 74035
// points := [ 40 , 1 , 1 ] ;
74016: LD_ADDR_VAR 0 9
74020: PUSH
74021: LD_INT 40
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: LD_INT 1
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: LIST
74034: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74035: LD_VAR 0 6
74039: PPUSH
74040: CALL_OW 264
74044: PUSH
74045: LD_INT 29
74047: PUSH
74048: EMPTY
74049: LIST
74050: IN
74051: IFFALSE 74072
// points := [ 70 , 200 , 400 ] ;
74053: LD_ADDR_VAR 0 9
74057: PUSH
74058: LD_INT 70
74060: PUSH
74061: LD_INT 200
74063: PUSH
74064: LD_INT 400
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: LIST
74071: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74072: LD_VAR 0 6
74076: PPUSH
74077: CALL_OW 264
74081: PUSH
74082: LD_INT 14
74084: PUSH
74085: LD_INT 53
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: IN
74092: IFFALSE 74113
// points := [ 40 , 10 , 20 ] ;
74094: LD_ADDR_VAR 0 9
74098: PUSH
74099: LD_INT 40
74101: PUSH
74102: LD_INT 10
74104: PUSH
74105: LD_INT 20
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: LIST
74112: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74113: LD_VAR 0 6
74117: PPUSH
74118: CALL_OW 264
74122: PUSH
74123: LD_INT 9
74125: PUSH
74126: EMPTY
74127: LIST
74128: IN
74129: IFFALSE 74150
// points := [ 5 , 70 , 20 ] ;
74131: LD_ADDR_VAR 0 9
74135: PUSH
74136: LD_INT 5
74138: PUSH
74139: LD_INT 70
74141: PUSH
74142: LD_INT 20
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: LIST
74149: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74150: LD_VAR 0 6
74154: PPUSH
74155: CALL_OW 264
74159: PUSH
74160: LD_INT 10
74162: PUSH
74163: EMPTY
74164: LIST
74165: IN
74166: IFFALSE 74187
// points := [ 35 , 110 , 70 ] ;
74168: LD_ADDR_VAR 0 9
74172: PUSH
74173: LD_INT 35
74175: PUSH
74176: LD_INT 110
74178: PUSH
74179: LD_INT 70
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: LIST
74186: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74187: LD_VAR 0 6
74191: PPUSH
74192: CALL_OW 265
74196: PUSH
74197: LD_INT 25
74199: EQUAL
74200: IFFALSE 74221
// points := [ 80 , 65 , 100 ] ;
74202: LD_ADDR_VAR 0 9
74206: PUSH
74207: LD_INT 80
74209: PUSH
74210: LD_INT 65
74212: PUSH
74213: LD_INT 100
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: LIST
74220: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74221: LD_VAR 0 6
74225: PPUSH
74226: CALL_OW 263
74230: PUSH
74231: LD_INT 1
74233: EQUAL
74234: IFFALSE 74269
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74236: LD_ADDR_VAR 0 10
74240: PUSH
74241: LD_VAR 0 10
74245: PUSH
74246: LD_VAR 0 6
74250: PPUSH
74251: CALL_OW 311
74255: PPUSH
74256: LD_INT 3
74258: PPUSH
74259: CALL_OW 259
74263: PUSH
74264: LD_INT 4
74266: MUL
74267: MUL
74268: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74269: LD_VAR 0 6
74273: PPUSH
74274: CALL_OW 263
74278: PUSH
74279: LD_INT 2
74281: EQUAL
74282: IFFALSE 74333
// begin j := IsControledBy ( i ) ;
74284: LD_ADDR_VAR 0 7
74288: PUSH
74289: LD_VAR 0 6
74293: PPUSH
74294: CALL_OW 312
74298: ST_TO_ADDR
// if j then
74299: LD_VAR 0 7
74303: IFFALSE 74333
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74305: LD_ADDR_VAR 0 10
74309: PUSH
74310: LD_VAR 0 10
74314: PUSH
74315: LD_VAR 0 7
74319: PPUSH
74320: LD_INT 3
74322: PPUSH
74323: CALL_OW 259
74327: PUSH
74328: LD_INT 3
74330: MUL
74331: MUL
74332: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74333: LD_VAR 0 6
74337: PPUSH
74338: CALL_OW 264
74342: PUSH
74343: LD_INT 5
74345: PUSH
74346: LD_INT 6
74348: PUSH
74349: LD_INT 46
74351: PUSH
74352: LD_INT 44
74354: PUSH
74355: LD_INT 47
74357: PUSH
74358: LD_INT 45
74360: PUSH
74361: LD_INT 28
74363: PUSH
74364: LD_INT 7
74366: PUSH
74367: LD_INT 27
74369: PUSH
74370: LD_INT 29
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: LIST
74380: LIST
74381: LIST
74382: LIST
74383: LIST
74384: IN
74385: PUSH
74386: LD_VAR 0 1
74390: PPUSH
74391: LD_INT 52
74393: PPUSH
74394: CALL_OW 321
74398: PUSH
74399: LD_INT 2
74401: EQUAL
74402: AND
74403: IFFALSE 74420
// bpoints := bpoints * 1.2 ;
74405: LD_ADDR_VAR 0 10
74409: PUSH
74410: LD_VAR 0 10
74414: PUSH
74415: LD_REAL  1.20000000000000E+0000
74418: MUL
74419: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74420: LD_VAR 0 6
74424: PPUSH
74425: CALL_OW 264
74429: PUSH
74430: LD_INT 6
74432: PUSH
74433: LD_INT 46
74435: PUSH
74436: LD_INT 47
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: LIST
74443: IN
74444: IFFALSE 74461
// bpoints := bpoints * 1.2 ;
74446: LD_ADDR_VAR 0 10
74450: PUSH
74451: LD_VAR 0 10
74455: PUSH
74456: LD_REAL  1.20000000000000E+0000
74459: MUL
74460: ST_TO_ADDR
// end ; unit_building :
74461: GO 74475
74463: LD_INT 3
74465: DOUBLE
74466: EQUAL
74467: IFTRUE 74471
74469: GO 74474
74471: POP
// ; end ;
74472: GO 74475
74474: POP
// for j = 1 to 3 do
74475: LD_ADDR_VAR 0 7
74479: PUSH
74480: DOUBLE
74481: LD_INT 1
74483: DEC
74484: ST_TO_ADDR
74485: LD_INT 3
74487: PUSH
74488: FOR_TO
74489: IFFALSE 74542
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74491: LD_ADDR_VAR 0 5
74495: PUSH
74496: LD_VAR 0 5
74500: PPUSH
74501: LD_VAR 0 7
74505: PPUSH
74506: LD_VAR 0 5
74510: PUSH
74511: LD_VAR 0 7
74515: ARRAY
74516: PUSH
74517: LD_VAR 0 9
74521: PUSH
74522: LD_VAR 0 7
74526: ARRAY
74527: PUSH
74528: LD_VAR 0 10
74532: MUL
74533: PLUS
74534: PPUSH
74535: CALL_OW 1
74539: ST_TO_ADDR
74540: GO 74488
74542: POP
74543: POP
// end ;
74544: GO 73027
74546: POP
74547: POP
// result := Replace ( result , 4 , tmp ) ;
74548: LD_ADDR_VAR 0 5
74552: PUSH
74553: LD_VAR 0 5
74557: PPUSH
74558: LD_INT 4
74560: PPUSH
74561: LD_VAR 0 8
74565: PPUSH
74566: CALL_OW 1
74570: ST_TO_ADDR
// end ;
74571: LD_VAR 0 5
74575: RET
// export function DangerAtRange ( unit , range ) ; begin
74576: LD_INT 0
74578: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74579: LD_ADDR_VAR 0 3
74583: PUSH
74584: LD_VAR 0 1
74588: PPUSH
74589: CALL_OW 255
74593: PPUSH
74594: LD_VAR 0 1
74598: PPUSH
74599: CALL_OW 250
74603: PPUSH
74604: LD_VAR 0 1
74608: PPUSH
74609: CALL_OW 251
74613: PPUSH
74614: LD_VAR 0 2
74618: PPUSH
74619: CALL 72879 0 4
74623: ST_TO_ADDR
// end ;
74624: LD_VAR 0 3
74628: RET
// export function DangerInArea ( side , area ) ; begin
74629: LD_INT 0
74631: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74632: LD_ADDR_VAR 0 3
74636: PUSH
74637: LD_VAR 0 2
74641: PPUSH
74642: LD_INT 81
74644: PUSH
74645: LD_VAR 0 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PPUSH
74654: CALL_OW 70
74658: ST_TO_ADDR
// end ;
74659: LD_VAR 0 3
74663: RET
// export function IsExtension ( b ) ; begin
74664: LD_INT 0
74666: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74667: LD_ADDR_VAR 0 2
74671: PUSH
74672: LD_VAR 0 1
74676: PUSH
74677: LD_INT 23
74679: PUSH
74680: LD_INT 20
74682: PUSH
74683: LD_INT 22
74685: PUSH
74686: LD_INT 17
74688: PUSH
74689: LD_INT 24
74691: PUSH
74692: LD_INT 21
74694: PUSH
74695: LD_INT 19
74697: PUSH
74698: LD_INT 16
74700: PUSH
74701: LD_INT 25
74703: PUSH
74704: LD_INT 18
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: LIST
74717: LIST
74718: IN
74719: ST_TO_ADDR
// end ;
74720: LD_VAR 0 2
74724: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74725: LD_INT 0
74727: PPUSH
74728: PPUSH
74729: PPUSH
// result := [ ] ;
74730: LD_ADDR_VAR 0 3
74734: PUSH
74735: EMPTY
74736: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74737: LD_ADDR_VAR 0 4
74741: PUSH
74742: LD_VAR 0 2
74746: PPUSH
74747: LD_INT 21
74749: PUSH
74750: LD_INT 3
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PPUSH
74757: CALL_OW 70
74761: ST_TO_ADDR
// if not tmp then
74762: LD_VAR 0 4
74766: NOT
74767: IFFALSE 74771
// exit ;
74769: GO 74829
// for i in tmp do
74771: LD_ADDR_VAR 0 5
74775: PUSH
74776: LD_VAR 0 4
74780: PUSH
74781: FOR_IN
74782: IFFALSE 74817
// if GetBase ( i ) <> base then
74784: LD_VAR 0 5
74788: PPUSH
74789: CALL_OW 274
74793: PUSH
74794: LD_VAR 0 1
74798: NONEQUAL
74799: IFFALSE 74815
// ComLinkToBase ( base , i ) ;
74801: LD_VAR 0 1
74805: PPUSH
74806: LD_VAR 0 5
74810: PPUSH
74811: CALL_OW 169
74815: GO 74781
74817: POP
74818: POP
// result := tmp ;
74819: LD_ADDR_VAR 0 3
74823: PUSH
74824: LD_VAR 0 4
74828: ST_TO_ADDR
// end ;
74829: LD_VAR 0 3
74833: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74834: LD_INT 0
74836: PPUSH
74837: PPUSH
// if BuildingStatus ( b ) = bs_build then
74838: LD_VAR 0 2
74842: PPUSH
74843: CALL_OW 461
74847: PUSH
74848: LD_INT 1
74850: EQUAL
74851: IFFALSE 74911
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74853: LD_VAR 0 1
74857: PPUSH
74858: LD_STRING h
74860: PUSH
74861: LD_VAR 0 2
74865: PPUSH
74866: CALL_OW 250
74870: PUSH
74871: LD_VAR 0 2
74875: PPUSH
74876: CALL_OW 251
74880: PUSH
74881: LD_VAR 0 2
74885: PUSH
74886: LD_INT 0
74888: PUSH
74889: LD_INT 0
74891: PUSH
74892: LD_INT 0
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: LIST
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: PUSH
74904: EMPTY
74905: LIST
74906: PPUSH
74907: CALL_OW 446
// end ;
74911: LD_VAR 0 3
74915: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74916: LD_INT 0
74918: PPUSH
74919: PPUSH
74920: PPUSH
74921: PPUSH
74922: PPUSH
74923: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74924: LD_VAR 0 1
74928: NOT
74929: PUSH
74930: LD_VAR 0 1
74934: PPUSH
74935: CALL_OW 263
74939: PUSH
74940: LD_INT 2
74942: EQUAL
74943: NOT
74944: OR
74945: IFFALSE 74949
// exit ;
74947: GO 75265
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74949: LD_ADDR_VAR 0 6
74953: PUSH
74954: LD_INT 22
74956: PUSH
74957: LD_VAR 0 1
74961: PPUSH
74962: CALL_OW 255
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 2
74973: PUSH
74974: LD_INT 30
74976: PUSH
74977: LD_INT 36
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 34
74986: PUSH
74987: LD_INT 31
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: LIST
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PPUSH
75003: CALL_OW 69
75007: ST_TO_ADDR
// if not tmp then
75008: LD_VAR 0 6
75012: NOT
75013: IFFALSE 75017
// exit ;
75015: GO 75265
// result := [ ] ;
75017: LD_ADDR_VAR 0 2
75021: PUSH
75022: EMPTY
75023: ST_TO_ADDR
// for i in tmp do
75024: LD_ADDR_VAR 0 3
75028: PUSH
75029: LD_VAR 0 6
75033: PUSH
75034: FOR_IN
75035: IFFALSE 75106
// begin t := UnitsInside ( i ) ;
75037: LD_ADDR_VAR 0 4
75041: PUSH
75042: LD_VAR 0 3
75046: PPUSH
75047: CALL_OW 313
75051: ST_TO_ADDR
// if t then
75052: LD_VAR 0 4
75056: IFFALSE 75104
// for j in t do
75058: LD_ADDR_VAR 0 7
75062: PUSH
75063: LD_VAR 0 4
75067: PUSH
75068: FOR_IN
75069: IFFALSE 75102
// result := Insert ( result , result + 1 , j ) ;
75071: LD_ADDR_VAR 0 2
75075: PUSH
75076: LD_VAR 0 2
75080: PPUSH
75081: LD_VAR 0 2
75085: PUSH
75086: LD_INT 1
75088: PLUS
75089: PPUSH
75090: LD_VAR 0 7
75094: PPUSH
75095: CALL_OW 2
75099: ST_TO_ADDR
75100: GO 75068
75102: POP
75103: POP
// end ;
75104: GO 75034
75106: POP
75107: POP
// if not result then
75108: LD_VAR 0 2
75112: NOT
75113: IFFALSE 75117
// exit ;
75115: GO 75265
// mech := result [ 1 ] ;
75117: LD_ADDR_VAR 0 5
75121: PUSH
75122: LD_VAR 0 2
75126: PUSH
75127: LD_INT 1
75129: ARRAY
75130: ST_TO_ADDR
// if result > 1 then
75131: LD_VAR 0 2
75135: PUSH
75136: LD_INT 1
75138: GREATER
75139: IFFALSE 75251
// for i = 2 to result do
75141: LD_ADDR_VAR 0 3
75145: PUSH
75146: DOUBLE
75147: LD_INT 2
75149: DEC
75150: ST_TO_ADDR
75151: LD_VAR 0 2
75155: PUSH
75156: FOR_TO
75157: IFFALSE 75249
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75159: LD_ADDR_VAR 0 4
75163: PUSH
75164: LD_VAR 0 2
75168: PUSH
75169: LD_VAR 0 3
75173: ARRAY
75174: PPUSH
75175: LD_INT 3
75177: PPUSH
75178: CALL_OW 259
75182: PUSH
75183: LD_VAR 0 2
75187: PUSH
75188: LD_VAR 0 3
75192: ARRAY
75193: PPUSH
75194: CALL_OW 432
75198: MINUS
75199: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75200: LD_VAR 0 4
75204: PUSH
75205: LD_VAR 0 5
75209: PPUSH
75210: LD_INT 3
75212: PPUSH
75213: CALL_OW 259
75217: PUSH
75218: LD_VAR 0 5
75222: PPUSH
75223: CALL_OW 432
75227: MINUS
75228: GREATEREQUAL
75229: IFFALSE 75247
// mech := result [ i ] ;
75231: LD_ADDR_VAR 0 5
75235: PUSH
75236: LD_VAR 0 2
75240: PUSH
75241: LD_VAR 0 3
75245: ARRAY
75246: ST_TO_ADDR
// end ;
75247: GO 75156
75249: POP
75250: POP
// ComLinkTo ( vehicle , mech ) ;
75251: LD_VAR 0 1
75255: PPUSH
75256: LD_VAR 0 5
75260: PPUSH
75261: CALL_OW 135
// end ;
75265: LD_VAR 0 2
75269: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75270: LD_INT 0
75272: PPUSH
75273: PPUSH
75274: PPUSH
75275: PPUSH
75276: PPUSH
75277: PPUSH
75278: PPUSH
75279: PPUSH
75280: PPUSH
75281: PPUSH
75282: PPUSH
75283: PPUSH
75284: PPUSH
// result := [ ] ;
75285: LD_ADDR_VAR 0 7
75289: PUSH
75290: EMPTY
75291: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75292: LD_VAR 0 1
75296: PPUSH
75297: CALL_OW 266
75301: PUSH
75302: LD_INT 0
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: IN
75312: NOT
75313: IFFALSE 75317
// exit ;
75315: GO 76948
// if name then
75317: LD_VAR 0 3
75321: IFFALSE 75337
// SetBName ( base_dep , name ) ;
75323: LD_VAR 0 1
75327: PPUSH
75328: LD_VAR 0 3
75332: PPUSH
75333: CALL_OW 500
// base := GetBase ( base_dep ) ;
75337: LD_ADDR_VAR 0 15
75341: PUSH
75342: LD_VAR 0 1
75346: PPUSH
75347: CALL_OW 274
75351: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75352: LD_ADDR_VAR 0 16
75356: PUSH
75357: LD_VAR 0 1
75361: PPUSH
75362: CALL_OW 255
75366: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75367: LD_ADDR_VAR 0 17
75371: PUSH
75372: LD_VAR 0 1
75376: PPUSH
75377: CALL_OW 248
75381: ST_TO_ADDR
// if sources then
75382: LD_VAR 0 5
75386: IFFALSE 75433
// for i = 1 to 3 do
75388: LD_ADDR_VAR 0 8
75392: PUSH
75393: DOUBLE
75394: LD_INT 1
75396: DEC
75397: ST_TO_ADDR
75398: LD_INT 3
75400: PUSH
75401: FOR_TO
75402: IFFALSE 75431
// AddResourceType ( base , i , sources [ i ] ) ;
75404: LD_VAR 0 15
75408: PPUSH
75409: LD_VAR 0 8
75413: PPUSH
75414: LD_VAR 0 5
75418: PUSH
75419: LD_VAR 0 8
75423: ARRAY
75424: PPUSH
75425: CALL_OW 276
75429: GO 75401
75431: POP
75432: POP
// buildings := GetBaseBuildings ( base , area ) ;
75433: LD_ADDR_VAR 0 18
75437: PUSH
75438: LD_VAR 0 15
75442: PPUSH
75443: LD_VAR 0 2
75447: PPUSH
75448: CALL 74725 0 2
75452: ST_TO_ADDR
// InitHc ;
75453: CALL_OW 19
// InitUc ;
75457: CALL_OW 18
// uc_side := side ;
75461: LD_ADDR_OWVAR 20
75465: PUSH
75466: LD_VAR 0 16
75470: ST_TO_ADDR
// uc_nation := nation ;
75471: LD_ADDR_OWVAR 21
75475: PUSH
75476: LD_VAR 0 17
75480: ST_TO_ADDR
// if buildings then
75481: LD_VAR 0 18
75485: IFFALSE 76807
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75487: LD_ADDR_VAR 0 19
75491: PUSH
75492: LD_VAR 0 18
75496: PPUSH
75497: LD_INT 2
75499: PUSH
75500: LD_INT 30
75502: PUSH
75503: LD_INT 29
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 30
75512: PUSH
75513: LD_INT 30
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: LIST
75524: PPUSH
75525: CALL_OW 72
75529: ST_TO_ADDR
// if tmp then
75530: LD_VAR 0 19
75534: IFFALSE 75582
// for i in tmp do
75536: LD_ADDR_VAR 0 8
75540: PUSH
75541: LD_VAR 0 19
75545: PUSH
75546: FOR_IN
75547: IFFALSE 75580
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75549: LD_VAR 0 8
75553: PPUSH
75554: CALL_OW 250
75558: PPUSH
75559: LD_VAR 0 8
75563: PPUSH
75564: CALL_OW 251
75568: PPUSH
75569: LD_VAR 0 16
75573: PPUSH
75574: CALL_OW 441
75578: GO 75546
75580: POP
75581: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75582: LD_VAR 0 18
75586: PPUSH
75587: LD_INT 2
75589: PUSH
75590: LD_INT 30
75592: PUSH
75593: LD_INT 32
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 30
75602: PUSH
75603: LD_INT 33
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: LIST
75614: PPUSH
75615: CALL_OW 72
75619: IFFALSE 75707
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75621: LD_ADDR_VAR 0 8
75625: PUSH
75626: LD_VAR 0 18
75630: PPUSH
75631: LD_INT 2
75633: PUSH
75634: LD_INT 30
75636: PUSH
75637: LD_INT 32
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: LD_INT 30
75646: PUSH
75647: LD_INT 33
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: LIST
75658: PPUSH
75659: CALL_OW 72
75663: PUSH
75664: FOR_IN
75665: IFFALSE 75705
// begin if not GetBWeapon ( i ) then
75667: LD_VAR 0 8
75671: PPUSH
75672: CALL_OW 269
75676: NOT
75677: IFFALSE 75703
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75679: LD_VAR 0 8
75683: PPUSH
75684: LD_VAR 0 8
75688: PPUSH
75689: LD_VAR 0 2
75693: PPUSH
75694: CALL 76953 0 2
75698: PPUSH
75699: CALL_OW 431
// end ;
75703: GO 75664
75705: POP
75706: POP
// end ; for i = 1 to personel do
75707: LD_ADDR_VAR 0 8
75711: PUSH
75712: DOUBLE
75713: LD_INT 1
75715: DEC
75716: ST_TO_ADDR
75717: LD_VAR 0 6
75721: PUSH
75722: FOR_TO
75723: IFFALSE 76787
// begin if i > 4 then
75725: LD_VAR 0 8
75729: PUSH
75730: LD_INT 4
75732: GREATER
75733: IFFALSE 75737
// break ;
75735: GO 76787
// case i of 1 :
75737: LD_VAR 0 8
75741: PUSH
75742: LD_INT 1
75744: DOUBLE
75745: EQUAL
75746: IFTRUE 75750
75748: GO 75830
75750: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75751: LD_ADDR_VAR 0 12
75755: PUSH
75756: LD_VAR 0 18
75760: PPUSH
75761: LD_INT 22
75763: PUSH
75764: LD_VAR 0 16
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 58
75775: PUSH
75776: EMPTY
75777: LIST
75778: PUSH
75779: LD_INT 2
75781: PUSH
75782: LD_INT 30
75784: PUSH
75785: LD_INT 32
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 30
75794: PUSH
75795: LD_INT 4
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 30
75804: PUSH
75805: LD_INT 5
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: LIST
75822: PPUSH
75823: CALL_OW 72
75827: ST_TO_ADDR
75828: GO 76052
75830: LD_INT 2
75832: DOUBLE
75833: EQUAL
75834: IFTRUE 75838
75836: GO 75900
75838: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75839: LD_ADDR_VAR 0 12
75843: PUSH
75844: LD_VAR 0 18
75848: PPUSH
75849: LD_INT 22
75851: PUSH
75852: LD_VAR 0 16
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 2
75863: PUSH
75864: LD_INT 30
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 30
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: LIST
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PPUSH
75893: CALL_OW 72
75897: ST_TO_ADDR
75898: GO 76052
75900: LD_INT 3
75902: DOUBLE
75903: EQUAL
75904: IFTRUE 75908
75906: GO 75970
75908: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75909: LD_ADDR_VAR 0 12
75913: PUSH
75914: LD_VAR 0 18
75918: PPUSH
75919: LD_INT 22
75921: PUSH
75922: LD_VAR 0 16
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 2
75933: PUSH
75934: LD_INT 30
75936: PUSH
75937: LD_INT 2
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 30
75946: PUSH
75947: LD_INT 3
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: LIST
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PPUSH
75963: CALL_OW 72
75967: ST_TO_ADDR
75968: GO 76052
75970: LD_INT 4
75972: DOUBLE
75973: EQUAL
75974: IFTRUE 75978
75976: GO 76051
75978: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75979: LD_ADDR_VAR 0 12
75983: PUSH
75984: LD_VAR 0 18
75988: PPUSH
75989: LD_INT 22
75991: PUSH
75992: LD_VAR 0 16
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 2
76003: PUSH
76004: LD_INT 30
76006: PUSH
76007: LD_INT 6
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 30
76016: PUSH
76017: LD_INT 7
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 30
76026: PUSH
76027: LD_INT 8
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PPUSH
76044: CALL_OW 72
76048: ST_TO_ADDR
76049: GO 76052
76051: POP
// if i = 1 then
76052: LD_VAR 0 8
76056: PUSH
76057: LD_INT 1
76059: EQUAL
76060: IFFALSE 76171
// begin tmp := [ ] ;
76062: LD_ADDR_VAR 0 19
76066: PUSH
76067: EMPTY
76068: ST_TO_ADDR
// for j in f do
76069: LD_ADDR_VAR 0 9
76073: PUSH
76074: LD_VAR 0 12
76078: PUSH
76079: FOR_IN
76080: IFFALSE 76153
// if GetBType ( j ) = b_bunker then
76082: LD_VAR 0 9
76086: PPUSH
76087: CALL_OW 266
76091: PUSH
76092: LD_INT 32
76094: EQUAL
76095: IFFALSE 76122
// tmp := Insert ( tmp , 1 , j ) else
76097: LD_ADDR_VAR 0 19
76101: PUSH
76102: LD_VAR 0 19
76106: PPUSH
76107: LD_INT 1
76109: PPUSH
76110: LD_VAR 0 9
76114: PPUSH
76115: CALL_OW 2
76119: ST_TO_ADDR
76120: GO 76151
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76122: LD_ADDR_VAR 0 19
76126: PUSH
76127: LD_VAR 0 19
76131: PPUSH
76132: LD_VAR 0 19
76136: PUSH
76137: LD_INT 1
76139: PLUS
76140: PPUSH
76141: LD_VAR 0 9
76145: PPUSH
76146: CALL_OW 2
76150: ST_TO_ADDR
76151: GO 76079
76153: POP
76154: POP
// if tmp then
76155: LD_VAR 0 19
76159: IFFALSE 76171
// f := tmp ;
76161: LD_ADDR_VAR 0 12
76165: PUSH
76166: LD_VAR 0 19
76170: ST_TO_ADDR
// end ; x := personel [ i ] ;
76171: LD_ADDR_VAR 0 13
76175: PUSH
76176: LD_VAR 0 6
76180: PUSH
76181: LD_VAR 0 8
76185: ARRAY
76186: ST_TO_ADDR
// if x = - 1 then
76187: LD_VAR 0 13
76191: PUSH
76192: LD_INT 1
76194: NEG
76195: EQUAL
76196: IFFALSE 76405
// begin for j in f do
76198: LD_ADDR_VAR 0 9
76202: PUSH
76203: LD_VAR 0 12
76207: PUSH
76208: FOR_IN
76209: IFFALSE 76401
// repeat InitHc ;
76211: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76215: LD_VAR 0 9
76219: PPUSH
76220: CALL_OW 266
76224: PUSH
76225: LD_INT 5
76227: EQUAL
76228: IFFALSE 76298
// begin if UnitsInside ( j ) < 3 then
76230: LD_VAR 0 9
76234: PPUSH
76235: CALL_OW 313
76239: PUSH
76240: LD_INT 3
76242: LESS
76243: IFFALSE 76279
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76245: LD_INT 0
76247: PPUSH
76248: LD_INT 5
76250: PUSH
76251: LD_INT 8
76253: PUSH
76254: LD_INT 9
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: LIST
76261: PUSH
76262: LD_VAR 0 17
76266: ARRAY
76267: PPUSH
76268: LD_VAR 0 4
76272: PPUSH
76273: CALL_OW 380
76277: GO 76296
// PrepareHuman ( false , i , skill ) ;
76279: LD_INT 0
76281: PPUSH
76282: LD_VAR 0 8
76286: PPUSH
76287: LD_VAR 0 4
76291: PPUSH
76292: CALL_OW 380
// end else
76296: GO 76315
// PrepareHuman ( false , i , skill ) ;
76298: LD_INT 0
76300: PPUSH
76301: LD_VAR 0 8
76305: PPUSH
76306: LD_VAR 0 4
76310: PPUSH
76311: CALL_OW 380
// un := CreateHuman ;
76315: LD_ADDR_VAR 0 14
76319: PUSH
76320: CALL_OW 44
76324: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76325: LD_ADDR_VAR 0 7
76329: PUSH
76330: LD_VAR 0 7
76334: PPUSH
76335: LD_INT 1
76337: PPUSH
76338: LD_VAR 0 14
76342: PPUSH
76343: CALL_OW 2
76347: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76348: LD_VAR 0 14
76352: PPUSH
76353: LD_VAR 0 9
76357: PPUSH
76358: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76362: LD_VAR 0 9
76366: PPUSH
76367: CALL_OW 313
76371: PUSH
76372: LD_INT 6
76374: EQUAL
76375: PUSH
76376: LD_VAR 0 9
76380: PPUSH
76381: CALL_OW 266
76385: PUSH
76386: LD_INT 32
76388: PUSH
76389: LD_INT 31
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: IN
76396: OR
76397: IFFALSE 76211
76399: GO 76208
76401: POP
76402: POP
// end else
76403: GO 76785
// for j = 1 to x do
76405: LD_ADDR_VAR 0 9
76409: PUSH
76410: DOUBLE
76411: LD_INT 1
76413: DEC
76414: ST_TO_ADDR
76415: LD_VAR 0 13
76419: PUSH
76420: FOR_TO
76421: IFFALSE 76783
// begin InitHc ;
76423: CALL_OW 19
// if not f then
76427: LD_VAR 0 12
76431: NOT
76432: IFFALSE 76521
// begin PrepareHuman ( false , i , skill ) ;
76434: LD_INT 0
76436: PPUSH
76437: LD_VAR 0 8
76441: PPUSH
76442: LD_VAR 0 4
76446: PPUSH
76447: CALL_OW 380
// un := CreateHuman ;
76451: LD_ADDR_VAR 0 14
76455: PUSH
76456: CALL_OW 44
76460: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76461: LD_ADDR_VAR 0 7
76465: PUSH
76466: LD_VAR 0 7
76470: PPUSH
76471: LD_INT 1
76473: PPUSH
76474: LD_VAR 0 14
76478: PPUSH
76479: CALL_OW 2
76483: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76484: LD_VAR 0 14
76488: PPUSH
76489: LD_VAR 0 1
76493: PPUSH
76494: CALL_OW 250
76498: PPUSH
76499: LD_VAR 0 1
76503: PPUSH
76504: CALL_OW 251
76508: PPUSH
76509: LD_INT 10
76511: PPUSH
76512: LD_INT 0
76514: PPUSH
76515: CALL_OW 50
// continue ;
76519: GO 76420
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76521: LD_VAR 0 12
76525: PUSH
76526: LD_INT 1
76528: ARRAY
76529: PPUSH
76530: CALL_OW 313
76534: PUSH
76535: LD_VAR 0 12
76539: PUSH
76540: LD_INT 1
76542: ARRAY
76543: PPUSH
76544: CALL_OW 266
76548: PUSH
76549: LD_INT 32
76551: PUSH
76552: LD_INT 31
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: IN
76559: AND
76560: PUSH
76561: LD_VAR 0 12
76565: PUSH
76566: LD_INT 1
76568: ARRAY
76569: PPUSH
76570: CALL_OW 313
76574: PUSH
76575: LD_INT 6
76577: EQUAL
76578: OR
76579: IFFALSE 76599
// f := Delete ( f , 1 ) ;
76581: LD_ADDR_VAR 0 12
76585: PUSH
76586: LD_VAR 0 12
76590: PPUSH
76591: LD_INT 1
76593: PPUSH
76594: CALL_OW 3
76598: ST_TO_ADDR
// if not f then
76599: LD_VAR 0 12
76603: NOT
76604: IFFALSE 76622
// begin x := x + 2 ;
76606: LD_ADDR_VAR 0 13
76610: PUSH
76611: LD_VAR 0 13
76615: PUSH
76616: LD_INT 2
76618: PLUS
76619: ST_TO_ADDR
// continue ;
76620: GO 76420
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76622: LD_VAR 0 12
76626: PUSH
76627: LD_INT 1
76629: ARRAY
76630: PPUSH
76631: CALL_OW 266
76635: PUSH
76636: LD_INT 5
76638: EQUAL
76639: IFFALSE 76713
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76641: LD_VAR 0 12
76645: PUSH
76646: LD_INT 1
76648: ARRAY
76649: PPUSH
76650: CALL_OW 313
76654: PUSH
76655: LD_INT 3
76657: LESS
76658: IFFALSE 76694
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76660: LD_INT 0
76662: PPUSH
76663: LD_INT 5
76665: PUSH
76666: LD_INT 8
76668: PUSH
76669: LD_INT 9
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: LIST
76676: PUSH
76677: LD_VAR 0 17
76681: ARRAY
76682: PPUSH
76683: LD_VAR 0 4
76687: PPUSH
76688: CALL_OW 380
76692: GO 76711
// PrepareHuman ( false , i , skill ) ;
76694: LD_INT 0
76696: PPUSH
76697: LD_VAR 0 8
76701: PPUSH
76702: LD_VAR 0 4
76706: PPUSH
76707: CALL_OW 380
// end else
76711: GO 76730
// PrepareHuman ( false , i , skill ) ;
76713: LD_INT 0
76715: PPUSH
76716: LD_VAR 0 8
76720: PPUSH
76721: LD_VAR 0 4
76725: PPUSH
76726: CALL_OW 380
// un := CreateHuman ;
76730: LD_ADDR_VAR 0 14
76734: PUSH
76735: CALL_OW 44
76739: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76740: LD_ADDR_VAR 0 7
76744: PUSH
76745: LD_VAR 0 7
76749: PPUSH
76750: LD_INT 1
76752: PPUSH
76753: LD_VAR 0 14
76757: PPUSH
76758: CALL_OW 2
76762: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76763: LD_VAR 0 14
76767: PPUSH
76768: LD_VAR 0 12
76772: PUSH
76773: LD_INT 1
76775: ARRAY
76776: PPUSH
76777: CALL_OW 52
// end ;
76781: GO 76420
76783: POP
76784: POP
// end ;
76785: GO 75722
76787: POP
76788: POP
// result := result ^ buildings ;
76789: LD_ADDR_VAR 0 7
76793: PUSH
76794: LD_VAR 0 7
76798: PUSH
76799: LD_VAR 0 18
76803: ADD
76804: ST_TO_ADDR
// end else
76805: GO 76948
// begin for i = 1 to personel do
76807: LD_ADDR_VAR 0 8
76811: PUSH
76812: DOUBLE
76813: LD_INT 1
76815: DEC
76816: ST_TO_ADDR
76817: LD_VAR 0 6
76821: PUSH
76822: FOR_TO
76823: IFFALSE 76946
// begin if i > 4 then
76825: LD_VAR 0 8
76829: PUSH
76830: LD_INT 4
76832: GREATER
76833: IFFALSE 76837
// break ;
76835: GO 76946
// x := personel [ i ] ;
76837: LD_ADDR_VAR 0 13
76841: PUSH
76842: LD_VAR 0 6
76846: PUSH
76847: LD_VAR 0 8
76851: ARRAY
76852: ST_TO_ADDR
// if x = - 1 then
76853: LD_VAR 0 13
76857: PUSH
76858: LD_INT 1
76860: NEG
76861: EQUAL
76862: IFFALSE 76866
// continue ;
76864: GO 76822
// PrepareHuman ( false , i , skill ) ;
76866: LD_INT 0
76868: PPUSH
76869: LD_VAR 0 8
76873: PPUSH
76874: LD_VAR 0 4
76878: PPUSH
76879: CALL_OW 380
// un := CreateHuman ;
76883: LD_ADDR_VAR 0 14
76887: PUSH
76888: CALL_OW 44
76892: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76893: LD_VAR 0 14
76897: PPUSH
76898: LD_VAR 0 1
76902: PPUSH
76903: CALL_OW 250
76907: PPUSH
76908: LD_VAR 0 1
76912: PPUSH
76913: CALL_OW 251
76917: PPUSH
76918: LD_INT 10
76920: PPUSH
76921: LD_INT 0
76923: PPUSH
76924: CALL_OW 50
// result := result ^ un ;
76928: LD_ADDR_VAR 0 7
76932: PUSH
76933: LD_VAR 0 7
76937: PUSH
76938: LD_VAR 0 14
76942: ADD
76943: ST_TO_ADDR
// end ;
76944: GO 76822
76946: POP
76947: POP
// end ; end ;
76948: LD_VAR 0 7
76952: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76953: LD_INT 0
76955: PPUSH
76956: PPUSH
76957: PPUSH
76958: PPUSH
76959: PPUSH
76960: PPUSH
76961: PPUSH
76962: PPUSH
76963: PPUSH
76964: PPUSH
76965: PPUSH
76966: PPUSH
76967: PPUSH
76968: PPUSH
76969: PPUSH
76970: PPUSH
// result := false ;
76971: LD_ADDR_VAR 0 3
76975: PUSH
76976: LD_INT 0
76978: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76979: LD_VAR 0 1
76983: NOT
76984: PUSH
76985: LD_VAR 0 1
76989: PPUSH
76990: CALL_OW 266
76994: PUSH
76995: LD_INT 32
76997: PUSH
76998: LD_INT 33
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: IN
77005: NOT
77006: OR
77007: IFFALSE 77011
// exit ;
77009: GO 78147
// nat := GetNation ( tower ) ;
77011: LD_ADDR_VAR 0 12
77015: PUSH
77016: LD_VAR 0 1
77020: PPUSH
77021: CALL_OW 248
77025: ST_TO_ADDR
// side := GetSide ( tower ) ;
77026: LD_ADDR_VAR 0 16
77030: PUSH
77031: LD_VAR 0 1
77035: PPUSH
77036: CALL_OW 255
77040: ST_TO_ADDR
// x := GetX ( tower ) ;
77041: LD_ADDR_VAR 0 10
77045: PUSH
77046: LD_VAR 0 1
77050: PPUSH
77051: CALL_OW 250
77055: ST_TO_ADDR
// y := GetY ( tower ) ;
77056: LD_ADDR_VAR 0 11
77060: PUSH
77061: LD_VAR 0 1
77065: PPUSH
77066: CALL_OW 251
77070: ST_TO_ADDR
// if not x or not y then
77071: LD_VAR 0 10
77075: NOT
77076: PUSH
77077: LD_VAR 0 11
77081: NOT
77082: OR
77083: IFFALSE 77087
// exit ;
77085: GO 78147
// weapon := 0 ;
77087: LD_ADDR_VAR 0 18
77091: PUSH
77092: LD_INT 0
77094: ST_TO_ADDR
// fac_list := [ ] ;
77095: LD_ADDR_VAR 0 17
77099: PUSH
77100: EMPTY
77101: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77102: LD_ADDR_VAR 0 6
77106: PUSH
77107: LD_VAR 0 1
77111: PPUSH
77112: CALL_OW 274
77116: PPUSH
77117: LD_VAR 0 2
77121: PPUSH
77122: CALL 74725 0 2
77126: PPUSH
77127: LD_INT 30
77129: PUSH
77130: LD_INT 3
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PPUSH
77137: CALL_OW 72
77141: ST_TO_ADDR
// if not factories then
77142: LD_VAR 0 6
77146: NOT
77147: IFFALSE 77151
// exit ;
77149: GO 78147
// for i in factories do
77151: LD_ADDR_VAR 0 8
77155: PUSH
77156: LD_VAR 0 6
77160: PUSH
77161: FOR_IN
77162: IFFALSE 77187
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77164: LD_ADDR_VAR 0 17
77168: PUSH
77169: LD_VAR 0 17
77173: PUSH
77174: LD_VAR 0 8
77178: PPUSH
77179: CALL_OW 478
77183: UNION
77184: ST_TO_ADDR
77185: GO 77161
77187: POP
77188: POP
// if not fac_list then
77189: LD_VAR 0 17
77193: NOT
77194: IFFALSE 77198
// exit ;
77196: GO 78147
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77198: LD_ADDR_VAR 0 5
77202: PUSH
77203: LD_INT 4
77205: PUSH
77206: LD_INT 5
77208: PUSH
77209: LD_INT 9
77211: PUSH
77212: LD_INT 10
77214: PUSH
77215: LD_INT 6
77217: PUSH
77218: LD_INT 7
77220: PUSH
77221: LD_INT 11
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: LIST
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 27
77235: PUSH
77236: LD_INT 28
77238: PUSH
77239: LD_INT 26
77241: PUSH
77242: LD_INT 30
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: LIST
77249: LIST
77250: PUSH
77251: LD_INT 43
77253: PUSH
77254: LD_INT 44
77256: PUSH
77257: LD_INT 46
77259: PUSH
77260: LD_INT 45
77262: PUSH
77263: LD_INT 47
77265: PUSH
77266: LD_INT 49
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: LIST
77281: PUSH
77282: LD_VAR 0 12
77286: ARRAY
77287: ST_TO_ADDR
// for i in list do
77288: LD_ADDR_VAR 0 8
77292: PUSH
77293: LD_VAR 0 5
77297: PUSH
77298: FOR_IN
77299: IFFALSE 77332
// if not i in fac_list then
77301: LD_VAR 0 8
77305: PUSH
77306: LD_VAR 0 17
77310: IN
77311: NOT
77312: IFFALSE 77330
// list := list diff i ;
77314: LD_ADDR_VAR 0 5
77318: PUSH
77319: LD_VAR 0 5
77323: PUSH
77324: LD_VAR 0 8
77328: DIFF
77329: ST_TO_ADDR
77330: GO 77298
77332: POP
77333: POP
// if not list then
77334: LD_VAR 0 5
77338: NOT
77339: IFFALSE 77343
// exit ;
77341: GO 78147
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77343: LD_VAR 0 12
77347: PUSH
77348: LD_INT 3
77350: EQUAL
77351: PUSH
77352: LD_INT 49
77354: PUSH
77355: LD_VAR 0 5
77359: IN
77360: AND
77361: PUSH
77362: LD_INT 31
77364: PPUSH
77365: LD_VAR 0 16
77369: PPUSH
77370: CALL_OW 321
77374: PUSH
77375: LD_INT 2
77377: EQUAL
77378: AND
77379: IFFALSE 77439
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77381: LD_INT 22
77383: PUSH
77384: LD_VAR 0 16
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 35
77395: PUSH
77396: LD_INT 49
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 91
77405: PUSH
77406: LD_VAR 0 1
77410: PUSH
77411: LD_INT 10
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: LIST
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: LIST
77423: PPUSH
77424: CALL_OW 69
77428: NOT
77429: IFFALSE 77439
// weapon := ru_time_lapser ;
77431: LD_ADDR_VAR 0 18
77435: PUSH
77436: LD_INT 49
77438: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77439: LD_VAR 0 12
77443: PUSH
77444: LD_INT 1
77446: PUSH
77447: LD_INT 2
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: IN
77454: PUSH
77455: LD_INT 11
77457: PUSH
77458: LD_VAR 0 5
77462: IN
77463: PUSH
77464: LD_INT 30
77466: PUSH
77467: LD_VAR 0 5
77471: IN
77472: OR
77473: AND
77474: PUSH
77475: LD_INT 6
77477: PPUSH
77478: LD_VAR 0 16
77482: PPUSH
77483: CALL_OW 321
77487: PUSH
77488: LD_INT 2
77490: EQUAL
77491: AND
77492: IFFALSE 77657
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77494: LD_INT 22
77496: PUSH
77497: LD_VAR 0 16
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 2
77508: PUSH
77509: LD_INT 35
77511: PUSH
77512: LD_INT 11
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 35
77521: PUSH
77522: LD_INT 30
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 91
77536: PUSH
77537: LD_VAR 0 1
77541: PUSH
77542: LD_INT 18
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: LIST
77554: PPUSH
77555: CALL_OW 69
77559: NOT
77560: PUSH
77561: LD_INT 22
77563: PUSH
77564: LD_VAR 0 16
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 2
77575: PUSH
77576: LD_INT 30
77578: PUSH
77579: LD_INT 32
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: PUSH
77586: LD_INT 30
77588: PUSH
77589: LD_INT 33
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 91
77603: PUSH
77604: LD_VAR 0 1
77608: PUSH
77609: LD_INT 12
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: LIST
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: LIST
77621: PUSH
77622: EMPTY
77623: LIST
77624: PPUSH
77625: CALL_OW 69
77629: PUSH
77630: LD_INT 2
77632: GREATER
77633: AND
77634: IFFALSE 77657
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77636: LD_ADDR_VAR 0 18
77640: PUSH
77641: LD_INT 11
77643: PUSH
77644: LD_INT 30
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_VAR 0 12
77655: ARRAY
77656: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77657: LD_VAR 0 18
77661: NOT
77662: PUSH
77663: LD_INT 40
77665: PPUSH
77666: LD_VAR 0 16
77670: PPUSH
77671: CALL_OW 321
77675: PUSH
77676: LD_INT 2
77678: EQUAL
77679: AND
77680: PUSH
77681: LD_INT 7
77683: PUSH
77684: LD_VAR 0 5
77688: IN
77689: PUSH
77690: LD_INT 28
77692: PUSH
77693: LD_VAR 0 5
77697: IN
77698: OR
77699: PUSH
77700: LD_INT 45
77702: PUSH
77703: LD_VAR 0 5
77707: IN
77708: OR
77709: AND
77710: IFFALSE 77964
// begin hex := GetHexInfo ( x , y ) ;
77712: LD_ADDR_VAR 0 4
77716: PUSH
77717: LD_VAR 0 10
77721: PPUSH
77722: LD_VAR 0 11
77726: PPUSH
77727: CALL_OW 546
77731: ST_TO_ADDR
// if hex [ 1 ] then
77732: LD_VAR 0 4
77736: PUSH
77737: LD_INT 1
77739: ARRAY
77740: IFFALSE 77744
// exit ;
77742: GO 78147
// height := hex [ 2 ] ;
77744: LD_ADDR_VAR 0 15
77748: PUSH
77749: LD_VAR 0 4
77753: PUSH
77754: LD_INT 2
77756: ARRAY
77757: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77758: LD_ADDR_VAR 0 14
77762: PUSH
77763: LD_INT 0
77765: PUSH
77766: LD_INT 2
77768: PUSH
77769: LD_INT 3
77771: PUSH
77772: LD_INT 5
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: ST_TO_ADDR
// for i in tmp do
77781: LD_ADDR_VAR 0 8
77785: PUSH
77786: LD_VAR 0 14
77790: PUSH
77791: FOR_IN
77792: IFFALSE 77962
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77794: LD_ADDR_VAR 0 9
77798: PUSH
77799: LD_VAR 0 10
77803: PPUSH
77804: LD_VAR 0 8
77808: PPUSH
77809: LD_INT 5
77811: PPUSH
77812: CALL_OW 272
77816: PUSH
77817: LD_VAR 0 11
77821: PPUSH
77822: LD_VAR 0 8
77826: PPUSH
77827: LD_INT 5
77829: PPUSH
77830: CALL_OW 273
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77839: LD_VAR 0 9
77843: PUSH
77844: LD_INT 1
77846: ARRAY
77847: PPUSH
77848: LD_VAR 0 9
77852: PUSH
77853: LD_INT 2
77855: ARRAY
77856: PPUSH
77857: CALL_OW 488
77861: IFFALSE 77960
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77863: LD_ADDR_VAR 0 4
77867: PUSH
77868: LD_VAR 0 9
77872: PUSH
77873: LD_INT 1
77875: ARRAY
77876: PPUSH
77877: LD_VAR 0 9
77881: PUSH
77882: LD_INT 2
77884: ARRAY
77885: PPUSH
77886: CALL_OW 546
77890: ST_TO_ADDR
// if hex [ 1 ] then
77891: LD_VAR 0 4
77895: PUSH
77896: LD_INT 1
77898: ARRAY
77899: IFFALSE 77903
// continue ;
77901: GO 77791
// h := hex [ 2 ] ;
77903: LD_ADDR_VAR 0 13
77907: PUSH
77908: LD_VAR 0 4
77912: PUSH
77913: LD_INT 2
77915: ARRAY
77916: ST_TO_ADDR
// if h + 7 < height then
77917: LD_VAR 0 13
77921: PUSH
77922: LD_INT 7
77924: PLUS
77925: PUSH
77926: LD_VAR 0 15
77930: LESS
77931: IFFALSE 77960
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77933: LD_ADDR_VAR 0 18
77937: PUSH
77938: LD_INT 7
77940: PUSH
77941: LD_INT 28
77943: PUSH
77944: LD_INT 45
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: LIST
77951: PUSH
77952: LD_VAR 0 12
77956: ARRAY
77957: ST_TO_ADDR
// break ;
77958: GO 77962
// end ; end ; end ;
77960: GO 77791
77962: POP
77963: POP
// end ; if not weapon then
77964: LD_VAR 0 18
77968: NOT
77969: IFFALSE 78029
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77971: LD_ADDR_VAR 0 5
77975: PUSH
77976: LD_VAR 0 5
77980: PUSH
77981: LD_INT 11
77983: PUSH
77984: LD_INT 30
77986: PUSH
77987: LD_INT 49
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: LIST
77994: DIFF
77995: ST_TO_ADDR
// if not list then
77996: LD_VAR 0 5
78000: NOT
78001: IFFALSE 78005
// exit ;
78003: GO 78147
// weapon := list [ rand ( 1 , list ) ] ;
78005: LD_ADDR_VAR 0 18
78009: PUSH
78010: LD_VAR 0 5
78014: PUSH
78015: LD_INT 1
78017: PPUSH
78018: LD_VAR 0 5
78022: PPUSH
78023: CALL_OW 12
78027: ARRAY
78028: ST_TO_ADDR
// end ; if weapon then
78029: LD_VAR 0 18
78033: IFFALSE 78147
// begin tmp := CostOfWeapon ( weapon ) ;
78035: LD_ADDR_VAR 0 14
78039: PUSH
78040: LD_VAR 0 18
78044: PPUSH
78045: CALL_OW 451
78049: ST_TO_ADDR
// j := GetBase ( tower ) ;
78050: LD_ADDR_VAR 0 9
78054: PUSH
78055: LD_VAR 0 1
78059: PPUSH
78060: CALL_OW 274
78064: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78065: LD_VAR 0 9
78069: PPUSH
78070: LD_INT 1
78072: PPUSH
78073: CALL_OW 275
78077: PUSH
78078: LD_VAR 0 14
78082: PUSH
78083: LD_INT 1
78085: ARRAY
78086: GREATEREQUAL
78087: PUSH
78088: LD_VAR 0 9
78092: PPUSH
78093: LD_INT 2
78095: PPUSH
78096: CALL_OW 275
78100: PUSH
78101: LD_VAR 0 14
78105: PUSH
78106: LD_INT 2
78108: ARRAY
78109: GREATEREQUAL
78110: AND
78111: PUSH
78112: LD_VAR 0 9
78116: PPUSH
78117: LD_INT 3
78119: PPUSH
78120: CALL_OW 275
78124: PUSH
78125: LD_VAR 0 14
78129: PUSH
78130: LD_INT 3
78132: ARRAY
78133: GREATEREQUAL
78134: AND
78135: IFFALSE 78147
// result := weapon ;
78137: LD_ADDR_VAR 0 3
78141: PUSH
78142: LD_VAR 0 18
78146: ST_TO_ADDR
// end ; end ;
78147: LD_VAR 0 3
78151: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78152: LD_INT 0
78154: PPUSH
78155: PPUSH
// result := true ;
78156: LD_ADDR_VAR 0 3
78160: PUSH
78161: LD_INT 1
78163: ST_TO_ADDR
// if array1 = array2 then
78164: LD_VAR 0 1
78168: PUSH
78169: LD_VAR 0 2
78173: EQUAL
78174: IFFALSE 78234
// begin for i = 1 to array1 do
78176: LD_ADDR_VAR 0 4
78180: PUSH
78181: DOUBLE
78182: LD_INT 1
78184: DEC
78185: ST_TO_ADDR
78186: LD_VAR 0 1
78190: PUSH
78191: FOR_TO
78192: IFFALSE 78230
// if array1 [ i ] <> array2 [ i ] then
78194: LD_VAR 0 1
78198: PUSH
78199: LD_VAR 0 4
78203: ARRAY
78204: PUSH
78205: LD_VAR 0 2
78209: PUSH
78210: LD_VAR 0 4
78214: ARRAY
78215: NONEQUAL
78216: IFFALSE 78228
// begin result := false ;
78218: LD_ADDR_VAR 0 3
78222: PUSH
78223: LD_INT 0
78225: ST_TO_ADDR
// break ;
78226: GO 78230
// end ;
78228: GO 78191
78230: POP
78231: POP
// end else
78232: GO 78242
// result := false ;
78234: LD_ADDR_VAR 0 3
78238: PUSH
78239: LD_INT 0
78241: ST_TO_ADDR
// end ;
78242: LD_VAR 0 3
78246: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78247: LD_INT 0
78249: PPUSH
78250: PPUSH
78251: PPUSH
// pom := GetBase ( fac ) ;
78252: LD_ADDR_VAR 0 5
78256: PUSH
78257: LD_VAR 0 1
78261: PPUSH
78262: CALL_OW 274
78266: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78267: LD_ADDR_VAR 0 4
78271: PUSH
78272: LD_VAR 0 2
78276: PUSH
78277: LD_INT 1
78279: ARRAY
78280: PPUSH
78281: LD_VAR 0 2
78285: PUSH
78286: LD_INT 2
78288: ARRAY
78289: PPUSH
78290: LD_VAR 0 2
78294: PUSH
78295: LD_INT 3
78297: ARRAY
78298: PPUSH
78299: LD_VAR 0 2
78303: PUSH
78304: LD_INT 4
78306: ARRAY
78307: PPUSH
78308: CALL_OW 449
78312: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78313: LD_ADDR_VAR 0 3
78317: PUSH
78318: LD_VAR 0 5
78322: PPUSH
78323: LD_INT 1
78325: PPUSH
78326: CALL_OW 275
78330: PUSH
78331: LD_VAR 0 4
78335: PUSH
78336: LD_INT 1
78338: ARRAY
78339: GREATEREQUAL
78340: PUSH
78341: LD_VAR 0 5
78345: PPUSH
78346: LD_INT 2
78348: PPUSH
78349: CALL_OW 275
78353: PUSH
78354: LD_VAR 0 4
78358: PUSH
78359: LD_INT 2
78361: ARRAY
78362: GREATEREQUAL
78363: AND
78364: PUSH
78365: LD_VAR 0 5
78369: PPUSH
78370: LD_INT 3
78372: PPUSH
78373: CALL_OW 275
78377: PUSH
78378: LD_VAR 0 4
78382: PUSH
78383: LD_INT 3
78385: ARRAY
78386: GREATEREQUAL
78387: AND
78388: ST_TO_ADDR
// end ;
78389: LD_VAR 0 3
78393: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78394: LD_INT 0
78396: PPUSH
78397: PPUSH
78398: PPUSH
78399: PPUSH
// pom := GetBase ( building ) ;
78400: LD_ADDR_VAR 0 3
78404: PUSH
78405: LD_VAR 0 1
78409: PPUSH
78410: CALL_OW 274
78414: ST_TO_ADDR
// if not pom then
78415: LD_VAR 0 3
78419: NOT
78420: IFFALSE 78424
// exit ;
78422: GO 78594
// btype := GetBType ( building ) ;
78424: LD_ADDR_VAR 0 5
78428: PUSH
78429: LD_VAR 0 1
78433: PPUSH
78434: CALL_OW 266
78438: ST_TO_ADDR
// if btype = b_armoury then
78439: LD_VAR 0 5
78443: PUSH
78444: LD_INT 4
78446: EQUAL
78447: IFFALSE 78457
// btype := b_barracks ;
78449: LD_ADDR_VAR 0 5
78453: PUSH
78454: LD_INT 5
78456: ST_TO_ADDR
// if btype = b_depot then
78457: LD_VAR 0 5
78461: PUSH
78462: LD_INT 0
78464: EQUAL
78465: IFFALSE 78475
// btype := b_warehouse ;
78467: LD_ADDR_VAR 0 5
78471: PUSH
78472: LD_INT 1
78474: ST_TO_ADDR
// if btype = b_workshop then
78475: LD_VAR 0 5
78479: PUSH
78480: LD_INT 2
78482: EQUAL
78483: IFFALSE 78493
// btype := b_factory ;
78485: LD_ADDR_VAR 0 5
78489: PUSH
78490: LD_INT 3
78492: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78493: LD_ADDR_VAR 0 4
78497: PUSH
78498: LD_VAR 0 5
78502: PPUSH
78503: LD_VAR 0 1
78507: PPUSH
78508: CALL_OW 248
78512: PPUSH
78513: CALL_OW 450
78517: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78518: LD_ADDR_VAR 0 2
78522: PUSH
78523: LD_VAR 0 3
78527: PPUSH
78528: LD_INT 1
78530: PPUSH
78531: CALL_OW 275
78535: PUSH
78536: LD_VAR 0 4
78540: PUSH
78541: LD_INT 1
78543: ARRAY
78544: GREATEREQUAL
78545: PUSH
78546: LD_VAR 0 3
78550: PPUSH
78551: LD_INT 2
78553: PPUSH
78554: CALL_OW 275
78558: PUSH
78559: LD_VAR 0 4
78563: PUSH
78564: LD_INT 2
78566: ARRAY
78567: GREATEREQUAL
78568: AND
78569: PUSH
78570: LD_VAR 0 3
78574: PPUSH
78575: LD_INT 3
78577: PPUSH
78578: CALL_OW 275
78582: PUSH
78583: LD_VAR 0 4
78587: PUSH
78588: LD_INT 3
78590: ARRAY
78591: GREATEREQUAL
78592: AND
78593: ST_TO_ADDR
// end ;
78594: LD_VAR 0 2
78598: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78599: LD_INT 0
78601: PPUSH
78602: PPUSH
78603: PPUSH
// pom := GetBase ( building ) ;
78604: LD_ADDR_VAR 0 4
78608: PUSH
78609: LD_VAR 0 1
78613: PPUSH
78614: CALL_OW 274
78618: ST_TO_ADDR
// if not pom then
78619: LD_VAR 0 4
78623: NOT
78624: IFFALSE 78628
// exit ;
78626: GO 78729
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78628: LD_ADDR_VAR 0 5
78632: PUSH
78633: LD_VAR 0 2
78637: PPUSH
78638: LD_VAR 0 1
78642: PPUSH
78643: CALL_OW 248
78647: PPUSH
78648: CALL_OW 450
78652: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78653: LD_ADDR_VAR 0 3
78657: PUSH
78658: LD_VAR 0 4
78662: PPUSH
78663: LD_INT 1
78665: PPUSH
78666: CALL_OW 275
78670: PUSH
78671: LD_VAR 0 5
78675: PUSH
78676: LD_INT 1
78678: ARRAY
78679: GREATEREQUAL
78680: PUSH
78681: LD_VAR 0 4
78685: PPUSH
78686: LD_INT 2
78688: PPUSH
78689: CALL_OW 275
78693: PUSH
78694: LD_VAR 0 5
78698: PUSH
78699: LD_INT 2
78701: ARRAY
78702: GREATEREQUAL
78703: AND
78704: PUSH
78705: LD_VAR 0 4
78709: PPUSH
78710: LD_INT 3
78712: PPUSH
78713: CALL_OW 275
78717: PUSH
78718: LD_VAR 0 5
78722: PUSH
78723: LD_INT 3
78725: ARRAY
78726: GREATEREQUAL
78727: AND
78728: ST_TO_ADDR
// end ;
78729: LD_VAR 0 3
78733: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78734: LD_INT 0
78736: PPUSH
78737: PPUSH
78738: PPUSH
78739: PPUSH
78740: PPUSH
78741: PPUSH
78742: PPUSH
78743: PPUSH
78744: PPUSH
78745: PPUSH
// result := false ;
78746: LD_ADDR_VAR 0 6
78750: PUSH
78751: LD_INT 0
78753: ST_TO_ADDR
// if not base or not btype or not x or not y then
78754: LD_VAR 0 1
78758: NOT
78759: PUSH
78760: LD_VAR 0 2
78764: NOT
78765: OR
78766: PUSH
78767: LD_VAR 0 3
78771: NOT
78772: OR
78773: PUSH
78774: LD_VAR 0 4
78778: NOT
78779: OR
78780: IFFALSE 78784
// exit ;
78782: GO 79393
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78784: LD_ADDR_VAR 0 12
78788: PUSH
78789: LD_VAR 0 2
78793: PPUSH
78794: LD_VAR 0 3
78798: PPUSH
78799: LD_VAR 0 4
78803: PPUSH
78804: LD_VAR 0 5
78808: PPUSH
78809: LD_VAR 0 1
78813: PUSH
78814: LD_INT 1
78816: ARRAY
78817: PPUSH
78818: CALL_OW 248
78822: PPUSH
78823: LD_INT 0
78825: PPUSH
78826: CALL 80230 0 6
78830: ST_TO_ADDR
// if not hexes then
78831: LD_VAR 0 12
78835: NOT
78836: IFFALSE 78840
// exit ;
78838: GO 79393
// for i = 1 to hexes do
78840: LD_ADDR_VAR 0 7
78844: PUSH
78845: DOUBLE
78846: LD_INT 1
78848: DEC
78849: ST_TO_ADDR
78850: LD_VAR 0 12
78854: PUSH
78855: FOR_TO
78856: IFFALSE 79391
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78858: LD_ADDR_VAR 0 11
78862: PUSH
78863: LD_VAR 0 12
78867: PUSH
78868: LD_VAR 0 7
78872: ARRAY
78873: PUSH
78874: LD_INT 1
78876: ARRAY
78877: PPUSH
78878: LD_VAR 0 12
78882: PUSH
78883: LD_VAR 0 7
78887: ARRAY
78888: PUSH
78889: LD_INT 2
78891: ARRAY
78892: PPUSH
78893: CALL_OW 428
78897: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78898: LD_VAR 0 12
78902: PUSH
78903: LD_VAR 0 7
78907: ARRAY
78908: PUSH
78909: LD_INT 1
78911: ARRAY
78912: PPUSH
78913: LD_VAR 0 12
78917: PUSH
78918: LD_VAR 0 7
78922: ARRAY
78923: PUSH
78924: LD_INT 2
78926: ARRAY
78927: PPUSH
78928: CALL_OW 351
78932: PUSH
78933: LD_VAR 0 12
78937: PUSH
78938: LD_VAR 0 7
78942: ARRAY
78943: PUSH
78944: LD_INT 1
78946: ARRAY
78947: PPUSH
78948: LD_VAR 0 12
78952: PUSH
78953: LD_VAR 0 7
78957: ARRAY
78958: PUSH
78959: LD_INT 2
78961: ARRAY
78962: PPUSH
78963: CALL_OW 488
78967: NOT
78968: OR
78969: PUSH
78970: LD_VAR 0 11
78974: PPUSH
78975: CALL_OW 247
78979: PUSH
78980: LD_INT 3
78982: EQUAL
78983: OR
78984: IFFALSE 78990
// exit ;
78986: POP
78987: POP
78988: GO 79393
// if not tmp or not tmp in base then
78990: LD_VAR 0 11
78994: NOT
78995: PUSH
78996: LD_VAR 0 11
79000: PUSH
79001: LD_VAR 0 1
79005: IN
79006: NOT
79007: OR
79008: IFFALSE 79012
// continue ;
79010: GO 78855
// result := true ;
79012: LD_ADDR_VAR 0 6
79016: PUSH
79017: LD_INT 1
79019: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79020: LD_ADDR_VAR 0 15
79024: PUSH
79025: LD_VAR 0 1
79029: PPUSH
79030: LD_INT 22
79032: PUSH
79033: LD_VAR 0 11
79037: PPUSH
79038: CALL_OW 255
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 2
79049: PUSH
79050: LD_INT 30
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 30
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: LIST
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PPUSH
79079: CALL_OW 72
79083: ST_TO_ADDR
// if dep then
79084: LD_VAR 0 15
79088: IFFALSE 79224
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79090: LD_ADDR_VAR 0 14
79094: PUSH
79095: LD_VAR 0 15
79099: PUSH
79100: LD_INT 1
79102: ARRAY
79103: PPUSH
79104: CALL_OW 250
79108: PPUSH
79109: LD_VAR 0 15
79113: PUSH
79114: LD_INT 1
79116: ARRAY
79117: PPUSH
79118: CALL_OW 254
79122: PPUSH
79123: LD_INT 5
79125: PPUSH
79126: CALL_OW 272
79130: PUSH
79131: LD_VAR 0 15
79135: PUSH
79136: LD_INT 1
79138: ARRAY
79139: PPUSH
79140: CALL_OW 251
79144: PPUSH
79145: LD_VAR 0 15
79149: PUSH
79150: LD_INT 1
79152: ARRAY
79153: PPUSH
79154: CALL_OW 254
79158: PPUSH
79159: LD_INT 5
79161: PPUSH
79162: CALL_OW 273
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79171: LD_VAR 0 14
79175: PUSH
79176: LD_INT 1
79178: ARRAY
79179: PPUSH
79180: LD_VAR 0 14
79184: PUSH
79185: LD_INT 2
79187: ARRAY
79188: PPUSH
79189: CALL_OW 488
79193: IFFALSE 79224
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79195: LD_VAR 0 11
79199: PPUSH
79200: LD_VAR 0 14
79204: PUSH
79205: LD_INT 1
79207: ARRAY
79208: PPUSH
79209: LD_VAR 0 14
79213: PUSH
79214: LD_INT 2
79216: ARRAY
79217: PPUSH
79218: CALL_OW 111
// continue ;
79222: GO 78855
// end ; end ; r := GetDir ( tmp ) ;
79224: LD_ADDR_VAR 0 13
79228: PUSH
79229: LD_VAR 0 11
79233: PPUSH
79234: CALL_OW 254
79238: ST_TO_ADDR
// if r = 5 then
79239: LD_VAR 0 13
79243: PUSH
79244: LD_INT 5
79246: EQUAL
79247: IFFALSE 79257
// r := 0 ;
79249: LD_ADDR_VAR 0 13
79253: PUSH
79254: LD_INT 0
79256: ST_TO_ADDR
// for j = r to 5 do
79257: LD_ADDR_VAR 0 8
79261: PUSH
79262: DOUBLE
79263: LD_VAR 0 13
79267: DEC
79268: ST_TO_ADDR
79269: LD_INT 5
79271: PUSH
79272: FOR_TO
79273: IFFALSE 79387
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79275: LD_ADDR_VAR 0 9
79279: PUSH
79280: LD_VAR 0 11
79284: PPUSH
79285: CALL_OW 250
79289: PPUSH
79290: LD_VAR 0 8
79294: PPUSH
79295: LD_INT 2
79297: PPUSH
79298: CALL_OW 272
79302: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79303: LD_ADDR_VAR 0 10
79307: PUSH
79308: LD_VAR 0 11
79312: PPUSH
79313: CALL_OW 251
79317: PPUSH
79318: LD_VAR 0 8
79322: PPUSH
79323: LD_INT 2
79325: PPUSH
79326: CALL_OW 273
79330: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79331: LD_VAR 0 9
79335: PPUSH
79336: LD_VAR 0 10
79340: PPUSH
79341: CALL_OW 488
79345: PUSH
79346: LD_VAR 0 9
79350: PPUSH
79351: LD_VAR 0 10
79355: PPUSH
79356: CALL_OW 428
79360: NOT
79361: AND
79362: IFFALSE 79385
// begin ComMoveXY ( tmp , _x , _y ) ;
79364: LD_VAR 0 11
79368: PPUSH
79369: LD_VAR 0 9
79373: PPUSH
79374: LD_VAR 0 10
79378: PPUSH
79379: CALL_OW 111
// break ;
79383: GO 79387
// end ; end ;
79385: GO 79272
79387: POP
79388: POP
// end ;
79389: GO 78855
79391: POP
79392: POP
// end ;
79393: LD_VAR 0 6
79397: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79398: LD_INT 0
79400: PPUSH
79401: PPUSH
79402: PPUSH
79403: PPUSH
79404: PPUSH
79405: PPUSH
79406: PPUSH
79407: PPUSH
79408: PPUSH
79409: PPUSH
// result := false ;
79410: LD_ADDR_VAR 0 6
79414: PUSH
79415: LD_INT 0
79417: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79418: LD_VAR 0 1
79422: NOT
79423: PUSH
79424: LD_VAR 0 1
79428: PPUSH
79429: CALL_OW 266
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: LD_INT 1
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: IN
79444: NOT
79445: OR
79446: PUSH
79447: LD_VAR 0 2
79451: NOT
79452: OR
79453: PUSH
79454: LD_VAR 0 5
79458: PUSH
79459: LD_INT 0
79461: PUSH
79462: LD_INT 1
79464: PUSH
79465: LD_INT 2
79467: PUSH
79468: LD_INT 3
79470: PUSH
79471: LD_INT 4
79473: PUSH
79474: LD_INT 5
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: IN
79485: NOT
79486: OR
79487: PUSH
79488: LD_VAR 0 3
79492: PPUSH
79493: LD_VAR 0 4
79497: PPUSH
79498: CALL_OW 488
79502: NOT
79503: OR
79504: IFFALSE 79508
// exit ;
79506: GO 80225
// pom := GetBase ( depot ) ;
79508: LD_ADDR_VAR 0 10
79512: PUSH
79513: LD_VAR 0 1
79517: PPUSH
79518: CALL_OW 274
79522: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79523: LD_ADDR_VAR 0 11
79527: PUSH
79528: LD_VAR 0 2
79532: PPUSH
79533: LD_VAR 0 1
79537: PPUSH
79538: CALL_OW 248
79542: PPUSH
79543: CALL_OW 450
79547: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79548: LD_VAR 0 10
79552: PPUSH
79553: LD_INT 1
79555: PPUSH
79556: CALL_OW 275
79560: PUSH
79561: LD_VAR 0 11
79565: PUSH
79566: LD_INT 1
79568: ARRAY
79569: GREATEREQUAL
79570: PUSH
79571: LD_VAR 0 10
79575: PPUSH
79576: LD_INT 2
79578: PPUSH
79579: CALL_OW 275
79583: PUSH
79584: LD_VAR 0 11
79588: PUSH
79589: LD_INT 2
79591: ARRAY
79592: GREATEREQUAL
79593: AND
79594: PUSH
79595: LD_VAR 0 10
79599: PPUSH
79600: LD_INT 3
79602: PPUSH
79603: CALL_OW 275
79607: PUSH
79608: LD_VAR 0 11
79612: PUSH
79613: LD_INT 3
79615: ARRAY
79616: GREATEREQUAL
79617: AND
79618: NOT
79619: IFFALSE 79623
// exit ;
79621: GO 80225
// if GetBType ( depot ) = b_depot then
79623: LD_VAR 0 1
79627: PPUSH
79628: CALL_OW 266
79632: PUSH
79633: LD_INT 0
79635: EQUAL
79636: IFFALSE 79648
// dist := 28 else
79638: LD_ADDR_VAR 0 14
79642: PUSH
79643: LD_INT 28
79645: ST_TO_ADDR
79646: GO 79656
// dist := 36 ;
79648: LD_ADDR_VAR 0 14
79652: PUSH
79653: LD_INT 36
79655: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79656: LD_VAR 0 1
79660: PPUSH
79661: LD_VAR 0 3
79665: PPUSH
79666: LD_VAR 0 4
79670: PPUSH
79671: CALL_OW 297
79675: PUSH
79676: LD_VAR 0 14
79680: GREATER
79681: IFFALSE 79685
// exit ;
79683: GO 80225
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79685: LD_ADDR_VAR 0 12
79689: PUSH
79690: LD_VAR 0 2
79694: PPUSH
79695: LD_VAR 0 3
79699: PPUSH
79700: LD_VAR 0 4
79704: PPUSH
79705: LD_VAR 0 5
79709: PPUSH
79710: LD_VAR 0 1
79714: PPUSH
79715: CALL_OW 248
79719: PPUSH
79720: LD_INT 0
79722: PPUSH
79723: CALL 80230 0 6
79727: ST_TO_ADDR
// if not hexes then
79728: LD_VAR 0 12
79732: NOT
79733: IFFALSE 79737
// exit ;
79735: GO 80225
// hex := GetHexInfo ( x , y ) ;
79737: LD_ADDR_VAR 0 15
79741: PUSH
79742: LD_VAR 0 3
79746: PPUSH
79747: LD_VAR 0 4
79751: PPUSH
79752: CALL_OW 546
79756: ST_TO_ADDR
// if hex [ 1 ] then
79757: LD_VAR 0 15
79761: PUSH
79762: LD_INT 1
79764: ARRAY
79765: IFFALSE 79769
// exit ;
79767: GO 80225
// height := hex [ 2 ] ;
79769: LD_ADDR_VAR 0 13
79773: PUSH
79774: LD_VAR 0 15
79778: PUSH
79779: LD_INT 2
79781: ARRAY
79782: ST_TO_ADDR
// for i = 1 to hexes do
79783: LD_ADDR_VAR 0 7
79787: PUSH
79788: DOUBLE
79789: LD_INT 1
79791: DEC
79792: ST_TO_ADDR
79793: LD_VAR 0 12
79797: PUSH
79798: FOR_TO
79799: IFFALSE 80129
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79801: LD_VAR 0 12
79805: PUSH
79806: LD_VAR 0 7
79810: ARRAY
79811: PUSH
79812: LD_INT 1
79814: ARRAY
79815: PPUSH
79816: LD_VAR 0 12
79820: PUSH
79821: LD_VAR 0 7
79825: ARRAY
79826: PUSH
79827: LD_INT 2
79829: ARRAY
79830: PPUSH
79831: CALL_OW 488
79835: NOT
79836: PUSH
79837: LD_VAR 0 12
79841: PUSH
79842: LD_VAR 0 7
79846: ARRAY
79847: PUSH
79848: LD_INT 1
79850: ARRAY
79851: PPUSH
79852: LD_VAR 0 12
79856: PUSH
79857: LD_VAR 0 7
79861: ARRAY
79862: PUSH
79863: LD_INT 2
79865: ARRAY
79866: PPUSH
79867: CALL_OW 428
79871: PUSH
79872: LD_INT 0
79874: GREATER
79875: OR
79876: PUSH
79877: LD_VAR 0 12
79881: PUSH
79882: LD_VAR 0 7
79886: ARRAY
79887: PUSH
79888: LD_INT 1
79890: ARRAY
79891: PPUSH
79892: LD_VAR 0 12
79896: PUSH
79897: LD_VAR 0 7
79901: ARRAY
79902: PUSH
79903: LD_INT 2
79905: ARRAY
79906: PPUSH
79907: CALL_OW 351
79911: OR
79912: IFFALSE 79918
// exit ;
79914: POP
79915: POP
79916: GO 80225
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79918: LD_ADDR_VAR 0 8
79922: PUSH
79923: LD_VAR 0 12
79927: PUSH
79928: LD_VAR 0 7
79932: ARRAY
79933: PUSH
79934: LD_INT 1
79936: ARRAY
79937: PPUSH
79938: LD_VAR 0 12
79942: PUSH
79943: LD_VAR 0 7
79947: ARRAY
79948: PUSH
79949: LD_INT 2
79951: ARRAY
79952: PPUSH
79953: CALL_OW 546
79957: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79958: LD_VAR 0 8
79962: PUSH
79963: LD_INT 1
79965: ARRAY
79966: PUSH
79967: LD_VAR 0 8
79971: PUSH
79972: LD_INT 2
79974: ARRAY
79975: PUSH
79976: LD_VAR 0 13
79980: PUSH
79981: LD_INT 2
79983: PLUS
79984: GREATER
79985: OR
79986: PUSH
79987: LD_VAR 0 8
79991: PUSH
79992: LD_INT 2
79994: ARRAY
79995: PUSH
79996: LD_VAR 0 13
80000: PUSH
80001: LD_INT 2
80003: MINUS
80004: LESS
80005: OR
80006: PUSH
80007: LD_VAR 0 8
80011: PUSH
80012: LD_INT 3
80014: ARRAY
80015: PUSH
80016: LD_INT 0
80018: PUSH
80019: LD_INT 8
80021: PUSH
80022: LD_INT 9
80024: PUSH
80025: LD_INT 10
80027: PUSH
80028: LD_INT 11
80030: PUSH
80031: LD_INT 12
80033: PUSH
80034: LD_INT 13
80036: PUSH
80037: LD_INT 16
80039: PUSH
80040: LD_INT 17
80042: PUSH
80043: LD_INT 18
80045: PUSH
80046: LD_INT 19
80048: PUSH
80049: LD_INT 20
80051: PUSH
80052: LD_INT 21
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: IN
80070: NOT
80071: OR
80072: PUSH
80073: LD_VAR 0 8
80077: PUSH
80078: LD_INT 5
80080: ARRAY
80081: NOT
80082: OR
80083: PUSH
80084: LD_VAR 0 8
80088: PUSH
80089: LD_INT 6
80091: ARRAY
80092: PUSH
80093: LD_INT 1
80095: PUSH
80096: LD_INT 2
80098: PUSH
80099: LD_INT 7
80101: PUSH
80102: LD_INT 9
80104: PUSH
80105: LD_INT 10
80107: PUSH
80108: LD_INT 11
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: IN
80119: NOT
80120: OR
80121: IFFALSE 80127
// exit ;
80123: POP
80124: POP
80125: GO 80225
// end ;
80127: GO 79798
80129: POP
80130: POP
// side := GetSide ( depot ) ;
80131: LD_ADDR_VAR 0 9
80135: PUSH
80136: LD_VAR 0 1
80140: PPUSH
80141: CALL_OW 255
80145: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80146: LD_VAR 0 9
80150: PPUSH
80151: LD_VAR 0 3
80155: PPUSH
80156: LD_VAR 0 4
80160: PPUSH
80161: LD_INT 20
80163: PPUSH
80164: CALL 72879 0 4
80168: PUSH
80169: LD_INT 4
80171: ARRAY
80172: IFFALSE 80176
// exit ;
80174: GO 80225
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80176: LD_VAR 0 2
80180: PUSH
80181: LD_INT 29
80183: PUSH
80184: LD_INT 30
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: IN
80191: PUSH
80192: LD_VAR 0 3
80196: PPUSH
80197: LD_VAR 0 4
80201: PPUSH
80202: LD_VAR 0 9
80206: PPUSH
80207: CALL_OW 440
80211: NOT
80212: AND
80213: IFFALSE 80217
// exit ;
80215: GO 80225
// result := true ;
80217: LD_ADDR_VAR 0 6
80221: PUSH
80222: LD_INT 1
80224: ST_TO_ADDR
// end ;
80225: LD_VAR 0 6
80229: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80230: LD_INT 0
80232: PPUSH
80233: PPUSH
80234: PPUSH
80235: PPUSH
80236: PPUSH
80237: PPUSH
80238: PPUSH
80239: PPUSH
80240: PPUSH
80241: PPUSH
80242: PPUSH
80243: PPUSH
80244: PPUSH
80245: PPUSH
80246: PPUSH
80247: PPUSH
80248: PPUSH
80249: PPUSH
80250: PPUSH
80251: PPUSH
80252: PPUSH
80253: PPUSH
80254: PPUSH
80255: PPUSH
80256: PPUSH
80257: PPUSH
80258: PPUSH
80259: PPUSH
80260: PPUSH
80261: PPUSH
80262: PPUSH
80263: PPUSH
80264: PPUSH
80265: PPUSH
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
80274: PPUSH
80275: PPUSH
80276: PPUSH
80277: PPUSH
80278: PPUSH
80279: PPUSH
80280: PPUSH
80281: PPUSH
80282: PPUSH
80283: PPUSH
80284: PPUSH
80285: PPUSH
80286: PPUSH
80287: PPUSH
80288: PPUSH
80289: PPUSH
// result = [ ] ;
80290: LD_ADDR_VAR 0 7
80294: PUSH
80295: EMPTY
80296: ST_TO_ADDR
// temp_list = [ ] ;
80297: LD_ADDR_VAR 0 9
80301: PUSH
80302: EMPTY
80303: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80304: LD_VAR 0 4
80308: PUSH
80309: LD_INT 0
80311: PUSH
80312: LD_INT 1
80314: PUSH
80315: LD_INT 2
80317: PUSH
80318: LD_INT 3
80320: PUSH
80321: LD_INT 4
80323: PUSH
80324: LD_INT 5
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: IN
80335: NOT
80336: PUSH
80337: LD_VAR 0 1
80341: PUSH
80342: LD_INT 0
80344: PUSH
80345: LD_INT 1
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: IN
80352: PUSH
80353: LD_VAR 0 5
80357: PUSH
80358: LD_INT 1
80360: PUSH
80361: LD_INT 2
80363: PUSH
80364: LD_INT 3
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: LIST
80371: IN
80372: NOT
80373: AND
80374: OR
80375: IFFALSE 80379
// exit ;
80377: GO 98770
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80379: LD_VAR 0 1
80383: PUSH
80384: LD_INT 6
80386: PUSH
80387: LD_INT 7
80389: PUSH
80390: LD_INT 8
80392: PUSH
80393: LD_INT 13
80395: PUSH
80396: LD_INT 12
80398: PUSH
80399: LD_INT 15
80401: PUSH
80402: LD_INT 11
80404: PUSH
80405: LD_INT 14
80407: PUSH
80408: LD_INT 10
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: IN
80422: IFFALSE 80432
// btype = b_lab ;
80424: LD_ADDR_VAR 0 1
80428: PUSH
80429: LD_INT 6
80431: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80432: LD_VAR 0 6
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: LD_INT 1
80442: PUSH
80443: LD_INT 2
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: LIST
80450: IN
80451: NOT
80452: PUSH
80453: LD_VAR 0 1
80457: PUSH
80458: LD_INT 0
80460: PUSH
80461: LD_INT 1
80463: PUSH
80464: LD_INT 2
80466: PUSH
80467: LD_INT 3
80469: PUSH
80470: LD_INT 6
80472: PUSH
80473: LD_INT 36
80475: PUSH
80476: LD_INT 4
80478: PUSH
80479: LD_INT 5
80481: PUSH
80482: LD_INT 31
80484: PUSH
80485: LD_INT 32
80487: PUSH
80488: LD_INT 33
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: IN
80504: NOT
80505: PUSH
80506: LD_VAR 0 6
80510: PUSH
80511: LD_INT 1
80513: EQUAL
80514: AND
80515: OR
80516: PUSH
80517: LD_VAR 0 1
80521: PUSH
80522: LD_INT 2
80524: PUSH
80525: LD_INT 3
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: IN
80532: NOT
80533: PUSH
80534: LD_VAR 0 6
80538: PUSH
80539: LD_INT 2
80541: EQUAL
80542: AND
80543: OR
80544: IFFALSE 80554
// mode = 0 ;
80546: LD_ADDR_VAR 0 6
80550: PUSH
80551: LD_INT 0
80553: ST_TO_ADDR
// case mode of 0 :
80554: LD_VAR 0 6
80558: PUSH
80559: LD_INT 0
80561: DOUBLE
80562: EQUAL
80563: IFTRUE 80567
80565: GO 92020
80567: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80568: LD_ADDR_VAR 0 11
80572: PUSH
80573: LD_INT 0
80575: PUSH
80576: LD_INT 0
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: LD_INT 1
80588: NEG
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: LD_INT 0
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 1
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 0
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 1
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: LD_INT 2
80653: NEG
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 2
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 1
80683: PUSH
80684: LD_INT 2
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 0
80693: PUSH
80694: LD_INT 2
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: LD_INT 1
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 1
80714: PUSH
80715: LD_INT 3
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 0
80724: PUSH
80725: LD_INT 3
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 1
80734: NEG
80735: PUSH
80736: LD_INT 2
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80761: LD_ADDR_VAR 0 12
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 0
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 1
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 1
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: LD_INT 1
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: NEG
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 2
80853: PUSH
80854: LD_INT 0
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 2
80863: PUSH
80864: LD_INT 1
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 1
80873: NEG
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 2
80884: NEG
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 2
80895: NEG
80896: PUSH
80897: LD_INT 1
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 2
80907: NEG
80908: PUSH
80909: LD_INT 1
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 3
80918: NEG
80919: PUSH
80920: LD_INT 0
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 3
80929: NEG
80930: PUSH
80931: LD_INT 1
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80957: LD_ADDR_VAR 0 13
80961: PUSH
80962: LD_INT 0
80964: PUSH
80965: LD_INT 0
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PUSH
80972: LD_INT 0
80974: PUSH
80975: LD_INT 1
80977: NEG
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 1
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 1
80995: PUSH
80996: LD_INT 1
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 0
81005: PUSH
81006: LD_INT 1
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 1
81015: NEG
81016: PUSH
81017: LD_INT 0
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 1
81026: NEG
81027: PUSH
81028: LD_INT 1
81030: NEG
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 1
81038: NEG
81039: PUSH
81040: LD_INT 2
81042: NEG
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 2
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 1
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 2
81080: NEG
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: NEG
81093: PUSH
81094: LD_INT 2
81096: NEG
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: NEG
81105: PUSH
81106: LD_INT 3
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 3
81116: NEG
81117: PUSH
81118: LD_INT 2
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 3
81128: NEG
81129: PUSH
81130: LD_INT 3
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81156: LD_ADDR_VAR 0 14
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 0
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: LD_INT 1
81176: NEG
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 1
81184: PUSH
81185: LD_INT 0
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 1
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: LD_INT 1
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 1
81225: NEG
81226: PUSH
81227: LD_INT 1
81229: NEG
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: LD_INT 2
81241: NEG
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: LD_INT 2
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 1
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 1
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: LD_INT 2
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 1
81291: NEG
81292: PUSH
81293: LD_INT 1
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 1
81302: NEG
81303: PUSH
81304: LD_INT 3
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 0
81314: PUSH
81315: LD_INT 3
81317: NEG
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: PUSH
81323: LD_INT 1
81325: PUSH
81326: LD_INT 2
81328: NEG
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81352: LD_ADDR_VAR 0 15
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: LD_INT 0
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 0
81369: PUSH
81370: LD_INT 1
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: LD_INT 0
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 1
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: LD_INT 1
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: NEG
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 1
81421: NEG
81422: PUSH
81423: LD_INT 1
81425: NEG
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: LD_INT 1
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 2
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 2
81454: PUSH
81455: LD_INT 1
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 1
81464: NEG
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 2
81475: NEG
81476: PUSH
81477: LD_INT 0
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 2
81486: NEG
81487: PUSH
81488: LD_INT 1
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 2
81498: PUSH
81499: LD_INT 1
81501: NEG
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 3
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 3
81519: PUSH
81520: LD_INT 1
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81545: LD_ADDR_VAR 0 16
81549: PUSH
81550: LD_INT 0
81552: PUSH
81553: LD_INT 0
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: LD_INT 1
81565: NEG
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 1
81573: PUSH
81574: LD_INT 0
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 1
81583: PUSH
81584: LD_INT 1
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 0
81593: PUSH
81594: LD_INT 1
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: NEG
81604: PUSH
81605: LD_INT 0
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 1
81614: NEG
81615: PUSH
81616: LD_INT 1
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 1
81626: NEG
81627: PUSH
81628: LD_INT 2
81630: NEG
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 2
81638: PUSH
81639: LD_INT 1
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 2
81648: PUSH
81649: LD_INT 2
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: LD_INT 2
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 2
81668: NEG
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 2
81680: NEG
81681: PUSH
81682: LD_INT 2
81684: NEG
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 3
81692: PUSH
81693: LD_INT 2
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 3
81702: PUSH
81703: LD_INT 3
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: LD_INT 3
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81738: LD_ADDR_VAR 0 17
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: LD_INT 0
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: LD_INT 1
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 1
81796: NEG
81797: PUSH
81798: LD_INT 0
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 1
81807: NEG
81808: PUSH
81809: LD_INT 1
81811: NEG
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: LD_INT 2
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 2
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 1
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 2
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 1
81883: PUSH
81884: LD_INT 2
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 1
81903: NEG
81904: PUSH
81905: LD_INT 1
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 2
81914: NEG
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 2
81925: NEG
81926: PUSH
81927: LD_INT 1
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: LD_INT 2
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81968: LD_ADDR_VAR 0 18
81972: PUSH
81973: LD_INT 0
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: LD_INT 1
81988: NEG
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 1
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: LD_INT 1
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 1
82037: NEG
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: LD_INT 2
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 2
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 2
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 2
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: LD_INT 2
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: LD_INT 0
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82198: LD_ADDR_VAR 0 19
82202: PUSH
82203: LD_INT 0
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 1
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 1
82256: NEG
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: NEG
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 2
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 2
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 1
82363: NEG
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: NEG
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 2
82401: NEG
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82428: LD_ADDR_VAR 0 20
82432: PUSH
82433: LD_INT 0
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: LD_INT 1
82448: NEG
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: LD_INT 1
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: LD_INT 1
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 1
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: LD_INT 2
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 1
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 2
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: LD_INT 2
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: LD_INT 2
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: LD_INT 2
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 1
82593: NEG
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: NEG
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: NEG
82616: PUSH
82617: LD_INT 1
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 2
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82658: LD_ADDR_VAR 0 21
82662: PUSH
82663: LD_INT 0
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 0
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: NEG
82728: PUSH
82729: LD_INT 1
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 1
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 1
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 2
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: NEG
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 2
82845: NEG
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 2
82857: NEG
82858: PUSH
82859: LD_INT 2
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82888: LD_ADDR_VAR 0 22
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: LD_INT 0
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: LD_INT 1
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 1
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 1
82926: PUSH
82927: LD_INT 1
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: LD_INT 1
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 2
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 2
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 2
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 2
83013: PUSH
83014: LD_INT 1
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 2
83023: PUSH
83024: LD_INT 2
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: LD_INT 2
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 1
83053: NEG
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 2
83064: NEG
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 2
83075: NEG
83076: PUSH
83077: LD_INT 1
83079: NEG
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 2
83087: NEG
83088: PUSH
83089: LD_INT 2
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83118: LD_ADDR_VAR 0 23
83122: PUSH
83123: LD_INT 0
83125: PUSH
83126: LD_INT 0
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 1
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 1
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: NEG
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: LD_INT 1
83187: NEG
83188: PUSH
83189: LD_INT 1
83191: NEG
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 1
83199: NEG
83200: PUSH
83201: LD_INT 2
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 0
83211: PUSH
83212: LD_INT 2
83214: NEG
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: PUSH
83223: LD_INT 1
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 2
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 2
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 2
83253: PUSH
83254: LD_INT 2
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 1
83263: PUSH
83264: LD_INT 2
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: LD_INT 2
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 2
83294: NEG
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 2
83305: NEG
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: LD_INT 2
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: NEG
83330: PUSH
83331: LD_INT 3
83333: NEG
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 1
83341: NEG
83342: PUSH
83343: LD_INT 3
83345: NEG
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: LD_INT 2
83356: NEG
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 2
83364: PUSH
83365: LD_INT 1
83367: NEG
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83398: LD_ADDR_VAR 0 24
83402: PUSH
83403: LD_INT 0
83405: PUSH
83406: LD_INT 0
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: LD_INT 1
83418: NEG
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: PUSH
83427: LD_INT 0
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 1
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 0
83446: PUSH
83447: LD_INT 1
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: LD_INT 2
83483: NEG
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 0
83491: PUSH
83492: LD_INT 2
83494: NEG
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: LD_INT 1
83505: NEG
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 2
83513: PUSH
83514: LD_INT 0
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 2
83533: PUSH
83534: LD_INT 2
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: PUSH
83544: LD_INT 2
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 2
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 1
83563: NEG
83564: PUSH
83565: LD_INT 1
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 2
83574: NEG
83575: PUSH
83576: LD_INT 0
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 2
83585: NEG
83586: PUSH
83587: LD_INT 1
83589: NEG
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 2
83597: NEG
83598: PUSH
83599: LD_INT 2
83601: NEG
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_INT 1
83609: PUSH
83610: LD_INT 2
83612: NEG
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 2
83620: PUSH
83621: LD_INT 1
83623: NEG
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 3
83631: PUSH
83632: LD_INT 1
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 3
83641: PUSH
83642: LD_INT 2
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83674: LD_ADDR_VAR 0 25
83678: PUSH
83679: LD_INT 0
83681: PUSH
83682: LD_INT 0
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 0
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 1
83702: PUSH
83703: LD_INT 0
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 1
83712: PUSH
83713: LD_INT 1
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 0
83722: PUSH
83723: LD_INT 1
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: NEG
83733: PUSH
83734: LD_INT 0
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 1
83743: NEG
83744: PUSH
83745: LD_INT 1
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 1
83755: NEG
83756: PUSH
83757: LD_INT 2
83759: NEG
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: LD_INT 2
83770: NEG
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: PUSH
83779: LD_INT 1
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 2
83789: PUSH
83790: LD_INT 0
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 2
83799: PUSH
83800: LD_INT 1
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 2
83809: PUSH
83810: LD_INT 2
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: LD_INT 2
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 2
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 1
83839: NEG
83840: PUSH
83841: LD_INT 1
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 2
83850: NEG
83851: PUSH
83852: LD_INT 0
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 2
83861: NEG
83862: PUSH
83863: LD_INT 1
83865: NEG
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 2
83873: NEG
83874: PUSH
83875: LD_INT 2
83877: NEG
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 3
83885: PUSH
83886: LD_INT 1
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 3
83895: PUSH
83896: LD_INT 2
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 2
83905: PUSH
83906: LD_INT 3
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 1
83915: PUSH
83916: LD_INT 3
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83948: LD_ADDR_VAR 0 26
83952: PUSH
83953: LD_INT 0
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: LD_INT 1
83968: NEG
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 1
83976: PUSH
83977: LD_INT 0
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 1
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 0
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 1
84006: NEG
84007: PUSH
84008: LD_INT 0
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 1
84017: NEG
84018: PUSH
84019: LD_INT 1
84021: NEG
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 1
84029: NEG
84030: PUSH
84031: LD_INT 2
84033: NEG
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: LD_INT 2
84044: NEG
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: LD_INT 1
84055: NEG
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 2
84063: PUSH
84064: LD_INT 0
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 2
84073: PUSH
84074: LD_INT 1
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 2
84083: PUSH
84084: LD_INT 2
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 1
84093: PUSH
84094: LD_INT 2
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 0
84103: PUSH
84104: LD_INT 2
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 1
84113: NEG
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 2
84124: NEG
84125: PUSH
84126: LD_INT 0
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 2
84135: NEG
84136: PUSH
84137: LD_INT 1
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 2
84147: NEG
84148: PUSH
84149: LD_INT 2
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 2
84159: PUSH
84160: LD_INT 3
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: PUSH
84170: LD_INT 3
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 1
84179: NEG
84180: PUSH
84181: LD_INT 2
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 2
84190: NEG
84191: PUSH
84192: LD_INT 1
84194: PUSH
84195: EMPTY
84196: LIST
84197: LIST
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84224: LD_ADDR_VAR 0 27
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: NEG
84283: PUSH
84284: LD_INT 0
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 1
84293: NEG
84294: PUSH
84295: LD_INT 1
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 2
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 0
84317: PUSH
84318: LD_INT 2
84320: NEG
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 1
84328: PUSH
84329: LD_INT 1
84331: NEG
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 2
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 2
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 2
84359: PUSH
84360: LD_INT 2
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: PUSH
84370: LD_INT 2
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: LD_INT 2
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 1
84389: NEG
84390: PUSH
84391: LD_INT 1
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 2
84400: NEG
84401: PUSH
84402: LD_INT 0
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 2
84411: NEG
84412: PUSH
84413: LD_INT 1
84415: NEG
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 2
84423: NEG
84424: PUSH
84425: LD_INT 2
84427: NEG
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 1
84435: NEG
84436: PUSH
84437: LD_INT 2
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 2
84446: NEG
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 3
84457: NEG
84458: PUSH
84459: LD_INT 1
84461: NEG
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 3
84469: NEG
84470: PUSH
84471: LD_INT 2
84473: NEG
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84504: LD_ADDR_VAR 0 28
84508: PUSH
84509: LD_INT 0
84511: PUSH
84512: LD_INT 0
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 0
84521: PUSH
84522: LD_INT 1
84524: NEG
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 1
84532: PUSH
84533: LD_INT 0
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 1
84542: PUSH
84543: LD_INT 1
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 0
84552: PUSH
84553: LD_INT 1
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 1
84562: NEG
84563: PUSH
84564: LD_INT 0
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 1
84573: NEG
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 1
84585: NEG
84586: PUSH
84587: LD_INT 2
84589: NEG
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: LD_INT 2
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 1
84611: NEG
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 2
84629: PUSH
84630: LD_INT 1
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 2
84639: PUSH
84640: LD_INT 2
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: LD_INT 2
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: LD_INT 2
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 1
84669: NEG
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 2
84680: NEG
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 2
84691: NEG
84692: PUSH
84693: LD_INT 1
84695: NEG
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 2
84703: NEG
84704: PUSH
84705: LD_INT 2
84707: NEG
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 2
84715: NEG
84716: PUSH
84717: LD_INT 3
84719: NEG
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 1
84727: NEG
84728: PUSH
84729: LD_INT 3
84731: NEG
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 3
84739: NEG
84740: PUSH
84741: LD_INT 1
84743: NEG
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 3
84751: NEG
84752: PUSH
84753: LD_INT 2
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84786: LD_ADDR_VAR 0 29
84790: PUSH
84791: LD_INT 0
84793: PUSH
84794: LD_INT 0
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 0
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 1
84814: PUSH
84815: LD_INT 0
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 1
84824: PUSH
84825: LD_INT 1
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 0
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 1
84844: NEG
84845: PUSH
84846: LD_INT 0
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: PUSH
84853: LD_INT 1
84855: NEG
84856: PUSH
84857: LD_INT 1
84859: NEG
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 1
84867: NEG
84868: PUSH
84869: LD_INT 2
84871: NEG
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 0
84879: PUSH
84880: LD_INT 2
84882: NEG
84883: PUSH
84884: EMPTY
84885: LIST
84886: LIST
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: LD_INT 1
84893: NEG
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 2
84901: PUSH
84902: LD_INT 0
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 2
84911: PUSH
84912: LD_INT 1
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 1
84921: PUSH
84922: LD_INT 2
84924: PUSH
84925: EMPTY
84926: LIST
84927: LIST
84928: PUSH
84929: LD_INT 0
84931: PUSH
84932: LD_INT 2
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 2
84952: NEG
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 2
84964: NEG
84965: PUSH
84966: LD_INT 2
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 2
84976: NEG
84977: PUSH
84978: LD_INT 3
84980: NEG
84981: PUSH
84982: EMPTY
84983: LIST
84984: LIST
84985: PUSH
84986: LD_INT 2
84988: PUSH
84989: LD_INT 1
84991: NEG
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 3
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 1
85009: PUSH
85010: LD_INT 3
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: LD_INT 2
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 3
85030: NEG
85031: PUSH
85032: LD_INT 2
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85065: LD_ADDR_VAR 0 30
85069: PUSH
85070: LD_INT 0
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 0
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: PUSH
85094: LD_INT 0
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: LD_INT 0
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 1
85134: NEG
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: LD_INT 2
85150: NEG
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: LD_INT 2
85161: NEG
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 1
85169: PUSH
85170: LD_INT 1
85172: NEG
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 2
85180: PUSH
85181: LD_INT 0
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 2
85190: PUSH
85191: LD_INT 1
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 2
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: EMPTY
85205: LIST
85206: LIST
85207: PUSH
85208: LD_INT 1
85210: PUSH
85211: LD_INT 2
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 1
85220: NEG
85221: PUSH
85222: LD_INT 1
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 2
85231: NEG
85232: PUSH
85233: LD_INT 0
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 2
85242: NEG
85243: PUSH
85244: LD_INT 1
85246: NEG
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 3
85258: NEG
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: PUSH
85267: LD_INT 2
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: LD_INT 2
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 2
85287: PUSH
85288: LD_INT 3
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 2
85297: NEG
85298: PUSH
85299: LD_INT 1
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 3
85308: NEG
85309: PUSH
85310: LD_INT 1
85312: NEG
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85343: LD_ADDR_VAR 0 31
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: LD_INT 0
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: LD_INT 1
85363: NEG
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 1
85371: PUSH
85372: LD_INT 0
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: LD_INT 1
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 1
85401: NEG
85402: PUSH
85403: LD_INT 0
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 1
85412: NEG
85413: PUSH
85414: LD_INT 1
85416: NEG
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 1
85424: NEG
85425: PUSH
85426: LD_INT 2
85428: NEG
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 1
85436: PUSH
85437: LD_INT 1
85439: NEG
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PUSH
85445: LD_INT 2
85447: PUSH
85448: LD_INT 0
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 2
85457: PUSH
85458: LD_INT 1
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 2
85467: PUSH
85468: LD_INT 2
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 1
85477: PUSH
85478: LD_INT 2
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 0
85487: PUSH
85488: LD_INT 2
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 1
85497: NEG
85498: PUSH
85499: LD_INT 1
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 2
85508: NEG
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 2
85520: NEG
85521: PUSH
85522: LD_INT 2
85524: NEG
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 2
85532: NEG
85533: PUSH
85534: LD_INT 3
85536: NEG
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 3
85555: PUSH
85556: LD_INT 1
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 3
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: LD_INT 2
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: LD_INT 3
85586: NEG
85587: PUSH
85588: LD_INT 2
85590: NEG
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85621: LD_ADDR_VAR 0 32
85625: PUSH
85626: LD_INT 0
85628: PUSH
85629: LD_INT 0
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 0
85638: PUSH
85639: LD_INT 1
85641: NEG
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 1
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: LD_INT 1
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: LD_INT 0
85669: PUSH
85670: LD_INT 1
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 1
85679: NEG
85680: PUSH
85681: LD_INT 0
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: NEG
85691: PUSH
85692: LD_INT 1
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: NEG
85703: PUSH
85704: LD_INT 2
85706: NEG
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 0
85714: PUSH
85715: LD_INT 2
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: LD_INT 1
85728: NEG
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: PUSH
85734: LD_INT 2
85736: PUSH
85737: LD_INT 1
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 2
85746: PUSH
85747: LD_INT 2
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 1
85756: PUSH
85757: LD_INT 2
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: LD_INT 2
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: NEG
85777: PUSH
85778: LD_INT 1
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 2
85787: NEG
85788: PUSH
85789: LD_INT 0
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: LD_INT 2
85798: NEG
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: PUSH
85808: LD_INT 1
85810: NEG
85811: PUSH
85812: LD_INT 3
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: PUSH
85823: LD_INT 2
85825: NEG
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 3
85833: PUSH
85834: LD_INT 2
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 2
85843: PUSH
85844: LD_INT 3
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: LD_INT 2
85853: NEG
85854: PUSH
85855: LD_INT 1
85857: PUSH
85858: EMPTY
85859: LIST
85860: LIST
85861: PUSH
85862: LD_INT 3
85864: NEG
85865: PUSH
85866: LD_INT 1
85868: NEG
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85899: LD_ADDR_VAR 0 33
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: LD_INT 0
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 0
85916: PUSH
85917: LD_INT 1
85919: NEG
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 1
85927: PUSH
85928: LD_INT 0
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 1
85937: PUSH
85938: LD_INT 1
85940: PUSH
85941: EMPTY
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 0
85947: PUSH
85948: LD_INT 1
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 1
85957: NEG
85958: PUSH
85959: LD_INT 0
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 1
85968: NEG
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: NEG
85981: PUSH
85982: LD_INT 2
85984: NEG
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 1
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 2
86003: PUSH
86004: LD_INT 0
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 2
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 1
86023: PUSH
86024: LD_INT 2
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 0
86033: PUSH
86034: LD_INT 2
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 1
86043: NEG
86044: PUSH
86045: LD_INT 1
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 2
86054: NEG
86055: PUSH
86056: LD_INT 0
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 2
86065: NEG
86066: PUSH
86067: LD_INT 1
86069: NEG
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 2
86077: NEG
86078: PUSH
86079: LD_INT 2
86081: NEG
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 2
86089: NEG
86090: PUSH
86091: LD_INT 3
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 2
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 3
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: LD_INT 3
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: LD_INT 2
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 3
86143: NEG
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86178: LD_ADDR_VAR 0 34
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 0
86195: PUSH
86196: LD_INT 1
86198: NEG
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 1
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 1
86285: NEG
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: LD_INT 1
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: LD_INT 2
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 1
86313: PUSH
86314: LD_INT 2
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 1
86323: NEG
86324: PUSH
86325: LD_INT 1
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 2
86334: NEG
86335: PUSH
86336: LD_INT 0
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 2
86345: NEG
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 2
86357: NEG
86358: PUSH
86359: LD_INT 2
86361: NEG
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: LD_INT 3
86373: NEG
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 1
86381: PUSH
86382: LD_INT 2
86384: NEG
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 3
86392: PUSH
86393: LD_INT 2
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: PUSH
86400: LD_INT 2
86402: PUSH
86403: LD_INT 3
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 2
86412: NEG
86413: PUSH
86414: LD_INT 1
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 3
86423: NEG
86424: PUSH
86425: LD_INT 1
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86458: LD_ADDR_VAR 0 35
86462: PUSH
86463: LD_INT 0
86465: PUSH
86466: LD_INT 0
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 0
86475: PUSH
86476: LD_INT 1
86478: NEG
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 1
86486: PUSH
86487: LD_INT 0
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: PUSH
86494: LD_INT 1
86496: PUSH
86497: LD_INT 1
86499: PUSH
86500: EMPTY
86501: LIST
86502: LIST
86503: PUSH
86504: LD_INT 0
86506: PUSH
86507: LD_INT 1
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: LD_INT 0
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 1
86527: NEG
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 2
86539: PUSH
86540: LD_INT 1
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 2
86549: NEG
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86570: LD_ADDR_VAR 0 36
86574: PUSH
86575: LD_INT 0
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 1
86598: PUSH
86599: LD_INT 0
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: LD_INT 1
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: LD_INT 1
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 1
86628: NEG
86629: PUSH
86630: LD_INT 0
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 1
86639: NEG
86640: PUSH
86641: LD_INT 1
86643: NEG
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 1
86651: NEG
86652: PUSH
86653: LD_INT 2
86655: NEG
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: PUSH
86661: LD_INT 1
86663: PUSH
86664: LD_INT 2
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86682: LD_ADDR_VAR 0 37
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 0
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 0
86699: PUSH
86700: LD_INT 1
86702: NEG
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 1
86720: PUSH
86721: LD_INT 1
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 0
86730: PUSH
86731: LD_INT 1
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: NEG
86741: PUSH
86742: LD_INT 0
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 1
86751: NEG
86752: PUSH
86753: LD_INT 1
86755: NEG
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 1
86763: PUSH
86764: LD_INT 1
86766: NEG
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 1
86774: NEG
86775: PUSH
86776: LD_INT 1
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86794: LD_ADDR_VAR 0 38
86798: PUSH
86799: LD_INT 0
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 0
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: LD_INT 0
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 1
86832: PUSH
86833: LD_INT 1
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 0
86842: PUSH
86843: LD_INT 1
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 1
86852: NEG
86853: PUSH
86854: LD_INT 0
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: LD_INT 1
86867: NEG
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 2
86875: PUSH
86876: LD_INT 1
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 2
86885: NEG
86886: PUSH
86887: LD_INT 1
86889: NEG
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86906: LD_ADDR_VAR 0 39
86910: PUSH
86911: LD_INT 0
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: LD_INT 1
86926: NEG
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 1
86934: PUSH
86935: LD_INT 0
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: NEG
86976: PUSH
86977: LD_INT 1
86979: NEG
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 1
86999: PUSH
87000: LD_INT 2
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87018: LD_ADDR_VAR 0 40
87022: PUSH
87023: LD_INT 0
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: LD_INT 1
87038: NEG
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: LD_INT 0
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 1
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 0
87066: PUSH
87067: LD_INT 1
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: LD_INT 0
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: LD_INT 1
87091: NEG
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 1
87099: PUSH
87100: LD_INT 1
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: LD_INT 1
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87130: LD_ADDR_VAR 0 41
87134: PUSH
87135: LD_INT 0
87137: PUSH
87138: LD_INT 0
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 0
87147: PUSH
87148: LD_INT 1
87150: NEG
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 1
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 1
87168: PUSH
87169: LD_INT 1
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: PUSH
87176: LD_INT 0
87178: PUSH
87179: LD_INT 1
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 1
87188: NEG
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: NEG
87200: PUSH
87201: LD_INT 1
87203: NEG
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 1
87211: NEG
87212: PUSH
87213: LD_INT 2
87215: NEG
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 1
87223: PUSH
87224: LD_INT 1
87226: NEG
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 2
87234: PUSH
87235: LD_INT 0
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 2
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 2
87254: PUSH
87255: LD_INT 2
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: LD_INT 2
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: LD_INT 1
87274: NEG
87275: PUSH
87276: LD_INT 1
87278: PUSH
87279: EMPTY
87280: LIST
87281: LIST
87282: PUSH
87283: LD_INT 2
87285: NEG
87286: PUSH
87287: LD_INT 0
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: LD_INT 1
87300: NEG
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 2
87308: NEG
87309: PUSH
87310: LD_INT 2
87312: NEG
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 2
87320: NEG
87321: PUSH
87322: LD_INT 3
87324: NEG
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: LD_INT 1
87335: NEG
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: PUSH
87341: LD_INT 3
87343: PUSH
87344: LD_INT 0
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 3
87353: PUSH
87354: LD_INT 1
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 3
87363: PUSH
87364: LD_INT 2
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 3
87373: PUSH
87374: LD_INT 3
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 2
87383: PUSH
87384: LD_INT 3
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 2
87393: NEG
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 3
87404: NEG
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 3
87415: NEG
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 3
87427: NEG
87428: PUSH
87429: LD_INT 2
87431: NEG
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 3
87439: NEG
87440: PUSH
87441: LD_INT 3
87443: NEG
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87480: LD_ADDR_VAR 0 42
87484: PUSH
87485: LD_INT 0
87487: PUSH
87488: LD_INT 0
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 0
87528: PUSH
87529: LD_INT 1
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: NEG
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 1
87549: NEG
87550: PUSH
87551: LD_INT 1
87553: NEG
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: NEG
87562: PUSH
87563: LD_INT 2
87565: NEG
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 0
87573: PUSH
87574: LD_INT 2
87576: NEG
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: LD_INT 1
87587: NEG
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 2
87595: PUSH
87596: LD_INT 1
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 2
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 1
87615: PUSH
87616: LD_INT 2
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 0
87625: PUSH
87626: LD_INT 2
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 1
87635: NEG
87636: PUSH
87637: LD_INT 1
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 2
87646: NEG
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 2
87658: NEG
87659: PUSH
87660: LD_INT 2
87662: NEG
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: LD_INT 2
87670: NEG
87671: PUSH
87672: LD_INT 3
87674: NEG
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: LD_INT 3
87686: NEG
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: LD_INT 3
87697: NEG
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 1
87705: PUSH
87706: LD_INT 2
87708: NEG
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 3
87716: PUSH
87717: LD_INT 2
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 3
87726: PUSH
87727: LD_INT 3
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 2
87736: PUSH
87737: LD_INT 3
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 1
87746: PUSH
87747: LD_INT 3
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 0
87756: PUSH
87757: LD_INT 3
87759: PUSH
87760: EMPTY
87761: LIST
87762: LIST
87763: PUSH
87764: LD_INT 1
87766: NEG
87767: PUSH
87768: LD_INT 2
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 3
87777: NEG
87778: PUSH
87779: LD_INT 2
87781: NEG
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 3
87789: NEG
87790: PUSH
87791: LD_INT 3
87793: NEG
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87830: LD_ADDR_VAR 0 43
87834: PUSH
87835: LD_INT 0
87837: PUSH
87838: LD_INT 0
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 0
87847: PUSH
87848: LD_INT 1
87850: NEG
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 1
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: LD_INT 1
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: LD_INT 1
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 1
87899: NEG
87900: PUSH
87901: LD_INT 1
87903: NEG
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 1
87911: NEG
87912: PUSH
87913: LD_INT 2
87915: NEG
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 0
87923: PUSH
87924: LD_INT 2
87926: NEG
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: LD_INT 1
87937: NEG
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 2
87945: PUSH
87946: LD_INT 0
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: PUSH
87953: LD_INT 2
87955: PUSH
87956: LD_INT 1
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: PUSH
87966: LD_INT 2
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 0
87975: PUSH
87976: LD_INT 2
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: PUSH
87983: LD_INT 1
87985: NEG
87986: PUSH
87987: LD_INT 1
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 2
87996: NEG
87997: PUSH
87998: LD_INT 0
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 2
88007: NEG
88008: PUSH
88009: LD_INT 1
88011: NEG
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 1
88019: NEG
88020: PUSH
88021: LD_INT 3
88023: NEG
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 0
88031: PUSH
88032: LD_INT 3
88034: NEG
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 1
88042: PUSH
88043: LD_INT 2
88045: NEG
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: LD_INT 2
88053: PUSH
88054: LD_INT 1
88056: NEG
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 3
88064: PUSH
88065: LD_INT 0
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 3
88074: PUSH
88075: LD_INT 1
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: LD_INT 3
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: PUSH
88092: LD_INT 0
88094: PUSH
88095: LD_INT 3
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 1
88104: NEG
88105: PUSH
88106: LD_INT 2
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 2
88115: NEG
88116: PUSH
88117: LD_INT 1
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 3
88126: NEG
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 3
88137: NEG
88138: PUSH
88139: LD_INT 1
88141: NEG
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88178: LD_ADDR_VAR 0 44
88182: PUSH
88183: LD_INT 0
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 0
88195: PUSH
88196: LD_INT 1
88198: NEG
88199: PUSH
88200: EMPTY
88201: LIST
88202: LIST
88203: PUSH
88204: LD_INT 1
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: LD_INT 1
88216: PUSH
88217: LD_INT 1
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 0
88226: PUSH
88227: LD_INT 1
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: PUSH
88234: LD_INT 1
88236: NEG
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 1
88247: NEG
88248: PUSH
88249: LD_INT 1
88251: NEG
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: LD_INT 2
88263: NEG
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: LD_INT 1
88274: NEG
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: PUSH
88283: LD_INT 0
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 2
88292: PUSH
88293: LD_INT 1
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 2
88302: PUSH
88303: LD_INT 2
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 1
88312: PUSH
88313: LD_INT 2
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 1
88322: NEG
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 2
88333: NEG
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: LD_INT 1
88348: NEG
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 2
88356: NEG
88357: PUSH
88358: LD_INT 2
88360: NEG
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 2
88368: NEG
88369: PUSH
88370: LD_INT 3
88372: NEG
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 2
88380: PUSH
88381: LD_INT 1
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 3
88391: PUSH
88392: LD_INT 0
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 3
88401: PUSH
88402: LD_INT 1
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 3
88411: PUSH
88412: LD_INT 2
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 3
88421: PUSH
88422: LD_INT 3
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 2
88431: PUSH
88432: LD_INT 3
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 2
88441: NEG
88442: PUSH
88443: LD_INT 1
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: PUSH
88450: LD_INT 3
88452: NEG
88453: PUSH
88454: LD_INT 0
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 3
88463: NEG
88464: PUSH
88465: LD_INT 1
88467: NEG
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 3
88475: NEG
88476: PUSH
88477: LD_INT 2
88479: NEG
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 3
88487: NEG
88488: PUSH
88489: LD_INT 3
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88528: LD_ADDR_VAR 0 45
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: LD_INT 0
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 1
88566: PUSH
88567: LD_INT 1
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 0
88576: PUSH
88577: LD_INT 1
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 1
88597: NEG
88598: PUSH
88599: LD_INT 1
88601: NEG
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: NEG
88610: PUSH
88611: LD_INT 2
88613: NEG
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 0
88621: PUSH
88622: LD_INT 2
88624: NEG
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: LD_INT 1
88635: NEG
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 2
88643: PUSH
88644: LD_INT 1
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 2
88653: PUSH
88654: LD_INT 2
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: LD_INT 2
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: LD_INT 2
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 1
88683: NEG
88684: PUSH
88685: LD_INT 1
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: LD_INT 1
88698: NEG
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 2
88706: NEG
88707: PUSH
88708: LD_INT 2
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 2
88718: NEG
88719: PUSH
88720: LD_INT 3
88722: NEG
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 1
88730: NEG
88731: PUSH
88732: LD_INT 3
88734: NEG
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 0
88742: PUSH
88743: LD_INT 3
88745: NEG
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: PUSH
88754: LD_INT 2
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 3
88764: PUSH
88765: LD_INT 2
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 3
88774: PUSH
88775: LD_INT 3
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 2
88784: PUSH
88785: LD_INT 3
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: LD_INT 3
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 0
88804: PUSH
88805: LD_INT 3
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 1
88814: NEG
88815: PUSH
88816: LD_INT 2
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 3
88825: NEG
88826: PUSH
88827: LD_INT 2
88829: NEG
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 3
88837: NEG
88838: PUSH
88839: LD_INT 3
88841: NEG
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88878: LD_ADDR_VAR 0 46
88882: PUSH
88883: LD_INT 0
88885: PUSH
88886: LD_INT 0
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 0
88895: PUSH
88896: LD_INT 1
88898: NEG
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: LD_INT 0
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: LD_INT 1
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: LD_INT 1
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: LD_INT 0
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 1
88947: NEG
88948: PUSH
88949: LD_INT 1
88951: NEG
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: LD_INT 1
88959: NEG
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 0
88971: PUSH
88972: LD_INT 2
88974: NEG
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 1
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 2
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 2
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 1
89013: PUSH
89014: LD_INT 2
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 0
89023: PUSH
89024: LD_INT 2
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 1
89033: NEG
89034: PUSH
89035: LD_INT 1
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 2
89044: NEG
89045: PUSH
89046: LD_INT 0
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 2
89055: NEG
89056: PUSH
89057: LD_INT 1
89059: NEG
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 1
89067: NEG
89068: PUSH
89069: LD_INT 3
89071: NEG
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 0
89079: PUSH
89080: LD_INT 3
89082: NEG
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: LD_INT 2
89093: NEG
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 2
89101: PUSH
89102: LD_INT 1
89104: NEG
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 3
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 3
89122: PUSH
89123: LD_INT 1
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: LD_INT 3
89135: PUSH
89136: EMPTY
89137: LIST
89138: LIST
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: LD_INT 3
89145: PUSH
89146: EMPTY
89147: LIST
89148: LIST
89149: PUSH
89150: LD_INT 1
89152: NEG
89153: PUSH
89154: LD_INT 2
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 2
89163: NEG
89164: PUSH
89165: LD_INT 1
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 3
89174: NEG
89175: PUSH
89176: LD_INT 0
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 3
89185: NEG
89186: PUSH
89187: LD_INT 1
89189: NEG
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89226: LD_ADDR_VAR 0 47
89230: PUSH
89231: LD_INT 0
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 0
89243: PUSH
89244: LD_INT 1
89246: NEG
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 1
89254: PUSH
89255: LD_INT 0
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: LD_INT 1
89264: PUSH
89265: LD_INT 1
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: LD_INT 1
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: NEG
89285: PUSH
89286: LD_INT 0
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: LD_INT 1
89299: NEG
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 1
89307: NEG
89308: PUSH
89309: LD_INT 2
89311: NEG
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 0
89319: PUSH
89320: LD_INT 2
89322: NEG
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 1
89330: PUSH
89331: LD_INT 1
89333: NEG
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 2
89341: NEG
89342: PUSH
89343: LD_INT 1
89345: NEG
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 2
89353: NEG
89354: PUSH
89355: LD_INT 2
89357: NEG
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89377: LD_ADDR_VAR 0 48
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: LD_INT 0
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: LD_INT 0
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 1
89405: PUSH
89406: LD_INT 0
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 1
89415: PUSH
89416: LD_INT 1
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: PUSH
89429: EMPTY
89430: LIST
89431: LIST
89432: PUSH
89433: LD_INT 1
89435: NEG
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: NEG
89447: PUSH
89448: LD_INT 1
89450: NEG
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: LD_INT 2
89462: NEG
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: LD_INT 2
89473: NEG
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: LD_INT 1
89484: NEG
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 2
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 2
89502: PUSH
89503: LD_INT 1
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: EMPTY
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89524: LD_ADDR_VAR 0 49
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 0
89541: PUSH
89542: LD_INT 1
89544: NEG
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 1
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 1
89562: PUSH
89563: LD_INT 1
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 0
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 1
89582: NEG
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: NEG
89594: PUSH
89595: LD_INT 1
89597: NEG
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: PUSH
89606: LD_INT 1
89608: NEG
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 2
89616: PUSH
89617: LD_INT 0
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: PUSH
89627: LD_INT 1
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 2
89636: PUSH
89637: LD_INT 2
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: PUSH
89644: LD_INT 1
89646: PUSH
89647: LD_INT 2
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89668: LD_ADDR_VAR 0 50
89672: PUSH
89673: LD_INT 0
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 0
89685: PUSH
89686: LD_INT 1
89688: NEG
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 1
89696: PUSH
89697: LD_INT 0
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: PUSH
89704: LD_INT 1
89706: PUSH
89707: LD_INT 1
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: PUSH
89714: LD_INT 0
89716: PUSH
89717: LD_INT 1
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 1
89737: NEG
89738: PUSH
89739: LD_INT 1
89741: NEG
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 2
89749: PUSH
89750: LD_INT 1
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PUSH
89757: LD_INT 2
89759: PUSH
89760: LD_INT 2
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: LD_INT 2
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 0
89779: PUSH
89780: LD_INT 2
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 1
89789: NEG
89790: PUSH
89791: LD_INT 1
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89812: LD_ADDR_VAR 0 51
89816: PUSH
89817: LD_INT 0
89819: PUSH
89820: LD_INT 0
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 0
89829: PUSH
89830: LD_INT 1
89832: NEG
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: PUSH
89848: LD_INT 1
89850: PUSH
89851: LD_INT 1
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 0
89860: PUSH
89861: LD_INT 1
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: LD_INT 0
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 1
89881: NEG
89882: PUSH
89883: LD_INT 1
89885: NEG
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 1
89893: PUSH
89894: LD_INT 2
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 0
89903: PUSH
89904: LD_INT 2
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 1
89913: NEG
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 2
89924: NEG
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 2
89935: NEG
89936: PUSH
89937: LD_INT 1
89939: NEG
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89959: LD_ADDR_VAR 0 52
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: LD_INT 0
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 1
89979: NEG
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 1
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: LD_INT 1
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 0
90007: PUSH
90008: LD_INT 1
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 1
90028: NEG
90029: PUSH
90030: LD_INT 1
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: NEG
90041: PUSH
90042: LD_INT 2
90044: NEG
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: PUSH
90050: LD_INT 1
90052: NEG
90053: PUSH
90054: LD_INT 1
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 2
90063: NEG
90064: PUSH
90065: LD_INT 0
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 2
90074: NEG
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 2
90086: NEG
90087: PUSH
90088: LD_INT 2
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90110: LD_ADDR_VAR 0 53
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: LD_INT 0
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: LD_INT 1
90130: NEG
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: LD_INT 1
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: LD_INT 1
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 1
90168: NEG
90169: PUSH
90170: LD_INT 0
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 1
90179: NEG
90180: PUSH
90181: LD_INT 1
90183: NEG
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 1
90191: NEG
90192: PUSH
90193: LD_INT 2
90195: NEG
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: LD_INT 2
90206: NEG
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 1
90214: PUSH
90215: LD_INT 1
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 2
90235: PUSH
90236: LD_INT 1
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 2
90245: PUSH
90246: LD_INT 2
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 1
90255: PUSH
90256: LD_INT 2
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 0
90265: PUSH
90266: LD_INT 2
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: LD_INT 1
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 2
90286: NEG
90287: PUSH
90288: LD_INT 0
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 2
90297: NEG
90298: PUSH
90299: LD_INT 1
90301: NEG
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 2
90309: NEG
90310: PUSH
90311: LD_INT 2
90313: NEG
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90340: LD_ADDR_VAR 0 54
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: LD_INT 1
90360: NEG
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 1
90378: PUSH
90379: LD_INT 1
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 1
90398: NEG
90399: PUSH
90400: LD_INT 0
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: LD_INT 1
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: NEG
90422: PUSH
90423: LD_INT 2
90425: NEG
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 2
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 2
90475: PUSH
90476: LD_INT 2
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 2
90516: NEG
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 2
90527: NEG
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 2
90539: NEG
90540: PUSH
90541: LD_INT 2
90543: NEG
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90570: LD_ADDR_VAR 0 55
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 1
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 1
90628: NEG
90629: PUSH
90630: LD_INT 0
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 1
90639: NEG
90640: PUSH
90641: LD_INT 1
90643: NEG
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: LD_INT 2
90655: NEG
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: LD_INT 2
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 2
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 2
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 2
90705: PUSH
90706: LD_INT 2
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: LD_INT 2
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: LD_INT 2
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 2
90746: NEG
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 2
90757: NEG
90758: PUSH
90759: LD_INT 1
90761: NEG
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90800: LD_ADDR_VAR 0 56
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: PUSH
90839: LD_INT 1
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: PUSH
90846: LD_INT 0
90848: PUSH
90849: LD_INT 1
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 1
90858: NEG
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 1
90869: NEG
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: NEG
90882: PUSH
90883: LD_INT 2
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 0
90893: PUSH
90894: LD_INT 2
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 1
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 2
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 2
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 2
90935: PUSH
90936: LD_INT 2
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 1
90945: PUSH
90946: LD_INT 2
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: LD_INT 2
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 1
90965: NEG
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 2
90976: NEG
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 2
90987: NEG
90988: PUSH
90989: LD_INT 1
90991: NEG
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 2
90999: NEG
91000: PUSH
91001: LD_INT 2
91003: NEG
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91030: LD_ADDR_VAR 0 57
91034: PUSH
91035: LD_INT 0
91037: PUSH
91038: LD_INT 0
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 0
91047: PUSH
91048: LD_INT 1
91050: NEG
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 1
91068: PUSH
91069: LD_INT 1
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 0
91078: PUSH
91079: LD_INT 1
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: LD_INT 1
91103: NEG
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: LD_INT 2
91115: NEG
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 2
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: LD_INT 1
91137: NEG
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 2
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 2
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 2
91165: PUSH
91166: LD_INT 2
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 1
91175: PUSH
91176: LD_INT 2
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 2
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 1
91195: NEG
91196: PUSH
91197: LD_INT 1
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 2
91206: NEG
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 2
91217: NEG
91218: PUSH
91219: LD_INT 1
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 2
91229: NEG
91230: PUSH
91231: LD_INT 2
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91260: LD_ADDR_VAR 0 58
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: LD_INT 0
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 0
91277: PUSH
91278: LD_INT 1
91280: NEG
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 1
91288: PUSH
91289: LD_INT 0
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 1
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 0
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 1
91318: NEG
91319: PUSH
91320: LD_INT 0
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 1
91329: NEG
91330: PUSH
91331: LD_INT 1
91333: NEG
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 1
91341: NEG
91342: PUSH
91343: LD_INT 2
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 0
91353: PUSH
91354: LD_INT 2
91356: NEG
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 1
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: LD_INT 2
91375: PUSH
91376: LD_INT 0
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 2
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 2
91395: PUSH
91396: LD_INT 2
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: LD_INT 2
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: LD_INT 2
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 1
91425: NEG
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 2
91436: NEG
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 2
91447: NEG
91448: PUSH
91449: LD_INT 1
91451: NEG
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 2
91459: NEG
91460: PUSH
91461: LD_INT 2
91463: NEG
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91490: LD_ADDR_VAR 0 59
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: LD_INT 1
91510: NEG
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: LD_INT 0
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 1
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: LD_INT 1
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 1
91559: NEG
91560: PUSH
91561: LD_INT 1
91563: NEG
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91578: LD_ADDR_VAR 0 60
91582: PUSH
91583: LD_INT 0
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: LD_INT 1
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 0
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 1
91616: PUSH
91617: LD_INT 1
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 0
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 1
91636: NEG
91637: PUSH
91638: LD_INT 0
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: NEG
91648: PUSH
91649: LD_INT 1
91651: NEG
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91666: LD_ADDR_VAR 0 61
91670: PUSH
91671: LD_INT 0
91673: PUSH
91674: LD_INT 0
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 0
91683: PUSH
91684: LD_INT 1
91686: NEG
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 1
91694: PUSH
91695: LD_INT 0
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 1
91704: PUSH
91705: LD_INT 1
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 0
91714: PUSH
91715: LD_INT 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 1
91724: NEG
91725: PUSH
91726: LD_INT 0
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 1
91735: NEG
91736: PUSH
91737: LD_INT 1
91739: NEG
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91754: LD_ADDR_VAR 0 62
91758: PUSH
91759: LD_INT 0
91761: PUSH
91762: LD_INT 0
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 0
91771: PUSH
91772: LD_INT 1
91774: NEG
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: PUSH
91780: LD_INT 1
91782: PUSH
91783: LD_INT 0
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: LD_INT 1
91792: PUSH
91793: LD_INT 1
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 0
91802: PUSH
91803: LD_INT 1
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 1
91812: NEG
91813: PUSH
91814: LD_INT 0
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: PUSH
91821: LD_INT 1
91823: NEG
91824: PUSH
91825: LD_INT 1
91827: NEG
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91842: LD_ADDR_VAR 0 63
91846: PUSH
91847: LD_INT 0
91849: PUSH
91850: LD_INT 0
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 0
91859: PUSH
91860: LD_INT 1
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 1
91870: PUSH
91871: LD_INT 0
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 1
91880: PUSH
91881: LD_INT 1
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 0
91890: PUSH
91891: LD_INT 1
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 1
91900: NEG
91901: PUSH
91902: LD_INT 0
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 1
91911: NEG
91912: PUSH
91913: LD_INT 1
91915: NEG
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91930: LD_ADDR_VAR 0 64
91934: PUSH
91935: LD_INT 0
91937: PUSH
91938: LD_INT 0
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 0
91947: PUSH
91948: LD_INT 1
91950: NEG
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 1
91958: PUSH
91959: LD_INT 0
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: LD_INT 1
91968: PUSH
91969: LD_INT 1
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 0
91978: PUSH
91979: LD_INT 1
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: LD_INT 1
91988: NEG
91989: PUSH
91990: LD_INT 0
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: PUSH
91997: LD_INT 1
91999: NEG
92000: PUSH
92001: LD_INT 1
92003: NEG
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: ST_TO_ADDR
// end ; 1 :
92018: GO 97915
92020: LD_INT 1
92022: DOUBLE
92023: EQUAL
92024: IFTRUE 92028
92026: GO 94651
92028: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92029: LD_ADDR_VAR 0 11
92033: PUSH
92034: LD_INT 1
92036: NEG
92037: PUSH
92038: LD_INT 3
92040: NEG
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 0
92048: PUSH
92049: LD_INT 3
92051: NEG
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 1
92059: PUSH
92060: LD_INT 2
92062: NEG
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: LIST
92072: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92073: LD_ADDR_VAR 0 12
92077: PUSH
92078: LD_INT 2
92080: PUSH
92081: LD_INT 1
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 3
92091: PUSH
92092: LD_INT 0
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_INT 3
92101: PUSH
92102: LD_INT 1
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: LIST
92113: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92114: LD_ADDR_VAR 0 13
92118: PUSH
92119: LD_INT 3
92121: PUSH
92122: LD_INT 2
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 3
92131: PUSH
92132: LD_INT 3
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 2
92141: PUSH
92142: LD_INT 3
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: LIST
92153: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92154: LD_ADDR_VAR 0 14
92158: PUSH
92159: LD_INT 1
92161: PUSH
92162: LD_INT 3
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 0
92171: PUSH
92172: LD_INT 3
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: PUSH
92179: LD_INT 1
92181: NEG
92182: PUSH
92183: LD_INT 2
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: LIST
92194: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92195: LD_ADDR_VAR 0 15
92199: PUSH
92200: LD_INT 2
92202: NEG
92203: PUSH
92204: LD_INT 1
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 3
92213: NEG
92214: PUSH
92215: LD_INT 0
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 3
92224: NEG
92225: PUSH
92226: LD_INT 1
92228: NEG
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: LIST
92238: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92239: LD_ADDR_VAR 0 16
92243: PUSH
92244: LD_INT 2
92246: NEG
92247: PUSH
92248: LD_INT 3
92250: NEG
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 3
92258: NEG
92259: PUSH
92260: LD_INT 2
92262: NEG
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 3
92270: NEG
92271: PUSH
92272: LD_INT 3
92274: NEG
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: LIST
92284: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92285: LD_ADDR_VAR 0 17
92289: PUSH
92290: LD_INT 1
92292: NEG
92293: PUSH
92294: LD_INT 3
92296: NEG
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 0
92304: PUSH
92305: LD_INT 3
92307: NEG
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PUSH
92313: LD_INT 1
92315: PUSH
92316: LD_INT 2
92318: NEG
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92329: LD_ADDR_VAR 0 18
92333: PUSH
92334: LD_INT 2
92336: PUSH
92337: LD_INT 1
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 3
92347: PUSH
92348: LD_INT 0
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 3
92357: PUSH
92358: LD_INT 1
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: LIST
92369: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92370: LD_ADDR_VAR 0 19
92374: PUSH
92375: LD_INT 3
92377: PUSH
92378: LD_INT 2
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 3
92387: PUSH
92388: LD_INT 3
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 2
92397: PUSH
92398: LD_INT 3
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: LIST
92409: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92410: LD_ADDR_VAR 0 20
92414: PUSH
92415: LD_INT 1
92417: PUSH
92418: LD_INT 3
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: LD_INT 3
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 1
92437: NEG
92438: PUSH
92439: LD_INT 2
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: LIST
92450: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92451: LD_ADDR_VAR 0 21
92455: PUSH
92456: LD_INT 2
92458: NEG
92459: PUSH
92460: LD_INT 1
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 3
92469: NEG
92470: PUSH
92471: LD_INT 0
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 3
92480: NEG
92481: PUSH
92482: LD_INT 1
92484: NEG
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: LIST
92494: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92495: LD_ADDR_VAR 0 22
92499: PUSH
92500: LD_INT 2
92502: NEG
92503: PUSH
92504: LD_INT 3
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 3
92514: NEG
92515: PUSH
92516: LD_INT 2
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 3
92526: NEG
92527: PUSH
92528: LD_INT 3
92530: NEG
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: LIST
92540: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92541: LD_ADDR_VAR 0 23
92545: PUSH
92546: LD_INT 0
92548: PUSH
92549: LD_INT 3
92551: NEG
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 1
92559: NEG
92560: PUSH
92561: LD_INT 4
92563: NEG
92564: PUSH
92565: EMPTY
92566: LIST
92567: LIST
92568: PUSH
92569: LD_INT 1
92571: PUSH
92572: LD_INT 3
92574: NEG
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: LIST
92584: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92585: LD_ADDR_VAR 0 24
92589: PUSH
92590: LD_INT 3
92592: PUSH
92593: LD_INT 0
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 3
92602: PUSH
92603: LD_INT 1
92605: NEG
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 4
92613: PUSH
92614: LD_INT 1
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92626: LD_ADDR_VAR 0 25
92630: PUSH
92631: LD_INT 3
92633: PUSH
92634: LD_INT 3
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 4
92643: PUSH
92644: LD_INT 3
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 3
92653: PUSH
92654: LD_INT 4
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: LIST
92665: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92666: LD_ADDR_VAR 0 26
92670: PUSH
92671: LD_INT 0
92673: PUSH
92674: LD_INT 3
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 1
92683: PUSH
92684: LD_INT 4
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: LD_INT 3
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: LIST
92706: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92707: LD_ADDR_VAR 0 27
92711: PUSH
92712: LD_INT 3
92714: NEG
92715: PUSH
92716: LD_INT 0
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: PUSH
92723: LD_INT 3
92725: NEG
92726: PUSH
92727: LD_INT 1
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: LD_INT 4
92736: NEG
92737: PUSH
92738: LD_INT 1
92740: NEG
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: LIST
92750: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92751: LD_ADDR_VAR 0 28
92755: PUSH
92756: LD_INT 3
92758: NEG
92759: PUSH
92760: LD_INT 3
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 3
92770: NEG
92771: PUSH
92772: LD_INT 4
92774: NEG
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 4
92782: NEG
92783: PUSH
92784: LD_INT 3
92786: NEG
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: LIST
92796: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92797: LD_ADDR_VAR 0 29
92801: PUSH
92802: LD_INT 1
92804: NEG
92805: PUSH
92806: LD_INT 3
92808: NEG
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 0
92816: PUSH
92817: LD_INT 3
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 1
92827: PUSH
92828: LD_INT 2
92830: NEG
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: LD_INT 4
92842: NEG
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 0
92850: PUSH
92851: LD_INT 4
92853: NEG
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 1
92861: PUSH
92862: LD_INT 3
92864: NEG
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 1
92872: NEG
92873: PUSH
92874: LD_INT 5
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 0
92884: PUSH
92885: LD_INT 5
92887: NEG
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 1
92895: PUSH
92896: LD_INT 4
92898: NEG
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 1
92906: NEG
92907: PUSH
92908: LD_INT 6
92910: NEG
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 0
92918: PUSH
92919: LD_INT 6
92921: NEG
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 1
92929: PUSH
92930: LD_INT 5
92932: NEG
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92952: LD_ADDR_VAR 0 30
92956: PUSH
92957: LD_INT 2
92959: PUSH
92960: LD_INT 1
92962: NEG
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 3
92970: PUSH
92971: LD_INT 0
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 3
92980: PUSH
92981: LD_INT 1
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 3
92990: PUSH
92991: LD_INT 1
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 4
93001: PUSH
93002: LD_INT 0
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PUSH
93009: LD_INT 4
93011: PUSH
93012: LD_INT 1
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 4
93021: PUSH
93022: LD_INT 1
93024: NEG
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 5
93032: PUSH
93033: LD_INT 0
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 5
93042: PUSH
93043: LD_INT 1
93045: PUSH
93046: EMPTY
93047: LIST
93048: LIST
93049: PUSH
93050: LD_INT 5
93052: PUSH
93053: LD_INT 1
93055: NEG
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 6
93063: PUSH
93064: LD_INT 0
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 6
93073: PUSH
93074: LD_INT 1
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93095: LD_ADDR_VAR 0 31
93099: PUSH
93100: LD_INT 3
93102: PUSH
93103: LD_INT 2
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 3
93112: PUSH
93113: LD_INT 3
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PUSH
93120: LD_INT 2
93122: PUSH
93123: LD_INT 3
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 4
93132: PUSH
93133: LD_INT 3
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 4
93142: PUSH
93143: LD_INT 4
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 3
93152: PUSH
93153: LD_INT 4
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 5
93162: PUSH
93163: LD_INT 4
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PUSH
93170: LD_INT 5
93172: PUSH
93173: LD_INT 5
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 4
93182: PUSH
93183: LD_INT 5
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 6
93192: PUSH
93193: LD_INT 5
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 6
93202: PUSH
93203: LD_INT 6
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: LD_INT 5
93212: PUSH
93213: LD_INT 6
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93234: LD_ADDR_VAR 0 32
93238: PUSH
93239: LD_INT 1
93241: PUSH
93242: LD_INT 3
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: LD_INT 3
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 1
93261: NEG
93262: PUSH
93263: LD_INT 2
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 1
93272: PUSH
93273: LD_INT 4
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 0
93282: PUSH
93283: LD_INT 4
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 1
93292: NEG
93293: PUSH
93294: LD_INT 3
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 1
93303: PUSH
93304: LD_INT 5
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 0
93313: PUSH
93314: LD_INT 5
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 1
93323: NEG
93324: PUSH
93325: LD_INT 4
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 1
93334: PUSH
93335: LD_INT 6
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 0
93344: PUSH
93345: LD_INT 6
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 1
93354: NEG
93355: PUSH
93356: LD_INT 5
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93377: LD_ADDR_VAR 0 33
93381: PUSH
93382: LD_INT 2
93384: NEG
93385: PUSH
93386: LD_INT 1
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 3
93395: NEG
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 3
93406: NEG
93407: PUSH
93408: LD_INT 1
93410: NEG
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: LD_INT 3
93418: NEG
93419: PUSH
93420: LD_INT 1
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: LD_INT 4
93429: NEG
93430: PUSH
93431: LD_INT 0
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 4
93440: NEG
93441: PUSH
93442: LD_INT 1
93444: NEG
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 4
93452: NEG
93453: PUSH
93454: LD_INT 1
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 5
93463: NEG
93464: PUSH
93465: LD_INT 0
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 5
93474: NEG
93475: PUSH
93476: LD_INT 1
93478: NEG
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 5
93486: NEG
93487: PUSH
93488: LD_INT 1
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 6
93497: NEG
93498: PUSH
93499: LD_INT 0
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PUSH
93506: LD_INT 6
93508: NEG
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93532: LD_ADDR_VAR 0 34
93536: PUSH
93537: LD_INT 2
93539: NEG
93540: PUSH
93541: LD_INT 3
93543: NEG
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: PUSH
93549: LD_INT 3
93551: NEG
93552: PUSH
93553: LD_INT 2
93555: NEG
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 3
93563: NEG
93564: PUSH
93565: LD_INT 3
93567: NEG
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: LD_INT 3
93575: NEG
93576: PUSH
93577: LD_INT 4
93579: NEG
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 4
93587: NEG
93588: PUSH
93589: LD_INT 3
93591: NEG
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 4
93599: NEG
93600: PUSH
93601: LD_INT 4
93603: NEG
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 4
93611: NEG
93612: PUSH
93613: LD_INT 5
93615: NEG
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 5
93623: NEG
93624: PUSH
93625: LD_INT 4
93627: NEG
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 5
93635: NEG
93636: PUSH
93637: LD_INT 5
93639: NEG
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 5
93647: NEG
93648: PUSH
93649: LD_INT 6
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 6
93659: NEG
93660: PUSH
93661: LD_INT 5
93663: NEG
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 6
93671: NEG
93672: PUSH
93673: LD_INT 6
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93695: LD_ADDR_VAR 0 41
93699: PUSH
93700: LD_INT 0
93702: PUSH
93703: LD_INT 2
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 1
93713: NEG
93714: PUSH
93715: LD_INT 3
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: LD_INT 2
93728: NEG
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: LIST
93738: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93739: LD_ADDR_VAR 0 42
93743: PUSH
93744: LD_INT 2
93746: PUSH
93747: LD_INT 0
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 2
93756: PUSH
93757: LD_INT 1
93759: NEG
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: LD_INT 3
93767: PUSH
93768: LD_INT 1
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: LIST
93779: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93780: LD_ADDR_VAR 0 43
93784: PUSH
93785: LD_INT 2
93787: PUSH
93788: LD_INT 2
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 3
93797: PUSH
93798: LD_INT 2
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: LD_INT 3
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: LIST
93819: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93820: LD_ADDR_VAR 0 44
93824: PUSH
93825: LD_INT 0
93827: PUSH
93828: LD_INT 2
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 1
93837: PUSH
93838: LD_INT 3
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 1
93847: NEG
93848: PUSH
93849: LD_INT 2
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: LIST
93860: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93861: LD_ADDR_VAR 0 45
93865: PUSH
93866: LD_INT 2
93868: NEG
93869: PUSH
93870: LD_INT 0
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 2
93879: NEG
93880: PUSH
93881: LD_INT 1
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 3
93890: NEG
93891: PUSH
93892: LD_INT 1
93894: NEG
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: LIST
93904: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93905: LD_ADDR_VAR 0 46
93909: PUSH
93910: LD_INT 2
93912: NEG
93913: PUSH
93914: LD_INT 2
93916: NEG
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 2
93924: NEG
93925: PUSH
93926: LD_INT 3
93928: NEG
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: PUSH
93934: LD_INT 3
93936: NEG
93937: PUSH
93938: LD_INT 2
93940: NEG
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: LIST
93950: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93951: LD_ADDR_VAR 0 47
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: LD_INT 3
93962: NEG
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 1
93970: NEG
93971: PUSH
93972: LD_INT 3
93974: NEG
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93984: LD_ADDR_VAR 0 48
93988: PUSH
93989: LD_INT 1
93991: PUSH
93992: LD_INT 2
93994: NEG
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 2
94002: PUSH
94003: LD_INT 1
94005: NEG
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94015: LD_ADDR_VAR 0 49
94019: PUSH
94020: LD_INT 3
94022: PUSH
94023: LD_INT 1
94025: PUSH
94026: EMPTY
94027: LIST
94028: LIST
94029: PUSH
94030: LD_INT 3
94032: PUSH
94033: LD_INT 2
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94044: LD_ADDR_VAR 0 50
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: LD_INT 3
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: LD_INT 3
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94073: LD_ADDR_VAR 0 51
94077: PUSH
94078: LD_INT 1
94080: NEG
94081: PUSH
94082: LD_INT 2
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 2
94091: NEG
94092: PUSH
94093: LD_INT 1
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94104: LD_ADDR_VAR 0 52
94108: PUSH
94109: LD_INT 3
94111: NEG
94112: PUSH
94113: LD_INT 1
94115: NEG
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 3
94123: NEG
94124: PUSH
94125: LD_INT 2
94127: NEG
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94137: LD_ADDR_VAR 0 53
94141: PUSH
94142: LD_INT 1
94144: NEG
94145: PUSH
94146: LD_INT 3
94148: NEG
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 0
94156: PUSH
94157: LD_INT 3
94159: NEG
94160: PUSH
94161: EMPTY
94162: LIST
94163: LIST
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: LD_INT 2
94170: NEG
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: LIST
94180: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94181: LD_ADDR_VAR 0 54
94185: PUSH
94186: LD_INT 2
94188: PUSH
94189: LD_INT 1
94191: NEG
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 3
94199: PUSH
94200: LD_INT 0
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PUSH
94207: LD_INT 3
94209: PUSH
94210: LD_INT 1
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: LIST
94221: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94222: LD_ADDR_VAR 0 55
94226: PUSH
94227: LD_INT 3
94229: PUSH
94230: LD_INT 2
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PUSH
94237: LD_INT 3
94239: PUSH
94240: LD_INT 3
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: PUSH
94247: LD_INT 2
94249: PUSH
94250: LD_INT 3
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: LIST
94261: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94262: LD_ADDR_VAR 0 56
94266: PUSH
94267: LD_INT 1
94269: PUSH
94270: LD_INT 3
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 0
94279: PUSH
94280: LD_INT 3
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 1
94289: NEG
94290: PUSH
94291: LD_INT 2
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: LIST
94302: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94303: LD_ADDR_VAR 0 57
94307: PUSH
94308: LD_INT 2
94310: NEG
94311: PUSH
94312: LD_INT 1
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 3
94321: NEG
94322: PUSH
94323: LD_INT 0
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 3
94332: NEG
94333: PUSH
94334: LD_INT 1
94336: NEG
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: LIST
94346: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94347: LD_ADDR_VAR 0 58
94351: PUSH
94352: LD_INT 2
94354: NEG
94355: PUSH
94356: LD_INT 3
94358: NEG
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 3
94366: NEG
94367: PUSH
94368: LD_INT 2
94370: NEG
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 3
94378: NEG
94379: PUSH
94380: LD_INT 3
94382: NEG
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: LIST
94392: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94393: LD_ADDR_VAR 0 59
94397: PUSH
94398: LD_INT 1
94400: NEG
94401: PUSH
94402: LD_INT 2
94404: NEG
94405: PUSH
94406: EMPTY
94407: LIST
94408: LIST
94409: PUSH
94410: LD_INT 0
94412: PUSH
94413: LD_INT 2
94415: NEG
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 1
94423: PUSH
94424: LD_INT 1
94426: NEG
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: LIST
94436: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94437: LD_ADDR_VAR 0 60
94441: PUSH
94442: LD_INT 1
94444: PUSH
94445: LD_INT 1
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 2
94455: PUSH
94456: LD_INT 0
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 2
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: LIST
94477: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94478: LD_ADDR_VAR 0 61
94482: PUSH
94483: LD_INT 2
94485: PUSH
94486: LD_INT 1
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 2
94495: PUSH
94496: LD_INT 2
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 1
94505: PUSH
94506: LD_INT 2
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: LIST
94517: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94518: LD_ADDR_VAR 0 62
94522: PUSH
94523: LD_INT 1
94525: PUSH
94526: LD_INT 2
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: LD_INT 2
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 1
94545: NEG
94546: PUSH
94547: LD_INT 1
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: LIST
94558: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94559: LD_ADDR_VAR 0 63
94563: PUSH
94564: LD_INT 1
94566: NEG
94567: PUSH
94568: LD_INT 1
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: LD_INT 2
94577: NEG
94578: PUSH
94579: LD_INT 0
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 2
94588: NEG
94589: PUSH
94590: LD_INT 1
94592: NEG
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: LIST
94602: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94603: LD_ADDR_VAR 0 64
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: LD_INT 2
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: LD_INT 1
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 2
94634: NEG
94635: PUSH
94636: LD_INT 2
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: LIST
94648: ST_TO_ADDR
// end ; 2 :
94649: GO 97915
94651: LD_INT 2
94653: DOUBLE
94654: EQUAL
94655: IFTRUE 94659
94657: GO 97914
94659: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94660: LD_ADDR_VAR 0 29
94664: PUSH
94665: LD_INT 4
94667: PUSH
94668: LD_INT 0
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 4
94677: PUSH
94678: LD_INT 1
94680: NEG
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: PUSH
94686: LD_INT 5
94688: PUSH
94689: LD_INT 0
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 5
94698: PUSH
94699: LD_INT 1
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: PUSH
94706: LD_INT 4
94708: PUSH
94709: LD_INT 1
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 3
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 3
94728: PUSH
94729: LD_INT 1
94731: NEG
94732: PUSH
94733: EMPTY
94734: LIST
94735: LIST
94736: PUSH
94737: LD_INT 3
94739: PUSH
94740: LD_INT 2
94742: NEG
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 5
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 3
94760: PUSH
94761: LD_INT 3
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 3
94770: PUSH
94771: LD_INT 2
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: LD_INT 3
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 4
94790: PUSH
94791: LD_INT 4
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 3
94800: PUSH
94801: LD_INT 4
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 2
94810: PUSH
94811: LD_INT 3
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 2
94820: PUSH
94821: LD_INT 2
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 4
94830: PUSH
94831: LD_INT 2
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 2
94840: PUSH
94841: LD_INT 4
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 0
94850: PUSH
94851: LD_INT 4
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 0
94860: PUSH
94861: LD_INT 3
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: PUSH
94868: LD_INT 1
94870: PUSH
94871: LD_INT 4
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 1
94880: PUSH
94881: LD_INT 5
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: LD_INT 5
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 1
94900: NEG
94901: PUSH
94902: LD_INT 4
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 1
94911: NEG
94912: PUSH
94913: LD_INT 3
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: LD_INT 2
94922: PUSH
94923: LD_INT 5
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 2
94932: NEG
94933: PUSH
94934: LD_INT 3
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 3
94943: NEG
94944: PUSH
94945: LD_INT 0
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 3
94954: NEG
94955: PUSH
94956: LD_INT 1
94958: NEG
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PUSH
94964: LD_INT 2
94966: NEG
94967: PUSH
94968: LD_INT 0
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 2
94977: NEG
94978: PUSH
94979: LD_INT 1
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 3
94988: NEG
94989: PUSH
94990: LD_INT 1
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 4
94999: NEG
95000: PUSH
95001: LD_INT 0
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 4
95010: NEG
95011: PUSH
95012: LD_INT 1
95014: NEG
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 4
95022: NEG
95023: PUSH
95024: LD_INT 2
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 2
95034: NEG
95035: PUSH
95036: LD_INT 2
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 4
95045: NEG
95046: PUSH
95047: LD_INT 4
95049: NEG
95050: PUSH
95051: EMPTY
95052: LIST
95053: LIST
95054: PUSH
95055: LD_INT 4
95057: NEG
95058: PUSH
95059: LD_INT 5
95061: NEG
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: PUSH
95067: LD_INT 3
95069: NEG
95070: PUSH
95071: LD_INT 4
95073: NEG
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 3
95081: NEG
95082: PUSH
95083: LD_INT 3
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 4
95093: NEG
95094: PUSH
95095: LD_INT 3
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 5
95105: NEG
95106: PUSH
95107: LD_INT 4
95109: NEG
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 5
95117: NEG
95118: PUSH
95119: LD_INT 5
95121: NEG
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 3
95129: NEG
95130: PUSH
95131: LD_INT 5
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 5
95141: NEG
95142: PUSH
95143: LD_INT 3
95145: NEG
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95198: LD_ADDR_VAR 0 30
95202: PUSH
95203: LD_INT 4
95205: PUSH
95206: LD_INT 4
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 4
95215: PUSH
95216: LD_INT 3
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: LD_INT 5
95225: PUSH
95226: LD_INT 4
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 5
95235: PUSH
95236: LD_INT 5
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 4
95245: PUSH
95246: LD_INT 5
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: LD_INT 3
95255: PUSH
95256: LD_INT 4
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 3
95265: PUSH
95266: LD_INT 3
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 5
95275: PUSH
95276: LD_INT 3
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 3
95285: PUSH
95286: LD_INT 5
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 0
95295: PUSH
95296: LD_INT 3
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 0
95305: PUSH
95306: LD_INT 2
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 1
95315: PUSH
95316: LD_INT 3
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 1
95325: PUSH
95326: LD_INT 4
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: PUSH
95333: LD_INT 0
95335: PUSH
95336: LD_INT 4
95338: PUSH
95339: EMPTY
95340: LIST
95341: LIST
95342: PUSH
95343: LD_INT 1
95345: NEG
95346: PUSH
95347: LD_INT 3
95349: PUSH
95350: EMPTY
95351: LIST
95352: LIST
95353: PUSH
95354: LD_INT 1
95356: NEG
95357: PUSH
95358: LD_INT 2
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 2
95367: PUSH
95368: LD_INT 4
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 2
95377: NEG
95378: PUSH
95379: LD_INT 2
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 4
95388: NEG
95389: PUSH
95390: LD_INT 0
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 4
95399: NEG
95400: PUSH
95401: LD_INT 1
95403: NEG
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 3
95411: NEG
95412: PUSH
95413: LD_INT 0
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 3
95422: NEG
95423: PUSH
95424: LD_INT 1
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 4
95433: NEG
95434: PUSH
95435: LD_INT 1
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 5
95444: NEG
95445: PUSH
95446: LD_INT 0
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: LD_INT 5
95455: NEG
95456: PUSH
95457: LD_INT 1
95459: NEG
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 5
95467: NEG
95468: PUSH
95469: LD_INT 2
95471: NEG
95472: PUSH
95473: EMPTY
95474: LIST
95475: LIST
95476: PUSH
95477: LD_INT 3
95479: NEG
95480: PUSH
95481: LD_INT 2
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PUSH
95488: LD_INT 3
95490: NEG
95491: PUSH
95492: LD_INT 3
95494: NEG
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: LD_INT 3
95502: NEG
95503: PUSH
95504: LD_INT 4
95506: NEG
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PUSH
95512: LD_INT 2
95514: NEG
95515: PUSH
95516: LD_INT 3
95518: NEG
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 2
95526: NEG
95527: PUSH
95528: LD_INT 2
95530: NEG
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: PUSH
95536: LD_INT 3
95538: NEG
95539: PUSH
95540: LD_INT 2
95542: NEG
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 4
95550: NEG
95551: PUSH
95552: LD_INT 3
95554: NEG
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 4
95562: NEG
95563: PUSH
95564: LD_INT 4
95566: NEG
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 2
95574: NEG
95575: PUSH
95576: LD_INT 4
95578: NEG
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 4
95586: NEG
95587: PUSH
95588: LD_INT 2
95590: NEG
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 0
95598: PUSH
95599: LD_INT 4
95601: NEG
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 0
95609: PUSH
95610: LD_INT 5
95612: NEG
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: PUSH
95618: LD_INT 1
95620: PUSH
95621: LD_INT 4
95623: NEG
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 1
95631: PUSH
95632: LD_INT 3
95634: NEG
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 0
95642: PUSH
95643: LD_INT 3
95645: NEG
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 1
95653: NEG
95654: PUSH
95655: LD_INT 4
95657: NEG
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 1
95665: NEG
95666: PUSH
95667: LD_INT 5
95669: NEG
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 2
95677: PUSH
95678: LD_INT 3
95680: NEG
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 2
95688: NEG
95689: PUSH
95690: LD_INT 5
95692: NEG
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95745: LD_ADDR_VAR 0 31
95749: PUSH
95750: LD_INT 0
95752: PUSH
95753: LD_INT 4
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: PUSH
95760: LD_INT 0
95762: PUSH
95763: LD_INT 3
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 1
95772: PUSH
95773: LD_INT 4
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 1
95782: PUSH
95783: LD_INT 5
95785: PUSH
95786: EMPTY
95787: LIST
95788: LIST
95789: PUSH
95790: LD_INT 0
95792: PUSH
95793: LD_INT 5
95795: PUSH
95796: EMPTY
95797: LIST
95798: LIST
95799: PUSH
95800: LD_INT 1
95802: NEG
95803: PUSH
95804: LD_INT 4
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 1
95813: NEG
95814: PUSH
95815: LD_INT 3
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 2
95824: PUSH
95825: LD_INT 5
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PUSH
95832: LD_INT 2
95834: NEG
95835: PUSH
95836: LD_INT 3
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 3
95845: NEG
95846: PUSH
95847: LD_INT 0
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 3
95856: NEG
95857: PUSH
95858: LD_INT 1
95860: NEG
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: PUSH
95866: LD_INT 2
95868: NEG
95869: PUSH
95870: LD_INT 0
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 2
95879: NEG
95880: PUSH
95881: LD_INT 1
95883: PUSH
95884: EMPTY
95885: LIST
95886: LIST
95887: PUSH
95888: LD_INT 3
95890: NEG
95891: PUSH
95892: LD_INT 1
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 4
95901: NEG
95902: PUSH
95903: LD_INT 0
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: LD_INT 4
95912: NEG
95913: PUSH
95914: LD_INT 1
95916: NEG
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 4
95924: NEG
95925: PUSH
95926: LD_INT 2
95928: NEG
95929: PUSH
95930: EMPTY
95931: LIST
95932: LIST
95933: PUSH
95934: LD_INT 2
95936: NEG
95937: PUSH
95938: LD_INT 2
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: PUSH
95945: LD_INT 4
95947: NEG
95948: PUSH
95949: LD_INT 4
95951: NEG
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: PUSH
95957: LD_INT 4
95959: NEG
95960: PUSH
95961: LD_INT 5
95963: NEG
95964: PUSH
95965: EMPTY
95966: LIST
95967: LIST
95968: PUSH
95969: LD_INT 3
95971: NEG
95972: PUSH
95973: LD_INT 4
95975: NEG
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 3
95983: NEG
95984: PUSH
95985: LD_INT 3
95987: NEG
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 4
95995: NEG
95996: PUSH
95997: LD_INT 3
95999: NEG
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 5
96007: NEG
96008: PUSH
96009: LD_INT 4
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 5
96019: NEG
96020: PUSH
96021: LD_INT 5
96023: NEG
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 3
96031: NEG
96032: PUSH
96033: LD_INT 5
96035: NEG
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 5
96043: NEG
96044: PUSH
96045: LD_INT 3
96047: NEG
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 0
96055: PUSH
96056: LD_INT 3
96058: NEG
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 0
96066: PUSH
96067: LD_INT 4
96069: NEG
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 1
96077: PUSH
96078: LD_INT 3
96080: NEG
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 1
96088: PUSH
96089: LD_INT 2
96091: NEG
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 0
96099: PUSH
96100: LD_INT 2
96102: NEG
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 1
96110: NEG
96111: PUSH
96112: LD_INT 3
96114: NEG
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 1
96122: NEG
96123: PUSH
96124: LD_INT 4
96126: NEG
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: PUSH
96132: LD_INT 2
96134: PUSH
96135: LD_INT 2
96137: NEG
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: LD_INT 2
96145: NEG
96146: PUSH
96147: LD_INT 4
96149: NEG
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 4
96157: PUSH
96158: LD_INT 0
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 4
96167: PUSH
96168: LD_INT 1
96170: NEG
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 5
96178: PUSH
96179: LD_INT 0
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 5
96188: PUSH
96189: LD_INT 1
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 4
96198: PUSH
96199: LD_INT 1
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 3
96208: PUSH
96209: LD_INT 0
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 3
96218: PUSH
96219: LD_INT 1
96221: NEG
96222: PUSH
96223: EMPTY
96224: LIST
96225: LIST
96226: PUSH
96227: LD_INT 3
96229: PUSH
96230: LD_INT 2
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 5
96240: PUSH
96241: LD_INT 2
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96295: LD_ADDR_VAR 0 32
96299: PUSH
96300: LD_INT 4
96302: NEG
96303: PUSH
96304: LD_INT 0
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 4
96313: NEG
96314: PUSH
96315: LD_INT 1
96317: NEG
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 3
96325: NEG
96326: PUSH
96327: LD_INT 0
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: NEG
96337: PUSH
96338: LD_INT 1
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: PUSH
96345: LD_INT 4
96347: NEG
96348: PUSH
96349: LD_INT 1
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 5
96358: NEG
96359: PUSH
96360: LD_INT 0
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 5
96369: NEG
96370: PUSH
96371: LD_INT 1
96373: NEG
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: LD_INT 5
96381: NEG
96382: PUSH
96383: LD_INT 2
96385: NEG
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: LD_INT 3
96393: NEG
96394: PUSH
96395: LD_INT 2
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 3
96404: NEG
96405: PUSH
96406: LD_INT 3
96408: NEG
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 3
96416: NEG
96417: PUSH
96418: LD_INT 4
96420: NEG
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 2
96428: NEG
96429: PUSH
96430: LD_INT 3
96432: NEG
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 2
96440: NEG
96441: PUSH
96442: LD_INT 2
96444: NEG
96445: PUSH
96446: EMPTY
96447: LIST
96448: LIST
96449: PUSH
96450: LD_INT 3
96452: NEG
96453: PUSH
96454: LD_INT 2
96456: NEG
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 4
96464: NEG
96465: PUSH
96466: LD_INT 3
96468: NEG
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 4
96476: NEG
96477: PUSH
96478: LD_INT 4
96480: NEG
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 2
96488: NEG
96489: PUSH
96490: LD_INT 4
96492: NEG
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 4
96500: NEG
96501: PUSH
96502: LD_INT 2
96504: NEG
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 0
96512: PUSH
96513: LD_INT 4
96515: NEG
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 0
96523: PUSH
96524: LD_INT 5
96526: NEG
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: PUSH
96532: LD_INT 1
96534: PUSH
96535: LD_INT 4
96537: NEG
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 1
96545: PUSH
96546: LD_INT 3
96548: NEG
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 0
96556: PUSH
96557: LD_INT 3
96559: NEG
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 1
96567: NEG
96568: PUSH
96569: LD_INT 4
96571: NEG
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 1
96579: NEG
96580: PUSH
96581: LD_INT 5
96583: NEG
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: PUSH
96589: LD_INT 2
96591: PUSH
96592: LD_INT 3
96594: NEG
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 2
96602: NEG
96603: PUSH
96604: LD_INT 5
96606: NEG
96607: PUSH
96608: EMPTY
96609: LIST
96610: LIST
96611: PUSH
96612: LD_INT 3
96614: PUSH
96615: LD_INT 0
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 3
96624: PUSH
96625: LD_INT 1
96627: NEG
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 4
96635: PUSH
96636: LD_INT 0
96638: PUSH
96639: EMPTY
96640: LIST
96641: LIST
96642: PUSH
96643: LD_INT 4
96645: PUSH
96646: LD_INT 1
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 3
96655: PUSH
96656: LD_INT 1
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 2
96665: PUSH
96666: LD_INT 0
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 2
96675: PUSH
96676: LD_INT 1
96678: NEG
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 2
96686: PUSH
96687: LD_INT 2
96689: NEG
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 4
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 4
96707: PUSH
96708: LD_INT 4
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 4
96717: PUSH
96718: LD_INT 3
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 5
96727: PUSH
96728: LD_INT 4
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 5
96737: PUSH
96738: LD_INT 5
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 4
96747: PUSH
96748: LD_INT 5
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 3
96757: PUSH
96758: LD_INT 4
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: LD_INT 3
96767: PUSH
96768: LD_INT 3
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 5
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 3
96787: PUSH
96788: LD_INT 5
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96842: LD_ADDR_VAR 0 33
96846: PUSH
96847: LD_INT 4
96849: NEG
96850: PUSH
96851: LD_INT 4
96853: NEG
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 4
96861: NEG
96862: PUSH
96863: LD_INT 5
96865: NEG
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 3
96873: NEG
96874: PUSH
96875: LD_INT 4
96877: NEG
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 3
96885: NEG
96886: PUSH
96887: LD_INT 3
96889: NEG
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 4
96897: NEG
96898: PUSH
96899: LD_INT 3
96901: NEG
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 5
96909: NEG
96910: PUSH
96911: LD_INT 4
96913: NEG
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 5
96921: NEG
96922: PUSH
96923: LD_INT 5
96925: NEG
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 3
96933: NEG
96934: PUSH
96935: LD_INT 5
96937: NEG
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 5
96945: NEG
96946: PUSH
96947: LD_INT 3
96949: NEG
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 0
96957: PUSH
96958: LD_INT 3
96960: NEG
96961: PUSH
96962: EMPTY
96963: LIST
96964: LIST
96965: PUSH
96966: LD_INT 0
96968: PUSH
96969: LD_INT 4
96971: NEG
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PUSH
96977: LD_INT 1
96979: PUSH
96980: LD_INT 3
96982: NEG
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: LD_INT 1
96990: PUSH
96991: LD_INT 2
96993: NEG
96994: PUSH
96995: EMPTY
96996: LIST
96997: LIST
96998: PUSH
96999: LD_INT 0
97001: PUSH
97002: LD_INT 2
97004: NEG
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: PUSH
97010: LD_INT 1
97012: NEG
97013: PUSH
97014: LD_INT 3
97016: NEG
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 1
97024: NEG
97025: PUSH
97026: LD_INT 4
97028: NEG
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 2
97036: PUSH
97037: LD_INT 2
97039: NEG
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 2
97047: NEG
97048: PUSH
97049: LD_INT 4
97051: NEG
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PUSH
97057: LD_INT 4
97059: PUSH
97060: LD_INT 0
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 4
97069: PUSH
97070: LD_INT 1
97072: NEG
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 5
97080: PUSH
97081: LD_INT 0
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 5
97090: PUSH
97091: LD_INT 1
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: PUSH
97098: LD_INT 4
97100: PUSH
97101: LD_INT 1
97103: PUSH
97104: EMPTY
97105: LIST
97106: LIST
97107: PUSH
97108: LD_INT 3
97110: PUSH
97111: LD_INT 0
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 3
97120: PUSH
97121: LD_INT 1
97123: NEG
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 3
97131: PUSH
97132: LD_INT 2
97134: NEG
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 5
97142: PUSH
97143: LD_INT 2
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PUSH
97150: LD_INT 3
97152: PUSH
97153: LD_INT 3
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PUSH
97160: LD_INT 3
97162: PUSH
97163: LD_INT 2
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 4
97172: PUSH
97173: LD_INT 3
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PUSH
97180: LD_INT 4
97182: PUSH
97183: LD_INT 4
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: PUSH
97190: LD_INT 3
97192: PUSH
97193: LD_INT 4
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: PUSH
97200: LD_INT 2
97202: PUSH
97203: LD_INT 3
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: PUSH
97210: LD_INT 2
97212: PUSH
97213: LD_INT 2
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 4
97222: PUSH
97223: LD_INT 2
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 2
97232: PUSH
97233: LD_INT 4
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 0
97242: PUSH
97243: LD_INT 4
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: LD_INT 0
97252: PUSH
97253: LD_INT 3
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PUSH
97260: LD_INT 1
97262: PUSH
97263: LD_INT 4
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: PUSH
97270: LD_INT 1
97272: PUSH
97273: LD_INT 5
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 0
97282: PUSH
97283: LD_INT 5
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 1
97292: NEG
97293: PUSH
97294: LD_INT 4
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: LD_INT 1
97303: NEG
97304: PUSH
97305: LD_INT 3
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 2
97314: PUSH
97315: LD_INT 5
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PUSH
97322: LD_INT 2
97324: NEG
97325: PUSH
97326: LD_INT 3
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97380: LD_ADDR_VAR 0 34
97384: PUSH
97385: LD_INT 0
97387: PUSH
97388: LD_INT 4
97390: NEG
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 0
97398: PUSH
97399: LD_INT 5
97401: NEG
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 1
97409: PUSH
97410: LD_INT 4
97412: NEG
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 1
97420: PUSH
97421: LD_INT 3
97423: NEG
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_INT 0
97431: PUSH
97432: LD_INT 3
97434: NEG
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 1
97442: NEG
97443: PUSH
97444: LD_INT 4
97446: NEG
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PUSH
97452: LD_INT 1
97454: NEG
97455: PUSH
97456: LD_INT 5
97458: NEG
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: PUSH
97464: LD_INT 2
97466: PUSH
97467: LD_INT 3
97469: NEG
97470: PUSH
97471: EMPTY
97472: LIST
97473: LIST
97474: PUSH
97475: LD_INT 2
97477: NEG
97478: PUSH
97479: LD_INT 5
97481: NEG
97482: PUSH
97483: EMPTY
97484: LIST
97485: LIST
97486: PUSH
97487: LD_INT 3
97489: PUSH
97490: LD_INT 0
97492: PUSH
97493: EMPTY
97494: LIST
97495: LIST
97496: PUSH
97497: LD_INT 3
97499: PUSH
97500: LD_INT 1
97502: NEG
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 4
97510: PUSH
97511: LD_INT 0
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: PUSH
97518: LD_INT 4
97520: PUSH
97521: LD_INT 1
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: PUSH
97528: LD_INT 3
97530: PUSH
97531: LD_INT 1
97533: PUSH
97534: EMPTY
97535: LIST
97536: LIST
97537: PUSH
97538: LD_INT 2
97540: PUSH
97541: LD_INT 0
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PUSH
97548: LD_INT 2
97550: PUSH
97551: LD_INT 1
97553: NEG
97554: PUSH
97555: EMPTY
97556: LIST
97557: LIST
97558: PUSH
97559: LD_INT 2
97561: PUSH
97562: LD_INT 2
97564: NEG
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 4
97572: PUSH
97573: LD_INT 2
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PUSH
97580: LD_INT 4
97582: PUSH
97583: LD_INT 4
97585: PUSH
97586: EMPTY
97587: LIST
97588: LIST
97589: PUSH
97590: LD_INT 4
97592: PUSH
97593: LD_INT 3
97595: PUSH
97596: EMPTY
97597: LIST
97598: LIST
97599: PUSH
97600: LD_INT 5
97602: PUSH
97603: LD_INT 4
97605: PUSH
97606: EMPTY
97607: LIST
97608: LIST
97609: PUSH
97610: LD_INT 5
97612: PUSH
97613: LD_INT 5
97615: PUSH
97616: EMPTY
97617: LIST
97618: LIST
97619: PUSH
97620: LD_INT 4
97622: PUSH
97623: LD_INT 5
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 3
97632: PUSH
97633: LD_INT 4
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 3
97642: PUSH
97643: LD_INT 3
97645: PUSH
97646: EMPTY
97647: LIST
97648: LIST
97649: PUSH
97650: LD_INT 5
97652: PUSH
97653: LD_INT 3
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: PUSH
97660: LD_INT 3
97662: PUSH
97663: LD_INT 5
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: PUSH
97670: LD_INT 0
97672: PUSH
97673: LD_INT 3
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: PUSH
97680: LD_INT 0
97682: PUSH
97683: LD_INT 2
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: PUSH
97690: LD_INT 1
97692: PUSH
97693: LD_INT 3
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: PUSH
97700: LD_INT 1
97702: PUSH
97703: LD_INT 4
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: LD_INT 0
97712: PUSH
97713: LD_INT 4
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: LD_INT 1
97722: NEG
97723: PUSH
97724: LD_INT 3
97726: PUSH
97727: EMPTY
97728: LIST
97729: LIST
97730: PUSH
97731: LD_INT 1
97733: NEG
97734: PUSH
97735: LD_INT 2
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: PUSH
97742: LD_INT 2
97744: PUSH
97745: LD_INT 4
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PUSH
97752: LD_INT 2
97754: NEG
97755: PUSH
97756: LD_INT 2
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: PUSH
97763: LD_INT 4
97765: NEG
97766: PUSH
97767: LD_INT 0
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PUSH
97774: LD_INT 4
97776: NEG
97777: PUSH
97778: LD_INT 1
97780: NEG
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: PUSH
97786: LD_INT 3
97788: NEG
97789: PUSH
97790: LD_INT 0
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 3
97799: NEG
97800: PUSH
97801: LD_INT 1
97803: PUSH
97804: EMPTY
97805: LIST
97806: LIST
97807: PUSH
97808: LD_INT 4
97810: NEG
97811: PUSH
97812: LD_INT 1
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PUSH
97819: LD_INT 5
97821: NEG
97822: PUSH
97823: LD_INT 0
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 5
97832: NEG
97833: PUSH
97834: LD_INT 1
97836: NEG
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 5
97844: NEG
97845: PUSH
97846: LD_INT 2
97848: NEG
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: PUSH
97854: LD_INT 3
97856: NEG
97857: PUSH
97858: LD_INT 2
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: ST_TO_ADDR
// end ; end ;
97912: GO 97915
97914: POP
// case btype of b_depot , b_warehouse :
97915: LD_VAR 0 1
97919: PUSH
97920: LD_INT 0
97922: DOUBLE
97923: EQUAL
97924: IFTRUE 97934
97926: LD_INT 1
97928: DOUBLE
97929: EQUAL
97930: IFTRUE 97934
97932: GO 98135
97934: POP
// case nation of nation_american :
97935: LD_VAR 0 5
97939: PUSH
97940: LD_INT 1
97942: DOUBLE
97943: EQUAL
97944: IFTRUE 97948
97946: GO 98004
97948: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97949: LD_ADDR_VAR 0 9
97953: PUSH
97954: LD_VAR 0 11
97958: PUSH
97959: LD_VAR 0 12
97963: PUSH
97964: LD_VAR 0 13
97968: PUSH
97969: LD_VAR 0 14
97973: PUSH
97974: LD_VAR 0 15
97978: PUSH
97979: LD_VAR 0 16
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: PUSH
97992: LD_VAR 0 4
97996: PUSH
97997: LD_INT 1
97999: PLUS
98000: ARRAY
98001: ST_TO_ADDR
98002: GO 98133
98004: LD_INT 2
98006: DOUBLE
98007: EQUAL
98008: IFTRUE 98012
98010: GO 98068
98012: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98013: LD_ADDR_VAR 0 9
98017: PUSH
98018: LD_VAR 0 17
98022: PUSH
98023: LD_VAR 0 18
98027: PUSH
98028: LD_VAR 0 19
98032: PUSH
98033: LD_VAR 0 20
98037: PUSH
98038: LD_VAR 0 21
98042: PUSH
98043: LD_VAR 0 22
98047: PUSH
98048: EMPTY
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: PUSH
98056: LD_VAR 0 4
98060: PUSH
98061: LD_INT 1
98063: PLUS
98064: ARRAY
98065: ST_TO_ADDR
98066: GO 98133
98068: LD_INT 3
98070: DOUBLE
98071: EQUAL
98072: IFTRUE 98076
98074: GO 98132
98076: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98077: LD_ADDR_VAR 0 9
98081: PUSH
98082: LD_VAR 0 23
98086: PUSH
98087: LD_VAR 0 24
98091: PUSH
98092: LD_VAR 0 25
98096: PUSH
98097: LD_VAR 0 26
98101: PUSH
98102: LD_VAR 0 27
98106: PUSH
98107: LD_VAR 0 28
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: PUSH
98120: LD_VAR 0 4
98124: PUSH
98125: LD_INT 1
98127: PLUS
98128: ARRAY
98129: ST_TO_ADDR
98130: GO 98133
98132: POP
98133: GO 98688
98135: LD_INT 2
98137: DOUBLE
98138: EQUAL
98139: IFTRUE 98149
98141: LD_INT 3
98143: DOUBLE
98144: EQUAL
98145: IFTRUE 98149
98147: GO 98205
98149: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98150: LD_ADDR_VAR 0 9
98154: PUSH
98155: LD_VAR 0 29
98159: PUSH
98160: LD_VAR 0 30
98164: PUSH
98165: LD_VAR 0 31
98169: PUSH
98170: LD_VAR 0 32
98174: PUSH
98175: LD_VAR 0 33
98179: PUSH
98180: LD_VAR 0 34
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: PUSH
98193: LD_VAR 0 4
98197: PUSH
98198: LD_INT 1
98200: PLUS
98201: ARRAY
98202: ST_TO_ADDR
98203: GO 98688
98205: LD_INT 16
98207: DOUBLE
98208: EQUAL
98209: IFTRUE 98267
98211: LD_INT 17
98213: DOUBLE
98214: EQUAL
98215: IFTRUE 98267
98217: LD_INT 18
98219: DOUBLE
98220: EQUAL
98221: IFTRUE 98267
98223: LD_INT 19
98225: DOUBLE
98226: EQUAL
98227: IFTRUE 98267
98229: LD_INT 22
98231: DOUBLE
98232: EQUAL
98233: IFTRUE 98267
98235: LD_INT 20
98237: DOUBLE
98238: EQUAL
98239: IFTRUE 98267
98241: LD_INT 21
98243: DOUBLE
98244: EQUAL
98245: IFTRUE 98267
98247: LD_INT 23
98249: DOUBLE
98250: EQUAL
98251: IFTRUE 98267
98253: LD_INT 24
98255: DOUBLE
98256: EQUAL
98257: IFTRUE 98267
98259: LD_INT 25
98261: DOUBLE
98262: EQUAL
98263: IFTRUE 98267
98265: GO 98323
98267: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98268: LD_ADDR_VAR 0 9
98272: PUSH
98273: LD_VAR 0 35
98277: PUSH
98278: LD_VAR 0 36
98282: PUSH
98283: LD_VAR 0 37
98287: PUSH
98288: LD_VAR 0 38
98292: PUSH
98293: LD_VAR 0 39
98297: PUSH
98298: LD_VAR 0 40
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: PUSH
98311: LD_VAR 0 4
98315: PUSH
98316: LD_INT 1
98318: PLUS
98319: ARRAY
98320: ST_TO_ADDR
98321: GO 98688
98323: LD_INT 6
98325: DOUBLE
98326: EQUAL
98327: IFTRUE 98379
98329: LD_INT 7
98331: DOUBLE
98332: EQUAL
98333: IFTRUE 98379
98335: LD_INT 8
98337: DOUBLE
98338: EQUAL
98339: IFTRUE 98379
98341: LD_INT 13
98343: DOUBLE
98344: EQUAL
98345: IFTRUE 98379
98347: LD_INT 12
98349: DOUBLE
98350: EQUAL
98351: IFTRUE 98379
98353: LD_INT 15
98355: DOUBLE
98356: EQUAL
98357: IFTRUE 98379
98359: LD_INT 11
98361: DOUBLE
98362: EQUAL
98363: IFTRUE 98379
98365: LD_INT 14
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98379
98371: LD_INT 10
98373: DOUBLE
98374: EQUAL
98375: IFTRUE 98379
98377: GO 98435
98379: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98380: LD_ADDR_VAR 0 9
98384: PUSH
98385: LD_VAR 0 41
98389: PUSH
98390: LD_VAR 0 42
98394: PUSH
98395: LD_VAR 0 43
98399: PUSH
98400: LD_VAR 0 44
98404: PUSH
98405: LD_VAR 0 45
98409: PUSH
98410: LD_VAR 0 46
98414: PUSH
98415: EMPTY
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: PUSH
98423: LD_VAR 0 4
98427: PUSH
98428: LD_INT 1
98430: PLUS
98431: ARRAY
98432: ST_TO_ADDR
98433: GO 98688
98435: LD_INT 36
98437: DOUBLE
98438: EQUAL
98439: IFTRUE 98443
98441: GO 98499
98443: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98444: LD_ADDR_VAR 0 9
98448: PUSH
98449: LD_VAR 0 47
98453: PUSH
98454: LD_VAR 0 48
98458: PUSH
98459: LD_VAR 0 49
98463: PUSH
98464: LD_VAR 0 50
98468: PUSH
98469: LD_VAR 0 51
98473: PUSH
98474: LD_VAR 0 52
98478: PUSH
98479: EMPTY
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: PUSH
98487: LD_VAR 0 4
98491: PUSH
98492: LD_INT 1
98494: PLUS
98495: ARRAY
98496: ST_TO_ADDR
98497: GO 98688
98499: LD_INT 4
98501: DOUBLE
98502: EQUAL
98503: IFTRUE 98525
98505: LD_INT 5
98507: DOUBLE
98508: EQUAL
98509: IFTRUE 98525
98511: LD_INT 34
98513: DOUBLE
98514: EQUAL
98515: IFTRUE 98525
98517: LD_INT 37
98519: DOUBLE
98520: EQUAL
98521: IFTRUE 98525
98523: GO 98581
98525: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98526: LD_ADDR_VAR 0 9
98530: PUSH
98531: LD_VAR 0 53
98535: PUSH
98536: LD_VAR 0 54
98540: PUSH
98541: LD_VAR 0 55
98545: PUSH
98546: LD_VAR 0 56
98550: PUSH
98551: LD_VAR 0 57
98555: PUSH
98556: LD_VAR 0 58
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: PUSH
98569: LD_VAR 0 4
98573: PUSH
98574: LD_INT 1
98576: PLUS
98577: ARRAY
98578: ST_TO_ADDR
98579: GO 98688
98581: LD_INT 31
98583: DOUBLE
98584: EQUAL
98585: IFTRUE 98631
98587: LD_INT 32
98589: DOUBLE
98590: EQUAL
98591: IFTRUE 98631
98593: LD_INT 33
98595: DOUBLE
98596: EQUAL
98597: IFTRUE 98631
98599: LD_INT 27
98601: DOUBLE
98602: EQUAL
98603: IFTRUE 98631
98605: LD_INT 26
98607: DOUBLE
98608: EQUAL
98609: IFTRUE 98631
98611: LD_INT 28
98613: DOUBLE
98614: EQUAL
98615: IFTRUE 98631
98617: LD_INT 29
98619: DOUBLE
98620: EQUAL
98621: IFTRUE 98631
98623: LD_INT 30
98625: DOUBLE
98626: EQUAL
98627: IFTRUE 98631
98629: GO 98687
98631: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98632: LD_ADDR_VAR 0 9
98636: PUSH
98637: LD_VAR 0 59
98641: PUSH
98642: LD_VAR 0 60
98646: PUSH
98647: LD_VAR 0 61
98651: PUSH
98652: LD_VAR 0 62
98656: PUSH
98657: LD_VAR 0 63
98661: PUSH
98662: LD_VAR 0 64
98666: PUSH
98667: EMPTY
98668: LIST
98669: LIST
98670: LIST
98671: LIST
98672: LIST
98673: LIST
98674: PUSH
98675: LD_VAR 0 4
98679: PUSH
98680: LD_INT 1
98682: PLUS
98683: ARRAY
98684: ST_TO_ADDR
98685: GO 98688
98687: POP
// temp_list2 = [ ] ;
98688: LD_ADDR_VAR 0 10
98692: PUSH
98693: EMPTY
98694: ST_TO_ADDR
// for i in temp_list do
98695: LD_ADDR_VAR 0 8
98699: PUSH
98700: LD_VAR 0 9
98704: PUSH
98705: FOR_IN
98706: IFFALSE 98758
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98708: LD_ADDR_VAR 0 10
98712: PUSH
98713: LD_VAR 0 10
98717: PUSH
98718: LD_VAR 0 8
98722: PUSH
98723: LD_INT 1
98725: ARRAY
98726: PUSH
98727: LD_VAR 0 2
98731: PLUS
98732: PUSH
98733: LD_VAR 0 8
98737: PUSH
98738: LD_INT 2
98740: ARRAY
98741: PUSH
98742: LD_VAR 0 3
98746: PLUS
98747: PUSH
98748: EMPTY
98749: LIST
98750: LIST
98751: PUSH
98752: EMPTY
98753: LIST
98754: ADD
98755: ST_TO_ADDR
98756: GO 98705
98758: POP
98759: POP
// result = temp_list2 ;
98760: LD_ADDR_VAR 0 7
98764: PUSH
98765: LD_VAR 0 10
98769: ST_TO_ADDR
// end ;
98770: LD_VAR 0 7
98774: RET
// export function EnemyInRange ( unit , dist ) ; begin
98775: LD_INT 0
98777: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98778: LD_ADDR_VAR 0 3
98782: PUSH
98783: LD_VAR 0 1
98787: PPUSH
98788: CALL_OW 255
98792: PPUSH
98793: LD_VAR 0 1
98797: PPUSH
98798: CALL_OW 250
98802: PPUSH
98803: LD_VAR 0 1
98807: PPUSH
98808: CALL_OW 251
98812: PPUSH
98813: LD_VAR 0 2
98817: PPUSH
98818: CALL 72879 0 4
98822: PUSH
98823: LD_INT 4
98825: ARRAY
98826: ST_TO_ADDR
// end ;
98827: LD_VAR 0 3
98831: RET
// export function PlayerSeeMe ( unit ) ; begin
98832: LD_INT 0
98834: PPUSH
// result := See ( your_side , unit ) ;
98835: LD_ADDR_VAR 0 2
98839: PUSH
98840: LD_OWVAR 2
98844: PPUSH
98845: LD_VAR 0 1
98849: PPUSH
98850: CALL_OW 292
98854: ST_TO_ADDR
// end ;
98855: LD_VAR 0 2
98859: RET
// export function ReverseDir ( unit ) ; begin
98860: LD_INT 0
98862: PPUSH
// if not unit then
98863: LD_VAR 0 1
98867: NOT
98868: IFFALSE 98872
// exit ;
98870: GO 98895
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98872: LD_ADDR_VAR 0 2
98876: PUSH
98877: LD_VAR 0 1
98881: PPUSH
98882: CALL_OW 254
98886: PUSH
98887: LD_INT 3
98889: PLUS
98890: PUSH
98891: LD_INT 6
98893: MOD
98894: ST_TO_ADDR
// end ;
98895: LD_VAR 0 2
98899: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98900: LD_INT 0
98902: PPUSH
98903: PPUSH
98904: PPUSH
98905: PPUSH
98906: PPUSH
// if not hexes then
98907: LD_VAR 0 2
98911: NOT
98912: IFFALSE 98916
// exit ;
98914: GO 99064
// dist := 9999 ;
98916: LD_ADDR_VAR 0 5
98920: PUSH
98921: LD_INT 9999
98923: ST_TO_ADDR
// for i = 1 to hexes do
98924: LD_ADDR_VAR 0 4
98928: PUSH
98929: DOUBLE
98930: LD_INT 1
98932: DEC
98933: ST_TO_ADDR
98934: LD_VAR 0 2
98938: PUSH
98939: FOR_TO
98940: IFFALSE 99052
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98942: LD_VAR 0 1
98946: PPUSH
98947: LD_VAR 0 2
98951: PUSH
98952: LD_VAR 0 4
98956: ARRAY
98957: PUSH
98958: LD_INT 1
98960: ARRAY
98961: PPUSH
98962: LD_VAR 0 2
98966: PUSH
98967: LD_VAR 0 4
98971: ARRAY
98972: PUSH
98973: LD_INT 2
98975: ARRAY
98976: PPUSH
98977: CALL_OW 297
98981: PUSH
98982: LD_VAR 0 5
98986: LESS
98987: IFFALSE 99050
// begin hex := hexes [ i ] ;
98989: LD_ADDR_VAR 0 7
98993: PUSH
98994: LD_VAR 0 2
98998: PUSH
98999: LD_VAR 0 4
99003: ARRAY
99004: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99005: LD_ADDR_VAR 0 5
99009: PUSH
99010: LD_VAR 0 1
99014: PPUSH
99015: LD_VAR 0 2
99019: PUSH
99020: LD_VAR 0 4
99024: ARRAY
99025: PUSH
99026: LD_INT 1
99028: ARRAY
99029: PPUSH
99030: LD_VAR 0 2
99034: PUSH
99035: LD_VAR 0 4
99039: ARRAY
99040: PUSH
99041: LD_INT 2
99043: ARRAY
99044: PPUSH
99045: CALL_OW 297
99049: ST_TO_ADDR
// end ; end ;
99050: GO 98939
99052: POP
99053: POP
// result := hex ;
99054: LD_ADDR_VAR 0 3
99058: PUSH
99059: LD_VAR 0 7
99063: ST_TO_ADDR
// end ;
99064: LD_VAR 0 3
99068: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99069: LD_INT 0
99071: PPUSH
99072: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99073: LD_VAR 0 1
99077: NOT
99078: PUSH
99079: LD_VAR 0 1
99083: PUSH
99084: LD_INT 21
99086: PUSH
99087: LD_INT 2
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PUSH
99094: LD_INT 23
99096: PUSH
99097: LD_INT 2
99099: PUSH
99100: EMPTY
99101: LIST
99102: LIST
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PPUSH
99108: CALL_OW 69
99112: IN
99113: NOT
99114: OR
99115: IFFALSE 99119
// exit ;
99117: GO 99166
// for i = 1 to 3 do
99119: LD_ADDR_VAR 0 3
99123: PUSH
99124: DOUBLE
99125: LD_INT 1
99127: DEC
99128: ST_TO_ADDR
99129: LD_INT 3
99131: PUSH
99132: FOR_TO
99133: IFFALSE 99164
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99135: LD_VAR 0 1
99139: PPUSH
99140: CALL_OW 250
99144: PPUSH
99145: LD_VAR 0 1
99149: PPUSH
99150: CALL_OW 251
99154: PPUSH
99155: LD_INT 1
99157: PPUSH
99158: CALL_OW 453
99162: GO 99132
99164: POP
99165: POP
// end ;
99166: LD_VAR 0 2
99170: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99171: LD_INT 0
99173: PPUSH
99174: PPUSH
99175: PPUSH
99176: PPUSH
99177: PPUSH
99178: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99179: LD_VAR 0 1
99183: NOT
99184: PUSH
99185: LD_VAR 0 2
99189: NOT
99190: OR
99191: PUSH
99192: LD_VAR 0 1
99196: PPUSH
99197: CALL_OW 314
99201: OR
99202: IFFALSE 99206
// exit ;
99204: GO 99647
// x := GetX ( enemy_unit ) ;
99206: LD_ADDR_VAR 0 7
99210: PUSH
99211: LD_VAR 0 2
99215: PPUSH
99216: CALL_OW 250
99220: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99221: LD_ADDR_VAR 0 8
99225: PUSH
99226: LD_VAR 0 2
99230: PPUSH
99231: CALL_OW 251
99235: ST_TO_ADDR
// if not x or not y then
99236: LD_VAR 0 7
99240: NOT
99241: PUSH
99242: LD_VAR 0 8
99246: NOT
99247: OR
99248: IFFALSE 99252
// exit ;
99250: GO 99647
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99252: LD_ADDR_VAR 0 6
99256: PUSH
99257: LD_VAR 0 7
99261: PPUSH
99262: LD_INT 0
99264: PPUSH
99265: LD_INT 4
99267: PPUSH
99268: CALL_OW 272
99272: PUSH
99273: LD_VAR 0 8
99277: PPUSH
99278: LD_INT 0
99280: PPUSH
99281: LD_INT 4
99283: PPUSH
99284: CALL_OW 273
99288: PUSH
99289: EMPTY
99290: LIST
99291: LIST
99292: PUSH
99293: LD_VAR 0 7
99297: PPUSH
99298: LD_INT 1
99300: PPUSH
99301: LD_INT 4
99303: PPUSH
99304: CALL_OW 272
99308: PUSH
99309: LD_VAR 0 8
99313: PPUSH
99314: LD_INT 1
99316: PPUSH
99317: LD_INT 4
99319: PPUSH
99320: CALL_OW 273
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: PUSH
99329: LD_VAR 0 7
99333: PPUSH
99334: LD_INT 2
99336: PPUSH
99337: LD_INT 4
99339: PPUSH
99340: CALL_OW 272
99344: PUSH
99345: LD_VAR 0 8
99349: PPUSH
99350: LD_INT 2
99352: PPUSH
99353: LD_INT 4
99355: PPUSH
99356: CALL_OW 273
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PUSH
99365: LD_VAR 0 7
99369: PPUSH
99370: LD_INT 3
99372: PPUSH
99373: LD_INT 4
99375: PPUSH
99376: CALL_OW 272
99380: PUSH
99381: LD_VAR 0 8
99385: PPUSH
99386: LD_INT 3
99388: PPUSH
99389: LD_INT 4
99391: PPUSH
99392: CALL_OW 273
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: PUSH
99401: LD_VAR 0 7
99405: PPUSH
99406: LD_INT 4
99408: PPUSH
99409: LD_INT 4
99411: PPUSH
99412: CALL_OW 272
99416: PUSH
99417: LD_VAR 0 8
99421: PPUSH
99422: LD_INT 4
99424: PPUSH
99425: LD_INT 4
99427: PPUSH
99428: CALL_OW 273
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: LD_VAR 0 7
99441: PPUSH
99442: LD_INT 5
99444: PPUSH
99445: LD_INT 4
99447: PPUSH
99448: CALL_OW 272
99452: PUSH
99453: LD_VAR 0 8
99457: PPUSH
99458: LD_INT 5
99460: PPUSH
99461: LD_INT 4
99463: PPUSH
99464: CALL_OW 273
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: LIST
99477: LIST
99478: LIST
99479: LIST
99480: ST_TO_ADDR
// for i = tmp downto 1 do
99481: LD_ADDR_VAR 0 4
99485: PUSH
99486: DOUBLE
99487: LD_VAR 0 6
99491: INC
99492: ST_TO_ADDR
99493: LD_INT 1
99495: PUSH
99496: FOR_DOWNTO
99497: IFFALSE 99598
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99499: LD_VAR 0 6
99503: PUSH
99504: LD_VAR 0 4
99508: ARRAY
99509: PUSH
99510: LD_INT 1
99512: ARRAY
99513: PPUSH
99514: LD_VAR 0 6
99518: PUSH
99519: LD_VAR 0 4
99523: ARRAY
99524: PUSH
99525: LD_INT 2
99527: ARRAY
99528: PPUSH
99529: CALL_OW 488
99533: NOT
99534: PUSH
99535: LD_VAR 0 6
99539: PUSH
99540: LD_VAR 0 4
99544: ARRAY
99545: PUSH
99546: LD_INT 1
99548: ARRAY
99549: PPUSH
99550: LD_VAR 0 6
99554: PUSH
99555: LD_VAR 0 4
99559: ARRAY
99560: PUSH
99561: LD_INT 2
99563: ARRAY
99564: PPUSH
99565: CALL_OW 428
99569: PUSH
99570: LD_INT 0
99572: NONEQUAL
99573: OR
99574: IFFALSE 99596
// tmp := Delete ( tmp , i ) ;
99576: LD_ADDR_VAR 0 6
99580: PUSH
99581: LD_VAR 0 6
99585: PPUSH
99586: LD_VAR 0 4
99590: PPUSH
99591: CALL_OW 3
99595: ST_TO_ADDR
99596: GO 99496
99598: POP
99599: POP
// j := GetClosestHex ( unit , tmp ) ;
99600: LD_ADDR_VAR 0 5
99604: PUSH
99605: LD_VAR 0 1
99609: PPUSH
99610: LD_VAR 0 6
99614: PPUSH
99615: CALL 98900 0 2
99619: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99620: LD_VAR 0 1
99624: PPUSH
99625: LD_VAR 0 5
99629: PUSH
99630: LD_INT 1
99632: ARRAY
99633: PPUSH
99634: LD_VAR 0 5
99638: PUSH
99639: LD_INT 2
99641: ARRAY
99642: PPUSH
99643: CALL_OW 111
// end ;
99647: LD_VAR 0 3
99651: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99652: LD_INT 0
99654: PPUSH
99655: PPUSH
99656: PPUSH
// uc_side = 0 ;
99657: LD_ADDR_OWVAR 20
99661: PUSH
99662: LD_INT 0
99664: ST_TO_ADDR
// uc_nation = 0 ;
99665: LD_ADDR_OWVAR 21
99669: PUSH
99670: LD_INT 0
99672: ST_TO_ADDR
// InitHc ;
99673: CALL_OW 19
// InitVc ;
99677: CALL_OW 20
// if mastodonts then
99681: LD_VAR 0 6
99685: IFFALSE 99752
// for i = 1 to mastodonts do
99687: LD_ADDR_VAR 0 11
99691: PUSH
99692: DOUBLE
99693: LD_INT 1
99695: DEC
99696: ST_TO_ADDR
99697: LD_VAR 0 6
99701: PUSH
99702: FOR_TO
99703: IFFALSE 99750
// begin vc_chassis := 31 ;
99705: LD_ADDR_OWVAR 37
99709: PUSH
99710: LD_INT 31
99712: ST_TO_ADDR
// vc_control := control_rider ;
99713: LD_ADDR_OWVAR 38
99717: PUSH
99718: LD_INT 4
99720: ST_TO_ADDR
// animal := CreateVehicle ;
99721: LD_ADDR_VAR 0 12
99725: PUSH
99726: CALL_OW 45
99730: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99731: LD_VAR 0 12
99735: PPUSH
99736: LD_VAR 0 8
99740: PPUSH
99741: LD_INT 0
99743: PPUSH
99744: CALL 106523 0 3
// end ;
99748: GO 99702
99750: POP
99751: POP
// if horses then
99752: LD_VAR 0 5
99756: IFFALSE 99823
// for i = 1 to horses do
99758: LD_ADDR_VAR 0 11
99762: PUSH
99763: DOUBLE
99764: LD_INT 1
99766: DEC
99767: ST_TO_ADDR
99768: LD_VAR 0 5
99772: PUSH
99773: FOR_TO
99774: IFFALSE 99821
// begin hc_class := 21 ;
99776: LD_ADDR_OWVAR 28
99780: PUSH
99781: LD_INT 21
99783: ST_TO_ADDR
// hc_gallery :=  ;
99784: LD_ADDR_OWVAR 33
99788: PUSH
99789: LD_STRING 
99791: ST_TO_ADDR
// animal := CreateHuman ;
99792: LD_ADDR_VAR 0 12
99796: PUSH
99797: CALL_OW 44
99801: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99802: LD_VAR 0 12
99806: PPUSH
99807: LD_VAR 0 8
99811: PPUSH
99812: LD_INT 0
99814: PPUSH
99815: CALL 106523 0 3
// end ;
99819: GO 99773
99821: POP
99822: POP
// if birds then
99823: LD_VAR 0 1
99827: IFFALSE 99894
// for i = 1 to birds do
99829: LD_ADDR_VAR 0 11
99833: PUSH
99834: DOUBLE
99835: LD_INT 1
99837: DEC
99838: ST_TO_ADDR
99839: LD_VAR 0 1
99843: PUSH
99844: FOR_TO
99845: IFFALSE 99892
// begin hc_class = 18 ;
99847: LD_ADDR_OWVAR 28
99851: PUSH
99852: LD_INT 18
99854: ST_TO_ADDR
// hc_gallery =  ;
99855: LD_ADDR_OWVAR 33
99859: PUSH
99860: LD_STRING 
99862: ST_TO_ADDR
// animal := CreateHuman ;
99863: LD_ADDR_VAR 0 12
99867: PUSH
99868: CALL_OW 44
99872: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99873: LD_VAR 0 12
99877: PPUSH
99878: LD_VAR 0 8
99882: PPUSH
99883: LD_INT 0
99885: PPUSH
99886: CALL 106523 0 3
// end ;
99890: GO 99844
99892: POP
99893: POP
// if tigers then
99894: LD_VAR 0 2
99898: IFFALSE 99982
// for i = 1 to tigers do
99900: LD_ADDR_VAR 0 11
99904: PUSH
99905: DOUBLE
99906: LD_INT 1
99908: DEC
99909: ST_TO_ADDR
99910: LD_VAR 0 2
99914: PUSH
99915: FOR_TO
99916: IFFALSE 99980
// begin hc_class = class_tiger ;
99918: LD_ADDR_OWVAR 28
99922: PUSH
99923: LD_INT 14
99925: ST_TO_ADDR
// hc_gallery =  ;
99926: LD_ADDR_OWVAR 33
99930: PUSH
99931: LD_STRING 
99933: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99934: LD_ADDR_OWVAR 35
99938: PUSH
99939: LD_INT 7
99941: NEG
99942: PPUSH
99943: LD_INT 7
99945: PPUSH
99946: CALL_OW 12
99950: ST_TO_ADDR
// animal := CreateHuman ;
99951: LD_ADDR_VAR 0 12
99955: PUSH
99956: CALL_OW 44
99960: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99961: LD_VAR 0 12
99965: PPUSH
99966: LD_VAR 0 8
99970: PPUSH
99971: LD_INT 0
99973: PPUSH
99974: CALL 106523 0 3
// end ;
99978: GO 99915
99980: POP
99981: POP
// if apemans then
99982: LD_VAR 0 3
99986: IFFALSE 100109
// for i = 1 to apemans do
99988: LD_ADDR_VAR 0 11
99992: PUSH
99993: DOUBLE
99994: LD_INT 1
99996: DEC
99997: ST_TO_ADDR
99998: LD_VAR 0 3
100002: PUSH
100003: FOR_TO
100004: IFFALSE 100107
// begin hc_class = class_apeman ;
100006: LD_ADDR_OWVAR 28
100010: PUSH
100011: LD_INT 12
100013: ST_TO_ADDR
// hc_gallery =  ;
100014: LD_ADDR_OWVAR 33
100018: PUSH
100019: LD_STRING 
100021: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100022: LD_ADDR_OWVAR 35
100026: PUSH
100027: LD_INT 5
100029: NEG
100030: PPUSH
100031: LD_INT 5
100033: PPUSH
100034: CALL_OW 12
100038: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100039: LD_ADDR_OWVAR 31
100043: PUSH
100044: LD_INT 1
100046: PPUSH
100047: LD_INT 3
100049: PPUSH
100050: CALL_OW 12
100054: PUSH
100055: LD_INT 1
100057: PPUSH
100058: LD_INT 3
100060: PPUSH
100061: CALL_OW 12
100065: PUSH
100066: LD_INT 0
100068: PUSH
100069: LD_INT 0
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: ST_TO_ADDR
// animal := CreateHuman ;
100078: LD_ADDR_VAR 0 12
100082: PUSH
100083: CALL_OW 44
100087: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100088: LD_VAR 0 12
100092: PPUSH
100093: LD_VAR 0 8
100097: PPUSH
100098: LD_INT 0
100100: PPUSH
100101: CALL 106523 0 3
// end ;
100105: GO 100003
100107: POP
100108: POP
// if enchidnas then
100109: LD_VAR 0 4
100113: IFFALSE 100180
// for i = 1 to enchidnas do
100115: LD_ADDR_VAR 0 11
100119: PUSH
100120: DOUBLE
100121: LD_INT 1
100123: DEC
100124: ST_TO_ADDR
100125: LD_VAR 0 4
100129: PUSH
100130: FOR_TO
100131: IFFALSE 100178
// begin hc_class = 13 ;
100133: LD_ADDR_OWVAR 28
100137: PUSH
100138: LD_INT 13
100140: ST_TO_ADDR
// hc_gallery =  ;
100141: LD_ADDR_OWVAR 33
100145: PUSH
100146: LD_STRING 
100148: ST_TO_ADDR
// animal := CreateHuman ;
100149: LD_ADDR_VAR 0 12
100153: PUSH
100154: CALL_OW 44
100158: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100159: LD_VAR 0 12
100163: PPUSH
100164: LD_VAR 0 8
100168: PPUSH
100169: LD_INT 0
100171: PPUSH
100172: CALL 106523 0 3
// end ;
100176: GO 100130
100178: POP
100179: POP
// if fishes then
100180: LD_VAR 0 7
100184: IFFALSE 100251
// for i = 1 to fishes do
100186: LD_ADDR_VAR 0 11
100190: PUSH
100191: DOUBLE
100192: LD_INT 1
100194: DEC
100195: ST_TO_ADDR
100196: LD_VAR 0 7
100200: PUSH
100201: FOR_TO
100202: IFFALSE 100249
// begin hc_class = 20 ;
100204: LD_ADDR_OWVAR 28
100208: PUSH
100209: LD_INT 20
100211: ST_TO_ADDR
// hc_gallery =  ;
100212: LD_ADDR_OWVAR 33
100216: PUSH
100217: LD_STRING 
100219: ST_TO_ADDR
// animal := CreateHuman ;
100220: LD_ADDR_VAR 0 12
100224: PUSH
100225: CALL_OW 44
100229: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100230: LD_VAR 0 12
100234: PPUSH
100235: LD_VAR 0 9
100239: PPUSH
100240: LD_INT 0
100242: PPUSH
100243: CALL 106523 0 3
// end ;
100247: GO 100201
100249: POP
100250: POP
// end ;
100251: LD_VAR 0 10
100255: RET
// export function WantHeal ( sci , unit ) ; begin
100256: LD_INT 0
100258: PPUSH
// if GetTaskList ( sci ) > 0 then
100259: LD_VAR 0 1
100263: PPUSH
100264: CALL_OW 437
100268: PUSH
100269: LD_INT 0
100271: GREATER
100272: IFFALSE 100342
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100274: LD_VAR 0 1
100278: PPUSH
100279: CALL_OW 437
100283: PUSH
100284: LD_INT 1
100286: ARRAY
100287: PUSH
100288: LD_INT 1
100290: ARRAY
100291: PUSH
100292: LD_STRING l
100294: EQUAL
100295: PUSH
100296: LD_VAR 0 1
100300: PPUSH
100301: CALL_OW 437
100305: PUSH
100306: LD_INT 1
100308: ARRAY
100309: PUSH
100310: LD_INT 4
100312: ARRAY
100313: PUSH
100314: LD_VAR 0 2
100318: EQUAL
100319: AND
100320: IFFALSE 100332
// result := true else
100322: LD_ADDR_VAR 0 3
100326: PUSH
100327: LD_INT 1
100329: ST_TO_ADDR
100330: GO 100340
// result := false ;
100332: LD_ADDR_VAR 0 3
100336: PUSH
100337: LD_INT 0
100339: ST_TO_ADDR
// end else
100340: GO 100350
// result := false ;
100342: LD_ADDR_VAR 0 3
100346: PUSH
100347: LD_INT 0
100349: ST_TO_ADDR
// end ;
100350: LD_VAR 0 3
100354: RET
// export function HealTarget ( sci ) ; begin
100355: LD_INT 0
100357: PPUSH
// if not sci then
100358: LD_VAR 0 1
100362: NOT
100363: IFFALSE 100367
// exit ;
100365: GO 100432
// result := 0 ;
100367: LD_ADDR_VAR 0 2
100371: PUSH
100372: LD_INT 0
100374: ST_TO_ADDR
// if GetTaskList ( sci ) then
100375: LD_VAR 0 1
100379: PPUSH
100380: CALL_OW 437
100384: IFFALSE 100432
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100386: LD_VAR 0 1
100390: PPUSH
100391: CALL_OW 437
100395: PUSH
100396: LD_INT 1
100398: ARRAY
100399: PUSH
100400: LD_INT 1
100402: ARRAY
100403: PUSH
100404: LD_STRING l
100406: EQUAL
100407: IFFALSE 100432
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100409: LD_ADDR_VAR 0 2
100413: PUSH
100414: LD_VAR 0 1
100418: PPUSH
100419: CALL_OW 437
100423: PUSH
100424: LD_INT 1
100426: ARRAY
100427: PUSH
100428: LD_INT 4
100430: ARRAY
100431: ST_TO_ADDR
// end ;
100432: LD_VAR 0 2
100436: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100437: LD_INT 0
100439: PPUSH
100440: PPUSH
100441: PPUSH
100442: PPUSH
100443: PPUSH
100444: PPUSH
100445: PPUSH
100446: PPUSH
100447: PPUSH
100448: PPUSH
100449: PPUSH
100450: PPUSH
100451: PPUSH
100452: PPUSH
100453: PPUSH
100454: PPUSH
100455: PPUSH
100456: PPUSH
100457: PPUSH
100458: PPUSH
100459: PPUSH
100460: PPUSH
100461: PPUSH
100462: PPUSH
100463: PPUSH
100464: PPUSH
100465: PPUSH
100466: PPUSH
100467: PPUSH
100468: PPUSH
100469: PPUSH
100470: PPUSH
100471: PPUSH
100472: PPUSH
// if not list then
100473: LD_VAR 0 1
100477: NOT
100478: IFFALSE 100482
// exit ;
100480: GO 105134
// base := list [ 1 ] ;
100482: LD_ADDR_VAR 0 3
100486: PUSH
100487: LD_VAR 0 1
100491: PUSH
100492: LD_INT 1
100494: ARRAY
100495: ST_TO_ADDR
// group := list [ 2 ] ;
100496: LD_ADDR_VAR 0 4
100500: PUSH
100501: LD_VAR 0 1
100505: PUSH
100506: LD_INT 2
100508: ARRAY
100509: ST_TO_ADDR
// path := list [ 3 ] ;
100510: LD_ADDR_VAR 0 5
100514: PUSH
100515: LD_VAR 0 1
100519: PUSH
100520: LD_INT 3
100522: ARRAY
100523: ST_TO_ADDR
// flags := list [ 4 ] ;
100524: LD_ADDR_VAR 0 6
100528: PUSH
100529: LD_VAR 0 1
100533: PUSH
100534: LD_INT 4
100536: ARRAY
100537: ST_TO_ADDR
// mined := [ ] ;
100538: LD_ADDR_VAR 0 27
100542: PUSH
100543: EMPTY
100544: ST_TO_ADDR
// bombed := [ ] ;
100545: LD_ADDR_VAR 0 28
100549: PUSH
100550: EMPTY
100551: ST_TO_ADDR
// healers := [ ] ;
100552: LD_ADDR_VAR 0 31
100556: PUSH
100557: EMPTY
100558: ST_TO_ADDR
// to_heal := [ ] ;
100559: LD_ADDR_VAR 0 30
100563: PUSH
100564: EMPTY
100565: ST_TO_ADDR
// repairs := [ ] ;
100566: LD_ADDR_VAR 0 33
100570: PUSH
100571: EMPTY
100572: ST_TO_ADDR
// to_repair := [ ] ;
100573: LD_ADDR_VAR 0 32
100577: PUSH
100578: EMPTY
100579: ST_TO_ADDR
// if not group or not path then
100580: LD_VAR 0 4
100584: NOT
100585: PUSH
100586: LD_VAR 0 5
100590: NOT
100591: OR
100592: IFFALSE 100596
// exit ;
100594: GO 105134
// side := GetSide ( group [ 1 ] ) ;
100596: LD_ADDR_VAR 0 35
100600: PUSH
100601: LD_VAR 0 4
100605: PUSH
100606: LD_INT 1
100608: ARRAY
100609: PPUSH
100610: CALL_OW 255
100614: ST_TO_ADDR
// if flags then
100615: LD_VAR 0 6
100619: IFFALSE 100763
// begin f_ignore_area := flags [ 1 ] ;
100621: LD_ADDR_VAR 0 17
100625: PUSH
100626: LD_VAR 0 6
100630: PUSH
100631: LD_INT 1
100633: ARRAY
100634: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100635: LD_ADDR_VAR 0 18
100639: PUSH
100640: LD_VAR 0 6
100644: PUSH
100645: LD_INT 2
100647: ARRAY
100648: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100649: LD_ADDR_VAR 0 19
100653: PUSH
100654: LD_VAR 0 6
100658: PUSH
100659: LD_INT 3
100661: ARRAY
100662: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100663: LD_ADDR_VAR 0 20
100667: PUSH
100668: LD_VAR 0 6
100672: PUSH
100673: LD_INT 4
100675: ARRAY
100676: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100677: LD_ADDR_VAR 0 21
100681: PUSH
100682: LD_VAR 0 6
100686: PUSH
100687: LD_INT 5
100689: ARRAY
100690: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100691: LD_ADDR_VAR 0 22
100695: PUSH
100696: LD_VAR 0 6
100700: PUSH
100701: LD_INT 6
100703: ARRAY
100704: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100705: LD_ADDR_VAR 0 23
100709: PUSH
100710: LD_VAR 0 6
100714: PUSH
100715: LD_INT 7
100717: ARRAY
100718: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100719: LD_ADDR_VAR 0 24
100723: PUSH
100724: LD_VAR 0 6
100728: PUSH
100729: LD_INT 8
100731: ARRAY
100732: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100733: LD_ADDR_VAR 0 25
100737: PUSH
100738: LD_VAR 0 6
100742: PUSH
100743: LD_INT 9
100745: ARRAY
100746: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100747: LD_ADDR_VAR 0 26
100751: PUSH
100752: LD_VAR 0 6
100756: PUSH
100757: LD_INT 10
100759: ARRAY
100760: ST_TO_ADDR
// end else
100761: GO 100843
// begin f_ignore_area := false ;
100763: LD_ADDR_VAR 0 17
100767: PUSH
100768: LD_INT 0
100770: ST_TO_ADDR
// f_capture := false ;
100771: LD_ADDR_VAR 0 18
100775: PUSH
100776: LD_INT 0
100778: ST_TO_ADDR
// f_ignore_civ := false ;
100779: LD_ADDR_VAR 0 19
100783: PUSH
100784: LD_INT 0
100786: ST_TO_ADDR
// f_murder := false ;
100787: LD_ADDR_VAR 0 20
100791: PUSH
100792: LD_INT 0
100794: ST_TO_ADDR
// f_mines := false ;
100795: LD_ADDR_VAR 0 21
100799: PUSH
100800: LD_INT 0
100802: ST_TO_ADDR
// f_repair := false ;
100803: LD_ADDR_VAR 0 22
100807: PUSH
100808: LD_INT 0
100810: ST_TO_ADDR
// f_heal := false ;
100811: LD_ADDR_VAR 0 23
100815: PUSH
100816: LD_INT 0
100818: ST_TO_ADDR
// f_spacetime := false ;
100819: LD_ADDR_VAR 0 24
100823: PUSH
100824: LD_INT 0
100826: ST_TO_ADDR
// f_attack_depot := false ;
100827: LD_ADDR_VAR 0 25
100831: PUSH
100832: LD_INT 0
100834: ST_TO_ADDR
// f_crawl := false ;
100835: LD_ADDR_VAR 0 26
100839: PUSH
100840: LD_INT 0
100842: ST_TO_ADDR
// end ; if f_heal then
100843: LD_VAR 0 23
100847: IFFALSE 100874
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100849: LD_ADDR_VAR 0 31
100853: PUSH
100854: LD_VAR 0 4
100858: PPUSH
100859: LD_INT 25
100861: PUSH
100862: LD_INT 4
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: PPUSH
100869: CALL_OW 72
100873: ST_TO_ADDR
// if f_repair then
100874: LD_VAR 0 22
100878: IFFALSE 100905
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100880: LD_ADDR_VAR 0 33
100884: PUSH
100885: LD_VAR 0 4
100889: PPUSH
100890: LD_INT 25
100892: PUSH
100893: LD_INT 3
100895: PUSH
100896: EMPTY
100897: LIST
100898: LIST
100899: PPUSH
100900: CALL_OW 72
100904: ST_TO_ADDR
// units_path := [ ] ;
100905: LD_ADDR_VAR 0 16
100909: PUSH
100910: EMPTY
100911: ST_TO_ADDR
// for i = 1 to group do
100912: LD_ADDR_VAR 0 7
100916: PUSH
100917: DOUBLE
100918: LD_INT 1
100920: DEC
100921: ST_TO_ADDR
100922: LD_VAR 0 4
100926: PUSH
100927: FOR_TO
100928: IFFALSE 100957
// units_path := Replace ( units_path , i , path ) ;
100930: LD_ADDR_VAR 0 16
100934: PUSH
100935: LD_VAR 0 16
100939: PPUSH
100940: LD_VAR 0 7
100944: PPUSH
100945: LD_VAR 0 5
100949: PPUSH
100950: CALL_OW 1
100954: ST_TO_ADDR
100955: GO 100927
100957: POP
100958: POP
// repeat for i = group downto 1 do
100959: LD_ADDR_VAR 0 7
100963: PUSH
100964: DOUBLE
100965: LD_VAR 0 4
100969: INC
100970: ST_TO_ADDR
100971: LD_INT 1
100973: PUSH
100974: FOR_DOWNTO
100975: IFFALSE 105097
// begin wait ( 5 ) ;
100977: LD_INT 5
100979: PPUSH
100980: CALL_OW 67
// tmp := [ ] ;
100984: LD_ADDR_VAR 0 14
100988: PUSH
100989: EMPTY
100990: ST_TO_ADDR
// attacking := false ;
100991: LD_ADDR_VAR 0 29
100995: PUSH
100996: LD_INT 0
100998: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100999: LD_VAR 0 4
101003: PUSH
101004: LD_VAR 0 7
101008: ARRAY
101009: PPUSH
101010: CALL_OW 301
101014: PUSH
101015: LD_VAR 0 4
101019: PUSH
101020: LD_VAR 0 7
101024: ARRAY
101025: NOT
101026: OR
101027: IFFALSE 101136
// begin if GetType ( group [ i ] ) = unit_human then
101029: LD_VAR 0 4
101033: PUSH
101034: LD_VAR 0 7
101038: ARRAY
101039: PPUSH
101040: CALL_OW 247
101044: PUSH
101045: LD_INT 1
101047: EQUAL
101048: IFFALSE 101094
// begin to_heal := to_heal diff group [ i ] ;
101050: LD_ADDR_VAR 0 30
101054: PUSH
101055: LD_VAR 0 30
101059: PUSH
101060: LD_VAR 0 4
101064: PUSH
101065: LD_VAR 0 7
101069: ARRAY
101070: DIFF
101071: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101072: LD_ADDR_VAR 0 31
101076: PUSH
101077: LD_VAR 0 31
101081: PUSH
101082: LD_VAR 0 4
101086: PUSH
101087: LD_VAR 0 7
101091: ARRAY
101092: DIFF
101093: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101094: LD_ADDR_VAR 0 4
101098: PUSH
101099: LD_VAR 0 4
101103: PPUSH
101104: LD_VAR 0 7
101108: PPUSH
101109: CALL_OW 3
101113: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101114: LD_ADDR_VAR 0 16
101118: PUSH
101119: LD_VAR 0 16
101123: PPUSH
101124: LD_VAR 0 7
101128: PPUSH
101129: CALL_OW 3
101133: ST_TO_ADDR
// continue ;
101134: GO 100974
// end ; if f_repair then
101136: LD_VAR 0 22
101140: IFFALSE 101629
// begin if GetType ( group [ i ] ) = unit_vehicle then
101142: LD_VAR 0 4
101146: PUSH
101147: LD_VAR 0 7
101151: ARRAY
101152: PPUSH
101153: CALL_OW 247
101157: PUSH
101158: LD_INT 2
101160: EQUAL
101161: IFFALSE 101351
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101163: LD_VAR 0 4
101167: PUSH
101168: LD_VAR 0 7
101172: ARRAY
101173: PPUSH
101174: CALL_OW 256
101178: PUSH
101179: LD_INT 700
101181: LESS
101182: PUSH
101183: LD_VAR 0 4
101187: PUSH
101188: LD_VAR 0 7
101192: ARRAY
101193: PUSH
101194: LD_VAR 0 32
101198: IN
101199: NOT
101200: AND
101201: IFFALSE 101225
// to_repair := to_repair union group [ i ] ;
101203: LD_ADDR_VAR 0 32
101207: PUSH
101208: LD_VAR 0 32
101212: PUSH
101213: LD_VAR 0 4
101217: PUSH
101218: LD_VAR 0 7
101222: ARRAY
101223: UNION
101224: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101225: LD_VAR 0 4
101229: PUSH
101230: LD_VAR 0 7
101234: ARRAY
101235: PPUSH
101236: CALL_OW 256
101240: PUSH
101241: LD_INT 1000
101243: EQUAL
101244: PUSH
101245: LD_VAR 0 4
101249: PUSH
101250: LD_VAR 0 7
101254: ARRAY
101255: PUSH
101256: LD_VAR 0 32
101260: IN
101261: AND
101262: IFFALSE 101286
// to_repair := to_repair diff group [ i ] ;
101264: LD_ADDR_VAR 0 32
101268: PUSH
101269: LD_VAR 0 32
101273: PUSH
101274: LD_VAR 0 4
101278: PUSH
101279: LD_VAR 0 7
101283: ARRAY
101284: DIFF
101285: ST_TO_ADDR
// if group [ i ] in to_repair then
101286: LD_VAR 0 4
101290: PUSH
101291: LD_VAR 0 7
101295: ARRAY
101296: PUSH
101297: LD_VAR 0 32
101301: IN
101302: IFFALSE 101349
// begin if not IsInArea ( group [ i ] , f_repair ) then
101304: LD_VAR 0 4
101308: PUSH
101309: LD_VAR 0 7
101313: ARRAY
101314: PPUSH
101315: LD_VAR 0 22
101319: PPUSH
101320: CALL_OW 308
101324: NOT
101325: IFFALSE 101347
// ComMoveToArea ( group [ i ] , f_repair ) ;
101327: LD_VAR 0 4
101331: PUSH
101332: LD_VAR 0 7
101336: ARRAY
101337: PPUSH
101338: LD_VAR 0 22
101342: PPUSH
101343: CALL_OW 113
// continue ;
101347: GO 100974
// end ; end else
101349: GO 101629
// if group [ i ] in repairs then
101351: LD_VAR 0 4
101355: PUSH
101356: LD_VAR 0 7
101360: ARRAY
101361: PUSH
101362: LD_VAR 0 33
101366: IN
101367: IFFALSE 101629
// begin if IsInUnit ( group [ i ] ) then
101369: LD_VAR 0 4
101373: PUSH
101374: LD_VAR 0 7
101378: ARRAY
101379: PPUSH
101380: CALL_OW 310
101384: IFFALSE 101452
// begin z := IsInUnit ( group [ i ] ) ;
101386: LD_ADDR_VAR 0 13
101390: PUSH
101391: LD_VAR 0 4
101395: PUSH
101396: LD_VAR 0 7
101400: ARRAY
101401: PPUSH
101402: CALL_OW 310
101406: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101407: LD_VAR 0 13
101411: PUSH
101412: LD_VAR 0 32
101416: IN
101417: PUSH
101418: LD_VAR 0 13
101422: PPUSH
101423: LD_VAR 0 22
101427: PPUSH
101428: CALL_OW 308
101432: AND
101433: IFFALSE 101450
// ComExitVehicle ( group [ i ] ) ;
101435: LD_VAR 0 4
101439: PUSH
101440: LD_VAR 0 7
101444: ARRAY
101445: PPUSH
101446: CALL_OW 121
// end else
101450: GO 101629
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101452: LD_ADDR_VAR 0 13
101456: PUSH
101457: LD_VAR 0 4
101461: PPUSH
101462: LD_INT 95
101464: PUSH
101465: LD_VAR 0 22
101469: PUSH
101470: EMPTY
101471: LIST
101472: LIST
101473: PUSH
101474: LD_INT 58
101476: PUSH
101477: EMPTY
101478: LIST
101479: PUSH
101480: EMPTY
101481: LIST
101482: LIST
101483: PPUSH
101484: CALL_OW 72
101488: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101489: LD_VAR 0 4
101493: PUSH
101494: LD_VAR 0 7
101498: ARRAY
101499: PPUSH
101500: CALL_OW 314
101504: NOT
101505: IFFALSE 101627
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101507: LD_ADDR_VAR 0 10
101511: PUSH
101512: LD_VAR 0 13
101516: PPUSH
101517: LD_VAR 0 4
101521: PUSH
101522: LD_VAR 0 7
101526: ARRAY
101527: PPUSH
101528: CALL_OW 74
101532: ST_TO_ADDR
// if not x then
101533: LD_VAR 0 10
101537: NOT
101538: IFFALSE 101542
// continue ;
101540: GO 100974
// if GetLives ( x ) < 1000 then
101542: LD_VAR 0 10
101546: PPUSH
101547: CALL_OW 256
101551: PUSH
101552: LD_INT 1000
101554: LESS
101555: IFFALSE 101579
// ComRepairVehicle ( group [ i ] , x ) else
101557: LD_VAR 0 4
101561: PUSH
101562: LD_VAR 0 7
101566: ARRAY
101567: PPUSH
101568: LD_VAR 0 10
101572: PPUSH
101573: CALL_OW 129
101577: GO 101627
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101579: LD_VAR 0 23
101583: PUSH
101584: LD_VAR 0 4
101588: PUSH
101589: LD_VAR 0 7
101593: ARRAY
101594: PPUSH
101595: CALL_OW 256
101599: PUSH
101600: LD_INT 1000
101602: LESS
101603: AND
101604: NOT
101605: IFFALSE 101627
// ComEnterUnit ( group [ i ] , x ) ;
101607: LD_VAR 0 4
101611: PUSH
101612: LD_VAR 0 7
101616: ARRAY
101617: PPUSH
101618: LD_VAR 0 10
101622: PPUSH
101623: CALL_OW 120
// end ; continue ;
101627: GO 100974
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101629: LD_VAR 0 23
101633: PUSH
101634: LD_VAR 0 4
101638: PUSH
101639: LD_VAR 0 7
101643: ARRAY
101644: PPUSH
101645: CALL_OW 247
101649: PUSH
101650: LD_INT 1
101652: EQUAL
101653: AND
101654: IFFALSE 102132
// begin if group [ i ] in healers then
101656: LD_VAR 0 4
101660: PUSH
101661: LD_VAR 0 7
101665: ARRAY
101666: PUSH
101667: LD_VAR 0 31
101671: IN
101672: IFFALSE 101945
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101674: LD_VAR 0 4
101678: PUSH
101679: LD_VAR 0 7
101683: ARRAY
101684: PPUSH
101685: LD_VAR 0 23
101689: PPUSH
101690: CALL_OW 308
101694: NOT
101695: PUSH
101696: LD_VAR 0 4
101700: PUSH
101701: LD_VAR 0 7
101705: ARRAY
101706: PPUSH
101707: CALL_OW 314
101711: NOT
101712: AND
101713: IFFALSE 101737
// ComMoveToArea ( group [ i ] , f_heal ) else
101715: LD_VAR 0 4
101719: PUSH
101720: LD_VAR 0 7
101724: ARRAY
101725: PPUSH
101726: LD_VAR 0 23
101730: PPUSH
101731: CALL_OW 113
101735: GO 101943
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101737: LD_VAR 0 4
101741: PUSH
101742: LD_VAR 0 7
101746: ARRAY
101747: PPUSH
101748: CALL 100355 0 1
101752: PPUSH
101753: CALL_OW 256
101757: PUSH
101758: LD_INT 1000
101760: EQUAL
101761: IFFALSE 101780
// ComStop ( group [ i ] ) else
101763: LD_VAR 0 4
101767: PUSH
101768: LD_VAR 0 7
101772: ARRAY
101773: PPUSH
101774: CALL_OW 141
101778: GO 101943
// if not HasTask ( group [ i ] ) and to_heal then
101780: LD_VAR 0 4
101784: PUSH
101785: LD_VAR 0 7
101789: ARRAY
101790: PPUSH
101791: CALL_OW 314
101795: NOT
101796: PUSH
101797: LD_VAR 0 30
101801: AND
101802: IFFALSE 101943
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101804: LD_ADDR_VAR 0 13
101808: PUSH
101809: LD_VAR 0 30
101813: PPUSH
101814: LD_INT 3
101816: PUSH
101817: LD_INT 54
101819: PUSH
101820: EMPTY
101821: LIST
101822: PUSH
101823: EMPTY
101824: LIST
101825: LIST
101826: PPUSH
101827: CALL_OW 72
101831: PPUSH
101832: LD_VAR 0 4
101836: PUSH
101837: LD_VAR 0 7
101841: ARRAY
101842: PPUSH
101843: CALL_OW 74
101847: ST_TO_ADDR
// if z then
101848: LD_VAR 0 13
101852: IFFALSE 101943
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101854: LD_INT 91
101856: PUSH
101857: LD_VAR 0 13
101861: PUSH
101862: LD_INT 10
101864: PUSH
101865: EMPTY
101866: LIST
101867: LIST
101868: LIST
101869: PUSH
101870: LD_INT 81
101872: PUSH
101873: LD_VAR 0 13
101877: PPUSH
101878: CALL_OW 255
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: PUSH
101887: EMPTY
101888: LIST
101889: LIST
101890: PPUSH
101891: CALL_OW 69
101895: PUSH
101896: LD_INT 0
101898: EQUAL
101899: IFFALSE 101923
// ComHeal ( group [ i ] , z ) else
101901: LD_VAR 0 4
101905: PUSH
101906: LD_VAR 0 7
101910: ARRAY
101911: PPUSH
101912: LD_VAR 0 13
101916: PPUSH
101917: CALL_OW 128
101921: GO 101943
// ComMoveToArea ( group [ i ] , f_heal ) ;
101923: LD_VAR 0 4
101927: PUSH
101928: LD_VAR 0 7
101932: ARRAY
101933: PPUSH
101934: LD_VAR 0 23
101938: PPUSH
101939: CALL_OW 113
// end ; continue ;
101943: GO 100974
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101945: LD_VAR 0 4
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PPUSH
101956: CALL_OW 256
101960: PUSH
101961: LD_INT 700
101963: LESS
101964: PUSH
101965: LD_VAR 0 4
101969: PUSH
101970: LD_VAR 0 7
101974: ARRAY
101975: PUSH
101976: LD_VAR 0 30
101980: IN
101981: NOT
101982: AND
101983: IFFALSE 102007
// to_heal := to_heal union group [ i ] ;
101985: LD_ADDR_VAR 0 30
101989: PUSH
101990: LD_VAR 0 30
101994: PUSH
101995: LD_VAR 0 4
101999: PUSH
102000: LD_VAR 0 7
102004: ARRAY
102005: UNION
102006: ST_TO_ADDR
// if group [ i ] in to_heal then
102007: LD_VAR 0 4
102011: PUSH
102012: LD_VAR 0 7
102016: ARRAY
102017: PUSH
102018: LD_VAR 0 30
102022: IN
102023: IFFALSE 102132
// begin if GetLives ( group [ i ] ) = 1000 then
102025: LD_VAR 0 4
102029: PUSH
102030: LD_VAR 0 7
102034: ARRAY
102035: PPUSH
102036: CALL_OW 256
102040: PUSH
102041: LD_INT 1000
102043: EQUAL
102044: IFFALSE 102070
// to_heal := to_heal diff group [ i ] else
102046: LD_ADDR_VAR 0 30
102050: PUSH
102051: LD_VAR 0 30
102055: PUSH
102056: LD_VAR 0 4
102060: PUSH
102061: LD_VAR 0 7
102065: ARRAY
102066: DIFF
102067: ST_TO_ADDR
102068: GO 102132
// begin if not IsInArea ( group [ i ] , to_heal ) then
102070: LD_VAR 0 4
102074: PUSH
102075: LD_VAR 0 7
102079: ARRAY
102080: PPUSH
102081: LD_VAR 0 30
102085: PPUSH
102086: CALL_OW 308
102090: NOT
102091: IFFALSE 102115
// ComMoveToArea ( group [ i ] , f_heal ) else
102093: LD_VAR 0 4
102097: PUSH
102098: LD_VAR 0 7
102102: ARRAY
102103: PPUSH
102104: LD_VAR 0 23
102108: PPUSH
102109: CALL_OW 113
102113: GO 102130
// ComHold ( group [ i ] ) ;
102115: LD_VAR 0 4
102119: PUSH
102120: LD_VAR 0 7
102124: ARRAY
102125: PPUSH
102126: CALL_OW 140
// continue ;
102130: GO 100974
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102132: LD_VAR 0 4
102136: PUSH
102137: LD_VAR 0 7
102141: ARRAY
102142: PPUSH
102143: LD_INT 10
102145: PPUSH
102146: CALL 98775 0 2
102150: NOT
102151: PUSH
102152: LD_VAR 0 16
102156: PUSH
102157: LD_VAR 0 7
102161: ARRAY
102162: PUSH
102163: EMPTY
102164: EQUAL
102165: NOT
102166: AND
102167: IFFALSE 102433
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102169: LD_VAR 0 4
102173: PUSH
102174: LD_VAR 0 7
102178: ARRAY
102179: PPUSH
102180: CALL_OW 262
102184: PUSH
102185: LD_INT 1
102187: PUSH
102188: LD_INT 2
102190: PUSH
102191: EMPTY
102192: LIST
102193: LIST
102194: IN
102195: IFFALSE 102236
// if GetFuel ( group [ i ] ) < 10 then
102197: LD_VAR 0 4
102201: PUSH
102202: LD_VAR 0 7
102206: ARRAY
102207: PPUSH
102208: CALL_OW 261
102212: PUSH
102213: LD_INT 10
102215: LESS
102216: IFFALSE 102236
// SetFuel ( group [ i ] , 12 ) ;
102218: LD_VAR 0 4
102222: PUSH
102223: LD_VAR 0 7
102227: ARRAY
102228: PPUSH
102229: LD_INT 12
102231: PPUSH
102232: CALL_OW 240
// if units_path [ i ] then
102236: LD_VAR 0 16
102240: PUSH
102241: LD_VAR 0 7
102245: ARRAY
102246: IFFALSE 102431
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102248: LD_VAR 0 4
102252: PUSH
102253: LD_VAR 0 7
102257: ARRAY
102258: PPUSH
102259: LD_VAR 0 16
102263: PUSH
102264: LD_VAR 0 7
102268: ARRAY
102269: PUSH
102270: LD_INT 1
102272: ARRAY
102273: PUSH
102274: LD_INT 1
102276: ARRAY
102277: PPUSH
102278: LD_VAR 0 16
102282: PUSH
102283: LD_VAR 0 7
102287: ARRAY
102288: PUSH
102289: LD_INT 1
102291: ARRAY
102292: PUSH
102293: LD_INT 2
102295: ARRAY
102296: PPUSH
102297: CALL_OW 297
102301: PUSH
102302: LD_INT 6
102304: GREATER
102305: IFFALSE 102380
// begin if not HasTask ( group [ i ] ) then
102307: LD_VAR 0 4
102311: PUSH
102312: LD_VAR 0 7
102316: ARRAY
102317: PPUSH
102318: CALL_OW 314
102322: NOT
102323: IFFALSE 102378
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102325: LD_VAR 0 4
102329: PUSH
102330: LD_VAR 0 7
102334: ARRAY
102335: PPUSH
102336: LD_VAR 0 16
102340: PUSH
102341: LD_VAR 0 7
102345: ARRAY
102346: PUSH
102347: LD_INT 1
102349: ARRAY
102350: PUSH
102351: LD_INT 1
102353: ARRAY
102354: PPUSH
102355: LD_VAR 0 16
102359: PUSH
102360: LD_VAR 0 7
102364: ARRAY
102365: PUSH
102366: LD_INT 1
102368: ARRAY
102369: PUSH
102370: LD_INT 2
102372: ARRAY
102373: PPUSH
102374: CALL_OW 114
// end else
102378: GO 102431
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102380: LD_ADDR_VAR 0 15
102384: PUSH
102385: LD_VAR 0 16
102389: PUSH
102390: LD_VAR 0 7
102394: ARRAY
102395: PPUSH
102396: LD_INT 1
102398: PPUSH
102399: CALL_OW 3
102403: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102404: LD_ADDR_VAR 0 16
102408: PUSH
102409: LD_VAR 0 16
102413: PPUSH
102414: LD_VAR 0 7
102418: PPUSH
102419: LD_VAR 0 15
102423: PPUSH
102424: CALL_OW 1
102428: ST_TO_ADDR
// continue ;
102429: GO 100974
// end ; end ; end else
102431: GO 105095
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102433: LD_ADDR_VAR 0 14
102437: PUSH
102438: LD_INT 81
102440: PUSH
102441: LD_VAR 0 4
102445: PUSH
102446: LD_VAR 0 7
102450: ARRAY
102451: PPUSH
102452: CALL_OW 255
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PPUSH
102461: CALL_OW 69
102465: ST_TO_ADDR
// if not tmp then
102466: LD_VAR 0 14
102470: NOT
102471: IFFALSE 102475
// continue ;
102473: GO 100974
// if f_ignore_area then
102475: LD_VAR 0 17
102479: IFFALSE 102567
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102481: LD_ADDR_VAR 0 15
102485: PUSH
102486: LD_VAR 0 14
102490: PPUSH
102491: LD_INT 3
102493: PUSH
102494: LD_INT 92
102496: PUSH
102497: LD_VAR 0 17
102501: PUSH
102502: LD_INT 1
102504: ARRAY
102505: PUSH
102506: LD_VAR 0 17
102510: PUSH
102511: LD_INT 2
102513: ARRAY
102514: PUSH
102515: LD_VAR 0 17
102519: PUSH
102520: LD_INT 3
102522: ARRAY
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: LIST
102528: LIST
102529: PUSH
102530: EMPTY
102531: LIST
102532: LIST
102533: PPUSH
102534: CALL_OW 72
102538: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102539: LD_VAR 0 14
102543: PUSH
102544: LD_VAR 0 15
102548: DIFF
102549: IFFALSE 102567
// tmp := tmp diff tmp2 ;
102551: LD_ADDR_VAR 0 14
102555: PUSH
102556: LD_VAR 0 14
102560: PUSH
102561: LD_VAR 0 15
102565: DIFF
102566: ST_TO_ADDR
// end ; if not f_murder then
102567: LD_VAR 0 20
102571: NOT
102572: IFFALSE 102630
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102574: LD_ADDR_VAR 0 15
102578: PUSH
102579: LD_VAR 0 14
102583: PPUSH
102584: LD_INT 3
102586: PUSH
102587: LD_INT 50
102589: PUSH
102590: EMPTY
102591: LIST
102592: PUSH
102593: EMPTY
102594: LIST
102595: LIST
102596: PPUSH
102597: CALL_OW 72
102601: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102602: LD_VAR 0 14
102606: PUSH
102607: LD_VAR 0 15
102611: DIFF
102612: IFFALSE 102630
// tmp := tmp diff tmp2 ;
102614: LD_ADDR_VAR 0 14
102618: PUSH
102619: LD_VAR 0 14
102623: PUSH
102624: LD_VAR 0 15
102628: DIFF
102629: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102630: LD_ADDR_VAR 0 14
102634: PUSH
102635: LD_VAR 0 4
102639: PUSH
102640: LD_VAR 0 7
102644: ARRAY
102645: PPUSH
102646: LD_VAR 0 14
102650: PPUSH
102651: LD_INT 1
102653: PPUSH
102654: LD_INT 1
102656: PPUSH
102657: CALL 72418 0 4
102661: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102662: LD_VAR 0 4
102666: PUSH
102667: LD_VAR 0 7
102671: ARRAY
102672: PPUSH
102673: CALL_OW 257
102677: PUSH
102678: LD_INT 1
102680: EQUAL
102681: IFFALSE 103129
// begin if WantPlant ( group [ i ] ) then
102683: LD_VAR 0 4
102687: PUSH
102688: LD_VAR 0 7
102692: ARRAY
102693: PPUSH
102694: CALL 71919 0 1
102698: IFFALSE 102702
// continue ;
102700: GO 100974
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102702: LD_VAR 0 18
102706: PUSH
102707: LD_VAR 0 4
102711: PUSH
102712: LD_VAR 0 7
102716: ARRAY
102717: PPUSH
102718: CALL_OW 310
102722: NOT
102723: AND
102724: PUSH
102725: LD_VAR 0 14
102729: PUSH
102730: LD_INT 1
102732: ARRAY
102733: PUSH
102734: LD_VAR 0 14
102738: PPUSH
102739: LD_INT 21
102741: PUSH
102742: LD_INT 2
102744: PUSH
102745: EMPTY
102746: LIST
102747: LIST
102748: PUSH
102749: LD_INT 58
102751: PUSH
102752: EMPTY
102753: LIST
102754: PUSH
102755: EMPTY
102756: LIST
102757: LIST
102758: PPUSH
102759: CALL_OW 72
102763: IN
102764: AND
102765: IFFALSE 102801
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102767: LD_VAR 0 4
102771: PUSH
102772: LD_VAR 0 7
102776: ARRAY
102777: PPUSH
102778: LD_VAR 0 14
102782: PUSH
102783: LD_INT 1
102785: ARRAY
102786: PPUSH
102787: CALL_OW 120
// attacking := true ;
102791: LD_ADDR_VAR 0 29
102795: PUSH
102796: LD_INT 1
102798: ST_TO_ADDR
// continue ;
102799: GO 100974
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102801: LD_VAR 0 26
102805: PUSH
102806: LD_VAR 0 4
102810: PUSH
102811: LD_VAR 0 7
102815: ARRAY
102816: PPUSH
102817: CALL_OW 257
102821: PUSH
102822: LD_INT 1
102824: EQUAL
102825: AND
102826: PUSH
102827: LD_VAR 0 4
102831: PUSH
102832: LD_VAR 0 7
102836: ARRAY
102837: PPUSH
102838: CALL_OW 256
102842: PUSH
102843: LD_INT 800
102845: LESS
102846: AND
102847: PUSH
102848: LD_VAR 0 4
102852: PUSH
102853: LD_VAR 0 7
102857: ARRAY
102858: PPUSH
102859: CALL_OW 318
102863: NOT
102864: AND
102865: IFFALSE 102882
// ComCrawl ( group [ i ] ) ;
102867: LD_VAR 0 4
102871: PUSH
102872: LD_VAR 0 7
102876: ARRAY
102877: PPUSH
102878: CALL_OW 137
// if f_mines then
102882: LD_VAR 0 21
102886: IFFALSE 103129
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102888: LD_VAR 0 14
102892: PUSH
102893: LD_INT 1
102895: ARRAY
102896: PPUSH
102897: CALL_OW 247
102901: PUSH
102902: LD_INT 3
102904: EQUAL
102905: PUSH
102906: LD_VAR 0 14
102910: PUSH
102911: LD_INT 1
102913: ARRAY
102914: PUSH
102915: LD_VAR 0 27
102919: IN
102920: NOT
102921: AND
102922: IFFALSE 103129
// begin x := GetX ( tmp [ 1 ] ) ;
102924: LD_ADDR_VAR 0 10
102928: PUSH
102929: LD_VAR 0 14
102933: PUSH
102934: LD_INT 1
102936: ARRAY
102937: PPUSH
102938: CALL_OW 250
102942: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102943: LD_ADDR_VAR 0 11
102947: PUSH
102948: LD_VAR 0 14
102952: PUSH
102953: LD_INT 1
102955: ARRAY
102956: PPUSH
102957: CALL_OW 251
102961: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102962: LD_ADDR_VAR 0 12
102966: PUSH
102967: LD_VAR 0 4
102971: PUSH
102972: LD_VAR 0 7
102976: ARRAY
102977: PPUSH
102978: CALL 98860 0 1
102982: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102983: LD_VAR 0 4
102987: PUSH
102988: LD_VAR 0 7
102992: ARRAY
102993: PPUSH
102994: LD_VAR 0 10
102998: PPUSH
102999: LD_VAR 0 11
103003: PPUSH
103004: LD_VAR 0 14
103008: PUSH
103009: LD_INT 1
103011: ARRAY
103012: PPUSH
103013: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103017: LD_VAR 0 4
103021: PUSH
103022: LD_VAR 0 7
103026: ARRAY
103027: PPUSH
103028: LD_VAR 0 10
103032: PPUSH
103033: LD_VAR 0 12
103037: PPUSH
103038: LD_INT 7
103040: PPUSH
103041: CALL_OW 272
103045: PPUSH
103046: LD_VAR 0 11
103050: PPUSH
103051: LD_VAR 0 12
103055: PPUSH
103056: LD_INT 7
103058: PPUSH
103059: CALL_OW 273
103063: PPUSH
103064: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103068: LD_VAR 0 4
103072: PUSH
103073: LD_VAR 0 7
103077: ARRAY
103078: PPUSH
103079: LD_INT 71
103081: PPUSH
103082: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103086: LD_ADDR_VAR 0 27
103090: PUSH
103091: LD_VAR 0 27
103095: PPUSH
103096: LD_VAR 0 27
103100: PUSH
103101: LD_INT 1
103103: PLUS
103104: PPUSH
103105: LD_VAR 0 14
103109: PUSH
103110: LD_INT 1
103112: ARRAY
103113: PPUSH
103114: CALL_OW 1
103118: ST_TO_ADDR
// attacking := true ;
103119: LD_ADDR_VAR 0 29
103123: PUSH
103124: LD_INT 1
103126: ST_TO_ADDR
// continue ;
103127: GO 100974
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103129: LD_VAR 0 4
103133: PUSH
103134: LD_VAR 0 7
103138: ARRAY
103139: PPUSH
103140: CALL_OW 257
103144: PUSH
103145: LD_INT 17
103147: EQUAL
103148: PUSH
103149: LD_VAR 0 4
103153: PUSH
103154: LD_VAR 0 7
103158: ARRAY
103159: PPUSH
103160: CALL_OW 110
103164: PUSH
103165: LD_INT 71
103167: EQUAL
103168: NOT
103169: AND
103170: IFFALSE 103316
// begin attacking := false ;
103172: LD_ADDR_VAR 0 29
103176: PUSH
103177: LD_INT 0
103179: ST_TO_ADDR
// k := 5 ;
103180: LD_ADDR_VAR 0 9
103184: PUSH
103185: LD_INT 5
103187: ST_TO_ADDR
// if tmp < k then
103188: LD_VAR 0 14
103192: PUSH
103193: LD_VAR 0 9
103197: LESS
103198: IFFALSE 103210
// k := tmp ;
103200: LD_ADDR_VAR 0 9
103204: PUSH
103205: LD_VAR 0 14
103209: ST_TO_ADDR
// for j = 1 to k do
103210: LD_ADDR_VAR 0 8
103214: PUSH
103215: DOUBLE
103216: LD_INT 1
103218: DEC
103219: ST_TO_ADDR
103220: LD_VAR 0 9
103224: PUSH
103225: FOR_TO
103226: IFFALSE 103314
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103228: LD_VAR 0 14
103232: PUSH
103233: LD_VAR 0 8
103237: ARRAY
103238: PUSH
103239: LD_VAR 0 14
103243: PPUSH
103244: LD_INT 58
103246: PUSH
103247: EMPTY
103248: LIST
103249: PPUSH
103250: CALL_OW 72
103254: IN
103255: NOT
103256: IFFALSE 103312
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103258: LD_VAR 0 4
103262: PUSH
103263: LD_VAR 0 7
103267: ARRAY
103268: PPUSH
103269: LD_VAR 0 14
103273: PUSH
103274: LD_VAR 0 8
103278: ARRAY
103279: PPUSH
103280: CALL_OW 115
// attacking := true ;
103284: LD_ADDR_VAR 0 29
103288: PUSH
103289: LD_INT 1
103291: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103292: LD_VAR 0 4
103296: PUSH
103297: LD_VAR 0 7
103301: ARRAY
103302: PPUSH
103303: LD_INT 71
103305: PPUSH
103306: CALL_OW 109
// continue ;
103310: GO 103225
// end ; end ;
103312: GO 103225
103314: POP
103315: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103316: LD_VAR 0 4
103320: PUSH
103321: LD_VAR 0 7
103325: ARRAY
103326: PPUSH
103327: CALL_OW 257
103331: PUSH
103332: LD_INT 8
103334: EQUAL
103335: PUSH
103336: LD_VAR 0 4
103340: PUSH
103341: LD_VAR 0 7
103345: ARRAY
103346: PPUSH
103347: CALL_OW 264
103351: PUSH
103352: LD_INT 28
103354: PUSH
103355: LD_INT 45
103357: PUSH
103358: LD_INT 7
103360: PUSH
103361: LD_INT 47
103363: PUSH
103364: EMPTY
103365: LIST
103366: LIST
103367: LIST
103368: LIST
103369: IN
103370: OR
103371: IFFALSE 103627
// begin attacking := false ;
103373: LD_ADDR_VAR 0 29
103377: PUSH
103378: LD_INT 0
103380: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103381: LD_VAR 0 14
103385: PUSH
103386: LD_INT 1
103388: ARRAY
103389: PPUSH
103390: CALL_OW 266
103394: PUSH
103395: LD_INT 32
103397: PUSH
103398: LD_INT 31
103400: PUSH
103401: LD_INT 33
103403: PUSH
103404: LD_INT 4
103406: PUSH
103407: LD_INT 5
103409: PUSH
103410: EMPTY
103411: LIST
103412: LIST
103413: LIST
103414: LIST
103415: LIST
103416: IN
103417: IFFALSE 103603
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103419: LD_ADDR_VAR 0 9
103423: PUSH
103424: LD_VAR 0 14
103428: PUSH
103429: LD_INT 1
103431: ARRAY
103432: PPUSH
103433: CALL_OW 266
103437: PPUSH
103438: LD_VAR 0 14
103442: PUSH
103443: LD_INT 1
103445: ARRAY
103446: PPUSH
103447: CALL_OW 250
103451: PPUSH
103452: LD_VAR 0 14
103456: PUSH
103457: LD_INT 1
103459: ARRAY
103460: PPUSH
103461: CALL_OW 251
103465: PPUSH
103466: LD_VAR 0 14
103470: PUSH
103471: LD_INT 1
103473: ARRAY
103474: PPUSH
103475: CALL_OW 254
103479: PPUSH
103480: LD_VAR 0 14
103484: PUSH
103485: LD_INT 1
103487: ARRAY
103488: PPUSH
103489: CALL_OW 248
103493: PPUSH
103494: LD_INT 0
103496: PPUSH
103497: CALL 80230 0 6
103501: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103502: LD_ADDR_VAR 0 8
103506: PUSH
103507: LD_VAR 0 4
103511: PUSH
103512: LD_VAR 0 7
103516: ARRAY
103517: PPUSH
103518: LD_VAR 0 9
103522: PPUSH
103523: CALL 98900 0 2
103527: ST_TO_ADDR
// if j then
103528: LD_VAR 0 8
103532: IFFALSE 103601
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103534: LD_VAR 0 8
103538: PUSH
103539: LD_INT 1
103541: ARRAY
103542: PPUSH
103543: LD_VAR 0 8
103547: PUSH
103548: LD_INT 2
103550: ARRAY
103551: PPUSH
103552: CALL_OW 488
103556: IFFALSE 103601
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103558: LD_VAR 0 4
103562: PUSH
103563: LD_VAR 0 7
103567: ARRAY
103568: PPUSH
103569: LD_VAR 0 8
103573: PUSH
103574: LD_INT 1
103576: ARRAY
103577: PPUSH
103578: LD_VAR 0 8
103582: PUSH
103583: LD_INT 2
103585: ARRAY
103586: PPUSH
103587: CALL_OW 116
// attacking := true ;
103591: LD_ADDR_VAR 0 29
103595: PUSH
103596: LD_INT 1
103598: ST_TO_ADDR
// continue ;
103599: GO 100974
// end ; end else
103601: GO 103627
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103603: LD_VAR 0 4
103607: PUSH
103608: LD_VAR 0 7
103612: ARRAY
103613: PPUSH
103614: LD_VAR 0 14
103618: PUSH
103619: LD_INT 1
103621: ARRAY
103622: PPUSH
103623: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103627: LD_VAR 0 4
103631: PUSH
103632: LD_VAR 0 7
103636: ARRAY
103637: PPUSH
103638: CALL_OW 265
103642: PUSH
103643: LD_INT 11
103645: EQUAL
103646: IFFALSE 103924
// begin k := 10 ;
103648: LD_ADDR_VAR 0 9
103652: PUSH
103653: LD_INT 10
103655: ST_TO_ADDR
// x := 0 ;
103656: LD_ADDR_VAR 0 10
103660: PUSH
103661: LD_INT 0
103663: ST_TO_ADDR
// if tmp < k then
103664: LD_VAR 0 14
103668: PUSH
103669: LD_VAR 0 9
103673: LESS
103674: IFFALSE 103686
// k := tmp ;
103676: LD_ADDR_VAR 0 9
103680: PUSH
103681: LD_VAR 0 14
103685: ST_TO_ADDR
// for j = k downto 1 do
103686: LD_ADDR_VAR 0 8
103690: PUSH
103691: DOUBLE
103692: LD_VAR 0 9
103696: INC
103697: ST_TO_ADDR
103698: LD_INT 1
103700: PUSH
103701: FOR_DOWNTO
103702: IFFALSE 103777
// begin if GetType ( tmp [ j ] ) = unit_human then
103704: LD_VAR 0 14
103708: PUSH
103709: LD_VAR 0 8
103713: ARRAY
103714: PPUSH
103715: CALL_OW 247
103719: PUSH
103720: LD_INT 1
103722: EQUAL
103723: IFFALSE 103775
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103725: LD_VAR 0 4
103729: PUSH
103730: LD_VAR 0 7
103734: ARRAY
103735: PPUSH
103736: LD_VAR 0 14
103740: PUSH
103741: LD_VAR 0 8
103745: ARRAY
103746: PPUSH
103747: CALL 99171 0 2
// x := tmp [ j ] ;
103751: LD_ADDR_VAR 0 10
103755: PUSH
103756: LD_VAR 0 14
103760: PUSH
103761: LD_VAR 0 8
103765: ARRAY
103766: ST_TO_ADDR
// attacking := true ;
103767: LD_ADDR_VAR 0 29
103771: PUSH
103772: LD_INT 1
103774: ST_TO_ADDR
// end ; end ;
103775: GO 103701
103777: POP
103778: POP
// if not x then
103779: LD_VAR 0 10
103783: NOT
103784: IFFALSE 103924
// begin attacking := true ;
103786: LD_ADDR_VAR 0 29
103790: PUSH
103791: LD_INT 1
103793: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103794: LD_VAR 0 4
103798: PUSH
103799: LD_VAR 0 7
103803: ARRAY
103804: PPUSH
103805: CALL_OW 250
103809: PPUSH
103810: LD_VAR 0 4
103814: PUSH
103815: LD_VAR 0 7
103819: ARRAY
103820: PPUSH
103821: CALL_OW 251
103825: PPUSH
103826: CALL_OW 546
103830: PUSH
103831: LD_INT 2
103833: ARRAY
103834: PUSH
103835: LD_VAR 0 14
103839: PUSH
103840: LD_INT 1
103842: ARRAY
103843: PPUSH
103844: CALL_OW 250
103848: PPUSH
103849: LD_VAR 0 14
103853: PUSH
103854: LD_INT 1
103856: ARRAY
103857: PPUSH
103858: CALL_OW 251
103862: PPUSH
103863: CALL_OW 546
103867: PUSH
103868: LD_INT 2
103870: ARRAY
103871: EQUAL
103872: IFFALSE 103900
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103874: LD_VAR 0 4
103878: PUSH
103879: LD_VAR 0 7
103883: ARRAY
103884: PPUSH
103885: LD_VAR 0 14
103889: PUSH
103890: LD_INT 1
103892: ARRAY
103893: PPUSH
103894: CALL 99171 0 2
103898: GO 103924
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103900: LD_VAR 0 4
103904: PUSH
103905: LD_VAR 0 7
103909: ARRAY
103910: PPUSH
103911: LD_VAR 0 14
103915: PUSH
103916: LD_INT 1
103918: ARRAY
103919: PPUSH
103920: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103924: LD_VAR 0 4
103928: PUSH
103929: LD_VAR 0 7
103933: ARRAY
103934: PPUSH
103935: CALL_OW 264
103939: PUSH
103940: LD_INT 29
103942: EQUAL
103943: IFFALSE 104309
// begin if WantsToAttack ( group [ i ] ) in bombed then
103945: LD_VAR 0 4
103949: PUSH
103950: LD_VAR 0 7
103954: ARRAY
103955: PPUSH
103956: CALL_OW 319
103960: PUSH
103961: LD_VAR 0 28
103965: IN
103966: IFFALSE 103970
// continue ;
103968: GO 100974
// k := 8 ;
103970: LD_ADDR_VAR 0 9
103974: PUSH
103975: LD_INT 8
103977: ST_TO_ADDR
// x := 0 ;
103978: LD_ADDR_VAR 0 10
103982: PUSH
103983: LD_INT 0
103985: ST_TO_ADDR
// if tmp < k then
103986: LD_VAR 0 14
103990: PUSH
103991: LD_VAR 0 9
103995: LESS
103996: IFFALSE 104008
// k := tmp ;
103998: LD_ADDR_VAR 0 9
104002: PUSH
104003: LD_VAR 0 14
104007: ST_TO_ADDR
// for j = 1 to k do
104008: LD_ADDR_VAR 0 8
104012: PUSH
104013: DOUBLE
104014: LD_INT 1
104016: DEC
104017: ST_TO_ADDR
104018: LD_VAR 0 9
104022: PUSH
104023: FOR_TO
104024: IFFALSE 104156
// begin if GetType ( tmp [ j ] ) = unit_building then
104026: LD_VAR 0 14
104030: PUSH
104031: LD_VAR 0 8
104035: ARRAY
104036: PPUSH
104037: CALL_OW 247
104041: PUSH
104042: LD_INT 3
104044: EQUAL
104045: IFFALSE 104154
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104047: LD_VAR 0 14
104051: PUSH
104052: LD_VAR 0 8
104056: ARRAY
104057: PUSH
104058: LD_VAR 0 28
104062: IN
104063: NOT
104064: PUSH
104065: LD_VAR 0 14
104069: PUSH
104070: LD_VAR 0 8
104074: ARRAY
104075: PPUSH
104076: CALL_OW 313
104080: AND
104081: IFFALSE 104154
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104083: LD_VAR 0 4
104087: PUSH
104088: LD_VAR 0 7
104092: ARRAY
104093: PPUSH
104094: LD_VAR 0 14
104098: PUSH
104099: LD_VAR 0 8
104103: ARRAY
104104: PPUSH
104105: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104109: LD_ADDR_VAR 0 28
104113: PUSH
104114: LD_VAR 0 28
104118: PPUSH
104119: LD_VAR 0 28
104123: PUSH
104124: LD_INT 1
104126: PLUS
104127: PPUSH
104128: LD_VAR 0 14
104132: PUSH
104133: LD_VAR 0 8
104137: ARRAY
104138: PPUSH
104139: CALL_OW 1
104143: ST_TO_ADDR
// attacking := true ;
104144: LD_ADDR_VAR 0 29
104148: PUSH
104149: LD_INT 1
104151: ST_TO_ADDR
// break ;
104152: GO 104156
// end ; end ;
104154: GO 104023
104156: POP
104157: POP
// if not attacking and f_attack_depot then
104158: LD_VAR 0 29
104162: NOT
104163: PUSH
104164: LD_VAR 0 25
104168: AND
104169: IFFALSE 104264
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104171: LD_ADDR_VAR 0 13
104175: PUSH
104176: LD_VAR 0 14
104180: PPUSH
104181: LD_INT 2
104183: PUSH
104184: LD_INT 30
104186: PUSH
104187: LD_INT 0
104189: PUSH
104190: EMPTY
104191: LIST
104192: LIST
104193: PUSH
104194: LD_INT 30
104196: PUSH
104197: LD_INT 1
104199: PUSH
104200: EMPTY
104201: LIST
104202: LIST
104203: PUSH
104204: EMPTY
104205: LIST
104206: LIST
104207: LIST
104208: PPUSH
104209: CALL_OW 72
104213: ST_TO_ADDR
// if z then
104214: LD_VAR 0 13
104218: IFFALSE 104264
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104220: LD_VAR 0 4
104224: PUSH
104225: LD_VAR 0 7
104229: ARRAY
104230: PPUSH
104231: LD_VAR 0 13
104235: PPUSH
104236: LD_VAR 0 4
104240: PUSH
104241: LD_VAR 0 7
104245: ARRAY
104246: PPUSH
104247: CALL_OW 74
104251: PPUSH
104252: CALL_OW 115
// attacking := true ;
104256: LD_ADDR_VAR 0 29
104260: PUSH
104261: LD_INT 1
104263: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104264: LD_VAR 0 4
104268: PUSH
104269: LD_VAR 0 7
104273: ARRAY
104274: PPUSH
104275: CALL_OW 256
104279: PUSH
104280: LD_INT 500
104282: LESS
104283: IFFALSE 104309
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104285: LD_VAR 0 4
104289: PUSH
104290: LD_VAR 0 7
104294: ARRAY
104295: PPUSH
104296: LD_VAR 0 14
104300: PUSH
104301: LD_INT 1
104303: ARRAY
104304: PPUSH
104305: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104309: LD_VAR 0 4
104313: PUSH
104314: LD_VAR 0 7
104318: ARRAY
104319: PPUSH
104320: CALL_OW 264
104324: PUSH
104325: LD_INT 49
104327: EQUAL
104328: IFFALSE 104449
// begin if not HasTask ( group [ i ] ) then
104330: LD_VAR 0 4
104334: PUSH
104335: LD_VAR 0 7
104339: ARRAY
104340: PPUSH
104341: CALL_OW 314
104345: NOT
104346: IFFALSE 104449
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104348: LD_ADDR_VAR 0 9
104352: PUSH
104353: LD_INT 81
104355: PUSH
104356: LD_VAR 0 4
104360: PUSH
104361: LD_VAR 0 7
104365: ARRAY
104366: PPUSH
104367: CALL_OW 255
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: PPUSH
104376: CALL_OW 69
104380: PPUSH
104381: LD_VAR 0 4
104385: PUSH
104386: LD_VAR 0 7
104390: ARRAY
104391: PPUSH
104392: CALL_OW 74
104396: ST_TO_ADDR
// if k then
104397: LD_VAR 0 9
104401: IFFALSE 104449
// if GetDistUnits ( group [ i ] , k ) > 10 then
104403: LD_VAR 0 4
104407: PUSH
104408: LD_VAR 0 7
104412: ARRAY
104413: PPUSH
104414: LD_VAR 0 9
104418: PPUSH
104419: CALL_OW 296
104423: PUSH
104424: LD_INT 10
104426: GREATER
104427: IFFALSE 104449
// ComMoveUnit ( group [ i ] , k ) ;
104429: LD_VAR 0 4
104433: PUSH
104434: LD_VAR 0 7
104438: ARRAY
104439: PPUSH
104440: LD_VAR 0 9
104444: PPUSH
104445: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104449: LD_VAR 0 4
104453: PUSH
104454: LD_VAR 0 7
104458: ARRAY
104459: PPUSH
104460: CALL_OW 256
104464: PUSH
104465: LD_INT 250
104467: LESS
104468: PUSH
104469: LD_VAR 0 4
104473: PUSH
104474: LD_VAR 0 7
104478: ARRAY
104479: PUSH
104480: LD_INT 21
104482: PUSH
104483: LD_INT 2
104485: PUSH
104486: EMPTY
104487: LIST
104488: LIST
104489: PUSH
104490: LD_INT 23
104492: PUSH
104493: LD_INT 2
104495: PUSH
104496: EMPTY
104497: LIST
104498: LIST
104499: PUSH
104500: EMPTY
104501: LIST
104502: LIST
104503: PPUSH
104504: CALL_OW 69
104508: IN
104509: AND
104510: IFFALSE 104635
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104512: LD_ADDR_VAR 0 9
104516: PUSH
104517: LD_OWVAR 3
104521: PUSH
104522: LD_VAR 0 4
104526: PUSH
104527: LD_VAR 0 7
104531: ARRAY
104532: DIFF
104533: PPUSH
104534: LD_VAR 0 4
104538: PUSH
104539: LD_VAR 0 7
104543: ARRAY
104544: PPUSH
104545: CALL_OW 74
104549: ST_TO_ADDR
// if not k then
104550: LD_VAR 0 9
104554: NOT
104555: IFFALSE 104559
// continue ;
104557: GO 100974
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104559: LD_VAR 0 9
104563: PUSH
104564: LD_INT 81
104566: PUSH
104567: LD_VAR 0 4
104571: PUSH
104572: LD_VAR 0 7
104576: ARRAY
104577: PPUSH
104578: CALL_OW 255
104582: PUSH
104583: EMPTY
104584: LIST
104585: LIST
104586: PPUSH
104587: CALL_OW 69
104591: IN
104592: PUSH
104593: LD_VAR 0 9
104597: PPUSH
104598: LD_VAR 0 4
104602: PUSH
104603: LD_VAR 0 7
104607: ARRAY
104608: PPUSH
104609: CALL_OW 296
104613: PUSH
104614: LD_INT 5
104616: LESS
104617: AND
104618: IFFALSE 104635
// ComAutodestruct ( group [ i ] ) ;
104620: LD_VAR 0 4
104624: PUSH
104625: LD_VAR 0 7
104629: ARRAY
104630: PPUSH
104631: CALL 99069 0 1
// end ; if f_attack_depot then
104635: LD_VAR 0 25
104639: IFFALSE 104751
// begin k := 6 ;
104641: LD_ADDR_VAR 0 9
104645: PUSH
104646: LD_INT 6
104648: ST_TO_ADDR
// if tmp < k then
104649: LD_VAR 0 14
104653: PUSH
104654: LD_VAR 0 9
104658: LESS
104659: IFFALSE 104671
// k := tmp ;
104661: LD_ADDR_VAR 0 9
104665: PUSH
104666: LD_VAR 0 14
104670: ST_TO_ADDR
// for j = 1 to k do
104671: LD_ADDR_VAR 0 8
104675: PUSH
104676: DOUBLE
104677: LD_INT 1
104679: DEC
104680: ST_TO_ADDR
104681: LD_VAR 0 9
104685: PUSH
104686: FOR_TO
104687: IFFALSE 104749
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104689: LD_VAR 0 8
104693: PPUSH
104694: CALL_OW 266
104698: PUSH
104699: LD_INT 0
104701: PUSH
104702: LD_INT 1
104704: PUSH
104705: EMPTY
104706: LIST
104707: LIST
104708: IN
104709: IFFALSE 104747
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104711: LD_VAR 0 4
104715: PUSH
104716: LD_VAR 0 7
104720: ARRAY
104721: PPUSH
104722: LD_VAR 0 14
104726: PUSH
104727: LD_VAR 0 8
104731: ARRAY
104732: PPUSH
104733: CALL_OW 115
// attacking := true ;
104737: LD_ADDR_VAR 0 29
104741: PUSH
104742: LD_INT 1
104744: ST_TO_ADDR
// break ;
104745: GO 104749
// end ;
104747: GO 104686
104749: POP
104750: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104751: LD_VAR 0 4
104755: PUSH
104756: LD_VAR 0 7
104760: ARRAY
104761: PPUSH
104762: CALL_OW 302
104766: PUSH
104767: LD_VAR 0 29
104771: NOT
104772: AND
104773: IFFALSE 105095
// begin if GetTag ( group [ i ] ) = 71 then
104775: LD_VAR 0 4
104779: PUSH
104780: LD_VAR 0 7
104784: ARRAY
104785: PPUSH
104786: CALL_OW 110
104790: PUSH
104791: LD_INT 71
104793: EQUAL
104794: IFFALSE 104835
// begin if HasTask ( group [ i ] ) then
104796: LD_VAR 0 4
104800: PUSH
104801: LD_VAR 0 7
104805: ARRAY
104806: PPUSH
104807: CALL_OW 314
104811: IFFALSE 104817
// continue else
104813: GO 100974
104815: GO 104835
// SetTag ( group [ i ] , 0 ) ;
104817: LD_VAR 0 4
104821: PUSH
104822: LD_VAR 0 7
104826: ARRAY
104827: PPUSH
104828: LD_INT 0
104830: PPUSH
104831: CALL_OW 109
// end ; k := 8 ;
104835: LD_ADDR_VAR 0 9
104839: PUSH
104840: LD_INT 8
104842: ST_TO_ADDR
// x := 0 ;
104843: LD_ADDR_VAR 0 10
104847: PUSH
104848: LD_INT 0
104850: ST_TO_ADDR
// if tmp < k then
104851: LD_VAR 0 14
104855: PUSH
104856: LD_VAR 0 9
104860: LESS
104861: IFFALSE 104873
// k := tmp ;
104863: LD_ADDR_VAR 0 9
104867: PUSH
104868: LD_VAR 0 14
104872: ST_TO_ADDR
// for j = 1 to k do
104873: LD_ADDR_VAR 0 8
104877: PUSH
104878: DOUBLE
104879: LD_INT 1
104881: DEC
104882: ST_TO_ADDR
104883: LD_VAR 0 9
104887: PUSH
104888: FOR_TO
104889: IFFALSE 104987
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104891: LD_VAR 0 14
104895: PUSH
104896: LD_VAR 0 8
104900: ARRAY
104901: PPUSH
104902: CALL_OW 247
104906: PUSH
104907: LD_INT 1
104909: EQUAL
104910: PUSH
104911: LD_VAR 0 14
104915: PUSH
104916: LD_VAR 0 8
104920: ARRAY
104921: PPUSH
104922: CALL_OW 256
104926: PUSH
104927: LD_INT 250
104929: LESS
104930: PUSH
104931: LD_VAR 0 20
104935: AND
104936: PUSH
104937: LD_VAR 0 20
104941: NOT
104942: PUSH
104943: LD_VAR 0 14
104947: PUSH
104948: LD_VAR 0 8
104952: ARRAY
104953: PPUSH
104954: CALL_OW 256
104958: PUSH
104959: LD_INT 250
104961: GREATEREQUAL
104962: AND
104963: OR
104964: AND
104965: IFFALSE 104985
// begin x := tmp [ j ] ;
104967: LD_ADDR_VAR 0 10
104971: PUSH
104972: LD_VAR 0 14
104976: PUSH
104977: LD_VAR 0 8
104981: ARRAY
104982: ST_TO_ADDR
// break ;
104983: GO 104987
// end ;
104985: GO 104888
104987: POP
104988: POP
// if x then
104989: LD_VAR 0 10
104993: IFFALSE 105017
// ComAttackUnit ( group [ i ] , x ) else
104995: LD_VAR 0 4
104999: PUSH
105000: LD_VAR 0 7
105004: ARRAY
105005: PPUSH
105006: LD_VAR 0 10
105010: PPUSH
105011: CALL_OW 115
105015: GO 105041
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105017: LD_VAR 0 4
105021: PUSH
105022: LD_VAR 0 7
105026: ARRAY
105027: PPUSH
105028: LD_VAR 0 14
105032: PUSH
105033: LD_INT 1
105035: ARRAY
105036: PPUSH
105037: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105041: LD_VAR 0 4
105045: PUSH
105046: LD_VAR 0 7
105050: ARRAY
105051: PPUSH
105052: CALL_OW 314
105056: NOT
105057: IFFALSE 105095
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105059: LD_VAR 0 4
105063: PUSH
105064: LD_VAR 0 7
105068: ARRAY
105069: PPUSH
105070: LD_VAR 0 14
105074: PPUSH
105075: LD_VAR 0 4
105079: PUSH
105080: LD_VAR 0 7
105084: ARRAY
105085: PPUSH
105086: CALL_OW 74
105090: PPUSH
105091: CALL_OW 115
// end ; end ; end ;
105095: GO 100974
105097: POP
105098: POP
// wait ( 0 0$1 ) ;
105099: LD_INT 35
105101: PPUSH
105102: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105106: LD_VAR 0 4
105110: PUSH
105111: EMPTY
105112: EQUAL
105113: PUSH
105114: LD_INT 81
105116: PUSH
105117: LD_VAR 0 35
105121: PUSH
105122: EMPTY
105123: LIST
105124: LIST
105125: PPUSH
105126: CALL_OW 69
105130: NOT
105131: OR
105132: IFFALSE 100959
// end ;
105134: LD_VAR 0 2
105138: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105139: LD_INT 0
105141: PPUSH
105142: PPUSH
105143: PPUSH
105144: PPUSH
// if not base_units then
105145: LD_VAR 0 1
105149: NOT
105150: IFFALSE 105154
// exit ;
105152: GO 105241
// result := false ;
105154: LD_ADDR_VAR 0 2
105158: PUSH
105159: LD_INT 0
105161: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105162: LD_ADDR_VAR 0 5
105166: PUSH
105167: LD_VAR 0 1
105171: PPUSH
105172: LD_INT 21
105174: PUSH
105175: LD_INT 3
105177: PUSH
105178: EMPTY
105179: LIST
105180: LIST
105181: PPUSH
105182: CALL_OW 72
105186: ST_TO_ADDR
// if not tmp then
105187: LD_VAR 0 5
105191: NOT
105192: IFFALSE 105196
// exit ;
105194: GO 105241
// for i in tmp do
105196: LD_ADDR_VAR 0 3
105200: PUSH
105201: LD_VAR 0 5
105205: PUSH
105206: FOR_IN
105207: IFFALSE 105239
// begin result := EnemyInRange ( i , 22 ) ;
105209: LD_ADDR_VAR 0 2
105213: PUSH
105214: LD_VAR 0 3
105218: PPUSH
105219: LD_INT 22
105221: PPUSH
105222: CALL 98775 0 2
105226: ST_TO_ADDR
// if result then
105227: LD_VAR 0 2
105231: IFFALSE 105237
// exit ;
105233: POP
105234: POP
105235: GO 105241
// end ;
105237: GO 105206
105239: POP
105240: POP
// end ;
105241: LD_VAR 0 2
105245: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105246: LD_INT 0
105248: PPUSH
105249: PPUSH
// if not units then
105250: LD_VAR 0 1
105254: NOT
105255: IFFALSE 105259
// exit ;
105257: GO 105329
// result := [ ] ;
105259: LD_ADDR_VAR 0 3
105263: PUSH
105264: EMPTY
105265: ST_TO_ADDR
// for i in units do
105266: LD_ADDR_VAR 0 4
105270: PUSH
105271: LD_VAR 0 1
105275: PUSH
105276: FOR_IN
105277: IFFALSE 105327
// if GetTag ( i ) = tag then
105279: LD_VAR 0 4
105283: PPUSH
105284: CALL_OW 110
105288: PUSH
105289: LD_VAR 0 2
105293: EQUAL
105294: IFFALSE 105325
// result := Insert ( result , result + 1 , i ) ;
105296: LD_ADDR_VAR 0 3
105300: PUSH
105301: LD_VAR 0 3
105305: PPUSH
105306: LD_VAR 0 3
105310: PUSH
105311: LD_INT 1
105313: PLUS
105314: PPUSH
105315: LD_VAR 0 4
105319: PPUSH
105320: CALL_OW 2
105324: ST_TO_ADDR
105325: GO 105276
105327: POP
105328: POP
// end ;
105329: LD_VAR 0 3
105333: RET
// export function IsDriver ( un ) ; begin
105334: LD_INT 0
105336: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105337: LD_ADDR_VAR 0 2
105341: PUSH
105342: LD_VAR 0 1
105346: PUSH
105347: LD_INT 55
105349: PUSH
105350: EMPTY
105351: LIST
105352: PPUSH
105353: CALL_OW 69
105357: IN
105358: ST_TO_ADDR
// end ;
105359: LD_VAR 0 2
105363: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105364: LD_INT 0
105366: PPUSH
105367: PPUSH
// list := [ ] ;
105368: LD_ADDR_VAR 0 5
105372: PUSH
105373: EMPTY
105374: ST_TO_ADDR
// case d of 0 :
105375: LD_VAR 0 3
105379: PUSH
105380: LD_INT 0
105382: DOUBLE
105383: EQUAL
105384: IFTRUE 105388
105386: GO 105521
105388: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105389: LD_ADDR_VAR 0 5
105393: PUSH
105394: LD_VAR 0 1
105398: PUSH
105399: LD_INT 4
105401: MINUS
105402: PUSH
105403: LD_VAR 0 2
105407: PUSH
105408: LD_INT 4
105410: MINUS
105411: PUSH
105412: LD_INT 2
105414: PUSH
105415: EMPTY
105416: LIST
105417: LIST
105418: LIST
105419: PUSH
105420: LD_VAR 0 1
105424: PUSH
105425: LD_INT 3
105427: MINUS
105428: PUSH
105429: LD_VAR 0 2
105433: PUSH
105434: LD_INT 1
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: LIST
105441: PUSH
105442: LD_VAR 0 1
105446: PUSH
105447: LD_INT 4
105449: PLUS
105450: PUSH
105451: LD_VAR 0 2
105455: PUSH
105456: LD_INT 4
105458: PUSH
105459: EMPTY
105460: LIST
105461: LIST
105462: LIST
105463: PUSH
105464: LD_VAR 0 1
105468: PUSH
105469: LD_INT 3
105471: PLUS
105472: PUSH
105473: LD_VAR 0 2
105477: PUSH
105478: LD_INT 3
105480: PLUS
105481: PUSH
105482: LD_INT 5
105484: PUSH
105485: EMPTY
105486: LIST
105487: LIST
105488: LIST
105489: PUSH
105490: LD_VAR 0 1
105494: PUSH
105495: LD_VAR 0 2
105499: PUSH
105500: LD_INT 4
105502: PLUS
105503: PUSH
105504: LD_INT 0
105506: PUSH
105507: EMPTY
105508: LIST
105509: LIST
105510: LIST
105511: PUSH
105512: EMPTY
105513: LIST
105514: LIST
105515: LIST
105516: LIST
105517: LIST
105518: ST_TO_ADDR
// end ; 1 :
105519: GO 106219
105521: LD_INT 1
105523: DOUBLE
105524: EQUAL
105525: IFTRUE 105529
105527: GO 105662
105529: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105530: LD_ADDR_VAR 0 5
105534: PUSH
105535: LD_VAR 0 1
105539: PUSH
105540: LD_VAR 0 2
105544: PUSH
105545: LD_INT 4
105547: MINUS
105548: PUSH
105549: LD_INT 3
105551: PUSH
105552: EMPTY
105553: LIST
105554: LIST
105555: LIST
105556: PUSH
105557: LD_VAR 0 1
105561: PUSH
105562: LD_INT 3
105564: MINUS
105565: PUSH
105566: LD_VAR 0 2
105570: PUSH
105571: LD_INT 3
105573: MINUS
105574: PUSH
105575: LD_INT 2
105577: PUSH
105578: EMPTY
105579: LIST
105580: LIST
105581: LIST
105582: PUSH
105583: LD_VAR 0 1
105587: PUSH
105588: LD_INT 4
105590: MINUS
105591: PUSH
105592: LD_VAR 0 2
105596: PUSH
105597: LD_INT 1
105599: PUSH
105600: EMPTY
105601: LIST
105602: LIST
105603: LIST
105604: PUSH
105605: LD_VAR 0 1
105609: PUSH
105610: LD_VAR 0 2
105614: PUSH
105615: LD_INT 3
105617: PLUS
105618: PUSH
105619: LD_INT 0
105621: PUSH
105622: EMPTY
105623: LIST
105624: LIST
105625: LIST
105626: PUSH
105627: LD_VAR 0 1
105631: PUSH
105632: LD_INT 4
105634: PLUS
105635: PUSH
105636: LD_VAR 0 2
105640: PUSH
105641: LD_INT 4
105643: PLUS
105644: PUSH
105645: LD_INT 5
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: PUSH
105653: EMPTY
105654: LIST
105655: LIST
105656: LIST
105657: LIST
105658: LIST
105659: ST_TO_ADDR
// end ; 2 :
105660: GO 106219
105662: LD_INT 2
105664: DOUBLE
105665: EQUAL
105666: IFTRUE 105670
105668: GO 105799
105670: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105671: LD_ADDR_VAR 0 5
105675: PUSH
105676: LD_VAR 0 1
105680: PUSH
105681: LD_VAR 0 2
105685: PUSH
105686: LD_INT 3
105688: MINUS
105689: PUSH
105690: LD_INT 3
105692: PUSH
105693: EMPTY
105694: LIST
105695: LIST
105696: LIST
105697: PUSH
105698: LD_VAR 0 1
105702: PUSH
105703: LD_INT 4
105705: PLUS
105706: PUSH
105707: LD_VAR 0 2
105711: PUSH
105712: LD_INT 4
105714: PUSH
105715: EMPTY
105716: LIST
105717: LIST
105718: LIST
105719: PUSH
105720: LD_VAR 0 1
105724: PUSH
105725: LD_VAR 0 2
105729: PUSH
105730: LD_INT 4
105732: PLUS
105733: PUSH
105734: LD_INT 0
105736: PUSH
105737: EMPTY
105738: LIST
105739: LIST
105740: LIST
105741: PUSH
105742: LD_VAR 0 1
105746: PUSH
105747: LD_INT 3
105749: MINUS
105750: PUSH
105751: LD_VAR 0 2
105755: PUSH
105756: LD_INT 1
105758: PUSH
105759: EMPTY
105760: LIST
105761: LIST
105762: LIST
105763: PUSH
105764: LD_VAR 0 1
105768: PUSH
105769: LD_INT 4
105771: MINUS
105772: PUSH
105773: LD_VAR 0 2
105777: PUSH
105778: LD_INT 4
105780: MINUS
105781: PUSH
105782: LD_INT 2
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: LIST
105789: PUSH
105790: EMPTY
105791: LIST
105792: LIST
105793: LIST
105794: LIST
105795: LIST
105796: ST_TO_ADDR
// end ; 3 :
105797: GO 106219
105799: LD_INT 3
105801: DOUBLE
105802: EQUAL
105803: IFTRUE 105807
105805: GO 105940
105807: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105808: LD_ADDR_VAR 0 5
105812: PUSH
105813: LD_VAR 0 1
105817: PUSH
105818: LD_INT 3
105820: PLUS
105821: PUSH
105822: LD_VAR 0 2
105826: PUSH
105827: LD_INT 4
105829: PUSH
105830: EMPTY
105831: LIST
105832: LIST
105833: LIST
105834: PUSH
105835: LD_VAR 0 1
105839: PUSH
105840: LD_INT 4
105842: PLUS
105843: PUSH
105844: LD_VAR 0 2
105848: PUSH
105849: LD_INT 4
105851: PLUS
105852: PUSH
105853: LD_INT 5
105855: PUSH
105856: EMPTY
105857: LIST
105858: LIST
105859: LIST
105860: PUSH
105861: LD_VAR 0 1
105865: PUSH
105866: LD_INT 4
105868: MINUS
105869: PUSH
105870: LD_VAR 0 2
105874: PUSH
105875: LD_INT 1
105877: PUSH
105878: EMPTY
105879: LIST
105880: LIST
105881: LIST
105882: PUSH
105883: LD_VAR 0 1
105887: PUSH
105888: LD_VAR 0 2
105892: PUSH
105893: LD_INT 4
105895: MINUS
105896: PUSH
105897: LD_INT 3
105899: PUSH
105900: EMPTY
105901: LIST
105902: LIST
105903: LIST
105904: PUSH
105905: LD_VAR 0 1
105909: PUSH
105910: LD_INT 3
105912: MINUS
105913: PUSH
105914: LD_VAR 0 2
105918: PUSH
105919: LD_INT 3
105921: MINUS
105922: PUSH
105923: LD_INT 2
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: LIST
105930: PUSH
105931: EMPTY
105932: LIST
105933: LIST
105934: LIST
105935: LIST
105936: LIST
105937: ST_TO_ADDR
// end ; 4 :
105938: GO 106219
105940: LD_INT 4
105942: DOUBLE
105943: EQUAL
105944: IFTRUE 105948
105946: GO 106081
105948: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105949: LD_ADDR_VAR 0 5
105953: PUSH
105954: LD_VAR 0 1
105958: PUSH
105959: LD_VAR 0 2
105963: PUSH
105964: LD_INT 4
105966: PLUS
105967: PUSH
105968: LD_INT 0
105970: PUSH
105971: EMPTY
105972: LIST
105973: LIST
105974: LIST
105975: PUSH
105976: LD_VAR 0 1
105980: PUSH
105981: LD_INT 3
105983: PLUS
105984: PUSH
105985: LD_VAR 0 2
105989: PUSH
105990: LD_INT 3
105992: PLUS
105993: PUSH
105994: LD_INT 5
105996: PUSH
105997: EMPTY
105998: LIST
105999: LIST
106000: LIST
106001: PUSH
106002: LD_VAR 0 1
106006: PUSH
106007: LD_INT 4
106009: PLUS
106010: PUSH
106011: LD_VAR 0 2
106015: PUSH
106016: LD_INT 4
106018: PUSH
106019: EMPTY
106020: LIST
106021: LIST
106022: LIST
106023: PUSH
106024: LD_VAR 0 1
106028: PUSH
106029: LD_VAR 0 2
106033: PUSH
106034: LD_INT 3
106036: MINUS
106037: PUSH
106038: LD_INT 3
106040: PUSH
106041: EMPTY
106042: LIST
106043: LIST
106044: LIST
106045: PUSH
106046: LD_VAR 0 1
106050: PUSH
106051: LD_INT 4
106053: MINUS
106054: PUSH
106055: LD_VAR 0 2
106059: PUSH
106060: LD_INT 4
106062: MINUS
106063: PUSH
106064: LD_INT 2
106066: PUSH
106067: EMPTY
106068: LIST
106069: LIST
106070: LIST
106071: PUSH
106072: EMPTY
106073: LIST
106074: LIST
106075: LIST
106076: LIST
106077: LIST
106078: ST_TO_ADDR
// end ; 5 :
106079: GO 106219
106081: LD_INT 5
106083: DOUBLE
106084: EQUAL
106085: IFTRUE 106089
106087: GO 106218
106089: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106090: LD_ADDR_VAR 0 5
106094: PUSH
106095: LD_VAR 0 1
106099: PUSH
106100: LD_INT 4
106102: MINUS
106103: PUSH
106104: LD_VAR 0 2
106108: PUSH
106109: LD_INT 1
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: LIST
106116: PUSH
106117: LD_VAR 0 1
106121: PUSH
106122: LD_VAR 0 2
106126: PUSH
106127: LD_INT 4
106129: MINUS
106130: PUSH
106131: LD_INT 3
106133: PUSH
106134: EMPTY
106135: LIST
106136: LIST
106137: LIST
106138: PUSH
106139: LD_VAR 0 1
106143: PUSH
106144: LD_INT 4
106146: PLUS
106147: PUSH
106148: LD_VAR 0 2
106152: PUSH
106153: LD_INT 4
106155: PLUS
106156: PUSH
106157: LD_INT 5
106159: PUSH
106160: EMPTY
106161: LIST
106162: LIST
106163: LIST
106164: PUSH
106165: LD_VAR 0 1
106169: PUSH
106170: LD_INT 3
106172: PLUS
106173: PUSH
106174: LD_VAR 0 2
106178: PUSH
106179: LD_INT 4
106181: PUSH
106182: EMPTY
106183: LIST
106184: LIST
106185: LIST
106186: PUSH
106187: LD_VAR 0 1
106191: PUSH
106192: LD_VAR 0 2
106196: PUSH
106197: LD_INT 3
106199: PLUS
106200: PUSH
106201: LD_INT 0
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: LIST
106208: PUSH
106209: EMPTY
106210: LIST
106211: LIST
106212: LIST
106213: LIST
106214: LIST
106215: ST_TO_ADDR
// end ; end ;
106216: GO 106219
106218: POP
// result := list ;
106219: LD_ADDR_VAR 0 4
106223: PUSH
106224: LD_VAR 0 5
106228: ST_TO_ADDR
// end ;
106229: LD_VAR 0 4
106233: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106234: LD_INT 0
106236: PPUSH
106237: PPUSH
106238: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106239: LD_VAR 0 1
106243: NOT
106244: PUSH
106245: LD_VAR 0 2
106249: PUSH
106250: LD_INT 1
106252: PUSH
106253: LD_INT 2
106255: PUSH
106256: LD_INT 3
106258: PUSH
106259: LD_INT 4
106261: PUSH
106262: EMPTY
106263: LIST
106264: LIST
106265: LIST
106266: LIST
106267: IN
106268: NOT
106269: OR
106270: IFFALSE 106274
// exit ;
106272: GO 106366
// tmp := [ ] ;
106274: LD_ADDR_VAR 0 5
106278: PUSH
106279: EMPTY
106280: ST_TO_ADDR
// for i in units do
106281: LD_ADDR_VAR 0 4
106285: PUSH
106286: LD_VAR 0 1
106290: PUSH
106291: FOR_IN
106292: IFFALSE 106335
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106294: LD_ADDR_VAR 0 5
106298: PUSH
106299: LD_VAR 0 5
106303: PPUSH
106304: LD_VAR 0 5
106308: PUSH
106309: LD_INT 1
106311: PLUS
106312: PPUSH
106313: LD_VAR 0 4
106317: PPUSH
106318: LD_VAR 0 2
106322: PPUSH
106323: CALL_OW 259
106327: PPUSH
106328: CALL_OW 2
106332: ST_TO_ADDR
106333: GO 106291
106335: POP
106336: POP
// if not tmp then
106337: LD_VAR 0 5
106341: NOT
106342: IFFALSE 106346
// exit ;
106344: GO 106366
// result := SortListByListDesc ( units , tmp ) ;
106346: LD_ADDR_VAR 0 3
106350: PUSH
106351: LD_VAR 0 1
106355: PPUSH
106356: LD_VAR 0 5
106360: PPUSH
106361: CALL_OW 77
106365: ST_TO_ADDR
// end ;
106366: LD_VAR 0 3
106370: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106371: LD_INT 0
106373: PPUSH
106374: PPUSH
106375: PPUSH
// x := GetX ( building ) ;
106376: LD_ADDR_VAR 0 4
106380: PUSH
106381: LD_VAR 0 2
106385: PPUSH
106386: CALL_OW 250
106390: ST_TO_ADDR
// y := GetY ( building ) ;
106391: LD_ADDR_VAR 0 5
106395: PUSH
106396: LD_VAR 0 2
106400: PPUSH
106401: CALL_OW 251
106405: ST_TO_ADDR
// if GetTaskList ( unit ) then
106406: LD_VAR 0 1
106410: PPUSH
106411: CALL_OW 437
106415: IFFALSE 106510
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106417: LD_STRING e
106419: PUSH
106420: LD_VAR 0 1
106424: PPUSH
106425: CALL_OW 437
106429: PUSH
106430: LD_INT 1
106432: ARRAY
106433: PUSH
106434: LD_INT 1
106436: ARRAY
106437: EQUAL
106438: PUSH
106439: LD_VAR 0 4
106443: PUSH
106444: LD_VAR 0 1
106448: PPUSH
106449: CALL_OW 437
106453: PUSH
106454: LD_INT 1
106456: ARRAY
106457: PUSH
106458: LD_INT 2
106460: ARRAY
106461: EQUAL
106462: AND
106463: PUSH
106464: LD_VAR 0 5
106468: PUSH
106469: LD_VAR 0 1
106473: PPUSH
106474: CALL_OW 437
106478: PUSH
106479: LD_INT 1
106481: ARRAY
106482: PUSH
106483: LD_INT 3
106485: ARRAY
106486: EQUAL
106487: AND
106488: IFFALSE 106500
// result := true else
106490: LD_ADDR_VAR 0 3
106494: PUSH
106495: LD_INT 1
106497: ST_TO_ADDR
106498: GO 106508
// result := false ;
106500: LD_ADDR_VAR 0 3
106504: PUSH
106505: LD_INT 0
106507: ST_TO_ADDR
// end else
106508: GO 106518
// result := false ;
106510: LD_ADDR_VAR 0 3
106514: PUSH
106515: LD_INT 0
106517: ST_TO_ADDR
// end ;
106518: LD_VAR 0 3
106522: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106523: LD_INT 0
106525: PPUSH
106526: PPUSH
106527: PPUSH
106528: PPUSH
// if not unit or not area then
106529: LD_VAR 0 1
106533: NOT
106534: PUSH
106535: LD_VAR 0 2
106539: NOT
106540: OR
106541: IFFALSE 106545
// exit ;
106543: GO 106709
// tmp := AreaToList ( area , i ) ;
106545: LD_ADDR_VAR 0 6
106549: PUSH
106550: LD_VAR 0 2
106554: PPUSH
106555: LD_VAR 0 5
106559: PPUSH
106560: CALL_OW 517
106564: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106565: LD_ADDR_VAR 0 5
106569: PUSH
106570: DOUBLE
106571: LD_INT 1
106573: DEC
106574: ST_TO_ADDR
106575: LD_VAR 0 6
106579: PUSH
106580: LD_INT 1
106582: ARRAY
106583: PUSH
106584: FOR_TO
106585: IFFALSE 106707
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106587: LD_ADDR_VAR 0 7
106591: PUSH
106592: LD_VAR 0 6
106596: PUSH
106597: LD_INT 1
106599: ARRAY
106600: PUSH
106601: LD_VAR 0 5
106605: ARRAY
106606: PUSH
106607: LD_VAR 0 6
106611: PUSH
106612: LD_INT 2
106614: ARRAY
106615: PUSH
106616: LD_VAR 0 5
106620: ARRAY
106621: PUSH
106622: EMPTY
106623: LIST
106624: LIST
106625: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106626: LD_VAR 0 7
106630: PUSH
106631: LD_INT 1
106633: ARRAY
106634: PPUSH
106635: LD_VAR 0 7
106639: PUSH
106640: LD_INT 2
106642: ARRAY
106643: PPUSH
106644: CALL_OW 428
106648: PUSH
106649: LD_INT 0
106651: EQUAL
106652: IFFALSE 106705
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106654: LD_VAR 0 1
106658: PPUSH
106659: LD_VAR 0 7
106663: PUSH
106664: LD_INT 1
106666: ARRAY
106667: PPUSH
106668: LD_VAR 0 7
106672: PUSH
106673: LD_INT 2
106675: ARRAY
106676: PPUSH
106677: LD_VAR 0 3
106681: PPUSH
106682: CALL_OW 48
// result := IsPlaced ( unit ) ;
106686: LD_ADDR_VAR 0 4
106690: PUSH
106691: LD_VAR 0 1
106695: PPUSH
106696: CALL_OW 305
106700: ST_TO_ADDR
// exit ;
106701: POP
106702: POP
106703: GO 106709
// end ; end ;
106705: GO 106584
106707: POP
106708: POP
// end ;
106709: LD_VAR 0 4
106713: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106714: LD_INT 0
106716: PPUSH
106717: PPUSH
106718: PPUSH
// if not side or side > 8 then
106719: LD_VAR 0 1
106723: NOT
106724: PUSH
106725: LD_VAR 0 1
106729: PUSH
106730: LD_INT 8
106732: GREATER
106733: OR
106734: IFFALSE 106738
// exit ;
106736: GO 106925
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106738: LD_ADDR_VAR 0 4
106742: PUSH
106743: LD_INT 22
106745: PUSH
106746: LD_VAR 0 1
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: PUSH
106755: LD_INT 21
106757: PUSH
106758: LD_INT 3
106760: PUSH
106761: EMPTY
106762: LIST
106763: LIST
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: PPUSH
106769: CALL_OW 69
106773: ST_TO_ADDR
// if not tmp then
106774: LD_VAR 0 4
106778: NOT
106779: IFFALSE 106783
// exit ;
106781: GO 106925
// enable_addtolog := true ;
106783: LD_ADDR_OWVAR 81
106787: PUSH
106788: LD_INT 1
106790: ST_TO_ADDR
// AddToLog ( [ ) ;
106791: LD_STRING [
106793: PPUSH
106794: CALL_OW 561
// for i in tmp do
106798: LD_ADDR_VAR 0 3
106802: PUSH
106803: LD_VAR 0 4
106807: PUSH
106808: FOR_IN
106809: IFFALSE 106916
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106811: LD_STRING [
106813: PUSH
106814: LD_VAR 0 3
106818: PPUSH
106819: CALL_OW 266
106823: STR
106824: PUSH
106825: LD_STRING , 
106827: STR
106828: PUSH
106829: LD_VAR 0 3
106833: PPUSH
106834: CALL_OW 250
106838: STR
106839: PUSH
106840: LD_STRING , 
106842: STR
106843: PUSH
106844: LD_VAR 0 3
106848: PPUSH
106849: CALL_OW 251
106853: STR
106854: PUSH
106855: LD_STRING , 
106857: STR
106858: PUSH
106859: LD_VAR 0 3
106863: PPUSH
106864: CALL_OW 254
106868: STR
106869: PUSH
106870: LD_STRING , 
106872: STR
106873: PUSH
106874: LD_VAR 0 3
106878: PPUSH
106879: LD_INT 1
106881: PPUSH
106882: CALL_OW 268
106886: STR
106887: PUSH
106888: LD_STRING , 
106890: STR
106891: PUSH
106892: LD_VAR 0 3
106896: PPUSH
106897: LD_INT 2
106899: PPUSH
106900: CALL_OW 268
106904: STR
106905: PUSH
106906: LD_STRING ],
106908: STR
106909: PPUSH
106910: CALL_OW 561
// end ;
106914: GO 106808
106916: POP
106917: POP
// AddToLog ( ]; ) ;
106918: LD_STRING ];
106920: PPUSH
106921: CALL_OW 561
// end ;
106925: LD_VAR 0 2
106929: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106930: LD_INT 0
106932: PPUSH
106933: PPUSH
106934: PPUSH
106935: PPUSH
106936: PPUSH
// if not area or not rate or not max then
106937: LD_VAR 0 1
106941: NOT
106942: PUSH
106943: LD_VAR 0 2
106947: NOT
106948: OR
106949: PUSH
106950: LD_VAR 0 4
106954: NOT
106955: OR
106956: IFFALSE 106960
// exit ;
106958: GO 107152
// while 1 do
106960: LD_INT 1
106962: IFFALSE 107152
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106964: LD_ADDR_VAR 0 9
106968: PUSH
106969: LD_VAR 0 1
106973: PPUSH
106974: LD_INT 1
106976: PPUSH
106977: CALL_OW 287
106981: PUSH
106982: LD_INT 10
106984: MUL
106985: ST_TO_ADDR
// r := rate / 10 ;
106986: LD_ADDR_VAR 0 7
106990: PUSH
106991: LD_VAR 0 2
106995: PUSH
106996: LD_INT 10
106998: DIVREAL
106999: ST_TO_ADDR
// time := 1 1$00 ;
107000: LD_ADDR_VAR 0 8
107004: PUSH
107005: LD_INT 2100
107007: ST_TO_ADDR
// if amount < min then
107008: LD_VAR 0 9
107012: PUSH
107013: LD_VAR 0 3
107017: LESS
107018: IFFALSE 107036
// r := r * 2 else
107020: LD_ADDR_VAR 0 7
107024: PUSH
107025: LD_VAR 0 7
107029: PUSH
107030: LD_INT 2
107032: MUL
107033: ST_TO_ADDR
107034: GO 107062
// if amount > max then
107036: LD_VAR 0 9
107040: PUSH
107041: LD_VAR 0 4
107045: GREATER
107046: IFFALSE 107062
// r := r / 2 ;
107048: LD_ADDR_VAR 0 7
107052: PUSH
107053: LD_VAR 0 7
107057: PUSH
107058: LD_INT 2
107060: DIVREAL
107061: ST_TO_ADDR
// time := time / r ;
107062: LD_ADDR_VAR 0 8
107066: PUSH
107067: LD_VAR 0 8
107071: PUSH
107072: LD_VAR 0 7
107076: DIVREAL
107077: ST_TO_ADDR
// if time < 0 then
107078: LD_VAR 0 8
107082: PUSH
107083: LD_INT 0
107085: LESS
107086: IFFALSE 107103
// time := time * - 1 ;
107088: LD_ADDR_VAR 0 8
107092: PUSH
107093: LD_VAR 0 8
107097: PUSH
107098: LD_INT 1
107100: NEG
107101: MUL
107102: ST_TO_ADDR
// wait ( time ) ;
107103: LD_VAR 0 8
107107: PPUSH
107108: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107112: LD_INT 35
107114: PPUSH
107115: LD_INT 875
107117: PPUSH
107118: CALL_OW 12
107122: PPUSH
107123: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107127: LD_INT 1
107129: PPUSH
107130: LD_INT 5
107132: PPUSH
107133: CALL_OW 12
107137: PPUSH
107138: LD_VAR 0 1
107142: PPUSH
107143: LD_INT 1
107145: PPUSH
107146: CALL_OW 55
// end ;
107150: GO 106960
// end ;
107152: LD_VAR 0 5
107156: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107157: LD_INT 0
107159: PPUSH
107160: PPUSH
107161: PPUSH
107162: PPUSH
107163: PPUSH
107164: PPUSH
107165: PPUSH
107166: PPUSH
// if not turrets or not factories then
107167: LD_VAR 0 1
107171: NOT
107172: PUSH
107173: LD_VAR 0 2
107177: NOT
107178: OR
107179: IFFALSE 107183
// exit ;
107181: GO 107490
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107183: LD_ADDR_VAR 0 10
107187: PUSH
107188: LD_INT 5
107190: PUSH
107191: LD_INT 6
107193: PUSH
107194: EMPTY
107195: LIST
107196: LIST
107197: PUSH
107198: LD_INT 2
107200: PUSH
107201: LD_INT 4
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: PUSH
107208: LD_INT 3
107210: PUSH
107211: LD_INT 5
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: PUSH
107218: EMPTY
107219: LIST
107220: LIST
107221: LIST
107222: PUSH
107223: LD_INT 24
107225: PUSH
107226: LD_INT 25
107228: PUSH
107229: EMPTY
107230: LIST
107231: LIST
107232: PUSH
107233: LD_INT 23
107235: PUSH
107236: LD_INT 27
107238: PUSH
107239: EMPTY
107240: LIST
107241: LIST
107242: PUSH
107243: EMPTY
107244: LIST
107245: LIST
107246: PUSH
107247: LD_INT 42
107249: PUSH
107250: LD_INT 43
107252: PUSH
107253: EMPTY
107254: LIST
107255: LIST
107256: PUSH
107257: LD_INT 44
107259: PUSH
107260: LD_INT 46
107262: PUSH
107263: EMPTY
107264: LIST
107265: LIST
107266: PUSH
107267: LD_INT 45
107269: PUSH
107270: LD_INT 47
107272: PUSH
107273: EMPTY
107274: LIST
107275: LIST
107276: PUSH
107277: EMPTY
107278: LIST
107279: LIST
107280: LIST
107281: PUSH
107282: EMPTY
107283: LIST
107284: LIST
107285: LIST
107286: ST_TO_ADDR
// result := [ ] ;
107287: LD_ADDR_VAR 0 3
107291: PUSH
107292: EMPTY
107293: ST_TO_ADDR
// for i in turrets do
107294: LD_ADDR_VAR 0 4
107298: PUSH
107299: LD_VAR 0 1
107303: PUSH
107304: FOR_IN
107305: IFFALSE 107488
// begin nat := GetNation ( i ) ;
107307: LD_ADDR_VAR 0 7
107311: PUSH
107312: LD_VAR 0 4
107316: PPUSH
107317: CALL_OW 248
107321: ST_TO_ADDR
// weapon := 0 ;
107322: LD_ADDR_VAR 0 8
107326: PUSH
107327: LD_INT 0
107329: ST_TO_ADDR
// if not nat then
107330: LD_VAR 0 7
107334: NOT
107335: IFFALSE 107339
// continue ;
107337: GO 107304
// for j in list [ nat ] do
107339: LD_ADDR_VAR 0 5
107343: PUSH
107344: LD_VAR 0 10
107348: PUSH
107349: LD_VAR 0 7
107353: ARRAY
107354: PUSH
107355: FOR_IN
107356: IFFALSE 107397
// if GetBWeapon ( i ) = j [ 1 ] then
107358: LD_VAR 0 4
107362: PPUSH
107363: CALL_OW 269
107367: PUSH
107368: LD_VAR 0 5
107372: PUSH
107373: LD_INT 1
107375: ARRAY
107376: EQUAL
107377: IFFALSE 107395
// begin weapon := j [ 2 ] ;
107379: LD_ADDR_VAR 0 8
107383: PUSH
107384: LD_VAR 0 5
107388: PUSH
107389: LD_INT 2
107391: ARRAY
107392: ST_TO_ADDR
// break ;
107393: GO 107397
// end ;
107395: GO 107355
107397: POP
107398: POP
// if not weapon then
107399: LD_VAR 0 8
107403: NOT
107404: IFFALSE 107408
// continue ;
107406: GO 107304
// for k in factories do
107408: LD_ADDR_VAR 0 6
107412: PUSH
107413: LD_VAR 0 2
107417: PUSH
107418: FOR_IN
107419: IFFALSE 107484
// begin weapons := AvailableWeaponList ( k ) ;
107421: LD_ADDR_VAR 0 9
107425: PUSH
107426: LD_VAR 0 6
107430: PPUSH
107431: CALL_OW 478
107435: ST_TO_ADDR
// if not weapons then
107436: LD_VAR 0 9
107440: NOT
107441: IFFALSE 107445
// continue ;
107443: GO 107418
// if weapon in weapons then
107445: LD_VAR 0 8
107449: PUSH
107450: LD_VAR 0 9
107454: IN
107455: IFFALSE 107482
// begin result := [ i , weapon ] ;
107457: LD_ADDR_VAR 0 3
107461: PUSH
107462: LD_VAR 0 4
107466: PUSH
107467: LD_VAR 0 8
107471: PUSH
107472: EMPTY
107473: LIST
107474: LIST
107475: ST_TO_ADDR
// exit ;
107476: POP
107477: POP
107478: POP
107479: POP
107480: GO 107490
// end ; end ;
107482: GO 107418
107484: POP
107485: POP
// end ;
107486: GO 107304
107488: POP
107489: POP
// end ;
107490: LD_VAR 0 3
107494: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107495: LD_INT 0
107497: PPUSH
// if not side or side > 8 then
107498: LD_VAR 0 3
107502: NOT
107503: PUSH
107504: LD_VAR 0 3
107508: PUSH
107509: LD_INT 8
107511: GREATER
107512: OR
107513: IFFALSE 107517
// exit ;
107515: GO 107576
// if not range then
107517: LD_VAR 0 4
107521: NOT
107522: IFFALSE 107533
// range := - 12 ;
107524: LD_ADDR_VAR 0 4
107528: PUSH
107529: LD_INT 12
107531: NEG
107532: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107533: LD_VAR 0 1
107537: PPUSH
107538: LD_VAR 0 2
107542: PPUSH
107543: LD_VAR 0 3
107547: PPUSH
107548: LD_VAR 0 4
107552: PPUSH
107553: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107557: LD_VAR 0 1
107561: PPUSH
107562: LD_VAR 0 2
107566: PPUSH
107567: LD_VAR 0 3
107571: PPUSH
107572: CALL_OW 331
// end ;
107576: LD_VAR 0 5
107580: RET
// export function Video ( mode ) ; begin
107581: LD_INT 0
107583: PPUSH
// ingame_video = mode ;
107584: LD_ADDR_OWVAR 52
107588: PUSH
107589: LD_VAR 0 1
107593: ST_TO_ADDR
// interface_hidden = mode ;
107594: LD_ADDR_OWVAR 54
107598: PUSH
107599: LD_VAR 0 1
107603: ST_TO_ADDR
// end ;
107604: LD_VAR 0 2
107608: RET
// export function Join ( array , element ) ; begin
107609: LD_INT 0
107611: PPUSH
// result := array ^ element ;
107612: LD_ADDR_VAR 0 3
107616: PUSH
107617: LD_VAR 0 1
107621: PUSH
107622: LD_VAR 0 2
107626: ADD
107627: ST_TO_ADDR
// end ;
107628: LD_VAR 0 3
107632: RET
// export function JoinUnion ( array , element ) ; begin
107633: LD_INT 0
107635: PPUSH
// result := array union element ;
107636: LD_ADDR_VAR 0 3
107640: PUSH
107641: LD_VAR 0 1
107645: PUSH
107646: LD_VAR 0 2
107650: UNION
107651: ST_TO_ADDR
// end ;
107652: LD_VAR 0 3
107656: RET
// export function GetBehemoths ( side ) ; begin
107657: LD_INT 0
107659: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107660: LD_ADDR_VAR 0 2
107664: PUSH
107665: LD_INT 22
107667: PUSH
107668: LD_VAR 0 1
107672: PUSH
107673: EMPTY
107674: LIST
107675: LIST
107676: PUSH
107677: LD_INT 31
107679: PUSH
107680: LD_INT 25
107682: PUSH
107683: EMPTY
107684: LIST
107685: LIST
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: PPUSH
107691: CALL_OW 69
107695: ST_TO_ADDR
// end ;
107696: LD_VAR 0 2
107700: RET
// export function Shuffle ( array ) ; var i , index ; begin
107701: LD_INT 0
107703: PPUSH
107704: PPUSH
107705: PPUSH
// result := [ ] ;
107706: LD_ADDR_VAR 0 2
107710: PUSH
107711: EMPTY
107712: ST_TO_ADDR
// if not array then
107713: LD_VAR 0 1
107717: NOT
107718: IFFALSE 107722
// exit ;
107720: GO 107821
// Randomize ;
107722: CALL_OW 10
// for i = array downto 1 do
107726: LD_ADDR_VAR 0 3
107730: PUSH
107731: DOUBLE
107732: LD_VAR 0 1
107736: INC
107737: ST_TO_ADDR
107738: LD_INT 1
107740: PUSH
107741: FOR_DOWNTO
107742: IFFALSE 107819
// begin index := rand ( 1 , array ) ;
107744: LD_ADDR_VAR 0 4
107748: PUSH
107749: LD_INT 1
107751: PPUSH
107752: LD_VAR 0 1
107756: PPUSH
107757: CALL_OW 12
107761: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107762: LD_ADDR_VAR 0 2
107766: PUSH
107767: LD_VAR 0 2
107771: PPUSH
107772: LD_VAR 0 2
107776: PUSH
107777: LD_INT 1
107779: PLUS
107780: PPUSH
107781: LD_VAR 0 1
107785: PUSH
107786: LD_VAR 0 4
107790: ARRAY
107791: PPUSH
107792: CALL_OW 2
107796: ST_TO_ADDR
// array := Delete ( array , index ) ;
107797: LD_ADDR_VAR 0 1
107801: PUSH
107802: LD_VAR 0 1
107806: PPUSH
107807: LD_VAR 0 4
107811: PPUSH
107812: CALL_OW 3
107816: ST_TO_ADDR
// end ;
107817: GO 107741
107819: POP
107820: POP
// end ;
107821: LD_VAR 0 2
107825: RET
// export function GetBaseMaterials ( base ) ; begin
107826: LD_INT 0
107828: PPUSH
// result := [ 0 , 0 , 0 ] ;
107829: LD_ADDR_VAR 0 2
107833: PUSH
107834: LD_INT 0
107836: PUSH
107837: LD_INT 0
107839: PUSH
107840: LD_INT 0
107842: PUSH
107843: EMPTY
107844: LIST
107845: LIST
107846: LIST
107847: ST_TO_ADDR
// if not base then
107848: LD_VAR 0 1
107852: NOT
107853: IFFALSE 107857
// exit ;
107855: GO 107906
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107857: LD_ADDR_VAR 0 2
107861: PUSH
107862: LD_VAR 0 1
107866: PPUSH
107867: LD_INT 1
107869: PPUSH
107870: CALL_OW 275
107874: PUSH
107875: LD_VAR 0 1
107879: PPUSH
107880: LD_INT 2
107882: PPUSH
107883: CALL_OW 275
107887: PUSH
107888: LD_VAR 0 1
107892: PPUSH
107893: LD_INT 3
107895: PPUSH
107896: CALL_OW 275
107900: PUSH
107901: EMPTY
107902: LIST
107903: LIST
107904: LIST
107905: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107906: LD_VAR 0 2
107910: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107911: LD_INT 0
107913: PPUSH
107914: PPUSH
107915: PPUSH
107916: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107917: LD_VAR 0 1
107921: PPUSH
107922: CALL_OW 264
107926: PUSH
107927: LD_EXP 99
107931: EQUAL
107932: IFFALSE 108004
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107934: LD_INT 68
107936: PPUSH
107937: LD_VAR 0 1
107941: PPUSH
107942: CALL_OW 255
107946: PPUSH
107947: CALL_OW 321
107951: PUSH
107952: LD_INT 2
107954: EQUAL
107955: IFFALSE 107967
// eff := 70 else
107957: LD_ADDR_VAR 0 6
107961: PUSH
107962: LD_INT 70
107964: ST_TO_ADDR
107965: GO 107975
// eff := 30 ;
107967: LD_ADDR_VAR 0 6
107971: PUSH
107972: LD_INT 30
107974: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107975: LD_VAR 0 1
107979: PPUSH
107980: CALL_OW 250
107984: PPUSH
107985: LD_VAR 0 1
107989: PPUSH
107990: CALL_OW 251
107994: PPUSH
107995: LD_VAR 0 6
107999: PPUSH
108000: CALL_OW 495
// end ; end ;
108004: LD_VAR 0 4
108008: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
108009: LD_INT 0
108011: PPUSH
108012: PPUSH
108013: PPUSH
108014: PPUSH
108015: PPUSH
108016: PPUSH
// if cmd = 124 then
108017: LD_VAR 0 1
108021: PUSH
108022: LD_INT 124
108024: EQUAL
108025: IFFALSE 108231
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
108027: LD_ADDR_VAR 0 5
108031: PUSH
108032: LD_INT 2
108034: PUSH
108035: LD_INT 34
108037: PUSH
108038: LD_INT 53
108040: PUSH
108041: EMPTY
108042: LIST
108043: LIST
108044: PUSH
108045: LD_INT 34
108047: PUSH
108048: LD_INT 14
108050: PUSH
108051: EMPTY
108052: LIST
108053: LIST
108054: PUSH
108055: EMPTY
108056: LIST
108057: LIST
108058: LIST
108059: PPUSH
108060: CALL_OW 69
108064: ST_TO_ADDR
// if not tmp then
108065: LD_VAR 0 5
108069: NOT
108070: IFFALSE 108074
// exit ;
108072: GO 108231
// for i in tmp do
108074: LD_ADDR_VAR 0 3
108078: PUSH
108079: LD_VAR 0 5
108083: PUSH
108084: FOR_IN
108085: IFFALSE 108229
// begin taskList := GetTaskList ( i ) ;
108087: LD_ADDR_VAR 0 6
108091: PUSH
108092: LD_VAR 0 3
108096: PPUSH
108097: CALL_OW 437
108101: ST_TO_ADDR
// if not taskList then
108102: LD_VAR 0 6
108106: NOT
108107: IFFALSE 108111
// continue ;
108109: GO 108084
// for j = 1 to taskList do
108111: LD_ADDR_VAR 0 4
108115: PUSH
108116: DOUBLE
108117: LD_INT 1
108119: DEC
108120: ST_TO_ADDR
108121: LD_VAR 0 6
108125: PUSH
108126: FOR_TO
108127: IFFALSE 108225
// if taskList [ j ] [ 1 ] = | then
108129: LD_VAR 0 6
108133: PUSH
108134: LD_VAR 0 4
108138: ARRAY
108139: PUSH
108140: LD_INT 1
108142: ARRAY
108143: PUSH
108144: LD_STRING |
108146: EQUAL
108147: IFFALSE 108223
// begin _taskList := Delete ( taskList , 1 ) ;
108149: LD_ADDR_VAR 0 7
108153: PUSH
108154: LD_VAR 0 6
108158: PPUSH
108159: LD_INT 1
108161: PPUSH
108162: CALL_OW 3
108166: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
108167: LD_VAR 0 3
108171: PPUSH
108172: LD_VAR 0 7
108176: PPUSH
108177: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
108181: LD_VAR 0 3
108185: PPUSH
108186: LD_VAR 0 6
108190: PUSH
108191: LD_VAR 0 4
108195: ARRAY
108196: PUSH
108197: LD_INT 2
108199: ARRAY
108200: PPUSH
108201: LD_VAR 0 6
108205: PUSH
108206: LD_VAR 0 4
108210: ARRAY
108211: PUSH
108212: LD_INT 3
108214: ARRAY
108215: PPUSH
108216: LD_INT 8
108218: PPUSH
108219: CALL 108236 0 4
// end ;
108223: GO 108126
108225: POP
108226: POP
// end ;
108227: GO 108084
108229: POP
108230: POP
// end ; end ;
108231: LD_VAR 0 2
108235: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108236: LD_INT 0
108238: PPUSH
108239: PPUSH
108240: PPUSH
108241: PPUSH
108242: PPUSH
108243: PPUSH
108244: PPUSH
108245: PPUSH
108246: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108247: LD_VAR 0 1
108251: NOT
108252: PUSH
108253: LD_VAR 0 2
108257: PPUSH
108258: LD_VAR 0 3
108262: PPUSH
108263: CALL_OW 488
108267: NOT
108268: OR
108269: PUSH
108270: LD_VAR 0 4
108274: NOT
108275: OR
108276: IFFALSE 108280
// exit ;
108278: GO 108620
// list := [ ] ;
108280: LD_ADDR_VAR 0 13
108284: PUSH
108285: EMPTY
108286: ST_TO_ADDR
// if x - r < 0 then
108287: LD_VAR 0 2
108291: PUSH
108292: LD_VAR 0 4
108296: MINUS
108297: PUSH
108298: LD_INT 0
108300: LESS
108301: IFFALSE 108313
// min_x := 0 else
108303: LD_ADDR_VAR 0 7
108307: PUSH
108308: LD_INT 0
108310: ST_TO_ADDR
108311: GO 108329
// min_x := x - r ;
108313: LD_ADDR_VAR 0 7
108317: PUSH
108318: LD_VAR 0 2
108322: PUSH
108323: LD_VAR 0 4
108327: MINUS
108328: ST_TO_ADDR
// if y - r < 0 then
108329: LD_VAR 0 3
108333: PUSH
108334: LD_VAR 0 4
108338: MINUS
108339: PUSH
108340: LD_INT 0
108342: LESS
108343: IFFALSE 108355
// min_y := 0 else
108345: LD_ADDR_VAR 0 8
108349: PUSH
108350: LD_INT 0
108352: ST_TO_ADDR
108353: GO 108371
// min_y := y - r ;
108355: LD_ADDR_VAR 0 8
108359: PUSH
108360: LD_VAR 0 3
108364: PUSH
108365: LD_VAR 0 4
108369: MINUS
108370: ST_TO_ADDR
// max_x := x + r ;
108371: LD_ADDR_VAR 0 9
108375: PUSH
108376: LD_VAR 0 2
108380: PUSH
108381: LD_VAR 0 4
108385: PLUS
108386: ST_TO_ADDR
// max_y := y + r ;
108387: LD_ADDR_VAR 0 10
108391: PUSH
108392: LD_VAR 0 3
108396: PUSH
108397: LD_VAR 0 4
108401: PLUS
108402: ST_TO_ADDR
// for _x = min_x to max_x do
108403: LD_ADDR_VAR 0 11
108407: PUSH
108408: DOUBLE
108409: LD_VAR 0 7
108413: DEC
108414: ST_TO_ADDR
108415: LD_VAR 0 9
108419: PUSH
108420: FOR_TO
108421: IFFALSE 108538
// for _y = min_y to max_y do
108423: LD_ADDR_VAR 0 12
108427: PUSH
108428: DOUBLE
108429: LD_VAR 0 8
108433: DEC
108434: ST_TO_ADDR
108435: LD_VAR 0 10
108439: PUSH
108440: FOR_TO
108441: IFFALSE 108534
// begin if not ValidHex ( _x , _y ) then
108443: LD_VAR 0 11
108447: PPUSH
108448: LD_VAR 0 12
108452: PPUSH
108453: CALL_OW 488
108457: NOT
108458: IFFALSE 108462
// continue ;
108460: GO 108440
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108462: LD_VAR 0 11
108466: PPUSH
108467: LD_VAR 0 12
108471: PPUSH
108472: CALL_OW 351
108476: PUSH
108477: LD_VAR 0 11
108481: PPUSH
108482: LD_VAR 0 12
108486: PPUSH
108487: CALL_OW 554
108491: AND
108492: IFFALSE 108532
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108494: LD_ADDR_VAR 0 13
108498: PUSH
108499: LD_VAR 0 13
108503: PPUSH
108504: LD_VAR 0 13
108508: PUSH
108509: LD_INT 1
108511: PLUS
108512: PPUSH
108513: LD_VAR 0 11
108517: PUSH
108518: LD_VAR 0 12
108522: PUSH
108523: EMPTY
108524: LIST
108525: LIST
108526: PPUSH
108527: CALL_OW 2
108531: ST_TO_ADDR
// end ;
108532: GO 108440
108534: POP
108535: POP
108536: GO 108420
108538: POP
108539: POP
// if not list then
108540: LD_VAR 0 13
108544: NOT
108545: IFFALSE 108549
// exit ;
108547: GO 108620
// for i in list do
108549: LD_ADDR_VAR 0 6
108553: PUSH
108554: LD_VAR 0 13
108558: PUSH
108559: FOR_IN
108560: IFFALSE 108618
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108562: LD_VAR 0 1
108566: PPUSH
108567: LD_STRING M
108569: PUSH
108570: LD_VAR 0 6
108574: PUSH
108575: LD_INT 1
108577: ARRAY
108578: PUSH
108579: LD_VAR 0 6
108583: PUSH
108584: LD_INT 2
108586: ARRAY
108587: PUSH
108588: LD_INT 0
108590: PUSH
108591: LD_INT 0
108593: PUSH
108594: LD_INT 0
108596: PUSH
108597: LD_INT 0
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: LIST
108604: LIST
108605: LIST
108606: LIST
108607: LIST
108608: PUSH
108609: EMPTY
108610: LIST
108611: PPUSH
108612: CALL_OW 447
108616: GO 108559
108618: POP
108619: POP
// end ;
108620: LD_VAR 0 5
108624: RET
