// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35053 0 0
// InitNature ;
  19: CALL 34813 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11072 0 0
// PrepareRussian ;
  40: CALL 6956 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14966 0 0
// MC_Start ( ) ;
  60: CALL 37165 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 134
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 135
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59426 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59519 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58869 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58684 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59426 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59519 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58684 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58869 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59299 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58366 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59426 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59519 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 139
 955: PUSH
 956: LD_EXP 139
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58684 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59426 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59519 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58576 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59837 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 59008 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59299 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59299 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59631 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58684 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59250 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 65076 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69900 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69900 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69900 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69900 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69900 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 65076 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 65076 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 65076 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 65076 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 65076 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 65076 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 65076 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 65076 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 65076 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 65076 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 65076 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 65076 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 65076 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 65076 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 65076 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 65076 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 65076 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 65076 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 65076 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 65076 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 65076 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 65076 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 65076 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 65076 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 65076 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 65076 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 65076 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 65076 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 16 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 16
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 16 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 16
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69900 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 65076 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 65076 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 65076 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4448: LD_EXP 61
4452: PPUSH
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 10
4458: PPUSH
4459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_VAR 0 3
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PUSH
4480: LD_INT 30
4482: PUSH
4483: LD_INT 32
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 58
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: PPUSH
4501: CALL_OW 69
4505: ST_TO_ADDR
// for i = 1 to 10 do
4506: LD_ADDR_VAR 0 2
4510: PUSH
4511: DOUBLE
4512: LD_INT 1
4514: DEC
4515: ST_TO_ADDR
4516: LD_INT 10
4518: PUSH
4519: FOR_TO
4520: IFFALSE 4592
// begin uc_nation := nation_nature ;
4522: LD_ADDR_OWVAR 21
4526: PUSH
4527: LD_INT 0
4529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4530: LD_ADDR_OWVAR 28
4534: PUSH
4535: LD_INT 15
4537: ST_TO_ADDR
// hc_gallery :=  ;
4538: LD_ADDR_OWVAR 33
4542: PUSH
4543: LD_STRING 
4545: ST_TO_ADDR
// hc_name :=  ;
4546: LD_ADDR_OWVAR 26
4550: PUSH
4551: LD_STRING 
4553: ST_TO_ADDR
// un := CreateHuman ;
4554: LD_ADDR_VAR 0 4
4558: PUSH
4559: CALL_OW 44
4563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4564: LD_VAR 0 4
4568: PPUSH
4569: LD_VAR 0 5
4573: PUSH
4574: LD_VAR 0 5
4578: PUSH
4579: LD_VAR 0 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// end ;
4590: GO 4519
4592: POP
4593: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4594: LD_ADDR_VAR 0 5
4598: PUSH
4599: LD_STRING 12_kurt_squad
4601: PPUSH
4602: CALL_OW 31
4606: ST_TO_ADDR
// if tmp then
4607: LD_VAR 0 5
4611: IFFALSE 4645
// for i in tmp do
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_VAR 0 5
4622: PUSH
4623: FOR_IN
4624: IFFALSE 4643
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4626: LD_VAR 0 2
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 0
4636: PPUSH
4637: CALL_OW 49
4641: GO 4623
4643: POP
4644: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4645: LD_INT 324
4647: PPUSH
4648: LD_INT 5
4650: PPUSH
4651: LD_STRING 
4653: PPUSH
4654: LD_INT 8
4656: PUSH
4657: LD_INT 9
4659: PUSH
4660: LD_INT 10
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_OWVAR 67
4672: ARRAY
4673: PPUSH
4674: LD_INT 3000
4676: PUSH
4677: LD_INT 500
4679: PUSH
4680: LD_INT 150
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: LIST
4687: PPUSH
4688: LD_INT 16
4690: PUSH
4691: LD_INT 6
4693: PUSH
4694: LD_INT 6
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PPUSH
4706: CALL 73309 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4710: LD_ADDR_EXP 110
4714: PUSH
4715: LD_EXP 110
4719: PPUSH
4720: LD_INT 3
4722: PPUSH
4723: LD_INT 22
4725: PUSH
4726: LD_VAR 0 3
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 3
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 2
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: PUSH
4772: LD_EXP 60
4776: DIFF
4777: PPUSH
4778: CALL_OW 1
4782: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 7
4788: PPUSH
4789: CALL_OW 383
// Friend := CreateHuman ;
4793: LD_ADDR_EXP 62
4797: PUSH
4798: CALL_OW 44
4802: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4803: LD_INT 14
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 1
4811: PPUSH
4812: LD_INT 29
4814: PPUSH
4815: LD_INT 100
4817: PPUSH
4818: CALL 69900 0 5
// powellBomb := CreateVehicle ;
4822: LD_ADDR_EXP 63
4826: PUSH
4827: CALL_OW 45
4831: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4832: LD_EXP 63
4836: PPUSH
4837: LD_INT 90
4839: PPUSH
4840: LD_INT 51
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 48
// end ;
4850: LD_VAR 0 1
4854: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4855: LD_INT 0
4857: PPUSH
4858: PPUSH
4859: PPUSH
// if IsLive ( kozlov_fac ) then
4860: LD_INT 332
4862: PPUSH
4863: CALL_OW 300
4867: IFFALSE 4871
// exit ;
4869: GO 5438
// ComExitBuilding ( Kozlov ) ;
4871: LD_EXP 61
4875: PPUSH
4876: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4880: LD_EXP 61
4884: PPUSH
4885: CALL_OW 257
4889: PUSH
4890: LD_INT 2
4892: NONEQUAL
4893: IFFALSE 4928
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4895: LD_EXP 61
4899: PPUSH
4900: LD_INT 324
4902: PPUSH
4903: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4907: LD_EXP 61
4911: PPUSH
4912: LD_INT 2
4914: PPUSH
4915: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4919: LD_EXP 61
4923: PPUSH
4924: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4928: LD_EXP 61
4932: PPUSH
4933: LD_INT 2
4935: PPUSH
4936: LD_INT 93
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4956: LD_INT 22
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 3
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PUSH
4986: LD_INT 57
4988: PUSH
4989: EMPTY
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: IFFALSE 4949
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 8
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 3
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 23
5031: PUSH
5032: LD_INT 3
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 57
5041: PUSH
5042: EMPTY
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 1
5058: ARRAY
5059: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5060: LD_INT 22
5062: PUSH
5063: LD_INT 8
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 3
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 21
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 69
5099: NOT
5100: IFFALSE 5178
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5102: LD_EXP 61
5106: PPUSH
5107: LD_INT 21
5109: PPUSH
5110: LD_INT 97
5112: PPUSH
5113: LD_INT 36
5115: PPUSH
5116: LD_INT 5
5118: PPUSH
5119: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5130: LD_INT 22
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 23
5142: PUSH
5143: LD_INT 3
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 30
5152: PUSH
5153: LD_INT 21
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 57
5162: PUSH
5163: EMPTY
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: IFFALSE 5123
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5178: LD_INT 22
5180: PUSH
5181: LD_INT 8
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: LD_INT 23
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 30
5200: PUSH
5201: LD_INT 18
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 69
5217: NOT
5218: IFFALSE 5296
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5220: LD_EXP 61
5224: PPUSH
5225: LD_INT 18
5227: PPUSH
5228: LD_INT 89
5230: PPUSH
5231: LD_INT 32
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5241: LD_INT 35
5243: PPUSH
5244: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5248: LD_INT 22
5250: PUSH
5251: LD_INT 8
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: LD_INT 23
5260: PUSH
5261: LD_INT 3
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: LD_INT 18
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 57
5280: PUSH
5281: EMPTY
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 69
5294: IFFALSE 5241
// end ; lab := kozlov_lab ;
5296: LD_ADDR_VAR 0 3
5300: PUSH
5301: LD_INT 336
5303: ST_TO_ADDR
// if not lab then
5304: LD_VAR 0 3
5308: NOT
5309: IFFALSE 5313
// exit ;
5311: GO 5438
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5313: LD_EXP 61
5317: PPUSH
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 1
5325: ARRAY
5326: PPUSH
5327: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5331: LD_EXP 61
5335: PPUSH
5336: LD_INT 4
5338: PPUSH
5339: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: LD_INT 25
5354: PPUSH
5355: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5359: LD_INT 35
5361: PPUSH
5362: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5366: LD_INT 25
5368: PPUSH
5369: LD_INT 8
5371: PPUSH
5372: CALL_OW 321
5376: PUSH
5377: LD_INT 2
5379: EQUAL
5380: IFFALSE 5359
// ComExitBuilding ( Kozlov ) ;
5382: LD_EXP 61
5386: PPUSH
5387: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5391: LD_EXP 61
5395: PPUSH
5396: LD_VAR 0 2
5400: PPUSH
5401: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5405: LD_EXP 61
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_INT 23
5424: PPUSH
5425: LD_INT 3
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 48
5433: PPUSH
5434: CALL_OW 125
// end ;
5438: LD_VAR 0 1
5442: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5443: LD_EXP 22
5447: NOT
5448: PUSH
5449: LD_EXP 15
5453: PUSH
5454: LD_INT 6
5456: GREATEREQUAL
5457: AND
5458: IFFALSE 5539
5460: GO 5462
5462: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5463: LD_INT 3
5465: PPUSH
5466: LD_INT 3
5468: PPUSH
5469: CALL 58869 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5473: LD_INT 3
5475: PPUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 14
5496: PUSH
5497: LD_INT 1
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 28
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 14
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 28
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 58732 0 2
// end ;
5539: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5540: LD_EXP 22
5544: NOT
5545: PUSH
5546: LD_EXP 15
5550: PUSH
5551: LD_INT 6
5553: GREATEREQUAL
5554: AND
5555: PUSH
5556: LD_INT 3
5558: PPUSH
5559: LD_INT 1
5561: PPUSH
5562: CALL 60150 0 2
5566: NOT
5567: AND
5568: IFFALSE 6408
5570: GO 5572
5572: DISABLE
5573: LD_INT 0
5575: PPUSH
5576: PPUSH
5577: PPUSH
// begin enable ;
5578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5579: LD_INT 22
5581: PUSH
5582: LD_INT 8
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 23
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 6408
// if Prob ( 40 ) then
5623: LD_INT 40
5625: PPUSH
5626: CALL_OW 13
5630: IFFALSE 5757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5632: LD_INT 3
5634: PPUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 28
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PPUSH
5751: CALL 58732 0 2
// end else
5755: GO 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 14
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 27
5771: PUSH
5772: LD_INT 26
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_OWVAR 67
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 14
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 27
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: PUSH
5853: LD_OWVAR 67
5857: ARRAY
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: PUSH
5865: LD_INT 13
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: LD_INT 2
5873: PUSH
5874: LD_INT 26
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: LD_INT 29
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 13
5902: PUSH
5903: LD_INT 1
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: LD_INT 29
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 14
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: LD_INT 26
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL 58732 0 2
// end ; repeat wait ( 0 0$1 ) ;
5948: LD_INT 35
5950: PPUSH
5951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5955: LD_INT 3
5957: PPUSH
5958: LD_INT 1
5960: PPUSH
5961: CALL 60150 0 2
5965: PUSH
5966: LD_INT 6
5968: GREATEREQUAL
5969: IFFALSE 5948
// wait ( 0 0$30 ) ;
5971: LD_INT 1050
5973: PPUSH
5974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_INT 3
5985: PPUSH
5986: LD_INT 1
5988: PPUSH
5989: CALL 60150 0 2
5993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5994: LD_ADDR_EXP 129
5998: PUSH
5999: LD_EXP 129
6003: PPUSH
6004: LD_INT 3
6006: PPUSH
6007: LD_EXP 129
6011: PUSH
6012: LD_INT 3
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 2
6020: DIFF
6021: PPUSH
6022: CALL_OW 1
6026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6027: LD_ADDR_VAR 0 3
6031: PUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: CALL_OW 12
6042: ST_TO_ADDR
// if target then
6043: LD_VAR 0 3
6047: IFFALSE 6175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 24
6061: PUSH
6062: LD_INT 250
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i in tmp do
6074: LD_ADDR_VAR 0 1
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: FOR_IN
6085: IFFALSE 6125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6087: LD_VAR 0 1
6091: PPUSH
6092: LD_INT 89
6094: PPUSH
6095: LD_INT 71
6097: PPUSH
6098: CALL_OW 297
6102: PUSH
6103: LD_INT 9
6105: GREATER
6106: IFFALSE 6123
// ComMoveXY ( i , 89 , 71 ) ;
6108: LD_VAR 0 1
6112: PPUSH
6113: LD_INT 89
6115: PPUSH
6116: LD_INT 71
6118: PPUSH
6119: CALL_OW 111
6123: GO 6084
6125: POP
6126: POP
// wait ( 0 0$1 ) ;
6127: LD_INT 35
6129: PPUSH
6130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: LD_INT 92
6141: PUSH
6142: LD_INT 89
6144: PUSH
6145: LD_INT 71
6147: PUSH
6148: LD_INT 9
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 72
6161: PUSH
6162: LD_VAR 0 2
6166: PUSH
6167: LD_INT 1
6169: MINUS
6170: GREATEREQUAL
6171: IFFALSE 6049
// end else
6173: GO 6299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_VAR 0 2
6184: PPUSH
6185: LD_INT 24
6187: PUSH
6188: LD_INT 250
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 72
6199: ST_TO_ADDR
// for i in tmp do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_IN
6211: IFFALSE 6251
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 125
6220: PPUSH
6221: LD_INT 129
6223: PPUSH
6224: CALL_OW 297
6228: PUSH
6229: LD_INT 9
6231: GREATER
6232: IFFALSE 6249
// ComMoveXY ( i , 125 , 129 ) ;
6234: LD_VAR 0 1
6238: PPUSH
6239: LD_INT 125
6241: PPUSH
6242: LD_INT 129
6244: PPUSH
6245: CALL_OW 111
6249: GO 6210
6251: POP
6252: POP
// wait ( 0 0$1 ) ;
6253: LD_INT 35
6255: PPUSH
6256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 92
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 129
6273: PUSH
6274: LD_INT 9
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PPUSH
6283: CALL_OW 72
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: LD_INT 1
6295: MINUS
6296: GREATEREQUAL
6297: IFFALSE 6175
// end ; repeat wait ( 0 0$1 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// for i in tmp do
6306: LD_ADDR_VAR 0 1
6310: PUSH
6311: LD_VAR 0 2
6315: PUSH
6316: FOR_IN
6317: IFFALSE 6399
// begin if GetLives ( i ) > 251 then
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 256
6328: PUSH
6329: LD_INT 251
6331: GREATER
6332: IFFALSE 6370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_INT 81
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PPUSH
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 74
6363: PPUSH
6364: CALL_OW 115
6368: GO 6397
// if IsDead ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 301
6379: IFFALSE 6397
// tmp := tmp diff i ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PUSH
6391: LD_VAR 0 1
6395: DIFF
6396: ST_TO_ADDR
// end ;
6397: GO 6316
6399: POP
6400: POP
// until not tmp ;
6401: LD_VAR 0 2
6405: NOT
6406: IFFALSE 6299
// end ;
6408: PPOPN 3
6410: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6411: LD_EXP 22
6415: NOT
6416: PUSH
6417: LD_EXP 15
6421: PUSH
6422: LD_INT 6
6424: GREATEREQUAL
6425: AND
6426: PUSH
6427: LD_OWVAR 67
6431: PUSH
6432: LD_INT 1
6434: GREATER
6435: AND
6436: IFFALSE 6953
6438: GO 6440
6440: DISABLE
6441: LD_INT 0
6443: PPUSH
6444: PPUSH
6445: PPUSH
// begin enable ;
6446: ENABLE
// tmp := [ ] ;
6447: LD_ADDR_VAR 0 3
6451: PUSH
6452: EMPTY
6453: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6454: LD_ADDR_VAR 0 1
6458: PUSH
6459: DOUBLE
6460: LD_INT 1
6462: DEC
6463: ST_TO_ADDR
6464: LD_INT 4
6466: PUSH
6467: LD_INT 6
6469: PUSH
6470: LD_INT 7
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_OWVAR 67
6482: ARRAY
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6645
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6503: LD_INT 13
6505: PUSH
6506: LD_INT 14
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_INT 5
6530: PPUSH
6531: LD_INT 27
6533: PUSH
6534: LD_INT 28
6536: PUSH
6537: LD_INT 26
6539: PUSH
6540: LD_INT 25
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 1
6551: PPUSH
6552: LD_INT 4
6554: PPUSH
6555: CALL_OW 12
6559: ARRAY
6560: PPUSH
6561: LD_INT 88
6563: PPUSH
6564: CALL 69900 0 5
// un := CreateVehicle ;
6568: LD_ADDR_VAR 0 2
6572: PUSH
6573: CALL_OW 45
6577: ST_TO_ADDR
// tmp := tmp ^ un ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: ADD
6593: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 30
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6621: LD_VAR 0 2
6625: PPUSH
6626: LD_INT 16
6628: PPUSH
6629: LD_INT 11
6631: PPUSH
6632: CALL_OW 111
// wait ( 0 0$2 ) ;
6636: LD_INT 70
6638: PPUSH
6639: CALL_OW 67
// end ;
6643: GO 6484
6645: POP
6646: POP
// for i = 1 to Difficulty do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_OWVAR 67
6661: PUSH
6662: FOR_TO
6663: IFFALSE 6788
// begin uc_side := 8 ;
6665: LD_ADDR_OWVAR 20
6669: PUSH
6670: LD_INT 8
6672: ST_TO_ADDR
// uc_nation := 2 ;
6673: LD_ADDR_OWVAR 21
6677: PUSH
6678: LD_INT 2
6680: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6681: LD_INT 0
6683: PPUSH
6684: LD_INT 8
6686: PPUSH
6687: LD_INT 8
6689: PUSH
6690: LD_INT 8
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: PUSH
6701: LD_OWVAR 67
6705: ARRAY
6706: PPUSH
6707: CALL_OW 380
// un := CreateHuman ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: CALL_OW 44
6720: ST_TO_ADDR
// tmp := tmp ^ un ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: ADD
6736: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6737: LD_VAR 0 2
6741: PPUSH
6742: LD_INT 3
6744: PPUSH
6745: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 30
6756: PPUSH
6757: LD_INT 0
6759: PPUSH
6760: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6764: LD_VAR 0 2
6768: PPUSH
6769: LD_INT 16
6771: PPUSH
6772: LD_INT 11
6774: PPUSH
6775: CALL_OW 111
// wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// end ;
6786: GO 6662
6788: POP
6789: POP
// repeat wait ( 0 0$1 ) ;
6790: LD_INT 35
6792: PPUSH
6793: CALL_OW 67
// for i in tmp do
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: FOR_IN
6808: IFFALSE 6944
// begin if GetLives ( i ) > 250 then
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 250
6822: GREATER
6823: IFFALSE 6915
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6825: LD_INT 81
6827: PUSH
6828: LD_INT 8
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 91
6837: PUSH
6838: LD_VAR 0 1
6842: PUSH
6843: LD_INT 10
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: NOT
6860: IFFALSE 6879
// ComAgressiveMove ( i , 67 , 110 ) else
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 67
6869: PPUSH
6870: LD_INT 110
6872: PPUSH
6873: CALL_OW 114
6877: GO 6913
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 81
6886: PUSH
6887: LD_INT 8
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: CALL_OW 74
6908: PPUSH
6909: CALL_OW 115
// end else
6913: GO 6942
// if IsDead ( i ) then
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 301
6924: IFFALSE 6942
// tmp := tmp diff i ;
6926: LD_ADDR_VAR 0 3
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 1
6940: DIFF
6941: ST_TO_ADDR
// end ;
6942: GO 6807
6944: POP
6945: POP
// until not tmp ;
6946: LD_VAR 0 3
6950: NOT
6951: IFFALSE 6790
// end ; end_of_file
6953: PPOPN 3
6955: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
// side := 3 ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_INT 3
6974: ST_TO_ADDR
// uc_side := side ;
6975: LD_ADDR_OWVAR 20
6979: PUSH
6980: LD_VAR 0 6
6984: ST_TO_ADDR
// uc_nation := 3 ;
6985: LD_ADDR_OWVAR 21
6989: PUSH
6990: LD_INT 3
6992: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_VAR 0 6
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 21
7012: PUSH
7013: LD_INT 3
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 69
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetBLevel ( i , 10 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 10
7039: PPUSH
7040: CALL_OW 241
7044: GO 7029
7046: POP
7047: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7048: LD_ADDR_VAR 0 9
7052: PUSH
7053: LD_INT 22
7055: PUSH
7056: LD_VAR 0 6
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 34
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PPUSH
7079: CALL_OW 69
7083: ST_TO_ADDR
// if teleport then
7084: LD_VAR 0 9
7088: IFFALSE 7109
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7090: LD_VAR 0 9
7094: PUSH
7095: LD_INT 1
7097: ARRAY
7098: PPUSH
7099: LD_INT 123
7101: PPUSH
7102: LD_INT 122
7104: PPUSH
7105: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7109: LD_ADDR_EXP 64
7113: PUSH
7114: LD_STRING Platonov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7122: LD_ADDR_EXP 65
7126: PUSH
7127: LD_STRING Kovalyuk
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7135: LD_ADDR_EXP 67
7139: PUSH
7140: LD_STRING Yakotich
7142: PPUSH
7143: LD_EXP 1
7147: NOT
7148: PPUSH
7149: LD_STRING 09_
7151: PPUSH
7152: CALL 65076 0 3
7156: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7157: LD_ADDR_EXP 66
7161: PUSH
7162: LD_STRING Bystrov
7164: PPUSH
7165: CALL_OW 25
7169: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7170: LD_ADDR_EXP 68
7174: PUSH
7175: LD_STRING Gleb
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7183: LD_STRING 03_Cornel
7185: PPUSH
7186: CALL_OW 28
7190: IFFALSE 7238
// begin Bierezov := NewCharacter ( Mikhail ) ;
7192: LD_ADDR_EXP 69
7196: PUSH
7197: LD_STRING Mikhail
7199: PPUSH
7200: CALL_OW 25
7204: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7205: LD_EXP 69
7209: PPUSH
7210: LD_INT 197
7212: PPUSH
7213: LD_INT 111
7215: PPUSH
7216: LD_INT 9
7218: PPUSH
7219: LD_INT 0
7221: PPUSH
7222: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 3
7233: PPUSH
7234: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7238: LD_EXP 64
7242: PPUSH
7243: LD_INT 126
7245: PPUSH
7246: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7250: LD_EXP 65
7254: PPUSH
7255: LD_INT 134
7257: PPUSH
7258: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7262: LD_EXP 67
7266: PPUSH
7267: LD_INT 197
7269: PPUSH
7270: LD_INT 111
7272: PPUSH
7273: LD_INT 9
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7283: LD_EXP 66
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7304: LD_EXP 68
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: LD_INT 126
7332: PPUSH
7333: LD_INT 4
7335: PPUSH
7336: LD_STRING zhukov
7338: PPUSH
7339: LD_INT 9
7341: PUSH
7342: LD_INT 10
7344: PUSH
7345: LD_INT 10
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PUSH
7353: LD_OWVAR 67
7357: ARRAY
7358: PPUSH
7359: LD_INT 90000
7361: PUSH
7362: LD_INT 1000
7364: PUSH
7365: LD_INT 300
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PPUSH
7373: LD_INT 18
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: LD_INT 13
7381: PUSH
7382: LD_INT 8
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PPUSH
7391: CALL 73309 0 6
7395: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7396: LD_ADDR_VAR 0 4
7400: PUSH
7401: LD_INT 267
7403: PPUSH
7404: CALL_OW 274
7408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 1
7416: PPUSH
7417: LD_INT 5000
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7439: LD_VAR 0 4
7443: PPUSH
7444: LD_INT 3
7446: PPUSH
7447: LD_INT 200
7449: PPUSH
7450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7454: LD_ADDR_EXP 110
7458: PUSH
7459: LD_EXP 110
7463: PPUSH
7464: LD_INT 2
7466: PPUSH
7467: LD_VAR 0 5
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_VAR 0 6
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 21
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: UNION
7510: PUSH
7511: LD_EXP 64
7515: DIFF
7516: PPUSH
7517: CALL_OW 1
7521: ST_TO_ADDR
// behemoths := [ ] ;
7522: LD_ADDR_EXP 72
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// behemothBuilders := [ ] ;
7529: LD_ADDR_EXP 73
7533: PUSH
7534: EMPTY
7535: ST_TO_ADDR
// if Kovalyuk then
7536: LD_EXP 65
7540: IFFALSE 7562
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7542: LD_ADDR_EXP 73
7546: PUSH
7547: LD_EXP 73
7551: PPUSH
7552: LD_EXP 65
7556: PPUSH
7557: CALL 100946 0 2
7561: ST_TO_ADDR
// j := 3 ;
7562: LD_ADDR_VAR 0 3
7566: PUSH
7567: LD_INT 3
7569: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 25
7587: PUSH
7588: LD_INT 3
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: PUSH
7604: LD_EXP 65
7608: DIFF
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7661
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7613: LD_ADDR_EXP 73
7617: PUSH
7618: LD_EXP 73
7622: PPUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: CALL 100946 0 2
7632: ST_TO_ADDR
// j := j - 1 ;
7633: LD_ADDR_VAR 0 3
7637: PUSH
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 1
7645: MINUS
7646: ST_TO_ADDR
// if j = 0 then
7647: LD_VAR 0 3
7651: PUSH
7652: LD_INT 0
7654: EQUAL
7655: IFFALSE 7659
// break ;
7657: GO 7661
// end ;
7659: GO 7610
7661: POP
7662: POP
// end ;
7663: LD_VAR 0 1
7667: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7668: LD_INT 0
7670: PPUSH
7671: PPUSH
7672: PPUSH
7673: PPUSH
7674: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 209
7682: PUSH
7683: LD_INT 149
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 219
7692: PUSH
7693: LD_INT 154
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 223
7702: PUSH
7703: LD_INT 149
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 232
7712: PUSH
7713: LD_INT 155
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: ST_TO_ADDR
// if not behemothBuilders then
7726: LD_EXP 73
7730: NOT
7731: IFFALSE 7735
// exit ;
7733: GO 7839
// j := 1 ;
7735: LD_ADDR_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ST_TO_ADDR
// for i in behemothBuilders do
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_EXP 73
7752: PUSH
7753: FOR_IN
7754: IFFALSE 7837
// begin if IsInUnit ( i ) then
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 310
7765: IFFALSE 7776
// ComExitBuilding ( i ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 37
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 1
7797: ARRAY
7798: PPUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 3
7808: ARRAY
7809: PUSH
7810: LD_INT 2
7812: ARRAY
7813: PPUSH
7814: LD_INT 0
7816: PPUSH
7817: CALL_OW 230
// j := j + 1 ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_VAR 0 3
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7753
7837: POP
7838: POP
// end ;
7839: LD_VAR 0 1
7843: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7844: LD_INT 24
7846: PPUSH
7847: LD_INT 30
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 70
7861: IFFALSE 7874
7863: GO 7865
7865: DISABLE
// behemothUnderConstruct := true ;
7866: LD_ADDR_EXP 26
7870: PUSH
7871: LD_INT 1
7873: ST_TO_ADDR
7874: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7875: LD_INT 3
7877: PPUSH
7878: CALL 100994 0 1
7882: PUSH
7883: LD_INT 22
7885: PUSH
7886: LD_INT 3
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: LD_INT 30
7895: PUSH
7896: LD_INT 37
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: NOT
7912: AND
7913: IFFALSE 8099
7915: GO 7917
7917: DISABLE
7918: LD_INT 0
7920: PPUSH
7921: PPUSH
// begin enable ;
7922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7923: LD_ADDR_VAR 0 2
7927: PUSH
7928: LD_INT 3
7930: PPUSH
7931: CALL 100994 0 1
7935: ST_TO_ADDR
// for i in tmp do
7936: LD_ADDR_VAR 0 1
7940: PUSH
7941: LD_VAR 0 2
7945: PUSH
7946: FOR_IN
7947: IFFALSE 8097
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 9
7956: PPUSH
7957: CALL_OW 308
7961: PUSH
7962: LD_VAR 0 1
7966: PPUSH
7967: CALL_OW 110
7971: PUSH
7972: LD_INT 2
7974: EQUAL
7975: NOT
7976: AND
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7991: LD_INT 81
7993: PUSH
7994: LD_INT 3
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 91
8003: PUSH
8004: LD_VAR 0 1
8008: PUSH
8009: LD_INT 12
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: NOT
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8061
// ComAgressiveMove ( i , 64 , 93 ) else
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 64
8051: PPUSH
8052: LD_INT 93
8054: PPUSH
8055: CALL_OW 114
8059: GO 8095
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8061: LD_VAR 0 1
8065: PPUSH
8066: LD_INT 81
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: PPUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 74
8090: PPUSH
8091: CALL_OW 115
// end ;
8095: GO 7946
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
8106: PPUSH
// result := [ ] ;
8107: LD_ADDR_VAR 0 2
8111: PUSH
8112: EMPTY
8113: ST_TO_ADDR
// uc_side := 6 ;
8114: LD_ADDR_OWVAR 20
8118: PUSH
8119: LD_INT 6
8121: ST_TO_ADDR
// uc_nation := 3 ;
8122: LD_ADDR_OWVAR 21
8126: PUSH
8127: LD_INT 3
8129: ST_TO_ADDR
// case strength of 1 :
8130: LD_VAR 0 1
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8281
8143: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8144: LD_ADDR_VAR 0 3
8148: PUSH
8149: DOUBLE
8150: LD_INT 1
8152: DEC
8153: ST_TO_ADDR
8154: LD_INT 4
8156: PUSH
8157: LD_INT 5
8159: PUSH
8160: LD_INT 6
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_OWVAR 67
8172: ARRAY
8173: PUSH
8174: FOR_TO
8175: IFFALSE 8277
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8177: LD_INT 22
8179: PUSH
8180: LD_INT 24
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 2
8194: MOD
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: ARRAY
8200: PPUSH
8201: LD_INT 1
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_INT 2
8216: PPUSH
8217: CALL_OW 12
8221: ARRAY
8222: PPUSH
8223: LD_INT 3
8225: PPUSH
8226: LD_INT 43
8228: PUSH
8229: LD_INT 44
8231: PUSH
8232: LD_INT 45
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 3
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 80
8254: PPUSH
8255: CALL 69900 0 5
// result := result union CreateVehicle ;
8259: LD_ADDR_VAR 0 2
8263: PUSH
8264: LD_VAR 0 2
8268: PUSH
8269: CALL_OW 45
8273: UNION
8274: ST_TO_ADDR
// end ;
8275: GO 8174
8277: POP
8278: POP
// end ; 2 :
8279: GO 9232
8281: LD_INT 2
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8445
8289: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_OWVAR 67
8318: ARRAY
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8323: LD_INT 22
8325: PUSH
8326: LD_INT 24
8328: PUSH
8329: LD_INT 24
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 3
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: LD_INT 44
8387: PUSH
8388: LD_INT 46
8390: PUSH
8391: LD_INT 46
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 6
8409: MOD
8410: PUSH
8411: LD_INT 1
8413: PLUS
8414: ARRAY
8415: PPUSH
8416: LD_INT 80
8418: PPUSH
8419: CALL 69900 0 5
// result := result union CreateVehicle ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: CALL_OW 45
8437: UNION
8438: ST_TO_ADDR
// end ;
8439: GO 8320
8441: POP
8442: POP
// end ; 3 :
8443: GO 9232
8445: LD_INT 3
8447: DOUBLE
8448: EQUAL
8449: IFTRUE 8453
8451: GO 8609
8453: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8454: LD_ADDR_VAR 0 3
8458: PUSH
8459: DOUBLE
8460: LD_INT 1
8462: DEC
8463: ST_TO_ADDR
8464: LD_INT 5
8466: PUSH
8467: LD_INT 7
8469: PUSH
8470: LD_INT 8
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: FOR_TO
8485: IFFALSE 8605
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8487: LD_INT 22
8489: PUSH
8490: LD_INT 24
8492: PUSH
8493: LD_INT 24
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: LIST
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_INT 3
8508: MOD
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PUSH
8518: LD_INT 3
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 1
8527: PPUSH
8528: LD_INT 2
8530: PPUSH
8531: CALL_OW 12
8535: ARRAY
8536: PPUSH
8537: LD_INT 3
8539: PPUSH
8540: LD_INT 43
8542: PUSH
8543: LD_INT 47
8545: PUSH
8546: LD_INT 45
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: LD_INT 46
8554: PUSH
8555: LD_INT 46
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: PUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 6
8573: MOD
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: ARRAY
8579: PPUSH
8580: LD_INT 80
8582: PPUSH
8583: CALL 69900 0 5
// result := result union CreateVehicle ;
8587: LD_ADDR_VAR 0 2
8591: PUSH
8592: LD_VAR 0 2
8596: PUSH
8597: CALL_OW 45
8601: UNION
8602: ST_TO_ADDR
// end ;
8603: GO 8484
8605: POP
8606: POP
// end ; 4 :
8607: GO 9232
8609: LD_INT 4
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 9231
8617: POP
// begin uc_nation := 3 ;
8618: LD_ADDR_OWVAR 21
8622: PUSH
8623: LD_INT 3
8625: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8626: LD_ADDR_VAR 0 3
8630: PUSH
8631: DOUBLE
8632: LD_INT 1
8634: DEC
8635: ST_TO_ADDR
8636: LD_INT 6
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 9
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: FOR_TO
8657: IFFALSE 8777
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8659: LD_INT 22
8661: PUSH
8662: LD_INT 24
8664: PUSH
8665: LD_INT 24
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: LD_INT 3
8680: MOD
8681: PUSH
8682: LD_INT 1
8684: PLUS
8685: ARRAY
8686: PPUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ARRAY
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 47
8717: PUSH
8718: LD_INT 47
8720: PUSH
8721: LD_INT 45
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: LD_INT 46
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 6
8745: MOD
8746: PUSH
8747: LD_INT 1
8749: PLUS
8750: ARRAY
8751: PPUSH
8752: LD_INT 80
8754: PPUSH
8755: CALL 69900 0 5
// result := result union CreateVehicle ;
8759: LD_ADDR_VAR 0 2
8763: PUSH
8764: LD_VAR 0 2
8768: PUSH
8769: CALL_OW 45
8773: UNION
8774: ST_TO_ADDR
// end ;
8775: GO 8656
8777: POP
8778: POP
// if not KappaStatus then
8779: LD_EXP 2
8783: NOT
8784: IFFALSE 9019
// begin uc_nation := 1 ;
8786: LD_ADDR_OWVAR 21
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// for i = 1 to 3 do
8794: LD_ADDR_VAR 0 3
8798: PUSH
8799: DOUBLE
8800: LD_INT 1
8802: DEC
8803: ST_TO_ADDR
8804: LD_INT 3
8806: PUSH
8807: FOR_TO
8808: IFFALSE 8944
// begin j := rand ( 0 , 1 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 0
8817: PPUSH
8818: LD_INT 1
8820: PPUSH
8821: CALL_OW 12
8825: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8826: LD_INT 3
8828: PUSH
8829: LD_INT 5
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_VAR 0 4
8848: PUSH
8849: LD_INT 1
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: CALL_OW 12
8859: PLUS
8860: ARRAY
8861: PPUSH
8862: LD_INT 1
8864: PUSH
8865: LD_INT 3
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: PUSH
8872: LD_INT 1
8874: PPUSH
8875: LD_INT 2
8877: PPUSH
8878: CALL_OW 12
8882: ARRAY
8883: PPUSH
8884: LD_INT 3
8886: PPUSH
8887: LD_INT 9
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: LD_INT 6
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_VAR 0 4
8905: PUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 12
8916: PLUS
8917: ARRAY
8918: PPUSH
8919: LD_INT 85
8921: PPUSH
8922: CALL 69900 0 5
// result := result union CreateVehicle ;
8926: LD_ADDR_VAR 0 2
8930: PUSH
8931: LD_VAR 0 2
8935: PUSH
8936: CALL_OW 45
8940: UNION
8941: ST_TO_ADDR
// end ;
8942: GO 8807
8944: POP
8945: POP
// if vsevolodFirstAttack then
8946: LD_EXP 24
8950: IFFALSE 9017
// begin vsevolodFirstAttack := false ;
8952: LD_ADDR_EXP 24
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8960: LD_INT 5
8962: PPUSH
8963: LD_INT 3
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 6
8971: PPUSH
8972: LD_INT 100
8974: PPUSH
8975: CALL 69900 0 5
// sewiVeh := CreateVehicle ;
8979: LD_ADDR_EXP 71
8983: PUSH
8984: CALL_OW 45
8988: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8989: LD_EXP 71
8993: PPUSH
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 242
// result := result union sewiVeh ;
9001: LD_ADDR_VAR 0 2
9005: PUSH
9006: LD_VAR 0 2
9010: PUSH
9011: LD_EXP 71
9015: UNION
9016: ST_TO_ADDR
// end ; end else
9017: GO 9229
// if vsevolodFirstAttack then
9019: LD_EXP 24
9023: IFFALSE 9229
// begin vsevolodFirstAttack := false ;
9025: LD_ADDR_EXP 24
9029: PUSH
9030: LD_INT 0
9032: ST_TO_ADDR
// uc_nation := 3 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 3
9040: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 2
9053: PUSH
9054: LD_OWVAR 67
9058: PLUS
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9169
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9063: LD_INT 22
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 24
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 3
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: PPUSH
9091: LD_INT 1
9093: PUSH
9094: LD_INT 3
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 2
9106: PPUSH
9107: CALL_OW 12
9111: ARRAY
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 45
9118: PUSH
9119: LD_INT 47
9121: PUSH
9122: LD_INT 47
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 80
9146: PPUSH
9147: CALL 69900 0 5
// result := result union CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: LD_VAR 0 2
9160: PUSH
9161: CALL_OW 45
9165: UNION
9166: ST_TO_ADDR
// end ;
9167: GO 9060
9169: POP
9170: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9171: LD_INT 24
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: LD_INT 47
9182: PPUSH
9183: LD_INT 100
9185: PPUSH
9186: CALL 69900 0 5
// sewiVeh := CreateVehicle ;
9190: LD_ADDR_EXP 71
9194: PUSH
9195: CALL_OW 45
9199: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9200: LD_EXP 71
9204: PPUSH
9205: LD_INT 6
9207: NEG
9208: PPUSH
9209: CALL_OW 242
// result := result union sewiVeh ;
9213: LD_ADDR_VAR 0 2
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_EXP 71
9227: UNION
9228: ST_TO_ADDR
// end ; end ; end ;
9229: GO 9232
9231: POP
// end ;
9232: LD_VAR 0 2
9236: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9237: LD_EXP 16
9241: IFFALSE 10082
9243: GO 9245
9245: DISABLE
9246: LD_INT 0
9248: PPUSH
9249: PPUSH
9250: PPUSH
9251: PPUSH
9252: PPUSH
9253: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9254: LD_ADDR_VAR 0 4
9258: PUSH
9259: LD_INT 11
9261: PUSH
9262: LD_INT 12
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9269: LD_ADDR_VAR 0 3
9273: PUSH
9274: LD_INT 11550
9276: PUSH
9277: LD_INT 10150
9279: PUSH
9280: LD_INT 9800
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_OWVAR 67
9292: ARRAY
9293: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9294: LD_ADDR_VAR 0 6
9298: PUSH
9299: LD_INT 70
9301: PUSH
9302: LD_INT 118
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: LD_INT 78
9311: PUSH
9312: LD_INT 31
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: ST_TO_ADDR
// repeat if missionStage = 2 then
9323: LD_EXP 15
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9342
// wait ( 1 1$30 ) else
9333: LD_INT 3150
9335: PPUSH
9336: CALL_OW 67
9340: GO 9351
// wait ( time ) ;
9342: LD_VAR 0 3
9346: PPUSH
9347: CALL_OW 67
// if missionStage = 6 then
9351: LD_EXP 15
9355: PUSH
9356: LD_INT 6
9358: EQUAL
9359: IFFALSE 9387
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9361: LD_INT 51
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: LD_INT 2
9369: PPUSH
9370: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9374: LD_INT 57
9376: PPUSH
9377: LD_INT 6
9379: PPUSH
9380: LD_INT 2
9382: PPUSH
9383: CALL_OW 322
// end ; if missionStage = 8 then
9387: LD_EXP 15
9391: PUSH
9392: LD_INT 8
9394: EQUAL
9395: IFFALSE 9423
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9397: LD_INT 52
9399: PPUSH
9400: LD_INT 6
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9410: LD_INT 58
9412: PPUSH
9413: LD_INT 6
9415: PPUSH
9416: LD_INT 2
9418: PPUSH
9419: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9423: LD_EXP 15
9427: PUSH
9428: LD_INT 10
9430: EQUAL
9431: PUSH
9432: LD_OWVAR 67
9436: PUSH
9437: LD_INT 1
9439: GREATER
9440: AND
9441: IFFALSE 9469
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9443: LD_INT 53
9445: PPUSH
9446: LD_INT 6
9448: PPUSH
9449: LD_INT 2
9451: PPUSH
9452: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9456: LD_INT 59
9458: PPUSH
9459: LD_INT 6
9461: PPUSH
9462: LD_INT 2
9464: PPUSH
9465: CALL_OW 322
// end ; if activeAttacks then
9469: LD_EXP 16
9473: IFFALSE 10076
// begin if missionStage = 2 then
9475: LD_EXP 15
9479: PUSH
9480: LD_INT 2
9482: EQUAL
9483: IFFALSE 9493
// strength := 1 ;
9485: LD_ADDR_VAR 0 5
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// if missionStage > 2 then
9493: LD_EXP 15
9497: PUSH
9498: LD_INT 2
9500: GREATER
9501: IFFALSE 9511
// strength := 2 ;
9503: LD_ADDR_VAR 0 5
9507: PUSH
9508: LD_INT 2
9510: ST_TO_ADDR
// if missionStage > 6 then
9511: LD_EXP 15
9515: PUSH
9516: LD_INT 6
9518: GREATER
9519: IFFALSE 9529
// strength := 3 ;
9521: LD_ADDR_VAR 0 5
9525: PUSH
9526: LD_INT 3
9528: ST_TO_ADDR
// if missionStage > 10 then
9529: LD_EXP 15
9533: PUSH
9534: LD_INT 10
9536: GREATER
9537: IFFALSE 9547
// strength := 4 ;
9539: LD_ADDR_VAR 0 5
9543: PUSH
9544: LD_INT 4
9546: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9547: LD_ADDR_VAR 0 2
9551: PUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: CALL 8102 0 1
9561: ST_TO_ADDR
// for i in tmp do
9562: LD_ADDR_VAR 0 1
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: FOR_IN
9573: IFFALSE 9756
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9575: LD_VAR 0 1
9579: PPUSH
9580: LD_VAR 0 4
9584: PUSH
9585: LD_INT 1
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 12
9595: ARRAY
9596: PPUSH
9597: LD_INT 0
9599: PPUSH
9600: CALL_OW 49
// if i = sewiVeh then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 71
9613: EQUAL
9614: IFFALSE 9651
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9616: LD_ADDR_EXP 70
9620: PUSH
9621: LD_STRING Vsevolod
9623: PPUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_STRING 
9629: PPUSH
9630: CALL 65076 0 3
9634: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9635: LD_EXP 70
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 52
// end else
9649: GO 9732
// if GetControl ( i ) = control_manual then
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 263
9660: PUSH
9661: LD_INT 1
9663: EQUAL
9664: IFFALSE 9732
// begin uc_side := 6 ;
9666: LD_ADDR_OWVAR 20
9670: PUSH
9671: LD_INT 6
9673: ST_TO_ADDR
// uc_nation := 3 ;
9674: LD_ADDR_OWVAR 21
9678: PUSH
9679: LD_INT 3
9681: ST_TO_ADDR
// hc_gallery :=  ;
9682: LD_ADDR_OWVAR 33
9686: PUSH
9687: LD_STRING 
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9698: LD_INT 0
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: LD_INT 10
9706: PPUSH
9707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9711: CALL_OW 44
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9725: LD_INT 10
9727: PPUSH
9728: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: LD_INT 111
9739: PPUSH
9740: LD_INT 197
9742: PPUSH
9743: CALL_OW 111
// wait ( 0 0$2 ) ;
9747: LD_INT 70
9749: PPUSH
9750: CALL_OW 67
// end ;
9754: GO 9572
9756: POP
9757: POP
// repeat wait ( 0 0$1 ) ;
9758: LD_INT 35
9760: PPUSH
9761: CALL_OW 67
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 10057
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9778: LD_INT 81
9780: PUSH
9781: LD_INT 6
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 91
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_INT 12
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9870
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 81
9821: PUSH
9822: LD_INT 6
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 91
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_INT 12
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 74
9863: PPUSH
9864: CALL_OW 115
9868: GO 10055
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9870: LD_INT 9
9872: PPUSH
9873: LD_INT 81
9875: PUSH
9876: LD_INT 6
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PPUSH
9883: CALL_OW 70
9887: IFFALSE 10021
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 6
9898: PUSH
9899: LD_INT 1
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 6
9911: PUSH
9912: LD_INT 1
9914: ARRAY
9915: PUSH
9916: LD_INT 2
9918: ARRAY
9919: PPUSH
9920: CALL_OW 297
9924: PUSH
9925: LD_INT 10
9927: GREATER
9928: PUSH
9929: LD_VAR 0 1
9933: PPUSH
9934: LD_INT 9
9936: PPUSH
9937: CALL_OW 308
9941: NOT
9942: AND
9943: IFFALSE 9982
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_VAR 0 6
9954: PUSH
9955: LD_INT 1
9957: ARRAY
9958: PUSH
9959: LD_INT 1
9961: ARRAY
9962: PPUSH
9963: LD_VAR 0 6
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PUSH
9972: LD_INT 2
9974: ARRAY
9975: PPUSH
9976: CALL_OW 114
9980: GO 10019
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_INT 9
9989: PPUSH
9990: LD_INT 81
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PPUSH
10000: CALL_OW 70
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 74
10014: PPUSH
10015: CALL_OW 115
// end else
10019: GO 10055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 81
10028: PUSH
10029: LD_INT 6
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 69
10040: PPUSH
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 74
10050: PPUSH
10051: CALL_OW 115
// end ;
10055: GO 9775
10057: POP
10058: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10059: LD_INT 22
10061: PUSH
10062: LD_INT 6
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: NOT
10074: IFFALSE 9758
// end ; until russianDestroyed ;
10076: LD_EXP 21
10080: IFFALSE 9323
// end ;
10082: PPOPN 6
10084: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10085: LD_EXP 21
10089: NOT
10090: PUSH
10091: LD_EXP 15
10095: PUSH
10096: LD_INT 6
10098: GREATEREQUAL
10099: AND
10100: PUSH
10101: LD_INT 2
10103: PPUSH
10104: LD_INT 1
10106: PPUSH
10107: CALL 60150 0 2
10111: NOT
10112: AND
10113: IFFALSE 11069
10115: GO 10117
10117: DISABLE
10118: LD_INT 0
10120: PPUSH
10121: PPUSH
10122: PPUSH
10123: PPUSH
// begin enable ;
10124: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10125: LD_INT 22
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 30
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 69
10153: NOT
10154: IFFALSE 10158
// exit ;
10156: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10158: LD_ADDR_VAR 0 4
10162: PUSH
10163: LD_INT 22
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 30
10175: PUSH
10176: LD_INT 34
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PPUSH
10187: CALL_OW 69
10191: ST_TO_ADDR
// if Prob ( 40 ) then
10192: LD_INT 40
10194: PPUSH
10195: CALL_OW 13
10199: IFFALSE 10326
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 49
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 22
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 49
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 22
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 49
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 24
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 24
10278: PUSH
10279: LD_INT 3
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 24
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 46
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL 58732 0 2
// end else
10324: GO 10449
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 24
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 47
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 24
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 47
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 24
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 47
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 24
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 46
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 24
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 46
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 24
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 46
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PPUSH
10445: CALL 58732 0 2
// end ; if Difficulty > 1 then
10449: LD_OWVAR 67
10453: PUSH
10454: LD_INT 1
10456: GREATER
10457: IFFALSE 10487
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 47
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: PPUSH
10483: CALL 58732 0 2
// repeat wait ( 0 0$1 ) ;
10487: LD_INT 35
10489: PPUSH
10490: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10494: LD_INT 2
10496: PPUSH
10497: LD_INT 1
10499: PPUSH
10500: CALL 60150 0 2
10504: PUSH
10505: LD_INT 6
10507: PUSH
10508: LD_INT 7
10510: PUSH
10511: LD_INT 7
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: LD_OWVAR 67
10523: ARRAY
10524: GREATEREQUAL
10525: IFFALSE 10487
// wait ( 0 0$30 ) ;
10527: LD_INT 1050
10529: PPUSH
10530: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10534: LD_ADDR_VAR 0 2
10538: PUSH
10539: LD_INT 2
10541: PPUSH
10542: LD_INT 1
10544: PPUSH
10545: CALL 60150 0 2
10549: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10550: LD_ADDR_EXP 129
10554: PUSH
10555: LD_EXP 129
10559: PPUSH
10560: LD_INT 2
10562: PPUSH
10563: LD_EXP 129
10567: PUSH
10568: LD_INT 2
10570: ARRAY
10571: PUSH
10572: LD_VAR 0 2
10576: DIFF
10577: PPUSH
10578: CALL_OW 1
10582: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10583: LD_ADDR_VAR 0 3
10587: PUSH
10588: LD_INT 0
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 12
10598: ST_TO_ADDR
// if target then
10599: LD_VAR 0 3
10603: IFFALSE 10731
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: LD_INT 24
10617: PUSH
10618: LD_INT 250
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 72
10629: ST_TO_ADDR
// for i in tmp do
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: LD_VAR 0 2
10639: PUSH
10640: FOR_IN
10641: IFFALSE 10681
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 139
10650: PPUSH
10651: LD_INT 89
10653: PPUSH
10654: CALL_OW 297
10658: PUSH
10659: LD_INT 9
10661: GREATER
10662: IFFALSE 10679
// ComMoveXY ( i , 139 , 89 ) ;
10664: LD_VAR 0 1
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: LD_INT 89
10674: PPUSH
10675: CALL_OW 111
10679: GO 10640
10681: POP
10682: POP
// wait ( 0 0$1 ) ;
10683: LD_INT 35
10685: PPUSH
10686: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10690: LD_VAR 0 2
10694: PPUSH
10695: LD_INT 92
10697: PUSH
10698: LD_INT 139
10700: PUSH
10701: LD_INT 89
10703: PUSH
10704: LD_INT 9
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 72
10717: PUSH
10718: LD_VAR 0 2
10722: PUSH
10723: LD_INT 1
10725: MINUS
10726: GREATEREQUAL
10727: IFFALSE 10605
// end else
10729: GO 10873
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10731: LD_VAR 0 2
10735: PPUSH
10736: LD_VAR 0 4
10740: PUSH
10741: LD_INT 1
10743: ARRAY
10744: PPUSH
10745: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 250
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 72
10773: ST_TO_ADDR
// for i in tmp do
10774: LD_ADDR_VAR 0 1
10778: PUSH
10779: LD_VAR 0 2
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10825
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 124
10794: PPUSH
10795: LD_INT 139
10797: PPUSH
10798: CALL_OW 297
10802: PUSH
10803: LD_INT 9
10805: GREATER
10806: IFFALSE 10823
// ComMoveXY ( i , 124 , 139 ) ;
10808: LD_VAR 0 1
10812: PPUSH
10813: LD_INT 124
10815: PPUSH
10816: LD_INT 139
10818: PPUSH
10819: CALL_OW 111
10823: GO 10784
10825: POP
10826: POP
// wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_INT 92
10841: PUSH
10842: LD_INT 124
10844: PUSH
10845: LD_INT 139
10847: PUSH
10848: LD_INT 9
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: PUSH
10862: LD_VAR 0 2
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: GREATEREQUAL
10871: IFFALSE 10749
// end ; repeat wait ( 0 0$1 ) ;
10873: LD_INT 35
10875: PPUSH
10876: CALL_OW 67
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 251
10905: GREATER
10906: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 49
10920: EQUAL
10921: IFFALSE 10977
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 2
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 1
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 8
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 112
10975: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_INT 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 8
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10890
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10873
// end ; end_of_file
11069: PPOPN 4
11071: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11072: LD_INT 0
11074: PPUSH
11075: PPUSH
11076: PPUSH
11077: PPUSH
11078: PPUSH
11079: PPUSH
// side := 7 ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 7
11087: ST_TO_ADDR
// uc_side := side ;
11088: LD_ADDR_OWVAR 20
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
// uc_nation := 1 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_VAR 0 5
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: LD_INT 21
11125: PUSH
11126: LD_INT 3
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PPUSH
11137: CALL_OW 69
11141: PUSH
11142: FOR_IN
11143: IFFALSE 11159
// SetBLevel ( i , 10 ) ;
11145: LD_VAR 0 2
11149: PPUSH
11150: LD_INT 10
11152: PPUSH
11153: CALL_OW 241
11157: GO 11142
11159: POP
11160: POP
// base := GetBase ( al_depot ) ;
11161: LD_ADDR_VAR 0 4
11165: PUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 274
11173: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11174: LD_ADDR_VAR 0 6
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_VAR 0 5
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 34
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: ST_TO_ADDR
// if teleport then
11210: LD_VAR 0 6
11214: IFFALSE 11235
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11216: LD_VAR 0 6
11220: PUSH
11221: LD_INT 1
11223: ARRAY
11224: PPUSH
11225: LD_INT 262
11227: PPUSH
11228: LD_INT 119
11230: PPUSH
11231: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: LD_INT 19500
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 2
11257: PPUSH
11258: LD_INT 200
11260: PPUSH
11261: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 650
11275: PPUSH
11276: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11280: LD_ADDR_EXP 74
11284: PUSH
11285: LD_STRING Roth
11287: PPUSH
11288: CALL_OW 25
11292: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11293: LD_ADDR_EXP 75
11297: PUSH
11298: LD_STRING Simms
11300: PPUSH
11301: LD_EXP 1
11305: NOT
11306: PPUSH
11307: LD_STRING 10c_
11309: PPUSH
11310: CALL 65076 0 3
11314: ST_TO_ADDR
// if not Simms then
11315: LD_EXP 75
11319: NOT
11320: IFFALSE 11350
// begin uc_nation := 1 ;
11322: LD_ADDR_OWVAR 21
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11330: LD_INT 2
11332: PPUSH
11333: LD_INT 10
11335: PPUSH
11336: CALL_OW 384
// Simms := CreateHuman ;
11340: LD_ADDR_EXP 75
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// end ; uc_nation := 3 ;
11350: LD_ADDR_OWVAR 21
11354: PUSH
11355: LD_INT 3
11357: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11358: LD_ADDR_EXP 76
11362: PUSH
11363: LD_STRING Kirilenkova
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11371: LD_ADDR_EXP 90
11375: PUSH
11376: LD_STRING Oblukov
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11384: LD_ADDR_EXP 77
11388: PUSH
11389: LD_STRING Dolgov
11391: PPUSH
11392: CALL_OW 25
11396: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11397: LD_ADDR_EXP 78
11401: PUSH
11402: LD_STRING Petrosyan
11404: PPUSH
11405: CALL_OW 25
11409: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11410: LD_ADDR_EXP 89
11414: PUSH
11415: LD_STRING Scholtze
11417: PPUSH
11418: CALL_OW 25
11422: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11423: LD_ADDR_EXP 88
11427: PUSH
11428: LD_STRING Kapitsova
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11436: LD_ADDR_EXP 79
11440: PUSH
11441: LD_STRING Petrovova
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11449: LD_ADDR_EXP 80
11453: PUSH
11454: LD_STRING Kuzmov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11462: LD_ADDR_EXP 87
11466: PUSH
11467: LD_STRING Karamazov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11475: LD_STRING 13_Lipshchin_1
11477: PPUSH
11478: LD_INT 0
11480: PPUSH
11481: CALL_OW 30
11485: IFFALSE 11500
// Lipshchin := NewCharacter ( Lipshchin ) ;
11487: LD_ADDR_EXP 81
11491: PUSH
11492: LD_STRING Lipshchin
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11500: LD_STRING 13_Titov_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Titov := NewCharacter ( Titov ) ;
11512: LD_ADDR_EXP 83
11516: PUSH
11517: LD_STRING Titov
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11525: LD_STRING 13_Gnyevko_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Gnyevko := NewCharacter ( Gnyevko ) ;
11537: LD_ADDR_EXP 82
11541: PUSH
11542: LD_STRING Gnyevko
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11550: LD_STRING 13_Xavier_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Xavier := NewCharacter ( Xavier2 ) ;
11562: LD_ADDR_EXP 84
11566: PUSH
11567: LD_STRING Xavier2
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11575: LD_STRING 13_Belkov_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Belkov := NewCharacter ( Belkov ) ;
11587: LD_ADDR_EXP 85
11591: PUSH
11592: LD_STRING Belkov
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if not BurlakStatus then
11600: LD_EXP 9
11604: NOT
11605: IFFALSE 11620
// Burlak = NewCharacter ( Burlak ) ;
11607: LD_ADDR_EXP 86
11611: PUSH
11612: LD_STRING Burlak
11614: PPUSH
11615: CALL_OW 25
11619: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11620: LD_ADDR_VAR 0 3
11624: PUSH
11625: LD_EXP 74
11629: PUSH
11630: LD_EXP 76
11634: PUSH
11635: LD_EXP 90
11639: PUSH
11640: LD_EXP 77
11644: PUSH
11645: LD_EXP 78
11649: PUSH
11650: LD_EXP 89
11654: PUSH
11655: LD_EXP 88
11659: PUSH
11660: LD_EXP 79
11664: PUSH
11665: LD_EXP 80
11669: PUSH
11670: LD_EXP 87
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: ST_TO_ADDR
// if Simms then
11687: LD_EXP 75
11691: IFFALSE 11709
// tmp := tmp ^ Simms ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_EXP 75
11707: ADD
11708: ST_TO_ADDR
// if Titov then
11709: LD_EXP 83
11713: IFFALSE 11731
// tmp := tmp ^ Titov ;
11715: LD_ADDR_VAR 0 3
11719: PUSH
11720: LD_VAR 0 3
11724: PUSH
11725: LD_EXP 83
11729: ADD
11730: ST_TO_ADDR
// if Lipshchin then
11731: LD_EXP 81
11735: IFFALSE 11753
// tmp := tmp ^ Lipshchin ;
11737: LD_ADDR_VAR 0 3
11741: PUSH
11742: LD_VAR 0 3
11746: PUSH
11747: LD_EXP 81
11751: ADD
11752: ST_TO_ADDR
// if Gnyevko then
11753: LD_EXP 82
11757: IFFALSE 11775
// tmp := tmp ^ Gnyevko ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_VAR 0 3
11768: PUSH
11769: LD_EXP 82
11773: ADD
11774: ST_TO_ADDR
// if Xavier then
11775: LD_EXP 84
11779: IFFALSE 11797
// tmp := tmp ^ Xavier ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: LD_EXP 84
11795: ADD
11796: ST_TO_ADDR
// if Belkov then
11797: LD_EXP 85
11801: IFFALSE 11819
// tmp := tmp ^ Belkov ;
11803: LD_ADDR_VAR 0 3
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_EXP 85
11817: ADD
11818: ST_TO_ADDR
// if Burlak then
11819: LD_EXP 86
11823: IFFALSE 11841
// tmp := tmp ^ Burlak ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_VAR 0 3
11834: PUSH
11835: LD_EXP 86
11839: ADD
11840: ST_TO_ADDR
// for i = 1 to 11 do
11841: LD_ADDR_VAR 0 2
11845: PUSH
11846: DOUBLE
11847: LD_INT 1
11849: DEC
11850: ST_TO_ADDR
11851: LD_INT 11
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11921
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11857: LD_ADDR_OWVAR 21
11861: PUSH
11862: LD_INT 1
11864: PUSH
11865: LD_INT 3
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 1
11874: PPUSH
11875: LD_INT 2
11877: PPUSH
11878: CALL_OW 12
11882: ARRAY
11883: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11884: LD_INT 0
11886: PPUSH
11887: LD_VAR 0 2
11891: PUSH
11892: LD_INT 2
11894: DIV
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11903: LD_ADDR_VAR 0 3
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: CALL_OW 44
11917: ADD
11918: ST_TO_ADDR
// end ;
11919: GO 11854
11921: POP
11922: POP
// for i in tmp do
11923: LD_ADDR_VAR 0 2
11927: PUSH
11928: LD_VAR 0 3
11932: PUSH
11933: FOR_IN
11934: IFFALSE 11959
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11936: LD_VAR 0 2
11940: PPUSH
11941: LD_INT 260
11943: PPUSH
11944: LD_INT 235
11946: PPUSH
11947: LD_INT 8
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 50
11957: GO 11933
11959: POP
11960: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11961: LD_ADDR_EXP 110
11965: PUSH
11966: LD_EXP 110
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: LD_INT 21
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: PUSH
12012: LD_EXP 74
12016: PUSH
12017: LD_EXP 75
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: DIFF
12026: PPUSH
12027: CALL_OW 1
12031: ST_TO_ADDR
// uc_side := 0 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
// uc_nation := 0 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// for i = 1 to 5 do
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: DOUBLE
12054: LD_INT 1
12056: DEC
12057: ST_TO_ADDR
12058: LD_INT 5
12060: PUSH
12061: FOR_TO
12062: IFFALSE 12099
// begin InitHc ;
12064: CALL_OW 19
// hc_class := class_apeman ;
12068: LD_ADDR_OWVAR 28
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12076: CALL_OW 44
12080: PPUSH
12081: LD_INT 299
12083: PPUSH
12084: LD_INT 229
12086: PPUSH
12087: LD_INT 10
12089: PPUSH
12090: LD_INT 0
12092: PPUSH
12093: CALL_OW 50
// end ;
12097: GO 12061
12099: POP
12100: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 259
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12116: LD_EXP 74
12120: PPUSH
12121: LD_INT 262
12123: PPUSH
12124: LD_INT 235
12126: PPUSH
12127: CALL_OW 178
// if Simms then
12131: LD_EXP 75
12135: IFFALSE 12166
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_INT 262
12144: PPUSH
12145: LD_INT 235
12147: PPUSH
12148: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12152: LD_EXP 75
12156: PPUSH
12157: LD_EXP 74
12161: PPUSH
12162: CALL_OW 179
// end ; end ;
12166: LD_VAR 0 1
12170: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12171: LD_EXP 31
12175: PUSH
12176: LD_EXP 23
12180: NOT
12181: AND
12182: IFFALSE 12358
12184: GO 12186
12186: DISABLE
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// begin enable ;
12192: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 81
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 2
12210: PUSH
12211: LD_INT 32
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 30
12233: PUSH
12234: LD_INT 28
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 34
12243: PUSH
12244: LD_INT 49
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 34
12253: PUSH
12254: LD_INT 10
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: LD_INT 34
12263: PUSH
12264: LD_INT 8
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ST_TO_ADDR
// if not tmp then
12289: LD_VAR 0 2
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12358
// target := tmp [ rand ( 1 , tmp ) ] ;
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_VAR 0 2
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 12
12320: ARRAY
12321: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 255
12331: PUSH
12332: LD_INT 1
12334: EQUAL
12335: IFFALSE 12346
// CenterNowOnUnits ( target ) ;
12337: LD_VAR 0 3
12341: PPUSH
12342: CALL_OW 87
// SetLives ( target , 0 ) ;
12346: LD_VAR 0 3
12350: PPUSH
12351: LD_INT 0
12353: PPUSH
12354: CALL_OW 234
// end ;
12358: PPOPN 3
12360: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12361: LD_EXP 23
12365: NOT
12366: PUSH
12367: LD_EXP 31
12371: AND
12372: IFFALSE 12894
12374: GO 12376
12376: DISABLE
12377: LD_INT 0
12379: PPUSH
12380: PPUSH
12381: PPUSH
// begin uc_side := 7 ;
12382: LD_ADDR_OWVAR 20
12386: PUSH
12387: LD_INT 7
12389: ST_TO_ADDR
// uc_nation := 1 ;
12390: LD_ADDR_OWVAR 21
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 125
12405: PUSH
12406: LD_INT 163
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 185
12415: PUSH
12416: LD_INT 168
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 111
12425: PUSH
12426: LD_INT 97
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: PPUSH
12438: CALL 101038 0 1
12442: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12443: LD_ADDR_EXP 91
12447: PUSH
12448: EMPTY
12449: ST_TO_ADDR
// for i = 1 to Difficulty do
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_OWVAR 67
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12624
// begin InitHc ;
12468: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12472: LD_INT 0
12474: PPUSH
12475: LD_INT 8
12477: PPUSH
12478: CALL_OW 381
// un := CreateHuman ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 258
12499: PPUSH
12500: LD_INT 267
12502: PPUSH
12503: LD_INT 4
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12513: LD_ADDR_EXP 91
12517: PUSH
12518: LD_EXP 91
12522: PUSH
12523: LD_VAR 0 2
12527: UNION
12528: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12529: LD_VAR 0 2
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 1
12547: ARRAY
12548: PPUSH
12549: LD_VAR 0 3
12553: PUSH
12554: LD_VAR 0 1
12558: ARRAY
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 4
12566: PPUSH
12567: LD_INT 1
12569: PPUSH
12570: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 1
12592: ARRAY
12593: PPUSH
12594: LD_VAR 0 3
12598: PUSH
12599: LD_VAR 0 1
12603: ARRAY
12604: PUSH
12605: LD_INT 2
12607: ARRAY
12608: PPUSH
12609: CALL_OW 171
// AddComInvisible ( un ) ;
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL_OW 212
// end ;
12622: GO 12465
12624: POP
12625: POP
// repeat wait ( 0 0$20 ) ;
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 67
// for i in allianceSpecialForce do
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_EXP 91
12642: PUSH
12643: FOR_IN
12644: IFFALSE 12879
// begin if IsInvisible ( i ) then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 571
12655: IFFALSE 12848
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12657: LD_ADDR_VAR 0 3
12661: PUSH
12662: LD_INT 22
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 50
12674: PUSH
12675: EMPTY
12676: LIST
12677: PUSH
12678: LD_INT 56
12680: PUSH
12681: EMPTY
12682: LIST
12683: PUSH
12684: LD_INT 91
12686: PUSH
12687: LD_VAR 0 1
12691: PUSH
12692: LD_INT 25
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 35
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 2
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 25
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 25
12742: PUSH
12743: LD_INT 3
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 25
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 25
12762: PUSH
12763: LD_INT 5
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 25
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 3
12805: NOT
12806: IFFALSE 12810
// continue ;
12808: GO 12643
// if Prob ( 30 * Difficulty ) then
12810: LD_INT 30
12812: PUSH
12813: LD_OWVAR 67
12817: MUL
12818: PPUSH
12819: CALL_OW 13
12823: IFFALSE 12848
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_VAR 0 3
12837: PPUSH
12838: CALL_OW 12
12842: ARRAY
12843: PPUSH
12844: CALL 31141 0 1
// end ; if IsDead ( i ) then
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 301
12857: IFFALSE 12877
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12859: LD_ADDR_EXP 91
12863: PUSH
12864: LD_EXP 91
12868: PUSH
12869: LD_VAR 0 1
12873: DIFF
12874: ST_TO_ADDR
// continue ;
12875: GO 12643
// end ; end ;
12877: GO 12643
12879: POP
12880: POP
// until allianceDestroyed or not allianceSpecialForce ;
12881: LD_EXP 23
12885: PUSH
12886: LD_EXP 91
12890: NOT
12891: OR
12892: IFFALSE 12626
// end ;
12894: PPOPN 3
12896: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12897: LD_EXP 23
12901: NOT
12902: PUSH
12903: LD_EXP 31
12907: AND
12908: IFFALSE 13875
12910: GO 12912
12912: DISABLE
12913: LD_INT 0
12915: PPUSH
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12920: LD_INT 22
12922: PUSH
12923: LD_INT 7
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 30
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PPUSH
12944: CALL_OW 69
12948: NOT
12949: IFFALSE 12953
// exit ;
12951: GO 13875
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12953: LD_ADDR_VAR 0 4
12957: PUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 7
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: ST_TO_ADDR
// if Prob ( 40 ) then
12987: LD_INT 40
12989: PPUSH
12990: CALL_OW 13
12994: IFFALSE 13121
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 5
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 6
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 6
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 24
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 45
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 47
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58732 0 2
// end else
13119: GO 13244
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 24
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 47
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 24
13144: PUSH
13145: LD_INT 3
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 47
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 5
13162: PUSH
13163: LD_INT 3
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 5
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: LD_INT 2
13186: PUSH
13187: LD_INT 9
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 24
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: LD_INT 3
13204: PUSH
13205: LD_INT 45
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 45
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: PPUSH
13240: CALL 58732 0 2
// end ; if Difficulty > 1 then
13244: LD_OWVAR 67
13248: PUSH
13249: LD_INT 1
13251: GREATER
13252: IFFALSE 13282
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13254: LD_INT 1
13256: PPUSH
13257: LD_INT 24
13259: PUSH
13260: LD_INT 3
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 47
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: PPUSH
13278: CALL 58732 0 2
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13289: LD_INT 1
13291: PPUSH
13292: LD_INT 1
13294: PPUSH
13295: CALL 60150 0 2
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: PUSH
13314: LD_OWVAR 67
13318: ARRAY
13319: GREATEREQUAL
13320: IFFALSE 13282
// wait ( 0 0$40 ) ;
13322: LD_INT 1400
13324: PPUSH
13325: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13329: LD_ADDR_VAR 0 2
13333: PUSH
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 1
13339: PPUSH
13340: CALL 60150 0 2
13344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13345: LD_ADDR_EXP 129
13349: PUSH
13350: LD_EXP 129
13354: PPUSH
13355: LD_INT 1
13357: PPUSH
13358: LD_EXP 129
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PUSH
13367: LD_VAR 0 2
13371: DIFF
13372: PPUSH
13373: CALL_OW 1
13377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13378: LD_ADDR_VAR 0 3
13382: PUSH
13383: LD_INT 0
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 12
13393: ST_TO_ADDR
// if target then
13394: LD_VAR 0 3
13398: IFFALSE 13564
// begin for i in tmp do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13436
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: LD_INT 179
13420: PPUSH
13421: LD_INT 209
13423: PPUSH
13424: LD_INT 8
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 483
13434: GO 13410
13436: POP
13437: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 250
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PPUSH
13458: CALL_OW 72
13462: ST_TO_ADDR
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13514
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 179
13483: PPUSH
13484: LD_INT 209
13486: PPUSH
13487: CALL_OW 297
13491: PUSH
13492: LD_INT 9
13494: GREATER
13495: IFFALSE 13512
// ComMoveXY ( i , 179 , 209 ) ;
13497: LD_VAR 0 1
13501: PPUSH
13502: LD_INT 179
13504: PPUSH
13505: LD_INT 209
13507: PPUSH
13508: CALL_OW 111
13512: GO 13473
13514: POP
13515: POP
// wait ( 0 0$1 ) ;
13516: LD_INT 35
13518: PPUSH
13519: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: LD_INT 92
13530: PUSH
13531: LD_INT 179
13533: PUSH
13534: LD_INT 209
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: PPUSH
13546: CALL_OW 72
13550: PUSH
13551: LD_VAR 0 2
13555: PUSH
13556: LD_INT 1
13558: MINUS
13559: GREATEREQUAL
13560: IFFALSE 13438
// end else
13562: GO 13726
// begin for i in tmp do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: FOR_IN
13575: IFFALSE 13600
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 285
13584: PPUSH
13585: LD_INT 163
13587: PPUSH
13588: LD_INT 8
13590: PPUSH
13591: LD_INT 1
13593: PPUSH
13594: CALL_OW 483
13598: GO 13574
13600: POP
13601: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13602: LD_ADDR_VAR 0 2
13606: PUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: LD_INT 24
13614: PUSH
13615: LD_INT 250
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13678
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13640: LD_VAR 0 1
13644: PPUSH
13645: LD_INT 285
13647: PPUSH
13648: LD_INT 163
13650: PPUSH
13651: CALL_OW 297
13655: PUSH
13656: LD_INT 9
13658: GREATER
13659: IFFALSE 13676
// ComMoveXY ( i , 285 , 163 ) ;
13661: LD_VAR 0 1
13665: PPUSH
13666: LD_INT 285
13668: PPUSH
13669: LD_INT 163
13671: PPUSH
13672: CALL_OW 111
13676: GO 13637
13678: POP
13679: POP
// wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 92
13694: PUSH
13695: LD_INT 285
13697: PUSH
13698: LD_INT 163
13700: PUSH
13701: LD_INT 9
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 72
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: MINUS
13723: GREATEREQUAL
13724: IFFALSE 13602
// end ; repeat wait ( 0 0$1 ) ;
13726: LD_INT 35
13728: PPUSH
13729: CALL_OW 67
// for i in tmp do
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_VAR 0 2
13742: PUSH
13743: FOR_IN
13744: IFFALSE 13866
// if GetLives ( i ) > 251 then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 256
13755: PUSH
13756: LD_INT 251
13758: GREATER
13759: IFFALSE 13848
// begin if GetWeapon ( i ) = ru_time_lapser then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 264
13770: PUSH
13771: LD_INT 49
13773: EQUAL
13774: IFFALSE 13812
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13776: LD_VAR 0 1
13780: PPUSH
13781: LD_INT 81
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: PPUSH
13796: LD_VAR 0 1
13800: PPUSH
13801: CALL_OW 74
13805: PPUSH
13806: CALL_OW 112
13810: GO 13846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_INT 81
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PPUSH
13827: CALL_OW 69
13831: PPUSH
13832: LD_VAR 0 1
13836: PPUSH
13837: CALL_OW 74
13841: PPUSH
13842: CALL_OW 115
// end else
13846: GO 13864
// tmp := tmp diff i ;
13848: LD_ADDR_VAR 0 2
13852: PUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 1
13862: DIFF
13863: ST_TO_ADDR
13864: GO 13743
13866: POP
13867: POP
// until not tmp ;
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13726
// end ; end_of_file
13875: PPOPN 4
13877: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
13882: PPUSH
13883: PPUSH
// missionStage := 13 ;
13884: LD_ADDR_EXP 15
13888: PUSH
13889: LD_INT 13
13891: ST_TO_ADDR
// uc_side := 2 ;
13892: LD_ADDR_OWVAR 20
13896: PUSH
13897: LD_INT 2
13899: ST_TO_ADDR
// uc_nation := 2 ;
13900: LD_ADDR_OWVAR 21
13904: PUSH
13905: LD_INT 2
13907: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13908: LD_ADDR_EXP 92
13912: PUSH
13913: LD_STRING Omar
13915: PPUSH
13916: CALL_OW 25
13920: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13921: LD_EXP 92
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13933: LD_EXP 92
13937: PPUSH
13938: LD_INT 242
13940: PPUSH
13941: LD_INT 75
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13951: LD_ADDR_EXP 93
13955: PUSH
13956: LD_STRING Heike
13958: PPUSH
13959: CALL_OW 25
13963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13964: LD_INT 14
13966: PPUSH
13967: LD_INT 3
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: LD_INT 27
13975: PPUSH
13976: LD_INT 100
13978: PPUSH
13979: CALL 69900 0 5
// veh := CreateVehicle ;
13983: LD_ADDR_VAR 0 3
13987: PUSH
13988: CALL_OW 45
13992: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13993: LD_VAR 0 3
13997: PPUSH
13998: LD_INT 1
14000: PPUSH
14001: CALL_OW 242
// SetDir ( veh , 4 ) ;
14005: LD_VAR 0 3
14009: PPUSH
14010: LD_INT 4
14012: PPUSH
14013: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 241
14024: PPUSH
14025: LD_INT 72
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14035: LD_EXP 93
14039: PPUSH
14040: LD_VAR 0 3
14044: PPUSH
14045: CALL_OW 52
// if KhatamStatus then
14049: LD_EXP 8
14053: IFFALSE 14104
// begin Khatam := NewCharacter ( Khatam ) ;
14055: LD_ADDR_EXP 94
14059: PUSH
14060: LD_STRING Khatam
14062: PPUSH
14063: CALL_OW 25
14067: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14068: LD_EXP 94
14072: PPUSH
14073: LD_INT 245
14075: PPUSH
14076: LD_INT 78
14078: PPUSH
14079: LD_INT 3
14081: PPUSH
14082: LD_INT 0
14084: PPUSH
14085: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14089: LD_EXP 94
14093: PPUSH
14094: LD_INT 4
14096: PPUSH
14097: LD_INT 10
14099: PPUSH
14100: CALL_OW 237
// end ; for i = 1 to Difficulty do
14104: LD_ADDR_VAR 0 2
14108: PUSH
14109: DOUBLE
14110: LD_INT 1
14112: DEC
14113: ST_TO_ADDR
14114: LD_OWVAR 67
14118: PUSH
14119: FOR_TO
14120: IFFALSE 14186
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 7
14127: PUSH
14128: LD_OWVAR 67
14132: PLUS
14133: PPUSH
14134: CALL_OW 384
// un := CreateHuman ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: CALL_OW 44
14147: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14148: LD_VAR 0 4
14152: PPUSH
14153: LD_INT 28
14155: PUSH
14156: LD_INT 29
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 2
14170: MOD
14171: PUSH
14172: LD_INT 1
14174: PLUS
14175: ARRAY
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14119
14186: POP
14187: POP
// for i = 1 to 6 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 6
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14247
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 7
14209: PUSH
14210: LD_OWVAR 67
14214: PLUS
14215: PPUSH
14216: CALL_OW 381
// un := CreateHuman ;
14220: LD_ADDR_VAR 0 4
14224: PUSH
14225: CALL_OW 44
14229: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_INT 28
14237: PPUSH
14238: LD_INT 0
14240: PPUSH
14241: CALL_OW 49
// end ;
14245: GO 14201
14247: POP
14248: POP
// for i = 1 to 3 do
14249: LD_ADDR_VAR 0 2
14253: PUSH
14254: DOUBLE
14255: LD_INT 1
14257: DEC
14258: ST_TO_ADDR
14259: LD_INT 3
14261: PUSH
14262: FOR_TO
14263: IFFALSE 14311
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14265: LD_INT 0
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 7
14273: PUSH
14274: LD_OWVAR 67
14278: PLUS
14279: PPUSH
14280: CALL_OW 380
// un := CreateHuman ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: CALL_OW 44
14293: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14294: LD_VAR 0 4
14298: PPUSH
14299: LD_INT 28
14301: PPUSH
14302: LD_INT 0
14304: PPUSH
14305: CALL_OW 49
// end ;
14309: GO 14262
14311: POP
14312: POP
// for i = 1 to 3 do
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: DOUBLE
14319: LD_INT 1
14321: DEC
14322: ST_TO_ADDR
14323: LD_INT 3
14325: PUSH
14326: FOR_TO
14327: IFFALSE 14417
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14329: LD_INT 14
14331: PPUSH
14332: LD_INT 2
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_INT 28
14340: PPUSH
14341: LD_INT 80
14343: PPUSH
14344: CALL 69900 0 5
// veh := CreateVehicle ;
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: CALL_OW 45
14357: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 3
14365: PPUSH
14366: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 29
14377: PPUSH
14378: LD_INT 0
14380: PPUSH
14381: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14385: LD_INT 0
14387: PPUSH
14388: LD_INT 7
14390: PUSH
14391: LD_OWVAR 67
14395: PLUS
14396: PPUSH
14397: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14401: CALL_OW 44
14405: PPUSH
14406: LD_VAR 0 3
14410: PPUSH
14411: CALL_OW 52
// end ;
14415: GO 14326
14417: POP
14418: POP
// for i = 1 to 5 + Difficulty do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_INT 5
14431: PUSH
14432: LD_OWVAR 67
14436: PLUS
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14566
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: LD_INT 3
14449: PPUSH
14450: CALL_OW 12
14454: PPUSH
14455: LD_INT 1
14457: PPUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 26
14463: PUSH
14464: LD_INT 27
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: LD_INT 4
14483: MOD
14484: PUSH
14485: LD_INT 1
14487: PLUS
14488: ARRAY
14489: PPUSH
14490: LD_INT 80
14492: PPUSH
14493: CALL 69900 0 5
// veh := CreateVehicle ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: CALL_OW 45
14506: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14507: LD_VAR 0 3
14511: PPUSH
14512: LD_INT 4
14514: PPUSH
14515: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 28
14526: PPUSH
14527: LD_INT 0
14529: PPUSH
14530: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14534: LD_INT 0
14536: PPUSH
14537: LD_INT 7
14539: PUSH
14540: LD_OWVAR 67
14544: PLUS
14545: PPUSH
14546: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14550: CALL_OW 44
14554: PPUSH
14555: LD_VAR 0 3
14559: PPUSH
14560: CALL_OW 52
// end ;
14564: GO 14438
14566: POP
14567: POP
// for i = 1 to 3 do
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: DOUBLE
14574: LD_INT 1
14576: DEC
14577: ST_TO_ADDR
14578: LD_INT 3
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14642
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14584: LD_INT 14
14586: PPUSH
14587: LD_INT 3
14589: PPUSH
14590: LD_INT 5
14592: PPUSH
14593: LD_INT 29
14595: PPUSH
14596: LD_INT 80
14598: PPUSH
14599: CALL 69900 0 5
// veh := CreateVehicle ;
14603: LD_ADDR_VAR 0 3
14607: PUSH
14608: CALL_OW 45
14612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 4
14620: PPUSH
14621: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 28
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// end ;
14640: GO 14581
14642: POP
14643: POP
// end ;
14644: LD_VAR 0 1
14648: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14649: LD_INT 22
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: IFFALSE 14963
14665: GO 14667
14667: DISABLE
14668: LD_INT 0
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 22
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PUSH
14688: LD_INT 25
14690: PUSH
14691: LD_INT 4
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PPUSH
14702: CALL_OW 69
14706: PUSH
14707: LD_EXP 94
14711: DIFF
14712: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14713: LD_ADDR_VAR 0 2
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 94
14737: PUSH
14738: LD_VAR 0 3
14742: UNION
14743: DIFF
14744: ST_TO_ADDR
// if Khatam then
14745: LD_EXP 94
14749: IFFALSE 14766
// ComMoveXY ( Khatam , 211 , 92 ) ;
14751: LD_EXP 94
14755: PPUSH
14756: LD_INT 211
14758: PPUSH
14759: LD_INT 92
14761: PPUSH
14762: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14766: LD_INT 197
14768: PPUSH
14769: LD_INT 80
14771: PPUSH
14772: LD_INT 2
14774: PPUSH
14775: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14779: LD_INT 213
14781: PPUSH
14782: LD_INT 90
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14792: LD_INT 215
14794: PPUSH
14795: LD_INT 129
14797: PPUSH
14798: LD_INT 2
14800: PPUSH
14801: CALL_OW 441
// if sci then
14805: LD_VAR 0 3
14809: IFFALSE 14830
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14811: LD_VAR 0 3
14815: PUSH
14816: LD_INT 1
14818: ARRAY
14819: PPUSH
14820: LD_INT 197
14822: PPUSH
14823: LD_INT 80
14825: PPUSH
14826: CALL_OW 158
// if sci > 1 then
14830: LD_VAR 0 3
14834: PUSH
14835: LD_INT 1
14837: GREATER
14838: IFFALSE 14859
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 2
14847: ARRAY
14848: PPUSH
14849: LD_INT 213
14851: PPUSH
14852: LD_INT 90
14854: PPUSH
14855: CALL_OW 158
// if sci > 2 then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_INT 2
14866: GREATER
14867: IFFALSE 14888
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 3
14876: ARRAY
14877: PPUSH
14878: LD_INT 215
14880: PPUSH
14881: LD_INT 129
14883: PPUSH
14884: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14888: LD_INT 35
14890: PPUSH
14891: CALL_OW 67
// for i in tmp do
14895: LD_ADDR_VAR 0 1
14899: PUSH
14900: LD_VAR 0 2
14904: PUSH
14905: FOR_IN
14906: IFFALSE 14944
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14908: LD_VAR 0 1
14912: PPUSH
14913: LD_INT 81
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: PPUSH
14923: CALL_OW 69
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 74
14937: PPUSH
14938: CALL_OW 115
14942: GO 14905
14944: POP
14945: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14946: LD_INT 22
14948: PUSH
14949: LD_INT 2
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: CALL_OW 69
14960: NOT
14961: IFFALSE 14888
// end ; end_of_file
14963: PPOPN 3
14965: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
// Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 100918 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 7
14991: PPUSH
14992: LD_INT 0
14994: PPUSH
14995: CALL_OW 517
14999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15000: LD_ADDR_VAR 0 2
15004: PUSH
15005: DOUBLE
15006: LD_INT 1
15008: DEC
15009: ST_TO_ADDR
15010: LD_VAR 0 5
15014: PUSH
15015: LD_INT 1
15017: ARRAY
15018: PUSH
15019: FOR_TO
15020: IFFALSE 15065
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 2
15044: ARRAY
15045: PUSH
15046: LD_VAR 0 2
15050: ARRAY
15051: PPUSH
15052: LD_INT 1
15054: PPUSH
15055: LD_INT 15
15057: NEG
15058: PPUSH
15059: CALL 100832 0 4
15063: GO 15019
15065: POP
15066: POP
// CenterNowOnUnits ( Powell ) ;
15067: LD_EXP 58
15071: PPUSH
15072: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: LD_EXP 56
15085: PUSH
15086: EMPTY
15087: LIST
15088: ST_TO_ADDR
// if GirlNewVeh then
15089: LD_EXP 57
15093: IFFALSE 15111
// tmp := tmp ^ GirlNewVeh ;
15095: LD_ADDR_VAR 0 5
15099: PUSH
15100: LD_VAR 0 5
15104: PUSH
15105: LD_EXP 57
15109: ADD
15110: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15111: LD_VAR 0 5
15115: PPUSH
15116: LD_INT 60
15118: PPUSH
15119: LD_INT 109
15121: PPUSH
15122: CALL_OW 111
// if KappaStatus then
15126: LD_EXP 2
15130: IFFALSE 15182
// begin Say ( JMM , D1nT-JMM-1 ) ;
15132: LD_EXP 39
15136: PPUSH
15137: LD_STRING D1nT-JMM-1
15139: PPUSH
15140: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15144: LD_EXP 58
15148: PPUSH
15149: LD_STRING D1T-Pow-1
15151: PPUSH
15152: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15156: LD_EXP 39
15160: PPUSH
15161: LD_STRING D1T-JMM-2
15163: PPUSH
15164: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15168: LD_EXP 58
15172: PPUSH
15173: LD_STRING D1T-Pow-2
15175: PPUSH
15176: CALL_OW 88
// end else
15180: GO 15388
// if JMMGirlStatus then
15182: LD_EXP 6
15186: IFFALSE 15331
// begin Say ( JMM , D1T-JMM-1 ) ;
15188: LD_EXP 39
15192: PPUSH
15193: LD_STRING D1T-JMM-1
15195: PPUSH
15196: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15200: LD_EXP 58
15204: PPUSH
15205: LD_STRING D1T-Pow-1
15207: PPUSH
15208: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-3
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-3
15231: PPUSH
15232: CALL_OW 88
// if JMMGirl then
15236: LD_EXP 7
15240: IFFALSE 15329
// begin case JMMGirl of 1 :
15242: LD_EXP 7
15246: PUSH
15247: LD_INT 1
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15270
15255: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15256: LD_EXP 40
15260: PPUSH
15261: LD_STRING D1T-Joan-3
15263: PPUSH
15264: CALL_OW 88
15268: GO 15317
15270: LD_INT 2
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15293
15278: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15279: LD_EXP 42
15283: PPUSH
15284: LD_STRING D1T-Lisa-3
15286: PPUSH
15287: CALL_OW 88
15291: GO 15317
15293: LD_INT 3
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15316
15301: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15302: LD_EXP 54
15306: PPUSH
15307: LD_STRING D1T-Con-3
15309: PPUSH
15310: CALL_OW 88
15314: GO 15317
15316: POP
// Say ( Powell , D1T-Pow-4 ) ;
15317: LD_EXP 58
15321: PPUSH
15322: LD_STRING D1T-Pow-4
15324: PPUSH
15325: CALL_OW 88
// end ; end else
15329: GO 15388
// if not FastEnd then
15331: LD_EXP 11
15335: NOT
15336: IFFALSE 15364
// begin Say ( JMM , D1T-JMM-4 ) ;
15338: LD_EXP 39
15342: PPUSH
15343: LD_STRING D1T-JMM-4
15345: PPUSH
15346: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15350: LD_EXP 58
15354: PPUSH
15355: LD_STRING D1T-Pow-5
15357: PPUSH
15358: CALL_OW 88
// end else
15362: GO 15388
// begin Say ( JMM , D1nT-JMM-1 ) ;
15364: LD_EXP 39
15368: PPUSH
15369: LD_STRING D1nT-JMM-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15376: LD_EXP 58
15380: PPUSH
15381: LD_STRING D1nT-Pow-1
15383: PPUSH
15384: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15388: LD_INT 35
15390: PPUSH
15391: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15395: LD_EXP 56
15399: PPUSH
15400: CALL_OW 314
15404: NOT
15405: IFFALSE 15388
// ComExitVehicle ( JMM ) ;
15407: LD_EXP 39
15411: PPUSH
15412: CALL_OW 121
// wait ( 3 ) ;
15416: LD_INT 3
15418: PPUSH
15419: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_INT 60
15430: PPUSH
15431: LD_INT 94
15433: PPUSH
15434: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15438: LD_EXP 39
15442: PPUSH
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 179
// if Joan then
15452: LD_EXP 40
15456: IFFALSE 15510
// begin ComExitVehicle ( Joan ) ;
15458: LD_EXP 40
15462: PPUSH
15463: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15467: LD_EXP 40
15471: PPUSH
15472: LD_INT 35
15474: PPUSH
15475: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_INT 65
15486: PPUSH
15487: LD_INT 104
15489: PPUSH
15490: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15494: LD_EXP 40
15498: PPUSH
15499: LD_EXP 39
15503: PPUSH
15504: CALL_OW 179
// end else
15508: GO 15644
// if Lisa and JMMGirl = 2 then
15510: LD_EXP 42
15514: PUSH
15515: LD_EXP 7
15519: PUSH
15520: LD_INT 2
15522: EQUAL
15523: AND
15524: IFFALSE 15578
// begin ComExitVehicle ( Lisa ) ;
15526: LD_EXP 42
15530: PPUSH
15531: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15535: LD_EXP 42
15539: PPUSH
15540: LD_INT 35
15542: PPUSH
15543: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_INT 65
15554: PPUSH
15555: LD_INT 104
15557: PPUSH
15558: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15562: LD_EXP 42
15566: PPUSH
15567: LD_EXP 39
15571: PPUSH
15572: CALL_OW 179
// end else
15576: GO 15644
// if Connie and JMMGirl = 3 then
15578: LD_EXP 54
15582: PUSH
15583: LD_EXP 7
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15644
// begin ComExitVehicle ( Connie ) ;
15594: LD_EXP 54
15598: PPUSH
15599: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15603: LD_EXP 54
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_INT 65
15622: PPUSH
15623: LD_INT 104
15625: PPUSH
15626: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15630: LD_EXP 54
15634: PPUSH
15635: LD_EXP 39
15639: PPUSH
15640: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15644: LD_INT 35
15646: PPUSH
15647: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15651: LD_EXP 39
15655: PPUSH
15656: LD_EXP 58
15660: PPUSH
15661: CALL_OW 296
15665: PUSH
15666: LD_INT 6
15668: LESS
15669: IFFALSE 15644
// wait ( 0 0$0.5 ) ;
15671: LD_INT 18
15673: PPUSH
15674: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15678: LD_EXP 39
15682: PPUSH
15683: LD_STRING D1-JMM-1
15685: PPUSH
15686: CALL_OW 88
// async ;
15690: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15691: LD_EXP 58
15695: PPUSH
15696: LD_STRING D1-Pow-1
15698: PPUSH
15699: CALL_OW 88
// if not dialogue_skipped then
15703: LD_OWVAR 59
15707: NOT
15708: IFFALSE 15717
// wait ( 0 0$2 ) ;
15710: LD_INT 70
15712: PPUSH
15713: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15717: LD_INT 170
15719: PPUSH
15720: LD_INT 99
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: LD_INT 6
15728: NEG
15729: PPUSH
15730: CALL 100832 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15734: LD_INT 174
15736: PPUSH
15737: LD_INT 115
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 6
15745: NEG
15746: PPUSH
15747: CALL 100832 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15751: LD_INT 169
15753: PPUSH
15754: LD_INT 71
15756: PPUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 6
15762: NEG
15763: PPUSH
15764: CALL 100832 0 4
// if not dialogue_skipped then
15768: LD_OWVAR 59
15772: NOT
15773: IFFALSE 15792
// begin CenterOnXY ( 170 , 99 ) ;
15775: LD_INT 170
15777: PPUSH
15778: LD_INT 99
15780: PPUSH
15781: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15785: LD_INT 80
15787: PPUSH
15788: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15792: LD_INT 75
15794: PPUSH
15795: LD_INT 53
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: LD_INT 9
15803: NEG
15804: PPUSH
15805: CALL 100832 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15809: LD_INT 54
15811: PPUSH
15812: LD_INT 42
15814: PPUSH
15815: LD_INT 1
15817: PPUSH
15818: LD_INT 9
15820: NEG
15821: PPUSH
15822: CALL 100832 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15826: LD_INT 62
15828: PPUSH
15829: LD_INT 51
15831: PPUSH
15832: LD_INT 1
15834: PPUSH
15835: LD_INT 9
15837: NEG
15838: PPUSH
15839: CALL 100832 0 4
// if not dialogue_skipped then
15843: LD_OWVAR 59
15847: NOT
15848: IFFALSE 15867
// begin CenterOnXY ( 75 , 53 ) ;
15850: LD_INT 75
15852: PPUSH
15853: LD_INT 53
15855: PPUSH
15856: CALL_OW 84
// wait ( 0 0$4 ) ;
15860: LD_INT 140
15862: PPUSH
15863: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15867: LD_EXP 58
15871: PPUSH
15872: CALL_OW 87
// if not dialogue_skipped then
15876: LD_OWVAR 59
15880: NOT
15881: IFFALSE 15890
// wait ( 0 0$2 ) ;
15883: LD_INT 70
15885: PPUSH
15886: CALL_OW 67
// sync ;
15890: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15891: LD_EXP 39
15895: PPUSH
15896: LD_STRING D1-JMM-2
15898: PPUSH
15899: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15903: LD_EXP 58
15907: PPUSH
15908: LD_STRING D1-Pow-2
15910: PPUSH
15911: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15915: LD_EXP 39
15919: PPUSH
15920: LD_STRING D1-JMM-3
15922: PPUSH
15923: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15927: LD_EXP 58
15931: PPUSH
15932: LD_STRING D1-Pow-3
15934: PPUSH
15935: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15939: LD_EXP 39
15943: PPUSH
15944: LD_STRING D1-JMM-4
15946: PPUSH
15947: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15951: LD_EXP 58
15955: PPUSH
15956: LD_STRING D1-Pow-4
15958: PPUSH
15959: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15963: LD_EXP 39
15967: PPUSH
15968: LD_STRING D1-JMM-5
15970: PPUSH
15971: CALL_OW 88
// async ;
15975: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-5
15983: PPUSH
15984: CALL_OW 88
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$3.6 ) ;
15995: LD_INT 126
15997: PPUSH
15998: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16002: LD_INT 134
16004: PPUSH
16005: LD_INT 210
16007: PPUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_INT 11
16013: NEG
16014: PPUSH
16015: CALL 100832 0 4
// if not dialogue_skipped then
16019: LD_OWVAR 59
16023: NOT
16024: IFFALSE 16043
// begin CenterOnXY ( 134 , 210 ) ;
16026: LD_INT 134
16028: PPUSH
16029: LD_INT 210
16031: PPUSH
16032: CALL_OW 84
// wait ( 0 0$2 ) ;
16036: LD_INT 70
16038: PPUSH
16039: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16043: LD_INT 101
16045: PPUSH
16046: LD_INT 159
16048: PPUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_INT 10
16054: NEG
16055: PPUSH
16056: CALL 100832 0 4
// if not dialogue_skipped then
16060: LD_OWVAR 59
16064: NOT
16065: IFFALSE 16084
// begin CenterOnXY ( 101 , 159 ) ;
16067: LD_INT 101
16069: PPUSH
16070: LD_INT 159
16072: PPUSH
16073: CALL_OW 84
// wait ( 0 0$2 ) ;
16077: LD_INT 70
16079: PPUSH
16080: CALL_OW 67
// end ; sync ;
16084: SYNC
// CenterNowOnUnits ( Powell ) ;
16085: LD_EXP 58
16089: PPUSH
16090: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 5
16113: PUSH
16114: LD_INT 6
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: ST_TO_ADDR
// if not dialogue_skipped then
16125: LD_OWVAR 59
16129: NOT
16130: IFFALSE 16299
// begin game_speed := 4 ;
16132: LD_ADDR_OWVAR 65
16136: PUSH
16137: LD_INT 4
16139: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16140: LD_INT 210
16142: PPUSH
16143: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16147: LD_ADDR_VAR 0 7
16151: PUSH
16152: LD_STRING Q1
16154: PPUSH
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 98
16164: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_STRING Q1
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 98
16182: ST_TO_ADDR
// options = options diff dec ;
16183: LD_ADDR_VAR 0 6
16187: PUSH
16188: LD_VAR 0 6
16192: PUSH
16193: LD_VAR 0 7
16197: DIFF
16198: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16199: LD_VAR 0 7
16203: PPUSH
16204: LD_VAR 0 6
16208: PPUSH
16209: CALL 17771 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16213: LD_VAR 0 7
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 6
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: IN
16228: PUSH
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 2
16236: EQUAL
16237: OR
16238: IFFALSE 16165
// if not ( dec in [ 5 , 6 ] ) then
16240: LD_VAR 0 7
16244: PUSH
16245: LD_INT 5
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: IN
16255: NOT
16256: IFFALSE 16299
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16258: LD_ADDR_VAR 0 7
16262: PUSH
16263: LD_STRING Q1a
16265: PPUSH
16266: LD_INT 1
16268: PUSH
16269: LD_INT 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 98
16280: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16281: LD_VAR 0 7
16285: PUSH
16286: LD_INT 4
16288: PLUS
16289: PPUSH
16290: LD_VAR 0 6
16294: PPUSH
16295: CALL 17771 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16299: LD_INT 81
16301: PPUSH
16302: LD_INT 127
16304: PPUSH
16305: CALL_OW 84
// amount := 5 ;
16309: LD_ADDR_VAR 0 8
16313: PUSH
16314: LD_INT 5
16316: ST_TO_ADDR
// macmilan_squad := [ ] ;
16317: LD_ADDR_VAR 0 9
16321: PUSH
16322: EMPTY
16323: ST_TO_ADDR
// if vip < amount then
16324: LD_EXP 59
16328: PUSH
16329: LD_VAR 0 8
16333: LESS
16334: IFFALSE 16378
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16336: LD_ADDR_VAR 0 5
16340: PUSH
16341: LD_EXP 59
16345: PUSH
16346: LD_INT 22
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: UNION
16375: ST_TO_ADDR
16376: GO 16388
// tmp := vip ;
16378: LD_ADDR_VAR 0 5
16382: PUSH
16383: LD_EXP 59
16387: ST_TO_ADDR
// tmp := tmp diff Powell ;
16388: LD_ADDR_VAR 0 5
16392: PUSH
16393: LD_VAR 0 5
16397: PUSH
16398: LD_EXP 58
16402: DIFF
16403: ST_TO_ADDR
// if tmp < amount then
16404: LD_VAR 0 5
16408: PUSH
16409: LD_VAR 0 8
16413: LESS
16414: IFFALSE 16426
// amount := tmp ;
16416: LD_ADDR_VAR 0 8
16420: PUSH
16421: LD_VAR 0 5
16425: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16426: LD_VAR 0 5
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 257
16439: PUSH
16440: LD_INT 2
16442: NONEQUAL
16443: IFFALSE 16505
// begin if IsInUnit ( tmp [ 1 ] ) then
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 310
16458: IFFALSE 16473
// ComExitBuilding ( tmp [ 1 ] ) ;
16460: LD_VAR 0 5
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16473: LD_VAR 0 5
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: PPUSH
16482: LD_INT 387
16484: PPUSH
16485: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16489: LD_VAR 0 5
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PPUSH
16498: LD_INT 2
16500: PPUSH
16501: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_INT 82
16512: PPUSH
16513: LD_INT 129
16515: PPUSH
16516: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16520: LD_EXP 39
16524: PPUSH
16525: LD_EXP 58
16529: PPUSH
16530: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16534: LD_INT 22
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: PUSH
16549: LD_EXP 39
16553: DIFF
16554: PPUSH
16555: LD_INT 84
16557: PPUSH
16558: LD_INT 128
16560: PPUSH
16561: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 39
16584: DIFF
16585: PPUSH
16586: LD_EXP 39
16590: PPUSH
16591: CALL_OW 179
// for i = 1 to amount do
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: DOUBLE
16601: LD_INT 1
16603: DEC
16604: ST_TO_ADDR
16605: LD_VAR 0 8
16609: PUSH
16610: FOR_TO
16611: IFFALSE 16779
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16613: LD_ADDR_VAR 0 9
16617: PUSH
16618: LD_VAR 0 9
16622: PUSH
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: ADD
16634: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: CALL_OW 310
16650: IFFALSE 16667
// AddComExitBuilding ( tmp [ i ] ) ;
16652: LD_VAR 0 5
16656: PUSH
16657: LD_VAR 0 2
16661: ARRAY
16662: PPUSH
16663: CALL_OW 182
// if i = 2 and JMMNewVeh then
16667: LD_VAR 0 2
16671: PUSH
16672: LD_INT 2
16674: EQUAL
16675: PUSH
16676: LD_EXP 56
16680: AND
16681: IFFALSE 16739
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 2
16692: ARRAY
16693: PPUSH
16694: LD_EXP 56
16698: PPUSH
16699: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16703: LD_VAR 0 5
16707: PUSH
16708: LD_VAR 0 2
16712: ARRAY
16713: PPUSH
16714: LD_INT 86
16716: PPUSH
16717: LD_INT 133
16719: PPUSH
16720: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16739: LD_VAR 0 5
16743: PUSH
16744: LD_VAR 0 2
16748: ARRAY
16749: PPUSH
16750: LD_INT 8
16752: PPUSH
16753: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: LD_EXP 39
16772: PPUSH
16773: CALL_OW 179
// end ;
16777: GO 16610
16779: POP
16780: POP
// if GirlNewVeh then
16781: LD_EXP 57
16785: IFFALSE 16799
// SetSide ( GirlNewVeh , 4 ) ;
16787: LD_EXP 57
16791: PPUSH
16792: LD_INT 4
16794: PPUSH
16795: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16799: LD_INT 35
16801: PPUSH
16802: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16806: LD_VAR 0 9
16810: PPUSH
16811: LD_INT 95
16813: PUSH
16814: LD_INT 9
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PPUSH
16821: CALL_OW 72
16825: PUSH
16826: LD_INT 0
16828: EQUAL
16829: PUSH
16830: LD_EXP 39
16834: PPUSH
16835: LD_INT 9
16837: PPUSH
16838: CALL_OW 308
16842: NOT
16843: AND
16844: IFFALSE 16799
// wait ( 0 0$2 ) ;
16846: LD_INT 70
16848: PPUSH
16849: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16853: LD_VAR 0 9
16857: PPUSH
16858: LD_INT 1
16860: PPUSH
16861: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16865: LD_INT 21
16867: PUSH
16868: LD_INT 2
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 92
16877: PUSH
16878: LD_INT 83
16880: PUSH
16881: LD_INT 130
16883: PUSH
16884: LD_INT 10
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PPUSH
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 235
// Video ( false ) ;
16909: LD_INT 0
16911: PPUSH
16912: CALL 100918 0 1
// ChangeMissionObjectives ( M1 ) ;
16916: LD_STRING M1
16918: PPUSH
16919: CALL_OW 337
// SaveForQuickRestart ;
16923: CALL_OW 22
// missionStart := true ;
16927: LD_ADDR_EXP 13
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// missionStage := 2 ;
16935: LD_ADDR_EXP 15
16939: PUSH
16940: LD_INT 2
16942: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16943: LD_INT 105
16945: PPUSH
16946: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16950: LD_ADDR_VAR 0 5
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 21
16967: PUSH
16968: LD_INT 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_EXP 58
16988: DIFF
16989: ST_TO_ADDR
// if not tmp then
16990: LD_VAR 0 5
16994: NOT
16995: IFFALSE 17010
// tmp := [ Powell ] ;
16997: LD_ADDR_VAR 0 5
17001: PUSH
17002: LD_EXP 58
17006: PUSH
17007: EMPTY
17008: LIST
17009: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17010: LD_ADDR_EXP 110
17014: PUSH
17015: LD_EXP 110
17019: PPUSH
17020: LD_INT 4
17022: PPUSH
17023: LD_INT 22
17025: PUSH
17026: LD_INT 4
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 23
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: PUSH
17070: LD_EXP 58
17074: DIFF
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17081: LD_ADDR_VAR 0 4
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 4
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 34
17098: PUSH
17099: LD_INT 12
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 310
17132: IFFALSE 17147
// ComExitBuilding ( tmp [ 1 ] ) ;
17134: LD_VAR 0 5
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17147: LD_VAR 0 5
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PPUSH
17156: LD_VAR 0 4
17160: PPUSH
17161: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17165: LD_VAR 0 5
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PPUSH
17174: LD_INT 80
17176: PPUSH
17177: LD_INT 136
17179: PPUSH
17180: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17184: LD_VAR 0 5
17188: PUSH
17189: LD_INT 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17197: LD_VAR 0 5
17201: PUSH
17202: LD_INT 1
17204: ARRAY
17205: PPUSH
17206: LD_INT 59
17208: PPUSH
17209: LD_INT 112
17211: PPUSH
17212: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17229: LD_EXP 40
17233: PUSH
17234: LD_EXP 40
17238: PPUSH
17239: CALL_OW 255
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: AND
17248: IFFALSE 17274
// begin Say ( Joan , D3W-Joan-1 ) ;
17250: LD_EXP 40
17254: PPUSH
17255: LD_STRING D3W-Joan-1
17257: PPUSH
17258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17262: LD_EXP 39
17266: PPUSH
17267: LD_STRING D3W-JMM-1
17269: PPUSH
17270: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17274: LD_EXP 42
17278: PUSH
17279: LD_EXP 42
17283: PPUSH
17284: CALL_OW 255
17288: PUSH
17289: LD_INT 1
17291: EQUAL
17292: AND
17293: PUSH
17294: LD_EXP 42
17298: PUSH
17299: LD_EXP 59
17303: IN
17304: NOT
17305: AND
17306: IFFALSE 17332
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17308: LD_EXP 42
17312: PPUSH
17313: LD_STRING D3W-Lisa-1
17315: PPUSH
17316: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17320: LD_EXP 39
17324: PPUSH
17325: LD_STRING D3W-JMM-1
17327: PPUSH
17328: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17332: LD_EXP 54
17336: PUSH
17337: LD_EXP 54
17341: PPUSH
17342: CALL_OW 255
17346: PUSH
17347: LD_INT 1
17349: EQUAL
17350: AND
17351: IFFALSE 17377
// begin Say ( Connie , D3W-Con-1 ) ;
17353: LD_EXP 54
17357: PPUSH
17358: LD_STRING D3W-Con-1
17360: PPUSH
17361: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17365: LD_EXP 39
17369: PPUSH
17370: LD_STRING D3W-JMM-1
17372: PPUSH
17373: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17377: LD_EXP 42
17381: PUSH
17382: LD_EXP 59
17386: IN
17387: PUSH
17388: LD_EXP 42
17392: PPUSH
17393: CALL_OW 255
17397: PUSH
17398: LD_INT 1
17400: EQUAL
17401: AND
17402: IFFALSE 17418
// Say ( Lisa , D3nW-Lisa-1 ) else
17404: LD_EXP 42
17408: PPUSH
17409: LD_STRING D3nW-Lisa-1
17411: PPUSH
17412: CALL_OW 88
17416: GO 17662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17418: LD_EXP 45
17422: PUSH
17423: LD_EXP 59
17427: IN
17428: PUSH
17429: LD_EXP 45
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 1
17441: EQUAL
17442: AND
17443: IFFALSE 17459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17445: LD_EXP 45
17449: PPUSH
17450: LD_STRING D3nW-Cyrus-1
17452: PPUSH
17453: CALL_OW 88
17457: GO 17662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17459: LD_EXP 44
17463: PUSH
17464: LD_EXP 59
17468: IN
17469: PUSH
17470: LD_EXP 44
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: AND
17484: IFFALSE 17500
// Say ( Bobby , D3nW-Bobby-1 ) else
17486: LD_EXP 44
17490: PPUSH
17491: LD_STRING D3nW-Bobby-1
17493: PPUSH
17494: CALL_OW 88
17498: GO 17662
// if Gary in vip and GetSide ( Gary ) = 1 then
17500: LD_EXP 51
17504: PUSH
17505: LD_EXP 59
17509: IN
17510: PUSH
17511: LD_EXP 51
17515: PPUSH
17516: CALL_OW 255
17520: PUSH
17521: LD_INT 1
17523: EQUAL
17524: AND
17525: IFFALSE 17541
// Say ( Gary , D3nW-Gary-1 ) else
17527: LD_EXP 51
17531: PPUSH
17532: LD_STRING D3nW-Gary-1
17534: PPUSH
17535: CALL_OW 88
17539: GO 17662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17541: LD_EXP 43
17545: PUSH
17546: LD_EXP 59
17550: IN
17551: PUSH
17552: LD_EXP 43
17556: PPUSH
17557: CALL_OW 255
17561: PUSH
17562: LD_INT 1
17564: EQUAL
17565: AND
17566: IFFALSE 17582
// Say ( Donaldson , D3nW-Don-1 ) else
17568: LD_EXP 43
17572: PPUSH
17573: LD_STRING D3nW-Don-1
17575: PPUSH
17576: CALL_OW 88
17580: GO 17662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17582: LD_EXP 50
17586: PUSH
17587: LD_EXP 59
17591: IN
17592: PUSH
17593: LD_EXP 50
17597: PPUSH
17598: CALL_OW 255
17602: PUSH
17603: LD_INT 1
17605: EQUAL
17606: AND
17607: IFFALSE 17623
// Say ( Cornel , D3nW-Corn-1 ) else
17609: LD_EXP 50
17613: PPUSH
17614: LD_STRING D3nW-Corn-1
17616: PPUSH
17617: CALL_OW 88
17621: GO 17662
// if Frank in vip and GetSide ( Frank ) = 1 then
17623: LD_EXP 52
17627: PUSH
17628: LD_EXP 59
17632: IN
17633: PUSH
17634: LD_EXP 52
17638: PPUSH
17639: CALL_OW 255
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: AND
17648: IFFALSE 17662
// Say ( Frank , D3nW-Frank-1 ) ;
17650: LD_EXP 52
17654: PPUSH
17655: LD_STRING D3nW-Frank-1
17657: PPUSH
17658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17662: LD_EXP 59
17666: PPUSH
17667: LD_INT 22
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PPUSH
17677: CALL_OW 72
17681: IFFALSE 17707
// begin Say ( JMM , D3nW-JMM-1 ) ;
17683: LD_EXP 39
17687: PPUSH
17688: LD_STRING D3nW-JMM-1
17690: PPUSH
17691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17695: LD_EXP 39
17699: PPUSH
17700: LD_STRING D3nW-JMM-1a
17702: PPUSH
17703: CALL_OW 88
// end ; t := 0 0$00 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17715: LD_INT 35
17717: PPUSH
17718: CALL_OW 67
// t := t + 0 0$1 ;
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_VAR 0 3
17731: PUSH
17732: LD_INT 35
17734: PLUS
17735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17736: LD_INT 59
17738: PPUSH
17739: LD_INT 112
17741: PPUSH
17742: CALL_OW 428
17746: PUSH
17747: LD_VAR 0 3
17751: PUSH
17752: LD_INT 2100
17754: GREATER
17755: OR
17756: IFFALSE 17715
// activeAttacks := true ;
17758: LD_ADDR_EXP 16
17762: PUSH
17763: LD_INT 1
17765: ST_TO_ADDR
// end ;
17766: LD_VAR 0 1
17770: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17771: LD_INT 0
17773: PPUSH
// case question of 1 :
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 1
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17838
17787: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D2Mot-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17800: LD_EXP 58
17804: PPUSH
17805: LD_STRING D2Mot-Pow-1
17807: PPUSH
17808: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17812: LD_EXP 39
17816: PPUSH
17817: LD_STRING D2Mot-JMM-2
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17824: LD_EXP 58
17828: PPUSH
17829: LD_STRING D2Mot-Pow-2
17831: PPUSH
17832: CALL_OW 88
// end ; 2 :
17836: GO 18189
17838: LD_INT 2
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17922
17846: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17847: LD_EXP 39
17851: PPUSH
17852: LD_STRING D2Rus-JMM-1
17854: PPUSH
17855: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17859: LD_EXP 58
17863: PPUSH
17864: LD_STRING D2Rus-Pow-1
17866: PPUSH
17867: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17871: LD_EXP 39
17875: PPUSH
17876: LD_STRING D2Rus-JMM-2
17878: PPUSH
17879: CALL_OW 88
// if not ( 3 in list_of_q ) then
17883: LD_INT 3
17885: PUSH
17886: LD_VAR 0 2
17890: IN
17891: NOT
17892: IFFALSE 17908
// Say ( Powell , D2Rus-Pow-2 ) else
17894: LD_EXP 58
17898: PPUSH
17899: LD_STRING D2Rus-Pow-2
17901: PPUSH
17902: CALL_OW 88
17906: GO 17920
// Say ( Powell , D2Rus-Pow-2a ) ;
17908: LD_EXP 58
17912: PPUSH
17913: LD_STRING D2Rus-Pow-2a
17915: PPUSH
17916: CALL_OW 88
// end ; 3 :
17920: GO 18189
17922: LD_INT 3
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18015
17930: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Leg-JMM-1
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17943: LD_EXP 58
17947: PPUSH
17948: LD_STRING D2Leg-Pow-1
17950: PPUSH
17951: CALL_OW 88
// if 2 in list_of_q then
17955: LD_INT 2
17957: PUSH
17958: LD_VAR 0 2
17962: IN
17963: IFFALSE 17989
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Leg-JMM-2
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Leg-Pow-2
17984: PPUSH
17985: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Leg-JMM-3
17996: PPUSH
17997: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18001: LD_EXP 58
18005: PPUSH
18006: LD_STRING D2Leg-Pow-3
18008: PPUSH
18009: CALL_OW 88
// end ; 4 :
18013: GO 18189
18015: LD_INT 4
18017: DOUBLE
18018: EQUAL
18019: IFTRUE 18023
18021: GO 18098
18023: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18024: LD_EXP 39
18028: PPUSH
18029: LD_STRING D2Ar-JMM-1
18031: PPUSH
18032: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18036: LD_EXP 58
18040: PPUSH
18041: LD_STRING D2Ar-Pow-1
18043: PPUSH
18044: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18048: LD_EXP 39
18052: PPUSH
18053: LD_STRING D2Ar-JMM-2
18055: PPUSH
18056: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18060: LD_EXP 58
18064: PPUSH
18065: LD_STRING D2Ar-Pow-2
18067: PPUSH
18068: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18072: LD_EXP 39
18076: PPUSH
18077: LD_STRING D2Ar-JMM-3
18079: PPUSH
18080: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18084: LD_EXP 58
18088: PPUSH
18089: LD_STRING D2Ar-Pow-3
18091: PPUSH
18092: CALL_OW 88
// end ; 5 :
18096: GO 18189
18098: LD_INT 5
18100: DOUBLE
18101: EQUAL
18102: IFTRUE 18106
18104: GO 18121
18106: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Conf-JMM-1
18114: PPUSH
18115: CALL_OW 88
18119: GO 18189
18121: LD_INT 6
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18188
18129: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18130: LD_EXP 39
18134: PPUSH
18135: LD_STRING D2Com-JMM-1
18137: PPUSH
18138: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18142: LD_EXP 58
18146: PPUSH
18147: LD_STRING D2Com-Pow-1
18149: PPUSH
18150: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18154: LD_EXP 39
18158: PPUSH
18159: LD_STRING D2Com-JMM-2
18161: PPUSH
18162: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18166: LD_EXP 58
18170: PPUSH
18171: LD_STRING D2Com-Pow-2
18173: PPUSH
18174: CALL_OW 88
// powellAngerQuery := true ;
18178: LD_ADDR_EXP 36
18182: PUSH
18183: LD_INT 1
18185: ST_TO_ADDR
// end ; end ;
18186: GO 18189
18188: POP
// end ;
18189: LD_VAR 0 3
18193: RET
// every 0 0$5 trigger missionStart do var tmp ;
18194: LD_EXP 13
18198: IFFALSE 18481
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18213: LD_INT 14
18215: PPUSH
18216: LD_INT 22
18218: PUSH
18219: LD_INT 1
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PPUSH
18226: CALL_OW 70
18230: PUSH
18231: LD_EXP 15
18235: PUSH
18236: LD_INT 2
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: LD_INT 4
18244: PUSH
18245: LD_INT 5
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: IN
18254: AND
18255: IFFALSE 18471
// begin powellAnger := powellAnger + 1 ;
18257: LD_ADDR_EXP 17
18261: PUSH
18262: LD_EXP 17
18266: PUSH
18267: LD_INT 1
18269: PLUS
18270: ST_TO_ADDR
// Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 100918 0 1
// CenterNowOnUnits ( tmp ) ;
18278: LD_VAR 0 1
18282: PPUSH
18283: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18287: LD_INT 14
18289: PPUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PPUSH
18300: CALL_OW 70
18304: PPUSH
18305: LD_INT 86
18307: PPUSH
18308: LD_INT 133
18310: PPUSH
18311: CALL_OW 111
// async ;
18315: ASYNC
// case powellAnger of 1 :
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 1
18323: DOUBLE
18324: EQUAL
18325: IFTRUE 18329
18327: GO 18344
18329: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18330: LD_EXP 58
18334: PPUSH
18335: LD_STRING DBack1-Pow-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18391
18344: LD_INT 2
18346: DOUBLE
18347: EQUAL
18348: IFTRUE 18352
18350: GO 18367
18352: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18353: LD_EXP 58
18357: PPUSH
18358: LD_STRING DBack2-Pow-1
18360: PPUSH
18361: CALL_OW 88
18365: GO 18391
18367: LD_INT 3
18369: DOUBLE
18370: EQUAL
18371: IFTRUE 18375
18373: GO 18390
18375: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18376: LD_EXP 58
18380: PPUSH
18381: LD_STRING DBack3-Pow-1
18383: PPUSH
18384: CALL_OW 88
18388: GO 18391
18390: POP
// sync ;
18391: SYNC
// repeat wait ( 0 0$1 ) ;
18392: LD_INT 35
18394: PPUSH
18395: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18427: LD_INT 14
18429: PPUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 70
18444: NOT
18445: IFFALSE 18392
// if powellAnger >= 3 then
18447: LD_EXP 17
18451: PUSH
18452: LD_INT 3
18454: GREATEREQUAL
18455: IFFALSE 18464
// YouLost ( Dismissed ) ;
18457: LD_STRING Dismissed
18459: PPUSH
18460: CALL_OW 104
// Video ( false ) ;
18464: LD_INT 0
18466: PPUSH
18467: CALL 100918 0 1
// end ; until missionStage > 5 ;
18471: LD_EXP 15
18475: PUSH
18476: LD_INT 5
18478: GREATER
18479: IFFALSE 18206
// end ;
18481: PPOPN 1
18483: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18484: LD_EXP 13
18488: PUSH
18489: LD_INT 22
18491: PUSH
18492: LD_INT 4
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 21
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: PPUSH
18513: CALL_OW 69
18517: PUSH
18518: LD_INT 4
18520: GREATEREQUAL
18521: AND
18522: PUSH
18523: LD_EXP 15
18527: PUSH
18528: LD_INT 2
18530: EQUAL
18531: AND
18532: IFFALSE 20355
18534: GO 18536
18536: DISABLE
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
18541: PPUSH
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
18546: PPUSH
// begin missionStage := 3 ;
18547: LD_ADDR_EXP 15
18551: PUSH
18552: LD_INT 3
18554: ST_TO_ADDR
// retreat := false ;
18555: LD_ADDR_VAR 0 4
18559: PUSH
18560: LD_INT 0
18562: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18563: LD_ADDR_VAR 0 5
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 4
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18597: LD_ADDR_VAR 0 6
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_INT 4
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 5
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: ST_TO_ADDR
// if not bar then
18631: LD_VAR 0 6
18635: NOT
18636: IFFALSE 18689
// begin repeat wait ( 0 0$1 ) ;
18638: LD_INT 35
18640: PPUSH
18641: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18645: LD_INT 22
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: LD_INT 57
18660: PUSH
18661: EMPTY
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 30
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: PPUSH
18683: CALL_OW 69
18687: IFFALSE 18638
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18689: LD_ADDR_VAR 0 6
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 4
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 30
18706: PUSH
18707: LD_INT 5
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL_OW 69
18722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18723: LD_INT 35
18725: PPUSH
18726: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18730: LD_EXP 129
18734: PUSH
18735: LD_INT 4
18737: ARRAY
18738: PUSH
18739: LD_INT 4
18741: GREATEREQUAL
18742: IFFALSE 18723
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_INT 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 2
18761: PUSH
18762: LD_INT 25
18764: PUSH
18765: LD_INT 1
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 25
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 25
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 25
18794: PUSH
18795: LD_INT 4
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 25
18804: PUSH
18805: LD_INT 5
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL_OW 69
18828: PUSH
18829: LD_EXP 58
18833: PUSH
18834: LD_EXP 59
18838: ADD
18839: DIFF
18840: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18841: LD_ADDR_VAR 0 3
18845: PUSH
18846: LD_VAR 0 2
18850: PPUSH
18851: LD_INT 26
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PPUSH
18861: CALL_OW 72
18865: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18866: LD_ADDR_VAR 0 2
18870: PUSH
18871: LD_VAR 0 2
18875: PUSH
18876: LD_VAR 0 3
18880: DIFF
18881: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18882: LD_ADDR_VAR 0 2
18886: PUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: LD_INT 1
18894: PPUSH
18895: CALL 99571 0 2
18899: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 3
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 99571 0 2
18917: ST_TO_ADDR
// for i = 1 to 4 do
18918: LD_ADDR_VAR 0 1
18922: PUSH
18923: DOUBLE
18924: LD_INT 1
18926: DEC
18927: ST_TO_ADDR
18928: LD_INT 4
18930: PUSH
18931: FOR_TO
18932: IFFALSE 19098
// begin if tmp2 then
18934: LD_VAR 0 3
18938: IFFALSE 19019
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18940: LD_ADDR_EXP 18
18944: PUSH
18945: LD_EXP 18
18949: PPUSH
18950: LD_INT 1
18952: PPUSH
18953: LD_EXP 18
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PUSH
18962: LD_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: ARRAY
18972: ADD
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18979: LD_VAR 0 3
18983: PUSH
18984: LD_VAR 0 3
18988: ARRAY
18989: PPUSH
18990: LD_INT 1
18992: PPUSH
18993: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 3
19011: PPUSH
19012: CALL_OW 3
19016: ST_TO_ADDR
// end else
19017: GO 19096
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19019: LD_ADDR_EXP 18
19023: PUSH
19024: LD_EXP 18
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: LD_EXP 18
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 2
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 2
19067: ARRAY
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 3
19095: ST_TO_ADDR
// end ; end ;
19096: GO 18931
19098: POP
19099: POP
// if tmp2 then
19100: LD_VAR 0 3
19104: IFFALSE 19122
// tmp := tmp union tmp2 ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 2
19115: PUSH
19116: LD_VAR 0 3
19120: UNION
19121: ST_TO_ADDR
// for i = 1 to 4 do
19122: LD_ADDR_VAR 0 1
19126: PUSH
19127: DOUBLE
19128: LD_INT 1
19130: DEC
19131: ST_TO_ADDR
19132: LD_INT 4
19134: PUSH
19135: FOR_TO
19136: IFFALSE 19185
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19138: LD_ADDR_EXP 18
19142: PUSH
19143: LD_EXP 18
19147: PPUSH
19148: LD_INT 2
19150: PPUSH
19151: LD_EXP 18
19155: PUSH
19156: LD_INT 2
19158: ARRAY
19159: PUSH
19160: LD_VAR 0 2
19164: PUSH
19165: LD_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: MINUS
19175: ARRAY
19176: ADD
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
19183: GO 19135
19185: POP
19186: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19187: LD_ADDR_EXP 110
19191: PUSH
19192: LD_EXP 110
19196: PPUSH
19197: LD_INT 4
19199: PPUSH
19200: LD_EXP 110
19204: PUSH
19205: LD_INT 4
19207: ARRAY
19208: PUSH
19209: LD_EXP 18
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: DIFF
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_INT 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 313
19237: IFFALSE 19292
// begin for i in UnitsInside ( arm [ 1 ] ) do
19239: LD_ADDR_VAR 0 1
19243: PUSH
19244: LD_VAR 0 5
19248: PUSH
19249: LD_INT 1
19251: ARRAY
19252: PPUSH
19253: CALL_OW 313
19257: PUSH
19258: FOR_IN
19259: IFFALSE 19290
// begin ComExitBuilding ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_VAR 0 6
19279: PUSH
19280: LD_INT 1
19282: ARRAY
19283: PPUSH
19284: CALL_OW 180
// end ;
19288: GO 19258
19290: POP
19291: POP
// end ; wait ( 0 0$3 ) ;
19292: LD_INT 105
19294: PPUSH
19295: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19299: LD_ADDR_VAR 0 1
19303: PUSH
19304: LD_EXP 18
19308: PUSH
19309: LD_INT 1
19311: ARRAY
19312: PUSH
19313: FOR_IN
19314: IFFALSE 19421
// begin if IsInUnit ( i ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 310
19325: IFFALSE 19336
// ComExitBuilding ( i ) ;
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 122
// if GetClass ( i ) <> 1 then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 257
19345: PUSH
19346: LD_INT 1
19348: NONEQUAL
19349: IFFALSE 19390
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19351: LD_VAR 0 1
19355: PPUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 183
// AddComExitBuilding ( i ) ;
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_INT 60
19397: PPUSH
19398: LD_INT 94
19400: PPUSH
19401: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_EXP 58
19414: PPUSH
19415: CALL_OW 179
// end ;
19419: GO 19313
19421: POP
19422: POP
// wait ( 0 0$15 ) ;
19423: LD_INT 525
19425: PPUSH
19426: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19430: LD_EXP 58
19434: PPUSH
19435: LD_STRING D4-Pow-1
19437: PPUSH
19438: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19442: LD_ADDR_VAR 0 2
19446: PUSH
19447: LD_EXP 18
19451: PUSH
19452: LD_INT 1
19454: ARRAY
19455: PPUSH
19456: LD_INT 26
19458: PUSH
19459: LD_INT 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 72
19470: ST_TO_ADDR
// if tmp then
19471: LD_VAR 0 2
19475: IFFALSE 19493
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19477: LD_VAR 0 2
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_STRING D4-Sol1-1
19488: PPUSH
19489: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19493: LD_EXP 58
19497: PPUSH
19498: LD_STRING D4-Pow-2
19500: PPUSH
19501: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19505: LD_ADDR_VAR 0 1
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_EXP 18
19519: PUSH
19520: LD_INT 1
19522: ARRAY
19523: PUSH
19524: FOR_TO
19525: IFFALSE 19618
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: PPUSH
19542: LD_EXP 129
19546: PUSH
19547: LD_INT 4
19549: ARRAY
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19559: LD_ADDR_EXP 129
19563: PUSH
19564: LD_EXP 129
19568: PPUSH
19569: LD_INT 4
19571: PPUSH
19572: LD_EXP 129
19576: PUSH
19577: LD_INT 4
19579: ARRAY
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: CALL_OW 3
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19594: LD_INT 8
19596: PPUSH
19597: LD_EXP 18
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 471
// end ;
19616: GO 19524
19618: POP
19619: POP
// repeat wait ( 0 0$1 ) ;
19620: LD_INT 35
19622: PPUSH
19623: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PPUSH
19636: LD_INT 55
19638: PUSH
19639: EMPTY
19640: LIST
19641: PPUSH
19642: CALL_OW 72
19646: PUSH
19647: LD_INT 4
19649: GREATEREQUAL
19650: IFFALSE 19620
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 69
19663: PPUSH
19664: LD_INT 94
19666: PPUSH
19667: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19671: LD_EXP 18
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: PPUSH
19680: LD_INT 82
19682: PPUSH
19683: LD_INT 83
19685: PPUSH
19686: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19690: LD_EXP 18
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: LD_INT 77
19701: PPUSH
19702: LD_INT 69
19704: PPUSH
19705: CALL_OW 174
// repeat wait ( 3 ) ;
19709: LD_INT 3
19711: PPUSH
19712: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19716: LD_ADDR_VAR 0 1
19720: PUSH
19721: LD_EXP 18
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: FOR_IN
19731: IFFALSE 19867
// begin if GetLives ( i ) < 990 then
19733: LD_VAR 0 1
19737: PPUSH
19738: CALL_OW 256
19742: PUSH
19743: LD_INT 990
19745: LESS
19746: IFFALSE 19760
// SetLives ( i , 1000 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_INT 1000
19755: PPUSH
19756: CALL_OW 234
// if not IsInUnit ( i ) then
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 310
19769: NOT
19770: IFFALSE 19865
// begin if not HasTask ( i ) then
19772: LD_VAR 0 1
19776: PPUSH
19777: CALL_OW 314
19781: NOT
19782: IFFALSE 19799
// ComMoveXY ( i , 64 , 93 ) ;
19784: LD_VAR 0 1
19788: PPUSH
19789: LD_INT 64
19791: PPUSH
19792: LD_INT 93
19794: PPUSH
19795: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19799: LD_VAR 0 4
19803: NOT
19804: PUSH
19805: LD_VAR 0 1
19809: PPUSH
19810: CALL_OW 258
19814: PUSH
19815: LD_INT 1
19817: EQUAL
19818: AND
19819: IFFALSE 19865
// begin retreat := true ;
19821: LD_ADDR_VAR 0 4
19825: PUSH
19826: LD_INT 1
19828: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: LD_STRING D4a-Sol1-1
19848: PPUSH
19849: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19853: LD_EXP 58
19857: PPUSH
19858: LD_STRING D4a-Pow-1
19860: PPUSH
19861: CALL_OW 88
// end ; end ; end ;
19865: GO 19730
19867: POP
19868: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19869: LD_EXP 18
19873: PUSH
19874: LD_INT 1
19876: ARRAY
19877: PPUSH
19878: LD_INT 95
19880: PUSH
19881: LD_INT 9
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 55
19893: PUSH
19894: EMPTY
19895: LIST
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: PUSH
19910: LD_INT 4
19912: GREATEREQUAL
19913: IFFALSE 19709
// for i in powellSquadAttack [ 1 ] do
19915: LD_ADDR_VAR 0 1
19919: PUSH
19920: LD_EXP 18
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PUSH
19929: FOR_IN
19930: IFFALSE 20066
// begin if GetTag ( i ) = 2 then
19932: LD_VAR 0 1
19936: PPUSH
19937: CALL_OW 110
19941: PUSH
19942: LD_INT 2
19944: EQUAL
19945: IFFALSE 20007
// begin ComMoveXY ( i , 60 , 94 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 60
19954: PPUSH
19955: LD_INT 94
19957: PPUSH
19958: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_EXP 58
19971: PPUSH
19972: CALL_OW 179
// wait ( 0 0$3 ) ;
19976: LD_INT 105
19978: PPUSH
19979: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19983: LD_VAR 0 1
19987: PPUSH
19988: LD_STRING D4a-Sol1-2
19990: PPUSH
19991: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19995: LD_EXP 58
19999: PPUSH
20000: LD_STRING D4a-Pow-2
20002: PPUSH
20003: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20007: LD_VAR 0 1
20011: PPUSH
20012: LD_INT 0
20014: PPUSH
20015: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20019: LD_ADDR_EXP 110
20023: PUSH
20024: LD_EXP 110
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: LD_EXP 110
20036: PUSH
20037: LD_INT 4
20039: ARRAY
20040: PUSH
20041: LD_VAR 0 1
20045: UNION
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20052: LD_INT 8
20054: PPUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: CALL_OW 472
// end ;
20064: GO 19929
20066: POP
20067: POP
// wait ( 4 4$00 ) ;
20068: LD_INT 8400
20070: PPUSH
20071: CALL_OW 67
// uc_side := 6 ;
20075: LD_ADDR_OWVAR 20
20079: PUSH
20080: LD_INT 6
20082: ST_TO_ADDR
// uc_nation := 3 ;
20083: LD_ADDR_OWVAR 21
20087: PUSH
20088: LD_INT 3
20090: ST_TO_ADDR
// ru := [ ] ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: EMPTY
20097: ST_TO_ADDR
// for i = 1 to 4 do
20098: LD_ADDR_VAR 0 1
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_INT 4
20110: PUSH
20111: FOR_TO
20112: IFFALSE 20213
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20114: LD_INT 22
20116: PPUSH
20117: LD_INT 1
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 43
20125: PUSH
20126: LD_INT 44
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 2
20138: PPUSH
20139: CALL_OW 12
20143: ARRAY
20144: PPUSH
20145: LD_INT 89
20147: PPUSH
20148: CALL 69900 0 5
// un := CreateVehicle ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: CALL_OW 45
20161: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20162: LD_VAR 0 8
20166: PPUSH
20167: LD_INT 4
20169: PPUSH
20170: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20174: LD_VAR 0 8
20178: PPUSH
20179: LD_INT 136
20181: PPUSH
20182: LD_INT 90
20184: PPUSH
20185: LD_INT 8
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 50
// ru := ru ^ un ;
20195: LD_ADDR_VAR 0 7
20199: PUSH
20200: LD_VAR 0 7
20204: PUSH
20205: LD_VAR 0 8
20209: ADD
20210: ST_TO_ADDR
// end ;
20211: GO 20111
20213: POP
20214: POP
// if ru then
20215: LD_VAR 0 7
20219: IFFALSE 20236
// ComAgressiveMove ( ru , 80 , 92 ) ;
20221: LD_VAR 0 7
20225: PPUSH
20226: LD_INT 80
20228: PPUSH
20229: LD_INT 92
20231: PPUSH
20232: CALL_OW 114
// wait ( 8 8$00 ) ;
20236: LD_INT 16800
20238: PPUSH
20239: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20243: LD_INT 4
20245: PPUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 1
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 5
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: PUSH
20264: LD_INT 4
20266: PUSH
20267: LD_INT 1
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 6
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 1
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 3
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 7
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 3
20320: PUSH
20321: LD_INT 1
20323: PUSH
20324: LD_INT 1
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 58684 0 2
// missionStage := 4 ;
20347: LD_ADDR_EXP 15
20351: PUSH
20352: LD_INT 4
20354: ST_TO_ADDR
// end ;
20355: PPOPN 8
20357: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20358: LD_EXP 15
20362: PUSH
20363: LD_INT 4
20365: EQUAL
20366: PUSH
20367: LD_INT 22
20369: PUSH
20370: LD_INT 4
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 21
20379: PUSH
20380: LD_INT 2
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PPUSH
20391: CALL_OW 69
20395: PUSH
20396: LD_INT 5
20398: GREATEREQUAL
20399: AND
20400: IFFALSE 24505
20402: GO 20404
20404: DISABLE
20405: LD_INT 0
20407: PPUSH
20408: PPUSH
20409: PPUSH
20410: PPUSH
20411: PPUSH
20412: PPUSH
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
20419: PPUSH
// begin missionStage := 5 ;
20420: LD_ADDR_EXP 15
20424: PUSH
20425: LD_INT 5
20427: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20428: LD_ADDR_VAR 0 10
20432: PUSH
20433: LD_INT 22
20435: PUSH
20436: LD_INT 4
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: LD_INT 2
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 4
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 30
20458: PUSH
20459: LD_INT 5
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PPUSH
20475: CALL_OW 69
20479: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20480: LD_ADDR_VAR 0 6
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 1
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 3
20507: PUSH
20508: LD_INT 25
20510: PUSH
20511: LD_INT 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 3
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 12
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: PPUSH
20545: CALL_OW 69
20549: PUSH
20550: LD_EXP 58
20554: DIFF
20555: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20556: LD_ADDR_VAR 0 9
20560: PUSH
20561: LD_INT 22
20563: PUSH
20564: LD_INT 4
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 3
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PPUSH
20585: CALL_OW 69
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20594: LD_INT 35
20596: PPUSH
20597: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20601: LD_EXP 129
20605: PUSH
20606: LD_INT 4
20608: ARRAY
20609: PUSH
20610: LD_INT 5
20612: GREATEREQUAL
20613: PUSH
20614: LD_EXP 129
20618: PUSH
20619: LD_INT 4
20621: ARRAY
20622: PPUSH
20623: LD_INT 58
20625: PUSH
20626: EMPTY
20627: LIST
20628: PPUSH
20629: CALL_OW 72
20633: PUSH
20634: LD_INT 5
20636: GREATEREQUAL
20637: AND
20638: IFFALSE 20594
// powellAllowRetreat := false ;
20640: LD_ADDR_EXP 19
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20648: LD_INT 700
20650: PPUSH
20651: CALL_OW 67
// activeAttacks := false ;
20655: LD_ADDR_EXP 16
20659: PUSH
20660: LD_INT 0
20662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20663: LD_INT 35
20665: PPUSH
20666: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20670: LD_INT 22
20672: PUSH
20673: LD_INT 6
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: LD_INT 0
20687: EQUAL
20688: IFFALSE 20663
// tmp := mc_vehicles [ 4 ] ;
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_EXP 129
20699: PUSH
20700: LD_INT 4
20702: ARRAY
20703: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20704: LD_ADDR_VAR 0 1
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_EXP 18
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20981
// begin for j in powellSquadAttack [ i ] do
20722: LD_ADDR_VAR 0 2
20726: PUSH
20727: LD_EXP 18
20731: PUSH
20732: LD_VAR 0 1
20736: ARRAY
20737: PUSH
20738: FOR_IN
20739: IFFALSE 20977
// begin forces := forces diff j ;
20741: LD_ADDR_VAR 0 6
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: LD_VAR 0 2
20755: DIFF
20756: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20757: LD_VAR 0 2
20761: PPUSH
20762: LD_INT 1
20764: PPUSH
20765: CALL_OW 109
// wait ( 0 0$2 ) ;
20769: LD_INT 70
20771: PPUSH
20772: CALL_OW 67
// if IsInUnit ( j ) then
20776: LD_VAR 0 2
20780: PPUSH
20781: CALL_OW 310
20785: IFFALSE 20796
// ComExitBuilding ( j ) ;
20787: LD_VAR 0 2
20791: PPUSH
20792: CALL_OW 122
// if GetClass ( j ) <> 1 then
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 1
20808: NONEQUAL
20809: IFFALSE 20889
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20811: LD_VAR 0 10
20815: PUSH
20816: LD_INT 1
20818: ARRAY
20819: PPUSH
20820: CALL_OW 313
20824: PUSH
20825: LD_INT 5
20827: GREATEREQUAL
20828: IFFALSE 20850
// AddComEnterUnit ( j , arm [ 2 ] ) else
20830: LD_VAR 0 2
20834: PPUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: PPUSH
20844: CALL_OW 180
20848: GO 20868
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20850: LD_VAR 0 2
20854: PPUSH
20855: LD_VAR 0 10
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20868: LD_VAR 0 2
20872: PPUSH
20873: LD_INT 1
20875: PPUSH
20876: CALL_OW 183
// AddComExitBuilding ( j ) ;
20880: LD_VAR 0 2
20884: PPUSH
20885: CALL_OW 182
// end ; if i = 2 then
20889: LD_VAR 0 1
20893: PUSH
20894: LD_INT 2
20896: EQUAL
20897: IFFALSE 20914
// AddComMoveXY ( j , 61 , 93 ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: LD_INT 61
20906: PPUSH
20907: LD_INT 93
20909: PPUSH
20910: CALL_OW 171
// if i = 1 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 1
20921: EQUAL
20922: IFFALSE 20975
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_VAR 0 3
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_VAR 0 3
20951: PPUSH
20952: LD_INT 1
20954: PPUSH
20955: CALL_OW 3
20959: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_INT 69
20967: PPUSH
20968: LD_INT 94
20970: PPUSH
20971: CALL_OW 171
// end ; end ;
20975: GO 20738
20977: POP
20978: POP
// end ;
20979: GO 20719
20981: POP
20982: POP
// wait ( 0 0$55 ) ;
20983: LD_INT 1925
20985: PPUSH
20986: CALL_OW 67
// MC_Kill ( 4 ) ;
20990: LD_INT 4
20992: PPUSH
20993: CALL 35288 0 1
// tmp := UnitsInside ( fac ) ;
20997: LD_ADDR_VAR 0 3
21001: PUSH
21002: LD_VAR 0 9
21006: PPUSH
21007: CALL_OW 313
21011: ST_TO_ADDR
// if tmp then
21012: LD_VAR 0 3
21016: IFFALSE 21137
// for i in tmp do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 3
21027: PUSH
21028: FOR_IN
21029: IFFALSE 21135
// begin ComExitBuilding ( i ) ;
21031: LD_VAR 0 1
21035: PPUSH
21036: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21040: LD_VAR 0 10
21044: PUSH
21045: LD_INT 2
21047: ARRAY
21048: PPUSH
21049: CALL_OW 313
21053: PUSH
21054: LD_INT 6
21056: LESS
21057: IFFALSE 21079
// AddComEnterUnit ( i , arm [ 2 ] ) else
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 2
21071: ARRAY
21072: PPUSH
21073: CALL_OW 180
21077: GO 21133
// if UnitsInside ( arm [ 1 ] ) < 6 then
21079: LD_VAR 0 10
21083: PUSH
21084: LD_INT 1
21086: ARRAY
21087: PPUSH
21088: CALL_OW 313
21092: PUSH
21093: LD_INT 6
21095: LESS
21096: IFFALSE 21118
// AddComEnterUnit ( i , arm [ 1 ] ) else
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 10
21107: PUSH
21108: LD_INT 1
21110: ARRAY
21111: PPUSH
21112: CALL_OW 180
21116: GO 21133
// AddComMoveXY ( i , 37 , 68 ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_INT 37
21125: PPUSH
21126: LD_INT 68
21128: PPUSH
21129: CALL_OW 171
// end ;
21133: GO 21028
21135: POP
21136: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21137: LD_ADDR_VAR 0 11
21141: PUSH
21142: LD_VAR 0 6
21146: PPUSH
21147: LD_INT 26
21149: PUSH
21150: LD_INT 1
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL_OW 72
21161: PUSH
21162: LD_EXP 59
21166: DIFF
21167: ST_TO_ADDR
// if not speaker then
21168: LD_VAR 0 11
21172: NOT
21173: IFFALSE 21200
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21175: LD_ADDR_VAR 0 11
21179: PUSH
21180: LD_VAR 0 6
21184: PPUSH
21185: LD_INT 26
21187: PUSH
21188: LD_INT 1
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PPUSH
21195: CALL_OW 72
21199: ST_TO_ADDR
// if speaker then
21200: LD_VAR 0 11
21204: IFFALSE 21220
// speaker := speaker [ 1 ] ;
21206: LD_ADDR_VAR 0 11
21210: PUSH
21211: LD_VAR 0 11
21215: PUSH
21216: LD_INT 1
21218: ARRAY
21219: ST_TO_ADDR
// Video ( true ) ;
21220: LD_INT 1
21222: PPUSH
21223: CALL 100918 0 1
// CenterNowOnUnits ( Powell ) ;
21227: LD_EXP 58
21231: PPUSH
21232: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 6
21245: PPUSH
21246: LD_INT 3
21248: PUSH
21249: LD_INT 25
21251: PUSH
21252: LD_INT 1
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 72
21267: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21268: LD_ADDR_VAR 0 12
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 30
21285: PUSH
21286: LD_INT 32
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 58
21295: PUSH
21296: EMPTY
21297: LIST
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 69
21308: ST_TO_ADDR
// for i = 1 to 6 do
21309: LD_ADDR_VAR 0 1
21313: PUSH
21314: DOUBLE
21315: LD_INT 1
21317: DEC
21318: ST_TO_ADDR
21319: LD_INT 6
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21464
// begin if IsInUnit ( tmp [ i ] ) then
21325: LD_VAR 0 3
21329: PUSH
21330: LD_VAR 0 1
21334: ARRAY
21335: PPUSH
21336: CALL_OW 310
21340: IFFALSE 21357
// ComExitBuilding ( tmp [ i ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21357: LD_VAR 0 3
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: PPUSH
21368: LD_VAR 0 10
21372: PUSH
21373: LD_INT 1
21375: ARRAY
21376: PPUSH
21377: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21381: LD_VAR 0 3
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PPUSH
21392: LD_INT 1
21394: PPUSH
21395: CALL_OW 183
// if emp_towers then
21399: LD_VAR 0 12
21403: IFFALSE 21462
// begin AddComExitBuilding ( tmp [ i ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_VAR 0 1
21429: ARRAY
21430: PPUSH
21431: LD_VAR 0 12
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21444: LD_ADDR_VAR 0 12
21448: PUSH
21449: LD_VAR 0 12
21453: PPUSH
21454: LD_INT 1
21456: PPUSH
21457: CALL_OW 3
21461: ST_TO_ADDR
// end ; end ;
21462: GO 21322
21464: POP
21465: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_EXP 18
21475: PUSH
21476: LD_INT 1
21478: ARRAY
21479: PUSH
21480: LD_EXP 18
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: ADD
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 2
21517: ARRAY
21518: PUSH
21519: FOR_IN
21520: IFFALSE 21538
// ComTurnUnit ( i , Powell ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_EXP 58
21531: PPUSH
21532: CALL_OW 119
21536: GO 21519
21538: POP
21539: POP
// Say ( Powell , D5-Pow-1 ) ;
21540: LD_EXP 58
21544: PPUSH
21545: LD_STRING D5-Pow-1
21547: PPUSH
21548: CALL_OW 88
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21574
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PPUSH
21567: LD_STRING D5-Sol2-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21574: LD_EXP 58
21578: PPUSH
21579: LD_STRING D5-Pow-2
21581: PPUSH
21582: CALL_OW 88
// if tmp > 1 then
21586: LD_VAR 0 3
21590: PUSH
21591: LD_INT 1
21593: GREATER
21594: IFFALSE 21612
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 2
21603: ARRAY
21604: PPUSH
21605: LD_STRING D5-Sol2-2
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5-Pow-3
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21631: LD_ADDR_VAR 0 3
21635: PUSH
21636: LD_EXP 18
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PUSH
21645: LD_EXP 18
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: UNION
21654: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21655: LD_VAR 0 3
21659: PPUSH
21660: LD_INT 80
21662: PPUSH
21663: LD_INT 67
21665: PPUSH
21666: CALL_OW 114
// wait ( 0 0$2 ) ;
21670: LD_INT 70
21672: PPUSH
21673: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21677: LD_INT 79
21679: PPUSH
21680: LD_INT 72
21682: PPUSH
21683: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21687: LD_INT 35
21689: PPUSH
21690: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_INT 3
21701: PUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1000
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: IFFALSE 21687
// Say ( Powell , D5a-Pow-1 ) ;
21722: LD_EXP 58
21726: PPUSH
21727: LD_STRING D5a-Pow-1
21729: PPUSH
21730: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21734: LD_EXP 58
21738: PPUSH
21739: LD_STRING D5a-Pow-1a
21741: PPUSH
21742: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21746: LD_INT 10
21748: PPUSH
21749: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21753: LD_EXP 58
21757: PPUSH
21758: LD_STRING D5a-Pow-1b
21760: PPUSH
21761: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21765: LD_EXP 58
21769: PPUSH
21770: LD_STRING D5a-Pow-1c
21772: PPUSH
21773: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21777: LD_EXP 58
21781: PPUSH
21782: LD_STRING D5a-Pow-1d
21784: PPUSH
21785: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21789: LD_INT 35
21791: PPUSH
21792: CALL_OW 67
// if not HasTask ( tmp ) then
21796: LD_VAR 0 3
21800: PPUSH
21801: CALL_OW 314
21805: NOT
21806: IFFALSE 21823
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 80
21815: PPUSH
21816: LD_INT 67
21818: PPUSH
21819: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 24
21830: PUSH
21831: LD_INT 1
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 72
21842: NOT
21843: IFFALSE 21789
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_INT 22
21852: PUSH
21853: LD_INT 4
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 92
21862: PUSH
21863: LD_INT 60
21865: PUSH
21866: LD_INT 93
21868: PUSH
21869: LD_INT 10
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 3
21880: PUSH
21881: LD_INT 54
21883: PUSH
21884: EMPTY
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PPUSH
21896: CALL_OW 69
21900: PUSH
21901: LD_EXP 58
21905: DIFF
21906: ST_TO_ADDR
// if tmp then
21907: LD_VAR 0 3
21911: IFFALSE 21945
// for i in tmp do
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_VAR 0 3
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21943
// ComMoveXY ( i , 36 , 67 ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_INT 36
21933: PPUSH
21934: LD_INT 67
21936: PPUSH
21937: CALL_OW 111
21941: GO 21923
21943: POP
21944: POP
// wait ( 0 0$3 ) ;
21945: LD_INT 105
21947: PPUSH
21948: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6-Sol3-1
21959: PPUSH
21960: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21964: LD_EXP 58
21968: PPUSH
21969: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21973: LD_EXP 58
21977: PPUSH
21978: LD_STRING D6-Pow-1
21980: PPUSH
21981: CALL_OW 88
// tmp := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// for i = 1 to 2 do
21992: LD_ADDR_VAR 0 1
21996: PUSH
21997: DOUBLE
21998: LD_INT 1
22000: DEC
22001: ST_TO_ADDR
22002: LD_INT 2
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22120
// begin uc_side := 8 ;
22008: LD_ADDR_OWVAR 20
22012: PUSH
22013: LD_INT 8
22015: ST_TO_ADDR
// uc_nation := 2 ;
22016: LD_ADDR_OWVAR 21
22020: PUSH
22021: LD_INT 2
22023: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22024: LD_INT 14
22026: PPUSH
22027: LD_INT 3
22029: PPUSH
22030: LD_INT 2
22032: PPUSH
22033: LD_INT 29
22035: PPUSH
22036: LD_INT 100
22038: PPUSH
22039: CALL 69900 0 5
// veh := CreateVehicle ;
22043: LD_ADDR_VAR 0 13
22047: PUSH
22048: CALL_OW 45
22052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22053: LD_VAR 0 13
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22065: LD_VAR 0 13
22069: PPUSH
22070: LD_INT 99
22072: PPUSH
22073: LD_INT 83
22075: PPUSH
22076: LD_INT 6
22078: PPUSH
22079: LD_INT 0
22081: PPUSH
22082: CALL_OW 50
// wait ( 3 ) ;
22086: LD_INT 3
22088: PPUSH
22089: CALL_OW 67
// Connect ( veh ) ;
22093: LD_VAR 0 13
22097: PPUSH
22098: CALL 72955 0 1
// tmp := tmp ^ veh ;
22102: LD_ADDR_VAR 0 3
22106: PUSH
22107: LD_VAR 0 3
22111: PUSH
22112: LD_VAR 0 13
22116: ADD
22117: ST_TO_ADDR
// end ;
22118: GO 22005
22120: POP
22121: POP
// wait ( 0 0$1 ) ;
22122: LD_INT 35
22124: PPUSH
22125: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22129: LD_INT 99
22131: PPUSH
22132: LD_INT 83
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 10
22140: PPUSH
22141: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22145: LD_INT 99
22147: PPUSH
22148: LD_INT 83
22150: PPUSH
22151: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22155: LD_VAR 0 11
22159: PPUSH
22160: LD_STRING D6-Sol3-2
22162: PPUSH
22163: CALL_OW 88
// async ;
22167: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22168: LD_EXP 58
22172: PPUSH
22173: LD_STRING D6-Pow-2
22175: PPUSH
22176: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_VAR 0 9
22193: PPUSH
22194: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22198: LD_VAR 0 3
22202: PUSH
22203: LD_INT 2
22205: ARRAY
22206: PPUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 21
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: PPUSH
22236: LD_VAR 0 3
22240: PUSH
22241: LD_INT 2
22243: ARRAY
22244: PPUSH
22245: CALL_OW 74
22249: PPUSH
22250: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22254: LD_EXP 58
22258: PPUSH
22259: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22263: LD_INT 99
22265: PPUSH
22266: LD_INT 83
22268: PPUSH
22269: LD_INT 1
22271: PPUSH
22272: CALL_OW 331
// repeat wait ( 4 ) ;
22276: LD_INT 4
22278: PPUSH
22279: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22283: LD_VAR 0 3
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 256
22296: PUSH
22297: LD_INT 1000
22299: LESS
22300: IFFALSE 22318
// SetLives ( tmp [ 1 ] , 1000 ) ;
22302: LD_VAR 0 3
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_INT 1000
22313: PPUSH
22314: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22318: LD_INT 22
22320: PUSH
22321: LD_INT 4
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 30
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_INT 0
22349: EQUAL
22350: IFFALSE 22276
// sync ;
22352: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22353: LD_EXP 58
22357: PPUSH
22358: LD_STRING D6a-Pow-1
22360: PPUSH
22361: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22365: LD_VAR 0 11
22369: PPUSH
22370: LD_STRING D6a-Sol3-1
22372: PPUSH
22373: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22377: LD_EXP 58
22381: PPUSH
22382: LD_STRING D6a-Pow-2
22384: PPUSH
22385: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22389: LD_VAR 0 11
22393: PPUSH
22394: LD_STRING D6a-Sol3-2
22396: PPUSH
22397: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22401: LD_EXP 58
22405: PPUSH
22406: LD_STRING D6a-Pow-3
22408: PPUSH
22409: CALL_OW 88
// powellCenterCameraMode := true ;
22413: LD_ADDR_EXP 20
22417: PUSH
22418: LD_INT 1
22420: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: LD_INT 22
22428: PUSH
22429: LD_INT 8
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PPUSH
22450: CALL_OW 69
22454: PUSH
22455: FOR_IN
22456: IFFALSE 22511
// begin SetTag ( i , 1 ) ;
22458: LD_VAR 0 1
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 109
// ComExitBuilding ( i ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 35
22486: PPUSH
22487: LD_INT 6
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 53
22501: PPUSH
22502: LD_INT 4
22504: PPUSH
22505: CALL_OW 171
// end ;
22509: GO 22455
22511: POP
22512: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 22
22520: PUSH
22521: LD_INT 4
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 21
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 3
22540: PUSH
22541: LD_INT 34
22543: PUSH
22544: LD_INT 12
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22565: LD_EXP 58
22569: PPUSH
22570: LD_VAR 0 3
22574: PPUSH
22575: LD_EXP 58
22579: PPUSH
22580: CALL_OW 74
22584: PPUSH
22585: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 88
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 100
22611: PPUSH
22612: LD_INT 75
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22619: LD_EXP 58
22623: PPUSH
22624: LD_INT 88
22626: PPUSH
22627: LD_INT 53
22629: PPUSH
22630: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22634: LD_INT 8
22636: PPUSH
22637: LD_EXP 58
22641: PPUSH
22642: CALL_OW 471
// repeat wait ( 3 ) ;
22646: LD_INT 3
22648: PPUSH
22649: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 92
22665: PUSH
22666: LD_INT 100
22668: PUSH
22669: LD_INT 75
22671: PUSH
22672: LD_INT 6
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 69
22689: IFFALSE 22646
// async ;
22691: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_STRING D6b-Pow-1
22699: PPUSH
22700: CALL_OW 88
// repeat wait ( 3 ) ;
22704: LD_INT 3
22706: PPUSH
22707: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: PPUSH
22721: CALL_OW 256
22725: PUSH
22726: LD_INT 1000
22728: LESS
22729: IFFALSE 22748
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: CALL_OW 310
22740: PPUSH
22741: LD_INT 1000
22743: PPUSH
22744: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22748: LD_EXP 58
22752: PPUSH
22753: CALL_OW 256
22757: PUSH
22758: LD_INT 1000
22760: LESS
22761: IFFALSE 22775
// SetLives ( Powell , 1000 ) ;
22763: LD_EXP 58
22767: PPUSH
22768: LD_INT 1000
22770: PPUSH
22771: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22775: LD_EXP 58
22779: PPUSH
22780: LD_EXP 63
22784: PPUSH
22785: CALL_OW 296
22789: PUSH
22790: LD_INT 5
22792: LESS
22793: PUSH
22794: LD_EXP 58
22798: PPUSH
22799: CALL_OW 310
22803: PPUSH
22804: LD_EXP 63
22808: PPUSH
22809: CALL_OW 296
22813: PUSH
22814: LD_INT 5
22816: LESS
22817: OR
22818: IFFALSE 22837
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: CALL_OW 310
22829: PPUSH
22830: LD_INT 100
22832: PPUSH
22833: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22837: LD_EXP 58
22841: PPUSH
22842: CALL_OW 310
22846: NOT
22847: IFFALSE 22704
// DoNotAttack ( 8 , powellBomb ) ;
22849: LD_INT 8
22851: PPUSH
22852: LD_EXP 63
22856: PPUSH
22857: CALL_OW 471
// game_speed := 4 ;
22861: LD_ADDR_OWVAR 65
22865: PUSH
22866: LD_INT 4
22868: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_STRING D6b-Pow-1a
22876: PPUSH
22877: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22881: LD_EXP 58
22885: PPUSH
22886: LD_EXP 63
22890: PPUSH
22891: CALL_OW 180
// sync ;
22895: SYNC
// repeat wait ( 0 0$1 ) ;
22896: LD_INT 35
22898: PPUSH
22899: CALL_OW 67
// until IsInUnit ( Powell ) ;
22903: LD_EXP 58
22907: PPUSH
22908: CALL_OW 310
22912: IFFALSE 22896
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22914: LD_INT 8
22916: PPUSH
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 91
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 44
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 96
22968: PPUSH
22969: LD_INT 41
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 92
22983: PPUSH
22984: LD_INT 39
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 88
22998: PPUSH
22999: LD_INT 41
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 91
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 44
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 96
23043: PPUSH
23044: LD_INT 41
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 92
23058: PPUSH
23059: LD_INT 39
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 88
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 91
23088: PPUSH
23089: LD_INT 44
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 39
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 93
23118: PPUSH
23119: LD_INT 36
23121: PPUSH
23122: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23126: LD_INT 122
23128: PPUSH
23129: CALL_OW 67
// game_speed := 4 ;
23133: LD_ADDR_OWVAR 65
23137: PUSH
23138: LD_INT 4
23140: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_STRING D6b-Pow-1b
23148: PPUSH
23149: CALL_OW 88
// tmp := [ ] ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_INT 78
23167: PUSH
23168: LD_INT 47
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: LD_INT 106
23177: PUSH
23178: LD_INT 53
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_INT 8
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 21
23206: PUSH
23207: LD_INT 3
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 92
23216: PUSH
23217: LD_INT 90
23219: PUSH
23220: LD_INT 52
23222: PUSH
23223: LD_INT 12
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: PPUSH
23237: CALL_OW 69
23241: PUSH
23242: FOR_IN
23243: IFFALSE 23268
// tmp := tmp ^ UnitsInside ( i ) ;
23245: LD_ADDR_VAR 0 3
23249: PUSH
23250: LD_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 313
23264: ADD
23265: ST_TO_ADDR
23266: GO 23242
23268: POP
23269: POP
// for i in tmp do
23270: LD_ADDR_VAR 0 1
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23443
// begin dist := 9999 ;
23283: LD_ADDR_VAR 0 8
23287: PUSH
23288: LD_INT 9999
23290: ST_TO_ADDR
// _xy := [ ] ;
23291: LD_ADDR_VAR 0 7
23295: PUSH
23296: EMPTY
23297: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23298: LD_VAR 0 1
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 109
// ComExitBuilding ( i ) ;
23310: LD_VAR 0 1
23314: PPUSH
23315: CALL_OW 122
// for j in xy do
23319: LD_ADDR_VAR 0 2
23323: PUSH
23324: LD_VAR 0 5
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23412
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23332: LD_VAR 0 1
23336: PPUSH
23337: LD_VAR 0 2
23341: PUSH
23342: LD_INT 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 2
23350: PUSH
23351: LD_INT 2
23353: ARRAY
23354: PPUSH
23355: CALL_OW 297
23359: PUSH
23360: LD_VAR 0 8
23364: LESS
23365: IFFALSE 23410
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_VAR 0 1
23376: PPUSH
23377: LD_VAR 0 2
23381: PUSH
23382: LD_INT 1
23384: ARRAY
23385: PPUSH
23386: LD_VAR 0 2
23390: PUSH
23391: LD_INT 2
23393: ARRAY
23394: PPUSH
23395: CALL_OW 297
23399: ST_TO_ADDR
// _xy := j ;
23400: LD_ADDR_VAR 0 7
23404: PUSH
23405: LD_VAR 0 2
23409: ST_TO_ADDR
// end ;
23410: GO 23329
23412: POP
23413: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: LD_VAR 0 7
23423: PUSH
23424: LD_INT 1
23426: ARRAY
23427: PPUSH
23428: LD_VAR 0 7
23432: PUSH
23433: LD_INT 2
23435: ARRAY
23436: PPUSH
23437: CALL_OW 171
// end ;
23441: GO 23280
23443: POP
23444: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: LD_INT 26
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 25
23467: PUSH
23468: LD_INT 1
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PPUSH
23479: CALL_OW 72
23483: ST_TO_ADDR
// if tmp2 < 2 then
23484: LD_VAR 0 4
23488: PUSH
23489: LD_INT 2
23491: LESS
23492: IFFALSE 23561
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23494: LD_ADDR_VAR 0 4
23498: PUSH
23499: LD_INT 22
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: LD_INT 1
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 3
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 15
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: LIST
23540: PPUSH
23541: CALL_OW 69
23545: PUSH
23546: LD_EXP 60
23550: PUSH
23551: LD_EXP 61
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: DIFF
23560: ST_TO_ADDR
// if tmp2 then
23561: LD_VAR 0 4
23565: IFFALSE 23583
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23567: LD_VAR 0 4
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_STRING D6b-ArSol1-1
23578: PPUSH
23579: CALL_OW 88
// async ;
23583: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23584: LD_EXP 58
23588: PPUSH
23589: LD_STRING D6b-Pow-2
23591: PPUSH
23592: CALL_OW 88
// wait ( 0 0$1 ) ;
23596: LD_INT 35
23598: PPUSH
23599: CALL_OW 67
// if tmp2 > 1 then
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 1
23610: GREATER
23611: IFFALSE 23629
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: LD_STRING D6b-ArSol2-1
23624: PPUSH
23625: CALL_OW 88
// sync ;
23629: SYNC
// repeat wait ( 5 ) ;
23630: LD_INT 5
23632: PPUSH
23633: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23637: LD_INT 93
23639: PPUSH
23640: LD_INT 36
23642: PPUSH
23643: CALL_OW 428
23647: PPUSH
23648: CALL_OW 255
23652: PUSH
23653: LD_INT 4
23655: EQUAL
23656: IFFALSE 23630
// DialogueOn ;
23658: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23662: LD_INT 10
23664: PPUSH
23665: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23669: LD_EXP 58
23673: PPUSH
23674: LD_STRING D6b-Pow-2a
23676: PPUSH
23677: CALL_OW 88
// DialogueOff ;
23681: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23685: LD_EXP 58
23689: PPUSH
23690: CALL_OW 310
23694: PPUSH
23695: LD_INT 332
23697: PPUSH
23698: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23702: LD_INT 93
23704: PPUSH
23705: LD_INT 35
23707: PPUSH
23708: LD_INT 1
23710: PPUSH
23711: LD_INT 6
23713: NEG
23714: PPUSH
23715: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23719: LD_INT 35
23721: PPUSH
23722: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23726: LD_INT 332
23728: PPUSH
23729: CALL_OW 256
23733: PUSH
23734: LD_INT 1000
23736: LESS
23737: PUSH
23738: LD_INT 332
23740: PPUSH
23741: CALL_OW 300
23745: AND
23746: IFFALSE 23758
// SetLives ( kozlov_fac , 0 ) ;
23748: LD_INT 332
23750: PPUSH
23751: LD_INT 0
23753: PPUSH
23754: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23758: LD_INT 332
23760: PPUSH
23761: CALL_OW 301
23765: PUSH
23766: LD_EXP 58
23770: PPUSH
23771: CALL_OW 301
23775: OR
23776: IFFALSE 23719
// game_speed := 4 ;
23778: LD_ADDR_OWVAR 65
23782: PUSH
23783: LD_INT 4
23785: ST_TO_ADDR
// powellCenterCameraMode := false ;
23786: LD_ADDR_EXP 20
23790: PUSH
23791: LD_INT 0
23793: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23794: LD_ADDR_VAR 0 1
23798: PUSH
23799: LD_VAR 0 3
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 8
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 25
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 69
23832: UNION
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23851
// SetTag ( i , 0 ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 0
23844: PPUSH
23845: CALL_OW 109
23849: GO 23834
23851: POP
23852: POP
// wait ( 0 0$3 ) ;
23853: LD_INT 105
23855: PPUSH
23856: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23860: LD_INT 93
23862: PPUSH
23863: LD_INT 35
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 331
// DialogueOn ;
23873: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23877: LD_VAR 0 11
23881: PPUSH
23882: LD_STRING D6c-Sol3-1
23884: PPUSH
23885: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23889: LD_INT 10
23891: PPUSH
23892: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23896: LD_EXP 39
23900: PPUSH
23901: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23905: LD_EXP 39
23909: PPUSH
23910: LD_STRING D6c-JMM-1
23912: PPUSH
23913: CALL_OW 88
// if Cyrus then
23917: LD_EXP 45
23921: IFFALSE 23935
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23923: LD_EXP 45
23927: PPUSH
23928: LD_STRING D6c-Cyrus-1
23930: PPUSH
23931: CALL_OW 88
// if Bobby then
23935: LD_EXP 44
23939: IFFALSE 23953
// Say ( Bobby , D6c-Bobby-1 ) ;
23941: LD_EXP 44
23945: PPUSH
23946: LD_STRING D6c-Bobby-1
23948: PPUSH
23949: CALL_OW 88
// if Cornel then
23953: LD_EXP 50
23957: IFFALSE 23971
// Say ( Cornel , D6c-Corn-1 ) ;
23959: LD_EXP 50
23963: PPUSH
23964: LD_STRING D6c-Corn-1
23966: PPUSH
23967: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23971: LD_ADDR_VAR 0 4
23975: PUSH
23976: LD_INT 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_INT 1
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 4
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 26
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 3
24016: PUSH
24017: LD_INT 25
24019: PUSH
24020: LD_INT 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 25
24029: PUSH
24030: LD_INT 12
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: PPUSH
24047: CALL_OW 69
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_EXP 39
24061: UNION
24062: PUSH
24063: LD_EXP 59
24067: UNION
24068: PUSH
24069: EMPTY
24070: LIST
24071: DIFF
24072: ST_TO_ADDR
// if tmp2 then
24073: LD_VAR 0 4
24077: IFFALSE 24095
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24079: LD_VAR 0 4
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: PPUSH
24088: LD_STRING D6c-Sol1-1
24090: PPUSH
24091: CALL_OW 88
// if Lisa then
24095: LD_EXP 42
24099: IFFALSE 24113
// Say ( Lisa , D6c-Lisa-1 ) ;
24101: LD_EXP 42
24105: PPUSH
24106: LD_STRING D6c-Lisa-1
24108: PPUSH
24109: CALL_OW 88
// if Gary then
24113: LD_EXP 51
24117: IFFALSE 24131
// Say ( Gary , D6c-Gary-1 ) ;
24119: LD_EXP 51
24123: PPUSH
24124: LD_STRING D6c-Gary-1
24126: PPUSH
24127: CALL_OW 88
// if Donaldson then
24131: LD_EXP 43
24135: IFFALSE 24149
// Say ( Donaldson , D6c-Don-1 ) ;
24137: LD_EXP 43
24141: PPUSH
24142: LD_STRING D6c-Don-1
24144: PPUSH
24145: CALL_OW 88
// if tmp2 > 1 then
24149: LD_VAR 0 4
24153: PUSH
24154: LD_INT 1
24156: GREATER
24157: IFFALSE 24175
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24159: LD_VAR 0 4
24163: PUSH
24164: LD_INT 2
24166: ARRAY
24167: PPUSH
24168: LD_STRING D6c-Sol2-1
24170: PPUSH
24171: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24175: LD_VAR 0 11
24179: PPUSH
24180: LD_STRING D6c-Sol3-2
24182: PPUSH
24183: CALL_OW 88
// dwait ( 0 0$1 ) ;
24187: LD_INT 35
24189: PPUSH
24190: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24194: LD_EXP 39
24198: PPUSH
24199: LD_STRING D6c-JMM-2
24201: PPUSH
24202: CALL_OW 88
// DialogueOff ;
24206: CALL_OW 7
// Video ( false ) ;
24210: LD_INT 0
24212: PPUSH
24213: CALL 100918 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24217: LD_INT 22
24219: PUSH
24220: LD_INT 4
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PPUSH
24227: CALL_OW 69
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 4
24244: PPUSH
24245: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24249: LD_ADDR_VAR 0 1
24253: PUSH
24254: LD_INT 4
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 65139 0 3
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24306
// if GetTech ( i , 1 ) <> state_researched then
24271: LD_VAR 0 1
24275: PPUSH
24276: LD_INT 1
24278: PPUSH
24279: CALL_OW 321
24283: PUSH
24284: LD_INT 2
24286: NONEQUAL
24287: IFFALSE 24304
// SetTech ( i , 1 , state_researched ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 1
24296: PPUSH
24297: LD_INT 2
24299: PPUSH
24300: CALL_OW 322
24304: GO 24268
24306: POP
24307: POP
// missionStage := 6 ;
24308: LD_ADDR_EXP 15
24312: PUSH
24313: LD_INT 6
24315: ST_TO_ADDR
// activeAttacks := true ;
24316: LD_ADDR_EXP 16
24320: PUSH
24321: LD_INT 1
24323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24324: LD_STRING M2
24326: PPUSH
24327: CALL_OW 337
// SaveForQuickRestart ;
24331: CALL_OW 22
// wait ( 0 0$40 ) ;
24335: LD_INT 1400
24337: PPUSH
24338: CALL_OW 67
// DialogueOn ;
24342: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24346: LD_EXP 62
24350: PPUSH
24351: LD_STRING D7-Friend-1
24353: PPUSH
24354: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24358: LD_EXP 39
24362: PPUSH
24363: LD_STRING D7-JMM-1
24365: PPUSH
24366: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24370: LD_EXP 62
24374: PPUSH
24375: LD_STRING D7-Friend-2
24377: PPUSH
24378: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24382: LD_EXP 39
24386: PPUSH
24387: LD_STRING D7-JMM-2
24389: PPUSH
24390: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24394: LD_EXP 62
24398: PPUSH
24399: LD_STRING D7-Friend-3
24401: PPUSH
24402: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24406: LD_EXP 39
24410: PPUSH
24411: LD_STRING D7-JMM-3
24413: PPUSH
24414: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24418: LD_EXP 62
24422: PPUSH
24423: LD_STRING D7-Friend-4
24425: PPUSH
24426: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24430: LD_EXP 39
24434: PPUSH
24435: LD_STRING D7-JMM-4
24437: PPUSH
24438: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24442: LD_EXP 62
24446: PPUSH
24447: LD_STRING D7-Friend-5
24449: PPUSH
24450: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24454: LD_EXP 39
24458: PPUSH
24459: LD_STRING D7-JMM-5
24461: PPUSH
24462: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24466: LD_EXP 62
24470: PPUSH
24471: LD_STRING D7-Friend-6
24473: PPUSH
24474: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24478: LD_EXP 39
24482: PPUSH
24483: LD_STRING D7-JMM-6
24485: PPUSH
24486: CALL_OW 88
// DialogueOff ;
24490: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24494: LD_STRING Mlegion
24496: PPUSH
24497: CALL_OW 337
// RebuildKozlovFactory ;
24501: CALL 4855 0 0
// end ;
24505: PPOPN 13
24507: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24508: LD_EXP 20
24512: PUSH
24513: LD_EXP 58
24517: PPUSH
24518: CALL_OW 300
24522: AND
24523: IFFALSE 24565
24525: GO 24527
24527: DISABLE
// begin enable ;
24528: ENABLE
// if IsInUnit ( Powell ) then
24529: LD_EXP 58
24533: PPUSH
24534: CALL_OW 310
24538: IFFALSE 24556
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24540: LD_EXP 58
24544: PPUSH
24545: CALL_OW 310
24549: PPUSH
24550: CALL_OW 85
24554: GO 24565
// CenterOnUnits ( Powell ) ;
24556: LD_EXP 58
24560: PPUSH
24561: CALL_OW 85
// end ;
24565: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24566: LD_INT 22
24568: PUSH
24569: LD_INT 8
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 34
24578: PUSH
24579: LD_INT 48
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 69
24594: IFFALSE 24868
24596: GO 24598
24598: DISABLE
24599: LD_INT 0
24601: PPUSH
24602: PPUSH
// begin if missionStage < 9 then
24603: LD_EXP 15
24607: PUSH
24608: LD_INT 9
24610: LESS
24611: IFFALSE 24621
// missionStage := 9 ;
24613: LD_ADDR_EXP 15
24617: PUSH
24618: LD_INT 9
24620: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24621: LD_ADDR_VAR 0 1
24625: PUSH
24626: LD_INT 22
24628: PUSH
24629: LD_INT 8
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 34
24638: PUSH
24639: LD_INT 48
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PPUSH
24650: CALL_OW 69
24654: PUSH
24655: LD_INT 1
24657: ARRAY
24658: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24659: LD_INT 175
24661: PPUSH
24662: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24666: LD_EXP 12
24670: PUSH
24671: LD_EXP 3
24675: PUSH
24676: LD_INT 0
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: IN
24686: OR
24687: IFFALSE 24710
// target := [ 68 , 108 , 1 ] else
24689: LD_ADDR_VAR 0 2
24693: PUSH
24694: LD_INT 68
24696: PUSH
24697: LD_INT 108
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: ST_TO_ADDR
24708: GO 24729
// target := [ 181 , 88 , 2 ] ;
24710: LD_ADDR_VAR 0 2
24714: PUSH
24715: LD_INT 181
24717: PUSH
24718: LD_INT 88
24720: PUSH
24721: LD_INT 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24729: LD_VAR 0 1
24733: PPUSH
24734: LD_VAR 0 2
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 2
24747: PUSH
24748: LD_INT 2
24750: ARRAY
24751: PPUSH
24752: CALL_OW 176
// if target [ 3 ] = 1 then
24756: LD_VAR 0 2
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 1
24767: EQUAL
24768: IFFALSE 24784
// SayRadio ( Kurt , D12-Kurt-1 ) else
24770: LD_EXP 60
24774: PPUSH
24775: LD_STRING D12-Kurt-1
24777: PPUSH
24778: CALL_OW 94
24782: GO 24808
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D12a-Kurt-1
24791: PPUSH
24792: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24796: LD_EXP 74
24800: PPUSH
24801: LD_STRING D12a-Roth-1
24803: PPUSH
24804: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24808: LD_INT 350
24810: PPUSH
24811: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24815: LD_VAR 0 1
24819: PPUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 23
24832: PUSH
24833: LD_INT 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 30
24842: PUSH
24843: LD_INT 3
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: CALL_OW 228
// end ;
24868: PPOPN 2
24870: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24871: LD_EXP 60
24875: PPUSH
24876: CALL_OW 256
24880: PUSH
24881: LD_INT 999
24883: LESS
24884: PUSH
24885: LD_INT 22
24887: PUSH
24888: LD_INT 8
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 21
24897: PUSH
24898: LD_INT 1
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 23
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: LD_INT 8
24930: PUSH
24931: LD_INT 7
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_OWVAR 67
24943: ARRAY
24944: LESSEQUAL
24945: OR
24946: PUSH
24947: LD_INT 22
24949: PUSH
24950: LD_INT 8
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 34
24959: PUSH
24960: LD_INT 48
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PPUSH
24971: CALL_OW 69
24975: NOT
24976: AND
24977: PUSH
24978: LD_EXP 60
24982: PPUSH
24983: CALL_OW 302
24987: AND
24988: PUSH
24989: LD_INT 5
24991: PPUSH
24992: LD_INT 22
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PPUSH
25002: CALL_OW 70
25006: AND
25007: IFFALSE 25712
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
25016: PPUSH
// begin DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25021: LD_EXP 39
25025: PPUSH
25026: LD_STRING D13-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25033: LD_EXP 60
25037: PPUSH
25038: LD_STRING D13-Kurt-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25045: LD_EXP 39
25049: PPUSH
25050: LD_STRING D13-JMM-2
25052: PPUSH
25053: CALL_OW 88
// if FakeInfo then
25057: LD_EXP 12
25061: IFFALSE 25081
// begin Say ( Kurt , D13-Kurt-2 ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_STRING D13-Kurt-2
25070: PPUSH
25071: CALL_OW 88
// DialogueOff ;
25075: CALL_OW 7
// exit ;
25079: GO 25712
// end ; if not KurtStatus then
25081: LD_EXP 3
25085: NOT
25086: IFFALSE 25102
// Say ( Kurt , D13-Kurt-2b ) else
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2b
25095: PPUSH
25096: CALL_OW 88
25100: GO 25114
// Say ( Kurt , D13-Kurt-2a ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_STRING D13-Kurt-2a
25109: PPUSH
25110: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25114: LD_EXP 39
25118: PPUSH
25119: LD_STRING D13-JMM-3
25121: PPUSH
25122: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25126: LD_EXP 60
25130: PPUSH
25131: LD_STRING D13-Kurt-3
25133: PPUSH
25134: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-4
25145: PPUSH
25146: CALL_OW 88
// DialogueOff ;
25150: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25154: LD_STRING MlegionOut
25156: PPUSH
25157: CALL_OW 337
// legionDestroyed := true ;
25161: LD_ADDR_EXP 22
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25169: LD_INT 3
25171: PPUSH
25172: CALL 35288 0 1
// KillUnit ( Kozlov ) ;
25176: LD_EXP 61
25180: PPUSH
25181: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_INT 22
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 23
25202: PUSH
25203: LD_INT 3
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 3
25212: PUSH
25213: LD_INT 21
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 69
25236: PUSH
25237: FOR_IN
25238: IFFALSE 25251
// KillUnit ( i ) ;
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 66
25249: GO 25237
25251: POP
25252: POP
// ChangeSideFog ( 8 , 1 ) ;
25253: LD_INT 8
25255: PPUSH
25256: LD_INT 1
25258: PPUSH
25259: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25263: LD_ADDR_VAR 0 2
25267: PUSH
25268: LD_INT 22
25270: PUSH
25271: LD_INT 8
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 21
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PPUSH
25292: CALL_OW 69
25296: PUSH
25297: LD_EXP 61
25301: PUSH
25302: LD_EXP 60
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: DIFF
25311: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25312: LD_VAR 0 2
25316: PUSH
25317: LD_INT 6
25319: PUSH
25320: LD_INT 5
25322: PUSH
25323: LD_INT 4
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_OWVAR 67
25335: ARRAY
25336: GREATEREQUAL
25337: IFFALSE 25511
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_INT 6
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: LD_INT 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_OWVAR 67
25362: ARRAY
25363: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25364: LD_ADDR_VAR 0 1
25368: PUSH
25369: DOUBLE
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: PLUS
25383: MINUS
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25507
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25392: LD_ADDR_EXP 38
25396: PUSH
25397: LD_EXP 38
25401: PUSH
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: ADD
25413: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_VAR 0 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 310
25429: IFFALSE 25446
// ComExitBuilding ( tmp [ i ] ) ;
25431: LD_VAR 0 2
25435: PUSH
25436: LD_VAR 0 1
25440: ARRAY
25441: PPUSH
25442: CALL_OW 122
// if IsInUnit ( i ) then
25446: LD_VAR 0 1
25450: PPUSH
25451: CALL_OW 310
25455: IFFALSE 25472
// ComExitVehicle ( tmp [ i ] ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 1
25481: ARRAY
25482: PPUSH
25483: LD_INT 34
25485: PUSH
25486: LD_INT 0
25488: PPUSH
25489: LD_INT 6
25491: PPUSH
25492: CALL_OW 12
25496: PLUS
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: CALL_OW 171
// end ;
25505: GO 25389
25507: POP
25508: POP
// end else
25509: GO 25521
// x := tmp ;
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: LD_VAR 0 2
25520: ST_TO_ADDR
// for i := tmp downto tmp - x do
25521: LD_ADDR_VAR 0 1
25525: PUSH
25526: DOUBLE
25527: LD_VAR 0 2
25531: INC
25532: ST_TO_ADDR
25533: LD_VAR 0 2
25537: PUSH
25538: LD_VAR 0 3
25542: MINUS
25543: PUSH
25544: FOR_DOWNTO
25545: IFFALSE 25599
// begin if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitVehicle ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25579: LD_VAR 0 2
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: PPUSH
25590: LD_INT 1
25592: PPUSH
25593: CALL_OW 235
// end ;
25597: GO 25544
25599: POP
25600: POP
// SetSide ( Kurt , 1 ) ;
25601: LD_EXP 60
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25613: LD_INT 22
25615: PUSH
25616: LD_INT 8
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 21
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PPUSH
25637: CALL_OW 69
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25649: LD_INT 8
25651: PPUSH
25652: LD_INT 1
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: LD_INT 1
25660: PPUSH
25661: CALL_OW 80
// wait ( 1 1$20 ) ;
25665: LD_INT 2800
25667: PPUSH
25668: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25672: LD_EXP 62
25676: PPUSH
25677: LD_INT 37
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 48
// wait ( 0 0$1 ) ;
25690: LD_INT 35
25692: PPUSH
25693: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 60
25704: PPUSH
25705: LD_INT 95
25707: PPUSH
25708: CALL_OW 111
// end ;
25712: PPOPN 3
25714: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25715: LD_EXP 22
25719: NOT
25720: PUSH
25721: LD_INT 22
25723: PUSH
25724: LD_INT 8
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 21
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PPUSH
25745: CALL_OW 69
25749: PUSH
25750: LD_INT 0
25752: EQUAL
25753: AND
25754: IFFALSE 25774
25756: GO 25758
25758: DISABLE
// begin legionDestroyed := true ;
25759: LD_ADDR_EXP 22
25763: PUSH
25764: LD_INT 1
25766: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25767: LD_STRING MlegionOut
25769: PPUSH
25770: CALL_OW 337
// end ;
25774: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25775: LD_EXP 38
25779: IFFALSE 25854
25781: GO 25783
25783: DISABLE
25784: LD_INT 0
25786: PPUSH
// begin enable ;
25787: ENABLE
// for i in legionEscapeUnits do
25788: LD_ADDR_VAR 0 1
25792: PUSH
25793: LD_EXP 38
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25852
// begin if IsInArea ( i , legionEscapeArea ) then
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 31
25808: PPUSH
25809: CALL_OW 308
25813: IFFALSE 25826
// RemoveUnit ( i ) else
25815: LD_VAR 0 1
25819: PPUSH
25820: CALL_OW 64
25824: GO 25850
// if not HasTask ( i ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: CALL_OW 314
25835: NOT
25836: IFFALSE 25850
// ComMoveToArea ( i , legionEscapeArea ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 31
25845: PPUSH
25846: CALL_OW 113
// end ;
25850: GO 25798
25852: POP
25853: POP
// end ;
25854: PPOPN 1
25856: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25857: LD_INT 1
25859: PPUSH
25860: LD_EXP 62
25864: PPUSH
25865: CALL_OW 292
25869: IFFALSE 26167
25871: GO 25873
25873: DISABLE
25874: LD_INT 0
25876: PPUSH
// begin wait ( 0 0$2 ) ;
25877: LD_INT 70
25879: PPUSH
25880: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25884: LD_EXP 62
25888: PPUSH
25889: CALL_OW 87
// DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14-JMM-2
25928: PPUSH
25929: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25933: LD_EXP 62
25937: PPUSH
25938: LD_STRING D14-Friend-2
25940: PPUSH
25941: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25945: LD_EXP 39
25949: PPUSH
25950: LD_STRING D14-JMM-3
25952: PPUSH
25953: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25957: LD_EXP 62
25961: PPUSH
25962: LD_STRING D14-Friend-3
25964: PPUSH
25965: CALL_OW 88
// DialogueOff ;
25969: CALL_OW 7
// dec = Query ( Q14 ) ;
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: LD_STRING Q14
25980: PPUSH
25981: CALL_OW 97
25985: ST_TO_ADDR
// if dec = 1 then
25986: LD_VAR 0 1
25990: PUSH
25991: LD_INT 1
25993: EQUAL
25994: IFFALSE 26028
// begin DialogueOn ;
25996: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26000: LD_EXP 39
26004: PPUSH
26005: LD_STRING D14a-JMM-1
26007: PPUSH
26008: CALL_OW 88
// DialogueOff ;
26012: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26016: LD_EXP 62
26020: PPUSH
26021: LD_INT 1
26023: PPUSH
26024: CALL_OW 235
// end ; if dec = 2 then
26028: LD_VAR 0 1
26032: PUSH
26033: LD_INT 2
26035: EQUAL
26036: IFFALSE 26089
// begin DialogueOn ;
26038: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26042: LD_EXP 39
26046: PPUSH
26047: LD_STRING D14b-JMM-1
26049: PPUSH
26050: CALL_OW 88
// DialogueOff ;
26054: CALL_OW 7
// wait ( 0 0$1 ) ;
26058: LD_INT 35
26060: PPUSH
26061: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26065: LD_EXP 62
26069: PPUSH
26070: LD_INT 9
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL_OW 111
// AddComHold ( Friend ) ;
26080: LD_EXP 62
26084: PPUSH
26085: CALL_OW 200
// end ; if dec = 3 then
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 3
26096: EQUAL
26097: IFFALSE 26167
// begin DialogueOn ;
26099: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26103: LD_EXP 39
26107: PPUSH
26108: LD_STRING D14c-JMM-1
26110: PPUSH
26111: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26115: LD_EXP 62
26119: PPUSH
26120: LD_STRING D14c-Friend-1
26122: PPUSH
26123: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26127: LD_EXP 39
26131: PPUSH
26132: LD_STRING D14c-JMM-2
26134: PPUSH
26135: CALL_OW 88
// DialogueOff ;
26139: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26143: LD_EXP 62
26147: PPUSH
26148: LD_INT 9
26150: PPUSH
26151: LD_INT 2
26153: PPUSH
26154: CALL_OW 111
// AddComHold ( Friend ) ;
26158: LD_EXP 62
26162: PPUSH
26163: CALL_OW 200
// end ; end ;
26167: PPOPN 1
26169: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26170: LD_INT 9
26172: PPUSH
26173: LD_INT 2
26175: PPUSH
26176: CALL_OW 428
26180: PUSH
26181: LD_EXP 62
26185: EQUAL
26186: PUSH
26187: LD_EXP 62
26191: PPUSH
26192: CALL_OW 255
26196: PUSH
26197: LD_INT 8
26199: EQUAL
26200: AND
26201: IFFALSE 26215
26203: GO 26205
26205: DISABLE
// RemoveUnit ( Friend ) ;
26206: LD_EXP 62
26210: PPUSH
26211: CALL_OW 64
26215: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26216: LD_EXP 14
26220: PUSH
26221: LD_INT 31500
26223: GREATEREQUAL
26224: PUSH
26225: LD_EXP 7
26229: AND
26230: PUSH
26231: LD_EXP 2
26235: AND
26236: IFFALSE 26666
26238: GO 26240
26240: DISABLE
26241: LD_INT 0
26243: PPUSH
26244: PPUSH
26245: PPUSH
// begin missionStage := 7 ;
26246: LD_ADDR_EXP 15
26250: PUSH
26251: LD_INT 7
26253: ST_TO_ADDR
// uc_side = 1 ;
26254: LD_ADDR_OWVAR 20
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// uc_nation = 1 ;
26262: LD_ADDR_OWVAR 21
26266: PUSH
26267: LD_INT 1
26269: ST_TO_ADDR
// for i = 1 to 5 do
26270: LD_ADDR_VAR 0 1
26274: PUSH
26275: DOUBLE
26276: LD_INT 1
26278: DEC
26279: ST_TO_ADDR
26280: LD_INT 5
26282: PUSH
26283: FOR_TO
26284: IFFALSE 26380
// begin vc_engine = 3 ;
26286: LD_ADDR_OWVAR 39
26290: PUSH
26291: LD_INT 3
26293: ST_TO_ADDR
// vc_control = 3 ;
26294: LD_ADDR_OWVAR 38
26298: PUSH
26299: LD_INT 3
26301: ST_TO_ADDR
// vc_chassis = 3 ;
26302: LD_ADDR_OWVAR 37
26306: PUSH
26307: LD_INT 3
26309: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26310: LD_ADDR_OWVAR 40
26314: PUSH
26315: LD_INT 5
26317: PUSH
26318: LD_INT 9
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PPUSH
26332: LD_INT 3
26334: PPUSH
26335: CALL_OW 12
26339: ARRAY
26340: ST_TO_ADDR
// veh = CreateVehicle ;
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: CALL_OW 45
26350: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26351: LD_VAR 0 2
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26363: LD_VAR 0 2
26367: PPUSH
26368: LD_INT 19
26370: PPUSH
26371: LD_INT 0
26373: PPUSH
26374: CALL_OW 49
// end ;
26378: GO 26283
26380: POP
26381: POP
// vc_engine = 3 ;
26382: LD_ADDR_OWVAR 39
26386: PUSH
26387: LD_INT 3
26389: ST_TO_ADDR
// vc_control = 1 ;
26390: LD_ADDR_OWVAR 38
26394: PUSH
26395: LD_INT 1
26397: ST_TO_ADDR
// vc_chassis = 3 ;
26398: LD_ADDR_OWVAR 37
26402: PUSH
26403: LD_INT 3
26405: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26406: LD_ADDR_OWVAR 40
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: LD_INT 9
26416: PUSH
26417: LD_INT 7
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 1
26427: PPUSH
26428: LD_INT 3
26430: PPUSH
26431: CALL_OW 12
26435: ARRAY
26436: ST_TO_ADDR
// vehG = CreateVehicle ;
26437: LD_ADDR_VAR 0 3
26441: PUSH
26442: CALL_OW 45
26446: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26447: LD_VAR 0 3
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26459: LD_VAR 0 3
26463: PPUSH
26464: LD_INT 19
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 49
// if JMMGirl = 1 then
26474: LD_EXP 7
26478: PUSH
26479: LD_INT 1
26481: EQUAL
26482: IFFALSE 26538
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26484: LD_ADDR_EXP 40
26488: PUSH
26489: LD_STRING Joan
26491: PPUSH
26492: LD_INT 1
26494: PPUSH
26495: LD_STRING 14_
26497: PPUSH
26498: CALL 65076 0 3
26502: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26503: LD_EXP 40
26507: PPUSH
26508: LD_VAR 0 3
26512: PPUSH
26513: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26517: LD_VAR 0 3
26521: PPUSH
26522: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26526: LD_EXP 40
26530: PPUSH
26531: LD_STRING D10BW-Joan-1
26533: PPUSH
26534: CALL_OW 94
// end ; if JMMGirl = 2 then
26538: LD_EXP 7
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: IFFALSE 26602
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26548: LD_ADDR_EXP 42
26552: PUSH
26553: LD_STRING Lisa
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_STRING 14_
26561: PPUSH
26562: CALL 65076 0 3
26566: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26567: LD_EXP 42
26571: PPUSH
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26590: LD_EXP 42
26594: PPUSH
26595: LD_STRING D10BW-Lisa-1
26597: PPUSH
26598: CALL_OW 94
// end ; if JMMGirl = 3 then
26602: LD_EXP 7
26606: PUSH
26607: LD_INT 3
26609: EQUAL
26610: IFFALSE 26666
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26612: LD_ADDR_EXP 54
26616: PUSH
26617: LD_STRING Connie
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_STRING 14_
26625: PPUSH
26626: CALL 65076 0 3
26630: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26631: LD_EXP 54
26635: PPUSH
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26654: LD_EXP 54
26658: PPUSH
26659: LD_STRING D10BW-Con-1
26661: PPUSH
26662: CALL_OW 94
// end ; end ;
26666: PPOPN 3
26668: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26669: LD_EXP 14
26673: PUSH
26674: LD_INT 94500
26676: GREATEREQUAL
26677: IFFALSE 27089
26679: GO 26681
26681: DISABLE
26682: LD_INT 0
26684: PPUSH
26685: PPUSH
26686: PPUSH
// begin tmp := PrepareStevensSquad ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: CALL 2197 0 0
26696: ST_TO_ADDR
// if not tmp then
26697: LD_VAR 0 3
26701: NOT
26702: IFFALSE 26706
// exit ;
26704: GO 27089
// uc_side := 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation := 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i in tmp do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_VAR 0 3
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26830
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26735: LD_INT 3
26737: PPUSH
26738: LD_INT 3
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: PPUSH
26761: LD_INT 3
26763: PPUSH
26764: CALL_OW 12
26768: ARRAY
26769: PPUSH
26770: LD_INT 40
26772: PPUSH
26773: CALL 69900 0 5
// veh := CreateVehicle ;
26777: LD_ADDR_VAR 0 2
26781: PUSH
26782: CALL_OW 45
26786: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26787: LD_VAR 0 2
26791: PPUSH
26792: LD_INT 1
26794: PPUSH
26795: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26799: LD_VAR 0 2
26803: PPUSH
26804: LD_INT 19
26806: PPUSH
26807: LD_INT 0
26809: PPUSH
26810: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26814: LD_VAR 0 1
26818: PPUSH
26819: LD_VAR 0 2
26823: PPUSH
26824: CALL_OW 52
// end ;
26828: GO 26732
26830: POP
26831: POP
// missionStage := 8 ;
26832: LD_ADDR_EXP 15
26836: PUSH
26837: LD_INT 8
26839: ST_TO_ADDR
// DialogueOn ;
26840: CALL_OW 6
// if Stevens then
26844: LD_EXP 41
26848: IFFALSE 26962
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26850: LD_EXP 41
26854: PPUSH
26855: CALL_OW 310
26859: PPUSH
26860: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26864: LD_EXP 41
26868: PPUSH
26869: LD_STRING D8-Huck-1
26871: PPUSH
26872: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26876: LD_EXP 39
26880: PPUSH
26881: LD_STRING D8-JMM-1
26883: PPUSH
26884: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26888: LD_EXP 41
26892: PPUSH
26893: LD_STRING D8-Huck-2
26895: PPUSH
26896: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26900: LD_EXP 39
26904: PPUSH
26905: LD_STRING D8-JMM-2
26907: PPUSH
26908: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26912: LD_EXP 41
26916: PPUSH
26917: LD_STRING D8-Huck-3
26919: PPUSH
26920: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26924: LD_EXP 39
26928: PPUSH
26929: LD_STRING D8-JMM-3
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26936: LD_EXP 41
26940: PPUSH
26941: LD_STRING D8-Huck-4
26943: PPUSH
26944: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26948: LD_EXP 39
26952: PPUSH
26953: LD_STRING D8-JMM-4
26955: PPUSH
26956: CALL_OW 88
// end else
26960: GO 27072
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26962: LD_EXP 55
26966: PPUSH
26967: CALL_OW 310
26971: PPUSH
26972: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26976: LD_EXP 55
26980: PPUSH
26981: LD_STRING D8-Huck-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D8-JMM-1a
26995: PPUSH
26996: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27000: LD_EXP 55
27004: PPUSH
27005: LD_STRING D8-Huck-2
27007: PPUSH
27008: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27012: LD_EXP 39
27016: PPUSH
27017: LD_STRING D8-JMM-2
27019: PPUSH
27020: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27024: LD_EXP 55
27028: PPUSH
27029: LD_STRING D8-Huck-3
27031: PPUSH
27032: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27036: LD_EXP 39
27040: PPUSH
27041: LD_STRING D8-JMM-3
27043: PPUSH
27044: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27048: LD_EXP 55
27052: PPUSH
27053: LD_STRING D8-Huck-4
27055: PPUSH
27056: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27060: LD_EXP 39
27064: PPUSH
27065: LD_STRING D8-JMM-4
27067: PPUSH
27068: CALL_OW 88
// end ; DialogueOff ;
27072: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27076: LD_INT 25
27078: PPUSH
27079: LD_INT 1
27081: PPUSH
27082: LD_INT 1
27084: PPUSH
27085: CALL_OW 322
// end ;
27089: PPOPN 3
27091: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27092: LD_INT 1
27094: PPUSH
27095: LD_EXP 71
27099: PPUSH
27100: CALL_OW 292
27104: IFFALSE 27355
27106: GO 27108
27108: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27109: LD_EXP 71
27113: PPUSH
27114: CALL_OW 87
// DialogueOn ;
27118: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-1
27129: PPUSH
27130: CALL_OW 88
// if BurlakStatus = 1 then
27134: LD_EXP 9
27138: PUSH
27139: LD_INT 1
27141: EQUAL
27142: IFFALSE 27156
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-1a
27151: PPUSH
27152: CALL_OW 94
// end ; if BurlakStatus = 0 then
27156: LD_EXP 9
27160: PUSH
27161: LD_INT 0
27163: EQUAL
27164: IFFALSE 27178
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27166: LD_EXP 70
27170: PPUSH
27171: LD_STRING D10nB-Vse-1
27173: PPUSH
27174: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27178: LD_EXP 39
27182: PPUSH
27183: LD_STRING D10nB-JMM-2
27185: PPUSH
27186: CALL_OW 88
// if KappaStatus then
27190: LD_EXP 2
27194: IFFALSE 27208
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27196: LD_EXP 70
27200: PPUSH
27201: LD_STRING D10nB-Vse-5a
27203: PPUSH
27204: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27208: LD_EXP 2
27212: NOT
27213: PUSH
27214: LD_EXP 6
27218: PUSH
27219: LD_INT 0
27221: EQUAL
27222: AND
27223: IFFALSE 27351
// begin if JMMGirl = 1 then
27225: LD_EXP 7
27229: PUSH
27230: LD_INT 1
27232: EQUAL
27233: IFFALSE 27283
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27235: LD_EXP 70
27239: PPUSH
27240: LD_STRING D10nB-Vse-2
27242: PPUSH
27243: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27259: LD_EXP 70
27263: PPUSH
27264: LD_STRING D10nB-Vse-3
27266: PPUSH
27267: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27271: LD_EXP 39
27275: PPUSH
27276: LD_STRING D10nB-JMM-4
27278: PPUSH
27279: CALL_OW 88
// end ; if JMMGirl = 2 then
27283: LD_EXP 7
27287: PUSH
27288: LD_INT 2
27290: EQUAL
27291: IFFALSE 27317
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27293: LD_EXP 70
27297: PPUSH
27298: LD_STRING D10nB-Vse-4
27300: PPUSH
27301: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27305: LD_EXP 39
27309: PPUSH
27310: LD_STRING D10nB-JMM-5
27312: PPUSH
27313: CALL_OW 88
// end ; if JMMGirl = 3 then
27317: LD_EXP 7
27321: PUSH
27322: LD_INT 3
27324: EQUAL
27325: IFFALSE 27351
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27327: LD_EXP 70
27331: PPUSH
27332: LD_STRING D10nB-Vse-5
27334: PPUSH
27335: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27339: LD_EXP 39
27343: PPUSH
27344: LD_STRING D10nB-JMM-6
27346: PPUSH
27347: CALL_OW 88
// end ; end ; DialogueOff ;
27351: CALL_OW 7
// end ;
27355: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27356: LD_EXP 14
27360: PUSH
27361: LD_INT 115500
27363: GREATEREQUAL
27364: IFFALSE 27740
27366: GO 27368
27368: DISABLE
27369: LD_INT 0
27371: PPUSH
// begin missionStage := 10 ;
27372: LD_ADDR_EXP 15
27376: PUSH
27377: LD_INT 10
27379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27380: LD_ADDR_VAR 0 1
27384: PUSH
27385: LD_INT 22
27387: PUSH
27388: LD_INT 1
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 23
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 26
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 25
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 3
27434: PUSH
27435: LD_INT 25
27437: PUSH
27438: LD_INT 16
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PPUSH
27456: CALL_OW 69
27460: PUSH
27461: LD_EXP 39
27465: PUSH
27466: LD_EXP 60
27470: PUSH
27471: LD_EXP 41
27475: PUSH
27476: LD_EXP 55
27480: PUSH
27481: LD_EXP 42
27485: PUSH
27486: LD_EXP 43
27490: PUSH
27491: LD_EXP 44
27495: PUSH
27496: LD_EXP 45
27500: PUSH
27501: LD_EXP 46
27505: PUSH
27506: LD_EXP 47
27510: PUSH
27511: LD_EXP 48
27515: PUSH
27516: LD_EXP 49
27520: PUSH
27521: LD_EXP 50
27525: PUSH
27526: LD_EXP 51
27530: PUSH
27531: LD_EXP 52
27535: PUSH
27536: LD_EXP 53
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// if not tmp and Brown then
27560: LD_VAR 0 1
27564: NOT
27565: PUSH
27566: LD_EXP 47
27570: AND
27571: IFFALSE 27586
// tmp := [ Brown ] ;
27573: LD_ADDR_VAR 0 1
27577: PUSH
27578: LD_EXP 47
27582: PUSH
27583: EMPTY
27584: LIST
27585: ST_TO_ADDR
// DialogueOn ;
27586: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27590: LD_VAR 0 1
27594: PUSH
27595: LD_INT 1
27597: ARRAY
27598: PPUSH
27599: LD_STRING D11-Sol1-1
27601: PPUSH
27602: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27606: LD_EXP 64
27610: PPUSH
27611: LD_STRING D11-Pla-1
27613: PPUSH
27614: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27618: LD_EXP 65
27622: PPUSH
27623: LD_STRING D11-Kov-1
27625: PPUSH
27626: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27630: LD_EXP 64
27634: PPUSH
27635: LD_STRING D11-Pla-2
27637: PPUSH
27638: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27642: LD_VAR 0 1
27646: PUSH
27647: LD_INT 1
27649: ARRAY
27650: PPUSH
27651: LD_STRING D11-Sol1-2
27653: PPUSH
27654: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27658: LD_EXP 39
27662: PPUSH
27663: LD_STRING D11-JMM-2
27665: PPUSH
27666: CALL_OW 88
// DialogueOff ;
27670: CALL_OW 7
// allowBehemothConstruct := true ;
27674: LD_ADDR_EXP 25
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27682: LD_STRING M4
27684: PPUSH
27685: CALL_OW 337
// BuildBehemoths ;
27689: CALL 7668 0 0
// repeat wait ( 15 15$00 ) ;
27693: LD_INT 31500
27695: PPUSH
27696: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27700: LD_EXP 27
27704: IFFALSE 27708
// break ;
27706: GO 27740
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27708: LD_INT 267
27710: PPUSH
27711: CALL_OW 274
27715: PPUSH
27716: LD_INT 1
27718: PPUSH
27719: CALL_OW 275
27723: PUSH
27724: LD_INT 1000
27726: GREATEREQUAL
27727: IFFALSE 27733
// BuildBehemoths ;
27729: CALL 7668 0 0
// until not behemothBuilders ;
27733: LD_EXP 73
27737: NOT
27738: IFFALSE 27693
// end ;
27740: PPOPN 1
27742: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27743: LD_EXP 73
27747: NOT
27748: PUSH
27749: LD_EXP 28
27753: NOT
27754: AND
27755: PUSH
27756: LD_EXP 25
27760: AND
27761: IFFALSE 27781
27763: GO 27765
27765: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27766: LD_STRING M4a
27768: PPUSH
27769: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27773: LD_ADDR_EXP 27
27777: PUSH
27778: LD_INT 1
27780: ST_TO_ADDR
// end ;
27781: END
// every 0 0$1 trigger behemothDone do
27782: LD_EXP 28
27786: IFFALSE 27798
27788: GO 27790
27790: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27791: LD_STRING M4b
27793: PPUSH
27794: CALL_OW 337
27798: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27799: LD_EXP 29
27803: NOT
27804: IFFALSE 28000
27806: GO 27808
27808: DISABLE
27809: LD_INT 0
27811: PPUSH
27812: PPUSH
// begin enable ;
27813: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27814: LD_ADDR_VAR 0 1
27818: PUSH
27819: LD_INT 3
27821: PPUSH
27822: CALL 100994 0 1
27826: ST_TO_ADDR
// if not tmp and not behemothDone then
27827: LD_VAR 0 1
27831: NOT
27832: PUSH
27833: LD_EXP 28
27837: NOT
27838: AND
27839: IFFALSE 27875
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27841: LD_ADDR_VAR 0 1
27845: PUSH
27846: LD_INT 22
27848: PUSH
27849: LD_INT 3
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 37
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: ST_TO_ADDR
// if not tmp then
27875: LD_VAR 0 1
27879: NOT
27880: IFFALSE 27884
// exit ;
27882: GO 28000
// for i in tmp do
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: FOR_IN
27895: IFFALSE 27998
// if See ( 1 , i ) then
27897: LD_INT 1
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: CALL_OW 292
27909: IFFALSE 27996
// begin if GetType ( i ) = unit_building then
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 247
27920: PUSH
27921: LD_INT 3
27923: EQUAL
27924: IFFALSE 27962
// begin CenterNowOnUnits ( i ) ;
27926: LD_VAR 0 2
27930: PPUSH
27931: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27935: LD_EXP 39
27939: PPUSH
27940: LD_STRING D17a-JMM-1
27942: PPUSH
27943: CALL_OW 88
// seeBehemoth := true ;
27947: LD_ADDR_EXP 29
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// disable ;
27955: DISABLE
// exit ;
27956: POP
27957: POP
27958: GO 28000
// end else
27960: GO 27996
// begin CenterNowOnUnits ( i ) ;
27962: LD_VAR 0 2
27966: PPUSH
27967: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27971: LD_EXP 39
27975: PPUSH
27976: LD_STRING D17b-JMM-1
27978: PPUSH
27979: CALL_OW 88
// seeBehemoth := true ;
27983: LD_ADDR_EXP 29
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// disable ;
27991: DISABLE
// exit ;
27992: POP
27993: POP
27994: GO 28000
// end ; end ;
27996: GO 27894
27998: POP
27999: POP
// end ;
28000: PPOPN 2
28002: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28003: LD_EXP 14
28007: PUSH
28008: LD_INT 123200
28010: GREATEREQUAL
28011: IFFALSE 29187
28013: GO 28015
28015: DISABLE
28016: LD_INT 0
28018: PPUSH
28019: PPUSH
28020: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28021: LD_INT 2
28023: PPUSH
28024: LD_INT 23
28026: PUSH
28027: LD_INT 3
28029: PUSH
28030: LD_INT 3
28032: PUSH
28033: LD_INT 48
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: EMPTY
28043: LIST
28044: PPUSH
28045: CALL 58732 0 2
// repeat wait ( 0 0$1 ) ;
28049: LD_INT 35
28051: PPUSH
28052: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28056: LD_INT 22
28058: PUSH
28059: LD_INT 3
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 34
28068: PUSH
28069: LD_INT 48
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 69
28084: IFFALSE 28049
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28086: LD_ADDR_VAR 0 1
28090: PUSH
28091: LD_INT 22
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 48
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: ST_TO_ADDR
// missionStage := 12 ;
28124: LD_ADDR_EXP 15
28128: PUSH
28129: LD_INT 12
28131: ST_TO_ADDR
// platonovHasBomb := true ;
28132: LD_ADDR_EXP 30
28136: PUSH
28137: LD_INT 1
28139: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 181
28147: PPUSH
28148: LD_INT 86
28150: PPUSH
28151: CALL_OW 171
// AddComHold ( bomb ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 200
// wait ( 0 0$10 ) ;
28164: LD_INT 350
28166: PPUSH
28167: CALL_OW 67
// DialogueOn ;
28171: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28175: LD_EXP 64
28179: PPUSH
28180: LD_STRING D15-Pla-1
28182: PPUSH
28183: CALL_OW 94
// dec = Query ( Q15a ) ;
28187: LD_ADDR_VAR 0 2
28191: PUSH
28192: LD_STRING Q15a
28194: PPUSH
28195: CALL_OW 97
28199: ST_TO_ADDR
// if dec = 1 then
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28231
// begin Say ( JMM , D15a-JMM-1 ) ;
28210: LD_EXP 39
28214: PPUSH
28215: LD_STRING D15a-JMM-1
28217: PPUSH
28218: CALL_OW 88
// YouLost ( Surrender ) ;
28222: LD_STRING Surrender
28224: PPUSH
28225: CALL_OW 104
// exit ;
28229: GO 29187
// end ; if dec = 2 then
28231: LD_VAR 0 2
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28308
// begin Say ( JMM , D15b-JMM-1 ) ;
28241: LD_EXP 39
28245: PPUSH
28246: LD_STRING D15b-JMM-1
28248: PPUSH
28249: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28253: LD_EXP 64
28257: PPUSH
28258: LD_STRING D15b-Pla-1
28260: PPUSH
28261: CALL_OW 94
// DialogueOff ;
28265: CALL_OW 7
// wait ( 3 3$00 ) ;
28269: LD_INT 6300
28271: PPUSH
28272: CALL_OW 67
// DialogueOn ;
28276: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28280: LD_EXP 39
28284: PPUSH
28285: LD_STRING D15d-JMM-1a
28287: PPUSH
28288: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28292: LD_EXP 64
28296: PPUSH
28297: LD_STRING D15d-Pla-1
28299: PPUSH
28300: CALL_OW 94
// DialogueOff ;
28304: CALL_OW 7
// end ; if dec = 3 then
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 3
28315: EQUAL
28316: IFFALSE 28370
// begin Say ( JMM , D15c-JMM-1 ) ;
28318: LD_EXP 39
28322: PPUSH
28323: LD_STRING D15c-JMM-1
28325: PPUSH
28326: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28330: LD_EXP 64
28334: PPUSH
28335: LD_STRING D15c-Pla-1
28337: PPUSH
28338: CALL_OW 94
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$15 ) ;
28346: LD_INT 525
28348: PPUSH
28349: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28353: LD_VAR 0 1
28357: PPUSH
28358: LD_INT 60
28360: PPUSH
28361: LD_INT 95
28363: PPUSH
28364: CALL_OW 116
// exit ;
28368: GO 29187
// end ; if dec = 4 then
28370: LD_VAR 0 2
28374: PUSH
28375: LD_INT 4
28377: EQUAL
28378: IFFALSE 28408
// begin Say ( JMM , D15d-JMM-1 ) ;
28380: LD_EXP 39
28384: PPUSH
28385: LD_STRING D15d-JMM-1
28387: PPUSH
28388: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28392: LD_EXP 64
28396: PPUSH
28397: LD_STRING D15d-Pla-1
28399: PPUSH
28400: CALL_OW 94
// DialogueOff ;
28404: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28408: LD_EXP 62
28412: PPUSH
28413: CALL_OW 302
28417: PUSH
28418: LD_EXP 62
28422: PPUSH
28423: CALL_OW 255
28427: PUSH
28428: LD_INT 1
28430: EQUAL
28431: AND
28432: PUSH
28433: LD_INT 22
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 34
28445: PUSH
28446: LD_INT 8
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PPUSH
28457: CALL_OW 69
28461: NOT
28462: AND
28463: IFFALSE 29088
// begin SetSide ( Friend , 8 ) ;
28465: LD_EXP 62
28469: PPUSH
28470: LD_INT 8
28472: PPUSH
28473: CALL_OW 235
// if IsInUnit ( Friend ) then
28477: LD_EXP 62
28481: PPUSH
28482: CALL_OW 310
28486: IFFALSE 28497
// ComExitBuilding ( Friend ) ;
28488: LD_EXP 62
28492: PPUSH
28493: CALL_OW 122
// if IsDriver ( Friend ) then
28497: LD_EXP 62
28501: PPUSH
28502: CALL 98671 0 1
28506: IFFALSE 28517
// ComExitVehicle ( Friend ) ;
28508: LD_EXP 62
28512: PPUSH
28513: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28517: LD_EXP 62
28521: PPUSH
28522: LD_INT 9
28524: PPUSH
28525: LD_INT 2
28527: PPUSH
28528: CALL_OW 171
// wait ( 0 0$05 ) ;
28532: LD_INT 175
28534: PPUSH
28535: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28539: LD_EXP 62
28543: PPUSH
28544: CALL_OW 87
// DialogueOn ;
28548: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28552: LD_EXP 39
28556: PPUSH
28557: LD_STRING D16-JMM-1
28559: PPUSH
28560: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28564: LD_EXP 62
28568: PPUSH
28569: LD_STRING D16-Friend-1
28571: PPUSH
28572: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28576: LD_EXP 39
28580: PPUSH
28581: LD_STRING D16-JMM-2
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28592: LD_EXP 62
28596: PPUSH
28597: LD_INT 1
28599: PPUSH
28600: CALL_OW 235
// ComHold ( Friend ) ;
28604: LD_EXP 62
28608: PPUSH
28609: CALL_OW 140
// wait ( 0 0$20 ) ;
28613: LD_INT 700
28615: PPUSH
28616: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28620: LD_EXP 62
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 297
28635: PUSH
28636: LD_INT 30
28638: LESS
28639: IFFALSE 28708
// begin SetSide ( Friend , 8 ) ;
28641: LD_EXP 62
28645: PPUSH
28646: LD_INT 8
28648: PPUSH
28649: CALL_OW 235
// if IsInUnit ( Friend ) then
28653: LD_EXP 62
28657: PPUSH
28658: CALL_OW 310
28662: IFFALSE 28673
// ComExitBuilding ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 122
// if IsDriver ( Friend ) then
28673: LD_EXP 62
28677: PPUSH
28678: CALL 98671 0 1
28682: IFFALSE 28693
// ComExitVehicle ( Friend ) ;
28684: LD_EXP 62
28688: PPUSH
28689: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28693: LD_EXP 62
28697: PPUSH
28698: LD_INT 9
28700: PPUSH
28701: LD_INT 2
28703: PPUSH
28704: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28708: LD_INT 1050
28710: PPUSH
28711: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28715: LD_INT 22
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 34
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: NOT
28744: IFFALSE 29066
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28746: LD_ADDR_VAR 0 3
28750: PUSH
28751: LD_INT 22
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 26
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: PUSH
28774: LD_INT 25
28776: PUSH
28777: LD_INT 12
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 25
28786: PUSH
28787: LD_INT 16
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PPUSH
28804: CALL_OW 69
28808: PUSH
28809: LD_EXP 39
28813: PUSH
28814: LD_EXP 41
28818: PUSH
28819: LD_EXP 55
28823: PUSH
28824: LD_EXP 42
28828: PUSH
28829: LD_EXP 43
28833: PUSH
28834: LD_EXP 44
28838: PUSH
28839: LD_EXP 45
28843: PUSH
28844: LD_EXP 46
28848: PUSH
28849: LD_EXP 47
28853: PUSH
28854: LD_EXP 48
28858: PUSH
28859: LD_EXP 49
28863: PUSH
28864: LD_EXP 50
28868: PUSH
28869: LD_EXP 51
28873: PUSH
28874: LD_EXP 52
28878: PUSH
28879: LD_EXP 53
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: DIFF
28901: ST_TO_ADDR
// DialogueOn ;
28902: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28906: LD_EXP 64
28910: PPUSH
28911: LD_STRING D16a-Pla-1
28913: PPUSH
28914: CALL_OW 94
// if Stevens then
28918: LD_EXP 41
28922: IFFALSE 28938
// Say ( Stevens , D16a-Huck-1 ) else
28924: LD_EXP 41
28928: PPUSH
28929: LD_STRING D16a-Huck-1
28931: PPUSH
28932: CALL_OW 88
28936: GO 28980
// if Baker then
28938: LD_EXP 55
28942: IFFALSE 28958
// Say ( Baker , D16a-Huck-1 ) else
28944: LD_EXP 55
28948: PPUSH
28949: LD_STRING D16a-Huck-1
28951: PPUSH
28952: CALL_OW 88
28956: GO 28980
// if tmp then
28958: LD_VAR 0 3
28962: IFFALSE 28980
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28964: LD_VAR 0 3
28968: PUSH
28969: LD_INT 1
28971: ARRAY
28972: PPUSH
28973: LD_STRING D16a-Sol1-1
28975: PPUSH
28976: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28980: LD_EXP 62
28984: PPUSH
28985: CALL_OW 255
28989: PUSH
28990: LD_INT 8
28992: EQUAL
28993: IFFALSE 29009
// Say ( JMM , D16a-JMM-1 ) else
28995: LD_EXP 39
28999: PPUSH
29000: LD_STRING D16a-JMM-1
29002: PPUSH
29003: CALL_OW 88
29007: GO 29045
// begin Say ( JMM , D16a-JMM-1a ) ;
29009: LD_EXP 39
29013: PPUSH
29014: LD_STRING D16a-JMM-1a
29016: PPUSH
29017: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29021: LD_EXP 62
29025: PPUSH
29026: LD_STRING D16a-Friend-1
29028: PPUSH
29029: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29033: LD_EXP 62
29037: PPUSH
29038: LD_INT 3
29040: PPUSH
29041: CALL_OW 235
// end ; DialogueOff ;
29045: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29049: LD_VAR 0 1
29053: PPUSH
29054: LD_INT 60
29056: PPUSH
29057: LD_INT 95
29059: PPUSH
29060: CALL_OW 116
// end else
29064: GO 29086
// begin DialogueOn ;
29066: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29070: LD_EXP 64
29074: PPUSH
29075: LD_STRING D16c-Pla-
29077: PPUSH
29078: CALL_OW 94
// DialogueOff ;
29082: CALL_OW 7
// end ; end else
29086: GO 29187
// begin wait ( 3 3$00 ) ;
29088: LD_INT 6300
29090: PPUSH
29091: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29095: LD_INT 22
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 34
29107: PUSH
29108: LD_INT 8
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: CALL_OW 69
29123: NOT
29124: IFFALSE 29167
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29126: LD_EXP 64
29130: PPUSH
29131: LD_STRING D16b-Pla-1
29133: PPUSH
29134: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29138: LD_EXP 39
29142: PPUSH
29143: LD_STRING D16b-JMM-
29145: PPUSH
29146: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29150: LD_VAR 0 1
29154: PPUSH
29155: LD_INT 60
29157: PPUSH
29158: LD_INT 95
29160: PPUSH
29161: CALL_OW 116
// end else
29165: GO 29187
// begin DialogueOn ;
29167: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D16c-Pla-
29178: PPUSH
29179: CALL_OW 94
// DialogueOff ;
29183: CALL_OW 7
// end ; end ; end ;
29187: PPOPN 3
29189: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29190: LD_EXP 14
29194: PUSH
29195: LD_INT 126000
29197: GREATEREQUAL
29198: PUSH
29199: LD_EXP 23
29203: NOT
29204: AND
29205: PUSH
29206: LD_EXP 74
29210: PPUSH
29211: CALL_OW 302
29215: AND
29216: IFFALSE 29574
29218: GO 29220
29220: DISABLE
29221: LD_INT 0
29223: PPUSH
// begin missionStage = 11 ;
29224: LD_ADDR_EXP 15
29228: PUSH
29229: LD_INT 11
29231: ST_TO_ADDR
// DialogueOn ;
29232: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9-Roth-1
29243: PPUSH
29244: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29248: LD_EXP 39
29252: PPUSH
29253: LD_STRING D9-JMM-1
29255: PPUSH
29256: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29260: LD_EXP 74
29264: PPUSH
29265: LD_STRING D9-Roth-2
29267: PPUSH
29268: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29272: LD_EXP 74
29276: PPUSH
29277: LD_STRING D9-Roth-2a
29279: PPUSH
29280: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29284: LD_EXP 64
29288: PPUSH
29289: LD_STRING D9-Pla-2
29291: PPUSH
29292: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29296: LD_EXP 74
29300: PPUSH
29301: LD_STRING D9-Roth-3
29303: PPUSH
29304: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29308: LD_EXP 64
29312: PPUSH
29313: LD_STRING D9-Pla-3
29315: PPUSH
29316: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29320: LD_EXP 74
29324: PPUSH
29325: LD_STRING D9-Roth-4
29327: PPUSH
29328: CALL_OW 94
// dec = Query ( Q9 ) ;
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_STRING Q9
29339: PPUSH
29340: CALL_OW 97
29344: ST_TO_ADDR
// if dec = 1 then
29345: LD_VAR 0 1
29349: PUSH
29350: LD_INT 1
29352: EQUAL
29353: IFFALSE 29367
// SayRadio ( Roth , D9a-Roth-1 ) ;
29355: LD_EXP 74
29359: PPUSH
29360: LD_STRING D9a-Roth-1
29362: PPUSH
29363: CALL_OW 94
// if dec = 2 then
29367: LD_VAR 0 1
29371: PUSH
29372: LD_INT 2
29374: EQUAL
29375: IFFALSE 29401
// begin Say ( JMM , D9b-JMM-1 ) ;
29377: LD_EXP 39
29381: PPUSH
29382: LD_STRING D9b-JMM-1
29384: PPUSH
29385: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9b-Roth-1
29396: PPUSH
29397: CALL_OW 94
// end ; if dec = 3 then
29401: LD_VAR 0 1
29405: PUSH
29406: LD_INT 3
29408: EQUAL
29409: IFFALSE 29471
// begin Say ( JMM , D9c-JMM-1 ) ;
29411: LD_EXP 39
29415: PPUSH
29416: LD_STRING D9c-JMM-1
29418: PPUSH
29419: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29423: LD_EXP 74
29427: PPUSH
29428: LD_STRING D9c-Roth-1
29430: PPUSH
29431: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29435: LD_EXP 39
29439: PPUSH
29440: LD_STRING D9c-JMM-2
29442: PPUSH
29443: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29447: LD_EXP 74
29451: PPUSH
29452: LD_STRING D9c-Roth-2
29454: PPUSH
29455: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29459: LD_EXP 39
29463: PPUSH
29464: LD_STRING D9c-JMM-3
29466: PPUSH
29467: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29471: LD_EXP 74
29475: PPUSH
29476: LD_STRING D9c-Roth-3
29478: PPUSH
29479: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29483: LD_EXP 74
29487: PPUSH
29488: LD_STRING D9cont-Roth-1
29490: PPUSH
29491: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29495: LD_EXP 39
29499: PPUSH
29500: LD_STRING D9cont-JMM-1
29502: PPUSH
29503: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29507: LD_EXP 74
29511: PPUSH
29512: LD_STRING D9cont-Roth-2
29514: PPUSH
29515: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29519: LD_EXP 39
29523: PPUSH
29524: LD_STRING D9cont-JMM-2
29526: PPUSH
29527: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29531: LD_EXP 74
29535: PPUSH
29536: LD_STRING D9cont-Roth-3
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29543: LD_EXP 39
29547: PPUSH
29548: LD_STRING D9cont-JMM-3
29550: PPUSH
29551: CALL_OW 88
// DialogueOff ;
29555: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29559: LD_STRING M3
29561: PPUSH
29562: CALL_OW 337
// allianceActive := true ;
29566: LD_ADDR_EXP 31
29570: PUSH
29571: LD_INT 1
29573: ST_TO_ADDR
// end ;
29574: PPOPN 1
29576: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29577: LD_INT 1
29579: PPUSH
29580: LD_INT 126
29582: PPUSH
29583: CALL_OW 292
29587: PUSH
29588: LD_EXP 64
29592: PPUSH
29593: CALL_OW 310
29597: AND
29598: IFFALSE 29678
29600: GO 29602
29602: DISABLE
29603: LD_INT 0
29605: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29606: LD_EXP 64
29610: PPUSH
29611: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 4
29622: PPUSH
29623: LD_INT 22
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 70
29637: PPUSH
29638: LD_EXP 64
29642: PPUSH
29643: CALL_OW 74
29647: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29648: LD_EXP 64
29652: PPUSH
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 1
29660: ARRAY
29661: PPUSH
29662: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29666: LD_EXP 64
29670: PPUSH
29671: LD_STRING D18-Pla-1
29673: PPUSH
29674: CALL_OW 88
// end ;
29678: PPOPN 1
29680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29681: LD_EXP 64
29685: PPUSH
29686: CALL_OW 301
29690: PUSH
29691: LD_EXP 67
29695: PPUSH
29696: CALL_OW 301
29700: AND
29701: PUSH
29702: LD_INT 22
29704: PUSH
29705: LD_INT 3
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 21
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 50
29724: PUSH
29725: EMPTY
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PUSH
29738: LD_INT 7
29740: PUSH
29741: LD_INT 8
29743: PUSH
29744: LD_INT 9
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_OWVAR 67
29756: ARRAY
29757: LESS
29758: AND
29759: IFFALSE 30530
29761: GO 29763
29763: DISABLE
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
// begin MC_Kill ( 1 ) ;
29770: LD_INT 1
29772: PPUSH
29773: CALL 35288 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29777: LD_INT 1
29779: PPUSH
29780: LD_INT 3
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: LD_INT 1
29788: PPUSH
29789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29793: LD_ADDR_VAR 0 1
29797: PUSH
29798: LD_INT 22
29800: PUSH
29801: LD_INT 3
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 21
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 24
29820: PUSH
29821: LD_INT 900
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 69
29837: PUSH
29838: FOR_IN
29839: IFFALSE 29870
// if GetSex ( i ) = sex_male then
29841: LD_VAR 0 1
29845: PPUSH
29846: CALL_OW 258
29850: PUSH
29851: LD_INT 1
29853: EQUAL
29854: IFFALSE 29868
// begin tmp = i ;
29856: LD_ADDR_VAR 0 2
29860: PUSH
29861: LD_VAR 0 1
29865: ST_TO_ADDR
// break ;
29866: GO 29870
// end ;
29868: GO 29838
29870: POP
29871: POP
// if tmp = 0 then
29872: LD_VAR 0 2
29876: PUSH
29877: LD_INT 0
29879: EQUAL
29880: IFFALSE 29934
// begin uc_side = 3 ;
29882: LD_ADDR_OWVAR 20
29886: PUSH
29887: LD_INT 3
29889: ST_TO_ADDR
// uc_nation = 3 ;
29890: LD_ADDR_OWVAR 21
29894: PUSH
29895: LD_INT 3
29897: ST_TO_ADDR
// hc_name =  ;
29898: LD_ADDR_OWVAR 26
29902: PUSH
29903: LD_STRING 
29905: ST_TO_ADDR
// hc_gallery =  ;
29906: LD_ADDR_OWVAR 33
29910: PUSH
29911: LD_STRING 
29913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 10
29919: PPUSH
29920: CALL_OW 381
// tmp = CreateHuman ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: CALL_OW 44
29933: ST_TO_ADDR
// end ; DialogueOn ;
29934: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_STRING DSurrenderRussians-RSol1-1a
29945: PPUSH
29946: CALL_OW 94
// DialogueOff ;
29950: CALL_OW 7
// russianDestroyed := true ;
29954: LD_ADDR_EXP 21
29958: PUSH
29959: LD_INT 1
29961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29962: LD_INT 22
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 21
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PPUSH
29986: CALL_OW 69
29990: PPUSH
29991: CALL_OW 122
// wait ( 0 0$1 ) ;
29995: LD_INT 35
29997: PPUSH
29998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30002: LD_INT 22
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 21
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 69
30030: PPUSH
30031: LD_INT 25
30033: PPUSH
30034: CALL_OW 173
// wait ( 0 0$10 ) ;
30038: LD_INT 350
30040: PPUSH
30041: CALL_OW 67
// PrepareOmarInvasion ;
30045: CALL 13878 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30049: LD_ADDR_VAR 0 2
30053: PUSH
30054: LD_EXP 92
30058: PPUSH
30059: CALL_OW 250
30063: PUSH
30064: LD_EXP 92
30068: PPUSH
30069: CALL_OW 251
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30078: LD_VAR 0 2
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: LD_VAR 0 2
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: PPUSH
30096: LD_INT 1
30098: PPUSH
30099: LD_INT 8
30101: NEG
30102: PPUSH
30103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30107: LD_EXP 92
30111: PPUSH
30112: CALL_OW 87
// DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30120: LD_EXP 39
30124: PPUSH
30125: LD_STRING D19-JMM-1
30127: PPUSH
30128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30132: LD_ADDR_VAR 0 3
30136: PUSH
30137: LD_INT 22
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 26
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 2
30159: PUSH
30160: LD_INT 25
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 25
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 25
30182: PUSH
30183: LD_INT 3
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 25
30192: PUSH
30193: LD_INT 4
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 25
30202: PUSH
30203: LD_INT 5
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 25
30212: PUSH
30213: LD_INT 8
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 69
30238: PUSH
30239: LD_EXP 39
30243: PUSH
30244: LD_EXP 40
30248: PUSH
30249: LD_EXP 41
30253: PUSH
30254: LD_EXP 42
30258: PUSH
30259: LD_EXP 43
30263: PUSH
30264: LD_EXP 44
30268: PUSH
30269: LD_EXP 45
30273: PUSH
30274: LD_EXP 46
30278: PUSH
30279: LD_EXP 47
30283: PUSH
30284: LD_EXP 48
30288: PUSH
30289: LD_EXP 49
30293: PUSH
30294: LD_EXP 50
30298: PUSH
30299: LD_EXP 51
30303: PUSH
30304: LD_EXP 52
30308: PUSH
30309: LD_EXP 53
30313: PUSH
30314: LD_EXP 54
30318: PUSH
30319: LD_EXP 55
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: DIFF
30343: ST_TO_ADDR
// if tmp2 then
30344: LD_VAR 0 3
30348: IFFALSE 30366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30350: LD_VAR 0 3
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: LD_STRING D19-Sol1-1
30361: PPUSH
30362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30366: LD_EXP 39
30370: PPUSH
30371: LD_STRING D19-JMM-2
30373: PPUSH
30374: CALL_OW 88
// DialogueOff ;
30378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30382: LD_VAR 0 2
30386: PUSH
30387: LD_INT 1
30389: ARRAY
30390: PPUSH
30391: LD_VAR 0 2
30395: PUSH
30396: LD_INT 2
30398: ARRAY
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30407: LD_STRING M5
30409: PPUSH
30410: CALL_OW 337
// omarOnMotherLode := false ;
30414: LD_ADDR_VAR 0 4
30418: PUSH
30419: LD_INT 0
30421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30422: LD_INT 35
30424: PPUSH
30425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30429: LD_EXP 92
30433: PPUSH
30434: LD_INT 215
30436: PPUSH
30437: LD_INT 100
30439: PPUSH
30440: CALL_OW 297
30444: PUSH
30445: LD_INT 10
30447: LESS
30448: PUSH
30449: LD_VAR 0 4
30453: NOT
30454: AND
30455: IFFALSE 30489
// begin omarOnMotherLode := true ;
30457: LD_ADDR_VAR 0 4
30461: PUSH
30462: LD_INT 1
30464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30465: LD_EXP 39
30469: PPUSH
30470: LD_STRING D19b-JMM-1
30472: PPUSH
30473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30477: LD_EXP 92
30481: PPUSH
30482: LD_STRING DOmarContam-Omar-1
30484: PPUSH
30485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30489: LD_EXP 92
30493: PPUSH
30494: CALL_OW 301
30498: IFFALSE 30422
// Say ( JMM , D19a-JMM-1 ) ;
30500: LD_EXP 39
30504: PPUSH
30505: LD_STRING D19a-JMM-1
30507: PPUSH
30508: CALL_OW 88
// if Heike then
30512: LD_EXP 93
30516: IFFALSE 30530
// Say ( Heike , D19a-Hke-1 ) ;
30518: LD_EXP 93
30522: PPUSH
30523: LD_STRING D19a-Hke-1
30525: PPUSH
30526: CALL_OW 88
// end ;
30530: PPOPN 4
30532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30533: LD_INT 22
30535: PUSH
30536: LD_INT 3
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 21
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 69
30561: PUSH
30562: LD_EXP 21
30566: AND
30567: IFFALSE 30635
30569: GO 30571
30571: DISABLE
30572: LD_INT 0
30574: PPUSH
30575: PPUSH
// begin enable ;
30576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_INT 25
30584: PPUSH
30585: LD_INT 22
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 70
30599: ST_TO_ADDR
// if not tmp then
30600: LD_VAR 0 2
30604: NOT
30605: IFFALSE 30609
// exit ;
30607: GO 30635
// for i in tmp do
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_VAR 0 2
30618: PUSH
30619: FOR_IN
30620: IFFALSE 30633
// RemoveUnit ( i ) ;
30622: LD_VAR 0 1
30626: PPUSH
30627: CALL_OW 64
30631: GO 30619
30633: POP
30634: POP
// end ;
30635: PPOPN 2
30637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30638: LD_INT 22
30640: PUSH
30641: LD_INT 7
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 21
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 69
30666: PUSH
30667: LD_INT 6
30669: LESS
30670: IFFALSE 31138
30672: GO 30674
30674: DISABLE
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
// begin MC_Kill ( 1 ) ;
30679: LD_INT 1
30681: PPUSH
30682: CALL 35288 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30686: LD_INT 7
30688: PPUSH
30689: LD_INT 1
30691: PPUSH
30692: LD_INT 1
30694: PPUSH
30695: LD_INT 1
30697: PPUSH
30698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30702: LD_ADDR_VAR 0 1
30706: PUSH
30707: LD_INT 22
30709: PUSH
30710: LD_INT 7
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 26
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 69
30735: PUSH
30736: LD_EXP 74
30740: DIFF
30741: ST_TO_ADDR
// if tmp then
30742: LD_VAR 0 1
30746: IFFALSE 30764
// tmp := tmp [ 1 ] else
30748: LD_ADDR_VAR 0 1
30752: PUSH
30753: LD_VAR 0 1
30757: PUSH
30758: LD_INT 1
30760: ARRAY
30761: ST_TO_ADDR
30762: GO 30800
// begin uc_side := 7 ;
30764: LD_ADDR_OWVAR 20
30768: PUSH
30769: LD_INT 7
30771: ST_TO_ADDR
// uc_nation := 1 ;
30772: LD_ADDR_OWVAR 21
30776: PUSH
30777: LD_INT 1
30779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30780: LD_INT 1
30782: PPUSH
30783: LD_INT 8
30785: PPUSH
30786: CALL_OW 384
// tmp := CreateHuman ;
30790: LD_ADDR_VAR 0 1
30794: PUSH
30795: CALL_OW 44
30799: ST_TO_ADDR
// end ; DialogueOn ;
30800: CALL_OW 6
// if IsOK ( Roth ) then
30804: LD_EXP 74
30808: PPUSH
30809: CALL_OW 302
30813: IFFALSE 30827
// Say ( JMM , DAb-JMM-1 ) ;
30815: LD_EXP 39
30819: PPUSH
30820: LD_STRING DAb-JMM-1
30822: PPUSH
30823: CALL_OW 88
// if IsOK ( Roth ) then
30827: LD_EXP 74
30831: PPUSH
30832: CALL_OW 302
30836: IFFALSE 30860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30838: LD_EXP 74
30842: PPUSH
30843: LD_STRING DSurrenderAlliance-Roth-1
30845: PPUSH
30846: CALL_OW 88
// RothCaptured := true ;
30850: LD_ADDR_EXP 33
30854: PUSH
30855: LD_INT 1
30857: ST_TO_ADDR
// end else
30858: GO 30872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30860: LD_VAR 0 1
30864: PPUSH
30865: LD_STRING DSurrenderAlliance-Sci1-1
30867: PPUSH
30868: CALL_OW 88
// DialogueOff ;
30872: CALL_OW 7
// allianceDestroyed := true ;
30876: LD_ADDR_EXP 23
30880: PUSH
30881: LD_INT 1
30883: ST_TO_ADDR
// if capturedUnit = 0 then
30884: LD_EXP 34
30888: PUSH
30889: LD_INT 0
30891: EQUAL
30892: IFFALSE 30901
// SetAchievement ( ACH_ALLIANCE ) ;
30894: LD_STRING ACH_ALLIANCE
30896: PPUSH
30897: CALL_OW 543
// if trueAmericans then
30901: LD_EXP 35
30905: IFFALSE 30981
// begin if trueAmericans = 1 then
30907: LD_EXP 35
30911: PUSH
30912: LD_INT 1
30914: EQUAL
30915: IFFALSE 30931
// Say ( JMM , DAb-JMM-1a ) else
30917: LD_EXP 39
30921: PPUSH
30922: LD_STRING DAb-JMM-1a
30924: PPUSH
30925: CALL_OW 88
30929: GO 30943
// Say ( JMM , DAb-JMM-1b ) ;
30931: LD_EXP 39
30935: PPUSH
30936: LD_STRING DAb-JMM-1b
30938: PPUSH
30939: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30943: LD_EXP 35
30947: PPUSH
30948: CALL_OW 87
// for i in trueAmericans do
30952: LD_ADDR_VAR 0 2
30956: PUSH
30957: LD_EXP 35
30961: PUSH
30962: FOR_IN
30963: IFFALSE 30979
// SetSide ( i , 1 ) ;
30965: LD_VAR 0 2
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 235
30977: GO 30962
30979: POP
30980: POP
// end ; repeat wait ( 0 0$1 ) ;
30981: LD_INT 35
30983: PPUSH
30984: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30988: LD_ADDR_VAR 0 2
30992: PUSH
30993: LD_INT 22
30995: PUSH
30996: LD_INT 7
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 21
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: CALL_OW 69
31021: PUSH
31022: FOR_IN
31023: IFFALSE 31105
// begin if IsInUnit ( i ) then
31025: LD_VAR 0 2
31029: PPUSH
31030: CALL_OW 310
31034: IFFALSE 31045
// ComExitBuilding ( i ) ;
31036: LD_VAR 0 2
31040: PPUSH
31041: CALL_OW 122
// if IsDriver ( i ) then
31045: LD_VAR 0 2
31049: PPUSH
31050: CALL 98671 0 1
31054: IFFALSE 31065
// ComExitVehicle ( i ) ;
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31065: LD_VAR 0 2
31069: PPUSH
31070: LD_INT 26
31072: PPUSH
31073: CALL_OW 308
31077: NOT
31078: IFFALSE 31094
// AddComMoveToArea ( i , allianceEscapeArea ) else
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_INT 26
31087: PPUSH
31088: CALL_OW 173
31092: GO 31103
// RemoveUnit ( i ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: CALL_OW 64
// end ;
31103: GO 31022
31105: POP
31106: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31107: LD_INT 22
31109: PUSH
31110: LD_INT 7
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 21
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: NOT
31136: IFFALSE 30981
// end ;
31138: PPOPN 2
31140: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31141: LD_INT 0
31143: PPUSH
31144: PPUSH
// if not unit then
31145: LD_VAR 0 1
31149: NOT
31150: IFFALSE 31154
// exit ;
31152: GO 32652
// DoNotAttack ( 7 , unit ) ;
31154: LD_INT 7
31156: PPUSH
31157: LD_VAR 0 1
31161: PPUSH
31162: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_INT 260
31173: PPUSH
31174: LD_INT 235
31176: PPUSH
31177: LD_INT 3
31179: PPUSH
31180: LD_INT 1
31182: PPUSH
31183: CALL_OW 483
// SetSide ( unit , 4 ) ;
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_INT 4
31194: PPUSH
31195: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31199: LD_ADDR_EXP 34
31203: PUSH
31204: LD_EXP 34
31208: PUSH
31209: LD_INT 1
31211: PLUS
31212: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31213: LD_INT 70
31215: PPUSH
31216: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31220: LD_INT 260
31222: PPUSH
31223: LD_INT 235
31225: PPUSH
31226: LD_INT 1
31228: PPUSH
31229: LD_INT 8
31231: NEG
31232: PPUSH
31233: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31237: LD_VAR 0 1
31241: PPUSH
31242: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31246: LD_VAR 0 1
31250: PPUSH
31251: LD_EXP 74
31255: PPUSH
31256: CALL_OW 119
// DialogueOn ;
31260: CALL_OW 6
// case unit of JMM :
31264: LD_VAR 0 1
31268: PUSH
31269: LD_EXP 39
31273: DOUBLE
31274: EQUAL
31275: IFTRUE 31279
31277: GO 31294
31279: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31280: LD_EXP 39
31284: PPUSH
31285: LD_STRING DA1-JMM-1
31287: PPUSH
31288: CALL_OW 91
31292: GO 31736
31294: LD_EXP 40
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31305: LD_EXP 40
31309: PPUSH
31310: LD_STRING DA1-Joan-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31736
31319: LD_EXP 42
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31330: LD_EXP 42
31334: PPUSH
31335: LD_STRING DA1-Lisa-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31736
31344: LD_EXP 43
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31355: LD_EXP 43
31359: PPUSH
31360: LD_STRING DA1-Don-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31736
31369: LD_EXP 50
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31380: LD_EXP 50
31384: PPUSH
31385: LD_STRING DA1-Corn-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31736
31394: LD_EXP 46
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31405: LD_EXP 46
31409: PPUSH
31410: LD_STRING DA1-Den-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31736
31419: LD_EXP 44
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31430: LD_EXP 44
31434: PPUSH
31435: LD_STRING DA1-Bobby-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31736
31444: LD_EXP 48
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31455: LD_EXP 48
31459: PPUSH
31460: LD_STRING DA1-Glad-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31736
31469: LD_EXP 45
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31480: LD_EXP 45
31484: PPUSH
31485: LD_STRING DA1-Cyrus-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31736
31494: LD_EXP 41
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31505: LD_EXP 41
31509: PPUSH
31510: LD_STRING DA1-Huck-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31736
31519: LD_EXP 55
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31530: LD_EXP 55
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31736
31544: LD_EXP 47
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31555: LD_EXP 47
31559: PPUSH
31560: LD_STRING DA1-Brown-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31736
31569: LD_EXP 51
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31580: LD_EXP 51
31584: PPUSH
31585: LD_STRING DA1-Gary-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31736
31594: LD_EXP 54
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31605: LD_EXP 54
31609: PPUSH
31610: LD_STRING DA1-Con-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31736
31619: LD_EXP 60
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31630: LD_EXP 60
31634: PPUSH
31635: LD_STRING DA1-Kurt-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31736
31644: LD_EXP 53
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31655: LD_EXP 53
31659: PPUSH
31660: LD_STRING DA1-Yam-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31736
31669: LD_EXP 52
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31680: LD_EXP 52
31684: PPUSH
31685: LD_STRING DA1-Frank-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31736
31694: POP
// begin if GetSex ( unit ) = sex_male then
31695: LD_VAR 0 1
31699: PPUSH
31700: CALL_OW 258
31704: PUSH
31705: LD_INT 1
31707: EQUAL
31708: IFFALSE 31724
// ForceSay ( unit , DA1-Sol1-1 ) else
31710: LD_VAR 0 1
31714: PPUSH
31715: LD_STRING DA1-Sol1-1
31717: PPUSH
31718: CALL_OW 91
31722: GO 31736
// ForceSay ( unit , DA1-FSol1-1 ) ;
31724: LD_VAR 0 1
31728: PPUSH
31729: LD_STRING DA1-FSol1-1
31731: PPUSH
31732: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31736: LD_EXP 74
31740: PPUSH
31741: LD_STRING DA-Roth-1
31743: PPUSH
31744: CALL_OW 88
// if capturedUnit = 1 then
31748: LD_EXP 34
31752: PUSH
31753: LD_INT 1
31755: EQUAL
31756: IFFALSE 31784
// begin Say ( Simms , DA-Sim-1 ) ;
31758: LD_EXP 75
31762: PPUSH
31763: LD_STRING DA-Sim-1
31765: PPUSH
31766: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31770: LD_EXP 74
31774: PPUSH
31775: LD_STRING DA-Roth-2
31777: PPUSH
31778: CALL_OW 88
// end else
31782: GO 31796
// Say ( Simms , DA-Sim-2 ) ;
31784: LD_EXP 75
31788: PPUSH
31789: LD_STRING DA-Sim-2
31791: PPUSH
31792: CALL_OW 88
// case unit of JMM :
31796: LD_VAR 0 1
31800: PUSH
31801: LD_EXP 39
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31812: LD_EXP 39
31816: PPUSH
31817: LD_STRING DA1-JMM-1a
31819: PPUSH
31820: CALL_OW 91
31824: GO 32333
31826: LD_EXP 40
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31837: LD_EXP 40
31841: PPUSH
31842: LD_STRING DA1-Joan-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32333
31851: LD_EXP 42
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31862: LD_EXP 42
31866: PPUSH
31867: LD_STRING DA1-Lisa-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32333
31876: LD_EXP 43
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31887: LD_EXP 43
31891: PPUSH
31892: LD_STRING DA1-Don-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32333
31901: LD_EXP 50
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31912: LD_EXP 50
31916: PPUSH
31917: LD_STRING DA1-Corn-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32333
31926: LD_EXP 46
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31937: LD_EXP 46
31941: PPUSH
31942: LD_STRING DA1-Den-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32333
31951: LD_EXP 44
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31962: LD_EXP 44
31966: PPUSH
31967: LD_STRING DA1-Bobby-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32333
31976: LD_EXP 48
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31987: LD_EXP 48
31991: PPUSH
31992: LD_STRING DA1-Glad-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32333
32001: LD_EXP 45
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32012: LD_EXP 45
32016: PPUSH
32017: LD_STRING DA1-Cyrus-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32333
32026: LD_EXP 41
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32037: LD_EXP 41
32041: PPUSH
32042: LD_STRING DA1-Huck-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32333
32051: LD_EXP 55
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32062: LD_EXP 55
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32333
32076: LD_EXP 47
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32087: LD_EXP 47
32091: PPUSH
32092: LD_STRING DA1-Brown-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32333
32101: LD_EXP 51
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32112: LD_EXP 51
32116: PPUSH
32117: LD_STRING DA1-Gary-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32333
32126: LD_EXP 54
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32137: LD_EXP 54
32141: PPUSH
32142: LD_STRING DA1-Con-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32333
32151: LD_EXP 60
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32162: LD_EXP 60
32166: PPUSH
32167: LD_STRING DA1-Kurt-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32333
32176: LD_EXP 53
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32187: LD_EXP 53
32191: PPUSH
32192: LD_STRING DA1-Yam-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32333
32201: LD_EXP 52
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32212: LD_EXP 52
32216: PPUSH
32217: LD_STRING DA1-Frank-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32333
32226: POP
// begin join := rand ( 0 , 1 ) ;
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: LD_INT 0
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: CALL_OW 12
32242: ST_TO_ADDR
// if join then
32243: LD_VAR 0 3
32247: IFFALSE 32292
// begin if GetSex ( unit ) = sex_male then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 258
32258: PUSH
32259: LD_INT 1
32261: EQUAL
32262: IFFALSE 32278
// ForceSay ( unit , DA1-Sol1-1b ) else
32264: LD_VAR 0 1
32268: PPUSH
32269: LD_STRING DA1-Sol1-1b
32271: PPUSH
32272: CALL_OW 91
32276: GO 32290
// ForceSay ( unit , DA1-FSol1-1b ) ;
32278: LD_VAR 0 1
32282: PPUSH
32283: LD_STRING DA1-FSol1-1b
32285: PPUSH
32286: CALL_OW 91
// end else
32290: GO 32333
// begin if GetSex ( unit ) = sex_male then
32292: LD_VAR 0 1
32296: PPUSH
32297: CALL_OW 258
32301: PUSH
32302: LD_INT 1
32304: EQUAL
32305: IFFALSE 32321
// ForceSay ( unit , DA1-Sol1-1a ) else
32307: LD_VAR 0 1
32311: PPUSH
32312: LD_STRING DA1-Sol1-1a
32314: PPUSH
32315: CALL_OW 91
32319: GO 32333
// ForceSay ( unit , DA1-FSol1-1a ) ;
32321: LD_VAR 0 1
32325: PPUSH
32326: LD_STRING DA1-FSol1-1a
32328: PPUSH
32329: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32333: LD_VAR 0 1
32337: PUSH
32338: LD_EXP 39
32342: EQUAL
32343: IFFALSE 32354
// begin YouLost ( JMMCaptured ) ;
32345: LD_STRING JMMCaptured
32347: PPUSH
32348: CALL_OW 104
// exit ;
32352: GO 32652
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32354: LD_VAR 0 1
32358: PUSH
32359: LD_EXP 43
32363: PUSH
32364: LD_EXP 46
32368: PUSH
32369: LD_EXP 44
32373: PUSH
32374: LD_EXP 41
32378: PUSH
32379: LD_EXP 55
32383: PUSH
32384: LD_EXP 47
32388: PUSH
32389: LD_EXP 53
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: IN
32403: PUSH
32404: LD_VAR 0 3
32408: OR
32409: IFFALSE 32508
// begin Say ( Roth , DA-Roth-3 ) ;
32411: LD_EXP 74
32415: PPUSH
32416: LD_STRING DA-Roth-3
32418: PPUSH
32419: CALL_OW 88
// SetSide ( unit , 7 ) ;
32423: LD_VAR 0 1
32427: PPUSH
32428: LD_INT 7
32430: PPUSH
32431: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32435: LD_ADDR_EXP 110
32439: PUSH
32440: LD_EXP 110
32444: PPUSH
32445: LD_INT 1
32447: PPUSH
32448: LD_EXP 110
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: PUSH
32457: LD_VAR 0 1
32461: ADD
32462: PPUSH
32463: CALL_OW 1
32467: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32468: LD_INT 260
32470: PPUSH
32471: LD_INT 235
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32481: LD_VAR 0 1
32485: PPUSH
32486: LD_INT 1000
32488: PPUSH
32489: CALL_OW 234
// DialogueOff ;
32493: CALL_OW 7
// ComFree ( unit ) ;
32497: LD_VAR 0 1
32501: PPUSH
32502: CALL_OW 139
// end else
32506: GO 32589
// begin Say ( Roth , DA-Roth-3a ) ;
32508: LD_EXP 74
32512: PPUSH
32513: LD_STRING DA-Roth-3a
32515: PPUSH
32516: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32520: LD_ADDR_EXP 35
32524: PUSH
32525: LD_EXP 35
32529: PUSH
32530: LD_VAR 0 1
32534: ADD
32535: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32536: LD_INT 260
32538: PPUSH
32539: LD_INT 235
32541: PPUSH
32542: LD_INT 1
32544: PPUSH
32545: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32549: LD_VAR 0 1
32553: PPUSH
32554: LD_INT 1000
32556: PPUSH
32557: CALL_OW 234
// DialogueOff ;
32561: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 272
32572: PPUSH
32573: LD_INT 254
32575: PPUSH
32576: CALL_OW 111
// AddComHold ( unit ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: CALL_OW 200
// end ; if capturedUnit = 1 then
32589: LD_EXP 34
32593: PUSH
32594: LD_INT 1
32596: EQUAL
32597: IFFALSE 32652
// begin DialogueOn ;
32599: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32603: LD_EXP 39
32607: PPUSH
32608: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32612: LD_EXP 39
32616: PPUSH
32617: LD_STRING DAa-JMM-1
32619: PPUSH
32620: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32624: LD_EXP 39
32628: PPUSH
32629: LD_STRING DAa-JMM-1a
32631: PPUSH
32632: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32636: LD_EXP 39
32640: PPUSH
32641: LD_STRING DAa-JMM-1b
32643: PPUSH
32644: CALL_OW 88
// DialogueOff ;
32648: CALL_OW 7
// end ; end ;
32652: LD_VAR 0 2
32656: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32657: LD_EXP 15
32661: PUSH
32662: LD_INT 13
32664: GREATEREQUAL
32665: PUSH
32666: LD_INT 22
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 21
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 69
32694: PUSH
32695: LD_INT 0
32697: EQUAL
32698: AND
32699: PUSH
32700: LD_INT 22
32702: PUSH
32703: LD_INT 2
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 21
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 50
32722: PUSH
32723: EMPTY
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: AND
32740: PUSH
32741: LD_EXP 21
32745: AND
32746: PUSH
32747: LD_EXP 22
32751: AND
32752: PUSH
32753: LD_EXP 23
32757: AND
32758: IFFALSE 33400
32760: GO 32762
32762: DISABLE
32763: LD_INT 0
32765: PPUSH
32766: PPUSH
32767: PPUSH
// begin m1 := false ;
32768: LD_ADDR_VAR 0 1
32772: PUSH
32773: LD_INT 0
32775: ST_TO_ADDR
// m2 := false ;
32776: LD_ADDR_VAR 0 2
32780: PUSH
32781: LD_INT 0
32783: ST_TO_ADDR
// m3 := false ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 0
32791: ST_TO_ADDR
// if not bombExploded then
32792: LD_EXP 37
32796: NOT
32797: IFFALSE 32806
// SetAchievement ( ACH_SIBROCKET ) ;
32799: LD_STRING ACH_SIBROCKET
32801: PPUSH
32802: CALL_OW 543
// if tick <= 120 120$00 then
32806: LD_OWVAR 1
32810: PUSH
32811: LD_INT 252000
32813: LESSEQUAL
32814: IFFALSE 32830
// begin wait ( 3 ) ;
32816: LD_INT 3
32818: PPUSH
32819: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32823: LD_STRING ACH_ASPEED_15
32825: PPUSH
32826: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32830: LD_EXP 39
32834: PPUSH
32835: CALL_OW 87
// music_class := 5 ;
32839: LD_ADDR_OWVAR 72
32843: PUSH
32844: LD_INT 5
32846: ST_TO_ADDR
// music_nat := 5 ;
32847: LD_ADDR_OWVAR 71
32851: PUSH
32852: LD_INT 5
32854: ST_TO_ADDR
// DialogueOn ;
32855: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32859: LD_EXP 39
32863: PPUSH
32864: LD_STRING D20-JMM-1
32866: PPUSH
32867: CALL_OW 88
// if IsOK ( Joan ) then
32871: LD_EXP 40
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Joan , D20-Joan-1 ) ;
32882: LD_EXP 40
32886: PPUSH
32887: LD_STRING D20-Joan-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Lisa ) then
32894: LD_EXP 42
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Lisa , D20-Lisa-1 ) ;
32905: LD_EXP 42
32909: PPUSH
32910: LD_STRING D20-Lisa-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Donaldson ) then
32917: LD_EXP 43
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Donaldson , D20-Don-1 ) ;
32928: LD_EXP 43
32932: PPUSH
32933: LD_STRING D20-Don-1
32935: PPUSH
32936: CALL_OW 88
// if IsOK ( Cornel ) then
32940: LD_EXP 50
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Cornel , D20-Corn-1 ) ;
32951: LD_EXP 50
32955: PPUSH
32956: LD_STRING D20-Corn-1
32958: PPUSH
32959: CALL_OW 88
// if IsOk ( Denis ) then
32963: LD_EXP 46
32967: PPUSH
32968: CALL_OW 302
32972: IFFALSE 32986
// Say ( Denis , D20-Den-1 ) ;
32974: LD_EXP 46
32978: PPUSH
32979: LD_STRING D20-Den-1
32981: PPUSH
32982: CALL_OW 88
// if IsOk ( Bobby ) then
32986: LD_EXP 44
32990: PPUSH
32991: CALL_OW 302
32995: IFFALSE 33009
// Say ( Bobby , D20-Bobby-1 ) ;
32997: LD_EXP 44
33001: PPUSH
33002: LD_STRING D20-Bobby-1
33004: PPUSH
33005: CALL_OW 88
// if IsOk ( Gladstone ) then
33009: LD_EXP 48
33013: PPUSH
33014: CALL_OW 302
33018: IFFALSE 33032
// Say ( Gladstone , D20-Glad-1 ) ;
33020: LD_EXP 48
33024: PPUSH
33025: LD_STRING D20-Glad-1
33027: PPUSH
33028: CALL_OW 88
// if IsOk ( Cyrus ) then
33032: LD_EXP 45
33036: PPUSH
33037: CALL_OW 302
33041: IFFALSE 33055
// Say ( Cyrus , D20-Cyrus-1 ) ;
33043: LD_EXP 45
33047: PPUSH
33048: LD_STRING D20-Cyrus-1
33050: PPUSH
33051: CALL_OW 88
// if IsOk ( Stevens ) then
33055: LD_EXP 41
33059: PPUSH
33060: CALL_OW 302
33064: IFFALSE 33078
// Say ( Stevens , D20-Huck-1 ) ;
33066: LD_EXP 41
33070: PPUSH
33071: LD_STRING D20-Huck-1
33073: PPUSH
33074: CALL_OW 88
// if IsOk ( Brown ) then
33078: LD_EXP 47
33082: PPUSH
33083: CALL_OW 302
33087: IFFALSE 33101
// Say ( Brown , D20-Brown-1 ) ;
33089: LD_EXP 47
33093: PPUSH
33094: LD_STRING D20-Brown-1
33096: PPUSH
33097: CALL_OW 88
// if IsOk ( Gary ) then
33101: LD_EXP 51
33105: PPUSH
33106: CALL_OW 302
33110: IFFALSE 33124
// Say ( Gary , D20-Gary-1 ) ;
33112: LD_EXP 51
33116: PPUSH
33117: LD_STRING D20-Gary-1
33119: PPUSH
33120: CALL_OW 88
// if IsOk ( Connie ) then
33124: LD_EXP 54
33128: PPUSH
33129: CALL_OW 302
33133: IFFALSE 33147
// Say ( Connie , D20-Con-1 ) ;
33135: LD_EXP 54
33139: PPUSH
33140: LD_STRING D20-Con-1
33142: PPUSH
33143: CALL_OW 88
// if IsOk ( Kurt ) then
33147: LD_EXP 60
33151: PPUSH
33152: CALL_OW 302
33156: IFFALSE 33170
// Say ( Kurt , D20-Kurt-1 ) ;
33158: LD_EXP 60
33162: PPUSH
33163: LD_STRING D20-Kurt-1
33165: PPUSH
33166: CALL_OW 88
// if IsOk ( Kikuchi ) then
33170: LD_EXP 53
33174: PPUSH
33175: CALL_OW 302
33179: IFFALSE 33193
// Say ( Kikuchi , D20-Yam-1 ) ;
33181: LD_EXP 53
33185: PPUSH
33186: LD_STRING D20-Yam-1
33188: PPUSH
33189: CALL_OW 88
// if IsOk ( Frank ) then
33193: LD_EXP 52
33197: PPUSH
33198: CALL_OW 302
33202: IFFALSE 33216
// Say ( Frank , D20-Frank-1 ) ;
33204: LD_EXP 52
33208: PPUSH
33209: LD_STRING D20-Frank-1
33211: PPUSH
33212: CALL_OW 88
// DialogueOff ;
33216: CALL_OW 7
// if RothCaptured then
33220: LD_EXP 33
33224: IFFALSE 33246
// begin m1 := true ;
33226: LD_ADDR_VAR 0 1
33230: PUSH
33231: LD_INT 1
33233: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33234: LD_STRING Roth
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 101
// end else
33244: GO 33257
// AddMedal ( Roth , - 1 ) ;
33246: LD_STRING Roth
33248: PPUSH
33249: LD_INT 1
33251: NEG
33252: PPUSH
33253: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33257: LD_EXP 27
33261: IFFALSE 33283
// begin m2 := true ;
33263: LD_ADDR_VAR 0 2
33267: PUSH
33268: LD_INT 1
33270: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33271: LD_STRING Project
33273: PPUSH
33274: LD_INT 1
33276: PPUSH
33277: CALL_OW 101
// end else
33281: GO 33294
// AddMedal ( Project , - 1 ) ;
33283: LD_STRING Project
33285: PPUSH
33286: LD_INT 1
33288: NEG
33289: PPUSH
33290: CALL_OW 101
// if lostCounter = 0 then
33294: LD_EXP 32
33298: PUSH
33299: LD_INT 0
33301: EQUAL
33302: IFFALSE 33324
// begin m3 := true ;
33304: LD_ADDR_VAR 0 3
33308: PUSH
33309: LD_INT 1
33311: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33312: LD_STRING NoLosses
33314: PPUSH
33315: LD_INT 1
33317: PPUSH
33318: CALL_OW 101
// end else
33322: GO 33335
// AddMedal ( NoLosses , - 1 ) ;
33324: LD_STRING NoLosses
33326: PPUSH
33327: LD_INT 1
33329: NEG
33330: PPUSH
33331: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33335: LD_VAR 0 1
33339: PUSH
33340: LD_VAR 0 2
33344: AND
33345: PUSH
33346: LD_VAR 0 3
33350: AND
33351: PUSH
33352: LD_OWVAR 67
33356: PUSH
33357: LD_INT 3
33359: EQUAL
33360: AND
33361: IFFALSE 33373
// SetAchievementEX ( ACH_AMER , 15 ) ;
33363: LD_STRING ACH_AMER
33365: PPUSH
33366: LD_INT 15
33368: PPUSH
33369: CALL_OW 564
// GiveMedals ( MAIN ) ;
33373: LD_STRING MAIN
33375: PPUSH
33376: CALL_OW 102
// music_class := 4 ;
33380: LD_ADDR_OWVAR 72
33384: PUSH
33385: LD_INT 4
33387: ST_TO_ADDR
// music_nat := 1 ;
33388: LD_ADDR_OWVAR 71
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// YouWin ;
33396: CALL_OW 103
// end ; end_of_file
33400: PPOPN 3
33402: END
// export function CustomEvent ( event ) ; begin
33403: LD_INT 0
33405: PPUSH
// end ;
33406: LD_VAR 0 2
33410: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 2
33424: PUSH
33425: LD_INT 4
33427: EQUAL
33428: AND
33429: PUSH
33430: LD_EXP 58
33434: PPUSH
33435: CALL_OW 300
33439: AND
33440: IFFALSE 33456
// begin wait ( 0 0$2 ) ;
33442: LD_INT 70
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Dismissed ) ;
33449: LD_STRING Dismissed
33451: PPUSH
33452: CALL_OW 104
// end ; end ;
33456: PPOPN 2
33458: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33459: LD_VAR 0 2
33463: PPUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_INT 18
33471: PPUSH
33472: CALL_OW 309
33476: IFFALSE 33485
// YouLost ( Motherlode3 ) ;
33478: LD_STRING Motherlode3
33480: PPUSH
33481: CALL_OW 104
// end ;
33485: PPOPN 3
33487: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33488: LD_EXP 27
33492: NOT
33493: IFFALSE 33503
// behemothDone := true ;
33495: LD_ADDR_EXP 28
33499: PUSH
33500: LD_INT 1
33502: ST_TO_ADDR
// end ;
33503: PPOPN 1
33505: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33506: LD_VAR 0 1
33510: PPUSH
33511: CALL_OW 255
33515: PUSH
33516: LD_INT 1
33518: EQUAL
33519: IFFALSE 33529
// bombExploded := true ;
33521: LD_ADDR_EXP 37
33525: PUSH
33526: LD_INT 1
33528: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33529: LD_VAR 0 1
33533: PPUSH
33534: CALL_OW 255
33538: PUSH
33539: LD_INT 1
33541: EQUAL
33542: PUSH
33543: LD_EXP 30
33547: AND
33548: PUSH
33549: LD_INT 22
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 34
33561: PUSH
33562: LD_INT 48
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PPUSH
33573: CALL_OW 69
33577: AND
33578: PUSH
33579: LD_INT 22
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 34
33591: PUSH
33592: LD_INT 8
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PPUSH
33603: CALL_OW 69
33607: NOT
33608: AND
33609: IFFALSE 33661
// begin wait ( 0 0$5 ) ;
33611: LD_INT 175
33613: PPUSH
33614: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33618: LD_INT 22
33620: PUSH
33621: LD_INT 3
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 34
33630: PUSH
33631: LD_INT 48
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PPUSH
33642: CALL_OW 69
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: LD_INT 60
33653: PPUSH
33654: LD_INT 95
33656: PPUSH
33657: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33661: LD_VAR 0 2
33665: PPUSH
33666: LD_VAR 0 3
33670: PPUSH
33671: LD_INT 18
33673: PPUSH
33674: CALL_OW 309
33678: IFFALSE 33738
// begin if GetSide ( unit ) = 1 then
33680: LD_VAR 0 1
33684: PPUSH
33685: CALL_OW 255
33689: PUSH
33690: LD_INT 1
33692: EQUAL
33693: IFFALSE 33709
// begin wait ( 0 0$6 ) ;
33695: LD_INT 210
33697: PPUSH
33698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33702: LD_STRING Motherlode2
33704: PPUSH
33705: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33709: LD_VAR 0 1
33713: PPUSH
33714: CALL_OW 255
33718: PUSH
33719: LD_INT 8
33721: EQUAL
33722: IFFALSE 33738
// begin wait ( 0 0$6 ) ;
33724: LD_INT 210
33726: PPUSH
33727: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33731: LD_STRING Motherlode1
33733: PPUSH
33734: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33738: LD_VAR 0 1
33742: PPUSH
33743: CALL_OW 255
33747: PUSH
33748: LD_INT 3
33750: EQUAL
33751: IFFALSE 33772
// begin wait ( 0 0$5 ) ;
33753: LD_INT 175
33755: PPUSH
33756: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33760: LD_EXP 64
33764: PPUSH
33765: LD_STRING D18-Pla-1
33767: PPUSH
33768: CALL_OW 94
// end ; end ;
33772: PPOPN 3
33774: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33775: LD_VAR 0 1
33779: PUSH
33780: LD_INT 22
33782: PUSH
33783: LD_INT 1
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 21
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 23
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: PPUSH
33815: CALL_OW 69
33819: IN
33820: IFFALSE 33836
// lostCounter := lostCounter + 1 ;
33822: LD_ADDR_EXP 32
33826: PUSH
33827: LD_EXP 32
33831: PUSH
33832: LD_INT 1
33834: PLUS
33835: ST_TO_ADDR
// if un in behemothBuilders then
33836: LD_VAR 0 1
33840: PUSH
33841: LD_EXP 73
33845: IN
33846: IFFALSE 33866
// begin behemothBuilders := behemothBuilders diff un ;
33848: LD_ADDR_EXP 73
33852: PUSH
33853: LD_EXP 73
33857: PUSH
33858: LD_VAR 0 1
33862: DIFF
33863: ST_TO_ADDR
// exit ;
33864: GO 33896
// end ; if un = JMM then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 39
33875: EQUAL
33876: IFFALSE 33887
// begin YouLost ( JMM ) ;
33878: LD_STRING JMM
33880: PPUSH
33881: CALL_OW 104
// exit ;
33885: GO 33896
// end ; MCE_UnitDestroyed ( un ) ;
33887: LD_VAR 0 1
33891: PPUSH
33892: CALL 62124 0 1
// end ;
33896: PPOPN 1
33898: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33899: LD_VAR 0 1
33903: PPUSH
33904: LD_VAR 0 2
33908: PPUSH
33909: CALL 64458 0 2
// end ;
33913: PPOPN 2
33915: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL 63526 0 1
// end ;
33925: PPOPN 1
33927: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33928: LD_VAR 0 1
33932: PUSH
33933: LD_INT 22
33935: PUSH
33936: LD_INT 8
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 30
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 23
33955: PUSH
33956: LD_INT 3
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: LIST
33967: PPUSH
33968: CALL_OW 69
33972: IN
33973: IFFALSE 34000
// begin ComUpgrade ( building ) ;
33975: LD_VAR 0 1
33979: PPUSH
33980: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33984: LD_EXP 61
33988: PPUSH
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL 72873 0 2
// exit ;
33998: GO 34009
// end ; MCE_BuildingComplete ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL 63767 0 1
// end ;
34009: PPOPN 1
34011: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34012: LD_VAR 0 1
34016: PPUSH
34017: LD_VAR 0 2
34021: PPUSH
34022: CALL 61820 0 2
// end ;
34026: PPOPN 2
34028: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_VAR 0 3
34043: PPUSH
34044: LD_VAR 0 4
34048: PPUSH
34049: LD_VAR 0 5
34053: PPUSH
34054: CALL 61440 0 5
// end ;
34058: PPOPN 5
34060: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: CALL 61036 0 2
// end ;
34075: PPOPN 2
34077: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34078: LD_VAR 0 1
34082: PPUSH
34083: LD_VAR 0 2
34087: PPUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: LD_VAR 0 4
34097: PPUSH
34098: CALL 60874 0 4
// end ;
34102: PPOPN 4
34104: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34105: LD_VAR 0 1
34109: PPUSH
34110: LD_VAR 0 2
34114: PPUSH
34115: LD_VAR 0 3
34119: PPUSH
34120: CALL 60649 0 3
// end ;
34124: PPOPN 3
34126: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34127: LD_VAR 0 1
34131: PPUSH
34132: LD_VAR 0 2
34136: PPUSH
34137: CALL 60534 0 2
// end ;
34141: PPOPN 2
34143: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: LD_VAR 0 2
34153: PPUSH
34154: CALL 64719 0 2
// end ;
34158: PPOPN 2
34160: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 255
34170: PUSH
34171: LD_INT 4
34173: EQUAL
34174: PUSH
34175: LD_VAR 0 1
34179: PUSH
34180: LD_EXP 18
34184: PUSH
34185: LD_INT 1
34187: ARRAY
34188: IN
34189: AND
34190: PUSH
34191: LD_EXP 19
34195: AND
34196: IFFALSE 34215
// begin ComMoveXY ( driver , 61 , 93 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 61
34205: PPUSH
34206: LD_INT 93
34208: PPUSH
34209: CALL_OW 111
// exit ;
34213: GO 34239
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34215: LD_VAR 0 1
34219: PPUSH
34220: LD_VAR 0 2
34224: PPUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: LD_VAR 0 4
34234: PPUSH
34235: CALL 64935 0 4
// end ;
34239: PPOPN 4
34241: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34242: LD_VAR 0 1
34246: PPUSH
34247: LD_VAR 0 2
34251: PPUSH
34252: CALL 60343 0 2
// end ;
34256: PPOPN 2
34258: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: CALL 112581 0 1
// end ; end_of_file
34268: PPOPN 1
34270: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34271: LD_EXP 15
34275: PUSH
34276: LD_INT 2
34278: EQUAL
34279: IFFALSE 34758
34281: GO 34283
34283: DISABLE
34284: LD_INT 0
34286: PPUSH
// begin time := 0 0$40 ;
34287: LD_ADDR_VAR 0 1
34291: PUSH
34292: LD_INT 1400
34294: ST_TO_ADDR
// repeat wait ( time ) ;
34295: LD_VAR 0 1
34299: PPUSH
34300: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34304: LD_INT 1
34306: PPUSH
34307: LD_INT 5
34309: PPUSH
34310: CALL_OW 12
34314: PPUSH
34315: LD_INT 106
34317: PPUSH
34318: LD_INT 150
34320: PPUSH
34321: LD_INT 19
34323: PPUSH
34324: LD_INT 1
34326: PPUSH
34327: CALL_OW 56
// time := time + 0 0$9 ;
34331: LD_ADDR_VAR 0 1
34335: PUSH
34336: LD_VAR 0 1
34340: PUSH
34341: LD_INT 315
34343: PLUS
34344: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34345: LD_INT 455
34347: PPUSH
34348: LD_INT 840
34350: PPUSH
34351: CALL_OW 12
34355: PPUSH
34356: CALL_OW 67
// if Prob ( 50 ) then
34360: LD_INT 50
34362: PPUSH
34363: CALL_OW 13
34367: IFFALSE 34396
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34369: LD_INT 1
34371: PPUSH
34372: LD_INT 5
34374: PPUSH
34375: CALL_OW 12
34379: PPUSH
34380: LD_INT 62
34382: PPUSH
34383: LD_INT 108
34385: PPUSH
34386: LD_INT 10
34388: PPUSH
34389: LD_INT 1
34391: PPUSH
34392: CALL_OW 56
// until missionStage > 4 ;
34396: LD_EXP 15
34400: PUSH
34401: LD_INT 4
34403: GREATER
34404: IFFALSE 34295
// repeat wait ( 0 0$1 ) ;
34406: LD_INT 35
34408: PPUSH
34409: CALL_OW 67
// until missionStage = 6 ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 6
34420: EQUAL
34421: IFFALSE 34406
// time := 0 0$50 ;
34423: LD_ADDR_VAR 0 1
34427: PUSH
34428: LD_INT 1750
34430: ST_TO_ADDR
// repeat wait ( time ) ;
34431: LD_VAR 0 1
34435: PPUSH
34436: CALL_OW 67
// if Prob ( 50 ) then
34440: LD_INT 50
34442: PPUSH
34443: CALL_OW 13
34447: IFFALSE 34476
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34449: LD_INT 1
34451: PPUSH
34452: LD_INT 5
34454: PPUSH
34455: CALL_OW 12
34459: PPUSH
34460: LD_INT 106
34462: PPUSH
34463: LD_INT 89
34465: PPUSH
34466: LD_INT 45
34468: PPUSH
34469: LD_INT 1
34471: PPUSH
34472: CALL_OW 56
// time := time + 0 0$2 ;
34476: LD_ADDR_VAR 0 1
34480: PUSH
34481: LD_VAR 0 1
34485: PUSH
34486: LD_INT 70
34488: PLUS
34489: ST_TO_ADDR
// if Prob ( 30 ) then
34490: LD_INT 30
34492: PPUSH
34493: CALL_OW 13
34497: IFFALSE 34543
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34499: LD_INT 385
34501: PPUSH
34502: LD_INT 945
34504: PPUSH
34505: CALL_OW 12
34509: PPUSH
34510: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34514: LD_INT 1
34516: PPUSH
34517: LD_INT 5
34519: PPUSH
34520: CALL_OW 12
34524: PPUSH
34525: LD_INT 21
34527: PPUSH
34528: LD_INT 26
34530: PPUSH
34531: LD_INT 12
34533: PPUSH
34534: LD_INT 1
34536: PPUSH
34537: CALL_OW 56
// end else
34541: GO 34579
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34543: LD_INT 700
34545: PPUSH
34546: LD_INT 1225
34548: PPUSH
34549: CALL_OW 12
34553: PPUSH
34554: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34558: LD_INT 1
34560: PPUSH
34561: LD_INT 5
34563: PPUSH
34564: CALL_OW 12
34568: PPUSH
34569: LD_INT 16
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: CALL_OW 55
// end ; if Prob ( 50 ) then
34579: LD_INT 50
34581: PPUSH
34582: CALL_OW 13
34586: IFFALSE 34632
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34588: LD_INT 700
34590: PPUSH
34591: LD_INT 1050
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34603: LD_INT 1
34605: PPUSH
34606: LD_INT 5
34608: PPUSH
34609: CALL_OW 12
34613: PPUSH
34614: LD_INT 181
34616: PPUSH
34617: LD_INT 218
34619: PPUSH
34620: LD_INT 16
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 56
// end else
34630: GO 34668
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34632: LD_INT 350
34634: PPUSH
34635: LD_INT 525
34637: PPUSH
34638: CALL_OW 12
34642: PPUSH
34643: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34647: LD_INT 1
34649: PPUSH
34650: LD_INT 5
34652: PPUSH
34653: CALL_OW 12
34657: PPUSH
34658: LD_INT 15
34660: PPUSH
34661: LD_INT 1
34663: PPUSH
34664: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34668: LD_INT 45
34670: PUSH
34671: LD_INT 32
34673: PUSH
34674: LD_INT 25
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: PUSH
34682: LD_OWVAR 67
34686: ARRAY
34687: PPUSH
34688: CALL_OW 13
34692: IFFALSE 34736
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34694: LD_INT 175
34696: PPUSH
34697: LD_INT 315
34699: PPUSH
34700: CALL_OW 12
34704: PPUSH
34705: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34709: LD_INT 1
34711: PPUSH
34712: LD_INT 5
34714: PPUSH
34715: CALL_OW 12
34719: PPUSH
34720: LD_INT 103
34722: PPUSH
34723: LD_INT 140
34725: PPUSH
34726: LD_INT 20
34728: PPUSH
34729: LD_INT 1
34731: PPUSH
34732: CALL_OW 56
// end ; if time > 1 1$20 then
34736: LD_VAR 0 1
34740: PUSH
34741: LD_INT 2800
34743: GREATER
34744: IFFALSE 34754
// time := 0 0$30 ;
34746: LD_ADDR_VAR 0 1
34750: PUSH
34751: LD_INT 1050
34753: ST_TO_ADDR
// until false ;
34754: LD_INT 0
34756: IFFALSE 34431
// end ; end_of_file
34758: PPOPN 1
34760: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34761: LD_EXP 13
34765: PUSH
34766: LD_EXP 15
34770: PUSH
34771: LD_INT 6
34773: GREATEREQUAL
34774: AND
34775: IFFALSE 34812
34777: GO 34779
34779: DISABLE
// begin enable ;
34780: ENABLE
// missionTime := missionTime + 0 0$1 ;
34781: LD_ADDR_EXP 14
34785: PUSH
34786: LD_EXP 14
34790: PUSH
34791: LD_INT 35
34793: PLUS
34794: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34795: LD_ADDR_OWVAR 47
34799: PUSH
34800: LD_STRING #Am15-1
34802: PUSH
34803: LD_EXP 14
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: ST_TO_ADDR
// end ; end_of_file
34812: END
// export function InitNature ; begin
34813: LD_INT 0
34815: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34816: LD_INT 3
34818: PPUSH
34819: LD_INT 3
34821: PPUSH
34822: LD_INT 2
34824: PPUSH
34825: LD_INT 1
34827: PPUSH
34828: LD_INT 1
34830: PPUSH
34831: LD_INT 0
34833: PPUSH
34834: LD_INT 0
34836: PPUSH
34837: LD_INT 20
34839: PPUSH
34840: LD_INT 0
34842: PPUSH
34843: CALL 97691 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 1
34858: PPUSH
34859: LD_INT 1
34861: PPUSH
34862: LD_INT 0
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: LD_INT 21
34870: PPUSH
34871: LD_INT 0
34873: PPUSH
34874: CALL 97691 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34878: LD_INT 4
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 2
34886: PPUSH
34887: LD_INT 4
34889: PPUSH
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: LD_INT 22
34901: PPUSH
34902: LD_INT 0
34904: PPUSH
34905: CALL 97691 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34909: LD_INT 0
34911: PPUSH
34912: LD_INT 0
34914: PPUSH
34915: LD_INT 0
34917: PPUSH
34918: LD_INT 0
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 0
34926: PPUSH
34927: LD_INT 9
34929: PPUSH
34930: LD_INT 0
34932: PPUSH
34933: LD_INT 23
34935: PPUSH
34936: CALL 97691 0 9
// end ; end_of_file
34940: LD_VAR 0 1
34944: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
34945: GO 34947
34947: DISABLE
// begin ru_radar := 98 ;
34948: LD_ADDR_EXP 95
34952: PUSH
34953: LD_INT 98
34955: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34956: LD_ADDR_EXP 96
34960: PUSH
34961: LD_INT 89
34963: ST_TO_ADDR
// us_hack := 99 ;
34964: LD_ADDR_EXP 97
34968: PUSH
34969: LD_INT 99
34971: ST_TO_ADDR
// us_artillery := 97 ;
34972: LD_ADDR_EXP 98
34976: PUSH
34977: LD_INT 97
34979: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34980: LD_ADDR_EXP 99
34984: PUSH
34985: LD_INT 91
34987: ST_TO_ADDR
// tech_Artillery := 80 ;
34988: LD_ADDR_EXP 100
34992: PUSH
34993: LD_INT 80
34995: ST_TO_ADDR
// tech_RadMat := 81 ;
34996: LD_ADDR_EXP 101
35000: PUSH
35001: LD_INT 81
35003: ST_TO_ADDR
// tech_BasicTools := 82 ;
35004: LD_ADDR_EXP 102
35008: PUSH
35009: LD_INT 82
35011: ST_TO_ADDR
// tech_Cargo := 83 ;
35012: LD_ADDR_EXP 103
35016: PUSH
35017: LD_INT 83
35019: ST_TO_ADDR
// tech_Track := 84 ;
35020: LD_ADDR_EXP 104
35024: PUSH
35025: LD_INT 84
35027: ST_TO_ADDR
// tech_Crane := 85 ;
35028: LD_ADDR_EXP 105
35032: PUSH
35033: LD_INT 85
35035: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_INT 86
35043: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35044: LD_ADDR_EXP 107
35048: PUSH
35049: LD_INT 87
35051: ST_TO_ADDR
// end ; end_of_file
35052: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35053: LD_INT 0
35055: PPUSH
35056: PPUSH
// skirmish := false ;
35057: LD_ADDR_EXP 108
35061: PUSH
35062: LD_INT 0
35064: ST_TO_ADDR
// debug_mc := false ;
35065: LD_ADDR_EXP 109
35069: PUSH
35070: LD_INT 0
35072: ST_TO_ADDR
// mc_bases := [ ] ;
35073: LD_ADDR_EXP 110
35077: PUSH
35078: EMPTY
35079: ST_TO_ADDR
// mc_sides := [ ] ;
35080: LD_ADDR_EXP 136
35084: PUSH
35085: EMPTY
35086: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35087: LD_ADDR_EXP 111
35091: PUSH
35092: EMPTY
35093: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35094: LD_ADDR_EXP 112
35098: PUSH
35099: EMPTY
35100: ST_TO_ADDR
// mc_need_heal := [ ] ;
35101: LD_ADDR_EXP 113
35105: PUSH
35106: EMPTY
35107: ST_TO_ADDR
// mc_healers := [ ] ;
35108: LD_ADDR_EXP 114
35112: PUSH
35113: EMPTY
35114: ST_TO_ADDR
// mc_build_list := [ ] ;
35115: LD_ADDR_EXP 115
35119: PUSH
35120: EMPTY
35121: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35122: LD_ADDR_EXP 142
35126: PUSH
35127: EMPTY
35128: ST_TO_ADDR
// mc_builders := [ ] ;
35129: LD_ADDR_EXP 116
35133: PUSH
35134: EMPTY
35135: ST_TO_ADDR
// mc_construct_list := [ ] ;
35136: LD_ADDR_EXP 117
35140: PUSH
35141: EMPTY
35142: ST_TO_ADDR
// mc_turret_list := [ ] ;
35143: LD_ADDR_EXP 118
35147: PUSH
35148: EMPTY
35149: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35150: LD_ADDR_EXP 119
35154: PUSH
35155: EMPTY
35156: ST_TO_ADDR
// mc_miners := [ ] ;
35157: LD_ADDR_EXP 124
35161: PUSH
35162: EMPTY
35163: ST_TO_ADDR
// mc_mines := [ ] ;
35164: LD_ADDR_EXP 123
35168: PUSH
35169: EMPTY
35170: ST_TO_ADDR
// mc_minefields := [ ] ;
35171: LD_ADDR_EXP 125
35175: PUSH
35176: EMPTY
35177: ST_TO_ADDR
// mc_crates := [ ] ;
35178: LD_ADDR_EXP 126
35182: PUSH
35183: EMPTY
35184: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35185: LD_ADDR_EXP 127
35189: PUSH
35190: EMPTY
35191: ST_TO_ADDR
// mc_crates_area := [ ] ;
35192: LD_ADDR_EXP 128
35196: PUSH
35197: EMPTY
35198: ST_TO_ADDR
// mc_vehicles := [ ] ;
35199: LD_ADDR_EXP 129
35203: PUSH
35204: EMPTY
35205: ST_TO_ADDR
// mc_attack := [ ] ;
35206: LD_ADDR_EXP 130
35210: PUSH
35211: EMPTY
35212: ST_TO_ADDR
// mc_produce := [ ] ;
35213: LD_ADDR_EXP 131
35217: PUSH
35218: EMPTY
35219: ST_TO_ADDR
// mc_defender := [ ] ;
35220: LD_ADDR_EXP 132
35224: PUSH
35225: EMPTY
35226: ST_TO_ADDR
// mc_parking := [ ] ;
35227: LD_ADDR_EXP 134
35231: PUSH
35232: EMPTY
35233: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35234: LD_ADDR_EXP 120
35238: PUSH
35239: EMPTY
35240: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35241: LD_ADDR_EXP 122
35245: PUSH
35246: EMPTY
35247: ST_TO_ADDR
// mc_scan := [ ] ;
35248: LD_ADDR_EXP 133
35252: PUSH
35253: EMPTY
35254: ST_TO_ADDR
// mc_scan_area := [ ] ;
35255: LD_ADDR_EXP 135
35259: PUSH
35260: EMPTY
35261: ST_TO_ADDR
// mc_tech := [ ] ;
35262: LD_ADDR_EXP 137
35266: PUSH
35267: EMPTY
35268: ST_TO_ADDR
// mc_class := [ ] ;
35269: LD_ADDR_EXP 151
35273: PUSH
35274: EMPTY
35275: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35276: LD_ADDR_EXP 152
35280: PUSH
35281: EMPTY
35282: ST_TO_ADDR
// end ;
35283: LD_VAR 0 1
35287: RET
// export function MC_Kill ( base ) ; begin
35288: LD_INT 0
35290: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35291: LD_ADDR_EXP 110
35295: PUSH
35296: LD_EXP 110
35300: PPUSH
35301: LD_VAR 0 1
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35313: LD_ADDR_EXP 111
35317: PUSH
35318: LD_EXP 111
35322: PPUSH
35323: LD_VAR 0 1
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35335: LD_ADDR_EXP 112
35339: PUSH
35340: LD_EXP 112
35344: PPUSH
35345: LD_VAR 0 1
35349: PPUSH
35350: EMPTY
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35357: LD_ADDR_EXP 113
35361: PUSH
35362: LD_EXP 113
35366: PPUSH
35367: LD_VAR 0 1
35371: PPUSH
35372: EMPTY
35373: PPUSH
35374: CALL_OW 1
35378: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35379: LD_ADDR_EXP 114
35383: PUSH
35384: LD_EXP 114
35388: PPUSH
35389: LD_VAR 0 1
35393: PPUSH
35394: EMPTY
35395: PPUSH
35396: CALL_OW 1
35400: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35401: LD_ADDR_EXP 115
35405: PUSH
35406: LD_EXP 115
35410: PPUSH
35411: LD_VAR 0 1
35415: PPUSH
35416: EMPTY
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35423: LD_ADDR_EXP 116
35427: PUSH
35428: LD_EXP 116
35432: PPUSH
35433: LD_VAR 0 1
35437: PPUSH
35438: EMPTY
35439: PPUSH
35440: CALL_OW 1
35444: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35445: LD_ADDR_EXP 117
35449: PUSH
35450: LD_EXP 117
35454: PPUSH
35455: LD_VAR 0 1
35459: PPUSH
35460: EMPTY
35461: PPUSH
35462: CALL_OW 1
35466: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35467: LD_ADDR_EXP 118
35471: PUSH
35472: LD_EXP 118
35476: PPUSH
35477: LD_VAR 0 1
35481: PPUSH
35482: EMPTY
35483: PPUSH
35484: CALL_OW 1
35488: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35489: LD_ADDR_EXP 119
35493: PUSH
35494: LD_EXP 119
35498: PPUSH
35499: LD_VAR 0 1
35503: PPUSH
35504: EMPTY
35505: PPUSH
35506: CALL_OW 1
35510: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35511: LD_ADDR_EXP 120
35515: PUSH
35516: LD_EXP 120
35520: PPUSH
35521: LD_VAR 0 1
35525: PPUSH
35526: EMPTY
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35533: LD_ADDR_EXP 121
35537: PUSH
35538: LD_EXP 121
35542: PPUSH
35543: LD_VAR 0 1
35547: PPUSH
35548: LD_INT 0
35550: PPUSH
35551: CALL_OW 1
35555: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35556: LD_ADDR_EXP 122
35560: PUSH
35561: LD_EXP 122
35565: PPUSH
35566: LD_VAR 0 1
35570: PPUSH
35571: EMPTY
35572: PPUSH
35573: CALL_OW 1
35577: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35578: LD_ADDR_EXP 123
35582: PUSH
35583: LD_EXP 123
35587: PPUSH
35588: LD_VAR 0 1
35592: PPUSH
35593: EMPTY
35594: PPUSH
35595: CALL_OW 1
35599: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35600: LD_ADDR_EXP 124
35604: PUSH
35605: LD_EXP 124
35609: PPUSH
35610: LD_VAR 0 1
35614: PPUSH
35615: EMPTY
35616: PPUSH
35617: CALL_OW 1
35621: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35622: LD_ADDR_EXP 125
35626: PUSH
35627: LD_EXP 125
35631: PPUSH
35632: LD_VAR 0 1
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35644: LD_ADDR_EXP 126
35648: PUSH
35649: LD_EXP 126
35653: PPUSH
35654: LD_VAR 0 1
35658: PPUSH
35659: EMPTY
35660: PPUSH
35661: CALL_OW 1
35665: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35666: LD_ADDR_EXP 127
35670: PUSH
35671: LD_EXP 127
35675: PPUSH
35676: LD_VAR 0 1
35680: PPUSH
35681: EMPTY
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35688: LD_ADDR_EXP 128
35692: PUSH
35693: LD_EXP 128
35697: PPUSH
35698: LD_VAR 0 1
35702: PPUSH
35703: EMPTY
35704: PPUSH
35705: CALL_OW 1
35709: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35710: LD_ADDR_EXP 129
35714: PUSH
35715: LD_EXP 129
35719: PPUSH
35720: LD_VAR 0 1
35724: PPUSH
35725: EMPTY
35726: PPUSH
35727: CALL_OW 1
35731: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35732: LD_ADDR_EXP 130
35736: PUSH
35737: LD_EXP 130
35741: PPUSH
35742: LD_VAR 0 1
35746: PPUSH
35747: EMPTY
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35754: LD_ADDR_EXP 131
35758: PUSH
35759: LD_EXP 131
35763: PPUSH
35764: LD_VAR 0 1
35768: PPUSH
35769: EMPTY
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35776: LD_ADDR_EXP 132
35780: PUSH
35781: LD_EXP 132
35785: PPUSH
35786: LD_VAR 0 1
35790: PPUSH
35791: EMPTY
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35798: LD_ADDR_EXP 133
35802: PUSH
35803: LD_EXP 133
35807: PPUSH
35808: LD_VAR 0 1
35812: PPUSH
35813: EMPTY
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35820: LD_ADDR_EXP 134
35824: PUSH
35825: LD_EXP 134
35829: PPUSH
35830: LD_VAR 0 1
35834: PPUSH
35835: EMPTY
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35842: LD_ADDR_EXP 135
35846: PUSH
35847: LD_EXP 135
35851: PPUSH
35852: LD_VAR 0 1
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35864: LD_ADDR_EXP 137
35868: PUSH
35869: LD_EXP 137
35873: PPUSH
35874: LD_VAR 0 1
35878: PPUSH
35879: EMPTY
35880: PPUSH
35881: CALL_OW 1
35885: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35886: LD_ADDR_EXP 139
35890: PUSH
35891: LD_EXP 139
35895: PPUSH
35896: LD_VAR 0 1
35900: PPUSH
35901: EMPTY
35902: PPUSH
35903: CALL_OW 1
35907: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35908: LD_ADDR_EXP 140
35912: PUSH
35913: LD_EXP 140
35917: PPUSH
35918: LD_VAR 0 1
35922: PPUSH
35923: EMPTY
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35930: LD_ADDR_EXP 141
35934: PUSH
35935: LD_EXP 141
35939: PPUSH
35940: LD_VAR 0 1
35944: PPUSH
35945: EMPTY
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35952: LD_ADDR_EXP 142
35956: PUSH
35957: LD_EXP 142
35961: PPUSH
35962: LD_VAR 0 1
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35974: LD_ADDR_EXP 143
35978: PUSH
35979: LD_EXP 143
35983: PPUSH
35984: LD_VAR 0 1
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35996: LD_ADDR_EXP 144
36000: PUSH
36001: LD_EXP 144
36005: PPUSH
36006: LD_VAR 0 1
36010: PPUSH
36011: EMPTY
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36018: LD_ADDR_EXP 145
36022: PUSH
36023: LD_EXP 145
36027: PPUSH
36028: LD_VAR 0 1
36032: PPUSH
36033: EMPTY
36034: PPUSH
36035: CALL_OW 1
36039: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36040: LD_ADDR_EXP 146
36044: PUSH
36045: LD_EXP 146
36049: PPUSH
36050: LD_VAR 0 1
36054: PPUSH
36055: EMPTY
36056: PPUSH
36057: CALL_OW 1
36061: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36062: LD_ADDR_EXP 147
36066: PUSH
36067: LD_EXP 147
36071: PPUSH
36072: LD_VAR 0 1
36076: PPUSH
36077: EMPTY
36078: PPUSH
36079: CALL_OW 1
36083: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36084: LD_ADDR_EXP 148
36088: PUSH
36089: LD_EXP 148
36093: PPUSH
36094: LD_VAR 0 1
36098: PPUSH
36099: EMPTY
36100: PPUSH
36101: CALL_OW 1
36105: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36106: LD_ADDR_EXP 149
36110: PUSH
36111: LD_EXP 149
36115: PPUSH
36116: LD_VAR 0 1
36120: PPUSH
36121: EMPTY
36122: PPUSH
36123: CALL_OW 1
36127: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36128: LD_ADDR_EXP 150
36132: PUSH
36133: LD_EXP 150
36137: PPUSH
36138: LD_VAR 0 1
36142: PPUSH
36143: EMPTY
36144: PPUSH
36145: CALL_OW 1
36149: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36150: LD_ADDR_EXP 151
36154: PUSH
36155: LD_EXP 151
36159: PPUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: EMPTY
36166: PPUSH
36167: CALL_OW 1
36171: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36172: LD_ADDR_EXP 152
36176: PUSH
36177: LD_EXP 152
36181: PPUSH
36182: LD_VAR 0 1
36186: PPUSH
36187: LD_INT 0
36189: PPUSH
36190: CALL_OW 1
36194: ST_TO_ADDR
// end ;
36195: LD_VAR 0 2
36199: RET
// export function MC_Add ( side , units ) ; var base ; begin
36200: LD_INT 0
36202: PPUSH
36203: PPUSH
// base := mc_bases + 1 ;
36204: LD_ADDR_VAR 0 4
36208: PUSH
36209: LD_EXP 110
36213: PUSH
36214: LD_INT 1
36216: PLUS
36217: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36218: LD_ADDR_EXP 136
36222: PUSH
36223: LD_EXP 136
36227: PPUSH
36228: LD_VAR 0 4
36232: PPUSH
36233: LD_VAR 0 1
36237: PPUSH
36238: CALL_OW 1
36242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36243: LD_ADDR_EXP 110
36247: PUSH
36248: LD_EXP 110
36252: PPUSH
36253: LD_VAR 0 4
36257: PPUSH
36258: LD_VAR 0 2
36262: PPUSH
36263: CALL_OW 1
36267: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36268: LD_ADDR_EXP 111
36272: PUSH
36273: LD_EXP 111
36277: PPUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36290: LD_ADDR_EXP 112
36294: PUSH
36295: LD_EXP 112
36299: PPUSH
36300: LD_VAR 0 4
36304: PPUSH
36305: EMPTY
36306: PPUSH
36307: CALL_OW 1
36311: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36312: LD_ADDR_EXP 113
36316: PUSH
36317: LD_EXP 113
36321: PPUSH
36322: LD_VAR 0 4
36326: PPUSH
36327: EMPTY
36328: PPUSH
36329: CALL_OW 1
36333: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36334: LD_ADDR_EXP 114
36338: PUSH
36339: LD_EXP 114
36343: PPUSH
36344: LD_VAR 0 4
36348: PPUSH
36349: EMPTY
36350: PPUSH
36351: CALL_OW 1
36355: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36356: LD_ADDR_EXP 115
36360: PUSH
36361: LD_EXP 115
36365: PPUSH
36366: LD_VAR 0 4
36370: PPUSH
36371: EMPTY
36372: PPUSH
36373: CALL_OW 1
36377: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36378: LD_ADDR_EXP 116
36382: PUSH
36383: LD_EXP 116
36387: PPUSH
36388: LD_VAR 0 4
36392: PPUSH
36393: EMPTY
36394: PPUSH
36395: CALL_OW 1
36399: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36400: LD_ADDR_EXP 117
36404: PUSH
36405: LD_EXP 117
36409: PPUSH
36410: LD_VAR 0 4
36414: PPUSH
36415: EMPTY
36416: PPUSH
36417: CALL_OW 1
36421: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36422: LD_ADDR_EXP 118
36426: PUSH
36427: LD_EXP 118
36431: PPUSH
36432: LD_VAR 0 4
36436: PPUSH
36437: EMPTY
36438: PPUSH
36439: CALL_OW 1
36443: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36444: LD_ADDR_EXP 119
36448: PUSH
36449: LD_EXP 119
36453: PPUSH
36454: LD_VAR 0 4
36458: PPUSH
36459: EMPTY
36460: PPUSH
36461: CALL_OW 1
36465: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36466: LD_ADDR_EXP 120
36470: PUSH
36471: LD_EXP 120
36475: PPUSH
36476: LD_VAR 0 4
36480: PPUSH
36481: EMPTY
36482: PPUSH
36483: CALL_OW 1
36487: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36488: LD_ADDR_EXP 121
36492: PUSH
36493: LD_EXP 121
36497: PPUSH
36498: LD_VAR 0 4
36502: PPUSH
36503: LD_INT 0
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36511: LD_ADDR_EXP 122
36515: PUSH
36516: LD_EXP 122
36520: PPUSH
36521: LD_VAR 0 4
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36533: LD_ADDR_EXP 123
36537: PUSH
36538: LD_EXP 123
36542: PPUSH
36543: LD_VAR 0 4
36547: PPUSH
36548: EMPTY
36549: PPUSH
36550: CALL_OW 1
36554: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36555: LD_ADDR_EXP 124
36559: PUSH
36560: LD_EXP 124
36564: PPUSH
36565: LD_VAR 0 4
36569: PPUSH
36570: EMPTY
36571: PPUSH
36572: CALL_OW 1
36576: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36577: LD_ADDR_EXP 125
36581: PUSH
36582: LD_EXP 125
36586: PPUSH
36587: LD_VAR 0 4
36591: PPUSH
36592: EMPTY
36593: PPUSH
36594: CALL_OW 1
36598: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36599: LD_ADDR_EXP 126
36603: PUSH
36604: LD_EXP 126
36608: PPUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: EMPTY
36615: PPUSH
36616: CALL_OW 1
36620: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36621: LD_ADDR_EXP 127
36625: PUSH
36626: LD_EXP 127
36630: PPUSH
36631: LD_VAR 0 4
36635: PPUSH
36636: EMPTY
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36643: LD_ADDR_EXP 128
36647: PUSH
36648: LD_EXP 128
36652: PPUSH
36653: LD_VAR 0 4
36657: PPUSH
36658: EMPTY
36659: PPUSH
36660: CALL_OW 1
36664: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36665: LD_ADDR_EXP 129
36669: PUSH
36670: LD_EXP 129
36674: PPUSH
36675: LD_VAR 0 4
36679: PPUSH
36680: EMPTY
36681: PPUSH
36682: CALL_OW 1
36686: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36687: LD_ADDR_EXP 130
36691: PUSH
36692: LD_EXP 130
36696: PPUSH
36697: LD_VAR 0 4
36701: PPUSH
36702: EMPTY
36703: PPUSH
36704: CALL_OW 1
36708: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36709: LD_ADDR_EXP 131
36713: PUSH
36714: LD_EXP 131
36718: PPUSH
36719: LD_VAR 0 4
36723: PPUSH
36724: EMPTY
36725: PPUSH
36726: CALL_OW 1
36730: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36731: LD_ADDR_EXP 132
36735: PUSH
36736: LD_EXP 132
36740: PPUSH
36741: LD_VAR 0 4
36745: PPUSH
36746: EMPTY
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36753: LD_ADDR_EXP 133
36757: PUSH
36758: LD_EXP 133
36762: PPUSH
36763: LD_VAR 0 4
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36775: LD_ADDR_EXP 134
36779: PUSH
36780: LD_EXP 134
36784: PPUSH
36785: LD_VAR 0 4
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36797: LD_ADDR_EXP 135
36801: PUSH
36802: LD_EXP 135
36806: PPUSH
36807: LD_VAR 0 4
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36819: LD_ADDR_EXP 137
36823: PUSH
36824: LD_EXP 137
36828: PPUSH
36829: LD_VAR 0 4
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36841: LD_ADDR_EXP 139
36845: PUSH
36846: LD_EXP 139
36850: PPUSH
36851: LD_VAR 0 4
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36863: LD_ADDR_EXP 140
36867: PUSH
36868: LD_EXP 140
36872: PPUSH
36873: LD_VAR 0 4
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36885: LD_ADDR_EXP 141
36889: PUSH
36890: LD_EXP 141
36894: PPUSH
36895: LD_VAR 0 4
36899: PPUSH
36900: EMPTY
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36907: LD_ADDR_EXP 142
36911: PUSH
36912: LD_EXP 142
36916: PPUSH
36917: LD_VAR 0 4
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36929: LD_ADDR_EXP 143
36933: PUSH
36934: LD_EXP 143
36938: PPUSH
36939: LD_VAR 0 4
36943: PPUSH
36944: EMPTY
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36951: LD_ADDR_EXP 144
36955: PUSH
36956: LD_EXP 144
36960: PPUSH
36961: LD_VAR 0 4
36965: PPUSH
36966: EMPTY
36967: PPUSH
36968: CALL_OW 1
36972: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36973: LD_ADDR_EXP 145
36977: PUSH
36978: LD_EXP 145
36982: PPUSH
36983: LD_VAR 0 4
36987: PPUSH
36988: EMPTY
36989: PPUSH
36990: CALL_OW 1
36994: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36995: LD_ADDR_EXP 146
36999: PUSH
37000: LD_EXP 146
37004: PPUSH
37005: LD_VAR 0 4
37009: PPUSH
37010: EMPTY
37011: PPUSH
37012: CALL_OW 1
37016: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37017: LD_ADDR_EXP 147
37021: PUSH
37022: LD_EXP 147
37026: PPUSH
37027: LD_VAR 0 4
37031: PPUSH
37032: EMPTY
37033: PPUSH
37034: CALL_OW 1
37038: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37039: LD_ADDR_EXP 148
37043: PUSH
37044: LD_EXP 148
37048: PPUSH
37049: LD_VAR 0 4
37053: PPUSH
37054: EMPTY
37055: PPUSH
37056: CALL_OW 1
37060: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37061: LD_ADDR_EXP 149
37065: PUSH
37066: LD_EXP 149
37070: PPUSH
37071: LD_VAR 0 4
37075: PPUSH
37076: EMPTY
37077: PPUSH
37078: CALL_OW 1
37082: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37083: LD_ADDR_EXP 150
37087: PUSH
37088: LD_EXP 150
37092: PPUSH
37093: LD_VAR 0 4
37097: PPUSH
37098: EMPTY
37099: PPUSH
37100: CALL_OW 1
37104: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37105: LD_ADDR_EXP 151
37109: PUSH
37110: LD_EXP 151
37114: PPUSH
37115: LD_VAR 0 4
37119: PPUSH
37120: EMPTY
37121: PPUSH
37122: CALL_OW 1
37126: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37127: LD_ADDR_EXP 152
37131: PUSH
37132: LD_EXP 152
37136: PPUSH
37137: LD_VAR 0 4
37141: PPUSH
37142: LD_INT 0
37144: PPUSH
37145: CALL_OW 1
37149: ST_TO_ADDR
// result := base ;
37150: LD_ADDR_VAR 0 3
37154: PUSH
37155: LD_VAR 0 4
37159: ST_TO_ADDR
// end ;
37160: LD_VAR 0 3
37164: RET
// export function MC_Start ( ) ; var i ; begin
37165: LD_INT 0
37167: PPUSH
37168: PPUSH
// for i = 1 to mc_bases do
37169: LD_ADDR_VAR 0 2
37173: PUSH
37174: DOUBLE
37175: LD_INT 1
37177: DEC
37178: ST_TO_ADDR
37179: LD_EXP 110
37183: PUSH
37184: FOR_TO
37185: IFFALSE 38262
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37187: LD_ADDR_EXP 110
37191: PUSH
37192: LD_EXP 110
37196: PPUSH
37197: LD_VAR 0 2
37201: PPUSH
37202: LD_EXP 110
37206: PUSH
37207: LD_VAR 0 2
37211: ARRAY
37212: PUSH
37213: LD_INT 0
37215: DIFF
37216: PPUSH
37217: CALL_OW 1
37221: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37222: LD_ADDR_EXP 111
37226: PUSH
37227: LD_EXP 111
37231: PPUSH
37232: LD_VAR 0 2
37236: PPUSH
37237: EMPTY
37238: PPUSH
37239: CALL_OW 1
37243: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37244: LD_ADDR_EXP 112
37248: PUSH
37249: LD_EXP 112
37253: PPUSH
37254: LD_VAR 0 2
37258: PPUSH
37259: EMPTY
37260: PPUSH
37261: CALL_OW 1
37265: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37266: LD_ADDR_EXP 113
37270: PUSH
37271: LD_EXP 113
37275: PPUSH
37276: LD_VAR 0 2
37280: PPUSH
37281: EMPTY
37282: PPUSH
37283: CALL_OW 1
37287: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37288: LD_ADDR_EXP 114
37292: PUSH
37293: LD_EXP 114
37297: PPUSH
37298: LD_VAR 0 2
37302: PPUSH
37303: EMPTY
37304: PUSH
37305: EMPTY
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PPUSH
37311: CALL_OW 1
37315: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37316: LD_ADDR_EXP 115
37320: PUSH
37321: LD_EXP 115
37325: PPUSH
37326: LD_VAR 0 2
37330: PPUSH
37331: EMPTY
37332: PPUSH
37333: CALL_OW 1
37337: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37338: LD_ADDR_EXP 142
37342: PUSH
37343: LD_EXP 142
37347: PPUSH
37348: LD_VAR 0 2
37352: PPUSH
37353: EMPTY
37354: PPUSH
37355: CALL_OW 1
37359: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37360: LD_ADDR_EXP 116
37364: PUSH
37365: LD_EXP 116
37369: PPUSH
37370: LD_VAR 0 2
37374: PPUSH
37375: EMPTY
37376: PPUSH
37377: CALL_OW 1
37381: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37382: LD_ADDR_EXP 117
37386: PUSH
37387: LD_EXP 117
37391: PPUSH
37392: LD_VAR 0 2
37396: PPUSH
37397: EMPTY
37398: PPUSH
37399: CALL_OW 1
37403: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37404: LD_ADDR_EXP 118
37408: PUSH
37409: LD_EXP 118
37413: PPUSH
37414: LD_VAR 0 2
37418: PPUSH
37419: LD_EXP 110
37423: PUSH
37424: LD_VAR 0 2
37428: ARRAY
37429: PPUSH
37430: LD_INT 2
37432: PUSH
37433: LD_INT 30
37435: PUSH
37436: LD_INT 32
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 30
37445: PUSH
37446: LD_INT 33
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: LIST
37457: PPUSH
37458: CALL_OW 72
37462: PPUSH
37463: CALL_OW 1
37467: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37468: LD_ADDR_EXP 119
37472: PUSH
37473: LD_EXP 119
37477: PPUSH
37478: LD_VAR 0 2
37482: PPUSH
37483: LD_EXP 110
37487: PUSH
37488: LD_VAR 0 2
37492: ARRAY
37493: PPUSH
37494: LD_INT 2
37496: PUSH
37497: LD_INT 30
37499: PUSH
37500: LD_INT 32
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 30
37509: PUSH
37510: LD_INT 31
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 58
37524: PUSH
37525: EMPTY
37526: LIST
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PPUSH
37532: CALL_OW 72
37536: PPUSH
37537: CALL_OW 1
37541: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37542: LD_ADDR_EXP 120
37546: PUSH
37547: LD_EXP 120
37551: PPUSH
37552: LD_VAR 0 2
37556: PPUSH
37557: EMPTY
37558: PPUSH
37559: CALL_OW 1
37563: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37564: LD_ADDR_EXP 124
37568: PUSH
37569: LD_EXP 124
37573: PPUSH
37574: LD_VAR 0 2
37578: PPUSH
37579: EMPTY
37580: PPUSH
37581: CALL_OW 1
37585: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37586: LD_ADDR_EXP 123
37590: PUSH
37591: LD_EXP 123
37595: PPUSH
37596: LD_VAR 0 2
37600: PPUSH
37601: EMPTY
37602: PPUSH
37603: CALL_OW 1
37607: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37608: LD_ADDR_EXP 125
37612: PUSH
37613: LD_EXP 125
37617: PPUSH
37618: LD_VAR 0 2
37622: PPUSH
37623: EMPTY
37624: PPUSH
37625: CALL_OW 1
37629: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37630: LD_ADDR_EXP 126
37634: PUSH
37635: LD_EXP 126
37639: PPUSH
37640: LD_VAR 0 2
37644: PPUSH
37645: EMPTY
37646: PPUSH
37647: CALL_OW 1
37651: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37652: LD_ADDR_EXP 127
37656: PUSH
37657: LD_EXP 127
37661: PPUSH
37662: LD_VAR 0 2
37666: PPUSH
37667: EMPTY
37668: PPUSH
37669: CALL_OW 1
37673: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37674: LD_ADDR_EXP 128
37678: PUSH
37679: LD_EXP 128
37683: PPUSH
37684: LD_VAR 0 2
37688: PPUSH
37689: EMPTY
37690: PPUSH
37691: CALL_OW 1
37695: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37696: LD_ADDR_EXP 129
37700: PUSH
37701: LD_EXP 129
37705: PPUSH
37706: LD_VAR 0 2
37710: PPUSH
37711: EMPTY
37712: PPUSH
37713: CALL_OW 1
37717: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37718: LD_ADDR_EXP 130
37722: PUSH
37723: LD_EXP 130
37727: PPUSH
37728: LD_VAR 0 2
37732: PPUSH
37733: EMPTY
37734: PPUSH
37735: CALL_OW 1
37739: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37740: LD_ADDR_EXP 131
37744: PUSH
37745: LD_EXP 131
37749: PPUSH
37750: LD_VAR 0 2
37754: PPUSH
37755: EMPTY
37756: PPUSH
37757: CALL_OW 1
37761: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37762: LD_ADDR_EXP 132
37766: PUSH
37767: LD_EXP 132
37771: PPUSH
37772: LD_VAR 0 2
37776: PPUSH
37777: EMPTY
37778: PPUSH
37779: CALL_OW 1
37783: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37784: LD_ADDR_EXP 121
37788: PUSH
37789: LD_EXP 121
37793: PPUSH
37794: LD_VAR 0 2
37798: PPUSH
37799: LD_INT 0
37801: PPUSH
37802: CALL_OW 1
37806: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37807: LD_ADDR_EXP 134
37811: PUSH
37812: LD_EXP 134
37816: PPUSH
37817: LD_VAR 0 2
37821: PPUSH
37822: LD_INT 0
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37830: LD_ADDR_EXP 122
37834: PUSH
37835: LD_EXP 122
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37852: LD_ADDR_EXP 133
37856: PUSH
37857: LD_EXP 133
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: LD_INT 0
37869: PPUSH
37870: CALL_OW 1
37874: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37875: LD_ADDR_EXP 135
37879: PUSH
37880: LD_EXP 135
37884: PPUSH
37885: LD_VAR 0 2
37889: PPUSH
37890: EMPTY
37891: PPUSH
37892: CALL_OW 1
37896: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37897: LD_ADDR_EXP 138
37901: PUSH
37902: LD_EXP 138
37906: PPUSH
37907: LD_VAR 0 2
37911: PPUSH
37912: LD_INT 0
37914: PPUSH
37915: CALL_OW 1
37919: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37920: LD_ADDR_EXP 139
37924: PUSH
37925: LD_EXP 139
37929: PPUSH
37930: LD_VAR 0 2
37934: PPUSH
37935: EMPTY
37936: PPUSH
37937: CALL_OW 1
37941: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37942: LD_ADDR_EXP 140
37946: PUSH
37947: LD_EXP 140
37951: PPUSH
37952: LD_VAR 0 2
37956: PPUSH
37957: EMPTY
37958: PPUSH
37959: CALL_OW 1
37963: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37964: LD_ADDR_EXP 141
37968: PUSH
37969: LD_EXP 141
37973: PPUSH
37974: LD_VAR 0 2
37978: PPUSH
37979: EMPTY
37980: PPUSH
37981: CALL_OW 1
37985: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37986: LD_ADDR_EXP 143
37990: PUSH
37991: LD_EXP 143
37995: PPUSH
37996: LD_VAR 0 2
38000: PPUSH
38001: LD_EXP 110
38005: PUSH
38006: LD_VAR 0 2
38010: ARRAY
38011: PPUSH
38012: LD_INT 2
38014: PUSH
38015: LD_INT 30
38017: PUSH
38018: LD_INT 6
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 30
38027: PUSH
38028: LD_INT 7
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 30
38037: PUSH
38038: LD_INT 8
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: PPUSH
38051: CALL_OW 72
38055: PPUSH
38056: CALL_OW 1
38060: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38061: LD_ADDR_EXP 144
38065: PUSH
38066: LD_EXP 144
38070: PPUSH
38071: LD_VAR 0 2
38075: PPUSH
38076: EMPTY
38077: PPUSH
38078: CALL_OW 1
38082: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38083: LD_ADDR_EXP 145
38087: PUSH
38088: LD_EXP 145
38092: PPUSH
38093: LD_VAR 0 2
38097: PPUSH
38098: EMPTY
38099: PPUSH
38100: CALL_OW 1
38104: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38105: LD_ADDR_EXP 146
38109: PUSH
38110: LD_EXP 146
38114: PPUSH
38115: LD_VAR 0 2
38119: PPUSH
38120: EMPTY
38121: PPUSH
38122: CALL_OW 1
38126: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38127: LD_ADDR_EXP 147
38131: PUSH
38132: LD_EXP 147
38136: PPUSH
38137: LD_VAR 0 2
38141: PPUSH
38142: EMPTY
38143: PPUSH
38144: CALL_OW 1
38148: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38149: LD_ADDR_EXP 148
38153: PUSH
38154: LD_EXP 148
38158: PPUSH
38159: LD_VAR 0 2
38163: PPUSH
38164: EMPTY
38165: PPUSH
38166: CALL_OW 1
38170: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38171: LD_ADDR_EXP 149
38175: PUSH
38176: LD_EXP 149
38180: PPUSH
38181: LD_VAR 0 2
38185: PPUSH
38186: EMPTY
38187: PPUSH
38188: CALL_OW 1
38192: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38193: LD_ADDR_EXP 150
38197: PUSH
38198: LD_EXP 150
38202: PPUSH
38203: LD_VAR 0 2
38207: PPUSH
38208: EMPTY
38209: PPUSH
38210: CALL_OW 1
38214: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38215: LD_ADDR_EXP 151
38219: PUSH
38220: LD_EXP 151
38224: PPUSH
38225: LD_VAR 0 2
38229: PPUSH
38230: EMPTY
38231: PPUSH
38232: CALL_OW 1
38236: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38237: LD_ADDR_EXP 152
38241: PUSH
38242: LD_EXP 152
38246: PPUSH
38247: LD_VAR 0 2
38251: PPUSH
38252: LD_INT 0
38254: PPUSH
38255: CALL_OW 1
38259: ST_TO_ADDR
// end ;
38260: GO 37184
38262: POP
38263: POP
// MC_InitSides ( ) ;
38264: CALL 38550 0 0
// MC_InitResearch ( ) ;
38268: CALL 38289 0 0
// CustomInitMacro ( ) ;
38272: CALL 467 0 0
// skirmish := true ;
38276: LD_ADDR_EXP 108
38280: PUSH
38281: LD_INT 1
38283: ST_TO_ADDR
// end ;
38284: LD_VAR 0 1
38288: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38289: LD_INT 0
38291: PPUSH
38292: PPUSH
38293: PPUSH
38294: PPUSH
38295: PPUSH
38296: PPUSH
// if not mc_bases then
38297: LD_EXP 110
38301: NOT
38302: IFFALSE 38306
// exit ;
38304: GO 38545
// for i = 1 to 8 do
38306: LD_ADDR_VAR 0 2
38310: PUSH
38311: DOUBLE
38312: LD_INT 1
38314: DEC
38315: ST_TO_ADDR
38316: LD_INT 8
38318: PUSH
38319: FOR_TO
38320: IFFALSE 38346
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38322: LD_ADDR_EXP 137
38326: PUSH
38327: LD_EXP 137
38331: PPUSH
38332: LD_VAR 0 2
38336: PPUSH
38337: EMPTY
38338: PPUSH
38339: CALL_OW 1
38343: ST_TO_ADDR
38344: GO 38319
38346: POP
38347: POP
// tmp := [ ] ;
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: EMPTY
38354: ST_TO_ADDR
// for i = 1 to mc_sides do
38355: LD_ADDR_VAR 0 2
38359: PUSH
38360: DOUBLE
38361: LD_INT 1
38363: DEC
38364: ST_TO_ADDR
38365: LD_EXP 136
38369: PUSH
38370: FOR_TO
38371: IFFALSE 38429
// if not mc_sides [ i ] in tmp then
38373: LD_EXP 136
38377: PUSH
38378: LD_VAR 0 2
38382: ARRAY
38383: PUSH
38384: LD_VAR 0 5
38388: IN
38389: NOT
38390: IFFALSE 38427
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38392: LD_ADDR_VAR 0 5
38396: PUSH
38397: LD_VAR 0 5
38401: PPUSH
38402: LD_VAR 0 5
38406: PUSH
38407: LD_INT 1
38409: PLUS
38410: PPUSH
38411: LD_EXP 136
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: PPUSH
38422: CALL_OW 2
38426: ST_TO_ADDR
38427: GO 38370
38429: POP
38430: POP
// if not tmp then
38431: LD_VAR 0 5
38435: NOT
38436: IFFALSE 38440
// exit ;
38438: GO 38545
// for j in tmp do
38440: LD_ADDR_VAR 0 3
38444: PUSH
38445: LD_VAR 0 5
38449: PUSH
38450: FOR_IN
38451: IFFALSE 38543
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38453: LD_ADDR_VAR 0 6
38457: PUSH
38458: LD_INT 22
38460: PUSH
38461: LD_VAR 0 3
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PPUSH
38470: CALL_OW 69
38474: ST_TO_ADDR
// if not un then
38475: LD_VAR 0 6
38479: NOT
38480: IFFALSE 38484
// continue ;
38482: GO 38450
// nation := GetNation ( un [ 1 ] ) ;
38484: LD_ADDR_VAR 0 4
38488: PUSH
38489: LD_VAR 0 6
38493: PUSH
38494: LD_INT 1
38496: ARRAY
38497: PPUSH
38498: CALL_OW 248
38502: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38503: LD_ADDR_EXP 137
38507: PUSH
38508: LD_EXP 137
38512: PPUSH
38513: LD_VAR 0 3
38517: PPUSH
38518: LD_VAR 0 3
38522: PPUSH
38523: LD_VAR 0 4
38527: PPUSH
38528: LD_INT 1
38530: PPUSH
38531: CALL 65139 0 3
38535: PPUSH
38536: CALL_OW 1
38540: ST_TO_ADDR
// end ;
38541: GO 38450
38543: POP
38544: POP
// end ;
38545: LD_VAR 0 1
38549: RET
// export function MC_InitSides ( ) ; var i ; begin
38550: LD_INT 0
38552: PPUSH
38553: PPUSH
// if not mc_bases then
38554: LD_EXP 110
38558: NOT
38559: IFFALSE 38563
// exit ;
38561: GO 38637
// for i = 1 to mc_bases do
38563: LD_ADDR_VAR 0 2
38567: PUSH
38568: DOUBLE
38569: LD_INT 1
38571: DEC
38572: ST_TO_ADDR
38573: LD_EXP 110
38577: PUSH
38578: FOR_TO
38579: IFFALSE 38635
// if mc_bases [ i ] then
38581: LD_EXP 110
38585: PUSH
38586: LD_VAR 0 2
38590: ARRAY
38591: IFFALSE 38633
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38593: LD_ADDR_EXP 136
38597: PUSH
38598: LD_EXP 136
38602: PPUSH
38603: LD_VAR 0 2
38607: PPUSH
38608: LD_EXP 110
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: PUSH
38619: LD_INT 1
38621: ARRAY
38622: PPUSH
38623: CALL_OW 255
38627: PPUSH
38628: CALL_OW 1
38632: ST_TO_ADDR
38633: GO 38578
38635: POP
38636: POP
// end ;
38637: LD_VAR 0 1
38641: RET
// every 0 0$01 trigger skirmish do
38642: LD_EXP 108
38646: IFFALSE 38800
38648: GO 38650
38650: DISABLE
// begin enable ;
38651: ENABLE
// MC_CheckBuildings ( ) ;
38652: CALL 43298 0 0
// MC_CheckPeopleLife ( ) ;
38656: CALL 43423 0 0
// RaiseSailEvent ( 100 ) ;
38660: LD_INT 100
38662: PPUSH
38663: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38667: LD_INT 103
38669: PPUSH
38670: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38674: LD_INT 104
38676: PPUSH
38677: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38681: LD_INT 105
38683: PPUSH
38684: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38688: LD_INT 106
38690: PPUSH
38691: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38695: LD_INT 107
38697: PPUSH
38698: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38702: LD_INT 108
38704: PPUSH
38705: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38709: LD_INT 109
38711: PPUSH
38712: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38716: LD_INT 110
38718: PPUSH
38719: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38723: LD_INT 111
38725: PPUSH
38726: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38730: LD_INT 112
38732: PPUSH
38733: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38737: LD_INT 113
38739: PPUSH
38740: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38744: LD_INT 120
38746: PPUSH
38747: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38751: LD_INT 121
38753: PPUSH
38754: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38758: LD_INT 122
38760: PPUSH
38761: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38765: LD_INT 123
38767: PPUSH
38768: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38772: LD_INT 124
38774: PPUSH
38775: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38779: LD_INT 125
38781: PPUSH
38782: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38786: LD_INT 126
38788: PPUSH
38789: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38793: LD_INT 200
38795: PPUSH
38796: CALL_OW 427
// end ;
38800: END
// on SailEvent ( event ) do begin if event < 100 then
38801: LD_VAR 0 1
38805: PUSH
38806: LD_INT 100
38808: LESS
38809: IFFALSE 38820
// CustomEvent ( event ) ;
38811: LD_VAR 0 1
38815: PPUSH
38816: CALL 33403 0 1
// if event = 100 then
38820: LD_VAR 0 1
38824: PUSH
38825: LD_INT 100
38827: EQUAL
38828: IFFALSE 38834
// MC_ClassManager ( ) ;
38830: CALL 39226 0 0
// if event = 101 then
38834: LD_VAR 0 1
38838: PUSH
38839: LD_INT 101
38841: EQUAL
38842: IFFALSE 38848
// MC_RepairBuildings ( ) ;
38844: CALL 44008 0 0
// if event = 102 then
38848: LD_VAR 0 1
38852: PUSH
38853: LD_INT 102
38855: EQUAL
38856: IFFALSE 38862
// MC_Heal ( ) ;
38858: CALL 44867 0 0
// if event = 103 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 103
38869: EQUAL
38870: IFFALSE 38876
// MC_Build ( ) ;
38872: CALL 45289 0 0
// if event = 104 then
38876: LD_VAR 0 1
38880: PUSH
38881: LD_INT 104
38883: EQUAL
38884: IFFALSE 38890
// MC_TurretWeapon ( ) ;
38886: CALL 46902 0 0
// if event = 105 then
38890: LD_VAR 0 1
38894: PUSH
38895: LD_INT 105
38897: EQUAL
38898: IFFALSE 38904
// MC_BuildUpgrade ( ) ;
38900: CALL 46453 0 0
// if event = 106 then
38904: LD_VAR 0 1
38908: PUSH
38909: LD_INT 106
38911: EQUAL
38912: IFFALSE 38918
// MC_PlantMines ( ) ;
38914: CALL 47332 0 0
// if event = 107 then
38918: LD_VAR 0 1
38922: PUSH
38923: LD_INT 107
38925: EQUAL
38926: IFFALSE 38932
// MC_CollectCrates ( ) ;
38928: CALL 48130 0 0
// if event = 108 then
38932: LD_VAR 0 1
38936: PUSH
38937: LD_INT 108
38939: EQUAL
38940: IFFALSE 38946
// MC_LinkRemoteControl ( ) ;
38942: CALL 49906 0 0
// if event = 109 then
38946: LD_VAR 0 1
38950: PUSH
38951: LD_INT 109
38953: EQUAL
38954: IFFALSE 38960
// MC_ProduceVehicle ( ) ;
38956: CALL 50087 0 0
// if event = 110 then
38960: LD_VAR 0 1
38964: PUSH
38965: LD_INT 110
38967: EQUAL
38968: IFFALSE 38974
// MC_SendAttack ( ) ;
38970: CALL 50553 0 0
// if event = 111 then
38974: LD_VAR 0 1
38978: PUSH
38979: LD_INT 111
38981: EQUAL
38982: IFFALSE 38988
// MC_Defend ( ) ;
38984: CALL 50661 0 0
// if event = 112 then
38988: LD_VAR 0 1
38992: PUSH
38993: LD_INT 112
38995: EQUAL
38996: IFFALSE 39002
// MC_Research ( ) ;
38998: CALL 51266 0 0
// if event = 113 then
39002: LD_VAR 0 1
39006: PUSH
39007: LD_INT 113
39009: EQUAL
39010: IFFALSE 39016
// MC_MinesTrigger ( ) ;
39012: CALL 52380 0 0
// if event = 120 then
39016: LD_VAR 0 1
39020: PUSH
39021: LD_INT 120
39023: EQUAL
39024: IFFALSE 39030
// MC_RepairVehicle ( ) ;
39026: CALL 52479 0 0
// if event = 121 then
39030: LD_VAR 0 1
39034: PUSH
39035: LD_INT 121
39037: EQUAL
39038: IFFALSE 39044
// MC_TameApe ( ) ;
39040: CALL 53209 0 0
// if event = 122 then
39044: LD_VAR 0 1
39048: PUSH
39049: LD_INT 122
39051: EQUAL
39052: IFFALSE 39058
// MC_ChangeApeClass ( ) ;
39054: CALL 54038 0 0
// if event = 123 then
39058: LD_VAR 0 1
39062: PUSH
39063: LD_INT 123
39065: EQUAL
39066: IFFALSE 39072
// MC_Bazooka ( ) ;
39068: CALL 54688 0 0
// if event = 124 then
39072: LD_VAR 0 1
39076: PUSH
39077: LD_INT 124
39079: EQUAL
39080: IFFALSE 39086
// MC_TeleportExit ( ) ;
39082: CALL 54886 0 0
// if event = 125 then
39086: LD_VAR 0 1
39090: PUSH
39091: LD_INT 125
39093: EQUAL
39094: IFFALSE 39100
// MC_Deposits ( ) ;
39096: CALL 55533 0 0
// if event = 126 then
39100: LD_VAR 0 1
39104: PUSH
39105: LD_INT 126
39107: EQUAL
39108: IFFALSE 39114
// MC_RemoteDriver ( ) ;
39110: CALL 56158 0 0
// if event = 200 then
39114: LD_VAR 0 1
39118: PUSH
39119: LD_INT 200
39121: EQUAL
39122: IFFALSE 39128
// MC_Idle ( ) ;
39124: CALL 58107 0 0
// end ;
39128: PPOPN 1
39130: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39131: LD_INT 0
39133: PPUSH
39134: PPUSH
// if not mc_bases [ base ] or not tag then
39135: LD_EXP 110
39139: PUSH
39140: LD_VAR 0 1
39144: ARRAY
39145: NOT
39146: PUSH
39147: LD_VAR 0 2
39151: NOT
39152: OR
39153: IFFALSE 39157
// exit ;
39155: GO 39221
// for i in mc_bases [ base ] union mc_ape [ base ] do
39157: LD_ADDR_VAR 0 4
39161: PUSH
39162: LD_EXP 110
39166: PUSH
39167: LD_VAR 0 1
39171: ARRAY
39172: PUSH
39173: LD_EXP 139
39177: PUSH
39178: LD_VAR 0 1
39182: ARRAY
39183: UNION
39184: PUSH
39185: FOR_IN
39186: IFFALSE 39219
// if GetTag ( i ) = tag then
39188: LD_VAR 0 4
39192: PPUSH
39193: CALL_OW 110
39197: PUSH
39198: LD_VAR 0 2
39202: EQUAL
39203: IFFALSE 39217
// SetTag ( i , 0 ) ;
39205: LD_VAR 0 4
39209: PPUSH
39210: LD_INT 0
39212: PPUSH
39213: CALL_OW 109
39217: GO 39185
39219: POP
39220: POP
// end ;
39221: LD_VAR 0 3
39225: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39226: LD_INT 0
39228: PPUSH
39229: PPUSH
39230: PPUSH
39231: PPUSH
39232: PPUSH
39233: PPUSH
39234: PPUSH
39235: PPUSH
// if not mc_bases then
39236: LD_EXP 110
39240: NOT
39241: IFFALSE 39245
// exit ;
39243: GO 39703
// for i = 1 to mc_bases do
39245: LD_ADDR_VAR 0 2
39249: PUSH
39250: DOUBLE
39251: LD_INT 1
39253: DEC
39254: ST_TO_ADDR
39255: LD_EXP 110
39259: PUSH
39260: FOR_TO
39261: IFFALSE 39701
// begin tmp := MC_ClassCheckReq ( i ) ;
39263: LD_ADDR_VAR 0 4
39267: PUSH
39268: LD_VAR 0 2
39272: PPUSH
39273: CALL 39708 0 1
39277: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39278: LD_ADDR_EXP 151
39282: PUSH
39283: LD_EXP 151
39287: PPUSH
39288: LD_VAR 0 2
39292: PPUSH
39293: LD_VAR 0 4
39297: PPUSH
39298: CALL_OW 1
39302: ST_TO_ADDR
// if not tmp then
39303: LD_VAR 0 4
39307: NOT
39308: IFFALSE 39312
// continue ;
39310: GO 39260
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39312: LD_ADDR_VAR 0 6
39316: PUSH
39317: LD_EXP 110
39321: PUSH
39322: LD_VAR 0 2
39326: ARRAY
39327: PPUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 30
39333: PUSH
39334: LD_INT 4
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 30
39343: PUSH
39344: LD_INT 5
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: LIST
39355: PPUSH
39356: CALL_OW 72
39360: PUSH
39361: LD_EXP 110
39365: PUSH
39366: LD_VAR 0 2
39370: ARRAY
39371: PPUSH
39372: LD_INT 2
39374: PUSH
39375: LD_INT 30
39377: PUSH
39378: LD_INT 0
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 30
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: LIST
39399: PPUSH
39400: CALL_OW 72
39404: PUSH
39405: LD_EXP 110
39409: PUSH
39410: LD_VAR 0 2
39414: ARRAY
39415: PPUSH
39416: LD_INT 30
39418: PUSH
39419: LD_INT 3
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PPUSH
39426: CALL_OW 72
39430: PUSH
39431: LD_EXP 110
39435: PUSH
39436: LD_VAR 0 2
39440: ARRAY
39441: PPUSH
39442: LD_INT 2
39444: PUSH
39445: LD_INT 30
39447: PUSH
39448: LD_INT 6
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 30
39457: PUSH
39458: LD_INT 7
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: LD_INT 30
39467: PUSH
39468: LD_INT 8
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: PPUSH
39481: CALL_OW 72
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: ST_TO_ADDR
// for j = 1 to 4 do
39492: LD_ADDR_VAR 0 3
39496: PUSH
39497: DOUBLE
39498: LD_INT 1
39500: DEC
39501: ST_TO_ADDR
39502: LD_INT 4
39504: PUSH
39505: FOR_TO
39506: IFFALSE 39697
// begin if not tmp [ j ] then
39508: LD_VAR 0 4
39512: PUSH
39513: LD_VAR 0 3
39517: ARRAY
39518: NOT
39519: IFFALSE 39523
// continue ;
39521: GO 39505
// for p in tmp [ j ] do
39523: LD_ADDR_VAR 0 5
39527: PUSH
39528: LD_VAR 0 4
39532: PUSH
39533: LD_VAR 0 3
39537: ARRAY
39538: PUSH
39539: FOR_IN
39540: IFFALSE 39693
// begin if not b [ j ] then
39542: LD_VAR 0 6
39546: PUSH
39547: LD_VAR 0 3
39551: ARRAY
39552: NOT
39553: IFFALSE 39557
// break ;
39555: GO 39693
// e := 0 ;
39557: LD_ADDR_VAR 0 7
39561: PUSH
39562: LD_INT 0
39564: ST_TO_ADDR
// for k in b [ j ] do
39565: LD_ADDR_VAR 0 8
39569: PUSH
39570: LD_VAR 0 6
39574: PUSH
39575: LD_VAR 0 3
39579: ARRAY
39580: PUSH
39581: FOR_IN
39582: IFFALSE 39609
// if IsNotFull ( k ) then
39584: LD_VAR 0 8
39588: PPUSH
39589: CALL 67288 0 1
39593: IFFALSE 39607
// begin e := k ;
39595: LD_ADDR_VAR 0 7
39599: PUSH
39600: LD_VAR 0 8
39604: ST_TO_ADDR
// break ;
39605: GO 39609
// end ;
39607: GO 39581
39609: POP
39610: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39611: LD_VAR 0 7
39615: PUSH
39616: LD_VAR 0 5
39620: PPUSH
39621: LD_VAR 0 7
39625: PPUSH
39626: CALL 99708 0 2
39630: NOT
39631: AND
39632: IFFALSE 39691
// begin if IsInUnit ( p ) then
39634: LD_VAR 0 5
39638: PPUSH
39639: CALL_OW 310
39643: IFFALSE 39654
// ComExitBuilding ( p ) ;
39645: LD_VAR 0 5
39649: PPUSH
39650: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39654: LD_VAR 0 5
39658: PPUSH
39659: LD_VAR 0 7
39663: PPUSH
39664: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39668: LD_VAR 0 5
39672: PPUSH
39673: LD_VAR 0 3
39677: PPUSH
39678: CALL_OW 183
// AddComExitBuilding ( p ) ;
39682: LD_VAR 0 5
39686: PPUSH
39687: CALL_OW 182
// end ; end ;
39691: GO 39539
39693: POP
39694: POP
// end ;
39695: GO 39505
39697: POP
39698: POP
// end ;
39699: GO 39260
39701: POP
39702: POP
// end ;
39703: LD_VAR 0 1
39707: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39708: LD_INT 0
39710: PPUSH
39711: PPUSH
39712: PPUSH
39713: PPUSH
39714: PPUSH
39715: PPUSH
39716: PPUSH
39717: PPUSH
39718: PPUSH
39719: PPUSH
39720: PPUSH
39721: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39722: LD_VAR 0 1
39726: NOT
39727: PUSH
39728: LD_EXP 110
39732: PUSH
39733: LD_VAR 0 1
39737: ARRAY
39738: NOT
39739: OR
39740: PUSH
39741: LD_EXP 110
39745: PUSH
39746: LD_VAR 0 1
39750: ARRAY
39751: PPUSH
39752: LD_INT 2
39754: PUSH
39755: LD_INT 30
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 30
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: LIST
39779: PPUSH
39780: CALL_OW 72
39784: NOT
39785: OR
39786: IFFALSE 39790
// exit ;
39788: GO 43293
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39790: LD_ADDR_VAR 0 4
39794: PUSH
39795: LD_EXP 110
39799: PUSH
39800: LD_VAR 0 1
39804: ARRAY
39805: PPUSH
39806: LD_INT 2
39808: PUSH
39809: LD_INT 25
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 25
39821: PUSH
39822: LD_INT 2
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 25
39831: PUSH
39832: LD_INT 3
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 25
39841: PUSH
39842: LD_INT 4
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 25
39851: PUSH
39852: LD_INT 5
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 25
39861: PUSH
39862: LD_INT 8
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: LD_INT 25
39871: PUSH
39872: LD_INT 9
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: PPUSH
39889: CALL_OW 72
39893: ST_TO_ADDR
// if not tmp then
39894: LD_VAR 0 4
39898: NOT
39899: IFFALSE 39903
// exit ;
39901: GO 43293
// for i in tmp do
39903: LD_ADDR_VAR 0 3
39907: PUSH
39908: LD_VAR 0 4
39912: PUSH
39913: FOR_IN
39914: IFFALSE 39945
// if GetTag ( i ) then
39916: LD_VAR 0 3
39920: PPUSH
39921: CALL_OW 110
39925: IFFALSE 39943
// tmp := tmp diff i ;
39927: LD_ADDR_VAR 0 4
39931: PUSH
39932: LD_VAR 0 4
39936: PUSH
39937: LD_VAR 0 3
39941: DIFF
39942: ST_TO_ADDR
39943: GO 39913
39945: POP
39946: POP
// if not tmp then
39947: LD_VAR 0 4
39951: NOT
39952: IFFALSE 39956
// exit ;
39954: GO 43293
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39956: LD_ADDR_VAR 0 5
39960: PUSH
39961: LD_EXP 110
39965: PUSH
39966: LD_VAR 0 1
39970: ARRAY
39971: PPUSH
39972: LD_INT 2
39974: PUSH
39975: LD_INT 25
39977: PUSH
39978: LD_INT 1
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 25
39987: PUSH
39988: LD_INT 5
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 25
39997: PUSH
39998: LD_INT 8
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 25
40007: PUSH
40008: LD_INT 9
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: PPUSH
40022: CALL_OW 72
40026: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40027: LD_ADDR_VAR 0 6
40031: PUSH
40032: LD_EXP 110
40036: PUSH
40037: LD_VAR 0 1
40041: ARRAY
40042: PPUSH
40043: LD_INT 25
40045: PUSH
40046: LD_INT 2
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PPUSH
40053: CALL_OW 72
40057: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40058: LD_ADDR_VAR 0 7
40062: PUSH
40063: LD_EXP 110
40067: PUSH
40068: LD_VAR 0 1
40072: ARRAY
40073: PPUSH
40074: LD_INT 25
40076: PUSH
40077: LD_INT 3
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PPUSH
40084: CALL_OW 72
40088: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40089: LD_ADDR_VAR 0 8
40093: PUSH
40094: LD_EXP 110
40098: PUSH
40099: LD_VAR 0 1
40103: ARRAY
40104: PPUSH
40105: LD_INT 25
40107: PUSH
40108: LD_INT 4
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: LD_INT 24
40117: PUSH
40118: LD_INT 251
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PPUSH
40129: CALL_OW 72
40133: ST_TO_ADDR
// if mc_scan [ base ] then
40134: LD_EXP 133
40138: PUSH
40139: LD_VAR 0 1
40143: ARRAY
40144: IFFALSE 40605
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40146: LD_ADDR_EXP 152
40150: PUSH
40151: LD_EXP 152
40155: PPUSH
40156: LD_VAR 0 1
40160: PPUSH
40161: LD_INT 4
40163: PPUSH
40164: CALL_OW 1
40168: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40169: LD_ADDR_VAR 0 12
40173: PUSH
40174: LD_EXP 110
40178: PUSH
40179: LD_VAR 0 1
40183: ARRAY
40184: PPUSH
40185: LD_INT 2
40187: PUSH
40188: LD_INT 30
40190: PUSH
40191: LD_INT 4
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 30
40200: PUSH
40201: LD_INT 5
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: LIST
40212: PPUSH
40213: CALL_OW 72
40217: ST_TO_ADDR
// if not b then
40218: LD_VAR 0 12
40222: NOT
40223: IFFALSE 40227
// exit ;
40225: GO 43293
// p := [ ] ;
40227: LD_ADDR_VAR 0 11
40231: PUSH
40232: EMPTY
40233: ST_TO_ADDR
// if sci >= 2 then
40234: LD_VAR 0 8
40238: PUSH
40239: LD_INT 2
40241: GREATEREQUAL
40242: IFFALSE 40273
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40244: LD_ADDR_VAR 0 8
40248: PUSH
40249: LD_VAR 0 8
40253: PUSH
40254: LD_INT 1
40256: ARRAY
40257: PUSH
40258: LD_VAR 0 8
40262: PUSH
40263: LD_INT 2
40265: ARRAY
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: ST_TO_ADDR
40271: GO 40334
// if sci = 1 then
40273: LD_VAR 0 8
40277: PUSH
40278: LD_INT 1
40280: EQUAL
40281: IFFALSE 40302
// sci := [ sci [ 1 ] ] else
40283: LD_ADDR_VAR 0 8
40287: PUSH
40288: LD_VAR 0 8
40292: PUSH
40293: LD_INT 1
40295: ARRAY
40296: PUSH
40297: EMPTY
40298: LIST
40299: ST_TO_ADDR
40300: GO 40334
// if sci = 0 then
40302: LD_VAR 0 8
40306: PUSH
40307: LD_INT 0
40309: EQUAL
40310: IFFALSE 40334
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40312: LD_ADDR_VAR 0 11
40316: PUSH
40317: LD_VAR 0 4
40321: PPUSH
40322: LD_INT 4
40324: PPUSH
40325: CALL 99571 0 2
40329: PUSH
40330: LD_INT 1
40332: ARRAY
40333: ST_TO_ADDR
// if eng > 4 then
40334: LD_VAR 0 6
40338: PUSH
40339: LD_INT 4
40341: GREATER
40342: IFFALSE 40388
// for i = eng downto 4 do
40344: LD_ADDR_VAR 0 3
40348: PUSH
40349: DOUBLE
40350: LD_VAR 0 6
40354: INC
40355: ST_TO_ADDR
40356: LD_INT 4
40358: PUSH
40359: FOR_DOWNTO
40360: IFFALSE 40386
// eng := eng diff eng [ i ] ;
40362: LD_ADDR_VAR 0 6
40366: PUSH
40367: LD_VAR 0 6
40371: PUSH
40372: LD_VAR 0 6
40376: PUSH
40377: LD_VAR 0 3
40381: ARRAY
40382: DIFF
40383: ST_TO_ADDR
40384: GO 40359
40386: POP
40387: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40388: LD_ADDR_VAR 0 4
40392: PUSH
40393: LD_VAR 0 4
40397: PUSH
40398: LD_VAR 0 5
40402: PUSH
40403: LD_VAR 0 6
40407: UNION
40408: PUSH
40409: LD_VAR 0 7
40413: UNION
40414: PUSH
40415: LD_VAR 0 8
40419: UNION
40420: DIFF
40421: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40422: LD_ADDR_VAR 0 13
40426: PUSH
40427: LD_EXP 110
40431: PUSH
40432: LD_VAR 0 1
40436: ARRAY
40437: PPUSH
40438: LD_INT 2
40440: PUSH
40441: LD_INT 30
40443: PUSH
40444: LD_INT 32
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 30
40453: PUSH
40454: LD_INT 31
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: LIST
40465: PPUSH
40466: CALL_OW 72
40470: PUSH
40471: LD_EXP 110
40475: PUSH
40476: LD_VAR 0 1
40480: ARRAY
40481: PPUSH
40482: LD_INT 2
40484: PUSH
40485: LD_INT 30
40487: PUSH
40488: LD_INT 4
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 30
40497: PUSH
40498: LD_INT 5
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: LIST
40509: PPUSH
40510: CALL_OW 72
40514: PUSH
40515: LD_INT 6
40517: MUL
40518: PLUS
40519: ST_TO_ADDR
// if bcount < tmp then
40520: LD_VAR 0 13
40524: PUSH
40525: LD_VAR 0 4
40529: LESS
40530: IFFALSE 40576
// for i = tmp downto bcount do
40532: LD_ADDR_VAR 0 3
40536: PUSH
40537: DOUBLE
40538: LD_VAR 0 4
40542: INC
40543: ST_TO_ADDR
40544: LD_VAR 0 13
40548: PUSH
40549: FOR_DOWNTO
40550: IFFALSE 40574
// tmp := Delete ( tmp , tmp ) ;
40552: LD_ADDR_VAR 0 4
40556: PUSH
40557: LD_VAR 0 4
40561: PPUSH
40562: LD_VAR 0 4
40566: PPUSH
40567: CALL_OW 3
40571: ST_TO_ADDR
40572: GO 40549
40574: POP
40575: POP
// result := [ tmp , 0 , 0 , p ] ;
40576: LD_ADDR_VAR 0 2
40580: PUSH
40581: LD_VAR 0 4
40585: PUSH
40586: LD_INT 0
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_VAR 0 11
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: ST_TO_ADDR
// exit ;
40603: GO 43293
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40605: LD_EXP 110
40609: PUSH
40610: LD_VAR 0 1
40614: ARRAY
40615: PPUSH
40616: LD_INT 2
40618: PUSH
40619: LD_INT 30
40621: PUSH
40622: LD_INT 6
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 30
40631: PUSH
40632: LD_INT 7
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 30
40641: PUSH
40642: LD_INT 8
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: PPUSH
40655: CALL_OW 72
40659: NOT
40660: PUSH
40661: LD_EXP 110
40665: PUSH
40666: LD_VAR 0 1
40670: ARRAY
40671: PPUSH
40672: LD_INT 30
40674: PUSH
40675: LD_INT 3
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PPUSH
40682: CALL_OW 72
40686: NOT
40687: AND
40688: IFFALSE 40760
// begin if eng = tmp then
40690: LD_VAR 0 6
40694: PUSH
40695: LD_VAR 0 4
40699: EQUAL
40700: IFFALSE 40704
// exit ;
40702: GO 43293
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40704: LD_ADDR_EXP 152
40708: PUSH
40709: LD_EXP 152
40713: PPUSH
40714: LD_VAR 0 1
40718: PPUSH
40719: LD_INT 1
40721: PPUSH
40722: CALL_OW 1
40726: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40727: LD_ADDR_VAR 0 2
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: LD_VAR 0 4
40739: PUSH
40740: LD_VAR 0 6
40744: DIFF
40745: PUSH
40746: LD_INT 0
40748: PUSH
40749: LD_INT 0
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// exit ;
40758: GO 43293
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40760: LD_EXP 137
40764: PUSH
40765: LD_EXP 136
40769: PUSH
40770: LD_VAR 0 1
40774: ARRAY
40775: ARRAY
40776: PUSH
40777: LD_EXP 110
40781: PUSH
40782: LD_VAR 0 1
40786: ARRAY
40787: PPUSH
40788: LD_INT 2
40790: PUSH
40791: LD_INT 30
40793: PUSH
40794: LD_INT 6
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 30
40803: PUSH
40804: LD_INT 7
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 30
40813: PUSH
40814: LD_INT 8
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: LIST
40825: LIST
40826: PPUSH
40827: CALL_OW 72
40831: AND
40832: PUSH
40833: LD_EXP 110
40837: PUSH
40838: LD_VAR 0 1
40842: ARRAY
40843: PPUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 3
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PPUSH
40854: CALL_OW 72
40858: NOT
40859: AND
40860: IFFALSE 41074
// begin if sci >= 6 then
40862: LD_VAR 0 8
40866: PUSH
40867: LD_INT 6
40869: GREATEREQUAL
40870: IFFALSE 40874
// exit ;
40872: GO 43293
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40874: LD_ADDR_EXP 152
40878: PUSH
40879: LD_EXP 152
40883: PPUSH
40884: LD_VAR 0 1
40888: PPUSH
40889: LD_INT 2
40891: PPUSH
40892: CALL_OW 1
40896: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40897: LD_ADDR_VAR 0 9
40901: PUSH
40902: LD_VAR 0 4
40906: PUSH
40907: LD_VAR 0 8
40911: DIFF
40912: PPUSH
40913: LD_INT 4
40915: PPUSH
40916: CALL 99571 0 2
40920: ST_TO_ADDR
// p := [ ] ;
40921: LD_ADDR_VAR 0 11
40925: PUSH
40926: EMPTY
40927: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40928: LD_VAR 0 8
40932: PUSH
40933: LD_INT 6
40935: LESS
40936: PUSH
40937: LD_VAR 0 9
40941: PUSH
40942: LD_INT 6
40944: GREATER
40945: AND
40946: IFFALSE 41027
// begin for i = 1 to 6 - sci do
40948: LD_ADDR_VAR 0 3
40952: PUSH
40953: DOUBLE
40954: LD_INT 1
40956: DEC
40957: ST_TO_ADDR
40958: LD_INT 6
40960: PUSH
40961: LD_VAR 0 8
40965: MINUS
40966: PUSH
40967: FOR_TO
40968: IFFALSE 41023
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40970: LD_ADDR_VAR 0 11
40974: PUSH
40975: LD_VAR 0 11
40979: PPUSH
40980: LD_VAR 0 11
40984: PUSH
40985: LD_INT 1
40987: PLUS
40988: PPUSH
40989: LD_VAR 0 9
40993: PUSH
40994: LD_INT 1
40996: ARRAY
40997: PPUSH
40998: CALL_OW 2
41002: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41003: LD_ADDR_VAR 0 9
41007: PUSH
41008: LD_VAR 0 9
41012: PPUSH
41013: LD_INT 1
41015: PPUSH
41016: CALL_OW 3
41020: ST_TO_ADDR
// end ;
41021: GO 40967
41023: POP
41024: POP
// end else
41025: GO 41047
// if sort then
41027: LD_VAR 0 9
41031: IFFALSE 41047
// p := sort [ 1 ] ;
41033: LD_ADDR_VAR 0 11
41037: PUSH
41038: LD_VAR 0 9
41042: PUSH
41043: LD_INT 1
41045: ARRAY
41046: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41047: LD_ADDR_VAR 0 2
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: LD_INT 0
41057: PUSH
41058: LD_INT 0
41060: PUSH
41061: LD_VAR 0 11
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: ST_TO_ADDR
// exit ;
41072: GO 43293
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41074: LD_EXP 137
41078: PUSH
41079: LD_EXP 136
41083: PUSH
41084: LD_VAR 0 1
41088: ARRAY
41089: ARRAY
41090: PUSH
41091: LD_EXP 110
41095: PUSH
41096: LD_VAR 0 1
41100: ARRAY
41101: PPUSH
41102: LD_INT 2
41104: PUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 6
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 30
41117: PUSH
41118: LD_INT 7
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 30
41127: PUSH
41128: LD_INT 8
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: PPUSH
41141: CALL_OW 72
41145: AND
41146: PUSH
41147: LD_EXP 110
41151: PUSH
41152: LD_VAR 0 1
41156: ARRAY
41157: PPUSH
41158: LD_INT 30
41160: PUSH
41161: LD_INT 3
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PPUSH
41168: CALL_OW 72
41172: AND
41173: IFFALSE 41907
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41175: LD_ADDR_EXP 152
41179: PUSH
41180: LD_EXP 152
41184: PPUSH
41185: LD_VAR 0 1
41189: PPUSH
41190: LD_INT 3
41192: PPUSH
41193: CALL_OW 1
41197: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41198: LD_ADDR_VAR 0 2
41202: PUSH
41203: LD_INT 0
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: ST_TO_ADDR
// if not eng then
41221: LD_VAR 0 6
41225: NOT
41226: IFFALSE 41289
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41228: LD_ADDR_VAR 0 11
41232: PUSH
41233: LD_VAR 0 4
41237: PPUSH
41238: LD_INT 2
41240: PPUSH
41241: CALL 99571 0 2
41245: PUSH
41246: LD_INT 1
41248: ARRAY
41249: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41250: LD_ADDR_VAR 0 2
41254: PUSH
41255: LD_VAR 0 2
41259: PPUSH
41260: LD_INT 2
41262: PPUSH
41263: LD_VAR 0 11
41267: PPUSH
41268: CALL_OW 1
41272: ST_TO_ADDR
// tmp := tmp diff p ;
41273: LD_ADDR_VAR 0 4
41277: PUSH
41278: LD_VAR 0 4
41282: PUSH
41283: LD_VAR 0 11
41287: DIFF
41288: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41289: LD_VAR 0 4
41293: PUSH
41294: LD_VAR 0 8
41298: PUSH
41299: LD_INT 6
41301: LESS
41302: AND
41303: IFFALSE 41491
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41305: LD_ADDR_VAR 0 9
41309: PUSH
41310: LD_VAR 0 4
41314: PUSH
41315: LD_VAR 0 8
41319: PUSH
41320: LD_VAR 0 7
41324: UNION
41325: DIFF
41326: PPUSH
41327: LD_INT 4
41329: PPUSH
41330: CALL 99571 0 2
41334: ST_TO_ADDR
// p := [ ] ;
41335: LD_ADDR_VAR 0 11
41339: PUSH
41340: EMPTY
41341: ST_TO_ADDR
// if sort then
41342: LD_VAR 0 9
41346: IFFALSE 41462
// for i = 1 to 6 - sci do
41348: LD_ADDR_VAR 0 3
41352: PUSH
41353: DOUBLE
41354: LD_INT 1
41356: DEC
41357: ST_TO_ADDR
41358: LD_INT 6
41360: PUSH
41361: LD_VAR 0 8
41365: MINUS
41366: PUSH
41367: FOR_TO
41368: IFFALSE 41460
// begin if i = sort then
41370: LD_VAR 0 3
41374: PUSH
41375: LD_VAR 0 9
41379: EQUAL
41380: IFFALSE 41384
// break ;
41382: GO 41460
// if GetClass ( i ) = 4 then
41384: LD_VAR 0 3
41388: PPUSH
41389: CALL_OW 257
41393: PUSH
41394: LD_INT 4
41396: EQUAL
41397: IFFALSE 41401
// continue ;
41399: GO 41367
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41401: LD_ADDR_VAR 0 11
41405: PUSH
41406: LD_VAR 0 11
41410: PPUSH
41411: LD_VAR 0 11
41415: PUSH
41416: LD_INT 1
41418: PLUS
41419: PPUSH
41420: LD_VAR 0 9
41424: PUSH
41425: LD_VAR 0 3
41429: ARRAY
41430: PPUSH
41431: CALL_OW 2
41435: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41436: LD_ADDR_VAR 0 4
41440: PUSH
41441: LD_VAR 0 4
41445: PUSH
41446: LD_VAR 0 9
41450: PUSH
41451: LD_VAR 0 3
41455: ARRAY
41456: DIFF
41457: ST_TO_ADDR
// end ;
41458: GO 41367
41460: POP
41461: POP
// if p then
41462: LD_VAR 0 11
41466: IFFALSE 41491
// result := Replace ( result , 4 , p ) ;
41468: LD_ADDR_VAR 0 2
41472: PUSH
41473: LD_VAR 0 2
41477: PPUSH
41478: LD_INT 4
41480: PPUSH
41481: LD_VAR 0 11
41485: PPUSH
41486: CALL_OW 1
41490: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41491: LD_VAR 0 4
41495: PUSH
41496: LD_VAR 0 7
41500: PUSH
41501: LD_INT 6
41503: LESS
41504: AND
41505: IFFALSE 41693
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41507: LD_ADDR_VAR 0 9
41511: PUSH
41512: LD_VAR 0 4
41516: PUSH
41517: LD_VAR 0 8
41521: PUSH
41522: LD_VAR 0 7
41526: UNION
41527: DIFF
41528: PPUSH
41529: LD_INT 3
41531: PPUSH
41532: CALL 99571 0 2
41536: ST_TO_ADDR
// p := [ ] ;
41537: LD_ADDR_VAR 0 11
41541: PUSH
41542: EMPTY
41543: ST_TO_ADDR
// if sort then
41544: LD_VAR 0 9
41548: IFFALSE 41664
// for i = 1 to 6 - mech do
41550: LD_ADDR_VAR 0 3
41554: PUSH
41555: DOUBLE
41556: LD_INT 1
41558: DEC
41559: ST_TO_ADDR
41560: LD_INT 6
41562: PUSH
41563: LD_VAR 0 7
41567: MINUS
41568: PUSH
41569: FOR_TO
41570: IFFALSE 41662
// begin if i = sort then
41572: LD_VAR 0 3
41576: PUSH
41577: LD_VAR 0 9
41581: EQUAL
41582: IFFALSE 41586
// break ;
41584: GO 41662
// if GetClass ( i ) = 3 then
41586: LD_VAR 0 3
41590: PPUSH
41591: CALL_OW 257
41595: PUSH
41596: LD_INT 3
41598: EQUAL
41599: IFFALSE 41603
// continue ;
41601: GO 41569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41603: LD_ADDR_VAR 0 11
41607: PUSH
41608: LD_VAR 0 11
41612: PPUSH
41613: LD_VAR 0 11
41617: PUSH
41618: LD_INT 1
41620: PLUS
41621: PPUSH
41622: LD_VAR 0 9
41626: PUSH
41627: LD_VAR 0 3
41631: ARRAY
41632: PPUSH
41633: CALL_OW 2
41637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41638: LD_ADDR_VAR 0 4
41642: PUSH
41643: LD_VAR 0 4
41647: PUSH
41648: LD_VAR 0 9
41652: PUSH
41653: LD_VAR 0 3
41657: ARRAY
41658: DIFF
41659: ST_TO_ADDR
// end ;
41660: GO 41569
41662: POP
41663: POP
// if p then
41664: LD_VAR 0 11
41668: IFFALSE 41693
// result := Replace ( result , 3 , p ) ;
41670: LD_ADDR_VAR 0 2
41674: PUSH
41675: LD_VAR 0 2
41679: PPUSH
41680: LD_INT 3
41682: PPUSH
41683: LD_VAR 0 11
41687: PPUSH
41688: CALL_OW 1
41692: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41693: LD_VAR 0 4
41697: PUSH
41698: LD_INT 6
41700: GREATER
41701: PUSH
41702: LD_VAR 0 6
41706: PUSH
41707: LD_INT 6
41709: LESS
41710: AND
41711: IFFALSE 41905
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41713: LD_ADDR_VAR 0 9
41717: PUSH
41718: LD_VAR 0 4
41722: PUSH
41723: LD_VAR 0 8
41727: PUSH
41728: LD_VAR 0 7
41732: UNION
41733: PUSH
41734: LD_VAR 0 6
41738: UNION
41739: DIFF
41740: PPUSH
41741: LD_INT 2
41743: PPUSH
41744: CALL 99571 0 2
41748: ST_TO_ADDR
// p := [ ] ;
41749: LD_ADDR_VAR 0 11
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// if sort then
41756: LD_VAR 0 9
41760: IFFALSE 41876
// for i = 1 to 6 - eng do
41762: LD_ADDR_VAR 0 3
41766: PUSH
41767: DOUBLE
41768: LD_INT 1
41770: DEC
41771: ST_TO_ADDR
41772: LD_INT 6
41774: PUSH
41775: LD_VAR 0 6
41779: MINUS
41780: PUSH
41781: FOR_TO
41782: IFFALSE 41874
// begin if i = sort then
41784: LD_VAR 0 3
41788: PUSH
41789: LD_VAR 0 9
41793: EQUAL
41794: IFFALSE 41798
// break ;
41796: GO 41874
// if GetClass ( i ) = 2 then
41798: LD_VAR 0 3
41802: PPUSH
41803: CALL_OW 257
41807: PUSH
41808: LD_INT 2
41810: EQUAL
41811: IFFALSE 41815
// continue ;
41813: GO 41781
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41815: LD_ADDR_VAR 0 11
41819: PUSH
41820: LD_VAR 0 11
41824: PPUSH
41825: LD_VAR 0 11
41829: PUSH
41830: LD_INT 1
41832: PLUS
41833: PPUSH
41834: LD_VAR 0 9
41838: PUSH
41839: LD_VAR 0 3
41843: ARRAY
41844: PPUSH
41845: CALL_OW 2
41849: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41850: LD_ADDR_VAR 0 4
41854: PUSH
41855: LD_VAR 0 4
41859: PUSH
41860: LD_VAR 0 9
41864: PUSH
41865: LD_VAR 0 3
41869: ARRAY
41870: DIFF
41871: ST_TO_ADDR
// end ;
41872: GO 41781
41874: POP
41875: POP
// if p then
41876: LD_VAR 0 11
41880: IFFALSE 41905
// result := Replace ( result , 2 , p ) ;
41882: LD_ADDR_VAR 0 2
41886: PUSH
41887: LD_VAR 0 2
41891: PPUSH
41892: LD_INT 2
41894: PPUSH
41895: LD_VAR 0 11
41899: PPUSH
41900: CALL_OW 1
41904: ST_TO_ADDR
// end ; exit ;
41905: GO 43293
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41907: LD_EXP 137
41911: PUSH
41912: LD_EXP 136
41916: PUSH
41917: LD_VAR 0 1
41921: ARRAY
41922: ARRAY
41923: NOT
41924: PUSH
41925: LD_EXP 110
41929: PUSH
41930: LD_VAR 0 1
41934: ARRAY
41935: PPUSH
41936: LD_INT 30
41938: PUSH
41939: LD_INT 3
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PPUSH
41946: CALL_OW 72
41950: AND
41951: PUSH
41952: LD_EXP 115
41956: PUSH
41957: LD_VAR 0 1
41961: ARRAY
41962: AND
41963: IFFALSE 42571
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41965: LD_ADDR_EXP 152
41969: PUSH
41970: LD_EXP 152
41974: PPUSH
41975: LD_VAR 0 1
41979: PPUSH
41980: LD_INT 5
41982: PPUSH
41983: CALL_OW 1
41987: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41988: LD_ADDR_VAR 0 2
41992: PUSH
41993: LD_INT 0
41995: PUSH
41996: LD_INT 0
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: LD_INT 0
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: LIST
42009: LIST
42010: ST_TO_ADDR
// if sci > 1 then
42011: LD_VAR 0 8
42015: PUSH
42016: LD_INT 1
42018: GREATER
42019: IFFALSE 42047
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42021: LD_ADDR_VAR 0 4
42025: PUSH
42026: LD_VAR 0 4
42030: PUSH
42031: LD_VAR 0 8
42035: PUSH
42036: LD_VAR 0 8
42040: PUSH
42041: LD_INT 1
42043: ARRAY
42044: DIFF
42045: DIFF
42046: ST_TO_ADDR
// if tmp and not sci then
42047: LD_VAR 0 4
42051: PUSH
42052: LD_VAR 0 8
42056: NOT
42057: AND
42058: IFFALSE 42127
// begin sort := SortBySkill ( tmp , 4 ) ;
42060: LD_ADDR_VAR 0 9
42064: PUSH
42065: LD_VAR 0 4
42069: PPUSH
42070: LD_INT 4
42072: PPUSH
42073: CALL 99571 0 2
42077: ST_TO_ADDR
// if sort then
42078: LD_VAR 0 9
42082: IFFALSE 42098
// p := sort [ 1 ] ;
42084: LD_ADDR_VAR 0 11
42088: PUSH
42089: LD_VAR 0 9
42093: PUSH
42094: LD_INT 1
42096: ARRAY
42097: ST_TO_ADDR
// if p then
42098: LD_VAR 0 11
42102: IFFALSE 42127
// result := Replace ( result , 4 , p ) ;
42104: LD_ADDR_VAR 0 2
42108: PUSH
42109: LD_VAR 0 2
42113: PPUSH
42114: LD_INT 4
42116: PPUSH
42117: LD_VAR 0 11
42121: PPUSH
42122: CALL_OW 1
42126: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42127: LD_ADDR_VAR 0 4
42131: PUSH
42132: LD_VAR 0 4
42136: PUSH
42137: LD_VAR 0 7
42141: DIFF
42142: ST_TO_ADDR
// if tmp and mech < 6 then
42143: LD_VAR 0 4
42147: PUSH
42148: LD_VAR 0 7
42152: PUSH
42153: LD_INT 6
42155: LESS
42156: AND
42157: IFFALSE 42345
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42159: LD_ADDR_VAR 0 9
42163: PUSH
42164: LD_VAR 0 4
42168: PUSH
42169: LD_VAR 0 8
42173: PUSH
42174: LD_VAR 0 7
42178: UNION
42179: DIFF
42180: PPUSH
42181: LD_INT 3
42183: PPUSH
42184: CALL 99571 0 2
42188: ST_TO_ADDR
// p := [ ] ;
42189: LD_ADDR_VAR 0 11
42193: PUSH
42194: EMPTY
42195: ST_TO_ADDR
// if sort then
42196: LD_VAR 0 9
42200: IFFALSE 42316
// for i = 1 to 6 - mech do
42202: LD_ADDR_VAR 0 3
42206: PUSH
42207: DOUBLE
42208: LD_INT 1
42210: DEC
42211: ST_TO_ADDR
42212: LD_INT 6
42214: PUSH
42215: LD_VAR 0 7
42219: MINUS
42220: PUSH
42221: FOR_TO
42222: IFFALSE 42314
// begin if i = sort then
42224: LD_VAR 0 3
42228: PUSH
42229: LD_VAR 0 9
42233: EQUAL
42234: IFFALSE 42238
// break ;
42236: GO 42314
// if GetClass ( i ) = 3 then
42238: LD_VAR 0 3
42242: PPUSH
42243: CALL_OW 257
42247: PUSH
42248: LD_INT 3
42250: EQUAL
42251: IFFALSE 42255
// continue ;
42253: GO 42221
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42255: LD_ADDR_VAR 0 11
42259: PUSH
42260: LD_VAR 0 11
42264: PPUSH
42265: LD_VAR 0 11
42269: PUSH
42270: LD_INT 1
42272: PLUS
42273: PPUSH
42274: LD_VAR 0 9
42278: PUSH
42279: LD_VAR 0 3
42283: ARRAY
42284: PPUSH
42285: CALL_OW 2
42289: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42290: LD_ADDR_VAR 0 4
42294: PUSH
42295: LD_VAR 0 4
42299: PUSH
42300: LD_VAR 0 9
42304: PUSH
42305: LD_VAR 0 3
42309: ARRAY
42310: DIFF
42311: ST_TO_ADDR
// end ;
42312: GO 42221
42314: POP
42315: POP
// if p then
42316: LD_VAR 0 11
42320: IFFALSE 42345
// result := Replace ( result , 3 , p ) ;
42322: LD_ADDR_VAR 0 2
42326: PUSH
42327: LD_VAR 0 2
42331: PPUSH
42332: LD_INT 3
42334: PPUSH
42335: LD_VAR 0 11
42339: PPUSH
42340: CALL_OW 1
42344: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42345: LD_ADDR_VAR 0 4
42349: PUSH
42350: LD_VAR 0 4
42354: PUSH
42355: LD_VAR 0 6
42359: DIFF
42360: ST_TO_ADDR
// if tmp and eng < 6 then
42361: LD_VAR 0 4
42365: PUSH
42366: LD_VAR 0 6
42370: PUSH
42371: LD_INT 6
42373: LESS
42374: AND
42375: IFFALSE 42569
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42377: LD_ADDR_VAR 0 9
42381: PUSH
42382: LD_VAR 0 4
42386: PUSH
42387: LD_VAR 0 8
42391: PUSH
42392: LD_VAR 0 7
42396: UNION
42397: PUSH
42398: LD_VAR 0 6
42402: UNION
42403: DIFF
42404: PPUSH
42405: LD_INT 2
42407: PPUSH
42408: CALL 99571 0 2
42412: ST_TO_ADDR
// p := [ ] ;
42413: LD_ADDR_VAR 0 11
42417: PUSH
42418: EMPTY
42419: ST_TO_ADDR
// if sort then
42420: LD_VAR 0 9
42424: IFFALSE 42540
// for i = 1 to 6 - eng do
42426: LD_ADDR_VAR 0 3
42430: PUSH
42431: DOUBLE
42432: LD_INT 1
42434: DEC
42435: ST_TO_ADDR
42436: LD_INT 6
42438: PUSH
42439: LD_VAR 0 6
42443: MINUS
42444: PUSH
42445: FOR_TO
42446: IFFALSE 42538
// begin if i = sort then
42448: LD_VAR 0 3
42452: PUSH
42453: LD_VAR 0 9
42457: EQUAL
42458: IFFALSE 42462
// break ;
42460: GO 42538
// if GetClass ( i ) = 2 then
42462: LD_VAR 0 3
42466: PPUSH
42467: CALL_OW 257
42471: PUSH
42472: LD_INT 2
42474: EQUAL
42475: IFFALSE 42479
// continue ;
42477: GO 42445
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42479: LD_ADDR_VAR 0 11
42483: PUSH
42484: LD_VAR 0 11
42488: PPUSH
42489: LD_VAR 0 11
42493: PUSH
42494: LD_INT 1
42496: PLUS
42497: PPUSH
42498: LD_VAR 0 9
42502: PUSH
42503: LD_VAR 0 3
42507: ARRAY
42508: PPUSH
42509: CALL_OW 2
42513: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42514: LD_ADDR_VAR 0 4
42518: PUSH
42519: LD_VAR 0 4
42523: PUSH
42524: LD_VAR 0 9
42528: PUSH
42529: LD_VAR 0 3
42533: ARRAY
42534: DIFF
42535: ST_TO_ADDR
// end ;
42536: GO 42445
42538: POP
42539: POP
// if p then
42540: LD_VAR 0 11
42544: IFFALSE 42569
// result := Replace ( result , 2 , p ) ;
42546: LD_ADDR_VAR 0 2
42550: PUSH
42551: LD_VAR 0 2
42555: PPUSH
42556: LD_INT 2
42558: PPUSH
42559: LD_VAR 0 11
42563: PPUSH
42564: CALL_OW 1
42568: ST_TO_ADDR
// end ; exit ;
42569: GO 43293
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42571: LD_EXP 137
42575: PUSH
42576: LD_EXP 136
42580: PUSH
42581: LD_VAR 0 1
42585: ARRAY
42586: ARRAY
42587: NOT
42588: PUSH
42589: LD_EXP 110
42593: PUSH
42594: LD_VAR 0 1
42598: ARRAY
42599: PPUSH
42600: LD_INT 30
42602: PUSH
42603: LD_INT 3
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PPUSH
42610: CALL_OW 72
42614: AND
42615: PUSH
42616: LD_EXP 115
42620: PUSH
42621: LD_VAR 0 1
42625: ARRAY
42626: NOT
42627: AND
42628: IFFALSE 43293
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42630: LD_ADDR_EXP 152
42634: PUSH
42635: LD_EXP 152
42639: PPUSH
42640: LD_VAR 0 1
42644: PPUSH
42645: LD_INT 6
42647: PPUSH
42648: CALL_OW 1
42652: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42653: LD_ADDR_VAR 0 2
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: LIST
42674: LIST
42675: ST_TO_ADDR
// if sci >= 1 then
42676: LD_VAR 0 8
42680: PUSH
42681: LD_INT 1
42683: GREATEREQUAL
42684: IFFALSE 42706
// tmp := tmp diff sci [ 1 ] ;
42686: LD_ADDR_VAR 0 4
42690: PUSH
42691: LD_VAR 0 4
42695: PUSH
42696: LD_VAR 0 8
42700: PUSH
42701: LD_INT 1
42703: ARRAY
42704: DIFF
42705: ST_TO_ADDR
// if tmp and not sci then
42706: LD_VAR 0 4
42710: PUSH
42711: LD_VAR 0 8
42715: NOT
42716: AND
42717: IFFALSE 42786
// begin sort := SortBySkill ( tmp , 4 ) ;
42719: LD_ADDR_VAR 0 9
42723: PUSH
42724: LD_VAR 0 4
42728: PPUSH
42729: LD_INT 4
42731: PPUSH
42732: CALL 99571 0 2
42736: ST_TO_ADDR
// if sort then
42737: LD_VAR 0 9
42741: IFFALSE 42757
// p := sort [ 1 ] ;
42743: LD_ADDR_VAR 0 11
42747: PUSH
42748: LD_VAR 0 9
42752: PUSH
42753: LD_INT 1
42755: ARRAY
42756: ST_TO_ADDR
// if p then
42757: LD_VAR 0 11
42761: IFFALSE 42786
// result := Replace ( result , 4 , p ) ;
42763: LD_ADDR_VAR 0 2
42767: PUSH
42768: LD_VAR 0 2
42772: PPUSH
42773: LD_INT 4
42775: PPUSH
42776: LD_VAR 0 11
42780: PPUSH
42781: CALL_OW 1
42785: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42786: LD_ADDR_VAR 0 4
42790: PUSH
42791: LD_VAR 0 4
42795: PUSH
42796: LD_VAR 0 7
42800: DIFF
42801: ST_TO_ADDR
// if tmp and mech < 6 then
42802: LD_VAR 0 4
42806: PUSH
42807: LD_VAR 0 7
42811: PUSH
42812: LD_INT 6
42814: LESS
42815: AND
42816: IFFALSE 42998
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42818: LD_ADDR_VAR 0 9
42822: PUSH
42823: LD_VAR 0 4
42827: PUSH
42828: LD_VAR 0 7
42832: DIFF
42833: PPUSH
42834: LD_INT 3
42836: PPUSH
42837: CALL 99571 0 2
42841: ST_TO_ADDR
// p := [ ] ;
42842: LD_ADDR_VAR 0 11
42846: PUSH
42847: EMPTY
42848: ST_TO_ADDR
// if sort then
42849: LD_VAR 0 9
42853: IFFALSE 42969
// for i = 1 to 6 - mech do
42855: LD_ADDR_VAR 0 3
42859: PUSH
42860: DOUBLE
42861: LD_INT 1
42863: DEC
42864: ST_TO_ADDR
42865: LD_INT 6
42867: PUSH
42868: LD_VAR 0 7
42872: MINUS
42873: PUSH
42874: FOR_TO
42875: IFFALSE 42967
// begin if i = sort then
42877: LD_VAR 0 3
42881: PUSH
42882: LD_VAR 0 9
42886: EQUAL
42887: IFFALSE 42891
// break ;
42889: GO 42967
// if GetClass ( i ) = 3 then
42891: LD_VAR 0 3
42895: PPUSH
42896: CALL_OW 257
42900: PUSH
42901: LD_INT 3
42903: EQUAL
42904: IFFALSE 42908
// continue ;
42906: GO 42874
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42908: LD_ADDR_VAR 0 11
42912: PUSH
42913: LD_VAR 0 11
42917: PPUSH
42918: LD_VAR 0 11
42922: PUSH
42923: LD_INT 1
42925: PLUS
42926: PPUSH
42927: LD_VAR 0 9
42931: PUSH
42932: LD_VAR 0 3
42936: ARRAY
42937: PPUSH
42938: CALL_OW 2
42942: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42943: LD_ADDR_VAR 0 4
42947: PUSH
42948: LD_VAR 0 4
42952: PUSH
42953: LD_VAR 0 9
42957: PUSH
42958: LD_VAR 0 3
42962: ARRAY
42963: DIFF
42964: ST_TO_ADDR
// end ;
42965: GO 42874
42967: POP
42968: POP
// if p then
42969: LD_VAR 0 11
42973: IFFALSE 42998
// result := Replace ( result , 3 , p ) ;
42975: LD_ADDR_VAR 0 2
42979: PUSH
42980: LD_VAR 0 2
42984: PPUSH
42985: LD_INT 3
42987: PPUSH
42988: LD_VAR 0 11
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42998: LD_ADDR_VAR 0 4
43002: PUSH
43003: LD_VAR 0 4
43007: PUSH
43008: LD_VAR 0 6
43012: DIFF
43013: ST_TO_ADDR
// if tmp and eng < 4 then
43014: LD_VAR 0 4
43018: PUSH
43019: LD_VAR 0 6
43023: PUSH
43024: LD_INT 4
43026: LESS
43027: AND
43028: IFFALSE 43218
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43030: LD_ADDR_VAR 0 9
43034: PUSH
43035: LD_VAR 0 4
43039: PUSH
43040: LD_VAR 0 7
43044: PUSH
43045: LD_VAR 0 6
43049: UNION
43050: DIFF
43051: PPUSH
43052: LD_INT 2
43054: PPUSH
43055: CALL 99571 0 2
43059: ST_TO_ADDR
// p := [ ] ;
43060: LD_ADDR_VAR 0 11
43064: PUSH
43065: EMPTY
43066: ST_TO_ADDR
// if sort then
43067: LD_VAR 0 9
43071: IFFALSE 43187
// for i = 1 to 4 - eng do
43073: LD_ADDR_VAR 0 3
43077: PUSH
43078: DOUBLE
43079: LD_INT 1
43081: DEC
43082: ST_TO_ADDR
43083: LD_INT 4
43085: PUSH
43086: LD_VAR 0 6
43090: MINUS
43091: PUSH
43092: FOR_TO
43093: IFFALSE 43185
// begin if i = sort then
43095: LD_VAR 0 3
43099: PUSH
43100: LD_VAR 0 9
43104: EQUAL
43105: IFFALSE 43109
// break ;
43107: GO 43185
// if GetClass ( i ) = 2 then
43109: LD_VAR 0 3
43113: PPUSH
43114: CALL_OW 257
43118: PUSH
43119: LD_INT 2
43121: EQUAL
43122: IFFALSE 43126
// continue ;
43124: GO 43092
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43126: LD_ADDR_VAR 0 11
43130: PUSH
43131: LD_VAR 0 11
43135: PPUSH
43136: LD_VAR 0 11
43140: PUSH
43141: LD_INT 1
43143: PLUS
43144: PPUSH
43145: LD_VAR 0 9
43149: PUSH
43150: LD_VAR 0 3
43154: ARRAY
43155: PPUSH
43156: CALL_OW 2
43160: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43161: LD_ADDR_VAR 0 4
43165: PUSH
43166: LD_VAR 0 4
43170: PUSH
43171: LD_VAR 0 9
43175: PUSH
43176: LD_VAR 0 3
43180: ARRAY
43181: DIFF
43182: ST_TO_ADDR
// end ;
43183: GO 43092
43185: POP
43186: POP
// if p then
43187: LD_VAR 0 11
43191: IFFALSE 43216
// result := Replace ( result , 2 , p ) ;
43193: LD_ADDR_VAR 0 2
43197: PUSH
43198: LD_VAR 0 2
43202: PPUSH
43203: LD_INT 2
43205: PPUSH
43206: LD_VAR 0 11
43210: PPUSH
43211: CALL_OW 1
43215: ST_TO_ADDR
// end else
43216: GO 43262
// for i = eng downto 5 do
43218: LD_ADDR_VAR 0 3
43222: PUSH
43223: DOUBLE
43224: LD_VAR 0 6
43228: INC
43229: ST_TO_ADDR
43230: LD_INT 5
43232: PUSH
43233: FOR_DOWNTO
43234: IFFALSE 43260
// tmp := tmp union eng [ i ] ;
43236: LD_ADDR_VAR 0 4
43240: PUSH
43241: LD_VAR 0 4
43245: PUSH
43246: LD_VAR 0 6
43250: PUSH
43251: LD_VAR 0 3
43255: ARRAY
43256: UNION
43257: ST_TO_ADDR
43258: GO 43233
43260: POP
43261: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43262: LD_ADDR_VAR 0 2
43266: PUSH
43267: LD_VAR 0 2
43271: PPUSH
43272: LD_INT 1
43274: PPUSH
43275: LD_VAR 0 4
43279: PUSH
43280: LD_VAR 0 5
43284: DIFF
43285: PPUSH
43286: CALL_OW 1
43290: ST_TO_ADDR
// exit ;
43291: GO 43293
// end ; end ;
43293: LD_VAR 0 2
43297: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43298: LD_INT 0
43300: PPUSH
43301: PPUSH
43302: PPUSH
// if not mc_bases then
43303: LD_EXP 110
43307: NOT
43308: IFFALSE 43312
// exit ;
43310: GO 43418
// for i = 1 to mc_bases do
43312: LD_ADDR_VAR 0 2
43316: PUSH
43317: DOUBLE
43318: LD_INT 1
43320: DEC
43321: ST_TO_ADDR
43322: LD_EXP 110
43326: PUSH
43327: FOR_TO
43328: IFFALSE 43409
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43330: LD_ADDR_VAR 0 3
43334: PUSH
43335: LD_EXP 110
43339: PUSH
43340: LD_VAR 0 2
43344: ARRAY
43345: PPUSH
43346: LD_INT 21
43348: PUSH
43349: LD_INT 3
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: PUSH
43356: LD_INT 3
43358: PUSH
43359: LD_INT 24
43361: PUSH
43362: LD_INT 1000
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PPUSH
43377: CALL_OW 72
43381: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43382: LD_ADDR_EXP 111
43386: PUSH
43387: LD_EXP 111
43391: PPUSH
43392: LD_VAR 0 2
43396: PPUSH
43397: LD_VAR 0 3
43401: PPUSH
43402: CALL_OW 1
43406: ST_TO_ADDR
// end ;
43407: GO 43327
43409: POP
43410: POP
// RaiseSailEvent ( 101 ) ;
43411: LD_INT 101
43413: PPUSH
43414: CALL_OW 427
// end ;
43418: LD_VAR 0 1
43422: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43423: LD_INT 0
43425: PPUSH
43426: PPUSH
43427: PPUSH
43428: PPUSH
43429: PPUSH
43430: PPUSH
43431: PPUSH
// if not mc_bases then
43432: LD_EXP 110
43436: NOT
43437: IFFALSE 43441
// exit ;
43439: GO 44003
// for i = 1 to mc_bases do
43441: LD_ADDR_VAR 0 2
43445: PUSH
43446: DOUBLE
43447: LD_INT 1
43449: DEC
43450: ST_TO_ADDR
43451: LD_EXP 110
43455: PUSH
43456: FOR_TO
43457: IFFALSE 43994
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43459: LD_ADDR_VAR 0 5
43463: PUSH
43464: LD_EXP 110
43468: PUSH
43469: LD_VAR 0 2
43473: ARRAY
43474: PUSH
43475: LD_EXP 139
43479: PUSH
43480: LD_VAR 0 2
43484: ARRAY
43485: UNION
43486: PPUSH
43487: LD_INT 21
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 1
43499: PUSH
43500: LD_INT 3
43502: PUSH
43503: LD_INT 54
43505: PUSH
43506: EMPTY
43507: LIST
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 3
43515: PUSH
43516: LD_INT 24
43518: PUSH
43519: LD_INT 800
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: LIST
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PPUSH
43539: CALL_OW 72
43543: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43544: LD_ADDR_VAR 0 6
43548: PUSH
43549: LD_EXP 110
43553: PUSH
43554: LD_VAR 0 2
43558: ARRAY
43559: PPUSH
43560: LD_INT 21
43562: PUSH
43563: LD_INT 1
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: LD_INT 1
43572: PUSH
43573: LD_INT 3
43575: PUSH
43576: LD_INT 54
43578: PUSH
43579: EMPTY
43580: LIST
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 3
43588: PUSH
43589: LD_INT 24
43591: PUSH
43592: LD_INT 250
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: LIST
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PPUSH
43612: CALL_OW 72
43616: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43617: LD_ADDR_VAR 0 7
43621: PUSH
43622: LD_VAR 0 5
43626: PUSH
43627: LD_VAR 0 6
43631: DIFF
43632: ST_TO_ADDR
// if not need_heal_1 then
43633: LD_VAR 0 6
43637: NOT
43638: IFFALSE 43671
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43640: LD_ADDR_EXP 113
43644: PUSH
43645: LD_EXP 113
43649: PPUSH
43650: LD_VAR 0 2
43654: PUSH
43655: LD_INT 1
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PPUSH
43662: EMPTY
43663: PPUSH
43664: CALL 70022 0 3
43668: ST_TO_ADDR
43669: GO 43741
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43671: LD_ADDR_EXP 113
43675: PUSH
43676: LD_EXP 113
43680: PPUSH
43681: LD_VAR 0 2
43685: PUSH
43686: LD_INT 1
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PPUSH
43693: LD_EXP 113
43697: PUSH
43698: LD_VAR 0 2
43702: ARRAY
43703: PUSH
43704: LD_INT 1
43706: ARRAY
43707: PPUSH
43708: LD_INT 3
43710: PUSH
43711: LD_INT 24
43713: PUSH
43714: LD_INT 1000
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PPUSH
43725: CALL_OW 72
43729: PUSH
43730: LD_VAR 0 6
43734: UNION
43735: PPUSH
43736: CALL 70022 0 3
43740: ST_TO_ADDR
// if not need_heal_2 then
43741: LD_VAR 0 7
43745: NOT
43746: IFFALSE 43779
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43748: LD_ADDR_EXP 113
43752: PUSH
43753: LD_EXP 113
43757: PPUSH
43758: LD_VAR 0 2
43762: PUSH
43763: LD_INT 2
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PPUSH
43770: EMPTY
43771: PPUSH
43772: CALL 70022 0 3
43776: ST_TO_ADDR
43777: GO 43811
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43779: LD_ADDR_EXP 113
43783: PUSH
43784: LD_EXP 113
43788: PPUSH
43789: LD_VAR 0 2
43793: PUSH
43794: LD_INT 2
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PPUSH
43801: LD_VAR 0 7
43805: PPUSH
43806: CALL 70022 0 3
43810: ST_TO_ADDR
// if need_heal_2 then
43811: LD_VAR 0 7
43815: IFFALSE 43976
// for j in need_heal_2 do
43817: LD_ADDR_VAR 0 3
43821: PUSH
43822: LD_VAR 0 7
43826: PUSH
43827: FOR_IN
43828: IFFALSE 43974
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43830: LD_ADDR_VAR 0 5
43834: PUSH
43835: LD_EXP 110
43839: PUSH
43840: LD_VAR 0 2
43844: ARRAY
43845: PPUSH
43846: LD_INT 2
43848: PUSH
43849: LD_INT 30
43851: PUSH
43852: LD_INT 6
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 30
43861: PUSH
43862: LD_INT 7
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 30
43871: PUSH
43872: LD_INT 8
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: LD_INT 30
43881: PUSH
43882: LD_INT 0
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 30
43891: PUSH
43892: LD_INT 1
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: PPUSH
43907: CALL_OW 72
43911: ST_TO_ADDR
// if tmp then
43912: LD_VAR 0 5
43916: IFFALSE 43972
// begin k := NearestUnitToUnit ( tmp , j ) ;
43918: LD_ADDR_VAR 0 4
43922: PUSH
43923: LD_VAR 0 5
43927: PPUSH
43928: LD_VAR 0 3
43932: PPUSH
43933: CALL_OW 74
43937: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43938: LD_VAR 0 3
43942: PPUSH
43943: LD_VAR 0 4
43947: PPUSH
43948: CALL_OW 296
43952: PUSH
43953: LD_INT 5
43955: GREATER
43956: IFFALSE 43972
// ComMoveUnit ( j , k ) ;
43958: LD_VAR 0 3
43962: PPUSH
43963: LD_VAR 0 4
43967: PPUSH
43968: CALL_OW 112
// end ; end ;
43972: GO 43827
43974: POP
43975: POP
// if not need_heal_1 and not need_heal_2 then
43976: LD_VAR 0 6
43980: NOT
43981: PUSH
43982: LD_VAR 0 7
43986: NOT
43987: AND
43988: IFFALSE 43992
// continue ;
43990: GO 43456
// end ;
43992: GO 43456
43994: POP
43995: POP
// RaiseSailEvent ( 102 ) ;
43996: LD_INT 102
43998: PPUSH
43999: CALL_OW 427
// end ;
44003: LD_VAR 0 1
44007: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
44012: PPUSH
44013: PPUSH
44014: PPUSH
44015: PPUSH
44016: PPUSH
44017: PPUSH
// if not mc_bases then
44018: LD_EXP 110
44022: NOT
44023: IFFALSE 44027
// exit ;
44025: GO 44862
// for i = 1 to mc_bases do
44027: LD_ADDR_VAR 0 2
44031: PUSH
44032: DOUBLE
44033: LD_INT 1
44035: DEC
44036: ST_TO_ADDR
44037: LD_EXP 110
44041: PUSH
44042: FOR_TO
44043: IFFALSE 44860
// begin if not mc_building_need_repair [ i ] then
44045: LD_EXP 111
44049: PUSH
44050: LD_VAR 0 2
44054: ARRAY
44055: NOT
44056: IFFALSE 44230
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
44058: LD_ADDR_VAR 0 6
44062: PUSH
44063: LD_EXP 129
44067: PUSH
44068: LD_VAR 0 2
44072: ARRAY
44073: PPUSH
44074: LD_INT 3
44076: PUSH
44077: LD_INT 24
44079: PUSH
44080: LD_INT 1000
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 2
44093: PUSH
44094: LD_INT 34
44096: PUSH
44097: LD_INT 13
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: PUSH
44104: LD_INT 34
44106: PUSH
44107: LD_INT 52
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: LIST
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PPUSH
44123: CALL_OW 72
44127: ST_TO_ADDR
// if cranes then
44128: LD_VAR 0 6
44132: IFFALSE 44194
// for j in cranes do
44134: LD_ADDR_VAR 0 3
44138: PUSH
44139: LD_VAR 0 6
44143: PUSH
44144: FOR_IN
44145: IFFALSE 44192
// if not IsInArea ( j , mc_parking [ i ] ) then
44147: LD_VAR 0 3
44151: PPUSH
44152: LD_EXP 134
44156: PUSH
44157: LD_VAR 0 2
44161: ARRAY
44162: PPUSH
44163: CALL_OW 308
44167: NOT
44168: IFFALSE 44190
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44170: LD_VAR 0 3
44174: PPUSH
44175: LD_EXP 134
44179: PUSH
44180: LD_VAR 0 2
44184: ARRAY
44185: PPUSH
44186: CALL_OW 113
44190: GO 44144
44192: POP
44193: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44194: LD_ADDR_EXP 112
44198: PUSH
44199: LD_EXP 112
44203: PPUSH
44204: LD_VAR 0 2
44208: PPUSH
44209: EMPTY
44210: PPUSH
44211: CALL_OW 1
44215: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44216: LD_VAR 0 2
44220: PPUSH
44221: LD_INT 101
44223: PPUSH
44224: CALL 39131 0 2
// continue ;
44228: GO 44042
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44230: LD_ADDR_EXP 116
44234: PUSH
44235: LD_EXP 116
44239: PPUSH
44240: LD_VAR 0 2
44244: PPUSH
44245: EMPTY
44246: PPUSH
44247: CALL_OW 1
44251: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44252: LD_VAR 0 2
44256: PPUSH
44257: LD_INT 103
44259: PPUSH
44260: CALL 39131 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44264: LD_ADDR_VAR 0 5
44268: PUSH
44269: LD_EXP 110
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PUSH
44280: LD_EXP 139
44284: PUSH
44285: LD_VAR 0 2
44289: ARRAY
44290: UNION
44291: PPUSH
44292: LD_INT 2
44294: PUSH
44295: LD_INT 25
44297: PUSH
44298: LD_INT 2
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 25
44307: PUSH
44308: LD_INT 16
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: LIST
44319: PUSH
44320: EMPTY
44321: LIST
44322: PPUSH
44323: CALL_OW 72
44327: PUSH
44328: LD_EXP 113
44332: PUSH
44333: LD_VAR 0 2
44337: ARRAY
44338: PUSH
44339: LD_INT 1
44341: ARRAY
44342: PUSH
44343: LD_EXP 113
44347: PUSH
44348: LD_VAR 0 2
44352: ARRAY
44353: PUSH
44354: LD_INT 2
44356: ARRAY
44357: UNION
44358: DIFF
44359: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44360: LD_ADDR_VAR 0 6
44364: PUSH
44365: LD_EXP 129
44369: PUSH
44370: LD_VAR 0 2
44374: ARRAY
44375: PPUSH
44376: LD_INT 2
44378: PUSH
44379: LD_INT 34
44381: PUSH
44382: LD_INT 13
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 34
44391: PUSH
44392: LD_INT 52
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: LIST
44403: PPUSH
44404: CALL_OW 72
44408: ST_TO_ADDR
// if cranes then
44409: LD_VAR 0 6
44413: IFFALSE 44549
// begin for j in cranes do
44415: LD_ADDR_VAR 0 3
44419: PUSH
44420: LD_VAR 0 6
44424: PUSH
44425: FOR_IN
44426: IFFALSE 44547
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44428: LD_VAR 0 3
44432: PPUSH
44433: CALL_OW 256
44437: PUSH
44438: LD_INT 500
44440: GREATEREQUAL
44441: PUSH
44442: LD_VAR 0 3
44446: PPUSH
44447: CALL_OW 314
44451: NOT
44452: AND
44453: IFFALSE 44487
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44455: LD_VAR 0 3
44459: PPUSH
44460: LD_EXP 111
44464: PUSH
44465: LD_VAR 0 2
44469: ARRAY
44470: PPUSH
44471: LD_VAR 0 3
44475: PPUSH
44476: CALL_OW 74
44480: PPUSH
44481: CALL_OW 130
44485: GO 44545
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44487: LD_VAR 0 3
44491: PPUSH
44492: CALL_OW 256
44496: PUSH
44497: LD_INT 500
44499: LESS
44500: PUSH
44501: LD_VAR 0 3
44505: PPUSH
44506: LD_EXP 134
44510: PUSH
44511: LD_VAR 0 2
44515: ARRAY
44516: PPUSH
44517: CALL_OW 308
44521: NOT
44522: AND
44523: IFFALSE 44545
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44525: LD_VAR 0 3
44529: PPUSH
44530: LD_EXP 134
44534: PUSH
44535: LD_VAR 0 2
44539: ARRAY
44540: PPUSH
44541: CALL_OW 113
44545: GO 44425
44547: POP
44548: POP
// end ; if tmp > 3 then
44549: LD_VAR 0 5
44553: PUSH
44554: LD_INT 3
44556: GREATER
44557: IFFALSE 44577
// tmp := ShrinkArray ( tmp , 4 ) ;
44559: LD_ADDR_VAR 0 5
44563: PUSH
44564: LD_VAR 0 5
44568: PPUSH
44569: LD_INT 4
44571: PPUSH
44572: CALL 101248 0 2
44576: ST_TO_ADDR
// if not tmp then
44577: LD_VAR 0 5
44581: NOT
44582: IFFALSE 44586
// continue ;
44584: GO 44042
// for j in tmp do
44586: LD_ADDR_VAR 0 3
44590: PUSH
44591: LD_VAR 0 5
44595: PUSH
44596: FOR_IN
44597: IFFALSE 44856
// begin if IsInUnit ( j ) then
44599: LD_VAR 0 3
44603: PPUSH
44604: CALL_OW 310
44608: IFFALSE 44619
// ComExitBuilding ( j ) ;
44610: LD_VAR 0 3
44614: PPUSH
44615: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44619: LD_VAR 0 3
44623: PUSH
44624: LD_EXP 112
44628: PUSH
44629: LD_VAR 0 2
44633: ARRAY
44634: IN
44635: NOT
44636: IFFALSE 44694
// begin SetTag ( j , 101 ) ;
44638: LD_VAR 0 3
44642: PPUSH
44643: LD_INT 101
44645: PPUSH
44646: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44650: LD_ADDR_EXP 112
44654: PUSH
44655: LD_EXP 112
44659: PPUSH
44660: LD_VAR 0 2
44664: PUSH
44665: LD_EXP 112
44669: PUSH
44670: LD_VAR 0 2
44674: ARRAY
44675: PUSH
44676: LD_INT 1
44678: PLUS
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PPUSH
44684: LD_VAR 0 3
44688: PPUSH
44689: CALL 70022 0 3
44693: ST_TO_ADDR
// end ; wait ( 1 ) ;
44694: LD_INT 1
44696: PPUSH
44697: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44701: LD_ADDR_VAR 0 7
44705: PUSH
44706: LD_EXP 111
44710: PUSH
44711: LD_VAR 0 2
44715: ARRAY
44716: ST_TO_ADDR
// if mc_scan [ i ] then
44717: LD_EXP 133
44721: PUSH
44722: LD_VAR 0 2
44726: ARRAY
44727: IFFALSE 44789
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44729: LD_ADDR_VAR 0 7
44733: PUSH
44734: LD_EXP 111
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: PPUSH
44745: LD_INT 3
44747: PUSH
44748: LD_INT 30
44750: PUSH
44751: LD_INT 32
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 30
44760: PUSH
44761: LD_INT 33
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 30
44770: PUSH
44771: LD_INT 31
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: PPUSH
44784: CALL_OW 72
44788: ST_TO_ADDR
// if not to_repair_tmp then
44789: LD_VAR 0 7
44793: NOT
44794: IFFALSE 44798
// continue ;
44796: GO 44596
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44798: LD_ADDR_VAR 0 8
44802: PUSH
44803: LD_VAR 0 7
44807: PPUSH
44808: LD_VAR 0 3
44812: PPUSH
44813: CALL_OW 74
44817: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
44818: LD_VAR 0 8
44822: PPUSH
44823: LD_INT 16
44825: PPUSH
44826: CALL 72615 0 2
44830: PUSH
44831: LD_INT 4
44833: ARRAY
44834: PUSH
44835: LD_INT 5
44837: LESS
44838: IFFALSE 44854
// ComRepairBuilding ( j , to_repair ) ;
44840: LD_VAR 0 3
44844: PPUSH
44845: LD_VAR 0 8
44849: PPUSH
44850: CALL_OW 130
// end ;
44854: GO 44596
44856: POP
44857: POP
// end ;
44858: GO 44042
44860: POP
44861: POP
// end ;
44862: LD_VAR 0 1
44866: RET
// export function MC_Heal ; var i , j , tmp ; begin
44867: LD_INT 0
44869: PPUSH
44870: PPUSH
44871: PPUSH
44872: PPUSH
// if not mc_bases then
44873: LD_EXP 110
44877: NOT
44878: IFFALSE 44882
// exit ;
44880: GO 45284
// for i = 1 to mc_bases do
44882: LD_ADDR_VAR 0 2
44886: PUSH
44887: DOUBLE
44888: LD_INT 1
44890: DEC
44891: ST_TO_ADDR
44892: LD_EXP 110
44896: PUSH
44897: FOR_TO
44898: IFFALSE 45282
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44900: LD_EXP 113
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: PUSH
44911: LD_INT 1
44913: ARRAY
44914: NOT
44915: PUSH
44916: LD_EXP 113
44920: PUSH
44921: LD_VAR 0 2
44925: ARRAY
44926: PUSH
44927: LD_INT 2
44929: ARRAY
44930: NOT
44931: AND
44932: IFFALSE 44970
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44934: LD_ADDR_EXP 114
44938: PUSH
44939: LD_EXP 114
44943: PPUSH
44944: LD_VAR 0 2
44948: PPUSH
44949: EMPTY
44950: PPUSH
44951: CALL_OW 1
44955: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44956: LD_VAR 0 2
44960: PPUSH
44961: LD_INT 102
44963: PPUSH
44964: CALL 39131 0 2
// continue ;
44968: GO 44897
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44970: LD_ADDR_VAR 0 4
44974: PUSH
44975: LD_EXP 110
44979: PUSH
44980: LD_VAR 0 2
44984: ARRAY
44985: PPUSH
44986: LD_INT 25
44988: PUSH
44989: LD_INT 4
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PPUSH
44996: CALL_OW 72
45000: ST_TO_ADDR
// if not tmp then
45001: LD_VAR 0 4
45005: NOT
45006: IFFALSE 45010
// continue ;
45008: GO 44897
// if mc_taming [ i ] then
45010: LD_EXP 141
45014: PUSH
45015: LD_VAR 0 2
45019: ARRAY
45020: IFFALSE 45044
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45022: LD_ADDR_EXP 141
45026: PUSH
45027: LD_EXP 141
45031: PPUSH
45032: LD_VAR 0 2
45036: PPUSH
45037: EMPTY
45038: PPUSH
45039: CALL_OW 1
45043: ST_TO_ADDR
// for j in tmp do
45044: LD_ADDR_VAR 0 3
45048: PUSH
45049: LD_VAR 0 4
45053: PUSH
45054: FOR_IN
45055: IFFALSE 45278
// begin if IsInUnit ( j ) then
45057: LD_VAR 0 3
45061: PPUSH
45062: CALL_OW 310
45066: IFFALSE 45077
// ComExitBuilding ( j ) ;
45068: LD_VAR 0 3
45072: PPUSH
45073: CALL_OW 122
// if not j in mc_healers [ i ] then
45077: LD_VAR 0 3
45081: PUSH
45082: LD_EXP 114
45086: PUSH
45087: LD_VAR 0 2
45091: ARRAY
45092: IN
45093: NOT
45094: IFFALSE 45140
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45096: LD_ADDR_EXP 114
45100: PUSH
45101: LD_EXP 114
45105: PPUSH
45106: LD_VAR 0 2
45110: PUSH
45111: LD_EXP 114
45115: PUSH
45116: LD_VAR 0 2
45120: ARRAY
45121: PUSH
45122: LD_INT 1
45124: PLUS
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PPUSH
45130: LD_VAR 0 3
45134: PPUSH
45135: CALL 70022 0 3
45139: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45140: LD_VAR 0 3
45144: PPUSH
45145: CALL_OW 110
45149: PUSH
45150: LD_INT 102
45152: NONEQUAL
45153: IFFALSE 45167
// SetTag ( j , 102 ) ;
45155: LD_VAR 0 3
45159: PPUSH
45160: LD_INT 102
45162: PPUSH
45163: CALL_OW 109
// Wait ( 3 ) ;
45167: LD_INT 3
45169: PPUSH
45170: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45174: LD_EXP 113
45178: PUSH
45179: LD_VAR 0 2
45183: ARRAY
45184: PUSH
45185: LD_INT 1
45187: ARRAY
45188: IFFALSE 45220
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45190: LD_VAR 0 3
45194: PPUSH
45195: LD_EXP 113
45199: PUSH
45200: LD_VAR 0 2
45204: ARRAY
45205: PUSH
45206: LD_INT 1
45208: ARRAY
45209: PUSH
45210: LD_INT 1
45212: ARRAY
45213: PPUSH
45214: CALL_OW 128
45218: GO 45276
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45220: LD_VAR 0 3
45224: PPUSH
45225: CALL_OW 314
45229: NOT
45230: PUSH
45231: LD_EXP 113
45235: PUSH
45236: LD_VAR 0 2
45240: ARRAY
45241: PUSH
45242: LD_INT 2
45244: ARRAY
45245: AND
45246: IFFALSE 45276
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45248: LD_VAR 0 3
45252: PPUSH
45253: LD_EXP 113
45257: PUSH
45258: LD_VAR 0 2
45262: ARRAY
45263: PUSH
45264: LD_INT 2
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: ARRAY
45271: PPUSH
45272: CALL_OW 128
// end ;
45276: GO 45054
45278: POP
45279: POP
// end ;
45280: GO 44897
45282: POP
45283: POP
// end ;
45284: LD_VAR 0 1
45288: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45289: LD_INT 0
45291: PPUSH
45292: PPUSH
45293: PPUSH
45294: PPUSH
45295: PPUSH
// if not mc_bases then
45296: LD_EXP 110
45300: NOT
45301: IFFALSE 45305
// exit ;
45303: GO 46448
// for i = 1 to mc_bases do
45305: LD_ADDR_VAR 0 2
45309: PUSH
45310: DOUBLE
45311: LD_INT 1
45313: DEC
45314: ST_TO_ADDR
45315: LD_EXP 110
45319: PUSH
45320: FOR_TO
45321: IFFALSE 46446
// begin if mc_scan [ i ] then
45323: LD_EXP 133
45327: PUSH
45328: LD_VAR 0 2
45332: ARRAY
45333: IFFALSE 45337
// continue ;
45335: GO 45320
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45337: LD_EXP 115
45341: PUSH
45342: LD_VAR 0 2
45346: ARRAY
45347: NOT
45348: PUSH
45349: LD_EXP 117
45353: PUSH
45354: LD_VAR 0 2
45358: ARRAY
45359: NOT
45360: AND
45361: PUSH
45362: LD_EXP 116
45366: PUSH
45367: LD_VAR 0 2
45371: ARRAY
45372: AND
45373: IFFALSE 45411
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45375: LD_ADDR_EXP 116
45379: PUSH
45380: LD_EXP 116
45384: PPUSH
45385: LD_VAR 0 2
45389: PPUSH
45390: EMPTY
45391: PPUSH
45392: CALL_OW 1
45396: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45397: LD_VAR 0 2
45401: PPUSH
45402: LD_INT 103
45404: PPUSH
45405: CALL 39131 0 2
// continue ;
45409: GO 45320
// end ; if mc_construct_list [ i ] then
45411: LD_EXP 117
45415: PUSH
45416: LD_VAR 0 2
45420: ARRAY
45421: IFFALSE 45641
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45423: LD_ADDR_VAR 0 4
45427: PUSH
45428: LD_EXP 110
45432: PUSH
45433: LD_VAR 0 2
45437: ARRAY
45438: PPUSH
45439: LD_INT 25
45441: PUSH
45442: LD_INT 2
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PPUSH
45449: CALL_OW 72
45453: PUSH
45454: LD_EXP 112
45458: PUSH
45459: LD_VAR 0 2
45463: ARRAY
45464: DIFF
45465: ST_TO_ADDR
// if not tmp then
45466: LD_VAR 0 4
45470: NOT
45471: IFFALSE 45475
// continue ;
45473: GO 45320
// for j in tmp do
45475: LD_ADDR_VAR 0 3
45479: PUSH
45480: LD_VAR 0 4
45484: PUSH
45485: FOR_IN
45486: IFFALSE 45637
// begin if not mc_builders [ i ] then
45488: LD_EXP 116
45492: PUSH
45493: LD_VAR 0 2
45497: ARRAY
45498: NOT
45499: IFFALSE 45557
// begin SetTag ( j , 103 ) ;
45501: LD_VAR 0 3
45505: PPUSH
45506: LD_INT 103
45508: PPUSH
45509: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45513: LD_ADDR_EXP 116
45517: PUSH
45518: LD_EXP 116
45522: PPUSH
45523: LD_VAR 0 2
45527: PUSH
45528: LD_EXP 116
45532: PUSH
45533: LD_VAR 0 2
45537: ARRAY
45538: PUSH
45539: LD_INT 1
45541: PLUS
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PPUSH
45547: LD_VAR 0 3
45551: PPUSH
45552: CALL 70022 0 3
45556: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45557: LD_VAR 0 3
45561: PPUSH
45562: CALL_OW 310
45566: IFFALSE 45577
// ComExitBuilding ( j ) ;
45568: LD_VAR 0 3
45572: PPUSH
45573: CALL_OW 122
// wait ( 3 ) ;
45577: LD_INT 3
45579: PPUSH
45580: CALL_OW 67
// if not mc_construct_list [ i ] then
45584: LD_EXP 117
45588: PUSH
45589: LD_VAR 0 2
45593: ARRAY
45594: NOT
45595: IFFALSE 45599
// break ;
45597: GO 45637
// if not HasTask ( j ) then
45599: LD_VAR 0 3
45603: PPUSH
45604: CALL_OW 314
45608: NOT
45609: IFFALSE 45635
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45611: LD_VAR 0 3
45615: PPUSH
45616: LD_EXP 117
45620: PUSH
45621: LD_VAR 0 2
45625: ARRAY
45626: PUSH
45627: LD_INT 1
45629: ARRAY
45630: PPUSH
45631: CALL 72873 0 2
// end ;
45635: GO 45485
45637: POP
45638: POP
// end else
45639: GO 46444
// if mc_build_list [ i ] then
45641: LD_EXP 115
45645: PUSH
45646: LD_VAR 0 2
45650: ARRAY
45651: IFFALSE 46444
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45653: LD_ADDR_VAR 0 5
45657: PUSH
45658: LD_EXP 110
45662: PUSH
45663: LD_VAR 0 2
45667: ARRAY
45668: PPUSH
45669: LD_INT 2
45671: PUSH
45672: LD_INT 30
45674: PUSH
45675: LD_INT 0
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: LD_INT 30
45684: PUSH
45685: LD_INT 1
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: PPUSH
45697: CALL_OW 72
45701: ST_TO_ADDR
// if depot then
45702: LD_VAR 0 5
45706: IFFALSE 45724
// depot := depot [ 1 ] else
45708: LD_ADDR_VAR 0 5
45712: PUSH
45713: LD_VAR 0 5
45717: PUSH
45718: LD_INT 1
45720: ARRAY
45721: ST_TO_ADDR
45722: GO 45732
// depot := 0 ;
45724: LD_ADDR_VAR 0 5
45728: PUSH
45729: LD_INT 0
45731: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45732: LD_EXP 115
45736: PUSH
45737: LD_VAR 0 2
45741: ARRAY
45742: PUSH
45743: LD_INT 1
45745: ARRAY
45746: PUSH
45747: LD_INT 1
45749: ARRAY
45750: PPUSH
45751: CALL 72703 0 1
45755: PUSH
45756: LD_EXP 110
45760: PUSH
45761: LD_VAR 0 2
45765: ARRAY
45766: PPUSH
45767: LD_INT 2
45769: PUSH
45770: LD_INT 30
45772: PUSH
45773: LD_INT 2
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 30
45782: PUSH
45783: LD_INT 3
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: LIST
45794: PPUSH
45795: CALL_OW 72
45799: NOT
45800: AND
45801: IFFALSE 45906
// begin for j = 1 to mc_build_list [ i ] do
45803: LD_ADDR_VAR 0 3
45807: PUSH
45808: DOUBLE
45809: LD_INT 1
45811: DEC
45812: ST_TO_ADDR
45813: LD_EXP 115
45817: PUSH
45818: LD_VAR 0 2
45822: ARRAY
45823: PUSH
45824: FOR_TO
45825: IFFALSE 45904
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45827: LD_EXP 115
45831: PUSH
45832: LD_VAR 0 2
45836: ARRAY
45837: PUSH
45838: LD_VAR 0 3
45842: ARRAY
45843: PUSH
45844: LD_INT 1
45846: ARRAY
45847: PUSH
45848: LD_INT 2
45850: EQUAL
45851: IFFALSE 45902
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45853: LD_ADDR_EXP 115
45857: PUSH
45858: LD_EXP 115
45862: PPUSH
45863: LD_VAR 0 2
45867: PPUSH
45868: LD_EXP 115
45872: PUSH
45873: LD_VAR 0 2
45877: ARRAY
45878: PPUSH
45879: LD_VAR 0 3
45883: PPUSH
45884: LD_INT 1
45886: PPUSH
45887: LD_INT 0
45889: PPUSH
45890: CALL 69440 0 4
45894: PPUSH
45895: CALL_OW 1
45899: ST_TO_ADDR
// break ;
45900: GO 45904
// end ;
45902: GO 45824
45904: POP
45905: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45906: LD_EXP 115
45910: PUSH
45911: LD_VAR 0 2
45915: ARRAY
45916: PUSH
45917: LD_INT 1
45919: ARRAY
45920: PUSH
45921: LD_INT 1
45923: ARRAY
45924: PUSH
45925: LD_INT 0
45927: EQUAL
45928: PUSH
45929: LD_VAR 0 5
45933: PUSH
45934: LD_VAR 0 5
45938: PPUSH
45939: LD_EXP 115
45943: PUSH
45944: LD_VAR 0 2
45948: ARRAY
45949: PUSH
45950: LD_INT 1
45952: ARRAY
45953: PUSH
45954: LD_INT 1
45956: ARRAY
45957: PPUSH
45958: LD_EXP 115
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: PUSH
45969: LD_INT 1
45971: ARRAY
45972: PUSH
45973: LD_INT 2
45975: ARRAY
45976: PPUSH
45977: LD_EXP 115
45981: PUSH
45982: LD_VAR 0 2
45986: ARRAY
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: PUSH
45992: LD_INT 3
45994: ARRAY
45995: PPUSH
45996: LD_EXP 115
46000: PUSH
46001: LD_VAR 0 2
46005: ARRAY
46006: PUSH
46007: LD_INT 1
46009: ARRAY
46010: PUSH
46011: LD_INT 4
46013: ARRAY
46014: PPUSH
46015: CALL 77437 0 5
46019: AND
46020: OR
46021: IFFALSE 46302
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46023: LD_ADDR_VAR 0 4
46027: PUSH
46028: LD_EXP 110
46032: PUSH
46033: LD_VAR 0 2
46037: ARRAY
46038: PPUSH
46039: LD_INT 25
46041: PUSH
46042: LD_INT 2
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PPUSH
46049: CALL_OW 72
46053: PUSH
46054: LD_EXP 112
46058: PUSH
46059: LD_VAR 0 2
46063: ARRAY
46064: DIFF
46065: ST_TO_ADDR
// if not tmp then
46066: LD_VAR 0 4
46070: NOT
46071: IFFALSE 46075
// continue ;
46073: GO 45320
// for j in tmp do
46075: LD_ADDR_VAR 0 3
46079: PUSH
46080: LD_VAR 0 4
46084: PUSH
46085: FOR_IN
46086: IFFALSE 46298
// begin if not mc_builders [ i ] then
46088: LD_EXP 116
46092: PUSH
46093: LD_VAR 0 2
46097: ARRAY
46098: NOT
46099: IFFALSE 46157
// begin SetTag ( j , 103 ) ;
46101: LD_VAR 0 3
46105: PPUSH
46106: LD_INT 103
46108: PPUSH
46109: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46113: LD_ADDR_EXP 116
46117: PUSH
46118: LD_EXP 116
46122: PPUSH
46123: LD_VAR 0 2
46127: PUSH
46128: LD_EXP 116
46132: PUSH
46133: LD_VAR 0 2
46137: ARRAY
46138: PUSH
46139: LD_INT 1
46141: PLUS
46142: PUSH
46143: EMPTY
46144: LIST
46145: LIST
46146: PPUSH
46147: LD_VAR 0 3
46151: PPUSH
46152: CALL 70022 0 3
46156: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46157: LD_VAR 0 3
46161: PPUSH
46162: CALL_OW 310
46166: IFFALSE 46177
// ComExitBuilding ( j ) ;
46168: LD_VAR 0 3
46172: PPUSH
46173: CALL_OW 122
// wait ( 3 ) ;
46177: LD_INT 3
46179: PPUSH
46180: CALL_OW 67
// if not mc_build_list [ i ] then
46184: LD_EXP 115
46188: PUSH
46189: LD_VAR 0 2
46193: ARRAY
46194: NOT
46195: IFFALSE 46199
// break ;
46197: GO 46298
// if not HasTask ( j ) then
46199: LD_VAR 0 3
46203: PPUSH
46204: CALL_OW 314
46208: NOT
46209: IFFALSE 46296
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46211: LD_VAR 0 3
46215: PPUSH
46216: LD_EXP 115
46220: PUSH
46221: LD_VAR 0 2
46225: ARRAY
46226: PUSH
46227: LD_INT 1
46229: ARRAY
46230: PUSH
46231: LD_INT 1
46233: ARRAY
46234: PPUSH
46235: LD_EXP 115
46239: PUSH
46240: LD_VAR 0 2
46244: ARRAY
46245: PUSH
46246: LD_INT 1
46248: ARRAY
46249: PUSH
46250: LD_INT 2
46252: ARRAY
46253: PPUSH
46254: LD_EXP 115
46258: PUSH
46259: LD_VAR 0 2
46263: ARRAY
46264: PUSH
46265: LD_INT 1
46267: ARRAY
46268: PUSH
46269: LD_INT 3
46271: ARRAY
46272: PPUSH
46273: LD_EXP 115
46277: PUSH
46278: LD_VAR 0 2
46282: ARRAY
46283: PUSH
46284: LD_INT 1
46286: ARRAY
46287: PUSH
46288: LD_INT 4
46290: ARRAY
46291: PPUSH
46292: CALL_OW 145
// end ;
46296: GO 46085
46298: POP
46299: POP
// end else
46300: GO 46444
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46302: LD_EXP 110
46306: PUSH
46307: LD_VAR 0 2
46311: ARRAY
46312: PPUSH
46313: LD_EXP 115
46317: PUSH
46318: LD_VAR 0 2
46322: ARRAY
46323: PUSH
46324: LD_INT 1
46326: ARRAY
46327: PUSH
46328: LD_INT 1
46330: ARRAY
46331: PPUSH
46332: LD_EXP 115
46336: PUSH
46337: LD_VAR 0 2
46341: ARRAY
46342: PUSH
46343: LD_INT 1
46345: ARRAY
46346: PUSH
46347: LD_INT 2
46349: ARRAY
46350: PPUSH
46351: LD_EXP 115
46355: PUSH
46356: LD_VAR 0 2
46360: ARRAY
46361: PUSH
46362: LD_INT 1
46364: ARRAY
46365: PUSH
46366: LD_INT 3
46368: ARRAY
46369: PPUSH
46370: LD_EXP 115
46374: PUSH
46375: LD_VAR 0 2
46379: ARRAY
46380: PUSH
46381: LD_INT 1
46383: ARRAY
46384: PUSH
46385: LD_INT 4
46387: ARRAY
46388: PPUSH
46389: CALL 76773 0 5
46393: NOT
46394: IFFALSE 46444
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46396: LD_ADDR_EXP 115
46400: PUSH
46401: LD_EXP 115
46405: PPUSH
46406: LD_VAR 0 2
46410: PPUSH
46411: LD_EXP 115
46415: PUSH
46416: LD_VAR 0 2
46420: ARRAY
46421: PPUSH
46422: LD_INT 1
46424: PPUSH
46425: LD_INT 1
46427: NEG
46428: PPUSH
46429: LD_INT 0
46431: PPUSH
46432: CALL 69440 0 4
46436: PPUSH
46437: CALL_OW 1
46441: ST_TO_ADDR
// continue ;
46442: GO 45320
// end ; end ; end ;
46444: GO 45320
46446: POP
46447: POP
// end ;
46448: LD_VAR 0 1
46452: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46453: LD_INT 0
46455: PPUSH
46456: PPUSH
46457: PPUSH
46458: PPUSH
46459: PPUSH
46460: PPUSH
// if not mc_bases then
46461: LD_EXP 110
46465: NOT
46466: IFFALSE 46470
// exit ;
46468: GO 46897
// for i = 1 to mc_bases do
46470: LD_ADDR_VAR 0 2
46474: PUSH
46475: DOUBLE
46476: LD_INT 1
46478: DEC
46479: ST_TO_ADDR
46480: LD_EXP 110
46484: PUSH
46485: FOR_TO
46486: IFFALSE 46895
// begin tmp := mc_build_upgrade [ i ] ;
46488: LD_ADDR_VAR 0 4
46492: PUSH
46493: LD_EXP 142
46497: PUSH
46498: LD_VAR 0 2
46502: ARRAY
46503: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46504: LD_ADDR_VAR 0 6
46508: PUSH
46509: LD_EXP 143
46513: PUSH
46514: LD_VAR 0 2
46518: ARRAY
46519: PPUSH
46520: LD_INT 2
46522: PUSH
46523: LD_INT 30
46525: PUSH
46526: LD_INT 6
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: PUSH
46533: LD_INT 30
46535: PUSH
46536: LD_INT 7
46538: PUSH
46539: EMPTY
46540: LIST
46541: LIST
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: LIST
46547: PPUSH
46548: CALL_OW 72
46552: ST_TO_ADDR
// if not tmp and not lab then
46553: LD_VAR 0 4
46557: NOT
46558: PUSH
46559: LD_VAR 0 6
46563: NOT
46564: AND
46565: IFFALSE 46569
// continue ;
46567: GO 46485
// if tmp then
46569: LD_VAR 0 4
46573: IFFALSE 46693
// for j in tmp do
46575: LD_ADDR_VAR 0 3
46579: PUSH
46580: LD_VAR 0 4
46584: PUSH
46585: FOR_IN
46586: IFFALSE 46691
// begin if UpgradeCost ( j ) then
46588: LD_VAR 0 3
46592: PPUSH
46593: CALL 76433 0 1
46597: IFFALSE 46689
// begin ComUpgrade ( j ) ;
46599: LD_VAR 0 3
46603: PPUSH
46604: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46608: LD_ADDR_EXP 142
46612: PUSH
46613: LD_EXP 142
46617: PPUSH
46618: LD_VAR 0 2
46622: PPUSH
46623: LD_EXP 142
46627: PUSH
46628: LD_VAR 0 2
46632: ARRAY
46633: PUSH
46634: LD_VAR 0 3
46638: DIFF
46639: PPUSH
46640: CALL_OW 1
46644: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46645: LD_ADDR_EXP 117
46649: PUSH
46650: LD_EXP 117
46654: PPUSH
46655: LD_VAR 0 2
46659: PUSH
46660: LD_EXP 117
46664: PUSH
46665: LD_VAR 0 2
46669: ARRAY
46670: PUSH
46671: LD_INT 1
46673: PLUS
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PPUSH
46679: LD_VAR 0 3
46683: PPUSH
46684: CALL 70022 0 3
46688: ST_TO_ADDR
// end ; end ;
46689: GO 46585
46691: POP
46692: POP
// if not lab or not mc_lab_upgrade [ i ] then
46693: LD_VAR 0 6
46697: NOT
46698: PUSH
46699: LD_EXP 144
46703: PUSH
46704: LD_VAR 0 2
46708: ARRAY
46709: NOT
46710: OR
46711: IFFALSE 46715
// continue ;
46713: GO 46485
// for j in lab do
46715: LD_ADDR_VAR 0 3
46719: PUSH
46720: LD_VAR 0 6
46724: PUSH
46725: FOR_IN
46726: IFFALSE 46891
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46728: LD_VAR 0 3
46732: PPUSH
46733: CALL_OW 266
46737: PUSH
46738: LD_INT 6
46740: PUSH
46741: LD_INT 7
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: IN
46748: PUSH
46749: LD_VAR 0 3
46753: PPUSH
46754: CALL_OW 461
46758: PUSH
46759: LD_INT 1
46761: NONEQUAL
46762: AND
46763: IFFALSE 46889
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46765: LD_VAR 0 3
46769: PPUSH
46770: LD_EXP 144
46774: PUSH
46775: LD_VAR 0 2
46779: ARRAY
46780: PUSH
46781: LD_INT 1
46783: ARRAY
46784: PPUSH
46785: CALL 76638 0 2
46789: IFFALSE 46889
// begin ComCancel ( j ) ;
46791: LD_VAR 0 3
46795: PPUSH
46796: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46800: LD_VAR 0 3
46804: PPUSH
46805: LD_EXP 144
46809: PUSH
46810: LD_VAR 0 2
46814: ARRAY
46815: PUSH
46816: LD_INT 1
46818: ARRAY
46819: PPUSH
46820: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46824: LD_VAR 0 3
46828: PUSH
46829: LD_EXP 117
46833: PUSH
46834: LD_VAR 0 2
46838: ARRAY
46839: IN
46840: NOT
46841: IFFALSE 46887
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46843: LD_ADDR_EXP 117
46847: PUSH
46848: LD_EXP 117
46852: PPUSH
46853: LD_VAR 0 2
46857: PUSH
46858: LD_EXP 117
46862: PUSH
46863: LD_VAR 0 2
46867: ARRAY
46868: PUSH
46869: LD_INT 1
46871: PLUS
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: PPUSH
46877: LD_VAR 0 3
46881: PPUSH
46882: CALL 70022 0 3
46886: ST_TO_ADDR
// break ;
46887: GO 46891
// end ; end ; end ;
46889: GO 46725
46891: POP
46892: POP
// end ;
46893: GO 46485
46895: POP
46896: POP
// end ;
46897: LD_VAR 0 1
46901: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46902: LD_INT 0
46904: PPUSH
46905: PPUSH
46906: PPUSH
46907: PPUSH
46908: PPUSH
46909: PPUSH
46910: PPUSH
46911: PPUSH
46912: PPUSH
// if not mc_bases then
46913: LD_EXP 110
46917: NOT
46918: IFFALSE 46922
// exit ;
46920: GO 47327
// for i = 1 to mc_bases do
46922: LD_ADDR_VAR 0 2
46926: PUSH
46927: DOUBLE
46928: LD_INT 1
46930: DEC
46931: ST_TO_ADDR
46932: LD_EXP 110
46936: PUSH
46937: FOR_TO
46938: IFFALSE 47325
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46940: LD_EXP 118
46944: PUSH
46945: LD_VAR 0 2
46949: ARRAY
46950: NOT
46951: PUSH
46952: LD_EXP 110
46956: PUSH
46957: LD_VAR 0 2
46961: ARRAY
46962: PPUSH
46963: LD_INT 30
46965: PUSH
46966: LD_INT 3
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: PPUSH
46973: CALL_OW 72
46977: NOT
46978: OR
46979: IFFALSE 46983
// continue ;
46981: GO 46937
// busy := false ;
46983: LD_ADDR_VAR 0 8
46987: PUSH
46988: LD_INT 0
46990: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46991: LD_ADDR_VAR 0 4
46995: PUSH
46996: LD_EXP 110
47000: PUSH
47001: LD_VAR 0 2
47005: ARRAY
47006: PPUSH
47007: LD_INT 30
47009: PUSH
47010: LD_INT 3
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PPUSH
47017: CALL_OW 72
47021: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47022: LD_ADDR_VAR 0 6
47026: PUSH
47027: LD_EXP 118
47031: PUSH
47032: LD_VAR 0 2
47036: ARRAY
47037: PPUSH
47038: LD_INT 2
47040: PUSH
47041: LD_INT 30
47043: PUSH
47044: LD_INT 32
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 30
47053: PUSH
47054: LD_INT 33
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: LIST
47065: PPUSH
47066: CALL_OW 72
47070: ST_TO_ADDR
// if not t then
47071: LD_VAR 0 6
47075: NOT
47076: IFFALSE 47080
// continue ;
47078: GO 46937
// for j in tmp do
47080: LD_ADDR_VAR 0 3
47084: PUSH
47085: LD_VAR 0 4
47089: PUSH
47090: FOR_IN
47091: IFFALSE 47121
// if not BuildingStatus ( j ) = bs_idle then
47093: LD_VAR 0 3
47097: PPUSH
47098: CALL_OW 461
47102: PUSH
47103: LD_INT 2
47105: EQUAL
47106: NOT
47107: IFFALSE 47119
// begin busy := true ;
47109: LD_ADDR_VAR 0 8
47113: PUSH
47114: LD_INT 1
47116: ST_TO_ADDR
// break ;
47117: GO 47121
// end ;
47119: GO 47090
47121: POP
47122: POP
// if busy then
47123: LD_VAR 0 8
47127: IFFALSE 47131
// continue ;
47129: GO 46937
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47131: LD_ADDR_VAR 0 7
47135: PUSH
47136: LD_VAR 0 6
47140: PPUSH
47141: LD_INT 35
47143: PUSH
47144: LD_INT 0
47146: PUSH
47147: EMPTY
47148: LIST
47149: LIST
47150: PPUSH
47151: CALL_OW 72
47155: ST_TO_ADDR
// if tw then
47156: LD_VAR 0 7
47160: IFFALSE 47237
// begin tw := tw [ 1 ] ;
47162: LD_ADDR_VAR 0 7
47166: PUSH
47167: LD_VAR 0 7
47171: PUSH
47172: LD_INT 1
47174: ARRAY
47175: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47176: LD_ADDR_VAR 0 9
47180: PUSH
47181: LD_VAR 0 7
47185: PPUSH
47186: LD_EXP 135
47190: PUSH
47191: LD_VAR 0 2
47195: ARRAY
47196: PPUSH
47197: CALL 74992 0 2
47201: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47202: LD_EXP 149
47206: PUSH
47207: LD_VAR 0 2
47211: ARRAY
47212: IFFALSE 47235
// if not weapon in mc_allowed_tower_weapons [ i ] then
47214: LD_VAR 0 9
47218: PUSH
47219: LD_EXP 149
47223: PUSH
47224: LD_VAR 0 2
47228: ARRAY
47229: IN
47230: NOT
47231: IFFALSE 47235
// continue ;
47233: GO 46937
// end else
47235: GO 47300
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47237: LD_ADDR_VAR 0 5
47241: PUSH
47242: LD_EXP 118
47246: PUSH
47247: LD_VAR 0 2
47251: ARRAY
47252: PPUSH
47253: LD_VAR 0 4
47257: PPUSH
47258: CALL 100494 0 2
47262: ST_TO_ADDR
// if not tmp2 then
47263: LD_VAR 0 5
47267: NOT
47268: IFFALSE 47272
// continue ;
47270: GO 46937
// tw := tmp2 [ 1 ] ;
47272: LD_ADDR_VAR 0 7
47276: PUSH
47277: LD_VAR 0 5
47281: PUSH
47282: LD_INT 1
47284: ARRAY
47285: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47286: LD_ADDR_VAR 0 9
47290: PUSH
47291: LD_VAR 0 5
47295: PUSH
47296: LD_INT 2
47298: ARRAY
47299: ST_TO_ADDR
// end ; if not weapon then
47300: LD_VAR 0 9
47304: NOT
47305: IFFALSE 47309
// continue ;
47307: GO 46937
// ComPlaceWeapon ( tw , weapon ) ;
47309: LD_VAR 0 7
47313: PPUSH
47314: LD_VAR 0 9
47318: PPUSH
47319: CALL_OW 148
// end ;
47323: GO 46937
47325: POP
47326: POP
// end ;
47327: LD_VAR 0 1
47331: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47332: LD_INT 0
47334: PPUSH
47335: PPUSH
47336: PPUSH
47337: PPUSH
47338: PPUSH
47339: PPUSH
// if not mc_bases then
47340: LD_EXP 110
47344: NOT
47345: IFFALSE 47349
// exit ;
47347: GO 48125
// for i = 1 to mc_bases do
47349: LD_ADDR_VAR 0 2
47353: PUSH
47354: DOUBLE
47355: LD_INT 1
47357: DEC
47358: ST_TO_ADDR
47359: LD_EXP 110
47363: PUSH
47364: FOR_TO
47365: IFFALSE 48123
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47367: LD_EXP 123
47371: PUSH
47372: LD_VAR 0 2
47376: ARRAY
47377: NOT
47378: PUSH
47379: LD_EXP 123
47383: PUSH
47384: LD_VAR 0 2
47388: ARRAY
47389: PUSH
47390: LD_EXP 124
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: EQUAL
47401: OR
47402: PUSH
47403: LD_EXP 133
47407: PUSH
47408: LD_VAR 0 2
47412: ARRAY
47413: OR
47414: IFFALSE 47418
// continue ;
47416: GO 47364
// if mc_miners [ i ] then
47418: LD_EXP 124
47422: PUSH
47423: LD_VAR 0 2
47427: ARRAY
47428: IFFALSE 47810
// begin for j = mc_miners [ i ] downto 1 do
47430: LD_ADDR_VAR 0 3
47434: PUSH
47435: DOUBLE
47436: LD_EXP 124
47440: PUSH
47441: LD_VAR 0 2
47445: ARRAY
47446: INC
47447: ST_TO_ADDR
47448: LD_INT 1
47450: PUSH
47451: FOR_DOWNTO
47452: IFFALSE 47808
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47454: LD_EXP 124
47458: PUSH
47459: LD_VAR 0 2
47463: ARRAY
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: PPUSH
47471: CALL_OW 301
47475: PUSH
47476: LD_EXP 124
47480: PUSH
47481: LD_VAR 0 2
47485: ARRAY
47486: PUSH
47487: LD_VAR 0 3
47491: ARRAY
47492: PPUSH
47493: CALL_OW 257
47497: PUSH
47498: LD_INT 1
47500: NONEQUAL
47501: OR
47502: IFFALSE 47565
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47504: LD_ADDR_VAR 0 5
47508: PUSH
47509: LD_EXP 124
47513: PUSH
47514: LD_VAR 0 2
47518: ARRAY
47519: PUSH
47520: LD_EXP 124
47524: PUSH
47525: LD_VAR 0 2
47529: ARRAY
47530: PUSH
47531: LD_VAR 0 3
47535: ARRAY
47536: DIFF
47537: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47538: LD_ADDR_EXP 124
47542: PUSH
47543: LD_EXP 124
47547: PPUSH
47548: LD_VAR 0 2
47552: PPUSH
47553: LD_VAR 0 5
47557: PPUSH
47558: CALL_OW 1
47562: ST_TO_ADDR
// continue ;
47563: GO 47451
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47565: LD_EXP 124
47569: PUSH
47570: LD_VAR 0 2
47574: ARRAY
47575: PUSH
47576: LD_VAR 0 3
47580: ARRAY
47581: PPUSH
47582: CALL_OW 257
47586: PUSH
47587: LD_INT 1
47589: EQUAL
47590: PUSH
47591: LD_EXP 124
47595: PUSH
47596: LD_VAR 0 2
47600: ARRAY
47601: PUSH
47602: LD_VAR 0 3
47606: ARRAY
47607: PPUSH
47608: CALL_OW 459
47612: NOT
47613: AND
47614: PUSH
47615: LD_EXP 124
47619: PUSH
47620: LD_VAR 0 2
47624: ARRAY
47625: PUSH
47626: LD_VAR 0 3
47630: ARRAY
47631: PPUSH
47632: CALL_OW 314
47636: NOT
47637: AND
47638: IFFALSE 47806
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47640: LD_EXP 124
47644: PUSH
47645: LD_VAR 0 2
47649: ARRAY
47650: PUSH
47651: LD_VAR 0 3
47655: ARRAY
47656: PPUSH
47657: CALL_OW 310
47661: IFFALSE 47684
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47663: LD_EXP 124
47667: PUSH
47668: LD_VAR 0 2
47672: ARRAY
47673: PUSH
47674: LD_VAR 0 3
47678: ARRAY
47679: PPUSH
47680: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47684: LD_EXP 124
47688: PUSH
47689: LD_VAR 0 2
47693: ARRAY
47694: PUSH
47695: LD_VAR 0 3
47699: ARRAY
47700: PPUSH
47701: CALL_OW 314
47705: NOT
47706: IFFALSE 47806
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47708: LD_EXP 124
47712: PUSH
47713: LD_VAR 0 2
47717: ARRAY
47718: PUSH
47719: LD_VAR 0 3
47723: ARRAY
47724: PPUSH
47725: LD_EXP 123
47729: PUSH
47730: LD_VAR 0 2
47734: ARRAY
47735: PUSH
47736: LD_VAR 0 3
47740: PUSH
47741: LD_EXP 123
47745: PUSH
47746: LD_VAR 0 2
47750: ARRAY
47751: MOD
47752: PUSH
47753: LD_INT 1
47755: PLUS
47756: ARRAY
47757: PUSH
47758: LD_INT 1
47760: ARRAY
47761: PPUSH
47762: LD_EXP 123
47766: PUSH
47767: LD_VAR 0 2
47771: ARRAY
47772: PUSH
47773: LD_VAR 0 3
47777: PUSH
47778: LD_EXP 123
47782: PUSH
47783: LD_VAR 0 2
47787: ARRAY
47788: MOD
47789: PUSH
47790: LD_INT 1
47792: PLUS
47793: ARRAY
47794: PUSH
47795: LD_INT 2
47797: ARRAY
47798: PPUSH
47799: LD_INT 0
47801: PPUSH
47802: CALL_OW 193
// end ; end ;
47806: GO 47451
47808: POP
47809: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47810: LD_ADDR_VAR 0 5
47814: PUSH
47815: LD_EXP 110
47819: PUSH
47820: LD_VAR 0 2
47824: ARRAY
47825: PPUSH
47826: LD_INT 2
47828: PUSH
47829: LD_INT 30
47831: PUSH
47832: LD_INT 4
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: LD_INT 30
47841: PUSH
47842: LD_INT 5
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: PUSH
47849: LD_INT 30
47851: PUSH
47852: LD_INT 32
47854: PUSH
47855: EMPTY
47856: LIST
47857: LIST
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: PPUSH
47865: CALL_OW 72
47869: ST_TO_ADDR
// if not tmp then
47870: LD_VAR 0 5
47874: NOT
47875: IFFALSE 47879
// continue ;
47877: GO 47364
// list := [ ] ;
47879: LD_ADDR_VAR 0 6
47883: PUSH
47884: EMPTY
47885: ST_TO_ADDR
// for j in tmp do
47886: LD_ADDR_VAR 0 3
47890: PUSH
47891: LD_VAR 0 5
47895: PUSH
47896: FOR_IN
47897: IFFALSE 47966
// begin for k in UnitsInside ( j ) do
47899: LD_ADDR_VAR 0 4
47903: PUSH
47904: LD_VAR 0 3
47908: PPUSH
47909: CALL_OW 313
47913: PUSH
47914: FOR_IN
47915: IFFALSE 47962
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47917: LD_VAR 0 4
47921: PPUSH
47922: CALL_OW 257
47926: PUSH
47927: LD_INT 1
47929: EQUAL
47930: PUSH
47931: LD_VAR 0 4
47935: PPUSH
47936: CALL_OW 459
47940: NOT
47941: AND
47942: IFFALSE 47960
// list := list ^ k ;
47944: LD_ADDR_VAR 0 6
47948: PUSH
47949: LD_VAR 0 6
47953: PUSH
47954: LD_VAR 0 4
47958: ADD
47959: ST_TO_ADDR
47960: GO 47914
47962: POP
47963: POP
// end ;
47964: GO 47896
47966: POP
47967: POP
// list := list diff mc_miners [ i ] ;
47968: LD_ADDR_VAR 0 6
47972: PUSH
47973: LD_VAR 0 6
47977: PUSH
47978: LD_EXP 124
47982: PUSH
47983: LD_VAR 0 2
47987: ARRAY
47988: DIFF
47989: ST_TO_ADDR
// if not list then
47990: LD_VAR 0 6
47994: NOT
47995: IFFALSE 47999
// continue ;
47997: GO 47364
// k := mc_mines [ i ] - mc_miners [ i ] ;
47999: LD_ADDR_VAR 0 4
48003: PUSH
48004: LD_EXP 123
48008: PUSH
48009: LD_VAR 0 2
48013: ARRAY
48014: PUSH
48015: LD_EXP 124
48019: PUSH
48020: LD_VAR 0 2
48024: ARRAY
48025: MINUS
48026: ST_TO_ADDR
// if k > list then
48027: LD_VAR 0 4
48031: PUSH
48032: LD_VAR 0 6
48036: GREATER
48037: IFFALSE 48049
// k := list ;
48039: LD_ADDR_VAR 0 4
48043: PUSH
48044: LD_VAR 0 6
48048: ST_TO_ADDR
// for j = 1 to k do
48049: LD_ADDR_VAR 0 3
48053: PUSH
48054: DOUBLE
48055: LD_INT 1
48057: DEC
48058: ST_TO_ADDR
48059: LD_VAR 0 4
48063: PUSH
48064: FOR_TO
48065: IFFALSE 48119
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48067: LD_ADDR_EXP 124
48071: PUSH
48072: LD_EXP 124
48076: PPUSH
48077: LD_VAR 0 2
48081: PUSH
48082: LD_EXP 124
48086: PUSH
48087: LD_VAR 0 2
48091: ARRAY
48092: PUSH
48093: LD_INT 1
48095: PLUS
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: PPUSH
48101: LD_VAR 0 6
48105: PUSH
48106: LD_VAR 0 3
48110: ARRAY
48111: PPUSH
48112: CALL 70022 0 3
48116: ST_TO_ADDR
48117: GO 48064
48119: POP
48120: POP
// end ;
48121: GO 47364
48123: POP
48124: POP
// end ;
48125: LD_VAR 0 1
48129: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48130: LD_INT 0
48132: PPUSH
48133: PPUSH
48134: PPUSH
48135: PPUSH
48136: PPUSH
48137: PPUSH
48138: PPUSH
48139: PPUSH
48140: PPUSH
48141: PPUSH
// if not mc_bases then
48142: LD_EXP 110
48146: NOT
48147: IFFALSE 48151
// exit ;
48149: GO 49901
// for i = 1 to mc_bases do
48151: LD_ADDR_VAR 0 2
48155: PUSH
48156: DOUBLE
48157: LD_INT 1
48159: DEC
48160: ST_TO_ADDR
48161: LD_EXP 110
48165: PUSH
48166: FOR_TO
48167: IFFALSE 49899
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48169: LD_EXP 110
48173: PUSH
48174: LD_VAR 0 2
48178: ARRAY
48179: NOT
48180: PUSH
48181: LD_EXP 117
48185: PUSH
48186: LD_VAR 0 2
48190: ARRAY
48191: OR
48192: IFFALSE 48196
// continue ;
48194: GO 48166
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48196: LD_EXP 126
48200: PUSH
48201: LD_VAR 0 2
48205: ARRAY
48206: NOT
48207: PUSH
48208: LD_EXP 127
48212: PUSH
48213: LD_VAR 0 2
48217: ARRAY
48218: AND
48219: IFFALSE 48257
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48221: LD_ADDR_EXP 127
48225: PUSH
48226: LD_EXP 127
48230: PPUSH
48231: LD_VAR 0 2
48235: PPUSH
48236: EMPTY
48237: PPUSH
48238: CALL_OW 1
48242: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48243: LD_VAR 0 2
48247: PPUSH
48248: LD_INT 107
48250: PPUSH
48251: CALL 39131 0 2
// continue ;
48255: GO 48166
// end ; target := [ ] ;
48257: LD_ADDR_VAR 0 6
48261: PUSH
48262: EMPTY
48263: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48264: LD_ADDR_VAR 0 3
48268: PUSH
48269: DOUBLE
48270: LD_EXP 126
48274: PUSH
48275: LD_VAR 0 2
48279: ARRAY
48280: INC
48281: ST_TO_ADDR
48282: LD_INT 1
48284: PUSH
48285: FOR_DOWNTO
48286: IFFALSE 48546
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48288: LD_EXP 126
48292: PUSH
48293: LD_VAR 0 2
48297: ARRAY
48298: PUSH
48299: LD_VAR 0 3
48303: ARRAY
48304: PUSH
48305: LD_INT 2
48307: ARRAY
48308: PPUSH
48309: LD_EXP 126
48313: PUSH
48314: LD_VAR 0 2
48318: ARRAY
48319: PUSH
48320: LD_VAR 0 3
48324: ARRAY
48325: PUSH
48326: LD_INT 3
48328: ARRAY
48329: PPUSH
48330: CALL_OW 488
48334: PUSH
48335: LD_EXP 126
48339: PUSH
48340: LD_VAR 0 2
48344: ARRAY
48345: PUSH
48346: LD_VAR 0 3
48350: ARRAY
48351: PUSH
48352: LD_INT 2
48354: ARRAY
48355: PPUSH
48356: LD_EXP 126
48360: PUSH
48361: LD_VAR 0 2
48365: ARRAY
48366: PUSH
48367: LD_VAR 0 3
48371: ARRAY
48372: PUSH
48373: LD_INT 3
48375: ARRAY
48376: PPUSH
48377: CALL_OW 284
48381: PUSH
48382: LD_INT 0
48384: EQUAL
48385: AND
48386: IFFALSE 48441
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48388: LD_ADDR_VAR 0 5
48392: PUSH
48393: LD_EXP 126
48397: PUSH
48398: LD_VAR 0 2
48402: ARRAY
48403: PPUSH
48404: LD_VAR 0 3
48408: PPUSH
48409: CALL_OW 3
48413: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48414: LD_ADDR_EXP 126
48418: PUSH
48419: LD_EXP 126
48423: PPUSH
48424: LD_VAR 0 2
48428: PPUSH
48429: LD_VAR 0 5
48433: PPUSH
48434: CALL_OW 1
48438: ST_TO_ADDR
// continue ;
48439: GO 48285
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48441: LD_EXP 110
48445: PUSH
48446: LD_VAR 0 2
48450: ARRAY
48451: PUSH
48452: LD_INT 1
48454: ARRAY
48455: PPUSH
48456: CALL_OW 255
48460: PPUSH
48461: LD_EXP 126
48465: PUSH
48466: LD_VAR 0 2
48470: ARRAY
48471: PUSH
48472: LD_VAR 0 3
48476: ARRAY
48477: PUSH
48478: LD_INT 2
48480: ARRAY
48481: PPUSH
48482: LD_EXP 126
48486: PUSH
48487: LD_VAR 0 2
48491: ARRAY
48492: PUSH
48493: LD_VAR 0 3
48497: ARRAY
48498: PUSH
48499: LD_INT 3
48501: ARRAY
48502: PPUSH
48503: LD_INT 30
48505: PPUSH
48506: CALL 70918 0 4
48510: PUSH
48511: LD_INT 4
48513: ARRAY
48514: PUSH
48515: LD_INT 0
48517: EQUAL
48518: IFFALSE 48544
// begin target := mc_crates [ i ] [ j ] ;
48520: LD_ADDR_VAR 0 6
48524: PUSH
48525: LD_EXP 126
48529: PUSH
48530: LD_VAR 0 2
48534: ARRAY
48535: PUSH
48536: LD_VAR 0 3
48540: ARRAY
48541: ST_TO_ADDR
// break ;
48542: GO 48546
// end ; end ;
48544: GO 48285
48546: POP
48547: POP
// if not target then
48548: LD_VAR 0 6
48552: NOT
48553: IFFALSE 48557
// continue ;
48555: GO 48166
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48557: LD_ADDR_VAR 0 7
48561: PUSH
48562: LD_EXP 129
48566: PUSH
48567: LD_VAR 0 2
48571: ARRAY
48572: PPUSH
48573: LD_INT 2
48575: PUSH
48576: LD_INT 3
48578: PUSH
48579: LD_INT 58
48581: PUSH
48582: EMPTY
48583: LIST
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: PUSH
48589: LD_INT 61
48591: PUSH
48592: EMPTY
48593: LIST
48594: PUSH
48595: LD_INT 33
48597: PUSH
48598: LD_INT 5
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: PUSH
48605: LD_INT 33
48607: PUSH
48608: LD_INT 3
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 2
48624: PUSH
48625: LD_INT 34
48627: PUSH
48628: LD_INT 32
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: PUSH
48635: LD_INT 34
48637: PUSH
48638: LD_INT 51
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PUSH
48645: LD_INT 34
48647: PUSH
48648: LD_INT 12
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: EMPTY
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PPUSH
48665: CALL_OW 72
48669: ST_TO_ADDR
// if not cargo then
48670: LD_VAR 0 7
48674: NOT
48675: IFFALSE 49318
// begin if mc_crates_collector [ i ] < 5 then
48677: LD_EXP 127
48681: PUSH
48682: LD_VAR 0 2
48686: ARRAY
48687: PUSH
48688: LD_INT 5
48690: LESS
48691: IFFALSE 49057
// begin if mc_ape [ i ] then
48693: LD_EXP 139
48697: PUSH
48698: LD_VAR 0 2
48702: ARRAY
48703: IFFALSE 48750
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48705: LD_ADDR_VAR 0 5
48709: PUSH
48710: LD_EXP 139
48714: PUSH
48715: LD_VAR 0 2
48719: ARRAY
48720: PPUSH
48721: LD_INT 25
48723: PUSH
48724: LD_INT 16
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PUSH
48731: LD_INT 24
48733: PUSH
48734: LD_INT 750
48736: PUSH
48737: EMPTY
48738: LIST
48739: LIST
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PPUSH
48745: CALL_OW 72
48749: ST_TO_ADDR
// if not tmp then
48750: LD_VAR 0 5
48754: NOT
48755: IFFALSE 48802
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48757: LD_ADDR_VAR 0 5
48761: PUSH
48762: LD_EXP 110
48766: PUSH
48767: LD_VAR 0 2
48771: ARRAY
48772: PPUSH
48773: LD_INT 25
48775: PUSH
48776: LD_INT 2
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 24
48785: PUSH
48786: LD_INT 750
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: PPUSH
48797: CALL_OW 72
48801: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48802: LD_EXP 139
48806: PUSH
48807: LD_VAR 0 2
48811: ARRAY
48812: PUSH
48813: LD_EXP 110
48817: PUSH
48818: LD_VAR 0 2
48822: ARRAY
48823: PPUSH
48824: LD_INT 25
48826: PUSH
48827: LD_INT 2
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 24
48836: PUSH
48837: LD_INT 750
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PPUSH
48848: CALL_OW 72
48852: AND
48853: PUSH
48854: LD_VAR 0 5
48858: PUSH
48859: LD_INT 5
48861: LESS
48862: AND
48863: IFFALSE 48945
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48865: LD_ADDR_VAR 0 3
48869: PUSH
48870: LD_EXP 110
48874: PUSH
48875: LD_VAR 0 2
48879: ARRAY
48880: PPUSH
48881: LD_INT 25
48883: PUSH
48884: LD_INT 2
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PUSH
48891: LD_INT 24
48893: PUSH
48894: LD_INT 750
48896: PUSH
48897: EMPTY
48898: LIST
48899: LIST
48900: PUSH
48901: EMPTY
48902: LIST
48903: LIST
48904: PPUSH
48905: CALL_OW 72
48909: PUSH
48910: FOR_IN
48911: IFFALSE 48943
// begin tmp := tmp union j ;
48913: LD_ADDR_VAR 0 5
48917: PUSH
48918: LD_VAR 0 5
48922: PUSH
48923: LD_VAR 0 3
48927: UNION
48928: ST_TO_ADDR
// if tmp >= 5 then
48929: LD_VAR 0 5
48933: PUSH
48934: LD_INT 5
48936: GREATEREQUAL
48937: IFFALSE 48941
// break ;
48939: GO 48943
// end ;
48941: GO 48910
48943: POP
48944: POP
// end ; if not tmp then
48945: LD_VAR 0 5
48949: NOT
48950: IFFALSE 48954
// continue ;
48952: GO 48166
// for j in tmp do
48954: LD_ADDR_VAR 0 3
48958: PUSH
48959: LD_VAR 0 5
48963: PUSH
48964: FOR_IN
48965: IFFALSE 49055
// if not GetTag ( j ) then
48967: LD_VAR 0 3
48971: PPUSH
48972: CALL_OW 110
48976: NOT
48977: IFFALSE 49053
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48979: LD_ADDR_EXP 127
48983: PUSH
48984: LD_EXP 127
48988: PPUSH
48989: LD_VAR 0 2
48993: PUSH
48994: LD_EXP 127
48998: PUSH
48999: LD_VAR 0 2
49003: ARRAY
49004: PUSH
49005: LD_INT 1
49007: PLUS
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PPUSH
49013: LD_VAR 0 3
49017: PPUSH
49018: CALL 70022 0 3
49022: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49023: LD_VAR 0 3
49027: PPUSH
49028: LD_INT 107
49030: PPUSH
49031: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49035: LD_EXP 127
49039: PUSH
49040: LD_VAR 0 2
49044: ARRAY
49045: PUSH
49046: LD_INT 5
49048: GREATEREQUAL
49049: IFFALSE 49053
// break ;
49051: GO 49055
// end ;
49053: GO 48964
49055: POP
49056: POP
// end ; if mc_crates_collector [ i ] and target then
49057: LD_EXP 127
49061: PUSH
49062: LD_VAR 0 2
49066: ARRAY
49067: PUSH
49068: LD_VAR 0 6
49072: AND
49073: IFFALSE 49316
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49075: LD_EXP 127
49079: PUSH
49080: LD_VAR 0 2
49084: ARRAY
49085: PUSH
49086: LD_VAR 0 6
49090: PUSH
49091: LD_INT 1
49093: ARRAY
49094: LESS
49095: IFFALSE 49115
// tmp := mc_crates_collector [ i ] else
49097: LD_ADDR_VAR 0 5
49101: PUSH
49102: LD_EXP 127
49106: PUSH
49107: LD_VAR 0 2
49111: ARRAY
49112: ST_TO_ADDR
49113: GO 49129
// tmp := target [ 1 ] ;
49115: LD_ADDR_VAR 0 5
49119: PUSH
49120: LD_VAR 0 6
49124: PUSH
49125: LD_INT 1
49127: ARRAY
49128: ST_TO_ADDR
// k := 0 ;
49129: LD_ADDR_VAR 0 4
49133: PUSH
49134: LD_INT 0
49136: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49137: LD_ADDR_VAR 0 3
49141: PUSH
49142: LD_EXP 127
49146: PUSH
49147: LD_VAR 0 2
49151: ARRAY
49152: PUSH
49153: FOR_IN
49154: IFFALSE 49314
// begin k := k + 1 ;
49156: LD_ADDR_VAR 0 4
49160: PUSH
49161: LD_VAR 0 4
49165: PUSH
49166: LD_INT 1
49168: PLUS
49169: ST_TO_ADDR
// if k > tmp then
49170: LD_VAR 0 4
49174: PUSH
49175: LD_VAR 0 5
49179: GREATER
49180: IFFALSE 49184
// break ;
49182: GO 49314
// if not GetClass ( j ) in [ 2 , 16 ] then
49184: LD_VAR 0 3
49188: PPUSH
49189: CALL_OW 257
49193: PUSH
49194: LD_INT 2
49196: PUSH
49197: LD_INT 16
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: IN
49204: NOT
49205: IFFALSE 49258
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49207: LD_ADDR_EXP 127
49211: PUSH
49212: LD_EXP 127
49216: PPUSH
49217: LD_VAR 0 2
49221: PPUSH
49222: LD_EXP 127
49226: PUSH
49227: LD_VAR 0 2
49231: ARRAY
49232: PUSH
49233: LD_VAR 0 3
49237: DIFF
49238: PPUSH
49239: CALL_OW 1
49243: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49244: LD_VAR 0 3
49248: PPUSH
49249: LD_INT 0
49251: PPUSH
49252: CALL_OW 109
// continue ;
49256: GO 49153
// end ; if IsInUnit ( j ) then
49258: LD_VAR 0 3
49262: PPUSH
49263: CALL_OW 310
49267: IFFALSE 49278
// ComExitBuilding ( j ) ;
49269: LD_VAR 0 3
49273: PPUSH
49274: CALL_OW 122
// wait ( 3 ) ;
49278: LD_INT 3
49280: PPUSH
49281: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49285: LD_VAR 0 3
49289: PPUSH
49290: LD_VAR 0 6
49294: PUSH
49295: LD_INT 2
49297: ARRAY
49298: PPUSH
49299: LD_VAR 0 6
49303: PUSH
49304: LD_INT 3
49306: ARRAY
49307: PPUSH
49308: CALL_OW 117
// end ;
49312: GO 49153
49314: POP
49315: POP
// end ; end else
49316: GO 49897
// begin for j in cargo do
49318: LD_ADDR_VAR 0 3
49322: PUSH
49323: LD_VAR 0 7
49327: PUSH
49328: FOR_IN
49329: IFFALSE 49895
// begin if GetTag ( j ) <> 0 then
49331: LD_VAR 0 3
49335: PPUSH
49336: CALL_OW 110
49340: PUSH
49341: LD_INT 0
49343: NONEQUAL
49344: IFFALSE 49348
// continue ;
49346: GO 49328
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49348: LD_VAR 0 3
49352: PPUSH
49353: CALL_OW 256
49357: PUSH
49358: LD_INT 1000
49360: LESS
49361: PUSH
49362: LD_VAR 0 3
49366: PPUSH
49367: LD_EXP 134
49371: PUSH
49372: LD_VAR 0 2
49376: ARRAY
49377: PPUSH
49378: CALL_OW 308
49382: NOT
49383: AND
49384: IFFALSE 49406
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49386: LD_VAR 0 3
49390: PPUSH
49391: LD_EXP 134
49395: PUSH
49396: LD_VAR 0 2
49400: ARRAY
49401: PPUSH
49402: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49406: LD_VAR 0 3
49410: PPUSH
49411: CALL_OW 256
49415: PUSH
49416: LD_INT 1000
49418: LESS
49419: PUSH
49420: LD_VAR 0 3
49424: PPUSH
49425: LD_EXP 134
49429: PUSH
49430: LD_VAR 0 2
49434: ARRAY
49435: PPUSH
49436: CALL_OW 308
49440: AND
49441: IFFALSE 49445
// continue ;
49443: GO 49328
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49445: LD_VAR 0 3
49449: PPUSH
49450: CALL_OW 262
49454: PUSH
49455: LD_INT 2
49457: EQUAL
49458: PUSH
49459: LD_VAR 0 3
49463: PPUSH
49464: CALL_OW 261
49468: PUSH
49469: LD_INT 15
49471: LESS
49472: AND
49473: IFFALSE 49477
// continue ;
49475: GO 49328
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49477: LD_VAR 0 3
49481: PPUSH
49482: CALL_OW 262
49486: PUSH
49487: LD_INT 1
49489: EQUAL
49490: PUSH
49491: LD_VAR 0 3
49495: PPUSH
49496: CALL_OW 261
49500: PUSH
49501: LD_INT 10
49503: LESS
49504: AND
49505: IFFALSE 49834
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49507: LD_ADDR_VAR 0 8
49511: PUSH
49512: LD_EXP 110
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PPUSH
49523: LD_INT 2
49525: PUSH
49526: LD_INT 30
49528: PUSH
49529: LD_INT 0
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PUSH
49536: LD_INT 30
49538: PUSH
49539: LD_INT 1
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: LIST
49550: PPUSH
49551: CALL_OW 72
49555: ST_TO_ADDR
// if not depot then
49556: LD_VAR 0 8
49560: NOT
49561: IFFALSE 49565
// continue ;
49563: GO 49328
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49565: LD_VAR 0 3
49569: PPUSH
49570: LD_VAR 0 8
49574: PPUSH
49575: LD_VAR 0 3
49579: PPUSH
49580: CALL_OW 74
49584: PPUSH
49585: CALL_OW 296
49589: PUSH
49590: LD_INT 6
49592: LESS
49593: IFFALSE 49609
// SetFuel ( j , 100 ) else
49595: LD_VAR 0 3
49599: PPUSH
49600: LD_INT 100
49602: PPUSH
49603: CALL_OW 240
49607: GO 49834
// if GetFuel ( j ) = 0 then
49609: LD_VAR 0 3
49613: PPUSH
49614: CALL_OW 261
49618: PUSH
49619: LD_INT 0
49621: EQUAL
49622: IFFALSE 49834
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49624: LD_ADDR_EXP 129
49628: PUSH
49629: LD_EXP 129
49633: PPUSH
49634: LD_VAR 0 2
49638: PPUSH
49639: LD_EXP 129
49643: PUSH
49644: LD_VAR 0 2
49648: ARRAY
49649: PUSH
49650: LD_VAR 0 3
49654: DIFF
49655: PPUSH
49656: CALL_OW 1
49660: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49661: LD_VAR 0 3
49665: PPUSH
49666: CALL_OW 263
49670: PUSH
49671: LD_INT 1
49673: EQUAL
49674: IFFALSE 49690
// ComExitVehicle ( IsInUnit ( j ) ) ;
49676: LD_VAR 0 3
49680: PPUSH
49681: CALL_OW 310
49685: PPUSH
49686: CALL_OW 121
// if GetControl ( j ) = control_remote then
49690: LD_VAR 0 3
49694: PPUSH
49695: CALL_OW 263
49699: PUSH
49700: LD_INT 2
49702: EQUAL
49703: IFFALSE 49714
// ComUnlink ( j ) ;
49705: LD_VAR 0 3
49709: PPUSH
49710: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49714: LD_ADDR_VAR 0 9
49718: PUSH
49719: LD_VAR 0 2
49723: PPUSH
49724: LD_INT 3
49726: PPUSH
49727: CALL 59187 0 2
49731: ST_TO_ADDR
// if fac then
49732: LD_VAR 0 9
49736: IFFALSE 49832
// begin for k in fac do
49738: LD_ADDR_VAR 0 4
49742: PUSH
49743: LD_VAR 0 9
49747: PUSH
49748: FOR_IN
49749: IFFALSE 49830
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49751: LD_ADDR_VAR 0 10
49755: PUSH
49756: LD_VAR 0 9
49760: PPUSH
49761: LD_VAR 0 3
49765: PPUSH
49766: CALL_OW 265
49770: PPUSH
49771: LD_VAR 0 3
49775: PPUSH
49776: CALL_OW 262
49780: PPUSH
49781: LD_VAR 0 3
49785: PPUSH
49786: CALL_OW 263
49790: PPUSH
49791: LD_VAR 0 3
49795: PPUSH
49796: CALL_OW 264
49800: PPUSH
49801: CALL 67554 0 5
49805: ST_TO_ADDR
// if components then
49806: LD_VAR 0 10
49810: IFFALSE 49828
// begin MC_InsertProduceList ( i , components ) ;
49812: LD_VAR 0 2
49816: PPUSH
49817: LD_VAR 0 10
49821: PPUSH
49822: CALL 58732 0 2
// break ;
49826: GO 49830
// end ; end ;
49828: GO 49748
49830: POP
49831: POP
// end ; continue ;
49832: GO 49328
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49834: LD_VAR 0 3
49838: PPUSH
49839: LD_INT 1
49841: PPUSH
49842: CALL_OW 289
49846: PUSH
49847: LD_INT 100
49849: LESS
49850: PUSH
49851: LD_VAR 0 3
49855: PPUSH
49856: CALL_OW 314
49860: NOT
49861: AND
49862: IFFALSE 49891
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49864: LD_VAR 0 3
49868: PPUSH
49869: LD_VAR 0 6
49873: PUSH
49874: LD_INT 2
49876: ARRAY
49877: PPUSH
49878: LD_VAR 0 6
49882: PUSH
49883: LD_INT 3
49885: ARRAY
49886: PPUSH
49887: CALL_OW 117
// break ;
49891: GO 49895
// end ;
49893: GO 49328
49895: POP
49896: POP
// end ; end ;
49897: GO 48166
49899: POP
49900: POP
// end ;
49901: LD_VAR 0 1
49905: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49906: LD_INT 0
49908: PPUSH
49909: PPUSH
49910: PPUSH
49911: PPUSH
// if not mc_bases then
49912: LD_EXP 110
49916: NOT
49917: IFFALSE 49921
// exit ;
49919: GO 50082
// for i = 1 to mc_bases do
49921: LD_ADDR_VAR 0 2
49925: PUSH
49926: DOUBLE
49927: LD_INT 1
49929: DEC
49930: ST_TO_ADDR
49931: LD_EXP 110
49935: PUSH
49936: FOR_TO
49937: IFFALSE 50080
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49939: LD_ADDR_VAR 0 4
49943: PUSH
49944: LD_EXP 129
49948: PUSH
49949: LD_VAR 0 2
49953: ARRAY
49954: PUSH
49955: LD_EXP 132
49959: PUSH
49960: LD_VAR 0 2
49964: ARRAY
49965: UNION
49966: PPUSH
49967: LD_INT 33
49969: PUSH
49970: LD_INT 2
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PPUSH
49977: CALL_OW 72
49981: ST_TO_ADDR
// if tmp then
49982: LD_VAR 0 4
49986: IFFALSE 50078
// for j in tmp do
49988: LD_ADDR_VAR 0 3
49992: PUSH
49993: LD_VAR 0 4
49997: PUSH
49998: FOR_IN
49999: IFFALSE 50076
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50001: LD_VAR 0 3
50005: PPUSH
50006: CALL_OW 312
50010: NOT
50011: PUSH
50012: LD_VAR 0 3
50016: PPUSH
50017: CALL_OW 256
50021: PUSH
50022: LD_INT 250
50024: GREATEREQUAL
50025: AND
50026: IFFALSE 50039
// Connect ( j ) else
50028: LD_VAR 0 3
50032: PPUSH
50033: CALL 72955 0 1
50037: GO 50074
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50039: LD_VAR 0 3
50043: PPUSH
50044: CALL_OW 256
50048: PUSH
50049: LD_INT 250
50051: LESS
50052: PUSH
50053: LD_VAR 0 3
50057: PPUSH
50058: CALL_OW 312
50062: AND
50063: IFFALSE 50074
// ComUnlink ( j ) ;
50065: LD_VAR 0 3
50069: PPUSH
50070: CALL_OW 136
50074: GO 49998
50076: POP
50077: POP
// end ;
50078: GO 49936
50080: POP
50081: POP
// end ;
50082: LD_VAR 0 1
50086: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50087: LD_INT 0
50089: PPUSH
50090: PPUSH
50091: PPUSH
50092: PPUSH
50093: PPUSH
// if not mc_bases then
50094: LD_EXP 110
50098: NOT
50099: IFFALSE 50103
// exit ;
50101: GO 50548
// for i = 1 to mc_bases do
50103: LD_ADDR_VAR 0 2
50107: PUSH
50108: DOUBLE
50109: LD_INT 1
50111: DEC
50112: ST_TO_ADDR
50113: LD_EXP 110
50117: PUSH
50118: FOR_TO
50119: IFFALSE 50546
// begin if not mc_produce [ i ] then
50121: LD_EXP 131
50125: PUSH
50126: LD_VAR 0 2
50130: ARRAY
50131: NOT
50132: IFFALSE 50136
// continue ;
50134: GO 50118
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50136: LD_ADDR_VAR 0 5
50140: PUSH
50141: LD_EXP 110
50145: PUSH
50146: LD_VAR 0 2
50150: ARRAY
50151: PPUSH
50152: LD_INT 30
50154: PUSH
50155: LD_INT 3
50157: PUSH
50158: EMPTY
50159: LIST
50160: LIST
50161: PPUSH
50162: CALL_OW 72
50166: ST_TO_ADDR
// if not fac then
50167: LD_VAR 0 5
50171: NOT
50172: IFFALSE 50176
// continue ;
50174: GO 50118
// for j in fac do
50176: LD_ADDR_VAR 0 3
50180: PUSH
50181: LD_VAR 0 5
50185: PUSH
50186: FOR_IN
50187: IFFALSE 50542
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50189: LD_VAR 0 3
50193: PPUSH
50194: CALL_OW 461
50198: PUSH
50199: LD_INT 2
50201: NONEQUAL
50202: PUSH
50203: LD_VAR 0 3
50207: PPUSH
50208: LD_INT 15
50210: PPUSH
50211: CALL 72615 0 2
50215: PUSH
50216: LD_INT 4
50218: ARRAY
50219: OR
50220: IFFALSE 50224
// continue ;
50222: GO 50186
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50224: LD_VAR 0 3
50228: PPUSH
50229: LD_EXP 131
50233: PUSH
50234: LD_VAR 0 2
50238: ARRAY
50239: PUSH
50240: LD_INT 1
50242: ARRAY
50243: PUSH
50244: LD_INT 1
50246: ARRAY
50247: PPUSH
50248: LD_EXP 131
50252: PUSH
50253: LD_VAR 0 2
50257: ARRAY
50258: PUSH
50259: LD_INT 1
50261: ARRAY
50262: PUSH
50263: LD_INT 2
50265: ARRAY
50266: PPUSH
50267: LD_EXP 131
50271: PUSH
50272: LD_VAR 0 2
50276: ARRAY
50277: PUSH
50278: LD_INT 1
50280: ARRAY
50281: PUSH
50282: LD_INT 3
50284: ARRAY
50285: PPUSH
50286: LD_EXP 131
50290: PUSH
50291: LD_VAR 0 2
50295: ARRAY
50296: PUSH
50297: LD_INT 1
50299: ARRAY
50300: PUSH
50301: LD_INT 4
50303: ARRAY
50304: PPUSH
50305: CALL_OW 448
50309: PUSH
50310: LD_VAR 0 3
50314: PPUSH
50315: LD_EXP 131
50319: PUSH
50320: LD_VAR 0 2
50324: ARRAY
50325: PUSH
50326: LD_INT 1
50328: ARRAY
50329: PUSH
50330: LD_INT 1
50332: ARRAY
50333: PUSH
50334: LD_EXP 131
50338: PUSH
50339: LD_VAR 0 2
50343: ARRAY
50344: PUSH
50345: LD_INT 1
50347: ARRAY
50348: PUSH
50349: LD_INT 2
50351: ARRAY
50352: PUSH
50353: LD_EXP 131
50357: PUSH
50358: LD_VAR 0 2
50362: ARRAY
50363: PUSH
50364: LD_INT 1
50366: ARRAY
50367: PUSH
50368: LD_INT 3
50370: ARRAY
50371: PUSH
50372: LD_EXP 131
50376: PUSH
50377: LD_VAR 0 2
50381: ARRAY
50382: PUSH
50383: LD_INT 1
50385: ARRAY
50386: PUSH
50387: LD_INT 4
50389: ARRAY
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: LIST
50395: LIST
50396: PPUSH
50397: CALL 76286 0 2
50401: AND
50402: IFFALSE 50540
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50404: LD_VAR 0 3
50408: PPUSH
50409: LD_EXP 131
50413: PUSH
50414: LD_VAR 0 2
50418: ARRAY
50419: PUSH
50420: LD_INT 1
50422: ARRAY
50423: PUSH
50424: LD_INT 1
50426: ARRAY
50427: PPUSH
50428: LD_EXP 131
50432: PUSH
50433: LD_VAR 0 2
50437: ARRAY
50438: PUSH
50439: LD_INT 1
50441: ARRAY
50442: PUSH
50443: LD_INT 2
50445: ARRAY
50446: PPUSH
50447: LD_EXP 131
50451: PUSH
50452: LD_VAR 0 2
50456: ARRAY
50457: PUSH
50458: LD_INT 1
50460: ARRAY
50461: PUSH
50462: LD_INT 3
50464: ARRAY
50465: PPUSH
50466: LD_EXP 131
50470: PUSH
50471: LD_VAR 0 2
50475: ARRAY
50476: PUSH
50477: LD_INT 1
50479: ARRAY
50480: PUSH
50481: LD_INT 4
50483: ARRAY
50484: PPUSH
50485: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50489: LD_ADDR_VAR 0 4
50493: PUSH
50494: LD_EXP 131
50498: PUSH
50499: LD_VAR 0 2
50503: ARRAY
50504: PPUSH
50505: LD_INT 1
50507: PPUSH
50508: CALL_OW 3
50512: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50513: LD_ADDR_EXP 131
50517: PUSH
50518: LD_EXP 131
50522: PPUSH
50523: LD_VAR 0 2
50527: PPUSH
50528: LD_VAR 0 4
50532: PPUSH
50533: CALL_OW 1
50537: ST_TO_ADDR
// break ;
50538: GO 50542
// end ; end ;
50540: GO 50186
50542: POP
50543: POP
// end ;
50544: GO 50118
50546: POP
50547: POP
// end ;
50548: LD_VAR 0 1
50552: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50553: LD_INT 0
50555: PPUSH
50556: PPUSH
50557: PPUSH
// if not mc_bases then
50558: LD_EXP 110
50562: NOT
50563: IFFALSE 50567
// exit ;
50565: GO 50656
// for i = 1 to mc_bases do
50567: LD_ADDR_VAR 0 2
50571: PUSH
50572: DOUBLE
50573: LD_INT 1
50575: DEC
50576: ST_TO_ADDR
50577: LD_EXP 110
50581: PUSH
50582: FOR_TO
50583: IFFALSE 50654
// begin if mc_attack [ i ] then
50585: LD_EXP 130
50589: PUSH
50590: LD_VAR 0 2
50594: ARRAY
50595: IFFALSE 50652
// begin tmp := mc_attack [ i ] [ 1 ] ;
50597: LD_ADDR_VAR 0 3
50601: PUSH
50602: LD_EXP 130
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50617: LD_ADDR_EXP 130
50621: PUSH
50622: LD_EXP 130
50626: PPUSH
50627: LD_VAR 0 2
50631: PPUSH
50632: EMPTY
50633: PPUSH
50634: CALL_OW 1
50638: ST_TO_ADDR
// Attack ( tmp ) ;
50639: LD_VAR 0 3
50643: PPUSH
50644: CALL 113051 0 1
// exit ;
50648: POP
50649: POP
50650: GO 50656
// end ; end ;
50652: GO 50582
50654: POP
50655: POP
// end ;
50656: LD_VAR 0 1
50660: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50661: LD_INT 0
50663: PPUSH
50664: PPUSH
50665: PPUSH
50666: PPUSH
50667: PPUSH
50668: PPUSH
50669: PPUSH
// if not mc_bases then
50670: LD_EXP 110
50674: NOT
50675: IFFALSE 50679
// exit ;
50677: GO 51261
// for i = 1 to mc_bases do
50679: LD_ADDR_VAR 0 2
50683: PUSH
50684: DOUBLE
50685: LD_INT 1
50687: DEC
50688: ST_TO_ADDR
50689: LD_EXP 110
50693: PUSH
50694: FOR_TO
50695: IFFALSE 51259
// begin if not mc_bases [ i ] then
50697: LD_EXP 110
50701: PUSH
50702: LD_VAR 0 2
50706: ARRAY
50707: NOT
50708: IFFALSE 50712
// continue ;
50710: GO 50694
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50712: LD_ADDR_VAR 0 7
50716: PUSH
50717: LD_EXP 110
50721: PUSH
50722: LD_VAR 0 2
50726: ARRAY
50727: PUSH
50728: LD_INT 1
50730: ARRAY
50731: PPUSH
50732: CALL 66858 0 1
50736: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50737: LD_ADDR_EXP 133
50741: PUSH
50742: LD_EXP 133
50746: PPUSH
50747: LD_VAR 0 2
50751: PPUSH
50752: LD_EXP 110
50756: PUSH
50757: LD_VAR 0 2
50761: ARRAY
50762: PUSH
50763: LD_INT 1
50765: ARRAY
50766: PPUSH
50767: CALL_OW 255
50771: PPUSH
50772: LD_EXP 135
50776: PUSH
50777: LD_VAR 0 2
50781: ARRAY
50782: PPUSH
50783: CALL 66823 0 2
50787: PPUSH
50788: CALL_OW 1
50792: ST_TO_ADDR
// if not mc_scan [ i ] then
50793: LD_EXP 133
50797: PUSH
50798: LD_VAR 0 2
50802: ARRAY
50803: NOT
50804: IFFALSE 50959
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50806: LD_ADDR_VAR 0 4
50810: PUSH
50811: LD_EXP 110
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PPUSH
50822: LD_INT 2
50824: PUSH
50825: LD_INT 25
50827: PUSH
50828: LD_INT 5
50830: PUSH
50831: EMPTY
50832: LIST
50833: LIST
50834: PUSH
50835: LD_INT 25
50837: PUSH
50838: LD_INT 8
50840: PUSH
50841: EMPTY
50842: LIST
50843: LIST
50844: PUSH
50845: LD_INT 25
50847: PUSH
50848: LD_INT 9
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: PUSH
50855: EMPTY
50856: LIST
50857: LIST
50858: LIST
50859: LIST
50860: PPUSH
50861: CALL_OW 72
50865: ST_TO_ADDR
// if not tmp then
50866: LD_VAR 0 4
50870: NOT
50871: IFFALSE 50875
// continue ;
50873: GO 50694
// for j in tmp do
50875: LD_ADDR_VAR 0 3
50879: PUSH
50880: LD_VAR 0 4
50884: PUSH
50885: FOR_IN
50886: IFFALSE 50957
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50888: LD_VAR 0 3
50892: PPUSH
50893: CALL_OW 310
50897: PPUSH
50898: CALL_OW 266
50902: PUSH
50903: LD_INT 5
50905: EQUAL
50906: PUSH
50907: LD_VAR 0 3
50911: PPUSH
50912: CALL_OW 257
50916: PUSH
50917: LD_INT 1
50919: EQUAL
50920: AND
50921: PUSH
50922: LD_VAR 0 3
50926: PPUSH
50927: CALL_OW 459
50931: NOT
50932: AND
50933: PUSH
50934: LD_VAR 0 7
50938: AND
50939: IFFALSE 50955
// ComChangeProfession ( j , class ) ;
50941: LD_VAR 0 3
50945: PPUSH
50946: LD_VAR 0 7
50950: PPUSH
50951: CALL_OW 123
50955: GO 50885
50957: POP
50958: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50959: LD_EXP 133
50963: PUSH
50964: LD_VAR 0 2
50968: ARRAY
50969: PUSH
50970: LD_EXP 132
50974: PUSH
50975: LD_VAR 0 2
50979: ARRAY
50980: NOT
50981: AND
50982: PUSH
50983: LD_EXP 110
50987: PUSH
50988: LD_VAR 0 2
50992: ARRAY
50993: PPUSH
50994: LD_INT 30
50996: PUSH
50997: LD_INT 32
50999: PUSH
51000: EMPTY
51001: LIST
51002: LIST
51003: PPUSH
51004: CALL_OW 72
51008: NOT
51009: AND
51010: PUSH
51011: LD_EXP 110
51015: PUSH
51016: LD_VAR 0 2
51020: ARRAY
51021: PPUSH
51022: LD_INT 2
51024: PUSH
51025: LD_INT 30
51027: PUSH
51028: LD_INT 4
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: PUSH
51035: LD_INT 30
51037: PUSH
51038: LD_INT 5
51040: PUSH
51041: EMPTY
51042: LIST
51043: LIST
51044: PUSH
51045: EMPTY
51046: LIST
51047: LIST
51048: LIST
51049: PPUSH
51050: CALL_OW 72
51054: NOT
51055: AND
51056: IFFALSE 51188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51058: LD_ADDR_VAR 0 4
51062: PUSH
51063: LD_EXP 110
51067: PUSH
51068: LD_VAR 0 2
51072: ARRAY
51073: PPUSH
51074: LD_INT 2
51076: PUSH
51077: LD_INT 25
51079: PUSH
51080: LD_INT 1
51082: PUSH
51083: EMPTY
51084: LIST
51085: LIST
51086: PUSH
51087: LD_INT 25
51089: PUSH
51090: LD_INT 5
51092: PUSH
51093: EMPTY
51094: LIST
51095: LIST
51096: PUSH
51097: LD_INT 25
51099: PUSH
51100: LD_INT 8
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: PUSH
51107: LD_INT 25
51109: PUSH
51110: LD_INT 9
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: PPUSH
51124: CALL_OW 72
51128: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51129: LD_ADDR_VAR 0 4
51133: PUSH
51134: LD_VAR 0 4
51138: PUSH
51139: LD_VAR 0 4
51143: PPUSH
51144: LD_INT 18
51146: PPUSH
51147: CALL 98583 0 2
51151: DIFF
51152: ST_TO_ADDR
// if tmp then
51153: LD_VAR 0 4
51157: IFFALSE 51188
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51159: LD_VAR 0 2
51163: PPUSH
51164: LD_VAR 0 4
51168: PPUSH
51169: LD_EXP 135
51173: PUSH
51174: LD_VAR 0 2
51178: ARRAY
51179: PPUSH
51180: CALL 117760 0 3
// exit ;
51184: POP
51185: POP
51186: GO 51261
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51188: LD_EXP 133
51192: PUSH
51193: LD_VAR 0 2
51197: ARRAY
51198: PUSH
51199: LD_EXP 132
51203: PUSH
51204: LD_VAR 0 2
51208: ARRAY
51209: AND
51210: IFFALSE 51257
// begin tmp := mc_defender [ i ] ;
51212: LD_ADDR_VAR 0 4
51216: PUSH
51217: LD_EXP 132
51221: PUSH
51222: LD_VAR 0 2
51226: ARRAY
51227: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51228: LD_VAR 0 2
51232: PPUSH
51233: LD_VAR 0 4
51237: PPUSH
51238: LD_EXP 133
51242: PUSH
51243: LD_VAR 0 2
51247: ARRAY
51248: PPUSH
51249: CALL 118321 0 3
// exit ;
51253: POP
51254: POP
51255: GO 51261
// end ; end ;
51257: GO 50694
51259: POP
51260: POP
// end ;
51261: LD_VAR 0 1
51265: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51266: LD_INT 0
51268: PPUSH
51269: PPUSH
51270: PPUSH
51271: PPUSH
51272: PPUSH
51273: PPUSH
51274: PPUSH
51275: PPUSH
51276: PPUSH
51277: PPUSH
51278: PPUSH
// if not mc_bases then
51279: LD_EXP 110
51283: NOT
51284: IFFALSE 51288
// exit ;
51286: GO 52375
// for i = 1 to mc_bases do
51288: LD_ADDR_VAR 0 2
51292: PUSH
51293: DOUBLE
51294: LD_INT 1
51296: DEC
51297: ST_TO_ADDR
51298: LD_EXP 110
51302: PUSH
51303: FOR_TO
51304: IFFALSE 52373
// begin tmp := mc_lab [ i ] ;
51306: LD_ADDR_VAR 0 6
51310: PUSH
51311: LD_EXP 143
51315: PUSH
51316: LD_VAR 0 2
51320: ARRAY
51321: ST_TO_ADDR
// if not tmp then
51322: LD_VAR 0 6
51326: NOT
51327: IFFALSE 51331
// continue ;
51329: GO 51303
// idle_lab := 0 ;
51331: LD_ADDR_VAR 0 11
51335: PUSH
51336: LD_INT 0
51338: ST_TO_ADDR
// for j in tmp do
51339: LD_ADDR_VAR 0 3
51343: PUSH
51344: LD_VAR 0 6
51348: PUSH
51349: FOR_IN
51350: IFFALSE 52369
// begin researching := false ;
51352: LD_ADDR_VAR 0 10
51356: PUSH
51357: LD_INT 0
51359: ST_TO_ADDR
// side := GetSide ( j ) ;
51360: LD_ADDR_VAR 0 4
51364: PUSH
51365: LD_VAR 0 3
51369: PPUSH
51370: CALL_OW 255
51374: ST_TO_ADDR
// if not mc_tech [ side ] then
51375: LD_EXP 137
51379: PUSH
51380: LD_VAR 0 4
51384: ARRAY
51385: NOT
51386: IFFALSE 51390
// continue ;
51388: GO 51349
// if BuildingStatus ( j ) = bs_idle then
51390: LD_VAR 0 3
51394: PPUSH
51395: CALL_OW 461
51399: PUSH
51400: LD_INT 2
51402: EQUAL
51403: IFFALSE 51591
// begin if idle_lab and UnitsInside ( j ) < 6 then
51405: LD_VAR 0 11
51409: PUSH
51410: LD_VAR 0 3
51414: PPUSH
51415: CALL_OW 313
51419: PUSH
51420: LD_INT 6
51422: LESS
51423: AND
51424: IFFALSE 51495
// begin tmp2 := UnitsInside ( idle_lab ) ;
51426: LD_ADDR_VAR 0 9
51430: PUSH
51431: LD_VAR 0 11
51435: PPUSH
51436: CALL_OW 313
51440: ST_TO_ADDR
// if tmp2 then
51441: LD_VAR 0 9
51445: IFFALSE 51487
// for x in tmp2 do
51447: LD_ADDR_VAR 0 7
51451: PUSH
51452: LD_VAR 0 9
51456: PUSH
51457: FOR_IN
51458: IFFALSE 51485
// begin ComExitBuilding ( x ) ;
51460: LD_VAR 0 7
51464: PPUSH
51465: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51469: LD_VAR 0 7
51473: PPUSH
51474: LD_VAR 0 3
51478: PPUSH
51479: CALL_OW 180
// end ;
51483: GO 51457
51485: POP
51486: POP
// idle_lab := 0 ;
51487: LD_ADDR_VAR 0 11
51491: PUSH
51492: LD_INT 0
51494: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51495: LD_ADDR_VAR 0 5
51499: PUSH
51500: LD_EXP 137
51504: PUSH
51505: LD_VAR 0 4
51509: ARRAY
51510: PUSH
51511: FOR_IN
51512: IFFALSE 51572
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51514: LD_VAR 0 3
51518: PPUSH
51519: LD_VAR 0 5
51523: PPUSH
51524: CALL_OW 430
51528: PUSH
51529: LD_VAR 0 4
51533: PPUSH
51534: LD_VAR 0 5
51538: PPUSH
51539: CALL 65928 0 2
51543: AND
51544: IFFALSE 51570
// begin researching := true ;
51546: LD_ADDR_VAR 0 10
51550: PUSH
51551: LD_INT 1
51553: ST_TO_ADDR
// ComResearch ( j , t ) ;
51554: LD_VAR 0 3
51558: PPUSH
51559: LD_VAR 0 5
51563: PPUSH
51564: CALL_OW 124
// break ;
51568: GO 51572
// end ;
51570: GO 51511
51572: POP
51573: POP
// if not researching then
51574: LD_VAR 0 10
51578: NOT
51579: IFFALSE 51591
// idle_lab := j ;
51581: LD_ADDR_VAR 0 11
51585: PUSH
51586: LD_VAR 0 3
51590: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51591: LD_VAR 0 3
51595: PPUSH
51596: CALL_OW 461
51600: PUSH
51601: LD_INT 10
51603: EQUAL
51604: IFFALSE 52192
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51606: LD_EXP 139
51610: PUSH
51611: LD_VAR 0 2
51615: ARRAY
51616: NOT
51617: PUSH
51618: LD_EXP 140
51622: PUSH
51623: LD_VAR 0 2
51627: ARRAY
51628: NOT
51629: AND
51630: PUSH
51631: LD_EXP 137
51635: PUSH
51636: LD_VAR 0 4
51640: ARRAY
51641: PUSH
51642: LD_INT 1
51644: GREATER
51645: AND
51646: IFFALSE 51777
// begin ComCancel ( j ) ;
51648: LD_VAR 0 3
51652: PPUSH
51653: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51657: LD_ADDR_EXP 137
51661: PUSH
51662: LD_EXP 137
51666: PPUSH
51667: LD_VAR 0 4
51671: PPUSH
51672: LD_EXP 137
51676: PUSH
51677: LD_VAR 0 4
51681: ARRAY
51682: PPUSH
51683: LD_EXP 137
51687: PUSH
51688: LD_VAR 0 4
51692: ARRAY
51693: PUSH
51694: LD_INT 1
51696: MINUS
51697: PPUSH
51698: LD_EXP 137
51702: PUSH
51703: LD_VAR 0 4
51707: ARRAY
51708: PPUSH
51709: LD_INT 0
51711: PPUSH
51712: CALL 69440 0 4
51716: PPUSH
51717: CALL_OW 1
51721: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51722: LD_ADDR_EXP 137
51726: PUSH
51727: LD_EXP 137
51731: PPUSH
51732: LD_VAR 0 4
51736: PPUSH
51737: LD_EXP 137
51741: PUSH
51742: LD_VAR 0 4
51746: ARRAY
51747: PPUSH
51748: LD_EXP 137
51752: PUSH
51753: LD_VAR 0 4
51757: ARRAY
51758: PPUSH
51759: LD_INT 1
51761: PPUSH
51762: LD_INT 0
51764: PPUSH
51765: CALL 69440 0 4
51769: PPUSH
51770: CALL_OW 1
51774: ST_TO_ADDR
// continue ;
51775: GO 51349
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51777: LD_EXP 139
51781: PUSH
51782: LD_VAR 0 2
51786: ARRAY
51787: PUSH
51788: LD_EXP 140
51792: PUSH
51793: LD_VAR 0 2
51797: ARRAY
51798: NOT
51799: AND
51800: IFFALSE 51927
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51802: LD_ADDR_EXP 140
51806: PUSH
51807: LD_EXP 140
51811: PPUSH
51812: LD_VAR 0 2
51816: PUSH
51817: LD_EXP 140
51821: PUSH
51822: LD_VAR 0 2
51826: ARRAY
51827: PUSH
51828: LD_INT 1
51830: PLUS
51831: PUSH
51832: EMPTY
51833: LIST
51834: LIST
51835: PPUSH
51836: LD_EXP 139
51840: PUSH
51841: LD_VAR 0 2
51845: ARRAY
51846: PUSH
51847: LD_INT 1
51849: ARRAY
51850: PPUSH
51851: CALL 70022 0 3
51855: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51856: LD_EXP 139
51860: PUSH
51861: LD_VAR 0 2
51865: ARRAY
51866: PUSH
51867: LD_INT 1
51869: ARRAY
51870: PPUSH
51871: LD_INT 112
51873: PPUSH
51874: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51878: LD_ADDR_VAR 0 9
51882: PUSH
51883: LD_EXP 139
51887: PUSH
51888: LD_VAR 0 2
51892: ARRAY
51893: PPUSH
51894: LD_INT 1
51896: PPUSH
51897: CALL_OW 3
51901: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51902: LD_ADDR_EXP 139
51906: PUSH
51907: LD_EXP 139
51911: PPUSH
51912: LD_VAR 0 2
51916: PPUSH
51917: LD_VAR 0 9
51921: PPUSH
51922: CALL_OW 1
51926: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51927: LD_EXP 139
51931: PUSH
51932: LD_VAR 0 2
51936: ARRAY
51937: PUSH
51938: LD_EXP 140
51942: PUSH
51943: LD_VAR 0 2
51947: ARRAY
51948: AND
51949: PUSH
51950: LD_EXP 140
51954: PUSH
51955: LD_VAR 0 2
51959: ARRAY
51960: PUSH
51961: LD_INT 1
51963: ARRAY
51964: PPUSH
51965: CALL_OW 310
51969: NOT
51970: AND
51971: PUSH
51972: LD_VAR 0 3
51976: PPUSH
51977: CALL_OW 313
51981: PUSH
51982: LD_INT 6
51984: EQUAL
51985: AND
51986: IFFALSE 52042
// begin tmp2 := UnitsInside ( j ) ;
51988: LD_ADDR_VAR 0 9
51992: PUSH
51993: LD_VAR 0 3
51997: PPUSH
51998: CALL_OW 313
52002: ST_TO_ADDR
// if tmp2 = 6 then
52003: LD_VAR 0 9
52007: PUSH
52008: LD_INT 6
52010: EQUAL
52011: IFFALSE 52042
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52013: LD_VAR 0 9
52017: PUSH
52018: LD_INT 1
52020: ARRAY
52021: PPUSH
52022: LD_INT 112
52024: PPUSH
52025: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52029: LD_VAR 0 9
52033: PUSH
52034: LD_INT 1
52036: ARRAY
52037: PPUSH
52038: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52042: LD_EXP 140
52046: PUSH
52047: LD_VAR 0 2
52051: ARRAY
52052: PUSH
52053: LD_EXP 140
52057: PUSH
52058: LD_VAR 0 2
52062: ARRAY
52063: PUSH
52064: LD_INT 1
52066: ARRAY
52067: PPUSH
52068: CALL_OW 314
52072: NOT
52073: AND
52074: PUSH
52075: LD_EXP 140
52079: PUSH
52080: LD_VAR 0 2
52084: ARRAY
52085: PUSH
52086: LD_INT 1
52088: ARRAY
52089: PPUSH
52090: CALL_OW 310
52094: NOT
52095: AND
52096: IFFALSE 52122
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52098: LD_EXP 140
52102: PUSH
52103: LD_VAR 0 2
52107: ARRAY
52108: PUSH
52109: LD_INT 1
52111: ARRAY
52112: PPUSH
52113: LD_VAR 0 3
52117: PPUSH
52118: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52122: LD_EXP 140
52126: PUSH
52127: LD_VAR 0 2
52131: ARRAY
52132: PUSH
52133: LD_INT 1
52135: ARRAY
52136: PPUSH
52137: CALL_OW 310
52141: PUSH
52142: LD_EXP 140
52146: PUSH
52147: LD_VAR 0 2
52151: ARRAY
52152: PUSH
52153: LD_INT 1
52155: ARRAY
52156: PPUSH
52157: CALL_OW 310
52161: PPUSH
52162: CALL_OW 461
52166: PUSH
52167: LD_INT 3
52169: NONEQUAL
52170: AND
52171: IFFALSE 52192
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52173: LD_EXP 140
52177: PUSH
52178: LD_VAR 0 2
52182: ARRAY
52183: PUSH
52184: LD_INT 1
52186: ARRAY
52187: PPUSH
52188: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52192: LD_VAR 0 3
52196: PPUSH
52197: CALL_OW 461
52201: PUSH
52202: LD_INT 6
52204: EQUAL
52205: PUSH
52206: LD_VAR 0 6
52210: PUSH
52211: LD_INT 1
52213: GREATER
52214: AND
52215: IFFALSE 52367
// begin sci := [ ] ;
52217: LD_ADDR_VAR 0 8
52221: PUSH
52222: EMPTY
52223: ST_TO_ADDR
// for x in ( tmp diff j ) do
52224: LD_ADDR_VAR 0 7
52228: PUSH
52229: LD_VAR 0 6
52233: PUSH
52234: LD_VAR 0 3
52238: DIFF
52239: PUSH
52240: FOR_IN
52241: IFFALSE 52293
// begin if sci = 6 then
52243: LD_VAR 0 8
52247: PUSH
52248: LD_INT 6
52250: EQUAL
52251: IFFALSE 52255
// break ;
52253: GO 52293
// if BuildingStatus ( x ) = bs_idle then
52255: LD_VAR 0 7
52259: PPUSH
52260: CALL_OW 461
52264: PUSH
52265: LD_INT 2
52267: EQUAL
52268: IFFALSE 52291
// sci := sci ^ UnitsInside ( x ) ;
52270: LD_ADDR_VAR 0 8
52274: PUSH
52275: LD_VAR 0 8
52279: PUSH
52280: LD_VAR 0 7
52284: PPUSH
52285: CALL_OW 313
52289: ADD
52290: ST_TO_ADDR
// end ;
52291: GO 52240
52293: POP
52294: POP
// if not sci then
52295: LD_VAR 0 8
52299: NOT
52300: IFFALSE 52304
// continue ;
52302: GO 51349
// for x in sci do
52304: LD_ADDR_VAR 0 7
52308: PUSH
52309: LD_VAR 0 8
52313: PUSH
52314: FOR_IN
52315: IFFALSE 52365
// if IsInUnit ( x ) and not HasTask ( x ) then
52317: LD_VAR 0 7
52321: PPUSH
52322: CALL_OW 310
52326: PUSH
52327: LD_VAR 0 7
52331: PPUSH
52332: CALL_OW 314
52336: NOT
52337: AND
52338: IFFALSE 52363
// begin ComExitBuilding ( x ) ;
52340: LD_VAR 0 7
52344: PPUSH
52345: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52349: LD_VAR 0 7
52353: PPUSH
52354: LD_VAR 0 3
52358: PPUSH
52359: CALL_OW 180
// end ;
52363: GO 52314
52365: POP
52366: POP
// end ; end ;
52367: GO 51349
52369: POP
52370: POP
// end ;
52371: GO 51303
52373: POP
52374: POP
// end ;
52375: LD_VAR 0 1
52379: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52380: LD_INT 0
52382: PPUSH
52383: PPUSH
// if not mc_bases then
52384: LD_EXP 110
52388: NOT
52389: IFFALSE 52393
// exit ;
52391: GO 52474
// for i = 1 to mc_bases do
52393: LD_ADDR_VAR 0 2
52397: PUSH
52398: DOUBLE
52399: LD_INT 1
52401: DEC
52402: ST_TO_ADDR
52403: LD_EXP 110
52407: PUSH
52408: FOR_TO
52409: IFFALSE 52472
// if mc_mines [ i ] and mc_miners [ i ] then
52411: LD_EXP 123
52415: PUSH
52416: LD_VAR 0 2
52420: ARRAY
52421: PUSH
52422: LD_EXP 124
52426: PUSH
52427: LD_VAR 0 2
52431: ARRAY
52432: AND
52433: IFFALSE 52470
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52435: LD_EXP 124
52439: PUSH
52440: LD_VAR 0 2
52444: ARRAY
52445: PUSH
52446: LD_INT 1
52448: ARRAY
52449: PPUSH
52450: CALL_OW 255
52454: PPUSH
52455: LD_EXP 123
52459: PUSH
52460: LD_VAR 0 2
52464: ARRAY
52465: PPUSH
52466: CALL 67011 0 2
52470: GO 52408
52472: POP
52473: POP
// end ;
52474: LD_VAR 0 1
52478: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52479: LD_INT 0
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
52485: PPUSH
52486: PPUSH
52487: PPUSH
52488: PPUSH
// if not mc_bases or not mc_parking then
52489: LD_EXP 110
52493: NOT
52494: PUSH
52495: LD_EXP 134
52499: NOT
52500: OR
52501: IFFALSE 52505
// exit ;
52503: GO 53204
// for i = 1 to mc_bases do
52505: LD_ADDR_VAR 0 2
52509: PUSH
52510: DOUBLE
52511: LD_INT 1
52513: DEC
52514: ST_TO_ADDR
52515: LD_EXP 110
52519: PUSH
52520: FOR_TO
52521: IFFALSE 53202
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52523: LD_EXP 110
52527: PUSH
52528: LD_VAR 0 2
52532: ARRAY
52533: NOT
52534: PUSH
52535: LD_EXP 134
52539: PUSH
52540: LD_VAR 0 2
52544: ARRAY
52545: NOT
52546: OR
52547: IFFALSE 52551
// continue ;
52549: GO 52520
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52551: LD_ADDR_VAR 0 5
52555: PUSH
52556: LD_EXP 110
52560: PUSH
52561: LD_VAR 0 2
52565: ARRAY
52566: PUSH
52567: LD_INT 1
52569: ARRAY
52570: PPUSH
52571: CALL_OW 255
52575: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52576: LD_ADDR_VAR 0 6
52580: PUSH
52581: LD_EXP 110
52585: PUSH
52586: LD_VAR 0 2
52590: ARRAY
52591: PPUSH
52592: LD_INT 30
52594: PUSH
52595: LD_INT 3
52597: PUSH
52598: EMPTY
52599: LIST
52600: LIST
52601: PPUSH
52602: CALL_OW 72
52606: ST_TO_ADDR
// if not fac then
52607: LD_VAR 0 6
52611: NOT
52612: IFFALSE 52663
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52614: LD_ADDR_VAR 0 6
52618: PUSH
52619: LD_EXP 110
52623: PUSH
52624: LD_VAR 0 2
52628: ARRAY
52629: PPUSH
52630: LD_INT 2
52632: PUSH
52633: LD_INT 30
52635: PUSH
52636: LD_INT 0
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: PUSH
52643: LD_INT 30
52645: PUSH
52646: LD_INT 1
52648: PUSH
52649: EMPTY
52650: LIST
52651: LIST
52652: PUSH
52653: EMPTY
52654: LIST
52655: LIST
52656: LIST
52657: PPUSH
52658: CALL_OW 72
52662: ST_TO_ADDR
// if not fac then
52663: LD_VAR 0 6
52667: NOT
52668: IFFALSE 52672
// continue ;
52670: GO 52520
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52672: LD_ADDR_VAR 0 7
52676: PUSH
52677: LD_EXP 134
52681: PUSH
52682: LD_VAR 0 2
52686: ARRAY
52687: PPUSH
52688: LD_INT 22
52690: PUSH
52691: LD_VAR 0 5
52695: PUSH
52696: EMPTY
52697: LIST
52698: LIST
52699: PUSH
52700: LD_INT 21
52702: PUSH
52703: LD_INT 2
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: PUSH
52710: LD_INT 3
52712: PUSH
52713: LD_INT 24
52715: PUSH
52716: LD_INT 1000
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: LIST
52731: PPUSH
52732: CALL_OW 70
52736: ST_TO_ADDR
// for j in fac do
52737: LD_ADDR_VAR 0 3
52741: PUSH
52742: LD_VAR 0 6
52746: PUSH
52747: FOR_IN
52748: IFFALSE 52829
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52750: LD_ADDR_VAR 0 7
52754: PUSH
52755: LD_VAR 0 7
52759: PUSH
52760: LD_INT 22
52762: PUSH
52763: LD_VAR 0 5
52767: PUSH
52768: EMPTY
52769: LIST
52770: LIST
52771: PUSH
52772: LD_INT 91
52774: PUSH
52775: LD_VAR 0 3
52779: PUSH
52780: LD_INT 15
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: PUSH
52788: LD_INT 21
52790: PUSH
52791: LD_INT 2
52793: PUSH
52794: EMPTY
52795: LIST
52796: LIST
52797: PUSH
52798: LD_INT 3
52800: PUSH
52801: LD_INT 24
52803: PUSH
52804: LD_INT 1000
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: PPUSH
52821: CALL_OW 69
52825: UNION
52826: ST_TO_ADDR
52827: GO 52747
52829: POP
52830: POP
// if not vehs then
52831: LD_VAR 0 7
52835: NOT
52836: IFFALSE 52862
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52838: LD_ADDR_EXP 122
52842: PUSH
52843: LD_EXP 122
52847: PPUSH
52848: LD_VAR 0 2
52852: PPUSH
52853: EMPTY
52854: PPUSH
52855: CALL_OW 1
52859: ST_TO_ADDR
// continue ;
52860: GO 52520
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52862: LD_ADDR_VAR 0 8
52866: PUSH
52867: LD_EXP 110
52871: PUSH
52872: LD_VAR 0 2
52876: ARRAY
52877: PPUSH
52878: LD_INT 30
52880: PUSH
52881: LD_INT 3
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: PPUSH
52888: CALL_OW 72
52892: ST_TO_ADDR
// if tmp then
52893: LD_VAR 0 8
52897: IFFALSE 53000
// begin for j in tmp do
52899: LD_ADDR_VAR 0 3
52903: PUSH
52904: LD_VAR 0 8
52908: PUSH
52909: FOR_IN
52910: IFFALSE 52998
// for k in UnitsInside ( j ) do
52912: LD_ADDR_VAR 0 4
52916: PUSH
52917: LD_VAR 0 3
52921: PPUSH
52922: CALL_OW 313
52926: PUSH
52927: FOR_IN
52928: IFFALSE 52994
// if k then
52930: LD_VAR 0 4
52934: IFFALSE 52992
// if not k in mc_repair_vehicle [ i ] then
52936: LD_VAR 0 4
52940: PUSH
52941: LD_EXP 122
52945: PUSH
52946: LD_VAR 0 2
52950: ARRAY
52951: IN
52952: NOT
52953: IFFALSE 52992
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52955: LD_ADDR_EXP 122
52959: PUSH
52960: LD_EXP 122
52964: PPUSH
52965: LD_VAR 0 2
52969: PPUSH
52970: LD_EXP 122
52974: PUSH
52975: LD_VAR 0 2
52979: ARRAY
52980: PUSH
52981: LD_VAR 0 4
52985: UNION
52986: PPUSH
52987: CALL_OW 1
52991: ST_TO_ADDR
52992: GO 52927
52994: POP
52995: POP
52996: GO 52909
52998: POP
52999: POP
// end ; if not mc_repair_vehicle [ i ] then
53000: LD_EXP 122
53004: PUSH
53005: LD_VAR 0 2
53009: ARRAY
53010: NOT
53011: IFFALSE 53015
// continue ;
53013: GO 52520
// for j in mc_repair_vehicle [ i ] do
53015: LD_ADDR_VAR 0 3
53019: PUSH
53020: LD_EXP 122
53024: PUSH
53025: LD_VAR 0 2
53029: ARRAY
53030: PUSH
53031: FOR_IN
53032: IFFALSE 53198
// begin if GetClass ( j ) <> 3 then
53034: LD_VAR 0 3
53038: PPUSH
53039: CALL_OW 257
53043: PUSH
53044: LD_INT 3
53046: NONEQUAL
53047: IFFALSE 53088
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53049: LD_ADDR_EXP 122
53053: PUSH
53054: LD_EXP 122
53058: PPUSH
53059: LD_VAR 0 2
53063: PPUSH
53064: LD_EXP 122
53068: PUSH
53069: LD_VAR 0 2
53073: ARRAY
53074: PUSH
53075: LD_VAR 0 3
53079: DIFF
53080: PPUSH
53081: CALL_OW 1
53085: ST_TO_ADDR
// continue ;
53086: GO 53031
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53088: LD_VAR 0 3
53092: PPUSH
53093: CALL_OW 311
53097: NOT
53098: PUSH
53099: LD_VAR 0 3
53103: PUSH
53104: LD_EXP 113
53108: PUSH
53109: LD_VAR 0 2
53113: ARRAY
53114: PUSH
53115: LD_INT 1
53117: ARRAY
53118: IN
53119: NOT
53120: AND
53121: PUSH
53122: LD_VAR 0 3
53126: PUSH
53127: LD_EXP 113
53131: PUSH
53132: LD_VAR 0 2
53136: ARRAY
53137: PUSH
53138: LD_INT 2
53140: ARRAY
53141: IN
53142: NOT
53143: AND
53144: IFFALSE 53196
// begin if IsInUnit ( j ) then
53146: LD_VAR 0 3
53150: PPUSH
53151: CALL_OW 310
53155: IFFALSE 53166
// ComExitBuilding ( j ) ;
53157: LD_VAR 0 3
53161: PPUSH
53162: CALL_OW 122
// if not HasTask ( j ) then
53166: LD_VAR 0 3
53170: PPUSH
53171: CALL_OW 314
53175: NOT
53176: IFFALSE 53196
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53178: LD_VAR 0 3
53182: PPUSH
53183: LD_VAR 0 7
53187: PUSH
53188: LD_INT 1
53190: ARRAY
53191: PPUSH
53192: CALL_OW 189
// end ; end ;
53196: GO 53031
53198: POP
53199: POP
// end ;
53200: GO 52520
53202: POP
53203: POP
// end ;
53204: LD_VAR 0 1
53208: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53209: LD_INT 0
53211: PPUSH
53212: PPUSH
53213: PPUSH
53214: PPUSH
53215: PPUSH
53216: PPUSH
53217: PPUSH
53218: PPUSH
53219: PPUSH
53220: PPUSH
53221: PPUSH
// if not mc_bases then
53222: LD_EXP 110
53226: NOT
53227: IFFALSE 53231
// exit ;
53229: GO 54033
// for i = 1 to mc_bases do
53231: LD_ADDR_VAR 0 2
53235: PUSH
53236: DOUBLE
53237: LD_INT 1
53239: DEC
53240: ST_TO_ADDR
53241: LD_EXP 110
53245: PUSH
53246: FOR_TO
53247: IFFALSE 54031
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53249: LD_EXP 138
53253: PUSH
53254: LD_VAR 0 2
53258: ARRAY
53259: NOT
53260: PUSH
53261: LD_EXP 113
53265: PUSH
53266: LD_VAR 0 2
53270: ARRAY
53271: PUSH
53272: LD_INT 1
53274: ARRAY
53275: OR
53276: PUSH
53277: LD_EXP 113
53281: PUSH
53282: LD_VAR 0 2
53286: ARRAY
53287: PUSH
53288: LD_INT 2
53290: ARRAY
53291: OR
53292: PUSH
53293: LD_EXP 136
53297: PUSH
53298: LD_VAR 0 2
53302: ARRAY
53303: PPUSH
53304: LD_INT 1
53306: PPUSH
53307: CALL_OW 325
53311: NOT
53312: OR
53313: PUSH
53314: LD_EXP 133
53318: PUSH
53319: LD_VAR 0 2
53323: ARRAY
53324: OR
53325: IFFALSE 53329
// continue ;
53327: GO 53246
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53329: LD_ADDR_VAR 0 8
53333: PUSH
53334: LD_EXP 110
53338: PUSH
53339: LD_VAR 0 2
53343: ARRAY
53344: PPUSH
53345: LD_INT 25
53347: PUSH
53348: LD_INT 4
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: PUSH
53355: LD_INT 50
53357: PUSH
53358: EMPTY
53359: LIST
53360: PUSH
53361: LD_INT 3
53363: PUSH
53364: LD_INT 60
53366: PUSH
53367: EMPTY
53368: LIST
53369: PUSH
53370: EMPTY
53371: LIST
53372: LIST
53373: PUSH
53374: EMPTY
53375: LIST
53376: LIST
53377: LIST
53378: PPUSH
53379: CALL_OW 72
53383: PUSH
53384: LD_EXP 114
53388: PUSH
53389: LD_VAR 0 2
53393: ARRAY
53394: DIFF
53395: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53396: LD_ADDR_VAR 0 9
53400: PUSH
53401: LD_EXP 110
53405: PUSH
53406: LD_VAR 0 2
53410: ARRAY
53411: PPUSH
53412: LD_INT 2
53414: PUSH
53415: LD_INT 30
53417: PUSH
53418: LD_INT 0
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: PUSH
53425: LD_INT 30
53427: PUSH
53428: LD_INT 1
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: LIST
53439: PPUSH
53440: CALL_OW 72
53444: ST_TO_ADDR
// if not tmp or not dep then
53445: LD_VAR 0 8
53449: NOT
53450: PUSH
53451: LD_VAR 0 9
53455: NOT
53456: OR
53457: IFFALSE 53461
// continue ;
53459: GO 53246
// side := GetSide ( tmp [ 1 ] ) ;
53461: LD_ADDR_VAR 0 11
53465: PUSH
53466: LD_VAR 0 8
53470: PUSH
53471: LD_INT 1
53473: ARRAY
53474: PPUSH
53475: CALL_OW 255
53479: ST_TO_ADDR
// dep := dep [ 1 ] ;
53480: LD_ADDR_VAR 0 9
53484: PUSH
53485: LD_VAR 0 9
53489: PUSH
53490: LD_INT 1
53492: ARRAY
53493: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53494: LD_ADDR_VAR 0 7
53498: PUSH
53499: LD_EXP 138
53503: PUSH
53504: LD_VAR 0 2
53508: ARRAY
53509: PPUSH
53510: LD_INT 22
53512: PUSH
53513: LD_INT 0
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: PUSH
53520: LD_INT 25
53522: PUSH
53523: LD_INT 12
53525: PUSH
53526: EMPTY
53527: LIST
53528: LIST
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PPUSH
53534: CALL_OW 70
53538: PUSH
53539: LD_INT 22
53541: PUSH
53542: LD_INT 0
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: PUSH
53549: LD_INT 25
53551: PUSH
53552: LD_INT 12
53554: PUSH
53555: EMPTY
53556: LIST
53557: LIST
53558: PUSH
53559: LD_INT 91
53561: PUSH
53562: LD_VAR 0 9
53566: PUSH
53567: LD_INT 20
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: LIST
53574: PUSH
53575: EMPTY
53576: LIST
53577: LIST
53578: LIST
53579: PPUSH
53580: CALL_OW 69
53584: UNION
53585: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53586: LD_ADDR_VAR 0 10
53590: PUSH
53591: LD_EXP 138
53595: PUSH
53596: LD_VAR 0 2
53600: ARRAY
53601: PPUSH
53602: LD_INT 81
53604: PUSH
53605: LD_VAR 0 11
53609: PUSH
53610: EMPTY
53611: LIST
53612: LIST
53613: PPUSH
53614: CALL_OW 70
53618: ST_TO_ADDR
// if not apes or danger_at_area then
53619: LD_VAR 0 7
53623: NOT
53624: PUSH
53625: LD_VAR 0 10
53629: OR
53630: IFFALSE 53680
// begin if mc_taming [ i ] then
53632: LD_EXP 141
53636: PUSH
53637: LD_VAR 0 2
53641: ARRAY
53642: IFFALSE 53678
// begin MC_Reset ( i , 121 ) ;
53644: LD_VAR 0 2
53648: PPUSH
53649: LD_INT 121
53651: PPUSH
53652: CALL 39131 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53656: LD_ADDR_EXP 141
53660: PUSH
53661: LD_EXP 141
53665: PPUSH
53666: LD_VAR 0 2
53670: PPUSH
53671: EMPTY
53672: PPUSH
53673: CALL_OW 1
53677: ST_TO_ADDR
// end ; continue ;
53678: GO 53246
// end ; for j in tmp do
53680: LD_ADDR_VAR 0 3
53684: PUSH
53685: LD_VAR 0 8
53689: PUSH
53690: FOR_IN
53691: IFFALSE 54027
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53693: LD_VAR 0 3
53697: PUSH
53698: LD_EXP 141
53702: PUSH
53703: LD_VAR 0 2
53707: ARRAY
53708: IN
53709: NOT
53710: PUSH
53711: LD_EXP 141
53715: PUSH
53716: LD_VAR 0 2
53720: ARRAY
53721: PUSH
53722: LD_INT 3
53724: LESS
53725: AND
53726: IFFALSE 53784
// begin SetTag ( j , 121 ) ;
53728: LD_VAR 0 3
53732: PPUSH
53733: LD_INT 121
53735: PPUSH
53736: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53740: LD_ADDR_EXP 141
53744: PUSH
53745: LD_EXP 141
53749: PPUSH
53750: LD_VAR 0 2
53754: PUSH
53755: LD_EXP 141
53759: PUSH
53760: LD_VAR 0 2
53764: ARRAY
53765: PUSH
53766: LD_INT 1
53768: PLUS
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: PPUSH
53774: LD_VAR 0 3
53778: PPUSH
53779: CALL 70022 0 3
53783: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53784: LD_VAR 0 3
53788: PUSH
53789: LD_EXP 141
53793: PUSH
53794: LD_VAR 0 2
53798: ARRAY
53799: IN
53800: IFFALSE 54025
// begin if GetClass ( j ) <> 4 then
53802: LD_VAR 0 3
53806: PPUSH
53807: CALL_OW 257
53811: PUSH
53812: LD_INT 4
53814: NONEQUAL
53815: IFFALSE 53868
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53817: LD_ADDR_EXP 141
53821: PUSH
53822: LD_EXP 141
53826: PPUSH
53827: LD_VAR 0 2
53831: PPUSH
53832: LD_EXP 141
53836: PUSH
53837: LD_VAR 0 2
53841: ARRAY
53842: PUSH
53843: LD_VAR 0 3
53847: DIFF
53848: PPUSH
53849: CALL_OW 1
53853: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53854: LD_VAR 0 3
53858: PPUSH
53859: LD_INT 0
53861: PPUSH
53862: CALL_OW 109
// continue ;
53866: GO 53690
// end ; if IsInUnit ( j ) then
53868: LD_VAR 0 3
53872: PPUSH
53873: CALL_OW 310
53877: IFFALSE 53888
// ComExitBuilding ( j ) ;
53879: LD_VAR 0 3
53883: PPUSH
53884: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53888: LD_ADDR_VAR 0 6
53892: PUSH
53893: LD_VAR 0 7
53897: PPUSH
53898: LD_VAR 0 3
53902: PPUSH
53903: CALL_OW 74
53907: ST_TO_ADDR
// if not ape then
53908: LD_VAR 0 6
53912: NOT
53913: IFFALSE 53917
// break ;
53915: GO 54027
// x := GetX ( ape ) ;
53917: LD_ADDR_VAR 0 4
53921: PUSH
53922: LD_VAR 0 6
53926: PPUSH
53927: CALL_OW 250
53931: ST_TO_ADDR
// y := GetY ( ape ) ;
53932: LD_ADDR_VAR 0 5
53936: PUSH
53937: LD_VAR 0 6
53941: PPUSH
53942: CALL_OW 251
53946: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53947: LD_VAR 0 4
53951: PPUSH
53952: LD_VAR 0 5
53956: PPUSH
53957: CALL_OW 488
53961: NOT
53962: PUSH
53963: LD_VAR 0 11
53967: PPUSH
53968: LD_VAR 0 4
53972: PPUSH
53973: LD_VAR 0 5
53977: PPUSH
53978: LD_INT 20
53980: PPUSH
53981: CALL 70918 0 4
53985: PUSH
53986: LD_INT 4
53988: ARRAY
53989: OR
53990: IFFALSE 53994
// break ;
53992: GO 54027
// if not HasTask ( j ) then
53994: LD_VAR 0 3
53998: PPUSH
53999: CALL_OW 314
54003: NOT
54004: IFFALSE 54025
// ComTameXY ( j , x , y ) ;
54006: LD_VAR 0 3
54010: PPUSH
54011: LD_VAR 0 4
54015: PPUSH
54016: LD_VAR 0 5
54020: PPUSH
54021: CALL_OW 131
// end ; end ;
54025: GO 53690
54027: POP
54028: POP
// end ;
54029: GO 53246
54031: POP
54032: POP
// end ;
54033: LD_VAR 0 1
54037: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54038: LD_INT 0
54040: PPUSH
54041: PPUSH
54042: PPUSH
54043: PPUSH
54044: PPUSH
54045: PPUSH
54046: PPUSH
54047: PPUSH
// if not mc_bases then
54048: LD_EXP 110
54052: NOT
54053: IFFALSE 54057
// exit ;
54055: GO 54683
// for i = 1 to mc_bases do
54057: LD_ADDR_VAR 0 2
54061: PUSH
54062: DOUBLE
54063: LD_INT 1
54065: DEC
54066: ST_TO_ADDR
54067: LD_EXP 110
54071: PUSH
54072: FOR_TO
54073: IFFALSE 54681
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54075: LD_EXP 139
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: NOT
54086: PUSH
54087: LD_EXP 139
54091: PUSH
54092: LD_VAR 0 2
54096: ARRAY
54097: PPUSH
54098: LD_INT 25
54100: PUSH
54101: LD_INT 12
54103: PUSH
54104: EMPTY
54105: LIST
54106: LIST
54107: PPUSH
54108: CALL_OW 72
54112: NOT
54113: OR
54114: IFFALSE 54118
// continue ;
54116: GO 54072
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54118: LD_ADDR_VAR 0 5
54122: PUSH
54123: LD_EXP 139
54127: PUSH
54128: LD_VAR 0 2
54132: ARRAY
54133: PUSH
54134: LD_INT 1
54136: ARRAY
54137: PPUSH
54138: CALL_OW 255
54142: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54143: LD_VAR 0 5
54147: PPUSH
54148: LD_INT 2
54150: PPUSH
54151: CALL_OW 325
54155: IFFALSE 54408
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54157: LD_ADDR_VAR 0 4
54161: PUSH
54162: LD_EXP 139
54166: PUSH
54167: LD_VAR 0 2
54171: ARRAY
54172: PPUSH
54173: LD_INT 25
54175: PUSH
54176: LD_INT 16
54178: PUSH
54179: EMPTY
54180: LIST
54181: LIST
54182: PPUSH
54183: CALL_OW 72
54187: ST_TO_ADDR
// if tmp < 6 then
54188: LD_VAR 0 4
54192: PUSH
54193: LD_INT 6
54195: LESS
54196: IFFALSE 54408
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54198: LD_ADDR_VAR 0 6
54202: PUSH
54203: LD_EXP 110
54207: PUSH
54208: LD_VAR 0 2
54212: ARRAY
54213: PPUSH
54214: LD_INT 2
54216: PUSH
54217: LD_INT 30
54219: PUSH
54220: LD_INT 0
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: PUSH
54227: LD_INT 30
54229: PUSH
54230: LD_INT 1
54232: PUSH
54233: EMPTY
54234: LIST
54235: LIST
54236: PUSH
54237: EMPTY
54238: LIST
54239: LIST
54240: LIST
54241: PPUSH
54242: CALL_OW 72
54246: ST_TO_ADDR
// if depot then
54247: LD_VAR 0 6
54251: IFFALSE 54408
// begin selected := 0 ;
54253: LD_ADDR_VAR 0 7
54257: PUSH
54258: LD_INT 0
54260: ST_TO_ADDR
// for j in depot do
54261: LD_ADDR_VAR 0 3
54265: PUSH
54266: LD_VAR 0 6
54270: PUSH
54271: FOR_IN
54272: IFFALSE 54303
// begin if UnitsInside ( j ) < 6 then
54274: LD_VAR 0 3
54278: PPUSH
54279: CALL_OW 313
54283: PUSH
54284: LD_INT 6
54286: LESS
54287: IFFALSE 54301
// begin selected := j ;
54289: LD_ADDR_VAR 0 7
54293: PUSH
54294: LD_VAR 0 3
54298: ST_TO_ADDR
// break ;
54299: GO 54303
// end ; end ;
54301: GO 54271
54303: POP
54304: POP
// if selected then
54305: LD_VAR 0 7
54309: IFFALSE 54408
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54311: LD_ADDR_VAR 0 3
54315: PUSH
54316: LD_EXP 139
54320: PUSH
54321: LD_VAR 0 2
54325: ARRAY
54326: PPUSH
54327: LD_INT 25
54329: PUSH
54330: LD_INT 12
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PPUSH
54337: CALL_OW 72
54341: PUSH
54342: FOR_IN
54343: IFFALSE 54406
// if not HasTask ( j ) then
54345: LD_VAR 0 3
54349: PPUSH
54350: CALL_OW 314
54354: NOT
54355: IFFALSE 54404
// begin if not IsInUnit ( j ) then
54357: LD_VAR 0 3
54361: PPUSH
54362: CALL_OW 310
54366: NOT
54367: IFFALSE 54383
// ComEnterUnit ( j , selected ) ;
54369: LD_VAR 0 3
54373: PPUSH
54374: LD_VAR 0 7
54378: PPUSH
54379: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54383: LD_VAR 0 3
54387: PPUSH
54388: LD_INT 16
54390: PPUSH
54391: CALL_OW 183
// AddComExitBuilding ( j ) ;
54395: LD_VAR 0 3
54399: PPUSH
54400: CALL_OW 182
// end ;
54404: GO 54342
54406: POP
54407: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54408: LD_VAR 0 5
54412: PPUSH
54413: LD_INT 11
54415: PPUSH
54416: CALL_OW 325
54420: IFFALSE 54679
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54422: LD_ADDR_VAR 0 4
54426: PUSH
54427: LD_EXP 139
54431: PUSH
54432: LD_VAR 0 2
54436: ARRAY
54437: PPUSH
54438: LD_INT 25
54440: PUSH
54441: LD_INT 16
54443: PUSH
54444: EMPTY
54445: LIST
54446: LIST
54447: PPUSH
54448: CALL_OW 72
54452: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54453: LD_VAR 0 4
54457: PUSH
54458: LD_INT 6
54460: GREATEREQUAL
54461: PUSH
54462: LD_VAR 0 5
54466: PPUSH
54467: LD_INT 2
54469: PPUSH
54470: CALL_OW 325
54474: NOT
54475: OR
54476: IFFALSE 54679
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54478: LD_ADDR_VAR 0 8
54482: PUSH
54483: LD_EXP 110
54487: PUSH
54488: LD_VAR 0 2
54492: ARRAY
54493: PPUSH
54494: LD_INT 2
54496: PUSH
54497: LD_INT 30
54499: PUSH
54500: LD_INT 4
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: PUSH
54507: LD_INT 30
54509: PUSH
54510: LD_INT 5
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: LIST
54521: PPUSH
54522: CALL_OW 72
54526: ST_TO_ADDR
// if barracks then
54527: LD_VAR 0 8
54531: IFFALSE 54679
// begin selected := 0 ;
54533: LD_ADDR_VAR 0 7
54537: PUSH
54538: LD_INT 0
54540: ST_TO_ADDR
// for j in barracks do
54541: LD_ADDR_VAR 0 3
54545: PUSH
54546: LD_VAR 0 8
54550: PUSH
54551: FOR_IN
54552: IFFALSE 54583
// begin if UnitsInside ( j ) < 6 then
54554: LD_VAR 0 3
54558: PPUSH
54559: CALL_OW 313
54563: PUSH
54564: LD_INT 6
54566: LESS
54567: IFFALSE 54581
// begin selected := j ;
54569: LD_ADDR_VAR 0 7
54573: PUSH
54574: LD_VAR 0 3
54578: ST_TO_ADDR
// break ;
54579: GO 54583
// end ; end ;
54581: GO 54551
54583: POP
54584: POP
// if selected then
54585: LD_VAR 0 7
54589: IFFALSE 54679
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54591: LD_ADDR_VAR 0 3
54595: PUSH
54596: LD_EXP 139
54600: PUSH
54601: LD_VAR 0 2
54605: ARRAY
54606: PPUSH
54607: LD_INT 25
54609: PUSH
54610: LD_INT 12
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: PPUSH
54617: CALL_OW 72
54621: PUSH
54622: FOR_IN
54623: IFFALSE 54677
// if not IsInUnit ( j ) and not HasTask ( j ) then
54625: LD_VAR 0 3
54629: PPUSH
54630: CALL_OW 310
54634: NOT
54635: PUSH
54636: LD_VAR 0 3
54640: PPUSH
54641: CALL_OW 314
54645: NOT
54646: AND
54647: IFFALSE 54675
// begin ComEnterUnit ( j , selected ) ;
54649: LD_VAR 0 3
54653: PPUSH
54654: LD_VAR 0 7
54658: PPUSH
54659: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54663: LD_VAR 0 3
54667: PPUSH
54668: LD_INT 15
54670: PPUSH
54671: CALL_OW 183
// end ;
54675: GO 54622
54677: POP
54678: POP
// end ; end ; end ; end ; end ;
54679: GO 54072
54681: POP
54682: POP
// end ;
54683: LD_VAR 0 1
54687: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54688: LD_INT 0
54690: PPUSH
54691: PPUSH
54692: PPUSH
54693: PPUSH
// if not mc_bases then
54694: LD_EXP 110
54698: NOT
54699: IFFALSE 54703
// exit ;
54701: GO 54881
// for i = 1 to mc_bases do
54703: LD_ADDR_VAR 0 2
54707: PUSH
54708: DOUBLE
54709: LD_INT 1
54711: DEC
54712: ST_TO_ADDR
54713: LD_EXP 110
54717: PUSH
54718: FOR_TO
54719: IFFALSE 54879
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54721: LD_ADDR_VAR 0 4
54725: PUSH
54726: LD_EXP 110
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PPUSH
54737: LD_INT 25
54739: PUSH
54740: LD_INT 9
54742: PUSH
54743: EMPTY
54744: LIST
54745: LIST
54746: PPUSH
54747: CALL_OW 72
54751: ST_TO_ADDR
// if not tmp then
54752: LD_VAR 0 4
54756: NOT
54757: IFFALSE 54761
// continue ;
54759: GO 54718
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54761: LD_EXP 136
54765: PUSH
54766: LD_VAR 0 2
54770: ARRAY
54771: PPUSH
54772: LD_INT 29
54774: PPUSH
54775: CALL_OW 325
54779: NOT
54780: PUSH
54781: LD_EXP 136
54785: PUSH
54786: LD_VAR 0 2
54790: ARRAY
54791: PPUSH
54792: LD_INT 28
54794: PPUSH
54795: CALL_OW 325
54799: NOT
54800: AND
54801: IFFALSE 54805
// continue ;
54803: GO 54718
// for j in tmp do
54805: LD_ADDR_VAR 0 3
54809: PUSH
54810: LD_VAR 0 4
54814: PUSH
54815: FOR_IN
54816: IFFALSE 54875
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54818: LD_VAR 0 3
54822: PUSH
54823: LD_EXP 113
54827: PUSH
54828: LD_VAR 0 2
54832: ARRAY
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: IN
54838: NOT
54839: PUSH
54840: LD_VAR 0 3
54844: PUSH
54845: LD_EXP 113
54849: PUSH
54850: LD_VAR 0 2
54854: ARRAY
54855: PUSH
54856: LD_INT 2
54858: ARRAY
54859: IN
54860: NOT
54861: AND
54862: IFFALSE 54873
// ComSpaceTimeShoot ( j ) ;
54864: LD_VAR 0 3
54868: PPUSH
54869: CALL 66019 0 1
54873: GO 54815
54875: POP
54876: POP
// end ;
54877: GO 54718
54879: POP
54880: POP
// end ;
54881: LD_VAR 0 1
54885: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54886: LD_INT 0
54888: PPUSH
54889: PPUSH
54890: PPUSH
54891: PPUSH
54892: PPUSH
54893: PPUSH
54894: PPUSH
54895: PPUSH
54896: PPUSH
// if not mc_bases then
54897: LD_EXP 110
54901: NOT
54902: IFFALSE 54906
// exit ;
54904: GO 55528
// for i = 1 to mc_bases do
54906: LD_ADDR_VAR 0 2
54910: PUSH
54911: DOUBLE
54912: LD_INT 1
54914: DEC
54915: ST_TO_ADDR
54916: LD_EXP 110
54920: PUSH
54921: FOR_TO
54922: IFFALSE 55526
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54924: LD_EXP 145
54928: PUSH
54929: LD_VAR 0 2
54933: ARRAY
54934: NOT
54935: PUSH
54936: LD_INT 38
54938: PPUSH
54939: LD_EXP 136
54943: PUSH
54944: LD_VAR 0 2
54948: ARRAY
54949: PPUSH
54950: CALL_OW 321
54954: PUSH
54955: LD_INT 2
54957: NONEQUAL
54958: OR
54959: IFFALSE 54963
// continue ;
54961: GO 54921
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54963: LD_ADDR_VAR 0 8
54967: PUSH
54968: LD_EXP 110
54972: PUSH
54973: LD_VAR 0 2
54977: ARRAY
54978: PPUSH
54979: LD_INT 30
54981: PUSH
54982: LD_INT 34
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: PPUSH
54989: CALL_OW 72
54993: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54994: LD_ADDR_VAR 0 9
54998: PUSH
54999: LD_EXP 110
55003: PUSH
55004: LD_VAR 0 2
55008: ARRAY
55009: PPUSH
55010: LD_INT 25
55012: PUSH
55013: LD_INT 4
55015: PUSH
55016: EMPTY
55017: LIST
55018: LIST
55019: PPUSH
55020: CALL_OW 72
55024: PPUSH
55025: LD_INT 0
55027: PPUSH
55028: CALL 98583 0 2
55032: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55033: LD_VAR 0 9
55037: NOT
55038: PUSH
55039: LD_VAR 0 8
55043: NOT
55044: OR
55045: PUSH
55046: LD_EXP 110
55050: PUSH
55051: LD_VAR 0 2
55055: ARRAY
55056: PPUSH
55057: LD_INT 124
55059: PPUSH
55060: CALL 98583 0 2
55064: OR
55065: IFFALSE 55069
// continue ;
55067: GO 54921
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55069: LD_EXP 146
55073: PUSH
55074: LD_VAR 0 2
55078: ARRAY
55079: PUSH
55080: LD_EXP 145
55084: PUSH
55085: LD_VAR 0 2
55089: ARRAY
55090: LESS
55091: PUSH
55092: LD_EXP 146
55096: PUSH
55097: LD_VAR 0 2
55101: ARRAY
55102: PUSH
55103: LD_VAR 0 8
55107: LESS
55108: AND
55109: IFFALSE 55524
// begin tmp := sci [ 1 ] ;
55111: LD_ADDR_VAR 0 7
55115: PUSH
55116: LD_VAR 0 9
55120: PUSH
55121: LD_INT 1
55123: ARRAY
55124: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55125: LD_VAR 0 7
55129: PPUSH
55130: LD_INT 124
55132: PPUSH
55133: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55137: LD_ADDR_VAR 0 3
55141: PUSH
55142: DOUBLE
55143: LD_EXP 145
55147: PUSH
55148: LD_VAR 0 2
55152: ARRAY
55153: INC
55154: ST_TO_ADDR
55155: LD_EXP 145
55159: PUSH
55160: LD_VAR 0 2
55164: ARRAY
55165: PUSH
55166: FOR_DOWNTO
55167: IFFALSE 55510
// begin if IsInUnit ( tmp ) then
55169: LD_VAR 0 7
55173: PPUSH
55174: CALL_OW 310
55178: IFFALSE 55189
// ComExitBuilding ( tmp ) ;
55180: LD_VAR 0 7
55184: PPUSH
55185: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55189: LD_INT 35
55191: PPUSH
55192: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55196: LD_VAR 0 7
55200: PPUSH
55201: CALL_OW 310
55205: NOT
55206: PUSH
55207: LD_VAR 0 7
55211: PPUSH
55212: CALL_OW 314
55216: NOT
55217: AND
55218: IFFALSE 55189
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55220: LD_ADDR_VAR 0 6
55224: PUSH
55225: LD_VAR 0 7
55229: PPUSH
55230: CALL_OW 250
55234: PUSH
55235: LD_VAR 0 7
55239: PPUSH
55240: CALL_OW 251
55244: PUSH
55245: EMPTY
55246: LIST
55247: LIST
55248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55249: LD_INT 35
55251: PPUSH
55252: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55256: LD_ADDR_VAR 0 4
55260: PUSH
55261: LD_EXP 145
55265: PUSH
55266: LD_VAR 0 2
55270: ARRAY
55271: PUSH
55272: LD_VAR 0 3
55276: ARRAY
55277: PUSH
55278: LD_INT 1
55280: ARRAY
55281: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55282: LD_ADDR_VAR 0 5
55286: PUSH
55287: LD_EXP 145
55291: PUSH
55292: LD_VAR 0 2
55296: ARRAY
55297: PUSH
55298: LD_VAR 0 3
55302: ARRAY
55303: PUSH
55304: LD_INT 2
55306: ARRAY
55307: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55308: LD_VAR 0 7
55312: PPUSH
55313: LD_INT 10
55315: PPUSH
55316: CALL 72615 0 2
55320: PUSH
55321: LD_INT 4
55323: ARRAY
55324: IFFALSE 55362
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55326: LD_VAR 0 7
55330: PPUSH
55331: LD_VAR 0 6
55335: PUSH
55336: LD_INT 1
55338: ARRAY
55339: PPUSH
55340: LD_VAR 0 6
55344: PUSH
55345: LD_INT 2
55347: ARRAY
55348: PPUSH
55349: CALL_OW 111
// wait ( 0 0$10 ) ;
55353: LD_INT 350
55355: PPUSH
55356: CALL_OW 67
// end else
55360: GO 55388
// begin ComMoveXY ( tmp , x , y ) ;
55362: LD_VAR 0 7
55366: PPUSH
55367: LD_VAR 0 4
55371: PPUSH
55372: LD_VAR 0 5
55376: PPUSH
55377: CALL_OW 111
// wait ( 0 0$3 ) ;
55381: LD_INT 105
55383: PPUSH
55384: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55388: LD_VAR 0 7
55392: PPUSH
55393: LD_VAR 0 4
55397: PPUSH
55398: LD_VAR 0 5
55402: PPUSH
55403: CALL_OW 307
55407: IFFALSE 55249
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55409: LD_VAR 0 7
55413: PPUSH
55414: LD_VAR 0 4
55418: PPUSH
55419: LD_VAR 0 5
55423: PPUSH
55424: LD_VAR 0 8
55428: PUSH
55429: LD_VAR 0 3
55433: ARRAY
55434: PPUSH
55435: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55439: LD_INT 35
55441: PPUSH
55442: CALL_OW 67
// until not HasTask ( tmp ) ;
55446: LD_VAR 0 7
55450: PPUSH
55451: CALL_OW 314
55455: NOT
55456: IFFALSE 55439
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55458: LD_ADDR_EXP 146
55462: PUSH
55463: LD_EXP 146
55467: PPUSH
55468: LD_VAR 0 2
55472: PUSH
55473: LD_EXP 146
55477: PUSH
55478: LD_VAR 0 2
55482: ARRAY
55483: PUSH
55484: LD_INT 1
55486: PLUS
55487: PUSH
55488: EMPTY
55489: LIST
55490: LIST
55491: PPUSH
55492: LD_VAR 0 8
55496: PUSH
55497: LD_VAR 0 3
55501: ARRAY
55502: PPUSH
55503: CALL 70022 0 3
55507: ST_TO_ADDR
// end ;
55508: GO 55166
55510: POP
55511: POP
// MC_Reset ( i , 124 ) ;
55512: LD_VAR 0 2
55516: PPUSH
55517: LD_INT 124
55519: PPUSH
55520: CALL 39131 0 2
// end ; end ;
55524: GO 54921
55526: POP
55527: POP
// end ;
55528: LD_VAR 0 1
55532: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55533: LD_INT 0
55535: PPUSH
55536: PPUSH
55537: PPUSH
// if not mc_bases then
55538: LD_EXP 110
55542: NOT
55543: IFFALSE 55547
// exit ;
55545: GO 56153
// for i = 1 to mc_bases do
55547: LD_ADDR_VAR 0 2
55551: PUSH
55552: DOUBLE
55553: LD_INT 1
55555: DEC
55556: ST_TO_ADDR
55557: LD_EXP 110
55561: PUSH
55562: FOR_TO
55563: IFFALSE 56151
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55565: LD_ADDR_VAR 0 3
55569: PUSH
55570: LD_EXP 110
55574: PUSH
55575: LD_VAR 0 2
55579: ARRAY
55580: PPUSH
55581: LD_INT 25
55583: PUSH
55584: LD_INT 4
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: PPUSH
55591: CALL_OW 72
55595: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55596: LD_VAR 0 3
55600: NOT
55601: PUSH
55602: LD_EXP 147
55606: PUSH
55607: LD_VAR 0 2
55611: ARRAY
55612: NOT
55613: OR
55614: PUSH
55615: LD_EXP 110
55619: PUSH
55620: LD_VAR 0 2
55624: ARRAY
55625: PPUSH
55626: LD_INT 2
55628: PUSH
55629: LD_INT 30
55631: PUSH
55632: LD_INT 0
55634: PUSH
55635: EMPTY
55636: LIST
55637: LIST
55638: PUSH
55639: LD_INT 30
55641: PUSH
55642: LD_INT 1
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: LIST
55653: PPUSH
55654: CALL_OW 72
55658: NOT
55659: OR
55660: IFFALSE 55710
// begin if mc_deposits_finder [ i ] then
55662: LD_EXP 148
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: IFFALSE 55708
// begin MC_Reset ( i , 125 ) ;
55674: LD_VAR 0 2
55678: PPUSH
55679: LD_INT 125
55681: PPUSH
55682: CALL 39131 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55686: LD_ADDR_EXP 148
55690: PUSH
55691: LD_EXP 148
55695: PPUSH
55696: LD_VAR 0 2
55700: PPUSH
55701: EMPTY
55702: PPUSH
55703: CALL_OW 1
55707: ST_TO_ADDR
// end ; continue ;
55708: GO 55562
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55710: LD_EXP 147
55714: PUSH
55715: LD_VAR 0 2
55719: ARRAY
55720: PUSH
55721: LD_INT 1
55723: ARRAY
55724: PUSH
55725: LD_INT 3
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: EQUAL
55732: PUSH
55733: LD_INT 20
55735: PPUSH
55736: LD_EXP 136
55740: PUSH
55741: LD_VAR 0 2
55745: ARRAY
55746: PPUSH
55747: CALL_OW 321
55751: PUSH
55752: LD_INT 2
55754: NONEQUAL
55755: AND
55756: IFFALSE 55806
// begin if mc_deposits_finder [ i ] then
55758: LD_EXP 148
55762: PUSH
55763: LD_VAR 0 2
55767: ARRAY
55768: IFFALSE 55804
// begin MC_Reset ( i , 125 ) ;
55770: LD_VAR 0 2
55774: PPUSH
55775: LD_INT 125
55777: PPUSH
55778: CALL 39131 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55782: LD_ADDR_EXP 148
55786: PUSH
55787: LD_EXP 148
55791: PPUSH
55792: LD_VAR 0 2
55796: PPUSH
55797: EMPTY
55798: PPUSH
55799: CALL_OW 1
55803: ST_TO_ADDR
// end ; continue ;
55804: GO 55562
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55806: LD_EXP 147
55810: PUSH
55811: LD_VAR 0 2
55815: ARRAY
55816: PUSH
55817: LD_INT 1
55819: ARRAY
55820: PUSH
55821: LD_INT 1
55823: ARRAY
55824: PPUSH
55825: LD_EXP 147
55829: PUSH
55830: LD_VAR 0 2
55834: ARRAY
55835: PUSH
55836: LD_INT 1
55838: ARRAY
55839: PUSH
55840: LD_INT 2
55842: ARRAY
55843: PPUSH
55844: LD_EXP 136
55848: PUSH
55849: LD_VAR 0 2
55853: ARRAY
55854: PPUSH
55855: CALL_OW 440
55859: IFFALSE 55902
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55861: LD_ADDR_EXP 147
55865: PUSH
55866: LD_EXP 147
55870: PPUSH
55871: LD_VAR 0 2
55875: PPUSH
55876: LD_EXP 147
55880: PUSH
55881: LD_VAR 0 2
55885: ARRAY
55886: PPUSH
55887: LD_INT 1
55889: PPUSH
55890: CALL_OW 3
55894: PPUSH
55895: CALL_OW 1
55899: ST_TO_ADDR
55900: GO 56149
// begin if not mc_deposits_finder [ i ] then
55902: LD_EXP 148
55906: PUSH
55907: LD_VAR 0 2
55911: ARRAY
55912: NOT
55913: IFFALSE 55965
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55915: LD_ADDR_EXP 148
55919: PUSH
55920: LD_EXP 148
55924: PPUSH
55925: LD_VAR 0 2
55929: PPUSH
55930: LD_VAR 0 3
55934: PUSH
55935: LD_INT 1
55937: ARRAY
55938: PUSH
55939: EMPTY
55940: LIST
55941: PPUSH
55942: CALL_OW 1
55946: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55947: LD_VAR 0 3
55951: PUSH
55952: LD_INT 1
55954: ARRAY
55955: PPUSH
55956: LD_INT 125
55958: PPUSH
55959: CALL_OW 109
// end else
55963: GO 56149
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55965: LD_EXP 148
55969: PUSH
55970: LD_VAR 0 2
55974: ARRAY
55975: PUSH
55976: LD_INT 1
55978: ARRAY
55979: PPUSH
55980: CALL_OW 310
55984: IFFALSE 56007
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55986: LD_EXP 148
55990: PUSH
55991: LD_VAR 0 2
55995: ARRAY
55996: PUSH
55997: LD_INT 1
55999: ARRAY
56000: PPUSH
56001: CALL_OW 122
56005: GO 56149
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56007: LD_EXP 148
56011: PUSH
56012: LD_VAR 0 2
56016: ARRAY
56017: PUSH
56018: LD_INT 1
56020: ARRAY
56021: PPUSH
56022: CALL_OW 314
56026: NOT
56027: PUSH
56028: LD_EXP 148
56032: PUSH
56033: LD_VAR 0 2
56037: ARRAY
56038: PUSH
56039: LD_INT 1
56041: ARRAY
56042: PPUSH
56043: LD_EXP 147
56047: PUSH
56048: LD_VAR 0 2
56052: ARRAY
56053: PUSH
56054: LD_INT 1
56056: ARRAY
56057: PUSH
56058: LD_INT 1
56060: ARRAY
56061: PPUSH
56062: LD_EXP 147
56066: PUSH
56067: LD_VAR 0 2
56071: ARRAY
56072: PUSH
56073: LD_INT 1
56075: ARRAY
56076: PUSH
56077: LD_INT 2
56079: ARRAY
56080: PPUSH
56081: CALL_OW 297
56085: PUSH
56086: LD_INT 6
56088: GREATER
56089: AND
56090: IFFALSE 56149
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56092: LD_EXP 148
56096: PUSH
56097: LD_VAR 0 2
56101: ARRAY
56102: PUSH
56103: LD_INT 1
56105: ARRAY
56106: PPUSH
56107: LD_EXP 147
56111: PUSH
56112: LD_VAR 0 2
56116: ARRAY
56117: PUSH
56118: LD_INT 1
56120: ARRAY
56121: PUSH
56122: LD_INT 1
56124: ARRAY
56125: PPUSH
56126: LD_EXP 147
56130: PUSH
56131: LD_VAR 0 2
56135: ARRAY
56136: PUSH
56137: LD_INT 1
56139: ARRAY
56140: PUSH
56141: LD_INT 2
56143: ARRAY
56144: PPUSH
56145: CALL_OW 111
// end ; end ; end ;
56149: GO 55562
56151: POP
56152: POP
// end ;
56153: LD_VAR 0 1
56157: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56158: LD_INT 0
56160: PPUSH
56161: PPUSH
56162: PPUSH
56163: PPUSH
56164: PPUSH
56165: PPUSH
56166: PPUSH
56167: PPUSH
56168: PPUSH
56169: PPUSH
56170: PPUSH
// if not mc_bases then
56171: LD_EXP 110
56175: NOT
56176: IFFALSE 56180
// exit ;
56178: GO 57120
// for i = 1 to mc_bases do
56180: LD_ADDR_VAR 0 2
56184: PUSH
56185: DOUBLE
56186: LD_INT 1
56188: DEC
56189: ST_TO_ADDR
56190: LD_EXP 110
56194: PUSH
56195: FOR_TO
56196: IFFALSE 57118
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56198: LD_EXP 110
56202: PUSH
56203: LD_VAR 0 2
56207: ARRAY
56208: NOT
56209: PUSH
56210: LD_EXP 133
56214: PUSH
56215: LD_VAR 0 2
56219: ARRAY
56220: OR
56221: IFFALSE 56225
// continue ;
56223: GO 56195
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56225: LD_ADDR_VAR 0 7
56229: PUSH
56230: LD_EXP 110
56234: PUSH
56235: LD_VAR 0 2
56239: ARRAY
56240: PUSH
56241: LD_INT 1
56243: ARRAY
56244: PPUSH
56245: CALL_OW 248
56249: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56250: LD_VAR 0 7
56254: PUSH
56255: LD_INT 3
56257: EQUAL
56258: PUSH
56259: LD_EXP 129
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: PUSH
56270: LD_EXP 132
56274: PUSH
56275: LD_VAR 0 2
56279: ARRAY
56280: UNION
56281: PPUSH
56282: LD_INT 33
56284: PUSH
56285: LD_INT 2
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: PPUSH
56292: CALL_OW 72
56296: NOT
56297: OR
56298: IFFALSE 56302
// continue ;
56300: GO 56195
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56302: LD_ADDR_VAR 0 9
56306: PUSH
56307: LD_EXP 110
56311: PUSH
56312: LD_VAR 0 2
56316: ARRAY
56317: PPUSH
56318: LD_INT 30
56320: PUSH
56321: LD_INT 36
56323: PUSH
56324: EMPTY
56325: LIST
56326: LIST
56327: PPUSH
56328: CALL_OW 72
56332: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56333: LD_ADDR_VAR 0 10
56337: PUSH
56338: LD_EXP 129
56342: PUSH
56343: LD_VAR 0 2
56347: ARRAY
56348: PPUSH
56349: LD_INT 34
56351: PUSH
56352: LD_INT 31
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PPUSH
56359: CALL_OW 72
56363: ST_TO_ADDR
// if not cts and not mcts then
56364: LD_VAR 0 9
56368: NOT
56369: PUSH
56370: LD_VAR 0 10
56374: NOT
56375: AND
56376: IFFALSE 56380
// continue ;
56378: GO 56195
// x := cts ;
56380: LD_ADDR_VAR 0 11
56384: PUSH
56385: LD_VAR 0 9
56389: ST_TO_ADDR
// if not x then
56390: LD_VAR 0 11
56394: NOT
56395: IFFALSE 56407
// x := mcts ;
56397: LD_ADDR_VAR 0 11
56401: PUSH
56402: LD_VAR 0 10
56406: ST_TO_ADDR
// if not x then
56407: LD_VAR 0 11
56411: NOT
56412: IFFALSE 56416
// continue ;
56414: GO 56195
// if mc_remote_driver [ i ] then
56416: LD_EXP 150
56420: PUSH
56421: LD_VAR 0 2
56425: ARRAY
56426: IFFALSE 56813
// for j in mc_remote_driver [ i ] do
56428: LD_ADDR_VAR 0 3
56432: PUSH
56433: LD_EXP 150
56437: PUSH
56438: LD_VAR 0 2
56442: ARRAY
56443: PUSH
56444: FOR_IN
56445: IFFALSE 56811
// begin if GetClass ( j ) <> 3 then
56447: LD_VAR 0 3
56451: PPUSH
56452: CALL_OW 257
56456: PUSH
56457: LD_INT 3
56459: NONEQUAL
56460: IFFALSE 56513
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56462: LD_ADDR_EXP 150
56466: PUSH
56467: LD_EXP 150
56471: PPUSH
56472: LD_VAR 0 2
56476: PPUSH
56477: LD_EXP 150
56481: PUSH
56482: LD_VAR 0 2
56486: ARRAY
56487: PUSH
56488: LD_VAR 0 3
56492: DIFF
56493: PPUSH
56494: CALL_OW 1
56498: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56499: LD_VAR 0 3
56503: PPUSH
56504: LD_INT 0
56506: PPUSH
56507: CALL_OW 109
// continue ;
56511: GO 56444
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56513: LD_EXP 129
56517: PUSH
56518: LD_VAR 0 2
56522: ARRAY
56523: PPUSH
56524: LD_INT 34
56526: PUSH
56527: LD_INT 31
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PUSH
56534: LD_INT 58
56536: PUSH
56537: EMPTY
56538: LIST
56539: PUSH
56540: EMPTY
56541: LIST
56542: LIST
56543: PPUSH
56544: CALL_OW 72
56548: PUSH
56549: LD_VAR 0 3
56553: PPUSH
56554: CALL 98671 0 1
56558: NOT
56559: AND
56560: IFFALSE 56631
// begin if IsInUnit ( j ) then
56562: LD_VAR 0 3
56566: PPUSH
56567: CALL_OW 310
56571: IFFALSE 56582
// ComExitBuilding ( j ) ;
56573: LD_VAR 0 3
56577: PPUSH
56578: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56582: LD_VAR 0 3
56586: PPUSH
56587: LD_EXP 129
56591: PUSH
56592: LD_VAR 0 2
56596: ARRAY
56597: PPUSH
56598: LD_INT 34
56600: PUSH
56601: LD_INT 31
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: PUSH
56608: LD_INT 58
56610: PUSH
56611: EMPTY
56612: LIST
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: PPUSH
56618: CALL_OW 72
56622: PUSH
56623: LD_INT 1
56625: ARRAY
56626: PPUSH
56627: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56631: LD_VAR 0 3
56635: PPUSH
56636: CALL_OW 310
56640: NOT
56641: PUSH
56642: LD_VAR 0 3
56646: PPUSH
56647: CALL_OW 310
56651: PPUSH
56652: CALL_OW 266
56656: PUSH
56657: LD_INT 36
56659: NONEQUAL
56660: PUSH
56661: LD_VAR 0 3
56665: PPUSH
56666: CALL 98671 0 1
56670: NOT
56671: AND
56672: OR
56673: IFFALSE 56809
// begin if IsInUnit ( j ) then
56675: LD_VAR 0 3
56679: PPUSH
56680: CALL_OW 310
56684: IFFALSE 56695
// ComExitBuilding ( j ) ;
56686: LD_VAR 0 3
56690: PPUSH
56691: CALL_OW 122
// ct := 0 ;
56695: LD_ADDR_VAR 0 8
56699: PUSH
56700: LD_INT 0
56702: ST_TO_ADDR
// for k in x do
56703: LD_ADDR_VAR 0 4
56707: PUSH
56708: LD_VAR 0 11
56712: PUSH
56713: FOR_IN
56714: IFFALSE 56787
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56716: LD_VAR 0 4
56720: PPUSH
56721: CALL_OW 264
56725: PUSH
56726: LD_INT 31
56728: EQUAL
56729: PUSH
56730: LD_VAR 0 4
56734: PPUSH
56735: CALL_OW 311
56739: NOT
56740: AND
56741: PUSH
56742: LD_VAR 0 4
56746: PPUSH
56747: CALL_OW 266
56751: PUSH
56752: LD_INT 36
56754: EQUAL
56755: PUSH
56756: LD_VAR 0 4
56760: PPUSH
56761: CALL_OW 313
56765: PUSH
56766: LD_INT 3
56768: LESS
56769: AND
56770: OR
56771: IFFALSE 56785
// begin ct := k ;
56773: LD_ADDR_VAR 0 8
56777: PUSH
56778: LD_VAR 0 4
56782: ST_TO_ADDR
// break ;
56783: GO 56787
// end ;
56785: GO 56713
56787: POP
56788: POP
// if ct then
56789: LD_VAR 0 8
56793: IFFALSE 56809
// ComEnterUnit ( j , ct ) ;
56795: LD_VAR 0 3
56799: PPUSH
56800: LD_VAR 0 8
56804: PPUSH
56805: CALL_OW 120
// end ; end ;
56809: GO 56444
56811: POP
56812: POP
// places := 0 ;
56813: LD_ADDR_VAR 0 5
56817: PUSH
56818: LD_INT 0
56820: ST_TO_ADDR
// for j = 1 to x do
56821: LD_ADDR_VAR 0 3
56825: PUSH
56826: DOUBLE
56827: LD_INT 1
56829: DEC
56830: ST_TO_ADDR
56831: LD_VAR 0 11
56835: PUSH
56836: FOR_TO
56837: IFFALSE 56913
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56839: LD_VAR 0 11
56843: PUSH
56844: LD_VAR 0 3
56848: ARRAY
56849: PPUSH
56850: CALL_OW 264
56854: PUSH
56855: LD_INT 31
56857: EQUAL
56858: IFFALSE 56876
// places := places + 1 else
56860: LD_ADDR_VAR 0 5
56864: PUSH
56865: LD_VAR 0 5
56869: PUSH
56870: LD_INT 1
56872: PLUS
56873: ST_TO_ADDR
56874: GO 56911
// if GetBType ( x [ j ] ) = b_control_tower then
56876: LD_VAR 0 11
56880: PUSH
56881: LD_VAR 0 3
56885: ARRAY
56886: PPUSH
56887: CALL_OW 266
56891: PUSH
56892: LD_INT 36
56894: EQUAL
56895: IFFALSE 56911
// places := places + 3 ;
56897: LD_ADDR_VAR 0 5
56901: PUSH
56902: LD_VAR 0 5
56906: PUSH
56907: LD_INT 3
56909: PLUS
56910: ST_TO_ADDR
56911: GO 56836
56913: POP
56914: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56915: LD_VAR 0 5
56919: PUSH
56920: LD_INT 0
56922: EQUAL
56923: PUSH
56924: LD_VAR 0 5
56928: PUSH
56929: LD_EXP 150
56933: PUSH
56934: LD_VAR 0 2
56938: ARRAY
56939: LESSEQUAL
56940: OR
56941: IFFALSE 56945
// continue ;
56943: GO 56195
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56945: LD_ADDR_VAR 0 6
56949: PUSH
56950: LD_EXP 110
56954: PUSH
56955: LD_VAR 0 2
56959: ARRAY
56960: PPUSH
56961: LD_INT 25
56963: PUSH
56964: LD_INT 3
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PPUSH
56971: CALL_OW 72
56975: PUSH
56976: LD_EXP 150
56980: PUSH
56981: LD_VAR 0 2
56985: ARRAY
56986: DIFF
56987: PPUSH
56988: LD_INT 3
56990: PPUSH
56991: CALL 99571 0 2
56995: ST_TO_ADDR
// for j in tmp do
56996: LD_ADDR_VAR 0 3
57000: PUSH
57001: LD_VAR 0 6
57005: PUSH
57006: FOR_IN
57007: IFFALSE 57042
// if GetTag ( j ) > 0 then
57009: LD_VAR 0 3
57013: PPUSH
57014: CALL_OW 110
57018: PUSH
57019: LD_INT 0
57021: GREATER
57022: IFFALSE 57040
// tmp := tmp diff j ;
57024: LD_ADDR_VAR 0 6
57028: PUSH
57029: LD_VAR 0 6
57033: PUSH
57034: LD_VAR 0 3
57038: DIFF
57039: ST_TO_ADDR
57040: GO 57006
57042: POP
57043: POP
// if not tmp then
57044: LD_VAR 0 6
57048: NOT
57049: IFFALSE 57053
// continue ;
57051: GO 56195
// if places then
57053: LD_VAR 0 5
57057: IFFALSE 57116
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57059: LD_ADDR_EXP 150
57063: PUSH
57064: LD_EXP 150
57068: PPUSH
57069: LD_VAR 0 2
57073: PPUSH
57074: LD_EXP 150
57078: PUSH
57079: LD_VAR 0 2
57083: ARRAY
57084: PUSH
57085: LD_VAR 0 6
57089: PUSH
57090: LD_INT 1
57092: ARRAY
57093: UNION
57094: PPUSH
57095: CALL_OW 1
57099: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57100: LD_VAR 0 6
57104: PUSH
57105: LD_INT 1
57107: ARRAY
57108: PPUSH
57109: LD_INT 126
57111: PPUSH
57112: CALL_OW 109
// end ; end ;
57116: GO 56195
57118: POP
57119: POP
// end ;
57120: LD_VAR 0 1
57124: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57125: LD_INT 0
57127: PPUSH
57128: PPUSH
57129: PPUSH
57130: PPUSH
57131: PPUSH
57132: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57133: LD_VAR 0 1
57137: NOT
57138: PUSH
57139: LD_VAR 0 2
57143: NOT
57144: OR
57145: PUSH
57146: LD_VAR 0 3
57150: NOT
57151: OR
57152: PUSH
57153: LD_VAR 0 4
57157: PUSH
57158: LD_INT 1
57160: PUSH
57161: LD_INT 2
57163: PUSH
57164: LD_INT 3
57166: PUSH
57167: LD_INT 4
57169: PUSH
57170: LD_INT 5
57172: PUSH
57173: LD_INT 8
57175: PUSH
57176: LD_INT 9
57178: PUSH
57179: LD_INT 15
57181: PUSH
57182: LD_INT 16
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: LIST
57189: LIST
57190: LIST
57191: LIST
57192: LIST
57193: LIST
57194: LIST
57195: IN
57196: NOT
57197: OR
57198: IFFALSE 57202
// exit ;
57200: GO 58102
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57202: LD_ADDR_VAR 0 2
57206: PUSH
57207: LD_VAR 0 2
57211: PPUSH
57212: LD_INT 21
57214: PUSH
57215: LD_INT 3
57217: PUSH
57218: EMPTY
57219: LIST
57220: LIST
57221: PUSH
57222: LD_INT 24
57224: PUSH
57225: LD_INT 250
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: PPUSH
57236: CALL_OW 72
57240: ST_TO_ADDR
// case class of 1 , 15 :
57241: LD_VAR 0 4
57245: PUSH
57246: LD_INT 1
57248: DOUBLE
57249: EQUAL
57250: IFTRUE 57260
57252: LD_INT 15
57254: DOUBLE
57255: EQUAL
57256: IFTRUE 57260
57258: GO 57345
57260: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57261: LD_ADDR_VAR 0 8
57265: PUSH
57266: LD_VAR 0 2
57270: PPUSH
57271: LD_INT 2
57273: PUSH
57274: LD_INT 30
57276: PUSH
57277: LD_INT 32
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: PUSH
57284: LD_INT 30
57286: PUSH
57287: LD_INT 31
57289: PUSH
57290: EMPTY
57291: LIST
57292: LIST
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: LIST
57298: PPUSH
57299: CALL_OW 72
57303: PUSH
57304: LD_VAR 0 2
57308: PPUSH
57309: LD_INT 2
57311: PUSH
57312: LD_INT 30
57314: PUSH
57315: LD_INT 4
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: PUSH
57322: LD_INT 30
57324: PUSH
57325: LD_INT 5
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: PUSH
57332: EMPTY
57333: LIST
57334: LIST
57335: LIST
57336: PPUSH
57337: CALL_OW 72
57341: ADD
57342: ST_TO_ADDR
57343: GO 57591
57345: LD_INT 2
57347: DOUBLE
57348: EQUAL
57349: IFTRUE 57359
57351: LD_INT 16
57353: DOUBLE
57354: EQUAL
57355: IFTRUE 57359
57357: GO 57405
57359: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57360: LD_ADDR_VAR 0 8
57364: PUSH
57365: LD_VAR 0 2
57369: PPUSH
57370: LD_INT 2
57372: PUSH
57373: LD_INT 30
57375: PUSH
57376: LD_INT 0
57378: PUSH
57379: EMPTY
57380: LIST
57381: LIST
57382: PUSH
57383: LD_INT 30
57385: PUSH
57386: LD_INT 1
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: LIST
57397: PPUSH
57398: CALL_OW 72
57402: ST_TO_ADDR
57403: GO 57591
57405: LD_INT 3
57407: DOUBLE
57408: EQUAL
57409: IFTRUE 57413
57411: GO 57459
57413: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57414: LD_ADDR_VAR 0 8
57418: PUSH
57419: LD_VAR 0 2
57423: PPUSH
57424: LD_INT 2
57426: PUSH
57427: LD_INT 30
57429: PUSH
57430: LD_INT 2
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: LD_INT 30
57439: PUSH
57440: LD_INT 3
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PUSH
57447: EMPTY
57448: LIST
57449: LIST
57450: LIST
57451: PPUSH
57452: CALL_OW 72
57456: ST_TO_ADDR
57457: GO 57591
57459: LD_INT 4
57461: DOUBLE
57462: EQUAL
57463: IFTRUE 57467
57465: GO 57524
57467: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57468: LD_ADDR_VAR 0 8
57472: PUSH
57473: LD_VAR 0 2
57477: PPUSH
57478: LD_INT 2
57480: PUSH
57481: LD_INT 30
57483: PUSH
57484: LD_INT 6
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: PUSH
57491: LD_INT 30
57493: PUSH
57494: LD_INT 7
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PUSH
57501: LD_INT 30
57503: PUSH
57504: LD_INT 8
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PUSH
57511: EMPTY
57512: LIST
57513: LIST
57514: LIST
57515: LIST
57516: PPUSH
57517: CALL_OW 72
57521: ST_TO_ADDR
57522: GO 57591
57524: LD_INT 5
57526: DOUBLE
57527: EQUAL
57528: IFTRUE 57544
57530: LD_INT 8
57532: DOUBLE
57533: EQUAL
57534: IFTRUE 57544
57536: LD_INT 9
57538: DOUBLE
57539: EQUAL
57540: IFTRUE 57544
57542: GO 57590
57544: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57545: LD_ADDR_VAR 0 8
57549: PUSH
57550: LD_VAR 0 2
57554: PPUSH
57555: LD_INT 2
57557: PUSH
57558: LD_INT 30
57560: PUSH
57561: LD_INT 4
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PUSH
57568: LD_INT 30
57570: PUSH
57571: LD_INT 5
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: LIST
57582: PPUSH
57583: CALL_OW 72
57587: ST_TO_ADDR
57588: GO 57591
57590: POP
// if not tmp then
57591: LD_VAR 0 8
57595: NOT
57596: IFFALSE 57600
// exit ;
57598: GO 58102
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57600: LD_VAR 0 4
57604: PUSH
57605: LD_INT 1
57607: PUSH
57608: LD_INT 15
57610: PUSH
57611: EMPTY
57612: LIST
57613: LIST
57614: IN
57615: PUSH
57616: LD_EXP 119
57620: PUSH
57621: LD_VAR 0 1
57625: ARRAY
57626: AND
57627: IFFALSE 57783
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57629: LD_ADDR_VAR 0 9
57633: PUSH
57634: LD_EXP 119
57638: PUSH
57639: LD_VAR 0 1
57643: ARRAY
57644: PUSH
57645: LD_INT 1
57647: ARRAY
57648: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57649: LD_VAR 0 9
57653: PUSH
57654: LD_EXP 120
57658: PUSH
57659: LD_VAR 0 1
57663: ARRAY
57664: IN
57665: NOT
57666: IFFALSE 57781
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57668: LD_ADDR_EXP 120
57672: PUSH
57673: LD_EXP 120
57677: PPUSH
57678: LD_VAR 0 1
57682: PUSH
57683: LD_EXP 120
57687: PUSH
57688: LD_VAR 0 1
57692: ARRAY
57693: PUSH
57694: LD_INT 1
57696: PLUS
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: PPUSH
57702: LD_VAR 0 9
57706: PPUSH
57707: CALL 70022 0 3
57711: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57712: LD_ADDR_EXP 119
57716: PUSH
57717: LD_EXP 119
57721: PPUSH
57722: LD_VAR 0 1
57726: PPUSH
57727: LD_EXP 119
57731: PUSH
57732: LD_VAR 0 1
57736: ARRAY
57737: PUSH
57738: LD_VAR 0 9
57742: DIFF
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57749: LD_VAR 0 3
57753: PPUSH
57754: LD_EXP 120
57758: PUSH
57759: LD_VAR 0 1
57763: ARRAY
57764: PUSH
57765: LD_EXP 120
57769: PUSH
57770: LD_VAR 0 1
57774: ARRAY
57775: ARRAY
57776: PPUSH
57777: CALL_OW 120
// end ; exit ;
57781: GO 58102
// end ; if tmp > 1 then
57783: LD_VAR 0 8
57787: PUSH
57788: LD_INT 1
57790: GREATER
57791: IFFALSE 57895
// for i = 2 to tmp do
57793: LD_ADDR_VAR 0 6
57797: PUSH
57798: DOUBLE
57799: LD_INT 2
57801: DEC
57802: ST_TO_ADDR
57803: LD_VAR 0 8
57807: PUSH
57808: FOR_TO
57809: IFFALSE 57893
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57811: LD_VAR 0 8
57815: PUSH
57816: LD_VAR 0 6
57820: ARRAY
57821: PPUSH
57822: CALL_OW 461
57826: PUSH
57827: LD_INT 6
57829: EQUAL
57830: IFFALSE 57891
// begin x := tmp [ i ] ;
57832: LD_ADDR_VAR 0 9
57836: PUSH
57837: LD_VAR 0 8
57841: PUSH
57842: LD_VAR 0 6
57846: ARRAY
57847: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57848: LD_ADDR_VAR 0 8
57852: PUSH
57853: LD_VAR 0 8
57857: PPUSH
57858: LD_VAR 0 6
57862: PPUSH
57863: CALL_OW 3
57867: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57868: LD_ADDR_VAR 0 8
57872: PUSH
57873: LD_VAR 0 8
57877: PPUSH
57878: LD_INT 1
57880: PPUSH
57881: LD_VAR 0 9
57885: PPUSH
57886: CALL_OW 2
57890: ST_TO_ADDR
// end ;
57891: GO 57808
57893: POP
57894: POP
// for i in tmp do
57895: LD_ADDR_VAR 0 6
57899: PUSH
57900: LD_VAR 0 8
57904: PUSH
57905: FOR_IN
57906: IFFALSE 57975
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57908: LD_VAR 0 6
57912: PPUSH
57913: CALL_OW 313
57917: PUSH
57918: LD_INT 6
57920: LESS
57921: PUSH
57922: LD_VAR 0 6
57926: PPUSH
57927: CALL_OW 266
57931: PUSH
57932: LD_INT 31
57934: PUSH
57935: LD_INT 32
57937: PUSH
57938: EMPTY
57939: LIST
57940: LIST
57941: IN
57942: NOT
57943: AND
57944: PUSH
57945: LD_VAR 0 6
57949: PPUSH
57950: CALL_OW 313
57954: PUSH
57955: LD_INT 0
57957: EQUAL
57958: OR
57959: IFFALSE 57973
// begin j := i ;
57961: LD_ADDR_VAR 0 7
57965: PUSH
57966: LD_VAR 0 6
57970: ST_TO_ADDR
// break ;
57971: GO 57975
// end ; end ;
57973: GO 57905
57975: POP
57976: POP
// if j then
57977: LD_VAR 0 7
57981: IFFALSE 57999
// ComEnterUnit ( unit , j ) else
57983: LD_VAR 0 3
57987: PPUSH
57988: LD_VAR 0 7
57992: PPUSH
57993: CALL_OW 120
57997: GO 58102
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57999: LD_ADDR_VAR 0 10
58003: PUSH
58004: LD_VAR 0 2
58008: PPUSH
58009: LD_INT 2
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: LD_INT 0
58017: PUSH
58018: EMPTY
58019: LIST
58020: LIST
58021: PUSH
58022: LD_INT 30
58024: PUSH
58025: LD_INT 1
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: LIST
58036: PPUSH
58037: CALL_OW 72
58041: ST_TO_ADDR
// if depot then
58042: LD_VAR 0 10
58046: IFFALSE 58102
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58048: LD_ADDR_VAR 0 10
58052: PUSH
58053: LD_VAR 0 10
58057: PPUSH
58058: LD_VAR 0 3
58062: PPUSH
58063: CALL_OW 74
58067: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58068: LD_VAR 0 3
58072: PPUSH
58073: LD_VAR 0 10
58077: PPUSH
58078: CALL_OW 296
58082: PUSH
58083: LD_INT 10
58085: GREATER
58086: IFFALSE 58102
// ComStandNearbyBuilding ( unit , depot ) ;
58088: LD_VAR 0 3
58092: PPUSH
58093: LD_VAR 0 10
58097: PPUSH
58098: CALL 66636 0 2
// end ; end ; end ;
58102: LD_VAR 0 5
58106: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58107: LD_INT 0
58109: PPUSH
58110: PPUSH
58111: PPUSH
58112: PPUSH
// if not mc_bases then
58113: LD_EXP 110
58117: NOT
58118: IFFALSE 58122
// exit ;
58120: GO 58361
// for i = 1 to mc_bases do
58122: LD_ADDR_VAR 0 2
58126: PUSH
58127: DOUBLE
58128: LD_INT 1
58130: DEC
58131: ST_TO_ADDR
58132: LD_EXP 110
58136: PUSH
58137: FOR_TO
58138: IFFALSE 58359
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58140: LD_ADDR_VAR 0 4
58144: PUSH
58145: LD_EXP 110
58149: PUSH
58150: LD_VAR 0 2
58154: ARRAY
58155: PPUSH
58156: LD_INT 21
58158: PUSH
58159: LD_INT 1
58161: PUSH
58162: EMPTY
58163: LIST
58164: LIST
58165: PPUSH
58166: CALL_OW 72
58170: PUSH
58171: LD_EXP 139
58175: PUSH
58176: LD_VAR 0 2
58180: ARRAY
58181: UNION
58182: ST_TO_ADDR
// if not tmp then
58183: LD_VAR 0 4
58187: NOT
58188: IFFALSE 58192
// continue ;
58190: GO 58137
// for j in tmp do
58192: LD_ADDR_VAR 0 3
58196: PUSH
58197: LD_VAR 0 4
58201: PUSH
58202: FOR_IN
58203: IFFALSE 58355
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58205: LD_VAR 0 3
58209: PPUSH
58210: CALL_OW 110
58214: NOT
58215: PUSH
58216: LD_VAR 0 3
58220: PPUSH
58221: CALL_OW 314
58225: NOT
58226: AND
58227: PUSH
58228: LD_VAR 0 3
58232: PPUSH
58233: CALL_OW 311
58237: NOT
58238: AND
58239: PUSH
58240: LD_VAR 0 3
58244: PPUSH
58245: CALL_OW 310
58249: NOT
58250: AND
58251: PUSH
58252: LD_VAR 0 3
58256: PUSH
58257: LD_EXP 113
58261: PUSH
58262: LD_VAR 0 2
58266: ARRAY
58267: PUSH
58268: LD_INT 1
58270: ARRAY
58271: IN
58272: NOT
58273: AND
58274: PUSH
58275: LD_VAR 0 3
58279: PUSH
58280: LD_EXP 113
58284: PUSH
58285: LD_VAR 0 2
58289: ARRAY
58290: PUSH
58291: LD_INT 2
58293: ARRAY
58294: IN
58295: NOT
58296: AND
58297: PUSH
58298: LD_VAR 0 3
58302: PUSH
58303: LD_EXP 122
58307: PUSH
58308: LD_VAR 0 2
58312: ARRAY
58313: IN
58314: NOT
58315: AND
58316: IFFALSE 58353
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58318: LD_VAR 0 2
58322: PPUSH
58323: LD_EXP 110
58327: PUSH
58328: LD_VAR 0 2
58332: ARRAY
58333: PPUSH
58334: LD_VAR 0 3
58338: PPUSH
58339: LD_VAR 0 3
58343: PPUSH
58344: CALL_OW 257
58348: PPUSH
58349: CALL 57125 0 4
// end ;
58353: GO 58202
58355: POP
58356: POP
// end ;
58357: GO 58137
58359: POP
58360: POP
// end ;
58361: LD_VAR 0 1
58365: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58366: LD_INT 0
58368: PPUSH
58369: PPUSH
58370: PPUSH
58371: PPUSH
58372: PPUSH
58373: PPUSH
// if not mc_bases [ base ] then
58374: LD_EXP 110
58378: PUSH
58379: LD_VAR 0 1
58383: ARRAY
58384: NOT
58385: IFFALSE 58389
// exit ;
58387: GO 58571
// tmp := [ ] ;
58389: LD_ADDR_VAR 0 6
58393: PUSH
58394: EMPTY
58395: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58396: LD_ADDR_VAR 0 7
58400: PUSH
58401: LD_VAR 0 3
58405: PPUSH
58406: LD_INT 0
58408: PPUSH
58409: CALL_OW 517
58413: ST_TO_ADDR
// if not list then
58414: LD_VAR 0 7
58418: NOT
58419: IFFALSE 58423
// exit ;
58421: GO 58571
// for i = 1 to amount do
58423: LD_ADDR_VAR 0 5
58427: PUSH
58428: DOUBLE
58429: LD_INT 1
58431: DEC
58432: ST_TO_ADDR
58433: LD_VAR 0 2
58437: PUSH
58438: FOR_TO
58439: IFFALSE 58519
// begin x := rand ( 1 , list [ 1 ] ) ;
58441: LD_ADDR_VAR 0 8
58445: PUSH
58446: LD_INT 1
58448: PPUSH
58449: LD_VAR 0 7
58453: PUSH
58454: LD_INT 1
58456: ARRAY
58457: PPUSH
58458: CALL_OW 12
58462: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58463: LD_ADDR_VAR 0 6
58467: PUSH
58468: LD_VAR 0 6
58472: PPUSH
58473: LD_VAR 0 5
58477: PPUSH
58478: LD_VAR 0 7
58482: PUSH
58483: LD_INT 1
58485: ARRAY
58486: PUSH
58487: LD_VAR 0 8
58491: ARRAY
58492: PUSH
58493: LD_VAR 0 7
58497: PUSH
58498: LD_INT 2
58500: ARRAY
58501: PUSH
58502: LD_VAR 0 8
58506: ARRAY
58507: PUSH
58508: EMPTY
58509: LIST
58510: LIST
58511: PPUSH
58512: CALL_OW 1
58516: ST_TO_ADDR
// end ;
58517: GO 58438
58519: POP
58520: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58521: LD_ADDR_EXP 123
58525: PUSH
58526: LD_EXP 123
58530: PPUSH
58531: LD_VAR 0 1
58535: PPUSH
58536: LD_VAR 0 6
58540: PPUSH
58541: CALL_OW 1
58545: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58546: LD_ADDR_EXP 125
58550: PUSH
58551: LD_EXP 125
58555: PPUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: LD_VAR 0 3
58565: PPUSH
58566: CALL_OW 1
58570: ST_TO_ADDR
// end ;
58571: LD_VAR 0 4
58575: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58576: LD_INT 0
58578: PPUSH
// if not mc_bases [ base ] then
58579: LD_EXP 110
58583: PUSH
58584: LD_VAR 0 1
58588: ARRAY
58589: NOT
58590: IFFALSE 58594
// exit ;
58592: GO 58619
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58594: LD_ADDR_EXP 115
58598: PUSH
58599: LD_EXP 115
58603: PPUSH
58604: LD_VAR 0 1
58608: PPUSH
58609: LD_VAR 0 2
58613: PPUSH
58614: CALL_OW 1
58618: ST_TO_ADDR
// end ;
58619: LD_VAR 0 3
58623: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58624: LD_INT 0
58626: PPUSH
// if not mc_bases [ base ] then
58627: LD_EXP 110
58631: PUSH
58632: LD_VAR 0 1
58636: ARRAY
58637: NOT
58638: IFFALSE 58642
// exit ;
58640: GO 58679
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58642: LD_ADDR_EXP 115
58646: PUSH
58647: LD_EXP 115
58651: PPUSH
58652: LD_VAR 0 1
58656: PPUSH
58657: LD_EXP 115
58661: PUSH
58662: LD_VAR 0 1
58666: ARRAY
58667: PUSH
58668: LD_VAR 0 2
58672: UNION
58673: PPUSH
58674: CALL_OW 1
58678: ST_TO_ADDR
// end ;
58679: LD_VAR 0 3
58683: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58684: LD_INT 0
58686: PPUSH
// if not mc_bases [ base ] then
58687: LD_EXP 110
58691: PUSH
58692: LD_VAR 0 1
58696: ARRAY
58697: NOT
58698: IFFALSE 58702
// exit ;
58700: GO 58727
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58702: LD_ADDR_EXP 131
58706: PUSH
58707: LD_EXP 131
58711: PPUSH
58712: LD_VAR 0 1
58716: PPUSH
58717: LD_VAR 0 2
58721: PPUSH
58722: CALL_OW 1
58726: ST_TO_ADDR
// end ;
58727: LD_VAR 0 3
58731: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58732: LD_INT 0
58734: PPUSH
// if not mc_bases [ base ] then
58735: LD_EXP 110
58739: PUSH
58740: LD_VAR 0 1
58744: ARRAY
58745: NOT
58746: IFFALSE 58750
// exit ;
58748: GO 58787
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58750: LD_ADDR_EXP 131
58754: PUSH
58755: LD_EXP 131
58759: PPUSH
58760: LD_VAR 0 1
58764: PPUSH
58765: LD_EXP 131
58769: PUSH
58770: LD_VAR 0 1
58774: ARRAY
58775: PUSH
58776: LD_VAR 0 2
58780: ADD
58781: PPUSH
58782: CALL_OW 1
58786: ST_TO_ADDR
// end ;
58787: LD_VAR 0 3
58791: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58792: LD_INT 0
58794: PPUSH
// if not mc_bases [ base ] then
58795: LD_EXP 110
58799: PUSH
58800: LD_VAR 0 1
58804: ARRAY
58805: NOT
58806: IFFALSE 58810
// exit ;
58808: GO 58864
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58810: LD_ADDR_EXP 132
58814: PUSH
58815: LD_EXP 132
58819: PPUSH
58820: LD_VAR 0 1
58824: PPUSH
58825: LD_VAR 0 2
58829: PPUSH
58830: CALL_OW 1
58834: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58835: LD_ADDR_EXP 121
58839: PUSH
58840: LD_EXP 121
58844: PPUSH
58845: LD_VAR 0 1
58849: PPUSH
58850: LD_VAR 0 2
58854: PUSH
58855: LD_INT 0
58857: PLUS
58858: PPUSH
58859: CALL_OW 1
58863: ST_TO_ADDR
// end ;
58864: LD_VAR 0 3
58868: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58869: LD_INT 0
58871: PPUSH
// if not mc_bases [ base ] then
58872: LD_EXP 110
58876: PUSH
58877: LD_VAR 0 1
58881: ARRAY
58882: NOT
58883: IFFALSE 58887
// exit ;
58885: GO 58912
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58887: LD_ADDR_EXP 121
58891: PUSH
58892: LD_EXP 121
58896: PPUSH
58897: LD_VAR 0 1
58901: PPUSH
58902: LD_VAR 0 2
58906: PPUSH
58907: CALL_OW 1
58911: ST_TO_ADDR
// end ;
58912: LD_VAR 0 3
58916: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58917: LD_INT 0
58919: PPUSH
58920: PPUSH
58921: PPUSH
58922: PPUSH
// if not mc_bases [ base ] then
58923: LD_EXP 110
58927: PUSH
58928: LD_VAR 0 1
58932: ARRAY
58933: NOT
58934: IFFALSE 58938
// exit ;
58936: GO 59003
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58938: LD_ADDR_EXP 130
58942: PUSH
58943: LD_EXP 130
58947: PPUSH
58948: LD_VAR 0 1
58952: PUSH
58953: LD_EXP 130
58957: PUSH
58958: LD_VAR 0 1
58962: ARRAY
58963: PUSH
58964: LD_INT 1
58966: PLUS
58967: PUSH
58968: EMPTY
58969: LIST
58970: LIST
58971: PPUSH
58972: LD_VAR 0 1
58976: PUSH
58977: LD_VAR 0 2
58981: PUSH
58982: LD_VAR 0 3
58986: PUSH
58987: LD_VAR 0 4
58991: PUSH
58992: EMPTY
58993: LIST
58994: LIST
58995: LIST
58996: LIST
58997: PPUSH
58998: CALL 70022 0 3
59002: ST_TO_ADDR
// end ;
59003: LD_VAR 0 5
59007: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59008: LD_INT 0
59010: PPUSH
// if not mc_bases [ base ] then
59011: LD_EXP 110
59015: PUSH
59016: LD_VAR 0 1
59020: ARRAY
59021: NOT
59022: IFFALSE 59026
// exit ;
59024: GO 59051
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59026: LD_ADDR_EXP 147
59030: PUSH
59031: LD_EXP 147
59035: PPUSH
59036: LD_VAR 0 1
59040: PPUSH
59041: LD_VAR 0 2
59045: PPUSH
59046: CALL_OW 1
59050: ST_TO_ADDR
// end ;
59051: LD_VAR 0 3
59055: RET
// export function MC_GetMinesField ( base ) ; begin
59056: LD_INT 0
59058: PPUSH
// result := mc_mines [ base ] ;
59059: LD_ADDR_VAR 0 2
59063: PUSH
59064: LD_EXP 123
59068: PUSH
59069: LD_VAR 0 1
59073: ARRAY
59074: ST_TO_ADDR
// end ;
59075: LD_VAR 0 2
59079: RET
// export function MC_GetProduceList ( base ) ; begin
59080: LD_INT 0
59082: PPUSH
// result := mc_produce [ base ] ;
59083: LD_ADDR_VAR 0 2
59087: PUSH
59088: LD_EXP 131
59092: PUSH
59093: LD_VAR 0 1
59097: ARRAY
59098: ST_TO_ADDR
// end ;
59099: LD_VAR 0 2
59103: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59104: LD_INT 0
59106: PPUSH
59107: PPUSH
// if not mc_bases then
59108: LD_EXP 110
59112: NOT
59113: IFFALSE 59117
// exit ;
59115: GO 59182
// if mc_bases [ base ] then
59117: LD_EXP 110
59121: PUSH
59122: LD_VAR 0 1
59126: ARRAY
59127: IFFALSE 59182
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59129: LD_ADDR_VAR 0 3
59133: PUSH
59134: LD_EXP 110
59138: PUSH
59139: LD_VAR 0 1
59143: ARRAY
59144: PPUSH
59145: LD_INT 30
59147: PUSH
59148: LD_VAR 0 2
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PPUSH
59157: CALL_OW 72
59161: ST_TO_ADDR
// if result then
59162: LD_VAR 0 3
59166: IFFALSE 59182
// result := result [ 1 ] ;
59168: LD_ADDR_VAR 0 3
59172: PUSH
59173: LD_VAR 0 3
59177: PUSH
59178: LD_INT 1
59180: ARRAY
59181: ST_TO_ADDR
// end ; end ;
59182: LD_VAR 0 3
59186: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59187: LD_INT 0
59189: PPUSH
59190: PPUSH
// if not mc_bases then
59191: LD_EXP 110
59195: NOT
59196: IFFALSE 59200
// exit ;
59198: GO 59245
// if mc_bases [ base ] then
59200: LD_EXP 110
59204: PUSH
59205: LD_VAR 0 1
59209: ARRAY
59210: IFFALSE 59245
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59212: LD_ADDR_VAR 0 3
59216: PUSH
59217: LD_EXP 110
59221: PUSH
59222: LD_VAR 0 1
59226: ARRAY
59227: PPUSH
59228: LD_INT 30
59230: PUSH
59231: LD_VAR 0 2
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PPUSH
59240: CALL_OW 72
59244: ST_TO_ADDR
// end ;
59245: LD_VAR 0 3
59249: RET
// export function MC_SetTame ( base , area ) ; begin
59250: LD_INT 0
59252: PPUSH
// if not mc_bases or not base then
59253: LD_EXP 110
59257: NOT
59258: PUSH
59259: LD_VAR 0 1
59263: NOT
59264: OR
59265: IFFALSE 59269
// exit ;
59267: GO 59294
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59269: LD_ADDR_EXP 138
59273: PUSH
59274: LD_EXP 138
59278: PPUSH
59279: LD_VAR 0 1
59283: PPUSH
59284: LD_VAR 0 2
59288: PPUSH
59289: CALL_OW 1
59293: ST_TO_ADDR
// end ;
59294: LD_VAR 0 3
59298: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59299: LD_INT 0
59301: PPUSH
59302: PPUSH
// if not mc_bases or not base then
59303: LD_EXP 110
59307: NOT
59308: PUSH
59309: LD_VAR 0 1
59313: NOT
59314: OR
59315: IFFALSE 59319
// exit ;
59317: GO 59421
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59319: LD_ADDR_VAR 0 4
59323: PUSH
59324: LD_EXP 110
59328: PUSH
59329: LD_VAR 0 1
59333: ARRAY
59334: PPUSH
59335: LD_INT 30
59337: PUSH
59338: LD_VAR 0 2
59342: PUSH
59343: EMPTY
59344: LIST
59345: LIST
59346: PPUSH
59347: CALL_OW 72
59351: ST_TO_ADDR
// if not tmp then
59352: LD_VAR 0 4
59356: NOT
59357: IFFALSE 59361
// exit ;
59359: GO 59421
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59361: LD_ADDR_EXP 142
59365: PUSH
59366: LD_EXP 142
59370: PPUSH
59371: LD_VAR 0 1
59375: PPUSH
59376: LD_EXP 142
59380: PUSH
59381: LD_VAR 0 1
59385: ARRAY
59386: PPUSH
59387: LD_EXP 142
59391: PUSH
59392: LD_VAR 0 1
59396: ARRAY
59397: PUSH
59398: LD_INT 1
59400: PLUS
59401: PPUSH
59402: LD_VAR 0 4
59406: PUSH
59407: LD_INT 1
59409: ARRAY
59410: PPUSH
59411: CALL_OW 2
59415: PPUSH
59416: CALL_OW 1
59420: ST_TO_ADDR
// end ;
59421: LD_VAR 0 3
59425: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59426: LD_INT 0
59428: PPUSH
59429: PPUSH
// if not mc_bases or not base or not kinds then
59430: LD_EXP 110
59434: NOT
59435: PUSH
59436: LD_VAR 0 1
59440: NOT
59441: OR
59442: PUSH
59443: LD_VAR 0 2
59447: NOT
59448: OR
59449: IFFALSE 59453
// exit ;
59451: GO 59514
// for i in kinds do
59453: LD_ADDR_VAR 0 4
59457: PUSH
59458: LD_VAR 0 2
59462: PUSH
59463: FOR_IN
59464: IFFALSE 59512
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59466: LD_ADDR_EXP 144
59470: PUSH
59471: LD_EXP 144
59475: PPUSH
59476: LD_VAR 0 1
59480: PUSH
59481: LD_EXP 144
59485: PUSH
59486: LD_VAR 0 1
59490: ARRAY
59491: PUSH
59492: LD_INT 1
59494: PLUS
59495: PUSH
59496: EMPTY
59497: LIST
59498: LIST
59499: PPUSH
59500: LD_VAR 0 4
59504: PPUSH
59505: CALL 70022 0 3
59509: ST_TO_ADDR
59510: GO 59463
59512: POP
59513: POP
// end ;
59514: LD_VAR 0 3
59518: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59519: LD_INT 0
59521: PPUSH
// if not mc_bases or not base or not areas then
59522: LD_EXP 110
59526: NOT
59527: PUSH
59528: LD_VAR 0 1
59532: NOT
59533: OR
59534: PUSH
59535: LD_VAR 0 2
59539: NOT
59540: OR
59541: IFFALSE 59545
// exit ;
59543: GO 59570
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59545: LD_ADDR_EXP 128
59549: PUSH
59550: LD_EXP 128
59554: PPUSH
59555: LD_VAR 0 1
59559: PPUSH
59560: LD_VAR 0 2
59564: PPUSH
59565: CALL_OW 1
59569: ST_TO_ADDR
// end ;
59570: LD_VAR 0 3
59574: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59575: LD_INT 0
59577: PPUSH
// if not mc_bases or not base or not teleports_exit then
59578: LD_EXP 110
59582: NOT
59583: PUSH
59584: LD_VAR 0 1
59588: NOT
59589: OR
59590: PUSH
59591: LD_VAR 0 2
59595: NOT
59596: OR
59597: IFFALSE 59601
// exit ;
59599: GO 59626
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59601: LD_ADDR_EXP 145
59605: PUSH
59606: LD_EXP 145
59610: PPUSH
59611: LD_VAR 0 1
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: CALL_OW 1
59625: ST_TO_ADDR
// end ;
59626: LD_VAR 0 3
59630: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59631: LD_INT 0
59633: PPUSH
59634: PPUSH
59635: PPUSH
// if not mc_bases or not base or not ext_list then
59636: LD_EXP 110
59640: NOT
59641: PUSH
59642: LD_VAR 0 1
59646: NOT
59647: OR
59648: PUSH
59649: LD_VAR 0 5
59653: NOT
59654: OR
59655: IFFALSE 59659
// exit ;
59657: GO 59832
// tmp := GetFacExtXYD ( x , y , d ) ;
59659: LD_ADDR_VAR 0 8
59663: PUSH
59664: LD_VAR 0 2
59668: PPUSH
59669: LD_VAR 0 3
59673: PPUSH
59674: LD_VAR 0 4
59678: PPUSH
59679: CALL 98701 0 3
59683: ST_TO_ADDR
// if not tmp then
59684: LD_VAR 0 8
59688: NOT
59689: IFFALSE 59693
// exit ;
59691: GO 59832
// for i in tmp do
59693: LD_ADDR_VAR 0 7
59697: PUSH
59698: LD_VAR 0 8
59702: PUSH
59703: FOR_IN
59704: IFFALSE 59830
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59706: LD_ADDR_EXP 115
59710: PUSH
59711: LD_EXP 115
59715: PPUSH
59716: LD_VAR 0 1
59720: PPUSH
59721: LD_EXP 115
59725: PUSH
59726: LD_VAR 0 1
59730: ARRAY
59731: PPUSH
59732: LD_EXP 115
59736: PUSH
59737: LD_VAR 0 1
59741: ARRAY
59742: PUSH
59743: LD_INT 1
59745: PLUS
59746: PPUSH
59747: LD_VAR 0 5
59751: PUSH
59752: LD_INT 1
59754: ARRAY
59755: PUSH
59756: LD_VAR 0 7
59760: PUSH
59761: LD_INT 1
59763: ARRAY
59764: PUSH
59765: LD_VAR 0 7
59769: PUSH
59770: LD_INT 2
59772: ARRAY
59773: PUSH
59774: LD_VAR 0 7
59778: PUSH
59779: LD_INT 3
59781: ARRAY
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: LIST
59787: LIST
59788: PPUSH
59789: CALL_OW 2
59793: PPUSH
59794: CALL_OW 1
59798: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59799: LD_ADDR_VAR 0 5
59803: PUSH
59804: LD_VAR 0 5
59808: PPUSH
59809: LD_INT 1
59811: PPUSH
59812: CALL_OW 3
59816: ST_TO_ADDR
// if not ext_list then
59817: LD_VAR 0 5
59821: NOT
59822: IFFALSE 59828
// exit ;
59824: POP
59825: POP
59826: GO 59832
// end ;
59828: GO 59703
59830: POP
59831: POP
// end ;
59832: LD_VAR 0 6
59836: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59837: LD_INT 0
59839: PPUSH
// if not mc_bases or not base or not weapon_list then
59840: LD_EXP 110
59844: NOT
59845: PUSH
59846: LD_VAR 0 1
59850: NOT
59851: OR
59852: PUSH
59853: LD_VAR 0 2
59857: NOT
59858: OR
59859: IFFALSE 59863
// exit ;
59861: GO 59888
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59863: LD_ADDR_EXP 149
59867: PUSH
59868: LD_EXP 149
59872: PPUSH
59873: LD_VAR 0 1
59877: PPUSH
59878: LD_VAR 0 2
59882: PPUSH
59883: CALL_OW 1
59887: ST_TO_ADDR
// end ;
59888: LD_VAR 0 3
59892: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59893: LD_INT 0
59895: PPUSH
// if not mc_bases or not base or not tech_list then
59896: LD_EXP 110
59900: NOT
59901: PUSH
59902: LD_VAR 0 1
59906: NOT
59907: OR
59908: PUSH
59909: LD_VAR 0 2
59913: NOT
59914: OR
59915: IFFALSE 59919
// exit ;
59917: GO 59944
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59919: LD_ADDR_EXP 137
59923: PUSH
59924: LD_EXP 137
59928: PPUSH
59929: LD_VAR 0 1
59933: PPUSH
59934: LD_VAR 0 2
59938: PPUSH
59939: CALL_OW 1
59943: ST_TO_ADDR
// end ;
59944: LD_VAR 0 3
59948: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59949: LD_INT 0
59951: PPUSH
// if not mc_bases or not parking_area or not base then
59952: LD_EXP 110
59956: NOT
59957: PUSH
59958: LD_VAR 0 2
59962: NOT
59963: OR
59964: PUSH
59965: LD_VAR 0 1
59969: NOT
59970: OR
59971: IFFALSE 59975
// exit ;
59973: GO 60000
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59975: LD_ADDR_EXP 134
59979: PUSH
59980: LD_EXP 134
59984: PPUSH
59985: LD_VAR 0 1
59989: PPUSH
59990: LD_VAR 0 2
59994: PPUSH
59995: CALL_OW 1
59999: ST_TO_ADDR
// end ;
60000: LD_VAR 0 3
60004: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60005: LD_INT 0
60007: PPUSH
// if not mc_bases or not base or not scan_area then
60008: LD_EXP 110
60012: NOT
60013: PUSH
60014: LD_VAR 0 1
60018: NOT
60019: OR
60020: PUSH
60021: LD_VAR 0 2
60025: NOT
60026: OR
60027: IFFALSE 60031
// exit ;
60029: GO 60056
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60031: LD_ADDR_EXP 135
60035: PUSH
60036: LD_EXP 135
60040: PPUSH
60041: LD_VAR 0 1
60045: PPUSH
60046: LD_VAR 0 2
60050: PPUSH
60051: CALL_OW 1
60055: ST_TO_ADDR
// end ;
60056: LD_VAR 0 3
60060: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60061: LD_INT 0
60063: PPUSH
60064: PPUSH
// if not mc_bases or not base then
60065: LD_EXP 110
60069: NOT
60070: PUSH
60071: LD_VAR 0 1
60075: NOT
60076: OR
60077: IFFALSE 60081
// exit ;
60079: GO 60145
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60081: LD_ADDR_VAR 0 3
60085: PUSH
60086: LD_INT 1
60088: PUSH
60089: LD_INT 2
60091: PUSH
60092: LD_INT 3
60094: PUSH
60095: LD_INT 4
60097: PUSH
60098: LD_INT 11
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: LIST
60105: LIST
60106: LIST
60107: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60108: LD_ADDR_EXP 137
60112: PUSH
60113: LD_EXP 137
60117: PPUSH
60118: LD_VAR 0 1
60122: PPUSH
60123: LD_EXP 137
60127: PUSH
60128: LD_VAR 0 1
60132: ARRAY
60133: PUSH
60134: LD_VAR 0 3
60138: DIFF
60139: PPUSH
60140: CALL_OW 1
60144: ST_TO_ADDR
// end ;
60145: LD_VAR 0 2
60149: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60150: LD_INT 0
60152: PPUSH
// result := mc_vehicles [ base ] ;
60153: LD_ADDR_VAR 0 3
60157: PUSH
60158: LD_EXP 129
60162: PUSH
60163: LD_VAR 0 1
60167: ARRAY
60168: ST_TO_ADDR
// if onlyCombat then
60169: LD_VAR 0 2
60173: IFFALSE 60338
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60175: LD_ADDR_VAR 0 3
60179: PUSH
60180: LD_VAR 0 3
60184: PUSH
60185: LD_VAR 0 3
60189: PPUSH
60190: LD_INT 2
60192: PUSH
60193: LD_INT 34
60195: PUSH
60196: LD_INT 12
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: PUSH
60203: LD_INT 34
60205: PUSH
60206: LD_INT 51
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: PUSH
60213: LD_INT 34
60215: PUSH
60216: LD_EXP 96
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: LD_INT 34
60227: PUSH
60228: LD_INT 32
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 34
60237: PUSH
60238: LD_INT 13
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: LD_INT 34
60247: PUSH
60248: LD_INT 52
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: PUSH
60255: LD_INT 34
60257: PUSH
60258: LD_INT 14
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PUSH
60265: LD_INT 34
60267: PUSH
60268: LD_INT 53
60270: PUSH
60271: EMPTY
60272: LIST
60273: LIST
60274: PUSH
60275: LD_INT 34
60277: PUSH
60278: LD_EXP 95
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PUSH
60287: LD_INT 34
60289: PUSH
60290: LD_INT 31
60292: PUSH
60293: EMPTY
60294: LIST
60295: LIST
60296: PUSH
60297: LD_INT 34
60299: PUSH
60300: LD_INT 48
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: PUSH
60307: LD_INT 34
60309: PUSH
60310: LD_INT 8
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: PUSH
60317: EMPTY
60318: LIST
60319: LIST
60320: LIST
60321: LIST
60322: LIST
60323: LIST
60324: LIST
60325: LIST
60326: LIST
60327: LIST
60328: LIST
60329: LIST
60330: LIST
60331: PPUSH
60332: CALL_OW 72
60336: DIFF
60337: ST_TO_ADDR
// end ; end_of_file
60338: LD_VAR 0 3
60342: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60343: LD_INT 0
60345: PPUSH
60346: PPUSH
60347: PPUSH
// if not mc_bases or not skirmish then
60348: LD_EXP 110
60352: NOT
60353: PUSH
60354: LD_EXP 108
60358: NOT
60359: OR
60360: IFFALSE 60364
// exit ;
60362: GO 60529
// for i = 1 to mc_bases do
60364: LD_ADDR_VAR 0 4
60368: PUSH
60369: DOUBLE
60370: LD_INT 1
60372: DEC
60373: ST_TO_ADDR
60374: LD_EXP 110
60378: PUSH
60379: FOR_TO
60380: IFFALSE 60527
// begin if sci in mc_bases [ i ] then
60382: LD_VAR 0 2
60386: PUSH
60387: LD_EXP 110
60391: PUSH
60392: LD_VAR 0 4
60396: ARRAY
60397: IN
60398: IFFALSE 60525
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60400: LD_ADDR_EXP 139
60404: PUSH
60405: LD_EXP 139
60409: PPUSH
60410: LD_VAR 0 4
60414: PUSH
60415: LD_EXP 139
60419: PUSH
60420: LD_VAR 0 4
60424: ARRAY
60425: PUSH
60426: LD_INT 1
60428: PLUS
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PPUSH
60434: LD_VAR 0 1
60438: PPUSH
60439: CALL 70022 0 3
60443: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60444: LD_ADDR_VAR 0 5
60448: PUSH
60449: LD_EXP 110
60453: PUSH
60454: LD_VAR 0 4
60458: ARRAY
60459: PPUSH
60460: LD_INT 2
60462: PUSH
60463: LD_INT 30
60465: PUSH
60466: LD_INT 0
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: PUSH
60473: LD_INT 30
60475: PUSH
60476: LD_INT 1
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: PUSH
60483: EMPTY
60484: LIST
60485: LIST
60486: LIST
60487: PPUSH
60488: CALL_OW 72
60492: PPUSH
60493: LD_VAR 0 1
60497: PPUSH
60498: CALL_OW 74
60502: ST_TO_ADDR
// if tmp then
60503: LD_VAR 0 5
60507: IFFALSE 60523
// ComStandNearbyBuilding ( ape , tmp ) ;
60509: LD_VAR 0 1
60513: PPUSH
60514: LD_VAR 0 5
60518: PPUSH
60519: CALL 66636 0 2
// break ;
60523: GO 60527
// end ; end ;
60525: GO 60379
60527: POP
60528: POP
// end ;
60529: LD_VAR 0 3
60533: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
60538: PPUSH
// if not mc_bases or not skirmish then
60539: LD_EXP 110
60543: NOT
60544: PUSH
60545: LD_EXP 108
60549: NOT
60550: OR
60551: IFFALSE 60555
// exit ;
60553: GO 60644
// for i = 1 to mc_bases do
60555: LD_ADDR_VAR 0 4
60559: PUSH
60560: DOUBLE
60561: LD_INT 1
60563: DEC
60564: ST_TO_ADDR
60565: LD_EXP 110
60569: PUSH
60570: FOR_TO
60571: IFFALSE 60642
// begin if building in mc_busy_turret_list [ i ] then
60573: LD_VAR 0 1
60577: PUSH
60578: LD_EXP 120
60582: PUSH
60583: LD_VAR 0 4
60587: ARRAY
60588: IN
60589: IFFALSE 60640
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60591: LD_ADDR_VAR 0 5
60595: PUSH
60596: LD_EXP 120
60600: PUSH
60601: LD_VAR 0 4
60605: ARRAY
60606: PUSH
60607: LD_VAR 0 1
60611: DIFF
60612: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60613: LD_ADDR_EXP 120
60617: PUSH
60618: LD_EXP 120
60622: PPUSH
60623: LD_VAR 0 4
60627: PPUSH
60628: LD_VAR 0 5
60632: PPUSH
60633: CALL_OW 1
60637: ST_TO_ADDR
// break ;
60638: GO 60642
// end ; end ;
60640: GO 60570
60642: POP
60643: POP
// end ;
60644: LD_VAR 0 3
60648: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60649: LD_INT 0
60651: PPUSH
60652: PPUSH
60653: PPUSH
// if not mc_bases or not skirmish then
60654: LD_EXP 110
60658: NOT
60659: PUSH
60660: LD_EXP 108
60664: NOT
60665: OR
60666: IFFALSE 60670
// exit ;
60668: GO 60869
// for i = 1 to mc_bases do
60670: LD_ADDR_VAR 0 5
60674: PUSH
60675: DOUBLE
60676: LD_INT 1
60678: DEC
60679: ST_TO_ADDR
60680: LD_EXP 110
60684: PUSH
60685: FOR_TO
60686: IFFALSE 60867
// if building in mc_bases [ i ] then
60688: LD_VAR 0 1
60692: PUSH
60693: LD_EXP 110
60697: PUSH
60698: LD_VAR 0 5
60702: ARRAY
60703: IN
60704: IFFALSE 60865
// begin tmp := mc_bases [ i ] diff building ;
60706: LD_ADDR_VAR 0 6
60710: PUSH
60711: LD_EXP 110
60715: PUSH
60716: LD_VAR 0 5
60720: ARRAY
60721: PUSH
60722: LD_VAR 0 1
60726: DIFF
60727: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60728: LD_ADDR_EXP 110
60732: PUSH
60733: LD_EXP 110
60737: PPUSH
60738: LD_VAR 0 5
60742: PPUSH
60743: LD_VAR 0 6
60747: PPUSH
60748: CALL_OW 1
60752: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60753: LD_VAR 0 1
60757: PUSH
60758: LD_EXP 118
60762: PUSH
60763: LD_VAR 0 5
60767: ARRAY
60768: IN
60769: IFFALSE 60808
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60771: LD_ADDR_EXP 118
60775: PUSH
60776: LD_EXP 118
60780: PPUSH
60781: LD_VAR 0 5
60785: PPUSH
60786: LD_EXP 118
60790: PUSH
60791: LD_VAR 0 5
60795: ARRAY
60796: PUSH
60797: LD_VAR 0 1
60801: DIFF
60802: PPUSH
60803: CALL_OW 1
60807: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60808: LD_VAR 0 1
60812: PUSH
60813: LD_EXP 119
60817: PUSH
60818: LD_VAR 0 5
60822: ARRAY
60823: IN
60824: IFFALSE 60863
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60826: LD_ADDR_EXP 119
60830: PUSH
60831: LD_EXP 119
60835: PPUSH
60836: LD_VAR 0 5
60840: PPUSH
60841: LD_EXP 119
60845: PUSH
60846: LD_VAR 0 5
60850: ARRAY
60851: PUSH
60852: LD_VAR 0 1
60856: DIFF
60857: PPUSH
60858: CALL_OW 1
60862: ST_TO_ADDR
// break ;
60863: GO 60867
// end ;
60865: GO 60685
60867: POP
60868: POP
// end ;
60869: LD_VAR 0 4
60873: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60874: LD_INT 0
60876: PPUSH
60877: PPUSH
60878: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60879: LD_EXP 110
60883: NOT
60884: PUSH
60885: LD_EXP 108
60889: NOT
60890: OR
60891: PUSH
60892: LD_VAR 0 3
60896: PUSH
60897: LD_EXP 136
60901: IN
60902: NOT
60903: OR
60904: IFFALSE 60908
// exit ;
60906: GO 61031
// for i = 1 to mc_vehicles do
60908: LD_ADDR_VAR 0 6
60912: PUSH
60913: DOUBLE
60914: LD_INT 1
60916: DEC
60917: ST_TO_ADDR
60918: LD_EXP 129
60922: PUSH
60923: FOR_TO
60924: IFFALSE 61029
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60926: LD_VAR 0 2
60930: PUSH
60931: LD_EXP 129
60935: PUSH
60936: LD_VAR 0 6
60940: ARRAY
60941: IN
60942: PUSH
60943: LD_VAR 0 1
60947: PUSH
60948: LD_EXP 129
60952: PUSH
60953: LD_VAR 0 6
60957: ARRAY
60958: IN
60959: OR
60960: IFFALSE 61027
// begin tmp := mc_vehicles [ i ] diff old ;
60962: LD_ADDR_VAR 0 7
60966: PUSH
60967: LD_EXP 129
60971: PUSH
60972: LD_VAR 0 6
60976: ARRAY
60977: PUSH
60978: LD_VAR 0 2
60982: DIFF
60983: ST_TO_ADDR
// tmp := tmp diff new ;
60984: LD_ADDR_VAR 0 7
60988: PUSH
60989: LD_VAR 0 7
60993: PUSH
60994: LD_VAR 0 1
60998: DIFF
60999: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61000: LD_ADDR_EXP 129
61004: PUSH
61005: LD_EXP 129
61009: PPUSH
61010: LD_VAR 0 6
61014: PPUSH
61015: LD_VAR 0 7
61019: PPUSH
61020: CALL_OW 1
61024: ST_TO_ADDR
// break ;
61025: GO 61029
// end ;
61027: GO 60923
61029: POP
61030: POP
// end ;
61031: LD_VAR 0 5
61035: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61036: LD_INT 0
61038: PPUSH
61039: PPUSH
61040: PPUSH
61041: PPUSH
// if not mc_bases or not skirmish then
61042: LD_EXP 110
61046: NOT
61047: PUSH
61048: LD_EXP 108
61052: NOT
61053: OR
61054: IFFALSE 61058
// exit ;
61056: GO 61435
// side := GetSide ( vehicle ) ;
61058: LD_ADDR_VAR 0 5
61062: PUSH
61063: LD_VAR 0 1
61067: PPUSH
61068: CALL_OW 255
61072: ST_TO_ADDR
// for i = 1 to mc_bases do
61073: LD_ADDR_VAR 0 4
61077: PUSH
61078: DOUBLE
61079: LD_INT 1
61081: DEC
61082: ST_TO_ADDR
61083: LD_EXP 110
61087: PUSH
61088: FOR_TO
61089: IFFALSE 61433
// begin if factory in mc_bases [ i ] then
61091: LD_VAR 0 2
61095: PUSH
61096: LD_EXP 110
61100: PUSH
61101: LD_VAR 0 4
61105: ARRAY
61106: IN
61107: IFFALSE 61431
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61109: LD_EXP 132
61113: PUSH
61114: LD_VAR 0 4
61118: ARRAY
61119: PUSH
61120: LD_EXP 121
61124: PUSH
61125: LD_VAR 0 4
61129: ARRAY
61130: LESS
61131: PUSH
61132: LD_VAR 0 1
61136: PPUSH
61137: CALL_OW 264
61141: PUSH
61142: LD_INT 31
61144: PUSH
61145: LD_INT 32
61147: PUSH
61148: LD_INT 51
61150: PUSH
61151: LD_EXP 96
61155: PUSH
61156: LD_INT 12
61158: PUSH
61159: LD_INT 30
61161: PUSH
61162: LD_EXP 95
61166: PUSH
61167: LD_INT 11
61169: PUSH
61170: LD_INT 53
61172: PUSH
61173: LD_INT 14
61175: PUSH
61176: LD_EXP 99
61180: PUSH
61181: LD_INT 29
61183: PUSH
61184: LD_EXP 97
61188: PUSH
61189: LD_INT 13
61191: PUSH
61192: LD_INT 52
61194: PUSH
61195: LD_INT 48
61197: PUSH
61198: LD_INT 8
61200: PUSH
61201: EMPTY
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: LIST
61215: LIST
61216: LIST
61217: LIST
61218: LIST
61219: IN
61220: NOT
61221: AND
61222: IFFALSE 61270
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61224: LD_ADDR_EXP 132
61228: PUSH
61229: LD_EXP 132
61233: PPUSH
61234: LD_VAR 0 4
61238: PUSH
61239: LD_EXP 132
61243: PUSH
61244: LD_VAR 0 4
61248: ARRAY
61249: PUSH
61250: LD_INT 1
61252: PLUS
61253: PUSH
61254: EMPTY
61255: LIST
61256: LIST
61257: PPUSH
61258: LD_VAR 0 1
61262: PPUSH
61263: CALL 70022 0 3
61267: ST_TO_ADDR
61268: GO 61314
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61270: LD_ADDR_EXP 129
61274: PUSH
61275: LD_EXP 129
61279: PPUSH
61280: LD_VAR 0 4
61284: PUSH
61285: LD_EXP 129
61289: PUSH
61290: LD_VAR 0 4
61294: ARRAY
61295: PUSH
61296: LD_INT 1
61298: PLUS
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PPUSH
61304: LD_VAR 0 1
61308: PPUSH
61309: CALL 70022 0 3
61313: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61314: LD_VAR 0 1
61318: PPUSH
61319: CALL_OW 263
61323: PUSH
61324: LD_INT 2
61326: EQUAL
61327: IFFALSE 61347
// begin repeat wait ( 0 0$1 ) ;
61329: LD_INT 35
61331: PPUSH
61332: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61336: LD_VAR 0 1
61340: PPUSH
61341: CALL_OW 312
61345: IFFALSE 61329
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61347: LD_VAR 0 1
61351: PPUSH
61352: LD_EXP 134
61356: PUSH
61357: LD_VAR 0 4
61361: ARRAY
61362: PPUSH
61363: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61367: LD_VAR 0 1
61371: PPUSH
61372: CALL_OW 263
61376: PUSH
61377: LD_INT 1
61379: NONEQUAL
61380: IFFALSE 61384
// break ;
61382: GO 61433
// repeat wait ( 0 0$1 ) ;
61384: LD_INT 35
61386: PPUSH
61387: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61391: LD_VAR 0 1
61395: PPUSH
61396: LD_EXP 134
61400: PUSH
61401: LD_VAR 0 4
61405: ARRAY
61406: PPUSH
61407: CALL_OW 308
61411: IFFALSE 61384
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61413: LD_VAR 0 1
61417: PPUSH
61418: CALL_OW 311
61422: PPUSH
61423: CALL_OW 121
// exit ;
61427: POP
61428: POP
61429: GO 61435
// end ; end ;
61431: GO 61088
61433: POP
61434: POP
// end ;
61435: LD_VAR 0 3
61439: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61440: LD_INT 0
61442: PPUSH
61443: PPUSH
61444: PPUSH
61445: PPUSH
// if not mc_bases or not skirmish then
61446: LD_EXP 110
61450: NOT
61451: PUSH
61452: LD_EXP 108
61456: NOT
61457: OR
61458: IFFALSE 61462
// exit ;
61460: GO 61815
// repeat wait ( 0 0$1 ) ;
61462: LD_INT 35
61464: PPUSH
61465: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61469: LD_VAR 0 2
61473: PPUSH
61474: LD_VAR 0 3
61478: PPUSH
61479: CALL_OW 284
61483: IFFALSE 61462
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61485: LD_VAR 0 2
61489: PPUSH
61490: LD_VAR 0 3
61494: PPUSH
61495: CALL_OW 283
61499: PUSH
61500: LD_INT 4
61502: EQUAL
61503: IFFALSE 61507
// exit ;
61505: GO 61815
// for i = 1 to mc_bases do
61507: LD_ADDR_VAR 0 7
61511: PUSH
61512: DOUBLE
61513: LD_INT 1
61515: DEC
61516: ST_TO_ADDR
61517: LD_EXP 110
61521: PUSH
61522: FOR_TO
61523: IFFALSE 61813
// begin if mc_crates_area [ i ] then
61525: LD_EXP 128
61529: PUSH
61530: LD_VAR 0 7
61534: ARRAY
61535: IFFALSE 61646
// for j in mc_crates_area [ i ] do
61537: LD_ADDR_VAR 0 8
61541: PUSH
61542: LD_EXP 128
61546: PUSH
61547: LD_VAR 0 7
61551: ARRAY
61552: PUSH
61553: FOR_IN
61554: IFFALSE 61644
// if InArea ( x , y , j ) then
61556: LD_VAR 0 2
61560: PPUSH
61561: LD_VAR 0 3
61565: PPUSH
61566: LD_VAR 0 8
61570: PPUSH
61571: CALL_OW 309
61575: IFFALSE 61642
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61577: LD_ADDR_EXP 126
61581: PUSH
61582: LD_EXP 126
61586: PPUSH
61587: LD_VAR 0 7
61591: PUSH
61592: LD_EXP 126
61596: PUSH
61597: LD_VAR 0 7
61601: ARRAY
61602: PUSH
61603: LD_INT 1
61605: PLUS
61606: PUSH
61607: EMPTY
61608: LIST
61609: LIST
61610: PPUSH
61611: LD_VAR 0 4
61615: PUSH
61616: LD_VAR 0 2
61620: PUSH
61621: LD_VAR 0 3
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: LIST
61630: PPUSH
61631: CALL 70022 0 3
61635: ST_TO_ADDR
// exit ;
61636: POP
61637: POP
61638: POP
61639: POP
61640: GO 61815
// end ;
61642: GO 61553
61644: POP
61645: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61646: LD_ADDR_VAR 0 9
61650: PUSH
61651: LD_EXP 110
61655: PUSH
61656: LD_VAR 0 7
61660: ARRAY
61661: PPUSH
61662: LD_INT 2
61664: PUSH
61665: LD_INT 30
61667: PUSH
61668: LD_INT 0
61670: PUSH
61671: EMPTY
61672: LIST
61673: LIST
61674: PUSH
61675: LD_INT 30
61677: PUSH
61678: LD_INT 1
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: EMPTY
61686: LIST
61687: LIST
61688: LIST
61689: PPUSH
61690: CALL_OW 72
61694: ST_TO_ADDR
// if not depot then
61695: LD_VAR 0 9
61699: NOT
61700: IFFALSE 61704
// continue ;
61702: GO 61522
// for j in depot do
61704: LD_ADDR_VAR 0 8
61708: PUSH
61709: LD_VAR 0 9
61713: PUSH
61714: FOR_IN
61715: IFFALSE 61809
// if GetDistUnitXY ( j , x , y ) < 30 then
61717: LD_VAR 0 8
61721: PPUSH
61722: LD_VAR 0 2
61726: PPUSH
61727: LD_VAR 0 3
61731: PPUSH
61732: CALL_OW 297
61736: PUSH
61737: LD_INT 30
61739: LESS
61740: IFFALSE 61807
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61742: LD_ADDR_EXP 126
61746: PUSH
61747: LD_EXP 126
61751: PPUSH
61752: LD_VAR 0 7
61756: PUSH
61757: LD_EXP 126
61761: PUSH
61762: LD_VAR 0 7
61766: ARRAY
61767: PUSH
61768: LD_INT 1
61770: PLUS
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PPUSH
61776: LD_VAR 0 4
61780: PUSH
61781: LD_VAR 0 2
61785: PUSH
61786: LD_VAR 0 3
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: LIST
61795: PPUSH
61796: CALL 70022 0 3
61800: ST_TO_ADDR
// exit ;
61801: POP
61802: POP
61803: POP
61804: POP
61805: GO 61815
// end ;
61807: GO 61714
61809: POP
61810: POP
// end ;
61811: GO 61522
61813: POP
61814: POP
// end ;
61815: LD_VAR 0 6
61819: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61820: LD_INT 0
61822: PPUSH
61823: PPUSH
61824: PPUSH
61825: PPUSH
// if not mc_bases or not skirmish then
61826: LD_EXP 110
61830: NOT
61831: PUSH
61832: LD_EXP 108
61836: NOT
61837: OR
61838: IFFALSE 61842
// exit ;
61840: GO 62119
// side := GetSide ( lab ) ;
61842: LD_ADDR_VAR 0 4
61846: PUSH
61847: LD_VAR 0 2
61851: PPUSH
61852: CALL_OW 255
61856: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61857: LD_VAR 0 4
61861: PUSH
61862: LD_EXP 136
61866: IN
61867: NOT
61868: PUSH
61869: LD_EXP 137
61873: NOT
61874: OR
61875: PUSH
61876: LD_EXP 110
61880: NOT
61881: OR
61882: IFFALSE 61886
// exit ;
61884: GO 62119
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61886: LD_ADDR_EXP 137
61890: PUSH
61891: LD_EXP 137
61895: PPUSH
61896: LD_VAR 0 4
61900: PPUSH
61901: LD_EXP 137
61905: PUSH
61906: LD_VAR 0 4
61910: ARRAY
61911: PUSH
61912: LD_VAR 0 1
61916: DIFF
61917: PPUSH
61918: CALL_OW 1
61922: ST_TO_ADDR
// for i = 1 to mc_bases do
61923: LD_ADDR_VAR 0 5
61927: PUSH
61928: DOUBLE
61929: LD_INT 1
61931: DEC
61932: ST_TO_ADDR
61933: LD_EXP 110
61937: PUSH
61938: FOR_TO
61939: IFFALSE 62117
// begin if lab in mc_bases [ i ] then
61941: LD_VAR 0 2
61945: PUSH
61946: LD_EXP 110
61950: PUSH
61951: LD_VAR 0 5
61955: ARRAY
61956: IN
61957: IFFALSE 62115
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61959: LD_VAR 0 1
61963: PUSH
61964: LD_INT 11
61966: PUSH
61967: LD_INT 4
61969: PUSH
61970: LD_INT 3
61972: PUSH
61973: LD_INT 2
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: IN
61982: PUSH
61983: LD_EXP 140
61987: PUSH
61988: LD_VAR 0 5
61992: ARRAY
61993: AND
61994: IFFALSE 62115
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61996: LD_ADDR_VAR 0 6
62000: PUSH
62001: LD_EXP 140
62005: PUSH
62006: LD_VAR 0 5
62010: ARRAY
62011: PUSH
62012: LD_INT 1
62014: ARRAY
62015: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62016: LD_ADDR_EXP 140
62020: PUSH
62021: LD_EXP 140
62025: PPUSH
62026: LD_VAR 0 5
62030: PPUSH
62031: EMPTY
62032: PPUSH
62033: CALL_OW 1
62037: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62038: LD_VAR 0 6
62042: PPUSH
62043: LD_INT 0
62045: PPUSH
62046: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62050: LD_VAR 0 6
62054: PPUSH
62055: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62059: LD_ADDR_EXP 139
62063: PUSH
62064: LD_EXP 139
62068: PPUSH
62069: LD_VAR 0 5
62073: PPUSH
62074: LD_EXP 139
62078: PUSH
62079: LD_VAR 0 5
62083: ARRAY
62084: PPUSH
62085: LD_INT 1
62087: PPUSH
62088: LD_VAR 0 6
62092: PPUSH
62093: CALL_OW 2
62097: PPUSH
62098: CALL_OW 1
62102: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62103: LD_VAR 0 5
62107: PPUSH
62108: LD_INT 112
62110: PPUSH
62111: CALL 39131 0 2
// end ; end ; end ;
62115: GO 61938
62117: POP
62118: POP
// end ;
62119: LD_VAR 0 3
62123: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62124: LD_INT 0
62126: PPUSH
62127: PPUSH
62128: PPUSH
62129: PPUSH
62130: PPUSH
62131: PPUSH
62132: PPUSH
62133: PPUSH
// if not mc_bases or not skirmish then
62134: LD_EXP 110
62138: NOT
62139: PUSH
62140: LD_EXP 108
62144: NOT
62145: OR
62146: IFFALSE 62150
// exit ;
62148: GO 63521
// for i = 1 to mc_bases do
62150: LD_ADDR_VAR 0 3
62154: PUSH
62155: DOUBLE
62156: LD_INT 1
62158: DEC
62159: ST_TO_ADDR
62160: LD_EXP 110
62164: PUSH
62165: FOR_TO
62166: IFFALSE 63519
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62168: LD_VAR 0 1
62172: PUSH
62173: LD_EXP 110
62177: PUSH
62178: LD_VAR 0 3
62182: ARRAY
62183: IN
62184: PUSH
62185: LD_VAR 0 1
62189: PUSH
62190: LD_EXP 117
62194: PUSH
62195: LD_VAR 0 3
62199: ARRAY
62200: IN
62201: OR
62202: PUSH
62203: LD_VAR 0 1
62207: PUSH
62208: LD_EXP 132
62212: PUSH
62213: LD_VAR 0 3
62217: ARRAY
62218: IN
62219: OR
62220: PUSH
62221: LD_VAR 0 1
62225: PUSH
62226: LD_EXP 129
62230: PUSH
62231: LD_VAR 0 3
62235: ARRAY
62236: IN
62237: OR
62238: PUSH
62239: LD_VAR 0 1
62243: PUSH
62244: LD_EXP 139
62248: PUSH
62249: LD_VAR 0 3
62253: ARRAY
62254: IN
62255: OR
62256: PUSH
62257: LD_VAR 0 1
62261: PUSH
62262: LD_EXP 140
62266: PUSH
62267: LD_VAR 0 3
62271: ARRAY
62272: IN
62273: OR
62274: IFFALSE 63517
// begin if un in mc_ape [ i ] then
62276: LD_VAR 0 1
62280: PUSH
62281: LD_EXP 139
62285: PUSH
62286: LD_VAR 0 3
62290: ARRAY
62291: IN
62292: IFFALSE 62331
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62294: LD_ADDR_EXP 139
62298: PUSH
62299: LD_EXP 139
62303: PPUSH
62304: LD_VAR 0 3
62308: PPUSH
62309: LD_EXP 139
62313: PUSH
62314: LD_VAR 0 3
62318: ARRAY
62319: PUSH
62320: LD_VAR 0 1
62324: DIFF
62325: PPUSH
62326: CALL_OW 1
62330: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62331: LD_VAR 0 1
62335: PUSH
62336: LD_EXP 140
62340: PUSH
62341: LD_VAR 0 3
62345: ARRAY
62346: IN
62347: IFFALSE 62371
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62349: LD_ADDR_EXP 140
62353: PUSH
62354: LD_EXP 140
62358: PPUSH
62359: LD_VAR 0 3
62363: PPUSH
62364: EMPTY
62365: PPUSH
62366: CALL_OW 1
62370: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62371: LD_VAR 0 1
62375: PPUSH
62376: CALL_OW 247
62380: PUSH
62381: LD_INT 2
62383: EQUAL
62384: PUSH
62385: LD_VAR 0 1
62389: PPUSH
62390: CALL_OW 110
62394: PUSH
62395: LD_INT 20
62397: EQUAL
62398: PUSH
62399: LD_VAR 0 1
62403: PUSH
62404: LD_EXP 132
62408: PUSH
62409: LD_VAR 0 3
62413: ARRAY
62414: IN
62415: OR
62416: PUSH
62417: LD_VAR 0 1
62421: PPUSH
62422: CALL_OW 264
62426: PUSH
62427: LD_INT 12
62429: PUSH
62430: LD_INT 51
62432: PUSH
62433: LD_EXP 96
62437: PUSH
62438: LD_INT 32
62440: PUSH
62441: LD_INT 13
62443: PUSH
62444: LD_INT 52
62446: PUSH
62447: LD_INT 31
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: IN
62459: OR
62460: AND
62461: IFFALSE 62769
// begin if un in mc_defender [ i ] then
62463: LD_VAR 0 1
62467: PUSH
62468: LD_EXP 132
62472: PUSH
62473: LD_VAR 0 3
62477: ARRAY
62478: IN
62479: IFFALSE 62518
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62481: LD_ADDR_EXP 132
62485: PUSH
62486: LD_EXP 132
62490: PPUSH
62491: LD_VAR 0 3
62495: PPUSH
62496: LD_EXP 132
62500: PUSH
62501: LD_VAR 0 3
62505: ARRAY
62506: PUSH
62507: LD_VAR 0 1
62511: DIFF
62512: PPUSH
62513: CALL_OW 1
62517: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62518: LD_ADDR_VAR 0 8
62522: PUSH
62523: LD_VAR 0 3
62527: PPUSH
62528: LD_INT 3
62530: PPUSH
62531: CALL 59187 0 2
62535: ST_TO_ADDR
// if fac then
62536: LD_VAR 0 8
62540: IFFALSE 62769
// begin for j in fac do
62542: LD_ADDR_VAR 0 4
62546: PUSH
62547: LD_VAR 0 8
62551: PUSH
62552: FOR_IN
62553: IFFALSE 62767
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62555: LD_ADDR_VAR 0 9
62559: PUSH
62560: LD_VAR 0 8
62564: PPUSH
62565: LD_VAR 0 1
62569: PPUSH
62570: CALL_OW 265
62574: PPUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: CALL_OW 262
62584: PPUSH
62585: LD_VAR 0 1
62589: PPUSH
62590: CALL_OW 263
62594: PPUSH
62595: LD_VAR 0 1
62599: PPUSH
62600: CALL_OW 264
62604: PPUSH
62605: CALL 67554 0 5
62609: ST_TO_ADDR
// if components then
62610: LD_VAR 0 9
62614: IFFALSE 62765
// begin if GetWeapon ( un ) = ar_control_tower then
62616: LD_VAR 0 1
62620: PPUSH
62621: CALL_OW 264
62625: PUSH
62626: LD_INT 31
62628: EQUAL
62629: IFFALSE 62746
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62631: LD_VAR 0 1
62635: PPUSH
62636: CALL_OW 311
62640: PPUSH
62641: LD_INT 0
62643: PPUSH
62644: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62648: LD_ADDR_EXP 150
62652: PUSH
62653: LD_EXP 150
62657: PPUSH
62658: LD_VAR 0 3
62662: PPUSH
62663: LD_EXP 150
62667: PUSH
62668: LD_VAR 0 3
62672: ARRAY
62673: PUSH
62674: LD_VAR 0 1
62678: PPUSH
62679: CALL_OW 311
62683: DIFF
62684: PPUSH
62685: CALL_OW 1
62689: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62690: LD_ADDR_VAR 0 7
62694: PUSH
62695: LD_EXP 131
62699: PUSH
62700: LD_VAR 0 3
62704: ARRAY
62705: PPUSH
62706: LD_INT 1
62708: PPUSH
62709: LD_VAR 0 9
62713: PPUSH
62714: CALL_OW 2
62718: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62719: LD_ADDR_EXP 131
62723: PUSH
62724: LD_EXP 131
62728: PPUSH
62729: LD_VAR 0 3
62733: PPUSH
62734: LD_VAR 0 7
62738: PPUSH
62739: CALL_OW 1
62743: ST_TO_ADDR
// end else
62744: GO 62763
// MC_InsertProduceList ( i , [ components ] ) ;
62746: LD_VAR 0 3
62750: PPUSH
62751: LD_VAR 0 9
62755: PUSH
62756: EMPTY
62757: LIST
62758: PPUSH
62759: CALL 58732 0 2
// break ;
62763: GO 62767
// end ; end ;
62765: GO 62552
62767: POP
62768: POP
// end ; end ; if GetType ( un ) = unit_building then
62769: LD_VAR 0 1
62773: PPUSH
62774: CALL_OW 247
62778: PUSH
62779: LD_INT 3
62781: EQUAL
62782: IFFALSE 63185
// begin btype := GetBType ( un ) ;
62784: LD_ADDR_VAR 0 5
62788: PUSH
62789: LD_VAR 0 1
62793: PPUSH
62794: CALL_OW 266
62798: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62799: LD_VAR 0 5
62803: PUSH
62804: LD_INT 29
62806: PUSH
62807: LD_INT 30
62809: PUSH
62810: EMPTY
62811: LIST
62812: LIST
62813: IN
62814: IFFALSE 62887
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62816: LD_VAR 0 1
62820: PPUSH
62821: CALL_OW 250
62825: PPUSH
62826: LD_VAR 0 1
62830: PPUSH
62831: CALL_OW 251
62835: PPUSH
62836: LD_VAR 0 1
62840: PPUSH
62841: CALL_OW 255
62845: PPUSH
62846: CALL_OW 440
62850: NOT
62851: IFFALSE 62887
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62853: LD_VAR 0 1
62857: PPUSH
62858: CALL_OW 250
62862: PPUSH
62863: LD_VAR 0 1
62867: PPUSH
62868: CALL_OW 251
62872: PPUSH
62873: LD_VAR 0 1
62877: PPUSH
62878: CALL_OW 255
62882: PPUSH
62883: CALL_OW 441
// end ; if btype = b_warehouse then
62887: LD_VAR 0 5
62891: PUSH
62892: LD_INT 1
62894: EQUAL
62895: IFFALSE 62913
// begin btype := b_depot ;
62897: LD_ADDR_VAR 0 5
62901: PUSH
62902: LD_INT 0
62904: ST_TO_ADDR
// pos := 1 ;
62905: LD_ADDR_VAR 0 6
62909: PUSH
62910: LD_INT 1
62912: ST_TO_ADDR
// end ; if btype = b_factory then
62913: LD_VAR 0 5
62917: PUSH
62918: LD_INT 3
62920: EQUAL
62921: IFFALSE 62939
// begin btype := b_workshop ;
62923: LD_ADDR_VAR 0 5
62927: PUSH
62928: LD_INT 2
62930: ST_TO_ADDR
// pos := 1 ;
62931: LD_ADDR_VAR 0 6
62935: PUSH
62936: LD_INT 1
62938: ST_TO_ADDR
// end ; if btype = b_barracks then
62939: LD_VAR 0 5
62943: PUSH
62944: LD_INT 5
62946: EQUAL
62947: IFFALSE 62957
// btype := b_armoury ;
62949: LD_ADDR_VAR 0 5
62953: PUSH
62954: LD_INT 4
62956: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62957: LD_VAR 0 5
62961: PUSH
62962: LD_INT 7
62964: PUSH
62965: LD_INT 8
62967: PUSH
62968: EMPTY
62969: LIST
62970: LIST
62971: IN
62972: IFFALSE 62982
// btype := b_lab ;
62974: LD_ADDR_VAR 0 5
62978: PUSH
62979: LD_INT 6
62981: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62982: LD_ADDR_EXP 115
62986: PUSH
62987: LD_EXP 115
62991: PPUSH
62992: LD_VAR 0 3
62996: PUSH
62997: LD_EXP 115
63001: PUSH
63002: LD_VAR 0 3
63006: ARRAY
63007: PUSH
63008: LD_INT 1
63010: PLUS
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PPUSH
63016: LD_VAR 0 5
63020: PUSH
63021: LD_VAR 0 1
63025: PPUSH
63026: CALL_OW 250
63030: PUSH
63031: LD_VAR 0 1
63035: PPUSH
63036: CALL_OW 251
63040: PUSH
63041: LD_VAR 0 1
63045: PPUSH
63046: CALL_OW 254
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: LIST
63055: LIST
63056: PPUSH
63057: CALL 70022 0 3
63061: ST_TO_ADDR
// if pos = 1 then
63062: LD_VAR 0 6
63066: PUSH
63067: LD_INT 1
63069: EQUAL
63070: IFFALSE 63185
// begin tmp := mc_build_list [ i ] ;
63072: LD_ADDR_VAR 0 7
63076: PUSH
63077: LD_EXP 115
63081: PUSH
63082: LD_VAR 0 3
63086: ARRAY
63087: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63088: LD_VAR 0 7
63092: PPUSH
63093: LD_INT 2
63095: PUSH
63096: LD_INT 30
63098: PUSH
63099: LD_INT 0
63101: PUSH
63102: EMPTY
63103: LIST
63104: LIST
63105: PUSH
63106: LD_INT 30
63108: PUSH
63109: LD_INT 1
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: LIST
63120: PPUSH
63121: CALL_OW 72
63125: IFFALSE 63135
// pos := 2 ;
63127: LD_ADDR_VAR 0 6
63131: PUSH
63132: LD_INT 2
63134: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63135: LD_ADDR_VAR 0 7
63139: PUSH
63140: LD_VAR 0 7
63144: PPUSH
63145: LD_VAR 0 6
63149: PPUSH
63150: LD_VAR 0 7
63154: PPUSH
63155: CALL 70348 0 3
63159: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63160: LD_ADDR_EXP 115
63164: PUSH
63165: LD_EXP 115
63169: PPUSH
63170: LD_VAR 0 3
63174: PPUSH
63175: LD_VAR 0 7
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63185: LD_VAR 0 1
63189: PUSH
63190: LD_EXP 110
63194: PUSH
63195: LD_VAR 0 3
63199: ARRAY
63200: IN
63201: IFFALSE 63240
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63203: LD_ADDR_EXP 110
63207: PUSH
63208: LD_EXP 110
63212: PPUSH
63213: LD_VAR 0 3
63217: PPUSH
63218: LD_EXP 110
63222: PUSH
63223: LD_VAR 0 3
63227: ARRAY
63228: PUSH
63229: LD_VAR 0 1
63233: DIFF
63234: PPUSH
63235: CALL_OW 1
63239: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63240: LD_VAR 0 1
63244: PUSH
63245: LD_EXP 117
63249: PUSH
63250: LD_VAR 0 3
63254: ARRAY
63255: IN
63256: IFFALSE 63295
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63258: LD_ADDR_EXP 117
63262: PUSH
63263: LD_EXP 117
63267: PPUSH
63268: LD_VAR 0 3
63272: PPUSH
63273: LD_EXP 117
63277: PUSH
63278: LD_VAR 0 3
63282: ARRAY
63283: PUSH
63284: LD_VAR 0 1
63288: DIFF
63289: PPUSH
63290: CALL_OW 1
63294: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63295: LD_VAR 0 1
63299: PUSH
63300: LD_EXP 129
63304: PUSH
63305: LD_VAR 0 3
63309: ARRAY
63310: IN
63311: IFFALSE 63350
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63313: LD_ADDR_EXP 129
63317: PUSH
63318: LD_EXP 129
63322: PPUSH
63323: LD_VAR 0 3
63327: PPUSH
63328: LD_EXP 129
63332: PUSH
63333: LD_VAR 0 3
63337: ARRAY
63338: PUSH
63339: LD_VAR 0 1
63343: DIFF
63344: PPUSH
63345: CALL_OW 1
63349: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63350: LD_VAR 0 1
63354: PUSH
63355: LD_EXP 132
63359: PUSH
63360: LD_VAR 0 3
63364: ARRAY
63365: IN
63366: IFFALSE 63405
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63368: LD_ADDR_EXP 132
63372: PUSH
63373: LD_EXP 132
63377: PPUSH
63378: LD_VAR 0 3
63382: PPUSH
63383: LD_EXP 132
63387: PUSH
63388: LD_VAR 0 3
63392: ARRAY
63393: PUSH
63394: LD_VAR 0 1
63398: DIFF
63399: PPUSH
63400: CALL_OW 1
63404: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63405: LD_VAR 0 1
63409: PUSH
63410: LD_EXP 119
63414: PUSH
63415: LD_VAR 0 3
63419: ARRAY
63420: IN
63421: IFFALSE 63460
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63423: LD_ADDR_EXP 119
63427: PUSH
63428: LD_EXP 119
63432: PPUSH
63433: LD_VAR 0 3
63437: PPUSH
63438: LD_EXP 119
63442: PUSH
63443: LD_VAR 0 3
63447: ARRAY
63448: PUSH
63449: LD_VAR 0 1
63453: DIFF
63454: PPUSH
63455: CALL_OW 1
63459: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63460: LD_VAR 0 1
63464: PUSH
63465: LD_EXP 118
63469: PUSH
63470: LD_VAR 0 3
63474: ARRAY
63475: IN
63476: IFFALSE 63515
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63478: LD_ADDR_EXP 118
63482: PUSH
63483: LD_EXP 118
63487: PPUSH
63488: LD_VAR 0 3
63492: PPUSH
63493: LD_EXP 118
63497: PUSH
63498: LD_VAR 0 3
63502: ARRAY
63503: PUSH
63504: LD_VAR 0 1
63508: DIFF
63509: PPUSH
63510: CALL_OW 1
63514: ST_TO_ADDR
// end ; break ;
63515: GO 63519
// end ;
63517: GO 62165
63519: POP
63520: POP
// end ;
63521: LD_VAR 0 2
63525: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63526: LD_INT 0
63528: PPUSH
63529: PPUSH
63530: PPUSH
// if not mc_bases or not skirmish then
63531: LD_EXP 110
63535: NOT
63536: PUSH
63537: LD_EXP 108
63541: NOT
63542: OR
63543: IFFALSE 63547
// exit ;
63545: GO 63762
// for i = 1 to mc_bases do
63547: LD_ADDR_VAR 0 3
63551: PUSH
63552: DOUBLE
63553: LD_INT 1
63555: DEC
63556: ST_TO_ADDR
63557: LD_EXP 110
63561: PUSH
63562: FOR_TO
63563: IFFALSE 63760
// begin if building in mc_construct_list [ i ] then
63565: LD_VAR 0 1
63569: PUSH
63570: LD_EXP 117
63574: PUSH
63575: LD_VAR 0 3
63579: ARRAY
63580: IN
63581: IFFALSE 63758
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63583: LD_ADDR_EXP 117
63587: PUSH
63588: LD_EXP 117
63592: PPUSH
63593: LD_VAR 0 3
63597: PPUSH
63598: LD_EXP 117
63602: PUSH
63603: LD_VAR 0 3
63607: ARRAY
63608: PUSH
63609: LD_VAR 0 1
63613: DIFF
63614: PPUSH
63615: CALL_OW 1
63619: ST_TO_ADDR
// if building in mc_lab [ i ] then
63620: LD_VAR 0 1
63624: PUSH
63625: LD_EXP 143
63629: PUSH
63630: LD_VAR 0 3
63634: ARRAY
63635: IN
63636: IFFALSE 63691
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63638: LD_ADDR_EXP 144
63642: PUSH
63643: LD_EXP 144
63647: PPUSH
63648: LD_VAR 0 3
63652: PPUSH
63653: LD_EXP 144
63657: PUSH
63658: LD_VAR 0 3
63662: ARRAY
63663: PPUSH
63664: LD_INT 1
63666: PPUSH
63667: LD_EXP 144
63671: PUSH
63672: LD_VAR 0 3
63676: ARRAY
63677: PPUSH
63678: LD_INT 0
63680: PPUSH
63681: CALL 69440 0 4
63685: PPUSH
63686: CALL_OW 1
63690: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63691: LD_VAR 0 1
63695: PUSH
63696: LD_EXP 110
63700: PUSH
63701: LD_VAR 0 3
63705: ARRAY
63706: IN
63707: NOT
63708: IFFALSE 63754
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63710: LD_ADDR_EXP 110
63714: PUSH
63715: LD_EXP 110
63719: PPUSH
63720: LD_VAR 0 3
63724: PUSH
63725: LD_EXP 110
63729: PUSH
63730: LD_VAR 0 3
63734: ARRAY
63735: PUSH
63736: LD_INT 1
63738: PLUS
63739: PUSH
63740: EMPTY
63741: LIST
63742: LIST
63743: PPUSH
63744: LD_VAR 0 1
63748: PPUSH
63749: CALL 70022 0 3
63753: ST_TO_ADDR
// exit ;
63754: POP
63755: POP
63756: GO 63762
// end ; end ;
63758: GO 63562
63760: POP
63761: POP
// end ;
63762: LD_VAR 0 2
63766: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63767: LD_INT 0
63769: PPUSH
63770: PPUSH
63771: PPUSH
63772: PPUSH
63773: PPUSH
63774: PPUSH
63775: PPUSH
// if not mc_bases or not skirmish then
63776: LD_EXP 110
63780: NOT
63781: PUSH
63782: LD_EXP 108
63786: NOT
63787: OR
63788: IFFALSE 63792
// exit ;
63790: GO 64453
// for i = 1 to mc_bases do
63792: LD_ADDR_VAR 0 3
63796: PUSH
63797: DOUBLE
63798: LD_INT 1
63800: DEC
63801: ST_TO_ADDR
63802: LD_EXP 110
63806: PUSH
63807: FOR_TO
63808: IFFALSE 64451
// begin if building in mc_construct_list [ i ] then
63810: LD_VAR 0 1
63814: PUSH
63815: LD_EXP 117
63819: PUSH
63820: LD_VAR 0 3
63824: ARRAY
63825: IN
63826: IFFALSE 64449
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63828: LD_ADDR_EXP 117
63832: PUSH
63833: LD_EXP 117
63837: PPUSH
63838: LD_VAR 0 3
63842: PPUSH
63843: LD_EXP 117
63847: PUSH
63848: LD_VAR 0 3
63852: ARRAY
63853: PUSH
63854: LD_VAR 0 1
63858: DIFF
63859: PPUSH
63860: CALL_OW 1
63864: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63865: LD_ADDR_EXP 110
63869: PUSH
63870: LD_EXP 110
63874: PPUSH
63875: LD_VAR 0 3
63879: PUSH
63880: LD_EXP 110
63884: PUSH
63885: LD_VAR 0 3
63889: ARRAY
63890: PUSH
63891: LD_INT 1
63893: PLUS
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PPUSH
63899: LD_VAR 0 1
63903: PPUSH
63904: CALL 70022 0 3
63908: ST_TO_ADDR
// btype := GetBType ( building ) ;
63909: LD_ADDR_VAR 0 5
63913: PUSH
63914: LD_VAR 0 1
63918: PPUSH
63919: CALL_OW 266
63923: ST_TO_ADDR
// side := GetSide ( building ) ;
63924: LD_ADDR_VAR 0 8
63928: PUSH
63929: LD_VAR 0 1
63933: PPUSH
63934: CALL_OW 255
63938: ST_TO_ADDR
// if btype = b_lab then
63939: LD_VAR 0 5
63943: PUSH
63944: LD_INT 6
63946: EQUAL
63947: IFFALSE 63997
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63949: LD_ADDR_EXP 143
63953: PUSH
63954: LD_EXP 143
63958: PPUSH
63959: LD_VAR 0 3
63963: PUSH
63964: LD_EXP 143
63968: PUSH
63969: LD_VAR 0 3
63973: ARRAY
63974: PUSH
63975: LD_INT 1
63977: PLUS
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PPUSH
63983: LD_VAR 0 1
63987: PPUSH
63988: CALL 70022 0 3
63992: ST_TO_ADDR
// exit ;
63993: POP
63994: POP
63995: GO 64453
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63997: LD_VAR 0 5
64001: PUSH
64002: LD_INT 0
64004: PUSH
64005: LD_INT 2
64007: PUSH
64008: LD_INT 4
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: LIST
64015: IN
64016: IFFALSE 64140
// begin if btype = b_armoury then
64018: LD_VAR 0 5
64022: PUSH
64023: LD_INT 4
64025: EQUAL
64026: IFFALSE 64036
// btype := b_barracks ;
64028: LD_ADDR_VAR 0 5
64032: PUSH
64033: LD_INT 5
64035: ST_TO_ADDR
// if btype = b_depot then
64036: LD_VAR 0 5
64040: PUSH
64041: LD_INT 0
64043: EQUAL
64044: IFFALSE 64054
// btype := b_warehouse ;
64046: LD_ADDR_VAR 0 5
64050: PUSH
64051: LD_INT 1
64053: ST_TO_ADDR
// if btype = b_workshop then
64054: LD_VAR 0 5
64058: PUSH
64059: LD_INT 2
64061: EQUAL
64062: IFFALSE 64072
// btype := b_factory ;
64064: LD_ADDR_VAR 0 5
64068: PUSH
64069: LD_INT 3
64071: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64072: LD_VAR 0 5
64076: PPUSH
64077: LD_VAR 0 8
64081: PPUSH
64082: CALL_OW 323
64086: PUSH
64087: LD_INT 1
64089: EQUAL
64090: IFFALSE 64136
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64092: LD_ADDR_EXP 142
64096: PUSH
64097: LD_EXP 142
64101: PPUSH
64102: LD_VAR 0 3
64106: PUSH
64107: LD_EXP 142
64111: PUSH
64112: LD_VAR 0 3
64116: ARRAY
64117: PUSH
64118: LD_INT 1
64120: PLUS
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: PPUSH
64126: LD_VAR 0 1
64130: PPUSH
64131: CALL 70022 0 3
64135: ST_TO_ADDR
// exit ;
64136: POP
64137: POP
64138: GO 64453
// end ; if btype in [ b_bunker , b_turret ] then
64140: LD_VAR 0 5
64144: PUSH
64145: LD_INT 32
64147: PUSH
64148: LD_INT 33
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: IN
64155: IFFALSE 64445
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64157: LD_ADDR_EXP 118
64161: PUSH
64162: LD_EXP 118
64166: PPUSH
64167: LD_VAR 0 3
64171: PUSH
64172: LD_EXP 118
64176: PUSH
64177: LD_VAR 0 3
64181: ARRAY
64182: PUSH
64183: LD_INT 1
64185: PLUS
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PPUSH
64191: LD_VAR 0 1
64195: PPUSH
64196: CALL 70022 0 3
64200: ST_TO_ADDR
// if btype = b_bunker then
64201: LD_VAR 0 5
64205: PUSH
64206: LD_INT 32
64208: EQUAL
64209: IFFALSE 64445
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64211: LD_ADDR_EXP 119
64215: PUSH
64216: LD_EXP 119
64220: PPUSH
64221: LD_VAR 0 3
64225: PUSH
64226: LD_EXP 119
64230: PUSH
64231: LD_VAR 0 3
64235: ARRAY
64236: PUSH
64237: LD_INT 1
64239: PLUS
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PPUSH
64245: LD_VAR 0 1
64249: PPUSH
64250: CALL 70022 0 3
64254: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64255: LD_ADDR_VAR 0 6
64259: PUSH
64260: LD_EXP 110
64264: PUSH
64265: LD_VAR 0 3
64269: ARRAY
64270: PPUSH
64271: LD_INT 25
64273: PUSH
64274: LD_INT 1
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PUSH
64281: LD_INT 3
64283: PUSH
64284: LD_INT 54
64286: PUSH
64287: EMPTY
64288: LIST
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PPUSH
64298: CALL_OW 72
64302: ST_TO_ADDR
// if tmp then
64303: LD_VAR 0 6
64307: IFFALSE 64313
// exit ;
64309: POP
64310: POP
64311: GO 64453
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64313: LD_ADDR_VAR 0 6
64317: PUSH
64318: LD_EXP 110
64322: PUSH
64323: LD_VAR 0 3
64327: ARRAY
64328: PPUSH
64329: LD_INT 2
64331: PUSH
64332: LD_INT 30
64334: PUSH
64335: LD_INT 4
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: LD_INT 30
64344: PUSH
64345: LD_INT 5
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: LIST
64356: PPUSH
64357: CALL_OW 72
64361: ST_TO_ADDR
// if not tmp then
64362: LD_VAR 0 6
64366: NOT
64367: IFFALSE 64373
// exit ;
64369: POP
64370: POP
64371: GO 64453
// for j in tmp do
64373: LD_ADDR_VAR 0 4
64377: PUSH
64378: LD_VAR 0 6
64382: PUSH
64383: FOR_IN
64384: IFFALSE 64443
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64386: LD_ADDR_VAR 0 7
64390: PUSH
64391: LD_VAR 0 4
64395: PPUSH
64396: CALL_OW 313
64400: PPUSH
64401: LD_INT 25
64403: PUSH
64404: LD_INT 1
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PPUSH
64411: CALL_OW 72
64415: ST_TO_ADDR
// if units then
64416: LD_VAR 0 7
64420: IFFALSE 64441
// begin ComExitBuilding ( units [ 1 ] ) ;
64422: LD_VAR 0 7
64426: PUSH
64427: LD_INT 1
64429: ARRAY
64430: PPUSH
64431: CALL_OW 122
// exit ;
64435: POP
64436: POP
64437: POP
64438: POP
64439: GO 64453
// end ; end ;
64441: GO 64383
64443: POP
64444: POP
// end ; end ; exit ;
64445: POP
64446: POP
64447: GO 64453
// end ; end ;
64449: GO 63807
64451: POP
64452: POP
// end ;
64453: LD_VAR 0 2
64457: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64458: LD_INT 0
64460: PPUSH
64461: PPUSH
64462: PPUSH
64463: PPUSH
64464: PPUSH
64465: PPUSH
64466: PPUSH
// if not mc_bases or not skirmish then
64467: LD_EXP 110
64471: NOT
64472: PUSH
64473: LD_EXP 108
64477: NOT
64478: OR
64479: IFFALSE 64483
// exit ;
64481: GO 64714
// btype := GetBType ( building ) ;
64483: LD_ADDR_VAR 0 6
64487: PUSH
64488: LD_VAR 0 1
64492: PPUSH
64493: CALL_OW 266
64497: ST_TO_ADDR
// x := GetX ( building ) ;
64498: LD_ADDR_VAR 0 7
64502: PUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: CALL_OW 250
64512: ST_TO_ADDR
// y := GetY ( building ) ;
64513: LD_ADDR_VAR 0 8
64517: PUSH
64518: LD_VAR 0 1
64522: PPUSH
64523: CALL_OW 251
64527: ST_TO_ADDR
// d := GetDir ( building ) ;
64528: LD_ADDR_VAR 0 9
64532: PUSH
64533: LD_VAR 0 1
64537: PPUSH
64538: CALL_OW 254
64542: ST_TO_ADDR
// for i = 1 to mc_bases do
64543: LD_ADDR_VAR 0 4
64547: PUSH
64548: DOUBLE
64549: LD_INT 1
64551: DEC
64552: ST_TO_ADDR
64553: LD_EXP 110
64557: PUSH
64558: FOR_TO
64559: IFFALSE 64712
// begin if not mc_build_list [ i ] then
64561: LD_EXP 115
64565: PUSH
64566: LD_VAR 0 4
64570: ARRAY
64571: NOT
64572: IFFALSE 64576
// continue ;
64574: GO 64558
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64576: LD_VAR 0 6
64580: PUSH
64581: LD_VAR 0 7
64585: PUSH
64586: LD_VAR 0 8
64590: PUSH
64591: LD_VAR 0 9
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: PPUSH
64602: LD_EXP 115
64606: PUSH
64607: LD_VAR 0 4
64611: ARRAY
64612: PUSH
64613: LD_INT 1
64615: ARRAY
64616: PPUSH
64617: CALL 76191 0 2
64621: IFFALSE 64710
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64623: LD_ADDR_EXP 115
64627: PUSH
64628: LD_EXP 115
64632: PPUSH
64633: LD_VAR 0 4
64637: PPUSH
64638: LD_EXP 115
64642: PUSH
64643: LD_VAR 0 4
64647: ARRAY
64648: PPUSH
64649: LD_INT 1
64651: PPUSH
64652: CALL_OW 3
64656: PPUSH
64657: CALL_OW 1
64661: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64662: LD_ADDR_EXP 117
64666: PUSH
64667: LD_EXP 117
64671: PPUSH
64672: LD_VAR 0 4
64676: PUSH
64677: LD_EXP 117
64681: PUSH
64682: LD_VAR 0 4
64686: ARRAY
64687: PUSH
64688: LD_INT 1
64690: PLUS
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PPUSH
64696: LD_VAR 0 1
64700: PPUSH
64701: CALL 70022 0 3
64705: ST_TO_ADDR
// exit ;
64706: POP
64707: POP
64708: GO 64714
// end ; end ;
64710: GO 64558
64712: POP
64713: POP
// end ;
64714: LD_VAR 0 3
64718: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64719: LD_INT 0
64721: PPUSH
64722: PPUSH
64723: PPUSH
// if not mc_bases or not skirmish then
64724: LD_EXP 110
64728: NOT
64729: PUSH
64730: LD_EXP 108
64734: NOT
64735: OR
64736: IFFALSE 64740
// exit ;
64738: GO 64930
// for i = 1 to mc_bases do
64740: LD_ADDR_VAR 0 4
64744: PUSH
64745: DOUBLE
64746: LD_INT 1
64748: DEC
64749: ST_TO_ADDR
64750: LD_EXP 110
64754: PUSH
64755: FOR_TO
64756: IFFALSE 64843
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64758: LD_VAR 0 1
64762: PUSH
64763: LD_EXP 118
64767: PUSH
64768: LD_VAR 0 4
64772: ARRAY
64773: IN
64774: PUSH
64775: LD_VAR 0 1
64779: PUSH
64780: LD_EXP 119
64784: PUSH
64785: LD_VAR 0 4
64789: ARRAY
64790: IN
64791: NOT
64792: AND
64793: IFFALSE 64841
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64795: LD_ADDR_EXP 119
64799: PUSH
64800: LD_EXP 119
64804: PPUSH
64805: LD_VAR 0 4
64809: PUSH
64810: LD_EXP 119
64814: PUSH
64815: LD_VAR 0 4
64819: ARRAY
64820: PUSH
64821: LD_INT 1
64823: PLUS
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PPUSH
64829: LD_VAR 0 1
64833: PPUSH
64834: CALL 70022 0 3
64838: ST_TO_ADDR
// break ;
64839: GO 64843
// end ; end ;
64841: GO 64755
64843: POP
64844: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64845: LD_VAR 0 1
64849: PPUSH
64850: CALL_OW 257
64854: PUSH
64855: LD_EXP 136
64859: IN
64860: PUSH
64861: LD_VAR 0 1
64865: PPUSH
64866: CALL_OW 266
64870: PUSH
64871: LD_INT 5
64873: EQUAL
64874: AND
64875: PUSH
64876: LD_VAR 0 2
64880: PPUSH
64881: CALL_OW 110
64885: PUSH
64886: LD_INT 18
64888: NONEQUAL
64889: AND
64890: IFFALSE 64930
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64892: LD_VAR 0 2
64896: PPUSH
64897: CALL_OW 257
64901: PUSH
64902: LD_INT 5
64904: PUSH
64905: LD_INT 8
64907: PUSH
64908: LD_INT 9
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: LIST
64915: IN
64916: IFFALSE 64930
// SetClass ( unit , 1 ) ;
64918: LD_VAR 0 2
64922: PPUSH
64923: LD_INT 1
64925: PPUSH
64926: CALL_OW 336
// end ;
64930: LD_VAR 0 3
64934: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64935: LD_INT 0
64937: PPUSH
64938: PPUSH
// if not mc_bases or not skirmish then
64939: LD_EXP 110
64943: NOT
64944: PUSH
64945: LD_EXP 108
64949: NOT
64950: OR
64951: IFFALSE 64955
// exit ;
64953: GO 65071
// if GetLives ( abandoned_vehicle ) > 250 then
64955: LD_VAR 0 2
64959: PPUSH
64960: CALL_OW 256
64964: PUSH
64965: LD_INT 250
64967: GREATER
64968: IFFALSE 64972
// exit ;
64970: GO 65071
// for i = 1 to mc_bases do
64972: LD_ADDR_VAR 0 6
64976: PUSH
64977: DOUBLE
64978: LD_INT 1
64980: DEC
64981: ST_TO_ADDR
64982: LD_EXP 110
64986: PUSH
64987: FOR_TO
64988: IFFALSE 65069
// begin if driver in mc_bases [ i ] then
64990: LD_VAR 0 1
64994: PUSH
64995: LD_EXP 110
64999: PUSH
65000: LD_VAR 0 6
65004: ARRAY
65005: IN
65006: IFFALSE 65067
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65008: LD_VAR 0 1
65012: PPUSH
65013: LD_EXP 110
65017: PUSH
65018: LD_VAR 0 6
65022: ARRAY
65023: PPUSH
65024: LD_INT 2
65026: PUSH
65027: LD_INT 30
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 30
65039: PUSH
65040: LD_INT 1
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: LIST
65051: PPUSH
65052: CALL_OW 72
65056: PUSH
65057: LD_INT 1
65059: ARRAY
65060: PPUSH
65061: CALL_OW 112
// break ;
65065: GO 65069
// end ; end ;
65067: GO 64987
65069: POP
65070: POP
// end ; end_of_file
65071: LD_VAR 0 5
65075: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65076: LD_INT 0
65078: PPUSH
65079: PPUSH
// if exist_mode then
65080: LD_VAR 0 2
65084: IFFALSE 65109
// unit := CreateCharacter ( prefix & ident ) else
65086: LD_ADDR_VAR 0 5
65090: PUSH
65091: LD_VAR 0 3
65095: PUSH
65096: LD_VAR 0 1
65100: STR
65101: PPUSH
65102: CALL_OW 34
65106: ST_TO_ADDR
65107: GO 65124
// unit := NewCharacter ( ident ) ;
65109: LD_ADDR_VAR 0 5
65113: PUSH
65114: LD_VAR 0 1
65118: PPUSH
65119: CALL_OW 25
65123: ST_TO_ADDR
// result := unit ;
65124: LD_ADDR_VAR 0 4
65128: PUSH
65129: LD_VAR 0 5
65133: ST_TO_ADDR
// end ;
65134: LD_VAR 0 4
65138: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65139: LD_INT 0
65141: PPUSH
65142: PPUSH
// if not side or not nation then
65143: LD_VAR 0 1
65147: NOT
65148: PUSH
65149: LD_VAR 0 2
65153: NOT
65154: OR
65155: IFFALSE 65159
// exit ;
65157: GO 65923
// case nation of nation_american :
65159: LD_VAR 0 2
65163: PUSH
65164: LD_INT 1
65166: DOUBLE
65167: EQUAL
65168: IFTRUE 65172
65170: GO 65386
65172: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65173: LD_ADDR_VAR 0 4
65177: PUSH
65178: LD_INT 35
65180: PUSH
65181: LD_INT 45
65183: PUSH
65184: LD_INT 46
65186: PUSH
65187: LD_INT 47
65189: PUSH
65190: LD_INT 82
65192: PUSH
65193: LD_INT 83
65195: PUSH
65196: LD_INT 84
65198: PUSH
65199: LD_INT 85
65201: PUSH
65202: LD_INT 86
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: LD_INT 2
65210: PUSH
65211: LD_INT 6
65213: PUSH
65214: LD_INT 15
65216: PUSH
65217: LD_INT 16
65219: PUSH
65220: LD_INT 7
65222: PUSH
65223: LD_INT 12
65225: PUSH
65226: LD_INT 13
65228: PUSH
65229: LD_INT 10
65231: PUSH
65232: LD_INT 14
65234: PUSH
65235: LD_INT 20
65237: PUSH
65238: LD_INT 21
65240: PUSH
65241: LD_INT 22
65243: PUSH
65244: LD_INT 25
65246: PUSH
65247: LD_INT 32
65249: PUSH
65250: LD_INT 27
65252: PUSH
65253: LD_INT 36
65255: PUSH
65256: LD_INT 69
65258: PUSH
65259: LD_INT 39
65261: PUSH
65262: LD_INT 34
65264: PUSH
65265: LD_INT 40
65267: PUSH
65268: LD_INT 48
65270: PUSH
65271: LD_INT 49
65273: PUSH
65274: LD_INT 50
65276: PUSH
65277: LD_INT 51
65279: PUSH
65280: LD_INT 52
65282: PUSH
65283: LD_INT 53
65285: PUSH
65286: LD_INT 54
65288: PUSH
65289: LD_INT 55
65291: PUSH
65292: LD_INT 56
65294: PUSH
65295: LD_INT 57
65297: PUSH
65298: LD_INT 58
65300: PUSH
65301: LD_INT 59
65303: PUSH
65304: LD_INT 60
65306: PUSH
65307: LD_INT 61
65309: PUSH
65310: LD_INT 62
65312: PUSH
65313: LD_INT 80
65315: PUSH
65316: LD_INT 82
65318: PUSH
65319: LD_INT 83
65321: PUSH
65322: LD_INT 84
65324: PUSH
65325: LD_INT 85
65327: PUSH
65328: LD_INT 86
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: ST_TO_ADDR
65384: GO 65847
65386: LD_INT 2
65388: DOUBLE
65389: EQUAL
65390: IFTRUE 65394
65392: GO 65616
65394: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65395: LD_ADDR_VAR 0 4
65399: PUSH
65400: LD_INT 35
65402: PUSH
65403: LD_INT 45
65405: PUSH
65406: LD_INT 46
65408: PUSH
65409: LD_INT 47
65411: PUSH
65412: LD_INT 82
65414: PUSH
65415: LD_INT 83
65417: PUSH
65418: LD_INT 84
65420: PUSH
65421: LD_INT 85
65423: PUSH
65424: LD_INT 87
65426: PUSH
65427: LD_INT 70
65429: PUSH
65430: LD_INT 1
65432: PUSH
65433: LD_INT 11
65435: PUSH
65436: LD_INT 3
65438: PUSH
65439: LD_INT 4
65441: PUSH
65442: LD_INT 5
65444: PUSH
65445: LD_INT 6
65447: PUSH
65448: LD_INT 15
65450: PUSH
65451: LD_INT 18
65453: PUSH
65454: LD_INT 7
65456: PUSH
65457: LD_INT 17
65459: PUSH
65460: LD_INT 8
65462: PUSH
65463: LD_INT 20
65465: PUSH
65466: LD_INT 21
65468: PUSH
65469: LD_INT 22
65471: PUSH
65472: LD_INT 72
65474: PUSH
65475: LD_INT 26
65477: PUSH
65478: LD_INT 69
65480: PUSH
65481: LD_INT 39
65483: PUSH
65484: LD_INT 40
65486: PUSH
65487: LD_INT 41
65489: PUSH
65490: LD_INT 42
65492: PUSH
65493: LD_INT 43
65495: PUSH
65496: LD_INT 48
65498: PUSH
65499: LD_INT 49
65501: PUSH
65502: LD_INT 50
65504: PUSH
65505: LD_INT 51
65507: PUSH
65508: LD_INT 52
65510: PUSH
65511: LD_INT 53
65513: PUSH
65514: LD_INT 54
65516: PUSH
65517: LD_INT 55
65519: PUSH
65520: LD_INT 56
65522: PUSH
65523: LD_INT 60
65525: PUSH
65526: LD_INT 61
65528: PUSH
65529: LD_INT 62
65531: PUSH
65532: LD_INT 66
65534: PUSH
65535: LD_INT 67
65537: PUSH
65538: LD_INT 68
65540: PUSH
65541: LD_INT 81
65543: PUSH
65544: LD_INT 82
65546: PUSH
65547: LD_INT 83
65549: PUSH
65550: LD_INT 84
65552: PUSH
65553: LD_INT 85
65555: PUSH
65556: LD_INT 87
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: ST_TO_ADDR
65614: GO 65847
65616: LD_INT 3
65618: DOUBLE
65619: EQUAL
65620: IFTRUE 65624
65622: GO 65846
65624: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65625: LD_ADDR_VAR 0 4
65629: PUSH
65630: LD_INT 46
65632: PUSH
65633: LD_INT 47
65635: PUSH
65636: LD_INT 1
65638: PUSH
65639: LD_INT 2
65641: PUSH
65642: LD_INT 82
65644: PUSH
65645: LD_INT 83
65647: PUSH
65648: LD_INT 84
65650: PUSH
65651: LD_INT 85
65653: PUSH
65654: LD_INT 86
65656: PUSH
65657: LD_INT 11
65659: PUSH
65660: LD_INT 9
65662: PUSH
65663: LD_INT 20
65665: PUSH
65666: LD_INT 19
65668: PUSH
65669: LD_INT 21
65671: PUSH
65672: LD_INT 24
65674: PUSH
65675: LD_INT 22
65677: PUSH
65678: LD_INT 25
65680: PUSH
65681: LD_INT 28
65683: PUSH
65684: LD_INT 29
65686: PUSH
65687: LD_INT 30
65689: PUSH
65690: LD_INT 31
65692: PUSH
65693: LD_INT 37
65695: PUSH
65696: LD_INT 38
65698: PUSH
65699: LD_INT 32
65701: PUSH
65702: LD_INT 27
65704: PUSH
65705: LD_INT 33
65707: PUSH
65708: LD_INT 69
65710: PUSH
65711: LD_INT 39
65713: PUSH
65714: LD_INT 34
65716: PUSH
65717: LD_INT 40
65719: PUSH
65720: LD_INT 71
65722: PUSH
65723: LD_INT 23
65725: PUSH
65726: LD_INT 44
65728: PUSH
65729: LD_INT 48
65731: PUSH
65732: LD_INT 49
65734: PUSH
65735: LD_INT 50
65737: PUSH
65738: LD_INT 51
65740: PUSH
65741: LD_INT 52
65743: PUSH
65744: LD_INT 53
65746: PUSH
65747: LD_INT 54
65749: PUSH
65750: LD_INT 55
65752: PUSH
65753: LD_INT 56
65755: PUSH
65756: LD_INT 57
65758: PUSH
65759: LD_INT 58
65761: PUSH
65762: LD_INT 59
65764: PUSH
65765: LD_INT 63
65767: PUSH
65768: LD_INT 64
65770: PUSH
65771: LD_INT 65
65773: PUSH
65774: LD_INT 82
65776: PUSH
65777: LD_INT 83
65779: PUSH
65780: LD_INT 84
65782: PUSH
65783: LD_INT 85
65785: PUSH
65786: LD_INT 86
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: ST_TO_ADDR
65844: GO 65847
65846: POP
// if state > - 1 and state < 3 then
65847: LD_VAR 0 3
65851: PUSH
65852: LD_INT 1
65854: NEG
65855: GREATER
65856: PUSH
65857: LD_VAR 0 3
65861: PUSH
65862: LD_INT 3
65864: LESS
65865: AND
65866: IFFALSE 65923
// for i in result do
65868: LD_ADDR_VAR 0 5
65872: PUSH
65873: LD_VAR 0 4
65877: PUSH
65878: FOR_IN
65879: IFFALSE 65921
// if GetTech ( i , side ) <> state then
65881: LD_VAR 0 5
65885: PPUSH
65886: LD_VAR 0 1
65890: PPUSH
65891: CALL_OW 321
65895: PUSH
65896: LD_VAR 0 3
65900: NONEQUAL
65901: IFFALSE 65919
// result := result diff i ;
65903: LD_ADDR_VAR 0 4
65907: PUSH
65908: LD_VAR 0 4
65912: PUSH
65913: LD_VAR 0 5
65917: DIFF
65918: ST_TO_ADDR
65919: GO 65878
65921: POP
65922: POP
// end ;
65923: LD_VAR 0 4
65927: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65928: LD_INT 0
65930: PPUSH
65931: PPUSH
65932: PPUSH
// result := true ;
65933: LD_ADDR_VAR 0 3
65937: PUSH
65938: LD_INT 1
65940: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65941: LD_ADDR_VAR 0 5
65945: PUSH
65946: LD_VAR 0 2
65950: PPUSH
65951: CALL_OW 480
65955: ST_TO_ADDR
// if not tmp then
65956: LD_VAR 0 5
65960: NOT
65961: IFFALSE 65965
// exit ;
65963: GO 66014
// for i in tmp do
65965: LD_ADDR_VAR 0 4
65969: PUSH
65970: LD_VAR 0 5
65974: PUSH
65975: FOR_IN
65976: IFFALSE 66012
// if GetTech ( i , side ) <> state_researched then
65978: LD_VAR 0 4
65982: PPUSH
65983: LD_VAR 0 1
65987: PPUSH
65988: CALL_OW 321
65992: PUSH
65993: LD_INT 2
65995: NONEQUAL
65996: IFFALSE 66010
// begin result := false ;
65998: LD_ADDR_VAR 0 3
66002: PUSH
66003: LD_INT 0
66005: ST_TO_ADDR
// exit ;
66006: POP
66007: POP
66008: GO 66014
// end ;
66010: GO 65975
66012: POP
66013: POP
// end ;
66014: LD_VAR 0 3
66018: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66019: LD_INT 0
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
66027: PPUSH
66028: PPUSH
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66034: LD_VAR 0 1
66038: NOT
66039: PUSH
66040: LD_VAR 0 1
66044: PPUSH
66045: CALL_OW 257
66049: PUSH
66050: LD_INT 9
66052: NONEQUAL
66053: OR
66054: IFFALSE 66058
// exit ;
66056: GO 66631
// side := GetSide ( unit ) ;
66058: LD_ADDR_VAR 0 9
66062: PUSH
66063: LD_VAR 0 1
66067: PPUSH
66068: CALL_OW 255
66072: ST_TO_ADDR
// tech_space := tech_spacanom ;
66073: LD_ADDR_VAR 0 12
66077: PUSH
66078: LD_INT 29
66080: ST_TO_ADDR
// tech_time := tech_taurad ;
66081: LD_ADDR_VAR 0 13
66085: PUSH
66086: LD_INT 28
66088: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66089: LD_ADDR_VAR 0 11
66093: PUSH
66094: LD_VAR 0 1
66098: PPUSH
66099: CALL_OW 310
66103: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66104: LD_VAR 0 11
66108: PPUSH
66109: CALL_OW 247
66113: PUSH
66114: LD_INT 2
66116: EQUAL
66117: IFFALSE 66121
// exit ;
66119: GO 66631
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66121: LD_ADDR_VAR 0 8
66125: PUSH
66126: LD_INT 81
66128: PUSH
66129: LD_VAR 0 9
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 3
66140: PUSH
66141: LD_INT 21
66143: PUSH
66144: LD_INT 3
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PPUSH
66159: CALL_OW 69
66163: ST_TO_ADDR
// if not tmp then
66164: LD_VAR 0 8
66168: NOT
66169: IFFALSE 66173
// exit ;
66171: GO 66631
// if in_unit then
66173: LD_VAR 0 11
66177: IFFALSE 66201
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66179: LD_ADDR_VAR 0 10
66183: PUSH
66184: LD_VAR 0 8
66188: PPUSH
66189: LD_VAR 0 11
66193: PPUSH
66194: CALL_OW 74
66198: ST_TO_ADDR
66199: GO 66221
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66201: LD_ADDR_VAR 0 10
66205: PUSH
66206: LD_VAR 0 8
66210: PPUSH
66211: LD_VAR 0 1
66215: PPUSH
66216: CALL_OW 74
66220: ST_TO_ADDR
// if not enemy then
66221: LD_VAR 0 10
66225: NOT
66226: IFFALSE 66230
// exit ;
66228: GO 66631
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66230: LD_VAR 0 11
66234: PUSH
66235: LD_VAR 0 11
66239: PPUSH
66240: LD_VAR 0 10
66244: PPUSH
66245: CALL_OW 296
66249: PUSH
66250: LD_INT 13
66252: GREATER
66253: AND
66254: PUSH
66255: LD_VAR 0 1
66259: PPUSH
66260: LD_VAR 0 10
66264: PPUSH
66265: CALL_OW 296
66269: PUSH
66270: LD_INT 12
66272: GREATER
66273: OR
66274: IFFALSE 66278
// exit ;
66276: GO 66631
// missile := [ 1 ] ;
66278: LD_ADDR_VAR 0 14
66282: PUSH
66283: LD_INT 1
66285: PUSH
66286: EMPTY
66287: LIST
66288: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66289: LD_VAR 0 9
66293: PPUSH
66294: LD_VAR 0 12
66298: PPUSH
66299: CALL_OW 325
66303: IFFALSE 66332
// missile := Insert ( missile , missile + 1 , 2 ) ;
66305: LD_ADDR_VAR 0 14
66309: PUSH
66310: LD_VAR 0 14
66314: PPUSH
66315: LD_VAR 0 14
66319: PUSH
66320: LD_INT 1
66322: PLUS
66323: PPUSH
66324: LD_INT 2
66326: PPUSH
66327: CALL_OW 2
66331: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66332: LD_VAR 0 9
66336: PPUSH
66337: LD_VAR 0 13
66341: PPUSH
66342: CALL_OW 325
66346: PUSH
66347: LD_VAR 0 10
66351: PPUSH
66352: CALL_OW 255
66356: PPUSH
66357: LD_VAR 0 13
66361: PPUSH
66362: CALL_OW 325
66366: NOT
66367: AND
66368: IFFALSE 66397
// missile := Insert ( missile , missile + 1 , 3 ) ;
66370: LD_ADDR_VAR 0 14
66374: PUSH
66375: LD_VAR 0 14
66379: PPUSH
66380: LD_VAR 0 14
66384: PUSH
66385: LD_INT 1
66387: PLUS
66388: PPUSH
66389: LD_INT 3
66391: PPUSH
66392: CALL_OW 2
66396: ST_TO_ADDR
// if missile < 2 then
66397: LD_VAR 0 14
66401: PUSH
66402: LD_INT 2
66404: LESS
66405: IFFALSE 66409
// exit ;
66407: GO 66631
// x := GetX ( enemy ) ;
66409: LD_ADDR_VAR 0 4
66413: PUSH
66414: LD_VAR 0 10
66418: PPUSH
66419: CALL_OW 250
66423: ST_TO_ADDR
// y := GetY ( enemy ) ;
66424: LD_ADDR_VAR 0 5
66428: PUSH
66429: LD_VAR 0 10
66433: PPUSH
66434: CALL_OW 251
66438: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66439: LD_ADDR_VAR 0 6
66443: PUSH
66444: LD_VAR 0 4
66448: PUSH
66449: LD_INT 1
66451: NEG
66452: PPUSH
66453: LD_INT 1
66455: PPUSH
66456: CALL_OW 12
66460: PLUS
66461: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66462: LD_ADDR_VAR 0 7
66466: PUSH
66467: LD_VAR 0 5
66471: PUSH
66472: LD_INT 1
66474: NEG
66475: PPUSH
66476: LD_INT 1
66478: PPUSH
66479: CALL_OW 12
66483: PLUS
66484: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66485: LD_VAR 0 6
66489: PPUSH
66490: LD_VAR 0 7
66494: PPUSH
66495: CALL_OW 488
66499: NOT
66500: IFFALSE 66522
// begin _x := x ;
66502: LD_ADDR_VAR 0 6
66506: PUSH
66507: LD_VAR 0 4
66511: ST_TO_ADDR
// _y := y ;
66512: LD_ADDR_VAR 0 7
66516: PUSH
66517: LD_VAR 0 5
66521: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66522: LD_ADDR_VAR 0 3
66526: PUSH
66527: LD_INT 1
66529: PPUSH
66530: LD_VAR 0 14
66534: PPUSH
66535: CALL_OW 12
66539: ST_TO_ADDR
// case i of 1 :
66540: LD_VAR 0 3
66544: PUSH
66545: LD_INT 1
66547: DOUBLE
66548: EQUAL
66549: IFTRUE 66553
66551: GO 66570
66553: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66554: LD_VAR 0 1
66558: PPUSH
66559: LD_VAR 0 10
66563: PPUSH
66564: CALL_OW 115
66568: GO 66631
66570: LD_INT 2
66572: DOUBLE
66573: EQUAL
66574: IFTRUE 66578
66576: GO 66600
66578: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66579: LD_VAR 0 1
66583: PPUSH
66584: LD_VAR 0 6
66588: PPUSH
66589: LD_VAR 0 7
66593: PPUSH
66594: CALL_OW 153
66598: GO 66631
66600: LD_INT 3
66602: DOUBLE
66603: EQUAL
66604: IFTRUE 66608
66606: GO 66630
66608: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66609: LD_VAR 0 1
66613: PPUSH
66614: LD_VAR 0 6
66618: PPUSH
66619: LD_VAR 0 7
66623: PPUSH
66624: CALL_OW 154
66628: GO 66631
66630: POP
// end ;
66631: LD_VAR 0 2
66635: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66636: LD_INT 0
66638: PPUSH
66639: PPUSH
66640: PPUSH
66641: PPUSH
66642: PPUSH
66643: PPUSH
// if not unit or not building then
66644: LD_VAR 0 1
66648: NOT
66649: PUSH
66650: LD_VAR 0 2
66654: NOT
66655: OR
66656: IFFALSE 66660
// exit ;
66658: GO 66818
// x := GetX ( building ) ;
66660: LD_ADDR_VAR 0 5
66664: PUSH
66665: LD_VAR 0 2
66669: PPUSH
66670: CALL_OW 250
66674: ST_TO_ADDR
// y := GetY ( building ) ;
66675: LD_ADDR_VAR 0 6
66679: PUSH
66680: LD_VAR 0 2
66684: PPUSH
66685: CALL_OW 251
66689: ST_TO_ADDR
// for i = 0 to 5 do
66690: LD_ADDR_VAR 0 4
66694: PUSH
66695: DOUBLE
66696: LD_INT 0
66698: DEC
66699: ST_TO_ADDR
66700: LD_INT 5
66702: PUSH
66703: FOR_TO
66704: IFFALSE 66816
// begin _x := ShiftX ( x , i , 3 ) ;
66706: LD_ADDR_VAR 0 7
66710: PUSH
66711: LD_VAR 0 5
66715: PPUSH
66716: LD_VAR 0 4
66720: PPUSH
66721: LD_INT 3
66723: PPUSH
66724: CALL_OW 272
66728: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66729: LD_ADDR_VAR 0 8
66733: PUSH
66734: LD_VAR 0 6
66738: PPUSH
66739: LD_VAR 0 4
66743: PPUSH
66744: LD_INT 3
66746: PPUSH
66747: CALL_OW 273
66751: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66752: LD_VAR 0 7
66756: PPUSH
66757: LD_VAR 0 8
66761: PPUSH
66762: CALL_OW 488
66766: NOT
66767: IFFALSE 66771
// continue ;
66769: GO 66703
// if HexInfo ( _x , _y ) = 0 then
66771: LD_VAR 0 7
66775: PPUSH
66776: LD_VAR 0 8
66780: PPUSH
66781: CALL_OW 428
66785: PUSH
66786: LD_INT 0
66788: EQUAL
66789: IFFALSE 66814
// begin ComMoveXY ( unit , _x , _y ) ;
66791: LD_VAR 0 1
66795: PPUSH
66796: LD_VAR 0 7
66800: PPUSH
66801: LD_VAR 0 8
66805: PPUSH
66806: CALL_OW 111
// exit ;
66810: POP
66811: POP
66812: GO 66818
// end ; end ;
66814: GO 66703
66816: POP
66817: POP
// end ;
66818: LD_VAR 0 3
66822: RET
// export function ScanBase ( side , base_area ) ; begin
66823: LD_INT 0
66825: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66826: LD_ADDR_VAR 0 3
66830: PUSH
66831: LD_VAR 0 2
66835: PPUSH
66836: LD_INT 81
66838: PUSH
66839: LD_VAR 0 1
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PPUSH
66848: CALL_OW 70
66852: ST_TO_ADDR
// end ;
66853: LD_VAR 0 3
66857: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66858: LD_INT 0
66860: PPUSH
66861: PPUSH
66862: PPUSH
66863: PPUSH
// result := false ;
66864: LD_ADDR_VAR 0 2
66868: PUSH
66869: LD_INT 0
66871: ST_TO_ADDR
// side := GetSide ( unit ) ;
66872: LD_ADDR_VAR 0 3
66876: PUSH
66877: LD_VAR 0 1
66881: PPUSH
66882: CALL_OW 255
66886: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66887: LD_ADDR_VAR 0 4
66891: PUSH
66892: LD_VAR 0 1
66896: PPUSH
66897: CALL_OW 248
66901: ST_TO_ADDR
// case nat of 1 :
66902: LD_VAR 0 4
66906: PUSH
66907: LD_INT 1
66909: DOUBLE
66910: EQUAL
66911: IFTRUE 66915
66913: GO 66926
66915: POP
// tech := tech_lassight ; 2 :
66916: LD_ADDR_VAR 0 5
66920: PUSH
66921: LD_INT 12
66923: ST_TO_ADDR
66924: GO 66965
66926: LD_INT 2
66928: DOUBLE
66929: EQUAL
66930: IFTRUE 66934
66932: GO 66945
66934: POP
// tech := tech_mortar ; 3 :
66935: LD_ADDR_VAR 0 5
66939: PUSH
66940: LD_INT 41
66942: ST_TO_ADDR
66943: GO 66965
66945: LD_INT 3
66947: DOUBLE
66948: EQUAL
66949: IFTRUE 66953
66951: GO 66964
66953: POP
// tech := tech_bazooka ; end ;
66954: LD_ADDR_VAR 0 5
66958: PUSH
66959: LD_INT 44
66961: ST_TO_ADDR
66962: GO 66965
66964: POP
// if Researched ( side , tech ) then
66965: LD_VAR 0 3
66969: PPUSH
66970: LD_VAR 0 5
66974: PPUSH
66975: CALL_OW 325
66979: IFFALSE 67006
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66981: LD_ADDR_VAR 0 2
66985: PUSH
66986: LD_INT 5
66988: PUSH
66989: LD_INT 8
66991: PUSH
66992: LD_INT 9
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: LIST
66999: PUSH
67000: LD_VAR 0 4
67004: ARRAY
67005: ST_TO_ADDR
// end ;
67006: LD_VAR 0 2
67010: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67011: LD_INT 0
67013: PPUSH
67014: PPUSH
67015: PPUSH
// if not mines then
67016: LD_VAR 0 2
67020: NOT
67021: IFFALSE 67025
// exit ;
67023: GO 67169
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67025: LD_ADDR_VAR 0 5
67029: PUSH
67030: LD_INT 81
67032: PUSH
67033: LD_VAR 0 1
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 3
67044: PUSH
67045: LD_INT 21
67047: PUSH
67048: LD_INT 3
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: PPUSH
67063: CALL_OW 69
67067: ST_TO_ADDR
// for i in mines do
67068: LD_ADDR_VAR 0 4
67072: PUSH
67073: LD_VAR 0 2
67077: PUSH
67078: FOR_IN
67079: IFFALSE 67167
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67081: LD_VAR 0 4
67085: PUSH
67086: LD_INT 1
67088: ARRAY
67089: PPUSH
67090: LD_VAR 0 4
67094: PUSH
67095: LD_INT 2
67097: ARRAY
67098: PPUSH
67099: CALL_OW 458
67103: NOT
67104: IFFALSE 67108
// continue ;
67106: GO 67078
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67108: LD_VAR 0 4
67112: PUSH
67113: LD_INT 1
67115: ARRAY
67116: PPUSH
67117: LD_VAR 0 4
67121: PUSH
67122: LD_INT 2
67124: ARRAY
67125: PPUSH
67126: CALL_OW 428
67130: PUSH
67131: LD_VAR 0 5
67135: IN
67136: IFFALSE 67165
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67138: LD_VAR 0 4
67142: PUSH
67143: LD_INT 1
67145: ARRAY
67146: PPUSH
67147: LD_VAR 0 4
67151: PUSH
67152: LD_INT 2
67154: ARRAY
67155: PPUSH
67156: LD_VAR 0 1
67160: PPUSH
67161: CALL_OW 456
// end ;
67165: GO 67078
67167: POP
67168: POP
// end ;
67169: LD_VAR 0 3
67173: RET
// export function Count ( array ) ; var i ; begin
67174: LD_INT 0
67176: PPUSH
67177: PPUSH
// result := 0 ;
67178: LD_ADDR_VAR 0 2
67182: PUSH
67183: LD_INT 0
67185: ST_TO_ADDR
// for i in array do
67186: LD_ADDR_VAR 0 3
67190: PUSH
67191: LD_VAR 0 1
67195: PUSH
67196: FOR_IN
67197: IFFALSE 67221
// if i then
67199: LD_VAR 0 3
67203: IFFALSE 67219
// result := result + 1 ;
67205: LD_ADDR_VAR 0 2
67209: PUSH
67210: LD_VAR 0 2
67214: PUSH
67215: LD_INT 1
67217: PLUS
67218: ST_TO_ADDR
67219: GO 67196
67221: POP
67222: POP
// end ;
67223: LD_VAR 0 2
67227: RET
// export function IsEmpty ( building ) ; begin
67228: LD_INT 0
67230: PPUSH
// if not building then
67231: LD_VAR 0 1
67235: NOT
67236: IFFALSE 67240
// exit ;
67238: GO 67283
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67240: LD_ADDR_VAR 0 2
67244: PUSH
67245: LD_VAR 0 1
67249: PUSH
67250: LD_INT 22
67252: PUSH
67253: LD_VAR 0 1
67257: PPUSH
67258: CALL_OW 255
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 58
67269: PUSH
67270: EMPTY
67271: LIST
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PPUSH
67277: CALL_OW 69
67281: IN
67282: ST_TO_ADDR
// end ;
67283: LD_VAR 0 2
67287: RET
// export function IsNotFull ( building ) ; begin
67288: LD_INT 0
67290: PPUSH
// if not building then
67291: LD_VAR 0 1
67295: NOT
67296: IFFALSE 67300
// exit ;
67298: GO 67319
// result := UnitsInside ( building ) < 6 ;
67300: LD_ADDR_VAR 0 2
67304: PUSH
67305: LD_VAR 0 1
67309: PPUSH
67310: CALL_OW 313
67314: PUSH
67315: LD_INT 6
67317: LESS
67318: ST_TO_ADDR
// end ;
67319: LD_VAR 0 2
67323: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67324: LD_INT 0
67326: PPUSH
67327: PPUSH
67328: PPUSH
67329: PPUSH
// tmp := [ ] ;
67330: LD_ADDR_VAR 0 3
67334: PUSH
67335: EMPTY
67336: ST_TO_ADDR
// list := [ ] ;
67337: LD_ADDR_VAR 0 5
67341: PUSH
67342: EMPTY
67343: ST_TO_ADDR
// for i = 16 to 25 do
67344: LD_ADDR_VAR 0 4
67348: PUSH
67349: DOUBLE
67350: LD_INT 16
67352: DEC
67353: ST_TO_ADDR
67354: LD_INT 25
67356: PUSH
67357: FOR_TO
67358: IFFALSE 67431
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67360: LD_ADDR_VAR 0 3
67364: PUSH
67365: LD_VAR 0 3
67369: PUSH
67370: LD_INT 22
67372: PUSH
67373: LD_VAR 0 1
67377: PPUSH
67378: CALL_OW 255
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 91
67389: PUSH
67390: LD_VAR 0 1
67394: PUSH
67395: LD_INT 6
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 30
67405: PUSH
67406: LD_VAR 0 4
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: LIST
67419: PUSH
67420: EMPTY
67421: LIST
67422: PPUSH
67423: CALL_OW 69
67427: ADD
67428: ST_TO_ADDR
67429: GO 67357
67431: POP
67432: POP
// for i = 1 to tmp do
67433: LD_ADDR_VAR 0 4
67437: PUSH
67438: DOUBLE
67439: LD_INT 1
67441: DEC
67442: ST_TO_ADDR
67443: LD_VAR 0 3
67447: PUSH
67448: FOR_TO
67449: IFFALSE 67537
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67451: LD_ADDR_VAR 0 5
67455: PUSH
67456: LD_VAR 0 5
67460: PUSH
67461: LD_VAR 0 3
67465: PUSH
67466: LD_VAR 0 4
67470: ARRAY
67471: PPUSH
67472: CALL_OW 266
67476: PUSH
67477: LD_VAR 0 3
67481: PUSH
67482: LD_VAR 0 4
67486: ARRAY
67487: PPUSH
67488: CALL_OW 250
67492: PUSH
67493: LD_VAR 0 3
67497: PUSH
67498: LD_VAR 0 4
67502: ARRAY
67503: PPUSH
67504: CALL_OW 251
67508: PUSH
67509: LD_VAR 0 3
67513: PUSH
67514: LD_VAR 0 4
67518: ARRAY
67519: PPUSH
67520: CALL_OW 254
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: PUSH
67531: EMPTY
67532: LIST
67533: ADD
67534: ST_TO_ADDR
67535: GO 67448
67537: POP
67538: POP
// result := list ;
67539: LD_ADDR_VAR 0 2
67543: PUSH
67544: LD_VAR 0 5
67548: ST_TO_ADDR
// end ;
67549: LD_VAR 0 2
67553: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67554: LD_INT 0
67556: PPUSH
67557: PPUSH
67558: PPUSH
67559: PPUSH
67560: PPUSH
67561: PPUSH
67562: PPUSH
// if not factory then
67563: LD_VAR 0 1
67567: NOT
67568: IFFALSE 67572
// exit ;
67570: GO 68165
// if control = control_apeman then
67572: LD_VAR 0 4
67576: PUSH
67577: LD_INT 5
67579: EQUAL
67580: IFFALSE 67689
// begin tmp := UnitsInside ( factory ) ;
67582: LD_ADDR_VAR 0 8
67586: PUSH
67587: LD_VAR 0 1
67591: PPUSH
67592: CALL_OW 313
67596: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67597: LD_VAR 0 8
67601: PPUSH
67602: LD_INT 25
67604: PUSH
67605: LD_INT 12
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PPUSH
67612: CALL_OW 72
67616: NOT
67617: IFFALSE 67627
// control := control_manual ;
67619: LD_ADDR_VAR 0 4
67623: PUSH
67624: LD_INT 1
67626: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67627: LD_ADDR_VAR 0 8
67631: PUSH
67632: LD_VAR 0 1
67636: PPUSH
67637: CALL 67324 0 1
67641: ST_TO_ADDR
// if tmp then
67642: LD_VAR 0 8
67646: IFFALSE 67689
// begin for i in tmp do
67648: LD_ADDR_VAR 0 7
67652: PUSH
67653: LD_VAR 0 8
67657: PUSH
67658: FOR_IN
67659: IFFALSE 67687
// if i [ 1 ] = b_ext_radio then
67661: LD_VAR 0 7
67665: PUSH
67666: LD_INT 1
67668: ARRAY
67669: PUSH
67670: LD_INT 22
67672: EQUAL
67673: IFFALSE 67685
// begin control := control_remote ;
67675: LD_ADDR_VAR 0 4
67679: PUSH
67680: LD_INT 2
67682: ST_TO_ADDR
// break ;
67683: GO 67687
// end ;
67685: GO 67658
67687: POP
67688: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67689: LD_VAR 0 1
67693: PPUSH
67694: LD_VAR 0 2
67698: PPUSH
67699: LD_VAR 0 3
67703: PPUSH
67704: LD_VAR 0 4
67708: PPUSH
67709: LD_VAR 0 5
67713: PPUSH
67714: CALL_OW 448
67718: IFFALSE 67753
// begin result := [ chassis , engine , control , weapon ] ;
67720: LD_ADDR_VAR 0 6
67724: PUSH
67725: LD_VAR 0 2
67729: PUSH
67730: LD_VAR 0 3
67734: PUSH
67735: LD_VAR 0 4
67739: PUSH
67740: LD_VAR 0 5
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: ST_TO_ADDR
// exit ;
67751: GO 68165
// end ; _chassis := AvailableChassisList ( factory ) ;
67753: LD_ADDR_VAR 0 9
67757: PUSH
67758: LD_VAR 0 1
67762: PPUSH
67763: CALL_OW 475
67767: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67768: LD_ADDR_VAR 0 11
67772: PUSH
67773: LD_VAR 0 1
67777: PPUSH
67778: CALL_OW 476
67782: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67783: LD_ADDR_VAR 0 12
67787: PUSH
67788: LD_VAR 0 1
67792: PPUSH
67793: CALL_OW 477
67797: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67798: LD_ADDR_VAR 0 10
67802: PUSH
67803: LD_VAR 0 1
67807: PPUSH
67808: CALL_OW 478
67812: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67813: LD_VAR 0 9
67817: NOT
67818: PUSH
67819: LD_VAR 0 11
67823: NOT
67824: OR
67825: PUSH
67826: LD_VAR 0 12
67830: NOT
67831: OR
67832: PUSH
67833: LD_VAR 0 10
67837: NOT
67838: OR
67839: IFFALSE 67874
// begin result := [ chassis , engine , control , weapon ] ;
67841: LD_ADDR_VAR 0 6
67845: PUSH
67846: LD_VAR 0 2
67850: PUSH
67851: LD_VAR 0 3
67855: PUSH
67856: LD_VAR 0 4
67860: PUSH
67861: LD_VAR 0 5
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: ST_TO_ADDR
// exit ;
67872: GO 68165
// end ; if not chassis in _chassis then
67874: LD_VAR 0 2
67878: PUSH
67879: LD_VAR 0 9
67883: IN
67884: NOT
67885: IFFALSE 67911
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67887: LD_ADDR_VAR 0 2
67891: PUSH
67892: LD_VAR 0 9
67896: PUSH
67897: LD_INT 1
67899: PPUSH
67900: LD_VAR 0 9
67904: PPUSH
67905: CALL_OW 12
67909: ARRAY
67910: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67911: LD_VAR 0 2
67915: PPUSH
67916: LD_VAR 0 3
67920: PPUSH
67921: CALL 68170 0 2
67925: NOT
67926: IFFALSE 67985
// repeat engine := _engine [ 1 ] ;
67928: LD_ADDR_VAR 0 3
67932: PUSH
67933: LD_VAR 0 11
67937: PUSH
67938: LD_INT 1
67940: ARRAY
67941: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67942: LD_ADDR_VAR 0 11
67946: PUSH
67947: LD_VAR 0 11
67951: PPUSH
67952: LD_INT 1
67954: PPUSH
67955: CALL_OW 3
67959: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67960: LD_VAR 0 2
67964: PPUSH
67965: LD_VAR 0 3
67969: PPUSH
67970: CALL 68170 0 2
67974: PUSH
67975: LD_VAR 0 11
67979: PUSH
67980: EMPTY
67981: EQUAL
67982: OR
67983: IFFALSE 67928
// if not control in _control then
67985: LD_VAR 0 4
67989: PUSH
67990: LD_VAR 0 12
67994: IN
67995: NOT
67996: IFFALSE 68022
// control := _control [ rand ( 1 , _control ) ] ;
67998: LD_ADDR_VAR 0 4
68002: PUSH
68003: LD_VAR 0 12
68007: PUSH
68008: LD_INT 1
68010: PPUSH
68011: LD_VAR 0 12
68015: PPUSH
68016: CALL_OW 12
68020: ARRAY
68021: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68022: LD_VAR 0 2
68026: PPUSH
68027: LD_VAR 0 5
68031: PPUSH
68032: CALL 68390 0 2
68036: NOT
68037: IFFALSE 68096
// repeat weapon := _weapon [ 1 ] ;
68039: LD_ADDR_VAR 0 5
68043: PUSH
68044: LD_VAR 0 10
68048: PUSH
68049: LD_INT 1
68051: ARRAY
68052: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68053: LD_ADDR_VAR 0 10
68057: PUSH
68058: LD_VAR 0 10
68062: PPUSH
68063: LD_INT 1
68065: PPUSH
68066: CALL_OW 3
68070: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68071: LD_VAR 0 2
68075: PPUSH
68076: LD_VAR 0 5
68080: PPUSH
68081: CALL 68390 0 2
68085: PUSH
68086: LD_VAR 0 10
68090: PUSH
68091: EMPTY
68092: EQUAL
68093: OR
68094: IFFALSE 68039
// result := [ ] ;
68096: LD_ADDR_VAR 0 6
68100: PUSH
68101: EMPTY
68102: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68103: LD_VAR 0 1
68107: PPUSH
68108: LD_VAR 0 2
68112: PPUSH
68113: LD_VAR 0 3
68117: PPUSH
68118: LD_VAR 0 4
68122: PPUSH
68123: LD_VAR 0 5
68127: PPUSH
68128: CALL_OW 448
68132: IFFALSE 68165
// result := [ chassis , engine , control , weapon ] ;
68134: LD_ADDR_VAR 0 6
68138: PUSH
68139: LD_VAR 0 2
68143: PUSH
68144: LD_VAR 0 3
68148: PUSH
68149: LD_VAR 0 4
68153: PUSH
68154: LD_VAR 0 5
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// end ;
68165: LD_VAR 0 6
68169: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68170: LD_INT 0
68172: PPUSH
// if not chassis or not engine then
68173: LD_VAR 0 1
68177: NOT
68178: PUSH
68179: LD_VAR 0 2
68183: NOT
68184: OR
68185: IFFALSE 68189
// exit ;
68187: GO 68385
// case engine of engine_solar :
68189: LD_VAR 0 2
68193: PUSH
68194: LD_INT 2
68196: DOUBLE
68197: EQUAL
68198: IFTRUE 68202
68200: GO 68240
68202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68203: LD_ADDR_VAR 0 3
68207: PUSH
68208: LD_INT 11
68210: PUSH
68211: LD_INT 12
68213: PUSH
68214: LD_INT 13
68216: PUSH
68217: LD_INT 14
68219: PUSH
68220: LD_INT 1
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: LD_INT 3
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: ST_TO_ADDR
68238: GO 68369
68240: LD_INT 1
68242: DOUBLE
68243: EQUAL
68244: IFTRUE 68248
68246: GO 68310
68248: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68249: LD_ADDR_VAR 0 3
68253: PUSH
68254: LD_INT 11
68256: PUSH
68257: LD_INT 12
68259: PUSH
68260: LD_INT 13
68262: PUSH
68263: LD_INT 14
68265: PUSH
68266: LD_INT 1
68268: PUSH
68269: LD_INT 2
68271: PUSH
68272: LD_INT 3
68274: PUSH
68275: LD_INT 4
68277: PUSH
68278: LD_INT 5
68280: PUSH
68281: LD_INT 21
68283: PUSH
68284: LD_INT 23
68286: PUSH
68287: LD_INT 22
68289: PUSH
68290: LD_INT 24
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: ST_TO_ADDR
68308: GO 68369
68310: LD_INT 3
68312: DOUBLE
68313: EQUAL
68314: IFTRUE 68318
68316: GO 68368
68318: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68319: LD_ADDR_VAR 0 3
68323: PUSH
68324: LD_INT 13
68326: PUSH
68327: LD_INT 14
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: LD_INT 3
68335: PUSH
68336: LD_INT 4
68338: PUSH
68339: LD_INT 5
68341: PUSH
68342: LD_INT 21
68344: PUSH
68345: LD_INT 22
68347: PUSH
68348: LD_INT 23
68350: PUSH
68351: LD_INT 24
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: LIST
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: ST_TO_ADDR
68366: GO 68369
68368: POP
// result := ( chassis in result ) ;
68369: LD_ADDR_VAR 0 3
68373: PUSH
68374: LD_VAR 0 1
68378: PUSH
68379: LD_VAR 0 3
68383: IN
68384: ST_TO_ADDR
// end ;
68385: LD_VAR 0 3
68389: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68390: LD_INT 0
68392: PPUSH
// if not chassis or not weapon then
68393: LD_VAR 0 1
68397: NOT
68398: PUSH
68399: LD_VAR 0 2
68403: NOT
68404: OR
68405: IFFALSE 68409
// exit ;
68407: GO 69435
// case weapon of us_machine_gun :
68409: LD_VAR 0 2
68413: PUSH
68414: LD_INT 2
68416: DOUBLE
68417: EQUAL
68418: IFTRUE 68422
68420: GO 68452
68422: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68423: LD_ADDR_VAR 0 3
68427: PUSH
68428: LD_INT 1
68430: PUSH
68431: LD_INT 2
68433: PUSH
68434: LD_INT 3
68436: PUSH
68437: LD_INT 4
68439: PUSH
68440: LD_INT 5
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: ST_TO_ADDR
68450: GO 69419
68452: LD_INT 3
68454: DOUBLE
68455: EQUAL
68456: IFTRUE 68460
68458: GO 68490
68460: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68461: LD_ADDR_VAR 0 3
68465: PUSH
68466: LD_INT 1
68468: PUSH
68469: LD_INT 2
68471: PUSH
68472: LD_INT 3
68474: PUSH
68475: LD_INT 4
68477: PUSH
68478: LD_INT 5
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: ST_TO_ADDR
68488: GO 69419
68490: LD_INT 11
68492: DOUBLE
68493: EQUAL
68494: IFTRUE 68498
68496: GO 68528
68498: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68499: LD_ADDR_VAR 0 3
68503: PUSH
68504: LD_INT 1
68506: PUSH
68507: LD_INT 2
68509: PUSH
68510: LD_INT 3
68512: PUSH
68513: LD_INT 4
68515: PUSH
68516: LD_INT 5
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: ST_TO_ADDR
68526: GO 69419
68528: LD_INT 4
68530: DOUBLE
68531: EQUAL
68532: IFTRUE 68536
68534: GO 68562
68536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68537: LD_ADDR_VAR 0 3
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: LD_INT 3
68547: PUSH
68548: LD_INT 4
68550: PUSH
68551: LD_INT 5
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: ST_TO_ADDR
68560: GO 69419
68562: LD_INT 5
68564: DOUBLE
68565: EQUAL
68566: IFTRUE 68570
68568: GO 68596
68570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68571: LD_ADDR_VAR 0 3
68575: PUSH
68576: LD_INT 2
68578: PUSH
68579: LD_INT 3
68581: PUSH
68582: LD_INT 4
68584: PUSH
68585: LD_INT 5
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: ST_TO_ADDR
68594: GO 69419
68596: LD_INT 9
68598: DOUBLE
68599: EQUAL
68600: IFTRUE 68604
68602: GO 68630
68604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68605: LD_ADDR_VAR 0 3
68609: PUSH
68610: LD_INT 2
68612: PUSH
68613: LD_INT 3
68615: PUSH
68616: LD_INT 4
68618: PUSH
68619: LD_INT 5
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: ST_TO_ADDR
68628: GO 69419
68630: LD_INT 7
68632: DOUBLE
68633: EQUAL
68634: IFTRUE 68638
68636: GO 68664
68638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68639: LD_ADDR_VAR 0 3
68643: PUSH
68644: LD_INT 2
68646: PUSH
68647: LD_INT 3
68649: PUSH
68650: LD_INT 4
68652: PUSH
68653: LD_INT 5
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: ST_TO_ADDR
68662: GO 69419
68664: LD_INT 12
68666: DOUBLE
68667: EQUAL
68668: IFTRUE 68672
68670: GO 68698
68672: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68673: LD_ADDR_VAR 0 3
68677: PUSH
68678: LD_INT 2
68680: PUSH
68681: LD_INT 3
68683: PUSH
68684: LD_INT 4
68686: PUSH
68687: LD_INT 5
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: ST_TO_ADDR
68696: GO 69419
68698: LD_INT 13
68700: DOUBLE
68701: EQUAL
68702: IFTRUE 68706
68704: GO 68732
68706: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68707: LD_ADDR_VAR 0 3
68711: PUSH
68712: LD_INT 2
68714: PUSH
68715: LD_INT 3
68717: PUSH
68718: LD_INT 4
68720: PUSH
68721: LD_INT 5
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: ST_TO_ADDR
68730: GO 69419
68732: LD_INT 14
68734: DOUBLE
68735: EQUAL
68736: IFTRUE 68740
68738: GO 68758
68740: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68741: LD_ADDR_VAR 0 3
68745: PUSH
68746: LD_INT 4
68748: PUSH
68749: LD_INT 5
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: ST_TO_ADDR
68756: GO 69419
68758: LD_INT 6
68760: DOUBLE
68761: EQUAL
68762: IFTRUE 68766
68764: GO 68784
68766: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68767: LD_ADDR_VAR 0 3
68771: PUSH
68772: LD_INT 4
68774: PUSH
68775: LD_INT 5
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: ST_TO_ADDR
68782: GO 69419
68784: LD_INT 10
68786: DOUBLE
68787: EQUAL
68788: IFTRUE 68792
68790: GO 68810
68792: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68793: LD_ADDR_VAR 0 3
68797: PUSH
68798: LD_INT 4
68800: PUSH
68801: LD_INT 5
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: ST_TO_ADDR
68808: GO 69419
68810: LD_INT 22
68812: DOUBLE
68813: EQUAL
68814: IFTRUE 68818
68816: GO 68844
68818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68819: LD_ADDR_VAR 0 3
68823: PUSH
68824: LD_INT 11
68826: PUSH
68827: LD_INT 12
68829: PUSH
68830: LD_INT 13
68832: PUSH
68833: LD_INT 14
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: ST_TO_ADDR
68842: GO 69419
68844: LD_INT 23
68846: DOUBLE
68847: EQUAL
68848: IFTRUE 68852
68850: GO 68878
68852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68853: LD_ADDR_VAR 0 3
68857: PUSH
68858: LD_INT 11
68860: PUSH
68861: LD_INT 12
68863: PUSH
68864: LD_INT 13
68866: PUSH
68867: LD_INT 14
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: ST_TO_ADDR
68876: GO 69419
68878: LD_INT 24
68880: DOUBLE
68881: EQUAL
68882: IFTRUE 68886
68884: GO 68912
68886: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68887: LD_ADDR_VAR 0 3
68891: PUSH
68892: LD_INT 11
68894: PUSH
68895: LD_INT 12
68897: PUSH
68898: LD_INT 13
68900: PUSH
68901: LD_INT 14
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: ST_TO_ADDR
68910: GO 69419
68912: LD_INT 30
68914: DOUBLE
68915: EQUAL
68916: IFTRUE 68920
68918: GO 68946
68920: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68921: LD_ADDR_VAR 0 3
68925: PUSH
68926: LD_INT 11
68928: PUSH
68929: LD_INT 12
68931: PUSH
68932: LD_INT 13
68934: PUSH
68935: LD_INT 14
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: ST_TO_ADDR
68944: GO 69419
68946: LD_INT 25
68948: DOUBLE
68949: EQUAL
68950: IFTRUE 68954
68952: GO 68972
68954: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68955: LD_ADDR_VAR 0 3
68959: PUSH
68960: LD_INT 13
68962: PUSH
68963: LD_INT 14
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: ST_TO_ADDR
68970: GO 69419
68972: LD_INT 27
68974: DOUBLE
68975: EQUAL
68976: IFTRUE 68980
68978: GO 68998
68980: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68981: LD_ADDR_VAR 0 3
68985: PUSH
68986: LD_INT 13
68988: PUSH
68989: LD_INT 14
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: ST_TO_ADDR
68996: GO 69419
68998: LD_INT 28
69000: DOUBLE
69001: EQUAL
69002: IFTRUE 69006
69004: GO 69024
69006: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69007: LD_ADDR_VAR 0 3
69011: PUSH
69012: LD_INT 13
69014: PUSH
69015: LD_INT 14
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: ST_TO_ADDR
69022: GO 69419
69024: LD_INT 29
69026: DOUBLE
69027: EQUAL
69028: IFTRUE 69032
69030: GO 69050
69032: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69033: LD_ADDR_VAR 0 3
69037: PUSH
69038: LD_INT 13
69040: PUSH
69041: LD_INT 14
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: ST_TO_ADDR
69048: GO 69419
69050: LD_INT 31
69052: DOUBLE
69053: EQUAL
69054: IFTRUE 69058
69056: GO 69076
69058: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69059: LD_ADDR_VAR 0 3
69063: PUSH
69064: LD_INT 13
69066: PUSH
69067: LD_INT 14
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: ST_TO_ADDR
69074: GO 69419
69076: LD_INT 26
69078: DOUBLE
69079: EQUAL
69080: IFTRUE 69084
69082: GO 69102
69084: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69085: LD_ADDR_VAR 0 3
69089: PUSH
69090: LD_INT 13
69092: PUSH
69093: LD_INT 14
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: ST_TO_ADDR
69100: GO 69419
69102: LD_INT 42
69104: DOUBLE
69105: EQUAL
69106: IFTRUE 69110
69108: GO 69136
69110: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69111: LD_ADDR_VAR 0 3
69115: PUSH
69116: LD_INT 21
69118: PUSH
69119: LD_INT 22
69121: PUSH
69122: LD_INT 23
69124: PUSH
69125: LD_INT 24
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: ST_TO_ADDR
69134: GO 69419
69136: LD_INT 43
69138: DOUBLE
69139: EQUAL
69140: IFTRUE 69144
69142: GO 69170
69144: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69145: LD_ADDR_VAR 0 3
69149: PUSH
69150: LD_INT 21
69152: PUSH
69153: LD_INT 22
69155: PUSH
69156: LD_INT 23
69158: PUSH
69159: LD_INT 24
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: ST_TO_ADDR
69168: GO 69419
69170: LD_INT 44
69172: DOUBLE
69173: EQUAL
69174: IFTRUE 69178
69176: GO 69204
69178: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69179: LD_ADDR_VAR 0 3
69183: PUSH
69184: LD_INT 21
69186: PUSH
69187: LD_INT 22
69189: PUSH
69190: LD_INT 23
69192: PUSH
69193: LD_INT 24
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: ST_TO_ADDR
69202: GO 69419
69204: LD_INT 45
69206: DOUBLE
69207: EQUAL
69208: IFTRUE 69212
69210: GO 69238
69212: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69213: LD_ADDR_VAR 0 3
69217: PUSH
69218: LD_INT 21
69220: PUSH
69221: LD_INT 22
69223: PUSH
69224: LD_INT 23
69226: PUSH
69227: LD_INT 24
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: ST_TO_ADDR
69236: GO 69419
69238: LD_INT 49
69240: DOUBLE
69241: EQUAL
69242: IFTRUE 69246
69244: GO 69272
69246: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69247: LD_ADDR_VAR 0 3
69251: PUSH
69252: LD_INT 21
69254: PUSH
69255: LD_INT 22
69257: PUSH
69258: LD_INT 23
69260: PUSH
69261: LD_INT 24
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: ST_TO_ADDR
69270: GO 69419
69272: LD_INT 51
69274: DOUBLE
69275: EQUAL
69276: IFTRUE 69280
69278: GO 69306
69280: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69281: LD_ADDR_VAR 0 3
69285: PUSH
69286: LD_INT 21
69288: PUSH
69289: LD_INT 22
69291: PUSH
69292: LD_INT 23
69294: PUSH
69295: LD_INT 24
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: ST_TO_ADDR
69304: GO 69419
69306: LD_INT 52
69308: DOUBLE
69309: EQUAL
69310: IFTRUE 69314
69312: GO 69340
69314: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69315: LD_ADDR_VAR 0 3
69319: PUSH
69320: LD_INT 21
69322: PUSH
69323: LD_INT 22
69325: PUSH
69326: LD_INT 23
69328: PUSH
69329: LD_INT 24
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: ST_TO_ADDR
69338: GO 69419
69340: LD_INT 53
69342: DOUBLE
69343: EQUAL
69344: IFTRUE 69348
69346: GO 69366
69348: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69349: LD_ADDR_VAR 0 3
69353: PUSH
69354: LD_INT 23
69356: PUSH
69357: LD_INT 24
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: ST_TO_ADDR
69364: GO 69419
69366: LD_INT 46
69368: DOUBLE
69369: EQUAL
69370: IFTRUE 69374
69372: GO 69392
69374: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69375: LD_ADDR_VAR 0 3
69379: PUSH
69380: LD_INT 23
69382: PUSH
69383: LD_INT 24
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: ST_TO_ADDR
69390: GO 69419
69392: LD_INT 47
69394: DOUBLE
69395: EQUAL
69396: IFTRUE 69400
69398: GO 69418
69400: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69401: LD_ADDR_VAR 0 3
69405: PUSH
69406: LD_INT 23
69408: PUSH
69409: LD_INT 24
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: ST_TO_ADDR
69416: GO 69419
69418: POP
// result := ( chassis in result ) ;
69419: LD_ADDR_VAR 0 3
69423: PUSH
69424: LD_VAR 0 1
69428: PUSH
69429: LD_VAR 0 3
69433: IN
69434: ST_TO_ADDR
// end ;
69435: LD_VAR 0 3
69439: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69440: LD_INT 0
69442: PPUSH
69443: PPUSH
69444: PPUSH
69445: PPUSH
69446: PPUSH
69447: PPUSH
69448: PPUSH
// result := array ;
69449: LD_ADDR_VAR 0 5
69453: PUSH
69454: LD_VAR 0 1
69458: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69459: LD_VAR 0 1
69463: NOT
69464: PUSH
69465: LD_VAR 0 2
69469: NOT
69470: OR
69471: PUSH
69472: LD_VAR 0 3
69476: NOT
69477: OR
69478: PUSH
69479: LD_VAR 0 2
69483: PUSH
69484: LD_VAR 0 1
69488: GREATER
69489: OR
69490: PUSH
69491: LD_VAR 0 3
69495: PUSH
69496: LD_VAR 0 1
69500: GREATER
69501: OR
69502: IFFALSE 69506
// exit ;
69504: GO 69802
// if direction then
69506: LD_VAR 0 4
69510: IFFALSE 69574
// begin d := 1 ;
69512: LD_ADDR_VAR 0 9
69516: PUSH
69517: LD_INT 1
69519: ST_TO_ADDR
// if i_from > i_to then
69520: LD_VAR 0 2
69524: PUSH
69525: LD_VAR 0 3
69529: GREATER
69530: IFFALSE 69556
// length := ( array - i_from ) + i_to else
69532: LD_ADDR_VAR 0 11
69536: PUSH
69537: LD_VAR 0 1
69541: PUSH
69542: LD_VAR 0 2
69546: MINUS
69547: PUSH
69548: LD_VAR 0 3
69552: PLUS
69553: ST_TO_ADDR
69554: GO 69572
// length := i_to - i_from ;
69556: LD_ADDR_VAR 0 11
69560: PUSH
69561: LD_VAR 0 3
69565: PUSH
69566: LD_VAR 0 2
69570: MINUS
69571: ST_TO_ADDR
// end else
69572: GO 69635
// begin d := - 1 ;
69574: LD_ADDR_VAR 0 9
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: ST_TO_ADDR
// if i_from > i_to then
69583: LD_VAR 0 2
69587: PUSH
69588: LD_VAR 0 3
69592: GREATER
69593: IFFALSE 69613
// length := i_from - i_to else
69595: LD_ADDR_VAR 0 11
69599: PUSH
69600: LD_VAR 0 2
69604: PUSH
69605: LD_VAR 0 3
69609: MINUS
69610: ST_TO_ADDR
69611: GO 69635
// length := ( array - i_to ) + i_from ;
69613: LD_ADDR_VAR 0 11
69617: PUSH
69618: LD_VAR 0 1
69622: PUSH
69623: LD_VAR 0 3
69627: MINUS
69628: PUSH
69629: LD_VAR 0 2
69633: PLUS
69634: ST_TO_ADDR
// end ; if not length then
69635: LD_VAR 0 11
69639: NOT
69640: IFFALSE 69644
// exit ;
69642: GO 69802
// tmp := array ;
69644: LD_ADDR_VAR 0 10
69648: PUSH
69649: LD_VAR 0 1
69653: ST_TO_ADDR
// for i = 1 to length do
69654: LD_ADDR_VAR 0 6
69658: PUSH
69659: DOUBLE
69660: LD_INT 1
69662: DEC
69663: ST_TO_ADDR
69664: LD_VAR 0 11
69668: PUSH
69669: FOR_TO
69670: IFFALSE 69790
// begin for j = 1 to array do
69672: LD_ADDR_VAR 0 7
69676: PUSH
69677: DOUBLE
69678: LD_INT 1
69680: DEC
69681: ST_TO_ADDR
69682: LD_VAR 0 1
69686: PUSH
69687: FOR_TO
69688: IFFALSE 69776
// begin k := j + d ;
69690: LD_ADDR_VAR 0 8
69694: PUSH
69695: LD_VAR 0 7
69699: PUSH
69700: LD_VAR 0 9
69704: PLUS
69705: ST_TO_ADDR
// if k > array then
69706: LD_VAR 0 8
69710: PUSH
69711: LD_VAR 0 1
69715: GREATER
69716: IFFALSE 69726
// k := 1 ;
69718: LD_ADDR_VAR 0 8
69722: PUSH
69723: LD_INT 1
69725: ST_TO_ADDR
// if not k then
69726: LD_VAR 0 8
69730: NOT
69731: IFFALSE 69743
// k := array ;
69733: LD_ADDR_VAR 0 8
69737: PUSH
69738: LD_VAR 0 1
69742: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69743: LD_ADDR_VAR 0 10
69747: PUSH
69748: LD_VAR 0 10
69752: PPUSH
69753: LD_VAR 0 8
69757: PPUSH
69758: LD_VAR 0 1
69762: PUSH
69763: LD_VAR 0 7
69767: ARRAY
69768: PPUSH
69769: CALL_OW 1
69773: ST_TO_ADDR
// end ;
69774: GO 69687
69776: POP
69777: POP
// array := tmp ;
69778: LD_ADDR_VAR 0 1
69782: PUSH
69783: LD_VAR 0 10
69787: ST_TO_ADDR
// end ;
69788: GO 69669
69790: POP
69791: POP
// result := array ;
69792: LD_ADDR_VAR 0 5
69796: PUSH
69797: LD_VAR 0 1
69801: ST_TO_ADDR
// end ;
69802: LD_VAR 0 5
69806: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69807: LD_INT 0
69809: PPUSH
69810: PPUSH
// result := 0 ;
69811: LD_ADDR_VAR 0 3
69815: PUSH
69816: LD_INT 0
69818: ST_TO_ADDR
// if not array or not value in array then
69819: LD_VAR 0 1
69823: NOT
69824: PUSH
69825: LD_VAR 0 2
69829: PUSH
69830: LD_VAR 0 1
69834: IN
69835: NOT
69836: OR
69837: IFFALSE 69841
// exit ;
69839: GO 69895
// for i = 1 to array do
69841: LD_ADDR_VAR 0 4
69845: PUSH
69846: DOUBLE
69847: LD_INT 1
69849: DEC
69850: ST_TO_ADDR
69851: LD_VAR 0 1
69855: PUSH
69856: FOR_TO
69857: IFFALSE 69893
// if value = array [ i ] then
69859: LD_VAR 0 2
69863: PUSH
69864: LD_VAR 0 1
69868: PUSH
69869: LD_VAR 0 4
69873: ARRAY
69874: EQUAL
69875: IFFALSE 69891
// begin result := i ;
69877: LD_ADDR_VAR 0 3
69881: PUSH
69882: LD_VAR 0 4
69886: ST_TO_ADDR
// exit ;
69887: POP
69888: POP
69889: GO 69895
// end ;
69891: GO 69856
69893: POP
69894: POP
// end ;
69895: LD_VAR 0 3
69899: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69900: LD_INT 0
69902: PPUSH
// vc_chassis := chassis ;
69903: LD_ADDR_OWVAR 37
69907: PUSH
69908: LD_VAR 0 1
69912: ST_TO_ADDR
// vc_engine := engine ;
69913: LD_ADDR_OWVAR 39
69917: PUSH
69918: LD_VAR 0 2
69922: ST_TO_ADDR
// vc_control := control ;
69923: LD_ADDR_OWVAR 38
69927: PUSH
69928: LD_VAR 0 3
69932: ST_TO_ADDR
// vc_weapon := weapon ;
69933: LD_ADDR_OWVAR 40
69937: PUSH
69938: LD_VAR 0 4
69942: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69943: LD_ADDR_OWVAR 41
69947: PUSH
69948: LD_VAR 0 5
69952: ST_TO_ADDR
// end ;
69953: LD_VAR 0 6
69957: RET
// export function WantPlant ( unit ) ; var task ; begin
69958: LD_INT 0
69960: PPUSH
69961: PPUSH
// result := false ;
69962: LD_ADDR_VAR 0 2
69966: PUSH
69967: LD_INT 0
69969: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69970: LD_ADDR_VAR 0 3
69974: PUSH
69975: LD_VAR 0 1
69979: PPUSH
69980: CALL_OW 437
69984: ST_TO_ADDR
// if task then
69985: LD_VAR 0 3
69989: IFFALSE 70017
// if task [ 1 ] [ 1 ] = p then
69991: LD_VAR 0 3
69995: PUSH
69996: LD_INT 1
69998: ARRAY
69999: PUSH
70000: LD_INT 1
70002: ARRAY
70003: PUSH
70004: LD_STRING p
70006: EQUAL
70007: IFFALSE 70017
// result := true ;
70009: LD_ADDR_VAR 0 2
70013: PUSH
70014: LD_INT 1
70016: ST_TO_ADDR
// end ;
70017: LD_VAR 0 2
70021: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70022: LD_INT 0
70024: PPUSH
70025: PPUSH
70026: PPUSH
70027: PPUSH
// if pos < 1 then
70028: LD_VAR 0 2
70032: PUSH
70033: LD_INT 1
70035: LESS
70036: IFFALSE 70040
// exit ;
70038: GO 70343
// if pos = 1 then
70040: LD_VAR 0 2
70044: PUSH
70045: LD_INT 1
70047: EQUAL
70048: IFFALSE 70081
// result := Replace ( arr , pos [ 1 ] , value ) else
70050: LD_ADDR_VAR 0 4
70054: PUSH
70055: LD_VAR 0 1
70059: PPUSH
70060: LD_VAR 0 2
70064: PUSH
70065: LD_INT 1
70067: ARRAY
70068: PPUSH
70069: LD_VAR 0 3
70073: PPUSH
70074: CALL_OW 1
70078: ST_TO_ADDR
70079: GO 70343
// begin tmp := arr ;
70081: LD_ADDR_VAR 0 6
70085: PUSH
70086: LD_VAR 0 1
70090: ST_TO_ADDR
// s_arr := [ tmp ] ;
70091: LD_ADDR_VAR 0 7
70095: PUSH
70096: LD_VAR 0 6
70100: PUSH
70101: EMPTY
70102: LIST
70103: ST_TO_ADDR
// for i = 1 to pos - 1 do
70104: LD_ADDR_VAR 0 5
70108: PUSH
70109: DOUBLE
70110: LD_INT 1
70112: DEC
70113: ST_TO_ADDR
70114: LD_VAR 0 2
70118: PUSH
70119: LD_INT 1
70121: MINUS
70122: PUSH
70123: FOR_TO
70124: IFFALSE 70169
// begin tmp := tmp [ pos [ i ] ] ;
70126: LD_ADDR_VAR 0 6
70130: PUSH
70131: LD_VAR 0 6
70135: PUSH
70136: LD_VAR 0 2
70140: PUSH
70141: LD_VAR 0 5
70145: ARRAY
70146: ARRAY
70147: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70148: LD_ADDR_VAR 0 7
70152: PUSH
70153: LD_VAR 0 7
70157: PUSH
70158: LD_VAR 0 6
70162: PUSH
70163: EMPTY
70164: LIST
70165: ADD
70166: ST_TO_ADDR
// end ;
70167: GO 70123
70169: POP
70170: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70171: LD_ADDR_VAR 0 6
70175: PUSH
70176: LD_VAR 0 6
70180: PPUSH
70181: LD_VAR 0 2
70185: PUSH
70186: LD_VAR 0 2
70190: ARRAY
70191: PPUSH
70192: LD_VAR 0 3
70196: PPUSH
70197: CALL_OW 1
70201: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70202: LD_ADDR_VAR 0 7
70206: PUSH
70207: LD_VAR 0 7
70211: PPUSH
70212: LD_VAR 0 7
70216: PPUSH
70217: LD_VAR 0 6
70221: PPUSH
70222: CALL_OW 1
70226: ST_TO_ADDR
// for i = s_arr downto 2 do
70227: LD_ADDR_VAR 0 5
70231: PUSH
70232: DOUBLE
70233: LD_VAR 0 7
70237: INC
70238: ST_TO_ADDR
70239: LD_INT 2
70241: PUSH
70242: FOR_DOWNTO
70243: IFFALSE 70327
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70245: LD_ADDR_VAR 0 6
70249: PUSH
70250: LD_VAR 0 7
70254: PUSH
70255: LD_VAR 0 5
70259: PUSH
70260: LD_INT 1
70262: MINUS
70263: ARRAY
70264: PPUSH
70265: LD_VAR 0 2
70269: PUSH
70270: LD_VAR 0 5
70274: PUSH
70275: LD_INT 1
70277: MINUS
70278: ARRAY
70279: PPUSH
70280: LD_VAR 0 7
70284: PUSH
70285: LD_VAR 0 5
70289: ARRAY
70290: PPUSH
70291: CALL_OW 1
70295: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70296: LD_ADDR_VAR 0 7
70300: PUSH
70301: LD_VAR 0 7
70305: PPUSH
70306: LD_VAR 0 5
70310: PUSH
70311: LD_INT 1
70313: MINUS
70314: PPUSH
70315: LD_VAR 0 6
70319: PPUSH
70320: CALL_OW 1
70324: ST_TO_ADDR
// end ;
70325: GO 70242
70327: POP
70328: POP
// result := s_arr [ 1 ] ;
70329: LD_ADDR_VAR 0 4
70333: PUSH
70334: LD_VAR 0 7
70338: PUSH
70339: LD_INT 1
70341: ARRAY
70342: ST_TO_ADDR
// end ; end ;
70343: LD_VAR 0 4
70347: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70348: LD_INT 0
70350: PPUSH
70351: PPUSH
// if not list then
70352: LD_VAR 0 1
70356: NOT
70357: IFFALSE 70361
// exit ;
70359: GO 70452
// i := list [ pos1 ] ;
70361: LD_ADDR_VAR 0 5
70365: PUSH
70366: LD_VAR 0 1
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: ST_TO_ADDR
// if not i then
70377: LD_VAR 0 5
70381: NOT
70382: IFFALSE 70386
// exit ;
70384: GO 70452
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70386: LD_ADDR_VAR 0 1
70390: PUSH
70391: LD_VAR 0 1
70395: PPUSH
70396: LD_VAR 0 2
70400: PPUSH
70401: LD_VAR 0 1
70405: PUSH
70406: LD_VAR 0 3
70410: ARRAY
70411: PPUSH
70412: CALL_OW 1
70416: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70417: LD_ADDR_VAR 0 1
70421: PUSH
70422: LD_VAR 0 1
70426: PPUSH
70427: LD_VAR 0 3
70431: PPUSH
70432: LD_VAR 0 5
70436: PPUSH
70437: CALL_OW 1
70441: ST_TO_ADDR
// result := list ;
70442: LD_ADDR_VAR 0 4
70446: PUSH
70447: LD_VAR 0 1
70451: ST_TO_ADDR
// end ;
70452: LD_VAR 0 4
70456: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70457: LD_INT 0
70459: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70460: LD_ADDR_VAR 0 5
70464: PUSH
70465: LD_VAR 0 1
70469: PPUSH
70470: CALL_OW 250
70474: PPUSH
70475: LD_VAR 0 1
70479: PPUSH
70480: CALL_OW 251
70484: PPUSH
70485: LD_VAR 0 2
70489: PPUSH
70490: LD_VAR 0 3
70494: PPUSH
70495: LD_VAR 0 4
70499: PPUSH
70500: CALL 70510 0 5
70504: ST_TO_ADDR
// end ;
70505: LD_VAR 0 5
70509: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70510: LD_INT 0
70512: PPUSH
70513: PPUSH
70514: PPUSH
70515: PPUSH
// if not list then
70516: LD_VAR 0 3
70520: NOT
70521: IFFALSE 70525
// exit ;
70523: GO 70913
// result := [ ] ;
70525: LD_ADDR_VAR 0 6
70529: PUSH
70530: EMPTY
70531: ST_TO_ADDR
// for i in list do
70532: LD_ADDR_VAR 0 7
70536: PUSH
70537: LD_VAR 0 3
70541: PUSH
70542: FOR_IN
70543: IFFALSE 70745
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70545: LD_ADDR_VAR 0 9
70549: PUSH
70550: LD_VAR 0 7
70554: PPUSH
70555: LD_VAR 0 1
70559: PPUSH
70560: LD_VAR 0 2
70564: PPUSH
70565: CALL_OW 297
70569: ST_TO_ADDR
// if not result then
70570: LD_VAR 0 6
70574: NOT
70575: IFFALSE 70601
// result := [ [ i , tmp ] ] else
70577: LD_ADDR_VAR 0 6
70581: PUSH
70582: LD_VAR 0 7
70586: PUSH
70587: LD_VAR 0 9
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: EMPTY
70597: LIST
70598: ST_TO_ADDR
70599: GO 70743
// begin if result [ result ] [ 2 ] < tmp then
70601: LD_VAR 0 6
70605: PUSH
70606: LD_VAR 0 6
70610: ARRAY
70611: PUSH
70612: LD_INT 2
70614: ARRAY
70615: PUSH
70616: LD_VAR 0 9
70620: LESS
70621: IFFALSE 70663
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70623: LD_ADDR_VAR 0 6
70627: PUSH
70628: LD_VAR 0 6
70632: PPUSH
70633: LD_VAR 0 6
70637: PUSH
70638: LD_INT 1
70640: PLUS
70641: PPUSH
70642: LD_VAR 0 7
70646: PUSH
70647: LD_VAR 0 9
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PPUSH
70656: CALL_OW 2
70660: ST_TO_ADDR
70661: GO 70743
// for j = 1 to result do
70663: LD_ADDR_VAR 0 8
70667: PUSH
70668: DOUBLE
70669: LD_INT 1
70671: DEC
70672: ST_TO_ADDR
70673: LD_VAR 0 6
70677: PUSH
70678: FOR_TO
70679: IFFALSE 70741
// begin if tmp < result [ j ] [ 2 ] then
70681: LD_VAR 0 9
70685: PUSH
70686: LD_VAR 0 6
70690: PUSH
70691: LD_VAR 0 8
70695: ARRAY
70696: PUSH
70697: LD_INT 2
70699: ARRAY
70700: LESS
70701: IFFALSE 70739
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70703: LD_ADDR_VAR 0 6
70707: PUSH
70708: LD_VAR 0 6
70712: PPUSH
70713: LD_VAR 0 8
70717: PPUSH
70718: LD_VAR 0 7
70722: PUSH
70723: LD_VAR 0 9
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PPUSH
70732: CALL_OW 2
70736: ST_TO_ADDR
// break ;
70737: GO 70741
// end ; end ;
70739: GO 70678
70741: POP
70742: POP
// end ; end ;
70743: GO 70542
70745: POP
70746: POP
// if result and not asc then
70747: LD_VAR 0 6
70751: PUSH
70752: LD_VAR 0 4
70756: NOT
70757: AND
70758: IFFALSE 70833
// begin tmp := result ;
70760: LD_ADDR_VAR 0 9
70764: PUSH
70765: LD_VAR 0 6
70769: ST_TO_ADDR
// for i = tmp downto 1 do
70770: LD_ADDR_VAR 0 7
70774: PUSH
70775: DOUBLE
70776: LD_VAR 0 9
70780: INC
70781: ST_TO_ADDR
70782: LD_INT 1
70784: PUSH
70785: FOR_DOWNTO
70786: IFFALSE 70831
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70788: LD_ADDR_VAR 0 6
70792: PUSH
70793: LD_VAR 0 6
70797: PPUSH
70798: LD_VAR 0 9
70802: PUSH
70803: LD_VAR 0 7
70807: MINUS
70808: PUSH
70809: LD_INT 1
70811: PLUS
70812: PPUSH
70813: LD_VAR 0 9
70817: PUSH
70818: LD_VAR 0 7
70822: ARRAY
70823: PPUSH
70824: CALL_OW 1
70828: ST_TO_ADDR
70829: GO 70785
70831: POP
70832: POP
// end ; tmp := [ ] ;
70833: LD_ADDR_VAR 0 9
70837: PUSH
70838: EMPTY
70839: ST_TO_ADDR
// if mode then
70840: LD_VAR 0 5
70844: IFFALSE 70913
// begin for i = 1 to result do
70846: LD_ADDR_VAR 0 7
70850: PUSH
70851: DOUBLE
70852: LD_INT 1
70854: DEC
70855: ST_TO_ADDR
70856: LD_VAR 0 6
70860: PUSH
70861: FOR_TO
70862: IFFALSE 70901
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70864: LD_ADDR_VAR 0 9
70868: PUSH
70869: LD_VAR 0 9
70873: PPUSH
70874: LD_VAR 0 7
70878: PPUSH
70879: LD_VAR 0 6
70883: PUSH
70884: LD_VAR 0 7
70888: ARRAY
70889: PUSH
70890: LD_INT 1
70892: ARRAY
70893: PPUSH
70894: CALL_OW 1
70898: ST_TO_ADDR
70899: GO 70861
70901: POP
70902: POP
// result := tmp ;
70903: LD_ADDR_VAR 0 6
70907: PUSH
70908: LD_VAR 0 9
70912: ST_TO_ADDR
// end ; end ;
70913: LD_VAR 0 6
70917: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70918: LD_INT 0
70920: PPUSH
70921: PPUSH
70922: PPUSH
70923: PPUSH
70924: PPUSH
70925: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70926: LD_ADDR_VAR 0 5
70930: PUSH
70931: LD_INT 0
70933: PUSH
70934: LD_INT 0
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: ST_TO_ADDR
// if not x or not y then
70948: LD_VAR 0 2
70952: NOT
70953: PUSH
70954: LD_VAR 0 3
70958: NOT
70959: OR
70960: IFFALSE 70964
// exit ;
70962: GO 72610
// if not range then
70964: LD_VAR 0 4
70968: NOT
70969: IFFALSE 70979
// range := 10 ;
70971: LD_ADDR_VAR 0 4
70975: PUSH
70976: LD_INT 10
70978: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70979: LD_ADDR_VAR 0 8
70983: PUSH
70984: LD_INT 81
70986: PUSH
70987: LD_VAR 0 1
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 92
70998: PUSH
70999: LD_VAR 0 2
71003: PUSH
71004: LD_VAR 0 3
71008: PUSH
71009: LD_VAR 0 4
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 3
71022: PUSH
71023: LD_INT 21
71025: PUSH
71026: LD_INT 3
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: LIST
71041: PPUSH
71042: CALL_OW 69
71046: ST_TO_ADDR
// if not tmp then
71047: LD_VAR 0 8
71051: NOT
71052: IFFALSE 71056
// exit ;
71054: GO 72610
// for i in tmp do
71056: LD_ADDR_VAR 0 6
71060: PUSH
71061: LD_VAR 0 8
71065: PUSH
71066: FOR_IN
71067: IFFALSE 72585
// begin points := [ 0 , 0 , 0 ] ;
71069: LD_ADDR_VAR 0 9
71073: PUSH
71074: LD_INT 0
71076: PUSH
71077: LD_INT 0
71079: PUSH
71080: LD_INT 0
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: ST_TO_ADDR
// bpoints := 1 ;
71088: LD_ADDR_VAR 0 10
71092: PUSH
71093: LD_INT 1
71095: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71096: LD_VAR 0 6
71100: PPUSH
71101: CALL_OW 247
71105: PUSH
71106: LD_INT 1
71108: DOUBLE
71109: EQUAL
71110: IFTRUE 71114
71112: GO 71692
71114: POP
// begin if GetClass ( i ) = 1 then
71115: LD_VAR 0 6
71119: PPUSH
71120: CALL_OW 257
71124: PUSH
71125: LD_INT 1
71127: EQUAL
71128: IFFALSE 71149
// points := [ 10 , 5 , 3 ] ;
71130: LD_ADDR_VAR 0 9
71134: PUSH
71135: LD_INT 10
71137: PUSH
71138: LD_INT 5
71140: PUSH
71141: LD_INT 3
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: LIST
71148: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71149: LD_VAR 0 6
71153: PPUSH
71154: CALL_OW 257
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 3
71164: PUSH
71165: LD_INT 4
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: LIST
71172: IN
71173: IFFALSE 71194
// points := [ 3 , 2 , 1 ] ;
71175: LD_ADDR_VAR 0 9
71179: PUSH
71180: LD_INT 3
71182: PUSH
71183: LD_INT 2
71185: PUSH
71186: LD_INT 1
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: LIST
71193: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71194: LD_VAR 0 6
71198: PPUSH
71199: CALL_OW 257
71203: PUSH
71204: LD_INT 5
71206: EQUAL
71207: IFFALSE 71228
// points := [ 130 , 5 , 2 ] ;
71209: LD_ADDR_VAR 0 9
71213: PUSH
71214: LD_INT 130
71216: PUSH
71217: LD_INT 5
71219: PUSH
71220: LD_INT 2
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: LIST
71227: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71228: LD_VAR 0 6
71232: PPUSH
71233: CALL_OW 257
71237: PUSH
71238: LD_INT 8
71240: EQUAL
71241: IFFALSE 71262
// points := [ 35 , 35 , 30 ] ;
71243: LD_ADDR_VAR 0 9
71247: PUSH
71248: LD_INT 35
71250: PUSH
71251: LD_INT 35
71253: PUSH
71254: LD_INT 30
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: LIST
71261: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71262: LD_VAR 0 6
71266: PPUSH
71267: CALL_OW 257
71271: PUSH
71272: LD_INT 9
71274: EQUAL
71275: IFFALSE 71296
// points := [ 20 , 55 , 40 ] ;
71277: LD_ADDR_VAR 0 9
71281: PUSH
71282: LD_INT 20
71284: PUSH
71285: LD_INT 55
71287: PUSH
71288: LD_INT 40
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: LIST
71295: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71296: LD_VAR 0 6
71300: PPUSH
71301: CALL_OW 257
71305: PUSH
71306: LD_INT 12
71308: PUSH
71309: LD_INT 16
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: IN
71316: IFFALSE 71337
// points := [ 5 , 3 , 2 ] ;
71318: LD_ADDR_VAR 0 9
71322: PUSH
71323: LD_INT 5
71325: PUSH
71326: LD_INT 3
71328: PUSH
71329: LD_INT 2
71331: PUSH
71332: EMPTY
71333: LIST
71334: LIST
71335: LIST
71336: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71337: LD_VAR 0 6
71341: PPUSH
71342: CALL_OW 257
71346: PUSH
71347: LD_INT 17
71349: EQUAL
71350: IFFALSE 71371
// points := [ 100 , 50 , 75 ] ;
71352: LD_ADDR_VAR 0 9
71356: PUSH
71357: LD_INT 100
71359: PUSH
71360: LD_INT 50
71362: PUSH
71363: LD_INT 75
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: LIST
71370: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71371: LD_VAR 0 6
71375: PPUSH
71376: CALL_OW 257
71380: PUSH
71381: LD_INT 15
71383: EQUAL
71384: IFFALSE 71405
// points := [ 10 , 5 , 3 ] ;
71386: LD_ADDR_VAR 0 9
71390: PUSH
71391: LD_INT 10
71393: PUSH
71394: LD_INT 5
71396: PUSH
71397: LD_INT 3
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: LIST
71404: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71405: LD_VAR 0 6
71409: PPUSH
71410: CALL_OW 257
71414: PUSH
71415: LD_INT 14
71417: EQUAL
71418: IFFALSE 71439
// points := [ 10 , 0 , 0 ] ;
71420: LD_ADDR_VAR 0 9
71424: PUSH
71425: LD_INT 10
71427: PUSH
71428: LD_INT 0
71430: PUSH
71431: LD_INT 0
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: LIST
71438: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71439: LD_VAR 0 6
71443: PPUSH
71444: CALL_OW 257
71448: PUSH
71449: LD_INT 11
71451: EQUAL
71452: IFFALSE 71473
// points := [ 30 , 10 , 5 ] ;
71454: LD_ADDR_VAR 0 9
71458: PUSH
71459: LD_INT 30
71461: PUSH
71462: LD_INT 10
71464: PUSH
71465: LD_INT 5
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: LIST
71472: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71473: LD_VAR 0 1
71477: PPUSH
71478: LD_INT 5
71480: PPUSH
71481: CALL_OW 321
71485: PUSH
71486: LD_INT 2
71488: EQUAL
71489: IFFALSE 71506
// bpoints := bpoints * 1.8 ;
71491: LD_ADDR_VAR 0 10
71495: PUSH
71496: LD_VAR 0 10
71500: PUSH
71501: LD_REAL  1.80000000000000E+0000
71504: MUL
71505: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71506: LD_VAR 0 6
71510: PPUSH
71511: CALL_OW 257
71515: PUSH
71516: LD_INT 1
71518: PUSH
71519: LD_INT 2
71521: PUSH
71522: LD_INT 3
71524: PUSH
71525: LD_INT 4
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: IN
71534: PUSH
71535: LD_VAR 0 1
71539: PPUSH
71540: LD_INT 51
71542: PPUSH
71543: CALL_OW 321
71547: PUSH
71548: LD_INT 2
71550: EQUAL
71551: AND
71552: IFFALSE 71569
// bpoints := bpoints * 1.2 ;
71554: LD_ADDR_VAR 0 10
71558: PUSH
71559: LD_VAR 0 10
71563: PUSH
71564: LD_REAL  1.20000000000000E+0000
71567: MUL
71568: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71569: LD_VAR 0 6
71573: PPUSH
71574: CALL_OW 257
71578: PUSH
71579: LD_INT 5
71581: PUSH
71582: LD_INT 7
71584: PUSH
71585: LD_INT 9
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: LIST
71592: IN
71593: PUSH
71594: LD_VAR 0 1
71598: PPUSH
71599: LD_INT 52
71601: PPUSH
71602: CALL_OW 321
71606: PUSH
71607: LD_INT 2
71609: EQUAL
71610: AND
71611: IFFALSE 71628
// bpoints := bpoints * 1.5 ;
71613: LD_ADDR_VAR 0 10
71617: PUSH
71618: LD_VAR 0 10
71622: PUSH
71623: LD_REAL  1.50000000000000E+0000
71626: MUL
71627: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71628: LD_VAR 0 1
71632: PPUSH
71633: LD_INT 66
71635: PPUSH
71636: CALL_OW 321
71640: PUSH
71641: LD_INT 2
71643: EQUAL
71644: IFFALSE 71661
// bpoints := bpoints * 1.1 ;
71646: LD_ADDR_VAR 0 10
71650: PUSH
71651: LD_VAR 0 10
71655: PUSH
71656: LD_REAL  1.10000000000000E+0000
71659: MUL
71660: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71661: LD_ADDR_VAR 0 10
71665: PUSH
71666: LD_VAR 0 10
71670: PUSH
71671: LD_VAR 0 6
71675: PPUSH
71676: LD_INT 1
71678: PPUSH
71679: CALL_OW 259
71683: PUSH
71684: LD_REAL  1.15000000000000E+0000
71687: MUL
71688: MUL
71689: ST_TO_ADDR
// end ; unit_vehicle :
71690: GO 72514
71692: LD_INT 2
71694: DOUBLE
71695: EQUAL
71696: IFTRUE 71700
71698: GO 72502
71700: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71701: LD_VAR 0 6
71705: PPUSH
71706: CALL_OW 264
71710: PUSH
71711: LD_INT 2
71713: PUSH
71714: LD_INT 42
71716: PUSH
71717: LD_INT 24
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: LIST
71724: IN
71725: IFFALSE 71746
// points := [ 25 , 5 , 3 ] ;
71727: LD_ADDR_VAR 0 9
71731: PUSH
71732: LD_INT 25
71734: PUSH
71735: LD_INT 5
71737: PUSH
71738: LD_INT 3
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: LIST
71745: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71746: LD_VAR 0 6
71750: PPUSH
71751: CALL_OW 264
71755: PUSH
71756: LD_INT 4
71758: PUSH
71759: LD_INT 43
71761: PUSH
71762: LD_INT 25
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: LIST
71769: IN
71770: IFFALSE 71791
// points := [ 40 , 15 , 5 ] ;
71772: LD_ADDR_VAR 0 9
71776: PUSH
71777: LD_INT 40
71779: PUSH
71780: LD_INT 15
71782: PUSH
71783: LD_INT 5
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: LIST
71790: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71791: LD_VAR 0 6
71795: PPUSH
71796: CALL_OW 264
71800: PUSH
71801: LD_INT 3
71803: PUSH
71804: LD_INT 23
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: IN
71811: IFFALSE 71832
// points := [ 7 , 25 , 8 ] ;
71813: LD_ADDR_VAR 0 9
71817: PUSH
71818: LD_INT 7
71820: PUSH
71821: LD_INT 25
71823: PUSH
71824: LD_INT 8
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: LIST
71831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71832: LD_VAR 0 6
71836: PPUSH
71837: CALL_OW 264
71841: PUSH
71842: LD_INT 5
71844: PUSH
71845: LD_INT 27
71847: PUSH
71848: LD_INT 44
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: LIST
71855: IN
71856: IFFALSE 71877
// points := [ 14 , 50 , 16 ] ;
71858: LD_ADDR_VAR 0 9
71862: PUSH
71863: LD_INT 14
71865: PUSH
71866: LD_INT 50
71868: PUSH
71869: LD_INT 16
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: LIST
71876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71877: LD_VAR 0 6
71881: PPUSH
71882: CALL_OW 264
71886: PUSH
71887: LD_INT 6
71889: PUSH
71890: LD_INT 46
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: IN
71897: IFFALSE 71918
// points := [ 32 , 120 , 70 ] ;
71899: LD_ADDR_VAR 0 9
71903: PUSH
71904: LD_INT 32
71906: PUSH
71907: LD_INT 120
71909: PUSH
71910: LD_INT 70
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: LIST
71917: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71918: LD_VAR 0 6
71922: PPUSH
71923: CALL_OW 264
71927: PUSH
71928: LD_INT 7
71930: PUSH
71931: LD_INT 28
71933: PUSH
71934: LD_INT 45
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: LIST
71941: IN
71942: IFFALSE 71963
// points := [ 35 , 20 , 45 ] ;
71944: LD_ADDR_VAR 0 9
71948: PUSH
71949: LD_INT 35
71951: PUSH
71952: LD_INT 20
71954: PUSH
71955: LD_INT 45
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: LIST
71962: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71963: LD_VAR 0 6
71967: PPUSH
71968: CALL_OW 264
71972: PUSH
71973: LD_INT 47
71975: PUSH
71976: EMPTY
71977: LIST
71978: IN
71979: IFFALSE 72000
// points := [ 67 , 45 , 75 ] ;
71981: LD_ADDR_VAR 0 9
71985: PUSH
71986: LD_INT 67
71988: PUSH
71989: LD_INT 45
71991: PUSH
71992: LD_INT 75
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: LIST
71999: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72000: LD_VAR 0 6
72004: PPUSH
72005: CALL_OW 264
72009: PUSH
72010: LD_INT 26
72012: PUSH
72013: EMPTY
72014: LIST
72015: IN
72016: IFFALSE 72037
// points := [ 120 , 30 , 80 ] ;
72018: LD_ADDR_VAR 0 9
72022: PUSH
72023: LD_INT 120
72025: PUSH
72026: LD_INT 30
72028: PUSH
72029: LD_INT 80
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: LIST
72036: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72037: LD_VAR 0 6
72041: PPUSH
72042: CALL_OW 264
72046: PUSH
72047: LD_INT 22
72049: PUSH
72050: EMPTY
72051: LIST
72052: IN
72053: IFFALSE 72074
// points := [ 40 , 1 , 1 ] ;
72055: LD_ADDR_VAR 0 9
72059: PUSH
72060: LD_INT 40
72062: PUSH
72063: LD_INT 1
72065: PUSH
72066: LD_INT 1
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: LIST
72073: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72074: LD_VAR 0 6
72078: PPUSH
72079: CALL_OW 264
72083: PUSH
72084: LD_INT 29
72086: PUSH
72087: EMPTY
72088: LIST
72089: IN
72090: IFFALSE 72111
// points := [ 70 , 200 , 400 ] ;
72092: LD_ADDR_VAR 0 9
72096: PUSH
72097: LD_INT 70
72099: PUSH
72100: LD_INT 200
72102: PUSH
72103: LD_INT 400
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72111: LD_VAR 0 6
72115: PPUSH
72116: CALL_OW 264
72120: PUSH
72121: LD_INT 14
72123: PUSH
72124: LD_INT 53
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: IN
72131: IFFALSE 72152
// points := [ 40 , 10 , 20 ] ;
72133: LD_ADDR_VAR 0 9
72137: PUSH
72138: LD_INT 40
72140: PUSH
72141: LD_INT 10
72143: PUSH
72144: LD_INT 20
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: LIST
72151: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72152: LD_VAR 0 6
72156: PPUSH
72157: CALL_OW 264
72161: PUSH
72162: LD_INT 9
72164: PUSH
72165: EMPTY
72166: LIST
72167: IN
72168: IFFALSE 72189
// points := [ 5 , 70 , 20 ] ;
72170: LD_ADDR_VAR 0 9
72174: PUSH
72175: LD_INT 5
72177: PUSH
72178: LD_INT 70
72180: PUSH
72181: LD_INT 20
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: LIST
72188: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72189: LD_VAR 0 6
72193: PPUSH
72194: CALL_OW 264
72198: PUSH
72199: LD_INT 10
72201: PUSH
72202: EMPTY
72203: LIST
72204: IN
72205: IFFALSE 72226
// points := [ 35 , 110 , 70 ] ;
72207: LD_ADDR_VAR 0 9
72211: PUSH
72212: LD_INT 35
72214: PUSH
72215: LD_INT 110
72217: PUSH
72218: LD_INT 70
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: LIST
72225: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72226: LD_VAR 0 6
72230: PPUSH
72231: CALL_OW 265
72235: PUSH
72236: LD_INT 25
72238: EQUAL
72239: IFFALSE 72260
// points := [ 80 , 65 , 100 ] ;
72241: LD_ADDR_VAR 0 9
72245: PUSH
72246: LD_INT 80
72248: PUSH
72249: LD_INT 65
72251: PUSH
72252: LD_INT 100
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: LIST
72259: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72260: LD_VAR 0 6
72264: PPUSH
72265: CALL_OW 263
72269: PUSH
72270: LD_INT 1
72272: EQUAL
72273: IFFALSE 72308
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72275: LD_ADDR_VAR 0 10
72279: PUSH
72280: LD_VAR 0 10
72284: PUSH
72285: LD_VAR 0 6
72289: PPUSH
72290: CALL_OW 311
72294: PPUSH
72295: LD_INT 3
72297: PPUSH
72298: CALL_OW 259
72302: PUSH
72303: LD_INT 4
72305: MUL
72306: MUL
72307: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72308: LD_VAR 0 6
72312: PPUSH
72313: CALL_OW 263
72317: PUSH
72318: LD_INT 2
72320: EQUAL
72321: IFFALSE 72372
// begin j := IsControledBy ( i ) ;
72323: LD_ADDR_VAR 0 7
72327: PUSH
72328: LD_VAR 0 6
72332: PPUSH
72333: CALL_OW 312
72337: ST_TO_ADDR
// if j then
72338: LD_VAR 0 7
72342: IFFALSE 72372
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72344: LD_ADDR_VAR 0 10
72348: PUSH
72349: LD_VAR 0 10
72353: PUSH
72354: LD_VAR 0 7
72358: PPUSH
72359: LD_INT 3
72361: PPUSH
72362: CALL_OW 259
72366: PUSH
72367: LD_INT 3
72369: MUL
72370: MUL
72371: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72372: LD_VAR 0 6
72376: PPUSH
72377: CALL_OW 264
72381: PUSH
72382: LD_INT 5
72384: PUSH
72385: LD_INT 6
72387: PUSH
72388: LD_INT 46
72390: PUSH
72391: LD_INT 44
72393: PUSH
72394: LD_INT 47
72396: PUSH
72397: LD_INT 45
72399: PUSH
72400: LD_INT 28
72402: PUSH
72403: LD_INT 7
72405: PUSH
72406: LD_INT 27
72408: PUSH
72409: LD_INT 29
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: IN
72424: PUSH
72425: LD_VAR 0 1
72429: PPUSH
72430: LD_INT 52
72432: PPUSH
72433: CALL_OW 321
72437: PUSH
72438: LD_INT 2
72440: EQUAL
72441: AND
72442: IFFALSE 72459
// bpoints := bpoints * 1.2 ;
72444: LD_ADDR_VAR 0 10
72448: PUSH
72449: LD_VAR 0 10
72453: PUSH
72454: LD_REAL  1.20000000000000E+0000
72457: MUL
72458: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72459: LD_VAR 0 6
72463: PPUSH
72464: CALL_OW 264
72468: PUSH
72469: LD_INT 6
72471: PUSH
72472: LD_INT 46
72474: PUSH
72475: LD_INT 47
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: LIST
72482: IN
72483: IFFALSE 72500
// bpoints := bpoints * 1.2 ;
72485: LD_ADDR_VAR 0 10
72489: PUSH
72490: LD_VAR 0 10
72494: PUSH
72495: LD_REAL  1.20000000000000E+0000
72498: MUL
72499: ST_TO_ADDR
// end ; unit_building :
72500: GO 72514
72502: LD_INT 3
72504: DOUBLE
72505: EQUAL
72506: IFTRUE 72510
72508: GO 72513
72510: POP
// ; end ;
72511: GO 72514
72513: POP
// for j = 1 to 3 do
72514: LD_ADDR_VAR 0 7
72518: PUSH
72519: DOUBLE
72520: LD_INT 1
72522: DEC
72523: ST_TO_ADDR
72524: LD_INT 3
72526: PUSH
72527: FOR_TO
72528: IFFALSE 72581
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72530: LD_ADDR_VAR 0 5
72534: PUSH
72535: LD_VAR 0 5
72539: PPUSH
72540: LD_VAR 0 7
72544: PPUSH
72545: LD_VAR 0 5
72549: PUSH
72550: LD_VAR 0 7
72554: ARRAY
72555: PUSH
72556: LD_VAR 0 9
72560: PUSH
72561: LD_VAR 0 7
72565: ARRAY
72566: PUSH
72567: LD_VAR 0 10
72571: MUL
72572: PLUS
72573: PPUSH
72574: CALL_OW 1
72578: ST_TO_ADDR
72579: GO 72527
72581: POP
72582: POP
// end ;
72583: GO 71066
72585: POP
72586: POP
// result := Replace ( result , 4 , tmp ) ;
72587: LD_ADDR_VAR 0 5
72591: PUSH
72592: LD_VAR 0 5
72596: PPUSH
72597: LD_INT 4
72599: PPUSH
72600: LD_VAR 0 8
72604: PPUSH
72605: CALL_OW 1
72609: ST_TO_ADDR
// end ;
72610: LD_VAR 0 5
72614: RET
// export function DangerAtRange ( unit , range ) ; begin
72615: LD_INT 0
72617: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72618: LD_ADDR_VAR 0 3
72622: PUSH
72623: LD_VAR 0 1
72627: PPUSH
72628: CALL_OW 255
72632: PPUSH
72633: LD_VAR 0 1
72637: PPUSH
72638: CALL_OW 250
72642: PPUSH
72643: LD_VAR 0 1
72647: PPUSH
72648: CALL_OW 251
72652: PPUSH
72653: LD_VAR 0 2
72657: PPUSH
72658: CALL 70918 0 4
72662: ST_TO_ADDR
// end ;
72663: LD_VAR 0 3
72667: RET
// export function DangerInArea ( side , area ) ; begin
72668: LD_INT 0
72670: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72671: LD_ADDR_VAR 0 3
72675: PUSH
72676: LD_VAR 0 2
72680: PPUSH
72681: LD_INT 81
72683: PUSH
72684: LD_VAR 0 1
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PPUSH
72693: CALL_OW 70
72697: ST_TO_ADDR
// end ;
72698: LD_VAR 0 3
72702: RET
// export function IsExtension ( b ) ; begin
72703: LD_INT 0
72705: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72706: LD_ADDR_VAR 0 2
72710: PUSH
72711: LD_VAR 0 1
72715: PUSH
72716: LD_INT 23
72718: PUSH
72719: LD_INT 20
72721: PUSH
72722: LD_INT 22
72724: PUSH
72725: LD_INT 17
72727: PUSH
72728: LD_INT 24
72730: PUSH
72731: LD_INT 21
72733: PUSH
72734: LD_INT 19
72736: PUSH
72737: LD_INT 16
72739: PUSH
72740: LD_INT 25
72742: PUSH
72743: LD_INT 18
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: IN
72758: ST_TO_ADDR
// end ;
72759: LD_VAR 0 2
72763: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72764: LD_INT 0
72766: PPUSH
72767: PPUSH
72768: PPUSH
// result := [ ] ;
72769: LD_ADDR_VAR 0 3
72773: PUSH
72774: EMPTY
72775: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72776: LD_ADDR_VAR 0 4
72780: PUSH
72781: LD_VAR 0 2
72785: PPUSH
72786: LD_INT 21
72788: PUSH
72789: LD_INT 3
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PPUSH
72796: CALL_OW 70
72800: ST_TO_ADDR
// if not tmp then
72801: LD_VAR 0 4
72805: NOT
72806: IFFALSE 72810
// exit ;
72808: GO 72868
// for i in tmp do
72810: LD_ADDR_VAR 0 5
72814: PUSH
72815: LD_VAR 0 4
72819: PUSH
72820: FOR_IN
72821: IFFALSE 72856
// if GetBase ( i ) <> base then
72823: LD_VAR 0 5
72827: PPUSH
72828: CALL_OW 274
72832: PUSH
72833: LD_VAR 0 1
72837: NONEQUAL
72838: IFFALSE 72854
// ComLinkToBase ( base , i ) ;
72840: LD_VAR 0 1
72844: PPUSH
72845: LD_VAR 0 5
72849: PPUSH
72850: CALL_OW 169
72854: GO 72820
72856: POP
72857: POP
// result := tmp ;
72858: LD_ADDR_VAR 0 3
72862: PUSH
72863: LD_VAR 0 4
72867: ST_TO_ADDR
// end ;
72868: LD_VAR 0 3
72872: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72873: LD_INT 0
72875: PPUSH
72876: PPUSH
// if BuildingStatus ( b ) = bs_build then
72877: LD_VAR 0 2
72881: PPUSH
72882: CALL_OW 461
72886: PUSH
72887: LD_INT 1
72889: EQUAL
72890: IFFALSE 72950
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72892: LD_VAR 0 1
72896: PPUSH
72897: LD_STRING h
72899: PUSH
72900: LD_VAR 0 2
72904: PPUSH
72905: CALL_OW 250
72909: PUSH
72910: LD_VAR 0 2
72914: PPUSH
72915: CALL_OW 251
72919: PUSH
72920: LD_VAR 0 2
72924: PUSH
72925: LD_INT 0
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: LD_INT 0
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: PUSH
72943: EMPTY
72944: LIST
72945: PPUSH
72946: CALL_OW 446
// end ;
72950: LD_VAR 0 3
72954: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72955: LD_INT 0
72957: PPUSH
72958: PPUSH
72959: PPUSH
72960: PPUSH
72961: PPUSH
72962: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72963: LD_VAR 0 1
72967: NOT
72968: PUSH
72969: LD_VAR 0 1
72973: PPUSH
72974: CALL_OW 263
72978: PUSH
72979: LD_INT 2
72981: EQUAL
72982: NOT
72983: OR
72984: IFFALSE 72988
// exit ;
72986: GO 73304
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72988: LD_ADDR_VAR 0 6
72992: PUSH
72993: LD_INT 22
72995: PUSH
72996: LD_VAR 0 1
73000: PPUSH
73001: CALL_OW 255
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: PUSH
73013: LD_INT 30
73015: PUSH
73016: LD_INT 36
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 34
73025: PUSH
73026: LD_INT 31
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: LIST
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PPUSH
73042: CALL_OW 69
73046: ST_TO_ADDR
// if not tmp then
73047: LD_VAR 0 6
73051: NOT
73052: IFFALSE 73056
// exit ;
73054: GO 73304
// result := [ ] ;
73056: LD_ADDR_VAR 0 2
73060: PUSH
73061: EMPTY
73062: ST_TO_ADDR
// for i in tmp do
73063: LD_ADDR_VAR 0 3
73067: PUSH
73068: LD_VAR 0 6
73072: PUSH
73073: FOR_IN
73074: IFFALSE 73145
// begin t := UnitsInside ( i ) ;
73076: LD_ADDR_VAR 0 4
73080: PUSH
73081: LD_VAR 0 3
73085: PPUSH
73086: CALL_OW 313
73090: ST_TO_ADDR
// if t then
73091: LD_VAR 0 4
73095: IFFALSE 73143
// for j in t do
73097: LD_ADDR_VAR 0 7
73101: PUSH
73102: LD_VAR 0 4
73106: PUSH
73107: FOR_IN
73108: IFFALSE 73141
// result := Insert ( result , result + 1 , j ) ;
73110: LD_ADDR_VAR 0 2
73114: PUSH
73115: LD_VAR 0 2
73119: PPUSH
73120: LD_VAR 0 2
73124: PUSH
73125: LD_INT 1
73127: PLUS
73128: PPUSH
73129: LD_VAR 0 7
73133: PPUSH
73134: CALL_OW 2
73138: ST_TO_ADDR
73139: GO 73107
73141: POP
73142: POP
// end ;
73143: GO 73073
73145: POP
73146: POP
// if not result then
73147: LD_VAR 0 2
73151: NOT
73152: IFFALSE 73156
// exit ;
73154: GO 73304
// mech := result [ 1 ] ;
73156: LD_ADDR_VAR 0 5
73160: PUSH
73161: LD_VAR 0 2
73165: PUSH
73166: LD_INT 1
73168: ARRAY
73169: ST_TO_ADDR
// if result > 1 then
73170: LD_VAR 0 2
73174: PUSH
73175: LD_INT 1
73177: GREATER
73178: IFFALSE 73290
// for i = 2 to result do
73180: LD_ADDR_VAR 0 3
73184: PUSH
73185: DOUBLE
73186: LD_INT 2
73188: DEC
73189: ST_TO_ADDR
73190: LD_VAR 0 2
73194: PUSH
73195: FOR_TO
73196: IFFALSE 73288
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73198: LD_ADDR_VAR 0 4
73202: PUSH
73203: LD_VAR 0 2
73207: PUSH
73208: LD_VAR 0 3
73212: ARRAY
73213: PPUSH
73214: LD_INT 3
73216: PPUSH
73217: CALL_OW 259
73221: PUSH
73222: LD_VAR 0 2
73226: PUSH
73227: LD_VAR 0 3
73231: ARRAY
73232: PPUSH
73233: CALL_OW 432
73237: MINUS
73238: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73239: LD_VAR 0 4
73243: PUSH
73244: LD_VAR 0 5
73248: PPUSH
73249: LD_INT 3
73251: PPUSH
73252: CALL_OW 259
73256: PUSH
73257: LD_VAR 0 5
73261: PPUSH
73262: CALL_OW 432
73266: MINUS
73267: GREATEREQUAL
73268: IFFALSE 73286
// mech := result [ i ] ;
73270: LD_ADDR_VAR 0 5
73274: PUSH
73275: LD_VAR 0 2
73279: PUSH
73280: LD_VAR 0 3
73284: ARRAY
73285: ST_TO_ADDR
// end ;
73286: GO 73195
73288: POP
73289: POP
// ComLinkTo ( vehicle , mech ) ;
73290: LD_VAR 0 1
73294: PPUSH
73295: LD_VAR 0 5
73299: PPUSH
73300: CALL_OW 135
// end ;
73304: LD_VAR 0 2
73308: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73309: LD_INT 0
73311: PPUSH
73312: PPUSH
73313: PPUSH
73314: PPUSH
73315: PPUSH
73316: PPUSH
73317: PPUSH
73318: PPUSH
73319: PPUSH
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
// result := [ ] ;
73324: LD_ADDR_VAR 0 7
73328: PUSH
73329: EMPTY
73330: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73331: LD_VAR 0 1
73335: PPUSH
73336: CALL_OW 266
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: LD_INT 1
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: IN
73351: NOT
73352: IFFALSE 73356
// exit ;
73354: GO 74987
// if name then
73356: LD_VAR 0 3
73360: IFFALSE 73376
// SetBName ( base_dep , name ) ;
73362: LD_VAR 0 1
73366: PPUSH
73367: LD_VAR 0 3
73371: PPUSH
73372: CALL_OW 500
// base := GetBase ( base_dep ) ;
73376: LD_ADDR_VAR 0 15
73380: PUSH
73381: LD_VAR 0 1
73385: PPUSH
73386: CALL_OW 274
73390: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73391: LD_ADDR_VAR 0 16
73395: PUSH
73396: LD_VAR 0 1
73400: PPUSH
73401: CALL_OW 255
73405: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73406: LD_ADDR_VAR 0 17
73410: PUSH
73411: LD_VAR 0 1
73415: PPUSH
73416: CALL_OW 248
73420: ST_TO_ADDR
// if sources then
73421: LD_VAR 0 5
73425: IFFALSE 73472
// for i = 1 to 3 do
73427: LD_ADDR_VAR 0 8
73431: PUSH
73432: DOUBLE
73433: LD_INT 1
73435: DEC
73436: ST_TO_ADDR
73437: LD_INT 3
73439: PUSH
73440: FOR_TO
73441: IFFALSE 73470
// AddResourceType ( base , i , sources [ i ] ) ;
73443: LD_VAR 0 15
73447: PPUSH
73448: LD_VAR 0 8
73452: PPUSH
73453: LD_VAR 0 5
73457: PUSH
73458: LD_VAR 0 8
73462: ARRAY
73463: PPUSH
73464: CALL_OW 276
73468: GO 73440
73470: POP
73471: POP
// buildings := GetBaseBuildings ( base , area ) ;
73472: LD_ADDR_VAR 0 18
73476: PUSH
73477: LD_VAR 0 15
73481: PPUSH
73482: LD_VAR 0 2
73486: PPUSH
73487: CALL 72764 0 2
73491: ST_TO_ADDR
// InitHc ;
73492: CALL_OW 19
// InitUc ;
73496: CALL_OW 18
// uc_side := side ;
73500: LD_ADDR_OWVAR 20
73504: PUSH
73505: LD_VAR 0 16
73509: ST_TO_ADDR
// uc_nation := nation ;
73510: LD_ADDR_OWVAR 21
73514: PUSH
73515: LD_VAR 0 17
73519: ST_TO_ADDR
// if buildings then
73520: LD_VAR 0 18
73524: IFFALSE 74846
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73526: LD_ADDR_VAR 0 19
73530: PUSH
73531: LD_VAR 0 18
73535: PPUSH
73536: LD_INT 2
73538: PUSH
73539: LD_INT 30
73541: PUSH
73542: LD_INT 29
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 30
73551: PUSH
73552: LD_INT 30
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: LIST
73563: PPUSH
73564: CALL_OW 72
73568: ST_TO_ADDR
// if tmp then
73569: LD_VAR 0 19
73573: IFFALSE 73621
// for i in tmp do
73575: LD_ADDR_VAR 0 8
73579: PUSH
73580: LD_VAR 0 19
73584: PUSH
73585: FOR_IN
73586: IFFALSE 73619
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73588: LD_VAR 0 8
73592: PPUSH
73593: CALL_OW 250
73597: PPUSH
73598: LD_VAR 0 8
73602: PPUSH
73603: CALL_OW 251
73607: PPUSH
73608: LD_VAR 0 16
73612: PPUSH
73613: CALL_OW 441
73617: GO 73585
73619: POP
73620: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73621: LD_VAR 0 18
73625: PPUSH
73626: LD_INT 2
73628: PUSH
73629: LD_INT 30
73631: PUSH
73632: LD_INT 32
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 30
73641: PUSH
73642: LD_INT 33
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: LIST
73653: PPUSH
73654: CALL_OW 72
73658: IFFALSE 73746
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73660: LD_ADDR_VAR 0 8
73664: PUSH
73665: LD_VAR 0 18
73669: PPUSH
73670: LD_INT 2
73672: PUSH
73673: LD_INT 30
73675: PUSH
73676: LD_INT 32
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 30
73685: PUSH
73686: LD_INT 33
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: LIST
73697: PPUSH
73698: CALL_OW 72
73702: PUSH
73703: FOR_IN
73704: IFFALSE 73744
// begin if not GetBWeapon ( i ) then
73706: LD_VAR 0 8
73710: PPUSH
73711: CALL_OW 269
73715: NOT
73716: IFFALSE 73742
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73718: LD_VAR 0 8
73722: PPUSH
73723: LD_VAR 0 8
73727: PPUSH
73728: LD_VAR 0 2
73732: PPUSH
73733: CALL 74992 0 2
73737: PPUSH
73738: CALL_OW 431
// end ;
73742: GO 73703
73744: POP
73745: POP
// end ; for i = 1 to personel do
73746: LD_ADDR_VAR 0 8
73750: PUSH
73751: DOUBLE
73752: LD_INT 1
73754: DEC
73755: ST_TO_ADDR
73756: LD_VAR 0 6
73760: PUSH
73761: FOR_TO
73762: IFFALSE 74826
// begin if i > 4 then
73764: LD_VAR 0 8
73768: PUSH
73769: LD_INT 4
73771: GREATER
73772: IFFALSE 73776
// break ;
73774: GO 74826
// case i of 1 :
73776: LD_VAR 0 8
73780: PUSH
73781: LD_INT 1
73783: DOUBLE
73784: EQUAL
73785: IFTRUE 73789
73787: GO 73869
73789: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73790: LD_ADDR_VAR 0 12
73794: PUSH
73795: LD_VAR 0 18
73799: PPUSH
73800: LD_INT 22
73802: PUSH
73803: LD_VAR 0 16
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 58
73814: PUSH
73815: EMPTY
73816: LIST
73817: PUSH
73818: LD_INT 2
73820: PUSH
73821: LD_INT 30
73823: PUSH
73824: LD_INT 32
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 30
73833: PUSH
73834: LD_INT 4
73836: PUSH
73837: EMPTY
73838: LIST
73839: LIST
73840: PUSH
73841: LD_INT 30
73843: PUSH
73844: LD_INT 5
73846: PUSH
73847: EMPTY
73848: LIST
73849: LIST
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: LIST
73861: PPUSH
73862: CALL_OW 72
73866: ST_TO_ADDR
73867: GO 74091
73869: LD_INT 2
73871: DOUBLE
73872: EQUAL
73873: IFTRUE 73877
73875: GO 73939
73877: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73878: LD_ADDR_VAR 0 12
73882: PUSH
73883: LD_VAR 0 18
73887: PPUSH
73888: LD_INT 22
73890: PUSH
73891: LD_VAR 0 16
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 2
73902: PUSH
73903: LD_INT 30
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 30
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PPUSH
73932: CALL_OW 72
73936: ST_TO_ADDR
73937: GO 74091
73939: LD_INT 3
73941: DOUBLE
73942: EQUAL
73943: IFTRUE 73947
73945: GO 74009
73947: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73948: LD_ADDR_VAR 0 12
73952: PUSH
73953: LD_VAR 0 18
73957: PPUSH
73958: LD_INT 22
73960: PUSH
73961: LD_VAR 0 16
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 2
73972: PUSH
73973: LD_INT 30
73975: PUSH
73976: LD_INT 2
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 30
73985: PUSH
73986: LD_INT 3
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: LIST
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PPUSH
74002: CALL_OW 72
74006: ST_TO_ADDR
74007: GO 74091
74009: LD_INT 4
74011: DOUBLE
74012: EQUAL
74013: IFTRUE 74017
74015: GO 74090
74017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74018: LD_ADDR_VAR 0 12
74022: PUSH
74023: LD_VAR 0 18
74027: PPUSH
74028: LD_INT 22
74030: PUSH
74031: LD_VAR 0 16
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: LD_INT 30
74045: PUSH
74046: LD_INT 6
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 30
74055: PUSH
74056: LD_INT 7
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 30
74065: PUSH
74066: LD_INT 8
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PPUSH
74083: CALL_OW 72
74087: ST_TO_ADDR
74088: GO 74091
74090: POP
// if i = 1 then
74091: LD_VAR 0 8
74095: PUSH
74096: LD_INT 1
74098: EQUAL
74099: IFFALSE 74210
// begin tmp := [ ] ;
74101: LD_ADDR_VAR 0 19
74105: PUSH
74106: EMPTY
74107: ST_TO_ADDR
// for j in f do
74108: LD_ADDR_VAR 0 9
74112: PUSH
74113: LD_VAR 0 12
74117: PUSH
74118: FOR_IN
74119: IFFALSE 74192
// if GetBType ( j ) = b_bunker then
74121: LD_VAR 0 9
74125: PPUSH
74126: CALL_OW 266
74130: PUSH
74131: LD_INT 32
74133: EQUAL
74134: IFFALSE 74161
// tmp := Insert ( tmp , 1 , j ) else
74136: LD_ADDR_VAR 0 19
74140: PUSH
74141: LD_VAR 0 19
74145: PPUSH
74146: LD_INT 1
74148: PPUSH
74149: LD_VAR 0 9
74153: PPUSH
74154: CALL_OW 2
74158: ST_TO_ADDR
74159: GO 74190
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74161: LD_ADDR_VAR 0 19
74165: PUSH
74166: LD_VAR 0 19
74170: PPUSH
74171: LD_VAR 0 19
74175: PUSH
74176: LD_INT 1
74178: PLUS
74179: PPUSH
74180: LD_VAR 0 9
74184: PPUSH
74185: CALL_OW 2
74189: ST_TO_ADDR
74190: GO 74118
74192: POP
74193: POP
// if tmp then
74194: LD_VAR 0 19
74198: IFFALSE 74210
// f := tmp ;
74200: LD_ADDR_VAR 0 12
74204: PUSH
74205: LD_VAR 0 19
74209: ST_TO_ADDR
// end ; x := personel [ i ] ;
74210: LD_ADDR_VAR 0 13
74214: PUSH
74215: LD_VAR 0 6
74219: PUSH
74220: LD_VAR 0 8
74224: ARRAY
74225: ST_TO_ADDR
// if x = - 1 then
74226: LD_VAR 0 13
74230: PUSH
74231: LD_INT 1
74233: NEG
74234: EQUAL
74235: IFFALSE 74444
// begin for j in f do
74237: LD_ADDR_VAR 0 9
74241: PUSH
74242: LD_VAR 0 12
74246: PUSH
74247: FOR_IN
74248: IFFALSE 74440
// repeat InitHc ;
74250: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74254: LD_VAR 0 9
74258: PPUSH
74259: CALL_OW 266
74263: PUSH
74264: LD_INT 5
74266: EQUAL
74267: IFFALSE 74337
// begin if UnitsInside ( j ) < 3 then
74269: LD_VAR 0 9
74273: PPUSH
74274: CALL_OW 313
74278: PUSH
74279: LD_INT 3
74281: LESS
74282: IFFALSE 74318
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74284: LD_INT 0
74286: PPUSH
74287: LD_INT 5
74289: PUSH
74290: LD_INT 8
74292: PUSH
74293: LD_INT 9
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: LIST
74300: PUSH
74301: LD_VAR 0 17
74305: ARRAY
74306: PPUSH
74307: LD_VAR 0 4
74311: PPUSH
74312: CALL_OW 380
74316: GO 74335
// PrepareHuman ( false , i , skill ) ;
74318: LD_INT 0
74320: PPUSH
74321: LD_VAR 0 8
74325: PPUSH
74326: LD_VAR 0 4
74330: PPUSH
74331: CALL_OW 380
// end else
74335: GO 74354
// PrepareHuman ( false , i , skill ) ;
74337: LD_INT 0
74339: PPUSH
74340: LD_VAR 0 8
74344: PPUSH
74345: LD_VAR 0 4
74349: PPUSH
74350: CALL_OW 380
// un := CreateHuman ;
74354: LD_ADDR_VAR 0 14
74358: PUSH
74359: CALL_OW 44
74363: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74364: LD_ADDR_VAR 0 7
74368: PUSH
74369: LD_VAR 0 7
74373: PPUSH
74374: LD_INT 1
74376: PPUSH
74377: LD_VAR 0 14
74381: PPUSH
74382: CALL_OW 2
74386: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74387: LD_VAR 0 14
74391: PPUSH
74392: LD_VAR 0 9
74396: PPUSH
74397: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74401: LD_VAR 0 9
74405: PPUSH
74406: CALL_OW 313
74410: PUSH
74411: LD_INT 6
74413: EQUAL
74414: PUSH
74415: LD_VAR 0 9
74419: PPUSH
74420: CALL_OW 266
74424: PUSH
74425: LD_INT 32
74427: PUSH
74428: LD_INT 31
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: IN
74435: OR
74436: IFFALSE 74250
74438: GO 74247
74440: POP
74441: POP
// end else
74442: GO 74824
// for j = 1 to x do
74444: LD_ADDR_VAR 0 9
74448: PUSH
74449: DOUBLE
74450: LD_INT 1
74452: DEC
74453: ST_TO_ADDR
74454: LD_VAR 0 13
74458: PUSH
74459: FOR_TO
74460: IFFALSE 74822
// begin InitHc ;
74462: CALL_OW 19
// if not f then
74466: LD_VAR 0 12
74470: NOT
74471: IFFALSE 74560
// begin PrepareHuman ( false , i , skill ) ;
74473: LD_INT 0
74475: PPUSH
74476: LD_VAR 0 8
74480: PPUSH
74481: LD_VAR 0 4
74485: PPUSH
74486: CALL_OW 380
// un := CreateHuman ;
74490: LD_ADDR_VAR 0 14
74494: PUSH
74495: CALL_OW 44
74499: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74500: LD_ADDR_VAR 0 7
74504: PUSH
74505: LD_VAR 0 7
74509: PPUSH
74510: LD_INT 1
74512: PPUSH
74513: LD_VAR 0 14
74517: PPUSH
74518: CALL_OW 2
74522: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74523: LD_VAR 0 14
74527: PPUSH
74528: LD_VAR 0 1
74532: PPUSH
74533: CALL_OW 250
74537: PPUSH
74538: LD_VAR 0 1
74542: PPUSH
74543: CALL_OW 251
74547: PPUSH
74548: LD_INT 10
74550: PPUSH
74551: LD_INT 0
74553: PPUSH
74554: CALL_OW 50
// continue ;
74558: GO 74459
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74560: LD_VAR 0 12
74564: PUSH
74565: LD_INT 1
74567: ARRAY
74568: PPUSH
74569: CALL_OW 313
74573: PUSH
74574: LD_VAR 0 12
74578: PUSH
74579: LD_INT 1
74581: ARRAY
74582: PPUSH
74583: CALL_OW 266
74587: PUSH
74588: LD_INT 32
74590: PUSH
74591: LD_INT 31
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: IN
74598: AND
74599: PUSH
74600: LD_VAR 0 12
74604: PUSH
74605: LD_INT 1
74607: ARRAY
74608: PPUSH
74609: CALL_OW 313
74613: PUSH
74614: LD_INT 6
74616: EQUAL
74617: OR
74618: IFFALSE 74638
// f := Delete ( f , 1 ) ;
74620: LD_ADDR_VAR 0 12
74624: PUSH
74625: LD_VAR 0 12
74629: PPUSH
74630: LD_INT 1
74632: PPUSH
74633: CALL_OW 3
74637: ST_TO_ADDR
// if not f then
74638: LD_VAR 0 12
74642: NOT
74643: IFFALSE 74661
// begin x := x + 2 ;
74645: LD_ADDR_VAR 0 13
74649: PUSH
74650: LD_VAR 0 13
74654: PUSH
74655: LD_INT 2
74657: PLUS
74658: ST_TO_ADDR
// continue ;
74659: GO 74459
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74661: LD_VAR 0 12
74665: PUSH
74666: LD_INT 1
74668: ARRAY
74669: PPUSH
74670: CALL_OW 266
74674: PUSH
74675: LD_INT 5
74677: EQUAL
74678: IFFALSE 74752
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74680: LD_VAR 0 12
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PPUSH
74689: CALL_OW 313
74693: PUSH
74694: LD_INT 3
74696: LESS
74697: IFFALSE 74733
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74699: LD_INT 0
74701: PPUSH
74702: LD_INT 5
74704: PUSH
74705: LD_INT 8
74707: PUSH
74708: LD_INT 9
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: LIST
74715: PUSH
74716: LD_VAR 0 17
74720: ARRAY
74721: PPUSH
74722: LD_VAR 0 4
74726: PPUSH
74727: CALL_OW 380
74731: GO 74750
// PrepareHuman ( false , i , skill ) ;
74733: LD_INT 0
74735: PPUSH
74736: LD_VAR 0 8
74740: PPUSH
74741: LD_VAR 0 4
74745: PPUSH
74746: CALL_OW 380
// end else
74750: GO 74769
// PrepareHuman ( false , i , skill ) ;
74752: LD_INT 0
74754: PPUSH
74755: LD_VAR 0 8
74759: PPUSH
74760: LD_VAR 0 4
74764: PPUSH
74765: CALL_OW 380
// un := CreateHuman ;
74769: LD_ADDR_VAR 0 14
74773: PUSH
74774: CALL_OW 44
74778: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74779: LD_ADDR_VAR 0 7
74783: PUSH
74784: LD_VAR 0 7
74788: PPUSH
74789: LD_INT 1
74791: PPUSH
74792: LD_VAR 0 14
74796: PPUSH
74797: CALL_OW 2
74801: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74802: LD_VAR 0 14
74806: PPUSH
74807: LD_VAR 0 12
74811: PUSH
74812: LD_INT 1
74814: ARRAY
74815: PPUSH
74816: CALL_OW 52
// end ;
74820: GO 74459
74822: POP
74823: POP
// end ;
74824: GO 73761
74826: POP
74827: POP
// result := result ^ buildings ;
74828: LD_ADDR_VAR 0 7
74832: PUSH
74833: LD_VAR 0 7
74837: PUSH
74838: LD_VAR 0 18
74842: ADD
74843: ST_TO_ADDR
// end else
74844: GO 74987
// begin for i = 1 to personel do
74846: LD_ADDR_VAR 0 8
74850: PUSH
74851: DOUBLE
74852: LD_INT 1
74854: DEC
74855: ST_TO_ADDR
74856: LD_VAR 0 6
74860: PUSH
74861: FOR_TO
74862: IFFALSE 74985
// begin if i > 4 then
74864: LD_VAR 0 8
74868: PUSH
74869: LD_INT 4
74871: GREATER
74872: IFFALSE 74876
// break ;
74874: GO 74985
// x := personel [ i ] ;
74876: LD_ADDR_VAR 0 13
74880: PUSH
74881: LD_VAR 0 6
74885: PUSH
74886: LD_VAR 0 8
74890: ARRAY
74891: ST_TO_ADDR
// if x = - 1 then
74892: LD_VAR 0 13
74896: PUSH
74897: LD_INT 1
74899: NEG
74900: EQUAL
74901: IFFALSE 74905
// continue ;
74903: GO 74861
// PrepareHuman ( false , i , skill ) ;
74905: LD_INT 0
74907: PPUSH
74908: LD_VAR 0 8
74912: PPUSH
74913: LD_VAR 0 4
74917: PPUSH
74918: CALL_OW 380
// un := CreateHuman ;
74922: LD_ADDR_VAR 0 14
74926: PUSH
74927: CALL_OW 44
74931: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74932: LD_VAR 0 14
74936: PPUSH
74937: LD_VAR 0 1
74941: PPUSH
74942: CALL_OW 250
74946: PPUSH
74947: LD_VAR 0 1
74951: PPUSH
74952: CALL_OW 251
74956: PPUSH
74957: LD_INT 10
74959: PPUSH
74960: LD_INT 0
74962: PPUSH
74963: CALL_OW 50
// result := result ^ un ;
74967: LD_ADDR_VAR 0 7
74971: PUSH
74972: LD_VAR 0 7
74976: PUSH
74977: LD_VAR 0 14
74981: ADD
74982: ST_TO_ADDR
// end ;
74983: GO 74861
74985: POP
74986: POP
// end ; end ;
74987: LD_VAR 0 7
74991: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74992: LD_INT 0
74994: PPUSH
74995: PPUSH
74996: PPUSH
74997: PPUSH
74998: PPUSH
74999: PPUSH
75000: PPUSH
75001: PPUSH
75002: PPUSH
75003: PPUSH
75004: PPUSH
75005: PPUSH
75006: PPUSH
75007: PPUSH
75008: PPUSH
75009: PPUSH
// result := false ;
75010: LD_ADDR_VAR 0 3
75014: PUSH
75015: LD_INT 0
75017: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75018: LD_VAR 0 1
75022: NOT
75023: PUSH
75024: LD_VAR 0 1
75028: PPUSH
75029: CALL_OW 266
75033: PUSH
75034: LD_INT 32
75036: PUSH
75037: LD_INT 33
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: IN
75044: NOT
75045: OR
75046: IFFALSE 75050
// exit ;
75048: GO 76186
// nat := GetNation ( tower ) ;
75050: LD_ADDR_VAR 0 12
75054: PUSH
75055: LD_VAR 0 1
75059: PPUSH
75060: CALL_OW 248
75064: ST_TO_ADDR
// side := GetSide ( tower ) ;
75065: LD_ADDR_VAR 0 16
75069: PUSH
75070: LD_VAR 0 1
75074: PPUSH
75075: CALL_OW 255
75079: ST_TO_ADDR
// x := GetX ( tower ) ;
75080: LD_ADDR_VAR 0 10
75084: PUSH
75085: LD_VAR 0 1
75089: PPUSH
75090: CALL_OW 250
75094: ST_TO_ADDR
// y := GetY ( tower ) ;
75095: LD_ADDR_VAR 0 11
75099: PUSH
75100: LD_VAR 0 1
75104: PPUSH
75105: CALL_OW 251
75109: ST_TO_ADDR
// if not x or not y then
75110: LD_VAR 0 10
75114: NOT
75115: PUSH
75116: LD_VAR 0 11
75120: NOT
75121: OR
75122: IFFALSE 75126
// exit ;
75124: GO 76186
// weapon := 0 ;
75126: LD_ADDR_VAR 0 18
75130: PUSH
75131: LD_INT 0
75133: ST_TO_ADDR
// fac_list := [ ] ;
75134: LD_ADDR_VAR 0 17
75138: PUSH
75139: EMPTY
75140: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75141: LD_ADDR_VAR 0 6
75145: PUSH
75146: LD_VAR 0 1
75150: PPUSH
75151: CALL_OW 274
75155: PPUSH
75156: LD_VAR 0 2
75160: PPUSH
75161: CALL 72764 0 2
75165: PPUSH
75166: LD_INT 30
75168: PUSH
75169: LD_INT 3
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PPUSH
75176: CALL_OW 72
75180: ST_TO_ADDR
// if not factories then
75181: LD_VAR 0 6
75185: NOT
75186: IFFALSE 75190
// exit ;
75188: GO 76186
// for i in factories do
75190: LD_ADDR_VAR 0 8
75194: PUSH
75195: LD_VAR 0 6
75199: PUSH
75200: FOR_IN
75201: IFFALSE 75226
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75203: LD_ADDR_VAR 0 17
75207: PUSH
75208: LD_VAR 0 17
75212: PUSH
75213: LD_VAR 0 8
75217: PPUSH
75218: CALL_OW 478
75222: UNION
75223: ST_TO_ADDR
75224: GO 75200
75226: POP
75227: POP
// if not fac_list then
75228: LD_VAR 0 17
75232: NOT
75233: IFFALSE 75237
// exit ;
75235: GO 76186
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75237: LD_ADDR_VAR 0 5
75241: PUSH
75242: LD_INT 4
75244: PUSH
75245: LD_INT 5
75247: PUSH
75248: LD_INT 9
75250: PUSH
75251: LD_INT 10
75253: PUSH
75254: LD_INT 6
75256: PUSH
75257: LD_INT 7
75259: PUSH
75260: LD_INT 11
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 27
75274: PUSH
75275: LD_INT 28
75277: PUSH
75278: LD_INT 26
75280: PUSH
75281: LD_INT 30
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 43
75292: PUSH
75293: LD_INT 44
75295: PUSH
75296: LD_INT 46
75298: PUSH
75299: LD_INT 45
75301: PUSH
75302: LD_INT 47
75304: PUSH
75305: LD_INT 49
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: LIST
75320: PUSH
75321: LD_VAR 0 12
75325: ARRAY
75326: ST_TO_ADDR
// for i in list do
75327: LD_ADDR_VAR 0 8
75331: PUSH
75332: LD_VAR 0 5
75336: PUSH
75337: FOR_IN
75338: IFFALSE 75371
// if not i in fac_list then
75340: LD_VAR 0 8
75344: PUSH
75345: LD_VAR 0 17
75349: IN
75350: NOT
75351: IFFALSE 75369
// list := list diff i ;
75353: LD_ADDR_VAR 0 5
75357: PUSH
75358: LD_VAR 0 5
75362: PUSH
75363: LD_VAR 0 8
75367: DIFF
75368: ST_TO_ADDR
75369: GO 75337
75371: POP
75372: POP
// if not list then
75373: LD_VAR 0 5
75377: NOT
75378: IFFALSE 75382
// exit ;
75380: GO 76186
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75382: LD_VAR 0 12
75386: PUSH
75387: LD_INT 3
75389: EQUAL
75390: PUSH
75391: LD_INT 49
75393: PUSH
75394: LD_VAR 0 5
75398: IN
75399: AND
75400: PUSH
75401: LD_INT 31
75403: PPUSH
75404: LD_VAR 0 16
75408: PPUSH
75409: CALL_OW 321
75413: PUSH
75414: LD_INT 2
75416: EQUAL
75417: AND
75418: IFFALSE 75478
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75420: LD_INT 22
75422: PUSH
75423: LD_VAR 0 16
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 35
75434: PUSH
75435: LD_INT 49
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 91
75444: PUSH
75445: LD_VAR 0 1
75449: PUSH
75450: LD_INT 10
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: LIST
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: LIST
75462: PPUSH
75463: CALL_OW 69
75467: NOT
75468: IFFALSE 75478
// weapon := ru_time_lapser ;
75470: LD_ADDR_VAR 0 18
75474: PUSH
75475: LD_INT 49
75477: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75478: LD_VAR 0 12
75482: PUSH
75483: LD_INT 1
75485: PUSH
75486: LD_INT 2
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: IN
75493: PUSH
75494: LD_INT 11
75496: PUSH
75497: LD_VAR 0 5
75501: IN
75502: PUSH
75503: LD_INT 30
75505: PUSH
75506: LD_VAR 0 5
75510: IN
75511: OR
75512: AND
75513: PUSH
75514: LD_INT 6
75516: PPUSH
75517: LD_VAR 0 16
75521: PPUSH
75522: CALL_OW 321
75526: PUSH
75527: LD_INT 2
75529: EQUAL
75530: AND
75531: IFFALSE 75696
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75533: LD_INT 22
75535: PUSH
75536: LD_VAR 0 16
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 2
75547: PUSH
75548: LD_INT 35
75550: PUSH
75551: LD_INT 11
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 35
75560: PUSH
75561: LD_INT 30
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 91
75575: PUSH
75576: LD_VAR 0 1
75580: PUSH
75581: LD_INT 18
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: LIST
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: LIST
75593: PPUSH
75594: CALL_OW 69
75598: NOT
75599: PUSH
75600: LD_INT 22
75602: PUSH
75603: LD_VAR 0 16
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 2
75614: PUSH
75615: LD_INT 30
75617: PUSH
75618: LD_INT 32
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 30
75627: PUSH
75628: LD_INT 33
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 91
75642: PUSH
75643: LD_VAR 0 1
75647: PUSH
75648: LD_INT 12
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: LIST
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: LIST
75660: PUSH
75661: EMPTY
75662: LIST
75663: PPUSH
75664: CALL_OW 69
75668: PUSH
75669: LD_INT 2
75671: GREATER
75672: AND
75673: IFFALSE 75696
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75675: LD_ADDR_VAR 0 18
75679: PUSH
75680: LD_INT 11
75682: PUSH
75683: LD_INT 30
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_VAR 0 12
75694: ARRAY
75695: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75696: LD_VAR 0 18
75700: NOT
75701: PUSH
75702: LD_INT 40
75704: PPUSH
75705: LD_VAR 0 16
75709: PPUSH
75710: CALL_OW 321
75714: PUSH
75715: LD_INT 2
75717: EQUAL
75718: AND
75719: PUSH
75720: LD_INT 7
75722: PUSH
75723: LD_VAR 0 5
75727: IN
75728: PUSH
75729: LD_INT 28
75731: PUSH
75732: LD_VAR 0 5
75736: IN
75737: OR
75738: PUSH
75739: LD_INT 45
75741: PUSH
75742: LD_VAR 0 5
75746: IN
75747: OR
75748: AND
75749: IFFALSE 76003
// begin hex := GetHexInfo ( x , y ) ;
75751: LD_ADDR_VAR 0 4
75755: PUSH
75756: LD_VAR 0 10
75760: PPUSH
75761: LD_VAR 0 11
75765: PPUSH
75766: CALL_OW 546
75770: ST_TO_ADDR
// if hex [ 1 ] then
75771: LD_VAR 0 4
75775: PUSH
75776: LD_INT 1
75778: ARRAY
75779: IFFALSE 75783
// exit ;
75781: GO 76186
// height := hex [ 2 ] ;
75783: LD_ADDR_VAR 0 15
75787: PUSH
75788: LD_VAR 0 4
75792: PUSH
75793: LD_INT 2
75795: ARRAY
75796: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75797: LD_ADDR_VAR 0 14
75801: PUSH
75802: LD_INT 0
75804: PUSH
75805: LD_INT 2
75807: PUSH
75808: LD_INT 3
75810: PUSH
75811: LD_INT 5
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: ST_TO_ADDR
// for i in tmp do
75820: LD_ADDR_VAR 0 8
75824: PUSH
75825: LD_VAR 0 14
75829: PUSH
75830: FOR_IN
75831: IFFALSE 76001
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75833: LD_ADDR_VAR 0 9
75837: PUSH
75838: LD_VAR 0 10
75842: PPUSH
75843: LD_VAR 0 8
75847: PPUSH
75848: LD_INT 5
75850: PPUSH
75851: CALL_OW 272
75855: PUSH
75856: LD_VAR 0 11
75860: PPUSH
75861: LD_VAR 0 8
75865: PPUSH
75866: LD_INT 5
75868: PPUSH
75869: CALL_OW 273
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75878: LD_VAR 0 9
75882: PUSH
75883: LD_INT 1
75885: ARRAY
75886: PPUSH
75887: LD_VAR 0 9
75891: PUSH
75892: LD_INT 2
75894: ARRAY
75895: PPUSH
75896: CALL_OW 488
75900: IFFALSE 75999
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75902: LD_ADDR_VAR 0 4
75906: PUSH
75907: LD_VAR 0 9
75911: PUSH
75912: LD_INT 1
75914: ARRAY
75915: PPUSH
75916: LD_VAR 0 9
75920: PUSH
75921: LD_INT 2
75923: ARRAY
75924: PPUSH
75925: CALL_OW 546
75929: ST_TO_ADDR
// if hex [ 1 ] then
75930: LD_VAR 0 4
75934: PUSH
75935: LD_INT 1
75937: ARRAY
75938: IFFALSE 75942
// continue ;
75940: GO 75830
// h := hex [ 2 ] ;
75942: LD_ADDR_VAR 0 13
75946: PUSH
75947: LD_VAR 0 4
75951: PUSH
75952: LD_INT 2
75954: ARRAY
75955: ST_TO_ADDR
// if h + 7 < height then
75956: LD_VAR 0 13
75960: PUSH
75961: LD_INT 7
75963: PLUS
75964: PUSH
75965: LD_VAR 0 15
75969: LESS
75970: IFFALSE 75999
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75972: LD_ADDR_VAR 0 18
75976: PUSH
75977: LD_INT 7
75979: PUSH
75980: LD_INT 28
75982: PUSH
75983: LD_INT 45
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: LIST
75990: PUSH
75991: LD_VAR 0 12
75995: ARRAY
75996: ST_TO_ADDR
// break ;
75997: GO 76001
// end ; end ; end ;
75999: GO 75830
76001: POP
76002: POP
// end ; if not weapon then
76003: LD_VAR 0 18
76007: NOT
76008: IFFALSE 76068
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76010: LD_ADDR_VAR 0 5
76014: PUSH
76015: LD_VAR 0 5
76019: PUSH
76020: LD_INT 11
76022: PUSH
76023: LD_INT 30
76025: PUSH
76026: LD_INT 49
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: LIST
76033: DIFF
76034: ST_TO_ADDR
// if not list then
76035: LD_VAR 0 5
76039: NOT
76040: IFFALSE 76044
// exit ;
76042: GO 76186
// weapon := list [ rand ( 1 , list ) ] ;
76044: LD_ADDR_VAR 0 18
76048: PUSH
76049: LD_VAR 0 5
76053: PUSH
76054: LD_INT 1
76056: PPUSH
76057: LD_VAR 0 5
76061: PPUSH
76062: CALL_OW 12
76066: ARRAY
76067: ST_TO_ADDR
// end ; if weapon then
76068: LD_VAR 0 18
76072: IFFALSE 76186
// begin tmp := CostOfWeapon ( weapon ) ;
76074: LD_ADDR_VAR 0 14
76078: PUSH
76079: LD_VAR 0 18
76083: PPUSH
76084: CALL_OW 451
76088: ST_TO_ADDR
// j := GetBase ( tower ) ;
76089: LD_ADDR_VAR 0 9
76093: PUSH
76094: LD_VAR 0 1
76098: PPUSH
76099: CALL_OW 274
76103: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76104: LD_VAR 0 9
76108: PPUSH
76109: LD_INT 1
76111: PPUSH
76112: CALL_OW 275
76116: PUSH
76117: LD_VAR 0 14
76121: PUSH
76122: LD_INT 1
76124: ARRAY
76125: GREATEREQUAL
76126: PUSH
76127: LD_VAR 0 9
76131: PPUSH
76132: LD_INT 2
76134: PPUSH
76135: CALL_OW 275
76139: PUSH
76140: LD_VAR 0 14
76144: PUSH
76145: LD_INT 2
76147: ARRAY
76148: GREATEREQUAL
76149: AND
76150: PUSH
76151: LD_VAR 0 9
76155: PPUSH
76156: LD_INT 3
76158: PPUSH
76159: CALL_OW 275
76163: PUSH
76164: LD_VAR 0 14
76168: PUSH
76169: LD_INT 3
76171: ARRAY
76172: GREATEREQUAL
76173: AND
76174: IFFALSE 76186
// result := weapon ;
76176: LD_ADDR_VAR 0 3
76180: PUSH
76181: LD_VAR 0 18
76185: ST_TO_ADDR
// end ; end ;
76186: LD_VAR 0 3
76190: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76191: LD_INT 0
76193: PPUSH
76194: PPUSH
// result := true ;
76195: LD_ADDR_VAR 0 3
76199: PUSH
76200: LD_INT 1
76202: ST_TO_ADDR
// if array1 = array2 then
76203: LD_VAR 0 1
76207: PUSH
76208: LD_VAR 0 2
76212: EQUAL
76213: IFFALSE 76273
// begin for i = 1 to array1 do
76215: LD_ADDR_VAR 0 4
76219: PUSH
76220: DOUBLE
76221: LD_INT 1
76223: DEC
76224: ST_TO_ADDR
76225: LD_VAR 0 1
76229: PUSH
76230: FOR_TO
76231: IFFALSE 76269
// if array1 [ i ] <> array2 [ i ] then
76233: LD_VAR 0 1
76237: PUSH
76238: LD_VAR 0 4
76242: ARRAY
76243: PUSH
76244: LD_VAR 0 2
76248: PUSH
76249: LD_VAR 0 4
76253: ARRAY
76254: NONEQUAL
76255: IFFALSE 76267
// begin result := false ;
76257: LD_ADDR_VAR 0 3
76261: PUSH
76262: LD_INT 0
76264: ST_TO_ADDR
// break ;
76265: GO 76269
// end ;
76267: GO 76230
76269: POP
76270: POP
// end else
76271: GO 76281
// result := false ;
76273: LD_ADDR_VAR 0 3
76277: PUSH
76278: LD_INT 0
76280: ST_TO_ADDR
// end ;
76281: LD_VAR 0 3
76285: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76286: LD_INT 0
76288: PPUSH
76289: PPUSH
76290: PPUSH
// pom := GetBase ( fac ) ;
76291: LD_ADDR_VAR 0 5
76295: PUSH
76296: LD_VAR 0 1
76300: PPUSH
76301: CALL_OW 274
76305: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76306: LD_ADDR_VAR 0 4
76310: PUSH
76311: LD_VAR 0 2
76315: PUSH
76316: LD_INT 1
76318: ARRAY
76319: PPUSH
76320: LD_VAR 0 2
76324: PUSH
76325: LD_INT 2
76327: ARRAY
76328: PPUSH
76329: LD_VAR 0 2
76333: PUSH
76334: LD_INT 3
76336: ARRAY
76337: PPUSH
76338: LD_VAR 0 2
76342: PUSH
76343: LD_INT 4
76345: ARRAY
76346: PPUSH
76347: CALL_OW 449
76351: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76352: LD_ADDR_VAR 0 3
76356: PUSH
76357: LD_VAR 0 5
76361: PPUSH
76362: LD_INT 1
76364: PPUSH
76365: CALL_OW 275
76369: PUSH
76370: LD_VAR 0 4
76374: PUSH
76375: LD_INT 1
76377: ARRAY
76378: GREATEREQUAL
76379: PUSH
76380: LD_VAR 0 5
76384: PPUSH
76385: LD_INT 2
76387: PPUSH
76388: CALL_OW 275
76392: PUSH
76393: LD_VAR 0 4
76397: PUSH
76398: LD_INT 2
76400: ARRAY
76401: GREATEREQUAL
76402: AND
76403: PUSH
76404: LD_VAR 0 5
76408: PPUSH
76409: LD_INT 3
76411: PPUSH
76412: CALL_OW 275
76416: PUSH
76417: LD_VAR 0 4
76421: PUSH
76422: LD_INT 3
76424: ARRAY
76425: GREATEREQUAL
76426: AND
76427: ST_TO_ADDR
// end ;
76428: LD_VAR 0 3
76432: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76433: LD_INT 0
76435: PPUSH
76436: PPUSH
76437: PPUSH
76438: PPUSH
// pom := GetBase ( building ) ;
76439: LD_ADDR_VAR 0 3
76443: PUSH
76444: LD_VAR 0 1
76448: PPUSH
76449: CALL_OW 274
76453: ST_TO_ADDR
// if not pom then
76454: LD_VAR 0 3
76458: NOT
76459: IFFALSE 76463
// exit ;
76461: GO 76633
// btype := GetBType ( building ) ;
76463: LD_ADDR_VAR 0 5
76467: PUSH
76468: LD_VAR 0 1
76472: PPUSH
76473: CALL_OW 266
76477: ST_TO_ADDR
// if btype = b_armoury then
76478: LD_VAR 0 5
76482: PUSH
76483: LD_INT 4
76485: EQUAL
76486: IFFALSE 76496
// btype := b_barracks ;
76488: LD_ADDR_VAR 0 5
76492: PUSH
76493: LD_INT 5
76495: ST_TO_ADDR
// if btype = b_depot then
76496: LD_VAR 0 5
76500: PUSH
76501: LD_INT 0
76503: EQUAL
76504: IFFALSE 76514
// btype := b_warehouse ;
76506: LD_ADDR_VAR 0 5
76510: PUSH
76511: LD_INT 1
76513: ST_TO_ADDR
// if btype = b_workshop then
76514: LD_VAR 0 5
76518: PUSH
76519: LD_INT 2
76521: EQUAL
76522: IFFALSE 76532
// btype := b_factory ;
76524: LD_ADDR_VAR 0 5
76528: PUSH
76529: LD_INT 3
76531: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76532: LD_ADDR_VAR 0 4
76536: PUSH
76537: LD_VAR 0 5
76541: PPUSH
76542: LD_VAR 0 1
76546: PPUSH
76547: CALL_OW 248
76551: PPUSH
76552: CALL_OW 450
76556: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76557: LD_ADDR_VAR 0 2
76561: PUSH
76562: LD_VAR 0 3
76566: PPUSH
76567: LD_INT 1
76569: PPUSH
76570: CALL_OW 275
76574: PUSH
76575: LD_VAR 0 4
76579: PUSH
76580: LD_INT 1
76582: ARRAY
76583: GREATEREQUAL
76584: PUSH
76585: LD_VAR 0 3
76589: PPUSH
76590: LD_INT 2
76592: PPUSH
76593: CALL_OW 275
76597: PUSH
76598: LD_VAR 0 4
76602: PUSH
76603: LD_INT 2
76605: ARRAY
76606: GREATEREQUAL
76607: AND
76608: PUSH
76609: LD_VAR 0 3
76613: PPUSH
76614: LD_INT 3
76616: PPUSH
76617: CALL_OW 275
76621: PUSH
76622: LD_VAR 0 4
76626: PUSH
76627: LD_INT 3
76629: ARRAY
76630: GREATEREQUAL
76631: AND
76632: ST_TO_ADDR
// end ;
76633: LD_VAR 0 2
76637: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76638: LD_INT 0
76640: PPUSH
76641: PPUSH
76642: PPUSH
// pom := GetBase ( building ) ;
76643: LD_ADDR_VAR 0 4
76647: PUSH
76648: LD_VAR 0 1
76652: PPUSH
76653: CALL_OW 274
76657: ST_TO_ADDR
// if not pom then
76658: LD_VAR 0 4
76662: NOT
76663: IFFALSE 76667
// exit ;
76665: GO 76768
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76667: LD_ADDR_VAR 0 5
76671: PUSH
76672: LD_VAR 0 2
76676: PPUSH
76677: LD_VAR 0 1
76681: PPUSH
76682: CALL_OW 248
76686: PPUSH
76687: CALL_OW 450
76691: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76692: LD_ADDR_VAR 0 3
76696: PUSH
76697: LD_VAR 0 4
76701: PPUSH
76702: LD_INT 1
76704: PPUSH
76705: CALL_OW 275
76709: PUSH
76710: LD_VAR 0 5
76714: PUSH
76715: LD_INT 1
76717: ARRAY
76718: GREATEREQUAL
76719: PUSH
76720: LD_VAR 0 4
76724: PPUSH
76725: LD_INT 2
76727: PPUSH
76728: CALL_OW 275
76732: PUSH
76733: LD_VAR 0 5
76737: PUSH
76738: LD_INT 2
76740: ARRAY
76741: GREATEREQUAL
76742: AND
76743: PUSH
76744: LD_VAR 0 4
76748: PPUSH
76749: LD_INT 3
76751: PPUSH
76752: CALL_OW 275
76756: PUSH
76757: LD_VAR 0 5
76761: PUSH
76762: LD_INT 3
76764: ARRAY
76765: GREATEREQUAL
76766: AND
76767: ST_TO_ADDR
// end ;
76768: LD_VAR 0 3
76772: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76773: LD_INT 0
76775: PPUSH
76776: PPUSH
76777: PPUSH
76778: PPUSH
76779: PPUSH
76780: PPUSH
76781: PPUSH
76782: PPUSH
76783: PPUSH
76784: PPUSH
// result := false ;
76785: LD_ADDR_VAR 0 6
76789: PUSH
76790: LD_INT 0
76792: ST_TO_ADDR
// if not base or not btype or not x or not y then
76793: LD_VAR 0 1
76797: NOT
76798: PUSH
76799: LD_VAR 0 2
76803: NOT
76804: OR
76805: PUSH
76806: LD_VAR 0 3
76810: NOT
76811: OR
76812: PUSH
76813: LD_VAR 0 4
76817: NOT
76818: OR
76819: IFFALSE 76823
// exit ;
76821: GO 77432
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76823: LD_ADDR_VAR 0 12
76827: PUSH
76828: LD_VAR 0 2
76832: PPUSH
76833: LD_VAR 0 3
76837: PPUSH
76838: LD_VAR 0 4
76842: PPUSH
76843: LD_VAR 0 5
76847: PPUSH
76848: LD_VAR 0 1
76852: PUSH
76853: LD_INT 1
76855: ARRAY
76856: PPUSH
76857: CALL_OW 248
76861: PPUSH
76862: LD_INT 0
76864: PPUSH
76865: CALL 78269 0 6
76869: ST_TO_ADDR
// if not hexes then
76870: LD_VAR 0 12
76874: NOT
76875: IFFALSE 76879
// exit ;
76877: GO 77432
// for i = 1 to hexes do
76879: LD_ADDR_VAR 0 7
76883: PUSH
76884: DOUBLE
76885: LD_INT 1
76887: DEC
76888: ST_TO_ADDR
76889: LD_VAR 0 12
76893: PUSH
76894: FOR_TO
76895: IFFALSE 77430
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76897: LD_ADDR_VAR 0 11
76901: PUSH
76902: LD_VAR 0 12
76906: PUSH
76907: LD_VAR 0 7
76911: ARRAY
76912: PUSH
76913: LD_INT 1
76915: ARRAY
76916: PPUSH
76917: LD_VAR 0 12
76921: PUSH
76922: LD_VAR 0 7
76926: ARRAY
76927: PUSH
76928: LD_INT 2
76930: ARRAY
76931: PPUSH
76932: CALL_OW 428
76936: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76937: LD_VAR 0 12
76941: PUSH
76942: LD_VAR 0 7
76946: ARRAY
76947: PUSH
76948: LD_INT 1
76950: ARRAY
76951: PPUSH
76952: LD_VAR 0 12
76956: PUSH
76957: LD_VAR 0 7
76961: ARRAY
76962: PUSH
76963: LD_INT 2
76965: ARRAY
76966: PPUSH
76967: CALL_OW 351
76971: PUSH
76972: LD_VAR 0 12
76976: PUSH
76977: LD_VAR 0 7
76981: ARRAY
76982: PUSH
76983: LD_INT 1
76985: ARRAY
76986: PPUSH
76987: LD_VAR 0 12
76991: PUSH
76992: LD_VAR 0 7
76996: ARRAY
76997: PUSH
76998: LD_INT 2
77000: ARRAY
77001: PPUSH
77002: CALL_OW 488
77006: NOT
77007: OR
77008: PUSH
77009: LD_VAR 0 11
77013: PPUSH
77014: CALL_OW 247
77018: PUSH
77019: LD_INT 3
77021: EQUAL
77022: OR
77023: IFFALSE 77029
// exit ;
77025: POP
77026: POP
77027: GO 77432
// if not tmp or not tmp in base then
77029: LD_VAR 0 11
77033: NOT
77034: PUSH
77035: LD_VAR 0 11
77039: PUSH
77040: LD_VAR 0 1
77044: IN
77045: NOT
77046: OR
77047: IFFALSE 77051
// continue ;
77049: GO 76894
// result := true ;
77051: LD_ADDR_VAR 0 6
77055: PUSH
77056: LD_INT 1
77058: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77059: LD_ADDR_VAR 0 15
77063: PUSH
77064: LD_VAR 0 1
77068: PPUSH
77069: LD_INT 22
77071: PUSH
77072: LD_VAR 0 11
77076: PPUSH
77077: CALL_OW 255
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 2
77088: PUSH
77089: LD_INT 30
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 30
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: LIST
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PPUSH
77118: CALL_OW 72
77122: ST_TO_ADDR
// if dep then
77123: LD_VAR 0 15
77127: IFFALSE 77263
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77129: LD_ADDR_VAR 0 14
77133: PUSH
77134: LD_VAR 0 15
77138: PUSH
77139: LD_INT 1
77141: ARRAY
77142: PPUSH
77143: CALL_OW 250
77147: PPUSH
77148: LD_VAR 0 15
77152: PUSH
77153: LD_INT 1
77155: ARRAY
77156: PPUSH
77157: CALL_OW 254
77161: PPUSH
77162: LD_INT 5
77164: PPUSH
77165: CALL_OW 272
77169: PUSH
77170: LD_VAR 0 15
77174: PUSH
77175: LD_INT 1
77177: ARRAY
77178: PPUSH
77179: CALL_OW 251
77183: PPUSH
77184: LD_VAR 0 15
77188: PUSH
77189: LD_INT 1
77191: ARRAY
77192: PPUSH
77193: CALL_OW 254
77197: PPUSH
77198: LD_INT 5
77200: PPUSH
77201: CALL_OW 273
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77210: LD_VAR 0 14
77214: PUSH
77215: LD_INT 1
77217: ARRAY
77218: PPUSH
77219: LD_VAR 0 14
77223: PUSH
77224: LD_INT 2
77226: ARRAY
77227: PPUSH
77228: CALL_OW 488
77232: IFFALSE 77263
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77234: LD_VAR 0 11
77238: PPUSH
77239: LD_VAR 0 14
77243: PUSH
77244: LD_INT 1
77246: ARRAY
77247: PPUSH
77248: LD_VAR 0 14
77252: PUSH
77253: LD_INT 2
77255: ARRAY
77256: PPUSH
77257: CALL_OW 111
// continue ;
77261: GO 76894
// end ; end ; r := GetDir ( tmp ) ;
77263: LD_ADDR_VAR 0 13
77267: PUSH
77268: LD_VAR 0 11
77272: PPUSH
77273: CALL_OW 254
77277: ST_TO_ADDR
// if r = 5 then
77278: LD_VAR 0 13
77282: PUSH
77283: LD_INT 5
77285: EQUAL
77286: IFFALSE 77296
// r := 0 ;
77288: LD_ADDR_VAR 0 13
77292: PUSH
77293: LD_INT 0
77295: ST_TO_ADDR
// for j = r to 5 do
77296: LD_ADDR_VAR 0 8
77300: PUSH
77301: DOUBLE
77302: LD_VAR 0 13
77306: DEC
77307: ST_TO_ADDR
77308: LD_INT 5
77310: PUSH
77311: FOR_TO
77312: IFFALSE 77426
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77314: LD_ADDR_VAR 0 9
77318: PUSH
77319: LD_VAR 0 11
77323: PPUSH
77324: CALL_OW 250
77328: PPUSH
77329: LD_VAR 0 8
77333: PPUSH
77334: LD_INT 2
77336: PPUSH
77337: CALL_OW 272
77341: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77342: LD_ADDR_VAR 0 10
77346: PUSH
77347: LD_VAR 0 11
77351: PPUSH
77352: CALL_OW 251
77356: PPUSH
77357: LD_VAR 0 8
77361: PPUSH
77362: LD_INT 2
77364: PPUSH
77365: CALL_OW 273
77369: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77370: LD_VAR 0 9
77374: PPUSH
77375: LD_VAR 0 10
77379: PPUSH
77380: CALL_OW 488
77384: PUSH
77385: LD_VAR 0 9
77389: PPUSH
77390: LD_VAR 0 10
77394: PPUSH
77395: CALL_OW 428
77399: NOT
77400: AND
77401: IFFALSE 77424
// begin ComMoveXY ( tmp , _x , _y ) ;
77403: LD_VAR 0 11
77407: PPUSH
77408: LD_VAR 0 9
77412: PPUSH
77413: LD_VAR 0 10
77417: PPUSH
77418: CALL_OW 111
// break ;
77422: GO 77426
// end ; end ;
77424: GO 77311
77426: POP
77427: POP
// end ;
77428: GO 76894
77430: POP
77431: POP
// end ;
77432: LD_VAR 0 6
77436: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77437: LD_INT 0
77439: PPUSH
77440: PPUSH
77441: PPUSH
77442: PPUSH
77443: PPUSH
77444: PPUSH
77445: PPUSH
77446: PPUSH
77447: PPUSH
77448: PPUSH
// result := false ;
77449: LD_ADDR_VAR 0 6
77453: PUSH
77454: LD_INT 0
77456: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77457: LD_VAR 0 1
77461: NOT
77462: PUSH
77463: LD_VAR 0 1
77467: PPUSH
77468: CALL_OW 266
77472: PUSH
77473: LD_INT 0
77475: PUSH
77476: LD_INT 1
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: IN
77483: NOT
77484: OR
77485: PUSH
77486: LD_VAR 0 2
77490: NOT
77491: OR
77492: PUSH
77493: LD_VAR 0 5
77497: PUSH
77498: LD_INT 0
77500: PUSH
77501: LD_INT 1
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: LD_INT 3
77509: PUSH
77510: LD_INT 4
77512: PUSH
77513: LD_INT 5
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: LIST
77523: IN
77524: NOT
77525: OR
77526: PUSH
77527: LD_VAR 0 3
77531: PPUSH
77532: LD_VAR 0 4
77536: PPUSH
77537: CALL_OW 488
77541: NOT
77542: OR
77543: IFFALSE 77547
// exit ;
77545: GO 78264
// pom := GetBase ( depot ) ;
77547: LD_ADDR_VAR 0 10
77551: PUSH
77552: LD_VAR 0 1
77556: PPUSH
77557: CALL_OW 274
77561: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77562: LD_ADDR_VAR 0 11
77566: PUSH
77567: LD_VAR 0 2
77571: PPUSH
77572: LD_VAR 0 1
77576: PPUSH
77577: CALL_OW 248
77581: PPUSH
77582: CALL_OW 450
77586: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77587: LD_VAR 0 10
77591: PPUSH
77592: LD_INT 1
77594: PPUSH
77595: CALL_OW 275
77599: PUSH
77600: LD_VAR 0 11
77604: PUSH
77605: LD_INT 1
77607: ARRAY
77608: GREATEREQUAL
77609: PUSH
77610: LD_VAR 0 10
77614: PPUSH
77615: LD_INT 2
77617: PPUSH
77618: CALL_OW 275
77622: PUSH
77623: LD_VAR 0 11
77627: PUSH
77628: LD_INT 2
77630: ARRAY
77631: GREATEREQUAL
77632: AND
77633: PUSH
77634: LD_VAR 0 10
77638: PPUSH
77639: LD_INT 3
77641: PPUSH
77642: CALL_OW 275
77646: PUSH
77647: LD_VAR 0 11
77651: PUSH
77652: LD_INT 3
77654: ARRAY
77655: GREATEREQUAL
77656: AND
77657: NOT
77658: IFFALSE 77662
// exit ;
77660: GO 78264
// if GetBType ( depot ) = b_depot then
77662: LD_VAR 0 1
77666: PPUSH
77667: CALL_OW 266
77671: PUSH
77672: LD_INT 0
77674: EQUAL
77675: IFFALSE 77687
// dist := 28 else
77677: LD_ADDR_VAR 0 14
77681: PUSH
77682: LD_INT 28
77684: ST_TO_ADDR
77685: GO 77695
// dist := 36 ;
77687: LD_ADDR_VAR 0 14
77691: PUSH
77692: LD_INT 36
77694: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77695: LD_VAR 0 1
77699: PPUSH
77700: LD_VAR 0 3
77704: PPUSH
77705: LD_VAR 0 4
77709: PPUSH
77710: CALL_OW 297
77714: PUSH
77715: LD_VAR 0 14
77719: GREATER
77720: IFFALSE 77724
// exit ;
77722: GO 78264
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77724: LD_ADDR_VAR 0 12
77728: PUSH
77729: LD_VAR 0 2
77733: PPUSH
77734: LD_VAR 0 3
77738: PPUSH
77739: LD_VAR 0 4
77743: PPUSH
77744: LD_VAR 0 5
77748: PPUSH
77749: LD_VAR 0 1
77753: PPUSH
77754: CALL_OW 248
77758: PPUSH
77759: LD_INT 0
77761: PPUSH
77762: CALL 78269 0 6
77766: ST_TO_ADDR
// if not hexes then
77767: LD_VAR 0 12
77771: NOT
77772: IFFALSE 77776
// exit ;
77774: GO 78264
// hex := GetHexInfo ( x , y ) ;
77776: LD_ADDR_VAR 0 15
77780: PUSH
77781: LD_VAR 0 3
77785: PPUSH
77786: LD_VAR 0 4
77790: PPUSH
77791: CALL_OW 546
77795: ST_TO_ADDR
// if hex [ 1 ] then
77796: LD_VAR 0 15
77800: PUSH
77801: LD_INT 1
77803: ARRAY
77804: IFFALSE 77808
// exit ;
77806: GO 78264
// height := hex [ 2 ] ;
77808: LD_ADDR_VAR 0 13
77812: PUSH
77813: LD_VAR 0 15
77817: PUSH
77818: LD_INT 2
77820: ARRAY
77821: ST_TO_ADDR
// for i = 1 to hexes do
77822: LD_ADDR_VAR 0 7
77826: PUSH
77827: DOUBLE
77828: LD_INT 1
77830: DEC
77831: ST_TO_ADDR
77832: LD_VAR 0 12
77836: PUSH
77837: FOR_TO
77838: IFFALSE 78168
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77840: LD_VAR 0 12
77844: PUSH
77845: LD_VAR 0 7
77849: ARRAY
77850: PUSH
77851: LD_INT 1
77853: ARRAY
77854: PPUSH
77855: LD_VAR 0 12
77859: PUSH
77860: LD_VAR 0 7
77864: ARRAY
77865: PUSH
77866: LD_INT 2
77868: ARRAY
77869: PPUSH
77870: CALL_OW 488
77874: NOT
77875: PUSH
77876: LD_VAR 0 12
77880: PUSH
77881: LD_VAR 0 7
77885: ARRAY
77886: PUSH
77887: LD_INT 1
77889: ARRAY
77890: PPUSH
77891: LD_VAR 0 12
77895: PUSH
77896: LD_VAR 0 7
77900: ARRAY
77901: PUSH
77902: LD_INT 2
77904: ARRAY
77905: PPUSH
77906: CALL_OW 428
77910: PUSH
77911: LD_INT 0
77913: GREATER
77914: OR
77915: PUSH
77916: LD_VAR 0 12
77920: PUSH
77921: LD_VAR 0 7
77925: ARRAY
77926: PUSH
77927: LD_INT 1
77929: ARRAY
77930: PPUSH
77931: LD_VAR 0 12
77935: PUSH
77936: LD_VAR 0 7
77940: ARRAY
77941: PUSH
77942: LD_INT 2
77944: ARRAY
77945: PPUSH
77946: CALL_OW 351
77950: OR
77951: IFFALSE 77957
// exit ;
77953: POP
77954: POP
77955: GO 78264
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77957: LD_ADDR_VAR 0 8
77961: PUSH
77962: LD_VAR 0 12
77966: PUSH
77967: LD_VAR 0 7
77971: ARRAY
77972: PUSH
77973: LD_INT 1
77975: ARRAY
77976: PPUSH
77977: LD_VAR 0 12
77981: PUSH
77982: LD_VAR 0 7
77986: ARRAY
77987: PUSH
77988: LD_INT 2
77990: ARRAY
77991: PPUSH
77992: CALL_OW 546
77996: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77997: LD_VAR 0 8
78001: PUSH
78002: LD_INT 1
78004: ARRAY
78005: PUSH
78006: LD_VAR 0 8
78010: PUSH
78011: LD_INT 2
78013: ARRAY
78014: PUSH
78015: LD_VAR 0 13
78019: PUSH
78020: LD_INT 2
78022: PLUS
78023: GREATER
78024: OR
78025: PUSH
78026: LD_VAR 0 8
78030: PUSH
78031: LD_INT 2
78033: ARRAY
78034: PUSH
78035: LD_VAR 0 13
78039: PUSH
78040: LD_INT 2
78042: MINUS
78043: LESS
78044: OR
78045: PUSH
78046: LD_VAR 0 8
78050: PUSH
78051: LD_INT 3
78053: ARRAY
78054: PUSH
78055: LD_INT 0
78057: PUSH
78058: LD_INT 8
78060: PUSH
78061: LD_INT 9
78063: PUSH
78064: LD_INT 10
78066: PUSH
78067: LD_INT 11
78069: PUSH
78070: LD_INT 12
78072: PUSH
78073: LD_INT 13
78075: PUSH
78076: LD_INT 16
78078: PUSH
78079: LD_INT 17
78081: PUSH
78082: LD_INT 18
78084: PUSH
78085: LD_INT 19
78087: PUSH
78088: LD_INT 20
78090: PUSH
78091: LD_INT 21
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: LIST
78098: LIST
78099: LIST
78100: LIST
78101: LIST
78102: LIST
78103: LIST
78104: LIST
78105: LIST
78106: LIST
78107: LIST
78108: IN
78109: NOT
78110: OR
78111: PUSH
78112: LD_VAR 0 8
78116: PUSH
78117: LD_INT 5
78119: ARRAY
78120: NOT
78121: OR
78122: PUSH
78123: LD_VAR 0 8
78127: PUSH
78128: LD_INT 6
78130: ARRAY
78131: PUSH
78132: LD_INT 1
78134: PUSH
78135: LD_INT 2
78137: PUSH
78138: LD_INT 7
78140: PUSH
78141: LD_INT 9
78143: PUSH
78144: LD_INT 10
78146: PUSH
78147: LD_INT 11
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: IN
78158: NOT
78159: OR
78160: IFFALSE 78166
// exit ;
78162: POP
78163: POP
78164: GO 78264
// end ;
78166: GO 77837
78168: POP
78169: POP
// side := GetSide ( depot ) ;
78170: LD_ADDR_VAR 0 9
78174: PUSH
78175: LD_VAR 0 1
78179: PPUSH
78180: CALL_OW 255
78184: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78185: LD_VAR 0 9
78189: PPUSH
78190: LD_VAR 0 3
78194: PPUSH
78195: LD_VAR 0 4
78199: PPUSH
78200: LD_INT 20
78202: PPUSH
78203: CALL 70918 0 4
78207: PUSH
78208: LD_INT 4
78210: ARRAY
78211: IFFALSE 78215
// exit ;
78213: GO 78264
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78215: LD_VAR 0 2
78219: PUSH
78220: LD_INT 29
78222: PUSH
78223: LD_INT 30
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: IN
78230: PUSH
78231: LD_VAR 0 3
78235: PPUSH
78236: LD_VAR 0 4
78240: PPUSH
78241: LD_VAR 0 9
78245: PPUSH
78246: CALL_OW 440
78250: NOT
78251: AND
78252: IFFALSE 78256
// exit ;
78254: GO 78264
// result := true ;
78256: LD_ADDR_VAR 0 6
78260: PUSH
78261: LD_INT 1
78263: ST_TO_ADDR
// end ;
78264: LD_VAR 0 6
78268: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78269: LD_INT 0
78271: PPUSH
78272: PPUSH
78273: PPUSH
78274: PPUSH
78275: PPUSH
78276: PPUSH
78277: PPUSH
78278: PPUSH
78279: PPUSH
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
78288: PPUSH
78289: PPUSH
78290: PPUSH
78291: PPUSH
78292: PPUSH
78293: PPUSH
78294: PPUSH
78295: PPUSH
78296: PPUSH
78297: PPUSH
78298: PPUSH
78299: PPUSH
78300: PPUSH
78301: PPUSH
78302: PPUSH
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
78320: PPUSH
78321: PPUSH
78322: PPUSH
78323: PPUSH
78324: PPUSH
78325: PPUSH
78326: PPUSH
78327: PPUSH
78328: PPUSH
// result = [ ] ;
78329: LD_ADDR_VAR 0 7
78333: PUSH
78334: EMPTY
78335: ST_TO_ADDR
// temp_list = [ ] ;
78336: LD_ADDR_VAR 0 9
78340: PUSH
78341: EMPTY
78342: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78343: LD_VAR 0 4
78347: PUSH
78348: LD_INT 0
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: LD_INT 2
78356: PUSH
78357: LD_INT 3
78359: PUSH
78360: LD_INT 4
78362: PUSH
78363: LD_INT 5
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: IN
78374: NOT
78375: PUSH
78376: LD_VAR 0 1
78380: PUSH
78381: LD_INT 0
78383: PUSH
78384: LD_INT 1
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: IN
78391: PUSH
78392: LD_VAR 0 5
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: LD_INT 2
78402: PUSH
78403: LD_INT 3
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: LIST
78410: IN
78411: NOT
78412: AND
78413: OR
78414: IFFALSE 78418
// exit ;
78416: GO 96809
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78418: LD_VAR 0 1
78422: PUSH
78423: LD_INT 6
78425: PUSH
78426: LD_INT 7
78428: PUSH
78429: LD_INT 8
78431: PUSH
78432: LD_INT 13
78434: PUSH
78435: LD_INT 12
78437: PUSH
78438: LD_INT 15
78440: PUSH
78441: LD_INT 11
78443: PUSH
78444: LD_INT 14
78446: PUSH
78447: LD_INT 10
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: IN
78461: IFFALSE 78471
// btype = b_lab ;
78463: LD_ADDR_VAR 0 1
78467: PUSH
78468: LD_INT 6
78470: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78471: LD_VAR 0 6
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: LD_INT 2
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: LIST
78489: IN
78490: NOT
78491: PUSH
78492: LD_VAR 0 1
78496: PUSH
78497: LD_INT 0
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: LD_INT 2
78505: PUSH
78506: LD_INT 3
78508: PUSH
78509: LD_INT 6
78511: PUSH
78512: LD_INT 36
78514: PUSH
78515: LD_INT 4
78517: PUSH
78518: LD_INT 5
78520: PUSH
78521: LD_INT 31
78523: PUSH
78524: LD_INT 32
78526: PUSH
78527: LD_INT 33
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: IN
78543: NOT
78544: PUSH
78545: LD_VAR 0 6
78549: PUSH
78550: LD_INT 1
78552: EQUAL
78553: AND
78554: OR
78555: PUSH
78556: LD_VAR 0 1
78560: PUSH
78561: LD_INT 2
78563: PUSH
78564: LD_INT 3
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: IN
78571: NOT
78572: PUSH
78573: LD_VAR 0 6
78577: PUSH
78578: LD_INT 2
78580: EQUAL
78581: AND
78582: OR
78583: IFFALSE 78593
// mode = 0 ;
78585: LD_ADDR_VAR 0 6
78589: PUSH
78590: LD_INT 0
78592: ST_TO_ADDR
// case mode of 0 :
78593: LD_VAR 0 6
78597: PUSH
78598: LD_INT 0
78600: DOUBLE
78601: EQUAL
78602: IFTRUE 78606
78604: GO 90059
78606: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78607: LD_ADDR_VAR 0 11
78611: PUSH
78612: LD_INT 0
78614: PUSH
78615: LD_INT 0
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 0
78624: PUSH
78625: LD_INT 1
78627: NEG
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 1
78635: PUSH
78636: LD_INT 0
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 1
78645: PUSH
78646: LD_INT 1
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 0
78655: PUSH
78656: LD_INT 1
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 1
78665: NEG
78666: PUSH
78667: LD_INT 0
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: LD_INT 1
78680: NEG
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 1
78688: NEG
78689: PUSH
78690: LD_INT 2
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: LD_INT 2
78703: NEG
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: LD_INT 1
78714: NEG
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 1
78722: PUSH
78723: LD_INT 2
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 0
78732: PUSH
78733: LD_INT 2
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 1
78742: NEG
78743: PUSH
78744: LD_INT 1
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 1
78753: PUSH
78754: LD_INT 3
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 0
78763: PUSH
78764: LD_INT 3
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 1
78773: NEG
78774: PUSH
78775: LD_INT 2
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78800: LD_ADDR_VAR 0 12
78804: PUSH
78805: LD_INT 0
78807: PUSH
78808: LD_INT 0
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 1
78820: NEG
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 1
78828: PUSH
78829: LD_INT 0
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 1
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 0
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 1
78858: NEG
78859: PUSH
78860: LD_INT 0
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 1
78869: NEG
78870: PUSH
78871: LD_INT 1
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: PUSH
78882: LD_INT 1
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 2
78892: PUSH
78893: LD_INT 0
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 2
78902: PUSH
78903: LD_INT 1
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: LD_INT 1
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PUSH
78921: LD_INT 2
78923: NEG
78924: PUSH
78925: LD_INT 0
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 2
78934: NEG
78935: PUSH
78936: LD_INT 1
78938: NEG
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 2
78946: NEG
78947: PUSH
78948: LD_INT 1
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 3
78957: NEG
78958: PUSH
78959: LD_INT 0
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 3
78968: NEG
78969: PUSH
78970: LD_INT 1
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78996: LD_ADDR_VAR 0 13
79000: PUSH
79001: LD_INT 0
79003: PUSH
79004: LD_INT 0
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 1
79016: NEG
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 1
79024: PUSH
79025: LD_INT 0
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 1
79034: PUSH
79035: LD_INT 1
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 0
79044: PUSH
79045: LD_INT 1
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 1
79054: NEG
79055: PUSH
79056: LD_INT 0
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: NEG
79066: PUSH
79067: LD_INT 1
79069: NEG
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 1
79077: NEG
79078: PUSH
79079: LD_INT 2
79081: NEG
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: LD_INT 1
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 2
79099: PUSH
79100: LD_INT 2
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: LD_INT 2
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 2
79119: NEG
79120: PUSH
79121: LD_INT 1
79123: NEG
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 2
79131: NEG
79132: PUSH
79133: LD_INT 2
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 2
79143: NEG
79144: PUSH
79145: LD_INT 3
79147: NEG
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: LD_INT 2
79159: NEG
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 3
79167: NEG
79168: PUSH
79169: LD_INT 3
79171: NEG
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79195: LD_ADDR_VAR 0 14
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: LD_INT 0
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 0
79212: PUSH
79213: LD_INT 1
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 1
79223: PUSH
79224: LD_INT 0
79226: PUSH
79227: EMPTY
79228: LIST
79229: LIST
79230: PUSH
79231: LD_INT 1
79233: PUSH
79234: LD_INT 1
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: LD_INT 1
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 1
79253: NEG
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 1
79264: NEG
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 1
79276: NEG
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 0
79288: PUSH
79289: LD_INT 2
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 1
79299: PUSH
79300: LD_INT 1
79302: NEG
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 1
79310: PUSH
79311: LD_INT 2
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 0
79320: PUSH
79321: LD_INT 2
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 1
79330: NEG
79331: PUSH
79332: LD_INT 1
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: LD_INT 3
79345: NEG
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 0
79353: PUSH
79354: LD_INT 3
79356: NEG
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: PUSH
79362: LD_INT 1
79364: PUSH
79365: LD_INT 2
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79391: LD_ADDR_VAR 0 15
79395: PUSH
79396: LD_INT 0
79398: PUSH
79399: LD_INT 0
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: LD_INT 1
79411: NEG
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 1
79419: PUSH
79420: LD_INT 0
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 1
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 0
79439: PUSH
79440: LD_INT 1
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 1
79449: NEG
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 1
79460: NEG
79461: PUSH
79462: LD_INT 1
79464: NEG
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 1
79472: PUSH
79473: LD_INT 1
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 2
79483: PUSH
79484: LD_INT 0
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 2
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 1
79503: NEG
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 2
79514: NEG
79515: PUSH
79516: LD_INT 0
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 2
79525: NEG
79526: PUSH
79527: LD_INT 1
79529: NEG
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: LD_INT 1
79540: NEG
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 3
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 3
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79584: LD_ADDR_VAR 0 16
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: LD_INT 0
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 0
79601: PUSH
79602: LD_INT 1
79604: NEG
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: LD_INT 1
79612: PUSH
79613: LD_INT 0
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: LD_INT 1
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 1
79642: NEG
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 1
79653: NEG
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 1
79665: NEG
79666: PUSH
79667: LD_INT 2
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 2
79677: PUSH
79678: LD_INT 1
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 2
79687: PUSH
79688: LD_INT 2
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 1
79697: PUSH
79698: LD_INT 2
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 2
79707: NEG
79708: PUSH
79709: LD_INT 1
79711: NEG
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: LD_INT 2
79719: NEG
79720: PUSH
79721: LD_INT 2
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 3
79731: PUSH
79732: LD_INT 2
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: PUSH
79742: LD_INT 3
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 2
79751: PUSH
79752: LD_INT 3
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79777: LD_ADDR_VAR 0 17
79781: PUSH
79782: LD_INT 0
79784: PUSH
79785: LD_INT 0
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: LD_INT 1
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 1
79805: PUSH
79806: LD_INT 0
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 1
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 0
79825: PUSH
79826: LD_INT 1
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: NEG
79836: PUSH
79837: LD_INT 0
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: LD_INT 1
79850: NEG
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: NEG
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 0
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 1
79881: PUSH
79882: LD_INT 1
79884: NEG
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 2
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: LD_INT 2
79912: PUSH
79913: LD_INT 2
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 1
79922: PUSH
79923: LD_INT 2
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: LD_INT 2
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 1
79942: NEG
79943: PUSH
79944: LD_INT 1
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 2
79953: NEG
79954: PUSH
79955: LD_INT 0
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 2
79964: NEG
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 2
79976: NEG
79977: PUSH
79978: LD_INT 2
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80007: LD_ADDR_VAR 0 18
80011: PUSH
80012: LD_INT 0
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: LD_INT 1
80027: NEG
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: PUSH
80036: LD_INT 0
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 1
80045: PUSH
80046: LD_INT 1
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: LD_INT 1
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 1
80065: NEG
80066: PUSH
80067: LD_INT 0
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 1
80076: NEG
80077: PUSH
80078: LD_INT 1
80080: NEG
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 1
80088: NEG
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 0
80100: PUSH
80101: LD_INT 2
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 1
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 2
80132: PUSH
80133: LD_INT 1
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 2
80142: PUSH
80143: LD_INT 2
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 1
80152: PUSH
80153: LD_INT 2
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 0
80162: PUSH
80163: LD_INT 2
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 1
80172: NEG
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 2
80183: NEG
80184: PUSH
80185: LD_INT 0
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 2
80194: NEG
80195: PUSH
80196: LD_INT 1
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 2
80206: NEG
80207: PUSH
80208: LD_INT 2
80210: NEG
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: LIST
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80237: LD_ADDR_VAR 0 19
80241: PUSH
80242: LD_INT 0
80244: PUSH
80245: LD_INT 0
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 1
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 1
80275: PUSH
80276: LD_INT 1
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: LD_INT 1
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 1
80295: NEG
80296: PUSH
80297: LD_INT 0
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 1
80306: NEG
80307: PUSH
80308: LD_INT 1
80310: NEG
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 0
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: PUSH
80353: LD_INT 0
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: LD_INT 2
80362: PUSH
80363: LD_INT 1
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 2
80372: PUSH
80373: LD_INT 2
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 1
80382: PUSH
80383: LD_INT 2
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 0
80392: PUSH
80393: LD_INT 2
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: NEG
80414: PUSH
80415: LD_INT 0
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 2
80424: NEG
80425: PUSH
80426: LD_INT 1
80428: NEG
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 2
80436: NEG
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80467: LD_ADDR_VAR 0 20
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 0
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 1
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: NEG
80526: PUSH
80527: LD_INT 0
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 1
80536: NEG
80537: PUSH
80538: LD_INT 1
80540: NEG
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: LD_INT 2
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 1
80571: PUSH
80572: LD_INT 1
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 2
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 2
80592: PUSH
80593: LD_INT 1
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 2
80602: PUSH
80603: LD_INT 2
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: PUSH
80613: LD_INT 2
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 0
80622: PUSH
80623: LD_INT 2
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 1
80632: NEG
80633: PUSH
80634: LD_INT 1
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 2
80643: NEG
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 2
80654: NEG
80655: PUSH
80656: LD_INT 1
80658: NEG
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 2
80666: NEG
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80697: LD_ADDR_VAR 0 21
80701: PUSH
80702: LD_INT 0
80704: PUSH
80705: LD_INT 0
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 0
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 1
80725: PUSH
80726: LD_INT 0
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 1
80735: PUSH
80736: LD_INT 1
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 0
80745: PUSH
80746: LD_INT 1
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 1
80755: NEG
80756: PUSH
80757: LD_INT 0
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 1
80766: NEG
80767: PUSH
80768: LD_INT 1
80770: NEG
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 0
80790: PUSH
80791: LD_INT 2
80793: NEG
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 1
80801: PUSH
80802: LD_INT 1
80804: NEG
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 2
80812: PUSH
80813: LD_INT 0
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 2
80822: PUSH
80823: LD_INT 1
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 2
80832: PUSH
80833: LD_INT 2
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: LD_INT 2
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 0
80852: PUSH
80853: LD_INT 2
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 1
80862: NEG
80863: PUSH
80864: LD_INT 1
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 2
80873: NEG
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 2
80884: NEG
80885: PUSH
80886: LD_INT 1
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 2
80896: NEG
80897: PUSH
80898: LD_INT 2
80900: NEG
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80927: LD_ADDR_VAR 0 22
80931: PUSH
80932: LD_INT 0
80934: PUSH
80935: LD_INT 0
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 0
80944: PUSH
80945: LD_INT 1
80947: NEG
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 1
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 1
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 1
80985: NEG
80986: PUSH
80987: LD_INT 0
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 1
81008: NEG
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 0
81020: PUSH
81021: LD_INT 2
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 2
81052: PUSH
81053: LD_INT 1
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 2
81062: PUSH
81063: LD_INT 2
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 1
81072: PUSH
81073: LD_INT 2
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 0
81082: PUSH
81083: LD_INT 2
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 2
81103: NEG
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: NEG
81115: PUSH
81116: LD_INT 1
81118: NEG
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 2
81126: NEG
81127: PUSH
81128: LD_INT 2
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81157: LD_ADDR_VAR 0 23
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: LD_INT 0
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 0
81174: PUSH
81175: LD_INT 1
81177: NEG
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: LD_INT 0
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 1
81195: PUSH
81196: LD_INT 1
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: PUSH
81203: LD_INT 0
81205: PUSH
81206: LD_INT 1
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 1
81215: NEG
81216: PUSH
81217: LD_INT 0
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 1
81226: NEG
81227: PUSH
81228: LD_INT 1
81230: NEG
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 1
81238: NEG
81239: PUSH
81240: LD_INT 2
81242: NEG
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 0
81250: PUSH
81251: LD_INT 2
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 1
81261: PUSH
81262: LD_INT 1
81264: NEG
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 2
81272: PUSH
81273: LD_INT 0
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 2
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 2
81292: PUSH
81293: LD_INT 2
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 1
81302: PUSH
81303: LD_INT 2
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 0
81312: PUSH
81313: LD_INT 2
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 1
81322: NEG
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: NEG
81334: PUSH
81335: LD_INT 0
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 2
81344: NEG
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 2
81356: NEG
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 2
81368: NEG
81369: PUSH
81370: LD_INT 3
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: NEG
81381: PUSH
81382: LD_INT 3
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: LD_INT 2
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: LD_INT 1
81406: NEG
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81437: LD_ADDR_VAR 0 24
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 0
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: LD_INT 0
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 1
81475: PUSH
81476: LD_INT 1
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 0
81485: PUSH
81486: LD_INT 1
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 1
81495: NEG
81496: PUSH
81497: LD_INT 0
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: LD_INT 1
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 1
81518: NEG
81519: PUSH
81520: LD_INT 2
81522: NEG
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: PUSH
81528: LD_INT 0
81530: PUSH
81531: LD_INT 2
81533: NEG
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 1
81541: PUSH
81542: LD_INT 1
81544: NEG
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: LD_INT 0
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 2
81562: PUSH
81563: LD_INT 1
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 2
81572: PUSH
81573: LD_INT 2
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: LD_INT 2
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: LD_INT 2
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 2
81613: NEG
81614: PUSH
81615: LD_INT 0
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 2
81624: NEG
81625: PUSH
81626: LD_INT 1
81628: NEG
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: LD_INT 2
81636: NEG
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 1
81648: PUSH
81649: LD_INT 2
81651: NEG
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 2
81659: PUSH
81660: LD_INT 1
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 3
81670: PUSH
81671: LD_INT 1
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 3
81680: PUSH
81681: LD_INT 2
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81713: LD_ADDR_VAR 0 25
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 0
81730: PUSH
81731: LD_INT 1
81733: NEG
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 1
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 0
81761: PUSH
81762: LD_INT 1
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: LD_INT 0
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: LD_INT 1
81786: NEG
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 0
81806: PUSH
81807: LD_INT 2
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 1
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 2
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 2
81838: PUSH
81839: LD_INT 1
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 2
81848: PUSH
81849: LD_INT 2
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: LD_INT 2
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 0
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 1
81878: NEG
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: NEG
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 2
81900: NEG
81901: PUSH
81902: LD_INT 1
81904: NEG
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: LD_INT 2
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 3
81924: PUSH
81925: LD_INT 1
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 3
81934: PUSH
81935: LD_INT 2
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: LD_INT 3
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 1
81954: PUSH
81955: LD_INT 3
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81987: LD_ADDR_VAR 0 26
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: LD_INT 0
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 0
82004: PUSH
82005: LD_INT 1
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: PUSH
82016: LD_INT 0
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 1
82025: PUSH
82026: LD_INT 1
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 0
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 1
82045: NEG
82046: PUSH
82047: LD_INT 0
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 1
82056: NEG
82057: PUSH
82058: LD_INT 1
82060: NEG
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: LD_INT 1
82068: NEG
82069: PUSH
82070: LD_INT 2
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 0
82080: PUSH
82081: LD_INT 2
82083: NEG
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: LD_INT 1
82094: NEG
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 2
82102: PUSH
82103: LD_INT 0
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 2
82112: PUSH
82113: LD_INT 1
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 2
82122: PUSH
82123: LD_INT 2
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 1
82132: PUSH
82133: LD_INT 2
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 0
82142: PUSH
82143: LD_INT 2
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 1
82152: NEG
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 2
82163: NEG
82164: PUSH
82165: LD_INT 0
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 2
82174: NEG
82175: PUSH
82176: LD_INT 1
82178: NEG
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: LD_INT 2
82190: NEG
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 2
82198: PUSH
82199: LD_INT 3
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 1
82208: PUSH
82209: LD_INT 3
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: LD_INT 2
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 2
82229: NEG
82230: PUSH
82231: LD_INT 1
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82263: LD_ADDR_VAR 0 27
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: LD_INT 0
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: LD_INT 1
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 1
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: LD_INT 1
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 0
82311: PUSH
82312: LD_INT 1
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 1
82321: NEG
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 1
82332: NEG
82333: PUSH
82334: LD_INT 1
82336: NEG
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: LD_INT 2
82348: NEG
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: LD_INT 2
82359: NEG
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: LD_INT 1
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 2
82378: PUSH
82379: LD_INT 0
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 2
82388: PUSH
82389: LD_INT 1
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: LD_INT 2
82398: PUSH
82399: LD_INT 2
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 1
82408: PUSH
82409: LD_INT 2
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 0
82418: PUSH
82419: LD_INT 2
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 1
82428: NEG
82429: PUSH
82430: LD_INT 1
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 2
82439: NEG
82440: PUSH
82441: LD_INT 0
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 2
82450: NEG
82451: PUSH
82452: LD_INT 1
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 2
82462: NEG
82463: PUSH
82464: LD_INT 2
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 1
82474: NEG
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 2
82485: NEG
82486: PUSH
82487: LD_INT 1
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 3
82496: NEG
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 3
82508: NEG
82509: PUSH
82510: LD_INT 2
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82543: LD_ADDR_VAR 0 28
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: PUSH
82572: LD_INT 0
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 0
82591: PUSH
82592: LD_INT 1
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: NEG
82602: PUSH
82603: LD_INT 0
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: LD_INT 1
82616: NEG
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 1
82624: NEG
82625: PUSH
82626: LD_INT 2
82628: NEG
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 0
82636: PUSH
82637: LD_INT 2
82639: NEG
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 1
82647: PUSH
82648: LD_INT 1
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 2
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 2
82668: PUSH
82669: LD_INT 1
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 2
82678: PUSH
82679: LD_INT 2
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: LD_INT 1
82688: PUSH
82689: LD_INT 2
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 0
82698: PUSH
82699: LD_INT 2
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: LD_INT 1
82708: NEG
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 2
82719: NEG
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 2
82742: NEG
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: LD_INT 3
82758: NEG
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 1
82766: NEG
82767: PUSH
82768: LD_INT 3
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 3
82778: NEG
82779: PUSH
82780: LD_INT 1
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 3
82790: NEG
82791: PUSH
82792: LD_INT 2
82794: NEG
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82825: LD_ADDR_VAR 0 29
82829: PUSH
82830: LD_INT 0
82832: PUSH
82833: LD_INT 0
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 0
82842: PUSH
82843: LD_INT 1
82845: NEG
82846: PUSH
82847: EMPTY
82848: LIST
82849: LIST
82850: PUSH
82851: LD_INT 1
82853: PUSH
82854: LD_INT 0
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 1
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 0
82873: PUSH
82874: LD_INT 1
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 1
82883: NEG
82884: PUSH
82885: LD_INT 0
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 1
82894: NEG
82895: PUSH
82896: LD_INT 1
82898: NEG
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 1
82906: NEG
82907: PUSH
82908: LD_INT 2
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 0
82918: PUSH
82919: LD_INT 2
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 1
82929: PUSH
82930: LD_INT 1
82932: NEG
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 2
82940: PUSH
82941: LD_INT 0
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 2
82950: PUSH
82951: LD_INT 1
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 1
82960: PUSH
82961: LD_INT 2
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 0
82970: PUSH
82971: LD_INT 2
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: NEG
82981: PUSH
82982: LD_INT 1
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 2
82991: NEG
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 2
83003: NEG
83004: PUSH
83005: LD_INT 2
83007: NEG
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: NEG
83016: PUSH
83017: LD_INT 3
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: PUSH
83028: LD_INT 1
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 3
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: LD_INT 3
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: NEG
83059: PUSH
83060: LD_INT 2
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 3
83069: NEG
83070: PUSH
83071: LD_INT 2
83073: NEG
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83104: LD_ADDR_VAR 0 30
83108: PUSH
83109: LD_INT 0
83111: PUSH
83112: LD_INT 0
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: LD_INT 1
83124: NEG
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 1
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: PUSH
83143: LD_INT 1
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 0
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 1
83173: NEG
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: LD_INT 2
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 1
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 2
83219: PUSH
83220: LD_INT 0
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 2
83229: PUSH
83230: LD_INT 1
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: LD_INT 2
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 1
83249: PUSH
83250: LD_INT 2
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 1
83259: NEG
83260: PUSH
83261: LD_INT 1
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 2
83270: NEG
83271: PUSH
83272: LD_INT 0
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 2
83281: NEG
83282: PUSH
83283: LD_INT 1
83285: NEG
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: LD_INT 3
83297: NEG
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 1
83305: PUSH
83306: LD_INT 2
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 3
83316: PUSH
83317: LD_INT 2
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 2
83326: PUSH
83327: LD_INT 3
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 2
83336: NEG
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 3
83347: NEG
83348: PUSH
83349: LD_INT 1
83351: NEG
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83382: LD_ADDR_VAR 0 31
83386: PUSH
83387: LD_INT 0
83389: PUSH
83390: LD_INT 0
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 0
83399: PUSH
83400: LD_INT 1
83402: NEG
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 1
83410: PUSH
83411: LD_INT 0
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 1
83420: PUSH
83421: LD_INT 1
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 0
83430: PUSH
83431: LD_INT 1
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 1
83440: NEG
83441: PUSH
83442: LD_INT 0
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 1
83451: NEG
83452: PUSH
83453: LD_INT 1
83455: NEG
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: LD_INT 2
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: LD_INT 1
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 2
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 2
83496: PUSH
83497: LD_INT 1
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 2
83506: PUSH
83507: LD_INT 2
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: LD_INT 2
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 0
83526: PUSH
83527: LD_INT 2
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 1
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: LD_INT 1
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 2
83571: NEG
83572: PUSH
83573: LD_INT 3
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 2
83583: PUSH
83584: LD_INT 1
83586: NEG
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 3
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: LD_INT 3
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 1
83614: NEG
83615: PUSH
83616: LD_INT 2
83618: PUSH
83619: EMPTY
83620: LIST
83621: LIST
83622: PUSH
83623: LD_INT 3
83625: NEG
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83660: LD_ADDR_VAR 0 32
83664: PUSH
83665: LD_INT 0
83667: PUSH
83668: LD_INT 0
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 0
83677: PUSH
83678: LD_INT 1
83680: NEG
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 1
83688: PUSH
83689: LD_INT 0
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 1
83698: PUSH
83699: LD_INT 1
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: LD_INT 1
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 1
83718: NEG
83719: PUSH
83720: LD_INT 0
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 1
83729: NEG
83730: PUSH
83731: LD_INT 1
83733: NEG
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 1
83741: NEG
83742: PUSH
83743: LD_INT 2
83745: NEG
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 0
83753: PUSH
83754: LD_INT 2
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 2
83775: PUSH
83776: LD_INT 1
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 2
83785: PUSH
83786: LD_INT 2
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 1
83795: PUSH
83796: LD_INT 2
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: LD_INT 2
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 1
83815: NEG
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 2
83826: NEG
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 2
83837: NEG
83838: PUSH
83839: LD_INT 1
83841: NEG
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 1
83849: NEG
83850: PUSH
83851: LD_INT 3
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: LD_INT 2
83864: NEG
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: PUSH
83870: LD_INT 3
83872: PUSH
83873: LD_INT 2
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 2
83882: PUSH
83883: LD_INT 3
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 2
83892: NEG
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 3
83903: NEG
83904: PUSH
83905: LD_INT 1
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83938: LD_ADDR_VAR 0 33
83942: PUSH
83943: LD_INT 0
83945: PUSH
83946: LD_INT 0
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 0
83955: PUSH
83956: LD_INT 1
83958: NEG
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 1
83966: PUSH
83967: LD_INT 0
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 1
83976: PUSH
83977: LD_INT 1
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 0
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 1
83996: NEG
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 1
84007: NEG
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 1
84019: NEG
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 1
84031: PUSH
84032: LD_INT 1
84034: NEG
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: PUSH
84043: LD_INT 0
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 2
84052: PUSH
84053: LD_INT 1
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: LD_INT 2
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: LD_INT 2
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: NEG
84083: PUSH
84084: LD_INT 1
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: LD_INT 0
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 2
84104: NEG
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 2
84116: NEG
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 2
84128: NEG
84129: PUSH
84130: LD_INT 3
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 2
84140: PUSH
84141: LD_INT 1
84143: NEG
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 3
84151: PUSH
84152: LD_INT 1
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: PUSH
84162: LD_INT 3
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 1
84171: NEG
84172: PUSH
84173: LD_INT 2
84175: PUSH
84176: EMPTY
84177: LIST
84178: LIST
84179: PUSH
84180: LD_INT 3
84182: NEG
84183: PUSH
84184: LD_INT 2
84186: NEG
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84217: LD_ADDR_VAR 0 34
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: LD_INT 0
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: LD_INT 1
84237: NEG
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 1
84245: PUSH
84246: LD_INT 0
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 1
84255: PUSH
84256: LD_INT 1
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 0
84265: PUSH
84266: LD_INT 1
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 1
84275: NEG
84276: PUSH
84277: LD_INT 0
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 1
84286: NEG
84287: PUSH
84288: LD_INT 1
84290: NEG
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 1
84298: NEG
84299: PUSH
84300: LD_INT 2
84302: NEG
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 0
84310: PUSH
84311: LD_INT 2
84313: NEG
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: LD_INT 1
84324: NEG
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 2
84332: PUSH
84333: LD_INT 1
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 2
84342: PUSH
84343: LD_INT 2
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: LD_INT 2
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 1
84362: NEG
84363: PUSH
84364: LD_INT 1
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 2
84373: NEG
84374: PUSH
84375: LD_INT 0
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 2
84384: NEG
84385: PUSH
84386: LD_INT 1
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 2
84396: NEG
84397: PUSH
84398: LD_INT 2
84400: NEG
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: PUSH
84406: LD_INT 1
84408: NEG
84409: PUSH
84410: LD_INT 3
84412: NEG
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 1
84420: PUSH
84421: LD_INT 2
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 3
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: LD_INT 3
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 2
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 3
84462: NEG
84463: PUSH
84464: LD_INT 1
84466: NEG
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84497: LD_ADDR_VAR 0 35
84501: PUSH
84502: LD_INT 0
84504: PUSH
84505: LD_INT 0
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 0
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 1
84525: PUSH
84526: LD_INT 0
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 1
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: LD_INT 0
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 1
84555: NEG
84556: PUSH
84557: LD_INT 0
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_INT 1
84566: NEG
84567: PUSH
84568: LD_INT 1
84570: NEG
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 2
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 2
84588: NEG
84589: PUSH
84590: LD_INT 1
84592: NEG
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84609: LD_ADDR_VAR 0 36
84613: PUSH
84614: LD_INT 0
84616: PUSH
84617: LD_INT 0
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 0
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 1
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 1
84647: PUSH
84648: LD_INT 1
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 0
84657: PUSH
84658: LD_INT 1
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: NEG
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 1
84678: NEG
84679: PUSH
84680: LD_INT 1
84682: NEG
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: PUSH
84688: LD_INT 1
84690: NEG
84691: PUSH
84692: LD_INT 2
84694: NEG
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: LD_INT 2
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84721: LD_ADDR_VAR 0 37
84725: PUSH
84726: LD_INT 0
84728: PUSH
84729: LD_INT 0
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: LD_INT 1
84741: NEG
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: PUSH
84747: LD_INT 1
84749: PUSH
84750: LD_INT 0
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 1
84759: PUSH
84760: LD_INT 1
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 0
84769: PUSH
84770: LD_INT 1
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: PUSH
84777: LD_INT 1
84779: NEG
84780: PUSH
84781: LD_INT 0
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 1
84790: NEG
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 1
84802: PUSH
84803: LD_INT 1
84805: NEG
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 1
84813: NEG
84814: PUSH
84815: LD_INT 1
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84833: LD_ADDR_VAR 0 38
84837: PUSH
84838: LD_INT 0
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 0
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 1
84861: PUSH
84862: LD_INT 0
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 1
84871: PUSH
84872: LD_INT 1
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 0
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 1
84891: NEG
84892: PUSH
84893: LD_INT 0
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 1
84902: NEG
84903: PUSH
84904: LD_INT 1
84906: NEG
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 2
84914: PUSH
84915: LD_INT 1
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 2
84924: NEG
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84945: LD_ADDR_VAR 0 39
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 0
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: LD_INT 1
84965: NEG
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 1
84973: PUSH
84974: LD_INT 0
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 1
84983: PUSH
84984: LD_INT 1
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: LD_INT 1
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: NEG
85004: PUSH
85005: LD_INT 0
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 1
85014: NEG
85015: PUSH
85016: LD_INT 1
85018: NEG
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 1
85026: NEG
85027: PUSH
85028: LD_INT 2
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: PUSH
85039: LD_INT 2
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85057: LD_ADDR_VAR 0 40
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: LD_INT 0
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 1
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: PUSH
85086: LD_INT 0
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: LD_INT 1
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 0
85105: PUSH
85106: LD_INT 1
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 1
85115: NEG
85116: PUSH
85117: LD_INT 0
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 1
85126: NEG
85127: PUSH
85128: LD_INT 1
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 1
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85169: LD_ADDR_VAR 0 41
85173: PUSH
85174: LD_INT 0
85176: PUSH
85177: LD_INT 0
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 0
85186: PUSH
85187: LD_INT 1
85189: NEG
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 1
85197: PUSH
85198: LD_INT 0
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 1
85207: PUSH
85208: LD_INT 1
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 0
85217: PUSH
85218: LD_INT 1
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 0
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 1
85238: NEG
85239: PUSH
85240: LD_INT 1
85242: NEG
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 1
85250: NEG
85251: PUSH
85252: LD_INT 2
85254: NEG
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: LD_INT 1
85262: PUSH
85263: LD_INT 1
85265: NEG
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PUSH
85271: LD_INT 2
85273: PUSH
85274: LD_INT 0
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: LD_INT 2
85283: PUSH
85284: LD_INT 1
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PUSH
85291: LD_INT 2
85293: PUSH
85294: LD_INT 2
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: LD_INT 2
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: NEG
85314: PUSH
85315: LD_INT 1
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: NEG
85325: PUSH
85326: LD_INT 0
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 2
85335: NEG
85336: PUSH
85337: LD_INT 1
85339: NEG
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 2
85347: NEG
85348: PUSH
85349: LD_INT 2
85351: NEG
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: PUSH
85357: LD_INT 2
85359: NEG
85360: PUSH
85361: LD_INT 3
85363: NEG
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 2
85371: PUSH
85372: LD_INT 1
85374: NEG
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 3
85382: PUSH
85383: LD_INT 0
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 3
85392: PUSH
85393: LD_INT 1
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 3
85402: PUSH
85403: LD_INT 2
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 3
85412: PUSH
85413: LD_INT 3
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: LD_INT 3
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 2
85432: NEG
85433: PUSH
85434: LD_INT 1
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 3
85454: NEG
85455: PUSH
85456: LD_INT 1
85458: NEG
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 3
85466: NEG
85467: PUSH
85468: LD_INT 2
85470: NEG
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PUSH
85476: LD_INT 3
85478: NEG
85479: PUSH
85480: LD_INT 3
85482: NEG
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85519: LD_ADDR_VAR 0 42
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: LD_INT 0
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: LD_INT 1
85539: NEG
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: LD_INT 0
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 1
85557: PUSH
85558: LD_INT 1
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: LD_INT 0
85567: PUSH
85568: LD_INT 1
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 1
85577: NEG
85578: PUSH
85579: LD_INT 0
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: NEG
85589: PUSH
85590: LD_INT 1
85592: NEG
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: LD_INT 2
85604: NEG
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 0
85612: PUSH
85613: LD_INT 2
85615: NEG
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 1
85623: PUSH
85624: LD_INT 1
85626: NEG
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 2
85644: PUSH
85645: LD_INT 2
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: LD_INT 2
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 2
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 1
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 2
85685: NEG
85686: PUSH
85687: LD_INT 1
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 2
85697: NEG
85698: PUSH
85699: LD_INT 2
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 2
85709: NEG
85710: PUSH
85711: LD_INT 3
85713: NEG
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 1
85721: NEG
85722: PUSH
85723: LD_INT 3
85725: NEG
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: LD_INT 3
85736: NEG
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: LD_INT 2
85747: NEG
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 3
85755: PUSH
85756: LD_INT 2
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 3
85765: PUSH
85766: LD_INT 3
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: LD_INT 2
85775: PUSH
85776: LD_INT 3
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: PUSH
85783: LD_INT 1
85785: PUSH
85786: LD_INT 3
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: LD_INT 3
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 1
85805: NEG
85806: PUSH
85807: LD_INT 2
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 3
85816: NEG
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 3
85828: NEG
85829: PUSH
85830: LD_INT 3
85832: NEG
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85869: LD_ADDR_VAR 0 43
85873: PUSH
85874: LD_INT 0
85876: PUSH
85877: LD_INT 0
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 0
85886: PUSH
85887: LD_INT 1
85889: NEG
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 1
85897: PUSH
85898: LD_INT 0
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 1
85907: PUSH
85908: LD_INT 1
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 0
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 1
85927: NEG
85928: PUSH
85929: LD_INT 0
85931: PUSH
85932: EMPTY
85933: LIST
85934: LIST
85935: PUSH
85936: LD_INT 1
85938: NEG
85939: PUSH
85940: LD_INT 1
85942: NEG
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: LD_INT 2
85954: NEG
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 0
85962: PUSH
85963: LD_INT 2
85965: NEG
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 1
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 2
85984: PUSH
85985: LD_INT 0
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 2
85994: PUSH
85995: LD_INT 1
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: LD_INT 2
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: NEG
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 2
86046: NEG
86047: PUSH
86048: LD_INT 1
86050: NEG
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: LD_INT 3
86062: NEG
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: LD_INT 3
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 1
86081: PUSH
86082: LD_INT 2
86084: NEG
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 2
86092: PUSH
86093: LD_INT 1
86095: NEG
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 3
86103: PUSH
86104: LD_INT 0
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 3
86113: PUSH
86114: LD_INT 1
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: PUSH
86124: LD_INT 3
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 3
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 1
86143: NEG
86144: PUSH
86145: LD_INT 2
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 2
86154: NEG
86155: PUSH
86156: LD_INT 1
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 3
86165: NEG
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 3
86176: NEG
86177: PUSH
86178: LD_INT 1
86180: NEG
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86217: LD_ADDR_VAR 0 44
86221: PUSH
86222: LD_INT 0
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: LD_INT 1
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: LD_INT 1
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 0
86265: PUSH
86266: LD_INT 1
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 1
86286: NEG
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: NEG
86299: PUSH
86300: LD_INT 2
86302: NEG
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 1
86310: PUSH
86311: LD_INT 1
86313: NEG
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: LD_INT 0
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: LD_INT 1
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 2
86341: PUSH
86342: LD_INT 2
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 1
86351: PUSH
86352: LD_INT 2
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PUSH
86359: LD_INT 1
86361: NEG
86362: PUSH
86363: LD_INT 1
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 2
86383: NEG
86384: PUSH
86385: LD_INT 1
86387: NEG
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 2
86395: NEG
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 2
86407: NEG
86408: PUSH
86409: LD_INT 3
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 2
86419: PUSH
86420: LD_INT 1
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 3
86430: PUSH
86431: LD_INT 0
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 3
86440: PUSH
86441: LD_INT 1
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 3
86450: PUSH
86451: LD_INT 2
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 3
86460: PUSH
86461: LD_INT 3
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 2
86470: PUSH
86471: LD_INT 3
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 2
86480: NEG
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 3
86491: NEG
86492: PUSH
86493: LD_INT 0
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 3
86502: NEG
86503: PUSH
86504: LD_INT 1
86506: NEG
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 3
86514: NEG
86515: PUSH
86516: LD_INT 2
86518: NEG
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 3
86526: NEG
86527: PUSH
86528: LD_INT 3
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86567: LD_ADDR_VAR 0 45
86571: PUSH
86572: LD_INT 0
86574: PUSH
86575: LD_INT 0
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 0
86584: PUSH
86585: LD_INT 1
86587: NEG
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: LD_INT 0
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: LD_INT 1
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 0
86615: PUSH
86616: LD_INT 1
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 0
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: NEG
86637: PUSH
86638: LD_INT 1
86640: NEG
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 1
86648: NEG
86649: PUSH
86650: LD_INT 2
86652: NEG
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 0
86660: PUSH
86661: LD_INT 2
86663: NEG
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 1
86671: PUSH
86672: LD_INT 1
86674: NEG
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 2
86682: PUSH
86683: LD_INT 1
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: LD_INT 2
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PUSH
86700: LD_INT 1
86702: PUSH
86703: LD_INT 2
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: LD_INT 2
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: LD_INT 1
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 2
86733: NEG
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 2
86745: NEG
86746: PUSH
86747: LD_INT 2
86749: NEG
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 2
86757: NEG
86758: PUSH
86759: LD_INT 3
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: LD_INT 3
86773: NEG
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: LD_INT 3
86784: NEG
86785: PUSH
86786: EMPTY
86787: LIST
86788: LIST
86789: PUSH
86790: LD_INT 1
86792: PUSH
86793: LD_INT 2
86795: NEG
86796: PUSH
86797: EMPTY
86798: LIST
86799: LIST
86800: PUSH
86801: LD_INT 3
86803: PUSH
86804: LD_INT 2
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 3
86813: PUSH
86814: LD_INT 3
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: LD_INT 3
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 1
86833: PUSH
86834: LD_INT 3
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: LD_INT 3
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 1
86853: NEG
86854: PUSH
86855: LD_INT 2
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 3
86864: NEG
86865: PUSH
86866: LD_INT 2
86868: NEG
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: LD_INT 3
86876: NEG
86877: PUSH
86878: LD_INT 3
86880: NEG
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86917: LD_ADDR_VAR 0 46
86921: PUSH
86922: LD_INT 0
86924: PUSH
86925: LD_INT 0
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: LD_INT 1
86937: NEG
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 1
86945: PUSH
86946: LD_INT 0
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: LD_INT 1
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 0
86965: PUSH
86966: LD_INT 1
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: NEG
86976: PUSH
86977: LD_INT 0
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 1
86986: NEG
86987: PUSH
86988: LD_INT 1
86990: NEG
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 1
86998: NEG
86999: PUSH
87000: LD_INT 2
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 0
87010: PUSH
87011: LD_INT 2
87013: NEG
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 1
87021: PUSH
87022: LD_INT 1
87024: NEG
87025: PUSH
87026: EMPTY
87027: LIST
87028: LIST
87029: PUSH
87030: LD_INT 2
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 2
87042: PUSH
87043: LD_INT 1
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: LD_INT 2
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: LD_INT 2
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 1
87072: NEG
87073: PUSH
87074: LD_INT 1
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 2
87083: NEG
87084: PUSH
87085: LD_INT 0
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 2
87094: NEG
87095: PUSH
87096: LD_INT 1
87098: NEG
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 1
87106: NEG
87107: PUSH
87108: LD_INT 3
87110: NEG
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 0
87118: PUSH
87119: LD_INT 3
87121: NEG
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_INT 1
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 2
87140: PUSH
87141: LD_INT 1
87143: NEG
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PUSH
87149: LD_INT 3
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 3
87161: PUSH
87162: LD_INT 1
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: PUSH
87172: LD_INT 3
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 0
87181: PUSH
87182: LD_INT 3
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 1
87191: NEG
87192: PUSH
87193: LD_INT 2
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 2
87202: NEG
87203: PUSH
87204: LD_INT 1
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 3
87213: NEG
87214: PUSH
87215: LD_INT 0
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 3
87224: NEG
87225: PUSH
87226: LD_INT 1
87228: NEG
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87265: LD_ADDR_VAR 0 47
87269: PUSH
87270: LD_INT 0
87272: PUSH
87273: LD_INT 0
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: LD_INT 1
87285: NEG
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: LD_INT 1
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 0
87313: PUSH
87314: LD_INT 1
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: LD_INT 0
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: NEG
87335: PUSH
87336: LD_INT 1
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 1
87346: NEG
87347: PUSH
87348: LD_INT 2
87350: NEG
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 0
87358: PUSH
87359: LD_INT 2
87361: NEG
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 1
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 2
87380: NEG
87381: PUSH
87382: LD_INT 1
87384: NEG
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 2
87392: NEG
87393: PUSH
87394: LD_INT 2
87396: NEG
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87416: LD_ADDR_VAR 0 48
87420: PUSH
87421: LD_INT 0
87423: PUSH
87424: LD_INT 0
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 1
87436: NEG
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: PUSH
87445: LD_INT 0
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: LD_INT 1
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: NEG
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 1
87485: NEG
87486: PUSH
87487: LD_INT 1
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: NEG
87498: PUSH
87499: LD_INT 2
87501: NEG
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 0
87509: PUSH
87510: LD_INT 2
87512: NEG
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 1
87520: PUSH
87521: LD_INT 1
87523: NEG
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 2
87531: PUSH
87532: LD_INT 0
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: LD_INT 1
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87563: LD_ADDR_VAR 0 49
87567: PUSH
87568: LD_INT 0
87570: PUSH
87571: LD_INT 0
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 0
87580: PUSH
87581: LD_INT 1
87583: NEG
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: LD_INT 0
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 1
87601: PUSH
87602: LD_INT 1
87604: PUSH
87605: EMPTY
87606: LIST
87607: LIST
87608: PUSH
87609: LD_INT 0
87611: PUSH
87612: LD_INT 1
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 1
87621: NEG
87622: PUSH
87623: LD_INT 0
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 1
87632: NEG
87633: PUSH
87634: LD_INT 1
87636: NEG
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 1
87644: PUSH
87645: LD_INT 1
87647: NEG
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 2
87655: PUSH
87656: LD_INT 0
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 2
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: EMPTY
87670: LIST
87671: LIST
87672: PUSH
87673: LD_INT 2
87675: PUSH
87676: LD_INT 2
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 1
87685: PUSH
87686: LD_INT 2
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: PUSH
87693: EMPTY
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87707: LD_ADDR_VAR 0 50
87711: PUSH
87712: LD_INT 0
87714: PUSH
87715: LD_INT 0
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 0
87724: PUSH
87725: LD_INT 1
87727: NEG
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 1
87735: PUSH
87736: LD_INT 0
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: LD_INT 1
87745: PUSH
87746: LD_INT 1
87748: PUSH
87749: EMPTY
87750: LIST
87751: LIST
87752: PUSH
87753: LD_INT 0
87755: PUSH
87756: LD_INT 1
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: LD_INT 0
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: LD_INT 1
87776: NEG
87777: PUSH
87778: LD_INT 1
87780: NEG
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 2
87788: PUSH
87789: LD_INT 1
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 2
87798: PUSH
87799: LD_INT 2
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: PUSH
87806: LD_INT 1
87808: PUSH
87809: LD_INT 2
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: PUSH
87816: LD_INT 0
87818: PUSH
87819: LD_INT 2
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: LD_INT 1
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87851: LD_ADDR_VAR 0 51
87855: PUSH
87856: LD_INT 0
87858: PUSH
87859: LD_INT 0
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 0
87868: PUSH
87869: LD_INT 1
87871: NEG
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 1
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: PUSH
87890: LD_INT 1
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: LD_INT 1
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 1
87920: NEG
87921: PUSH
87922: LD_INT 1
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 1
87932: PUSH
87933: LD_INT 2
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 0
87942: PUSH
87943: LD_INT 2
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 1
87952: NEG
87953: PUSH
87954: LD_INT 1
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 2
87974: NEG
87975: PUSH
87976: LD_INT 1
87978: NEG
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87998: LD_ADDR_VAR 0 52
88002: PUSH
88003: LD_INT 0
88005: PUSH
88006: LD_INT 0
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 1
88018: NEG
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 1
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: LD_INT 1
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 0
88046: PUSH
88047: LD_INT 1
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 1
88056: NEG
88057: PUSH
88058: LD_INT 0
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 1
88067: NEG
88068: PUSH
88069: LD_INT 1
88071: NEG
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 1
88079: NEG
88080: PUSH
88081: LD_INT 2
88083: NEG
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 1
88091: NEG
88092: PUSH
88093: LD_INT 1
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: LD_INT 0
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 2
88113: NEG
88114: PUSH
88115: LD_INT 1
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 2
88125: NEG
88126: PUSH
88127: LD_INT 2
88129: NEG
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88149: LD_ADDR_VAR 0 53
88153: PUSH
88154: LD_INT 0
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: LD_INT 1
88169: NEG
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 1
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 0
88197: PUSH
88198: LD_INT 1
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: NEG
88208: PUSH
88209: LD_INT 0
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 1
88222: NEG
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: LD_INT 2
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: LD_INT 2
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 1
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 2
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 2
88284: PUSH
88285: LD_INT 2
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 1
88294: PUSH
88295: LD_INT 2
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 0
88304: PUSH
88305: LD_INT 2
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 1
88314: NEG
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 2
88325: NEG
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 2
88336: NEG
88337: PUSH
88338: LD_INT 1
88340: NEG
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 2
88348: NEG
88349: PUSH
88350: LD_INT 2
88352: NEG
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88379: LD_ADDR_VAR 0 54
88383: PUSH
88384: LD_INT 0
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: LD_INT 1
88399: NEG
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 1
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: PUSH
88418: LD_INT 1
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 1
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: NEG
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: LD_INT 1
88452: NEG
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 1
88460: NEG
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: LD_INT 2
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 1
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 2
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 2
88514: PUSH
88515: LD_INT 2
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: LD_INT 2
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 0
88534: PUSH
88535: LD_INT 2
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 2
88555: NEG
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 2
88566: NEG
88567: PUSH
88568: LD_INT 1
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 2
88578: NEG
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88609: LD_ADDR_VAR 0 55
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: LD_INT 1
88629: NEG
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: PUSH
88635: LD_INT 1
88637: PUSH
88638: LD_INT 0
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: PUSH
88645: LD_INT 1
88647: PUSH
88648: LD_INT 1
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: LD_INT 1
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 1
88667: NEG
88668: PUSH
88669: LD_INT 0
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: NEG
88679: PUSH
88680: LD_INT 1
88682: NEG
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: NEG
88691: PUSH
88692: LD_INT 2
88694: NEG
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 0
88702: PUSH
88703: LD_INT 2
88705: NEG
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 2
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 2
88734: PUSH
88735: LD_INT 1
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 2
88744: PUSH
88745: LD_INT 2
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 1
88754: PUSH
88755: LD_INT 2
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: LD_INT 2
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 1
88774: NEG
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: NEG
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 2
88796: NEG
88797: PUSH
88798: LD_INT 1
88800: NEG
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 2
88808: NEG
88809: PUSH
88810: LD_INT 2
88812: NEG
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88839: LD_ADDR_VAR 0 56
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: LD_INT 0
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 0
88856: PUSH
88857: LD_INT 1
88859: NEG
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 1
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 1
88877: PUSH
88878: LD_INT 1
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: PUSH
88885: LD_INT 0
88887: PUSH
88888: LD_INT 1
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 1
88897: NEG
88898: PUSH
88899: LD_INT 0
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: LD_INT 1
88908: NEG
88909: PUSH
88910: LD_INT 1
88912: NEG
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 0
88932: PUSH
88933: LD_INT 2
88935: NEG
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 1
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 2
88954: PUSH
88955: LD_INT 0
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 2
88964: PUSH
88965: LD_INT 1
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 2
88974: PUSH
88975: LD_INT 2
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: LD_INT 1
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 0
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PUSH
89002: LD_INT 1
89004: NEG
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 2
89015: NEG
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 2
89026: NEG
89027: PUSH
89028: LD_INT 1
89030: NEG
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 2
89038: NEG
89039: PUSH
89040: LD_INT 2
89042: NEG
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89069: LD_ADDR_VAR 0 57
89073: PUSH
89074: LD_INT 0
89076: PUSH
89077: LD_INT 0
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 0
89086: PUSH
89087: LD_INT 1
89089: NEG
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: LD_INT 0
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: PUSH
89108: LD_INT 1
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PUSH
89115: LD_INT 0
89117: PUSH
89118: LD_INT 1
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: LD_INT 1
89127: NEG
89128: PUSH
89129: LD_INT 0
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: NEG
89139: PUSH
89140: LD_INT 1
89142: NEG
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 1
89150: NEG
89151: PUSH
89152: LD_INT 2
89154: NEG
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 0
89162: PUSH
89163: LD_INT 2
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: LD_INT 1
89176: NEG
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 2
89184: PUSH
89185: LD_INT 0
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 2
89194: PUSH
89195: LD_INT 1
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 2
89204: PUSH
89205: LD_INT 2
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 1
89214: PUSH
89215: LD_INT 2
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 0
89224: PUSH
89225: LD_INT 2
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: NEG
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 2
89245: NEG
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 2
89256: NEG
89257: PUSH
89258: LD_INT 1
89260: NEG
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 2
89268: NEG
89269: PUSH
89270: LD_INT 2
89272: NEG
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89299: LD_ADDR_VAR 0 58
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: LD_INT 0
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 0
89316: PUSH
89317: LD_INT 1
89319: NEG
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PUSH
89325: LD_INT 1
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: LD_INT 1
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 0
89347: PUSH
89348: LD_INT 1
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: NEG
89358: PUSH
89359: LD_INT 0
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 1
89368: NEG
89369: PUSH
89370: LD_INT 1
89372: NEG
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 1
89380: NEG
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: LD_INT 2
89395: NEG
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: LD_INT 1
89406: NEG
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: PUSH
89412: LD_INT 2
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: EMPTY
89419: LIST
89420: LIST
89421: PUSH
89422: LD_INT 2
89424: PUSH
89425: LD_INT 1
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 2
89434: PUSH
89435: LD_INT 2
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: LD_INT 2
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 0
89454: PUSH
89455: LD_INT 2
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 1
89464: NEG
89465: PUSH
89466: LD_INT 1
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 2
89475: NEG
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 2
89486: NEG
89487: PUSH
89488: LD_INT 1
89490: NEG
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 2
89498: NEG
89499: PUSH
89500: LD_INT 2
89502: NEG
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89529: LD_ADDR_VAR 0 59
89533: PUSH
89534: LD_INT 0
89536: PUSH
89537: LD_INT 0
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 0
89546: PUSH
89547: LD_INT 1
89549: NEG
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 1
89557: PUSH
89558: LD_INT 0
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 1
89567: PUSH
89568: LD_INT 1
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: LD_INT 1
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 1
89587: NEG
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: PUSH
89600: LD_INT 1
89602: NEG
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89617: LD_ADDR_VAR 0 60
89621: PUSH
89622: LD_INT 0
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: LD_INT 1
89637: NEG
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 1
89645: PUSH
89646: LD_INT 0
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 1
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 0
89665: PUSH
89666: LD_INT 1
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: LD_INT 1
89686: NEG
89687: PUSH
89688: LD_INT 1
89690: NEG
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89705: LD_ADDR_VAR 0 61
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 0
89722: PUSH
89723: LD_INT 1
89725: NEG
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: PUSH
89731: LD_INT 1
89733: PUSH
89734: LD_INT 0
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 1
89743: PUSH
89744: LD_INT 1
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 0
89753: PUSH
89754: LD_INT 1
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 1
89763: NEG
89764: PUSH
89765: LD_INT 0
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 1
89774: NEG
89775: PUSH
89776: LD_INT 1
89778: NEG
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89793: LD_ADDR_VAR 0 62
89797: PUSH
89798: LD_INT 0
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 0
89810: PUSH
89811: LD_INT 1
89813: NEG
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 1
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: PUSH
89829: LD_INT 1
89831: PUSH
89832: LD_INT 1
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: PUSH
89839: LD_INT 0
89841: PUSH
89842: LD_INT 1
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: NEG
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: PUSH
89860: LD_INT 1
89862: NEG
89863: PUSH
89864: LD_INT 1
89866: NEG
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89881: LD_ADDR_VAR 0 63
89885: PUSH
89886: LD_INT 0
89888: PUSH
89889: LD_INT 0
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: LD_INT 1
89901: NEG
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 1
89909: PUSH
89910: LD_INT 0
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: LD_INT 1
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 0
89929: PUSH
89930: LD_INT 1
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 1
89939: NEG
89940: PUSH
89941: LD_INT 0
89943: PUSH
89944: EMPTY
89945: LIST
89946: LIST
89947: PUSH
89948: LD_INT 1
89950: NEG
89951: PUSH
89952: LD_INT 1
89954: NEG
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89969: LD_ADDR_VAR 0 64
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 0
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 0
89986: PUSH
89987: LD_INT 1
89989: NEG
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: LD_INT 0
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: LD_INT 1
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 0
90017: PUSH
90018: LD_INT 1
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: LD_INT 0
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 1
90038: NEG
90039: PUSH
90040: LD_INT 1
90042: NEG
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: ST_TO_ADDR
// end ; 1 :
90057: GO 95954
90059: LD_INT 1
90061: DOUBLE
90062: EQUAL
90063: IFTRUE 90067
90065: GO 92690
90067: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90068: LD_ADDR_VAR 0 11
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: LD_INT 3
90079: NEG
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 0
90087: PUSH
90088: LD_INT 3
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 1
90098: PUSH
90099: LD_INT 2
90101: NEG
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: LIST
90111: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90112: LD_ADDR_VAR 0 12
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 3
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 3
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: LIST
90152: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90153: LD_ADDR_VAR 0 13
90157: PUSH
90158: LD_INT 3
90160: PUSH
90161: LD_INT 2
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 3
90170: PUSH
90171: LD_INT 3
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 2
90180: PUSH
90181: LD_INT 3
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: LIST
90192: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90193: LD_ADDR_VAR 0 14
90197: PUSH
90198: LD_INT 1
90200: PUSH
90201: LD_INT 3
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 0
90210: PUSH
90211: LD_INT 3
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 1
90220: NEG
90221: PUSH
90222: LD_INT 2
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: LIST
90233: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90234: LD_ADDR_VAR 0 15
90238: PUSH
90239: LD_INT 2
90241: NEG
90242: PUSH
90243: LD_INT 1
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 3
90252: NEG
90253: PUSH
90254: LD_INT 0
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: LD_INT 3
90263: NEG
90264: PUSH
90265: LD_INT 1
90267: NEG
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: LIST
90277: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90278: LD_ADDR_VAR 0 16
90282: PUSH
90283: LD_INT 2
90285: NEG
90286: PUSH
90287: LD_INT 3
90289: NEG
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 3
90297: NEG
90298: PUSH
90299: LD_INT 2
90301: NEG
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 3
90309: NEG
90310: PUSH
90311: LD_INT 3
90313: NEG
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: LIST
90323: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90324: LD_ADDR_VAR 0 17
90328: PUSH
90329: LD_INT 1
90331: NEG
90332: PUSH
90333: LD_INT 3
90335: NEG
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: LD_INT 3
90346: NEG
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: LD_INT 2
90357: NEG
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: LIST
90367: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90368: LD_ADDR_VAR 0 18
90372: PUSH
90373: LD_INT 2
90375: PUSH
90376: LD_INT 1
90378: NEG
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: PUSH
90384: LD_INT 3
90386: PUSH
90387: LD_INT 0
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 3
90396: PUSH
90397: LD_INT 1
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: LIST
90408: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90409: LD_ADDR_VAR 0 19
90413: PUSH
90414: LD_INT 3
90416: PUSH
90417: LD_INT 2
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 3
90426: PUSH
90427: LD_INT 3
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 2
90436: PUSH
90437: LD_INT 3
90439: PUSH
90440: EMPTY
90441: LIST
90442: LIST
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: LIST
90448: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90449: LD_ADDR_VAR 0 20
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: LD_INT 3
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 0
90466: PUSH
90467: LD_INT 3
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 1
90476: NEG
90477: PUSH
90478: LD_INT 2
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PUSH
90485: EMPTY
90486: LIST
90487: LIST
90488: LIST
90489: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90490: LD_ADDR_VAR 0 21
90494: PUSH
90495: LD_INT 2
90497: NEG
90498: PUSH
90499: LD_INT 1
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 3
90508: NEG
90509: PUSH
90510: LD_INT 0
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 3
90519: NEG
90520: PUSH
90521: LD_INT 1
90523: NEG
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: LIST
90533: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90534: LD_ADDR_VAR 0 22
90538: PUSH
90539: LD_INT 2
90541: NEG
90542: PUSH
90543: LD_INT 3
90545: NEG
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 3
90553: NEG
90554: PUSH
90555: LD_INT 2
90557: NEG
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: LD_INT 3
90565: NEG
90566: PUSH
90567: LD_INT 3
90569: NEG
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: LIST
90579: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90580: LD_ADDR_VAR 0 23
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: LD_INT 3
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: NEG
90599: PUSH
90600: LD_INT 4
90602: NEG
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 1
90610: PUSH
90611: LD_INT 3
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: LIST
90623: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90624: LD_ADDR_VAR 0 24
90628: PUSH
90629: LD_INT 3
90631: PUSH
90632: LD_INT 0
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 3
90641: PUSH
90642: LD_INT 1
90644: NEG
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 4
90652: PUSH
90653: LD_INT 1
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90665: LD_ADDR_VAR 0 25
90669: PUSH
90670: LD_INT 3
90672: PUSH
90673: LD_INT 3
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 4
90682: PUSH
90683: LD_INT 3
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: LD_INT 3
90692: PUSH
90693: LD_INT 4
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: LIST
90704: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90705: LD_ADDR_VAR 0 26
90709: PUSH
90710: LD_INT 0
90712: PUSH
90713: LD_INT 3
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 4
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 1
90732: NEG
90733: PUSH
90734: LD_INT 3
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: LIST
90745: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90746: LD_ADDR_VAR 0 27
90750: PUSH
90751: LD_INT 3
90753: NEG
90754: PUSH
90755: LD_INT 0
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 3
90764: NEG
90765: PUSH
90766: LD_INT 1
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 4
90775: NEG
90776: PUSH
90777: LD_INT 1
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: LIST
90789: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90790: LD_ADDR_VAR 0 28
90794: PUSH
90795: LD_INT 3
90797: NEG
90798: PUSH
90799: LD_INT 3
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 3
90809: NEG
90810: PUSH
90811: LD_INT 4
90813: NEG
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 4
90821: NEG
90822: PUSH
90823: LD_INT 3
90825: NEG
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: LIST
90835: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90836: LD_ADDR_VAR 0 29
90840: PUSH
90841: LD_INT 1
90843: NEG
90844: PUSH
90845: LD_INT 3
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 0
90855: PUSH
90856: LD_INT 3
90858: NEG
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 1
90866: PUSH
90867: LD_INT 2
90869: NEG
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 1
90877: NEG
90878: PUSH
90879: LD_INT 4
90881: NEG
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: LD_INT 4
90892: NEG
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 1
90900: PUSH
90901: LD_INT 3
90903: NEG
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 1
90911: NEG
90912: PUSH
90913: LD_INT 5
90915: NEG
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: LD_INT 5
90926: NEG
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 1
90934: PUSH
90935: LD_INT 4
90937: NEG
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 1
90945: NEG
90946: PUSH
90947: LD_INT 6
90949: NEG
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: LD_INT 6
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: LD_INT 5
90971: NEG
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90991: LD_ADDR_VAR 0 30
90995: PUSH
90996: LD_INT 2
90998: PUSH
90999: LD_INT 1
91001: NEG
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: LD_INT 3
91009: PUSH
91010: LD_INT 0
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 3
91019: PUSH
91020: LD_INT 1
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: PUSH
91027: LD_INT 3
91029: PUSH
91030: LD_INT 1
91032: NEG
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 4
91040: PUSH
91041: LD_INT 0
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 4
91050: PUSH
91051: LD_INT 1
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 4
91060: PUSH
91061: LD_INT 1
91063: NEG
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 5
91071: PUSH
91072: LD_INT 0
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 5
91081: PUSH
91082: LD_INT 1
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 5
91091: PUSH
91092: LD_INT 1
91094: NEG
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 6
91102: PUSH
91103: LD_INT 0
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: PUSH
91110: LD_INT 6
91112: PUSH
91113: LD_INT 1
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91134: LD_ADDR_VAR 0 31
91138: PUSH
91139: LD_INT 3
91141: PUSH
91142: LD_INT 2
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 3
91151: PUSH
91152: LD_INT 3
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 2
91161: PUSH
91162: LD_INT 3
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 4
91171: PUSH
91172: LD_INT 3
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 4
91181: PUSH
91182: LD_INT 4
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 3
91191: PUSH
91192: LD_INT 4
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 5
91201: PUSH
91202: LD_INT 4
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 5
91211: PUSH
91212: LD_INT 5
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 4
91221: PUSH
91222: LD_INT 5
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 6
91231: PUSH
91232: LD_INT 5
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 6
91241: PUSH
91242: LD_INT 6
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 5
91251: PUSH
91252: LD_INT 6
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91273: LD_ADDR_VAR 0 32
91277: PUSH
91278: LD_INT 1
91280: PUSH
91281: LD_INT 3
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 0
91290: PUSH
91291: LD_INT 3
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 1
91300: NEG
91301: PUSH
91302: LD_INT 2
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: LD_INT 4
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: LD_INT 4
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: LD_INT 3
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: LD_INT 5
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: LD_INT 5
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: LD_INT 4
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 1
91373: PUSH
91374: LD_INT 6
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: LD_INT 6
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: LD_INT 1
91393: NEG
91394: PUSH
91395: LD_INT 5
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91416: LD_ADDR_VAR 0 33
91420: PUSH
91421: LD_INT 2
91423: NEG
91424: PUSH
91425: LD_INT 1
91427: PUSH
91428: EMPTY
91429: LIST
91430: LIST
91431: PUSH
91432: LD_INT 3
91434: NEG
91435: PUSH
91436: LD_INT 0
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 3
91445: NEG
91446: PUSH
91447: LD_INT 1
91449: NEG
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 3
91457: NEG
91458: PUSH
91459: LD_INT 1
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 4
91468: NEG
91469: PUSH
91470: LD_INT 0
91472: PUSH
91473: EMPTY
91474: LIST
91475: LIST
91476: PUSH
91477: LD_INT 4
91479: NEG
91480: PUSH
91481: LD_INT 1
91483: NEG
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 4
91491: NEG
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 5
91502: NEG
91503: PUSH
91504: LD_INT 0
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 5
91513: NEG
91514: PUSH
91515: LD_INT 1
91517: NEG
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 5
91525: NEG
91526: PUSH
91527: LD_INT 1
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 6
91536: NEG
91537: PUSH
91538: LD_INT 0
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: LD_INT 6
91547: NEG
91548: PUSH
91549: LD_INT 1
91551: NEG
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91571: LD_ADDR_VAR 0 34
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: LD_INT 3
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 3
91590: NEG
91591: PUSH
91592: LD_INT 2
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 3
91602: NEG
91603: PUSH
91604: LD_INT 3
91606: NEG
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 3
91614: NEG
91615: PUSH
91616: LD_INT 4
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 4
91626: NEG
91627: PUSH
91628: LD_INT 3
91630: NEG
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 4
91638: NEG
91639: PUSH
91640: LD_INT 4
91642: NEG
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 4
91650: NEG
91651: PUSH
91652: LD_INT 5
91654: NEG
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 5
91662: NEG
91663: PUSH
91664: LD_INT 4
91666: NEG
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 5
91674: NEG
91675: PUSH
91676: LD_INT 5
91678: NEG
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 5
91686: NEG
91687: PUSH
91688: LD_INT 6
91690: NEG
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 6
91698: NEG
91699: PUSH
91700: LD_INT 5
91702: NEG
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: PUSH
91708: LD_INT 6
91710: NEG
91711: PUSH
91712: LD_INT 6
91714: NEG
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91734: LD_ADDR_VAR 0 41
91738: PUSH
91739: LD_INT 0
91741: PUSH
91742: LD_INT 2
91744: NEG
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 1
91752: NEG
91753: PUSH
91754: LD_INT 3
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 1
91764: PUSH
91765: LD_INT 2
91767: NEG
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: LIST
91777: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91778: LD_ADDR_VAR 0 42
91782: PUSH
91783: LD_INT 2
91785: PUSH
91786: LD_INT 0
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 2
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 3
91806: PUSH
91807: LD_INT 1
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: LIST
91818: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91819: LD_ADDR_VAR 0 43
91823: PUSH
91824: LD_INT 2
91826: PUSH
91827: LD_INT 2
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 3
91836: PUSH
91837: LD_INT 2
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 2
91846: PUSH
91847: LD_INT 3
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: PUSH
91854: EMPTY
91855: LIST
91856: LIST
91857: LIST
91858: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91859: LD_ADDR_VAR 0 44
91863: PUSH
91864: LD_INT 0
91866: PUSH
91867: LD_INT 2
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: PUSH
91874: LD_INT 1
91876: PUSH
91877: LD_INT 3
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 1
91886: NEG
91887: PUSH
91888: LD_INT 2
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: LIST
91899: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91900: LD_ADDR_VAR 0 45
91904: PUSH
91905: LD_INT 2
91907: NEG
91908: PUSH
91909: LD_INT 0
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 2
91918: NEG
91919: PUSH
91920: LD_INT 1
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: PUSH
91927: LD_INT 3
91929: NEG
91930: PUSH
91931: LD_INT 1
91933: NEG
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: LIST
91943: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91944: LD_ADDR_VAR 0 46
91948: PUSH
91949: LD_INT 2
91951: NEG
91952: PUSH
91953: LD_INT 2
91955: NEG
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 2
91963: NEG
91964: PUSH
91965: LD_INT 3
91967: NEG
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: NEG
91976: PUSH
91977: LD_INT 2
91979: NEG
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: LIST
91989: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91990: LD_ADDR_VAR 0 47
91994: PUSH
91995: LD_INT 2
91997: NEG
91998: PUSH
91999: LD_INT 3
92001: NEG
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: PUSH
92007: LD_INT 1
92009: NEG
92010: PUSH
92011: LD_INT 3
92013: NEG
92014: PUSH
92015: EMPTY
92016: LIST
92017: LIST
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92023: LD_ADDR_VAR 0 48
92027: PUSH
92028: LD_INT 1
92030: PUSH
92031: LD_INT 2
92033: NEG
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 2
92041: PUSH
92042: LD_INT 1
92044: NEG
92045: PUSH
92046: EMPTY
92047: LIST
92048: LIST
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92054: LD_ADDR_VAR 0 49
92058: PUSH
92059: LD_INT 3
92061: PUSH
92062: LD_INT 1
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 3
92071: PUSH
92072: LD_INT 2
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: EMPTY
92080: LIST
92081: LIST
92082: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92083: LD_ADDR_VAR 0 50
92087: PUSH
92088: LD_INT 2
92090: PUSH
92091: LD_INT 3
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 1
92100: PUSH
92101: LD_INT 3
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92112: LD_ADDR_VAR 0 51
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: LD_INT 2
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 2
92130: NEG
92131: PUSH
92132: LD_INT 1
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92143: LD_ADDR_VAR 0 52
92147: PUSH
92148: LD_INT 3
92150: NEG
92151: PUSH
92152: LD_INT 1
92154: NEG
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: PUSH
92160: LD_INT 3
92162: NEG
92163: PUSH
92164: LD_INT 2
92166: NEG
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92176: LD_ADDR_VAR 0 53
92180: PUSH
92181: LD_INT 1
92183: NEG
92184: PUSH
92185: LD_INT 3
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 0
92195: PUSH
92196: LD_INT 3
92198: NEG
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 1
92206: PUSH
92207: LD_INT 2
92209: NEG
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: LIST
92219: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92220: LD_ADDR_VAR 0 54
92224: PUSH
92225: LD_INT 2
92227: PUSH
92228: LD_INT 1
92230: NEG
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 3
92238: PUSH
92239: LD_INT 0
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 3
92248: PUSH
92249: LD_INT 1
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: LIST
92260: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92261: LD_ADDR_VAR 0 55
92265: PUSH
92266: LD_INT 3
92268: PUSH
92269: LD_INT 2
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 3
92278: PUSH
92279: LD_INT 3
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 2
92288: PUSH
92289: LD_INT 3
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: LIST
92300: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92301: LD_ADDR_VAR 0 56
92305: PUSH
92306: LD_INT 1
92308: PUSH
92309: LD_INT 3
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 0
92318: PUSH
92319: LD_INT 3
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: LD_INT 2
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: LIST
92341: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92342: LD_ADDR_VAR 0 57
92346: PUSH
92347: LD_INT 2
92349: NEG
92350: PUSH
92351: LD_INT 1
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 3
92360: NEG
92361: PUSH
92362: LD_INT 0
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: LD_INT 3
92371: NEG
92372: PUSH
92373: LD_INT 1
92375: NEG
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: LIST
92385: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92386: LD_ADDR_VAR 0 58
92390: PUSH
92391: LD_INT 2
92393: NEG
92394: PUSH
92395: LD_INT 3
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: LD_INT 2
92409: NEG
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 3
92417: NEG
92418: PUSH
92419: LD_INT 3
92421: NEG
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: LIST
92431: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92432: LD_ADDR_VAR 0 59
92436: PUSH
92437: LD_INT 1
92439: NEG
92440: PUSH
92441: LD_INT 2
92443: NEG
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: LD_INT 0
92451: PUSH
92452: LD_INT 2
92454: NEG
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: LD_INT 1
92462: PUSH
92463: LD_INT 1
92465: NEG
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: LIST
92475: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92476: LD_ADDR_VAR 0 60
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: LD_INT 1
92486: NEG
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 2
92494: PUSH
92495: LD_INT 0
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: LD_INT 2
92504: PUSH
92505: LD_INT 1
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: LIST
92516: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92517: LD_ADDR_VAR 0 61
92521: PUSH
92522: LD_INT 2
92524: PUSH
92525: LD_INT 1
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 2
92534: PUSH
92535: LD_INT 2
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 1
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: LIST
92556: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92557: LD_ADDR_VAR 0 62
92561: PUSH
92562: LD_INT 1
92564: PUSH
92565: LD_INT 2
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: LD_INT 0
92574: PUSH
92575: LD_INT 2
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: LD_INT 1
92584: NEG
92585: PUSH
92586: LD_INT 1
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: LIST
92597: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92598: LD_ADDR_VAR 0 63
92602: PUSH
92603: LD_INT 1
92605: NEG
92606: PUSH
92607: LD_INT 1
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 2
92616: NEG
92617: PUSH
92618: LD_INT 0
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: NEG
92628: PUSH
92629: LD_INT 1
92631: NEG
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: LIST
92641: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92642: LD_ADDR_VAR 0 64
92646: PUSH
92647: LD_INT 1
92649: NEG
92650: PUSH
92651: LD_INT 2
92653: NEG
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 2
92661: NEG
92662: PUSH
92663: LD_INT 1
92665: NEG
92666: PUSH
92667: EMPTY
92668: LIST
92669: LIST
92670: PUSH
92671: LD_INT 2
92673: NEG
92674: PUSH
92675: LD_INT 2
92677: NEG
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: LIST
92687: ST_TO_ADDR
// end ; 2 :
92688: GO 95954
92690: LD_INT 2
92692: DOUBLE
92693: EQUAL
92694: IFTRUE 92698
92696: GO 95953
92698: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92699: LD_ADDR_VAR 0 29
92703: PUSH
92704: LD_INT 4
92706: PUSH
92707: LD_INT 0
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 4
92716: PUSH
92717: LD_INT 1
92719: NEG
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 5
92727: PUSH
92728: LD_INT 0
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 5
92737: PUSH
92738: LD_INT 1
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 4
92747: PUSH
92748: LD_INT 1
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: PUSH
92755: LD_INT 3
92757: PUSH
92758: LD_INT 0
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 3
92767: PUSH
92768: LD_INT 1
92770: NEG
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 3
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 5
92789: PUSH
92790: LD_INT 2
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 3
92799: PUSH
92800: LD_INT 3
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: PUSH
92807: LD_INT 3
92809: PUSH
92810: LD_INT 2
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 4
92819: PUSH
92820: LD_INT 3
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 4
92829: PUSH
92830: LD_INT 4
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 3
92839: PUSH
92840: LD_INT 4
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 2
92849: PUSH
92850: LD_INT 3
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 2
92859: PUSH
92860: LD_INT 2
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 4
92869: PUSH
92870: LD_INT 2
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 2
92879: PUSH
92880: LD_INT 4
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 0
92889: PUSH
92890: LD_INT 4
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 0
92899: PUSH
92900: LD_INT 3
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 1
92909: PUSH
92910: LD_INT 4
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 1
92919: PUSH
92920: LD_INT 5
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 0
92929: PUSH
92930: LD_INT 5
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 1
92939: NEG
92940: PUSH
92941: LD_INT 4
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: LD_INT 3
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 2
92961: PUSH
92962: LD_INT 5
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 2
92971: NEG
92972: PUSH
92973: LD_INT 3
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 3
92982: NEG
92983: PUSH
92984: LD_INT 0
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 3
92993: NEG
92994: PUSH
92995: LD_INT 1
92997: NEG
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 2
93005: NEG
93006: PUSH
93007: LD_INT 0
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 2
93016: NEG
93017: PUSH
93018: LD_INT 1
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 3
93027: NEG
93028: PUSH
93029: LD_INT 1
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: PUSH
93036: LD_INT 4
93038: NEG
93039: PUSH
93040: LD_INT 0
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PUSH
93047: LD_INT 4
93049: NEG
93050: PUSH
93051: LD_INT 1
93053: NEG
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: PUSH
93059: LD_INT 4
93061: NEG
93062: PUSH
93063: LD_INT 2
93065: NEG
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 2
93073: NEG
93074: PUSH
93075: LD_INT 2
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 4
93084: NEG
93085: PUSH
93086: LD_INT 4
93088: NEG
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 4
93096: NEG
93097: PUSH
93098: LD_INT 5
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 3
93108: NEG
93109: PUSH
93110: LD_INT 4
93112: NEG
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 3
93120: NEG
93121: PUSH
93122: LD_INT 3
93124: NEG
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 4
93132: NEG
93133: PUSH
93134: LD_INT 3
93136: NEG
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 5
93144: NEG
93145: PUSH
93146: LD_INT 4
93148: NEG
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 5
93156: NEG
93157: PUSH
93158: LD_INT 5
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 3
93168: NEG
93169: PUSH
93170: LD_INT 5
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 5
93180: NEG
93181: PUSH
93182: LD_INT 3
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93237: LD_ADDR_VAR 0 30
93241: PUSH
93242: LD_INT 4
93244: PUSH
93245: LD_INT 4
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PUSH
93252: LD_INT 4
93254: PUSH
93255: LD_INT 3
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 5
93264: PUSH
93265: LD_INT 4
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 5
93274: PUSH
93275: LD_INT 5
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 4
93284: PUSH
93285: LD_INT 5
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 3
93294: PUSH
93295: LD_INT 4
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 3
93304: PUSH
93305: LD_INT 3
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 5
93314: PUSH
93315: LD_INT 3
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 3
93324: PUSH
93325: LD_INT 5
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 0
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 0
93344: PUSH
93345: LD_INT 2
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 1
93354: PUSH
93355: LD_INT 3
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 1
93364: PUSH
93365: LD_INT 4
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 0
93374: PUSH
93375: LD_INT 4
93377: PUSH
93378: EMPTY
93379: LIST
93380: LIST
93381: PUSH
93382: LD_INT 1
93384: NEG
93385: PUSH
93386: LD_INT 3
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 1
93395: NEG
93396: PUSH
93397: LD_INT 2
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 2
93406: PUSH
93407: LD_INT 4
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 2
93416: NEG
93417: PUSH
93418: LD_INT 2
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 4
93427: NEG
93428: PUSH
93429: LD_INT 0
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 4
93438: NEG
93439: PUSH
93440: LD_INT 1
93442: NEG
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 3
93450: NEG
93451: PUSH
93452: LD_INT 0
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 3
93461: NEG
93462: PUSH
93463: LD_INT 1
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 4
93472: NEG
93473: PUSH
93474: LD_INT 1
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 5
93483: NEG
93484: PUSH
93485: LD_INT 0
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PUSH
93492: LD_INT 5
93494: NEG
93495: PUSH
93496: LD_INT 1
93498: NEG
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 5
93506: NEG
93507: PUSH
93508: LD_INT 2
93510: NEG
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PUSH
93516: LD_INT 3
93518: NEG
93519: PUSH
93520: LD_INT 2
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 3
93529: NEG
93530: PUSH
93531: LD_INT 3
93533: NEG
93534: PUSH
93535: EMPTY
93536: LIST
93537: LIST
93538: PUSH
93539: LD_INT 3
93541: NEG
93542: PUSH
93543: LD_INT 4
93545: NEG
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 2
93553: NEG
93554: PUSH
93555: LD_INT 3
93557: NEG
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: LD_INT 2
93565: NEG
93566: PUSH
93567: LD_INT 2
93569: NEG
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 3
93577: NEG
93578: PUSH
93579: LD_INT 2
93581: NEG
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 4
93589: NEG
93590: PUSH
93591: LD_INT 3
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 4
93601: NEG
93602: PUSH
93603: LD_INT 4
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 2
93613: NEG
93614: PUSH
93615: LD_INT 4
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 4
93625: NEG
93626: PUSH
93627: LD_INT 2
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 0
93637: PUSH
93638: LD_INT 4
93640: NEG
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 0
93648: PUSH
93649: LD_INT 5
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 1
93659: PUSH
93660: LD_INT 4
93662: NEG
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 1
93670: PUSH
93671: LD_INT 3
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 0
93681: PUSH
93682: LD_INT 3
93684: NEG
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: PUSH
93690: LD_INT 1
93692: NEG
93693: PUSH
93694: LD_INT 4
93696: NEG
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PUSH
93702: LD_INT 1
93704: NEG
93705: PUSH
93706: LD_INT 5
93708: NEG
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 2
93716: PUSH
93717: LD_INT 3
93719: NEG
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: PUSH
93725: LD_INT 2
93727: NEG
93728: PUSH
93729: LD_INT 5
93731: NEG
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93784: LD_ADDR_VAR 0 31
93788: PUSH
93789: LD_INT 0
93791: PUSH
93792: LD_INT 4
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: PUSH
93799: LD_INT 0
93801: PUSH
93802: LD_INT 3
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 1
93811: PUSH
93812: LD_INT 4
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 1
93821: PUSH
93822: LD_INT 5
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 0
93831: PUSH
93832: LD_INT 5
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 1
93841: NEG
93842: PUSH
93843: LD_INT 4
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 1
93852: NEG
93853: PUSH
93854: LD_INT 3
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 2
93863: PUSH
93864: LD_INT 5
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 2
93873: NEG
93874: PUSH
93875: LD_INT 3
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: LD_INT 3
93884: NEG
93885: PUSH
93886: LD_INT 0
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: PUSH
93893: LD_INT 3
93895: NEG
93896: PUSH
93897: LD_INT 1
93899: NEG
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 2
93907: NEG
93908: PUSH
93909: LD_INT 0
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 2
93918: NEG
93919: PUSH
93920: LD_INT 1
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 3
93929: NEG
93930: PUSH
93931: LD_INT 1
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 4
93940: NEG
93941: PUSH
93942: LD_INT 0
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 4
93951: NEG
93952: PUSH
93953: LD_INT 1
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 4
93963: NEG
93964: PUSH
93965: LD_INT 2
93967: NEG
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 2
93975: NEG
93976: PUSH
93977: LD_INT 2
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 4
93986: NEG
93987: PUSH
93988: LD_INT 4
93990: NEG
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 4
93998: NEG
93999: PUSH
94000: LD_INT 5
94002: NEG
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 3
94010: NEG
94011: PUSH
94012: LD_INT 4
94014: NEG
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: LD_INT 3
94022: NEG
94023: PUSH
94024: LD_INT 3
94026: NEG
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 4
94034: NEG
94035: PUSH
94036: LD_INT 3
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 5
94046: NEG
94047: PUSH
94048: LD_INT 4
94050: NEG
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PUSH
94056: LD_INT 5
94058: NEG
94059: PUSH
94060: LD_INT 5
94062: NEG
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 3
94070: NEG
94071: PUSH
94072: LD_INT 5
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 5
94082: NEG
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 0
94094: PUSH
94095: LD_INT 3
94097: NEG
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 0
94105: PUSH
94106: LD_INT 4
94108: NEG
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 1
94116: PUSH
94117: LD_INT 3
94119: NEG
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 1
94127: PUSH
94128: LD_INT 2
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 0
94138: PUSH
94139: LD_INT 2
94141: NEG
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 1
94149: NEG
94150: PUSH
94151: LD_INT 3
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 1
94161: NEG
94162: PUSH
94163: LD_INT 4
94165: NEG
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: PUSH
94174: LD_INT 2
94176: NEG
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 2
94184: NEG
94185: PUSH
94186: LD_INT 4
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 4
94196: PUSH
94197: LD_INT 0
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 4
94206: PUSH
94207: LD_INT 1
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 5
94217: PUSH
94218: LD_INT 0
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 5
94227: PUSH
94228: LD_INT 1
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 4
94237: PUSH
94238: LD_INT 1
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 3
94247: PUSH
94248: LD_INT 0
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: LD_INT 1
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: PUSH
94269: LD_INT 2
94271: NEG
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 5
94279: PUSH
94280: LD_INT 2
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: EMPTY
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94334: LD_ADDR_VAR 0 32
94338: PUSH
94339: LD_INT 4
94341: NEG
94342: PUSH
94343: LD_INT 0
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 4
94352: NEG
94353: PUSH
94354: LD_INT 1
94356: NEG
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 3
94364: NEG
94365: PUSH
94366: LD_INT 0
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 3
94375: NEG
94376: PUSH
94377: LD_INT 1
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 4
94386: NEG
94387: PUSH
94388: LD_INT 1
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 5
94397: NEG
94398: PUSH
94399: LD_INT 0
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 5
94408: NEG
94409: PUSH
94410: LD_INT 1
94412: NEG
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: PUSH
94418: LD_INT 5
94420: NEG
94421: PUSH
94422: LD_INT 2
94424: NEG
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 3
94432: NEG
94433: PUSH
94434: LD_INT 2
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: PUSH
94441: LD_INT 3
94443: NEG
94444: PUSH
94445: LD_INT 3
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 3
94455: NEG
94456: PUSH
94457: LD_INT 4
94459: NEG
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 2
94467: NEG
94468: PUSH
94469: LD_INT 3
94471: NEG
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 2
94479: NEG
94480: PUSH
94481: LD_INT 2
94483: NEG
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 3
94491: NEG
94492: PUSH
94493: LD_INT 2
94495: NEG
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 4
94503: NEG
94504: PUSH
94505: LD_INT 3
94507: NEG
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 4
94515: NEG
94516: PUSH
94517: LD_INT 4
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 2
94527: NEG
94528: PUSH
94529: LD_INT 4
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 4
94539: NEG
94540: PUSH
94541: LD_INT 2
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 0
94551: PUSH
94552: LD_INT 4
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 0
94562: PUSH
94563: LD_INT 5
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 1
94573: PUSH
94574: LD_INT 4
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 1
94584: PUSH
94585: LD_INT 3
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 0
94595: PUSH
94596: LD_INT 3
94598: NEG
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 1
94606: NEG
94607: PUSH
94608: LD_INT 4
94610: NEG
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 1
94618: NEG
94619: PUSH
94620: LD_INT 5
94622: NEG
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 2
94630: PUSH
94631: LD_INT 3
94633: NEG
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 2
94641: NEG
94642: PUSH
94643: LD_INT 5
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 3
94653: PUSH
94654: LD_INT 0
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 3
94663: PUSH
94664: LD_INT 1
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 4
94674: PUSH
94675: LD_INT 0
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 4
94684: PUSH
94685: LD_INT 1
94687: PUSH
94688: EMPTY
94689: LIST
94690: LIST
94691: PUSH
94692: LD_INT 3
94694: PUSH
94695: LD_INT 1
94697: PUSH
94698: EMPTY
94699: LIST
94700: LIST
94701: PUSH
94702: LD_INT 2
94704: PUSH
94705: LD_INT 0
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: LD_INT 1
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 2
94725: PUSH
94726: LD_INT 2
94728: NEG
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 4
94736: PUSH
94737: LD_INT 2
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 4
94746: PUSH
94747: LD_INT 4
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 4
94756: PUSH
94757: LD_INT 3
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 5
94766: PUSH
94767: LD_INT 4
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 5
94776: PUSH
94777: LD_INT 5
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: LD_INT 4
94786: PUSH
94787: LD_INT 5
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 3
94796: PUSH
94797: LD_INT 4
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: LD_INT 3
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 5
94816: PUSH
94817: LD_INT 3
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 3
94826: PUSH
94827: LD_INT 5
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94881: LD_ADDR_VAR 0 33
94885: PUSH
94886: LD_INT 4
94888: NEG
94889: PUSH
94890: LD_INT 4
94892: NEG
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 4
94900: NEG
94901: PUSH
94902: LD_INT 5
94904: NEG
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 3
94912: NEG
94913: PUSH
94914: LD_INT 4
94916: NEG
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 3
94924: NEG
94925: PUSH
94926: LD_INT 3
94928: NEG
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 4
94936: NEG
94937: PUSH
94938: LD_INT 3
94940: NEG
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 5
94948: NEG
94949: PUSH
94950: LD_INT 4
94952: NEG
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: LD_INT 5
94960: NEG
94961: PUSH
94962: LD_INT 5
94964: NEG
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 3
94972: NEG
94973: PUSH
94974: LD_INT 5
94976: NEG
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: LD_INT 3
94988: NEG
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 0
94996: PUSH
94997: LD_INT 3
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 0
95007: PUSH
95008: LD_INT 4
95010: NEG
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 1
95018: PUSH
95019: LD_INT 3
95021: NEG
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 1
95029: PUSH
95030: LD_INT 2
95032: NEG
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 0
95040: PUSH
95041: LD_INT 2
95043: NEG
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 1
95051: NEG
95052: PUSH
95053: LD_INT 3
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 1
95063: NEG
95064: PUSH
95065: LD_INT 4
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 2
95075: PUSH
95076: LD_INT 2
95078: NEG
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 2
95086: NEG
95087: PUSH
95088: LD_INT 4
95090: NEG
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 4
95098: PUSH
95099: LD_INT 0
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 4
95108: PUSH
95109: LD_INT 1
95111: NEG
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 5
95119: PUSH
95120: LD_INT 0
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 5
95129: PUSH
95130: LD_INT 1
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PUSH
95137: LD_INT 4
95139: PUSH
95140: LD_INT 1
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: LD_INT 3
95149: PUSH
95150: LD_INT 0
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: LD_INT 1
95162: NEG
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PUSH
95168: LD_INT 3
95170: PUSH
95171: LD_INT 2
95173: NEG
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 5
95181: PUSH
95182: LD_INT 2
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 3
95191: PUSH
95192: LD_INT 3
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 3
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 4
95211: PUSH
95212: LD_INT 3
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 4
95221: PUSH
95222: LD_INT 4
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: PUSH
95229: LD_INT 3
95231: PUSH
95232: LD_INT 4
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 2
95241: PUSH
95242: LD_INT 3
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: PUSH
95249: LD_INT 2
95251: PUSH
95252: LD_INT 2
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 4
95261: PUSH
95262: LD_INT 2
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 2
95271: PUSH
95272: LD_INT 4
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 0
95281: PUSH
95282: LD_INT 4
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 0
95291: PUSH
95292: LD_INT 3
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 1
95301: PUSH
95302: LD_INT 4
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 1
95311: PUSH
95312: LD_INT 5
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PUSH
95319: LD_INT 0
95321: PUSH
95322: LD_INT 5
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: PUSH
95329: LD_INT 1
95331: NEG
95332: PUSH
95333: LD_INT 4
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 1
95342: NEG
95343: PUSH
95344: LD_INT 3
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: PUSH
95351: LD_INT 2
95353: PUSH
95354: LD_INT 5
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: LD_INT 2
95363: NEG
95364: PUSH
95365: LD_INT 3
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95419: LD_ADDR_VAR 0 34
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: LD_INT 4
95429: NEG
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 0
95437: PUSH
95438: LD_INT 5
95440: NEG
95441: PUSH
95442: EMPTY
95443: LIST
95444: LIST
95445: PUSH
95446: LD_INT 1
95448: PUSH
95449: LD_INT 4
95451: NEG
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 1
95459: PUSH
95460: LD_INT 3
95462: NEG
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 0
95470: PUSH
95471: LD_INT 3
95473: NEG
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 1
95481: NEG
95482: PUSH
95483: LD_INT 4
95485: NEG
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 1
95493: NEG
95494: PUSH
95495: LD_INT 5
95497: NEG
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 2
95505: PUSH
95506: LD_INT 3
95508: NEG
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 2
95516: NEG
95517: PUSH
95518: LD_INT 5
95520: NEG
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: LD_INT 3
95528: PUSH
95529: LD_INT 0
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: PUSH
95536: LD_INT 3
95538: PUSH
95539: LD_INT 1
95541: NEG
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 4
95549: PUSH
95550: LD_INT 0
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 4
95559: PUSH
95560: LD_INT 1
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 3
95569: PUSH
95570: LD_INT 1
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 2
95579: PUSH
95580: LD_INT 0
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: LD_INT 2
95589: PUSH
95590: LD_INT 1
95592: NEG
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 2
95600: PUSH
95601: LD_INT 2
95603: NEG
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 4
95611: PUSH
95612: LD_INT 2
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 4
95621: PUSH
95622: LD_INT 4
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 4
95631: PUSH
95632: LD_INT 3
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 5
95641: PUSH
95642: LD_INT 4
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 5
95651: PUSH
95652: LD_INT 5
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: PUSH
95659: LD_INT 4
95661: PUSH
95662: LD_INT 5
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 3
95671: PUSH
95672: LD_INT 4
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 3
95681: PUSH
95682: LD_INT 3
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 5
95691: PUSH
95692: LD_INT 3
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 3
95701: PUSH
95702: LD_INT 5
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: PUSH
95709: LD_INT 0
95711: PUSH
95712: LD_INT 3
95714: PUSH
95715: EMPTY
95716: LIST
95717: LIST
95718: PUSH
95719: LD_INT 0
95721: PUSH
95722: LD_INT 2
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_INT 1
95731: PUSH
95732: LD_INT 3
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 1
95741: PUSH
95742: LD_INT 4
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 0
95751: PUSH
95752: LD_INT 4
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 1
95761: NEG
95762: PUSH
95763: LD_INT 3
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 1
95772: NEG
95773: PUSH
95774: LD_INT 2
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 2
95783: PUSH
95784: LD_INT 4
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 2
95793: NEG
95794: PUSH
95795: LD_INT 2
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 4
95804: NEG
95805: PUSH
95806: LD_INT 0
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 4
95815: NEG
95816: PUSH
95817: LD_INT 1
95819: NEG
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 3
95827: NEG
95828: PUSH
95829: LD_INT 0
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 3
95838: NEG
95839: PUSH
95840: LD_INT 1
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 4
95849: NEG
95850: PUSH
95851: LD_INT 1
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PUSH
95858: LD_INT 5
95860: NEG
95861: PUSH
95862: LD_INT 0
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 5
95871: NEG
95872: PUSH
95873: LD_INT 1
95875: NEG
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 5
95883: NEG
95884: PUSH
95885: LD_INT 2
95887: NEG
95888: PUSH
95889: EMPTY
95890: LIST
95891: LIST
95892: PUSH
95893: LD_INT 3
95895: NEG
95896: PUSH
95897: LD_INT 2
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: ST_TO_ADDR
// end ; end ;
95951: GO 95954
95953: POP
// case btype of b_depot , b_warehouse :
95954: LD_VAR 0 1
95958: PUSH
95959: LD_INT 0
95961: DOUBLE
95962: EQUAL
95963: IFTRUE 95973
95965: LD_INT 1
95967: DOUBLE
95968: EQUAL
95969: IFTRUE 95973
95971: GO 96174
95973: POP
// case nation of nation_american :
95974: LD_VAR 0 5
95978: PUSH
95979: LD_INT 1
95981: DOUBLE
95982: EQUAL
95983: IFTRUE 95987
95985: GO 96043
95987: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95988: LD_ADDR_VAR 0 9
95992: PUSH
95993: LD_VAR 0 11
95997: PUSH
95998: LD_VAR 0 12
96002: PUSH
96003: LD_VAR 0 13
96007: PUSH
96008: LD_VAR 0 14
96012: PUSH
96013: LD_VAR 0 15
96017: PUSH
96018: LD_VAR 0 16
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: PUSH
96031: LD_VAR 0 4
96035: PUSH
96036: LD_INT 1
96038: PLUS
96039: ARRAY
96040: ST_TO_ADDR
96041: GO 96172
96043: LD_INT 2
96045: DOUBLE
96046: EQUAL
96047: IFTRUE 96051
96049: GO 96107
96051: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96052: LD_ADDR_VAR 0 9
96056: PUSH
96057: LD_VAR 0 17
96061: PUSH
96062: LD_VAR 0 18
96066: PUSH
96067: LD_VAR 0 19
96071: PUSH
96072: LD_VAR 0 20
96076: PUSH
96077: LD_VAR 0 21
96081: PUSH
96082: LD_VAR 0 22
96086: PUSH
96087: EMPTY
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: PUSH
96095: LD_VAR 0 4
96099: PUSH
96100: LD_INT 1
96102: PLUS
96103: ARRAY
96104: ST_TO_ADDR
96105: GO 96172
96107: LD_INT 3
96109: DOUBLE
96110: EQUAL
96111: IFTRUE 96115
96113: GO 96171
96115: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96116: LD_ADDR_VAR 0 9
96120: PUSH
96121: LD_VAR 0 23
96125: PUSH
96126: LD_VAR 0 24
96130: PUSH
96131: LD_VAR 0 25
96135: PUSH
96136: LD_VAR 0 26
96140: PUSH
96141: LD_VAR 0 27
96145: PUSH
96146: LD_VAR 0 28
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: PUSH
96159: LD_VAR 0 4
96163: PUSH
96164: LD_INT 1
96166: PLUS
96167: ARRAY
96168: ST_TO_ADDR
96169: GO 96172
96171: POP
96172: GO 96727
96174: LD_INT 2
96176: DOUBLE
96177: EQUAL
96178: IFTRUE 96188
96180: LD_INT 3
96182: DOUBLE
96183: EQUAL
96184: IFTRUE 96188
96186: GO 96244
96188: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96189: LD_ADDR_VAR 0 9
96193: PUSH
96194: LD_VAR 0 29
96198: PUSH
96199: LD_VAR 0 30
96203: PUSH
96204: LD_VAR 0 31
96208: PUSH
96209: LD_VAR 0 32
96213: PUSH
96214: LD_VAR 0 33
96218: PUSH
96219: LD_VAR 0 34
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: PUSH
96232: LD_VAR 0 4
96236: PUSH
96237: LD_INT 1
96239: PLUS
96240: ARRAY
96241: ST_TO_ADDR
96242: GO 96727
96244: LD_INT 16
96246: DOUBLE
96247: EQUAL
96248: IFTRUE 96306
96250: LD_INT 17
96252: DOUBLE
96253: EQUAL
96254: IFTRUE 96306
96256: LD_INT 18
96258: DOUBLE
96259: EQUAL
96260: IFTRUE 96306
96262: LD_INT 19
96264: DOUBLE
96265: EQUAL
96266: IFTRUE 96306
96268: LD_INT 22
96270: DOUBLE
96271: EQUAL
96272: IFTRUE 96306
96274: LD_INT 20
96276: DOUBLE
96277: EQUAL
96278: IFTRUE 96306
96280: LD_INT 21
96282: DOUBLE
96283: EQUAL
96284: IFTRUE 96306
96286: LD_INT 23
96288: DOUBLE
96289: EQUAL
96290: IFTRUE 96306
96292: LD_INT 24
96294: DOUBLE
96295: EQUAL
96296: IFTRUE 96306
96298: LD_INT 25
96300: DOUBLE
96301: EQUAL
96302: IFTRUE 96306
96304: GO 96362
96306: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96307: LD_ADDR_VAR 0 9
96311: PUSH
96312: LD_VAR 0 35
96316: PUSH
96317: LD_VAR 0 36
96321: PUSH
96322: LD_VAR 0 37
96326: PUSH
96327: LD_VAR 0 38
96331: PUSH
96332: LD_VAR 0 39
96336: PUSH
96337: LD_VAR 0 40
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: PUSH
96350: LD_VAR 0 4
96354: PUSH
96355: LD_INT 1
96357: PLUS
96358: ARRAY
96359: ST_TO_ADDR
96360: GO 96727
96362: LD_INT 6
96364: DOUBLE
96365: EQUAL
96366: IFTRUE 96418
96368: LD_INT 7
96370: DOUBLE
96371: EQUAL
96372: IFTRUE 96418
96374: LD_INT 8
96376: DOUBLE
96377: EQUAL
96378: IFTRUE 96418
96380: LD_INT 13
96382: DOUBLE
96383: EQUAL
96384: IFTRUE 96418
96386: LD_INT 12
96388: DOUBLE
96389: EQUAL
96390: IFTRUE 96418
96392: LD_INT 15
96394: DOUBLE
96395: EQUAL
96396: IFTRUE 96418
96398: LD_INT 11
96400: DOUBLE
96401: EQUAL
96402: IFTRUE 96418
96404: LD_INT 14
96406: DOUBLE
96407: EQUAL
96408: IFTRUE 96418
96410: LD_INT 10
96412: DOUBLE
96413: EQUAL
96414: IFTRUE 96418
96416: GO 96474
96418: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96419: LD_ADDR_VAR 0 9
96423: PUSH
96424: LD_VAR 0 41
96428: PUSH
96429: LD_VAR 0 42
96433: PUSH
96434: LD_VAR 0 43
96438: PUSH
96439: LD_VAR 0 44
96443: PUSH
96444: LD_VAR 0 45
96448: PUSH
96449: LD_VAR 0 46
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: PUSH
96462: LD_VAR 0 4
96466: PUSH
96467: LD_INT 1
96469: PLUS
96470: ARRAY
96471: ST_TO_ADDR
96472: GO 96727
96474: LD_INT 36
96476: DOUBLE
96477: EQUAL
96478: IFTRUE 96482
96480: GO 96538
96482: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96483: LD_ADDR_VAR 0 9
96487: PUSH
96488: LD_VAR 0 47
96492: PUSH
96493: LD_VAR 0 48
96497: PUSH
96498: LD_VAR 0 49
96502: PUSH
96503: LD_VAR 0 50
96507: PUSH
96508: LD_VAR 0 51
96512: PUSH
96513: LD_VAR 0 52
96517: PUSH
96518: EMPTY
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: PUSH
96526: LD_VAR 0 4
96530: PUSH
96531: LD_INT 1
96533: PLUS
96534: ARRAY
96535: ST_TO_ADDR
96536: GO 96727
96538: LD_INT 4
96540: DOUBLE
96541: EQUAL
96542: IFTRUE 96564
96544: LD_INT 5
96546: DOUBLE
96547: EQUAL
96548: IFTRUE 96564
96550: LD_INT 34
96552: DOUBLE
96553: EQUAL
96554: IFTRUE 96564
96556: LD_INT 37
96558: DOUBLE
96559: EQUAL
96560: IFTRUE 96564
96562: GO 96620
96564: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96565: LD_ADDR_VAR 0 9
96569: PUSH
96570: LD_VAR 0 53
96574: PUSH
96575: LD_VAR 0 54
96579: PUSH
96580: LD_VAR 0 55
96584: PUSH
96585: LD_VAR 0 56
96589: PUSH
96590: LD_VAR 0 57
96594: PUSH
96595: LD_VAR 0 58
96599: PUSH
96600: EMPTY
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: PUSH
96608: LD_VAR 0 4
96612: PUSH
96613: LD_INT 1
96615: PLUS
96616: ARRAY
96617: ST_TO_ADDR
96618: GO 96727
96620: LD_INT 31
96622: DOUBLE
96623: EQUAL
96624: IFTRUE 96670
96626: LD_INT 32
96628: DOUBLE
96629: EQUAL
96630: IFTRUE 96670
96632: LD_INT 33
96634: DOUBLE
96635: EQUAL
96636: IFTRUE 96670
96638: LD_INT 27
96640: DOUBLE
96641: EQUAL
96642: IFTRUE 96670
96644: LD_INT 26
96646: DOUBLE
96647: EQUAL
96648: IFTRUE 96670
96650: LD_INT 28
96652: DOUBLE
96653: EQUAL
96654: IFTRUE 96670
96656: LD_INT 29
96658: DOUBLE
96659: EQUAL
96660: IFTRUE 96670
96662: LD_INT 30
96664: DOUBLE
96665: EQUAL
96666: IFTRUE 96670
96668: GO 96726
96670: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96671: LD_ADDR_VAR 0 9
96675: PUSH
96676: LD_VAR 0 59
96680: PUSH
96681: LD_VAR 0 60
96685: PUSH
96686: LD_VAR 0 61
96690: PUSH
96691: LD_VAR 0 62
96695: PUSH
96696: LD_VAR 0 63
96700: PUSH
96701: LD_VAR 0 64
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: PUSH
96714: LD_VAR 0 4
96718: PUSH
96719: LD_INT 1
96721: PLUS
96722: ARRAY
96723: ST_TO_ADDR
96724: GO 96727
96726: POP
// temp_list2 = [ ] ;
96727: LD_ADDR_VAR 0 10
96731: PUSH
96732: EMPTY
96733: ST_TO_ADDR
// for i in temp_list do
96734: LD_ADDR_VAR 0 8
96738: PUSH
96739: LD_VAR 0 9
96743: PUSH
96744: FOR_IN
96745: IFFALSE 96797
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96747: LD_ADDR_VAR 0 10
96751: PUSH
96752: LD_VAR 0 10
96756: PUSH
96757: LD_VAR 0 8
96761: PUSH
96762: LD_INT 1
96764: ARRAY
96765: PUSH
96766: LD_VAR 0 2
96770: PLUS
96771: PUSH
96772: LD_VAR 0 8
96776: PUSH
96777: LD_INT 2
96779: ARRAY
96780: PUSH
96781: LD_VAR 0 3
96785: PLUS
96786: PUSH
96787: EMPTY
96788: LIST
96789: LIST
96790: PUSH
96791: EMPTY
96792: LIST
96793: ADD
96794: ST_TO_ADDR
96795: GO 96744
96797: POP
96798: POP
// result = temp_list2 ;
96799: LD_ADDR_VAR 0 7
96803: PUSH
96804: LD_VAR 0 10
96808: ST_TO_ADDR
// end ;
96809: LD_VAR 0 7
96813: RET
// export function EnemyInRange ( unit , dist ) ; begin
96814: LD_INT 0
96816: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96817: LD_ADDR_VAR 0 3
96821: PUSH
96822: LD_VAR 0 1
96826: PPUSH
96827: CALL_OW 255
96831: PPUSH
96832: LD_VAR 0 1
96836: PPUSH
96837: CALL_OW 250
96841: PPUSH
96842: LD_VAR 0 1
96846: PPUSH
96847: CALL_OW 251
96851: PPUSH
96852: LD_VAR 0 2
96856: PPUSH
96857: CALL 70918 0 4
96861: PUSH
96862: LD_INT 4
96864: ARRAY
96865: ST_TO_ADDR
// end ;
96866: LD_VAR 0 3
96870: RET
// export function PlayerSeeMe ( unit ) ; begin
96871: LD_INT 0
96873: PPUSH
// result := See ( your_side , unit ) ;
96874: LD_ADDR_VAR 0 2
96878: PUSH
96879: LD_OWVAR 2
96883: PPUSH
96884: LD_VAR 0 1
96888: PPUSH
96889: CALL_OW 292
96893: ST_TO_ADDR
// end ;
96894: LD_VAR 0 2
96898: RET
// export function ReverseDir ( unit ) ; begin
96899: LD_INT 0
96901: PPUSH
// if not unit then
96902: LD_VAR 0 1
96906: NOT
96907: IFFALSE 96911
// exit ;
96909: GO 96934
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96911: LD_ADDR_VAR 0 2
96915: PUSH
96916: LD_VAR 0 1
96920: PPUSH
96921: CALL_OW 254
96925: PUSH
96926: LD_INT 3
96928: PLUS
96929: PUSH
96930: LD_INT 6
96932: MOD
96933: ST_TO_ADDR
// end ;
96934: LD_VAR 0 2
96938: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96939: LD_INT 0
96941: PPUSH
96942: PPUSH
96943: PPUSH
96944: PPUSH
96945: PPUSH
// if not hexes then
96946: LD_VAR 0 2
96950: NOT
96951: IFFALSE 96955
// exit ;
96953: GO 97103
// dist := 9999 ;
96955: LD_ADDR_VAR 0 5
96959: PUSH
96960: LD_INT 9999
96962: ST_TO_ADDR
// for i = 1 to hexes do
96963: LD_ADDR_VAR 0 4
96967: PUSH
96968: DOUBLE
96969: LD_INT 1
96971: DEC
96972: ST_TO_ADDR
96973: LD_VAR 0 2
96977: PUSH
96978: FOR_TO
96979: IFFALSE 97091
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96981: LD_VAR 0 1
96985: PPUSH
96986: LD_VAR 0 2
96990: PUSH
96991: LD_VAR 0 4
96995: ARRAY
96996: PUSH
96997: LD_INT 1
96999: ARRAY
97000: PPUSH
97001: LD_VAR 0 2
97005: PUSH
97006: LD_VAR 0 4
97010: ARRAY
97011: PUSH
97012: LD_INT 2
97014: ARRAY
97015: PPUSH
97016: CALL_OW 297
97020: PUSH
97021: LD_VAR 0 5
97025: LESS
97026: IFFALSE 97089
// begin hex := hexes [ i ] ;
97028: LD_ADDR_VAR 0 7
97032: PUSH
97033: LD_VAR 0 2
97037: PUSH
97038: LD_VAR 0 4
97042: ARRAY
97043: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97044: LD_ADDR_VAR 0 5
97048: PUSH
97049: LD_VAR 0 1
97053: PPUSH
97054: LD_VAR 0 2
97058: PUSH
97059: LD_VAR 0 4
97063: ARRAY
97064: PUSH
97065: LD_INT 1
97067: ARRAY
97068: PPUSH
97069: LD_VAR 0 2
97073: PUSH
97074: LD_VAR 0 4
97078: ARRAY
97079: PUSH
97080: LD_INT 2
97082: ARRAY
97083: PPUSH
97084: CALL_OW 297
97088: ST_TO_ADDR
// end ; end ;
97089: GO 96978
97091: POP
97092: POP
// result := hex ;
97093: LD_ADDR_VAR 0 3
97097: PUSH
97098: LD_VAR 0 7
97102: ST_TO_ADDR
// end ;
97103: LD_VAR 0 3
97107: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97108: LD_INT 0
97110: PPUSH
97111: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97112: LD_VAR 0 1
97116: NOT
97117: PUSH
97118: LD_VAR 0 1
97122: PUSH
97123: LD_INT 21
97125: PUSH
97126: LD_INT 2
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: PUSH
97133: LD_INT 23
97135: PUSH
97136: LD_INT 2
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PPUSH
97147: CALL_OW 69
97151: IN
97152: NOT
97153: OR
97154: IFFALSE 97158
// exit ;
97156: GO 97205
// for i = 1 to 3 do
97158: LD_ADDR_VAR 0 3
97162: PUSH
97163: DOUBLE
97164: LD_INT 1
97166: DEC
97167: ST_TO_ADDR
97168: LD_INT 3
97170: PUSH
97171: FOR_TO
97172: IFFALSE 97203
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97174: LD_VAR 0 1
97178: PPUSH
97179: CALL_OW 250
97183: PPUSH
97184: LD_VAR 0 1
97188: PPUSH
97189: CALL_OW 251
97193: PPUSH
97194: LD_INT 1
97196: PPUSH
97197: CALL_OW 453
97201: GO 97171
97203: POP
97204: POP
// end ;
97205: LD_VAR 0 2
97209: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97210: LD_INT 0
97212: PPUSH
97213: PPUSH
97214: PPUSH
97215: PPUSH
97216: PPUSH
97217: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97218: LD_VAR 0 1
97222: NOT
97223: PUSH
97224: LD_VAR 0 2
97228: NOT
97229: OR
97230: PUSH
97231: LD_VAR 0 1
97235: PPUSH
97236: CALL_OW 314
97240: OR
97241: IFFALSE 97245
// exit ;
97243: GO 97686
// x := GetX ( enemy_unit ) ;
97245: LD_ADDR_VAR 0 7
97249: PUSH
97250: LD_VAR 0 2
97254: PPUSH
97255: CALL_OW 250
97259: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97260: LD_ADDR_VAR 0 8
97264: PUSH
97265: LD_VAR 0 2
97269: PPUSH
97270: CALL_OW 251
97274: ST_TO_ADDR
// if not x or not y then
97275: LD_VAR 0 7
97279: NOT
97280: PUSH
97281: LD_VAR 0 8
97285: NOT
97286: OR
97287: IFFALSE 97291
// exit ;
97289: GO 97686
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97291: LD_ADDR_VAR 0 6
97295: PUSH
97296: LD_VAR 0 7
97300: PPUSH
97301: LD_INT 0
97303: PPUSH
97304: LD_INT 4
97306: PPUSH
97307: CALL_OW 272
97311: PUSH
97312: LD_VAR 0 8
97316: PPUSH
97317: LD_INT 0
97319: PPUSH
97320: LD_INT 4
97322: PPUSH
97323: CALL_OW 273
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: PUSH
97332: LD_VAR 0 7
97336: PPUSH
97337: LD_INT 1
97339: PPUSH
97340: LD_INT 4
97342: PPUSH
97343: CALL_OW 272
97347: PUSH
97348: LD_VAR 0 8
97352: PPUSH
97353: LD_INT 1
97355: PPUSH
97356: LD_INT 4
97358: PPUSH
97359: CALL_OW 273
97363: PUSH
97364: EMPTY
97365: LIST
97366: LIST
97367: PUSH
97368: LD_VAR 0 7
97372: PPUSH
97373: LD_INT 2
97375: PPUSH
97376: LD_INT 4
97378: PPUSH
97379: CALL_OW 272
97383: PUSH
97384: LD_VAR 0 8
97388: PPUSH
97389: LD_INT 2
97391: PPUSH
97392: LD_INT 4
97394: PPUSH
97395: CALL_OW 273
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: LD_VAR 0 7
97408: PPUSH
97409: LD_INT 3
97411: PPUSH
97412: LD_INT 4
97414: PPUSH
97415: CALL_OW 272
97419: PUSH
97420: LD_VAR 0 8
97424: PPUSH
97425: LD_INT 3
97427: PPUSH
97428: LD_INT 4
97430: PPUSH
97431: CALL_OW 273
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_VAR 0 7
97444: PPUSH
97445: LD_INT 4
97447: PPUSH
97448: LD_INT 4
97450: PPUSH
97451: CALL_OW 272
97455: PUSH
97456: LD_VAR 0 8
97460: PPUSH
97461: LD_INT 4
97463: PPUSH
97464: LD_INT 4
97466: PPUSH
97467: CALL_OW 273
97471: PUSH
97472: EMPTY
97473: LIST
97474: LIST
97475: PUSH
97476: LD_VAR 0 7
97480: PPUSH
97481: LD_INT 5
97483: PPUSH
97484: LD_INT 4
97486: PPUSH
97487: CALL_OW 272
97491: PUSH
97492: LD_VAR 0 8
97496: PPUSH
97497: LD_INT 5
97499: PPUSH
97500: LD_INT 4
97502: PPUSH
97503: CALL_OW 273
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: EMPTY
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: ST_TO_ADDR
// for i = tmp downto 1 do
97520: LD_ADDR_VAR 0 4
97524: PUSH
97525: DOUBLE
97526: LD_VAR 0 6
97530: INC
97531: ST_TO_ADDR
97532: LD_INT 1
97534: PUSH
97535: FOR_DOWNTO
97536: IFFALSE 97637
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97538: LD_VAR 0 6
97542: PUSH
97543: LD_VAR 0 4
97547: ARRAY
97548: PUSH
97549: LD_INT 1
97551: ARRAY
97552: PPUSH
97553: LD_VAR 0 6
97557: PUSH
97558: LD_VAR 0 4
97562: ARRAY
97563: PUSH
97564: LD_INT 2
97566: ARRAY
97567: PPUSH
97568: CALL_OW 488
97572: NOT
97573: PUSH
97574: LD_VAR 0 6
97578: PUSH
97579: LD_VAR 0 4
97583: ARRAY
97584: PUSH
97585: LD_INT 1
97587: ARRAY
97588: PPUSH
97589: LD_VAR 0 6
97593: PUSH
97594: LD_VAR 0 4
97598: ARRAY
97599: PUSH
97600: LD_INT 2
97602: ARRAY
97603: PPUSH
97604: CALL_OW 428
97608: PUSH
97609: LD_INT 0
97611: NONEQUAL
97612: OR
97613: IFFALSE 97635
// tmp := Delete ( tmp , i ) ;
97615: LD_ADDR_VAR 0 6
97619: PUSH
97620: LD_VAR 0 6
97624: PPUSH
97625: LD_VAR 0 4
97629: PPUSH
97630: CALL_OW 3
97634: ST_TO_ADDR
97635: GO 97535
97637: POP
97638: POP
// j := GetClosestHex ( unit , tmp ) ;
97639: LD_ADDR_VAR 0 5
97643: PUSH
97644: LD_VAR 0 1
97648: PPUSH
97649: LD_VAR 0 6
97653: PPUSH
97654: CALL 96939 0 2
97658: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97659: LD_VAR 0 1
97663: PPUSH
97664: LD_VAR 0 5
97668: PUSH
97669: LD_INT 1
97671: ARRAY
97672: PPUSH
97673: LD_VAR 0 5
97677: PUSH
97678: LD_INT 2
97680: ARRAY
97681: PPUSH
97682: CALL_OW 111
// end ;
97686: LD_VAR 0 3
97690: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97691: LD_INT 0
97693: PPUSH
97694: PPUSH
97695: PPUSH
// uc_side = 0 ;
97696: LD_ADDR_OWVAR 20
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// uc_nation = 0 ;
97704: LD_ADDR_OWVAR 21
97708: PUSH
97709: LD_INT 0
97711: ST_TO_ADDR
// InitHc ;
97712: CALL_OW 19
// InitVc ;
97716: CALL_OW 20
// if mastodonts then
97720: LD_VAR 0 6
97724: IFFALSE 97791
// for i = 1 to mastodonts do
97726: LD_ADDR_VAR 0 11
97730: PUSH
97731: DOUBLE
97732: LD_INT 1
97734: DEC
97735: ST_TO_ADDR
97736: LD_VAR 0 6
97740: PUSH
97741: FOR_TO
97742: IFFALSE 97789
// begin vc_chassis := 31 ;
97744: LD_ADDR_OWVAR 37
97748: PUSH
97749: LD_INT 31
97751: ST_TO_ADDR
// vc_control := control_rider ;
97752: LD_ADDR_OWVAR 38
97756: PUSH
97757: LD_INT 4
97759: ST_TO_ADDR
// animal := CreateVehicle ;
97760: LD_ADDR_VAR 0 12
97764: PUSH
97765: CALL_OW 45
97769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97770: LD_VAR 0 12
97774: PPUSH
97775: LD_VAR 0 8
97779: PPUSH
97780: LD_INT 0
97782: PPUSH
97783: CALL 99860 0 3
// end ;
97787: GO 97741
97789: POP
97790: POP
// if horses then
97791: LD_VAR 0 5
97795: IFFALSE 97862
// for i = 1 to horses do
97797: LD_ADDR_VAR 0 11
97801: PUSH
97802: DOUBLE
97803: LD_INT 1
97805: DEC
97806: ST_TO_ADDR
97807: LD_VAR 0 5
97811: PUSH
97812: FOR_TO
97813: IFFALSE 97860
// begin hc_class := 21 ;
97815: LD_ADDR_OWVAR 28
97819: PUSH
97820: LD_INT 21
97822: ST_TO_ADDR
// hc_gallery :=  ;
97823: LD_ADDR_OWVAR 33
97827: PUSH
97828: LD_STRING 
97830: ST_TO_ADDR
// animal := CreateHuman ;
97831: LD_ADDR_VAR 0 12
97835: PUSH
97836: CALL_OW 44
97840: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97841: LD_VAR 0 12
97845: PPUSH
97846: LD_VAR 0 8
97850: PPUSH
97851: LD_INT 0
97853: PPUSH
97854: CALL 99860 0 3
// end ;
97858: GO 97812
97860: POP
97861: POP
// if birds then
97862: LD_VAR 0 1
97866: IFFALSE 97933
// for i = 1 to birds do
97868: LD_ADDR_VAR 0 11
97872: PUSH
97873: DOUBLE
97874: LD_INT 1
97876: DEC
97877: ST_TO_ADDR
97878: LD_VAR 0 1
97882: PUSH
97883: FOR_TO
97884: IFFALSE 97931
// begin hc_class = 18 ;
97886: LD_ADDR_OWVAR 28
97890: PUSH
97891: LD_INT 18
97893: ST_TO_ADDR
// hc_gallery =  ;
97894: LD_ADDR_OWVAR 33
97898: PUSH
97899: LD_STRING 
97901: ST_TO_ADDR
// animal := CreateHuman ;
97902: LD_ADDR_VAR 0 12
97906: PUSH
97907: CALL_OW 44
97911: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97912: LD_VAR 0 12
97916: PPUSH
97917: LD_VAR 0 8
97921: PPUSH
97922: LD_INT 0
97924: PPUSH
97925: CALL 99860 0 3
// end ;
97929: GO 97883
97931: POP
97932: POP
// if tigers then
97933: LD_VAR 0 2
97937: IFFALSE 98021
// for i = 1 to tigers do
97939: LD_ADDR_VAR 0 11
97943: PUSH
97944: DOUBLE
97945: LD_INT 1
97947: DEC
97948: ST_TO_ADDR
97949: LD_VAR 0 2
97953: PUSH
97954: FOR_TO
97955: IFFALSE 98019
// begin hc_class = class_tiger ;
97957: LD_ADDR_OWVAR 28
97961: PUSH
97962: LD_INT 14
97964: ST_TO_ADDR
// hc_gallery =  ;
97965: LD_ADDR_OWVAR 33
97969: PUSH
97970: LD_STRING 
97972: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97973: LD_ADDR_OWVAR 35
97977: PUSH
97978: LD_INT 7
97980: NEG
97981: PPUSH
97982: LD_INT 7
97984: PPUSH
97985: CALL_OW 12
97989: ST_TO_ADDR
// animal := CreateHuman ;
97990: LD_ADDR_VAR 0 12
97994: PUSH
97995: CALL_OW 44
97999: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98000: LD_VAR 0 12
98004: PPUSH
98005: LD_VAR 0 8
98009: PPUSH
98010: LD_INT 0
98012: PPUSH
98013: CALL 99860 0 3
// end ;
98017: GO 97954
98019: POP
98020: POP
// if apemans then
98021: LD_VAR 0 3
98025: IFFALSE 98148
// for i = 1 to apemans do
98027: LD_ADDR_VAR 0 11
98031: PUSH
98032: DOUBLE
98033: LD_INT 1
98035: DEC
98036: ST_TO_ADDR
98037: LD_VAR 0 3
98041: PUSH
98042: FOR_TO
98043: IFFALSE 98146
// begin hc_class = class_apeman ;
98045: LD_ADDR_OWVAR 28
98049: PUSH
98050: LD_INT 12
98052: ST_TO_ADDR
// hc_gallery =  ;
98053: LD_ADDR_OWVAR 33
98057: PUSH
98058: LD_STRING 
98060: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98061: LD_ADDR_OWVAR 35
98065: PUSH
98066: LD_INT 5
98068: NEG
98069: PPUSH
98070: LD_INT 5
98072: PPUSH
98073: CALL_OW 12
98077: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98078: LD_ADDR_OWVAR 31
98082: PUSH
98083: LD_INT 1
98085: PPUSH
98086: LD_INT 3
98088: PPUSH
98089: CALL_OW 12
98093: PUSH
98094: LD_INT 1
98096: PPUSH
98097: LD_INT 3
98099: PPUSH
98100: CALL_OW 12
98104: PUSH
98105: LD_INT 0
98107: PUSH
98108: LD_INT 0
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: ST_TO_ADDR
// animal := CreateHuman ;
98117: LD_ADDR_VAR 0 12
98121: PUSH
98122: CALL_OW 44
98126: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98127: LD_VAR 0 12
98131: PPUSH
98132: LD_VAR 0 8
98136: PPUSH
98137: LD_INT 0
98139: PPUSH
98140: CALL 99860 0 3
// end ;
98144: GO 98042
98146: POP
98147: POP
// if enchidnas then
98148: LD_VAR 0 4
98152: IFFALSE 98219
// for i = 1 to enchidnas do
98154: LD_ADDR_VAR 0 11
98158: PUSH
98159: DOUBLE
98160: LD_INT 1
98162: DEC
98163: ST_TO_ADDR
98164: LD_VAR 0 4
98168: PUSH
98169: FOR_TO
98170: IFFALSE 98217
// begin hc_class = 13 ;
98172: LD_ADDR_OWVAR 28
98176: PUSH
98177: LD_INT 13
98179: ST_TO_ADDR
// hc_gallery =  ;
98180: LD_ADDR_OWVAR 33
98184: PUSH
98185: LD_STRING 
98187: ST_TO_ADDR
// animal := CreateHuman ;
98188: LD_ADDR_VAR 0 12
98192: PUSH
98193: CALL_OW 44
98197: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98198: LD_VAR 0 12
98202: PPUSH
98203: LD_VAR 0 8
98207: PPUSH
98208: LD_INT 0
98210: PPUSH
98211: CALL 99860 0 3
// end ;
98215: GO 98169
98217: POP
98218: POP
// if fishes then
98219: LD_VAR 0 7
98223: IFFALSE 98290
// for i = 1 to fishes do
98225: LD_ADDR_VAR 0 11
98229: PUSH
98230: DOUBLE
98231: LD_INT 1
98233: DEC
98234: ST_TO_ADDR
98235: LD_VAR 0 7
98239: PUSH
98240: FOR_TO
98241: IFFALSE 98288
// begin hc_class = 20 ;
98243: LD_ADDR_OWVAR 28
98247: PUSH
98248: LD_INT 20
98250: ST_TO_ADDR
// hc_gallery =  ;
98251: LD_ADDR_OWVAR 33
98255: PUSH
98256: LD_STRING 
98258: ST_TO_ADDR
// animal := CreateHuman ;
98259: LD_ADDR_VAR 0 12
98263: PUSH
98264: CALL_OW 44
98268: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98269: LD_VAR 0 12
98273: PPUSH
98274: LD_VAR 0 9
98278: PPUSH
98279: LD_INT 0
98281: PPUSH
98282: CALL 99860 0 3
// end ;
98286: GO 98240
98288: POP
98289: POP
// end ;
98290: LD_VAR 0 10
98294: RET
// export function WantHeal ( sci , unit ) ; begin
98295: LD_INT 0
98297: PPUSH
// if GetTaskList ( sci ) > 0 then
98298: LD_VAR 0 1
98302: PPUSH
98303: CALL_OW 437
98307: PUSH
98308: LD_INT 0
98310: GREATER
98311: IFFALSE 98381
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98313: LD_VAR 0 1
98317: PPUSH
98318: CALL_OW 437
98322: PUSH
98323: LD_INT 1
98325: ARRAY
98326: PUSH
98327: LD_INT 1
98329: ARRAY
98330: PUSH
98331: LD_STRING l
98333: EQUAL
98334: PUSH
98335: LD_VAR 0 1
98339: PPUSH
98340: CALL_OW 437
98344: PUSH
98345: LD_INT 1
98347: ARRAY
98348: PUSH
98349: LD_INT 4
98351: ARRAY
98352: PUSH
98353: LD_VAR 0 2
98357: EQUAL
98358: AND
98359: IFFALSE 98371
// result := true else
98361: LD_ADDR_VAR 0 3
98365: PUSH
98366: LD_INT 1
98368: ST_TO_ADDR
98369: GO 98379
// result := false ;
98371: LD_ADDR_VAR 0 3
98375: PUSH
98376: LD_INT 0
98378: ST_TO_ADDR
// end else
98379: GO 98389
// result := false ;
98381: LD_ADDR_VAR 0 3
98385: PUSH
98386: LD_INT 0
98388: ST_TO_ADDR
// end ;
98389: LD_VAR 0 3
98393: RET
// export function HealTarget ( sci ) ; begin
98394: LD_INT 0
98396: PPUSH
// if not sci then
98397: LD_VAR 0 1
98401: NOT
98402: IFFALSE 98406
// exit ;
98404: GO 98471
// result := 0 ;
98406: LD_ADDR_VAR 0 2
98410: PUSH
98411: LD_INT 0
98413: ST_TO_ADDR
// if GetTaskList ( sci ) then
98414: LD_VAR 0 1
98418: PPUSH
98419: CALL_OW 437
98423: IFFALSE 98471
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98425: LD_VAR 0 1
98429: PPUSH
98430: CALL_OW 437
98434: PUSH
98435: LD_INT 1
98437: ARRAY
98438: PUSH
98439: LD_INT 1
98441: ARRAY
98442: PUSH
98443: LD_STRING l
98445: EQUAL
98446: IFFALSE 98471
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98448: LD_ADDR_VAR 0 2
98452: PUSH
98453: LD_VAR 0 1
98457: PPUSH
98458: CALL_OW 437
98462: PUSH
98463: LD_INT 1
98465: ARRAY
98466: PUSH
98467: LD_INT 4
98469: ARRAY
98470: ST_TO_ADDR
// end ;
98471: LD_VAR 0 2
98475: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98476: LD_INT 0
98478: PPUSH
98479: PPUSH
98480: PPUSH
98481: PPUSH
// if not base_units then
98482: LD_VAR 0 1
98486: NOT
98487: IFFALSE 98491
// exit ;
98489: GO 98578
// result := false ;
98491: LD_ADDR_VAR 0 2
98495: PUSH
98496: LD_INT 0
98498: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98499: LD_ADDR_VAR 0 5
98503: PUSH
98504: LD_VAR 0 1
98508: PPUSH
98509: LD_INT 21
98511: PUSH
98512: LD_INT 3
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PPUSH
98519: CALL_OW 72
98523: ST_TO_ADDR
// if not tmp then
98524: LD_VAR 0 5
98528: NOT
98529: IFFALSE 98533
// exit ;
98531: GO 98578
// for i in tmp do
98533: LD_ADDR_VAR 0 3
98537: PUSH
98538: LD_VAR 0 5
98542: PUSH
98543: FOR_IN
98544: IFFALSE 98576
// begin result := EnemyInRange ( i , 22 ) ;
98546: LD_ADDR_VAR 0 2
98550: PUSH
98551: LD_VAR 0 3
98555: PPUSH
98556: LD_INT 22
98558: PPUSH
98559: CALL 96814 0 2
98563: ST_TO_ADDR
// if result then
98564: LD_VAR 0 2
98568: IFFALSE 98574
// exit ;
98570: POP
98571: POP
98572: GO 98578
// end ;
98574: GO 98543
98576: POP
98577: POP
// end ;
98578: LD_VAR 0 2
98582: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98583: LD_INT 0
98585: PPUSH
98586: PPUSH
// if not units then
98587: LD_VAR 0 1
98591: NOT
98592: IFFALSE 98596
// exit ;
98594: GO 98666
// result := [ ] ;
98596: LD_ADDR_VAR 0 3
98600: PUSH
98601: EMPTY
98602: ST_TO_ADDR
// for i in units do
98603: LD_ADDR_VAR 0 4
98607: PUSH
98608: LD_VAR 0 1
98612: PUSH
98613: FOR_IN
98614: IFFALSE 98664
// if GetTag ( i ) = tag then
98616: LD_VAR 0 4
98620: PPUSH
98621: CALL_OW 110
98625: PUSH
98626: LD_VAR 0 2
98630: EQUAL
98631: IFFALSE 98662
// result := Insert ( result , result + 1 , i ) ;
98633: LD_ADDR_VAR 0 3
98637: PUSH
98638: LD_VAR 0 3
98642: PPUSH
98643: LD_VAR 0 3
98647: PUSH
98648: LD_INT 1
98650: PLUS
98651: PPUSH
98652: LD_VAR 0 4
98656: PPUSH
98657: CALL_OW 2
98661: ST_TO_ADDR
98662: GO 98613
98664: POP
98665: POP
// end ;
98666: LD_VAR 0 3
98670: RET
// export function IsDriver ( un ) ; begin
98671: LD_INT 0
98673: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98674: LD_ADDR_VAR 0 2
98678: PUSH
98679: LD_VAR 0 1
98683: PUSH
98684: LD_INT 55
98686: PUSH
98687: EMPTY
98688: LIST
98689: PPUSH
98690: CALL_OW 69
98694: IN
98695: ST_TO_ADDR
// end ;
98696: LD_VAR 0 2
98700: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98701: LD_INT 0
98703: PPUSH
98704: PPUSH
// list := [ ] ;
98705: LD_ADDR_VAR 0 5
98709: PUSH
98710: EMPTY
98711: ST_TO_ADDR
// case d of 0 :
98712: LD_VAR 0 3
98716: PUSH
98717: LD_INT 0
98719: DOUBLE
98720: EQUAL
98721: IFTRUE 98725
98723: GO 98858
98725: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98726: LD_ADDR_VAR 0 5
98730: PUSH
98731: LD_VAR 0 1
98735: PUSH
98736: LD_INT 4
98738: MINUS
98739: PUSH
98740: LD_VAR 0 2
98744: PUSH
98745: LD_INT 4
98747: MINUS
98748: PUSH
98749: LD_INT 2
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: LIST
98756: PUSH
98757: LD_VAR 0 1
98761: PUSH
98762: LD_INT 3
98764: MINUS
98765: PUSH
98766: LD_VAR 0 2
98770: PUSH
98771: LD_INT 1
98773: PUSH
98774: EMPTY
98775: LIST
98776: LIST
98777: LIST
98778: PUSH
98779: LD_VAR 0 1
98783: PUSH
98784: LD_INT 4
98786: PLUS
98787: PUSH
98788: LD_VAR 0 2
98792: PUSH
98793: LD_INT 4
98795: PUSH
98796: EMPTY
98797: LIST
98798: LIST
98799: LIST
98800: PUSH
98801: LD_VAR 0 1
98805: PUSH
98806: LD_INT 3
98808: PLUS
98809: PUSH
98810: LD_VAR 0 2
98814: PUSH
98815: LD_INT 3
98817: PLUS
98818: PUSH
98819: LD_INT 5
98821: PUSH
98822: EMPTY
98823: LIST
98824: LIST
98825: LIST
98826: PUSH
98827: LD_VAR 0 1
98831: PUSH
98832: LD_VAR 0 2
98836: PUSH
98837: LD_INT 4
98839: PLUS
98840: PUSH
98841: LD_INT 0
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: LIST
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: ST_TO_ADDR
// end ; 1 :
98856: GO 99556
98858: LD_INT 1
98860: DOUBLE
98861: EQUAL
98862: IFTRUE 98866
98864: GO 98999
98866: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98867: LD_ADDR_VAR 0 5
98871: PUSH
98872: LD_VAR 0 1
98876: PUSH
98877: LD_VAR 0 2
98881: PUSH
98882: LD_INT 4
98884: MINUS
98885: PUSH
98886: LD_INT 3
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: LIST
98893: PUSH
98894: LD_VAR 0 1
98898: PUSH
98899: LD_INT 3
98901: MINUS
98902: PUSH
98903: LD_VAR 0 2
98907: PUSH
98908: LD_INT 3
98910: MINUS
98911: PUSH
98912: LD_INT 2
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: LIST
98919: PUSH
98920: LD_VAR 0 1
98924: PUSH
98925: LD_INT 4
98927: MINUS
98928: PUSH
98929: LD_VAR 0 2
98933: PUSH
98934: LD_INT 1
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: LIST
98941: PUSH
98942: LD_VAR 0 1
98946: PUSH
98947: LD_VAR 0 2
98951: PUSH
98952: LD_INT 3
98954: PLUS
98955: PUSH
98956: LD_INT 0
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: LIST
98963: PUSH
98964: LD_VAR 0 1
98968: PUSH
98969: LD_INT 4
98971: PLUS
98972: PUSH
98973: LD_VAR 0 2
98977: PUSH
98978: LD_INT 4
98980: PLUS
98981: PUSH
98982: LD_INT 5
98984: PUSH
98985: EMPTY
98986: LIST
98987: LIST
98988: LIST
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: ST_TO_ADDR
// end ; 2 :
98997: GO 99556
98999: LD_INT 2
99001: DOUBLE
99002: EQUAL
99003: IFTRUE 99007
99005: GO 99136
99007: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99008: LD_ADDR_VAR 0 5
99012: PUSH
99013: LD_VAR 0 1
99017: PUSH
99018: LD_VAR 0 2
99022: PUSH
99023: LD_INT 3
99025: MINUS
99026: PUSH
99027: LD_INT 3
99029: PUSH
99030: EMPTY
99031: LIST
99032: LIST
99033: LIST
99034: PUSH
99035: LD_VAR 0 1
99039: PUSH
99040: LD_INT 4
99042: PLUS
99043: PUSH
99044: LD_VAR 0 2
99048: PUSH
99049: LD_INT 4
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: LIST
99056: PUSH
99057: LD_VAR 0 1
99061: PUSH
99062: LD_VAR 0 2
99066: PUSH
99067: LD_INT 4
99069: PLUS
99070: PUSH
99071: LD_INT 0
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: LIST
99078: PUSH
99079: LD_VAR 0 1
99083: PUSH
99084: LD_INT 3
99086: MINUS
99087: PUSH
99088: LD_VAR 0 2
99092: PUSH
99093: LD_INT 1
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: LIST
99100: PUSH
99101: LD_VAR 0 1
99105: PUSH
99106: LD_INT 4
99108: MINUS
99109: PUSH
99110: LD_VAR 0 2
99114: PUSH
99115: LD_INT 4
99117: MINUS
99118: PUSH
99119: LD_INT 2
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: LIST
99126: PUSH
99127: EMPTY
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: ST_TO_ADDR
// end ; 3 :
99134: GO 99556
99136: LD_INT 3
99138: DOUBLE
99139: EQUAL
99140: IFTRUE 99144
99142: GO 99277
99144: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99145: LD_ADDR_VAR 0 5
99149: PUSH
99150: LD_VAR 0 1
99154: PUSH
99155: LD_INT 3
99157: PLUS
99158: PUSH
99159: LD_VAR 0 2
99163: PUSH
99164: LD_INT 4
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: LIST
99171: PUSH
99172: LD_VAR 0 1
99176: PUSH
99177: LD_INT 4
99179: PLUS
99180: PUSH
99181: LD_VAR 0 2
99185: PUSH
99186: LD_INT 4
99188: PLUS
99189: PUSH
99190: LD_INT 5
99192: PUSH
99193: EMPTY
99194: LIST
99195: LIST
99196: LIST
99197: PUSH
99198: LD_VAR 0 1
99202: PUSH
99203: LD_INT 4
99205: MINUS
99206: PUSH
99207: LD_VAR 0 2
99211: PUSH
99212: LD_INT 1
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: LIST
99219: PUSH
99220: LD_VAR 0 1
99224: PUSH
99225: LD_VAR 0 2
99229: PUSH
99230: LD_INT 4
99232: MINUS
99233: PUSH
99234: LD_INT 3
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: LIST
99241: PUSH
99242: LD_VAR 0 1
99246: PUSH
99247: LD_INT 3
99249: MINUS
99250: PUSH
99251: LD_VAR 0 2
99255: PUSH
99256: LD_INT 3
99258: MINUS
99259: PUSH
99260: LD_INT 2
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: LIST
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: ST_TO_ADDR
// end ; 4 :
99275: GO 99556
99277: LD_INT 4
99279: DOUBLE
99280: EQUAL
99281: IFTRUE 99285
99283: GO 99418
99285: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99286: LD_ADDR_VAR 0 5
99290: PUSH
99291: LD_VAR 0 1
99295: PUSH
99296: LD_VAR 0 2
99300: PUSH
99301: LD_INT 4
99303: PLUS
99304: PUSH
99305: LD_INT 0
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: LIST
99312: PUSH
99313: LD_VAR 0 1
99317: PUSH
99318: LD_INT 3
99320: PLUS
99321: PUSH
99322: LD_VAR 0 2
99326: PUSH
99327: LD_INT 3
99329: PLUS
99330: PUSH
99331: LD_INT 5
99333: PUSH
99334: EMPTY
99335: LIST
99336: LIST
99337: LIST
99338: PUSH
99339: LD_VAR 0 1
99343: PUSH
99344: LD_INT 4
99346: PLUS
99347: PUSH
99348: LD_VAR 0 2
99352: PUSH
99353: LD_INT 4
99355: PUSH
99356: EMPTY
99357: LIST
99358: LIST
99359: LIST
99360: PUSH
99361: LD_VAR 0 1
99365: PUSH
99366: LD_VAR 0 2
99370: PUSH
99371: LD_INT 3
99373: MINUS
99374: PUSH
99375: LD_INT 3
99377: PUSH
99378: EMPTY
99379: LIST
99380: LIST
99381: LIST
99382: PUSH
99383: LD_VAR 0 1
99387: PUSH
99388: LD_INT 4
99390: MINUS
99391: PUSH
99392: LD_VAR 0 2
99396: PUSH
99397: LD_INT 4
99399: MINUS
99400: PUSH
99401: LD_INT 2
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: LIST
99408: PUSH
99409: EMPTY
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: ST_TO_ADDR
// end ; 5 :
99416: GO 99556
99418: LD_INT 5
99420: DOUBLE
99421: EQUAL
99422: IFTRUE 99426
99424: GO 99555
99426: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99427: LD_ADDR_VAR 0 5
99431: PUSH
99432: LD_VAR 0 1
99436: PUSH
99437: LD_INT 4
99439: MINUS
99440: PUSH
99441: LD_VAR 0 2
99445: PUSH
99446: LD_INT 1
99448: PUSH
99449: EMPTY
99450: LIST
99451: LIST
99452: LIST
99453: PUSH
99454: LD_VAR 0 1
99458: PUSH
99459: LD_VAR 0 2
99463: PUSH
99464: LD_INT 4
99466: MINUS
99467: PUSH
99468: LD_INT 3
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: LIST
99475: PUSH
99476: LD_VAR 0 1
99480: PUSH
99481: LD_INT 4
99483: PLUS
99484: PUSH
99485: LD_VAR 0 2
99489: PUSH
99490: LD_INT 4
99492: PLUS
99493: PUSH
99494: LD_INT 5
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: LIST
99501: PUSH
99502: LD_VAR 0 1
99506: PUSH
99507: LD_INT 3
99509: PLUS
99510: PUSH
99511: LD_VAR 0 2
99515: PUSH
99516: LD_INT 4
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: LIST
99523: PUSH
99524: LD_VAR 0 1
99528: PUSH
99529: LD_VAR 0 2
99533: PUSH
99534: LD_INT 3
99536: PLUS
99537: PUSH
99538: LD_INT 0
99540: PUSH
99541: EMPTY
99542: LIST
99543: LIST
99544: LIST
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: ST_TO_ADDR
// end ; end ;
99553: GO 99556
99555: POP
// result := list ;
99556: LD_ADDR_VAR 0 4
99560: PUSH
99561: LD_VAR 0 5
99565: ST_TO_ADDR
// end ;
99566: LD_VAR 0 4
99570: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99571: LD_INT 0
99573: PPUSH
99574: PPUSH
99575: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99576: LD_VAR 0 1
99580: NOT
99581: PUSH
99582: LD_VAR 0 2
99586: PUSH
99587: LD_INT 1
99589: PUSH
99590: LD_INT 2
99592: PUSH
99593: LD_INT 3
99595: PUSH
99596: LD_INT 4
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: IN
99605: NOT
99606: OR
99607: IFFALSE 99611
// exit ;
99609: GO 99703
// tmp := [ ] ;
99611: LD_ADDR_VAR 0 5
99615: PUSH
99616: EMPTY
99617: ST_TO_ADDR
// for i in units do
99618: LD_ADDR_VAR 0 4
99622: PUSH
99623: LD_VAR 0 1
99627: PUSH
99628: FOR_IN
99629: IFFALSE 99672
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99631: LD_ADDR_VAR 0 5
99635: PUSH
99636: LD_VAR 0 5
99640: PPUSH
99641: LD_VAR 0 5
99645: PUSH
99646: LD_INT 1
99648: PLUS
99649: PPUSH
99650: LD_VAR 0 4
99654: PPUSH
99655: LD_VAR 0 2
99659: PPUSH
99660: CALL_OW 259
99664: PPUSH
99665: CALL_OW 2
99669: ST_TO_ADDR
99670: GO 99628
99672: POP
99673: POP
// if not tmp then
99674: LD_VAR 0 5
99678: NOT
99679: IFFALSE 99683
// exit ;
99681: GO 99703
// result := SortListByListDesc ( units , tmp ) ;
99683: LD_ADDR_VAR 0 3
99687: PUSH
99688: LD_VAR 0 1
99692: PPUSH
99693: LD_VAR 0 5
99697: PPUSH
99698: CALL_OW 77
99702: ST_TO_ADDR
// end ;
99703: LD_VAR 0 3
99707: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99708: LD_INT 0
99710: PPUSH
99711: PPUSH
99712: PPUSH
// x := GetX ( building ) ;
99713: LD_ADDR_VAR 0 4
99717: PUSH
99718: LD_VAR 0 2
99722: PPUSH
99723: CALL_OW 250
99727: ST_TO_ADDR
// y := GetY ( building ) ;
99728: LD_ADDR_VAR 0 5
99732: PUSH
99733: LD_VAR 0 2
99737: PPUSH
99738: CALL_OW 251
99742: ST_TO_ADDR
// if GetTaskList ( unit ) then
99743: LD_VAR 0 1
99747: PPUSH
99748: CALL_OW 437
99752: IFFALSE 99847
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99754: LD_STRING e
99756: PUSH
99757: LD_VAR 0 1
99761: PPUSH
99762: CALL_OW 437
99766: PUSH
99767: LD_INT 1
99769: ARRAY
99770: PUSH
99771: LD_INT 1
99773: ARRAY
99774: EQUAL
99775: PUSH
99776: LD_VAR 0 4
99780: PUSH
99781: LD_VAR 0 1
99785: PPUSH
99786: CALL_OW 437
99790: PUSH
99791: LD_INT 1
99793: ARRAY
99794: PUSH
99795: LD_INT 2
99797: ARRAY
99798: EQUAL
99799: AND
99800: PUSH
99801: LD_VAR 0 5
99805: PUSH
99806: LD_VAR 0 1
99810: PPUSH
99811: CALL_OW 437
99815: PUSH
99816: LD_INT 1
99818: ARRAY
99819: PUSH
99820: LD_INT 3
99822: ARRAY
99823: EQUAL
99824: AND
99825: IFFALSE 99837
// result := true else
99827: LD_ADDR_VAR 0 3
99831: PUSH
99832: LD_INT 1
99834: ST_TO_ADDR
99835: GO 99845
// result := false ;
99837: LD_ADDR_VAR 0 3
99841: PUSH
99842: LD_INT 0
99844: ST_TO_ADDR
// end else
99845: GO 99855
// result := false ;
99847: LD_ADDR_VAR 0 3
99851: PUSH
99852: LD_INT 0
99854: ST_TO_ADDR
// end ;
99855: LD_VAR 0 3
99859: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99860: LD_INT 0
99862: PPUSH
99863: PPUSH
99864: PPUSH
99865: PPUSH
// if not unit or not area then
99866: LD_VAR 0 1
99870: NOT
99871: PUSH
99872: LD_VAR 0 2
99876: NOT
99877: OR
99878: IFFALSE 99882
// exit ;
99880: GO 100046
// tmp := AreaToList ( area , i ) ;
99882: LD_ADDR_VAR 0 6
99886: PUSH
99887: LD_VAR 0 2
99891: PPUSH
99892: LD_VAR 0 5
99896: PPUSH
99897: CALL_OW 517
99901: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99902: LD_ADDR_VAR 0 5
99906: PUSH
99907: DOUBLE
99908: LD_INT 1
99910: DEC
99911: ST_TO_ADDR
99912: LD_VAR 0 6
99916: PUSH
99917: LD_INT 1
99919: ARRAY
99920: PUSH
99921: FOR_TO
99922: IFFALSE 100044
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99924: LD_ADDR_VAR 0 7
99928: PUSH
99929: LD_VAR 0 6
99933: PUSH
99934: LD_INT 1
99936: ARRAY
99937: PUSH
99938: LD_VAR 0 5
99942: ARRAY
99943: PUSH
99944: LD_VAR 0 6
99948: PUSH
99949: LD_INT 2
99951: ARRAY
99952: PUSH
99953: LD_VAR 0 5
99957: ARRAY
99958: PUSH
99959: EMPTY
99960: LIST
99961: LIST
99962: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99963: LD_VAR 0 7
99967: PUSH
99968: LD_INT 1
99970: ARRAY
99971: PPUSH
99972: LD_VAR 0 7
99976: PUSH
99977: LD_INT 2
99979: ARRAY
99980: PPUSH
99981: CALL_OW 428
99985: PUSH
99986: LD_INT 0
99988: EQUAL
99989: IFFALSE 100042
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99991: LD_VAR 0 1
99995: PPUSH
99996: LD_VAR 0 7
100000: PUSH
100001: LD_INT 1
100003: ARRAY
100004: PPUSH
100005: LD_VAR 0 7
100009: PUSH
100010: LD_INT 2
100012: ARRAY
100013: PPUSH
100014: LD_VAR 0 3
100018: PPUSH
100019: CALL_OW 48
// result := IsPlaced ( unit ) ;
100023: LD_ADDR_VAR 0 4
100027: PUSH
100028: LD_VAR 0 1
100032: PPUSH
100033: CALL_OW 305
100037: ST_TO_ADDR
// exit ;
100038: POP
100039: POP
100040: GO 100046
// end ; end ;
100042: GO 99921
100044: POP
100045: POP
// end ;
100046: LD_VAR 0 4
100050: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100051: LD_INT 0
100053: PPUSH
100054: PPUSH
100055: PPUSH
// if not side or side > 8 then
100056: LD_VAR 0 1
100060: NOT
100061: PUSH
100062: LD_VAR 0 1
100066: PUSH
100067: LD_INT 8
100069: GREATER
100070: OR
100071: IFFALSE 100075
// exit ;
100073: GO 100262
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100075: LD_ADDR_VAR 0 4
100079: PUSH
100080: LD_INT 22
100082: PUSH
100083: LD_VAR 0 1
100087: PUSH
100088: EMPTY
100089: LIST
100090: LIST
100091: PUSH
100092: LD_INT 21
100094: PUSH
100095: LD_INT 3
100097: PUSH
100098: EMPTY
100099: LIST
100100: LIST
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PPUSH
100106: CALL_OW 69
100110: ST_TO_ADDR
// if not tmp then
100111: LD_VAR 0 4
100115: NOT
100116: IFFALSE 100120
// exit ;
100118: GO 100262
// enable_addtolog := true ;
100120: LD_ADDR_OWVAR 81
100124: PUSH
100125: LD_INT 1
100127: ST_TO_ADDR
// AddToLog ( [ ) ;
100128: LD_STRING [
100130: PPUSH
100131: CALL_OW 561
// for i in tmp do
100135: LD_ADDR_VAR 0 3
100139: PUSH
100140: LD_VAR 0 4
100144: PUSH
100145: FOR_IN
100146: IFFALSE 100253
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100148: LD_STRING [
100150: PUSH
100151: LD_VAR 0 3
100155: PPUSH
100156: CALL_OW 266
100160: STR
100161: PUSH
100162: LD_STRING , 
100164: STR
100165: PUSH
100166: LD_VAR 0 3
100170: PPUSH
100171: CALL_OW 250
100175: STR
100176: PUSH
100177: LD_STRING , 
100179: STR
100180: PUSH
100181: LD_VAR 0 3
100185: PPUSH
100186: CALL_OW 251
100190: STR
100191: PUSH
100192: LD_STRING , 
100194: STR
100195: PUSH
100196: LD_VAR 0 3
100200: PPUSH
100201: CALL_OW 254
100205: STR
100206: PUSH
100207: LD_STRING , 
100209: STR
100210: PUSH
100211: LD_VAR 0 3
100215: PPUSH
100216: LD_INT 1
100218: PPUSH
100219: CALL_OW 268
100223: STR
100224: PUSH
100225: LD_STRING , 
100227: STR
100228: PUSH
100229: LD_VAR 0 3
100233: PPUSH
100234: LD_INT 2
100236: PPUSH
100237: CALL_OW 268
100241: STR
100242: PUSH
100243: LD_STRING ],
100245: STR
100246: PPUSH
100247: CALL_OW 561
// end ;
100251: GO 100145
100253: POP
100254: POP
// AddToLog ( ]; ) ;
100255: LD_STRING ];
100257: PPUSH
100258: CALL_OW 561
// end ;
100262: LD_VAR 0 2
100266: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100267: LD_INT 0
100269: PPUSH
100270: PPUSH
100271: PPUSH
100272: PPUSH
100273: PPUSH
// if not area or not rate or not max then
100274: LD_VAR 0 1
100278: NOT
100279: PUSH
100280: LD_VAR 0 2
100284: NOT
100285: OR
100286: PUSH
100287: LD_VAR 0 4
100291: NOT
100292: OR
100293: IFFALSE 100297
// exit ;
100295: GO 100489
// while 1 do
100297: LD_INT 1
100299: IFFALSE 100489
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100301: LD_ADDR_VAR 0 9
100305: PUSH
100306: LD_VAR 0 1
100310: PPUSH
100311: LD_INT 1
100313: PPUSH
100314: CALL_OW 287
100318: PUSH
100319: LD_INT 10
100321: MUL
100322: ST_TO_ADDR
// r := rate / 10 ;
100323: LD_ADDR_VAR 0 7
100327: PUSH
100328: LD_VAR 0 2
100332: PUSH
100333: LD_INT 10
100335: DIVREAL
100336: ST_TO_ADDR
// time := 1 1$00 ;
100337: LD_ADDR_VAR 0 8
100341: PUSH
100342: LD_INT 2100
100344: ST_TO_ADDR
// if amount < min then
100345: LD_VAR 0 9
100349: PUSH
100350: LD_VAR 0 3
100354: LESS
100355: IFFALSE 100373
// r := r * 2 else
100357: LD_ADDR_VAR 0 7
100361: PUSH
100362: LD_VAR 0 7
100366: PUSH
100367: LD_INT 2
100369: MUL
100370: ST_TO_ADDR
100371: GO 100399
// if amount > max then
100373: LD_VAR 0 9
100377: PUSH
100378: LD_VAR 0 4
100382: GREATER
100383: IFFALSE 100399
// r := r / 2 ;
100385: LD_ADDR_VAR 0 7
100389: PUSH
100390: LD_VAR 0 7
100394: PUSH
100395: LD_INT 2
100397: DIVREAL
100398: ST_TO_ADDR
// time := time / r ;
100399: LD_ADDR_VAR 0 8
100403: PUSH
100404: LD_VAR 0 8
100408: PUSH
100409: LD_VAR 0 7
100413: DIVREAL
100414: ST_TO_ADDR
// if time < 0 then
100415: LD_VAR 0 8
100419: PUSH
100420: LD_INT 0
100422: LESS
100423: IFFALSE 100440
// time := time * - 1 ;
100425: LD_ADDR_VAR 0 8
100429: PUSH
100430: LD_VAR 0 8
100434: PUSH
100435: LD_INT 1
100437: NEG
100438: MUL
100439: ST_TO_ADDR
// wait ( time ) ;
100440: LD_VAR 0 8
100444: PPUSH
100445: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100449: LD_INT 35
100451: PPUSH
100452: LD_INT 875
100454: PPUSH
100455: CALL_OW 12
100459: PPUSH
100460: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100464: LD_INT 1
100466: PPUSH
100467: LD_INT 5
100469: PPUSH
100470: CALL_OW 12
100474: PPUSH
100475: LD_VAR 0 1
100479: PPUSH
100480: LD_INT 1
100482: PPUSH
100483: CALL_OW 55
// end ;
100487: GO 100297
// end ;
100489: LD_VAR 0 5
100493: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100494: LD_INT 0
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
100500: PPUSH
100501: PPUSH
100502: PPUSH
100503: PPUSH
// if not turrets or not factories then
100504: LD_VAR 0 1
100508: NOT
100509: PUSH
100510: LD_VAR 0 2
100514: NOT
100515: OR
100516: IFFALSE 100520
// exit ;
100518: GO 100827
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100520: LD_ADDR_VAR 0 10
100524: PUSH
100525: LD_INT 5
100527: PUSH
100528: LD_INT 6
100530: PUSH
100531: EMPTY
100532: LIST
100533: LIST
100534: PUSH
100535: LD_INT 2
100537: PUSH
100538: LD_INT 4
100540: PUSH
100541: EMPTY
100542: LIST
100543: LIST
100544: PUSH
100545: LD_INT 3
100547: PUSH
100548: LD_INT 5
100550: PUSH
100551: EMPTY
100552: LIST
100553: LIST
100554: PUSH
100555: EMPTY
100556: LIST
100557: LIST
100558: LIST
100559: PUSH
100560: LD_INT 24
100562: PUSH
100563: LD_INT 25
100565: PUSH
100566: EMPTY
100567: LIST
100568: LIST
100569: PUSH
100570: LD_INT 23
100572: PUSH
100573: LD_INT 27
100575: PUSH
100576: EMPTY
100577: LIST
100578: LIST
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: PUSH
100584: LD_INT 42
100586: PUSH
100587: LD_INT 43
100589: PUSH
100590: EMPTY
100591: LIST
100592: LIST
100593: PUSH
100594: LD_INT 44
100596: PUSH
100597: LD_INT 46
100599: PUSH
100600: EMPTY
100601: LIST
100602: LIST
100603: PUSH
100604: LD_INT 45
100606: PUSH
100607: LD_INT 47
100609: PUSH
100610: EMPTY
100611: LIST
100612: LIST
100613: PUSH
100614: EMPTY
100615: LIST
100616: LIST
100617: LIST
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: LIST
100623: ST_TO_ADDR
// result := [ ] ;
100624: LD_ADDR_VAR 0 3
100628: PUSH
100629: EMPTY
100630: ST_TO_ADDR
// for i in turrets do
100631: LD_ADDR_VAR 0 4
100635: PUSH
100636: LD_VAR 0 1
100640: PUSH
100641: FOR_IN
100642: IFFALSE 100825
// begin nat := GetNation ( i ) ;
100644: LD_ADDR_VAR 0 7
100648: PUSH
100649: LD_VAR 0 4
100653: PPUSH
100654: CALL_OW 248
100658: ST_TO_ADDR
// weapon := 0 ;
100659: LD_ADDR_VAR 0 8
100663: PUSH
100664: LD_INT 0
100666: ST_TO_ADDR
// if not nat then
100667: LD_VAR 0 7
100671: NOT
100672: IFFALSE 100676
// continue ;
100674: GO 100641
// for j in list [ nat ] do
100676: LD_ADDR_VAR 0 5
100680: PUSH
100681: LD_VAR 0 10
100685: PUSH
100686: LD_VAR 0 7
100690: ARRAY
100691: PUSH
100692: FOR_IN
100693: IFFALSE 100734
// if GetBWeapon ( i ) = j [ 1 ] then
100695: LD_VAR 0 4
100699: PPUSH
100700: CALL_OW 269
100704: PUSH
100705: LD_VAR 0 5
100709: PUSH
100710: LD_INT 1
100712: ARRAY
100713: EQUAL
100714: IFFALSE 100732
// begin weapon := j [ 2 ] ;
100716: LD_ADDR_VAR 0 8
100720: PUSH
100721: LD_VAR 0 5
100725: PUSH
100726: LD_INT 2
100728: ARRAY
100729: ST_TO_ADDR
// break ;
100730: GO 100734
// end ;
100732: GO 100692
100734: POP
100735: POP
// if not weapon then
100736: LD_VAR 0 8
100740: NOT
100741: IFFALSE 100745
// continue ;
100743: GO 100641
// for k in factories do
100745: LD_ADDR_VAR 0 6
100749: PUSH
100750: LD_VAR 0 2
100754: PUSH
100755: FOR_IN
100756: IFFALSE 100821
// begin weapons := AvailableWeaponList ( k ) ;
100758: LD_ADDR_VAR 0 9
100762: PUSH
100763: LD_VAR 0 6
100767: PPUSH
100768: CALL_OW 478
100772: ST_TO_ADDR
// if not weapons then
100773: LD_VAR 0 9
100777: NOT
100778: IFFALSE 100782
// continue ;
100780: GO 100755
// if weapon in weapons then
100782: LD_VAR 0 8
100786: PUSH
100787: LD_VAR 0 9
100791: IN
100792: IFFALSE 100819
// begin result := [ i , weapon ] ;
100794: LD_ADDR_VAR 0 3
100798: PUSH
100799: LD_VAR 0 4
100803: PUSH
100804: LD_VAR 0 8
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: ST_TO_ADDR
// exit ;
100813: POP
100814: POP
100815: POP
100816: POP
100817: GO 100827
// end ; end ;
100819: GO 100755
100821: POP
100822: POP
// end ;
100823: GO 100641
100825: POP
100826: POP
// end ;
100827: LD_VAR 0 3
100831: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100832: LD_INT 0
100834: PPUSH
// if not side or side > 8 then
100835: LD_VAR 0 3
100839: NOT
100840: PUSH
100841: LD_VAR 0 3
100845: PUSH
100846: LD_INT 8
100848: GREATER
100849: OR
100850: IFFALSE 100854
// exit ;
100852: GO 100913
// if not range then
100854: LD_VAR 0 4
100858: NOT
100859: IFFALSE 100870
// range := - 12 ;
100861: LD_ADDR_VAR 0 4
100865: PUSH
100866: LD_INT 12
100868: NEG
100869: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100870: LD_VAR 0 1
100874: PPUSH
100875: LD_VAR 0 2
100879: PPUSH
100880: LD_VAR 0 3
100884: PPUSH
100885: LD_VAR 0 4
100889: PPUSH
100890: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100894: LD_VAR 0 1
100898: PPUSH
100899: LD_VAR 0 2
100903: PPUSH
100904: LD_VAR 0 3
100908: PPUSH
100909: CALL_OW 331
// end ;
100913: LD_VAR 0 5
100917: RET
// export function Video ( mode ) ; begin
100918: LD_INT 0
100920: PPUSH
// ingame_video = mode ;
100921: LD_ADDR_OWVAR 52
100925: PUSH
100926: LD_VAR 0 1
100930: ST_TO_ADDR
// interface_hidden = mode ;
100931: LD_ADDR_OWVAR 54
100935: PUSH
100936: LD_VAR 0 1
100940: ST_TO_ADDR
// end ;
100941: LD_VAR 0 2
100945: RET
// export function Join ( array , element ) ; begin
100946: LD_INT 0
100948: PPUSH
// result := array ^ element ;
100949: LD_ADDR_VAR 0 3
100953: PUSH
100954: LD_VAR 0 1
100958: PUSH
100959: LD_VAR 0 2
100963: ADD
100964: ST_TO_ADDR
// end ;
100965: LD_VAR 0 3
100969: RET
// export function JoinUnion ( array , element ) ; begin
100970: LD_INT 0
100972: PPUSH
// result := array union element ;
100973: LD_ADDR_VAR 0 3
100977: PUSH
100978: LD_VAR 0 1
100982: PUSH
100983: LD_VAR 0 2
100987: UNION
100988: ST_TO_ADDR
// end ;
100989: LD_VAR 0 3
100993: RET
// export function GetBehemoths ( side ) ; begin
100994: LD_INT 0
100996: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
100997: LD_ADDR_VAR 0 2
101001: PUSH
101002: LD_INT 22
101004: PUSH
101005: LD_VAR 0 1
101009: PUSH
101010: EMPTY
101011: LIST
101012: LIST
101013: PUSH
101014: LD_INT 31
101016: PUSH
101017: LD_INT 25
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PPUSH
101028: CALL_OW 69
101032: ST_TO_ADDR
// end ;
101033: LD_VAR 0 2
101037: RET
// export function Shuffle ( array ) ; var i , index ; begin
101038: LD_INT 0
101040: PPUSH
101041: PPUSH
101042: PPUSH
// result := [ ] ;
101043: LD_ADDR_VAR 0 2
101047: PUSH
101048: EMPTY
101049: ST_TO_ADDR
// if not array then
101050: LD_VAR 0 1
101054: NOT
101055: IFFALSE 101059
// exit ;
101057: GO 101158
// Randomize ;
101059: CALL_OW 10
// for i = array downto 1 do
101063: LD_ADDR_VAR 0 3
101067: PUSH
101068: DOUBLE
101069: LD_VAR 0 1
101073: INC
101074: ST_TO_ADDR
101075: LD_INT 1
101077: PUSH
101078: FOR_DOWNTO
101079: IFFALSE 101156
// begin index := rand ( 1 , array ) ;
101081: LD_ADDR_VAR 0 4
101085: PUSH
101086: LD_INT 1
101088: PPUSH
101089: LD_VAR 0 1
101093: PPUSH
101094: CALL_OW 12
101098: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101099: LD_ADDR_VAR 0 2
101103: PUSH
101104: LD_VAR 0 2
101108: PPUSH
101109: LD_VAR 0 2
101113: PUSH
101114: LD_INT 1
101116: PLUS
101117: PPUSH
101118: LD_VAR 0 1
101122: PUSH
101123: LD_VAR 0 4
101127: ARRAY
101128: PPUSH
101129: CALL_OW 2
101133: ST_TO_ADDR
// array := Delete ( array , index ) ;
101134: LD_ADDR_VAR 0 1
101138: PUSH
101139: LD_VAR 0 1
101143: PPUSH
101144: LD_VAR 0 4
101148: PPUSH
101149: CALL_OW 3
101153: ST_TO_ADDR
// end ;
101154: GO 101078
101156: POP
101157: POP
// end ;
101158: LD_VAR 0 2
101162: RET
// export function GetBaseMaterials ( base ) ; begin
101163: LD_INT 0
101165: PPUSH
// result := [ 0 , 0 , 0 ] ;
101166: LD_ADDR_VAR 0 2
101170: PUSH
101171: LD_INT 0
101173: PUSH
101174: LD_INT 0
101176: PUSH
101177: LD_INT 0
101179: PUSH
101180: EMPTY
101181: LIST
101182: LIST
101183: LIST
101184: ST_TO_ADDR
// if not base then
101185: LD_VAR 0 1
101189: NOT
101190: IFFALSE 101194
// exit ;
101192: GO 101243
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101194: LD_ADDR_VAR 0 2
101198: PUSH
101199: LD_VAR 0 1
101203: PPUSH
101204: LD_INT 1
101206: PPUSH
101207: CALL_OW 275
101211: PUSH
101212: LD_VAR 0 1
101216: PPUSH
101217: LD_INT 2
101219: PPUSH
101220: CALL_OW 275
101224: PUSH
101225: LD_VAR 0 1
101229: PPUSH
101230: LD_INT 3
101232: PPUSH
101233: CALL_OW 275
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: LIST
101242: ST_TO_ADDR
// end ;
101243: LD_VAR 0 2
101247: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101248: LD_INT 0
101250: PPUSH
101251: PPUSH
// result := array ;
101252: LD_ADDR_VAR 0 3
101256: PUSH
101257: LD_VAR 0 1
101261: ST_TO_ADDR
// if size > 0 then
101262: LD_VAR 0 2
101266: PUSH
101267: LD_INT 0
101269: GREATER
101270: IFFALSE 101316
// for i := array downto size do
101272: LD_ADDR_VAR 0 4
101276: PUSH
101277: DOUBLE
101278: LD_VAR 0 1
101282: INC
101283: ST_TO_ADDR
101284: LD_VAR 0 2
101288: PUSH
101289: FOR_DOWNTO
101290: IFFALSE 101314
// result := Delete ( result , result ) ;
101292: LD_ADDR_VAR 0 3
101296: PUSH
101297: LD_VAR 0 3
101301: PPUSH
101302: LD_VAR 0 3
101306: PPUSH
101307: CALL_OW 3
101311: ST_TO_ADDR
101312: GO 101289
101314: POP
101315: POP
// end ;
101316: LD_VAR 0 3
101320: RET
// export function ComExit ( unit ) ; var tmp ; begin
101321: LD_INT 0
101323: PPUSH
101324: PPUSH
// if not IsInUnit ( unit ) then
101325: LD_VAR 0 1
101329: PPUSH
101330: CALL_OW 310
101334: NOT
101335: IFFALSE 101339
// exit ;
101337: GO 101399
// tmp := IsInUnit ( unit ) ;
101339: LD_ADDR_VAR 0 3
101343: PUSH
101344: LD_VAR 0 1
101348: PPUSH
101349: CALL_OW 310
101353: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101354: LD_VAR 0 3
101358: PPUSH
101359: CALL_OW 247
101363: PUSH
101364: LD_INT 2
101366: EQUAL
101367: IFFALSE 101380
// ComExitVehicle ( unit ) else
101369: LD_VAR 0 1
101373: PPUSH
101374: CALL_OW 121
101378: GO 101389
// ComExitBuilding ( unit ) ;
101380: LD_VAR 0 1
101384: PPUSH
101385: CALL_OW 122
// result := tmp ;
101389: LD_ADDR_VAR 0 2
101393: PUSH
101394: LD_VAR 0 3
101398: ST_TO_ADDR
// end ;
101399: LD_VAR 0 2
101403: RET
// export function ResetHc ; begin
101404: LD_INT 0
101406: PPUSH
// InitHc ;
101407: CALL_OW 19
// hc_importance := 0 ;
101411: LD_ADDR_OWVAR 32
101415: PUSH
101416: LD_INT 0
101418: ST_TO_ADDR
// end ; end_of_file end_of_file
101419: LD_VAR 0 1
101423: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
101424: GO 101426
101426: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
101427: LD_STRING initStreamRollete();
101429: PPUSH
101430: CALL_OW 559
// InitStreamMode ;
101434: CALL 101443 0 0
// DefineStreamItems ( ) ;
101438: CALL 101883 0 0
// end ;
101442: END
// function InitStreamMode ; begin
101443: LD_INT 0
101445: PPUSH
// streamModeActive := false ;
101446: LD_ADDR_EXP 153
101450: PUSH
101451: LD_INT 0
101453: ST_TO_ADDR
// normalCounter := 36 ;
101454: LD_ADDR_EXP 154
101458: PUSH
101459: LD_INT 36
101461: ST_TO_ADDR
// hardcoreCounter := 16 ;
101462: LD_ADDR_EXP 155
101466: PUSH
101467: LD_INT 16
101469: ST_TO_ADDR
// sRocket := false ;
101470: LD_ADDR_EXP 158
101474: PUSH
101475: LD_INT 0
101477: ST_TO_ADDR
// sSpeed := false ;
101478: LD_ADDR_EXP 157
101482: PUSH
101483: LD_INT 0
101485: ST_TO_ADDR
// sEngine := false ;
101486: LD_ADDR_EXP 159
101490: PUSH
101491: LD_INT 0
101493: ST_TO_ADDR
// sSpec := false ;
101494: LD_ADDR_EXP 156
101498: PUSH
101499: LD_INT 0
101501: ST_TO_ADDR
// sLevel := false ;
101502: LD_ADDR_EXP 160
101506: PUSH
101507: LD_INT 0
101509: ST_TO_ADDR
// sArmoury := false ;
101510: LD_ADDR_EXP 161
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
// sRadar := false ;
101518: LD_ADDR_EXP 162
101522: PUSH
101523: LD_INT 0
101525: ST_TO_ADDR
// sBunker := false ;
101526: LD_ADDR_EXP 163
101530: PUSH
101531: LD_INT 0
101533: ST_TO_ADDR
// sHack := false ;
101534: LD_ADDR_EXP 164
101538: PUSH
101539: LD_INT 0
101541: ST_TO_ADDR
// sFire := false ;
101542: LD_ADDR_EXP 165
101546: PUSH
101547: LD_INT 0
101549: ST_TO_ADDR
// sRefresh := false ;
101550: LD_ADDR_EXP 166
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// sExp := false ;
101558: LD_ADDR_EXP 167
101562: PUSH
101563: LD_INT 0
101565: ST_TO_ADDR
// sDepot := false ;
101566: LD_ADDR_EXP 168
101570: PUSH
101571: LD_INT 0
101573: ST_TO_ADDR
// sFlag := false ;
101574: LD_ADDR_EXP 169
101578: PUSH
101579: LD_INT 0
101581: ST_TO_ADDR
// sKamikadze := false ;
101582: LD_ADDR_EXP 177
101586: PUSH
101587: LD_INT 0
101589: ST_TO_ADDR
// sTroll := false ;
101590: LD_ADDR_EXP 178
101594: PUSH
101595: LD_INT 0
101597: ST_TO_ADDR
// sSlow := false ;
101598: LD_ADDR_EXP 179
101602: PUSH
101603: LD_INT 0
101605: ST_TO_ADDR
// sLack := false ;
101606: LD_ADDR_EXP 180
101610: PUSH
101611: LD_INT 0
101613: ST_TO_ADDR
// sTank := false ;
101614: LD_ADDR_EXP 182
101618: PUSH
101619: LD_INT 0
101621: ST_TO_ADDR
// sRemote := false ;
101622: LD_ADDR_EXP 183
101626: PUSH
101627: LD_INT 0
101629: ST_TO_ADDR
// sPowell := false ;
101630: LD_ADDR_EXP 184
101634: PUSH
101635: LD_INT 0
101637: ST_TO_ADDR
// sTeleport := false ;
101638: LD_ADDR_EXP 187
101642: PUSH
101643: LD_INT 0
101645: ST_TO_ADDR
// sOilTower := false ;
101646: LD_ADDR_EXP 189
101650: PUSH
101651: LD_INT 0
101653: ST_TO_ADDR
// sShovel := false ;
101654: LD_ADDR_EXP 190
101658: PUSH
101659: LD_INT 0
101661: ST_TO_ADDR
// sSheik := false ;
101662: LD_ADDR_EXP 191
101666: PUSH
101667: LD_INT 0
101669: ST_TO_ADDR
// sEarthquake := false ;
101670: LD_ADDR_EXP 193
101674: PUSH
101675: LD_INT 0
101677: ST_TO_ADDR
// sAI := false ;
101678: LD_ADDR_EXP 194
101682: PUSH
101683: LD_INT 0
101685: ST_TO_ADDR
// sCargo := false ;
101686: LD_ADDR_EXP 197
101690: PUSH
101691: LD_INT 0
101693: ST_TO_ADDR
// sDLaser := false ;
101694: LD_ADDR_EXP 198
101698: PUSH
101699: LD_INT 0
101701: ST_TO_ADDR
// sExchange := false ;
101702: LD_ADDR_EXP 199
101706: PUSH
101707: LD_INT 0
101709: ST_TO_ADDR
// sFac := false ;
101710: LD_ADDR_EXP 200
101714: PUSH
101715: LD_INT 0
101717: ST_TO_ADDR
// sPower := false ;
101718: LD_ADDR_EXP 201
101722: PUSH
101723: LD_INT 0
101725: ST_TO_ADDR
// sRandom := false ;
101726: LD_ADDR_EXP 202
101730: PUSH
101731: LD_INT 0
101733: ST_TO_ADDR
// sShield := false ;
101734: LD_ADDR_EXP 203
101738: PUSH
101739: LD_INT 0
101741: ST_TO_ADDR
// sTime := false ;
101742: LD_ADDR_EXP 204
101746: PUSH
101747: LD_INT 0
101749: ST_TO_ADDR
// sTools := false ;
101750: LD_ADDR_EXP 205
101754: PUSH
101755: LD_INT 0
101757: ST_TO_ADDR
// sSold := false ;
101758: LD_ADDR_EXP 170
101762: PUSH
101763: LD_INT 0
101765: ST_TO_ADDR
// sDiff := false ;
101766: LD_ADDR_EXP 171
101770: PUSH
101771: LD_INT 0
101773: ST_TO_ADDR
// sFog := false ;
101774: LD_ADDR_EXP 174
101778: PUSH
101779: LD_INT 0
101781: ST_TO_ADDR
// sReset := false ;
101782: LD_ADDR_EXP 175
101786: PUSH
101787: LD_INT 0
101789: ST_TO_ADDR
// sSun := false ;
101790: LD_ADDR_EXP 176
101794: PUSH
101795: LD_INT 0
101797: ST_TO_ADDR
// sTiger := false ;
101798: LD_ADDR_EXP 172
101802: PUSH
101803: LD_INT 0
101805: ST_TO_ADDR
// sBomb := false ;
101806: LD_ADDR_EXP 173
101810: PUSH
101811: LD_INT 0
101813: ST_TO_ADDR
// sWound := false ;
101814: LD_ADDR_EXP 181
101818: PUSH
101819: LD_INT 0
101821: ST_TO_ADDR
// sBetray := false ;
101822: LD_ADDR_EXP 185
101826: PUSH
101827: LD_INT 0
101829: ST_TO_ADDR
// sContamin := false ;
101830: LD_ADDR_EXP 186
101834: PUSH
101835: LD_INT 0
101837: ST_TO_ADDR
// sOil := false ;
101838: LD_ADDR_EXP 188
101842: PUSH
101843: LD_INT 0
101845: ST_TO_ADDR
// sStu := false ;
101846: LD_ADDR_EXP 192
101850: PUSH
101851: LD_INT 0
101853: ST_TO_ADDR
// sBazooka := false ;
101854: LD_ADDR_EXP 195
101858: PUSH
101859: LD_INT 0
101861: ST_TO_ADDR
// sMortar := false ;
101862: LD_ADDR_EXP 196
101866: PUSH
101867: LD_INT 0
101869: ST_TO_ADDR
// sRanger := false ;
101870: LD_ADDR_EXP 206
101874: PUSH
101875: LD_INT 0
101877: ST_TO_ADDR
// end ;
101878: LD_VAR 0 1
101882: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
101883: LD_INT 0
101885: PPUSH
101886: PPUSH
101887: PPUSH
101888: PPUSH
101889: PPUSH
// result := [ ] ;
101890: LD_ADDR_VAR 0 1
101894: PUSH
101895: EMPTY
101896: ST_TO_ADDR
// if campaign_id = 1 then
101897: LD_OWVAR 69
101901: PUSH
101902: LD_INT 1
101904: EQUAL
101905: IFFALSE 104843
// begin case mission_number of 1 :
101907: LD_OWVAR 70
101911: PUSH
101912: LD_INT 1
101914: DOUBLE
101915: EQUAL
101916: IFTRUE 101920
101918: GO 101984
101920: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
101921: LD_ADDR_VAR 0 1
101925: PUSH
101926: LD_INT 2
101928: PUSH
101929: LD_INT 4
101931: PUSH
101932: LD_INT 11
101934: PUSH
101935: LD_INT 12
101937: PUSH
101938: LD_INT 15
101940: PUSH
101941: LD_INT 16
101943: PUSH
101944: LD_INT 22
101946: PUSH
101947: LD_INT 23
101949: PUSH
101950: LD_INT 26
101952: PUSH
101953: EMPTY
101954: LIST
101955: LIST
101956: LIST
101957: LIST
101958: LIST
101959: LIST
101960: LIST
101961: LIST
101962: LIST
101963: PUSH
101964: LD_INT 101
101966: PUSH
101967: LD_INT 102
101969: PUSH
101970: LD_INT 106
101972: PUSH
101973: EMPTY
101974: LIST
101975: LIST
101976: LIST
101977: PUSH
101978: EMPTY
101979: LIST
101980: LIST
101981: ST_TO_ADDR
101982: GO 104841
101984: LD_INT 2
101986: DOUBLE
101987: EQUAL
101988: IFTRUE 101992
101990: GO 102064
101992: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
101993: LD_ADDR_VAR 0 1
101997: PUSH
101998: LD_INT 2
102000: PUSH
102001: LD_INT 4
102003: PUSH
102004: LD_INT 11
102006: PUSH
102007: LD_INT 12
102009: PUSH
102010: LD_INT 15
102012: PUSH
102013: LD_INT 16
102015: PUSH
102016: LD_INT 22
102018: PUSH
102019: LD_INT 23
102021: PUSH
102022: LD_INT 26
102024: PUSH
102025: EMPTY
102026: LIST
102027: LIST
102028: LIST
102029: LIST
102030: LIST
102031: LIST
102032: LIST
102033: LIST
102034: LIST
102035: PUSH
102036: LD_INT 101
102038: PUSH
102039: LD_INT 102
102041: PUSH
102042: LD_INT 105
102044: PUSH
102045: LD_INT 106
102047: PUSH
102048: LD_INT 108
102050: PUSH
102051: EMPTY
102052: LIST
102053: LIST
102054: LIST
102055: LIST
102056: LIST
102057: PUSH
102058: EMPTY
102059: LIST
102060: LIST
102061: ST_TO_ADDR
102062: GO 104841
102064: LD_INT 3
102066: DOUBLE
102067: EQUAL
102068: IFTRUE 102072
102070: GO 102148
102072: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
102073: LD_ADDR_VAR 0 1
102077: PUSH
102078: LD_INT 2
102080: PUSH
102081: LD_INT 4
102083: PUSH
102084: LD_INT 5
102086: PUSH
102087: LD_INT 11
102089: PUSH
102090: LD_INT 12
102092: PUSH
102093: LD_INT 15
102095: PUSH
102096: LD_INT 16
102098: PUSH
102099: LD_INT 22
102101: PUSH
102102: LD_INT 26
102104: PUSH
102105: LD_INT 36
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: LIST
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: PUSH
102120: LD_INT 101
102122: PUSH
102123: LD_INT 102
102125: PUSH
102126: LD_INT 105
102128: PUSH
102129: LD_INT 106
102131: PUSH
102132: LD_INT 108
102134: PUSH
102135: EMPTY
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: ST_TO_ADDR
102146: GO 104841
102148: LD_INT 4
102150: DOUBLE
102151: EQUAL
102152: IFTRUE 102156
102154: GO 102240
102156: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
102157: LD_ADDR_VAR 0 1
102161: PUSH
102162: LD_INT 2
102164: PUSH
102165: LD_INT 4
102167: PUSH
102168: LD_INT 5
102170: PUSH
102171: LD_INT 8
102173: PUSH
102174: LD_INT 11
102176: PUSH
102177: LD_INT 12
102179: PUSH
102180: LD_INT 15
102182: PUSH
102183: LD_INT 16
102185: PUSH
102186: LD_INT 22
102188: PUSH
102189: LD_INT 23
102191: PUSH
102192: LD_INT 26
102194: PUSH
102195: LD_INT 36
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: LIST
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: PUSH
102212: LD_INT 101
102214: PUSH
102215: LD_INT 102
102217: PUSH
102218: LD_INT 105
102220: PUSH
102221: LD_INT 106
102223: PUSH
102224: LD_INT 108
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: ST_TO_ADDR
102238: GO 104841
102240: LD_INT 5
102242: DOUBLE
102243: EQUAL
102244: IFTRUE 102248
102246: GO 102348
102248: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
102249: LD_ADDR_VAR 0 1
102253: PUSH
102254: LD_INT 2
102256: PUSH
102257: LD_INT 4
102259: PUSH
102260: LD_INT 5
102262: PUSH
102263: LD_INT 6
102265: PUSH
102266: LD_INT 8
102268: PUSH
102269: LD_INT 11
102271: PUSH
102272: LD_INT 12
102274: PUSH
102275: LD_INT 15
102277: PUSH
102278: LD_INT 16
102280: PUSH
102281: LD_INT 22
102283: PUSH
102284: LD_INT 23
102286: PUSH
102287: LD_INT 25
102289: PUSH
102290: LD_INT 26
102292: PUSH
102293: LD_INT 36
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: LIST
102304: LIST
102305: LIST
102306: LIST
102307: LIST
102308: LIST
102309: LIST
102310: LIST
102311: PUSH
102312: LD_INT 101
102314: PUSH
102315: LD_INT 102
102317: PUSH
102318: LD_INT 105
102320: PUSH
102321: LD_INT 106
102323: PUSH
102324: LD_INT 108
102326: PUSH
102327: LD_INT 109
102329: PUSH
102330: LD_INT 112
102332: PUSH
102333: EMPTY
102334: LIST
102335: LIST
102336: LIST
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: ST_TO_ADDR
102346: GO 104841
102348: LD_INT 6
102350: DOUBLE
102351: EQUAL
102352: IFTRUE 102356
102354: GO 102476
102356: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
102357: LD_ADDR_VAR 0 1
102361: PUSH
102362: LD_INT 2
102364: PUSH
102365: LD_INT 4
102367: PUSH
102368: LD_INT 5
102370: PUSH
102371: LD_INT 6
102373: PUSH
102374: LD_INT 8
102376: PUSH
102377: LD_INT 11
102379: PUSH
102380: LD_INT 12
102382: PUSH
102383: LD_INT 15
102385: PUSH
102386: LD_INT 16
102388: PUSH
102389: LD_INT 20
102391: PUSH
102392: LD_INT 21
102394: PUSH
102395: LD_INT 22
102397: PUSH
102398: LD_INT 23
102400: PUSH
102401: LD_INT 25
102403: PUSH
102404: LD_INT 26
102406: PUSH
102407: LD_INT 30
102409: PUSH
102410: LD_INT 31
102412: PUSH
102413: LD_INT 32
102415: PUSH
102416: LD_INT 36
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: LIST
102425: LIST
102426: LIST
102427: LIST
102428: LIST
102429: LIST
102430: LIST
102431: LIST
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: LIST
102437: LIST
102438: LIST
102439: PUSH
102440: LD_INT 101
102442: PUSH
102443: LD_INT 102
102445: PUSH
102446: LD_INT 105
102448: PUSH
102449: LD_INT 106
102451: PUSH
102452: LD_INT 108
102454: PUSH
102455: LD_INT 109
102457: PUSH
102458: LD_INT 112
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: LIST
102465: LIST
102466: LIST
102467: LIST
102468: LIST
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: ST_TO_ADDR
102474: GO 104841
102476: LD_INT 7
102478: DOUBLE
102479: EQUAL
102480: IFTRUE 102484
102482: GO 102584
102484: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
102485: LD_ADDR_VAR 0 1
102489: PUSH
102490: LD_INT 2
102492: PUSH
102493: LD_INT 4
102495: PUSH
102496: LD_INT 5
102498: PUSH
102499: LD_INT 7
102501: PUSH
102502: LD_INT 11
102504: PUSH
102505: LD_INT 12
102507: PUSH
102508: LD_INT 15
102510: PUSH
102511: LD_INT 16
102513: PUSH
102514: LD_INT 20
102516: PUSH
102517: LD_INT 21
102519: PUSH
102520: LD_INT 22
102522: PUSH
102523: LD_INT 23
102525: PUSH
102526: LD_INT 25
102528: PUSH
102529: LD_INT 26
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: LIST
102546: LIST
102547: PUSH
102548: LD_INT 101
102550: PUSH
102551: LD_INT 102
102553: PUSH
102554: LD_INT 103
102556: PUSH
102557: LD_INT 105
102559: PUSH
102560: LD_INT 106
102562: PUSH
102563: LD_INT 108
102565: PUSH
102566: LD_INT 112
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: PUSH
102578: EMPTY
102579: LIST
102580: LIST
102581: ST_TO_ADDR
102582: GO 104841
102584: LD_INT 8
102586: DOUBLE
102587: EQUAL
102588: IFTRUE 102592
102590: GO 102720
102592: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
102593: LD_ADDR_VAR 0 1
102597: PUSH
102598: LD_INT 2
102600: PUSH
102601: LD_INT 4
102603: PUSH
102604: LD_INT 5
102606: PUSH
102607: LD_INT 6
102609: PUSH
102610: LD_INT 7
102612: PUSH
102613: LD_INT 8
102615: PUSH
102616: LD_INT 11
102618: PUSH
102619: LD_INT 12
102621: PUSH
102622: LD_INT 15
102624: PUSH
102625: LD_INT 16
102627: PUSH
102628: LD_INT 20
102630: PUSH
102631: LD_INT 21
102633: PUSH
102634: LD_INT 22
102636: PUSH
102637: LD_INT 23
102639: PUSH
102640: LD_INT 25
102642: PUSH
102643: LD_INT 26
102645: PUSH
102646: LD_INT 30
102648: PUSH
102649: LD_INT 31
102651: PUSH
102652: LD_INT 32
102654: PUSH
102655: LD_INT 36
102657: PUSH
102658: EMPTY
102659: LIST
102660: LIST
102661: LIST
102662: LIST
102663: LIST
102664: LIST
102665: LIST
102666: LIST
102667: LIST
102668: LIST
102669: LIST
102670: LIST
102671: LIST
102672: LIST
102673: LIST
102674: LIST
102675: LIST
102676: LIST
102677: LIST
102678: LIST
102679: PUSH
102680: LD_INT 101
102682: PUSH
102683: LD_INT 102
102685: PUSH
102686: LD_INT 103
102688: PUSH
102689: LD_INT 105
102691: PUSH
102692: LD_INT 106
102694: PUSH
102695: LD_INT 108
102697: PUSH
102698: LD_INT 109
102700: PUSH
102701: LD_INT 112
102703: PUSH
102704: EMPTY
102705: LIST
102706: LIST
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: PUSH
102714: EMPTY
102715: LIST
102716: LIST
102717: ST_TO_ADDR
102718: GO 104841
102720: LD_INT 9
102722: DOUBLE
102723: EQUAL
102724: IFTRUE 102728
102726: GO 102864
102728: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
102729: LD_ADDR_VAR 0 1
102733: PUSH
102734: LD_INT 2
102736: PUSH
102737: LD_INT 4
102739: PUSH
102740: LD_INT 5
102742: PUSH
102743: LD_INT 6
102745: PUSH
102746: LD_INT 7
102748: PUSH
102749: LD_INT 8
102751: PUSH
102752: LD_INT 11
102754: PUSH
102755: LD_INT 12
102757: PUSH
102758: LD_INT 15
102760: PUSH
102761: LD_INT 16
102763: PUSH
102764: LD_INT 20
102766: PUSH
102767: LD_INT 21
102769: PUSH
102770: LD_INT 22
102772: PUSH
102773: LD_INT 23
102775: PUSH
102776: LD_INT 25
102778: PUSH
102779: LD_INT 26
102781: PUSH
102782: LD_INT 28
102784: PUSH
102785: LD_INT 30
102787: PUSH
102788: LD_INT 31
102790: PUSH
102791: LD_INT 32
102793: PUSH
102794: LD_INT 36
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: LIST
102801: LIST
102802: LIST
102803: LIST
102804: LIST
102805: LIST
102806: LIST
102807: LIST
102808: LIST
102809: LIST
102810: LIST
102811: LIST
102812: LIST
102813: LIST
102814: LIST
102815: LIST
102816: LIST
102817: LIST
102818: LIST
102819: PUSH
102820: LD_INT 101
102822: PUSH
102823: LD_INT 102
102825: PUSH
102826: LD_INT 103
102828: PUSH
102829: LD_INT 105
102831: PUSH
102832: LD_INT 106
102834: PUSH
102835: LD_INT 108
102837: PUSH
102838: LD_INT 109
102840: PUSH
102841: LD_INT 112
102843: PUSH
102844: LD_INT 114
102846: PUSH
102847: EMPTY
102848: LIST
102849: LIST
102850: LIST
102851: LIST
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: LIST
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: ST_TO_ADDR
102862: GO 104841
102864: LD_INT 10
102866: DOUBLE
102867: EQUAL
102868: IFTRUE 102872
102870: GO 103056
102872: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
102873: LD_ADDR_VAR 0 1
102877: PUSH
102878: LD_INT 2
102880: PUSH
102881: LD_INT 4
102883: PUSH
102884: LD_INT 5
102886: PUSH
102887: LD_INT 6
102889: PUSH
102890: LD_INT 7
102892: PUSH
102893: LD_INT 8
102895: PUSH
102896: LD_INT 9
102898: PUSH
102899: LD_INT 10
102901: PUSH
102902: LD_INT 11
102904: PUSH
102905: LD_INT 12
102907: PUSH
102908: LD_INT 13
102910: PUSH
102911: LD_INT 14
102913: PUSH
102914: LD_INT 15
102916: PUSH
102917: LD_INT 16
102919: PUSH
102920: LD_INT 17
102922: PUSH
102923: LD_INT 18
102925: PUSH
102926: LD_INT 19
102928: PUSH
102929: LD_INT 20
102931: PUSH
102932: LD_INT 21
102934: PUSH
102935: LD_INT 22
102937: PUSH
102938: LD_INT 23
102940: PUSH
102941: LD_INT 24
102943: PUSH
102944: LD_INT 25
102946: PUSH
102947: LD_INT 26
102949: PUSH
102950: LD_INT 28
102952: PUSH
102953: LD_INT 30
102955: PUSH
102956: LD_INT 31
102958: PUSH
102959: LD_INT 32
102961: PUSH
102962: LD_INT 36
102964: PUSH
102965: EMPTY
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: LIST
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: LIST
102978: LIST
102979: LIST
102980: LIST
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: LIST
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: LIST
102991: LIST
102992: LIST
102993: LIST
102994: LIST
102995: PUSH
102996: LD_INT 101
102998: PUSH
102999: LD_INT 102
103001: PUSH
103002: LD_INT 103
103004: PUSH
103005: LD_INT 104
103007: PUSH
103008: LD_INT 105
103010: PUSH
103011: LD_INT 106
103013: PUSH
103014: LD_INT 107
103016: PUSH
103017: LD_INT 108
103019: PUSH
103020: LD_INT 109
103022: PUSH
103023: LD_INT 110
103025: PUSH
103026: LD_INT 111
103028: PUSH
103029: LD_INT 112
103031: PUSH
103032: LD_INT 114
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: LIST
103039: LIST
103040: LIST
103041: LIST
103042: LIST
103043: LIST
103044: LIST
103045: LIST
103046: LIST
103047: LIST
103048: LIST
103049: PUSH
103050: EMPTY
103051: LIST
103052: LIST
103053: ST_TO_ADDR
103054: GO 104841
103056: LD_INT 11
103058: DOUBLE
103059: EQUAL
103060: IFTRUE 103064
103062: GO 103256
103064: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
103065: LD_ADDR_VAR 0 1
103069: PUSH
103070: LD_INT 2
103072: PUSH
103073: LD_INT 3
103075: PUSH
103076: LD_INT 4
103078: PUSH
103079: LD_INT 5
103081: PUSH
103082: LD_INT 6
103084: PUSH
103085: LD_INT 7
103087: PUSH
103088: LD_INT 8
103090: PUSH
103091: LD_INT 9
103093: PUSH
103094: LD_INT 10
103096: PUSH
103097: LD_INT 11
103099: PUSH
103100: LD_INT 12
103102: PUSH
103103: LD_INT 13
103105: PUSH
103106: LD_INT 14
103108: PUSH
103109: LD_INT 15
103111: PUSH
103112: LD_INT 16
103114: PUSH
103115: LD_INT 17
103117: PUSH
103118: LD_INT 18
103120: PUSH
103121: LD_INT 19
103123: PUSH
103124: LD_INT 20
103126: PUSH
103127: LD_INT 21
103129: PUSH
103130: LD_INT 22
103132: PUSH
103133: LD_INT 23
103135: PUSH
103136: LD_INT 24
103138: PUSH
103139: LD_INT 25
103141: PUSH
103142: LD_INT 26
103144: PUSH
103145: LD_INT 28
103147: PUSH
103148: LD_INT 30
103150: PUSH
103151: LD_INT 31
103153: PUSH
103154: LD_INT 32
103156: PUSH
103157: LD_INT 34
103159: PUSH
103160: LD_INT 36
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: LIST
103173: LIST
103174: LIST
103175: LIST
103176: LIST
103177: LIST
103178: LIST
103179: LIST
103180: LIST
103181: LIST
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: LIST
103194: LIST
103195: PUSH
103196: LD_INT 101
103198: PUSH
103199: LD_INT 102
103201: PUSH
103202: LD_INT 103
103204: PUSH
103205: LD_INT 104
103207: PUSH
103208: LD_INT 105
103210: PUSH
103211: LD_INT 106
103213: PUSH
103214: LD_INT 107
103216: PUSH
103217: LD_INT 108
103219: PUSH
103220: LD_INT 109
103222: PUSH
103223: LD_INT 110
103225: PUSH
103226: LD_INT 111
103228: PUSH
103229: LD_INT 112
103231: PUSH
103232: LD_INT 114
103234: PUSH
103235: EMPTY
103236: LIST
103237: LIST
103238: LIST
103239: LIST
103240: LIST
103241: LIST
103242: LIST
103243: LIST
103244: LIST
103245: LIST
103246: LIST
103247: LIST
103248: LIST
103249: PUSH
103250: EMPTY
103251: LIST
103252: LIST
103253: ST_TO_ADDR
103254: GO 104841
103256: LD_INT 12
103258: DOUBLE
103259: EQUAL
103260: IFTRUE 103264
103262: GO 103472
103264: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
103265: LD_ADDR_VAR 0 1
103269: PUSH
103270: LD_INT 1
103272: PUSH
103273: LD_INT 2
103275: PUSH
103276: LD_INT 3
103278: PUSH
103279: LD_INT 4
103281: PUSH
103282: LD_INT 5
103284: PUSH
103285: LD_INT 6
103287: PUSH
103288: LD_INT 7
103290: PUSH
103291: LD_INT 8
103293: PUSH
103294: LD_INT 9
103296: PUSH
103297: LD_INT 10
103299: PUSH
103300: LD_INT 11
103302: PUSH
103303: LD_INT 12
103305: PUSH
103306: LD_INT 13
103308: PUSH
103309: LD_INT 14
103311: PUSH
103312: LD_INT 15
103314: PUSH
103315: LD_INT 16
103317: PUSH
103318: LD_INT 17
103320: PUSH
103321: LD_INT 18
103323: PUSH
103324: LD_INT 19
103326: PUSH
103327: LD_INT 20
103329: PUSH
103330: LD_INT 21
103332: PUSH
103333: LD_INT 22
103335: PUSH
103336: LD_INT 23
103338: PUSH
103339: LD_INT 24
103341: PUSH
103342: LD_INT 25
103344: PUSH
103345: LD_INT 26
103347: PUSH
103348: LD_INT 27
103350: PUSH
103351: LD_INT 28
103353: PUSH
103354: LD_INT 30
103356: PUSH
103357: LD_INT 31
103359: PUSH
103360: LD_INT 32
103362: PUSH
103363: LD_INT 33
103365: PUSH
103366: LD_INT 34
103368: PUSH
103369: LD_INT 36
103371: PUSH
103372: EMPTY
103373: LIST
103374: LIST
103375: LIST
103376: LIST
103377: LIST
103378: LIST
103379: LIST
103380: LIST
103381: LIST
103382: LIST
103383: LIST
103384: LIST
103385: LIST
103386: LIST
103387: LIST
103388: LIST
103389: LIST
103390: LIST
103391: LIST
103392: LIST
103393: LIST
103394: LIST
103395: LIST
103396: LIST
103397: LIST
103398: LIST
103399: LIST
103400: LIST
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: LIST
103407: PUSH
103408: LD_INT 101
103410: PUSH
103411: LD_INT 102
103413: PUSH
103414: LD_INT 103
103416: PUSH
103417: LD_INT 104
103419: PUSH
103420: LD_INT 105
103422: PUSH
103423: LD_INT 106
103425: PUSH
103426: LD_INT 107
103428: PUSH
103429: LD_INT 108
103431: PUSH
103432: LD_INT 109
103434: PUSH
103435: LD_INT 110
103437: PUSH
103438: LD_INT 111
103440: PUSH
103441: LD_INT 112
103443: PUSH
103444: LD_INT 113
103446: PUSH
103447: LD_INT 114
103449: PUSH
103450: EMPTY
103451: LIST
103452: LIST
103453: LIST
103454: LIST
103455: LIST
103456: LIST
103457: LIST
103458: LIST
103459: LIST
103460: LIST
103461: LIST
103462: LIST
103463: LIST
103464: LIST
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: ST_TO_ADDR
103470: GO 104841
103472: LD_INT 13
103474: DOUBLE
103475: EQUAL
103476: IFTRUE 103480
103478: GO 103676
103480: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
103481: LD_ADDR_VAR 0 1
103485: PUSH
103486: LD_INT 1
103488: PUSH
103489: LD_INT 2
103491: PUSH
103492: LD_INT 3
103494: PUSH
103495: LD_INT 4
103497: PUSH
103498: LD_INT 5
103500: PUSH
103501: LD_INT 8
103503: PUSH
103504: LD_INT 9
103506: PUSH
103507: LD_INT 10
103509: PUSH
103510: LD_INT 11
103512: PUSH
103513: LD_INT 12
103515: PUSH
103516: LD_INT 14
103518: PUSH
103519: LD_INT 15
103521: PUSH
103522: LD_INT 16
103524: PUSH
103525: LD_INT 17
103527: PUSH
103528: LD_INT 18
103530: PUSH
103531: LD_INT 19
103533: PUSH
103534: LD_INT 20
103536: PUSH
103537: LD_INT 21
103539: PUSH
103540: LD_INT 22
103542: PUSH
103543: LD_INT 23
103545: PUSH
103546: LD_INT 24
103548: PUSH
103549: LD_INT 25
103551: PUSH
103552: LD_INT 26
103554: PUSH
103555: LD_INT 27
103557: PUSH
103558: LD_INT 28
103560: PUSH
103561: LD_INT 30
103563: PUSH
103564: LD_INT 31
103566: PUSH
103567: LD_INT 32
103569: PUSH
103570: LD_INT 33
103572: PUSH
103573: LD_INT 34
103575: PUSH
103576: LD_INT 36
103578: PUSH
103579: EMPTY
103580: LIST
103581: LIST
103582: LIST
103583: LIST
103584: LIST
103585: LIST
103586: LIST
103587: LIST
103588: LIST
103589: LIST
103590: LIST
103591: LIST
103592: LIST
103593: LIST
103594: LIST
103595: LIST
103596: LIST
103597: LIST
103598: LIST
103599: LIST
103600: LIST
103601: LIST
103602: LIST
103603: LIST
103604: LIST
103605: LIST
103606: LIST
103607: LIST
103608: LIST
103609: LIST
103610: LIST
103611: PUSH
103612: LD_INT 101
103614: PUSH
103615: LD_INT 102
103617: PUSH
103618: LD_INT 103
103620: PUSH
103621: LD_INT 104
103623: PUSH
103624: LD_INT 105
103626: PUSH
103627: LD_INT 106
103629: PUSH
103630: LD_INT 107
103632: PUSH
103633: LD_INT 108
103635: PUSH
103636: LD_INT 109
103638: PUSH
103639: LD_INT 110
103641: PUSH
103642: LD_INT 111
103644: PUSH
103645: LD_INT 112
103647: PUSH
103648: LD_INT 113
103650: PUSH
103651: LD_INT 114
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: LIST
103658: LIST
103659: LIST
103660: LIST
103661: LIST
103662: LIST
103663: LIST
103664: LIST
103665: LIST
103666: LIST
103667: LIST
103668: LIST
103669: PUSH
103670: EMPTY
103671: LIST
103672: LIST
103673: ST_TO_ADDR
103674: GO 104841
103676: LD_INT 14
103678: DOUBLE
103679: EQUAL
103680: IFTRUE 103684
103682: GO 103896
103684: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
103685: LD_ADDR_VAR 0 1
103689: PUSH
103690: LD_INT 1
103692: PUSH
103693: LD_INT 2
103695: PUSH
103696: LD_INT 3
103698: PUSH
103699: LD_INT 4
103701: PUSH
103702: LD_INT 5
103704: PUSH
103705: LD_INT 6
103707: PUSH
103708: LD_INT 7
103710: PUSH
103711: LD_INT 8
103713: PUSH
103714: LD_INT 9
103716: PUSH
103717: LD_INT 10
103719: PUSH
103720: LD_INT 11
103722: PUSH
103723: LD_INT 12
103725: PUSH
103726: LD_INT 13
103728: PUSH
103729: LD_INT 14
103731: PUSH
103732: LD_INT 15
103734: PUSH
103735: LD_INT 16
103737: PUSH
103738: LD_INT 17
103740: PUSH
103741: LD_INT 18
103743: PUSH
103744: LD_INT 19
103746: PUSH
103747: LD_INT 20
103749: PUSH
103750: LD_INT 21
103752: PUSH
103753: LD_INT 22
103755: PUSH
103756: LD_INT 23
103758: PUSH
103759: LD_INT 24
103761: PUSH
103762: LD_INT 25
103764: PUSH
103765: LD_INT 26
103767: PUSH
103768: LD_INT 27
103770: PUSH
103771: LD_INT 28
103773: PUSH
103774: LD_INT 29
103776: PUSH
103777: LD_INT 30
103779: PUSH
103780: LD_INT 31
103782: PUSH
103783: LD_INT 32
103785: PUSH
103786: LD_INT 33
103788: PUSH
103789: LD_INT 34
103791: PUSH
103792: LD_INT 36
103794: PUSH
103795: EMPTY
103796: LIST
103797: LIST
103798: LIST
103799: LIST
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: LIST
103808: LIST
103809: LIST
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: LIST
103815: LIST
103816: LIST
103817: LIST
103818: LIST
103819: LIST
103820: LIST
103821: LIST
103822: LIST
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: LIST
103830: LIST
103831: PUSH
103832: LD_INT 101
103834: PUSH
103835: LD_INT 102
103837: PUSH
103838: LD_INT 103
103840: PUSH
103841: LD_INT 104
103843: PUSH
103844: LD_INT 105
103846: PUSH
103847: LD_INT 106
103849: PUSH
103850: LD_INT 107
103852: PUSH
103853: LD_INT 108
103855: PUSH
103856: LD_INT 109
103858: PUSH
103859: LD_INT 110
103861: PUSH
103862: LD_INT 111
103864: PUSH
103865: LD_INT 112
103867: PUSH
103868: LD_INT 113
103870: PUSH
103871: LD_INT 114
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: LIST
103878: LIST
103879: LIST
103880: LIST
103881: LIST
103882: LIST
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: LIST
103888: LIST
103889: PUSH
103890: EMPTY
103891: LIST
103892: LIST
103893: ST_TO_ADDR
103894: GO 104841
103896: LD_INT 15
103898: DOUBLE
103899: EQUAL
103900: IFTRUE 103904
103902: GO 104116
103904: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
103905: LD_ADDR_VAR 0 1
103909: PUSH
103910: LD_INT 1
103912: PUSH
103913: LD_INT 2
103915: PUSH
103916: LD_INT 3
103918: PUSH
103919: LD_INT 4
103921: PUSH
103922: LD_INT 5
103924: PUSH
103925: LD_INT 6
103927: PUSH
103928: LD_INT 7
103930: PUSH
103931: LD_INT 8
103933: PUSH
103934: LD_INT 9
103936: PUSH
103937: LD_INT 10
103939: PUSH
103940: LD_INT 11
103942: PUSH
103943: LD_INT 12
103945: PUSH
103946: LD_INT 13
103948: PUSH
103949: LD_INT 14
103951: PUSH
103952: LD_INT 15
103954: PUSH
103955: LD_INT 16
103957: PUSH
103958: LD_INT 17
103960: PUSH
103961: LD_INT 18
103963: PUSH
103964: LD_INT 19
103966: PUSH
103967: LD_INT 20
103969: PUSH
103970: LD_INT 21
103972: PUSH
103973: LD_INT 22
103975: PUSH
103976: LD_INT 23
103978: PUSH
103979: LD_INT 24
103981: PUSH
103982: LD_INT 25
103984: PUSH
103985: LD_INT 26
103987: PUSH
103988: LD_INT 27
103990: PUSH
103991: LD_INT 28
103993: PUSH
103994: LD_INT 29
103996: PUSH
103997: LD_INT 30
103999: PUSH
104000: LD_INT 31
104002: PUSH
104003: LD_INT 32
104005: PUSH
104006: LD_INT 33
104008: PUSH
104009: LD_INT 34
104011: PUSH
104012: LD_INT 36
104014: PUSH
104015: EMPTY
104016: LIST
104017: LIST
104018: LIST
104019: LIST
104020: LIST
104021: LIST
104022: LIST
104023: LIST
104024: LIST
104025: LIST
104026: LIST
104027: LIST
104028: LIST
104029: LIST
104030: LIST
104031: LIST
104032: LIST
104033: LIST
104034: LIST
104035: LIST
104036: LIST
104037: LIST
104038: LIST
104039: LIST
104040: LIST
104041: LIST
104042: LIST
104043: LIST
104044: LIST
104045: LIST
104046: LIST
104047: LIST
104048: LIST
104049: LIST
104050: LIST
104051: PUSH
104052: LD_INT 101
104054: PUSH
104055: LD_INT 102
104057: PUSH
104058: LD_INT 103
104060: PUSH
104061: LD_INT 104
104063: PUSH
104064: LD_INT 105
104066: PUSH
104067: LD_INT 106
104069: PUSH
104070: LD_INT 107
104072: PUSH
104073: LD_INT 108
104075: PUSH
104076: LD_INT 109
104078: PUSH
104079: LD_INT 110
104081: PUSH
104082: LD_INT 111
104084: PUSH
104085: LD_INT 112
104087: PUSH
104088: LD_INT 113
104090: PUSH
104091: LD_INT 114
104093: PUSH
104094: EMPTY
104095: LIST
104096: LIST
104097: LIST
104098: LIST
104099: LIST
104100: LIST
104101: LIST
104102: LIST
104103: LIST
104104: LIST
104105: LIST
104106: LIST
104107: LIST
104108: LIST
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: ST_TO_ADDR
104114: GO 104841
104116: LD_INT 16
104118: DOUBLE
104119: EQUAL
104120: IFTRUE 104124
104122: GO 104248
104124: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
104125: LD_ADDR_VAR 0 1
104129: PUSH
104130: LD_INT 2
104132: PUSH
104133: LD_INT 4
104135: PUSH
104136: LD_INT 5
104138: PUSH
104139: LD_INT 7
104141: PUSH
104142: LD_INT 11
104144: PUSH
104145: LD_INT 12
104147: PUSH
104148: LD_INT 15
104150: PUSH
104151: LD_INT 16
104153: PUSH
104154: LD_INT 20
104156: PUSH
104157: LD_INT 21
104159: PUSH
104160: LD_INT 22
104162: PUSH
104163: LD_INT 23
104165: PUSH
104166: LD_INT 25
104168: PUSH
104169: LD_INT 26
104171: PUSH
104172: LD_INT 30
104174: PUSH
104175: LD_INT 31
104177: PUSH
104178: LD_INT 32
104180: PUSH
104181: LD_INT 33
104183: PUSH
104184: LD_INT 34
104186: PUSH
104187: EMPTY
104188: LIST
104189: LIST
104190: LIST
104191: LIST
104192: LIST
104193: LIST
104194: LIST
104195: LIST
104196: LIST
104197: LIST
104198: LIST
104199: LIST
104200: LIST
104201: LIST
104202: LIST
104203: LIST
104204: LIST
104205: LIST
104206: LIST
104207: PUSH
104208: LD_INT 101
104210: PUSH
104211: LD_INT 102
104213: PUSH
104214: LD_INT 103
104216: PUSH
104217: LD_INT 106
104219: PUSH
104220: LD_INT 108
104222: PUSH
104223: LD_INT 112
104225: PUSH
104226: LD_INT 113
104228: PUSH
104229: LD_INT 114
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: LIST
104236: LIST
104237: LIST
104238: LIST
104239: LIST
104240: LIST
104241: PUSH
104242: EMPTY
104243: LIST
104244: LIST
104245: ST_TO_ADDR
104246: GO 104841
104248: LD_INT 17
104250: DOUBLE
104251: EQUAL
104252: IFTRUE 104256
104254: GO 104468
104256: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
104257: LD_ADDR_VAR 0 1
104261: PUSH
104262: LD_INT 1
104264: PUSH
104265: LD_INT 2
104267: PUSH
104268: LD_INT 3
104270: PUSH
104271: LD_INT 4
104273: PUSH
104274: LD_INT 5
104276: PUSH
104277: LD_INT 6
104279: PUSH
104280: LD_INT 7
104282: PUSH
104283: LD_INT 8
104285: PUSH
104286: LD_INT 9
104288: PUSH
104289: LD_INT 10
104291: PUSH
104292: LD_INT 11
104294: PUSH
104295: LD_INT 12
104297: PUSH
104298: LD_INT 13
104300: PUSH
104301: LD_INT 14
104303: PUSH
104304: LD_INT 15
104306: PUSH
104307: LD_INT 16
104309: PUSH
104310: LD_INT 17
104312: PUSH
104313: LD_INT 18
104315: PUSH
104316: LD_INT 19
104318: PUSH
104319: LD_INT 20
104321: PUSH
104322: LD_INT 21
104324: PUSH
104325: LD_INT 22
104327: PUSH
104328: LD_INT 23
104330: PUSH
104331: LD_INT 24
104333: PUSH
104334: LD_INT 25
104336: PUSH
104337: LD_INT 26
104339: PUSH
104340: LD_INT 27
104342: PUSH
104343: LD_INT 28
104345: PUSH
104346: LD_INT 29
104348: PUSH
104349: LD_INT 30
104351: PUSH
104352: LD_INT 31
104354: PUSH
104355: LD_INT 32
104357: PUSH
104358: LD_INT 33
104360: PUSH
104361: LD_INT 34
104363: PUSH
104364: LD_INT 36
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: LIST
104371: LIST
104372: LIST
104373: LIST
104374: LIST
104375: LIST
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: LIST
104393: LIST
104394: LIST
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: LIST
104400: LIST
104401: LIST
104402: LIST
104403: PUSH
104404: LD_INT 101
104406: PUSH
104407: LD_INT 102
104409: PUSH
104410: LD_INT 103
104412: PUSH
104413: LD_INT 104
104415: PUSH
104416: LD_INT 105
104418: PUSH
104419: LD_INT 106
104421: PUSH
104422: LD_INT 107
104424: PUSH
104425: LD_INT 108
104427: PUSH
104428: LD_INT 109
104430: PUSH
104431: LD_INT 110
104433: PUSH
104434: LD_INT 111
104436: PUSH
104437: LD_INT 112
104439: PUSH
104440: LD_INT 113
104442: PUSH
104443: LD_INT 114
104445: PUSH
104446: EMPTY
104447: LIST
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: PUSH
104462: EMPTY
104463: LIST
104464: LIST
104465: ST_TO_ADDR
104466: GO 104841
104468: LD_INT 18
104470: DOUBLE
104471: EQUAL
104472: IFTRUE 104476
104474: GO 104612
104476: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
104477: LD_ADDR_VAR 0 1
104481: PUSH
104482: LD_INT 2
104484: PUSH
104485: LD_INT 4
104487: PUSH
104488: LD_INT 5
104490: PUSH
104491: LD_INT 7
104493: PUSH
104494: LD_INT 11
104496: PUSH
104497: LD_INT 12
104499: PUSH
104500: LD_INT 15
104502: PUSH
104503: LD_INT 16
104505: PUSH
104506: LD_INT 20
104508: PUSH
104509: LD_INT 21
104511: PUSH
104512: LD_INT 22
104514: PUSH
104515: LD_INT 23
104517: PUSH
104518: LD_INT 25
104520: PUSH
104521: LD_INT 26
104523: PUSH
104524: LD_INT 30
104526: PUSH
104527: LD_INT 31
104529: PUSH
104530: LD_INT 32
104532: PUSH
104533: LD_INT 33
104535: PUSH
104536: LD_INT 34
104538: PUSH
104539: LD_INT 35
104541: PUSH
104542: LD_INT 36
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: LIST
104549: LIST
104550: LIST
104551: LIST
104552: LIST
104553: LIST
104554: LIST
104555: LIST
104556: LIST
104557: LIST
104558: LIST
104559: LIST
104560: LIST
104561: LIST
104562: LIST
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: PUSH
104568: LD_INT 101
104570: PUSH
104571: LD_INT 102
104573: PUSH
104574: LD_INT 103
104576: PUSH
104577: LD_INT 106
104579: PUSH
104580: LD_INT 108
104582: PUSH
104583: LD_INT 112
104585: PUSH
104586: LD_INT 113
104588: PUSH
104589: LD_INT 114
104591: PUSH
104592: LD_INT 115
104594: PUSH
104595: EMPTY
104596: LIST
104597: LIST
104598: LIST
104599: LIST
104600: LIST
104601: LIST
104602: LIST
104603: LIST
104604: LIST
104605: PUSH
104606: EMPTY
104607: LIST
104608: LIST
104609: ST_TO_ADDR
104610: GO 104841
104612: LD_INT 19
104614: DOUBLE
104615: EQUAL
104616: IFTRUE 104620
104618: GO 104840
104620: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
104621: LD_ADDR_VAR 0 1
104625: PUSH
104626: LD_INT 1
104628: PUSH
104629: LD_INT 2
104631: PUSH
104632: LD_INT 3
104634: PUSH
104635: LD_INT 4
104637: PUSH
104638: LD_INT 5
104640: PUSH
104641: LD_INT 6
104643: PUSH
104644: LD_INT 7
104646: PUSH
104647: LD_INT 8
104649: PUSH
104650: LD_INT 9
104652: PUSH
104653: LD_INT 10
104655: PUSH
104656: LD_INT 11
104658: PUSH
104659: LD_INT 12
104661: PUSH
104662: LD_INT 13
104664: PUSH
104665: LD_INT 14
104667: PUSH
104668: LD_INT 15
104670: PUSH
104671: LD_INT 16
104673: PUSH
104674: LD_INT 17
104676: PUSH
104677: LD_INT 18
104679: PUSH
104680: LD_INT 19
104682: PUSH
104683: LD_INT 20
104685: PUSH
104686: LD_INT 21
104688: PUSH
104689: LD_INT 22
104691: PUSH
104692: LD_INT 23
104694: PUSH
104695: LD_INT 24
104697: PUSH
104698: LD_INT 25
104700: PUSH
104701: LD_INT 26
104703: PUSH
104704: LD_INT 27
104706: PUSH
104707: LD_INT 28
104709: PUSH
104710: LD_INT 29
104712: PUSH
104713: LD_INT 30
104715: PUSH
104716: LD_INT 31
104718: PUSH
104719: LD_INT 32
104721: PUSH
104722: LD_INT 33
104724: PUSH
104725: LD_INT 34
104727: PUSH
104728: LD_INT 35
104730: PUSH
104731: LD_INT 36
104733: PUSH
104734: EMPTY
104735: LIST
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: LIST
104741: LIST
104742: LIST
104743: LIST
104744: LIST
104745: LIST
104746: LIST
104747: LIST
104748: LIST
104749: LIST
104750: LIST
104751: LIST
104752: LIST
104753: LIST
104754: LIST
104755: LIST
104756: LIST
104757: LIST
104758: LIST
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: PUSH
104772: LD_INT 101
104774: PUSH
104775: LD_INT 102
104777: PUSH
104778: LD_INT 103
104780: PUSH
104781: LD_INT 104
104783: PUSH
104784: LD_INT 105
104786: PUSH
104787: LD_INT 106
104789: PUSH
104790: LD_INT 107
104792: PUSH
104793: LD_INT 108
104795: PUSH
104796: LD_INT 109
104798: PUSH
104799: LD_INT 110
104801: PUSH
104802: LD_INT 111
104804: PUSH
104805: LD_INT 112
104807: PUSH
104808: LD_INT 113
104810: PUSH
104811: LD_INT 114
104813: PUSH
104814: LD_INT 115
104816: PUSH
104817: EMPTY
104818: LIST
104819: LIST
104820: LIST
104821: LIST
104822: LIST
104823: LIST
104824: LIST
104825: LIST
104826: LIST
104827: LIST
104828: LIST
104829: LIST
104830: LIST
104831: LIST
104832: LIST
104833: PUSH
104834: EMPTY
104835: LIST
104836: LIST
104837: ST_TO_ADDR
104838: GO 104841
104840: POP
// end else
104841: GO 105060
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
104843: LD_ADDR_VAR 0 1
104847: PUSH
104848: LD_INT 1
104850: PUSH
104851: LD_INT 2
104853: PUSH
104854: LD_INT 3
104856: PUSH
104857: LD_INT 4
104859: PUSH
104860: LD_INT 5
104862: PUSH
104863: LD_INT 6
104865: PUSH
104866: LD_INT 7
104868: PUSH
104869: LD_INT 8
104871: PUSH
104872: LD_INT 9
104874: PUSH
104875: LD_INT 10
104877: PUSH
104878: LD_INT 11
104880: PUSH
104881: LD_INT 12
104883: PUSH
104884: LD_INT 13
104886: PUSH
104887: LD_INT 14
104889: PUSH
104890: LD_INT 15
104892: PUSH
104893: LD_INT 16
104895: PUSH
104896: LD_INT 17
104898: PUSH
104899: LD_INT 18
104901: PUSH
104902: LD_INT 19
104904: PUSH
104905: LD_INT 20
104907: PUSH
104908: LD_INT 21
104910: PUSH
104911: LD_INT 22
104913: PUSH
104914: LD_INT 23
104916: PUSH
104917: LD_INT 24
104919: PUSH
104920: LD_INT 25
104922: PUSH
104923: LD_INT 26
104925: PUSH
104926: LD_INT 27
104928: PUSH
104929: LD_INT 28
104931: PUSH
104932: LD_INT 29
104934: PUSH
104935: LD_INT 30
104937: PUSH
104938: LD_INT 31
104940: PUSH
104941: LD_INT 32
104943: PUSH
104944: LD_INT 33
104946: PUSH
104947: LD_INT 34
104949: PUSH
104950: LD_INT 35
104952: PUSH
104953: LD_INT 36
104955: PUSH
104956: EMPTY
104957: LIST
104958: LIST
104959: LIST
104960: LIST
104961: LIST
104962: LIST
104963: LIST
104964: LIST
104965: LIST
104966: LIST
104967: LIST
104968: LIST
104969: LIST
104970: LIST
104971: LIST
104972: LIST
104973: LIST
104974: LIST
104975: LIST
104976: LIST
104977: LIST
104978: LIST
104979: LIST
104980: LIST
104981: LIST
104982: LIST
104983: LIST
104984: LIST
104985: LIST
104986: LIST
104987: LIST
104988: LIST
104989: LIST
104990: LIST
104991: LIST
104992: LIST
104993: PUSH
104994: LD_INT 101
104996: PUSH
104997: LD_INT 102
104999: PUSH
105000: LD_INT 103
105002: PUSH
105003: LD_INT 104
105005: PUSH
105006: LD_INT 105
105008: PUSH
105009: LD_INT 106
105011: PUSH
105012: LD_INT 107
105014: PUSH
105015: LD_INT 108
105017: PUSH
105018: LD_INT 109
105020: PUSH
105021: LD_INT 110
105023: PUSH
105024: LD_INT 111
105026: PUSH
105027: LD_INT 112
105029: PUSH
105030: LD_INT 113
105032: PUSH
105033: LD_INT 114
105035: PUSH
105036: LD_INT 115
105038: PUSH
105039: EMPTY
105040: LIST
105041: LIST
105042: LIST
105043: LIST
105044: LIST
105045: LIST
105046: LIST
105047: LIST
105048: LIST
105049: LIST
105050: LIST
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: PUSH
105056: EMPTY
105057: LIST
105058: LIST
105059: ST_TO_ADDR
// if result then
105060: LD_VAR 0 1
105064: IFFALSE 105353
// begin normal :=  ;
105066: LD_ADDR_VAR 0 3
105070: PUSH
105071: LD_STRING 
105073: ST_TO_ADDR
// hardcore :=  ;
105074: LD_ADDR_VAR 0 4
105078: PUSH
105079: LD_STRING 
105081: ST_TO_ADDR
// for i = 1 to normalCounter do
105082: LD_ADDR_VAR 0 5
105086: PUSH
105087: DOUBLE
105088: LD_INT 1
105090: DEC
105091: ST_TO_ADDR
105092: LD_EXP 154
105096: PUSH
105097: FOR_TO
105098: IFFALSE 105199
// begin tmp := 0 ;
105100: LD_ADDR_VAR 0 2
105104: PUSH
105105: LD_STRING 0
105107: ST_TO_ADDR
// if result [ 1 ] then
105108: LD_VAR 0 1
105112: PUSH
105113: LD_INT 1
105115: ARRAY
105116: IFFALSE 105181
// if result [ 1 ] [ 1 ] = i then
105118: LD_VAR 0 1
105122: PUSH
105123: LD_INT 1
105125: ARRAY
105126: PUSH
105127: LD_INT 1
105129: ARRAY
105130: PUSH
105131: LD_VAR 0 5
105135: EQUAL
105136: IFFALSE 105181
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
105138: LD_ADDR_VAR 0 1
105142: PUSH
105143: LD_VAR 0 1
105147: PPUSH
105148: LD_INT 1
105150: PPUSH
105151: LD_VAR 0 1
105155: PUSH
105156: LD_INT 1
105158: ARRAY
105159: PPUSH
105160: LD_INT 1
105162: PPUSH
105163: CALL_OW 3
105167: PPUSH
105168: CALL_OW 1
105172: ST_TO_ADDR
// tmp := 1 ;
105173: LD_ADDR_VAR 0 2
105177: PUSH
105178: LD_STRING 1
105180: ST_TO_ADDR
// end ; normal := normal & tmp ;
105181: LD_ADDR_VAR 0 3
105185: PUSH
105186: LD_VAR 0 3
105190: PUSH
105191: LD_VAR 0 2
105195: STR
105196: ST_TO_ADDR
// end ;
105197: GO 105097
105199: POP
105200: POP
// for i = 1 to hardcoreCounter do
105201: LD_ADDR_VAR 0 5
105205: PUSH
105206: DOUBLE
105207: LD_INT 1
105209: DEC
105210: ST_TO_ADDR
105211: LD_EXP 155
105215: PUSH
105216: FOR_TO
105217: IFFALSE 105322
// begin tmp := 0 ;
105219: LD_ADDR_VAR 0 2
105223: PUSH
105224: LD_STRING 0
105226: ST_TO_ADDR
// if result [ 2 ] then
105227: LD_VAR 0 1
105231: PUSH
105232: LD_INT 2
105234: ARRAY
105235: IFFALSE 105304
// if result [ 2 ] [ 1 ] = 100 + i then
105237: LD_VAR 0 1
105241: PUSH
105242: LD_INT 2
105244: ARRAY
105245: PUSH
105246: LD_INT 1
105248: ARRAY
105249: PUSH
105250: LD_INT 100
105252: PUSH
105253: LD_VAR 0 5
105257: PLUS
105258: EQUAL
105259: IFFALSE 105304
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
105261: LD_ADDR_VAR 0 1
105265: PUSH
105266: LD_VAR 0 1
105270: PPUSH
105271: LD_INT 2
105273: PPUSH
105274: LD_VAR 0 1
105278: PUSH
105279: LD_INT 2
105281: ARRAY
105282: PPUSH
105283: LD_INT 1
105285: PPUSH
105286: CALL_OW 3
105290: PPUSH
105291: CALL_OW 1
105295: ST_TO_ADDR
// tmp := 1 ;
105296: LD_ADDR_VAR 0 2
105300: PUSH
105301: LD_STRING 1
105303: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105304: LD_ADDR_VAR 0 4
105308: PUSH
105309: LD_VAR 0 4
105313: PUSH
105314: LD_VAR 0 2
105318: STR
105319: ST_TO_ADDR
// end ;
105320: GO 105216
105322: POP
105323: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
105324: LD_STRING getStreamItemsFromMission("
105326: PUSH
105327: LD_VAR 0 3
105331: STR
105332: PUSH
105333: LD_STRING ","
105335: STR
105336: PUSH
105337: LD_VAR 0 4
105341: STR
105342: PUSH
105343: LD_STRING ")
105345: STR
105346: PPUSH
105347: CALL_OW 559
// end else
105351: GO 105360
// ToLua ( getStreamItemsFromMission("","") ) ;
105353: LD_STRING getStreamItemsFromMission("","")
105355: PPUSH
105356: CALL_OW 559
// end ;
105360: LD_VAR 0 1
105364: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
105365: LD_VAR 0 2
105369: PUSH
105370: LD_INT 100
105372: EQUAL
105373: IFFALSE 106322
// begin if not StreamModeActive then
105375: LD_EXP 153
105379: NOT
105380: IFFALSE 105390
// StreamModeActive := true ;
105382: LD_ADDR_EXP 153
105386: PUSH
105387: LD_INT 1
105389: ST_TO_ADDR
// if p3 = 0 then
105390: LD_VAR 0 3
105394: PUSH
105395: LD_INT 0
105397: EQUAL
105398: IFFALSE 105404
// InitStreamMode ;
105400: CALL 101443 0 0
// if p3 = 1 then
105404: LD_VAR 0 3
105408: PUSH
105409: LD_INT 1
105411: EQUAL
105412: IFFALSE 105422
// sRocket := true ;
105414: LD_ADDR_EXP 158
105418: PUSH
105419: LD_INT 1
105421: ST_TO_ADDR
// if p3 = 2 then
105422: LD_VAR 0 3
105426: PUSH
105427: LD_INT 2
105429: EQUAL
105430: IFFALSE 105440
// sSpeed := true ;
105432: LD_ADDR_EXP 157
105436: PUSH
105437: LD_INT 1
105439: ST_TO_ADDR
// if p3 = 3 then
105440: LD_VAR 0 3
105444: PUSH
105445: LD_INT 3
105447: EQUAL
105448: IFFALSE 105458
// sEngine := true ;
105450: LD_ADDR_EXP 159
105454: PUSH
105455: LD_INT 1
105457: ST_TO_ADDR
// if p3 = 4 then
105458: LD_VAR 0 3
105462: PUSH
105463: LD_INT 4
105465: EQUAL
105466: IFFALSE 105476
// sSpec := true ;
105468: LD_ADDR_EXP 156
105472: PUSH
105473: LD_INT 1
105475: ST_TO_ADDR
// if p3 = 5 then
105476: LD_VAR 0 3
105480: PUSH
105481: LD_INT 5
105483: EQUAL
105484: IFFALSE 105494
// sLevel := true ;
105486: LD_ADDR_EXP 160
105490: PUSH
105491: LD_INT 1
105493: ST_TO_ADDR
// if p3 = 6 then
105494: LD_VAR 0 3
105498: PUSH
105499: LD_INT 6
105501: EQUAL
105502: IFFALSE 105512
// sArmoury := true ;
105504: LD_ADDR_EXP 161
105508: PUSH
105509: LD_INT 1
105511: ST_TO_ADDR
// if p3 = 7 then
105512: LD_VAR 0 3
105516: PUSH
105517: LD_INT 7
105519: EQUAL
105520: IFFALSE 105530
// sRadar := true ;
105522: LD_ADDR_EXP 162
105526: PUSH
105527: LD_INT 1
105529: ST_TO_ADDR
// if p3 = 8 then
105530: LD_VAR 0 3
105534: PUSH
105535: LD_INT 8
105537: EQUAL
105538: IFFALSE 105548
// sBunker := true ;
105540: LD_ADDR_EXP 163
105544: PUSH
105545: LD_INT 1
105547: ST_TO_ADDR
// if p3 = 9 then
105548: LD_VAR 0 3
105552: PUSH
105553: LD_INT 9
105555: EQUAL
105556: IFFALSE 105566
// sHack := true ;
105558: LD_ADDR_EXP 164
105562: PUSH
105563: LD_INT 1
105565: ST_TO_ADDR
// if p3 = 10 then
105566: LD_VAR 0 3
105570: PUSH
105571: LD_INT 10
105573: EQUAL
105574: IFFALSE 105584
// sFire := true ;
105576: LD_ADDR_EXP 165
105580: PUSH
105581: LD_INT 1
105583: ST_TO_ADDR
// if p3 = 11 then
105584: LD_VAR 0 3
105588: PUSH
105589: LD_INT 11
105591: EQUAL
105592: IFFALSE 105602
// sRefresh := true ;
105594: LD_ADDR_EXP 166
105598: PUSH
105599: LD_INT 1
105601: ST_TO_ADDR
// if p3 = 12 then
105602: LD_VAR 0 3
105606: PUSH
105607: LD_INT 12
105609: EQUAL
105610: IFFALSE 105620
// sExp := true ;
105612: LD_ADDR_EXP 167
105616: PUSH
105617: LD_INT 1
105619: ST_TO_ADDR
// if p3 = 13 then
105620: LD_VAR 0 3
105624: PUSH
105625: LD_INT 13
105627: EQUAL
105628: IFFALSE 105638
// sDepot := true ;
105630: LD_ADDR_EXP 168
105634: PUSH
105635: LD_INT 1
105637: ST_TO_ADDR
// if p3 = 14 then
105638: LD_VAR 0 3
105642: PUSH
105643: LD_INT 14
105645: EQUAL
105646: IFFALSE 105656
// sFlag := true ;
105648: LD_ADDR_EXP 169
105652: PUSH
105653: LD_INT 1
105655: ST_TO_ADDR
// if p3 = 15 then
105656: LD_VAR 0 3
105660: PUSH
105661: LD_INT 15
105663: EQUAL
105664: IFFALSE 105674
// sKamikadze := true ;
105666: LD_ADDR_EXP 177
105670: PUSH
105671: LD_INT 1
105673: ST_TO_ADDR
// if p3 = 16 then
105674: LD_VAR 0 3
105678: PUSH
105679: LD_INT 16
105681: EQUAL
105682: IFFALSE 105692
// sTroll := true ;
105684: LD_ADDR_EXP 178
105688: PUSH
105689: LD_INT 1
105691: ST_TO_ADDR
// if p3 = 17 then
105692: LD_VAR 0 3
105696: PUSH
105697: LD_INT 17
105699: EQUAL
105700: IFFALSE 105710
// sSlow := true ;
105702: LD_ADDR_EXP 179
105706: PUSH
105707: LD_INT 1
105709: ST_TO_ADDR
// if p3 = 18 then
105710: LD_VAR 0 3
105714: PUSH
105715: LD_INT 18
105717: EQUAL
105718: IFFALSE 105728
// sLack := true ;
105720: LD_ADDR_EXP 180
105724: PUSH
105725: LD_INT 1
105727: ST_TO_ADDR
// if p3 = 19 then
105728: LD_VAR 0 3
105732: PUSH
105733: LD_INT 19
105735: EQUAL
105736: IFFALSE 105746
// sTank := true ;
105738: LD_ADDR_EXP 182
105742: PUSH
105743: LD_INT 1
105745: ST_TO_ADDR
// if p3 = 20 then
105746: LD_VAR 0 3
105750: PUSH
105751: LD_INT 20
105753: EQUAL
105754: IFFALSE 105764
// sRemote := true ;
105756: LD_ADDR_EXP 183
105760: PUSH
105761: LD_INT 1
105763: ST_TO_ADDR
// if p3 = 21 then
105764: LD_VAR 0 3
105768: PUSH
105769: LD_INT 21
105771: EQUAL
105772: IFFALSE 105782
// sPowell := true ;
105774: LD_ADDR_EXP 184
105778: PUSH
105779: LD_INT 1
105781: ST_TO_ADDR
// if p3 = 22 then
105782: LD_VAR 0 3
105786: PUSH
105787: LD_INT 22
105789: EQUAL
105790: IFFALSE 105800
// sTeleport := true ;
105792: LD_ADDR_EXP 187
105796: PUSH
105797: LD_INT 1
105799: ST_TO_ADDR
// if p3 = 23 then
105800: LD_VAR 0 3
105804: PUSH
105805: LD_INT 23
105807: EQUAL
105808: IFFALSE 105818
// sOilTower := true ;
105810: LD_ADDR_EXP 189
105814: PUSH
105815: LD_INT 1
105817: ST_TO_ADDR
// if p3 = 24 then
105818: LD_VAR 0 3
105822: PUSH
105823: LD_INT 24
105825: EQUAL
105826: IFFALSE 105836
// sShovel := true ;
105828: LD_ADDR_EXP 190
105832: PUSH
105833: LD_INT 1
105835: ST_TO_ADDR
// if p3 = 25 then
105836: LD_VAR 0 3
105840: PUSH
105841: LD_INT 25
105843: EQUAL
105844: IFFALSE 105854
// sSheik := true ;
105846: LD_ADDR_EXP 191
105850: PUSH
105851: LD_INT 1
105853: ST_TO_ADDR
// if p3 = 26 then
105854: LD_VAR 0 3
105858: PUSH
105859: LD_INT 26
105861: EQUAL
105862: IFFALSE 105872
// sEarthquake := true ;
105864: LD_ADDR_EXP 193
105868: PUSH
105869: LD_INT 1
105871: ST_TO_ADDR
// if p3 = 27 then
105872: LD_VAR 0 3
105876: PUSH
105877: LD_INT 27
105879: EQUAL
105880: IFFALSE 105890
// sAI := true ;
105882: LD_ADDR_EXP 194
105886: PUSH
105887: LD_INT 1
105889: ST_TO_ADDR
// if p3 = 28 then
105890: LD_VAR 0 3
105894: PUSH
105895: LD_INT 28
105897: EQUAL
105898: IFFALSE 105908
// sCargo := true ;
105900: LD_ADDR_EXP 197
105904: PUSH
105905: LD_INT 1
105907: ST_TO_ADDR
// if p3 = 29 then
105908: LD_VAR 0 3
105912: PUSH
105913: LD_INT 29
105915: EQUAL
105916: IFFALSE 105926
// sDLaser := true ;
105918: LD_ADDR_EXP 198
105922: PUSH
105923: LD_INT 1
105925: ST_TO_ADDR
// if p3 = 30 then
105926: LD_VAR 0 3
105930: PUSH
105931: LD_INT 30
105933: EQUAL
105934: IFFALSE 105944
// sExchange := true ;
105936: LD_ADDR_EXP 199
105940: PUSH
105941: LD_INT 1
105943: ST_TO_ADDR
// if p3 = 31 then
105944: LD_VAR 0 3
105948: PUSH
105949: LD_INT 31
105951: EQUAL
105952: IFFALSE 105962
// sFac := true ;
105954: LD_ADDR_EXP 200
105958: PUSH
105959: LD_INT 1
105961: ST_TO_ADDR
// if p3 = 32 then
105962: LD_VAR 0 3
105966: PUSH
105967: LD_INT 32
105969: EQUAL
105970: IFFALSE 105980
// sPower := true ;
105972: LD_ADDR_EXP 201
105976: PUSH
105977: LD_INT 1
105979: ST_TO_ADDR
// if p3 = 33 then
105980: LD_VAR 0 3
105984: PUSH
105985: LD_INT 33
105987: EQUAL
105988: IFFALSE 105998
// sRandom := true ;
105990: LD_ADDR_EXP 202
105994: PUSH
105995: LD_INT 1
105997: ST_TO_ADDR
// if p3 = 34 then
105998: LD_VAR 0 3
106002: PUSH
106003: LD_INT 34
106005: EQUAL
106006: IFFALSE 106016
// sShield := true ;
106008: LD_ADDR_EXP 203
106012: PUSH
106013: LD_INT 1
106015: ST_TO_ADDR
// if p3 = 35 then
106016: LD_VAR 0 3
106020: PUSH
106021: LD_INT 35
106023: EQUAL
106024: IFFALSE 106034
// sTime := true ;
106026: LD_ADDR_EXP 204
106030: PUSH
106031: LD_INT 1
106033: ST_TO_ADDR
// if p3 = 36 then
106034: LD_VAR 0 3
106038: PUSH
106039: LD_INT 36
106041: EQUAL
106042: IFFALSE 106052
// sTools := true ;
106044: LD_ADDR_EXP 205
106048: PUSH
106049: LD_INT 1
106051: ST_TO_ADDR
// if p3 = 101 then
106052: LD_VAR 0 3
106056: PUSH
106057: LD_INT 101
106059: EQUAL
106060: IFFALSE 106070
// sSold := true ;
106062: LD_ADDR_EXP 170
106066: PUSH
106067: LD_INT 1
106069: ST_TO_ADDR
// if p3 = 102 then
106070: LD_VAR 0 3
106074: PUSH
106075: LD_INT 102
106077: EQUAL
106078: IFFALSE 106088
// sDiff := true ;
106080: LD_ADDR_EXP 171
106084: PUSH
106085: LD_INT 1
106087: ST_TO_ADDR
// if p3 = 103 then
106088: LD_VAR 0 3
106092: PUSH
106093: LD_INT 103
106095: EQUAL
106096: IFFALSE 106106
// sFog := true ;
106098: LD_ADDR_EXP 174
106102: PUSH
106103: LD_INT 1
106105: ST_TO_ADDR
// if p3 = 104 then
106106: LD_VAR 0 3
106110: PUSH
106111: LD_INT 104
106113: EQUAL
106114: IFFALSE 106124
// sReset := true ;
106116: LD_ADDR_EXP 175
106120: PUSH
106121: LD_INT 1
106123: ST_TO_ADDR
// if p3 = 105 then
106124: LD_VAR 0 3
106128: PUSH
106129: LD_INT 105
106131: EQUAL
106132: IFFALSE 106142
// sSun := true ;
106134: LD_ADDR_EXP 176
106138: PUSH
106139: LD_INT 1
106141: ST_TO_ADDR
// if p3 = 106 then
106142: LD_VAR 0 3
106146: PUSH
106147: LD_INT 106
106149: EQUAL
106150: IFFALSE 106160
// sTiger := true ;
106152: LD_ADDR_EXP 172
106156: PUSH
106157: LD_INT 1
106159: ST_TO_ADDR
// if p3 = 107 then
106160: LD_VAR 0 3
106164: PUSH
106165: LD_INT 107
106167: EQUAL
106168: IFFALSE 106178
// sBomb := true ;
106170: LD_ADDR_EXP 173
106174: PUSH
106175: LD_INT 1
106177: ST_TO_ADDR
// if p3 = 108 then
106178: LD_VAR 0 3
106182: PUSH
106183: LD_INT 108
106185: EQUAL
106186: IFFALSE 106196
// sWound := true ;
106188: LD_ADDR_EXP 181
106192: PUSH
106193: LD_INT 1
106195: ST_TO_ADDR
// if p3 = 109 then
106196: LD_VAR 0 3
106200: PUSH
106201: LD_INT 109
106203: EQUAL
106204: IFFALSE 106214
// sBetray := true ;
106206: LD_ADDR_EXP 185
106210: PUSH
106211: LD_INT 1
106213: ST_TO_ADDR
// if p3 = 110 then
106214: LD_VAR 0 3
106218: PUSH
106219: LD_INT 110
106221: EQUAL
106222: IFFALSE 106232
// sContamin := true ;
106224: LD_ADDR_EXP 186
106228: PUSH
106229: LD_INT 1
106231: ST_TO_ADDR
// if p3 = 111 then
106232: LD_VAR 0 3
106236: PUSH
106237: LD_INT 111
106239: EQUAL
106240: IFFALSE 106250
// sOil := true ;
106242: LD_ADDR_EXP 188
106246: PUSH
106247: LD_INT 1
106249: ST_TO_ADDR
// if p3 = 112 then
106250: LD_VAR 0 3
106254: PUSH
106255: LD_INT 112
106257: EQUAL
106258: IFFALSE 106268
// sStu := true ;
106260: LD_ADDR_EXP 192
106264: PUSH
106265: LD_INT 1
106267: ST_TO_ADDR
// if p3 = 113 then
106268: LD_VAR 0 3
106272: PUSH
106273: LD_INT 113
106275: EQUAL
106276: IFFALSE 106286
// sBazooka := true ;
106278: LD_ADDR_EXP 195
106282: PUSH
106283: LD_INT 1
106285: ST_TO_ADDR
// if p3 = 114 then
106286: LD_VAR 0 3
106290: PUSH
106291: LD_INT 114
106293: EQUAL
106294: IFFALSE 106304
// sMortar := true ;
106296: LD_ADDR_EXP 196
106300: PUSH
106301: LD_INT 1
106303: ST_TO_ADDR
// if p3 = 115 then
106304: LD_VAR 0 3
106308: PUSH
106309: LD_INT 115
106311: EQUAL
106312: IFFALSE 106322
// sRanger := true ;
106314: LD_ADDR_EXP 206
106318: PUSH
106319: LD_INT 1
106321: ST_TO_ADDR
// end ; end ;
106322: PPOPN 6
106324: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106325: LD_EXP 153
106329: PUSH
106330: LD_EXP 158
106334: AND
106335: IFFALSE 106459
106337: GO 106339
106339: DISABLE
106340: LD_INT 0
106342: PPUSH
106343: PPUSH
// begin enable ;
106344: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106345: LD_ADDR_VAR 0 2
106349: PUSH
106350: LD_INT 22
106352: PUSH
106353: LD_OWVAR 2
106357: PUSH
106358: EMPTY
106359: LIST
106360: LIST
106361: PUSH
106362: LD_INT 2
106364: PUSH
106365: LD_INT 34
106367: PUSH
106368: LD_INT 7
106370: PUSH
106371: EMPTY
106372: LIST
106373: LIST
106374: PUSH
106375: LD_INT 34
106377: PUSH
106378: LD_INT 45
106380: PUSH
106381: EMPTY
106382: LIST
106383: LIST
106384: PUSH
106385: LD_INT 34
106387: PUSH
106388: LD_INT 28
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: PUSH
106395: LD_INT 34
106397: PUSH
106398: LD_INT 47
106400: PUSH
106401: EMPTY
106402: LIST
106403: LIST
106404: PUSH
106405: EMPTY
106406: LIST
106407: LIST
106408: LIST
106409: LIST
106410: LIST
106411: PUSH
106412: EMPTY
106413: LIST
106414: LIST
106415: PPUSH
106416: CALL_OW 69
106420: ST_TO_ADDR
// if not tmp then
106421: LD_VAR 0 2
106425: NOT
106426: IFFALSE 106430
// exit ;
106428: GO 106459
// for i in tmp do
106430: LD_ADDR_VAR 0 1
106434: PUSH
106435: LD_VAR 0 2
106439: PUSH
106440: FOR_IN
106441: IFFALSE 106457
// begin SetLives ( i , 0 ) ;
106443: LD_VAR 0 1
106447: PPUSH
106448: LD_INT 0
106450: PPUSH
106451: CALL_OW 234
// end ;
106455: GO 106440
106457: POP
106458: POP
// end ;
106459: PPOPN 2
106461: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106462: LD_EXP 153
106466: PUSH
106467: LD_EXP 159
106471: AND
106472: IFFALSE 106556
106474: GO 106476
106476: DISABLE
106477: LD_INT 0
106479: PPUSH
106480: PPUSH
// begin enable ;
106481: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106482: LD_ADDR_VAR 0 2
106486: PUSH
106487: LD_INT 22
106489: PUSH
106490: LD_OWVAR 2
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: PUSH
106499: LD_INT 32
106501: PUSH
106502: LD_INT 3
106504: PUSH
106505: EMPTY
106506: LIST
106507: LIST
106508: PUSH
106509: EMPTY
106510: LIST
106511: LIST
106512: PPUSH
106513: CALL_OW 69
106517: ST_TO_ADDR
// if not tmp then
106518: LD_VAR 0 2
106522: NOT
106523: IFFALSE 106527
// exit ;
106525: GO 106556
// for i in tmp do
106527: LD_ADDR_VAR 0 1
106531: PUSH
106532: LD_VAR 0 2
106536: PUSH
106537: FOR_IN
106538: IFFALSE 106554
// begin SetLives ( i , 0 ) ;
106540: LD_VAR 0 1
106544: PPUSH
106545: LD_INT 0
106547: PPUSH
106548: CALL_OW 234
// end ;
106552: GO 106537
106554: POP
106555: POP
// end ;
106556: PPOPN 2
106558: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106559: LD_EXP 153
106563: PUSH
106564: LD_EXP 156
106568: AND
106569: IFFALSE 106662
106571: GO 106573
106573: DISABLE
106574: LD_INT 0
106576: PPUSH
// begin enable ;
106577: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106578: LD_ADDR_VAR 0 1
106582: PUSH
106583: LD_INT 22
106585: PUSH
106586: LD_OWVAR 2
106590: PUSH
106591: EMPTY
106592: LIST
106593: LIST
106594: PUSH
106595: LD_INT 2
106597: PUSH
106598: LD_INT 25
106600: PUSH
106601: LD_INT 5
106603: PUSH
106604: EMPTY
106605: LIST
106606: LIST
106607: PUSH
106608: LD_INT 25
106610: PUSH
106611: LD_INT 9
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PUSH
106618: LD_INT 25
106620: PUSH
106621: LD_INT 8
106623: PUSH
106624: EMPTY
106625: LIST
106626: LIST
106627: PUSH
106628: EMPTY
106629: LIST
106630: LIST
106631: LIST
106632: LIST
106633: PUSH
106634: EMPTY
106635: LIST
106636: LIST
106637: PPUSH
106638: CALL_OW 69
106642: PUSH
106643: FOR_IN
106644: IFFALSE 106660
// begin SetClass ( i , 1 ) ;
106646: LD_VAR 0 1
106650: PPUSH
106651: LD_INT 1
106653: PPUSH
106654: CALL_OW 336
// end ;
106658: GO 106643
106660: POP
106661: POP
// end ;
106662: PPOPN 1
106664: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106665: LD_EXP 153
106669: PUSH
106670: LD_EXP 157
106674: AND
106675: PUSH
106676: LD_OWVAR 65
106680: PUSH
106681: LD_INT 7
106683: LESS
106684: AND
106685: IFFALSE 106699
106687: GO 106689
106689: DISABLE
// begin enable ;
106690: ENABLE
// game_speed := 7 ;
106691: LD_ADDR_OWVAR 65
106695: PUSH
106696: LD_INT 7
106698: ST_TO_ADDR
// end ;
106699: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106700: LD_EXP 153
106704: PUSH
106705: LD_EXP 160
106709: AND
106710: IFFALSE 106912
106712: GO 106714
106714: DISABLE
106715: LD_INT 0
106717: PPUSH
106718: PPUSH
106719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106720: LD_ADDR_VAR 0 3
106724: PUSH
106725: LD_INT 81
106727: PUSH
106728: LD_OWVAR 2
106732: PUSH
106733: EMPTY
106734: LIST
106735: LIST
106736: PUSH
106737: LD_INT 21
106739: PUSH
106740: LD_INT 1
106742: PUSH
106743: EMPTY
106744: LIST
106745: LIST
106746: PUSH
106747: EMPTY
106748: LIST
106749: LIST
106750: PPUSH
106751: CALL_OW 69
106755: ST_TO_ADDR
// if not tmp then
106756: LD_VAR 0 3
106760: NOT
106761: IFFALSE 106765
// exit ;
106763: GO 106912
// if tmp > 5 then
106765: LD_VAR 0 3
106769: PUSH
106770: LD_INT 5
106772: GREATER
106773: IFFALSE 106785
// k := 5 else
106775: LD_ADDR_VAR 0 2
106779: PUSH
106780: LD_INT 5
106782: ST_TO_ADDR
106783: GO 106795
// k := tmp ;
106785: LD_ADDR_VAR 0 2
106789: PUSH
106790: LD_VAR 0 3
106794: ST_TO_ADDR
// for i := 1 to k do
106795: LD_ADDR_VAR 0 1
106799: PUSH
106800: DOUBLE
106801: LD_INT 1
106803: DEC
106804: ST_TO_ADDR
106805: LD_VAR 0 2
106809: PUSH
106810: FOR_TO
106811: IFFALSE 106910
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106813: LD_VAR 0 3
106817: PUSH
106818: LD_VAR 0 1
106822: ARRAY
106823: PPUSH
106824: LD_VAR 0 1
106828: PUSH
106829: LD_INT 4
106831: MOD
106832: PUSH
106833: LD_INT 1
106835: PLUS
106836: PPUSH
106837: CALL_OW 259
106841: PUSH
106842: LD_INT 10
106844: LESS
106845: IFFALSE 106908
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106847: LD_VAR 0 3
106851: PUSH
106852: LD_VAR 0 1
106856: ARRAY
106857: PPUSH
106858: LD_VAR 0 1
106862: PUSH
106863: LD_INT 4
106865: MOD
106866: PUSH
106867: LD_INT 1
106869: PLUS
106870: PPUSH
106871: LD_VAR 0 3
106875: PUSH
106876: LD_VAR 0 1
106880: ARRAY
106881: PPUSH
106882: LD_VAR 0 1
106886: PUSH
106887: LD_INT 4
106889: MOD
106890: PUSH
106891: LD_INT 1
106893: PLUS
106894: PPUSH
106895: CALL_OW 259
106899: PUSH
106900: LD_INT 1
106902: PLUS
106903: PPUSH
106904: CALL_OW 237
106908: GO 106810
106910: POP
106911: POP
// end ;
106912: PPOPN 3
106914: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106915: LD_EXP 153
106919: PUSH
106920: LD_EXP 161
106924: AND
106925: IFFALSE 106945
106927: GO 106929
106929: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106930: LD_INT 4
106932: PPUSH
106933: LD_OWVAR 2
106937: PPUSH
106938: LD_INT 0
106940: PPUSH
106941: CALL_OW 324
106945: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106946: LD_EXP 153
106950: PUSH
106951: LD_EXP 190
106955: AND
106956: IFFALSE 106976
106958: GO 106960
106960: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106961: LD_INT 19
106963: PPUSH
106964: LD_OWVAR 2
106968: PPUSH
106969: LD_INT 0
106971: PPUSH
106972: CALL_OW 324
106976: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106977: LD_EXP 153
106981: PUSH
106982: LD_EXP 162
106986: AND
106987: IFFALSE 107089
106989: GO 106991
106991: DISABLE
106992: LD_INT 0
106994: PPUSH
106995: PPUSH
// begin enable ;
106996: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
106997: LD_ADDR_VAR 0 2
107001: PUSH
107002: LD_INT 22
107004: PUSH
107005: LD_OWVAR 2
107009: PUSH
107010: EMPTY
107011: LIST
107012: LIST
107013: PUSH
107014: LD_INT 2
107016: PUSH
107017: LD_INT 34
107019: PUSH
107020: LD_INT 11
107022: PUSH
107023: EMPTY
107024: LIST
107025: LIST
107026: PUSH
107027: LD_INT 34
107029: PUSH
107030: LD_INT 30
107032: PUSH
107033: EMPTY
107034: LIST
107035: LIST
107036: PUSH
107037: EMPTY
107038: LIST
107039: LIST
107040: LIST
107041: PUSH
107042: EMPTY
107043: LIST
107044: LIST
107045: PPUSH
107046: CALL_OW 69
107050: ST_TO_ADDR
// if not tmp then
107051: LD_VAR 0 2
107055: NOT
107056: IFFALSE 107060
// exit ;
107058: GO 107089
// for i in tmp do
107060: LD_ADDR_VAR 0 1
107064: PUSH
107065: LD_VAR 0 2
107069: PUSH
107070: FOR_IN
107071: IFFALSE 107087
// begin SetLives ( i , 0 ) ;
107073: LD_VAR 0 1
107077: PPUSH
107078: LD_INT 0
107080: PPUSH
107081: CALL_OW 234
// end ;
107085: GO 107070
107087: POP
107088: POP
// end ;
107089: PPOPN 2
107091: END
// every 0 0$1 trigger StreamModeActive and sBunker do
107092: LD_EXP 153
107096: PUSH
107097: LD_EXP 163
107101: AND
107102: IFFALSE 107122
107104: GO 107106
107106: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
107107: LD_INT 32
107109: PPUSH
107110: LD_OWVAR 2
107114: PPUSH
107115: LD_INT 0
107117: PPUSH
107118: CALL_OW 324
107122: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
107123: LD_EXP 153
107127: PUSH
107128: LD_EXP 164
107132: AND
107133: IFFALSE 107314
107135: GO 107137
107137: DISABLE
107138: LD_INT 0
107140: PPUSH
107141: PPUSH
107142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
107143: LD_ADDR_VAR 0 2
107147: PUSH
107148: LD_INT 22
107150: PUSH
107151: LD_OWVAR 2
107155: PUSH
107156: EMPTY
107157: LIST
107158: LIST
107159: PUSH
107160: LD_INT 33
107162: PUSH
107163: LD_INT 3
107165: PUSH
107166: EMPTY
107167: LIST
107168: LIST
107169: PUSH
107170: EMPTY
107171: LIST
107172: LIST
107173: PPUSH
107174: CALL_OW 69
107178: ST_TO_ADDR
// if not tmp then
107179: LD_VAR 0 2
107183: NOT
107184: IFFALSE 107188
// exit ;
107186: GO 107314
// side := 0 ;
107188: LD_ADDR_VAR 0 3
107192: PUSH
107193: LD_INT 0
107195: ST_TO_ADDR
// for i := 1 to 8 do
107196: LD_ADDR_VAR 0 1
107200: PUSH
107201: DOUBLE
107202: LD_INT 1
107204: DEC
107205: ST_TO_ADDR
107206: LD_INT 8
107208: PUSH
107209: FOR_TO
107210: IFFALSE 107258
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
107212: LD_OWVAR 2
107216: PUSH
107217: LD_VAR 0 1
107221: NONEQUAL
107222: PUSH
107223: LD_OWVAR 2
107227: PPUSH
107228: LD_VAR 0 1
107232: PPUSH
107233: CALL_OW 81
107237: PUSH
107238: LD_INT 2
107240: EQUAL
107241: AND
107242: IFFALSE 107256
// begin side := i ;
107244: LD_ADDR_VAR 0 3
107248: PUSH
107249: LD_VAR 0 1
107253: ST_TO_ADDR
// break ;
107254: GO 107258
// end ;
107256: GO 107209
107258: POP
107259: POP
// if not side then
107260: LD_VAR 0 3
107264: NOT
107265: IFFALSE 107269
// exit ;
107267: GO 107314
// for i := 1 to tmp do
107269: LD_ADDR_VAR 0 1
107273: PUSH
107274: DOUBLE
107275: LD_INT 1
107277: DEC
107278: ST_TO_ADDR
107279: LD_VAR 0 2
107283: PUSH
107284: FOR_TO
107285: IFFALSE 107312
// if Prob ( 60 ) then
107287: LD_INT 60
107289: PPUSH
107290: CALL_OW 13
107294: IFFALSE 107310
// SetSide ( i , side ) ;
107296: LD_VAR 0 1
107300: PPUSH
107301: LD_VAR 0 3
107305: PPUSH
107306: CALL_OW 235
107310: GO 107284
107312: POP
107313: POP
// end ;
107314: PPOPN 3
107316: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107317: LD_EXP 153
107321: PUSH
107322: LD_EXP 166
107326: AND
107327: IFFALSE 107446
107329: GO 107331
107331: DISABLE
107332: LD_INT 0
107334: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107335: LD_ADDR_VAR 0 1
107339: PUSH
107340: LD_INT 22
107342: PUSH
107343: LD_OWVAR 2
107347: PUSH
107348: EMPTY
107349: LIST
107350: LIST
107351: PUSH
107352: LD_INT 21
107354: PUSH
107355: LD_INT 1
107357: PUSH
107358: EMPTY
107359: LIST
107360: LIST
107361: PUSH
107362: LD_INT 3
107364: PUSH
107365: LD_INT 23
107367: PUSH
107368: LD_INT 0
107370: PUSH
107371: EMPTY
107372: LIST
107373: LIST
107374: PUSH
107375: EMPTY
107376: LIST
107377: LIST
107378: PUSH
107379: EMPTY
107380: LIST
107381: LIST
107382: LIST
107383: PPUSH
107384: CALL_OW 69
107388: PUSH
107389: FOR_IN
107390: IFFALSE 107444
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107392: LD_VAR 0 1
107396: PPUSH
107397: CALL_OW 257
107401: PUSH
107402: LD_INT 1
107404: PUSH
107405: LD_INT 2
107407: PUSH
107408: LD_INT 3
107410: PUSH
107411: LD_INT 4
107413: PUSH
107414: EMPTY
107415: LIST
107416: LIST
107417: LIST
107418: LIST
107419: IN
107420: IFFALSE 107442
// SetClass ( un , rand ( 1 , 4 ) ) ;
107422: LD_VAR 0 1
107426: PPUSH
107427: LD_INT 1
107429: PPUSH
107430: LD_INT 4
107432: PPUSH
107433: CALL_OW 12
107437: PPUSH
107438: CALL_OW 336
107442: GO 107389
107444: POP
107445: POP
// end ;
107446: PPOPN 1
107448: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107449: LD_EXP 153
107453: PUSH
107454: LD_EXP 165
107458: AND
107459: IFFALSE 107538
107461: GO 107463
107463: DISABLE
107464: LD_INT 0
107466: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107467: LD_ADDR_VAR 0 1
107471: PUSH
107472: LD_INT 22
107474: PUSH
107475: LD_OWVAR 2
107479: PUSH
107480: EMPTY
107481: LIST
107482: LIST
107483: PUSH
107484: LD_INT 21
107486: PUSH
107487: LD_INT 3
107489: PUSH
107490: EMPTY
107491: LIST
107492: LIST
107493: PUSH
107494: EMPTY
107495: LIST
107496: LIST
107497: PPUSH
107498: CALL_OW 69
107502: ST_TO_ADDR
// if not tmp then
107503: LD_VAR 0 1
107507: NOT
107508: IFFALSE 107512
// exit ;
107510: GO 107538
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107512: LD_VAR 0 1
107516: PUSH
107517: LD_INT 1
107519: PPUSH
107520: LD_VAR 0 1
107524: PPUSH
107525: CALL_OW 12
107529: ARRAY
107530: PPUSH
107531: LD_INT 100
107533: PPUSH
107534: CALL_OW 234
// end ;
107538: PPOPN 1
107540: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107541: LD_EXP 153
107545: PUSH
107546: LD_EXP 167
107550: AND
107551: IFFALSE 107649
107553: GO 107555
107555: DISABLE
107556: LD_INT 0
107558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107559: LD_ADDR_VAR 0 1
107563: PUSH
107564: LD_INT 22
107566: PUSH
107567: LD_OWVAR 2
107571: PUSH
107572: EMPTY
107573: LIST
107574: LIST
107575: PUSH
107576: LD_INT 21
107578: PUSH
107579: LD_INT 1
107581: PUSH
107582: EMPTY
107583: LIST
107584: LIST
107585: PUSH
107586: EMPTY
107587: LIST
107588: LIST
107589: PPUSH
107590: CALL_OW 69
107594: ST_TO_ADDR
// if not tmp then
107595: LD_VAR 0 1
107599: NOT
107600: IFFALSE 107604
// exit ;
107602: GO 107649
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107604: LD_VAR 0 1
107608: PUSH
107609: LD_INT 1
107611: PPUSH
107612: LD_VAR 0 1
107616: PPUSH
107617: CALL_OW 12
107621: ARRAY
107622: PPUSH
107623: LD_INT 1
107625: PPUSH
107626: LD_INT 4
107628: PPUSH
107629: CALL_OW 12
107633: PPUSH
107634: LD_INT 3000
107636: PPUSH
107637: LD_INT 9000
107639: PPUSH
107640: CALL_OW 12
107644: PPUSH
107645: CALL_OW 492
// end ;
107649: PPOPN 1
107651: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107652: LD_EXP 153
107656: PUSH
107657: LD_EXP 168
107661: AND
107662: IFFALSE 107682
107664: GO 107666
107666: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107667: LD_INT 1
107669: PPUSH
107670: LD_OWVAR 2
107674: PPUSH
107675: LD_INT 0
107677: PPUSH
107678: CALL_OW 324
107682: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107683: LD_EXP 153
107687: PUSH
107688: LD_EXP 169
107692: AND
107693: IFFALSE 107776
107695: GO 107697
107697: DISABLE
107698: LD_INT 0
107700: PPUSH
107701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107702: LD_ADDR_VAR 0 2
107706: PUSH
107707: LD_INT 22
107709: PUSH
107710: LD_OWVAR 2
107714: PUSH
107715: EMPTY
107716: LIST
107717: LIST
107718: PUSH
107719: LD_INT 21
107721: PUSH
107722: LD_INT 3
107724: PUSH
107725: EMPTY
107726: LIST
107727: LIST
107728: PUSH
107729: EMPTY
107730: LIST
107731: LIST
107732: PPUSH
107733: CALL_OW 69
107737: ST_TO_ADDR
// if not tmp then
107738: LD_VAR 0 2
107742: NOT
107743: IFFALSE 107747
// exit ;
107745: GO 107776
// for i in tmp do
107747: LD_ADDR_VAR 0 1
107751: PUSH
107752: LD_VAR 0 2
107756: PUSH
107757: FOR_IN
107758: IFFALSE 107774
// SetBLevel ( i , 10 ) ;
107760: LD_VAR 0 1
107764: PPUSH
107765: LD_INT 10
107767: PPUSH
107768: CALL_OW 241
107772: GO 107757
107774: POP
107775: POP
// end ;
107776: PPOPN 2
107778: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107779: LD_EXP 153
107783: PUSH
107784: LD_EXP 170
107788: AND
107789: IFFALSE 107900
107791: GO 107793
107793: DISABLE
107794: LD_INT 0
107796: PPUSH
107797: PPUSH
107798: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107799: LD_ADDR_VAR 0 3
107803: PUSH
107804: LD_INT 22
107806: PUSH
107807: LD_OWVAR 2
107811: PUSH
107812: EMPTY
107813: LIST
107814: LIST
107815: PUSH
107816: LD_INT 25
107818: PUSH
107819: LD_INT 1
107821: PUSH
107822: EMPTY
107823: LIST
107824: LIST
107825: PUSH
107826: EMPTY
107827: LIST
107828: LIST
107829: PPUSH
107830: CALL_OW 69
107834: ST_TO_ADDR
// if not tmp then
107835: LD_VAR 0 3
107839: NOT
107840: IFFALSE 107844
// exit ;
107842: GO 107900
// un := tmp [ rand ( 1 , tmp ) ] ;
107844: LD_ADDR_VAR 0 2
107848: PUSH
107849: LD_VAR 0 3
107853: PUSH
107854: LD_INT 1
107856: PPUSH
107857: LD_VAR 0 3
107861: PPUSH
107862: CALL_OW 12
107866: ARRAY
107867: ST_TO_ADDR
// if Crawls ( un ) then
107868: LD_VAR 0 2
107872: PPUSH
107873: CALL_OW 318
107877: IFFALSE 107888
// ComWalk ( un ) ;
107879: LD_VAR 0 2
107883: PPUSH
107884: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107888: LD_VAR 0 2
107892: PPUSH
107893: LD_INT 5
107895: PPUSH
107896: CALL_OW 336
// end ;
107900: PPOPN 3
107902: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
107903: LD_EXP 153
107907: PUSH
107908: LD_EXP 171
107912: AND
107913: PUSH
107914: LD_OWVAR 67
107918: PUSH
107919: LD_INT 3
107921: LESS
107922: AND
107923: IFFALSE 107942
107925: GO 107927
107927: DISABLE
// Difficulty := Difficulty + 1 ;
107928: LD_ADDR_OWVAR 67
107932: PUSH
107933: LD_OWVAR 67
107937: PUSH
107938: LD_INT 1
107940: PLUS
107941: ST_TO_ADDR
107942: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107943: LD_EXP 153
107947: PUSH
107948: LD_EXP 172
107952: AND
107953: IFFALSE 108056
107955: GO 107957
107957: DISABLE
107958: LD_INT 0
107960: PPUSH
// begin for i := 1 to 5 do
107961: LD_ADDR_VAR 0 1
107965: PUSH
107966: DOUBLE
107967: LD_INT 1
107969: DEC
107970: ST_TO_ADDR
107971: LD_INT 5
107973: PUSH
107974: FOR_TO
107975: IFFALSE 108054
// begin uc_nation := nation_nature ;
107977: LD_ADDR_OWVAR 21
107981: PUSH
107982: LD_INT 0
107984: ST_TO_ADDR
// uc_side := 0 ;
107985: LD_ADDR_OWVAR 20
107989: PUSH
107990: LD_INT 0
107992: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107993: LD_ADDR_OWVAR 29
107997: PUSH
107998: LD_INT 12
108000: PUSH
108001: LD_INT 12
108003: PUSH
108004: EMPTY
108005: LIST
108006: LIST
108007: ST_TO_ADDR
// hc_agressivity := 20 ;
108008: LD_ADDR_OWVAR 35
108012: PUSH
108013: LD_INT 20
108015: ST_TO_ADDR
// hc_class := class_tiger ;
108016: LD_ADDR_OWVAR 28
108020: PUSH
108021: LD_INT 14
108023: ST_TO_ADDR
// hc_gallery :=  ;
108024: LD_ADDR_OWVAR 33
108028: PUSH
108029: LD_STRING 
108031: ST_TO_ADDR
// hc_name :=  ;
108032: LD_ADDR_OWVAR 26
108036: PUSH
108037: LD_STRING 
108039: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
108040: CALL_OW 44
108044: PPUSH
108045: LD_INT 0
108047: PPUSH
108048: CALL_OW 51
// end ;
108052: GO 107974
108054: POP
108055: POP
// end ;
108056: PPOPN 1
108058: END
// every 0 0$1 trigger StreamModeActive and sBomb do
108059: LD_EXP 153
108063: PUSH
108064: LD_EXP 173
108068: AND
108069: IFFALSE 108078
108071: GO 108073
108073: DISABLE
// StreamSibBomb ;
108074: CALL 108079 0 0
108078: END
// export function StreamSibBomb ; var i , x , y ; begin
108079: LD_INT 0
108081: PPUSH
108082: PPUSH
108083: PPUSH
108084: PPUSH
// result := false ;
108085: LD_ADDR_VAR 0 1
108089: PUSH
108090: LD_INT 0
108092: ST_TO_ADDR
// for i := 1 to 16 do
108093: LD_ADDR_VAR 0 2
108097: PUSH
108098: DOUBLE
108099: LD_INT 1
108101: DEC
108102: ST_TO_ADDR
108103: LD_INT 16
108105: PUSH
108106: FOR_TO
108107: IFFALSE 108306
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108109: LD_ADDR_VAR 0 3
108113: PUSH
108114: LD_INT 10
108116: PUSH
108117: LD_INT 20
108119: PUSH
108120: LD_INT 30
108122: PUSH
108123: LD_INT 40
108125: PUSH
108126: LD_INT 50
108128: PUSH
108129: LD_INT 60
108131: PUSH
108132: LD_INT 70
108134: PUSH
108135: LD_INT 80
108137: PUSH
108138: LD_INT 90
108140: PUSH
108141: LD_INT 100
108143: PUSH
108144: LD_INT 110
108146: PUSH
108147: LD_INT 120
108149: PUSH
108150: LD_INT 130
108152: PUSH
108153: LD_INT 140
108155: PUSH
108156: LD_INT 150
108158: PUSH
108159: EMPTY
108160: LIST
108161: LIST
108162: LIST
108163: LIST
108164: LIST
108165: LIST
108166: LIST
108167: LIST
108168: LIST
108169: LIST
108170: LIST
108171: LIST
108172: LIST
108173: LIST
108174: LIST
108175: PUSH
108176: LD_INT 1
108178: PPUSH
108179: LD_INT 15
108181: PPUSH
108182: CALL_OW 12
108186: ARRAY
108187: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108188: LD_ADDR_VAR 0 4
108192: PUSH
108193: LD_INT 10
108195: PUSH
108196: LD_INT 20
108198: PUSH
108199: LD_INT 30
108201: PUSH
108202: LD_INT 40
108204: PUSH
108205: LD_INT 50
108207: PUSH
108208: LD_INT 60
108210: PUSH
108211: LD_INT 70
108213: PUSH
108214: LD_INT 80
108216: PUSH
108217: LD_INT 90
108219: PUSH
108220: LD_INT 100
108222: PUSH
108223: LD_INT 110
108225: PUSH
108226: LD_INT 120
108228: PUSH
108229: LD_INT 130
108231: PUSH
108232: LD_INT 140
108234: PUSH
108235: LD_INT 150
108237: PUSH
108238: EMPTY
108239: LIST
108240: LIST
108241: LIST
108242: LIST
108243: LIST
108244: LIST
108245: LIST
108246: LIST
108247: LIST
108248: LIST
108249: LIST
108250: LIST
108251: LIST
108252: LIST
108253: LIST
108254: PUSH
108255: LD_INT 1
108257: PPUSH
108258: LD_INT 15
108260: PPUSH
108261: CALL_OW 12
108265: ARRAY
108266: ST_TO_ADDR
// if ValidHex ( x , y ) then
108267: LD_VAR 0 3
108271: PPUSH
108272: LD_VAR 0 4
108276: PPUSH
108277: CALL_OW 488
108281: IFFALSE 108304
// begin result := [ x , y ] ;
108283: LD_ADDR_VAR 0 1
108287: PUSH
108288: LD_VAR 0 3
108292: PUSH
108293: LD_VAR 0 4
108297: PUSH
108298: EMPTY
108299: LIST
108300: LIST
108301: ST_TO_ADDR
// break ;
108302: GO 108306
// end ; end ;
108304: GO 108106
108306: POP
108307: POP
// if result then
108308: LD_VAR 0 1
108312: IFFALSE 108372
// begin ToLua ( playSibBomb() ) ;
108314: LD_STRING playSibBomb()
108316: PPUSH
108317: CALL_OW 559
// wait ( 0 0$14 ) ;
108321: LD_INT 490
108323: PPUSH
108324: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108328: LD_VAR 0 1
108332: PUSH
108333: LD_INT 1
108335: ARRAY
108336: PPUSH
108337: LD_VAR 0 1
108341: PUSH
108342: LD_INT 2
108344: ARRAY
108345: PPUSH
108346: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108350: LD_VAR 0 1
108354: PUSH
108355: LD_INT 1
108357: ARRAY
108358: PPUSH
108359: LD_VAR 0 1
108363: PUSH
108364: LD_INT 2
108366: ARRAY
108367: PPUSH
108368: CALL_OW 429
// end ; end ;
108372: LD_VAR 0 1
108376: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108377: LD_EXP 153
108381: PUSH
108382: LD_EXP 175
108386: AND
108387: IFFALSE 108399
108389: GO 108391
108391: DISABLE
// YouLost (  ) ;
108392: LD_STRING 
108394: PPUSH
108395: CALL_OW 104
108399: END
// every 0 0$1 trigger StreamModeActive and sFog do
108400: LD_EXP 153
108404: PUSH
108405: LD_EXP 174
108409: AND
108410: IFFALSE 108424
108412: GO 108414
108414: DISABLE
// FogOff ( your_side ) ;
108415: LD_OWVAR 2
108419: PPUSH
108420: CALL_OW 344
108424: END
// every 0 0$1 trigger StreamModeActive and sSun do
108425: LD_EXP 153
108429: PUSH
108430: LD_EXP 176
108434: AND
108435: IFFALSE 108463
108437: GO 108439
108439: DISABLE
// begin solar_recharge_percent := 0 ;
108440: LD_ADDR_OWVAR 79
108444: PUSH
108445: LD_INT 0
108447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108448: LD_INT 10500
108450: PPUSH
108451: CALL_OW 67
// solar_recharge_percent := 100 ;
108455: LD_ADDR_OWVAR 79
108459: PUSH
108460: LD_INT 100
108462: ST_TO_ADDR
// end ;
108463: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108464: LD_EXP 153
108468: PUSH
108469: LD_EXP 177
108473: AND
108474: IFFALSE 108713
108476: GO 108478
108478: DISABLE
108479: LD_INT 0
108481: PPUSH
108482: PPUSH
108483: PPUSH
// begin tmp := [ ] ;
108484: LD_ADDR_VAR 0 3
108488: PUSH
108489: EMPTY
108490: ST_TO_ADDR
// for i := 1 to 6 do
108491: LD_ADDR_VAR 0 1
108495: PUSH
108496: DOUBLE
108497: LD_INT 1
108499: DEC
108500: ST_TO_ADDR
108501: LD_INT 6
108503: PUSH
108504: FOR_TO
108505: IFFALSE 108610
// begin uc_nation := nation_nature ;
108507: LD_ADDR_OWVAR 21
108511: PUSH
108512: LD_INT 0
108514: ST_TO_ADDR
// uc_side := 0 ;
108515: LD_ADDR_OWVAR 20
108519: PUSH
108520: LD_INT 0
108522: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108523: LD_ADDR_OWVAR 29
108527: PUSH
108528: LD_INT 12
108530: PUSH
108531: LD_INT 12
108533: PUSH
108534: EMPTY
108535: LIST
108536: LIST
108537: ST_TO_ADDR
// hc_agressivity := 20 ;
108538: LD_ADDR_OWVAR 35
108542: PUSH
108543: LD_INT 20
108545: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108546: LD_ADDR_OWVAR 28
108550: PUSH
108551: LD_INT 17
108553: ST_TO_ADDR
// hc_gallery :=  ;
108554: LD_ADDR_OWVAR 33
108558: PUSH
108559: LD_STRING 
108561: ST_TO_ADDR
// hc_name :=  ;
108562: LD_ADDR_OWVAR 26
108566: PUSH
108567: LD_STRING 
108569: ST_TO_ADDR
// un := CreateHuman ;
108570: LD_ADDR_VAR 0 2
108574: PUSH
108575: CALL_OW 44
108579: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108580: LD_VAR 0 2
108584: PPUSH
108585: LD_INT 1
108587: PPUSH
108588: CALL_OW 51
// tmp := tmp ^ un ;
108592: LD_ADDR_VAR 0 3
108596: PUSH
108597: LD_VAR 0 3
108601: PUSH
108602: LD_VAR 0 2
108606: ADD
108607: ST_TO_ADDR
// end ;
108608: GO 108504
108610: POP
108611: POP
// repeat wait ( 0 0$1 ) ;
108612: LD_INT 35
108614: PPUSH
108615: CALL_OW 67
// for un in tmp do
108619: LD_ADDR_VAR 0 2
108623: PUSH
108624: LD_VAR 0 3
108628: PUSH
108629: FOR_IN
108630: IFFALSE 108704
// begin if IsDead ( un ) then
108632: LD_VAR 0 2
108636: PPUSH
108637: CALL_OW 301
108641: IFFALSE 108661
// begin tmp := tmp diff un ;
108643: LD_ADDR_VAR 0 3
108647: PUSH
108648: LD_VAR 0 3
108652: PUSH
108653: LD_VAR 0 2
108657: DIFF
108658: ST_TO_ADDR
// continue ;
108659: GO 108629
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108661: LD_VAR 0 2
108665: PPUSH
108666: LD_INT 3
108668: PUSH
108669: LD_INT 22
108671: PUSH
108672: LD_INT 0
108674: PUSH
108675: EMPTY
108676: LIST
108677: LIST
108678: PUSH
108679: EMPTY
108680: LIST
108681: LIST
108682: PPUSH
108683: CALL_OW 69
108687: PPUSH
108688: LD_VAR 0 2
108692: PPUSH
108693: CALL_OW 74
108697: PPUSH
108698: CALL_OW 115
// end ;
108702: GO 108629
108704: POP
108705: POP
// until not tmp ;
108706: LD_VAR 0 3
108710: NOT
108711: IFFALSE 108612
// end ;
108713: PPOPN 3
108715: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108716: LD_EXP 153
108720: PUSH
108721: LD_EXP 178
108725: AND
108726: IFFALSE 108780
108728: GO 108730
108730: DISABLE
// begin ToLua ( displayTroll(); ) ;
108731: LD_STRING displayTroll();
108733: PPUSH
108734: CALL_OW 559
// wait ( 3 3$00 ) ;
108738: LD_INT 6300
108740: PPUSH
108741: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108745: LD_STRING hideTroll();
108747: PPUSH
108748: CALL_OW 559
// wait ( 1 1$00 ) ;
108752: LD_INT 2100
108754: PPUSH
108755: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108759: LD_STRING displayTroll();
108761: PPUSH
108762: CALL_OW 559
// wait ( 1 1$00 ) ;
108766: LD_INT 2100
108768: PPUSH
108769: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108773: LD_STRING hideTroll();
108775: PPUSH
108776: CALL_OW 559
// end ;
108780: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108781: LD_EXP 153
108785: PUSH
108786: LD_EXP 179
108790: AND
108791: IFFALSE 108854
108793: GO 108795
108795: DISABLE
108796: LD_INT 0
108798: PPUSH
// begin p := 0 ;
108799: LD_ADDR_VAR 0 1
108803: PUSH
108804: LD_INT 0
108806: ST_TO_ADDR
// repeat game_speed := 1 ;
108807: LD_ADDR_OWVAR 65
108811: PUSH
108812: LD_INT 1
108814: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108815: LD_INT 35
108817: PPUSH
108818: CALL_OW 67
// p := p + 1 ;
108822: LD_ADDR_VAR 0 1
108826: PUSH
108827: LD_VAR 0 1
108831: PUSH
108832: LD_INT 1
108834: PLUS
108835: ST_TO_ADDR
// until p >= 60 ;
108836: LD_VAR 0 1
108840: PUSH
108841: LD_INT 60
108843: GREATEREQUAL
108844: IFFALSE 108807
// game_speed := 4 ;
108846: LD_ADDR_OWVAR 65
108850: PUSH
108851: LD_INT 4
108853: ST_TO_ADDR
// end ;
108854: PPOPN 1
108856: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108857: LD_EXP 153
108861: PUSH
108862: LD_EXP 180
108866: AND
108867: IFFALSE 109013
108869: GO 108871
108871: DISABLE
108872: LD_INT 0
108874: PPUSH
108875: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108876: LD_ADDR_VAR 0 1
108880: PUSH
108881: LD_INT 22
108883: PUSH
108884: LD_OWVAR 2
108888: PUSH
108889: EMPTY
108890: LIST
108891: LIST
108892: PUSH
108893: LD_INT 2
108895: PUSH
108896: LD_INT 30
108898: PUSH
108899: LD_INT 0
108901: PUSH
108902: EMPTY
108903: LIST
108904: LIST
108905: PUSH
108906: LD_INT 30
108908: PUSH
108909: LD_INT 1
108911: PUSH
108912: EMPTY
108913: LIST
108914: LIST
108915: PUSH
108916: EMPTY
108917: LIST
108918: LIST
108919: LIST
108920: PUSH
108921: EMPTY
108922: LIST
108923: LIST
108924: PPUSH
108925: CALL_OW 69
108929: ST_TO_ADDR
// if not depot then
108930: LD_VAR 0 1
108934: NOT
108935: IFFALSE 108939
// exit ;
108937: GO 109013
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108939: LD_ADDR_VAR 0 2
108943: PUSH
108944: LD_VAR 0 1
108948: PUSH
108949: LD_INT 1
108951: PPUSH
108952: LD_VAR 0 1
108956: PPUSH
108957: CALL_OW 12
108961: ARRAY
108962: PPUSH
108963: CALL_OW 274
108967: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108968: LD_VAR 0 2
108972: PPUSH
108973: LD_INT 1
108975: PPUSH
108976: LD_INT 0
108978: PPUSH
108979: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108983: LD_VAR 0 2
108987: PPUSH
108988: LD_INT 2
108990: PPUSH
108991: LD_INT 0
108993: PPUSH
108994: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
108998: LD_VAR 0 2
109002: PPUSH
109003: LD_INT 3
109005: PPUSH
109006: LD_INT 0
109008: PPUSH
109009: CALL_OW 277
// end ;
109013: PPOPN 2
109015: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
109016: LD_EXP 153
109020: PUSH
109021: LD_EXP 181
109025: AND
109026: IFFALSE 109123
109028: GO 109030
109030: DISABLE
109031: LD_INT 0
109033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109034: LD_ADDR_VAR 0 1
109038: PUSH
109039: LD_INT 22
109041: PUSH
109042: LD_OWVAR 2
109046: PUSH
109047: EMPTY
109048: LIST
109049: LIST
109050: PUSH
109051: LD_INT 21
109053: PUSH
109054: LD_INT 1
109056: PUSH
109057: EMPTY
109058: LIST
109059: LIST
109060: PUSH
109061: LD_INT 3
109063: PUSH
109064: LD_INT 23
109066: PUSH
109067: LD_INT 0
109069: PUSH
109070: EMPTY
109071: LIST
109072: LIST
109073: PUSH
109074: EMPTY
109075: LIST
109076: LIST
109077: PUSH
109078: EMPTY
109079: LIST
109080: LIST
109081: LIST
109082: PPUSH
109083: CALL_OW 69
109087: ST_TO_ADDR
// if not tmp then
109088: LD_VAR 0 1
109092: NOT
109093: IFFALSE 109097
// exit ;
109095: GO 109123
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
109097: LD_VAR 0 1
109101: PUSH
109102: LD_INT 1
109104: PPUSH
109105: LD_VAR 0 1
109109: PPUSH
109110: CALL_OW 12
109114: ARRAY
109115: PPUSH
109116: LD_INT 200
109118: PPUSH
109119: CALL_OW 234
// end ;
109123: PPOPN 1
109125: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
109126: LD_EXP 153
109130: PUSH
109131: LD_EXP 182
109135: AND
109136: IFFALSE 109215
109138: GO 109140
109140: DISABLE
109141: LD_INT 0
109143: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
109144: LD_ADDR_VAR 0 1
109148: PUSH
109149: LD_INT 22
109151: PUSH
109152: LD_OWVAR 2
109156: PUSH
109157: EMPTY
109158: LIST
109159: LIST
109160: PUSH
109161: LD_INT 21
109163: PUSH
109164: LD_INT 2
109166: PUSH
109167: EMPTY
109168: LIST
109169: LIST
109170: PUSH
109171: EMPTY
109172: LIST
109173: LIST
109174: PPUSH
109175: CALL_OW 69
109179: ST_TO_ADDR
// if not tmp then
109180: LD_VAR 0 1
109184: NOT
109185: IFFALSE 109189
// exit ;
109187: GO 109215
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
109189: LD_VAR 0 1
109193: PUSH
109194: LD_INT 1
109196: PPUSH
109197: LD_VAR 0 1
109201: PPUSH
109202: CALL_OW 12
109206: ARRAY
109207: PPUSH
109208: LD_INT 60
109210: PPUSH
109211: CALL_OW 234
// end ;
109215: PPOPN 1
109217: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
109218: LD_EXP 153
109222: PUSH
109223: LD_EXP 183
109227: AND
109228: IFFALSE 109327
109230: GO 109232
109232: DISABLE
109233: LD_INT 0
109235: PPUSH
109236: PPUSH
// begin enable ;
109237: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
109238: LD_ADDR_VAR 0 1
109242: PUSH
109243: LD_INT 22
109245: PUSH
109246: LD_OWVAR 2
109250: PUSH
109251: EMPTY
109252: LIST
109253: LIST
109254: PUSH
109255: LD_INT 61
109257: PUSH
109258: EMPTY
109259: LIST
109260: PUSH
109261: LD_INT 33
109263: PUSH
109264: LD_INT 2
109266: PUSH
109267: EMPTY
109268: LIST
109269: LIST
109270: PUSH
109271: EMPTY
109272: LIST
109273: LIST
109274: LIST
109275: PPUSH
109276: CALL_OW 69
109280: ST_TO_ADDR
// if not tmp then
109281: LD_VAR 0 1
109285: NOT
109286: IFFALSE 109290
// exit ;
109288: GO 109327
// for i in tmp do
109290: LD_ADDR_VAR 0 2
109294: PUSH
109295: LD_VAR 0 1
109299: PUSH
109300: FOR_IN
109301: IFFALSE 109325
// if IsControledBy ( i ) then
109303: LD_VAR 0 2
109307: PPUSH
109308: CALL_OW 312
109312: IFFALSE 109323
// ComUnlink ( i ) ;
109314: LD_VAR 0 2
109318: PPUSH
109319: CALL_OW 136
109323: GO 109300
109325: POP
109326: POP
// end ;
109327: PPOPN 2
109329: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109330: LD_EXP 153
109334: PUSH
109335: LD_EXP 184
109339: AND
109340: IFFALSE 109480
109342: GO 109344
109344: DISABLE
109345: LD_INT 0
109347: PPUSH
109348: PPUSH
// begin ToLua ( displayPowell(); ) ;
109349: LD_STRING displayPowell();
109351: PPUSH
109352: CALL_OW 559
// uc_side := 0 ;
109356: LD_ADDR_OWVAR 20
109360: PUSH
109361: LD_INT 0
109363: ST_TO_ADDR
// uc_nation := 2 ;
109364: LD_ADDR_OWVAR 21
109368: PUSH
109369: LD_INT 2
109371: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109372: LD_ADDR_OWVAR 37
109376: PUSH
109377: LD_INT 14
109379: ST_TO_ADDR
// vc_engine := engine_siberite ;
109380: LD_ADDR_OWVAR 39
109384: PUSH
109385: LD_INT 3
109387: ST_TO_ADDR
// vc_control := control_apeman ;
109388: LD_ADDR_OWVAR 38
109392: PUSH
109393: LD_INT 5
109395: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109396: LD_ADDR_OWVAR 40
109400: PUSH
109401: LD_INT 29
109403: ST_TO_ADDR
// un := CreateVehicle ;
109404: LD_ADDR_VAR 0 2
109408: PUSH
109409: CALL_OW 45
109413: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109414: LD_VAR 0 2
109418: PPUSH
109419: LD_INT 1
109421: PPUSH
109422: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109426: LD_INT 35
109428: PPUSH
109429: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109433: LD_VAR 0 2
109437: PPUSH
109438: LD_INT 22
109440: PUSH
109441: LD_OWVAR 2
109445: PUSH
109446: EMPTY
109447: LIST
109448: LIST
109449: PPUSH
109450: CALL_OW 69
109454: PPUSH
109455: LD_VAR 0 2
109459: PPUSH
109460: CALL_OW 74
109464: PPUSH
109465: CALL_OW 115
// until IsDead ( un ) ;
109469: LD_VAR 0 2
109473: PPUSH
109474: CALL_OW 301
109478: IFFALSE 109426
// end ;
109480: PPOPN 2
109482: END
// every 0 0$1 trigger StreamModeActive and sStu do
109483: LD_EXP 153
109487: PUSH
109488: LD_EXP 192
109492: AND
109493: IFFALSE 109509
109495: GO 109497
109497: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109498: LD_STRING displayStucuk();
109500: PPUSH
109501: CALL_OW 559
// ResetFog ;
109505: CALL_OW 335
// end ;
109509: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109510: LD_EXP 153
109514: PUSH
109515: LD_EXP 185
109519: AND
109520: IFFALSE 109661
109522: GO 109524
109524: DISABLE
109525: LD_INT 0
109527: PPUSH
109528: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109529: LD_ADDR_VAR 0 2
109533: PUSH
109534: LD_INT 22
109536: PUSH
109537: LD_OWVAR 2
109541: PUSH
109542: EMPTY
109543: LIST
109544: LIST
109545: PUSH
109546: LD_INT 21
109548: PUSH
109549: LD_INT 1
109551: PUSH
109552: EMPTY
109553: LIST
109554: LIST
109555: PUSH
109556: EMPTY
109557: LIST
109558: LIST
109559: PPUSH
109560: CALL_OW 69
109564: ST_TO_ADDR
// if not tmp then
109565: LD_VAR 0 2
109569: NOT
109570: IFFALSE 109574
// exit ;
109572: GO 109661
// un := tmp [ rand ( 1 , tmp ) ] ;
109574: LD_ADDR_VAR 0 1
109578: PUSH
109579: LD_VAR 0 2
109583: PUSH
109584: LD_INT 1
109586: PPUSH
109587: LD_VAR 0 2
109591: PPUSH
109592: CALL_OW 12
109596: ARRAY
109597: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109598: LD_VAR 0 1
109602: PPUSH
109603: LD_INT 0
109605: PPUSH
109606: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109610: LD_VAR 0 1
109614: PPUSH
109615: LD_OWVAR 3
109619: PUSH
109620: LD_VAR 0 1
109624: DIFF
109625: PPUSH
109626: LD_VAR 0 1
109630: PPUSH
109631: CALL_OW 74
109635: PPUSH
109636: CALL_OW 115
// wait ( 0 0$20 ) ;
109640: LD_INT 700
109642: PPUSH
109643: CALL_OW 67
// SetSide ( un , your_side ) ;
109647: LD_VAR 0 1
109651: PPUSH
109652: LD_OWVAR 2
109656: PPUSH
109657: CALL_OW 235
// end ;
109661: PPOPN 2
109663: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109664: LD_EXP 153
109668: PUSH
109669: LD_EXP 186
109673: AND
109674: IFFALSE 109780
109676: GO 109678
109678: DISABLE
109679: LD_INT 0
109681: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109682: LD_ADDR_VAR 0 1
109686: PUSH
109687: LD_INT 22
109689: PUSH
109690: LD_OWVAR 2
109694: PUSH
109695: EMPTY
109696: LIST
109697: LIST
109698: PUSH
109699: LD_INT 2
109701: PUSH
109702: LD_INT 30
109704: PUSH
109705: LD_INT 0
109707: PUSH
109708: EMPTY
109709: LIST
109710: LIST
109711: PUSH
109712: LD_INT 30
109714: PUSH
109715: LD_INT 1
109717: PUSH
109718: EMPTY
109719: LIST
109720: LIST
109721: PUSH
109722: EMPTY
109723: LIST
109724: LIST
109725: LIST
109726: PUSH
109727: EMPTY
109728: LIST
109729: LIST
109730: PPUSH
109731: CALL_OW 69
109735: ST_TO_ADDR
// if not depot then
109736: LD_VAR 0 1
109740: NOT
109741: IFFALSE 109745
// exit ;
109743: GO 109780
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109745: LD_VAR 0 1
109749: PUSH
109750: LD_INT 1
109752: ARRAY
109753: PPUSH
109754: CALL_OW 250
109758: PPUSH
109759: LD_VAR 0 1
109763: PUSH
109764: LD_INT 1
109766: ARRAY
109767: PPUSH
109768: CALL_OW 251
109772: PPUSH
109773: LD_INT 70
109775: PPUSH
109776: CALL_OW 495
// end ;
109780: PPOPN 1
109782: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109783: LD_EXP 153
109787: PUSH
109788: LD_EXP 187
109792: AND
109793: IFFALSE 110004
109795: GO 109797
109797: DISABLE
109798: LD_INT 0
109800: PPUSH
109801: PPUSH
109802: PPUSH
109803: PPUSH
109804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109805: LD_ADDR_VAR 0 5
109809: PUSH
109810: LD_INT 22
109812: PUSH
109813: LD_OWVAR 2
109817: PUSH
109818: EMPTY
109819: LIST
109820: LIST
109821: PUSH
109822: LD_INT 21
109824: PUSH
109825: LD_INT 1
109827: PUSH
109828: EMPTY
109829: LIST
109830: LIST
109831: PUSH
109832: EMPTY
109833: LIST
109834: LIST
109835: PPUSH
109836: CALL_OW 69
109840: ST_TO_ADDR
// if not tmp then
109841: LD_VAR 0 5
109845: NOT
109846: IFFALSE 109850
// exit ;
109848: GO 110004
// for i in tmp do
109850: LD_ADDR_VAR 0 1
109854: PUSH
109855: LD_VAR 0 5
109859: PUSH
109860: FOR_IN
109861: IFFALSE 110002
// begin d := rand ( 0 , 5 ) ;
109863: LD_ADDR_VAR 0 4
109867: PUSH
109868: LD_INT 0
109870: PPUSH
109871: LD_INT 5
109873: PPUSH
109874: CALL_OW 12
109878: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109879: LD_ADDR_VAR 0 2
109883: PUSH
109884: LD_VAR 0 1
109888: PPUSH
109889: CALL_OW 250
109893: PPUSH
109894: LD_VAR 0 4
109898: PPUSH
109899: LD_INT 3
109901: PPUSH
109902: LD_INT 12
109904: PPUSH
109905: CALL_OW 12
109909: PPUSH
109910: CALL_OW 272
109914: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109915: LD_ADDR_VAR 0 3
109919: PUSH
109920: LD_VAR 0 1
109924: PPUSH
109925: CALL_OW 251
109929: PPUSH
109930: LD_VAR 0 4
109934: PPUSH
109935: LD_INT 3
109937: PPUSH
109938: LD_INT 12
109940: PPUSH
109941: CALL_OW 12
109945: PPUSH
109946: CALL_OW 273
109950: ST_TO_ADDR
// if ValidHex ( x , y ) then
109951: LD_VAR 0 2
109955: PPUSH
109956: LD_VAR 0 3
109960: PPUSH
109961: CALL_OW 488
109965: IFFALSE 110000
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109967: LD_VAR 0 1
109971: PPUSH
109972: LD_VAR 0 2
109976: PPUSH
109977: LD_VAR 0 3
109981: PPUSH
109982: LD_INT 3
109984: PPUSH
109985: LD_INT 6
109987: PPUSH
109988: CALL_OW 12
109992: PPUSH
109993: LD_INT 1
109995: PPUSH
109996: CALL_OW 483
// end ;
110000: GO 109860
110002: POP
110003: POP
// end ;
110004: PPOPN 5
110006: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110007: LD_EXP 153
110011: PUSH
110012: LD_EXP 188
110016: AND
110017: IFFALSE 110111
110019: GO 110021
110021: DISABLE
110022: LD_INT 0
110024: PPUSH
110025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
110026: LD_ADDR_VAR 0 2
110030: PUSH
110031: LD_INT 22
110033: PUSH
110034: LD_OWVAR 2
110038: PUSH
110039: EMPTY
110040: LIST
110041: LIST
110042: PUSH
110043: LD_INT 32
110045: PUSH
110046: LD_INT 1
110048: PUSH
110049: EMPTY
110050: LIST
110051: LIST
110052: PUSH
110053: LD_INT 21
110055: PUSH
110056: LD_INT 2
110058: PUSH
110059: EMPTY
110060: LIST
110061: LIST
110062: PUSH
110063: EMPTY
110064: LIST
110065: LIST
110066: LIST
110067: PPUSH
110068: CALL_OW 69
110072: ST_TO_ADDR
// if not tmp then
110073: LD_VAR 0 2
110077: NOT
110078: IFFALSE 110082
// exit ;
110080: GO 110111
// for i in tmp do
110082: LD_ADDR_VAR 0 1
110086: PUSH
110087: LD_VAR 0 2
110091: PUSH
110092: FOR_IN
110093: IFFALSE 110109
// SetFuel ( i , 0 ) ;
110095: LD_VAR 0 1
110099: PPUSH
110100: LD_INT 0
110102: PPUSH
110103: CALL_OW 240
110107: GO 110092
110109: POP
110110: POP
// end ;
110111: PPOPN 2
110113: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
110114: LD_EXP 153
110118: PUSH
110119: LD_EXP 189
110123: AND
110124: IFFALSE 110190
110126: GO 110128
110128: DISABLE
110129: LD_INT 0
110131: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
110132: LD_ADDR_VAR 0 1
110136: PUSH
110137: LD_INT 22
110139: PUSH
110140: LD_OWVAR 2
110144: PUSH
110145: EMPTY
110146: LIST
110147: LIST
110148: PUSH
110149: LD_INT 30
110151: PUSH
110152: LD_INT 29
110154: PUSH
110155: EMPTY
110156: LIST
110157: LIST
110158: PUSH
110159: EMPTY
110160: LIST
110161: LIST
110162: PPUSH
110163: CALL_OW 69
110167: ST_TO_ADDR
// if not tmp then
110168: LD_VAR 0 1
110172: NOT
110173: IFFALSE 110177
// exit ;
110175: GO 110190
// DestroyUnit ( tmp [ 1 ] ) ;
110177: LD_VAR 0 1
110181: PUSH
110182: LD_INT 1
110184: ARRAY
110185: PPUSH
110186: CALL_OW 65
// end ;
110190: PPOPN 1
110192: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
110193: LD_EXP 153
110197: PUSH
110198: LD_EXP 191
110202: AND
110203: IFFALSE 110332
110205: GO 110207
110207: DISABLE
110208: LD_INT 0
110210: PPUSH
// begin uc_side := 0 ;
110211: LD_ADDR_OWVAR 20
110215: PUSH
110216: LD_INT 0
110218: ST_TO_ADDR
// uc_nation := nation_arabian ;
110219: LD_ADDR_OWVAR 21
110223: PUSH
110224: LD_INT 2
110226: ST_TO_ADDR
// hc_gallery :=  ;
110227: LD_ADDR_OWVAR 33
110231: PUSH
110232: LD_STRING 
110234: ST_TO_ADDR
// hc_name :=  ;
110235: LD_ADDR_OWVAR 26
110239: PUSH
110240: LD_STRING 
110242: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
110243: LD_INT 1
110245: PPUSH
110246: LD_INT 11
110248: PPUSH
110249: LD_INT 10
110251: PPUSH
110252: CALL_OW 380
// un := CreateHuman ;
110256: LD_ADDR_VAR 0 1
110260: PUSH
110261: CALL_OW 44
110265: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110266: LD_VAR 0 1
110270: PPUSH
110271: LD_INT 1
110273: PPUSH
110274: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110278: LD_INT 35
110280: PPUSH
110281: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110285: LD_VAR 0 1
110289: PPUSH
110290: LD_INT 22
110292: PUSH
110293: LD_OWVAR 2
110297: PUSH
110298: EMPTY
110299: LIST
110300: LIST
110301: PPUSH
110302: CALL_OW 69
110306: PPUSH
110307: LD_VAR 0 1
110311: PPUSH
110312: CALL_OW 74
110316: PPUSH
110317: CALL_OW 115
// until IsDead ( un ) ;
110321: LD_VAR 0 1
110325: PPUSH
110326: CALL_OW 301
110330: IFFALSE 110278
// end ;
110332: PPOPN 1
110334: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110335: LD_EXP 153
110339: PUSH
110340: LD_EXP 193
110344: AND
110345: IFFALSE 110357
110347: GO 110349
110349: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110350: LD_STRING earthquake(getX(game), 0, 32)
110352: PPUSH
110353: CALL_OW 559
110357: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110358: LD_EXP 153
110362: PUSH
110363: LD_EXP 194
110367: AND
110368: IFFALSE 110459
110370: GO 110372
110372: DISABLE
110373: LD_INT 0
110375: PPUSH
// begin enable ;
110376: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110377: LD_ADDR_VAR 0 1
110381: PUSH
110382: LD_INT 22
110384: PUSH
110385: LD_OWVAR 2
110389: PUSH
110390: EMPTY
110391: LIST
110392: LIST
110393: PUSH
110394: LD_INT 21
110396: PUSH
110397: LD_INT 2
110399: PUSH
110400: EMPTY
110401: LIST
110402: LIST
110403: PUSH
110404: LD_INT 33
110406: PUSH
110407: LD_INT 3
110409: PUSH
110410: EMPTY
110411: LIST
110412: LIST
110413: PUSH
110414: EMPTY
110415: LIST
110416: LIST
110417: LIST
110418: PPUSH
110419: CALL_OW 69
110423: ST_TO_ADDR
// if not tmp then
110424: LD_VAR 0 1
110428: NOT
110429: IFFALSE 110433
// exit ;
110431: GO 110459
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110433: LD_VAR 0 1
110437: PUSH
110438: LD_INT 1
110440: PPUSH
110441: LD_VAR 0 1
110445: PPUSH
110446: CALL_OW 12
110450: ARRAY
110451: PPUSH
110452: LD_INT 1
110454: PPUSH
110455: CALL_OW 234
// end ;
110459: PPOPN 1
110461: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110462: LD_EXP 153
110466: PUSH
110467: LD_EXP 195
110471: AND
110472: IFFALSE 110613
110474: GO 110476
110476: DISABLE
110477: LD_INT 0
110479: PPUSH
110480: PPUSH
110481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110482: LD_ADDR_VAR 0 3
110486: PUSH
110487: LD_INT 22
110489: PUSH
110490: LD_OWVAR 2
110494: PUSH
110495: EMPTY
110496: LIST
110497: LIST
110498: PUSH
110499: LD_INT 25
110501: PUSH
110502: LD_INT 1
110504: PUSH
110505: EMPTY
110506: LIST
110507: LIST
110508: PUSH
110509: EMPTY
110510: LIST
110511: LIST
110512: PPUSH
110513: CALL_OW 69
110517: ST_TO_ADDR
// if not tmp then
110518: LD_VAR 0 3
110522: NOT
110523: IFFALSE 110527
// exit ;
110525: GO 110613
// un := tmp [ rand ( 1 , tmp ) ] ;
110527: LD_ADDR_VAR 0 2
110531: PUSH
110532: LD_VAR 0 3
110536: PUSH
110537: LD_INT 1
110539: PPUSH
110540: LD_VAR 0 3
110544: PPUSH
110545: CALL_OW 12
110549: ARRAY
110550: ST_TO_ADDR
// if Crawls ( un ) then
110551: LD_VAR 0 2
110555: PPUSH
110556: CALL_OW 318
110560: IFFALSE 110571
// ComWalk ( un ) ;
110562: LD_VAR 0 2
110566: PPUSH
110567: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110571: LD_VAR 0 2
110575: PPUSH
110576: LD_INT 9
110578: PPUSH
110579: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110583: LD_INT 28
110585: PPUSH
110586: LD_OWVAR 2
110590: PPUSH
110591: LD_INT 2
110593: PPUSH
110594: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110598: LD_INT 29
110600: PPUSH
110601: LD_OWVAR 2
110605: PPUSH
110606: LD_INT 2
110608: PPUSH
110609: CALL_OW 322
// end ;
110613: PPOPN 3
110615: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110616: LD_EXP 153
110620: PUSH
110621: LD_EXP 196
110625: AND
110626: IFFALSE 110737
110628: GO 110630
110630: DISABLE
110631: LD_INT 0
110633: PPUSH
110634: PPUSH
110635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110636: LD_ADDR_VAR 0 3
110640: PUSH
110641: LD_INT 22
110643: PUSH
110644: LD_OWVAR 2
110648: PUSH
110649: EMPTY
110650: LIST
110651: LIST
110652: PUSH
110653: LD_INT 25
110655: PUSH
110656: LD_INT 1
110658: PUSH
110659: EMPTY
110660: LIST
110661: LIST
110662: PUSH
110663: EMPTY
110664: LIST
110665: LIST
110666: PPUSH
110667: CALL_OW 69
110671: ST_TO_ADDR
// if not tmp then
110672: LD_VAR 0 3
110676: NOT
110677: IFFALSE 110681
// exit ;
110679: GO 110737
// un := tmp [ rand ( 1 , tmp ) ] ;
110681: LD_ADDR_VAR 0 2
110685: PUSH
110686: LD_VAR 0 3
110690: PUSH
110691: LD_INT 1
110693: PPUSH
110694: LD_VAR 0 3
110698: PPUSH
110699: CALL_OW 12
110703: ARRAY
110704: ST_TO_ADDR
// if Crawls ( un ) then
110705: LD_VAR 0 2
110709: PPUSH
110710: CALL_OW 318
110714: IFFALSE 110725
// ComWalk ( un ) ;
110716: LD_VAR 0 2
110720: PPUSH
110721: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110725: LD_VAR 0 2
110729: PPUSH
110730: LD_INT 8
110732: PPUSH
110733: CALL_OW 336
// end ;
110737: PPOPN 3
110739: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110740: LD_EXP 153
110744: PUSH
110745: LD_EXP 197
110749: AND
110750: IFFALSE 110894
110752: GO 110754
110754: DISABLE
110755: LD_INT 0
110757: PPUSH
110758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110759: LD_ADDR_VAR 0 2
110763: PUSH
110764: LD_INT 22
110766: PUSH
110767: LD_OWVAR 2
110771: PUSH
110772: EMPTY
110773: LIST
110774: LIST
110775: PUSH
110776: LD_INT 21
110778: PUSH
110779: LD_INT 2
110781: PUSH
110782: EMPTY
110783: LIST
110784: LIST
110785: PUSH
110786: LD_INT 2
110788: PUSH
110789: LD_INT 34
110791: PUSH
110792: LD_INT 12
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: PUSH
110799: LD_INT 34
110801: PUSH
110802: LD_INT 51
110804: PUSH
110805: EMPTY
110806: LIST
110807: LIST
110808: PUSH
110809: LD_INT 34
110811: PUSH
110812: LD_INT 32
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PUSH
110819: EMPTY
110820: LIST
110821: LIST
110822: LIST
110823: LIST
110824: PUSH
110825: EMPTY
110826: LIST
110827: LIST
110828: LIST
110829: PPUSH
110830: CALL_OW 69
110834: ST_TO_ADDR
// if not tmp then
110835: LD_VAR 0 2
110839: NOT
110840: IFFALSE 110844
// exit ;
110842: GO 110894
// for i in tmp do
110844: LD_ADDR_VAR 0 1
110848: PUSH
110849: LD_VAR 0 2
110853: PUSH
110854: FOR_IN
110855: IFFALSE 110892
// if GetCargo ( i , mat_artifact ) = 0 then
110857: LD_VAR 0 1
110861: PPUSH
110862: LD_INT 4
110864: PPUSH
110865: CALL_OW 289
110869: PUSH
110870: LD_INT 0
110872: EQUAL
110873: IFFALSE 110890
// SetCargo ( i , mat_siberit , 100 ) ;
110875: LD_VAR 0 1
110879: PPUSH
110880: LD_INT 3
110882: PPUSH
110883: LD_INT 100
110885: PPUSH
110886: CALL_OW 290
110890: GO 110854
110892: POP
110893: POP
// end ;
110894: PPOPN 2
110896: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110897: LD_EXP 153
110901: PUSH
110902: LD_EXP 198
110906: AND
110907: IFFALSE 111090
110909: GO 110911
110911: DISABLE
110912: LD_INT 0
110914: PPUSH
110915: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110916: LD_ADDR_VAR 0 2
110920: PUSH
110921: LD_INT 22
110923: PUSH
110924: LD_OWVAR 2
110928: PUSH
110929: EMPTY
110930: LIST
110931: LIST
110932: PPUSH
110933: CALL_OW 69
110937: ST_TO_ADDR
// if not tmp then
110938: LD_VAR 0 2
110942: NOT
110943: IFFALSE 110947
// exit ;
110945: GO 111090
// for i := 1 to 2 do
110947: LD_ADDR_VAR 0 1
110951: PUSH
110952: DOUBLE
110953: LD_INT 1
110955: DEC
110956: ST_TO_ADDR
110957: LD_INT 2
110959: PUSH
110960: FOR_TO
110961: IFFALSE 111088
// begin uc_side := your_side ;
110963: LD_ADDR_OWVAR 20
110967: PUSH
110968: LD_OWVAR 2
110972: ST_TO_ADDR
// uc_nation := nation_american ;
110973: LD_ADDR_OWVAR 21
110977: PUSH
110978: LD_INT 1
110980: ST_TO_ADDR
// vc_chassis := us_morphling ;
110981: LD_ADDR_OWVAR 37
110985: PUSH
110986: LD_INT 5
110988: ST_TO_ADDR
// vc_engine := engine_siberite ;
110989: LD_ADDR_OWVAR 39
110993: PUSH
110994: LD_INT 3
110996: ST_TO_ADDR
// vc_control := control_computer ;
110997: LD_ADDR_OWVAR 38
111001: PUSH
111002: LD_INT 3
111004: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111005: LD_ADDR_OWVAR 40
111009: PUSH
111010: LD_INT 10
111012: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111013: LD_VAR 0 2
111017: PUSH
111018: LD_INT 1
111020: ARRAY
111021: PPUSH
111022: CALL_OW 310
111026: NOT
111027: IFFALSE 111074
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
111029: CALL_OW 45
111033: PPUSH
111034: LD_VAR 0 2
111038: PUSH
111039: LD_INT 1
111041: ARRAY
111042: PPUSH
111043: CALL_OW 250
111047: PPUSH
111048: LD_VAR 0 2
111052: PUSH
111053: LD_INT 1
111055: ARRAY
111056: PPUSH
111057: CALL_OW 251
111061: PPUSH
111062: LD_INT 12
111064: PPUSH
111065: LD_INT 1
111067: PPUSH
111068: CALL_OW 50
111072: GO 111086
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
111074: CALL_OW 45
111078: PPUSH
111079: LD_INT 1
111081: PPUSH
111082: CALL_OW 51
// end ;
111086: GO 110960
111088: POP
111089: POP
// end ;
111090: PPOPN 2
111092: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
111093: LD_EXP 153
111097: PUSH
111098: LD_EXP 199
111102: AND
111103: IFFALSE 111325
111105: GO 111107
111107: DISABLE
111108: LD_INT 0
111110: PPUSH
111111: PPUSH
111112: PPUSH
111113: PPUSH
111114: PPUSH
111115: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111116: LD_ADDR_VAR 0 6
111120: PUSH
111121: LD_INT 22
111123: PUSH
111124: LD_OWVAR 2
111128: PUSH
111129: EMPTY
111130: LIST
111131: LIST
111132: PUSH
111133: LD_INT 21
111135: PUSH
111136: LD_INT 1
111138: PUSH
111139: EMPTY
111140: LIST
111141: LIST
111142: PUSH
111143: LD_INT 3
111145: PUSH
111146: LD_INT 23
111148: PUSH
111149: LD_INT 0
111151: PUSH
111152: EMPTY
111153: LIST
111154: LIST
111155: PUSH
111156: EMPTY
111157: LIST
111158: LIST
111159: PUSH
111160: EMPTY
111161: LIST
111162: LIST
111163: LIST
111164: PPUSH
111165: CALL_OW 69
111169: ST_TO_ADDR
// if not tmp then
111170: LD_VAR 0 6
111174: NOT
111175: IFFALSE 111179
// exit ;
111177: GO 111325
// s1 := rand ( 1 , 4 ) ;
111179: LD_ADDR_VAR 0 2
111183: PUSH
111184: LD_INT 1
111186: PPUSH
111187: LD_INT 4
111189: PPUSH
111190: CALL_OW 12
111194: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
111195: LD_ADDR_VAR 0 4
111199: PUSH
111200: LD_VAR 0 6
111204: PUSH
111205: LD_INT 1
111207: ARRAY
111208: PPUSH
111209: LD_VAR 0 2
111213: PPUSH
111214: CALL_OW 259
111218: ST_TO_ADDR
// if s1 = 1 then
111219: LD_VAR 0 2
111223: PUSH
111224: LD_INT 1
111226: EQUAL
111227: IFFALSE 111247
// s2 := rand ( 2 , 4 ) else
111229: LD_ADDR_VAR 0 3
111233: PUSH
111234: LD_INT 2
111236: PPUSH
111237: LD_INT 4
111239: PPUSH
111240: CALL_OW 12
111244: ST_TO_ADDR
111245: GO 111255
// s2 := 1 ;
111247: LD_ADDR_VAR 0 3
111251: PUSH
111252: LD_INT 1
111254: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
111255: LD_ADDR_VAR 0 5
111259: PUSH
111260: LD_VAR 0 6
111264: PUSH
111265: LD_INT 1
111267: ARRAY
111268: PPUSH
111269: LD_VAR 0 3
111273: PPUSH
111274: CALL_OW 259
111278: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
111279: LD_VAR 0 6
111283: PUSH
111284: LD_INT 1
111286: ARRAY
111287: PPUSH
111288: LD_VAR 0 2
111292: PPUSH
111293: LD_VAR 0 5
111297: PPUSH
111298: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111302: LD_VAR 0 6
111306: PUSH
111307: LD_INT 1
111309: ARRAY
111310: PPUSH
111311: LD_VAR 0 3
111315: PPUSH
111316: LD_VAR 0 4
111320: PPUSH
111321: CALL_OW 237
// end ;
111325: PPOPN 6
111327: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111328: LD_EXP 153
111332: PUSH
111333: LD_EXP 200
111337: AND
111338: IFFALSE 111417
111340: GO 111342
111342: DISABLE
111343: LD_INT 0
111345: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111346: LD_ADDR_VAR 0 1
111350: PUSH
111351: LD_INT 22
111353: PUSH
111354: LD_OWVAR 2
111358: PUSH
111359: EMPTY
111360: LIST
111361: LIST
111362: PUSH
111363: LD_INT 30
111365: PUSH
111366: LD_INT 3
111368: PUSH
111369: EMPTY
111370: LIST
111371: LIST
111372: PUSH
111373: EMPTY
111374: LIST
111375: LIST
111376: PPUSH
111377: CALL_OW 69
111381: ST_TO_ADDR
// if not tmp then
111382: LD_VAR 0 1
111386: NOT
111387: IFFALSE 111391
// exit ;
111389: GO 111417
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111391: LD_VAR 0 1
111395: PUSH
111396: LD_INT 1
111398: PPUSH
111399: LD_VAR 0 1
111403: PPUSH
111404: CALL_OW 12
111408: ARRAY
111409: PPUSH
111410: LD_INT 1
111412: PPUSH
111413: CALL_OW 234
// end ;
111417: PPOPN 1
111419: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111420: LD_EXP 153
111424: PUSH
111425: LD_EXP 201
111429: AND
111430: IFFALSE 111542
111432: GO 111434
111434: DISABLE
111435: LD_INT 0
111437: PPUSH
111438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111439: LD_ADDR_VAR 0 2
111443: PUSH
111444: LD_INT 22
111446: PUSH
111447: LD_OWVAR 2
111451: PUSH
111452: EMPTY
111453: LIST
111454: LIST
111455: PUSH
111456: LD_INT 2
111458: PUSH
111459: LD_INT 30
111461: PUSH
111462: LD_INT 27
111464: PUSH
111465: EMPTY
111466: LIST
111467: LIST
111468: PUSH
111469: LD_INT 30
111471: PUSH
111472: LD_INT 26
111474: PUSH
111475: EMPTY
111476: LIST
111477: LIST
111478: PUSH
111479: LD_INT 30
111481: PUSH
111482: LD_INT 28
111484: PUSH
111485: EMPTY
111486: LIST
111487: LIST
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: LIST
111493: LIST
111494: PUSH
111495: EMPTY
111496: LIST
111497: LIST
111498: PPUSH
111499: CALL_OW 69
111503: ST_TO_ADDR
// if not tmp then
111504: LD_VAR 0 2
111508: NOT
111509: IFFALSE 111513
// exit ;
111511: GO 111542
// for i in tmp do
111513: LD_ADDR_VAR 0 1
111517: PUSH
111518: LD_VAR 0 2
111522: PUSH
111523: FOR_IN
111524: IFFALSE 111540
// SetLives ( i , 1 ) ;
111526: LD_VAR 0 1
111530: PPUSH
111531: LD_INT 1
111533: PPUSH
111534: CALL_OW 234
111538: GO 111523
111540: POP
111541: POP
// end ;
111542: PPOPN 2
111544: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111545: LD_EXP 153
111549: PUSH
111550: LD_EXP 202
111554: AND
111555: IFFALSE 111829
111557: GO 111559
111559: DISABLE
111560: LD_INT 0
111562: PPUSH
111563: PPUSH
111564: PPUSH
// begin i := rand ( 1 , 7 ) ;
111565: LD_ADDR_VAR 0 1
111569: PUSH
111570: LD_INT 1
111572: PPUSH
111573: LD_INT 7
111575: PPUSH
111576: CALL_OW 12
111580: ST_TO_ADDR
// case i of 1 :
111581: LD_VAR 0 1
111585: PUSH
111586: LD_INT 1
111588: DOUBLE
111589: EQUAL
111590: IFTRUE 111594
111592: GO 111604
111594: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111595: LD_STRING earthquake(getX(game), 0, 32)
111597: PPUSH
111598: CALL_OW 559
111602: GO 111829
111604: LD_INT 2
111606: DOUBLE
111607: EQUAL
111608: IFTRUE 111612
111610: GO 111626
111612: POP
// begin ToLua ( displayStucuk(); ) ;
111613: LD_STRING displayStucuk();
111615: PPUSH
111616: CALL_OW 559
// ResetFog ;
111620: CALL_OW 335
// end ; 3 :
111624: GO 111829
111626: LD_INT 3
111628: DOUBLE
111629: EQUAL
111630: IFTRUE 111634
111632: GO 111738
111634: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111635: LD_ADDR_VAR 0 2
111639: PUSH
111640: LD_INT 22
111642: PUSH
111643: LD_OWVAR 2
111647: PUSH
111648: EMPTY
111649: LIST
111650: LIST
111651: PUSH
111652: LD_INT 25
111654: PUSH
111655: LD_INT 1
111657: PUSH
111658: EMPTY
111659: LIST
111660: LIST
111661: PUSH
111662: EMPTY
111663: LIST
111664: LIST
111665: PPUSH
111666: CALL_OW 69
111670: ST_TO_ADDR
// if not tmp then
111671: LD_VAR 0 2
111675: NOT
111676: IFFALSE 111680
// exit ;
111678: GO 111829
// un := tmp [ rand ( 1 , tmp ) ] ;
111680: LD_ADDR_VAR 0 3
111684: PUSH
111685: LD_VAR 0 2
111689: PUSH
111690: LD_INT 1
111692: PPUSH
111693: LD_VAR 0 2
111697: PPUSH
111698: CALL_OW 12
111702: ARRAY
111703: ST_TO_ADDR
// if Crawls ( un ) then
111704: LD_VAR 0 3
111708: PPUSH
111709: CALL_OW 318
111713: IFFALSE 111724
// ComWalk ( un ) ;
111715: LD_VAR 0 3
111719: PPUSH
111720: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111724: LD_VAR 0 3
111728: PPUSH
111729: LD_INT 8
111731: PPUSH
111732: CALL_OW 336
// end ; 4 :
111736: GO 111829
111738: LD_INT 4
111740: DOUBLE
111741: EQUAL
111742: IFTRUE 111746
111744: GO 111807
111746: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111747: LD_ADDR_VAR 0 2
111751: PUSH
111752: LD_INT 22
111754: PUSH
111755: LD_OWVAR 2
111759: PUSH
111760: EMPTY
111761: LIST
111762: LIST
111763: PUSH
111764: LD_INT 30
111766: PUSH
111767: LD_INT 29
111769: PUSH
111770: EMPTY
111771: LIST
111772: LIST
111773: PUSH
111774: EMPTY
111775: LIST
111776: LIST
111777: PPUSH
111778: CALL_OW 69
111782: ST_TO_ADDR
// if not tmp then
111783: LD_VAR 0 2
111787: NOT
111788: IFFALSE 111792
// exit ;
111790: GO 111829
// DestroyUnit ( tmp [ 1 ] ) ;
111792: LD_VAR 0 2
111796: PUSH
111797: LD_INT 1
111799: ARRAY
111800: PPUSH
111801: CALL_OW 65
// end ; 5 .. 7 :
111805: GO 111829
111807: LD_INT 5
111809: DOUBLE
111810: GREATEREQUAL
111811: IFFALSE 111819
111813: LD_INT 7
111815: DOUBLE
111816: LESSEQUAL
111817: IFTRUE 111821
111819: GO 111828
111821: POP
// StreamSibBomb ; end ;
111822: CALL 108079 0 0
111826: GO 111829
111828: POP
// end ;
111829: PPOPN 3
111831: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111832: LD_EXP 153
111836: PUSH
111837: LD_EXP 203
111841: AND
111842: IFFALSE 111998
111844: GO 111846
111846: DISABLE
111847: LD_INT 0
111849: PPUSH
111850: PPUSH
111851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111852: LD_ADDR_VAR 0 2
111856: PUSH
111857: LD_INT 81
111859: PUSH
111860: LD_OWVAR 2
111864: PUSH
111865: EMPTY
111866: LIST
111867: LIST
111868: PUSH
111869: LD_INT 2
111871: PUSH
111872: LD_INT 21
111874: PUSH
111875: LD_INT 1
111877: PUSH
111878: EMPTY
111879: LIST
111880: LIST
111881: PUSH
111882: LD_INT 21
111884: PUSH
111885: LD_INT 2
111887: PUSH
111888: EMPTY
111889: LIST
111890: LIST
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: LIST
111896: PUSH
111897: EMPTY
111898: LIST
111899: LIST
111900: PPUSH
111901: CALL_OW 69
111905: ST_TO_ADDR
// if not tmp then
111906: LD_VAR 0 2
111910: NOT
111911: IFFALSE 111915
// exit ;
111913: GO 111998
// p := 0 ;
111915: LD_ADDR_VAR 0 3
111919: PUSH
111920: LD_INT 0
111922: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111923: LD_INT 35
111925: PPUSH
111926: CALL_OW 67
// p := p + 1 ;
111930: LD_ADDR_VAR 0 3
111934: PUSH
111935: LD_VAR 0 3
111939: PUSH
111940: LD_INT 1
111942: PLUS
111943: ST_TO_ADDR
// for i in tmp do
111944: LD_ADDR_VAR 0 1
111948: PUSH
111949: LD_VAR 0 2
111953: PUSH
111954: FOR_IN
111955: IFFALSE 111986
// if GetLives ( i ) < 1000 then
111957: LD_VAR 0 1
111961: PPUSH
111962: CALL_OW 256
111966: PUSH
111967: LD_INT 1000
111969: LESS
111970: IFFALSE 111984
// SetLives ( i , 1000 ) ;
111972: LD_VAR 0 1
111976: PPUSH
111977: LD_INT 1000
111979: PPUSH
111980: CALL_OW 234
111984: GO 111954
111986: POP
111987: POP
// until p > 20 ;
111988: LD_VAR 0 3
111992: PUSH
111993: LD_INT 20
111995: GREATER
111996: IFFALSE 111923
// end ;
111998: PPOPN 3
112000: END
// every 0 0$1 trigger StreamModeActive and sTime do
112001: LD_EXP 153
112005: PUSH
112006: LD_EXP 204
112010: AND
112011: IFFALSE 112046
112013: GO 112015
112015: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
112016: LD_INT 28
112018: PPUSH
112019: LD_OWVAR 2
112023: PPUSH
112024: LD_INT 2
112026: PPUSH
112027: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
112031: LD_INT 30
112033: PPUSH
112034: LD_OWVAR 2
112038: PPUSH
112039: LD_INT 2
112041: PPUSH
112042: CALL_OW 322
// end ;
112046: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
112047: LD_EXP 153
112051: PUSH
112052: LD_EXP 205
112056: AND
112057: IFFALSE 112178
112059: GO 112061
112061: DISABLE
112062: LD_INT 0
112064: PPUSH
112065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112066: LD_ADDR_VAR 0 2
112070: PUSH
112071: LD_INT 22
112073: PUSH
112074: LD_OWVAR 2
112078: PUSH
112079: EMPTY
112080: LIST
112081: LIST
112082: PUSH
112083: LD_INT 21
112085: PUSH
112086: LD_INT 1
112088: PUSH
112089: EMPTY
112090: LIST
112091: LIST
112092: PUSH
112093: LD_INT 3
112095: PUSH
112096: LD_INT 23
112098: PUSH
112099: LD_INT 0
112101: PUSH
112102: EMPTY
112103: LIST
112104: LIST
112105: PUSH
112106: EMPTY
112107: LIST
112108: LIST
112109: PUSH
112110: EMPTY
112111: LIST
112112: LIST
112113: LIST
112114: PPUSH
112115: CALL_OW 69
112119: ST_TO_ADDR
// if not tmp then
112120: LD_VAR 0 2
112124: NOT
112125: IFFALSE 112129
// exit ;
112127: GO 112178
// for i in tmp do
112129: LD_ADDR_VAR 0 1
112133: PUSH
112134: LD_VAR 0 2
112138: PUSH
112139: FOR_IN
112140: IFFALSE 112176
// begin if Crawls ( i ) then
112142: LD_VAR 0 1
112146: PPUSH
112147: CALL_OW 318
112151: IFFALSE 112162
// ComWalk ( i ) ;
112153: LD_VAR 0 1
112157: PPUSH
112158: CALL_OW 138
// SetClass ( i , 2 ) ;
112162: LD_VAR 0 1
112166: PPUSH
112167: LD_INT 2
112169: PPUSH
112170: CALL_OW 336
// end ;
112174: GO 112139
112176: POP
112177: POP
// end ;
112178: PPOPN 2
112180: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
112181: LD_EXP 153
112185: PUSH
112186: LD_EXP 206
112190: AND
112191: IFFALSE 112472
112193: GO 112195
112195: DISABLE
112196: LD_INT 0
112198: PPUSH
112199: PPUSH
112200: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
112201: LD_OWVAR 2
112205: PPUSH
112206: LD_INT 9
112208: PPUSH
112209: LD_INT 1
112211: PPUSH
112212: LD_INT 1
112214: PPUSH
112215: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
112219: LD_INT 9
112221: PPUSH
112222: LD_OWVAR 2
112226: PPUSH
112227: CALL_OW 343
// uc_side := 9 ;
112231: LD_ADDR_OWVAR 20
112235: PUSH
112236: LD_INT 9
112238: ST_TO_ADDR
// uc_nation := 2 ;
112239: LD_ADDR_OWVAR 21
112243: PUSH
112244: LD_INT 2
112246: ST_TO_ADDR
// hc_name := Dark Warrior ;
112247: LD_ADDR_OWVAR 26
112251: PUSH
112252: LD_STRING Dark Warrior
112254: ST_TO_ADDR
// hc_gallery :=  ;
112255: LD_ADDR_OWVAR 33
112259: PUSH
112260: LD_STRING 
112262: ST_TO_ADDR
// hc_noskilllimit := true ;
112263: LD_ADDR_OWVAR 76
112267: PUSH
112268: LD_INT 1
112270: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
112271: LD_ADDR_OWVAR 31
112275: PUSH
112276: LD_INT 30
112278: PUSH
112279: LD_INT 30
112281: PUSH
112282: LD_INT 30
112284: PUSH
112285: LD_INT 30
112287: PUSH
112288: EMPTY
112289: LIST
112290: LIST
112291: LIST
112292: LIST
112293: ST_TO_ADDR
// un := CreateHuman ;
112294: LD_ADDR_VAR 0 3
112298: PUSH
112299: CALL_OW 44
112303: ST_TO_ADDR
// hc_noskilllimit := false ;
112304: LD_ADDR_OWVAR 76
112308: PUSH
112309: LD_INT 0
112311: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112312: LD_VAR 0 3
112316: PPUSH
112317: LD_INT 1
112319: PPUSH
112320: CALL_OW 51
// p := 0 ;
112324: LD_ADDR_VAR 0 2
112328: PUSH
112329: LD_INT 0
112331: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112332: LD_INT 35
112334: PPUSH
112335: CALL_OW 67
// p := p + 1 ;
112339: LD_ADDR_VAR 0 2
112343: PUSH
112344: LD_VAR 0 2
112348: PUSH
112349: LD_INT 1
112351: PLUS
112352: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112353: LD_VAR 0 3
112357: PPUSH
112358: CALL_OW 256
112362: PUSH
112363: LD_INT 1000
112365: LESS
112366: IFFALSE 112380
// SetLives ( un , 1000 ) ;
112368: LD_VAR 0 3
112372: PPUSH
112373: LD_INT 1000
112375: PPUSH
112376: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112380: LD_VAR 0 3
112384: PPUSH
112385: LD_INT 81
112387: PUSH
112388: LD_OWVAR 2
112392: PUSH
112393: EMPTY
112394: LIST
112395: LIST
112396: PUSH
112397: LD_INT 91
112399: PUSH
112400: LD_VAR 0 3
112404: PUSH
112405: LD_INT 30
112407: PUSH
112408: EMPTY
112409: LIST
112410: LIST
112411: LIST
112412: PUSH
112413: EMPTY
112414: LIST
112415: LIST
112416: PPUSH
112417: CALL_OW 69
112421: PPUSH
112422: LD_VAR 0 3
112426: PPUSH
112427: CALL_OW 74
112431: PPUSH
112432: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
112436: LD_VAR 0 2
112440: PUSH
112441: LD_INT 60
112443: GREATER
112444: PUSH
112445: LD_VAR 0 3
112449: PPUSH
112450: CALL_OW 301
112454: OR
112455: IFFALSE 112332
// if un then
112457: LD_VAR 0 3
112461: IFFALSE 112472
// RemoveUnit ( un ) ;
112463: LD_VAR 0 3
112467: PPUSH
112468: CALL_OW 64
// end ; end_of_file
112472: PPOPN 3
112474: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112475: LD_INT 0
112477: PPUSH
112478: PPUSH
112479: PPUSH
112480: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112481: LD_VAR 0 1
112485: PPUSH
112486: CALL_OW 264
112490: PUSH
112491: LD_EXP 99
112495: EQUAL
112496: IFFALSE 112568
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112498: LD_INT 68
112500: PPUSH
112501: LD_VAR 0 1
112505: PPUSH
112506: CALL_OW 255
112510: PPUSH
112511: CALL_OW 321
112515: PUSH
112516: LD_INT 2
112518: EQUAL
112519: IFFALSE 112531
// eff := 70 else
112521: LD_ADDR_VAR 0 4
112525: PUSH
112526: LD_INT 70
112528: ST_TO_ADDR
112529: GO 112539
// eff := 30 ;
112531: LD_ADDR_VAR 0 4
112535: PUSH
112536: LD_INT 30
112538: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112539: LD_VAR 0 1
112543: PPUSH
112544: CALL_OW 250
112548: PPUSH
112549: LD_VAR 0 1
112553: PPUSH
112554: CALL_OW 251
112558: PPUSH
112559: LD_VAR 0 4
112563: PPUSH
112564: CALL_OW 495
// end ; end ;
112568: LD_VAR 0 2
112572: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112573: LD_INT 0
112575: PPUSH
// end ;
112576: LD_VAR 0 4
112580: RET
// export function SOS_Command ( cmd ) ; begin
112581: LD_INT 0
112583: PPUSH
// end ;
112584: LD_VAR 0 2
112588: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112589: LD_VAR 0 1
112593: PUSH
112594: LD_INT 255
112596: EQUAL
112597: PUSH
112598: LD_VAR 0 2
112602: PPUSH
112603: CALL_OW 264
112607: PUSH
112608: LD_INT 14
112610: PUSH
112611: LD_INT 53
112613: PUSH
112614: EMPTY
112615: LIST
112616: LIST
112617: IN
112618: AND
112619: PUSH
112620: LD_VAR 0 4
112624: PPUSH
112625: LD_VAR 0 5
112629: PPUSH
112630: CALL_OW 488
112634: AND
112635: IFFALSE 112659
// CutTreeXYR ( unit , x , y , 12 ) ;
112637: LD_VAR 0 2
112641: PPUSH
112642: LD_VAR 0 4
112646: PPUSH
112647: LD_VAR 0 5
112651: PPUSH
112652: LD_INT 12
112654: PPUSH
112655: CALL 112662 0 4
// end ;
112659: PPOPN 5
112661: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112662: LD_INT 0
112664: PPUSH
112665: PPUSH
112666: PPUSH
112667: PPUSH
112668: PPUSH
112669: PPUSH
112670: PPUSH
112671: PPUSH
112672: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
112673: LD_VAR 0 1
112677: NOT
112678: PUSH
112679: LD_VAR 0 2
112683: PPUSH
112684: LD_VAR 0 3
112688: PPUSH
112689: CALL_OW 488
112693: NOT
112694: OR
112695: PUSH
112696: LD_VAR 0 4
112700: NOT
112701: OR
112702: IFFALSE 112706
// exit ;
112704: GO 113046
// list := [ ] ;
112706: LD_ADDR_VAR 0 13
112710: PUSH
112711: EMPTY
112712: ST_TO_ADDR
// if x - r < 0 then
112713: LD_VAR 0 2
112717: PUSH
112718: LD_VAR 0 4
112722: MINUS
112723: PUSH
112724: LD_INT 0
112726: LESS
112727: IFFALSE 112739
// min_x := 0 else
112729: LD_ADDR_VAR 0 7
112733: PUSH
112734: LD_INT 0
112736: ST_TO_ADDR
112737: GO 112755
// min_x := x - r ;
112739: LD_ADDR_VAR 0 7
112743: PUSH
112744: LD_VAR 0 2
112748: PUSH
112749: LD_VAR 0 4
112753: MINUS
112754: ST_TO_ADDR
// if y - r < 0 then
112755: LD_VAR 0 3
112759: PUSH
112760: LD_VAR 0 4
112764: MINUS
112765: PUSH
112766: LD_INT 0
112768: LESS
112769: IFFALSE 112781
// min_y := 0 else
112771: LD_ADDR_VAR 0 8
112775: PUSH
112776: LD_INT 0
112778: ST_TO_ADDR
112779: GO 112797
// min_y := y - r ;
112781: LD_ADDR_VAR 0 8
112785: PUSH
112786: LD_VAR 0 3
112790: PUSH
112791: LD_VAR 0 4
112795: MINUS
112796: ST_TO_ADDR
// max_x := x + r ;
112797: LD_ADDR_VAR 0 9
112801: PUSH
112802: LD_VAR 0 2
112806: PUSH
112807: LD_VAR 0 4
112811: PLUS
112812: ST_TO_ADDR
// max_y := y + r ;
112813: LD_ADDR_VAR 0 10
112817: PUSH
112818: LD_VAR 0 3
112822: PUSH
112823: LD_VAR 0 4
112827: PLUS
112828: ST_TO_ADDR
// for _x = min_x to max_x do
112829: LD_ADDR_VAR 0 11
112833: PUSH
112834: DOUBLE
112835: LD_VAR 0 7
112839: DEC
112840: ST_TO_ADDR
112841: LD_VAR 0 9
112845: PUSH
112846: FOR_TO
112847: IFFALSE 112964
// for _y = min_y to max_y do
112849: LD_ADDR_VAR 0 12
112853: PUSH
112854: DOUBLE
112855: LD_VAR 0 8
112859: DEC
112860: ST_TO_ADDR
112861: LD_VAR 0 10
112865: PUSH
112866: FOR_TO
112867: IFFALSE 112960
// begin if not ValidHex ( _x , _y ) then
112869: LD_VAR 0 11
112873: PPUSH
112874: LD_VAR 0 12
112878: PPUSH
112879: CALL_OW 488
112883: NOT
112884: IFFALSE 112888
// continue ;
112886: GO 112866
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112888: LD_VAR 0 11
112892: PPUSH
112893: LD_VAR 0 12
112897: PPUSH
112898: CALL_OW 351
112902: PUSH
112903: LD_VAR 0 11
112907: PPUSH
112908: LD_VAR 0 12
112912: PPUSH
112913: CALL_OW 554
112917: AND
112918: IFFALSE 112958
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112920: LD_ADDR_VAR 0 13
112924: PUSH
112925: LD_VAR 0 13
112929: PPUSH
112930: LD_VAR 0 13
112934: PUSH
112935: LD_INT 1
112937: PLUS
112938: PPUSH
112939: LD_VAR 0 11
112943: PUSH
112944: LD_VAR 0 12
112948: PUSH
112949: EMPTY
112950: LIST
112951: LIST
112952: PPUSH
112953: CALL_OW 2
112957: ST_TO_ADDR
// end ;
112958: GO 112866
112960: POP
112961: POP
112962: GO 112846
112964: POP
112965: POP
// if not list then
112966: LD_VAR 0 13
112970: NOT
112971: IFFALSE 112975
// exit ;
112973: GO 113046
// for i in list do
112975: LD_ADDR_VAR 0 6
112979: PUSH
112980: LD_VAR 0 13
112984: PUSH
112985: FOR_IN
112986: IFFALSE 113044
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
112988: LD_VAR 0 1
112992: PPUSH
112993: LD_STRING M
112995: PUSH
112996: LD_VAR 0 6
113000: PUSH
113001: LD_INT 1
113003: ARRAY
113004: PUSH
113005: LD_VAR 0 6
113009: PUSH
113010: LD_INT 2
113012: ARRAY
113013: PUSH
113014: LD_INT 0
113016: PUSH
113017: LD_INT 0
113019: PUSH
113020: LD_INT 0
113022: PUSH
113023: LD_INT 0
113025: PUSH
113026: EMPTY
113027: LIST
113028: LIST
113029: LIST
113030: LIST
113031: LIST
113032: LIST
113033: LIST
113034: PUSH
113035: EMPTY
113036: LIST
113037: PPUSH
113038: CALL_OW 447
113042: GO 112985
113044: POP
113045: POP
// end ; end_of_file
113046: LD_VAR 0 5
113050: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113051: LD_INT 0
113053: PPUSH
113054: PPUSH
113055: PPUSH
113056: PPUSH
113057: PPUSH
113058: PPUSH
113059: PPUSH
113060: PPUSH
113061: PPUSH
113062: PPUSH
113063: PPUSH
113064: PPUSH
113065: PPUSH
113066: PPUSH
113067: PPUSH
113068: PPUSH
113069: PPUSH
113070: PPUSH
113071: PPUSH
113072: PPUSH
113073: PPUSH
113074: PPUSH
113075: PPUSH
113076: PPUSH
113077: PPUSH
113078: PPUSH
113079: PPUSH
113080: PPUSH
113081: PPUSH
113082: PPUSH
113083: PPUSH
113084: PPUSH
113085: PPUSH
113086: PPUSH
// if not list then
113087: LD_VAR 0 1
113091: NOT
113092: IFFALSE 113096
// exit ;
113094: GO 117755
// base := list [ 1 ] ;
113096: LD_ADDR_VAR 0 3
113100: PUSH
113101: LD_VAR 0 1
113105: PUSH
113106: LD_INT 1
113108: ARRAY
113109: ST_TO_ADDR
// group := list [ 2 ] ;
113110: LD_ADDR_VAR 0 4
113114: PUSH
113115: LD_VAR 0 1
113119: PUSH
113120: LD_INT 2
113122: ARRAY
113123: ST_TO_ADDR
// path := list [ 3 ] ;
113124: LD_ADDR_VAR 0 5
113128: PUSH
113129: LD_VAR 0 1
113133: PUSH
113134: LD_INT 3
113136: ARRAY
113137: ST_TO_ADDR
// flags := list [ 4 ] ;
113138: LD_ADDR_VAR 0 6
113142: PUSH
113143: LD_VAR 0 1
113147: PUSH
113148: LD_INT 4
113150: ARRAY
113151: ST_TO_ADDR
// mined := [ ] ;
113152: LD_ADDR_VAR 0 27
113156: PUSH
113157: EMPTY
113158: ST_TO_ADDR
// bombed := [ ] ;
113159: LD_ADDR_VAR 0 28
113163: PUSH
113164: EMPTY
113165: ST_TO_ADDR
// healers := [ ] ;
113166: LD_ADDR_VAR 0 31
113170: PUSH
113171: EMPTY
113172: ST_TO_ADDR
// to_heal := [ ] ;
113173: LD_ADDR_VAR 0 30
113177: PUSH
113178: EMPTY
113179: ST_TO_ADDR
// repairs := [ ] ;
113180: LD_ADDR_VAR 0 33
113184: PUSH
113185: EMPTY
113186: ST_TO_ADDR
// to_repair := [ ] ;
113187: LD_ADDR_VAR 0 32
113191: PUSH
113192: EMPTY
113193: ST_TO_ADDR
// if not group or not path then
113194: LD_VAR 0 4
113198: NOT
113199: PUSH
113200: LD_VAR 0 5
113204: NOT
113205: OR
113206: IFFALSE 113210
// exit ;
113208: GO 117755
// side := GetSide ( group [ 1 ] ) ;
113210: LD_ADDR_VAR 0 35
113214: PUSH
113215: LD_VAR 0 4
113219: PUSH
113220: LD_INT 1
113222: ARRAY
113223: PPUSH
113224: CALL_OW 255
113228: ST_TO_ADDR
// if flags then
113229: LD_VAR 0 6
113233: IFFALSE 113377
// begin f_ignore_area := flags [ 1 ] ;
113235: LD_ADDR_VAR 0 17
113239: PUSH
113240: LD_VAR 0 6
113244: PUSH
113245: LD_INT 1
113247: ARRAY
113248: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113249: LD_ADDR_VAR 0 18
113253: PUSH
113254: LD_VAR 0 6
113258: PUSH
113259: LD_INT 2
113261: ARRAY
113262: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113263: LD_ADDR_VAR 0 19
113267: PUSH
113268: LD_VAR 0 6
113272: PUSH
113273: LD_INT 3
113275: ARRAY
113276: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113277: LD_ADDR_VAR 0 20
113281: PUSH
113282: LD_VAR 0 6
113286: PUSH
113287: LD_INT 4
113289: ARRAY
113290: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113291: LD_ADDR_VAR 0 21
113295: PUSH
113296: LD_VAR 0 6
113300: PUSH
113301: LD_INT 5
113303: ARRAY
113304: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113305: LD_ADDR_VAR 0 22
113309: PUSH
113310: LD_VAR 0 6
113314: PUSH
113315: LD_INT 6
113317: ARRAY
113318: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113319: LD_ADDR_VAR 0 23
113323: PUSH
113324: LD_VAR 0 6
113328: PUSH
113329: LD_INT 7
113331: ARRAY
113332: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113333: LD_ADDR_VAR 0 24
113337: PUSH
113338: LD_VAR 0 6
113342: PUSH
113343: LD_INT 8
113345: ARRAY
113346: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113347: LD_ADDR_VAR 0 25
113351: PUSH
113352: LD_VAR 0 6
113356: PUSH
113357: LD_INT 9
113359: ARRAY
113360: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113361: LD_ADDR_VAR 0 26
113365: PUSH
113366: LD_VAR 0 6
113370: PUSH
113371: LD_INT 10
113373: ARRAY
113374: ST_TO_ADDR
// end else
113375: GO 113457
// begin f_ignore_area := false ;
113377: LD_ADDR_VAR 0 17
113381: PUSH
113382: LD_INT 0
113384: ST_TO_ADDR
// f_capture := false ;
113385: LD_ADDR_VAR 0 18
113389: PUSH
113390: LD_INT 0
113392: ST_TO_ADDR
// f_ignore_civ := false ;
113393: LD_ADDR_VAR 0 19
113397: PUSH
113398: LD_INT 0
113400: ST_TO_ADDR
// f_murder := false ;
113401: LD_ADDR_VAR 0 20
113405: PUSH
113406: LD_INT 0
113408: ST_TO_ADDR
// f_mines := false ;
113409: LD_ADDR_VAR 0 21
113413: PUSH
113414: LD_INT 0
113416: ST_TO_ADDR
// f_repair := false ;
113417: LD_ADDR_VAR 0 22
113421: PUSH
113422: LD_INT 0
113424: ST_TO_ADDR
// f_heal := false ;
113425: LD_ADDR_VAR 0 23
113429: PUSH
113430: LD_INT 0
113432: ST_TO_ADDR
// f_spacetime := false ;
113433: LD_ADDR_VAR 0 24
113437: PUSH
113438: LD_INT 0
113440: ST_TO_ADDR
// f_attack_depot := false ;
113441: LD_ADDR_VAR 0 25
113445: PUSH
113446: LD_INT 0
113448: ST_TO_ADDR
// f_crawl := false ;
113449: LD_ADDR_VAR 0 26
113453: PUSH
113454: LD_INT 0
113456: ST_TO_ADDR
// end ; if f_heal then
113457: LD_VAR 0 23
113461: IFFALSE 113488
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113463: LD_ADDR_VAR 0 31
113467: PUSH
113468: LD_VAR 0 4
113472: PPUSH
113473: LD_INT 25
113475: PUSH
113476: LD_INT 4
113478: PUSH
113479: EMPTY
113480: LIST
113481: LIST
113482: PPUSH
113483: CALL_OW 72
113487: ST_TO_ADDR
// if f_repair then
113488: LD_VAR 0 22
113492: IFFALSE 113519
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113494: LD_ADDR_VAR 0 33
113498: PUSH
113499: LD_VAR 0 4
113503: PPUSH
113504: LD_INT 25
113506: PUSH
113507: LD_INT 3
113509: PUSH
113510: EMPTY
113511: LIST
113512: LIST
113513: PPUSH
113514: CALL_OW 72
113518: ST_TO_ADDR
// units_path := [ ] ;
113519: LD_ADDR_VAR 0 16
113523: PUSH
113524: EMPTY
113525: ST_TO_ADDR
// for i = 1 to group do
113526: LD_ADDR_VAR 0 7
113530: PUSH
113531: DOUBLE
113532: LD_INT 1
113534: DEC
113535: ST_TO_ADDR
113536: LD_VAR 0 4
113540: PUSH
113541: FOR_TO
113542: IFFALSE 113571
// units_path := Replace ( units_path , i , path ) ;
113544: LD_ADDR_VAR 0 16
113548: PUSH
113549: LD_VAR 0 16
113553: PPUSH
113554: LD_VAR 0 7
113558: PPUSH
113559: LD_VAR 0 5
113563: PPUSH
113564: CALL_OW 1
113568: ST_TO_ADDR
113569: GO 113541
113571: POP
113572: POP
// repeat for i = group downto 1 do
113573: LD_ADDR_VAR 0 7
113577: PUSH
113578: DOUBLE
113579: LD_VAR 0 4
113583: INC
113584: ST_TO_ADDR
113585: LD_INT 1
113587: PUSH
113588: FOR_DOWNTO
113589: IFFALSE 117711
// begin wait ( 5 ) ;
113591: LD_INT 5
113593: PPUSH
113594: CALL_OW 67
// tmp := [ ] ;
113598: LD_ADDR_VAR 0 14
113602: PUSH
113603: EMPTY
113604: ST_TO_ADDR
// attacking := false ;
113605: LD_ADDR_VAR 0 29
113609: PUSH
113610: LD_INT 0
113612: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113613: LD_VAR 0 4
113617: PUSH
113618: LD_VAR 0 7
113622: ARRAY
113623: PPUSH
113624: CALL_OW 301
113628: PUSH
113629: LD_VAR 0 4
113633: PUSH
113634: LD_VAR 0 7
113638: ARRAY
113639: NOT
113640: OR
113641: IFFALSE 113750
// begin if GetType ( group [ i ] ) = unit_human then
113643: LD_VAR 0 4
113647: PUSH
113648: LD_VAR 0 7
113652: ARRAY
113653: PPUSH
113654: CALL_OW 247
113658: PUSH
113659: LD_INT 1
113661: EQUAL
113662: IFFALSE 113708
// begin to_heal := to_heal diff group [ i ] ;
113664: LD_ADDR_VAR 0 30
113668: PUSH
113669: LD_VAR 0 30
113673: PUSH
113674: LD_VAR 0 4
113678: PUSH
113679: LD_VAR 0 7
113683: ARRAY
113684: DIFF
113685: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113686: LD_ADDR_VAR 0 31
113690: PUSH
113691: LD_VAR 0 31
113695: PUSH
113696: LD_VAR 0 4
113700: PUSH
113701: LD_VAR 0 7
113705: ARRAY
113706: DIFF
113707: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113708: LD_ADDR_VAR 0 4
113712: PUSH
113713: LD_VAR 0 4
113717: PPUSH
113718: LD_VAR 0 7
113722: PPUSH
113723: CALL_OW 3
113727: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113728: LD_ADDR_VAR 0 16
113732: PUSH
113733: LD_VAR 0 16
113737: PPUSH
113738: LD_VAR 0 7
113742: PPUSH
113743: CALL_OW 3
113747: ST_TO_ADDR
// continue ;
113748: GO 113588
// end ; if f_repair then
113750: LD_VAR 0 22
113754: IFFALSE 114243
// begin if GetType ( group [ i ] ) = unit_vehicle then
113756: LD_VAR 0 4
113760: PUSH
113761: LD_VAR 0 7
113765: ARRAY
113766: PPUSH
113767: CALL_OW 247
113771: PUSH
113772: LD_INT 2
113774: EQUAL
113775: IFFALSE 113965
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113777: LD_VAR 0 4
113781: PUSH
113782: LD_VAR 0 7
113786: ARRAY
113787: PPUSH
113788: CALL_OW 256
113792: PUSH
113793: LD_INT 700
113795: LESS
113796: PUSH
113797: LD_VAR 0 4
113801: PUSH
113802: LD_VAR 0 7
113806: ARRAY
113807: PUSH
113808: LD_VAR 0 32
113812: IN
113813: NOT
113814: AND
113815: IFFALSE 113839
// to_repair := to_repair union group [ i ] ;
113817: LD_ADDR_VAR 0 32
113821: PUSH
113822: LD_VAR 0 32
113826: PUSH
113827: LD_VAR 0 4
113831: PUSH
113832: LD_VAR 0 7
113836: ARRAY
113837: UNION
113838: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113839: LD_VAR 0 4
113843: PUSH
113844: LD_VAR 0 7
113848: ARRAY
113849: PPUSH
113850: CALL_OW 256
113854: PUSH
113855: LD_INT 1000
113857: EQUAL
113858: PUSH
113859: LD_VAR 0 4
113863: PUSH
113864: LD_VAR 0 7
113868: ARRAY
113869: PUSH
113870: LD_VAR 0 32
113874: IN
113875: AND
113876: IFFALSE 113900
// to_repair := to_repair diff group [ i ] ;
113878: LD_ADDR_VAR 0 32
113882: PUSH
113883: LD_VAR 0 32
113887: PUSH
113888: LD_VAR 0 4
113892: PUSH
113893: LD_VAR 0 7
113897: ARRAY
113898: DIFF
113899: ST_TO_ADDR
// if group [ i ] in to_repair then
113900: LD_VAR 0 4
113904: PUSH
113905: LD_VAR 0 7
113909: ARRAY
113910: PUSH
113911: LD_VAR 0 32
113915: IN
113916: IFFALSE 113963
// begin if not IsInArea ( group [ i ] , f_repair ) then
113918: LD_VAR 0 4
113922: PUSH
113923: LD_VAR 0 7
113927: ARRAY
113928: PPUSH
113929: LD_VAR 0 22
113933: PPUSH
113934: CALL_OW 308
113938: NOT
113939: IFFALSE 113961
// ComMoveToArea ( group [ i ] , f_repair ) ;
113941: LD_VAR 0 4
113945: PUSH
113946: LD_VAR 0 7
113950: ARRAY
113951: PPUSH
113952: LD_VAR 0 22
113956: PPUSH
113957: CALL_OW 113
// continue ;
113961: GO 113588
// end ; end else
113963: GO 114243
// if group [ i ] in repairs then
113965: LD_VAR 0 4
113969: PUSH
113970: LD_VAR 0 7
113974: ARRAY
113975: PUSH
113976: LD_VAR 0 33
113980: IN
113981: IFFALSE 114243
// begin if IsInUnit ( group [ i ] ) then
113983: LD_VAR 0 4
113987: PUSH
113988: LD_VAR 0 7
113992: ARRAY
113993: PPUSH
113994: CALL_OW 310
113998: IFFALSE 114066
// begin z := IsInUnit ( group [ i ] ) ;
114000: LD_ADDR_VAR 0 13
114004: PUSH
114005: LD_VAR 0 4
114009: PUSH
114010: LD_VAR 0 7
114014: ARRAY
114015: PPUSH
114016: CALL_OW 310
114020: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114021: LD_VAR 0 13
114025: PUSH
114026: LD_VAR 0 32
114030: IN
114031: PUSH
114032: LD_VAR 0 13
114036: PPUSH
114037: LD_VAR 0 22
114041: PPUSH
114042: CALL_OW 308
114046: AND
114047: IFFALSE 114064
// ComExitVehicle ( group [ i ] ) ;
114049: LD_VAR 0 4
114053: PUSH
114054: LD_VAR 0 7
114058: ARRAY
114059: PPUSH
114060: CALL_OW 121
// end else
114064: GO 114243
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114066: LD_ADDR_VAR 0 13
114070: PUSH
114071: LD_VAR 0 4
114075: PPUSH
114076: LD_INT 95
114078: PUSH
114079: LD_VAR 0 22
114083: PUSH
114084: EMPTY
114085: LIST
114086: LIST
114087: PUSH
114088: LD_INT 58
114090: PUSH
114091: EMPTY
114092: LIST
114093: PUSH
114094: EMPTY
114095: LIST
114096: LIST
114097: PPUSH
114098: CALL_OW 72
114102: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114103: LD_VAR 0 4
114107: PUSH
114108: LD_VAR 0 7
114112: ARRAY
114113: PPUSH
114114: CALL_OW 314
114118: NOT
114119: IFFALSE 114241
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114121: LD_ADDR_VAR 0 10
114125: PUSH
114126: LD_VAR 0 13
114130: PPUSH
114131: LD_VAR 0 4
114135: PUSH
114136: LD_VAR 0 7
114140: ARRAY
114141: PPUSH
114142: CALL_OW 74
114146: ST_TO_ADDR
// if not x then
114147: LD_VAR 0 10
114151: NOT
114152: IFFALSE 114156
// continue ;
114154: GO 113588
// if GetLives ( x ) < 1000 then
114156: LD_VAR 0 10
114160: PPUSH
114161: CALL_OW 256
114165: PUSH
114166: LD_INT 1000
114168: LESS
114169: IFFALSE 114193
// ComRepairVehicle ( group [ i ] , x ) else
114171: LD_VAR 0 4
114175: PUSH
114176: LD_VAR 0 7
114180: ARRAY
114181: PPUSH
114182: LD_VAR 0 10
114186: PPUSH
114187: CALL_OW 129
114191: GO 114241
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114193: LD_VAR 0 23
114197: PUSH
114198: LD_VAR 0 4
114202: PUSH
114203: LD_VAR 0 7
114207: ARRAY
114208: PPUSH
114209: CALL_OW 256
114213: PUSH
114214: LD_INT 1000
114216: LESS
114217: AND
114218: NOT
114219: IFFALSE 114241
// ComEnterUnit ( group [ i ] , x ) ;
114221: LD_VAR 0 4
114225: PUSH
114226: LD_VAR 0 7
114230: ARRAY
114231: PPUSH
114232: LD_VAR 0 10
114236: PPUSH
114237: CALL_OW 120
// end ; continue ;
114241: GO 113588
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114243: LD_VAR 0 23
114247: PUSH
114248: LD_VAR 0 4
114252: PUSH
114253: LD_VAR 0 7
114257: ARRAY
114258: PPUSH
114259: CALL_OW 247
114263: PUSH
114264: LD_INT 1
114266: EQUAL
114267: AND
114268: IFFALSE 114746
// begin if group [ i ] in healers then
114270: LD_VAR 0 4
114274: PUSH
114275: LD_VAR 0 7
114279: ARRAY
114280: PUSH
114281: LD_VAR 0 31
114285: IN
114286: IFFALSE 114559
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114288: LD_VAR 0 4
114292: PUSH
114293: LD_VAR 0 7
114297: ARRAY
114298: PPUSH
114299: LD_VAR 0 23
114303: PPUSH
114304: CALL_OW 308
114308: NOT
114309: PUSH
114310: LD_VAR 0 4
114314: PUSH
114315: LD_VAR 0 7
114319: ARRAY
114320: PPUSH
114321: CALL_OW 314
114325: NOT
114326: AND
114327: IFFALSE 114351
// ComMoveToArea ( group [ i ] , f_heal ) else
114329: LD_VAR 0 4
114333: PUSH
114334: LD_VAR 0 7
114338: ARRAY
114339: PPUSH
114340: LD_VAR 0 23
114344: PPUSH
114345: CALL_OW 113
114349: GO 114557
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114351: LD_VAR 0 4
114355: PUSH
114356: LD_VAR 0 7
114360: ARRAY
114361: PPUSH
114362: CALL 98394 0 1
114366: PPUSH
114367: CALL_OW 256
114371: PUSH
114372: LD_INT 1000
114374: EQUAL
114375: IFFALSE 114394
// ComStop ( group [ i ] ) else
114377: LD_VAR 0 4
114381: PUSH
114382: LD_VAR 0 7
114386: ARRAY
114387: PPUSH
114388: CALL_OW 141
114392: GO 114557
// if not HasTask ( group [ i ] ) and to_heal then
114394: LD_VAR 0 4
114398: PUSH
114399: LD_VAR 0 7
114403: ARRAY
114404: PPUSH
114405: CALL_OW 314
114409: NOT
114410: PUSH
114411: LD_VAR 0 30
114415: AND
114416: IFFALSE 114557
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114418: LD_ADDR_VAR 0 13
114422: PUSH
114423: LD_VAR 0 30
114427: PPUSH
114428: LD_INT 3
114430: PUSH
114431: LD_INT 54
114433: PUSH
114434: EMPTY
114435: LIST
114436: PUSH
114437: EMPTY
114438: LIST
114439: LIST
114440: PPUSH
114441: CALL_OW 72
114445: PPUSH
114446: LD_VAR 0 4
114450: PUSH
114451: LD_VAR 0 7
114455: ARRAY
114456: PPUSH
114457: CALL_OW 74
114461: ST_TO_ADDR
// if z then
114462: LD_VAR 0 13
114466: IFFALSE 114557
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114468: LD_INT 91
114470: PUSH
114471: LD_VAR 0 13
114475: PUSH
114476: LD_INT 10
114478: PUSH
114479: EMPTY
114480: LIST
114481: LIST
114482: LIST
114483: PUSH
114484: LD_INT 81
114486: PUSH
114487: LD_VAR 0 13
114491: PPUSH
114492: CALL_OW 255
114496: PUSH
114497: EMPTY
114498: LIST
114499: LIST
114500: PUSH
114501: EMPTY
114502: LIST
114503: LIST
114504: PPUSH
114505: CALL_OW 69
114509: PUSH
114510: LD_INT 0
114512: EQUAL
114513: IFFALSE 114537
// ComHeal ( group [ i ] , z ) else
114515: LD_VAR 0 4
114519: PUSH
114520: LD_VAR 0 7
114524: ARRAY
114525: PPUSH
114526: LD_VAR 0 13
114530: PPUSH
114531: CALL_OW 128
114535: GO 114557
// ComMoveToArea ( group [ i ] , f_heal ) ;
114537: LD_VAR 0 4
114541: PUSH
114542: LD_VAR 0 7
114546: ARRAY
114547: PPUSH
114548: LD_VAR 0 23
114552: PPUSH
114553: CALL_OW 113
// end ; continue ;
114557: GO 113588
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114559: LD_VAR 0 4
114563: PUSH
114564: LD_VAR 0 7
114568: ARRAY
114569: PPUSH
114570: CALL_OW 256
114574: PUSH
114575: LD_INT 700
114577: LESS
114578: PUSH
114579: LD_VAR 0 4
114583: PUSH
114584: LD_VAR 0 7
114588: ARRAY
114589: PUSH
114590: LD_VAR 0 30
114594: IN
114595: NOT
114596: AND
114597: IFFALSE 114621
// to_heal := to_heal union group [ i ] ;
114599: LD_ADDR_VAR 0 30
114603: PUSH
114604: LD_VAR 0 30
114608: PUSH
114609: LD_VAR 0 4
114613: PUSH
114614: LD_VAR 0 7
114618: ARRAY
114619: UNION
114620: ST_TO_ADDR
// if group [ i ] in to_heal then
114621: LD_VAR 0 4
114625: PUSH
114626: LD_VAR 0 7
114630: ARRAY
114631: PUSH
114632: LD_VAR 0 30
114636: IN
114637: IFFALSE 114746
// begin if GetLives ( group [ i ] ) = 1000 then
114639: LD_VAR 0 4
114643: PUSH
114644: LD_VAR 0 7
114648: ARRAY
114649: PPUSH
114650: CALL_OW 256
114654: PUSH
114655: LD_INT 1000
114657: EQUAL
114658: IFFALSE 114684
// to_heal := to_heal diff group [ i ] else
114660: LD_ADDR_VAR 0 30
114664: PUSH
114665: LD_VAR 0 30
114669: PUSH
114670: LD_VAR 0 4
114674: PUSH
114675: LD_VAR 0 7
114679: ARRAY
114680: DIFF
114681: ST_TO_ADDR
114682: GO 114746
// begin if not IsInArea ( group [ i ] , to_heal ) then
114684: LD_VAR 0 4
114688: PUSH
114689: LD_VAR 0 7
114693: ARRAY
114694: PPUSH
114695: LD_VAR 0 30
114699: PPUSH
114700: CALL_OW 308
114704: NOT
114705: IFFALSE 114729
// ComMoveToArea ( group [ i ] , f_heal ) else
114707: LD_VAR 0 4
114711: PUSH
114712: LD_VAR 0 7
114716: ARRAY
114717: PPUSH
114718: LD_VAR 0 23
114722: PPUSH
114723: CALL_OW 113
114727: GO 114744
// ComHold ( group [ i ] ) ;
114729: LD_VAR 0 4
114733: PUSH
114734: LD_VAR 0 7
114738: ARRAY
114739: PPUSH
114740: CALL_OW 140
// continue ;
114744: GO 113588
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114746: LD_VAR 0 4
114750: PUSH
114751: LD_VAR 0 7
114755: ARRAY
114756: PPUSH
114757: LD_INT 10
114759: PPUSH
114760: CALL 96814 0 2
114764: NOT
114765: PUSH
114766: LD_VAR 0 16
114770: PUSH
114771: LD_VAR 0 7
114775: ARRAY
114776: PUSH
114777: EMPTY
114778: EQUAL
114779: NOT
114780: AND
114781: IFFALSE 115047
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114783: LD_VAR 0 4
114787: PUSH
114788: LD_VAR 0 7
114792: ARRAY
114793: PPUSH
114794: CALL_OW 262
114798: PUSH
114799: LD_INT 1
114801: PUSH
114802: LD_INT 2
114804: PUSH
114805: EMPTY
114806: LIST
114807: LIST
114808: IN
114809: IFFALSE 114850
// if GetFuel ( group [ i ] ) < 10 then
114811: LD_VAR 0 4
114815: PUSH
114816: LD_VAR 0 7
114820: ARRAY
114821: PPUSH
114822: CALL_OW 261
114826: PUSH
114827: LD_INT 10
114829: LESS
114830: IFFALSE 114850
// SetFuel ( group [ i ] , 12 ) ;
114832: LD_VAR 0 4
114836: PUSH
114837: LD_VAR 0 7
114841: ARRAY
114842: PPUSH
114843: LD_INT 12
114845: PPUSH
114846: CALL_OW 240
// if units_path [ i ] then
114850: LD_VAR 0 16
114854: PUSH
114855: LD_VAR 0 7
114859: ARRAY
114860: IFFALSE 115045
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114862: LD_VAR 0 4
114866: PUSH
114867: LD_VAR 0 7
114871: ARRAY
114872: PPUSH
114873: LD_VAR 0 16
114877: PUSH
114878: LD_VAR 0 7
114882: ARRAY
114883: PUSH
114884: LD_INT 1
114886: ARRAY
114887: PUSH
114888: LD_INT 1
114890: ARRAY
114891: PPUSH
114892: LD_VAR 0 16
114896: PUSH
114897: LD_VAR 0 7
114901: ARRAY
114902: PUSH
114903: LD_INT 1
114905: ARRAY
114906: PUSH
114907: LD_INT 2
114909: ARRAY
114910: PPUSH
114911: CALL_OW 297
114915: PUSH
114916: LD_INT 6
114918: GREATER
114919: IFFALSE 114994
// begin if not HasTask ( group [ i ] ) then
114921: LD_VAR 0 4
114925: PUSH
114926: LD_VAR 0 7
114930: ARRAY
114931: PPUSH
114932: CALL_OW 314
114936: NOT
114937: IFFALSE 114992
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114939: LD_VAR 0 4
114943: PUSH
114944: LD_VAR 0 7
114948: ARRAY
114949: PPUSH
114950: LD_VAR 0 16
114954: PUSH
114955: LD_VAR 0 7
114959: ARRAY
114960: PUSH
114961: LD_INT 1
114963: ARRAY
114964: PUSH
114965: LD_INT 1
114967: ARRAY
114968: PPUSH
114969: LD_VAR 0 16
114973: PUSH
114974: LD_VAR 0 7
114978: ARRAY
114979: PUSH
114980: LD_INT 1
114982: ARRAY
114983: PUSH
114984: LD_INT 2
114986: ARRAY
114987: PPUSH
114988: CALL_OW 114
// end else
114992: GO 115045
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114994: LD_ADDR_VAR 0 15
114998: PUSH
114999: LD_VAR 0 16
115003: PUSH
115004: LD_VAR 0 7
115008: ARRAY
115009: PPUSH
115010: LD_INT 1
115012: PPUSH
115013: CALL_OW 3
115017: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115018: LD_ADDR_VAR 0 16
115022: PUSH
115023: LD_VAR 0 16
115027: PPUSH
115028: LD_VAR 0 7
115032: PPUSH
115033: LD_VAR 0 15
115037: PPUSH
115038: CALL_OW 1
115042: ST_TO_ADDR
// continue ;
115043: GO 113588
// end ; end ; end else
115045: GO 117709
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115047: LD_ADDR_VAR 0 14
115051: PUSH
115052: LD_INT 81
115054: PUSH
115055: LD_VAR 0 4
115059: PUSH
115060: LD_VAR 0 7
115064: ARRAY
115065: PPUSH
115066: CALL_OW 255
115070: PUSH
115071: EMPTY
115072: LIST
115073: LIST
115074: PPUSH
115075: CALL_OW 69
115079: ST_TO_ADDR
// if not tmp then
115080: LD_VAR 0 14
115084: NOT
115085: IFFALSE 115089
// continue ;
115087: GO 113588
// if f_ignore_area then
115089: LD_VAR 0 17
115093: IFFALSE 115181
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115095: LD_ADDR_VAR 0 15
115099: PUSH
115100: LD_VAR 0 14
115104: PPUSH
115105: LD_INT 3
115107: PUSH
115108: LD_INT 92
115110: PUSH
115111: LD_VAR 0 17
115115: PUSH
115116: LD_INT 1
115118: ARRAY
115119: PUSH
115120: LD_VAR 0 17
115124: PUSH
115125: LD_INT 2
115127: ARRAY
115128: PUSH
115129: LD_VAR 0 17
115133: PUSH
115134: LD_INT 3
115136: ARRAY
115137: PUSH
115138: EMPTY
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: PUSH
115144: EMPTY
115145: LIST
115146: LIST
115147: PPUSH
115148: CALL_OW 72
115152: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115153: LD_VAR 0 14
115157: PUSH
115158: LD_VAR 0 15
115162: DIFF
115163: IFFALSE 115181
// tmp := tmp diff tmp2 ;
115165: LD_ADDR_VAR 0 14
115169: PUSH
115170: LD_VAR 0 14
115174: PUSH
115175: LD_VAR 0 15
115179: DIFF
115180: ST_TO_ADDR
// end ; if not f_murder then
115181: LD_VAR 0 20
115185: NOT
115186: IFFALSE 115244
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115188: LD_ADDR_VAR 0 15
115192: PUSH
115193: LD_VAR 0 14
115197: PPUSH
115198: LD_INT 3
115200: PUSH
115201: LD_INT 50
115203: PUSH
115204: EMPTY
115205: LIST
115206: PUSH
115207: EMPTY
115208: LIST
115209: LIST
115210: PPUSH
115211: CALL_OW 72
115215: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115216: LD_VAR 0 14
115220: PUSH
115221: LD_VAR 0 15
115225: DIFF
115226: IFFALSE 115244
// tmp := tmp diff tmp2 ;
115228: LD_ADDR_VAR 0 14
115232: PUSH
115233: LD_VAR 0 14
115237: PUSH
115238: LD_VAR 0 15
115242: DIFF
115243: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115244: LD_ADDR_VAR 0 14
115248: PUSH
115249: LD_VAR 0 4
115253: PUSH
115254: LD_VAR 0 7
115258: ARRAY
115259: PPUSH
115260: LD_VAR 0 14
115264: PPUSH
115265: LD_INT 1
115267: PPUSH
115268: LD_INT 1
115270: PPUSH
115271: CALL 70457 0 4
115275: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115276: LD_VAR 0 4
115280: PUSH
115281: LD_VAR 0 7
115285: ARRAY
115286: PPUSH
115287: CALL_OW 257
115291: PUSH
115292: LD_INT 1
115294: EQUAL
115295: IFFALSE 115743
// begin if WantPlant ( group [ i ] ) then
115297: LD_VAR 0 4
115301: PUSH
115302: LD_VAR 0 7
115306: ARRAY
115307: PPUSH
115308: CALL 69958 0 1
115312: IFFALSE 115316
// continue ;
115314: GO 113588
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115316: LD_VAR 0 18
115320: PUSH
115321: LD_VAR 0 4
115325: PUSH
115326: LD_VAR 0 7
115330: ARRAY
115331: PPUSH
115332: CALL_OW 310
115336: NOT
115337: AND
115338: PUSH
115339: LD_VAR 0 14
115343: PUSH
115344: LD_INT 1
115346: ARRAY
115347: PUSH
115348: LD_VAR 0 14
115352: PPUSH
115353: LD_INT 21
115355: PUSH
115356: LD_INT 2
115358: PUSH
115359: EMPTY
115360: LIST
115361: LIST
115362: PUSH
115363: LD_INT 58
115365: PUSH
115366: EMPTY
115367: LIST
115368: PUSH
115369: EMPTY
115370: LIST
115371: LIST
115372: PPUSH
115373: CALL_OW 72
115377: IN
115378: AND
115379: IFFALSE 115415
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115381: LD_VAR 0 4
115385: PUSH
115386: LD_VAR 0 7
115390: ARRAY
115391: PPUSH
115392: LD_VAR 0 14
115396: PUSH
115397: LD_INT 1
115399: ARRAY
115400: PPUSH
115401: CALL_OW 120
// attacking := true ;
115405: LD_ADDR_VAR 0 29
115409: PUSH
115410: LD_INT 1
115412: ST_TO_ADDR
// continue ;
115413: GO 113588
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115415: LD_VAR 0 26
115419: PUSH
115420: LD_VAR 0 4
115424: PUSH
115425: LD_VAR 0 7
115429: ARRAY
115430: PPUSH
115431: CALL_OW 257
115435: PUSH
115436: LD_INT 1
115438: EQUAL
115439: AND
115440: PUSH
115441: LD_VAR 0 4
115445: PUSH
115446: LD_VAR 0 7
115450: ARRAY
115451: PPUSH
115452: CALL_OW 256
115456: PUSH
115457: LD_INT 800
115459: LESS
115460: AND
115461: PUSH
115462: LD_VAR 0 4
115466: PUSH
115467: LD_VAR 0 7
115471: ARRAY
115472: PPUSH
115473: CALL_OW 318
115477: NOT
115478: AND
115479: IFFALSE 115496
// ComCrawl ( group [ i ] ) ;
115481: LD_VAR 0 4
115485: PUSH
115486: LD_VAR 0 7
115490: ARRAY
115491: PPUSH
115492: CALL_OW 137
// if f_mines then
115496: LD_VAR 0 21
115500: IFFALSE 115743
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115502: LD_VAR 0 14
115506: PUSH
115507: LD_INT 1
115509: ARRAY
115510: PPUSH
115511: CALL_OW 247
115515: PUSH
115516: LD_INT 3
115518: EQUAL
115519: PUSH
115520: LD_VAR 0 14
115524: PUSH
115525: LD_INT 1
115527: ARRAY
115528: PUSH
115529: LD_VAR 0 27
115533: IN
115534: NOT
115535: AND
115536: IFFALSE 115743
// begin x := GetX ( tmp [ 1 ] ) ;
115538: LD_ADDR_VAR 0 10
115542: PUSH
115543: LD_VAR 0 14
115547: PUSH
115548: LD_INT 1
115550: ARRAY
115551: PPUSH
115552: CALL_OW 250
115556: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115557: LD_ADDR_VAR 0 11
115561: PUSH
115562: LD_VAR 0 14
115566: PUSH
115567: LD_INT 1
115569: ARRAY
115570: PPUSH
115571: CALL_OW 251
115575: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115576: LD_ADDR_VAR 0 12
115580: PUSH
115581: LD_VAR 0 4
115585: PUSH
115586: LD_VAR 0 7
115590: ARRAY
115591: PPUSH
115592: CALL 96899 0 1
115596: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115597: LD_VAR 0 4
115601: PUSH
115602: LD_VAR 0 7
115606: ARRAY
115607: PPUSH
115608: LD_VAR 0 10
115612: PPUSH
115613: LD_VAR 0 11
115617: PPUSH
115618: LD_VAR 0 14
115622: PUSH
115623: LD_INT 1
115625: ARRAY
115626: PPUSH
115627: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115631: LD_VAR 0 4
115635: PUSH
115636: LD_VAR 0 7
115640: ARRAY
115641: PPUSH
115642: LD_VAR 0 10
115646: PPUSH
115647: LD_VAR 0 12
115651: PPUSH
115652: LD_INT 7
115654: PPUSH
115655: CALL_OW 272
115659: PPUSH
115660: LD_VAR 0 11
115664: PPUSH
115665: LD_VAR 0 12
115669: PPUSH
115670: LD_INT 7
115672: PPUSH
115673: CALL_OW 273
115677: PPUSH
115678: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115682: LD_VAR 0 4
115686: PUSH
115687: LD_VAR 0 7
115691: ARRAY
115692: PPUSH
115693: LD_INT 71
115695: PPUSH
115696: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115700: LD_ADDR_VAR 0 27
115704: PUSH
115705: LD_VAR 0 27
115709: PPUSH
115710: LD_VAR 0 27
115714: PUSH
115715: LD_INT 1
115717: PLUS
115718: PPUSH
115719: LD_VAR 0 14
115723: PUSH
115724: LD_INT 1
115726: ARRAY
115727: PPUSH
115728: CALL_OW 1
115732: ST_TO_ADDR
// attacking := true ;
115733: LD_ADDR_VAR 0 29
115737: PUSH
115738: LD_INT 1
115740: ST_TO_ADDR
// continue ;
115741: GO 113588
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115743: LD_VAR 0 4
115747: PUSH
115748: LD_VAR 0 7
115752: ARRAY
115753: PPUSH
115754: CALL_OW 257
115758: PUSH
115759: LD_INT 17
115761: EQUAL
115762: PUSH
115763: LD_VAR 0 4
115767: PUSH
115768: LD_VAR 0 7
115772: ARRAY
115773: PPUSH
115774: CALL_OW 110
115778: PUSH
115779: LD_INT 71
115781: EQUAL
115782: NOT
115783: AND
115784: IFFALSE 115930
// begin attacking := false ;
115786: LD_ADDR_VAR 0 29
115790: PUSH
115791: LD_INT 0
115793: ST_TO_ADDR
// k := 5 ;
115794: LD_ADDR_VAR 0 9
115798: PUSH
115799: LD_INT 5
115801: ST_TO_ADDR
// if tmp < k then
115802: LD_VAR 0 14
115806: PUSH
115807: LD_VAR 0 9
115811: LESS
115812: IFFALSE 115824
// k := tmp ;
115814: LD_ADDR_VAR 0 9
115818: PUSH
115819: LD_VAR 0 14
115823: ST_TO_ADDR
// for j = 1 to k do
115824: LD_ADDR_VAR 0 8
115828: PUSH
115829: DOUBLE
115830: LD_INT 1
115832: DEC
115833: ST_TO_ADDR
115834: LD_VAR 0 9
115838: PUSH
115839: FOR_TO
115840: IFFALSE 115928
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115842: LD_VAR 0 14
115846: PUSH
115847: LD_VAR 0 8
115851: ARRAY
115852: PUSH
115853: LD_VAR 0 14
115857: PPUSH
115858: LD_INT 58
115860: PUSH
115861: EMPTY
115862: LIST
115863: PPUSH
115864: CALL_OW 72
115868: IN
115869: NOT
115870: IFFALSE 115926
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115872: LD_VAR 0 4
115876: PUSH
115877: LD_VAR 0 7
115881: ARRAY
115882: PPUSH
115883: LD_VAR 0 14
115887: PUSH
115888: LD_VAR 0 8
115892: ARRAY
115893: PPUSH
115894: CALL_OW 115
// attacking := true ;
115898: LD_ADDR_VAR 0 29
115902: PUSH
115903: LD_INT 1
115905: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115906: LD_VAR 0 4
115910: PUSH
115911: LD_VAR 0 7
115915: ARRAY
115916: PPUSH
115917: LD_INT 71
115919: PPUSH
115920: CALL_OW 109
// continue ;
115924: GO 115839
// end ; end ;
115926: GO 115839
115928: POP
115929: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115930: LD_VAR 0 4
115934: PUSH
115935: LD_VAR 0 7
115939: ARRAY
115940: PPUSH
115941: CALL_OW 257
115945: PUSH
115946: LD_INT 8
115948: EQUAL
115949: PUSH
115950: LD_VAR 0 4
115954: PUSH
115955: LD_VAR 0 7
115959: ARRAY
115960: PPUSH
115961: CALL_OW 264
115965: PUSH
115966: LD_INT 28
115968: PUSH
115969: LD_INT 45
115971: PUSH
115972: LD_INT 7
115974: PUSH
115975: LD_INT 47
115977: PUSH
115978: EMPTY
115979: LIST
115980: LIST
115981: LIST
115982: LIST
115983: IN
115984: OR
115985: IFFALSE 116241
// begin attacking := false ;
115987: LD_ADDR_VAR 0 29
115991: PUSH
115992: LD_INT 0
115994: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115995: LD_VAR 0 14
115999: PUSH
116000: LD_INT 1
116002: ARRAY
116003: PPUSH
116004: CALL_OW 266
116008: PUSH
116009: LD_INT 32
116011: PUSH
116012: LD_INT 31
116014: PUSH
116015: LD_INT 33
116017: PUSH
116018: LD_INT 4
116020: PUSH
116021: LD_INT 5
116023: PUSH
116024: EMPTY
116025: LIST
116026: LIST
116027: LIST
116028: LIST
116029: LIST
116030: IN
116031: IFFALSE 116217
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116033: LD_ADDR_VAR 0 9
116037: PUSH
116038: LD_VAR 0 14
116042: PUSH
116043: LD_INT 1
116045: ARRAY
116046: PPUSH
116047: CALL_OW 266
116051: PPUSH
116052: LD_VAR 0 14
116056: PUSH
116057: LD_INT 1
116059: ARRAY
116060: PPUSH
116061: CALL_OW 250
116065: PPUSH
116066: LD_VAR 0 14
116070: PUSH
116071: LD_INT 1
116073: ARRAY
116074: PPUSH
116075: CALL_OW 251
116079: PPUSH
116080: LD_VAR 0 14
116084: PUSH
116085: LD_INT 1
116087: ARRAY
116088: PPUSH
116089: CALL_OW 254
116093: PPUSH
116094: LD_VAR 0 14
116098: PUSH
116099: LD_INT 1
116101: ARRAY
116102: PPUSH
116103: CALL_OW 248
116107: PPUSH
116108: LD_INT 0
116110: PPUSH
116111: CALL 78269 0 6
116115: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116116: LD_ADDR_VAR 0 8
116120: PUSH
116121: LD_VAR 0 4
116125: PUSH
116126: LD_VAR 0 7
116130: ARRAY
116131: PPUSH
116132: LD_VAR 0 9
116136: PPUSH
116137: CALL 96939 0 2
116141: ST_TO_ADDR
// if j then
116142: LD_VAR 0 8
116146: IFFALSE 116215
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116148: LD_VAR 0 8
116152: PUSH
116153: LD_INT 1
116155: ARRAY
116156: PPUSH
116157: LD_VAR 0 8
116161: PUSH
116162: LD_INT 2
116164: ARRAY
116165: PPUSH
116166: CALL_OW 488
116170: IFFALSE 116215
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116172: LD_VAR 0 4
116176: PUSH
116177: LD_VAR 0 7
116181: ARRAY
116182: PPUSH
116183: LD_VAR 0 8
116187: PUSH
116188: LD_INT 1
116190: ARRAY
116191: PPUSH
116192: LD_VAR 0 8
116196: PUSH
116197: LD_INT 2
116199: ARRAY
116200: PPUSH
116201: CALL_OW 116
// attacking := true ;
116205: LD_ADDR_VAR 0 29
116209: PUSH
116210: LD_INT 1
116212: ST_TO_ADDR
// continue ;
116213: GO 113588
// end ; end else
116215: GO 116241
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116217: LD_VAR 0 4
116221: PUSH
116222: LD_VAR 0 7
116226: ARRAY
116227: PPUSH
116228: LD_VAR 0 14
116232: PUSH
116233: LD_INT 1
116235: ARRAY
116236: PPUSH
116237: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116241: LD_VAR 0 4
116245: PUSH
116246: LD_VAR 0 7
116250: ARRAY
116251: PPUSH
116252: CALL_OW 265
116256: PUSH
116257: LD_INT 11
116259: EQUAL
116260: IFFALSE 116538
// begin k := 10 ;
116262: LD_ADDR_VAR 0 9
116266: PUSH
116267: LD_INT 10
116269: ST_TO_ADDR
// x := 0 ;
116270: LD_ADDR_VAR 0 10
116274: PUSH
116275: LD_INT 0
116277: ST_TO_ADDR
// if tmp < k then
116278: LD_VAR 0 14
116282: PUSH
116283: LD_VAR 0 9
116287: LESS
116288: IFFALSE 116300
// k := tmp ;
116290: LD_ADDR_VAR 0 9
116294: PUSH
116295: LD_VAR 0 14
116299: ST_TO_ADDR
// for j = k downto 1 do
116300: LD_ADDR_VAR 0 8
116304: PUSH
116305: DOUBLE
116306: LD_VAR 0 9
116310: INC
116311: ST_TO_ADDR
116312: LD_INT 1
116314: PUSH
116315: FOR_DOWNTO
116316: IFFALSE 116391
// begin if GetType ( tmp [ j ] ) = unit_human then
116318: LD_VAR 0 14
116322: PUSH
116323: LD_VAR 0 8
116327: ARRAY
116328: PPUSH
116329: CALL_OW 247
116333: PUSH
116334: LD_INT 1
116336: EQUAL
116337: IFFALSE 116389
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116339: LD_VAR 0 4
116343: PUSH
116344: LD_VAR 0 7
116348: ARRAY
116349: PPUSH
116350: LD_VAR 0 14
116354: PUSH
116355: LD_VAR 0 8
116359: ARRAY
116360: PPUSH
116361: CALL 97210 0 2
// x := tmp [ j ] ;
116365: LD_ADDR_VAR 0 10
116369: PUSH
116370: LD_VAR 0 14
116374: PUSH
116375: LD_VAR 0 8
116379: ARRAY
116380: ST_TO_ADDR
// attacking := true ;
116381: LD_ADDR_VAR 0 29
116385: PUSH
116386: LD_INT 1
116388: ST_TO_ADDR
// end ; end ;
116389: GO 116315
116391: POP
116392: POP
// if not x then
116393: LD_VAR 0 10
116397: NOT
116398: IFFALSE 116538
// begin attacking := true ;
116400: LD_ADDR_VAR 0 29
116404: PUSH
116405: LD_INT 1
116407: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116408: LD_VAR 0 4
116412: PUSH
116413: LD_VAR 0 7
116417: ARRAY
116418: PPUSH
116419: CALL_OW 250
116423: PPUSH
116424: LD_VAR 0 4
116428: PUSH
116429: LD_VAR 0 7
116433: ARRAY
116434: PPUSH
116435: CALL_OW 251
116439: PPUSH
116440: CALL_OW 546
116444: PUSH
116445: LD_INT 2
116447: ARRAY
116448: PUSH
116449: LD_VAR 0 14
116453: PUSH
116454: LD_INT 1
116456: ARRAY
116457: PPUSH
116458: CALL_OW 250
116462: PPUSH
116463: LD_VAR 0 14
116467: PUSH
116468: LD_INT 1
116470: ARRAY
116471: PPUSH
116472: CALL_OW 251
116476: PPUSH
116477: CALL_OW 546
116481: PUSH
116482: LD_INT 2
116484: ARRAY
116485: EQUAL
116486: IFFALSE 116514
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116488: LD_VAR 0 4
116492: PUSH
116493: LD_VAR 0 7
116497: ARRAY
116498: PPUSH
116499: LD_VAR 0 14
116503: PUSH
116504: LD_INT 1
116506: ARRAY
116507: PPUSH
116508: CALL 97210 0 2
116512: GO 116538
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116514: LD_VAR 0 4
116518: PUSH
116519: LD_VAR 0 7
116523: ARRAY
116524: PPUSH
116525: LD_VAR 0 14
116529: PUSH
116530: LD_INT 1
116532: ARRAY
116533: PPUSH
116534: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116538: LD_VAR 0 4
116542: PUSH
116543: LD_VAR 0 7
116547: ARRAY
116548: PPUSH
116549: CALL_OW 264
116553: PUSH
116554: LD_INT 29
116556: EQUAL
116557: IFFALSE 116923
// begin if WantsToAttack ( group [ i ] ) in bombed then
116559: LD_VAR 0 4
116563: PUSH
116564: LD_VAR 0 7
116568: ARRAY
116569: PPUSH
116570: CALL_OW 319
116574: PUSH
116575: LD_VAR 0 28
116579: IN
116580: IFFALSE 116584
// continue ;
116582: GO 113588
// k := 8 ;
116584: LD_ADDR_VAR 0 9
116588: PUSH
116589: LD_INT 8
116591: ST_TO_ADDR
// x := 0 ;
116592: LD_ADDR_VAR 0 10
116596: PUSH
116597: LD_INT 0
116599: ST_TO_ADDR
// if tmp < k then
116600: LD_VAR 0 14
116604: PUSH
116605: LD_VAR 0 9
116609: LESS
116610: IFFALSE 116622
// k := tmp ;
116612: LD_ADDR_VAR 0 9
116616: PUSH
116617: LD_VAR 0 14
116621: ST_TO_ADDR
// for j = 1 to k do
116622: LD_ADDR_VAR 0 8
116626: PUSH
116627: DOUBLE
116628: LD_INT 1
116630: DEC
116631: ST_TO_ADDR
116632: LD_VAR 0 9
116636: PUSH
116637: FOR_TO
116638: IFFALSE 116770
// begin if GetType ( tmp [ j ] ) = unit_building then
116640: LD_VAR 0 14
116644: PUSH
116645: LD_VAR 0 8
116649: ARRAY
116650: PPUSH
116651: CALL_OW 247
116655: PUSH
116656: LD_INT 3
116658: EQUAL
116659: IFFALSE 116768
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116661: LD_VAR 0 14
116665: PUSH
116666: LD_VAR 0 8
116670: ARRAY
116671: PUSH
116672: LD_VAR 0 28
116676: IN
116677: NOT
116678: PUSH
116679: LD_VAR 0 14
116683: PUSH
116684: LD_VAR 0 8
116688: ARRAY
116689: PPUSH
116690: CALL_OW 313
116694: AND
116695: IFFALSE 116768
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116697: LD_VAR 0 4
116701: PUSH
116702: LD_VAR 0 7
116706: ARRAY
116707: PPUSH
116708: LD_VAR 0 14
116712: PUSH
116713: LD_VAR 0 8
116717: ARRAY
116718: PPUSH
116719: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116723: LD_ADDR_VAR 0 28
116727: PUSH
116728: LD_VAR 0 28
116732: PPUSH
116733: LD_VAR 0 28
116737: PUSH
116738: LD_INT 1
116740: PLUS
116741: PPUSH
116742: LD_VAR 0 14
116746: PUSH
116747: LD_VAR 0 8
116751: ARRAY
116752: PPUSH
116753: CALL_OW 1
116757: ST_TO_ADDR
// attacking := true ;
116758: LD_ADDR_VAR 0 29
116762: PUSH
116763: LD_INT 1
116765: ST_TO_ADDR
// break ;
116766: GO 116770
// end ; end ;
116768: GO 116637
116770: POP
116771: POP
// if not attacking and f_attack_depot then
116772: LD_VAR 0 29
116776: NOT
116777: PUSH
116778: LD_VAR 0 25
116782: AND
116783: IFFALSE 116878
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116785: LD_ADDR_VAR 0 13
116789: PUSH
116790: LD_VAR 0 14
116794: PPUSH
116795: LD_INT 2
116797: PUSH
116798: LD_INT 30
116800: PUSH
116801: LD_INT 0
116803: PUSH
116804: EMPTY
116805: LIST
116806: LIST
116807: PUSH
116808: LD_INT 30
116810: PUSH
116811: LD_INT 1
116813: PUSH
116814: EMPTY
116815: LIST
116816: LIST
116817: PUSH
116818: EMPTY
116819: LIST
116820: LIST
116821: LIST
116822: PPUSH
116823: CALL_OW 72
116827: ST_TO_ADDR
// if z then
116828: LD_VAR 0 13
116832: IFFALSE 116878
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116834: LD_VAR 0 4
116838: PUSH
116839: LD_VAR 0 7
116843: ARRAY
116844: PPUSH
116845: LD_VAR 0 13
116849: PPUSH
116850: LD_VAR 0 4
116854: PUSH
116855: LD_VAR 0 7
116859: ARRAY
116860: PPUSH
116861: CALL_OW 74
116865: PPUSH
116866: CALL_OW 115
// attacking := true ;
116870: LD_ADDR_VAR 0 29
116874: PUSH
116875: LD_INT 1
116877: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116878: LD_VAR 0 4
116882: PUSH
116883: LD_VAR 0 7
116887: ARRAY
116888: PPUSH
116889: CALL_OW 256
116893: PUSH
116894: LD_INT 500
116896: LESS
116897: IFFALSE 116923
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116899: LD_VAR 0 4
116903: PUSH
116904: LD_VAR 0 7
116908: ARRAY
116909: PPUSH
116910: LD_VAR 0 14
116914: PUSH
116915: LD_INT 1
116917: ARRAY
116918: PPUSH
116919: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116923: LD_VAR 0 4
116927: PUSH
116928: LD_VAR 0 7
116932: ARRAY
116933: PPUSH
116934: CALL_OW 264
116938: PUSH
116939: LD_INT 49
116941: EQUAL
116942: IFFALSE 117063
// begin if not HasTask ( group [ i ] ) then
116944: LD_VAR 0 4
116948: PUSH
116949: LD_VAR 0 7
116953: ARRAY
116954: PPUSH
116955: CALL_OW 314
116959: NOT
116960: IFFALSE 117063
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116962: LD_ADDR_VAR 0 9
116966: PUSH
116967: LD_INT 81
116969: PUSH
116970: LD_VAR 0 4
116974: PUSH
116975: LD_VAR 0 7
116979: ARRAY
116980: PPUSH
116981: CALL_OW 255
116985: PUSH
116986: EMPTY
116987: LIST
116988: LIST
116989: PPUSH
116990: CALL_OW 69
116994: PPUSH
116995: LD_VAR 0 4
116999: PUSH
117000: LD_VAR 0 7
117004: ARRAY
117005: PPUSH
117006: CALL_OW 74
117010: ST_TO_ADDR
// if k then
117011: LD_VAR 0 9
117015: IFFALSE 117063
// if GetDistUnits ( group [ i ] , k ) > 10 then
117017: LD_VAR 0 4
117021: PUSH
117022: LD_VAR 0 7
117026: ARRAY
117027: PPUSH
117028: LD_VAR 0 9
117032: PPUSH
117033: CALL_OW 296
117037: PUSH
117038: LD_INT 10
117040: GREATER
117041: IFFALSE 117063
// ComMoveUnit ( group [ i ] , k ) ;
117043: LD_VAR 0 4
117047: PUSH
117048: LD_VAR 0 7
117052: ARRAY
117053: PPUSH
117054: LD_VAR 0 9
117058: PPUSH
117059: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117063: LD_VAR 0 4
117067: PUSH
117068: LD_VAR 0 7
117072: ARRAY
117073: PPUSH
117074: CALL_OW 256
117078: PUSH
117079: LD_INT 250
117081: LESS
117082: PUSH
117083: LD_VAR 0 4
117087: PUSH
117088: LD_VAR 0 7
117092: ARRAY
117093: PUSH
117094: LD_INT 21
117096: PUSH
117097: LD_INT 2
117099: PUSH
117100: EMPTY
117101: LIST
117102: LIST
117103: PUSH
117104: LD_INT 23
117106: PUSH
117107: LD_INT 2
117109: PUSH
117110: EMPTY
117111: LIST
117112: LIST
117113: PUSH
117114: EMPTY
117115: LIST
117116: LIST
117117: PPUSH
117118: CALL_OW 69
117122: IN
117123: AND
117124: IFFALSE 117249
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117126: LD_ADDR_VAR 0 9
117130: PUSH
117131: LD_OWVAR 3
117135: PUSH
117136: LD_VAR 0 4
117140: PUSH
117141: LD_VAR 0 7
117145: ARRAY
117146: DIFF
117147: PPUSH
117148: LD_VAR 0 4
117152: PUSH
117153: LD_VAR 0 7
117157: ARRAY
117158: PPUSH
117159: CALL_OW 74
117163: ST_TO_ADDR
// if not k then
117164: LD_VAR 0 9
117168: NOT
117169: IFFALSE 117173
// continue ;
117171: GO 113588
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117173: LD_VAR 0 9
117177: PUSH
117178: LD_INT 81
117180: PUSH
117181: LD_VAR 0 4
117185: PUSH
117186: LD_VAR 0 7
117190: ARRAY
117191: PPUSH
117192: CALL_OW 255
117196: PUSH
117197: EMPTY
117198: LIST
117199: LIST
117200: PPUSH
117201: CALL_OW 69
117205: IN
117206: PUSH
117207: LD_VAR 0 9
117211: PPUSH
117212: LD_VAR 0 4
117216: PUSH
117217: LD_VAR 0 7
117221: ARRAY
117222: PPUSH
117223: CALL_OW 296
117227: PUSH
117228: LD_INT 5
117230: LESS
117231: AND
117232: IFFALSE 117249
// ComAutodestruct ( group [ i ] ) ;
117234: LD_VAR 0 4
117238: PUSH
117239: LD_VAR 0 7
117243: ARRAY
117244: PPUSH
117245: CALL 97108 0 1
// end ; if f_attack_depot then
117249: LD_VAR 0 25
117253: IFFALSE 117365
// begin k := 6 ;
117255: LD_ADDR_VAR 0 9
117259: PUSH
117260: LD_INT 6
117262: ST_TO_ADDR
// if tmp < k then
117263: LD_VAR 0 14
117267: PUSH
117268: LD_VAR 0 9
117272: LESS
117273: IFFALSE 117285
// k := tmp ;
117275: LD_ADDR_VAR 0 9
117279: PUSH
117280: LD_VAR 0 14
117284: ST_TO_ADDR
// for j = 1 to k do
117285: LD_ADDR_VAR 0 8
117289: PUSH
117290: DOUBLE
117291: LD_INT 1
117293: DEC
117294: ST_TO_ADDR
117295: LD_VAR 0 9
117299: PUSH
117300: FOR_TO
117301: IFFALSE 117363
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117303: LD_VAR 0 8
117307: PPUSH
117308: CALL_OW 266
117312: PUSH
117313: LD_INT 0
117315: PUSH
117316: LD_INT 1
117318: PUSH
117319: EMPTY
117320: LIST
117321: LIST
117322: IN
117323: IFFALSE 117361
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117325: LD_VAR 0 4
117329: PUSH
117330: LD_VAR 0 7
117334: ARRAY
117335: PPUSH
117336: LD_VAR 0 14
117340: PUSH
117341: LD_VAR 0 8
117345: ARRAY
117346: PPUSH
117347: CALL_OW 115
// attacking := true ;
117351: LD_ADDR_VAR 0 29
117355: PUSH
117356: LD_INT 1
117358: ST_TO_ADDR
// break ;
117359: GO 117363
// end ;
117361: GO 117300
117363: POP
117364: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117365: LD_VAR 0 4
117369: PUSH
117370: LD_VAR 0 7
117374: ARRAY
117375: PPUSH
117376: CALL_OW 302
117380: PUSH
117381: LD_VAR 0 29
117385: NOT
117386: AND
117387: IFFALSE 117709
// begin if GetTag ( group [ i ] ) = 71 then
117389: LD_VAR 0 4
117393: PUSH
117394: LD_VAR 0 7
117398: ARRAY
117399: PPUSH
117400: CALL_OW 110
117404: PUSH
117405: LD_INT 71
117407: EQUAL
117408: IFFALSE 117449
// begin if HasTask ( group [ i ] ) then
117410: LD_VAR 0 4
117414: PUSH
117415: LD_VAR 0 7
117419: ARRAY
117420: PPUSH
117421: CALL_OW 314
117425: IFFALSE 117431
// continue else
117427: GO 113588
117429: GO 117449
// SetTag ( group [ i ] , 0 ) ;
117431: LD_VAR 0 4
117435: PUSH
117436: LD_VAR 0 7
117440: ARRAY
117441: PPUSH
117442: LD_INT 0
117444: PPUSH
117445: CALL_OW 109
// end ; k := 8 ;
117449: LD_ADDR_VAR 0 9
117453: PUSH
117454: LD_INT 8
117456: ST_TO_ADDR
// x := 0 ;
117457: LD_ADDR_VAR 0 10
117461: PUSH
117462: LD_INT 0
117464: ST_TO_ADDR
// if tmp < k then
117465: LD_VAR 0 14
117469: PUSH
117470: LD_VAR 0 9
117474: LESS
117475: IFFALSE 117487
// k := tmp ;
117477: LD_ADDR_VAR 0 9
117481: PUSH
117482: LD_VAR 0 14
117486: ST_TO_ADDR
// for j = 1 to k do
117487: LD_ADDR_VAR 0 8
117491: PUSH
117492: DOUBLE
117493: LD_INT 1
117495: DEC
117496: ST_TO_ADDR
117497: LD_VAR 0 9
117501: PUSH
117502: FOR_TO
117503: IFFALSE 117601
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117505: LD_VAR 0 14
117509: PUSH
117510: LD_VAR 0 8
117514: ARRAY
117515: PPUSH
117516: CALL_OW 247
117520: PUSH
117521: LD_INT 1
117523: EQUAL
117524: PUSH
117525: LD_VAR 0 14
117529: PUSH
117530: LD_VAR 0 8
117534: ARRAY
117535: PPUSH
117536: CALL_OW 256
117540: PUSH
117541: LD_INT 250
117543: LESS
117544: PUSH
117545: LD_VAR 0 20
117549: AND
117550: PUSH
117551: LD_VAR 0 20
117555: NOT
117556: PUSH
117557: LD_VAR 0 14
117561: PUSH
117562: LD_VAR 0 8
117566: ARRAY
117567: PPUSH
117568: CALL_OW 256
117572: PUSH
117573: LD_INT 250
117575: GREATEREQUAL
117576: AND
117577: OR
117578: AND
117579: IFFALSE 117599
// begin x := tmp [ j ] ;
117581: LD_ADDR_VAR 0 10
117585: PUSH
117586: LD_VAR 0 14
117590: PUSH
117591: LD_VAR 0 8
117595: ARRAY
117596: ST_TO_ADDR
// break ;
117597: GO 117601
// end ;
117599: GO 117502
117601: POP
117602: POP
// if x then
117603: LD_VAR 0 10
117607: IFFALSE 117631
// ComAttackUnit ( group [ i ] , x ) else
117609: LD_VAR 0 4
117613: PUSH
117614: LD_VAR 0 7
117618: ARRAY
117619: PPUSH
117620: LD_VAR 0 10
117624: PPUSH
117625: CALL_OW 115
117629: GO 117655
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117631: LD_VAR 0 4
117635: PUSH
117636: LD_VAR 0 7
117640: ARRAY
117641: PPUSH
117642: LD_VAR 0 14
117646: PUSH
117647: LD_INT 1
117649: ARRAY
117650: PPUSH
117651: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117655: LD_VAR 0 4
117659: PUSH
117660: LD_VAR 0 7
117664: ARRAY
117665: PPUSH
117666: CALL_OW 314
117670: NOT
117671: IFFALSE 117709
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117673: LD_VAR 0 4
117677: PUSH
117678: LD_VAR 0 7
117682: ARRAY
117683: PPUSH
117684: LD_VAR 0 14
117688: PPUSH
117689: LD_VAR 0 4
117693: PUSH
117694: LD_VAR 0 7
117698: ARRAY
117699: PPUSH
117700: CALL_OW 74
117704: PPUSH
117705: CALL_OW 115
// end ; end ; end ;
117709: GO 113588
117711: POP
117712: POP
// wait ( 0 0$2 ) ;
117713: LD_INT 70
117715: PPUSH
117716: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117720: LD_VAR 0 4
117724: NOT
117725: PUSH
117726: LD_VAR 0 4
117730: PUSH
117731: EMPTY
117732: EQUAL
117733: OR
117734: PUSH
117735: LD_INT 81
117737: PUSH
117738: LD_VAR 0 35
117742: PUSH
117743: EMPTY
117744: LIST
117745: LIST
117746: PPUSH
117747: CALL_OW 69
117751: NOT
117752: OR
117753: IFFALSE 113573
// end ;
117755: LD_VAR 0 2
117759: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
117760: LD_INT 0
117762: PPUSH
117763: PPUSH
117764: PPUSH
117765: PPUSH
117766: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
117767: LD_VAR 0 1
117771: NOT
117772: PUSH
117773: LD_EXP 110
117777: PUSH
117778: LD_VAR 0 1
117782: ARRAY
117783: NOT
117784: OR
117785: PUSH
117786: LD_VAR 0 2
117790: NOT
117791: OR
117792: PUSH
117793: LD_VAR 0 3
117797: NOT
117798: OR
117799: IFFALSE 117803
// exit ;
117801: GO 118316
// side := mc_sides [ base ] ;
117803: LD_ADDR_VAR 0 6
117807: PUSH
117808: LD_EXP 136
117812: PUSH
117813: LD_VAR 0 1
117817: ARRAY
117818: ST_TO_ADDR
// if not side then
117819: LD_VAR 0 6
117823: NOT
117824: IFFALSE 117828
// exit ;
117826: GO 118316
// for i in solds do
117828: LD_ADDR_VAR 0 7
117832: PUSH
117833: LD_VAR 0 2
117837: PUSH
117838: FOR_IN
117839: IFFALSE 117900
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117841: LD_VAR 0 7
117845: PPUSH
117846: CALL_OW 310
117850: PPUSH
117851: CALL_OW 266
117855: PUSH
117856: LD_INT 32
117858: PUSH
117859: LD_INT 31
117861: PUSH
117862: EMPTY
117863: LIST
117864: LIST
117865: IN
117866: IFFALSE 117886
// solds := solds diff i else
117868: LD_ADDR_VAR 0 2
117872: PUSH
117873: LD_VAR 0 2
117877: PUSH
117878: LD_VAR 0 7
117882: DIFF
117883: ST_TO_ADDR
117884: GO 117898
// SetTag ( i , 18 ) ;
117886: LD_VAR 0 7
117890: PPUSH
117891: LD_INT 18
117893: PPUSH
117894: CALL_OW 109
117898: GO 117838
117900: POP
117901: POP
// if not solds then
117902: LD_VAR 0 2
117906: NOT
117907: IFFALSE 117911
// exit ;
117909: GO 118316
// repeat wait ( 0 0$1 ) ;
117911: LD_INT 35
117913: PPUSH
117914: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
117918: LD_ADDR_VAR 0 5
117922: PUSH
117923: LD_VAR 0 6
117927: PPUSH
117928: LD_VAR 0 3
117932: PPUSH
117933: CALL 66823 0 2
117937: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117938: LD_EXP 110
117942: PUSH
117943: LD_VAR 0 1
117947: ARRAY
117948: NOT
117949: PUSH
117950: LD_EXP 110
117954: PUSH
117955: LD_VAR 0 1
117959: ARRAY
117960: PUSH
117961: EMPTY
117962: EQUAL
117963: OR
117964: IFFALSE 118001
// begin for i in solds do
117966: LD_ADDR_VAR 0 7
117970: PUSH
117971: LD_VAR 0 2
117975: PUSH
117976: FOR_IN
117977: IFFALSE 117990
// ComStop ( i ) ;
117979: LD_VAR 0 7
117983: PPUSH
117984: CALL_OW 141
117988: GO 117976
117990: POP
117991: POP
// solds := [ ] ;
117992: LD_ADDR_VAR 0 2
117996: PUSH
117997: EMPTY
117998: ST_TO_ADDR
// exit ;
117999: GO 118316
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
118001: LD_VAR 0 5
118005: NOT
118006: PUSH
118007: LD_VAR 0 5
118011: PUSH
118012: LD_INT 3
118014: GREATER
118015: OR
118016: PUSH
118017: LD_EXP 132
118021: PUSH
118022: LD_VAR 0 1
118026: ARRAY
118027: OR
118028: IFFALSE 118069
// begin for i in solds do
118030: LD_ADDR_VAR 0 7
118034: PUSH
118035: LD_VAR 0 2
118039: PUSH
118040: FOR_IN
118041: IFFALSE 118065
// if HasTask ( i ) then
118043: LD_VAR 0 7
118047: PPUSH
118048: CALL_OW 314
118052: IFFALSE 118063
// ComStop ( i ) ;
118054: LD_VAR 0 7
118058: PPUSH
118059: CALL_OW 141
118063: GO 118040
118065: POP
118066: POP
// break ;
118067: GO 118304
// end ; for i in solds do
118069: LD_ADDR_VAR 0 7
118073: PUSH
118074: LD_VAR 0 2
118078: PUSH
118079: FOR_IN
118080: IFFALSE 118296
// begin if IsInUnit ( i ) then
118082: LD_VAR 0 7
118086: PPUSH
118087: CALL_OW 310
118091: IFFALSE 118102
// ComExitBuilding ( i ) ;
118093: LD_VAR 0 7
118097: PPUSH
118098: CALL_OW 122
// if GetLives ( i ) > 333 then
118102: LD_VAR 0 7
118106: PPUSH
118107: CALL_OW 256
118111: PUSH
118112: LD_INT 333
118114: GREATER
118115: IFFALSE 118143
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
118117: LD_VAR 0 7
118121: PPUSH
118122: LD_VAR 0 5
118126: PPUSH
118127: LD_VAR 0 7
118131: PPUSH
118132: CALL_OW 74
118136: PPUSH
118137: CALL_OW 115
118141: GO 118294
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118143: LD_ADDR_VAR 0 8
118147: PUSH
118148: LD_EXP 110
118152: PUSH
118153: LD_VAR 0 1
118157: ARRAY
118158: PPUSH
118159: LD_INT 2
118161: PUSH
118162: LD_INT 30
118164: PUSH
118165: LD_INT 0
118167: PUSH
118168: EMPTY
118169: LIST
118170: LIST
118171: PUSH
118172: LD_INT 30
118174: PUSH
118175: LD_INT 1
118177: PUSH
118178: EMPTY
118179: LIST
118180: LIST
118181: PUSH
118182: LD_INT 30
118184: PUSH
118185: LD_INT 6
118187: PUSH
118188: EMPTY
118189: LIST
118190: LIST
118191: PUSH
118192: EMPTY
118193: LIST
118194: LIST
118195: LIST
118196: LIST
118197: PPUSH
118198: CALL_OW 72
118202: PPUSH
118203: LD_VAR 0 7
118207: PPUSH
118208: CALL_OW 74
118212: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118213: LD_VAR 0 7
118217: PPUSH
118218: LD_VAR 0 8
118222: PPUSH
118223: CALL_OW 250
118227: PPUSH
118228: LD_INT 3
118230: PPUSH
118231: LD_INT 5
118233: PPUSH
118234: CALL_OW 272
118238: PPUSH
118239: LD_VAR 0 8
118243: PPUSH
118244: CALL_OW 251
118248: PPUSH
118249: LD_INT 3
118251: PPUSH
118252: LD_INT 5
118254: PPUSH
118255: CALL_OW 273
118259: PPUSH
118260: CALL_OW 111
// SetTag ( i , 0 ) ;
118264: LD_VAR 0 7
118268: PPUSH
118269: LD_INT 0
118271: PPUSH
118272: CALL_OW 109
// solds := solds diff i ;
118276: LD_ADDR_VAR 0 2
118280: PUSH
118281: LD_VAR 0 2
118285: PUSH
118286: LD_VAR 0 7
118290: DIFF
118291: ST_TO_ADDR
// continue ;
118292: GO 118079
// end ; end ;
118294: GO 118079
118296: POP
118297: POP
// until solds ;
118298: LD_VAR 0 2
118302: IFFALSE 117911
// MC_Reset ( base , 18 ) ;
118304: LD_VAR 0 1
118308: PPUSH
118309: LD_INT 18
118311: PPUSH
118312: CALL 39131 0 2
// end ;
118316: LD_VAR 0 4
118320: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
118321: LD_INT 0
118323: PPUSH
118324: PPUSH
118325: PPUSH
118326: PPUSH
118327: PPUSH
118328: PPUSH
118329: PPUSH
118330: PPUSH
118331: PPUSH
118332: PPUSH
118333: PPUSH
118334: PPUSH
118335: PPUSH
118336: PPUSH
118337: PPUSH
118338: PPUSH
118339: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118340: LD_ADDR_VAR 0 13
118344: PUSH
118345: LD_EXP 110
118349: PUSH
118350: LD_VAR 0 1
118354: ARRAY
118355: PPUSH
118356: LD_INT 25
118358: PUSH
118359: LD_INT 3
118361: PUSH
118362: EMPTY
118363: LIST
118364: LIST
118365: PPUSH
118366: CALL_OW 72
118370: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118371: LD_EXP 150
118375: PUSH
118376: LD_VAR 0 1
118380: ARRAY
118381: IFFALSE 118405
// mechs := mechs diff mc_remote_driver [ base ] ;
118383: LD_ADDR_VAR 0 13
118387: PUSH
118388: LD_VAR 0 13
118392: PUSH
118393: LD_EXP 150
118397: PUSH
118398: LD_VAR 0 1
118402: ARRAY
118403: DIFF
118404: ST_TO_ADDR
// for i in mechs do
118405: LD_ADDR_VAR 0 5
118409: PUSH
118410: LD_VAR 0 13
118414: PUSH
118415: FOR_IN
118416: IFFALSE 118451
// if GetTag ( i ) > 0 then
118418: LD_VAR 0 5
118422: PPUSH
118423: CALL_OW 110
118427: PUSH
118428: LD_INT 0
118430: GREATER
118431: IFFALSE 118449
// mechs := mechs diff i ;
118433: LD_ADDR_VAR 0 13
118437: PUSH
118438: LD_VAR 0 13
118442: PUSH
118443: LD_VAR 0 5
118447: DIFF
118448: ST_TO_ADDR
118449: GO 118415
118451: POP
118452: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118453: LD_ADDR_VAR 0 9
118457: PUSH
118458: LD_EXP 110
118462: PUSH
118463: LD_VAR 0 1
118467: ARRAY
118468: PPUSH
118469: LD_INT 2
118471: PUSH
118472: LD_INT 25
118474: PUSH
118475: LD_INT 1
118477: PUSH
118478: EMPTY
118479: LIST
118480: LIST
118481: PUSH
118482: LD_INT 25
118484: PUSH
118485: LD_INT 5
118487: PUSH
118488: EMPTY
118489: LIST
118490: LIST
118491: PUSH
118492: LD_INT 25
118494: PUSH
118495: LD_INT 8
118497: PUSH
118498: EMPTY
118499: LIST
118500: LIST
118501: PUSH
118502: LD_INT 25
118504: PUSH
118505: LD_INT 9
118507: PUSH
118508: EMPTY
118509: LIST
118510: LIST
118511: PUSH
118512: EMPTY
118513: LIST
118514: LIST
118515: LIST
118516: LIST
118517: LIST
118518: PPUSH
118519: CALL_OW 72
118523: ST_TO_ADDR
// if not defenders and not solds then
118524: LD_VAR 0 2
118528: NOT
118529: PUSH
118530: LD_VAR 0 9
118534: NOT
118535: AND
118536: IFFALSE 118540
// exit ;
118538: GO 120166
// depot_under_attack := false ;
118540: LD_ADDR_VAR 0 17
118544: PUSH
118545: LD_INT 0
118547: ST_TO_ADDR
// sold_defenders := [ ] ;
118548: LD_ADDR_VAR 0 18
118552: PUSH
118553: EMPTY
118554: ST_TO_ADDR
// if mechs then
118555: LD_VAR 0 13
118559: IFFALSE 118688
// for i in defenders do
118561: LD_ADDR_VAR 0 5
118565: PUSH
118566: LD_VAR 0 2
118570: PUSH
118571: FOR_IN
118572: IFFALSE 118686
// begin SetTag ( i , 20 ) ;
118574: LD_VAR 0 5
118578: PPUSH
118579: LD_INT 20
118581: PPUSH
118582: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
118586: LD_VAR 0 5
118590: PPUSH
118591: CALL_OW 263
118595: PUSH
118596: LD_INT 1
118598: EQUAL
118599: PUSH
118600: LD_VAR 0 5
118604: PPUSH
118605: CALL_OW 311
118609: NOT
118610: AND
118611: PUSH
118612: LD_VAR 0 13
118616: AND
118617: IFFALSE 118684
// begin un := mechs [ 1 ] ;
118619: LD_ADDR_VAR 0 11
118623: PUSH
118624: LD_VAR 0 13
118628: PUSH
118629: LD_INT 1
118631: ARRAY
118632: ST_TO_ADDR
// ComExitBuilding ( un ) ;
118633: LD_VAR 0 11
118637: PPUSH
118638: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
118642: LD_VAR 0 11
118646: PPUSH
118647: LD_VAR 0 5
118651: PPUSH
118652: CALL_OW 180
// SetTag ( un , 19 ) ;
118656: LD_VAR 0 11
118660: PPUSH
118661: LD_INT 19
118663: PPUSH
118664: CALL_OW 109
// mechs := mechs diff un ;
118668: LD_ADDR_VAR 0 13
118672: PUSH
118673: LD_VAR 0 13
118677: PUSH
118678: LD_VAR 0 11
118682: DIFF
118683: ST_TO_ADDR
// end ; end ;
118684: GO 118571
118686: POP
118687: POP
// if solds then
118688: LD_VAR 0 9
118692: IFFALSE 118751
// for i in solds do
118694: LD_ADDR_VAR 0 5
118698: PUSH
118699: LD_VAR 0 9
118703: PUSH
118704: FOR_IN
118705: IFFALSE 118749
// if not GetTag ( i ) then
118707: LD_VAR 0 5
118711: PPUSH
118712: CALL_OW 110
118716: NOT
118717: IFFALSE 118747
// begin defenders := defenders union i ;
118719: LD_ADDR_VAR 0 2
118723: PUSH
118724: LD_VAR 0 2
118728: PUSH
118729: LD_VAR 0 5
118733: UNION
118734: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118735: LD_VAR 0 5
118739: PPUSH
118740: LD_INT 18
118742: PPUSH
118743: CALL_OW 109
// end ;
118747: GO 118704
118749: POP
118750: POP
// repeat wait ( 0 0$1 ) ;
118751: LD_INT 35
118753: PPUSH
118754: CALL_OW 67
// enemy := mc_scan [ base ] ;
118758: LD_ADDR_VAR 0 3
118762: PUSH
118763: LD_EXP 133
118767: PUSH
118768: LD_VAR 0 1
118772: ARRAY
118773: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118774: LD_EXP 110
118778: PUSH
118779: LD_VAR 0 1
118783: ARRAY
118784: NOT
118785: PUSH
118786: LD_EXP 110
118790: PUSH
118791: LD_VAR 0 1
118795: ARRAY
118796: PUSH
118797: EMPTY
118798: EQUAL
118799: OR
118800: IFFALSE 118837
// begin for i in defenders do
118802: LD_ADDR_VAR 0 5
118806: PUSH
118807: LD_VAR 0 2
118811: PUSH
118812: FOR_IN
118813: IFFALSE 118826
// ComStop ( i ) ;
118815: LD_VAR 0 5
118819: PPUSH
118820: CALL_OW 141
118824: GO 118812
118826: POP
118827: POP
// defenders := [ ] ;
118828: LD_ADDR_VAR 0 2
118832: PUSH
118833: EMPTY
118834: ST_TO_ADDR
// exit ;
118835: GO 120166
// end ; for i in defenders do
118837: LD_ADDR_VAR 0 5
118841: PUSH
118842: LD_VAR 0 2
118846: PUSH
118847: FOR_IN
118848: IFFALSE 119666
// begin e := NearestUnitToUnit ( enemy , i ) ;
118850: LD_ADDR_VAR 0 14
118854: PUSH
118855: LD_VAR 0 3
118859: PPUSH
118860: LD_VAR 0 5
118864: PPUSH
118865: CALL_OW 74
118869: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118870: LD_ADDR_VAR 0 8
118874: PUSH
118875: LD_EXP 110
118879: PUSH
118880: LD_VAR 0 1
118884: ARRAY
118885: PPUSH
118886: LD_INT 2
118888: PUSH
118889: LD_INT 30
118891: PUSH
118892: LD_INT 0
118894: PUSH
118895: EMPTY
118896: LIST
118897: LIST
118898: PUSH
118899: LD_INT 30
118901: PUSH
118902: LD_INT 1
118904: PUSH
118905: EMPTY
118906: LIST
118907: LIST
118908: PUSH
118909: EMPTY
118910: LIST
118911: LIST
118912: LIST
118913: PPUSH
118914: CALL_OW 72
118918: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118919: LD_ADDR_VAR 0 17
118923: PUSH
118924: LD_VAR 0 8
118928: NOT
118929: PUSH
118930: LD_VAR 0 8
118934: PPUSH
118935: LD_INT 3
118937: PUSH
118938: LD_INT 24
118940: PUSH
118941: LD_INT 600
118943: PUSH
118944: EMPTY
118945: LIST
118946: LIST
118947: PUSH
118948: EMPTY
118949: LIST
118950: LIST
118951: PPUSH
118952: CALL_OW 72
118956: OR
118957: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118958: LD_VAR 0 5
118962: PPUSH
118963: CALL_OW 247
118967: PUSH
118968: LD_INT 2
118970: DOUBLE
118971: EQUAL
118972: IFTRUE 118976
118974: GO 119372
118976: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118977: LD_VAR 0 5
118981: PPUSH
118982: CALL_OW 256
118986: PUSH
118987: LD_INT 650
118989: GREATER
118990: PUSH
118991: LD_VAR 0 5
118995: PPUSH
118996: LD_VAR 0 14
119000: PPUSH
119001: CALL_OW 296
119005: PUSH
119006: LD_INT 40
119008: LESS
119009: PUSH
119010: LD_VAR 0 14
119014: PPUSH
119015: LD_EXP 135
119019: PUSH
119020: LD_VAR 0 1
119024: ARRAY
119025: PPUSH
119026: CALL_OW 308
119030: OR
119031: AND
119032: IFFALSE 119154
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119034: LD_VAR 0 5
119038: PPUSH
119039: CALL_OW 262
119043: PUSH
119044: LD_INT 1
119046: EQUAL
119047: PUSH
119048: LD_VAR 0 5
119052: PPUSH
119053: CALL_OW 261
119057: PUSH
119058: LD_INT 30
119060: LESS
119061: AND
119062: PUSH
119063: LD_VAR 0 8
119067: AND
119068: IFFALSE 119138
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119070: LD_VAR 0 5
119074: PPUSH
119075: LD_VAR 0 8
119079: PPUSH
119080: LD_VAR 0 5
119084: PPUSH
119085: CALL_OW 74
119089: PPUSH
119090: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119094: LD_VAR 0 5
119098: PPUSH
119099: LD_VAR 0 8
119103: PPUSH
119104: LD_VAR 0 5
119108: PPUSH
119109: CALL_OW 74
119113: PPUSH
119114: CALL_OW 296
119118: PUSH
119119: LD_INT 6
119121: LESS
119122: IFFALSE 119136
// SetFuel ( i , 100 ) ;
119124: LD_VAR 0 5
119128: PPUSH
119129: LD_INT 100
119131: PPUSH
119132: CALL_OW 240
// end else
119136: GO 119152
// ComAttackUnit ( i , e ) ;
119138: LD_VAR 0 5
119142: PPUSH
119143: LD_VAR 0 14
119147: PPUSH
119148: CALL_OW 115
// end else
119152: GO 119255
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119154: LD_VAR 0 14
119158: PPUSH
119159: LD_EXP 135
119163: PUSH
119164: LD_VAR 0 1
119168: ARRAY
119169: PPUSH
119170: CALL_OW 308
119174: NOT
119175: PUSH
119176: LD_VAR 0 5
119180: PPUSH
119181: LD_VAR 0 14
119185: PPUSH
119186: CALL_OW 296
119190: PUSH
119191: LD_INT 40
119193: GREATEREQUAL
119194: AND
119195: PUSH
119196: LD_VAR 0 5
119200: PPUSH
119201: CALL_OW 256
119205: PUSH
119206: LD_INT 650
119208: LESSEQUAL
119209: OR
119210: PUSH
119211: LD_VAR 0 5
119215: PPUSH
119216: LD_EXP 134
119220: PUSH
119221: LD_VAR 0 1
119225: ARRAY
119226: PPUSH
119227: CALL_OW 308
119231: NOT
119232: AND
119233: IFFALSE 119255
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119235: LD_VAR 0 5
119239: PPUSH
119240: LD_EXP 134
119244: PUSH
119245: LD_VAR 0 1
119249: ARRAY
119250: PPUSH
119251: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119255: LD_VAR 0 5
119259: PPUSH
119260: CALL_OW 256
119264: PUSH
119265: LD_INT 998
119267: LESS
119268: PUSH
119269: LD_VAR 0 5
119273: PPUSH
119274: CALL_OW 263
119278: PUSH
119279: LD_INT 1
119281: EQUAL
119282: AND
119283: PUSH
119284: LD_VAR 0 5
119288: PPUSH
119289: CALL_OW 311
119293: AND
119294: PUSH
119295: LD_VAR 0 5
119299: PPUSH
119300: LD_EXP 134
119304: PUSH
119305: LD_VAR 0 1
119309: ARRAY
119310: PPUSH
119311: CALL_OW 308
119315: AND
119316: IFFALSE 119370
// begin mech := IsDrivenBy ( i ) ;
119318: LD_ADDR_VAR 0 10
119322: PUSH
119323: LD_VAR 0 5
119327: PPUSH
119328: CALL_OW 311
119332: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119333: LD_VAR 0 10
119337: PPUSH
119338: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119342: LD_VAR 0 10
119346: PPUSH
119347: LD_VAR 0 5
119351: PPUSH
119352: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119356: LD_VAR 0 10
119360: PPUSH
119361: LD_VAR 0 5
119365: PPUSH
119366: CALL_OW 180
// end ; end ; unit_human :
119370: GO 119637
119372: LD_INT 1
119374: DOUBLE
119375: EQUAL
119376: IFTRUE 119380
119378: GO 119636
119380: POP
// begin b := IsInUnit ( i ) ;
119381: LD_ADDR_VAR 0 19
119385: PUSH
119386: LD_VAR 0 5
119390: PPUSH
119391: CALL_OW 310
119395: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119396: LD_ADDR_VAR 0 20
119400: PUSH
119401: LD_VAR 0 19
119405: NOT
119406: PUSH
119407: LD_VAR 0 19
119411: PPUSH
119412: CALL_OW 266
119416: PUSH
119417: LD_INT 32
119419: PUSH
119420: LD_INT 31
119422: PUSH
119423: EMPTY
119424: LIST
119425: LIST
119426: IN
119427: OR
119428: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119429: LD_VAR 0 17
119433: PUSH
119434: LD_VAR 0 2
119438: PPUSH
119439: LD_INT 21
119441: PUSH
119442: LD_INT 2
119444: PUSH
119445: EMPTY
119446: LIST
119447: LIST
119448: PPUSH
119449: CALL_OW 72
119453: PUSH
119454: LD_INT 1
119456: LESSEQUAL
119457: OR
119458: PUSH
119459: LD_VAR 0 20
119463: AND
119464: PUSH
119465: LD_VAR 0 5
119469: PUSH
119470: LD_VAR 0 18
119474: IN
119475: NOT
119476: AND
119477: IFFALSE 119570
// begin if b then
119479: LD_VAR 0 19
119483: IFFALSE 119532
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119485: LD_VAR 0 19
119489: PPUSH
119490: LD_VAR 0 3
119494: PPUSH
119495: LD_VAR 0 19
119499: PPUSH
119500: CALL_OW 74
119504: PPUSH
119505: CALL_OW 296
119509: PUSH
119510: LD_INT 10
119512: LESS
119513: PUSH
119514: LD_VAR 0 19
119518: PPUSH
119519: CALL_OW 461
119523: PUSH
119524: LD_INT 7
119526: NONEQUAL
119527: AND
119528: IFFALSE 119532
// continue ;
119530: GO 118847
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119532: LD_ADDR_VAR 0 18
119536: PUSH
119537: LD_VAR 0 18
119541: PPUSH
119542: LD_VAR 0 18
119546: PUSH
119547: LD_INT 1
119549: PLUS
119550: PPUSH
119551: LD_VAR 0 5
119555: PPUSH
119556: CALL_OW 1
119560: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119561: LD_VAR 0 5
119565: PPUSH
119566: CALL_OW 122
// end ; if sold_defenders then
119570: LD_VAR 0 18
119574: IFFALSE 119634
// if i in sold_defenders then
119576: LD_VAR 0 5
119580: PUSH
119581: LD_VAR 0 18
119585: IN
119586: IFFALSE 119634
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119588: LD_VAR 0 5
119592: PPUSH
119593: CALL_OW 314
119597: NOT
119598: PUSH
119599: LD_VAR 0 5
119603: PPUSH
119604: LD_VAR 0 14
119608: PPUSH
119609: CALL_OW 296
119613: PUSH
119614: LD_INT 30
119616: LESS
119617: AND
119618: IFFALSE 119634
// ComAttackUnit ( i , e ) ;
119620: LD_VAR 0 5
119624: PPUSH
119625: LD_VAR 0 14
119629: PPUSH
119630: CALL_OW 115
// end ; end ; end ;
119634: GO 119637
119636: POP
// if IsDead ( i ) then
119637: LD_VAR 0 5
119641: PPUSH
119642: CALL_OW 301
119646: IFFALSE 119664
// defenders := defenders diff i ;
119648: LD_ADDR_VAR 0 2
119652: PUSH
119653: LD_VAR 0 2
119657: PUSH
119658: LD_VAR 0 5
119662: DIFF
119663: ST_TO_ADDR
// end ;
119664: GO 118847
119666: POP
119667: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119668: LD_VAR 0 3
119672: NOT
119673: PUSH
119674: LD_VAR 0 2
119678: NOT
119679: OR
119680: PUSH
119681: LD_EXP 110
119685: PUSH
119686: LD_VAR 0 1
119690: ARRAY
119691: NOT
119692: OR
119693: IFFALSE 118751
// MC_Reset ( base , 18 ) ;
119695: LD_VAR 0 1
119699: PPUSH
119700: LD_INT 18
119702: PPUSH
119703: CALL 39131 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119707: LD_ADDR_VAR 0 2
119711: PUSH
119712: LD_VAR 0 2
119716: PUSH
119717: LD_VAR 0 2
119721: PPUSH
119722: LD_INT 2
119724: PUSH
119725: LD_INT 25
119727: PUSH
119728: LD_INT 1
119730: PUSH
119731: EMPTY
119732: LIST
119733: LIST
119734: PUSH
119735: LD_INT 25
119737: PUSH
119738: LD_INT 5
119740: PUSH
119741: EMPTY
119742: LIST
119743: LIST
119744: PUSH
119745: LD_INT 25
119747: PUSH
119748: LD_INT 8
119750: PUSH
119751: EMPTY
119752: LIST
119753: LIST
119754: PUSH
119755: LD_INT 25
119757: PUSH
119758: LD_INT 9
119760: PUSH
119761: EMPTY
119762: LIST
119763: LIST
119764: PUSH
119765: EMPTY
119766: LIST
119767: LIST
119768: LIST
119769: LIST
119770: LIST
119771: PPUSH
119772: CALL_OW 72
119776: DIFF
119777: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119778: LD_VAR 0 3
119782: NOT
119783: PUSH
119784: LD_VAR 0 2
119788: PPUSH
119789: LD_INT 21
119791: PUSH
119792: LD_INT 2
119794: PUSH
119795: EMPTY
119796: LIST
119797: LIST
119798: PPUSH
119799: CALL_OW 72
119803: AND
119804: IFFALSE 120142
// begin tmp := FilterByTag ( defenders , 19 ) ;
119806: LD_ADDR_VAR 0 12
119810: PUSH
119811: LD_VAR 0 2
119815: PPUSH
119816: LD_INT 19
119818: PPUSH
119819: CALL 98583 0 2
119823: ST_TO_ADDR
// if tmp then
119824: LD_VAR 0 12
119828: IFFALSE 119898
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119830: LD_ADDR_VAR 0 12
119834: PUSH
119835: LD_VAR 0 12
119839: PPUSH
119840: LD_INT 25
119842: PUSH
119843: LD_INT 3
119845: PUSH
119846: EMPTY
119847: LIST
119848: LIST
119849: PPUSH
119850: CALL_OW 72
119854: ST_TO_ADDR
// if tmp then
119855: LD_VAR 0 12
119859: IFFALSE 119898
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119861: LD_ADDR_EXP 122
119865: PUSH
119866: LD_EXP 122
119870: PPUSH
119871: LD_VAR 0 1
119875: PPUSH
119876: LD_EXP 122
119880: PUSH
119881: LD_VAR 0 1
119885: ARRAY
119886: PUSH
119887: LD_VAR 0 12
119891: UNION
119892: PPUSH
119893: CALL_OW 1
119897: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119898: LD_VAR 0 1
119902: PPUSH
119903: LD_INT 19
119905: PPUSH
119906: CALL 39131 0 2
// repeat wait ( 0 0$1 ) ;
119910: LD_INT 35
119912: PPUSH
119913: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119917: LD_EXP 110
119921: PUSH
119922: LD_VAR 0 1
119926: ARRAY
119927: NOT
119928: PUSH
119929: LD_EXP 110
119933: PUSH
119934: LD_VAR 0 1
119938: ARRAY
119939: PUSH
119940: EMPTY
119941: EQUAL
119942: OR
119943: IFFALSE 119980
// begin for i in defenders do
119945: LD_ADDR_VAR 0 5
119949: PUSH
119950: LD_VAR 0 2
119954: PUSH
119955: FOR_IN
119956: IFFALSE 119969
// ComStop ( i ) ;
119958: LD_VAR 0 5
119962: PPUSH
119963: CALL_OW 141
119967: GO 119955
119969: POP
119970: POP
// defenders := [ ] ;
119971: LD_ADDR_VAR 0 2
119975: PUSH
119976: EMPTY
119977: ST_TO_ADDR
// exit ;
119978: GO 120166
// end ; for i in defenders do
119980: LD_ADDR_VAR 0 5
119984: PUSH
119985: LD_VAR 0 2
119989: PUSH
119990: FOR_IN
119991: IFFALSE 120080
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119993: LD_VAR 0 5
119997: PPUSH
119998: LD_EXP 134
120002: PUSH
120003: LD_VAR 0 1
120007: ARRAY
120008: PPUSH
120009: CALL_OW 308
120013: NOT
120014: IFFALSE 120038
// ComMoveToArea ( i , mc_parking [ base ] ) else
120016: LD_VAR 0 5
120020: PPUSH
120021: LD_EXP 134
120025: PUSH
120026: LD_VAR 0 1
120030: ARRAY
120031: PPUSH
120032: CALL_OW 113
120036: GO 120078
// if GetControl ( i ) = control_manual then
120038: LD_VAR 0 5
120042: PPUSH
120043: CALL_OW 263
120047: PUSH
120048: LD_INT 1
120050: EQUAL
120051: IFFALSE 120078
// if IsDrivenBy ( i ) then
120053: LD_VAR 0 5
120057: PPUSH
120058: CALL_OW 311
120062: IFFALSE 120078
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120064: LD_VAR 0 5
120068: PPUSH
120069: CALL_OW 311
120073: PPUSH
120074: CALL_OW 121
// end ;
120078: GO 119990
120080: POP
120081: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120082: LD_VAR 0 2
120086: PPUSH
120087: LD_INT 95
120089: PUSH
120090: LD_EXP 134
120094: PUSH
120095: LD_VAR 0 1
120099: ARRAY
120100: PUSH
120101: EMPTY
120102: LIST
120103: LIST
120104: PPUSH
120105: CALL_OW 72
120109: PUSH
120110: LD_VAR 0 2
120114: EQUAL
120115: PUSH
120116: LD_EXP 133
120120: PUSH
120121: LD_VAR 0 1
120125: ARRAY
120126: OR
120127: PUSH
120128: LD_EXP 110
120132: PUSH
120133: LD_VAR 0 1
120137: ARRAY
120138: NOT
120139: OR
120140: IFFALSE 119910
// end ; MC_Reset ( base , 19 ) ;
120142: LD_VAR 0 1
120146: PPUSH
120147: LD_INT 19
120149: PPUSH
120150: CALL 39131 0 2
// MC_Reset ( base , 20 ) ;
120154: LD_VAR 0 1
120158: PPUSH
120159: LD_INT 20
120161: PPUSH
120162: CALL 39131 0 2
// end ;
120166: LD_VAR 0 4
120170: RET
