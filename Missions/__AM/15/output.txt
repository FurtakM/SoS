// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34702 0 0
// InitNature ;
  19: CALL 34526 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10941 0 0
// PrepareRussian ;
  40: CALL 6924 0 0
// PrepareLegion ;
  44: CALL 4164 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14835 0 0
// MC_Start ( ) ;
  60: CALL 36814 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 126
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 127
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59091 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59184 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58534 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58349 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59091 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59184 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58349 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58534 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 58964 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58031 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59091 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59184 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 131
 955: PUSH
 956: LD_EXP 131
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58349 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59091 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59184 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58241 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59502 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58673 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 58964 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 58964 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59296 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58349 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 58915 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger debug do var i , tmp ;
1549: LD_EXP 1
1553: IFFALSE 1660
1555: GO 1557
1557: DISABLE
1558: LD_INT 0
1560: PPUSH
1561: PPUSH
// begin enable ;
1562: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1563: LD_ADDR_VAR 0 2
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: PUSH
1578: LD_INT 3
1580: PUSH
1581: LD_INT 21
1583: PUSH
1584: LD_INT 3
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PUSH
1595: LD_INT 3
1597: PUSH
1598: LD_INT 24
1600: PUSH
1601: LD_INT 999
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: EMPTY
1613: LIST
1614: LIST
1615: LIST
1616: PPUSH
1617: CALL_OW 69
1621: ST_TO_ADDR
// if not tmp then
1622: LD_VAR 0 2
1626: NOT
1627: IFFALSE 1631
// exit ;
1629: GO 1660
// for i in tmp do
1631: LD_ADDR_VAR 0 1
1635: PUSH
1636: LD_VAR 0 2
1640: PUSH
1641: FOR_IN
1642: IFFALSE 1658
// SetLives ( i , 1000 ) ;
1644: LD_VAR 0 1
1648: PPUSH
1649: LD_INT 1000
1651: PPUSH
1652: CALL_OW 234
1656: GO 1641
1658: POP
1659: POP
// end ;
1660: PPOPN 2
1662: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1663: LD_EXP 36
1667: PUSH
1668: LD_EXP 17
1672: PUSH
1673: LD_INT 2
1675: GREATEREQUAL
1676: AND
1677: IFFALSE 1689
1679: GO 1681
1681: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1682: LD_STRING ACH_POWELL
1684: PPUSH
1685: CALL_OW 543
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64741 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1753: LD_INT 3
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 5
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 71856 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 71856 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1850: LD_INT 3
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 5
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 71856 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 71856 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 71856 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64741 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64741 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64741 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64741 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64741 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64741 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64741 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64741 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64741 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64741 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64741 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64741 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64741 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64741 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64741 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 2500
2959: PPUSH
2960: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2964: LD_INT 387
2966: PPUSH
2967: CALL_OW 274
2971: PPUSH
2972: LD_INT 2
2974: PPUSH
2975: LD_INT 400
2977: PPUSH
2978: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2982: LD_INT 387
2984: PPUSH
2985: CALL_OW 274
2989: PPUSH
2990: LD_INT 3
2992: PPUSH
2993: LD_INT 10
2995: PPUSH
2996: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3000: LD_ADDR_EXP 58
3004: PUSH
3005: LD_STRING Powell
3007: PPUSH
3008: CALL_OW 25
3012: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3013: LD_EXP 58
3017: PPUSH
3018: LD_INT 57
3020: PPUSH
3021: LD_INT 94
3023: PPUSH
3024: LD_INT 0
3026: PPUSH
3027: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3031: LD_EXP 58
3035: PPUSH
3036: LD_INT 58
3038: PPUSH
3039: LD_INT 94
3041: PPUSH
3042: CALL_OW 118
// vip := [ ] ;
3046: LD_ADDR_EXP 59
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// tmp := [ ] ;
3053: LD_ADDR_VAR 0 6
3057: PUSH
3058: EMPTY
3059: ST_TO_ADDR
// if JMMGirl <> 2 then
3060: LD_EXP 7
3064: PUSH
3065: LD_INT 2
3067: NONEQUAL
3068: IFFALSE 3092
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3070: LD_ADDR_EXP 42
3074: PUSH
3075: LD_STRING Lisa
3077: PPUSH
3078: LD_EXP 1
3082: NOT
3083: PPUSH
3084: LD_STRING 13s_
3086: PPUSH
3087: CALL 64741 0 3
3091: ST_TO_ADDR
// if Lisa then
3092: LD_EXP 42
3096: IFFALSE 3114
// tmp := tmp ^ Lisa ;
3098: LD_ADDR_VAR 0 6
3102: PUSH
3103: LD_VAR 0 6
3107: PUSH
3108: LD_EXP 42
3112: ADD
3113: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3114: LD_ADDR_EXP 43
3118: PUSH
3119: LD_STRING Donaldson
3121: PPUSH
3122: LD_EXP 1
3126: NOT
3127: PPUSH
3128: LD_STRING 13s_
3130: PPUSH
3131: CALL 64741 0 3
3135: ST_TO_ADDR
// if Donaldson then
3136: LD_EXP 43
3140: IFFALSE 3158
// tmp := tmp ^ Donaldson ;
3142: LD_ADDR_VAR 0 6
3146: PUSH
3147: LD_VAR 0 6
3151: PUSH
3152: LD_EXP 43
3156: ADD
3157: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3158: LD_ADDR_EXP 44
3162: PUSH
3163: LD_STRING Bobby
3165: PPUSH
3166: LD_EXP 1
3170: NOT
3171: PPUSH
3172: LD_STRING 13s_
3174: PPUSH
3175: CALL 64741 0 3
3179: ST_TO_ADDR
// if Bobby then
3180: LD_EXP 44
3184: IFFALSE 3202
// tmp := tmp ^ Bobby ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: LD_VAR 0 6
3195: PUSH
3196: LD_EXP 44
3200: ADD
3201: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3202: LD_ADDR_EXP 45
3206: PUSH
3207: LD_STRING Cyrus
3209: PPUSH
3210: LD_EXP 1
3214: NOT
3215: PPUSH
3216: LD_STRING 13s_
3218: PPUSH
3219: CALL 64741 0 3
3223: ST_TO_ADDR
// if Cyrus then
3224: LD_EXP 45
3228: IFFALSE 3246
// tmp := tmp ^ Cyrus ;
3230: LD_ADDR_VAR 0 6
3234: PUSH
3235: LD_VAR 0 6
3239: PUSH
3240: LD_EXP 45
3244: ADD
3245: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 46
3250: PUSH
3251: LD_STRING Denis
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 64741 0 3
3267: ST_TO_ADDR
// if not Denis then
3268: LD_EXP 46
3272: NOT
3273: IFFALSE 3297
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3275: LD_ADDR_EXP 46
3279: PUSH
3280: LD_STRING Denis
3282: PPUSH
3283: LD_EXP 1
3287: NOT
3288: PPUSH
3289: LD_STRING 13f_
3291: PPUSH
3292: CALL 64741 0 3
3296: ST_TO_ADDR
// if Denis then
3297: LD_EXP 46
3301: IFFALSE 3319
// tmp := tmp ^ Denis ;
3303: LD_ADDR_VAR 0 6
3307: PUSH
3308: LD_VAR 0 6
3312: PUSH
3313: LD_EXP 46
3317: ADD
3318: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3319: LD_ADDR_EXP 47
3323: PUSH
3324: LD_STRING Brown
3326: PPUSH
3327: LD_EXP 1
3331: NOT
3332: PPUSH
3333: LD_STRING 13s_
3335: PPUSH
3336: CALL 64741 0 3
3340: ST_TO_ADDR
// if Brown then
3341: LD_EXP 47
3345: IFFALSE 3363
// tmp := tmp ^ Brown ;
3347: LD_ADDR_VAR 0 6
3351: PUSH
3352: LD_VAR 0 6
3356: PUSH
3357: LD_EXP 47
3361: ADD
3362: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3363: LD_ADDR_EXP 48
3367: PUSH
3368: LD_STRING Gladstone
3370: PPUSH
3371: LD_EXP 1
3375: NOT
3376: PPUSH
3377: LD_STRING 13s_
3379: PPUSH
3380: CALL 64741 0 3
3384: ST_TO_ADDR
// if Gladstone then
3385: LD_EXP 48
3389: IFFALSE 3407
// tmp := tmp ^ Gladstone ;
3391: LD_ADDR_VAR 0 6
3395: PUSH
3396: LD_VAR 0 6
3400: PUSH
3401: LD_EXP 48
3405: ADD
3406: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3407: LD_ADDR_EXP 49
3411: PUSH
3412: LD_STRING Houten
3414: PPUSH
3415: LD_EXP 1
3419: NOT
3420: PPUSH
3421: LD_STRING 13s_
3423: PPUSH
3424: CALL 64741 0 3
3428: ST_TO_ADDR
// if Houten then
3429: LD_EXP 49
3433: IFFALSE 3451
// tmp := tmp ^ Houten ;
3435: LD_ADDR_VAR 0 6
3439: PUSH
3440: LD_VAR 0 6
3444: PUSH
3445: LD_EXP 49
3449: ADD
3450: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3451: LD_ADDR_EXP 50
3455: PUSH
3456: LD_STRING Cornel
3458: PPUSH
3459: LD_EXP 1
3463: NOT
3464: PPUSH
3465: LD_STRING 13s_
3467: PPUSH
3468: CALL 64741 0 3
3472: ST_TO_ADDR
// if Cornel then
3473: LD_EXP 50
3477: IFFALSE 3495
// tmp := tmp ^ Cornel ;
3479: LD_ADDR_VAR 0 6
3483: PUSH
3484: LD_VAR 0 6
3488: PUSH
3489: LD_EXP 50
3493: ADD
3494: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3495: LD_ADDR_EXP 51
3499: PUSH
3500: LD_STRING Gary
3502: PPUSH
3503: LD_EXP 1
3507: NOT
3508: PPUSH
3509: LD_STRING 13s_
3511: PPUSH
3512: CALL 64741 0 3
3516: ST_TO_ADDR
// if Gary then
3517: LD_EXP 51
3521: IFFALSE 3539
// tmp := tmp ^ Gary ;
3523: LD_ADDR_VAR 0 6
3527: PUSH
3528: LD_VAR 0 6
3532: PUSH
3533: LD_EXP 51
3537: ADD
3538: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3539: LD_ADDR_EXP 52
3543: PUSH
3544: LD_STRING Frank
3546: PPUSH
3547: LD_EXP 1
3551: NOT
3552: PPUSH
3553: LD_STRING 13s_
3555: PPUSH
3556: CALL 64741 0 3
3560: ST_TO_ADDR
// if Frank then
3561: LD_EXP 52
3565: IFFALSE 3583
// tmp := tmp ^ Frank ;
3567: LD_ADDR_VAR 0 6
3571: PUSH
3572: LD_VAR 0 6
3576: PUSH
3577: LD_EXP 52
3581: ADD
3582: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3583: LD_ADDR_EXP 53
3587: PUSH
3588: LD_STRING Kikuchi
3590: PPUSH
3591: LD_EXP 1
3595: NOT
3596: PPUSH
3597: LD_STRING 13s_
3599: PPUSH
3600: CALL 64741 0 3
3604: ST_TO_ADDR
// if Kikuchi then
3605: LD_EXP 53
3609: IFFALSE 3627
// tmp := tmp ^ Kikuchi ;
3611: LD_ADDR_VAR 0 6
3615: PUSH
3616: LD_VAR 0 6
3620: PUSH
3621: LD_EXP 53
3625: ADD
3626: ST_TO_ADDR
// vip := tmp ;
3627: LD_ADDR_EXP 59
3631: PUSH
3632: LD_VAR 0 6
3636: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3637: LD_ADDR_VAR 0 6
3641: PUSH
3642: LD_VAR 0 6
3646: PUSH
3647: LD_STRING 13s_others
3649: PPUSH
3650: CALL_OW 31
3654: UNION
3655: ST_TO_ADDR
// if tmp < 20 then
3656: LD_VAR 0 6
3660: PUSH
3661: LD_INT 20
3663: LESS
3664: IFFALSE 3731
// for i = 1 to 20 - tmp do
3666: LD_ADDR_VAR 0 2
3670: PUSH
3671: DOUBLE
3672: LD_INT 1
3674: DEC
3675: ST_TO_ADDR
3676: LD_INT 20
3678: PUSH
3679: LD_VAR 0 6
3683: MINUS
3684: PUSH
3685: FOR_TO
3686: IFFALSE 3729
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3688: LD_INT 1
3690: PPUSH
3691: LD_VAR 0 2
3695: PUSH
3696: LD_INT 4
3698: MOD
3699: PUSH
3700: LD_INT 1
3702: PLUS
3703: PPUSH
3704: LD_INT 5
3706: PPUSH
3707: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3711: LD_ADDR_VAR 0 6
3715: PUSH
3716: LD_VAR 0 6
3720: PUSH
3721: CALL_OW 44
3725: ADD
3726: ST_TO_ADDR
// end ;
3727: GO 3685
3729: POP
3730: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3731: LD_ADDR_VAR 0 7
3735: PUSH
3736: LD_INT 22
3738: PUSH
3739: LD_INT 4
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: PUSH
3746: LD_INT 30
3748: PUSH
3749: LD_INT 0
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PPUSH
3760: CALL_OW 69
3764: PUSH
3765: LD_INT 1
3767: ARRAY
3768: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3769: LD_ADDR_VAR 0 8
3773: PUSH
3774: LD_INT 22
3776: PUSH
3777: LD_INT 4
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 30
3786: PUSH
3787: LD_INT 6
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_INT 1
3805: ARRAY
3806: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3807: LD_ADDR_VAR 0 9
3811: PUSH
3812: LD_INT 22
3814: PUSH
3815: LD_INT 4
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: PUSH
3822: LD_INT 30
3824: PUSH
3825: LD_INT 4
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PPUSH
3836: CALL_OW 69
3840: PUSH
3841: LD_INT 1
3843: ARRAY
3844: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3845: LD_ADDR_VAR 0 10
3849: PUSH
3850: LD_INT 22
3852: PUSH
3853: LD_INT 4
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 30
3862: PUSH
3863: LD_INT 2
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PPUSH
3874: CALL_OW 69
3878: PUSH
3879: LD_INT 1
3881: ARRAY
3882: ST_TO_ADDR
// for i in tmp do
3883: LD_ADDR_VAR 0 2
3887: PUSH
3888: LD_VAR 0 6
3892: PUSH
3893: FOR_IN
3894: IFFALSE 4020
// begin cl := GetClass ( i ) ;
3896: LD_ADDR_VAR 0 5
3900: PUSH
3901: LD_VAR 0 2
3905: PPUSH
3906: CALL_OW 257
3910: ST_TO_ADDR
// if cl > 4 then
3911: LD_VAR 0 5
3915: PUSH
3916: LD_INT 4
3918: GREATER
3919: IFFALSE 3929
// cl := 1 ;
3921: LD_ADDR_VAR 0 5
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3929: LD_ADDR_VAR 0 3
3933: PUSH
3934: LD_VAR 0 9
3938: PUSH
3939: LD_VAR 0 7
3943: PUSH
3944: LD_VAR 0 10
3948: PUSH
3949: LD_VAR 0 8
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: PUSH
3960: LD_VAR 0 5
3964: ARRAY
3965: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3966: LD_VAR 0 3
3970: PPUSH
3971: CALL_OW 313
3975: PUSH
3976: LD_INT 5
3978: LESS
3979: IFFALSE 3997
// PlaceHumanInUnit ( i , b ) else
3981: LD_VAR 0 2
3985: PPUSH
3986: LD_VAR 0 3
3990: PPUSH
3991: CALL_OW 52
3995: GO 4018
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_INT 58
4004: PPUSH
4005: LD_INT 91
4007: PPUSH
4008: LD_INT 6
4010: PPUSH
4011: LD_INT 0
4013: PPUSH
4014: CALL_OW 50
// end ;
4018: GO 3893
4020: POP
4021: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4022: LD_INT 2
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 12
4033: PPUSH
4034: LD_INT 100
4036: PPUSH
4037: CALL 71856 0 5
// veh := CreateVehicle ;
4041: LD_ADDR_VAR 0 4
4045: PUSH
4046: CALL_OW 45
4050: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4051: LD_VAR 0 4
4055: PPUSH
4056: LD_INT 4
4058: PPUSH
4059: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4063: LD_VAR 0 4
4067: PPUSH
4068: LD_INT 49
4070: PPUSH
4071: LD_INT 88
4073: PPUSH
4074: LD_INT 0
4076: PPUSH
4077: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4081: LD_VAR 0 4
4085: PPUSH
4086: LD_INT 1
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL_OW 290
// uc_side := 0 ;
4096: LD_ADDR_OWVAR 20
4100: PUSH
4101: LD_INT 0
4103: ST_TO_ADDR
// uc_nation := 0 ;
4104: LD_ADDR_OWVAR 21
4108: PUSH
4109: LD_INT 0
4111: ST_TO_ADDR
// for i = 1 to 4 do
4112: LD_ADDR_VAR 0 2
4116: PUSH
4117: DOUBLE
4118: LD_INT 1
4120: DEC
4121: ST_TO_ADDR
4122: LD_INT 4
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4157
// begin InitHc ;
4128: CALL_OW 19
// hc_class := class_apeman ;
4132: LD_ADDR_OWVAR 28
4136: PUSH
4137: LD_INT 12
4139: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4140: CALL_OW 44
4144: PPUSH
4145: LD_INT 13
4147: PPUSH
4148: LD_INT 0
4150: PPUSH
4151: CALL_OW 49
// end ;
4155: GO 4125
4157: POP
4158: POP
// end ; end_of_file
4159: LD_VAR 0 1
4163: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
// side := 8 ;
4171: LD_ADDR_VAR 0 3
4175: PUSH
4176: LD_INT 8
4178: ST_TO_ADDR
// uc_side := side ;
4179: LD_ADDR_OWVAR 20
4183: PUSH
4184: LD_VAR 0 3
4188: ST_TO_ADDR
// uc_nation := 2 ;
4189: LD_ADDR_OWVAR 21
4193: PUSH
4194: LD_INT 2
4196: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4197: LD_ADDR_VAR 0 2
4201: PUSH
4202: LD_INT 22
4204: PUSH
4205: LD_VAR 0 3
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 21
4216: PUSH
4217: LD_INT 3
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: PPUSH
4228: CALL_OW 69
4232: PUSH
4233: FOR_IN
4234: IFFALSE 4250
// SetBLevel ( i , 10 ) ;
4236: LD_VAR 0 2
4240: PPUSH
4241: LD_INT 10
4243: PPUSH
4244: CALL_OW 241
4248: GO 4233
4250: POP
4251: POP
// if KurtStatus then
4252: LD_EXP 3
4256: IFFALSE 4279
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4258: LD_ADDR_EXP 60
4262: PUSH
4263: LD_STRING Kurt
4265: PPUSH
4266: LD_INT 0
4268: PPUSH
4269: LD_STRING 
4271: PPUSH
4272: CALL 64741 0 3
4276: ST_TO_ADDR
4277: GO 4301
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4279: LD_ADDR_EXP 60
4283: PUSH
4284: LD_STRING AltKurt
4286: PPUSH
4287: LD_EXP 1
4291: NOT
4292: PPUSH
4293: LD_STRING 
4295: PPUSH
4296: CALL 64741 0 3
4300: ST_TO_ADDR
// if not Kurt then
4301: LD_EXP 60
4305: NOT
4306: IFFALSE 4332
// begin InitHc ;
4308: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4312: LD_INT 1
4314: PPUSH
4315: LD_INT 10
4317: PPUSH
4318: CALL_OW 381
// Kurt := CreateHuman ;
4322: LD_ADDR_EXP 60
4326: PUSH
4327: CALL_OW 44
4331: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4332: LD_EXP 60
4336: PPUSH
4337: LD_INT 324
4339: PPUSH
4340: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4344: LD_ADDR_EXP 61
4348: PUSH
4349: LD_STRING Kozlov
4351: PPUSH
4352: LD_INT 0
4354: PPUSH
4355: LD_STRING 
4357: PPUSH
4358: CALL 64741 0 3
4362: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4363: LD_EXP 61
4367: PPUSH
4368: LD_INT 22
4370: PUSH
4371: LD_INT 8
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: PUSH
4378: LD_INT 23
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 30
4390: PUSH
4391: LD_INT 8
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: LIST
4402: PPUSH
4403: CALL_OW 69
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4416: LD_EXP 61
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 10
4426: PPUSH
4427: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4431: LD_ADDR_VAR 0 5
4435: PUSH
4436: LD_INT 22
4438: PUSH
4439: LD_VAR 0 3
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: LD_INT 30
4450: PUSH
4451: LD_INT 32
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PUSH
4458: LD_INT 58
4460: PUSH
4461: EMPTY
4462: LIST
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: PPUSH
4469: CALL_OW 69
4473: ST_TO_ADDR
// for i = 1 to 10 do
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_INT 10
4486: PUSH
4487: FOR_TO
4488: IFFALSE 4560
// begin uc_nation := nation_nature ;
4490: LD_ADDR_OWVAR 21
4494: PUSH
4495: LD_INT 0
4497: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4498: LD_ADDR_OWVAR 28
4502: PUSH
4503: LD_INT 15
4505: ST_TO_ADDR
// hc_gallery :=  ;
4506: LD_ADDR_OWVAR 33
4510: PUSH
4511: LD_STRING 
4513: ST_TO_ADDR
// hc_name :=  ;
4514: LD_ADDR_OWVAR 26
4518: PUSH
4519: LD_STRING 
4521: ST_TO_ADDR
// un := CreateHuman ;
4522: LD_ADDR_VAR 0 4
4526: PUSH
4527: CALL_OW 44
4531: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4532: LD_VAR 0 4
4536: PPUSH
4537: LD_VAR 0 5
4541: PUSH
4542: LD_VAR 0 5
4546: PUSH
4547: LD_VAR 0 2
4551: MINUS
4552: ARRAY
4553: PPUSH
4554: CALL_OW 52
// end ;
4558: GO 4487
4560: POP
4561: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4562: LD_ADDR_VAR 0 5
4566: PUSH
4567: LD_STRING 12_kurt_squad
4569: PPUSH
4570: CALL_OW 31
4574: ST_TO_ADDR
// if tmp then
4575: LD_VAR 0 5
4579: IFFALSE 4613
// for i in tmp do
4581: LD_ADDR_VAR 0 2
4585: PUSH
4586: LD_VAR 0 5
4590: PUSH
4591: FOR_IN
4592: IFFALSE 4611
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4594: LD_VAR 0 2
4598: PPUSH
4599: LD_INT 5
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 49
4609: GO 4591
4611: POP
4612: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4613: LD_INT 324
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_STRING 
4621: PPUSH
4622: LD_INT 8
4624: PUSH
4625: LD_INT 9
4627: PUSH
4628: LD_INT 10
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: LIST
4635: PUSH
4636: LD_OWVAR 67
4640: ARRAY
4641: PPUSH
4642: LD_INT 3000
4644: PUSH
4645: LD_INT 500
4647: PUSH
4648: LD_INT 150
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: PPUSH
4656: LD_INT 16
4658: PUSH
4659: LD_INT 6
4661: PUSH
4662: LD_INT 6
4664: PUSH
4665: LD_INT 8
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: LIST
4673: PPUSH
4674: CALL 75265 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4678: LD_ADDR_EXP 102
4682: PUSH
4683: LD_EXP 102
4687: PPUSH
4688: LD_INT 3
4690: PPUSH
4691: LD_INT 22
4693: PUSH
4694: LD_VAR 0 3
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PUSH
4703: LD_INT 23
4705: PUSH
4706: LD_INT 2
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PUSH
4713: LD_INT 3
4715: PUSH
4716: LD_INT 21
4718: PUSH
4719: LD_INT 2
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: LIST
4734: PPUSH
4735: CALL_OW 69
4739: PUSH
4740: LD_EXP 60
4744: DIFF
4745: PPUSH
4746: CALL_OW 1
4750: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4751: LD_INT 1
4753: PPUSH
4754: LD_INT 7
4756: PPUSH
4757: CALL_OW 383
// Friend := CreateHuman ;
4761: LD_ADDR_EXP 62
4765: PUSH
4766: CALL_OW 44
4770: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4771: LD_INT 14
4773: PPUSH
4774: LD_INT 3
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 29
4782: PPUSH
4783: LD_INT 100
4785: PPUSH
4786: CALL 71856 0 5
// powellBomb := CreateVehicle ;
4790: LD_ADDR_EXP 63
4794: PUSH
4795: CALL_OW 45
4799: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4800: LD_EXP 63
4804: PPUSH
4805: LD_INT 90
4807: PPUSH
4808: LD_INT 51
4810: PPUSH
4811: LD_INT 0
4813: PPUSH
4814: CALL_OW 48
// end ;
4818: LD_VAR 0 1
4822: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4823: LD_INT 0
4825: PPUSH
4826: PPUSH
4827: PPUSH
// if IsLive ( kozlov_fac ) then
4828: LD_INT 332
4830: PPUSH
4831: CALL_OW 300
4835: IFFALSE 4839
// exit ;
4837: GO 5406
// ComExitBuilding ( Kozlov ) ;
4839: LD_EXP 61
4843: PPUSH
4844: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4848: LD_EXP 61
4852: PPUSH
4853: CALL_OW 257
4857: PUSH
4858: LD_INT 2
4860: NONEQUAL
4861: IFFALSE 4896
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4863: LD_EXP 61
4867: PPUSH
4868: LD_INT 324
4870: PPUSH
4871: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4875: LD_EXP 61
4879: PPUSH
4880: LD_INT 2
4882: PPUSH
4883: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4887: LD_EXP 61
4891: PPUSH
4892: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4896: LD_EXP 61
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: LD_INT 93
4906: PPUSH
4907: LD_INT 32
4909: PPUSH
4910: LD_INT 3
4912: PPUSH
4913: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4924: LD_INT 22
4926: PUSH
4927: LD_INT 8
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 30
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 23
4946: PUSH
4947: LD_INT 3
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 57
4956: PUSH
4957: EMPTY
4958: LIST
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PPUSH
4966: CALL_OW 69
4970: IFFALSE 4917
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4972: LD_ADDR_VAR 0 2
4976: PUSH
4977: LD_INT 22
4979: PUSH
4980: LD_INT 8
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: LD_INT 23
4999: PUSH
5000: LD_INT 3
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 57
5009: PUSH
5010: EMPTY
5011: LIST
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5028: LD_INT 22
5030: PUSH
5031: LD_INT 8
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 23
5040: PUSH
5041: LD_INT 3
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 30
5050: PUSH
5051: LD_INT 21
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: NOT
5068: IFFALSE 5146
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5070: LD_EXP 61
5074: PPUSH
5075: LD_INT 21
5077: PPUSH
5078: LD_INT 97
5080: PPUSH
5081: LD_INT 36
5083: PPUSH
5084: LD_INT 5
5086: PPUSH
5087: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5091: LD_INT 35
5093: PPUSH
5094: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5098: LD_INT 22
5100: PUSH
5101: LD_INT 8
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: PUSH
5108: LD_INT 23
5110: PUSH
5111: LD_INT 3
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PUSH
5118: LD_INT 30
5120: PUSH
5121: LD_INT 21
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PUSH
5128: LD_INT 57
5130: PUSH
5131: EMPTY
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: LIST
5138: LIST
5139: PPUSH
5140: CALL_OW 69
5144: IFFALSE 5091
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5146: LD_INT 22
5148: PUSH
5149: LD_INT 8
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 23
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 18
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: LIST
5180: PPUSH
5181: CALL_OW 69
5185: NOT
5186: IFFALSE 5264
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5188: LD_EXP 61
5192: PPUSH
5193: LD_INT 18
5195: PPUSH
5196: LD_INT 89
5198: PPUSH
5199: LD_INT 32
5201: PPUSH
5202: LD_INT 1
5204: PPUSH
5205: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5209: LD_INT 35
5211: PPUSH
5212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5216: LD_INT 22
5218: PUSH
5219: LD_INT 8
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 23
5228: PUSH
5229: LD_INT 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 30
5238: PUSH
5239: LD_INT 18
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 57
5248: PUSH
5249: EMPTY
5250: LIST
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PPUSH
5258: CALL_OW 69
5262: IFFALSE 5209
// end ; lab := kozlov_lab ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: LD_INT 336
5271: ST_TO_ADDR
// if not lab then
5272: LD_VAR 0 3
5276: NOT
5277: IFFALSE 5281
// exit ;
5279: GO 5406
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5281: LD_EXP 61
5285: PPUSH
5286: LD_VAR 0 3
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: PPUSH
5295: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5299: LD_EXP 61
5303: PPUSH
5304: LD_INT 4
5306: PPUSH
5307: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5311: LD_VAR 0 3
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 25
5322: PPUSH
5323: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5327: LD_INT 35
5329: PPUSH
5330: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5334: LD_INT 25
5336: PPUSH
5337: LD_INT 8
5339: PPUSH
5340: CALL_OW 321
5344: PUSH
5345: LD_INT 2
5347: EQUAL
5348: IFFALSE 5327
// ComExitBuilding ( Kozlov ) ;
5350: LD_EXP 61
5354: PPUSH
5355: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5359: LD_EXP 61
5363: PPUSH
5364: LD_VAR 0 2
5368: PPUSH
5369: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5373: LD_EXP 61
5377: PPUSH
5378: LD_INT 3
5380: PPUSH
5381: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5385: LD_VAR 0 2
5389: PPUSH
5390: LD_INT 23
5392: PPUSH
5393: LD_INT 3
5395: PPUSH
5396: LD_INT 1
5398: PPUSH
5399: LD_INT 48
5401: PPUSH
5402: CALL_OW 125
// end ;
5406: LD_VAR 0 1
5410: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5411: LD_EXP 22
5415: NOT
5416: PUSH
5417: LD_EXP 15
5421: PUSH
5422: LD_INT 6
5424: GREATEREQUAL
5425: AND
5426: IFFALSE 5507
5428: GO 5430
5430: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5431: LD_INT 3
5433: PPUSH
5434: LD_INT 3
5436: PPUSH
5437: CALL 58534 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5441: LD_INT 3
5443: PPUSH
5444: LD_INT 14
5446: PUSH
5447: LD_INT 1
5449: PUSH
5450: LD_INT 1
5452: PUSH
5453: LD_INT 28
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 14
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 28
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 14
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 28
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 58397 0 2
// end ;
5507: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: PUSH
5524: LD_INT 3
5526: PPUSH
5527: LD_INT 1
5529: PPUSH
5530: CALL 59815 0 2
5534: NOT
5535: AND
5536: IFFALSE 6376
5538: GO 5540
5540: DISABLE
5541: LD_INT 0
5543: PPUSH
5544: PPUSH
5545: PPUSH
// begin enable ;
5546: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5547: LD_INT 22
5549: PUSH
5550: LD_INT 8
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 23
5559: PUSH
5560: LD_INT 2
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 30
5569: PUSH
5570: LD_INT 3
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: NOT
5587: IFFALSE 5591
// exit ;
5589: GO 6376
// if Prob ( 40 ) then
5591: LD_INT 40
5593: PPUSH
5594: CALL_OW 13
5598: IFFALSE 5725
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5600: LD_INT 3
5602: PPUSH
5603: LD_INT 14
5605: PUSH
5606: LD_INT 1
5608: PUSH
5609: LD_INT 2
5611: PUSH
5612: LD_INT 28
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 28
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 2
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 26
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: PPUSH
5719: CALL 58397 0 2
// end else
5723: GO 5916
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5725: LD_INT 3
5727: PPUSH
5728: LD_INT 14
5730: PUSH
5731: LD_INT 1
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 27
5739: PUSH
5740: LD_INT 26
5742: PUSH
5743: LD_INT 26
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: PUSH
5763: LD_INT 14
5765: PUSH
5766: LD_INT 1
5768: PUSH
5769: LD_INT 2
5771: PUSH
5772: LD_INT 27
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: LD_INT 26
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: LIST
5785: PUSH
5786: LD_OWVAR 67
5790: ARRAY
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 14
5800: PUSH
5801: LD_INT 1
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: LD_INT 29
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_OWVAR 67
5825: ARRAY
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 13
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: LD_INT 2
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: LD_INT 29
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: PUSH
5856: LD_OWVAR 67
5860: ARRAY
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 13
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: LD_INT 2
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 14
5888: PUSH
5889: LD_INT 1
5891: PUSH
5892: LD_INT 2
5894: PUSH
5895: LD_INT 26
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: PPUSH
5912: CALL 58397 0 2
// end ; repeat wait ( 0 0$1 ) ;
5916: LD_INT 35
5918: PPUSH
5919: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5923: LD_INT 3
5925: PPUSH
5926: LD_INT 1
5928: PPUSH
5929: CALL 59815 0 2
5933: PUSH
5934: LD_INT 6
5936: GREATEREQUAL
5937: IFFALSE 5916
// wait ( 0 0$30 ) ;
5939: LD_INT 1050
5941: PPUSH
5942: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5946: LD_ADDR_VAR 0 2
5950: PUSH
5951: LD_INT 3
5953: PPUSH
5954: LD_INT 1
5956: PPUSH
5957: CALL 59815 0 2
5961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5962: LD_ADDR_EXP 121
5966: PUSH
5967: LD_EXP 121
5971: PPUSH
5972: LD_INT 3
5974: PPUSH
5975: LD_EXP 121
5979: PUSH
5980: LD_INT 3
5982: ARRAY
5983: PUSH
5984: LD_VAR 0 2
5988: DIFF
5989: PPUSH
5990: CALL_OW 1
5994: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 2
6005: PPUSH
6006: CALL_OW 12
6010: ST_TO_ADDR
// if target then
6011: LD_VAR 0 3
6015: IFFALSE 6143
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6017: LD_ADDR_VAR 0 2
6021: PUSH
6022: LD_VAR 0 2
6026: PPUSH
6027: LD_INT 24
6029: PUSH
6030: LD_INT 250
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: PPUSH
6037: CALL_OW 72
6041: ST_TO_ADDR
// for i in tmp do
6042: LD_ADDR_VAR 0 1
6046: PUSH
6047: LD_VAR 0 2
6051: PUSH
6052: FOR_IN
6053: IFFALSE 6093
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6055: LD_VAR 0 1
6059: PPUSH
6060: LD_INT 89
6062: PPUSH
6063: LD_INT 71
6065: PPUSH
6066: CALL_OW 297
6070: PUSH
6071: LD_INT 9
6073: GREATER
6074: IFFALSE 6091
// ComMoveXY ( i , 89 , 71 ) ;
6076: LD_VAR 0 1
6080: PPUSH
6081: LD_INT 89
6083: PPUSH
6084: LD_INT 71
6086: PPUSH
6087: CALL_OW 111
6091: GO 6052
6093: POP
6094: POP
// wait ( 0 0$1 ) ;
6095: LD_INT 35
6097: PPUSH
6098: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6102: LD_VAR 0 2
6106: PPUSH
6107: LD_INT 92
6109: PUSH
6110: LD_INT 89
6112: PUSH
6113: LD_INT 71
6115: PUSH
6116: LD_INT 9
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: CALL_OW 72
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_INT 1
6137: MINUS
6138: GREATEREQUAL
6139: IFFALSE 6017
// end else
6141: GO 6267
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6143: LD_ADDR_VAR 0 2
6147: PUSH
6148: LD_VAR 0 2
6152: PPUSH
6153: LD_INT 24
6155: PUSH
6156: LD_INT 250
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 72
6167: ST_TO_ADDR
// for i in tmp do
6168: LD_ADDR_VAR 0 1
6172: PUSH
6173: LD_VAR 0 2
6177: PUSH
6178: FOR_IN
6179: IFFALSE 6219
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6181: LD_VAR 0 1
6185: PPUSH
6186: LD_INT 125
6188: PPUSH
6189: LD_INT 129
6191: PPUSH
6192: CALL_OW 297
6196: PUSH
6197: LD_INT 9
6199: GREATER
6200: IFFALSE 6217
// ComMoveXY ( i , 125 , 129 ) ;
6202: LD_VAR 0 1
6206: PPUSH
6207: LD_INT 125
6209: PPUSH
6210: LD_INT 129
6212: PPUSH
6213: CALL_OW 111
6217: GO 6178
6219: POP
6220: POP
// wait ( 0 0$1 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6228: LD_VAR 0 2
6232: PPUSH
6233: LD_INT 92
6235: PUSH
6236: LD_INT 125
6238: PUSH
6239: LD_INT 129
6241: PUSH
6242: LD_INT 9
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: PUSH
6256: LD_VAR 0 2
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: GREATEREQUAL
6265: IFFALSE 6143
// end ; repeat wait ( 0 0$1 ) ;
6267: LD_INT 35
6269: PPUSH
6270: CALL_OW 67
// for i in tmp do
6274: LD_ADDR_VAR 0 1
6278: PUSH
6279: LD_VAR 0 2
6283: PUSH
6284: FOR_IN
6285: IFFALSE 6367
// begin if GetLives ( i ) > 251 then
6287: LD_VAR 0 1
6291: PPUSH
6292: CALL_OW 256
6296: PUSH
6297: LD_INT 251
6299: GREATER
6300: IFFALSE 6338
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6302: LD_VAR 0 1
6306: PPUSH
6307: LD_INT 81
6309: PUSH
6310: LD_INT 8
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 69
6321: PPUSH
6322: LD_VAR 0 1
6326: PPUSH
6327: CALL_OW 74
6331: PPUSH
6332: CALL_OW 115
6336: GO 6365
// if IsDead ( i ) then
6338: LD_VAR 0 1
6342: PPUSH
6343: CALL_OW 301
6347: IFFALSE 6365
// tmp := tmp diff i ;
6349: LD_ADDR_VAR 0 2
6353: PUSH
6354: LD_VAR 0 2
6358: PUSH
6359: LD_VAR 0 1
6363: DIFF
6364: ST_TO_ADDR
// end ;
6365: GO 6284
6367: POP
6368: POP
// until not tmp ;
6369: LD_VAR 0 2
6373: NOT
6374: IFFALSE 6267
// end ;
6376: PPOPN 3
6378: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6379: LD_EXP 22
6383: NOT
6384: PUSH
6385: LD_EXP 15
6389: PUSH
6390: LD_INT 6
6392: GREATEREQUAL
6393: AND
6394: PUSH
6395: LD_OWVAR 67
6399: PUSH
6400: LD_INT 1
6402: GREATER
6403: AND
6404: IFFALSE 6921
6406: GO 6408
6408: DISABLE
6409: LD_INT 0
6411: PPUSH
6412: PPUSH
6413: PPUSH
// begin enable ;
6414: ENABLE
// tmp := [ ] ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: EMPTY
6421: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6422: LD_ADDR_VAR 0 1
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_INT 4
6434: PUSH
6435: LD_INT 6
6437: PUSH
6438: LD_INT 7
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_OWVAR 67
6450: ARRAY
6451: PUSH
6452: FOR_TO
6453: IFFALSE 6613
// begin uc_side := 8 ;
6455: LD_ADDR_OWVAR 20
6459: PUSH
6460: LD_INT 8
6462: ST_TO_ADDR
// uc_nation := 2 ;
6463: LD_ADDR_OWVAR 21
6467: PUSH
6468: LD_INT 2
6470: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6471: LD_INT 13
6473: PUSH
6474: LD_INT 14
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_INT 2
6486: PPUSH
6487: CALL_OW 12
6491: ARRAY
6492: PPUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 5
6498: PPUSH
6499: LD_INT 27
6501: PUSH
6502: LD_INT 28
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: LD_INT 25
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: LIST
6515: LIST
6516: PUSH
6517: LD_INT 1
6519: PPUSH
6520: LD_INT 4
6522: PPUSH
6523: CALL_OW 12
6527: ARRAY
6528: PPUSH
6529: LD_INT 88
6531: PPUSH
6532: CALL 71856 0 5
// un := CreateVehicle ;
6536: LD_ADDR_VAR 0 2
6540: PUSH
6541: CALL_OW 45
6545: ST_TO_ADDR
// tmp := tmp ^ un ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_VAR 0 2
6560: ADD
6561: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6562: LD_VAR 0 2
6566: PPUSH
6567: LD_INT 3
6569: PPUSH
6570: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6574: LD_VAR 0 2
6578: PPUSH
6579: LD_INT 30
6581: PPUSH
6582: LD_INT 0
6584: PPUSH
6585: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: LD_INT 16
6596: PPUSH
6597: LD_INT 11
6599: PPUSH
6600: CALL_OW 111
// wait ( 0 0$2 ) ;
6604: LD_INT 70
6606: PPUSH
6607: CALL_OW 67
// end ;
6611: GO 6452
6613: POP
6614: POP
// for i = 1 to Difficulty do
6615: LD_ADDR_VAR 0 1
6619: PUSH
6620: DOUBLE
6621: LD_INT 1
6623: DEC
6624: ST_TO_ADDR
6625: LD_OWVAR 67
6629: PUSH
6630: FOR_TO
6631: IFFALSE 6756
// begin uc_side := 8 ;
6633: LD_ADDR_OWVAR 20
6637: PUSH
6638: LD_INT 8
6640: ST_TO_ADDR
// uc_nation := 2 ;
6641: LD_ADDR_OWVAR 21
6645: PUSH
6646: LD_INT 2
6648: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6649: LD_INT 0
6651: PPUSH
6652: LD_INT 8
6654: PPUSH
6655: LD_INT 8
6657: PUSH
6658: LD_INT 8
6660: PUSH
6661: LD_INT 9
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_OWVAR 67
6673: ARRAY
6674: PPUSH
6675: CALL_OW 380
// un := CreateHuman ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 44
6688: ST_TO_ADDR
// tmp := tmp ^ un ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PUSH
6699: LD_VAR 0 2
6703: ADD
6704: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6705: LD_VAR 0 2
6709: PPUSH
6710: LD_INT 3
6712: PPUSH
6713: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6717: LD_VAR 0 2
6721: PPUSH
6722: LD_INT 30
6724: PPUSH
6725: LD_INT 0
6727: PPUSH
6728: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 16
6739: PPUSH
6740: LD_INT 11
6742: PPUSH
6743: CALL_OW 111
// wait ( 0 0$2 ) ;
6747: LD_INT 70
6749: PPUSH
6750: CALL_OW 67
// end ;
6754: GO 6630
6756: POP
6757: POP
// repeat wait ( 0 0$1 ) ;
6758: LD_INT 35
6760: PPUSH
6761: CALL_OW 67
// for i in tmp do
6765: LD_ADDR_VAR 0 1
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: FOR_IN
6776: IFFALSE 6912
// begin if GetLives ( i ) > 250 then
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 256
6787: PUSH
6788: LD_INT 250
6790: GREATER
6791: IFFALSE 6883
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6793: LD_INT 81
6795: PUSH
6796: LD_INT 8
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: PUSH
6803: LD_INT 91
6805: PUSH
6806: LD_VAR 0 1
6810: PUSH
6811: LD_INT 10
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: LIST
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PPUSH
6823: CALL_OW 69
6827: NOT
6828: IFFALSE 6847
// ComAgressiveMove ( i , 67 , 110 ) else
6830: LD_VAR 0 1
6834: PPUSH
6835: LD_INT 67
6837: PPUSH
6838: LD_INT 110
6840: PPUSH
6841: CALL_OW 114
6845: GO 6881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 81
6854: PUSH
6855: LD_INT 8
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PPUSH
6862: CALL_OW 69
6866: PPUSH
6867: LD_VAR 0 1
6871: PPUSH
6872: CALL_OW 74
6876: PPUSH
6877: CALL_OW 115
// end else
6881: GO 6910
// if IsDead ( i ) then
6883: LD_VAR 0 1
6887: PPUSH
6888: CALL_OW 301
6892: IFFALSE 6910
// tmp := tmp diff i ;
6894: LD_ADDR_VAR 0 3
6898: PUSH
6899: LD_VAR 0 3
6903: PUSH
6904: LD_VAR 0 1
6908: DIFF
6909: ST_TO_ADDR
// end ;
6910: GO 6775
6912: POP
6913: POP
// until not tmp ;
6914: LD_VAR 0 3
6918: NOT
6919: IFFALSE 6758
// end ; end_of_file
6921: PPOPN 3
6923: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
6932: PPUSH
6933: PPUSH
6934: PPUSH
// side := 3 ;
6935: LD_ADDR_VAR 0 6
6939: PUSH
6940: LD_INT 3
6942: ST_TO_ADDR
// uc_side := side ;
6943: LD_ADDR_OWVAR 20
6947: PUSH
6948: LD_VAR 0 6
6952: ST_TO_ADDR
// uc_nation := 3 ;
6953: LD_ADDR_OWVAR 21
6957: PUSH
6958: LD_INT 3
6960: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_VAR 0 6
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PUSH
6978: LD_INT 21
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PPUSH
6992: CALL_OW 69
6996: PUSH
6997: FOR_IN
6998: IFFALSE 7014
// SetBLevel ( i , 10 ) ;
7000: LD_VAR 0 2
7004: PPUSH
7005: LD_INT 10
7007: PPUSH
7008: CALL_OW 241
7012: GO 6997
7014: POP
7015: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7016: LD_ADDR_VAR 0 9
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 6
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 30
7035: PUSH
7036: LD_INT 34
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: CALL_OW 69
7051: ST_TO_ADDR
// if teleport then
7052: LD_VAR 0 9
7056: IFFALSE 7077
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7058: LD_VAR 0 9
7062: PUSH
7063: LD_INT 1
7065: ARRAY
7066: PPUSH
7067: LD_INT 123
7069: PPUSH
7070: LD_INT 122
7072: PPUSH
7073: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7077: LD_ADDR_EXP 64
7081: PUSH
7082: LD_STRING Platonov
7084: PPUSH
7085: CALL_OW 25
7089: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7090: LD_ADDR_EXP 65
7094: PUSH
7095: LD_STRING Kovalyuk
7097: PPUSH
7098: CALL_OW 25
7102: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7103: LD_ADDR_EXP 67
7107: PUSH
7108: LD_STRING Yakotich
7110: PPUSH
7111: CALL_OW 25
7115: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7116: LD_ADDR_EXP 66
7120: PUSH
7121: LD_STRING Bystrov
7123: PPUSH
7124: CALL_OW 25
7128: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7129: LD_ADDR_EXP 68
7133: PUSH
7134: LD_STRING Gleb
7136: PPUSH
7137: CALL_OW 25
7141: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7142: LD_STRING 03_Cornel
7144: PPUSH
7145: CALL_OW 28
7149: IFFALSE 7197
// begin Bierezov := NewCharacter ( Mikhail ) ;
7151: LD_ADDR_EXP 69
7155: PUSH
7156: LD_STRING Mikhail
7158: PPUSH
7159: CALL_OW 25
7163: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7164: LD_EXP 69
7168: PPUSH
7169: LD_INT 197
7171: PPUSH
7172: LD_INT 111
7174: PPUSH
7175: LD_INT 9
7177: PPUSH
7178: LD_INT 0
7180: PPUSH
7181: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7185: LD_EXP 69
7189: PPUSH
7190: LD_INT 3
7192: PPUSH
7193: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7197: LD_EXP 64
7201: PPUSH
7202: LD_INT 126
7204: PPUSH
7205: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7209: LD_EXP 65
7213: PPUSH
7214: LD_INT 134
7216: PPUSH
7217: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7221: LD_EXP 67
7225: PPUSH
7226: LD_INT 197
7228: PPUSH
7229: LD_INT 111
7231: PPUSH
7232: LD_INT 9
7234: PPUSH
7235: LD_INT 0
7237: PPUSH
7238: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7242: LD_EXP 66
7246: PPUSH
7247: LD_INT 197
7249: PPUSH
7250: LD_INT 111
7252: PPUSH
7253: LD_INT 9
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7263: LD_EXP 68
7267: PPUSH
7268: LD_INT 197
7270: PPUSH
7271: LD_INT 111
7273: PPUSH
7274: LD_INT 9
7276: PPUSH
7277: LD_INT 0
7279: PPUSH
7280: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7284: LD_ADDR_VAR 0 5
7288: PUSH
7289: LD_INT 126
7291: PPUSH
7292: LD_INT 4
7294: PPUSH
7295: LD_STRING zhukov
7297: PPUSH
7298: LD_INT 9
7300: PUSH
7301: LD_INT 10
7303: PUSH
7304: LD_INT 10
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: LIST
7311: PUSH
7312: LD_OWVAR 67
7316: ARRAY
7317: PPUSH
7318: LD_INT 90000
7320: PUSH
7321: LD_INT 1000
7323: PUSH
7324: LD_INT 300
7326: PUSH
7327: EMPTY
7328: LIST
7329: LIST
7330: LIST
7331: PPUSH
7332: LD_INT 21
7334: PUSH
7335: LD_INT 8
7337: PUSH
7338: LD_INT 13
7340: PUSH
7341: LD_INT 8
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: PPUSH
7350: CALL 75265 0 6
7354: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7355: LD_ADDR_VAR 0 4
7359: PUSH
7360: LD_INT 267
7362: PPUSH
7363: CALL_OW 274
7367: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7368: LD_VAR 0 4
7372: PPUSH
7373: LD_INT 1
7375: PPUSH
7376: LD_INT 5000
7378: PPUSH
7379: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7383: LD_VAR 0 4
7387: PPUSH
7388: LD_INT 2
7390: PPUSH
7391: LD_INT 200
7393: PPUSH
7394: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7398: LD_VAR 0 4
7402: PPUSH
7403: LD_INT 3
7405: PPUSH
7406: LD_INT 200
7408: PPUSH
7409: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7413: LD_ADDR_EXP 102
7417: PUSH
7418: LD_EXP 102
7422: PPUSH
7423: LD_INT 2
7425: PPUSH
7426: LD_VAR 0 5
7430: PUSH
7431: LD_INT 22
7433: PUSH
7434: LD_VAR 0 6
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: PUSH
7443: LD_INT 3
7445: PUSH
7446: LD_INT 21
7448: PUSH
7449: LD_INT 2
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL_OW 69
7468: UNION
7469: PUSH
7470: LD_EXP 64
7474: DIFF
7475: PPUSH
7476: CALL_OW 1
7480: ST_TO_ADDR
// behemoths := [ ] ;
7481: LD_ADDR_EXP 72
7485: PUSH
7486: EMPTY
7487: ST_TO_ADDR
// behemothBuilders := [ ] ;
7488: LD_ADDR_EXP 73
7492: PUSH
7493: EMPTY
7494: ST_TO_ADDR
// if Kovalyuk then
7495: LD_EXP 65
7499: IFFALSE 7521
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7501: LD_ADDR_EXP 73
7505: PUSH
7506: LD_EXP 73
7510: PPUSH
7511: LD_EXP 65
7515: PPUSH
7516: CALL 107604 0 2
7520: ST_TO_ADDR
// j := 3 ;
7521: LD_ADDR_VAR 0 3
7525: PUSH
7526: LD_INT 3
7528: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7529: LD_ADDR_VAR 0 2
7533: PUSH
7534: LD_INT 22
7536: PUSH
7537: LD_INT 3
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 25
7546: PUSH
7547: LD_INT 3
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PPUSH
7558: CALL_OW 69
7562: PUSH
7563: LD_EXP 65
7567: DIFF
7568: PUSH
7569: FOR_IN
7570: IFFALSE 7620
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7572: LD_ADDR_EXP 73
7576: PUSH
7577: LD_EXP 73
7581: PPUSH
7582: LD_VAR 0 2
7586: PPUSH
7587: CALL 107604 0 2
7591: ST_TO_ADDR
// j := j - 1 ;
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_VAR 0 3
7601: PUSH
7602: LD_INT 1
7604: MINUS
7605: ST_TO_ADDR
// if j = 0 then
7606: LD_VAR 0 3
7610: PUSH
7611: LD_INT 0
7613: EQUAL
7614: IFFALSE 7618
// break ;
7616: GO 7620
// end ;
7618: GO 7569
7620: POP
7621: POP
// end ;
7622: LD_VAR 0 1
7626: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7627: LD_INT 0
7629: PPUSH
7630: PPUSH
7631: PPUSH
7632: PPUSH
7633: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7634: LD_ADDR_VAR 0 4
7638: PUSH
7639: LD_INT 209
7641: PUSH
7642: LD_INT 149
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: LD_INT 219
7651: PUSH
7652: LD_INT 154
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 223
7661: PUSH
7662: LD_INT 149
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: PUSH
7669: LD_INT 232
7671: PUSH
7672: LD_INT 155
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: LIST
7683: LIST
7684: ST_TO_ADDR
// if not behemothBuilders then
7685: LD_EXP 73
7689: NOT
7690: IFFALSE 7694
// exit ;
7692: GO 7798
// j := 1 ;
7694: LD_ADDR_VAR 0 3
7698: PUSH
7699: LD_INT 1
7701: ST_TO_ADDR
// for i in behemothBuilders do
7702: LD_ADDR_VAR 0 2
7706: PUSH
7707: LD_EXP 73
7711: PUSH
7712: FOR_IN
7713: IFFALSE 7796
// begin if IsInUnit ( i ) then
7715: LD_VAR 0 2
7719: PPUSH
7720: CALL_OW 310
7724: IFFALSE 7735
// ComExitBuilding ( i ) ;
7726: LD_VAR 0 2
7730: PPUSH
7731: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7735: LD_VAR 0 2
7739: PPUSH
7740: LD_INT 37
7742: PPUSH
7743: LD_VAR 0 4
7747: PUSH
7748: LD_VAR 0 3
7752: ARRAY
7753: PUSH
7754: LD_INT 1
7756: ARRAY
7757: PPUSH
7758: LD_VAR 0 4
7762: PUSH
7763: LD_VAR 0 3
7767: ARRAY
7768: PUSH
7769: LD_INT 2
7771: ARRAY
7772: PPUSH
7773: LD_INT 0
7775: PPUSH
7776: CALL_OW 230
// j := j + 1 ;
7780: LD_ADDR_VAR 0 3
7784: PUSH
7785: LD_VAR 0 3
7789: PUSH
7790: LD_INT 1
7792: PLUS
7793: ST_TO_ADDR
// end ;
7794: GO 7712
7796: POP
7797: POP
// end ;
7798: LD_VAR 0 1
7802: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7803: LD_INT 24
7805: PPUSH
7806: LD_INT 30
7808: PUSH
7809: LD_INT 37
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 70
7820: IFFALSE 7833
7822: GO 7824
7824: DISABLE
// behemothUnderConstruct := true ;
7825: LD_ADDR_EXP 26
7829: PUSH
7830: LD_INT 1
7832: ST_TO_ADDR
7833: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7834: LD_INT 3
7836: PPUSH
7837: CALL 107652 0 1
7841: PUSH
7842: LD_INT 22
7844: PUSH
7845: LD_INT 3
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PUSH
7852: LD_INT 30
7854: PUSH
7855: LD_INT 37
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: NOT
7871: AND
7872: IFFALSE 8058
7874: GO 7876
7876: DISABLE
7877: LD_INT 0
7879: PPUSH
7880: PPUSH
// begin enable ;
7881: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7882: LD_ADDR_VAR 0 2
7886: PUSH
7887: LD_INT 3
7889: PPUSH
7890: CALL 107652 0 1
7894: ST_TO_ADDR
// for i in tmp do
7895: LD_ADDR_VAR 0 1
7899: PUSH
7900: LD_VAR 0 2
7904: PUSH
7905: FOR_IN
7906: IFFALSE 8056
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7908: LD_VAR 0 1
7912: PPUSH
7913: LD_INT 9
7915: PPUSH
7916: CALL_OW 308
7920: PUSH
7921: LD_VAR 0 1
7925: PPUSH
7926: CALL_OW 110
7930: PUSH
7931: LD_INT 2
7933: EQUAL
7934: NOT
7935: AND
7936: IFFALSE 7950
// SetTag ( i , 2 ) ;
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_INT 2
7945: PPUSH
7946: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7950: LD_INT 81
7952: PUSH
7953: LD_INT 3
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PUSH
7960: LD_INT 91
7962: PUSH
7963: LD_VAR 0 1
7967: PUSH
7968: LD_INT 12
7970: PUSH
7971: EMPTY
7972: LIST
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PPUSH
7980: CALL_OW 69
7984: NOT
7985: PUSH
7986: LD_VAR 0 1
7990: PPUSH
7991: CALL_OW 110
7995: PUSH
7996: LD_INT 2
7998: EQUAL
7999: NOT
8000: AND
8001: IFFALSE 8020
// ComAgressiveMove ( i , 64 , 93 ) else
8003: LD_VAR 0 1
8007: PPUSH
8008: LD_INT 64
8010: PPUSH
8011: LD_INT 93
8013: PPUSH
8014: CALL_OW 114
8018: GO 8054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8020: LD_VAR 0 1
8024: PPUSH
8025: LD_INT 81
8027: PUSH
8028: LD_INT 3
8030: PUSH
8031: EMPTY
8032: LIST
8033: LIST
8034: PPUSH
8035: CALL_OW 69
8039: PPUSH
8040: LD_VAR 0 1
8044: PPUSH
8045: CALL_OW 74
8049: PPUSH
8050: CALL_OW 115
// end ;
8054: GO 7905
8056: POP
8057: POP
// end ;
8058: PPOPN 2
8060: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8061: LD_INT 0
8063: PPUSH
8064: PPUSH
8065: PPUSH
// result := [ ] ;
8066: LD_ADDR_VAR 0 2
8070: PUSH
8071: EMPTY
8072: ST_TO_ADDR
// uc_side := 6 ;
8073: LD_ADDR_OWVAR 20
8077: PUSH
8078: LD_INT 6
8080: ST_TO_ADDR
// uc_nation := 3 ;
8081: LD_ADDR_OWVAR 21
8085: PUSH
8086: LD_INT 3
8088: ST_TO_ADDR
// case strength of 1 :
8089: LD_VAR 0 1
8093: PUSH
8094: LD_INT 1
8096: DOUBLE
8097: EQUAL
8098: IFTRUE 8102
8100: GO 8240
8102: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8103: LD_ADDR_VAR 0 3
8107: PUSH
8108: DOUBLE
8109: LD_INT 1
8111: DEC
8112: ST_TO_ADDR
8113: LD_INT 4
8115: PUSH
8116: LD_INT 5
8118: PUSH
8119: LD_INT 6
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PUSH
8133: FOR_TO
8134: IFFALSE 8236
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8136: LD_INT 22
8138: PUSH
8139: LD_INT 24
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PUSH
8146: LD_VAR 0 3
8150: PUSH
8151: LD_INT 2
8153: MOD
8154: PUSH
8155: LD_INT 1
8157: PLUS
8158: ARRAY
8159: PPUSH
8160: LD_INT 1
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: LD_INT 1
8172: PPUSH
8173: LD_INT 2
8175: PPUSH
8176: CALL_OW 12
8180: ARRAY
8181: PPUSH
8182: LD_INT 3
8184: PPUSH
8185: LD_INT 43
8187: PUSH
8188: LD_INT 44
8190: PUSH
8191: LD_INT 45
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: PUSH
8199: LD_INT 1
8201: PPUSH
8202: LD_INT 3
8204: PPUSH
8205: CALL_OW 12
8209: ARRAY
8210: PPUSH
8211: LD_INT 80
8213: PPUSH
8214: CALL 71856 0 5
// result := result union CreateVehicle ;
8218: LD_ADDR_VAR 0 2
8222: PUSH
8223: LD_VAR 0 2
8227: PUSH
8228: CALL_OW 45
8232: UNION
8233: ST_TO_ADDR
// end ;
8234: GO 8133
8236: POP
8237: POP
// end ; 2 :
8238: GO 9184
8240: LD_INT 2
8242: DOUBLE
8243: EQUAL
8244: IFTRUE 8248
8246: GO 8404
8248: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8249: LD_ADDR_VAR 0 3
8253: PUSH
8254: DOUBLE
8255: LD_INT 1
8257: DEC
8258: ST_TO_ADDR
8259: LD_INT 5
8261: PUSH
8262: LD_INT 6
8264: PUSH
8265: LD_INT 7
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: LIST
8272: PUSH
8273: LD_OWVAR 67
8277: ARRAY
8278: PUSH
8279: FOR_TO
8280: IFFALSE 8400
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8282: LD_INT 22
8284: PUSH
8285: LD_INT 24
8287: PUSH
8288: LD_INT 24
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: LIST
8295: PUSH
8296: LD_VAR 0 3
8300: PUSH
8301: LD_INT 3
8303: MOD
8304: PUSH
8305: LD_INT 1
8307: PLUS
8308: ARRAY
8309: PPUSH
8310: LD_INT 1
8312: PUSH
8313: LD_INT 3
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PUSH
8320: LD_INT 1
8322: PPUSH
8323: LD_INT 2
8325: PPUSH
8326: CALL_OW 12
8330: ARRAY
8331: PPUSH
8332: LD_INT 3
8334: PPUSH
8335: LD_INT 43
8337: PUSH
8338: LD_INT 44
8340: PUSH
8341: LD_INT 45
8343: PUSH
8344: LD_INT 44
8346: PUSH
8347: LD_INT 46
8349: PUSH
8350: LD_INT 46
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: PUSH
8361: LD_VAR 0 3
8365: PUSH
8366: LD_INT 6
8368: MOD
8369: PUSH
8370: LD_INT 1
8372: PLUS
8373: ARRAY
8374: PPUSH
8375: LD_INT 80
8377: PPUSH
8378: CALL 71856 0 5
// result := result union CreateVehicle ;
8382: LD_ADDR_VAR 0 2
8386: PUSH
8387: LD_VAR 0 2
8391: PUSH
8392: CALL_OW 45
8396: UNION
8397: ST_TO_ADDR
// end ;
8398: GO 8279
8400: POP
8401: POP
// end ; 3 :
8402: GO 9184
8404: LD_INT 3
8406: DOUBLE
8407: EQUAL
8408: IFTRUE 8412
8410: GO 8568
8412: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8413: LD_ADDR_VAR 0 3
8417: PUSH
8418: DOUBLE
8419: LD_INT 1
8421: DEC
8422: ST_TO_ADDR
8423: LD_INT 5
8425: PUSH
8426: LD_INT 7
8428: PUSH
8429: LD_INT 8
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: PUSH
8437: LD_OWVAR 67
8441: ARRAY
8442: PUSH
8443: FOR_TO
8444: IFFALSE 8564
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8446: LD_INT 22
8448: PUSH
8449: LD_INT 24
8451: PUSH
8452: LD_INT 24
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: LIST
8459: PUSH
8460: LD_VAR 0 3
8464: PUSH
8465: LD_INT 3
8467: MOD
8468: PUSH
8469: LD_INT 1
8471: PLUS
8472: ARRAY
8473: PPUSH
8474: LD_INT 1
8476: PUSH
8477: LD_INT 3
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: LD_INT 1
8486: PPUSH
8487: LD_INT 2
8489: PPUSH
8490: CALL_OW 12
8494: ARRAY
8495: PPUSH
8496: LD_INT 3
8498: PPUSH
8499: LD_INT 43
8501: PUSH
8502: LD_INT 47
8504: PUSH
8505: LD_INT 45
8507: PUSH
8508: LD_INT 45
8510: PUSH
8511: LD_INT 46
8513: PUSH
8514: LD_INT 46
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: LIST
8524: PUSH
8525: LD_VAR 0 3
8529: PUSH
8530: LD_INT 6
8532: MOD
8533: PUSH
8534: LD_INT 1
8536: PLUS
8537: ARRAY
8538: PPUSH
8539: LD_INT 80
8541: PPUSH
8542: CALL 71856 0 5
// result := result union CreateVehicle ;
8546: LD_ADDR_VAR 0 2
8550: PUSH
8551: LD_VAR 0 2
8555: PUSH
8556: CALL_OW 45
8560: UNION
8561: ST_TO_ADDR
// end ;
8562: GO 8443
8564: POP
8565: POP
// end ; 4 :
8566: GO 9184
8568: LD_INT 4
8570: DOUBLE
8571: EQUAL
8572: IFTRUE 8576
8574: GO 9183
8576: POP
// begin uc_nation := 3 ;
8577: LD_ADDR_OWVAR 21
8581: PUSH
8582: LD_INT 3
8584: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8585: LD_ADDR_VAR 0 3
8589: PUSH
8590: DOUBLE
8591: LD_INT 1
8593: DEC
8594: ST_TO_ADDR
8595: LD_INT 6
8597: PUSH
8598: LD_INT 8
8600: PUSH
8601: LD_INT 9
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: LIST
8608: PUSH
8609: LD_OWVAR 67
8613: ARRAY
8614: PUSH
8615: FOR_TO
8616: IFFALSE 8736
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8618: LD_INT 22
8620: PUSH
8621: LD_INT 24
8623: PUSH
8624: LD_INT 24
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_VAR 0 3
8636: PUSH
8637: LD_INT 3
8639: MOD
8640: PUSH
8641: LD_INT 1
8643: PLUS
8644: ARRAY
8645: PPUSH
8646: LD_INT 1
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: LD_INT 1
8658: PPUSH
8659: LD_INT 2
8661: PPUSH
8662: CALL_OW 12
8666: ARRAY
8667: PPUSH
8668: LD_INT 3
8670: PPUSH
8671: LD_INT 45
8673: PUSH
8674: LD_INT 47
8676: PUSH
8677: LD_INT 47
8679: PUSH
8680: LD_INT 45
8682: PUSH
8683: LD_INT 46
8685: PUSH
8686: LD_INT 46
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: LIST
8695: LIST
8696: PUSH
8697: LD_VAR 0 3
8701: PUSH
8702: LD_INT 6
8704: MOD
8705: PUSH
8706: LD_INT 1
8708: PLUS
8709: ARRAY
8710: PPUSH
8711: LD_INT 80
8713: PPUSH
8714: CALL 71856 0 5
// result := result union CreateVehicle ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_VAR 0 2
8727: PUSH
8728: CALL_OW 45
8732: UNION
8733: ST_TO_ADDR
// end ;
8734: GO 8615
8736: POP
8737: POP
// if not KappaStatus then
8738: LD_EXP 2
8742: NOT
8743: IFFALSE 8978
// begin uc_nation := 1 ;
8745: LD_ADDR_OWVAR 21
8749: PUSH
8750: LD_INT 1
8752: ST_TO_ADDR
// for i = 1 to 3 do
8753: LD_ADDR_VAR 0 3
8757: PUSH
8758: DOUBLE
8759: LD_INT 1
8761: DEC
8762: ST_TO_ADDR
8763: LD_INT 3
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8903
// begin j := rand ( 0 , 1 ) ;
8769: LD_ADDR_VAR 0 4
8773: PUSH
8774: LD_INT 0
8776: PPUSH
8777: LD_INT 1
8779: PPUSH
8780: CALL_OW 12
8784: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8785: LD_INT 3
8787: PUSH
8788: LD_INT 5
8790: PUSH
8791: LD_INT 5
8793: PUSH
8794: LD_INT 4
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: LIST
8802: PUSH
8803: LD_VAR 0 4
8807: PUSH
8808: LD_INT 1
8810: PPUSH
8811: LD_INT 3
8813: PPUSH
8814: CALL_OW 12
8818: PLUS
8819: ARRAY
8820: PPUSH
8821: LD_INT 1
8823: PUSH
8824: LD_INT 3
8826: PUSH
8827: EMPTY
8828: LIST
8829: LIST
8830: PUSH
8831: LD_INT 1
8833: PPUSH
8834: LD_INT 2
8836: PPUSH
8837: CALL_OW 12
8841: ARRAY
8842: PPUSH
8843: LD_INT 3
8845: PPUSH
8846: LD_INT 9
8848: PUSH
8849: LD_INT 7
8851: PUSH
8852: LD_INT 6
8854: PUSH
8855: EMPTY
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_VAR 0 4
8864: PUSH
8865: LD_INT 1
8867: PPUSH
8868: LD_INT 2
8870: PPUSH
8871: CALL_OW 12
8875: PLUS
8876: ARRAY
8877: PPUSH
8878: LD_INT 85
8880: PPUSH
8881: CALL 71856 0 5
// result := result union CreateVehicle ;
8885: LD_ADDR_VAR 0 2
8889: PUSH
8890: LD_VAR 0 2
8894: PUSH
8895: CALL_OW 45
8899: UNION
8900: ST_TO_ADDR
// end ;
8901: GO 8766
8903: POP
8904: POP
// if vsevolodFirstAttack then
8905: LD_EXP 24
8909: IFFALSE 8976
// begin vsevolodFirstAttack := false ;
8911: LD_ADDR_EXP 24
8915: PUSH
8916: LD_INT 0
8918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8919: LD_INT 5
8921: PPUSH
8922: LD_INT 3
8924: PPUSH
8925: LD_INT 1
8927: PPUSH
8928: LD_INT 6
8930: PPUSH
8931: LD_INT 100
8933: PPUSH
8934: CALL 71856 0 5
// sewiVeh := CreateVehicle ;
8938: LD_ADDR_EXP 71
8942: PUSH
8943: CALL_OW 45
8947: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8948: LD_EXP 71
8952: PPUSH
8953: LD_INT 1
8955: PPUSH
8956: CALL_OW 242
// result := result union sewiVeh ;
8960: LD_ADDR_VAR 0 2
8964: PUSH
8965: LD_VAR 0 2
8969: PUSH
8970: LD_EXP 71
8974: UNION
8975: ST_TO_ADDR
// end ; end else
8976: GO 9181
// if vsevolodFirstAttack then
8978: LD_EXP 24
8982: IFFALSE 9181
// begin vsevolodFirstAttack := false ;
8984: LD_ADDR_EXP 24
8988: PUSH
8989: LD_INT 0
8991: ST_TO_ADDR
// uc_nation := 3 ;
8992: LD_ADDR_OWVAR 21
8996: PUSH
8997: LD_INT 3
8999: ST_TO_ADDR
// for i = 1 to 3 do
9000: LD_ADDR_VAR 0 3
9004: PUSH
9005: DOUBLE
9006: LD_INT 1
9008: DEC
9009: ST_TO_ADDR
9010: LD_INT 3
9012: PUSH
9013: FOR_TO
9014: IFFALSE 9122
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9016: LD_INT 22
9018: PUSH
9019: LD_INT 24
9021: PUSH
9022: LD_INT 24
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: LIST
9029: PUSH
9030: LD_VAR 0 3
9034: PUSH
9035: LD_INT 3
9037: MOD
9038: PUSH
9039: LD_INT 1
9041: PLUS
9042: ARRAY
9043: PPUSH
9044: LD_INT 1
9046: PUSH
9047: LD_INT 3
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: LD_INT 1
9056: PPUSH
9057: LD_INT 2
9059: PPUSH
9060: CALL_OW 12
9064: ARRAY
9065: PPUSH
9066: LD_INT 3
9068: PPUSH
9069: LD_INT 45
9071: PUSH
9072: LD_INT 47
9074: PUSH
9075: LD_INT 47
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: LIST
9082: PUSH
9083: LD_VAR 0 3
9087: PUSH
9088: LD_INT 3
9090: MOD
9091: PUSH
9092: LD_INT 1
9094: PLUS
9095: ARRAY
9096: PPUSH
9097: LD_INT 80
9099: PPUSH
9100: CALL 71856 0 5
// result := result union CreateVehicle ;
9104: LD_ADDR_VAR 0 2
9108: PUSH
9109: LD_VAR 0 2
9113: PUSH
9114: CALL_OW 45
9118: UNION
9119: ST_TO_ADDR
// end ;
9120: GO 9013
9122: POP
9123: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9124: LD_INT 24
9126: PPUSH
9127: LD_INT 3
9129: PPUSH
9130: LD_INT 1
9132: PPUSH
9133: LD_INT 47
9135: PPUSH
9136: LD_INT 100
9138: PPUSH
9139: CALL 71856 0 5
// sewiVeh := CreateVehicle ;
9143: LD_ADDR_EXP 71
9147: PUSH
9148: CALL_OW 45
9152: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9153: LD_EXP 71
9157: PPUSH
9158: LD_INT 1
9160: PPUSH
9161: CALL_OW 242
// result := result union sewiVeh ;
9165: LD_ADDR_VAR 0 2
9169: PUSH
9170: LD_VAR 0 2
9174: PUSH
9175: LD_EXP 71
9179: UNION
9180: ST_TO_ADDR
// end ; end ; end ;
9181: GO 9184
9183: POP
// end ;
9184: LD_VAR 0 2
9188: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9189: LD_EXP 16
9193: IFFALSE 9951
9195: GO 9197
9197: DISABLE
9198: LD_INT 0
9200: PPUSH
9201: PPUSH
9202: PPUSH
9203: PPUSH
9204: PPUSH
9205: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9206: LD_ADDR_VAR 0 4
9210: PUSH
9211: LD_INT 11
9213: PUSH
9214: LD_INT 12
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$40 , 4 4$10 ] [ Difficulty ] ;
9221: LD_ADDR_VAR 0 3
9225: PUSH
9226: LD_INT 11550
9228: PUSH
9229: LD_INT 9800
9231: PUSH
9232: LD_INT 8750
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: LIST
9239: PUSH
9240: LD_OWVAR 67
9244: ARRAY
9245: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9246: LD_ADDR_VAR 0 6
9250: PUSH
9251: LD_INT 70
9253: PUSH
9254: LD_INT 118
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: PUSH
9261: LD_INT 78
9263: PUSH
9264: LD_INT 31
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: ST_TO_ADDR
// repeat if missionStage = 2 then
9275: LD_EXP 15
9279: PUSH
9280: LD_INT 2
9282: EQUAL
9283: IFFALSE 9294
// wait ( 1 1$30 ) else
9285: LD_INT 3150
9287: PPUSH
9288: CALL_OW 67
9292: GO 9303
// wait ( time ) ;
9294: LD_VAR 0 3
9298: PPUSH
9299: CALL_OW 67
// if missionStage = 6 then
9303: LD_EXP 15
9307: PUSH
9308: LD_INT 6
9310: EQUAL
9311: IFFALSE 9339
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9313: LD_INT 51
9315: PPUSH
9316: LD_INT 6
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9326: LD_INT 57
9328: PPUSH
9329: LD_INT 6
9331: PPUSH
9332: LD_INT 2
9334: PPUSH
9335: CALL_OW 322
// end ; if missionStage = 8 then
9339: LD_EXP 15
9343: PUSH
9344: LD_INT 8
9346: EQUAL
9347: IFFALSE 9375
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9349: LD_INT 52
9351: PPUSH
9352: LD_INT 6
9354: PPUSH
9355: LD_INT 2
9357: PPUSH
9358: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9362: LD_INT 58
9364: PPUSH
9365: LD_INT 6
9367: PPUSH
9368: LD_INT 2
9370: PPUSH
9371: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9375: LD_EXP 15
9379: PUSH
9380: LD_INT 10
9382: EQUAL
9383: PUSH
9384: LD_OWVAR 67
9388: PUSH
9389: LD_INT 1
9391: GREATER
9392: AND
9393: IFFALSE 9421
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9395: LD_INT 53
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9408: LD_INT 59
9410: PPUSH
9411: LD_INT 6
9413: PPUSH
9414: LD_INT 2
9416: PPUSH
9417: CALL_OW 322
// end ; if activeAttacks then
9421: LD_EXP 16
9425: IFFALSE 9945
// begin if missionStage = 2 then
9427: LD_EXP 15
9431: PUSH
9432: LD_INT 2
9434: EQUAL
9435: IFFALSE 9445
// strength := 1 ;
9437: LD_ADDR_VAR 0 5
9441: PUSH
9442: LD_INT 1
9444: ST_TO_ADDR
// if missionStage > 2 then
9445: LD_EXP 15
9449: PUSH
9450: LD_INT 2
9452: GREATER
9453: IFFALSE 9463
// strength := 2 ;
9455: LD_ADDR_VAR 0 5
9459: PUSH
9460: LD_INT 2
9462: ST_TO_ADDR
// if missionStage > 6 then
9463: LD_EXP 15
9467: PUSH
9468: LD_INT 6
9470: GREATER
9471: IFFALSE 9481
// strength := 3 ;
9473: LD_ADDR_VAR 0 5
9477: PUSH
9478: LD_INT 3
9480: ST_TO_ADDR
// if missionStage > 10 then
9481: LD_EXP 15
9485: PUSH
9486: LD_INT 10
9488: GREATER
9489: IFFALSE 9499
// strength := 4 ;
9491: LD_ADDR_VAR 0 5
9495: PUSH
9496: LD_INT 4
9498: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9499: LD_ADDR_VAR 0 2
9503: PUSH
9504: LD_VAR 0 5
9508: PPUSH
9509: CALL 8061 0 1
9513: ST_TO_ADDR
// for i in tmp do
9514: LD_ADDR_VAR 0 1
9518: PUSH
9519: LD_VAR 0 2
9523: PUSH
9524: FOR_IN
9525: IFFALSE 9625
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9527: LD_VAR 0 1
9531: PPUSH
9532: LD_VAR 0 4
9536: PUSH
9537: LD_INT 1
9539: PPUSH
9540: LD_INT 2
9542: PPUSH
9543: CALL_OW 12
9547: ARRAY
9548: PPUSH
9549: LD_INT 0
9551: PPUSH
9552: CALL_OW 49
// if i = sewiVeh then
9556: LD_VAR 0 1
9560: PUSH
9561: LD_EXP 71
9565: EQUAL
9566: IFFALSE 9601
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9568: LD_ADDR_EXP 70
9572: PUSH
9573: LD_STRING Vsevolod
9575: PPUSH
9576: LD_INT 0
9578: PPUSH
9579: LD_STRING 
9581: PPUSH
9582: CALL 64741 0 3
9586: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9587: LD_EXP 70
9591: PPUSH
9592: LD_VAR 0 1
9596: PPUSH
9597: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9601: LD_VAR 0 1
9605: PPUSH
9606: LD_INT 111
9608: PPUSH
9609: LD_INT 197
9611: PPUSH
9612: CALL_OW 111
// wait ( 0 0$2 ) ;
9616: LD_INT 70
9618: PPUSH
9619: CALL_OW 67
// end ;
9623: GO 9524
9625: POP
9626: POP
// repeat wait ( 0 0$1 ) ;
9627: LD_INT 35
9629: PPUSH
9630: CALL_OW 67
// for i in tmp do
9634: LD_ADDR_VAR 0 1
9638: PUSH
9639: LD_VAR 0 2
9643: PUSH
9644: FOR_IN
9645: IFFALSE 9926
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9647: LD_INT 81
9649: PUSH
9650: LD_INT 6
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 91
9659: PUSH
9660: LD_VAR 0 1
9664: PUSH
9665: LD_INT 12
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PPUSH
9677: CALL_OW 69
9681: IFFALSE 9739
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9683: LD_VAR 0 1
9687: PPUSH
9688: LD_INT 81
9690: PUSH
9691: LD_INT 6
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: PUSH
9698: LD_INT 91
9700: PUSH
9701: LD_VAR 0 1
9705: PUSH
9706: LD_INT 12
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PPUSH
9718: CALL_OW 69
9722: PPUSH
9723: LD_VAR 0 1
9727: PPUSH
9728: CALL_OW 74
9732: PPUSH
9733: CALL_OW 115
9737: GO 9924
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9739: LD_INT 9
9741: PPUSH
9742: LD_INT 81
9744: PUSH
9745: LD_INT 6
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PPUSH
9752: CALL_OW 70
9756: IFFALSE 9890
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9758: LD_VAR 0 1
9762: PPUSH
9763: LD_VAR 0 6
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PUSH
9772: LD_INT 1
9774: ARRAY
9775: PPUSH
9776: LD_VAR 0 6
9780: PUSH
9781: LD_INT 1
9783: ARRAY
9784: PUSH
9785: LD_INT 2
9787: ARRAY
9788: PPUSH
9789: CALL_OW 297
9793: PUSH
9794: LD_INT 10
9796: GREATER
9797: PUSH
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_INT 9
9805: PPUSH
9806: CALL_OW 308
9810: NOT
9811: AND
9812: IFFALSE 9851
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_VAR 0 6
9823: PUSH
9824: LD_INT 1
9826: ARRAY
9827: PUSH
9828: LD_INT 1
9830: ARRAY
9831: PPUSH
9832: LD_VAR 0 6
9836: PUSH
9837: LD_INT 1
9839: ARRAY
9840: PUSH
9841: LD_INT 2
9843: ARRAY
9844: PPUSH
9845: CALL_OW 114
9849: GO 9888
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9851: LD_VAR 0 1
9855: PPUSH
9856: LD_INT 9
9858: PPUSH
9859: LD_INT 81
9861: PUSH
9862: LD_INT 6
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PPUSH
9869: CALL_OW 70
9873: PPUSH
9874: LD_VAR 0 1
9878: PPUSH
9879: CALL_OW 74
9883: PPUSH
9884: CALL_OW 115
// end else
9888: GO 9924
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9890: LD_VAR 0 1
9894: PPUSH
9895: LD_INT 81
9897: PUSH
9898: LD_INT 6
9900: PUSH
9901: EMPTY
9902: LIST
9903: LIST
9904: PPUSH
9905: CALL_OW 69
9909: PPUSH
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 74
9919: PPUSH
9920: CALL_OW 115
// end ;
9924: GO 9644
9926: POP
9927: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9928: LD_INT 22
9930: PUSH
9931: LD_INT 6
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 69
9942: NOT
9943: IFFALSE 9627
// end ; until russianDestroyed ;
9945: LD_EXP 21
9949: IFFALSE 9275
// end ;
9951: PPOPN 6
9953: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9954: LD_EXP 21
9958: NOT
9959: PUSH
9960: LD_EXP 15
9964: PUSH
9965: LD_INT 6
9967: GREATEREQUAL
9968: AND
9969: PUSH
9970: LD_INT 2
9972: PPUSH
9973: LD_INT 1
9975: PPUSH
9976: CALL 59815 0 2
9980: NOT
9981: AND
9982: IFFALSE 10938
9984: GO 9986
9986: DISABLE
9987: LD_INT 0
9989: PPUSH
9990: PPUSH
9991: PPUSH
9992: PPUSH
// begin enable ;
9993: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9994: LD_INT 22
9996: PUSH
9997: LD_INT 3
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PUSH
10004: LD_INT 30
10006: PUSH
10007: LD_INT 3
10009: PUSH
10010: EMPTY
10011: LIST
10012: LIST
10013: PUSH
10014: EMPTY
10015: LIST
10016: LIST
10017: PPUSH
10018: CALL_OW 69
10022: NOT
10023: IFFALSE 10027
// exit ;
10025: GO 10938
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10027: LD_ADDR_VAR 0 4
10031: PUSH
10032: LD_INT 22
10034: PUSH
10035: LD_INT 3
10037: PUSH
10038: EMPTY
10039: LIST
10040: LIST
10041: PUSH
10042: LD_INT 30
10044: PUSH
10045: LD_INT 34
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: EMPTY
10053: LIST
10054: LIST
10055: PPUSH
10056: CALL_OW 69
10060: ST_TO_ADDR
// if Prob ( 40 ) then
10061: LD_INT 40
10063: PPUSH
10064: CALL_OW 13
10068: IFFALSE 10195
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10070: LD_INT 2
10072: PPUSH
10073: LD_INT 22
10075: PUSH
10076: LD_INT 3
10078: PUSH
10079: LD_INT 3
10081: PUSH
10082: LD_INT 49
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: PUSH
10091: LD_INT 22
10093: PUSH
10094: LD_INT 3
10096: PUSH
10097: LD_INT 3
10099: PUSH
10100: LD_INT 49
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_INT 22
10111: PUSH
10112: LD_INT 3
10114: PUSH
10115: LD_INT 3
10117: PUSH
10118: LD_INT 49
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: PUSH
10127: LD_INT 24
10129: PUSH
10130: LD_INT 3
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 46
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 24
10147: PUSH
10148: LD_INT 3
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: LD_INT 46
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: PUSH
10163: LD_INT 24
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 46
10174: PUSH
10175: EMPTY
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: PPUSH
10189: CALL 58397 0 2
// end else
10193: GO 10318
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10195: LD_INT 2
10197: PPUSH
10198: LD_INT 24
10200: PUSH
10201: LD_INT 3
10203: PUSH
10204: LD_INT 3
10206: PUSH
10207: LD_INT 47
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: PUSH
10216: LD_INT 24
10218: PUSH
10219: LD_INT 3
10221: PUSH
10222: LD_INT 3
10224: PUSH
10225: LD_INT 47
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: PUSH
10234: LD_INT 24
10236: PUSH
10237: LD_INT 3
10239: PUSH
10240: LD_INT 3
10242: PUSH
10243: LD_INT 47
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: PUSH
10252: LD_INT 24
10254: PUSH
10255: LD_INT 3
10257: PUSH
10258: LD_INT 3
10260: PUSH
10261: LD_INT 46
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: LIST
10268: LIST
10269: PUSH
10270: LD_INT 24
10272: PUSH
10273: LD_INT 3
10275: PUSH
10276: LD_INT 3
10278: PUSH
10279: LD_INT 46
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 24
10290: PUSH
10291: LD_INT 3
10293: PUSH
10294: LD_INT 3
10296: PUSH
10297: LD_INT 46
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: PPUSH
10314: CALL 58397 0 2
// end ; if Difficulty > 1 then
10318: LD_OWVAR 67
10322: PUSH
10323: LD_INT 1
10325: GREATER
10326: IFFALSE 10356
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10328: LD_INT 2
10330: PPUSH
10331: LD_INT 24
10333: PUSH
10334: LD_INT 3
10336: PUSH
10337: LD_INT 3
10339: PUSH
10340: LD_INT 47
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: PUSH
10349: EMPTY
10350: LIST
10351: PPUSH
10352: CALL 58397 0 2
// repeat wait ( 0 0$1 ) ;
10356: LD_INT 35
10358: PPUSH
10359: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10363: LD_INT 2
10365: PPUSH
10366: LD_INT 1
10368: PPUSH
10369: CALL 59815 0 2
10373: PUSH
10374: LD_INT 6
10376: PUSH
10377: LD_INT 7
10379: PUSH
10380: LD_INT 7
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: LIST
10387: PUSH
10388: LD_OWVAR 67
10392: ARRAY
10393: GREATEREQUAL
10394: IFFALSE 10356
// wait ( 0 0$30 ) ;
10396: LD_INT 1050
10398: PPUSH
10399: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10403: LD_ADDR_VAR 0 2
10407: PUSH
10408: LD_INT 2
10410: PPUSH
10411: LD_INT 1
10413: PPUSH
10414: CALL 59815 0 2
10418: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10419: LD_ADDR_EXP 121
10423: PUSH
10424: LD_EXP 121
10428: PPUSH
10429: LD_INT 2
10431: PPUSH
10432: LD_EXP 121
10436: PUSH
10437: LD_INT 2
10439: ARRAY
10440: PUSH
10441: LD_VAR 0 2
10445: DIFF
10446: PPUSH
10447: CALL_OW 1
10451: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10452: LD_ADDR_VAR 0 3
10456: PUSH
10457: LD_INT 0
10459: PPUSH
10460: LD_INT 1
10462: PPUSH
10463: CALL_OW 12
10467: ST_TO_ADDR
// if target then
10468: LD_VAR 0 3
10472: IFFALSE 10600
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10474: LD_ADDR_VAR 0 2
10478: PUSH
10479: LD_VAR 0 2
10483: PPUSH
10484: LD_INT 24
10486: PUSH
10487: LD_INT 250
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PPUSH
10494: CALL_OW 72
10498: ST_TO_ADDR
// for i in tmp do
10499: LD_ADDR_VAR 0 1
10503: PUSH
10504: LD_VAR 0 2
10508: PUSH
10509: FOR_IN
10510: IFFALSE 10550
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10512: LD_VAR 0 1
10516: PPUSH
10517: LD_INT 139
10519: PPUSH
10520: LD_INT 89
10522: PPUSH
10523: CALL_OW 297
10527: PUSH
10528: LD_INT 9
10530: GREATER
10531: IFFALSE 10548
// ComMoveXY ( i , 139 , 89 ) ;
10533: LD_VAR 0 1
10537: PPUSH
10538: LD_INT 139
10540: PPUSH
10541: LD_INT 89
10543: PPUSH
10544: CALL_OW 111
10548: GO 10509
10550: POP
10551: POP
// wait ( 0 0$1 ) ;
10552: LD_INT 35
10554: PPUSH
10555: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10559: LD_VAR 0 2
10563: PPUSH
10564: LD_INT 92
10566: PUSH
10567: LD_INT 139
10569: PUSH
10570: LD_INT 89
10572: PUSH
10573: LD_INT 9
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL_OW 72
10586: PUSH
10587: LD_VAR 0 2
10591: PUSH
10592: LD_INT 1
10594: MINUS
10595: GREATEREQUAL
10596: IFFALSE 10474
// end else
10598: GO 10742
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: LD_VAR 0 4
10609: PUSH
10610: LD_INT 1
10612: ARRAY
10613: PPUSH
10614: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_VAR 0 2
10627: PPUSH
10628: LD_INT 24
10630: PUSH
10631: LD_INT 250
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PPUSH
10638: CALL_OW 72
10642: ST_TO_ADDR
// for i in tmp do
10643: LD_ADDR_VAR 0 1
10647: PUSH
10648: LD_VAR 0 2
10652: PUSH
10653: FOR_IN
10654: IFFALSE 10694
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10656: LD_VAR 0 1
10660: PPUSH
10661: LD_INT 124
10663: PPUSH
10664: LD_INT 139
10666: PPUSH
10667: CALL_OW 297
10671: PUSH
10672: LD_INT 9
10674: GREATER
10675: IFFALSE 10692
// ComMoveXY ( i , 124 , 139 ) ;
10677: LD_VAR 0 1
10681: PPUSH
10682: LD_INT 124
10684: PPUSH
10685: LD_INT 139
10687: PPUSH
10688: CALL_OW 111
10692: GO 10653
10694: POP
10695: POP
// wait ( 0 0$1 ) ;
10696: LD_INT 35
10698: PPUSH
10699: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10703: LD_VAR 0 2
10707: PPUSH
10708: LD_INT 92
10710: PUSH
10711: LD_INT 124
10713: PUSH
10714: LD_INT 139
10716: PUSH
10717: LD_INT 9
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 72
10730: PUSH
10731: LD_VAR 0 2
10735: PUSH
10736: LD_INT 1
10738: MINUS
10739: GREATEREQUAL
10740: IFFALSE 10618
// end ; repeat wait ( 0 0$1 ) ;
10742: LD_INT 35
10744: PPUSH
10745: CALL_OW 67
// for i in tmp do
10749: LD_ADDR_VAR 0 1
10753: PUSH
10754: LD_VAR 0 2
10758: PUSH
10759: FOR_IN
10760: IFFALSE 10929
// begin if GetLives ( i ) > 251 then
10762: LD_VAR 0 1
10766: PPUSH
10767: CALL_OW 256
10771: PUSH
10772: LD_INT 251
10774: GREATER
10775: IFFALSE 10900
// begin if GetWeapon ( i ) = ru_time_lapser then
10777: LD_VAR 0 1
10781: PPUSH
10782: CALL_OW 264
10786: PUSH
10787: LD_INT 49
10789: EQUAL
10790: IFFALSE 10846
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_INT 2
10799: PUSH
10800: LD_INT 22
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: LD_INT 22
10812: PUSH
10813: LD_INT 8
10815: PUSH
10816: EMPTY
10817: LIST
10818: LIST
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: LIST
10824: PPUSH
10825: CALL_OW 69
10829: PPUSH
10830: LD_VAR 0 1
10834: PPUSH
10835: CALL_OW 74
10839: PPUSH
10840: CALL_OW 112
10844: GO 10898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10846: LD_VAR 0 1
10850: PPUSH
10851: LD_INT 2
10853: PUSH
10854: LD_INT 22
10856: PUSH
10857: LD_INT 1
10859: PUSH
10860: EMPTY
10861: LIST
10862: LIST
10863: PUSH
10864: LD_INT 22
10866: PUSH
10867: LD_INT 8
10869: PUSH
10870: EMPTY
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: PPUSH
10879: CALL_OW 69
10883: PPUSH
10884: LD_VAR 0 1
10888: PPUSH
10889: CALL_OW 74
10893: PPUSH
10894: CALL_OW 115
// end else
10898: GO 10927
// if IsDead ( i ) then
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 301
10909: IFFALSE 10927
// tmp := tmp diff i ;
10911: LD_ADDR_VAR 0 2
10915: PUSH
10916: LD_VAR 0 2
10920: PUSH
10921: LD_VAR 0 1
10925: DIFF
10926: ST_TO_ADDR
// end ;
10927: GO 10759
10929: POP
10930: POP
// until not tmp ;
10931: LD_VAR 0 2
10935: NOT
10936: IFFALSE 10742
// end ; end_of_file
10938: PPOPN 4
10940: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10941: LD_INT 0
10943: PPUSH
10944: PPUSH
10945: PPUSH
10946: PPUSH
10947: PPUSH
10948: PPUSH
// side := 7 ;
10949: LD_ADDR_VAR 0 5
10953: PUSH
10954: LD_INT 7
10956: ST_TO_ADDR
// uc_side := side ;
10957: LD_ADDR_OWVAR 20
10961: PUSH
10962: LD_VAR 0 5
10966: ST_TO_ADDR
// uc_nation := 1 ;
10967: LD_ADDR_OWVAR 21
10971: PUSH
10972: LD_INT 1
10974: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10975: LD_ADDR_VAR 0 2
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_VAR 0 5
10987: PUSH
10988: EMPTY
10989: LIST
10990: LIST
10991: PUSH
10992: LD_INT 21
10994: PUSH
10995: LD_INT 3
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PPUSH
11006: CALL_OW 69
11010: PUSH
11011: FOR_IN
11012: IFFALSE 11028
// SetBLevel ( i , 10 ) ;
11014: LD_VAR 0 2
11018: PPUSH
11019: LD_INT 10
11021: PPUSH
11022: CALL_OW 241
11026: GO 11011
11028: POP
11029: POP
// base := GetBase ( al_depot ) ;
11030: LD_ADDR_VAR 0 4
11034: PUSH
11035: LD_INT 2
11037: PPUSH
11038: CALL_OW 274
11042: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11043: LD_ADDR_VAR 0 6
11047: PUSH
11048: LD_INT 22
11050: PUSH
11051: LD_VAR 0 5
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: LD_INT 30
11062: PUSH
11063: LD_INT 34
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PPUSH
11074: CALL_OW 69
11078: ST_TO_ADDR
// if teleport then
11079: LD_VAR 0 6
11083: IFFALSE 11104
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11085: LD_VAR 0 6
11089: PUSH
11090: LD_INT 1
11092: ARRAY
11093: PPUSH
11094: LD_INT 262
11096: PPUSH
11097: LD_INT 119
11099: PPUSH
11100: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11104: LD_VAR 0 4
11108: PPUSH
11109: LD_INT 1
11111: PPUSH
11112: LD_INT 19500
11114: PPUSH
11115: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11119: LD_VAR 0 4
11123: PPUSH
11124: LD_INT 2
11126: PPUSH
11127: LD_INT 200
11129: PPUSH
11130: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11134: LD_VAR 0 4
11138: PPUSH
11139: LD_INT 3
11141: PPUSH
11142: LD_INT 650
11144: PPUSH
11145: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11149: LD_ADDR_EXP 74
11153: PUSH
11154: LD_STRING Roth
11156: PPUSH
11157: CALL_OW 25
11161: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11162: LD_ADDR_EXP 75
11166: PUSH
11167: LD_STRING Simms
11169: PPUSH
11170: LD_EXP 1
11174: NOT
11175: PPUSH
11176: LD_STRING 10c_
11178: PPUSH
11179: CALL 64741 0 3
11183: ST_TO_ADDR
// if not Simms then
11184: LD_EXP 75
11188: NOT
11189: IFFALSE 11219
// begin uc_nation := 1 ;
11191: LD_ADDR_OWVAR 21
11195: PUSH
11196: LD_INT 1
11198: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11199: LD_INT 2
11201: PPUSH
11202: LD_INT 10
11204: PPUSH
11205: CALL_OW 384
// Simms := CreateHuman ;
11209: LD_ADDR_EXP 75
11213: PUSH
11214: CALL_OW 44
11218: ST_TO_ADDR
// end ; uc_nation := 3 ;
11219: LD_ADDR_OWVAR 21
11223: PUSH
11224: LD_INT 3
11226: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11227: LD_ADDR_EXP 76
11231: PUSH
11232: LD_STRING Kirilenkova
11234: PPUSH
11235: CALL_OW 25
11239: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11240: LD_ADDR_EXP 90
11244: PUSH
11245: LD_STRING Oblukov
11247: PPUSH
11248: CALL_OW 25
11252: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11253: LD_ADDR_EXP 77
11257: PUSH
11258: LD_STRING Dolgov
11260: PPUSH
11261: CALL_OW 25
11265: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11266: LD_ADDR_EXP 78
11270: PUSH
11271: LD_STRING Petrosyan
11273: PPUSH
11274: CALL_OW 25
11278: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11279: LD_ADDR_EXP 89
11283: PUSH
11284: LD_STRING Scholtze
11286: PPUSH
11287: CALL_OW 25
11291: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11292: LD_ADDR_EXP 88
11296: PUSH
11297: LD_STRING Kapitsova
11299: PPUSH
11300: CALL_OW 25
11304: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11305: LD_ADDR_EXP 79
11309: PUSH
11310: LD_STRING Petrovova
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11318: LD_ADDR_EXP 80
11322: PUSH
11323: LD_STRING Kuzmov
11325: PPUSH
11326: CALL_OW 25
11330: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11331: LD_ADDR_EXP 87
11335: PUSH
11336: LD_STRING Karamazov
11338: PPUSH
11339: CALL_OW 25
11343: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11344: LD_STRING 13_Lipshchin_1
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 30
11354: IFFALSE 11369
// Lipshchin := NewCharacter ( Lipshchin ) ;
11356: LD_ADDR_EXP 81
11360: PUSH
11361: LD_STRING Lipshchin
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11369: LD_STRING 13_Titov_1
11371: PPUSH
11372: LD_INT 0
11374: PPUSH
11375: CALL_OW 30
11379: IFFALSE 11394
// Titov := NewCharacter ( Titov ) ;
11381: LD_ADDR_EXP 83
11385: PUSH
11386: LD_STRING Titov
11388: PPUSH
11389: CALL_OW 25
11393: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11394: LD_STRING 13_Gnyevko_1
11396: PPUSH
11397: LD_INT 0
11399: PPUSH
11400: CALL_OW 30
11404: IFFALSE 11419
// Gnyevko := NewCharacter ( Gnyevko ) ;
11406: LD_ADDR_EXP 82
11410: PUSH
11411: LD_STRING Gnyevko
11413: PPUSH
11414: CALL_OW 25
11418: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11419: LD_STRING 13_Xavier_1
11421: PPUSH
11422: LD_INT 0
11424: PPUSH
11425: CALL_OW 30
11429: IFFALSE 11444
// Xavier := NewCharacter ( Xavier2 ) ;
11431: LD_ADDR_EXP 84
11435: PUSH
11436: LD_STRING Xavier2
11438: PPUSH
11439: CALL_OW 25
11443: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11444: LD_STRING 13_Belkov_1
11446: PPUSH
11447: LD_INT 0
11449: PPUSH
11450: CALL_OW 30
11454: IFFALSE 11469
// Belkov := NewCharacter ( Belkov ) ;
11456: LD_ADDR_EXP 85
11460: PUSH
11461: LD_STRING Belkov
11463: PPUSH
11464: CALL_OW 25
11468: ST_TO_ADDR
// if not BurlakStatus then
11469: LD_EXP 9
11473: NOT
11474: IFFALSE 11489
// Burlak = NewCharacter ( Burlak ) ;
11476: LD_ADDR_EXP 86
11480: PUSH
11481: LD_STRING Burlak
11483: PPUSH
11484: CALL_OW 25
11488: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11489: LD_ADDR_VAR 0 3
11493: PUSH
11494: LD_EXP 74
11498: PUSH
11499: LD_EXP 76
11503: PUSH
11504: LD_EXP 90
11508: PUSH
11509: LD_EXP 77
11513: PUSH
11514: LD_EXP 78
11518: PUSH
11519: LD_EXP 89
11523: PUSH
11524: LD_EXP 88
11528: PUSH
11529: LD_EXP 79
11533: PUSH
11534: LD_EXP 80
11538: PUSH
11539: LD_EXP 87
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: ST_TO_ADDR
// if Simms then
11556: LD_EXP 75
11560: IFFALSE 11578
// tmp := tmp ^ Simms ;
11562: LD_ADDR_VAR 0 3
11566: PUSH
11567: LD_VAR 0 3
11571: PUSH
11572: LD_EXP 75
11576: ADD
11577: ST_TO_ADDR
// if Titov then
11578: LD_EXP 83
11582: IFFALSE 11600
// tmp := tmp ^ Titov ;
11584: LD_ADDR_VAR 0 3
11588: PUSH
11589: LD_VAR 0 3
11593: PUSH
11594: LD_EXP 83
11598: ADD
11599: ST_TO_ADDR
// if Lipshchin then
11600: LD_EXP 81
11604: IFFALSE 11622
// tmp := tmp ^ Lipshchin ;
11606: LD_ADDR_VAR 0 3
11610: PUSH
11611: LD_VAR 0 3
11615: PUSH
11616: LD_EXP 81
11620: ADD
11621: ST_TO_ADDR
// if Gnyevko then
11622: LD_EXP 82
11626: IFFALSE 11644
// tmp := tmp ^ Gnyevko ;
11628: LD_ADDR_VAR 0 3
11632: PUSH
11633: LD_VAR 0 3
11637: PUSH
11638: LD_EXP 82
11642: ADD
11643: ST_TO_ADDR
// if Xavier then
11644: LD_EXP 84
11648: IFFALSE 11666
// tmp := tmp ^ Xavier ;
11650: LD_ADDR_VAR 0 3
11654: PUSH
11655: LD_VAR 0 3
11659: PUSH
11660: LD_EXP 84
11664: ADD
11665: ST_TO_ADDR
// if Belkov then
11666: LD_EXP 85
11670: IFFALSE 11688
// tmp := tmp ^ Belkov ;
11672: LD_ADDR_VAR 0 3
11676: PUSH
11677: LD_VAR 0 3
11681: PUSH
11682: LD_EXP 85
11686: ADD
11687: ST_TO_ADDR
// if Burlak then
11688: LD_EXP 86
11692: IFFALSE 11710
// tmp := tmp ^ Burlak ;
11694: LD_ADDR_VAR 0 3
11698: PUSH
11699: LD_VAR 0 3
11703: PUSH
11704: LD_EXP 86
11708: ADD
11709: ST_TO_ADDR
// for i = 1 to 8 do
11710: LD_ADDR_VAR 0 2
11714: PUSH
11715: DOUBLE
11716: LD_INT 1
11718: DEC
11719: ST_TO_ADDR
11720: LD_INT 8
11722: PUSH
11723: FOR_TO
11724: IFFALSE 11790
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11726: LD_ADDR_OWVAR 21
11730: PUSH
11731: LD_INT 1
11733: PUSH
11734: LD_INT 3
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 1
11743: PPUSH
11744: LD_INT 2
11746: PPUSH
11747: CALL_OW 12
11751: ARRAY
11752: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11753: LD_INT 0
11755: PPUSH
11756: LD_VAR 0 2
11760: PUSH
11761: LD_INT 2
11763: DIV
11764: PPUSH
11765: LD_INT 10
11767: PPUSH
11768: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11772: LD_ADDR_VAR 0 3
11776: PUSH
11777: LD_VAR 0 3
11781: PUSH
11782: CALL_OW 44
11786: ADD
11787: ST_TO_ADDR
// end ;
11788: GO 11723
11790: POP
11791: POP
// for i in tmp do
11792: LD_ADDR_VAR 0 2
11796: PUSH
11797: LD_VAR 0 3
11801: PUSH
11802: FOR_IN
11803: IFFALSE 11828
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11805: LD_VAR 0 2
11809: PPUSH
11810: LD_INT 260
11812: PPUSH
11813: LD_INT 235
11815: PPUSH
11816: LD_INT 8
11818: PPUSH
11819: LD_INT 0
11821: PPUSH
11822: CALL_OW 50
11826: GO 11802
11828: POP
11829: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11830: LD_ADDR_EXP 102
11834: PUSH
11835: LD_EXP 102
11839: PPUSH
11840: LD_INT 1
11842: PPUSH
11843: LD_INT 22
11845: PUSH
11846: LD_VAR 0 5
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 3
11857: PUSH
11858: LD_INT 21
11860: PUSH
11861: LD_INT 2
11863: PUSH
11864: EMPTY
11865: LIST
11866: LIST
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: EMPTY
11873: LIST
11874: LIST
11875: PPUSH
11876: CALL_OW 69
11880: PUSH
11881: LD_EXP 74
11885: PUSH
11886: LD_EXP 75
11890: PUSH
11891: EMPTY
11892: LIST
11893: LIST
11894: DIFF
11895: PPUSH
11896: CALL_OW 1
11900: ST_TO_ADDR
// uc_side := 0 ;
11901: LD_ADDR_OWVAR 20
11905: PUSH
11906: LD_INT 0
11908: ST_TO_ADDR
// uc_nation := 0 ;
11909: LD_ADDR_OWVAR 21
11913: PUSH
11914: LD_INT 0
11916: ST_TO_ADDR
// for i = 1 to 5 do
11917: LD_ADDR_VAR 0 2
11921: PUSH
11922: DOUBLE
11923: LD_INT 1
11925: DEC
11926: ST_TO_ADDR
11927: LD_INT 5
11929: PUSH
11930: FOR_TO
11931: IFFALSE 11968
// begin InitHc ;
11933: CALL_OW 19
// hc_class := class_apeman ;
11937: LD_ADDR_OWVAR 28
11941: PUSH
11942: LD_INT 12
11944: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11945: CALL_OW 44
11949: PPUSH
11950: LD_INT 299
11952: PPUSH
11953: LD_INT 229
11955: PPUSH
11956: LD_INT 10
11958: PPUSH
11959: LD_INT 0
11961: PPUSH
11962: CALL_OW 50
// end ;
11966: GO 11930
11968: POP
11969: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11970: LD_EXP 74
11974: PPUSH
11975: LD_INT 259
11977: PPUSH
11978: LD_INT 235
11980: PPUSH
11981: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11985: LD_EXP 74
11989: PPUSH
11990: LD_INT 262
11992: PPUSH
11993: LD_INT 235
11995: PPUSH
11996: CALL_OW 178
// if Simms then
12000: LD_EXP 75
12004: IFFALSE 12035
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12006: LD_EXP 75
12010: PPUSH
12011: LD_INT 262
12013: PPUSH
12014: LD_INT 235
12016: PPUSH
12017: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12021: LD_EXP 75
12025: PPUSH
12026: LD_EXP 74
12030: PPUSH
12031: CALL_OW 179
// end ; end ;
12035: LD_VAR 0 1
12039: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12040: LD_EXP 31
12044: PUSH
12045: LD_EXP 23
12049: NOT
12050: AND
12051: IFFALSE 12227
12053: GO 12055
12055: DISABLE
12056: LD_INT 0
12058: PPUSH
12059: PPUSH
12060: PPUSH
// begin enable ;
12061: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12062: LD_ADDR_VAR 0 2
12066: PUSH
12067: LD_INT 81
12069: PUSH
12070: LD_INT 7
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PUSH
12077: LD_INT 2
12079: PUSH
12080: LD_INT 32
12082: PUSH
12083: LD_INT 3
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: LD_INT 30
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 30
12102: PUSH
12103: LD_INT 28
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: LD_INT 34
12112: PUSH
12113: LD_INT 49
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PUSH
12120: LD_INT 34
12122: PUSH
12123: LD_INT 10
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 34
12132: PUSH
12133: LD_INT 8
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: LIST
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: PPUSH
12153: CALL_OW 69
12157: ST_TO_ADDR
// if not tmp then
12158: LD_VAR 0 2
12162: NOT
12163: IFFALSE 12167
// exit ;
12165: GO 12227
// target := tmp [ rand ( 1 , tmp ) ] ;
12167: LD_ADDR_VAR 0 3
12171: PUSH
12172: LD_VAR 0 2
12176: PUSH
12177: LD_INT 1
12179: PPUSH
12180: LD_VAR 0 2
12184: PPUSH
12185: CALL_OW 12
12189: ARRAY
12190: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12191: LD_VAR 0 3
12195: PPUSH
12196: CALL_OW 255
12200: PUSH
12201: LD_INT 1
12203: EQUAL
12204: IFFALSE 12215
// CenterNowOnUnits ( target ) ;
12206: LD_VAR 0 3
12210: PPUSH
12211: CALL_OW 87
// SetLives ( target , 0 ) ;
12215: LD_VAR 0 3
12219: PPUSH
12220: LD_INT 0
12222: PPUSH
12223: CALL_OW 234
// end ;
12227: PPOPN 3
12229: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12230: LD_EXP 23
12234: NOT
12235: PUSH
12236: LD_EXP 31
12240: AND
12241: IFFALSE 12763
12243: GO 12245
12245: DISABLE
12246: LD_INT 0
12248: PPUSH
12249: PPUSH
12250: PPUSH
// begin uc_side := 7 ;
12251: LD_ADDR_OWVAR 20
12255: PUSH
12256: LD_INT 7
12258: ST_TO_ADDR
// uc_nation := 1 ;
12259: LD_ADDR_OWVAR 21
12263: PUSH
12264: LD_INT 1
12266: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12267: LD_ADDR_VAR 0 3
12271: PUSH
12272: LD_INT 125
12274: PUSH
12275: LD_INT 163
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PUSH
12282: LD_INT 185
12284: PUSH
12285: LD_INT 168
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: LD_INT 111
12294: PUSH
12295: LD_INT 97
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: PPUSH
12307: CALL 107696 0 1
12311: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12312: LD_ADDR_EXP 91
12316: PUSH
12317: EMPTY
12318: ST_TO_ADDR
// for i = 1 to Difficulty do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: DOUBLE
12325: LD_INT 1
12327: DEC
12328: ST_TO_ADDR
12329: LD_OWVAR 67
12333: PUSH
12334: FOR_TO
12335: IFFALSE 12493
// begin InitHc ;
12337: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12341: LD_INT 0
12343: PPUSH
12344: LD_INT 8
12346: PPUSH
12347: CALL_OW 381
// un := CreateHuman ;
12351: LD_ADDR_VAR 0 2
12355: PUSH
12356: CALL_OW 44
12360: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12361: LD_VAR 0 2
12365: PPUSH
12366: LD_INT 258
12368: PPUSH
12369: LD_INT 267
12371: PPUSH
12372: LD_INT 4
12374: PPUSH
12375: LD_INT 0
12377: PPUSH
12378: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12382: LD_ADDR_EXP 91
12386: PUSH
12387: LD_EXP 91
12391: PUSH
12392: LD_VAR 0 2
12396: UNION
12397: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12398: LD_VAR 0 2
12402: PPUSH
12403: LD_VAR 0 3
12407: PUSH
12408: LD_VAR 0 1
12412: ARRAY
12413: PUSH
12414: LD_INT 1
12416: ARRAY
12417: PPUSH
12418: LD_VAR 0 3
12422: PUSH
12423: LD_VAR 0 1
12427: ARRAY
12428: PUSH
12429: LD_INT 2
12431: ARRAY
12432: PPUSH
12433: LD_INT 4
12435: PPUSH
12436: LD_INT 1
12438: PPUSH
12439: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12443: LD_VAR 0 2
12447: PPUSH
12448: LD_VAR 0 3
12452: PUSH
12453: LD_VAR 0 1
12457: ARRAY
12458: PUSH
12459: LD_INT 1
12461: ARRAY
12462: PPUSH
12463: LD_VAR 0 3
12467: PUSH
12468: LD_VAR 0 1
12472: ARRAY
12473: PUSH
12474: LD_INT 2
12476: ARRAY
12477: PPUSH
12478: CALL_OW 171
// AddComInvisible ( un ) ;
12482: LD_VAR 0 2
12486: PPUSH
12487: CALL_OW 212
// end ;
12491: GO 12334
12493: POP
12494: POP
// repeat wait ( 0 0$20 ) ;
12495: LD_INT 700
12497: PPUSH
12498: CALL_OW 67
// for i in allianceSpecialForce do
12502: LD_ADDR_VAR 0 1
12506: PUSH
12507: LD_EXP 91
12511: PUSH
12512: FOR_IN
12513: IFFALSE 12748
// begin if IsInvisible ( i ) then
12515: LD_VAR 0 1
12519: PPUSH
12520: CALL_OW 571
12524: IFFALSE 12717
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12526: LD_ADDR_VAR 0 3
12530: PUSH
12531: LD_INT 22
12533: PUSH
12534: LD_INT 1
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 50
12543: PUSH
12544: EMPTY
12545: LIST
12546: PUSH
12547: LD_INT 56
12549: PUSH
12550: EMPTY
12551: LIST
12552: PUSH
12553: LD_INT 91
12555: PUSH
12556: LD_VAR 0 1
12560: PUSH
12561: LD_INT 25
12563: PUSH
12564: LD_INT 30
12566: PUSH
12567: LD_INT 35
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: LIST
12574: PUSH
12575: LD_OWVAR 67
12579: ARRAY
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: LIST
12585: PUSH
12586: LD_INT 2
12588: PUSH
12589: LD_INT 25
12591: PUSH
12592: LD_INT 1
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 25
12601: PUSH
12602: LD_INT 2
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 25
12611: PUSH
12612: LD_INT 3
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: LD_INT 25
12621: PUSH
12622: LD_INT 4
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 25
12631: PUSH
12632: LD_INT 5
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 25
12641: PUSH
12642: LD_INT 8
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: LIST
12664: PPUSH
12665: CALL_OW 69
12669: ST_TO_ADDR
// if not tmp then
12670: LD_VAR 0 3
12674: NOT
12675: IFFALSE 12679
// continue ;
12677: GO 12512
// if Prob ( 30 * Difficulty ) then
12679: LD_INT 30
12681: PUSH
12682: LD_OWVAR 67
12686: MUL
12687: PPUSH
12688: CALL_OW 13
12692: IFFALSE 12717
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12694: LD_VAR 0 3
12698: PUSH
12699: LD_INT 1
12701: PPUSH
12702: LD_VAR 0 3
12706: PPUSH
12707: CALL_OW 12
12711: ARRAY
12712: PPUSH
12713: CALL 30847 0 1
// end ; if IsDead ( i ) then
12717: LD_VAR 0 1
12721: PPUSH
12722: CALL_OW 301
12726: IFFALSE 12746
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12728: LD_ADDR_EXP 91
12732: PUSH
12733: LD_EXP 91
12737: PUSH
12738: LD_VAR 0 1
12742: DIFF
12743: ST_TO_ADDR
// continue ;
12744: GO 12512
// end ; end ;
12746: GO 12512
12748: POP
12749: POP
// until allianceDestroyed or not allianceSpecialForce ;
12750: LD_EXP 23
12754: PUSH
12755: LD_EXP 91
12759: NOT
12760: OR
12761: IFFALSE 12495
// end ;
12763: PPOPN 3
12765: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12766: LD_EXP 23
12770: NOT
12771: PUSH
12772: LD_EXP 31
12776: AND
12777: IFFALSE 13744
12779: GO 12781
12781: DISABLE
12782: LD_INT 0
12784: PPUSH
12785: PPUSH
12786: PPUSH
12787: PPUSH
// begin enable ;
12788: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12789: LD_INT 22
12791: PUSH
12792: LD_INT 7
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PUSH
12799: LD_INT 30
12801: PUSH
12802: LD_INT 3
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PPUSH
12813: CALL_OW 69
12817: NOT
12818: IFFALSE 12822
// exit ;
12820: GO 13744
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12822: LD_ADDR_VAR 0 4
12826: PUSH
12827: LD_INT 22
12829: PUSH
12830: LD_INT 7
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: LD_INT 30
12839: PUSH
12840: LD_INT 34
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PPUSH
12851: CALL_OW 69
12855: ST_TO_ADDR
// if Prob ( 40 ) then
12856: LD_INT 40
12858: PPUSH
12859: CALL_OW 13
12863: IFFALSE 12990
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12865: LD_INT 1
12867: PPUSH
12868: LD_INT 5
12870: PUSH
12871: LD_INT 3
12873: PUSH
12874: LD_INT 2
12876: PUSH
12877: LD_INT 6
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: PUSH
12886: LD_INT 5
12888: PUSH
12889: LD_INT 3
12891: PUSH
12892: LD_INT 2
12894: PUSH
12895: LD_INT 6
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: LIST
12902: LIST
12903: PUSH
12904: LD_INT 5
12906: PUSH
12907: LD_INT 3
12909: PUSH
12910: LD_INT 2
12912: PUSH
12913: LD_INT 6
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 24
12924: PUSH
12925: LD_INT 3
12927: PUSH
12928: LD_INT 3
12930: PUSH
12931: LD_INT 45
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: PUSH
12940: LD_INT 24
12942: PUSH
12943: LD_INT 3
12945: PUSH
12946: LD_INT 3
12948: PUSH
12949: LD_INT 47
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: PUSH
12958: LD_INT 24
12960: PUSH
12961: LD_INT 3
12963: PUSH
12964: LD_INT 3
12966: PUSH
12967: LD_INT 45
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: LIST
12974: LIST
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: LIST
12983: PPUSH
12984: CALL 58397 0 2
// end else
12988: GO 13113
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12990: LD_INT 1
12992: PPUSH
12993: LD_INT 24
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: LD_INT 3
13001: PUSH
13002: LD_INT 47
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: PUSH
13011: LD_INT 24
13013: PUSH
13014: LD_INT 3
13016: PUSH
13017: LD_INT 3
13019: PUSH
13020: LD_INT 47
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: PUSH
13029: LD_INT 5
13031: PUSH
13032: LD_INT 3
13034: PUSH
13035: LD_INT 2
13037: PUSH
13038: LD_INT 9
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: LIST
13045: LIST
13046: PUSH
13047: LD_INT 5
13049: PUSH
13050: LD_INT 3
13052: PUSH
13053: LD_INT 2
13055: PUSH
13056: LD_INT 9
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 24
13067: PUSH
13068: LD_INT 1
13070: PUSH
13071: LD_INT 3
13073: PUSH
13074: LD_INT 45
13076: PUSH
13077: EMPTY
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 24
13085: PUSH
13086: LD_INT 1
13088: PUSH
13089: LD_INT 3
13091: PUSH
13092: LD_INT 45
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: LIST
13107: LIST
13108: PPUSH
13109: CALL 58397 0 2
// end ; if Difficulty > 1 then
13113: LD_OWVAR 67
13117: PUSH
13118: LD_INT 1
13120: GREATER
13121: IFFALSE 13151
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13123: LD_INT 1
13125: PPUSH
13126: LD_INT 24
13128: PUSH
13129: LD_INT 3
13131: PUSH
13132: LD_INT 3
13134: PUSH
13135: LD_INT 47
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: PUSH
13144: EMPTY
13145: LIST
13146: PPUSH
13147: CALL 58397 0 2
// repeat wait ( 0 0$1 ) ;
13151: LD_INT 35
13153: PPUSH
13154: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13158: LD_INT 1
13160: PPUSH
13161: LD_INT 1
13163: PPUSH
13164: CALL 59815 0 2
13168: PUSH
13169: LD_INT 6
13171: PUSH
13172: LD_INT 7
13174: PUSH
13175: LD_INT 7
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: LIST
13182: PUSH
13183: LD_OWVAR 67
13187: ARRAY
13188: GREATEREQUAL
13189: IFFALSE 13151
// wait ( 0 0$40 ) ;
13191: LD_INT 1400
13193: PPUSH
13194: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13198: LD_ADDR_VAR 0 2
13202: PUSH
13203: LD_INT 1
13205: PPUSH
13206: LD_INT 1
13208: PPUSH
13209: CALL 59815 0 2
13213: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13214: LD_ADDR_EXP 121
13218: PUSH
13219: LD_EXP 121
13223: PPUSH
13224: LD_INT 1
13226: PPUSH
13227: LD_EXP 121
13231: PUSH
13232: LD_INT 1
13234: ARRAY
13235: PUSH
13236: LD_VAR 0 2
13240: DIFF
13241: PPUSH
13242: CALL_OW 1
13246: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13247: LD_ADDR_VAR 0 3
13251: PUSH
13252: LD_INT 0
13254: PPUSH
13255: LD_INT 1
13257: PPUSH
13258: CALL_OW 12
13262: ST_TO_ADDR
// if target then
13263: LD_VAR 0 3
13267: IFFALSE 13433
// begin for i in tmp do
13269: LD_ADDR_VAR 0 1
13273: PUSH
13274: LD_VAR 0 2
13278: PUSH
13279: FOR_IN
13280: IFFALSE 13305
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13282: LD_VAR 0 1
13286: PPUSH
13287: LD_INT 179
13289: PPUSH
13290: LD_INT 209
13292: PPUSH
13293: LD_INT 8
13295: PPUSH
13296: LD_INT 1
13298: PPUSH
13299: CALL_OW 483
13303: GO 13279
13305: POP
13306: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13307: LD_ADDR_VAR 0 2
13311: PUSH
13312: LD_VAR 0 2
13316: PPUSH
13317: LD_INT 24
13319: PUSH
13320: LD_INT 250
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 72
13331: ST_TO_ADDR
// for i in tmp do
13332: LD_ADDR_VAR 0 1
13336: PUSH
13337: LD_VAR 0 2
13341: PUSH
13342: FOR_IN
13343: IFFALSE 13383
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13345: LD_VAR 0 1
13349: PPUSH
13350: LD_INT 179
13352: PPUSH
13353: LD_INT 209
13355: PPUSH
13356: CALL_OW 297
13360: PUSH
13361: LD_INT 9
13363: GREATER
13364: IFFALSE 13381
// ComMoveXY ( i , 179 , 209 ) ;
13366: LD_VAR 0 1
13370: PPUSH
13371: LD_INT 179
13373: PPUSH
13374: LD_INT 209
13376: PPUSH
13377: CALL_OW 111
13381: GO 13342
13383: POP
13384: POP
// wait ( 0 0$1 ) ;
13385: LD_INT 35
13387: PPUSH
13388: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13392: LD_VAR 0 2
13396: PPUSH
13397: LD_INT 92
13399: PUSH
13400: LD_INT 179
13402: PUSH
13403: LD_INT 209
13405: PUSH
13406: LD_INT 9
13408: PUSH
13409: EMPTY
13410: LIST
13411: LIST
13412: LIST
13413: LIST
13414: PPUSH
13415: CALL_OW 72
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_INT 1
13427: MINUS
13428: GREATEREQUAL
13429: IFFALSE 13307
// end else
13431: GO 13595
// begin for i in tmp do
13433: LD_ADDR_VAR 0 1
13437: PUSH
13438: LD_VAR 0 2
13442: PUSH
13443: FOR_IN
13444: IFFALSE 13469
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13446: LD_VAR 0 1
13450: PPUSH
13451: LD_INT 285
13453: PPUSH
13454: LD_INT 163
13456: PPUSH
13457: LD_INT 8
13459: PPUSH
13460: LD_INT 1
13462: PPUSH
13463: CALL_OW 483
13467: GO 13443
13469: POP
13470: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 2
13480: PPUSH
13481: LD_INT 24
13483: PUSH
13484: LD_INT 250
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: PPUSH
13491: CALL_OW 72
13495: ST_TO_ADDR
// for i in tmp do
13496: LD_ADDR_VAR 0 1
13500: PUSH
13501: LD_VAR 0 2
13505: PUSH
13506: FOR_IN
13507: IFFALSE 13547
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13509: LD_VAR 0 1
13513: PPUSH
13514: LD_INT 285
13516: PPUSH
13517: LD_INT 163
13519: PPUSH
13520: CALL_OW 297
13524: PUSH
13525: LD_INT 9
13527: GREATER
13528: IFFALSE 13545
// ComMoveXY ( i , 285 , 163 ) ;
13530: LD_VAR 0 1
13534: PPUSH
13535: LD_INT 285
13537: PPUSH
13538: LD_INT 163
13540: PPUSH
13541: CALL_OW 111
13545: GO 13506
13547: POP
13548: POP
// wait ( 0 0$1 ) ;
13549: LD_INT 35
13551: PPUSH
13552: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13556: LD_VAR 0 2
13560: PPUSH
13561: LD_INT 92
13563: PUSH
13564: LD_INT 285
13566: PUSH
13567: LD_INT 163
13569: PUSH
13570: LD_INT 9
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: PPUSH
13579: CALL_OW 72
13583: PUSH
13584: LD_VAR 0 2
13588: PUSH
13589: LD_INT 1
13591: MINUS
13592: GREATEREQUAL
13593: IFFALSE 13471
// end ; repeat wait ( 0 0$1 ) ;
13595: LD_INT 35
13597: PPUSH
13598: CALL_OW 67
// for i in tmp do
13602: LD_ADDR_VAR 0 1
13606: PUSH
13607: LD_VAR 0 2
13611: PUSH
13612: FOR_IN
13613: IFFALSE 13735
// if GetLives ( i ) > 251 then
13615: LD_VAR 0 1
13619: PPUSH
13620: CALL_OW 256
13624: PUSH
13625: LD_INT 251
13627: GREATER
13628: IFFALSE 13717
// begin if GetWeapon ( i ) = ru_time_lapser then
13630: LD_VAR 0 1
13634: PPUSH
13635: CALL_OW 264
13639: PUSH
13640: LD_INT 49
13642: EQUAL
13643: IFFALSE 13681
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_INT 81
13652: PUSH
13653: LD_INT 7
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PPUSH
13660: CALL_OW 69
13664: PPUSH
13665: LD_VAR 0 1
13669: PPUSH
13670: CALL_OW 74
13674: PPUSH
13675: CALL_OW 112
13679: GO 13715
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13681: LD_VAR 0 1
13685: PPUSH
13686: LD_INT 81
13688: PUSH
13689: LD_INT 7
13691: PUSH
13692: EMPTY
13693: LIST
13694: LIST
13695: PPUSH
13696: CALL_OW 69
13700: PPUSH
13701: LD_VAR 0 1
13705: PPUSH
13706: CALL_OW 74
13710: PPUSH
13711: CALL_OW 115
// end else
13715: GO 13733
// tmp := tmp diff i ;
13717: LD_ADDR_VAR 0 2
13721: PUSH
13722: LD_VAR 0 2
13726: PUSH
13727: LD_VAR 0 1
13731: DIFF
13732: ST_TO_ADDR
13733: GO 13612
13735: POP
13736: POP
// until not tmp ;
13737: LD_VAR 0 2
13741: NOT
13742: IFFALSE 13595
// end ; end_of_file
13744: PPOPN 4
13746: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
13751: PPUSH
13752: PPUSH
// missionStage := 13 ;
13753: LD_ADDR_EXP 15
13757: PUSH
13758: LD_INT 13
13760: ST_TO_ADDR
// uc_side := 2 ;
13761: LD_ADDR_OWVAR 20
13765: PUSH
13766: LD_INT 2
13768: ST_TO_ADDR
// uc_nation := 2 ;
13769: LD_ADDR_OWVAR 21
13773: PUSH
13774: LD_INT 2
13776: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13777: LD_ADDR_EXP 92
13781: PUSH
13782: LD_STRING Omar
13784: PPUSH
13785: CALL_OW 25
13789: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13790: LD_EXP 92
13794: PPUSH
13795: LD_INT 4
13797: PPUSH
13798: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13802: LD_EXP 92
13806: PPUSH
13807: LD_INT 242
13809: PPUSH
13810: LD_INT 75
13812: PPUSH
13813: LD_INT 0
13815: PPUSH
13816: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13820: LD_ADDR_EXP 93
13824: PUSH
13825: LD_STRING Heike
13827: PPUSH
13828: CALL_OW 25
13832: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13833: LD_INT 14
13835: PPUSH
13836: LD_INT 3
13838: PPUSH
13839: LD_INT 1
13841: PPUSH
13842: LD_INT 27
13844: PPUSH
13845: LD_INT 100
13847: PPUSH
13848: CALL 71856 0 5
// veh := CreateVehicle ;
13852: LD_ADDR_VAR 0 3
13856: PUSH
13857: CALL_OW 45
13861: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13862: LD_VAR 0 3
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 242
// SetDir ( veh , 4 ) ;
13874: LD_VAR 0 3
13878: PPUSH
13879: LD_INT 4
13881: PPUSH
13882: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13886: LD_VAR 0 3
13890: PPUSH
13891: LD_INT 241
13893: PPUSH
13894: LD_INT 72
13896: PPUSH
13897: LD_INT 0
13899: PPUSH
13900: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13904: LD_EXP 93
13908: PPUSH
13909: LD_VAR 0 3
13913: PPUSH
13914: CALL_OW 52
// if KhatamStatus then
13918: LD_EXP 8
13922: IFFALSE 13973
// begin Khatam := NewCharacter ( Khatam ) ;
13924: LD_ADDR_EXP 94
13928: PUSH
13929: LD_STRING Khatam
13931: PPUSH
13932: CALL_OW 25
13936: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13937: LD_EXP 94
13941: PPUSH
13942: LD_INT 245
13944: PPUSH
13945: LD_INT 78
13947: PPUSH
13948: LD_INT 3
13950: PPUSH
13951: LD_INT 0
13953: PPUSH
13954: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13958: LD_EXP 94
13962: PPUSH
13963: LD_INT 4
13965: PPUSH
13966: LD_INT 10
13968: PPUSH
13969: CALL_OW 237
// end ; for i = 1 to Difficulty do
13973: LD_ADDR_VAR 0 2
13977: PUSH
13978: DOUBLE
13979: LD_INT 1
13981: DEC
13982: ST_TO_ADDR
13983: LD_OWVAR 67
13987: PUSH
13988: FOR_TO
13989: IFFALSE 14055
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13991: LD_INT 0
13993: PPUSH
13994: LD_INT 7
13996: PUSH
13997: LD_OWVAR 67
14001: PLUS
14002: PPUSH
14003: CALL_OW 384
// un := CreateHuman ;
14007: LD_ADDR_VAR 0 4
14011: PUSH
14012: CALL_OW 44
14016: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14017: LD_VAR 0 4
14021: PPUSH
14022: LD_INT 28
14024: PUSH
14025: LD_INT 29
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PUSH
14032: LD_VAR 0 2
14036: PUSH
14037: LD_INT 2
14039: MOD
14040: PUSH
14041: LD_INT 1
14043: PLUS
14044: ARRAY
14045: PPUSH
14046: LD_INT 0
14048: PPUSH
14049: CALL_OW 49
// end ;
14053: GO 13988
14055: POP
14056: POP
// for i = 1 to 6 do
14057: LD_ADDR_VAR 0 2
14061: PUSH
14062: DOUBLE
14063: LD_INT 1
14065: DEC
14066: ST_TO_ADDR
14067: LD_INT 6
14069: PUSH
14070: FOR_TO
14071: IFFALSE 14116
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14073: LD_INT 0
14075: PPUSH
14076: LD_INT 7
14078: PUSH
14079: LD_OWVAR 67
14083: PLUS
14084: PPUSH
14085: CALL_OW 381
// un := CreateHuman ;
14089: LD_ADDR_VAR 0 4
14093: PUSH
14094: CALL_OW 44
14098: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14099: LD_VAR 0 4
14103: PPUSH
14104: LD_INT 28
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 49
// end ;
14114: GO 14070
14116: POP
14117: POP
// for i = 1 to 3 do
14118: LD_ADDR_VAR 0 2
14122: PUSH
14123: DOUBLE
14124: LD_INT 1
14126: DEC
14127: ST_TO_ADDR
14128: LD_INT 3
14130: PUSH
14131: FOR_TO
14132: IFFALSE 14180
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14134: LD_INT 0
14136: PPUSH
14137: LD_INT 8
14139: PPUSH
14140: LD_INT 7
14142: PUSH
14143: LD_OWVAR 67
14147: PLUS
14148: PPUSH
14149: CALL_OW 380
// un := CreateHuman ;
14153: LD_ADDR_VAR 0 4
14157: PUSH
14158: CALL_OW 44
14162: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14163: LD_VAR 0 4
14167: PPUSH
14168: LD_INT 28
14170: PPUSH
14171: LD_INT 0
14173: PPUSH
14174: CALL_OW 49
// end ;
14178: GO 14131
14180: POP
14181: POP
// for i = 1 to 3 do
14182: LD_ADDR_VAR 0 2
14186: PUSH
14187: DOUBLE
14188: LD_INT 1
14190: DEC
14191: ST_TO_ADDR
14192: LD_INT 3
14194: PUSH
14195: FOR_TO
14196: IFFALSE 14286
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14198: LD_INT 14
14200: PPUSH
14201: LD_INT 2
14203: PPUSH
14204: LD_INT 1
14206: PPUSH
14207: LD_INT 28
14209: PPUSH
14210: LD_INT 80
14212: PPUSH
14213: CALL 71856 0 5
// veh := CreateVehicle ;
14217: LD_ADDR_VAR 0 3
14221: PUSH
14222: CALL_OW 45
14226: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14227: LD_VAR 0 3
14231: PPUSH
14232: LD_INT 3
14234: PPUSH
14235: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14239: LD_VAR 0 3
14243: PPUSH
14244: LD_INT 29
14246: PPUSH
14247: LD_INT 0
14249: PPUSH
14250: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14254: LD_INT 0
14256: PPUSH
14257: LD_INT 7
14259: PUSH
14260: LD_OWVAR 67
14264: PLUS
14265: PPUSH
14266: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14270: CALL_OW 44
14274: PPUSH
14275: LD_VAR 0 3
14279: PPUSH
14280: CALL_OW 52
// end ;
14284: GO 14195
14286: POP
14287: POP
// for i = 1 to 5 + Difficulty do
14288: LD_ADDR_VAR 0 2
14292: PUSH
14293: DOUBLE
14294: LD_INT 1
14296: DEC
14297: ST_TO_ADDR
14298: LD_INT 5
14300: PUSH
14301: LD_OWVAR 67
14305: PLUS
14306: PUSH
14307: FOR_TO
14308: IFFALSE 14435
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14310: LD_INT 14
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 3
14318: PPUSH
14319: CALL_OW 12
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: LD_INT 28
14329: PUSH
14330: LD_INT 26
14332: PUSH
14333: LD_INT 27
14335: PUSH
14336: LD_INT 25
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: PUSH
14345: LD_VAR 0 2
14349: PUSH
14350: LD_INT 4
14352: MOD
14353: PUSH
14354: LD_INT 1
14356: PLUS
14357: ARRAY
14358: PPUSH
14359: LD_INT 80
14361: PPUSH
14362: CALL 71856 0 5
// veh := CreateVehicle ;
14366: LD_ADDR_VAR 0 3
14370: PUSH
14371: CALL_OW 45
14375: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14376: LD_VAR 0 3
14380: PPUSH
14381: LD_INT 4
14383: PPUSH
14384: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14388: LD_VAR 0 3
14392: PPUSH
14393: LD_INT 28
14395: PPUSH
14396: LD_INT 0
14398: PPUSH
14399: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14403: LD_INT 0
14405: PPUSH
14406: LD_INT 7
14408: PUSH
14409: LD_OWVAR 67
14413: PLUS
14414: PPUSH
14415: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14419: CALL_OW 44
14423: PPUSH
14424: LD_VAR 0 3
14428: PPUSH
14429: CALL_OW 52
// end ;
14433: GO 14307
14435: POP
14436: POP
// for i = 1 to 3 do
14437: LD_ADDR_VAR 0 2
14441: PUSH
14442: DOUBLE
14443: LD_INT 1
14445: DEC
14446: ST_TO_ADDR
14447: LD_INT 3
14449: PUSH
14450: FOR_TO
14451: IFFALSE 14511
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14453: LD_INT 14
14455: PPUSH
14456: LD_INT 3
14458: PPUSH
14459: LD_INT 5
14461: PPUSH
14462: LD_INT 29
14464: PPUSH
14465: LD_INT 80
14467: PPUSH
14468: CALL 71856 0 5
// veh := CreateVehicle ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: CALL_OW 45
14481: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14482: LD_VAR 0 3
14486: PPUSH
14487: LD_INT 4
14489: PPUSH
14490: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14494: LD_VAR 0 3
14498: PPUSH
14499: LD_INT 28
14501: PPUSH
14502: LD_INT 0
14504: PPUSH
14505: CALL_OW 49
// end ;
14509: GO 14450
14511: POP
14512: POP
// end ;
14513: LD_VAR 0 1
14517: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14518: LD_INT 22
14520: PUSH
14521: LD_INT 2
14523: PUSH
14524: EMPTY
14525: LIST
14526: LIST
14527: PPUSH
14528: CALL_OW 69
14532: IFFALSE 14832
14534: GO 14536
14536: DISABLE
14537: LD_INT 0
14539: PPUSH
14540: PPUSH
14541: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14542: LD_ADDR_VAR 0 3
14546: PUSH
14547: LD_INT 22
14549: PUSH
14550: LD_INT 2
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: LD_INT 25
14559: PUSH
14560: LD_INT 4
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PPUSH
14571: CALL_OW 69
14575: PUSH
14576: LD_EXP 94
14580: DIFF
14581: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14582: LD_ADDR_VAR 0 2
14586: PUSH
14587: LD_INT 22
14589: PUSH
14590: LD_INT 2
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PPUSH
14597: CALL_OW 69
14601: PUSH
14602: LD_EXP 94
14606: PUSH
14607: LD_VAR 0 3
14611: UNION
14612: DIFF
14613: ST_TO_ADDR
// if Khatam then
14614: LD_EXP 94
14618: IFFALSE 14635
// ComMoveXY ( Khatam , 211 , 92 ) ;
14620: LD_EXP 94
14624: PPUSH
14625: LD_INT 211
14627: PPUSH
14628: LD_INT 92
14630: PPUSH
14631: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14635: LD_INT 197
14637: PPUSH
14638: LD_INT 80
14640: PPUSH
14641: LD_INT 2
14643: PPUSH
14644: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14648: LD_INT 213
14650: PPUSH
14651: LD_INT 90
14653: PPUSH
14654: LD_INT 2
14656: PPUSH
14657: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14661: LD_INT 215
14663: PPUSH
14664: LD_INT 129
14666: PPUSH
14667: LD_INT 2
14669: PPUSH
14670: CALL_OW 441
// if sci then
14674: LD_VAR 0 3
14678: IFFALSE 14699
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14680: LD_VAR 0 3
14684: PUSH
14685: LD_INT 1
14687: ARRAY
14688: PPUSH
14689: LD_INT 197
14691: PPUSH
14692: LD_INT 80
14694: PPUSH
14695: CALL_OW 158
// if sci > 1 then
14699: LD_VAR 0 3
14703: PUSH
14704: LD_INT 1
14706: GREATER
14707: IFFALSE 14728
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14709: LD_VAR 0 3
14713: PUSH
14714: LD_INT 2
14716: ARRAY
14717: PPUSH
14718: LD_INT 213
14720: PPUSH
14721: LD_INT 90
14723: PPUSH
14724: CALL_OW 158
// if sci > 2 then
14728: LD_VAR 0 3
14732: PUSH
14733: LD_INT 2
14735: GREATER
14736: IFFALSE 14757
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14738: LD_VAR 0 3
14742: PUSH
14743: LD_INT 3
14745: ARRAY
14746: PPUSH
14747: LD_INT 215
14749: PPUSH
14750: LD_INT 129
14752: PPUSH
14753: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14757: LD_INT 35
14759: PPUSH
14760: CALL_OW 67
// for i in tmp do
14764: LD_ADDR_VAR 0 1
14768: PUSH
14769: LD_VAR 0 2
14773: PUSH
14774: FOR_IN
14775: IFFALSE 14813
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14777: LD_VAR 0 1
14781: PPUSH
14782: LD_INT 81
14784: PUSH
14785: LD_INT 2
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: PPUSH
14797: LD_VAR 0 1
14801: PPUSH
14802: CALL_OW 74
14806: PPUSH
14807: CALL_OW 115
14811: GO 14774
14813: POP
14814: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14815: LD_INT 22
14817: PUSH
14818: LD_INT 2
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PPUSH
14825: CALL_OW 69
14829: NOT
14830: IFFALSE 14757
// end ; end_of_file
14832: PPOPN 3
14834: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14835: LD_INT 0
14837: PPUSH
14838: PPUSH
14839: PPUSH
14840: PPUSH
14841: PPUSH
14842: PPUSH
14843: PPUSH
14844: PPUSH
14845: PPUSH
// Video ( true ) ;
14846: LD_INT 1
14848: PPUSH
14849: CALL 107576 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14853: LD_ADDR_VAR 0 5
14857: PUSH
14858: LD_INT 7
14860: PPUSH
14861: LD_INT 0
14863: PPUSH
14864: CALL_OW 517
14868: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14869: LD_ADDR_VAR 0 2
14873: PUSH
14874: DOUBLE
14875: LD_INT 1
14877: DEC
14878: ST_TO_ADDR
14879: LD_VAR 0 5
14883: PUSH
14884: LD_INT 1
14886: ARRAY
14887: PUSH
14888: FOR_TO
14889: IFFALSE 14934
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14891: LD_VAR 0 5
14895: PUSH
14896: LD_INT 1
14898: ARRAY
14899: PUSH
14900: LD_VAR 0 2
14904: ARRAY
14905: PPUSH
14906: LD_VAR 0 5
14910: PUSH
14911: LD_INT 2
14913: ARRAY
14914: PUSH
14915: LD_VAR 0 2
14919: ARRAY
14920: PPUSH
14921: LD_INT 1
14923: PPUSH
14924: LD_INT 15
14926: NEG
14927: PPUSH
14928: CALL 107490 0 4
14932: GO 14888
14934: POP
14935: POP
// CenterNowOnUnits ( Powell ) ;
14936: LD_EXP 58
14940: PPUSH
14941: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14945: LD_ADDR_VAR 0 5
14949: PUSH
14950: LD_EXP 56
14954: PUSH
14955: EMPTY
14956: LIST
14957: ST_TO_ADDR
// if GirlNewVeh then
14958: LD_EXP 57
14962: IFFALSE 14980
// tmp := tmp ^ GirlNewVeh ;
14964: LD_ADDR_VAR 0 5
14968: PUSH
14969: LD_VAR 0 5
14973: PUSH
14974: LD_EXP 57
14978: ADD
14979: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14980: LD_VAR 0 5
14984: PPUSH
14985: LD_INT 60
14987: PPUSH
14988: LD_INT 109
14990: PPUSH
14991: CALL_OW 111
// if KappaStatus then
14995: LD_EXP 2
14999: IFFALSE 15051
// begin Say ( JMM , D1nT-JMM-1 ) ;
15001: LD_EXP 39
15005: PPUSH
15006: LD_STRING D1nT-JMM-1
15008: PPUSH
15009: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15013: LD_EXP 58
15017: PPUSH
15018: LD_STRING D1T-Pow-1
15020: PPUSH
15021: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15025: LD_EXP 39
15029: PPUSH
15030: LD_STRING D1T-JMM-2
15032: PPUSH
15033: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15037: LD_EXP 58
15041: PPUSH
15042: LD_STRING D1T-Pow-2
15044: PPUSH
15045: CALL_OW 88
// end else
15049: GO 15257
// if JMMGirlStatus then
15051: LD_EXP 6
15055: IFFALSE 15200
// begin Say ( JMM , D1T-JMM-1 ) ;
15057: LD_EXP 39
15061: PPUSH
15062: LD_STRING D1T-JMM-1
15064: PPUSH
15065: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15069: LD_EXP 58
15073: PPUSH
15074: LD_STRING D1T-Pow-1
15076: PPUSH
15077: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15081: LD_EXP 39
15085: PPUSH
15086: LD_STRING D1T-JMM-3
15088: PPUSH
15089: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15093: LD_EXP 58
15097: PPUSH
15098: LD_STRING D1T-Pow-3
15100: PPUSH
15101: CALL_OW 88
// if JMMGirl then
15105: LD_EXP 7
15109: IFFALSE 15198
// begin case JMMGirl of 1 :
15111: LD_EXP 7
15115: PUSH
15116: LD_INT 1
15118: DOUBLE
15119: EQUAL
15120: IFTRUE 15124
15122: GO 15139
15124: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15125: LD_EXP 40
15129: PPUSH
15130: LD_STRING D1T-Joan-3
15132: PPUSH
15133: CALL_OW 88
15137: GO 15186
15139: LD_INT 2
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15162
15147: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15148: LD_EXP 42
15152: PPUSH
15153: LD_STRING D1T-Lisa-3
15155: PPUSH
15156: CALL_OW 88
15160: GO 15186
15162: LD_INT 3
15164: DOUBLE
15165: EQUAL
15166: IFTRUE 15170
15168: GO 15185
15170: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15171: LD_EXP 54
15175: PPUSH
15176: LD_STRING D1T-Con-3
15178: PPUSH
15179: CALL_OW 88
15183: GO 15186
15185: POP
// Say ( Powell , D1T-Pow-4 ) ;
15186: LD_EXP 58
15190: PPUSH
15191: LD_STRING D1T-Pow-4
15193: PPUSH
15194: CALL_OW 88
// end ; end else
15198: GO 15257
// if not FastEnd then
15200: LD_EXP 11
15204: NOT
15205: IFFALSE 15233
// begin Say ( JMM , D1T-JMM-4 ) ;
15207: LD_EXP 39
15211: PPUSH
15212: LD_STRING D1T-JMM-4
15214: PPUSH
15215: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15219: LD_EXP 58
15223: PPUSH
15224: LD_STRING D1T-Pow-5
15226: PPUSH
15227: CALL_OW 88
// end else
15231: GO 15257
// begin Say ( JMM , D1nT-JMM-1 ) ;
15233: LD_EXP 39
15237: PPUSH
15238: LD_STRING D1nT-JMM-1
15240: PPUSH
15241: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15245: LD_EXP 58
15249: PPUSH
15250: LD_STRING D1nT-Pow-1
15252: PPUSH
15253: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15257: LD_INT 35
15259: PPUSH
15260: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15264: LD_EXP 56
15268: PPUSH
15269: CALL_OW 314
15273: NOT
15274: IFFALSE 15257
// ComExitVehicle ( JMM ) ;
15276: LD_EXP 39
15280: PPUSH
15281: CALL_OW 121
// wait ( 3 ) ;
15285: LD_INT 3
15287: PPUSH
15288: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15292: LD_EXP 39
15296: PPUSH
15297: LD_INT 60
15299: PPUSH
15300: LD_INT 94
15302: PPUSH
15303: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15307: LD_EXP 39
15311: PPUSH
15312: LD_EXP 58
15316: PPUSH
15317: CALL_OW 179
// if Joan then
15321: LD_EXP 40
15325: IFFALSE 15379
// begin ComExitVehicle ( Joan ) ;
15327: LD_EXP 40
15331: PPUSH
15332: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15336: LD_EXP 40
15340: PPUSH
15341: LD_INT 35
15343: PPUSH
15344: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15348: LD_EXP 40
15352: PPUSH
15353: LD_INT 65
15355: PPUSH
15356: LD_INT 104
15358: PPUSH
15359: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15363: LD_EXP 40
15367: PPUSH
15368: LD_EXP 39
15372: PPUSH
15373: CALL_OW 179
// end else
15377: GO 15513
// if Lisa and JMMGirl = 2 then
15379: LD_EXP 42
15383: PUSH
15384: LD_EXP 7
15388: PUSH
15389: LD_INT 2
15391: EQUAL
15392: AND
15393: IFFALSE 15447
// begin ComExitVehicle ( Lisa ) ;
15395: LD_EXP 42
15399: PPUSH
15400: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15404: LD_EXP 42
15408: PPUSH
15409: LD_INT 35
15411: PPUSH
15412: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15416: LD_EXP 42
15420: PPUSH
15421: LD_INT 65
15423: PPUSH
15424: LD_INT 104
15426: PPUSH
15427: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15431: LD_EXP 42
15435: PPUSH
15436: LD_EXP 39
15440: PPUSH
15441: CALL_OW 179
// end else
15445: GO 15513
// if Connie and JMMGirl = 3 then
15447: LD_EXP 54
15451: PUSH
15452: LD_EXP 7
15456: PUSH
15457: LD_INT 3
15459: EQUAL
15460: AND
15461: IFFALSE 15513
// begin ComExitVehicle ( Connie ) ;
15463: LD_EXP 54
15467: PPUSH
15468: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15472: LD_EXP 54
15476: PPUSH
15477: LD_INT 35
15479: PPUSH
15480: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15484: LD_EXP 54
15488: PPUSH
15489: LD_INT 65
15491: PPUSH
15492: LD_INT 104
15494: PPUSH
15495: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15499: LD_EXP 54
15503: PPUSH
15504: LD_EXP 39
15508: PPUSH
15509: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15513: LD_INT 35
15515: PPUSH
15516: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15520: LD_EXP 39
15524: PPUSH
15525: LD_EXP 58
15529: PPUSH
15530: CALL_OW 296
15534: PUSH
15535: LD_INT 6
15537: LESS
15538: IFFALSE 15513
// wait ( 0 0$0.5 ) ;
15540: LD_INT 18
15542: PPUSH
15543: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15547: LD_EXP 39
15551: PPUSH
15552: LD_STRING D1-JMM-1
15554: PPUSH
15555: CALL_OW 88
// async ;
15559: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15560: LD_EXP 58
15564: PPUSH
15565: LD_STRING D1-Pow-1
15567: PPUSH
15568: CALL_OW 88
// if not dialogue_skipped then
15572: LD_OWVAR 59
15576: NOT
15577: IFFALSE 15586
// wait ( 0 0$2 ) ;
15579: LD_INT 70
15581: PPUSH
15582: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15586: LD_INT 170
15588: PPUSH
15589: LD_INT 99
15591: PPUSH
15592: LD_INT 1
15594: PPUSH
15595: LD_INT 6
15597: NEG
15598: PPUSH
15599: CALL 107490 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15603: LD_INT 174
15605: PPUSH
15606: LD_INT 115
15608: PPUSH
15609: LD_INT 1
15611: PPUSH
15612: LD_INT 6
15614: NEG
15615: PPUSH
15616: CALL 107490 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15620: LD_INT 169
15622: PPUSH
15623: LD_INT 71
15625: PPUSH
15626: LD_INT 1
15628: PPUSH
15629: LD_INT 6
15631: NEG
15632: PPUSH
15633: CALL 107490 0 4
// if not dialogue_skipped then
15637: LD_OWVAR 59
15641: NOT
15642: IFFALSE 15661
// begin CenterOnXY ( 170 , 99 ) ;
15644: LD_INT 170
15646: PPUSH
15647: LD_INT 99
15649: PPUSH
15650: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15654: LD_INT 80
15656: PPUSH
15657: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15661: LD_INT 75
15663: PPUSH
15664: LD_INT 53
15666: PPUSH
15667: LD_INT 1
15669: PPUSH
15670: LD_INT 9
15672: NEG
15673: PPUSH
15674: CALL 107490 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15678: LD_INT 54
15680: PPUSH
15681: LD_INT 42
15683: PPUSH
15684: LD_INT 1
15686: PPUSH
15687: LD_INT 9
15689: NEG
15690: PPUSH
15691: CALL 107490 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15695: LD_INT 62
15697: PPUSH
15698: LD_INT 51
15700: PPUSH
15701: LD_INT 1
15703: PPUSH
15704: LD_INT 9
15706: NEG
15707: PPUSH
15708: CALL 107490 0 4
// if not dialogue_skipped then
15712: LD_OWVAR 59
15716: NOT
15717: IFFALSE 15736
// begin CenterOnXY ( 75 , 53 ) ;
15719: LD_INT 75
15721: PPUSH
15722: LD_INT 53
15724: PPUSH
15725: CALL_OW 84
// wait ( 0 0$4 ) ;
15729: LD_INT 140
15731: PPUSH
15732: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15736: LD_EXP 58
15740: PPUSH
15741: CALL_OW 87
// if not dialogue_skipped then
15745: LD_OWVAR 59
15749: NOT
15750: IFFALSE 15759
// wait ( 0 0$2 ) ;
15752: LD_INT 70
15754: PPUSH
15755: CALL_OW 67
// sync ;
15759: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15760: LD_EXP 39
15764: PPUSH
15765: LD_STRING D1-JMM-2
15767: PPUSH
15768: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15772: LD_EXP 58
15776: PPUSH
15777: LD_STRING D1-Pow-2
15779: PPUSH
15780: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15784: LD_EXP 39
15788: PPUSH
15789: LD_STRING D1-JMM-3
15791: PPUSH
15792: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15796: LD_EXP 58
15800: PPUSH
15801: LD_STRING D1-Pow-3
15803: PPUSH
15804: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15808: LD_EXP 39
15812: PPUSH
15813: LD_STRING D1-JMM-4
15815: PPUSH
15816: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15820: LD_EXP 58
15824: PPUSH
15825: LD_STRING D1-Pow-4
15827: PPUSH
15828: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15832: LD_EXP 39
15836: PPUSH
15837: LD_STRING D1-JMM-5
15839: PPUSH
15840: CALL_OW 88
// async ;
15844: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15845: LD_EXP 58
15849: PPUSH
15850: LD_STRING D1-Pow-5
15852: PPUSH
15853: CALL_OW 88
// if not dialogue_skipped then
15857: LD_OWVAR 59
15861: NOT
15862: IFFALSE 15871
// wait ( 0 0$3.6 ) ;
15864: LD_INT 126
15866: PPUSH
15867: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15871: LD_INT 134
15873: PPUSH
15874: LD_INT 210
15876: PPUSH
15877: LD_INT 1
15879: PPUSH
15880: LD_INT 11
15882: NEG
15883: PPUSH
15884: CALL 107490 0 4
// if not dialogue_skipped then
15888: LD_OWVAR 59
15892: NOT
15893: IFFALSE 15912
// begin CenterOnXY ( 134 , 210 ) ;
15895: LD_INT 134
15897: PPUSH
15898: LD_INT 210
15900: PPUSH
15901: CALL_OW 84
// wait ( 0 0$2 ) ;
15905: LD_INT 70
15907: PPUSH
15908: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15912: LD_INT 101
15914: PPUSH
15915: LD_INT 159
15917: PPUSH
15918: LD_INT 1
15920: PPUSH
15921: LD_INT 10
15923: NEG
15924: PPUSH
15925: CALL 107490 0 4
// if not dialogue_skipped then
15929: LD_OWVAR 59
15933: NOT
15934: IFFALSE 15953
// begin CenterOnXY ( 101 , 159 ) ;
15936: LD_INT 101
15938: PPUSH
15939: LD_INT 159
15941: PPUSH
15942: CALL_OW 84
// wait ( 0 0$2 ) ;
15946: LD_INT 70
15948: PPUSH
15949: CALL_OW 67
// end ; sync ;
15953: SYNC
// CenterNowOnUnits ( Powell ) ;
15954: LD_EXP 58
15958: PPUSH
15959: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15963: LD_ADDR_VAR 0 6
15967: PUSH
15968: LD_INT 1
15970: PUSH
15971: LD_INT 2
15973: PUSH
15974: LD_INT 3
15976: PUSH
15977: LD_INT 4
15979: PUSH
15980: LD_INT 5
15982: PUSH
15983: LD_INT 6
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: LIST
15993: ST_TO_ADDR
// if not dialogue_skipped then
15994: LD_OWVAR 59
15998: NOT
15999: IFFALSE 16168
// begin game_speed := 4 ;
16001: LD_ADDR_OWVAR 65
16005: PUSH
16006: LD_INT 4
16008: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16009: LD_INT 210
16011: PPUSH
16012: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16016: LD_ADDR_VAR 0 7
16020: PUSH
16021: LD_STRING Q1
16023: PPUSH
16024: LD_VAR 0 6
16028: PPUSH
16029: CALL_OW 98
16033: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16034: LD_ADDR_VAR 0 7
16038: PUSH
16039: LD_STRING Q1
16041: PPUSH
16042: LD_VAR 0 6
16046: PPUSH
16047: CALL_OW 98
16051: ST_TO_ADDR
// options = options diff dec ;
16052: LD_ADDR_VAR 0 6
16056: PUSH
16057: LD_VAR 0 6
16061: PUSH
16062: LD_VAR 0 7
16066: DIFF
16067: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16068: LD_VAR 0 7
16072: PPUSH
16073: LD_VAR 0 6
16077: PPUSH
16078: CALL 17640 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16082: LD_VAR 0 7
16086: PUSH
16087: LD_INT 5
16089: PUSH
16090: LD_INT 6
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: IN
16097: PUSH
16098: LD_VAR 0 6
16102: PUSH
16103: LD_INT 2
16105: EQUAL
16106: OR
16107: IFFALSE 16034
// if not ( dec in [ 5 , 6 ] ) then
16109: LD_VAR 0 7
16113: PUSH
16114: LD_INT 5
16116: PUSH
16117: LD_INT 6
16119: PUSH
16120: EMPTY
16121: LIST
16122: LIST
16123: IN
16124: NOT
16125: IFFALSE 16168
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16127: LD_ADDR_VAR 0 7
16131: PUSH
16132: LD_STRING Q1a
16134: PPUSH
16135: LD_INT 1
16137: PUSH
16138: LD_INT 2
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16150: LD_VAR 0 7
16154: PUSH
16155: LD_INT 4
16157: PLUS
16158: PPUSH
16159: LD_VAR 0 6
16163: PPUSH
16164: CALL 17640 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16168: LD_INT 81
16170: PPUSH
16171: LD_INT 127
16173: PPUSH
16174: CALL_OW 84
// amount := 5 ;
16178: LD_ADDR_VAR 0 8
16182: PUSH
16183: LD_INT 5
16185: ST_TO_ADDR
// macmilan_squad := [ ] ;
16186: LD_ADDR_VAR 0 9
16190: PUSH
16191: EMPTY
16192: ST_TO_ADDR
// if vip < amount then
16193: LD_EXP 59
16197: PUSH
16198: LD_VAR 0 8
16202: LESS
16203: IFFALSE 16247
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16205: LD_ADDR_VAR 0 5
16209: PUSH
16210: LD_EXP 59
16214: PUSH
16215: LD_INT 22
16217: PUSH
16218: LD_INT 4
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: PUSH
16225: LD_INT 21
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: EMPTY
16236: LIST
16237: LIST
16238: PPUSH
16239: CALL_OW 69
16243: UNION
16244: ST_TO_ADDR
16245: GO 16257
// tmp := vip ;
16247: LD_ADDR_VAR 0 5
16251: PUSH
16252: LD_EXP 59
16256: ST_TO_ADDR
// tmp := tmp diff Powell ;
16257: LD_ADDR_VAR 0 5
16261: PUSH
16262: LD_VAR 0 5
16266: PUSH
16267: LD_EXP 58
16271: DIFF
16272: ST_TO_ADDR
// if tmp < amount then
16273: LD_VAR 0 5
16277: PUSH
16278: LD_VAR 0 8
16282: LESS
16283: IFFALSE 16295
// amount := tmp ;
16285: LD_ADDR_VAR 0 8
16289: PUSH
16290: LD_VAR 0 5
16294: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16295: LD_VAR 0 5
16299: PUSH
16300: LD_INT 1
16302: ARRAY
16303: PPUSH
16304: CALL_OW 257
16308: PUSH
16309: LD_INT 2
16311: NONEQUAL
16312: IFFALSE 16374
// begin if IsInUnit ( tmp [ 1 ] ) then
16314: LD_VAR 0 5
16318: PUSH
16319: LD_INT 1
16321: ARRAY
16322: PPUSH
16323: CALL_OW 310
16327: IFFALSE 16342
// ComExitBuilding ( tmp [ 1 ] ) ;
16329: LD_VAR 0 5
16333: PUSH
16334: LD_INT 1
16336: ARRAY
16337: PPUSH
16338: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16342: LD_VAR 0 5
16346: PUSH
16347: LD_INT 1
16349: ARRAY
16350: PPUSH
16351: LD_INT 387
16353: PPUSH
16354: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16358: LD_VAR 0 5
16362: PUSH
16363: LD_INT 1
16365: ARRAY
16366: PPUSH
16367: LD_INT 2
16369: PPUSH
16370: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16374: LD_EXP 39
16378: PPUSH
16379: LD_INT 82
16381: PPUSH
16382: LD_INT 129
16384: PPUSH
16385: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16389: LD_EXP 39
16393: PPUSH
16394: LD_EXP 58
16398: PPUSH
16399: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16403: LD_INT 22
16405: PUSH
16406: LD_INT 1
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: PPUSH
16413: CALL_OW 69
16417: PUSH
16418: LD_EXP 39
16422: DIFF
16423: PPUSH
16424: LD_INT 84
16426: PPUSH
16427: LD_INT 128
16429: PPUSH
16430: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16434: LD_INT 22
16436: PUSH
16437: LD_INT 1
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PPUSH
16444: CALL_OW 69
16448: PUSH
16449: LD_EXP 39
16453: DIFF
16454: PPUSH
16455: LD_EXP 39
16459: PPUSH
16460: CALL_OW 179
// for i = 1 to amount do
16464: LD_ADDR_VAR 0 2
16468: PUSH
16469: DOUBLE
16470: LD_INT 1
16472: DEC
16473: ST_TO_ADDR
16474: LD_VAR 0 8
16478: PUSH
16479: FOR_TO
16480: IFFALSE 16648
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16482: LD_ADDR_VAR 0 9
16486: PUSH
16487: LD_VAR 0 9
16491: PUSH
16492: LD_VAR 0 5
16496: PUSH
16497: LD_VAR 0 2
16501: ARRAY
16502: ADD
16503: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16504: LD_VAR 0 5
16508: PUSH
16509: LD_VAR 0 2
16513: ARRAY
16514: PPUSH
16515: CALL_OW 310
16519: IFFALSE 16536
// AddComExitBuilding ( tmp [ i ] ) ;
16521: LD_VAR 0 5
16525: PUSH
16526: LD_VAR 0 2
16530: ARRAY
16531: PPUSH
16532: CALL_OW 182
// if i = 2 and JMMNewVeh then
16536: LD_VAR 0 2
16540: PUSH
16541: LD_INT 2
16543: EQUAL
16544: PUSH
16545: LD_EXP 56
16549: AND
16550: IFFALSE 16608
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16552: LD_VAR 0 5
16556: PUSH
16557: LD_VAR 0 2
16561: ARRAY
16562: PPUSH
16563: LD_EXP 56
16567: PPUSH
16568: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16572: LD_VAR 0 5
16576: PUSH
16577: LD_VAR 0 2
16581: ARRAY
16582: PPUSH
16583: LD_INT 86
16585: PPUSH
16586: LD_INT 133
16588: PPUSH
16589: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16593: LD_VAR 0 5
16597: PUSH
16598: LD_VAR 0 2
16602: ARRAY
16603: PPUSH
16604: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: PPUSH
16619: LD_INT 8
16621: PPUSH
16622: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16626: LD_VAR 0 5
16630: PUSH
16631: LD_VAR 0 2
16635: ARRAY
16636: PPUSH
16637: LD_EXP 39
16641: PPUSH
16642: CALL_OW 179
// end ;
16646: GO 16479
16648: POP
16649: POP
// if GirlNewVeh then
16650: LD_EXP 57
16654: IFFALSE 16668
// SetSide ( GirlNewVeh , 4 ) ;
16656: LD_EXP 57
16660: PPUSH
16661: LD_INT 4
16663: PPUSH
16664: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16668: LD_INT 35
16670: PPUSH
16671: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16675: LD_VAR 0 9
16679: PPUSH
16680: LD_INT 95
16682: PUSH
16683: LD_INT 9
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PPUSH
16690: CALL_OW 72
16694: PUSH
16695: LD_INT 0
16697: EQUAL
16698: PUSH
16699: LD_EXP 39
16703: PPUSH
16704: LD_INT 9
16706: PPUSH
16707: CALL_OW 308
16711: NOT
16712: AND
16713: IFFALSE 16668
// wait ( 0 0$2 ) ;
16715: LD_INT 70
16717: PPUSH
16718: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16722: LD_VAR 0 9
16726: PPUSH
16727: LD_INT 1
16729: PPUSH
16730: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16734: LD_INT 21
16736: PUSH
16737: LD_INT 2
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: PUSH
16744: LD_INT 92
16746: PUSH
16747: LD_INT 83
16749: PUSH
16750: LD_INT 130
16752: PUSH
16753: LD_INT 10
16755: PUSH
16756: EMPTY
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PPUSH
16766: CALL_OW 69
16770: PPUSH
16771: LD_INT 1
16773: PPUSH
16774: CALL_OW 235
// Video ( false ) ;
16778: LD_INT 0
16780: PPUSH
16781: CALL 107576 0 1
// ChangeMissionObjectives ( M1 ) ;
16785: LD_STRING M1
16787: PPUSH
16788: CALL_OW 337
// SaveForQuickRestart ;
16792: CALL_OW 22
// missionStart := true ;
16796: LD_ADDR_EXP 13
16800: PUSH
16801: LD_INT 1
16803: ST_TO_ADDR
// missionStage := 2 ;
16804: LD_ADDR_EXP 15
16808: PUSH
16809: LD_INT 2
16811: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16812: LD_INT 105
16814: PPUSH
16815: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16819: LD_ADDR_VAR 0 5
16823: PUSH
16824: LD_INT 22
16826: PUSH
16827: LD_INT 4
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: PUSH
16834: LD_INT 21
16836: PUSH
16837: LD_INT 1
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PPUSH
16848: CALL_OW 69
16852: PUSH
16853: LD_EXP 58
16857: DIFF
16858: ST_TO_ADDR
// if not tmp then
16859: LD_VAR 0 5
16863: NOT
16864: IFFALSE 16879
// tmp := [ Powell ] ;
16866: LD_ADDR_VAR 0 5
16870: PUSH
16871: LD_EXP 58
16875: PUSH
16876: EMPTY
16877: LIST
16878: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16879: LD_ADDR_EXP 102
16883: PUSH
16884: LD_EXP 102
16888: PPUSH
16889: LD_INT 4
16891: PPUSH
16892: LD_INT 22
16894: PUSH
16895: LD_INT 4
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 23
16904: PUSH
16905: LD_INT 1
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: LD_INT 3
16914: PUSH
16915: LD_INT 21
16917: PUSH
16918: LD_INT 2
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: LIST
16933: PPUSH
16934: CALL_OW 69
16938: PUSH
16939: LD_EXP 58
16943: DIFF
16944: PPUSH
16945: CALL_OW 1
16949: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16950: LD_ADDR_VAR 0 4
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 34
16967: PUSH
16968: LD_INT 12
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16988: LD_VAR 0 5
16992: PUSH
16993: LD_INT 1
16995: ARRAY
16996: PPUSH
16997: CALL_OW 310
17001: IFFALSE 17016
// ComExitBuilding ( tmp [ 1 ] ) ;
17003: LD_VAR 0 5
17007: PUSH
17008: LD_INT 1
17010: ARRAY
17011: PPUSH
17012: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17016: LD_VAR 0 5
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: LD_VAR 0 4
17029: PPUSH
17030: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17034: LD_VAR 0 5
17038: PUSH
17039: LD_INT 1
17041: ARRAY
17042: PPUSH
17043: LD_INT 80
17045: PPUSH
17046: LD_INT 136
17048: PPUSH
17049: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17053: LD_VAR 0 5
17057: PUSH
17058: LD_INT 1
17060: ARRAY
17061: PPUSH
17062: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17066: LD_VAR 0 5
17070: PUSH
17071: LD_INT 1
17073: ARRAY
17074: PPUSH
17075: LD_INT 59
17077: PPUSH
17078: LD_INT 112
17080: PPUSH
17081: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17085: LD_VAR 0 5
17089: PUSH
17090: LD_INT 1
17092: ARRAY
17093: PPUSH
17094: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17098: LD_EXP 40
17102: PUSH
17103: LD_EXP 40
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17143
// begin Say ( Joan , D3W-Joan-1 ) ;
17119: LD_EXP 40
17123: PPUSH
17124: LD_STRING D3W-Joan-1
17126: PPUSH
17127: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17131: LD_EXP 39
17135: PPUSH
17136: LD_STRING D3W-JMM-1
17138: PPUSH
17139: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17143: LD_EXP 42
17147: PUSH
17148: LD_EXP 42
17152: PPUSH
17153: CALL_OW 255
17157: PUSH
17158: LD_INT 1
17160: EQUAL
17161: AND
17162: PUSH
17163: LD_EXP 42
17167: PUSH
17168: LD_EXP 59
17172: IN
17173: NOT
17174: AND
17175: IFFALSE 17201
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17177: LD_EXP 42
17181: PPUSH
17182: LD_STRING D3W-Lisa-1
17184: PPUSH
17185: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17189: LD_EXP 39
17193: PPUSH
17194: LD_STRING D3W-JMM-1
17196: PPUSH
17197: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17201: LD_EXP 54
17205: PUSH
17206: LD_EXP 54
17210: PPUSH
17211: CALL_OW 255
17215: PUSH
17216: LD_INT 1
17218: EQUAL
17219: AND
17220: IFFALSE 17246
// begin Say ( Connie , D3W-Con-1 ) ;
17222: LD_EXP 54
17226: PPUSH
17227: LD_STRING D3W-Con-1
17229: PPUSH
17230: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17234: LD_EXP 39
17238: PPUSH
17239: LD_STRING D3W-JMM-1
17241: PPUSH
17242: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17246: LD_EXP 42
17250: PUSH
17251: LD_EXP 59
17255: IN
17256: PUSH
17257: LD_EXP 42
17261: PPUSH
17262: CALL_OW 255
17266: PUSH
17267: LD_INT 1
17269: EQUAL
17270: AND
17271: IFFALSE 17287
// Say ( Lisa , D3nW-Lisa-1 ) else
17273: LD_EXP 42
17277: PPUSH
17278: LD_STRING D3nW-Lisa-1
17280: PPUSH
17281: CALL_OW 88
17285: GO 17531
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17287: LD_EXP 45
17291: PUSH
17292: LD_EXP 59
17296: IN
17297: PUSH
17298: LD_EXP 45
17302: PPUSH
17303: CALL_OW 255
17307: PUSH
17308: LD_INT 1
17310: EQUAL
17311: AND
17312: IFFALSE 17328
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17314: LD_EXP 45
17318: PPUSH
17319: LD_STRING D3nW-Cyrus-1
17321: PPUSH
17322: CALL_OW 88
17326: GO 17531
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17328: LD_EXP 44
17332: PUSH
17333: LD_EXP 59
17337: IN
17338: PUSH
17339: LD_EXP 44
17343: PPUSH
17344: CALL_OW 255
17348: PUSH
17349: LD_INT 1
17351: EQUAL
17352: AND
17353: IFFALSE 17369
// Say ( Bobby , D3nW-Bobby-1 ) else
17355: LD_EXP 44
17359: PPUSH
17360: LD_STRING D3nW-Bobby-1
17362: PPUSH
17363: CALL_OW 88
17367: GO 17531
// if Gary in vip and GetSide ( Gary ) = 1 then
17369: LD_EXP 51
17373: PUSH
17374: LD_EXP 59
17378: IN
17379: PUSH
17380: LD_EXP 51
17384: PPUSH
17385: CALL_OW 255
17389: PUSH
17390: LD_INT 1
17392: EQUAL
17393: AND
17394: IFFALSE 17410
// Say ( Gary , D3nW-Gary-1 ) else
17396: LD_EXP 51
17400: PPUSH
17401: LD_STRING D3nW-Gary-1
17403: PPUSH
17404: CALL_OW 88
17408: GO 17531
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17410: LD_EXP 43
17414: PUSH
17415: LD_EXP 59
17419: IN
17420: PUSH
17421: LD_EXP 43
17425: PPUSH
17426: CALL_OW 255
17430: PUSH
17431: LD_INT 1
17433: EQUAL
17434: AND
17435: IFFALSE 17451
// Say ( Donaldson , D3nW-Don-1 ) else
17437: LD_EXP 43
17441: PPUSH
17442: LD_STRING D3nW-Don-1
17444: PPUSH
17445: CALL_OW 88
17449: GO 17531
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17451: LD_EXP 50
17455: PUSH
17456: LD_EXP 59
17460: IN
17461: PUSH
17462: LD_EXP 50
17466: PPUSH
17467: CALL_OW 255
17471: PUSH
17472: LD_INT 1
17474: EQUAL
17475: AND
17476: IFFALSE 17492
// Say ( Cornel , D3nW-Corn-1 ) else
17478: LD_EXP 50
17482: PPUSH
17483: LD_STRING D3nW-Corn-1
17485: PPUSH
17486: CALL_OW 88
17490: GO 17531
// if Frank in vip and GetSide ( Frank ) = 1 then
17492: LD_EXP 52
17496: PUSH
17497: LD_EXP 59
17501: IN
17502: PUSH
17503: LD_EXP 52
17507: PPUSH
17508: CALL_OW 255
17512: PUSH
17513: LD_INT 1
17515: EQUAL
17516: AND
17517: IFFALSE 17531
// Say ( Frank , D3nW-Frank-1 ) ;
17519: LD_EXP 52
17523: PPUSH
17524: LD_STRING D3nW-Frank-1
17526: PPUSH
17527: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17531: LD_EXP 59
17535: PPUSH
17536: LD_INT 22
17538: PUSH
17539: LD_INT 1
17541: PUSH
17542: EMPTY
17543: LIST
17544: LIST
17545: PPUSH
17546: CALL_OW 72
17550: IFFALSE 17576
// begin Say ( JMM , D3nW-JMM-1 ) ;
17552: LD_EXP 39
17556: PPUSH
17557: LD_STRING D3nW-JMM-1
17559: PPUSH
17560: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17564: LD_EXP 39
17568: PPUSH
17569: LD_STRING D3nW-JMM-1a
17571: PPUSH
17572: CALL_OW 88
// end ; t := 0 0$00 ;
17576: LD_ADDR_VAR 0 3
17580: PUSH
17581: LD_INT 0
17583: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17584: LD_INT 35
17586: PPUSH
17587: CALL_OW 67
// t := t + 0 0$1 ;
17591: LD_ADDR_VAR 0 3
17595: PUSH
17596: LD_VAR 0 3
17600: PUSH
17601: LD_INT 35
17603: PLUS
17604: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17605: LD_INT 59
17607: PPUSH
17608: LD_INT 112
17610: PPUSH
17611: CALL_OW 428
17615: PUSH
17616: LD_VAR 0 3
17620: PUSH
17621: LD_INT 2100
17623: GREATER
17624: OR
17625: IFFALSE 17584
// activeAttacks := true ;
17627: LD_ADDR_EXP 16
17631: PUSH
17632: LD_INT 1
17634: ST_TO_ADDR
// end ;
17635: LD_VAR 0 1
17639: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17640: LD_INT 0
17642: PPUSH
// case question of 1 :
17643: LD_VAR 0 1
17647: PUSH
17648: LD_INT 1
17650: DOUBLE
17651: EQUAL
17652: IFTRUE 17656
17654: GO 17707
17656: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17657: LD_EXP 39
17661: PPUSH
17662: LD_STRING D2Mot-JMM-1
17664: PPUSH
17665: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17669: LD_EXP 58
17673: PPUSH
17674: LD_STRING D2Mot-Pow-1
17676: PPUSH
17677: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17681: LD_EXP 39
17685: PPUSH
17686: LD_STRING D2Mot-JMM-2
17688: PPUSH
17689: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17693: LD_EXP 58
17697: PPUSH
17698: LD_STRING D2Mot-Pow-2
17700: PPUSH
17701: CALL_OW 88
// end ; 2 :
17705: GO 18058
17707: LD_INT 2
17709: DOUBLE
17710: EQUAL
17711: IFTRUE 17715
17713: GO 17791
17715: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17716: LD_EXP 39
17720: PPUSH
17721: LD_STRING D2Rus-JMM-1
17723: PPUSH
17724: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17728: LD_EXP 58
17732: PPUSH
17733: LD_STRING D2Rus-Pow-1
17735: PPUSH
17736: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17740: LD_EXP 39
17744: PPUSH
17745: LD_STRING D2Rus-JMM-2
17747: PPUSH
17748: CALL_OW 88
// if not ( 3 in list_of_q ) then
17752: LD_INT 3
17754: PUSH
17755: LD_VAR 0 2
17759: IN
17760: NOT
17761: IFFALSE 17777
// Say ( Powell , D2Rus-Pow-2 ) else
17763: LD_EXP 58
17767: PPUSH
17768: LD_STRING D2Rus-Pow-2
17770: PPUSH
17771: CALL_OW 88
17775: GO 17789
// Say ( Powell , D2Rus-Pow-2a ) ;
17777: LD_EXP 58
17781: PPUSH
17782: LD_STRING D2Rus-Pow-2a
17784: PPUSH
17785: CALL_OW 88
// end ; 3 :
17789: GO 18058
17791: LD_INT 3
17793: DOUBLE
17794: EQUAL
17795: IFTRUE 17799
17797: GO 17884
17799: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17800: LD_EXP 39
17804: PPUSH
17805: LD_STRING D2Leg-JMM-1
17807: PPUSH
17808: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17812: LD_EXP 58
17816: PPUSH
17817: LD_STRING D2Leg-Pow-1
17819: PPUSH
17820: CALL_OW 88
// if 2 in list_of_q then
17824: LD_INT 2
17826: PUSH
17827: LD_VAR 0 2
17831: IN
17832: IFFALSE 17858
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17834: LD_EXP 39
17838: PPUSH
17839: LD_STRING D2Leg-JMM-2
17841: PPUSH
17842: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17846: LD_EXP 58
17850: PPUSH
17851: LD_STRING D2Leg-Pow-2
17853: PPUSH
17854: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17858: LD_EXP 39
17862: PPUSH
17863: LD_STRING D2Leg-JMM-3
17865: PPUSH
17866: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17870: LD_EXP 58
17874: PPUSH
17875: LD_STRING D2Leg-Pow-3
17877: PPUSH
17878: CALL_OW 88
// end ; 4 :
17882: GO 18058
17884: LD_INT 4
17886: DOUBLE
17887: EQUAL
17888: IFTRUE 17892
17890: GO 17967
17892: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17893: LD_EXP 39
17897: PPUSH
17898: LD_STRING D2Ar-JMM-1
17900: PPUSH
17901: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17905: LD_EXP 58
17909: PPUSH
17910: LD_STRING D2Ar-Pow-1
17912: PPUSH
17913: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17917: LD_EXP 39
17921: PPUSH
17922: LD_STRING D2Ar-JMM-2
17924: PPUSH
17925: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17929: LD_EXP 58
17933: PPUSH
17934: LD_STRING D2Ar-Pow-2
17936: PPUSH
17937: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17941: LD_EXP 39
17945: PPUSH
17946: LD_STRING D2Ar-JMM-3
17948: PPUSH
17949: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17953: LD_EXP 58
17957: PPUSH
17958: LD_STRING D2Ar-Pow-3
17960: PPUSH
17961: CALL_OW 88
// end ; 5 :
17965: GO 18058
17967: LD_INT 5
17969: DOUBLE
17970: EQUAL
17971: IFTRUE 17975
17973: GO 17990
17975: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17976: LD_EXP 39
17980: PPUSH
17981: LD_STRING D2Conf-JMM-1
17983: PPUSH
17984: CALL_OW 88
17988: GO 18058
17990: LD_INT 6
17992: DOUBLE
17993: EQUAL
17994: IFTRUE 17998
17996: GO 18057
17998: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17999: LD_EXP 39
18003: PPUSH
18004: LD_STRING D2Com-JMM-1
18006: PPUSH
18007: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18011: LD_EXP 58
18015: PPUSH
18016: LD_STRING D2Com-Pow-1
18018: PPUSH
18019: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18023: LD_EXP 39
18027: PPUSH
18028: LD_STRING D2Com-JMM-2
18030: PPUSH
18031: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18035: LD_EXP 58
18039: PPUSH
18040: LD_STRING D2Com-Pow-2
18042: PPUSH
18043: CALL_OW 88
// powellAngerQuery := true ;
18047: LD_ADDR_EXP 36
18051: PUSH
18052: LD_INT 1
18054: ST_TO_ADDR
// end ; end ;
18055: GO 18058
18057: POP
// end ;
18058: LD_VAR 0 3
18062: RET
// every 0 0$5 trigger missionStart do var tmp ;
18063: LD_EXP 13
18067: IFFALSE 18350
18069: GO 18071
18071: DISABLE
18072: LD_INT 0
18074: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18075: LD_INT 35
18077: PPUSH
18078: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18082: LD_INT 14
18084: PPUSH
18085: LD_INT 22
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 70
18099: PUSH
18100: LD_EXP 15
18104: PUSH
18105: LD_INT 2
18107: PUSH
18108: LD_INT 3
18110: PUSH
18111: LD_INT 4
18113: PUSH
18114: LD_INT 5
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: IN
18123: AND
18124: IFFALSE 18340
// begin powellAnger := powellAnger + 1 ;
18126: LD_ADDR_EXP 17
18130: PUSH
18131: LD_EXP 17
18135: PUSH
18136: LD_INT 1
18138: PLUS
18139: ST_TO_ADDR
// Video ( true ) ;
18140: LD_INT 1
18142: PPUSH
18143: CALL 107576 0 1
// CenterNowOnUnits ( tmp ) ;
18147: LD_VAR 0 1
18151: PPUSH
18152: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18156: LD_INT 14
18158: PPUSH
18159: LD_INT 22
18161: PUSH
18162: LD_INT 1
18164: PUSH
18165: EMPTY
18166: LIST
18167: LIST
18168: PPUSH
18169: CALL_OW 70
18173: PPUSH
18174: LD_INT 86
18176: PPUSH
18177: LD_INT 133
18179: PPUSH
18180: CALL_OW 111
// async ;
18184: ASYNC
// case powellAnger of 1 :
18185: LD_EXP 17
18189: PUSH
18190: LD_INT 1
18192: DOUBLE
18193: EQUAL
18194: IFTRUE 18198
18196: GO 18213
18198: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18199: LD_EXP 58
18203: PPUSH
18204: LD_STRING DBack1-Pow-1
18206: PPUSH
18207: CALL_OW 88
18211: GO 18260
18213: LD_INT 2
18215: DOUBLE
18216: EQUAL
18217: IFTRUE 18221
18219: GO 18236
18221: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18222: LD_EXP 58
18226: PPUSH
18227: LD_STRING DBack2-Pow-1
18229: PPUSH
18230: CALL_OW 88
18234: GO 18260
18236: LD_INT 3
18238: DOUBLE
18239: EQUAL
18240: IFTRUE 18244
18242: GO 18259
18244: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18245: LD_EXP 58
18249: PPUSH
18250: LD_STRING DBack3-Pow-1
18252: PPUSH
18253: CALL_OW 88
18257: GO 18260
18259: POP
// sync ;
18260: SYNC
// repeat wait ( 0 0$1 ) ;
18261: LD_INT 35
18263: PPUSH
18264: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18268: LD_INT 14
18270: PPUSH
18271: LD_INT 22
18273: PUSH
18274: LD_INT 1
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 70
18285: PPUSH
18286: LD_INT 86
18288: PPUSH
18289: LD_INT 133
18291: PPUSH
18292: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18296: LD_INT 14
18298: PPUSH
18299: LD_INT 22
18301: PUSH
18302: LD_INT 1
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PPUSH
18309: CALL_OW 70
18313: NOT
18314: IFFALSE 18261
// if powellAnger >= 3 then
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 3
18323: GREATEREQUAL
18324: IFFALSE 18333
// YouLost ( Dismissed ) ;
18326: LD_STRING Dismissed
18328: PPUSH
18329: CALL_OW 104
// Video ( false ) ;
18333: LD_INT 0
18335: PPUSH
18336: CALL 107576 0 1
// end ; until missionStage > 5 ;
18340: LD_EXP 15
18344: PUSH
18345: LD_INT 5
18347: GREATER
18348: IFFALSE 18075
// end ;
18350: PPOPN 1
18352: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18353: LD_EXP 13
18357: PUSH
18358: LD_INT 22
18360: PUSH
18361: LD_INT 4
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: PUSH
18368: LD_INT 21
18370: PUSH
18371: LD_INT 2
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: PPUSH
18382: CALL_OW 69
18386: PUSH
18387: LD_INT 4
18389: GREATEREQUAL
18390: AND
18391: PUSH
18392: LD_EXP 15
18396: PUSH
18397: LD_INT 2
18399: EQUAL
18400: AND
18401: IFFALSE 20224
18403: GO 18405
18405: DISABLE
18406: LD_INT 0
18408: PPUSH
18409: PPUSH
18410: PPUSH
18411: PPUSH
18412: PPUSH
18413: PPUSH
18414: PPUSH
18415: PPUSH
// begin missionStage := 3 ;
18416: LD_ADDR_EXP 15
18420: PUSH
18421: LD_INT 3
18423: ST_TO_ADDR
// retreat := false ;
18424: LD_ADDR_VAR 0 4
18428: PUSH
18429: LD_INT 0
18431: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18432: LD_ADDR_VAR 0 5
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 30
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: PPUSH
18461: CALL_OW 69
18465: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18466: LD_ADDR_VAR 0 6
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_INT 4
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: PUSH
18481: LD_INT 30
18483: PUSH
18484: LD_INT 5
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PPUSH
18495: CALL_OW 69
18499: ST_TO_ADDR
// if not bar then
18500: LD_VAR 0 6
18504: NOT
18505: IFFALSE 18558
// begin repeat wait ( 0 0$1 ) ;
18507: LD_INT 35
18509: PPUSH
18510: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 3
18526: PUSH
18527: LD_INT 57
18529: PUSH
18530: EMPTY
18531: LIST
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: PUSH
18537: LD_INT 30
18539: PUSH
18540: LD_INT 5
18542: PUSH
18543: EMPTY
18544: LIST
18545: LIST
18546: PUSH
18547: EMPTY
18548: LIST
18549: LIST
18550: LIST
18551: PPUSH
18552: CALL_OW 69
18556: IFFALSE 18507
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18558: LD_ADDR_VAR 0 6
18562: PUSH
18563: LD_INT 22
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: LD_INT 30
18575: PUSH
18576: LD_INT 5
18578: PUSH
18579: EMPTY
18580: LIST
18581: LIST
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: PPUSH
18587: CALL_OW 69
18591: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18592: LD_INT 35
18594: PPUSH
18595: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18599: LD_EXP 121
18603: PUSH
18604: LD_INT 4
18606: ARRAY
18607: PUSH
18608: LD_INT 4
18610: GREATEREQUAL
18611: IFFALSE 18592
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18613: LD_ADDR_VAR 0 2
18617: PUSH
18618: LD_INT 22
18620: PUSH
18621: LD_INT 4
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 25
18633: PUSH
18634: LD_INT 1
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 25
18643: PUSH
18644: LD_INT 2
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: LD_INT 25
18653: PUSH
18654: LD_INT 3
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: PUSH
18661: LD_INT 25
18663: PUSH
18664: LD_INT 4
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PUSH
18671: LD_INT 25
18673: PUSH
18674: LD_INT 5
18676: PUSH
18677: EMPTY
18678: LIST
18679: LIST
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PPUSH
18693: CALL_OW 69
18697: PUSH
18698: LD_EXP 58
18702: PUSH
18703: LD_EXP 59
18707: ADD
18708: DIFF
18709: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18710: LD_ADDR_VAR 0 3
18714: PUSH
18715: LD_VAR 0 2
18719: PPUSH
18720: LD_INT 26
18722: PUSH
18723: LD_INT 1
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: PPUSH
18730: CALL_OW 72
18734: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18735: LD_ADDR_VAR 0 2
18739: PUSH
18740: LD_VAR 0 2
18744: PUSH
18745: LD_VAR 0 3
18749: DIFF
18750: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PPUSH
18761: LD_INT 1
18763: PPUSH
18764: CALL 106229 0 2
18768: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18769: LD_ADDR_VAR 0 3
18773: PUSH
18774: LD_VAR 0 3
18778: PPUSH
18779: LD_INT 1
18781: PPUSH
18782: CALL 106229 0 2
18786: ST_TO_ADDR
// for i = 1 to 4 do
18787: LD_ADDR_VAR 0 1
18791: PUSH
18792: DOUBLE
18793: LD_INT 1
18795: DEC
18796: ST_TO_ADDR
18797: LD_INT 4
18799: PUSH
18800: FOR_TO
18801: IFFALSE 18967
// begin if tmp2 then
18803: LD_VAR 0 3
18807: IFFALSE 18888
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18809: LD_ADDR_EXP 18
18813: PUSH
18814: LD_EXP 18
18818: PPUSH
18819: LD_INT 1
18821: PPUSH
18822: LD_EXP 18
18826: PUSH
18827: LD_INT 1
18829: ARRAY
18830: PUSH
18831: LD_VAR 0 3
18835: PUSH
18836: LD_VAR 0 3
18840: ARRAY
18841: ADD
18842: PPUSH
18843: CALL_OW 1
18847: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18848: LD_VAR 0 3
18852: PUSH
18853: LD_VAR 0 3
18857: ARRAY
18858: PPUSH
18859: LD_INT 1
18861: PPUSH
18862: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 3
18875: PPUSH
18876: LD_VAR 0 3
18880: PPUSH
18881: CALL_OW 3
18885: ST_TO_ADDR
// end else
18886: GO 18965
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18888: LD_ADDR_EXP 18
18892: PUSH
18893: LD_EXP 18
18897: PPUSH
18898: LD_INT 1
18900: PPUSH
18901: LD_EXP 18
18905: PUSH
18906: LD_INT 1
18908: ARRAY
18909: PUSH
18910: LD_VAR 0 2
18914: PUSH
18915: LD_VAR 0 2
18919: ARRAY
18920: ADD
18921: PPUSH
18922: CALL_OW 1
18926: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18927: LD_VAR 0 2
18931: PUSH
18932: LD_VAR 0 2
18936: ARRAY
18937: PPUSH
18938: LD_INT 1
18940: PPUSH
18941: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18945: LD_ADDR_VAR 0 2
18949: PUSH
18950: LD_VAR 0 2
18954: PPUSH
18955: LD_VAR 0 2
18959: PPUSH
18960: CALL_OW 3
18964: ST_TO_ADDR
// end ; end ;
18965: GO 18800
18967: POP
18968: POP
// if tmp2 then
18969: LD_VAR 0 3
18973: IFFALSE 18991
// tmp := tmp union tmp2 ;
18975: LD_ADDR_VAR 0 2
18979: PUSH
18980: LD_VAR 0 2
18984: PUSH
18985: LD_VAR 0 3
18989: UNION
18990: ST_TO_ADDR
// for i = 1 to 4 do
18991: LD_ADDR_VAR 0 1
18995: PUSH
18996: DOUBLE
18997: LD_INT 1
18999: DEC
19000: ST_TO_ADDR
19001: LD_INT 4
19003: PUSH
19004: FOR_TO
19005: IFFALSE 19054
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19007: LD_ADDR_EXP 18
19011: PUSH
19012: LD_EXP 18
19016: PPUSH
19017: LD_INT 2
19019: PPUSH
19020: LD_EXP 18
19024: PUSH
19025: LD_INT 2
19027: ARRAY
19028: PUSH
19029: LD_VAR 0 2
19033: PUSH
19034: LD_VAR 0 2
19038: PUSH
19039: LD_VAR 0 1
19043: MINUS
19044: ARRAY
19045: ADD
19046: PPUSH
19047: CALL_OW 1
19051: ST_TO_ADDR
19052: GO 19004
19054: POP
19055: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19056: LD_ADDR_EXP 102
19060: PUSH
19061: LD_EXP 102
19065: PPUSH
19066: LD_INT 4
19068: PPUSH
19069: LD_EXP 102
19073: PUSH
19074: LD_INT 4
19076: ARRAY
19077: PUSH
19078: LD_EXP 18
19082: PUSH
19083: LD_INT 1
19085: ARRAY
19086: DIFF
19087: PPUSH
19088: CALL_OW 1
19092: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19093: LD_VAR 0 5
19097: PUSH
19098: LD_INT 1
19100: ARRAY
19101: PPUSH
19102: CALL_OW 313
19106: IFFALSE 19161
// begin for i in UnitsInside ( arm [ 1 ] ) do
19108: LD_ADDR_VAR 0 1
19112: PUSH
19113: LD_VAR 0 5
19117: PUSH
19118: LD_INT 1
19120: ARRAY
19121: PPUSH
19122: CALL_OW 313
19126: PUSH
19127: FOR_IN
19128: IFFALSE 19159
// begin ComExitBuilding ( i ) ;
19130: LD_VAR 0 1
19134: PPUSH
19135: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19139: LD_VAR 0 1
19143: PPUSH
19144: LD_VAR 0 6
19148: PUSH
19149: LD_INT 1
19151: ARRAY
19152: PPUSH
19153: CALL_OW 180
// end ;
19157: GO 19127
19159: POP
19160: POP
// end ; wait ( 0 0$3 ) ;
19161: LD_INT 105
19163: PPUSH
19164: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19168: LD_ADDR_VAR 0 1
19172: PUSH
19173: LD_EXP 18
19177: PUSH
19178: LD_INT 1
19180: ARRAY
19181: PUSH
19182: FOR_IN
19183: IFFALSE 19290
// begin if IsInUnit ( i ) then
19185: LD_VAR 0 1
19189: PPUSH
19190: CALL_OW 310
19194: IFFALSE 19205
// ComExitBuilding ( i ) ;
19196: LD_VAR 0 1
19200: PPUSH
19201: CALL_OW 122
// if GetClass ( i ) <> 1 then
19205: LD_VAR 0 1
19209: PPUSH
19210: CALL_OW 257
19214: PUSH
19215: LD_INT 1
19217: NONEQUAL
19218: IFFALSE 19259
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19220: LD_VAR 0 1
19224: PPUSH
19225: LD_VAR 0 5
19229: PUSH
19230: LD_INT 1
19232: ARRAY
19233: PPUSH
19234: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19238: LD_VAR 0 1
19242: PPUSH
19243: LD_INT 1
19245: PPUSH
19246: CALL_OW 183
// AddComExitBuilding ( i ) ;
19250: LD_VAR 0 1
19254: PPUSH
19255: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19259: LD_VAR 0 1
19263: PPUSH
19264: LD_INT 60
19266: PPUSH
19267: LD_INT 94
19269: PPUSH
19270: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19274: LD_VAR 0 1
19278: PPUSH
19279: LD_EXP 58
19283: PPUSH
19284: CALL_OW 179
// end ;
19288: GO 19182
19290: POP
19291: POP
// wait ( 0 0$15 ) ;
19292: LD_INT 525
19294: PPUSH
19295: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19299: LD_EXP 58
19303: PPUSH
19304: LD_STRING D4-Pow-1
19306: PPUSH
19307: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19311: LD_ADDR_VAR 0 2
19315: PUSH
19316: LD_EXP 18
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: PPUSH
19325: LD_INT 26
19327: PUSH
19328: LD_INT 1
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: PPUSH
19335: CALL_OW 72
19339: ST_TO_ADDR
// if tmp then
19340: LD_VAR 0 2
19344: IFFALSE 19362
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19346: LD_VAR 0 2
19350: PUSH
19351: LD_INT 1
19353: ARRAY
19354: PPUSH
19355: LD_STRING D4-Sol1-1
19357: PPUSH
19358: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19362: LD_EXP 58
19366: PPUSH
19367: LD_STRING D4-Pow-2
19369: PPUSH
19370: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19374: LD_ADDR_VAR 0 1
19378: PUSH
19379: DOUBLE
19380: LD_INT 1
19382: DEC
19383: ST_TO_ADDR
19384: LD_EXP 18
19388: PUSH
19389: LD_INT 1
19391: ARRAY
19392: PUSH
19393: FOR_TO
19394: IFFALSE 19487
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19396: LD_EXP 18
19400: PUSH
19401: LD_INT 1
19403: ARRAY
19404: PUSH
19405: LD_VAR 0 1
19409: ARRAY
19410: PPUSH
19411: LD_EXP 121
19415: PUSH
19416: LD_INT 4
19418: ARRAY
19419: PUSH
19420: LD_INT 1
19422: ARRAY
19423: PPUSH
19424: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19428: LD_ADDR_EXP 121
19432: PUSH
19433: LD_EXP 121
19437: PPUSH
19438: LD_INT 4
19440: PPUSH
19441: LD_EXP 121
19445: PUSH
19446: LD_INT 4
19448: ARRAY
19449: PPUSH
19450: LD_INT 1
19452: PPUSH
19453: CALL_OW 3
19457: PPUSH
19458: CALL_OW 1
19462: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19463: LD_INT 8
19465: PPUSH
19466: LD_EXP 18
19470: PUSH
19471: LD_INT 1
19473: ARRAY
19474: PUSH
19475: LD_VAR 0 1
19479: ARRAY
19480: PPUSH
19481: CALL_OW 471
// end ;
19485: GO 19393
19487: POP
19488: POP
// repeat wait ( 0 0$1 ) ;
19489: LD_INT 35
19491: PPUSH
19492: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19496: LD_EXP 18
19500: PUSH
19501: LD_INT 1
19503: ARRAY
19504: PPUSH
19505: LD_INT 55
19507: PUSH
19508: EMPTY
19509: LIST
19510: PPUSH
19511: CALL_OW 72
19515: PUSH
19516: LD_INT 4
19518: GREATEREQUAL
19519: IFFALSE 19489
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19521: LD_EXP 18
19525: PUSH
19526: LD_INT 1
19528: ARRAY
19529: PPUSH
19530: LD_INT 69
19532: PPUSH
19533: LD_INT 94
19535: PPUSH
19536: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PPUSH
19549: LD_INT 82
19551: PPUSH
19552: LD_INT 83
19554: PPUSH
19555: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19559: LD_EXP 18
19563: PUSH
19564: LD_INT 1
19566: ARRAY
19567: PPUSH
19568: LD_INT 77
19570: PPUSH
19571: LD_INT 69
19573: PPUSH
19574: CALL_OW 174
// repeat wait ( 3 ) ;
19578: LD_INT 3
19580: PPUSH
19581: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19585: LD_ADDR_VAR 0 1
19589: PUSH
19590: LD_EXP 18
19594: PUSH
19595: LD_INT 1
19597: ARRAY
19598: PUSH
19599: FOR_IN
19600: IFFALSE 19736
// begin if GetLives ( i ) < 990 then
19602: LD_VAR 0 1
19606: PPUSH
19607: CALL_OW 256
19611: PUSH
19612: LD_INT 990
19614: LESS
19615: IFFALSE 19629
// SetLives ( i , 1000 ) ;
19617: LD_VAR 0 1
19621: PPUSH
19622: LD_INT 1000
19624: PPUSH
19625: CALL_OW 234
// if not IsInUnit ( i ) then
19629: LD_VAR 0 1
19633: PPUSH
19634: CALL_OW 310
19638: NOT
19639: IFFALSE 19734
// begin if not HasTask ( i ) then
19641: LD_VAR 0 1
19645: PPUSH
19646: CALL_OW 314
19650: NOT
19651: IFFALSE 19668
// ComMoveXY ( i , 64 , 93 ) ;
19653: LD_VAR 0 1
19657: PPUSH
19658: LD_INT 64
19660: PPUSH
19661: LD_INT 93
19663: PPUSH
19664: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19668: LD_VAR 0 4
19672: NOT
19673: PUSH
19674: LD_VAR 0 1
19678: PPUSH
19679: CALL_OW 258
19683: PUSH
19684: LD_INT 1
19686: EQUAL
19687: AND
19688: IFFALSE 19734
// begin retreat := true ;
19690: LD_ADDR_VAR 0 4
19694: PUSH
19695: LD_INT 1
19697: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19698: LD_VAR 0 1
19702: PPUSH
19703: LD_INT 2
19705: PPUSH
19706: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19710: LD_VAR 0 1
19714: PPUSH
19715: LD_STRING D4a-Sol1-1
19717: PPUSH
19718: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19722: LD_EXP 58
19726: PPUSH
19727: LD_STRING D4a-Pow-1
19729: PPUSH
19730: CALL_OW 88
// end ; end ; end ;
19734: GO 19599
19736: POP
19737: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19738: LD_EXP 18
19742: PUSH
19743: LD_INT 1
19745: ARRAY
19746: PPUSH
19747: LD_INT 95
19749: PUSH
19750: LD_INT 9
19752: PUSH
19753: EMPTY
19754: LIST
19755: LIST
19756: PUSH
19757: LD_INT 3
19759: PUSH
19760: LD_INT 55
19762: PUSH
19763: EMPTY
19764: LIST
19765: PUSH
19766: EMPTY
19767: LIST
19768: LIST
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: PPUSH
19774: CALL_OW 72
19778: PUSH
19779: LD_INT 4
19781: GREATEREQUAL
19782: IFFALSE 19578
// for i in powellSquadAttack [ 1 ] do
19784: LD_ADDR_VAR 0 1
19788: PUSH
19789: LD_EXP 18
19793: PUSH
19794: LD_INT 1
19796: ARRAY
19797: PUSH
19798: FOR_IN
19799: IFFALSE 19935
// begin if GetTag ( i ) = 2 then
19801: LD_VAR 0 1
19805: PPUSH
19806: CALL_OW 110
19810: PUSH
19811: LD_INT 2
19813: EQUAL
19814: IFFALSE 19876
// begin ComMoveXY ( i , 60 , 94 ) ;
19816: LD_VAR 0 1
19820: PPUSH
19821: LD_INT 60
19823: PPUSH
19824: LD_INT 94
19826: PPUSH
19827: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19831: LD_VAR 0 1
19835: PPUSH
19836: LD_EXP 58
19840: PPUSH
19841: CALL_OW 179
// wait ( 0 0$3 ) ;
19845: LD_INT 105
19847: PPUSH
19848: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19852: LD_VAR 0 1
19856: PPUSH
19857: LD_STRING D4a-Sol1-2
19859: PPUSH
19860: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19864: LD_EXP 58
19868: PPUSH
19869: LD_STRING D4a-Pow-2
19871: PPUSH
19872: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19876: LD_VAR 0 1
19880: PPUSH
19881: LD_INT 0
19883: PPUSH
19884: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19888: LD_ADDR_EXP 102
19892: PUSH
19893: LD_EXP 102
19897: PPUSH
19898: LD_INT 4
19900: PPUSH
19901: LD_EXP 102
19905: PUSH
19906: LD_INT 4
19908: ARRAY
19909: PUSH
19910: LD_VAR 0 1
19914: UNION
19915: PPUSH
19916: CALL_OW 1
19920: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19921: LD_INT 8
19923: PPUSH
19924: LD_VAR 0 1
19928: PPUSH
19929: CALL_OW 472
// end ;
19933: GO 19798
19935: POP
19936: POP
// wait ( 4 4$00 ) ;
19937: LD_INT 8400
19939: PPUSH
19940: CALL_OW 67
// uc_side := 6 ;
19944: LD_ADDR_OWVAR 20
19948: PUSH
19949: LD_INT 6
19951: ST_TO_ADDR
// uc_nation := 3 ;
19952: LD_ADDR_OWVAR 21
19956: PUSH
19957: LD_INT 3
19959: ST_TO_ADDR
// ru := [ ] ;
19960: LD_ADDR_VAR 0 7
19964: PUSH
19965: EMPTY
19966: ST_TO_ADDR
// for i = 1 to 4 do
19967: LD_ADDR_VAR 0 1
19971: PUSH
19972: DOUBLE
19973: LD_INT 1
19975: DEC
19976: ST_TO_ADDR
19977: LD_INT 4
19979: PUSH
19980: FOR_TO
19981: IFFALSE 20082
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19983: LD_INT 22
19985: PPUSH
19986: LD_INT 1
19988: PPUSH
19989: LD_INT 3
19991: PPUSH
19992: LD_INT 43
19994: PUSH
19995: LD_INT 44
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: PUSH
20002: LD_INT 1
20004: PPUSH
20005: LD_INT 2
20007: PPUSH
20008: CALL_OW 12
20012: ARRAY
20013: PPUSH
20014: LD_INT 89
20016: PPUSH
20017: CALL 71856 0 5
// un := CreateVehicle ;
20021: LD_ADDR_VAR 0 8
20025: PUSH
20026: CALL_OW 45
20030: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20031: LD_VAR 0 8
20035: PPUSH
20036: LD_INT 4
20038: PPUSH
20039: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20043: LD_VAR 0 8
20047: PPUSH
20048: LD_INT 136
20050: PPUSH
20051: LD_INT 90
20053: PPUSH
20054: LD_INT 8
20056: PPUSH
20057: LD_INT 0
20059: PPUSH
20060: CALL_OW 50
// ru := ru ^ un ;
20064: LD_ADDR_VAR 0 7
20068: PUSH
20069: LD_VAR 0 7
20073: PUSH
20074: LD_VAR 0 8
20078: ADD
20079: ST_TO_ADDR
// end ;
20080: GO 19980
20082: POP
20083: POP
// if ru then
20084: LD_VAR 0 7
20088: IFFALSE 20105
// ComAgressiveMove ( ru , 80 , 92 ) ;
20090: LD_VAR 0 7
20094: PPUSH
20095: LD_INT 80
20097: PPUSH
20098: LD_INT 92
20100: PPUSH
20101: CALL_OW 114
// wait ( 8 8$00 ) ;
20105: LD_INT 16800
20107: PPUSH
20108: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20112: LD_INT 4
20114: PPUSH
20115: LD_INT 3
20117: PUSH
20118: LD_INT 1
20120: PUSH
20121: LD_INT 1
20123: PUSH
20124: LD_INT 5
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 4
20135: PUSH
20136: LD_INT 1
20138: PUSH
20139: LD_INT 1
20141: PUSH
20142: LD_INT 6
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: LIST
20149: LIST
20150: PUSH
20151: LD_INT 4
20153: PUSH
20154: LD_INT 1
20156: PUSH
20157: LD_INT 1
20159: PUSH
20160: LD_INT 7
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: LIST
20168: PUSH
20169: LD_INT 3
20171: PUSH
20172: LD_INT 1
20174: PUSH
20175: LD_INT 1
20177: PUSH
20178: LD_INT 7
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: LIST
20185: LIST
20186: PUSH
20187: LD_INT 3
20189: PUSH
20190: LD_INT 1
20192: PUSH
20193: LD_INT 1
20195: PUSH
20196: LD_INT 5
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: PPUSH
20212: CALL 58349 0 2
// missionStage := 4 ;
20216: LD_ADDR_EXP 15
20220: PUSH
20221: LD_INT 4
20223: ST_TO_ADDR
// end ;
20224: PPOPN 8
20226: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20227: LD_EXP 15
20231: PUSH
20232: LD_INT 4
20234: EQUAL
20235: PUSH
20236: LD_INT 22
20238: PUSH
20239: LD_INT 4
20241: PUSH
20242: EMPTY
20243: LIST
20244: LIST
20245: PUSH
20246: LD_INT 21
20248: PUSH
20249: LD_INT 2
20251: PUSH
20252: EMPTY
20253: LIST
20254: LIST
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PPUSH
20260: CALL_OW 69
20264: PUSH
20265: LD_INT 5
20267: GREATEREQUAL
20268: AND
20269: IFFALSE 24374
20271: GO 20273
20273: DISABLE
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
20278: PPUSH
20279: PPUSH
20280: PPUSH
20281: PPUSH
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
// begin missionStage := 5 ;
20289: LD_ADDR_EXP 15
20293: PUSH
20294: LD_INT 5
20296: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20297: LD_ADDR_VAR 0 10
20301: PUSH
20302: LD_INT 22
20304: PUSH
20305: LD_INT 4
20307: PUSH
20308: EMPTY
20309: LIST
20310: LIST
20311: PUSH
20312: LD_INT 2
20314: PUSH
20315: LD_INT 30
20317: PUSH
20318: LD_INT 4
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 30
20327: PUSH
20328: LD_INT 5
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PUSH
20335: EMPTY
20336: LIST
20337: LIST
20338: LIST
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: PPUSH
20344: CALL_OW 69
20348: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20349: LD_ADDR_VAR 0 6
20353: PUSH
20354: LD_INT 22
20356: PUSH
20357: LD_INT 4
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: LD_INT 21
20366: PUSH
20367: LD_INT 1
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: PUSH
20374: LD_INT 3
20376: PUSH
20377: LD_INT 25
20379: PUSH
20380: LD_INT 16
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PUSH
20391: LD_INT 3
20393: PUSH
20394: LD_INT 25
20396: PUSH
20397: LD_INT 12
20399: PUSH
20400: EMPTY
20401: LIST
20402: LIST
20403: PUSH
20404: EMPTY
20405: LIST
20406: LIST
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: LIST
20412: LIST
20413: PPUSH
20414: CALL_OW 69
20418: PUSH
20419: LD_EXP 58
20423: DIFF
20424: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 22
20432: PUSH
20433: LD_INT 4
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 30
20442: PUSH
20443: LD_INT 3
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: PUSH
20450: EMPTY
20451: LIST
20452: LIST
20453: PPUSH
20454: CALL_OW 69
20458: PUSH
20459: LD_INT 1
20461: ARRAY
20462: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20463: LD_INT 35
20465: PPUSH
20466: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20470: LD_EXP 121
20474: PUSH
20475: LD_INT 4
20477: ARRAY
20478: PUSH
20479: LD_INT 5
20481: GREATEREQUAL
20482: PUSH
20483: LD_EXP 121
20487: PUSH
20488: LD_INT 4
20490: ARRAY
20491: PPUSH
20492: LD_INT 58
20494: PUSH
20495: EMPTY
20496: LIST
20497: PPUSH
20498: CALL_OW 72
20502: PUSH
20503: LD_INT 5
20505: GREATEREQUAL
20506: AND
20507: IFFALSE 20463
// powellAllowRetreat := false ;
20509: LD_ADDR_EXP 19
20513: PUSH
20514: LD_INT 0
20516: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20517: LD_INT 700
20519: PPUSH
20520: CALL_OW 67
// activeAttacks := false ;
20524: LD_ADDR_EXP 16
20528: PUSH
20529: LD_INT 0
20531: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20532: LD_INT 35
20534: PPUSH
20535: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20539: LD_INT 22
20541: PUSH
20542: LD_INT 6
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PPUSH
20549: CALL_OW 69
20553: PUSH
20554: LD_INT 0
20556: EQUAL
20557: IFFALSE 20532
// tmp := mc_vehicles [ 4 ] ;
20559: LD_ADDR_VAR 0 3
20563: PUSH
20564: LD_EXP 121
20568: PUSH
20569: LD_INT 4
20571: ARRAY
20572: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20573: LD_ADDR_VAR 0 1
20577: PUSH
20578: DOUBLE
20579: LD_INT 1
20581: DEC
20582: ST_TO_ADDR
20583: LD_EXP 18
20587: PUSH
20588: FOR_TO
20589: IFFALSE 20850
// begin for j in powellSquadAttack [ i ] do
20591: LD_ADDR_VAR 0 2
20595: PUSH
20596: LD_EXP 18
20600: PUSH
20601: LD_VAR 0 1
20605: ARRAY
20606: PUSH
20607: FOR_IN
20608: IFFALSE 20846
// begin forces := forces diff j ;
20610: LD_ADDR_VAR 0 6
20614: PUSH
20615: LD_VAR 0 6
20619: PUSH
20620: LD_VAR 0 2
20624: DIFF
20625: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20626: LD_VAR 0 2
20630: PPUSH
20631: LD_INT 1
20633: PPUSH
20634: CALL_OW 109
// wait ( 0 0$2 ) ;
20638: LD_INT 70
20640: PPUSH
20641: CALL_OW 67
// if IsInUnit ( j ) then
20645: LD_VAR 0 2
20649: PPUSH
20650: CALL_OW 310
20654: IFFALSE 20665
// ComExitBuilding ( j ) ;
20656: LD_VAR 0 2
20660: PPUSH
20661: CALL_OW 122
// if GetClass ( j ) <> 1 then
20665: LD_VAR 0 2
20669: PPUSH
20670: CALL_OW 257
20674: PUSH
20675: LD_INT 1
20677: NONEQUAL
20678: IFFALSE 20758
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20680: LD_VAR 0 10
20684: PUSH
20685: LD_INT 1
20687: ARRAY
20688: PPUSH
20689: CALL_OW 313
20693: PUSH
20694: LD_INT 5
20696: GREATEREQUAL
20697: IFFALSE 20719
// AddComEnterUnit ( j , arm [ 2 ] ) else
20699: LD_VAR 0 2
20703: PPUSH
20704: LD_VAR 0 10
20708: PUSH
20709: LD_INT 2
20711: ARRAY
20712: PPUSH
20713: CALL_OW 180
20717: GO 20737
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20719: LD_VAR 0 2
20723: PPUSH
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20737: LD_VAR 0 2
20741: PPUSH
20742: LD_INT 1
20744: PPUSH
20745: CALL_OW 183
// AddComExitBuilding ( j ) ;
20749: LD_VAR 0 2
20753: PPUSH
20754: CALL_OW 182
// end ; if i = 2 then
20758: LD_VAR 0 1
20762: PUSH
20763: LD_INT 2
20765: EQUAL
20766: IFFALSE 20783
// AddComMoveXY ( j , 61 , 93 ) ;
20768: LD_VAR 0 2
20772: PPUSH
20773: LD_INT 61
20775: PPUSH
20776: LD_INT 93
20778: PPUSH
20779: CALL_OW 171
// if i = 1 then
20783: LD_VAR 0 1
20787: PUSH
20788: LD_INT 1
20790: EQUAL
20791: IFFALSE 20844
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20793: LD_VAR 0 2
20797: PPUSH
20798: LD_VAR 0 3
20802: PUSH
20803: LD_INT 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20811: LD_ADDR_VAR 0 3
20815: PUSH
20816: LD_VAR 0 3
20820: PPUSH
20821: LD_INT 1
20823: PPUSH
20824: CALL_OW 3
20828: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20829: LD_VAR 0 2
20833: PPUSH
20834: LD_INT 69
20836: PPUSH
20837: LD_INT 94
20839: PPUSH
20840: CALL_OW 171
// end ; end ;
20844: GO 20607
20846: POP
20847: POP
// end ;
20848: GO 20588
20850: POP
20851: POP
// wait ( 0 0$55 ) ;
20852: LD_INT 1925
20854: PPUSH
20855: CALL_OW 67
// MC_Kill ( 4 ) ;
20859: LD_INT 4
20861: PPUSH
20862: CALL 34937 0 1
// tmp := UnitsInside ( fac ) ;
20866: LD_ADDR_VAR 0 3
20870: PUSH
20871: LD_VAR 0 9
20875: PPUSH
20876: CALL_OW 313
20880: ST_TO_ADDR
// if tmp then
20881: LD_VAR 0 3
20885: IFFALSE 21006
// for i in tmp do
20887: LD_ADDR_VAR 0 1
20891: PUSH
20892: LD_VAR 0 3
20896: PUSH
20897: FOR_IN
20898: IFFALSE 21004
// begin ComExitBuilding ( i ) ;
20900: LD_VAR 0 1
20904: PPUSH
20905: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20909: LD_VAR 0 10
20913: PUSH
20914: LD_INT 2
20916: ARRAY
20917: PPUSH
20918: CALL_OW 313
20922: PUSH
20923: LD_INT 6
20925: LESS
20926: IFFALSE 20948
// AddComEnterUnit ( i , arm [ 2 ] ) else
20928: LD_VAR 0 1
20932: PPUSH
20933: LD_VAR 0 10
20937: PUSH
20938: LD_INT 2
20940: ARRAY
20941: PPUSH
20942: CALL_OW 180
20946: GO 21002
// if UnitsInside ( arm [ 1 ] ) < 6 then
20948: LD_VAR 0 10
20952: PUSH
20953: LD_INT 1
20955: ARRAY
20956: PPUSH
20957: CALL_OW 313
20961: PUSH
20962: LD_INT 6
20964: LESS
20965: IFFALSE 20987
// AddComEnterUnit ( i , arm [ 1 ] ) else
20967: LD_VAR 0 1
20971: PPUSH
20972: LD_VAR 0 10
20976: PUSH
20977: LD_INT 1
20979: ARRAY
20980: PPUSH
20981: CALL_OW 180
20985: GO 21002
// AddComMoveXY ( i , 37 , 68 ) ;
20987: LD_VAR 0 1
20991: PPUSH
20992: LD_INT 37
20994: PPUSH
20995: LD_INT 68
20997: PPUSH
20998: CALL_OW 171
// end ;
21002: GO 20897
21004: POP
21005: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21006: LD_ADDR_VAR 0 11
21010: PUSH
21011: LD_VAR 0 6
21015: PPUSH
21016: LD_INT 26
21018: PUSH
21019: LD_INT 1
21021: PUSH
21022: EMPTY
21023: LIST
21024: LIST
21025: PPUSH
21026: CALL_OW 72
21030: PUSH
21031: LD_EXP 59
21035: DIFF
21036: ST_TO_ADDR
// if not speaker then
21037: LD_VAR 0 11
21041: NOT
21042: IFFALSE 21069
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21044: LD_ADDR_VAR 0 11
21048: PUSH
21049: LD_VAR 0 6
21053: PPUSH
21054: LD_INT 26
21056: PUSH
21057: LD_INT 1
21059: PUSH
21060: EMPTY
21061: LIST
21062: LIST
21063: PPUSH
21064: CALL_OW 72
21068: ST_TO_ADDR
// if speaker then
21069: LD_VAR 0 11
21073: IFFALSE 21089
// speaker := speaker [ 1 ] ;
21075: LD_ADDR_VAR 0 11
21079: PUSH
21080: LD_VAR 0 11
21084: PUSH
21085: LD_INT 1
21087: ARRAY
21088: ST_TO_ADDR
// Video ( true ) ;
21089: LD_INT 1
21091: PPUSH
21092: CALL 107576 0 1
// CenterNowOnUnits ( Powell ) ;
21096: LD_EXP 58
21100: PPUSH
21101: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21105: LD_ADDR_VAR 0 3
21109: PUSH
21110: LD_VAR 0 6
21114: PPUSH
21115: LD_INT 3
21117: PUSH
21118: LD_INT 25
21120: PUSH
21121: LD_INT 1
21123: PUSH
21124: EMPTY
21125: LIST
21126: LIST
21127: PUSH
21128: EMPTY
21129: LIST
21130: LIST
21131: PPUSH
21132: CALL_OW 72
21136: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21137: LD_ADDR_VAR 0 12
21141: PUSH
21142: LD_INT 22
21144: PUSH
21145: LD_INT 4
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: PUSH
21152: LD_INT 30
21154: PUSH
21155: LD_INT 32
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: LD_INT 58
21164: PUSH
21165: EMPTY
21166: LIST
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL_OW 69
21177: ST_TO_ADDR
// for i = 1 to 6 do
21178: LD_ADDR_VAR 0 1
21182: PUSH
21183: DOUBLE
21184: LD_INT 1
21186: DEC
21187: ST_TO_ADDR
21188: LD_INT 6
21190: PUSH
21191: FOR_TO
21192: IFFALSE 21333
// begin if IsInUnit ( tmp [ i ] ) then
21194: LD_VAR 0 3
21198: PUSH
21199: LD_VAR 0 1
21203: ARRAY
21204: PPUSH
21205: CALL_OW 310
21209: IFFALSE 21226
// ComExitBuilding ( tmp [ i ] ) ;
21211: LD_VAR 0 3
21215: PUSH
21216: LD_VAR 0 1
21220: ARRAY
21221: PPUSH
21222: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21226: LD_VAR 0 3
21230: PUSH
21231: LD_VAR 0 1
21235: ARRAY
21236: PPUSH
21237: LD_VAR 0 10
21241: PUSH
21242: LD_INT 1
21244: ARRAY
21245: PPUSH
21246: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21250: LD_VAR 0 3
21254: PUSH
21255: LD_VAR 0 1
21259: ARRAY
21260: PPUSH
21261: LD_INT 1
21263: PPUSH
21264: CALL_OW 183
// if emp_towers then
21268: LD_VAR 0 12
21272: IFFALSE 21331
// begin AddComExitBuilding ( tmp [ i ] ) ;
21274: LD_VAR 0 3
21278: PUSH
21279: LD_VAR 0 1
21283: ARRAY
21284: PPUSH
21285: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21289: LD_VAR 0 3
21293: PUSH
21294: LD_VAR 0 1
21298: ARRAY
21299: PPUSH
21300: LD_VAR 0 12
21304: PUSH
21305: LD_INT 1
21307: ARRAY
21308: PPUSH
21309: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21313: LD_ADDR_VAR 0 12
21317: PUSH
21318: LD_VAR 0 12
21322: PPUSH
21323: LD_INT 1
21325: PPUSH
21326: CALL_OW 3
21330: ST_TO_ADDR
// end ; end ;
21331: GO 21191
21333: POP
21334: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21335: LD_ADDR_VAR 0 3
21339: PUSH
21340: LD_EXP 18
21344: PUSH
21345: LD_INT 1
21347: ARRAY
21348: PUSH
21349: LD_EXP 18
21353: PUSH
21354: LD_INT 2
21356: ARRAY
21357: ADD
21358: PPUSH
21359: LD_INT 26
21361: PUSH
21362: LD_INT 1
21364: PUSH
21365: EMPTY
21366: LIST
21367: LIST
21368: PPUSH
21369: CALL_OW 72
21373: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21374: LD_ADDR_VAR 0 1
21378: PUSH
21379: LD_EXP 18
21383: PUSH
21384: LD_INT 2
21386: ARRAY
21387: PUSH
21388: FOR_IN
21389: IFFALSE 21407
// ComTurnUnit ( i , Powell ) ;
21391: LD_VAR 0 1
21395: PPUSH
21396: LD_EXP 58
21400: PPUSH
21401: CALL_OW 119
21405: GO 21388
21407: POP
21408: POP
// Say ( Powell , D5-Pow-1 ) ;
21409: LD_EXP 58
21413: PPUSH
21414: LD_STRING D5-Pow-1
21416: PPUSH
21417: CALL_OW 88
// if tmp then
21421: LD_VAR 0 3
21425: IFFALSE 21443
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21427: LD_VAR 0 3
21431: PUSH
21432: LD_INT 1
21434: ARRAY
21435: PPUSH
21436: LD_STRING D5-Sol2-1
21438: PPUSH
21439: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21443: LD_EXP 58
21447: PPUSH
21448: LD_STRING D5-Pow-2
21450: PPUSH
21451: CALL_OW 88
// if tmp > 1 then
21455: LD_VAR 0 3
21459: PUSH
21460: LD_INT 1
21462: GREATER
21463: IFFALSE 21481
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21465: LD_VAR 0 3
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: PPUSH
21474: LD_STRING D5-Sol2-2
21476: PPUSH
21477: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21481: LD_EXP 58
21485: PPUSH
21486: LD_STRING D5-Pow-3
21488: PPUSH
21489: CALL_OW 88
// wait ( 0 0$1 ) ;
21493: LD_INT 35
21495: PPUSH
21496: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21500: LD_ADDR_VAR 0 3
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 1
21512: ARRAY
21513: PUSH
21514: LD_EXP 18
21518: PUSH
21519: LD_INT 2
21521: ARRAY
21522: UNION
21523: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21524: LD_VAR 0 3
21528: PPUSH
21529: LD_INT 80
21531: PPUSH
21532: LD_INT 67
21534: PPUSH
21535: CALL_OW 114
// wait ( 0 0$2 ) ;
21539: LD_INT 70
21541: PPUSH
21542: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21546: LD_INT 79
21548: PPUSH
21549: LD_INT 72
21551: PPUSH
21552: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21556: LD_INT 35
21558: PPUSH
21559: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21563: LD_VAR 0 3
21567: PPUSH
21568: LD_INT 3
21570: PUSH
21571: LD_INT 24
21573: PUSH
21574: LD_INT 1000
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: PUSH
21581: EMPTY
21582: LIST
21583: LIST
21584: PPUSH
21585: CALL_OW 72
21589: IFFALSE 21556
// Say ( Powell , D5a-Pow-1 ) ;
21591: LD_EXP 58
21595: PPUSH
21596: LD_STRING D5a-Pow-1
21598: PPUSH
21599: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21603: LD_EXP 58
21607: PPUSH
21608: LD_STRING D5a-Pow-1a
21610: PPUSH
21611: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21615: LD_INT 10
21617: PPUSH
21618: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21622: LD_EXP 58
21626: PPUSH
21627: LD_STRING D5a-Pow-1b
21629: PPUSH
21630: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21634: LD_EXP 58
21638: PPUSH
21639: LD_STRING D5a-Pow-1c
21641: PPUSH
21642: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21646: LD_EXP 58
21650: PPUSH
21651: LD_STRING D5a-Pow-1d
21653: PPUSH
21654: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21658: LD_INT 35
21660: PPUSH
21661: CALL_OW 67
// if not HasTask ( tmp ) then
21665: LD_VAR 0 3
21669: PPUSH
21670: CALL_OW 314
21674: NOT
21675: IFFALSE 21692
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21677: LD_VAR 0 3
21681: PPUSH
21682: LD_INT 80
21684: PPUSH
21685: LD_INT 67
21687: PPUSH
21688: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21692: LD_VAR 0 3
21696: PPUSH
21697: LD_INT 24
21699: PUSH
21700: LD_INT 1
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: PPUSH
21707: CALL_OW 72
21711: NOT
21712: IFFALSE 21658
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21714: LD_ADDR_VAR 0 3
21718: PUSH
21719: LD_INT 22
21721: PUSH
21722: LD_INT 4
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: PUSH
21729: LD_INT 92
21731: PUSH
21732: LD_INT 60
21734: PUSH
21735: LD_INT 93
21737: PUSH
21738: LD_INT 10
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: LIST
21745: LIST
21746: PUSH
21747: LD_INT 3
21749: PUSH
21750: LD_INT 54
21752: PUSH
21753: EMPTY
21754: LIST
21755: PUSH
21756: EMPTY
21757: LIST
21758: LIST
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: LIST
21764: PPUSH
21765: CALL_OW 69
21769: PUSH
21770: LD_EXP 58
21774: DIFF
21775: ST_TO_ADDR
// if tmp then
21776: LD_VAR 0 3
21780: IFFALSE 21814
// for i in tmp do
21782: LD_ADDR_VAR 0 1
21786: PUSH
21787: LD_VAR 0 3
21791: PUSH
21792: FOR_IN
21793: IFFALSE 21812
// ComMoveXY ( i , 36 , 67 ) ;
21795: LD_VAR 0 1
21799: PPUSH
21800: LD_INT 36
21802: PPUSH
21803: LD_INT 67
21805: PPUSH
21806: CALL_OW 111
21810: GO 21792
21812: POP
21813: POP
// wait ( 0 0$3 ) ;
21814: LD_INT 105
21816: PPUSH
21817: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21821: LD_VAR 0 11
21825: PPUSH
21826: LD_STRING D6-Sol3-1
21828: PPUSH
21829: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21833: LD_EXP 58
21837: PPUSH
21838: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21842: LD_EXP 58
21846: PPUSH
21847: LD_STRING D6-Pow-1
21849: PPUSH
21850: CALL_OW 88
// tmp := [ ] ;
21854: LD_ADDR_VAR 0 3
21858: PUSH
21859: EMPTY
21860: ST_TO_ADDR
// for i = 1 to 2 do
21861: LD_ADDR_VAR 0 1
21865: PUSH
21866: DOUBLE
21867: LD_INT 1
21869: DEC
21870: ST_TO_ADDR
21871: LD_INT 2
21873: PUSH
21874: FOR_TO
21875: IFFALSE 21989
// begin uc_side := 8 ;
21877: LD_ADDR_OWVAR 20
21881: PUSH
21882: LD_INT 8
21884: ST_TO_ADDR
// uc_nation := 2 ;
21885: LD_ADDR_OWVAR 21
21889: PUSH
21890: LD_INT 2
21892: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21893: LD_INT 14
21895: PPUSH
21896: LD_INT 3
21898: PPUSH
21899: LD_INT 2
21901: PPUSH
21902: LD_INT 29
21904: PPUSH
21905: LD_INT 100
21907: PPUSH
21908: CALL 71856 0 5
// veh := CreateVehicle ;
21912: LD_ADDR_VAR 0 13
21916: PUSH
21917: CALL_OW 45
21921: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21922: LD_VAR 0 13
21926: PPUSH
21927: LD_INT 4
21929: PPUSH
21930: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21934: LD_VAR 0 13
21938: PPUSH
21939: LD_INT 99
21941: PPUSH
21942: LD_INT 83
21944: PPUSH
21945: LD_INT 6
21947: PPUSH
21948: LD_INT 0
21950: PPUSH
21951: CALL_OW 50
// wait ( 3 ) ;
21955: LD_INT 3
21957: PPUSH
21958: CALL_OW 67
// Connect ( veh ) ;
21962: LD_VAR 0 13
21966: PPUSH
21967: CALL 74911 0 1
// tmp := tmp ^ veh ;
21971: LD_ADDR_VAR 0 3
21975: PUSH
21976: LD_VAR 0 3
21980: PUSH
21981: LD_VAR 0 13
21985: ADD
21986: ST_TO_ADDR
// end ;
21987: GO 21874
21989: POP
21990: POP
// wait ( 0 0$1 ) ;
21991: LD_INT 35
21993: PPUSH
21994: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21998: LD_INT 99
22000: PPUSH
22001: LD_INT 83
22003: PPUSH
22004: LD_INT 1
22006: PPUSH
22007: LD_INT 10
22009: PPUSH
22010: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22014: LD_INT 99
22016: PPUSH
22017: LD_INT 83
22019: PPUSH
22020: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22024: LD_VAR 0 11
22028: PPUSH
22029: LD_STRING D6-Sol3-2
22031: PPUSH
22032: CALL_OW 88
// async ;
22036: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22037: LD_EXP 58
22041: PPUSH
22042: LD_STRING D6-Pow-2
22044: PPUSH
22045: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22049: LD_VAR 0 3
22053: PUSH
22054: LD_INT 1
22056: ARRAY
22057: PPUSH
22058: LD_VAR 0 9
22062: PPUSH
22063: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22067: LD_VAR 0 3
22071: PUSH
22072: LD_INT 2
22074: ARRAY
22075: PPUSH
22076: LD_INT 22
22078: PUSH
22079: LD_INT 4
22081: PUSH
22082: EMPTY
22083: LIST
22084: LIST
22085: PUSH
22086: LD_INT 21
22088: PUSH
22089: LD_INT 3
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: PUSH
22096: EMPTY
22097: LIST
22098: LIST
22099: PPUSH
22100: CALL_OW 69
22104: PPUSH
22105: LD_VAR 0 3
22109: PUSH
22110: LD_INT 2
22112: ARRAY
22113: PPUSH
22114: CALL_OW 74
22118: PPUSH
22119: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22123: LD_EXP 58
22127: PPUSH
22128: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22132: LD_INT 99
22134: PPUSH
22135: LD_INT 83
22137: PPUSH
22138: LD_INT 1
22140: PPUSH
22141: CALL_OW 331
// repeat wait ( 4 ) ;
22145: LD_INT 4
22147: PPUSH
22148: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22152: LD_VAR 0 3
22156: PUSH
22157: LD_INT 1
22159: ARRAY
22160: PPUSH
22161: CALL_OW 256
22165: PUSH
22166: LD_INT 1000
22168: LESS
22169: IFFALSE 22187
// SetLives ( tmp [ 1 ] , 1000 ) ;
22171: LD_VAR 0 3
22175: PUSH
22176: LD_INT 1
22178: ARRAY
22179: PPUSH
22180: LD_INT 1000
22182: PPUSH
22183: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22187: LD_INT 22
22189: PUSH
22190: LD_INT 4
22192: PUSH
22193: EMPTY
22194: LIST
22195: LIST
22196: PUSH
22197: LD_INT 30
22199: PUSH
22200: LD_INT 3
22202: PUSH
22203: EMPTY
22204: LIST
22205: LIST
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PPUSH
22211: CALL_OW 69
22215: PUSH
22216: LD_INT 0
22218: EQUAL
22219: IFFALSE 22145
// sync ;
22221: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22222: LD_EXP 58
22226: PPUSH
22227: LD_STRING D6a-Pow-1
22229: PPUSH
22230: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22234: LD_VAR 0 11
22238: PPUSH
22239: LD_STRING D6a-Sol3-1
22241: PPUSH
22242: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22246: LD_EXP 58
22250: PPUSH
22251: LD_STRING D6a-Pow-2
22253: PPUSH
22254: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22258: LD_VAR 0 11
22262: PPUSH
22263: LD_STRING D6a-Sol3-2
22265: PPUSH
22266: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22270: LD_EXP 58
22274: PPUSH
22275: LD_STRING D6a-Pow-3
22277: PPUSH
22278: CALL_OW 88
// powellCenterCameraMode := true ;
22282: LD_ADDR_EXP 20
22286: PUSH
22287: LD_INT 1
22289: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22290: LD_ADDR_VAR 0 1
22294: PUSH
22295: LD_INT 22
22297: PUSH
22298: LD_INT 8
22300: PUSH
22301: EMPTY
22302: LIST
22303: LIST
22304: PUSH
22305: LD_INT 25
22307: PUSH
22308: LD_INT 2
22310: PUSH
22311: EMPTY
22312: LIST
22313: LIST
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: PPUSH
22319: CALL_OW 69
22323: PUSH
22324: FOR_IN
22325: IFFALSE 22380
// begin SetTag ( i , 1 ) ;
22327: LD_VAR 0 1
22331: PPUSH
22332: LD_INT 1
22334: PPUSH
22335: CALL_OW 109
// ComExitBuilding ( i ) ;
22339: LD_VAR 0 1
22343: PPUSH
22344: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22348: LD_VAR 0 1
22352: PPUSH
22353: LD_INT 35
22355: PPUSH
22356: LD_INT 6
22358: PPUSH
22359: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22363: LD_VAR 0 1
22367: PPUSH
22368: LD_INT 53
22370: PPUSH
22371: LD_INT 4
22373: PPUSH
22374: CALL_OW 171
// end ;
22378: GO 22324
22380: POP
22381: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22382: LD_ADDR_VAR 0 3
22386: PUSH
22387: LD_INT 22
22389: PUSH
22390: LD_INT 4
22392: PUSH
22393: EMPTY
22394: LIST
22395: LIST
22396: PUSH
22397: LD_INT 21
22399: PUSH
22400: LD_INT 2
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 3
22409: PUSH
22410: LD_INT 34
22412: PUSH
22413: LD_INT 12
22415: PUSH
22416: EMPTY
22417: LIST
22418: LIST
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: EMPTY
22425: LIST
22426: LIST
22427: LIST
22428: PPUSH
22429: CALL_OW 69
22433: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22434: LD_EXP 58
22438: PPUSH
22439: LD_VAR 0 3
22443: PPUSH
22444: LD_EXP 58
22448: PPUSH
22449: CALL_OW 74
22453: PPUSH
22454: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22458: LD_EXP 58
22462: PPUSH
22463: LD_INT 100
22465: PPUSH
22466: LD_INT 88
22468: PPUSH
22469: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22473: LD_EXP 58
22477: PPUSH
22478: LD_INT 100
22480: PPUSH
22481: LD_INT 75
22483: PPUSH
22484: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22488: LD_EXP 58
22492: PPUSH
22493: LD_INT 88
22495: PPUSH
22496: LD_INT 53
22498: PPUSH
22499: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22503: LD_INT 8
22505: PPUSH
22506: LD_EXP 58
22510: PPUSH
22511: CALL_OW 471
// repeat wait ( 3 ) ;
22515: LD_INT 3
22517: PPUSH
22518: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22522: LD_INT 22
22524: PUSH
22525: LD_INT 4
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: PUSH
22532: LD_INT 92
22534: PUSH
22535: LD_INT 100
22537: PUSH
22538: LD_INT 75
22540: PUSH
22541: LD_INT 6
22543: PUSH
22544: EMPTY
22545: LIST
22546: LIST
22547: LIST
22548: LIST
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: PPUSH
22554: CALL_OW 69
22558: IFFALSE 22515
// async ;
22560: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22561: LD_EXP 58
22565: PPUSH
22566: LD_STRING D6b-Pow-1
22568: PPUSH
22569: CALL_OW 88
// repeat wait ( 3 ) ;
22573: LD_INT 3
22575: PPUSH
22576: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22580: LD_EXP 58
22584: PPUSH
22585: CALL_OW 310
22589: PPUSH
22590: CALL_OW 256
22594: PUSH
22595: LD_INT 1000
22597: LESS
22598: IFFALSE 22617
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 310
22609: PPUSH
22610: LD_INT 1000
22612: PPUSH
22613: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22617: LD_EXP 58
22621: PPUSH
22622: CALL_OW 256
22626: PUSH
22627: LD_INT 1000
22629: LESS
22630: IFFALSE 22644
// SetLives ( Powell , 1000 ) ;
22632: LD_EXP 58
22636: PPUSH
22637: LD_INT 1000
22639: PPUSH
22640: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22644: LD_EXP 58
22648: PPUSH
22649: LD_EXP 63
22653: PPUSH
22654: CALL_OW 296
22658: PUSH
22659: LD_INT 5
22661: LESS
22662: PUSH
22663: LD_EXP 58
22667: PPUSH
22668: CALL_OW 310
22672: PPUSH
22673: LD_EXP 63
22677: PPUSH
22678: CALL_OW 296
22682: PUSH
22683: LD_INT 5
22685: LESS
22686: OR
22687: IFFALSE 22706
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22689: LD_EXP 58
22693: PPUSH
22694: CALL_OW 310
22698: PPUSH
22699: LD_INT 100
22701: PPUSH
22702: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22706: LD_EXP 58
22710: PPUSH
22711: CALL_OW 310
22715: NOT
22716: IFFALSE 22573
// DoNotAttack ( 8 , powellBomb ) ;
22718: LD_INT 8
22720: PPUSH
22721: LD_EXP 63
22725: PPUSH
22726: CALL_OW 471
// game_speed := 4 ;
22730: LD_ADDR_OWVAR 65
22734: PUSH
22735: LD_INT 4
22737: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22738: LD_EXP 58
22742: PPUSH
22743: LD_STRING D6b-Pow-1a
22745: PPUSH
22746: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22750: LD_EXP 58
22754: PPUSH
22755: LD_EXP 63
22759: PPUSH
22760: CALL_OW 180
// sync ;
22764: SYNC
// repeat wait ( 0 0$1 ) ;
22765: LD_INT 35
22767: PPUSH
22768: CALL_OW 67
// until IsInUnit ( Powell ) ;
22772: LD_EXP 58
22776: PPUSH
22777: CALL_OW 310
22781: IFFALSE 22765
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22783: LD_INT 8
22785: PPUSH
22786: LD_EXP 58
22790: PPUSH
22791: CALL_OW 310
22795: PPUSH
22796: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22800: LD_EXP 58
22804: PPUSH
22805: LD_INT 91
22807: PPUSH
22808: LD_INT 44
22810: PPUSH
22811: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22815: LD_EXP 58
22819: PPUSH
22820: LD_INT 96
22822: PPUSH
22823: LD_INT 44
22825: PPUSH
22826: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22830: LD_EXP 58
22834: PPUSH
22835: LD_INT 96
22837: PPUSH
22838: LD_INT 41
22840: PPUSH
22841: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: LD_INT 92
22852: PPUSH
22853: LD_INT 39
22855: PPUSH
22856: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22860: LD_EXP 58
22864: PPUSH
22865: LD_INT 88
22867: PPUSH
22868: LD_INT 41
22870: PPUSH
22871: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22875: LD_EXP 58
22879: PPUSH
22880: LD_INT 91
22882: PPUSH
22883: LD_INT 44
22885: PPUSH
22886: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22890: LD_EXP 58
22894: PPUSH
22895: LD_INT 96
22897: PPUSH
22898: LD_INT 44
22900: PPUSH
22901: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22905: LD_EXP 58
22909: PPUSH
22910: LD_INT 96
22912: PPUSH
22913: LD_INT 41
22915: PPUSH
22916: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22920: LD_EXP 58
22924: PPUSH
22925: LD_INT 92
22927: PPUSH
22928: LD_INT 39
22930: PPUSH
22931: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22935: LD_EXP 58
22939: PPUSH
22940: LD_INT 88
22942: PPUSH
22943: LD_INT 41
22945: PPUSH
22946: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22950: LD_EXP 58
22954: PPUSH
22955: LD_INT 91
22957: PPUSH
22958: LD_INT 44
22960: PPUSH
22961: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22965: LD_EXP 58
22969: PPUSH
22970: LD_INT 93
22972: PPUSH
22973: LD_INT 39
22975: PPUSH
22976: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22980: LD_EXP 58
22984: PPUSH
22985: LD_INT 93
22987: PPUSH
22988: LD_INT 36
22990: PPUSH
22991: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22995: LD_INT 122
22997: PPUSH
22998: CALL_OW 67
// game_speed := 4 ;
23002: LD_ADDR_OWVAR 65
23006: PUSH
23007: LD_INT 4
23009: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23010: LD_EXP 58
23014: PPUSH
23015: LD_STRING D6b-Pow-1b
23017: PPUSH
23018: CALL_OW 88
// tmp := [ ] ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: EMPTY
23028: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23029: LD_ADDR_VAR 0 5
23033: PUSH
23034: LD_INT 78
23036: PUSH
23037: LD_INT 47
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PUSH
23044: LD_INT 106
23046: PUSH
23047: LD_INT 53
23049: PUSH
23050: EMPTY
23051: LIST
23052: LIST
23053: PUSH
23054: EMPTY
23055: LIST
23056: LIST
23057: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23058: LD_ADDR_VAR 0 1
23062: PUSH
23063: LD_INT 22
23065: PUSH
23066: LD_INT 8
23068: PUSH
23069: EMPTY
23070: LIST
23071: LIST
23072: PUSH
23073: LD_INT 21
23075: PUSH
23076: LD_INT 3
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: LD_INT 92
23085: PUSH
23086: LD_INT 90
23088: PUSH
23089: LD_INT 52
23091: PUSH
23092: LD_INT 12
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: PPUSH
23106: CALL_OW 69
23110: PUSH
23111: FOR_IN
23112: IFFALSE 23137
// tmp := tmp ^ UnitsInside ( i ) ;
23114: LD_ADDR_VAR 0 3
23118: PUSH
23119: LD_VAR 0 3
23123: PUSH
23124: LD_VAR 0 1
23128: PPUSH
23129: CALL_OW 313
23133: ADD
23134: ST_TO_ADDR
23135: GO 23111
23137: POP
23138: POP
// for i in tmp do
23139: LD_ADDR_VAR 0 1
23143: PUSH
23144: LD_VAR 0 3
23148: PUSH
23149: FOR_IN
23150: IFFALSE 23312
// begin dist := 9999 ;
23152: LD_ADDR_VAR 0 8
23156: PUSH
23157: LD_INT 9999
23159: ST_TO_ADDR
// _xy := [ ] ;
23160: LD_ADDR_VAR 0 7
23164: PUSH
23165: EMPTY
23166: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23167: LD_VAR 0 1
23171: PPUSH
23172: LD_INT 1
23174: PPUSH
23175: CALL_OW 109
// ComExitBuilding ( i ) ;
23179: LD_VAR 0 1
23183: PPUSH
23184: CALL_OW 122
// for j in xy do
23188: LD_ADDR_VAR 0 2
23192: PUSH
23193: LD_VAR 0 5
23197: PUSH
23198: FOR_IN
23199: IFFALSE 23281
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23201: LD_VAR 0 1
23205: PPUSH
23206: LD_VAR 0 2
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: LD_VAR 0 2
23219: PUSH
23220: LD_INT 2
23222: ARRAY
23223: PPUSH
23224: CALL_OW 297
23228: PUSH
23229: LD_VAR 0 8
23233: LESS
23234: IFFALSE 23279
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23236: LD_ADDR_VAR 0 8
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: LD_VAR 0 2
23250: PUSH
23251: LD_INT 1
23253: ARRAY
23254: PPUSH
23255: LD_VAR 0 2
23259: PUSH
23260: LD_INT 2
23262: ARRAY
23263: PPUSH
23264: CALL_OW 297
23268: ST_TO_ADDR
// _xy := j ;
23269: LD_ADDR_VAR 0 7
23273: PUSH
23274: LD_VAR 0 2
23278: ST_TO_ADDR
// end ;
23279: GO 23198
23281: POP
23282: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_VAR 0 7
23292: PUSH
23293: LD_INT 1
23295: ARRAY
23296: PPUSH
23297: LD_VAR 0 7
23301: PUSH
23302: LD_INT 2
23304: ARRAY
23305: PPUSH
23306: CALL_OW 171
// end ;
23310: GO 23149
23312: POP
23313: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23314: LD_ADDR_VAR 0 4
23318: PUSH
23319: LD_VAR 0 3
23323: PPUSH
23324: LD_INT 26
23326: PUSH
23327: LD_INT 1
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PUSH
23334: LD_INT 25
23336: PUSH
23337: LD_INT 1
23339: PUSH
23340: EMPTY
23341: LIST
23342: LIST
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PPUSH
23348: CALL_OW 72
23352: ST_TO_ADDR
// if tmp2 < 2 then
23353: LD_VAR 0 4
23357: PUSH
23358: LD_INT 2
23360: LESS
23361: IFFALSE 23430
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23363: LD_ADDR_VAR 0 4
23367: PUSH
23368: LD_INT 22
23370: PUSH
23371: LD_INT 8
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: LD_INT 26
23380: PUSH
23381: LD_INT 1
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: PUSH
23388: LD_INT 3
23390: PUSH
23391: LD_INT 25
23393: PUSH
23394: LD_INT 15
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: PUSH
23401: EMPTY
23402: LIST
23403: LIST
23404: PUSH
23405: EMPTY
23406: LIST
23407: LIST
23408: LIST
23409: PPUSH
23410: CALL_OW 69
23414: PUSH
23415: LD_EXP 60
23419: PUSH
23420: LD_EXP 61
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: DIFF
23429: ST_TO_ADDR
// if tmp2 then
23430: LD_VAR 0 4
23434: IFFALSE 23452
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23436: LD_VAR 0 4
23440: PUSH
23441: LD_INT 1
23443: ARRAY
23444: PPUSH
23445: LD_STRING D6b-ArSol1-1
23447: PPUSH
23448: CALL_OW 88
// async ;
23452: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23453: LD_EXP 58
23457: PPUSH
23458: LD_STRING D6b-Pow-2
23460: PPUSH
23461: CALL_OW 88
// wait ( 0 0$1 ) ;
23465: LD_INT 35
23467: PPUSH
23468: CALL_OW 67
// if tmp2 > 1 then
23472: LD_VAR 0 4
23476: PUSH
23477: LD_INT 1
23479: GREATER
23480: IFFALSE 23498
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23482: LD_VAR 0 4
23486: PUSH
23487: LD_INT 2
23489: ARRAY
23490: PPUSH
23491: LD_STRING D6b-ArSol2-1
23493: PPUSH
23494: CALL_OW 88
// sync ;
23498: SYNC
// repeat wait ( 5 ) ;
23499: LD_INT 5
23501: PPUSH
23502: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23506: LD_INT 93
23508: PPUSH
23509: LD_INT 36
23511: PPUSH
23512: CALL_OW 428
23516: PPUSH
23517: CALL_OW 255
23521: PUSH
23522: LD_INT 4
23524: EQUAL
23525: IFFALSE 23499
// DialogueOn ;
23527: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23531: LD_INT 10
23533: PPUSH
23534: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23538: LD_EXP 58
23542: PPUSH
23543: LD_STRING D6b-Pow-2a
23545: PPUSH
23546: CALL_OW 88
// DialogueOff ;
23550: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23554: LD_EXP 58
23558: PPUSH
23559: CALL_OW 310
23563: PPUSH
23564: LD_INT 332
23566: PPUSH
23567: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23571: LD_INT 93
23573: PPUSH
23574: LD_INT 35
23576: PPUSH
23577: LD_INT 1
23579: PPUSH
23580: LD_INT 6
23582: NEG
23583: PPUSH
23584: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23588: LD_INT 35
23590: PPUSH
23591: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23595: LD_INT 332
23597: PPUSH
23598: CALL_OW 256
23602: PUSH
23603: LD_INT 1000
23605: LESS
23606: PUSH
23607: LD_INT 332
23609: PPUSH
23610: CALL_OW 300
23614: AND
23615: IFFALSE 23627
// SetLives ( kozlov_fac , 0 ) ;
23617: LD_INT 332
23619: PPUSH
23620: LD_INT 0
23622: PPUSH
23623: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23627: LD_INT 332
23629: PPUSH
23630: CALL_OW 301
23634: PUSH
23635: LD_EXP 58
23639: PPUSH
23640: CALL_OW 301
23644: OR
23645: IFFALSE 23588
// game_speed := 4 ;
23647: LD_ADDR_OWVAR 65
23651: PUSH
23652: LD_INT 4
23654: ST_TO_ADDR
// powellCenterCameraMode := false ;
23655: LD_ADDR_EXP 20
23659: PUSH
23660: LD_INT 0
23662: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23663: LD_ADDR_VAR 0 1
23667: PUSH
23668: LD_VAR 0 3
23672: PUSH
23673: LD_INT 22
23675: PUSH
23676: LD_INT 8
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: LD_INT 25
23685: PUSH
23686: LD_INT 2
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: PPUSH
23697: CALL_OW 69
23701: UNION
23702: PUSH
23703: FOR_IN
23704: IFFALSE 23720
// SetTag ( i , 0 ) ;
23706: LD_VAR 0 1
23710: PPUSH
23711: LD_INT 0
23713: PPUSH
23714: CALL_OW 109
23718: GO 23703
23720: POP
23721: POP
// wait ( 0 0$3 ) ;
23722: LD_INT 105
23724: PPUSH
23725: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23729: LD_INT 93
23731: PPUSH
23732: LD_INT 35
23734: PPUSH
23735: LD_INT 1
23737: PPUSH
23738: CALL_OW 331
// DialogueOn ;
23742: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23746: LD_VAR 0 11
23750: PPUSH
23751: LD_STRING D6c-Sol3-1
23753: PPUSH
23754: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23758: LD_INT 10
23760: PPUSH
23761: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23765: LD_EXP 39
23769: PPUSH
23770: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23774: LD_EXP 39
23778: PPUSH
23779: LD_STRING D6c-JMM-1
23781: PPUSH
23782: CALL_OW 88
// if Cyrus then
23786: LD_EXP 45
23790: IFFALSE 23804
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23792: LD_EXP 45
23796: PPUSH
23797: LD_STRING D6c-Cyrus-1
23799: PPUSH
23800: CALL_OW 88
// if Bobby then
23804: LD_EXP 44
23808: IFFALSE 23822
// Say ( Bobby , D6c-Bobby-1 ) ;
23810: LD_EXP 44
23814: PPUSH
23815: LD_STRING D6c-Bobby-1
23817: PPUSH
23818: CALL_OW 88
// if Cornel then
23822: LD_EXP 50
23826: IFFALSE 23840
// Say ( Cornel , D6c-Corn-1 ) ;
23828: LD_EXP 50
23832: PPUSH
23833: LD_STRING D6c-Corn-1
23835: PPUSH
23836: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23840: LD_ADDR_VAR 0 4
23844: PUSH
23845: LD_INT 2
23847: PUSH
23848: LD_INT 22
23850: PUSH
23851: LD_INT 1
23853: PUSH
23854: EMPTY
23855: LIST
23856: LIST
23857: PUSH
23858: LD_INT 22
23860: PUSH
23861: LD_INT 4
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: LIST
23872: PUSH
23873: LD_INT 26
23875: PUSH
23876: LD_INT 1
23878: PUSH
23879: EMPTY
23880: LIST
23881: LIST
23882: PUSH
23883: LD_INT 3
23885: PUSH
23886: LD_INT 25
23888: PUSH
23889: LD_INT 16
23891: PUSH
23892: EMPTY
23893: LIST
23894: LIST
23895: PUSH
23896: LD_INT 25
23898: PUSH
23899: LD_INT 12
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: LIST
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: PPUSH
23916: CALL_OW 69
23920: PUSH
23921: LD_VAR 0 11
23925: PUSH
23926: LD_EXP 39
23930: UNION
23931: PUSH
23932: LD_EXP 59
23936: UNION
23937: PUSH
23938: EMPTY
23939: LIST
23940: DIFF
23941: ST_TO_ADDR
// if tmp2 then
23942: LD_VAR 0 4
23946: IFFALSE 23964
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23948: LD_VAR 0 4
23952: PUSH
23953: LD_INT 1
23955: ARRAY
23956: PPUSH
23957: LD_STRING D6c-Sol1-1
23959: PPUSH
23960: CALL_OW 88
// if Lisa then
23964: LD_EXP 42
23968: IFFALSE 23982
// Say ( Lisa , D6c-Lisa-1 ) ;
23970: LD_EXP 42
23974: PPUSH
23975: LD_STRING D6c-Lisa-1
23977: PPUSH
23978: CALL_OW 88
// if Gary then
23982: LD_EXP 51
23986: IFFALSE 24000
// Say ( Gary , D6c-Gary-1 ) ;
23988: LD_EXP 51
23992: PPUSH
23993: LD_STRING D6c-Gary-1
23995: PPUSH
23996: CALL_OW 88
// if Donaldson then
24000: LD_EXP 43
24004: IFFALSE 24018
// Say ( Donaldson , D6c-Don-1 ) ;
24006: LD_EXP 43
24010: PPUSH
24011: LD_STRING D6c-Don-1
24013: PPUSH
24014: CALL_OW 88
// if tmp2 > 1 then
24018: LD_VAR 0 4
24022: PUSH
24023: LD_INT 1
24025: GREATER
24026: IFFALSE 24044
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24028: LD_VAR 0 4
24032: PUSH
24033: LD_INT 2
24035: ARRAY
24036: PPUSH
24037: LD_STRING D6c-Sol2-1
24039: PPUSH
24040: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24044: LD_VAR 0 11
24048: PPUSH
24049: LD_STRING D6c-Sol3-2
24051: PPUSH
24052: CALL_OW 88
// dwait ( 0 0$1 ) ;
24056: LD_INT 35
24058: PPUSH
24059: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24063: LD_EXP 39
24067: PPUSH
24068: LD_STRING D6c-JMM-2
24070: PPUSH
24071: CALL_OW 88
// DialogueOff ;
24075: CALL_OW 7
// Video ( false ) ;
24079: LD_INT 0
24081: PPUSH
24082: CALL 107576 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24086: LD_INT 22
24088: PUSH
24089: LD_INT 4
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: PPUSH
24096: CALL_OW 69
24100: PPUSH
24101: LD_INT 1
24103: PPUSH
24104: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24108: LD_INT 4
24110: PPUSH
24111: LD_INT 4
24113: PPUSH
24114: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24118: LD_ADDR_VAR 0 1
24122: PUSH
24123: LD_INT 4
24125: PPUSH
24126: LD_INT 1
24128: PPUSH
24129: LD_INT 2
24131: PPUSH
24132: CALL 64804 0 3
24136: PUSH
24137: FOR_IN
24138: IFFALSE 24175
// if GetTech ( i , 1 ) <> state_researched then
24140: LD_VAR 0 1
24144: PPUSH
24145: LD_INT 1
24147: PPUSH
24148: CALL_OW 321
24152: PUSH
24153: LD_INT 2
24155: NONEQUAL
24156: IFFALSE 24173
// SetTech ( i , 1 , state_researched ) ;
24158: LD_VAR 0 1
24162: PPUSH
24163: LD_INT 1
24165: PPUSH
24166: LD_INT 2
24168: PPUSH
24169: CALL_OW 322
24173: GO 24137
24175: POP
24176: POP
// missionStage := 6 ;
24177: LD_ADDR_EXP 15
24181: PUSH
24182: LD_INT 6
24184: ST_TO_ADDR
// activeAttacks := true ;
24185: LD_ADDR_EXP 16
24189: PUSH
24190: LD_INT 1
24192: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24193: LD_STRING M2
24195: PPUSH
24196: CALL_OW 337
// SaveForQuickRestart ;
24200: CALL_OW 22
// wait ( 0 0$40 ) ;
24204: LD_INT 1400
24206: PPUSH
24207: CALL_OW 67
// DialogueOn ;
24211: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24215: LD_EXP 62
24219: PPUSH
24220: LD_STRING D7-Friend-1
24222: PPUSH
24223: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24227: LD_EXP 39
24231: PPUSH
24232: LD_STRING D7-JMM-1
24234: PPUSH
24235: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24239: LD_EXP 62
24243: PPUSH
24244: LD_STRING D7-Friend-2
24246: PPUSH
24247: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24251: LD_EXP 39
24255: PPUSH
24256: LD_STRING D7-JMM-2
24258: PPUSH
24259: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24263: LD_EXP 62
24267: PPUSH
24268: LD_STRING D7-Friend-3
24270: PPUSH
24271: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24275: LD_EXP 39
24279: PPUSH
24280: LD_STRING D7-JMM-3
24282: PPUSH
24283: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24287: LD_EXP 62
24291: PPUSH
24292: LD_STRING D7-Friend-4
24294: PPUSH
24295: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24299: LD_EXP 39
24303: PPUSH
24304: LD_STRING D7-JMM-4
24306: PPUSH
24307: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24311: LD_EXP 62
24315: PPUSH
24316: LD_STRING D7-Friend-5
24318: PPUSH
24319: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24323: LD_EXP 39
24327: PPUSH
24328: LD_STRING D7-JMM-5
24330: PPUSH
24331: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24335: LD_EXP 62
24339: PPUSH
24340: LD_STRING D7-Friend-6
24342: PPUSH
24343: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24347: LD_EXP 39
24351: PPUSH
24352: LD_STRING D7-JMM-6
24354: PPUSH
24355: CALL_OW 88
// DialogueOff ;
24359: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24363: LD_STRING Mlegion
24365: PPUSH
24366: CALL_OW 337
// RebuildKozlovFactory ;
24370: CALL 4823 0 0
// end ;
24374: PPOPN 13
24376: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24377: LD_EXP 20
24381: PUSH
24382: LD_EXP 58
24386: PPUSH
24387: CALL_OW 300
24391: AND
24392: IFFALSE 24434
24394: GO 24396
24396: DISABLE
// begin enable ;
24397: ENABLE
// if IsInUnit ( Powell ) then
24398: LD_EXP 58
24402: PPUSH
24403: CALL_OW 310
24407: IFFALSE 24425
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24409: LD_EXP 58
24413: PPUSH
24414: CALL_OW 310
24418: PPUSH
24419: CALL_OW 85
24423: GO 24434
// CenterOnUnits ( Powell ) ;
24425: LD_EXP 58
24429: PPUSH
24430: CALL_OW 85
// end ;
24434: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24435: LD_INT 22
24437: PUSH
24438: LD_INT 8
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: LD_INT 34
24447: PUSH
24448: LD_INT 48
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 69
24463: IFFALSE 24737
24465: GO 24467
24467: DISABLE
24468: LD_INT 0
24470: PPUSH
24471: PPUSH
// begin if missionStage < 9 then
24472: LD_EXP 15
24476: PUSH
24477: LD_INT 9
24479: LESS
24480: IFFALSE 24490
// missionStage := 9 ;
24482: LD_ADDR_EXP 15
24486: PUSH
24487: LD_INT 9
24489: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24490: LD_ADDR_VAR 0 1
24494: PUSH
24495: LD_INT 22
24497: PUSH
24498: LD_INT 8
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: LD_INT 34
24507: PUSH
24508: LD_INT 48
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PPUSH
24519: CALL_OW 69
24523: PUSH
24524: LD_INT 1
24526: ARRAY
24527: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24528: LD_INT 175
24530: PPUSH
24531: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24535: LD_EXP 12
24539: PUSH
24540: LD_EXP 3
24544: PUSH
24545: LD_INT 0
24547: PUSH
24548: LD_INT 2
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: IN
24555: OR
24556: IFFALSE 24579
// target := [ 68 , 108 , 1 ] else
24558: LD_ADDR_VAR 0 2
24562: PUSH
24563: LD_INT 68
24565: PUSH
24566: LD_INT 108
24568: PUSH
24569: LD_INT 1
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: LIST
24576: ST_TO_ADDR
24577: GO 24598
// target := [ 181 , 88 , 2 ] ;
24579: LD_ADDR_VAR 0 2
24583: PUSH
24584: LD_INT 181
24586: PUSH
24587: LD_INT 88
24589: PUSH
24590: LD_INT 2
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: LIST
24597: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24598: LD_VAR 0 1
24602: PPUSH
24603: LD_VAR 0 2
24607: PUSH
24608: LD_INT 1
24610: ARRAY
24611: PPUSH
24612: LD_VAR 0 2
24616: PUSH
24617: LD_INT 2
24619: ARRAY
24620: PPUSH
24621: CALL_OW 176
// if target [ 3 ] = 1 then
24625: LD_VAR 0 2
24629: PUSH
24630: LD_INT 3
24632: ARRAY
24633: PUSH
24634: LD_INT 1
24636: EQUAL
24637: IFFALSE 24653
// SayRadio ( Kurt , D12-Kurt-1 ) else
24639: LD_EXP 60
24643: PPUSH
24644: LD_STRING D12-Kurt-1
24646: PPUSH
24647: CALL_OW 94
24651: GO 24677
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24653: LD_EXP 60
24657: PPUSH
24658: LD_STRING D12a-Kurt-1
24660: PPUSH
24661: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24665: LD_EXP 74
24669: PPUSH
24670: LD_STRING D12a-Roth-1
24672: PPUSH
24673: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24677: LD_INT 350
24679: PPUSH
24680: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24684: LD_VAR 0 1
24688: PPUSH
24689: LD_INT 22
24691: PUSH
24692: LD_INT 8
24694: PUSH
24695: EMPTY
24696: LIST
24697: LIST
24698: PUSH
24699: LD_INT 23
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 30
24711: PUSH
24712: LD_INT 3
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: LIST
24723: PPUSH
24724: CALL_OW 69
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 228
// end ;
24737: PPOPN 2
24739: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24740: LD_EXP 60
24744: PPUSH
24745: CALL_OW 256
24749: PUSH
24750: LD_INT 999
24752: LESS
24753: PUSH
24754: LD_INT 22
24756: PUSH
24757: LD_INT 8
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: LD_INT 21
24766: PUSH
24767: LD_INT 1
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 23
24776: PUSH
24777: LD_INT 2
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PPUSH
24789: CALL_OW 69
24793: PUSH
24794: LD_INT 9
24796: PUSH
24797: LD_INT 8
24799: PUSH
24800: LD_INT 7
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: LIST
24807: PUSH
24808: LD_OWVAR 67
24812: ARRAY
24813: LESSEQUAL
24814: OR
24815: PUSH
24816: LD_INT 22
24818: PUSH
24819: LD_INT 8
24821: PUSH
24822: EMPTY
24823: LIST
24824: LIST
24825: PUSH
24826: LD_INT 34
24828: PUSH
24829: LD_INT 48
24831: PUSH
24832: EMPTY
24833: LIST
24834: LIST
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: NOT
24845: AND
24846: PUSH
24847: LD_EXP 60
24851: PPUSH
24852: CALL_OW 302
24856: AND
24857: PUSH
24858: LD_INT 5
24860: PPUSH
24861: LD_INT 22
24863: PUSH
24864: LD_INT 1
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: PPUSH
24871: CALL_OW 70
24875: AND
24876: IFFALSE 25513
24878: GO 24880
24880: DISABLE
24881: LD_INT 0
24883: PPUSH
24884: PPUSH
24885: PPUSH
// begin DialogueOn ;
24886: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24890: LD_EXP 39
24894: PPUSH
24895: LD_STRING D13-JMM-1
24897: PPUSH
24898: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24902: LD_EXP 60
24906: PPUSH
24907: LD_STRING D13-Kurt-1
24909: PPUSH
24910: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24914: LD_EXP 39
24918: PPUSH
24919: LD_STRING D13-JMM-2
24921: PPUSH
24922: CALL_OW 88
// if FakeInfo then
24926: LD_EXP 12
24930: IFFALSE 24950
// begin Say ( Kurt , D13-Kurt-2 ) ;
24932: LD_EXP 60
24936: PPUSH
24937: LD_STRING D13-Kurt-2
24939: PPUSH
24940: CALL_OW 88
// DialogueOff ;
24944: CALL_OW 7
// exit ;
24948: GO 25513
// end ; if not KurtStatus then
24950: LD_EXP 3
24954: NOT
24955: IFFALSE 24971
// Say ( Kurt , D13-Kurt-2b ) else
24957: LD_EXP 60
24961: PPUSH
24962: LD_STRING D13-Kurt-2b
24964: PPUSH
24965: CALL_OW 88
24969: GO 24983
// Say ( Kurt , D13-Kurt-2a ) ;
24971: LD_EXP 60
24975: PPUSH
24976: LD_STRING D13-Kurt-2a
24978: PPUSH
24979: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24983: LD_EXP 39
24987: PPUSH
24988: LD_STRING D13-JMM-3
24990: PPUSH
24991: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24995: LD_EXP 60
24999: PPUSH
25000: LD_STRING D13-Kurt-3
25002: PPUSH
25003: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25007: LD_EXP 39
25011: PPUSH
25012: LD_STRING D13-JMM-4
25014: PPUSH
25015: CALL_OW 88
// DialogueOff ;
25019: CALL_OW 7
// MC_Kill ( 3 ) ;
25023: LD_INT 3
25025: PPUSH
25026: CALL 34937 0 1
// KillUnit ( Kozlov ) ;
25030: LD_EXP 61
25034: PPUSH
25035: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25039: LD_INT 22
25041: PUSH
25042: LD_INT 8
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 21
25051: PUSH
25052: LD_INT 3
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 23
25061: PUSH
25062: LD_INT 3
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: LD_INT 30
25071: PUSH
25072: LD_INT 3
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: EMPTY
25080: LIST
25081: LIST
25082: LIST
25083: LIST
25084: PPUSH
25085: CALL_OW 69
25089: PUSH
25090: LD_INT 1
25092: ARRAY
25093: PPUSH
25094: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25098: LD_INT 8
25100: PPUSH
25101: LD_INT 1
25103: PPUSH
25104: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25108: LD_ADDR_VAR 0 2
25112: PUSH
25113: LD_INT 22
25115: PUSH
25116: LD_INT 8
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: PUSH
25123: LD_INT 21
25125: PUSH
25126: LD_INT 1
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PPUSH
25137: CALL_OW 69
25141: PUSH
25142: LD_EXP 61
25146: PUSH
25147: LD_EXP 60
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: DIFF
25156: ST_TO_ADDR
// if tmp >= [ 9 , 8 , 7 ] [ Difficulty ] then
25157: LD_VAR 0 2
25161: PUSH
25162: LD_INT 9
25164: PUSH
25165: LD_INT 8
25167: PUSH
25168: LD_INT 7
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: LIST
25175: PUSH
25176: LD_OWVAR 67
25180: ARRAY
25181: GREATEREQUAL
25182: IFFALSE 25344
// begin x := [ 9 , 8 , 7 ] [ Difficulty ] ;
25184: LD_ADDR_VAR 0 3
25188: PUSH
25189: LD_INT 9
25191: PUSH
25192: LD_INT 8
25194: PUSH
25195: LD_INT 7
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: PUSH
25203: LD_OWVAR 67
25207: ARRAY
25208: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25209: LD_ADDR_VAR 0 1
25213: PUSH
25214: DOUBLE
25215: LD_VAR 0 2
25219: PUSH
25220: LD_VAR 0 3
25224: PUSH
25225: LD_INT 1
25227: PLUS
25228: MINUS
25229: INC
25230: ST_TO_ADDR
25231: LD_INT 1
25233: PUSH
25234: FOR_DOWNTO
25235: IFFALSE 25340
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25237: LD_ADDR_EXP 38
25241: PUSH
25242: LD_EXP 38
25246: PUSH
25247: LD_VAR 0 2
25251: PUSH
25252: LD_VAR 0 1
25256: ARRAY
25257: ADD
25258: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25259: LD_VAR 0 2
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: CALL_OW 310
25274: IFFALSE 25291
// ComExitBuilding ( tmp [ i ] ) ;
25276: LD_VAR 0 2
25280: PUSH
25281: LD_VAR 0 1
25285: ARRAY
25286: PPUSH
25287: CALL_OW 122
// if IsInUnit ( i ) then
25291: LD_VAR 0 1
25295: PPUSH
25296: CALL_OW 310
25300: IFFALSE 25317
// ComExitVehicle ( tmp [ i ] ) ;
25302: LD_VAR 0 2
25306: PUSH
25307: LD_VAR 0 1
25311: ARRAY
25312: PPUSH
25313: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 37 , 1 ) ;
25317: LD_VAR 0 2
25321: PUSH
25322: LD_VAR 0 1
25326: ARRAY
25327: PPUSH
25328: LD_INT 37
25330: PPUSH
25331: LD_INT 1
25333: PPUSH
25334: CALL_OW 171
// end ;
25338: GO 25234
25340: POP
25341: POP
// end else
25342: GO 25354
// x := tmp ;
25344: LD_ADDR_VAR 0 3
25348: PUSH
25349: LD_VAR 0 2
25353: ST_TO_ADDR
// for i := tmp downto tmp - x do
25354: LD_ADDR_VAR 0 1
25358: PUSH
25359: DOUBLE
25360: LD_VAR 0 2
25364: INC
25365: ST_TO_ADDR
25366: LD_VAR 0 2
25370: PUSH
25371: LD_VAR 0 3
25375: MINUS
25376: PUSH
25377: FOR_DOWNTO
25378: IFFALSE 25400
// SetSide ( tmp [ i ] , 1 ) ;
25380: LD_VAR 0 2
25384: PUSH
25385: LD_VAR 0 1
25389: ARRAY
25390: PPUSH
25391: LD_INT 1
25393: PPUSH
25394: CALL_OW 235
25398: GO 25377
25400: POP
25401: POP
// SetSide ( Kurt , 1 ) ;
25402: LD_EXP 60
25406: PPUSH
25407: LD_INT 1
25409: PPUSH
25410: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25414: LD_INT 22
25416: PUSH
25417: LD_INT 8
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 21
25426: PUSH
25427: LD_INT 3
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: EMPTY
25435: LIST
25436: LIST
25437: PPUSH
25438: CALL_OW 69
25442: PPUSH
25443: LD_INT 1
25445: PPUSH
25446: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25450: LD_INT 8
25452: PPUSH
25453: LD_INT 1
25455: PPUSH
25456: LD_INT 1
25458: PPUSH
25459: LD_INT 1
25461: PPUSH
25462: CALL_OW 80
// wait ( 0 0$40 ) ;
25466: LD_INT 1400
25468: PPUSH
25469: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25473: LD_EXP 62
25477: PPUSH
25478: LD_INT 37
25480: PPUSH
25481: LD_INT 1
25483: PPUSH
25484: LD_INT 0
25486: PPUSH
25487: CALL_OW 48
// wait ( 0 0$1 ) ;
25491: LD_INT 35
25493: PPUSH
25494: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25498: LD_EXP 62
25502: PPUSH
25503: LD_INT 60
25505: PPUSH
25506: LD_INT 95
25508: PPUSH
25509: CALL_OW 111
// end ;
25513: PPOPN 3
25515: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25516: LD_EXP 38
25520: IFFALSE 25595
25522: GO 25524
25524: DISABLE
25525: LD_INT 0
25527: PPUSH
// begin enable ;
25528: ENABLE
// for i in legionEscapeUnits do
25529: LD_ADDR_VAR 0 1
25533: PUSH
25534: LD_EXP 38
25538: PUSH
25539: FOR_IN
25540: IFFALSE 25593
// begin if IsInArea ( i , legionEscapeArea ) then
25542: LD_VAR 0 1
25546: PPUSH
25547: LD_INT 31
25549: PPUSH
25550: CALL_OW 308
25554: IFFALSE 25567
// RemoveUnit ( i ) else
25556: LD_VAR 0 1
25560: PPUSH
25561: CALL_OW 64
25565: GO 25591
// if not HasTask ( i ) then
25567: LD_VAR 0 1
25571: PPUSH
25572: CALL_OW 314
25576: NOT
25577: IFFALSE 25591
// ComMoveToArea ( i , legionEscapeArea ) ;
25579: LD_VAR 0 1
25583: PPUSH
25584: LD_INT 31
25586: PPUSH
25587: CALL_OW 113
// end ;
25591: GO 25539
25593: POP
25594: POP
// end ;
25595: PPOPN 1
25597: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25598: LD_INT 22
25600: PUSH
25601: LD_INT 8
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 21
25610: PUSH
25611: LD_INT 1
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PPUSH
25622: CALL_OW 69
25626: PUSH
25627: LD_INT 0
25629: EQUAL
25630: IFFALSE 25650
25632: GO 25634
25634: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25635: LD_STRING MlegionOut
25637: PPUSH
25638: CALL_OW 337
// legionDestroyed := true ;
25642: LD_ADDR_EXP 22
25646: PUSH
25647: LD_INT 1
25649: ST_TO_ADDR
// end ;
25650: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25651: LD_INT 1
25653: PPUSH
25654: LD_EXP 62
25658: PPUSH
25659: CALL_OW 292
25663: IFFALSE 25977
25665: GO 25667
25667: DISABLE
25668: LD_INT 0
25670: PPUSH
// begin wait ( 0 0$2 ) ;
25671: LD_INT 70
25673: PPUSH
25674: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25678: LD_EXP 62
25682: PPUSH
25683: CALL_OW 87
// DialogueOn ;
25687: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25691: LD_EXP 39
25695: PPUSH
25696: LD_STRING D14-JMM-1
25698: PPUSH
25699: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25703: LD_EXP 62
25707: PPUSH
25708: LD_STRING D14-Friend-1
25710: PPUSH
25711: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25715: LD_EXP 39
25719: PPUSH
25720: LD_STRING D14-JMM-2
25722: PPUSH
25723: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25727: LD_EXP 62
25731: PPUSH
25732: LD_STRING D14-Friend-2
25734: PPUSH
25735: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25739: LD_EXP 39
25743: PPUSH
25744: LD_STRING D14-JMM-3
25746: PPUSH
25747: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25751: LD_EXP 62
25755: PPUSH
25756: LD_STRING D14-Friend-3
25758: PPUSH
25759: CALL_OW 88
// DialogueOff ;
25763: CALL_OW 7
// dec = Query ( Q14 ) ;
25767: LD_ADDR_VAR 0 1
25771: PUSH
25772: LD_STRING Q14
25774: PPUSH
25775: CALL_OW 97
25779: ST_TO_ADDR
// if dec = 1 then
25780: LD_VAR 0 1
25784: PUSH
25785: LD_INT 1
25787: EQUAL
25788: IFFALSE 25822
// begin DialogueOn ;
25790: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25794: LD_EXP 39
25798: PPUSH
25799: LD_STRING D14a-JMM-1
25801: PPUSH
25802: CALL_OW 88
// DialogueOff ;
25806: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25810: LD_EXP 62
25814: PPUSH
25815: LD_INT 1
25817: PPUSH
25818: CALL_OW 235
// end ; if dec = 2 then
25822: LD_VAR 0 1
25826: PUSH
25827: LD_INT 2
25829: EQUAL
25830: IFFALSE 25883
// begin DialogueOn ;
25832: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25836: LD_EXP 39
25840: PPUSH
25841: LD_STRING D14b-JMM-1
25843: PPUSH
25844: CALL_OW 88
// DialogueOff ;
25848: CALL_OW 7
// wait ( 0 0$1 ) ;
25852: LD_INT 35
25854: PPUSH
25855: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25859: LD_EXP 62
25863: PPUSH
25864: LD_INT 9
25866: PPUSH
25867: LD_INT 2
25869: PPUSH
25870: CALL_OW 111
// AddComHold ( Friend ) ;
25874: LD_EXP 62
25878: PPUSH
25879: CALL_OW 200
// end ; if dec = 3 then
25883: LD_VAR 0 1
25887: PUSH
25888: LD_INT 3
25890: EQUAL
25891: IFFALSE 25977
// begin DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14c-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14c-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14c-JMM-2
25928: PPUSH
25929: CALL_OW 88
// DialogueOff ;
25933: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25937: LD_INT 8
25939: PPUSH
25940: LD_INT 1
25942: PPUSH
25943: LD_INT 2
25945: PPUSH
25946: LD_INT 1
25948: PPUSH
25949: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25953: LD_EXP 62
25957: PPUSH
25958: LD_INT 9
25960: PPUSH
25961: LD_INT 2
25963: PPUSH
25964: CALL_OW 111
// AddComHold ( Friend ) ;
25968: LD_EXP 62
25972: PPUSH
25973: CALL_OW 200
// end ; end ;
25977: PPOPN 1
25979: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25980: LD_INT 9
25982: PPUSH
25983: LD_INT 2
25985: PPUSH
25986: CALL_OW 428
25990: PUSH
25991: LD_EXP 62
25995: EQUAL
25996: PUSH
25997: LD_EXP 62
26001: PPUSH
26002: CALL_OW 255
26006: PUSH
26007: LD_INT 8
26009: EQUAL
26010: AND
26011: IFFALSE 26025
26013: GO 26015
26015: DISABLE
// RemoveUnit ( Friend ) ;
26016: LD_EXP 62
26020: PPUSH
26021: CALL_OW 64
26025: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26026: LD_EXP 14
26030: PUSH
26031: LD_INT 31500
26033: GREATEREQUAL
26034: PUSH
26035: LD_EXP 7
26039: AND
26040: PUSH
26041: LD_EXP 2
26045: AND
26046: IFFALSE 26476
26048: GO 26050
26050: DISABLE
26051: LD_INT 0
26053: PPUSH
26054: PPUSH
26055: PPUSH
// begin missionStage := 7 ;
26056: LD_ADDR_EXP 15
26060: PUSH
26061: LD_INT 7
26063: ST_TO_ADDR
// uc_side = 1 ;
26064: LD_ADDR_OWVAR 20
26068: PUSH
26069: LD_INT 1
26071: ST_TO_ADDR
// uc_nation = 1 ;
26072: LD_ADDR_OWVAR 21
26076: PUSH
26077: LD_INT 1
26079: ST_TO_ADDR
// for i = 1 to 5 do
26080: LD_ADDR_VAR 0 1
26084: PUSH
26085: DOUBLE
26086: LD_INT 1
26088: DEC
26089: ST_TO_ADDR
26090: LD_INT 5
26092: PUSH
26093: FOR_TO
26094: IFFALSE 26190
// begin vc_engine = 3 ;
26096: LD_ADDR_OWVAR 39
26100: PUSH
26101: LD_INT 3
26103: ST_TO_ADDR
// vc_control = 3 ;
26104: LD_ADDR_OWVAR 38
26108: PUSH
26109: LD_INT 3
26111: ST_TO_ADDR
// vc_chassis = 3 ;
26112: LD_ADDR_OWVAR 37
26116: PUSH
26117: LD_INT 3
26119: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26120: LD_ADDR_OWVAR 40
26124: PUSH
26125: LD_INT 5
26127: PUSH
26128: LD_INT 9
26130: PUSH
26131: LD_INT 7
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: LIST
26138: PUSH
26139: LD_INT 1
26141: PPUSH
26142: LD_INT 3
26144: PPUSH
26145: CALL_OW 12
26149: ARRAY
26150: ST_TO_ADDR
// veh = CreateVehicle ;
26151: LD_ADDR_VAR 0 2
26155: PUSH
26156: CALL_OW 45
26160: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26161: LD_VAR 0 2
26165: PPUSH
26166: LD_INT 1
26168: PPUSH
26169: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26173: LD_VAR 0 2
26177: PPUSH
26178: LD_INT 19
26180: PPUSH
26181: LD_INT 0
26183: PPUSH
26184: CALL_OW 49
// end ;
26188: GO 26093
26190: POP
26191: POP
// vc_engine = 3 ;
26192: LD_ADDR_OWVAR 39
26196: PUSH
26197: LD_INT 3
26199: ST_TO_ADDR
// vc_control = 1 ;
26200: LD_ADDR_OWVAR 38
26204: PUSH
26205: LD_INT 1
26207: ST_TO_ADDR
// vc_chassis = 3 ;
26208: LD_ADDR_OWVAR 37
26212: PUSH
26213: LD_INT 3
26215: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26216: LD_ADDR_OWVAR 40
26220: PUSH
26221: LD_INT 5
26223: PUSH
26224: LD_INT 9
26226: PUSH
26227: LD_INT 7
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: LIST
26234: PUSH
26235: LD_INT 1
26237: PPUSH
26238: LD_INT 3
26240: PPUSH
26241: CALL_OW 12
26245: ARRAY
26246: ST_TO_ADDR
// vehG = CreateVehicle ;
26247: LD_ADDR_VAR 0 3
26251: PUSH
26252: CALL_OW 45
26256: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26257: LD_VAR 0 3
26261: PPUSH
26262: LD_INT 1
26264: PPUSH
26265: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26269: LD_VAR 0 3
26273: PPUSH
26274: LD_INT 19
26276: PPUSH
26277: LD_INT 0
26279: PPUSH
26280: CALL_OW 49
// if JMMGirl = 1 then
26284: LD_EXP 7
26288: PUSH
26289: LD_INT 1
26291: EQUAL
26292: IFFALSE 26348
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26294: LD_ADDR_EXP 40
26298: PUSH
26299: LD_STRING Joan
26301: PPUSH
26302: LD_INT 1
26304: PPUSH
26305: LD_STRING 14_
26307: PPUSH
26308: CALL 64741 0 3
26312: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26313: LD_EXP 40
26317: PPUSH
26318: LD_VAR 0 3
26322: PPUSH
26323: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26327: LD_VAR 0 3
26331: PPUSH
26332: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26336: LD_EXP 40
26340: PPUSH
26341: LD_STRING D10BW-Joan-1
26343: PPUSH
26344: CALL_OW 94
// end ; if JMMGirl = 2 then
26348: LD_EXP 7
26352: PUSH
26353: LD_INT 2
26355: EQUAL
26356: IFFALSE 26412
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26358: LD_ADDR_EXP 42
26362: PUSH
26363: LD_STRING Lisa
26365: PPUSH
26366: LD_INT 1
26368: PPUSH
26369: LD_STRING 14_
26371: PPUSH
26372: CALL 64741 0 3
26376: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26377: LD_EXP 42
26381: PPUSH
26382: LD_VAR 0 3
26386: PPUSH
26387: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26391: LD_VAR 0 3
26395: PPUSH
26396: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26400: LD_EXP 42
26404: PPUSH
26405: LD_STRING D10BW-Lisa-1
26407: PPUSH
26408: CALL_OW 94
// end ; if JMMGirl = 3 then
26412: LD_EXP 7
26416: PUSH
26417: LD_INT 3
26419: EQUAL
26420: IFFALSE 26476
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26422: LD_ADDR_EXP 54
26426: PUSH
26427: LD_STRING Connie
26429: PPUSH
26430: LD_INT 1
26432: PPUSH
26433: LD_STRING 14_
26435: PPUSH
26436: CALL 64741 0 3
26440: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26441: LD_EXP 54
26445: PPUSH
26446: LD_VAR 0 3
26450: PPUSH
26451: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26455: LD_VAR 0 3
26459: PPUSH
26460: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26464: LD_EXP 54
26468: PPUSH
26469: LD_STRING D10BW-Con-1
26471: PPUSH
26472: CALL_OW 94
// end ; end ;
26476: PPOPN 3
26478: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26479: LD_EXP 14
26483: PUSH
26484: LD_INT 94500
26486: GREATEREQUAL
26487: IFFALSE 26899
26489: GO 26491
26491: DISABLE
26492: LD_INT 0
26494: PPUSH
26495: PPUSH
26496: PPUSH
// begin tmp := PrepareStevensSquad ;
26497: LD_ADDR_VAR 0 3
26501: PUSH
26502: CALL 2197 0 0
26506: ST_TO_ADDR
// if not tmp then
26507: LD_VAR 0 3
26511: NOT
26512: IFFALSE 26516
// exit ;
26514: GO 26899
// uc_side := 1 ;
26516: LD_ADDR_OWVAR 20
26520: PUSH
26521: LD_INT 1
26523: ST_TO_ADDR
// uc_nation := 1 ;
26524: LD_ADDR_OWVAR 21
26528: PUSH
26529: LD_INT 1
26531: ST_TO_ADDR
// for i in tmp do
26532: LD_ADDR_VAR 0 1
26536: PUSH
26537: LD_VAR 0 3
26541: PUSH
26542: FOR_IN
26543: IFFALSE 26640
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26545: LD_INT 3
26547: PPUSH
26548: LD_INT 3
26550: PPUSH
26551: LD_INT 1
26553: PPUSH
26554: LD_INT 5
26556: PUSH
26557: LD_INT 9
26559: PUSH
26560: LD_INT 7
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 1
26570: PPUSH
26571: LD_INT 3
26573: PPUSH
26574: CALL_OW 12
26578: ARRAY
26579: PPUSH
26580: LD_INT 40
26582: PPUSH
26583: CALL 71856 0 5
// veh := CreateVehicle ;
26587: LD_ADDR_VAR 0 2
26591: PUSH
26592: CALL_OW 45
26596: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26597: LD_VAR 0 2
26601: PPUSH
26602: LD_INT 1
26604: PPUSH
26605: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26609: LD_VAR 0 2
26613: PPUSH
26614: LD_INT 19
26616: PPUSH
26617: LD_INT 0
26619: PPUSH
26620: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26624: LD_VAR 0 1
26628: PPUSH
26629: LD_VAR 0 2
26633: PPUSH
26634: CALL_OW 52
// end ;
26638: GO 26542
26640: POP
26641: POP
// missionStage := 8 ;
26642: LD_ADDR_EXP 15
26646: PUSH
26647: LD_INT 8
26649: ST_TO_ADDR
// DialogueOn ;
26650: CALL_OW 6
// if Stevens then
26654: LD_EXP 41
26658: IFFALSE 26772
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26660: LD_EXP 41
26664: PPUSH
26665: CALL_OW 310
26669: PPUSH
26670: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26674: LD_EXP 41
26678: PPUSH
26679: LD_STRING D8-Huck-1
26681: PPUSH
26682: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26686: LD_EXP 39
26690: PPUSH
26691: LD_STRING D8-JMM-1
26693: PPUSH
26694: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26698: LD_EXP 41
26702: PPUSH
26703: LD_STRING D8-Huck-2
26705: PPUSH
26706: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26710: LD_EXP 39
26714: PPUSH
26715: LD_STRING D8-JMM-2
26717: PPUSH
26718: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26722: LD_EXP 41
26726: PPUSH
26727: LD_STRING D8-Huck-3
26729: PPUSH
26730: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26734: LD_EXP 39
26738: PPUSH
26739: LD_STRING D8-JMM-3
26741: PPUSH
26742: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26746: LD_EXP 41
26750: PPUSH
26751: LD_STRING D8-Huck-4
26753: PPUSH
26754: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26758: LD_EXP 39
26762: PPUSH
26763: LD_STRING D8-JMM-4
26765: PPUSH
26766: CALL_OW 88
// end else
26770: GO 26882
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26772: LD_EXP 55
26776: PPUSH
26777: CALL_OW 310
26781: PPUSH
26782: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26786: LD_EXP 55
26790: PPUSH
26791: LD_STRING D8-Huck-1
26793: PPUSH
26794: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26798: LD_EXP 39
26802: PPUSH
26803: LD_STRING D8-JMM-1a
26805: PPUSH
26806: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26810: LD_EXP 55
26814: PPUSH
26815: LD_STRING D8-Huck-2
26817: PPUSH
26818: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26822: LD_EXP 39
26826: PPUSH
26827: LD_STRING D8-JMM-2
26829: PPUSH
26830: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26834: LD_EXP 55
26838: PPUSH
26839: LD_STRING D8-Huck-3
26841: PPUSH
26842: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26846: LD_EXP 39
26850: PPUSH
26851: LD_STRING D8-JMM-3
26853: PPUSH
26854: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26858: LD_EXP 55
26862: PPUSH
26863: LD_STRING D8-Huck-4
26865: PPUSH
26866: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26870: LD_EXP 39
26874: PPUSH
26875: LD_STRING D8-JMM-4
26877: PPUSH
26878: CALL_OW 88
// end ; DialogueOff ;
26882: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26886: LD_INT 25
26888: PPUSH
26889: LD_INT 1
26891: PPUSH
26892: LD_INT 1
26894: PPUSH
26895: CALL_OW 322
// end ;
26899: PPOPN 3
26901: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26902: LD_INT 1
26904: PPUSH
26905: LD_EXP 71
26909: PPUSH
26910: CALL_OW 292
26914: IFFALSE 27165
26916: GO 26918
26918: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26919: LD_EXP 71
26923: PPUSH
26924: CALL_OW 87
// DialogueOn ;
26928: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26932: LD_EXP 39
26936: PPUSH
26937: LD_STRING D10nB-JMM-1
26939: PPUSH
26940: CALL_OW 88
// if BurlakStatus = 1 then
26944: LD_EXP 9
26948: PUSH
26949: LD_INT 1
26951: EQUAL
26952: IFFALSE 26966
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26954: LD_EXP 70
26958: PPUSH
26959: LD_STRING D10nB-Vse-1a
26961: PPUSH
26962: CALL_OW 94
// end ; if BurlakStatus = 0 then
26966: LD_EXP 9
26970: PUSH
26971: LD_INT 0
26973: EQUAL
26974: IFFALSE 26988
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26976: LD_EXP 70
26980: PPUSH
26981: LD_STRING D10nB-Vse-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D10nB-JMM-2
26995: PPUSH
26996: CALL_OW 88
// if KappaStatus then
27000: LD_EXP 2
27004: IFFALSE 27018
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27006: LD_EXP 70
27010: PPUSH
27011: LD_STRING D10nB-Vse-5a
27013: PPUSH
27014: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27018: LD_EXP 2
27022: NOT
27023: PUSH
27024: LD_EXP 6
27028: PUSH
27029: LD_INT 0
27031: EQUAL
27032: AND
27033: IFFALSE 27161
// begin if JMMGirl = 1 then
27035: LD_EXP 7
27039: PUSH
27040: LD_INT 1
27042: EQUAL
27043: IFFALSE 27093
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27045: LD_EXP 70
27049: PPUSH
27050: LD_STRING D10nB-Vse-2
27052: PPUSH
27053: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27057: LD_EXP 39
27061: PPUSH
27062: LD_STRING D10nB-JMM-3
27064: PPUSH
27065: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27069: LD_EXP 70
27073: PPUSH
27074: LD_STRING D10nB-Vse-3
27076: PPUSH
27077: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27081: LD_EXP 39
27085: PPUSH
27086: LD_STRING D10nB-JMM-4
27088: PPUSH
27089: CALL_OW 88
// end ; if JMMGirl = 2 then
27093: LD_EXP 7
27097: PUSH
27098: LD_INT 2
27100: EQUAL
27101: IFFALSE 27127
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27103: LD_EXP 70
27107: PPUSH
27108: LD_STRING D10nB-Vse-4
27110: PPUSH
27111: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27115: LD_EXP 39
27119: PPUSH
27120: LD_STRING D10nB-JMM-5
27122: PPUSH
27123: CALL_OW 88
// end ; if JMMGirl = 3 then
27127: LD_EXP 7
27131: PUSH
27132: LD_INT 3
27134: EQUAL
27135: IFFALSE 27161
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27137: LD_EXP 70
27141: PPUSH
27142: LD_STRING D10nB-Vse-5
27144: PPUSH
27145: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27149: LD_EXP 39
27153: PPUSH
27154: LD_STRING D10nB-JMM-6
27156: PPUSH
27157: CALL_OW 88
// end ; end ; DialogueOff ;
27161: CALL_OW 7
// end ;
27165: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27166: LD_EXP 14
27170: PUSH
27171: LD_INT 115500
27173: GREATEREQUAL
27174: IFFALSE 27550
27176: GO 27178
27178: DISABLE
27179: LD_INT 0
27181: PPUSH
// begin missionStage := 10 ;
27182: LD_ADDR_EXP 15
27186: PUSH
27187: LD_INT 10
27189: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27190: LD_ADDR_VAR 0 1
27194: PUSH
27195: LD_INT 22
27197: PUSH
27198: LD_INT 1
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 23
27207: PUSH
27208: LD_INT 1
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: LD_INT 26
27217: PUSH
27218: LD_INT 1
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PUSH
27225: LD_INT 3
27227: PUSH
27228: LD_INT 25
27230: PUSH
27231: LD_INT 12
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 3
27244: PUSH
27245: LD_INT 25
27247: PUSH
27248: LD_INT 16
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: PPUSH
27266: CALL_OW 69
27270: PUSH
27271: LD_EXP 39
27275: PUSH
27276: LD_EXP 60
27280: PUSH
27281: LD_EXP 41
27285: PUSH
27286: LD_EXP 55
27290: PUSH
27291: LD_EXP 42
27295: PUSH
27296: LD_EXP 43
27300: PUSH
27301: LD_EXP 44
27305: PUSH
27306: LD_EXP 45
27310: PUSH
27311: LD_EXP 46
27315: PUSH
27316: LD_EXP 47
27320: PUSH
27321: LD_EXP 48
27325: PUSH
27326: LD_EXP 49
27330: PUSH
27331: LD_EXP 50
27335: PUSH
27336: LD_EXP 51
27340: PUSH
27341: LD_EXP 52
27345: PUSH
27346: LD_EXP 53
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: DIFF
27369: ST_TO_ADDR
// if not tmp and Brown then
27370: LD_VAR 0 1
27374: NOT
27375: PUSH
27376: LD_EXP 47
27380: AND
27381: IFFALSE 27396
// tmp := [ Brown ] ;
27383: LD_ADDR_VAR 0 1
27387: PUSH
27388: LD_EXP 47
27392: PUSH
27393: EMPTY
27394: LIST
27395: ST_TO_ADDR
// DialogueOn ;
27396: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27400: LD_VAR 0 1
27404: PUSH
27405: LD_INT 1
27407: ARRAY
27408: PPUSH
27409: LD_STRING D11-Sol1-1
27411: PPUSH
27412: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27416: LD_EXP 64
27420: PPUSH
27421: LD_STRING D11-Pla-1
27423: PPUSH
27424: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27428: LD_EXP 65
27432: PPUSH
27433: LD_STRING D11-Kov-1
27435: PPUSH
27436: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27440: LD_EXP 64
27444: PPUSH
27445: LD_STRING D11-Pla-2
27447: PPUSH
27448: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27452: LD_VAR 0 1
27456: PUSH
27457: LD_INT 1
27459: ARRAY
27460: PPUSH
27461: LD_STRING D11-Sol1-2
27463: PPUSH
27464: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27468: LD_EXP 39
27472: PPUSH
27473: LD_STRING D11-JMM-2
27475: PPUSH
27476: CALL_OW 88
// DialogueOff ;
27480: CALL_OW 7
// allowBehemothConstruct := true ;
27484: LD_ADDR_EXP 25
27488: PUSH
27489: LD_INT 1
27491: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27492: LD_STRING M4
27494: PPUSH
27495: CALL_OW 337
// BuildBehemoths ;
27499: CALL 7627 0 0
// repeat wait ( 15 15$00 ) ;
27503: LD_INT 31500
27505: PPUSH
27506: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27510: LD_EXP 27
27514: IFFALSE 27518
// break ;
27516: GO 27550
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27518: LD_INT 267
27520: PPUSH
27521: CALL_OW 274
27525: PPUSH
27526: LD_INT 1
27528: PPUSH
27529: CALL_OW 275
27533: PUSH
27534: LD_INT 1000
27536: GREATEREQUAL
27537: IFFALSE 27543
// BuildBehemoths ;
27539: CALL 7627 0 0
// until not behemothBuilders ;
27543: LD_EXP 73
27547: NOT
27548: IFFALSE 27503
// end ;
27550: PPOPN 1
27552: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27553: LD_EXP 73
27557: NOT
27558: PUSH
27559: LD_EXP 28
27563: NOT
27564: AND
27565: PUSH
27566: LD_EXP 25
27570: AND
27571: IFFALSE 27591
27573: GO 27575
27575: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27576: LD_STRING M4a
27578: PPUSH
27579: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27583: LD_ADDR_EXP 27
27587: PUSH
27588: LD_INT 1
27590: ST_TO_ADDR
// end ;
27591: END
// every 0 0$1 trigger behemothDone do
27592: LD_EXP 28
27596: IFFALSE 27608
27598: GO 27600
27600: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27601: LD_STRING M4b
27603: PPUSH
27604: CALL_OW 337
27608: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27609: LD_EXP 29
27613: NOT
27614: IFFALSE 27810
27616: GO 27618
27618: DISABLE
27619: LD_INT 0
27621: PPUSH
27622: PPUSH
// begin enable ;
27623: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27624: LD_ADDR_VAR 0 1
27628: PUSH
27629: LD_INT 3
27631: PPUSH
27632: CALL 107652 0 1
27636: ST_TO_ADDR
// if not tmp and not behemothDone then
27637: LD_VAR 0 1
27641: NOT
27642: PUSH
27643: LD_EXP 28
27647: NOT
27648: AND
27649: IFFALSE 27685
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27651: LD_ADDR_VAR 0 1
27655: PUSH
27656: LD_INT 22
27658: PUSH
27659: LD_INT 3
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 30
27668: PUSH
27669: LD_INT 37
27671: PUSH
27672: EMPTY
27673: LIST
27674: LIST
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: PPUSH
27680: CALL_OW 69
27684: ST_TO_ADDR
// if not tmp then
27685: LD_VAR 0 1
27689: NOT
27690: IFFALSE 27694
// exit ;
27692: GO 27810
// for i in tmp do
27694: LD_ADDR_VAR 0 2
27698: PUSH
27699: LD_VAR 0 1
27703: PUSH
27704: FOR_IN
27705: IFFALSE 27808
// if See ( 1 , i ) then
27707: LD_INT 1
27709: PPUSH
27710: LD_VAR 0 2
27714: PPUSH
27715: CALL_OW 292
27719: IFFALSE 27806
// begin if GetType ( i ) = unit_building then
27721: LD_VAR 0 2
27725: PPUSH
27726: CALL_OW 247
27730: PUSH
27731: LD_INT 3
27733: EQUAL
27734: IFFALSE 27772
// begin CenterNowOnUnits ( i ) ;
27736: LD_VAR 0 2
27740: PPUSH
27741: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27745: LD_EXP 39
27749: PPUSH
27750: LD_STRING D17a-JMM-1
27752: PPUSH
27753: CALL_OW 88
// seeBehemoth := true ;
27757: LD_ADDR_EXP 29
27761: PUSH
27762: LD_INT 1
27764: ST_TO_ADDR
// disable ;
27765: DISABLE
// exit ;
27766: POP
27767: POP
27768: GO 27810
// end else
27770: GO 27806
// begin CenterNowOnUnits ( i ) ;
27772: LD_VAR 0 2
27776: PPUSH
27777: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27781: LD_EXP 39
27785: PPUSH
27786: LD_STRING D17b-JMM-1
27788: PPUSH
27789: CALL_OW 88
// seeBehemoth := true ;
27793: LD_ADDR_EXP 29
27797: PUSH
27798: LD_INT 1
27800: ST_TO_ADDR
// disable ;
27801: DISABLE
// exit ;
27802: POP
27803: POP
27804: GO 27810
// end ; end ;
27806: GO 27704
27808: POP
27809: POP
// end ;
27810: PPOPN 2
27812: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27813: LD_EXP 14
27817: PUSH
27818: LD_INT 116550
27820: GREATEREQUAL
27821: IFFALSE 28997
27823: GO 27825
27825: DISABLE
27826: LD_INT 0
27828: PPUSH
27829: PPUSH
27830: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27831: LD_INT 2
27833: PPUSH
27834: LD_INT 23
27836: PUSH
27837: LD_INT 3
27839: PUSH
27840: LD_INT 3
27842: PUSH
27843: LD_INT 48
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: PUSH
27852: EMPTY
27853: LIST
27854: PPUSH
27855: CALL 58397 0 2
// repeat wait ( 0 0$1 ) ;
27859: LD_INT 35
27861: PPUSH
27862: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27866: LD_INT 22
27868: PUSH
27869: LD_INT 3
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 34
27878: PUSH
27879: LD_INT 48
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: PPUSH
27890: CALL_OW 69
27894: IFFALSE 27859
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27896: LD_ADDR_VAR 0 1
27900: PUSH
27901: LD_INT 22
27903: PUSH
27904: LD_INT 3
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 34
27913: PUSH
27914: LD_INT 48
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PPUSH
27925: CALL_OW 69
27929: PUSH
27930: LD_INT 1
27932: ARRAY
27933: ST_TO_ADDR
// missionStage := 12 ;
27934: LD_ADDR_EXP 15
27938: PUSH
27939: LD_INT 12
27941: ST_TO_ADDR
// platonovHasBomb := true ;
27942: LD_ADDR_EXP 30
27946: PUSH
27947: LD_INT 1
27949: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27950: LD_VAR 0 1
27954: PPUSH
27955: LD_INT 181
27957: PPUSH
27958: LD_INT 86
27960: PPUSH
27961: CALL_OW 171
// AddComHold ( bomb ) ;
27965: LD_VAR 0 1
27969: PPUSH
27970: CALL_OW 200
// wait ( 0 0$10 ) ;
27974: LD_INT 350
27976: PPUSH
27977: CALL_OW 67
// DialogueOn ;
27981: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27985: LD_EXP 64
27989: PPUSH
27990: LD_STRING D15-Pla-1
27992: PPUSH
27993: CALL_OW 94
// dec = Query ( Q15a ) ;
27997: LD_ADDR_VAR 0 2
28001: PUSH
28002: LD_STRING Q15a
28004: PPUSH
28005: CALL_OW 97
28009: ST_TO_ADDR
// if dec = 1 then
28010: LD_VAR 0 2
28014: PUSH
28015: LD_INT 1
28017: EQUAL
28018: IFFALSE 28041
// begin Say ( JMM , D15a-JMM-1 ) ;
28020: LD_EXP 39
28024: PPUSH
28025: LD_STRING D15a-JMM-1
28027: PPUSH
28028: CALL_OW 88
// YouLost ( Surrender ) ;
28032: LD_STRING Surrender
28034: PPUSH
28035: CALL_OW 104
// exit ;
28039: GO 28997
// end ; if dec = 2 then
28041: LD_VAR 0 2
28045: PUSH
28046: LD_INT 2
28048: EQUAL
28049: IFFALSE 28118
// begin Say ( JMM , D15b-JMM-1 ) ;
28051: LD_EXP 39
28055: PPUSH
28056: LD_STRING D15b-JMM-1
28058: PPUSH
28059: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28063: LD_EXP 64
28067: PPUSH
28068: LD_STRING D15b-Pla-1
28070: PPUSH
28071: CALL_OW 94
// DialogueOff ;
28075: CALL_OW 7
// wait ( 3 3$00 ) ;
28079: LD_INT 6300
28081: PPUSH
28082: CALL_OW 67
// DialogueOn ;
28086: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28090: LD_EXP 39
28094: PPUSH
28095: LD_STRING D15d-JMM-1a
28097: PPUSH
28098: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28102: LD_EXP 64
28106: PPUSH
28107: LD_STRING D15d-Pla-1
28109: PPUSH
28110: CALL_OW 94
// DialogueOff ;
28114: CALL_OW 7
// end ; if dec = 3 then
28118: LD_VAR 0 2
28122: PUSH
28123: LD_INT 3
28125: EQUAL
28126: IFFALSE 28180
// begin Say ( JMM , D15c-JMM-1 ) ;
28128: LD_EXP 39
28132: PPUSH
28133: LD_STRING D15c-JMM-1
28135: PPUSH
28136: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28140: LD_EXP 64
28144: PPUSH
28145: LD_STRING D15c-Pla-1
28147: PPUSH
28148: CALL_OW 94
// DialogueOff ;
28152: CALL_OW 7
// wait ( 0 0$15 ) ;
28156: LD_INT 525
28158: PPUSH
28159: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28163: LD_VAR 0 1
28167: PPUSH
28168: LD_INT 60
28170: PPUSH
28171: LD_INT 95
28173: PPUSH
28174: CALL_OW 116
// exit ;
28178: GO 28997
// end ; if dec = 4 then
28180: LD_VAR 0 2
28184: PUSH
28185: LD_INT 4
28187: EQUAL
28188: IFFALSE 28218
// begin Say ( JMM , D15d-JMM-1 ) ;
28190: LD_EXP 39
28194: PPUSH
28195: LD_STRING D15d-JMM-1
28197: PPUSH
28198: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28202: LD_EXP 64
28206: PPUSH
28207: LD_STRING D15d-Pla-1
28209: PPUSH
28210: CALL_OW 94
// DialogueOff ;
28214: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28218: LD_EXP 62
28222: PPUSH
28223: CALL_OW 302
28227: PUSH
28228: LD_EXP 62
28232: PPUSH
28233: CALL_OW 255
28237: PUSH
28238: LD_INT 1
28240: EQUAL
28241: AND
28242: PUSH
28243: LD_INT 22
28245: PUSH
28246: LD_INT 1
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 34
28255: PUSH
28256: LD_INT 8
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: EMPTY
28264: LIST
28265: LIST
28266: PPUSH
28267: CALL_OW 69
28271: NOT
28272: AND
28273: IFFALSE 28898
// begin SetSide ( Friend , 8 ) ;
28275: LD_EXP 62
28279: PPUSH
28280: LD_INT 8
28282: PPUSH
28283: CALL_OW 235
// if IsInUnit ( Friend ) then
28287: LD_EXP 62
28291: PPUSH
28292: CALL_OW 310
28296: IFFALSE 28307
// ComExitBuilding ( Friend ) ;
28298: LD_EXP 62
28302: PPUSH
28303: CALL_OW 122
// if IsDriver ( Friend ) then
28307: LD_EXP 62
28311: PPUSH
28312: CALL 105329 0 1
28316: IFFALSE 28327
// ComExitVehicle ( Friend ) ;
28318: LD_EXP 62
28322: PPUSH
28323: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28327: LD_EXP 62
28331: PPUSH
28332: LD_INT 9
28334: PPUSH
28335: LD_INT 2
28337: PPUSH
28338: CALL_OW 171
// wait ( 0 0$05 ) ;
28342: LD_INT 175
28344: PPUSH
28345: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28349: LD_EXP 62
28353: PPUSH
28354: CALL_OW 87
// DialogueOn ;
28358: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28362: LD_EXP 39
28366: PPUSH
28367: LD_STRING D16-JMM-1
28369: PPUSH
28370: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28374: LD_EXP 62
28378: PPUSH
28379: LD_STRING D16-Friend-1
28381: PPUSH
28382: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28386: LD_EXP 39
28390: PPUSH
28391: LD_STRING D16-JMM-2
28393: PPUSH
28394: CALL_OW 88
// DialogueOff ;
28398: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28402: LD_EXP 62
28406: PPUSH
28407: LD_INT 1
28409: PPUSH
28410: CALL_OW 235
// ComHold ( Friend ) ;
28414: LD_EXP 62
28418: PPUSH
28419: CALL_OW 140
// wait ( 0 0$20 ) ;
28423: LD_INT 700
28425: PPUSH
28426: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28430: LD_EXP 62
28434: PPUSH
28435: LD_INT 9
28437: PPUSH
28438: LD_INT 2
28440: PPUSH
28441: CALL_OW 297
28445: PUSH
28446: LD_INT 30
28448: LESS
28449: IFFALSE 28518
// begin SetSide ( Friend , 8 ) ;
28451: LD_EXP 62
28455: PPUSH
28456: LD_INT 8
28458: PPUSH
28459: CALL_OW 235
// if IsInUnit ( Friend ) then
28463: LD_EXP 62
28467: PPUSH
28468: CALL_OW 310
28472: IFFALSE 28483
// ComExitBuilding ( Friend ) ;
28474: LD_EXP 62
28478: PPUSH
28479: CALL_OW 122
// if IsDriver ( Friend ) then
28483: LD_EXP 62
28487: PPUSH
28488: CALL 105329 0 1
28492: IFFALSE 28503
// ComExitVehicle ( Friend ) ;
28494: LD_EXP 62
28498: PPUSH
28499: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28503: LD_EXP 62
28507: PPUSH
28508: LD_INT 9
28510: PPUSH
28511: LD_INT 2
28513: PPUSH
28514: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28518: LD_INT 1050
28520: PPUSH
28521: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28525: LD_INT 22
28527: PUSH
28528: LD_INT 1
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 34
28537: PUSH
28538: LD_INT 8
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PPUSH
28549: CALL_OW 69
28553: NOT
28554: IFFALSE 28876
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28556: LD_ADDR_VAR 0 3
28560: PUSH
28561: LD_INT 22
28563: PUSH
28564: LD_INT 1
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 26
28573: PUSH
28574: LD_INT 1
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 3
28583: PUSH
28584: LD_INT 25
28586: PUSH
28587: LD_INT 12
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 25
28596: PUSH
28597: LD_INT 16
28599: PUSH
28600: EMPTY
28601: LIST
28602: LIST
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: LIST
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: LIST
28613: PPUSH
28614: CALL_OW 69
28618: PUSH
28619: LD_EXP 39
28623: PUSH
28624: LD_EXP 41
28628: PUSH
28629: LD_EXP 55
28633: PUSH
28634: LD_EXP 42
28638: PUSH
28639: LD_EXP 43
28643: PUSH
28644: LD_EXP 44
28648: PUSH
28649: LD_EXP 45
28653: PUSH
28654: LD_EXP 46
28658: PUSH
28659: LD_EXP 47
28663: PUSH
28664: LD_EXP 48
28668: PUSH
28669: LD_EXP 49
28673: PUSH
28674: LD_EXP 50
28678: PUSH
28679: LD_EXP 51
28683: PUSH
28684: LD_EXP 52
28688: PUSH
28689: LD_EXP 53
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: DIFF
28711: ST_TO_ADDR
// DialogueOn ;
28712: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28716: LD_EXP 64
28720: PPUSH
28721: LD_STRING D16a-Pla-1
28723: PPUSH
28724: CALL_OW 94
// if Stevens then
28728: LD_EXP 41
28732: IFFALSE 28748
// Say ( Stevens , D16a-Huck-1 ) else
28734: LD_EXP 41
28738: PPUSH
28739: LD_STRING D16a-Huck-1
28741: PPUSH
28742: CALL_OW 88
28746: GO 28790
// if Baker then
28748: LD_EXP 55
28752: IFFALSE 28768
// Say ( Baker , D16a-Huck-1 ) else
28754: LD_EXP 55
28758: PPUSH
28759: LD_STRING D16a-Huck-1
28761: PPUSH
28762: CALL_OW 88
28766: GO 28790
// if tmp then
28768: LD_VAR 0 3
28772: IFFALSE 28790
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28774: LD_VAR 0 3
28778: PUSH
28779: LD_INT 1
28781: ARRAY
28782: PPUSH
28783: LD_STRING D16a-Sol1-1
28785: PPUSH
28786: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28790: LD_EXP 62
28794: PPUSH
28795: CALL_OW 255
28799: PUSH
28800: LD_INT 8
28802: EQUAL
28803: IFFALSE 28819
// Say ( JMM , D16a-JMM-1 ) else
28805: LD_EXP 39
28809: PPUSH
28810: LD_STRING D16a-JMM-1
28812: PPUSH
28813: CALL_OW 88
28817: GO 28855
// begin Say ( JMM , D16a-JMM-1a ) ;
28819: LD_EXP 39
28823: PPUSH
28824: LD_STRING D16a-JMM-1a
28826: PPUSH
28827: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28831: LD_EXP 62
28835: PPUSH
28836: LD_STRING D16a-Friend-1
28838: PPUSH
28839: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28843: LD_EXP 62
28847: PPUSH
28848: LD_INT 3
28850: PPUSH
28851: CALL_OW 235
// end ; DialogueOff ;
28855: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28859: LD_VAR 0 1
28863: PPUSH
28864: LD_INT 60
28866: PPUSH
28867: LD_INT 95
28869: PPUSH
28870: CALL_OW 116
// end else
28874: GO 28896
// begin DialogueOn ;
28876: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28880: LD_EXP 64
28884: PPUSH
28885: LD_STRING D16c-Pla-
28887: PPUSH
28888: CALL_OW 94
// DialogueOff ;
28892: CALL_OW 7
// end ; end else
28896: GO 28997
// begin wait ( 3 3$00 ) ;
28898: LD_INT 6300
28900: PPUSH
28901: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28905: LD_INT 22
28907: PUSH
28908: LD_INT 1
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 34
28917: PUSH
28918: LD_INT 8
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: EMPTY
28926: LIST
28927: LIST
28928: PPUSH
28929: CALL_OW 69
28933: NOT
28934: IFFALSE 28977
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28936: LD_EXP 64
28940: PPUSH
28941: LD_STRING D16b-Pla-1
28943: PPUSH
28944: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28948: LD_EXP 39
28952: PPUSH
28953: LD_STRING D16b-JMM-
28955: PPUSH
28956: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28960: LD_VAR 0 1
28964: PPUSH
28965: LD_INT 60
28967: PPUSH
28968: LD_INT 95
28970: PPUSH
28971: CALL_OW 116
// end else
28975: GO 28997
// begin DialogueOn ;
28977: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28981: LD_EXP 64
28985: PPUSH
28986: LD_STRING D16c-Pla-
28988: PPUSH
28989: CALL_OW 94
// DialogueOff ;
28993: CALL_OW 7
// end ; end ; end ;
28997: PPOPN 3
28999: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29000: LD_EXP 14
29004: PUSH
29005: LD_INT 126000
29007: GREATEREQUAL
29008: PUSH
29009: LD_EXP 23
29013: NOT
29014: AND
29015: PUSH
29016: LD_EXP 74
29020: PPUSH
29021: CALL_OW 302
29025: AND
29026: IFFALSE 29384
29028: GO 29030
29030: DISABLE
29031: LD_INT 0
29033: PPUSH
// begin missionStage = 11 ;
29034: LD_ADDR_EXP 15
29038: PUSH
29039: LD_INT 11
29041: ST_TO_ADDR
// DialogueOn ;
29042: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29046: LD_EXP 74
29050: PPUSH
29051: LD_STRING D9-Roth-1
29053: PPUSH
29054: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29058: LD_EXP 39
29062: PPUSH
29063: LD_STRING D9-JMM-1
29065: PPUSH
29066: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29070: LD_EXP 74
29074: PPUSH
29075: LD_STRING D9-Roth-2
29077: PPUSH
29078: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29082: LD_EXP 74
29086: PPUSH
29087: LD_STRING D9-Roth-2a
29089: PPUSH
29090: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29094: LD_EXP 64
29098: PPUSH
29099: LD_STRING D9-Pla-2
29101: PPUSH
29102: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29106: LD_EXP 74
29110: PPUSH
29111: LD_STRING D9-Roth-3
29113: PPUSH
29114: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29118: LD_EXP 64
29122: PPUSH
29123: LD_STRING D9-Pla-3
29125: PPUSH
29126: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29130: LD_EXP 74
29134: PPUSH
29135: LD_STRING D9-Roth-4
29137: PPUSH
29138: CALL_OW 94
// dec = Query ( Q9 ) ;
29142: LD_ADDR_VAR 0 1
29146: PUSH
29147: LD_STRING Q9
29149: PPUSH
29150: CALL_OW 97
29154: ST_TO_ADDR
// if dec = 1 then
29155: LD_VAR 0 1
29159: PUSH
29160: LD_INT 1
29162: EQUAL
29163: IFFALSE 29177
// SayRadio ( Roth , D9a-Roth-1 ) ;
29165: LD_EXP 74
29169: PPUSH
29170: LD_STRING D9a-Roth-1
29172: PPUSH
29173: CALL_OW 94
// if dec = 2 then
29177: LD_VAR 0 1
29181: PUSH
29182: LD_INT 2
29184: EQUAL
29185: IFFALSE 29211
// begin Say ( JMM , D9b-JMM-1 ) ;
29187: LD_EXP 39
29191: PPUSH
29192: LD_STRING D9b-JMM-1
29194: PPUSH
29195: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29199: LD_EXP 74
29203: PPUSH
29204: LD_STRING D9b-Roth-1
29206: PPUSH
29207: CALL_OW 94
// end ; if dec = 3 then
29211: LD_VAR 0 1
29215: PUSH
29216: LD_INT 3
29218: EQUAL
29219: IFFALSE 29281
// begin Say ( JMM , D9c-JMM-1 ) ;
29221: LD_EXP 39
29225: PPUSH
29226: LD_STRING D9c-JMM-1
29228: PPUSH
29229: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29233: LD_EXP 74
29237: PPUSH
29238: LD_STRING D9c-Roth-1
29240: PPUSH
29241: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29245: LD_EXP 39
29249: PPUSH
29250: LD_STRING D9c-JMM-2
29252: PPUSH
29253: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29257: LD_EXP 74
29261: PPUSH
29262: LD_STRING D9c-Roth-2
29264: PPUSH
29265: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29269: LD_EXP 39
29273: PPUSH
29274: LD_STRING D9c-JMM-3
29276: PPUSH
29277: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29281: LD_EXP 74
29285: PPUSH
29286: LD_STRING D9c-Roth-3
29288: PPUSH
29289: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29293: LD_EXP 74
29297: PPUSH
29298: LD_STRING D9cont-Roth-1
29300: PPUSH
29301: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29305: LD_EXP 39
29309: PPUSH
29310: LD_STRING D9cont-JMM-1
29312: PPUSH
29313: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29317: LD_EXP 74
29321: PPUSH
29322: LD_STRING D9cont-Roth-2
29324: PPUSH
29325: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29329: LD_EXP 39
29333: PPUSH
29334: LD_STRING D9cont-JMM-2
29336: PPUSH
29337: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29341: LD_EXP 74
29345: PPUSH
29346: LD_STRING D9cont-Roth-3
29348: PPUSH
29349: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29353: LD_EXP 39
29357: PPUSH
29358: LD_STRING D9cont-JMM-3
29360: PPUSH
29361: CALL_OW 88
// DialogueOff ;
29365: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29369: LD_STRING M3
29371: PPUSH
29372: CALL_OW 337
// allianceActive := true ;
29376: LD_ADDR_EXP 31
29380: PUSH
29381: LD_INT 1
29383: ST_TO_ADDR
// end ;
29384: PPOPN 1
29386: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29387: LD_EXP 64
29391: PPUSH
29392: CALL_OW 301
29396: PUSH
29397: LD_EXP 67
29401: PPUSH
29402: CALL_OW 301
29406: AND
29407: PUSH
29408: LD_INT 22
29410: PUSH
29411: LD_INT 3
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 21
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 50
29430: PUSH
29431: EMPTY
29432: LIST
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: LIST
29438: PPUSH
29439: CALL_OW 69
29443: PUSH
29444: LD_INT 7
29446: PUSH
29447: LD_INT 8
29449: PUSH
29450: LD_INT 9
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: LIST
29457: PUSH
29458: LD_OWVAR 67
29462: ARRAY
29463: LESS
29464: AND
29465: IFFALSE 30236
29467: GO 29469
29469: DISABLE
29470: LD_INT 0
29472: PPUSH
29473: PPUSH
29474: PPUSH
29475: PPUSH
// begin MC_Kill ( 1 ) ;
29476: LD_INT 1
29478: PPUSH
29479: CALL 34937 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29483: LD_INT 1
29485: PPUSH
29486: LD_INT 3
29488: PPUSH
29489: LD_INT 1
29491: PPUSH
29492: LD_INT 1
29494: PPUSH
29495: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29499: LD_ADDR_VAR 0 1
29503: PUSH
29504: LD_INT 22
29506: PUSH
29507: LD_INT 3
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 21
29516: PUSH
29517: LD_INT 1
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 24
29526: PUSH
29527: LD_INT 900
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: LIST
29538: PPUSH
29539: CALL_OW 69
29543: PUSH
29544: FOR_IN
29545: IFFALSE 29576
// if GetSex ( i ) = sex_male then
29547: LD_VAR 0 1
29551: PPUSH
29552: CALL_OW 258
29556: PUSH
29557: LD_INT 1
29559: EQUAL
29560: IFFALSE 29574
// begin tmp = i ;
29562: LD_ADDR_VAR 0 2
29566: PUSH
29567: LD_VAR 0 1
29571: ST_TO_ADDR
// break ;
29572: GO 29576
// end ;
29574: GO 29544
29576: POP
29577: POP
// if tmp = 0 then
29578: LD_VAR 0 2
29582: PUSH
29583: LD_INT 0
29585: EQUAL
29586: IFFALSE 29640
// begin uc_side = 3 ;
29588: LD_ADDR_OWVAR 20
29592: PUSH
29593: LD_INT 3
29595: ST_TO_ADDR
// uc_nation = 3 ;
29596: LD_ADDR_OWVAR 21
29600: PUSH
29601: LD_INT 3
29603: ST_TO_ADDR
// hc_name =  ;
29604: LD_ADDR_OWVAR 26
29608: PUSH
29609: LD_STRING 
29611: ST_TO_ADDR
// hc_gallery =  ;
29612: LD_ADDR_OWVAR 33
29616: PUSH
29617: LD_STRING 
29619: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29620: LD_INT 1
29622: PPUSH
29623: LD_INT 10
29625: PPUSH
29626: CALL_OW 381
// tmp = CreateHuman ;
29630: LD_ADDR_VAR 0 2
29634: PUSH
29635: CALL_OW 44
29639: ST_TO_ADDR
// end ; DialogueOn ;
29640: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29644: LD_VAR 0 2
29648: PPUSH
29649: LD_STRING DSurrenderRussians-RSol1-1a
29651: PPUSH
29652: CALL_OW 94
// DialogueOff ;
29656: CALL_OW 7
// russianDestroyed := true ;
29660: LD_ADDR_EXP 21
29664: PUSH
29665: LD_INT 1
29667: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29668: LD_INT 22
29670: PUSH
29671: LD_INT 3
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 21
29680: PUSH
29681: LD_INT 1
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PPUSH
29692: CALL_OW 69
29696: PPUSH
29697: CALL_OW 122
// wait ( 0 0$1 ) ;
29701: LD_INT 35
29703: PPUSH
29704: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29708: LD_INT 22
29710: PUSH
29711: LD_INT 3
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 21
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PPUSH
29732: CALL_OW 69
29736: PPUSH
29737: LD_INT 25
29739: PPUSH
29740: CALL_OW 173
// wait ( 0 0$10 ) ;
29744: LD_INT 350
29746: PPUSH
29747: CALL_OW 67
// PrepareOmarInvasion ;
29751: CALL 13747 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29755: LD_ADDR_VAR 0 2
29759: PUSH
29760: LD_EXP 92
29764: PPUSH
29765: CALL_OW 250
29769: PUSH
29770: LD_EXP 92
29774: PPUSH
29775: CALL_OW 251
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29784: LD_VAR 0 2
29788: PUSH
29789: LD_INT 1
29791: ARRAY
29792: PPUSH
29793: LD_VAR 0 2
29797: PUSH
29798: LD_INT 2
29800: ARRAY
29801: PPUSH
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 8
29807: NEG
29808: PPUSH
29809: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29813: LD_EXP 92
29817: PPUSH
29818: CALL_OW 87
// DialogueOn ;
29822: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29826: LD_EXP 39
29830: PPUSH
29831: LD_STRING D19-JMM-1
29833: PPUSH
29834: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29838: LD_ADDR_VAR 0 3
29842: PUSH
29843: LD_INT 22
29845: PUSH
29846: LD_INT 1
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 26
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: LD_INT 25
29868: PUSH
29869: LD_INT 1
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 25
29878: PUSH
29879: LD_INT 2
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: LD_INT 25
29888: PUSH
29889: LD_INT 3
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 25
29898: PUSH
29899: LD_INT 4
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 25
29908: PUSH
29909: LD_INT 5
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 25
29918: PUSH
29919: LD_INT 8
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: LIST
29939: PPUSH
29940: CALL_OW 69
29944: PUSH
29945: LD_EXP 39
29949: PUSH
29950: LD_EXP 40
29954: PUSH
29955: LD_EXP 41
29959: PUSH
29960: LD_EXP 42
29964: PUSH
29965: LD_EXP 43
29969: PUSH
29970: LD_EXP 44
29974: PUSH
29975: LD_EXP 45
29979: PUSH
29980: LD_EXP 46
29984: PUSH
29985: LD_EXP 47
29989: PUSH
29990: LD_EXP 48
29994: PUSH
29995: LD_EXP 49
29999: PUSH
30000: LD_EXP 50
30004: PUSH
30005: LD_EXP 51
30009: PUSH
30010: LD_EXP 52
30014: PUSH
30015: LD_EXP 53
30019: PUSH
30020: LD_EXP 54
30024: PUSH
30025: LD_EXP 55
30029: PUSH
30030: EMPTY
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: DIFF
30049: ST_TO_ADDR
// if tmp2 then
30050: LD_VAR 0 3
30054: IFFALSE 30072
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30056: LD_VAR 0 3
30060: PUSH
30061: LD_INT 1
30063: ARRAY
30064: PPUSH
30065: LD_STRING D19-Sol1-1
30067: PPUSH
30068: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30072: LD_EXP 39
30076: PPUSH
30077: LD_STRING D19-JMM-2
30079: PPUSH
30080: CALL_OW 88
// DialogueOff ;
30084: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30088: LD_VAR 0 2
30092: PUSH
30093: LD_INT 1
30095: ARRAY
30096: PPUSH
30097: LD_VAR 0 2
30101: PUSH
30102: LD_INT 2
30104: ARRAY
30105: PPUSH
30106: LD_INT 1
30108: PPUSH
30109: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30113: LD_STRING M5
30115: PPUSH
30116: CALL_OW 337
// omarOnMotherLode := false ;
30120: LD_ADDR_VAR 0 4
30124: PUSH
30125: LD_INT 0
30127: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30128: LD_INT 35
30130: PPUSH
30131: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30135: LD_EXP 92
30139: PPUSH
30140: LD_INT 215
30142: PPUSH
30143: LD_INT 100
30145: PPUSH
30146: CALL_OW 297
30150: PUSH
30151: LD_INT 10
30153: LESS
30154: PUSH
30155: LD_VAR 0 4
30159: NOT
30160: AND
30161: IFFALSE 30195
// begin omarOnMotherLode := true ;
30163: LD_ADDR_VAR 0 4
30167: PUSH
30168: LD_INT 1
30170: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30171: LD_EXP 39
30175: PPUSH
30176: LD_STRING D19b-JMM-1
30178: PPUSH
30179: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30183: LD_EXP 92
30187: PPUSH
30188: LD_STRING DOmarContam-Omar-1
30190: PPUSH
30191: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30195: LD_EXP 92
30199: PPUSH
30200: CALL_OW 301
30204: IFFALSE 30128
// Say ( JMM , D19a-JMM-1 ) ;
30206: LD_EXP 39
30210: PPUSH
30211: LD_STRING D19a-JMM-1
30213: PPUSH
30214: CALL_OW 88
// if Heike then
30218: LD_EXP 93
30222: IFFALSE 30236
// Say ( Heike , D19a-Hke-1 ) ;
30224: LD_EXP 93
30228: PPUSH
30229: LD_STRING D19a-Hke-1
30231: PPUSH
30232: CALL_OW 88
// end ;
30236: PPOPN 4
30238: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30239: LD_INT 22
30241: PUSH
30242: LD_INT 3
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 21
30251: PUSH
30252: LD_INT 1
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PPUSH
30263: CALL_OW 69
30267: PUSH
30268: LD_EXP 21
30272: AND
30273: IFFALSE 30341
30275: GO 30277
30277: DISABLE
30278: LD_INT 0
30280: PPUSH
30281: PPUSH
// begin enable ;
30282: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30283: LD_ADDR_VAR 0 2
30287: PUSH
30288: LD_INT 25
30290: PPUSH
30291: LD_INT 22
30293: PUSH
30294: LD_INT 3
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PPUSH
30301: CALL_OW 70
30305: ST_TO_ADDR
// if not tmp then
30306: LD_VAR 0 2
30310: NOT
30311: IFFALSE 30315
// exit ;
30313: GO 30341
// for i in tmp do
30315: LD_ADDR_VAR 0 1
30319: PUSH
30320: LD_VAR 0 2
30324: PUSH
30325: FOR_IN
30326: IFFALSE 30339
// RemoveUnit ( i ) ;
30328: LD_VAR 0 1
30332: PPUSH
30333: CALL_OW 64
30337: GO 30325
30339: POP
30340: POP
// end ;
30341: PPOPN 2
30343: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30344: LD_INT 22
30346: PUSH
30347: LD_INT 7
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 21
30356: PUSH
30357: LD_INT 1
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PPUSH
30368: CALL_OW 69
30372: PUSH
30373: LD_INT 6
30375: LESS
30376: IFFALSE 30844
30378: GO 30380
30380: DISABLE
30381: LD_INT 0
30383: PPUSH
30384: PPUSH
// begin MC_Kill ( 1 ) ;
30385: LD_INT 1
30387: PPUSH
30388: CALL 34937 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30392: LD_INT 7
30394: PPUSH
30395: LD_INT 1
30397: PPUSH
30398: LD_INT 1
30400: PPUSH
30401: LD_INT 1
30403: PPUSH
30404: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30408: LD_ADDR_VAR 0 1
30412: PUSH
30413: LD_INT 22
30415: PUSH
30416: LD_INT 7
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 26
30425: PUSH
30426: LD_INT 1
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PPUSH
30437: CALL_OW 69
30441: PUSH
30442: LD_EXP 74
30446: DIFF
30447: ST_TO_ADDR
// if tmp then
30448: LD_VAR 0 1
30452: IFFALSE 30470
// tmp := tmp [ 1 ] else
30454: LD_ADDR_VAR 0 1
30458: PUSH
30459: LD_VAR 0 1
30463: PUSH
30464: LD_INT 1
30466: ARRAY
30467: ST_TO_ADDR
30468: GO 30506
// begin uc_side := 7 ;
30470: LD_ADDR_OWVAR 20
30474: PUSH
30475: LD_INT 7
30477: ST_TO_ADDR
// uc_nation := 1 ;
30478: LD_ADDR_OWVAR 21
30482: PUSH
30483: LD_INT 1
30485: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30486: LD_INT 1
30488: PPUSH
30489: LD_INT 8
30491: PPUSH
30492: CALL_OW 384
// tmp := CreateHuman ;
30496: LD_ADDR_VAR 0 1
30500: PUSH
30501: CALL_OW 44
30505: ST_TO_ADDR
// end ; DialogueOn ;
30506: CALL_OW 6
// if IsOK ( Roth ) then
30510: LD_EXP 74
30514: PPUSH
30515: CALL_OW 302
30519: IFFALSE 30533
// Say ( JMM , DAb-JMM-1 ) ;
30521: LD_EXP 39
30525: PPUSH
30526: LD_STRING DAb-JMM-1
30528: PPUSH
30529: CALL_OW 88
// if IsOK ( Roth ) then
30533: LD_EXP 74
30537: PPUSH
30538: CALL_OW 302
30542: IFFALSE 30566
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30544: LD_EXP 74
30548: PPUSH
30549: LD_STRING DSurrenderAlliance-Roth-1
30551: PPUSH
30552: CALL_OW 88
// RothCaptured := true ;
30556: LD_ADDR_EXP 33
30560: PUSH
30561: LD_INT 1
30563: ST_TO_ADDR
// end else
30564: GO 30578
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30566: LD_VAR 0 1
30570: PPUSH
30571: LD_STRING DSurrenderAlliance-Sci1-1
30573: PPUSH
30574: CALL_OW 88
// DialogueOff ;
30578: CALL_OW 7
// allianceDestroyed := true ;
30582: LD_ADDR_EXP 23
30586: PUSH
30587: LD_INT 1
30589: ST_TO_ADDR
// if capturedUnit = 0 then
30590: LD_EXP 34
30594: PUSH
30595: LD_INT 0
30597: EQUAL
30598: IFFALSE 30607
// SetAchievement ( ACH_ALLIANCE ) ;
30600: LD_STRING ACH_ALLIANCE
30602: PPUSH
30603: CALL_OW 543
// if trueAmericans then
30607: LD_EXP 35
30611: IFFALSE 30687
// begin if trueAmericans = 1 then
30613: LD_EXP 35
30617: PUSH
30618: LD_INT 1
30620: EQUAL
30621: IFFALSE 30637
// Say ( JMM , DAb-JMM-1a ) else
30623: LD_EXP 39
30627: PPUSH
30628: LD_STRING DAb-JMM-1a
30630: PPUSH
30631: CALL_OW 88
30635: GO 30649
// Say ( JMM , DAb-JMM-1b ) ;
30637: LD_EXP 39
30641: PPUSH
30642: LD_STRING DAb-JMM-1b
30644: PPUSH
30645: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30649: LD_EXP 35
30653: PPUSH
30654: CALL_OW 87
// for i in trueAmericans do
30658: LD_ADDR_VAR 0 2
30662: PUSH
30663: LD_EXP 35
30667: PUSH
30668: FOR_IN
30669: IFFALSE 30685
// SetSide ( i , 1 ) ;
30671: LD_VAR 0 2
30675: PPUSH
30676: LD_INT 1
30678: PPUSH
30679: CALL_OW 235
30683: GO 30668
30685: POP
30686: POP
// end ; repeat wait ( 0 0$1 ) ;
30687: LD_INT 35
30689: PPUSH
30690: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30694: LD_ADDR_VAR 0 2
30698: PUSH
30699: LD_INT 22
30701: PUSH
30702: LD_INT 7
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 21
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PPUSH
30723: CALL_OW 69
30727: PUSH
30728: FOR_IN
30729: IFFALSE 30811
// begin if IsInUnit ( i ) then
30731: LD_VAR 0 2
30735: PPUSH
30736: CALL_OW 310
30740: IFFALSE 30751
// ComExitBuilding ( i ) ;
30742: LD_VAR 0 2
30746: PPUSH
30747: CALL_OW 122
// if IsDriver ( i ) then
30751: LD_VAR 0 2
30755: PPUSH
30756: CALL 105329 0 1
30760: IFFALSE 30771
// ComExitVehicle ( i ) ;
30762: LD_VAR 0 2
30766: PPUSH
30767: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30771: LD_VAR 0 2
30775: PPUSH
30776: LD_INT 26
30778: PPUSH
30779: CALL_OW 308
30783: NOT
30784: IFFALSE 30800
// AddComMoveToArea ( i , allianceEscapeArea ) else
30786: LD_VAR 0 2
30790: PPUSH
30791: LD_INT 26
30793: PPUSH
30794: CALL_OW 173
30798: GO 30809
// RemoveUnit ( i ) ;
30800: LD_VAR 0 2
30804: PPUSH
30805: CALL_OW 64
// end ;
30809: GO 30728
30811: POP
30812: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30813: LD_INT 22
30815: PUSH
30816: LD_INT 7
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 21
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PPUSH
30837: CALL_OW 69
30841: NOT
30842: IFFALSE 30687
// end ;
30844: PPOPN 2
30846: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30847: LD_INT 0
30849: PPUSH
30850: PPUSH
// if not unit then
30851: LD_VAR 0 1
30855: NOT
30856: IFFALSE 30860
// exit ;
30858: GO 32358
// DoNotAttack ( 7 , unit ) ;
30860: LD_INT 7
30862: PPUSH
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30872: LD_VAR 0 1
30876: PPUSH
30877: LD_INT 260
30879: PPUSH
30880: LD_INT 235
30882: PPUSH
30883: LD_INT 3
30885: PPUSH
30886: LD_INT 1
30888: PPUSH
30889: CALL_OW 483
// SetSide ( unit , 4 ) ;
30893: LD_VAR 0 1
30897: PPUSH
30898: LD_INT 4
30900: PPUSH
30901: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30905: LD_ADDR_EXP 34
30909: PUSH
30910: LD_EXP 34
30914: PUSH
30915: LD_INT 1
30917: PLUS
30918: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30919: LD_INT 70
30921: PPUSH
30922: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30926: LD_INT 260
30928: PPUSH
30929: LD_INT 235
30931: PPUSH
30932: LD_INT 1
30934: PPUSH
30935: LD_INT 8
30937: NEG
30938: PPUSH
30939: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30943: LD_VAR 0 1
30947: PPUSH
30948: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30952: LD_VAR 0 1
30956: PPUSH
30957: LD_EXP 74
30961: PPUSH
30962: CALL_OW 119
// DialogueOn ;
30966: CALL_OW 6
// case unit of JMM :
30970: LD_VAR 0 1
30974: PUSH
30975: LD_EXP 39
30979: DOUBLE
30980: EQUAL
30981: IFTRUE 30985
30983: GO 31000
30985: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30986: LD_EXP 39
30990: PPUSH
30991: LD_STRING DA1-JMM-1
30993: PPUSH
30994: CALL_OW 91
30998: GO 31442
31000: LD_EXP 40
31004: DOUBLE
31005: EQUAL
31006: IFTRUE 31010
31008: GO 31025
31010: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31011: LD_EXP 40
31015: PPUSH
31016: LD_STRING DA1-Joan-1
31018: PPUSH
31019: CALL_OW 91
31023: GO 31442
31025: LD_EXP 42
31029: DOUBLE
31030: EQUAL
31031: IFTRUE 31035
31033: GO 31050
31035: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31036: LD_EXP 42
31040: PPUSH
31041: LD_STRING DA1-Lisa-1
31043: PPUSH
31044: CALL_OW 91
31048: GO 31442
31050: LD_EXP 43
31054: DOUBLE
31055: EQUAL
31056: IFTRUE 31060
31058: GO 31075
31060: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31061: LD_EXP 43
31065: PPUSH
31066: LD_STRING DA1-Don-1
31068: PPUSH
31069: CALL_OW 91
31073: GO 31442
31075: LD_EXP 50
31079: DOUBLE
31080: EQUAL
31081: IFTRUE 31085
31083: GO 31100
31085: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31086: LD_EXP 50
31090: PPUSH
31091: LD_STRING DA1-Corn-1
31093: PPUSH
31094: CALL_OW 91
31098: GO 31442
31100: LD_EXP 46
31104: DOUBLE
31105: EQUAL
31106: IFTRUE 31110
31108: GO 31125
31110: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31111: LD_EXP 46
31115: PPUSH
31116: LD_STRING DA1-Den-1
31118: PPUSH
31119: CALL_OW 91
31123: GO 31442
31125: LD_EXP 44
31129: DOUBLE
31130: EQUAL
31131: IFTRUE 31135
31133: GO 31150
31135: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31136: LD_EXP 44
31140: PPUSH
31141: LD_STRING DA1-Bobby-1
31143: PPUSH
31144: CALL_OW 91
31148: GO 31442
31150: LD_EXP 48
31154: DOUBLE
31155: EQUAL
31156: IFTRUE 31160
31158: GO 31175
31160: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31161: LD_EXP 48
31165: PPUSH
31166: LD_STRING DA1-Glad-1
31168: PPUSH
31169: CALL_OW 91
31173: GO 31442
31175: LD_EXP 45
31179: DOUBLE
31180: EQUAL
31181: IFTRUE 31185
31183: GO 31200
31185: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31186: LD_EXP 45
31190: PPUSH
31191: LD_STRING DA1-Cyrus-1
31193: PPUSH
31194: CALL_OW 91
31198: GO 31442
31200: LD_EXP 41
31204: DOUBLE
31205: EQUAL
31206: IFTRUE 31210
31208: GO 31225
31210: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31211: LD_EXP 41
31215: PPUSH
31216: LD_STRING DA1-Huck-1
31218: PPUSH
31219: CALL_OW 91
31223: GO 31442
31225: LD_EXP 55
31229: DOUBLE
31230: EQUAL
31231: IFTRUE 31235
31233: GO 31250
31235: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31236: LD_EXP 55
31240: PPUSH
31241: LD_STRING DA1-Huck-1
31243: PPUSH
31244: CALL_OW 91
31248: GO 31442
31250: LD_EXP 47
31254: DOUBLE
31255: EQUAL
31256: IFTRUE 31260
31258: GO 31275
31260: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31261: LD_EXP 47
31265: PPUSH
31266: LD_STRING DA1-Brown-1
31268: PPUSH
31269: CALL_OW 91
31273: GO 31442
31275: LD_EXP 51
31279: DOUBLE
31280: EQUAL
31281: IFTRUE 31285
31283: GO 31300
31285: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31286: LD_EXP 51
31290: PPUSH
31291: LD_STRING DA1-Gary-1
31293: PPUSH
31294: CALL_OW 91
31298: GO 31442
31300: LD_EXP 54
31304: DOUBLE
31305: EQUAL
31306: IFTRUE 31310
31308: GO 31325
31310: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31311: LD_EXP 54
31315: PPUSH
31316: LD_STRING DA1-Con-1
31318: PPUSH
31319: CALL_OW 91
31323: GO 31442
31325: LD_EXP 60
31329: DOUBLE
31330: EQUAL
31331: IFTRUE 31335
31333: GO 31350
31335: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31336: LD_EXP 60
31340: PPUSH
31341: LD_STRING DA1-Kurt-1
31343: PPUSH
31344: CALL_OW 91
31348: GO 31442
31350: LD_EXP 53
31354: DOUBLE
31355: EQUAL
31356: IFTRUE 31360
31358: GO 31375
31360: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31361: LD_EXP 53
31365: PPUSH
31366: LD_STRING DA1-Yam-1
31368: PPUSH
31369: CALL_OW 91
31373: GO 31442
31375: LD_EXP 52
31379: DOUBLE
31380: EQUAL
31381: IFTRUE 31385
31383: GO 31400
31385: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31386: LD_EXP 52
31390: PPUSH
31391: LD_STRING DA1-Frank-1
31393: PPUSH
31394: CALL_OW 91
31398: GO 31442
31400: POP
// begin if GetSex ( unit ) = sex_male then
31401: LD_VAR 0 1
31405: PPUSH
31406: CALL_OW 258
31410: PUSH
31411: LD_INT 1
31413: EQUAL
31414: IFFALSE 31430
// ForceSay ( unit , DA1-Sol1-1 ) else
31416: LD_VAR 0 1
31420: PPUSH
31421: LD_STRING DA1-Sol1-1
31423: PPUSH
31424: CALL_OW 91
31428: GO 31442
// ForceSay ( unit , DA1-FSol1-1 ) ;
31430: LD_VAR 0 1
31434: PPUSH
31435: LD_STRING DA1-FSol1-1
31437: PPUSH
31438: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31442: LD_EXP 74
31446: PPUSH
31447: LD_STRING DA-Roth-1
31449: PPUSH
31450: CALL_OW 88
// if capturedUnit = 1 then
31454: LD_EXP 34
31458: PUSH
31459: LD_INT 1
31461: EQUAL
31462: IFFALSE 31490
// begin Say ( Simms , DA-Sim-1 ) ;
31464: LD_EXP 75
31468: PPUSH
31469: LD_STRING DA-Sim-1
31471: PPUSH
31472: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31476: LD_EXP 74
31480: PPUSH
31481: LD_STRING DA-Roth-2
31483: PPUSH
31484: CALL_OW 88
// end else
31488: GO 31502
// Say ( Simms , DA-Sim-2 ) ;
31490: LD_EXP 75
31494: PPUSH
31495: LD_STRING DA-Sim-2
31497: PPUSH
31498: CALL_OW 88
// case unit of JMM :
31502: LD_VAR 0 1
31506: PUSH
31507: LD_EXP 39
31511: DOUBLE
31512: EQUAL
31513: IFTRUE 31517
31515: GO 31532
31517: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31518: LD_EXP 39
31522: PPUSH
31523: LD_STRING DA1-JMM-1a
31525: PPUSH
31526: CALL_OW 91
31530: GO 32039
31532: LD_EXP 40
31536: DOUBLE
31537: EQUAL
31538: IFTRUE 31542
31540: GO 31557
31542: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31543: LD_EXP 40
31547: PPUSH
31548: LD_STRING DA1-Joan-1a
31550: PPUSH
31551: CALL_OW 91
31555: GO 32039
31557: LD_EXP 42
31561: DOUBLE
31562: EQUAL
31563: IFTRUE 31567
31565: GO 31582
31567: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31568: LD_EXP 42
31572: PPUSH
31573: LD_STRING DA1-Lisa-1a
31575: PPUSH
31576: CALL_OW 91
31580: GO 32039
31582: LD_EXP 43
31586: DOUBLE
31587: EQUAL
31588: IFTRUE 31592
31590: GO 31607
31592: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31593: LD_EXP 43
31597: PPUSH
31598: LD_STRING DA1-Don-1a
31600: PPUSH
31601: CALL_OW 91
31605: GO 32039
31607: LD_EXP 50
31611: DOUBLE
31612: EQUAL
31613: IFTRUE 31617
31615: GO 31632
31617: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31618: LD_EXP 50
31622: PPUSH
31623: LD_STRING DA1-Corn-1a
31625: PPUSH
31626: CALL_OW 91
31630: GO 32039
31632: LD_EXP 46
31636: DOUBLE
31637: EQUAL
31638: IFTRUE 31642
31640: GO 31657
31642: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31643: LD_EXP 46
31647: PPUSH
31648: LD_STRING DA1-Den-1a
31650: PPUSH
31651: CALL_OW 91
31655: GO 32039
31657: LD_EXP 44
31661: DOUBLE
31662: EQUAL
31663: IFTRUE 31667
31665: GO 31682
31667: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31668: LD_EXP 44
31672: PPUSH
31673: LD_STRING DA1-Bobby-1a
31675: PPUSH
31676: CALL_OW 91
31680: GO 32039
31682: LD_EXP 48
31686: DOUBLE
31687: EQUAL
31688: IFTRUE 31692
31690: GO 31707
31692: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31693: LD_EXP 48
31697: PPUSH
31698: LD_STRING DA1-Glad-1a
31700: PPUSH
31701: CALL_OW 91
31705: GO 32039
31707: LD_EXP 45
31711: DOUBLE
31712: EQUAL
31713: IFTRUE 31717
31715: GO 31732
31717: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31718: LD_EXP 45
31722: PPUSH
31723: LD_STRING DA1-Cyrus-1a
31725: PPUSH
31726: CALL_OW 91
31730: GO 32039
31732: LD_EXP 41
31736: DOUBLE
31737: EQUAL
31738: IFTRUE 31742
31740: GO 31757
31742: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31743: LD_EXP 41
31747: PPUSH
31748: LD_STRING DA1-Huck-1a
31750: PPUSH
31751: CALL_OW 91
31755: GO 32039
31757: LD_EXP 55
31761: DOUBLE
31762: EQUAL
31763: IFTRUE 31767
31765: GO 31782
31767: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31768: LD_EXP 55
31772: PPUSH
31773: LD_STRING DA1-Huck-1a
31775: PPUSH
31776: CALL_OW 91
31780: GO 32039
31782: LD_EXP 47
31786: DOUBLE
31787: EQUAL
31788: IFTRUE 31792
31790: GO 31807
31792: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31793: LD_EXP 47
31797: PPUSH
31798: LD_STRING DA1-Brown-1a
31800: PPUSH
31801: CALL_OW 91
31805: GO 32039
31807: LD_EXP 51
31811: DOUBLE
31812: EQUAL
31813: IFTRUE 31817
31815: GO 31832
31817: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31818: LD_EXP 51
31822: PPUSH
31823: LD_STRING DA1-Gary-1a
31825: PPUSH
31826: CALL_OW 91
31830: GO 32039
31832: LD_EXP 54
31836: DOUBLE
31837: EQUAL
31838: IFTRUE 31842
31840: GO 31857
31842: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31843: LD_EXP 54
31847: PPUSH
31848: LD_STRING DA1-Con-1a
31850: PPUSH
31851: CALL_OW 91
31855: GO 32039
31857: LD_EXP 60
31861: DOUBLE
31862: EQUAL
31863: IFTRUE 31867
31865: GO 31882
31867: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31868: LD_EXP 60
31872: PPUSH
31873: LD_STRING DA1-Kurt-1a
31875: PPUSH
31876: CALL_OW 91
31880: GO 32039
31882: LD_EXP 53
31886: DOUBLE
31887: EQUAL
31888: IFTRUE 31892
31890: GO 31907
31892: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31893: LD_EXP 53
31897: PPUSH
31898: LD_STRING DA1-Yam-1a
31900: PPUSH
31901: CALL_OW 91
31905: GO 32039
31907: LD_EXP 52
31911: DOUBLE
31912: EQUAL
31913: IFTRUE 31917
31915: GO 31932
31917: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31918: LD_EXP 52
31922: PPUSH
31923: LD_STRING DA1-Frank-1a
31925: PPUSH
31926: CALL_OW 91
31930: GO 32039
31932: POP
// begin join := rand ( 0 , 1 ) ;
31933: LD_ADDR_VAR 0 3
31937: PUSH
31938: LD_INT 0
31940: PPUSH
31941: LD_INT 1
31943: PPUSH
31944: CALL_OW 12
31948: ST_TO_ADDR
// if join then
31949: LD_VAR 0 3
31953: IFFALSE 31998
// begin if GetSex ( unit ) = sex_male then
31955: LD_VAR 0 1
31959: PPUSH
31960: CALL_OW 258
31964: PUSH
31965: LD_INT 1
31967: EQUAL
31968: IFFALSE 31984
// ForceSay ( unit , DA1-Sol1-1b ) else
31970: LD_VAR 0 1
31974: PPUSH
31975: LD_STRING DA1-Sol1-1b
31977: PPUSH
31978: CALL_OW 91
31982: GO 31996
// ForceSay ( unit , DA1-FSol1-1b ) ;
31984: LD_VAR 0 1
31988: PPUSH
31989: LD_STRING DA1-FSol1-1b
31991: PPUSH
31992: CALL_OW 91
// end else
31996: GO 32039
// begin if GetSex ( unit ) = sex_male then
31998: LD_VAR 0 1
32002: PPUSH
32003: CALL_OW 258
32007: PUSH
32008: LD_INT 1
32010: EQUAL
32011: IFFALSE 32027
// ForceSay ( unit , DA1-Sol1-1a ) else
32013: LD_VAR 0 1
32017: PPUSH
32018: LD_STRING DA1-Sol1-1a
32020: PPUSH
32021: CALL_OW 91
32025: GO 32039
// ForceSay ( unit , DA1-FSol1-1a ) ;
32027: LD_VAR 0 1
32031: PPUSH
32032: LD_STRING DA1-FSol1-1a
32034: PPUSH
32035: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32039: LD_VAR 0 1
32043: PUSH
32044: LD_EXP 39
32048: EQUAL
32049: IFFALSE 32060
// begin YouLost ( JMMCaptured ) ;
32051: LD_STRING JMMCaptured
32053: PPUSH
32054: CALL_OW 104
// exit ;
32058: GO 32358
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32060: LD_VAR 0 1
32064: PUSH
32065: LD_EXP 43
32069: PUSH
32070: LD_EXP 46
32074: PUSH
32075: LD_EXP 44
32079: PUSH
32080: LD_EXP 41
32084: PUSH
32085: LD_EXP 55
32089: PUSH
32090: LD_EXP 47
32094: PUSH
32095: LD_EXP 53
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: IN
32109: PUSH
32110: LD_VAR 0 3
32114: OR
32115: IFFALSE 32214
// begin Say ( Roth , DA-Roth-3 ) ;
32117: LD_EXP 74
32121: PPUSH
32122: LD_STRING DA-Roth-3
32124: PPUSH
32125: CALL_OW 88
// SetSide ( unit , 7 ) ;
32129: LD_VAR 0 1
32133: PPUSH
32134: LD_INT 7
32136: PPUSH
32137: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32141: LD_ADDR_EXP 102
32145: PUSH
32146: LD_EXP 102
32150: PPUSH
32151: LD_INT 1
32153: PPUSH
32154: LD_EXP 102
32158: PUSH
32159: LD_INT 1
32161: ARRAY
32162: PUSH
32163: LD_VAR 0 1
32167: ADD
32168: PPUSH
32169: CALL_OW 1
32173: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32174: LD_INT 260
32176: PPUSH
32177: LD_INT 235
32179: PPUSH
32180: LD_INT 1
32182: PPUSH
32183: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32187: LD_VAR 0 1
32191: PPUSH
32192: LD_INT 1000
32194: PPUSH
32195: CALL_OW 234
// DialogueOff ;
32199: CALL_OW 7
// ComFree ( unit ) ;
32203: LD_VAR 0 1
32207: PPUSH
32208: CALL_OW 139
// end else
32212: GO 32295
// begin Say ( Roth , DA-Roth-3a ) ;
32214: LD_EXP 74
32218: PPUSH
32219: LD_STRING DA-Roth-3a
32221: PPUSH
32222: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32226: LD_ADDR_EXP 35
32230: PUSH
32231: LD_EXP 35
32235: PUSH
32236: LD_VAR 0 1
32240: ADD
32241: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32242: LD_INT 260
32244: PPUSH
32245: LD_INT 235
32247: PPUSH
32248: LD_INT 1
32250: PPUSH
32251: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32255: LD_VAR 0 1
32259: PPUSH
32260: LD_INT 1000
32262: PPUSH
32263: CALL_OW 234
// DialogueOff ;
32267: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32271: LD_VAR 0 1
32275: PPUSH
32276: LD_INT 272
32278: PPUSH
32279: LD_INT 254
32281: PPUSH
32282: CALL_OW 111
// AddComHold ( unit ) ;
32286: LD_VAR 0 1
32290: PPUSH
32291: CALL_OW 200
// end ; if capturedUnit = 1 then
32295: LD_EXP 34
32299: PUSH
32300: LD_INT 1
32302: EQUAL
32303: IFFALSE 32358
// begin DialogueOn ;
32305: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32309: LD_EXP 39
32313: PPUSH
32314: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32318: LD_EXP 39
32322: PPUSH
32323: LD_STRING DAa-JMM-1
32325: PPUSH
32326: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32330: LD_EXP 39
32334: PPUSH
32335: LD_STRING DAa-JMM-1a
32337: PPUSH
32338: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32342: LD_EXP 39
32346: PPUSH
32347: LD_STRING DAa-JMM-1b
32349: PPUSH
32350: CALL_OW 88
// DialogueOff ;
32354: CALL_OW 7
// end ; end ;
32358: LD_VAR 0 2
32362: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32363: LD_EXP 15
32367: PUSH
32368: LD_INT 13
32370: GREATEREQUAL
32371: PUSH
32372: LD_INT 22
32374: PUSH
32375: LD_INT 2
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 21
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PPUSH
32396: CALL_OW 69
32400: PUSH
32401: LD_INT 0
32403: EQUAL
32404: AND
32405: PUSH
32406: LD_INT 22
32408: PUSH
32409: LD_INT 2
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 21
32418: PUSH
32419: LD_INT 2
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 50
32428: PUSH
32429: EMPTY
32430: LIST
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: LIST
32436: PPUSH
32437: CALL_OW 69
32441: PUSH
32442: LD_INT 0
32444: EQUAL
32445: AND
32446: PUSH
32447: LD_EXP 21
32451: AND
32452: PUSH
32453: LD_EXP 22
32457: AND
32458: PUSH
32459: LD_EXP 23
32463: AND
32464: IFFALSE 33106
32466: GO 32468
32468: DISABLE
32469: LD_INT 0
32471: PPUSH
32472: PPUSH
32473: PPUSH
// begin m1 := false ;
32474: LD_ADDR_VAR 0 1
32478: PUSH
32479: LD_INT 0
32481: ST_TO_ADDR
// m2 := false ;
32482: LD_ADDR_VAR 0 2
32486: PUSH
32487: LD_INT 0
32489: ST_TO_ADDR
// m3 := false ;
32490: LD_ADDR_VAR 0 3
32494: PUSH
32495: LD_INT 0
32497: ST_TO_ADDR
// if not bombExploded then
32498: LD_EXP 37
32502: NOT
32503: IFFALSE 32512
// SetAchievement ( ACH_SIBROCKET ) ;
32505: LD_STRING ACH_SIBROCKET
32507: PPUSH
32508: CALL_OW 543
// if tick <= 120 120$00 then
32512: LD_OWVAR 1
32516: PUSH
32517: LD_INT 252000
32519: LESSEQUAL
32520: IFFALSE 32536
// begin wait ( 3 ) ;
32522: LD_INT 3
32524: PPUSH
32525: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32529: LD_STRING ACH_ASPEED_15
32531: PPUSH
32532: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32536: LD_EXP 39
32540: PPUSH
32541: CALL_OW 87
// music_class := 5 ;
32545: LD_ADDR_OWVAR 72
32549: PUSH
32550: LD_INT 5
32552: ST_TO_ADDR
// music_nat := 5 ;
32553: LD_ADDR_OWVAR 71
32557: PUSH
32558: LD_INT 5
32560: ST_TO_ADDR
// DialogueOn ;
32561: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32565: LD_EXP 39
32569: PPUSH
32570: LD_STRING D20-JMM-1
32572: PPUSH
32573: CALL_OW 88
// if IsOK ( Joan ) then
32577: LD_EXP 40
32581: PPUSH
32582: CALL_OW 302
32586: IFFALSE 32600
// Say ( Joan , D20-Joan-1 ) ;
32588: LD_EXP 40
32592: PPUSH
32593: LD_STRING D20-Joan-1
32595: PPUSH
32596: CALL_OW 88
// if IsOk ( Lisa ) then
32600: LD_EXP 42
32604: PPUSH
32605: CALL_OW 302
32609: IFFALSE 32623
// Say ( Lisa , D20-Lisa-1 ) ;
32611: LD_EXP 42
32615: PPUSH
32616: LD_STRING D20-Lisa-1
32618: PPUSH
32619: CALL_OW 88
// if IsOk ( Donaldson ) then
32623: LD_EXP 43
32627: PPUSH
32628: CALL_OW 302
32632: IFFALSE 32646
// Say ( Donaldson , D20-Don-1 ) ;
32634: LD_EXP 43
32638: PPUSH
32639: LD_STRING D20-Don-1
32641: PPUSH
32642: CALL_OW 88
// if IsOK ( Cornel ) then
32646: LD_EXP 50
32650: PPUSH
32651: CALL_OW 302
32655: IFFALSE 32669
// Say ( Cornel , D20-Corn-1 ) ;
32657: LD_EXP 50
32661: PPUSH
32662: LD_STRING D20-Corn-1
32664: PPUSH
32665: CALL_OW 88
// if IsOk ( Denis ) then
32669: LD_EXP 46
32673: PPUSH
32674: CALL_OW 302
32678: IFFALSE 32692
// Say ( Denis , D20-Den-1 ) ;
32680: LD_EXP 46
32684: PPUSH
32685: LD_STRING D20-Den-1
32687: PPUSH
32688: CALL_OW 88
// if IsOk ( Bobby ) then
32692: LD_EXP 44
32696: PPUSH
32697: CALL_OW 302
32701: IFFALSE 32715
// Say ( Bobby , D20-Bobby-1 ) ;
32703: LD_EXP 44
32707: PPUSH
32708: LD_STRING D20-Bobby-1
32710: PPUSH
32711: CALL_OW 88
// if IsOk ( Gladstone ) then
32715: LD_EXP 48
32719: PPUSH
32720: CALL_OW 302
32724: IFFALSE 32738
// Say ( Gladstone , D20-Glad-1 ) ;
32726: LD_EXP 48
32730: PPUSH
32731: LD_STRING D20-Glad-1
32733: PPUSH
32734: CALL_OW 88
// if IsOk ( Cyrus ) then
32738: LD_EXP 45
32742: PPUSH
32743: CALL_OW 302
32747: IFFALSE 32761
// Say ( Cyrus , D20-Cyrus-1 ) ;
32749: LD_EXP 45
32753: PPUSH
32754: LD_STRING D20-Cyrus-1
32756: PPUSH
32757: CALL_OW 88
// if IsOk ( Stevens ) then
32761: LD_EXP 41
32765: PPUSH
32766: CALL_OW 302
32770: IFFALSE 32784
// Say ( Stevens , D20-Huck-1 ) ;
32772: LD_EXP 41
32776: PPUSH
32777: LD_STRING D20-Huck-1
32779: PPUSH
32780: CALL_OW 88
// if IsOk ( Brown ) then
32784: LD_EXP 47
32788: PPUSH
32789: CALL_OW 302
32793: IFFALSE 32807
// Say ( Brown , D20-Brown-1 ) ;
32795: LD_EXP 47
32799: PPUSH
32800: LD_STRING D20-Brown-1
32802: PPUSH
32803: CALL_OW 88
// if IsOk ( Gary ) then
32807: LD_EXP 51
32811: PPUSH
32812: CALL_OW 302
32816: IFFALSE 32830
// Say ( Gary , D20-Gary-1 ) ;
32818: LD_EXP 51
32822: PPUSH
32823: LD_STRING D20-Gary-1
32825: PPUSH
32826: CALL_OW 88
// if IsOk ( Connie ) then
32830: LD_EXP 54
32834: PPUSH
32835: CALL_OW 302
32839: IFFALSE 32853
// Say ( Connie , D20-Con-1 ) ;
32841: LD_EXP 54
32845: PPUSH
32846: LD_STRING D20-Con-1
32848: PPUSH
32849: CALL_OW 88
// if IsOk ( Kurt ) then
32853: LD_EXP 60
32857: PPUSH
32858: CALL_OW 302
32862: IFFALSE 32876
// Say ( Kurt , D20-Kurt-1 ) ;
32864: LD_EXP 60
32868: PPUSH
32869: LD_STRING D20-Kurt-1
32871: PPUSH
32872: CALL_OW 88
// if IsOk ( Kikuchi ) then
32876: LD_EXP 53
32880: PPUSH
32881: CALL_OW 302
32885: IFFALSE 32899
// Say ( Kikuchi , D20-Yam-1 ) ;
32887: LD_EXP 53
32891: PPUSH
32892: LD_STRING D20-Yam-1
32894: PPUSH
32895: CALL_OW 88
// if IsOk ( Frank ) then
32899: LD_EXP 52
32903: PPUSH
32904: CALL_OW 302
32908: IFFALSE 32922
// Say ( Frank , D20-Frank-1 ) ;
32910: LD_EXP 52
32914: PPUSH
32915: LD_STRING D20-Frank-1
32917: PPUSH
32918: CALL_OW 88
// DialogueOff ;
32922: CALL_OW 7
// if RothCaptured then
32926: LD_EXP 33
32930: IFFALSE 32952
// begin m1 := true ;
32932: LD_ADDR_VAR 0 1
32936: PUSH
32937: LD_INT 1
32939: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32940: LD_STRING Roth
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: CALL_OW 101
// end else
32950: GO 32963
// AddMedal ( Roth , - 1 ) ;
32952: LD_STRING Roth
32954: PPUSH
32955: LD_INT 1
32957: NEG
32958: PPUSH
32959: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32963: LD_EXP 27
32967: IFFALSE 32989
// begin m2 := true ;
32969: LD_ADDR_VAR 0 2
32973: PUSH
32974: LD_INT 1
32976: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32977: LD_STRING Project
32979: PPUSH
32980: LD_INT 1
32982: PPUSH
32983: CALL_OW 101
// end else
32987: GO 33000
// AddMedal ( Project , - 1 ) ;
32989: LD_STRING Project
32991: PPUSH
32992: LD_INT 1
32994: NEG
32995: PPUSH
32996: CALL_OW 101
// if lostCounter = 0 then
33000: LD_EXP 32
33004: PUSH
33005: LD_INT 0
33007: EQUAL
33008: IFFALSE 33030
// begin m3 := true ;
33010: LD_ADDR_VAR 0 3
33014: PUSH
33015: LD_INT 1
33017: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33018: LD_STRING NoLosses
33020: PPUSH
33021: LD_INT 1
33023: PPUSH
33024: CALL_OW 101
// end else
33028: GO 33041
// AddMedal ( NoLosses , - 1 ) ;
33030: LD_STRING NoLosses
33032: PPUSH
33033: LD_INT 1
33035: NEG
33036: PPUSH
33037: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33041: LD_VAR 0 1
33045: PUSH
33046: LD_VAR 0 2
33050: AND
33051: PUSH
33052: LD_VAR 0 3
33056: AND
33057: PUSH
33058: LD_OWVAR 67
33062: PUSH
33063: LD_INT 3
33065: EQUAL
33066: AND
33067: IFFALSE 33079
// SetAchievementEX ( ACH_AMER , 15 ) ;
33069: LD_STRING ACH_AMER
33071: PPUSH
33072: LD_INT 15
33074: PPUSH
33075: CALL_OW 564
// GiveMedals ( MAIN ) ;
33079: LD_STRING MAIN
33081: PPUSH
33082: CALL_OW 102
// music_class := 4 ;
33086: LD_ADDR_OWVAR 72
33090: PUSH
33091: LD_INT 4
33093: ST_TO_ADDR
// music_nat := 1 ;
33094: LD_ADDR_OWVAR 71
33098: PUSH
33099: LD_INT 1
33101: ST_TO_ADDR
// YouWin ;
33102: CALL_OW 103
// end ; end_of_file
33106: PPOPN 3
33108: END
// export function CustomEvent ( event ) ; begin
33109: LD_INT 0
33111: PPUSH
// end ;
33112: LD_VAR 0 2
33116: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33117: LD_VAR 0 1
33121: PUSH
33122: LD_INT 1
33124: EQUAL
33125: PUSH
33126: LD_VAR 0 2
33130: PUSH
33131: LD_INT 4
33133: EQUAL
33134: AND
33135: PUSH
33136: LD_EXP 58
33140: PPUSH
33141: CALL_OW 300
33145: AND
33146: IFFALSE 33162
// begin wait ( 0 0$2 ) ;
33148: LD_INT 70
33150: PPUSH
33151: CALL_OW 67
// YouLost ( Dismissed ) ;
33155: LD_STRING Dismissed
33157: PPUSH
33158: CALL_OW 104
// end ; end ;
33162: PPOPN 2
33164: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33165: LD_VAR 0 2
33169: PPUSH
33170: LD_VAR 0 3
33174: PPUSH
33175: LD_INT 18
33177: PPUSH
33178: CALL_OW 309
33182: IFFALSE 33191
// YouLost ( Motherlode3 ) ;
33184: LD_STRING Motherlode3
33186: PPUSH
33187: CALL_OW 104
// end ;
33191: PPOPN 3
33193: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33194: LD_EXP 27
33198: NOT
33199: IFFALSE 33209
// behemothDone := true ;
33201: LD_ADDR_EXP 28
33205: PUSH
33206: LD_INT 1
33208: ST_TO_ADDR
// end ;
33209: PPOPN 1
33211: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33212: LD_VAR 0 1
33216: PPUSH
33217: CALL_OW 255
33221: PUSH
33222: LD_INT 1
33224: EQUAL
33225: IFFALSE 33235
// bombExploded := true ;
33227: LD_ADDR_EXP 37
33231: PUSH
33232: LD_INT 1
33234: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33235: LD_VAR 0 1
33239: PPUSH
33240: CALL_OW 255
33244: PUSH
33245: LD_INT 1
33247: EQUAL
33248: PUSH
33249: LD_EXP 30
33253: AND
33254: PUSH
33255: LD_INT 22
33257: PUSH
33258: LD_INT 3
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 34
33267: PUSH
33268: LD_INT 48
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PPUSH
33279: CALL_OW 69
33283: AND
33284: PUSH
33285: LD_INT 22
33287: PUSH
33288: LD_INT 1
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 34
33297: PUSH
33298: LD_INT 8
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PPUSH
33309: CALL_OW 69
33313: NOT
33314: AND
33315: IFFALSE 33367
// begin wait ( 0 0$5 ) ;
33317: LD_INT 175
33319: PPUSH
33320: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33324: LD_INT 22
33326: PUSH
33327: LD_INT 3
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 34
33336: PUSH
33337: LD_INT 48
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PPUSH
33348: CALL_OW 69
33352: PUSH
33353: LD_INT 1
33355: ARRAY
33356: PPUSH
33357: LD_INT 60
33359: PPUSH
33360: LD_INT 95
33362: PPUSH
33363: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33367: LD_VAR 0 2
33371: PPUSH
33372: LD_VAR 0 3
33376: PPUSH
33377: LD_INT 18
33379: PPUSH
33380: CALL_OW 309
33384: IFFALSE 33444
// begin if GetSide ( unit ) = 1 then
33386: LD_VAR 0 1
33390: PPUSH
33391: CALL_OW 255
33395: PUSH
33396: LD_INT 1
33398: EQUAL
33399: IFFALSE 33415
// begin wait ( 0 0$6 ) ;
33401: LD_INT 210
33403: PPUSH
33404: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33408: LD_STRING Motherlode2
33410: PPUSH
33411: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33415: LD_VAR 0 1
33419: PPUSH
33420: CALL_OW 255
33424: PUSH
33425: LD_INT 8
33427: EQUAL
33428: IFFALSE 33444
// begin wait ( 0 0$6 ) ;
33430: LD_INT 210
33432: PPUSH
33433: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33437: LD_STRING Motherlode1
33439: PPUSH
33440: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33444: LD_VAR 0 1
33448: PPUSH
33449: CALL_OW 255
33453: PUSH
33454: LD_INT 3
33456: EQUAL
33457: IFFALSE 33478
// begin wait ( 0 0$5 ) ;
33459: LD_INT 175
33461: PPUSH
33462: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33466: LD_EXP 64
33470: PPUSH
33471: LD_STRING D18-Pla-1
33473: PPUSH
33474: CALL_OW 94
// end ; end ;
33478: PPOPN 3
33480: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33481: LD_VAR 0 1
33485: PUSH
33486: LD_EXP 73
33490: IN
33491: IFFALSE 33511
// begin behemothBuilders := behemothBuilders diff un ;
33493: LD_ADDR_EXP 73
33497: PUSH
33498: LD_EXP 73
33502: PUSH
33503: LD_VAR 0 1
33507: DIFF
33508: ST_TO_ADDR
// exit ;
33509: GO 33609
// end ; if un = JMM then
33511: LD_VAR 0 1
33515: PUSH
33516: LD_EXP 39
33520: EQUAL
33521: IFFALSE 33532
// begin YouLost ( JMM ) ;
33523: LD_STRING JMM
33525: PPUSH
33526: CALL_OW 104
// exit ;
33530: GO 33609
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33532: LD_VAR 0 1
33536: PUSH
33537: LD_INT 22
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 3
33549: PUSH
33550: LD_INT 25
33552: PUSH
33553: LD_INT 16
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 25
33562: PUSH
33563: LD_INT 12
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: LIST
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PPUSH
33579: CALL_OW 69
33583: IN
33584: IFFALSE 33600
// lostCounter := lostCounter + 1 ;
33586: LD_ADDR_EXP 32
33590: PUSH
33591: LD_EXP 32
33595: PUSH
33596: LD_INT 1
33598: PLUS
33599: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33600: LD_VAR 0 1
33604: PPUSH
33605: CALL 61789 0 1
// end ;
33609: PPOPN 1
33611: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33612: LD_VAR 0 1
33616: PPUSH
33617: LD_VAR 0 2
33621: PPUSH
33622: CALL 64123 0 2
// end ;
33626: PPOPN 2
33628: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33629: LD_VAR 0 1
33633: PPUSH
33634: CALL 63191 0 1
// end ;
33638: PPOPN 1
33640: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33641: LD_VAR 0 1
33645: PUSH
33646: LD_INT 22
33648: PUSH
33649: LD_INT 8
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 30
33658: PUSH
33659: LD_INT 2
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 23
33668: PUSH
33669: LD_INT 3
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: LIST
33680: PPUSH
33681: CALL_OW 69
33685: IN
33686: IFFALSE 33713
// begin ComUpgrade ( building ) ;
33688: LD_VAR 0 1
33692: PPUSH
33693: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33697: LD_EXP 61
33701: PPUSH
33702: LD_VAR 0 1
33706: PPUSH
33707: CALL 74829 0 2
// exit ;
33711: GO 33722
// end ; MCE_BuildingComplete ( building ) ;
33713: LD_VAR 0 1
33717: PPUSH
33718: CALL 63432 0 1
// end ;
33722: PPOPN 1
33724: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33725: LD_VAR 0 1
33729: PPUSH
33730: LD_VAR 0 2
33734: PPUSH
33735: CALL 61485 0 2
// end ;
33739: PPOPN 2
33741: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33742: LD_VAR 0 1
33746: PPUSH
33747: LD_VAR 0 2
33751: PPUSH
33752: LD_VAR 0 3
33756: PPUSH
33757: LD_VAR 0 4
33761: PPUSH
33762: LD_VAR 0 5
33766: PPUSH
33767: CALL 61105 0 5
// end ;
33771: PPOPN 5
33773: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33774: LD_VAR 0 1
33778: PPUSH
33779: LD_VAR 0 2
33783: PPUSH
33784: CALL 60701 0 2
// end ;
33788: PPOPN 2
33790: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33791: LD_VAR 0 1
33795: PPUSH
33796: LD_VAR 0 2
33800: PPUSH
33801: LD_VAR 0 3
33805: PPUSH
33806: LD_VAR 0 4
33810: PPUSH
33811: CALL 60539 0 4
// end ;
33815: PPOPN 4
33817: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33818: LD_VAR 0 1
33822: PPUSH
33823: LD_VAR 0 2
33827: PPUSH
33828: LD_VAR 0 3
33832: PPUSH
33833: CALL 60314 0 3
// end ;
33837: PPOPN 3
33839: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33840: LD_VAR 0 1
33844: PPUSH
33845: LD_VAR 0 2
33849: PPUSH
33850: CALL 60199 0 2
// end ;
33854: PPOPN 2
33856: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33857: LD_VAR 0 1
33861: PPUSH
33862: LD_VAR 0 2
33866: PPUSH
33867: CALL 64384 0 2
// end ;
33871: PPOPN 2
33873: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33874: LD_VAR 0 1
33878: PPUSH
33879: CALL_OW 255
33883: PUSH
33884: LD_INT 4
33886: EQUAL
33887: PUSH
33888: LD_VAR 0 1
33892: PUSH
33893: LD_EXP 18
33897: PUSH
33898: LD_INT 1
33900: ARRAY
33901: IN
33902: AND
33903: PUSH
33904: LD_EXP 19
33908: AND
33909: IFFALSE 33928
// begin ComMoveXY ( driver , 61 , 93 ) ;
33911: LD_VAR 0 1
33915: PPUSH
33916: LD_INT 61
33918: PPUSH
33919: LD_INT 93
33921: PPUSH
33922: CALL_OW 111
// exit ;
33926: GO 33952
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33928: LD_VAR 0 1
33932: PPUSH
33933: LD_VAR 0 2
33937: PPUSH
33938: LD_VAR 0 3
33942: PPUSH
33943: LD_VAR 0 4
33947: PPUSH
33948: CALL 64600 0 4
// end ;
33952: PPOPN 4
33954: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33955: LD_VAR 0 1
33959: PPUSH
33960: LD_VAR 0 2
33964: PPUSH
33965: CALL 60008 0 2
// end ;
33969: PPOPN 2
33971: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33972: LD_VAR 0 1
33976: PPUSH
33977: CALL 108004 0 1
// end ; end_of_file
33981: PPOPN 1
33983: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33984: LD_EXP 15
33988: PUSH
33989: LD_INT 2
33991: EQUAL
33992: IFFALSE 34471
33994: GO 33996
33996: DISABLE
33997: LD_INT 0
33999: PPUSH
// begin time := 0 0$40 ;
34000: LD_ADDR_VAR 0 1
34004: PUSH
34005: LD_INT 1400
34007: ST_TO_ADDR
// repeat wait ( time ) ;
34008: LD_VAR 0 1
34012: PPUSH
34013: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34017: LD_INT 1
34019: PPUSH
34020: LD_INT 5
34022: PPUSH
34023: CALL_OW 12
34027: PPUSH
34028: LD_INT 106
34030: PPUSH
34031: LD_INT 150
34033: PPUSH
34034: LD_INT 19
34036: PPUSH
34037: LD_INT 1
34039: PPUSH
34040: CALL_OW 56
// time := time + 0 0$9 ;
34044: LD_ADDR_VAR 0 1
34048: PUSH
34049: LD_VAR 0 1
34053: PUSH
34054: LD_INT 315
34056: PLUS
34057: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34058: LD_INT 455
34060: PPUSH
34061: LD_INT 840
34063: PPUSH
34064: CALL_OW 12
34068: PPUSH
34069: CALL_OW 67
// if Prob ( 50 ) then
34073: LD_INT 50
34075: PPUSH
34076: CALL_OW 13
34080: IFFALSE 34109
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34082: LD_INT 1
34084: PPUSH
34085: LD_INT 5
34087: PPUSH
34088: CALL_OW 12
34092: PPUSH
34093: LD_INT 62
34095: PPUSH
34096: LD_INT 108
34098: PPUSH
34099: LD_INT 10
34101: PPUSH
34102: LD_INT 1
34104: PPUSH
34105: CALL_OW 56
// until missionStage > 4 ;
34109: LD_EXP 15
34113: PUSH
34114: LD_INT 4
34116: GREATER
34117: IFFALSE 34008
// repeat wait ( 0 0$1 ) ;
34119: LD_INT 35
34121: PPUSH
34122: CALL_OW 67
// until missionStage = 6 ;
34126: LD_EXP 15
34130: PUSH
34131: LD_INT 6
34133: EQUAL
34134: IFFALSE 34119
// time := 0 0$50 ;
34136: LD_ADDR_VAR 0 1
34140: PUSH
34141: LD_INT 1750
34143: ST_TO_ADDR
// repeat wait ( time ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: CALL_OW 67
// if Prob ( 50 ) then
34153: LD_INT 50
34155: PPUSH
34156: CALL_OW 13
34160: IFFALSE 34189
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34162: LD_INT 1
34164: PPUSH
34165: LD_INT 5
34167: PPUSH
34168: CALL_OW 12
34172: PPUSH
34173: LD_INT 106
34175: PPUSH
34176: LD_INT 89
34178: PPUSH
34179: LD_INT 45
34181: PPUSH
34182: LD_INT 1
34184: PPUSH
34185: CALL_OW 56
// time := time + 0 0$3 ;
34189: LD_ADDR_VAR 0 1
34193: PUSH
34194: LD_VAR 0 1
34198: PUSH
34199: LD_INT 105
34201: PLUS
34202: ST_TO_ADDR
// if Prob ( 30 ) then
34203: LD_INT 30
34205: PPUSH
34206: CALL_OW 13
34210: IFFALSE 34256
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
34212: LD_INT 525
34214: PPUSH
34215: LD_INT 735
34217: PPUSH
34218: CALL_OW 12
34222: PPUSH
34223: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34227: LD_INT 1
34229: PPUSH
34230: LD_INT 5
34232: PPUSH
34233: CALL_OW 12
34237: PPUSH
34238: LD_INT 21
34240: PPUSH
34241: LD_INT 26
34243: PPUSH
34244: LD_INT 12
34246: PPUSH
34247: LD_INT 1
34249: PPUSH
34250: CALL_OW 56
// end else
34254: GO 34292
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34256: LD_INT 700
34258: PPUSH
34259: LD_INT 1225
34261: PPUSH
34262: CALL_OW 12
34266: PPUSH
34267: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34271: LD_INT 1
34273: PPUSH
34274: LD_INT 5
34276: PPUSH
34277: CALL_OW 12
34281: PPUSH
34282: LD_INT 16
34284: PPUSH
34285: LD_INT 1
34287: PPUSH
34288: CALL_OW 55
// end ; if Prob ( 50 ) then
34292: LD_INT 50
34294: PPUSH
34295: CALL_OW 13
34299: IFFALSE 34345
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34301: LD_INT 700
34303: PPUSH
34304: LD_INT 1050
34306: PPUSH
34307: CALL_OW 12
34311: PPUSH
34312: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34316: LD_INT 1
34318: PPUSH
34319: LD_INT 5
34321: PPUSH
34322: CALL_OW 12
34326: PPUSH
34327: LD_INT 181
34329: PPUSH
34330: LD_INT 218
34332: PPUSH
34333: LD_INT 16
34335: PPUSH
34336: LD_INT 1
34338: PPUSH
34339: CALL_OW 56
// end else
34343: GO 34381
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34345: LD_INT 350
34347: PPUSH
34348: LD_INT 525
34350: PPUSH
34351: CALL_OW 12
34355: PPUSH
34356: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34360: LD_INT 1
34362: PPUSH
34363: LD_INT 5
34365: PPUSH
34366: CALL_OW 12
34370: PPUSH
34371: LD_INT 15
34373: PPUSH
34374: LD_INT 1
34376: PPUSH
34377: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34381: LD_INT 45
34383: PUSH
34384: LD_INT 32
34386: PUSH
34387: LD_INT 25
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: LIST
34394: PUSH
34395: LD_OWVAR 67
34399: ARRAY
34400: PPUSH
34401: CALL_OW 13
34405: IFFALSE 34449
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
34407: LD_INT 525
34409: PPUSH
34410: LD_INT 875
34412: PPUSH
34413: CALL_OW 12
34417: PPUSH
34418: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34422: LD_INT 1
34424: PPUSH
34425: LD_INT 5
34427: PPUSH
34428: CALL_OW 12
34432: PPUSH
34433: LD_INT 103
34435: PPUSH
34436: LD_INT 140
34438: PPUSH
34439: LD_INT 20
34441: PPUSH
34442: LD_INT 1
34444: PPUSH
34445: CALL_OW 56
// end ; if time > 1 1$40 then
34449: LD_VAR 0 1
34453: PUSH
34454: LD_INT 3500
34456: GREATER
34457: IFFALSE 34467
// time := 0 0$50 ;
34459: LD_ADDR_VAR 0 1
34463: PUSH
34464: LD_INT 1750
34466: ST_TO_ADDR
// until false ;
34467: LD_INT 0
34469: IFFALSE 34144
// end ; end_of_file
34471: PPOPN 1
34473: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34474: LD_EXP 13
34478: PUSH
34479: LD_EXP 15
34483: PUSH
34484: LD_INT 6
34486: GREATEREQUAL
34487: AND
34488: IFFALSE 34525
34490: GO 34492
34492: DISABLE
// begin enable ;
34493: ENABLE
// missionTime := missionTime + 0 0$1 ;
34494: LD_ADDR_EXP 14
34498: PUSH
34499: LD_EXP 14
34503: PUSH
34504: LD_INT 35
34506: PLUS
34507: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34508: LD_ADDR_OWVAR 47
34512: PUSH
34513: LD_STRING #Am15-1
34515: PUSH
34516: LD_EXP 14
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: ST_TO_ADDR
// end ; end_of_file
34525: END
// export function InitNature ; begin
34526: LD_INT 0
34528: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34529: LD_INT 3
34531: PPUSH
34532: LD_INT 3
34534: PPUSH
34535: LD_INT 2
34537: PPUSH
34538: LD_INT 1
34540: PPUSH
34541: LD_INT 1
34543: PPUSH
34544: LD_INT 0
34546: PPUSH
34547: LD_INT 0
34549: PPUSH
34550: LD_INT 20
34552: PPUSH
34553: LD_INT 0
34555: PPUSH
34556: CALL 99647 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34560: LD_INT 2
34562: PPUSH
34563: LD_INT 1
34565: PPUSH
34566: LD_INT 1
34568: PPUSH
34569: LD_INT 1
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: LD_INT 0
34577: PPUSH
34578: LD_INT 0
34580: PPUSH
34581: LD_INT 21
34583: PPUSH
34584: LD_INT 0
34586: PPUSH
34587: CALL 99647 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34591: LD_INT 4
34593: PPUSH
34594: LD_INT 1
34596: PPUSH
34597: LD_INT 2
34599: PPUSH
34600: LD_INT 4
34602: PPUSH
34603: LD_INT 2
34605: PPUSH
34606: LD_INT 1
34608: PPUSH
34609: LD_INT 0
34611: PPUSH
34612: LD_INT 22
34614: PPUSH
34615: LD_INT 0
34617: PPUSH
34618: CALL 99647 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34622: LD_INT 0
34624: PPUSH
34625: LD_INT 0
34627: PPUSH
34628: LD_INT 0
34630: PPUSH
34631: LD_INT 0
34633: PPUSH
34634: LD_INT 0
34636: PPUSH
34637: LD_INT 0
34639: PPUSH
34640: LD_INT 9
34642: PPUSH
34643: LD_INT 0
34645: PPUSH
34646: LD_INT 23
34648: PPUSH
34649: CALL 99647 0 9
// end ; end_of_file
34653: LD_VAR 0 1
34657: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34658: GO 34660
34660: DISABLE
// begin ru_radar := 98 ;
34661: LD_ADDR_EXP 95
34665: PUSH
34666: LD_INT 98
34668: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34669: LD_ADDR_EXP 96
34673: PUSH
34674: LD_INT 89
34676: ST_TO_ADDR
// us_hack := 99 ;
34677: LD_ADDR_EXP 97
34681: PUSH
34682: LD_INT 99
34684: ST_TO_ADDR
// us_artillery := 97 ;
34685: LD_ADDR_EXP 98
34689: PUSH
34690: LD_INT 97
34692: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34693: LD_ADDR_EXP 99
34697: PUSH
34698: LD_INT 91
34700: ST_TO_ADDR
// end ; end_of_file
34701: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34702: LD_INT 0
34704: PPUSH
34705: PPUSH
// skirmish := false ;
34706: LD_ADDR_EXP 100
34710: PUSH
34711: LD_INT 0
34713: ST_TO_ADDR
// debug_mc := false ;
34714: LD_ADDR_EXP 101
34718: PUSH
34719: LD_INT 0
34721: ST_TO_ADDR
// mc_bases := [ ] ;
34722: LD_ADDR_EXP 102
34726: PUSH
34727: EMPTY
34728: ST_TO_ADDR
// mc_sides := [ ] ;
34729: LD_ADDR_EXP 128
34733: PUSH
34734: EMPTY
34735: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34736: LD_ADDR_EXP 103
34740: PUSH
34741: EMPTY
34742: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34743: LD_ADDR_EXP 104
34747: PUSH
34748: EMPTY
34749: ST_TO_ADDR
// mc_need_heal := [ ] ;
34750: LD_ADDR_EXP 105
34754: PUSH
34755: EMPTY
34756: ST_TO_ADDR
// mc_healers := [ ] ;
34757: LD_ADDR_EXP 106
34761: PUSH
34762: EMPTY
34763: ST_TO_ADDR
// mc_build_list := [ ] ;
34764: LD_ADDR_EXP 107
34768: PUSH
34769: EMPTY
34770: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34771: LD_ADDR_EXP 134
34775: PUSH
34776: EMPTY
34777: ST_TO_ADDR
// mc_builders := [ ] ;
34778: LD_ADDR_EXP 108
34782: PUSH
34783: EMPTY
34784: ST_TO_ADDR
// mc_construct_list := [ ] ;
34785: LD_ADDR_EXP 109
34789: PUSH
34790: EMPTY
34791: ST_TO_ADDR
// mc_turret_list := [ ] ;
34792: LD_ADDR_EXP 110
34796: PUSH
34797: EMPTY
34798: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34799: LD_ADDR_EXP 111
34803: PUSH
34804: EMPTY
34805: ST_TO_ADDR
// mc_miners := [ ] ;
34806: LD_ADDR_EXP 116
34810: PUSH
34811: EMPTY
34812: ST_TO_ADDR
// mc_mines := [ ] ;
34813: LD_ADDR_EXP 115
34817: PUSH
34818: EMPTY
34819: ST_TO_ADDR
// mc_minefields := [ ] ;
34820: LD_ADDR_EXP 117
34824: PUSH
34825: EMPTY
34826: ST_TO_ADDR
// mc_crates := [ ] ;
34827: LD_ADDR_EXP 118
34831: PUSH
34832: EMPTY
34833: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34834: LD_ADDR_EXP 119
34838: PUSH
34839: EMPTY
34840: ST_TO_ADDR
// mc_crates_area := [ ] ;
34841: LD_ADDR_EXP 120
34845: PUSH
34846: EMPTY
34847: ST_TO_ADDR
// mc_vehicles := [ ] ;
34848: LD_ADDR_EXP 121
34852: PUSH
34853: EMPTY
34854: ST_TO_ADDR
// mc_attack := [ ] ;
34855: LD_ADDR_EXP 122
34859: PUSH
34860: EMPTY
34861: ST_TO_ADDR
// mc_produce := [ ] ;
34862: LD_ADDR_EXP 123
34866: PUSH
34867: EMPTY
34868: ST_TO_ADDR
// mc_defender := [ ] ;
34869: LD_ADDR_EXP 124
34873: PUSH
34874: EMPTY
34875: ST_TO_ADDR
// mc_parking := [ ] ;
34876: LD_ADDR_EXP 126
34880: PUSH
34881: EMPTY
34882: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34883: LD_ADDR_EXP 112
34887: PUSH
34888: EMPTY
34889: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34890: LD_ADDR_EXP 114
34894: PUSH
34895: EMPTY
34896: ST_TO_ADDR
// mc_scan := [ ] ;
34897: LD_ADDR_EXP 125
34901: PUSH
34902: EMPTY
34903: ST_TO_ADDR
// mc_scan_area := [ ] ;
34904: LD_ADDR_EXP 127
34908: PUSH
34909: EMPTY
34910: ST_TO_ADDR
// mc_tech := [ ] ;
34911: LD_ADDR_EXP 129
34915: PUSH
34916: EMPTY
34917: ST_TO_ADDR
// mc_class := [ ] ;
34918: LD_ADDR_EXP 143
34922: PUSH
34923: EMPTY
34924: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34925: LD_ADDR_EXP 144
34929: PUSH
34930: EMPTY
34931: ST_TO_ADDR
// end ;
34932: LD_VAR 0 1
34936: RET
// export function MC_Kill ( base ) ; begin
34937: LD_INT 0
34939: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34940: LD_ADDR_EXP 102
34944: PUSH
34945: LD_EXP 102
34949: PPUSH
34950: LD_VAR 0 1
34954: PPUSH
34955: EMPTY
34956: PPUSH
34957: CALL_OW 1
34961: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34962: LD_ADDR_EXP 103
34966: PUSH
34967: LD_EXP 103
34971: PPUSH
34972: LD_VAR 0 1
34976: PPUSH
34977: EMPTY
34978: PPUSH
34979: CALL_OW 1
34983: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34984: LD_ADDR_EXP 104
34988: PUSH
34989: LD_EXP 104
34993: PPUSH
34994: LD_VAR 0 1
34998: PPUSH
34999: EMPTY
35000: PPUSH
35001: CALL_OW 1
35005: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35006: LD_ADDR_EXP 105
35010: PUSH
35011: LD_EXP 105
35015: PPUSH
35016: LD_VAR 0 1
35020: PPUSH
35021: EMPTY
35022: PPUSH
35023: CALL_OW 1
35027: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35028: LD_ADDR_EXP 106
35032: PUSH
35033: LD_EXP 106
35037: PPUSH
35038: LD_VAR 0 1
35042: PPUSH
35043: EMPTY
35044: PPUSH
35045: CALL_OW 1
35049: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35050: LD_ADDR_EXP 107
35054: PUSH
35055: LD_EXP 107
35059: PPUSH
35060: LD_VAR 0 1
35064: PPUSH
35065: EMPTY
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35072: LD_ADDR_EXP 108
35076: PUSH
35077: LD_EXP 108
35081: PPUSH
35082: LD_VAR 0 1
35086: PPUSH
35087: EMPTY
35088: PPUSH
35089: CALL_OW 1
35093: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35094: LD_ADDR_EXP 109
35098: PUSH
35099: LD_EXP 109
35103: PPUSH
35104: LD_VAR 0 1
35108: PPUSH
35109: EMPTY
35110: PPUSH
35111: CALL_OW 1
35115: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35116: LD_ADDR_EXP 110
35120: PUSH
35121: LD_EXP 110
35125: PPUSH
35126: LD_VAR 0 1
35130: PPUSH
35131: EMPTY
35132: PPUSH
35133: CALL_OW 1
35137: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35138: LD_ADDR_EXP 111
35142: PUSH
35143: LD_EXP 111
35147: PPUSH
35148: LD_VAR 0 1
35152: PPUSH
35153: EMPTY
35154: PPUSH
35155: CALL_OW 1
35159: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35160: LD_ADDR_EXP 112
35164: PUSH
35165: LD_EXP 112
35169: PPUSH
35170: LD_VAR 0 1
35174: PPUSH
35175: EMPTY
35176: PPUSH
35177: CALL_OW 1
35181: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35182: LD_ADDR_EXP 113
35186: PUSH
35187: LD_EXP 113
35191: PPUSH
35192: LD_VAR 0 1
35196: PPUSH
35197: LD_INT 0
35199: PPUSH
35200: CALL_OW 1
35204: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35205: LD_ADDR_EXP 114
35209: PUSH
35210: LD_EXP 114
35214: PPUSH
35215: LD_VAR 0 1
35219: PPUSH
35220: EMPTY
35221: PPUSH
35222: CALL_OW 1
35226: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35227: LD_ADDR_EXP 115
35231: PUSH
35232: LD_EXP 115
35236: PPUSH
35237: LD_VAR 0 1
35241: PPUSH
35242: EMPTY
35243: PPUSH
35244: CALL_OW 1
35248: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35249: LD_ADDR_EXP 116
35253: PUSH
35254: LD_EXP 116
35258: PPUSH
35259: LD_VAR 0 1
35263: PPUSH
35264: EMPTY
35265: PPUSH
35266: CALL_OW 1
35270: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35271: LD_ADDR_EXP 117
35275: PUSH
35276: LD_EXP 117
35280: PPUSH
35281: LD_VAR 0 1
35285: PPUSH
35286: EMPTY
35287: PPUSH
35288: CALL_OW 1
35292: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35293: LD_ADDR_EXP 118
35297: PUSH
35298: LD_EXP 118
35302: PPUSH
35303: LD_VAR 0 1
35307: PPUSH
35308: EMPTY
35309: PPUSH
35310: CALL_OW 1
35314: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35315: LD_ADDR_EXP 119
35319: PUSH
35320: LD_EXP 119
35324: PPUSH
35325: LD_VAR 0 1
35329: PPUSH
35330: EMPTY
35331: PPUSH
35332: CALL_OW 1
35336: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35337: LD_ADDR_EXP 120
35341: PUSH
35342: LD_EXP 120
35346: PPUSH
35347: LD_VAR 0 1
35351: PPUSH
35352: EMPTY
35353: PPUSH
35354: CALL_OW 1
35358: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35359: LD_ADDR_EXP 121
35363: PUSH
35364: LD_EXP 121
35368: PPUSH
35369: LD_VAR 0 1
35373: PPUSH
35374: EMPTY
35375: PPUSH
35376: CALL_OW 1
35380: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35381: LD_ADDR_EXP 122
35385: PUSH
35386: LD_EXP 122
35390: PPUSH
35391: LD_VAR 0 1
35395: PPUSH
35396: EMPTY
35397: PPUSH
35398: CALL_OW 1
35402: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35403: LD_ADDR_EXP 123
35407: PUSH
35408: LD_EXP 123
35412: PPUSH
35413: LD_VAR 0 1
35417: PPUSH
35418: EMPTY
35419: PPUSH
35420: CALL_OW 1
35424: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35425: LD_ADDR_EXP 124
35429: PUSH
35430: LD_EXP 124
35434: PPUSH
35435: LD_VAR 0 1
35439: PPUSH
35440: EMPTY
35441: PPUSH
35442: CALL_OW 1
35446: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35447: LD_ADDR_EXP 125
35451: PUSH
35452: LD_EXP 125
35456: PPUSH
35457: LD_VAR 0 1
35461: PPUSH
35462: EMPTY
35463: PPUSH
35464: CALL_OW 1
35468: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35469: LD_ADDR_EXP 126
35473: PUSH
35474: LD_EXP 126
35478: PPUSH
35479: LD_VAR 0 1
35483: PPUSH
35484: EMPTY
35485: PPUSH
35486: CALL_OW 1
35490: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35491: LD_ADDR_EXP 127
35495: PUSH
35496: LD_EXP 127
35500: PPUSH
35501: LD_VAR 0 1
35505: PPUSH
35506: EMPTY
35507: PPUSH
35508: CALL_OW 1
35512: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35513: LD_ADDR_EXP 129
35517: PUSH
35518: LD_EXP 129
35522: PPUSH
35523: LD_VAR 0 1
35527: PPUSH
35528: EMPTY
35529: PPUSH
35530: CALL_OW 1
35534: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35535: LD_ADDR_EXP 131
35539: PUSH
35540: LD_EXP 131
35544: PPUSH
35545: LD_VAR 0 1
35549: PPUSH
35550: EMPTY
35551: PPUSH
35552: CALL_OW 1
35556: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35557: LD_ADDR_EXP 132
35561: PUSH
35562: LD_EXP 132
35566: PPUSH
35567: LD_VAR 0 1
35571: PPUSH
35572: EMPTY
35573: PPUSH
35574: CALL_OW 1
35578: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35579: LD_ADDR_EXP 133
35583: PUSH
35584: LD_EXP 133
35588: PPUSH
35589: LD_VAR 0 1
35593: PPUSH
35594: EMPTY
35595: PPUSH
35596: CALL_OW 1
35600: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35601: LD_ADDR_EXP 134
35605: PUSH
35606: LD_EXP 134
35610: PPUSH
35611: LD_VAR 0 1
35615: PPUSH
35616: EMPTY
35617: PPUSH
35618: CALL_OW 1
35622: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35623: LD_ADDR_EXP 135
35627: PUSH
35628: LD_EXP 135
35632: PPUSH
35633: LD_VAR 0 1
35637: PPUSH
35638: EMPTY
35639: PPUSH
35640: CALL_OW 1
35644: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35645: LD_ADDR_EXP 136
35649: PUSH
35650: LD_EXP 136
35654: PPUSH
35655: LD_VAR 0 1
35659: PPUSH
35660: EMPTY
35661: PPUSH
35662: CALL_OW 1
35666: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35667: LD_ADDR_EXP 137
35671: PUSH
35672: LD_EXP 137
35676: PPUSH
35677: LD_VAR 0 1
35681: PPUSH
35682: EMPTY
35683: PPUSH
35684: CALL_OW 1
35688: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35689: LD_ADDR_EXP 138
35693: PUSH
35694: LD_EXP 138
35698: PPUSH
35699: LD_VAR 0 1
35703: PPUSH
35704: EMPTY
35705: PPUSH
35706: CALL_OW 1
35710: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35711: LD_ADDR_EXP 139
35715: PUSH
35716: LD_EXP 139
35720: PPUSH
35721: LD_VAR 0 1
35725: PPUSH
35726: EMPTY
35727: PPUSH
35728: CALL_OW 1
35732: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35733: LD_ADDR_EXP 140
35737: PUSH
35738: LD_EXP 140
35742: PPUSH
35743: LD_VAR 0 1
35747: PPUSH
35748: EMPTY
35749: PPUSH
35750: CALL_OW 1
35754: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35755: LD_ADDR_EXP 141
35759: PUSH
35760: LD_EXP 141
35764: PPUSH
35765: LD_VAR 0 1
35769: PPUSH
35770: EMPTY
35771: PPUSH
35772: CALL_OW 1
35776: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35777: LD_ADDR_EXP 142
35781: PUSH
35782: LD_EXP 142
35786: PPUSH
35787: LD_VAR 0 1
35791: PPUSH
35792: EMPTY
35793: PPUSH
35794: CALL_OW 1
35798: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35799: LD_ADDR_EXP 143
35803: PUSH
35804: LD_EXP 143
35808: PPUSH
35809: LD_VAR 0 1
35813: PPUSH
35814: EMPTY
35815: PPUSH
35816: CALL_OW 1
35820: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35821: LD_ADDR_EXP 144
35825: PUSH
35826: LD_EXP 144
35830: PPUSH
35831: LD_VAR 0 1
35835: PPUSH
35836: LD_INT 0
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// end ;
35844: LD_VAR 0 2
35848: RET
// export function MC_Add ( side , units ) ; var base ; begin
35849: LD_INT 0
35851: PPUSH
35852: PPUSH
// base := mc_bases + 1 ;
35853: LD_ADDR_VAR 0 4
35857: PUSH
35858: LD_EXP 102
35862: PUSH
35863: LD_INT 1
35865: PLUS
35866: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35867: LD_ADDR_EXP 128
35871: PUSH
35872: LD_EXP 128
35876: PPUSH
35877: LD_VAR 0 4
35881: PPUSH
35882: LD_VAR 0 1
35886: PPUSH
35887: CALL_OW 1
35891: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35892: LD_ADDR_EXP 102
35896: PUSH
35897: LD_EXP 102
35901: PPUSH
35902: LD_VAR 0 4
35906: PPUSH
35907: LD_VAR 0 2
35911: PPUSH
35912: CALL_OW 1
35916: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35917: LD_ADDR_EXP 103
35921: PUSH
35922: LD_EXP 103
35926: PPUSH
35927: LD_VAR 0 4
35931: PPUSH
35932: EMPTY
35933: PPUSH
35934: CALL_OW 1
35938: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35939: LD_ADDR_EXP 104
35943: PUSH
35944: LD_EXP 104
35948: PPUSH
35949: LD_VAR 0 4
35953: PPUSH
35954: EMPTY
35955: PPUSH
35956: CALL_OW 1
35960: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35961: LD_ADDR_EXP 105
35965: PUSH
35966: LD_EXP 105
35970: PPUSH
35971: LD_VAR 0 4
35975: PPUSH
35976: EMPTY
35977: PPUSH
35978: CALL_OW 1
35982: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35983: LD_ADDR_EXP 106
35987: PUSH
35988: LD_EXP 106
35992: PPUSH
35993: LD_VAR 0 4
35997: PPUSH
35998: EMPTY
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36005: LD_ADDR_EXP 107
36009: PUSH
36010: LD_EXP 107
36014: PPUSH
36015: LD_VAR 0 4
36019: PPUSH
36020: EMPTY
36021: PPUSH
36022: CALL_OW 1
36026: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36027: LD_ADDR_EXP 108
36031: PUSH
36032: LD_EXP 108
36036: PPUSH
36037: LD_VAR 0 4
36041: PPUSH
36042: EMPTY
36043: PPUSH
36044: CALL_OW 1
36048: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36049: LD_ADDR_EXP 109
36053: PUSH
36054: LD_EXP 109
36058: PPUSH
36059: LD_VAR 0 4
36063: PPUSH
36064: EMPTY
36065: PPUSH
36066: CALL_OW 1
36070: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36071: LD_ADDR_EXP 110
36075: PUSH
36076: LD_EXP 110
36080: PPUSH
36081: LD_VAR 0 4
36085: PPUSH
36086: EMPTY
36087: PPUSH
36088: CALL_OW 1
36092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36093: LD_ADDR_EXP 111
36097: PUSH
36098: LD_EXP 111
36102: PPUSH
36103: LD_VAR 0 4
36107: PPUSH
36108: EMPTY
36109: PPUSH
36110: CALL_OW 1
36114: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36115: LD_ADDR_EXP 112
36119: PUSH
36120: LD_EXP 112
36124: PPUSH
36125: LD_VAR 0 4
36129: PPUSH
36130: EMPTY
36131: PPUSH
36132: CALL_OW 1
36136: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36137: LD_ADDR_EXP 113
36141: PUSH
36142: LD_EXP 113
36146: PPUSH
36147: LD_VAR 0 4
36151: PPUSH
36152: LD_INT 0
36154: PPUSH
36155: CALL_OW 1
36159: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36160: LD_ADDR_EXP 114
36164: PUSH
36165: LD_EXP 114
36169: PPUSH
36170: LD_VAR 0 4
36174: PPUSH
36175: EMPTY
36176: PPUSH
36177: CALL_OW 1
36181: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36182: LD_ADDR_EXP 115
36186: PUSH
36187: LD_EXP 115
36191: PPUSH
36192: LD_VAR 0 4
36196: PPUSH
36197: EMPTY
36198: PPUSH
36199: CALL_OW 1
36203: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36204: LD_ADDR_EXP 116
36208: PUSH
36209: LD_EXP 116
36213: PPUSH
36214: LD_VAR 0 4
36218: PPUSH
36219: EMPTY
36220: PPUSH
36221: CALL_OW 1
36225: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36226: LD_ADDR_EXP 117
36230: PUSH
36231: LD_EXP 117
36235: PPUSH
36236: LD_VAR 0 4
36240: PPUSH
36241: EMPTY
36242: PPUSH
36243: CALL_OW 1
36247: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36248: LD_ADDR_EXP 118
36252: PUSH
36253: LD_EXP 118
36257: PPUSH
36258: LD_VAR 0 4
36262: PPUSH
36263: EMPTY
36264: PPUSH
36265: CALL_OW 1
36269: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36270: LD_ADDR_EXP 119
36274: PUSH
36275: LD_EXP 119
36279: PPUSH
36280: LD_VAR 0 4
36284: PPUSH
36285: EMPTY
36286: PPUSH
36287: CALL_OW 1
36291: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36292: LD_ADDR_EXP 120
36296: PUSH
36297: LD_EXP 120
36301: PPUSH
36302: LD_VAR 0 4
36306: PPUSH
36307: EMPTY
36308: PPUSH
36309: CALL_OW 1
36313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36314: LD_ADDR_EXP 121
36318: PUSH
36319: LD_EXP 121
36323: PPUSH
36324: LD_VAR 0 4
36328: PPUSH
36329: EMPTY
36330: PPUSH
36331: CALL_OW 1
36335: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36336: LD_ADDR_EXP 122
36340: PUSH
36341: LD_EXP 122
36345: PPUSH
36346: LD_VAR 0 4
36350: PPUSH
36351: EMPTY
36352: PPUSH
36353: CALL_OW 1
36357: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36358: LD_ADDR_EXP 123
36362: PUSH
36363: LD_EXP 123
36367: PPUSH
36368: LD_VAR 0 4
36372: PPUSH
36373: EMPTY
36374: PPUSH
36375: CALL_OW 1
36379: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36380: LD_ADDR_EXP 124
36384: PUSH
36385: LD_EXP 124
36389: PPUSH
36390: LD_VAR 0 4
36394: PPUSH
36395: EMPTY
36396: PPUSH
36397: CALL_OW 1
36401: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36402: LD_ADDR_EXP 125
36406: PUSH
36407: LD_EXP 125
36411: PPUSH
36412: LD_VAR 0 4
36416: PPUSH
36417: EMPTY
36418: PPUSH
36419: CALL_OW 1
36423: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36424: LD_ADDR_EXP 126
36428: PUSH
36429: LD_EXP 126
36433: PPUSH
36434: LD_VAR 0 4
36438: PPUSH
36439: EMPTY
36440: PPUSH
36441: CALL_OW 1
36445: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36446: LD_ADDR_EXP 127
36450: PUSH
36451: LD_EXP 127
36455: PPUSH
36456: LD_VAR 0 4
36460: PPUSH
36461: EMPTY
36462: PPUSH
36463: CALL_OW 1
36467: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36468: LD_ADDR_EXP 129
36472: PUSH
36473: LD_EXP 129
36477: PPUSH
36478: LD_VAR 0 4
36482: PPUSH
36483: EMPTY
36484: PPUSH
36485: CALL_OW 1
36489: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36490: LD_ADDR_EXP 131
36494: PUSH
36495: LD_EXP 131
36499: PPUSH
36500: LD_VAR 0 4
36504: PPUSH
36505: EMPTY
36506: PPUSH
36507: CALL_OW 1
36511: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36512: LD_ADDR_EXP 132
36516: PUSH
36517: LD_EXP 132
36521: PPUSH
36522: LD_VAR 0 4
36526: PPUSH
36527: EMPTY
36528: PPUSH
36529: CALL_OW 1
36533: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36534: LD_ADDR_EXP 133
36538: PUSH
36539: LD_EXP 133
36543: PPUSH
36544: LD_VAR 0 4
36548: PPUSH
36549: EMPTY
36550: PPUSH
36551: CALL_OW 1
36555: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36556: LD_ADDR_EXP 134
36560: PUSH
36561: LD_EXP 134
36565: PPUSH
36566: LD_VAR 0 4
36570: PPUSH
36571: EMPTY
36572: PPUSH
36573: CALL_OW 1
36577: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36578: LD_ADDR_EXP 135
36582: PUSH
36583: LD_EXP 135
36587: PPUSH
36588: LD_VAR 0 4
36592: PPUSH
36593: EMPTY
36594: PPUSH
36595: CALL_OW 1
36599: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36600: LD_ADDR_EXP 136
36604: PUSH
36605: LD_EXP 136
36609: PPUSH
36610: LD_VAR 0 4
36614: PPUSH
36615: EMPTY
36616: PPUSH
36617: CALL_OW 1
36621: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36622: LD_ADDR_EXP 137
36626: PUSH
36627: LD_EXP 137
36631: PPUSH
36632: LD_VAR 0 4
36636: PPUSH
36637: EMPTY
36638: PPUSH
36639: CALL_OW 1
36643: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36644: LD_ADDR_EXP 138
36648: PUSH
36649: LD_EXP 138
36653: PPUSH
36654: LD_VAR 0 4
36658: PPUSH
36659: EMPTY
36660: PPUSH
36661: CALL_OW 1
36665: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36666: LD_ADDR_EXP 139
36670: PUSH
36671: LD_EXP 139
36675: PPUSH
36676: LD_VAR 0 4
36680: PPUSH
36681: EMPTY
36682: PPUSH
36683: CALL_OW 1
36687: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36688: LD_ADDR_EXP 140
36692: PUSH
36693: LD_EXP 140
36697: PPUSH
36698: LD_VAR 0 4
36702: PPUSH
36703: EMPTY
36704: PPUSH
36705: CALL_OW 1
36709: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36710: LD_ADDR_EXP 141
36714: PUSH
36715: LD_EXP 141
36719: PPUSH
36720: LD_VAR 0 4
36724: PPUSH
36725: EMPTY
36726: PPUSH
36727: CALL_OW 1
36731: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36732: LD_ADDR_EXP 142
36736: PUSH
36737: LD_EXP 142
36741: PPUSH
36742: LD_VAR 0 4
36746: PPUSH
36747: EMPTY
36748: PPUSH
36749: CALL_OW 1
36753: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36754: LD_ADDR_EXP 143
36758: PUSH
36759: LD_EXP 143
36763: PPUSH
36764: LD_VAR 0 4
36768: PPUSH
36769: EMPTY
36770: PPUSH
36771: CALL_OW 1
36775: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36776: LD_ADDR_EXP 144
36780: PUSH
36781: LD_EXP 144
36785: PPUSH
36786: LD_VAR 0 4
36790: PPUSH
36791: LD_INT 0
36793: PPUSH
36794: CALL_OW 1
36798: ST_TO_ADDR
// result := base ;
36799: LD_ADDR_VAR 0 3
36803: PUSH
36804: LD_VAR 0 4
36808: ST_TO_ADDR
// end ;
36809: LD_VAR 0 3
36813: RET
// export function MC_Start ( ) ; var i ; begin
36814: LD_INT 0
36816: PPUSH
36817: PPUSH
// for i = 1 to mc_bases do
36818: LD_ADDR_VAR 0 2
36822: PUSH
36823: DOUBLE
36824: LD_INT 1
36826: DEC
36827: ST_TO_ADDR
36828: LD_EXP 102
36832: PUSH
36833: FOR_TO
36834: IFFALSE 37911
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36836: LD_ADDR_EXP 102
36840: PUSH
36841: LD_EXP 102
36845: PPUSH
36846: LD_VAR 0 2
36850: PPUSH
36851: LD_EXP 102
36855: PUSH
36856: LD_VAR 0 2
36860: ARRAY
36861: PUSH
36862: LD_INT 0
36864: DIFF
36865: PPUSH
36866: CALL_OW 1
36870: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36871: LD_ADDR_EXP 103
36875: PUSH
36876: LD_EXP 103
36880: PPUSH
36881: LD_VAR 0 2
36885: PPUSH
36886: EMPTY
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36893: LD_ADDR_EXP 104
36897: PUSH
36898: LD_EXP 104
36902: PPUSH
36903: LD_VAR 0 2
36907: PPUSH
36908: EMPTY
36909: PPUSH
36910: CALL_OW 1
36914: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36915: LD_ADDR_EXP 105
36919: PUSH
36920: LD_EXP 105
36924: PPUSH
36925: LD_VAR 0 2
36929: PPUSH
36930: EMPTY
36931: PPUSH
36932: CALL_OW 1
36936: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36937: LD_ADDR_EXP 106
36941: PUSH
36942: LD_EXP 106
36946: PPUSH
36947: LD_VAR 0 2
36951: PPUSH
36952: EMPTY
36953: PUSH
36954: EMPTY
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PPUSH
36960: CALL_OW 1
36964: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36965: LD_ADDR_EXP 107
36969: PUSH
36970: LD_EXP 107
36974: PPUSH
36975: LD_VAR 0 2
36979: PPUSH
36980: EMPTY
36981: PPUSH
36982: CALL_OW 1
36986: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36987: LD_ADDR_EXP 134
36991: PUSH
36992: LD_EXP 134
36996: PPUSH
36997: LD_VAR 0 2
37001: PPUSH
37002: EMPTY
37003: PPUSH
37004: CALL_OW 1
37008: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37009: LD_ADDR_EXP 108
37013: PUSH
37014: LD_EXP 108
37018: PPUSH
37019: LD_VAR 0 2
37023: PPUSH
37024: EMPTY
37025: PPUSH
37026: CALL_OW 1
37030: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37031: LD_ADDR_EXP 109
37035: PUSH
37036: LD_EXP 109
37040: PPUSH
37041: LD_VAR 0 2
37045: PPUSH
37046: EMPTY
37047: PPUSH
37048: CALL_OW 1
37052: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37053: LD_ADDR_EXP 110
37057: PUSH
37058: LD_EXP 110
37062: PPUSH
37063: LD_VAR 0 2
37067: PPUSH
37068: LD_EXP 102
37072: PUSH
37073: LD_VAR 0 2
37077: ARRAY
37078: PPUSH
37079: LD_INT 2
37081: PUSH
37082: LD_INT 30
37084: PUSH
37085: LD_INT 32
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 30
37094: PUSH
37095: LD_INT 33
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: LIST
37106: PPUSH
37107: CALL_OW 72
37111: PPUSH
37112: CALL_OW 1
37116: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37117: LD_ADDR_EXP 111
37121: PUSH
37122: LD_EXP 111
37126: PPUSH
37127: LD_VAR 0 2
37131: PPUSH
37132: LD_EXP 102
37136: PUSH
37137: LD_VAR 0 2
37141: ARRAY
37142: PPUSH
37143: LD_INT 2
37145: PUSH
37146: LD_INT 30
37148: PUSH
37149: LD_INT 32
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 30
37158: PUSH
37159: LD_INT 31
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 58
37173: PUSH
37174: EMPTY
37175: LIST
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PPUSH
37181: CALL_OW 72
37185: PPUSH
37186: CALL_OW 1
37190: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37191: LD_ADDR_EXP 112
37195: PUSH
37196: LD_EXP 112
37200: PPUSH
37201: LD_VAR 0 2
37205: PPUSH
37206: EMPTY
37207: PPUSH
37208: CALL_OW 1
37212: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37213: LD_ADDR_EXP 116
37217: PUSH
37218: LD_EXP 116
37222: PPUSH
37223: LD_VAR 0 2
37227: PPUSH
37228: EMPTY
37229: PPUSH
37230: CALL_OW 1
37234: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37235: LD_ADDR_EXP 115
37239: PUSH
37240: LD_EXP 115
37244: PPUSH
37245: LD_VAR 0 2
37249: PPUSH
37250: EMPTY
37251: PPUSH
37252: CALL_OW 1
37256: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37257: LD_ADDR_EXP 117
37261: PUSH
37262: LD_EXP 117
37266: PPUSH
37267: LD_VAR 0 2
37271: PPUSH
37272: EMPTY
37273: PPUSH
37274: CALL_OW 1
37278: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37279: LD_ADDR_EXP 118
37283: PUSH
37284: LD_EXP 118
37288: PPUSH
37289: LD_VAR 0 2
37293: PPUSH
37294: EMPTY
37295: PPUSH
37296: CALL_OW 1
37300: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37301: LD_ADDR_EXP 119
37305: PUSH
37306: LD_EXP 119
37310: PPUSH
37311: LD_VAR 0 2
37315: PPUSH
37316: EMPTY
37317: PPUSH
37318: CALL_OW 1
37322: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37323: LD_ADDR_EXP 120
37327: PUSH
37328: LD_EXP 120
37332: PPUSH
37333: LD_VAR 0 2
37337: PPUSH
37338: EMPTY
37339: PPUSH
37340: CALL_OW 1
37344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37345: LD_ADDR_EXP 121
37349: PUSH
37350: LD_EXP 121
37354: PPUSH
37355: LD_VAR 0 2
37359: PPUSH
37360: EMPTY
37361: PPUSH
37362: CALL_OW 1
37366: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37367: LD_ADDR_EXP 122
37371: PUSH
37372: LD_EXP 122
37376: PPUSH
37377: LD_VAR 0 2
37381: PPUSH
37382: EMPTY
37383: PPUSH
37384: CALL_OW 1
37388: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37389: LD_ADDR_EXP 123
37393: PUSH
37394: LD_EXP 123
37398: PPUSH
37399: LD_VAR 0 2
37403: PPUSH
37404: EMPTY
37405: PPUSH
37406: CALL_OW 1
37410: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37411: LD_ADDR_EXP 124
37415: PUSH
37416: LD_EXP 124
37420: PPUSH
37421: LD_VAR 0 2
37425: PPUSH
37426: EMPTY
37427: PPUSH
37428: CALL_OW 1
37432: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37433: LD_ADDR_EXP 113
37437: PUSH
37438: LD_EXP 113
37442: PPUSH
37443: LD_VAR 0 2
37447: PPUSH
37448: LD_INT 0
37450: PPUSH
37451: CALL_OW 1
37455: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37456: LD_ADDR_EXP 126
37460: PUSH
37461: LD_EXP 126
37465: PPUSH
37466: LD_VAR 0 2
37470: PPUSH
37471: LD_INT 0
37473: PPUSH
37474: CALL_OW 1
37478: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37479: LD_ADDR_EXP 114
37483: PUSH
37484: LD_EXP 114
37488: PPUSH
37489: LD_VAR 0 2
37493: PPUSH
37494: EMPTY
37495: PPUSH
37496: CALL_OW 1
37500: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37501: LD_ADDR_EXP 125
37505: PUSH
37506: LD_EXP 125
37510: PPUSH
37511: LD_VAR 0 2
37515: PPUSH
37516: LD_INT 0
37518: PPUSH
37519: CALL_OW 1
37523: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37524: LD_ADDR_EXP 127
37528: PUSH
37529: LD_EXP 127
37533: PPUSH
37534: LD_VAR 0 2
37538: PPUSH
37539: EMPTY
37540: PPUSH
37541: CALL_OW 1
37545: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37546: LD_ADDR_EXP 130
37550: PUSH
37551: LD_EXP 130
37555: PPUSH
37556: LD_VAR 0 2
37560: PPUSH
37561: LD_INT 0
37563: PPUSH
37564: CALL_OW 1
37568: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37569: LD_ADDR_EXP 131
37573: PUSH
37574: LD_EXP 131
37578: PPUSH
37579: LD_VAR 0 2
37583: PPUSH
37584: EMPTY
37585: PPUSH
37586: CALL_OW 1
37590: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37591: LD_ADDR_EXP 132
37595: PUSH
37596: LD_EXP 132
37600: PPUSH
37601: LD_VAR 0 2
37605: PPUSH
37606: EMPTY
37607: PPUSH
37608: CALL_OW 1
37612: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37613: LD_ADDR_EXP 133
37617: PUSH
37618: LD_EXP 133
37622: PPUSH
37623: LD_VAR 0 2
37627: PPUSH
37628: EMPTY
37629: PPUSH
37630: CALL_OW 1
37634: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37635: LD_ADDR_EXP 135
37639: PUSH
37640: LD_EXP 135
37644: PPUSH
37645: LD_VAR 0 2
37649: PPUSH
37650: LD_EXP 102
37654: PUSH
37655: LD_VAR 0 2
37659: ARRAY
37660: PPUSH
37661: LD_INT 2
37663: PUSH
37664: LD_INT 30
37666: PUSH
37667: LD_INT 6
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 30
37676: PUSH
37677: LD_INT 7
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 30
37686: PUSH
37687: LD_INT 8
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: PPUSH
37700: CALL_OW 72
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37710: LD_ADDR_EXP 136
37714: PUSH
37715: LD_EXP 136
37719: PPUSH
37720: LD_VAR 0 2
37724: PPUSH
37725: EMPTY
37726: PPUSH
37727: CALL_OW 1
37731: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37732: LD_ADDR_EXP 137
37736: PUSH
37737: LD_EXP 137
37741: PPUSH
37742: LD_VAR 0 2
37746: PPUSH
37747: EMPTY
37748: PPUSH
37749: CALL_OW 1
37753: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37754: LD_ADDR_EXP 138
37758: PUSH
37759: LD_EXP 138
37763: PPUSH
37764: LD_VAR 0 2
37768: PPUSH
37769: EMPTY
37770: PPUSH
37771: CALL_OW 1
37775: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37776: LD_ADDR_EXP 139
37780: PUSH
37781: LD_EXP 139
37785: PPUSH
37786: LD_VAR 0 2
37790: PPUSH
37791: EMPTY
37792: PPUSH
37793: CALL_OW 1
37797: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37798: LD_ADDR_EXP 140
37802: PUSH
37803: LD_EXP 140
37807: PPUSH
37808: LD_VAR 0 2
37812: PPUSH
37813: EMPTY
37814: PPUSH
37815: CALL_OW 1
37819: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37820: LD_ADDR_EXP 141
37824: PUSH
37825: LD_EXP 141
37829: PPUSH
37830: LD_VAR 0 2
37834: PPUSH
37835: EMPTY
37836: PPUSH
37837: CALL_OW 1
37841: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37842: LD_ADDR_EXP 142
37846: PUSH
37847: LD_EXP 142
37851: PPUSH
37852: LD_VAR 0 2
37856: PPUSH
37857: EMPTY
37858: PPUSH
37859: CALL_OW 1
37863: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37864: LD_ADDR_EXP 143
37868: PUSH
37869: LD_EXP 143
37873: PPUSH
37874: LD_VAR 0 2
37878: PPUSH
37879: EMPTY
37880: PPUSH
37881: CALL_OW 1
37885: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37886: LD_ADDR_EXP 144
37890: PUSH
37891: LD_EXP 144
37895: PPUSH
37896: LD_VAR 0 2
37900: PPUSH
37901: LD_INT 0
37903: PPUSH
37904: CALL_OW 1
37908: ST_TO_ADDR
// end ;
37909: GO 36833
37911: POP
37912: POP
// MC_InitSides ( ) ;
37913: CALL 38199 0 0
// MC_InitResearch ( ) ;
37917: CALL 37938 0 0
// CustomInitMacro ( ) ;
37921: CALL 467 0 0
// skirmish := true ;
37925: LD_ADDR_EXP 100
37929: PUSH
37930: LD_INT 1
37932: ST_TO_ADDR
// end ;
37933: LD_VAR 0 1
37937: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37938: LD_INT 0
37940: PPUSH
37941: PPUSH
37942: PPUSH
37943: PPUSH
37944: PPUSH
37945: PPUSH
// if not mc_bases then
37946: LD_EXP 102
37950: NOT
37951: IFFALSE 37955
// exit ;
37953: GO 38194
// for i = 1 to 8 do
37955: LD_ADDR_VAR 0 2
37959: PUSH
37960: DOUBLE
37961: LD_INT 1
37963: DEC
37964: ST_TO_ADDR
37965: LD_INT 8
37967: PUSH
37968: FOR_TO
37969: IFFALSE 37995
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37971: LD_ADDR_EXP 129
37975: PUSH
37976: LD_EXP 129
37980: PPUSH
37981: LD_VAR 0 2
37985: PPUSH
37986: EMPTY
37987: PPUSH
37988: CALL_OW 1
37992: ST_TO_ADDR
37993: GO 37968
37995: POP
37996: POP
// tmp := [ ] ;
37997: LD_ADDR_VAR 0 5
38001: PUSH
38002: EMPTY
38003: ST_TO_ADDR
// for i = 1 to mc_sides do
38004: LD_ADDR_VAR 0 2
38008: PUSH
38009: DOUBLE
38010: LD_INT 1
38012: DEC
38013: ST_TO_ADDR
38014: LD_EXP 128
38018: PUSH
38019: FOR_TO
38020: IFFALSE 38078
// if not mc_sides [ i ] in tmp then
38022: LD_EXP 128
38026: PUSH
38027: LD_VAR 0 2
38031: ARRAY
38032: PUSH
38033: LD_VAR 0 5
38037: IN
38038: NOT
38039: IFFALSE 38076
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38041: LD_ADDR_VAR 0 5
38045: PUSH
38046: LD_VAR 0 5
38050: PPUSH
38051: LD_VAR 0 5
38055: PUSH
38056: LD_INT 1
38058: PLUS
38059: PPUSH
38060: LD_EXP 128
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: PPUSH
38071: CALL_OW 2
38075: ST_TO_ADDR
38076: GO 38019
38078: POP
38079: POP
// if not tmp then
38080: LD_VAR 0 5
38084: NOT
38085: IFFALSE 38089
// exit ;
38087: GO 38194
// for j in tmp do
38089: LD_ADDR_VAR 0 3
38093: PUSH
38094: LD_VAR 0 5
38098: PUSH
38099: FOR_IN
38100: IFFALSE 38192
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38102: LD_ADDR_VAR 0 6
38106: PUSH
38107: LD_INT 22
38109: PUSH
38110: LD_VAR 0 3
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PPUSH
38119: CALL_OW 69
38123: ST_TO_ADDR
// if not un then
38124: LD_VAR 0 6
38128: NOT
38129: IFFALSE 38133
// continue ;
38131: GO 38099
// nation := GetNation ( un [ 1 ] ) ;
38133: LD_ADDR_VAR 0 4
38137: PUSH
38138: LD_VAR 0 6
38142: PUSH
38143: LD_INT 1
38145: ARRAY
38146: PPUSH
38147: CALL_OW 248
38151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38152: LD_ADDR_EXP 129
38156: PUSH
38157: LD_EXP 129
38161: PPUSH
38162: LD_VAR 0 3
38166: PPUSH
38167: LD_VAR 0 3
38171: PPUSH
38172: LD_VAR 0 4
38176: PPUSH
38177: LD_INT 1
38179: PPUSH
38180: CALL 64804 0 3
38184: PPUSH
38185: CALL_OW 1
38189: ST_TO_ADDR
// end ;
38190: GO 38099
38192: POP
38193: POP
// end ;
38194: LD_VAR 0 1
38198: RET
// export function MC_InitSides ( ) ; var i ; begin
38199: LD_INT 0
38201: PPUSH
38202: PPUSH
// if not mc_bases then
38203: LD_EXP 102
38207: NOT
38208: IFFALSE 38212
// exit ;
38210: GO 38286
// for i = 1 to mc_bases do
38212: LD_ADDR_VAR 0 2
38216: PUSH
38217: DOUBLE
38218: LD_INT 1
38220: DEC
38221: ST_TO_ADDR
38222: LD_EXP 102
38226: PUSH
38227: FOR_TO
38228: IFFALSE 38284
// if mc_bases [ i ] then
38230: LD_EXP 102
38234: PUSH
38235: LD_VAR 0 2
38239: ARRAY
38240: IFFALSE 38282
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38242: LD_ADDR_EXP 128
38246: PUSH
38247: LD_EXP 128
38251: PPUSH
38252: LD_VAR 0 2
38256: PPUSH
38257: LD_EXP 102
38261: PUSH
38262: LD_VAR 0 2
38266: ARRAY
38267: PUSH
38268: LD_INT 1
38270: ARRAY
38271: PPUSH
38272: CALL_OW 255
38276: PPUSH
38277: CALL_OW 1
38281: ST_TO_ADDR
38282: GO 38227
38284: POP
38285: POP
// end ;
38286: LD_VAR 0 1
38290: RET
// every 0 0$01 trigger skirmish do
38291: LD_EXP 100
38295: IFFALSE 38449
38297: GO 38299
38299: DISABLE
// begin enable ;
38300: ENABLE
// MC_CheckBuildings ( ) ;
38301: CALL 42947 0 0
// MC_CheckPeopleLife ( ) ;
38305: CALL 43072 0 0
// RaiseSailEvent ( 100 ) ;
38309: LD_INT 100
38311: PPUSH
38312: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38316: LD_INT 103
38318: PPUSH
38319: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38323: LD_INT 104
38325: PPUSH
38326: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38330: LD_INT 105
38332: PPUSH
38333: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38337: LD_INT 106
38339: PPUSH
38340: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38344: LD_INT 107
38346: PPUSH
38347: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38351: LD_INT 108
38353: PPUSH
38354: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38358: LD_INT 109
38360: PPUSH
38361: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38365: LD_INT 110
38367: PPUSH
38368: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38372: LD_INT 111
38374: PPUSH
38375: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38379: LD_INT 112
38381: PPUSH
38382: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38386: LD_INT 113
38388: PPUSH
38389: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38393: LD_INT 120
38395: PPUSH
38396: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38400: LD_INT 121
38402: PPUSH
38403: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38407: LD_INT 122
38409: PPUSH
38410: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38414: LD_INT 123
38416: PPUSH
38417: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38421: LD_INT 124
38423: PPUSH
38424: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38428: LD_INT 125
38430: PPUSH
38431: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38435: LD_INT 126
38437: PPUSH
38438: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38442: LD_INT 200
38444: PPUSH
38445: CALL_OW 427
// end ;
38449: END
// on SailEvent ( event ) do begin if event < 100 then
38450: LD_VAR 0 1
38454: PUSH
38455: LD_INT 100
38457: LESS
38458: IFFALSE 38469
// CustomEvent ( event ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: CALL 33109 0 1
// if event = 100 then
38469: LD_VAR 0 1
38473: PUSH
38474: LD_INT 100
38476: EQUAL
38477: IFFALSE 38483
// MC_ClassManager ( ) ;
38479: CALL 38875 0 0
// if event = 101 then
38483: LD_VAR 0 1
38487: PUSH
38488: LD_INT 101
38490: EQUAL
38491: IFFALSE 38497
// MC_RepairBuildings ( ) ;
38493: CALL 43668 0 0
// if event = 102 then
38497: LD_VAR 0 1
38501: PUSH
38502: LD_INT 102
38504: EQUAL
38505: IFFALSE 38511
// MC_Heal ( ) ;
38507: CALL 44532 0 0
// if event = 103 then
38511: LD_VAR 0 1
38515: PUSH
38516: LD_INT 103
38518: EQUAL
38519: IFFALSE 38525
// MC_Build ( ) ;
38521: CALL 44954 0 0
// if event = 104 then
38525: LD_VAR 0 1
38529: PUSH
38530: LD_INT 104
38532: EQUAL
38533: IFFALSE 38539
// MC_TurretWeapon ( ) ;
38535: CALL 46567 0 0
// if event = 105 then
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 105
38546: EQUAL
38547: IFFALSE 38553
// MC_BuildUpgrade ( ) ;
38549: CALL 46118 0 0
// if event = 106 then
38553: LD_VAR 0 1
38557: PUSH
38558: LD_INT 106
38560: EQUAL
38561: IFFALSE 38567
// MC_PlantMines ( ) ;
38563: CALL 46997 0 0
// if event = 107 then
38567: LD_VAR 0 1
38571: PUSH
38572: LD_INT 107
38574: EQUAL
38575: IFFALSE 38581
// MC_CollectCrates ( ) ;
38577: CALL 47795 0 0
// if event = 108 then
38581: LD_VAR 0 1
38585: PUSH
38586: LD_INT 108
38588: EQUAL
38589: IFFALSE 38595
// MC_LinkRemoteControl ( ) ;
38591: CALL 49571 0 0
// if event = 109 then
38595: LD_VAR 0 1
38599: PUSH
38600: LD_INT 109
38602: EQUAL
38603: IFFALSE 38609
// MC_ProduceVehicle ( ) ;
38605: CALL 49752 0 0
// if event = 110 then
38609: LD_VAR 0 1
38613: PUSH
38614: LD_INT 110
38616: EQUAL
38617: IFFALSE 38623
// MC_SendAttack ( ) ;
38619: CALL 50218 0 0
// if event = 111 then
38623: LD_VAR 0 1
38627: PUSH
38628: LD_INT 111
38630: EQUAL
38631: IFFALSE 38637
// MC_Defend ( ) ;
38633: CALL 50326 0 0
// if event = 112 then
38637: LD_VAR 0 1
38641: PUSH
38642: LD_INT 112
38644: EQUAL
38645: IFFALSE 38651
// MC_Research ( ) ;
38647: CALL 50931 0 0
// if event = 113 then
38651: LD_VAR 0 1
38655: PUSH
38656: LD_INT 113
38658: EQUAL
38659: IFFALSE 38665
// MC_MinesTrigger ( ) ;
38661: CALL 52045 0 0
// if event = 120 then
38665: LD_VAR 0 1
38669: PUSH
38670: LD_INT 120
38672: EQUAL
38673: IFFALSE 38679
// MC_RepairVehicle ( ) ;
38675: CALL 52144 0 0
// if event = 121 then
38679: LD_VAR 0 1
38683: PUSH
38684: LD_INT 121
38686: EQUAL
38687: IFFALSE 38693
// MC_TameApe ( ) ;
38689: CALL 52874 0 0
// if event = 122 then
38693: LD_VAR 0 1
38697: PUSH
38698: LD_INT 122
38700: EQUAL
38701: IFFALSE 38707
// MC_ChangeApeClass ( ) ;
38703: CALL 53703 0 0
// if event = 123 then
38707: LD_VAR 0 1
38711: PUSH
38712: LD_INT 123
38714: EQUAL
38715: IFFALSE 38721
// MC_Bazooka ( ) ;
38717: CALL 54353 0 0
// if event = 124 then
38721: LD_VAR 0 1
38725: PUSH
38726: LD_INT 124
38728: EQUAL
38729: IFFALSE 38735
// MC_TeleportExit ( ) ;
38731: CALL 54551 0 0
// if event = 125 then
38735: LD_VAR 0 1
38739: PUSH
38740: LD_INT 125
38742: EQUAL
38743: IFFALSE 38749
// MC_Deposits ( ) ;
38745: CALL 55198 0 0
// if event = 126 then
38749: LD_VAR 0 1
38753: PUSH
38754: LD_INT 126
38756: EQUAL
38757: IFFALSE 38763
// MC_RemoteDriver ( ) ;
38759: CALL 55823 0 0
// if event = 200 then
38763: LD_VAR 0 1
38767: PUSH
38768: LD_INT 200
38770: EQUAL
38771: IFFALSE 38777
// MC_Idle ( ) ;
38773: CALL 57772 0 0
// end ;
38777: PPOPN 1
38779: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38780: LD_INT 0
38782: PPUSH
38783: PPUSH
// if not mc_bases [ base ] or not tag then
38784: LD_EXP 102
38788: PUSH
38789: LD_VAR 0 1
38793: ARRAY
38794: NOT
38795: PUSH
38796: LD_VAR 0 2
38800: NOT
38801: OR
38802: IFFALSE 38806
// exit ;
38804: GO 38870
// for i in mc_bases [ base ] union mc_ape [ base ] do
38806: LD_ADDR_VAR 0 4
38810: PUSH
38811: LD_EXP 102
38815: PUSH
38816: LD_VAR 0 1
38820: ARRAY
38821: PUSH
38822: LD_EXP 131
38826: PUSH
38827: LD_VAR 0 1
38831: ARRAY
38832: UNION
38833: PUSH
38834: FOR_IN
38835: IFFALSE 38868
// if GetTag ( i ) = tag then
38837: LD_VAR 0 4
38841: PPUSH
38842: CALL_OW 110
38846: PUSH
38847: LD_VAR 0 2
38851: EQUAL
38852: IFFALSE 38866
// SetTag ( i , 0 ) ;
38854: LD_VAR 0 4
38858: PPUSH
38859: LD_INT 0
38861: PPUSH
38862: CALL_OW 109
38866: GO 38834
38868: POP
38869: POP
// end ;
38870: LD_VAR 0 3
38874: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38875: LD_INT 0
38877: PPUSH
38878: PPUSH
38879: PPUSH
38880: PPUSH
38881: PPUSH
38882: PPUSH
38883: PPUSH
38884: PPUSH
// if not mc_bases then
38885: LD_EXP 102
38889: NOT
38890: IFFALSE 38894
// exit ;
38892: GO 39352
// for i = 1 to mc_bases do
38894: LD_ADDR_VAR 0 2
38898: PUSH
38899: DOUBLE
38900: LD_INT 1
38902: DEC
38903: ST_TO_ADDR
38904: LD_EXP 102
38908: PUSH
38909: FOR_TO
38910: IFFALSE 39350
// begin tmp := MC_ClassCheckReq ( i ) ;
38912: LD_ADDR_VAR 0 4
38916: PUSH
38917: LD_VAR 0 2
38921: PPUSH
38922: CALL 39357 0 1
38926: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38927: LD_ADDR_EXP 143
38931: PUSH
38932: LD_EXP 143
38936: PPUSH
38937: LD_VAR 0 2
38941: PPUSH
38942: LD_VAR 0 4
38946: PPUSH
38947: CALL_OW 1
38951: ST_TO_ADDR
// if not tmp then
38952: LD_VAR 0 4
38956: NOT
38957: IFFALSE 38961
// continue ;
38959: GO 38909
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38961: LD_ADDR_VAR 0 6
38965: PUSH
38966: LD_EXP 102
38970: PUSH
38971: LD_VAR 0 2
38975: ARRAY
38976: PPUSH
38977: LD_INT 2
38979: PUSH
38980: LD_INT 30
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 30
38992: PUSH
38993: LD_INT 5
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: PPUSH
39005: CALL_OW 72
39009: PUSH
39010: LD_EXP 102
39014: PUSH
39015: LD_VAR 0 2
39019: ARRAY
39020: PPUSH
39021: LD_INT 2
39023: PUSH
39024: LD_INT 30
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 30
39036: PUSH
39037: LD_INT 1
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: LIST
39048: PPUSH
39049: CALL_OW 72
39053: PUSH
39054: LD_EXP 102
39058: PUSH
39059: LD_VAR 0 2
39063: ARRAY
39064: PPUSH
39065: LD_INT 30
39067: PUSH
39068: LD_INT 3
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PPUSH
39075: CALL_OW 72
39079: PUSH
39080: LD_EXP 102
39084: PUSH
39085: LD_VAR 0 2
39089: ARRAY
39090: PPUSH
39091: LD_INT 2
39093: PUSH
39094: LD_INT 30
39096: PUSH
39097: LD_INT 6
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 30
39106: PUSH
39107: LD_INT 7
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 30
39116: PUSH
39117: LD_INT 8
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL_OW 72
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: LIST
39139: LIST
39140: ST_TO_ADDR
// for j = 1 to 4 do
39141: LD_ADDR_VAR 0 3
39145: PUSH
39146: DOUBLE
39147: LD_INT 1
39149: DEC
39150: ST_TO_ADDR
39151: LD_INT 4
39153: PUSH
39154: FOR_TO
39155: IFFALSE 39346
// begin if not tmp [ j ] then
39157: LD_VAR 0 4
39161: PUSH
39162: LD_VAR 0 3
39166: ARRAY
39167: NOT
39168: IFFALSE 39172
// continue ;
39170: GO 39154
// for p in tmp [ j ] do
39172: LD_ADDR_VAR 0 5
39176: PUSH
39177: LD_VAR 0 4
39181: PUSH
39182: LD_VAR 0 3
39186: ARRAY
39187: PUSH
39188: FOR_IN
39189: IFFALSE 39342
// begin if not b [ j ] then
39191: LD_VAR 0 6
39195: PUSH
39196: LD_VAR 0 3
39200: ARRAY
39201: NOT
39202: IFFALSE 39206
// break ;
39204: GO 39342
// e := 0 ;
39206: LD_ADDR_VAR 0 7
39210: PUSH
39211: LD_INT 0
39213: ST_TO_ADDR
// for k in b [ j ] do
39214: LD_ADDR_VAR 0 8
39218: PUSH
39219: LD_VAR 0 6
39223: PUSH
39224: LD_VAR 0 3
39228: ARRAY
39229: PUSH
39230: FOR_IN
39231: IFFALSE 39258
// if IsNotFull ( k ) then
39233: LD_VAR 0 8
39237: PPUSH
39238: CALL 69244 0 1
39242: IFFALSE 39256
// begin e := k ;
39244: LD_ADDR_VAR 0 7
39248: PUSH
39249: LD_VAR 0 8
39253: ST_TO_ADDR
// break ;
39254: GO 39258
// end ;
39256: GO 39230
39258: POP
39259: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39260: LD_VAR 0 7
39264: PUSH
39265: LD_VAR 0 5
39269: PPUSH
39270: LD_VAR 0 7
39274: PPUSH
39275: CALL 106366 0 2
39279: NOT
39280: AND
39281: IFFALSE 39340
// begin if IsInUnit ( p ) then
39283: LD_VAR 0 5
39287: PPUSH
39288: CALL_OW 310
39292: IFFALSE 39303
// ComExitBuilding ( p ) ;
39294: LD_VAR 0 5
39298: PPUSH
39299: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39303: LD_VAR 0 5
39307: PPUSH
39308: LD_VAR 0 7
39312: PPUSH
39313: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39317: LD_VAR 0 5
39321: PPUSH
39322: LD_VAR 0 3
39326: PPUSH
39327: CALL_OW 183
// AddComExitBuilding ( p ) ;
39331: LD_VAR 0 5
39335: PPUSH
39336: CALL_OW 182
// end ; end ;
39340: GO 39188
39342: POP
39343: POP
// end ;
39344: GO 39154
39346: POP
39347: POP
// end ;
39348: GO 38909
39350: POP
39351: POP
// end ;
39352: LD_VAR 0 1
39356: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39357: LD_INT 0
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
39363: PPUSH
39364: PPUSH
39365: PPUSH
39366: PPUSH
39367: PPUSH
39368: PPUSH
39369: PPUSH
39370: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39371: LD_VAR 0 1
39375: NOT
39376: PUSH
39377: LD_EXP 102
39381: PUSH
39382: LD_VAR 0 1
39386: ARRAY
39387: NOT
39388: OR
39389: PUSH
39390: LD_EXP 102
39394: PUSH
39395: LD_VAR 0 1
39399: ARRAY
39400: PPUSH
39401: LD_INT 2
39403: PUSH
39404: LD_INT 30
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 30
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: LIST
39428: PPUSH
39429: CALL_OW 72
39433: NOT
39434: OR
39435: IFFALSE 39439
// exit ;
39437: GO 42942
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39439: LD_ADDR_VAR 0 4
39443: PUSH
39444: LD_EXP 102
39448: PUSH
39449: LD_VAR 0 1
39453: ARRAY
39454: PPUSH
39455: LD_INT 2
39457: PUSH
39458: LD_INT 25
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 25
39470: PUSH
39471: LD_INT 2
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 25
39480: PUSH
39481: LD_INT 3
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: LD_INT 25
39490: PUSH
39491: LD_INT 4
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 25
39500: PUSH
39501: LD_INT 5
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 25
39510: PUSH
39511: LD_INT 8
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 25
39520: PUSH
39521: LD_INT 9
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: PPUSH
39538: CALL_OW 72
39542: ST_TO_ADDR
// if not tmp then
39543: LD_VAR 0 4
39547: NOT
39548: IFFALSE 39552
// exit ;
39550: GO 42942
// for i in tmp do
39552: LD_ADDR_VAR 0 3
39556: PUSH
39557: LD_VAR 0 4
39561: PUSH
39562: FOR_IN
39563: IFFALSE 39594
// if GetTag ( i ) then
39565: LD_VAR 0 3
39569: PPUSH
39570: CALL_OW 110
39574: IFFALSE 39592
// tmp := tmp diff i ;
39576: LD_ADDR_VAR 0 4
39580: PUSH
39581: LD_VAR 0 4
39585: PUSH
39586: LD_VAR 0 3
39590: DIFF
39591: ST_TO_ADDR
39592: GO 39562
39594: POP
39595: POP
// if not tmp then
39596: LD_VAR 0 4
39600: NOT
39601: IFFALSE 39605
// exit ;
39603: GO 42942
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39605: LD_ADDR_VAR 0 5
39609: PUSH
39610: LD_EXP 102
39614: PUSH
39615: LD_VAR 0 1
39619: ARRAY
39620: PPUSH
39621: LD_INT 2
39623: PUSH
39624: LD_INT 25
39626: PUSH
39627: LD_INT 1
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 25
39636: PUSH
39637: LD_INT 5
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 25
39646: PUSH
39647: LD_INT 8
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 25
39656: PUSH
39657: LD_INT 9
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: LIST
39670: PPUSH
39671: CALL_OW 72
39675: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39676: LD_ADDR_VAR 0 6
39680: PUSH
39681: LD_EXP 102
39685: PUSH
39686: LD_VAR 0 1
39690: ARRAY
39691: PPUSH
39692: LD_INT 25
39694: PUSH
39695: LD_INT 2
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PPUSH
39702: CALL_OW 72
39706: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39707: LD_ADDR_VAR 0 7
39711: PUSH
39712: LD_EXP 102
39716: PUSH
39717: LD_VAR 0 1
39721: ARRAY
39722: PPUSH
39723: LD_INT 25
39725: PUSH
39726: LD_INT 3
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PPUSH
39733: CALL_OW 72
39737: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39738: LD_ADDR_VAR 0 8
39742: PUSH
39743: LD_EXP 102
39747: PUSH
39748: LD_VAR 0 1
39752: ARRAY
39753: PPUSH
39754: LD_INT 25
39756: PUSH
39757: LD_INT 4
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 24
39766: PUSH
39767: LD_INT 251
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PPUSH
39778: CALL_OW 72
39782: ST_TO_ADDR
// if mc_scan [ base ] then
39783: LD_EXP 125
39787: PUSH
39788: LD_VAR 0 1
39792: ARRAY
39793: IFFALSE 40254
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39795: LD_ADDR_EXP 144
39799: PUSH
39800: LD_EXP 144
39804: PPUSH
39805: LD_VAR 0 1
39809: PPUSH
39810: LD_INT 4
39812: PPUSH
39813: CALL_OW 1
39817: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39818: LD_ADDR_VAR 0 12
39822: PUSH
39823: LD_EXP 102
39827: PUSH
39828: LD_VAR 0 1
39832: ARRAY
39833: PPUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 30
39839: PUSH
39840: LD_INT 4
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 30
39849: PUSH
39850: LD_INT 5
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: PPUSH
39862: CALL_OW 72
39866: ST_TO_ADDR
// if not b then
39867: LD_VAR 0 12
39871: NOT
39872: IFFALSE 39876
// exit ;
39874: GO 42942
// p := [ ] ;
39876: LD_ADDR_VAR 0 11
39880: PUSH
39881: EMPTY
39882: ST_TO_ADDR
// if sci >= 2 then
39883: LD_VAR 0 8
39887: PUSH
39888: LD_INT 2
39890: GREATEREQUAL
39891: IFFALSE 39922
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39893: LD_ADDR_VAR 0 8
39897: PUSH
39898: LD_VAR 0 8
39902: PUSH
39903: LD_INT 1
39905: ARRAY
39906: PUSH
39907: LD_VAR 0 8
39911: PUSH
39912: LD_INT 2
39914: ARRAY
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: ST_TO_ADDR
39920: GO 39983
// if sci = 1 then
39922: LD_VAR 0 8
39926: PUSH
39927: LD_INT 1
39929: EQUAL
39930: IFFALSE 39951
// sci := [ sci [ 1 ] ] else
39932: LD_ADDR_VAR 0 8
39936: PUSH
39937: LD_VAR 0 8
39941: PUSH
39942: LD_INT 1
39944: ARRAY
39945: PUSH
39946: EMPTY
39947: LIST
39948: ST_TO_ADDR
39949: GO 39983
// if sci = 0 then
39951: LD_VAR 0 8
39955: PUSH
39956: LD_INT 0
39958: EQUAL
39959: IFFALSE 39983
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39961: LD_ADDR_VAR 0 11
39965: PUSH
39966: LD_VAR 0 4
39970: PPUSH
39971: LD_INT 4
39973: PPUSH
39974: CALL 106229 0 2
39978: PUSH
39979: LD_INT 1
39981: ARRAY
39982: ST_TO_ADDR
// if eng > 4 then
39983: LD_VAR 0 6
39987: PUSH
39988: LD_INT 4
39990: GREATER
39991: IFFALSE 40037
// for i = eng downto 4 do
39993: LD_ADDR_VAR 0 3
39997: PUSH
39998: DOUBLE
39999: LD_VAR 0 6
40003: INC
40004: ST_TO_ADDR
40005: LD_INT 4
40007: PUSH
40008: FOR_DOWNTO
40009: IFFALSE 40035
// eng := eng diff eng [ i ] ;
40011: LD_ADDR_VAR 0 6
40015: PUSH
40016: LD_VAR 0 6
40020: PUSH
40021: LD_VAR 0 6
40025: PUSH
40026: LD_VAR 0 3
40030: ARRAY
40031: DIFF
40032: ST_TO_ADDR
40033: GO 40008
40035: POP
40036: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40037: LD_ADDR_VAR 0 4
40041: PUSH
40042: LD_VAR 0 4
40046: PUSH
40047: LD_VAR 0 5
40051: PUSH
40052: LD_VAR 0 6
40056: UNION
40057: PUSH
40058: LD_VAR 0 7
40062: UNION
40063: PUSH
40064: LD_VAR 0 8
40068: UNION
40069: DIFF
40070: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40071: LD_ADDR_VAR 0 13
40075: PUSH
40076: LD_EXP 102
40080: PUSH
40081: LD_VAR 0 1
40085: ARRAY
40086: PPUSH
40087: LD_INT 2
40089: PUSH
40090: LD_INT 30
40092: PUSH
40093: LD_INT 32
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: LD_INT 30
40102: PUSH
40103: LD_INT 31
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: LIST
40114: PPUSH
40115: CALL_OW 72
40119: PUSH
40120: LD_EXP 102
40124: PUSH
40125: LD_VAR 0 1
40129: ARRAY
40130: PPUSH
40131: LD_INT 2
40133: PUSH
40134: LD_INT 30
40136: PUSH
40137: LD_INT 4
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 30
40146: PUSH
40147: LD_INT 5
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: LIST
40158: PPUSH
40159: CALL_OW 72
40163: PUSH
40164: LD_INT 6
40166: MUL
40167: PLUS
40168: ST_TO_ADDR
// if bcount < tmp then
40169: LD_VAR 0 13
40173: PUSH
40174: LD_VAR 0 4
40178: LESS
40179: IFFALSE 40225
// for i = tmp downto bcount do
40181: LD_ADDR_VAR 0 3
40185: PUSH
40186: DOUBLE
40187: LD_VAR 0 4
40191: INC
40192: ST_TO_ADDR
40193: LD_VAR 0 13
40197: PUSH
40198: FOR_DOWNTO
40199: IFFALSE 40223
// tmp := Delete ( tmp , tmp ) ;
40201: LD_ADDR_VAR 0 4
40205: PUSH
40206: LD_VAR 0 4
40210: PPUSH
40211: LD_VAR 0 4
40215: PPUSH
40216: CALL_OW 3
40220: ST_TO_ADDR
40221: GO 40198
40223: POP
40224: POP
// result := [ tmp , 0 , 0 , p ] ;
40225: LD_ADDR_VAR 0 2
40229: PUSH
40230: LD_VAR 0 4
40234: PUSH
40235: LD_INT 0
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: LD_VAR 0 11
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: ST_TO_ADDR
// exit ;
40252: GO 42942
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40254: LD_EXP 102
40258: PUSH
40259: LD_VAR 0 1
40263: ARRAY
40264: PPUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 30
40270: PUSH
40271: LD_INT 6
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 30
40280: PUSH
40281: LD_INT 7
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 30
40290: PUSH
40291: LD_INT 8
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: PPUSH
40304: CALL_OW 72
40308: NOT
40309: PUSH
40310: LD_EXP 102
40314: PUSH
40315: LD_VAR 0 1
40319: ARRAY
40320: PPUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 3
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PPUSH
40331: CALL_OW 72
40335: NOT
40336: AND
40337: IFFALSE 40409
// begin if eng = tmp then
40339: LD_VAR 0 6
40343: PUSH
40344: LD_VAR 0 4
40348: EQUAL
40349: IFFALSE 40353
// exit ;
40351: GO 42942
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40353: LD_ADDR_EXP 144
40357: PUSH
40358: LD_EXP 144
40362: PPUSH
40363: LD_VAR 0 1
40367: PPUSH
40368: LD_INT 1
40370: PPUSH
40371: CALL_OW 1
40375: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40376: LD_ADDR_VAR 0 2
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: LD_VAR 0 4
40388: PUSH
40389: LD_VAR 0 6
40393: DIFF
40394: PUSH
40395: LD_INT 0
40397: PUSH
40398: LD_INT 0
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: ST_TO_ADDR
// exit ;
40407: GO 42942
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40409: LD_EXP 129
40413: PUSH
40414: LD_EXP 128
40418: PUSH
40419: LD_VAR 0 1
40423: ARRAY
40424: ARRAY
40425: PUSH
40426: LD_EXP 102
40430: PUSH
40431: LD_VAR 0 1
40435: ARRAY
40436: PPUSH
40437: LD_INT 2
40439: PUSH
40440: LD_INT 30
40442: PUSH
40443: LD_INT 6
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 30
40452: PUSH
40453: LD_INT 7
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 30
40462: PUSH
40463: LD_INT 8
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: PPUSH
40476: CALL_OW 72
40480: AND
40481: PUSH
40482: LD_EXP 102
40486: PUSH
40487: LD_VAR 0 1
40491: ARRAY
40492: PPUSH
40493: LD_INT 30
40495: PUSH
40496: LD_INT 3
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PPUSH
40503: CALL_OW 72
40507: NOT
40508: AND
40509: IFFALSE 40723
// begin if sci >= 6 then
40511: LD_VAR 0 8
40515: PUSH
40516: LD_INT 6
40518: GREATEREQUAL
40519: IFFALSE 40523
// exit ;
40521: GO 42942
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40523: LD_ADDR_EXP 144
40527: PUSH
40528: LD_EXP 144
40532: PPUSH
40533: LD_VAR 0 1
40537: PPUSH
40538: LD_INT 2
40540: PPUSH
40541: CALL_OW 1
40545: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40546: LD_ADDR_VAR 0 9
40550: PUSH
40551: LD_VAR 0 4
40555: PUSH
40556: LD_VAR 0 8
40560: DIFF
40561: PPUSH
40562: LD_INT 4
40564: PPUSH
40565: CALL 106229 0 2
40569: ST_TO_ADDR
// p := [ ] ;
40570: LD_ADDR_VAR 0 11
40574: PUSH
40575: EMPTY
40576: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40577: LD_VAR 0 8
40581: PUSH
40582: LD_INT 6
40584: LESS
40585: PUSH
40586: LD_VAR 0 9
40590: PUSH
40591: LD_INT 6
40593: GREATER
40594: AND
40595: IFFALSE 40676
// begin for i = 1 to 6 - sci do
40597: LD_ADDR_VAR 0 3
40601: PUSH
40602: DOUBLE
40603: LD_INT 1
40605: DEC
40606: ST_TO_ADDR
40607: LD_INT 6
40609: PUSH
40610: LD_VAR 0 8
40614: MINUS
40615: PUSH
40616: FOR_TO
40617: IFFALSE 40672
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40619: LD_ADDR_VAR 0 11
40623: PUSH
40624: LD_VAR 0 11
40628: PPUSH
40629: LD_VAR 0 11
40633: PUSH
40634: LD_INT 1
40636: PLUS
40637: PPUSH
40638: LD_VAR 0 9
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: PPUSH
40647: CALL_OW 2
40651: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40652: LD_ADDR_VAR 0 9
40656: PUSH
40657: LD_VAR 0 9
40661: PPUSH
40662: LD_INT 1
40664: PPUSH
40665: CALL_OW 3
40669: ST_TO_ADDR
// end ;
40670: GO 40616
40672: POP
40673: POP
// end else
40674: GO 40696
// if sort then
40676: LD_VAR 0 9
40680: IFFALSE 40696
// p := sort [ 1 ] ;
40682: LD_ADDR_VAR 0 11
40686: PUSH
40687: LD_VAR 0 9
40691: PUSH
40692: LD_INT 1
40694: ARRAY
40695: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40696: LD_ADDR_VAR 0 2
40700: PUSH
40701: LD_INT 0
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: LD_INT 0
40709: PUSH
40710: LD_VAR 0 11
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: ST_TO_ADDR
// exit ;
40721: GO 42942
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40723: LD_EXP 129
40727: PUSH
40728: LD_EXP 128
40732: PUSH
40733: LD_VAR 0 1
40737: ARRAY
40738: ARRAY
40739: PUSH
40740: LD_EXP 102
40744: PUSH
40745: LD_VAR 0 1
40749: ARRAY
40750: PPUSH
40751: LD_INT 2
40753: PUSH
40754: LD_INT 30
40756: PUSH
40757: LD_INT 6
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 30
40766: PUSH
40767: LD_INT 7
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 30
40776: PUSH
40777: LD_INT 8
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: PPUSH
40790: CALL_OW 72
40794: AND
40795: PUSH
40796: LD_EXP 102
40800: PUSH
40801: LD_VAR 0 1
40805: ARRAY
40806: PPUSH
40807: LD_INT 30
40809: PUSH
40810: LD_INT 3
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PPUSH
40817: CALL_OW 72
40821: AND
40822: IFFALSE 41556
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40824: LD_ADDR_EXP 144
40828: PUSH
40829: LD_EXP 144
40833: PPUSH
40834: LD_VAR 0 1
40838: PPUSH
40839: LD_INT 3
40841: PPUSH
40842: CALL_OW 1
40846: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40847: LD_ADDR_VAR 0 2
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: LD_INT 0
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: ST_TO_ADDR
// if not eng then
40870: LD_VAR 0 6
40874: NOT
40875: IFFALSE 40938
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40877: LD_ADDR_VAR 0 11
40881: PUSH
40882: LD_VAR 0 4
40886: PPUSH
40887: LD_INT 2
40889: PPUSH
40890: CALL 106229 0 2
40894: PUSH
40895: LD_INT 1
40897: ARRAY
40898: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40899: LD_ADDR_VAR 0 2
40903: PUSH
40904: LD_VAR 0 2
40908: PPUSH
40909: LD_INT 2
40911: PPUSH
40912: LD_VAR 0 11
40916: PPUSH
40917: CALL_OW 1
40921: ST_TO_ADDR
// tmp := tmp diff p ;
40922: LD_ADDR_VAR 0 4
40926: PUSH
40927: LD_VAR 0 4
40931: PUSH
40932: LD_VAR 0 11
40936: DIFF
40937: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40938: LD_VAR 0 4
40942: PUSH
40943: LD_VAR 0 8
40947: PUSH
40948: LD_INT 6
40950: LESS
40951: AND
40952: IFFALSE 41140
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40954: LD_ADDR_VAR 0 9
40958: PUSH
40959: LD_VAR 0 4
40963: PUSH
40964: LD_VAR 0 8
40968: PUSH
40969: LD_VAR 0 7
40973: UNION
40974: DIFF
40975: PPUSH
40976: LD_INT 4
40978: PPUSH
40979: CALL 106229 0 2
40983: ST_TO_ADDR
// p := [ ] ;
40984: LD_ADDR_VAR 0 11
40988: PUSH
40989: EMPTY
40990: ST_TO_ADDR
// if sort then
40991: LD_VAR 0 9
40995: IFFALSE 41111
// for i = 1 to 6 - sci do
40997: LD_ADDR_VAR 0 3
41001: PUSH
41002: DOUBLE
41003: LD_INT 1
41005: DEC
41006: ST_TO_ADDR
41007: LD_INT 6
41009: PUSH
41010: LD_VAR 0 8
41014: MINUS
41015: PUSH
41016: FOR_TO
41017: IFFALSE 41109
// begin if i = sort then
41019: LD_VAR 0 3
41023: PUSH
41024: LD_VAR 0 9
41028: EQUAL
41029: IFFALSE 41033
// break ;
41031: GO 41109
// if GetClass ( i ) = 4 then
41033: LD_VAR 0 3
41037: PPUSH
41038: CALL_OW 257
41042: PUSH
41043: LD_INT 4
41045: EQUAL
41046: IFFALSE 41050
// continue ;
41048: GO 41016
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41050: LD_ADDR_VAR 0 11
41054: PUSH
41055: LD_VAR 0 11
41059: PPUSH
41060: LD_VAR 0 11
41064: PUSH
41065: LD_INT 1
41067: PLUS
41068: PPUSH
41069: LD_VAR 0 9
41073: PUSH
41074: LD_VAR 0 3
41078: ARRAY
41079: PPUSH
41080: CALL_OW 2
41084: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41085: LD_ADDR_VAR 0 4
41089: PUSH
41090: LD_VAR 0 4
41094: PUSH
41095: LD_VAR 0 9
41099: PUSH
41100: LD_VAR 0 3
41104: ARRAY
41105: DIFF
41106: ST_TO_ADDR
// end ;
41107: GO 41016
41109: POP
41110: POP
// if p then
41111: LD_VAR 0 11
41115: IFFALSE 41140
// result := Replace ( result , 4 , p ) ;
41117: LD_ADDR_VAR 0 2
41121: PUSH
41122: LD_VAR 0 2
41126: PPUSH
41127: LD_INT 4
41129: PPUSH
41130: LD_VAR 0 11
41134: PPUSH
41135: CALL_OW 1
41139: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41140: LD_VAR 0 4
41144: PUSH
41145: LD_VAR 0 7
41149: PUSH
41150: LD_INT 6
41152: LESS
41153: AND
41154: IFFALSE 41342
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41156: LD_ADDR_VAR 0 9
41160: PUSH
41161: LD_VAR 0 4
41165: PUSH
41166: LD_VAR 0 8
41170: PUSH
41171: LD_VAR 0 7
41175: UNION
41176: DIFF
41177: PPUSH
41178: LD_INT 3
41180: PPUSH
41181: CALL 106229 0 2
41185: ST_TO_ADDR
// p := [ ] ;
41186: LD_ADDR_VAR 0 11
41190: PUSH
41191: EMPTY
41192: ST_TO_ADDR
// if sort then
41193: LD_VAR 0 9
41197: IFFALSE 41313
// for i = 1 to 6 - mech do
41199: LD_ADDR_VAR 0 3
41203: PUSH
41204: DOUBLE
41205: LD_INT 1
41207: DEC
41208: ST_TO_ADDR
41209: LD_INT 6
41211: PUSH
41212: LD_VAR 0 7
41216: MINUS
41217: PUSH
41218: FOR_TO
41219: IFFALSE 41311
// begin if i = sort then
41221: LD_VAR 0 3
41225: PUSH
41226: LD_VAR 0 9
41230: EQUAL
41231: IFFALSE 41235
// break ;
41233: GO 41311
// if GetClass ( i ) = 3 then
41235: LD_VAR 0 3
41239: PPUSH
41240: CALL_OW 257
41244: PUSH
41245: LD_INT 3
41247: EQUAL
41248: IFFALSE 41252
// continue ;
41250: GO 41218
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41252: LD_ADDR_VAR 0 11
41256: PUSH
41257: LD_VAR 0 11
41261: PPUSH
41262: LD_VAR 0 11
41266: PUSH
41267: LD_INT 1
41269: PLUS
41270: PPUSH
41271: LD_VAR 0 9
41275: PUSH
41276: LD_VAR 0 3
41280: ARRAY
41281: PPUSH
41282: CALL_OW 2
41286: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41287: LD_ADDR_VAR 0 4
41291: PUSH
41292: LD_VAR 0 4
41296: PUSH
41297: LD_VAR 0 9
41301: PUSH
41302: LD_VAR 0 3
41306: ARRAY
41307: DIFF
41308: ST_TO_ADDR
// end ;
41309: GO 41218
41311: POP
41312: POP
// if p then
41313: LD_VAR 0 11
41317: IFFALSE 41342
// result := Replace ( result , 3 , p ) ;
41319: LD_ADDR_VAR 0 2
41323: PUSH
41324: LD_VAR 0 2
41328: PPUSH
41329: LD_INT 3
41331: PPUSH
41332: LD_VAR 0 11
41336: PPUSH
41337: CALL_OW 1
41341: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41342: LD_VAR 0 4
41346: PUSH
41347: LD_INT 6
41349: GREATER
41350: PUSH
41351: LD_VAR 0 6
41355: PUSH
41356: LD_INT 6
41358: LESS
41359: AND
41360: IFFALSE 41554
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41362: LD_ADDR_VAR 0 9
41366: PUSH
41367: LD_VAR 0 4
41371: PUSH
41372: LD_VAR 0 8
41376: PUSH
41377: LD_VAR 0 7
41381: UNION
41382: PUSH
41383: LD_VAR 0 6
41387: UNION
41388: DIFF
41389: PPUSH
41390: LD_INT 2
41392: PPUSH
41393: CALL 106229 0 2
41397: ST_TO_ADDR
// p := [ ] ;
41398: LD_ADDR_VAR 0 11
41402: PUSH
41403: EMPTY
41404: ST_TO_ADDR
// if sort then
41405: LD_VAR 0 9
41409: IFFALSE 41525
// for i = 1 to 6 - eng do
41411: LD_ADDR_VAR 0 3
41415: PUSH
41416: DOUBLE
41417: LD_INT 1
41419: DEC
41420: ST_TO_ADDR
41421: LD_INT 6
41423: PUSH
41424: LD_VAR 0 6
41428: MINUS
41429: PUSH
41430: FOR_TO
41431: IFFALSE 41523
// begin if i = sort then
41433: LD_VAR 0 3
41437: PUSH
41438: LD_VAR 0 9
41442: EQUAL
41443: IFFALSE 41447
// break ;
41445: GO 41523
// if GetClass ( i ) = 2 then
41447: LD_VAR 0 3
41451: PPUSH
41452: CALL_OW 257
41456: PUSH
41457: LD_INT 2
41459: EQUAL
41460: IFFALSE 41464
// continue ;
41462: GO 41430
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41464: LD_ADDR_VAR 0 11
41468: PUSH
41469: LD_VAR 0 11
41473: PPUSH
41474: LD_VAR 0 11
41478: PUSH
41479: LD_INT 1
41481: PLUS
41482: PPUSH
41483: LD_VAR 0 9
41487: PUSH
41488: LD_VAR 0 3
41492: ARRAY
41493: PPUSH
41494: CALL_OW 2
41498: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41499: LD_ADDR_VAR 0 4
41503: PUSH
41504: LD_VAR 0 4
41508: PUSH
41509: LD_VAR 0 9
41513: PUSH
41514: LD_VAR 0 3
41518: ARRAY
41519: DIFF
41520: ST_TO_ADDR
// end ;
41521: GO 41430
41523: POP
41524: POP
// if p then
41525: LD_VAR 0 11
41529: IFFALSE 41554
// result := Replace ( result , 2 , p ) ;
41531: LD_ADDR_VAR 0 2
41535: PUSH
41536: LD_VAR 0 2
41540: PPUSH
41541: LD_INT 2
41543: PPUSH
41544: LD_VAR 0 11
41548: PPUSH
41549: CALL_OW 1
41553: ST_TO_ADDR
// end ; exit ;
41554: GO 42942
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41556: LD_EXP 129
41560: PUSH
41561: LD_EXP 128
41565: PUSH
41566: LD_VAR 0 1
41570: ARRAY
41571: ARRAY
41572: NOT
41573: PUSH
41574: LD_EXP 102
41578: PUSH
41579: LD_VAR 0 1
41583: ARRAY
41584: PPUSH
41585: LD_INT 30
41587: PUSH
41588: LD_INT 3
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PPUSH
41595: CALL_OW 72
41599: AND
41600: PUSH
41601: LD_EXP 107
41605: PUSH
41606: LD_VAR 0 1
41610: ARRAY
41611: AND
41612: IFFALSE 42220
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41614: LD_ADDR_EXP 144
41618: PUSH
41619: LD_EXP 144
41623: PPUSH
41624: LD_VAR 0 1
41628: PPUSH
41629: LD_INT 5
41631: PPUSH
41632: CALL_OW 1
41636: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41637: LD_ADDR_VAR 0 2
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: LD_INT 0
41650: PUSH
41651: LD_INT 0
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// if sci > 1 then
41660: LD_VAR 0 8
41664: PUSH
41665: LD_INT 1
41667: GREATER
41668: IFFALSE 41696
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41670: LD_ADDR_VAR 0 4
41674: PUSH
41675: LD_VAR 0 4
41679: PUSH
41680: LD_VAR 0 8
41684: PUSH
41685: LD_VAR 0 8
41689: PUSH
41690: LD_INT 1
41692: ARRAY
41693: DIFF
41694: DIFF
41695: ST_TO_ADDR
// if tmp and not sci then
41696: LD_VAR 0 4
41700: PUSH
41701: LD_VAR 0 8
41705: NOT
41706: AND
41707: IFFALSE 41776
// begin sort := SortBySkill ( tmp , 4 ) ;
41709: LD_ADDR_VAR 0 9
41713: PUSH
41714: LD_VAR 0 4
41718: PPUSH
41719: LD_INT 4
41721: PPUSH
41722: CALL 106229 0 2
41726: ST_TO_ADDR
// if sort then
41727: LD_VAR 0 9
41731: IFFALSE 41747
// p := sort [ 1 ] ;
41733: LD_ADDR_VAR 0 11
41737: PUSH
41738: LD_VAR 0 9
41742: PUSH
41743: LD_INT 1
41745: ARRAY
41746: ST_TO_ADDR
// if p then
41747: LD_VAR 0 11
41751: IFFALSE 41776
// result := Replace ( result , 4 , p ) ;
41753: LD_ADDR_VAR 0 2
41757: PUSH
41758: LD_VAR 0 2
41762: PPUSH
41763: LD_INT 4
41765: PPUSH
41766: LD_VAR 0 11
41770: PPUSH
41771: CALL_OW 1
41775: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41776: LD_ADDR_VAR 0 4
41780: PUSH
41781: LD_VAR 0 4
41785: PUSH
41786: LD_VAR 0 7
41790: DIFF
41791: ST_TO_ADDR
// if tmp and mech < 6 then
41792: LD_VAR 0 4
41796: PUSH
41797: LD_VAR 0 7
41801: PUSH
41802: LD_INT 6
41804: LESS
41805: AND
41806: IFFALSE 41994
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41808: LD_ADDR_VAR 0 9
41812: PUSH
41813: LD_VAR 0 4
41817: PUSH
41818: LD_VAR 0 8
41822: PUSH
41823: LD_VAR 0 7
41827: UNION
41828: DIFF
41829: PPUSH
41830: LD_INT 3
41832: PPUSH
41833: CALL 106229 0 2
41837: ST_TO_ADDR
// p := [ ] ;
41838: LD_ADDR_VAR 0 11
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// if sort then
41845: LD_VAR 0 9
41849: IFFALSE 41965
// for i = 1 to 6 - mech do
41851: LD_ADDR_VAR 0 3
41855: PUSH
41856: DOUBLE
41857: LD_INT 1
41859: DEC
41860: ST_TO_ADDR
41861: LD_INT 6
41863: PUSH
41864: LD_VAR 0 7
41868: MINUS
41869: PUSH
41870: FOR_TO
41871: IFFALSE 41963
// begin if i = sort then
41873: LD_VAR 0 3
41877: PUSH
41878: LD_VAR 0 9
41882: EQUAL
41883: IFFALSE 41887
// break ;
41885: GO 41963
// if GetClass ( i ) = 3 then
41887: LD_VAR 0 3
41891: PPUSH
41892: CALL_OW 257
41896: PUSH
41897: LD_INT 3
41899: EQUAL
41900: IFFALSE 41904
// continue ;
41902: GO 41870
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41904: LD_ADDR_VAR 0 11
41908: PUSH
41909: LD_VAR 0 11
41913: PPUSH
41914: LD_VAR 0 11
41918: PUSH
41919: LD_INT 1
41921: PLUS
41922: PPUSH
41923: LD_VAR 0 9
41927: PUSH
41928: LD_VAR 0 3
41932: ARRAY
41933: PPUSH
41934: CALL_OW 2
41938: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41939: LD_ADDR_VAR 0 4
41943: PUSH
41944: LD_VAR 0 4
41948: PUSH
41949: LD_VAR 0 9
41953: PUSH
41954: LD_VAR 0 3
41958: ARRAY
41959: DIFF
41960: ST_TO_ADDR
// end ;
41961: GO 41870
41963: POP
41964: POP
// if p then
41965: LD_VAR 0 11
41969: IFFALSE 41994
// result := Replace ( result , 3 , p ) ;
41971: LD_ADDR_VAR 0 2
41975: PUSH
41976: LD_VAR 0 2
41980: PPUSH
41981: LD_INT 3
41983: PPUSH
41984: LD_VAR 0 11
41988: PPUSH
41989: CALL_OW 1
41993: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41994: LD_ADDR_VAR 0 4
41998: PUSH
41999: LD_VAR 0 4
42003: PUSH
42004: LD_VAR 0 6
42008: DIFF
42009: ST_TO_ADDR
// if tmp and eng < 6 then
42010: LD_VAR 0 4
42014: PUSH
42015: LD_VAR 0 6
42019: PUSH
42020: LD_INT 6
42022: LESS
42023: AND
42024: IFFALSE 42218
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42026: LD_ADDR_VAR 0 9
42030: PUSH
42031: LD_VAR 0 4
42035: PUSH
42036: LD_VAR 0 8
42040: PUSH
42041: LD_VAR 0 7
42045: UNION
42046: PUSH
42047: LD_VAR 0 6
42051: UNION
42052: DIFF
42053: PPUSH
42054: LD_INT 2
42056: PPUSH
42057: CALL 106229 0 2
42061: ST_TO_ADDR
// p := [ ] ;
42062: LD_ADDR_VAR 0 11
42066: PUSH
42067: EMPTY
42068: ST_TO_ADDR
// if sort then
42069: LD_VAR 0 9
42073: IFFALSE 42189
// for i = 1 to 6 - eng do
42075: LD_ADDR_VAR 0 3
42079: PUSH
42080: DOUBLE
42081: LD_INT 1
42083: DEC
42084: ST_TO_ADDR
42085: LD_INT 6
42087: PUSH
42088: LD_VAR 0 6
42092: MINUS
42093: PUSH
42094: FOR_TO
42095: IFFALSE 42187
// begin if i = sort then
42097: LD_VAR 0 3
42101: PUSH
42102: LD_VAR 0 9
42106: EQUAL
42107: IFFALSE 42111
// break ;
42109: GO 42187
// if GetClass ( i ) = 2 then
42111: LD_VAR 0 3
42115: PPUSH
42116: CALL_OW 257
42120: PUSH
42121: LD_INT 2
42123: EQUAL
42124: IFFALSE 42128
// continue ;
42126: GO 42094
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42128: LD_ADDR_VAR 0 11
42132: PUSH
42133: LD_VAR 0 11
42137: PPUSH
42138: LD_VAR 0 11
42142: PUSH
42143: LD_INT 1
42145: PLUS
42146: PPUSH
42147: LD_VAR 0 9
42151: PUSH
42152: LD_VAR 0 3
42156: ARRAY
42157: PPUSH
42158: CALL_OW 2
42162: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42163: LD_ADDR_VAR 0 4
42167: PUSH
42168: LD_VAR 0 4
42172: PUSH
42173: LD_VAR 0 9
42177: PUSH
42178: LD_VAR 0 3
42182: ARRAY
42183: DIFF
42184: ST_TO_ADDR
// end ;
42185: GO 42094
42187: POP
42188: POP
// if p then
42189: LD_VAR 0 11
42193: IFFALSE 42218
// result := Replace ( result , 2 , p ) ;
42195: LD_ADDR_VAR 0 2
42199: PUSH
42200: LD_VAR 0 2
42204: PPUSH
42205: LD_INT 2
42207: PPUSH
42208: LD_VAR 0 11
42212: PPUSH
42213: CALL_OW 1
42217: ST_TO_ADDR
// end ; exit ;
42218: GO 42942
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42220: LD_EXP 129
42224: PUSH
42225: LD_EXP 128
42229: PUSH
42230: LD_VAR 0 1
42234: ARRAY
42235: ARRAY
42236: NOT
42237: PUSH
42238: LD_EXP 102
42242: PUSH
42243: LD_VAR 0 1
42247: ARRAY
42248: PPUSH
42249: LD_INT 30
42251: PUSH
42252: LD_INT 3
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PPUSH
42259: CALL_OW 72
42263: AND
42264: PUSH
42265: LD_EXP 107
42269: PUSH
42270: LD_VAR 0 1
42274: ARRAY
42275: NOT
42276: AND
42277: IFFALSE 42942
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42279: LD_ADDR_EXP 144
42283: PUSH
42284: LD_EXP 144
42288: PPUSH
42289: LD_VAR 0 1
42293: PPUSH
42294: LD_INT 6
42296: PPUSH
42297: CALL_OW 1
42301: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42302: LD_ADDR_VAR 0 2
42306: PUSH
42307: LD_INT 0
42309: PUSH
42310: LD_INT 0
42312: PUSH
42313: LD_INT 0
42315: PUSH
42316: LD_INT 0
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: ST_TO_ADDR
// if sci >= 1 then
42325: LD_VAR 0 8
42329: PUSH
42330: LD_INT 1
42332: GREATEREQUAL
42333: IFFALSE 42355
// tmp := tmp diff sci [ 1 ] ;
42335: LD_ADDR_VAR 0 4
42339: PUSH
42340: LD_VAR 0 4
42344: PUSH
42345: LD_VAR 0 8
42349: PUSH
42350: LD_INT 1
42352: ARRAY
42353: DIFF
42354: ST_TO_ADDR
// if tmp and not sci then
42355: LD_VAR 0 4
42359: PUSH
42360: LD_VAR 0 8
42364: NOT
42365: AND
42366: IFFALSE 42435
// begin sort := SortBySkill ( tmp , 4 ) ;
42368: LD_ADDR_VAR 0 9
42372: PUSH
42373: LD_VAR 0 4
42377: PPUSH
42378: LD_INT 4
42380: PPUSH
42381: CALL 106229 0 2
42385: ST_TO_ADDR
// if sort then
42386: LD_VAR 0 9
42390: IFFALSE 42406
// p := sort [ 1 ] ;
42392: LD_ADDR_VAR 0 11
42396: PUSH
42397: LD_VAR 0 9
42401: PUSH
42402: LD_INT 1
42404: ARRAY
42405: ST_TO_ADDR
// if p then
42406: LD_VAR 0 11
42410: IFFALSE 42435
// result := Replace ( result , 4 , p ) ;
42412: LD_ADDR_VAR 0 2
42416: PUSH
42417: LD_VAR 0 2
42421: PPUSH
42422: LD_INT 4
42424: PPUSH
42425: LD_VAR 0 11
42429: PPUSH
42430: CALL_OW 1
42434: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42435: LD_ADDR_VAR 0 4
42439: PUSH
42440: LD_VAR 0 4
42444: PUSH
42445: LD_VAR 0 7
42449: DIFF
42450: ST_TO_ADDR
// if tmp and mech < 6 then
42451: LD_VAR 0 4
42455: PUSH
42456: LD_VAR 0 7
42460: PUSH
42461: LD_INT 6
42463: LESS
42464: AND
42465: IFFALSE 42647
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42467: LD_ADDR_VAR 0 9
42471: PUSH
42472: LD_VAR 0 4
42476: PUSH
42477: LD_VAR 0 7
42481: DIFF
42482: PPUSH
42483: LD_INT 3
42485: PPUSH
42486: CALL 106229 0 2
42490: ST_TO_ADDR
// p := [ ] ;
42491: LD_ADDR_VAR 0 11
42495: PUSH
42496: EMPTY
42497: ST_TO_ADDR
// if sort then
42498: LD_VAR 0 9
42502: IFFALSE 42618
// for i = 1 to 6 - mech do
42504: LD_ADDR_VAR 0 3
42508: PUSH
42509: DOUBLE
42510: LD_INT 1
42512: DEC
42513: ST_TO_ADDR
42514: LD_INT 6
42516: PUSH
42517: LD_VAR 0 7
42521: MINUS
42522: PUSH
42523: FOR_TO
42524: IFFALSE 42616
// begin if i = sort then
42526: LD_VAR 0 3
42530: PUSH
42531: LD_VAR 0 9
42535: EQUAL
42536: IFFALSE 42540
// break ;
42538: GO 42616
// if GetClass ( i ) = 3 then
42540: LD_VAR 0 3
42544: PPUSH
42545: CALL_OW 257
42549: PUSH
42550: LD_INT 3
42552: EQUAL
42553: IFFALSE 42557
// continue ;
42555: GO 42523
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42557: LD_ADDR_VAR 0 11
42561: PUSH
42562: LD_VAR 0 11
42566: PPUSH
42567: LD_VAR 0 11
42571: PUSH
42572: LD_INT 1
42574: PLUS
42575: PPUSH
42576: LD_VAR 0 9
42580: PUSH
42581: LD_VAR 0 3
42585: ARRAY
42586: PPUSH
42587: CALL_OW 2
42591: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42592: LD_ADDR_VAR 0 4
42596: PUSH
42597: LD_VAR 0 4
42601: PUSH
42602: LD_VAR 0 9
42606: PUSH
42607: LD_VAR 0 3
42611: ARRAY
42612: DIFF
42613: ST_TO_ADDR
// end ;
42614: GO 42523
42616: POP
42617: POP
// if p then
42618: LD_VAR 0 11
42622: IFFALSE 42647
// result := Replace ( result , 3 , p ) ;
42624: LD_ADDR_VAR 0 2
42628: PUSH
42629: LD_VAR 0 2
42633: PPUSH
42634: LD_INT 3
42636: PPUSH
42637: LD_VAR 0 11
42641: PPUSH
42642: CALL_OW 1
42646: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42647: LD_ADDR_VAR 0 4
42651: PUSH
42652: LD_VAR 0 4
42656: PUSH
42657: LD_VAR 0 6
42661: DIFF
42662: ST_TO_ADDR
// if tmp and eng < 4 then
42663: LD_VAR 0 4
42667: PUSH
42668: LD_VAR 0 6
42672: PUSH
42673: LD_INT 4
42675: LESS
42676: AND
42677: IFFALSE 42867
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42679: LD_ADDR_VAR 0 9
42683: PUSH
42684: LD_VAR 0 4
42688: PUSH
42689: LD_VAR 0 7
42693: PUSH
42694: LD_VAR 0 6
42698: UNION
42699: DIFF
42700: PPUSH
42701: LD_INT 2
42703: PPUSH
42704: CALL 106229 0 2
42708: ST_TO_ADDR
// p := [ ] ;
42709: LD_ADDR_VAR 0 11
42713: PUSH
42714: EMPTY
42715: ST_TO_ADDR
// if sort then
42716: LD_VAR 0 9
42720: IFFALSE 42836
// for i = 1 to 4 - eng do
42722: LD_ADDR_VAR 0 3
42726: PUSH
42727: DOUBLE
42728: LD_INT 1
42730: DEC
42731: ST_TO_ADDR
42732: LD_INT 4
42734: PUSH
42735: LD_VAR 0 6
42739: MINUS
42740: PUSH
42741: FOR_TO
42742: IFFALSE 42834
// begin if i = sort then
42744: LD_VAR 0 3
42748: PUSH
42749: LD_VAR 0 9
42753: EQUAL
42754: IFFALSE 42758
// break ;
42756: GO 42834
// if GetClass ( i ) = 2 then
42758: LD_VAR 0 3
42762: PPUSH
42763: CALL_OW 257
42767: PUSH
42768: LD_INT 2
42770: EQUAL
42771: IFFALSE 42775
// continue ;
42773: GO 42741
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42775: LD_ADDR_VAR 0 11
42779: PUSH
42780: LD_VAR 0 11
42784: PPUSH
42785: LD_VAR 0 11
42789: PUSH
42790: LD_INT 1
42792: PLUS
42793: PPUSH
42794: LD_VAR 0 9
42798: PUSH
42799: LD_VAR 0 3
42803: ARRAY
42804: PPUSH
42805: CALL_OW 2
42809: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42810: LD_ADDR_VAR 0 4
42814: PUSH
42815: LD_VAR 0 4
42819: PUSH
42820: LD_VAR 0 9
42824: PUSH
42825: LD_VAR 0 3
42829: ARRAY
42830: DIFF
42831: ST_TO_ADDR
// end ;
42832: GO 42741
42834: POP
42835: POP
// if p then
42836: LD_VAR 0 11
42840: IFFALSE 42865
// result := Replace ( result , 2 , p ) ;
42842: LD_ADDR_VAR 0 2
42846: PUSH
42847: LD_VAR 0 2
42851: PPUSH
42852: LD_INT 2
42854: PPUSH
42855: LD_VAR 0 11
42859: PPUSH
42860: CALL_OW 1
42864: ST_TO_ADDR
// end else
42865: GO 42911
// for i = eng downto 5 do
42867: LD_ADDR_VAR 0 3
42871: PUSH
42872: DOUBLE
42873: LD_VAR 0 6
42877: INC
42878: ST_TO_ADDR
42879: LD_INT 5
42881: PUSH
42882: FOR_DOWNTO
42883: IFFALSE 42909
// tmp := tmp union eng [ i ] ;
42885: LD_ADDR_VAR 0 4
42889: PUSH
42890: LD_VAR 0 4
42894: PUSH
42895: LD_VAR 0 6
42899: PUSH
42900: LD_VAR 0 3
42904: ARRAY
42905: UNION
42906: ST_TO_ADDR
42907: GO 42882
42909: POP
42910: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42911: LD_ADDR_VAR 0 2
42915: PUSH
42916: LD_VAR 0 2
42920: PPUSH
42921: LD_INT 1
42923: PPUSH
42924: LD_VAR 0 4
42928: PUSH
42929: LD_VAR 0 5
42933: DIFF
42934: PPUSH
42935: CALL_OW 1
42939: ST_TO_ADDR
// exit ;
42940: GO 42942
// end ; end ;
42942: LD_VAR 0 2
42946: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42947: LD_INT 0
42949: PPUSH
42950: PPUSH
42951: PPUSH
// if not mc_bases then
42952: LD_EXP 102
42956: NOT
42957: IFFALSE 42961
// exit ;
42959: GO 43067
// for i = 1 to mc_bases do
42961: LD_ADDR_VAR 0 2
42965: PUSH
42966: DOUBLE
42967: LD_INT 1
42969: DEC
42970: ST_TO_ADDR
42971: LD_EXP 102
42975: PUSH
42976: FOR_TO
42977: IFFALSE 43058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42979: LD_ADDR_VAR 0 3
42983: PUSH
42984: LD_EXP 102
42988: PUSH
42989: LD_VAR 0 2
42993: ARRAY
42994: PPUSH
42995: LD_INT 21
42997: PUSH
42998: LD_INT 3
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 3
43007: PUSH
43008: LD_INT 24
43010: PUSH
43011: LD_INT 1000
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PPUSH
43026: CALL_OW 72
43030: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43031: LD_ADDR_EXP 103
43035: PUSH
43036: LD_EXP 103
43040: PPUSH
43041: LD_VAR 0 2
43045: PPUSH
43046: LD_VAR 0 3
43050: PPUSH
43051: CALL_OW 1
43055: ST_TO_ADDR
// end ;
43056: GO 42976
43058: POP
43059: POP
// RaiseSailEvent ( 101 ) ;
43060: LD_INT 101
43062: PPUSH
43063: CALL_OW 427
// end ;
43067: LD_VAR 0 1
43071: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43072: LD_INT 0
43074: PPUSH
43075: PPUSH
43076: PPUSH
43077: PPUSH
43078: PPUSH
43079: PPUSH
43080: PPUSH
// if not mc_bases then
43081: LD_EXP 102
43085: NOT
43086: IFFALSE 43090
// exit ;
43088: GO 43663
// for i = 1 to mc_bases do
43090: LD_ADDR_VAR 0 2
43094: PUSH
43095: DOUBLE
43096: LD_INT 1
43098: DEC
43099: ST_TO_ADDR
43100: LD_EXP 102
43104: PUSH
43105: FOR_TO
43106: IFFALSE 43654
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43108: LD_ADDR_VAR 0 5
43112: PUSH
43113: LD_EXP 102
43117: PUSH
43118: LD_VAR 0 2
43122: ARRAY
43123: PUSH
43124: LD_EXP 131
43128: PUSH
43129: LD_VAR 0 2
43133: ARRAY
43134: UNION
43135: PPUSH
43136: LD_INT 21
43138: PUSH
43139: LD_INT 1
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 1
43148: PUSH
43149: LD_INT 3
43151: PUSH
43152: LD_INT 54
43154: PUSH
43155: EMPTY
43156: LIST
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: PUSH
43162: LD_INT 3
43164: PUSH
43165: LD_INT 24
43167: PUSH
43168: LD_INT 800
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PPUSH
43188: CALL_OW 72
43192: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43193: LD_ADDR_VAR 0 6
43197: PUSH
43198: LD_EXP 102
43202: PUSH
43203: LD_VAR 0 2
43207: ARRAY
43208: PPUSH
43209: LD_INT 21
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: LD_INT 3
43224: PUSH
43225: LD_INT 54
43227: PUSH
43228: EMPTY
43229: LIST
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 3
43237: PUSH
43238: LD_INT 24
43240: PUSH
43241: LD_INT 250
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PPUSH
43261: CALL_OW 72
43265: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43266: LD_ADDR_VAR 0 7
43270: PUSH
43271: LD_VAR 0 5
43275: PUSH
43276: LD_VAR 0 6
43280: DIFF
43281: ST_TO_ADDR
// if not need_heal_1 then
43282: LD_VAR 0 6
43286: NOT
43287: IFFALSE 43320
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43289: LD_ADDR_EXP 105
43293: PUSH
43294: LD_EXP 105
43298: PPUSH
43299: LD_VAR 0 2
43303: PUSH
43304: LD_INT 1
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PPUSH
43311: EMPTY
43312: PPUSH
43313: CALL 71978 0 3
43317: ST_TO_ADDR
43318: GO 43390
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43320: LD_ADDR_EXP 105
43324: PUSH
43325: LD_EXP 105
43329: PPUSH
43330: LD_VAR 0 2
43334: PUSH
43335: LD_INT 1
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PPUSH
43342: LD_EXP 105
43346: PUSH
43347: LD_VAR 0 2
43351: ARRAY
43352: PUSH
43353: LD_INT 1
43355: ARRAY
43356: PPUSH
43357: LD_INT 3
43359: PUSH
43360: LD_INT 24
43362: PUSH
43363: LD_INT 1000
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PPUSH
43374: CALL_OW 72
43378: PUSH
43379: LD_VAR 0 6
43383: UNION
43384: PPUSH
43385: CALL 71978 0 3
43389: ST_TO_ADDR
// if not need_heal_2 then
43390: LD_VAR 0 7
43394: NOT
43395: IFFALSE 43428
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43397: LD_ADDR_EXP 105
43401: PUSH
43402: LD_EXP 105
43406: PPUSH
43407: LD_VAR 0 2
43411: PUSH
43412: LD_INT 2
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PPUSH
43419: EMPTY
43420: PPUSH
43421: CALL 71978 0 3
43425: ST_TO_ADDR
43426: GO 43460
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43428: LD_ADDR_EXP 105
43432: PUSH
43433: LD_EXP 105
43437: PPUSH
43438: LD_VAR 0 2
43442: PUSH
43443: LD_INT 2
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PPUSH
43450: LD_VAR 0 7
43454: PPUSH
43455: CALL 71978 0 3
43459: ST_TO_ADDR
// if need_heal_2 then
43460: LD_VAR 0 7
43464: IFFALSE 43636
// for j in need_heal_2 do
43466: LD_ADDR_VAR 0 3
43470: PUSH
43471: LD_VAR 0 7
43475: PUSH
43476: FOR_IN
43477: IFFALSE 43634
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43479: LD_ADDR_VAR 0 5
43483: PUSH
43484: LD_EXP 102
43488: PUSH
43489: LD_VAR 0 2
43493: ARRAY
43494: PPUSH
43495: LD_INT 2
43497: PUSH
43498: LD_INT 30
43500: PUSH
43501: LD_INT 6
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 30
43510: PUSH
43511: LD_INT 7
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 30
43520: PUSH
43521: LD_INT 8
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 30
43530: PUSH
43531: LD_INT 0
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 30
43540: PUSH
43541: LD_INT 1
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: LD_INT 25
43550: PUSH
43551: LD_INT 4
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: PPUSH
43567: CALL_OW 72
43571: ST_TO_ADDR
// if tmp then
43572: LD_VAR 0 5
43576: IFFALSE 43632
// begin k := NearestUnitToUnit ( tmp , j ) ;
43578: LD_ADDR_VAR 0 4
43582: PUSH
43583: LD_VAR 0 5
43587: PPUSH
43588: LD_VAR 0 3
43592: PPUSH
43593: CALL_OW 74
43597: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43598: LD_VAR 0 3
43602: PPUSH
43603: LD_VAR 0 4
43607: PPUSH
43608: CALL_OW 296
43612: PUSH
43613: LD_INT 7
43615: GREATER
43616: IFFALSE 43632
// ComMoveUnit ( j , k ) ;
43618: LD_VAR 0 3
43622: PPUSH
43623: LD_VAR 0 4
43627: PPUSH
43628: CALL_OW 112
// end ; end ;
43632: GO 43476
43634: POP
43635: POP
// if not need_heal_1 and not need_heal_2 then
43636: LD_VAR 0 6
43640: NOT
43641: PUSH
43642: LD_VAR 0 7
43646: NOT
43647: AND
43648: IFFALSE 43652
// continue ;
43650: GO 43105
// end ;
43652: GO 43105
43654: POP
43655: POP
// RaiseSailEvent ( 102 ) ;
43656: LD_INT 102
43658: PPUSH
43659: CALL_OW 427
// end ;
43663: LD_VAR 0 1
43667: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43668: LD_INT 0
43670: PPUSH
43671: PPUSH
43672: PPUSH
43673: PPUSH
43674: PPUSH
43675: PPUSH
43676: PPUSH
43677: PPUSH
// if not mc_bases then
43678: LD_EXP 102
43682: NOT
43683: IFFALSE 43687
// exit ;
43685: GO 44527
// for i = 1 to mc_bases do
43687: LD_ADDR_VAR 0 2
43691: PUSH
43692: DOUBLE
43693: LD_INT 1
43695: DEC
43696: ST_TO_ADDR
43697: LD_EXP 102
43701: PUSH
43702: FOR_TO
43703: IFFALSE 44525
// begin if not mc_building_need_repair [ i ] then
43705: LD_EXP 103
43709: PUSH
43710: LD_VAR 0 2
43714: ARRAY
43715: NOT
43716: IFFALSE 43890
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43718: LD_ADDR_VAR 0 6
43722: PUSH
43723: LD_EXP 121
43727: PUSH
43728: LD_VAR 0 2
43732: ARRAY
43733: PPUSH
43734: LD_INT 3
43736: PUSH
43737: LD_INT 24
43739: PUSH
43740: LD_INT 1000
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 2
43753: PUSH
43754: LD_INT 34
43756: PUSH
43757: LD_INT 13
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 34
43766: PUSH
43767: LD_INT 52
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: LIST
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PPUSH
43783: CALL_OW 72
43787: ST_TO_ADDR
// if cranes then
43788: LD_VAR 0 6
43792: IFFALSE 43854
// for j in cranes do
43794: LD_ADDR_VAR 0 3
43798: PUSH
43799: LD_VAR 0 6
43803: PUSH
43804: FOR_IN
43805: IFFALSE 43852
// if not IsInArea ( j , mc_parking [ i ] ) then
43807: LD_VAR 0 3
43811: PPUSH
43812: LD_EXP 126
43816: PUSH
43817: LD_VAR 0 2
43821: ARRAY
43822: PPUSH
43823: CALL_OW 308
43827: NOT
43828: IFFALSE 43850
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43830: LD_VAR 0 3
43834: PPUSH
43835: LD_EXP 126
43839: PUSH
43840: LD_VAR 0 2
43844: ARRAY
43845: PPUSH
43846: CALL_OW 113
43850: GO 43804
43852: POP
43853: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43854: LD_ADDR_EXP 104
43858: PUSH
43859: LD_EXP 104
43863: PPUSH
43864: LD_VAR 0 2
43868: PPUSH
43869: EMPTY
43870: PPUSH
43871: CALL_OW 1
43875: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43876: LD_VAR 0 2
43880: PPUSH
43881: LD_INT 101
43883: PPUSH
43884: CALL 38780 0 2
// continue ;
43888: GO 43702
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43890: LD_ADDR_EXP 108
43894: PUSH
43895: LD_EXP 108
43899: PPUSH
43900: LD_VAR 0 2
43904: PPUSH
43905: EMPTY
43906: PPUSH
43907: CALL_OW 1
43911: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43912: LD_VAR 0 2
43916: PPUSH
43917: LD_INT 103
43919: PPUSH
43920: CALL 38780 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43924: LD_ADDR_VAR 0 5
43928: PUSH
43929: LD_EXP 102
43933: PUSH
43934: LD_VAR 0 2
43938: ARRAY
43939: PUSH
43940: LD_EXP 131
43944: PUSH
43945: LD_VAR 0 2
43949: ARRAY
43950: UNION
43951: PPUSH
43952: LD_INT 2
43954: PUSH
43955: LD_INT 25
43957: PUSH
43958: LD_INT 2
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 25
43967: PUSH
43968: LD_INT 16
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: LIST
43979: PUSH
43980: EMPTY
43981: LIST
43982: PPUSH
43983: CALL_OW 72
43987: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43988: LD_ADDR_VAR 0 6
43992: PUSH
43993: LD_EXP 121
43997: PUSH
43998: LD_VAR 0 2
44002: ARRAY
44003: PPUSH
44004: LD_INT 2
44006: PUSH
44007: LD_INT 34
44009: PUSH
44010: LD_INT 13
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 34
44019: PUSH
44020: LD_INT 52
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: LIST
44031: PPUSH
44032: CALL_OW 72
44036: ST_TO_ADDR
// if cranes then
44037: LD_VAR 0 6
44041: IFFALSE 44177
// begin for j in cranes do
44043: LD_ADDR_VAR 0 3
44047: PUSH
44048: LD_VAR 0 6
44052: PUSH
44053: FOR_IN
44054: IFFALSE 44175
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44056: LD_VAR 0 3
44060: PPUSH
44061: CALL_OW 256
44065: PUSH
44066: LD_INT 500
44068: GREATEREQUAL
44069: PUSH
44070: LD_VAR 0 3
44074: PPUSH
44075: CALL_OW 314
44079: NOT
44080: AND
44081: IFFALSE 44115
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44083: LD_VAR 0 3
44087: PPUSH
44088: LD_EXP 103
44092: PUSH
44093: LD_VAR 0 2
44097: ARRAY
44098: PPUSH
44099: LD_VAR 0 3
44103: PPUSH
44104: CALL_OW 74
44108: PPUSH
44109: CALL_OW 130
44113: GO 44173
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44115: LD_VAR 0 3
44119: PPUSH
44120: CALL_OW 256
44124: PUSH
44125: LD_INT 500
44127: LESS
44128: PUSH
44129: LD_VAR 0 3
44133: PPUSH
44134: LD_EXP 126
44138: PUSH
44139: LD_VAR 0 2
44143: ARRAY
44144: PPUSH
44145: CALL_OW 308
44149: NOT
44150: AND
44151: IFFALSE 44173
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44153: LD_VAR 0 3
44157: PPUSH
44158: LD_EXP 126
44162: PUSH
44163: LD_VAR 0 2
44167: ARRAY
44168: PPUSH
44169: CALL_OW 113
44173: GO 44053
44175: POP
44176: POP
// end ; if not tmp then
44177: LD_VAR 0 5
44181: NOT
44182: IFFALSE 44186
// continue ;
44184: GO 43702
// for j in tmp do
44186: LD_ADDR_VAR 0 3
44190: PUSH
44191: LD_VAR 0 5
44195: PUSH
44196: FOR_IN
44197: IFFALSE 44521
// begin if mc_need_heal [ i ] then
44199: LD_EXP 105
44203: PUSH
44204: LD_VAR 0 2
44208: ARRAY
44209: IFFALSE 44257
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44211: LD_VAR 0 3
44215: PUSH
44216: LD_EXP 105
44220: PUSH
44221: LD_VAR 0 2
44225: ARRAY
44226: PUSH
44227: LD_INT 1
44229: ARRAY
44230: IN
44231: PUSH
44232: LD_VAR 0 3
44236: PUSH
44237: LD_EXP 105
44241: PUSH
44242: LD_VAR 0 2
44246: ARRAY
44247: PUSH
44248: LD_INT 2
44250: ARRAY
44251: IN
44252: OR
44253: IFFALSE 44257
// continue ;
44255: GO 44196
// if IsInUnit ( j ) then
44257: LD_VAR 0 3
44261: PPUSH
44262: CALL_OW 310
44266: IFFALSE 44277
// ComExitBuilding ( j ) ;
44268: LD_VAR 0 3
44272: PPUSH
44273: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44277: LD_VAR 0 3
44281: PUSH
44282: LD_EXP 104
44286: PUSH
44287: LD_VAR 0 2
44291: ARRAY
44292: IN
44293: NOT
44294: IFFALSE 44352
// begin SetTag ( j , 101 ) ;
44296: LD_VAR 0 3
44300: PPUSH
44301: LD_INT 101
44303: PPUSH
44304: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44308: LD_ADDR_EXP 104
44312: PUSH
44313: LD_EXP 104
44317: PPUSH
44318: LD_VAR 0 2
44322: PUSH
44323: LD_EXP 104
44327: PUSH
44328: LD_VAR 0 2
44332: ARRAY
44333: PUSH
44334: LD_INT 1
44336: PLUS
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PPUSH
44342: LD_VAR 0 3
44346: PPUSH
44347: CALL 71978 0 3
44351: ST_TO_ADDR
// end ; wait ( 1 ) ;
44352: LD_INT 1
44354: PPUSH
44355: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44359: LD_ADDR_VAR 0 7
44363: PUSH
44364: LD_EXP 103
44368: PUSH
44369: LD_VAR 0 2
44373: ARRAY
44374: ST_TO_ADDR
// if mc_scan [ i ] then
44375: LD_EXP 125
44379: PUSH
44380: LD_VAR 0 2
44384: ARRAY
44385: IFFALSE 44454
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44387: LD_ADDR_VAR 0 7
44391: PUSH
44392: LD_EXP 103
44396: PUSH
44397: LD_VAR 0 2
44401: ARRAY
44402: PPUSH
44403: LD_INT 3
44405: PUSH
44406: LD_INT 2
44408: PUSH
44409: LD_INT 30
44411: PUSH
44412: LD_INT 32
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 30
44421: PUSH
44422: LD_INT 33
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 30
44431: PUSH
44432: LD_INT 31
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: PUSH
44445: EMPTY
44446: LIST
44447: LIST
44448: PPUSH
44449: CALL_OW 72
44453: ST_TO_ADDR
// if not to_repair_tmp then
44454: LD_VAR 0 7
44458: NOT
44459: IFFALSE 44463
// continue ;
44461: GO 44196
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44463: LD_ADDR_VAR 0 8
44467: PUSH
44468: LD_VAR 0 7
44472: PPUSH
44473: LD_VAR 0 3
44477: PPUSH
44478: CALL_OW 74
44482: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44483: LD_VAR 0 8
44487: PPUSH
44488: LD_INT 14
44490: PPUSH
44491: CALL 74571 0 2
44495: PUSH
44496: LD_INT 4
44498: ARRAY
44499: PUSH
44500: LD_INT 5
44502: LESS
44503: IFFALSE 44519
// ComRepairBuilding ( j , to_repair ) ;
44505: LD_VAR 0 3
44509: PPUSH
44510: LD_VAR 0 8
44514: PPUSH
44515: CALL_OW 130
// end ;
44519: GO 44196
44521: POP
44522: POP
// end ;
44523: GO 43702
44525: POP
44526: POP
// end ;
44527: LD_VAR 0 1
44531: RET
// export function MC_Heal ; var i , j , tmp ; begin
44532: LD_INT 0
44534: PPUSH
44535: PPUSH
44536: PPUSH
44537: PPUSH
// if not mc_bases then
44538: LD_EXP 102
44542: NOT
44543: IFFALSE 44547
// exit ;
44545: GO 44949
// for i = 1 to mc_bases do
44547: LD_ADDR_VAR 0 2
44551: PUSH
44552: DOUBLE
44553: LD_INT 1
44555: DEC
44556: ST_TO_ADDR
44557: LD_EXP 102
44561: PUSH
44562: FOR_TO
44563: IFFALSE 44947
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44565: LD_EXP 105
44569: PUSH
44570: LD_VAR 0 2
44574: ARRAY
44575: PUSH
44576: LD_INT 1
44578: ARRAY
44579: NOT
44580: PUSH
44581: LD_EXP 105
44585: PUSH
44586: LD_VAR 0 2
44590: ARRAY
44591: PUSH
44592: LD_INT 2
44594: ARRAY
44595: NOT
44596: AND
44597: IFFALSE 44635
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44599: LD_ADDR_EXP 106
44603: PUSH
44604: LD_EXP 106
44608: PPUSH
44609: LD_VAR 0 2
44613: PPUSH
44614: EMPTY
44615: PPUSH
44616: CALL_OW 1
44620: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44621: LD_VAR 0 2
44625: PPUSH
44626: LD_INT 102
44628: PPUSH
44629: CALL 38780 0 2
// continue ;
44633: GO 44562
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44635: LD_ADDR_VAR 0 4
44639: PUSH
44640: LD_EXP 102
44644: PUSH
44645: LD_VAR 0 2
44649: ARRAY
44650: PPUSH
44651: LD_INT 25
44653: PUSH
44654: LD_INT 4
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PPUSH
44661: CALL_OW 72
44665: ST_TO_ADDR
// if not tmp then
44666: LD_VAR 0 4
44670: NOT
44671: IFFALSE 44675
// continue ;
44673: GO 44562
// if mc_taming [ i ] then
44675: LD_EXP 133
44679: PUSH
44680: LD_VAR 0 2
44684: ARRAY
44685: IFFALSE 44709
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44687: LD_ADDR_EXP 133
44691: PUSH
44692: LD_EXP 133
44696: PPUSH
44697: LD_VAR 0 2
44701: PPUSH
44702: EMPTY
44703: PPUSH
44704: CALL_OW 1
44708: ST_TO_ADDR
// for j in tmp do
44709: LD_ADDR_VAR 0 3
44713: PUSH
44714: LD_VAR 0 4
44718: PUSH
44719: FOR_IN
44720: IFFALSE 44943
// begin if IsInUnit ( j ) then
44722: LD_VAR 0 3
44726: PPUSH
44727: CALL_OW 310
44731: IFFALSE 44742
// ComExitBuilding ( j ) ;
44733: LD_VAR 0 3
44737: PPUSH
44738: CALL_OW 122
// if not j in mc_healers [ i ] then
44742: LD_VAR 0 3
44746: PUSH
44747: LD_EXP 106
44751: PUSH
44752: LD_VAR 0 2
44756: ARRAY
44757: IN
44758: NOT
44759: IFFALSE 44805
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44761: LD_ADDR_EXP 106
44765: PUSH
44766: LD_EXP 106
44770: PPUSH
44771: LD_VAR 0 2
44775: PUSH
44776: LD_EXP 106
44780: PUSH
44781: LD_VAR 0 2
44785: ARRAY
44786: PUSH
44787: LD_INT 1
44789: PLUS
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PPUSH
44795: LD_VAR 0 3
44799: PPUSH
44800: CALL 71978 0 3
44804: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44805: LD_VAR 0 3
44809: PPUSH
44810: CALL_OW 110
44814: PUSH
44815: LD_INT 102
44817: NONEQUAL
44818: IFFALSE 44832
// SetTag ( j , 102 ) ;
44820: LD_VAR 0 3
44824: PPUSH
44825: LD_INT 102
44827: PPUSH
44828: CALL_OW 109
// Wait ( 3 ) ;
44832: LD_INT 3
44834: PPUSH
44835: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44839: LD_EXP 105
44843: PUSH
44844: LD_VAR 0 2
44848: ARRAY
44849: PUSH
44850: LD_INT 1
44852: ARRAY
44853: IFFALSE 44885
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44855: LD_VAR 0 3
44859: PPUSH
44860: LD_EXP 105
44864: PUSH
44865: LD_VAR 0 2
44869: ARRAY
44870: PUSH
44871: LD_INT 1
44873: ARRAY
44874: PUSH
44875: LD_INT 1
44877: ARRAY
44878: PPUSH
44879: CALL_OW 128
44883: GO 44941
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44885: LD_VAR 0 3
44889: PPUSH
44890: CALL_OW 314
44894: NOT
44895: PUSH
44896: LD_EXP 105
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: PUSH
44907: LD_INT 2
44909: ARRAY
44910: AND
44911: IFFALSE 44941
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44913: LD_VAR 0 3
44917: PPUSH
44918: LD_EXP 105
44922: PUSH
44923: LD_VAR 0 2
44927: ARRAY
44928: PUSH
44929: LD_INT 2
44931: ARRAY
44932: PUSH
44933: LD_INT 1
44935: ARRAY
44936: PPUSH
44937: CALL_OW 128
// end ;
44941: GO 44719
44943: POP
44944: POP
// end ;
44945: GO 44562
44947: POP
44948: POP
// end ;
44949: LD_VAR 0 1
44953: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44954: LD_INT 0
44956: PPUSH
44957: PPUSH
44958: PPUSH
44959: PPUSH
44960: PPUSH
// if not mc_bases then
44961: LD_EXP 102
44965: NOT
44966: IFFALSE 44970
// exit ;
44968: GO 46113
// for i = 1 to mc_bases do
44970: LD_ADDR_VAR 0 2
44974: PUSH
44975: DOUBLE
44976: LD_INT 1
44978: DEC
44979: ST_TO_ADDR
44980: LD_EXP 102
44984: PUSH
44985: FOR_TO
44986: IFFALSE 46111
// begin if mc_scan [ i ] then
44988: LD_EXP 125
44992: PUSH
44993: LD_VAR 0 2
44997: ARRAY
44998: IFFALSE 45002
// continue ;
45000: GO 44985
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45002: LD_EXP 107
45006: PUSH
45007: LD_VAR 0 2
45011: ARRAY
45012: NOT
45013: PUSH
45014: LD_EXP 109
45018: PUSH
45019: LD_VAR 0 2
45023: ARRAY
45024: NOT
45025: AND
45026: PUSH
45027: LD_EXP 108
45031: PUSH
45032: LD_VAR 0 2
45036: ARRAY
45037: AND
45038: IFFALSE 45076
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45040: LD_ADDR_EXP 108
45044: PUSH
45045: LD_EXP 108
45049: PPUSH
45050: LD_VAR 0 2
45054: PPUSH
45055: EMPTY
45056: PPUSH
45057: CALL_OW 1
45061: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45062: LD_VAR 0 2
45066: PPUSH
45067: LD_INT 103
45069: PPUSH
45070: CALL 38780 0 2
// continue ;
45074: GO 44985
// end ; if mc_construct_list [ i ] then
45076: LD_EXP 109
45080: PUSH
45081: LD_VAR 0 2
45085: ARRAY
45086: IFFALSE 45306
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45088: LD_ADDR_VAR 0 4
45092: PUSH
45093: LD_EXP 102
45097: PUSH
45098: LD_VAR 0 2
45102: ARRAY
45103: PPUSH
45104: LD_INT 25
45106: PUSH
45107: LD_INT 2
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PPUSH
45114: CALL_OW 72
45118: PUSH
45119: LD_EXP 104
45123: PUSH
45124: LD_VAR 0 2
45128: ARRAY
45129: DIFF
45130: ST_TO_ADDR
// if not tmp then
45131: LD_VAR 0 4
45135: NOT
45136: IFFALSE 45140
// continue ;
45138: GO 44985
// for j in tmp do
45140: LD_ADDR_VAR 0 3
45144: PUSH
45145: LD_VAR 0 4
45149: PUSH
45150: FOR_IN
45151: IFFALSE 45302
// begin if not mc_builders [ i ] then
45153: LD_EXP 108
45157: PUSH
45158: LD_VAR 0 2
45162: ARRAY
45163: NOT
45164: IFFALSE 45222
// begin SetTag ( j , 103 ) ;
45166: LD_VAR 0 3
45170: PPUSH
45171: LD_INT 103
45173: PPUSH
45174: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45178: LD_ADDR_EXP 108
45182: PUSH
45183: LD_EXP 108
45187: PPUSH
45188: LD_VAR 0 2
45192: PUSH
45193: LD_EXP 108
45197: PUSH
45198: LD_VAR 0 2
45202: ARRAY
45203: PUSH
45204: LD_INT 1
45206: PLUS
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PPUSH
45212: LD_VAR 0 3
45216: PPUSH
45217: CALL 71978 0 3
45221: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45222: LD_VAR 0 3
45226: PPUSH
45227: CALL_OW 310
45231: IFFALSE 45242
// ComExitBuilding ( j ) ;
45233: LD_VAR 0 3
45237: PPUSH
45238: CALL_OW 122
// wait ( 3 ) ;
45242: LD_INT 3
45244: PPUSH
45245: CALL_OW 67
// if not mc_construct_list [ i ] then
45249: LD_EXP 109
45253: PUSH
45254: LD_VAR 0 2
45258: ARRAY
45259: NOT
45260: IFFALSE 45264
// break ;
45262: GO 45302
// if not HasTask ( j ) then
45264: LD_VAR 0 3
45268: PPUSH
45269: CALL_OW 314
45273: NOT
45274: IFFALSE 45300
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45276: LD_VAR 0 3
45280: PPUSH
45281: LD_EXP 109
45285: PUSH
45286: LD_VAR 0 2
45290: ARRAY
45291: PUSH
45292: LD_INT 1
45294: ARRAY
45295: PPUSH
45296: CALL 74829 0 2
// end ;
45300: GO 45150
45302: POP
45303: POP
// end else
45304: GO 46109
// if mc_build_list [ i ] then
45306: LD_EXP 107
45310: PUSH
45311: LD_VAR 0 2
45315: ARRAY
45316: IFFALSE 46109
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45318: LD_ADDR_VAR 0 5
45322: PUSH
45323: LD_EXP 102
45327: PUSH
45328: LD_VAR 0 2
45332: ARRAY
45333: PPUSH
45334: LD_INT 2
45336: PUSH
45337: LD_INT 30
45339: PUSH
45340: LD_INT 0
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 30
45349: PUSH
45350: LD_INT 1
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: LIST
45361: PPUSH
45362: CALL_OW 72
45366: ST_TO_ADDR
// if depot then
45367: LD_VAR 0 5
45371: IFFALSE 45389
// depot := depot [ 1 ] else
45373: LD_ADDR_VAR 0 5
45377: PUSH
45378: LD_VAR 0 5
45382: PUSH
45383: LD_INT 1
45385: ARRAY
45386: ST_TO_ADDR
45387: GO 45397
// depot := 0 ;
45389: LD_ADDR_VAR 0 5
45393: PUSH
45394: LD_INT 0
45396: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45397: LD_EXP 107
45401: PUSH
45402: LD_VAR 0 2
45406: ARRAY
45407: PUSH
45408: LD_INT 1
45410: ARRAY
45411: PUSH
45412: LD_INT 1
45414: ARRAY
45415: PPUSH
45416: CALL 74659 0 1
45420: PUSH
45421: LD_EXP 102
45425: PUSH
45426: LD_VAR 0 2
45430: ARRAY
45431: PPUSH
45432: LD_INT 2
45434: PUSH
45435: LD_INT 30
45437: PUSH
45438: LD_INT 2
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 30
45447: PUSH
45448: LD_INT 3
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: LIST
45459: PPUSH
45460: CALL_OW 72
45464: NOT
45465: AND
45466: IFFALSE 45571
// begin for j = 1 to mc_build_list [ i ] do
45468: LD_ADDR_VAR 0 3
45472: PUSH
45473: DOUBLE
45474: LD_INT 1
45476: DEC
45477: ST_TO_ADDR
45478: LD_EXP 107
45482: PUSH
45483: LD_VAR 0 2
45487: ARRAY
45488: PUSH
45489: FOR_TO
45490: IFFALSE 45569
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45492: LD_EXP 107
45496: PUSH
45497: LD_VAR 0 2
45501: ARRAY
45502: PUSH
45503: LD_VAR 0 3
45507: ARRAY
45508: PUSH
45509: LD_INT 1
45511: ARRAY
45512: PUSH
45513: LD_INT 2
45515: EQUAL
45516: IFFALSE 45567
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45518: LD_ADDR_EXP 107
45522: PUSH
45523: LD_EXP 107
45527: PPUSH
45528: LD_VAR 0 2
45532: PPUSH
45533: LD_EXP 107
45537: PUSH
45538: LD_VAR 0 2
45542: ARRAY
45543: PPUSH
45544: LD_VAR 0 3
45548: PPUSH
45549: LD_INT 1
45551: PPUSH
45552: LD_INT 0
45554: PPUSH
45555: CALL 71396 0 4
45559: PPUSH
45560: CALL_OW 1
45564: ST_TO_ADDR
// break ;
45565: GO 45569
// end ;
45567: GO 45489
45569: POP
45570: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45571: LD_EXP 107
45575: PUSH
45576: LD_VAR 0 2
45580: ARRAY
45581: PUSH
45582: LD_INT 1
45584: ARRAY
45585: PUSH
45586: LD_INT 1
45588: ARRAY
45589: PUSH
45590: LD_INT 0
45592: EQUAL
45593: PUSH
45594: LD_VAR 0 5
45598: PUSH
45599: LD_VAR 0 5
45603: PPUSH
45604: LD_EXP 107
45608: PUSH
45609: LD_VAR 0 2
45613: ARRAY
45614: PUSH
45615: LD_INT 1
45617: ARRAY
45618: PUSH
45619: LD_INT 1
45621: ARRAY
45622: PPUSH
45623: LD_EXP 107
45627: PUSH
45628: LD_VAR 0 2
45632: ARRAY
45633: PUSH
45634: LD_INT 1
45636: ARRAY
45637: PUSH
45638: LD_INT 2
45640: ARRAY
45641: PPUSH
45642: LD_EXP 107
45646: PUSH
45647: LD_VAR 0 2
45651: ARRAY
45652: PUSH
45653: LD_INT 1
45655: ARRAY
45656: PUSH
45657: LD_INT 3
45659: ARRAY
45660: PPUSH
45661: LD_EXP 107
45665: PUSH
45666: LD_VAR 0 2
45670: ARRAY
45671: PUSH
45672: LD_INT 1
45674: ARRAY
45675: PUSH
45676: LD_INT 4
45678: ARRAY
45679: PPUSH
45680: CALL 79393 0 5
45684: AND
45685: OR
45686: IFFALSE 45967
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45688: LD_ADDR_VAR 0 4
45692: PUSH
45693: LD_EXP 102
45697: PUSH
45698: LD_VAR 0 2
45702: ARRAY
45703: PPUSH
45704: LD_INT 25
45706: PUSH
45707: LD_INT 2
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PPUSH
45714: CALL_OW 72
45718: PUSH
45719: LD_EXP 104
45723: PUSH
45724: LD_VAR 0 2
45728: ARRAY
45729: DIFF
45730: ST_TO_ADDR
// if not tmp then
45731: LD_VAR 0 4
45735: NOT
45736: IFFALSE 45740
// continue ;
45738: GO 44985
// for j in tmp do
45740: LD_ADDR_VAR 0 3
45744: PUSH
45745: LD_VAR 0 4
45749: PUSH
45750: FOR_IN
45751: IFFALSE 45963
// begin if not mc_builders [ i ] then
45753: LD_EXP 108
45757: PUSH
45758: LD_VAR 0 2
45762: ARRAY
45763: NOT
45764: IFFALSE 45822
// begin SetTag ( j , 103 ) ;
45766: LD_VAR 0 3
45770: PPUSH
45771: LD_INT 103
45773: PPUSH
45774: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45778: LD_ADDR_EXP 108
45782: PUSH
45783: LD_EXP 108
45787: PPUSH
45788: LD_VAR 0 2
45792: PUSH
45793: LD_EXP 108
45797: PUSH
45798: LD_VAR 0 2
45802: ARRAY
45803: PUSH
45804: LD_INT 1
45806: PLUS
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PPUSH
45812: LD_VAR 0 3
45816: PPUSH
45817: CALL 71978 0 3
45821: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45822: LD_VAR 0 3
45826: PPUSH
45827: CALL_OW 310
45831: IFFALSE 45842
// ComExitBuilding ( j ) ;
45833: LD_VAR 0 3
45837: PPUSH
45838: CALL_OW 122
// wait ( 3 ) ;
45842: LD_INT 3
45844: PPUSH
45845: CALL_OW 67
// if not mc_build_list [ i ] then
45849: LD_EXP 107
45853: PUSH
45854: LD_VAR 0 2
45858: ARRAY
45859: NOT
45860: IFFALSE 45864
// break ;
45862: GO 45963
// if not HasTask ( j ) then
45864: LD_VAR 0 3
45868: PPUSH
45869: CALL_OW 314
45873: NOT
45874: IFFALSE 45961
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45876: LD_VAR 0 3
45880: PPUSH
45881: LD_EXP 107
45885: PUSH
45886: LD_VAR 0 2
45890: ARRAY
45891: PUSH
45892: LD_INT 1
45894: ARRAY
45895: PUSH
45896: LD_INT 1
45898: ARRAY
45899: PPUSH
45900: LD_EXP 107
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: LD_INT 1
45913: ARRAY
45914: PUSH
45915: LD_INT 2
45917: ARRAY
45918: PPUSH
45919: LD_EXP 107
45923: PUSH
45924: LD_VAR 0 2
45928: ARRAY
45929: PUSH
45930: LD_INT 1
45932: ARRAY
45933: PUSH
45934: LD_INT 3
45936: ARRAY
45937: PPUSH
45938: LD_EXP 107
45942: PUSH
45943: LD_VAR 0 2
45947: ARRAY
45948: PUSH
45949: LD_INT 1
45951: ARRAY
45952: PUSH
45953: LD_INT 4
45955: ARRAY
45956: PPUSH
45957: CALL_OW 145
// end ;
45961: GO 45750
45963: POP
45964: POP
// end else
45965: GO 46109
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45967: LD_EXP 102
45971: PUSH
45972: LD_VAR 0 2
45976: ARRAY
45977: PPUSH
45978: LD_EXP 107
45982: PUSH
45983: LD_VAR 0 2
45987: ARRAY
45988: PUSH
45989: LD_INT 1
45991: ARRAY
45992: PUSH
45993: LD_INT 1
45995: ARRAY
45996: PPUSH
45997: LD_EXP 107
46001: PUSH
46002: LD_VAR 0 2
46006: ARRAY
46007: PUSH
46008: LD_INT 1
46010: ARRAY
46011: PUSH
46012: LD_INT 2
46014: ARRAY
46015: PPUSH
46016: LD_EXP 107
46020: PUSH
46021: LD_VAR 0 2
46025: ARRAY
46026: PUSH
46027: LD_INT 1
46029: ARRAY
46030: PUSH
46031: LD_INT 3
46033: ARRAY
46034: PPUSH
46035: LD_EXP 107
46039: PUSH
46040: LD_VAR 0 2
46044: ARRAY
46045: PUSH
46046: LD_INT 1
46048: ARRAY
46049: PUSH
46050: LD_INT 4
46052: ARRAY
46053: PPUSH
46054: CALL 78729 0 5
46058: NOT
46059: IFFALSE 46109
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46061: LD_ADDR_EXP 107
46065: PUSH
46066: LD_EXP 107
46070: PPUSH
46071: LD_VAR 0 2
46075: PPUSH
46076: LD_EXP 107
46080: PUSH
46081: LD_VAR 0 2
46085: ARRAY
46086: PPUSH
46087: LD_INT 1
46089: PPUSH
46090: LD_INT 1
46092: NEG
46093: PPUSH
46094: LD_INT 0
46096: PPUSH
46097: CALL 71396 0 4
46101: PPUSH
46102: CALL_OW 1
46106: ST_TO_ADDR
// continue ;
46107: GO 44985
// end ; end ; end ;
46109: GO 44985
46111: POP
46112: POP
// end ;
46113: LD_VAR 0 1
46117: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46118: LD_INT 0
46120: PPUSH
46121: PPUSH
46122: PPUSH
46123: PPUSH
46124: PPUSH
46125: PPUSH
// if not mc_bases then
46126: LD_EXP 102
46130: NOT
46131: IFFALSE 46135
// exit ;
46133: GO 46562
// for i = 1 to mc_bases do
46135: LD_ADDR_VAR 0 2
46139: PUSH
46140: DOUBLE
46141: LD_INT 1
46143: DEC
46144: ST_TO_ADDR
46145: LD_EXP 102
46149: PUSH
46150: FOR_TO
46151: IFFALSE 46560
// begin tmp := mc_build_upgrade [ i ] ;
46153: LD_ADDR_VAR 0 4
46157: PUSH
46158: LD_EXP 134
46162: PUSH
46163: LD_VAR 0 2
46167: ARRAY
46168: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46169: LD_ADDR_VAR 0 6
46173: PUSH
46174: LD_EXP 135
46178: PUSH
46179: LD_VAR 0 2
46183: ARRAY
46184: PPUSH
46185: LD_INT 2
46187: PUSH
46188: LD_INT 30
46190: PUSH
46191: LD_INT 6
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 30
46200: PUSH
46201: LD_INT 7
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: LIST
46212: PPUSH
46213: CALL_OW 72
46217: ST_TO_ADDR
// if not tmp and not lab then
46218: LD_VAR 0 4
46222: NOT
46223: PUSH
46224: LD_VAR 0 6
46228: NOT
46229: AND
46230: IFFALSE 46234
// continue ;
46232: GO 46150
// if tmp then
46234: LD_VAR 0 4
46238: IFFALSE 46358
// for j in tmp do
46240: LD_ADDR_VAR 0 3
46244: PUSH
46245: LD_VAR 0 4
46249: PUSH
46250: FOR_IN
46251: IFFALSE 46356
// begin if UpgradeCost ( j ) then
46253: LD_VAR 0 3
46257: PPUSH
46258: CALL 78389 0 1
46262: IFFALSE 46354
// begin ComUpgrade ( j ) ;
46264: LD_VAR 0 3
46268: PPUSH
46269: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46273: LD_ADDR_EXP 134
46277: PUSH
46278: LD_EXP 134
46282: PPUSH
46283: LD_VAR 0 2
46287: PPUSH
46288: LD_EXP 134
46292: PUSH
46293: LD_VAR 0 2
46297: ARRAY
46298: PUSH
46299: LD_VAR 0 3
46303: DIFF
46304: PPUSH
46305: CALL_OW 1
46309: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46310: LD_ADDR_EXP 109
46314: PUSH
46315: LD_EXP 109
46319: PPUSH
46320: LD_VAR 0 2
46324: PUSH
46325: LD_EXP 109
46329: PUSH
46330: LD_VAR 0 2
46334: ARRAY
46335: PUSH
46336: LD_INT 1
46338: PLUS
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PPUSH
46344: LD_VAR 0 3
46348: PPUSH
46349: CALL 71978 0 3
46353: ST_TO_ADDR
// end ; end ;
46354: GO 46250
46356: POP
46357: POP
// if not lab or not mc_lab_upgrade [ i ] then
46358: LD_VAR 0 6
46362: NOT
46363: PUSH
46364: LD_EXP 136
46368: PUSH
46369: LD_VAR 0 2
46373: ARRAY
46374: NOT
46375: OR
46376: IFFALSE 46380
// continue ;
46378: GO 46150
// for j in lab do
46380: LD_ADDR_VAR 0 3
46384: PUSH
46385: LD_VAR 0 6
46389: PUSH
46390: FOR_IN
46391: IFFALSE 46556
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46393: LD_VAR 0 3
46397: PPUSH
46398: CALL_OW 266
46402: PUSH
46403: LD_INT 6
46405: PUSH
46406: LD_INT 7
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: IN
46413: PUSH
46414: LD_VAR 0 3
46418: PPUSH
46419: CALL_OW 461
46423: PUSH
46424: LD_INT 1
46426: NONEQUAL
46427: AND
46428: IFFALSE 46554
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46430: LD_VAR 0 3
46434: PPUSH
46435: LD_EXP 136
46439: PUSH
46440: LD_VAR 0 2
46444: ARRAY
46445: PUSH
46446: LD_INT 1
46448: ARRAY
46449: PPUSH
46450: CALL 78594 0 2
46454: IFFALSE 46554
// begin ComCancel ( j ) ;
46456: LD_VAR 0 3
46460: PPUSH
46461: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46465: LD_VAR 0 3
46469: PPUSH
46470: LD_EXP 136
46474: PUSH
46475: LD_VAR 0 2
46479: ARRAY
46480: PUSH
46481: LD_INT 1
46483: ARRAY
46484: PPUSH
46485: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46489: LD_VAR 0 3
46493: PUSH
46494: LD_EXP 109
46498: PUSH
46499: LD_VAR 0 2
46503: ARRAY
46504: IN
46505: NOT
46506: IFFALSE 46552
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46508: LD_ADDR_EXP 109
46512: PUSH
46513: LD_EXP 109
46517: PPUSH
46518: LD_VAR 0 2
46522: PUSH
46523: LD_EXP 109
46527: PUSH
46528: LD_VAR 0 2
46532: ARRAY
46533: PUSH
46534: LD_INT 1
46536: PLUS
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PPUSH
46542: LD_VAR 0 3
46546: PPUSH
46547: CALL 71978 0 3
46551: ST_TO_ADDR
// break ;
46552: GO 46556
// end ; end ; end ;
46554: GO 46390
46556: POP
46557: POP
// end ;
46558: GO 46150
46560: POP
46561: POP
// end ;
46562: LD_VAR 0 1
46566: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46567: LD_INT 0
46569: PPUSH
46570: PPUSH
46571: PPUSH
46572: PPUSH
46573: PPUSH
46574: PPUSH
46575: PPUSH
46576: PPUSH
46577: PPUSH
// if not mc_bases then
46578: LD_EXP 102
46582: NOT
46583: IFFALSE 46587
// exit ;
46585: GO 46992
// for i = 1 to mc_bases do
46587: LD_ADDR_VAR 0 2
46591: PUSH
46592: DOUBLE
46593: LD_INT 1
46595: DEC
46596: ST_TO_ADDR
46597: LD_EXP 102
46601: PUSH
46602: FOR_TO
46603: IFFALSE 46990
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46605: LD_EXP 110
46609: PUSH
46610: LD_VAR 0 2
46614: ARRAY
46615: NOT
46616: PUSH
46617: LD_EXP 102
46621: PUSH
46622: LD_VAR 0 2
46626: ARRAY
46627: PPUSH
46628: LD_INT 30
46630: PUSH
46631: LD_INT 3
46633: PUSH
46634: EMPTY
46635: LIST
46636: LIST
46637: PPUSH
46638: CALL_OW 72
46642: NOT
46643: OR
46644: IFFALSE 46648
// continue ;
46646: GO 46602
// busy := false ;
46648: LD_ADDR_VAR 0 8
46652: PUSH
46653: LD_INT 0
46655: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46656: LD_ADDR_VAR 0 4
46660: PUSH
46661: LD_EXP 102
46665: PUSH
46666: LD_VAR 0 2
46670: ARRAY
46671: PPUSH
46672: LD_INT 30
46674: PUSH
46675: LD_INT 3
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: PPUSH
46682: CALL_OW 72
46686: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46687: LD_ADDR_VAR 0 6
46691: PUSH
46692: LD_EXP 110
46696: PUSH
46697: LD_VAR 0 2
46701: ARRAY
46702: PPUSH
46703: LD_INT 2
46705: PUSH
46706: LD_INT 30
46708: PUSH
46709: LD_INT 32
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: PUSH
46716: LD_INT 30
46718: PUSH
46719: LD_INT 33
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: LIST
46730: PPUSH
46731: CALL_OW 72
46735: ST_TO_ADDR
// if not t then
46736: LD_VAR 0 6
46740: NOT
46741: IFFALSE 46745
// continue ;
46743: GO 46602
// for j in tmp do
46745: LD_ADDR_VAR 0 3
46749: PUSH
46750: LD_VAR 0 4
46754: PUSH
46755: FOR_IN
46756: IFFALSE 46786
// if not BuildingStatus ( j ) = bs_idle then
46758: LD_VAR 0 3
46762: PPUSH
46763: CALL_OW 461
46767: PUSH
46768: LD_INT 2
46770: EQUAL
46771: NOT
46772: IFFALSE 46784
// begin busy := true ;
46774: LD_ADDR_VAR 0 8
46778: PUSH
46779: LD_INT 1
46781: ST_TO_ADDR
// break ;
46782: GO 46786
// end ;
46784: GO 46755
46786: POP
46787: POP
// if busy then
46788: LD_VAR 0 8
46792: IFFALSE 46796
// continue ;
46794: GO 46602
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46796: LD_ADDR_VAR 0 7
46800: PUSH
46801: LD_VAR 0 6
46805: PPUSH
46806: LD_INT 35
46808: PUSH
46809: LD_INT 0
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PPUSH
46816: CALL_OW 72
46820: ST_TO_ADDR
// if tw then
46821: LD_VAR 0 7
46825: IFFALSE 46902
// begin tw := tw [ 1 ] ;
46827: LD_ADDR_VAR 0 7
46831: PUSH
46832: LD_VAR 0 7
46836: PUSH
46837: LD_INT 1
46839: ARRAY
46840: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46841: LD_ADDR_VAR 0 9
46845: PUSH
46846: LD_VAR 0 7
46850: PPUSH
46851: LD_EXP 127
46855: PUSH
46856: LD_VAR 0 2
46860: ARRAY
46861: PPUSH
46862: CALL 76948 0 2
46866: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46867: LD_EXP 141
46871: PUSH
46872: LD_VAR 0 2
46876: ARRAY
46877: IFFALSE 46900
// if not weapon in mc_allowed_tower_weapons [ i ] then
46879: LD_VAR 0 9
46883: PUSH
46884: LD_EXP 141
46888: PUSH
46889: LD_VAR 0 2
46893: ARRAY
46894: IN
46895: NOT
46896: IFFALSE 46900
// continue ;
46898: GO 46602
// end else
46900: GO 46965
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46902: LD_ADDR_VAR 0 5
46906: PUSH
46907: LD_EXP 110
46911: PUSH
46912: LD_VAR 0 2
46916: ARRAY
46917: PPUSH
46918: LD_VAR 0 4
46922: PPUSH
46923: CALL 107152 0 2
46927: ST_TO_ADDR
// if not tmp2 then
46928: LD_VAR 0 5
46932: NOT
46933: IFFALSE 46937
// continue ;
46935: GO 46602
// tw := tmp2 [ 1 ] ;
46937: LD_ADDR_VAR 0 7
46941: PUSH
46942: LD_VAR 0 5
46946: PUSH
46947: LD_INT 1
46949: ARRAY
46950: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46951: LD_ADDR_VAR 0 9
46955: PUSH
46956: LD_VAR 0 5
46960: PUSH
46961: LD_INT 2
46963: ARRAY
46964: ST_TO_ADDR
// end ; if not weapon then
46965: LD_VAR 0 9
46969: NOT
46970: IFFALSE 46974
// continue ;
46972: GO 46602
// ComPlaceWeapon ( tw , weapon ) ;
46974: LD_VAR 0 7
46978: PPUSH
46979: LD_VAR 0 9
46983: PPUSH
46984: CALL_OW 148
// end ;
46988: GO 46602
46990: POP
46991: POP
// end ;
46992: LD_VAR 0 1
46996: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46997: LD_INT 0
46999: PPUSH
47000: PPUSH
47001: PPUSH
47002: PPUSH
47003: PPUSH
47004: PPUSH
// if not mc_bases then
47005: LD_EXP 102
47009: NOT
47010: IFFALSE 47014
// exit ;
47012: GO 47790
// for i = 1 to mc_bases do
47014: LD_ADDR_VAR 0 2
47018: PUSH
47019: DOUBLE
47020: LD_INT 1
47022: DEC
47023: ST_TO_ADDR
47024: LD_EXP 102
47028: PUSH
47029: FOR_TO
47030: IFFALSE 47788
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47032: LD_EXP 115
47036: PUSH
47037: LD_VAR 0 2
47041: ARRAY
47042: NOT
47043: PUSH
47044: LD_EXP 115
47048: PUSH
47049: LD_VAR 0 2
47053: ARRAY
47054: PUSH
47055: LD_EXP 116
47059: PUSH
47060: LD_VAR 0 2
47064: ARRAY
47065: EQUAL
47066: OR
47067: PUSH
47068: LD_EXP 125
47072: PUSH
47073: LD_VAR 0 2
47077: ARRAY
47078: OR
47079: IFFALSE 47083
// continue ;
47081: GO 47029
// if mc_miners [ i ] then
47083: LD_EXP 116
47087: PUSH
47088: LD_VAR 0 2
47092: ARRAY
47093: IFFALSE 47475
// begin for j = mc_miners [ i ] downto 1 do
47095: LD_ADDR_VAR 0 3
47099: PUSH
47100: DOUBLE
47101: LD_EXP 116
47105: PUSH
47106: LD_VAR 0 2
47110: ARRAY
47111: INC
47112: ST_TO_ADDR
47113: LD_INT 1
47115: PUSH
47116: FOR_DOWNTO
47117: IFFALSE 47473
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47119: LD_EXP 116
47123: PUSH
47124: LD_VAR 0 2
47128: ARRAY
47129: PUSH
47130: LD_VAR 0 3
47134: ARRAY
47135: PPUSH
47136: CALL_OW 301
47140: PUSH
47141: LD_EXP 116
47145: PUSH
47146: LD_VAR 0 2
47150: ARRAY
47151: PUSH
47152: LD_VAR 0 3
47156: ARRAY
47157: PPUSH
47158: CALL_OW 257
47162: PUSH
47163: LD_INT 1
47165: NONEQUAL
47166: OR
47167: IFFALSE 47230
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47169: LD_ADDR_VAR 0 5
47173: PUSH
47174: LD_EXP 116
47178: PUSH
47179: LD_VAR 0 2
47183: ARRAY
47184: PUSH
47185: LD_EXP 116
47189: PUSH
47190: LD_VAR 0 2
47194: ARRAY
47195: PUSH
47196: LD_VAR 0 3
47200: ARRAY
47201: DIFF
47202: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47203: LD_ADDR_EXP 116
47207: PUSH
47208: LD_EXP 116
47212: PPUSH
47213: LD_VAR 0 2
47217: PPUSH
47218: LD_VAR 0 5
47222: PPUSH
47223: CALL_OW 1
47227: ST_TO_ADDR
// continue ;
47228: GO 47116
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47230: LD_EXP 116
47234: PUSH
47235: LD_VAR 0 2
47239: ARRAY
47240: PUSH
47241: LD_VAR 0 3
47245: ARRAY
47246: PPUSH
47247: CALL_OW 257
47251: PUSH
47252: LD_INT 1
47254: EQUAL
47255: PUSH
47256: LD_EXP 116
47260: PUSH
47261: LD_VAR 0 2
47265: ARRAY
47266: PUSH
47267: LD_VAR 0 3
47271: ARRAY
47272: PPUSH
47273: CALL_OW 459
47277: NOT
47278: AND
47279: PUSH
47280: LD_EXP 116
47284: PUSH
47285: LD_VAR 0 2
47289: ARRAY
47290: PUSH
47291: LD_VAR 0 3
47295: ARRAY
47296: PPUSH
47297: CALL_OW 314
47301: NOT
47302: AND
47303: IFFALSE 47471
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47305: LD_EXP 116
47309: PUSH
47310: LD_VAR 0 2
47314: ARRAY
47315: PUSH
47316: LD_VAR 0 3
47320: ARRAY
47321: PPUSH
47322: CALL_OW 310
47326: IFFALSE 47349
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47328: LD_EXP 116
47332: PUSH
47333: LD_VAR 0 2
47337: ARRAY
47338: PUSH
47339: LD_VAR 0 3
47343: ARRAY
47344: PPUSH
47345: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47349: LD_EXP 116
47353: PUSH
47354: LD_VAR 0 2
47358: ARRAY
47359: PUSH
47360: LD_VAR 0 3
47364: ARRAY
47365: PPUSH
47366: CALL_OW 314
47370: NOT
47371: IFFALSE 47471
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47373: LD_EXP 116
47377: PUSH
47378: LD_VAR 0 2
47382: ARRAY
47383: PUSH
47384: LD_VAR 0 3
47388: ARRAY
47389: PPUSH
47390: LD_EXP 115
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PUSH
47401: LD_VAR 0 3
47405: PUSH
47406: LD_EXP 115
47410: PUSH
47411: LD_VAR 0 2
47415: ARRAY
47416: MOD
47417: PUSH
47418: LD_INT 1
47420: PLUS
47421: ARRAY
47422: PUSH
47423: LD_INT 1
47425: ARRAY
47426: PPUSH
47427: LD_EXP 115
47431: PUSH
47432: LD_VAR 0 2
47436: ARRAY
47437: PUSH
47438: LD_VAR 0 3
47442: PUSH
47443: LD_EXP 115
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: MOD
47454: PUSH
47455: LD_INT 1
47457: PLUS
47458: ARRAY
47459: PUSH
47460: LD_INT 2
47462: ARRAY
47463: PPUSH
47464: LD_INT 0
47466: PPUSH
47467: CALL_OW 193
// end ; end ;
47471: GO 47116
47473: POP
47474: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47475: LD_ADDR_VAR 0 5
47479: PUSH
47480: LD_EXP 102
47484: PUSH
47485: LD_VAR 0 2
47489: ARRAY
47490: PPUSH
47491: LD_INT 2
47493: PUSH
47494: LD_INT 30
47496: PUSH
47497: LD_INT 4
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 30
47506: PUSH
47507: LD_INT 5
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: PUSH
47514: LD_INT 30
47516: PUSH
47517: LD_INT 32
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: PPUSH
47530: CALL_OW 72
47534: ST_TO_ADDR
// if not tmp then
47535: LD_VAR 0 5
47539: NOT
47540: IFFALSE 47544
// continue ;
47542: GO 47029
// list := [ ] ;
47544: LD_ADDR_VAR 0 6
47548: PUSH
47549: EMPTY
47550: ST_TO_ADDR
// for j in tmp do
47551: LD_ADDR_VAR 0 3
47555: PUSH
47556: LD_VAR 0 5
47560: PUSH
47561: FOR_IN
47562: IFFALSE 47631
// begin for k in UnitsInside ( j ) do
47564: LD_ADDR_VAR 0 4
47568: PUSH
47569: LD_VAR 0 3
47573: PPUSH
47574: CALL_OW 313
47578: PUSH
47579: FOR_IN
47580: IFFALSE 47627
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47582: LD_VAR 0 4
47586: PPUSH
47587: CALL_OW 257
47591: PUSH
47592: LD_INT 1
47594: EQUAL
47595: PUSH
47596: LD_VAR 0 4
47600: PPUSH
47601: CALL_OW 459
47605: NOT
47606: AND
47607: IFFALSE 47625
// list := list ^ k ;
47609: LD_ADDR_VAR 0 6
47613: PUSH
47614: LD_VAR 0 6
47618: PUSH
47619: LD_VAR 0 4
47623: ADD
47624: ST_TO_ADDR
47625: GO 47579
47627: POP
47628: POP
// end ;
47629: GO 47561
47631: POP
47632: POP
// list := list diff mc_miners [ i ] ;
47633: LD_ADDR_VAR 0 6
47637: PUSH
47638: LD_VAR 0 6
47642: PUSH
47643: LD_EXP 116
47647: PUSH
47648: LD_VAR 0 2
47652: ARRAY
47653: DIFF
47654: ST_TO_ADDR
// if not list then
47655: LD_VAR 0 6
47659: NOT
47660: IFFALSE 47664
// continue ;
47662: GO 47029
// k := mc_mines [ i ] - mc_miners [ i ] ;
47664: LD_ADDR_VAR 0 4
47668: PUSH
47669: LD_EXP 115
47673: PUSH
47674: LD_VAR 0 2
47678: ARRAY
47679: PUSH
47680: LD_EXP 116
47684: PUSH
47685: LD_VAR 0 2
47689: ARRAY
47690: MINUS
47691: ST_TO_ADDR
// if k > list then
47692: LD_VAR 0 4
47696: PUSH
47697: LD_VAR 0 6
47701: GREATER
47702: IFFALSE 47714
// k := list ;
47704: LD_ADDR_VAR 0 4
47708: PUSH
47709: LD_VAR 0 6
47713: ST_TO_ADDR
// for j = 1 to k do
47714: LD_ADDR_VAR 0 3
47718: PUSH
47719: DOUBLE
47720: LD_INT 1
47722: DEC
47723: ST_TO_ADDR
47724: LD_VAR 0 4
47728: PUSH
47729: FOR_TO
47730: IFFALSE 47784
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47732: LD_ADDR_EXP 116
47736: PUSH
47737: LD_EXP 116
47741: PPUSH
47742: LD_VAR 0 2
47746: PUSH
47747: LD_EXP 116
47751: PUSH
47752: LD_VAR 0 2
47756: ARRAY
47757: PUSH
47758: LD_INT 1
47760: PLUS
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: LD_VAR 0 6
47770: PUSH
47771: LD_VAR 0 3
47775: ARRAY
47776: PPUSH
47777: CALL 71978 0 3
47781: ST_TO_ADDR
47782: GO 47729
47784: POP
47785: POP
// end ;
47786: GO 47029
47788: POP
47789: POP
// end ;
47790: LD_VAR 0 1
47794: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47795: LD_INT 0
47797: PPUSH
47798: PPUSH
47799: PPUSH
47800: PPUSH
47801: PPUSH
47802: PPUSH
47803: PPUSH
47804: PPUSH
47805: PPUSH
47806: PPUSH
// if not mc_bases then
47807: LD_EXP 102
47811: NOT
47812: IFFALSE 47816
// exit ;
47814: GO 49566
// for i = 1 to mc_bases do
47816: LD_ADDR_VAR 0 2
47820: PUSH
47821: DOUBLE
47822: LD_INT 1
47824: DEC
47825: ST_TO_ADDR
47826: LD_EXP 102
47830: PUSH
47831: FOR_TO
47832: IFFALSE 49564
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47834: LD_EXP 102
47838: PUSH
47839: LD_VAR 0 2
47843: ARRAY
47844: NOT
47845: PUSH
47846: LD_EXP 109
47850: PUSH
47851: LD_VAR 0 2
47855: ARRAY
47856: OR
47857: IFFALSE 47861
// continue ;
47859: GO 47831
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47861: LD_EXP 118
47865: PUSH
47866: LD_VAR 0 2
47870: ARRAY
47871: NOT
47872: PUSH
47873: LD_EXP 119
47877: PUSH
47878: LD_VAR 0 2
47882: ARRAY
47883: AND
47884: IFFALSE 47922
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47886: LD_ADDR_EXP 119
47890: PUSH
47891: LD_EXP 119
47895: PPUSH
47896: LD_VAR 0 2
47900: PPUSH
47901: EMPTY
47902: PPUSH
47903: CALL_OW 1
47907: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47908: LD_VAR 0 2
47912: PPUSH
47913: LD_INT 107
47915: PPUSH
47916: CALL 38780 0 2
// continue ;
47920: GO 47831
// end ; target := [ ] ;
47922: LD_ADDR_VAR 0 6
47926: PUSH
47927: EMPTY
47928: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47929: LD_ADDR_VAR 0 3
47933: PUSH
47934: DOUBLE
47935: LD_EXP 118
47939: PUSH
47940: LD_VAR 0 2
47944: ARRAY
47945: INC
47946: ST_TO_ADDR
47947: LD_INT 1
47949: PUSH
47950: FOR_DOWNTO
47951: IFFALSE 48211
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47953: LD_EXP 118
47957: PUSH
47958: LD_VAR 0 2
47962: ARRAY
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PUSH
47970: LD_INT 2
47972: ARRAY
47973: PPUSH
47974: LD_EXP 118
47978: PUSH
47979: LD_VAR 0 2
47983: ARRAY
47984: PUSH
47985: LD_VAR 0 3
47989: ARRAY
47990: PUSH
47991: LD_INT 3
47993: ARRAY
47994: PPUSH
47995: CALL_OW 488
47999: PUSH
48000: LD_EXP 118
48004: PUSH
48005: LD_VAR 0 2
48009: ARRAY
48010: PUSH
48011: LD_VAR 0 3
48015: ARRAY
48016: PUSH
48017: LD_INT 2
48019: ARRAY
48020: PPUSH
48021: LD_EXP 118
48025: PUSH
48026: LD_VAR 0 2
48030: ARRAY
48031: PUSH
48032: LD_VAR 0 3
48036: ARRAY
48037: PUSH
48038: LD_INT 3
48040: ARRAY
48041: PPUSH
48042: CALL_OW 284
48046: PUSH
48047: LD_INT 0
48049: EQUAL
48050: AND
48051: IFFALSE 48106
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48053: LD_ADDR_VAR 0 5
48057: PUSH
48058: LD_EXP 118
48062: PUSH
48063: LD_VAR 0 2
48067: ARRAY
48068: PPUSH
48069: LD_VAR 0 3
48073: PPUSH
48074: CALL_OW 3
48078: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48079: LD_ADDR_EXP 118
48083: PUSH
48084: LD_EXP 118
48088: PPUSH
48089: LD_VAR 0 2
48093: PPUSH
48094: LD_VAR 0 5
48098: PPUSH
48099: CALL_OW 1
48103: ST_TO_ADDR
// continue ;
48104: GO 47950
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48106: LD_EXP 102
48110: PUSH
48111: LD_VAR 0 2
48115: ARRAY
48116: PUSH
48117: LD_INT 1
48119: ARRAY
48120: PPUSH
48121: CALL_OW 255
48125: PPUSH
48126: LD_EXP 118
48130: PUSH
48131: LD_VAR 0 2
48135: ARRAY
48136: PUSH
48137: LD_VAR 0 3
48141: ARRAY
48142: PUSH
48143: LD_INT 2
48145: ARRAY
48146: PPUSH
48147: LD_EXP 118
48151: PUSH
48152: LD_VAR 0 2
48156: ARRAY
48157: PUSH
48158: LD_VAR 0 3
48162: ARRAY
48163: PUSH
48164: LD_INT 3
48166: ARRAY
48167: PPUSH
48168: LD_INT 30
48170: PPUSH
48171: CALL 72874 0 4
48175: PUSH
48176: LD_INT 4
48178: ARRAY
48179: PUSH
48180: LD_INT 0
48182: EQUAL
48183: IFFALSE 48209
// begin target := mc_crates [ i ] [ j ] ;
48185: LD_ADDR_VAR 0 6
48189: PUSH
48190: LD_EXP 118
48194: PUSH
48195: LD_VAR 0 2
48199: ARRAY
48200: PUSH
48201: LD_VAR 0 3
48205: ARRAY
48206: ST_TO_ADDR
// break ;
48207: GO 48211
// end ; end ;
48209: GO 47950
48211: POP
48212: POP
// if not target then
48213: LD_VAR 0 6
48217: NOT
48218: IFFALSE 48222
// continue ;
48220: GO 47831
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48222: LD_ADDR_VAR 0 7
48226: PUSH
48227: LD_EXP 121
48231: PUSH
48232: LD_VAR 0 2
48236: ARRAY
48237: PPUSH
48238: LD_INT 2
48240: PUSH
48241: LD_INT 3
48243: PUSH
48244: LD_INT 58
48246: PUSH
48247: EMPTY
48248: LIST
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 61
48256: PUSH
48257: EMPTY
48258: LIST
48259: PUSH
48260: LD_INT 33
48262: PUSH
48263: LD_INT 5
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: PUSH
48270: LD_INT 33
48272: PUSH
48273: LD_INT 3
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: EMPTY
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 2
48289: PUSH
48290: LD_INT 34
48292: PUSH
48293: LD_INT 32
48295: PUSH
48296: EMPTY
48297: LIST
48298: LIST
48299: PUSH
48300: LD_INT 34
48302: PUSH
48303: LD_INT 51
48305: PUSH
48306: EMPTY
48307: LIST
48308: LIST
48309: PUSH
48310: LD_INT 34
48312: PUSH
48313: LD_INT 12
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: LIST
48324: LIST
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: PPUSH
48330: CALL_OW 72
48334: ST_TO_ADDR
// if not cargo then
48335: LD_VAR 0 7
48339: NOT
48340: IFFALSE 48983
// begin if mc_crates_collector [ i ] < 5 then
48342: LD_EXP 119
48346: PUSH
48347: LD_VAR 0 2
48351: ARRAY
48352: PUSH
48353: LD_INT 5
48355: LESS
48356: IFFALSE 48722
// begin if mc_ape [ i ] then
48358: LD_EXP 131
48362: PUSH
48363: LD_VAR 0 2
48367: ARRAY
48368: IFFALSE 48415
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48370: LD_ADDR_VAR 0 5
48374: PUSH
48375: LD_EXP 131
48379: PUSH
48380: LD_VAR 0 2
48384: ARRAY
48385: PPUSH
48386: LD_INT 25
48388: PUSH
48389: LD_INT 16
48391: PUSH
48392: EMPTY
48393: LIST
48394: LIST
48395: PUSH
48396: LD_INT 24
48398: PUSH
48399: LD_INT 750
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PUSH
48406: EMPTY
48407: LIST
48408: LIST
48409: PPUSH
48410: CALL_OW 72
48414: ST_TO_ADDR
// if not tmp then
48415: LD_VAR 0 5
48419: NOT
48420: IFFALSE 48467
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48422: LD_ADDR_VAR 0 5
48426: PUSH
48427: LD_EXP 102
48431: PUSH
48432: LD_VAR 0 2
48436: ARRAY
48437: PPUSH
48438: LD_INT 25
48440: PUSH
48441: LD_INT 2
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: PUSH
48448: LD_INT 24
48450: PUSH
48451: LD_INT 750
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: PPUSH
48462: CALL_OW 72
48466: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48467: LD_EXP 131
48471: PUSH
48472: LD_VAR 0 2
48476: ARRAY
48477: PUSH
48478: LD_EXP 102
48482: PUSH
48483: LD_VAR 0 2
48487: ARRAY
48488: PPUSH
48489: LD_INT 25
48491: PUSH
48492: LD_INT 2
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: PUSH
48499: LD_INT 24
48501: PUSH
48502: LD_INT 750
48504: PUSH
48505: EMPTY
48506: LIST
48507: LIST
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: PPUSH
48513: CALL_OW 72
48517: AND
48518: PUSH
48519: LD_VAR 0 5
48523: PUSH
48524: LD_INT 5
48526: LESS
48527: AND
48528: IFFALSE 48610
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48530: LD_ADDR_VAR 0 3
48534: PUSH
48535: LD_EXP 102
48539: PUSH
48540: LD_VAR 0 2
48544: ARRAY
48545: PPUSH
48546: LD_INT 25
48548: PUSH
48549: LD_INT 2
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: PUSH
48556: LD_INT 24
48558: PUSH
48559: LD_INT 750
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: PUSH
48566: EMPTY
48567: LIST
48568: LIST
48569: PPUSH
48570: CALL_OW 72
48574: PUSH
48575: FOR_IN
48576: IFFALSE 48608
// begin tmp := tmp union j ;
48578: LD_ADDR_VAR 0 5
48582: PUSH
48583: LD_VAR 0 5
48587: PUSH
48588: LD_VAR 0 3
48592: UNION
48593: ST_TO_ADDR
// if tmp >= 5 then
48594: LD_VAR 0 5
48598: PUSH
48599: LD_INT 5
48601: GREATEREQUAL
48602: IFFALSE 48606
// break ;
48604: GO 48608
// end ;
48606: GO 48575
48608: POP
48609: POP
// end ; if not tmp then
48610: LD_VAR 0 5
48614: NOT
48615: IFFALSE 48619
// continue ;
48617: GO 47831
// for j in tmp do
48619: LD_ADDR_VAR 0 3
48623: PUSH
48624: LD_VAR 0 5
48628: PUSH
48629: FOR_IN
48630: IFFALSE 48720
// if not GetTag ( j ) then
48632: LD_VAR 0 3
48636: PPUSH
48637: CALL_OW 110
48641: NOT
48642: IFFALSE 48718
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48644: LD_ADDR_EXP 119
48648: PUSH
48649: LD_EXP 119
48653: PPUSH
48654: LD_VAR 0 2
48658: PUSH
48659: LD_EXP 119
48663: PUSH
48664: LD_VAR 0 2
48668: ARRAY
48669: PUSH
48670: LD_INT 1
48672: PLUS
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PPUSH
48678: LD_VAR 0 3
48682: PPUSH
48683: CALL 71978 0 3
48687: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48688: LD_VAR 0 3
48692: PPUSH
48693: LD_INT 107
48695: PPUSH
48696: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48700: LD_EXP 119
48704: PUSH
48705: LD_VAR 0 2
48709: ARRAY
48710: PUSH
48711: LD_INT 5
48713: GREATEREQUAL
48714: IFFALSE 48718
// break ;
48716: GO 48720
// end ;
48718: GO 48629
48720: POP
48721: POP
// end ; if mc_crates_collector [ i ] and target then
48722: LD_EXP 119
48726: PUSH
48727: LD_VAR 0 2
48731: ARRAY
48732: PUSH
48733: LD_VAR 0 6
48737: AND
48738: IFFALSE 48981
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48740: LD_EXP 119
48744: PUSH
48745: LD_VAR 0 2
48749: ARRAY
48750: PUSH
48751: LD_VAR 0 6
48755: PUSH
48756: LD_INT 1
48758: ARRAY
48759: LESS
48760: IFFALSE 48780
// tmp := mc_crates_collector [ i ] else
48762: LD_ADDR_VAR 0 5
48766: PUSH
48767: LD_EXP 119
48771: PUSH
48772: LD_VAR 0 2
48776: ARRAY
48777: ST_TO_ADDR
48778: GO 48794
// tmp := target [ 1 ] ;
48780: LD_ADDR_VAR 0 5
48784: PUSH
48785: LD_VAR 0 6
48789: PUSH
48790: LD_INT 1
48792: ARRAY
48793: ST_TO_ADDR
// k := 0 ;
48794: LD_ADDR_VAR 0 4
48798: PUSH
48799: LD_INT 0
48801: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48802: LD_ADDR_VAR 0 3
48806: PUSH
48807: LD_EXP 119
48811: PUSH
48812: LD_VAR 0 2
48816: ARRAY
48817: PUSH
48818: FOR_IN
48819: IFFALSE 48979
// begin k := k + 1 ;
48821: LD_ADDR_VAR 0 4
48825: PUSH
48826: LD_VAR 0 4
48830: PUSH
48831: LD_INT 1
48833: PLUS
48834: ST_TO_ADDR
// if k > tmp then
48835: LD_VAR 0 4
48839: PUSH
48840: LD_VAR 0 5
48844: GREATER
48845: IFFALSE 48849
// break ;
48847: GO 48979
// if not GetClass ( j ) in [ 2 , 16 ] then
48849: LD_VAR 0 3
48853: PPUSH
48854: CALL_OW 257
48858: PUSH
48859: LD_INT 2
48861: PUSH
48862: LD_INT 16
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: IN
48869: NOT
48870: IFFALSE 48923
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48872: LD_ADDR_EXP 119
48876: PUSH
48877: LD_EXP 119
48881: PPUSH
48882: LD_VAR 0 2
48886: PPUSH
48887: LD_EXP 119
48891: PUSH
48892: LD_VAR 0 2
48896: ARRAY
48897: PUSH
48898: LD_VAR 0 3
48902: DIFF
48903: PPUSH
48904: CALL_OW 1
48908: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48909: LD_VAR 0 3
48913: PPUSH
48914: LD_INT 0
48916: PPUSH
48917: CALL_OW 109
// continue ;
48921: GO 48818
// end ; if IsInUnit ( j ) then
48923: LD_VAR 0 3
48927: PPUSH
48928: CALL_OW 310
48932: IFFALSE 48943
// ComExitBuilding ( j ) ;
48934: LD_VAR 0 3
48938: PPUSH
48939: CALL_OW 122
// wait ( 3 ) ;
48943: LD_INT 3
48945: PPUSH
48946: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48950: LD_VAR 0 3
48954: PPUSH
48955: LD_VAR 0 6
48959: PUSH
48960: LD_INT 2
48962: ARRAY
48963: PPUSH
48964: LD_VAR 0 6
48968: PUSH
48969: LD_INT 3
48971: ARRAY
48972: PPUSH
48973: CALL_OW 117
// end ;
48977: GO 48818
48979: POP
48980: POP
// end ; end else
48981: GO 49562
// begin for j in cargo do
48983: LD_ADDR_VAR 0 3
48987: PUSH
48988: LD_VAR 0 7
48992: PUSH
48993: FOR_IN
48994: IFFALSE 49560
// begin if GetTag ( j ) <> 0 then
48996: LD_VAR 0 3
49000: PPUSH
49001: CALL_OW 110
49005: PUSH
49006: LD_INT 0
49008: NONEQUAL
49009: IFFALSE 49013
// continue ;
49011: GO 48993
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49013: LD_VAR 0 3
49017: PPUSH
49018: CALL_OW 256
49022: PUSH
49023: LD_INT 1000
49025: LESS
49026: PUSH
49027: LD_VAR 0 3
49031: PPUSH
49032: LD_EXP 126
49036: PUSH
49037: LD_VAR 0 2
49041: ARRAY
49042: PPUSH
49043: CALL_OW 308
49047: NOT
49048: AND
49049: IFFALSE 49071
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49051: LD_VAR 0 3
49055: PPUSH
49056: LD_EXP 126
49060: PUSH
49061: LD_VAR 0 2
49065: ARRAY
49066: PPUSH
49067: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49071: LD_VAR 0 3
49075: PPUSH
49076: CALL_OW 256
49080: PUSH
49081: LD_INT 1000
49083: LESS
49084: PUSH
49085: LD_VAR 0 3
49089: PPUSH
49090: LD_EXP 126
49094: PUSH
49095: LD_VAR 0 2
49099: ARRAY
49100: PPUSH
49101: CALL_OW 308
49105: AND
49106: IFFALSE 49110
// continue ;
49108: GO 48993
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49110: LD_VAR 0 3
49114: PPUSH
49115: CALL_OW 262
49119: PUSH
49120: LD_INT 2
49122: EQUAL
49123: PUSH
49124: LD_VAR 0 3
49128: PPUSH
49129: CALL_OW 261
49133: PUSH
49134: LD_INT 15
49136: LESS
49137: AND
49138: IFFALSE 49142
// continue ;
49140: GO 48993
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49142: LD_VAR 0 3
49146: PPUSH
49147: CALL_OW 262
49151: PUSH
49152: LD_INT 1
49154: EQUAL
49155: PUSH
49156: LD_VAR 0 3
49160: PPUSH
49161: CALL_OW 261
49165: PUSH
49166: LD_INT 10
49168: LESS
49169: AND
49170: IFFALSE 49499
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49172: LD_ADDR_VAR 0 8
49176: PUSH
49177: LD_EXP 102
49181: PUSH
49182: LD_VAR 0 2
49186: ARRAY
49187: PPUSH
49188: LD_INT 2
49190: PUSH
49191: LD_INT 30
49193: PUSH
49194: LD_INT 0
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 30
49203: PUSH
49204: LD_INT 1
49206: PUSH
49207: EMPTY
49208: LIST
49209: LIST
49210: PUSH
49211: EMPTY
49212: LIST
49213: LIST
49214: LIST
49215: PPUSH
49216: CALL_OW 72
49220: ST_TO_ADDR
// if not depot then
49221: LD_VAR 0 8
49225: NOT
49226: IFFALSE 49230
// continue ;
49228: GO 48993
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49230: LD_VAR 0 3
49234: PPUSH
49235: LD_VAR 0 8
49239: PPUSH
49240: LD_VAR 0 3
49244: PPUSH
49245: CALL_OW 74
49249: PPUSH
49250: CALL_OW 296
49254: PUSH
49255: LD_INT 6
49257: LESS
49258: IFFALSE 49274
// SetFuel ( j , 100 ) else
49260: LD_VAR 0 3
49264: PPUSH
49265: LD_INT 100
49267: PPUSH
49268: CALL_OW 240
49272: GO 49499
// if GetFuel ( j ) = 0 then
49274: LD_VAR 0 3
49278: PPUSH
49279: CALL_OW 261
49283: PUSH
49284: LD_INT 0
49286: EQUAL
49287: IFFALSE 49499
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49289: LD_ADDR_EXP 121
49293: PUSH
49294: LD_EXP 121
49298: PPUSH
49299: LD_VAR 0 2
49303: PPUSH
49304: LD_EXP 121
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: PUSH
49315: LD_VAR 0 3
49319: DIFF
49320: PPUSH
49321: CALL_OW 1
49325: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49326: LD_VAR 0 3
49330: PPUSH
49331: CALL_OW 263
49335: PUSH
49336: LD_INT 1
49338: EQUAL
49339: IFFALSE 49355
// ComExitVehicle ( IsInUnit ( j ) ) ;
49341: LD_VAR 0 3
49345: PPUSH
49346: CALL_OW 310
49350: PPUSH
49351: CALL_OW 121
// if GetControl ( j ) = control_remote then
49355: LD_VAR 0 3
49359: PPUSH
49360: CALL_OW 263
49364: PUSH
49365: LD_INT 2
49367: EQUAL
49368: IFFALSE 49379
// ComUnlink ( j ) ;
49370: LD_VAR 0 3
49374: PPUSH
49375: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49379: LD_ADDR_VAR 0 9
49383: PUSH
49384: LD_VAR 0 2
49388: PPUSH
49389: LD_INT 3
49391: PPUSH
49392: CALL 58852 0 2
49396: ST_TO_ADDR
// if fac then
49397: LD_VAR 0 9
49401: IFFALSE 49497
// begin for k in fac do
49403: LD_ADDR_VAR 0 4
49407: PUSH
49408: LD_VAR 0 9
49412: PUSH
49413: FOR_IN
49414: IFFALSE 49495
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49416: LD_ADDR_VAR 0 10
49420: PUSH
49421: LD_VAR 0 9
49425: PPUSH
49426: LD_VAR 0 3
49430: PPUSH
49431: CALL_OW 265
49435: PPUSH
49436: LD_VAR 0 3
49440: PPUSH
49441: CALL_OW 262
49445: PPUSH
49446: LD_VAR 0 3
49450: PPUSH
49451: CALL_OW 263
49455: PPUSH
49456: LD_VAR 0 3
49460: PPUSH
49461: CALL_OW 264
49465: PPUSH
49466: CALL 69510 0 5
49470: ST_TO_ADDR
// if components then
49471: LD_VAR 0 10
49475: IFFALSE 49493
// begin MC_InsertProduceList ( i , components ) ;
49477: LD_VAR 0 2
49481: PPUSH
49482: LD_VAR 0 10
49486: PPUSH
49487: CALL 58397 0 2
// break ;
49491: GO 49495
// end ; end ;
49493: GO 49413
49495: POP
49496: POP
// end ; continue ;
49497: GO 48993
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_INT 1
49506: PPUSH
49507: CALL_OW 289
49511: PUSH
49512: LD_INT 100
49514: LESS
49515: PUSH
49516: LD_VAR 0 3
49520: PPUSH
49521: CALL_OW 314
49525: NOT
49526: AND
49527: IFFALSE 49556
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49529: LD_VAR 0 3
49533: PPUSH
49534: LD_VAR 0 6
49538: PUSH
49539: LD_INT 2
49541: ARRAY
49542: PPUSH
49543: LD_VAR 0 6
49547: PUSH
49548: LD_INT 3
49550: ARRAY
49551: PPUSH
49552: CALL_OW 117
// break ;
49556: GO 49560
// end ;
49558: GO 48993
49560: POP
49561: POP
// end ; end ;
49562: GO 47831
49564: POP
49565: POP
// end ;
49566: LD_VAR 0 1
49570: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49571: LD_INT 0
49573: PPUSH
49574: PPUSH
49575: PPUSH
49576: PPUSH
// if not mc_bases then
49577: LD_EXP 102
49581: NOT
49582: IFFALSE 49586
// exit ;
49584: GO 49747
// for i = 1 to mc_bases do
49586: LD_ADDR_VAR 0 2
49590: PUSH
49591: DOUBLE
49592: LD_INT 1
49594: DEC
49595: ST_TO_ADDR
49596: LD_EXP 102
49600: PUSH
49601: FOR_TO
49602: IFFALSE 49745
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49604: LD_ADDR_VAR 0 4
49608: PUSH
49609: LD_EXP 121
49613: PUSH
49614: LD_VAR 0 2
49618: ARRAY
49619: PUSH
49620: LD_EXP 124
49624: PUSH
49625: LD_VAR 0 2
49629: ARRAY
49630: UNION
49631: PPUSH
49632: LD_INT 33
49634: PUSH
49635: LD_INT 2
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PPUSH
49642: CALL_OW 72
49646: ST_TO_ADDR
// if tmp then
49647: LD_VAR 0 4
49651: IFFALSE 49743
// for j in tmp do
49653: LD_ADDR_VAR 0 3
49657: PUSH
49658: LD_VAR 0 4
49662: PUSH
49663: FOR_IN
49664: IFFALSE 49741
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49666: LD_VAR 0 3
49670: PPUSH
49671: CALL_OW 312
49675: NOT
49676: PUSH
49677: LD_VAR 0 3
49681: PPUSH
49682: CALL_OW 256
49686: PUSH
49687: LD_INT 250
49689: GREATEREQUAL
49690: AND
49691: IFFALSE 49704
// Connect ( j ) else
49693: LD_VAR 0 3
49697: PPUSH
49698: CALL 74911 0 1
49702: GO 49739
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49704: LD_VAR 0 3
49708: PPUSH
49709: CALL_OW 256
49713: PUSH
49714: LD_INT 250
49716: LESS
49717: PUSH
49718: LD_VAR 0 3
49722: PPUSH
49723: CALL_OW 312
49727: AND
49728: IFFALSE 49739
// ComUnlink ( j ) ;
49730: LD_VAR 0 3
49734: PPUSH
49735: CALL_OW 136
49739: GO 49663
49741: POP
49742: POP
// end ;
49743: GO 49601
49745: POP
49746: POP
// end ;
49747: LD_VAR 0 1
49751: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49752: LD_INT 0
49754: PPUSH
49755: PPUSH
49756: PPUSH
49757: PPUSH
49758: PPUSH
// if not mc_bases then
49759: LD_EXP 102
49763: NOT
49764: IFFALSE 49768
// exit ;
49766: GO 50213
// for i = 1 to mc_bases do
49768: LD_ADDR_VAR 0 2
49772: PUSH
49773: DOUBLE
49774: LD_INT 1
49776: DEC
49777: ST_TO_ADDR
49778: LD_EXP 102
49782: PUSH
49783: FOR_TO
49784: IFFALSE 50211
// begin if not mc_produce [ i ] then
49786: LD_EXP 123
49790: PUSH
49791: LD_VAR 0 2
49795: ARRAY
49796: NOT
49797: IFFALSE 49801
// continue ;
49799: GO 49783
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49801: LD_ADDR_VAR 0 5
49805: PUSH
49806: LD_EXP 102
49810: PUSH
49811: LD_VAR 0 2
49815: ARRAY
49816: PPUSH
49817: LD_INT 30
49819: PUSH
49820: LD_INT 3
49822: PUSH
49823: EMPTY
49824: LIST
49825: LIST
49826: PPUSH
49827: CALL_OW 72
49831: ST_TO_ADDR
// if not fac then
49832: LD_VAR 0 5
49836: NOT
49837: IFFALSE 49841
// continue ;
49839: GO 49783
// for j in fac do
49841: LD_ADDR_VAR 0 3
49845: PUSH
49846: LD_VAR 0 5
49850: PUSH
49851: FOR_IN
49852: IFFALSE 50207
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49854: LD_VAR 0 3
49858: PPUSH
49859: CALL_OW 461
49863: PUSH
49864: LD_INT 2
49866: NONEQUAL
49867: PUSH
49868: LD_VAR 0 3
49872: PPUSH
49873: LD_INT 15
49875: PPUSH
49876: CALL 74571 0 2
49880: PUSH
49881: LD_INT 4
49883: ARRAY
49884: OR
49885: IFFALSE 49889
// continue ;
49887: GO 49851
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49889: LD_VAR 0 3
49893: PPUSH
49894: LD_EXP 123
49898: PUSH
49899: LD_VAR 0 2
49903: ARRAY
49904: PUSH
49905: LD_INT 1
49907: ARRAY
49908: PUSH
49909: LD_INT 1
49911: ARRAY
49912: PPUSH
49913: LD_EXP 123
49917: PUSH
49918: LD_VAR 0 2
49922: ARRAY
49923: PUSH
49924: LD_INT 1
49926: ARRAY
49927: PUSH
49928: LD_INT 2
49930: ARRAY
49931: PPUSH
49932: LD_EXP 123
49936: PUSH
49937: LD_VAR 0 2
49941: ARRAY
49942: PUSH
49943: LD_INT 1
49945: ARRAY
49946: PUSH
49947: LD_INT 3
49949: ARRAY
49950: PPUSH
49951: LD_EXP 123
49955: PUSH
49956: LD_VAR 0 2
49960: ARRAY
49961: PUSH
49962: LD_INT 1
49964: ARRAY
49965: PUSH
49966: LD_INT 4
49968: ARRAY
49969: PPUSH
49970: CALL_OW 448
49974: PUSH
49975: LD_VAR 0 3
49979: PPUSH
49980: LD_EXP 123
49984: PUSH
49985: LD_VAR 0 2
49989: ARRAY
49990: PUSH
49991: LD_INT 1
49993: ARRAY
49994: PUSH
49995: LD_INT 1
49997: ARRAY
49998: PUSH
49999: LD_EXP 123
50003: PUSH
50004: LD_VAR 0 2
50008: ARRAY
50009: PUSH
50010: LD_INT 1
50012: ARRAY
50013: PUSH
50014: LD_INT 2
50016: ARRAY
50017: PUSH
50018: LD_EXP 123
50022: PUSH
50023: LD_VAR 0 2
50027: ARRAY
50028: PUSH
50029: LD_INT 1
50031: ARRAY
50032: PUSH
50033: LD_INT 3
50035: ARRAY
50036: PUSH
50037: LD_EXP 123
50041: PUSH
50042: LD_VAR 0 2
50046: ARRAY
50047: PUSH
50048: LD_INT 1
50050: ARRAY
50051: PUSH
50052: LD_INT 4
50054: ARRAY
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: LIST
50060: LIST
50061: PPUSH
50062: CALL 78242 0 2
50066: AND
50067: IFFALSE 50205
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50069: LD_VAR 0 3
50073: PPUSH
50074: LD_EXP 123
50078: PUSH
50079: LD_VAR 0 2
50083: ARRAY
50084: PUSH
50085: LD_INT 1
50087: ARRAY
50088: PUSH
50089: LD_INT 1
50091: ARRAY
50092: PPUSH
50093: LD_EXP 123
50097: PUSH
50098: LD_VAR 0 2
50102: ARRAY
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PUSH
50108: LD_INT 2
50110: ARRAY
50111: PPUSH
50112: LD_EXP 123
50116: PUSH
50117: LD_VAR 0 2
50121: ARRAY
50122: PUSH
50123: LD_INT 1
50125: ARRAY
50126: PUSH
50127: LD_INT 3
50129: ARRAY
50130: PPUSH
50131: LD_EXP 123
50135: PUSH
50136: LD_VAR 0 2
50140: ARRAY
50141: PUSH
50142: LD_INT 1
50144: ARRAY
50145: PUSH
50146: LD_INT 4
50148: ARRAY
50149: PPUSH
50150: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50154: LD_ADDR_VAR 0 4
50158: PUSH
50159: LD_EXP 123
50163: PUSH
50164: LD_VAR 0 2
50168: ARRAY
50169: PPUSH
50170: LD_INT 1
50172: PPUSH
50173: CALL_OW 3
50177: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50178: LD_ADDR_EXP 123
50182: PUSH
50183: LD_EXP 123
50187: PPUSH
50188: LD_VAR 0 2
50192: PPUSH
50193: LD_VAR 0 4
50197: PPUSH
50198: CALL_OW 1
50202: ST_TO_ADDR
// break ;
50203: GO 50207
// end ; end ;
50205: GO 49851
50207: POP
50208: POP
// end ;
50209: GO 49783
50211: POP
50212: POP
// end ;
50213: LD_VAR 0 1
50217: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50218: LD_INT 0
50220: PPUSH
50221: PPUSH
50222: PPUSH
// if not mc_bases then
50223: LD_EXP 102
50227: NOT
50228: IFFALSE 50232
// exit ;
50230: GO 50321
// for i = 1 to mc_bases do
50232: LD_ADDR_VAR 0 2
50236: PUSH
50237: DOUBLE
50238: LD_INT 1
50240: DEC
50241: ST_TO_ADDR
50242: LD_EXP 102
50246: PUSH
50247: FOR_TO
50248: IFFALSE 50319
// begin if mc_attack [ i ] then
50250: LD_EXP 122
50254: PUSH
50255: LD_VAR 0 2
50259: ARRAY
50260: IFFALSE 50317
// begin tmp := mc_attack [ i ] [ 1 ] ;
50262: LD_ADDR_VAR 0 3
50266: PUSH
50267: LD_EXP 122
50271: PUSH
50272: LD_VAR 0 2
50276: ARRAY
50277: PUSH
50278: LD_INT 1
50280: ARRAY
50281: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50282: LD_ADDR_EXP 122
50286: PUSH
50287: LD_EXP 122
50291: PPUSH
50292: LD_VAR 0 2
50296: PPUSH
50297: EMPTY
50298: PPUSH
50299: CALL_OW 1
50303: ST_TO_ADDR
// Attack ( tmp ) ;
50304: LD_VAR 0 3
50308: PPUSH
50309: CALL 100432 0 1
// exit ;
50313: POP
50314: POP
50315: GO 50321
// end ; end ;
50317: GO 50247
50319: POP
50320: POP
// end ;
50321: LD_VAR 0 1
50325: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50326: LD_INT 0
50328: PPUSH
50329: PPUSH
50330: PPUSH
50331: PPUSH
50332: PPUSH
50333: PPUSH
50334: PPUSH
// if not mc_bases then
50335: LD_EXP 102
50339: NOT
50340: IFFALSE 50344
// exit ;
50342: GO 50926
// for i = 1 to mc_bases do
50344: LD_ADDR_VAR 0 2
50348: PUSH
50349: DOUBLE
50350: LD_INT 1
50352: DEC
50353: ST_TO_ADDR
50354: LD_EXP 102
50358: PUSH
50359: FOR_TO
50360: IFFALSE 50924
// begin if not mc_bases [ i ] then
50362: LD_EXP 102
50366: PUSH
50367: LD_VAR 0 2
50371: ARRAY
50372: NOT
50373: IFFALSE 50377
// continue ;
50375: GO 50359
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50377: LD_ADDR_VAR 0 7
50381: PUSH
50382: LD_EXP 102
50386: PUSH
50387: LD_VAR 0 2
50391: ARRAY
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PPUSH
50397: CALL 68814 0 1
50401: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50402: LD_ADDR_EXP 125
50406: PUSH
50407: LD_EXP 125
50411: PPUSH
50412: LD_VAR 0 2
50416: PPUSH
50417: LD_EXP 102
50421: PUSH
50422: LD_VAR 0 2
50426: ARRAY
50427: PUSH
50428: LD_INT 1
50430: ARRAY
50431: PPUSH
50432: CALL_OW 255
50436: PPUSH
50437: LD_EXP 127
50441: PUSH
50442: LD_VAR 0 2
50446: ARRAY
50447: PPUSH
50448: CALL 66368 0 2
50452: PPUSH
50453: CALL_OW 1
50457: ST_TO_ADDR
// if not mc_scan [ i ] then
50458: LD_EXP 125
50462: PUSH
50463: LD_VAR 0 2
50467: ARRAY
50468: NOT
50469: IFFALSE 50624
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50471: LD_ADDR_VAR 0 4
50475: PUSH
50476: LD_EXP 102
50480: PUSH
50481: LD_VAR 0 2
50485: ARRAY
50486: PPUSH
50487: LD_INT 2
50489: PUSH
50490: LD_INT 25
50492: PUSH
50493: LD_INT 5
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: PUSH
50500: LD_INT 25
50502: PUSH
50503: LD_INT 8
50505: PUSH
50506: EMPTY
50507: LIST
50508: LIST
50509: PUSH
50510: LD_INT 25
50512: PUSH
50513: LD_INT 9
50515: PUSH
50516: EMPTY
50517: LIST
50518: LIST
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: LIST
50524: LIST
50525: PPUSH
50526: CALL_OW 72
50530: ST_TO_ADDR
// if not tmp then
50531: LD_VAR 0 4
50535: NOT
50536: IFFALSE 50540
// continue ;
50538: GO 50359
// for j in tmp do
50540: LD_ADDR_VAR 0 3
50544: PUSH
50545: LD_VAR 0 4
50549: PUSH
50550: FOR_IN
50551: IFFALSE 50622
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50553: LD_VAR 0 3
50557: PPUSH
50558: CALL_OW 310
50562: PPUSH
50563: CALL_OW 266
50567: PUSH
50568: LD_INT 5
50570: EQUAL
50571: PUSH
50572: LD_VAR 0 3
50576: PPUSH
50577: CALL_OW 257
50581: PUSH
50582: LD_INT 1
50584: EQUAL
50585: AND
50586: PUSH
50587: LD_VAR 0 3
50591: PPUSH
50592: CALL_OW 459
50596: NOT
50597: AND
50598: PUSH
50599: LD_VAR 0 7
50603: AND
50604: IFFALSE 50620
// ComChangeProfession ( j , class ) ;
50606: LD_VAR 0 3
50610: PPUSH
50611: LD_VAR 0 7
50615: PPUSH
50616: CALL_OW 123
50620: GO 50550
50622: POP
50623: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50624: LD_EXP 125
50628: PUSH
50629: LD_VAR 0 2
50633: ARRAY
50634: PUSH
50635: LD_EXP 124
50639: PUSH
50640: LD_VAR 0 2
50644: ARRAY
50645: NOT
50646: AND
50647: PUSH
50648: LD_EXP 102
50652: PUSH
50653: LD_VAR 0 2
50657: ARRAY
50658: PPUSH
50659: LD_INT 30
50661: PUSH
50662: LD_INT 32
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PPUSH
50669: CALL_OW 72
50673: NOT
50674: AND
50675: PUSH
50676: LD_EXP 102
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: PPUSH
50687: LD_INT 2
50689: PUSH
50690: LD_INT 30
50692: PUSH
50693: LD_INT 4
50695: PUSH
50696: EMPTY
50697: LIST
50698: LIST
50699: PUSH
50700: LD_INT 30
50702: PUSH
50703: LD_INT 5
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: PUSH
50710: EMPTY
50711: LIST
50712: LIST
50713: LIST
50714: PPUSH
50715: CALL_OW 72
50719: NOT
50720: AND
50721: IFFALSE 50853
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50723: LD_ADDR_VAR 0 4
50727: PUSH
50728: LD_EXP 102
50732: PUSH
50733: LD_VAR 0 2
50737: ARRAY
50738: PPUSH
50739: LD_INT 2
50741: PUSH
50742: LD_INT 25
50744: PUSH
50745: LD_INT 1
50747: PUSH
50748: EMPTY
50749: LIST
50750: LIST
50751: PUSH
50752: LD_INT 25
50754: PUSH
50755: LD_INT 5
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: PUSH
50762: LD_INT 25
50764: PUSH
50765: LD_INT 8
50767: PUSH
50768: EMPTY
50769: LIST
50770: LIST
50771: PUSH
50772: LD_INT 25
50774: PUSH
50775: LD_INT 9
50777: PUSH
50778: EMPTY
50779: LIST
50780: LIST
50781: PUSH
50782: EMPTY
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: LIST
50788: PPUSH
50789: CALL_OW 72
50793: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50794: LD_ADDR_VAR 0 4
50798: PUSH
50799: LD_VAR 0 4
50803: PUSH
50804: LD_VAR 0 4
50808: PPUSH
50809: LD_INT 18
50811: PPUSH
50812: CALL 105241 0 2
50816: DIFF
50817: ST_TO_ADDR
// if tmp then
50818: LD_VAR 0 4
50822: IFFALSE 50853
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50824: LD_VAR 0 2
50828: PPUSH
50829: LD_VAR 0 4
50833: PPUSH
50834: LD_EXP 127
50838: PUSH
50839: LD_VAR 0 2
50843: ARRAY
50844: PPUSH
50845: CALL 66403 0 3
// exit ;
50849: POP
50850: POP
50851: GO 50926
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50853: LD_EXP 125
50857: PUSH
50858: LD_VAR 0 2
50862: ARRAY
50863: PUSH
50864: LD_EXP 124
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: AND
50875: IFFALSE 50922
// begin tmp := mc_defender [ i ] ;
50877: LD_ADDR_VAR 0 4
50881: PUSH
50882: LD_EXP 124
50886: PUSH
50887: LD_VAR 0 2
50891: ARRAY
50892: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50893: LD_VAR 0 2
50897: PPUSH
50898: LD_VAR 0 4
50902: PPUSH
50903: LD_EXP 125
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: PPUSH
50914: CALL 66964 0 3
// exit ;
50918: POP
50919: POP
50920: GO 50926
// end ; end ;
50922: GO 50359
50924: POP
50925: POP
// end ;
50926: LD_VAR 0 1
50930: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50931: LD_INT 0
50933: PPUSH
50934: PPUSH
50935: PPUSH
50936: PPUSH
50937: PPUSH
50938: PPUSH
50939: PPUSH
50940: PPUSH
50941: PPUSH
50942: PPUSH
50943: PPUSH
// if not mc_bases then
50944: LD_EXP 102
50948: NOT
50949: IFFALSE 50953
// exit ;
50951: GO 52040
// for i = 1 to mc_bases do
50953: LD_ADDR_VAR 0 2
50957: PUSH
50958: DOUBLE
50959: LD_INT 1
50961: DEC
50962: ST_TO_ADDR
50963: LD_EXP 102
50967: PUSH
50968: FOR_TO
50969: IFFALSE 52038
// begin tmp := mc_lab [ i ] ;
50971: LD_ADDR_VAR 0 6
50975: PUSH
50976: LD_EXP 135
50980: PUSH
50981: LD_VAR 0 2
50985: ARRAY
50986: ST_TO_ADDR
// if not tmp then
50987: LD_VAR 0 6
50991: NOT
50992: IFFALSE 50996
// continue ;
50994: GO 50968
// idle_lab := 0 ;
50996: LD_ADDR_VAR 0 11
51000: PUSH
51001: LD_INT 0
51003: ST_TO_ADDR
// for j in tmp do
51004: LD_ADDR_VAR 0 3
51008: PUSH
51009: LD_VAR 0 6
51013: PUSH
51014: FOR_IN
51015: IFFALSE 52034
// begin researching := false ;
51017: LD_ADDR_VAR 0 10
51021: PUSH
51022: LD_INT 0
51024: ST_TO_ADDR
// side := GetSide ( j ) ;
51025: LD_ADDR_VAR 0 4
51029: PUSH
51030: LD_VAR 0 3
51034: PPUSH
51035: CALL_OW 255
51039: ST_TO_ADDR
// if not mc_tech [ side ] then
51040: LD_EXP 129
51044: PUSH
51045: LD_VAR 0 4
51049: ARRAY
51050: NOT
51051: IFFALSE 51055
// continue ;
51053: GO 51014
// if BuildingStatus ( j ) = bs_idle then
51055: LD_VAR 0 3
51059: PPUSH
51060: CALL_OW 461
51064: PUSH
51065: LD_INT 2
51067: EQUAL
51068: IFFALSE 51256
// begin if idle_lab and UnitsInside ( j ) < 6 then
51070: LD_VAR 0 11
51074: PUSH
51075: LD_VAR 0 3
51079: PPUSH
51080: CALL_OW 313
51084: PUSH
51085: LD_INT 6
51087: LESS
51088: AND
51089: IFFALSE 51160
// begin tmp2 := UnitsInside ( idle_lab ) ;
51091: LD_ADDR_VAR 0 9
51095: PUSH
51096: LD_VAR 0 11
51100: PPUSH
51101: CALL_OW 313
51105: ST_TO_ADDR
// if tmp2 then
51106: LD_VAR 0 9
51110: IFFALSE 51152
// for x in tmp2 do
51112: LD_ADDR_VAR 0 7
51116: PUSH
51117: LD_VAR 0 9
51121: PUSH
51122: FOR_IN
51123: IFFALSE 51150
// begin ComExitBuilding ( x ) ;
51125: LD_VAR 0 7
51129: PPUSH
51130: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51134: LD_VAR 0 7
51138: PPUSH
51139: LD_VAR 0 3
51143: PPUSH
51144: CALL_OW 180
// end ;
51148: GO 51122
51150: POP
51151: POP
// idle_lab := 0 ;
51152: LD_ADDR_VAR 0 11
51156: PUSH
51157: LD_INT 0
51159: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51160: LD_ADDR_VAR 0 5
51164: PUSH
51165: LD_EXP 129
51169: PUSH
51170: LD_VAR 0 4
51174: ARRAY
51175: PUSH
51176: FOR_IN
51177: IFFALSE 51237
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51179: LD_VAR 0 3
51183: PPUSH
51184: LD_VAR 0 5
51188: PPUSH
51189: CALL_OW 430
51193: PUSH
51194: LD_VAR 0 4
51198: PPUSH
51199: LD_VAR 0 5
51203: PPUSH
51204: CALL 65473 0 2
51208: AND
51209: IFFALSE 51235
// begin researching := true ;
51211: LD_ADDR_VAR 0 10
51215: PUSH
51216: LD_INT 1
51218: ST_TO_ADDR
// ComResearch ( j , t ) ;
51219: LD_VAR 0 3
51223: PPUSH
51224: LD_VAR 0 5
51228: PPUSH
51229: CALL_OW 124
// break ;
51233: GO 51237
// end ;
51235: GO 51176
51237: POP
51238: POP
// if not researching then
51239: LD_VAR 0 10
51243: NOT
51244: IFFALSE 51256
// idle_lab := j ;
51246: LD_ADDR_VAR 0 11
51250: PUSH
51251: LD_VAR 0 3
51255: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51256: LD_VAR 0 3
51260: PPUSH
51261: CALL_OW 461
51265: PUSH
51266: LD_INT 10
51268: EQUAL
51269: IFFALSE 51857
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51271: LD_EXP 131
51275: PUSH
51276: LD_VAR 0 2
51280: ARRAY
51281: NOT
51282: PUSH
51283: LD_EXP 132
51287: PUSH
51288: LD_VAR 0 2
51292: ARRAY
51293: NOT
51294: AND
51295: PUSH
51296: LD_EXP 129
51300: PUSH
51301: LD_VAR 0 4
51305: ARRAY
51306: PUSH
51307: LD_INT 1
51309: GREATER
51310: AND
51311: IFFALSE 51442
// begin ComCancel ( j ) ;
51313: LD_VAR 0 3
51317: PPUSH
51318: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51322: LD_ADDR_EXP 129
51326: PUSH
51327: LD_EXP 129
51331: PPUSH
51332: LD_VAR 0 4
51336: PPUSH
51337: LD_EXP 129
51341: PUSH
51342: LD_VAR 0 4
51346: ARRAY
51347: PPUSH
51348: LD_EXP 129
51352: PUSH
51353: LD_VAR 0 4
51357: ARRAY
51358: PUSH
51359: LD_INT 1
51361: MINUS
51362: PPUSH
51363: LD_EXP 129
51367: PUSH
51368: LD_VAR 0 4
51372: ARRAY
51373: PPUSH
51374: LD_INT 0
51376: PPUSH
51377: CALL 71396 0 4
51381: PPUSH
51382: CALL_OW 1
51386: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51387: LD_ADDR_EXP 129
51391: PUSH
51392: LD_EXP 129
51396: PPUSH
51397: LD_VAR 0 4
51401: PPUSH
51402: LD_EXP 129
51406: PUSH
51407: LD_VAR 0 4
51411: ARRAY
51412: PPUSH
51413: LD_EXP 129
51417: PUSH
51418: LD_VAR 0 4
51422: ARRAY
51423: PPUSH
51424: LD_INT 1
51426: PPUSH
51427: LD_INT 0
51429: PPUSH
51430: CALL 71396 0 4
51434: PPUSH
51435: CALL_OW 1
51439: ST_TO_ADDR
// continue ;
51440: GO 51014
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51442: LD_EXP 131
51446: PUSH
51447: LD_VAR 0 2
51451: ARRAY
51452: PUSH
51453: LD_EXP 132
51457: PUSH
51458: LD_VAR 0 2
51462: ARRAY
51463: NOT
51464: AND
51465: IFFALSE 51592
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51467: LD_ADDR_EXP 132
51471: PUSH
51472: LD_EXP 132
51476: PPUSH
51477: LD_VAR 0 2
51481: PUSH
51482: LD_EXP 132
51486: PUSH
51487: LD_VAR 0 2
51491: ARRAY
51492: PUSH
51493: LD_INT 1
51495: PLUS
51496: PUSH
51497: EMPTY
51498: LIST
51499: LIST
51500: PPUSH
51501: LD_EXP 131
51505: PUSH
51506: LD_VAR 0 2
51510: ARRAY
51511: PUSH
51512: LD_INT 1
51514: ARRAY
51515: PPUSH
51516: CALL 71978 0 3
51520: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51521: LD_EXP 131
51525: PUSH
51526: LD_VAR 0 2
51530: ARRAY
51531: PUSH
51532: LD_INT 1
51534: ARRAY
51535: PPUSH
51536: LD_INT 112
51538: PPUSH
51539: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51543: LD_ADDR_VAR 0 9
51547: PUSH
51548: LD_EXP 131
51552: PUSH
51553: LD_VAR 0 2
51557: ARRAY
51558: PPUSH
51559: LD_INT 1
51561: PPUSH
51562: CALL_OW 3
51566: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51567: LD_ADDR_EXP 131
51571: PUSH
51572: LD_EXP 131
51576: PPUSH
51577: LD_VAR 0 2
51581: PPUSH
51582: LD_VAR 0 9
51586: PPUSH
51587: CALL_OW 1
51591: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51592: LD_EXP 131
51596: PUSH
51597: LD_VAR 0 2
51601: ARRAY
51602: PUSH
51603: LD_EXP 132
51607: PUSH
51608: LD_VAR 0 2
51612: ARRAY
51613: AND
51614: PUSH
51615: LD_EXP 132
51619: PUSH
51620: LD_VAR 0 2
51624: ARRAY
51625: PUSH
51626: LD_INT 1
51628: ARRAY
51629: PPUSH
51630: CALL_OW 310
51634: NOT
51635: AND
51636: PUSH
51637: LD_VAR 0 3
51641: PPUSH
51642: CALL_OW 313
51646: PUSH
51647: LD_INT 6
51649: EQUAL
51650: AND
51651: IFFALSE 51707
// begin tmp2 := UnitsInside ( j ) ;
51653: LD_ADDR_VAR 0 9
51657: PUSH
51658: LD_VAR 0 3
51662: PPUSH
51663: CALL_OW 313
51667: ST_TO_ADDR
// if tmp2 = 6 then
51668: LD_VAR 0 9
51672: PUSH
51673: LD_INT 6
51675: EQUAL
51676: IFFALSE 51707
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51678: LD_VAR 0 9
51682: PUSH
51683: LD_INT 1
51685: ARRAY
51686: PPUSH
51687: LD_INT 112
51689: PPUSH
51690: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51694: LD_VAR 0 9
51698: PUSH
51699: LD_INT 1
51701: ARRAY
51702: PPUSH
51703: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51707: LD_EXP 132
51711: PUSH
51712: LD_VAR 0 2
51716: ARRAY
51717: PUSH
51718: LD_EXP 132
51722: PUSH
51723: LD_VAR 0 2
51727: ARRAY
51728: PUSH
51729: LD_INT 1
51731: ARRAY
51732: PPUSH
51733: CALL_OW 314
51737: NOT
51738: AND
51739: PUSH
51740: LD_EXP 132
51744: PUSH
51745: LD_VAR 0 2
51749: ARRAY
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL_OW 310
51759: NOT
51760: AND
51761: IFFALSE 51787
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51763: LD_EXP 132
51767: PUSH
51768: LD_VAR 0 2
51772: ARRAY
51773: PUSH
51774: LD_INT 1
51776: ARRAY
51777: PPUSH
51778: LD_VAR 0 3
51782: PPUSH
51783: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51787: LD_EXP 132
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PUSH
51798: LD_INT 1
51800: ARRAY
51801: PPUSH
51802: CALL_OW 310
51806: PUSH
51807: LD_EXP 132
51811: PUSH
51812: LD_VAR 0 2
51816: ARRAY
51817: PUSH
51818: LD_INT 1
51820: ARRAY
51821: PPUSH
51822: CALL_OW 310
51826: PPUSH
51827: CALL_OW 461
51831: PUSH
51832: LD_INT 3
51834: NONEQUAL
51835: AND
51836: IFFALSE 51857
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51838: LD_EXP 132
51842: PUSH
51843: LD_VAR 0 2
51847: ARRAY
51848: PUSH
51849: LD_INT 1
51851: ARRAY
51852: PPUSH
51853: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51857: LD_VAR 0 3
51861: PPUSH
51862: CALL_OW 461
51866: PUSH
51867: LD_INT 6
51869: EQUAL
51870: PUSH
51871: LD_VAR 0 6
51875: PUSH
51876: LD_INT 1
51878: GREATER
51879: AND
51880: IFFALSE 52032
// begin sci := [ ] ;
51882: LD_ADDR_VAR 0 8
51886: PUSH
51887: EMPTY
51888: ST_TO_ADDR
// for x in ( tmp diff j ) do
51889: LD_ADDR_VAR 0 7
51893: PUSH
51894: LD_VAR 0 6
51898: PUSH
51899: LD_VAR 0 3
51903: DIFF
51904: PUSH
51905: FOR_IN
51906: IFFALSE 51958
// begin if sci = 6 then
51908: LD_VAR 0 8
51912: PUSH
51913: LD_INT 6
51915: EQUAL
51916: IFFALSE 51920
// break ;
51918: GO 51958
// if BuildingStatus ( x ) = bs_idle then
51920: LD_VAR 0 7
51924: PPUSH
51925: CALL_OW 461
51929: PUSH
51930: LD_INT 2
51932: EQUAL
51933: IFFALSE 51956
// sci := sci ^ UnitsInside ( x ) ;
51935: LD_ADDR_VAR 0 8
51939: PUSH
51940: LD_VAR 0 8
51944: PUSH
51945: LD_VAR 0 7
51949: PPUSH
51950: CALL_OW 313
51954: ADD
51955: ST_TO_ADDR
// end ;
51956: GO 51905
51958: POP
51959: POP
// if not sci then
51960: LD_VAR 0 8
51964: NOT
51965: IFFALSE 51969
// continue ;
51967: GO 51014
// for x in sci do
51969: LD_ADDR_VAR 0 7
51973: PUSH
51974: LD_VAR 0 8
51978: PUSH
51979: FOR_IN
51980: IFFALSE 52030
// if IsInUnit ( x ) and not HasTask ( x ) then
51982: LD_VAR 0 7
51986: PPUSH
51987: CALL_OW 310
51991: PUSH
51992: LD_VAR 0 7
51996: PPUSH
51997: CALL_OW 314
52001: NOT
52002: AND
52003: IFFALSE 52028
// begin ComExitBuilding ( x ) ;
52005: LD_VAR 0 7
52009: PPUSH
52010: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52014: LD_VAR 0 7
52018: PPUSH
52019: LD_VAR 0 3
52023: PPUSH
52024: CALL_OW 180
// end ;
52028: GO 51979
52030: POP
52031: POP
// end ; end ;
52032: GO 51014
52034: POP
52035: POP
// end ;
52036: GO 50968
52038: POP
52039: POP
// end ;
52040: LD_VAR 0 1
52044: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52045: LD_INT 0
52047: PPUSH
52048: PPUSH
// if not mc_bases then
52049: LD_EXP 102
52053: NOT
52054: IFFALSE 52058
// exit ;
52056: GO 52139
// for i = 1 to mc_bases do
52058: LD_ADDR_VAR 0 2
52062: PUSH
52063: DOUBLE
52064: LD_INT 1
52066: DEC
52067: ST_TO_ADDR
52068: LD_EXP 102
52072: PUSH
52073: FOR_TO
52074: IFFALSE 52137
// if mc_mines [ i ] and mc_miners [ i ] then
52076: LD_EXP 115
52080: PUSH
52081: LD_VAR 0 2
52085: ARRAY
52086: PUSH
52087: LD_EXP 116
52091: PUSH
52092: LD_VAR 0 2
52096: ARRAY
52097: AND
52098: IFFALSE 52135
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52100: LD_EXP 116
52104: PUSH
52105: LD_VAR 0 2
52109: ARRAY
52110: PUSH
52111: LD_INT 1
52113: ARRAY
52114: PPUSH
52115: CALL_OW 255
52119: PPUSH
52120: LD_EXP 115
52124: PUSH
52125: LD_VAR 0 2
52129: ARRAY
52130: PPUSH
52131: CALL 68967 0 2
52135: GO 52073
52137: POP
52138: POP
// end ;
52139: LD_VAR 0 1
52143: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52144: LD_INT 0
52146: PPUSH
52147: PPUSH
52148: PPUSH
52149: PPUSH
52150: PPUSH
52151: PPUSH
52152: PPUSH
52153: PPUSH
// if not mc_bases or not mc_parking then
52154: LD_EXP 102
52158: NOT
52159: PUSH
52160: LD_EXP 126
52164: NOT
52165: OR
52166: IFFALSE 52170
// exit ;
52168: GO 52869
// for i = 1 to mc_bases do
52170: LD_ADDR_VAR 0 2
52174: PUSH
52175: DOUBLE
52176: LD_INT 1
52178: DEC
52179: ST_TO_ADDR
52180: LD_EXP 102
52184: PUSH
52185: FOR_TO
52186: IFFALSE 52867
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52188: LD_EXP 102
52192: PUSH
52193: LD_VAR 0 2
52197: ARRAY
52198: NOT
52199: PUSH
52200: LD_EXP 126
52204: PUSH
52205: LD_VAR 0 2
52209: ARRAY
52210: NOT
52211: OR
52212: IFFALSE 52216
// continue ;
52214: GO 52185
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52216: LD_ADDR_VAR 0 5
52220: PUSH
52221: LD_EXP 102
52225: PUSH
52226: LD_VAR 0 2
52230: ARRAY
52231: PUSH
52232: LD_INT 1
52234: ARRAY
52235: PPUSH
52236: CALL_OW 255
52240: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52241: LD_ADDR_VAR 0 6
52245: PUSH
52246: LD_EXP 102
52250: PUSH
52251: LD_VAR 0 2
52255: ARRAY
52256: PPUSH
52257: LD_INT 30
52259: PUSH
52260: LD_INT 3
52262: PUSH
52263: EMPTY
52264: LIST
52265: LIST
52266: PPUSH
52267: CALL_OW 72
52271: ST_TO_ADDR
// if not fac then
52272: LD_VAR 0 6
52276: NOT
52277: IFFALSE 52328
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52279: LD_ADDR_VAR 0 6
52283: PUSH
52284: LD_EXP 102
52288: PUSH
52289: LD_VAR 0 2
52293: ARRAY
52294: PPUSH
52295: LD_INT 2
52297: PUSH
52298: LD_INT 30
52300: PUSH
52301: LD_INT 0
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: PUSH
52308: LD_INT 30
52310: PUSH
52311: LD_INT 1
52313: PUSH
52314: EMPTY
52315: LIST
52316: LIST
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: LIST
52322: PPUSH
52323: CALL_OW 72
52327: ST_TO_ADDR
// if not fac then
52328: LD_VAR 0 6
52332: NOT
52333: IFFALSE 52337
// continue ;
52335: GO 52185
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52337: LD_ADDR_VAR 0 7
52341: PUSH
52342: LD_EXP 126
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: PPUSH
52353: LD_INT 22
52355: PUSH
52356: LD_VAR 0 5
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PUSH
52365: LD_INT 21
52367: PUSH
52368: LD_INT 2
52370: PUSH
52371: EMPTY
52372: LIST
52373: LIST
52374: PUSH
52375: LD_INT 3
52377: PUSH
52378: LD_INT 24
52380: PUSH
52381: LD_INT 1000
52383: PUSH
52384: EMPTY
52385: LIST
52386: LIST
52387: PUSH
52388: EMPTY
52389: LIST
52390: LIST
52391: PUSH
52392: EMPTY
52393: LIST
52394: LIST
52395: LIST
52396: PPUSH
52397: CALL_OW 70
52401: ST_TO_ADDR
// for j in fac do
52402: LD_ADDR_VAR 0 3
52406: PUSH
52407: LD_VAR 0 6
52411: PUSH
52412: FOR_IN
52413: IFFALSE 52494
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52415: LD_ADDR_VAR 0 7
52419: PUSH
52420: LD_VAR 0 7
52424: PUSH
52425: LD_INT 22
52427: PUSH
52428: LD_VAR 0 5
52432: PUSH
52433: EMPTY
52434: LIST
52435: LIST
52436: PUSH
52437: LD_INT 91
52439: PUSH
52440: LD_VAR 0 3
52444: PUSH
52445: LD_INT 15
52447: PUSH
52448: EMPTY
52449: LIST
52450: LIST
52451: LIST
52452: PUSH
52453: LD_INT 21
52455: PUSH
52456: LD_INT 2
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: PUSH
52463: LD_INT 3
52465: PUSH
52466: LD_INT 24
52468: PUSH
52469: LD_INT 1000
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: PUSH
52476: EMPTY
52477: LIST
52478: LIST
52479: PUSH
52480: EMPTY
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: PPUSH
52486: CALL_OW 69
52490: UNION
52491: ST_TO_ADDR
52492: GO 52412
52494: POP
52495: POP
// if not vehs then
52496: LD_VAR 0 7
52500: NOT
52501: IFFALSE 52527
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52503: LD_ADDR_EXP 114
52507: PUSH
52508: LD_EXP 114
52512: PPUSH
52513: LD_VAR 0 2
52517: PPUSH
52518: EMPTY
52519: PPUSH
52520: CALL_OW 1
52524: ST_TO_ADDR
// continue ;
52525: GO 52185
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52527: LD_ADDR_VAR 0 8
52531: PUSH
52532: LD_EXP 102
52536: PUSH
52537: LD_VAR 0 2
52541: ARRAY
52542: PPUSH
52543: LD_INT 30
52545: PUSH
52546: LD_INT 3
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: PPUSH
52553: CALL_OW 72
52557: ST_TO_ADDR
// if tmp then
52558: LD_VAR 0 8
52562: IFFALSE 52665
// begin for j in tmp do
52564: LD_ADDR_VAR 0 3
52568: PUSH
52569: LD_VAR 0 8
52573: PUSH
52574: FOR_IN
52575: IFFALSE 52663
// for k in UnitsInside ( j ) do
52577: LD_ADDR_VAR 0 4
52581: PUSH
52582: LD_VAR 0 3
52586: PPUSH
52587: CALL_OW 313
52591: PUSH
52592: FOR_IN
52593: IFFALSE 52659
// if k then
52595: LD_VAR 0 4
52599: IFFALSE 52657
// if not k in mc_repair_vehicle [ i ] then
52601: LD_VAR 0 4
52605: PUSH
52606: LD_EXP 114
52610: PUSH
52611: LD_VAR 0 2
52615: ARRAY
52616: IN
52617: NOT
52618: IFFALSE 52657
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52620: LD_ADDR_EXP 114
52624: PUSH
52625: LD_EXP 114
52629: PPUSH
52630: LD_VAR 0 2
52634: PPUSH
52635: LD_EXP 114
52639: PUSH
52640: LD_VAR 0 2
52644: ARRAY
52645: PUSH
52646: LD_VAR 0 4
52650: UNION
52651: PPUSH
52652: CALL_OW 1
52656: ST_TO_ADDR
52657: GO 52592
52659: POP
52660: POP
52661: GO 52574
52663: POP
52664: POP
// end ; if not mc_repair_vehicle [ i ] then
52665: LD_EXP 114
52669: PUSH
52670: LD_VAR 0 2
52674: ARRAY
52675: NOT
52676: IFFALSE 52680
// continue ;
52678: GO 52185
// for j in mc_repair_vehicle [ i ] do
52680: LD_ADDR_VAR 0 3
52684: PUSH
52685: LD_EXP 114
52689: PUSH
52690: LD_VAR 0 2
52694: ARRAY
52695: PUSH
52696: FOR_IN
52697: IFFALSE 52863
// begin if GetClass ( j ) <> 3 then
52699: LD_VAR 0 3
52703: PPUSH
52704: CALL_OW 257
52708: PUSH
52709: LD_INT 3
52711: NONEQUAL
52712: IFFALSE 52753
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52714: LD_ADDR_EXP 114
52718: PUSH
52719: LD_EXP 114
52723: PPUSH
52724: LD_VAR 0 2
52728: PPUSH
52729: LD_EXP 114
52733: PUSH
52734: LD_VAR 0 2
52738: ARRAY
52739: PUSH
52740: LD_VAR 0 3
52744: DIFF
52745: PPUSH
52746: CALL_OW 1
52750: ST_TO_ADDR
// continue ;
52751: GO 52696
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52753: LD_VAR 0 3
52757: PPUSH
52758: CALL_OW 311
52762: NOT
52763: PUSH
52764: LD_VAR 0 3
52768: PUSH
52769: LD_EXP 105
52773: PUSH
52774: LD_VAR 0 2
52778: ARRAY
52779: PUSH
52780: LD_INT 1
52782: ARRAY
52783: IN
52784: NOT
52785: AND
52786: PUSH
52787: LD_VAR 0 3
52791: PUSH
52792: LD_EXP 105
52796: PUSH
52797: LD_VAR 0 2
52801: ARRAY
52802: PUSH
52803: LD_INT 2
52805: ARRAY
52806: IN
52807: NOT
52808: AND
52809: IFFALSE 52861
// begin if IsInUnit ( j ) then
52811: LD_VAR 0 3
52815: PPUSH
52816: CALL_OW 310
52820: IFFALSE 52831
// ComExitBuilding ( j ) ;
52822: LD_VAR 0 3
52826: PPUSH
52827: CALL_OW 122
// if not HasTask ( j ) then
52831: LD_VAR 0 3
52835: PPUSH
52836: CALL_OW 314
52840: NOT
52841: IFFALSE 52861
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52843: LD_VAR 0 3
52847: PPUSH
52848: LD_VAR 0 7
52852: PUSH
52853: LD_INT 1
52855: ARRAY
52856: PPUSH
52857: CALL_OW 189
// end ; end ;
52861: GO 52696
52863: POP
52864: POP
// end ;
52865: GO 52185
52867: POP
52868: POP
// end ;
52869: LD_VAR 0 1
52873: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52874: LD_INT 0
52876: PPUSH
52877: PPUSH
52878: PPUSH
52879: PPUSH
52880: PPUSH
52881: PPUSH
52882: PPUSH
52883: PPUSH
52884: PPUSH
52885: PPUSH
52886: PPUSH
// if not mc_bases then
52887: LD_EXP 102
52891: NOT
52892: IFFALSE 52896
// exit ;
52894: GO 53698
// for i = 1 to mc_bases do
52896: LD_ADDR_VAR 0 2
52900: PUSH
52901: DOUBLE
52902: LD_INT 1
52904: DEC
52905: ST_TO_ADDR
52906: LD_EXP 102
52910: PUSH
52911: FOR_TO
52912: IFFALSE 53696
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52914: LD_EXP 130
52918: PUSH
52919: LD_VAR 0 2
52923: ARRAY
52924: NOT
52925: PUSH
52926: LD_EXP 105
52930: PUSH
52931: LD_VAR 0 2
52935: ARRAY
52936: PUSH
52937: LD_INT 1
52939: ARRAY
52940: OR
52941: PUSH
52942: LD_EXP 105
52946: PUSH
52947: LD_VAR 0 2
52951: ARRAY
52952: PUSH
52953: LD_INT 2
52955: ARRAY
52956: OR
52957: PUSH
52958: LD_EXP 128
52962: PUSH
52963: LD_VAR 0 2
52967: ARRAY
52968: PPUSH
52969: LD_INT 1
52971: PPUSH
52972: CALL_OW 325
52976: NOT
52977: OR
52978: PUSH
52979: LD_EXP 125
52983: PUSH
52984: LD_VAR 0 2
52988: ARRAY
52989: OR
52990: IFFALSE 52994
// continue ;
52992: GO 52911
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52994: LD_ADDR_VAR 0 8
52998: PUSH
52999: LD_EXP 102
53003: PUSH
53004: LD_VAR 0 2
53008: ARRAY
53009: PPUSH
53010: LD_INT 25
53012: PUSH
53013: LD_INT 4
53015: PUSH
53016: EMPTY
53017: LIST
53018: LIST
53019: PUSH
53020: LD_INT 50
53022: PUSH
53023: EMPTY
53024: LIST
53025: PUSH
53026: LD_INT 3
53028: PUSH
53029: LD_INT 60
53031: PUSH
53032: EMPTY
53033: LIST
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: LIST
53043: PPUSH
53044: CALL_OW 72
53048: PUSH
53049: LD_EXP 106
53053: PUSH
53054: LD_VAR 0 2
53058: ARRAY
53059: DIFF
53060: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53061: LD_ADDR_VAR 0 9
53065: PUSH
53066: LD_EXP 102
53070: PUSH
53071: LD_VAR 0 2
53075: ARRAY
53076: PPUSH
53077: LD_INT 2
53079: PUSH
53080: LD_INT 30
53082: PUSH
53083: LD_INT 0
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: PUSH
53090: LD_INT 30
53092: PUSH
53093: LD_INT 1
53095: PUSH
53096: EMPTY
53097: LIST
53098: LIST
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: LIST
53104: PPUSH
53105: CALL_OW 72
53109: ST_TO_ADDR
// if not tmp or not dep then
53110: LD_VAR 0 8
53114: NOT
53115: PUSH
53116: LD_VAR 0 9
53120: NOT
53121: OR
53122: IFFALSE 53126
// continue ;
53124: GO 52911
// side := GetSide ( tmp [ 1 ] ) ;
53126: LD_ADDR_VAR 0 11
53130: PUSH
53131: LD_VAR 0 8
53135: PUSH
53136: LD_INT 1
53138: ARRAY
53139: PPUSH
53140: CALL_OW 255
53144: ST_TO_ADDR
// dep := dep [ 1 ] ;
53145: LD_ADDR_VAR 0 9
53149: PUSH
53150: LD_VAR 0 9
53154: PUSH
53155: LD_INT 1
53157: ARRAY
53158: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53159: LD_ADDR_VAR 0 7
53163: PUSH
53164: LD_EXP 130
53168: PUSH
53169: LD_VAR 0 2
53173: ARRAY
53174: PPUSH
53175: LD_INT 22
53177: PUSH
53178: LD_INT 0
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: PUSH
53185: LD_INT 25
53187: PUSH
53188: LD_INT 12
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PPUSH
53199: CALL_OW 70
53203: PUSH
53204: LD_INT 22
53206: PUSH
53207: LD_INT 0
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: PUSH
53214: LD_INT 25
53216: PUSH
53217: LD_INT 12
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: PUSH
53224: LD_INT 91
53226: PUSH
53227: LD_VAR 0 9
53231: PUSH
53232: LD_INT 20
53234: PUSH
53235: EMPTY
53236: LIST
53237: LIST
53238: LIST
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: LIST
53244: PPUSH
53245: CALL_OW 69
53249: UNION
53250: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53251: LD_ADDR_VAR 0 10
53255: PUSH
53256: LD_EXP 130
53260: PUSH
53261: LD_VAR 0 2
53265: ARRAY
53266: PPUSH
53267: LD_INT 81
53269: PUSH
53270: LD_VAR 0 11
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: PPUSH
53279: CALL_OW 70
53283: ST_TO_ADDR
// if not apes or danger_at_area then
53284: LD_VAR 0 7
53288: NOT
53289: PUSH
53290: LD_VAR 0 10
53294: OR
53295: IFFALSE 53345
// begin if mc_taming [ i ] then
53297: LD_EXP 133
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: IFFALSE 53343
// begin MC_Reset ( i , 121 ) ;
53309: LD_VAR 0 2
53313: PPUSH
53314: LD_INT 121
53316: PPUSH
53317: CALL 38780 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53321: LD_ADDR_EXP 133
53325: PUSH
53326: LD_EXP 133
53330: PPUSH
53331: LD_VAR 0 2
53335: PPUSH
53336: EMPTY
53337: PPUSH
53338: CALL_OW 1
53342: ST_TO_ADDR
// end ; continue ;
53343: GO 52911
// end ; for j in tmp do
53345: LD_ADDR_VAR 0 3
53349: PUSH
53350: LD_VAR 0 8
53354: PUSH
53355: FOR_IN
53356: IFFALSE 53692
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53358: LD_VAR 0 3
53362: PUSH
53363: LD_EXP 133
53367: PUSH
53368: LD_VAR 0 2
53372: ARRAY
53373: IN
53374: NOT
53375: PUSH
53376: LD_EXP 133
53380: PUSH
53381: LD_VAR 0 2
53385: ARRAY
53386: PUSH
53387: LD_INT 3
53389: LESS
53390: AND
53391: IFFALSE 53449
// begin SetTag ( j , 121 ) ;
53393: LD_VAR 0 3
53397: PPUSH
53398: LD_INT 121
53400: PPUSH
53401: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53405: LD_ADDR_EXP 133
53409: PUSH
53410: LD_EXP 133
53414: PPUSH
53415: LD_VAR 0 2
53419: PUSH
53420: LD_EXP 133
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: PUSH
53431: LD_INT 1
53433: PLUS
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: PPUSH
53439: LD_VAR 0 3
53443: PPUSH
53444: CALL 71978 0 3
53448: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53449: LD_VAR 0 3
53453: PUSH
53454: LD_EXP 133
53458: PUSH
53459: LD_VAR 0 2
53463: ARRAY
53464: IN
53465: IFFALSE 53690
// begin if GetClass ( j ) <> 4 then
53467: LD_VAR 0 3
53471: PPUSH
53472: CALL_OW 257
53476: PUSH
53477: LD_INT 4
53479: NONEQUAL
53480: IFFALSE 53533
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53482: LD_ADDR_EXP 133
53486: PUSH
53487: LD_EXP 133
53491: PPUSH
53492: LD_VAR 0 2
53496: PPUSH
53497: LD_EXP 133
53501: PUSH
53502: LD_VAR 0 2
53506: ARRAY
53507: PUSH
53508: LD_VAR 0 3
53512: DIFF
53513: PPUSH
53514: CALL_OW 1
53518: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53519: LD_VAR 0 3
53523: PPUSH
53524: LD_INT 0
53526: PPUSH
53527: CALL_OW 109
// continue ;
53531: GO 53355
// end ; if IsInUnit ( j ) then
53533: LD_VAR 0 3
53537: PPUSH
53538: CALL_OW 310
53542: IFFALSE 53553
// ComExitBuilding ( j ) ;
53544: LD_VAR 0 3
53548: PPUSH
53549: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53553: LD_ADDR_VAR 0 6
53557: PUSH
53558: LD_VAR 0 7
53562: PPUSH
53563: LD_VAR 0 3
53567: PPUSH
53568: CALL_OW 74
53572: ST_TO_ADDR
// if not ape then
53573: LD_VAR 0 6
53577: NOT
53578: IFFALSE 53582
// break ;
53580: GO 53692
// x := GetX ( ape ) ;
53582: LD_ADDR_VAR 0 4
53586: PUSH
53587: LD_VAR 0 6
53591: PPUSH
53592: CALL_OW 250
53596: ST_TO_ADDR
// y := GetY ( ape ) ;
53597: LD_ADDR_VAR 0 5
53601: PUSH
53602: LD_VAR 0 6
53606: PPUSH
53607: CALL_OW 251
53611: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53612: LD_VAR 0 4
53616: PPUSH
53617: LD_VAR 0 5
53621: PPUSH
53622: CALL_OW 488
53626: NOT
53627: PUSH
53628: LD_VAR 0 11
53632: PPUSH
53633: LD_VAR 0 4
53637: PPUSH
53638: LD_VAR 0 5
53642: PPUSH
53643: LD_INT 20
53645: PPUSH
53646: CALL 72874 0 4
53650: PUSH
53651: LD_INT 4
53653: ARRAY
53654: OR
53655: IFFALSE 53659
// break ;
53657: GO 53692
// if not HasTask ( j ) then
53659: LD_VAR 0 3
53663: PPUSH
53664: CALL_OW 314
53668: NOT
53669: IFFALSE 53690
// ComTameXY ( j , x , y ) ;
53671: LD_VAR 0 3
53675: PPUSH
53676: LD_VAR 0 4
53680: PPUSH
53681: LD_VAR 0 5
53685: PPUSH
53686: CALL_OW 131
// end ; end ;
53690: GO 53355
53692: POP
53693: POP
// end ;
53694: GO 52911
53696: POP
53697: POP
// end ;
53698: LD_VAR 0 1
53702: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53703: LD_INT 0
53705: PPUSH
53706: PPUSH
53707: PPUSH
53708: PPUSH
53709: PPUSH
53710: PPUSH
53711: PPUSH
53712: PPUSH
// if not mc_bases then
53713: LD_EXP 102
53717: NOT
53718: IFFALSE 53722
// exit ;
53720: GO 54348
// for i = 1 to mc_bases do
53722: LD_ADDR_VAR 0 2
53726: PUSH
53727: DOUBLE
53728: LD_INT 1
53730: DEC
53731: ST_TO_ADDR
53732: LD_EXP 102
53736: PUSH
53737: FOR_TO
53738: IFFALSE 54346
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53740: LD_EXP 131
53744: PUSH
53745: LD_VAR 0 2
53749: ARRAY
53750: NOT
53751: PUSH
53752: LD_EXP 131
53756: PUSH
53757: LD_VAR 0 2
53761: ARRAY
53762: PPUSH
53763: LD_INT 25
53765: PUSH
53766: LD_INT 12
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: PPUSH
53773: CALL_OW 72
53777: NOT
53778: OR
53779: IFFALSE 53783
// continue ;
53781: GO 53737
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53783: LD_ADDR_VAR 0 5
53787: PUSH
53788: LD_EXP 131
53792: PUSH
53793: LD_VAR 0 2
53797: ARRAY
53798: PUSH
53799: LD_INT 1
53801: ARRAY
53802: PPUSH
53803: CALL_OW 255
53807: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53808: LD_VAR 0 5
53812: PPUSH
53813: LD_INT 2
53815: PPUSH
53816: CALL_OW 325
53820: IFFALSE 54073
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53822: LD_ADDR_VAR 0 4
53826: PUSH
53827: LD_EXP 131
53831: PUSH
53832: LD_VAR 0 2
53836: ARRAY
53837: PPUSH
53838: LD_INT 25
53840: PUSH
53841: LD_INT 16
53843: PUSH
53844: EMPTY
53845: LIST
53846: LIST
53847: PPUSH
53848: CALL_OW 72
53852: ST_TO_ADDR
// if tmp < 6 then
53853: LD_VAR 0 4
53857: PUSH
53858: LD_INT 6
53860: LESS
53861: IFFALSE 54073
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53863: LD_ADDR_VAR 0 6
53867: PUSH
53868: LD_EXP 102
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PPUSH
53879: LD_INT 2
53881: PUSH
53882: LD_INT 30
53884: PUSH
53885: LD_INT 0
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: PUSH
53892: LD_INT 30
53894: PUSH
53895: LD_INT 1
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PUSH
53902: EMPTY
53903: LIST
53904: LIST
53905: LIST
53906: PPUSH
53907: CALL_OW 72
53911: ST_TO_ADDR
// if depot then
53912: LD_VAR 0 6
53916: IFFALSE 54073
// begin selected := 0 ;
53918: LD_ADDR_VAR 0 7
53922: PUSH
53923: LD_INT 0
53925: ST_TO_ADDR
// for j in depot do
53926: LD_ADDR_VAR 0 3
53930: PUSH
53931: LD_VAR 0 6
53935: PUSH
53936: FOR_IN
53937: IFFALSE 53968
// begin if UnitsInside ( j ) < 6 then
53939: LD_VAR 0 3
53943: PPUSH
53944: CALL_OW 313
53948: PUSH
53949: LD_INT 6
53951: LESS
53952: IFFALSE 53966
// begin selected := j ;
53954: LD_ADDR_VAR 0 7
53958: PUSH
53959: LD_VAR 0 3
53963: ST_TO_ADDR
// break ;
53964: GO 53968
// end ; end ;
53966: GO 53936
53968: POP
53969: POP
// if selected then
53970: LD_VAR 0 7
53974: IFFALSE 54073
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53976: LD_ADDR_VAR 0 3
53980: PUSH
53981: LD_EXP 131
53985: PUSH
53986: LD_VAR 0 2
53990: ARRAY
53991: PPUSH
53992: LD_INT 25
53994: PUSH
53995: LD_INT 12
53997: PUSH
53998: EMPTY
53999: LIST
54000: LIST
54001: PPUSH
54002: CALL_OW 72
54006: PUSH
54007: FOR_IN
54008: IFFALSE 54071
// if not HasTask ( j ) then
54010: LD_VAR 0 3
54014: PPUSH
54015: CALL_OW 314
54019: NOT
54020: IFFALSE 54069
// begin if not IsInUnit ( j ) then
54022: LD_VAR 0 3
54026: PPUSH
54027: CALL_OW 310
54031: NOT
54032: IFFALSE 54048
// ComEnterUnit ( j , selected ) ;
54034: LD_VAR 0 3
54038: PPUSH
54039: LD_VAR 0 7
54043: PPUSH
54044: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54048: LD_VAR 0 3
54052: PPUSH
54053: LD_INT 16
54055: PPUSH
54056: CALL_OW 183
// AddComExitBuilding ( j ) ;
54060: LD_VAR 0 3
54064: PPUSH
54065: CALL_OW 182
// end ;
54069: GO 54007
54071: POP
54072: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54073: LD_VAR 0 5
54077: PPUSH
54078: LD_INT 11
54080: PPUSH
54081: CALL_OW 325
54085: IFFALSE 54344
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54087: LD_ADDR_VAR 0 4
54091: PUSH
54092: LD_EXP 131
54096: PUSH
54097: LD_VAR 0 2
54101: ARRAY
54102: PPUSH
54103: LD_INT 25
54105: PUSH
54106: LD_INT 16
54108: PUSH
54109: EMPTY
54110: LIST
54111: LIST
54112: PPUSH
54113: CALL_OW 72
54117: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54118: LD_VAR 0 4
54122: PUSH
54123: LD_INT 6
54125: GREATEREQUAL
54126: PUSH
54127: LD_VAR 0 5
54131: PPUSH
54132: LD_INT 2
54134: PPUSH
54135: CALL_OW 325
54139: NOT
54140: OR
54141: IFFALSE 54344
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54143: LD_ADDR_VAR 0 8
54147: PUSH
54148: LD_EXP 102
54152: PUSH
54153: LD_VAR 0 2
54157: ARRAY
54158: PPUSH
54159: LD_INT 2
54161: PUSH
54162: LD_INT 30
54164: PUSH
54165: LD_INT 4
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: PUSH
54172: LD_INT 30
54174: PUSH
54175: LD_INT 5
54177: PUSH
54178: EMPTY
54179: LIST
54180: LIST
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: LIST
54186: PPUSH
54187: CALL_OW 72
54191: ST_TO_ADDR
// if barracks then
54192: LD_VAR 0 8
54196: IFFALSE 54344
// begin selected := 0 ;
54198: LD_ADDR_VAR 0 7
54202: PUSH
54203: LD_INT 0
54205: ST_TO_ADDR
// for j in barracks do
54206: LD_ADDR_VAR 0 3
54210: PUSH
54211: LD_VAR 0 8
54215: PUSH
54216: FOR_IN
54217: IFFALSE 54248
// begin if UnitsInside ( j ) < 6 then
54219: LD_VAR 0 3
54223: PPUSH
54224: CALL_OW 313
54228: PUSH
54229: LD_INT 6
54231: LESS
54232: IFFALSE 54246
// begin selected := j ;
54234: LD_ADDR_VAR 0 7
54238: PUSH
54239: LD_VAR 0 3
54243: ST_TO_ADDR
// break ;
54244: GO 54248
// end ; end ;
54246: GO 54216
54248: POP
54249: POP
// if selected then
54250: LD_VAR 0 7
54254: IFFALSE 54344
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54256: LD_ADDR_VAR 0 3
54260: PUSH
54261: LD_EXP 131
54265: PUSH
54266: LD_VAR 0 2
54270: ARRAY
54271: PPUSH
54272: LD_INT 25
54274: PUSH
54275: LD_INT 12
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: PPUSH
54282: CALL_OW 72
54286: PUSH
54287: FOR_IN
54288: IFFALSE 54342
// if not IsInUnit ( j ) and not HasTask ( j ) then
54290: LD_VAR 0 3
54294: PPUSH
54295: CALL_OW 310
54299: NOT
54300: PUSH
54301: LD_VAR 0 3
54305: PPUSH
54306: CALL_OW 314
54310: NOT
54311: AND
54312: IFFALSE 54340
// begin ComEnterUnit ( j , selected ) ;
54314: LD_VAR 0 3
54318: PPUSH
54319: LD_VAR 0 7
54323: PPUSH
54324: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54328: LD_VAR 0 3
54332: PPUSH
54333: LD_INT 15
54335: PPUSH
54336: CALL_OW 183
// end ;
54340: GO 54287
54342: POP
54343: POP
// end ; end ; end ; end ; end ;
54344: GO 53737
54346: POP
54347: POP
// end ;
54348: LD_VAR 0 1
54352: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54353: LD_INT 0
54355: PPUSH
54356: PPUSH
54357: PPUSH
54358: PPUSH
// if not mc_bases then
54359: LD_EXP 102
54363: NOT
54364: IFFALSE 54368
// exit ;
54366: GO 54546
// for i = 1 to mc_bases do
54368: LD_ADDR_VAR 0 2
54372: PUSH
54373: DOUBLE
54374: LD_INT 1
54376: DEC
54377: ST_TO_ADDR
54378: LD_EXP 102
54382: PUSH
54383: FOR_TO
54384: IFFALSE 54544
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54386: LD_ADDR_VAR 0 4
54390: PUSH
54391: LD_EXP 102
54395: PUSH
54396: LD_VAR 0 2
54400: ARRAY
54401: PPUSH
54402: LD_INT 25
54404: PUSH
54405: LD_INT 9
54407: PUSH
54408: EMPTY
54409: LIST
54410: LIST
54411: PPUSH
54412: CALL_OW 72
54416: ST_TO_ADDR
// if not tmp then
54417: LD_VAR 0 4
54421: NOT
54422: IFFALSE 54426
// continue ;
54424: GO 54383
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54426: LD_EXP 128
54430: PUSH
54431: LD_VAR 0 2
54435: ARRAY
54436: PPUSH
54437: LD_INT 29
54439: PPUSH
54440: CALL_OW 325
54444: NOT
54445: PUSH
54446: LD_EXP 128
54450: PUSH
54451: LD_VAR 0 2
54455: ARRAY
54456: PPUSH
54457: LD_INT 28
54459: PPUSH
54460: CALL_OW 325
54464: NOT
54465: AND
54466: IFFALSE 54470
// continue ;
54468: GO 54383
// for j in tmp do
54470: LD_ADDR_VAR 0 3
54474: PUSH
54475: LD_VAR 0 4
54479: PUSH
54480: FOR_IN
54481: IFFALSE 54540
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54483: LD_VAR 0 3
54487: PUSH
54488: LD_EXP 105
54492: PUSH
54493: LD_VAR 0 2
54497: ARRAY
54498: PUSH
54499: LD_INT 1
54501: ARRAY
54502: IN
54503: NOT
54504: PUSH
54505: LD_VAR 0 3
54509: PUSH
54510: LD_EXP 105
54514: PUSH
54515: LD_VAR 0 2
54519: ARRAY
54520: PUSH
54521: LD_INT 2
54523: ARRAY
54524: IN
54525: NOT
54526: AND
54527: IFFALSE 54538
// ComSpaceTimeShoot ( j ) ;
54529: LD_VAR 0 3
54533: PPUSH
54534: CALL 65564 0 1
54538: GO 54480
54540: POP
54541: POP
// end ;
54542: GO 54383
54544: POP
54545: POP
// end ;
54546: LD_VAR 0 1
54550: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54551: LD_INT 0
54553: PPUSH
54554: PPUSH
54555: PPUSH
54556: PPUSH
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
54561: PPUSH
// if not mc_bases then
54562: LD_EXP 102
54566: NOT
54567: IFFALSE 54571
// exit ;
54569: GO 55193
// for i = 1 to mc_bases do
54571: LD_ADDR_VAR 0 2
54575: PUSH
54576: DOUBLE
54577: LD_INT 1
54579: DEC
54580: ST_TO_ADDR
54581: LD_EXP 102
54585: PUSH
54586: FOR_TO
54587: IFFALSE 55191
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54589: LD_EXP 137
54593: PUSH
54594: LD_VAR 0 2
54598: ARRAY
54599: NOT
54600: PUSH
54601: LD_INT 38
54603: PPUSH
54604: LD_EXP 128
54608: PUSH
54609: LD_VAR 0 2
54613: ARRAY
54614: PPUSH
54615: CALL_OW 321
54619: PUSH
54620: LD_INT 2
54622: NONEQUAL
54623: OR
54624: IFFALSE 54628
// continue ;
54626: GO 54586
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54628: LD_ADDR_VAR 0 8
54632: PUSH
54633: LD_EXP 102
54637: PUSH
54638: LD_VAR 0 2
54642: ARRAY
54643: PPUSH
54644: LD_INT 30
54646: PUSH
54647: LD_INT 34
54649: PUSH
54650: EMPTY
54651: LIST
54652: LIST
54653: PPUSH
54654: CALL_OW 72
54658: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54659: LD_ADDR_VAR 0 9
54663: PUSH
54664: LD_EXP 102
54668: PUSH
54669: LD_VAR 0 2
54673: ARRAY
54674: PPUSH
54675: LD_INT 25
54677: PUSH
54678: LD_INT 4
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: PPUSH
54685: CALL_OW 72
54689: PPUSH
54690: LD_INT 0
54692: PPUSH
54693: CALL 105241 0 2
54697: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54698: LD_VAR 0 9
54702: NOT
54703: PUSH
54704: LD_VAR 0 8
54708: NOT
54709: OR
54710: PUSH
54711: LD_EXP 102
54715: PUSH
54716: LD_VAR 0 2
54720: ARRAY
54721: PPUSH
54722: LD_INT 124
54724: PPUSH
54725: CALL 105241 0 2
54729: OR
54730: IFFALSE 54734
// continue ;
54732: GO 54586
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54734: LD_EXP 138
54738: PUSH
54739: LD_VAR 0 2
54743: ARRAY
54744: PUSH
54745: LD_EXP 137
54749: PUSH
54750: LD_VAR 0 2
54754: ARRAY
54755: LESS
54756: PUSH
54757: LD_EXP 138
54761: PUSH
54762: LD_VAR 0 2
54766: ARRAY
54767: PUSH
54768: LD_VAR 0 8
54772: LESS
54773: AND
54774: IFFALSE 55189
// begin tmp := sci [ 1 ] ;
54776: LD_ADDR_VAR 0 7
54780: PUSH
54781: LD_VAR 0 9
54785: PUSH
54786: LD_INT 1
54788: ARRAY
54789: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54790: LD_VAR 0 7
54794: PPUSH
54795: LD_INT 124
54797: PPUSH
54798: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54802: LD_ADDR_VAR 0 3
54806: PUSH
54807: DOUBLE
54808: LD_EXP 137
54812: PUSH
54813: LD_VAR 0 2
54817: ARRAY
54818: INC
54819: ST_TO_ADDR
54820: LD_EXP 137
54824: PUSH
54825: LD_VAR 0 2
54829: ARRAY
54830: PUSH
54831: FOR_DOWNTO
54832: IFFALSE 55175
// begin if IsInUnit ( tmp ) then
54834: LD_VAR 0 7
54838: PPUSH
54839: CALL_OW 310
54843: IFFALSE 54854
// ComExitBuilding ( tmp ) ;
54845: LD_VAR 0 7
54849: PPUSH
54850: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54854: LD_INT 35
54856: PPUSH
54857: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54861: LD_VAR 0 7
54865: PPUSH
54866: CALL_OW 310
54870: NOT
54871: PUSH
54872: LD_VAR 0 7
54876: PPUSH
54877: CALL_OW 314
54881: NOT
54882: AND
54883: IFFALSE 54854
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54885: LD_ADDR_VAR 0 6
54889: PUSH
54890: LD_VAR 0 7
54894: PPUSH
54895: CALL_OW 250
54899: PUSH
54900: LD_VAR 0 7
54904: PPUSH
54905: CALL_OW 251
54909: PUSH
54910: EMPTY
54911: LIST
54912: LIST
54913: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54914: LD_INT 35
54916: PPUSH
54917: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54921: LD_ADDR_VAR 0 4
54925: PUSH
54926: LD_EXP 137
54930: PUSH
54931: LD_VAR 0 2
54935: ARRAY
54936: PUSH
54937: LD_VAR 0 3
54941: ARRAY
54942: PUSH
54943: LD_INT 1
54945: ARRAY
54946: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54947: LD_ADDR_VAR 0 5
54951: PUSH
54952: LD_EXP 137
54956: PUSH
54957: LD_VAR 0 2
54961: ARRAY
54962: PUSH
54963: LD_VAR 0 3
54967: ARRAY
54968: PUSH
54969: LD_INT 2
54971: ARRAY
54972: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54973: LD_VAR 0 7
54977: PPUSH
54978: LD_INT 10
54980: PPUSH
54981: CALL 74571 0 2
54985: PUSH
54986: LD_INT 4
54988: ARRAY
54989: IFFALSE 55027
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54991: LD_VAR 0 7
54995: PPUSH
54996: LD_VAR 0 6
55000: PUSH
55001: LD_INT 1
55003: ARRAY
55004: PPUSH
55005: LD_VAR 0 6
55009: PUSH
55010: LD_INT 2
55012: ARRAY
55013: PPUSH
55014: CALL_OW 111
// wait ( 0 0$10 ) ;
55018: LD_INT 350
55020: PPUSH
55021: CALL_OW 67
// end else
55025: GO 55053
// begin ComMoveXY ( tmp , x , y ) ;
55027: LD_VAR 0 7
55031: PPUSH
55032: LD_VAR 0 4
55036: PPUSH
55037: LD_VAR 0 5
55041: PPUSH
55042: CALL_OW 111
// wait ( 0 0$3 ) ;
55046: LD_INT 105
55048: PPUSH
55049: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55053: LD_VAR 0 7
55057: PPUSH
55058: LD_VAR 0 4
55062: PPUSH
55063: LD_VAR 0 5
55067: PPUSH
55068: CALL_OW 307
55072: IFFALSE 54914
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55074: LD_VAR 0 7
55078: PPUSH
55079: LD_VAR 0 4
55083: PPUSH
55084: LD_VAR 0 5
55088: PPUSH
55089: LD_VAR 0 8
55093: PUSH
55094: LD_VAR 0 3
55098: ARRAY
55099: PPUSH
55100: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55104: LD_INT 35
55106: PPUSH
55107: CALL_OW 67
// until not HasTask ( tmp ) ;
55111: LD_VAR 0 7
55115: PPUSH
55116: CALL_OW 314
55120: NOT
55121: IFFALSE 55104
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55123: LD_ADDR_EXP 138
55127: PUSH
55128: LD_EXP 138
55132: PPUSH
55133: LD_VAR 0 2
55137: PUSH
55138: LD_EXP 138
55142: PUSH
55143: LD_VAR 0 2
55147: ARRAY
55148: PUSH
55149: LD_INT 1
55151: PLUS
55152: PUSH
55153: EMPTY
55154: LIST
55155: LIST
55156: PPUSH
55157: LD_VAR 0 8
55161: PUSH
55162: LD_VAR 0 3
55166: ARRAY
55167: PPUSH
55168: CALL 71978 0 3
55172: ST_TO_ADDR
// end ;
55173: GO 54831
55175: POP
55176: POP
// MC_Reset ( i , 124 ) ;
55177: LD_VAR 0 2
55181: PPUSH
55182: LD_INT 124
55184: PPUSH
55185: CALL 38780 0 2
// end ; end ;
55189: GO 54586
55191: POP
55192: POP
// end ;
55193: LD_VAR 0 1
55197: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55198: LD_INT 0
55200: PPUSH
55201: PPUSH
55202: PPUSH
// if not mc_bases then
55203: LD_EXP 102
55207: NOT
55208: IFFALSE 55212
// exit ;
55210: GO 55818
// for i = 1 to mc_bases do
55212: LD_ADDR_VAR 0 2
55216: PUSH
55217: DOUBLE
55218: LD_INT 1
55220: DEC
55221: ST_TO_ADDR
55222: LD_EXP 102
55226: PUSH
55227: FOR_TO
55228: IFFALSE 55816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55230: LD_ADDR_VAR 0 3
55234: PUSH
55235: LD_EXP 102
55239: PUSH
55240: LD_VAR 0 2
55244: ARRAY
55245: PPUSH
55246: LD_INT 25
55248: PUSH
55249: LD_INT 4
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: PPUSH
55256: CALL_OW 72
55260: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55261: LD_VAR 0 3
55265: NOT
55266: PUSH
55267: LD_EXP 139
55271: PUSH
55272: LD_VAR 0 2
55276: ARRAY
55277: NOT
55278: OR
55279: PUSH
55280: LD_EXP 102
55284: PUSH
55285: LD_VAR 0 2
55289: ARRAY
55290: PPUSH
55291: LD_INT 2
55293: PUSH
55294: LD_INT 30
55296: PUSH
55297: LD_INT 0
55299: PUSH
55300: EMPTY
55301: LIST
55302: LIST
55303: PUSH
55304: LD_INT 30
55306: PUSH
55307: LD_INT 1
55309: PUSH
55310: EMPTY
55311: LIST
55312: LIST
55313: PUSH
55314: EMPTY
55315: LIST
55316: LIST
55317: LIST
55318: PPUSH
55319: CALL_OW 72
55323: NOT
55324: OR
55325: IFFALSE 55375
// begin if mc_deposits_finder [ i ] then
55327: LD_EXP 140
55331: PUSH
55332: LD_VAR 0 2
55336: ARRAY
55337: IFFALSE 55373
// begin MC_Reset ( i , 125 ) ;
55339: LD_VAR 0 2
55343: PPUSH
55344: LD_INT 125
55346: PPUSH
55347: CALL 38780 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55351: LD_ADDR_EXP 140
55355: PUSH
55356: LD_EXP 140
55360: PPUSH
55361: LD_VAR 0 2
55365: PPUSH
55366: EMPTY
55367: PPUSH
55368: CALL_OW 1
55372: ST_TO_ADDR
// end ; continue ;
55373: GO 55227
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55375: LD_EXP 139
55379: PUSH
55380: LD_VAR 0 2
55384: ARRAY
55385: PUSH
55386: LD_INT 1
55388: ARRAY
55389: PUSH
55390: LD_INT 3
55392: ARRAY
55393: PUSH
55394: LD_INT 1
55396: EQUAL
55397: PUSH
55398: LD_INT 20
55400: PPUSH
55401: LD_EXP 128
55405: PUSH
55406: LD_VAR 0 2
55410: ARRAY
55411: PPUSH
55412: CALL_OW 321
55416: PUSH
55417: LD_INT 2
55419: NONEQUAL
55420: AND
55421: IFFALSE 55471
// begin if mc_deposits_finder [ i ] then
55423: LD_EXP 140
55427: PUSH
55428: LD_VAR 0 2
55432: ARRAY
55433: IFFALSE 55469
// begin MC_Reset ( i , 125 ) ;
55435: LD_VAR 0 2
55439: PPUSH
55440: LD_INT 125
55442: PPUSH
55443: CALL 38780 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55447: LD_ADDR_EXP 140
55451: PUSH
55452: LD_EXP 140
55456: PPUSH
55457: LD_VAR 0 2
55461: PPUSH
55462: EMPTY
55463: PPUSH
55464: CALL_OW 1
55468: ST_TO_ADDR
// end ; continue ;
55469: GO 55227
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55471: LD_EXP 139
55475: PUSH
55476: LD_VAR 0 2
55480: ARRAY
55481: PUSH
55482: LD_INT 1
55484: ARRAY
55485: PUSH
55486: LD_INT 1
55488: ARRAY
55489: PPUSH
55490: LD_EXP 139
55494: PUSH
55495: LD_VAR 0 2
55499: ARRAY
55500: PUSH
55501: LD_INT 1
55503: ARRAY
55504: PUSH
55505: LD_INT 2
55507: ARRAY
55508: PPUSH
55509: LD_EXP 128
55513: PUSH
55514: LD_VAR 0 2
55518: ARRAY
55519: PPUSH
55520: CALL_OW 440
55524: IFFALSE 55567
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55526: LD_ADDR_EXP 139
55530: PUSH
55531: LD_EXP 139
55535: PPUSH
55536: LD_VAR 0 2
55540: PPUSH
55541: LD_EXP 139
55545: PUSH
55546: LD_VAR 0 2
55550: ARRAY
55551: PPUSH
55552: LD_INT 1
55554: PPUSH
55555: CALL_OW 3
55559: PPUSH
55560: CALL_OW 1
55564: ST_TO_ADDR
55565: GO 55814
// begin if not mc_deposits_finder [ i ] then
55567: LD_EXP 140
55571: PUSH
55572: LD_VAR 0 2
55576: ARRAY
55577: NOT
55578: IFFALSE 55630
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55580: LD_ADDR_EXP 140
55584: PUSH
55585: LD_EXP 140
55589: PPUSH
55590: LD_VAR 0 2
55594: PPUSH
55595: LD_VAR 0 3
55599: PUSH
55600: LD_INT 1
55602: ARRAY
55603: PUSH
55604: EMPTY
55605: LIST
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55612: LD_VAR 0 3
55616: PUSH
55617: LD_INT 1
55619: ARRAY
55620: PPUSH
55621: LD_INT 125
55623: PPUSH
55624: CALL_OW 109
// end else
55628: GO 55814
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55630: LD_EXP 140
55634: PUSH
55635: LD_VAR 0 2
55639: ARRAY
55640: PUSH
55641: LD_INT 1
55643: ARRAY
55644: PPUSH
55645: CALL_OW 310
55649: IFFALSE 55672
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55651: LD_EXP 140
55655: PUSH
55656: LD_VAR 0 2
55660: ARRAY
55661: PUSH
55662: LD_INT 1
55664: ARRAY
55665: PPUSH
55666: CALL_OW 122
55670: GO 55814
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55672: LD_EXP 140
55676: PUSH
55677: LD_VAR 0 2
55681: ARRAY
55682: PUSH
55683: LD_INT 1
55685: ARRAY
55686: PPUSH
55687: CALL_OW 314
55691: NOT
55692: PUSH
55693: LD_EXP 140
55697: PUSH
55698: LD_VAR 0 2
55702: ARRAY
55703: PUSH
55704: LD_INT 1
55706: ARRAY
55707: PPUSH
55708: LD_EXP 139
55712: PUSH
55713: LD_VAR 0 2
55717: ARRAY
55718: PUSH
55719: LD_INT 1
55721: ARRAY
55722: PUSH
55723: LD_INT 1
55725: ARRAY
55726: PPUSH
55727: LD_EXP 139
55731: PUSH
55732: LD_VAR 0 2
55736: ARRAY
55737: PUSH
55738: LD_INT 1
55740: ARRAY
55741: PUSH
55742: LD_INT 2
55744: ARRAY
55745: PPUSH
55746: CALL_OW 297
55750: PUSH
55751: LD_INT 6
55753: GREATER
55754: AND
55755: IFFALSE 55814
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55757: LD_EXP 140
55761: PUSH
55762: LD_VAR 0 2
55766: ARRAY
55767: PUSH
55768: LD_INT 1
55770: ARRAY
55771: PPUSH
55772: LD_EXP 139
55776: PUSH
55777: LD_VAR 0 2
55781: ARRAY
55782: PUSH
55783: LD_INT 1
55785: ARRAY
55786: PUSH
55787: LD_INT 1
55789: ARRAY
55790: PPUSH
55791: LD_EXP 139
55795: PUSH
55796: LD_VAR 0 2
55800: ARRAY
55801: PUSH
55802: LD_INT 1
55804: ARRAY
55805: PUSH
55806: LD_INT 2
55808: ARRAY
55809: PPUSH
55810: CALL_OW 111
// end ; end ; end ;
55814: GO 55227
55816: POP
55817: POP
// end ;
55818: LD_VAR 0 1
55822: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55823: LD_INT 0
55825: PPUSH
55826: PPUSH
55827: PPUSH
55828: PPUSH
55829: PPUSH
55830: PPUSH
55831: PPUSH
55832: PPUSH
55833: PPUSH
55834: PPUSH
55835: PPUSH
// if not mc_bases then
55836: LD_EXP 102
55840: NOT
55841: IFFALSE 55845
// exit ;
55843: GO 56785
// for i = 1 to mc_bases do
55845: LD_ADDR_VAR 0 2
55849: PUSH
55850: DOUBLE
55851: LD_INT 1
55853: DEC
55854: ST_TO_ADDR
55855: LD_EXP 102
55859: PUSH
55860: FOR_TO
55861: IFFALSE 56783
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55863: LD_EXP 102
55867: PUSH
55868: LD_VAR 0 2
55872: ARRAY
55873: NOT
55874: PUSH
55875: LD_EXP 125
55879: PUSH
55880: LD_VAR 0 2
55884: ARRAY
55885: OR
55886: IFFALSE 55890
// continue ;
55888: GO 55860
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55890: LD_ADDR_VAR 0 7
55894: PUSH
55895: LD_EXP 102
55899: PUSH
55900: LD_VAR 0 2
55904: ARRAY
55905: PUSH
55906: LD_INT 1
55908: ARRAY
55909: PPUSH
55910: CALL_OW 248
55914: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55915: LD_VAR 0 7
55919: PUSH
55920: LD_INT 3
55922: EQUAL
55923: PUSH
55924: LD_EXP 121
55928: PUSH
55929: LD_VAR 0 2
55933: ARRAY
55934: PUSH
55935: LD_EXP 124
55939: PUSH
55940: LD_VAR 0 2
55944: ARRAY
55945: UNION
55946: PPUSH
55947: LD_INT 33
55949: PUSH
55950: LD_INT 2
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: PPUSH
55957: CALL_OW 72
55961: NOT
55962: OR
55963: IFFALSE 55967
// continue ;
55965: GO 55860
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55967: LD_ADDR_VAR 0 9
55971: PUSH
55972: LD_EXP 102
55976: PUSH
55977: LD_VAR 0 2
55981: ARRAY
55982: PPUSH
55983: LD_INT 30
55985: PUSH
55986: LD_INT 36
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: PPUSH
55993: CALL_OW 72
55997: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55998: LD_ADDR_VAR 0 10
56002: PUSH
56003: LD_EXP 121
56007: PUSH
56008: LD_VAR 0 2
56012: ARRAY
56013: PPUSH
56014: LD_INT 34
56016: PUSH
56017: LD_INT 31
56019: PUSH
56020: EMPTY
56021: LIST
56022: LIST
56023: PPUSH
56024: CALL_OW 72
56028: ST_TO_ADDR
// if not cts and not mcts then
56029: LD_VAR 0 9
56033: NOT
56034: PUSH
56035: LD_VAR 0 10
56039: NOT
56040: AND
56041: IFFALSE 56045
// continue ;
56043: GO 55860
// x := cts ;
56045: LD_ADDR_VAR 0 11
56049: PUSH
56050: LD_VAR 0 9
56054: ST_TO_ADDR
// if not x then
56055: LD_VAR 0 11
56059: NOT
56060: IFFALSE 56072
// x := mcts ;
56062: LD_ADDR_VAR 0 11
56066: PUSH
56067: LD_VAR 0 10
56071: ST_TO_ADDR
// if not x then
56072: LD_VAR 0 11
56076: NOT
56077: IFFALSE 56081
// continue ;
56079: GO 55860
// if mc_remote_driver [ i ] then
56081: LD_EXP 142
56085: PUSH
56086: LD_VAR 0 2
56090: ARRAY
56091: IFFALSE 56478
// for j in mc_remote_driver [ i ] do
56093: LD_ADDR_VAR 0 3
56097: PUSH
56098: LD_EXP 142
56102: PUSH
56103: LD_VAR 0 2
56107: ARRAY
56108: PUSH
56109: FOR_IN
56110: IFFALSE 56476
// begin if GetClass ( j ) <> 3 then
56112: LD_VAR 0 3
56116: PPUSH
56117: CALL_OW 257
56121: PUSH
56122: LD_INT 3
56124: NONEQUAL
56125: IFFALSE 56178
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56127: LD_ADDR_EXP 142
56131: PUSH
56132: LD_EXP 142
56136: PPUSH
56137: LD_VAR 0 2
56141: PPUSH
56142: LD_EXP 142
56146: PUSH
56147: LD_VAR 0 2
56151: ARRAY
56152: PUSH
56153: LD_VAR 0 3
56157: DIFF
56158: PPUSH
56159: CALL_OW 1
56163: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56164: LD_VAR 0 3
56168: PPUSH
56169: LD_INT 0
56171: PPUSH
56172: CALL_OW 109
// continue ;
56176: GO 56109
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56178: LD_EXP 121
56182: PUSH
56183: LD_VAR 0 2
56187: ARRAY
56188: PPUSH
56189: LD_INT 34
56191: PUSH
56192: LD_INT 31
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: PUSH
56199: LD_INT 58
56201: PUSH
56202: EMPTY
56203: LIST
56204: PUSH
56205: EMPTY
56206: LIST
56207: LIST
56208: PPUSH
56209: CALL_OW 72
56213: PUSH
56214: LD_VAR 0 3
56218: PPUSH
56219: CALL 105329 0 1
56223: NOT
56224: AND
56225: IFFALSE 56296
// begin if IsInUnit ( j ) then
56227: LD_VAR 0 3
56231: PPUSH
56232: CALL_OW 310
56236: IFFALSE 56247
// ComExitBuilding ( j ) ;
56238: LD_VAR 0 3
56242: PPUSH
56243: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56247: LD_VAR 0 3
56251: PPUSH
56252: LD_EXP 121
56256: PUSH
56257: LD_VAR 0 2
56261: ARRAY
56262: PPUSH
56263: LD_INT 34
56265: PUSH
56266: LD_INT 31
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: PUSH
56273: LD_INT 58
56275: PUSH
56276: EMPTY
56277: LIST
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: PPUSH
56283: CALL_OW 72
56287: PUSH
56288: LD_INT 1
56290: ARRAY
56291: PPUSH
56292: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56296: LD_VAR 0 3
56300: PPUSH
56301: CALL_OW 310
56305: NOT
56306: PUSH
56307: LD_VAR 0 3
56311: PPUSH
56312: CALL_OW 310
56316: PPUSH
56317: CALL_OW 266
56321: PUSH
56322: LD_INT 36
56324: NONEQUAL
56325: PUSH
56326: LD_VAR 0 3
56330: PPUSH
56331: CALL 105329 0 1
56335: NOT
56336: AND
56337: OR
56338: IFFALSE 56474
// begin if IsInUnit ( j ) then
56340: LD_VAR 0 3
56344: PPUSH
56345: CALL_OW 310
56349: IFFALSE 56360
// ComExitBuilding ( j ) ;
56351: LD_VAR 0 3
56355: PPUSH
56356: CALL_OW 122
// ct := 0 ;
56360: LD_ADDR_VAR 0 8
56364: PUSH
56365: LD_INT 0
56367: ST_TO_ADDR
// for k in x do
56368: LD_ADDR_VAR 0 4
56372: PUSH
56373: LD_VAR 0 11
56377: PUSH
56378: FOR_IN
56379: IFFALSE 56452
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56381: LD_VAR 0 4
56385: PPUSH
56386: CALL_OW 264
56390: PUSH
56391: LD_INT 31
56393: EQUAL
56394: PUSH
56395: LD_VAR 0 4
56399: PPUSH
56400: CALL_OW 311
56404: NOT
56405: AND
56406: PUSH
56407: LD_VAR 0 4
56411: PPUSH
56412: CALL_OW 266
56416: PUSH
56417: LD_INT 36
56419: EQUAL
56420: PUSH
56421: LD_VAR 0 4
56425: PPUSH
56426: CALL_OW 313
56430: PUSH
56431: LD_INT 3
56433: LESS
56434: AND
56435: OR
56436: IFFALSE 56450
// begin ct := k ;
56438: LD_ADDR_VAR 0 8
56442: PUSH
56443: LD_VAR 0 4
56447: ST_TO_ADDR
// break ;
56448: GO 56452
// end ;
56450: GO 56378
56452: POP
56453: POP
// if ct then
56454: LD_VAR 0 8
56458: IFFALSE 56474
// ComEnterUnit ( j , ct ) ;
56460: LD_VAR 0 3
56464: PPUSH
56465: LD_VAR 0 8
56469: PPUSH
56470: CALL_OW 120
// end ; end ;
56474: GO 56109
56476: POP
56477: POP
// places := 0 ;
56478: LD_ADDR_VAR 0 5
56482: PUSH
56483: LD_INT 0
56485: ST_TO_ADDR
// for j = 1 to x do
56486: LD_ADDR_VAR 0 3
56490: PUSH
56491: DOUBLE
56492: LD_INT 1
56494: DEC
56495: ST_TO_ADDR
56496: LD_VAR 0 11
56500: PUSH
56501: FOR_TO
56502: IFFALSE 56578
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56504: LD_VAR 0 11
56508: PUSH
56509: LD_VAR 0 3
56513: ARRAY
56514: PPUSH
56515: CALL_OW 264
56519: PUSH
56520: LD_INT 31
56522: EQUAL
56523: IFFALSE 56541
// places := places + 1 else
56525: LD_ADDR_VAR 0 5
56529: PUSH
56530: LD_VAR 0 5
56534: PUSH
56535: LD_INT 1
56537: PLUS
56538: ST_TO_ADDR
56539: GO 56576
// if GetBType ( x [ j ] ) = b_control_tower then
56541: LD_VAR 0 11
56545: PUSH
56546: LD_VAR 0 3
56550: ARRAY
56551: PPUSH
56552: CALL_OW 266
56556: PUSH
56557: LD_INT 36
56559: EQUAL
56560: IFFALSE 56576
// places := places + 3 ;
56562: LD_ADDR_VAR 0 5
56566: PUSH
56567: LD_VAR 0 5
56571: PUSH
56572: LD_INT 3
56574: PLUS
56575: ST_TO_ADDR
56576: GO 56501
56578: POP
56579: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56580: LD_VAR 0 5
56584: PUSH
56585: LD_INT 0
56587: EQUAL
56588: PUSH
56589: LD_VAR 0 5
56593: PUSH
56594: LD_EXP 142
56598: PUSH
56599: LD_VAR 0 2
56603: ARRAY
56604: LESSEQUAL
56605: OR
56606: IFFALSE 56610
// continue ;
56608: GO 55860
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56610: LD_ADDR_VAR 0 6
56614: PUSH
56615: LD_EXP 102
56619: PUSH
56620: LD_VAR 0 2
56624: ARRAY
56625: PPUSH
56626: LD_INT 25
56628: PUSH
56629: LD_INT 3
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: PPUSH
56636: CALL_OW 72
56640: PUSH
56641: LD_EXP 142
56645: PUSH
56646: LD_VAR 0 2
56650: ARRAY
56651: DIFF
56652: PPUSH
56653: LD_INT 3
56655: PPUSH
56656: CALL 106229 0 2
56660: ST_TO_ADDR
// for j in tmp do
56661: LD_ADDR_VAR 0 3
56665: PUSH
56666: LD_VAR 0 6
56670: PUSH
56671: FOR_IN
56672: IFFALSE 56707
// if GetTag ( j ) > 0 then
56674: LD_VAR 0 3
56678: PPUSH
56679: CALL_OW 110
56683: PUSH
56684: LD_INT 0
56686: GREATER
56687: IFFALSE 56705
// tmp := tmp diff j ;
56689: LD_ADDR_VAR 0 6
56693: PUSH
56694: LD_VAR 0 6
56698: PUSH
56699: LD_VAR 0 3
56703: DIFF
56704: ST_TO_ADDR
56705: GO 56671
56707: POP
56708: POP
// if not tmp then
56709: LD_VAR 0 6
56713: NOT
56714: IFFALSE 56718
// continue ;
56716: GO 55860
// if places then
56718: LD_VAR 0 5
56722: IFFALSE 56781
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56724: LD_ADDR_EXP 142
56728: PUSH
56729: LD_EXP 142
56733: PPUSH
56734: LD_VAR 0 2
56738: PPUSH
56739: LD_EXP 142
56743: PUSH
56744: LD_VAR 0 2
56748: ARRAY
56749: PUSH
56750: LD_VAR 0 6
56754: PUSH
56755: LD_INT 1
56757: ARRAY
56758: UNION
56759: PPUSH
56760: CALL_OW 1
56764: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56765: LD_VAR 0 6
56769: PUSH
56770: LD_INT 1
56772: ARRAY
56773: PPUSH
56774: LD_INT 126
56776: PPUSH
56777: CALL_OW 109
// end ; end ;
56781: GO 55860
56783: POP
56784: POP
// end ;
56785: LD_VAR 0 1
56789: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56790: LD_INT 0
56792: PPUSH
56793: PPUSH
56794: PPUSH
56795: PPUSH
56796: PPUSH
56797: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56798: LD_VAR 0 1
56802: NOT
56803: PUSH
56804: LD_VAR 0 2
56808: NOT
56809: OR
56810: PUSH
56811: LD_VAR 0 3
56815: NOT
56816: OR
56817: PUSH
56818: LD_VAR 0 4
56822: PUSH
56823: LD_INT 1
56825: PUSH
56826: LD_INT 2
56828: PUSH
56829: LD_INT 3
56831: PUSH
56832: LD_INT 4
56834: PUSH
56835: LD_INT 5
56837: PUSH
56838: LD_INT 8
56840: PUSH
56841: LD_INT 9
56843: PUSH
56844: LD_INT 15
56846: PUSH
56847: LD_INT 16
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: LIST
56854: LIST
56855: LIST
56856: LIST
56857: LIST
56858: LIST
56859: LIST
56860: IN
56861: NOT
56862: OR
56863: IFFALSE 56867
// exit ;
56865: GO 57767
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56867: LD_ADDR_VAR 0 2
56871: PUSH
56872: LD_VAR 0 2
56876: PPUSH
56877: LD_INT 21
56879: PUSH
56880: LD_INT 3
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PUSH
56887: LD_INT 24
56889: PUSH
56890: LD_INT 250
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: PPUSH
56901: CALL_OW 72
56905: ST_TO_ADDR
// case class of 1 , 15 :
56906: LD_VAR 0 4
56910: PUSH
56911: LD_INT 1
56913: DOUBLE
56914: EQUAL
56915: IFTRUE 56925
56917: LD_INT 15
56919: DOUBLE
56920: EQUAL
56921: IFTRUE 56925
56923: GO 57010
56925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56926: LD_ADDR_VAR 0 8
56930: PUSH
56931: LD_VAR 0 2
56935: PPUSH
56936: LD_INT 2
56938: PUSH
56939: LD_INT 30
56941: PUSH
56942: LD_INT 32
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: PUSH
56949: LD_INT 30
56951: PUSH
56952: LD_INT 31
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: LIST
56963: PPUSH
56964: CALL_OW 72
56968: PUSH
56969: LD_VAR 0 2
56973: PPUSH
56974: LD_INT 2
56976: PUSH
56977: LD_INT 30
56979: PUSH
56980: LD_INT 4
56982: PUSH
56983: EMPTY
56984: LIST
56985: LIST
56986: PUSH
56987: LD_INT 30
56989: PUSH
56990: LD_INT 5
56992: PUSH
56993: EMPTY
56994: LIST
56995: LIST
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: LIST
57001: PPUSH
57002: CALL_OW 72
57006: ADD
57007: ST_TO_ADDR
57008: GO 57256
57010: LD_INT 2
57012: DOUBLE
57013: EQUAL
57014: IFTRUE 57024
57016: LD_INT 16
57018: DOUBLE
57019: EQUAL
57020: IFTRUE 57024
57022: GO 57070
57024: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57025: LD_ADDR_VAR 0 8
57029: PUSH
57030: LD_VAR 0 2
57034: PPUSH
57035: LD_INT 2
57037: PUSH
57038: LD_INT 30
57040: PUSH
57041: LD_INT 0
57043: PUSH
57044: EMPTY
57045: LIST
57046: LIST
57047: PUSH
57048: LD_INT 30
57050: PUSH
57051: LD_INT 1
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: PUSH
57058: EMPTY
57059: LIST
57060: LIST
57061: LIST
57062: PPUSH
57063: CALL_OW 72
57067: ST_TO_ADDR
57068: GO 57256
57070: LD_INT 3
57072: DOUBLE
57073: EQUAL
57074: IFTRUE 57078
57076: GO 57124
57078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57079: LD_ADDR_VAR 0 8
57083: PUSH
57084: LD_VAR 0 2
57088: PPUSH
57089: LD_INT 2
57091: PUSH
57092: LD_INT 30
57094: PUSH
57095: LD_INT 2
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PUSH
57102: LD_INT 30
57104: PUSH
57105: LD_INT 3
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 72
57121: ST_TO_ADDR
57122: GO 57256
57124: LD_INT 4
57126: DOUBLE
57127: EQUAL
57128: IFTRUE 57132
57130: GO 57189
57132: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57133: LD_ADDR_VAR 0 8
57137: PUSH
57138: LD_VAR 0 2
57142: PPUSH
57143: LD_INT 2
57145: PUSH
57146: LD_INT 30
57148: PUSH
57149: LD_INT 6
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PUSH
57156: LD_INT 30
57158: PUSH
57159: LD_INT 7
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: PUSH
57166: LD_INT 30
57168: PUSH
57169: LD_INT 8
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: PUSH
57176: EMPTY
57177: LIST
57178: LIST
57179: LIST
57180: LIST
57181: PPUSH
57182: CALL_OW 72
57186: ST_TO_ADDR
57187: GO 57256
57189: LD_INT 5
57191: DOUBLE
57192: EQUAL
57193: IFTRUE 57209
57195: LD_INT 8
57197: DOUBLE
57198: EQUAL
57199: IFTRUE 57209
57201: LD_INT 9
57203: DOUBLE
57204: EQUAL
57205: IFTRUE 57209
57207: GO 57255
57209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57210: LD_ADDR_VAR 0 8
57214: PUSH
57215: LD_VAR 0 2
57219: PPUSH
57220: LD_INT 2
57222: PUSH
57223: LD_INT 30
57225: PUSH
57226: LD_INT 4
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: LD_INT 30
57235: PUSH
57236: LD_INT 5
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: EMPTY
57244: LIST
57245: LIST
57246: LIST
57247: PPUSH
57248: CALL_OW 72
57252: ST_TO_ADDR
57253: GO 57256
57255: POP
// if not tmp then
57256: LD_VAR 0 8
57260: NOT
57261: IFFALSE 57265
// exit ;
57263: GO 57767
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57265: LD_VAR 0 4
57269: PUSH
57270: LD_INT 1
57272: PUSH
57273: LD_INT 15
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: IN
57280: PUSH
57281: LD_EXP 111
57285: PUSH
57286: LD_VAR 0 1
57290: ARRAY
57291: AND
57292: IFFALSE 57448
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57294: LD_ADDR_VAR 0 9
57298: PUSH
57299: LD_EXP 111
57303: PUSH
57304: LD_VAR 0 1
57308: ARRAY
57309: PUSH
57310: LD_INT 1
57312: ARRAY
57313: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57314: LD_VAR 0 9
57318: PUSH
57319: LD_EXP 112
57323: PUSH
57324: LD_VAR 0 1
57328: ARRAY
57329: IN
57330: NOT
57331: IFFALSE 57446
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57333: LD_ADDR_EXP 112
57337: PUSH
57338: LD_EXP 112
57342: PPUSH
57343: LD_VAR 0 1
57347: PUSH
57348: LD_EXP 112
57352: PUSH
57353: LD_VAR 0 1
57357: ARRAY
57358: PUSH
57359: LD_INT 1
57361: PLUS
57362: PUSH
57363: EMPTY
57364: LIST
57365: LIST
57366: PPUSH
57367: LD_VAR 0 9
57371: PPUSH
57372: CALL 71978 0 3
57376: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57377: LD_ADDR_EXP 111
57381: PUSH
57382: LD_EXP 111
57386: PPUSH
57387: LD_VAR 0 1
57391: PPUSH
57392: LD_EXP 111
57396: PUSH
57397: LD_VAR 0 1
57401: ARRAY
57402: PUSH
57403: LD_VAR 0 9
57407: DIFF
57408: PPUSH
57409: CALL_OW 1
57413: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57414: LD_VAR 0 3
57418: PPUSH
57419: LD_EXP 112
57423: PUSH
57424: LD_VAR 0 1
57428: ARRAY
57429: PUSH
57430: LD_EXP 112
57434: PUSH
57435: LD_VAR 0 1
57439: ARRAY
57440: ARRAY
57441: PPUSH
57442: CALL_OW 120
// end ; exit ;
57446: GO 57767
// end ; if tmp > 1 then
57448: LD_VAR 0 8
57452: PUSH
57453: LD_INT 1
57455: GREATER
57456: IFFALSE 57560
// for i = 2 to tmp do
57458: LD_ADDR_VAR 0 6
57462: PUSH
57463: DOUBLE
57464: LD_INT 2
57466: DEC
57467: ST_TO_ADDR
57468: LD_VAR 0 8
57472: PUSH
57473: FOR_TO
57474: IFFALSE 57558
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57476: LD_VAR 0 8
57480: PUSH
57481: LD_VAR 0 6
57485: ARRAY
57486: PPUSH
57487: CALL_OW 461
57491: PUSH
57492: LD_INT 6
57494: EQUAL
57495: IFFALSE 57556
// begin x := tmp [ i ] ;
57497: LD_ADDR_VAR 0 9
57501: PUSH
57502: LD_VAR 0 8
57506: PUSH
57507: LD_VAR 0 6
57511: ARRAY
57512: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57513: LD_ADDR_VAR 0 8
57517: PUSH
57518: LD_VAR 0 8
57522: PPUSH
57523: LD_VAR 0 6
57527: PPUSH
57528: CALL_OW 3
57532: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57533: LD_ADDR_VAR 0 8
57537: PUSH
57538: LD_VAR 0 8
57542: PPUSH
57543: LD_INT 1
57545: PPUSH
57546: LD_VAR 0 9
57550: PPUSH
57551: CALL_OW 2
57555: ST_TO_ADDR
// end ;
57556: GO 57473
57558: POP
57559: POP
// for i in tmp do
57560: LD_ADDR_VAR 0 6
57564: PUSH
57565: LD_VAR 0 8
57569: PUSH
57570: FOR_IN
57571: IFFALSE 57640
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57573: LD_VAR 0 6
57577: PPUSH
57578: CALL_OW 313
57582: PUSH
57583: LD_INT 6
57585: LESS
57586: PUSH
57587: LD_VAR 0 6
57591: PPUSH
57592: CALL_OW 266
57596: PUSH
57597: LD_INT 31
57599: PUSH
57600: LD_INT 32
57602: PUSH
57603: EMPTY
57604: LIST
57605: LIST
57606: IN
57607: NOT
57608: AND
57609: PUSH
57610: LD_VAR 0 6
57614: PPUSH
57615: CALL_OW 313
57619: PUSH
57620: LD_INT 0
57622: EQUAL
57623: OR
57624: IFFALSE 57638
// begin j := i ;
57626: LD_ADDR_VAR 0 7
57630: PUSH
57631: LD_VAR 0 6
57635: ST_TO_ADDR
// break ;
57636: GO 57640
// end ; end ;
57638: GO 57570
57640: POP
57641: POP
// if j then
57642: LD_VAR 0 7
57646: IFFALSE 57664
// ComEnterUnit ( unit , j ) else
57648: LD_VAR 0 3
57652: PPUSH
57653: LD_VAR 0 7
57657: PPUSH
57658: CALL_OW 120
57662: GO 57767
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57664: LD_ADDR_VAR 0 10
57668: PUSH
57669: LD_VAR 0 2
57673: PPUSH
57674: LD_INT 2
57676: PUSH
57677: LD_INT 30
57679: PUSH
57680: LD_INT 0
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: PUSH
57687: LD_INT 30
57689: PUSH
57690: LD_INT 1
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: PUSH
57697: EMPTY
57698: LIST
57699: LIST
57700: LIST
57701: PPUSH
57702: CALL_OW 72
57706: ST_TO_ADDR
// if depot then
57707: LD_VAR 0 10
57711: IFFALSE 57767
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57713: LD_ADDR_VAR 0 10
57717: PUSH
57718: LD_VAR 0 10
57722: PPUSH
57723: LD_VAR 0 3
57727: PPUSH
57728: CALL_OW 74
57732: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57733: LD_VAR 0 3
57737: PPUSH
57738: LD_VAR 0 10
57742: PPUSH
57743: CALL_OW 296
57747: PUSH
57748: LD_INT 10
57750: GREATER
57751: IFFALSE 57767
// ComStandNearbyBuilding ( unit , depot ) ;
57753: LD_VAR 0 3
57757: PPUSH
57758: LD_VAR 0 10
57762: PPUSH
57763: CALL 66181 0 2
// end ; end ; end ;
57767: LD_VAR 0 5
57771: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57772: LD_INT 0
57774: PPUSH
57775: PPUSH
57776: PPUSH
57777: PPUSH
// if not mc_bases then
57778: LD_EXP 102
57782: NOT
57783: IFFALSE 57787
// exit ;
57785: GO 58026
// for i = 1 to mc_bases do
57787: LD_ADDR_VAR 0 2
57791: PUSH
57792: DOUBLE
57793: LD_INT 1
57795: DEC
57796: ST_TO_ADDR
57797: LD_EXP 102
57801: PUSH
57802: FOR_TO
57803: IFFALSE 58024
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57805: LD_ADDR_VAR 0 4
57809: PUSH
57810: LD_EXP 102
57814: PUSH
57815: LD_VAR 0 2
57819: ARRAY
57820: PPUSH
57821: LD_INT 21
57823: PUSH
57824: LD_INT 1
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: PPUSH
57831: CALL_OW 72
57835: PUSH
57836: LD_EXP 131
57840: PUSH
57841: LD_VAR 0 2
57845: ARRAY
57846: UNION
57847: ST_TO_ADDR
// if not tmp then
57848: LD_VAR 0 4
57852: NOT
57853: IFFALSE 57857
// continue ;
57855: GO 57802
// for j in tmp do
57857: LD_ADDR_VAR 0 3
57861: PUSH
57862: LD_VAR 0 4
57866: PUSH
57867: FOR_IN
57868: IFFALSE 58020
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57870: LD_VAR 0 3
57874: PPUSH
57875: CALL_OW 110
57879: NOT
57880: PUSH
57881: LD_VAR 0 3
57885: PPUSH
57886: CALL_OW 314
57890: NOT
57891: AND
57892: PUSH
57893: LD_VAR 0 3
57897: PPUSH
57898: CALL_OW 311
57902: NOT
57903: AND
57904: PUSH
57905: LD_VAR 0 3
57909: PPUSH
57910: CALL_OW 310
57914: NOT
57915: AND
57916: PUSH
57917: LD_VAR 0 3
57921: PUSH
57922: LD_EXP 105
57926: PUSH
57927: LD_VAR 0 2
57931: ARRAY
57932: PUSH
57933: LD_INT 1
57935: ARRAY
57936: IN
57937: NOT
57938: AND
57939: PUSH
57940: LD_VAR 0 3
57944: PUSH
57945: LD_EXP 105
57949: PUSH
57950: LD_VAR 0 2
57954: ARRAY
57955: PUSH
57956: LD_INT 2
57958: ARRAY
57959: IN
57960: NOT
57961: AND
57962: PUSH
57963: LD_VAR 0 3
57967: PUSH
57968: LD_EXP 114
57972: PUSH
57973: LD_VAR 0 2
57977: ARRAY
57978: IN
57979: NOT
57980: AND
57981: IFFALSE 58018
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57983: LD_VAR 0 2
57987: PPUSH
57988: LD_EXP 102
57992: PUSH
57993: LD_VAR 0 2
57997: ARRAY
57998: PPUSH
57999: LD_VAR 0 3
58003: PPUSH
58004: LD_VAR 0 3
58008: PPUSH
58009: CALL_OW 257
58013: PPUSH
58014: CALL 56790 0 4
// end ;
58018: GO 57867
58020: POP
58021: POP
// end ;
58022: GO 57802
58024: POP
58025: POP
// end ;
58026: LD_VAR 0 1
58030: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58031: LD_INT 0
58033: PPUSH
58034: PPUSH
58035: PPUSH
58036: PPUSH
58037: PPUSH
58038: PPUSH
// if not mc_bases [ base ] then
58039: LD_EXP 102
58043: PUSH
58044: LD_VAR 0 1
58048: ARRAY
58049: NOT
58050: IFFALSE 58054
// exit ;
58052: GO 58236
// tmp := [ ] ;
58054: LD_ADDR_VAR 0 6
58058: PUSH
58059: EMPTY
58060: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58061: LD_ADDR_VAR 0 7
58065: PUSH
58066: LD_VAR 0 3
58070: PPUSH
58071: LD_INT 0
58073: PPUSH
58074: CALL_OW 517
58078: ST_TO_ADDR
// if not list then
58079: LD_VAR 0 7
58083: NOT
58084: IFFALSE 58088
// exit ;
58086: GO 58236
// for i = 1 to amount do
58088: LD_ADDR_VAR 0 5
58092: PUSH
58093: DOUBLE
58094: LD_INT 1
58096: DEC
58097: ST_TO_ADDR
58098: LD_VAR 0 2
58102: PUSH
58103: FOR_TO
58104: IFFALSE 58184
// begin x := rand ( 1 , list [ 1 ] ) ;
58106: LD_ADDR_VAR 0 8
58110: PUSH
58111: LD_INT 1
58113: PPUSH
58114: LD_VAR 0 7
58118: PUSH
58119: LD_INT 1
58121: ARRAY
58122: PPUSH
58123: CALL_OW 12
58127: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58128: LD_ADDR_VAR 0 6
58132: PUSH
58133: LD_VAR 0 6
58137: PPUSH
58138: LD_VAR 0 5
58142: PPUSH
58143: LD_VAR 0 7
58147: PUSH
58148: LD_INT 1
58150: ARRAY
58151: PUSH
58152: LD_VAR 0 8
58156: ARRAY
58157: PUSH
58158: LD_VAR 0 7
58162: PUSH
58163: LD_INT 2
58165: ARRAY
58166: PUSH
58167: LD_VAR 0 8
58171: ARRAY
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PPUSH
58177: CALL_OW 1
58181: ST_TO_ADDR
// end ;
58182: GO 58103
58184: POP
58185: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58186: LD_ADDR_EXP 115
58190: PUSH
58191: LD_EXP 115
58195: PPUSH
58196: LD_VAR 0 1
58200: PPUSH
58201: LD_VAR 0 6
58205: PPUSH
58206: CALL_OW 1
58210: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58211: LD_ADDR_EXP 117
58215: PUSH
58216: LD_EXP 117
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: LD_VAR 0 3
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// end ;
58236: LD_VAR 0 4
58240: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58241: LD_INT 0
58243: PPUSH
// if not mc_bases [ base ] then
58244: LD_EXP 102
58248: PUSH
58249: LD_VAR 0 1
58253: ARRAY
58254: NOT
58255: IFFALSE 58259
// exit ;
58257: GO 58284
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58259: LD_ADDR_EXP 107
58263: PUSH
58264: LD_EXP 107
58268: PPUSH
58269: LD_VAR 0 1
58273: PPUSH
58274: LD_VAR 0 2
58278: PPUSH
58279: CALL_OW 1
58283: ST_TO_ADDR
// end ;
58284: LD_VAR 0 3
58288: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58289: LD_INT 0
58291: PPUSH
// if not mc_bases [ base ] then
58292: LD_EXP 102
58296: PUSH
58297: LD_VAR 0 1
58301: ARRAY
58302: NOT
58303: IFFALSE 58307
// exit ;
58305: GO 58344
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58307: LD_ADDR_EXP 107
58311: PUSH
58312: LD_EXP 107
58316: PPUSH
58317: LD_VAR 0 1
58321: PPUSH
58322: LD_EXP 107
58326: PUSH
58327: LD_VAR 0 1
58331: ARRAY
58332: PUSH
58333: LD_VAR 0 2
58337: UNION
58338: PPUSH
58339: CALL_OW 1
58343: ST_TO_ADDR
// end ;
58344: LD_VAR 0 3
58348: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58349: LD_INT 0
58351: PPUSH
// if not mc_bases [ base ] then
58352: LD_EXP 102
58356: PUSH
58357: LD_VAR 0 1
58361: ARRAY
58362: NOT
58363: IFFALSE 58367
// exit ;
58365: GO 58392
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58367: LD_ADDR_EXP 123
58371: PUSH
58372: LD_EXP 123
58376: PPUSH
58377: LD_VAR 0 1
58381: PPUSH
58382: LD_VAR 0 2
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// end ;
58392: LD_VAR 0 3
58396: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58397: LD_INT 0
58399: PPUSH
// if not mc_bases [ base ] then
58400: LD_EXP 102
58404: PUSH
58405: LD_VAR 0 1
58409: ARRAY
58410: NOT
58411: IFFALSE 58415
// exit ;
58413: GO 58452
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58415: LD_ADDR_EXP 123
58419: PUSH
58420: LD_EXP 123
58424: PPUSH
58425: LD_VAR 0 1
58429: PPUSH
58430: LD_EXP 123
58434: PUSH
58435: LD_VAR 0 1
58439: ARRAY
58440: PUSH
58441: LD_VAR 0 2
58445: ADD
58446: PPUSH
58447: CALL_OW 1
58451: ST_TO_ADDR
// end ;
58452: LD_VAR 0 3
58456: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58457: LD_INT 0
58459: PPUSH
// if not mc_bases [ base ] then
58460: LD_EXP 102
58464: PUSH
58465: LD_VAR 0 1
58469: ARRAY
58470: NOT
58471: IFFALSE 58475
// exit ;
58473: GO 58529
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58475: LD_ADDR_EXP 124
58479: PUSH
58480: LD_EXP 124
58484: PPUSH
58485: LD_VAR 0 1
58489: PPUSH
58490: LD_VAR 0 2
58494: PPUSH
58495: CALL_OW 1
58499: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58500: LD_ADDR_EXP 113
58504: PUSH
58505: LD_EXP 113
58509: PPUSH
58510: LD_VAR 0 1
58514: PPUSH
58515: LD_VAR 0 2
58519: PUSH
58520: LD_INT 0
58522: PLUS
58523: PPUSH
58524: CALL_OW 1
58528: ST_TO_ADDR
// end ;
58529: LD_VAR 0 3
58533: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58534: LD_INT 0
58536: PPUSH
// if not mc_bases [ base ] then
58537: LD_EXP 102
58541: PUSH
58542: LD_VAR 0 1
58546: ARRAY
58547: NOT
58548: IFFALSE 58552
// exit ;
58550: GO 58577
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58552: LD_ADDR_EXP 113
58556: PUSH
58557: LD_EXP 113
58561: PPUSH
58562: LD_VAR 0 1
58566: PPUSH
58567: LD_VAR 0 2
58571: PPUSH
58572: CALL_OW 1
58576: ST_TO_ADDR
// end ;
58577: LD_VAR 0 3
58581: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58582: LD_INT 0
58584: PPUSH
58585: PPUSH
58586: PPUSH
58587: PPUSH
// if not mc_bases [ base ] then
58588: LD_EXP 102
58592: PUSH
58593: LD_VAR 0 1
58597: ARRAY
58598: NOT
58599: IFFALSE 58603
// exit ;
58601: GO 58668
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58603: LD_ADDR_EXP 122
58607: PUSH
58608: LD_EXP 122
58612: PPUSH
58613: LD_VAR 0 1
58617: PUSH
58618: LD_EXP 122
58622: PUSH
58623: LD_VAR 0 1
58627: ARRAY
58628: PUSH
58629: LD_INT 1
58631: PLUS
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: PPUSH
58637: LD_VAR 0 1
58641: PUSH
58642: LD_VAR 0 2
58646: PUSH
58647: LD_VAR 0 3
58651: PUSH
58652: LD_VAR 0 4
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: LIST
58661: LIST
58662: PPUSH
58663: CALL 71978 0 3
58667: ST_TO_ADDR
// end ;
58668: LD_VAR 0 5
58672: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58673: LD_INT 0
58675: PPUSH
// if not mc_bases [ base ] then
58676: LD_EXP 102
58680: PUSH
58681: LD_VAR 0 1
58685: ARRAY
58686: NOT
58687: IFFALSE 58691
// exit ;
58689: GO 58716
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58691: LD_ADDR_EXP 139
58695: PUSH
58696: LD_EXP 139
58700: PPUSH
58701: LD_VAR 0 1
58705: PPUSH
58706: LD_VAR 0 2
58710: PPUSH
58711: CALL_OW 1
58715: ST_TO_ADDR
// end ;
58716: LD_VAR 0 3
58720: RET
// export function MC_GetMinesField ( base ) ; begin
58721: LD_INT 0
58723: PPUSH
// result := mc_mines [ base ] ;
58724: LD_ADDR_VAR 0 2
58728: PUSH
58729: LD_EXP 115
58733: PUSH
58734: LD_VAR 0 1
58738: ARRAY
58739: ST_TO_ADDR
// end ;
58740: LD_VAR 0 2
58744: RET
// export function MC_GetProduceList ( base ) ; begin
58745: LD_INT 0
58747: PPUSH
// result := mc_produce [ base ] ;
58748: LD_ADDR_VAR 0 2
58752: PUSH
58753: LD_EXP 123
58757: PUSH
58758: LD_VAR 0 1
58762: ARRAY
58763: ST_TO_ADDR
// end ;
58764: LD_VAR 0 2
58768: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58769: LD_INT 0
58771: PPUSH
58772: PPUSH
// if not mc_bases then
58773: LD_EXP 102
58777: NOT
58778: IFFALSE 58782
// exit ;
58780: GO 58847
// if mc_bases [ base ] then
58782: LD_EXP 102
58786: PUSH
58787: LD_VAR 0 1
58791: ARRAY
58792: IFFALSE 58847
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58794: LD_ADDR_VAR 0 3
58798: PUSH
58799: LD_EXP 102
58803: PUSH
58804: LD_VAR 0 1
58808: ARRAY
58809: PPUSH
58810: LD_INT 30
58812: PUSH
58813: LD_VAR 0 2
58817: PUSH
58818: EMPTY
58819: LIST
58820: LIST
58821: PPUSH
58822: CALL_OW 72
58826: ST_TO_ADDR
// if result then
58827: LD_VAR 0 3
58831: IFFALSE 58847
// result := result [ 1 ] ;
58833: LD_ADDR_VAR 0 3
58837: PUSH
58838: LD_VAR 0 3
58842: PUSH
58843: LD_INT 1
58845: ARRAY
58846: ST_TO_ADDR
// end ; end ;
58847: LD_VAR 0 3
58851: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58852: LD_INT 0
58854: PPUSH
58855: PPUSH
// if not mc_bases then
58856: LD_EXP 102
58860: NOT
58861: IFFALSE 58865
// exit ;
58863: GO 58910
// if mc_bases [ base ] then
58865: LD_EXP 102
58869: PUSH
58870: LD_VAR 0 1
58874: ARRAY
58875: IFFALSE 58910
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58877: LD_ADDR_VAR 0 3
58881: PUSH
58882: LD_EXP 102
58886: PUSH
58887: LD_VAR 0 1
58891: ARRAY
58892: PPUSH
58893: LD_INT 30
58895: PUSH
58896: LD_VAR 0 2
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: PPUSH
58905: CALL_OW 72
58909: ST_TO_ADDR
// end ;
58910: LD_VAR 0 3
58914: RET
// export function MC_SetTame ( base , area ) ; begin
58915: LD_INT 0
58917: PPUSH
// if not mc_bases or not base then
58918: LD_EXP 102
58922: NOT
58923: PUSH
58924: LD_VAR 0 1
58928: NOT
58929: OR
58930: IFFALSE 58934
// exit ;
58932: GO 58959
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58934: LD_ADDR_EXP 130
58938: PUSH
58939: LD_EXP 130
58943: PPUSH
58944: LD_VAR 0 1
58948: PPUSH
58949: LD_VAR 0 2
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// end ;
58959: LD_VAR 0 3
58963: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58964: LD_INT 0
58966: PPUSH
58967: PPUSH
// if not mc_bases or not base then
58968: LD_EXP 102
58972: NOT
58973: PUSH
58974: LD_VAR 0 1
58978: NOT
58979: OR
58980: IFFALSE 58984
// exit ;
58982: GO 59086
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58984: LD_ADDR_VAR 0 4
58988: PUSH
58989: LD_EXP 102
58993: PUSH
58994: LD_VAR 0 1
58998: ARRAY
58999: PPUSH
59000: LD_INT 30
59002: PUSH
59003: LD_VAR 0 2
59007: PUSH
59008: EMPTY
59009: LIST
59010: LIST
59011: PPUSH
59012: CALL_OW 72
59016: ST_TO_ADDR
// if not tmp then
59017: LD_VAR 0 4
59021: NOT
59022: IFFALSE 59026
// exit ;
59024: GO 59086
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59026: LD_ADDR_EXP 134
59030: PUSH
59031: LD_EXP 134
59035: PPUSH
59036: LD_VAR 0 1
59040: PPUSH
59041: LD_EXP 134
59045: PUSH
59046: LD_VAR 0 1
59050: ARRAY
59051: PPUSH
59052: LD_EXP 134
59056: PUSH
59057: LD_VAR 0 1
59061: ARRAY
59062: PUSH
59063: LD_INT 1
59065: PLUS
59066: PPUSH
59067: LD_VAR 0 4
59071: PUSH
59072: LD_INT 1
59074: ARRAY
59075: PPUSH
59076: CALL_OW 2
59080: PPUSH
59081: CALL_OW 1
59085: ST_TO_ADDR
// end ;
59086: LD_VAR 0 3
59090: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59091: LD_INT 0
59093: PPUSH
59094: PPUSH
// if not mc_bases or not base or not kinds then
59095: LD_EXP 102
59099: NOT
59100: PUSH
59101: LD_VAR 0 1
59105: NOT
59106: OR
59107: PUSH
59108: LD_VAR 0 2
59112: NOT
59113: OR
59114: IFFALSE 59118
// exit ;
59116: GO 59179
// for i in kinds do
59118: LD_ADDR_VAR 0 4
59122: PUSH
59123: LD_VAR 0 2
59127: PUSH
59128: FOR_IN
59129: IFFALSE 59177
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59131: LD_ADDR_EXP 136
59135: PUSH
59136: LD_EXP 136
59140: PPUSH
59141: LD_VAR 0 1
59145: PUSH
59146: LD_EXP 136
59150: PUSH
59151: LD_VAR 0 1
59155: ARRAY
59156: PUSH
59157: LD_INT 1
59159: PLUS
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: PPUSH
59165: LD_VAR 0 4
59169: PPUSH
59170: CALL 71978 0 3
59174: ST_TO_ADDR
59175: GO 59128
59177: POP
59178: POP
// end ;
59179: LD_VAR 0 3
59183: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59184: LD_INT 0
59186: PPUSH
// if not mc_bases or not base or not areas then
59187: LD_EXP 102
59191: NOT
59192: PUSH
59193: LD_VAR 0 1
59197: NOT
59198: OR
59199: PUSH
59200: LD_VAR 0 2
59204: NOT
59205: OR
59206: IFFALSE 59210
// exit ;
59208: GO 59235
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59210: LD_ADDR_EXP 120
59214: PUSH
59215: LD_EXP 120
59219: PPUSH
59220: LD_VAR 0 1
59224: PPUSH
59225: LD_VAR 0 2
59229: PPUSH
59230: CALL_OW 1
59234: ST_TO_ADDR
// end ;
59235: LD_VAR 0 3
59239: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59240: LD_INT 0
59242: PPUSH
// if not mc_bases or not base or not teleports_exit then
59243: LD_EXP 102
59247: NOT
59248: PUSH
59249: LD_VAR 0 1
59253: NOT
59254: OR
59255: PUSH
59256: LD_VAR 0 2
59260: NOT
59261: OR
59262: IFFALSE 59266
// exit ;
59264: GO 59291
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59266: LD_ADDR_EXP 137
59270: PUSH
59271: LD_EXP 137
59275: PPUSH
59276: LD_VAR 0 1
59280: PPUSH
59281: LD_VAR 0 2
59285: PPUSH
59286: CALL_OW 1
59290: ST_TO_ADDR
// end ;
59291: LD_VAR 0 3
59295: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
// if not mc_bases or not base or not ext_list then
59301: LD_EXP 102
59305: NOT
59306: PUSH
59307: LD_VAR 0 1
59311: NOT
59312: OR
59313: PUSH
59314: LD_VAR 0 5
59318: NOT
59319: OR
59320: IFFALSE 59324
// exit ;
59322: GO 59497
// tmp := GetFacExtXYD ( x , y , d ) ;
59324: LD_ADDR_VAR 0 8
59328: PUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: LD_VAR 0 3
59338: PPUSH
59339: LD_VAR 0 4
59343: PPUSH
59344: CALL 105359 0 3
59348: ST_TO_ADDR
// if not tmp then
59349: LD_VAR 0 8
59353: NOT
59354: IFFALSE 59358
// exit ;
59356: GO 59497
// for i in tmp do
59358: LD_ADDR_VAR 0 7
59362: PUSH
59363: LD_VAR 0 8
59367: PUSH
59368: FOR_IN
59369: IFFALSE 59495
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59371: LD_ADDR_EXP 107
59375: PUSH
59376: LD_EXP 107
59380: PPUSH
59381: LD_VAR 0 1
59385: PPUSH
59386: LD_EXP 107
59390: PUSH
59391: LD_VAR 0 1
59395: ARRAY
59396: PPUSH
59397: LD_EXP 107
59401: PUSH
59402: LD_VAR 0 1
59406: ARRAY
59407: PUSH
59408: LD_INT 1
59410: PLUS
59411: PPUSH
59412: LD_VAR 0 5
59416: PUSH
59417: LD_INT 1
59419: ARRAY
59420: PUSH
59421: LD_VAR 0 7
59425: PUSH
59426: LD_INT 1
59428: ARRAY
59429: PUSH
59430: LD_VAR 0 7
59434: PUSH
59435: LD_INT 2
59437: ARRAY
59438: PUSH
59439: LD_VAR 0 7
59443: PUSH
59444: LD_INT 3
59446: ARRAY
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: LIST
59452: LIST
59453: PPUSH
59454: CALL_OW 2
59458: PPUSH
59459: CALL_OW 1
59463: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59464: LD_ADDR_VAR 0 5
59468: PUSH
59469: LD_VAR 0 5
59473: PPUSH
59474: LD_INT 1
59476: PPUSH
59477: CALL_OW 3
59481: ST_TO_ADDR
// if not ext_list then
59482: LD_VAR 0 5
59486: NOT
59487: IFFALSE 59493
// exit ;
59489: POP
59490: POP
59491: GO 59497
// end ;
59493: GO 59368
59495: POP
59496: POP
// end ;
59497: LD_VAR 0 6
59501: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59502: LD_INT 0
59504: PPUSH
// if not mc_bases or not base or not weapon_list then
59505: LD_EXP 102
59509: NOT
59510: PUSH
59511: LD_VAR 0 1
59515: NOT
59516: OR
59517: PUSH
59518: LD_VAR 0 2
59522: NOT
59523: OR
59524: IFFALSE 59528
// exit ;
59526: GO 59553
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59528: LD_ADDR_EXP 141
59532: PUSH
59533: LD_EXP 141
59537: PPUSH
59538: LD_VAR 0 1
59542: PPUSH
59543: LD_VAR 0 2
59547: PPUSH
59548: CALL_OW 1
59552: ST_TO_ADDR
// end ;
59553: LD_VAR 0 3
59557: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59558: LD_INT 0
59560: PPUSH
// if not mc_bases or not base or not tech_list then
59561: LD_EXP 102
59565: NOT
59566: PUSH
59567: LD_VAR 0 1
59571: NOT
59572: OR
59573: PUSH
59574: LD_VAR 0 2
59578: NOT
59579: OR
59580: IFFALSE 59584
// exit ;
59582: GO 59609
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59584: LD_ADDR_EXP 129
59588: PUSH
59589: LD_EXP 129
59593: PPUSH
59594: LD_VAR 0 1
59598: PPUSH
59599: LD_VAR 0 2
59603: PPUSH
59604: CALL_OW 1
59608: ST_TO_ADDR
// end ;
59609: LD_VAR 0 3
59613: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59614: LD_INT 0
59616: PPUSH
// if not mc_bases or not parking_area or not base then
59617: LD_EXP 102
59621: NOT
59622: PUSH
59623: LD_VAR 0 2
59627: NOT
59628: OR
59629: PUSH
59630: LD_VAR 0 1
59634: NOT
59635: OR
59636: IFFALSE 59640
// exit ;
59638: GO 59665
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59640: LD_ADDR_EXP 126
59644: PUSH
59645: LD_EXP 126
59649: PPUSH
59650: LD_VAR 0 1
59654: PPUSH
59655: LD_VAR 0 2
59659: PPUSH
59660: CALL_OW 1
59664: ST_TO_ADDR
// end ;
59665: LD_VAR 0 3
59669: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59670: LD_INT 0
59672: PPUSH
// if not mc_bases or not base or not scan_area then
59673: LD_EXP 102
59677: NOT
59678: PUSH
59679: LD_VAR 0 1
59683: NOT
59684: OR
59685: PUSH
59686: LD_VAR 0 2
59690: NOT
59691: OR
59692: IFFALSE 59696
// exit ;
59694: GO 59721
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59696: LD_ADDR_EXP 127
59700: PUSH
59701: LD_EXP 127
59705: PPUSH
59706: LD_VAR 0 1
59710: PPUSH
59711: LD_VAR 0 2
59715: PPUSH
59716: CALL_OW 1
59720: ST_TO_ADDR
// end ;
59721: LD_VAR 0 3
59725: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59726: LD_INT 0
59728: PPUSH
59729: PPUSH
// if not mc_bases or not base then
59730: LD_EXP 102
59734: NOT
59735: PUSH
59736: LD_VAR 0 1
59740: NOT
59741: OR
59742: IFFALSE 59746
// exit ;
59744: GO 59810
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59746: LD_ADDR_VAR 0 3
59750: PUSH
59751: LD_INT 1
59753: PUSH
59754: LD_INT 2
59756: PUSH
59757: LD_INT 3
59759: PUSH
59760: LD_INT 4
59762: PUSH
59763: LD_INT 11
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: LIST
59770: LIST
59771: LIST
59772: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59773: LD_ADDR_EXP 129
59777: PUSH
59778: LD_EXP 129
59782: PPUSH
59783: LD_VAR 0 1
59787: PPUSH
59788: LD_EXP 129
59792: PUSH
59793: LD_VAR 0 1
59797: ARRAY
59798: PUSH
59799: LD_VAR 0 3
59803: DIFF
59804: PPUSH
59805: CALL_OW 1
59809: ST_TO_ADDR
// end ;
59810: LD_VAR 0 2
59814: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59815: LD_INT 0
59817: PPUSH
// result := mc_vehicles [ base ] ;
59818: LD_ADDR_VAR 0 3
59822: PUSH
59823: LD_EXP 121
59827: PUSH
59828: LD_VAR 0 1
59832: ARRAY
59833: ST_TO_ADDR
// if onlyCombat then
59834: LD_VAR 0 2
59838: IFFALSE 60003
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59840: LD_ADDR_VAR 0 3
59844: PUSH
59845: LD_VAR 0 3
59849: PUSH
59850: LD_VAR 0 3
59854: PPUSH
59855: LD_INT 2
59857: PUSH
59858: LD_INT 34
59860: PUSH
59861: LD_INT 12
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PUSH
59868: LD_INT 34
59870: PUSH
59871: LD_INT 51
59873: PUSH
59874: EMPTY
59875: LIST
59876: LIST
59877: PUSH
59878: LD_INT 34
59880: PUSH
59881: LD_EXP 96
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: PUSH
59890: LD_INT 34
59892: PUSH
59893: LD_INT 32
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: LD_INT 34
59902: PUSH
59903: LD_INT 13
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: LD_INT 34
59912: PUSH
59913: LD_INT 52
59915: PUSH
59916: EMPTY
59917: LIST
59918: LIST
59919: PUSH
59920: LD_INT 34
59922: PUSH
59923: LD_INT 14
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: PUSH
59930: LD_INT 34
59932: PUSH
59933: LD_INT 53
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 34
59942: PUSH
59943: LD_EXP 95
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PUSH
59952: LD_INT 34
59954: PUSH
59955: LD_INT 31
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: PUSH
59962: LD_INT 34
59964: PUSH
59965: LD_INT 48
59967: PUSH
59968: EMPTY
59969: LIST
59970: LIST
59971: PUSH
59972: LD_INT 34
59974: PUSH
59975: LD_INT 8
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: PUSH
59982: EMPTY
59983: LIST
59984: LIST
59985: LIST
59986: LIST
59987: LIST
59988: LIST
59989: LIST
59990: LIST
59991: LIST
59992: LIST
59993: LIST
59994: LIST
59995: LIST
59996: PPUSH
59997: CALL_OW 72
60001: DIFF
60002: ST_TO_ADDR
// end ; end_of_file
60003: LD_VAR 0 3
60007: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60008: LD_INT 0
60010: PPUSH
60011: PPUSH
60012: PPUSH
// if not mc_bases or not skirmish then
60013: LD_EXP 102
60017: NOT
60018: PUSH
60019: LD_EXP 100
60023: NOT
60024: OR
60025: IFFALSE 60029
// exit ;
60027: GO 60194
// for i = 1 to mc_bases do
60029: LD_ADDR_VAR 0 4
60033: PUSH
60034: DOUBLE
60035: LD_INT 1
60037: DEC
60038: ST_TO_ADDR
60039: LD_EXP 102
60043: PUSH
60044: FOR_TO
60045: IFFALSE 60192
// begin if sci in mc_bases [ i ] then
60047: LD_VAR 0 2
60051: PUSH
60052: LD_EXP 102
60056: PUSH
60057: LD_VAR 0 4
60061: ARRAY
60062: IN
60063: IFFALSE 60190
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60065: LD_ADDR_EXP 131
60069: PUSH
60070: LD_EXP 131
60074: PPUSH
60075: LD_VAR 0 4
60079: PUSH
60080: LD_EXP 131
60084: PUSH
60085: LD_VAR 0 4
60089: ARRAY
60090: PUSH
60091: LD_INT 1
60093: PLUS
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: PPUSH
60099: LD_VAR 0 1
60103: PPUSH
60104: CALL 71978 0 3
60108: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60109: LD_ADDR_VAR 0 5
60113: PUSH
60114: LD_EXP 102
60118: PUSH
60119: LD_VAR 0 4
60123: ARRAY
60124: PPUSH
60125: LD_INT 2
60127: PUSH
60128: LD_INT 30
60130: PUSH
60131: LD_INT 0
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: PUSH
60138: LD_INT 30
60140: PUSH
60141: LD_INT 1
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: LIST
60152: PPUSH
60153: CALL_OW 72
60157: PPUSH
60158: LD_VAR 0 1
60162: PPUSH
60163: CALL_OW 74
60167: ST_TO_ADDR
// if tmp then
60168: LD_VAR 0 5
60172: IFFALSE 60188
// ComStandNearbyBuilding ( ape , tmp ) ;
60174: LD_VAR 0 1
60178: PPUSH
60179: LD_VAR 0 5
60183: PPUSH
60184: CALL 66181 0 2
// break ;
60188: GO 60192
// end ; end ;
60190: GO 60044
60192: POP
60193: POP
// end ;
60194: LD_VAR 0 3
60198: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60199: LD_INT 0
60201: PPUSH
60202: PPUSH
60203: PPUSH
// if not mc_bases or not skirmish then
60204: LD_EXP 102
60208: NOT
60209: PUSH
60210: LD_EXP 100
60214: NOT
60215: OR
60216: IFFALSE 60220
// exit ;
60218: GO 60309
// for i = 1 to mc_bases do
60220: LD_ADDR_VAR 0 4
60224: PUSH
60225: DOUBLE
60226: LD_INT 1
60228: DEC
60229: ST_TO_ADDR
60230: LD_EXP 102
60234: PUSH
60235: FOR_TO
60236: IFFALSE 60307
// begin if building in mc_busy_turret_list [ i ] then
60238: LD_VAR 0 1
60242: PUSH
60243: LD_EXP 112
60247: PUSH
60248: LD_VAR 0 4
60252: ARRAY
60253: IN
60254: IFFALSE 60305
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60256: LD_ADDR_VAR 0 5
60260: PUSH
60261: LD_EXP 112
60265: PUSH
60266: LD_VAR 0 4
60270: ARRAY
60271: PUSH
60272: LD_VAR 0 1
60276: DIFF
60277: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60278: LD_ADDR_EXP 112
60282: PUSH
60283: LD_EXP 112
60287: PPUSH
60288: LD_VAR 0 4
60292: PPUSH
60293: LD_VAR 0 5
60297: PPUSH
60298: CALL_OW 1
60302: ST_TO_ADDR
// break ;
60303: GO 60307
// end ; end ;
60305: GO 60235
60307: POP
60308: POP
// end ;
60309: LD_VAR 0 3
60313: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60314: LD_INT 0
60316: PPUSH
60317: PPUSH
60318: PPUSH
// if not mc_bases or not skirmish then
60319: LD_EXP 102
60323: NOT
60324: PUSH
60325: LD_EXP 100
60329: NOT
60330: OR
60331: IFFALSE 60335
// exit ;
60333: GO 60534
// for i = 1 to mc_bases do
60335: LD_ADDR_VAR 0 5
60339: PUSH
60340: DOUBLE
60341: LD_INT 1
60343: DEC
60344: ST_TO_ADDR
60345: LD_EXP 102
60349: PUSH
60350: FOR_TO
60351: IFFALSE 60532
// if building in mc_bases [ i ] then
60353: LD_VAR 0 1
60357: PUSH
60358: LD_EXP 102
60362: PUSH
60363: LD_VAR 0 5
60367: ARRAY
60368: IN
60369: IFFALSE 60530
// begin tmp := mc_bases [ i ] diff building ;
60371: LD_ADDR_VAR 0 6
60375: PUSH
60376: LD_EXP 102
60380: PUSH
60381: LD_VAR 0 5
60385: ARRAY
60386: PUSH
60387: LD_VAR 0 1
60391: DIFF
60392: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60393: LD_ADDR_EXP 102
60397: PUSH
60398: LD_EXP 102
60402: PPUSH
60403: LD_VAR 0 5
60407: PPUSH
60408: LD_VAR 0 6
60412: PPUSH
60413: CALL_OW 1
60417: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60418: LD_VAR 0 1
60422: PUSH
60423: LD_EXP 110
60427: PUSH
60428: LD_VAR 0 5
60432: ARRAY
60433: IN
60434: IFFALSE 60473
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60436: LD_ADDR_EXP 110
60440: PUSH
60441: LD_EXP 110
60445: PPUSH
60446: LD_VAR 0 5
60450: PPUSH
60451: LD_EXP 110
60455: PUSH
60456: LD_VAR 0 5
60460: ARRAY
60461: PUSH
60462: LD_VAR 0 1
60466: DIFF
60467: PPUSH
60468: CALL_OW 1
60472: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60473: LD_VAR 0 1
60477: PUSH
60478: LD_EXP 111
60482: PUSH
60483: LD_VAR 0 5
60487: ARRAY
60488: IN
60489: IFFALSE 60528
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60491: LD_ADDR_EXP 111
60495: PUSH
60496: LD_EXP 111
60500: PPUSH
60501: LD_VAR 0 5
60505: PPUSH
60506: LD_EXP 111
60510: PUSH
60511: LD_VAR 0 5
60515: ARRAY
60516: PUSH
60517: LD_VAR 0 1
60521: DIFF
60522: PPUSH
60523: CALL_OW 1
60527: ST_TO_ADDR
// break ;
60528: GO 60532
// end ;
60530: GO 60350
60532: POP
60533: POP
// end ;
60534: LD_VAR 0 4
60538: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60539: LD_INT 0
60541: PPUSH
60542: PPUSH
60543: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60544: LD_EXP 102
60548: NOT
60549: PUSH
60550: LD_EXP 100
60554: NOT
60555: OR
60556: PUSH
60557: LD_VAR 0 3
60561: PUSH
60562: LD_EXP 128
60566: IN
60567: NOT
60568: OR
60569: IFFALSE 60573
// exit ;
60571: GO 60696
// for i = 1 to mc_vehicles do
60573: LD_ADDR_VAR 0 6
60577: PUSH
60578: DOUBLE
60579: LD_INT 1
60581: DEC
60582: ST_TO_ADDR
60583: LD_EXP 121
60587: PUSH
60588: FOR_TO
60589: IFFALSE 60694
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60591: LD_VAR 0 2
60595: PUSH
60596: LD_EXP 121
60600: PUSH
60601: LD_VAR 0 6
60605: ARRAY
60606: IN
60607: PUSH
60608: LD_VAR 0 1
60612: PUSH
60613: LD_EXP 121
60617: PUSH
60618: LD_VAR 0 6
60622: ARRAY
60623: IN
60624: OR
60625: IFFALSE 60692
// begin tmp := mc_vehicles [ i ] diff old ;
60627: LD_ADDR_VAR 0 7
60631: PUSH
60632: LD_EXP 121
60636: PUSH
60637: LD_VAR 0 6
60641: ARRAY
60642: PUSH
60643: LD_VAR 0 2
60647: DIFF
60648: ST_TO_ADDR
// tmp := tmp diff new ;
60649: LD_ADDR_VAR 0 7
60653: PUSH
60654: LD_VAR 0 7
60658: PUSH
60659: LD_VAR 0 1
60663: DIFF
60664: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60665: LD_ADDR_EXP 121
60669: PUSH
60670: LD_EXP 121
60674: PPUSH
60675: LD_VAR 0 6
60679: PPUSH
60680: LD_VAR 0 7
60684: PPUSH
60685: CALL_OW 1
60689: ST_TO_ADDR
// break ;
60690: GO 60694
// end ;
60692: GO 60588
60694: POP
60695: POP
// end ;
60696: LD_VAR 0 5
60700: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60701: LD_INT 0
60703: PPUSH
60704: PPUSH
60705: PPUSH
60706: PPUSH
// if not mc_bases or not skirmish then
60707: LD_EXP 102
60711: NOT
60712: PUSH
60713: LD_EXP 100
60717: NOT
60718: OR
60719: IFFALSE 60723
// exit ;
60721: GO 61100
// side := GetSide ( vehicle ) ;
60723: LD_ADDR_VAR 0 5
60727: PUSH
60728: LD_VAR 0 1
60732: PPUSH
60733: CALL_OW 255
60737: ST_TO_ADDR
// for i = 1 to mc_bases do
60738: LD_ADDR_VAR 0 4
60742: PUSH
60743: DOUBLE
60744: LD_INT 1
60746: DEC
60747: ST_TO_ADDR
60748: LD_EXP 102
60752: PUSH
60753: FOR_TO
60754: IFFALSE 61098
// begin if factory in mc_bases [ i ] then
60756: LD_VAR 0 2
60760: PUSH
60761: LD_EXP 102
60765: PUSH
60766: LD_VAR 0 4
60770: ARRAY
60771: IN
60772: IFFALSE 61096
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60774: LD_EXP 124
60778: PUSH
60779: LD_VAR 0 4
60783: ARRAY
60784: PUSH
60785: LD_EXP 113
60789: PUSH
60790: LD_VAR 0 4
60794: ARRAY
60795: LESS
60796: PUSH
60797: LD_VAR 0 1
60801: PPUSH
60802: CALL_OW 264
60806: PUSH
60807: LD_INT 31
60809: PUSH
60810: LD_INT 32
60812: PUSH
60813: LD_INT 51
60815: PUSH
60816: LD_EXP 96
60820: PUSH
60821: LD_INT 12
60823: PUSH
60824: LD_INT 30
60826: PUSH
60827: LD_EXP 95
60831: PUSH
60832: LD_INT 11
60834: PUSH
60835: LD_INT 53
60837: PUSH
60838: LD_INT 14
60840: PUSH
60841: LD_EXP 99
60845: PUSH
60846: LD_INT 29
60848: PUSH
60849: LD_EXP 97
60853: PUSH
60854: LD_INT 13
60856: PUSH
60857: LD_INT 52
60859: PUSH
60860: LD_INT 48
60862: PUSH
60863: LD_INT 8
60865: PUSH
60866: EMPTY
60867: LIST
60868: LIST
60869: LIST
60870: LIST
60871: LIST
60872: LIST
60873: LIST
60874: LIST
60875: LIST
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: IN
60885: NOT
60886: AND
60887: IFFALSE 60935
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60889: LD_ADDR_EXP 124
60893: PUSH
60894: LD_EXP 124
60898: PPUSH
60899: LD_VAR 0 4
60903: PUSH
60904: LD_EXP 124
60908: PUSH
60909: LD_VAR 0 4
60913: ARRAY
60914: PUSH
60915: LD_INT 1
60917: PLUS
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PPUSH
60923: LD_VAR 0 1
60927: PPUSH
60928: CALL 71978 0 3
60932: ST_TO_ADDR
60933: GO 60979
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60935: LD_ADDR_EXP 121
60939: PUSH
60940: LD_EXP 121
60944: PPUSH
60945: LD_VAR 0 4
60949: PUSH
60950: LD_EXP 121
60954: PUSH
60955: LD_VAR 0 4
60959: ARRAY
60960: PUSH
60961: LD_INT 1
60963: PLUS
60964: PUSH
60965: EMPTY
60966: LIST
60967: LIST
60968: PPUSH
60969: LD_VAR 0 1
60973: PPUSH
60974: CALL 71978 0 3
60978: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60979: LD_VAR 0 1
60983: PPUSH
60984: CALL_OW 263
60988: PUSH
60989: LD_INT 2
60991: EQUAL
60992: IFFALSE 61012
// begin repeat wait ( 0 0$1 ) ;
60994: LD_INT 35
60996: PPUSH
60997: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61001: LD_VAR 0 1
61005: PPUSH
61006: CALL_OW 312
61010: IFFALSE 60994
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61012: LD_VAR 0 1
61016: PPUSH
61017: LD_EXP 126
61021: PUSH
61022: LD_VAR 0 4
61026: ARRAY
61027: PPUSH
61028: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61032: LD_VAR 0 1
61036: PPUSH
61037: CALL_OW 263
61041: PUSH
61042: LD_INT 1
61044: NONEQUAL
61045: IFFALSE 61049
// break ;
61047: GO 61098
// repeat wait ( 0 0$1 ) ;
61049: LD_INT 35
61051: PPUSH
61052: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61056: LD_VAR 0 1
61060: PPUSH
61061: LD_EXP 126
61065: PUSH
61066: LD_VAR 0 4
61070: ARRAY
61071: PPUSH
61072: CALL_OW 308
61076: IFFALSE 61049
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61078: LD_VAR 0 1
61082: PPUSH
61083: CALL_OW 311
61087: PPUSH
61088: CALL_OW 121
// exit ;
61092: POP
61093: POP
61094: GO 61100
// end ; end ;
61096: GO 60753
61098: POP
61099: POP
// end ;
61100: LD_VAR 0 3
61104: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61105: LD_INT 0
61107: PPUSH
61108: PPUSH
61109: PPUSH
61110: PPUSH
// if not mc_bases or not skirmish then
61111: LD_EXP 102
61115: NOT
61116: PUSH
61117: LD_EXP 100
61121: NOT
61122: OR
61123: IFFALSE 61127
// exit ;
61125: GO 61480
// repeat wait ( 0 0$1 ) ;
61127: LD_INT 35
61129: PPUSH
61130: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61134: LD_VAR 0 2
61138: PPUSH
61139: LD_VAR 0 3
61143: PPUSH
61144: CALL_OW 284
61148: IFFALSE 61127
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61150: LD_VAR 0 2
61154: PPUSH
61155: LD_VAR 0 3
61159: PPUSH
61160: CALL_OW 283
61164: PUSH
61165: LD_INT 4
61167: EQUAL
61168: IFFALSE 61172
// exit ;
61170: GO 61480
// for i = 1 to mc_bases do
61172: LD_ADDR_VAR 0 7
61176: PUSH
61177: DOUBLE
61178: LD_INT 1
61180: DEC
61181: ST_TO_ADDR
61182: LD_EXP 102
61186: PUSH
61187: FOR_TO
61188: IFFALSE 61478
// begin if mc_crates_area [ i ] then
61190: LD_EXP 120
61194: PUSH
61195: LD_VAR 0 7
61199: ARRAY
61200: IFFALSE 61311
// for j in mc_crates_area [ i ] do
61202: LD_ADDR_VAR 0 8
61206: PUSH
61207: LD_EXP 120
61211: PUSH
61212: LD_VAR 0 7
61216: ARRAY
61217: PUSH
61218: FOR_IN
61219: IFFALSE 61309
// if InArea ( x , y , j ) then
61221: LD_VAR 0 2
61225: PPUSH
61226: LD_VAR 0 3
61230: PPUSH
61231: LD_VAR 0 8
61235: PPUSH
61236: CALL_OW 309
61240: IFFALSE 61307
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61242: LD_ADDR_EXP 118
61246: PUSH
61247: LD_EXP 118
61251: PPUSH
61252: LD_VAR 0 7
61256: PUSH
61257: LD_EXP 118
61261: PUSH
61262: LD_VAR 0 7
61266: ARRAY
61267: PUSH
61268: LD_INT 1
61270: PLUS
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: PPUSH
61276: LD_VAR 0 4
61280: PUSH
61281: LD_VAR 0 2
61285: PUSH
61286: LD_VAR 0 3
61290: PUSH
61291: EMPTY
61292: LIST
61293: LIST
61294: LIST
61295: PPUSH
61296: CALL 71978 0 3
61300: ST_TO_ADDR
// exit ;
61301: POP
61302: POP
61303: POP
61304: POP
61305: GO 61480
// end ;
61307: GO 61218
61309: POP
61310: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61311: LD_ADDR_VAR 0 9
61315: PUSH
61316: LD_EXP 102
61320: PUSH
61321: LD_VAR 0 7
61325: ARRAY
61326: PPUSH
61327: LD_INT 2
61329: PUSH
61330: LD_INT 30
61332: PUSH
61333: LD_INT 0
61335: PUSH
61336: EMPTY
61337: LIST
61338: LIST
61339: PUSH
61340: LD_INT 30
61342: PUSH
61343: LD_INT 1
61345: PUSH
61346: EMPTY
61347: LIST
61348: LIST
61349: PUSH
61350: EMPTY
61351: LIST
61352: LIST
61353: LIST
61354: PPUSH
61355: CALL_OW 72
61359: ST_TO_ADDR
// if not depot then
61360: LD_VAR 0 9
61364: NOT
61365: IFFALSE 61369
// continue ;
61367: GO 61187
// for j in depot do
61369: LD_ADDR_VAR 0 8
61373: PUSH
61374: LD_VAR 0 9
61378: PUSH
61379: FOR_IN
61380: IFFALSE 61474
// if GetDistUnitXY ( j , x , y ) < 30 then
61382: LD_VAR 0 8
61386: PPUSH
61387: LD_VAR 0 2
61391: PPUSH
61392: LD_VAR 0 3
61396: PPUSH
61397: CALL_OW 297
61401: PUSH
61402: LD_INT 30
61404: LESS
61405: IFFALSE 61472
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61407: LD_ADDR_EXP 118
61411: PUSH
61412: LD_EXP 118
61416: PPUSH
61417: LD_VAR 0 7
61421: PUSH
61422: LD_EXP 118
61426: PUSH
61427: LD_VAR 0 7
61431: ARRAY
61432: PUSH
61433: LD_INT 1
61435: PLUS
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PPUSH
61441: LD_VAR 0 4
61445: PUSH
61446: LD_VAR 0 2
61450: PUSH
61451: LD_VAR 0 3
61455: PUSH
61456: EMPTY
61457: LIST
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL 71978 0 3
61465: ST_TO_ADDR
// exit ;
61466: POP
61467: POP
61468: POP
61469: POP
61470: GO 61480
// end ;
61472: GO 61379
61474: POP
61475: POP
// end ;
61476: GO 61187
61478: POP
61479: POP
// end ;
61480: LD_VAR 0 6
61484: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61485: LD_INT 0
61487: PPUSH
61488: PPUSH
61489: PPUSH
61490: PPUSH
// if not mc_bases or not skirmish then
61491: LD_EXP 102
61495: NOT
61496: PUSH
61497: LD_EXP 100
61501: NOT
61502: OR
61503: IFFALSE 61507
// exit ;
61505: GO 61784
// side := GetSide ( lab ) ;
61507: LD_ADDR_VAR 0 4
61511: PUSH
61512: LD_VAR 0 2
61516: PPUSH
61517: CALL_OW 255
61521: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61522: LD_VAR 0 4
61526: PUSH
61527: LD_EXP 128
61531: IN
61532: NOT
61533: PUSH
61534: LD_EXP 129
61538: NOT
61539: OR
61540: PUSH
61541: LD_EXP 102
61545: NOT
61546: OR
61547: IFFALSE 61551
// exit ;
61549: GO 61784
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61551: LD_ADDR_EXP 129
61555: PUSH
61556: LD_EXP 129
61560: PPUSH
61561: LD_VAR 0 4
61565: PPUSH
61566: LD_EXP 129
61570: PUSH
61571: LD_VAR 0 4
61575: ARRAY
61576: PUSH
61577: LD_VAR 0 1
61581: DIFF
61582: PPUSH
61583: CALL_OW 1
61587: ST_TO_ADDR
// for i = 1 to mc_bases do
61588: LD_ADDR_VAR 0 5
61592: PUSH
61593: DOUBLE
61594: LD_INT 1
61596: DEC
61597: ST_TO_ADDR
61598: LD_EXP 102
61602: PUSH
61603: FOR_TO
61604: IFFALSE 61782
// begin if lab in mc_bases [ i ] then
61606: LD_VAR 0 2
61610: PUSH
61611: LD_EXP 102
61615: PUSH
61616: LD_VAR 0 5
61620: ARRAY
61621: IN
61622: IFFALSE 61780
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61624: LD_VAR 0 1
61628: PUSH
61629: LD_INT 11
61631: PUSH
61632: LD_INT 4
61634: PUSH
61635: LD_INT 3
61637: PUSH
61638: LD_INT 2
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: LIST
61645: LIST
61646: IN
61647: PUSH
61648: LD_EXP 132
61652: PUSH
61653: LD_VAR 0 5
61657: ARRAY
61658: AND
61659: IFFALSE 61780
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61661: LD_ADDR_VAR 0 6
61665: PUSH
61666: LD_EXP 132
61670: PUSH
61671: LD_VAR 0 5
61675: ARRAY
61676: PUSH
61677: LD_INT 1
61679: ARRAY
61680: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61681: LD_ADDR_EXP 132
61685: PUSH
61686: LD_EXP 132
61690: PPUSH
61691: LD_VAR 0 5
61695: PPUSH
61696: EMPTY
61697: PPUSH
61698: CALL_OW 1
61702: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61703: LD_VAR 0 6
61707: PPUSH
61708: LD_INT 0
61710: PPUSH
61711: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61715: LD_VAR 0 6
61719: PPUSH
61720: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61724: LD_ADDR_EXP 131
61728: PUSH
61729: LD_EXP 131
61733: PPUSH
61734: LD_VAR 0 5
61738: PPUSH
61739: LD_EXP 131
61743: PUSH
61744: LD_VAR 0 5
61748: ARRAY
61749: PPUSH
61750: LD_INT 1
61752: PPUSH
61753: LD_VAR 0 6
61757: PPUSH
61758: CALL_OW 2
61762: PPUSH
61763: CALL_OW 1
61767: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61768: LD_VAR 0 5
61772: PPUSH
61773: LD_INT 112
61775: PPUSH
61776: CALL 38780 0 2
// end ; end ; end ;
61780: GO 61603
61782: POP
61783: POP
// end ;
61784: LD_VAR 0 3
61788: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61789: LD_INT 0
61791: PPUSH
61792: PPUSH
61793: PPUSH
61794: PPUSH
61795: PPUSH
61796: PPUSH
61797: PPUSH
61798: PPUSH
// if not mc_bases or not skirmish then
61799: LD_EXP 102
61803: NOT
61804: PUSH
61805: LD_EXP 100
61809: NOT
61810: OR
61811: IFFALSE 61815
// exit ;
61813: GO 63186
// for i = 1 to mc_bases do
61815: LD_ADDR_VAR 0 3
61819: PUSH
61820: DOUBLE
61821: LD_INT 1
61823: DEC
61824: ST_TO_ADDR
61825: LD_EXP 102
61829: PUSH
61830: FOR_TO
61831: IFFALSE 63184
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61833: LD_VAR 0 1
61837: PUSH
61838: LD_EXP 102
61842: PUSH
61843: LD_VAR 0 3
61847: ARRAY
61848: IN
61849: PUSH
61850: LD_VAR 0 1
61854: PUSH
61855: LD_EXP 109
61859: PUSH
61860: LD_VAR 0 3
61864: ARRAY
61865: IN
61866: OR
61867: PUSH
61868: LD_VAR 0 1
61872: PUSH
61873: LD_EXP 124
61877: PUSH
61878: LD_VAR 0 3
61882: ARRAY
61883: IN
61884: OR
61885: PUSH
61886: LD_VAR 0 1
61890: PUSH
61891: LD_EXP 121
61895: PUSH
61896: LD_VAR 0 3
61900: ARRAY
61901: IN
61902: OR
61903: PUSH
61904: LD_VAR 0 1
61908: PUSH
61909: LD_EXP 131
61913: PUSH
61914: LD_VAR 0 3
61918: ARRAY
61919: IN
61920: OR
61921: PUSH
61922: LD_VAR 0 1
61926: PUSH
61927: LD_EXP 132
61931: PUSH
61932: LD_VAR 0 3
61936: ARRAY
61937: IN
61938: OR
61939: IFFALSE 63182
// begin if un in mc_ape [ i ] then
61941: LD_VAR 0 1
61945: PUSH
61946: LD_EXP 131
61950: PUSH
61951: LD_VAR 0 3
61955: ARRAY
61956: IN
61957: IFFALSE 61996
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61959: LD_ADDR_EXP 131
61963: PUSH
61964: LD_EXP 131
61968: PPUSH
61969: LD_VAR 0 3
61973: PPUSH
61974: LD_EXP 131
61978: PUSH
61979: LD_VAR 0 3
61983: ARRAY
61984: PUSH
61985: LD_VAR 0 1
61989: DIFF
61990: PPUSH
61991: CALL_OW 1
61995: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61996: LD_VAR 0 1
62000: PUSH
62001: LD_EXP 132
62005: PUSH
62006: LD_VAR 0 3
62010: ARRAY
62011: IN
62012: IFFALSE 62036
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62014: LD_ADDR_EXP 132
62018: PUSH
62019: LD_EXP 132
62023: PPUSH
62024: LD_VAR 0 3
62028: PPUSH
62029: EMPTY
62030: PPUSH
62031: CALL_OW 1
62035: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62036: LD_VAR 0 1
62040: PPUSH
62041: CALL_OW 247
62045: PUSH
62046: LD_INT 2
62048: EQUAL
62049: PUSH
62050: LD_VAR 0 1
62054: PPUSH
62055: CALL_OW 110
62059: PUSH
62060: LD_INT 20
62062: EQUAL
62063: PUSH
62064: LD_VAR 0 1
62068: PUSH
62069: LD_EXP 124
62073: PUSH
62074: LD_VAR 0 3
62078: ARRAY
62079: IN
62080: OR
62081: PUSH
62082: LD_VAR 0 1
62086: PPUSH
62087: CALL_OW 264
62091: PUSH
62092: LD_INT 12
62094: PUSH
62095: LD_INT 51
62097: PUSH
62098: LD_EXP 96
62102: PUSH
62103: LD_INT 32
62105: PUSH
62106: LD_INT 13
62108: PUSH
62109: LD_INT 52
62111: PUSH
62112: LD_INT 31
62114: PUSH
62115: EMPTY
62116: LIST
62117: LIST
62118: LIST
62119: LIST
62120: LIST
62121: LIST
62122: LIST
62123: IN
62124: OR
62125: AND
62126: IFFALSE 62434
// begin if un in mc_defender [ i ] then
62128: LD_VAR 0 1
62132: PUSH
62133: LD_EXP 124
62137: PUSH
62138: LD_VAR 0 3
62142: ARRAY
62143: IN
62144: IFFALSE 62183
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62146: LD_ADDR_EXP 124
62150: PUSH
62151: LD_EXP 124
62155: PPUSH
62156: LD_VAR 0 3
62160: PPUSH
62161: LD_EXP 124
62165: PUSH
62166: LD_VAR 0 3
62170: ARRAY
62171: PUSH
62172: LD_VAR 0 1
62176: DIFF
62177: PPUSH
62178: CALL_OW 1
62182: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62183: LD_ADDR_VAR 0 8
62187: PUSH
62188: LD_VAR 0 3
62192: PPUSH
62193: LD_INT 3
62195: PPUSH
62196: CALL 58852 0 2
62200: ST_TO_ADDR
// if fac then
62201: LD_VAR 0 8
62205: IFFALSE 62434
// begin for j in fac do
62207: LD_ADDR_VAR 0 4
62211: PUSH
62212: LD_VAR 0 8
62216: PUSH
62217: FOR_IN
62218: IFFALSE 62432
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62220: LD_ADDR_VAR 0 9
62224: PUSH
62225: LD_VAR 0 8
62229: PPUSH
62230: LD_VAR 0 1
62234: PPUSH
62235: CALL_OW 265
62239: PPUSH
62240: LD_VAR 0 1
62244: PPUSH
62245: CALL_OW 262
62249: PPUSH
62250: LD_VAR 0 1
62254: PPUSH
62255: CALL_OW 263
62259: PPUSH
62260: LD_VAR 0 1
62264: PPUSH
62265: CALL_OW 264
62269: PPUSH
62270: CALL 69510 0 5
62274: ST_TO_ADDR
// if components then
62275: LD_VAR 0 9
62279: IFFALSE 62430
// begin if GetWeapon ( un ) = ar_control_tower then
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 264
62290: PUSH
62291: LD_INT 31
62293: EQUAL
62294: IFFALSE 62411
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62296: LD_VAR 0 1
62300: PPUSH
62301: CALL_OW 311
62305: PPUSH
62306: LD_INT 0
62308: PPUSH
62309: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62313: LD_ADDR_EXP 142
62317: PUSH
62318: LD_EXP 142
62322: PPUSH
62323: LD_VAR 0 3
62327: PPUSH
62328: LD_EXP 142
62332: PUSH
62333: LD_VAR 0 3
62337: ARRAY
62338: PUSH
62339: LD_VAR 0 1
62343: PPUSH
62344: CALL_OW 311
62348: DIFF
62349: PPUSH
62350: CALL_OW 1
62354: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62355: LD_ADDR_VAR 0 7
62359: PUSH
62360: LD_EXP 123
62364: PUSH
62365: LD_VAR 0 3
62369: ARRAY
62370: PPUSH
62371: LD_INT 1
62373: PPUSH
62374: LD_VAR 0 9
62378: PPUSH
62379: CALL_OW 2
62383: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62384: LD_ADDR_EXP 123
62388: PUSH
62389: LD_EXP 123
62393: PPUSH
62394: LD_VAR 0 3
62398: PPUSH
62399: LD_VAR 0 7
62403: PPUSH
62404: CALL_OW 1
62408: ST_TO_ADDR
// end else
62409: GO 62428
// MC_InsertProduceList ( i , [ components ] ) ;
62411: LD_VAR 0 3
62415: PPUSH
62416: LD_VAR 0 9
62420: PUSH
62421: EMPTY
62422: LIST
62423: PPUSH
62424: CALL 58397 0 2
// break ;
62428: GO 62432
// end ; end ;
62430: GO 62217
62432: POP
62433: POP
// end ; end ; if GetType ( un ) = unit_building then
62434: LD_VAR 0 1
62438: PPUSH
62439: CALL_OW 247
62443: PUSH
62444: LD_INT 3
62446: EQUAL
62447: IFFALSE 62850
// begin btype := GetBType ( un ) ;
62449: LD_ADDR_VAR 0 5
62453: PUSH
62454: LD_VAR 0 1
62458: PPUSH
62459: CALL_OW 266
62463: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62464: LD_VAR 0 5
62468: PUSH
62469: LD_INT 29
62471: PUSH
62472: LD_INT 30
62474: PUSH
62475: EMPTY
62476: LIST
62477: LIST
62478: IN
62479: IFFALSE 62552
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62481: LD_VAR 0 1
62485: PPUSH
62486: CALL_OW 250
62490: PPUSH
62491: LD_VAR 0 1
62495: PPUSH
62496: CALL_OW 251
62500: PPUSH
62501: LD_VAR 0 1
62505: PPUSH
62506: CALL_OW 255
62510: PPUSH
62511: CALL_OW 440
62515: NOT
62516: IFFALSE 62552
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62518: LD_VAR 0 1
62522: PPUSH
62523: CALL_OW 250
62527: PPUSH
62528: LD_VAR 0 1
62532: PPUSH
62533: CALL_OW 251
62537: PPUSH
62538: LD_VAR 0 1
62542: PPUSH
62543: CALL_OW 255
62547: PPUSH
62548: CALL_OW 441
// end ; if btype = b_warehouse then
62552: LD_VAR 0 5
62556: PUSH
62557: LD_INT 1
62559: EQUAL
62560: IFFALSE 62578
// begin btype := b_depot ;
62562: LD_ADDR_VAR 0 5
62566: PUSH
62567: LD_INT 0
62569: ST_TO_ADDR
// pos := 1 ;
62570: LD_ADDR_VAR 0 6
62574: PUSH
62575: LD_INT 1
62577: ST_TO_ADDR
// end ; if btype = b_factory then
62578: LD_VAR 0 5
62582: PUSH
62583: LD_INT 3
62585: EQUAL
62586: IFFALSE 62604
// begin btype := b_workshop ;
62588: LD_ADDR_VAR 0 5
62592: PUSH
62593: LD_INT 2
62595: ST_TO_ADDR
// pos := 1 ;
62596: LD_ADDR_VAR 0 6
62600: PUSH
62601: LD_INT 1
62603: ST_TO_ADDR
// end ; if btype = b_barracks then
62604: LD_VAR 0 5
62608: PUSH
62609: LD_INT 5
62611: EQUAL
62612: IFFALSE 62622
// btype := b_armoury ;
62614: LD_ADDR_VAR 0 5
62618: PUSH
62619: LD_INT 4
62621: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62622: LD_VAR 0 5
62626: PUSH
62627: LD_INT 7
62629: PUSH
62630: LD_INT 8
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: IN
62637: IFFALSE 62647
// btype := b_lab ;
62639: LD_ADDR_VAR 0 5
62643: PUSH
62644: LD_INT 6
62646: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62647: LD_ADDR_EXP 107
62651: PUSH
62652: LD_EXP 107
62656: PPUSH
62657: LD_VAR 0 3
62661: PUSH
62662: LD_EXP 107
62666: PUSH
62667: LD_VAR 0 3
62671: ARRAY
62672: PUSH
62673: LD_INT 1
62675: PLUS
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PPUSH
62681: LD_VAR 0 5
62685: PUSH
62686: LD_VAR 0 1
62690: PPUSH
62691: CALL_OW 250
62695: PUSH
62696: LD_VAR 0 1
62700: PPUSH
62701: CALL_OW 251
62705: PUSH
62706: LD_VAR 0 1
62710: PPUSH
62711: CALL_OW 254
62715: PUSH
62716: EMPTY
62717: LIST
62718: LIST
62719: LIST
62720: LIST
62721: PPUSH
62722: CALL 71978 0 3
62726: ST_TO_ADDR
// if pos = 1 then
62727: LD_VAR 0 6
62731: PUSH
62732: LD_INT 1
62734: EQUAL
62735: IFFALSE 62850
// begin tmp := mc_build_list [ i ] ;
62737: LD_ADDR_VAR 0 7
62741: PUSH
62742: LD_EXP 107
62746: PUSH
62747: LD_VAR 0 3
62751: ARRAY
62752: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62753: LD_VAR 0 7
62757: PPUSH
62758: LD_INT 2
62760: PUSH
62761: LD_INT 30
62763: PUSH
62764: LD_INT 0
62766: PUSH
62767: EMPTY
62768: LIST
62769: LIST
62770: PUSH
62771: LD_INT 30
62773: PUSH
62774: LD_INT 1
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: LIST
62785: PPUSH
62786: CALL_OW 72
62790: IFFALSE 62800
// pos := 2 ;
62792: LD_ADDR_VAR 0 6
62796: PUSH
62797: LD_INT 2
62799: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62800: LD_ADDR_VAR 0 7
62804: PUSH
62805: LD_VAR 0 7
62809: PPUSH
62810: LD_VAR 0 6
62814: PPUSH
62815: LD_VAR 0 7
62819: PPUSH
62820: CALL 72304 0 3
62824: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62825: LD_ADDR_EXP 107
62829: PUSH
62830: LD_EXP 107
62834: PPUSH
62835: LD_VAR 0 3
62839: PPUSH
62840: LD_VAR 0 7
62844: PPUSH
62845: CALL_OW 1
62849: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62850: LD_VAR 0 1
62854: PUSH
62855: LD_EXP 102
62859: PUSH
62860: LD_VAR 0 3
62864: ARRAY
62865: IN
62866: IFFALSE 62905
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62868: LD_ADDR_EXP 102
62872: PUSH
62873: LD_EXP 102
62877: PPUSH
62878: LD_VAR 0 3
62882: PPUSH
62883: LD_EXP 102
62887: PUSH
62888: LD_VAR 0 3
62892: ARRAY
62893: PUSH
62894: LD_VAR 0 1
62898: DIFF
62899: PPUSH
62900: CALL_OW 1
62904: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62905: LD_VAR 0 1
62909: PUSH
62910: LD_EXP 109
62914: PUSH
62915: LD_VAR 0 3
62919: ARRAY
62920: IN
62921: IFFALSE 62960
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62923: LD_ADDR_EXP 109
62927: PUSH
62928: LD_EXP 109
62932: PPUSH
62933: LD_VAR 0 3
62937: PPUSH
62938: LD_EXP 109
62942: PUSH
62943: LD_VAR 0 3
62947: ARRAY
62948: PUSH
62949: LD_VAR 0 1
62953: DIFF
62954: PPUSH
62955: CALL_OW 1
62959: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62960: LD_VAR 0 1
62964: PUSH
62965: LD_EXP 121
62969: PUSH
62970: LD_VAR 0 3
62974: ARRAY
62975: IN
62976: IFFALSE 63015
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62978: LD_ADDR_EXP 121
62982: PUSH
62983: LD_EXP 121
62987: PPUSH
62988: LD_VAR 0 3
62992: PPUSH
62993: LD_EXP 121
62997: PUSH
62998: LD_VAR 0 3
63002: ARRAY
63003: PUSH
63004: LD_VAR 0 1
63008: DIFF
63009: PPUSH
63010: CALL_OW 1
63014: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63015: LD_VAR 0 1
63019: PUSH
63020: LD_EXP 124
63024: PUSH
63025: LD_VAR 0 3
63029: ARRAY
63030: IN
63031: IFFALSE 63070
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63033: LD_ADDR_EXP 124
63037: PUSH
63038: LD_EXP 124
63042: PPUSH
63043: LD_VAR 0 3
63047: PPUSH
63048: LD_EXP 124
63052: PUSH
63053: LD_VAR 0 3
63057: ARRAY
63058: PUSH
63059: LD_VAR 0 1
63063: DIFF
63064: PPUSH
63065: CALL_OW 1
63069: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63070: LD_VAR 0 1
63074: PUSH
63075: LD_EXP 111
63079: PUSH
63080: LD_VAR 0 3
63084: ARRAY
63085: IN
63086: IFFALSE 63125
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63088: LD_ADDR_EXP 111
63092: PUSH
63093: LD_EXP 111
63097: PPUSH
63098: LD_VAR 0 3
63102: PPUSH
63103: LD_EXP 111
63107: PUSH
63108: LD_VAR 0 3
63112: ARRAY
63113: PUSH
63114: LD_VAR 0 1
63118: DIFF
63119: PPUSH
63120: CALL_OW 1
63124: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63125: LD_VAR 0 1
63129: PUSH
63130: LD_EXP 110
63134: PUSH
63135: LD_VAR 0 3
63139: ARRAY
63140: IN
63141: IFFALSE 63180
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63143: LD_ADDR_EXP 110
63147: PUSH
63148: LD_EXP 110
63152: PPUSH
63153: LD_VAR 0 3
63157: PPUSH
63158: LD_EXP 110
63162: PUSH
63163: LD_VAR 0 3
63167: ARRAY
63168: PUSH
63169: LD_VAR 0 1
63173: DIFF
63174: PPUSH
63175: CALL_OW 1
63179: ST_TO_ADDR
// end ; break ;
63180: GO 63184
// end ;
63182: GO 61830
63184: POP
63185: POP
// end ;
63186: LD_VAR 0 2
63190: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63191: LD_INT 0
63193: PPUSH
63194: PPUSH
63195: PPUSH
// if not mc_bases or not skirmish then
63196: LD_EXP 102
63200: NOT
63201: PUSH
63202: LD_EXP 100
63206: NOT
63207: OR
63208: IFFALSE 63212
// exit ;
63210: GO 63427
// for i = 1 to mc_bases do
63212: LD_ADDR_VAR 0 3
63216: PUSH
63217: DOUBLE
63218: LD_INT 1
63220: DEC
63221: ST_TO_ADDR
63222: LD_EXP 102
63226: PUSH
63227: FOR_TO
63228: IFFALSE 63425
// begin if building in mc_construct_list [ i ] then
63230: LD_VAR 0 1
63234: PUSH
63235: LD_EXP 109
63239: PUSH
63240: LD_VAR 0 3
63244: ARRAY
63245: IN
63246: IFFALSE 63423
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63248: LD_ADDR_EXP 109
63252: PUSH
63253: LD_EXP 109
63257: PPUSH
63258: LD_VAR 0 3
63262: PPUSH
63263: LD_EXP 109
63267: PUSH
63268: LD_VAR 0 3
63272: ARRAY
63273: PUSH
63274: LD_VAR 0 1
63278: DIFF
63279: PPUSH
63280: CALL_OW 1
63284: ST_TO_ADDR
// if building in mc_lab [ i ] then
63285: LD_VAR 0 1
63289: PUSH
63290: LD_EXP 135
63294: PUSH
63295: LD_VAR 0 3
63299: ARRAY
63300: IN
63301: IFFALSE 63356
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63303: LD_ADDR_EXP 136
63307: PUSH
63308: LD_EXP 136
63312: PPUSH
63313: LD_VAR 0 3
63317: PPUSH
63318: LD_EXP 136
63322: PUSH
63323: LD_VAR 0 3
63327: ARRAY
63328: PPUSH
63329: LD_INT 1
63331: PPUSH
63332: LD_EXP 136
63336: PUSH
63337: LD_VAR 0 3
63341: ARRAY
63342: PPUSH
63343: LD_INT 0
63345: PPUSH
63346: CALL 71396 0 4
63350: PPUSH
63351: CALL_OW 1
63355: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63356: LD_VAR 0 1
63360: PUSH
63361: LD_EXP 102
63365: PUSH
63366: LD_VAR 0 3
63370: ARRAY
63371: IN
63372: NOT
63373: IFFALSE 63419
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63375: LD_ADDR_EXP 102
63379: PUSH
63380: LD_EXP 102
63384: PPUSH
63385: LD_VAR 0 3
63389: PUSH
63390: LD_EXP 102
63394: PUSH
63395: LD_VAR 0 3
63399: ARRAY
63400: PUSH
63401: LD_INT 1
63403: PLUS
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PPUSH
63409: LD_VAR 0 1
63413: PPUSH
63414: CALL 71978 0 3
63418: ST_TO_ADDR
// exit ;
63419: POP
63420: POP
63421: GO 63427
// end ; end ;
63423: GO 63227
63425: POP
63426: POP
// end ;
63427: LD_VAR 0 2
63431: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63432: LD_INT 0
63434: PPUSH
63435: PPUSH
63436: PPUSH
63437: PPUSH
63438: PPUSH
63439: PPUSH
63440: PPUSH
// if not mc_bases or not skirmish then
63441: LD_EXP 102
63445: NOT
63446: PUSH
63447: LD_EXP 100
63451: NOT
63452: OR
63453: IFFALSE 63457
// exit ;
63455: GO 64118
// for i = 1 to mc_bases do
63457: LD_ADDR_VAR 0 3
63461: PUSH
63462: DOUBLE
63463: LD_INT 1
63465: DEC
63466: ST_TO_ADDR
63467: LD_EXP 102
63471: PUSH
63472: FOR_TO
63473: IFFALSE 64116
// begin if building in mc_construct_list [ i ] then
63475: LD_VAR 0 1
63479: PUSH
63480: LD_EXP 109
63484: PUSH
63485: LD_VAR 0 3
63489: ARRAY
63490: IN
63491: IFFALSE 64114
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63493: LD_ADDR_EXP 109
63497: PUSH
63498: LD_EXP 109
63502: PPUSH
63503: LD_VAR 0 3
63507: PPUSH
63508: LD_EXP 109
63512: PUSH
63513: LD_VAR 0 3
63517: ARRAY
63518: PUSH
63519: LD_VAR 0 1
63523: DIFF
63524: PPUSH
63525: CALL_OW 1
63529: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63530: LD_ADDR_EXP 102
63534: PUSH
63535: LD_EXP 102
63539: PPUSH
63540: LD_VAR 0 3
63544: PUSH
63545: LD_EXP 102
63549: PUSH
63550: LD_VAR 0 3
63554: ARRAY
63555: PUSH
63556: LD_INT 1
63558: PLUS
63559: PUSH
63560: EMPTY
63561: LIST
63562: LIST
63563: PPUSH
63564: LD_VAR 0 1
63568: PPUSH
63569: CALL 71978 0 3
63573: ST_TO_ADDR
// btype := GetBType ( building ) ;
63574: LD_ADDR_VAR 0 5
63578: PUSH
63579: LD_VAR 0 1
63583: PPUSH
63584: CALL_OW 266
63588: ST_TO_ADDR
// side := GetSide ( building ) ;
63589: LD_ADDR_VAR 0 8
63593: PUSH
63594: LD_VAR 0 1
63598: PPUSH
63599: CALL_OW 255
63603: ST_TO_ADDR
// if btype = b_lab then
63604: LD_VAR 0 5
63608: PUSH
63609: LD_INT 6
63611: EQUAL
63612: IFFALSE 63662
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63614: LD_ADDR_EXP 135
63618: PUSH
63619: LD_EXP 135
63623: PPUSH
63624: LD_VAR 0 3
63628: PUSH
63629: LD_EXP 135
63633: PUSH
63634: LD_VAR 0 3
63638: ARRAY
63639: PUSH
63640: LD_INT 1
63642: PLUS
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL 71978 0 3
63657: ST_TO_ADDR
// exit ;
63658: POP
63659: POP
63660: GO 64118
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63662: LD_VAR 0 5
63666: PUSH
63667: LD_INT 0
63669: PUSH
63670: LD_INT 2
63672: PUSH
63673: LD_INT 4
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: LIST
63680: IN
63681: IFFALSE 63805
// begin if btype = b_armoury then
63683: LD_VAR 0 5
63687: PUSH
63688: LD_INT 4
63690: EQUAL
63691: IFFALSE 63701
// btype := b_barracks ;
63693: LD_ADDR_VAR 0 5
63697: PUSH
63698: LD_INT 5
63700: ST_TO_ADDR
// if btype = b_depot then
63701: LD_VAR 0 5
63705: PUSH
63706: LD_INT 0
63708: EQUAL
63709: IFFALSE 63719
// btype := b_warehouse ;
63711: LD_ADDR_VAR 0 5
63715: PUSH
63716: LD_INT 1
63718: ST_TO_ADDR
// if btype = b_workshop then
63719: LD_VAR 0 5
63723: PUSH
63724: LD_INT 2
63726: EQUAL
63727: IFFALSE 63737
// btype := b_factory ;
63729: LD_ADDR_VAR 0 5
63733: PUSH
63734: LD_INT 3
63736: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63737: LD_VAR 0 5
63741: PPUSH
63742: LD_VAR 0 8
63746: PPUSH
63747: CALL_OW 323
63751: PUSH
63752: LD_INT 1
63754: EQUAL
63755: IFFALSE 63801
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63757: LD_ADDR_EXP 134
63761: PUSH
63762: LD_EXP 134
63766: PPUSH
63767: LD_VAR 0 3
63771: PUSH
63772: LD_EXP 134
63776: PUSH
63777: LD_VAR 0 3
63781: ARRAY
63782: PUSH
63783: LD_INT 1
63785: PLUS
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PPUSH
63791: LD_VAR 0 1
63795: PPUSH
63796: CALL 71978 0 3
63800: ST_TO_ADDR
// exit ;
63801: POP
63802: POP
63803: GO 64118
// end ; if btype in [ b_bunker , b_turret ] then
63805: LD_VAR 0 5
63809: PUSH
63810: LD_INT 32
63812: PUSH
63813: LD_INT 33
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: IN
63820: IFFALSE 64110
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63822: LD_ADDR_EXP 110
63826: PUSH
63827: LD_EXP 110
63831: PPUSH
63832: LD_VAR 0 3
63836: PUSH
63837: LD_EXP 110
63841: PUSH
63842: LD_VAR 0 3
63846: ARRAY
63847: PUSH
63848: LD_INT 1
63850: PLUS
63851: PUSH
63852: EMPTY
63853: LIST
63854: LIST
63855: PPUSH
63856: LD_VAR 0 1
63860: PPUSH
63861: CALL 71978 0 3
63865: ST_TO_ADDR
// if btype = b_bunker then
63866: LD_VAR 0 5
63870: PUSH
63871: LD_INT 32
63873: EQUAL
63874: IFFALSE 64110
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63876: LD_ADDR_EXP 111
63880: PUSH
63881: LD_EXP 111
63885: PPUSH
63886: LD_VAR 0 3
63890: PUSH
63891: LD_EXP 111
63895: PUSH
63896: LD_VAR 0 3
63900: ARRAY
63901: PUSH
63902: LD_INT 1
63904: PLUS
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PPUSH
63910: LD_VAR 0 1
63914: PPUSH
63915: CALL 71978 0 3
63919: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63920: LD_ADDR_VAR 0 6
63924: PUSH
63925: LD_EXP 102
63929: PUSH
63930: LD_VAR 0 3
63934: ARRAY
63935: PPUSH
63936: LD_INT 25
63938: PUSH
63939: LD_INT 1
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: PUSH
63946: LD_INT 3
63948: PUSH
63949: LD_INT 54
63951: PUSH
63952: EMPTY
63953: LIST
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PPUSH
63963: CALL_OW 72
63967: ST_TO_ADDR
// if tmp then
63968: LD_VAR 0 6
63972: IFFALSE 63978
// exit ;
63974: POP
63975: POP
63976: GO 64118
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63978: LD_ADDR_VAR 0 6
63982: PUSH
63983: LD_EXP 102
63987: PUSH
63988: LD_VAR 0 3
63992: ARRAY
63993: PPUSH
63994: LD_INT 2
63996: PUSH
63997: LD_INT 30
63999: PUSH
64000: LD_INT 4
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 30
64009: PUSH
64010: LD_INT 5
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: LIST
64021: PPUSH
64022: CALL_OW 72
64026: ST_TO_ADDR
// if not tmp then
64027: LD_VAR 0 6
64031: NOT
64032: IFFALSE 64038
// exit ;
64034: POP
64035: POP
64036: GO 64118
// for j in tmp do
64038: LD_ADDR_VAR 0 4
64042: PUSH
64043: LD_VAR 0 6
64047: PUSH
64048: FOR_IN
64049: IFFALSE 64108
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64051: LD_ADDR_VAR 0 7
64055: PUSH
64056: LD_VAR 0 4
64060: PPUSH
64061: CALL_OW 313
64065: PPUSH
64066: LD_INT 25
64068: PUSH
64069: LD_INT 1
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PPUSH
64076: CALL_OW 72
64080: ST_TO_ADDR
// if units then
64081: LD_VAR 0 7
64085: IFFALSE 64106
// begin ComExitBuilding ( units [ 1 ] ) ;
64087: LD_VAR 0 7
64091: PUSH
64092: LD_INT 1
64094: ARRAY
64095: PPUSH
64096: CALL_OW 122
// exit ;
64100: POP
64101: POP
64102: POP
64103: POP
64104: GO 64118
// end ; end ;
64106: GO 64048
64108: POP
64109: POP
// end ; end ; exit ;
64110: POP
64111: POP
64112: GO 64118
// end ; end ;
64114: GO 63472
64116: POP
64117: POP
// end ;
64118: LD_VAR 0 2
64122: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64123: LD_INT 0
64125: PPUSH
64126: PPUSH
64127: PPUSH
64128: PPUSH
64129: PPUSH
64130: PPUSH
64131: PPUSH
// if not mc_bases or not skirmish then
64132: LD_EXP 102
64136: NOT
64137: PUSH
64138: LD_EXP 100
64142: NOT
64143: OR
64144: IFFALSE 64148
// exit ;
64146: GO 64379
// btype := GetBType ( building ) ;
64148: LD_ADDR_VAR 0 6
64152: PUSH
64153: LD_VAR 0 1
64157: PPUSH
64158: CALL_OW 266
64162: ST_TO_ADDR
// x := GetX ( building ) ;
64163: LD_ADDR_VAR 0 7
64167: PUSH
64168: LD_VAR 0 1
64172: PPUSH
64173: CALL_OW 250
64177: ST_TO_ADDR
// y := GetY ( building ) ;
64178: LD_ADDR_VAR 0 8
64182: PUSH
64183: LD_VAR 0 1
64187: PPUSH
64188: CALL_OW 251
64192: ST_TO_ADDR
// d := GetDir ( building ) ;
64193: LD_ADDR_VAR 0 9
64197: PUSH
64198: LD_VAR 0 1
64202: PPUSH
64203: CALL_OW 254
64207: ST_TO_ADDR
// for i = 1 to mc_bases do
64208: LD_ADDR_VAR 0 4
64212: PUSH
64213: DOUBLE
64214: LD_INT 1
64216: DEC
64217: ST_TO_ADDR
64218: LD_EXP 102
64222: PUSH
64223: FOR_TO
64224: IFFALSE 64377
// begin if not mc_build_list [ i ] then
64226: LD_EXP 107
64230: PUSH
64231: LD_VAR 0 4
64235: ARRAY
64236: NOT
64237: IFFALSE 64241
// continue ;
64239: GO 64223
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64241: LD_VAR 0 6
64245: PUSH
64246: LD_VAR 0 7
64250: PUSH
64251: LD_VAR 0 8
64255: PUSH
64256: LD_VAR 0 9
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: LIST
64265: LIST
64266: PPUSH
64267: LD_EXP 107
64271: PUSH
64272: LD_VAR 0 4
64276: ARRAY
64277: PUSH
64278: LD_INT 1
64280: ARRAY
64281: PPUSH
64282: CALL 78147 0 2
64286: IFFALSE 64375
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64288: LD_ADDR_EXP 107
64292: PUSH
64293: LD_EXP 107
64297: PPUSH
64298: LD_VAR 0 4
64302: PPUSH
64303: LD_EXP 107
64307: PUSH
64308: LD_VAR 0 4
64312: ARRAY
64313: PPUSH
64314: LD_INT 1
64316: PPUSH
64317: CALL_OW 3
64321: PPUSH
64322: CALL_OW 1
64326: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64327: LD_ADDR_EXP 109
64331: PUSH
64332: LD_EXP 109
64336: PPUSH
64337: LD_VAR 0 4
64341: PUSH
64342: LD_EXP 109
64346: PUSH
64347: LD_VAR 0 4
64351: ARRAY
64352: PUSH
64353: LD_INT 1
64355: PLUS
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PPUSH
64361: LD_VAR 0 1
64365: PPUSH
64366: CALL 71978 0 3
64370: ST_TO_ADDR
// exit ;
64371: POP
64372: POP
64373: GO 64379
// end ; end ;
64375: GO 64223
64377: POP
64378: POP
// end ;
64379: LD_VAR 0 3
64383: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64384: LD_INT 0
64386: PPUSH
64387: PPUSH
64388: PPUSH
// if not mc_bases or not skirmish then
64389: LD_EXP 102
64393: NOT
64394: PUSH
64395: LD_EXP 100
64399: NOT
64400: OR
64401: IFFALSE 64405
// exit ;
64403: GO 64595
// for i = 1 to mc_bases do
64405: LD_ADDR_VAR 0 4
64409: PUSH
64410: DOUBLE
64411: LD_INT 1
64413: DEC
64414: ST_TO_ADDR
64415: LD_EXP 102
64419: PUSH
64420: FOR_TO
64421: IFFALSE 64508
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64423: LD_VAR 0 1
64427: PUSH
64428: LD_EXP 110
64432: PUSH
64433: LD_VAR 0 4
64437: ARRAY
64438: IN
64439: PUSH
64440: LD_VAR 0 1
64444: PUSH
64445: LD_EXP 111
64449: PUSH
64450: LD_VAR 0 4
64454: ARRAY
64455: IN
64456: NOT
64457: AND
64458: IFFALSE 64506
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64460: LD_ADDR_EXP 111
64464: PUSH
64465: LD_EXP 111
64469: PPUSH
64470: LD_VAR 0 4
64474: PUSH
64475: LD_EXP 111
64479: PUSH
64480: LD_VAR 0 4
64484: ARRAY
64485: PUSH
64486: LD_INT 1
64488: PLUS
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PPUSH
64494: LD_VAR 0 1
64498: PPUSH
64499: CALL 71978 0 3
64503: ST_TO_ADDR
// break ;
64504: GO 64508
// end ; end ;
64506: GO 64420
64508: POP
64509: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64510: LD_VAR 0 1
64514: PPUSH
64515: CALL_OW 257
64519: PUSH
64520: LD_EXP 128
64524: IN
64525: PUSH
64526: LD_VAR 0 1
64530: PPUSH
64531: CALL_OW 266
64535: PUSH
64536: LD_INT 5
64538: EQUAL
64539: AND
64540: PUSH
64541: LD_VAR 0 2
64545: PPUSH
64546: CALL_OW 110
64550: PUSH
64551: LD_INT 18
64553: NONEQUAL
64554: AND
64555: IFFALSE 64595
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64557: LD_VAR 0 2
64561: PPUSH
64562: CALL_OW 257
64566: PUSH
64567: LD_INT 5
64569: PUSH
64570: LD_INT 8
64572: PUSH
64573: LD_INT 9
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: LIST
64580: IN
64581: IFFALSE 64595
// SetClass ( unit , 1 ) ;
64583: LD_VAR 0 2
64587: PPUSH
64588: LD_INT 1
64590: PPUSH
64591: CALL_OW 336
// end ;
64595: LD_VAR 0 3
64599: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64600: LD_INT 0
64602: PPUSH
64603: PPUSH
// if not mc_bases or not skirmish then
64604: LD_EXP 102
64608: NOT
64609: PUSH
64610: LD_EXP 100
64614: NOT
64615: OR
64616: IFFALSE 64620
// exit ;
64618: GO 64736
// if GetLives ( abandoned_vehicle ) > 250 then
64620: LD_VAR 0 2
64624: PPUSH
64625: CALL_OW 256
64629: PUSH
64630: LD_INT 250
64632: GREATER
64633: IFFALSE 64637
// exit ;
64635: GO 64736
// for i = 1 to mc_bases do
64637: LD_ADDR_VAR 0 6
64641: PUSH
64642: DOUBLE
64643: LD_INT 1
64645: DEC
64646: ST_TO_ADDR
64647: LD_EXP 102
64651: PUSH
64652: FOR_TO
64653: IFFALSE 64734
// begin if driver in mc_bases [ i ] then
64655: LD_VAR 0 1
64659: PUSH
64660: LD_EXP 102
64664: PUSH
64665: LD_VAR 0 6
64669: ARRAY
64670: IN
64671: IFFALSE 64732
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64673: LD_VAR 0 1
64677: PPUSH
64678: LD_EXP 102
64682: PUSH
64683: LD_VAR 0 6
64687: ARRAY
64688: PPUSH
64689: LD_INT 2
64691: PUSH
64692: LD_INT 30
64694: PUSH
64695: LD_INT 0
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: PUSH
64702: LD_INT 30
64704: PUSH
64705: LD_INT 1
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: LIST
64716: PPUSH
64717: CALL_OW 72
64721: PUSH
64722: LD_INT 1
64724: ARRAY
64725: PPUSH
64726: CALL_OW 112
// break ;
64730: GO 64734
// end ; end ;
64732: GO 64652
64734: POP
64735: POP
// end ; end_of_file
64736: LD_VAR 0 5
64740: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64741: LD_INT 0
64743: PPUSH
64744: PPUSH
// if exist_mode then
64745: LD_VAR 0 2
64749: IFFALSE 64774
// unit := CreateCharacter ( prefix & ident ) else
64751: LD_ADDR_VAR 0 5
64755: PUSH
64756: LD_VAR 0 3
64760: PUSH
64761: LD_VAR 0 1
64765: STR
64766: PPUSH
64767: CALL_OW 34
64771: ST_TO_ADDR
64772: GO 64789
// unit := NewCharacter ( ident ) ;
64774: LD_ADDR_VAR 0 5
64778: PUSH
64779: LD_VAR 0 1
64783: PPUSH
64784: CALL_OW 25
64788: ST_TO_ADDR
// result := unit ;
64789: LD_ADDR_VAR 0 4
64793: PUSH
64794: LD_VAR 0 5
64798: ST_TO_ADDR
// end ;
64799: LD_VAR 0 4
64803: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64804: LD_INT 0
64806: PPUSH
64807: PPUSH
// if not side or not nation then
64808: LD_VAR 0 1
64812: NOT
64813: PUSH
64814: LD_VAR 0 2
64818: NOT
64819: OR
64820: IFFALSE 64824
// exit ;
64822: GO 65468
// case nation of nation_american :
64824: LD_VAR 0 2
64828: PUSH
64829: LD_INT 1
64831: DOUBLE
64832: EQUAL
64833: IFTRUE 64837
64835: GO 65011
64837: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64838: LD_ADDR_VAR 0 4
64842: PUSH
64843: LD_INT 35
64845: PUSH
64846: LD_INT 45
64848: PUSH
64849: LD_INT 46
64851: PUSH
64852: LD_INT 47
64854: PUSH
64855: LD_INT 1
64857: PUSH
64858: LD_INT 2
64860: PUSH
64861: LD_INT 6
64863: PUSH
64864: LD_INT 15
64866: PUSH
64867: LD_INT 16
64869: PUSH
64870: LD_INT 7
64872: PUSH
64873: LD_INT 12
64875: PUSH
64876: LD_INT 13
64878: PUSH
64879: LD_INT 10
64881: PUSH
64882: LD_INT 14
64884: PUSH
64885: LD_INT 20
64887: PUSH
64888: LD_INT 21
64890: PUSH
64891: LD_INT 22
64893: PUSH
64894: LD_INT 25
64896: PUSH
64897: LD_INT 32
64899: PUSH
64900: LD_INT 27
64902: PUSH
64903: LD_INT 36
64905: PUSH
64906: LD_INT 69
64908: PUSH
64909: LD_INT 39
64911: PUSH
64912: LD_INT 34
64914: PUSH
64915: LD_INT 40
64917: PUSH
64918: LD_INT 48
64920: PUSH
64921: LD_INT 49
64923: PUSH
64924: LD_INT 50
64926: PUSH
64927: LD_INT 51
64929: PUSH
64930: LD_INT 52
64932: PUSH
64933: LD_INT 53
64935: PUSH
64936: LD_INT 54
64938: PUSH
64939: LD_INT 55
64941: PUSH
64942: LD_INT 56
64944: PUSH
64945: LD_INT 57
64947: PUSH
64948: LD_INT 58
64950: PUSH
64951: LD_INT 59
64953: PUSH
64954: LD_INT 60
64956: PUSH
64957: LD_INT 61
64959: PUSH
64960: LD_INT 62
64962: PUSH
64963: LD_INT 80
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: ST_TO_ADDR
65009: GO 65392
65011: LD_INT 2
65013: DOUBLE
65014: EQUAL
65015: IFTRUE 65019
65017: GO 65201
65019: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65020: LD_ADDR_VAR 0 4
65024: PUSH
65025: LD_INT 35
65027: PUSH
65028: LD_INT 45
65030: PUSH
65031: LD_INT 46
65033: PUSH
65034: LD_INT 47
65036: PUSH
65037: LD_INT 70
65039: PUSH
65040: LD_INT 1
65042: PUSH
65043: LD_INT 11
65045: PUSH
65046: LD_INT 3
65048: PUSH
65049: LD_INT 4
65051: PUSH
65052: LD_INT 5
65054: PUSH
65055: LD_INT 6
65057: PUSH
65058: LD_INT 15
65060: PUSH
65061: LD_INT 18
65063: PUSH
65064: LD_INT 7
65066: PUSH
65067: LD_INT 17
65069: PUSH
65070: LD_INT 8
65072: PUSH
65073: LD_INT 20
65075: PUSH
65076: LD_INT 21
65078: PUSH
65079: LD_INT 22
65081: PUSH
65082: LD_INT 72
65084: PUSH
65085: LD_INT 26
65087: PUSH
65088: LD_INT 69
65090: PUSH
65091: LD_INT 39
65093: PUSH
65094: LD_INT 40
65096: PUSH
65097: LD_INT 41
65099: PUSH
65100: LD_INT 42
65102: PUSH
65103: LD_INT 43
65105: PUSH
65106: LD_INT 48
65108: PUSH
65109: LD_INT 49
65111: PUSH
65112: LD_INT 50
65114: PUSH
65115: LD_INT 51
65117: PUSH
65118: LD_INT 52
65120: PUSH
65121: LD_INT 53
65123: PUSH
65124: LD_INT 54
65126: PUSH
65127: LD_INT 55
65129: PUSH
65130: LD_INT 56
65132: PUSH
65133: LD_INT 60
65135: PUSH
65136: LD_INT 61
65138: PUSH
65139: LD_INT 62
65141: PUSH
65142: LD_INT 66
65144: PUSH
65145: LD_INT 67
65147: PUSH
65148: LD_INT 68
65150: PUSH
65151: LD_INT 81
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: LIST
65185: LIST
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: ST_TO_ADDR
65199: GO 65392
65201: LD_INT 3
65203: DOUBLE
65204: EQUAL
65205: IFTRUE 65209
65207: GO 65391
65209: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65210: LD_ADDR_VAR 0 4
65214: PUSH
65215: LD_INT 46
65217: PUSH
65218: LD_INT 47
65220: PUSH
65221: LD_INT 1
65223: PUSH
65224: LD_INT 2
65226: PUSH
65227: LD_INT 11
65229: PUSH
65230: LD_INT 9
65232: PUSH
65233: LD_INT 20
65235: PUSH
65236: LD_INT 19
65238: PUSH
65239: LD_INT 21
65241: PUSH
65242: LD_INT 24
65244: PUSH
65245: LD_INT 22
65247: PUSH
65248: LD_INT 25
65250: PUSH
65251: LD_INT 28
65253: PUSH
65254: LD_INT 29
65256: PUSH
65257: LD_INT 30
65259: PUSH
65260: LD_INT 31
65262: PUSH
65263: LD_INT 37
65265: PUSH
65266: LD_INT 38
65268: PUSH
65269: LD_INT 32
65271: PUSH
65272: LD_INT 27
65274: PUSH
65275: LD_INT 33
65277: PUSH
65278: LD_INT 69
65280: PUSH
65281: LD_INT 39
65283: PUSH
65284: LD_INT 34
65286: PUSH
65287: LD_INT 40
65289: PUSH
65290: LD_INT 71
65292: PUSH
65293: LD_INT 23
65295: PUSH
65296: LD_INT 44
65298: PUSH
65299: LD_INT 48
65301: PUSH
65302: LD_INT 49
65304: PUSH
65305: LD_INT 50
65307: PUSH
65308: LD_INT 51
65310: PUSH
65311: LD_INT 52
65313: PUSH
65314: LD_INT 53
65316: PUSH
65317: LD_INT 54
65319: PUSH
65320: LD_INT 55
65322: PUSH
65323: LD_INT 56
65325: PUSH
65326: LD_INT 57
65328: PUSH
65329: LD_INT 58
65331: PUSH
65332: LD_INT 59
65334: PUSH
65335: LD_INT 63
65337: PUSH
65338: LD_INT 64
65340: PUSH
65341: LD_INT 65
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: ST_TO_ADDR
65389: GO 65392
65391: POP
// if state > - 1 and state < 3 then
65392: LD_VAR 0 3
65396: PUSH
65397: LD_INT 1
65399: NEG
65400: GREATER
65401: PUSH
65402: LD_VAR 0 3
65406: PUSH
65407: LD_INT 3
65409: LESS
65410: AND
65411: IFFALSE 65468
// for i in result do
65413: LD_ADDR_VAR 0 5
65417: PUSH
65418: LD_VAR 0 4
65422: PUSH
65423: FOR_IN
65424: IFFALSE 65466
// if GetTech ( i , side ) <> state then
65426: LD_VAR 0 5
65430: PPUSH
65431: LD_VAR 0 1
65435: PPUSH
65436: CALL_OW 321
65440: PUSH
65441: LD_VAR 0 3
65445: NONEQUAL
65446: IFFALSE 65464
// result := result diff i ;
65448: LD_ADDR_VAR 0 4
65452: PUSH
65453: LD_VAR 0 4
65457: PUSH
65458: LD_VAR 0 5
65462: DIFF
65463: ST_TO_ADDR
65464: GO 65423
65466: POP
65467: POP
// end ;
65468: LD_VAR 0 4
65472: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65473: LD_INT 0
65475: PPUSH
65476: PPUSH
65477: PPUSH
// result := true ;
65478: LD_ADDR_VAR 0 3
65482: PUSH
65483: LD_INT 1
65485: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65486: LD_ADDR_VAR 0 5
65490: PUSH
65491: LD_VAR 0 2
65495: PPUSH
65496: CALL_OW 480
65500: ST_TO_ADDR
// if not tmp then
65501: LD_VAR 0 5
65505: NOT
65506: IFFALSE 65510
// exit ;
65508: GO 65559
// for i in tmp do
65510: LD_ADDR_VAR 0 4
65514: PUSH
65515: LD_VAR 0 5
65519: PUSH
65520: FOR_IN
65521: IFFALSE 65557
// if GetTech ( i , side ) <> state_researched then
65523: LD_VAR 0 4
65527: PPUSH
65528: LD_VAR 0 1
65532: PPUSH
65533: CALL_OW 321
65537: PUSH
65538: LD_INT 2
65540: NONEQUAL
65541: IFFALSE 65555
// begin result := false ;
65543: LD_ADDR_VAR 0 3
65547: PUSH
65548: LD_INT 0
65550: ST_TO_ADDR
// exit ;
65551: POP
65552: POP
65553: GO 65559
// end ;
65555: GO 65520
65557: POP
65558: POP
// end ;
65559: LD_VAR 0 3
65563: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65564: LD_INT 0
65566: PPUSH
65567: PPUSH
65568: PPUSH
65569: PPUSH
65570: PPUSH
65571: PPUSH
65572: PPUSH
65573: PPUSH
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65579: LD_VAR 0 1
65583: NOT
65584: PUSH
65585: LD_VAR 0 1
65589: PPUSH
65590: CALL_OW 257
65594: PUSH
65595: LD_INT 9
65597: NONEQUAL
65598: OR
65599: IFFALSE 65603
// exit ;
65601: GO 66176
// side := GetSide ( unit ) ;
65603: LD_ADDR_VAR 0 9
65607: PUSH
65608: LD_VAR 0 1
65612: PPUSH
65613: CALL_OW 255
65617: ST_TO_ADDR
// tech_space := tech_spacanom ;
65618: LD_ADDR_VAR 0 12
65622: PUSH
65623: LD_INT 29
65625: ST_TO_ADDR
// tech_time := tech_taurad ;
65626: LD_ADDR_VAR 0 13
65630: PUSH
65631: LD_INT 28
65633: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65634: LD_ADDR_VAR 0 11
65638: PUSH
65639: LD_VAR 0 1
65643: PPUSH
65644: CALL_OW 310
65648: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65649: LD_VAR 0 11
65653: PPUSH
65654: CALL_OW 247
65658: PUSH
65659: LD_INT 2
65661: EQUAL
65662: IFFALSE 65666
// exit ;
65664: GO 66176
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65666: LD_ADDR_VAR 0 8
65670: PUSH
65671: LD_INT 81
65673: PUSH
65674: LD_VAR 0 9
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: PUSH
65683: LD_INT 3
65685: PUSH
65686: LD_INT 21
65688: PUSH
65689: LD_INT 3
65691: PUSH
65692: EMPTY
65693: LIST
65694: LIST
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PPUSH
65704: CALL_OW 69
65708: ST_TO_ADDR
// if not tmp then
65709: LD_VAR 0 8
65713: NOT
65714: IFFALSE 65718
// exit ;
65716: GO 66176
// if in_unit then
65718: LD_VAR 0 11
65722: IFFALSE 65746
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65724: LD_ADDR_VAR 0 10
65728: PUSH
65729: LD_VAR 0 8
65733: PPUSH
65734: LD_VAR 0 11
65738: PPUSH
65739: CALL_OW 74
65743: ST_TO_ADDR
65744: GO 65766
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65746: LD_ADDR_VAR 0 10
65750: PUSH
65751: LD_VAR 0 8
65755: PPUSH
65756: LD_VAR 0 1
65760: PPUSH
65761: CALL_OW 74
65765: ST_TO_ADDR
// if not enemy then
65766: LD_VAR 0 10
65770: NOT
65771: IFFALSE 65775
// exit ;
65773: GO 66176
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65775: LD_VAR 0 11
65779: PUSH
65780: LD_VAR 0 11
65784: PPUSH
65785: LD_VAR 0 10
65789: PPUSH
65790: CALL_OW 296
65794: PUSH
65795: LD_INT 13
65797: GREATER
65798: AND
65799: PUSH
65800: LD_VAR 0 1
65804: PPUSH
65805: LD_VAR 0 10
65809: PPUSH
65810: CALL_OW 296
65814: PUSH
65815: LD_INT 12
65817: GREATER
65818: OR
65819: IFFALSE 65823
// exit ;
65821: GO 66176
// missile := [ 1 ] ;
65823: LD_ADDR_VAR 0 14
65827: PUSH
65828: LD_INT 1
65830: PUSH
65831: EMPTY
65832: LIST
65833: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65834: LD_VAR 0 9
65838: PPUSH
65839: LD_VAR 0 12
65843: PPUSH
65844: CALL_OW 325
65848: IFFALSE 65877
// missile := Insert ( missile , missile + 1 , 2 ) ;
65850: LD_ADDR_VAR 0 14
65854: PUSH
65855: LD_VAR 0 14
65859: PPUSH
65860: LD_VAR 0 14
65864: PUSH
65865: LD_INT 1
65867: PLUS
65868: PPUSH
65869: LD_INT 2
65871: PPUSH
65872: CALL_OW 2
65876: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65877: LD_VAR 0 9
65881: PPUSH
65882: LD_VAR 0 13
65886: PPUSH
65887: CALL_OW 325
65891: PUSH
65892: LD_VAR 0 10
65896: PPUSH
65897: CALL_OW 255
65901: PPUSH
65902: LD_VAR 0 13
65906: PPUSH
65907: CALL_OW 325
65911: NOT
65912: AND
65913: IFFALSE 65942
// missile := Insert ( missile , missile + 1 , 3 ) ;
65915: LD_ADDR_VAR 0 14
65919: PUSH
65920: LD_VAR 0 14
65924: PPUSH
65925: LD_VAR 0 14
65929: PUSH
65930: LD_INT 1
65932: PLUS
65933: PPUSH
65934: LD_INT 3
65936: PPUSH
65937: CALL_OW 2
65941: ST_TO_ADDR
// if missile < 2 then
65942: LD_VAR 0 14
65946: PUSH
65947: LD_INT 2
65949: LESS
65950: IFFALSE 65954
// exit ;
65952: GO 66176
// x := GetX ( enemy ) ;
65954: LD_ADDR_VAR 0 4
65958: PUSH
65959: LD_VAR 0 10
65963: PPUSH
65964: CALL_OW 250
65968: ST_TO_ADDR
// y := GetY ( enemy ) ;
65969: LD_ADDR_VAR 0 5
65973: PUSH
65974: LD_VAR 0 10
65978: PPUSH
65979: CALL_OW 251
65983: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65984: LD_ADDR_VAR 0 6
65988: PUSH
65989: LD_VAR 0 4
65993: PUSH
65994: LD_INT 1
65996: NEG
65997: PPUSH
65998: LD_INT 1
66000: PPUSH
66001: CALL_OW 12
66005: PLUS
66006: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66007: LD_ADDR_VAR 0 7
66011: PUSH
66012: LD_VAR 0 5
66016: PUSH
66017: LD_INT 1
66019: NEG
66020: PPUSH
66021: LD_INT 1
66023: PPUSH
66024: CALL_OW 12
66028: PLUS
66029: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66030: LD_VAR 0 6
66034: PPUSH
66035: LD_VAR 0 7
66039: PPUSH
66040: CALL_OW 488
66044: NOT
66045: IFFALSE 66067
// begin _x := x ;
66047: LD_ADDR_VAR 0 6
66051: PUSH
66052: LD_VAR 0 4
66056: ST_TO_ADDR
// _y := y ;
66057: LD_ADDR_VAR 0 7
66061: PUSH
66062: LD_VAR 0 5
66066: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66067: LD_ADDR_VAR 0 3
66071: PUSH
66072: LD_INT 1
66074: PPUSH
66075: LD_VAR 0 14
66079: PPUSH
66080: CALL_OW 12
66084: ST_TO_ADDR
// case i of 1 :
66085: LD_VAR 0 3
66089: PUSH
66090: LD_INT 1
66092: DOUBLE
66093: EQUAL
66094: IFTRUE 66098
66096: GO 66115
66098: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66099: LD_VAR 0 1
66103: PPUSH
66104: LD_VAR 0 10
66108: PPUSH
66109: CALL_OW 115
66113: GO 66176
66115: LD_INT 2
66117: DOUBLE
66118: EQUAL
66119: IFTRUE 66123
66121: GO 66145
66123: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66124: LD_VAR 0 1
66128: PPUSH
66129: LD_VAR 0 6
66133: PPUSH
66134: LD_VAR 0 7
66138: PPUSH
66139: CALL_OW 153
66143: GO 66176
66145: LD_INT 3
66147: DOUBLE
66148: EQUAL
66149: IFTRUE 66153
66151: GO 66175
66153: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66154: LD_VAR 0 1
66158: PPUSH
66159: LD_VAR 0 6
66163: PPUSH
66164: LD_VAR 0 7
66168: PPUSH
66169: CALL_OW 154
66173: GO 66176
66175: POP
// end ;
66176: LD_VAR 0 2
66180: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66181: LD_INT 0
66183: PPUSH
66184: PPUSH
66185: PPUSH
66186: PPUSH
66187: PPUSH
66188: PPUSH
// if not unit or not building then
66189: LD_VAR 0 1
66193: NOT
66194: PUSH
66195: LD_VAR 0 2
66199: NOT
66200: OR
66201: IFFALSE 66205
// exit ;
66203: GO 66363
// x := GetX ( building ) ;
66205: LD_ADDR_VAR 0 5
66209: PUSH
66210: LD_VAR 0 2
66214: PPUSH
66215: CALL_OW 250
66219: ST_TO_ADDR
// y := GetY ( building ) ;
66220: LD_ADDR_VAR 0 6
66224: PUSH
66225: LD_VAR 0 2
66229: PPUSH
66230: CALL_OW 251
66234: ST_TO_ADDR
// for i = 0 to 5 do
66235: LD_ADDR_VAR 0 4
66239: PUSH
66240: DOUBLE
66241: LD_INT 0
66243: DEC
66244: ST_TO_ADDR
66245: LD_INT 5
66247: PUSH
66248: FOR_TO
66249: IFFALSE 66361
// begin _x := ShiftX ( x , i , 3 ) ;
66251: LD_ADDR_VAR 0 7
66255: PUSH
66256: LD_VAR 0 5
66260: PPUSH
66261: LD_VAR 0 4
66265: PPUSH
66266: LD_INT 3
66268: PPUSH
66269: CALL_OW 272
66273: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66274: LD_ADDR_VAR 0 8
66278: PUSH
66279: LD_VAR 0 6
66283: PPUSH
66284: LD_VAR 0 4
66288: PPUSH
66289: LD_INT 3
66291: PPUSH
66292: CALL_OW 273
66296: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66297: LD_VAR 0 7
66301: PPUSH
66302: LD_VAR 0 8
66306: PPUSH
66307: CALL_OW 488
66311: NOT
66312: IFFALSE 66316
// continue ;
66314: GO 66248
// if HexInfo ( _x , _y ) = 0 then
66316: LD_VAR 0 7
66320: PPUSH
66321: LD_VAR 0 8
66325: PPUSH
66326: CALL_OW 428
66330: PUSH
66331: LD_INT 0
66333: EQUAL
66334: IFFALSE 66359
// begin ComMoveXY ( unit , _x , _y ) ;
66336: LD_VAR 0 1
66340: PPUSH
66341: LD_VAR 0 7
66345: PPUSH
66346: LD_VAR 0 8
66350: PPUSH
66351: CALL_OW 111
// exit ;
66355: POP
66356: POP
66357: GO 66363
// end ; end ;
66359: GO 66248
66361: POP
66362: POP
// end ;
66363: LD_VAR 0 3
66367: RET
// export function ScanBase ( side , base_area ) ; begin
66368: LD_INT 0
66370: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66371: LD_ADDR_VAR 0 3
66375: PUSH
66376: LD_VAR 0 2
66380: PPUSH
66381: LD_INT 81
66383: PUSH
66384: LD_VAR 0 1
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PPUSH
66393: CALL_OW 70
66397: ST_TO_ADDR
// end ;
66398: LD_VAR 0 3
66402: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66403: LD_INT 0
66405: PPUSH
66406: PPUSH
66407: PPUSH
66408: PPUSH
66409: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66410: LD_VAR 0 1
66414: NOT
66415: PUSH
66416: LD_EXP 102
66420: PUSH
66421: LD_VAR 0 1
66425: ARRAY
66426: NOT
66427: OR
66428: PUSH
66429: LD_VAR 0 2
66433: NOT
66434: OR
66435: PUSH
66436: LD_VAR 0 3
66440: NOT
66441: OR
66442: IFFALSE 66446
// exit ;
66444: GO 66959
// side := mc_sides [ base ] ;
66446: LD_ADDR_VAR 0 6
66450: PUSH
66451: LD_EXP 128
66455: PUSH
66456: LD_VAR 0 1
66460: ARRAY
66461: ST_TO_ADDR
// if not side then
66462: LD_VAR 0 6
66466: NOT
66467: IFFALSE 66471
// exit ;
66469: GO 66959
// for i in solds do
66471: LD_ADDR_VAR 0 7
66475: PUSH
66476: LD_VAR 0 2
66480: PUSH
66481: FOR_IN
66482: IFFALSE 66543
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66484: LD_VAR 0 7
66488: PPUSH
66489: CALL_OW 310
66493: PPUSH
66494: CALL_OW 266
66498: PUSH
66499: LD_INT 32
66501: PUSH
66502: LD_INT 31
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: IN
66509: IFFALSE 66529
// solds := solds diff i else
66511: LD_ADDR_VAR 0 2
66515: PUSH
66516: LD_VAR 0 2
66520: PUSH
66521: LD_VAR 0 7
66525: DIFF
66526: ST_TO_ADDR
66527: GO 66541
// SetTag ( i , 18 ) ;
66529: LD_VAR 0 7
66533: PPUSH
66534: LD_INT 18
66536: PPUSH
66537: CALL_OW 109
66541: GO 66481
66543: POP
66544: POP
// if not solds then
66545: LD_VAR 0 2
66549: NOT
66550: IFFALSE 66554
// exit ;
66552: GO 66959
// repeat wait ( 0 0$1 ) ;
66554: LD_INT 35
66556: PPUSH
66557: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66561: LD_ADDR_VAR 0 5
66565: PUSH
66566: LD_VAR 0 6
66570: PPUSH
66571: LD_VAR 0 3
66575: PPUSH
66576: CALL 66368 0 2
66580: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66581: LD_EXP 102
66585: PUSH
66586: LD_VAR 0 1
66590: ARRAY
66591: NOT
66592: PUSH
66593: LD_EXP 102
66597: PUSH
66598: LD_VAR 0 1
66602: ARRAY
66603: PUSH
66604: EMPTY
66605: EQUAL
66606: OR
66607: IFFALSE 66644
// begin for i in solds do
66609: LD_ADDR_VAR 0 7
66613: PUSH
66614: LD_VAR 0 2
66618: PUSH
66619: FOR_IN
66620: IFFALSE 66633
// ComStop ( i ) ;
66622: LD_VAR 0 7
66626: PPUSH
66627: CALL_OW 141
66631: GO 66619
66633: POP
66634: POP
// solds := [ ] ;
66635: LD_ADDR_VAR 0 2
66639: PUSH
66640: EMPTY
66641: ST_TO_ADDR
// exit ;
66642: GO 66959
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66644: LD_VAR 0 5
66648: NOT
66649: PUSH
66650: LD_VAR 0 5
66654: PUSH
66655: LD_INT 3
66657: GREATER
66658: OR
66659: PUSH
66660: LD_EXP 124
66664: PUSH
66665: LD_VAR 0 1
66669: ARRAY
66670: OR
66671: IFFALSE 66712
// begin for i in solds do
66673: LD_ADDR_VAR 0 7
66677: PUSH
66678: LD_VAR 0 2
66682: PUSH
66683: FOR_IN
66684: IFFALSE 66708
// if HasTask ( i ) then
66686: LD_VAR 0 7
66690: PPUSH
66691: CALL_OW 314
66695: IFFALSE 66706
// ComStop ( i ) ;
66697: LD_VAR 0 7
66701: PPUSH
66702: CALL_OW 141
66706: GO 66683
66708: POP
66709: POP
// break ;
66710: GO 66947
// end ; for i in solds do
66712: LD_ADDR_VAR 0 7
66716: PUSH
66717: LD_VAR 0 2
66721: PUSH
66722: FOR_IN
66723: IFFALSE 66939
// begin if IsInUnit ( i ) then
66725: LD_VAR 0 7
66729: PPUSH
66730: CALL_OW 310
66734: IFFALSE 66745
// ComExitBuilding ( i ) ;
66736: LD_VAR 0 7
66740: PPUSH
66741: CALL_OW 122
// if GetLives ( i ) > 333 then
66745: LD_VAR 0 7
66749: PPUSH
66750: CALL_OW 256
66754: PUSH
66755: LD_INT 333
66757: GREATER
66758: IFFALSE 66786
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66760: LD_VAR 0 7
66764: PPUSH
66765: LD_VAR 0 5
66769: PPUSH
66770: LD_VAR 0 7
66774: PPUSH
66775: CALL_OW 74
66779: PPUSH
66780: CALL_OW 115
66784: GO 66937
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66786: LD_ADDR_VAR 0 8
66790: PUSH
66791: LD_EXP 102
66795: PUSH
66796: LD_VAR 0 1
66800: ARRAY
66801: PPUSH
66802: LD_INT 2
66804: PUSH
66805: LD_INT 30
66807: PUSH
66808: LD_INT 0
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 30
66817: PUSH
66818: LD_INT 1
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 30
66827: PUSH
66828: LD_INT 6
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: PPUSH
66841: CALL_OW 72
66845: PPUSH
66846: LD_VAR 0 7
66850: PPUSH
66851: CALL_OW 74
66855: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66856: LD_VAR 0 7
66860: PPUSH
66861: LD_VAR 0 8
66865: PPUSH
66866: CALL_OW 250
66870: PPUSH
66871: LD_INT 3
66873: PPUSH
66874: LD_INT 5
66876: PPUSH
66877: CALL_OW 272
66881: PPUSH
66882: LD_VAR 0 8
66886: PPUSH
66887: CALL_OW 251
66891: PPUSH
66892: LD_INT 3
66894: PPUSH
66895: LD_INT 5
66897: PPUSH
66898: CALL_OW 273
66902: PPUSH
66903: CALL_OW 111
// SetTag ( i , 0 ) ;
66907: LD_VAR 0 7
66911: PPUSH
66912: LD_INT 0
66914: PPUSH
66915: CALL_OW 109
// solds := solds diff i ;
66919: LD_ADDR_VAR 0 2
66923: PUSH
66924: LD_VAR 0 2
66928: PUSH
66929: LD_VAR 0 7
66933: DIFF
66934: ST_TO_ADDR
// continue ;
66935: GO 66722
// end ; end ;
66937: GO 66722
66939: POP
66940: POP
// until solds ;
66941: LD_VAR 0 2
66945: IFFALSE 66554
// MC_Reset ( base , 18 ) ;
66947: LD_VAR 0 1
66951: PPUSH
66952: LD_INT 18
66954: PPUSH
66955: CALL 38780 0 2
// end ;
66959: LD_VAR 0 4
66963: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66964: LD_INT 0
66966: PPUSH
66967: PPUSH
66968: PPUSH
66969: PPUSH
66970: PPUSH
66971: PPUSH
66972: PPUSH
66973: PPUSH
66974: PPUSH
66975: PPUSH
66976: PPUSH
66977: PPUSH
66978: PPUSH
66979: PPUSH
66980: PPUSH
66981: PPUSH
66982: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66983: LD_ADDR_VAR 0 13
66987: PUSH
66988: LD_EXP 102
66992: PUSH
66993: LD_VAR 0 1
66997: ARRAY
66998: PPUSH
66999: LD_INT 25
67001: PUSH
67002: LD_INT 3
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: PPUSH
67009: CALL_OW 72
67013: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67014: LD_EXP 142
67018: PUSH
67019: LD_VAR 0 1
67023: ARRAY
67024: IFFALSE 67048
// mechs := mechs diff mc_remote_driver [ base ] ;
67026: LD_ADDR_VAR 0 13
67030: PUSH
67031: LD_VAR 0 13
67035: PUSH
67036: LD_EXP 142
67040: PUSH
67041: LD_VAR 0 1
67045: ARRAY
67046: DIFF
67047: ST_TO_ADDR
// for i in mechs do
67048: LD_ADDR_VAR 0 5
67052: PUSH
67053: LD_VAR 0 13
67057: PUSH
67058: FOR_IN
67059: IFFALSE 67094
// if GetTag ( i ) > 0 then
67061: LD_VAR 0 5
67065: PPUSH
67066: CALL_OW 110
67070: PUSH
67071: LD_INT 0
67073: GREATER
67074: IFFALSE 67092
// mechs := mechs diff i ;
67076: LD_ADDR_VAR 0 13
67080: PUSH
67081: LD_VAR 0 13
67085: PUSH
67086: LD_VAR 0 5
67090: DIFF
67091: ST_TO_ADDR
67092: GO 67058
67094: POP
67095: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67096: LD_ADDR_VAR 0 9
67100: PUSH
67101: LD_EXP 102
67105: PUSH
67106: LD_VAR 0 1
67110: ARRAY
67111: PPUSH
67112: LD_INT 2
67114: PUSH
67115: LD_INT 25
67117: PUSH
67118: LD_INT 1
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 25
67127: PUSH
67128: LD_INT 5
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 25
67137: PUSH
67138: LD_INT 8
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 25
67147: PUSH
67148: LD_INT 9
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: PPUSH
67162: CALL_OW 72
67166: ST_TO_ADDR
// if not defenders and not solds then
67167: LD_VAR 0 2
67171: NOT
67172: PUSH
67173: LD_VAR 0 9
67177: NOT
67178: AND
67179: IFFALSE 67183
// exit ;
67181: GO 68809
// depot_under_attack := false ;
67183: LD_ADDR_VAR 0 17
67187: PUSH
67188: LD_INT 0
67190: ST_TO_ADDR
// sold_defenders := [ ] ;
67191: LD_ADDR_VAR 0 18
67195: PUSH
67196: EMPTY
67197: ST_TO_ADDR
// if mechs then
67198: LD_VAR 0 13
67202: IFFALSE 67331
// for i in defenders do
67204: LD_ADDR_VAR 0 5
67208: PUSH
67209: LD_VAR 0 2
67213: PUSH
67214: FOR_IN
67215: IFFALSE 67329
// begin SetTag ( i , 20 ) ;
67217: LD_VAR 0 5
67221: PPUSH
67222: LD_INT 20
67224: PPUSH
67225: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67229: LD_VAR 0 5
67233: PPUSH
67234: CALL_OW 263
67238: PUSH
67239: LD_INT 1
67241: EQUAL
67242: PUSH
67243: LD_VAR 0 5
67247: PPUSH
67248: CALL_OW 311
67252: NOT
67253: AND
67254: PUSH
67255: LD_VAR 0 13
67259: AND
67260: IFFALSE 67327
// begin un := mechs [ 1 ] ;
67262: LD_ADDR_VAR 0 11
67266: PUSH
67267: LD_VAR 0 13
67271: PUSH
67272: LD_INT 1
67274: ARRAY
67275: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67276: LD_VAR 0 11
67280: PPUSH
67281: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67285: LD_VAR 0 11
67289: PPUSH
67290: LD_VAR 0 5
67294: PPUSH
67295: CALL_OW 180
// SetTag ( un , 19 ) ;
67299: LD_VAR 0 11
67303: PPUSH
67304: LD_INT 19
67306: PPUSH
67307: CALL_OW 109
// mechs := mechs diff un ;
67311: LD_ADDR_VAR 0 13
67315: PUSH
67316: LD_VAR 0 13
67320: PUSH
67321: LD_VAR 0 11
67325: DIFF
67326: ST_TO_ADDR
// end ; end ;
67327: GO 67214
67329: POP
67330: POP
// if solds then
67331: LD_VAR 0 9
67335: IFFALSE 67394
// for i in solds do
67337: LD_ADDR_VAR 0 5
67341: PUSH
67342: LD_VAR 0 9
67346: PUSH
67347: FOR_IN
67348: IFFALSE 67392
// if not GetTag ( i ) then
67350: LD_VAR 0 5
67354: PPUSH
67355: CALL_OW 110
67359: NOT
67360: IFFALSE 67390
// begin defenders := defenders union i ;
67362: LD_ADDR_VAR 0 2
67366: PUSH
67367: LD_VAR 0 2
67371: PUSH
67372: LD_VAR 0 5
67376: UNION
67377: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67378: LD_VAR 0 5
67382: PPUSH
67383: LD_INT 18
67385: PPUSH
67386: CALL_OW 109
// end ;
67390: GO 67347
67392: POP
67393: POP
// repeat wait ( 0 0$1 ) ;
67394: LD_INT 35
67396: PPUSH
67397: CALL_OW 67
// enemy := mc_scan [ base ] ;
67401: LD_ADDR_VAR 0 3
67405: PUSH
67406: LD_EXP 125
67410: PUSH
67411: LD_VAR 0 1
67415: ARRAY
67416: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67417: LD_EXP 102
67421: PUSH
67422: LD_VAR 0 1
67426: ARRAY
67427: NOT
67428: PUSH
67429: LD_EXP 102
67433: PUSH
67434: LD_VAR 0 1
67438: ARRAY
67439: PUSH
67440: EMPTY
67441: EQUAL
67442: OR
67443: IFFALSE 67480
// begin for i in defenders do
67445: LD_ADDR_VAR 0 5
67449: PUSH
67450: LD_VAR 0 2
67454: PUSH
67455: FOR_IN
67456: IFFALSE 67469
// ComStop ( i ) ;
67458: LD_VAR 0 5
67462: PPUSH
67463: CALL_OW 141
67467: GO 67455
67469: POP
67470: POP
// defenders := [ ] ;
67471: LD_ADDR_VAR 0 2
67475: PUSH
67476: EMPTY
67477: ST_TO_ADDR
// exit ;
67478: GO 68809
// end ; for i in defenders do
67480: LD_ADDR_VAR 0 5
67484: PUSH
67485: LD_VAR 0 2
67489: PUSH
67490: FOR_IN
67491: IFFALSE 68309
// begin e := NearestUnitToUnit ( enemy , i ) ;
67493: LD_ADDR_VAR 0 14
67497: PUSH
67498: LD_VAR 0 3
67502: PPUSH
67503: LD_VAR 0 5
67507: PPUSH
67508: CALL_OW 74
67512: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67513: LD_ADDR_VAR 0 8
67517: PUSH
67518: LD_EXP 102
67522: PUSH
67523: LD_VAR 0 1
67527: ARRAY
67528: PPUSH
67529: LD_INT 2
67531: PUSH
67532: LD_INT 30
67534: PUSH
67535: LD_INT 0
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 30
67544: PUSH
67545: LD_INT 1
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: LIST
67556: PPUSH
67557: CALL_OW 72
67561: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67562: LD_ADDR_VAR 0 17
67566: PUSH
67567: LD_VAR 0 8
67571: NOT
67572: PUSH
67573: LD_VAR 0 8
67577: PPUSH
67578: LD_INT 3
67580: PUSH
67581: LD_INT 24
67583: PUSH
67584: LD_INT 600
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PPUSH
67595: CALL_OW 72
67599: OR
67600: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67601: LD_VAR 0 5
67605: PPUSH
67606: CALL_OW 247
67610: PUSH
67611: LD_INT 2
67613: DOUBLE
67614: EQUAL
67615: IFTRUE 67619
67617: GO 68015
67619: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67620: LD_VAR 0 5
67624: PPUSH
67625: CALL_OW 256
67629: PUSH
67630: LD_INT 650
67632: GREATER
67633: PUSH
67634: LD_VAR 0 5
67638: PPUSH
67639: LD_VAR 0 14
67643: PPUSH
67644: CALL_OW 296
67648: PUSH
67649: LD_INT 40
67651: LESS
67652: PUSH
67653: LD_VAR 0 14
67657: PPUSH
67658: LD_EXP 127
67662: PUSH
67663: LD_VAR 0 1
67667: ARRAY
67668: PPUSH
67669: CALL_OW 308
67673: OR
67674: AND
67675: IFFALSE 67797
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67677: LD_VAR 0 5
67681: PPUSH
67682: CALL_OW 262
67686: PUSH
67687: LD_INT 1
67689: EQUAL
67690: PUSH
67691: LD_VAR 0 5
67695: PPUSH
67696: CALL_OW 261
67700: PUSH
67701: LD_INT 30
67703: LESS
67704: AND
67705: PUSH
67706: LD_VAR 0 8
67710: AND
67711: IFFALSE 67781
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67713: LD_VAR 0 5
67717: PPUSH
67718: LD_VAR 0 8
67722: PPUSH
67723: LD_VAR 0 5
67727: PPUSH
67728: CALL_OW 74
67732: PPUSH
67733: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67737: LD_VAR 0 5
67741: PPUSH
67742: LD_VAR 0 8
67746: PPUSH
67747: LD_VAR 0 5
67751: PPUSH
67752: CALL_OW 74
67756: PPUSH
67757: CALL_OW 296
67761: PUSH
67762: LD_INT 6
67764: LESS
67765: IFFALSE 67779
// SetFuel ( i , 100 ) ;
67767: LD_VAR 0 5
67771: PPUSH
67772: LD_INT 100
67774: PPUSH
67775: CALL_OW 240
// end else
67779: GO 67795
// ComAttackUnit ( i , e ) ;
67781: LD_VAR 0 5
67785: PPUSH
67786: LD_VAR 0 14
67790: PPUSH
67791: CALL_OW 115
// end else
67795: GO 67898
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67797: LD_VAR 0 14
67801: PPUSH
67802: LD_EXP 127
67806: PUSH
67807: LD_VAR 0 1
67811: ARRAY
67812: PPUSH
67813: CALL_OW 308
67817: NOT
67818: PUSH
67819: LD_VAR 0 5
67823: PPUSH
67824: LD_VAR 0 14
67828: PPUSH
67829: CALL_OW 296
67833: PUSH
67834: LD_INT 40
67836: GREATEREQUAL
67837: AND
67838: PUSH
67839: LD_VAR 0 5
67843: PPUSH
67844: CALL_OW 256
67848: PUSH
67849: LD_INT 650
67851: LESSEQUAL
67852: OR
67853: PUSH
67854: LD_VAR 0 5
67858: PPUSH
67859: LD_EXP 126
67863: PUSH
67864: LD_VAR 0 1
67868: ARRAY
67869: PPUSH
67870: CALL_OW 308
67874: NOT
67875: AND
67876: IFFALSE 67898
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67878: LD_VAR 0 5
67882: PPUSH
67883: LD_EXP 126
67887: PUSH
67888: LD_VAR 0 1
67892: ARRAY
67893: PPUSH
67894: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67898: LD_VAR 0 5
67902: PPUSH
67903: CALL_OW 256
67907: PUSH
67908: LD_INT 998
67910: LESS
67911: PUSH
67912: LD_VAR 0 5
67916: PPUSH
67917: CALL_OW 263
67921: PUSH
67922: LD_INT 1
67924: EQUAL
67925: AND
67926: PUSH
67927: LD_VAR 0 5
67931: PPUSH
67932: CALL_OW 311
67936: AND
67937: PUSH
67938: LD_VAR 0 5
67942: PPUSH
67943: LD_EXP 126
67947: PUSH
67948: LD_VAR 0 1
67952: ARRAY
67953: PPUSH
67954: CALL_OW 308
67958: AND
67959: IFFALSE 68013
// begin mech := IsDrivenBy ( i ) ;
67961: LD_ADDR_VAR 0 10
67965: PUSH
67966: LD_VAR 0 5
67970: PPUSH
67971: CALL_OW 311
67975: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67976: LD_VAR 0 10
67980: PPUSH
67981: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67985: LD_VAR 0 10
67989: PPUSH
67990: LD_VAR 0 5
67994: PPUSH
67995: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67999: LD_VAR 0 10
68003: PPUSH
68004: LD_VAR 0 5
68008: PPUSH
68009: CALL_OW 180
// end ; end ; unit_human :
68013: GO 68280
68015: LD_INT 1
68017: DOUBLE
68018: EQUAL
68019: IFTRUE 68023
68021: GO 68279
68023: POP
// begin b := IsInUnit ( i ) ;
68024: LD_ADDR_VAR 0 19
68028: PUSH
68029: LD_VAR 0 5
68033: PPUSH
68034: CALL_OW 310
68038: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68039: LD_ADDR_VAR 0 20
68043: PUSH
68044: LD_VAR 0 19
68048: NOT
68049: PUSH
68050: LD_VAR 0 19
68054: PPUSH
68055: CALL_OW 266
68059: PUSH
68060: LD_INT 32
68062: PUSH
68063: LD_INT 31
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: IN
68070: OR
68071: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68072: LD_VAR 0 17
68076: PUSH
68077: LD_VAR 0 2
68081: PPUSH
68082: LD_INT 21
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PPUSH
68092: CALL_OW 72
68096: PUSH
68097: LD_INT 1
68099: LESSEQUAL
68100: OR
68101: PUSH
68102: LD_VAR 0 20
68106: AND
68107: PUSH
68108: LD_VAR 0 5
68112: PUSH
68113: LD_VAR 0 18
68117: IN
68118: NOT
68119: AND
68120: IFFALSE 68213
// begin if b then
68122: LD_VAR 0 19
68126: IFFALSE 68175
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68128: LD_VAR 0 19
68132: PPUSH
68133: LD_VAR 0 3
68137: PPUSH
68138: LD_VAR 0 19
68142: PPUSH
68143: CALL_OW 74
68147: PPUSH
68148: CALL_OW 296
68152: PUSH
68153: LD_INT 10
68155: LESS
68156: PUSH
68157: LD_VAR 0 19
68161: PPUSH
68162: CALL_OW 461
68166: PUSH
68167: LD_INT 7
68169: NONEQUAL
68170: AND
68171: IFFALSE 68175
// continue ;
68173: GO 67490
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68175: LD_ADDR_VAR 0 18
68179: PUSH
68180: LD_VAR 0 18
68184: PPUSH
68185: LD_VAR 0 18
68189: PUSH
68190: LD_INT 1
68192: PLUS
68193: PPUSH
68194: LD_VAR 0 5
68198: PPUSH
68199: CALL_OW 1
68203: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68204: LD_VAR 0 5
68208: PPUSH
68209: CALL_OW 122
// end ; if sold_defenders then
68213: LD_VAR 0 18
68217: IFFALSE 68277
// if i in sold_defenders then
68219: LD_VAR 0 5
68223: PUSH
68224: LD_VAR 0 18
68228: IN
68229: IFFALSE 68277
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68231: LD_VAR 0 5
68235: PPUSH
68236: CALL_OW 314
68240: NOT
68241: PUSH
68242: LD_VAR 0 5
68246: PPUSH
68247: LD_VAR 0 14
68251: PPUSH
68252: CALL_OW 296
68256: PUSH
68257: LD_INT 30
68259: LESS
68260: AND
68261: IFFALSE 68277
// ComAttackUnit ( i , e ) ;
68263: LD_VAR 0 5
68267: PPUSH
68268: LD_VAR 0 14
68272: PPUSH
68273: CALL_OW 115
// end ; end ; end ;
68277: GO 68280
68279: POP
// if IsDead ( i ) then
68280: LD_VAR 0 5
68284: PPUSH
68285: CALL_OW 301
68289: IFFALSE 68307
// defenders := defenders diff i ;
68291: LD_ADDR_VAR 0 2
68295: PUSH
68296: LD_VAR 0 2
68300: PUSH
68301: LD_VAR 0 5
68305: DIFF
68306: ST_TO_ADDR
// end ;
68307: GO 67490
68309: POP
68310: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68311: LD_VAR 0 3
68315: NOT
68316: PUSH
68317: LD_VAR 0 2
68321: NOT
68322: OR
68323: PUSH
68324: LD_EXP 102
68328: PUSH
68329: LD_VAR 0 1
68333: ARRAY
68334: NOT
68335: OR
68336: IFFALSE 67394
// MC_Reset ( base , 18 ) ;
68338: LD_VAR 0 1
68342: PPUSH
68343: LD_INT 18
68345: PPUSH
68346: CALL 38780 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68350: LD_ADDR_VAR 0 2
68354: PUSH
68355: LD_VAR 0 2
68359: PUSH
68360: LD_VAR 0 2
68364: PPUSH
68365: LD_INT 2
68367: PUSH
68368: LD_INT 25
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 25
68380: PUSH
68381: LD_INT 5
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 25
68390: PUSH
68391: LD_INT 8
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 25
68400: PUSH
68401: LD_INT 9
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: PPUSH
68415: CALL_OW 72
68419: DIFF
68420: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68421: LD_VAR 0 3
68425: NOT
68426: PUSH
68427: LD_VAR 0 2
68431: PPUSH
68432: LD_INT 21
68434: PUSH
68435: LD_INT 2
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PPUSH
68442: CALL_OW 72
68446: AND
68447: IFFALSE 68785
// begin tmp := FilterByTag ( defenders , 19 ) ;
68449: LD_ADDR_VAR 0 12
68453: PUSH
68454: LD_VAR 0 2
68458: PPUSH
68459: LD_INT 19
68461: PPUSH
68462: CALL 105241 0 2
68466: ST_TO_ADDR
// if tmp then
68467: LD_VAR 0 12
68471: IFFALSE 68541
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68473: LD_ADDR_VAR 0 12
68477: PUSH
68478: LD_VAR 0 12
68482: PPUSH
68483: LD_INT 25
68485: PUSH
68486: LD_INT 3
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PPUSH
68493: CALL_OW 72
68497: ST_TO_ADDR
// if tmp then
68498: LD_VAR 0 12
68502: IFFALSE 68541
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68504: LD_ADDR_EXP 114
68508: PUSH
68509: LD_EXP 114
68513: PPUSH
68514: LD_VAR 0 1
68518: PPUSH
68519: LD_EXP 114
68523: PUSH
68524: LD_VAR 0 1
68528: ARRAY
68529: PUSH
68530: LD_VAR 0 12
68534: UNION
68535: PPUSH
68536: CALL_OW 1
68540: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68541: LD_VAR 0 1
68545: PPUSH
68546: LD_INT 19
68548: PPUSH
68549: CALL 38780 0 2
// repeat wait ( 0 0$1 ) ;
68553: LD_INT 35
68555: PPUSH
68556: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68560: LD_EXP 102
68564: PUSH
68565: LD_VAR 0 1
68569: ARRAY
68570: NOT
68571: PUSH
68572: LD_EXP 102
68576: PUSH
68577: LD_VAR 0 1
68581: ARRAY
68582: PUSH
68583: EMPTY
68584: EQUAL
68585: OR
68586: IFFALSE 68623
// begin for i in defenders do
68588: LD_ADDR_VAR 0 5
68592: PUSH
68593: LD_VAR 0 2
68597: PUSH
68598: FOR_IN
68599: IFFALSE 68612
// ComStop ( i ) ;
68601: LD_VAR 0 5
68605: PPUSH
68606: CALL_OW 141
68610: GO 68598
68612: POP
68613: POP
// defenders := [ ] ;
68614: LD_ADDR_VAR 0 2
68618: PUSH
68619: EMPTY
68620: ST_TO_ADDR
// exit ;
68621: GO 68809
// end ; for i in defenders do
68623: LD_ADDR_VAR 0 5
68627: PUSH
68628: LD_VAR 0 2
68632: PUSH
68633: FOR_IN
68634: IFFALSE 68723
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68636: LD_VAR 0 5
68640: PPUSH
68641: LD_EXP 126
68645: PUSH
68646: LD_VAR 0 1
68650: ARRAY
68651: PPUSH
68652: CALL_OW 308
68656: NOT
68657: IFFALSE 68681
// ComMoveToArea ( i , mc_parking [ base ] ) else
68659: LD_VAR 0 5
68663: PPUSH
68664: LD_EXP 126
68668: PUSH
68669: LD_VAR 0 1
68673: ARRAY
68674: PPUSH
68675: CALL_OW 113
68679: GO 68721
// if GetControl ( i ) = control_manual then
68681: LD_VAR 0 5
68685: PPUSH
68686: CALL_OW 263
68690: PUSH
68691: LD_INT 1
68693: EQUAL
68694: IFFALSE 68721
// if IsDrivenBy ( i ) then
68696: LD_VAR 0 5
68700: PPUSH
68701: CALL_OW 311
68705: IFFALSE 68721
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68707: LD_VAR 0 5
68711: PPUSH
68712: CALL_OW 311
68716: PPUSH
68717: CALL_OW 121
// end ;
68721: GO 68633
68723: POP
68724: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68725: LD_VAR 0 2
68729: PPUSH
68730: LD_INT 95
68732: PUSH
68733: LD_EXP 126
68737: PUSH
68738: LD_VAR 0 1
68742: ARRAY
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PPUSH
68748: CALL_OW 72
68752: PUSH
68753: LD_VAR 0 2
68757: EQUAL
68758: PUSH
68759: LD_EXP 125
68763: PUSH
68764: LD_VAR 0 1
68768: ARRAY
68769: OR
68770: PUSH
68771: LD_EXP 102
68775: PUSH
68776: LD_VAR 0 1
68780: ARRAY
68781: NOT
68782: OR
68783: IFFALSE 68553
// end ; MC_Reset ( base , 19 ) ;
68785: LD_VAR 0 1
68789: PPUSH
68790: LD_INT 19
68792: PPUSH
68793: CALL 38780 0 2
// MC_Reset ( base , 20 ) ;
68797: LD_VAR 0 1
68801: PPUSH
68802: LD_INT 20
68804: PPUSH
68805: CALL 38780 0 2
// end ;
68809: LD_VAR 0 4
68813: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68814: LD_INT 0
68816: PPUSH
68817: PPUSH
68818: PPUSH
68819: PPUSH
// result := false ;
68820: LD_ADDR_VAR 0 2
68824: PUSH
68825: LD_INT 0
68827: ST_TO_ADDR
// side := GetSide ( unit ) ;
68828: LD_ADDR_VAR 0 3
68832: PUSH
68833: LD_VAR 0 1
68837: PPUSH
68838: CALL_OW 255
68842: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68843: LD_ADDR_VAR 0 4
68847: PUSH
68848: LD_VAR 0 1
68852: PPUSH
68853: CALL_OW 248
68857: ST_TO_ADDR
// case nat of 1 :
68858: LD_VAR 0 4
68862: PUSH
68863: LD_INT 1
68865: DOUBLE
68866: EQUAL
68867: IFTRUE 68871
68869: GO 68882
68871: POP
// tech := tech_lassight ; 2 :
68872: LD_ADDR_VAR 0 5
68876: PUSH
68877: LD_INT 12
68879: ST_TO_ADDR
68880: GO 68921
68882: LD_INT 2
68884: DOUBLE
68885: EQUAL
68886: IFTRUE 68890
68888: GO 68901
68890: POP
// tech := tech_mortar ; 3 :
68891: LD_ADDR_VAR 0 5
68895: PUSH
68896: LD_INT 41
68898: ST_TO_ADDR
68899: GO 68921
68901: LD_INT 3
68903: DOUBLE
68904: EQUAL
68905: IFTRUE 68909
68907: GO 68920
68909: POP
// tech := tech_bazooka ; end ;
68910: LD_ADDR_VAR 0 5
68914: PUSH
68915: LD_INT 44
68917: ST_TO_ADDR
68918: GO 68921
68920: POP
// if Researched ( side , tech ) then
68921: LD_VAR 0 3
68925: PPUSH
68926: LD_VAR 0 5
68930: PPUSH
68931: CALL_OW 325
68935: IFFALSE 68962
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68937: LD_ADDR_VAR 0 2
68941: PUSH
68942: LD_INT 5
68944: PUSH
68945: LD_INT 8
68947: PUSH
68948: LD_INT 9
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: LIST
68955: PUSH
68956: LD_VAR 0 4
68960: ARRAY
68961: ST_TO_ADDR
// end ;
68962: LD_VAR 0 2
68966: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68967: LD_INT 0
68969: PPUSH
68970: PPUSH
68971: PPUSH
// if not mines then
68972: LD_VAR 0 2
68976: NOT
68977: IFFALSE 68981
// exit ;
68979: GO 69125
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68981: LD_ADDR_VAR 0 5
68985: PUSH
68986: LD_INT 81
68988: PUSH
68989: LD_VAR 0 1
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 3
69000: PUSH
69001: LD_INT 21
69003: PUSH
69004: LD_INT 3
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PPUSH
69019: CALL_OW 69
69023: ST_TO_ADDR
// for i in mines do
69024: LD_ADDR_VAR 0 4
69028: PUSH
69029: LD_VAR 0 2
69033: PUSH
69034: FOR_IN
69035: IFFALSE 69123
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69037: LD_VAR 0 4
69041: PUSH
69042: LD_INT 1
69044: ARRAY
69045: PPUSH
69046: LD_VAR 0 4
69050: PUSH
69051: LD_INT 2
69053: ARRAY
69054: PPUSH
69055: CALL_OW 458
69059: NOT
69060: IFFALSE 69064
// continue ;
69062: GO 69034
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69064: LD_VAR 0 4
69068: PUSH
69069: LD_INT 1
69071: ARRAY
69072: PPUSH
69073: LD_VAR 0 4
69077: PUSH
69078: LD_INT 2
69080: ARRAY
69081: PPUSH
69082: CALL_OW 428
69086: PUSH
69087: LD_VAR 0 5
69091: IN
69092: IFFALSE 69121
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69094: LD_VAR 0 4
69098: PUSH
69099: LD_INT 1
69101: ARRAY
69102: PPUSH
69103: LD_VAR 0 4
69107: PUSH
69108: LD_INT 2
69110: ARRAY
69111: PPUSH
69112: LD_VAR 0 1
69116: PPUSH
69117: CALL_OW 456
// end ;
69121: GO 69034
69123: POP
69124: POP
// end ;
69125: LD_VAR 0 3
69129: RET
// export function Count ( array ) ; var i ; begin
69130: LD_INT 0
69132: PPUSH
69133: PPUSH
// result := 0 ;
69134: LD_ADDR_VAR 0 2
69138: PUSH
69139: LD_INT 0
69141: ST_TO_ADDR
// for i in array do
69142: LD_ADDR_VAR 0 3
69146: PUSH
69147: LD_VAR 0 1
69151: PUSH
69152: FOR_IN
69153: IFFALSE 69177
// if i then
69155: LD_VAR 0 3
69159: IFFALSE 69175
// result := result + 1 ;
69161: LD_ADDR_VAR 0 2
69165: PUSH
69166: LD_VAR 0 2
69170: PUSH
69171: LD_INT 1
69173: PLUS
69174: ST_TO_ADDR
69175: GO 69152
69177: POP
69178: POP
// end ;
69179: LD_VAR 0 2
69183: RET
// export function IsEmpty ( building ) ; begin
69184: LD_INT 0
69186: PPUSH
// if not building then
69187: LD_VAR 0 1
69191: NOT
69192: IFFALSE 69196
// exit ;
69194: GO 69239
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69196: LD_ADDR_VAR 0 2
69200: PUSH
69201: LD_VAR 0 1
69205: PUSH
69206: LD_INT 22
69208: PUSH
69209: LD_VAR 0 1
69213: PPUSH
69214: CALL_OW 255
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PUSH
69223: LD_INT 58
69225: PUSH
69226: EMPTY
69227: LIST
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PPUSH
69233: CALL_OW 69
69237: IN
69238: ST_TO_ADDR
// end ;
69239: LD_VAR 0 2
69243: RET
// export function IsNotFull ( building ) ; begin
69244: LD_INT 0
69246: PPUSH
// if not building then
69247: LD_VAR 0 1
69251: NOT
69252: IFFALSE 69256
// exit ;
69254: GO 69275
// result := UnitsInside ( building ) < 6 ;
69256: LD_ADDR_VAR 0 2
69260: PUSH
69261: LD_VAR 0 1
69265: PPUSH
69266: CALL_OW 313
69270: PUSH
69271: LD_INT 6
69273: LESS
69274: ST_TO_ADDR
// end ;
69275: LD_VAR 0 2
69279: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69280: LD_INT 0
69282: PPUSH
69283: PPUSH
69284: PPUSH
69285: PPUSH
// tmp := [ ] ;
69286: LD_ADDR_VAR 0 3
69290: PUSH
69291: EMPTY
69292: ST_TO_ADDR
// list := [ ] ;
69293: LD_ADDR_VAR 0 5
69297: PUSH
69298: EMPTY
69299: ST_TO_ADDR
// for i = 16 to 25 do
69300: LD_ADDR_VAR 0 4
69304: PUSH
69305: DOUBLE
69306: LD_INT 16
69308: DEC
69309: ST_TO_ADDR
69310: LD_INT 25
69312: PUSH
69313: FOR_TO
69314: IFFALSE 69387
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69316: LD_ADDR_VAR 0 3
69320: PUSH
69321: LD_VAR 0 3
69325: PUSH
69326: LD_INT 22
69328: PUSH
69329: LD_VAR 0 1
69333: PPUSH
69334: CALL_OW 255
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 91
69345: PUSH
69346: LD_VAR 0 1
69350: PUSH
69351: LD_INT 6
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 30
69361: PUSH
69362: LD_VAR 0 4
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: LIST
69375: PUSH
69376: EMPTY
69377: LIST
69378: PPUSH
69379: CALL_OW 69
69383: ADD
69384: ST_TO_ADDR
69385: GO 69313
69387: POP
69388: POP
// for i = 1 to tmp do
69389: LD_ADDR_VAR 0 4
69393: PUSH
69394: DOUBLE
69395: LD_INT 1
69397: DEC
69398: ST_TO_ADDR
69399: LD_VAR 0 3
69403: PUSH
69404: FOR_TO
69405: IFFALSE 69493
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69407: LD_ADDR_VAR 0 5
69411: PUSH
69412: LD_VAR 0 5
69416: PUSH
69417: LD_VAR 0 3
69421: PUSH
69422: LD_VAR 0 4
69426: ARRAY
69427: PPUSH
69428: CALL_OW 266
69432: PUSH
69433: LD_VAR 0 3
69437: PUSH
69438: LD_VAR 0 4
69442: ARRAY
69443: PPUSH
69444: CALL_OW 250
69448: PUSH
69449: LD_VAR 0 3
69453: PUSH
69454: LD_VAR 0 4
69458: ARRAY
69459: PPUSH
69460: CALL_OW 251
69464: PUSH
69465: LD_VAR 0 3
69469: PUSH
69470: LD_VAR 0 4
69474: ARRAY
69475: PPUSH
69476: CALL_OW 254
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: PUSH
69487: EMPTY
69488: LIST
69489: ADD
69490: ST_TO_ADDR
69491: GO 69404
69493: POP
69494: POP
// result := list ;
69495: LD_ADDR_VAR 0 2
69499: PUSH
69500: LD_VAR 0 5
69504: ST_TO_ADDR
// end ;
69505: LD_VAR 0 2
69509: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69510: LD_INT 0
69512: PPUSH
69513: PPUSH
69514: PPUSH
69515: PPUSH
69516: PPUSH
69517: PPUSH
69518: PPUSH
// if not factory then
69519: LD_VAR 0 1
69523: NOT
69524: IFFALSE 69528
// exit ;
69526: GO 70121
// if control = control_apeman then
69528: LD_VAR 0 4
69532: PUSH
69533: LD_INT 5
69535: EQUAL
69536: IFFALSE 69645
// begin tmp := UnitsInside ( factory ) ;
69538: LD_ADDR_VAR 0 8
69542: PUSH
69543: LD_VAR 0 1
69547: PPUSH
69548: CALL_OW 313
69552: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69553: LD_VAR 0 8
69557: PPUSH
69558: LD_INT 25
69560: PUSH
69561: LD_INT 12
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PPUSH
69568: CALL_OW 72
69572: NOT
69573: IFFALSE 69583
// control := control_manual ;
69575: LD_ADDR_VAR 0 4
69579: PUSH
69580: LD_INT 1
69582: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69583: LD_ADDR_VAR 0 8
69587: PUSH
69588: LD_VAR 0 1
69592: PPUSH
69593: CALL 69280 0 1
69597: ST_TO_ADDR
// if tmp then
69598: LD_VAR 0 8
69602: IFFALSE 69645
// begin for i in tmp do
69604: LD_ADDR_VAR 0 7
69608: PUSH
69609: LD_VAR 0 8
69613: PUSH
69614: FOR_IN
69615: IFFALSE 69643
// if i [ 1 ] = b_ext_radio then
69617: LD_VAR 0 7
69621: PUSH
69622: LD_INT 1
69624: ARRAY
69625: PUSH
69626: LD_INT 22
69628: EQUAL
69629: IFFALSE 69641
// begin control := control_remote ;
69631: LD_ADDR_VAR 0 4
69635: PUSH
69636: LD_INT 2
69638: ST_TO_ADDR
// break ;
69639: GO 69643
// end ;
69641: GO 69614
69643: POP
69644: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69645: LD_VAR 0 1
69649: PPUSH
69650: LD_VAR 0 2
69654: PPUSH
69655: LD_VAR 0 3
69659: PPUSH
69660: LD_VAR 0 4
69664: PPUSH
69665: LD_VAR 0 5
69669: PPUSH
69670: CALL_OW 448
69674: IFFALSE 69709
// begin result := [ chassis , engine , control , weapon ] ;
69676: LD_ADDR_VAR 0 6
69680: PUSH
69681: LD_VAR 0 2
69685: PUSH
69686: LD_VAR 0 3
69690: PUSH
69691: LD_VAR 0 4
69695: PUSH
69696: LD_VAR 0 5
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: ST_TO_ADDR
// exit ;
69707: GO 70121
// end ; _chassis := AvailableChassisList ( factory ) ;
69709: LD_ADDR_VAR 0 9
69713: PUSH
69714: LD_VAR 0 1
69718: PPUSH
69719: CALL_OW 475
69723: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69724: LD_ADDR_VAR 0 11
69728: PUSH
69729: LD_VAR 0 1
69733: PPUSH
69734: CALL_OW 476
69738: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69739: LD_ADDR_VAR 0 12
69743: PUSH
69744: LD_VAR 0 1
69748: PPUSH
69749: CALL_OW 477
69753: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69754: LD_ADDR_VAR 0 10
69758: PUSH
69759: LD_VAR 0 1
69763: PPUSH
69764: CALL_OW 478
69768: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69769: LD_VAR 0 9
69773: NOT
69774: PUSH
69775: LD_VAR 0 11
69779: NOT
69780: OR
69781: PUSH
69782: LD_VAR 0 12
69786: NOT
69787: OR
69788: PUSH
69789: LD_VAR 0 10
69793: NOT
69794: OR
69795: IFFALSE 69830
// begin result := [ chassis , engine , control , weapon ] ;
69797: LD_ADDR_VAR 0 6
69801: PUSH
69802: LD_VAR 0 2
69806: PUSH
69807: LD_VAR 0 3
69811: PUSH
69812: LD_VAR 0 4
69816: PUSH
69817: LD_VAR 0 5
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: ST_TO_ADDR
// exit ;
69828: GO 70121
// end ; if not chassis in _chassis then
69830: LD_VAR 0 2
69834: PUSH
69835: LD_VAR 0 9
69839: IN
69840: NOT
69841: IFFALSE 69867
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69843: LD_ADDR_VAR 0 2
69847: PUSH
69848: LD_VAR 0 9
69852: PUSH
69853: LD_INT 1
69855: PPUSH
69856: LD_VAR 0 9
69860: PPUSH
69861: CALL_OW 12
69865: ARRAY
69866: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69867: LD_VAR 0 2
69871: PPUSH
69872: LD_VAR 0 3
69876: PPUSH
69877: CALL 70126 0 2
69881: NOT
69882: IFFALSE 69941
// repeat engine := _engine [ 1 ] ;
69884: LD_ADDR_VAR 0 3
69888: PUSH
69889: LD_VAR 0 11
69893: PUSH
69894: LD_INT 1
69896: ARRAY
69897: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69898: LD_ADDR_VAR 0 11
69902: PUSH
69903: LD_VAR 0 11
69907: PPUSH
69908: LD_INT 1
69910: PPUSH
69911: CALL_OW 3
69915: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69916: LD_VAR 0 2
69920: PPUSH
69921: LD_VAR 0 3
69925: PPUSH
69926: CALL 70126 0 2
69930: PUSH
69931: LD_VAR 0 11
69935: PUSH
69936: EMPTY
69937: EQUAL
69938: OR
69939: IFFALSE 69884
// if not control in _control then
69941: LD_VAR 0 4
69945: PUSH
69946: LD_VAR 0 12
69950: IN
69951: NOT
69952: IFFALSE 69978
// control := _control [ rand ( 1 , _control ) ] ;
69954: LD_ADDR_VAR 0 4
69958: PUSH
69959: LD_VAR 0 12
69963: PUSH
69964: LD_INT 1
69966: PPUSH
69967: LD_VAR 0 12
69971: PPUSH
69972: CALL_OW 12
69976: ARRAY
69977: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69978: LD_VAR 0 2
69982: PPUSH
69983: LD_VAR 0 5
69987: PPUSH
69988: CALL 70346 0 2
69992: NOT
69993: IFFALSE 70052
// repeat weapon := _weapon [ 1 ] ;
69995: LD_ADDR_VAR 0 5
69999: PUSH
70000: LD_VAR 0 10
70004: PUSH
70005: LD_INT 1
70007: ARRAY
70008: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70009: LD_ADDR_VAR 0 10
70013: PUSH
70014: LD_VAR 0 10
70018: PPUSH
70019: LD_INT 1
70021: PPUSH
70022: CALL_OW 3
70026: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70027: LD_VAR 0 2
70031: PPUSH
70032: LD_VAR 0 5
70036: PPUSH
70037: CALL 70346 0 2
70041: PUSH
70042: LD_VAR 0 10
70046: PUSH
70047: EMPTY
70048: EQUAL
70049: OR
70050: IFFALSE 69995
// result := [ ] ;
70052: LD_ADDR_VAR 0 6
70056: PUSH
70057: EMPTY
70058: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70059: LD_VAR 0 1
70063: PPUSH
70064: LD_VAR 0 2
70068: PPUSH
70069: LD_VAR 0 3
70073: PPUSH
70074: LD_VAR 0 4
70078: PPUSH
70079: LD_VAR 0 5
70083: PPUSH
70084: CALL_OW 448
70088: IFFALSE 70121
// result := [ chassis , engine , control , weapon ] ;
70090: LD_ADDR_VAR 0 6
70094: PUSH
70095: LD_VAR 0 2
70099: PUSH
70100: LD_VAR 0 3
70104: PUSH
70105: LD_VAR 0 4
70109: PUSH
70110: LD_VAR 0 5
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: LIST
70119: LIST
70120: ST_TO_ADDR
// end ;
70121: LD_VAR 0 6
70125: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70126: LD_INT 0
70128: PPUSH
// if not chassis or not engine then
70129: LD_VAR 0 1
70133: NOT
70134: PUSH
70135: LD_VAR 0 2
70139: NOT
70140: OR
70141: IFFALSE 70145
// exit ;
70143: GO 70341
// case engine of engine_solar :
70145: LD_VAR 0 2
70149: PUSH
70150: LD_INT 2
70152: DOUBLE
70153: EQUAL
70154: IFTRUE 70158
70156: GO 70196
70158: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70159: LD_ADDR_VAR 0 3
70163: PUSH
70164: LD_INT 11
70166: PUSH
70167: LD_INT 12
70169: PUSH
70170: LD_INT 13
70172: PUSH
70173: LD_INT 14
70175: PUSH
70176: LD_INT 1
70178: PUSH
70179: LD_INT 2
70181: PUSH
70182: LD_INT 3
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: ST_TO_ADDR
70194: GO 70325
70196: LD_INT 1
70198: DOUBLE
70199: EQUAL
70200: IFTRUE 70204
70202: GO 70266
70204: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70205: LD_ADDR_VAR 0 3
70209: PUSH
70210: LD_INT 11
70212: PUSH
70213: LD_INT 12
70215: PUSH
70216: LD_INT 13
70218: PUSH
70219: LD_INT 14
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: LD_INT 2
70227: PUSH
70228: LD_INT 3
70230: PUSH
70231: LD_INT 4
70233: PUSH
70234: LD_INT 5
70236: PUSH
70237: LD_INT 21
70239: PUSH
70240: LD_INT 23
70242: PUSH
70243: LD_INT 22
70245: PUSH
70246: LD_INT 24
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: ST_TO_ADDR
70264: GO 70325
70266: LD_INT 3
70268: DOUBLE
70269: EQUAL
70270: IFTRUE 70274
70272: GO 70324
70274: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70275: LD_ADDR_VAR 0 3
70279: PUSH
70280: LD_INT 13
70282: PUSH
70283: LD_INT 14
70285: PUSH
70286: LD_INT 2
70288: PUSH
70289: LD_INT 3
70291: PUSH
70292: LD_INT 4
70294: PUSH
70295: LD_INT 5
70297: PUSH
70298: LD_INT 21
70300: PUSH
70301: LD_INT 22
70303: PUSH
70304: LD_INT 23
70306: PUSH
70307: LD_INT 24
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: ST_TO_ADDR
70322: GO 70325
70324: POP
// result := ( chassis in result ) ;
70325: LD_ADDR_VAR 0 3
70329: PUSH
70330: LD_VAR 0 1
70334: PUSH
70335: LD_VAR 0 3
70339: IN
70340: ST_TO_ADDR
// end ;
70341: LD_VAR 0 3
70345: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70346: LD_INT 0
70348: PPUSH
// if not chassis or not weapon then
70349: LD_VAR 0 1
70353: NOT
70354: PUSH
70355: LD_VAR 0 2
70359: NOT
70360: OR
70361: IFFALSE 70365
// exit ;
70363: GO 71391
// case weapon of us_machine_gun :
70365: LD_VAR 0 2
70369: PUSH
70370: LD_INT 2
70372: DOUBLE
70373: EQUAL
70374: IFTRUE 70378
70376: GO 70408
70378: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70379: LD_ADDR_VAR 0 3
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: LD_INT 3
70392: PUSH
70393: LD_INT 4
70395: PUSH
70396: LD_INT 5
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: ST_TO_ADDR
70406: GO 71375
70408: LD_INT 3
70410: DOUBLE
70411: EQUAL
70412: IFTRUE 70416
70414: GO 70446
70416: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70417: LD_ADDR_VAR 0 3
70421: PUSH
70422: LD_INT 1
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 3
70430: PUSH
70431: LD_INT 4
70433: PUSH
70434: LD_INT 5
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: ST_TO_ADDR
70444: GO 71375
70446: LD_INT 11
70448: DOUBLE
70449: EQUAL
70450: IFTRUE 70454
70452: GO 70484
70454: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70455: LD_ADDR_VAR 0 3
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: LD_INT 2
70465: PUSH
70466: LD_INT 3
70468: PUSH
70469: LD_INT 4
70471: PUSH
70472: LD_INT 5
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: ST_TO_ADDR
70482: GO 71375
70484: LD_INT 4
70486: DOUBLE
70487: EQUAL
70488: IFTRUE 70492
70490: GO 70518
70492: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70493: LD_ADDR_VAR 0 3
70497: PUSH
70498: LD_INT 2
70500: PUSH
70501: LD_INT 3
70503: PUSH
70504: LD_INT 4
70506: PUSH
70507: LD_INT 5
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: ST_TO_ADDR
70516: GO 71375
70518: LD_INT 5
70520: DOUBLE
70521: EQUAL
70522: IFTRUE 70526
70524: GO 70552
70526: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70527: LD_ADDR_VAR 0 3
70531: PUSH
70532: LD_INT 2
70534: PUSH
70535: LD_INT 3
70537: PUSH
70538: LD_INT 4
70540: PUSH
70541: LD_INT 5
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: ST_TO_ADDR
70550: GO 71375
70552: LD_INT 9
70554: DOUBLE
70555: EQUAL
70556: IFTRUE 70560
70558: GO 70586
70560: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70561: LD_ADDR_VAR 0 3
70565: PUSH
70566: LD_INT 2
70568: PUSH
70569: LD_INT 3
70571: PUSH
70572: LD_INT 4
70574: PUSH
70575: LD_INT 5
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: ST_TO_ADDR
70584: GO 71375
70586: LD_INT 7
70588: DOUBLE
70589: EQUAL
70590: IFTRUE 70594
70592: GO 70620
70594: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70595: LD_ADDR_VAR 0 3
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: LD_INT 4
70608: PUSH
70609: LD_INT 5
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: ST_TO_ADDR
70618: GO 71375
70620: LD_INT 12
70622: DOUBLE
70623: EQUAL
70624: IFTRUE 70628
70626: GO 70654
70628: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70629: LD_ADDR_VAR 0 3
70633: PUSH
70634: LD_INT 2
70636: PUSH
70637: LD_INT 3
70639: PUSH
70640: LD_INT 4
70642: PUSH
70643: LD_INT 5
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: ST_TO_ADDR
70652: GO 71375
70654: LD_INT 13
70656: DOUBLE
70657: EQUAL
70658: IFTRUE 70662
70660: GO 70688
70662: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70663: LD_ADDR_VAR 0 3
70667: PUSH
70668: LD_INT 2
70670: PUSH
70671: LD_INT 3
70673: PUSH
70674: LD_INT 4
70676: PUSH
70677: LD_INT 5
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: ST_TO_ADDR
70686: GO 71375
70688: LD_INT 14
70690: DOUBLE
70691: EQUAL
70692: IFTRUE 70696
70694: GO 70714
70696: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70697: LD_ADDR_VAR 0 3
70701: PUSH
70702: LD_INT 4
70704: PUSH
70705: LD_INT 5
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: ST_TO_ADDR
70712: GO 71375
70714: LD_INT 6
70716: DOUBLE
70717: EQUAL
70718: IFTRUE 70722
70720: GO 70740
70722: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70723: LD_ADDR_VAR 0 3
70727: PUSH
70728: LD_INT 4
70730: PUSH
70731: LD_INT 5
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: ST_TO_ADDR
70738: GO 71375
70740: LD_INT 10
70742: DOUBLE
70743: EQUAL
70744: IFTRUE 70748
70746: GO 70766
70748: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70749: LD_ADDR_VAR 0 3
70753: PUSH
70754: LD_INT 4
70756: PUSH
70757: LD_INT 5
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: ST_TO_ADDR
70764: GO 71375
70766: LD_INT 22
70768: DOUBLE
70769: EQUAL
70770: IFTRUE 70774
70772: GO 70800
70774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70775: LD_ADDR_VAR 0 3
70779: PUSH
70780: LD_INT 11
70782: PUSH
70783: LD_INT 12
70785: PUSH
70786: LD_INT 13
70788: PUSH
70789: LD_INT 14
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: ST_TO_ADDR
70798: GO 71375
70800: LD_INT 23
70802: DOUBLE
70803: EQUAL
70804: IFTRUE 70808
70806: GO 70834
70808: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70809: LD_ADDR_VAR 0 3
70813: PUSH
70814: LD_INT 11
70816: PUSH
70817: LD_INT 12
70819: PUSH
70820: LD_INT 13
70822: PUSH
70823: LD_INT 14
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: LIST
70830: LIST
70831: ST_TO_ADDR
70832: GO 71375
70834: LD_INT 24
70836: DOUBLE
70837: EQUAL
70838: IFTRUE 70842
70840: GO 70868
70842: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70843: LD_ADDR_VAR 0 3
70847: PUSH
70848: LD_INT 11
70850: PUSH
70851: LD_INT 12
70853: PUSH
70854: LD_INT 13
70856: PUSH
70857: LD_INT 14
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: ST_TO_ADDR
70866: GO 71375
70868: LD_INT 30
70870: DOUBLE
70871: EQUAL
70872: IFTRUE 70876
70874: GO 70902
70876: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70877: LD_ADDR_VAR 0 3
70881: PUSH
70882: LD_INT 11
70884: PUSH
70885: LD_INT 12
70887: PUSH
70888: LD_INT 13
70890: PUSH
70891: LD_INT 14
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: ST_TO_ADDR
70900: GO 71375
70902: LD_INT 25
70904: DOUBLE
70905: EQUAL
70906: IFTRUE 70910
70908: GO 70928
70910: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70911: LD_ADDR_VAR 0 3
70915: PUSH
70916: LD_INT 13
70918: PUSH
70919: LD_INT 14
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: ST_TO_ADDR
70926: GO 71375
70928: LD_INT 27
70930: DOUBLE
70931: EQUAL
70932: IFTRUE 70936
70934: GO 70954
70936: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70937: LD_ADDR_VAR 0 3
70941: PUSH
70942: LD_INT 13
70944: PUSH
70945: LD_INT 14
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: ST_TO_ADDR
70952: GO 71375
70954: LD_INT 28
70956: DOUBLE
70957: EQUAL
70958: IFTRUE 70962
70960: GO 70980
70962: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70963: LD_ADDR_VAR 0 3
70967: PUSH
70968: LD_INT 13
70970: PUSH
70971: LD_INT 14
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: ST_TO_ADDR
70978: GO 71375
70980: LD_INT 29
70982: DOUBLE
70983: EQUAL
70984: IFTRUE 70988
70986: GO 71006
70988: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70989: LD_ADDR_VAR 0 3
70993: PUSH
70994: LD_INT 13
70996: PUSH
70997: LD_INT 14
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: ST_TO_ADDR
71004: GO 71375
71006: LD_INT 31
71008: DOUBLE
71009: EQUAL
71010: IFTRUE 71014
71012: GO 71032
71014: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71015: LD_ADDR_VAR 0 3
71019: PUSH
71020: LD_INT 13
71022: PUSH
71023: LD_INT 14
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: ST_TO_ADDR
71030: GO 71375
71032: LD_INT 26
71034: DOUBLE
71035: EQUAL
71036: IFTRUE 71040
71038: GO 71058
71040: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71041: LD_ADDR_VAR 0 3
71045: PUSH
71046: LD_INT 13
71048: PUSH
71049: LD_INT 14
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: ST_TO_ADDR
71056: GO 71375
71058: LD_INT 42
71060: DOUBLE
71061: EQUAL
71062: IFTRUE 71066
71064: GO 71092
71066: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71067: LD_ADDR_VAR 0 3
71071: PUSH
71072: LD_INT 21
71074: PUSH
71075: LD_INT 22
71077: PUSH
71078: LD_INT 23
71080: PUSH
71081: LD_INT 24
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: ST_TO_ADDR
71090: GO 71375
71092: LD_INT 43
71094: DOUBLE
71095: EQUAL
71096: IFTRUE 71100
71098: GO 71126
71100: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71101: LD_ADDR_VAR 0 3
71105: PUSH
71106: LD_INT 21
71108: PUSH
71109: LD_INT 22
71111: PUSH
71112: LD_INT 23
71114: PUSH
71115: LD_INT 24
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: ST_TO_ADDR
71124: GO 71375
71126: LD_INT 44
71128: DOUBLE
71129: EQUAL
71130: IFTRUE 71134
71132: GO 71160
71134: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71135: LD_ADDR_VAR 0 3
71139: PUSH
71140: LD_INT 21
71142: PUSH
71143: LD_INT 22
71145: PUSH
71146: LD_INT 23
71148: PUSH
71149: LD_INT 24
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: ST_TO_ADDR
71158: GO 71375
71160: LD_INT 45
71162: DOUBLE
71163: EQUAL
71164: IFTRUE 71168
71166: GO 71194
71168: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71169: LD_ADDR_VAR 0 3
71173: PUSH
71174: LD_INT 21
71176: PUSH
71177: LD_INT 22
71179: PUSH
71180: LD_INT 23
71182: PUSH
71183: LD_INT 24
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: LIST
71190: LIST
71191: ST_TO_ADDR
71192: GO 71375
71194: LD_INT 49
71196: DOUBLE
71197: EQUAL
71198: IFTRUE 71202
71200: GO 71228
71202: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71203: LD_ADDR_VAR 0 3
71207: PUSH
71208: LD_INT 21
71210: PUSH
71211: LD_INT 22
71213: PUSH
71214: LD_INT 23
71216: PUSH
71217: LD_INT 24
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: ST_TO_ADDR
71226: GO 71375
71228: LD_INT 51
71230: DOUBLE
71231: EQUAL
71232: IFTRUE 71236
71234: GO 71262
71236: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71237: LD_ADDR_VAR 0 3
71241: PUSH
71242: LD_INT 21
71244: PUSH
71245: LD_INT 22
71247: PUSH
71248: LD_INT 23
71250: PUSH
71251: LD_INT 24
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: ST_TO_ADDR
71260: GO 71375
71262: LD_INT 52
71264: DOUBLE
71265: EQUAL
71266: IFTRUE 71270
71268: GO 71296
71270: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71271: LD_ADDR_VAR 0 3
71275: PUSH
71276: LD_INT 21
71278: PUSH
71279: LD_INT 22
71281: PUSH
71282: LD_INT 23
71284: PUSH
71285: LD_INT 24
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: ST_TO_ADDR
71294: GO 71375
71296: LD_INT 53
71298: DOUBLE
71299: EQUAL
71300: IFTRUE 71304
71302: GO 71322
71304: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71305: LD_ADDR_VAR 0 3
71309: PUSH
71310: LD_INT 23
71312: PUSH
71313: LD_INT 24
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: ST_TO_ADDR
71320: GO 71375
71322: LD_INT 46
71324: DOUBLE
71325: EQUAL
71326: IFTRUE 71330
71328: GO 71348
71330: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71331: LD_ADDR_VAR 0 3
71335: PUSH
71336: LD_INT 23
71338: PUSH
71339: LD_INT 24
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: ST_TO_ADDR
71346: GO 71375
71348: LD_INT 47
71350: DOUBLE
71351: EQUAL
71352: IFTRUE 71356
71354: GO 71374
71356: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71357: LD_ADDR_VAR 0 3
71361: PUSH
71362: LD_INT 23
71364: PUSH
71365: LD_INT 24
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: ST_TO_ADDR
71372: GO 71375
71374: POP
// result := ( chassis in result ) ;
71375: LD_ADDR_VAR 0 3
71379: PUSH
71380: LD_VAR 0 1
71384: PUSH
71385: LD_VAR 0 3
71389: IN
71390: ST_TO_ADDR
// end ;
71391: LD_VAR 0 3
71395: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71396: LD_INT 0
71398: PPUSH
71399: PPUSH
71400: PPUSH
71401: PPUSH
71402: PPUSH
71403: PPUSH
71404: PPUSH
// result := array ;
71405: LD_ADDR_VAR 0 5
71409: PUSH
71410: LD_VAR 0 1
71414: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71415: LD_VAR 0 1
71419: NOT
71420: PUSH
71421: LD_VAR 0 2
71425: NOT
71426: OR
71427: PUSH
71428: LD_VAR 0 3
71432: NOT
71433: OR
71434: PUSH
71435: LD_VAR 0 2
71439: PUSH
71440: LD_VAR 0 1
71444: GREATER
71445: OR
71446: PUSH
71447: LD_VAR 0 3
71451: PUSH
71452: LD_VAR 0 1
71456: GREATER
71457: OR
71458: IFFALSE 71462
// exit ;
71460: GO 71758
// if direction then
71462: LD_VAR 0 4
71466: IFFALSE 71530
// begin d := 1 ;
71468: LD_ADDR_VAR 0 9
71472: PUSH
71473: LD_INT 1
71475: ST_TO_ADDR
// if i_from > i_to then
71476: LD_VAR 0 2
71480: PUSH
71481: LD_VAR 0 3
71485: GREATER
71486: IFFALSE 71512
// length := ( array - i_from ) + i_to else
71488: LD_ADDR_VAR 0 11
71492: PUSH
71493: LD_VAR 0 1
71497: PUSH
71498: LD_VAR 0 2
71502: MINUS
71503: PUSH
71504: LD_VAR 0 3
71508: PLUS
71509: ST_TO_ADDR
71510: GO 71528
// length := i_to - i_from ;
71512: LD_ADDR_VAR 0 11
71516: PUSH
71517: LD_VAR 0 3
71521: PUSH
71522: LD_VAR 0 2
71526: MINUS
71527: ST_TO_ADDR
// end else
71528: GO 71591
// begin d := - 1 ;
71530: LD_ADDR_VAR 0 9
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: ST_TO_ADDR
// if i_from > i_to then
71539: LD_VAR 0 2
71543: PUSH
71544: LD_VAR 0 3
71548: GREATER
71549: IFFALSE 71569
// length := i_from - i_to else
71551: LD_ADDR_VAR 0 11
71555: PUSH
71556: LD_VAR 0 2
71560: PUSH
71561: LD_VAR 0 3
71565: MINUS
71566: ST_TO_ADDR
71567: GO 71591
// length := ( array - i_to ) + i_from ;
71569: LD_ADDR_VAR 0 11
71573: PUSH
71574: LD_VAR 0 1
71578: PUSH
71579: LD_VAR 0 3
71583: MINUS
71584: PUSH
71585: LD_VAR 0 2
71589: PLUS
71590: ST_TO_ADDR
// end ; if not length then
71591: LD_VAR 0 11
71595: NOT
71596: IFFALSE 71600
// exit ;
71598: GO 71758
// tmp := array ;
71600: LD_ADDR_VAR 0 10
71604: PUSH
71605: LD_VAR 0 1
71609: ST_TO_ADDR
// for i = 1 to length do
71610: LD_ADDR_VAR 0 6
71614: PUSH
71615: DOUBLE
71616: LD_INT 1
71618: DEC
71619: ST_TO_ADDR
71620: LD_VAR 0 11
71624: PUSH
71625: FOR_TO
71626: IFFALSE 71746
// begin for j = 1 to array do
71628: LD_ADDR_VAR 0 7
71632: PUSH
71633: DOUBLE
71634: LD_INT 1
71636: DEC
71637: ST_TO_ADDR
71638: LD_VAR 0 1
71642: PUSH
71643: FOR_TO
71644: IFFALSE 71732
// begin k := j + d ;
71646: LD_ADDR_VAR 0 8
71650: PUSH
71651: LD_VAR 0 7
71655: PUSH
71656: LD_VAR 0 9
71660: PLUS
71661: ST_TO_ADDR
// if k > array then
71662: LD_VAR 0 8
71666: PUSH
71667: LD_VAR 0 1
71671: GREATER
71672: IFFALSE 71682
// k := 1 ;
71674: LD_ADDR_VAR 0 8
71678: PUSH
71679: LD_INT 1
71681: ST_TO_ADDR
// if not k then
71682: LD_VAR 0 8
71686: NOT
71687: IFFALSE 71699
// k := array ;
71689: LD_ADDR_VAR 0 8
71693: PUSH
71694: LD_VAR 0 1
71698: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71699: LD_ADDR_VAR 0 10
71703: PUSH
71704: LD_VAR 0 10
71708: PPUSH
71709: LD_VAR 0 8
71713: PPUSH
71714: LD_VAR 0 1
71718: PUSH
71719: LD_VAR 0 7
71723: ARRAY
71724: PPUSH
71725: CALL_OW 1
71729: ST_TO_ADDR
// end ;
71730: GO 71643
71732: POP
71733: POP
// array := tmp ;
71734: LD_ADDR_VAR 0 1
71738: PUSH
71739: LD_VAR 0 10
71743: ST_TO_ADDR
// end ;
71744: GO 71625
71746: POP
71747: POP
// result := array ;
71748: LD_ADDR_VAR 0 5
71752: PUSH
71753: LD_VAR 0 1
71757: ST_TO_ADDR
// end ;
71758: LD_VAR 0 5
71762: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71763: LD_INT 0
71765: PPUSH
71766: PPUSH
// result := 0 ;
71767: LD_ADDR_VAR 0 3
71771: PUSH
71772: LD_INT 0
71774: ST_TO_ADDR
// if not array or not value in array then
71775: LD_VAR 0 1
71779: NOT
71780: PUSH
71781: LD_VAR 0 2
71785: PUSH
71786: LD_VAR 0 1
71790: IN
71791: NOT
71792: OR
71793: IFFALSE 71797
// exit ;
71795: GO 71851
// for i = 1 to array do
71797: LD_ADDR_VAR 0 4
71801: PUSH
71802: DOUBLE
71803: LD_INT 1
71805: DEC
71806: ST_TO_ADDR
71807: LD_VAR 0 1
71811: PUSH
71812: FOR_TO
71813: IFFALSE 71849
// if value = array [ i ] then
71815: LD_VAR 0 2
71819: PUSH
71820: LD_VAR 0 1
71824: PUSH
71825: LD_VAR 0 4
71829: ARRAY
71830: EQUAL
71831: IFFALSE 71847
// begin result := i ;
71833: LD_ADDR_VAR 0 3
71837: PUSH
71838: LD_VAR 0 4
71842: ST_TO_ADDR
// exit ;
71843: POP
71844: POP
71845: GO 71851
// end ;
71847: GO 71812
71849: POP
71850: POP
// end ;
71851: LD_VAR 0 3
71855: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71856: LD_INT 0
71858: PPUSH
// vc_chassis := chassis ;
71859: LD_ADDR_OWVAR 37
71863: PUSH
71864: LD_VAR 0 1
71868: ST_TO_ADDR
// vc_engine := engine ;
71869: LD_ADDR_OWVAR 39
71873: PUSH
71874: LD_VAR 0 2
71878: ST_TO_ADDR
// vc_control := control ;
71879: LD_ADDR_OWVAR 38
71883: PUSH
71884: LD_VAR 0 3
71888: ST_TO_ADDR
// vc_weapon := weapon ;
71889: LD_ADDR_OWVAR 40
71893: PUSH
71894: LD_VAR 0 4
71898: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71899: LD_ADDR_OWVAR 41
71903: PUSH
71904: LD_VAR 0 5
71908: ST_TO_ADDR
// end ;
71909: LD_VAR 0 6
71913: RET
// export function WantPlant ( unit ) ; var task ; begin
71914: LD_INT 0
71916: PPUSH
71917: PPUSH
// result := false ;
71918: LD_ADDR_VAR 0 2
71922: PUSH
71923: LD_INT 0
71925: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71926: LD_ADDR_VAR 0 3
71930: PUSH
71931: LD_VAR 0 1
71935: PPUSH
71936: CALL_OW 437
71940: ST_TO_ADDR
// if task then
71941: LD_VAR 0 3
71945: IFFALSE 71973
// if task [ 1 ] [ 1 ] = p then
71947: LD_VAR 0 3
71951: PUSH
71952: LD_INT 1
71954: ARRAY
71955: PUSH
71956: LD_INT 1
71958: ARRAY
71959: PUSH
71960: LD_STRING p
71962: EQUAL
71963: IFFALSE 71973
// result := true ;
71965: LD_ADDR_VAR 0 2
71969: PUSH
71970: LD_INT 1
71972: ST_TO_ADDR
// end ;
71973: LD_VAR 0 2
71977: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71978: LD_INT 0
71980: PPUSH
71981: PPUSH
71982: PPUSH
71983: PPUSH
// if pos < 1 then
71984: LD_VAR 0 2
71988: PUSH
71989: LD_INT 1
71991: LESS
71992: IFFALSE 71996
// exit ;
71994: GO 72299
// if pos = 1 then
71996: LD_VAR 0 2
72000: PUSH
72001: LD_INT 1
72003: EQUAL
72004: IFFALSE 72037
// result := Replace ( arr , pos [ 1 ] , value ) else
72006: LD_ADDR_VAR 0 4
72010: PUSH
72011: LD_VAR 0 1
72015: PPUSH
72016: LD_VAR 0 2
72020: PUSH
72021: LD_INT 1
72023: ARRAY
72024: PPUSH
72025: LD_VAR 0 3
72029: PPUSH
72030: CALL_OW 1
72034: ST_TO_ADDR
72035: GO 72299
// begin tmp := arr ;
72037: LD_ADDR_VAR 0 6
72041: PUSH
72042: LD_VAR 0 1
72046: ST_TO_ADDR
// s_arr := [ tmp ] ;
72047: LD_ADDR_VAR 0 7
72051: PUSH
72052: LD_VAR 0 6
72056: PUSH
72057: EMPTY
72058: LIST
72059: ST_TO_ADDR
// for i = 1 to pos - 1 do
72060: LD_ADDR_VAR 0 5
72064: PUSH
72065: DOUBLE
72066: LD_INT 1
72068: DEC
72069: ST_TO_ADDR
72070: LD_VAR 0 2
72074: PUSH
72075: LD_INT 1
72077: MINUS
72078: PUSH
72079: FOR_TO
72080: IFFALSE 72125
// begin tmp := tmp [ pos [ i ] ] ;
72082: LD_ADDR_VAR 0 6
72086: PUSH
72087: LD_VAR 0 6
72091: PUSH
72092: LD_VAR 0 2
72096: PUSH
72097: LD_VAR 0 5
72101: ARRAY
72102: ARRAY
72103: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72104: LD_ADDR_VAR 0 7
72108: PUSH
72109: LD_VAR 0 7
72113: PUSH
72114: LD_VAR 0 6
72118: PUSH
72119: EMPTY
72120: LIST
72121: ADD
72122: ST_TO_ADDR
// end ;
72123: GO 72079
72125: POP
72126: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72127: LD_ADDR_VAR 0 6
72131: PUSH
72132: LD_VAR 0 6
72136: PPUSH
72137: LD_VAR 0 2
72141: PUSH
72142: LD_VAR 0 2
72146: ARRAY
72147: PPUSH
72148: LD_VAR 0 3
72152: PPUSH
72153: CALL_OW 1
72157: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72158: LD_ADDR_VAR 0 7
72162: PUSH
72163: LD_VAR 0 7
72167: PPUSH
72168: LD_VAR 0 7
72172: PPUSH
72173: LD_VAR 0 6
72177: PPUSH
72178: CALL_OW 1
72182: ST_TO_ADDR
// for i = s_arr downto 2 do
72183: LD_ADDR_VAR 0 5
72187: PUSH
72188: DOUBLE
72189: LD_VAR 0 7
72193: INC
72194: ST_TO_ADDR
72195: LD_INT 2
72197: PUSH
72198: FOR_DOWNTO
72199: IFFALSE 72283
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72201: LD_ADDR_VAR 0 6
72205: PUSH
72206: LD_VAR 0 7
72210: PUSH
72211: LD_VAR 0 5
72215: PUSH
72216: LD_INT 1
72218: MINUS
72219: ARRAY
72220: PPUSH
72221: LD_VAR 0 2
72225: PUSH
72226: LD_VAR 0 5
72230: PUSH
72231: LD_INT 1
72233: MINUS
72234: ARRAY
72235: PPUSH
72236: LD_VAR 0 7
72240: PUSH
72241: LD_VAR 0 5
72245: ARRAY
72246: PPUSH
72247: CALL_OW 1
72251: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72252: LD_ADDR_VAR 0 7
72256: PUSH
72257: LD_VAR 0 7
72261: PPUSH
72262: LD_VAR 0 5
72266: PUSH
72267: LD_INT 1
72269: MINUS
72270: PPUSH
72271: LD_VAR 0 6
72275: PPUSH
72276: CALL_OW 1
72280: ST_TO_ADDR
// end ;
72281: GO 72198
72283: POP
72284: POP
// result := s_arr [ 1 ] ;
72285: LD_ADDR_VAR 0 4
72289: PUSH
72290: LD_VAR 0 7
72294: PUSH
72295: LD_INT 1
72297: ARRAY
72298: ST_TO_ADDR
// end ; end ;
72299: LD_VAR 0 4
72303: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72304: LD_INT 0
72306: PPUSH
72307: PPUSH
// if not list then
72308: LD_VAR 0 1
72312: NOT
72313: IFFALSE 72317
// exit ;
72315: GO 72408
// i := list [ pos1 ] ;
72317: LD_ADDR_VAR 0 5
72321: PUSH
72322: LD_VAR 0 1
72326: PUSH
72327: LD_VAR 0 2
72331: ARRAY
72332: ST_TO_ADDR
// if not i then
72333: LD_VAR 0 5
72337: NOT
72338: IFFALSE 72342
// exit ;
72340: GO 72408
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72342: LD_ADDR_VAR 0 1
72346: PUSH
72347: LD_VAR 0 1
72351: PPUSH
72352: LD_VAR 0 2
72356: PPUSH
72357: LD_VAR 0 1
72361: PUSH
72362: LD_VAR 0 3
72366: ARRAY
72367: PPUSH
72368: CALL_OW 1
72372: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72373: LD_ADDR_VAR 0 1
72377: PUSH
72378: LD_VAR 0 1
72382: PPUSH
72383: LD_VAR 0 3
72387: PPUSH
72388: LD_VAR 0 5
72392: PPUSH
72393: CALL_OW 1
72397: ST_TO_ADDR
// result := list ;
72398: LD_ADDR_VAR 0 4
72402: PUSH
72403: LD_VAR 0 1
72407: ST_TO_ADDR
// end ;
72408: LD_VAR 0 4
72412: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72413: LD_INT 0
72415: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72416: LD_ADDR_VAR 0 5
72420: PUSH
72421: LD_VAR 0 1
72425: PPUSH
72426: CALL_OW 250
72430: PPUSH
72431: LD_VAR 0 1
72435: PPUSH
72436: CALL_OW 251
72440: PPUSH
72441: LD_VAR 0 2
72445: PPUSH
72446: LD_VAR 0 3
72450: PPUSH
72451: LD_VAR 0 4
72455: PPUSH
72456: CALL 72466 0 5
72460: ST_TO_ADDR
// end ;
72461: LD_VAR 0 5
72465: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72466: LD_INT 0
72468: PPUSH
72469: PPUSH
72470: PPUSH
72471: PPUSH
// if not list then
72472: LD_VAR 0 3
72476: NOT
72477: IFFALSE 72481
// exit ;
72479: GO 72869
// result := [ ] ;
72481: LD_ADDR_VAR 0 6
72485: PUSH
72486: EMPTY
72487: ST_TO_ADDR
// for i in list do
72488: LD_ADDR_VAR 0 7
72492: PUSH
72493: LD_VAR 0 3
72497: PUSH
72498: FOR_IN
72499: IFFALSE 72701
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72501: LD_ADDR_VAR 0 9
72505: PUSH
72506: LD_VAR 0 7
72510: PPUSH
72511: LD_VAR 0 1
72515: PPUSH
72516: LD_VAR 0 2
72520: PPUSH
72521: CALL_OW 297
72525: ST_TO_ADDR
// if not result then
72526: LD_VAR 0 6
72530: NOT
72531: IFFALSE 72557
// result := [ [ i , tmp ] ] else
72533: LD_ADDR_VAR 0 6
72537: PUSH
72538: LD_VAR 0 7
72542: PUSH
72543: LD_VAR 0 9
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: EMPTY
72553: LIST
72554: ST_TO_ADDR
72555: GO 72699
// begin if result [ result ] [ 2 ] < tmp then
72557: LD_VAR 0 6
72561: PUSH
72562: LD_VAR 0 6
72566: ARRAY
72567: PUSH
72568: LD_INT 2
72570: ARRAY
72571: PUSH
72572: LD_VAR 0 9
72576: LESS
72577: IFFALSE 72619
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72579: LD_ADDR_VAR 0 6
72583: PUSH
72584: LD_VAR 0 6
72588: PPUSH
72589: LD_VAR 0 6
72593: PUSH
72594: LD_INT 1
72596: PLUS
72597: PPUSH
72598: LD_VAR 0 7
72602: PUSH
72603: LD_VAR 0 9
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PPUSH
72612: CALL_OW 2
72616: ST_TO_ADDR
72617: GO 72699
// for j = 1 to result do
72619: LD_ADDR_VAR 0 8
72623: PUSH
72624: DOUBLE
72625: LD_INT 1
72627: DEC
72628: ST_TO_ADDR
72629: LD_VAR 0 6
72633: PUSH
72634: FOR_TO
72635: IFFALSE 72697
// begin if tmp < result [ j ] [ 2 ] then
72637: LD_VAR 0 9
72641: PUSH
72642: LD_VAR 0 6
72646: PUSH
72647: LD_VAR 0 8
72651: ARRAY
72652: PUSH
72653: LD_INT 2
72655: ARRAY
72656: LESS
72657: IFFALSE 72695
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72659: LD_ADDR_VAR 0 6
72663: PUSH
72664: LD_VAR 0 6
72668: PPUSH
72669: LD_VAR 0 8
72673: PPUSH
72674: LD_VAR 0 7
72678: PUSH
72679: LD_VAR 0 9
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PPUSH
72688: CALL_OW 2
72692: ST_TO_ADDR
// break ;
72693: GO 72697
// end ; end ;
72695: GO 72634
72697: POP
72698: POP
// end ; end ;
72699: GO 72498
72701: POP
72702: POP
// if result and not asc then
72703: LD_VAR 0 6
72707: PUSH
72708: LD_VAR 0 4
72712: NOT
72713: AND
72714: IFFALSE 72789
// begin tmp := result ;
72716: LD_ADDR_VAR 0 9
72720: PUSH
72721: LD_VAR 0 6
72725: ST_TO_ADDR
// for i = tmp downto 1 do
72726: LD_ADDR_VAR 0 7
72730: PUSH
72731: DOUBLE
72732: LD_VAR 0 9
72736: INC
72737: ST_TO_ADDR
72738: LD_INT 1
72740: PUSH
72741: FOR_DOWNTO
72742: IFFALSE 72787
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72744: LD_ADDR_VAR 0 6
72748: PUSH
72749: LD_VAR 0 6
72753: PPUSH
72754: LD_VAR 0 9
72758: PUSH
72759: LD_VAR 0 7
72763: MINUS
72764: PUSH
72765: LD_INT 1
72767: PLUS
72768: PPUSH
72769: LD_VAR 0 9
72773: PUSH
72774: LD_VAR 0 7
72778: ARRAY
72779: PPUSH
72780: CALL_OW 1
72784: ST_TO_ADDR
72785: GO 72741
72787: POP
72788: POP
// end ; tmp := [ ] ;
72789: LD_ADDR_VAR 0 9
72793: PUSH
72794: EMPTY
72795: ST_TO_ADDR
// if mode then
72796: LD_VAR 0 5
72800: IFFALSE 72869
// begin for i = 1 to result do
72802: LD_ADDR_VAR 0 7
72806: PUSH
72807: DOUBLE
72808: LD_INT 1
72810: DEC
72811: ST_TO_ADDR
72812: LD_VAR 0 6
72816: PUSH
72817: FOR_TO
72818: IFFALSE 72857
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72820: LD_ADDR_VAR 0 9
72824: PUSH
72825: LD_VAR 0 9
72829: PPUSH
72830: LD_VAR 0 7
72834: PPUSH
72835: LD_VAR 0 6
72839: PUSH
72840: LD_VAR 0 7
72844: ARRAY
72845: PUSH
72846: LD_INT 1
72848: ARRAY
72849: PPUSH
72850: CALL_OW 1
72854: ST_TO_ADDR
72855: GO 72817
72857: POP
72858: POP
// result := tmp ;
72859: LD_ADDR_VAR 0 6
72863: PUSH
72864: LD_VAR 0 9
72868: ST_TO_ADDR
// end ; end ;
72869: LD_VAR 0 6
72873: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72874: LD_INT 0
72876: PPUSH
72877: PPUSH
72878: PPUSH
72879: PPUSH
72880: PPUSH
72881: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72882: LD_ADDR_VAR 0 5
72886: PUSH
72887: LD_INT 0
72889: PUSH
72890: LD_INT 0
72892: PUSH
72893: LD_INT 0
72895: PUSH
72896: EMPTY
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: ST_TO_ADDR
// if not x or not y then
72904: LD_VAR 0 2
72908: NOT
72909: PUSH
72910: LD_VAR 0 3
72914: NOT
72915: OR
72916: IFFALSE 72920
// exit ;
72918: GO 74566
// if not range then
72920: LD_VAR 0 4
72924: NOT
72925: IFFALSE 72935
// range := 10 ;
72927: LD_ADDR_VAR 0 4
72931: PUSH
72932: LD_INT 10
72934: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72935: LD_ADDR_VAR 0 8
72939: PUSH
72940: LD_INT 81
72942: PUSH
72943: LD_VAR 0 1
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 92
72954: PUSH
72955: LD_VAR 0 2
72959: PUSH
72960: LD_VAR 0 3
72964: PUSH
72965: LD_VAR 0 4
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 3
72978: PUSH
72979: LD_INT 21
72981: PUSH
72982: LD_INT 3
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: LIST
72997: PPUSH
72998: CALL_OW 69
73002: ST_TO_ADDR
// if not tmp then
73003: LD_VAR 0 8
73007: NOT
73008: IFFALSE 73012
// exit ;
73010: GO 74566
// for i in tmp do
73012: LD_ADDR_VAR 0 6
73016: PUSH
73017: LD_VAR 0 8
73021: PUSH
73022: FOR_IN
73023: IFFALSE 74541
// begin points := [ 0 , 0 , 0 ] ;
73025: LD_ADDR_VAR 0 9
73029: PUSH
73030: LD_INT 0
73032: PUSH
73033: LD_INT 0
73035: PUSH
73036: LD_INT 0
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: LIST
73043: ST_TO_ADDR
// bpoints := 1 ;
73044: LD_ADDR_VAR 0 10
73048: PUSH
73049: LD_INT 1
73051: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73052: LD_VAR 0 6
73056: PPUSH
73057: CALL_OW 247
73061: PUSH
73062: LD_INT 1
73064: DOUBLE
73065: EQUAL
73066: IFTRUE 73070
73068: GO 73648
73070: POP
// begin if GetClass ( i ) = 1 then
73071: LD_VAR 0 6
73075: PPUSH
73076: CALL_OW 257
73080: PUSH
73081: LD_INT 1
73083: EQUAL
73084: IFFALSE 73105
// points := [ 10 , 5 , 3 ] ;
73086: LD_ADDR_VAR 0 9
73090: PUSH
73091: LD_INT 10
73093: PUSH
73094: LD_INT 5
73096: PUSH
73097: LD_INT 3
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: LIST
73104: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73105: LD_VAR 0 6
73109: PPUSH
73110: CALL_OW 257
73114: PUSH
73115: LD_INT 2
73117: PUSH
73118: LD_INT 3
73120: PUSH
73121: LD_INT 4
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: LIST
73128: IN
73129: IFFALSE 73150
// points := [ 3 , 2 , 1 ] ;
73131: LD_ADDR_VAR 0 9
73135: PUSH
73136: LD_INT 3
73138: PUSH
73139: LD_INT 2
73141: PUSH
73142: LD_INT 1
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: LIST
73149: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73150: LD_VAR 0 6
73154: PPUSH
73155: CALL_OW 257
73159: PUSH
73160: LD_INT 5
73162: EQUAL
73163: IFFALSE 73184
// points := [ 130 , 5 , 2 ] ;
73165: LD_ADDR_VAR 0 9
73169: PUSH
73170: LD_INT 130
73172: PUSH
73173: LD_INT 5
73175: PUSH
73176: LD_INT 2
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: LIST
73183: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73184: LD_VAR 0 6
73188: PPUSH
73189: CALL_OW 257
73193: PUSH
73194: LD_INT 8
73196: EQUAL
73197: IFFALSE 73218
// points := [ 35 , 35 , 30 ] ;
73199: LD_ADDR_VAR 0 9
73203: PUSH
73204: LD_INT 35
73206: PUSH
73207: LD_INT 35
73209: PUSH
73210: LD_INT 30
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: LIST
73217: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73218: LD_VAR 0 6
73222: PPUSH
73223: CALL_OW 257
73227: PUSH
73228: LD_INT 9
73230: EQUAL
73231: IFFALSE 73252
// points := [ 20 , 55 , 40 ] ;
73233: LD_ADDR_VAR 0 9
73237: PUSH
73238: LD_INT 20
73240: PUSH
73241: LD_INT 55
73243: PUSH
73244: LD_INT 40
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: LIST
73251: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73252: LD_VAR 0 6
73256: PPUSH
73257: CALL_OW 257
73261: PUSH
73262: LD_INT 12
73264: PUSH
73265: LD_INT 16
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: IN
73272: IFFALSE 73293
// points := [ 5 , 3 , 2 ] ;
73274: LD_ADDR_VAR 0 9
73278: PUSH
73279: LD_INT 5
73281: PUSH
73282: LD_INT 3
73284: PUSH
73285: LD_INT 2
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73293: LD_VAR 0 6
73297: PPUSH
73298: CALL_OW 257
73302: PUSH
73303: LD_INT 17
73305: EQUAL
73306: IFFALSE 73327
// points := [ 100 , 50 , 75 ] ;
73308: LD_ADDR_VAR 0 9
73312: PUSH
73313: LD_INT 100
73315: PUSH
73316: LD_INT 50
73318: PUSH
73319: LD_INT 75
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: LIST
73326: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73327: LD_VAR 0 6
73331: PPUSH
73332: CALL_OW 257
73336: PUSH
73337: LD_INT 15
73339: EQUAL
73340: IFFALSE 73361
// points := [ 10 , 5 , 3 ] ;
73342: LD_ADDR_VAR 0 9
73346: PUSH
73347: LD_INT 10
73349: PUSH
73350: LD_INT 5
73352: PUSH
73353: LD_INT 3
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: LIST
73360: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73361: LD_VAR 0 6
73365: PPUSH
73366: CALL_OW 257
73370: PUSH
73371: LD_INT 14
73373: EQUAL
73374: IFFALSE 73395
// points := [ 10 , 0 , 0 ] ;
73376: LD_ADDR_VAR 0 9
73380: PUSH
73381: LD_INT 10
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: LIST
73394: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73395: LD_VAR 0 6
73399: PPUSH
73400: CALL_OW 257
73404: PUSH
73405: LD_INT 11
73407: EQUAL
73408: IFFALSE 73429
// points := [ 30 , 10 , 5 ] ;
73410: LD_ADDR_VAR 0 9
73414: PUSH
73415: LD_INT 30
73417: PUSH
73418: LD_INT 10
73420: PUSH
73421: LD_INT 5
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: LIST
73428: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73429: LD_VAR 0 1
73433: PPUSH
73434: LD_INT 5
73436: PPUSH
73437: CALL_OW 321
73441: PUSH
73442: LD_INT 2
73444: EQUAL
73445: IFFALSE 73462
// bpoints := bpoints * 1.8 ;
73447: LD_ADDR_VAR 0 10
73451: PUSH
73452: LD_VAR 0 10
73456: PUSH
73457: LD_REAL  1.80000000000000E+0000
73460: MUL
73461: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73462: LD_VAR 0 6
73466: PPUSH
73467: CALL_OW 257
73471: PUSH
73472: LD_INT 1
73474: PUSH
73475: LD_INT 2
73477: PUSH
73478: LD_INT 3
73480: PUSH
73481: LD_INT 4
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: IN
73490: PUSH
73491: LD_VAR 0 1
73495: PPUSH
73496: LD_INT 51
73498: PPUSH
73499: CALL_OW 321
73503: PUSH
73504: LD_INT 2
73506: EQUAL
73507: AND
73508: IFFALSE 73525
// bpoints := bpoints * 1.2 ;
73510: LD_ADDR_VAR 0 10
73514: PUSH
73515: LD_VAR 0 10
73519: PUSH
73520: LD_REAL  1.20000000000000E+0000
73523: MUL
73524: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73525: LD_VAR 0 6
73529: PPUSH
73530: CALL_OW 257
73534: PUSH
73535: LD_INT 5
73537: PUSH
73538: LD_INT 7
73540: PUSH
73541: LD_INT 9
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: IN
73549: PUSH
73550: LD_VAR 0 1
73554: PPUSH
73555: LD_INT 52
73557: PPUSH
73558: CALL_OW 321
73562: PUSH
73563: LD_INT 2
73565: EQUAL
73566: AND
73567: IFFALSE 73584
// bpoints := bpoints * 1.5 ;
73569: LD_ADDR_VAR 0 10
73573: PUSH
73574: LD_VAR 0 10
73578: PUSH
73579: LD_REAL  1.50000000000000E+0000
73582: MUL
73583: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73584: LD_VAR 0 1
73588: PPUSH
73589: LD_INT 66
73591: PPUSH
73592: CALL_OW 321
73596: PUSH
73597: LD_INT 2
73599: EQUAL
73600: IFFALSE 73617
// bpoints := bpoints * 1.1 ;
73602: LD_ADDR_VAR 0 10
73606: PUSH
73607: LD_VAR 0 10
73611: PUSH
73612: LD_REAL  1.10000000000000E+0000
73615: MUL
73616: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73617: LD_ADDR_VAR 0 10
73621: PUSH
73622: LD_VAR 0 10
73626: PUSH
73627: LD_VAR 0 6
73631: PPUSH
73632: LD_INT 1
73634: PPUSH
73635: CALL_OW 259
73639: PUSH
73640: LD_REAL  1.15000000000000E+0000
73643: MUL
73644: MUL
73645: ST_TO_ADDR
// end ; unit_vehicle :
73646: GO 74470
73648: LD_INT 2
73650: DOUBLE
73651: EQUAL
73652: IFTRUE 73656
73654: GO 74458
73656: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73657: LD_VAR 0 6
73661: PPUSH
73662: CALL_OW 264
73666: PUSH
73667: LD_INT 2
73669: PUSH
73670: LD_INT 42
73672: PUSH
73673: LD_INT 24
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: LIST
73680: IN
73681: IFFALSE 73702
// points := [ 25 , 5 , 3 ] ;
73683: LD_ADDR_VAR 0 9
73687: PUSH
73688: LD_INT 25
73690: PUSH
73691: LD_INT 5
73693: PUSH
73694: LD_INT 3
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73702: LD_VAR 0 6
73706: PPUSH
73707: CALL_OW 264
73711: PUSH
73712: LD_INT 4
73714: PUSH
73715: LD_INT 43
73717: PUSH
73718: LD_INT 25
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: LIST
73725: IN
73726: IFFALSE 73747
// points := [ 40 , 15 , 5 ] ;
73728: LD_ADDR_VAR 0 9
73732: PUSH
73733: LD_INT 40
73735: PUSH
73736: LD_INT 15
73738: PUSH
73739: LD_INT 5
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: LIST
73746: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73747: LD_VAR 0 6
73751: PPUSH
73752: CALL_OW 264
73756: PUSH
73757: LD_INT 3
73759: PUSH
73760: LD_INT 23
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: IN
73767: IFFALSE 73788
// points := [ 7 , 25 , 8 ] ;
73769: LD_ADDR_VAR 0 9
73773: PUSH
73774: LD_INT 7
73776: PUSH
73777: LD_INT 25
73779: PUSH
73780: LD_INT 8
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73788: LD_VAR 0 6
73792: PPUSH
73793: CALL_OW 264
73797: PUSH
73798: LD_INT 5
73800: PUSH
73801: LD_INT 27
73803: PUSH
73804: LD_INT 44
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: LIST
73811: IN
73812: IFFALSE 73833
// points := [ 14 , 50 , 16 ] ;
73814: LD_ADDR_VAR 0 9
73818: PUSH
73819: LD_INT 14
73821: PUSH
73822: LD_INT 50
73824: PUSH
73825: LD_INT 16
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: LIST
73832: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73833: LD_VAR 0 6
73837: PPUSH
73838: CALL_OW 264
73842: PUSH
73843: LD_INT 6
73845: PUSH
73846: LD_INT 46
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: IN
73853: IFFALSE 73874
// points := [ 32 , 120 , 70 ] ;
73855: LD_ADDR_VAR 0 9
73859: PUSH
73860: LD_INT 32
73862: PUSH
73863: LD_INT 120
73865: PUSH
73866: LD_INT 70
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: LIST
73873: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73874: LD_VAR 0 6
73878: PPUSH
73879: CALL_OW 264
73883: PUSH
73884: LD_INT 7
73886: PUSH
73887: LD_INT 28
73889: PUSH
73890: LD_INT 45
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: LIST
73897: IN
73898: IFFALSE 73919
// points := [ 35 , 20 , 45 ] ;
73900: LD_ADDR_VAR 0 9
73904: PUSH
73905: LD_INT 35
73907: PUSH
73908: LD_INT 20
73910: PUSH
73911: LD_INT 45
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: LIST
73918: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73919: LD_VAR 0 6
73923: PPUSH
73924: CALL_OW 264
73928: PUSH
73929: LD_INT 47
73931: PUSH
73932: EMPTY
73933: LIST
73934: IN
73935: IFFALSE 73956
// points := [ 67 , 45 , 75 ] ;
73937: LD_ADDR_VAR 0 9
73941: PUSH
73942: LD_INT 67
73944: PUSH
73945: LD_INT 45
73947: PUSH
73948: LD_INT 75
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: LIST
73955: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73956: LD_VAR 0 6
73960: PPUSH
73961: CALL_OW 264
73965: PUSH
73966: LD_INT 26
73968: PUSH
73969: EMPTY
73970: LIST
73971: IN
73972: IFFALSE 73993
// points := [ 120 , 30 , 80 ] ;
73974: LD_ADDR_VAR 0 9
73978: PUSH
73979: LD_INT 120
73981: PUSH
73982: LD_INT 30
73984: PUSH
73985: LD_INT 80
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: LIST
73992: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73993: LD_VAR 0 6
73997: PPUSH
73998: CALL_OW 264
74002: PUSH
74003: LD_INT 22
74005: PUSH
74006: EMPTY
74007: LIST
74008: IN
74009: IFFALSE 74030
// points := [ 40 , 1 , 1 ] ;
74011: LD_ADDR_VAR 0 9
74015: PUSH
74016: LD_INT 40
74018: PUSH
74019: LD_INT 1
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: LIST
74029: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74030: LD_VAR 0 6
74034: PPUSH
74035: CALL_OW 264
74039: PUSH
74040: LD_INT 29
74042: PUSH
74043: EMPTY
74044: LIST
74045: IN
74046: IFFALSE 74067
// points := [ 70 , 200 , 400 ] ;
74048: LD_ADDR_VAR 0 9
74052: PUSH
74053: LD_INT 70
74055: PUSH
74056: LD_INT 200
74058: PUSH
74059: LD_INT 400
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74067: LD_VAR 0 6
74071: PPUSH
74072: CALL_OW 264
74076: PUSH
74077: LD_INT 14
74079: PUSH
74080: LD_INT 53
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: IN
74087: IFFALSE 74108
// points := [ 40 , 10 , 20 ] ;
74089: LD_ADDR_VAR 0 9
74093: PUSH
74094: LD_INT 40
74096: PUSH
74097: LD_INT 10
74099: PUSH
74100: LD_INT 20
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: LIST
74107: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74108: LD_VAR 0 6
74112: PPUSH
74113: CALL_OW 264
74117: PUSH
74118: LD_INT 9
74120: PUSH
74121: EMPTY
74122: LIST
74123: IN
74124: IFFALSE 74145
// points := [ 5 , 70 , 20 ] ;
74126: LD_ADDR_VAR 0 9
74130: PUSH
74131: LD_INT 5
74133: PUSH
74134: LD_INT 70
74136: PUSH
74137: LD_INT 20
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: LIST
74144: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74145: LD_VAR 0 6
74149: PPUSH
74150: CALL_OW 264
74154: PUSH
74155: LD_INT 10
74157: PUSH
74158: EMPTY
74159: LIST
74160: IN
74161: IFFALSE 74182
// points := [ 35 , 110 , 70 ] ;
74163: LD_ADDR_VAR 0 9
74167: PUSH
74168: LD_INT 35
74170: PUSH
74171: LD_INT 110
74173: PUSH
74174: LD_INT 70
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: LIST
74181: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74182: LD_VAR 0 6
74186: PPUSH
74187: CALL_OW 265
74191: PUSH
74192: LD_INT 25
74194: EQUAL
74195: IFFALSE 74216
// points := [ 80 , 65 , 100 ] ;
74197: LD_ADDR_VAR 0 9
74201: PUSH
74202: LD_INT 80
74204: PUSH
74205: LD_INT 65
74207: PUSH
74208: LD_INT 100
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: LIST
74215: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74216: LD_VAR 0 6
74220: PPUSH
74221: CALL_OW 263
74225: PUSH
74226: LD_INT 1
74228: EQUAL
74229: IFFALSE 74264
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74231: LD_ADDR_VAR 0 10
74235: PUSH
74236: LD_VAR 0 10
74240: PUSH
74241: LD_VAR 0 6
74245: PPUSH
74246: CALL_OW 311
74250: PPUSH
74251: LD_INT 3
74253: PPUSH
74254: CALL_OW 259
74258: PUSH
74259: LD_INT 4
74261: MUL
74262: MUL
74263: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74264: LD_VAR 0 6
74268: PPUSH
74269: CALL_OW 263
74273: PUSH
74274: LD_INT 2
74276: EQUAL
74277: IFFALSE 74328
// begin j := IsControledBy ( i ) ;
74279: LD_ADDR_VAR 0 7
74283: PUSH
74284: LD_VAR 0 6
74288: PPUSH
74289: CALL_OW 312
74293: ST_TO_ADDR
// if j then
74294: LD_VAR 0 7
74298: IFFALSE 74328
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74300: LD_ADDR_VAR 0 10
74304: PUSH
74305: LD_VAR 0 10
74309: PUSH
74310: LD_VAR 0 7
74314: PPUSH
74315: LD_INT 3
74317: PPUSH
74318: CALL_OW 259
74322: PUSH
74323: LD_INT 3
74325: MUL
74326: MUL
74327: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74328: LD_VAR 0 6
74332: PPUSH
74333: CALL_OW 264
74337: PUSH
74338: LD_INT 5
74340: PUSH
74341: LD_INT 6
74343: PUSH
74344: LD_INT 46
74346: PUSH
74347: LD_INT 44
74349: PUSH
74350: LD_INT 47
74352: PUSH
74353: LD_INT 45
74355: PUSH
74356: LD_INT 28
74358: PUSH
74359: LD_INT 7
74361: PUSH
74362: LD_INT 27
74364: PUSH
74365: LD_INT 29
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: IN
74380: PUSH
74381: LD_VAR 0 1
74385: PPUSH
74386: LD_INT 52
74388: PPUSH
74389: CALL_OW 321
74393: PUSH
74394: LD_INT 2
74396: EQUAL
74397: AND
74398: IFFALSE 74415
// bpoints := bpoints * 1.2 ;
74400: LD_ADDR_VAR 0 10
74404: PUSH
74405: LD_VAR 0 10
74409: PUSH
74410: LD_REAL  1.20000000000000E+0000
74413: MUL
74414: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74415: LD_VAR 0 6
74419: PPUSH
74420: CALL_OW 264
74424: PUSH
74425: LD_INT 6
74427: PUSH
74428: LD_INT 46
74430: PUSH
74431: LD_INT 47
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: LIST
74438: IN
74439: IFFALSE 74456
// bpoints := bpoints * 1.2 ;
74441: LD_ADDR_VAR 0 10
74445: PUSH
74446: LD_VAR 0 10
74450: PUSH
74451: LD_REAL  1.20000000000000E+0000
74454: MUL
74455: ST_TO_ADDR
// end ; unit_building :
74456: GO 74470
74458: LD_INT 3
74460: DOUBLE
74461: EQUAL
74462: IFTRUE 74466
74464: GO 74469
74466: POP
// ; end ;
74467: GO 74470
74469: POP
// for j = 1 to 3 do
74470: LD_ADDR_VAR 0 7
74474: PUSH
74475: DOUBLE
74476: LD_INT 1
74478: DEC
74479: ST_TO_ADDR
74480: LD_INT 3
74482: PUSH
74483: FOR_TO
74484: IFFALSE 74537
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74486: LD_ADDR_VAR 0 5
74490: PUSH
74491: LD_VAR 0 5
74495: PPUSH
74496: LD_VAR 0 7
74500: PPUSH
74501: LD_VAR 0 5
74505: PUSH
74506: LD_VAR 0 7
74510: ARRAY
74511: PUSH
74512: LD_VAR 0 9
74516: PUSH
74517: LD_VAR 0 7
74521: ARRAY
74522: PUSH
74523: LD_VAR 0 10
74527: MUL
74528: PLUS
74529: PPUSH
74530: CALL_OW 1
74534: ST_TO_ADDR
74535: GO 74483
74537: POP
74538: POP
// end ;
74539: GO 73022
74541: POP
74542: POP
// result := Replace ( result , 4 , tmp ) ;
74543: LD_ADDR_VAR 0 5
74547: PUSH
74548: LD_VAR 0 5
74552: PPUSH
74553: LD_INT 4
74555: PPUSH
74556: LD_VAR 0 8
74560: PPUSH
74561: CALL_OW 1
74565: ST_TO_ADDR
// end ;
74566: LD_VAR 0 5
74570: RET
// export function DangerAtRange ( unit , range ) ; begin
74571: LD_INT 0
74573: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74574: LD_ADDR_VAR 0 3
74578: PUSH
74579: LD_VAR 0 1
74583: PPUSH
74584: CALL_OW 255
74588: PPUSH
74589: LD_VAR 0 1
74593: PPUSH
74594: CALL_OW 250
74598: PPUSH
74599: LD_VAR 0 1
74603: PPUSH
74604: CALL_OW 251
74608: PPUSH
74609: LD_VAR 0 2
74613: PPUSH
74614: CALL 72874 0 4
74618: ST_TO_ADDR
// end ;
74619: LD_VAR 0 3
74623: RET
// export function DangerInArea ( side , area ) ; begin
74624: LD_INT 0
74626: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74627: LD_ADDR_VAR 0 3
74631: PUSH
74632: LD_VAR 0 2
74636: PPUSH
74637: LD_INT 81
74639: PUSH
74640: LD_VAR 0 1
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PPUSH
74649: CALL_OW 70
74653: ST_TO_ADDR
// end ;
74654: LD_VAR 0 3
74658: RET
// export function IsExtension ( b ) ; begin
74659: LD_INT 0
74661: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74662: LD_ADDR_VAR 0 2
74666: PUSH
74667: LD_VAR 0 1
74671: PUSH
74672: LD_INT 23
74674: PUSH
74675: LD_INT 20
74677: PUSH
74678: LD_INT 22
74680: PUSH
74681: LD_INT 17
74683: PUSH
74684: LD_INT 24
74686: PUSH
74687: LD_INT 21
74689: PUSH
74690: LD_INT 19
74692: PUSH
74693: LD_INT 16
74695: PUSH
74696: LD_INT 25
74698: PUSH
74699: LD_INT 18
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: LIST
74706: LIST
74707: LIST
74708: LIST
74709: LIST
74710: LIST
74711: LIST
74712: LIST
74713: IN
74714: ST_TO_ADDR
// end ;
74715: LD_VAR 0 2
74719: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74720: LD_INT 0
74722: PPUSH
74723: PPUSH
74724: PPUSH
// result := [ ] ;
74725: LD_ADDR_VAR 0 3
74729: PUSH
74730: EMPTY
74731: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74732: LD_ADDR_VAR 0 4
74736: PUSH
74737: LD_VAR 0 2
74741: PPUSH
74742: LD_INT 21
74744: PUSH
74745: LD_INT 3
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PPUSH
74752: CALL_OW 70
74756: ST_TO_ADDR
// if not tmp then
74757: LD_VAR 0 4
74761: NOT
74762: IFFALSE 74766
// exit ;
74764: GO 74824
// for i in tmp do
74766: LD_ADDR_VAR 0 5
74770: PUSH
74771: LD_VAR 0 4
74775: PUSH
74776: FOR_IN
74777: IFFALSE 74812
// if GetBase ( i ) <> base then
74779: LD_VAR 0 5
74783: PPUSH
74784: CALL_OW 274
74788: PUSH
74789: LD_VAR 0 1
74793: NONEQUAL
74794: IFFALSE 74810
// ComLinkToBase ( base , i ) ;
74796: LD_VAR 0 1
74800: PPUSH
74801: LD_VAR 0 5
74805: PPUSH
74806: CALL_OW 169
74810: GO 74776
74812: POP
74813: POP
// result := tmp ;
74814: LD_ADDR_VAR 0 3
74818: PUSH
74819: LD_VAR 0 4
74823: ST_TO_ADDR
// end ;
74824: LD_VAR 0 3
74828: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74829: LD_INT 0
74831: PPUSH
74832: PPUSH
// if BuildingStatus ( b ) = bs_build then
74833: LD_VAR 0 2
74837: PPUSH
74838: CALL_OW 461
74842: PUSH
74843: LD_INT 1
74845: EQUAL
74846: IFFALSE 74906
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74848: LD_VAR 0 1
74852: PPUSH
74853: LD_STRING h
74855: PUSH
74856: LD_VAR 0 2
74860: PPUSH
74861: CALL_OW 250
74865: PUSH
74866: LD_VAR 0 2
74870: PPUSH
74871: CALL_OW 251
74875: PUSH
74876: LD_VAR 0 2
74880: PUSH
74881: LD_INT 0
74883: PUSH
74884: LD_INT 0
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: LIST
74894: LIST
74895: LIST
74896: LIST
74897: LIST
74898: PUSH
74899: EMPTY
74900: LIST
74901: PPUSH
74902: CALL_OW 446
// end ;
74906: LD_VAR 0 3
74910: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74911: LD_INT 0
74913: PPUSH
74914: PPUSH
74915: PPUSH
74916: PPUSH
74917: PPUSH
74918: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74919: LD_VAR 0 1
74923: NOT
74924: PUSH
74925: LD_VAR 0 1
74929: PPUSH
74930: CALL_OW 263
74934: PUSH
74935: LD_INT 2
74937: EQUAL
74938: NOT
74939: OR
74940: IFFALSE 74944
// exit ;
74942: GO 75260
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74944: LD_ADDR_VAR 0 6
74948: PUSH
74949: LD_INT 22
74951: PUSH
74952: LD_VAR 0 1
74956: PPUSH
74957: CALL_OW 255
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 2
74968: PUSH
74969: LD_INT 30
74971: PUSH
74972: LD_INT 36
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 34
74981: PUSH
74982: LD_INT 31
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: LIST
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PPUSH
74998: CALL_OW 69
75002: ST_TO_ADDR
// if not tmp then
75003: LD_VAR 0 6
75007: NOT
75008: IFFALSE 75012
// exit ;
75010: GO 75260
// result := [ ] ;
75012: LD_ADDR_VAR 0 2
75016: PUSH
75017: EMPTY
75018: ST_TO_ADDR
// for i in tmp do
75019: LD_ADDR_VAR 0 3
75023: PUSH
75024: LD_VAR 0 6
75028: PUSH
75029: FOR_IN
75030: IFFALSE 75101
// begin t := UnitsInside ( i ) ;
75032: LD_ADDR_VAR 0 4
75036: PUSH
75037: LD_VAR 0 3
75041: PPUSH
75042: CALL_OW 313
75046: ST_TO_ADDR
// if t then
75047: LD_VAR 0 4
75051: IFFALSE 75099
// for j in t do
75053: LD_ADDR_VAR 0 7
75057: PUSH
75058: LD_VAR 0 4
75062: PUSH
75063: FOR_IN
75064: IFFALSE 75097
// result := Insert ( result , result + 1 , j ) ;
75066: LD_ADDR_VAR 0 2
75070: PUSH
75071: LD_VAR 0 2
75075: PPUSH
75076: LD_VAR 0 2
75080: PUSH
75081: LD_INT 1
75083: PLUS
75084: PPUSH
75085: LD_VAR 0 7
75089: PPUSH
75090: CALL_OW 2
75094: ST_TO_ADDR
75095: GO 75063
75097: POP
75098: POP
// end ;
75099: GO 75029
75101: POP
75102: POP
// if not result then
75103: LD_VAR 0 2
75107: NOT
75108: IFFALSE 75112
// exit ;
75110: GO 75260
// mech := result [ 1 ] ;
75112: LD_ADDR_VAR 0 5
75116: PUSH
75117: LD_VAR 0 2
75121: PUSH
75122: LD_INT 1
75124: ARRAY
75125: ST_TO_ADDR
// if result > 1 then
75126: LD_VAR 0 2
75130: PUSH
75131: LD_INT 1
75133: GREATER
75134: IFFALSE 75246
// for i = 2 to result do
75136: LD_ADDR_VAR 0 3
75140: PUSH
75141: DOUBLE
75142: LD_INT 2
75144: DEC
75145: ST_TO_ADDR
75146: LD_VAR 0 2
75150: PUSH
75151: FOR_TO
75152: IFFALSE 75244
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75154: LD_ADDR_VAR 0 4
75158: PUSH
75159: LD_VAR 0 2
75163: PUSH
75164: LD_VAR 0 3
75168: ARRAY
75169: PPUSH
75170: LD_INT 3
75172: PPUSH
75173: CALL_OW 259
75177: PUSH
75178: LD_VAR 0 2
75182: PUSH
75183: LD_VAR 0 3
75187: ARRAY
75188: PPUSH
75189: CALL_OW 432
75193: MINUS
75194: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75195: LD_VAR 0 4
75199: PUSH
75200: LD_VAR 0 5
75204: PPUSH
75205: LD_INT 3
75207: PPUSH
75208: CALL_OW 259
75212: PUSH
75213: LD_VAR 0 5
75217: PPUSH
75218: CALL_OW 432
75222: MINUS
75223: GREATEREQUAL
75224: IFFALSE 75242
// mech := result [ i ] ;
75226: LD_ADDR_VAR 0 5
75230: PUSH
75231: LD_VAR 0 2
75235: PUSH
75236: LD_VAR 0 3
75240: ARRAY
75241: ST_TO_ADDR
// end ;
75242: GO 75151
75244: POP
75245: POP
// ComLinkTo ( vehicle , mech ) ;
75246: LD_VAR 0 1
75250: PPUSH
75251: LD_VAR 0 5
75255: PPUSH
75256: CALL_OW 135
// end ;
75260: LD_VAR 0 2
75264: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75265: LD_INT 0
75267: PPUSH
75268: PPUSH
75269: PPUSH
75270: PPUSH
75271: PPUSH
75272: PPUSH
75273: PPUSH
75274: PPUSH
75275: PPUSH
75276: PPUSH
75277: PPUSH
75278: PPUSH
75279: PPUSH
// result := [ ] ;
75280: LD_ADDR_VAR 0 7
75284: PUSH
75285: EMPTY
75286: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75287: LD_VAR 0 1
75291: PPUSH
75292: CALL_OW 266
75296: PUSH
75297: LD_INT 0
75299: PUSH
75300: LD_INT 1
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: IN
75307: NOT
75308: IFFALSE 75312
// exit ;
75310: GO 76943
// if name then
75312: LD_VAR 0 3
75316: IFFALSE 75332
// SetBName ( base_dep , name ) ;
75318: LD_VAR 0 1
75322: PPUSH
75323: LD_VAR 0 3
75327: PPUSH
75328: CALL_OW 500
// base := GetBase ( base_dep ) ;
75332: LD_ADDR_VAR 0 15
75336: PUSH
75337: LD_VAR 0 1
75341: PPUSH
75342: CALL_OW 274
75346: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75347: LD_ADDR_VAR 0 16
75351: PUSH
75352: LD_VAR 0 1
75356: PPUSH
75357: CALL_OW 255
75361: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75362: LD_ADDR_VAR 0 17
75366: PUSH
75367: LD_VAR 0 1
75371: PPUSH
75372: CALL_OW 248
75376: ST_TO_ADDR
// if sources then
75377: LD_VAR 0 5
75381: IFFALSE 75428
// for i = 1 to 3 do
75383: LD_ADDR_VAR 0 8
75387: PUSH
75388: DOUBLE
75389: LD_INT 1
75391: DEC
75392: ST_TO_ADDR
75393: LD_INT 3
75395: PUSH
75396: FOR_TO
75397: IFFALSE 75426
// AddResourceType ( base , i , sources [ i ] ) ;
75399: LD_VAR 0 15
75403: PPUSH
75404: LD_VAR 0 8
75408: PPUSH
75409: LD_VAR 0 5
75413: PUSH
75414: LD_VAR 0 8
75418: ARRAY
75419: PPUSH
75420: CALL_OW 276
75424: GO 75396
75426: POP
75427: POP
// buildings := GetBaseBuildings ( base , area ) ;
75428: LD_ADDR_VAR 0 18
75432: PUSH
75433: LD_VAR 0 15
75437: PPUSH
75438: LD_VAR 0 2
75442: PPUSH
75443: CALL 74720 0 2
75447: ST_TO_ADDR
// InitHc ;
75448: CALL_OW 19
// InitUc ;
75452: CALL_OW 18
// uc_side := side ;
75456: LD_ADDR_OWVAR 20
75460: PUSH
75461: LD_VAR 0 16
75465: ST_TO_ADDR
// uc_nation := nation ;
75466: LD_ADDR_OWVAR 21
75470: PUSH
75471: LD_VAR 0 17
75475: ST_TO_ADDR
// if buildings then
75476: LD_VAR 0 18
75480: IFFALSE 76802
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75482: LD_ADDR_VAR 0 19
75486: PUSH
75487: LD_VAR 0 18
75491: PPUSH
75492: LD_INT 2
75494: PUSH
75495: LD_INT 30
75497: PUSH
75498: LD_INT 29
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: PUSH
75505: LD_INT 30
75507: PUSH
75508: LD_INT 30
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: LIST
75519: PPUSH
75520: CALL_OW 72
75524: ST_TO_ADDR
// if tmp then
75525: LD_VAR 0 19
75529: IFFALSE 75577
// for i in tmp do
75531: LD_ADDR_VAR 0 8
75535: PUSH
75536: LD_VAR 0 19
75540: PUSH
75541: FOR_IN
75542: IFFALSE 75575
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75544: LD_VAR 0 8
75548: PPUSH
75549: CALL_OW 250
75553: PPUSH
75554: LD_VAR 0 8
75558: PPUSH
75559: CALL_OW 251
75563: PPUSH
75564: LD_VAR 0 16
75568: PPUSH
75569: CALL_OW 441
75573: GO 75541
75575: POP
75576: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75577: LD_VAR 0 18
75581: PPUSH
75582: LD_INT 2
75584: PUSH
75585: LD_INT 30
75587: PUSH
75588: LD_INT 32
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 30
75597: PUSH
75598: LD_INT 33
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: LIST
75609: PPUSH
75610: CALL_OW 72
75614: IFFALSE 75702
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75616: LD_ADDR_VAR 0 8
75620: PUSH
75621: LD_VAR 0 18
75625: PPUSH
75626: LD_INT 2
75628: PUSH
75629: LD_INT 30
75631: PUSH
75632: LD_INT 32
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 30
75641: PUSH
75642: LD_INT 33
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: LIST
75653: PPUSH
75654: CALL_OW 72
75658: PUSH
75659: FOR_IN
75660: IFFALSE 75700
// begin if not GetBWeapon ( i ) then
75662: LD_VAR 0 8
75666: PPUSH
75667: CALL_OW 269
75671: NOT
75672: IFFALSE 75698
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75674: LD_VAR 0 8
75678: PPUSH
75679: LD_VAR 0 8
75683: PPUSH
75684: LD_VAR 0 2
75688: PPUSH
75689: CALL 76948 0 2
75693: PPUSH
75694: CALL_OW 431
// end ;
75698: GO 75659
75700: POP
75701: POP
// end ; for i = 1 to personel do
75702: LD_ADDR_VAR 0 8
75706: PUSH
75707: DOUBLE
75708: LD_INT 1
75710: DEC
75711: ST_TO_ADDR
75712: LD_VAR 0 6
75716: PUSH
75717: FOR_TO
75718: IFFALSE 76782
// begin if i > 4 then
75720: LD_VAR 0 8
75724: PUSH
75725: LD_INT 4
75727: GREATER
75728: IFFALSE 75732
// break ;
75730: GO 76782
// case i of 1 :
75732: LD_VAR 0 8
75736: PUSH
75737: LD_INT 1
75739: DOUBLE
75740: EQUAL
75741: IFTRUE 75745
75743: GO 75825
75745: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75746: LD_ADDR_VAR 0 12
75750: PUSH
75751: LD_VAR 0 18
75755: PPUSH
75756: LD_INT 22
75758: PUSH
75759: LD_VAR 0 16
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 58
75770: PUSH
75771: EMPTY
75772: LIST
75773: PUSH
75774: LD_INT 2
75776: PUSH
75777: LD_INT 30
75779: PUSH
75780: LD_INT 32
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 30
75789: PUSH
75790: LD_INT 4
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 30
75799: PUSH
75800: LD_INT 5
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: LIST
75817: PPUSH
75818: CALL_OW 72
75822: ST_TO_ADDR
75823: GO 76047
75825: LD_INT 2
75827: DOUBLE
75828: EQUAL
75829: IFTRUE 75833
75831: GO 75895
75833: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75834: LD_ADDR_VAR 0 12
75838: PUSH
75839: LD_VAR 0 18
75843: PPUSH
75844: LD_INT 22
75846: PUSH
75847: LD_VAR 0 16
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: LD_INT 30
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 30
75871: PUSH
75872: LD_INT 1
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: LIST
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PPUSH
75888: CALL_OW 72
75892: ST_TO_ADDR
75893: GO 76047
75895: LD_INT 3
75897: DOUBLE
75898: EQUAL
75899: IFTRUE 75903
75901: GO 75965
75903: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75904: LD_ADDR_VAR 0 12
75908: PUSH
75909: LD_VAR 0 18
75913: PPUSH
75914: LD_INT 22
75916: PUSH
75917: LD_VAR 0 16
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 2
75928: PUSH
75929: LD_INT 30
75931: PUSH
75932: LD_INT 2
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 30
75941: PUSH
75942: LD_INT 3
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: LIST
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PPUSH
75958: CALL_OW 72
75962: ST_TO_ADDR
75963: GO 76047
75965: LD_INT 4
75967: DOUBLE
75968: EQUAL
75969: IFTRUE 75973
75971: GO 76046
75973: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75974: LD_ADDR_VAR 0 12
75978: PUSH
75979: LD_VAR 0 18
75983: PPUSH
75984: LD_INT 22
75986: PUSH
75987: LD_VAR 0 16
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: PUSH
75996: LD_INT 2
75998: PUSH
75999: LD_INT 30
76001: PUSH
76002: LD_INT 6
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 30
76011: PUSH
76012: LD_INT 7
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 30
76021: PUSH
76022: LD_INT 8
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PPUSH
76039: CALL_OW 72
76043: ST_TO_ADDR
76044: GO 76047
76046: POP
// if i = 1 then
76047: LD_VAR 0 8
76051: PUSH
76052: LD_INT 1
76054: EQUAL
76055: IFFALSE 76166
// begin tmp := [ ] ;
76057: LD_ADDR_VAR 0 19
76061: PUSH
76062: EMPTY
76063: ST_TO_ADDR
// for j in f do
76064: LD_ADDR_VAR 0 9
76068: PUSH
76069: LD_VAR 0 12
76073: PUSH
76074: FOR_IN
76075: IFFALSE 76148
// if GetBType ( j ) = b_bunker then
76077: LD_VAR 0 9
76081: PPUSH
76082: CALL_OW 266
76086: PUSH
76087: LD_INT 32
76089: EQUAL
76090: IFFALSE 76117
// tmp := Insert ( tmp , 1 , j ) else
76092: LD_ADDR_VAR 0 19
76096: PUSH
76097: LD_VAR 0 19
76101: PPUSH
76102: LD_INT 1
76104: PPUSH
76105: LD_VAR 0 9
76109: PPUSH
76110: CALL_OW 2
76114: ST_TO_ADDR
76115: GO 76146
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76117: LD_ADDR_VAR 0 19
76121: PUSH
76122: LD_VAR 0 19
76126: PPUSH
76127: LD_VAR 0 19
76131: PUSH
76132: LD_INT 1
76134: PLUS
76135: PPUSH
76136: LD_VAR 0 9
76140: PPUSH
76141: CALL_OW 2
76145: ST_TO_ADDR
76146: GO 76074
76148: POP
76149: POP
// if tmp then
76150: LD_VAR 0 19
76154: IFFALSE 76166
// f := tmp ;
76156: LD_ADDR_VAR 0 12
76160: PUSH
76161: LD_VAR 0 19
76165: ST_TO_ADDR
// end ; x := personel [ i ] ;
76166: LD_ADDR_VAR 0 13
76170: PUSH
76171: LD_VAR 0 6
76175: PUSH
76176: LD_VAR 0 8
76180: ARRAY
76181: ST_TO_ADDR
// if x = - 1 then
76182: LD_VAR 0 13
76186: PUSH
76187: LD_INT 1
76189: NEG
76190: EQUAL
76191: IFFALSE 76400
// begin for j in f do
76193: LD_ADDR_VAR 0 9
76197: PUSH
76198: LD_VAR 0 12
76202: PUSH
76203: FOR_IN
76204: IFFALSE 76396
// repeat InitHc ;
76206: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76210: LD_VAR 0 9
76214: PPUSH
76215: CALL_OW 266
76219: PUSH
76220: LD_INT 5
76222: EQUAL
76223: IFFALSE 76293
// begin if UnitsInside ( j ) < 3 then
76225: LD_VAR 0 9
76229: PPUSH
76230: CALL_OW 313
76234: PUSH
76235: LD_INT 3
76237: LESS
76238: IFFALSE 76274
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76240: LD_INT 0
76242: PPUSH
76243: LD_INT 5
76245: PUSH
76246: LD_INT 8
76248: PUSH
76249: LD_INT 9
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: LIST
76256: PUSH
76257: LD_VAR 0 17
76261: ARRAY
76262: PPUSH
76263: LD_VAR 0 4
76267: PPUSH
76268: CALL_OW 380
76272: GO 76291
// PrepareHuman ( false , i , skill ) ;
76274: LD_INT 0
76276: PPUSH
76277: LD_VAR 0 8
76281: PPUSH
76282: LD_VAR 0 4
76286: PPUSH
76287: CALL_OW 380
// end else
76291: GO 76310
// PrepareHuman ( false , i , skill ) ;
76293: LD_INT 0
76295: PPUSH
76296: LD_VAR 0 8
76300: PPUSH
76301: LD_VAR 0 4
76305: PPUSH
76306: CALL_OW 380
// un := CreateHuman ;
76310: LD_ADDR_VAR 0 14
76314: PUSH
76315: CALL_OW 44
76319: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76320: LD_ADDR_VAR 0 7
76324: PUSH
76325: LD_VAR 0 7
76329: PPUSH
76330: LD_INT 1
76332: PPUSH
76333: LD_VAR 0 14
76337: PPUSH
76338: CALL_OW 2
76342: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76343: LD_VAR 0 14
76347: PPUSH
76348: LD_VAR 0 9
76352: PPUSH
76353: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76357: LD_VAR 0 9
76361: PPUSH
76362: CALL_OW 313
76366: PUSH
76367: LD_INT 6
76369: EQUAL
76370: PUSH
76371: LD_VAR 0 9
76375: PPUSH
76376: CALL_OW 266
76380: PUSH
76381: LD_INT 32
76383: PUSH
76384: LD_INT 31
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: IN
76391: OR
76392: IFFALSE 76206
76394: GO 76203
76396: POP
76397: POP
// end else
76398: GO 76780
// for j = 1 to x do
76400: LD_ADDR_VAR 0 9
76404: PUSH
76405: DOUBLE
76406: LD_INT 1
76408: DEC
76409: ST_TO_ADDR
76410: LD_VAR 0 13
76414: PUSH
76415: FOR_TO
76416: IFFALSE 76778
// begin InitHc ;
76418: CALL_OW 19
// if not f then
76422: LD_VAR 0 12
76426: NOT
76427: IFFALSE 76516
// begin PrepareHuman ( false , i , skill ) ;
76429: LD_INT 0
76431: PPUSH
76432: LD_VAR 0 8
76436: PPUSH
76437: LD_VAR 0 4
76441: PPUSH
76442: CALL_OW 380
// un := CreateHuman ;
76446: LD_ADDR_VAR 0 14
76450: PUSH
76451: CALL_OW 44
76455: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76456: LD_ADDR_VAR 0 7
76460: PUSH
76461: LD_VAR 0 7
76465: PPUSH
76466: LD_INT 1
76468: PPUSH
76469: LD_VAR 0 14
76473: PPUSH
76474: CALL_OW 2
76478: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76479: LD_VAR 0 14
76483: PPUSH
76484: LD_VAR 0 1
76488: PPUSH
76489: CALL_OW 250
76493: PPUSH
76494: LD_VAR 0 1
76498: PPUSH
76499: CALL_OW 251
76503: PPUSH
76504: LD_INT 10
76506: PPUSH
76507: LD_INT 0
76509: PPUSH
76510: CALL_OW 50
// continue ;
76514: GO 76415
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76516: LD_VAR 0 12
76520: PUSH
76521: LD_INT 1
76523: ARRAY
76524: PPUSH
76525: CALL_OW 313
76529: PUSH
76530: LD_VAR 0 12
76534: PUSH
76535: LD_INT 1
76537: ARRAY
76538: PPUSH
76539: CALL_OW 266
76543: PUSH
76544: LD_INT 32
76546: PUSH
76547: LD_INT 31
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: IN
76554: AND
76555: PUSH
76556: LD_VAR 0 12
76560: PUSH
76561: LD_INT 1
76563: ARRAY
76564: PPUSH
76565: CALL_OW 313
76569: PUSH
76570: LD_INT 6
76572: EQUAL
76573: OR
76574: IFFALSE 76594
// f := Delete ( f , 1 ) ;
76576: LD_ADDR_VAR 0 12
76580: PUSH
76581: LD_VAR 0 12
76585: PPUSH
76586: LD_INT 1
76588: PPUSH
76589: CALL_OW 3
76593: ST_TO_ADDR
// if not f then
76594: LD_VAR 0 12
76598: NOT
76599: IFFALSE 76617
// begin x := x + 2 ;
76601: LD_ADDR_VAR 0 13
76605: PUSH
76606: LD_VAR 0 13
76610: PUSH
76611: LD_INT 2
76613: PLUS
76614: ST_TO_ADDR
// continue ;
76615: GO 76415
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76617: LD_VAR 0 12
76621: PUSH
76622: LD_INT 1
76624: ARRAY
76625: PPUSH
76626: CALL_OW 266
76630: PUSH
76631: LD_INT 5
76633: EQUAL
76634: IFFALSE 76708
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76636: LD_VAR 0 12
76640: PUSH
76641: LD_INT 1
76643: ARRAY
76644: PPUSH
76645: CALL_OW 313
76649: PUSH
76650: LD_INT 3
76652: LESS
76653: IFFALSE 76689
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76655: LD_INT 0
76657: PPUSH
76658: LD_INT 5
76660: PUSH
76661: LD_INT 8
76663: PUSH
76664: LD_INT 9
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: LIST
76671: PUSH
76672: LD_VAR 0 17
76676: ARRAY
76677: PPUSH
76678: LD_VAR 0 4
76682: PPUSH
76683: CALL_OW 380
76687: GO 76706
// PrepareHuman ( false , i , skill ) ;
76689: LD_INT 0
76691: PPUSH
76692: LD_VAR 0 8
76696: PPUSH
76697: LD_VAR 0 4
76701: PPUSH
76702: CALL_OW 380
// end else
76706: GO 76725
// PrepareHuman ( false , i , skill ) ;
76708: LD_INT 0
76710: PPUSH
76711: LD_VAR 0 8
76715: PPUSH
76716: LD_VAR 0 4
76720: PPUSH
76721: CALL_OW 380
// un := CreateHuman ;
76725: LD_ADDR_VAR 0 14
76729: PUSH
76730: CALL_OW 44
76734: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76735: LD_ADDR_VAR 0 7
76739: PUSH
76740: LD_VAR 0 7
76744: PPUSH
76745: LD_INT 1
76747: PPUSH
76748: LD_VAR 0 14
76752: PPUSH
76753: CALL_OW 2
76757: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76758: LD_VAR 0 14
76762: PPUSH
76763: LD_VAR 0 12
76767: PUSH
76768: LD_INT 1
76770: ARRAY
76771: PPUSH
76772: CALL_OW 52
// end ;
76776: GO 76415
76778: POP
76779: POP
// end ;
76780: GO 75717
76782: POP
76783: POP
// result := result ^ buildings ;
76784: LD_ADDR_VAR 0 7
76788: PUSH
76789: LD_VAR 0 7
76793: PUSH
76794: LD_VAR 0 18
76798: ADD
76799: ST_TO_ADDR
// end else
76800: GO 76943
// begin for i = 1 to personel do
76802: LD_ADDR_VAR 0 8
76806: PUSH
76807: DOUBLE
76808: LD_INT 1
76810: DEC
76811: ST_TO_ADDR
76812: LD_VAR 0 6
76816: PUSH
76817: FOR_TO
76818: IFFALSE 76941
// begin if i > 4 then
76820: LD_VAR 0 8
76824: PUSH
76825: LD_INT 4
76827: GREATER
76828: IFFALSE 76832
// break ;
76830: GO 76941
// x := personel [ i ] ;
76832: LD_ADDR_VAR 0 13
76836: PUSH
76837: LD_VAR 0 6
76841: PUSH
76842: LD_VAR 0 8
76846: ARRAY
76847: ST_TO_ADDR
// if x = - 1 then
76848: LD_VAR 0 13
76852: PUSH
76853: LD_INT 1
76855: NEG
76856: EQUAL
76857: IFFALSE 76861
// continue ;
76859: GO 76817
// PrepareHuman ( false , i , skill ) ;
76861: LD_INT 0
76863: PPUSH
76864: LD_VAR 0 8
76868: PPUSH
76869: LD_VAR 0 4
76873: PPUSH
76874: CALL_OW 380
// un := CreateHuman ;
76878: LD_ADDR_VAR 0 14
76882: PUSH
76883: CALL_OW 44
76887: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76888: LD_VAR 0 14
76892: PPUSH
76893: LD_VAR 0 1
76897: PPUSH
76898: CALL_OW 250
76902: PPUSH
76903: LD_VAR 0 1
76907: PPUSH
76908: CALL_OW 251
76912: PPUSH
76913: LD_INT 10
76915: PPUSH
76916: LD_INT 0
76918: PPUSH
76919: CALL_OW 50
// result := result ^ un ;
76923: LD_ADDR_VAR 0 7
76927: PUSH
76928: LD_VAR 0 7
76932: PUSH
76933: LD_VAR 0 14
76937: ADD
76938: ST_TO_ADDR
// end ;
76939: GO 76817
76941: POP
76942: POP
// end ; end ;
76943: LD_VAR 0 7
76947: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76948: LD_INT 0
76950: PPUSH
76951: PPUSH
76952: PPUSH
76953: PPUSH
76954: PPUSH
76955: PPUSH
76956: PPUSH
76957: PPUSH
76958: PPUSH
76959: PPUSH
76960: PPUSH
76961: PPUSH
76962: PPUSH
76963: PPUSH
76964: PPUSH
76965: PPUSH
// result := false ;
76966: LD_ADDR_VAR 0 3
76970: PUSH
76971: LD_INT 0
76973: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76974: LD_VAR 0 1
76978: NOT
76979: PUSH
76980: LD_VAR 0 1
76984: PPUSH
76985: CALL_OW 266
76989: PUSH
76990: LD_INT 32
76992: PUSH
76993: LD_INT 33
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: IN
77000: NOT
77001: OR
77002: IFFALSE 77006
// exit ;
77004: GO 78142
// nat := GetNation ( tower ) ;
77006: LD_ADDR_VAR 0 12
77010: PUSH
77011: LD_VAR 0 1
77015: PPUSH
77016: CALL_OW 248
77020: ST_TO_ADDR
// side := GetSide ( tower ) ;
77021: LD_ADDR_VAR 0 16
77025: PUSH
77026: LD_VAR 0 1
77030: PPUSH
77031: CALL_OW 255
77035: ST_TO_ADDR
// x := GetX ( tower ) ;
77036: LD_ADDR_VAR 0 10
77040: PUSH
77041: LD_VAR 0 1
77045: PPUSH
77046: CALL_OW 250
77050: ST_TO_ADDR
// y := GetY ( tower ) ;
77051: LD_ADDR_VAR 0 11
77055: PUSH
77056: LD_VAR 0 1
77060: PPUSH
77061: CALL_OW 251
77065: ST_TO_ADDR
// if not x or not y then
77066: LD_VAR 0 10
77070: NOT
77071: PUSH
77072: LD_VAR 0 11
77076: NOT
77077: OR
77078: IFFALSE 77082
// exit ;
77080: GO 78142
// weapon := 0 ;
77082: LD_ADDR_VAR 0 18
77086: PUSH
77087: LD_INT 0
77089: ST_TO_ADDR
// fac_list := [ ] ;
77090: LD_ADDR_VAR 0 17
77094: PUSH
77095: EMPTY
77096: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77097: LD_ADDR_VAR 0 6
77101: PUSH
77102: LD_VAR 0 1
77106: PPUSH
77107: CALL_OW 274
77111: PPUSH
77112: LD_VAR 0 2
77116: PPUSH
77117: CALL 74720 0 2
77121: PPUSH
77122: LD_INT 30
77124: PUSH
77125: LD_INT 3
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PPUSH
77132: CALL_OW 72
77136: ST_TO_ADDR
// if not factories then
77137: LD_VAR 0 6
77141: NOT
77142: IFFALSE 77146
// exit ;
77144: GO 78142
// for i in factories do
77146: LD_ADDR_VAR 0 8
77150: PUSH
77151: LD_VAR 0 6
77155: PUSH
77156: FOR_IN
77157: IFFALSE 77182
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77159: LD_ADDR_VAR 0 17
77163: PUSH
77164: LD_VAR 0 17
77168: PUSH
77169: LD_VAR 0 8
77173: PPUSH
77174: CALL_OW 478
77178: UNION
77179: ST_TO_ADDR
77180: GO 77156
77182: POP
77183: POP
// if not fac_list then
77184: LD_VAR 0 17
77188: NOT
77189: IFFALSE 77193
// exit ;
77191: GO 78142
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77193: LD_ADDR_VAR 0 5
77197: PUSH
77198: LD_INT 4
77200: PUSH
77201: LD_INT 5
77203: PUSH
77204: LD_INT 9
77206: PUSH
77207: LD_INT 10
77209: PUSH
77210: LD_INT 6
77212: PUSH
77213: LD_INT 7
77215: PUSH
77216: LD_INT 11
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: PUSH
77228: LD_INT 27
77230: PUSH
77231: LD_INT 28
77233: PUSH
77234: LD_INT 26
77236: PUSH
77237: LD_INT 30
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 43
77248: PUSH
77249: LD_INT 44
77251: PUSH
77252: LD_INT 46
77254: PUSH
77255: LD_INT 45
77257: PUSH
77258: LD_INT 47
77260: PUSH
77261: LD_INT 49
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: LIST
77276: PUSH
77277: LD_VAR 0 12
77281: ARRAY
77282: ST_TO_ADDR
// for i in list do
77283: LD_ADDR_VAR 0 8
77287: PUSH
77288: LD_VAR 0 5
77292: PUSH
77293: FOR_IN
77294: IFFALSE 77327
// if not i in fac_list then
77296: LD_VAR 0 8
77300: PUSH
77301: LD_VAR 0 17
77305: IN
77306: NOT
77307: IFFALSE 77325
// list := list diff i ;
77309: LD_ADDR_VAR 0 5
77313: PUSH
77314: LD_VAR 0 5
77318: PUSH
77319: LD_VAR 0 8
77323: DIFF
77324: ST_TO_ADDR
77325: GO 77293
77327: POP
77328: POP
// if not list then
77329: LD_VAR 0 5
77333: NOT
77334: IFFALSE 77338
// exit ;
77336: GO 78142
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77338: LD_VAR 0 12
77342: PUSH
77343: LD_INT 3
77345: EQUAL
77346: PUSH
77347: LD_INT 49
77349: PUSH
77350: LD_VAR 0 5
77354: IN
77355: AND
77356: PUSH
77357: LD_INT 31
77359: PPUSH
77360: LD_VAR 0 16
77364: PPUSH
77365: CALL_OW 321
77369: PUSH
77370: LD_INT 2
77372: EQUAL
77373: AND
77374: IFFALSE 77434
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77376: LD_INT 22
77378: PUSH
77379: LD_VAR 0 16
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 35
77390: PUSH
77391: LD_INT 49
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 91
77400: PUSH
77401: LD_VAR 0 1
77405: PUSH
77406: LD_INT 10
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: LIST
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: LIST
77418: PPUSH
77419: CALL_OW 69
77423: NOT
77424: IFFALSE 77434
// weapon := ru_time_lapser ;
77426: LD_ADDR_VAR 0 18
77430: PUSH
77431: LD_INT 49
77433: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77434: LD_VAR 0 12
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: LD_INT 2
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: IN
77449: PUSH
77450: LD_INT 11
77452: PUSH
77453: LD_VAR 0 5
77457: IN
77458: PUSH
77459: LD_INT 30
77461: PUSH
77462: LD_VAR 0 5
77466: IN
77467: OR
77468: AND
77469: PUSH
77470: LD_INT 6
77472: PPUSH
77473: LD_VAR 0 16
77477: PPUSH
77478: CALL_OW 321
77482: PUSH
77483: LD_INT 2
77485: EQUAL
77486: AND
77487: IFFALSE 77652
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77489: LD_INT 22
77491: PUSH
77492: LD_VAR 0 16
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 2
77503: PUSH
77504: LD_INT 35
77506: PUSH
77507: LD_INT 11
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 35
77516: PUSH
77517: LD_INT 30
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 91
77531: PUSH
77532: LD_VAR 0 1
77536: PUSH
77537: LD_INT 18
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: LIST
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: PPUSH
77550: CALL_OW 69
77554: NOT
77555: PUSH
77556: LD_INT 22
77558: PUSH
77559: LD_VAR 0 16
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PUSH
77568: LD_INT 2
77570: PUSH
77571: LD_INT 30
77573: PUSH
77574: LD_INT 32
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 30
77583: PUSH
77584: LD_INT 33
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: LIST
77595: PUSH
77596: LD_INT 91
77598: PUSH
77599: LD_VAR 0 1
77603: PUSH
77604: LD_INT 12
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: LIST
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: LIST
77616: PUSH
77617: EMPTY
77618: LIST
77619: PPUSH
77620: CALL_OW 69
77624: PUSH
77625: LD_INT 2
77627: GREATER
77628: AND
77629: IFFALSE 77652
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77631: LD_ADDR_VAR 0 18
77635: PUSH
77636: LD_INT 11
77638: PUSH
77639: LD_INT 30
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_VAR 0 12
77650: ARRAY
77651: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77652: LD_VAR 0 18
77656: NOT
77657: PUSH
77658: LD_INT 40
77660: PPUSH
77661: LD_VAR 0 16
77665: PPUSH
77666: CALL_OW 321
77670: PUSH
77671: LD_INT 2
77673: EQUAL
77674: AND
77675: PUSH
77676: LD_INT 7
77678: PUSH
77679: LD_VAR 0 5
77683: IN
77684: PUSH
77685: LD_INT 28
77687: PUSH
77688: LD_VAR 0 5
77692: IN
77693: OR
77694: PUSH
77695: LD_INT 45
77697: PUSH
77698: LD_VAR 0 5
77702: IN
77703: OR
77704: AND
77705: IFFALSE 77959
// begin hex := GetHexInfo ( x , y ) ;
77707: LD_ADDR_VAR 0 4
77711: PUSH
77712: LD_VAR 0 10
77716: PPUSH
77717: LD_VAR 0 11
77721: PPUSH
77722: CALL_OW 546
77726: ST_TO_ADDR
// if hex [ 1 ] then
77727: LD_VAR 0 4
77731: PUSH
77732: LD_INT 1
77734: ARRAY
77735: IFFALSE 77739
// exit ;
77737: GO 78142
// height := hex [ 2 ] ;
77739: LD_ADDR_VAR 0 15
77743: PUSH
77744: LD_VAR 0 4
77748: PUSH
77749: LD_INT 2
77751: ARRAY
77752: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77753: LD_ADDR_VAR 0 14
77757: PUSH
77758: LD_INT 0
77760: PUSH
77761: LD_INT 2
77763: PUSH
77764: LD_INT 3
77766: PUSH
77767: LD_INT 5
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: ST_TO_ADDR
// for i in tmp do
77776: LD_ADDR_VAR 0 8
77780: PUSH
77781: LD_VAR 0 14
77785: PUSH
77786: FOR_IN
77787: IFFALSE 77957
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77789: LD_ADDR_VAR 0 9
77793: PUSH
77794: LD_VAR 0 10
77798: PPUSH
77799: LD_VAR 0 8
77803: PPUSH
77804: LD_INT 5
77806: PPUSH
77807: CALL_OW 272
77811: PUSH
77812: LD_VAR 0 11
77816: PPUSH
77817: LD_VAR 0 8
77821: PPUSH
77822: LD_INT 5
77824: PPUSH
77825: CALL_OW 273
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77834: LD_VAR 0 9
77838: PUSH
77839: LD_INT 1
77841: ARRAY
77842: PPUSH
77843: LD_VAR 0 9
77847: PUSH
77848: LD_INT 2
77850: ARRAY
77851: PPUSH
77852: CALL_OW 488
77856: IFFALSE 77955
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77858: LD_ADDR_VAR 0 4
77862: PUSH
77863: LD_VAR 0 9
77867: PUSH
77868: LD_INT 1
77870: ARRAY
77871: PPUSH
77872: LD_VAR 0 9
77876: PUSH
77877: LD_INT 2
77879: ARRAY
77880: PPUSH
77881: CALL_OW 546
77885: ST_TO_ADDR
// if hex [ 1 ] then
77886: LD_VAR 0 4
77890: PUSH
77891: LD_INT 1
77893: ARRAY
77894: IFFALSE 77898
// continue ;
77896: GO 77786
// h := hex [ 2 ] ;
77898: LD_ADDR_VAR 0 13
77902: PUSH
77903: LD_VAR 0 4
77907: PUSH
77908: LD_INT 2
77910: ARRAY
77911: ST_TO_ADDR
// if h + 7 < height then
77912: LD_VAR 0 13
77916: PUSH
77917: LD_INT 7
77919: PLUS
77920: PUSH
77921: LD_VAR 0 15
77925: LESS
77926: IFFALSE 77955
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77928: LD_ADDR_VAR 0 18
77932: PUSH
77933: LD_INT 7
77935: PUSH
77936: LD_INT 28
77938: PUSH
77939: LD_INT 45
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: LIST
77946: PUSH
77947: LD_VAR 0 12
77951: ARRAY
77952: ST_TO_ADDR
// break ;
77953: GO 77957
// end ; end ; end ;
77955: GO 77786
77957: POP
77958: POP
// end ; if not weapon then
77959: LD_VAR 0 18
77963: NOT
77964: IFFALSE 78024
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77966: LD_ADDR_VAR 0 5
77970: PUSH
77971: LD_VAR 0 5
77975: PUSH
77976: LD_INT 11
77978: PUSH
77979: LD_INT 30
77981: PUSH
77982: LD_INT 49
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: LIST
77989: DIFF
77990: ST_TO_ADDR
// if not list then
77991: LD_VAR 0 5
77995: NOT
77996: IFFALSE 78000
// exit ;
77998: GO 78142
// weapon := list [ rand ( 1 , list ) ] ;
78000: LD_ADDR_VAR 0 18
78004: PUSH
78005: LD_VAR 0 5
78009: PUSH
78010: LD_INT 1
78012: PPUSH
78013: LD_VAR 0 5
78017: PPUSH
78018: CALL_OW 12
78022: ARRAY
78023: ST_TO_ADDR
// end ; if weapon then
78024: LD_VAR 0 18
78028: IFFALSE 78142
// begin tmp := CostOfWeapon ( weapon ) ;
78030: LD_ADDR_VAR 0 14
78034: PUSH
78035: LD_VAR 0 18
78039: PPUSH
78040: CALL_OW 451
78044: ST_TO_ADDR
// j := GetBase ( tower ) ;
78045: LD_ADDR_VAR 0 9
78049: PUSH
78050: LD_VAR 0 1
78054: PPUSH
78055: CALL_OW 274
78059: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78060: LD_VAR 0 9
78064: PPUSH
78065: LD_INT 1
78067: PPUSH
78068: CALL_OW 275
78072: PUSH
78073: LD_VAR 0 14
78077: PUSH
78078: LD_INT 1
78080: ARRAY
78081: GREATEREQUAL
78082: PUSH
78083: LD_VAR 0 9
78087: PPUSH
78088: LD_INT 2
78090: PPUSH
78091: CALL_OW 275
78095: PUSH
78096: LD_VAR 0 14
78100: PUSH
78101: LD_INT 2
78103: ARRAY
78104: GREATEREQUAL
78105: AND
78106: PUSH
78107: LD_VAR 0 9
78111: PPUSH
78112: LD_INT 3
78114: PPUSH
78115: CALL_OW 275
78119: PUSH
78120: LD_VAR 0 14
78124: PUSH
78125: LD_INT 3
78127: ARRAY
78128: GREATEREQUAL
78129: AND
78130: IFFALSE 78142
// result := weapon ;
78132: LD_ADDR_VAR 0 3
78136: PUSH
78137: LD_VAR 0 18
78141: ST_TO_ADDR
// end ; end ;
78142: LD_VAR 0 3
78146: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78147: LD_INT 0
78149: PPUSH
78150: PPUSH
// result := true ;
78151: LD_ADDR_VAR 0 3
78155: PUSH
78156: LD_INT 1
78158: ST_TO_ADDR
// if array1 = array2 then
78159: LD_VAR 0 1
78163: PUSH
78164: LD_VAR 0 2
78168: EQUAL
78169: IFFALSE 78229
// begin for i = 1 to array1 do
78171: LD_ADDR_VAR 0 4
78175: PUSH
78176: DOUBLE
78177: LD_INT 1
78179: DEC
78180: ST_TO_ADDR
78181: LD_VAR 0 1
78185: PUSH
78186: FOR_TO
78187: IFFALSE 78225
// if array1 [ i ] <> array2 [ i ] then
78189: LD_VAR 0 1
78193: PUSH
78194: LD_VAR 0 4
78198: ARRAY
78199: PUSH
78200: LD_VAR 0 2
78204: PUSH
78205: LD_VAR 0 4
78209: ARRAY
78210: NONEQUAL
78211: IFFALSE 78223
// begin result := false ;
78213: LD_ADDR_VAR 0 3
78217: PUSH
78218: LD_INT 0
78220: ST_TO_ADDR
// break ;
78221: GO 78225
// end ;
78223: GO 78186
78225: POP
78226: POP
// end else
78227: GO 78237
// result := false ;
78229: LD_ADDR_VAR 0 3
78233: PUSH
78234: LD_INT 0
78236: ST_TO_ADDR
// end ;
78237: LD_VAR 0 3
78241: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78242: LD_INT 0
78244: PPUSH
78245: PPUSH
78246: PPUSH
// pom := GetBase ( fac ) ;
78247: LD_ADDR_VAR 0 5
78251: PUSH
78252: LD_VAR 0 1
78256: PPUSH
78257: CALL_OW 274
78261: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78262: LD_ADDR_VAR 0 4
78266: PUSH
78267: LD_VAR 0 2
78271: PUSH
78272: LD_INT 1
78274: ARRAY
78275: PPUSH
78276: LD_VAR 0 2
78280: PUSH
78281: LD_INT 2
78283: ARRAY
78284: PPUSH
78285: LD_VAR 0 2
78289: PUSH
78290: LD_INT 3
78292: ARRAY
78293: PPUSH
78294: LD_VAR 0 2
78298: PUSH
78299: LD_INT 4
78301: ARRAY
78302: PPUSH
78303: CALL_OW 449
78307: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78308: LD_ADDR_VAR 0 3
78312: PUSH
78313: LD_VAR 0 5
78317: PPUSH
78318: LD_INT 1
78320: PPUSH
78321: CALL_OW 275
78325: PUSH
78326: LD_VAR 0 4
78330: PUSH
78331: LD_INT 1
78333: ARRAY
78334: GREATEREQUAL
78335: PUSH
78336: LD_VAR 0 5
78340: PPUSH
78341: LD_INT 2
78343: PPUSH
78344: CALL_OW 275
78348: PUSH
78349: LD_VAR 0 4
78353: PUSH
78354: LD_INT 2
78356: ARRAY
78357: GREATEREQUAL
78358: AND
78359: PUSH
78360: LD_VAR 0 5
78364: PPUSH
78365: LD_INT 3
78367: PPUSH
78368: CALL_OW 275
78372: PUSH
78373: LD_VAR 0 4
78377: PUSH
78378: LD_INT 3
78380: ARRAY
78381: GREATEREQUAL
78382: AND
78383: ST_TO_ADDR
// end ;
78384: LD_VAR 0 3
78388: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78389: LD_INT 0
78391: PPUSH
78392: PPUSH
78393: PPUSH
78394: PPUSH
// pom := GetBase ( building ) ;
78395: LD_ADDR_VAR 0 3
78399: PUSH
78400: LD_VAR 0 1
78404: PPUSH
78405: CALL_OW 274
78409: ST_TO_ADDR
// if not pom then
78410: LD_VAR 0 3
78414: NOT
78415: IFFALSE 78419
// exit ;
78417: GO 78589
// btype := GetBType ( building ) ;
78419: LD_ADDR_VAR 0 5
78423: PUSH
78424: LD_VAR 0 1
78428: PPUSH
78429: CALL_OW 266
78433: ST_TO_ADDR
// if btype = b_armoury then
78434: LD_VAR 0 5
78438: PUSH
78439: LD_INT 4
78441: EQUAL
78442: IFFALSE 78452
// btype := b_barracks ;
78444: LD_ADDR_VAR 0 5
78448: PUSH
78449: LD_INT 5
78451: ST_TO_ADDR
// if btype = b_depot then
78452: LD_VAR 0 5
78456: PUSH
78457: LD_INT 0
78459: EQUAL
78460: IFFALSE 78470
// btype := b_warehouse ;
78462: LD_ADDR_VAR 0 5
78466: PUSH
78467: LD_INT 1
78469: ST_TO_ADDR
// if btype = b_workshop then
78470: LD_VAR 0 5
78474: PUSH
78475: LD_INT 2
78477: EQUAL
78478: IFFALSE 78488
// btype := b_factory ;
78480: LD_ADDR_VAR 0 5
78484: PUSH
78485: LD_INT 3
78487: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78488: LD_ADDR_VAR 0 4
78492: PUSH
78493: LD_VAR 0 5
78497: PPUSH
78498: LD_VAR 0 1
78502: PPUSH
78503: CALL_OW 248
78507: PPUSH
78508: CALL_OW 450
78512: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78513: LD_ADDR_VAR 0 2
78517: PUSH
78518: LD_VAR 0 3
78522: PPUSH
78523: LD_INT 1
78525: PPUSH
78526: CALL_OW 275
78530: PUSH
78531: LD_VAR 0 4
78535: PUSH
78536: LD_INT 1
78538: ARRAY
78539: GREATEREQUAL
78540: PUSH
78541: LD_VAR 0 3
78545: PPUSH
78546: LD_INT 2
78548: PPUSH
78549: CALL_OW 275
78553: PUSH
78554: LD_VAR 0 4
78558: PUSH
78559: LD_INT 2
78561: ARRAY
78562: GREATEREQUAL
78563: AND
78564: PUSH
78565: LD_VAR 0 3
78569: PPUSH
78570: LD_INT 3
78572: PPUSH
78573: CALL_OW 275
78577: PUSH
78578: LD_VAR 0 4
78582: PUSH
78583: LD_INT 3
78585: ARRAY
78586: GREATEREQUAL
78587: AND
78588: ST_TO_ADDR
// end ;
78589: LD_VAR 0 2
78593: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78594: LD_INT 0
78596: PPUSH
78597: PPUSH
78598: PPUSH
// pom := GetBase ( building ) ;
78599: LD_ADDR_VAR 0 4
78603: PUSH
78604: LD_VAR 0 1
78608: PPUSH
78609: CALL_OW 274
78613: ST_TO_ADDR
// if not pom then
78614: LD_VAR 0 4
78618: NOT
78619: IFFALSE 78623
// exit ;
78621: GO 78724
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78623: LD_ADDR_VAR 0 5
78627: PUSH
78628: LD_VAR 0 2
78632: PPUSH
78633: LD_VAR 0 1
78637: PPUSH
78638: CALL_OW 248
78642: PPUSH
78643: CALL_OW 450
78647: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78648: LD_ADDR_VAR 0 3
78652: PUSH
78653: LD_VAR 0 4
78657: PPUSH
78658: LD_INT 1
78660: PPUSH
78661: CALL_OW 275
78665: PUSH
78666: LD_VAR 0 5
78670: PUSH
78671: LD_INT 1
78673: ARRAY
78674: GREATEREQUAL
78675: PUSH
78676: LD_VAR 0 4
78680: PPUSH
78681: LD_INT 2
78683: PPUSH
78684: CALL_OW 275
78688: PUSH
78689: LD_VAR 0 5
78693: PUSH
78694: LD_INT 2
78696: ARRAY
78697: GREATEREQUAL
78698: AND
78699: PUSH
78700: LD_VAR 0 4
78704: PPUSH
78705: LD_INT 3
78707: PPUSH
78708: CALL_OW 275
78712: PUSH
78713: LD_VAR 0 5
78717: PUSH
78718: LD_INT 3
78720: ARRAY
78721: GREATEREQUAL
78722: AND
78723: ST_TO_ADDR
// end ;
78724: LD_VAR 0 3
78728: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78729: LD_INT 0
78731: PPUSH
78732: PPUSH
78733: PPUSH
78734: PPUSH
78735: PPUSH
78736: PPUSH
78737: PPUSH
78738: PPUSH
78739: PPUSH
78740: PPUSH
// result := false ;
78741: LD_ADDR_VAR 0 6
78745: PUSH
78746: LD_INT 0
78748: ST_TO_ADDR
// if not base or not btype or not x or not y then
78749: LD_VAR 0 1
78753: NOT
78754: PUSH
78755: LD_VAR 0 2
78759: NOT
78760: OR
78761: PUSH
78762: LD_VAR 0 3
78766: NOT
78767: OR
78768: PUSH
78769: LD_VAR 0 4
78773: NOT
78774: OR
78775: IFFALSE 78779
// exit ;
78777: GO 79388
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78779: LD_ADDR_VAR 0 12
78783: PUSH
78784: LD_VAR 0 2
78788: PPUSH
78789: LD_VAR 0 3
78793: PPUSH
78794: LD_VAR 0 4
78798: PPUSH
78799: LD_VAR 0 5
78803: PPUSH
78804: LD_VAR 0 1
78808: PUSH
78809: LD_INT 1
78811: ARRAY
78812: PPUSH
78813: CALL_OW 248
78817: PPUSH
78818: LD_INT 0
78820: PPUSH
78821: CALL 80225 0 6
78825: ST_TO_ADDR
// if not hexes then
78826: LD_VAR 0 12
78830: NOT
78831: IFFALSE 78835
// exit ;
78833: GO 79388
// for i = 1 to hexes do
78835: LD_ADDR_VAR 0 7
78839: PUSH
78840: DOUBLE
78841: LD_INT 1
78843: DEC
78844: ST_TO_ADDR
78845: LD_VAR 0 12
78849: PUSH
78850: FOR_TO
78851: IFFALSE 79386
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78853: LD_ADDR_VAR 0 11
78857: PUSH
78858: LD_VAR 0 12
78862: PUSH
78863: LD_VAR 0 7
78867: ARRAY
78868: PUSH
78869: LD_INT 1
78871: ARRAY
78872: PPUSH
78873: LD_VAR 0 12
78877: PUSH
78878: LD_VAR 0 7
78882: ARRAY
78883: PUSH
78884: LD_INT 2
78886: ARRAY
78887: PPUSH
78888: CALL_OW 428
78892: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78893: LD_VAR 0 12
78897: PUSH
78898: LD_VAR 0 7
78902: ARRAY
78903: PUSH
78904: LD_INT 1
78906: ARRAY
78907: PPUSH
78908: LD_VAR 0 12
78912: PUSH
78913: LD_VAR 0 7
78917: ARRAY
78918: PUSH
78919: LD_INT 2
78921: ARRAY
78922: PPUSH
78923: CALL_OW 351
78927: PUSH
78928: LD_VAR 0 12
78932: PUSH
78933: LD_VAR 0 7
78937: ARRAY
78938: PUSH
78939: LD_INT 1
78941: ARRAY
78942: PPUSH
78943: LD_VAR 0 12
78947: PUSH
78948: LD_VAR 0 7
78952: ARRAY
78953: PUSH
78954: LD_INT 2
78956: ARRAY
78957: PPUSH
78958: CALL_OW 488
78962: NOT
78963: OR
78964: PUSH
78965: LD_VAR 0 11
78969: PPUSH
78970: CALL_OW 247
78974: PUSH
78975: LD_INT 3
78977: EQUAL
78978: OR
78979: IFFALSE 78985
// exit ;
78981: POP
78982: POP
78983: GO 79388
// if not tmp or not tmp in base then
78985: LD_VAR 0 11
78989: NOT
78990: PUSH
78991: LD_VAR 0 11
78995: PUSH
78996: LD_VAR 0 1
79000: IN
79001: NOT
79002: OR
79003: IFFALSE 79007
// continue ;
79005: GO 78850
// result := true ;
79007: LD_ADDR_VAR 0 6
79011: PUSH
79012: LD_INT 1
79014: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79015: LD_ADDR_VAR 0 15
79019: PUSH
79020: LD_VAR 0 1
79024: PPUSH
79025: LD_INT 22
79027: PUSH
79028: LD_VAR 0 11
79032: PPUSH
79033: CALL_OW 255
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 2
79044: PUSH
79045: LD_INT 30
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 30
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: LIST
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PPUSH
79074: CALL_OW 72
79078: ST_TO_ADDR
// if dep then
79079: LD_VAR 0 15
79083: IFFALSE 79219
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79085: LD_ADDR_VAR 0 14
79089: PUSH
79090: LD_VAR 0 15
79094: PUSH
79095: LD_INT 1
79097: ARRAY
79098: PPUSH
79099: CALL_OW 250
79103: PPUSH
79104: LD_VAR 0 15
79108: PUSH
79109: LD_INT 1
79111: ARRAY
79112: PPUSH
79113: CALL_OW 254
79117: PPUSH
79118: LD_INT 5
79120: PPUSH
79121: CALL_OW 272
79125: PUSH
79126: LD_VAR 0 15
79130: PUSH
79131: LD_INT 1
79133: ARRAY
79134: PPUSH
79135: CALL_OW 251
79139: PPUSH
79140: LD_VAR 0 15
79144: PUSH
79145: LD_INT 1
79147: ARRAY
79148: PPUSH
79149: CALL_OW 254
79153: PPUSH
79154: LD_INT 5
79156: PPUSH
79157: CALL_OW 273
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79166: LD_VAR 0 14
79170: PUSH
79171: LD_INT 1
79173: ARRAY
79174: PPUSH
79175: LD_VAR 0 14
79179: PUSH
79180: LD_INT 2
79182: ARRAY
79183: PPUSH
79184: CALL_OW 488
79188: IFFALSE 79219
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79190: LD_VAR 0 11
79194: PPUSH
79195: LD_VAR 0 14
79199: PUSH
79200: LD_INT 1
79202: ARRAY
79203: PPUSH
79204: LD_VAR 0 14
79208: PUSH
79209: LD_INT 2
79211: ARRAY
79212: PPUSH
79213: CALL_OW 111
// continue ;
79217: GO 78850
// end ; end ; r := GetDir ( tmp ) ;
79219: LD_ADDR_VAR 0 13
79223: PUSH
79224: LD_VAR 0 11
79228: PPUSH
79229: CALL_OW 254
79233: ST_TO_ADDR
// if r = 5 then
79234: LD_VAR 0 13
79238: PUSH
79239: LD_INT 5
79241: EQUAL
79242: IFFALSE 79252
// r := 0 ;
79244: LD_ADDR_VAR 0 13
79248: PUSH
79249: LD_INT 0
79251: ST_TO_ADDR
// for j = r to 5 do
79252: LD_ADDR_VAR 0 8
79256: PUSH
79257: DOUBLE
79258: LD_VAR 0 13
79262: DEC
79263: ST_TO_ADDR
79264: LD_INT 5
79266: PUSH
79267: FOR_TO
79268: IFFALSE 79382
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79270: LD_ADDR_VAR 0 9
79274: PUSH
79275: LD_VAR 0 11
79279: PPUSH
79280: CALL_OW 250
79284: PPUSH
79285: LD_VAR 0 8
79289: PPUSH
79290: LD_INT 2
79292: PPUSH
79293: CALL_OW 272
79297: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79298: LD_ADDR_VAR 0 10
79302: PUSH
79303: LD_VAR 0 11
79307: PPUSH
79308: CALL_OW 251
79312: PPUSH
79313: LD_VAR 0 8
79317: PPUSH
79318: LD_INT 2
79320: PPUSH
79321: CALL_OW 273
79325: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79326: LD_VAR 0 9
79330: PPUSH
79331: LD_VAR 0 10
79335: PPUSH
79336: CALL_OW 488
79340: PUSH
79341: LD_VAR 0 9
79345: PPUSH
79346: LD_VAR 0 10
79350: PPUSH
79351: CALL_OW 428
79355: NOT
79356: AND
79357: IFFALSE 79380
// begin ComMoveXY ( tmp , _x , _y ) ;
79359: LD_VAR 0 11
79363: PPUSH
79364: LD_VAR 0 9
79368: PPUSH
79369: LD_VAR 0 10
79373: PPUSH
79374: CALL_OW 111
// break ;
79378: GO 79382
// end ; end ;
79380: GO 79267
79382: POP
79383: POP
// end ;
79384: GO 78850
79386: POP
79387: POP
// end ;
79388: LD_VAR 0 6
79392: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79393: LD_INT 0
79395: PPUSH
79396: PPUSH
79397: PPUSH
79398: PPUSH
79399: PPUSH
79400: PPUSH
79401: PPUSH
79402: PPUSH
79403: PPUSH
79404: PPUSH
// result := false ;
79405: LD_ADDR_VAR 0 6
79409: PUSH
79410: LD_INT 0
79412: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79413: LD_VAR 0 1
79417: NOT
79418: PUSH
79419: LD_VAR 0 1
79423: PPUSH
79424: CALL_OW 266
79428: PUSH
79429: LD_INT 0
79431: PUSH
79432: LD_INT 1
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: IN
79439: NOT
79440: OR
79441: PUSH
79442: LD_VAR 0 2
79446: NOT
79447: OR
79448: PUSH
79449: LD_VAR 0 5
79453: PUSH
79454: LD_INT 0
79456: PUSH
79457: LD_INT 1
79459: PUSH
79460: LD_INT 2
79462: PUSH
79463: LD_INT 3
79465: PUSH
79466: LD_INT 4
79468: PUSH
79469: LD_INT 5
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: IN
79480: NOT
79481: OR
79482: PUSH
79483: LD_VAR 0 3
79487: PPUSH
79488: LD_VAR 0 4
79492: PPUSH
79493: CALL_OW 488
79497: NOT
79498: OR
79499: IFFALSE 79503
// exit ;
79501: GO 80220
// pom := GetBase ( depot ) ;
79503: LD_ADDR_VAR 0 10
79507: PUSH
79508: LD_VAR 0 1
79512: PPUSH
79513: CALL_OW 274
79517: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79518: LD_ADDR_VAR 0 11
79522: PUSH
79523: LD_VAR 0 2
79527: PPUSH
79528: LD_VAR 0 1
79532: PPUSH
79533: CALL_OW 248
79537: PPUSH
79538: CALL_OW 450
79542: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79543: LD_VAR 0 10
79547: PPUSH
79548: LD_INT 1
79550: PPUSH
79551: CALL_OW 275
79555: PUSH
79556: LD_VAR 0 11
79560: PUSH
79561: LD_INT 1
79563: ARRAY
79564: GREATEREQUAL
79565: PUSH
79566: LD_VAR 0 10
79570: PPUSH
79571: LD_INT 2
79573: PPUSH
79574: CALL_OW 275
79578: PUSH
79579: LD_VAR 0 11
79583: PUSH
79584: LD_INT 2
79586: ARRAY
79587: GREATEREQUAL
79588: AND
79589: PUSH
79590: LD_VAR 0 10
79594: PPUSH
79595: LD_INT 3
79597: PPUSH
79598: CALL_OW 275
79602: PUSH
79603: LD_VAR 0 11
79607: PUSH
79608: LD_INT 3
79610: ARRAY
79611: GREATEREQUAL
79612: AND
79613: NOT
79614: IFFALSE 79618
// exit ;
79616: GO 80220
// if GetBType ( depot ) = b_depot then
79618: LD_VAR 0 1
79622: PPUSH
79623: CALL_OW 266
79627: PUSH
79628: LD_INT 0
79630: EQUAL
79631: IFFALSE 79643
// dist := 28 else
79633: LD_ADDR_VAR 0 14
79637: PUSH
79638: LD_INT 28
79640: ST_TO_ADDR
79641: GO 79651
// dist := 36 ;
79643: LD_ADDR_VAR 0 14
79647: PUSH
79648: LD_INT 36
79650: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79651: LD_VAR 0 1
79655: PPUSH
79656: LD_VAR 0 3
79660: PPUSH
79661: LD_VAR 0 4
79665: PPUSH
79666: CALL_OW 297
79670: PUSH
79671: LD_VAR 0 14
79675: GREATER
79676: IFFALSE 79680
// exit ;
79678: GO 80220
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79680: LD_ADDR_VAR 0 12
79684: PUSH
79685: LD_VAR 0 2
79689: PPUSH
79690: LD_VAR 0 3
79694: PPUSH
79695: LD_VAR 0 4
79699: PPUSH
79700: LD_VAR 0 5
79704: PPUSH
79705: LD_VAR 0 1
79709: PPUSH
79710: CALL_OW 248
79714: PPUSH
79715: LD_INT 0
79717: PPUSH
79718: CALL 80225 0 6
79722: ST_TO_ADDR
// if not hexes then
79723: LD_VAR 0 12
79727: NOT
79728: IFFALSE 79732
// exit ;
79730: GO 80220
// hex := GetHexInfo ( x , y ) ;
79732: LD_ADDR_VAR 0 15
79736: PUSH
79737: LD_VAR 0 3
79741: PPUSH
79742: LD_VAR 0 4
79746: PPUSH
79747: CALL_OW 546
79751: ST_TO_ADDR
// if hex [ 1 ] then
79752: LD_VAR 0 15
79756: PUSH
79757: LD_INT 1
79759: ARRAY
79760: IFFALSE 79764
// exit ;
79762: GO 80220
// height := hex [ 2 ] ;
79764: LD_ADDR_VAR 0 13
79768: PUSH
79769: LD_VAR 0 15
79773: PUSH
79774: LD_INT 2
79776: ARRAY
79777: ST_TO_ADDR
// for i = 1 to hexes do
79778: LD_ADDR_VAR 0 7
79782: PUSH
79783: DOUBLE
79784: LD_INT 1
79786: DEC
79787: ST_TO_ADDR
79788: LD_VAR 0 12
79792: PUSH
79793: FOR_TO
79794: IFFALSE 80124
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79796: LD_VAR 0 12
79800: PUSH
79801: LD_VAR 0 7
79805: ARRAY
79806: PUSH
79807: LD_INT 1
79809: ARRAY
79810: PPUSH
79811: LD_VAR 0 12
79815: PUSH
79816: LD_VAR 0 7
79820: ARRAY
79821: PUSH
79822: LD_INT 2
79824: ARRAY
79825: PPUSH
79826: CALL_OW 488
79830: NOT
79831: PUSH
79832: LD_VAR 0 12
79836: PUSH
79837: LD_VAR 0 7
79841: ARRAY
79842: PUSH
79843: LD_INT 1
79845: ARRAY
79846: PPUSH
79847: LD_VAR 0 12
79851: PUSH
79852: LD_VAR 0 7
79856: ARRAY
79857: PUSH
79858: LD_INT 2
79860: ARRAY
79861: PPUSH
79862: CALL_OW 428
79866: PUSH
79867: LD_INT 0
79869: GREATER
79870: OR
79871: PUSH
79872: LD_VAR 0 12
79876: PUSH
79877: LD_VAR 0 7
79881: ARRAY
79882: PUSH
79883: LD_INT 1
79885: ARRAY
79886: PPUSH
79887: LD_VAR 0 12
79891: PUSH
79892: LD_VAR 0 7
79896: ARRAY
79897: PUSH
79898: LD_INT 2
79900: ARRAY
79901: PPUSH
79902: CALL_OW 351
79906: OR
79907: IFFALSE 79913
// exit ;
79909: POP
79910: POP
79911: GO 80220
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79913: LD_ADDR_VAR 0 8
79917: PUSH
79918: LD_VAR 0 12
79922: PUSH
79923: LD_VAR 0 7
79927: ARRAY
79928: PUSH
79929: LD_INT 1
79931: ARRAY
79932: PPUSH
79933: LD_VAR 0 12
79937: PUSH
79938: LD_VAR 0 7
79942: ARRAY
79943: PUSH
79944: LD_INT 2
79946: ARRAY
79947: PPUSH
79948: CALL_OW 546
79952: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79953: LD_VAR 0 8
79957: PUSH
79958: LD_INT 1
79960: ARRAY
79961: PUSH
79962: LD_VAR 0 8
79966: PUSH
79967: LD_INT 2
79969: ARRAY
79970: PUSH
79971: LD_VAR 0 13
79975: PUSH
79976: LD_INT 2
79978: PLUS
79979: GREATER
79980: OR
79981: PUSH
79982: LD_VAR 0 8
79986: PUSH
79987: LD_INT 2
79989: ARRAY
79990: PUSH
79991: LD_VAR 0 13
79995: PUSH
79996: LD_INT 2
79998: MINUS
79999: LESS
80000: OR
80001: PUSH
80002: LD_VAR 0 8
80006: PUSH
80007: LD_INT 3
80009: ARRAY
80010: PUSH
80011: LD_INT 0
80013: PUSH
80014: LD_INT 8
80016: PUSH
80017: LD_INT 9
80019: PUSH
80020: LD_INT 10
80022: PUSH
80023: LD_INT 11
80025: PUSH
80026: LD_INT 12
80028: PUSH
80029: LD_INT 13
80031: PUSH
80032: LD_INT 16
80034: PUSH
80035: LD_INT 17
80037: PUSH
80038: LD_INT 18
80040: PUSH
80041: LD_INT 19
80043: PUSH
80044: LD_INT 20
80046: PUSH
80047: LD_INT 21
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: IN
80065: NOT
80066: OR
80067: PUSH
80068: LD_VAR 0 8
80072: PUSH
80073: LD_INT 5
80075: ARRAY
80076: NOT
80077: OR
80078: PUSH
80079: LD_VAR 0 8
80083: PUSH
80084: LD_INT 6
80086: ARRAY
80087: PUSH
80088: LD_INT 1
80090: PUSH
80091: LD_INT 2
80093: PUSH
80094: LD_INT 7
80096: PUSH
80097: LD_INT 9
80099: PUSH
80100: LD_INT 10
80102: PUSH
80103: LD_INT 11
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: IN
80114: NOT
80115: OR
80116: IFFALSE 80122
// exit ;
80118: POP
80119: POP
80120: GO 80220
// end ;
80122: GO 79793
80124: POP
80125: POP
// side := GetSide ( depot ) ;
80126: LD_ADDR_VAR 0 9
80130: PUSH
80131: LD_VAR 0 1
80135: PPUSH
80136: CALL_OW 255
80140: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80141: LD_VAR 0 9
80145: PPUSH
80146: LD_VAR 0 3
80150: PPUSH
80151: LD_VAR 0 4
80155: PPUSH
80156: LD_INT 20
80158: PPUSH
80159: CALL 72874 0 4
80163: PUSH
80164: LD_INT 4
80166: ARRAY
80167: IFFALSE 80171
// exit ;
80169: GO 80220
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80171: LD_VAR 0 2
80175: PUSH
80176: LD_INT 29
80178: PUSH
80179: LD_INT 30
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: IN
80186: PUSH
80187: LD_VAR 0 3
80191: PPUSH
80192: LD_VAR 0 4
80196: PPUSH
80197: LD_VAR 0 9
80201: PPUSH
80202: CALL_OW 440
80206: NOT
80207: AND
80208: IFFALSE 80212
// exit ;
80210: GO 80220
// result := true ;
80212: LD_ADDR_VAR 0 6
80216: PUSH
80217: LD_INT 1
80219: ST_TO_ADDR
// end ;
80220: LD_VAR 0 6
80224: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80225: LD_INT 0
80227: PPUSH
80228: PPUSH
80229: PPUSH
80230: PPUSH
80231: PPUSH
80232: PPUSH
80233: PPUSH
80234: PPUSH
80235: PPUSH
80236: PPUSH
80237: PPUSH
80238: PPUSH
80239: PPUSH
80240: PPUSH
80241: PPUSH
80242: PPUSH
80243: PPUSH
80244: PPUSH
80245: PPUSH
80246: PPUSH
80247: PPUSH
80248: PPUSH
80249: PPUSH
80250: PPUSH
80251: PPUSH
80252: PPUSH
80253: PPUSH
80254: PPUSH
80255: PPUSH
80256: PPUSH
80257: PPUSH
80258: PPUSH
80259: PPUSH
80260: PPUSH
80261: PPUSH
80262: PPUSH
80263: PPUSH
80264: PPUSH
80265: PPUSH
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
80274: PPUSH
80275: PPUSH
80276: PPUSH
80277: PPUSH
80278: PPUSH
80279: PPUSH
80280: PPUSH
80281: PPUSH
80282: PPUSH
80283: PPUSH
80284: PPUSH
// result = [ ] ;
80285: LD_ADDR_VAR 0 7
80289: PUSH
80290: EMPTY
80291: ST_TO_ADDR
// temp_list = [ ] ;
80292: LD_ADDR_VAR 0 9
80296: PUSH
80297: EMPTY
80298: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80299: LD_VAR 0 4
80303: PUSH
80304: LD_INT 0
80306: PUSH
80307: LD_INT 1
80309: PUSH
80310: LD_INT 2
80312: PUSH
80313: LD_INT 3
80315: PUSH
80316: LD_INT 4
80318: PUSH
80319: LD_INT 5
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: IN
80330: NOT
80331: PUSH
80332: LD_VAR 0 1
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: LD_INT 1
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: IN
80347: PUSH
80348: LD_VAR 0 5
80352: PUSH
80353: LD_INT 1
80355: PUSH
80356: LD_INT 2
80358: PUSH
80359: LD_INT 3
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: LIST
80366: IN
80367: NOT
80368: AND
80369: OR
80370: IFFALSE 80374
// exit ;
80372: GO 98765
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80374: LD_VAR 0 1
80378: PUSH
80379: LD_INT 6
80381: PUSH
80382: LD_INT 7
80384: PUSH
80385: LD_INT 8
80387: PUSH
80388: LD_INT 13
80390: PUSH
80391: LD_INT 12
80393: PUSH
80394: LD_INT 15
80396: PUSH
80397: LD_INT 11
80399: PUSH
80400: LD_INT 14
80402: PUSH
80403: LD_INT 10
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: IN
80417: IFFALSE 80427
// btype = b_lab ;
80419: LD_ADDR_VAR 0 1
80423: PUSH
80424: LD_INT 6
80426: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80427: LD_VAR 0 6
80431: PUSH
80432: LD_INT 0
80434: PUSH
80435: LD_INT 1
80437: PUSH
80438: LD_INT 2
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: LIST
80445: IN
80446: NOT
80447: PUSH
80448: LD_VAR 0 1
80452: PUSH
80453: LD_INT 0
80455: PUSH
80456: LD_INT 1
80458: PUSH
80459: LD_INT 2
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 6
80467: PUSH
80468: LD_INT 36
80470: PUSH
80471: LD_INT 4
80473: PUSH
80474: LD_INT 5
80476: PUSH
80477: LD_INT 31
80479: PUSH
80480: LD_INT 32
80482: PUSH
80483: LD_INT 33
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: IN
80499: NOT
80500: PUSH
80501: LD_VAR 0 6
80505: PUSH
80506: LD_INT 1
80508: EQUAL
80509: AND
80510: OR
80511: PUSH
80512: LD_VAR 0 1
80516: PUSH
80517: LD_INT 2
80519: PUSH
80520: LD_INT 3
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: IN
80527: NOT
80528: PUSH
80529: LD_VAR 0 6
80533: PUSH
80534: LD_INT 2
80536: EQUAL
80537: AND
80538: OR
80539: IFFALSE 80549
// mode = 0 ;
80541: LD_ADDR_VAR 0 6
80545: PUSH
80546: LD_INT 0
80548: ST_TO_ADDR
// case mode of 0 :
80549: LD_VAR 0 6
80553: PUSH
80554: LD_INT 0
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80562
80560: GO 92015
80562: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80563: LD_ADDR_VAR 0 11
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 0
80580: PUSH
80581: LD_INT 1
80583: NEG
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 1
80591: PUSH
80592: LD_INT 0
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: LD_INT 1
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 1
80621: NEG
80622: PUSH
80623: LD_INT 0
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 1
80632: NEG
80633: PUSH
80634: LD_INT 1
80636: NEG
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 1
80644: NEG
80645: PUSH
80646: LD_INT 2
80648: NEG
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 0
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 1
80667: PUSH
80668: LD_INT 1
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 1
80678: PUSH
80679: LD_INT 2
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 2
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 1
80698: NEG
80699: PUSH
80700: LD_INT 1
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 1
80709: PUSH
80710: LD_INT 3
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: LD_INT 3
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 1
80729: NEG
80730: PUSH
80731: LD_INT 2
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80756: LD_ADDR_VAR 0 12
80760: PUSH
80761: LD_INT 0
80763: PUSH
80764: LD_INT 0
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: LD_INT 1
80776: NEG
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: LD_INT 0
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: PUSH
80795: LD_INT 1
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: LD_INT 0
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 2
80858: PUSH
80859: LD_INT 1
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 1
80868: NEG
80869: PUSH
80870: LD_INT 1
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 2
80879: NEG
80880: PUSH
80881: LD_INT 0
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 2
80890: NEG
80891: PUSH
80892: LD_INT 1
80894: NEG
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 2
80902: NEG
80903: PUSH
80904: LD_INT 1
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 3
80913: NEG
80914: PUSH
80915: LD_INT 0
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 3
80924: NEG
80925: PUSH
80926: LD_INT 1
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80952: LD_ADDR_VAR 0 13
80956: PUSH
80957: LD_INT 0
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 0
80969: PUSH
80970: LD_INT 1
80972: NEG
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: PUSH
80981: LD_INT 0
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 1
80990: PUSH
80991: LD_INT 1
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: LD_INT 1
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: NEG
81011: PUSH
81012: LD_INT 0
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 1
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: LD_INT 2
81037: NEG
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 2
81045: PUSH
81046: LD_INT 1
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 2
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 1
81065: PUSH
81066: LD_INT 2
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 2
81075: NEG
81076: PUSH
81077: LD_INT 1
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 2
81087: NEG
81088: PUSH
81089: LD_INT 2
81091: NEG
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 2
81099: NEG
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 3
81111: NEG
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 3
81123: NEG
81124: PUSH
81125: LD_INT 3
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81151: LD_ADDR_VAR 0 14
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 0
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 0
81168: PUSH
81169: LD_INT 1
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 1
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 1
81209: NEG
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: NEG
81233: PUSH
81234: LD_INT 2
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 0
81244: PUSH
81245: LD_INT 2
81247: NEG
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 1
81266: PUSH
81267: LD_INT 2
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: LD_INT 2
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 1
81286: NEG
81287: PUSH
81288: LD_INT 1
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: NEG
81298: PUSH
81299: LD_INT 3
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 0
81309: PUSH
81310: LD_INT 3
81312: NEG
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: LD_INT 2
81323: NEG
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81347: LD_ADDR_VAR 0 15
81351: PUSH
81352: LD_INT 0
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 0
81364: PUSH
81365: LD_INT 1
81367: NEG
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 1
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 1
81385: PUSH
81386: LD_INT 1
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 1
81405: NEG
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 1
81416: NEG
81417: PUSH
81418: LD_INT 1
81420: NEG
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PUSH
81426: LD_INT 1
81428: PUSH
81429: LD_INT 1
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 2
81439: PUSH
81440: LD_INT 0
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 1
81459: NEG
81460: PUSH
81461: LD_INT 1
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 2
81470: NEG
81471: PUSH
81472: LD_INT 0
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 2
81481: NEG
81482: PUSH
81483: LD_INT 1
81485: NEG
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 2
81493: PUSH
81494: LD_INT 1
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 3
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 3
81514: PUSH
81515: LD_INT 1
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81540: LD_ADDR_VAR 0 16
81544: PUSH
81545: LD_INT 0
81547: PUSH
81548: LD_INT 0
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 0
81557: PUSH
81558: LD_INT 1
81560: NEG
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 1
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 0
81588: PUSH
81589: LD_INT 1
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 1
81598: NEG
81599: PUSH
81600: LD_INT 0
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 1
81609: NEG
81610: PUSH
81611: LD_INT 1
81613: NEG
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 1
81621: NEG
81622: PUSH
81623: LD_INT 2
81625: NEG
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 2
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 2
81643: PUSH
81644: LD_INT 2
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: LD_INT 2
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 2
81663: NEG
81664: PUSH
81665: LD_INT 1
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 2
81675: NEG
81676: PUSH
81677: LD_INT 2
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 3
81687: PUSH
81688: LD_INT 2
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 3
81697: PUSH
81698: LD_INT 3
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 2
81707: PUSH
81708: LD_INT 3
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81733: LD_ADDR_VAR 0 17
81737: PUSH
81738: LD_INT 0
81740: PUSH
81741: LD_INT 0
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 0
81750: PUSH
81751: LD_INT 1
81753: NEG
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 1
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: PUSH
81772: LD_INT 1
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 0
81781: PUSH
81782: LD_INT 1
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 1
81791: NEG
81792: PUSH
81793: LD_INT 0
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 1
81802: NEG
81803: PUSH
81804: LD_INT 1
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: LD_INT 2
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: LD_INT 2
81829: NEG
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 1
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 2
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 2
81858: PUSH
81859: LD_INT 1
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 2
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 1
81878: PUSH
81879: LD_INT 2
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: LD_INT 2
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 2
81909: NEG
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 2
81932: NEG
81933: PUSH
81934: LD_INT 2
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81963: LD_ADDR_VAR 0 18
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: LD_INT 0
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 0
81980: PUSH
81981: LD_INT 1
81983: NEG
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 1
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: LD_INT 1
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: LD_INT 1
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: LD_INT 0
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 1
82032: NEG
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: LD_INT 2
82048: NEG
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 0
82056: PUSH
82057: LD_INT 2
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: LD_INT 1
82070: NEG
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 2
82078: PUSH
82079: LD_INT 0
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 2
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 2
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 1
82108: PUSH
82109: LD_INT 2
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 0
82118: PUSH
82119: LD_INT 2
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: LD_INT 1
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: NEG
82140: PUSH
82141: LD_INT 0
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 2
82150: NEG
82151: PUSH
82152: LD_INT 1
82154: NEG
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 2
82162: NEG
82163: PUSH
82164: LD_INT 2
82166: NEG
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82193: LD_ADDR_VAR 0 19
82197: PUSH
82198: LD_INT 0
82200: PUSH
82201: LD_INT 0
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 0
82210: PUSH
82211: LD_INT 1
82213: NEG
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 1
82231: PUSH
82232: LD_INT 1
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 0
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 1
82251: NEG
82252: PUSH
82253: LD_INT 0
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: NEG
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 1
82274: NEG
82275: PUSH
82276: LD_INT 2
82278: NEG
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: LD_INT 2
82289: NEG
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: PUSH
82295: LD_INT 1
82297: PUSH
82298: LD_INT 1
82300: NEG
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 2
82308: PUSH
82309: LD_INT 0
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 2
82318: PUSH
82319: LD_INT 1
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: LD_INT 2
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 1
82338: PUSH
82339: LD_INT 2
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: LD_INT 2
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 1
82358: NEG
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 2
82380: NEG
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 2
82392: NEG
82393: PUSH
82394: LD_INT 2
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82423: LD_ADDR_VAR 0 20
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: LD_INT 0
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 0
82440: PUSH
82441: LD_INT 1
82443: NEG
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 1
82451: PUSH
82452: LD_INT 0
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: PUSH
82462: LD_INT 1
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: LD_INT 1
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 1
82481: NEG
82482: PUSH
82483: LD_INT 0
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 1
82492: NEG
82493: PUSH
82494: LD_INT 1
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: LD_INT 2
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 0
82516: PUSH
82517: LD_INT 2
82519: NEG
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: LD_INT 1
82527: PUSH
82528: LD_INT 1
82530: NEG
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 2
82538: PUSH
82539: LD_INT 0
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 2
82548: PUSH
82549: LD_INT 1
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 2
82558: PUSH
82559: LD_INT 2
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 1
82568: PUSH
82569: LD_INT 2
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: LD_INT 2
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 1
82588: NEG
82589: PUSH
82590: LD_INT 1
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 2
82599: NEG
82600: PUSH
82601: LD_INT 0
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 2
82610: NEG
82611: PUSH
82612: LD_INT 1
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 2
82622: NEG
82623: PUSH
82624: LD_INT 2
82626: NEG
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82653: LD_ADDR_VAR 0 21
82657: PUSH
82658: LD_INT 0
82660: PUSH
82661: LD_INT 0
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: LD_INT 1
82673: NEG
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 1
82681: PUSH
82682: LD_INT 0
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 1
82691: PUSH
82692: LD_INT 1
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 0
82701: PUSH
82702: LD_INT 1
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 1
82711: NEG
82712: PUSH
82713: LD_INT 0
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 1
82722: NEG
82723: PUSH
82724: LD_INT 1
82726: NEG
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: LD_INT 2
82738: NEG
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 0
82746: PUSH
82747: LD_INT 2
82749: NEG
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: LD_INT 1
82760: NEG
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 2
82768: PUSH
82769: LD_INT 0
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 2
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 2
82788: PUSH
82789: LD_INT 2
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: PUSH
82799: LD_INT 2
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 0
82808: PUSH
82809: LD_INT 2
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: NEG
82819: PUSH
82820: LD_INT 1
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: NEG
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 2
82840: NEG
82841: PUSH
82842: LD_INT 1
82844: NEG
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: LD_INT 2
82856: NEG
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82883: LD_ADDR_VAR 0 22
82887: PUSH
82888: LD_INT 0
82890: PUSH
82891: LD_INT 0
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 0
82900: PUSH
82901: LD_INT 1
82903: NEG
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 1
82911: PUSH
82912: LD_INT 0
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 1
82921: PUSH
82922: LD_INT 1
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 0
82931: PUSH
82932: LD_INT 1
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: NEG
82942: PUSH
82943: LD_INT 0
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 1
82952: NEG
82953: PUSH
82954: LD_INT 1
82956: NEG
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 1
82964: NEG
82965: PUSH
82966: LD_INT 2
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 0
82976: PUSH
82977: LD_INT 2
82979: NEG
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 1
82987: PUSH
82988: LD_INT 1
82990: NEG
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 2
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 2
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 2
83018: PUSH
83019: LD_INT 2
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: LD_INT 2
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: LD_INT 2
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 1
83048: NEG
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 2
83059: NEG
83060: PUSH
83061: LD_INT 0
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 2
83070: NEG
83071: PUSH
83072: LD_INT 1
83074: NEG
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: LD_INT 2
83086: NEG
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83113: LD_ADDR_VAR 0 23
83117: PUSH
83118: LD_INT 0
83120: PUSH
83121: LD_INT 0
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: LD_INT 1
83133: NEG
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: LD_INT 0
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: PUSH
83152: LD_INT 1
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 1
83182: NEG
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 1
83194: NEG
83195: PUSH
83196: LD_INT 2
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 0
83206: PUSH
83207: LD_INT 2
83209: NEG
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 1
83217: PUSH
83218: LD_INT 1
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 2
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 2
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_INT 2
83248: PUSH
83249: LD_INT 2
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: LD_INT 2
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 0
83268: PUSH
83269: LD_INT 2
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 1
83278: NEG
83279: PUSH
83280: LD_INT 1
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: NEG
83290: PUSH
83291: LD_INT 0
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 2
83300: NEG
83301: PUSH
83302: LD_INT 1
83304: NEG
83305: PUSH
83306: EMPTY
83307: LIST
83308: LIST
83309: PUSH
83310: LD_INT 2
83312: NEG
83313: PUSH
83314: LD_INT 2
83316: NEG
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 2
83324: NEG
83325: PUSH
83326: LD_INT 3
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 1
83336: NEG
83337: PUSH
83338: LD_INT 3
83340: NEG
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 1
83348: PUSH
83349: LD_INT 2
83351: NEG
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 2
83359: PUSH
83360: LD_INT 1
83362: NEG
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83393: LD_ADDR_VAR 0 24
83397: PUSH
83398: LD_INT 0
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 0
83410: PUSH
83411: LD_INT 1
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: PUSH
83422: LD_INT 0
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 1
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 0
83441: PUSH
83442: LD_INT 1
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 1
83451: NEG
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 1
83462: NEG
83463: PUSH
83464: LD_INT 1
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 1
83474: NEG
83475: PUSH
83476: LD_INT 2
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: LD_INT 2
83489: NEG
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 1
83497: PUSH
83498: LD_INT 1
83500: NEG
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: LD_INT 1
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 2
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: LD_INT 2
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 0
83548: PUSH
83549: LD_INT 2
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 1
83558: NEG
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 2
83569: NEG
83570: PUSH
83571: LD_INT 0
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 2
83580: NEG
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 2
83592: NEG
83593: PUSH
83594: LD_INT 2
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: LD_INT 2
83607: NEG
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 2
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 3
83626: PUSH
83627: LD_INT 1
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 3
83636: PUSH
83637: LD_INT 2
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83669: LD_ADDR_VAR 0 25
83673: PUSH
83674: LD_INT 0
83676: PUSH
83677: LD_INT 0
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 0
83686: PUSH
83687: LD_INT 1
83689: NEG
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 1
83697: PUSH
83698: LD_INT 0
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 1
83707: PUSH
83708: LD_INT 1
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: LD_INT 1
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 1
83727: NEG
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 1
83738: NEG
83739: PUSH
83740: LD_INT 1
83742: NEG
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: LD_INT 1
83750: NEG
83751: PUSH
83752: LD_INT 2
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 0
83762: PUSH
83763: LD_INT 2
83765: NEG
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 1
83773: PUSH
83774: LD_INT 1
83776: NEG
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: LD_INT 0
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 2
83794: PUSH
83795: LD_INT 1
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 2
83804: PUSH
83805: LD_INT 2
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: LD_INT 2
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 0
83824: PUSH
83825: LD_INT 2
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 1
83834: NEG
83835: PUSH
83836: LD_INT 1
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: NEG
83846: PUSH
83847: LD_INT 0
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: PUSH
83854: LD_INT 2
83856: NEG
83857: PUSH
83858: LD_INT 1
83860: NEG
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 2
83868: NEG
83869: PUSH
83870: LD_INT 2
83872: NEG
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 3
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 3
83890: PUSH
83891: LD_INT 2
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: LD_INT 2
83900: PUSH
83901: LD_INT 3
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 1
83910: PUSH
83911: LD_INT 3
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83943: LD_ADDR_VAR 0 26
83947: PUSH
83948: LD_INT 0
83950: PUSH
83951: LD_INT 0
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 0
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 1
83971: PUSH
83972: LD_INT 0
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: LD_INT 1
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 1
84001: NEG
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: LD_INT 1
84016: NEG
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 1
84024: NEG
84025: PUSH
84026: LD_INT 2
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: LD_INT 2
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 1
84050: NEG
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 2
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: LD_INT 1
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 2
84078: PUSH
84079: LD_INT 2
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 2
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: LD_INT 2
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: LD_INT 1
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 2
84119: NEG
84120: PUSH
84121: LD_INT 0
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 2
84130: NEG
84131: PUSH
84132: LD_INT 1
84134: NEG
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 2
84142: NEG
84143: PUSH
84144: LD_INT 2
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 2
84154: PUSH
84155: LD_INT 3
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 1
84164: PUSH
84165: LD_INT 3
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 1
84174: NEG
84175: PUSH
84176: LD_INT 2
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 2
84185: NEG
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84219: LD_ADDR_VAR 0 27
84223: PUSH
84224: LD_INT 0
84226: PUSH
84227: LD_INT 0
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 0
84236: PUSH
84237: LD_INT 1
84239: NEG
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 1
84247: PUSH
84248: LD_INT 0
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 1
84257: PUSH
84258: LD_INT 1
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: LD_INT 0
84267: PUSH
84268: LD_INT 1
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: NEG
84278: PUSH
84279: LD_INT 0
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 1
84288: NEG
84289: PUSH
84290: LD_INT 1
84292: NEG
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: LD_INT 2
84304: NEG
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 0
84312: PUSH
84313: LD_INT 2
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 2
84334: PUSH
84335: LD_INT 0
84337: PUSH
84338: EMPTY
84339: LIST
84340: LIST
84341: PUSH
84342: LD_INT 2
84344: PUSH
84345: LD_INT 1
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 2
84354: PUSH
84355: LD_INT 2
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 2
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: LD_INT 2
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 2
84395: NEG
84396: PUSH
84397: LD_INT 0
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: NEG
84407: PUSH
84408: LD_INT 1
84410: NEG
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 2
84418: NEG
84419: PUSH
84420: LD_INT 2
84422: NEG
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 1
84430: NEG
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: NEG
84442: PUSH
84443: LD_INT 1
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: LD_INT 3
84452: NEG
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 3
84464: NEG
84465: PUSH
84466: LD_INT 2
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84499: LD_ADDR_VAR 0 28
84503: PUSH
84504: LD_INT 0
84506: PUSH
84507: LD_INT 0
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 0
84516: PUSH
84517: LD_INT 1
84519: NEG
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 1
84527: PUSH
84528: LD_INT 0
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 0
84547: PUSH
84548: LD_INT 1
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 1
84557: NEG
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 1
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 1
84580: NEG
84581: PUSH
84582: LD_INT 2
84584: NEG
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 0
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 1
84603: PUSH
84604: LD_INT 1
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: PUSH
84615: LD_INT 0
84617: PUSH
84618: EMPTY
84619: LIST
84620: LIST
84621: PUSH
84622: LD_INT 2
84624: PUSH
84625: LD_INT 1
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: LD_INT 2
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: LD_INT 2
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: LD_INT 0
84654: PUSH
84655: LD_INT 2
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: PUSH
84662: LD_INT 1
84664: NEG
84665: PUSH
84666: LD_INT 1
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 2
84675: NEG
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 2
84686: NEG
84687: PUSH
84688: LD_INT 1
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 2
84698: NEG
84699: PUSH
84700: LD_INT 2
84702: NEG
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 2
84710: NEG
84711: PUSH
84712: LD_INT 3
84714: NEG
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: NEG
84723: PUSH
84724: LD_INT 3
84726: NEG
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 3
84734: NEG
84735: PUSH
84736: LD_INT 1
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 3
84746: NEG
84747: PUSH
84748: LD_INT 2
84750: NEG
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84781: LD_ADDR_VAR 0 29
84785: PUSH
84786: LD_INT 0
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 0
84798: PUSH
84799: LD_INT 1
84801: NEG
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: LD_INT 1
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 0
84829: PUSH
84830: LD_INT 1
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 1
84839: NEG
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: NEG
84851: PUSH
84852: LD_INT 1
84854: NEG
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: PUSH
84860: LD_INT 1
84862: NEG
84863: PUSH
84864: LD_INT 2
84866: NEG
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 0
84874: PUSH
84875: LD_INT 2
84877: NEG
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 1
84885: PUSH
84886: LD_INT 1
84888: NEG
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 2
84896: PUSH
84897: LD_INT 0
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 2
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 1
84916: PUSH
84917: LD_INT 2
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 0
84926: PUSH
84927: LD_INT 2
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 1
84936: NEG
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 2
84947: NEG
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 2
84959: NEG
84960: PUSH
84961: LD_INT 2
84963: NEG
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 2
84971: NEG
84972: PUSH
84973: LD_INT 3
84975: NEG
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 2
84983: PUSH
84984: LD_INT 1
84986: NEG
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 3
84994: PUSH
84995: LD_INT 1
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: LD_INT 3
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 1
85014: NEG
85015: PUSH
85016: LD_INT 2
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PUSH
85023: LD_INT 3
85025: NEG
85026: PUSH
85027: LD_INT 2
85029: NEG
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85060: LD_ADDR_VAR 0 30
85064: PUSH
85065: LD_INT 0
85067: PUSH
85068: LD_INT 0
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: LD_INT 1
85080: NEG
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 1
85088: PUSH
85089: LD_INT 0
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 1
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 0
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 1
85118: NEG
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 1
85129: NEG
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: PUSH
85143: LD_INT 2
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: LD_INT 2
85156: NEG
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: PUSH
85165: LD_INT 1
85167: NEG
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 2
85175: PUSH
85176: LD_INT 0
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 2
85185: PUSH
85186: LD_INT 1
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 2
85195: PUSH
85196: LD_INT 2
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: LD_INT 2
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 1
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 2
85226: NEG
85227: PUSH
85228: LD_INT 0
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 2
85237: NEG
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 1
85249: NEG
85250: PUSH
85251: LD_INT 3
85253: NEG
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: LD_INT 2
85264: NEG
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 3
85272: PUSH
85273: LD_INT 2
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: PUSH
85280: LD_INT 2
85282: PUSH
85283: LD_INT 3
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 2
85292: NEG
85293: PUSH
85294: LD_INT 1
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 3
85303: NEG
85304: PUSH
85305: LD_INT 1
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85338: LD_ADDR_VAR 0 31
85342: PUSH
85343: LD_INT 0
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: LD_INT 1
85358: NEG
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 0
85386: PUSH
85387: LD_INT 1
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: LD_INT 1
85396: NEG
85397: PUSH
85398: LD_INT 0
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: LD_INT 1
85411: NEG
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 1
85419: NEG
85420: PUSH
85421: LD_INT 2
85423: NEG
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 1
85431: PUSH
85432: LD_INT 1
85434: NEG
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 2
85442: PUSH
85443: LD_INT 0
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 2
85452: PUSH
85453: LD_INT 1
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: LD_INT 2
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 1
85472: PUSH
85473: LD_INT 2
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 0
85482: PUSH
85483: LD_INT 2
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: PUSH
85490: LD_INT 1
85492: NEG
85493: PUSH
85494: LD_INT 1
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: PUSH
85501: LD_INT 2
85503: NEG
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 2
85515: NEG
85516: PUSH
85517: LD_INT 2
85519: NEG
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 2
85527: NEG
85528: PUSH
85529: LD_INT 3
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 2
85539: PUSH
85540: LD_INT 1
85542: NEG
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 3
85550: PUSH
85551: LD_INT 1
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 1
85560: PUSH
85561: LD_INT 3
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 1
85570: NEG
85571: PUSH
85572: LD_INT 2
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 3
85581: NEG
85582: PUSH
85583: LD_INT 2
85585: NEG
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85616: LD_ADDR_VAR 0 32
85620: PUSH
85621: LD_INT 0
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 0
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: LD_INT 0
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: LD_INT 1
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 1
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: NEG
85686: PUSH
85687: LD_INT 1
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 1
85697: NEG
85698: PUSH
85699: LD_INT 2
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 2
85712: NEG
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: LD_INT 2
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: PUSH
85752: LD_INT 2
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 0
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 1
85771: NEG
85772: PUSH
85773: LD_INT 1
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 2
85782: NEG
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 2
85793: NEG
85794: PUSH
85795: LD_INT 1
85797: NEG
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 1
85805: NEG
85806: PUSH
85807: LD_INT 3
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 3
85828: PUSH
85829: LD_INT 2
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: LD_INT 3
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 2
85848: NEG
85849: PUSH
85850: LD_INT 1
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 3
85859: NEG
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85894: LD_ADDR_VAR 0 33
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 0
85911: PUSH
85912: LD_INT 1
85914: NEG
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 1
85922: PUSH
85923: LD_INT 0
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 1
85932: PUSH
85933: LD_INT 1
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_INT 0
85942: PUSH
85943: LD_INT 1
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 1
85952: NEG
85953: PUSH
85954: LD_INT 0
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 1
85963: NEG
85964: PUSH
85965: LD_INT 1
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: LD_INT 1
85975: NEG
85976: PUSH
85977: LD_INT 2
85979: NEG
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: LD_INT 1
85987: PUSH
85988: LD_INT 1
85990: NEG
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: LD_INT 0
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 2
86008: PUSH
86009: LD_INT 1
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: LD_INT 1
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 0
86028: PUSH
86029: LD_INT 2
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: PUSH
86036: LD_INT 1
86038: NEG
86039: PUSH
86040: LD_INT 1
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: PUSH
86047: LD_INT 2
86049: NEG
86050: PUSH
86051: LD_INT 0
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 2
86060: NEG
86061: PUSH
86062: LD_INT 1
86064: NEG
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 2
86072: NEG
86073: PUSH
86074: LD_INT 2
86076: NEG
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 2
86084: NEG
86085: PUSH
86086: LD_INT 3
86088: NEG
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 2
86096: PUSH
86097: LD_INT 1
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 3
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 1
86117: PUSH
86118: LD_INT 3
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: LD_INT 2
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 3
86138: NEG
86139: PUSH
86140: LD_INT 2
86142: NEG
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86173: LD_ADDR_VAR 0 34
86177: PUSH
86178: LD_INT 0
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: LD_INT 1
86193: NEG
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 1
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: LD_INT 1
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 0
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: LD_INT 0
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 1
86242: NEG
86243: PUSH
86244: LD_INT 1
86246: NEG
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: PUSH
86256: LD_INT 2
86258: NEG
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: LD_INT 2
86269: NEG
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: PUSH
86278: LD_INT 1
86280: NEG
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 2
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 2
86298: PUSH
86299: LD_INT 2
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 1
86318: NEG
86319: PUSH
86320: LD_INT 1
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 2
86329: NEG
86330: PUSH
86331: LD_INT 0
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 2
86340: NEG
86341: PUSH
86342: LD_INT 1
86344: NEG
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 2
86352: NEG
86353: PUSH
86354: LD_INT 2
86356: NEG
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 1
86364: NEG
86365: PUSH
86366: LD_INT 3
86368: NEG
86369: PUSH
86370: EMPTY
86371: LIST
86372: LIST
86373: PUSH
86374: LD_INT 1
86376: PUSH
86377: LD_INT 2
86379: NEG
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 3
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 2
86397: PUSH
86398: LD_INT 3
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 2
86407: NEG
86408: PUSH
86409: LD_INT 1
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 3
86418: NEG
86419: PUSH
86420: LD_INT 1
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86453: LD_ADDR_VAR 0 35
86457: PUSH
86458: LD_INT 0
86460: PUSH
86461: LD_INT 0
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: LD_INT 1
86473: NEG
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 1
86481: PUSH
86482: LD_INT 0
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 1
86511: NEG
86512: PUSH
86513: LD_INT 0
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: LD_INT 1
86526: NEG
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 2
86534: PUSH
86535: LD_INT 1
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 2
86544: NEG
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86565: LD_ADDR_VAR 0 36
86569: PUSH
86570: LD_INT 0
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 0
86582: PUSH
86583: LD_INT 1
86585: NEG
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 1
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: PUSH
86604: LD_INT 1
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 1
86623: NEG
86624: PUSH
86625: LD_INT 0
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 1
86646: NEG
86647: PUSH
86648: LD_INT 2
86650: NEG
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 1
86658: PUSH
86659: LD_INT 2
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86677: LD_ADDR_VAR 0 37
86681: PUSH
86682: LD_INT 0
86684: PUSH
86685: LD_INT 0
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 0
86694: PUSH
86695: LD_INT 1
86697: NEG
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 1
86705: PUSH
86706: LD_INT 0
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: PUSH
86713: LD_INT 1
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 1
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 1
86735: NEG
86736: PUSH
86737: LD_INT 0
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: LD_INT 1
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86789: LD_ADDR_VAR 0 38
86793: PUSH
86794: LD_INT 0
86796: PUSH
86797: LD_INT 0
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: LD_INT 1
86809: NEG
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 1
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 1
86827: PUSH
86828: LD_INT 1
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 1
86847: NEG
86848: PUSH
86849: LD_INT 0
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 1
86858: NEG
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 1
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 2
86880: NEG
86881: PUSH
86882: LD_INT 1
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86901: LD_ADDR_VAR 0 39
86905: PUSH
86906: LD_INT 0
86908: PUSH
86909: LD_INT 0
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 0
86918: PUSH
86919: LD_INT 1
86921: NEG
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 1
86929: PUSH
86930: LD_INT 0
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 1
86939: PUSH
86940: LD_INT 1
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: LD_INT 0
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: PUSH
86972: LD_INT 1
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 1
86982: NEG
86983: PUSH
86984: LD_INT 2
86986: NEG
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 1
86994: PUSH
86995: LD_INT 2
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87013: LD_ADDR_VAR 0 40
87017: PUSH
87018: LD_INT 0
87020: PUSH
87021: LD_INT 0
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 1
87033: NEG
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 0
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 1
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: NEG
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: PUSH
87095: LD_INT 1
87097: NEG
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: LD_INT 1
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87125: LD_ADDR_VAR 0 41
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: LD_INT 0
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 0
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: PUSH
87154: LD_INT 0
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 1
87163: PUSH
87164: LD_INT 1
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: LD_INT 1
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 0
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: LD_INT 1
87198: NEG
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: NEG
87207: PUSH
87208: LD_INT 2
87210: NEG
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 1
87218: PUSH
87219: LD_INT 1
87221: NEG
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 2
87229: PUSH
87230: LD_INT 0
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 2
87239: PUSH
87240: LD_INT 1
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 2
87249: PUSH
87250: LD_INT 2
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: LD_INT 2
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 1
87269: NEG
87270: PUSH
87271: LD_INT 1
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 2
87280: NEG
87281: PUSH
87282: LD_INT 0
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: PUSH
87289: LD_INT 2
87291: NEG
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 2
87303: NEG
87304: PUSH
87305: LD_INT 2
87307: NEG
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 2
87315: NEG
87316: PUSH
87317: LD_INT 3
87319: NEG
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: PUSH
87325: LD_INT 2
87327: PUSH
87328: LD_INT 1
87330: NEG
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: PUSH
87336: LD_INT 3
87338: PUSH
87339: LD_INT 0
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 3
87348: PUSH
87349: LD_INT 1
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 3
87358: PUSH
87359: LD_INT 2
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 3
87368: PUSH
87369: LD_INT 3
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PUSH
87376: LD_INT 2
87378: PUSH
87379: LD_INT 3
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 2
87388: NEG
87389: PUSH
87390: LD_INT 1
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 3
87399: NEG
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 3
87410: NEG
87411: PUSH
87412: LD_INT 1
87414: NEG
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 3
87422: NEG
87423: PUSH
87424: LD_INT 2
87426: NEG
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: LD_INT 3
87434: NEG
87435: PUSH
87436: LD_INT 3
87438: NEG
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87475: LD_ADDR_VAR 0 42
87479: PUSH
87480: LD_INT 0
87482: PUSH
87483: LD_INT 0
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 0
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 1
87503: PUSH
87504: LD_INT 0
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 1
87513: PUSH
87514: LD_INT 1
87516: PUSH
87517: EMPTY
87518: LIST
87519: LIST
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: LD_INT 1
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 1
87533: NEG
87534: PUSH
87535: LD_INT 0
87537: PUSH
87538: EMPTY
87539: LIST
87540: LIST
87541: PUSH
87542: LD_INT 1
87544: NEG
87545: PUSH
87546: LD_INT 1
87548: NEG
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: PUSH
87554: LD_INT 1
87556: NEG
87557: PUSH
87558: LD_INT 2
87560: NEG
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 0
87568: PUSH
87569: LD_INT 2
87571: NEG
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 1
87579: PUSH
87580: LD_INT 1
87582: NEG
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 2
87590: PUSH
87591: LD_INT 1
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 2
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 1
87610: PUSH
87611: LD_INT 2
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: LD_INT 2
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 1
87630: NEG
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 2
87641: NEG
87642: PUSH
87643: LD_INT 1
87645: NEG
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 2
87653: NEG
87654: PUSH
87655: LD_INT 2
87657: NEG
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 2
87665: NEG
87666: PUSH
87667: LD_INT 3
87669: NEG
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: LD_INT 3
87681: NEG
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 0
87689: PUSH
87690: LD_INT 3
87692: NEG
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 1
87700: PUSH
87701: LD_INT 2
87703: NEG
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 3
87711: PUSH
87712: LD_INT 2
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 3
87721: PUSH
87722: LD_INT 3
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 2
87731: PUSH
87732: LD_INT 3
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 1
87741: PUSH
87742: LD_INT 3
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: LD_INT 3
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 2
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 3
87772: NEG
87773: PUSH
87774: LD_INT 2
87776: NEG
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 3
87784: NEG
87785: PUSH
87786: LD_INT 3
87788: NEG
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87825: LD_ADDR_VAR 0 43
87829: PUSH
87830: LD_INT 0
87832: PUSH
87833: LD_INT 0
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 0
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 1
87853: PUSH
87854: LD_INT 0
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: LD_INT 1
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: LD_INT 1
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 1
87883: NEG
87884: PUSH
87885: LD_INT 0
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 1
87894: NEG
87895: PUSH
87896: LD_INT 1
87898: NEG
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PUSH
87904: LD_INT 1
87906: NEG
87907: PUSH
87908: LD_INT 2
87910: NEG
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: LD_INT 2
87921: NEG
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 1
87929: PUSH
87930: LD_INT 1
87932: NEG
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 2
87940: PUSH
87941: LD_INT 0
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 2
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: LD_INT 2
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: LD_INT 2
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: NEG
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: NEG
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 2
88002: NEG
88003: PUSH
88004: LD_INT 1
88006: NEG
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: LD_INT 3
88018: NEG
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 0
88026: PUSH
88027: LD_INT 3
88029: NEG
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 1
88037: PUSH
88038: LD_INT 2
88040: NEG
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 2
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 3
88059: PUSH
88060: LD_INT 0
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 3
88069: PUSH
88070: LD_INT 1
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 1
88079: PUSH
88080: LD_INT 3
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 0
88089: PUSH
88090: LD_INT 3
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 1
88099: NEG
88100: PUSH
88101: LD_INT 2
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 2
88110: NEG
88111: PUSH
88112: LD_INT 1
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 3
88121: NEG
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 3
88132: NEG
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88173: LD_ADDR_VAR 0 44
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: NEG
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: LD_INT 2
88258: NEG
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 1
88266: PUSH
88267: LD_INT 1
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 2
88277: PUSH
88278: LD_INT 0
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: PUSH
88285: LD_INT 2
88287: PUSH
88288: LD_INT 1
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PUSH
88295: LD_INT 2
88297: PUSH
88298: LD_INT 2
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: PUSH
88305: LD_INT 1
88307: PUSH
88308: LD_INT 2
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: LD_INT 1
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 2
88328: NEG
88329: PUSH
88330: LD_INT 0
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: NEG
88340: PUSH
88341: LD_INT 1
88343: NEG
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: PUSH
88349: LD_INT 2
88351: NEG
88352: PUSH
88353: LD_INT 2
88355: NEG
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 2
88363: NEG
88364: PUSH
88365: LD_INT 3
88367: NEG
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 2
88375: PUSH
88376: LD_INT 1
88378: NEG
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: LD_INT 3
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 3
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 3
88406: PUSH
88407: LD_INT 2
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 3
88416: PUSH
88417: LD_INT 3
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 2
88426: PUSH
88427: LD_INT 3
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: PUSH
88434: LD_INT 2
88436: NEG
88437: PUSH
88438: LD_INT 1
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 3
88447: NEG
88448: PUSH
88449: LD_INT 0
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 3
88458: NEG
88459: PUSH
88460: LD_INT 1
88462: NEG
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 3
88470: NEG
88471: PUSH
88472: LD_INT 2
88474: NEG
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 3
88482: NEG
88483: PUSH
88484: LD_INT 3
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88523: LD_ADDR_VAR 0 45
88527: PUSH
88528: LD_INT 0
88530: PUSH
88531: LD_INT 0
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 0
88540: PUSH
88541: LD_INT 1
88543: NEG
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 1
88551: PUSH
88552: LD_INT 0
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 1
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: LD_INT 1
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 1
88581: NEG
88582: PUSH
88583: LD_INT 0
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 1
88592: NEG
88593: PUSH
88594: LD_INT 1
88596: NEG
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: PUSH
88602: LD_INT 1
88604: NEG
88605: PUSH
88606: LD_INT 2
88608: NEG
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: LD_INT 2
88619: NEG
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 1
88627: PUSH
88628: LD_INT 1
88630: NEG
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 2
88638: PUSH
88639: LD_INT 1
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 2
88648: PUSH
88649: LD_INT 2
88651: PUSH
88652: EMPTY
88653: LIST
88654: LIST
88655: PUSH
88656: LD_INT 1
88658: PUSH
88659: LD_INT 2
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: NEG
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: NEG
88690: PUSH
88691: LD_INT 1
88693: NEG
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 2
88701: NEG
88702: PUSH
88703: LD_INT 2
88705: NEG
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 2
88713: NEG
88714: PUSH
88715: LD_INT 3
88717: NEG
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 1
88725: NEG
88726: PUSH
88727: LD_INT 3
88729: NEG
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: PUSH
88735: LD_INT 0
88737: PUSH
88738: LD_INT 3
88740: NEG
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 1
88748: PUSH
88749: LD_INT 2
88751: NEG
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 3
88759: PUSH
88760: LD_INT 2
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 3
88769: PUSH
88770: LD_INT 3
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 2
88779: PUSH
88780: LD_INT 3
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: LD_INT 3
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 0
88799: PUSH
88800: LD_INT 3
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: PUSH
88811: LD_INT 2
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 3
88820: NEG
88821: PUSH
88822: LD_INT 2
88824: NEG
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 3
88832: NEG
88833: PUSH
88834: LD_INT 3
88836: NEG
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88873: LD_ADDR_VAR 0 46
88877: PUSH
88878: LD_INT 0
88880: PUSH
88881: LD_INT 0
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 0
88890: PUSH
88891: LD_INT 1
88893: NEG
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 1
88901: PUSH
88902: LD_INT 0
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 1
88911: PUSH
88912: LD_INT 1
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 1
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 1
88931: NEG
88932: PUSH
88933: LD_INT 0
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: NEG
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 1
88954: NEG
88955: PUSH
88956: LD_INT 2
88958: NEG
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: LD_INT 2
88969: NEG
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: LD_INT 1
88977: PUSH
88978: LD_INT 1
88980: NEG
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: PUSH
88986: LD_INT 2
88988: PUSH
88989: LD_INT 0
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PUSH
88996: LD_INT 2
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: LD_INT 2
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 0
89018: PUSH
89019: LD_INT 2
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 1
89028: NEG
89029: PUSH
89030: LD_INT 1
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 2
89039: NEG
89040: PUSH
89041: LD_INT 0
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: LD_INT 3
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 0
89074: PUSH
89075: LD_INT 3
89077: NEG
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 1
89085: PUSH
89086: LD_INT 2
89088: NEG
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 2
89096: PUSH
89097: LD_INT 1
89099: NEG
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 3
89107: PUSH
89108: LD_INT 0
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PUSH
89115: LD_INT 3
89117: PUSH
89118: LD_INT 1
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: LD_INT 1
89127: PUSH
89128: LD_INT 3
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: LD_INT 3
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: PUSH
89145: LD_INT 1
89147: NEG
89148: PUSH
89149: LD_INT 2
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 2
89158: NEG
89159: PUSH
89160: LD_INT 1
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 3
89169: NEG
89170: PUSH
89171: LD_INT 0
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 3
89180: NEG
89181: PUSH
89182: LD_INT 1
89184: NEG
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89221: LD_ADDR_VAR 0 47
89225: PUSH
89226: LD_INT 0
89228: PUSH
89229: LD_INT 0
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: PUSH
89236: LD_INT 0
89238: PUSH
89239: LD_INT 1
89241: NEG
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: LD_INT 0
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PUSH
89257: LD_INT 1
89259: PUSH
89260: LD_INT 1
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: LD_INT 0
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 1
89279: NEG
89280: PUSH
89281: LD_INT 0
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 1
89294: NEG
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 2
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 0
89314: PUSH
89315: LD_INT 2
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: LD_INT 1
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 2
89336: NEG
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 2
89348: NEG
89349: PUSH
89350: LD_INT 2
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89372: LD_ADDR_VAR 0 48
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: LD_INT 0
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: LD_INT 1
89392: NEG
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 1
89400: PUSH
89401: LD_INT 0
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 1
89410: PUSH
89411: LD_INT 1
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 0
89420: PUSH
89421: LD_INT 1
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 1
89430: NEG
89431: PUSH
89432: LD_INT 0
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 1
89441: NEG
89442: PUSH
89443: LD_INT 1
89445: NEG
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: LD_INT 2
89457: NEG
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: LD_INT 0
89465: PUSH
89466: LD_INT 2
89468: NEG
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: LD_INT 1
89479: NEG
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 2
89487: PUSH
89488: LD_INT 0
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 2
89497: PUSH
89498: LD_INT 1
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89519: LD_ADDR_VAR 0 49
89523: PUSH
89524: LD_INT 0
89526: PUSH
89527: LD_INT 0
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: PUSH
89534: LD_INT 0
89536: PUSH
89537: LD_INT 1
89539: NEG
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 1
89547: PUSH
89548: LD_INT 0
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 1
89557: PUSH
89558: LD_INT 1
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: LD_INT 1
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 1
89577: NEG
89578: PUSH
89579: LD_INT 0
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 1
89588: NEG
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 1
89600: PUSH
89601: LD_INT 1
89603: NEG
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 2
89611: PUSH
89612: LD_INT 0
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 2
89621: PUSH
89622: LD_INT 1
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 2
89631: PUSH
89632: LD_INT 2
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 1
89641: PUSH
89642: LD_INT 2
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89663: LD_ADDR_VAR 0 50
89667: PUSH
89668: LD_INT 0
89670: PUSH
89671: LD_INT 0
89673: PUSH
89674: EMPTY
89675: LIST
89676: LIST
89677: PUSH
89678: LD_INT 0
89680: PUSH
89681: LD_INT 1
89683: NEG
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: LD_INT 0
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 1
89701: PUSH
89702: LD_INT 1
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 0
89711: PUSH
89712: LD_INT 1
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 1
89721: NEG
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 1
89732: NEG
89733: PUSH
89734: LD_INT 1
89736: NEG
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 2
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 2
89754: PUSH
89755: LD_INT 2
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: LD_INT 2
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 0
89774: PUSH
89775: LD_INT 2
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 1
89784: NEG
89785: PUSH
89786: LD_INT 1
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89807: LD_ADDR_VAR 0 51
89811: PUSH
89812: LD_INT 0
89814: PUSH
89815: LD_INT 0
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: LD_INT 1
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: LD_INT 0
89838: PUSH
89839: EMPTY
89840: LIST
89841: LIST
89842: PUSH
89843: LD_INT 1
89845: PUSH
89846: LD_INT 1
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: LD_INT 1
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: LD_INT 0
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 1
89876: NEG
89877: PUSH
89878: LD_INT 1
89880: NEG
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PUSH
89886: LD_INT 1
89888: PUSH
89889: LD_INT 2
89891: PUSH
89892: EMPTY
89893: LIST
89894: LIST
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: LD_INT 2
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 1
89908: NEG
89909: PUSH
89910: LD_INT 1
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 2
89919: NEG
89920: PUSH
89921: LD_INT 0
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 2
89930: NEG
89931: PUSH
89932: LD_INT 1
89934: NEG
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89954: LD_ADDR_VAR 0 52
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 0
89971: PUSH
89972: LD_INT 1
89974: NEG
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 1
89982: PUSH
89983: LD_INT 0
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 1
89992: PUSH
89993: LD_INT 1
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: LD_INT 1
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: NEG
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 1
90023: NEG
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: LD_INT 2
90039: NEG
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: LD_INT 1
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 2
90058: NEG
90059: PUSH
90060: LD_INT 0
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 2
90069: NEG
90070: PUSH
90071: LD_INT 1
90073: NEG
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: NEG
90082: PUSH
90083: LD_INT 2
90085: NEG
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90105: LD_ADDR_VAR 0 53
90109: PUSH
90110: LD_INT 0
90112: PUSH
90113: LD_INT 0
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 0
90122: PUSH
90123: LD_INT 1
90125: NEG
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 1
90133: PUSH
90134: LD_INT 0
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: LD_INT 1
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 0
90153: PUSH
90154: LD_INT 1
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 1
90163: NEG
90164: PUSH
90165: LD_INT 0
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: LD_INT 1
90174: NEG
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: LD_INT 2
90190: NEG
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 0
90198: PUSH
90199: LD_INT 2
90201: NEG
90202: PUSH
90203: EMPTY
90204: LIST
90205: LIST
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: LD_INT 1
90212: NEG
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 2
90220: PUSH
90221: LD_INT 0
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 2
90230: PUSH
90231: LD_INT 1
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 2
90240: PUSH
90241: LD_INT 2
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 1
90250: PUSH
90251: LD_INT 2
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 0
90260: PUSH
90261: LD_INT 2
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: NEG
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 2
90281: NEG
90282: PUSH
90283: LD_INT 0
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 2
90292: NEG
90293: PUSH
90294: LD_INT 1
90296: NEG
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 2
90304: NEG
90305: PUSH
90306: LD_INT 2
90308: NEG
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90335: LD_ADDR_VAR 0 54
90339: PUSH
90340: LD_INT 0
90342: PUSH
90343: LD_INT 0
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 0
90352: PUSH
90353: LD_INT 1
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 1
90363: PUSH
90364: LD_INT 0
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: LD_INT 1
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 1
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 1
90393: NEG
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 1
90404: NEG
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PUSH
90414: LD_INT 1
90416: NEG
90417: PUSH
90418: LD_INT 2
90420: NEG
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 0
90428: PUSH
90429: LD_INT 2
90431: NEG
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 1
90439: PUSH
90440: LD_INT 1
90442: NEG
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 2
90450: PUSH
90451: LD_INT 0
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 2
90460: PUSH
90461: LD_INT 1
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: PUSH
90468: LD_INT 2
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: PUSH
90481: LD_INT 2
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: LD_INT 2
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: NEG
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 2
90511: NEG
90512: PUSH
90513: LD_INT 0
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PUSH
90520: LD_INT 2
90522: NEG
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 2
90534: NEG
90535: PUSH
90536: LD_INT 2
90538: NEG
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90565: LD_ADDR_VAR 0 55
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 0
90582: PUSH
90583: LD_INT 1
90585: NEG
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 1
90593: PUSH
90594: LD_INT 0
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: PUSH
90604: LD_INT 1
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 0
90613: PUSH
90614: LD_INT 1
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 1
90623: NEG
90624: PUSH
90625: LD_INT 0
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 1
90634: NEG
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: NEG
90647: PUSH
90648: LD_INT 2
90650: NEG
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: LD_INT 2
90661: NEG
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: LD_INT 1
90672: NEG
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 2
90680: PUSH
90681: LD_INT 0
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 2
90690: PUSH
90691: LD_INT 1
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 2
90700: PUSH
90701: LD_INT 2
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: PUSH
90711: LD_INT 2
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 0
90720: PUSH
90721: LD_INT 2
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: NEG
90731: PUSH
90732: LD_INT 1
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 2
90741: NEG
90742: PUSH
90743: LD_INT 0
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 2
90752: NEG
90753: PUSH
90754: LD_INT 1
90756: NEG
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 2
90764: NEG
90765: PUSH
90766: LD_INT 2
90768: NEG
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90795: LD_ADDR_VAR 0 56
90799: PUSH
90800: LD_INT 0
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: LD_INT 0
90812: PUSH
90813: LD_INT 1
90815: NEG
90816: PUSH
90817: EMPTY
90818: LIST
90819: LIST
90820: PUSH
90821: LD_INT 1
90823: PUSH
90824: LD_INT 0
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 1
90833: PUSH
90834: LD_INT 1
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 0
90843: PUSH
90844: LD_INT 1
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 1
90853: NEG
90854: PUSH
90855: LD_INT 0
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: PUSH
90862: LD_INT 1
90864: NEG
90865: PUSH
90866: LD_INT 1
90868: NEG
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: LD_INT 2
90880: NEG
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PUSH
90886: LD_INT 0
90888: PUSH
90889: LD_INT 2
90891: NEG
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 1
90899: PUSH
90900: LD_INT 1
90902: NEG
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 2
90910: PUSH
90911: LD_INT 0
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 2
90920: PUSH
90921: LD_INT 1
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 2
90930: PUSH
90931: LD_INT 2
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: PUSH
90941: LD_INT 2
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 0
90950: PUSH
90951: LD_INT 2
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: LD_INT 1
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 2
90971: NEG
90972: PUSH
90973: LD_INT 0
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 2
90982: NEG
90983: PUSH
90984: LD_INT 1
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 2
90994: NEG
90995: PUSH
90996: LD_INT 2
90998: NEG
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91025: LD_ADDR_VAR 0 57
91029: PUSH
91030: LD_INT 0
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: LD_INT 1
91045: NEG
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: LD_INT 1
91053: PUSH
91054: LD_INT 0
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 1
91063: PUSH
91064: LD_INT 1
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 0
91073: PUSH
91074: LD_INT 1
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: LD_INT 0
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 1
91094: NEG
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 1
91106: NEG
91107: PUSH
91108: LD_INT 2
91110: NEG
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 0
91118: PUSH
91119: LD_INT 2
91121: NEG
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 1
91129: PUSH
91130: LD_INT 1
91132: NEG
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 2
91140: PUSH
91141: LD_INT 0
91143: PUSH
91144: EMPTY
91145: LIST
91146: LIST
91147: PUSH
91148: LD_INT 2
91150: PUSH
91151: LD_INT 1
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: LD_INT 2
91160: PUSH
91161: LD_INT 2
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 1
91170: PUSH
91171: LD_INT 2
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: LD_INT 2
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: LD_INT 1
91190: NEG
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 2
91201: NEG
91202: PUSH
91203: LD_INT 0
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 2
91212: NEG
91213: PUSH
91214: LD_INT 1
91216: NEG
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: PUSH
91222: LD_INT 2
91224: NEG
91225: PUSH
91226: LD_INT 2
91228: NEG
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91255: LD_ADDR_VAR 0 58
91259: PUSH
91260: LD_INT 0
91262: PUSH
91263: LD_INT 0
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: PUSH
91270: LD_INT 0
91272: PUSH
91273: LD_INT 1
91275: NEG
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: PUSH
91281: LD_INT 1
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 1
91293: PUSH
91294: LD_INT 1
91296: PUSH
91297: EMPTY
91298: LIST
91299: LIST
91300: PUSH
91301: LD_INT 0
91303: PUSH
91304: LD_INT 1
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 1
91313: NEG
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 1
91324: NEG
91325: PUSH
91326: LD_INT 1
91328: NEG
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: PUSH
91334: LD_INT 1
91336: NEG
91337: PUSH
91338: LD_INT 2
91340: NEG
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 0
91348: PUSH
91349: LD_INT 2
91351: NEG
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 1
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 2
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 2
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 2
91390: PUSH
91391: LD_INT 2
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 1
91400: PUSH
91401: LD_INT 2
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: LD_INT 2
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 1
91420: NEG
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 2
91431: NEG
91432: PUSH
91433: LD_INT 0
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 2
91442: NEG
91443: PUSH
91444: LD_INT 1
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 2
91454: NEG
91455: PUSH
91456: LD_INT 2
91458: NEG
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91485: LD_ADDR_VAR 0 59
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: LD_INT 0
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 0
91502: PUSH
91503: LD_INT 1
91505: NEG
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 1
91513: PUSH
91514: LD_INT 0
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: PUSH
91521: LD_INT 1
91523: PUSH
91524: LD_INT 1
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: LD_INT 1
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 1
91543: NEG
91544: PUSH
91545: LD_INT 0
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 1
91554: NEG
91555: PUSH
91556: LD_INT 1
91558: NEG
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91573: LD_ADDR_VAR 0 60
91577: PUSH
91578: LD_INT 0
91580: PUSH
91581: LD_INT 0
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 0
91590: PUSH
91591: LD_INT 1
91593: NEG
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: LD_INT 0
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: PUSH
91609: LD_INT 1
91611: PUSH
91612: LD_INT 1
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: LD_INT 1
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 1
91631: NEG
91632: PUSH
91633: LD_INT 0
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: NEG
91643: PUSH
91644: LD_INT 1
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91661: LD_ADDR_VAR 0 61
91665: PUSH
91666: LD_INT 0
91668: PUSH
91669: LD_INT 0
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 0
91678: PUSH
91679: LD_INT 1
91681: NEG
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 1
91689: PUSH
91690: LD_INT 0
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: LD_INT 1
91699: PUSH
91700: LD_INT 1
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: PUSH
91707: LD_INT 0
91709: PUSH
91710: LD_INT 1
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 1
91719: NEG
91720: PUSH
91721: LD_INT 0
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 1
91730: NEG
91731: PUSH
91732: LD_INT 1
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91749: LD_ADDR_VAR 0 62
91753: PUSH
91754: LD_INT 0
91756: PUSH
91757: LD_INT 0
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 0
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 1
91777: PUSH
91778: LD_INT 0
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 1
91787: PUSH
91788: LD_INT 1
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 0
91797: PUSH
91798: LD_INT 1
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 1
91807: NEG
91808: PUSH
91809: LD_INT 0
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 1
91818: NEG
91819: PUSH
91820: LD_INT 1
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91837: LD_ADDR_VAR 0 63
91841: PUSH
91842: LD_INT 0
91844: PUSH
91845: LD_INT 0
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 0
91854: PUSH
91855: LD_INT 1
91857: NEG
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 1
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 1
91875: PUSH
91876: LD_INT 1
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 0
91885: PUSH
91886: LD_INT 1
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 1
91895: NEG
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 1
91906: NEG
91907: PUSH
91908: LD_INT 1
91910: NEG
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91925: LD_ADDR_VAR 0 64
91929: PUSH
91930: LD_INT 0
91932: PUSH
91933: LD_INT 0
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 0
91942: PUSH
91943: LD_INT 1
91945: NEG
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 1
91953: PUSH
91954: LD_INT 0
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 1
91963: PUSH
91964: LD_INT 1
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: LD_INT 0
91973: PUSH
91974: LD_INT 1
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 1
91983: NEG
91984: PUSH
91985: LD_INT 0
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 1
91994: NEG
91995: PUSH
91996: LD_INT 1
91998: NEG
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: ST_TO_ADDR
// end ; 1 :
92013: GO 97910
92015: LD_INT 1
92017: DOUBLE
92018: EQUAL
92019: IFTRUE 92023
92021: GO 94646
92023: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92024: LD_ADDR_VAR 0 11
92028: PUSH
92029: LD_INT 1
92031: NEG
92032: PUSH
92033: LD_INT 3
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 0
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 1
92054: PUSH
92055: LD_INT 2
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: LIST
92067: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92068: LD_ADDR_VAR 0 12
92072: PUSH
92073: LD_INT 2
92075: PUSH
92076: LD_INT 1
92078: NEG
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 3
92086: PUSH
92087: LD_INT 0
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 3
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: LIST
92108: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92109: LD_ADDR_VAR 0 13
92113: PUSH
92114: LD_INT 3
92116: PUSH
92117: LD_INT 2
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 3
92126: PUSH
92127: LD_INT 3
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 2
92136: PUSH
92137: LD_INT 3
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: LIST
92148: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92149: LD_ADDR_VAR 0 14
92153: PUSH
92154: LD_INT 1
92156: PUSH
92157: LD_INT 3
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 0
92166: PUSH
92167: LD_INT 3
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 1
92176: NEG
92177: PUSH
92178: LD_INT 2
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: LIST
92189: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92190: LD_ADDR_VAR 0 15
92194: PUSH
92195: LD_INT 2
92197: NEG
92198: PUSH
92199: LD_INT 1
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 3
92208: NEG
92209: PUSH
92210: LD_INT 0
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 3
92219: NEG
92220: PUSH
92221: LD_INT 1
92223: NEG
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: LIST
92233: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92234: LD_ADDR_VAR 0 16
92238: PUSH
92239: LD_INT 2
92241: NEG
92242: PUSH
92243: LD_INT 3
92245: NEG
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 3
92253: NEG
92254: PUSH
92255: LD_INT 2
92257: NEG
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 3
92265: NEG
92266: PUSH
92267: LD_INT 3
92269: NEG
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: LIST
92279: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92280: LD_ADDR_VAR 0 17
92284: PUSH
92285: LD_INT 1
92287: NEG
92288: PUSH
92289: LD_INT 3
92291: NEG
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 0
92299: PUSH
92300: LD_INT 3
92302: NEG
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 1
92310: PUSH
92311: LD_INT 2
92313: NEG
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: LIST
92323: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92324: LD_ADDR_VAR 0 18
92328: PUSH
92329: LD_INT 2
92331: PUSH
92332: LD_INT 1
92334: NEG
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 3
92342: PUSH
92343: LD_INT 0
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 3
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: LIST
92364: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92365: LD_ADDR_VAR 0 19
92369: PUSH
92370: LD_INT 3
92372: PUSH
92373: LD_INT 2
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 3
92382: PUSH
92383: LD_INT 3
92385: PUSH
92386: EMPTY
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 2
92392: PUSH
92393: LD_INT 3
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: LIST
92404: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92405: LD_ADDR_VAR 0 20
92409: PUSH
92410: LD_INT 1
92412: PUSH
92413: LD_INT 3
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: LD_INT 0
92422: PUSH
92423: LD_INT 3
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: LD_INT 1
92432: NEG
92433: PUSH
92434: LD_INT 2
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: LIST
92445: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92446: LD_ADDR_VAR 0 21
92450: PUSH
92451: LD_INT 2
92453: NEG
92454: PUSH
92455: LD_INT 1
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 3
92464: NEG
92465: PUSH
92466: LD_INT 0
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 3
92475: NEG
92476: PUSH
92477: LD_INT 1
92479: NEG
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: LIST
92489: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92490: LD_ADDR_VAR 0 22
92494: PUSH
92495: LD_INT 2
92497: NEG
92498: PUSH
92499: LD_INT 3
92501: NEG
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 3
92509: NEG
92510: PUSH
92511: LD_INT 2
92513: NEG
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: PUSH
92519: LD_INT 3
92521: NEG
92522: PUSH
92523: LD_INT 3
92525: NEG
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: LIST
92535: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92536: LD_ADDR_VAR 0 23
92540: PUSH
92541: LD_INT 0
92543: PUSH
92544: LD_INT 3
92546: NEG
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 1
92554: NEG
92555: PUSH
92556: LD_INT 4
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: PUSH
92567: LD_INT 3
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: LIST
92579: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92580: LD_ADDR_VAR 0 24
92584: PUSH
92585: LD_INT 3
92587: PUSH
92588: LD_INT 0
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: PUSH
92598: LD_INT 1
92600: NEG
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 4
92608: PUSH
92609: LD_INT 1
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: LIST
92620: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92621: LD_ADDR_VAR 0 25
92625: PUSH
92626: LD_INT 3
92628: PUSH
92629: LD_INT 3
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 4
92638: PUSH
92639: LD_INT 3
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 3
92648: PUSH
92649: LD_INT 4
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: LIST
92660: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92661: LD_ADDR_VAR 0 26
92665: PUSH
92666: LD_INT 0
92668: PUSH
92669: LD_INT 3
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 1
92678: PUSH
92679: LD_INT 4
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 1
92688: NEG
92689: PUSH
92690: LD_INT 3
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: LIST
92701: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92702: LD_ADDR_VAR 0 27
92706: PUSH
92707: LD_INT 3
92709: NEG
92710: PUSH
92711: LD_INT 0
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: PUSH
92718: LD_INT 3
92720: NEG
92721: PUSH
92722: LD_INT 1
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PUSH
92729: LD_INT 4
92731: NEG
92732: PUSH
92733: LD_INT 1
92735: NEG
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: LIST
92745: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92746: LD_ADDR_VAR 0 28
92750: PUSH
92751: LD_INT 3
92753: NEG
92754: PUSH
92755: LD_INT 3
92757: NEG
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 3
92765: NEG
92766: PUSH
92767: LD_INT 4
92769: NEG
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 4
92777: NEG
92778: PUSH
92779: LD_INT 3
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: LIST
92791: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92792: LD_ADDR_VAR 0 29
92796: PUSH
92797: LD_INT 1
92799: NEG
92800: PUSH
92801: LD_INT 3
92803: NEG
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 0
92811: PUSH
92812: LD_INT 3
92814: NEG
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: LD_INT 1
92822: PUSH
92823: LD_INT 2
92825: NEG
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 1
92833: NEG
92834: PUSH
92835: LD_INT 4
92837: NEG
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 0
92845: PUSH
92846: LD_INT 4
92848: NEG
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 1
92856: PUSH
92857: LD_INT 3
92859: NEG
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 1
92867: NEG
92868: PUSH
92869: LD_INT 5
92871: NEG
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 0
92879: PUSH
92880: LD_INT 5
92882: NEG
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: LD_INT 1
92890: PUSH
92891: LD_INT 4
92893: NEG
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 1
92901: NEG
92902: PUSH
92903: LD_INT 6
92905: NEG
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: LD_INT 6
92916: NEG
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PUSH
92922: LD_INT 1
92924: PUSH
92925: LD_INT 5
92927: NEG
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92947: LD_ADDR_VAR 0 30
92951: PUSH
92952: LD_INT 2
92954: PUSH
92955: LD_INT 1
92957: NEG
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 3
92965: PUSH
92966: LD_INT 0
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 3
92975: PUSH
92976: LD_INT 1
92978: PUSH
92979: EMPTY
92980: LIST
92981: LIST
92982: PUSH
92983: LD_INT 3
92985: PUSH
92986: LD_INT 1
92988: NEG
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: LD_INT 4
92996: PUSH
92997: LD_INT 0
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 4
93006: PUSH
93007: LD_INT 1
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 4
93016: PUSH
93017: LD_INT 1
93019: NEG
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 5
93027: PUSH
93028: LD_INT 0
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 5
93037: PUSH
93038: LD_INT 1
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 5
93047: PUSH
93048: LD_INT 1
93050: NEG
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 6
93058: PUSH
93059: LD_INT 0
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 6
93068: PUSH
93069: LD_INT 1
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93090: LD_ADDR_VAR 0 31
93094: PUSH
93095: LD_INT 3
93097: PUSH
93098: LD_INT 2
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: LD_INT 3
93107: PUSH
93108: LD_INT 3
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 2
93117: PUSH
93118: LD_INT 3
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 4
93127: PUSH
93128: LD_INT 3
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 4
93137: PUSH
93138: LD_INT 4
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: LD_INT 3
93147: PUSH
93148: LD_INT 4
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PUSH
93155: LD_INT 5
93157: PUSH
93158: LD_INT 4
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 5
93167: PUSH
93168: LD_INT 5
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 4
93177: PUSH
93178: LD_INT 5
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 6
93187: PUSH
93188: LD_INT 5
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 6
93197: PUSH
93198: LD_INT 6
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 5
93207: PUSH
93208: LD_INT 6
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93229: LD_ADDR_VAR 0 32
93233: PUSH
93234: LD_INT 1
93236: PUSH
93237: LD_INT 3
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 0
93246: PUSH
93247: LD_INT 3
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 1
93256: NEG
93257: PUSH
93258: LD_INT 2
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 1
93267: PUSH
93268: LD_INT 4
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 0
93277: PUSH
93278: LD_INT 4
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 1
93287: NEG
93288: PUSH
93289: LD_INT 3
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: LD_INT 1
93298: PUSH
93299: LD_INT 5
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 0
93308: PUSH
93309: LD_INT 5
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 1
93318: NEG
93319: PUSH
93320: LD_INT 4
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: PUSH
93327: LD_INT 1
93329: PUSH
93330: LD_INT 6
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 6
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: NEG
93350: PUSH
93351: LD_INT 5
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93372: LD_ADDR_VAR 0 33
93376: PUSH
93377: LD_INT 2
93379: NEG
93380: PUSH
93381: LD_INT 1
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 3
93390: NEG
93391: PUSH
93392: LD_INT 0
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 3
93401: NEG
93402: PUSH
93403: LD_INT 1
93405: NEG
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 3
93413: NEG
93414: PUSH
93415: LD_INT 1
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 4
93424: NEG
93425: PUSH
93426: LD_INT 0
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 4
93435: NEG
93436: PUSH
93437: LD_INT 1
93439: NEG
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 4
93447: NEG
93448: PUSH
93449: LD_INT 1
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 5
93458: NEG
93459: PUSH
93460: LD_INT 0
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 5
93469: NEG
93470: PUSH
93471: LD_INT 1
93473: NEG
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 5
93481: NEG
93482: PUSH
93483: LD_INT 1
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: PUSH
93490: LD_INT 6
93492: NEG
93493: PUSH
93494: LD_INT 0
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 6
93503: NEG
93504: PUSH
93505: LD_INT 1
93507: NEG
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93527: LD_ADDR_VAR 0 34
93531: PUSH
93532: LD_INT 2
93534: NEG
93535: PUSH
93536: LD_INT 3
93538: NEG
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 3
93546: NEG
93547: PUSH
93548: LD_INT 2
93550: NEG
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 3
93558: NEG
93559: PUSH
93560: LD_INT 3
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: LD_INT 4
93574: NEG
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: LD_INT 4
93582: NEG
93583: PUSH
93584: LD_INT 3
93586: NEG
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: PUSH
93592: LD_INT 4
93594: NEG
93595: PUSH
93596: LD_INT 4
93598: NEG
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 4
93606: NEG
93607: PUSH
93608: LD_INT 5
93610: NEG
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 5
93618: NEG
93619: PUSH
93620: LD_INT 4
93622: NEG
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: LD_INT 5
93630: NEG
93631: PUSH
93632: LD_INT 5
93634: NEG
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: LD_INT 5
93642: NEG
93643: PUSH
93644: LD_INT 6
93646: NEG
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 6
93654: NEG
93655: PUSH
93656: LD_INT 5
93658: NEG
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 6
93666: NEG
93667: PUSH
93668: LD_INT 6
93670: NEG
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93690: LD_ADDR_VAR 0 41
93694: PUSH
93695: LD_INT 0
93697: PUSH
93698: LD_INT 2
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 1
93708: NEG
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 1
93720: PUSH
93721: LD_INT 2
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: LIST
93733: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93734: LD_ADDR_VAR 0 42
93738: PUSH
93739: LD_INT 2
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 1
93754: NEG
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: LD_INT 3
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: LIST
93774: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93775: LD_ADDR_VAR 0 43
93779: PUSH
93780: LD_INT 2
93782: PUSH
93783: LD_INT 2
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: LD_INT 2
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 2
93802: PUSH
93803: LD_INT 3
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: LIST
93814: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93815: LD_ADDR_VAR 0 44
93819: PUSH
93820: LD_INT 0
93822: PUSH
93823: LD_INT 2
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 1
93832: PUSH
93833: LD_INT 3
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 1
93842: NEG
93843: PUSH
93844: LD_INT 2
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: LIST
93855: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93856: LD_ADDR_VAR 0 45
93860: PUSH
93861: LD_INT 2
93863: NEG
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 2
93874: NEG
93875: PUSH
93876: LD_INT 1
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 3
93885: NEG
93886: PUSH
93887: LD_INT 1
93889: NEG
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: LIST
93899: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93900: LD_ADDR_VAR 0 46
93904: PUSH
93905: LD_INT 2
93907: NEG
93908: PUSH
93909: LD_INT 2
93911: NEG
93912: PUSH
93913: EMPTY
93914: LIST
93915: LIST
93916: PUSH
93917: LD_INT 2
93919: NEG
93920: PUSH
93921: LD_INT 3
93923: NEG
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PUSH
93929: LD_INT 3
93931: NEG
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: LIST
93945: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93946: LD_ADDR_VAR 0 47
93950: PUSH
93951: LD_INT 2
93953: NEG
93954: PUSH
93955: LD_INT 3
93957: NEG
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 1
93965: NEG
93966: PUSH
93967: LD_INT 3
93969: NEG
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93979: LD_ADDR_VAR 0 48
93983: PUSH
93984: LD_INT 1
93986: PUSH
93987: LD_INT 2
93989: NEG
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 2
93997: PUSH
93998: LD_INT 1
94000: NEG
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94010: LD_ADDR_VAR 0 49
94014: PUSH
94015: LD_INT 3
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: LD_INT 3
94027: PUSH
94028: LD_INT 2
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94039: LD_ADDR_VAR 0 50
94043: PUSH
94044: LD_INT 2
94046: PUSH
94047: LD_INT 3
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 1
94056: PUSH
94057: LD_INT 3
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94068: LD_ADDR_VAR 0 51
94072: PUSH
94073: LD_INT 1
94075: NEG
94076: PUSH
94077: LD_INT 2
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 2
94086: NEG
94087: PUSH
94088: LD_INT 1
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94099: LD_ADDR_VAR 0 52
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 1
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 3
94118: NEG
94119: PUSH
94120: LD_INT 2
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94132: LD_ADDR_VAR 0 53
94136: PUSH
94137: LD_INT 1
94139: NEG
94140: PUSH
94141: LD_INT 3
94143: NEG
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 0
94151: PUSH
94152: LD_INT 3
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 1
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: LIST
94175: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94176: LD_ADDR_VAR 0 54
94180: PUSH
94181: LD_INT 2
94183: PUSH
94184: LD_INT 1
94186: NEG
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 3
94194: PUSH
94195: LD_INT 0
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 3
94204: PUSH
94205: LD_INT 1
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: LIST
94216: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94217: LD_ADDR_VAR 0 55
94221: PUSH
94222: LD_INT 3
94224: PUSH
94225: LD_INT 2
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: LD_INT 3
94234: PUSH
94235: LD_INT 3
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 2
94244: PUSH
94245: LD_INT 3
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: LIST
94256: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94257: LD_ADDR_VAR 0 56
94261: PUSH
94262: LD_INT 1
94264: PUSH
94265: LD_INT 3
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 0
94274: PUSH
94275: LD_INT 3
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 1
94284: NEG
94285: PUSH
94286: LD_INT 2
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: LIST
94297: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94298: LD_ADDR_VAR 0 57
94302: PUSH
94303: LD_INT 2
94305: NEG
94306: PUSH
94307: LD_INT 1
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 3
94316: NEG
94317: PUSH
94318: LD_INT 0
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 3
94327: NEG
94328: PUSH
94329: LD_INT 1
94331: NEG
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: LIST
94341: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94342: LD_ADDR_VAR 0 58
94346: PUSH
94347: LD_INT 2
94349: NEG
94350: PUSH
94351: LD_INT 3
94353: NEG
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 3
94361: NEG
94362: PUSH
94363: LD_INT 2
94365: NEG
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 3
94373: NEG
94374: PUSH
94375: LD_INT 3
94377: NEG
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: LIST
94387: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94388: LD_ADDR_VAR 0 59
94392: PUSH
94393: LD_INT 1
94395: NEG
94396: PUSH
94397: LD_INT 2
94399: NEG
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 0
94407: PUSH
94408: LD_INT 2
94410: NEG
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 1
94418: PUSH
94419: LD_INT 1
94421: NEG
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: LIST
94431: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94432: LD_ADDR_VAR 0 60
94436: PUSH
94437: LD_INT 1
94439: PUSH
94440: LD_INT 1
94442: NEG
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: LD_INT 2
94450: PUSH
94451: LD_INT 0
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: PUSH
94458: LD_INT 2
94460: PUSH
94461: LD_INT 1
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: LIST
94472: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94473: LD_ADDR_VAR 0 61
94477: PUSH
94478: LD_INT 2
94480: PUSH
94481: LD_INT 1
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 2
94490: PUSH
94491: LD_INT 2
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 1
94500: PUSH
94501: LD_INT 2
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: LIST
94512: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94513: LD_ADDR_VAR 0 62
94517: PUSH
94518: LD_INT 1
94520: PUSH
94521: LD_INT 2
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: LD_INT 0
94530: PUSH
94531: LD_INT 2
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 1
94540: NEG
94541: PUSH
94542: LD_INT 1
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: LIST
94553: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94554: LD_ADDR_VAR 0 63
94558: PUSH
94559: LD_INT 1
94561: NEG
94562: PUSH
94563: LD_INT 1
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 2
94572: NEG
94573: PUSH
94574: LD_INT 0
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 2
94583: NEG
94584: PUSH
94585: LD_INT 1
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: LIST
94597: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94598: LD_ADDR_VAR 0 64
94602: PUSH
94603: LD_INT 1
94605: NEG
94606: PUSH
94607: LD_INT 2
94609: NEG
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 2
94617: NEG
94618: PUSH
94619: LD_INT 1
94621: NEG
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 2
94629: NEG
94630: PUSH
94631: LD_INT 2
94633: NEG
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: LIST
94643: ST_TO_ADDR
// end ; 2 :
94644: GO 97910
94646: LD_INT 2
94648: DOUBLE
94649: EQUAL
94650: IFTRUE 94654
94652: GO 97909
94654: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94655: LD_ADDR_VAR 0 29
94659: PUSH
94660: LD_INT 4
94662: PUSH
94663: LD_INT 0
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: PUSH
94670: LD_INT 4
94672: PUSH
94673: LD_INT 1
94675: NEG
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 5
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 5
94693: PUSH
94694: LD_INT 1
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 4
94703: PUSH
94704: LD_INT 1
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 3
94713: PUSH
94714: LD_INT 0
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 3
94723: PUSH
94724: LD_INT 1
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 3
94734: PUSH
94735: LD_INT 2
94737: NEG
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: PUSH
94743: LD_INT 5
94745: PUSH
94746: LD_INT 2
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 3
94755: PUSH
94756: LD_INT 3
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 3
94765: PUSH
94766: LD_INT 2
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 4
94775: PUSH
94776: LD_INT 3
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: LD_INT 4
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: LD_INT 4
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 2
94805: PUSH
94806: LD_INT 3
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 2
94815: PUSH
94816: LD_INT 2
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 4
94825: PUSH
94826: LD_INT 2
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 2
94835: PUSH
94836: LD_INT 4
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 0
94845: PUSH
94846: LD_INT 4
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 0
94855: PUSH
94856: LD_INT 3
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: PUSH
94863: LD_INT 1
94865: PUSH
94866: LD_INT 4
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 1
94875: PUSH
94876: LD_INT 5
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 0
94885: PUSH
94886: LD_INT 5
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 1
94895: NEG
94896: PUSH
94897: LD_INT 4
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 1
94906: NEG
94907: PUSH
94908: LD_INT 3
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: LD_INT 5
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 2
94927: NEG
94928: PUSH
94929: LD_INT 3
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 3
94938: NEG
94939: PUSH
94940: LD_INT 0
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 3
94949: NEG
94950: PUSH
94951: LD_INT 1
94953: NEG
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: PUSH
94959: LD_INT 2
94961: NEG
94962: PUSH
94963: LD_INT 0
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 2
94972: NEG
94973: PUSH
94974: LD_INT 1
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: PUSH
94981: LD_INT 3
94983: NEG
94984: PUSH
94985: LD_INT 1
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 4
94994: NEG
94995: PUSH
94996: LD_INT 0
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: PUSH
95003: LD_INT 4
95005: NEG
95006: PUSH
95007: LD_INT 1
95009: NEG
95010: PUSH
95011: EMPTY
95012: LIST
95013: LIST
95014: PUSH
95015: LD_INT 4
95017: NEG
95018: PUSH
95019: LD_INT 2
95021: NEG
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 2
95029: NEG
95030: PUSH
95031: LD_INT 2
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 4
95040: NEG
95041: PUSH
95042: LD_INT 4
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 4
95052: NEG
95053: PUSH
95054: LD_INT 5
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 3
95064: NEG
95065: PUSH
95066: LD_INT 4
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 3
95076: NEG
95077: PUSH
95078: LD_INT 3
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 4
95088: NEG
95089: PUSH
95090: LD_INT 3
95092: NEG
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: LD_INT 5
95100: NEG
95101: PUSH
95102: LD_INT 4
95104: NEG
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: PUSH
95110: LD_INT 5
95112: NEG
95113: PUSH
95114: LD_INT 5
95116: NEG
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 3
95124: NEG
95125: PUSH
95126: LD_INT 5
95128: NEG
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 5
95136: NEG
95137: PUSH
95138: LD_INT 3
95140: NEG
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95193: LD_ADDR_VAR 0 30
95197: PUSH
95198: LD_INT 4
95200: PUSH
95201: LD_INT 4
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 4
95210: PUSH
95211: LD_INT 3
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PUSH
95218: LD_INT 5
95220: PUSH
95221: LD_INT 4
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 5
95230: PUSH
95231: LD_INT 5
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 4
95240: PUSH
95241: LD_INT 5
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 3
95250: PUSH
95251: LD_INT 4
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: LD_INT 3
95260: PUSH
95261: LD_INT 3
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 5
95270: PUSH
95271: LD_INT 3
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 3
95280: PUSH
95281: LD_INT 5
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 0
95290: PUSH
95291: LD_INT 3
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: PUSH
95298: LD_INT 0
95300: PUSH
95301: LD_INT 2
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 1
95310: PUSH
95311: LD_INT 3
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: LD_INT 1
95320: PUSH
95321: LD_INT 4
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: LD_INT 4
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 1
95340: NEG
95341: PUSH
95342: LD_INT 3
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 1
95351: NEG
95352: PUSH
95353: LD_INT 2
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 2
95362: PUSH
95363: LD_INT 4
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 2
95372: NEG
95373: PUSH
95374: LD_INT 2
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 4
95383: NEG
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 4
95394: NEG
95395: PUSH
95396: LD_INT 1
95398: NEG
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 3
95406: NEG
95407: PUSH
95408: LD_INT 0
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 3
95417: NEG
95418: PUSH
95419: LD_INT 1
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 4
95428: NEG
95429: PUSH
95430: LD_INT 1
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 5
95439: NEG
95440: PUSH
95441: LD_INT 0
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: LD_INT 5
95450: NEG
95451: PUSH
95452: LD_INT 1
95454: NEG
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: LD_INT 5
95462: NEG
95463: PUSH
95464: LD_INT 2
95466: NEG
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 3
95474: NEG
95475: PUSH
95476: LD_INT 2
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: LD_INT 3
95485: NEG
95486: PUSH
95487: LD_INT 3
95489: NEG
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 3
95497: NEG
95498: PUSH
95499: LD_INT 4
95501: NEG
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 2
95509: NEG
95510: PUSH
95511: LD_INT 3
95513: NEG
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 2
95521: NEG
95522: PUSH
95523: LD_INT 2
95525: NEG
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 3
95533: NEG
95534: PUSH
95535: LD_INT 2
95537: NEG
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 4
95545: NEG
95546: PUSH
95547: LD_INT 3
95549: NEG
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 4
95557: NEG
95558: PUSH
95559: LD_INT 4
95561: NEG
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 2
95569: NEG
95570: PUSH
95571: LD_INT 4
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 4
95581: NEG
95582: PUSH
95583: LD_INT 2
95585: NEG
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: PUSH
95591: LD_INT 0
95593: PUSH
95594: LD_INT 4
95596: NEG
95597: PUSH
95598: EMPTY
95599: LIST
95600: LIST
95601: PUSH
95602: LD_INT 0
95604: PUSH
95605: LD_INT 5
95607: NEG
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 1
95615: PUSH
95616: LD_INT 4
95618: NEG
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 1
95626: PUSH
95627: LD_INT 3
95629: NEG
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 0
95637: PUSH
95638: LD_INT 3
95640: NEG
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 1
95648: NEG
95649: PUSH
95650: LD_INT 4
95652: NEG
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 1
95660: NEG
95661: PUSH
95662: LD_INT 5
95664: NEG
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: PUSH
95670: LD_INT 2
95672: PUSH
95673: LD_INT 3
95675: NEG
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PUSH
95681: LD_INT 2
95683: NEG
95684: PUSH
95685: LD_INT 5
95687: NEG
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95740: LD_ADDR_VAR 0 31
95744: PUSH
95745: LD_INT 0
95747: PUSH
95748: LD_INT 4
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 0
95757: PUSH
95758: LD_INT 3
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 1
95767: PUSH
95768: LD_INT 4
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 1
95777: PUSH
95778: LD_INT 5
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 0
95787: PUSH
95788: LD_INT 5
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 1
95797: NEG
95798: PUSH
95799: LD_INT 4
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 1
95808: NEG
95809: PUSH
95810: LD_INT 3
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 2
95819: PUSH
95820: LD_INT 5
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 2
95829: NEG
95830: PUSH
95831: LD_INT 3
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 3
95840: NEG
95841: PUSH
95842: LD_INT 0
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 3
95851: NEG
95852: PUSH
95853: LD_INT 1
95855: NEG
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: PUSH
95861: LD_INT 2
95863: NEG
95864: PUSH
95865: LD_INT 0
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 2
95874: NEG
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 3
95885: NEG
95886: PUSH
95887: LD_INT 1
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 4
95896: NEG
95897: PUSH
95898: LD_INT 0
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 4
95907: NEG
95908: PUSH
95909: LD_INT 1
95911: NEG
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 4
95919: NEG
95920: PUSH
95921: LD_INT 2
95923: NEG
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 2
95931: NEG
95932: PUSH
95933: LD_INT 2
95935: PUSH
95936: EMPTY
95937: LIST
95938: LIST
95939: PUSH
95940: LD_INT 4
95942: NEG
95943: PUSH
95944: LD_INT 4
95946: NEG
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: PUSH
95952: LD_INT 4
95954: NEG
95955: PUSH
95956: LD_INT 5
95958: NEG
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 3
95966: NEG
95967: PUSH
95968: LD_INT 4
95970: NEG
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 3
95978: NEG
95979: PUSH
95980: LD_INT 3
95982: NEG
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 4
95990: NEG
95991: PUSH
95992: LD_INT 3
95994: NEG
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 5
96002: NEG
96003: PUSH
96004: LD_INT 4
96006: NEG
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 5
96014: NEG
96015: PUSH
96016: LD_INT 5
96018: NEG
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: LD_INT 3
96026: NEG
96027: PUSH
96028: LD_INT 5
96030: NEG
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 5
96038: NEG
96039: PUSH
96040: LD_INT 3
96042: NEG
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 0
96050: PUSH
96051: LD_INT 3
96053: NEG
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 0
96061: PUSH
96062: LD_INT 4
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 1
96072: PUSH
96073: LD_INT 3
96075: NEG
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 1
96083: PUSH
96084: LD_INT 2
96086: NEG
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 0
96094: PUSH
96095: LD_INT 2
96097: NEG
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 1
96105: NEG
96106: PUSH
96107: LD_INT 3
96109: NEG
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 1
96117: NEG
96118: PUSH
96119: LD_INT 4
96121: NEG
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: PUSH
96127: LD_INT 2
96129: PUSH
96130: LD_INT 2
96132: NEG
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PUSH
96138: LD_INT 2
96140: NEG
96141: PUSH
96142: LD_INT 4
96144: NEG
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 4
96152: PUSH
96153: LD_INT 0
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 4
96162: PUSH
96163: LD_INT 1
96165: NEG
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 5
96173: PUSH
96174: LD_INT 0
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 5
96183: PUSH
96184: LD_INT 1
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 4
96193: PUSH
96194: LD_INT 1
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 3
96203: PUSH
96204: LD_INT 0
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 3
96213: PUSH
96214: LD_INT 1
96216: NEG
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: LD_INT 3
96224: PUSH
96225: LD_INT 2
96227: NEG
96228: PUSH
96229: EMPTY
96230: LIST
96231: LIST
96232: PUSH
96233: LD_INT 5
96235: PUSH
96236: LD_INT 2
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96290: LD_ADDR_VAR 0 32
96294: PUSH
96295: LD_INT 4
96297: NEG
96298: PUSH
96299: LD_INT 0
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 4
96308: NEG
96309: PUSH
96310: LD_INT 1
96312: NEG
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 3
96320: NEG
96321: PUSH
96322: LD_INT 0
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: PUSH
96329: LD_INT 3
96331: NEG
96332: PUSH
96333: LD_INT 1
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: PUSH
96340: LD_INT 4
96342: NEG
96343: PUSH
96344: LD_INT 1
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 5
96353: NEG
96354: PUSH
96355: LD_INT 0
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: PUSH
96362: LD_INT 5
96364: NEG
96365: PUSH
96366: LD_INT 1
96368: NEG
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 5
96376: NEG
96377: PUSH
96378: LD_INT 2
96380: NEG
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 3
96388: NEG
96389: PUSH
96390: LD_INT 2
96392: PUSH
96393: EMPTY
96394: LIST
96395: LIST
96396: PUSH
96397: LD_INT 3
96399: NEG
96400: PUSH
96401: LD_INT 3
96403: NEG
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 3
96411: NEG
96412: PUSH
96413: LD_INT 4
96415: NEG
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: LD_INT 2
96423: NEG
96424: PUSH
96425: LD_INT 3
96427: NEG
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 2
96435: NEG
96436: PUSH
96437: LD_INT 2
96439: NEG
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 3
96447: NEG
96448: PUSH
96449: LD_INT 2
96451: NEG
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 4
96459: NEG
96460: PUSH
96461: LD_INT 3
96463: NEG
96464: PUSH
96465: EMPTY
96466: LIST
96467: LIST
96468: PUSH
96469: LD_INT 4
96471: NEG
96472: PUSH
96473: LD_INT 4
96475: NEG
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 2
96483: NEG
96484: PUSH
96485: LD_INT 4
96487: NEG
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 4
96495: NEG
96496: PUSH
96497: LD_INT 2
96499: NEG
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 0
96507: PUSH
96508: LD_INT 4
96510: NEG
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 0
96518: PUSH
96519: LD_INT 5
96521: NEG
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 1
96529: PUSH
96530: LD_INT 4
96532: NEG
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: PUSH
96538: LD_INT 1
96540: PUSH
96541: LD_INT 3
96543: NEG
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 0
96551: PUSH
96552: LD_INT 3
96554: NEG
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 1
96562: NEG
96563: PUSH
96564: LD_INT 4
96566: NEG
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 1
96574: NEG
96575: PUSH
96576: LD_INT 5
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 2
96586: PUSH
96587: LD_INT 3
96589: NEG
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 2
96597: NEG
96598: PUSH
96599: LD_INT 5
96601: NEG
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 3
96609: PUSH
96610: LD_INT 0
96612: PUSH
96613: EMPTY
96614: LIST
96615: LIST
96616: PUSH
96617: LD_INT 3
96619: PUSH
96620: LD_INT 1
96622: NEG
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PUSH
96628: LD_INT 4
96630: PUSH
96631: LD_INT 0
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 4
96640: PUSH
96641: LD_INT 1
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 3
96650: PUSH
96651: LD_INT 1
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 2
96660: PUSH
96661: LD_INT 0
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 2
96670: PUSH
96671: LD_INT 1
96673: NEG
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: LD_INT 2
96681: PUSH
96682: LD_INT 2
96684: NEG
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 4
96692: PUSH
96693: LD_INT 2
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 4
96702: PUSH
96703: LD_INT 4
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PUSH
96710: LD_INT 4
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 5
96722: PUSH
96723: LD_INT 4
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 5
96732: PUSH
96733: LD_INT 5
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 4
96742: PUSH
96743: LD_INT 5
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 3
96752: PUSH
96753: LD_INT 4
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 3
96762: PUSH
96763: LD_INT 3
96765: PUSH
96766: EMPTY
96767: LIST
96768: LIST
96769: PUSH
96770: LD_INT 5
96772: PUSH
96773: LD_INT 3
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: PUSH
96780: LD_INT 3
96782: PUSH
96783: LD_INT 5
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96837: LD_ADDR_VAR 0 33
96841: PUSH
96842: LD_INT 4
96844: NEG
96845: PUSH
96846: LD_INT 4
96848: NEG
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 4
96856: NEG
96857: PUSH
96858: LD_INT 5
96860: NEG
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 3
96868: NEG
96869: PUSH
96870: LD_INT 4
96872: NEG
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 3
96880: NEG
96881: PUSH
96882: LD_INT 3
96884: NEG
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 4
96892: NEG
96893: PUSH
96894: LD_INT 3
96896: NEG
96897: PUSH
96898: EMPTY
96899: LIST
96900: LIST
96901: PUSH
96902: LD_INT 5
96904: NEG
96905: PUSH
96906: LD_INT 4
96908: NEG
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: PUSH
96914: LD_INT 5
96916: NEG
96917: PUSH
96918: LD_INT 5
96920: NEG
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 3
96928: NEG
96929: PUSH
96930: LD_INT 5
96932: NEG
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 5
96940: NEG
96941: PUSH
96942: LD_INT 3
96944: NEG
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PUSH
96950: LD_INT 0
96952: PUSH
96953: LD_INT 3
96955: NEG
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: LD_INT 0
96963: PUSH
96964: LD_INT 4
96966: NEG
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PUSH
96972: LD_INT 1
96974: PUSH
96975: LD_INT 3
96977: NEG
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 1
96985: PUSH
96986: LD_INT 2
96988: NEG
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 0
96996: PUSH
96997: LD_INT 2
96999: NEG
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: LD_INT 1
97007: NEG
97008: PUSH
97009: LD_INT 3
97011: NEG
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 1
97019: NEG
97020: PUSH
97021: LD_INT 4
97023: NEG
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: PUSH
97029: LD_INT 2
97031: PUSH
97032: LD_INT 2
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 2
97042: NEG
97043: PUSH
97044: LD_INT 4
97046: NEG
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 4
97054: PUSH
97055: LD_INT 0
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 4
97064: PUSH
97065: LD_INT 1
97067: NEG
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 5
97075: PUSH
97076: LD_INT 0
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 5
97085: PUSH
97086: LD_INT 1
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PUSH
97093: LD_INT 4
97095: PUSH
97096: LD_INT 1
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PUSH
97103: LD_INT 3
97105: PUSH
97106: LD_INT 0
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_INT 3
97115: PUSH
97116: LD_INT 1
97118: NEG
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 3
97126: PUSH
97127: LD_INT 2
97129: NEG
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 5
97137: PUSH
97138: LD_INT 2
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 3
97147: PUSH
97148: LD_INT 3
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 3
97157: PUSH
97158: LD_INT 2
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 4
97167: PUSH
97168: LD_INT 3
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 4
97177: PUSH
97178: LD_INT 4
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 3
97187: PUSH
97188: LD_INT 4
97190: PUSH
97191: EMPTY
97192: LIST
97193: LIST
97194: PUSH
97195: LD_INT 2
97197: PUSH
97198: LD_INT 3
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: LD_INT 2
97207: PUSH
97208: LD_INT 2
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: LD_INT 4
97217: PUSH
97218: LD_INT 2
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PUSH
97225: LD_INT 2
97227: PUSH
97228: LD_INT 4
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 0
97237: PUSH
97238: LD_INT 4
97240: PUSH
97241: EMPTY
97242: LIST
97243: LIST
97244: PUSH
97245: LD_INT 0
97247: PUSH
97248: LD_INT 3
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: LD_INT 1
97257: PUSH
97258: LD_INT 4
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 1
97267: PUSH
97268: LD_INT 5
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 0
97277: PUSH
97278: LD_INT 5
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 1
97287: NEG
97288: PUSH
97289: LD_INT 4
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 1
97298: NEG
97299: PUSH
97300: LD_INT 3
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 2
97309: PUSH
97310: LD_INT 5
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 2
97319: NEG
97320: PUSH
97321: LD_INT 3
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97375: LD_ADDR_VAR 0 34
97379: PUSH
97380: LD_INT 0
97382: PUSH
97383: LD_INT 4
97385: NEG
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: PUSH
97391: LD_INT 0
97393: PUSH
97394: LD_INT 5
97396: NEG
97397: PUSH
97398: EMPTY
97399: LIST
97400: LIST
97401: PUSH
97402: LD_INT 1
97404: PUSH
97405: LD_INT 4
97407: NEG
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: LD_INT 1
97415: PUSH
97416: LD_INT 3
97418: NEG
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 0
97426: PUSH
97427: LD_INT 3
97429: NEG
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 1
97437: NEG
97438: PUSH
97439: LD_INT 4
97441: NEG
97442: PUSH
97443: EMPTY
97444: LIST
97445: LIST
97446: PUSH
97447: LD_INT 1
97449: NEG
97450: PUSH
97451: LD_INT 5
97453: NEG
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 2
97461: PUSH
97462: LD_INT 3
97464: NEG
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 2
97472: NEG
97473: PUSH
97474: LD_INT 5
97476: NEG
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: PUSH
97482: LD_INT 3
97484: PUSH
97485: LD_INT 0
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: LD_INT 3
97494: PUSH
97495: LD_INT 1
97497: NEG
97498: PUSH
97499: EMPTY
97500: LIST
97501: LIST
97502: PUSH
97503: LD_INT 4
97505: PUSH
97506: LD_INT 0
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PUSH
97513: LD_INT 4
97515: PUSH
97516: LD_INT 1
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: LD_INT 3
97525: PUSH
97526: LD_INT 1
97528: PUSH
97529: EMPTY
97530: LIST
97531: LIST
97532: PUSH
97533: LD_INT 2
97535: PUSH
97536: LD_INT 0
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 2
97545: PUSH
97546: LD_INT 1
97548: NEG
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 2
97556: PUSH
97557: LD_INT 2
97559: NEG
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 4
97567: PUSH
97568: LD_INT 2
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 4
97577: PUSH
97578: LD_INT 4
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: PUSH
97585: LD_INT 4
97587: PUSH
97588: LD_INT 3
97590: PUSH
97591: EMPTY
97592: LIST
97593: LIST
97594: PUSH
97595: LD_INT 5
97597: PUSH
97598: LD_INT 4
97600: PUSH
97601: EMPTY
97602: LIST
97603: LIST
97604: PUSH
97605: LD_INT 5
97607: PUSH
97608: LD_INT 5
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PUSH
97615: LD_INT 4
97617: PUSH
97618: LD_INT 5
97620: PUSH
97621: EMPTY
97622: LIST
97623: LIST
97624: PUSH
97625: LD_INT 3
97627: PUSH
97628: LD_INT 4
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: PUSH
97635: LD_INT 3
97637: PUSH
97638: LD_INT 3
97640: PUSH
97641: EMPTY
97642: LIST
97643: LIST
97644: PUSH
97645: LD_INT 5
97647: PUSH
97648: LD_INT 3
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: PUSH
97655: LD_INT 3
97657: PUSH
97658: LD_INT 5
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PUSH
97665: LD_INT 0
97667: PUSH
97668: LD_INT 3
97670: PUSH
97671: EMPTY
97672: LIST
97673: LIST
97674: PUSH
97675: LD_INT 0
97677: PUSH
97678: LD_INT 2
97680: PUSH
97681: EMPTY
97682: LIST
97683: LIST
97684: PUSH
97685: LD_INT 1
97687: PUSH
97688: LD_INT 3
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 1
97697: PUSH
97698: LD_INT 4
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: PUSH
97705: LD_INT 0
97707: PUSH
97708: LD_INT 4
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: PUSH
97715: LD_INT 1
97717: NEG
97718: PUSH
97719: LD_INT 3
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 1
97728: NEG
97729: PUSH
97730: LD_INT 2
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: PUSH
97737: LD_INT 2
97739: PUSH
97740: LD_INT 4
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: PUSH
97747: LD_INT 2
97749: NEG
97750: PUSH
97751: LD_INT 2
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 4
97760: NEG
97761: PUSH
97762: LD_INT 0
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 4
97771: NEG
97772: PUSH
97773: LD_INT 1
97775: NEG
97776: PUSH
97777: EMPTY
97778: LIST
97779: LIST
97780: PUSH
97781: LD_INT 3
97783: NEG
97784: PUSH
97785: LD_INT 0
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: PUSH
97792: LD_INT 3
97794: NEG
97795: PUSH
97796: LD_INT 1
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: PUSH
97803: LD_INT 4
97805: NEG
97806: PUSH
97807: LD_INT 1
97809: PUSH
97810: EMPTY
97811: LIST
97812: LIST
97813: PUSH
97814: LD_INT 5
97816: NEG
97817: PUSH
97818: LD_INT 0
97820: PUSH
97821: EMPTY
97822: LIST
97823: LIST
97824: PUSH
97825: LD_INT 5
97827: NEG
97828: PUSH
97829: LD_INT 1
97831: NEG
97832: PUSH
97833: EMPTY
97834: LIST
97835: LIST
97836: PUSH
97837: LD_INT 5
97839: NEG
97840: PUSH
97841: LD_INT 2
97843: NEG
97844: PUSH
97845: EMPTY
97846: LIST
97847: LIST
97848: PUSH
97849: LD_INT 3
97851: NEG
97852: PUSH
97853: LD_INT 2
97855: PUSH
97856: EMPTY
97857: LIST
97858: LIST
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: ST_TO_ADDR
// end ; end ;
97907: GO 97910
97909: POP
// case btype of b_depot , b_warehouse :
97910: LD_VAR 0 1
97914: PUSH
97915: LD_INT 0
97917: DOUBLE
97918: EQUAL
97919: IFTRUE 97929
97921: LD_INT 1
97923: DOUBLE
97924: EQUAL
97925: IFTRUE 97929
97927: GO 98130
97929: POP
// case nation of nation_american :
97930: LD_VAR 0 5
97934: PUSH
97935: LD_INT 1
97937: DOUBLE
97938: EQUAL
97939: IFTRUE 97943
97941: GO 97999
97943: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97944: LD_ADDR_VAR 0 9
97948: PUSH
97949: LD_VAR 0 11
97953: PUSH
97954: LD_VAR 0 12
97958: PUSH
97959: LD_VAR 0 13
97963: PUSH
97964: LD_VAR 0 14
97968: PUSH
97969: LD_VAR 0 15
97973: PUSH
97974: LD_VAR 0 16
97978: PUSH
97979: EMPTY
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: PUSH
97987: LD_VAR 0 4
97991: PUSH
97992: LD_INT 1
97994: PLUS
97995: ARRAY
97996: ST_TO_ADDR
97997: GO 98128
97999: LD_INT 2
98001: DOUBLE
98002: EQUAL
98003: IFTRUE 98007
98005: GO 98063
98007: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98008: LD_ADDR_VAR 0 9
98012: PUSH
98013: LD_VAR 0 17
98017: PUSH
98018: LD_VAR 0 18
98022: PUSH
98023: LD_VAR 0 19
98027: PUSH
98028: LD_VAR 0 20
98032: PUSH
98033: LD_VAR 0 21
98037: PUSH
98038: LD_VAR 0 22
98042: PUSH
98043: EMPTY
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: PUSH
98051: LD_VAR 0 4
98055: PUSH
98056: LD_INT 1
98058: PLUS
98059: ARRAY
98060: ST_TO_ADDR
98061: GO 98128
98063: LD_INT 3
98065: DOUBLE
98066: EQUAL
98067: IFTRUE 98071
98069: GO 98127
98071: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98072: LD_ADDR_VAR 0 9
98076: PUSH
98077: LD_VAR 0 23
98081: PUSH
98082: LD_VAR 0 24
98086: PUSH
98087: LD_VAR 0 25
98091: PUSH
98092: LD_VAR 0 26
98096: PUSH
98097: LD_VAR 0 27
98101: PUSH
98102: LD_VAR 0 28
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: PUSH
98115: LD_VAR 0 4
98119: PUSH
98120: LD_INT 1
98122: PLUS
98123: ARRAY
98124: ST_TO_ADDR
98125: GO 98128
98127: POP
98128: GO 98683
98130: LD_INT 2
98132: DOUBLE
98133: EQUAL
98134: IFTRUE 98144
98136: LD_INT 3
98138: DOUBLE
98139: EQUAL
98140: IFTRUE 98144
98142: GO 98200
98144: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98145: LD_ADDR_VAR 0 9
98149: PUSH
98150: LD_VAR 0 29
98154: PUSH
98155: LD_VAR 0 30
98159: PUSH
98160: LD_VAR 0 31
98164: PUSH
98165: LD_VAR 0 32
98169: PUSH
98170: LD_VAR 0 33
98174: PUSH
98175: LD_VAR 0 34
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: PUSH
98188: LD_VAR 0 4
98192: PUSH
98193: LD_INT 1
98195: PLUS
98196: ARRAY
98197: ST_TO_ADDR
98198: GO 98683
98200: LD_INT 16
98202: DOUBLE
98203: EQUAL
98204: IFTRUE 98262
98206: LD_INT 17
98208: DOUBLE
98209: EQUAL
98210: IFTRUE 98262
98212: LD_INT 18
98214: DOUBLE
98215: EQUAL
98216: IFTRUE 98262
98218: LD_INT 19
98220: DOUBLE
98221: EQUAL
98222: IFTRUE 98262
98224: LD_INT 22
98226: DOUBLE
98227: EQUAL
98228: IFTRUE 98262
98230: LD_INT 20
98232: DOUBLE
98233: EQUAL
98234: IFTRUE 98262
98236: LD_INT 21
98238: DOUBLE
98239: EQUAL
98240: IFTRUE 98262
98242: LD_INT 23
98244: DOUBLE
98245: EQUAL
98246: IFTRUE 98262
98248: LD_INT 24
98250: DOUBLE
98251: EQUAL
98252: IFTRUE 98262
98254: LD_INT 25
98256: DOUBLE
98257: EQUAL
98258: IFTRUE 98262
98260: GO 98318
98262: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98263: LD_ADDR_VAR 0 9
98267: PUSH
98268: LD_VAR 0 35
98272: PUSH
98273: LD_VAR 0 36
98277: PUSH
98278: LD_VAR 0 37
98282: PUSH
98283: LD_VAR 0 38
98287: PUSH
98288: LD_VAR 0 39
98292: PUSH
98293: LD_VAR 0 40
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: PUSH
98306: LD_VAR 0 4
98310: PUSH
98311: LD_INT 1
98313: PLUS
98314: ARRAY
98315: ST_TO_ADDR
98316: GO 98683
98318: LD_INT 6
98320: DOUBLE
98321: EQUAL
98322: IFTRUE 98374
98324: LD_INT 7
98326: DOUBLE
98327: EQUAL
98328: IFTRUE 98374
98330: LD_INT 8
98332: DOUBLE
98333: EQUAL
98334: IFTRUE 98374
98336: LD_INT 13
98338: DOUBLE
98339: EQUAL
98340: IFTRUE 98374
98342: LD_INT 12
98344: DOUBLE
98345: EQUAL
98346: IFTRUE 98374
98348: LD_INT 15
98350: DOUBLE
98351: EQUAL
98352: IFTRUE 98374
98354: LD_INT 11
98356: DOUBLE
98357: EQUAL
98358: IFTRUE 98374
98360: LD_INT 14
98362: DOUBLE
98363: EQUAL
98364: IFTRUE 98374
98366: LD_INT 10
98368: DOUBLE
98369: EQUAL
98370: IFTRUE 98374
98372: GO 98430
98374: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98375: LD_ADDR_VAR 0 9
98379: PUSH
98380: LD_VAR 0 41
98384: PUSH
98385: LD_VAR 0 42
98389: PUSH
98390: LD_VAR 0 43
98394: PUSH
98395: LD_VAR 0 44
98399: PUSH
98400: LD_VAR 0 45
98404: PUSH
98405: LD_VAR 0 46
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: PUSH
98418: LD_VAR 0 4
98422: PUSH
98423: LD_INT 1
98425: PLUS
98426: ARRAY
98427: ST_TO_ADDR
98428: GO 98683
98430: LD_INT 36
98432: DOUBLE
98433: EQUAL
98434: IFTRUE 98438
98436: GO 98494
98438: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98439: LD_ADDR_VAR 0 9
98443: PUSH
98444: LD_VAR 0 47
98448: PUSH
98449: LD_VAR 0 48
98453: PUSH
98454: LD_VAR 0 49
98458: PUSH
98459: LD_VAR 0 50
98463: PUSH
98464: LD_VAR 0 51
98468: PUSH
98469: LD_VAR 0 52
98473: PUSH
98474: EMPTY
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: PUSH
98482: LD_VAR 0 4
98486: PUSH
98487: LD_INT 1
98489: PLUS
98490: ARRAY
98491: ST_TO_ADDR
98492: GO 98683
98494: LD_INT 4
98496: DOUBLE
98497: EQUAL
98498: IFTRUE 98520
98500: LD_INT 5
98502: DOUBLE
98503: EQUAL
98504: IFTRUE 98520
98506: LD_INT 34
98508: DOUBLE
98509: EQUAL
98510: IFTRUE 98520
98512: LD_INT 37
98514: DOUBLE
98515: EQUAL
98516: IFTRUE 98520
98518: GO 98576
98520: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98521: LD_ADDR_VAR 0 9
98525: PUSH
98526: LD_VAR 0 53
98530: PUSH
98531: LD_VAR 0 54
98535: PUSH
98536: LD_VAR 0 55
98540: PUSH
98541: LD_VAR 0 56
98545: PUSH
98546: LD_VAR 0 57
98550: PUSH
98551: LD_VAR 0 58
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: PUSH
98564: LD_VAR 0 4
98568: PUSH
98569: LD_INT 1
98571: PLUS
98572: ARRAY
98573: ST_TO_ADDR
98574: GO 98683
98576: LD_INT 31
98578: DOUBLE
98579: EQUAL
98580: IFTRUE 98626
98582: LD_INT 32
98584: DOUBLE
98585: EQUAL
98586: IFTRUE 98626
98588: LD_INT 33
98590: DOUBLE
98591: EQUAL
98592: IFTRUE 98626
98594: LD_INT 27
98596: DOUBLE
98597: EQUAL
98598: IFTRUE 98626
98600: LD_INT 26
98602: DOUBLE
98603: EQUAL
98604: IFTRUE 98626
98606: LD_INT 28
98608: DOUBLE
98609: EQUAL
98610: IFTRUE 98626
98612: LD_INT 29
98614: DOUBLE
98615: EQUAL
98616: IFTRUE 98626
98618: LD_INT 30
98620: DOUBLE
98621: EQUAL
98622: IFTRUE 98626
98624: GO 98682
98626: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98627: LD_ADDR_VAR 0 9
98631: PUSH
98632: LD_VAR 0 59
98636: PUSH
98637: LD_VAR 0 60
98641: PUSH
98642: LD_VAR 0 61
98646: PUSH
98647: LD_VAR 0 62
98651: PUSH
98652: LD_VAR 0 63
98656: PUSH
98657: LD_VAR 0 64
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: LIST
98666: LIST
98667: LIST
98668: LIST
98669: PUSH
98670: LD_VAR 0 4
98674: PUSH
98675: LD_INT 1
98677: PLUS
98678: ARRAY
98679: ST_TO_ADDR
98680: GO 98683
98682: POP
// temp_list2 = [ ] ;
98683: LD_ADDR_VAR 0 10
98687: PUSH
98688: EMPTY
98689: ST_TO_ADDR
// for i in temp_list do
98690: LD_ADDR_VAR 0 8
98694: PUSH
98695: LD_VAR 0 9
98699: PUSH
98700: FOR_IN
98701: IFFALSE 98753
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98703: LD_ADDR_VAR 0 10
98707: PUSH
98708: LD_VAR 0 10
98712: PUSH
98713: LD_VAR 0 8
98717: PUSH
98718: LD_INT 1
98720: ARRAY
98721: PUSH
98722: LD_VAR 0 2
98726: PLUS
98727: PUSH
98728: LD_VAR 0 8
98732: PUSH
98733: LD_INT 2
98735: ARRAY
98736: PUSH
98737: LD_VAR 0 3
98741: PLUS
98742: PUSH
98743: EMPTY
98744: LIST
98745: LIST
98746: PUSH
98747: EMPTY
98748: LIST
98749: ADD
98750: ST_TO_ADDR
98751: GO 98700
98753: POP
98754: POP
// result = temp_list2 ;
98755: LD_ADDR_VAR 0 7
98759: PUSH
98760: LD_VAR 0 10
98764: ST_TO_ADDR
// end ;
98765: LD_VAR 0 7
98769: RET
// export function EnemyInRange ( unit , dist ) ; begin
98770: LD_INT 0
98772: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98773: LD_ADDR_VAR 0 3
98777: PUSH
98778: LD_VAR 0 1
98782: PPUSH
98783: CALL_OW 255
98787: PPUSH
98788: LD_VAR 0 1
98792: PPUSH
98793: CALL_OW 250
98797: PPUSH
98798: LD_VAR 0 1
98802: PPUSH
98803: CALL_OW 251
98807: PPUSH
98808: LD_VAR 0 2
98812: PPUSH
98813: CALL 72874 0 4
98817: PUSH
98818: LD_INT 4
98820: ARRAY
98821: ST_TO_ADDR
// end ;
98822: LD_VAR 0 3
98826: RET
// export function PlayerSeeMe ( unit ) ; begin
98827: LD_INT 0
98829: PPUSH
// result := See ( your_side , unit ) ;
98830: LD_ADDR_VAR 0 2
98834: PUSH
98835: LD_OWVAR 2
98839: PPUSH
98840: LD_VAR 0 1
98844: PPUSH
98845: CALL_OW 292
98849: ST_TO_ADDR
// end ;
98850: LD_VAR 0 2
98854: RET
// export function ReverseDir ( unit ) ; begin
98855: LD_INT 0
98857: PPUSH
// if not unit then
98858: LD_VAR 0 1
98862: NOT
98863: IFFALSE 98867
// exit ;
98865: GO 98890
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98867: LD_ADDR_VAR 0 2
98871: PUSH
98872: LD_VAR 0 1
98876: PPUSH
98877: CALL_OW 254
98881: PUSH
98882: LD_INT 3
98884: PLUS
98885: PUSH
98886: LD_INT 6
98888: MOD
98889: ST_TO_ADDR
// end ;
98890: LD_VAR 0 2
98894: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98895: LD_INT 0
98897: PPUSH
98898: PPUSH
98899: PPUSH
98900: PPUSH
98901: PPUSH
// if not hexes then
98902: LD_VAR 0 2
98906: NOT
98907: IFFALSE 98911
// exit ;
98909: GO 99059
// dist := 9999 ;
98911: LD_ADDR_VAR 0 5
98915: PUSH
98916: LD_INT 9999
98918: ST_TO_ADDR
// for i = 1 to hexes do
98919: LD_ADDR_VAR 0 4
98923: PUSH
98924: DOUBLE
98925: LD_INT 1
98927: DEC
98928: ST_TO_ADDR
98929: LD_VAR 0 2
98933: PUSH
98934: FOR_TO
98935: IFFALSE 99047
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98937: LD_VAR 0 1
98941: PPUSH
98942: LD_VAR 0 2
98946: PUSH
98947: LD_VAR 0 4
98951: ARRAY
98952: PUSH
98953: LD_INT 1
98955: ARRAY
98956: PPUSH
98957: LD_VAR 0 2
98961: PUSH
98962: LD_VAR 0 4
98966: ARRAY
98967: PUSH
98968: LD_INT 2
98970: ARRAY
98971: PPUSH
98972: CALL_OW 297
98976: PUSH
98977: LD_VAR 0 5
98981: LESS
98982: IFFALSE 99045
// begin hex := hexes [ i ] ;
98984: LD_ADDR_VAR 0 7
98988: PUSH
98989: LD_VAR 0 2
98993: PUSH
98994: LD_VAR 0 4
98998: ARRAY
98999: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99000: LD_ADDR_VAR 0 5
99004: PUSH
99005: LD_VAR 0 1
99009: PPUSH
99010: LD_VAR 0 2
99014: PUSH
99015: LD_VAR 0 4
99019: ARRAY
99020: PUSH
99021: LD_INT 1
99023: ARRAY
99024: PPUSH
99025: LD_VAR 0 2
99029: PUSH
99030: LD_VAR 0 4
99034: ARRAY
99035: PUSH
99036: LD_INT 2
99038: ARRAY
99039: PPUSH
99040: CALL_OW 297
99044: ST_TO_ADDR
// end ; end ;
99045: GO 98934
99047: POP
99048: POP
// result := hex ;
99049: LD_ADDR_VAR 0 3
99053: PUSH
99054: LD_VAR 0 7
99058: ST_TO_ADDR
// end ;
99059: LD_VAR 0 3
99063: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99064: LD_INT 0
99066: PPUSH
99067: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99068: LD_VAR 0 1
99072: NOT
99073: PUSH
99074: LD_VAR 0 1
99078: PUSH
99079: LD_INT 21
99081: PUSH
99082: LD_INT 2
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 23
99091: PUSH
99092: LD_INT 2
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PPUSH
99103: CALL_OW 69
99107: IN
99108: NOT
99109: OR
99110: IFFALSE 99114
// exit ;
99112: GO 99161
// for i = 1 to 3 do
99114: LD_ADDR_VAR 0 3
99118: PUSH
99119: DOUBLE
99120: LD_INT 1
99122: DEC
99123: ST_TO_ADDR
99124: LD_INT 3
99126: PUSH
99127: FOR_TO
99128: IFFALSE 99159
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99130: LD_VAR 0 1
99134: PPUSH
99135: CALL_OW 250
99139: PPUSH
99140: LD_VAR 0 1
99144: PPUSH
99145: CALL_OW 251
99149: PPUSH
99150: LD_INT 1
99152: PPUSH
99153: CALL_OW 453
99157: GO 99127
99159: POP
99160: POP
// end ;
99161: LD_VAR 0 2
99165: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99166: LD_INT 0
99168: PPUSH
99169: PPUSH
99170: PPUSH
99171: PPUSH
99172: PPUSH
99173: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99174: LD_VAR 0 1
99178: NOT
99179: PUSH
99180: LD_VAR 0 2
99184: NOT
99185: OR
99186: PUSH
99187: LD_VAR 0 1
99191: PPUSH
99192: CALL_OW 314
99196: OR
99197: IFFALSE 99201
// exit ;
99199: GO 99642
// x := GetX ( enemy_unit ) ;
99201: LD_ADDR_VAR 0 7
99205: PUSH
99206: LD_VAR 0 2
99210: PPUSH
99211: CALL_OW 250
99215: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99216: LD_ADDR_VAR 0 8
99220: PUSH
99221: LD_VAR 0 2
99225: PPUSH
99226: CALL_OW 251
99230: ST_TO_ADDR
// if not x or not y then
99231: LD_VAR 0 7
99235: NOT
99236: PUSH
99237: LD_VAR 0 8
99241: NOT
99242: OR
99243: IFFALSE 99247
// exit ;
99245: GO 99642
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99247: LD_ADDR_VAR 0 6
99251: PUSH
99252: LD_VAR 0 7
99256: PPUSH
99257: LD_INT 0
99259: PPUSH
99260: LD_INT 4
99262: PPUSH
99263: CALL_OW 272
99267: PUSH
99268: LD_VAR 0 8
99272: PPUSH
99273: LD_INT 0
99275: PPUSH
99276: LD_INT 4
99278: PPUSH
99279: CALL_OW 273
99283: PUSH
99284: EMPTY
99285: LIST
99286: LIST
99287: PUSH
99288: LD_VAR 0 7
99292: PPUSH
99293: LD_INT 1
99295: PPUSH
99296: LD_INT 4
99298: PPUSH
99299: CALL_OW 272
99303: PUSH
99304: LD_VAR 0 8
99308: PPUSH
99309: LD_INT 1
99311: PPUSH
99312: LD_INT 4
99314: PPUSH
99315: CALL_OW 273
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_VAR 0 7
99328: PPUSH
99329: LD_INT 2
99331: PPUSH
99332: LD_INT 4
99334: PPUSH
99335: CALL_OW 272
99339: PUSH
99340: LD_VAR 0 8
99344: PPUSH
99345: LD_INT 2
99347: PPUSH
99348: LD_INT 4
99350: PPUSH
99351: CALL_OW 273
99355: PUSH
99356: EMPTY
99357: LIST
99358: LIST
99359: PUSH
99360: LD_VAR 0 7
99364: PPUSH
99365: LD_INT 3
99367: PPUSH
99368: LD_INT 4
99370: PPUSH
99371: CALL_OW 272
99375: PUSH
99376: LD_VAR 0 8
99380: PPUSH
99381: LD_INT 3
99383: PPUSH
99384: LD_INT 4
99386: PPUSH
99387: CALL_OW 273
99391: PUSH
99392: EMPTY
99393: LIST
99394: LIST
99395: PUSH
99396: LD_VAR 0 7
99400: PPUSH
99401: LD_INT 4
99403: PPUSH
99404: LD_INT 4
99406: PPUSH
99407: CALL_OW 272
99411: PUSH
99412: LD_VAR 0 8
99416: PPUSH
99417: LD_INT 4
99419: PPUSH
99420: LD_INT 4
99422: PPUSH
99423: CALL_OW 273
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: PUSH
99432: LD_VAR 0 7
99436: PPUSH
99437: LD_INT 5
99439: PPUSH
99440: LD_INT 4
99442: PPUSH
99443: CALL_OW 272
99447: PUSH
99448: LD_VAR 0 8
99452: PPUSH
99453: LD_INT 5
99455: PPUSH
99456: LD_INT 4
99458: PPUSH
99459: CALL_OW 273
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: PUSH
99468: EMPTY
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: LIST
99474: LIST
99475: ST_TO_ADDR
// for i = tmp downto 1 do
99476: LD_ADDR_VAR 0 4
99480: PUSH
99481: DOUBLE
99482: LD_VAR 0 6
99486: INC
99487: ST_TO_ADDR
99488: LD_INT 1
99490: PUSH
99491: FOR_DOWNTO
99492: IFFALSE 99593
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99494: LD_VAR 0 6
99498: PUSH
99499: LD_VAR 0 4
99503: ARRAY
99504: PUSH
99505: LD_INT 1
99507: ARRAY
99508: PPUSH
99509: LD_VAR 0 6
99513: PUSH
99514: LD_VAR 0 4
99518: ARRAY
99519: PUSH
99520: LD_INT 2
99522: ARRAY
99523: PPUSH
99524: CALL_OW 488
99528: NOT
99529: PUSH
99530: LD_VAR 0 6
99534: PUSH
99535: LD_VAR 0 4
99539: ARRAY
99540: PUSH
99541: LD_INT 1
99543: ARRAY
99544: PPUSH
99545: LD_VAR 0 6
99549: PUSH
99550: LD_VAR 0 4
99554: ARRAY
99555: PUSH
99556: LD_INT 2
99558: ARRAY
99559: PPUSH
99560: CALL_OW 428
99564: PUSH
99565: LD_INT 0
99567: NONEQUAL
99568: OR
99569: IFFALSE 99591
// tmp := Delete ( tmp , i ) ;
99571: LD_ADDR_VAR 0 6
99575: PUSH
99576: LD_VAR 0 6
99580: PPUSH
99581: LD_VAR 0 4
99585: PPUSH
99586: CALL_OW 3
99590: ST_TO_ADDR
99591: GO 99491
99593: POP
99594: POP
// j := GetClosestHex ( unit , tmp ) ;
99595: LD_ADDR_VAR 0 5
99599: PUSH
99600: LD_VAR 0 1
99604: PPUSH
99605: LD_VAR 0 6
99609: PPUSH
99610: CALL 98895 0 2
99614: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99615: LD_VAR 0 1
99619: PPUSH
99620: LD_VAR 0 5
99624: PUSH
99625: LD_INT 1
99627: ARRAY
99628: PPUSH
99629: LD_VAR 0 5
99633: PUSH
99634: LD_INT 2
99636: ARRAY
99637: PPUSH
99638: CALL_OW 111
// end ;
99642: LD_VAR 0 3
99646: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99647: LD_INT 0
99649: PPUSH
99650: PPUSH
99651: PPUSH
// uc_side = 0 ;
99652: LD_ADDR_OWVAR 20
99656: PUSH
99657: LD_INT 0
99659: ST_TO_ADDR
// uc_nation = 0 ;
99660: LD_ADDR_OWVAR 21
99664: PUSH
99665: LD_INT 0
99667: ST_TO_ADDR
// InitHc ;
99668: CALL_OW 19
// InitVc ;
99672: CALL_OW 20
// if mastodonts then
99676: LD_VAR 0 6
99680: IFFALSE 99747
// for i = 1 to mastodonts do
99682: LD_ADDR_VAR 0 11
99686: PUSH
99687: DOUBLE
99688: LD_INT 1
99690: DEC
99691: ST_TO_ADDR
99692: LD_VAR 0 6
99696: PUSH
99697: FOR_TO
99698: IFFALSE 99745
// begin vc_chassis := 31 ;
99700: LD_ADDR_OWVAR 37
99704: PUSH
99705: LD_INT 31
99707: ST_TO_ADDR
// vc_control := control_rider ;
99708: LD_ADDR_OWVAR 38
99712: PUSH
99713: LD_INT 4
99715: ST_TO_ADDR
// animal := CreateVehicle ;
99716: LD_ADDR_VAR 0 12
99720: PUSH
99721: CALL_OW 45
99725: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99726: LD_VAR 0 12
99730: PPUSH
99731: LD_VAR 0 8
99735: PPUSH
99736: LD_INT 0
99738: PPUSH
99739: CALL 106518 0 3
// end ;
99743: GO 99697
99745: POP
99746: POP
// if horses then
99747: LD_VAR 0 5
99751: IFFALSE 99818
// for i = 1 to horses do
99753: LD_ADDR_VAR 0 11
99757: PUSH
99758: DOUBLE
99759: LD_INT 1
99761: DEC
99762: ST_TO_ADDR
99763: LD_VAR 0 5
99767: PUSH
99768: FOR_TO
99769: IFFALSE 99816
// begin hc_class := 21 ;
99771: LD_ADDR_OWVAR 28
99775: PUSH
99776: LD_INT 21
99778: ST_TO_ADDR
// hc_gallery :=  ;
99779: LD_ADDR_OWVAR 33
99783: PUSH
99784: LD_STRING 
99786: ST_TO_ADDR
// animal := CreateHuman ;
99787: LD_ADDR_VAR 0 12
99791: PUSH
99792: CALL_OW 44
99796: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99797: LD_VAR 0 12
99801: PPUSH
99802: LD_VAR 0 8
99806: PPUSH
99807: LD_INT 0
99809: PPUSH
99810: CALL 106518 0 3
// end ;
99814: GO 99768
99816: POP
99817: POP
// if birds then
99818: LD_VAR 0 1
99822: IFFALSE 99889
// for i = 1 to birds do
99824: LD_ADDR_VAR 0 11
99828: PUSH
99829: DOUBLE
99830: LD_INT 1
99832: DEC
99833: ST_TO_ADDR
99834: LD_VAR 0 1
99838: PUSH
99839: FOR_TO
99840: IFFALSE 99887
// begin hc_class = 18 ;
99842: LD_ADDR_OWVAR 28
99846: PUSH
99847: LD_INT 18
99849: ST_TO_ADDR
// hc_gallery =  ;
99850: LD_ADDR_OWVAR 33
99854: PUSH
99855: LD_STRING 
99857: ST_TO_ADDR
// animal := CreateHuman ;
99858: LD_ADDR_VAR 0 12
99862: PUSH
99863: CALL_OW 44
99867: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99868: LD_VAR 0 12
99872: PPUSH
99873: LD_VAR 0 8
99877: PPUSH
99878: LD_INT 0
99880: PPUSH
99881: CALL 106518 0 3
// end ;
99885: GO 99839
99887: POP
99888: POP
// if tigers then
99889: LD_VAR 0 2
99893: IFFALSE 99977
// for i = 1 to tigers do
99895: LD_ADDR_VAR 0 11
99899: PUSH
99900: DOUBLE
99901: LD_INT 1
99903: DEC
99904: ST_TO_ADDR
99905: LD_VAR 0 2
99909: PUSH
99910: FOR_TO
99911: IFFALSE 99975
// begin hc_class = class_tiger ;
99913: LD_ADDR_OWVAR 28
99917: PUSH
99918: LD_INT 14
99920: ST_TO_ADDR
// hc_gallery =  ;
99921: LD_ADDR_OWVAR 33
99925: PUSH
99926: LD_STRING 
99928: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99929: LD_ADDR_OWVAR 35
99933: PUSH
99934: LD_INT 7
99936: NEG
99937: PPUSH
99938: LD_INT 7
99940: PPUSH
99941: CALL_OW 12
99945: ST_TO_ADDR
// animal := CreateHuman ;
99946: LD_ADDR_VAR 0 12
99950: PUSH
99951: CALL_OW 44
99955: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99956: LD_VAR 0 12
99960: PPUSH
99961: LD_VAR 0 8
99965: PPUSH
99966: LD_INT 0
99968: PPUSH
99969: CALL 106518 0 3
// end ;
99973: GO 99910
99975: POP
99976: POP
// if apemans then
99977: LD_VAR 0 3
99981: IFFALSE 100104
// for i = 1 to apemans do
99983: LD_ADDR_VAR 0 11
99987: PUSH
99988: DOUBLE
99989: LD_INT 1
99991: DEC
99992: ST_TO_ADDR
99993: LD_VAR 0 3
99997: PUSH
99998: FOR_TO
99999: IFFALSE 100102
// begin hc_class = class_apeman ;
100001: LD_ADDR_OWVAR 28
100005: PUSH
100006: LD_INT 12
100008: ST_TO_ADDR
// hc_gallery =  ;
100009: LD_ADDR_OWVAR 33
100013: PUSH
100014: LD_STRING 
100016: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100017: LD_ADDR_OWVAR 35
100021: PUSH
100022: LD_INT 5
100024: NEG
100025: PPUSH
100026: LD_INT 5
100028: PPUSH
100029: CALL_OW 12
100033: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100034: LD_ADDR_OWVAR 31
100038: PUSH
100039: LD_INT 1
100041: PPUSH
100042: LD_INT 3
100044: PPUSH
100045: CALL_OW 12
100049: PUSH
100050: LD_INT 1
100052: PPUSH
100053: LD_INT 3
100055: PPUSH
100056: CALL_OW 12
100060: PUSH
100061: LD_INT 0
100063: PUSH
100064: LD_INT 0
100066: PUSH
100067: EMPTY
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: ST_TO_ADDR
// animal := CreateHuman ;
100073: LD_ADDR_VAR 0 12
100077: PUSH
100078: CALL_OW 44
100082: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100083: LD_VAR 0 12
100087: PPUSH
100088: LD_VAR 0 8
100092: PPUSH
100093: LD_INT 0
100095: PPUSH
100096: CALL 106518 0 3
// end ;
100100: GO 99998
100102: POP
100103: POP
// if enchidnas then
100104: LD_VAR 0 4
100108: IFFALSE 100175
// for i = 1 to enchidnas do
100110: LD_ADDR_VAR 0 11
100114: PUSH
100115: DOUBLE
100116: LD_INT 1
100118: DEC
100119: ST_TO_ADDR
100120: LD_VAR 0 4
100124: PUSH
100125: FOR_TO
100126: IFFALSE 100173
// begin hc_class = 13 ;
100128: LD_ADDR_OWVAR 28
100132: PUSH
100133: LD_INT 13
100135: ST_TO_ADDR
// hc_gallery =  ;
100136: LD_ADDR_OWVAR 33
100140: PUSH
100141: LD_STRING 
100143: ST_TO_ADDR
// animal := CreateHuman ;
100144: LD_ADDR_VAR 0 12
100148: PUSH
100149: CALL_OW 44
100153: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100154: LD_VAR 0 12
100158: PPUSH
100159: LD_VAR 0 8
100163: PPUSH
100164: LD_INT 0
100166: PPUSH
100167: CALL 106518 0 3
// end ;
100171: GO 100125
100173: POP
100174: POP
// if fishes then
100175: LD_VAR 0 7
100179: IFFALSE 100246
// for i = 1 to fishes do
100181: LD_ADDR_VAR 0 11
100185: PUSH
100186: DOUBLE
100187: LD_INT 1
100189: DEC
100190: ST_TO_ADDR
100191: LD_VAR 0 7
100195: PUSH
100196: FOR_TO
100197: IFFALSE 100244
// begin hc_class = 20 ;
100199: LD_ADDR_OWVAR 28
100203: PUSH
100204: LD_INT 20
100206: ST_TO_ADDR
// hc_gallery =  ;
100207: LD_ADDR_OWVAR 33
100211: PUSH
100212: LD_STRING 
100214: ST_TO_ADDR
// animal := CreateHuman ;
100215: LD_ADDR_VAR 0 12
100219: PUSH
100220: CALL_OW 44
100224: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100225: LD_VAR 0 12
100229: PPUSH
100230: LD_VAR 0 9
100234: PPUSH
100235: LD_INT 0
100237: PPUSH
100238: CALL 106518 0 3
// end ;
100242: GO 100196
100244: POP
100245: POP
// end ;
100246: LD_VAR 0 10
100250: RET
// export function WantHeal ( sci , unit ) ; begin
100251: LD_INT 0
100253: PPUSH
// if GetTaskList ( sci ) > 0 then
100254: LD_VAR 0 1
100258: PPUSH
100259: CALL_OW 437
100263: PUSH
100264: LD_INT 0
100266: GREATER
100267: IFFALSE 100337
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100269: LD_VAR 0 1
100273: PPUSH
100274: CALL_OW 437
100278: PUSH
100279: LD_INT 1
100281: ARRAY
100282: PUSH
100283: LD_INT 1
100285: ARRAY
100286: PUSH
100287: LD_STRING l
100289: EQUAL
100290: PUSH
100291: LD_VAR 0 1
100295: PPUSH
100296: CALL_OW 437
100300: PUSH
100301: LD_INT 1
100303: ARRAY
100304: PUSH
100305: LD_INT 4
100307: ARRAY
100308: PUSH
100309: LD_VAR 0 2
100313: EQUAL
100314: AND
100315: IFFALSE 100327
// result := true else
100317: LD_ADDR_VAR 0 3
100321: PUSH
100322: LD_INT 1
100324: ST_TO_ADDR
100325: GO 100335
// result := false ;
100327: LD_ADDR_VAR 0 3
100331: PUSH
100332: LD_INT 0
100334: ST_TO_ADDR
// end else
100335: GO 100345
// result := false ;
100337: LD_ADDR_VAR 0 3
100341: PUSH
100342: LD_INT 0
100344: ST_TO_ADDR
// end ;
100345: LD_VAR 0 3
100349: RET
// export function HealTarget ( sci ) ; begin
100350: LD_INT 0
100352: PPUSH
// if not sci then
100353: LD_VAR 0 1
100357: NOT
100358: IFFALSE 100362
// exit ;
100360: GO 100427
// result := 0 ;
100362: LD_ADDR_VAR 0 2
100366: PUSH
100367: LD_INT 0
100369: ST_TO_ADDR
// if GetTaskList ( sci ) then
100370: LD_VAR 0 1
100374: PPUSH
100375: CALL_OW 437
100379: IFFALSE 100427
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100381: LD_VAR 0 1
100385: PPUSH
100386: CALL_OW 437
100390: PUSH
100391: LD_INT 1
100393: ARRAY
100394: PUSH
100395: LD_INT 1
100397: ARRAY
100398: PUSH
100399: LD_STRING l
100401: EQUAL
100402: IFFALSE 100427
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100404: LD_ADDR_VAR 0 2
100408: PUSH
100409: LD_VAR 0 1
100413: PPUSH
100414: CALL_OW 437
100418: PUSH
100419: LD_INT 1
100421: ARRAY
100422: PUSH
100423: LD_INT 4
100425: ARRAY
100426: ST_TO_ADDR
// end ;
100427: LD_VAR 0 2
100431: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100432: LD_INT 0
100434: PPUSH
100435: PPUSH
100436: PPUSH
100437: PPUSH
100438: PPUSH
100439: PPUSH
100440: PPUSH
100441: PPUSH
100442: PPUSH
100443: PPUSH
100444: PPUSH
100445: PPUSH
100446: PPUSH
100447: PPUSH
100448: PPUSH
100449: PPUSH
100450: PPUSH
100451: PPUSH
100452: PPUSH
100453: PPUSH
100454: PPUSH
100455: PPUSH
100456: PPUSH
100457: PPUSH
100458: PPUSH
100459: PPUSH
100460: PPUSH
100461: PPUSH
100462: PPUSH
100463: PPUSH
100464: PPUSH
100465: PPUSH
100466: PPUSH
100467: PPUSH
// if not list then
100468: LD_VAR 0 1
100472: NOT
100473: IFFALSE 100477
// exit ;
100475: GO 105129
// base := list [ 1 ] ;
100477: LD_ADDR_VAR 0 3
100481: PUSH
100482: LD_VAR 0 1
100486: PUSH
100487: LD_INT 1
100489: ARRAY
100490: ST_TO_ADDR
// group := list [ 2 ] ;
100491: LD_ADDR_VAR 0 4
100495: PUSH
100496: LD_VAR 0 1
100500: PUSH
100501: LD_INT 2
100503: ARRAY
100504: ST_TO_ADDR
// path := list [ 3 ] ;
100505: LD_ADDR_VAR 0 5
100509: PUSH
100510: LD_VAR 0 1
100514: PUSH
100515: LD_INT 3
100517: ARRAY
100518: ST_TO_ADDR
// flags := list [ 4 ] ;
100519: LD_ADDR_VAR 0 6
100523: PUSH
100524: LD_VAR 0 1
100528: PUSH
100529: LD_INT 4
100531: ARRAY
100532: ST_TO_ADDR
// mined := [ ] ;
100533: LD_ADDR_VAR 0 27
100537: PUSH
100538: EMPTY
100539: ST_TO_ADDR
// bombed := [ ] ;
100540: LD_ADDR_VAR 0 28
100544: PUSH
100545: EMPTY
100546: ST_TO_ADDR
// healers := [ ] ;
100547: LD_ADDR_VAR 0 31
100551: PUSH
100552: EMPTY
100553: ST_TO_ADDR
// to_heal := [ ] ;
100554: LD_ADDR_VAR 0 30
100558: PUSH
100559: EMPTY
100560: ST_TO_ADDR
// repairs := [ ] ;
100561: LD_ADDR_VAR 0 33
100565: PUSH
100566: EMPTY
100567: ST_TO_ADDR
// to_repair := [ ] ;
100568: LD_ADDR_VAR 0 32
100572: PUSH
100573: EMPTY
100574: ST_TO_ADDR
// if not group or not path then
100575: LD_VAR 0 4
100579: NOT
100580: PUSH
100581: LD_VAR 0 5
100585: NOT
100586: OR
100587: IFFALSE 100591
// exit ;
100589: GO 105129
// side := GetSide ( group [ 1 ] ) ;
100591: LD_ADDR_VAR 0 35
100595: PUSH
100596: LD_VAR 0 4
100600: PUSH
100601: LD_INT 1
100603: ARRAY
100604: PPUSH
100605: CALL_OW 255
100609: ST_TO_ADDR
// if flags then
100610: LD_VAR 0 6
100614: IFFALSE 100758
// begin f_ignore_area := flags [ 1 ] ;
100616: LD_ADDR_VAR 0 17
100620: PUSH
100621: LD_VAR 0 6
100625: PUSH
100626: LD_INT 1
100628: ARRAY
100629: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100630: LD_ADDR_VAR 0 18
100634: PUSH
100635: LD_VAR 0 6
100639: PUSH
100640: LD_INT 2
100642: ARRAY
100643: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100644: LD_ADDR_VAR 0 19
100648: PUSH
100649: LD_VAR 0 6
100653: PUSH
100654: LD_INT 3
100656: ARRAY
100657: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100658: LD_ADDR_VAR 0 20
100662: PUSH
100663: LD_VAR 0 6
100667: PUSH
100668: LD_INT 4
100670: ARRAY
100671: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100672: LD_ADDR_VAR 0 21
100676: PUSH
100677: LD_VAR 0 6
100681: PUSH
100682: LD_INT 5
100684: ARRAY
100685: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100686: LD_ADDR_VAR 0 22
100690: PUSH
100691: LD_VAR 0 6
100695: PUSH
100696: LD_INT 6
100698: ARRAY
100699: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100700: LD_ADDR_VAR 0 23
100704: PUSH
100705: LD_VAR 0 6
100709: PUSH
100710: LD_INT 7
100712: ARRAY
100713: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100714: LD_ADDR_VAR 0 24
100718: PUSH
100719: LD_VAR 0 6
100723: PUSH
100724: LD_INT 8
100726: ARRAY
100727: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100728: LD_ADDR_VAR 0 25
100732: PUSH
100733: LD_VAR 0 6
100737: PUSH
100738: LD_INT 9
100740: ARRAY
100741: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100742: LD_ADDR_VAR 0 26
100746: PUSH
100747: LD_VAR 0 6
100751: PUSH
100752: LD_INT 10
100754: ARRAY
100755: ST_TO_ADDR
// end else
100756: GO 100838
// begin f_ignore_area := false ;
100758: LD_ADDR_VAR 0 17
100762: PUSH
100763: LD_INT 0
100765: ST_TO_ADDR
// f_capture := false ;
100766: LD_ADDR_VAR 0 18
100770: PUSH
100771: LD_INT 0
100773: ST_TO_ADDR
// f_ignore_civ := false ;
100774: LD_ADDR_VAR 0 19
100778: PUSH
100779: LD_INT 0
100781: ST_TO_ADDR
// f_murder := false ;
100782: LD_ADDR_VAR 0 20
100786: PUSH
100787: LD_INT 0
100789: ST_TO_ADDR
// f_mines := false ;
100790: LD_ADDR_VAR 0 21
100794: PUSH
100795: LD_INT 0
100797: ST_TO_ADDR
// f_repair := false ;
100798: LD_ADDR_VAR 0 22
100802: PUSH
100803: LD_INT 0
100805: ST_TO_ADDR
// f_heal := false ;
100806: LD_ADDR_VAR 0 23
100810: PUSH
100811: LD_INT 0
100813: ST_TO_ADDR
// f_spacetime := false ;
100814: LD_ADDR_VAR 0 24
100818: PUSH
100819: LD_INT 0
100821: ST_TO_ADDR
// f_attack_depot := false ;
100822: LD_ADDR_VAR 0 25
100826: PUSH
100827: LD_INT 0
100829: ST_TO_ADDR
// f_crawl := false ;
100830: LD_ADDR_VAR 0 26
100834: PUSH
100835: LD_INT 0
100837: ST_TO_ADDR
// end ; if f_heal then
100838: LD_VAR 0 23
100842: IFFALSE 100869
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100844: LD_ADDR_VAR 0 31
100848: PUSH
100849: LD_VAR 0 4
100853: PPUSH
100854: LD_INT 25
100856: PUSH
100857: LD_INT 4
100859: PUSH
100860: EMPTY
100861: LIST
100862: LIST
100863: PPUSH
100864: CALL_OW 72
100868: ST_TO_ADDR
// if f_repair then
100869: LD_VAR 0 22
100873: IFFALSE 100900
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100875: LD_ADDR_VAR 0 33
100879: PUSH
100880: LD_VAR 0 4
100884: PPUSH
100885: LD_INT 25
100887: PUSH
100888: LD_INT 3
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: PPUSH
100895: CALL_OW 72
100899: ST_TO_ADDR
// units_path := [ ] ;
100900: LD_ADDR_VAR 0 16
100904: PUSH
100905: EMPTY
100906: ST_TO_ADDR
// for i = 1 to group do
100907: LD_ADDR_VAR 0 7
100911: PUSH
100912: DOUBLE
100913: LD_INT 1
100915: DEC
100916: ST_TO_ADDR
100917: LD_VAR 0 4
100921: PUSH
100922: FOR_TO
100923: IFFALSE 100952
// units_path := Replace ( units_path , i , path ) ;
100925: LD_ADDR_VAR 0 16
100929: PUSH
100930: LD_VAR 0 16
100934: PPUSH
100935: LD_VAR 0 7
100939: PPUSH
100940: LD_VAR 0 5
100944: PPUSH
100945: CALL_OW 1
100949: ST_TO_ADDR
100950: GO 100922
100952: POP
100953: POP
// repeat for i = group downto 1 do
100954: LD_ADDR_VAR 0 7
100958: PUSH
100959: DOUBLE
100960: LD_VAR 0 4
100964: INC
100965: ST_TO_ADDR
100966: LD_INT 1
100968: PUSH
100969: FOR_DOWNTO
100970: IFFALSE 105092
// begin wait ( 5 ) ;
100972: LD_INT 5
100974: PPUSH
100975: CALL_OW 67
// tmp := [ ] ;
100979: LD_ADDR_VAR 0 14
100983: PUSH
100984: EMPTY
100985: ST_TO_ADDR
// attacking := false ;
100986: LD_ADDR_VAR 0 29
100990: PUSH
100991: LD_INT 0
100993: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100994: LD_VAR 0 4
100998: PUSH
100999: LD_VAR 0 7
101003: ARRAY
101004: PPUSH
101005: CALL_OW 301
101009: PUSH
101010: LD_VAR 0 4
101014: PUSH
101015: LD_VAR 0 7
101019: ARRAY
101020: NOT
101021: OR
101022: IFFALSE 101131
// begin if GetType ( group [ i ] ) = unit_human then
101024: LD_VAR 0 4
101028: PUSH
101029: LD_VAR 0 7
101033: ARRAY
101034: PPUSH
101035: CALL_OW 247
101039: PUSH
101040: LD_INT 1
101042: EQUAL
101043: IFFALSE 101089
// begin to_heal := to_heal diff group [ i ] ;
101045: LD_ADDR_VAR 0 30
101049: PUSH
101050: LD_VAR 0 30
101054: PUSH
101055: LD_VAR 0 4
101059: PUSH
101060: LD_VAR 0 7
101064: ARRAY
101065: DIFF
101066: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101067: LD_ADDR_VAR 0 31
101071: PUSH
101072: LD_VAR 0 31
101076: PUSH
101077: LD_VAR 0 4
101081: PUSH
101082: LD_VAR 0 7
101086: ARRAY
101087: DIFF
101088: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101089: LD_ADDR_VAR 0 4
101093: PUSH
101094: LD_VAR 0 4
101098: PPUSH
101099: LD_VAR 0 7
101103: PPUSH
101104: CALL_OW 3
101108: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101109: LD_ADDR_VAR 0 16
101113: PUSH
101114: LD_VAR 0 16
101118: PPUSH
101119: LD_VAR 0 7
101123: PPUSH
101124: CALL_OW 3
101128: ST_TO_ADDR
// continue ;
101129: GO 100969
// end ; if f_repair then
101131: LD_VAR 0 22
101135: IFFALSE 101624
// begin if GetType ( group [ i ] ) = unit_vehicle then
101137: LD_VAR 0 4
101141: PUSH
101142: LD_VAR 0 7
101146: ARRAY
101147: PPUSH
101148: CALL_OW 247
101152: PUSH
101153: LD_INT 2
101155: EQUAL
101156: IFFALSE 101346
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101158: LD_VAR 0 4
101162: PUSH
101163: LD_VAR 0 7
101167: ARRAY
101168: PPUSH
101169: CALL_OW 256
101173: PUSH
101174: LD_INT 700
101176: LESS
101177: PUSH
101178: LD_VAR 0 4
101182: PUSH
101183: LD_VAR 0 7
101187: ARRAY
101188: PUSH
101189: LD_VAR 0 32
101193: IN
101194: NOT
101195: AND
101196: IFFALSE 101220
// to_repair := to_repair union group [ i ] ;
101198: LD_ADDR_VAR 0 32
101202: PUSH
101203: LD_VAR 0 32
101207: PUSH
101208: LD_VAR 0 4
101212: PUSH
101213: LD_VAR 0 7
101217: ARRAY
101218: UNION
101219: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101220: LD_VAR 0 4
101224: PUSH
101225: LD_VAR 0 7
101229: ARRAY
101230: PPUSH
101231: CALL_OW 256
101235: PUSH
101236: LD_INT 1000
101238: EQUAL
101239: PUSH
101240: LD_VAR 0 4
101244: PUSH
101245: LD_VAR 0 7
101249: ARRAY
101250: PUSH
101251: LD_VAR 0 32
101255: IN
101256: AND
101257: IFFALSE 101281
// to_repair := to_repair diff group [ i ] ;
101259: LD_ADDR_VAR 0 32
101263: PUSH
101264: LD_VAR 0 32
101268: PUSH
101269: LD_VAR 0 4
101273: PUSH
101274: LD_VAR 0 7
101278: ARRAY
101279: DIFF
101280: ST_TO_ADDR
// if group [ i ] in to_repair then
101281: LD_VAR 0 4
101285: PUSH
101286: LD_VAR 0 7
101290: ARRAY
101291: PUSH
101292: LD_VAR 0 32
101296: IN
101297: IFFALSE 101344
// begin if not IsInArea ( group [ i ] , f_repair ) then
101299: LD_VAR 0 4
101303: PUSH
101304: LD_VAR 0 7
101308: ARRAY
101309: PPUSH
101310: LD_VAR 0 22
101314: PPUSH
101315: CALL_OW 308
101319: NOT
101320: IFFALSE 101342
// ComMoveToArea ( group [ i ] , f_repair ) ;
101322: LD_VAR 0 4
101326: PUSH
101327: LD_VAR 0 7
101331: ARRAY
101332: PPUSH
101333: LD_VAR 0 22
101337: PPUSH
101338: CALL_OW 113
// continue ;
101342: GO 100969
// end ; end else
101344: GO 101624
// if group [ i ] in repairs then
101346: LD_VAR 0 4
101350: PUSH
101351: LD_VAR 0 7
101355: ARRAY
101356: PUSH
101357: LD_VAR 0 33
101361: IN
101362: IFFALSE 101624
// begin if IsInUnit ( group [ i ] ) then
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 7
101373: ARRAY
101374: PPUSH
101375: CALL_OW 310
101379: IFFALSE 101447
// begin z := IsInUnit ( group [ i ] ) ;
101381: LD_ADDR_VAR 0 13
101385: PUSH
101386: LD_VAR 0 4
101390: PUSH
101391: LD_VAR 0 7
101395: ARRAY
101396: PPUSH
101397: CALL_OW 310
101401: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101402: LD_VAR 0 13
101406: PUSH
101407: LD_VAR 0 32
101411: IN
101412: PUSH
101413: LD_VAR 0 13
101417: PPUSH
101418: LD_VAR 0 22
101422: PPUSH
101423: CALL_OW 308
101427: AND
101428: IFFALSE 101445
// ComExitVehicle ( group [ i ] ) ;
101430: LD_VAR 0 4
101434: PUSH
101435: LD_VAR 0 7
101439: ARRAY
101440: PPUSH
101441: CALL_OW 121
// end else
101445: GO 101624
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101447: LD_ADDR_VAR 0 13
101451: PUSH
101452: LD_VAR 0 4
101456: PPUSH
101457: LD_INT 95
101459: PUSH
101460: LD_VAR 0 22
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: LD_INT 58
101471: PUSH
101472: EMPTY
101473: LIST
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PPUSH
101479: CALL_OW 72
101483: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101484: LD_VAR 0 4
101488: PUSH
101489: LD_VAR 0 7
101493: ARRAY
101494: PPUSH
101495: CALL_OW 314
101499: NOT
101500: IFFALSE 101622
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101502: LD_ADDR_VAR 0 10
101506: PUSH
101507: LD_VAR 0 13
101511: PPUSH
101512: LD_VAR 0 4
101516: PUSH
101517: LD_VAR 0 7
101521: ARRAY
101522: PPUSH
101523: CALL_OW 74
101527: ST_TO_ADDR
// if not x then
101528: LD_VAR 0 10
101532: NOT
101533: IFFALSE 101537
// continue ;
101535: GO 100969
// if GetLives ( x ) < 1000 then
101537: LD_VAR 0 10
101541: PPUSH
101542: CALL_OW 256
101546: PUSH
101547: LD_INT 1000
101549: LESS
101550: IFFALSE 101574
// ComRepairVehicle ( group [ i ] , x ) else
101552: LD_VAR 0 4
101556: PUSH
101557: LD_VAR 0 7
101561: ARRAY
101562: PPUSH
101563: LD_VAR 0 10
101567: PPUSH
101568: CALL_OW 129
101572: GO 101622
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101574: LD_VAR 0 23
101578: PUSH
101579: LD_VAR 0 4
101583: PUSH
101584: LD_VAR 0 7
101588: ARRAY
101589: PPUSH
101590: CALL_OW 256
101594: PUSH
101595: LD_INT 1000
101597: LESS
101598: AND
101599: NOT
101600: IFFALSE 101622
// ComEnterUnit ( group [ i ] , x ) ;
101602: LD_VAR 0 4
101606: PUSH
101607: LD_VAR 0 7
101611: ARRAY
101612: PPUSH
101613: LD_VAR 0 10
101617: PPUSH
101618: CALL_OW 120
// end ; continue ;
101622: GO 100969
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101624: LD_VAR 0 23
101628: PUSH
101629: LD_VAR 0 4
101633: PUSH
101634: LD_VAR 0 7
101638: ARRAY
101639: PPUSH
101640: CALL_OW 247
101644: PUSH
101645: LD_INT 1
101647: EQUAL
101648: AND
101649: IFFALSE 102127
// begin if group [ i ] in healers then
101651: LD_VAR 0 4
101655: PUSH
101656: LD_VAR 0 7
101660: ARRAY
101661: PUSH
101662: LD_VAR 0 31
101666: IN
101667: IFFALSE 101940
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101669: LD_VAR 0 4
101673: PUSH
101674: LD_VAR 0 7
101678: ARRAY
101679: PPUSH
101680: LD_VAR 0 23
101684: PPUSH
101685: CALL_OW 308
101689: NOT
101690: PUSH
101691: LD_VAR 0 4
101695: PUSH
101696: LD_VAR 0 7
101700: ARRAY
101701: PPUSH
101702: CALL_OW 314
101706: NOT
101707: AND
101708: IFFALSE 101732
// ComMoveToArea ( group [ i ] , f_heal ) else
101710: LD_VAR 0 4
101714: PUSH
101715: LD_VAR 0 7
101719: ARRAY
101720: PPUSH
101721: LD_VAR 0 23
101725: PPUSH
101726: CALL_OW 113
101730: GO 101938
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101732: LD_VAR 0 4
101736: PUSH
101737: LD_VAR 0 7
101741: ARRAY
101742: PPUSH
101743: CALL 100350 0 1
101747: PPUSH
101748: CALL_OW 256
101752: PUSH
101753: LD_INT 1000
101755: EQUAL
101756: IFFALSE 101775
// ComStop ( group [ i ] ) else
101758: LD_VAR 0 4
101762: PUSH
101763: LD_VAR 0 7
101767: ARRAY
101768: PPUSH
101769: CALL_OW 141
101773: GO 101938
// if not HasTask ( group [ i ] ) and to_heal then
101775: LD_VAR 0 4
101779: PUSH
101780: LD_VAR 0 7
101784: ARRAY
101785: PPUSH
101786: CALL_OW 314
101790: NOT
101791: PUSH
101792: LD_VAR 0 30
101796: AND
101797: IFFALSE 101938
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101799: LD_ADDR_VAR 0 13
101803: PUSH
101804: LD_VAR 0 30
101808: PPUSH
101809: LD_INT 3
101811: PUSH
101812: LD_INT 54
101814: PUSH
101815: EMPTY
101816: LIST
101817: PUSH
101818: EMPTY
101819: LIST
101820: LIST
101821: PPUSH
101822: CALL_OW 72
101826: PPUSH
101827: LD_VAR 0 4
101831: PUSH
101832: LD_VAR 0 7
101836: ARRAY
101837: PPUSH
101838: CALL_OW 74
101842: ST_TO_ADDR
// if z then
101843: LD_VAR 0 13
101847: IFFALSE 101938
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101849: LD_INT 91
101851: PUSH
101852: LD_VAR 0 13
101856: PUSH
101857: LD_INT 10
101859: PUSH
101860: EMPTY
101861: LIST
101862: LIST
101863: LIST
101864: PUSH
101865: LD_INT 81
101867: PUSH
101868: LD_VAR 0 13
101872: PPUSH
101873: CALL_OW 255
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: PUSH
101882: EMPTY
101883: LIST
101884: LIST
101885: PPUSH
101886: CALL_OW 69
101890: PUSH
101891: LD_INT 0
101893: EQUAL
101894: IFFALSE 101918
// ComHeal ( group [ i ] , z ) else
101896: LD_VAR 0 4
101900: PUSH
101901: LD_VAR 0 7
101905: ARRAY
101906: PPUSH
101907: LD_VAR 0 13
101911: PPUSH
101912: CALL_OW 128
101916: GO 101938
// ComMoveToArea ( group [ i ] , f_heal ) ;
101918: LD_VAR 0 4
101922: PUSH
101923: LD_VAR 0 7
101927: ARRAY
101928: PPUSH
101929: LD_VAR 0 23
101933: PPUSH
101934: CALL_OW 113
// end ; continue ;
101938: GO 100969
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101940: LD_VAR 0 4
101944: PUSH
101945: LD_VAR 0 7
101949: ARRAY
101950: PPUSH
101951: CALL_OW 256
101955: PUSH
101956: LD_INT 700
101958: LESS
101959: PUSH
101960: LD_VAR 0 4
101964: PUSH
101965: LD_VAR 0 7
101969: ARRAY
101970: PUSH
101971: LD_VAR 0 30
101975: IN
101976: NOT
101977: AND
101978: IFFALSE 102002
// to_heal := to_heal union group [ i ] ;
101980: LD_ADDR_VAR 0 30
101984: PUSH
101985: LD_VAR 0 30
101989: PUSH
101990: LD_VAR 0 4
101994: PUSH
101995: LD_VAR 0 7
101999: ARRAY
102000: UNION
102001: ST_TO_ADDR
// if group [ i ] in to_heal then
102002: LD_VAR 0 4
102006: PUSH
102007: LD_VAR 0 7
102011: ARRAY
102012: PUSH
102013: LD_VAR 0 30
102017: IN
102018: IFFALSE 102127
// begin if GetLives ( group [ i ] ) = 1000 then
102020: LD_VAR 0 4
102024: PUSH
102025: LD_VAR 0 7
102029: ARRAY
102030: PPUSH
102031: CALL_OW 256
102035: PUSH
102036: LD_INT 1000
102038: EQUAL
102039: IFFALSE 102065
// to_heal := to_heal diff group [ i ] else
102041: LD_ADDR_VAR 0 30
102045: PUSH
102046: LD_VAR 0 30
102050: PUSH
102051: LD_VAR 0 4
102055: PUSH
102056: LD_VAR 0 7
102060: ARRAY
102061: DIFF
102062: ST_TO_ADDR
102063: GO 102127
// begin if not IsInArea ( group [ i ] , to_heal ) then
102065: LD_VAR 0 4
102069: PUSH
102070: LD_VAR 0 7
102074: ARRAY
102075: PPUSH
102076: LD_VAR 0 30
102080: PPUSH
102081: CALL_OW 308
102085: NOT
102086: IFFALSE 102110
// ComMoveToArea ( group [ i ] , f_heal ) else
102088: LD_VAR 0 4
102092: PUSH
102093: LD_VAR 0 7
102097: ARRAY
102098: PPUSH
102099: LD_VAR 0 23
102103: PPUSH
102104: CALL_OW 113
102108: GO 102125
// ComHold ( group [ i ] ) ;
102110: LD_VAR 0 4
102114: PUSH
102115: LD_VAR 0 7
102119: ARRAY
102120: PPUSH
102121: CALL_OW 140
// continue ;
102125: GO 100969
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102127: LD_VAR 0 4
102131: PUSH
102132: LD_VAR 0 7
102136: ARRAY
102137: PPUSH
102138: LD_INT 10
102140: PPUSH
102141: CALL 98770 0 2
102145: NOT
102146: PUSH
102147: LD_VAR 0 16
102151: PUSH
102152: LD_VAR 0 7
102156: ARRAY
102157: PUSH
102158: EMPTY
102159: EQUAL
102160: NOT
102161: AND
102162: IFFALSE 102428
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102164: LD_VAR 0 4
102168: PUSH
102169: LD_VAR 0 7
102173: ARRAY
102174: PPUSH
102175: CALL_OW 262
102179: PUSH
102180: LD_INT 1
102182: PUSH
102183: LD_INT 2
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: IN
102190: IFFALSE 102231
// if GetFuel ( group [ i ] ) < 10 then
102192: LD_VAR 0 4
102196: PUSH
102197: LD_VAR 0 7
102201: ARRAY
102202: PPUSH
102203: CALL_OW 261
102207: PUSH
102208: LD_INT 10
102210: LESS
102211: IFFALSE 102231
// SetFuel ( group [ i ] , 12 ) ;
102213: LD_VAR 0 4
102217: PUSH
102218: LD_VAR 0 7
102222: ARRAY
102223: PPUSH
102224: LD_INT 12
102226: PPUSH
102227: CALL_OW 240
// if units_path [ i ] then
102231: LD_VAR 0 16
102235: PUSH
102236: LD_VAR 0 7
102240: ARRAY
102241: IFFALSE 102426
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102243: LD_VAR 0 4
102247: PUSH
102248: LD_VAR 0 7
102252: ARRAY
102253: PPUSH
102254: LD_VAR 0 16
102258: PUSH
102259: LD_VAR 0 7
102263: ARRAY
102264: PUSH
102265: LD_INT 1
102267: ARRAY
102268: PUSH
102269: LD_INT 1
102271: ARRAY
102272: PPUSH
102273: LD_VAR 0 16
102277: PUSH
102278: LD_VAR 0 7
102282: ARRAY
102283: PUSH
102284: LD_INT 1
102286: ARRAY
102287: PUSH
102288: LD_INT 2
102290: ARRAY
102291: PPUSH
102292: CALL_OW 297
102296: PUSH
102297: LD_INT 6
102299: GREATER
102300: IFFALSE 102375
// begin if not HasTask ( group [ i ] ) then
102302: LD_VAR 0 4
102306: PUSH
102307: LD_VAR 0 7
102311: ARRAY
102312: PPUSH
102313: CALL_OW 314
102317: NOT
102318: IFFALSE 102373
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102320: LD_VAR 0 4
102324: PUSH
102325: LD_VAR 0 7
102329: ARRAY
102330: PPUSH
102331: LD_VAR 0 16
102335: PUSH
102336: LD_VAR 0 7
102340: ARRAY
102341: PUSH
102342: LD_INT 1
102344: ARRAY
102345: PUSH
102346: LD_INT 1
102348: ARRAY
102349: PPUSH
102350: LD_VAR 0 16
102354: PUSH
102355: LD_VAR 0 7
102359: ARRAY
102360: PUSH
102361: LD_INT 1
102363: ARRAY
102364: PUSH
102365: LD_INT 2
102367: ARRAY
102368: PPUSH
102369: CALL_OW 114
// end else
102373: GO 102426
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102375: LD_ADDR_VAR 0 15
102379: PUSH
102380: LD_VAR 0 16
102384: PUSH
102385: LD_VAR 0 7
102389: ARRAY
102390: PPUSH
102391: LD_INT 1
102393: PPUSH
102394: CALL_OW 3
102398: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102399: LD_ADDR_VAR 0 16
102403: PUSH
102404: LD_VAR 0 16
102408: PPUSH
102409: LD_VAR 0 7
102413: PPUSH
102414: LD_VAR 0 15
102418: PPUSH
102419: CALL_OW 1
102423: ST_TO_ADDR
// continue ;
102424: GO 100969
// end ; end ; end else
102426: GO 105090
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102428: LD_ADDR_VAR 0 14
102432: PUSH
102433: LD_INT 81
102435: PUSH
102436: LD_VAR 0 4
102440: PUSH
102441: LD_VAR 0 7
102445: ARRAY
102446: PPUSH
102447: CALL_OW 255
102451: PUSH
102452: EMPTY
102453: LIST
102454: LIST
102455: PPUSH
102456: CALL_OW 69
102460: ST_TO_ADDR
// if not tmp then
102461: LD_VAR 0 14
102465: NOT
102466: IFFALSE 102470
// continue ;
102468: GO 100969
// if f_ignore_area then
102470: LD_VAR 0 17
102474: IFFALSE 102562
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102476: LD_ADDR_VAR 0 15
102480: PUSH
102481: LD_VAR 0 14
102485: PPUSH
102486: LD_INT 3
102488: PUSH
102489: LD_INT 92
102491: PUSH
102492: LD_VAR 0 17
102496: PUSH
102497: LD_INT 1
102499: ARRAY
102500: PUSH
102501: LD_VAR 0 17
102505: PUSH
102506: LD_INT 2
102508: ARRAY
102509: PUSH
102510: LD_VAR 0 17
102514: PUSH
102515: LD_INT 3
102517: ARRAY
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: LIST
102523: LIST
102524: PUSH
102525: EMPTY
102526: LIST
102527: LIST
102528: PPUSH
102529: CALL_OW 72
102533: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102534: LD_VAR 0 14
102538: PUSH
102539: LD_VAR 0 15
102543: DIFF
102544: IFFALSE 102562
// tmp := tmp diff tmp2 ;
102546: LD_ADDR_VAR 0 14
102550: PUSH
102551: LD_VAR 0 14
102555: PUSH
102556: LD_VAR 0 15
102560: DIFF
102561: ST_TO_ADDR
// end ; if not f_murder then
102562: LD_VAR 0 20
102566: NOT
102567: IFFALSE 102625
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102569: LD_ADDR_VAR 0 15
102573: PUSH
102574: LD_VAR 0 14
102578: PPUSH
102579: LD_INT 3
102581: PUSH
102582: LD_INT 50
102584: PUSH
102585: EMPTY
102586: LIST
102587: PUSH
102588: EMPTY
102589: LIST
102590: LIST
102591: PPUSH
102592: CALL_OW 72
102596: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102597: LD_VAR 0 14
102601: PUSH
102602: LD_VAR 0 15
102606: DIFF
102607: IFFALSE 102625
// tmp := tmp diff tmp2 ;
102609: LD_ADDR_VAR 0 14
102613: PUSH
102614: LD_VAR 0 14
102618: PUSH
102619: LD_VAR 0 15
102623: DIFF
102624: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102625: LD_ADDR_VAR 0 14
102629: PUSH
102630: LD_VAR 0 4
102634: PUSH
102635: LD_VAR 0 7
102639: ARRAY
102640: PPUSH
102641: LD_VAR 0 14
102645: PPUSH
102646: LD_INT 1
102648: PPUSH
102649: LD_INT 1
102651: PPUSH
102652: CALL 72413 0 4
102656: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102657: LD_VAR 0 4
102661: PUSH
102662: LD_VAR 0 7
102666: ARRAY
102667: PPUSH
102668: CALL_OW 257
102672: PUSH
102673: LD_INT 1
102675: EQUAL
102676: IFFALSE 103124
// begin if WantPlant ( group [ i ] ) then
102678: LD_VAR 0 4
102682: PUSH
102683: LD_VAR 0 7
102687: ARRAY
102688: PPUSH
102689: CALL 71914 0 1
102693: IFFALSE 102697
// continue ;
102695: GO 100969
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102697: LD_VAR 0 18
102701: PUSH
102702: LD_VAR 0 4
102706: PUSH
102707: LD_VAR 0 7
102711: ARRAY
102712: PPUSH
102713: CALL_OW 310
102717: NOT
102718: AND
102719: PUSH
102720: LD_VAR 0 14
102724: PUSH
102725: LD_INT 1
102727: ARRAY
102728: PUSH
102729: LD_VAR 0 14
102733: PPUSH
102734: LD_INT 21
102736: PUSH
102737: LD_INT 2
102739: PUSH
102740: EMPTY
102741: LIST
102742: LIST
102743: PUSH
102744: LD_INT 58
102746: PUSH
102747: EMPTY
102748: LIST
102749: PUSH
102750: EMPTY
102751: LIST
102752: LIST
102753: PPUSH
102754: CALL_OW 72
102758: IN
102759: AND
102760: IFFALSE 102796
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102762: LD_VAR 0 4
102766: PUSH
102767: LD_VAR 0 7
102771: ARRAY
102772: PPUSH
102773: LD_VAR 0 14
102777: PUSH
102778: LD_INT 1
102780: ARRAY
102781: PPUSH
102782: CALL_OW 120
// attacking := true ;
102786: LD_ADDR_VAR 0 29
102790: PUSH
102791: LD_INT 1
102793: ST_TO_ADDR
// continue ;
102794: GO 100969
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102796: LD_VAR 0 26
102800: PUSH
102801: LD_VAR 0 4
102805: PUSH
102806: LD_VAR 0 7
102810: ARRAY
102811: PPUSH
102812: CALL_OW 257
102816: PUSH
102817: LD_INT 1
102819: EQUAL
102820: AND
102821: PUSH
102822: LD_VAR 0 4
102826: PUSH
102827: LD_VAR 0 7
102831: ARRAY
102832: PPUSH
102833: CALL_OW 256
102837: PUSH
102838: LD_INT 800
102840: LESS
102841: AND
102842: PUSH
102843: LD_VAR 0 4
102847: PUSH
102848: LD_VAR 0 7
102852: ARRAY
102853: PPUSH
102854: CALL_OW 318
102858: NOT
102859: AND
102860: IFFALSE 102877
// ComCrawl ( group [ i ] ) ;
102862: LD_VAR 0 4
102866: PUSH
102867: LD_VAR 0 7
102871: ARRAY
102872: PPUSH
102873: CALL_OW 137
// if f_mines then
102877: LD_VAR 0 21
102881: IFFALSE 103124
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102883: LD_VAR 0 14
102887: PUSH
102888: LD_INT 1
102890: ARRAY
102891: PPUSH
102892: CALL_OW 247
102896: PUSH
102897: LD_INT 3
102899: EQUAL
102900: PUSH
102901: LD_VAR 0 14
102905: PUSH
102906: LD_INT 1
102908: ARRAY
102909: PUSH
102910: LD_VAR 0 27
102914: IN
102915: NOT
102916: AND
102917: IFFALSE 103124
// begin x := GetX ( tmp [ 1 ] ) ;
102919: LD_ADDR_VAR 0 10
102923: PUSH
102924: LD_VAR 0 14
102928: PUSH
102929: LD_INT 1
102931: ARRAY
102932: PPUSH
102933: CALL_OW 250
102937: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102938: LD_ADDR_VAR 0 11
102942: PUSH
102943: LD_VAR 0 14
102947: PUSH
102948: LD_INT 1
102950: ARRAY
102951: PPUSH
102952: CALL_OW 251
102956: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102957: LD_ADDR_VAR 0 12
102961: PUSH
102962: LD_VAR 0 4
102966: PUSH
102967: LD_VAR 0 7
102971: ARRAY
102972: PPUSH
102973: CALL 98855 0 1
102977: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102978: LD_VAR 0 4
102982: PUSH
102983: LD_VAR 0 7
102987: ARRAY
102988: PPUSH
102989: LD_VAR 0 10
102993: PPUSH
102994: LD_VAR 0 11
102998: PPUSH
102999: LD_VAR 0 14
103003: PUSH
103004: LD_INT 1
103006: ARRAY
103007: PPUSH
103008: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103012: LD_VAR 0 4
103016: PUSH
103017: LD_VAR 0 7
103021: ARRAY
103022: PPUSH
103023: LD_VAR 0 10
103027: PPUSH
103028: LD_VAR 0 12
103032: PPUSH
103033: LD_INT 7
103035: PPUSH
103036: CALL_OW 272
103040: PPUSH
103041: LD_VAR 0 11
103045: PPUSH
103046: LD_VAR 0 12
103050: PPUSH
103051: LD_INT 7
103053: PPUSH
103054: CALL_OW 273
103058: PPUSH
103059: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103063: LD_VAR 0 4
103067: PUSH
103068: LD_VAR 0 7
103072: ARRAY
103073: PPUSH
103074: LD_INT 71
103076: PPUSH
103077: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103081: LD_ADDR_VAR 0 27
103085: PUSH
103086: LD_VAR 0 27
103090: PPUSH
103091: LD_VAR 0 27
103095: PUSH
103096: LD_INT 1
103098: PLUS
103099: PPUSH
103100: LD_VAR 0 14
103104: PUSH
103105: LD_INT 1
103107: ARRAY
103108: PPUSH
103109: CALL_OW 1
103113: ST_TO_ADDR
// attacking := true ;
103114: LD_ADDR_VAR 0 29
103118: PUSH
103119: LD_INT 1
103121: ST_TO_ADDR
// continue ;
103122: GO 100969
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103124: LD_VAR 0 4
103128: PUSH
103129: LD_VAR 0 7
103133: ARRAY
103134: PPUSH
103135: CALL_OW 257
103139: PUSH
103140: LD_INT 17
103142: EQUAL
103143: PUSH
103144: LD_VAR 0 4
103148: PUSH
103149: LD_VAR 0 7
103153: ARRAY
103154: PPUSH
103155: CALL_OW 110
103159: PUSH
103160: LD_INT 71
103162: EQUAL
103163: NOT
103164: AND
103165: IFFALSE 103311
// begin attacking := false ;
103167: LD_ADDR_VAR 0 29
103171: PUSH
103172: LD_INT 0
103174: ST_TO_ADDR
// k := 5 ;
103175: LD_ADDR_VAR 0 9
103179: PUSH
103180: LD_INT 5
103182: ST_TO_ADDR
// if tmp < k then
103183: LD_VAR 0 14
103187: PUSH
103188: LD_VAR 0 9
103192: LESS
103193: IFFALSE 103205
// k := tmp ;
103195: LD_ADDR_VAR 0 9
103199: PUSH
103200: LD_VAR 0 14
103204: ST_TO_ADDR
// for j = 1 to k do
103205: LD_ADDR_VAR 0 8
103209: PUSH
103210: DOUBLE
103211: LD_INT 1
103213: DEC
103214: ST_TO_ADDR
103215: LD_VAR 0 9
103219: PUSH
103220: FOR_TO
103221: IFFALSE 103309
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103223: LD_VAR 0 14
103227: PUSH
103228: LD_VAR 0 8
103232: ARRAY
103233: PUSH
103234: LD_VAR 0 14
103238: PPUSH
103239: LD_INT 58
103241: PUSH
103242: EMPTY
103243: LIST
103244: PPUSH
103245: CALL_OW 72
103249: IN
103250: NOT
103251: IFFALSE 103307
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103253: LD_VAR 0 4
103257: PUSH
103258: LD_VAR 0 7
103262: ARRAY
103263: PPUSH
103264: LD_VAR 0 14
103268: PUSH
103269: LD_VAR 0 8
103273: ARRAY
103274: PPUSH
103275: CALL_OW 115
// attacking := true ;
103279: LD_ADDR_VAR 0 29
103283: PUSH
103284: LD_INT 1
103286: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103287: LD_VAR 0 4
103291: PUSH
103292: LD_VAR 0 7
103296: ARRAY
103297: PPUSH
103298: LD_INT 71
103300: PPUSH
103301: CALL_OW 109
// continue ;
103305: GO 103220
// end ; end ;
103307: GO 103220
103309: POP
103310: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103311: LD_VAR 0 4
103315: PUSH
103316: LD_VAR 0 7
103320: ARRAY
103321: PPUSH
103322: CALL_OW 257
103326: PUSH
103327: LD_INT 8
103329: EQUAL
103330: PUSH
103331: LD_VAR 0 4
103335: PUSH
103336: LD_VAR 0 7
103340: ARRAY
103341: PPUSH
103342: CALL_OW 264
103346: PUSH
103347: LD_INT 28
103349: PUSH
103350: LD_INT 45
103352: PUSH
103353: LD_INT 7
103355: PUSH
103356: LD_INT 47
103358: PUSH
103359: EMPTY
103360: LIST
103361: LIST
103362: LIST
103363: LIST
103364: IN
103365: OR
103366: IFFALSE 103622
// begin attacking := false ;
103368: LD_ADDR_VAR 0 29
103372: PUSH
103373: LD_INT 0
103375: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103376: LD_VAR 0 14
103380: PUSH
103381: LD_INT 1
103383: ARRAY
103384: PPUSH
103385: CALL_OW 266
103389: PUSH
103390: LD_INT 32
103392: PUSH
103393: LD_INT 31
103395: PUSH
103396: LD_INT 33
103398: PUSH
103399: LD_INT 4
103401: PUSH
103402: LD_INT 5
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: LIST
103409: LIST
103410: LIST
103411: IN
103412: IFFALSE 103598
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103414: LD_ADDR_VAR 0 9
103418: PUSH
103419: LD_VAR 0 14
103423: PUSH
103424: LD_INT 1
103426: ARRAY
103427: PPUSH
103428: CALL_OW 266
103432: PPUSH
103433: LD_VAR 0 14
103437: PUSH
103438: LD_INT 1
103440: ARRAY
103441: PPUSH
103442: CALL_OW 250
103446: PPUSH
103447: LD_VAR 0 14
103451: PUSH
103452: LD_INT 1
103454: ARRAY
103455: PPUSH
103456: CALL_OW 251
103460: PPUSH
103461: LD_VAR 0 14
103465: PUSH
103466: LD_INT 1
103468: ARRAY
103469: PPUSH
103470: CALL_OW 254
103474: PPUSH
103475: LD_VAR 0 14
103479: PUSH
103480: LD_INT 1
103482: ARRAY
103483: PPUSH
103484: CALL_OW 248
103488: PPUSH
103489: LD_INT 0
103491: PPUSH
103492: CALL 80225 0 6
103496: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103497: LD_ADDR_VAR 0 8
103501: PUSH
103502: LD_VAR 0 4
103506: PUSH
103507: LD_VAR 0 7
103511: ARRAY
103512: PPUSH
103513: LD_VAR 0 9
103517: PPUSH
103518: CALL 98895 0 2
103522: ST_TO_ADDR
// if j then
103523: LD_VAR 0 8
103527: IFFALSE 103596
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103529: LD_VAR 0 8
103533: PUSH
103534: LD_INT 1
103536: ARRAY
103537: PPUSH
103538: LD_VAR 0 8
103542: PUSH
103543: LD_INT 2
103545: ARRAY
103546: PPUSH
103547: CALL_OW 488
103551: IFFALSE 103596
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103553: LD_VAR 0 4
103557: PUSH
103558: LD_VAR 0 7
103562: ARRAY
103563: PPUSH
103564: LD_VAR 0 8
103568: PUSH
103569: LD_INT 1
103571: ARRAY
103572: PPUSH
103573: LD_VAR 0 8
103577: PUSH
103578: LD_INT 2
103580: ARRAY
103581: PPUSH
103582: CALL_OW 116
// attacking := true ;
103586: LD_ADDR_VAR 0 29
103590: PUSH
103591: LD_INT 1
103593: ST_TO_ADDR
// continue ;
103594: GO 100969
// end ; end else
103596: GO 103622
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103598: LD_VAR 0 4
103602: PUSH
103603: LD_VAR 0 7
103607: ARRAY
103608: PPUSH
103609: LD_VAR 0 14
103613: PUSH
103614: LD_INT 1
103616: ARRAY
103617: PPUSH
103618: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103622: LD_VAR 0 4
103626: PUSH
103627: LD_VAR 0 7
103631: ARRAY
103632: PPUSH
103633: CALL_OW 265
103637: PUSH
103638: LD_INT 11
103640: EQUAL
103641: IFFALSE 103919
// begin k := 10 ;
103643: LD_ADDR_VAR 0 9
103647: PUSH
103648: LD_INT 10
103650: ST_TO_ADDR
// x := 0 ;
103651: LD_ADDR_VAR 0 10
103655: PUSH
103656: LD_INT 0
103658: ST_TO_ADDR
// if tmp < k then
103659: LD_VAR 0 14
103663: PUSH
103664: LD_VAR 0 9
103668: LESS
103669: IFFALSE 103681
// k := tmp ;
103671: LD_ADDR_VAR 0 9
103675: PUSH
103676: LD_VAR 0 14
103680: ST_TO_ADDR
// for j = k downto 1 do
103681: LD_ADDR_VAR 0 8
103685: PUSH
103686: DOUBLE
103687: LD_VAR 0 9
103691: INC
103692: ST_TO_ADDR
103693: LD_INT 1
103695: PUSH
103696: FOR_DOWNTO
103697: IFFALSE 103772
// begin if GetType ( tmp [ j ] ) = unit_human then
103699: LD_VAR 0 14
103703: PUSH
103704: LD_VAR 0 8
103708: ARRAY
103709: PPUSH
103710: CALL_OW 247
103714: PUSH
103715: LD_INT 1
103717: EQUAL
103718: IFFALSE 103770
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103720: LD_VAR 0 4
103724: PUSH
103725: LD_VAR 0 7
103729: ARRAY
103730: PPUSH
103731: LD_VAR 0 14
103735: PUSH
103736: LD_VAR 0 8
103740: ARRAY
103741: PPUSH
103742: CALL 99166 0 2
// x := tmp [ j ] ;
103746: LD_ADDR_VAR 0 10
103750: PUSH
103751: LD_VAR 0 14
103755: PUSH
103756: LD_VAR 0 8
103760: ARRAY
103761: ST_TO_ADDR
// attacking := true ;
103762: LD_ADDR_VAR 0 29
103766: PUSH
103767: LD_INT 1
103769: ST_TO_ADDR
// end ; end ;
103770: GO 103696
103772: POP
103773: POP
// if not x then
103774: LD_VAR 0 10
103778: NOT
103779: IFFALSE 103919
// begin attacking := true ;
103781: LD_ADDR_VAR 0 29
103785: PUSH
103786: LD_INT 1
103788: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103789: LD_VAR 0 4
103793: PUSH
103794: LD_VAR 0 7
103798: ARRAY
103799: PPUSH
103800: CALL_OW 250
103804: PPUSH
103805: LD_VAR 0 4
103809: PUSH
103810: LD_VAR 0 7
103814: ARRAY
103815: PPUSH
103816: CALL_OW 251
103820: PPUSH
103821: CALL_OW 546
103825: PUSH
103826: LD_INT 2
103828: ARRAY
103829: PUSH
103830: LD_VAR 0 14
103834: PUSH
103835: LD_INT 1
103837: ARRAY
103838: PPUSH
103839: CALL_OW 250
103843: PPUSH
103844: LD_VAR 0 14
103848: PUSH
103849: LD_INT 1
103851: ARRAY
103852: PPUSH
103853: CALL_OW 251
103857: PPUSH
103858: CALL_OW 546
103862: PUSH
103863: LD_INT 2
103865: ARRAY
103866: EQUAL
103867: IFFALSE 103895
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103869: LD_VAR 0 4
103873: PUSH
103874: LD_VAR 0 7
103878: ARRAY
103879: PPUSH
103880: LD_VAR 0 14
103884: PUSH
103885: LD_INT 1
103887: ARRAY
103888: PPUSH
103889: CALL 99166 0 2
103893: GO 103919
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103895: LD_VAR 0 4
103899: PUSH
103900: LD_VAR 0 7
103904: ARRAY
103905: PPUSH
103906: LD_VAR 0 14
103910: PUSH
103911: LD_INT 1
103913: ARRAY
103914: PPUSH
103915: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103919: LD_VAR 0 4
103923: PUSH
103924: LD_VAR 0 7
103928: ARRAY
103929: PPUSH
103930: CALL_OW 264
103934: PUSH
103935: LD_INT 29
103937: EQUAL
103938: IFFALSE 104304
// begin if WantsToAttack ( group [ i ] ) in bombed then
103940: LD_VAR 0 4
103944: PUSH
103945: LD_VAR 0 7
103949: ARRAY
103950: PPUSH
103951: CALL_OW 319
103955: PUSH
103956: LD_VAR 0 28
103960: IN
103961: IFFALSE 103965
// continue ;
103963: GO 100969
// k := 8 ;
103965: LD_ADDR_VAR 0 9
103969: PUSH
103970: LD_INT 8
103972: ST_TO_ADDR
// x := 0 ;
103973: LD_ADDR_VAR 0 10
103977: PUSH
103978: LD_INT 0
103980: ST_TO_ADDR
// if tmp < k then
103981: LD_VAR 0 14
103985: PUSH
103986: LD_VAR 0 9
103990: LESS
103991: IFFALSE 104003
// k := tmp ;
103993: LD_ADDR_VAR 0 9
103997: PUSH
103998: LD_VAR 0 14
104002: ST_TO_ADDR
// for j = 1 to k do
104003: LD_ADDR_VAR 0 8
104007: PUSH
104008: DOUBLE
104009: LD_INT 1
104011: DEC
104012: ST_TO_ADDR
104013: LD_VAR 0 9
104017: PUSH
104018: FOR_TO
104019: IFFALSE 104151
// begin if GetType ( tmp [ j ] ) = unit_building then
104021: LD_VAR 0 14
104025: PUSH
104026: LD_VAR 0 8
104030: ARRAY
104031: PPUSH
104032: CALL_OW 247
104036: PUSH
104037: LD_INT 3
104039: EQUAL
104040: IFFALSE 104149
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104042: LD_VAR 0 14
104046: PUSH
104047: LD_VAR 0 8
104051: ARRAY
104052: PUSH
104053: LD_VAR 0 28
104057: IN
104058: NOT
104059: PUSH
104060: LD_VAR 0 14
104064: PUSH
104065: LD_VAR 0 8
104069: ARRAY
104070: PPUSH
104071: CALL_OW 313
104075: AND
104076: IFFALSE 104149
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104078: LD_VAR 0 4
104082: PUSH
104083: LD_VAR 0 7
104087: ARRAY
104088: PPUSH
104089: LD_VAR 0 14
104093: PUSH
104094: LD_VAR 0 8
104098: ARRAY
104099: PPUSH
104100: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104104: LD_ADDR_VAR 0 28
104108: PUSH
104109: LD_VAR 0 28
104113: PPUSH
104114: LD_VAR 0 28
104118: PUSH
104119: LD_INT 1
104121: PLUS
104122: PPUSH
104123: LD_VAR 0 14
104127: PUSH
104128: LD_VAR 0 8
104132: ARRAY
104133: PPUSH
104134: CALL_OW 1
104138: ST_TO_ADDR
// attacking := true ;
104139: LD_ADDR_VAR 0 29
104143: PUSH
104144: LD_INT 1
104146: ST_TO_ADDR
// break ;
104147: GO 104151
// end ; end ;
104149: GO 104018
104151: POP
104152: POP
// if not attacking and f_attack_depot then
104153: LD_VAR 0 29
104157: NOT
104158: PUSH
104159: LD_VAR 0 25
104163: AND
104164: IFFALSE 104259
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104166: LD_ADDR_VAR 0 13
104170: PUSH
104171: LD_VAR 0 14
104175: PPUSH
104176: LD_INT 2
104178: PUSH
104179: LD_INT 30
104181: PUSH
104182: LD_INT 0
104184: PUSH
104185: EMPTY
104186: LIST
104187: LIST
104188: PUSH
104189: LD_INT 30
104191: PUSH
104192: LD_INT 1
104194: PUSH
104195: EMPTY
104196: LIST
104197: LIST
104198: PUSH
104199: EMPTY
104200: LIST
104201: LIST
104202: LIST
104203: PPUSH
104204: CALL_OW 72
104208: ST_TO_ADDR
// if z then
104209: LD_VAR 0 13
104213: IFFALSE 104259
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104215: LD_VAR 0 4
104219: PUSH
104220: LD_VAR 0 7
104224: ARRAY
104225: PPUSH
104226: LD_VAR 0 13
104230: PPUSH
104231: LD_VAR 0 4
104235: PUSH
104236: LD_VAR 0 7
104240: ARRAY
104241: PPUSH
104242: CALL_OW 74
104246: PPUSH
104247: CALL_OW 115
// attacking := true ;
104251: LD_ADDR_VAR 0 29
104255: PUSH
104256: LD_INT 1
104258: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104259: LD_VAR 0 4
104263: PUSH
104264: LD_VAR 0 7
104268: ARRAY
104269: PPUSH
104270: CALL_OW 256
104274: PUSH
104275: LD_INT 500
104277: LESS
104278: IFFALSE 104304
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104280: LD_VAR 0 4
104284: PUSH
104285: LD_VAR 0 7
104289: ARRAY
104290: PPUSH
104291: LD_VAR 0 14
104295: PUSH
104296: LD_INT 1
104298: ARRAY
104299: PPUSH
104300: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104304: LD_VAR 0 4
104308: PUSH
104309: LD_VAR 0 7
104313: ARRAY
104314: PPUSH
104315: CALL_OW 264
104319: PUSH
104320: LD_INT 49
104322: EQUAL
104323: IFFALSE 104444
// begin if not HasTask ( group [ i ] ) then
104325: LD_VAR 0 4
104329: PUSH
104330: LD_VAR 0 7
104334: ARRAY
104335: PPUSH
104336: CALL_OW 314
104340: NOT
104341: IFFALSE 104444
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104343: LD_ADDR_VAR 0 9
104347: PUSH
104348: LD_INT 81
104350: PUSH
104351: LD_VAR 0 4
104355: PUSH
104356: LD_VAR 0 7
104360: ARRAY
104361: PPUSH
104362: CALL_OW 255
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: PPUSH
104371: CALL_OW 69
104375: PPUSH
104376: LD_VAR 0 4
104380: PUSH
104381: LD_VAR 0 7
104385: ARRAY
104386: PPUSH
104387: CALL_OW 74
104391: ST_TO_ADDR
// if k then
104392: LD_VAR 0 9
104396: IFFALSE 104444
// if GetDistUnits ( group [ i ] , k ) > 10 then
104398: LD_VAR 0 4
104402: PUSH
104403: LD_VAR 0 7
104407: ARRAY
104408: PPUSH
104409: LD_VAR 0 9
104413: PPUSH
104414: CALL_OW 296
104418: PUSH
104419: LD_INT 10
104421: GREATER
104422: IFFALSE 104444
// ComMoveUnit ( group [ i ] , k ) ;
104424: LD_VAR 0 4
104428: PUSH
104429: LD_VAR 0 7
104433: ARRAY
104434: PPUSH
104435: LD_VAR 0 9
104439: PPUSH
104440: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104444: LD_VAR 0 4
104448: PUSH
104449: LD_VAR 0 7
104453: ARRAY
104454: PPUSH
104455: CALL_OW 256
104459: PUSH
104460: LD_INT 250
104462: LESS
104463: PUSH
104464: LD_VAR 0 4
104468: PUSH
104469: LD_VAR 0 7
104473: ARRAY
104474: PUSH
104475: LD_INT 21
104477: PUSH
104478: LD_INT 2
104480: PUSH
104481: EMPTY
104482: LIST
104483: LIST
104484: PUSH
104485: LD_INT 23
104487: PUSH
104488: LD_INT 2
104490: PUSH
104491: EMPTY
104492: LIST
104493: LIST
104494: PUSH
104495: EMPTY
104496: LIST
104497: LIST
104498: PPUSH
104499: CALL_OW 69
104503: IN
104504: AND
104505: IFFALSE 104630
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104507: LD_ADDR_VAR 0 9
104511: PUSH
104512: LD_OWVAR 3
104516: PUSH
104517: LD_VAR 0 4
104521: PUSH
104522: LD_VAR 0 7
104526: ARRAY
104527: DIFF
104528: PPUSH
104529: LD_VAR 0 4
104533: PUSH
104534: LD_VAR 0 7
104538: ARRAY
104539: PPUSH
104540: CALL_OW 74
104544: ST_TO_ADDR
// if not k then
104545: LD_VAR 0 9
104549: NOT
104550: IFFALSE 104554
// continue ;
104552: GO 100969
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104554: LD_VAR 0 9
104558: PUSH
104559: LD_INT 81
104561: PUSH
104562: LD_VAR 0 4
104566: PUSH
104567: LD_VAR 0 7
104571: ARRAY
104572: PPUSH
104573: CALL_OW 255
104577: PUSH
104578: EMPTY
104579: LIST
104580: LIST
104581: PPUSH
104582: CALL_OW 69
104586: IN
104587: PUSH
104588: LD_VAR 0 9
104592: PPUSH
104593: LD_VAR 0 4
104597: PUSH
104598: LD_VAR 0 7
104602: ARRAY
104603: PPUSH
104604: CALL_OW 296
104608: PUSH
104609: LD_INT 5
104611: LESS
104612: AND
104613: IFFALSE 104630
// ComAutodestruct ( group [ i ] ) ;
104615: LD_VAR 0 4
104619: PUSH
104620: LD_VAR 0 7
104624: ARRAY
104625: PPUSH
104626: CALL 99064 0 1
// end ; if f_attack_depot then
104630: LD_VAR 0 25
104634: IFFALSE 104746
// begin k := 6 ;
104636: LD_ADDR_VAR 0 9
104640: PUSH
104641: LD_INT 6
104643: ST_TO_ADDR
// if tmp < k then
104644: LD_VAR 0 14
104648: PUSH
104649: LD_VAR 0 9
104653: LESS
104654: IFFALSE 104666
// k := tmp ;
104656: LD_ADDR_VAR 0 9
104660: PUSH
104661: LD_VAR 0 14
104665: ST_TO_ADDR
// for j = 1 to k do
104666: LD_ADDR_VAR 0 8
104670: PUSH
104671: DOUBLE
104672: LD_INT 1
104674: DEC
104675: ST_TO_ADDR
104676: LD_VAR 0 9
104680: PUSH
104681: FOR_TO
104682: IFFALSE 104744
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104684: LD_VAR 0 8
104688: PPUSH
104689: CALL_OW 266
104693: PUSH
104694: LD_INT 0
104696: PUSH
104697: LD_INT 1
104699: PUSH
104700: EMPTY
104701: LIST
104702: LIST
104703: IN
104704: IFFALSE 104742
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104706: LD_VAR 0 4
104710: PUSH
104711: LD_VAR 0 7
104715: ARRAY
104716: PPUSH
104717: LD_VAR 0 14
104721: PUSH
104722: LD_VAR 0 8
104726: ARRAY
104727: PPUSH
104728: CALL_OW 115
// attacking := true ;
104732: LD_ADDR_VAR 0 29
104736: PUSH
104737: LD_INT 1
104739: ST_TO_ADDR
// break ;
104740: GO 104744
// end ;
104742: GO 104681
104744: POP
104745: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104746: LD_VAR 0 4
104750: PUSH
104751: LD_VAR 0 7
104755: ARRAY
104756: PPUSH
104757: CALL_OW 302
104761: PUSH
104762: LD_VAR 0 29
104766: NOT
104767: AND
104768: IFFALSE 105090
// begin if GetTag ( group [ i ] ) = 71 then
104770: LD_VAR 0 4
104774: PUSH
104775: LD_VAR 0 7
104779: ARRAY
104780: PPUSH
104781: CALL_OW 110
104785: PUSH
104786: LD_INT 71
104788: EQUAL
104789: IFFALSE 104830
// begin if HasTask ( group [ i ] ) then
104791: LD_VAR 0 4
104795: PUSH
104796: LD_VAR 0 7
104800: ARRAY
104801: PPUSH
104802: CALL_OW 314
104806: IFFALSE 104812
// continue else
104808: GO 100969
104810: GO 104830
// SetTag ( group [ i ] , 0 ) ;
104812: LD_VAR 0 4
104816: PUSH
104817: LD_VAR 0 7
104821: ARRAY
104822: PPUSH
104823: LD_INT 0
104825: PPUSH
104826: CALL_OW 109
// end ; k := 8 ;
104830: LD_ADDR_VAR 0 9
104834: PUSH
104835: LD_INT 8
104837: ST_TO_ADDR
// x := 0 ;
104838: LD_ADDR_VAR 0 10
104842: PUSH
104843: LD_INT 0
104845: ST_TO_ADDR
// if tmp < k then
104846: LD_VAR 0 14
104850: PUSH
104851: LD_VAR 0 9
104855: LESS
104856: IFFALSE 104868
// k := tmp ;
104858: LD_ADDR_VAR 0 9
104862: PUSH
104863: LD_VAR 0 14
104867: ST_TO_ADDR
// for j = 1 to k do
104868: LD_ADDR_VAR 0 8
104872: PUSH
104873: DOUBLE
104874: LD_INT 1
104876: DEC
104877: ST_TO_ADDR
104878: LD_VAR 0 9
104882: PUSH
104883: FOR_TO
104884: IFFALSE 104982
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104886: LD_VAR 0 14
104890: PUSH
104891: LD_VAR 0 8
104895: ARRAY
104896: PPUSH
104897: CALL_OW 247
104901: PUSH
104902: LD_INT 1
104904: EQUAL
104905: PUSH
104906: LD_VAR 0 14
104910: PUSH
104911: LD_VAR 0 8
104915: ARRAY
104916: PPUSH
104917: CALL_OW 256
104921: PUSH
104922: LD_INT 250
104924: LESS
104925: PUSH
104926: LD_VAR 0 20
104930: AND
104931: PUSH
104932: LD_VAR 0 20
104936: NOT
104937: PUSH
104938: LD_VAR 0 14
104942: PUSH
104943: LD_VAR 0 8
104947: ARRAY
104948: PPUSH
104949: CALL_OW 256
104953: PUSH
104954: LD_INT 250
104956: GREATEREQUAL
104957: AND
104958: OR
104959: AND
104960: IFFALSE 104980
// begin x := tmp [ j ] ;
104962: LD_ADDR_VAR 0 10
104966: PUSH
104967: LD_VAR 0 14
104971: PUSH
104972: LD_VAR 0 8
104976: ARRAY
104977: ST_TO_ADDR
// break ;
104978: GO 104982
// end ;
104980: GO 104883
104982: POP
104983: POP
// if x then
104984: LD_VAR 0 10
104988: IFFALSE 105012
// ComAttackUnit ( group [ i ] , x ) else
104990: LD_VAR 0 4
104994: PUSH
104995: LD_VAR 0 7
104999: ARRAY
105000: PPUSH
105001: LD_VAR 0 10
105005: PPUSH
105006: CALL_OW 115
105010: GO 105036
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105012: LD_VAR 0 4
105016: PUSH
105017: LD_VAR 0 7
105021: ARRAY
105022: PPUSH
105023: LD_VAR 0 14
105027: PUSH
105028: LD_INT 1
105030: ARRAY
105031: PPUSH
105032: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105036: LD_VAR 0 4
105040: PUSH
105041: LD_VAR 0 7
105045: ARRAY
105046: PPUSH
105047: CALL_OW 314
105051: NOT
105052: IFFALSE 105090
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105054: LD_VAR 0 4
105058: PUSH
105059: LD_VAR 0 7
105063: ARRAY
105064: PPUSH
105065: LD_VAR 0 14
105069: PPUSH
105070: LD_VAR 0 4
105074: PUSH
105075: LD_VAR 0 7
105079: ARRAY
105080: PPUSH
105081: CALL_OW 74
105085: PPUSH
105086: CALL_OW 115
// end ; end ; end ;
105090: GO 100969
105092: POP
105093: POP
// wait ( 0 0$1 ) ;
105094: LD_INT 35
105096: PPUSH
105097: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105101: LD_VAR 0 4
105105: PUSH
105106: EMPTY
105107: EQUAL
105108: PUSH
105109: LD_INT 81
105111: PUSH
105112: LD_VAR 0 35
105116: PUSH
105117: EMPTY
105118: LIST
105119: LIST
105120: PPUSH
105121: CALL_OW 69
105125: NOT
105126: OR
105127: IFFALSE 100954
// end ;
105129: LD_VAR 0 2
105133: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105134: LD_INT 0
105136: PPUSH
105137: PPUSH
105138: PPUSH
105139: PPUSH
// if not base_units then
105140: LD_VAR 0 1
105144: NOT
105145: IFFALSE 105149
// exit ;
105147: GO 105236
// result := false ;
105149: LD_ADDR_VAR 0 2
105153: PUSH
105154: LD_INT 0
105156: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105157: LD_ADDR_VAR 0 5
105161: PUSH
105162: LD_VAR 0 1
105166: PPUSH
105167: LD_INT 21
105169: PUSH
105170: LD_INT 3
105172: PUSH
105173: EMPTY
105174: LIST
105175: LIST
105176: PPUSH
105177: CALL_OW 72
105181: ST_TO_ADDR
// if not tmp then
105182: LD_VAR 0 5
105186: NOT
105187: IFFALSE 105191
// exit ;
105189: GO 105236
// for i in tmp do
105191: LD_ADDR_VAR 0 3
105195: PUSH
105196: LD_VAR 0 5
105200: PUSH
105201: FOR_IN
105202: IFFALSE 105234
// begin result := EnemyInRange ( i , 22 ) ;
105204: LD_ADDR_VAR 0 2
105208: PUSH
105209: LD_VAR 0 3
105213: PPUSH
105214: LD_INT 22
105216: PPUSH
105217: CALL 98770 0 2
105221: ST_TO_ADDR
// if result then
105222: LD_VAR 0 2
105226: IFFALSE 105232
// exit ;
105228: POP
105229: POP
105230: GO 105236
// end ;
105232: GO 105201
105234: POP
105235: POP
// end ;
105236: LD_VAR 0 2
105240: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105241: LD_INT 0
105243: PPUSH
105244: PPUSH
// if not units then
105245: LD_VAR 0 1
105249: NOT
105250: IFFALSE 105254
// exit ;
105252: GO 105324
// result := [ ] ;
105254: LD_ADDR_VAR 0 3
105258: PUSH
105259: EMPTY
105260: ST_TO_ADDR
// for i in units do
105261: LD_ADDR_VAR 0 4
105265: PUSH
105266: LD_VAR 0 1
105270: PUSH
105271: FOR_IN
105272: IFFALSE 105322
// if GetTag ( i ) = tag then
105274: LD_VAR 0 4
105278: PPUSH
105279: CALL_OW 110
105283: PUSH
105284: LD_VAR 0 2
105288: EQUAL
105289: IFFALSE 105320
// result := Insert ( result , result + 1 , i ) ;
105291: LD_ADDR_VAR 0 3
105295: PUSH
105296: LD_VAR 0 3
105300: PPUSH
105301: LD_VAR 0 3
105305: PUSH
105306: LD_INT 1
105308: PLUS
105309: PPUSH
105310: LD_VAR 0 4
105314: PPUSH
105315: CALL_OW 2
105319: ST_TO_ADDR
105320: GO 105271
105322: POP
105323: POP
// end ;
105324: LD_VAR 0 3
105328: RET
// export function IsDriver ( un ) ; begin
105329: LD_INT 0
105331: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105332: LD_ADDR_VAR 0 2
105336: PUSH
105337: LD_VAR 0 1
105341: PUSH
105342: LD_INT 55
105344: PUSH
105345: EMPTY
105346: LIST
105347: PPUSH
105348: CALL_OW 69
105352: IN
105353: ST_TO_ADDR
// end ;
105354: LD_VAR 0 2
105358: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105359: LD_INT 0
105361: PPUSH
105362: PPUSH
// list := [ ] ;
105363: LD_ADDR_VAR 0 5
105367: PUSH
105368: EMPTY
105369: ST_TO_ADDR
// case d of 0 :
105370: LD_VAR 0 3
105374: PUSH
105375: LD_INT 0
105377: DOUBLE
105378: EQUAL
105379: IFTRUE 105383
105381: GO 105516
105383: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105384: LD_ADDR_VAR 0 5
105388: PUSH
105389: LD_VAR 0 1
105393: PUSH
105394: LD_INT 4
105396: MINUS
105397: PUSH
105398: LD_VAR 0 2
105402: PUSH
105403: LD_INT 4
105405: MINUS
105406: PUSH
105407: LD_INT 2
105409: PUSH
105410: EMPTY
105411: LIST
105412: LIST
105413: LIST
105414: PUSH
105415: LD_VAR 0 1
105419: PUSH
105420: LD_INT 3
105422: MINUS
105423: PUSH
105424: LD_VAR 0 2
105428: PUSH
105429: LD_INT 1
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: LIST
105436: PUSH
105437: LD_VAR 0 1
105441: PUSH
105442: LD_INT 4
105444: PLUS
105445: PUSH
105446: LD_VAR 0 2
105450: PUSH
105451: LD_INT 4
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: LIST
105458: PUSH
105459: LD_VAR 0 1
105463: PUSH
105464: LD_INT 3
105466: PLUS
105467: PUSH
105468: LD_VAR 0 2
105472: PUSH
105473: LD_INT 3
105475: PLUS
105476: PUSH
105477: LD_INT 5
105479: PUSH
105480: EMPTY
105481: LIST
105482: LIST
105483: LIST
105484: PUSH
105485: LD_VAR 0 1
105489: PUSH
105490: LD_VAR 0 2
105494: PUSH
105495: LD_INT 4
105497: PLUS
105498: PUSH
105499: LD_INT 0
105501: PUSH
105502: EMPTY
105503: LIST
105504: LIST
105505: LIST
105506: PUSH
105507: EMPTY
105508: LIST
105509: LIST
105510: LIST
105511: LIST
105512: LIST
105513: ST_TO_ADDR
// end ; 1 :
105514: GO 106214
105516: LD_INT 1
105518: DOUBLE
105519: EQUAL
105520: IFTRUE 105524
105522: GO 105657
105524: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105525: LD_ADDR_VAR 0 5
105529: PUSH
105530: LD_VAR 0 1
105534: PUSH
105535: LD_VAR 0 2
105539: PUSH
105540: LD_INT 4
105542: MINUS
105543: PUSH
105544: LD_INT 3
105546: PUSH
105547: EMPTY
105548: LIST
105549: LIST
105550: LIST
105551: PUSH
105552: LD_VAR 0 1
105556: PUSH
105557: LD_INT 3
105559: MINUS
105560: PUSH
105561: LD_VAR 0 2
105565: PUSH
105566: LD_INT 3
105568: MINUS
105569: PUSH
105570: LD_INT 2
105572: PUSH
105573: EMPTY
105574: LIST
105575: LIST
105576: LIST
105577: PUSH
105578: LD_VAR 0 1
105582: PUSH
105583: LD_INT 4
105585: MINUS
105586: PUSH
105587: LD_VAR 0 2
105591: PUSH
105592: LD_INT 1
105594: PUSH
105595: EMPTY
105596: LIST
105597: LIST
105598: LIST
105599: PUSH
105600: LD_VAR 0 1
105604: PUSH
105605: LD_VAR 0 2
105609: PUSH
105610: LD_INT 3
105612: PLUS
105613: PUSH
105614: LD_INT 0
105616: PUSH
105617: EMPTY
105618: LIST
105619: LIST
105620: LIST
105621: PUSH
105622: LD_VAR 0 1
105626: PUSH
105627: LD_INT 4
105629: PLUS
105630: PUSH
105631: LD_VAR 0 2
105635: PUSH
105636: LD_INT 4
105638: PLUS
105639: PUSH
105640: LD_INT 5
105642: PUSH
105643: EMPTY
105644: LIST
105645: LIST
105646: LIST
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: LIST
105653: LIST
105654: ST_TO_ADDR
// end ; 2 :
105655: GO 106214
105657: LD_INT 2
105659: DOUBLE
105660: EQUAL
105661: IFTRUE 105665
105663: GO 105794
105665: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105666: LD_ADDR_VAR 0 5
105670: PUSH
105671: LD_VAR 0 1
105675: PUSH
105676: LD_VAR 0 2
105680: PUSH
105681: LD_INT 3
105683: MINUS
105684: PUSH
105685: LD_INT 3
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: LIST
105692: PUSH
105693: LD_VAR 0 1
105697: PUSH
105698: LD_INT 4
105700: PLUS
105701: PUSH
105702: LD_VAR 0 2
105706: PUSH
105707: LD_INT 4
105709: PUSH
105710: EMPTY
105711: LIST
105712: LIST
105713: LIST
105714: PUSH
105715: LD_VAR 0 1
105719: PUSH
105720: LD_VAR 0 2
105724: PUSH
105725: LD_INT 4
105727: PLUS
105728: PUSH
105729: LD_INT 0
105731: PUSH
105732: EMPTY
105733: LIST
105734: LIST
105735: LIST
105736: PUSH
105737: LD_VAR 0 1
105741: PUSH
105742: LD_INT 3
105744: MINUS
105745: PUSH
105746: LD_VAR 0 2
105750: PUSH
105751: LD_INT 1
105753: PUSH
105754: EMPTY
105755: LIST
105756: LIST
105757: LIST
105758: PUSH
105759: LD_VAR 0 1
105763: PUSH
105764: LD_INT 4
105766: MINUS
105767: PUSH
105768: LD_VAR 0 2
105772: PUSH
105773: LD_INT 4
105775: MINUS
105776: PUSH
105777: LD_INT 2
105779: PUSH
105780: EMPTY
105781: LIST
105782: LIST
105783: LIST
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: LIST
105789: LIST
105790: LIST
105791: ST_TO_ADDR
// end ; 3 :
105792: GO 106214
105794: LD_INT 3
105796: DOUBLE
105797: EQUAL
105798: IFTRUE 105802
105800: GO 105935
105802: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105803: LD_ADDR_VAR 0 5
105807: PUSH
105808: LD_VAR 0 1
105812: PUSH
105813: LD_INT 3
105815: PLUS
105816: PUSH
105817: LD_VAR 0 2
105821: PUSH
105822: LD_INT 4
105824: PUSH
105825: EMPTY
105826: LIST
105827: LIST
105828: LIST
105829: PUSH
105830: LD_VAR 0 1
105834: PUSH
105835: LD_INT 4
105837: PLUS
105838: PUSH
105839: LD_VAR 0 2
105843: PUSH
105844: LD_INT 4
105846: PLUS
105847: PUSH
105848: LD_INT 5
105850: PUSH
105851: EMPTY
105852: LIST
105853: LIST
105854: LIST
105855: PUSH
105856: LD_VAR 0 1
105860: PUSH
105861: LD_INT 4
105863: MINUS
105864: PUSH
105865: LD_VAR 0 2
105869: PUSH
105870: LD_INT 1
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: LIST
105877: PUSH
105878: LD_VAR 0 1
105882: PUSH
105883: LD_VAR 0 2
105887: PUSH
105888: LD_INT 4
105890: MINUS
105891: PUSH
105892: LD_INT 3
105894: PUSH
105895: EMPTY
105896: LIST
105897: LIST
105898: LIST
105899: PUSH
105900: LD_VAR 0 1
105904: PUSH
105905: LD_INT 3
105907: MINUS
105908: PUSH
105909: LD_VAR 0 2
105913: PUSH
105914: LD_INT 3
105916: MINUS
105917: PUSH
105918: LD_INT 2
105920: PUSH
105921: EMPTY
105922: LIST
105923: LIST
105924: LIST
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: LIST
105930: LIST
105931: LIST
105932: ST_TO_ADDR
// end ; 4 :
105933: GO 106214
105935: LD_INT 4
105937: DOUBLE
105938: EQUAL
105939: IFTRUE 105943
105941: GO 106076
105943: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105944: LD_ADDR_VAR 0 5
105948: PUSH
105949: LD_VAR 0 1
105953: PUSH
105954: LD_VAR 0 2
105958: PUSH
105959: LD_INT 4
105961: PLUS
105962: PUSH
105963: LD_INT 0
105965: PUSH
105966: EMPTY
105967: LIST
105968: LIST
105969: LIST
105970: PUSH
105971: LD_VAR 0 1
105975: PUSH
105976: LD_INT 3
105978: PLUS
105979: PUSH
105980: LD_VAR 0 2
105984: PUSH
105985: LD_INT 3
105987: PLUS
105988: PUSH
105989: LD_INT 5
105991: PUSH
105992: EMPTY
105993: LIST
105994: LIST
105995: LIST
105996: PUSH
105997: LD_VAR 0 1
106001: PUSH
106002: LD_INT 4
106004: PLUS
106005: PUSH
106006: LD_VAR 0 2
106010: PUSH
106011: LD_INT 4
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: LIST
106018: PUSH
106019: LD_VAR 0 1
106023: PUSH
106024: LD_VAR 0 2
106028: PUSH
106029: LD_INT 3
106031: MINUS
106032: PUSH
106033: LD_INT 3
106035: PUSH
106036: EMPTY
106037: LIST
106038: LIST
106039: LIST
106040: PUSH
106041: LD_VAR 0 1
106045: PUSH
106046: LD_INT 4
106048: MINUS
106049: PUSH
106050: LD_VAR 0 2
106054: PUSH
106055: LD_INT 4
106057: MINUS
106058: PUSH
106059: LD_INT 2
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: LIST
106066: PUSH
106067: EMPTY
106068: LIST
106069: LIST
106070: LIST
106071: LIST
106072: LIST
106073: ST_TO_ADDR
// end ; 5 :
106074: GO 106214
106076: LD_INT 5
106078: DOUBLE
106079: EQUAL
106080: IFTRUE 106084
106082: GO 106213
106084: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106085: LD_ADDR_VAR 0 5
106089: PUSH
106090: LD_VAR 0 1
106094: PUSH
106095: LD_INT 4
106097: MINUS
106098: PUSH
106099: LD_VAR 0 2
106103: PUSH
106104: LD_INT 1
106106: PUSH
106107: EMPTY
106108: LIST
106109: LIST
106110: LIST
106111: PUSH
106112: LD_VAR 0 1
106116: PUSH
106117: LD_VAR 0 2
106121: PUSH
106122: LD_INT 4
106124: MINUS
106125: PUSH
106126: LD_INT 3
106128: PUSH
106129: EMPTY
106130: LIST
106131: LIST
106132: LIST
106133: PUSH
106134: LD_VAR 0 1
106138: PUSH
106139: LD_INT 4
106141: PLUS
106142: PUSH
106143: LD_VAR 0 2
106147: PUSH
106148: LD_INT 4
106150: PLUS
106151: PUSH
106152: LD_INT 5
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: LIST
106159: PUSH
106160: LD_VAR 0 1
106164: PUSH
106165: LD_INT 3
106167: PLUS
106168: PUSH
106169: LD_VAR 0 2
106173: PUSH
106174: LD_INT 4
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: LIST
106181: PUSH
106182: LD_VAR 0 1
106186: PUSH
106187: LD_VAR 0 2
106191: PUSH
106192: LD_INT 3
106194: PLUS
106195: PUSH
106196: LD_INT 0
106198: PUSH
106199: EMPTY
106200: LIST
106201: LIST
106202: LIST
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: LIST
106208: LIST
106209: LIST
106210: ST_TO_ADDR
// end ; end ;
106211: GO 106214
106213: POP
// result := list ;
106214: LD_ADDR_VAR 0 4
106218: PUSH
106219: LD_VAR 0 5
106223: ST_TO_ADDR
// end ;
106224: LD_VAR 0 4
106228: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106229: LD_INT 0
106231: PPUSH
106232: PPUSH
106233: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106234: LD_VAR 0 1
106238: NOT
106239: PUSH
106240: LD_VAR 0 2
106244: PUSH
106245: LD_INT 1
106247: PUSH
106248: LD_INT 2
106250: PUSH
106251: LD_INT 3
106253: PUSH
106254: LD_INT 4
106256: PUSH
106257: EMPTY
106258: LIST
106259: LIST
106260: LIST
106261: LIST
106262: IN
106263: NOT
106264: OR
106265: IFFALSE 106269
// exit ;
106267: GO 106361
// tmp := [ ] ;
106269: LD_ADDR_VAR 0 5
106273: PUSH
106274: EMPTY
106275: ST_TO_ADDR
// for i in units do
106276: LD_ADDR_VAR 0 4
106280: PUSH
106281: LD_VAR 0 1
106285: PUSH
106286: FOR_IN
106287: IFFALSE 106330
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106289: LD_ADDR_VAR 0 5
106293: PUSH
106294: LD_VAR 0 5
106298: PPUSH
106299: LD_VAR 0 5
106303: PUSH
106304: LD_INT 1
106306: PLUS
106307: PPUSH
106308: LD_VAR 0 4
106312: PPUSH
106313: LD_VAR 0 2
106317: PPUSH
106318: CALL_OW 259
106322: PPUSH
106323: CALL_OW 2
106327: ST_TO_ADDR
106328: GO 106286
106330: POP
106331: POP
// if not tmp then
106332: LD_VAR 0 5
106336: NOT
106337: IFFALSE 106341
// exit ;
106339: GO 106361
// result := SortListByListDesc ( units , tmp ) ;
106341: LD_ADDR_VAR 0 3
106345: PUSH
106346: LD_VAR 0 1
106350: PPUSH
106351: LD_VAR 0 5
106355: PPUSH
106356: CALL_OW 77
106360: ST_TO_ADDR
// end ;
106361: LD_VAR 0 3
106365: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106366: LD_INT 0
106368: PPUSH
106369: PPUSH
106370: PPUSH
// x := GetX ( building ) ;
106371: LD_ADDR_VAR 0 4
106375: PUSH
106376: LD_VAR 0 2
106380: PPUSH
106381: CALL_OW 250
106385: ST_TO_ADDR
// y := GetY ( building ) ;
106386: LD_ADDR_VAR 0 5
106390: PUSH
106391: LD_VAR 0 2
106395: PPUSH
106396: CALL_OW 251
106400: ST_TO_ADDR
// if GetTaskList ( unit ) then
106401: LD_VAR 0 1
106405: PPUSH
106406: CALL_OW 437
106410: IFFALSE 106505
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106412: LD_STRING e
106414: PUSH
106415: LD_VAR 0 1
106419: PPUSH
106420: CALL_OW 437
106424: PUSH
106425: LD_INT 1
106427: ARRAY
106428: PUSH
106429: LD_INT 1
106431: ARRAY
106432: EQUAL
106433: PUSH
106434: LD_VAR 0 4
106438: PUSH
106439: LD_VAR 0 1
106443: PPUSH
106444: CALL_OW 437
106448: PUSH
106449: LD_INT 1
106451: ARRAY
106452: PUSH
106453: LD_INT 2
106455: ARRAY
106456: EQUAL
106457: AND
106458: PUSH
106459: LD_VAR 0 5
106463: PUSH
106464: LD_VAR 0 1
106468: PPUSH
106469: CALL_OW 437
106473: PUSH
106474: LD_INT 1
106476: ARRAY
106477: PUSH
106478: LD_INT 3
106480: ARRAY
106481: EQUAL
106482: AND
106483: IFFALSE 106495
// result := true else
106485: LD_ADDR_VAR 0 3
106489: PUSH
106490: LD_INT 1
106492: ST_TO_ADDR
106493: GO 106503
// result := false ;
106495: LD_ADDR_VAR 0 3
106499: PUSH
106500: LD_INT 0
106502: ST_TO_ADDR
// end else
106503: GO 106513
// result := false ;
106505: LD_ADDR_VAR 0 3
106509: PUSH
106510: LD_INT 0
106512: ST_TO_ADDR
// end ;
106513: LD_VAR 0 3
106517: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106518: LD_INT 0
106520: PPUSH
106521: PPUSH
106522: PPUSH
106523: PPUSH
// if not unit or not area then
106524: LD_VAR 0 1
106528: NOT
106529: PUSH
106530: LD_VAR 0 2
106534: NOT
106535: OR
106536: IFFALSE 106540
// exit ;
106538: GO 106704
// tmp := AreaToList ( area , i ) ;
106540: LD_ADDR_VAR 0 6
106544: PUSH
106545: LD_VAR 0 2
106549: PPUSH
106550: LD_VAR 0 5
106554: PPUSH
106555: CALL_OW 517
106559: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106560: LD_ADDR_VAR 0 5
106564: PUSH
106565: DOUBLE
106566: LD_INT 1
106568: DEC
106569: ST_TO_ADDR
106570: LD_VAR 0 6
106574: PUSH
106575: LD_INT 1
106577: ARRAY
106578: PUSH
106579: FOR_TO
106580: IFFALSE 106702
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106582: LD_ADDR_VAR 0 7
106586: PUSH
106587: LD_VAR 0 6
106591: PUSH
106592: LD_INT 1
106594: ARRAY
106595: PUSH
106596: LD_VAR 0 5
106600: ARRAY
106601: PUSH
106602: LD_VAR 0 6
106606: PUSH
106607: LD_INT 2
106609: ARRAY
106610: PUSH
106611: LD_VAR 0 5
106615: ARRAY
106616: PUSH
106617: EMPTY
106618: LIST
106619: LIST
106620: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106621: LD_VAR 0 7
106625: PUSH
106626: LD_INT 1
106628: ARRAY
106629: PPUSH
106630: LD_VAR 0 7
106634: PUSH
106635: LD_INT 2
106637: ARRAY
106638: PPUSH
106639: CALL_OW 428
106643: PUSH
106644: LD_INT 0
106646: EQUAL
106647: IFFALSE 106700
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106649: LD_VAR 0 1
106653: PPUSH
106654: LD_VAR 0 7
106658: PUSH
106659: LD_INT 1
106661: ARRAY
106662: PPUSH
106663: LD_VAR 0 7
106667: PUSH
106668: LD_INT 2
106670: ARRAY
106671: PPUSH
106672: LD_VAR 0 3
106676: PPUSH
106677: CALL_OW 48
// result := IsPlaced ( unit ) ;
106681: LD_ADDR_VAR 0 4
106685: PUSH
106686: LD_VAR 0 1
106690: PPUSH
106691: CALL_OW 305
106695: ST_TO_ADDR
// exit ;
106696: POP
106697: POP
106698: GO 106704
// end ; end ;
106700: GO 106579
106702: POP
106703: POP
// end ;
106704: LD_VAR 0 4
106708: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106709: LD_INT 0
106711: PPUSH
106712: PPUSH
106713: PPUSH
// if not side or side > 8 then
106714: LD_VAR 0 1
106718: NOT
106719: PUSH
106720: LD_VAR 0 1
106724: PUSH
106725: LD_INT 8
106727: GREATER
106728: OR
106729: IFFALSE 106733
// exit ;
106731: GO 106920
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106733: LD_ADDR_VAR 0 4
106737: PUSH
106738: LD_INT 22
106740: PUSH
106741: LD_VAR 0 1
106745: PUSH
106746: EMPTY
106747: LIST
106748: LIST
106749: PUSH
106750: LD_INT 21
106752: PUSH
106753: LD_INT 3
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: PUSH
106760: EMPTY
106761: LIST
106762: LIST
106763: PPUSH
106764: CALL_OW 69
106768: ST_TO_ADDR
// if not tmp then
106769: LD_VAR 0 4
106773: NOT
106774: IFFALSE 106778
// exit ;
106776: GO 106920
// enable_addtolog := true ;
106778: LD_ADDR_OWVAR 81
106782: PUSH
106783: LD_INT 1
106785: ST_TO_ADDR
// AddToLog ( [ ) ;
106786: LD_STRING [
106788: PPUSH
106789: CALL_OW 561
// for i in tmp do
106793: LD_ADDR_VAR 0 3
106797: PUSH
106798: LD_VAR 0 4
106802: PUSH
106803: FOR_IN
106804: IFFALSE 106911
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106806: LD_STRING [
106808: PUSH
106809: LD_VAR 0 3
106813: PPUSH
106814: CALL_OW 266
106818: STR
106819: PUSH
106820: LD_STRING , 
106822: STR
106823: PUSH
106824: LD_VAR 0 3
106828: PPUSH
106829: CALL_OW 250
106833: STR
106834: PUSH
106835: LD_STRING , 
106837: STR
106838: PUSH
106839: LD_VAR 0 3
106843: PPUSH
106844: CALL_OW 251
106848: STR
106849: PUSH
106850: LD_STRING , 
106852: STR
106853: PUSH
106854: LD_VAR 0 3
106858: PPUSH
106859: CALL_OW 254
106863: STR
106864: PUSH
106865: LD_STRING , 
106867: STR
106868: PUSH
106869: LD_VAR 0 3
106873: PPUSH
106874: LD_INT 1
106876: PPUSH
106877: CALL_OW 268
106881: STR
106882: PUSH
106883: LD_STRING , 
106885: STR
106886: PUSH
106887: LD_VAR 0 3
106891: PPUSH
106892: LD_INT 2
106894: PPUSH
106895: CALL_OW 268
106899: STR
106900: PUSH
106901: LD_STRING ],
106903: STR
106904: PPUSH
106905: CALL_OW 561
// end ;
106909: GO 106803
106911: POP
106912: POP
// AddToLog ( ]; ) ;
106913: LD_STRING ];
106915: PPUSH
106916: CALL_OW 561
// end ;
106920: LD_VAR 0 2
106924: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106925: LD_INT 0
106927: PPUSH
106928: PPUSH
106929: PPUSH
106930: PPUSH
106931: PPUSH
// if not area or not rate or not max then
106932: LD_VAR 0 1
106936: NOT
106937: PUSH
106938: LD_VAR 0 2
106942: NOT
106943: OR
106944: PUSH
106945: LD_VAR 0 4
106949: NOT
106950: OR
106951: IFFALSE 106955
// exit ;
106953: GO 107147
// while 1 do
106955: LD_INT 1
106957: IFFALSE 107147
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106959: LD_ADDR_VAR 0 9
106963: PUSH
106964: LD_VAR 0 1
106968: PPUSH
106969: LD_INT 1
106971: PPUSH
106972: CALL_OW 287
106976: PUSH
106977: LD_INT 10
106979: MUL
106980: ST_TO_ADDR
// r := rate / 10 ;
106981: LD_ADDR_VAR 0 7
106985: PUSH
106986: LD_VAR 0 2
106990: PUSH
106991: LD_INT 10
106993: DIVREAL
106994: ST_TO_ADDR
// time := 1 1$00 ;
106995: LD_ADDR_VAR 0 8
106999: PUSH
107000: LD_INT 2100
107002: ST_TO_ADDR
// if amount < min then
107003: LD_VAR 0 9
107007: PUSH
107008: LD_VAR 0 3
107012: LESS
107013: IFFALSE 107031
// r := r * 2 else
107015: LD_ADDR_VAR 0 7
107019: PUSH
107020: LD_VAR 0 7
107024: PUSH
107025: LD_INT 2
107027: MUL
107028: ST_TO_ADDR
107029: GO 107057
// if amount > max then
107031: LD_VAR 0 9
107035: PUSH
107036: LD_VAR 0 4
107040: GREATER
107041: IFFALSE 107057
// r := r / 2 ;
107043: LD_ADDR_VAR 0 7
107047: PUSH
107048: LD_VAR 0 7
107052: PUSH
107053: LD_INT 2
107055: DIVREAL
107056: ST_TO_ADDR
// time := time / r ;
107057: LD_ADDR_VAR 0 8
107061: PUSH
107062: LD_VAR 0 8
107066: PUSH
107067: LD_VAR 0 7
107071: DIVREAL
107072: ST_TO_ADDR
// if time < 0 then
107073: LD_VAR 0 8
107077: PUSH
107078: LD_INT 0
107080: LESS
107081: IFFALSE 107098
// time := time * - 1 ;
107083: LD_ADDR_VAR 0 8
107087: PUSH
107088: LD_VAR 0 8
107092: PUSH
107093: LD_INT 1
107095: NEG
107096: MUL
107097: ST_TO_ADDR
// wait ( time ) ;
107098: LD_VAR 0 8
107102: PPUSH
107103: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107107: LD_INT 35
107109: PPUSH
107110: LD_INT 875
107112: PPUSH
107113: CALL_OW 12
107117: PPUSH
107118: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107122: LD_INT 1
107124: PPUSH
107125: LD_INT 5
107127: PPUSH
107128: CALL_OW 12
107132: PPUSH
107133: LD_VAR 0 1
107137: PPUSH
107138: LD_INT 1
107140: PPUSH
107141: CALL_OW 55
// end ;
107145: GO 106955
// end ;
107147: LD_VAR 0 5
107151: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107152: LD_INT 0
107154: PPUSH
107155: PPUSH
107156: PPUSH
107157: PPUSH
107158: PPUSH
107159: PPUSH
107160: PPUSH
107161: PPUSH
// if not turrets or not factories then
107162: LD_VAR 0 1
107166: NOT
107167: PUSH
107168: LD_VAR 0 2
107172: NOT
107173: OR
107174: IFFALSE 107178
// exit ;
107176: GO 107485
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107178: LD_ADDR_VAR 0 10
107182: PUSH
107183: LD_INT 5
107185: PUSH
107186: LD_INT 6
107188: PUSH
107189: EMPTY
107190: LIST
107191: LIST
107192: PUSH
107193: LD_INT 2
107195: PUSH
107196: LD_INT 4
107198: PUSH
107199: EMPTY
107200: LIST
107201: LIST
107202: PUSH
107203: LD_INT 3
107205: PUSH
107206: LD_INT 5
107208: PUSH
107209: EMPTY
107210: LIST
107211: LIST
107212: PUSH
107213: EMPTY
107214: LIST
107215: LIST
107216: LIST
107217: PUSH
107218: LD_INT 24
107220: PUSH
107221: LD_INT 25
107223: PUSH
107224: EMPTY
107225: LIST
107226: LIST
107227: PUSH
107228: LD_INT 23
107230: PUSH
107231: LD_INT 27
107233: PUSH
107234: EMPTY
107235: LIST
107236: LIST
107237: PUSH
107238: EMPTY
107239: LIST
107240: LIST
107241: PUSH
107242: LD_INT 42
107244: PUSH
107245: LD_INT 43
107247: PUSH
107248: EMPTY
107249: LIST
107250: LIST
107251: PUSH
107252: LD_INT 44
107254: PUSH
107255: LD_INT 46
107257: PUSH
107258: EMPTY
107259: LIST
107260: LIST
107261: PUSH
107262: LD_INT 45
107264: PUSH
107265: LD_INT 47
107267: PUSH
107268: EMPTY
107269: LIST
107270: LIST
107271: PUSH
107272: EMPTY
107273: LIST
107274: LIST
107275: LIST
107276: PUSH
107277: EMPTY
107278: LIST
107279: LIST
107280: LIST
107281: ST_TO_ADDR
// result := [ ] ;
107282: LD_ADDR_VAR 0 3
107286: PUSH
107287: EMPTY
107288: ST_TO_ADDR
// for i in turrets do
107289: LD_ADDR_VAR 0 4
107293: PUSH
107294: LD_VAR 0 1
107298: PUSH
107299: FOR_IN
107300: IFFALSE 107483
// begin nat := GetNation ( i ) ;
107302: LD_ADDR_VAR 0 7
107306: PUSH
107307: LD_VAR 0 4
107311: PPUSH
107312: CALL_OW 248
107316: ST_TO_ADDR
// weapon := 0 ;
107317: LD_ADDR_VAR 0 8
107321: PUSH
107322: LD_INT 0
107324: ST_TO_ADDR
// if not nat then
107325: LD_VAR 0 7
107329: NOT
107330: IFFALSE 107334
// continue ;
107332: GO 107299
// for j in list [ nat ] do
107334: LD_ADDR_VAR 0 5
107338: PUSH
107339: LD_VAR 0 10
107343: PUSH
107344: LD_VAR 0 7
107348: ARRAY
107349: PUSH
107350: FOR_IN
107351: IFFALSE 107392
// if GetBWeapon ( i ) = j [ 1 ] then
107353: LD_VAR 0 4
107357: PPUSH
107358: CALL_OW 269
107362: PUSH
107363: LD_VAR 0 5
107367: PUSH
107368: LD_INT 1
107370: ARRAY
107371: EQUAL
107372: IFFALSE 107390
// begin weapon := j [ 2 ] ;
107374: LD_ADDR_VAR 0 8
107378: PUSH
107379: LD_VAR 0 5
107383: PUSH
107384: LD_INT 2
107386: ARRAY
107387: ST_TO_ADDR
// break ;
107388: GO 107392
// end ;
107390: GO 107350
107392: POP
107393: POP
// if not weapon then
107394: LD_VAR 0 8
107398: NOT
107399: IFFALSE 107403
// continue ;
107401: GO 107299
// for k in factories do
107403: LD_ADDR_VAR 0 6
107407: PUSH
107408: LD_VAR 0 2
107412: PUSH
107413: FOR_IN
107414: IFFALSE 107479
// begin weapons := AvailableWeaponList ( k ) ;
107416: LD_ADDR_VAR 0 9
107420: PUSH
107421: LD_VAR 0 6
107425: PPUSH
107426: CALL_OW 478
107430: ST_TO_ADDR
// if not weapons then
107431: LD_VAR 0 9
107435: NOT
107436: IFFALSE 107440
// continue ;
107438: GO 107413
// if weapon in weapons then
107440: LD_VAR 0 8
107444: PUSH
107445: LD_VAR 0 9
107449: IN
107450: IFFALSE 107477
// begin result := [ i , weapon ] ;
107452: LD_ADDR_VAR 0 3
107456: PUSH
107457: LD_VAR 0 4
107461: PUSH
107462: LD_VAR 0 8
107466: PUSH
107467: EMPTY
107468: LIST
107469: LIST
107470: ST_TO_ADDR
// exit ;
107471: POP
107472: POP
107473: POP
107474: POP
107475: GO 107485
// end ; end ;
107477: GO 107413
107479: POP
107480: POP
// end ;
107481: GO 107299
107483: POP
107484: POP
// end ;
107485: LD_VAR 0 3
107489: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107490: LD_INT 0
107492: PPUSH
// if not side or side > 8 then
107493: LD_VAR 0 3
107497: NOT
107498: PUSH
107499: LD_VAR 0 3
107503: PUSH
107504: LD_INT 8
107506: GREATER
107507: OR
107508: IFFALSE 107512
// exit ;
107510: GO 107571
// if not range then
107512: LD_VAR 0 4
107516: NOT
107517: IFFALSE 107528
// range := - 12 ;
107519: LD_ADDR_VAR 0 4
107523: PUSH
107524: LD_INT 12
107526: NEG
107527: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107528: LD_VAR 0 1
107532: PPUSH
107533: LD_VAR 0 2
107537: PPUSH
107538: LD_VAR 0 3
107542: PPUSH
107543: LD_VAR 0 4
107547: PPUSH
107548: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107552: LD_VAR 0 1
107556: PPUSH
107557: LD_VAR 0 2
107561: PPUSH
107562: LD_VAR 0 3
107566: PPUSH
107567: CALL_OW 331
// end ;
107571: LD_VAR 0 5
107575: RET
// export function Video ( mode ) ; begin
107576: LD_INT 0
107578: PPUSH
// ingame_video = mode ;
107579: LD_ADDR_OWVAR 52
107583: PUSH
107584: LD_VAR 0 1
107588: ST_TO_ADDR
// interface_hidden = mode ;
107589: LD_ADDR_OWVAR 54
107593: PUSH
107594: LD_VAR 0 1
107598: ST_TO_ADDR
// end ;
107599: LD_VAR 0 2
107603: RET
// export function Join ( array , element ) ; begin
107604: LD_INT 0
107606: PPUSH
// result := array ^ element ;
107607: LD_ADDR_VAR 0 3
107611: PUSH
107612: LD_VAR 0 1
107616: PUSH
107617: LD_VAR 0 2
107621: ADD
107622: ST_TO_ADDR
// end ;
107623: LD_VAR 0 3
107627: RET
// export function JoinUnion ( array , element ) ; begin
107628: LD_INT 0
107630: PPUSH
// result := array union element ;
107631: LD_ADDR_VAR 0 3
107635: PUSH
107636: LD_VAR 0 1
107640: PUSH
107641: LD_VAR 0 2
107645: UNION
107646: ST_TO_ADDR
// end ;
107647: LD_VAR 0 3
107651: RET
// export function GetBehemoths ( side ) ; begin
107652: LD_INT 0
107654: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107655: LD_ADDR_VAR 0 2
107659: PUSH
107660: LD_INT 22
107662: PUSH
107663: LD_VAR 0 1
107667: PUSH
107668: EMPTY
107669: LIST
107670: LIST
107671: PUSH
107672: LD_INT 31
107674: PUSH
107675: LD_INT 25
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: PUSH
107682: EMPTY
107683: LIST
107684: LIST
107685: PPUSH
107686: CALL_OW 69
107690: ST_TO_ADDR
// end ;
107691: LD_VAR 0 2
107695: RET
// export function Shuffle ( array ) ; var i , index ; begin
107696: LD_INT 0
107698: PPUSH
107699: PPUSH
107700: PPUSH
// result := [ ] ;
107701: LD_ADDR_VAR 0 2
107705: PUSH
107706: EMPTY
107707: ST_TO_ADDR
// if not array then
107708: LD_VAR 0 1
107712: NOT
107713: IFFALSE 107717
// exit ;
107715: GO 107816
// Randomize ;
107717: CALL_OW 10
// for i = array downto 1 do
107721: LD_ADDR_VAR 0 3
107725: PUSH
107726: DOUBLE
107727: LD_VAR 0 1
107731: INC
107732: ST_TO_ADDR
107733: LD_INT 1
107735: PUSH
107736: FOR_DOWNTO
107737: IFFALSE 107814
// begin index := rand ( 1 , array ) ;
107739: LD_ADDR_VAR 0 4
107743: PUSH
107744: LD_INT 1
107746: PPUSH
107747: LD_VAR 0 1
107751: PPUSH
107752: CALL_OW 12
107756: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107757: LD_ADDR_VAR 0 2
107761: PUSH
107762: LD_VAR 0 2
107766: PPUSH
107767: LD_VAR 0 2
107771: PUSH
107772: LD_INT 1
107774: PLUS
107775: PPUSH
107776: LD_VAR 0 1
107780: PUSH
107781: LD_VAR 0 4
107785: ARRAY
107786: PPUSH
107787: CALL_OW 2
107791: ST_TO_ADDR
// array := Delete ( array , index ) ;
107792: LD_ADDR_VAR 0 1
107796: PUSH
107797: LD_VAR 0 1
107801: PPUSH
107802: LD_VAR 0 4
107806: PPUSH
107807: CALL_OW 3
107811: ST_TO_ADDR
// end ;
107812: GO 107736
107814: POP
107815: POP
// end ;
107816: LD_VAR 0 2
107820: RET
// export function GetBaseMaterials ( base ) ; begin
107821: LD_INT 0
107823: PPUSH
// result := [ 0 , 0 , 0 ] ;
107824: LD_ADDR_VAR 0 2
107828: PUSH
107829: LD_INT 0
107831: PUSH
107832: LD_INT 0
107834: PUSH
107835: LD_INT 0
107837: PUSH
107838: EMPTY
107839: LIST
107840: LIST
107841: LIST
107842: ST_TO_ADDR
// if not base then
107843: LD_VAR 0 1
107847: NOT
107848: IFFALSE 107852
// exit ;
107850: GO 107901
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107852: LD_ADDR_VAR 0 2
107856: PUSH
107857: LD_VAR 0 1
107861: PPUSH
107862: LD_INT 1
107864: PPUSH
107865: CALL_OW 275
107869: PUSH
107870: LD_VAR 0 1
107874: PPUSH
107875: LD_INT 2
107877: PPUSH
107878: CALL_OW 275
107882: PUSH
107883: LD_VAR 0 1
107887: PPUSH
107888: LD_INT 3
107890: PPUSH
107891: CALL_OW 275
107895: PUSH
107896: EMPTY
107897: LIST
107898: LIST
107899: LIST
107900: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107901: LD_VAR 0 2
107905: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107906: LD_INT 0
107908: PPUSH
107909: PPUSH
107910: PPUSH
107911: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107912: LD_VAR 0 1
107916: PPUSH
107917: CALL_OW 264
107921: PUSH
107922: LD_EXP 99
107926: EQUAL
107927: IFFALSE 107999
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107929: LD_INT 68
107931: PPUSH
107932: LD_VAR 0 1
107936: PPUSH
107937: CALL_OW 255
107941: PPUSH
107942: CALL_OW 321
107946: PUSH
107947: LD_INT 2
107949: EQUAL
107950: IFFALSE 107962
// eff := 70 else
107952: LD_ADDR_VAR 0 6
107956: PUSH
107957: LD_INT 70
107959: ST_TO_ADDR
107960: GO 107970
// eff := 30 ;
107962: LD_ADDR_VAR 0 6
107966: PUSH
107967: LD_INT 30
107969: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107970: LD_VAR 0 1
107974: PPUSH
107975: CALL_OW 250
107979: PPUSH
107980: LD_VAR 0 1
107984: PPUSH
107985: CALL_OW 251
107989: PPUSH
107990: LD_VAR 0 6
107994: PPUSH
107995: CALL_OW 495
// end ; end ;
107999: LD_VAR 0 4
108003: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
108004: LD_INT 0
108006: PPUSH
108007: PPUSH
108008: PPUSH
108009: PPUSH
108010: PPUSH
108011: PPUSH
// if cmd = 124 then
108012: LD_VAR 0 1
108016: PUSH
108017: LD_INT 124
108019: EQUAL
108020: IFFALSE 108226
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
108022: LD_ADDR_VAR 0 5
108026: PUSH
108027: LD_INT 2
108029: PUSH
108030: LD_INT 34
108032: PUSH
108033: LD_INT 53
108035: PUSH
108036: EMPTY
108037: LIST
108038: LIST
108039: PUSH
108040: LD_INT 34
108042: PUSH
108043: LD_INT 14
108045: PUSH
108046: EMPTY
108047: LIST
108048: LIST
108049: PUSH
108050: EMPTY
108051: LIST
108052: LIST
108053: LIST
108054: PPUSH
108055: CALL_OW 69
108059: ST_TO_ADDR
// if not tmp then
108060: LD_VAR 0 5
108064: NOT
108065: IFFALSE 108069
// exit ;
108067: GO 108226
// for i in tmp do
108069: LD_ADDR_VAR 0 3
108073: PUSH
108074: LD_VAR 0 5
108078: PUSH
108079: FOR_IN
108080: IFFALSE 108224
// begin taskList := GetTaskList ( i ) ;
108082: LD_ADDR_VAR 0 6
108086: PUSH
108087: LD_VAR 0 3
108091: PPUSH
108092: CALL_OW 437
108096: ST_TO_ADDR
// if not taskList then
108097: LD_VAR 0 6
108101: NOT
108102: IFFALSE 108106
// continue ;
108104: GO 108079
// for j = 1 to taskList do
108106: LD_ADDR_VAR 0 4
108110: PUSH
108111: DOUBLE
108112: LD_INT 1
108114: DEC
108115: ST_TO_ADDR
108116: LD_VAR 0 6
108120: PUSH
108121: FOR_TO
108122: IFFALSE 108220
// if taskList [ j ] [ 1 ] = | then
108124: LD_VAR 0 6
108128: PUSH
108129: LD_VAR 0 4
108133: ARRAY
108134: PUSH
108135: LD_INT 1
108137: ARRAY
108138: PUSH
108139: LD_STRING |
108141: EQUAL
108142: IFFALSE 108218
// begin _taskList := Delete ( taskList , 1 ) ;
108144: LD_ADDR_VAR 0 7
108148: PUSH
108149: LD_VAR 0 6
108153: PPUSH
108154: LD_INT 1
108156: PPUSH
108157: CALL_OW 3
108161: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
108162: LD_VAR 0 3
108166: PPUSH
108167: LD_VAR 0 7
108171: PPUSH
108172: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
108176: LD_VAR 0 3
108180: PPUSH
108181: LD_VAR 0 6
108185: PUSH
108186: LD_VAR 0 4
108190: ARRAY
108191: PUSH
108192: LD_INT 2
108194: ARRAY
108195: PPUSH
108196: LD_VAR 0 6
108200: PUSH
108201: LD_VAR 0 4
108205: ARRAY
108206: PUSH
108207: LD_INT 3
108209: ARRAY
108210: PPUSH
108211: LD_INT 8
108213: PPUSH
108214: CALL 108231 0 4
// end ;
108218: GO 108121
108220: POP
108221: POP
// end ;
108222: GO 108079
108224: POP
108225: POP
// end ; end ;
108226: LD_VAR 0 2
108230: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108231: LD_INT 0
108233: PPUSH
108234: PPUSH
108235: PPUSH
108236: PPUSH
108237: PPUSH
108238: PPUSH
108239: PPUSH
108240: PPUSH
108241: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108242: LD_VAR 0 1
108246: NOT
108247: PUSH
108248: LD_VAR 0 2
108252: PPUSH
108253: LD_VAR 0 3
108257: PPUSH
108258: CALL_OW 488
108262: NOT
108263: OR
108264: PUSH
108265: LD_VAR 0 4
108269: NOT
108270: OR
108271: IFFALSE 108275
// exit ;
108273: GO 108615
// list := [ ] ;
108275: LD_ADDR_VAR 0 13
108279: PUSH
108280: EMPTY
108281: ST_TO_ADDR
// if x - r < 0 then
108282: LD_VAR 0 2
108286: PUSH
108287: LD_VAR 0 4
108291: MINUS
108292: PUSH
108293: LD_INT 0
108295: LESS
108296: IFFALSE 108308
// min_x := 0 else
108298: LD_ADDR_VAR 0 7
108302: PUSH
108303: LD_INT 0
108305: ST_TO_ADDR
108306: GO 108324
// min_x := x - r ;
108308: LD_ADDR_VAR 0 7
108312: PUSH
108313: LD_VAR 0 2
108317: PUSH
108318: LD_VAR 0 4
108322: MINUS
108323: ST_TO_ADDR
// if y - r < 0 then
108324: LD_VAR 0 3
108328: PUSH
108329: LD_VAR 0 4
108333: MINUS
108334: PUSH
108335: LD_INT 0
108337: LESS
108338: IFFALSE 108350
// min_y := 0 else
108340: LD_ADDR_VAR 0 8
108344: PUSH
108345: LD_INT 0
108347: ST_TO_ADDR
108348: GO 108366
// min_y := y - r ;
108350: LD_ADDR_VAR 0 8
108354: PUSH
108355: LD_VAR 0 3
108359: PUSH
108360: LD_VAR 0 4
108364: MINUS
108365: ST_TO_ADDR
// max_x := x + r ;
108366: LD_ADDR_VAR 0 9
108370: PUSH
108371: LD_VAR 0 2
108375: PUSH
108376: LD_VAR 0 4
108380: PLUS
108381: ST_TO_ADDR
// max_y := y + r ;
108382: LD_ADDR_VAR 0 10
108386: PUSH
108387: LD_VAR 0 3
108391: PUSH
108392: LD_VAR 0 4
108396: PLUS
108397: ST_TO_ADDR
// for _x = min_x to max_x do
108398: LD_ADDR_VAR 0 11
108402: PUSH
108403: DOUBLE
108404: LD_VAR 0 7
108408: DEC
108409: ST_TO_ADDR
108410: LD_VAR 0 9
108414: PUSH
108415: FOR_TO
108416: IFFALSE 108533
// for _y = min_y to max_y do
108418: LD_ADDR_VAR 0 12
108422: PUSH
108423: DOUBLE
108424: LD_VAR 0 8
108428: DEC
108429: ST_TO_ADDR
108430: LD_VAR 0 10
108434: PUSH
108435: FOR_TO
108436: IFFALSE 108529
// begin if not ValidHex ( _x , _y ) then
108438: LD_VAR 0 11
108442: PPUSH
108443: LD_VAR 0 12
108447: PPUSH
108448: CALL_OW 488
108452: NOT
108453: IFFALSE 108457
// continue ;
108455: GO 108435
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108457: LD_VAR 0 11
108461: PPUSH
108462: LD_VAR 0 12
108466: PPUSH
108467: CALL_OW 351
108471: PUSH
108472: LD_VAR 0 11
108476: PPUSH
108477: LD_VAR 0 12
108481: PPUSH
108482: CALL_OW 554
108486: AND
108487: IFFALSE 108527
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108489: LD_ADDR_VAR 0 13
108493: PUSH
108494: LD_VAR 0 13
108498: PPUSH
108499: LD_VAR 0 13
108503: PUSH
108504: LD_INT 1
108506: PLUS
108507: PPUSH
108508: LD_VAR 0 11
108512: PUSH
108513: LD_VAR 0 12
108517: PUSH
108518: EMPTY
108519: LIST
108520: LIST
108521: PPUSH
108522: CALL_OW 2
108526: ST_TO_ADDR
// end ;
108527: GO 108435
108529: POP
108530: POP
108531: GO 108415
108533: POP
108534: POP
// if not list then
108535: LD_VAR 0 13
108539: NOT
108540: IFFALSE 108544
// exit ;
108542: GO 108615
// for i in list do
108544: LD_ADDR_VAR 0 6
108548: PUSH
108549: LD_VAR 0 13
108553: PUSH
108554: FOR_IN
108555: IFFALSE 108613
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108557: LD_VAR 0 1
108561: PPUSH
108562: LD_STRING M
108564: PUSH
108565: LD_VAR 0 6
108569: PUSH
108570: LD_INT 1
108572: ARRAY
108573: PUSH
108574: LD_VAR 0 6
108578: PUSH
108579: LD_INT 2
108581: ARRAY
108582: PUSH
108583: LD_INT 0
108585: PUSH
108586: LD_INT 0
108588: PUSH
108589: LD_INT 0
108591: PUSH
108592: LD_INT 0
108594: PUSH
108595: EMPTY
108596: LIST
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: LIST
108603: PUSH
108604: EMPTY
108605: LIST
108606: PPUSH
108607: CALL_OW 447
108611: GO 108554
108613: POP
108614: POP
// end ;
108615: LD_VAR 0 5
108619: RET
