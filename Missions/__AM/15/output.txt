// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38883 0 0
// InitNature ;
  19: CALL 38751 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12655 0 0
// PrepareRussian ;
  40: CALL 7537 0 0
// PrepareLegion ;
  44: CALL 4619 0 0
// PreparePowell ;
  48: CALL 3153 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17518 0 0
// MC_Start ( ) ;
  60: CALL 41063 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63859 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63952 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63302 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63117 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63859 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63952 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63117 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63302 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63732 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62780 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63859 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63952 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63117 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63859 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63952 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63009 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64270 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63441 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63732 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63732 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64064 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63117 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63683 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69591 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74431 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74431 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 59
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 59
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74431 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 59
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 59
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 59
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 59
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74431 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74431 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 60
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 60
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 60
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69591 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 60
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69591 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 60
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69591 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 60
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69591 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2491
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2413: LD_ADDR_OWVAR 30
2417: PUSH
2418: LD_INT 2
2420: PUSH
2421: LD_INT 2
2423: PUSH
2424: LD_INT 0
2426: PUSH
2427: LD_INT 2
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2436: LD_ADDR_OWVAR 31
2440: PUSH
2441: LD_INT 4
2443: PUSH
2444: LD_INT 5
2446: PUSH
2447: LD_INT 2
2449: PUSH
2450: LD_INT 10
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: ST_TO_ADDR
// Baker := CreateHuman ;
2459: LD_ADDR_EXP 56
2463: PUSH
2464: CALL_OW 44
2468: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: LD_VAR 0 2
2478: PUSH
2479: LD_EXP 56
2483: ADD
2484: ST_TO_ADDR
// InitHc ;
2485: CALL_OW 19
// end else
2489: GO 2507
// tmp := tmp ^ Stevens ;
2491: LD_ADDR_VAR 0 2
2495: PUSH
2496: LD_VAR 0 2
2500: PUSH
2501: LD_EXP 42
2505: ADD
2506: ST_TO_ADDR
// if not Lisa then
2507: LD_EXP 43
2511: NOT
2512: IFFALSE 2558
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2514: LD_ADDR_EXP 43
2518: PUSH
2519: LD_STRING Lisa
2521: PPUSH
2522: LD_EXP 1
2526: NOT
2527: PPUSH
2528: LD_STRING 13f_
2530: PPUSH
2531: CALL 69591 0 3
2535: ST_TO_ADDR
// if Lisa then
2536: LD_EXP 43
2540: IFFALSE 2558
// tmp := tmp ^ Lisa ;
2542: LD_ADDR_VAR 0 2
2546: PUSH
2547: LD_VAR 0 2
2551: PUSH
2552: LD_EXP 43
2556: ADD
2557: ST_TO_ADDR
// end ; if not Donaldson then
2558: LD_EXP 44
2562: NOT
2563: IFFALSE 2609
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2565: LD_ADDR_EXP 44
2569: PUSH
2570: LD_STRING Donaldson
2572: PPUSH
2573: LD_EXP 1
2577: NOT
2578: PPUSH
2579: LD_STRING 13f_
2581: PPUSH
2582: CALL 69591 0 3
2586: ST_TO_ADDR
// if Donaldson then
2587: LD_EXP 44
2591: IFFALSE 2609
// tmp := tmp ^ Donaldson ;
2593: LD_ADDR_VAR 0 2
2597: PUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_EXP 44
2607: ADD
2608: ST_TO_ADDR
// end ; if not Bobby then
2609: LD_EXP 45
2613: NOT
2614: IFFALSE 2660
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2616: LD_ADDR_EXP 45
2620: PUSH
2621: LD_STRING Bobby
2623: PPUSH
2624: LD_EXP 1
2628: NOT
2629: PPUSH
2630: LD_STRING 13f_
2632: PPUSH
2633: CALL 69591 0 3
2637: ST_TO_ADDR
// if Bobby then
2638: LD_EXP 45
2642: IFFALSE 2660
// tmp := tmp ^ Bobby ;
2644: LD_ADDR_VAR 0 2
2648: PUSH
2649: LD_VAR 0 2
2653: PUSH
2654: LD_EXP 45
2658: ADD
2659: ST_TO_ADDR
// end ; if not Cyrus then
2660: LD_EXP 46
2664: NOT
2665: IFFALSE 2711
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2667: LD_ADDR_EXP 46
2671: PUSH
2672: LD_STRING Cyrus
2674: PPUSH
2675: LD_EXP 1
2679: NOT
2680: PPUSH
2681: LD_STRING 13f_
2683: PPUSH
2684: CALL 69591 0 3
2688: ST_TO_ADDR
// if Cyrus then
2689: LD_EXP 46
2693: IFFALSE 2711
// tmp := tmp ^ Cyrus ;
2695: LD_ADDR_VAR 0 2
2699: PUSH
2700: LD_VAR 0 2
2704: PUSH
2705: LD_EXP 46
2709: ADD
2710: ST_TO_ADDR
// end ; if not Brown then
2711: LD_EXP 48
2715: NOT
2716: IFFALSE 2762
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2718: LD_ADDR_EXP 48
2722: PUSH
2723: LD_STRING Brown
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_STRING 13f_
2734: PPUSH
2735: CALL 69591 0 3
2739: ST_TO_ADDR
// if Brown then
2740: LD_EXP 48
2744: IFFALSE 2762
// tmp := tmp ^ Brown ;
2746: LD_ADDR_VAR 0 2
2750: PUSH
2751: LD_VAR 0 2
2755: PUSH
2756: LD_EXP 48
2760: ADD
2761: ST_TO_ADDR
// end ; if not Gladstone then
2762: LD_EXP 49
2766: NOT
2767: IFFALSE 2813
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2769: LD_ADDR_EXP 49
2773: PUSH
2774: LD_STRING Gladstone
2776: PPUSH
2777: LD_EXP 1
2781: NOT
2782: PPUSH
2783: LD_STRING 13f_
2785: PPUSH
2786: CALL 69591 0 3
2790: ST_TO_ADDR
// if Gladstone then
2791: LD_EXP 49
2795: IFFALSE 2813
// tmp := tmp ^ Gladstone ;
2797: LD_ADDR_VAR 0 2
2801: PUSH
2802: LD_VAR 0 2
2806: PUSH
2807: LD_EXP 49
2811: ADD
2812: ST_TO_ADDR
// end ; if not Houten then
2813: LD_EXP 50
2817: NOT
2818: IFFALSE 2864
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2820: LD_ADDR_EXP 50
2824: PUSH
2825: LD_STRING Houten
2827: PPUSH
2828: LD_EXP 1
2832: NOT
2833: PPUSH
2834: LD_STRING 13f_
2836: PPUSH
2837: CALL 69591 0 3
2841: ST_TO_ADDR
// if Houten then
2842: LD_EXP 50
2846: IFFALSE 2864
// tmp := tmp ^ Houten ;
2848: LD_ADDR_VAR 0 2
2852: PUSH
2853: LD_VAR 0 2
2857: PUSH
2858: LD_EXP 50
2862: ADD
2863: ST_TO_ADDR
// end ; if not Cornel then
2864: LD_EXP 51
2868: NOT
2869: IFFALSE 2915
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2871: LD_ADDR_EXP 51
2875: PUSH
2876: LD_STRING Cornell
2878: PPUSH
2879: LD_EXP 1
2883: NOT
2884: PPUSH
2885: LD_STRING 13f_
2887: PPUSH
2888: CALL 69591 0 3
2892: ST_TO_ADDR
// if Cornel then
2893: LD_EXP 51
2897: IFFALSE 2915
// tmp := tmp ^ Cornel ;
2899: LD_ADDR_VAR 0 2
2903: PUSH
2904: LD_VAR 0 2
2908: PUSH
2909: LD_EXP 51
2913: ADD
2914: ST_TO_ADDR
// end ; if not Gary then
2915: LD_EXP 52
2919: NOT
2920: IFFALSE 2966
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2922: LD_ADDR_EXP 52
2926: PUSH
2927: LD_STRING Gary
2929: PPUSH
2930: LD_EXP 1
2934: NOT
2935: PPUSH
2936: LD_STRING 13f_
2938: PPUSH
2939: CALL 69591 0 3
2943: ST_TO_ADDR
// if Gary then
2944: LD_EXP 52
2948: IFFALSE 2966
// tmp := tmp ^ Gary ;
2950: LD_ADDR_VAR 0 2
2954: PUSH
2955: LD_VAR 0 2
2959: PUSH
2960: LD_EXP 52
2964: ADD
2965: ST_TO_ADDR
// end ; if not Frank then
2966: LD_EXP 53
2970: NOT
2971: IFFALSE 3017
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2973: LD_ADDR_EXP 53
2977: PUSH
2978: LD_STRING Frank
2980: PPUSH
2981: LD_EXP 1
2985: NOT
2986: PPUSH
2987: LD_STRING 13f_
2989: PPUSH
2990: CALL 69591 0 3
2994: ST_TO_ADDR
// if Frank then
2995: LD_EXP 53
2999: IFFALSE 3017
// tmp := tmp ^ Frank ;
3001: LD_ADDR_VAR 0 2
3005: PUSH
3006: LD_VAR 0 2
3010: PUSH
3011: LD_EXP 53
3015: ADD
3016: ST_TO_ADDR
// end ; if not Kikuchi then
3017: LD_EXP 54
3021: NOT
3022: IFFALSE 3068
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3024: LD_ADDR_EXP 54
3028: PUSH
3029: LD_STRING Kikuchi
3031: PPUSH
3032: LD_EXP 1
3036: NOT
3037: PPUSH
3038: LD_STRING 13f_
3040: PPUSH
3041: CALL 69591 0 3
3045: ST_TO_ADDR
// if Kikuchi then
3046: LD_EXP 54
3050: IFFALSE 3068
// tmp := tmp ^ Kikuchi ;
3052: LD_ADDR_VAR 0 2
3056: PUSH
3057: LD_VAR 0 2
3061: PUSH
3062: LD_EXP 54
3066: ADD
3067: ST_TO_ADDR
// end ; if not DeltaDoctor then
3068: LD_EXP 58
3072: NOT
3073: IFFALSE 3119
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3075: LD_ADDR_EXP 58
3079: PUSH
3080: LD_STRING DeltaDoctor
3082: PPUSH
3083: LD_EXP 1
3087: NOT
3088: PPUSH
3089: LD_STRING 13f_
3091: PPUSH
3092: CALL 69591 0 3
3096: ST_TO_ADDR
// if Bobby then
3097: LD_EXP 45
3101: IFFALSE 3119
// tmp := tmp ^ DeltaDoctor ;
3103: LD_ADDR_VAR 0 2
3107: PUSH
3108: LD_VAR 0 2
3112: PUSH
3113: LD_EXP 58
3117: ADD
3118: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3119: LD_ADDR_VAR 0 2
3123: PUSH
3124: LD_VAR 0 2
3128: PUSH
3129: LD_STRING 13_other_survivors
3131: PPUSH
3132: CALL_OW 31
3136: UNION
3137: ST_TO_ADDR
// result := tmp ;
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 2
3147: ST_TO_ADDR
// end ; end_of_file
3148: LD_VAR 0 1
3152: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3153: LD_INT 0
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
3159: PPUSH
3160: PPUSH
3161: PPUSH
3162: PPUSH
3163: PPUSH
3164: PPUSH
// uc_side := 4 ;
3165: LD_ADDR_OWVAR 20
3169: PUSH
3170: LD_INT 4
3172: ST_TO_ADDR
// uc_nation := 1 ;
3173: LD_ADDR_OWVAR 21
3177: PUSH
3178: LD_INT 1
3180: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3181: LD_INT 387
3183: PPUSH
3184: CALL_OW 274
3188: PPUSH
3189: LD_INT 1
3191: PPUSH
3192: LD_INT 3500
3194: PUSH
3195: LD_INT 3000
3197: PUSH
3198: LD_INT 2500
3200: PUSH
3201: LD_INT 2000
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: PUSH
3210: LD_OWVAR 67
3214: ARRAY
3215: PPUSH
3216: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3220: LD_INT 387
3222: PPUSH
3223: CALL_OW 274
3227: PPUSH
3228: LD_INT 2
3230: PPUSH
3231: LD_INT 400
3233: PPUSH
3234: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3238: LD_INT 387
3240: PPUSH
3241: CALL_OW 274
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 10
3251: PPUSH
3252: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3256: LD_INT 387
3258: PPUSH
3259: LD_STRING sigma
3261: PPUSH
3262: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3266: LD_ADDR_EXP 61
3270: PUSH
3271: LD_STRING Powell
3273: PPUSH
3274: CALL_OW 25
3278: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3279: LD_EXP 61
3283: PPUSH
3284: LD_INT 57
3286: PPUSH
3287: LD_INT 94
3289: PPUSH
3290: LD_INT 0
3292: PPUSH
3293: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3297: LD_EXP 61
3301: PPUSH
3302: LD_INT 58
3304: PPUSH
3305: LD_INT 94
3307: PPUSH
3308: CALL_OW 118
// vip := [ ] ;
3312: LD_ADDR_EXP 62
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// extraSquad := [ ] ;
3319: LD_ADDR_EXP 63
3323: PUSH
3324: EMPTY
3325: ST_TO_ADDR
// tmp := [ ] ;
3326: LD_ADDR_VAR 0 5
3330: PUSH
3331: EMPTY
3332: ST_TO_ADDR
// if JMMGirl <> 2 then
3333: LD_EXP 7
3337: PUSH
3338: LD_INT 2
3340: NONEQUAL
3341: IFFALSE 3365
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3343: LD_ADDR_EXP 43
3347: PUSH
3348: LD_STRING Lisa
3350: PPUSH
3351: LD_EXP 1
3355: NOT
3356: PPUSH
3357: LD_STRING 13s_
3359: PPUSH
3360: CALL 69591 0 3
3364: ST_TO_ADDR
// if Lisa then
3365: LD_EXP 43
3369: IFFALSE 3387
// tmp := tmp ^ Lisa ;
3371: LD_ADDR_VAR 0 5
3375: PUSH
3376: LD_VAR 0 5
3380: PUSH
3381: LD_EXP 43
3385: ADD
3386: ST_TO_ADDR
// if JMMGirl < 3 then
3387: LD_EXP 7
3391: PUSH
3392: LD_INT 3
3394: LESS
3395: IFFALSE 3426
// begin Connie := NewCharacter ( Coonie ) ;
3397: LD_ADDR_EXP 55
3401: PUSH
3402: LD_STRING Coonie
3404: PPUSH
3405: CALL_OW 25
3409: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3410: LD_ADDR_VAR 0 5
3414: PUSH
3415: LD_VAR 0 5
3419: PUSH
3420: LD_EXP 55
3424: ADD
3425: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3426: LD_ADDR_EXP 44
3430: PUSH
3431: LD_STRING Donaldson
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: LD_STRING 13s_
3442: PPUSH
3443: CALL 69591 0 3
3447: ST_TO_ADDR
// if Donaldson then
3448: LD_EXP 44
3452: IFFALSE 3470
// tmp := tmp ^ Donaldson ;
3454: LD_ADDR_VAR 0 5
3458: PUSH
3459: LD_VAR 0 5
3463: PUSH
3464: LD_EXP 44
3468: ADD
3469: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3470: LD_ADDR_EXP 45
3474: PUSH
3475: LD_STRING Bobby
3477: PPUSH
3478: LD_EXP 1
3482: NOT
3483: PPUSH
3484: LD_STRING 13s_
3486: PPUSH
3487: CALL 69591 0 3
3491: ST_TO_ADDR
// if Bobby then
3492: LD_EXP 45
3496: IFFALSE 3514
// tmp := tmp ^ Bobby ;
3498: LD_ADDR_VAR 0 5
3502: PUSH
3503: LD_VAR 0 5
3507: PUSH
3508: LD_EXP 45
3512: ADD
3513: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3514: LD_ADDR_EXP 46
3518: PUSH
3519: LD_STRING Cyrus
3521: PPUSH
3522: LD_EXP 1
3526: NOT
3527: PPUSH
3528: LD_STRING 13s_
3530: PPUSH
3531: CALL 69591 0 3
3535: ST_TO_ADDR
// if Cyrus then
3536: LD_EXP 46
3540: IFFALSE 3558
// tmp := tmp ^ Cyrus ;
3542: LD_ADDR_VAR 0 5
3546: PUSH
3547: LD_VAR 0 5
3551: PUSH
3552: LD_EXP 46
3556: ADD
3557: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3558: LD_ADDR_EXP 47
3562: PUSH
3563: LD_STRING Denis
3565: PPUSH
3566: LD_EXP 1
3570: NOT
3571: PPUSH
3572: LD_STRING 13s_
3574: PPUSH
3575: CALL 69591 0 3
3579: ST_TO_ADDR
// if not Denis then
3580: LD_EXP 47
3584: NOT
3585: IFFALSE 3609
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3587: LD_ADDR_EXP 47
3591: PUSH
3592: LD_STRING Denis
3594: PPUSH
3595: LD_EXP 1
3599: NOT
3600: PPUSH
3601: LD_STRING 13f_
3603: PPUSH
3604: CALL 69591 0 3
3608: ST_TO_ADDR
// if Denis then
3609: LD_EXP 47
3613: IFFALSE 3631
// tmp := tmp ^ Denis ;
3615: LD_ADDR_VAR 0 5
3619: PUSH
3620: LD_VAR 0 5
3624: PUSH
3625: LD_EXP 47
3629: ADD
3630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3631: LD_ADDR_EXP 48
3635: PUSH
3636: LD_STRING Brown
3638: PPUSH
3639: LD_EXP 1
3643: NOT
3644: PPUSH
3645: LD_STRING 13s_
3647: PPUSH
3648: CALL 69591 0 3
3652: ST_TO_ADDR
// if Brown then
3653: LD_EXP 48
3657: IFFALSE 3675
// tmp := tmp ^ Brown ;
3659: LD_ADDR_VAR 0 5
3663: PUSH
3664: LD_VAR 0 5
3668: PUSH
3669: LD_EXP 48
3673: ADD
3674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3675: LD_ADDR_EXP 49
3679: PUSH
3680: LD_STRING Gladstone
3682: PPUSH
3683: LD_EXP 1
3687: NOT
3688: PPUSH
3689: LD_STRING 13s_
3691: PPUSH
3692: CALL 69591 0 3
3696: ST_TO_ADDR
// if Gladstone then
3697: LD_EXP 49
3701: IFFALSE 3719
// tmp := tmp ^ Gladstone ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: LD_VAR 0 5
3712: PUSH
3713: LD_EXP 49
3717: ADD
3718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3719: LD_ADDR_EXP 50
3723: PUSH
3724: LD_STRING Houten
3726: PPUSH
3727: LD_EXP 1
3731: NOT
3732: PPUSH
3733: LD_STRING 13s_
3735: PPUSH
3736: CALL 69591 0 3
3740: ST_TO_ADDR
// if Houten then
3741: LD_EXP 50
3745: IFFALSE 3763
// tmp := tmp ^ Houten ;
3747: LD_ADDR_VAR 0 5
3751: PUSH
3752: LD_VAR 0 5
3756: PUSH
3757: LD_EXP 50
3761: ADD
3762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3763: LD_ADDR_EXP 51
3767: PUSH
3768: LD_STRING Cornel
3770: PPUSH
3771: LD_EXP 1
3775: NOT
3776: PPUSH
3777: LD_STRING 13s_
3779: PPUSH
3780: CALL 69591 0 3
3784: ST_TO_ADDR
// if Cornel then
3785: LD_EXP 51
3789: IFFALSE 3807
// tmp := tmp ^ Cornel ;
3791: LD_ADDR_VAR 0 5
3795: PUSH
3796: LD_VAR 0 5
3800: PUSH
3801: LD_EXP 51
3805: ADD
3806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3807: LD_ADDR_EXP 52
3811: PUSH
3812: LD_STRING Gary
3814: PPUSH
3815: LD_EXP 1
3819: NOT
3820: PPUSH
3821: LD_STRING 13s_
3823: PPUSH
3824: CALL 69591 0 3
3828: ST_TO_ADDR
// if Gary then
3829: LD_EXP 52
3833: IFFALSE 3851
// tmp := tmp ^ Gary ;
3835: LD_ADDR_VAR 0 5
3839: PUSH
3840: LD_VAR 0 5
3844: PUSH
3845: LD_EXP 52
3849: ADD
3850: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3851: LD_ADDR_EXP 53
3855: PUSH
3856: LD_STRING Frank
3858: PPUSH
3859: LD_EXP 1
3863: NOT
3864: PPUSH
3865: LD_STRING 13s_
3867: PPUSH
3868: CALL 69591 0 3
3872: ST_TO_ADDR
// if Frank then
3873: LD_EXP 53
3877: IFFALSE 3895
// tmp := tmp ^ Frank ;
3879: LD_ADDR_VAR 0 5
3883: PUSH
3884: LD_VAR 0 5
3888: PUSH
3889: LD_EXP 53
3893: ADD
3894: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3895: LD_ADDR_EXP 54
3899: PUSH
3900: LD_STRING Kikuchi
3902: PPUSH
3903: LD_EXP 1
3907: NOT
3908: PPUSH
3909: LD_STRING 13s_
3911: PPUSH
3912: CALL 69591 0 3
3916: ST_TO_ADDR
// if Kikuchi then
3917: LD_EXP 54
3921: IFFALSE 3939
// tmp := tmp ^ Kikuchi ;
3923: LD_ADDR_VAR 0 5
3927: PUSH
3928: LD_VAR 0 5
3932: PUSH
3933: LD_EXP 54
3937: ADD
3938: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3939: LD_ADDR_EXP 58
3943: PUSH
3944: LD_STRING DeltaDoctor
3946: PPUSH
3947: LD_EXP 1
3951: NOT
3952: PPUSH
3953: LD_STRING 13s_
3955: PPUSH
3956: CALL 69591 0 3
3960: ST_TO_ADDR
// if DeltaDoctor then
3961: LD_EXP 58
3965: IFFALSE 3983
// tmp := tmp ^ DeltaDoctor ;
3967: LD_ADDR_VAR 0 5
3971: PUSH
3972: LD_VAR 0 5
3976: PUSH
3977: LD_EXP 58
3981: ADD
3982: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3983: LD_ADDR_EXP 57
3987: PUSH
3988: LD_STRING Mike
3990: PPUSH
3991: LD_EXP 1
3995: NOT
3996: PPUSH
3997: LD_STRING 10c_
3999: PPUSH
4000: CALL 69591 0 3
4004: ST_TO_ADDR
// if Mike then
4005: LD_EXP 57
4009: IFFALSE 4032
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4011: LD_EXP 57
4015: PPUSH
4016: LD_INT 61
4018: PPUSH
4019: LD_INT 89
4021: PPUSH
4022: LD_INT 8
4024: PPUSH
4025: LD_INT 0
4027: PPUSH
4028: CALL_OW 50
// vip := tmp ;
4032: LD_ADDR_EXP 62
4036: PUSH
4037: LD_VAR 0 5
4041: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4042: LD_ADDR_VAR 0 5
4046: PUSH
4047: LD_VAR 0 5
4051: PUSH
4052: LD_STRING 13s_others
4054: PPUSH
4055: CALL_OW 31
4059: UNION
4060: ST_TO_ADDR
// if tmp < 18 then
4061: LD_VAR 0 5
4065: PUSH
4066: LD_INT 18
4068: LESS
4069: IFFALSE 4174
// begin InitHC_All ( ) ;
4071: CALL_OW 584
// for i = 1 to 18 - tmp do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 18
4087: PUSH
4088: LD_VAR 0 5
4092: MINUS
4093: PUSH
4094: FOR_TO
4095: IFFALSE 4172
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4097: LD_INT 1
4099: PPUSH
4100: LD_VAR 0 2
4104: PUSH
4105: LD_INT 4
4107: MOD
4108: PUSH
4109: LD_INT 1
4111: PLUS
4112: PPUSH
4113: LD_INT 4
4115: PPUSH
4116: CALL_OW 380
// un := CreateHuman ;
4120: LD_ADDR_VAR 0 10
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4130: LD_ADDR_VAR 0 5
4134: PUSH
4135: LD_VAR 0 5
4139: PPUSH
4140: LD_VAR 0 10
4144: PPUSH
4145: CALL 107282 0 2
4149: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4150: LD_ADDR_EXP 63
4154: PUSH
4155: LD_EXP 63
4159: PPUSH
4160: LD_VAR 0 10
4164: PPUSH
4165: CALL 107282 0 2
4169: ST_TO_ADDR
// end ;
4170: GO 4094
4172: POP
4173: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_INT 53
4181: PPUSH
4182: LD_INT 94
4184: PPUSH
4185: CALL_OW 428
4189: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4190: LD_ADDR_VAR 0 7
4194: PUSH
4195: LD_INT 56
4197: PPUSH
4198: LD_INT 101
4200: PPUSH
4201: CALL_OW 428
4205: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4206: LD_ADDR_VAR 0 8
4210: PUSH
4211: LD_INT 67
4213: PPUSH
4214: LD_INT 101
4216: PPUSH
4217: CALL_OW 428
4221: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4222: LD_ADDR_VAR 0 9
4226: PUSH
4227: LD_INT 54
4229: PPUSH
4230: LD_INT 85
4232: PPUSH
4233: CALL_OW 428
4237: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4238: LD_ADDR_VAR 0 3
4242: PUSH
4243: LD_VAR 0 8
4247: PUSH
4248: LD_VAR 0 6
4252: PUSH
4253: LD_VAR 0 9
4257: PUSH
4258: LD_VAR 0 7
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: ST_TO_ADDR
// for i in tmp do
4269: LD_ADDR_VAR 0 2
4273: PUSH
4274: LD_VAR 0 5
4278: PUSH
4279: FOR_IN
4280: IFFALSE 4475
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4282: LD_VAR 0 3
4286: PUSH
4287: LD_INT 1
4289: ARRAY
4290: PPUSH
4291: CALL_OW 266
4295: PUSH
4296: LD_INT 4
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4319
4304: POP
// SetClass ( i , class_soldier ) ; b_depot :
4305: LD_VAR 0 2
4309: PPUSH
4310: LD_INT 1
4312: PPUSH
4313: CALL_OW 336
4317: GO 4389
4319: LD_INT 0
4321: DOUBLE
4322: EQUAL
4323: IFTRUE 4327
4325: GO 4342
4327: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4328: LD_VAR 0 2
4332: PPUSH
4333: LD_INT 2
4335: PPUSH
4336: CALL_OW 336
4340: GO 4389
4342: LD_INT 2
4344: DOUBLE
4345: EQUAL
4346: IFTRUE 4350
4348: GO 4365
4350: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4351: LD_VAR 0 2
4355: PPUSH
4356: LD_INT 3
4358: PPUSH
4359: CALL_OW 336
4363: GO 4389
4365: LD_INT 6
4367: DOUBLE
4368: EQUAL
4369: IFTRUE 4373
4371: GO 4388
4373: POP
// SetClass ( i , class_scientistic ) ; end ;
4374: LD_VAR 0 2
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: CALL_OW 336
4386: GO 4389
4388: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4389: LD_VAR 0 3
4393: PUSH
4394: LD_INT 1
4396: ARRAY
4397: PPUSH
4398: CALL_OW 313
4402: PUSH
4403: LD_INT 6
4405: EQUAL
4406: IFFALSE 4426
// b := Delete ( b , 1 ) ;
4408: LD_ADDR_VAR 0 3
4412: PUSH
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: CALL_OW 3
4425: ST_TO_ADDR
// if b then
4426: LD_VAR 0 3
4430: IFFALSE 4452
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4432: LD_VAR 0 2
4436: PPUSH
4437: LD_VAR 0 3
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: PPUSH
4446: CALL_OW 52
4450: GO 4473
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4452: LD_VAR 0 2
4456: PPUSH
4457: LD_INT 61
4459: PPUSH
4460: LD_INT 89
4462: PPUSH
4463: LD_INT 8
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 50
// end ;
4473: GO 4279
4475: POP
4476: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4477: LD_INT 2
4479: PPUSH
4480: LD_INT 1
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: LD_INT 12
4488: PPUSH
4489: LD_INT 100
4491: PPUSH
4492: CALL 74431 0 5
// veh := CreateVehicle ;
4496: LD_ADDR_VAR 0 4
4500: PUSH
4501: CALL_OW 45
4505: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4506: LD_VAR 0 4
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4518: LD_VAR 0 4
4522: PPUSH
4523: LD_INT 49
4525: PPUSH
4526: LD_INT 88
4528: PPUSH
4529: LD_INT 0
4531: PPUSH
4532: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4536: LD_VAR 0 4
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: LD_INT 100
4546: PPUSH
4547: CALL_OW 290
// uc_side := 0 ;
4551: LD_ADDR_OWVAR 20
4555: PUSH
4556: LD_INT 0
4558: ST_TO_ADDR
// uc_nation := 0 ;
4559: LD_ADDR_OWVAR 21
4563: PUSH
4564: LD_INT 0
4566: ST_TO_ADDR
// for i := 1 to 3 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 3
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4612
// begin InitHc ;
4583: CALL_OW 19
// hc_class := class_apeman ;
4587: LD_ADDR_OWVAR 28
4591: PUSH
4592: LD_INT 12
4594: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4595: CALL_OW 44
4599: PPUSH
4600: LD_INT 13
4602: PPUSH
4603: LD_INT 0
4605: PPUSH
4606: CALL_OW 49
// end ;
4610: GO 4580
4612: POP
4613: POP
// end ; end_of_file
4614: LD_VAR 0 1
4618: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4619: LD_INT 0
4621: PPUSH
4622: PPUSH
4623: PPUSH
4624: PPUSH
4625: PPUSH
// side := 8 ;
4626: LD_ADDR_VAR 0 3
4630: PUSH
4631: LD_INT 8
4633: ST_TO_ADDR
// uc_side := side ;
4634: LD_ADDR_OWVAR 20
4638: PUSH
4639: LD_VAR 0 3
4643: ST_TO_ADDR
// uc_nation := 2 ;
4644: LD_ADDR_OWVAR 21
4648: PUSH
4649: LD_INT 2
4651: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4652: LD_ADDR_VAR 0 2
4656: PUSH
4657: LD_INT 22
4659: PUSH
4660: LD_VAR 0 3
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 21
4671: PUSH
4672: LD_INT 3
4674: PUSH
4675: EMPTY
4676: LIST
4677: LIST
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 69
4687: PUSH
4688: FOR_IN
4689: IFFALSE 4705
// SetBLevel ( i , 10 ) ;
4691: LD_VAR 0 2
4695: PPUSH
4696: LD_INT 10
4698: PPUSH
4699: CALL_OW 241
4703: GO 4688
4705: POP
4706: POP
// if KurtStatus then
4707: LD_EXP 3
4711: IFFALSE 4734
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4713: LD_ADDR_EXP 64
4717: PUSH
4718: LD_STRING Kurt
4720: PPUSH
4721: LD_INT 0
4723: PPUSH
4724: LD_STRING 
4726: PPUSH
4727: CALL 69591 0 3
4731: ST_TO_ADDR
4732: GO 4756
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4734: LD_ADDR_EXP 64
4738: PUSH
4739: LD_STRING AltKurt
4741: PPUSH
4742: LD_EXP 1
4746: NOT
4747: PPUSH
4748: LD_STRING 
4750: PPUSH
4751: CALL 69591 0 3
4755: ST_TO_ADDR
// if not Kurt then
4756: LD_EXP 64
4760: NOT
4761: IFFALSE 4787
// begin InitHc ;
4763: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4767: LD_INT 1
4769: PPUSH
4770: LD_INT 10
4772: PPUSH
4773: CALL_OW 381
// Kurt := CreateHuman ;
4777: LD_ADDR_EXP 64
4781: PUSH
4782: CALL_OW 44
4786: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4787: LD_EXP 64
4791: PPUSH
4792: LD_INT 324
4794: PPUSH
4795: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4799: LD_ADDR_EXP 65
4803: PUSH
4804: LD_STRING Kozlov
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: LD_STRING 
4812: PPUSH
4813: CALL 69591 0 3
4817: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4818: LD_EXP 65
4822: PPUSH
4823: LD_INT 22
4825: PUSH
4826: LD_INT 8
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 23
4835: PUSH
4836: LD_INT 3
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_INT 30
4845: PUSH
4846: LD_INT 8
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: LIST
4857: PPUSH
4858: CALL_OW 69
4862: PUSH
4863: LD_INT 1
4865: ARRAY
4866: PPUSH
4867: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4871: LD_EXP 65
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 10
4881: PPUSH
4882: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4886: LD_EXP 65
4890: PPUSH
4891: LD_INT 4
4893: PPUSH
4894: LD_INT 10
4896: PPUSH
4897: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4901: LD_ADDR_VAR 0 5
4905: PUSH
4906: LD_INT 22
4908: PUSH
4909: LD_VAR 0 3
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: LD_INT 30
4920: PUSH
4921: LD_INT 32
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: LD_INT 58
4930: PUSH
4931: EMPTY
4932: LIST
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: PPUSH
4939: CALL_OW 69
4943: ST_TO_ADDR
// for i = 1 to 10 do
4944: LD_ADDR_VAR 0 2
4948: PUSH
4949: DOUBLE
4950: LD_INT 1
4952: DEC
4953: ST_TO_ADDR
4954: LD_INT 10
4956: PUSH
4957: FOR_TO
4958: IFFALSE 5030
// begin uc_nation := nation_nature ;
4960: LD_ADDR_OWVAR 21
4964: PUSH
4965: LD_INT 0
4967: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4968: LD_ADDR_OWVAR 28
4972: PUSH
4973: LD_INT 15
4975: ST_TO_ADDR
// hc_gallery :=  ;
4976: LD_ADDR_OWVAR 33
4980: PUSH
4981: LD_STRING 
4983: ST_TO_ADDR
// hc_name :=  ;
4984: LD_ADDR_OWVAR 26
4988: PUSH
4989: LD_STRING 
4991: ST_TO_ADDR
// un := CreateHuman ;
4992: LD_ADDR_VAR 0 4
4996: PUSH
4997: CALL_OW 44
5001: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5002: LD_VAR 0 4
5006: PPUSH
5007: LD_VAR 0 5
5011: PUSH
5012: LD_VAR 0 5
5016: PUSH
5017: LD_VAR 0 2
5021: MINUS
5022: ARRAY
5023: PPUSH
5024: CALL_OW 52
// end ;
5028: GO 4957
5030: POP
5031: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_STRING 12_kurt_squad
5039: PPUSH
5040: CALL_OW 31
5044: ST_TO_ADDR
// if tmp then
5045: LD_VAR 0 5
5049: IFFALSE 5083
// for i in tmp do
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_VAR 0 5
5060: PUSH
5061: FOR_IN
5062: IFFALSE 5081
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5064: LD_VAR 0 2
5068: PPUSH
5069: LD_INT 5
5071: PPUSH
5072: LD_INT 0
5074: PPUSH
5075: CALL_OW 49
5079: GO 5061
5081: POP
5082: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5083: LD_INT 324
5085: PPUSH
5086: LD_INT 5
5088: PPUSH
5089: LD_STRING 
5091: PPUSH
5092: LD_INT 8
5094: PUSH
5095: LD_INT 9
5097: PUSH
5098: LD_INT 10
5100: PUSH
5101: LD_INT 10
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: PUSH
5110: LD_OWVAR 67
5114: ARRAY
5115: PPUSH
5116: LD_INT 3000
5118: PUSH
5119: LD_INT 500
5121: PUSH
5122: LD_INT 150
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: PPUSH
5130: LD_INT 16
5132: PUSH
5133: LD_INT 6
5135: PUSH
5136: LD_INT 6
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PPUSH
5148: CALL 78252 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5152: LD_ADDR_EXP 102
5156: PUSH
5157: LD_EXP 102
5161: PPUSH
5162: LD_INT 3
5164: PPUSH
5165: LD_INT 22
5167: PUSH
5168: LD_VAR 0 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 3
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 2
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: PUSH
5214: LD_EXP 64
5218: DIFF
5219: PPUSH
5220: CALL_OW 1
5224: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5225: LD_INT 1
5227: PPUSH
5228: LD_INT 7
5230: PPUSH
5231: CALL_OW 383
// hc_name := Ali Hadrach ;
5235: LD_ADDR_OWVAR 26
5239: PUSH
5240: LD_STRING Ali Hadrach
5242: ST_TO_ADDR
// hc_face_number := 31 ;
5243: LD_ADDR_OWVAR 34
5247: PUSH
5248: LD_INT 31
5250: ST_TO_ADDR
// Friend := CreateHuman ;
5251: LD_ADDR_EXP 66
5255: PUSH
5256: CALL_OW 44
5260: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5261: LD_INT 14
5263: PPUSH
5264: LD_INT 3
5266: PPUSH
5267: LD_INT 1
5269: PPUSH
5270: LD_INT 29
5272: PPUSH
5273: LD_INT 100
5275: PPUSH
5276: CALL 74431 0 5
// powellBomb := CreateVehicle ;
5280: LD_ADDR_EXP 67
5284: PUSH
5285: CALL_OW 45
5289: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5290: LD_EXP 67
5294: PPUSH
5295: LD_INT 90
5297: PPUSH
5298: LD_INT 51
5300: PPUSH
5301: LD_INT 0
5303: PPUSH
5304: CALL_OW 48
// end ;
5308: LD_VAR 0 1
5312: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5313: LD_INT 0
5315: PPUSH
5316: PPUSH
5317: PPUSH
// if IsLive ( kozlov_fac ) then
5318: LD_INT 332
5320: PPUSH
5321: CALL_OW 300
5325: IFFALSE 5329
// exit ;
5327: GO 5896
// ComExitBuilding ( Kozlov ) ;
5329: LD_EXP 65
5333: PPUSH
5334: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5338: LD_EXP 65
5342: PPUSH
5343: CALL_OW 257
5347: PUSH
5348: LD_INT 2
5350: NONEQUAL
5351: IFFALSE 5386
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5353: LD_EXP 65
5357: PPUSH
5358: LD_INT 324
5360: PPUSH
5361: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5365: LD_EXP 65
5369: PPUSH
5370: LD_INT 2
5372: PPUSH
5373: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5377: LD_EXP 65
5381: PPUSH
5382: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5386: LD_EXP 65
5390: PPUSH
5391: LD_INT 2
5393: PPUSH
5394: LD_INT 93
5396: PPUSH
5397: LD_INT 32
5399: PPUSH
5400: LD_INT 3
5402: PPUSH
5403: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5407: LD_INT 35
5409: PPUSH
5410: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5414: LD_INT 22
5416: PUSH
5417: LD_INT 8
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: PUSH
5424: LD_INT 30
5426: PUSH
5427: LD_INT 3
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PUSH
5434: LD_INT 23
5436: PUSH
5437: LD_INT 3
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 57
5446: PUSH
5447: EMPTY
5448: LIST
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: LIST
5454: LIST
5455: PPUSH
5456: CALL_OW 69
5460: IFFALSE 5407
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5462: LD_ADDR_VAR 0 2
5466: PUSH
5467: LD_INT 22
5469: PUSH
5470: LD_INT 8
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 30
5479: PUSH
5480: LD_INT 3
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PUSH
5487: LD_INT 23
5489: PUSH
5490: LD_INT 3
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 57
5499: PUSH
5500: EMPTY
5501: LIST
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5518: LD_INT 22
5520: PUSH
5521: LD_INT 8
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: PUSH
5528: LD_INT 23
5530: PUSH
5531: LD_INT 3
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 30
5540: PUSH
5541: LD_INT 21
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: PPUSH
5553: CALL_OW 69
5557: NOT
5558: IFFALSE 5636
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5560: LD_EXP 65
5564: PPUSH
5565: LD_INT 21
5567: PPUSH
5568: LD_INT 97
5570: PPUSH
5571: LD_INT 36
5573: PPUSH
5574: LD_INT 5
5576: PPUSH
5577: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5581: LD_INT 35
5583: PPUSH
5584: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5588: LD_INT 22
5590: PUSH
5591: LD_INT 8
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 23
5600: PUSH
5601: LD_INT 3
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 30
5610: PUSH
5611: LD_INT 21
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 57
5620: PUSH
5621: EMPTY
5622: LIST
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 69
5634: IFFALSE 5581
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5636: LD_INT 22
5638: PUSH
5639: LD_INT 8
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: LD_INT 23
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 30
5658: PUSH
5659: LD_INT 18
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: LIST
5670: PPUSH
5671: CALL_OW 69
5675: NOT
5676: IFFALSE 5754
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5678: LD_EXP 65
5682: PPUSH
5683: LD_INT 18
5685: PPUSH
5686: LD_INT 89
5688: PPUSH
5689: LD_INT 32
5691: PPUSH
5692: LD_INT 1
5694: PPUSH
5695: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5699: LD_INT 35
5701: PPUSH
5702: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5706: LD_INT 22
5708: PUSH
5709: LD_INT 8
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 23
5718: PUSH
5719: LD_INT 3
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 30
5728: PUSH
5729: LD_INT 18
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 57
5738: PUSH
5739: EMPTY
5740: LIST
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PPUSH
5748: CALL_OW 69
5752: IFFALSE 5699
// end ; lab := kozlov_lab ;
5754: LD_ADDR_VAR 0 3
5758: PUSH
5759: LD_INT 336
5761: ST_TO_ADDR
// if not lab then
5762: LD_VAR 0 3
5766: NOT
5767: IFFALSE 5771
// exit ;
5769: GO 5896
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5771: LD_EXP 65
5775: PPUSH
5776: LD_VAR 0 3
5780: PUSH
5781: LD_INT 1
5783: ARRAY
5784: PPUSH
5785: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5789: LD_EXP 65
5793: PPUSH
5794: LD_INT 4
5796: PPUSH
5797: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5801: LD_VAR 0 3
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PPUSH
5810: LD_INT 25
5812: PPUSH
5813: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5817: LD_INT 35
5819: PPUSH
5820: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5824: LD_INT 25
5826: PPUSH
5827: LD_INT 8
5829: PPUSH
5830: CALL_OW 321
5834: PUSH
5835: LD_INT 2
5837: EQUAL
5838: IFFALSE 5817
// ComExitBuilding ( Kozlov ) ;
5840: LD_EXP 65
5844: PPUSH
5845: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5849: LD_EXP 65
5853: PPUSH
5854: LD_VAR 0 2
5858: PPUSH
5859: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5863: LD_EXP 65
5867: PPUSH
5868: LD_INT 3
5870: PPUSH
5871: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5875: LD_VAR 0 2
5879: PPUSH
5880: LD_INT 23
5882: PPUSH
5883: LD_INT 3
5885: PPUSH
5886: LD_INT 1
5888: PPUSH
5889: LD_INT 48
5891: PPUSH
5892: CALL_OW 125
// end ;
5896: LD_VAR 0 1
5900: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5901: LD_EXP 22
5905: NOT
5906: PUSH
5907: LD_EXP 15
5911: PUSH
5912: LD_INT 6
5914: GREATEREQUAL
5915: AND
5916: IFFALSE 5997
5918: GO 5920
5920: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5921: LD_INT 3
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: CALL 63302 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5931: LD_INT 3
5933: PPUSH
5934: LD_INT 14
5936: PUSH
5937: LD_INT 1
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: LD_INT 28
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: PUSH
5952: LD_INT 14
5954: PUSH
5955: LD_INT 1
5957: PUSH
5958: LD_INT 1
5960: PUSH
5961: LD_INT 28
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: LIST
5968: LIST
5969: PUSH
5970: LD_INT 14
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: LD_INT 1
5978: PUSH
5979: LD_INT 28
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL 63165 0 2
// end ;
5997: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5998: LD_EXP 22
6002: NOT
6003: PUSH
6004: LD_EXP 15
6008: PUSH
6009: LD_INT 6
6011: GREATEREQUAL
6012: AND
6013: PUSH
6014: LD_INT 3
6016: PPUSH
6017: LD_INT 1
6019: PPUSH
6020: CALL 64583 0 2
6024: NOT
6025: AND
6026: IFFALSE 6973
6028: GO 6030
6030: DISABLE
6031: LD_INT 0
6033: PPUSH
6034: PPUSH
6035: PPUSH
6036: PPUSH
// begin enable ;
6037: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6038: LD_INT 22
6040: PUSH
6041: LD_INT 8
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 23
6050: PUSH
6051: LD_INT 2
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 30
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: PPUSH
6073: CALL_OW 69
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6973
// if Prob ( 40 ) then
6082: LD_INT 40
6084: PPUSH
6085: CALL_OW 13
6089: IFFALSE 6216
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6091: LD_INT 3
6093: PPUSH
6094: LD_INT 14
6096: PUSH
6097: LD_INT 1
6099: PUSH
6100: LD_INT 2
6102: PUSH
6103: LD_INT 28
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PUSH
6112: LD_INT 14
6114: PUSH
6115: LD_INT 1
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: LD_INT 28
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 14
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 14
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 28
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 14
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 28
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 14
6186: PUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 26
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL 63165 0 2
// end else
6214: GO 6423
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6216: LD_INT 3
6218: PPUSH
6219: LD_INT 14
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: LD_INT 2
6227: PUSH
6228: LD_INT 27
6230: PUSH
6231: LD_INT 26
6233: PUSH
6234: LD_INT 26
6236: PUSH
6237: LD_INT 28
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_OWVAR 67
6250: ARRAY
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 14
6260: PUSH
6261: LD_INT 1
6263: PUSH
6264: LD_INT 2
6266: PUSH
6267: LD_INT 27
6269: PUSH
6270: LD_INT 26
6272: PUSH
6273: LD_INT 26
6275: PUSH
6276: LD_INT 26
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: LIST
6283: LIST
6284: PUSH
6285: LD_OWVAR 67
6289: ARRAY
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 14
6299: PUSH
6300: LD_INT 1
6302: PUSH
6303: LD_INT 2
6305: PUSH
6306: LD_INT 26
6308: PUSH
6309: LD_INT 26
6311: PUSH
6312: LD_INT 29
6314: PUSH
6315: LD_INT 29
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: LD_OWVAR 67
6328: ARRAY
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 13
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 26
6347: PUSH
6348: LD_INT 29
6350: PUSH
6351: LD_INT 29
6353: PUSH
6354: LD_INT 29
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 13
6377: PUSH
6378: LD_INT 1
6380: PUSH
6381: LD_INT 2
6383: PUSH
6384: LD_INT 29
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PUSH
6393: LD_INT 14
6395: PUSH
6396: LD_INT 1
6398: PUSH
6399: LD_INT 2
6401: PUSH
6402: LD_INT 26
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: PPUSH
6419: CALL 63165 0 2
// end ; wait ( 2 2$00 ) ;
6423: LD_INT 4200
6425: PPUSH
6426: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 8
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 3
6457: PUSH
6458: LD_INT 34
6460: PUSH
6461: LD_INT 31
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 34
6470: PUSH
6471: LD_INT 32
6473: PUSH
6474: EMPTY
6475: LIST
6476: LIST
6477: PUSH
6478: LD_INT 34
6480: PUSH
6481: LD_INT 88
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: PPUSH
6499: CALL_OW 69
6503: PUSH
6504: LD_EXP 124
6508: PUSH
6509: LD_INT 3
6511: ARRAY
6512: DIFF
6513: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6514: LD_ADDR_EXP 121
6518: PUSH
6519: LD_EXP 121
6523: PPUSH
6524: LD_INT 3
6526: PPUSH
6527: LD_EXP 121
6531: PUSH
6532: LD_INT 3
6534: ARRAY
6535: PUSH
6536: LD_VAR 0 2
6540: DIFF
6541: PPUSH
6542: CALL_OW 1
6546: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6547: LD_ADDR_VAR 0 3
6551: PUSH
6552: LD_INT 0
6554: PPUSH
6555: LD_INT 2
6557: PPUSH
6558: CALL_OW 12
6562: ST_TO_ADDR
// if target then
6563: LD_VAR 0 3
6567: IFFALSE 6729
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6569: LD_ADDR_VAR 0 2
6573: PUSH
6574: LD_VAR 0 2
6578: PPUSH
6579: LD_INT 24
6581: PUSH
6582: LD_INT 250
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: PPUSH
6589: CALL_OW 72
6593: ST_TO_ADDR
// if not tmp then
6594: LD_VAR 0 2
6598: NOT
6599: IFFALSE 6603
// break ;
6601: GO 6727
// for i in tmp do
6603: LD_ADDR_VAR 0 1
6607: PUSH
6608: LD_VAR 0 2
6612: PUSH
6613: FOR_IN
6614: IFFALSE 6654
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6616: LD_VAR 0 1
6620: PPUSH
6621: LD_INT 89
6623: PPUSH
6624: LD_INT 71
6626: PPUSH
6627: CALL_OW 297
6631: PUSH
6632: LD_INT 9
6634: GREATER
6635: IFFALSE 6652
// ComMoveXY ( i , 89 , 71 ) ;
6637: LD_VAR 0 1
6641: PPUSH
6642: LD_INT 89
6644: PPUSH
6645: LD_INT 71
6647: PPUSH
6648: CALL_OW 111
6652: GO 6613
6654: POP
6655: POP
// wait ( 0 0$1 ) ;
6656: LD_INT 35
6658: PPUSH
6659: CALL_OW 67
// p := Inc ( p ) ;
6663: LD_ADDR_VAR 0 4
6667: PUSH
6668: LD_VAR 0 4
6672: PPUSH
6673: CALL 108643 0 1
6677: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 92
6685: PUSH
6686: LD_INT 89
6688: PUSH
6689: LD_INT 71
6691: PUSH
6692: LD_INT 9
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: PPUSH
6701: CALL_OW 72
6705: PUSH
6706: LD_VAR 0 2
6710: PUSH
6711: LD_INT 1
6713: MINUS
6714: GREATEREQUAL
6715: PUSH
6716: LD_VAR 0 4
6720: PUSH
6721: LD_INT 30
6723: GREATER
6724: OR
6725: IFFALSE 6569
// end else
6727: GO 6887
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6729: LD_ADDR_VAR 0 2
6733: PUSH
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 24
6741: PUSH
6742: LD_INT 250
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: PPUSH
6749: CALL_OW 72
6753: ST_TO_ADDR
// if not tmp then
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6763
// break ;
6761: GO 6887
// for i in tmp do
6763: LD_ADDR_VAR 0 1
6767: PUSH
6768: LD_VAR 0 2
6772: PUSH
6773: FOR_IN
6774: IFFALSE 6814
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6776: LD_VAR 0 1
6780: PPUSH
6781: LD_INT 125
6783: PPUSH
6784: LD_INT 129
6786: PPUSH
6787: CALL_OW 297
6791: PUSH
6792: LD_INT 9
6794: GREATER
6795: IFFALSE 6812
// ComMoveXY ( i , 125 , 129 ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 125
6804: PPUSH
6805: LD_INT 129
6807: PPUSH
6808: CALL_OW 111
6812: GO 6773
6814: POP
6815: POP
// wait ( 0 0$1 ) ;
6816: LD_INT 35
6818: PPUSH
6819: CALL_OW 67
// p := Inc ( p ) ;
6823: LD_ADDR_VAR 0 4
6827: PUSH
6828: LD_VAR 0 4
6832: PPUSH
6833: CALL 108643 0 1
6837: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6838: LD_VAR 0 2
6842: PPUSH
6843: LD_INT 92
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 129
6851: PUSH
6852: LD_INT 9
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL_OW 72
6865: PUSH
6866: LD_VAR 0 2
6870: PUSH
6871: LD_INT 1
6873: MINUS
6874: GREATEREQUAL
6875: PUSH
6876: LD_VAR 0 4
6880: PUSH
6881: LD_INT 30
6883: GREATER
6884: OR
6885: IFFALSE 6729
// end ; repeat wait ( 0 0$1 ) ;
6887: LD_INT 35
6889: PPUSH
6890: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6894: LD_ADDR_VAR 0 2
6898: PUSH
6899: LD_VAR 0 2
6903: PPUSH
6904: LD_INT 50
6906: PUSH
6907: EMPTY
6908: LIST
6909: PPUSH
6910: CALL_OW 72
6914: ST_TO_ADDR
// for i in tmp do
6915: LD_ADDR_VAR 0 1
6919: PUSH
6920: LD_VAR 0 2
6924: PUSH
6925: FOR_IN
6926: IFFALSE 6964
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6928: LD_VAR 0 1
6932: PPUSH
6933: LD_INT 81
6935: PUSH
6936: LD_INT 8
6938: PUSH
6939: EMPTY
6940: LIST
6941: LIST
6942: PPUSH
6943: CALL_OW 69
6947: PPUSH
6948: LD_VAR 0 1
6952: PPUSH
6953: CALL_OW 74
6957: PPUSH
6958: CALL_OW 115
6962: GO 6925
6964: POP
6965: POP
// until not tmp ;
6966: LD_VAR 0 2
6970: NOT
6971: IFFALSE 6887
// end ;
6973: PPOPN 4
6975: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6976: LD_EXP 22
6980: NOT
6981: PUSH
6982: LD_EXP 15
6986: PUSH
6987: LD_INT 6
6989: GREATEREQUAL
6990: AND
6991: PUSH
6992: LD_OWVAR 67
6996: PUSH
6997: LD_INT 1
6999: GREATER
7000: AND
7001: IFFALSE 7534
7003: GO 7005
7005: DISABLE
7006: LD_INT 0
7008: PPUSH
7009: PPUSH
7010: PPUSH
// begin enable ;
7011: ENABLE
// tmp := [ ] ;
7012: LD_ADDR_VAR 0 3
7016: PUSH
7017: EMPTY
7018: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7019: LD_ADDR_VAR 0 1
7023: PUSH
7024: DOUBLE
7025: LD_INT 1
7027: DEC
7028: ST_TO_ADDR
7029: LD_INT 4
7031: PUSH
7032: LD_INT 6
7034: PUSH
7035: LD_INT 7
7037: PUSH
7038: LD_INT 8
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: PUSH
7047: LD_OWVAR 67
7051: ARRAY
7052: PUSH
7053: FOR_TO
7054: IFFALSE 7214
// begin uc_side := 8 ;
7056: LD_ADDR_OWVAR 20
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// uc_nation := 2 ;
7064: LD_ADDR_OWVAR 21
7068: PUSH
7069: LD_INT 2
7071: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7072: LD_INT 13
7074: PUSH
7075: LD_INT 14
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 1
7084: PPUSH
7085: LD_INT 2
7087: PPUSH
7088: CALL_OW 12
7092: ARRAY
7093: PPUSH
7094: LD_INT 1
7096: PPUSH
7097: LD_INT 5
7099: PPUSH
7100: LD_INT 27
7102: PUSH
7103: LD_INT 28
7105: PUSH
7106: LD_INT 26
7108: PUSH
7109: LD_INT 25
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: LIST
7116: LIST
7117: PUSH
7118: LD_INT 1
7120: PPUSH
7121: LD_INT 4
7123: PPUSH
7124: CALL_OW 12
7128: ARRAY
7129: PPUSH
7130: LD_INT 88
7132: PPUSH
7133: CALL 74431 0 5
// un := CreateVehicle ;
7137: LD_ADDR_VAR 0 2
7141: PUSH
7142: CALL_OW 45
7146: ST_TO_ADDR
// tmp := tmp ^ un ;
7147: LD_ADDR_VAR 0 3
7151: PUSH
7152: LD_VAR 0 3
7156: PUSH
7157: LD_VAR 0 2
7161: ADD
7162: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7163: LD_VAR 0 2
7167: PPUSH
7168: LD_INT 3
7170: PPUSH
7171: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7175: LD_VAR 0 2
7179: PPUSH
7180: LD_INT 30
7182: PPUSH
7183: LD_INT 0
7185: PPUSH
7186: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7190: LD_VAR 0 2
7194: PPUSH
7195: LD_INT 16
7197: PPUSH
7198: LD_INT 11
7200: PPUSH
7201: CALL_OW 111
// wait ( 0 0$2 ) ;
7205: LD_INT 70
7207: PPUSH
7208: CALL_OW 67
// end ;
7212: GO 7053
7214: POP
7215: POP
// for i = 1 to Difficulty do
7216: LD_ADDR_VAR 0 1
7220: PUSH
7221: DOUBLE
7222: LD_INT 1
7224: DEC
7225: ST_TO_ADDR
7226: LD_OWVAR 67
7230: PUSH
7231: FOR_TO
7232: IFFALSE 7361
// begin uc_side := 8 ;
7234: LD_ADDR_OWVAR 20
7238: PUSH
7239: LD_INT 8
7241: ST_TO_ADDR
// uc_nation := 2 ;
7242: LD_ADDR_OWVAR 21
7246: PUSH
7247: LD_INT 2
7249: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7250: LD_INT 0
7252: PPUSH
7253: LD_INT 8
7255: PPUSH
7256: LD_INT 8
7258: PUSH
7259: LD_INT 8
7261: PUSH
7262: LD_INT 9
7264: PUSH
7265: LD_INT 10
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: PUSH
7274: LD_OWVAR 67
7278: ARRAY
7279: PPUSH
7280: CALL_OW 380
// un := CreateHuman ;
7284: LD_ADDR_VAR 0 2
7288: PUSH
7289: CALL_OW 44
7293: ST_TO_ADDR
// tmp := tmp ^ un ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: ADD
7309: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7310: LD_VAR 0 2
7314: PPUSH
7315: LD_INT 3
7317: PPUSH
7318: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_INT 30
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7337: LD_VAR 0 2
7341: PPUSH
7342: LD_INT 16
7344: PPUSH
7345: LD_INT 11
7347: PPUSH
7348: CALL_OW 111
// wait ( 0 0$2 ) ;
7352: LD_INT 70
7354: PPUSH
7355: CALL_OW 67
// end ;
7359: GO 7231
7361: POP
7362: POP
// repeat wait ( 0 0$1 ) ;
7363: LD_INT 35
7365: PPUSH
7366: CALL_OW 67
// if legionDestroyed then
7370: LD_EXP 22
7374: IFFALSE 7378
// exit ;
7376: GO 7534
// for i in tmp do
7378: LD_ADDR_VAR 0 1
7382: PUSH
7383: LD_VAR 0 3
7387: PUSH
7388: FOR_IN
7389: IFFALSE 7525
// begin if GetLives ( i ) > 250 then
7391: LD_VAR 0 1
7395: PPUSH
7396: CALL_OW 256
7400: PUSH
7401: LD_INT 250
7403: GREATER
7404: IFFALSE 7496
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7406: LD_INT 81
7408: PUSH
7409: LD_INT 8
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 91
7418: PUSH
7419: LD_VAR 0 1
7423: PUSH
7424: LD_INT 10
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PPUSH
7436: CALL_OW 69
7440: NOT
7441: IFFALSE 7460
// ComAgressiveMove ( i , 67 , 110 ) else
7443: LD_VAR 0 1
7447: PPUSH
7448: LD_INT 67
7450: PPUSH
7451: LD_INT 110
7453: PPUSH
7454: CALL_OW 114
7458: GO 7494
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7460: LD_VAR 0 1
7464: PPUSH
7465: LD_INT 81
7467: PUSH
7468: LD_INT 8
7470: PUSH
7471: EMPTY
7472: LIST
7473: LIST
7474: PPUSH
7475: CALL_OW 69
7479: PPUSH
7480: LD_VAR 0 1
7484: PPUSH
7485: CALL_OW 74
7489: PPUSH
7490: CALL_OW 115
// end else
7494: GO 7523
// if IsDead ( i ) then
7496: LD_VAR 0 1
7500: PPUSH
7501: CALL_OW 301
7505: IFFALSE 7523
// tmp := tmp diff i ;
7507: LD_ADDR_VAR 0 3
7511: PUSH
7512: LD_VAR 0 3
7516: PUSH
7517: LD_VAR 0 1
7521: DIFF
7522: ST_TO_ADDR
// end ;
7523: GO 7388
7525: POP
7526: POP
// until not tmp ;
7527: LD_VAR 0 3
7531: NOT
7532: IFFALSE 7363
// end ; end_of_file
7534: PPOPN 3
7536: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7537: LD_INT 0
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
7547: PPUSH
7548: PPUSH
// side := 3 ;
7549: LD_ADDR_VAR 0 6
7553: PUSH
7554: LD_INT 3
7556: ST_TO_ADDR
// uc_side := side ;
7557: LD_ADDR_OWVAR 20
7561: PUSH
7562: LD_VAR 0 6
7566: ST_TO_ADDR
// uc_nation := 3 ;
7567: LD_ADDR_OWVAR 21
7571: PUSH
7572: LD_INT 3
7574: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7575: LD_ADDR_VAR 0 2
7579: PUSH
7580: LD_INT 22
7582: PUSH
7583: LD_VAR 0 6
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 21
7594: PUSH
7595: LD_INT 3
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PPUSH
7606: CALL_OW 69
7610: PUSH
7611: FOR_IN
7612: IFFALSE 7628
// SetBLevel ( i , 10 ) ;
7614: LD_VAR 0 2
7618: PPUSH
7619: LD_INT 10
7621: PPUSH
7622: CALL_OW 241
7626: GO 7611
7628: POP
7629: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7630: LD_ADDR_VAR 0 10
7634: PUSH
7635: LD_INT 22
7637: PUSH
7638: LD_VAR 0 6
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 30
7649: PUSH
7650: LD_INT 34
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PPUSH
7661: CALL_OW 69
7665: ST_TO_ADDR
// if teleport then
7666: LD_VAR 0 10
7670: IFFALSE 7691
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7672: LD_VAR 0 10
7676: PUSH
7677: LD_INT 1
7679: ARRAY
7680: PPUSH
7681: LD_INT 123
7683: PPUSH
7684: LD_INT 122
7686: PPUSH
7687: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7691: LD_ADDR_EXP 68
7695: PUSH
7696: LD_STRING Platonov
7698: PPUSH
7699: CALL_OW 25
7703: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7704: LD_ADDR_EXP 69
7708: PUSH
7709: LD_STRING Kovalyuk
7711: PPUSH
7712: CALL_OW 25
7716: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7717: LD_ADDR_EXP 71
7721: PUSH
7722: LD_STRING Yakotich
7724: PPUSH
7725: LD_EXP 1
7729: NOT
7730: PPUSH
7731: LD_STRING 09_
7733: PPUSH
7734: CALL 69591 0 3
7738: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7739: LD_ADDR_EXP 70
7743: PUSH
7744: LD_STRING Bystrov
7746: PPUSH
7747: CALL_OW 25
7751: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7752: LD_ADDR_EXP 72
7756: PUSH
7757: LD_STRING Gleb
7759: PPUSH
7760: CALL_OW 25
7764: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7765: LD_STRING 03_Cornel
7767: PPUSH
7768: CALL_OW 28
7772: IFFALSE 7820
// begin Bierezov := NewCharacter ( Mikhail ) ;
7774: LD_ADDR_EXP 73
7778: PUSH
7779: LD_STRING Mikhail
7781: PPUSH
7782: CALL_OW 25
7786: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7787: LD_EXP 73
7791: PPUSH
7792: LD_INT 197
7794: PPUSH
7795: LD_INT 111
7797: PPUSH
7798: LD_INT 9
7800: PPUSH
7801: LD_INT 0
7803: PPUSH
7804: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7808: LD_EXP 73
7812: PPUSH
7813: LD_INT 3
7815: PPUSH
7816: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7820: LD_EXP 68
7824: PPUSH
7825: LD_INT 126
7827: PPUSH
7828: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7832: LD_EXP 69
7836: PPUSH
7837: LD_INT 134
7839: PPUSH
7840: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7844: LD_EXP 71
7848: PPUSH
7849: LD_INT 197
7851: PPUSH
7852: LD_INT 111
7854: PPUSH
7855: LD_INT 9
7857: PPUSH
7858: LD_INT 0
7860: PPUSH
7861: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7865: LD_EXP 70
7869: PPUSH
7870: LD_INT 197
7872: PPUSH
7873: LD_INT 111
7875: PPUSH
7876: LD_INT 9
7878: PPUSH
7879: LD_INT 0
7881: PPUSH
7882: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7886: LD_EXP 72
7890: PPUSH
7891: LD_INT 197
7893: PPUSH
7894: LD_INT 111
7896: PPUSH
7897: LD_INT 9
7899: PPUSH
7900: LD_INT 0
7902: PPUSH
7903: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7907: LD_ADDR_VAR 0 5
7911: PUSH
7912: LD_INT 126
7914: PPUSH
7915: LD_INT 4
7917: PPUSH
7918: LD_STRING zhukov
7920: PPUSH
7921: LD_INT 9
7923: PUSH
7924: LD_INT 10
7926: PUSH
7927: LD_INT 10
7929: PUSH
7930: LD_INT 10
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_OWVAR 67
7943: ARRAY
7944: PPUSH
7945: LD_INT 90000
7947: PUSH
7948: LD_INT 1000
7950: PUSH
7951: LD_INT 300
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: LIST
7958: PPUSH
7959: LD_INT 18
7961: PUSH
7962: LD_INT 8
7964: PUSH
7965: LD_INT 12
7967: PUSH
7968: LD_INT 6
7970: PUSH
7971: EMPTY
7972: LIST
7973: LIST
7974: LIST
7975: LIST
7976: PPUSH
7977: CALL 78252 0 6
7981: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7982: LD_ADDR_EXP 102
7986: PUSH
7987: LD_EXP 102
7991: PPUSH
7992: LD_INT 2
7994: PPUSH
7995: LD_VAR 0 5
7999: PUSH
8000: LD_EXP 71
8004: PUSH
8005: LD_EXP 70
8009: PUSH
8010: LD_EXP 72
8014: PUSH
8015: LD_EXP 73
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: LIST
8024: LIST
8025: UNION
8026: PPUSH
8027: CALL_OW 1
8031: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8032: LD_ADDR_VAR 0 4
8036: PUSH
8037: LD_INT 267
8039: PPUSH
8040: CALL_OW 274
8044: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8045: LD_VAR 0 4
8049: PPUSH
8050: LD_INT 1
8052: PPUSH
8053: LD_INT 5000
8055: PPUSH
8056: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8060: LD_VAR 0 4
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_INT 200
8070: PPUSH
8071: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8075: LD_VAR 0 4
8079: PPUSH
8080: LD_INT 3
8082: PPUSH
8083: LD_INT 200
8085: PPUSH
8086: CALL_OW 277
// for i := 1 to 6 do
8090: LD_ADDR_VAR 0 2
8094: PUSH
8095: DOUBLE
8096: LD_INT 1
8098: DEC
8099: ST_TO_ADDR
8100: LD_INT 6
8102: PUSH
8103: FOR_TO
8104: IFFALSE 8187
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8106: LD_INT 0
8108: PPUSH
8109: LD_INT 8
8111: PUSH
8112: LD_INT 9
8114: PUSH
8115: LD_INT 10
8117: PUSH
8118: LD_INT 10
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PPUSH
8133: CALL_OW 381
// un := CreateHuman ;
8137: LD_ADDR_VAR 0 8
8141: PUSH
8142: CALL_OW 44
8146: ST_TO_ADDR
// if i mod 2 = 0 then
8147: LD_VAR 0 2
8151: PUSH
8152: LD_INT 2
8154: MOD
8155: PUSH
8156: LD_INT 0
8158: EQUAL
8159: IFFALSE 8173
// SetClass ( un , class_bazooker ) ;
8161: LD_VAR 0 8
8165: PPUSH
8166: LD_INT 9
8168: PPUSH
8169: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8173: LD_VAR 0 8
8177: PPUSH
8178: LD_INT 460
8180: PPUSH
8181: CALL_OW 52
// end ;
8185: GO 8103
8187: POP
8188: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8189: LD_INT 21
8191: PPUSH
8192: LD_INT 3
8194: PPUSH
8195: LD_INT 3
8197: PPUSH
8198: LD_INT 52
8200: PPUSH
8201: LD_INT 100
8203: PPUSH
8204: CALL 74431 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8208: CALL_OW 45
8212: PPUSH
8213: LD_INT 259
8215: PPUSH
8216: LD_INT 145
8218: PPUSH
8219: LD_INT 3
8221: PPUSH
8222: LD_INT 0
8224: PPUSH
8225: CALL 109422 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8229: CALL_OW 45
8233: PPUSH
8234: LD_INT 245
8236: PPUSH
8237: LD_INT 139
8239: PPUSH
8240: LD_INT 3
8242: PPUSH
8243: LD_INT 0
8245: PPUSH
8246: CALL 109422 0 5
// behemoths := [ ] ;
8250: LD_ADDR_EXP 76
8254: PUSH
8255: EMPTY
8256: ST_TO_ADDR
// behemothBuilders := [ ] ;
8257: LD_ADDR_EXP 77
8261: PUSH
8262: EMPTY
8263: ST_TO_ADDR
// if Kovalyuk then
8264: LD_EXP 69
8268: IFFALSE 8290
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8270: LD_ADDR_EXP 77
8274: PUSH
8275: LD_EXP 77
8279: PPUSH
8280: LD_EXP 69
8284: PPUSH
8285: CALL 107282 0 2
8289: ST_TO_ADDR
// j := 3 ;
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: LD_INT 3
8297: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8298: LD_ADDR_VAR 0 2
8302: PUSH
8303: LD_INT 22
8305: PUSH
8306: LD_INT 3
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PUSH
8313: LD_INT 25
8315: PUSH
8316: LD_INT 3
8318: PUSH
8319: EMPTY
8320: LIST
8321: LIST
8322: PUSH
8323: EMPTY
8324: LIST
8325: LIST
8326: PPUSH
8327: CALL_OW 69
8331: PUSH
8332: LD_EXP 69
8336: DIFF
8337: PUSH
8338: FOR_IN
8339: IFFALSE 8389
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8341: LD_ADDR_EXP 77
8345: PUSH
8346: LD_EXP 77
8350: PPUSH
8351: LD_VAR 0 2
8355: PPUSH
8356: CALL 107282 0 2
8360: ST_TO_ADDR
// j := j - 1 ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_VAR 0 3
8370: PUSH
8371: LD_INT 1
8373: MINUS
8374: ST_TO_ADDR
// if j = 0 then
8375: LD_VAR 0 3
8379: PUSH
8380: LD_INT 0
8382: EQUAL
8383: IFFALSE 8387
// break ;
8385: GO 8389
// end ;
8387: GO 8338
8389: POP
8390: POP
// end ;
8391: LD_VAR 0 1
8395: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8396: LD_INT 0
8398: PPUSH
8399: PPUSH
8400: PPUSH
8401: PPUSH
8402: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8403: LD_ADDR_VAR 0 4
8407: PUSH
8408: LD_INT 209
8410: PUSH
8411: LD_INT 149
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 219
8420: PUSH
8421: LD_INT 154
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: LD_INT 223
8430: PUSH
8431: LD_INT 149
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PUSH
8438: LD_INT 232
8440: PUSH
8441: LD_INT 155
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: LIST
8453: ST_TO_ADDR
// if not behemothBuilders then
8454: LD_EXP 77
8458: NOT
8459: IFFALSE 8463
// exit ;
8461: GO 8594
// j := 1 ;
8463: LD_ADDR_VAR 0 3
8467: PUSH
8468: LD_INT 1
8470: ST_TO_ADDR
// for i in behemothBuilders do
8471: LD_ADDR_VAR 0 2
8475: PUSH
8476: LD_EXP 77
8480: PUSH
8481: FOR_IN
8482: IFFALSE 8592
// begin if GetClass ( i ) <> class_mechanic then
8484: LD_VAR 0 2
8488: PPUSH
8489: CALL_OW 257
8493: PUSH
8494: LD_INT 3
8496: NONEQUAL
8497: IFFALSE 8511
// SetClass ( i , class_mechanic ) ;
8499: LD_VAR 0 2
8503: PPUSH
8504: LD_INT 3
8506: PPUSH
8507: CALL_OW 336
// if IsInUnit ( i ) then
8511: LD_VAR 0 2
8515: PPUSH
8516: CALL_OW 310
8520: IFFALSE 8531
// ComExitBuilding ( i ) ;
8522: LD_VAR 0 2
8526: PPUSH
8527: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8531: LD_VAR 0 2
8535: PPUSH
8536: LD_INT 37
8538: PPUSH
8539: LD_VAR 0 4
8543: PUSH
8544: LD_VAR 0 3
8548: ARRAY
8549: PUSH
8550: LD_INT 1
8552: ARRAY
8553: PPUSH
8554: LD_VAR 0 4
8558: PUSH
8559: LD_VAR 0 3
8563: ARRAY
8564: PUSH
8565: LD_INT 2
8567: ARRAY
8568: PPUSH
8569: LD_INT 0
8571: PPUSH
8572: CALL_OW 230
// j := j + 1 ;
8576: LD_ADDR_VAR 0 3
8580: PUSH
8581: LD_VAR 0 3
8585: PUSH
8586: LD_INT 1
8588: PLUS
8589: ST_TO_ADDR
// end ;
8590: GO 8481
8592: POP
8593: POP
// end ;
8594: LD_VAR 0 1
8598: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8599: LD_INT 24
8601: PPUSH
8602: LD_INT 30
8604: PUSH
8605: LD_INT 37
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PPUSH
8612: CALL_OW 70
8616: IFFALSE 8629
8618: GO 8620
8620: DISABLE
// behemothUnderConstruct := true ;
8621: LD_ADDR_EXP 26
8625: PUSH
8626: LD_INT 1
8628: ST_TO_ADDR
8629: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8630: LD_INT 3
8632: PPUSH
8633: CALL 107343 0 1
8637: PUSH
8638: LD_INT 22
8640: PUSH
8641: LD_INT 3
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: PUSH
8648: LD_INT 30
8650: PUSH
8651: LD_INT 37
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: PPUSH
8662: CALL_OW 69
8666: NOT
8667: AND
8668: IFFALSE 8854
8670: GO 8672
8672: DISABLE
8673: LD_INT 0
8675: PPUSH
8676: PPUSH
// begin enable ;
8677: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8678: LD_ADDR_VAR 0 2
8682: PUSH
8683: LD_INT 3
8685: PPUSH
8686: CALL 107343 0 1
8690: ST_TO_ADDR
// for i in tmp do
8691: LD_ADDR_VAR 0 1
8695: PUSH
8696: LD_VAR 0 2
8700: PUSH
8701: FOR_IN
8702: IFFALSE 8852
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8704: LD_VAR 0 1
8708: PPUSH
8709: LD_INT 9
8711: PPUSH
8712: CALL_OW 308
8716: PUSH
8717: LD_VAR 0 1
8721: PPUSH
8722: CALL_OW 110
8726: PUSH
8727: LD_INT 2
8729: EQUAL
8730: NOT
8731: AND
8732: IFFALSE 8746
// SetTag ( i , 2 ) ;
8734: LD_VAR 0 1
8738: PPUSH
8739: LD_INT 2
8741: PPUSH
8742: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8746: LD_INT 81
8748: PUSH
8749: LD_INT 3
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: PUSH
8756: LD_INT 91
8758: PUSH
8759: LD_VAR 0 1
8763: PUSH
8764: LD_INT 12
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: LIST
8771: PUSH
8772: EMPTY
8773: LIST
8774: LIST
8775: PPUSH
8776: CALL_OW 69
8780: NOT
8781: PUSH
8782: LD_VAR 0 1
8786: PPUSH
8787: CALL_OW 110
8791: PUSH
8792: LD_INT 2
8794: EQUAL
8795: NOT
8796: AND
8797: IFFALSE 8816
// ComAgressiveMove ( i , 64 , 93 ) else
8799: LD_VAR 0 1
8803: PPUSH
8804: LD_INT 64
8806: PPUSH
8807: LD_INT 93
8809: PPUSH
8810: CALL_OW 114
8814: GO 8850
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8816: LD_VAR 0 1
8820: PPUSH
8821: LD_INT 81
8823: PUSH
8824: LD_INT 3
8826: PUSH
8827: EMPTY
8828: LIST
8829: LIST
8830: PPUSH
8831: CALL_OW 69
8835: PPUSH
8836: LD_VAR 0 1
8840: PPUSH
8841: CALL_OW 74
8845: PPUSH
8846: CALL_OW 115
// end ;
8850: GO 8701
8852: POP
8853: POP
// end ;
8854: PPOPN 2
8856: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8857: LD_INT 0
8859: PPUSH
8860: PPUSH
8861: PPUSH
// result := [ ] ;
8862: LD_ADDR_VAR 0 2
8866: PUSH
8867: EMPTY
8868: ST_TO_ADDR
// uc_side := 6 ;
8869: LD_ADDR_OWVAR 20
8873: PUSH
8874: LD_INT 6
8876: ST_TO_ADDR
// uc_nation := 3 ;
8877: LD_ADDR_OWVAR 21
8881: PUSH
8882: LD_INT 3
8884: ST_TO_ADDR
// case strength of 1 :
8885: LD_VAR 0 1
8889: PUSH
8890: LD_INT 1
8892: DOUBLE
8893: EQUAL
8894: IFTRUE 8898
8896: GO 9040
8898: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8899: LD_ADDR_VAR 0 3
8903: PUSH
8904: DOUBLE
8905: LD_INT 1
8907: DEC
8908: ST_TO_ADDR
8909: LD_INT 4
8911: PUSH
8912: LD_INT 5
8914: PUSH
8915: LD_INT 6
8917: PUSH
8918: LD_INT 7
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: PUSH
8927: LD_OWVAR 67
8931: ARRAY
8932: PUSH
8933: FOR_TO
8934: IFFALSE 9036
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8936: LD_INT 22
8938: PUSH
8939: LD_INT 24
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PUSH
8946: LD_VAR 0 3
8950: PUSH
8951: LD_INT 2
8953: MOD
8954: PUSH
8955: LD_INT 1
8957: PLUS
8958: ARRAY
8959: PPUSH
8960: LD_INT 1
8962: PUSH
8963: LD_INT 3
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: PUSH
8970: LD_INT 1
8972: PPUSH
8973: LD_INT 2
8975: PPUSH
8976: CALL_OW 12
8980: ARRAY
8981: PPUSH
8982: LD_INT 3
8984: PPUSH
8985: LD_INT 43
8987: PUSH
8988: LD_INT 44
8990: PUSH
8991: LD_INT 45
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: LIST
8998: PUSH
8999: LD_INT 1
9001: PPUSH
9002: LD_INT 3
9004: PPUSH
9005: CALL_OW 12
9009: ARRAY
9010: PPUSH
9011: LD_INT 80
9013: PPUSH
9014: CALL 74431 0 5
// result := result union CreateVehicle ;
9018: LD_ADDR_VAR 0 2
9022: PUSH
9023: LD_VAR 0 2
9027: PUSH
9028: CALL_OW 45
9032: UNION
9033: ST_TO_ADDR
// end ;
9034: GO 8933
9036: POP
9037: POP
// end ; 2 :
9038: GO 10035
9040: LD_INT 2
9042: DOUBLE
9043: EQUAL
9044: IFTRUE 9048
9046: GO 9216
9048: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9049: LD_ADDR_VAR 0 3
9053: PUSH
9054: DOUBLE
9055: LD_INT 1
9057: DEC
9058: ST_TO_ADDR
9059: LD_INT 5
9061: PUSH
9062: LD_INT 6
9064: PUSH
9065: LD_INT 7
9067: PUSH
9068: LD_INT 8
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_OWVAR 67
9081: ARRAY
9082: PUSH
9083: FOR_TO
9084: IFFALSE 9212
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9086: LD_INT 22
9088: PUSH
9089: LD_INT 24
9091: PUSH
9092: LD_INT 24
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: PUSH
9100: LD_VAR 0 3
9104: PUSH
9105: LD_INT 3
9107: MOD
9108: PUSH
9109: LD_INT 1
9111: PLUS
9112: ARRAY
9113: PPUSH
9114: LD_INT 1
9116: PUSH
9117: LD_INT 3
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 1
9126: PPUSH
9127: LD_INT 2
9129: PPUSH
9130: CALL_OW 12
9134: ARRAY
9135: PPUSH
9136: LD_INT 3
9138: PPUSH
9139: LD_INT 43
9141: PUSH
9142: LD_INT 44
9144: PUSH
9145: LD_INT 45
9147: PUSH
9148: LD_INT 44
9150: PUSH
9151: LD_INT 46
9153: PUSH
9154: LD_INT 46
9156: PUSH
9157: LD_INT 49
9159: PUSH
9160: LD_INT 49
9162: PUSH
9163: EMPTY
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: PUSH
9173: LD_VAR 0 3
9177: PUSH
9178: LD_INT 8
9180: MOD
9181: PUSH
9182: LD_INT 1
9184: PLUS
9185: ARRAY
9186: PPUSH
9187: LD_INT 80
9189: PPUSH
9190: CALL 74431 0 5
// result := result union CreateVehicle ;
9194: LD_ADDR_VAR 0 2
9198: PUSH
9199: LD_VAR 0 2
9203: PUSH
9204: CALL_OW 45
9208: UNION
9209: ST_TO_ADDR
// end ;
9210: GO 9083
9212: POP
9213: POP
// end ; 3 :
9214: GO 10035
9216: LD_INT 3
9218: DOUBLE
9219: EQUAL
9220: IFTRUE 9224
9222: GO 9396
9224: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9225: LD_ADDR_VAR 0 3
9229: PUSH
9230: DOUBLE
9231: LD_INT 1
9233: DEC
9234: ST_TO_ADDR
9235: LD_INT 6
9237: PUSH
9238: LD_INT 7
9240: PUSH
9241: LD_INT 8
9243: PUSH
9244: LD_INT 9
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: LIST
9251: LIST
9252: PUSH
9253: LD_OWVAR 67
9257: ARRAY
9258: PUSH
9259: FOR_TO
9260: IFFALSE 9392
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9262: LD_INT 22
9264: PUSH
9265: LD_INT 24
9267: PUSH
9268: LD_INT 24
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: LIST
9275: PUSH
9276: LD_VAR 0 3
9280: PUSH
9281: LD_INT 3
9283: MOD
9284: PUSH
9285: LD_INT 1
9287: PLUS
9288: ARRAY
9289: PPUSH
9290: LD_INT 1
9292: PUSH
9293: LD_INT 3
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: PUSH
9300: LD_INT 1
9302: PPUSH
9303: LD_INT 2
9305: PPUSH
9306: CALL_OW 12
9310: ARRAY
9311: PPUSH
9312: LD_INT 3
9314: PPUSH
9315: LD_INT 43
9317: PUSH
9318: LD_INT 47
9320: PUSH
9321: LD_INT 45
9323: PUSH
9324: LD_INT 45
9326: PUSH
9327: LD_INT 46
9329: PUSH
9330: LD_INT 46
9332: PUSH
9333: LD_INT 49
9335: PUSH
9336: LD_INT 49
9338: PUSH
9339: LD_INT 49
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: LIST
9351: LIST
9352: PUSH
9353: LD_VAR 0 3
9357: PUSH
9358: LD_INT 9
9360: MOD
9361: PUSH
9362: LD_INT 1
9364: PLUS
9365: ARRAY
9366: PPUSH
9367: LD_INT 80
9369: PPUSH
9370: CALL 74431 0 5
// result := result union CreateVehicle ;
9374: LD_ADDR_VAR 0 2
9378: PUSH
9379: LD_VAR 0 2
9383: PUSH
9384: CALL_OW 45
9388: UNION
9389: ST_TO_ADDR
// end ;
9390: GO 9259
9392: POP
9393: POP
// end ; 4 :
9394: GO 10035
9396: LD_INT 4
9398: DOUBLE
9399: EQUAL
9400: IFTRUE 9404
9402: GO 10034
9404: POP
// begin uc_nation := 3 ;
9405: LD_ADDR_OWVAR 21
9409: PUSH
9410: LD_INT 3
9412: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9413: LD_ADDR_VAR 0 3
9417: PUSH
9418: DOUBLE
9419: LD_INT 1
9421: DEC
9422: ST_TO_ADDR
9423: LD_INT 6
9425: PUSH
9426: LD_INT 8
9428: PUSH
9429: LD_INT 9
9431: PUSH
9432: LD_INT 10
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: PUSH
9441: LD_OWVAR 67
9445: ARRAY
9446: PUSH
9447: FOR_TO
9448: IFFALSE 9580
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9450: LD_INT 22
9452: PUSH
9453: LD_INT 24
9455: PUSH
9456: LD_INT 24
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: LIST
9463: PUSH
9464: LD_VAR 0 3
9468: PUSH
9469: LD_INT 3
9471: MOD
9472: PUSH
9473: LD_INT 1
9475: PLUS
9476: ARRAY
9477: PPUSH
9478: LD_INT 1
9480: PUSH
9481: LD_INT 3
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: PUSH
9488: LD_INT 1
9490: PPUSH
9491: LD_INT 2
9493: PPUSH
9494: CALL_OW 12
9498: ARRAY
9499: PPUSH
9500: LD_INT 3
9502: PPUSH
9503: LD_INT 45
9505: PUSH
9506: LD_INT 47
9508: PUSH
9509: LD_INT 47
9511: PUSH
9512: LD_INT 45
9514: PUSH
9515: LD_INT 46
9517: PUSH
9518: LD_INT 46
9520: PUSH
9521: LD_INT 49
9523: PUSH
9524: LD_INT 49
9526: PUSH
9527: LD_INT 49
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: PUSH
9541: LD_VAR 0 3
9545: PUSH
9546: LD_INT 9
9548: MOD
9549: PUSH
9550: LD_INT 1
9552: PLUS
9553: ARRAY
9554: PPUSH
9555: LD_INT 80
9557: PPUSH
9558: CALL 74431 0 5
// result := result union CreateVehicle ;
9562: LD_ADDR_VAR 0 2
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: CALL_OW 45
9576: UNION
9577: ST_TO_ADDR
// end ;
9578: GO 9447
9580: POP
9581: POP
// if not KappaStatus then
9582: LD_EXP 2
9586: NOT
9587: IFFALSE 9822
// begin uc_nation := 1 ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 1
9596: ST_TO_ADDR
// for i = 1 to 3 do
9597: LD_ADDR_VAR 0 3
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_INT 3
9609: PUSH
9610: FOR_TO
9611: IFFALSE 9747
// begin j := rand ( 0 , 1 ) ;
9613: LD_ADDR_VAR 0 4
9617: PUSH
9618: LD_INT 0
9620: PPUSH
9621: LD_INT 1
9623: PPUSH
9624: CALL_OW 12
9628: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9629: LD_INT 3
9631: PUSH
9632: LD_INT 5
9634: PUSH
9635: LD_INT 5
9637: PUSH
9638: LD_INT 4
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_VAR 0 4
9651: PUSH
9652: LD_INT 1
9654: PPUSH
9655: LD_INT 3
9657: PPUSH
9658: CALL_OW 12
9662: PLUS
9663: ARRAY
9664: PPUSH
9665: LD_INT 1
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 1
9677: PPUSH
9678: LD_INT 2
9680: PPUSH
9681: CALL_OW 12
9685: ARRAY
9686: PPUSH
9687: LD_INT 3
9689: PPUSH
9690: LD_INT 9
9692: PUSH
9693: LD_INT 7
9695: PUSH
9696: LD_INT 6
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: LIST
9703: PUSH
9704: LD_VAR 0 4
9708: PUSH
9709: LD_INT 1
9711: PPUSH
9712: LD_INT 2
9714: PPUSH
9715: CALL_OW 12
9719: PLUS
9720: ARRAY
9721: PPUSH
9722: LD_INT 85
9724: PPUSH
9725: CALL 74431 0 5
// result := result union CreateVehicle ;
9729: LD_ADDR_VAR 0 2
9733: PUSH
9734: LD_VAR 0 2
9738: PUSH
9739: CALL_OW 45
9743: UNION
9744: ST_TO_ADDR
// end ;
9745: GO 9610
9747: POP
9748: POP
// if vsevolodFirstAttack then
9749: LD_EXP 24
9753: IFFALSE 9820
// begin vsevolodFirstAttack := false ;
9755: LD_ADDR_EXP 24
9759: PUSH
9760: LD_INT 0
9762: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9763: LD_INT 5
9765: PPUSH
9766: LD_INT 3
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: LD_INT 6
9774: PPUSH
9775: LD_INT 100
9777: PPUSH
9778: CALL 74431 0 5
// sewiVeh := CreateVehicle ;
9782: LD_ADDR_EXP 75
9786: PUSH
9787: CALL_OW 45
9791: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9792: LD_EXP 75
9796: PPUSH
9797: LD_INT 1
9799: PPUSH
9800: CALL_OW 242
// result := result union sewiVeh ;
9804: LD_ADDR_VAR 0 2
9808: PUSH
9809: LD_VAR 0 2
9813: PUSH
9814: LD_EXP 75
9818: UNION
9819: ST_TO_ADDR
// end ; end else
9820: GO 10032
// if vsevolodFirstAttack then
9822: LD_EXP 24
9826: IFFALSE 10032
// begin vsevolodFirstAttack := false ;
9828: LD_ADDR_EXP 24
9832: PUSH
9833: LD_INT 0
9835: ST_TO_ADDR
// uc_nation := 3 ;
9836: LD_ADDR_OWVAR 21
9840: PUSH
9841: LD_INT 3
9843: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9844: LD_ADDR_VAR 0 3
9848: PUSH
9849: DOUBLE
9850: LD_INT 1
9852: DEC
9853: ST_TO_ADDR
9854: LD_INT 2
9856: PUSH
9857: LD_OWVAR 67
9861: PLUS
9862: PUSH
9863: FOR_TO
9864: IFFALSE 9972
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9866: LD_INT 22
9868: PUSH
9869: LD_INT 24
9871: PUSH
9872: LD_INT 24
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: LIST
9879: PUSH
9880: LD_VAR 0 3
9884: PUSH
9885: LD_INT 3
9887: MOD
9888: PUSH
9889: LD_INT 1
9891: PLUS
9892: ARRAY
9893: PPUSH
9894: LD_INT 1
9896: PUSH
9897: LD_INT 3
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 1
9906: PPUSH
9907: LD_INT 2
9909: PPUSH
9910: CALL_OW 12
9914: ARRAY
9915: PPUSH
9916: LD_INT 1
9918: PPUSH
9919: LD_INT 45
9921: PUSH
9922: LD_INT 47
9924: PUSH
9925: LD_INT 47
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: LD_VAR 0 3
9937: PUSH
9938: LD_INT 3
9940: MOD
9941: PUSH
9942: LD_INT 1
9944: PLUS
9945: ARRAY
9946: PPUSH
9947: LD_INT 80
9949: PPUSH
9950: CALL 74431 0 5
// result := result union CreateVehicle ;
9954: LD_ADDR_VAR 0 2
9958: PUSH
9959: LD_VAR 0 2
9963: PUSH
9964: CALL_OW 45
9968: UNION
9969: ST_TO_ADDR
// end ;
9970: GO 9863
9972: POP
9973: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9974: LD_INT 24
9976: PPUSH
9977: LD_INT 3
9979: PPUSH
9980: LD_INT 1
9982: PPUSH
9983: LD_INT 47
9985: PPUSH
9986: LD_INT 100
9988: PPUSH
9989: CALL 74431 0 5
// sewiVeh := CreateVehicle ;
9993: LD_ADDR_EXP 75
9997: PUSH
9998: CALL_OW 45
10002: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
10003: LD_EXP 75
10007: PPUSH
10008: LD_INT 6
10010: NEG
10011: PPUSH
10012: CALL_OW 242
// result := result union sewiVeh ;
10016: LD_ADDR_VAR 0 2
10020: PUSH
10021: LD_VAR 0 2
10025: PUSH
10026: LD_EXP 75
10030: UNION
10031: ST_TO_ADDR
// end ; end ; end ;
10032: GO 10035
10034: POP
// end ;
10035: LD_VAR 0 2
10039: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10040: LD_EXP 16
10044: IFFALSE 10785
10046: GO 10048
10048: DISABLE
10049: LD_INT 0
10051: PPUSH
10052: PPUSH
10053: PPUSH
10054: PPUSH
10055: PPUSH
10056: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10057: LD_ADDR_VAR 0 4
10061: PUSH
10062: LD_INT 11
10064: PUSH
10065: LD_INT 12
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10072: LD_ADDR_VAR 0 3
10076: PUSH
10077: LD_INT 11550
10079: PUSH
10080: LD_INT 10150
10082: PUSH
10083: LD_INT 9800
10085: PUSH
10086: LD_INT 9450
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: PUSH
10095: LD_OWVAR 67
10099: ARRAY
10100: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10101: LD_ADDR_VAR 0 6
10105: PUSH
10106: LD_INT 70
10108: PUSH
10109: LD_INT 118
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PUSH
10116: LD_INT 78
10118: PUSH
10119: LD_INT 31
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: ST_TO_ADDR
// repeat if missionStage = 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 2
10137: EQUAL
10138: IFFALSE 10149
// wait ( 1 1$30 ) else
10140: LD_INT 3150
10142: PPUSH
10143: CALL_OW 67
10147: GO 10158
// wait ( time ) ;
10149: LD_VAR 0 3
10153: PPUSH
10154: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10158: LD_EXP 15
10162: PUSH
10163: LD_INT 6
10165: EQUAL
10166: PUSH
10167: LD_OWVAR 67
10171: PUSH
10172: LD_INT 2
10174: GREATER
10175: OR
10176: IFFALSE 10204
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10178: LD_INT 51
10180: PPUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 2
10186: PPUSH
10187: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10191: LD_INT 57
10193: PPUSH
10194: LD_INT 6
10196: PPUSH
10197: LD_INT 2
10199: PPUSH
10200: CALL_OW 322
// end ; if missionStage = 8 then
10204: LD_EXP 15
10208: PUSH
10209: LD_INT 8
10211: EQUAL
10212: IFFALSE 10240
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10214: LD_INT 52
10216: PPUSH
10217: LD_INT 6
10219: PPUSH
10220: LD_INT 2
10222: PPUSH
10223: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10227: LD_INT 58
10229: PPUSH
10230: LD_INT 6
10232: PPUSH
10233: LD_INT 2
10235: PPUSH
10236: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 4
10247: EQUAL
10248: PUSH
10249: LD_EXP 15
10253: PUSH
10254: LD_INT 10
10256: EQUAL
10257: OR
10258: IFFALSE 10286
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10260: LD_INT 53
10262: PPUSH
10263: LD_INT 6
10265: PPUSH
10266: LD_INT 2
10268: PPUSH
10269: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10273: LD_INT 59
10275: PPUSH
10276: LD_INT 6
10278: PPUSH
10279: LD_INT 2
10281: PPUSH
10282: CALL_OW 322
// end ; if activeAttacks then
10286: LD_EXP 16
10290: IFFALSE 10779
// begin if missionStage = 2 then
10292: LD_EXP 15
10296: PUSH
10297: LD_INT 2
10299: EQUAL
10300: IFFALSE 10310
// strength := 1 ;
10302: LD_ADDR_VAR 0 5
10306: PUSH
10307: LD_INT 1
10309: ST_TO_ADDR
// if missionStage > 2 then
10310: LD_EXP 15
10314: PUSH
10315: LD_INT 2
10317: GREATER
10318: IFFALSE 10328
// strength := 2 ;
10320: LD_ADDR_VAR 0 5
10324: PUSH
10325: LD_INT 2
10327: ST_TO_ADDR
// if missionStage > 6 then
10328: LD_EXP 15
10332: PUSH
10333: LD_INT 6
10335: GREATER
10336: IFFALSE 10346
// strength := 3 ;
10338: LD_ADDR_VAR 0 5
10342: PUSH
10343: LD_INT 3
10345: ST_TO_ADDR
// if missionStage > 10 then
10346: LD_EXP 15
10350: PUSH
10351: LD_INT 10
10353: GREATER
10354: IFFALSE 10364
// strength := 4 ;
10356: LD_ADDR_VAR 0 5
10360: PUSH
10361: LD_INT 4
10363: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10364: LD_ADDR_VAR 0 2
10368: PUSH
10369: LD_VAR 0 5
10373: PPUSH
10374: CALL 8857 0 1
10378: ST_TO_ADDR
// for i in tmp do
10379: LD_ADDR_VAR 0 1
10383: PUSH
10384: LD_VAR 0 2
10388: PUSH
10389: FOR_IN
10390: IFFALSE 10648
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10392: LD_VAR 0 1
10396: PPUSH
10397: LD_VAR 0 4
10401: PUSH
10402: LD_INT 1
10404: PPUSH
10405: LD_INT 2
10407: PPUSH
10408: CALL_OW 12
10412: ARRAY
10413: PPUSH
10414: LD_INT 0
10416: PPUSH
10417: CALL_OW 49
// if i = sewiVeh then
10421: LD_VAR 0 1
10425: PUSH
10426: LD_EXP 75
10430: EQUAL
10431: IFFALSE 10468
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10433: LD_ADDR_EXP 74
10437: PUSH
10438: LD_STRING Vsevolod
10440: PPUSH
10441: LD_INT 0
10443: PPUSH
10444: LD_STRING 
10446: PPUSH
10447: CALL 69591 0 3
10451: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10452: LD_EXP 74
10456: PPUSH
10457: LD_VAR 0 1
10461: PPUSH
10462: CALL_OW 52
// end else
10466: GO 10549
// if GetControl ( i ) = control_manual then
10468: LD_VAR 0 1
10472: PPUSH
10473: CALL_OW 263
10477: PUSH
10478: LD_INT 1
10480: EQUAL
10481: IFFALSE 10549
// begin uc_side := 6 ;
10483: LD_ADDR_OWVAR 20
10487: PUSH
10488: LD_INT 6
10490: ST_TO_ADDR
// uc_nation := 3 ;
10491: LD_ADDR_OWVAR 21
10495: PUSH
10496: LD_INT 3
10498: ST_TO_ADDR
// hc_gallery :=  ;
10499: LD_ADDR_OWVAR 33
10503: PUSH
10504: LD_STRING 
10506: ST_TO_ADDR
// hc_name :=  ;
10507: LD_ADDR_OWVAR 26
10511: PUSH
10512: LD_STRING 
10514: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10515: LD_INT 0
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: LD_INT 10
10523: PPUSH
10524: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10528: CALL_OW 44
10532: PPUSH
10533: LD_VAR 0 1
10537: PPUSH
10538: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10542: LD_INT 10
10544: PPUSH
10545: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10549: LD_INT 1
10551: PPUSH
10552: LD_INT 3
10554: PPUSH
10555: CALL_OW 12
10559: PUSH
10560: LD_INT 1
10562: DOUBLE
10563: EQUAL
10564: IFTRUE 10568
10566: GO 10586
10568: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10569: LD_VAR 0 1
10573: PPUSH
10574: LD_INT 111
10576: PPUSH
10577: LD_INT 197
10579: PPUSH
10580: CALL_OW 111
10584: GO 10639
10586: LD_INT 2
10588: DOUBLE
10589: EQUAL
10590: IFTRUE 10594
10592: GO 10612
10594: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10595: LD_VAR 0 1
10599: PPUSH
10600: LD_INT 91
10602: PPUSH
10603: LD_INT 165
10605: PPUSH
10606: CALL_OW 111
10610: GO 10639
10612: LD_INT 3
10614: DOUBLE
10615: EQUAL
10616: IFTRUE 10620
10618: GO 10638
10620: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10621: LD_VAR 0 1
10625: PPUSH
10626: LD_INT 137
10628: PPUSH
10629: LD_INT 157
10631: PPUSH
10632: CALL_OW 111
10636: GO 10639
10638: POP
// wait ( 0 0$2 ) ;
10639: LD_INT 70
10641: PPUSH
10642: CALL_OW 67
// end ;
10646: GO 10389
10648: POP
10649: POP
// repeat wait ( 0 0$1 ) ;
10650: LD_INT 35
10652: PPUSH
10653: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10657: LD_ADDR_VAR 0 1
10661: PUSH
10662: LD_VAR 0 2
10666: PPUSH
10667: LD_INT 50
10669: PUSH
10670: EMPTY
10671: LIST
10672: PPUSH
10673: CALL_OW 72
10677: PUSH
10678: FOR_IN
10679: IFFALSE 10738
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10681: LD_VAR 0 1
10685: PPUSH
10686: LD_INT 108
10688: PUSH
10689: LD_INT 153
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: PUSH
10696: LD_INT 105
10698: PUSH
10699: LD_INT 149
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: PUSH
10706: LD_INT 85
10708: PUSH
10709: LD_INT 131
10711: PUSH
10712: EMPTY
10713: LIST
10714: LIST
10715: PUSH
10716: LD_INT 64
10718: PUSH
10719: LD_INT 105
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PUSH
10726: EMPTY
10727: LIST
10728: LIST
10729: LIST
10730: LIST
10731: PPUSH
10732: CALL 109886 0 2
10736: GO 10678
10738: POP
10739: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10740: LD_VAR 0 2
10744: PPUSH
10745: LD_INT 3
10747: PUSH
10748: LD_INT 34
10750: PUSH
10751: LD_INT 49
10753: PUSH
10754: EMPTY
10755: LIST
10756: LIST
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PUSH
10762: LD_INT 50
10764: PUSH
10765: EMPTY
10766: LIST
10767: PUSH
10768: EMPTY
10769: LIST
10770: LIST
10771: PPUSH
10772: CALL_OW 72
10776: NOT
10777: IFFALSE 10650
// end ; until russianDestroyed ;
10779: LD_EXP 21
10783: IFFALSE 10130
// end ;
10785: PPOPN 6
10787: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10788: LD_EXP 21
10792: NOT
10793: PUSH
10794: LD_EXP 15
10798: PUSH
10799: LD_INT 6
10801: GREATEREQUAL
10802: AND
10803: IFFALSE 11823
10805: GO 10807
10807: DISABLE
10808: LD_INT 0
10810: PPUSH
10811: PPUSH
10812: PPUSH
10813: PPUSH
10814: PPUSH
// begin enable ;
10815: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10816: LD_INT 22
10818: PUSH
10819: LD_INT 3
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 30
10828: PUSH
10829: LD_INT 3
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: NOT
10845: IFFALSE 10849
// exit ;
10847: GO 11823
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10849: LD_ADDR_VAR 0 4
10853: PUSH
10854: LD_INT 22
10856: PUSH
10857: LD_INT 3
10859: PUSH
10860: EMPTY
10861: LIST
10862: LIST
10863: PUSH
10864: LD_INT 30
10866: PUSH
10867: LD_INT 34
10869: PUSH
10870: EMPTY
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PPUSH
10878: CALL_OW 69
10882: ST_TO_ADDR
// if Prob ( 40 ) then
10883: LD_INT 40
10885: PPUSH
10886: CALL_OW 13
10890: IFFALSE 11036
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10892: LD_INT 2
10894: PPUSH
10895: LD_INT 22
10897: PUSH
10898: LD_INT 3
10900: PUSH
10901: LD_INT 3
10903: PUSH
10904: LD_INT 49
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 22
10915: PUSH
10916: LD_INT 3
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: LD_INT 49
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 3
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 49
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: PUSH
10949: LD_INT 24
10951: PUSH
10952: LD_INT 3
10954: PUSH
10955: LD_INT 3
10957: PUSH
10958: LD_INT 46
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: PUSH
10967: LD_INT 24
10969: PUSH
10970: LD_INT 3
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: LD_INT 46
10978: PUSH
10979: EMPTY
10980: LIST
10981: LIST
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 24
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 46
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 24
11005: PUSH
11006: LD_INT 3
11008: PUSH
11009: LD_INT 3
11011: PUSH
11012: LD_INT 46
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: LIST
11029: PPUSH
11030: CALL 63165 0 2
// end else
11034: GO 11178
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11036: LD_INT 2
11038: PPUSH
11039: LD_INT 24
11041: PUSH
11042: LD_INT 3
11044: PUSH
11045: LD_INT 3
11047: PUSH
11048: LD_INT 47
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: LIST
11055: LIST
11056: PUSH
11057: LD_INT 24
11059: PUSH
11060: LD_INT 3
11062: PUSH
11063: LD_INT 3
11065: PUSH
11066: LD_INT 47
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 24
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 3
11083: PUSH
11084: LD_INT 47
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: LIST
11091: LIST
11092: PUSH
11093: LD_INT 24
11095: PUSH
11096: LD_INT 3
11098: PUSH
11099: LD_INT 3
11101: PUSH
11102: LD_INT 46
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PUSH
11111: LD_INT 24
11113: PUSH
11114: LD_INT 3
11116: PUSH
11117: LD_INT 3
11119: PUSH
11120: LD_INT 46
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 24
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: LD_INT 3
11137: PUSH
11138: LD_INT 46
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: LIST
11145: LIST
11146: PUSH
11147: LD_INT 24
11149: PUSH
11150: LD_INT 3
11152: PUSH
11153: LD_INT 3
11155: PUSH
11156: LD_INT 46
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: PPUSH
11174: CALL 63165 0 2
// end ; wait ( 2 2$00 ) ;
11178: LD_INT 4200
11180: PPUSH
11181: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11185: LD_ADDR_VAR 0 2
11189: PUSH
11190: LD_INT 22
11192: PUSH
11193: LD_INT 3
11195: PUSH
11196: EMPTY
11197: LIST
11198: LIST
11199: PUSH
11200: LD_INT 21
11202: PUSH
11203: LD_INT 2
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 3
11212: PUSH
11213: LD_INT 34
11215: PUSH
11216: LD_INT 48
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PUSH
11223: LD_INT 34
11225: PUSH
11226: LD_INT 51
11228: PUSH
11229: EMPTY
11230: LIST
11231: LIST
11232: PUSH
11233: LD_INT 34
11235: PUSH
11236: LD_INT 52
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: LIST
11253: PPUSH
11254: CALL_OW 69
11258: PUSH
11259: LD_EXP 124
11263: PUSH
11264: LD_INT 2
11266: ARRAY
11267: DIFF
11268: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11269: LD_ADDR_EXP 121
11273: PUSH
11274: LD_EXP 121
11278: PPUSH
11279: LD_INT 2
11281: PPUSH
11282: LD_EXP 121
11286: PUSH
11287: LD_INT 2
11289: ARRAY
11290: PUSH
11291: LD_VAR 0 2
11295: DIFF
11296: PPUSH
11297: CALL_OW 1
11301: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11302: LD_ADDR_VAR 0 3
11306: PUSH
11307: LD_INT 0
11309: PPUSH
11310: LD_INT 1
11312: PPUSH
11313: CALL_OW 12
11317: ST_TO_ADDR
// p := 0 ;
11318: LD_ADDR_VAR 0 5
11322: PUSH
11323: LD_INT 0
11325: ST_TO_ADDR
// if target then
11326: LD_VAR 0 3
11330: IFFALSE 11483
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11332: LD_ADDR_VAR 0 2
11336: PUSH
11337: LD_VAR 0 2
11341: PPUSH
11342: LD_INT 24
11344: PUSH
11345: LD_INT 250
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: PPUSH
11352: CALL_OW 72
11356: ST_TO_ADDR
// for i in tmp do
11357: LD_ADDR_VAR 0 1
11361: PUSH
11362: LD_VAR 0 2
11366: PUSH
11367: FOR_IN
11368: IFFALSE 11408
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11370: LD_VAR 0 1
11374: PPUSH
11375: LD_INT 139
11377: PPUSH
11378: LD_INT 89
11380: PPUSH
11381: CALL_OW 297
11385: PUSH
11386: LD_INT 9
11388: GREATER
11389: IFFALSE 11406
// ComMoveXY ( i , 139 , 89 ) ;
11391: LD_VAR 0 1
11395: PPUSH
11396: LD_INT 139
11398: PPUSH
11399: LD_INT 89
11401: PPUSH
11402: CALL_OW 111
11406: GO 11367
11408: POP
11409: POP
// wait ( 0 0$1 ) ;
11410: LD_INT 35
11412: PPUSH
11413: CALL_OW 67
// p := Inc ( p ) ;
11417: LD_ADDR_VAR 0 5
11421: PUSH
11422: LD_VAR 0 5
11426: PPUSH
11427: CALL 108643 0 1
11431: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11432: LD_VAR 0 2
11436: PPUSH
11437: LD_INT 92
11439: PUSH
11440: LD_INT 139
11442: PUSH
11443: LD_INT 89
11445: PUSH
11446: LD_INT 9
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: PPUSH
11455: CALL_OW 72
11459: PUSH
11460: LD_VAR 0 2
11464: PUSH
11465: LD_INT 1
11467: MINUS
11468: GREATEREQUAL
11469: PUSH
11470: LD_VAR 0 5
11474: PUSH
11475: LD_INT 60
11477: GREATER
11478: OR
11479: IFFALSE 11332
// end else
11481: GO 11650
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11483: LD_VAR 0 2
11487: PPUSH
11488: LD_VAR 0 4
11492: PUSH
11493: LD_INT 1
11495: ARRAY
11496: PPUSH
11497: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11501: LD_ADDR_VAR 0 2
11505: PUSH
11506: LD_VAR 0 2
11510: PPUSH
11511: LD_INT 24
11513: PUSH
11514: LD_INT 250
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: PPUSH
11521: CALL_OW 72
11525: ST_TO_ADDR
// for i in tmp do
11526: LD_ADDR_VAR 0 1
11530: PUSH
11531: LD_VAR 0 2
11535: PUSH
11536: FOR_IN
11537: IFFALSE 11577
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11539: LD_VAR 0 1
11543: PPUSH
11544: LD_INT 124
11546: PPUSH
11547: LD_INT 139
11549: PPUSH
11550: CALL_OW 297
11554: PUSH
11555: LD_INT 9
11557: GREATER
11558: IFFALSE 11575
// ComMoveXY ( i , 124 , 139 ) ;
11560: LD_VAR 0 1
11564: PPUSH
11565: LD_INT 124
11567: PPUSH
11568: LD_INT 139
11570: PPUSH
11571: CALL_OW 111
11575: GO 11536
11577: POP
11578: POP
// wait ( 0 0$1 ) ;
11579: LD_INT 35
11581: PPUSH
11582: CALL_OW 67
// p := Inc ( p ) ;
11586: LD_ADDR_VAR 0 5
11590: PUSH
11591: LD_VAR 0 5
11595: PPUSH
11596: CALL 108643 0 1
11600: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11601: LD_VAR 0 2
11605: PPUSH
11606: LD_INT 92
11608: PUSH
11609: LD_INT 124
11611: PUSH
11612: LD_INT 139
11614: PUSH
11615: LD_INT 9
11617: PUSH
11618: EMPTY
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: PPUSH
11624: CALL_OW 72
11628: PUSH
11629: LD_VAR 0 2
11633: PUSH
11634: LD_INT 1
11636: MINUS
11637: GREATEREQUAL
11638: PUSH
11639: LD_VAR 0 5
11643: PUSH
11644: LD_INT 60
11646: GREATER
11647: OR
11648: IFFALSE 11501
// end ; repeat wait ( 0 0$1 ) ;
11650: LD_INT 35
11652: PPUSH
11653: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11657: LD_ADDR_VAR 0 2
11661: PUSH
11662: LD_VAR 0 2
11666: PPUSH
11667: LD_INT 50
11669: PUSH
11670: EMPTY
11671: LIST
11672: PPUSH
11673: CALL_OW 72
11677: ST_TO_ADDR
// for i in tmp do
11678: LD_ADDR_VAR 0 1
11682: PUSH
11683: LD_VAR 0 2
11687: PUSH
11688: FOR_IN
11689: IFFALSE 11814
// begin if GetWeapon ( i ) = ru_time_lapser then
11691: LD_VAR 0 1
11695: PPUSH
11696: CALL_OW 264
11700: PUSH
11701: LD_INT 49
11703: EQUAL
11704: IFFALSE 11760
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11706: LD_VAR 0 1
11710: PPUSH
11711: LD_INT 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_INT 1
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: LD_INT 22
11726: PUSH
11727: LD_INT 8
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: EMPTY
11735: LIST
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 69
11743: PPUSH
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 74
11753: PPUSH
11754: CALL_OW 112
11758: GO 11812
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11760: LD_VAR 0 1
11764: PPUSH
11765: LD_INT 2
11767: PUSH
11768: LD_INT 22
11770: PUSH
11771: LD_INT 1
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PUSH
11778: LD_INT 22
11780: PUSH
11781: LD_INT 8
11783: PUSH
11784: EMPTY
11785: LIST
11786: LIST
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: LIST
11792: PPUSH
11793: CALL_OW 69
11797: PPUSH
11798: LD_VAR 0 1
11802: PPUSH
11803: CALL_OW 74
11807: PPUSH
11808: CALL_OW 115
// end ;
11812: GO 11688
11814: POP
11815: POP
// until not tmp ;
11816: LD_VAR 0 2
11820: NOT
11821: IFFALSE 11650
// end ;
11823: PPOPN 5
11825: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11826: LD_EXP 15
11830: PUSH
11831: LD_INT 7
11833: GREATEREQUAL
11834: PUSH
11835: LD_OWVAR 67
11839: PUSH
11840: LD_INT 1
11842: GREATER
11843: AND
11844: IFFALSE 12136
11846: GO 11848
11848: DISABLE
11849: LD_INT 0
11851: PPUSH
11852: PPUSH
11853: PPUSH
// begin ruMobile := [ ] ;
11854: LD_ADDR_EXP 78
11858: PUSH
11859: EMPTY
11860: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11861: LD_ADDR_VAR 0 1
11865: PUSH
11866: DOUBLE
11867: LD_INT 1
11869: DEC
11870: ST_TO_ADDR
11871: LD_INT 4
11873: PUSH
11874: LD_INT 5
11876: PUSH
11877: LD_INT 6
11879: PUSH
11880: EMPTY
11881: LIST
11882: LIST
11883: LIST
11884: PUSH
11885: LD_OWVAR 67
11889: PUSH
11890: LD_INT 1
11892: MINUS
11893: ARRAY
11894: PUSH
11895: FOR_TO
11896: IFFALSE 12134
// begin uc_side := 3 ;
11898: LD_ADDR_OWVAR 20
11902: PUSH
11903: LD_INT 3
11905: ST_TO_ADDR
// uc_nation := 1 ;
11906: LD_ADDR_OWVAR 21
11910: PUSH
11911: LD_INT 1
11913: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11914: LD_INT 5
11916: PPUSH
11917: LD_INT 3
11919: PPUSH
11920: LD_INT 1
11922: PPUSH
11923: LD_INT 9
11925: PUSH
11926: LD_INT 7
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: LD_VAR 0 1
11937: PUSH
11938: LD_INT 2
11940: MOD
11941: PUSH
11942: LD_INT 1
11944: PLUS
11945: ARRAY
11946: PPUSH
11947: LD_INT 100
11949: PPUSH
11950: CALL 74431 0 5
// veh := CreateVehicle ;
11954: LD_ADDR_VAR 0 2
11958: PUSH
11959: CALL_OW 45
11963: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11964: LD_VAR 0 2
11968: PPUSH
11969: LD_INT 3
11971: PPUSH
11972: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11976: LD_VAR 0 2
11980: PPUSH
11981: LD_INT 29
11983: PPUSH
11984: LD_INT 0
11986: PPUSH
11987: CALL_OW 49
// uc_nation := 3 ;
11991: LD_ADDR_OWVAR 21
11995: PUSH
11996: LD_INT 3
11998: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11999: LD_INT 0
12001: PPUSH
12002: LD_INT 10
12004: PPUSH
12005: CALL_OW 383
// un := CreateHuman ;
12009: LD_ADDR_VAR 0 3
12013: PUSH
12014: CALL_OW 44
12018: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12019: LD_VAR 0 3
12023: PPUSH
12024: LD_INT 105
12026: PPUSH
12027: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12031: LD_VAR 0 3
12035: PPUSH
12036: LD_INT 3
12038: PPUSH
12039: CALL_OW 259
12043: PUSH
12044: LD_INT 8
12046: PUSH
12047: LD_INT 9
12049: PUSH
12050: LD_INT 10
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: LIST
12057: PUSH
12058: LD_OWVAR 67
12062: ARRAY
12063: LESS
12064: IFFALSE 12098
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12066: LD_VAR 0 3
12070: PPUSH
12071: LD_INT 3
12073: PPUSH
12074: LD_INT 8
12076: PUSH
12077: LD_INT 9
12079: PUSH
12080: LD_INT 10
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: LIST
12087: PUSH
12088: LD_OWVAR 67
12092: ARRAY
12093: PPUSH
12094: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12098: LD_VAR 0 3
12102: PPUSH
12103: LD_VAR 0 2
12107: PPUSH
12108: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12112: LD_ADDR_EXP 78
12116: PUSH
12117: LD_EXP 78
12121: PPUSH
12122: LD_VAR 0 2
12126: PPUSH
12127: CALL 107282 0 2
12131: ST_TO_ADDR
// end ;
12132: GO 11895
12134: POP
12135: POP
// end ;
12136: PPOPN 3
12138: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12139: LD_EXP 78
12143: IFFALSE 12652
12145: GO 12147
12147: DISABLE
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
// begin enable ;
12153: ENABLE
// if not ruMobile then
12154: LD_EXP 78
12158: NOT
12159: IFFALSE 12164
// begin disable ;
12161: DISABLE
// exit ;
12162: GO 12652
// end ; for i in ruMobile do
12164: LD_ADDR_VAR 0 1
12168: PUSH
12169: LD_EXP 78
12173: PUSH
12174: FOR_IN
12175: IFFALSE 12650
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12177: LD_VAR 0 1
12181: PPUSH
12182: CALL_OW 302
12186: NOT
12187: PUSH
12188: LD_VAR 0 1
12192: PPUSH
12193: CALL_OW 255
12197: PUSH
12198: LD_INT 3
12200: NONEQUAL
12201: OR
12202: IFFALSE 12222
// begin ruMobile := ruMobile diff i ;
12204: LD_ADDR_EXP 78
12208: PUSH
12209: LD_EXP 78
12213: PUSH
12214: LD_VAR 0 1
12218: DIFF
12219: ST_TO_ADDR
// continue ;
12220: GO 12174
// end ; if GetTag ( i ) = 300 then
12222: LD_VAR 0 1
12226: PPUSH
12227: CALL_OW 110
12231: PUSH
12232: LD_INT 300
12234: EQUAL
12235: IFFALSE 12285
// begin ComMoveXY ( i , 160 , 81 ) ;
12237: LD_VAR 0 1
12241: PPUSH
12242: LD_INT 160
12244: PPUSH
12245: LD_INT 81
12247: PPUSH
12248: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12252: LD_VAR 0 1
12256: PPUSH
12257: LD_INT 160
12259: PPUSH
12260: LD_INT 81
12262: PPUSH
12263: CALL_OW 297
12267: PUSH
12268: LD_INT 8
12270: LESS
12271: IFFALSE 12285
// SetTag ( i , 301 ) ;
12273: LD_VAR 0 1
12277: PPUSH
12278: LD_INT 301
12280: PPUSH
12281: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12285: LD_VAR 0 1
12289: PPUSH
12290: CALL_OW 110
12294: PUSH
12295: LD_INT 301
12297: EQUAL
12298: IFFALSE 12341
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12300: LD_VAR 0 1
12304: PPUSH
12305: LD_INT 33
12307: PPUSH
12308: CALL_OW 308
12312: NOT
12313: IFFALSE 12329
// ComMoveToArea ( i , ruMobileParkingArea ) else
12315: LD_VAR 0 1
12319: PPUSH
12320: LD_INT 33
12322: PPUSH
12323: CALL_OW 113
12327: GO 12341
// SetTag ( i , 302 ) ;
12329: LD_VAR 0 1
12333: PPUSH
12334: LD_INT 302
12336: PPUSH
12337: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12341: LD_VAR 0 1
12345: PPUSH
12346: CALL_OW 110
12350: PUSH
12351: LD_INT 302
12353: EQUAL
12354: IFFALSE 12484
// begin if GetLives ( i ) < 1000 then
12356: LD_VAR 0 1
12360: PPUSH
12361: CALL_OW 256
12365: PUSH
12366: LD_INT 1000
12368: LESS
12369: IFFALSE 12461
// begin if not IsDrivenBy ( i ) then
12371: LD_VAR 0 1
12375: PPUSH
12376: CALL_OW 311
12380: NOT
12381: IFFALSE 12385
// continue ;
12383: GO 12174
// mech := IsDrivenBy ( i ) ;
12385: LD_ADDR_VAR 0 2
12389: PUSH
12390: LD_VAR 0 1
12394: PPUSH
12395: CALL_OW 311
12399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12400: LD_VAR 0 2
12404: PPUSH
12405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12409: LD_VAR 0 2
12413: PPUSH
12414: LD_VAR 0 1
12418: PPUSH
12419: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12423: LD_INT 35
12425: PPUSH
12426: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12430: LD_VAR 0 1
12434: PPUSH
12435: CALL_OW 256
12439: PUSH
12440: LD_INT 1000
12442: EQUAL
12443: IFFALSE 12423
// ComEnterUnit ( mech , i ) ;
12445: LD_VAR 0 2
12449: PPUSH
12450: LD_VAR 0 1
12454: PPUSH
12455: CALL_OW 120
// end else
12459: GO 12484
// if IsDrivenBy ( i ) then
12461: LD_VAR 0 1
12465: PPUSH
12466: CALL_OW 311
12470: IFFALSE 12484
// SetTag ( i , 0 ) ;
12472: LD_VAR 0 1
12476: PPUSH
12477: LD_INT 0
12479: PPUSH
12480: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12484: LD_VAR 0 1
12488: PPUSH
12489: CALL_OW 110
12493: PUSH
12494: LD_INT 300
12496: LESS
12497: IFFALSE 12648
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12499: LD_ADDR_VAR 0 3
12503: PUSH
12504: LD_INT 4
12506: PPUSH
12507: LD_INT 81
12509: PUSH
12510: LD_INT 3
12512: PUSH
12513: EMPTY
12514: LIST
12515: LIST
12516: PPUSH
12517: CALL_OW 70
12521: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12522: LD_VAR 0 1
12526: PPUSH
12527: CALL_OW 256
12531: PUSH
12532: LD_INT 650
12534: LESS
12535: IFFALSE 12560
// begin ComStop ( i ) ;
12537: LD_VAR 0 1
12541: PPUSH
12542: CALL_OW 141
// SetTag ( i , 300 ) ;
12546: LD_VAR 0 1
12550: PPUSH
12551: LD_INT 300
12553: PPUSH
12554: CALL_OW 109
// continue ;
12558: GO 12174
// end ; if enemy then
12560: LD_VAR 0 3
12564: IFFALSE 12604
// begin if not HasTask ( i ) then
12566: LD_VAR 0 1
12570: PPUSH
12571: CALL_OW 314
12575: NOT
12576: IFFALSE 12602
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12578: LD_VAR 0 1
12582: PPUSH
12583: LD_VAR 0 3
12587: PPUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 74
12597: PPUSH
12598: CALL_OW 115
// end else
12602: GO 12648
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: LD_INT 158
12611: PUSH
12612: LD_INT 61
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: LD_INT 98
12621: PUSH
12622: LD_INT 100
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 78
12631: PUSH
12632: LD_INT 93
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: LIST
12643: PPUSH
12644: CALL 109886 0 2
// end ; end ;
12648: GO 12174
12650: POP
12651: POP
// end ; end_of_file
12652: PPOPN 3
12654: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12655: LD_INT 0
12657: PPUSH
12658: PPUSH
12659: PPUSH
12660: PPUSH
12661: PPUSH
12662: PPUSH
12663: PPUSH
// SetInvulnrability ( alien , true ) ;
12664: LD_INT 1
12666: PPUSH
12667: LD_INT 1
12669: PPUSH
12670: CALL_OW 607
// side := 7 ;
12674: LD_ADDR_VAR 0 5
12678: PUSH
12679: LD_INT 7
12681: ST_TO_ADDR
// uc_side := side ;
12682: LD_ADDR_OWVAR 20
12686: PUSH
12687: LD_VAR 0 5
12691: ST_TO_ADDR
// uc_nation := 1 ;
12692: LD_ADDR_OWVAR 21
12696: PUSH
12697: LD_INT 1
12699: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12700: LD_ADDR_VAR 0 2
12704: PUSH
12705: LD_INT 22
12707: PUSH
12708: LD_VAR 0 5
12712: PUSH
12713: EMPTY
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 21
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: PPUSH
12731: CALL_OW 69
12735: PUSH
12736: FOR_IN
12737: IFFALSE 12753
// SetBLevel ( i , 10 ) ;
12739: LD_VAR 0 2
12743: PPUSH
12744: LD_INT 10
12746: PPUSH
12747: CALL_OW 241
12751: GO 12736
12753: POP
12754: POP
// base := GetBase ( al_depot ) ;
12755: LD_ADDR_VAR 0 4
12759: PUSH
12760: LD_INT 2
12762: PPUSH
12763: CALL_OW 274
12767: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12768: LD_ADDR_VAR 0 6
12772: PUSH
12773: LD_INT 22
12775: PUSH
12776: LD_VAR 0 5
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 30
12787: PUSH
12788: LD_INT 34
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: PPUSH
12799: CALL_OW 69
12803: ST_TO_ADDR
// if teleport then
12804: LD_VAR 0 6
12808: IFFALSE 12829
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12810: LD_VAR 0 6
12814: PUSH
12815: LD_INT 1
12817: ARRAY
12818: PPUSH
12819: LD_INT 262
12821: PPUSH
12822: LD_INT 119
12824: PPUSH
12825: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12829: LD_VAR 0 4
12833: PPUSH
12834: LD_INT 1
12836: PPUSH
12837: LD_INT 19500
12839: PPUSH
12840: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12844: LD_VAR 0 4
12848: PPUSH
12849: LD_INT 2
12851: PPUSH
12852: LD_INT 200
12854: PPUSH
12855: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12859: LD_VAR 0 4
12863: PPUSH
12864: LD_INT 3
12866: PPUSH
12867: LD_INT 650
12869: PPUSH
12870: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12874: LD_ADDR_EXP 79
12878: PUSH
12879: LD_STRING Roth
12881: PPUSH
12882: CALL_OW 25
12886: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12887: LD_ADDR_EXP 80
12891: PUSH
12892: LD_STRING Simms
12894: PPUSH
12895: LD_EXP 1
12899: NOT
12900: PPUSH
12901: LD_STRING 10c_
12903: PPUSH
12904: CALL 69591 0 3
12908: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12909: LD_EXP 80
12913: PPUSH
12914: LD_INT 4
12916: PPUSH
12917: CALL_OW 336
// if not Simms then
12921: LD_EXP 80
12925: NOT
12926: IFFALSE 12956
// begin uc_nation := 1 ;
12928: LD_ADDR_OWVAR 21
12932: PUSH
12933: LD_INT 1
12935: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12936: LD_INT 2
12938: PPUSH
12939: LD_INT 10
12941: PPUSH
12942: CALL_OW 384
// Simms := CreateHuman ;
12946: LD_ADDR_EXP 80
12950: PUSH
12951: CALL_OW 44
12955: ST_TO_ADDR
// end ; uc_nation := 3 ;
12956: LD_ADDR_OWVAR 21
12960: PUSH
12961: LD_INT 3
12963: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12964: LD_ADDR_EXP 81
12968: PUSH
12969: LD_STRING Kirilenkova
12971: PPUSH
12972: CALL_OW 25
12976: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12977: LD_ADDR_EXP 95
12981: PUSH
12982: LD_STRING Oblukov
12984: PPUSH
12985: CALL_OW 25
12989: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12990: LD_ADDR_EXP 82
12994: PUSH
12995: LD_STRING Dolgov
12997: PPUSH
12998: CALL_OW 25
13002: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13003: LD_ADDR_EXP 83
13007: PUSH
13008: LD_STRING Petrosyan
13010: PPUSH
13011: CALL_OW 25
13015: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13016: LD_ADDR_EXP 94
13020: PUSH
13021: LD_STRING Scholtze
13023: PPUSH
13024: CALL_OW 25
13028: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13029: LD_ADDR_EXP 93
13033: PUSH
13034: LD_STRING Kapitsova
13036: PPUSH
13037: CALL_OW 25
13041: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13042: LD_ADDR_EXP 84
13046: PUSH
13047: LD_STRING Petrovova
13049: PPUSH
13050: CALL_OW 25
13054: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13055: LD_ADDR_EXP 85
13059: PUSH
13060: LD_STRING Kuzmov
13062: PPUSH
13063: CALL_OW 25
13067: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13068: LD_ADDR_EXP 92
13072: PUSH
13073: LD_STRING Karamazov
13075: PPUSH
13076: CALL_OW 25
13080: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13081: LD_STRING 13_Lipshchin_1
13083: PPUSH
13084: LD_INT 0
13086: PPUSH
13087: CALL_OW 30
13091: IFFALSE 13106
// Lipshchin := NewCharacter ( Lipshchin ) ;
13093: LD_ADDR_EXP 86
13097: PUSH
13098: LD_STRING Lipshchin
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13106: LD_STRING 13_Titov_1
13108: PPUSH
13109: LD_INT 0
13111: PPUSH
13112: CALL_OW 30
13116: IFFALSE 13131
// Titov := NewCharacter ( Titov ) ;
13118: LD_ADDR_EXP 88
13122: PUSH
13123: LD_STRING Titov
13125: PPUSH
13126: CALL_OW 25
13130: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13131: LD_STRING 13_Gnyevko_1
13133: PPUSH
13134: LD_INT 0
13136: PPUSH
13137: CALL_OW 30
13141: IFFALSE 13156
// Gnyevko := NewCharacter ( Gnyevko ) ;
13143: LD_ADDR_EXP 87
13147: PUSH
13148: LD_STRING Gnyevko
13150: PPUSH
13151: CALL_OW 25
13155: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13156: LD_STRING 13_Xavier_1
13158: PPUSH
13159: LD_INT 0
13161: PPUSH
13162: CALL_OW 30
13166: IFFALSE 13181
// Xavier := NewCharacter ( Xavier2 ) ;
13168: LD_ADDR_EXP 89
13172: PUSH
13173: LD_STRING Xavier2
13175: PPUSH
13176: CALL_OW 25
13180: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13181: LD_STRING 13_Belkov_1
13183: PPUSH
13184: LD_INT 0
13186: PPUSH
13187: CALL_OW 30
13191: IFFALSE 13206
// Belkov := NewCharacter ( Belkov ) ;
13193: LD_ADDR_EXP 90
13197: PUSH
13198: LD_STRING Belkov
13200: PPUSH
13201: CALL_OW 25
13205: ST_TO_ADDR
// if not BurlakStatus then
13206: LD_EXP 9
13210: NOT
13211: IFFALSE 13226
// Burlak = NewCharacter ( Burlak ) ;
13213: LD_ADDR_EXP 91
13217: PUSH
13218: LD_STRING Burlak
13220: PPUSH
13221: CALL_OW 25
13225: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13226: LD_ADDR_VAR 0 3
13230: PUSH
13231: LD_EXP 79
13235: PUSH
13236: LD_EXP 81
13240: PUSH
13241: LD_EXP 95
13245: PUSH
13246: LD_EXP 82
13250: PUSH
13251: LD_EXP 83
13255: PUSH
13256: LD_EXP 94
13260: PUSH
13261: LD_EXP 93
13265: PUSH
13266: LD_EXP 84
13270: PUSH
13271: LD_EXP 85
13275: PUSH
13276: LD_EXP 92
13280: PUSH
13281: EMPTY
13282: LIST
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: ST_TO_ADDR
// if Simms then
13293: LD_EXP 80
13297: IFFALSE 13315
// tmp := tmp ^ Simms ;
13299: LD_ADDR_VAR 0 3
13303: PUSH
13304: LD_VAR 0 3
13308: PUSH
13309: LD_EXP 80
13313: ADD
13314: ST_TO_ADDR
// if Titov then
13315: LD_EXP 88
13319: IFFALSE 13337
// tmp := tmp ^ Titov ;
13321: LD_ADDR_VAR 0 3
13325: PUSH
13326: LD_VAR 0 3
13330: PUSH
13331: LD_EXP 88
13335: ADD
13336: ST_TO_ADDR
// if Lipshchin then
13337: LD_EXP 86
13341: IFFALSE 13359
// tmp := tmp ^ Lipshchin ;
13343: LD_ADDR_VAR 0 3
13347: PUSH
13348: LD_VAR 0 3
13352: PUSH
13353: LD_EXP 86
13357: ADD
13358: ST_TO_ADDR
// if Gnyevko then
13359: LD_EXP 87
13363: IFFALSE 13381
// tmp := tmp ^ Gnyevko ;
13365: LD_ADDR_VAR 0 3
13369: PUSH
13370: LD_VAR 0 3
13374: PUSH
13375: LD_EXP 87
13379: ADD
13380: ST_TO_ADDR
// if Xavier then
13381: LD_EXP 89
13385: IFFALSE 13403
// tmp := tmp ^ Xavier ;
13387: LD_ADDR_VAR 0 3
13391: PUSH
13392: LD_VAR 0 3
13396: PUSH
13397: LD_EXP 89
13401: ADD
13402: ST_TO_ADDR
// if Belkov then
13403: LD_EXP 90
13407: IFFALSE 13425
// tmp := tmp ^ Belkov ;
13409: LD_ADDR_VAR 0 3
13413: PUSH
13414: LD_VAR 0 3
13418: PUSH
13419: LD_EXP 90
13423: ADD
13424: ST_TO_ADDR
// if Burlak then
13425: LD_EXP 91
13429: IFFALSE 13447
// tmp := tmp ^ Burlak ;
13431: LD_ADDR_VAR 0 3
13435: PUSH
13436: LD_VAR 0 3
13440: PUSH
13441: LD_EXP 91
13445: ADD
13446: ST_TO_ADDR
// for i = 1 to 11 do
13447: LD_ADDR_VAR 0 2
13451: PUSH
13452: DOUBLE
13453: LD_INT 1
13455: DEC
13456: ST_TO_ADDR
13457: LD_INT 11
13459: PUSH
13460: FOR_TO
13461: IFFALSE 13529
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13463: LD_ADDR_OWVAR 21
13467: PUSH
13468: LD_INT 1
13470: PUSH
13471: LD_INT 3
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: LD_INT 1
13480: PPUSH
13481: LD_INT 2
13483: PPUSH
13484: CALL_OW 12
13488: ARRAY
13489: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13490: LD_INT 0
13492: PPUSH
13493: LD_INT 1
13495: PPUSH
13496: LD_INT 4
13498: PPUSH
13499: CALL_OW 12
13503: PPUSH
13504: LD_INT 10
13506: PPUSH
13507: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13511: LD_ADDR_VAR 0 3
13515: PUSH
13516: LD_VAR 0 3
13520: PUSH
13521: CALL_OW 44
13525: ADD
13526: ST_TO_ADDR
// end ;
13527: GO 13460
13529: POP
13530: POP
// for i in tmp do
13531: LD_ADDR_VAR 0 2
13535: PUSH
13536: LD_VAR 0 3
13540: PUSH
13541: FOR_IN
13542: IFFALSE 13567
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13544: LD_VAR 0 2
13548: PPUSH
13549: LD_INT 260
13551: PPUSH
13552: LD_INT 235
13554: PPUSH
13555: LD_INT 8
13557: PPUSH
13558: LD_INT 0
13560: PPUSH
13561: CALL_OW 50
13565: GO 13541
13567: POP
13568: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13569: LD_ADDR_EXP 102
13573: PUSH
13574: LD_EXP 102
13578: PPUSH
13579: LD_INT 1
13581: PPUSH
13582: LD_INT 22
13584: PUSH
13585: LD_VAR 0 5
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PUSH
13594: LD_INT 3
13596: PUSH
13597: LD_INT 21
13599: PUSH
13600: LD_INT 2
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PPUSH
13615: CALL_OW 69
13619: PUSH
13620: LD_EXP 79
13624: PUSH
13625: LD_EXP 80
13629: PUSH
13630: EMPTY
13631: LIST
13632: LIST
13633: DIFF
13634: PPUSH
13635: CALL_OW 1
13639: ST_TO_ADDR
// uc_side := 0 ;
13640: LD_ADDR_OWVAR 20
13644: PUSH
13645: LD_INT 0
13647: ST_TO_ADDR
// uc_nation := 0 ;
13648: LD_ADDR_OWVAR 21
13652: PUSH
13653: LD_INT 0
13655: ST_TO_ADDR
// for i = 1 to 5 do
13656: LD_ADDR_VAR 0 2
13660: PUSH
13661: DOUBLE
13662: LD_INT 1
13664: DEC
13665: ST_TO_ADDR
13666: LD_INT 5
13668: PUSH
13669: FOR_TO
13670: IFFALSE 13707
// begin InitHc ;
13672: CALL_OW 19
// hc_class := class_apeman ;
13676: LD_ADDR_OWVAR 28
13680: PUSH
13681: LD_INT 12
13683: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13684: CALL_OW 44
13688: PPUSH
13689: LD_INT 299
13691: PPUSH
13692: LD_INT 229
13694: PPUSH
13695: LD_INT 10
13697: PPUSH
13698: LD_INT 0
13700: PPUSH
13701: CALL_OW 50
// end ;
13705: GO 13669
13707: POP
13708: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13709: LD_EXP 79
13713: PPUSH
13714: LD_INT 259
13716: PPUSH
13717: LD_INT 235
13719: PPUSH
13720: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13724: LD_EXP 79
13728: PPUSH
13729: LD_INT 262
13731: PPUSH
13732: LD_INT 235
13734: PPUSH
13735: CALL_OW 178
// if Simms then
13739: LD_EXP 80
13743: IFFALSE 13774
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13745: LD_EXP 80
13749: PPUSH
13750: LD_INT 262
13752: PPUSH
13753: LD_INT 235
13755: PPUSH
13756: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13760: LD_EXP 80
13764: PPUSH
13765: LD_EXP 79
13769: PPUSH
13770: CALL_OW 179
// end ; uc_side := 7 ;
13774: LD_ADDR_OWVAR 20
13778: PUSH
13779: LD_INT 7
13781: ST_TO_ADDR
// uc_nation := 1 ;
13782: LD_ADDR_OWVAR 21
13786: PUSH
13787: LD_INT 1
13789: ST_TO_ADDR
// bc_type := b_control_tower ;
13790: LD_ADDR_OWVAR 42
13794: PUSH
13795: LD_INT 36
13797: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13798: LD_ADDR_VAR 0 7
13802: PUSH
13803: LD_INT 268
13805: PPUSH
13806: LD_INT 251
13808: PPUSH
13809: LD_INT 4
13811: PPUSH
13812: CALL_OW 47
13816: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13817: LD_INT 0
13819: PPUSH
13820: LD_INT 10
13822: PPUSH
13823: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13827: CALL_OW 44
13831: PPUSH
13832: LD_VAR 0 7
13836: PPUSH
13837: CALL_OW 52
// end ;
13841: LD_VAR 0 1
13845: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13846: LD_EXP 31
13850: PUSH
13851: LD_EXP 23
13855: NOT
13856: AND
13857: PUSH
13858: LD_INT 22
13860: PUSH
13861: LD_INT 7
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: LD_INT 30
13870: PUSH
13871: LD_INT 8
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PPUSH
13882: CALL_OW 69
13886: AND
13887: IFFALSE 14115
13889: GO 13891
13891: DISABLE
13892: LD_INT 0
13894: PPUSH
13895: PPUSH
13896: PPUSH
// begin enable ;
13897: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13898: LD_ADDR_VAR 0 2
13902: PUSH
13903: LD_INT 81
13905: PUSH
13906: LD_INT 7
13908: PUSH
13909: EMPTY
13910: LIST
13911: LIST
13912: PUSH
13913: LD_INT 2
13915: PUSH
13916: LD_INT 32
13918: PUSH
13919: LD_INT 3
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PUSH
13926: LD_INT 30
13928: PUSH
13929: LD_INT 30
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PUSH
13936: LD_INT 30
13938: PUSH
13939: LD_INT 28
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 34
13948: PUSH
13949: LD_INT 49
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 34
13958: PUSH
13959: LD_INT 10
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 34
13968: PUSH
13969: LD_INT 8
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PPUSH
13989: CALL_OW 69
13993: ST_TO_ADDR
// if not tmp then
13994: LD_VAR 0 2
13998: NOT
13999: IFFALSE 14003
// exit ;
14001: GO 14115
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14003: LD_VAR 0 2
14007: PPUSH
14008: LD_INT 34
14010: PUSH
14011: LD_INT 8
14013: PUSH
14014: EMPTY
14015: LIST
14016: LIST
14017: PPUSH
14018: CALL_OW 72
14022: IFFALSE 14055
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14024: LD_ADDR_VAR 0 3
14028: PUSH
14029: LD_VAR 0 2
14033: PPUSH
14034: LD_INT 34
14036: PUSH
14037: LD_INT 8
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: PPUSH
14044: CALL_OW 72
14048: PUSH
14049: LD_INT 1
14051: ARRAY
14052: ST_TO_ADDR
14053: GO 14079
// target := tmp [ rand ( 1 , tmp ) ] ;
14055: LD_ADDR_VAR 0 3
14059: PUSH
14060: LD_VAR 0 2
14064: PUSH
14065: LD_INT 1
14067: PPUSH
14068: LD_VAR 0 2
14072: PPUSH
14073: CALL_OW 12
14077: ARRAY
14078: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14079: LD_VAR 0 3
14083: PPUSH
14084: CALL_OW 255
14088: PUSH
14089: LD_INT 1
14091: EQUAL
14092: IFFALSE 14103
// CenterNowOnUnits ( target ) ;
14094: LD_VAR 0 3
14098: PPUSH
14099: CALL_OW 87
// SetLives ( target , 0 ) ;
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 0
14110: PPUSH
14111: CALL_OW 234
// end ;
14115: PPOPN 3
14117: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14118: LD_EXP 23
14122: NOT
14123: PUSH
14124: LD_EXP 31
14128: AND
14129: IFFALSE 14645
14131: GO 14133
14133: DISABLE
14134: LD_INT 0
14136: PPUSH
14137: PPUSH
14138: PPUSH
// begin uc_side := 7 ;
14139: LD_ADDR_OWVAR 20
14143: PUSH
14144: LD_INT 7
14146: ST_TO_ADDR
// uc_nation := 1 ;
14147: LD_ADDR_OWVAR 21
14151: PUSH
14152: LD_INT 1
14154: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14155: LD_ADDR_VAR 0 3
14159: PUSH
14160: LD_INT 125
14162: PUSH
14163: LD_INT 163
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: PUSH
14170: LD_INT 185
14172: PUSH
14173: LD_INT 168
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: PUSH
14180: LD_INT 111
14182: PUSH
14183: LD_INT 97
14185: PUSH
14186: EMPTY
14187: LIST
14188: LIST
14189: PUSH
14190: LD_INT 94
14192: PUSH
14193: LD_INT 114
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: PPUSH
14206: CALL 107387 0 1
14210: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14211: LD_ADDR_EXP 96
14215: PUSH
14216: EMPTY
14217: ST_TO_ADDR
// for i = 1 to Difficulty do
14218: LD_ADDR_VAR 0 1
14222: PUSH
14223: DOUBLE
14224: LD_INT 1
14226: DEC
14227: ST_TO_ADDR
14228: LD_OWVAR 67
14232: PUSH
14233: FOR_TO
14234: IFFALSE 14392
// begin InitHc ;
14236: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14240: LD_INT 0
14242: PPUSH
14243: LD_INT 8
14245: PPUSH
14246: CALL_OW 381
// un := CreateHuman ;
14250: LD_ADDR_VAR 0 2
14254: PUSH
14255: CALL_OW 44
14259: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14260: LD_VAR 0 2
14264: PPUSH
14265: LD_INT 258
14267: PPUSH
14268: LD_INT 267
14270: PPUSH
14271: LD_INT 4
14273: PPUSH
14274: LD_INT 0
14276: PPUSH
14277: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14281: LD_ADDR_EXP 96
14285: PUSH
14286: LD_EXP 96
14290: PUSH
14291: LD_VAR 0 2
14295: UNION
14296: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14297: LD_VAR 0 2
14301: PPUSH
14302: LD_VAR 0 3
14306: PUSH
14307: LD_VAR 0 1
14311: ARRAY
14312: PUSH
14313: LD_INT 1
14315: ARRAY
14316: PPUSH
14317: LD_VAR 0 3
14321: PUSH
14322: LD_VAR 0 1
14326: ARRAY
14327: PUSH
14328: LD_INT 2
14330: ARRAY
14331: PPUSH
14332: LD_INT 4
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14342: LD_VAR 0 2
14346: PPUSH
14347: LD_VAR 0 3
14351: PUSH
14352: LD_VAR 0 1
14356: ARRAY
14357: PUSH
14358: LD_INT 1
14360: ARRAY
14361: PPUSH
14362: LD_VAR 0 3
14366: PUSH
14367: LD_VAR 0 1
14371: ARRAY
14372: PUSH
14373: LD_INT 2
14375: ARRAY
14376: PPUSH
14377: CALL_OW 171
// AddComInvisible ( un ) ;
14381: LD_VAR 0 2
14385: PPUSH
14386: CALL_OW 212
// end ;
14390: GO 14233
14392: POP
14393: POP
// repeat wait ( 0 0$45 ) ;
14394: LD_INT 1575
14396: PPUSH
14397: CALL_OW 67
// for i in allianceSpecialForce do
14401: LD_ADDR_VAR 0 1
14405: PUSH
14406: LD_EXP 96
14410: PUSH
14411: FOR_IN
14412: IFFALSE 14630
// begin if IsInvisible ( i ) then
14414: LD_VAR 0 1
14418: PPUSH
14419: CALL_OW 571
14423: IFFALSE 14599
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: LD_INT 22
14432: PUSH
14433: LD_INT 1
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: PUSH
14440: LD_INT 50
14442: PUSH
14443: EMPTY
14444: LIST
14445: PUSH
14446: LD_INT 56
14448: PUSH
14449: EMPTY
14450: LIST
14451: PUSH
14452: LD_INT 91
14454: PUSH
14455: LD_VAR 0 1
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: LIST
14467: PUSH
14468: LD_INT 2
14470: PUSH
14471: LD_INT 25
14473: PUSH
14474: LD_INT 1
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PUSH
14481: LD_INT 25
14483: PUSH
14484: LD_INT 2
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 25
14493: PUSH
14494: LD_INT 3
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: PUSH
14501: LD_INT 25
14503: PUSH
14504: LD_INT 4
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: LD_INT 5
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 25
14523: PUSH
14524: LD_INT 8
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: PPUSH
14547: CALL_OW 69
14551: ST_TO_ADDR
// if not tmp then
14552: LD_VAR 0 3
14556: NOT
14557: IFFALSE 14561
// continue ;
14559: GO 14411
// if Prob ( 30 * Difficulty ) then
14561: LD_INT 30
14563: PUSH
14564: LD_OWVAR 67
14568: MUL
14569: PPUSH
14570: CALL_OW 13
14574: IFFALSE 14599
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14576: LD_VAR 0 3
14580: PUSH
14581: LD_INT 1
14583: PPUSH
14584: LD_VAR 0 3
14588: PPUSH
14589: CALL_OW 12
14593: ARRAY
14594: PPUSH
14595: CALL 34681 0 1
// end ; if IsDead ( i ) then
14599: LD_VAR 0 1
14603: PPUSH
14604: CALL_OW 301
14608: IFFALSE 14628
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14610: LD_ADDR_EXP 96
14614: PUSH
14615: LD_EXP 96
14619: PUSH
14620: LD_VAR 0 1
14624: DIFF
14625: ST_TO_ADDR
// continue ;
14626: GO 14411
// end ; end ;
14628: GO 14411
14630: POP
14631: POP
// until allianceDestroyed or not allianceSpecialForce ;
14632: LD_EXP 23
14636: PUSH
14637: LD_EXP 96
14641: NOT
14642: OR
14643: IFFALSE 14394
// end ;
14645: PPOPN 3
14647: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14648: LD_EXP 31
14652: PUSH
14653: LD_INT 22
14655: PUSH
14656: LD_INT 1
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 2
14665: PUSH
14666: LD_INT 35
14668: PUSH
14669: LD_INT 8
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 34
14678: PUSH
14679: LD_INT 8
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: LIST
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PPUSH
14695: CALL_OW 69
14699: AND
14700: IFFALSE 15100
14702: GO 14704
14704: DISABLE
14705: LD_INT 0
14707: PPUSH
14708: PPUSH
14709: PPUSH
14710: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14711: LD_ADDR_VAR 0 1
14715: PUSH
14716: DOUBLE
14717: LD_INT 1
14719: DEC
14720: ST_TO_ADDR
14721: LD_INT 6
14723: PUSH
14724: LD_INT 8
14726: PUSH
14727: LD_INT 10
14729: PUSH
14730: LD_INT 12
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: PUSH
14739: LD_OWVAR 67
14743: ARRAY
14744: PUSH
14745: FOR_TO
14746: IFFALSE 14938
// begin uc_side := 7 ;
14748: LD_ADDR_OWVAR 20
14752: PUSH
14753: LD_INT 7
14755: ST_TO_ADDR
// uc_nation := 1 ;
14756: LD_ADDR_OWVAR 21
14760: PUSH
14761: LD_INT 1
14763: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14764: LD_INT 5
14766: PPUSH
14767: LD_INT 3
14769: PPUSH
14770: LD_INT 2
14772: PUSH
14773: LD_INT 3
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: LD_INT 1
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 12
14790: ARRAY
14791: PPUSH
14792: LD_INT 6
14794: PUSH
14795: LD_INT 9
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 1
14804: PPUSH
14805: LD_INT 2
14807: PPUSH
14808: CALL_OW 12
14812: ARRAY
14813: PPUSH
14814: LD_INT 100
14816: PPUSH
14817: CALL 74431 0 5
// un := CreateVehicle ;
14821: LD_ADDR_VAR 0 2
14825: PUSH
14826: CALL_OW 45
14830: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14831: LD_VAR 0 2
14835: PPUSH
14836: LD_INT 4
14838: PPUSH
14839: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14843: LD_VAR 0 2
14847: PPUSH
14848: LD_INT 307
14850: PPUSH
14851: LD_INT 219
14853: PPUSH
14854: LD_INT 6
14856: PPUSH
14857: LD_INT 0
14859: PPUSH
14860: CALL_OW 50
// if GetControl ( un ) = control_remote then
14864: LD_VAR 0 2
14868: PPUSH
14869: CALL_OW 263
14873: PUSH
14874: LD_INT 2
14876: EQUAL
14877: IFFALSE 14888
// Connect ( un ) ;
14879: LD_VAR 0 2
14883: PPUSH
14884: CALL 77899 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14888: LD_VAR 0 2
14892: PPUSH
14893: LD_INT 124
14895: PPUSH
14896: LD_INT 92
14898: PPUSH
14899: LD_INT 12
14901: PPUSH
14902: LD_INT 1
14904: PPUSH
14905: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14909: LD_ADDR_VAR 0 3
14913: PUSH
14914: LD_VAR 0 3
14918: PPUSH
14919: LD_VAR 0 2
14923: PPUSH
14924: CALL 107282 0 2
14928: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14929: LD_INT 10
14931: PPUSH
14932: CALL_OW 67
// end ;
14936: GO 14745
14938: POP
14939: POP
// repeat wait ( 0 0$2 ) ;
14940: LD_INT 70
14942: PPUSH
14943: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14947: LD_ADDR_VAR 0 4
14951: PUSH
14952: LD_INT 22
14954: PUSH
14955: LD_INT 1
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: PUSH
14962: LD_INT 34
14964: PUSH
14965: LD_INT 8
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: PPUSH
14976: CALL_OW 69
14980: ST_TO_ADDR
// if not e then
14981: LD_VAR 0 4
14985: NOT
14986: IFFALSE 15022
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14988: LD_ADDR_VAR 0 4
14992: PUSH
14993: LD_INT 22
14995: PUSH
14996: LD_INT 1
14998: PUSH
14999: EMPTY
15000: LIST
15001: LIST
15002: PUSH
15003: LD_INT 21
15005: PUSH
15006: LD_INT 2
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PPUSH
15017: CALL_OW 69
15021: ST_TO_ADDR
// for i in tmp do
15022: LD_ADDR_VAR 0 1
15026: PUSH
15027: LD_VAR 0 3
15031: PUSH
15032: FOR_IN
15033: IFFALSE 15091
// if not IsOK ( i ) then
15035: LD_VAR 0 1
15039: PPUSH
15040: CALL_OW 302
15044: NOT
15045: IFFALSE 15065
// tmp := tmp diff i else
15047: LD_ADDR_VAR 0 3
15051: PUSH
15052: LD_VAR 0 3
15056: PUSH
15057: LD_VAR 0 1
15061: DIFF
15062: ST_TO_ADDR
15063: GO 15089
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15065: LD_VAR 0 1
15069: PPUSH
15070: LD_VAR 0 4
15074: PPUSH
15075: LD_VAR 0 1
15079: PPUSH
15080: CALL_OW 74
15084: PPUSH
15085: CALL_OW 115
15089: GO 15032
15091: POP
15092: POP
// until not tmp ;
15093: LD_VAR 0 3
15097: NOT
15098: IFFALSE 14940
// end ;
15100: PPOPN 4
15102: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15103: LD_EXP 23
15107: NOT
15108: PUSH
15109: LD_EXP 31
15113: AND
15114: IFFALSE 16167
15116: GO 15118
15118: DISABLE
15119: LD_INT 0
15121: PPUSH
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
// begin enable ;
15126: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15127: LD_INT 22
15129: PUSH
15130: LD_INT 7
15132: PUSH
15133: EMPTY
15134: LIST
15135: LIST
15136: PUSH
15137: LD_INT 30
15139: PUSH
15140: LD_INT 3
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PPUSH
15151: CALL_OW 69
15155: NOT
15156: IFFALSE 15160
// exit ;
15158: GO 16167
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15160: LD_ADDR_VAR 0 4
15164: PUSH
15165: LD_INT 22
15167: PUSH
15168: LD_INT 7
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 30
15177: PUSH
15178: LD_INT 34
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: PPUSH
15189: CALL_OW 69
15193: ST_TO_ADDR
// if Prob ( 40 ) then
15194: LD_INT 40
15196: PPUSH
15197: CALL_OW 13
15201: IFFALSE 15347
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15203: LD_INT 1
15205: PPUSH
15206: LD_INT 5
15208: PUSH
15209: LD_INT 3
15211: PUSH
15212: LD_INT 2
15214: PUSH
15215: LD_INT 6
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: PUSH
15224: LD_INT 5
15226: PUSH
15227: LD_INT 3
15229: PUSH
15230: LD_INT 2
15232: PUSH
15233: LD_INT 6
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: PUSH
15242: LD_INT 5
15244: PUSH
15245: LD_INT 3
15247: PUSH
15248: LD_INT 2
15250: PUSH
15251: LD_INT 6
15253: PUSH
15254: EMPTY
15255: LIST
15256: LIST
15257: LIST
15258: LIST
15259: PUSH
15260: LD_INT 5
15262: PUSH
15263: LD_INT 3
15265: PUSH
15266: LD_INT 2
15268: PUSH
15269: LD_INT 9
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: PUSH
15278: LD_INT 24
15280: PUSH
15281: LD_INT 3
15283: PUSH
15284: LD_INT 3
15286: PUSH
15287: LD_INT 45
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 24
15298: PUSH
15299: LD_INT 3
15301: PUSH
15302: LD_INT 3
15304: PUSH
15305: LD_INT 47
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 24
15316: PUSH
15317: LD_INT 3
15319: PUSH
15320: LD_INT 3
15322: PUSH
15323: LD_INT 45
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: PPUSH
15341: CALL 63165 0 2
// end else
15345: GO 15489
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15347: LD_INT 1
15349: PPUSH
15350: LD_INT 24
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 3
15358: PUSH
15359: LD_INT 47
15361: PUSH
15362: EMPTY
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: PUSH
15368: LD_INT 24
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: LD_INT 47
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: PUSH
15386: LD_INT 5
15388: PUSH
15389: LD_INT 3
15391: PUSH
15392: LD_INT 2
15394: PUSH
15395: LD_INT 9
15397: PUSH
15398: EMPTY
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: PUSH
15404: LD_INT 5
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 2
15412: PUSH
15413: LD_INT 9
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: LIST
15420: LIST
15421: PUSH
15422: LD_INT 5
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 2
15430: PUSH
15431: LD_INT 9
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: PUSH
15440: LD_INT 24
15442: PUSH
15443: LD_INT 1
15445: PUSH
15446: LD_INT 3
15448: PUSH
15449: LD_INT 45
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: PUSH
15458: LD_INT 24
15460: PUSH
15461: LD_INT 1
15463: PUSH
15464: LD_INT 3
15466: PUSH
15467: LD_INT 45
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: PPUSH
15485: CALL 63165 0 2
// end ; wait ( 2 2$00 ) ;
15489: LD_INT 4200
15491: PPUSH
15492: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15496: LD_ADDR_VAR 0 2
15500: PUSH
15501: LD_INT 22
15503: PUSH
15504: LD_INT 7
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: LD_INT 21
15513: PUSH
15514: LD_INT 2
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PUSH
15521: LD_INT 3
15523: PUSH
15524: LD_INT 34
15526: PUSH
15527: LD_INT 13
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PUSH
15534: LD_INT 34
15536: PUSH
15537: LD_INT 12
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PUSH
15544: LD_INT 34
15546: PUSH
15547: LD_INT 51
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PUSH
15554: LD_INT 34
15556: PUSH
15557: LD_INT 52
15559: PUSH
15560: EMPTY
15561: LIST
15562: LIST
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: LIST
15575: PPUSH
15576: CALL_OW 69
15580: PUSH
15581: LD_EXP 124
15585: PUSH
15586: LD_INT 1
15588: ARRAY
15589: DIFF
15590: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15591: LD_ADDR_EXP 121
15595: PUSH
15596: LD_EXP 121
15600: PPUSH
15601: LD_INT 1
15603: PPUSH
15604: LD_EXP 121
15608: PUSH
15609: LD_INT 1
15611: ARRAY
15612: PUSH
15613: LD_VAR 0 2
15617: DIFF
15618: PPUSH
15619: CALL_OW 1
15623: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15624: LD_ADDR_VAR 0 3
15628: PUSH
15629: LD_INT 0
15631: PPUSH
15632: LD_INT 1
15634: PPUSH
15635: CALL_OW 12
15639: ST_TO_ADDR
// p := 0 ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_INT 0
15647: ST_TO_ADDR
// if target then
15648: LD_VAR 0 3
15652: IFFALSE 15843
// begin for i in tmp do
15654: LD_ADDR_VAR 0 1
15658: PUSH
15659: LD_VAR 0 2
15663: PUSH
15664: FOR_IN
15665: IFFALSE 15690
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15667: LD_VAR 0 1
15671: PPUSH
15672: LD_INT 179
15674: PPUSH
15675: LD_INT 209
15677: PPUSH
15678: LD_INT 8
15680: PPUSH
15681: LD_INT 1
15683: PPUSH
15684: CALL_OW 483
15688: GO 15664
15690: POP
15691: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15692: LD_ADDR_VAR 0 2
15696: PUSH
15697: LD_VAR 0 2
15701: PPUSH
15702: LD_INT 24
15704: PUSH
15705: LD_INT 250
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PPUSH
15712: CALL_OW 72
15716: ST_TO_ADDR
// for i in tmp do
15717: LD_ADDR_VAR 0 1
15721: PUSH
15722: LD_VAR 0 2
15726: PUSH
15727: FOR_IN
15728: IFFALSE 15768
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15730: LD_VAR 0 1
15734: PPUSH
15735: LD_INT 179
15737: PPUSH
15738: LD_INT 209
15740: PPUSH
15741: CALL_OW 297
15745: PUSH
15746: LD_INT 9
15748: GREATER
15749: IFFALSE 15766
// ComMoveXY ( i , 179 , 209 ) ;
15751: LD_VAR 0 1
15755: PPUSH
15756: LD_INT 179
15758: PPUSH
15759: LD_INT 209
15761: PPUSH
15762: CALL_OW 111
15766: GO 15727
15768: POP
15769: POP
// wait ( 0 0$1 ) ;
15770: LD_INT 35
15772: PPUSH
15773: CALL_OW 67
// p := Inc ( p ) ;
15777: LD_ADDR_VAR 0 5
15781: PUSH
15782: LD_VAR 0 5
15786: PPUSH
15787: CALL 108643 0 1
15791: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15792: LD_VAR 0 2
15796: PPUSH
15797: LD_INT 92
15799: PUSH
15800: LD_INT 179
15802: PUSH
15803: LD_INT 209
15805: PUSH
15806: LD_INT 9
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: LIST
15813: LIST
15814: PPUSH
15815: CALL_OW 72
15819: PUSH
15820: LD_VAR 0 2
15824: PUSH
15825: LD_INT 1
15827: MINUS
15828: GREATEREQUAL
15829: PUSH
15830: LD_VAR 0 5
15834: PUSH
15835: LD_INT 30
15837: GREATER
15838: OR
15839: IFFALSE 15692
// end else
15841: GO 16030
// begin for i in tmp do
15843: LD_ADDR_VAR 0 1
15847: PUSH
15848: LD_VAR 0 2
15852: PUSH
15853: FOR_IN
15854: IFFALSE 15879
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15856: LD_VAR 0 1
15860: PPUSH
15861: LD_INT 285
15863: PPUSH
15864: LD_INT 163
15866: PPUSH
15867: LD_INT 8
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: CALL_OW 483
15877: GO 15853
15879: POP
15880: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15881: LD_ADDR_VAR 0 2
15885: PUSH
15886: LD_VAR 0 2
15890: PPUSH
15891: LD_INT 24
15893: PUSH
15894: LD_INT 250
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PPUSH
15901: CALL_OW 72
15905: ST_TO_ADDR
// for i in tmp do
15906: LD_ADDR_VAR 0 1
15910: PUSH
15911: LD_VAR 0 2
15915: PUSH
15916: FOR_IN
15917: IFFALSE 15957
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15919: LD_VAR 0 1
15923: PPUSH
15924: LD_INT 285
15926: PPUSH
15927: LD_INT 163
15929: PPUSH
15930: CALL_OW 297
15934: PUSH
15935: LD_INT 9
15937: GREATER
15938: IFFALSE 15955
// ComMoveXY ( i , 285 , 163 ) ;
15940: LD_VAR 0 1
15944: PPUSH
15945: LD_INT 285
15947: PPUSH
15948: LD_INT 163
15950: PPUSH
15951: CALL_OW 111
15955: GO 15916
15957: POP
15958: POP
// wait ( 0 0$1 ) ;
15959: LD_INT 35
15961: PPUSH
15962: CALL_OW 67
// p := Inc ( p ) ;
15966: LD_ADDR_VAR 0 5
15970: PUSH
15971: LD_VAR 0 5
15975: PPUSH
15976: CALL 108643 0 1
15980: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15981: LD_VAR 0 2
15985: PPUSH
15986: LD_INT 92
15988: PUSH
15989: LD_INT 285
15991: PUSH
15992: LD_INT 163
15994: PUSH
15995: LD_INT 9
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: PPUSH
16004: CALL_OW 72
16008: PUSH
16009: LD_VAR 0 2
16013: PUSH
16014: LD_INT 1
16016: MINUS
16017: GREATEREQUAL
16018: PUSH
16019: LD_VAR 0 5
16023: PUSH
16024: LD_INT 30
16026: GREATER
16027: OR
16028: IFFALSE 15881
// end ; repeat wait ( 0 0$1 ) ;
16030: LD_INT 35
16032: PPUSH
16033: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16037: LD_ADDR_VAR 0 2
16041: PUSH
16042: LD_VAR 0 2
16046: PPUSH
16047: LD_INT 50
16049: PUSH
16050: EMPTY
16051: LIST
16052: PPUSH
16053: CALL_OW 72
16057: ST_TO_ADDR
// for i in tmp do
16058: LD_ADDR_VAR 0 1
16062: PUSH
16063: LD_VAR 0 2
16067: PUSH
16068: FOR_IN
16069: IFFALSE 16158
// if GetWeapon ( i ) = ru_time_lapser then
16071: LD_VAR 0 1
16075: PPUSH
16076: CALL_OW 264
16080: PUSH
16081: LD_INT 49
16083: EQUAL
16084: IFFALSE 16122
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16086: LD_VAR 0 1
16090: PPUSH
16091: LD_INT 81
16093: PUSH
16094: LD_INT 7
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PPUSH
16101: CALL_OW 69
16105: PPUSH
16106: LD_VAR 0 1
16110: PPUSH
16111: CALL_OW 74
16115: PPUSH
16116: CALL_OW 112
16120: GO 16156
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16122: LD_VAR 0 1
16126: PPUSH
16127: LD_INT 81
16129: PUSH
16130: LD_INT 7
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PPUSH
16137: CALL_OW 69
16141: PPUSH
16142: LD_VAR 0 1
16146: PPUSH
16147: CALL_OW 74
16151: PPUSH
16152: CALL_OW 115
16156: GO 16068
16158: POP
16159: POP
// until not tmp ;
16160: LD_VAR 0 2
16164: NOT
16165: IFFALSE 16030
// end ;
16167: PPOPN 5
16169: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16170: LD_EXP 31
16174: PUSH
16175: LD_EXP 79
16179: PPUSH
16180: CALL_OW 302
16184: AND
16185: PUSH
16186: LD_OWVAR 67
16190: PUSH
16191: LD_INT 2
16193: GREATER
16194: AND
16195: IFFALSE 16295
16197: GO 16199
16199: DISABLE
// begin enable ;
16200: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16201: LD_EXP 79
16205: PPUSH
16206: LD_INT 245
16208: PPUSH
16209: LD_INT 234
16211: PPUSH
16212: CALL_OW 297
16216: PUSH
16217: LD_INT 6
16219: GREATER
16220: IFFALSE 16239
// ComMoveXY ( Roth , 245 , 234 ) else
16222: LD_EXP 79
16226: PPUSH
16227: LD_INT 245
16229: PPUSH
16230: LD_INT 234
16232: PPUSH
16233: CALL_OW 111
16237: GO 16295
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16239: LD_EXP 79
16243: PPUSH
16244: LD_INT 259
16246: PUSH
16247: LD_INT 235
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PUSH
16254: LD_INT 252
16256: PUSH
16257: LD_INT 209
16259: PUSH
16260: EMPTY
16261: LIST
16262: LIST
16263: PUSH
16264: LD_INT 275
16266: PUSH
16267: LD_INT 235
16269: PUSH
16270: EMPTY
16271: LIST
16272: LIST
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: LIST
16278: PUSH
16279: LD_INT 1
16281: PPUSH
16282: LD_INT 3
16284: PPUSH
16285: CALL_OW 12
16289: ARRAY
16290: PPUSH
16291: CALL 111430 0 2
// end ; end_of_file
16295: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16296: LD_INT 0
16298: PPUSH
16299: PPUSH
16300: PPUSH
16301: PPUSH
// missionStage := 13 ;
16302: LD_ADDR_EXP 15
16306: PUSH
16307: LD_INT 13
16309: ST_TO_ADDR
// uc_side := 2 ;
16310: LD_ADDR_OWVAR 20
16314: PUSH
16315: LD_INT 2
16317: ST_TO_ADDR
// uc_nation := 2 ;
16318: LD_ADDR_OWVAR 21
16322: PUSH
16323: LD_INT 2
16325: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16326: LD_ADDR_EXP 97
16330: PUSH
16331: LD_STRING Omar
16333: PPUSH
16334: CALL_OW 25
16338: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16339: LD_EXP 97
16343: PPUSH
16344: LD_INT 4
16346: PPUSH
16347: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16351: LD_EXP 97
16355: PPUSH
16356: LD_INT 242
16358: PPUSH
16359: LD_INT 75
16361: PPUSH
16362: LD_INT 0
16364: PPUSH
16365: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16369: LD_ADDR_EXP 98
16373: PUSH
16374: LD_STRING Heike
16376: PPUSH
16377: CALL_OW 25
16381: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16382: LD_INT 14
16384: PPUSH
16385: LD_INT 3
16387: PPUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_INT 27
16393: PPUSH
16394: LD_INT 100
16396: PPUSH
16397: CALL 74431 0 5
// veh := CreateVehicle ;
16401: LD_ADDR_VAR 0 3
16405: PUSH
16406: CALL_OW 45
16410: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16411: LD_VAR 0 3
16415: PPUSH
16416: LD_INT 2
16418: NEG
16419: PPUSH
16420: CALL_OW 242
// SetDir ( veh , 4 ) ;
16424: LD_VAR 0 3
16428: PPUSH
16429: LD_INT 4
16431: PPUSH
16432: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16436: LD_VAR 0 3
16440: PPUSH
16441: LD_INT 241
16443: PPUSH
16444: LD_INT 72
16446: PPUSH
16447: LD_INT 0
16449: PPUSH
16450: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16454: LD_EXP 98
16458: PPUSH
16459: LD_VAR 0 3
16463: PPUSH
16464: CALL_OW 52
// if KhatamStatus then
16468: LD_EXP 8
16472: IFFALSE 16535
// begin Khatam := NewCharacter ( Khatam ) ;
16474: LD_ADDR_EXP 99
16478: PUSH
16479: LD_STRING Khatam
16481: PPUSH
16482: CALL_OW 25
16486: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16487: LD_EXP 99
16491: PPUSH
16492: LD_INT 245
16494: PPUSH
16495: LD_INT 78
16497: PPUSH
16498: LD_INT 3
16500: PPUSH
16501: LD_INT 0
16503: PPUSH
16504: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16508: LD_EXP 99
16512: PPUSH
16513: LD_INT 4
16515: PPUSH
16516: LD_INT 10
16518: PPUSH
16519: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16523: LD_EXP 99
16527: PPUSH
16528: LD_INT 4
16530: PPUSH
16531: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16535: LD_ADDR_VAR 0 2
16539: PUSH
16540: DOUBLE
16541: LD_INT 1
16543: DEC
16544: ST_TO_ADDR
16545: LD_INT 2
16547: PUSH
16548: LD_INT 2
16550: PUSH
16551: LD_INT 3
16553: PUSH
16554: LD_INT 3
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: LIST
16561: LIST
16562: PUSH
16563: LD_OWVAR 67
16567: ARRAY
16568: PUSH
16569: FOR_TO
16570: IFFALSE 16636
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16572: LD_INT 0
16574: PPUSH
16575: LD_INT 6
16577: PUSH
16578: LD_OWVAR 67
16582: PLUS
16583: PPUSH
16584: CALL_OW 384
// un := CreateHuman ;
16588: LD_ADDR_VAR 0 4
16592: PUSH
16593: CALL_OW 44
16597: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16598: LD_VAR 0 4
16602: PPUSH
16603: LD_INT 28
16605: PUSH
16606: LD_INT 29
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: PUSH
16613: LD_VAR 0 2
16617: PUSH
16618: LD_INT 2
16620: MOD
16621: PUSH
16622: LD_INT 1
16624: PLUS
16625: ARRAY
16626: PPUSH
16627: LD_INT 0
16629: PPUSH
16630: CALL_OW 49
// end ;
16634: GO 16569
16636: POP
16637: POP
// for i = 1 to 6 do
16638: LD_ADDR_VAR 0 2
16642: PUSH
16643: DOUBLE
16644: LD_INT 1
16646: DEC
16647: ST_TO_ADDR
16648: LD_INT 6
16650: PUSH
16651: FOR_TO
16652: IFFALSE 16697
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16654: LD_INT 0
16656: PPUSH
16657: LD_INT 6
16659: PUSH
16660: LD_OWVAR 67
16664: PLUS
16665: PPUSH
16666: CALL_OW 381
// un := CreateHuman ;
16670: LD_ADDR_VAR 0 4
16674: PUSH
16675: CALL_OW 44
16679: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16680: LD_VAR 0 4
16684: PPUSH
16685: LD_INT 32
16687: PPUSH
16688: LD_INT 0
16690: PPUSH
16691: CALL_OW 49
// end ;
16695: GO 16651
16697: POP
16698: POP
// for i = 1 to 3 do
16699: LD_ADDR_VAR 0 2
16703: PUSH
16704: DOUBLE
16705: LD_INT 1
16707: DEC
16708: ST_TO_ADDR
16709: LD_INT 3
16711: PUSH
16712: FOR_TO
16713: IFFALSE 16761
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16715: LD_INT 0
16717: PPUSH
16718: LD_INT 8
16720: PPUSH
16721: LD_INT 6
16723: PUSH
16724: LD_OWVAR 67
16728: PLUS
16729: PPUSH
16730: CALL_OW 380
// un := CreateHuman ;
16734: LD_ADDR_VAR 0 4
16738: PUSH
16739: CALL_OW 44
16743: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16744: LD_VAR 0 4
16748: PPUSH
16749: LD_INT 32
16751: PPUSH
16752: LD_INT 0
16754: PPUSH
16755: CALL_OW 49
// end ;
16759: GO 16712
16761: POP
16762: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16763: LD_ADDR_VAR 0 2
16767: PUSH
16768: DOUBLE
16769: LD_INT 1
16771: DEC
16772: ST_TO_ADDR
16773: LD_INT 2
16775: PUSH
16776: LD_INT 3
16778: PUSH
16779: LD_INT 4
16781: PUSH
16782: LD_INT 4
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: PUSH
16791: LD_OWVAR 67
16795: ARRAY
16796: PUSH
16797: FOR_TO
16798: IFFALSE 16888
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16800: LD_INT 14
16802: PPUSH
16803: LD_INT 2
16805: PPUSH
16806: LD_INT 1
16808: PPUSH
16809: LD_INT 28
16811: PPUSH
16812: LD_INT 80
16814: PPUSH
16815: CALL 74431 0 5
// veh := CreateVehicle ;
16819: LD_ADDR_VAR 0 3
16823: PUSH
16824: CALL_OW 45
16828: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16829: LD_VAR 0 3
16833: PPUSH
16834: LD_INT 3
16836: PPUSH
16837: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16841: LD_VAR 0 3
16845: PPUSH
16846: LD_INT 29
16848: PPUSH
16849: LD_INT 0
16851: PPUSH
16852: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16856: LD_INT 0
16858: PPUSH
16859: LD_INT 6
16861: PUSH
16862: LD_OWVAR 67
16866: PLUS
16867: PPUSH
16868: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16872: CALL_OW 44
16876: PPUSH
16877: LD_VAR 0 3
16881: PPUSH
16882: CALL_OW 52
// end ;
16886: GO 16797
16888: POP
16889: POP
// for i = 1 to 5 + Difficulty do
16890: LD_ADDR_VAR 0 2
16894: PUSH
16895: DOUBLE
16896: LD_INT 1
16898: DEC
16899: ST_TO_ADDR
16900: LD_INT 5
16902: PUSH
16903: LD_OWVAR 67
16907: PLUS
16908: PUSH
16909: FOR_TO
16910: IFFALSE 17037
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16912: LD_INT 14
16914: PPUSH
16915: LD_INT 1
16917: PPUSH
16918: LD_INT 3
16920: PPUSH
16921: CALL_OW 12
16925: PPUSH
16926: LD_INT 1
16928: PPUSH
16929: LD_INT 28
16931: PUSH
16932: LD_INT 26
16934: PUSH
16935: LD_INT 27
16937: PUSH
16938: LD_INT 25
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: PUSH
16947: LD_VAR 0 2
16951: PUSH
16952: LD_INT 4
16954: MOD
16955: PUSH
16956: LD_INT 1
16958: PLUS
16959: ARRAY
16960: PPUSH
16961: LD_INT 80
16963: PPUSH
16964: CALL 74431 0 5
// veh := CreateVehicle ;
16968: LD_ADDR_VAR 0 3
16972: PUSH
16973: CALL_OW 45
16977: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16978: LD_VAR 0 3
16982: PPUSH
16983: LD_INT 4
16985: PPUSH
16986: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16990: LD_VAR 0 3
16994: PPUSH
16995: LD_INT 28
16997: PPUSH
16998: LD_INT 0
17000: PPUSH
17001: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17005: LD_INT 0
17007: PPUSH
17008: LD_INT 6
17010: PUSH
17011: LD_OWVAR 67
17015: PLUS
17016: PPUSH
17017: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17021: CALL_OW 44
17025: PPUSH
17026: LD_VAR 0 3
17030: PPUSH
17031: CALL_OW 52
// end ;
17035: GO 16909
17037: POP
17038: POP
// for i = 1 to Difficulty do
17039: LD_ADDR_VAR 0 2
17043: PUSH
17044: DOUBLE
17045: LD_INT 1
17047: DEC
17048: ST_TO_ADDR
17049: LD_OWVAR 67
17053: PUSH
17054: FOR_TO
17055: IFFALSE 17115
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17057: LD_INT 14
17059: PPUSH
17060: LD_INT 3
17062: PPUSH
17063: LD_INT 5
17065: PPUSH
17066: LD_INT 29
17068: PPUSH
17069: LD_INT 80
17071: PPUSH
17072: CALL 74431 0 5
// veh := CreateVehicle ;
17076: LD_ADDR_VAR 0 3
17080: PUSH
17081: CALL_OW 45
17085: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17086: LD_VAR 0 3
17090: PPUSH
17091: LD_INT 4
17093: PPUSH
17094: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17098: LD_VAR 0 3
17102: PPUSH
17103: LD_INT 28
17105: PPUSH
17106: LD_INT 0
17108: PPUSH
17109: CALL_OW 49
// end ;
17113: GO 17054
17115: POP
17116: POP
// end ;
17117: LD_VAR 0 1
17121: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17122: LD_INT 22
17124: PUSH
17125: LD_INT 2
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PPUSH
17132: CALL_OW 69
17136: IFFALSE 17515
17138: GO 17140
17140: DISABLE
17141: LD_INT 0
17143: PPUSH
17144: PPUSH
17145: PPUSH
17146: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17147: LD_ADDR_VAR 0 3
17151: PUSH
17152: LD_INT 22
17154: PUSH
17155: LD_INT 2
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: PUSH
17162: LD_INT 25
17164: PUSH
17165: LD_INT 4
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: PPUSH
17176: CALL_OW 69
17180: PUSH
17181: LD_EXP 99
17185: DIFF
17186: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17187: LD_ADDR_VAR 0 2
17191: PUSH
17192: LD_INT 22
17194: PUSH
17195: LD_INT 2
17197: PUSH
17198: EMPTY
17199: LIST
17200: LIST
17201: PPUSH
17202: CALL_OW 69
17206: PUSH
17207: LD_EXP 99
17211: PUSH
17212: LD_VAR 0 3
17216: UNION
17217: DIFF
17218: ST_TO_ADDR
// if Khatam then
17219: LD_EXP 99
17223: IFFALSE 17240
// ComMoveXY ( Khatam , 211 , 92 ) ;
17225: LD_EXP 99
17229: PPUSH
17230: LD_INT 211
17232: PPUSH
17233: LD_INT 92
17235: PPUSH
17236: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17240: LD_INT 197
17242: PPUSH
17243: LD_INT 80
17245: PPUSH
17246: LD_INT 2
17248: PPUSH
17249: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17253: LD_INT 213
17255: PPUSH
17256: LD_INT 90
17258: PPUSH
17259: LD_INT 2
17261: PPUSH
17262: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17266: LD_INT 215
17268: PPUSH
17269: LD_INT 129
17271: PPUSH
17272: LD_INT 2
17274: PPUSH
17275: CALL_OW 441
// if sci then
17279: LD_VAR 0 3
17283: IFFALSE 17304
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17285: LD_VAR 0 3
17289: PUSH
17290: LD_INT 1
17292: ARRAY
17293: PPUSH
17294: LD_INT 197
17296: PPUSH
17297: LD_INT 80
17299: PPUSH
17300: CALL_OW 158
// if sci > 1 then
17304: LD_VAR 0 3
17308: PUSH
17309: LD_INT 1
17311: GREATER
17312: IFFALSE 17333
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17314: LD_VAR 0 3
17318: PUSH
17319: LD_INT 2
17321: ARRAY
17322: PPUSH
17323: LD_INT 213
17325: PPUSH
17326: LD_INT 90
17328: PPUSH
17329: CALL_OW 158
// if sci > 2 then
17333: LD_VAR 0 3
17337: PUSH
17338: LD_INT 2
17340: GREATER
17341: IFFALSE 17362
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17343: LD_VAR 0 3
17347: PUSH
17348: LD_INT 3
17350: ARRAY
17351: PPUSH
17352: LD_INT 215
17354: PPUSH
17355: LD_INT 129
17357: PPUSH
17358: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17362: LD_VAR 0 2
17366: PPUSH
17367: LD_INT 195
17369: PPUSH
17370: LD_INT 102
17372: PPUSH
17373: CALL_OW 114
// wait ( 0 0$5 ) ;
17377: LD_INT 175
17379: PPUSH
17380: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17384: LD_INT 70
17386: PPUSH
17387: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17391: LD_ADDR_VAR 0 4
17395: PUSH
17396: LD_INT 92
17398: PUSH
17399: LD_INT 195
17401: PUSH
17402: LD_INT 102
17404: PUSH
17405: LD_INT 36
17407: PUSH
17408: EMPTY
17409: LIST
17410: LIST
17411: LIST
17412: LIST
17413: PUSH
17414: LD_INT 22
17416: PUSH
17417: LD_INT 1
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: PPUSH
17428: CALL_OW 69
17432: ST_TO_ADDR
// for i in tmp do
17433: LD_ADDR_VAR 0 1
17437: PUSH
17438: LD_VAR 0 2
17442: PUSH
17443: FOR_IN
17444: IFFALSE 17495
// if enemy then
17446: LD_VAR 0 4
17450: IFFALSE 17478
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17452: LD_VAR 0 1
17456: PPUSH
17457: LD_VAR 0 4
17461: PPUSH
17462: LD_VAR 0 1
17466: PPUSH
17467: CALL_OW 74
17471: PPUSH
17472: CALL_OW 115
17476: GO 17493
// ComAgressiveMove ( i , 195 , 102 ) ;
17478: LD_VAR 0 1
17482: PPUSH
17483: LD_INT 195
17485: PPUSH
17486: LD_INT 102
17488: PPUSH
17489: CALL_OW 114
17493: GO 17443
17495: POP
17496: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17497: LD_VAR 0 2
17501: PPUSH
17502: LD_INT 50
17504: PUSH
17505: EMPTY
17506: LIST
17507: PPUSH
17508: CALL_OW 72
17512: NOT
17513: IFFALSE 17384
// end ; end_of_file
17515: PPOPN 4
17517: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
17523: PPUSH
17524: PPUSH
17525: PPUSH
17526: PPUSH
17527: PPUSH
17528: PPUSH
// Video ( true ) ;
17529: LD_INT 1
17531: PPUSH
17532: CALL 107254 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17536: LD_ADDR_VAR 0 5
17540: PUSH
17541: LD_INT 7
17543: PPUSH
17544: LD_INT 0
17546: PPUSH
17547: CALL_OW 517
17551: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17552: LD_ADDR_VAR 0 2
17556: PUSH
17557: DOUBLE
17558: LD_INT 1
17560: DEC
17561: ST_TO_ADDR
17562: LD_VAR 0 5
17566: PUSH
17567: LD_INT 1
17569: ARRAY
17570: PUSH
17571: FOR_TO
17572: IFFALSE 17617
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17574: LD_VAR 0 5
17578: PUSH
17579: LD_INT 1
17581: ARRAY
17582: PUSH
17583: LD_VAR 0 2
17587: ARRAY
17588: PPUSH
17589: LD_VAR 0 5
17593: PUSH
17594: LD_INT 2
17596: ARRAY
17597: PUSH
17598: LD_VAR 0 2
17602: ARRAY
17603: PPUSH
17604: LD_INT 1
17606: PPUSH
17607: LD_INT 15
17609: NEG
17610: PPUSH
17611: CALL 107168 0 4
17615: GO 17571
17617: POP
17618: POP
// CenterNowOnUnits ( Powell ) ;
17619: LD_EXP 61
17623: PPUSH
17624: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17628: LD_ADDR_VAR 0 5
17632: PUSH
17633: LD_EXP 59
17637: PUSH
17638: EMPTY
17639: LIST
17640: ST_TO_ADDR
// if GirlNewVeh then
17641: LD_EXP 60
17645: IFFALSE 17663
// tmp := tmp ^ GirlNewVeh ;
17647: LD_ADDR_VAR 0 5
17651: PUSH
17652: LD_VAR 0 5
17656: PUSH
17657: LD_EXP 60
17661: ADD
17662: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17663: LD_VAR 0 5
17667: PPUSH
17668: LD_INT 60
17670: PPUSH
17671: LD_INT 109
17673: PPUSH
17674: CALL_OW 111
// if KappaStatus then
17678: LD_EXP 2
17682: IFFALSE 17734
// begin Say ( JMM , D1nT-JMM-1 ) ;
17684: LD_EXP 40
17688: PPUSH
17689: LD_STRING D1nT-JMM-1
17691: PPUSH
17692: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17696: LD_EXP 61
17700: PPUSH
17701: LD_STRING D1T-Pow-1
17703: PPUSH
17704: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17708: LD_EXP 40
17712: PPUSH
17713: LD_STRING D1T-JMM-2
17715: PPUSH
17716: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17720: LD_EXP 61
17724: PPUSH
17725: LD_STRING D1T-Pow-2
17727: PPUSH
17728: CALL_OW 88
// end else
17732: GO 17940
// if JMMGirlStatus then
17734: LD_EXP 6
17738: IFFALSE 17883
// begin Say ( JMM , D1T-JMM-1 ) ;
17740: LD_EXP 40
17744: PPUSH
17745: LD_STRING D1T-JMM-1
17747: PPUSH
17748: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17752: LD_EXP 61
17756: PPUSH
17757: LD_STRING D1T-Pow-1
17759: PPUSH
17760: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17764: LD_EXP 40
17768: PPUSH
17769: LD_STRING D1T-JMM-3
17771: PPUSH
17772: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17776: LD_EXP 61
17780: PPUSH
17781: LD_STRING D1T-Pow-3
17783: PPUSH
17784: CALL_OW 88
// if JMMGirl then
17788: LD_EXP 7
17792: IFFALSE 17881
// begin case JMMGirl of 1 :
17794: LD_EXP 7
17798: PUSH
17799: LD_INT 1
17801: DOUBLE
17802: EQUAL
17803: IFTRUE 17807
17805: GO 17822
17807: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17808: LD_EXP 41
17812: PPUSH
17813: LD_STRING D1T-Joan-3
17815: PPUSH
17816: CALL_OW 88
17820: GO 17869
17822: LD_INT 2
17824: DOUBLE
17825: EQUAL
17826: IFTRUE 17830
17828: GO 17845
17830: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17831: LD_EXP 43
17835: PPUSH
17836: LD_STRING D1T-Lisa-3
17838: PPUSH
17839: CALL_OW 88
17843: GO 17869
17845: LD_INT 3
17847: DOUBLE
17848: EQUAL
17849: IFTRUE 17853
17851: GO 17868
17853: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17854: LD_EXP 55
17858: PPUSH
17859: LD_STRING D1T-Con-3
17861: PPUSH
17862: CALL_OW 88
17866: GO 17869
17868: POP
// Say ( Powell , D1T-Pow-4 ) ;
17869: LD_EXP 61
17873: PPUSH
17874: LD_STRING D1T-Pow-4
17876: PPUSH
17877: CALL_OW 88
// end ; end else
17881: GO 17940
// if not FastEnd then
17883: LD_EXP 11
17887: NOT
17888: IFFALSE 17916
// begin Say ( JMM , D1T-JMM-4 ) ;
17890: LD_EXP 40
17894: PPUSH
17895: LD_STRING D1T-JMM-4
17897: PPUSH
17898: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17902: LD_EXP 61
17906: PPUSH
17907: LD_STRING D1T-Pow-5
17909: PPUSH
17910: CALL_OW 88
// end else
17914: GO 17940
// begin Say ( JMM , D1nT-JMM-1 ) ;
17916: LD_EXP 40
17920: PPUSH
17921: LD_STRING D1nT-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17928: LD_EXP 61
17932: PPUSH
17933: LD_STRING D1nT-Pow-1
17935: PPUSH
17936: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17940: LD_INT 3
17942: PPUSH
17943: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17947: LD_EXP 59
17951: PPUSH
17952: CALL_OW 314
17956: NOT
17957: IFFALSE 17940
// ComExitVehicle ( JMM ) ;
17959: LD_EXP 40
17963: PPUSH
17964: CALL_OW 121
// repeat wait ( 3 ) ;
17968: LD_INT 3
17970: PPUSH
17971: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17975: LD_EXP 40
17979: PPUSH
17980: CALL_OW 310
17984: NOT
17985: IFFALSE 17968
// ComMoveXY ( JMM , 60 , 94 ) ;
17987: LD_EXP 40
17991: PPUSH
17992: LD_INT 60
17994: PPUSH
17995: LD_INT 94
17997: PPUSH
17998: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18002: LD_EXP 40
18006: PPUSH
18007: LD_EXP 61
18011: PPUSH
18012: CALL_OW 179
// if Joan then
18016: LD_EXP 41
18020: IFFALSE 18074
// begin ComExitVehicle ( Joan ) ;
18022: LD_EXP 41
18026: PPUSH
18027: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18031: LD_EXP 41
18035: PPUSH
18036: LD_INT 35
18038: PPUSH
18039: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18043: LD_EXP 41
18047: PPUSH
18048: LD_INT 65
18050: PPUSH
18051: LD_INT 104
18053: PPUSH
18054: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18058: LD_EXP 41
18062: PPUSH
18063: LD_EXP 40
18067: PPUSH
18068: CALL_OW 179
// end else
18072: GO 18208
// if Lisa and JMMGirl = 2 then
18074: LD_EXP 43
18078: PUSH
18079: LD_EXP 7
18083: PUSH
18084: LD_INT 2
18086: EQUAL
18087: AND
18088: IFFALSE 18142
// begin ComExitVehicle ( Lisa ) ;
18090: LD_EXP 43
18094: PPUSH
18095: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18099: LD_EXP 43
18103: PPUSH
18104: LD_INT 35
18106: PPUSH
18107: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18111: LD_EXP 43
18115: PPUSH
18116: LD_INT 65
18118: PPUSH
18119: LD_INT 104
18121: PPUSH
18122: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18126: LD_EXP 43
18130: PPUSH
18131: LD_EXP 40
18135: PPUSH
18136: CALL_OW 179
// end else
18140: GO 18208
// if Connie and JMMGirl = 3 then
18142: LD_EXP 55
18146: PUSH
18147: LD_EXP 7
18151: PUSH
18152: LD_INT 3
18154: EQUAL
18155: AND
18156: IFFALSE 18208
// begin ComExitVehicle ( Connie ) ;
18158: LD_EXP 55
18162: PPUSH
18163: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18167: LD_EXP 55
18171: PPUSH
18172: LD_INT 35
18174: PPUSH
18175: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18179: LD_EXP 55
18183: PPUSH
18184: LD_INT 65
18186: PPUSH
18187: LD_INT 104
18189: PPUSH
18190: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18194: LD_EXP 55
18198: PPUSH
18199: LD_EXP 40
18203: PPUSH
18204: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18208: LD_INT 35
18210: PPUSH
18211: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18215: LD_EXP 40
18219: PPUSH
18220: LD_EXP 61
18224: PPUSH
18225: CALL_OW 296
18229: PUSH
18230: LD_INT 8
18232: LESS
18233: IFFALSE 18208
// wait ( 0 0$0.5 ) ;
18235: LD_INT 18
18237: PPUSH
18238: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18242: LD_EXP 40
18246: PPUSH
18247: LD_STRING D1-JMM-1
18249: PPUSH
18250: CALL_OW 88
// async ;
18254: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18255: LD_EXP 61
18259: PPUSH
18260: LD_STRING D1-Pow-1
18262: PPUSH
18263: CALL_OW 88
// if not dialogue_skipped then
18267: LD_OWVAR 59
18271: NOT
18272: IFFALSE 18281
// wait ( 0 0$2 ) ;
18274: LD_INT 70
18276: PPUSH
18277: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18281: LD_INT 170
18283: PPUSH
18284: LD_INT 99
18286: PPUSH
18287: LD_INT 1
18289: PPUSH
18290: LD_INT 6
18292: NEG
18293: PPUSH
18294: CALL 107168 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18298: LD_INT 174
18300: PPUSH
18301: LD_INT 115
18303: PPUSH
18304: LD_INT 1
18306: PPUSH
18307: LD_INT 6
18309: NEG
18310: PPUSH
18311: CALL 107168 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18315: LD_INT 169
18317: PPUSH
18318: LD_INT 71
18320: PPUSH
18321: LD_INT 1
18323: PPUSH
18324: LD_INT 6
18326: NEG
18327: PPUSH
18328: CALL 107168 0 4
// if not dialogue_skipped then
18332: LD_OWVAR 59
18336: NOT
18337: IFFALSE 18356
// begin CenterOnXY ( 170 , 99 ) ;
18339: LD_INT 170
18341: PPUSH
18342: LD_INT 99
18344: PPUSH
18345: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18349: LD_INT 80
18351: PPUSH
18352: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18356: LD_INT 75
18358: PPUSH
18359: LD_INT 53
18361: PPUSH
18362: LD_INT 1
18364: PPUSH
18365: LD_INT 9
18367: NEG
18368: PPUSH
18369: CALL 107168 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18373: LD_INT 54
18375: PPUSH
18376: LD_INT 42
18378: PPUSH
18379: LD_INT 1
18381: PPUSH
18382: LD_INT 9
18384: NEG
18385: PPUSH
18386: CALL 107168 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18390: LD_INT 62
18392: PPUSH
18393: LD_INT 51
18395: PPUSH
18396: LD_INT 1
18398: PPUSH
18399: LD_INT 9
18401: NEG
18402: PPUSH
18403: CALL 107168 0 4
// if not dialogue_skipped then
18407: LD_OWVAR 59
18411: NOT
18412: IFFALSE 18431
// begin CenterOnXY ( 75 , 53 ) ;
18414: LD_INT 75
18416: PPUSH
18417: LD_INT 53
18419: PPUSH
18420: CALL_OW 84
// wait ( 0 0$4 ) ;
18424: LD_INT 140
18426: PPUSH
18427: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18431: LD_EXP 61
18435: PPUSH
18436: CALL_OW 87
// if not dialogue_skipped then
18440: LD_OWVAR 59
18444: NOT
18445: IFFALSE 18454
// wait ( 0 0$2 ) ;
18447: LD_INT 70
18449: PPUSH
18450: CALL_OW 67
// sync ;
18454: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18455: LD_EXP 40
18459: PPUSH
18460: LD_STRING D1-JMM-2
18462: PPUSH
18463: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18467: LD_EXP 61
18471: PPUSH
18472: LD_STRING D1-Pow-2
18474: PPUSH
18475: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18479: LD_EXP 40
18483: PPUSH
18484: LD_STRING D1-JMM-3
18486: PPUSH
18487: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18491: LD_EXP 61
18495: PPUSH
18496: LD_STRING D1-Pow-3
18498: PPUSH
18499: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18503: LD_EXP 40
18507: PPUSH
18508: LD_STRING D1-JMM-4
18510: PPUSH
18511: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18515: LD_EXP 61
18519: PPUSH
18520: LD_STRING D1-Pow-4
18522: PPUSH
18523: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-5
18534: PPUSH
18535: CALL_OW 88
// async ;
18539: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18540: LD_EXP 61
18544: PPUSH
18545: LD_STRING D1-Pow-5
18547: PPUSH
18548: CALL_OW 88
// if not dialogue_skipped then
18552: LD_OWVAR 59
18556: NOT
18557: IFFALSE 18566
// wait ( 0 0$3.6 ) ;
18559: LD_INT 126
18561: PPUSH
18562: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18566: LD_INT 134
18568: PPUSH
18569: LD_INT 210
18571: PPUSH
18572: LD_INT 1
18574: PPUSH
18575: LD_INT 11
18577: NEG
18578: PPUSH
18579: CALL 107168 0 4
// if not dialogue_skipped then
18583: LD_OWVAR 59
18587: NOT
18588: IFFALSE 18607
// begin CenterOnXY ( 134 , 210 ) ;
18590: LD_INT 134
18592: PPUSH
18593: LD_INT 210
18595: PPUSH
18596: CALL_OW 84
// wait ( 0 0$2 ) ;
18600: LD_INT 70
18602: PPUSH
18603: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18607: LD_INT 101
18609: PPUSH
18610: LD_INT 159
18612: PPUSH
18613: LD_INT 1
18615: PPUSH
18616: LD_INT 10
18618: NEG
18619: PPUSH
18620: CALL 107168 0 4
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18648
// begin CenterOnXY ( 101 , 159 ) ;
18631: LD_INT 101
18633: PPUSH
18634: LD_INT 159
18636: PPUSH
18637: CALL_OW 84
// wait ( 0 0$2 ) ;
18641: LD_INT 70
18643: PPUSH
18644: CALL_OW 67
// end ; sync ;
18648: SYNC
// CenterNowOnUnits ( Powell ) ;
18649: LD_EXP 61
18653: PPUSH
18654: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18658: LD_ADDR_VAR 0 6
18662: PUSH
18663: LD_INT 1
18665: PUSH
18666: LD_INT 2
18668: PUSH
18669: LD_INT 3
18671: PUSH
18672: LD_INT 4
18674: PUSH
18675: LD_INT 5
18677: PUSH
18678: LD_INT 6
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: ST_TO_ADDR
// if not dialogue_skipped then
18689: LD_OWVAR 59
18693: NOT
18694: IFFALSE 18863
// begin game_speed := 4 ;
18696: LD_ADDR_OWVAR 65
18700: PUSH
18701: LD_INT 4
18703: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18704: LD_INT 210
18706: PPUSH
18707: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18711: LD_ADDR_VAR 0 7
18715: PUSH
18716: LD_STRING Q1
18718: PPUSH
18719: LD_VAR 0 6
18723: PPUSH
18724: CALL_OW 98
18728: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18729: LD_ADDR_VAR 0 7
18733: PUSH
18734: LD_STRING Q1
18736: PPUSH
18737: LD_VAR 0 6
18741: PPUSH
18742: CALL_OW 98
18746: ST_TO_ADDR
// options := options diff dec ;
18747: LD_ADDR_VAR 0 6
18751: PUSH
18752: LD_VAR 0 6
18756: PUSH
18757: LD_VAR 0 7
18761: DIFF
18762: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18763: LD_VAR 0 7
18767: PPUSH
18768: LD_VAR 0 6
18772: PPUSH
18773: CALL 20427 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18777: LD_VAR 0 7
18781: PUSH
18782: LD_INT 5
18784: PUSH
18785: LD_INT 6
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: IN
18792: PUSH
18793: LD_VAR 0 6
18797: PUSH
18798: LD_INT 2
18800: EQUAL
18801: OR
18802: IFFALSE 18729
// if not ( dec in [ 5 , 6 ] ) then
18804: LD_VAR 0 7
18808: PUSH
18809: LD_INT 5
18811: PUSH
18812: LD_INT 6
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: IN
18819: NOT
18820: IFFALSE 18863
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18822: LD_ADDR_VAR 0 7
18826: PUSH
18827: LD_STRING Q1a
18829: PPUSH
18830: LD_INT 1
18832: PUSH
18833: LD_INT 2
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: PPUSH
18840: CALL_OW 98
18844: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18845: LD_VAR 0 7
18849: PUSH
18850: LD_INT 4
18852: PLUS
18853: PPUSH
18854: LD_VAR 0 6
18858: PPUSH
18859: CALL 20427 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18863: LD_INT 81
18865: PPUSH
18866: LD_INT 127
18868: PPUSH
18869: CALL_OW 84
// amount := 8 ;
18873: LD_ADDR_VAR 0 8
18877: PUSH
18878: LD_INT 8
18880: ST_TO_ADDR
// macmilan_squad := [ ] ;
18881: LD_ADDR_VAR 0 9
18885: PUSH
18886: EMPTY
18887: ST_TO_ADDR
// if vip < amount then
18888: LD_EXP 62
18892: PUSH
18893: LD_VAR 0 8
18897: LESS
18898: IFFALSE 18942
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18900: LD_ADDR_VAR 0 5
18904: PUSH
18905: LD_EXP 62
18909: PUSH
18910: LD_INT 22
18912: PUSH
18913: LD_INT 4
18915: PUSH
18916: EMPTY
18917: LIST
18918: LIST
18919: PUSH
18920: LD_INT 21
18922: PUSH
18923: LD_INT 1
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: PPUSH
18934: CALL_OW 69
18938: UNION
18939: ST_TO_ADDR
18940: GO 18952
// tmp := vip ;
18942: LD_ADDR_VAR 0 5
18946: PUSH
18947: LD_EXP 62
18951: ST_TO_ADDR
// tmp := tmp diff Powell ;
18952: LD_ADDR_VAR 0 5
18956: PUSH
18957: LD_VAR 0 5
18961: PUSH
18962: LD_EXP 61
18966: DIFF
18967: ST_TO_ADDR
// if tmp < amount then
18968: LD_VAR 0 5
18972: PUSH
18973: LD_VAR 0 8
18977: LESS
18978: IFFALSE 18990
// amount := tmp ;
18980: LD_ADDR_VAR 0 8
18984: PUSH
18985: LD_VAR 0 5
18989: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18990: LD_VAR 0 5
18994: PUSH
18995: LD_INT 1
18997: ARRAY
18998: PPUSH
18999: CALL_OW 257
19003: PUSH
19004: LD_INT 2
19006: NONEQUAL
19007: IFFALSE 19105
// begin if IsInUnit ( tmp [ 1 ] ) then
19009: LD_VAR 0 5
19013: PUSH
19014: LD_INT 1
19016: ARRAY
19017: PPUSH
19018: CALL_OW 310
19022: IFFALSE 19037
// ComExitBuilding ( tmp [ 1 ] ) ;
19024: LD_VAR 0 5
19028: PUSH
19029: LD_INT 1
19031: ARRAY
19032: PPUSH
19033: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19037: LD_INT 387
19039: PPUSH
19040: CALL_OW 313
19044: PUSH
19045: LD_INT 6
19047: EQUAL
19048: IFFALSE 19073
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19050: LD_INT 387
19052: PPUSH
19053: CALL_OW 313
19057: PUSH
19058: LD_INT 1
19060: ARRAY
19061: PPUSH
19062: CALL_OW 122
// wait ( 3 ) ;
19066: LD_INT 3
19068: PPUSH
19069: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19073: LD_VAR 0 5
19077: PUSH
19078: LD_INT 1
19080: ARRAY
19081: PPUSH
19082: LD_INT 387
19084: PPUSH
19085: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19089: LD_VAR 0 5
19093: PUSH
19094: LD_INT 1
19096: ARRAY
19097: PPUSH
19098: LD_INT 2
19100: PPUSH
19101: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19105: LD_EXP 40
19109: PPUSH
19110: LD_INT 82
19112: PPUSH
19113: LD_INT 129
19115: PPUSH
19116: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19120: LD_EXP 40
19124: PPUSH
19125: LD_EXP 61
19129: PPUSH
19130: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19134: LD_INT 22
19136: PUSH
19137: LD_INT 1
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PPUSH
19144: CALL_OW 69
19148: PUSH
19149: LD_EXP 40
19153: DIFF
19154: PPUSH
19155: LD_INT 84
19157: PPUSH
19158: LD_INT 128
19160: PPUSH
19161: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19165: LD_INT 22
19167: PUSH
19168: LD_INT 1
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL_OW 69
19179: PUSH
19180: LD_EXP 40
19184: DIFF
19185: PPUSH
19186: LD_EXP 40
19190: PPUSH
19191: CALL_OW 179
// for i = 1 to amount do
19195: LD_ADDR_VAR 0 2
19199: PUSH
19200: DOUBLE
19201: LD_INT 1
19203: DEC
19204: ST_TO_ADDR
19205: LD_VAR 0 8
19209: PUSH
19210: FOR_TO
19211: IFFALSE 19379
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19213: LD_ADDR_VAR 0 9
19217: PUSH
19218: LD_VAR 0 9
19222: PUSH
19223: LD_VAR 0 5
19227: PUSH
19228: LD_VAR 0 2
19232: ARRAY
19233: ADD
19234: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19235: LD_VAR 0 5
19239: PUSH
19240: LD_VAR 0 2
19244: ARRAY
19245: PPUSH
19246: CALL_OW 310
19250: IFFALSE 19267
// AddComExitBuilding ( tmp [ i ] ) ;
19252: LD_VAR 0 5
19256: PUSH
19257: LD_VAR 0 2
19261: ARRAY
19262: PPUSH
19263: CALL_OW 182
// if i = 2 and JMMNewVeh then
19267: LD_VAR 0 2
19271: PUSH
19272: LD_INT 2
19274: EQUAL
19275: PUSH
19276: LD_EXP 59
19280: AND
19281: IFFALSE 19339
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19283: LD_VAR 0 5
19287: PUSH
19288: LD_VAR 0 2
19292: ARRAY
19293: PPUSH
19294: LD_EXP 59
19298: PPUSH
19299: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19303: LD_VAR 0 5
19307: PUSH
19308: LD_VAR 0 2
19312: ARRAY
19313: PPUSH
19314: LD_INT 86
19316: PPUSH
19317: LD_INT 133
19319: PPUSH
19320: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19339: LD_VAR 0 5
19343: PUSH
19344: LD_VAR 0 2
19348: ARRAY
19349: PPUSH
19350: LD_INT 8
19352: PPUSH
19353: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19357: LD_VAR 0 5
19361: PUSH
19362: LD_VAR 0 2
19366: ARRAY
19367: PPUSH
19368: LD_EXP 40
19372: PPUSH
19373: CALL_OW 179
// end ;
19377: GO 19210
19379: POP
19380: POP
// if GirlNewVeh then
19381: LD_EXP 60
19385: IFFALSE 19399
// SetSide ( GirlNewVeh , 4 ) ;
19387: LD_EXP 60
19391: PPUSH
19392: LD_INT 4
19394: PPUSH
19395: CALL_OW 235
// if Mike then
19399: LD_EXP 57
19403: IFFALSE 19440
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19405: LD_ADDR_VAR 0 9
19409: PUSH
19410: LD_VAR 0 9
19414: PPUSH
19415: LD_EXP 57
19419: PPUSH
19420: CALL 107282 0 2
19424: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19425: LD_EXP 57
19429: PPUSH
19430: LD_INT 86
19432: PPUSH
19433: LD_INT 133
19435: PPUSH
19436: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19440: LD_INT 35
19442: PPUSH
19443: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19447: LD_VAR 0 9
19451: PPUSH
19452: LD_INT 95
19454: PUSH
19455: LD_INT 9
19457: PUSH
19458: EMPTY
19459: LIST
19460: LIST
19461: PPUSH
19462: CALL_OW 72
19466: PUSH
19467: LD_INT 0
19469: EQUAL
19470: PUSH
19471: LD_EXP 40
19475: PPUSH
19476: LD_INT 9
19478: PPUSH
19479: CALL_OW 308
19483: NOT
19484: AND
19485: IFFALSE 19440
// wait ( 0 0$2 ) ;
19487: LD_INT 70
19489: PPUSH
19490: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19494: LD_VAR 0 9
19498: PPUSH
19499: LD_INT 1
19501: PPUSH
19502: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19506: LD_INT 21
19508: PUSH
19509: LD_INT 2
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: PUSH
19516: LD_INT 92
19518: PUSH
19519: LD_INT 83
19521: PUSH
19522: LD_INT 130
19524: PUSH
19525: LD_INT 10
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: LIST
19532: LIST
19533: PUSH
19534: EMPTY
19535: LIST
19536: LIST
19537: PPUSH
19538: CALL_OW 69
19542: PPUSH
19543: LD_INT 1
19545: PPUSH
19546: CALL_OW 235
// tick := 0 ;
19550: LD_ADDR_OWVAR 1
19554: PUSH
19555: LD_INT 0
19557: ST_TO_ADDR
// Video ( false ) ;
19558: LD_INT 0
19560: PPUSH
19561: CALL 107254 0 1
// ChangeMissionObjectives ( M1 ) ;
19565: LD_STRING M1
19567: PPUSH
19568: CALL_OW 337
// SaveForQuickRestart ;
19572: CALL_OW 22
// missionStart := true ;
19576: LD_ADDR_EXP 13
19580: PUSH
19581: LD_INT 1
19583: ST_TO_ADDR
// missionStage := 2 ;
19584: LD_ADDR_EXP 15
19588: PUSH
19589: LD_INT 2
19591: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19592: LD_INT 35
19594: PPUSH
19595: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19599: LD_ADDR_VAR 0 5
19603: PUSH
19604: LD_INT 22
19606: PUSH
19607: LD_INT 4
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: PUSH
19614: LD_INT 21
19616: PUSH
19617: LD_INT 1
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PPUSH
19628: CALL_OW 69
19632: PUSH
19633: LD_EXP 61
19637: DIFF
19638: ST_TO_ADDR
// if not tmp then
19639: LD_VAR 0 5
19643: NOT
19644: IFFALSE 19659
// tmp := [ Powell ] ;
19646: LD_ADDR_VAR 0 5
19650: PUSH
19651: LD_EXP 61
19655: PUSH
19656: EMPTY
19657: LIST
19658: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19659: LD_ADDR_VAR 0 4
19663: PUSH
19664: LD_INT 22
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 34
19676: PUSH
19677: LD_INT 12
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PPUSH
19688: CALL_OW 69
19692: PUSH
19693: LD_INT 1
19695: ARRAY
19696: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19697: LD_VAR 0 5
19701: PUSH
19702: LD_INT 1
19704: ARRAY
19705: PPUSH
19706: CALL_OW 310
19710: IFFALSE 19725
// ComExitBuilding ( tmp [ 1 ] ) ;
19712: LD_VAR 0 5
19716: PUSH
19717: LD_INT 1
19719: ARRAY
19720: PPUSH
19721: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19725: LD_VAR 0 5
19729: PUSH
19730: LD_INT 1
19732: ARRAY
19733: PPUSH
19734: LD_VAR 0 4
19738: PPUSH
19739: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19743: LD_VAR 0 5
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: LD_INT 80
19754: PPUSH
19755: LD_INT 136
19757: PPUSH
19758: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19762: LD_VAR 0 5
19766: PUSH
19767: LD_INT 1
19769: ARRAY
19770: PPUSH
19771: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19775: LD_VAR 0 5
19779: PUSH
19780: LD_INT 1
19782: ARRAY
19783: PPUSH
19784: LD_INT 59
19786: PPUSH
19787: LD_INT 112
19789: PPUSH
19790: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19794: LD_VAR 0 5
19798: PUSH
19799: LD_INT 1
19801: ARRAY
19802: PPUSH
19803: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19807: LD_EXP 41
19811: PUSH
19812: LD_EXP 41
19816: PPUSH
19817: CALL_OW 255
19821: PUSH
19822: LD_INT 1
19824: EQUAL
19825: AND
19826: IFFALSE 19852
// begin Say ( Joan , D3W-Joan-1 ) ;
19828: LD_EXP 41
19832: PPUSH
19833: LD_STRING D3W-Joan-1
19835: PPUSH
19836: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19840: LD_EXP 40
19844: PPUSH
19845: LD_STRING D3W-JMM-1
19847: PPUSH
19848: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19852: LD_EXP 43
19856: PUSH
19857: LD_EXP 43
19861: PPUSH
19862: CALL_OW 255
19866: PUSH
19867: LD_INT 1
19869: EQUAL
19870: AND
19871: PUSH
19872: LD_EXP 43
19876: PUSH
19877: LD_EXP 62
19881: IN
19882: NOT
19883: AND
19884: IFFALSE 19910
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19886: LD_EXP 43
19890: PPUSH
19891: LD_STRING D3W-Lisa-1
19893: PPUSH
19894: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19898: LD_EXP 40
19902: PPUSH
19903: LD_STRING D3W-JMM-1
19905: PPUSH
19906: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19910: LD_EXP 55
19914: PUSH
19915: LD_EXP 55
19919: PPUSH
19920: CALL_OW 255
19924: PUSH
19925: LD_INT 1
19927: EQUAL
19928: AND
19929: IFFALSE 19955
// begin Say ( Connie , D3W-Con-1 ) ;
19931: LD_EXP 55
19935: PPUSH
19936: LD_STRING D3W-Con-1
19938: PPUSH
19939: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19943: LD_EXP 40
19947: PPUSH
19948: LD_STRING D3W-JMM-1
19950: PPUSH
19951: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19955: LD_INT 18
19957: PPUSH
19958: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19962: LD_EXP 43
19966: PUSH
19967: LD_EXP 62
19971: IN
19972: PUSH
19973: LD_EXP 43
19977: PPUSH
19978: CALL_OW 255
19982: PUSH
19983: LD_INT 1
19985: EQUAL
19986: AND
19987: IFFALSE 20003
// Say ( Lisa , D3nW-Lisa-1 ) else
19989: LD_EXP 43
19993: PPUSH
19994: LD_STRING D3nW-Lisa-1
19996: PPUSH
19997: CALL_OW 88
20001: GO 20247
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20003: LD_EXP 46
20007: PUSH
20008: LD_EXP 62
20012: IN
20013: PUSH
20014: LD_EXP 46
20018: PPUSH
20019: CALL_OW 255
20023: PUSH
20024: LD_INT 1
20026: EQUAL
20027: AND
20028: IFFALSE 20044
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20030: LD_EXP 46
20034: PPUSH
20035: LD_STRING D3nW-Cyrus-1
20037: PPUSH
20038: CALL_OW 88
20042: GO 20247
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20044: LD_EXP 45
20048: PUSH
20049: LD_EXP 62
20053: IN
20054: PUSH
20055: LD_EXP 45
20059: PPUSH
20060: CALL_OW 255
20064: PUSH
20065: LD_INT 1
20067: EQUAL
20068: AND
20069: IFFALSE 20085
// Say ( Bobby , D3nW-Bobby-1 ) else
20071: LD_EXP 45
20075: PPUSH
20076: LD_STRING D3nW-Bobby-1
20078: PPUSH
20079: CALL_OW 88
20083: GO 20247
// if Gary in vip and GetSide ( Gary ) = 1 then
20085: LD_EXP 52
20089: PUSH
20090: LD_EXP 62
20094: IN
20095: PUSH
20096: LD_EXP 52
20100: PPUSH
20101: CALL_OW 255
20105: PUSH
20106: LD_INT 1
20108: EQUAL
20109: AND
20110: IFFALSE 20126
// Say ( Gary , D3nW-Gary-1 ) else
20112: LD_EXP 52
20116: PPUSH
20117: LD_STRING D3nW-Gary-1
20119: PPUSH
20120: CALL_OW 88
20124: GO 20247
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20126: LD_EXP 44
20130: PUSH
20131: LD_EXP 62
20135: IN
20136: PUSH
20137: LD_EXP 44
20141: PPUSH
20142: CALL_OW 255
20146: PUSH
20147: LD_INT 1
20149: EQUAL
20150: AND
20151: IFFALSE 20167
// Say ( Donaldson , D3nW-Don-1 ) else
20153: LD_EXP 44
20157: PPUSH
20158: LD_STRING D3nW-Don-1
20160: PPUSH
20161: CALL_OW 88
20165: GO 20247
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20167: LD_EXP 51
20171: PUSH
20172: LD_EXP 62
20176: IN
20177: PUSH
20178: LD_EXP 51
20182: PPUSH
20183: CALL_OW 255
20187: PUSH
20188: LD_INT 1
20190: EQUAL
20191: AND
20192: IFFALSE 20208
// Say ( Cornel , D3nW-Corn-1 ) else
20194: LD_EXP 51
20198: PPUSH
20199: LD_STRING D3nW-Corn-1
20201: PPUSH
20202: CALL_OW 88
20206: GO 20247
// if Frank in vip and GetSide ( Frank ) = 1 then
20208: LD_EXP 53
20212: PUSH
20213: LD_EXP 62
20217: IN
20218: PUSH
20219: LD_EXP 53
20223: PPUSH
20224: CALL_OW 255
20228: PUSH
20229: LD_INT 1
20231: EQUAL
20232: AND
20233: IFFALSE 20247
// Say ( Frank , D3nW-Frank-1 ) ;
20235: LD_EXP 53
20239: PPUSH
20240: LD_STRING D3nW-Frank-1
20242: PPUSH
20243: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20247: LD_EXP 62
20251: PPUSH
20252: LD_INT 22
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: PPUSH
20262: CALL_OW 72
20266: IFFALSE 20292
// begin Say ( JMM , D3nW-JMM-1 ) ;
20268: LD_EXP 40
20272: PPUSH
20273: LD_STRING D3nW-JMM-1
20275: PPUSH
20276: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20280: LD_EXP 40
20284: PPUSH
20285: LD_STRING D3nW-JMM-1a
20287: PPUSH
20288: CALL_OW 88
// end ; t := 0 0$00 ;
20292: LD_ADDR_VAR 0 3
20296: PUSH
20297: LD_INT 0
20299: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20300: LD_INT 35
20302: PPUSH
20303: CALL_OW 67
// t := t + 0 0$1 ;
20307: LD_ADDR_VAR 0 3
20311: PUSH
20312: LD_VAR 0 3
20316: PUSH
20317: LD_INT 35
20319: PLUS
20320: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20321: LD_INT 59
20323: PPUSH
20324: LD_INT 112
20326: PPUSH
20327: CALL_OW 428
20331: PUSH
20332: LD_VAR 0 3
20336: PUSH
20337: LD_INT 2100
20339: GREATER
20340: OR
20341: IFFALSE 20300
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20343: LD_ADDR_EXP 102
20347: PUSH
20348: LD_EXP 102
20352: PPUSH
20353: LD_INT 4
20355: PPUSH
20356: LD_INT 22
20358: PUSH
20359: LD_INT 4
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: PUSH
20366: LD_INT 23
20368: PUSH
20369: LD_INT 1
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PUSH
20376: LD_INT 3
20378: PUSH
20379: LD_INT 21
20381: PUSH
20382: LD_INT 2
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: PPUSH
20398: CALL_OW 69
20402: PUSH
20403: LD_EXP 61
20407: DIFF
20408: PPUSH
20409: CALL_OW 1
20413: ST_TO_ADDR
// activeAttacks := true ;
20414: LD_ADDR_EXP 16
20418: PUSH
20419: LD_INT 1
20421: ST_TO_ADDR
// end ;
20422: LD_VAR 0 1
20426: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20427: LD_INT 0
20429: PPUSH
// case question of 1 :
20430: LD_VAR 0 1
20434: PUSH
20435: LD_INT 1
20437: DOUBLE
20438: EQUAL
20439: IFTRUE 20443
20441: GO 20494
20443: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20444: LD_EXP 40
20448: PPUSH
20449: LD_STRING D2Mot-JMM-1
20451: PPUSH
20452: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20456: LD_EXP 61
20460: PPUSH
20461: LD_STRING D2Mot-Pow-1
20463: PPUSH
20464: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20468: LD_EXP 40
20472: PPUSH
20473: LD_STRING D2Mot-JMM-2
20475: PPUSH
20476: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20480: LD_EXP 61
20484: PPUSH
20485: LD_STRING D2Mot-Pow-2
20487: PPUSH
20488: CALL_OW 88
// end ; 2 :
20492: GO 20845
20494: LD_INT 2
20496: DOUBLE
20497: EQUAL
20498: IFTRUE 20502
20500: GO 20578
20502: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20503: LD_EXP 40
20507: PPUSH
20508: LD_STRING D2Rus-JMM-1
20510: PPUSH
20511: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20515: LD_EXP 61
20519: PPUSH
20520: LD_STRING D2Rus-Pow-1
20522: PPUSH
20523: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20527: LD_EXP 40
20531: PPUSH
20532: LD_STRING D2Rus-JMM-2
20534: PPUSH
20535: CALL_OW 88
// if not ( 3 in list_of_q ) then
20539: LD_INT 3
20541: PUSH
20542: LD_VAR 0 2
20546: IN
20547: NOT
20548: IFFALSE 20564
// Say ( Powell , D2Rus-Pow-2 ) else
20550: LD_EXP 61
20554: PPUSH
20555: LD_STRING D2Rus-Pow-2
20557: PPUSH
20558: CALL_OW 88
20562: GO 20576
// Say ( Powell , D2Rus-Pow-2a ) ;
20564: LD_EXP 61
20568: PPUSH
20569: LD_STRING D2Rus-Pow-2a
20571: PPUSH
20572: CALL_OW 88
// end ; 3 :
20576: GO 20845
20578: LD_INT 3
20580: DOUBLE
20581: EQUAL
20582: IFTRUE 20586
20584: GO 20671
20586: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20587: LD_EXP 40
20591: PPUSH
20592: LD_STRING D2Leg-JMM-1
20594: PPUSH
20595: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20599: LD_EXP 61
20603: PPUSH
20604: LD_STRING D2Leg-Pow-1
20606: PPUSH
20607: CALL_OW 88
// if 2 in list_of_q then
20611: LD_INT 2
20613: PUSH
20614: LD_VAR 0 2
20618: IN
20619: IFFALSE 20645
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20621: LD_EXP 40
20625: PPUSH
20626: LD_STRING D2Leg-JMM-2
20628: PPUSH
20629: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20633: LD_EXP 61
20637: PPUSH
20638: LD_STRING D2Leg-Pow-2
20640: PPUSH
20641: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20645: LD_EXP 40
20649: PPUSH
20650: LD_STRING D2Leg-JMM-3
20652: PPUSH
20653: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20657: LD_EXP 61
20661: PPUSH
20662: LD_STRING D2Leg-Pow-3
20664: PPUSH
20665: CALL_OW 88
// end ; 4 :
20669: GO 20845
20671: LD_INT 4
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20754
20679: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20680: LD_EXP 40
20684: PPUSH
20685: LD_STRING D2Ar-JMM-1
20687: PPUSH
20688: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20692: LD_EXP 61
20696: PPUSH
20697: LD_STRING D2Ar-Pow-1
20699: PPUSH
20700: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20704: LD_EXP 40
20708: PPUSH
20709: LD_STRING D2Ar-JMM-2
20711: PPUSH
20712: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20716: LD_EXP 61
20720: PPUSH
20721: LD_STRING D2Ar-Pow-2
20723: PPUSH
20724: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20728: LD_EXP 40
20732: PPUSH
20733: LD_STRING D2Ar-JMM-3
20735: PPUSH
20736: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20740: LD_EXP 61
20744: PPUSH
20745: LD_STRING D2Ar-Pow-3
20747: PPUSH
20748: CALL_OW 88
// end ; 5 :
20752: GO 20845
20754: LD_INT 5
20756: DOUBLE
20757: EQUAL
20758: IFTRUE 20762
20760: GO 20777
20762: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20763: LD_EXP 40
20767: PPUSH
20768: LD_STRING D2Conf-JMM-1
20770: PPUSH
20771: CALL_OW 88
20775: GO 20845
20777: LD_INT 6
20779: DOUBLE
20780: EQUAL
20781: IFTRUE 20785
20783: GO 20844
20785: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20786: LD_EXP 40
20790: PPUSH
20791: LD_STRING D2Com-JMM-1
20793: PPUSH
20794: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20798: LD_EXP 61
20802: PPUSH
20803: LD_STRING D2Com-Pow-1
20805: PPUSH
20806: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20810: LD_EXP 40
20814: PPUSH
20815: LD_STRING D2Com-JMM-2
20817: PPUSH
20818: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20822: LD_EXP 61
20826: PPUSH
20827: LD_STRING D2Com-Pow-2
20829: PPUSH
20830: CALL_OW 88
// powellAngerQuery := true ;
20834: LD_ADDR_EXP 36
20838: PUSH
20839: LD_INT 1
20841: ST_TO_ADDR
// end ; end ;
20842: GO 20845
20844: POP
// end ;
20845: LD_VAR 0 3
20849: RET
// every 0 0$5 trigger missionStart do var tmp ;
20850: LD_EXP 13
20854: IFFALSE 21179
20856: GO 20858
20858: DISABLE
20859: LD_INT 0
20861: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20862: LD_INT 35
20864: PPUSH
20865: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20869: LD_INT 14
20871: PPUSH
20872: LD_INT 22
20874: PUSH
20875: LD_INT 1
20877: PUSH
20878: EMPTY
20879: LIST
20880: LIST
20881: PUSH
20882: LD_INT 3
20884: PUSH
20885: LD_INT 21
20887: PUSH
20888: LD_INT 3
20890: PUSH
20891: EMPTY
20892: LIST
20893: LIST
20894: PUSH
20895: EMPTY
20896: LIST
20897: LIST
20898: PUSH
20899: EMPTY
20900: LIST
20901: LIST
20902: PPUSH
20903: CALL_OW 70
20907: PUSH
20908: LD_EXP 15
20912: PUSH
20913: LD_INT 2
20915: PUSH
20916: LD_INT 3
20918: PUSH
20919: LD_INT 4
20921: PUSH
20922: LD_INT 5
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: LIST
20929: LIST
20930: IN
20931: AND
20932: IFFALSE 21169
// begin powellAnger := powellAnger + 1 ;
20934: LD_ADDR_EXP 17
20938: PUSH
20939: LD_EXP 17
20943: PUSH
20944: LD_INT 1
20946: PLUS
20947: ST_TO_ADDR
// Video ( true ) ;
20948: LD_INT 1
20950: PPUSH
20951: CALL 107254 0 1
// CenterNowOnUnits ( tmp ) ;
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20964: LD_INT 14
20966: PPUSH
20967: LD_INT 22
20969: PUSH
20970: LD_INT 1
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PPUSH
20977: CALL_OW 70
20981: PPUSH
20982: LD_INT 86
20984: PPUSH
20985: LD_INT 133
20987: PPUSH
20988: CALL_OW 111
// async ;
20992: ASYNC
// case powellAnger of 1 :
20993: LD_EXP 17
20997: PUSH
20998: LD_INT 1
21000: DOUBLE
21001: EQUAL
21002: IFTRUE 21006
21004: GO 21021
21006: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21007: LD_EXP 61
21011: PPUSH
21012: LD_STRING DBack1-Pow-1
21014: PPUSH
21015: CALL_OW 88
21019: GO 21068
21021: LD_INT 2
21023: DOUBLE
21024: EQUAL
21025: IFTRUE 21029
21027: GO 21044
21029: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21030: LD_EXP 61
21034: PPUSH
21035: LD_STRING DBack2-Pow-1
21037: PPUSH
21038: CALL_OW 88
21042: GO 21068
21044: LD_INT 3
21046: DOUBLE
21047: EQUAL
21048: IFTRUE 21052
21050: GO 21067
21052: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21053: LD_EXP 61
21057: PPUSH
21058: LD_STRING DBack3-Pow-1
21060: PPUSH
21061: CALL_OW 88
21065: GO 21068
21067: POP
// sync ;
21068: SYNC
// repeat wait ( 0 0$1 ) ;
21069: LD_INT 35
21071: PPUSH
21072: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21076: LD_INT 14
21078: PPUSH
21079: LD_INT 22
21081: PUSH
21082: LD_INT 1
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: PPUSH
21089: CALL_OW 70
21093: PPUSH
21094: LD_INT 86
21096: PPUSH
21097: LD_INT 133
21099: PPUSH
21100: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21104: LD_INT 14
21106: PPUSH
21107: LD_INT 22
21109: PUSH
21110: LD_INT 1
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: PUSH
21117: LD_INT 3
21119: PUSH
21120: LD_INT 21
21122: PUSH
21123: LD_INT 3
21125: PUSH
21126: EMPTY
21127: LIST
21128: LIST
21129: PUSH
21130: EMPTY
21131: LIST
21132: LIST
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PPUSH
21138: CALL_OW 70
21142: NOT
21143: IFFALSE 21069
// if powellAnger >= 3 then
21145: LD_EXP 17
21149: PUSH
21150: LD_INT 3
21152: GREATEREQUAL
21153: IFFALSE 21162
// YouLost ( Dismissed ) ;
21155: LD_STRING Dismissed
21157: PPUSH
21158: CALL_OW 104
// Video ( false ) ;
21162: LD_INT 0
21164: PPUSH
21165: CALL 107254 0 1
// end ; until missionStage > 5 ;
21169: LD_EXP 15
21173: PUSH
21174: LD_INT 5
21176: GREATER
21177: IFFALSE 20862
// end ;
21179: PPOPN 1
21181: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21182: LD_EXP 13
21186: PUSH
21187: LD_INT 22
21189: PUSH
21190: LD_INT 4
21192: PUSH
21193: EMPTY
21194: LIST
21195: LIST
21196: PUSH
21197: LD_INT 21
21199: PUSH
21200: LD_INT 2
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PPUSH
21211: CALL_OW 69
21215: PUSH
21216: LD_INT 4
21218: GREATEREQUAL
21219: AND
21220: PUSH
21221: LD_EXP 15
21225: PUSH
21226: LD_INT 2
21228: EQUAL
21229: AND
21230: IFFALSE 23480
21232: GO 21234
21234: DISABLE
21235: LD_INT 0
21237: PPUSH
21238: PPUSH
21239: PPUSH
21240: PPUSH
21241: PPUSH
21242: PPUSH
21243: PPUSH
21244: PPUSH
21245: PPUSH
21246: PPUSH
21247: PPUSH
// begin missionStage := 3 ;
21248: LD_ADDR_EXP 15
21252: PUSH
21253: LD_INT 3
21255: ST_TO_ADDR
// retreat := false ;
21256: LD_ADDR_VAR 0 4
21260: PUSH
21261: LD_INT 0
21263: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21264: LD_ADDR_VAR 0 5
21268: PUSH
21269: LD_INT 22
21271: PUSH
21272: LD_INT 4
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: PUSH
21279: LD_INT 30
21281: PUSH
21282: LD_INT 4
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PPUSH
21293: CALL_OW 69
21297: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21298: LD_ADDR_VAR 0 6
21302: PUSH
21303: LD_INT 22
21305: PUSH
21306: LD_INT 4
21308: PUSH
21309: EMPTY
21310: LIST
21311: LIST
21312: PUSH
21313: LD_INT 30
21315: PUSH
21316: LD_INT 5
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: PUSH
21323: EMPTY
21324: LIST
21325: LIST
21326: PPUSH
21327: CALL_OW 69
21331: ST_TO_ADDR
// if not bar then
21332: LD_VAR 0 6
21336: NOT
21337: IFFALSE 21390
// begin repeat wait ( 0 0$1 ) ;
21339: LD_INT 35
21341: PPUSH
21342: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21346: LD_INT 22
21348: PUSH
21349: LD_INT 4
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: LD_INT 3
21358: PUSH
21359: LD_INT 57
21361: PUSH
21362: EMPTY
21363: LIST
21364: PUSH
21365: EMPTY
21366: LIST
21367: LIST
21368: PUSH
21369: LD_INT 30
21371: PUSH
21372: LD_INT 5
21374: PUSH
21375: EMPTY
21376: LIST
21377: LIST
21378: PUSH
21379: EMPTY
21380: LIST
21381: LIST
21382: LIST
21383: PPUSH
21384: CALL_OW 69
21388: IFFALSE 21339
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21390: LD_ADDR_VAR 0 6
21394: PUSH
21395: LD_INT 22
21397: PUSH
21398: LD_INT 4
21400: PUSH
21401: EMPTY
21402: LIST
21403: LIST
21404: PUSH
21405: LD_INT 30
21407: PUSH
21408: LD_INT 5
21410: PUSH
21411: EMPTY
21412: LIST
21413: LIST
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PPUSH
21419: CALL_OW 69
21423: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21424: LD_INT 35
21426: PPUSH
21427: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21431: LD_EXP 121
21435: PUSH
21436: LD_INT 4
21438: ARRAY
21439: PUSH
21440: LD_INT 4
21442: GREATEREQUAL
21443: IFFALSE 21424
// tmp := [ ] ;
21445: LD_ADDR_VAR 0 2
21449: PUSH
21450: EMPTY
21451: ST_TO_ADDR
// tmp2 := [ ] ;
21452: LD_ADDR_VAR 0 3
21456: PUSH
21457: EMPTY
21458: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21459: LD_ADDR_VAR 0 1
21463: PUSH
21464: LD_INT 22
21466: PUSH
21467: LD_INT 4
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: LD_INT 2
21476: PUSH
21477: LD_INT 25
21479: PUSH
21480: LD_INT 1
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: LD_INT 25
21489: PUSH
21490: LD_INT 2
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: PUSH
21497: LD_INT 25
21499: PUSH
21500: LD_INT 3
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 25
21509: PUSH
21510: LD_INT 4
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: LD_INT 25
21519: PUSH
21520: LD_INT 5
21522: PUSH
21523: EMPTY
21524: LIST
21525: LIST
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: LIST
21533: LIST
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PPUSH
21539: CALL_OW 69
21543: PUSH
21544: LD_EXP 61
21548: PUSH
21549: LD_EXP 62
21553: UNION
21554: DIFF
21555: PUSH
21556: FOR_IN
21557: IFFALSE 21619
// if not i in extraSquad then
21559: LD_VAR 0 1
21563: PUSH
21564: LD_EXP 63
21568: IN
21569: NOT
21570: IFFALSE 21594
// tmp := Join ( tmp , i ) else
21572: LD_ADDR_VAR 0 2
21576: PUSH
21577: LD_VAR 0 2
21581: PPUSH
21582: LD_VAR 0 1
21586: PPUSH
21587: CALL 107282 0 2
21591: ST_TO_ADDR
21592: GO 21617
// tmp := Insert ( tmp , 1 , i ) ;
21594: LD_ADDR_VAR 0 2
21598: PUSH
21599: LD_VAR 0 2
21603: PPUSH
21604: LD_INT 1
21606: PPUSH
21607: LD_VAR 0 1
21611: PPUSH
21612: CALL_OW 2
21616: ST_TO_ADDR
21617: GO 21556
21619: POP
21620: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21621: LD_ADDR_VAR 0 1
21625: PUSH
21626: LD_VAR 0 2
21630: PPUSH
21631: LD_INT 26
21633: PUSH
21634: LD_INT 1
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: PPUSH
21641: CALL_OW 72
21645: PUSH
21646: FOR_IN
21647: IFFALSE 21698
// begin p := Inc ( p ) ;
21649: LD_ADDR_VAR 0 11
21653: PUSH
21654: LD_VAR 0 11
21658: PPUSH
21659: CALL 108643 0 1
21663: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21664: LD_ADDR_VAR 0 3
21668: PUSH
21669: LD_VAR 0 3
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL 107282 0 2
21683: ST_TO_ADDR
// if p = 4 then
21684: LD_VAR 0 11
21688: PUSH
21689: LD_INT 4
21691: EQUAL
21692: IFFALSE 21696
// break ;
21694: GO 21698
// end ;
21696: GO 21646
21698: POP
21699: POP
// tmp := tmp diff tmp2 ;
21700: LD_ADDR_VAR 0 2
21704: PUSH
21705: LD_VAR 0 2
21709: PUSH
21710: LD_VAR 0 3
21714: DIFF
21715: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21716: LD_ADDR_VAR 0 2
21720: PUSH
21721: LD_VAR 0 2
21725: PPUSH
21726: LD_INT 3
21728: PPUSH
21729: CALL 105786 0 2
21733: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21734: LD_ADDR_VAR 0 3
21738: PUSH
21739: LD_VAR 0 3
21743: PPUSH
21744: LD_INT 3
21746: PPUSH
21747: CALL 105786 0 2
21751: ST_TO_ADDR
// for i := 1 to 4 do
21752: LD_ADDR_VAR 0 1
21756: PUSH
21757: DOUBLE
21758: LD_INT 1
21760: DEC
21761: ST_TO_ADDR
21762: LD_INT 4
21764: PUSH
21765: FOR_TO
21766: IFFALSE 21919
// begin if tmp2 then
21768: LD_VAR 0 3
21772: IFFALSE 21840
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21774: LD_ADDR_EXP 18
21778: PUSH
21779: LD_EXP 18
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_EXP 18
21791: PUSH
21792: LD_INT 1
21794: ARRAY
21795: PUSH
21796: LD_VAR 0 3
21800: PUSH
21801: LD_VAR 0 3
21805: ARRAY
21806: ADD
21807: PPUSH
21808: CALL_OW 1
21812: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21813: LD_VAR 0 3
21817: PUSH
21818: LD_VAR 0 3
21822: ARRAY
21823: PPUSH
21824: LD_INT 1
21826: PPUSH
21827: CALL_OW 109
// tmp2 := [ ] ;
21831: LD_ADDR_VAR 0 3
21835: PUSH
21836: EMPTY
21837: ST_TO_ADDR
// end else
21838: GO 21917
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21840: LD_ADDR_EXP 18
21844: PUSH
21845: LD_EXP 18
21849: PPUSH
21850: LD_INT 1
21852: PPUSH
21853: LD_EXP 18
21857: PUSH
21858: LD_INT 1
21860: ARRAY
21861: PUSH
21862: LD_VAR 0 2
21866: PUSH
21867: LD_VAR 0 2
21871: ARRAY
21872: ADD
21873: PPUSH
21874: CALL_OW 1
21878: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21879: LD_VAR 0 2
21883: PUSH
21884: LD_VAR 0 2
21888: ARRAY
21889: PPUSH
21890: LD_INT 1
21892: PPUSH
21893: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21897: LD_ADDR_VAR 0 2
21901: PUSH
21902: LD_VAR 0 2
21906: PPUSH
21907: LD_VAR 0 2
21911: PPUSH
21912: CALL_OW 3
21916: ST_TO_ADDR
// end ; end ;
21917: GO 21765
21919: POP
21920: POP
// if tmp2 then
21921: LD_VAR 0 3
21925: IFFALSE 21943
// tmp := tmp union tmp2 ;
21927: LD_ADDR_VAR 0 2
21931: PUSH
21932: LD_VAR 0 2
21936: PUSH
21937: LD_VAR 0 3
21941: UNION
21942: ST_TO_ADDR
// for i := 1 to 4 do
21943: LD_ADDR_VAR 0 1
21947: PUSH
21948: DOUBLE
21949: LD_INT 1
21951: DEC
21952: ST_TO_ADDR
21953: LD_INT 4
21955: PUSH
21956: FOR_TO
21957: IFFALSE 22006
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21959: LD_ADDR_EXP 18
21963: PUSH
21964: LD_EXP 18
21968: PPUSH
21969: LD_INT 2
21971: PPUSH
21972: LD_EXP 18
21976: PUSH
21977: LD_INT 2
21979: ARRAY
21980: PUSH
21981: LD_VAR 0 2
21985: PUSH
21986: LD_VAR 0 2
21990: PUSH
21991: LD_VAR 0 1
21995: MINUS
21996: ARRAY
21997: ADD
21998: PPUSH
21999: CALL_OW 1
22003: ST_TO_ADDR
22004: GO 21956
22006: POP
22007: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22008: LD_ADDR_EXP 102
22012: PUSH
22013: LD_EXP 102
22017: PPUSH
22018: LD_INT 4
22020: PPUSH
22021: LD_EXP 102
22025: PUSH
22026: LD_INT 4
22028: ARRAY
22029: PUSH
22030: LD_EXP 18
22034: PUSH
22035: LD_INT 1
22037: ARRAY
22038: DIFF
22039: PPUSH
22040: CALL_OW 1
22044: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22045: LD_VAR 0 5
22049: PUSH
22050: LD_INT 1
22052: ARRAY
22053: PPUSH
22054: CALL_OW 313
22058: IFFALSE 22113
// begin for i in UnitsInside ( arm [ 1 ] ) do
22060: LD_ADDR_VAR 0 1
22064: PUSH
22065: LD_VAR 0 5
22069: PUSH
22070: LD_INT 1
22072: ARRAY
22073: PPUSH
22074: CALL_OW 313
22078: PUSH
22079: FOR_IN
22080: IFFALSE 22111
// begin ComExitBuilding ( i ) ;
22082: LD_VAR 0 1
22086: PPUSH
22087: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22091: LD_VAR 0 1
22095: PPUSH
22096: LD_VAR 0 6
22100: PUSH
22101: LD_INT 1
22103: ARRAY
22104: PPUSH
22105: CALL_OW 180
// end ;
22109: GO 22079
22111: POP
22112: POP
// end ; wait ( 0 0$3 ) ;
22113: LD_INT 105
22115: PPUSH
22116: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22120: LD_ADDR_VAR 0 1
22124: PUSH
22125: LD_EXP 18
22129: PUSH
22130: LD_INT 1
22132: ARRAY
22133: PUSH
22134: FOR_IN
22135: IFFALSE 22242
// begin if IsInUnit ( i ) then
22137: LD_VAR 0 1
22141: PPUSH
22142: CALL_OW 310
22146: IFFALSE 22157
// ComExitBuilding ( i ) ;
22148: LD_VAR 0 1
22152: PPUSH
22153: CALL_OW 122
// if GetClass ( i ) <> 1 then
22157: LD_VAR 0 1
22161: PPUSH
22162: CALL_OW 257
22166: PUSH
22167: LD_INT 1
22169: NONEQUAL
22170: IFFALSE 22211
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22172: LD_VAR 0 1
22176: PPUSH
22177: LD_VAR 0 5
22181: PUSH
22182: LD_INT 1
22184: ARRAY
22185: PPUSH
22186: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22190: LD_VAR 0 1
22194: PPUSH
22195: LD_INT 1
22197: PPUSH
22198: CALL_OW 183
// AddComExitBuilding ( i ) ;
22202: LD_VAR 0 1
22206: PPUSH
22207: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22211: LD_VAR 0 1
22215: PPUSH
22216: LD_INT 60
22218: PPUSH
22219: LD_INT 94
22221: PPUSH
22222: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22226: LD_VAR 0 1
22230: PPUSH
22231: LD_EXP 61
22235: PPUSH
22236: CALL_OW 179
// end ;
22240: GO 22134
22242: POP
22243: POP
// wait ( 0 0$45 ) ;
22244: LD_INT 1575
22246: PPUSH
22247: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22251: LD_EXP 61
22255: PPUSH
22256: LD_STRING D4-Pow-1
22258: PPUSH
22259: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: LD_EXP 18
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: LD_INT 26
22279: PUSH
22280: LD_INT 1
22282: PUSH
22283: EMPTY
22284: LIST
22285: LIST
22286: PPUSH
22287: CALL_OW 72
22291: ST_TO_ADDR
// if tmp then
22292: LD_VAR 0 2
22296: IFFALSE 22314
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22298: LD_VAR 0 2
22302: PUSH
22303: LD_INT 1
22305: ARRAY
22306: PPUSH
22307: LD_STRING D4-Sol1-1
22309: PPUSH
22310: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22314: LD_EXP 61
22318: PPUSH
22319: LD_STRING D4-Pow-2
22321: PPUSH
22322: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22326: LD_ADDR_VAR 0 1
22330: PUSH
22331: DOUBLE
22332: LD_INT 1
22334: DEC
22335: ST_TO_ADDR
22336: LD_EXP 18
22340: PUSH
22341: LD_INT 1
22343: ARRAY
22344: PUSH
22345: FOR_TO
22346: IFFALSE 22439
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22348: LD_EXP 18
22352: PUSH
22353: LD_INT 1
22355: ARRAY
22356: PUSH
22357: LD_VAR 0 1
22361: ARRAY
22362: PPUSH
22363: LD_EXP 121
22367: PUSH
22368: LD_INT 4
22370: ARRAY
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22380: LD_ADDR_EXP 121
22384: PUSH
22385: LD_EXP 121
22389: PPUSH
22390: LD_INT 4
22392: PPUSH
22393: LD_EXP 121
22397: PUSH
22398: LD_INT 4
22400: ARRAY
22401: PPUSH
22402: LD_INT 1
22404: PPUSH
22405: CALL_OW 3
22409: PPUSH
22410: CALL_OW 1
22414: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22415: LD_INT 8
22417: PPUSH
22418: LD_EXP 18
22422: PUSH
22423: LD_INT 1
22425: ARRAY
22426: PUSH
22427: LD_VAR 0 1
22431: ARRAY
22432: PPUSH
22433: CALL_OW 471
// end ;
22437: GO 22345
22439: POP
22440: POP
// repeat wait ( 0 0$1 ) ;
22441: LD_INT 35
22443: PPUSH
22444: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22448: LD_EXP 18
22452: PUSH
22453: LD_INT 1
22455: ARRAY
22456: PPUSH
22457: LD_INT 55
22459: PUSH
22460: EMPTY
22461: LIST
22462: PPUSH
22463: CALL_OW 72
22467: PUSH
22468: LD_INT 4
22470: GREATEREQUAL
22471: IFFALSE 22441
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22473: LD_EXP 18
22477: PUSH
22478: LD_INT 1
22480: ARRAY
22481: PPUSH
22482: LD_INT 69
22484: PPUSH
22485: LD_INT 94
22487: PPUSH
22488: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22492: LD_EXP 18
22496: PUSH
22497: LD_INT 1
22499: ARRAY
22500: PPUSH
22501: LD_INT 82
22503: PPUSH
22504: LD_INT 83
22506: PPUSH
22507: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22511: LD_EXP 18
22515: PUSH
22516: LD_INT 1
22518: ARRAY
22519: PPUSH
22520: LD_INT 77
22522: PPUSH
22523: LD_INT 69
22525: PPUSH
22526: CALL_OW 174
// repeat wait ( 3 ) ;
22530: LD_INT 3
22532: PPUSH
22533: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22537: LD_ADDR_VAR 0 1
22541: PUSH
22542: LD_EXP 18
22546: PUSH
22547: LD_INT 1
22549: ARRAY
22550: PUSH
22551: FOR_IN
22552: IFFALSE 22688
// begin if GetLives ( i ) < 990 then
22554: LD_VAR 0 1
22558: PPUSH
22559: CALL_OW 256
22563: PUSH
22564: LD_INT 990
22566: LESS
22567: IFFALSE 22581
// SetLives ( i , 1000 ) ;
22569: LD_VAR 0 1
22573: PPUSH
22574: LD_INT 1000
22576: PPUSH
22577: CALL_OW 234
// if not IsInUnit ( i ) then
22581: LD_VAR 0 1
22585: PPUSH
22586: CALL_OW 310
22590: NOT
22591: IFFALSE 22686
// begin if not HasTask ( i ) then
22593: LD_VAR 0 1
22597: PPUSH
22598: CALL_OW 314
22602: NOT
22603: IFFALSE 22620
// ComMoveXY ( i , 64 , 93 ) ;
22605: LD_VAR 0 1
22609: PPUSH
22610: LD_INT 64
22612: PPUSH
22613: LD_INT 93
22615: PPUSH
22616: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22620: LD_VAR 0 4
22624: NOT
22625: PUSH
22626: LD_VAR 0 1
22630: PPUSH
22631: CALL_OW 258
22635: PUSH
22636: LD_INT 1
22638: EQUAL
22639: AND
22640: IFFALSE 22686
// begin retreat := true ;
22642: LD_ADDR_VAR 0 4
22646: PUSH
22647: LD_INT 1
22649: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22650: LD_VAR 0 1
22654: PPUSH
22655: LD_INT 2
22657: PPUSH
22658: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22662: LD_VAR 0 1
22666: PPUSH
22667: LD_STRING D4a-Sol1-1
22669: PPUSH
22670: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22674: LD_EXP 61
22678: PPUSH
22679: LD_STRING D4a-Pow-1
22681: PPUSH
22682: CALL_OW 88
// end ; end ; end ;
22686: GO 22551
22688: POP
22689: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22690: LD_EXP 18
22694: PUSH
22695: LD_INT 1
22697: ARRAY
22698: PPUSH
22699: LD_INT 95
22701: PUSH
22702: LD_INT 9
22704: PUSH
22705: EMPTY
22706: LIST
22707: LIST
22708: PUSH
22709: LD_INT 3
22711: PUSH
22712: LD_INT 55
22714: PUSH
22715: EMPTY
22716: LIST
22717: PUSH
22718: EMPTY
22719: LIST
22720: LIST
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: PPUSH
22726: CALL_OW 72
22730: PUSH
22731: LD_INT 4
22733: GREATEREQUAL
22734: IFFALSE 22530
// for i in powellSquadAttack [ 1 ] do
22736: LD_ADDR_VAR 0 1
22740: PUSH
22741: LD_EXP 18
22745: PUSH
22746: LD_INT 1
22748: ARRAY
22749: PUSH
22750: FOR_IN
22751: IFFALSE 22887
// begin if GetTag ( i ) = 2 then
22753: LD_VAR 0 1
22757: PPUSH
22758: CALL_OW 110
22762: PUSH
22763: LD_INT 2
22765: EQUAL
22766: IFFALSE 22828
// begin ComMoveXY ( i , 60 , 94 ) ;
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_INT 60
22775: PPUSH
22776: LD_INT 94
22778: PPUSH
22779: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22783: LD_VAR 0 1
22787: PPUSH
22788: LD_EXP 61
22792: PPUSH
22793: CALL_OW 179
// wait ( 0 0$3 ) ;
22797: LD_INT 105
22799: PPUSH
22800: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22804: LD_VAR 0 1
22808: PPUSH
22809: LD_STRING D4a-Sol1-2
22811: PPUSH
22812: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22816: LD_EXP 61
22820: PPUSH
22821: LD_STRING D4a-Pow-2
22823: PPUSH
22824: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22828: LD_VAR 0 1
22832: PPUSH
22833: LD_INT 0
22835: PPUSH
22836: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22840: LD_ADDR_EXP 102
22844: PUSH
22845: LD_EXP 102
22849: PPUSH
22850: LD_INT 4
22852: PPUSH
22853: LD_EXP 102
22857: PUSH
22858: LD_INT 4
22860: ARRAY
22861: PUSH
22862: LD_VAR 0 1
22866: UNION
22867: PPUSH
22868: CALL_OW 1
22872: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22873: LD_INT 8
22875: PPUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 472
// end ;
22885: GO 22750
22887: POP
22888: POP
// wait ( 2 2$00 ) ;
22889: LD_INT 4200
22891: PPUSH
22892: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22896: LD_ADDR_VAR 0 9
22900: PUSH
22901: LD_INT 22
22903: PUSH
22904: LD_INT 4
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: PUSH
22911: LD_INT 30
22913: PUSH
22914: LD_INT 32
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: LD_INT 58
22923: PUSH
22924: EMPTY
22925: LIST
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 69
22936: ST_TO_ADDR
// if tmp then
22937: LD_VAR 0 2
22941: IFFALSE 23181
// begin for i := 1 to tmp do
22943: LD_ADDR_VAR 0 1
22947: PUSH
22948: DOUBLE
22949: LD_INT 1
22951: DEC
22952: ST_TO_ADDR
22953: LD_VAR 0 2
22957: PUSH
22958: FOR_TO
22959: IFFALSE 23172
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22961: LD_ADDR_EXP 102
22965: PUSH
22966: LD_EXP 102
22970: PPUSH
22971: LD_INT 4
22973: PPUSH
22974: LD_EXP 102
22978: PUSH
22979: LD_INT 4
22981: ARRAY
22982: PUSH
22983: LD_VAR 0 2
22987: PUSH
22988: LD_VAR 0 1
22992: ARRAY
22993: DIFF
22994: PPUSH
22995: CALL_OW 1
22999: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23000: LD_ADDR_VAR 0 10
23004: PUSH
23005: LD_VAR 0 2
23009: PUSH
23010: LD_VAR 0 1
23014: ARRAY
23015: PPUSH
23016: CALL_OW 310
23020: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23021: LD_VAR 0 10
23025: PUSH
23026: LD_VAR 0 10
23030: PPUSH
23031: CALL_OW 266
23035: PUSH
23036: LD_INT 32
23038: EQUAL
23039: AND
23040: IFFALSE 23044
// continue ;
23042: GO 22958
// if t then
23044: LD_VAR 0 10
23048: IFFALSE 23065
// ComExitBuilding ( tmp [ i ] ) ;
23050: LD_VAR 0 2
23054: PUSH
23055: LD_VAR 0 1
23059: ARRAY
23060: PPUSH
23061: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23065: LD_VAR 0 2
23069: PUSH
23070: LD_VAR 0 1
23074: ARRAY
23075: PPUSH
23076: LD_VAR 0 5
23080: PUSH
23081: LD_INT 1
23083: ARRAY
23084: PPUSH
23085: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23089: LD_VAR 0 2
23093: PUSH
23094: LD_VAR 0 1
23098: ARRAY
23099: PPUSH
23100: LD_INT 1
23102: PPUSH
23103: CALL_OW 183
// if emptyTowers then
23107: LD_VAR 0 9
23111: IFFALSE 23170
// begin AddComExitBuilding ( tmp [ i ] ) ;
23113: LD_VAR 0 2
23117: PUSH
23118: LD_VAR 0 1
23122: ARRAY
23123: PPUSH
23124: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23128: LD_VAR 0 2
23132: PUSH
23133: LD_VAR 0 1
23137: ARRAY
23138: PPUSH
23139: LD_VAR 0 9
23143: PUSH
23144: LD_INT 1
23146: ARRAY
23147: PPUSH
23148: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23152: LD_ADDR_VAR 0 9
23156: PUSH
23157: LD_VAR 0 9
23161: PPUSH
23162: LD_INT 1
23164: PPUSH
23165: CALL_OW 3
23169: ST_TO_ADDR
// end ; end ;
23170: GO 22958
23172: POP
23173: POP
// wait ( 0 0$30 ) ;
23174: LD_INT 1050
23176: PPUSH
23177: CALL_OW 67
// end ; uc_side := 6 ;
23181: LD_ADDR_OWVAR 20
23185: PUSH
23186: LD_INT 6
23188: ST_TO_ADDR
// uc_nation := 3 ;
23189: LD_ADDR_OWVAR 21
23193: PUSH
23194: LD_INT 3
23196: ST_TO_ADDR
// ru := [ ] ;
23197: LD_ADDR_VAR 0 7
23201: PUSH
23202: EMPTY
23203: ST_TO_ADDR
// for i = 1 to 5 do
23204: LD_ADDR_VAR 0 1
23208: PUSH
23209: DOUBLE
23210: LD_INT 1
23212: DEC
23213: ST_TO_ADDR
23214: LD_INT 5
23216: PUSH
23217: FOR_TO
23218: IFFALSE 23338
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23220: LD_INT 22
23222: PUSH
23223: LD_INT 23
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: PUSH
23230: LD_INT 1
23232: PPUSH
23233: LD_INT 2
23235: PPUSH
23236: CALL_OW 12
23240: ARRAY
23241: PPUSH
23242: LD_INT 1
23244: PPUSH
23245: LD_INT 3
23247: PPUSH
23248: LD_INT 43
23250: PUSH
23251: LD_INT 44
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 1
23260: PPUSH
23261: LD_INT 2
23263: PPUSH
23264: CALL_OW 12
23268: ARRAY
23269: PPUSH
23270: LD_INT 89
23272: PPUSH
23273: CALL 74431 0 5
// un := CreateVehicle ;
23277: LD_ADDR_VAR 0 8
23281: PUSH
23282: CALL_OW 45
23286: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23287: LD_VAR 0 8
23291: PPUSH
23292: LD_INT 4
23294: PPUSH
23295: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23299: LD_VAR 0 8
23303: PPUSH
23304: LD_INT 136
23306: PPUSH
23307: LD_INT 90
23309: PPUSH
23310: LD_INT 8
23312: PPUSH
23313: LD_INT 0
23315: PPUSH
23316: CALL_OW 50
// ru := ru ^ un ;
23320: LD_ADDR_VAR 0 7
23324: PUSH
23325: LD_VAR 0 7
23329: PUSH
23330: LD_VAR 0 8
23334: ADD
23335: ST_TO_ADDR
// end ;
23336: GO 23217
23338: POP
23339: POP
// if ru then
23340: LD_VAR 0 7
23344: IFFALSE 23361
// ComAgressiveMove ( ru , 57 , 94 ) ;
23346: LD_VAR 0 7
23350: PPUSH
23351: LD_INT 57
23353: PPUSH
23354: LD_INT 94
23356: PPUSH
23357: CALL_OW 114
// wait ( 3 3$00 ) ;
23361: LD_INT 6300
23363: PPUSH
23364: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23368: LD_INT 4
23370: PPUSH
23371: LD_INT 3
23373: PUSH
23374: LD_INT 1
23376: PUSH
23377: LD_INT 1
23379: PUSH
23380: LD_INT 5
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: PUSH
23389: LD_INT 4
23391: PUSH
23392: LD_INT 1
23394: PUSH
23395: LD_INT 1
23397: PUSH
23398: LD_INT 6
23400: PUSH
23401: EMPTY
23402: LIST
23403: LIST
23404: LIST
23405: LIST
23406: PUSH
23407: LD_INT 4
23409: PUSH
23410: LD_INT 1
23412: PUSH
23413: LD_INT 1
23415: PUSH
23416: LD_INT 7
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: LIST
23423: LIST
23424: PUSH
23425: LD_INT 3
23427: PUSH
23428: LD_INT 1
23430: PUSH
23431: LD_INT 1
23433: PUSH
23434: LD_INT 7
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: LIST
23441: LIST
23442: PUSH
23443: LD_INT 3
23445: PUSH
23446: LD_INT 1
23448: PUSH
23449: LD_INT 1
23451: PUSH
23452: LD_INT 5
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: LIST
23459: LIST
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: LIST
23465: LIST
23466: LIST
23467: PPUSH
23468: CALL 63117 0 2
// missionStage := 4 ;
23472: LD_ADDR_EXP 15
23476: PUSH
23477: LD_INT 4
23479: ST_TO_ADDR
// end ;
23480: PPOPN 11
23482: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23483: LD_EXP 15
23487: PUSH
23488: LD_INT 4
23490: EQUAL
23491: PUSH
23492: LD_INT 22
23494: PUSH
23495: LD_INT 4
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PUSH
23502: LD_INT 21
23504: PUSH
23505: LD_INT 2
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: PPUSH
23516: CALL_OW 69
23520: PUSH
23521: LD_INT 5
23523: GREATEREQUAL
23524: AND
23525: IFFALSE 27792
23527: GO 23529
23529: DISABLE
23530: LD_INT 0
23532: PPUSH
23533: PPUSH
23534: PPUSH
23535: PPUSH
23536: PPUSH
23537: PPUSH
23538: PPUSH
23539: PPUSH
23540: PPUSH
23541: PPUSH
23542: PPUSH
23543: PPUSH
23544: PPUSH
// begin wait ( 0 0$10 ) ;
23545: LD_INT 350
23547: PPUSH
23548: CALL_OW 67
// missionStage := 5 ;
23552: LD_ADDR_EXP 15
23556: PUSH
23557: LD_INT 5
23559: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23560: LD_ADDR_VAR 0 10
23564: PUSH
23565: LD_INT 22
23567: PUSH
23568: LD_INT 4
23570: PUSH
23571: EMPTY
23572: LIST
23573: LIST
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: LD_INT 30
23580: PUSH
23581: LD_INT 4
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: LD_INT 30
23590: PUSH
23591: LD_INT 5
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: LIST
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 69
23611: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23612: LD_ADDR_VAR 0 6
23616: PUSH
23617: LD_INT 22
23619: PUSH
23620: LD_INT 4
23622: PUSH
23623: EMPTY
23624: LIST
23625: LIST
23626: PUSH
23627: LD_INT 21
23629: PUSH
23630: LD_INT 1
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 3
23639: PUSH
23640: LD_INT 25
23642: PUSH
23643: LD_INT 16
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: LD_INT 3
23656: PUSH
23657: LD_INT 25
23659: PUSH
23660: LD_INT 12
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: PPUSH
23677: CALL_OW 69
23681: PUSH
23682: LD_EXP 61
23686: DIFF
23687: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23688: LD_ADDR_VAR 0 9
23692: PUSH
23693: LD_INT 22
23695: PUSH
23696: LD_INT 4
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PUSH
23703: LD_INT 30
23705: PUSH
23706: LD_INT 3
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: PUSH
23713: EMPTY
23714: LIST
23715: LIST
23716: PPUSH
23717: CALL_OW 69
23721: PUSH
23722: LD_INT 1
23724: ARRAY
23725: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23726: LD_INT 350
23728: PPUSH
23729: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23733: LD_EXP 121
23737: PUSH
23738: LD_INT 4
23740: ARRAY
23741: PUSH
23742: LD_INT 5
23744: LESS
23745: PUSH
23746: LD_VAR 0 9
23750: PPUSH
23751: CALL_OW 461
23755: PUSH
23756: LD_INT 2
23758: EQUAL
23759: AND
23760: IFFALSE 23790
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23762: LD_INT 4
23764: PPUSH
23765: LD_INT 3
23767: PUSH
23768: LD_INT 1
23770: PUSH
23771: LD_INT 1
23773: PUSH
23774: LD_INT 5
23776: PUSH
23777: EMPTY
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: PUSH
23783: EMPTY
23784: LIST
23785: PPUSH
23786: CALL 63165 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23790: LD_EXP 121
23794: PUSH
23795: LD_INT 4
23797: ARRAY
23798: PUSH
23799: LD_INT 5
23801: GREATEREQUAL
23802: PUSH
23803: LD_EXP 121
23807: PUSH
23808: LD_INT 4
23810: ARRAY
23811: PPUSH
23812: LD_INT 58
23814: PUSH
23815: EMPTY
23816: LIST
23817: PPUSH
23818: CALL_OW 72
23822: PUSH
23823: LD_INT 5
23825: GREATEREQUAL
23826: AND
23827: IFFALSE 23726
// powellAllowRetreat := false ;
23829: LD_ADDR_EXP 19
23833: PUSH
23834: LD_INT 0
23836: ST_TO_ADDR
// activeAttacks := false ;
23837: LD_ADDR_EXP 16
23841: PUSH
23842: LD_INT 0
23844: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23845: LD_INT 35
23847: PPUSH
23848: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23852: LD_INT 22
23854: PUSH
23855: LD_INT 6
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PPUSH
23862: CALL_OW 69
23866: PUSH
23867: LD_INT 0
23869: EQUAL
23870: IFFALSE 23845
// tmp := mc_vehicles [ 4 ] ;
23872: LD_ADDR_VAR 0 3
23876: PUSH
23877: LD_EXP 121
23881: PUSH
23882: LD_INT 4
23884: ARRAY
23885: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23886: LD_ADDR_VAR 0 1
23890: PUSH
23891: DOUBLE
23892: LD_INT 1
23894: DEC
23895: ST_TO_ADDR
23896: LD_EXP 18
23900: PUSH
23901: FOR_TO
23902: IFFALSE 24163
// begin for j in powellSquadAttack [ i ] do
23904: LD_ADDR_VAR 0 2
23908: PUSH
23909: LD_EXP 18
23913: PUSH
23914: LD_VAR 0 1
23918: ARRAY
23919: PUSH
23920: FOR_IN
23921: IFFALSE 24159
// begin forces := forces diff j ;
23923: LD_ADDR_VAR 0 6
23927: PUSH
23928: LD_VAR 0 6
23932: PUSH
23933: LD_VAR 0 2
23937: DIFF
23938: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23939: LD_VAR 0 2
23943: PPUSH
23944: LD_INT 1
23946: PPUSH
23947: CALL_OW 109
// wait ( 0 0$2 ) ;
23951: LD_INT 70
23953: PPUSH
23954: CALL_OW 67
// if IsInUnit ( j ) then
23958: LD_VAR 0 2
23962: PPUSH
23963: CALL_OW 310
23967: IFFALSE 23978
// ComExitBuilding ( j ) ;
23969: LD_VAR 0 2
23973: PPUSH
23974: CALL_OW 122
// if GetClass ( j ) <> 1 then
23978: LD_VAR 0 2
23982: PPUSH
23983: CALL_OW 257
23987: PUSH
23988: LD_INT 1
23990: NONEQUAL
23991: IFFALSE 24071
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23993: LD_VAR 0 10
23997: PUSH
23998: LD_INT 1
24000: ARRAY
24001: PPUSH
24002: CALL_OW 313
24006: PUSH
24007: LD_INT 5
24009: GREATEREQUAL
24010: IFFALSE 24032
// AddComEnterUnit ( j , arm [ 2 ] ) else
24012: LD_VAR 0 2
24016: PPUSH
24017: LD_VAR 0 10
24021: PUSH
24022: LD_INT 2
24024: ARRAY
24025: PPUSH
24026: CALL_OW 180
24030: GO 24050
// AddComEnterUnit ( j , arm [ 1 ] ) ;
24032: LD_VAR 0 2
24036: PPUSH
24037: LD_VAR 0 10
24041: PUSH
24042: LD_INT 1
24044: ARRAY
24045: PPUSH
24046: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
24050: LD_VAR 0 2
24054: PPUSH
24055: LD_INT 1
24057: PPUSH
24058: CALL_OW 183
// AddComExitBuilding ( j ) ;
24062: LD_VAR 0 2
24066: PPUSH
24067: CALL_OW 182
// end ; if i = 2 then
24071: LD_VAR 0 1
24075: PUSH
24076: LD_INT 2
24078: EQUAL
24079: IFFALSE 24096
// AddComMoveXY ( j , 61 , 93 ) ;
24081: LD_VAR 0 2
24085: PPUSH
24086: LD_INT 61
24088: PPUSH
24089: LD_INT 93
24091: PPUSH
24092: CALL_OW 171
// if i = 1 then
24096: LD_VAR 0 1
24100: PUSH
24101: LD_INT 1
24103: EQUAL
24104: IFFALSE 24157
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24106: LD_VAR 0 2
24110: PPUSH
24111: LD_VAR 0 3
24115: PUSH
24116: LD_INT 1
24118: ARRAY
24119: PPUSH
24120: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24124: LD_ADDR_VAR 0 3
24128: PUSH
24129: LD_VAR 0 3
24133: PPUSH
24134: LD_INT 1
24136: PPUSH
24137: CALL_OW 3
24141: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24142: LD_VAR 0 2
24146: PPUSH
24147: LD_INT 69
24149: PPUSH
24150: LD_INT 94
24152: PPUSH
24153: CALL_OW 171
// end ; end ;
24157: GO 23920
24159: POP
24160: POP
// end ;
24161: GO 23901
24163: POP
24164: POP
// wait ( 0 0$30 ) ;
24165: LD_INT 1050
24167: PPUSH
24168: CALL_OW 67
// MC_Kill ( 4 ) ;
24172: LD_INT 4
24174: PPUSH
24175: CALL 39140 0 1
// tmp := UnitsInside ( fac ) ;
24179: LD_ADDR_VAR 0 3
24183: PUSH
24184: LD_VAR 0 9
24188: PPUSH
24189: CALL_OW 313
24193: ST_TO_ADDR
// if tmp then
24194: LD_VAR 0 3
24198: IFFALSE 24319
// for i in tmp do
24200: LD_ADDR_VAR 0 1
24204: PUSH
24205: LD_VAR 0 3
24209: PUSH
24210: FOR_IN
24211: IFFALSE 24317
// begin ComExitBuilding ( i ) ;
24213: LD_VAR 0 1
24217: PPUSH
24218: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24222: LD_VAR 0 10
24226: PUSH
24227: LD_INT 2
24229: ARRAY
24230: PPUSH
24231: CALL_OW 313
24235: PUSH
24236: LD_INT 6
24238: LESS
24239: IFFALSE 24261
// AddComEnterUnit ( i , arm [ 2 ] ) else
24241: LD_VAR 0 1
24245: PPUSH
24246: LD_VAR 0 10
24250: PUSH
24251: LD_INT 2
24253: ARRAY
24254: PPUSH
24255: CALL_OW 180
24259: GO 24315
// if UnitsInside ( arm [ 1 ] ) < 6 then
24261: LD_VAR 0 10
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: PPUSH
24270: CALL_OW 313
24274: PUSH
24275: LD_INT 6
24277: LESS
24278: IFFALSE 24300
// AddComEnterUnit ( i , arm [ 1 ] ) else
24280: LD_VAR 0 1
24284: PPUSH
24285: LD_VAR 0 10
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: CALL_OW 180
24298: GO 24315
// AddComMoveXY ( i , 37 , 68 ) ;
24300: LD_VAR 0 1
24304: PPUSH
24305: LD_INT 37
24307: PPUSH
24308: LD_INT 68
24310: PPUSH
24311: CALL_OW 171
// end ;
24315: GO 24210
24317: POP
24318: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24319: LD_ADDR_VAR 0 11
24323: PUSH
24324: LD_VAR 0 6
24328: PPUSH
24329: LD_INT 26
24331: PUSH
24332: LD_INT 1
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PPUSH
24339: CALL_OW 72
24343: PUSH
24344: LD_EXP 62
24348: DIFF
24349: ST_TO_ADDR
// if not speaker then
24350: LD_VAR 0 11
24354: NOT
24355: IFFALSE 24382
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24357: LD_ADDR_VAR 0 11
24361: PUSH
24362: LD_VAR 0 6
24366: PPUSH
24367: LD_INT 26
24369: PUSH
24370: LD_INT 1
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PPUSH
24377: CALL_OW 72
24381: ST_TO_ADDR
// if speaker then
24382: LD_VAR 0 11
24386: IFFALSE 24402
// speaker := speaker [ 1 ] ;
24388: LD_ADDR_VAR 0 11
24392: PUSH
24393: LD_VAR 0 11
24397: PUSH
24398: LD_INT 1
24400: ARRAY
24401: ST_TO_ADDR
// Video ( true ) ;
24402: LD_INT 1
24404: PPUSH
24405: CALL 107254 0 1
// CenterNowOnUnits ( Powell ) ;
24409: LD_EXP 61
24413: PPUSH
24414: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24418: LD_ADDR_VAR 0 3
24422: PUSH
24423: LD_VAR 0 6
24427: PPUSH
24428: LD_INT 3
24430: PUSH
24431: LD_INT 25
24433: PUSH
24434: LD_INT 1
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PPUSH
24445: CALL_OW 72
24449: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24450: LD_ADDR_VAR 0 12
24454: PUSH
24455: LD_INT 22
24457: PUSH
24458: LD_INT 4
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PUSH
24465: LD_INT 30
24467: PUSH
24468: LD_INT 32
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 58
24477: PUSH
24478: EMPTY
24479: LIST
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: LIST
24485: PPUSH
24486: CALL_OW 69
24490: ST_TO_ADDR
// for i := 1 to 4 do
24491: LD_ADDR_VAR 0 1
24495: PUSH
24496: DOUBLE
24497: LD_INT 1
24499: DEC
24500: ST_TO_ADDR
24501: LD_INT 4
24503: PUSH
24504: FOR_TO
24505: IFFALSE 24651
// begin if IsInUnit ( tmp [ i ] ) then
24507: LD_VAR 0 3
24511: PUSH
24512: LD_VAR 0 1
24516: ARRAY
24517: PPUSH
24518: CALL_OW 310
24522: IFFALSE 24539
// ComExitBuilding ( tmp [ i ] ) ;
24524: LD_VAR 0 3
24528: PUSH
24529: LD_VAR 0 1
24533: ARRAY
24534: PPUSH
24535: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24539: LD_VAR 0 3
24543: PUSH
24544: LD_VAR 0 1
24548: ARRAY
24549: PPUSH
24550: LD_VAR 0 10
24554: PUSH
24555: LD_INT 1
24557: ARRAY
24558: PPUSH
24559: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24563: LD_VAR 0 3
24567: PUSH
24568: LD_VAR 0 1
24572: ARRAY
24573: PPUSH
24574: LD_INT 1
24576: PPUSH
24577: CALL_OW 183
// if Count ( emp_towers ) then
24581: LD_VAR 0 12
24585: PPUSH
24586: CALL 71693 0 1
24590: IFFALSE 24649
// begin AddComExitBuilding ( tmp [ i ] ) ;
24592: LD_VAR 0 3
24596: PUSH
24597: LD_VAR 0 1
24601: ARRAY
24602: PPUSH
24603: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24607: LD_VAR 0 3
24611: PUSH
24612: LD_VAR 0 1
24616: ARRAY
24617: PPUSH
24618: LD_VAR 0 12
24622: PUSH
24623: LD_INT 1
24625: ARRAY
24626: PPUSH
24627: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24631: LD_ADDR_VAR 0 12
24635: PUSH
24636: LD_VAR 0 12
24640: PPUSH
24641: LD_INT 1
24643: PPUSH
24644: CALL_OW 3
24648: ST_TO_ADDR
// end ; end ;
24649: GO 24504
24651: POP
24652: POP
// wait ( 0 0$5 ) ;
24653: LD_INT 175
24655: PPUSH
24656: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24660: LD_VAR 0 3
24664: PPUSH
24665: LD_INT 3
24667: PUSH
24668: LD_INT 54
24670: PUSH
24671: EMPTY
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: PPUSH
24678: CALL_OW 72
24682: IFFALSE 24702
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24684: LD_VAR 0 3
24688: PPUSH
24689: LD_VAR 0 10
24693: PUSH
24694: LD_INT 1
24696: ARRAY
24697: PPUSH
24698: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24702: LD_ADDR_VAR 0 3
24706: PUSH
24707: LD_EXP 18
24711: PUSH
24712: LD_INT 1
24714: ARRAY
24715: PUSH
24716: LD_EXP 18
24720: PUSH
24721: LD_INT 2
24723: ARRAY
24724: ADD
24725: PPUSH
24726: LD_INT 26
24728: PUSH
24729: LD_INT 1
24731: PUSH
24732: EMPTY
24733: LIST
24734: LIST
24735: PPUSH
24736: CALL_OW 72
24740: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24741: LD_ADDR_VAR 0 1
24745: PUSH
24746: LD_EXP 18
24750: PUSH
24751: LD_INT 2
24753: ARRAY
24754: PUSH
24755: FOR_IN
24756: IFFALSE 24774
// ComTurnUnit ( i , Powell ) ;
24758: LD_VAR 0 1
24762: PPUSH
24763: LD_EXP 61
24767: PPUSH
24768: CALL_OW 119
24772: GO 24755
24774: POP
24775: POP
// Say ( Powell , D5-Pow-1 ) ;
24776: LD_EXP 61
24780: PPUSH
24781: LD_STRING D5-Pow-1
24783: PPUSH
24784: CALL_OW 88
// if tmp then
24788: LD_VAR 0 3
24792: IFFALSE 24810
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24794: LD_VAR 0 3
24798: PUSH
24799: LD_INT 1
24801: ARRAY
24802: PPUSH
24803: LD_STRING D5-Sol2-1
24805: PPUSH
24806: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24810: LD_EXP 61
24814: PPUSH
24815: LD_STRING D5-Pow-2
24817: PPUSH
24818: CALL_OW 88
// if tmp > 1 then
24822: LD_VAR 0 3
24826: PUSH
24827: LD_INT 1
24829: GREATER
24830: IFFALSE 24848
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24832: LD_VAR 0 3
24836: PUSH
24837: LD_INT 2
24839: ARRAY
24840: PPUSH
24841: LD_STRING D5-Sol2-2
24843: PPUSH
24844: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24848: LD_EXP 61
24852: PPUSH
24853: LD_STRING D5-Pow-3
24855: PPUSH
24856: CALL_OW 88
// wait ( 0 0$1 ) ;
24860: LD_INT 35
24862: PPUSH
24863: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24867: LD_ADDR_VAR 0 3
24871: PUSH
24872: LD_EXP 18
24876: PUSH
24877: LD_INT 1
24879: ARRAY
24880: PUSH
24881: LD_EXP 18
24885: PUSH
24886: LD_INT 2
24888: ARRAY
24889: UNION
24890: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24891: LD_VAR 0 3
24895: PPUSH
24896: LD_INT 80
24898: PPUSH
24899: LD_INT 67
24901: PPUSH
24902: CALL_OW 114
// wait ( 0 0$2 ) ;
24906: LD_INT 70
24908: PPUSH
24909: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24913: LD_INT 79
24915: PPUSH
24916: LD_INT 72
24918: PPUSH
24919: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24923: LD_INT 70
24925: PPUSH
24926: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24930: LD_VAR 0 3
24934: PPUSH
24935: LD_INT 3
24937: PUSH
24938: LD_INT 24
24940: PUSH
24941: LD_INT 1000
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PPUSH
24952: CALL_OW 72
24956: IFFALSE 24923
// Say ( Powell , D5a-Pow-1 ) ;
24958: LD_EXP 61
24962: PPUSH
24963: LD_STRING D5a-Pow-1
24965: PPUSH
24966: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24970: LD_EXP 61
24974: PPUSH
24975: LD_STRING D5a-Pow-1a
24977: PPUSH
24978: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24982: LD_INT 24
24984: PPUSH
24985: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24989: LD_EXP 61
24993: PPUSH
24994: LD_STRING D5a-Pow-1b
24996: PPUSH
24997: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25001: LD_INT 10
25003: PPUSH
25004: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25008: LD_EXP 61
25012: PPUSH
25013: LD_STRING D5a-Pow-1c
25015: PPUSH
25016: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25020: LD_VAR 0 3
25024: PPUSH
25025: LD_INT 68
25027: PPUSH
25028: LD_INT 63
25030: PPUSH
25031: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25035: LD_INT 18
25037: PPUSH
25038: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25042: LD_EXP 61
25046: PPUSH
25047: LD_STRING D5a-Pow-1d
25049: PPUSH
25050: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25054: LD_INT 35
25056: PPUSH
25057: CALL_OW 67
// if not HasTask ( tmp ) then
25061: LD_VAR 0 3
25065: PPUSH
25066: CALL_OW 314
25070: NOT
25071: IFFALSE 25088
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25073: LD_VAR 0 3
25077: PPUSH
25078: LD_INT 68
25080: PPUSH
25081: LD_INT 63
25083: PPUSH
25084: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25088: LD_VAR 0 3
25092: PPUSH
25093: LD_INT 24
25095: PUSH
25096: LD_INT 1
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PPUSH
25103: CALL_OW 72
25107: NOT
25108: IFFALSE 25054
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25110: LD_ADDR_VAR 0 3
25114: PUSH
25115: LD_INT 22
25117: PUSH
25118: LD_INT 4
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: LD_INT 92
25127: PUSH
25128: LD_INT 60
25130: PUSH
25131: LD_INT 93
25133: PUSH
25134: LD_INT 10
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: LIST
25141: LIST
25142: PUSH
25143: LD_INT 3
25145: PUSH
25146: LD_INT 54
25148: PUSH
25149: EMPTY
25150: LIST
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: LIST
25160: PPUSH
25161: CALL_OW 69
25165: PUSH
25166: LD_EXP 61
25170: DIFF
25171: ST_TO_ADDR
// if tmp then
25172: LD_VAR 0 3
25176: IFFALSE 25210
// for i in tmp do
25178: LD_ADDR_VAR 0 1
25182: PUSH
25183: LD_VAR 0 3
25187: PUSH
25188: FOR_IN
25189: IFFALSE 25208
// ComMoveXY ( i , 36 , 67 ) ;
25191: LD_VAR 0 1
25195: PPUSH
25196: LD_INT 36
25198: PPUSH
25199: LD_INT 67
25201: PPUSH
25202: CALL_OW 111
25206: GO 25188
25208: POP
25209: POP
// wait ( 0 0$3 ) ;
25210: LD_INT 105
25212: PPUSH
25213: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25217: LD_VAR 0 11
25221: PPUSH
25222: LD_STRING D6-Sol3-1
25224: PPUSH
25225: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25229: LD_EXP 61
25233: PPUSH
25234: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25238: LD_EXP 61
25242: PPUSH
25243: LD_STRING D6-Pow-1
25245: PPUSH
25246: CALL_OW 88
// tmp := [ ] ;
25250: LD_ADDR_VAR 0 3
25254: PUSH
25255: EMPTY
25256: ST_TO_ADDR
// for i = 1 to 2 do
25257: LD_ADDR_VAR 0 1
25261: PUSH
25262: DOUBLE
25263: LD_INT 1
25265: DEC
25266: ST_TO_ADDR
25267: LD_INT 2
25269: PUSH
25270: FOR_TO
25271: IFFALSE 25385
// begin uc_side := 8 ;
25273: LD_ADDR_OWVAR 20
25277: PUSH
25278: LD_INT 8
25280: ST_TO_ADDR
// uc_nation := 2 ;
25281: LD_ADDR_OWVAR 21
25285: PUSH
25286: LD_INT 2
25288: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25289: LD_INT 14
25291: PPUSH
25292: LD_INT 3
25294: PPUSH
25295: LD_INT 2
25297: PPUSH
25298: LD_INT 29
25300: PPUSH
25301: LD_INT 100
25303: PPUSH
25304: CALL 74431 0 5
// veh := CreateVehicle ;
25308: LD_ADDR_VAR 0 13
25312: PUSH
25313: CALL_OW 45
25317: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25318: LD_VAR 0 13
25322: PPUSH
25323: LD_INT 4
25325: PPUSH
25326: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25330: LD_VAR 0 13
25334: PPUSH
25335: LD_INT 99
25337: PPUSH
25338: LD_INT 83
25340: PPUSH
25341: LD_INT 3
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL_OW 50
// wait ( 3 ) ;
25351: LD_INT 3
25353: PPUSH
25354: CALL_OW 67
// Connect ( veh ) ;
25358: LD_VAR 0 13
25362: PPUSH
25363: CALL 77899 0 1
// tmp := tmp ^ veh ;
25367: LD_ADDR_VAR 0 3
25371: PUSH
25372: LD_VAR 0 3
25376: PUSH
25377: LD_VAR 0 13
25381: ADD
25382: ST_TO_ADDR
// end ;
25383: GO 25270
25385: POP
25386: POP
// wait ( 0 0$1 ) ;
25387: LD_INT 35
25389: PPUSH
25390: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25394: LD_INT 99
25396: PPUSH
25397: LD_INT 83
25399: PPUSH
25400: LD_INT 1
25402: PPUSH
25403: LD_INT 10
25405: PPUSH
25406: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25410: LD_INT 99
25412: PPUSH
25413: LD_INT 83
25415: PPUSH
25416: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25420: LD_VAR 0 11
25424: PPUSH
25425: LD_STRING D6-Sol3-2
25427: PPUSH
25428: CALL_OW 88
// async ;
25432: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25433: LD_EXP 61
25437: PPUSH
25438: LD_STRING D6-Pow-2
25440: PPUSH
25441: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25445: LD_VAR 0 3
25449: PUSH
25450: LD_INT 1
25452: ARRAY
25453: PPUSH
25454: LD_VAR 0 9
25458: PPUSH
25459: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25463: LD_VAR 0 3
25467: PUSH
25468: LD_INT 2
25470: ARRAY
25471: PPUSH
25472: LD_INT 22
25474: PUSH
25475: LD_INT 4
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_INT 21
25484: PUSH
25485: LD_INT 3
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: PUSH
25492: EMPTY
25493: LIST
25494: LIST
25495: PPUSH
25496: CALL_OW 69
25500: PPUSH
25501: LD_VAR 0 3
25505: PUSH
25506: LD_INT 2
25508: ARRAY
25509: PPUSH
25510: CALL_OW 74
25514: PPUSH
25515: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25519: LD_EXP 61
25523: PPUSH
25524: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25528: LD_INT 99
25530: PPUSH
25531: LD_INT 83
25533: PPUSH
25534: LD_INT 1
25536: PPUSH
25537: CALL_OW 331
// repeat wait ( 4 ) ;
25541: LD_INT 4
25543: PPUSH
25544: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25548: LD_VAR 0 3
25552: PUSH
25553: LD_INT 1
25555: ARRAY
25556: PPUSH
25557: CALL_OW 256
25561: PUSH
25562: LD_INT 1000
25564: LESS
25565: IFFALSE 25583
// SetLives ( tmp [ 1 ] , 1000 ) ;
25567: LD_VAR 0 3
25571: PUSH
25572: LD_INT 1
25574: ARRAY
25575: PPUSH
25576: LD_INT 1000
25578: PPUSH
25579: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25583: LD_INT 22
25585: PUSH
25586: LD_INT 4
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: LD_INT 30
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 69
25611: PUSH
25612: LD_INT 0
25614: EQUAL
25615: IFFALSE 25541
// skirmish := false ;
25617: LD_ADDR_EXP 100
25621: PUSH
25622: LD_INT 0
25624: ST_TO_ADDR
// sync ;
25625: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25626: LD_EXP 61
25630: PPUSH
25631: LD_STRING D6a-Pow-1
25633: PPUSH
25634: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25638: LD_VAR 0 11
25642: PPUSH
25643: LD_STRING D6a-Sol3-1
25645: PPUSH
25646: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25650: LD_EXP 61
25654: PPUSH
25655: LD_STRING D6a-Pow-2
25657: PPUSH
25658: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25662: LD_VAR 0 11
25666: PPUSH
25667: LD_STRING D6a-Sol3-2
25669: PPUSH
25670: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25674: LD_EXP 61
25678: PPUSH
25679: LD_STRING D6a-Pow-3
25681: PPUSH
25682: CALL_OW 88
// powellCenterCameraMode := true ;
25686: LD_ADDR_EXP 20
25690: PUSH
25691: LD_INT 1
25693: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25694: LD_ADDR_VAR 0 1
25698: PUSH
25699: LD_INT 22
25701: PUSH
25702: LD_INT 8
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: LD_INT 25
25711: PUSH
25712: LD_INT 2
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PPUSH
25723: CALL_OW 69
25727: PUSH
25728: FOR_IN
25729: IFFALSE 25784
// begin SetTag ( i , 1 ) ;
25731: LD_VAR 0 1
25735: PPUSH
25736: LD_INT 1
25738: PPUSH
25739: CALL_OW 109
// ComExitBuilding ( i ) ;
25743: LD_VAR 0 1
25747: PPUSH
25748: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25752: LD_VAR 0 1
25756: PPUSH
25757: LD_INT 35
25759: PPUSH
25760: LD_INT 6
25762: PPUSH
25763: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25767: LD_VAR 0 1
25771: PPUSH
25772: LD_INT 53
25774: PPUSH
25775: LD_INT 4
25777: PPUSH
25778: CALL_OW 171
// end ;
25782: GO 25728
25784: POP
25785: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25786: LD_ADDR_VAR 0 3
25790: PUSH
25791: LD_INT 22
25793: PUSH
25794: LD_INT 4
25796: PUSH
25797: EMPTY
25798: LIST
25799: LIST
25800: PUSH
25801: LD_INT 21
25803: PUSH
25804: LD_INT 2
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: PUSH
25811: LD_INT 3
25813: PUSH
25814: LD_INT 34
25816: PUSH
25817: LD_INT 12
25819: PUSH
25820: EMPTY
25821: LIST
25822: LIST
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: LIST
25832: PPUSH
25833: CALL_OW 69
25837: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25838: LD_EXP 61
25842: PPUSH
25843: LD_VAR 0 3
25847: PPUSH
25848: LD_EXP 61
25852: PPUSH
25853: CALL_OW 74
25857: PPUSH
25858: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25862: LD_EXP 61
25866: PPUSH
25867: LD_INT 100
25869: PPUSH
25870: LD_INT 88
25872: PPUSH
25873: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25877: LD_EXP 61
25881: PPUSH
25882: LD_INT 100
25884: PPUSH
25885: LD_INT 75
25887: PPUSH
25888: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25892: LD_EXP 61
25896: PPUSH
25897: LD_INT 88
25899: PPUSH
25900: LD_INT 53
25902: PPUSH
25903: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25907: LD_INT 8
25909: PPUSH
25910: LD_EXP 61
25914: PPUSH
25915: CALL_OW 471
// repeat wait ( 3 ) ;
25919: LD_INT 3
25921: PPUSH
25922: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25926: LD_INT 22
25928: PUSH
25929: LD_INT 4
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: PUSH
25936: LD_INT 92
25938: PUSH
25939: LD_INT 100
25941: PUSH
25942: LD_INT 75
25944: PUSH
25945: LD_INT 6
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PPUSH
25958: CALL_OW 69
25962: IFFALSE 25919
// async ;
25964: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25965: LD_EXP 61
25969: PPUSH
25970: LD_STRING D6b-Pow-1
25972: PPUSH
25973: CALL_OW 88
// repeat wait ( 3 ) ;
25977: LD_INT 3
25979: PPUSH
25980: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25984: LD_EXP 61
25988: PPUSH
25989: CALL_OW 310
25993: PPUSH
25994: CALL_OW 256
25998: PUSH
25999: LD_INT 1000
26001: LESS
26002: IFFALSE 26021
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26004: LD_EXP 61
26008: PPUSH
26009: CALL_OW 310
26013: PPUSH
26014: LD_INT 1000
26016: PPUSH
26017: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26021: LD_EXP 61
26025: PPUSH
26026: CALL_OW 256
26030: PUSH
26031: LD_INT 1000
26033: LESS
26034: IFFALSE 26048
// SetLives ( Powell , 1000 ) ;
26036: LD_EXP 61
26040: PPUSH
26041: LD_INT 1000
26043: PPUSH
26044: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26048: LD_EXP 61
26052: PPUSH
26053: LD_EXP 67
26057: PPUSH
26058: CALL_OW 296
26062: PUSH
26063: LD_INT 5
26065: LESS
26066: PUSH
26067: LD_EXP 61
26071: PPUSH
26072: CALL_OW 310
26076: PPUSH
26077: LD_EXP 67
26081: PPUSH
26082: CALL_OW 296
26086: PUSH
26087: LD_INT 5
26089: LESS
26090: OR
26091: IFFALSE 26110
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26093: LD_EXP 61
26097: PPUSH
26098: CALL_OW 310
26102: PPUSH
26103: LD_INT 100
26105: PPUSH
26106: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26110: LD_EXP 61
26114: PPUSH
26115: CALL_OW 310
26119: NOT
26120: IFFALSE 25977
// DoNotAttack ( 8 , powellBomb ) ;
26122: LD_INT 8
26124: PPUSH
26125: LD_EXP 67
26129: PPUSH
26130: CALL_OW 471
// game_speed := 4 ;
26134: LD_ADDR_OWVAR 65
26138: PUSH
26139: LD_INT 4
26141: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26142: LD_EXP 61
26146: PPUSH
26147: LD_STRING D6b-Pow-1a
26149: PPUSH
26150: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26154: LD_EXP 61
26158: PPUSH
26159: LD_EXP 67
26163: PPUSH
26164: CALL_OW 180
// sync ;
26168: SYNC
// repeat wait ( 0 0$1 ) ;
26169: LD_INT 35
26171: PPUSH
26172: CALL_OW 67
// until IsInUnit ( Powell ) ;
26176: LD_EXP 61
26180: PPUSH
26181: CALL_OW 310
26185: IFFALSE 26169
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26187: LD_INT 8
26189: PPUSH
26190: LD_EXP 61
26194: PPUSH
26195: CALL_OW 310
26199: PPUSH
26200: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26204: LD_EXP 61
26208: PPUSH
26209: LD_INT 91
26211: PPUSH
26212: LD_INT 44
26214: PPUSH
26215: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26219: LD_EXP 61
26223: PPUSH
26224: LD_INT 96
26226: PPUSH
26227: LD_INT 44
26229: PPUSH
26230: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26234: LD_EXP 61
26238: PPUSH
26239: LD_INT 96
26241: PPUSH
26242: LD_INT 41
26244: PPUSH
26245: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26249: LD_EXP 61
26253: PPUSH
26254: LD_INT 92
26256: PPUSH
26257: LD_INT 39
26259: PPUSH
26260: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26264: LD_EXP 61
26268: PPUSH
26269: LD_INT 88
26271: PPUSH
26272: LD_INT 41
26274: PPUSH
26275: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26279: LD_EXP 61
26283: PPUSH
26284: LD_INT 91
26286: PPUSH
26287: LD_INT 44
26289: PPUSH
26290: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26294: LD_EXP 61
26298: PPUSH
26299: LD_INT 96
26301: PPUSH
26302: LD_INT 44
26304: PPUSH
26305: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26309: LD_EXP 61
26313: PPUSH
26314: LD_INT 96
26316: PPUSH
26317: LD_INT 41
26319: PPUSH
26320: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26324: LD_EXP 61
26328: PPUSH
26329: LD_INT 92
26331: PPUSH
26332: LD_INT 39
26334: PPUSH
26335: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26339: LD_EXP 61
26343: PPUSH
26344: LD_INT 88
26346: PPUSH
26347: LD_INT 41
26349: PPUSH
26350: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26354: LD_EXP 61
26358: PPUSH
26359: LD_INT 91
26361: PPUSH
26362: LD_INT 44
26364: PPUSH
26365: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26369: LD_EXP 61
26373: PPUSH
26374: LD_INT 93
26376: PPUSH
26377: LD_INT 39
26379: PPUSH
26380: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26384: LD_EXP 61
26388: PPUSH
26389: LD_INT 93
26391: PPUSH
26392: LD_INT 36
26394: PPUSH
26395: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26399: LD_INT 122
26401: PPUSH
26402: CALL_OW 67
// game_speed := 4 ;
26406: LD_ADDR_OWVAR 65
26410: PUSH
26411: LD_INT 4
26413: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26414: LD_EXP 61
26418: PPUSH
26419: LD_STRING D6b-Pow-1b
26421: PPUSH
26422: CALL_OW 88
// tmp := [ ] ;
26426: LD_ADDR_VAR 0 3
26430: PUSH
26431: EMPTY
26432: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26433: LD_ADDR_VAR 0 5
26437: PUSH
26438: LD_INT 78
26440: PUSH
26441: LD_INT 47
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: LD_INT 106
26450: PUSH
26451: LD_INT 53
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26462: LD_ADDR_VAR 0 1
26466: PUSH
26467: LD_INT 22
26469: PUSH
26470: LD_INT 8
26472: PUSH
26473: EMPTY
26474: LIST
26475: LIST
26476: PUSH
26477: LD_INT 21
26479: PUSH
26480: LD_INT 3
26482: PUSH
26483: EMPTY
26484: LIST
26485: LIST
26486: PUSH
26487: LD_INT 92
26489: PUSH
26490: LD_INT 90
26492: PUSH
26493: LD_INT 52
26495: PUSH
26496: LD_INT 12
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: LIST
26503: LIST
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: LIST
26509: PPUSH
26510: CALL_OW 69
26514: PUSH
26515: FOR_IN
26516: IFFALSE 26541
// tmp := tmp ^ UnitsInside ( i ) ;
26518: LD_ADDR_VAR 0 3
26522: PUSH
26523: LD_VAR 0 3
26527: PUSH
26528: LD_VAR 0 1
26532: PPUSH
26533: CALL_OW 313
26537: ADD
26538: ST_TO_ADDR
26539: GO 26515
26541: POP
26542: POP
// for i in tmp do
26543: LD_ADDR_VAR 0 1
26547: PUSH
26548: LD_VAR 0 3
26552: PUSH
26553: FOR_IN
26554: IFFALSE 26716
// begin dist := 9999 ;
26556: LD_ADDR_VAR 0 8
26560: PUSH
26561: LD_INT 9999
26563: ST_TO_ADDR
// _xy := [ ] ;
26564: LD_ADDR_VAR 0 7
26568: PUSH
26569: EMPTY
26570: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26571: LD_VAR 0 1
26575: PPUSH
26576: LD_INT 1
26578: PPUSH
26579: CALL_OW 109
// ComExitBuilding ( i ) ;
26583: LD_VAR 0 1
26587: PPUSH
26588: CALL_OW 122
// for j in xy do
26592: LD_ADDR_VAR 0 2
26596: PUSH
26597: LD_VAR 0 5
26601: PUSH
26602: FOR_IN
26603: IFFALSE 26685
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26605: LD_VAR 0 1
26609: PPUSH
26610: LD_VAR 0 2
26614: PUSH
26615: LD_INT 1
26617: ARRAY
26618: PPUSH
26619: LD_VAR 0 2
26623: PUSH
26624: LD_INT 2
26626: ARRAY
26627: PPUSH
26628: CALL_OW 297
26632: PUSH
26633: LD_VAR 0 8
26637: LESS
26638: IFFALSE 26683
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26640: LD_ADDR_VAR 0 8
26644: PUSH
26645: LD_VAR 0 1
26649: PPUSH
26650: LD_VAR 0 2
26654: PUSH
26655: LD_INT 1
26657: ARRAY
26658: PPUSH
26659: LD_VAR 0 2
26663: PUSH
26664: LD_INT 2
26666: ARRAY
26667: PPUSH
26668: CALL_OW 297
26672: ST_TO_ADDR
// _xy := j ;
26673: LD_ADDR_VAR 0 7
26677: PUSH
26678: LD_VAR 0 2
26682: ST_TO_ADDR
// end ;
26683: GO 26602
26685: POP
26686: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26687: LD_VAR 0 1
26691: PPUSH
26692: LD_VAR 0 7
26696: PUSH
26697: LD_INT 1
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 7
26705: PUSH
26706: LD_INT 2
26708: ARRAY
26709: PPUSH
26710: CALL_OW 171
// end ;
26714: GO 26553
26716: POP
26717: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26718: LD_ADDR_VAR 0 4
26722: PUSH
26723: LD_VAR 0 3
26727: PPUSH
26728: LD_INT 26
26730: PUSH
26731: LD_INT 1
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: LD_INT 25
26740: PUSH
26741: LD_INT 1
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PPUSH
26752: CALL_OW 72
26756: ST_TO_ADDR
// if tmp2 < 2 then
26757: LD_VAR 0 4
26761: PUSH
26762: LD_INT 2
26764: LESS
26765: IFFALSE 26834
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26767: LD_ADDR_VAR 0 4
26771: PUSH
26772: LD_INT 22
26774: PUSH
26775: LD_INT 8
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 26
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: PUSH
26792: LD_INT 3
26794: PUSH
26795: LD_INT 25
26797: PUSH
26798: LD_INT 15
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: EMPTY
26806: LIST
26807: LIST
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: LIST
26813: PPUSH
26814: CALL_OW 69
26818: PUSH
26819: LD_EXP 64
26823: PUSH
26824: LD_EXP 65
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: DIFF
26833: ST_TO_ADDR
// if tmp2 then
26834: LD_VAR 0 4
26838: IFFALSE 26856
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26840: LD_VAR 0 4
26844: PUSH
26845: LD_INT 1
26847: ARRAY
26848: PPUSH
26849: LD_STRING D6b-ArSol1-1
26851: PPUSH
26852: CALL_OW 88
// async ;
26856: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26857: LD_EXP 61
26861: PPUSH
26862: LD_STRING D6b-Pow-2
26864: PPUSH
26865: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26869: LD_INT 18
26871: PPUSH
26872: CALL_OW 67
// if tmp2 > 1 then
26876: LD_VAR 0 4
26880: PUSH
26881: LD_INT 1
26883: GREATER
26884: IFFALSE 26902
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26886: LD_VAR 0 4
26890: PUSH
26891: LD_INT 2
26893: ARRAY
26894: PPUSH
26895: LD_STRING D6b-ArSol2-1
26897: PPUSH
26898: CALL_OW 88
// sync ;
26902: SYNC
// repeat wait ( 5 ) ;
26903: LD_INT 5
26905: PPUSH
26906: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26910: LD_INT 93
26912: PPUSH
26913: LD_INT 36
26915: PPUSH
26916: CALL_OW 428
26920: PPUSH
26921: CALL_OW 255
26925: PUSH
26926: LD_INT 4
26928: EQUAL
26929: IFFALSE 26903
// DialogueOn ;
26931: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26935: LD_INT 10
26937: PPUSH
26938: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26942: LD_EXP 61
26946: PPUSH
26947: LD_STRING D6b-Pow-2a
26949: PPUSH
26950: CALL_OW 88
// DialogueOff ;
26954: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26958: LD_EXP 61
26962: PPUSH
26963: CALL_OW 310
26967: PPUSH
26968: LD_INT 332
26970: PPUSH
26971: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26975: LD_INT 93
26977: PPUSH
26978: LD_INT 35
26980: PPUSH
26981: LD_INT 1
26983: PPUSH
26984: LD_INT 6
26986: NEG
26987: PPUSH
26988: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26992: LD_INT 35
26994: PPUSH
26995: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26999: LD_INT 332
27001: PPUSH
27002: CALL_OW 256
27006: PUSH
27007: LD_INT 1000
27009: LESS
27010: PUSH
27011: LD_INT 332
27013: PPUSH
27014: CALL_OW 300
27018: AND
27019: IFFALSE 27031
// SetLives ( kozlov_fac , 0 ) ;
27021: LD_INT 332
27023: PPUSH
27024: LD_INT 0
27026: PPUSH
27027: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27031: LD_INT 332
27033: PPUSH
27034: CALL_OW 301
27038: PUSH
27039: LD_EXP 61
27043: PPUSH
27044: CALL_OW 301
27048: OR
27049: IFFALSE 26992
// game_speed := 4 ;
27051: LD_ADDR_OWVAR 65
27055: PUSH
27056: LD_INT 4
27058: ST_TO_ADDR
// powellCenterCameraMode := false ;
27059: LD_ADDR_EXP 20
27063: PUSH
27064: LD_INT 0
27066: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27067: LD_ADDR_VAR 0 1
27071: PUSH
27072: LD_VAR 0 3
27076: PUSH
27077: LD_INT 22
27079: PUSH
27080: LD_INT 8
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 25
27089: PUSH
27090: LD_INT 2
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PPUSH
27101: CALL_OW 69
27105: UNION
27106: PUSH
27107: FOR_IN
27108: IFFALSE 27124
// SetTag ( i , 0 ) ;
27110: LD_VAR 0 1
27114: PPUSH
27115: LD_INT 0
27117: PPUSH
27118: CALL_OW 109
27122: GO 27107
27124: POP
27125: POP
// wait ( 0 0$3 ) ;
27126: LD_INT 105
27128: PPUSH
27129: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27133: LD_INT 93
27135: PPUSH
27136: LD_INT 35
27138: PPUSH
27139: LD_INT 1
27141: PPUSH
27142: CALL_OW 331
// DialogueOn ;
27146: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27150: LD_VAR 0 11
27154: PPUSH
27155: LD_STRING D6c-Sol3-1
27157: PPUSH
27158: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27162: LD_INT 10
27164: PPUSH
27165: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27169: LD_EXP 40
27173: PPUSH
27174: LD_STRING D6c-JMM-1
27176: PPUSH
27177: CALL_OW 88
// if Cyrus then
27181: LD_EXP 46
27185: IFFALSE 27199
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27187: LD_EXP 46
27191: PPUSH
27192: LD_STRING D6c-Cyrus-1
27194: PPUSH
27195: CALL_OW 88
// if Bobby then
27199: LD_EXP 45
27203: IFFALSE 27217
// Say ( Bobby , D6c-Bobby-1 ) ;
27205: LD_EXP 45
27209: PPUSH
27210: LD_STRING D6c-Bobby-1
27212: PPUSH
27213: CALL_OW 88
// if Cornel then
27217: LD_EXP 51
27221: IFFALSE 27235
// Say ( Cornel , D6c-Corn-1 ) ;
27223: LD_EXP 51
27227: PPUSH
27228: LD_STRING D6c-Corn-1
27230: PPUSH
27231: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27235: LD_ADDR_VAR 0 4
27239: PUSH
27240: LD_INT 2
27242: PUSH
27243: LD_INT 22
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PUSH
27253: LD_INT 22
27255: PUSH
27256: LD_INT 4
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 26
27270: PUSH
27271: LD_INT 1
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PUSH
27278: LD_INT 23
27280: PUSH
27281: LD_INT 1
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: LIST
27292: PPUSH
27293: CALL_OW 69
27297: PUSH
27298: LD_VAR 0 11
27302: PUSH
27303: LD_EXP 40
27307: UNION
27308: PUSH
27309: LD_EXP 62
27313: UNION
27314: DIFF
27315: ST_TO_ADDR
// if tmp2 then
27316: LD_VAR 0 4
27320: IFFALSE 27338
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27322: LD_VAR 0 4
27326: PUSH
27327: LD_INT 1
27329: ARRAY
27330: PPUSH
27331: LD_STRING D6c-Sol1-1
27333: PPUSH
27334: CALL_OW 88
// if Lisa then
27338: LD_EXP 43
27342: IFFALSE 27356
// Say ( Lisa , D6c-Lisa-1 ) ;
27344: LD_EXP 43
27348: PPUSH
27349: LD_STRING D6c-Lisa-1
27351: PPUSH
27352: CALL_OW 88
// if Gary then
27356: LD_EXP 52
27360: IFFALSE 27374
// Say ( Gary , D6c-Gary-1 ) ;
27362: LD_EXP 52
27366: PPUSH
27367: LD_STRING D6c-Gary-1
27369: PPUSH
27370: CALL_OW 88
// if Donaldson then
27374: LD_EXP 44
27378: IFFALSE 27392
// Say ( Donaldson , D6c-Don-1 ) ;
27380: LD_EXP 44
27384: PPUSH
27385: LD_STRING D6c-Don-1
27387: PPUSH
27388: CALL_OW 88
// if tmp2 > 1 then
27392: LD_VAR 0 4
27396: PUSH
27397: LD_INT 1
27399: GREATER
27400: IFFALSE 27418
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27402: LD_VAR 0 4
27406: PUSH
27407: LD_INT 2
27409: ARRAY
27410: PPUSH
27411: LD_STRING D6c-Sol2-1
27413: PPUSH
27414: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27418: LD_VAR 0 11
27422: PPUSH
27423: LD_STRING D6c-Sol3-2
27425: PPUSH
27426: CALL_OW 88
// if IsInUnit ( JMM ) then
27430: LD_EXP 40
27434: PPUSH
27435: CALL_OW 310
27439: IFFALSE 27457
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27441: LD_EXP 40
27445: PPUSH
27446: CALL_OW 310
27450: PPUSH
27451: CALL_OW 87
27455: GO 27466
// CenterNowOnUnits ( JMM ) ;
27457: LD_EXP 40
27461: PPUSH
27462: CALL_OW 87
// dwait ( 0 0$2 ) ;
27466: LD_INT 70
27468: PPUSH
27469: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27473: LD_EXP 40
27477: PPUSH
27478: LD_STRING D6c-JMM-2
27480: PPUSH
27481: CALL_OW 88
// DialogueOff ;
27485: CALL_OW 7
// Video ( false ) ;
27489: LD_INT 0
27491: PPUSH
27492: CALL 107254 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27496: LD_INT 22
27498: PUSH
27499: LD_INT 4
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PPUSH
27506: CALL_OW 69
27510: PPUSH
27511: LD_INT 1
27513: PPUSH
27514: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27518: LD_INT 4
27520: PPUSH
27521: LD_INT 4
27523: PPUSH
27524: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27528: LD_ADDR_VAR 0 1
27532: PUSH
27533: LD_INT 4
27535: PPUSH
27536: LD_INT 1
27538: PPUSH
27539: LD_INT 2
27541: PPUSH
27542: CALL 69654 0 3
27546: PUSH
27547: FOR_IN
27548: IFFALSE 27585
// if GetTech ( i , 1 ) <> state_researched then
27550: LD_VAR 0 1
27554: PPUSH
27555: LD_INT 1
27557: PPUSH
27558: CALL_OW 321
27562: PUSH
27563: LD_INT 2
27565: NONEQUAL
27566: IFFALSE 27583
// SetTech ( i , 1 , state_researched ) ;
27568: LD_VAR 0 1
27572: PPUSH
27573: LD_INT 1
27575: PPUSH
27576: LD_INT 2
27578: PPUSH
27579: CALL_OW 322
27583: GO 27547
27585: POP
27586: POP
// missionStage := 6 ;
27587: LD_ADDR_EXP 15
27591: PUSH
27592: LD_INT 6
27594: ST_TO_ADDR
// activeAttacks := true ;
27595: LD_ADDR_EXP 16
27599: PUSH
27600: LD_INT 1
27602: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27603: LD_STRING M2
27605: PPUSH
27606: CALL_OW 337
// SaveForQuickRestart ;
27610: CALL_OW 22
// wait ( 0 0$40 ) ;
27614: LD_INT 1400
27616: PPUSH
27617: CALL_OW 67
// DialogueOn ;
27621: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27625: LD_EXP 66
27629: PPUSH
27630: LD_STRING D7-Friend-1
27632: PPUSH
27633: CALL 111347 0 2
// Say ( JMM , D7-JMM-1 ) ;
27637: LD_EXP 40
27641: PPUSH
27642: LD_STRING D7-JMM-1
27644: PPUSH
27645: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27649: LD_EXP 66
27653: PPUSH
27654: LD_STRING D7-Friend-2
27656: PPUSH
27657: CALL 111347 0 2
// Say ( JMM , D7-JMM-2 ) ;
27661: LD_EXP 40
27665: PPUSH
27666: LD_STRING D7-JMM-2
27668: PPUSH
27669: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27673: LD_EXP 66
27677: PPUSH
27678: LD_STRING D7-Friend-3
27680: PPUSH
27681: CALL 111347 0 2
// Say ( JMM , D7-JMM-3 ) ;
27685: LD_EXP 40
27689: PPUSH
27690: LD_STRING D7-JMM-3
27692: PPUSH
27693: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27697: LD_EXP 66
27701: PPUSH
27702: LD_STRING D7-Friend-4
27704: PPUSH
27705: CALL 111347 0 2
// Say ( JMM , D7-JMM-4 ) ;
27709: LD_EXP 40
27713: PPUSH
27714: LD_STRING D7-JMM-4
27716: PPUSH
27717: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27721: LD_EXP 66
27725: PPUSH
27726: LD_STRING D7-Friend-5
27728: PPUSH
27729: CALL 111347 0 2
// Say ( JMM , D7-JMM-5 ) ;
27733: LD_EXP 40
27737: PPUSH
27738: LD_STRING D7-JMM-5
27740: PPUSH
27741: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27745: LD_EXP 66
27749: PPUSH
27750: LD_STRING D7-Friend-6
27752: PPUSH
27753: CALL 111347 0 2
// Say ( JMM , D7-JMM-6 ) ;
27757: LD_EXP 40
27761: PPUSH
27762: LD_STRING D7-JMM-6
27764: PPUSH
27765: CALL_OW 88
// DialogueOff ;
27769: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27773: LD_STRING Mlegion
27775: PPUSH
27776: CALL_OW 337
// skirmish := true ;
27780: LD_ADDR_EXP 100
27784: PUSH
27785: LD_INT 1
27787: ST_TO_ADDR
// RebuildKozlovFactory ;
27788: CALL 5313 0 0
// end ;
27792: PPOPN 13
27794: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27795: LD_EXP 20
27799: PUSH
27800: LD_EXP 61
27804: PPUSH
27805: CALL_OW 300
27809: AND
27810: IFFALSE 27852
27812: GO 27814
27814: DISABLE
// begin enable ;
27815: ENABLE
// if IsInUnit ( Powell ) then
27816: LD_EXP 61
27820: PPUSH
27821: CALL_OW 310
27825: IFFALSE 27843
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27827: LD_EXP 61
27831: PPUSH
27832: CALL_OW 310
27836: PPUSH
27837: CALL_OW 85
27841: GO 27852
// CenterOnUnits ( Powell ) ;
27843: LD_EXP 61
27847: PPUSH
27848: CALL_OW 85
// end ;
27852: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27853: LD_INT 22
27855: PUSH
27856: LD_INT 8
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 34
27865: PUSH
27866: LD_INT 48
27868: PUSH
27869: EMPTY
27870: LIST
27871: LIST
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PPUSH
27877: CALL_OW 69
27881: IFFALSE 28155
27883: GO 27885
27885: DISABLE
27886: LD_INT 0
27888: PPUSH
27889: PPUSH
// begin if missionStage < 9 then
27890: LD_EXP 15
27894: PUSH
27895: LD_INT 9
27897: LESS
27898: IFFALSE 27908
// missionStage := 9 ;
27900: LD_ADDR_EXP 15
27904: PUSH
27905: LD_INT 9
27907: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27908: LD_ADDR_VAR 0 1
27912: PUSH
27913: LD_INT 22
27915: PUSH
27916: LD_INT 8
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 34
27925: PUSH
27926: LD_INT 48
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PPUSH
27937: CALL_OW 69
27941: PUSH
27942: LD_INT 1
27944: ARRAY
27945: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27946: LD_INT 175
27948: PPUSH
27949: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27953: LD_EXP 12
27957: PUSH
27958: LD_EXP 3
27962: PUSH
27963: LD_INT 0
27965: PUSH
27966: LD_INT 2
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: IN
27973: OR
27974: IFFALSE 27997
// target := [ 68 , 108 , 1 ] else
27976: LD_ADDR_VAR 0 2
27980: PUSH
27981: LD_INT 68
27983: PUSH
27984: LD_INT 108
27986: PUSH
27987: LD_INT 1
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: LIST
27994: ST_TO_ADDR
27995: GO 28016
// target := [ 181 , 88 , 2 ] ;
27997: LD_ADDR_VAR 0 2
28001: PUSH
28002: LD_INT 181
28004: PUSH
28005: LD_INT 88
28007: PUSH
28008: LD_INT 2
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: LIST
28015: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28016: LD_VAR 0 1
28020: PPUSH
28021: LD_VAR 0 2
28025: PUSH
28026: LD_INT 1
28028: ARRAY
28029: PPUSH
28030: LD_VAR 0 2
28034: PUSH
28035: LD_INT 2
28037: ARRAY
28038: PPUSH
28039: CALL_OW 176
// if target [ 3 ] = 1 then
28043: LD_VAR 0 2
28047: PUSH
28048: LD_INT 3
28050: ARRAY
28051: PUSH
28052: LD_INT 1
28054: EQUAL
28055: IFFALSE 28071
// SayRadio ( Kurt , D12-Kurt-1 ) else
28057: LD_EXP 64
28061: PPUSH
28062: LD_STRING D12-Kurt-1
28064: PPUSH
28065: CALL_OW 94
28069: GO 28095
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28071: LD_EXP 64
28075: PPUSH
28076: LD_STRING D12a-Kurt-1
28078: PPUSH
28079: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28083: LD_EXP 79
28087: PPUSH
28088: LD_STRING D12a-Roth-1
28090: PPUSH
28091: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28095: LD_INT 350
28097: PPUSH
28098: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28102: LD_VAR 0 1
28106: PPUSH
28107: LD_INT 22
28109: PUSH
28110: LD_INT 8
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 23
28119: PUSH
28120: LD_INT 2
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 30
28129: PUSH
28130: LD_INT 3
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: LIST
28141: PPUSH
28142: CALL_OW 69
28146: PUSH
28147: LD_INT 1
28149: ARRAY
28150: PPUSH
28151: CALL_OW 228
// end ;
28155: PPOPN 2
28157: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28158: LD_EXP 64
28162: PPUSH
28163: CALL_OW 256
28167: PUSH
28168: LD_INT 999
28170: LESS
28171: PUSH
28172: LD_INT 22
28174: PUSH
28175: LD_INT 8
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 21
28184: PUSH
28185: LD_INT 1
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 23
28194: PUSH
28195: LD_INT 2
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: LIST
28206: PPUSH
28207: CALL_OW 69
28211: PUSH
28212: LD_INT 9
28214: PUSH
28215: LD_INT 8
28217: PUSH
28218: LD_INT 7
28220: PUSH
28221: LD_INT 6
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: PUSH
28230: LD_OWVAR 67
28234: ARRAY
28235: LESSEQUAL
28236: OR
28237: PUSH
28238: LD_INT 22
28240: PUSH
28241: LD_INT 8
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 34
28250: PUSH
28251: LD_INT 48
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PPUSH
28262: CALL_OW 69
28266: NOT
28267: AND
28268: PUSH
28269: LD_EXP 64
28273: PPUSH
28274: CALL_OW 302
28278: AND
28279: PUSH
28280: LD_INT 5
28282: PPUSH
28283: LD_INT 22
28285: PUSH
28286: LD_INT 1
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PPUSH
28293: CALL_OW 70
28297: AND
28298: IFFALSE 29060
28300: GO 28302
28302: DISABLE
28303: LD_INT 0
28305: PPUSH
28306: PPUSH
28307: PPUSH
// begin legionDestroyed := true ;
28308: LD_ADDR_EXP 22
28312: PUSH
28313: LD_INT 1
28315: ST_TO_ADDR
// DialogueOn ;
28316: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28320: LD_EXP 40
28324: PPUSH
28325: LD_STRING D13-JMM-1
28327: PPUSH
28328: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28332: LD_EXP 64
28336: PPUSH
28337: LD_STRING D13-Kurt-1
28339: PPUSH
28340: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28344: LD_EXP 40
28348: PPUSH
28349: LD_STRING D13-JMM-2
28351: PPUSH
28352: CALL_OW 88
// if FakeInfo then
28356: LD_EXP 12
28360: IFFALSE 28380
// begin Say ( Kurt , D13-Kurt-2 ) ;
28362: LD_EXP 64
28366: PPUSH
28367: LD_STRING D13-Kurt-2
28369: PPUSH
28370: CALL_OW 88
// DialogueOff ;
28374: CALL_OW 7
// exit ;
28378: GO 29060
// end ; if not KurtStatus then
28380: LD_EXP 3
28384: NOT
28385: IFFALSE 28401
// Say ( Kurt , D13-Kurt-2b ) else
28387: LD_EXP 64
28391: PPUSH
28392: LD_STRING D13-Kurt-2b
28394: PPUSH
28395: CALL_OW 88
28399: GO 28413
// Say ( Kurt , D13-Kurt-2a ) ;
28401: LD_EXP 64
28405: PPUSH
28406: LD_STRING D13-Kurt-2a
28408: PPUSH
28409: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28413: LD_EXP 40
28417: PPUSH
28418: LD_STRING D13-JMM-3
28420: PPUSH
28421: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28425: LD_EXP 64
28429: PPUSH
28430: LD_STRING D13-Kurt-3
28432: PPUSH
28433: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28437: LD_EXP 40
28441: PPUSH
28442: LD_STRING D13-JMM-4
28444: PPUSH
28445: CALL_OW 88
// DialogueOff ;
28449: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28453: LD_STRING MlegionOut
28455: PPUSH
28456: CALL_OW 337
// MC_Kill ( 3 ) ;
28460: LD_INT 3
28462: PPUSH
28463: CALL 39140 0 1
// KillUnit ( Kozlov ) ;
28467: LD_EXP 65
28471: PPUSH
28472: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28476: LD_ADDR_VAR 0 1
28480: PUSH
28481: LD_INT 22
28483: PUSH
28484: LD_INT 8
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 23
28493: PUSH
28494: LD_INT 3
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 3
28503: PUSH
28504: LD_INT 21
28506: PUSH
28507: LD_INT 33
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: LIST
28522: PPUSH
28523: CALL_OW 69
28527: PUSH
28528: FOR_IN
28529: IFFALSE 28542
// KillUnit ( i ) ;
28531: LD_VAR 0 1
28535: PPUSH
28536: CALL_OW 66
28540: GO 28528
28542: POP
28543: POP
// ChangeSideFog ( 8 , 1 ) ;
28544: LD_INT 8
28546: PPUSH
28547: LD_INT 1
28549: PPUSH
28550: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28554: LD_ADDR_VAR 0 2
28558: PUSH
28559: LD_INT 22
28561: PUSH
28562: LD_INT 8
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 21
28571: PUSH
28572: LD_INT 1
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: CALL_OW 69
28587: PUSH
28588: LD_EXP 65
28592: PUSH
28593: LD_EXP 64
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: DIFF
28602: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28603: LD_VAR 0 2
28607: PUSH
28608: LD_INT 6
28610: PUSH
28611: LD_INT 5
28613: PUSH
28614: LD_INT 4
28616: PUSH
28617: LD_INT 3
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: PUSH
28626: LD_OWVAR 67
28630: ARRAY
28631: GREATEREQUAL
28632: IFFALSE 28784
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28634: LD_ADDR_VAR 0 3
28638: PUSH
28639: LD_INT 6
28641: PUSH
28642: LD_INT 5
28644: PUSH
28645: LD_INT 4
28647: PUSH
28648: LD_INT 3
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: PUSH
28657: LD_OWVAR 67
28661: ARRAY
28662: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28663: LD_ADDR_VAR 0 1
28667: PUSH
28668: DOUBLE
28669: LD_VAR 0 2
28673: PUSH
28674: LD_VAR 0 3
28678: PUSH
28679: LD_INT 1
28681: PLUS
28682: MINUS
28683: INC
28684: ST_TO_ADDR
28685: LD_INT 1
28687: PUSH
28688: FOR_DOWNTO
28689: IFFALSE 28780
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28691: LD_ADDR_EXP 38
28695: PUSH
28696: LD_EXP 38
28700: PUSH
28701: LD_VAR 0 2
28705: PUSH
28706: LD_VAR 0 1
28710: ARRAY
28711: ADD
28712: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28713: LD_VAR 0 2
28717: PUSH
28718: LD_VAR 0 1
28722: ARRAY
28723: PPUSH
28724: CALL_OW 310
28728: IFFALSE 28745
// ComExit ( tmp [ i ] ) ;
28730: LD_VAR 0 2
28734: PUSH
28735: LD_VAR 0 1
28739: ARRAY
28740: PPUSH
28741: CALL 107680 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28745: LD_VAR 0 2
28749: PUSH
28750: LD_VAR 0 1
28754: ARRAY
28755: PPUSH
28756: LD_INT 34
28758: PUSH
28759: LD_INT 0
28761: PPUSH
28762: LD_INT 6
28764: PPUSH
28765: CALL_OW 12
28769: PLUS
28770: PPUSH
28771: LD_INT 1
28773: PPUSH
28774: CALL_OW 171
// end ;
28778: GO 28688
28780: POP
28781: POP
// end else
28782: GO 28794
// x := tmp ;
28784: LD_ADDR_VAR 0 3
28788: PUSH
28789: LD_VAR 0 2
28793: ST_TO_ADDR
// for i := tmp downto tmp - x do
28794: LD_ADDR_VAR 0 1
28798: PUSH
28799: DOUBLE
28800: LD_VAR 0 2
28804: INC
28805: ST_TO_ADDR
28806: LD_VAR 0 2
28810: PUSH
28811: LD_VAR 0 3
28815: MINUS
28816: PUSH
28817: FOR_DOWNTO
28818: IFFALSE 28890
// begin if IsInUnit ( tmp [ i ] ) then
28820: LD_VAR 0 2
28824: PUSH
28825: LD_VAR 0 1
28829: ARRAY
28830: PPUSH
28831: CALL_OW 310
28835: IFFALSE 28852
// ComExit ( tmp [ i ] ) ;
28837: LD_VAR 0 2
28841: PUSH
28842: LD_VAR 0 1
28846: ARRAY
28847: PPUSH
28848: CALL 107680 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28852: LD_VAR 0 2
28856: PUSH
28857: LD_VAR 0 1
28861: ARRAY
28862: PPUSH
28863: LD_INT 1
28865: PPUSH
28866: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28870: LD_VAR 0 2
28874: PUSH
28875: LD_VAR 0 1
28879: ARRAY
28880: PPUSH
28881: LD_INT 1000
28883: PPUSH
28884: CALL_OW 234
// end ;
28888: GO 28817
28890: POP
28891: POP
// wait ( 0 0$0.3 ) ;
28892: LD_INT 10
28894: PPUSH
28895: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28899: LD_ADDR_VAR 0 1
28903: PUSH
28904: LD_INT 22
28906: PUSH
28907: LD_INT 8
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 21
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PPUSH
28928: CALL_OW 69
28932: PUSH
28933: FOR_IN
28934: IFFALSE 28947
// KillUnit ( i ) ;
28936: LD_VAR 0 1
28940: PPUSH
28941: CALL_OW 66
28945: GO 28933
28947: POP
28948: POP
// SetSide ( Kurt , 1 ) ;
28949: LD_EXP 64
28953: PPUSH
28954: LD_INT 1
28956: PPUSH
28957: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28961: LD_INT 22
28963: PUSH
28964: LD_INT 8
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 21
28973: PUSH
28974: LD_INT 3
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PPUSH
28985: CALL_OW 69
28989: PPUSH
28990: LD_INT 1
28992: PPUSH
28993: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28997: LD_INT 8
28999: PPUSH
29000: LD_INT 1
29002: PPUSH
29003: LD_INT 1
29005: PPUSH
29006: LD_INT 1
29008: PPUSH
29009: CALL_OW 80
// wait ( 1 1$20 ) ;
29013: LD_INT 2800
29015: PPUSH
29016: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29020: LD_EXP 66
29024: PPUSH
29025: LD_INT 37
29027: PPUSH
29028: LD_INT 1
29030: PPUSH
29031: LD_INT 0
29033: PPUSH
29034: CALL_OW 48
// wait ( 0 0$1 ) ;
29038: LD_INT 35
29040: PPUSH
29041: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29045: LD_EXP 66
29049: PPUSH
29050: LD_INT 60
29052: PPUSH
29053: LD_INT 95
29055: PPUSH
29056: CALL_OW 111
// end ;
29060: PPOPN 3
29062: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29063: LD_EXP 22
29067: NOT
29068: PUSH
29069: LD_INT 22
29071: PUSH
29072: LD_INT 8
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 21
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PPUSH
29093: CALL_OW 69
29097: PUSH
29098: LD_INT 0
29100: EQUAL
29101: AND
29102: IFFALSE 29122
29104: GO 29106
29106: DISABLE
// begin legionDestroyed := true ;
29107: LD_ADDR_EXP 22
29111: PUSH
29112: LD_INT 1
29114: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29115: LD_STRING MlegionOut
29117: PPUSH
29118: CALL_OW 337
// end ;
29122: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29123: LD_EXP 38
29127: IFFALSE 29202
29129: GO 29131
29131: DISABLE
29132: LD_INT 0
29134: PPUSH
// begin enable ;
29135: ENABLE
// for i in legionEscapeUnits do
29136: LD_ADDR_VAR 0 1
29140: PUSH
29141: LD_EXP 38
29145: PUSH
29146: FOR_IN
29147: IFFALSE 29200
// begin if IsInArea ( i , legionEscapeArea ) then
29149: LD_VAR 0 1
29153: PPUSH
29154: LD_INT 31
29156: PPUSH
29157: CALL_OW 308
29161: IFFALSE 29174
// RemoveUnit ( i ) else
29163: LD_VAR 0 1
29167: PPUSH
29168: CALL_OW 64
29172: GO 29198
// if not HasTask ( i ) then
29174: LD_VAR 0 1
29178: PPUSH
29179: CALL_OW 314
29183: NOT
29184: IFFALSE 29198
// ComMoveToArea ( i , legionEscapeArea ) ;
29186: LD_VAR 0 1
29190: PPUSH
29191: LD_INT 31
29193: PPUSH
29194: CALL_OW 113
// end ;
29198: GO 29146
29200: POP
29201: POP
// end ;
29202: PPOPN 1
29204: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29205: LD_INT 1
29207: PPUSH
29208: LD_EXP 66
29212: PPUSH
29213: CALL_OW 292
29217: IFFALSE 29515
29219: GO 29221
29221: DISABLE
29222: LD_INT 0
29224: PPUSH
// begin wait ( 0 0$2 ) ;
29225: LD_INT 70
29227: PPUSH
29228: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29232: LD_EXP 66
29236: PPUSH
29237: CALL_OW 87
// DialogueOn ;
29241: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29245: LD_EXP 40
29249: PPUSH
29250: LD_STRING D14-JMM-1
29252: PPUSH
29253: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29257: LD_EXP 66
29261: PPUSH
29262: LD_STRING D14-Friend-1
29264: PPUSH
29265: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29269: LD_EXP 40
29273: PPUSH
29274: LD_STRING D14-JMM-2
29276: PPUSH
29277: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29281: LD_EXP 66
29285: PPUSH
29286: LD_STRING D14-Friend-2
29288: PPUSH
29289: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29293: LD_EXP 40
29297: PPUSH
29298: LD_STRING D14-JMM-3
29300: PPUSH
29301: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29305: LD_EXP 66
29309: PPUSH
29310: LD_STRING D14-Friend-3
29312: PPUSH
29313: CALL_OW 88
// DialogueOff ;
29317: CALL_OW 7
// dec := Query ( Q14 ) ;
29321: LD_ADDR_VAR 0 1
29325: PUSH
29326: LD_STRING Q14
29328: PPUSH
29329: CALL_OW 97
29333: ST_TO_ADDR
// if dec = 1 then
29334: LD_VAR 0 1
29338: PUSH
29339: LD_INT 1
29341: EQUAL
29342: IFFALSE 29376
// begin DialogueOn ;
29344: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29348: LD_EXP 40
29352: PPUSH
29353: LD_STRING D14a-JMM-1
29355: PPUSH
29356: CALL_OW 88
// DialogueOff ;
29360: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29364: LD_EXP 66
29368: PPUSH
29369: LD_INT 1
29371: PPUSH
29372: CALL_OW 235
// end ; if dec = 2 then
29376: LD_VAR 0 1
29380: PUSH
29381: LD_INT 2
29383: EQUAL
29384: IFFALSE 29437
// begin DialogueOn ;
29386: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29390: LD_EXP 40
29394: PPUSH
29395: LD_STRING D14b-JMM-1
29397: PPUSH
29398: CALL_OW 88
// DialogueOff ;
29402: CALL_OW 7
// wait ( 0 0$1 ) ;
29406: LD_INT 35
29408: PPUSH
29409: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29413: LD_EXP 66
29417: PPUSH
29418: LD_INT 9
29420: PPUSH
29421: LD_INT 2
29423: PPUSH
29424: CALL_OW 111
// AddComHold ( Friend ) ;
29428: LD_EXP 66
29432: PPUSH
29433: CALL_OW 200
// end ; if dec = 3 then
29437: LD_VAR 0 1
29441: PUSH
29442: LD_INT 3
29444: EQUAL
29445: IFFALSE 29515
// begin DialogueOn ;
29447: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29451: LD_EXP 40
29455: PPUSH
29456: LD_STRING D14c-JMM-1
29458: PPUSH
29459: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29463: LD_EXP 66
29467: PPUSH
29468: LD_STRING D14c-Friend-1
29470: PPUSH
29471: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29475: LD_EXP 40
29479: PPUSH
29480: LD_STRING D14c-JMM-2
29482: PPUSH
29483: CALL_OW 88
// DialogueOff ;
29487: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29491: LD_EXP 66
29495: PPUSH
29496: LD_INT 9
29498: PPUSH
29499: LD_INT 2
29501: PPUSH
29502: CALL_OW 111
// AddComHold ( Friend ) ;
29506: LD_EXP 66
29510: PPUSH
29511: CALL_OW 200
// end ; end ;
29515: PPOPN 1
29517: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29518: LD_INT 9
29520: PPUSH
29521: LD_INT 2
29523: PPUSH
29524: CALL_OW 428
29528: PUSH
29529: LD_EXP 66
29533: EQUAL
29534: PUSH
29535: LD_EXP 66
29539: PPUSH
29540: CALL_OW 255
29544: PUSH
29545: LD_INT 8
29547: EQUAL
29548: AND
29549: IFFALSE 29563
29551: GO 29553
29553: DISABLE
// RemoveUnit ( Friend ) ;
29554: LD_EXP 66
29558: PPUSH
29559: CALL_OW 64
29563: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29564: LD_EXP 14
29568: PUSH
29569: LD_INT 31500
29571: GREATEREQUAL
29572: PUSH
29573: LD_EXP 7
29577: AND
29578: PUSH
29579: LD_EXP 2
29583: AND
29584: IFFALSE 30030
29586: GO 29588
29588: DISABLE
29589: LD_INT 0
29591: PPUSH
29592: PPUSH
29593: PPUSH
// begin missionStage := 7 ;
29594: LD_ADDR_EXP 15
29598: PUSH
29599: LD_INT 7
29601: ST_TO_ADDR
// for i := 1 to 5 do
29602: LD_ADDR_VAR 0 1
29606: PUSH
29607: DOUBLE
29608: LD_INT 1
29610: DEC
29611: ST_TO_ADDR
29612: LD_INT 5
29614: PUSH
29615: FOR_TO
29616: IFFALSE 29728
// begin uc_side = 1 ;
29618: LD_ADDR_OWVAR 20
29622: PUSH
29623: LD_INT 1
29625: ST_TO_ADDR
// uc_nation = 1 ;
29626: LD_ADDR_OWVAR 21
29630: PUSH
29631: LD_INT 1
29633: ST_TO_ADDR
// vc_engine = 3 ;
29634: LD_ADDR_OWVAR 39
29638: PUSH
29639: LD_INT 3
29641: ST_TO_ADDR
// vc_control = 3 ;
29642: LD_ADDR_OWVAR 38
29646: PUSH
29647: LD_INT 3
29649: ST_TO_ADDR
// vc_chassis = 3 ;
29650: LD_ADDR_OWVAR 37
29654: PUSH
29655: LD_INT 3
29657: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29658: LD_ADDR_OWVAR 40
29662: PUSH
29663: LD_INT 5
29665: PUSH
29666: LD_INT 9
29668: PUSH
29669: LD_INT 7
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: PPUSH
29680: LD_INT 3
29682: PPUSH
29683: CALL_OW 12
29687: ARRAY
29688: ST_TO_ADDR
// veh = CreateVehicle ;
29689: LD_ADDR_VAR 0 2
29693: PUSH
29694: CALL_OW 45
29698: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29699: LD_VAR 0 2
29703: PPUSH
29704: LD_INT 1
29706: PPUSH
29707: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29711: LD_VAR 0 2
29715: PPUSH
29716: LD_INT 19
29718: PPUSH
29719: LD_INT 0
29721: PPUSH
29722: CALL_OW 49
// end ;
29726: GO 29615
29728: POP
29729: POP
// uc_side = 1 ;
29730: LD_ADDR_OWVAR 20
29734: PUSH
29735: LD_INT 1
29737: ST_TO_ADDR
// uc_nation = 1 ;
29738: LD_ADDR_OWVAR 21
29742: PUSH
29743: LD_INT 1
29745: ST_TO_ADDR
// vc_engine = 3 ;
29746: LD_ADDR_OWVAR 39
29750: PUSH
29751: LD_INT 3
29753: ST_TO_ADDR
// vc_control = 1 ;
29754: LD_ADDR_OWVAR 38
29758: PUSH
29759: LD_INT 1
29761: ST_TO_ADDR
// vc_chassis = 3 ;
29762: LD_ADDR_OWVAR 37
29766: PUSH
29767: LD_INT 3
29769: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29770: LD_ADDR_OWVAR 40
29774: PUSH
29775: LD_INT 5
29777: PUSH
29778: LD_INT 9
29780: PUSH
29781: LD_INT 7
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: LIST
29788: PUSH
29789: LD_INT 1
29791: PPUSH
29792: LD_INT 3
29794: PPUSH
29795: CALL_OW 12
29799: ARRAY
29800: ST_TO_ADDR
// vehG = CreateVehicle ;
29801: LD_ADDR_VAR 0 3
29805: PUSH
29806: CALL_OW 45
29810: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29811: LD_VAR 0 3
29815: PPUSH
29816: LD_INT 1
29818: PPUSH
29819: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29823: LD_VAR 0 3
29827: PPUSH
29828: LD_INT 19
29830: PPUSH
29831: LD_INT 0
29833: PPUSH
29834: CALL_OW 49
// if JMMGirl = 1 then
29838: LD_EXP 7
29842: PUSH
29843: LD_INT 1
29845: EQUAL
29846: IFFALSE 29902
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29848: LD_ADDR_EXP 41
29852: PUSH
29853: LD_STRING Joan
29855: PPUSH
29856: LD_INT 1
29858: PPUSH
29859: LD_STRING 14_
29861: PPUSH
29862: CALL 69591 0 3
29866: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29867: LD_EXP 41
29871: PPUSH
29872: LD_VAR 0 3
29876: PPUSH
29877: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29881: LD_VAR 0 3
29885: PPUSH
29886: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29890: LD_EXP 41
29894: PPUSH
29895: LD_STRING D10BW-Joan-1
29897: PPUSH
29898: CALL_OW 94
// end ; if JMMGirl = 2 then
29902: LD_EXP 7
29906: PUSH
29907: LD_INT 2
29909: EQUAL
29910: IFFALSE 29966
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29912: LD_ADDR_EXP 43
29916: PUSH
29917: LD_STRING Lisa
29919: PPUSH
29920: LD_INT 1
29922: PPUSH
29923: LD_STRING 14_
29925: PPUSH
29926: CALL 69591 0 3
29930: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29931: LD_EXP 43
29935: PPUSH
29936: LD_VAR 0 3
29940: PPUSH
29941: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29945: LD_VAR 0 3
29949: PPUSH
29950: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29954: LD_EXP 43
29958: PPUSH
29959: LD_STRING D10BW-Lisa-1
29961: PPUSH
29962: CALL_OW 94
// end ; if JMMGirl = 3 then
29966: LD_EXP 7
29970: PUSH
29971: LD_INT 3
29973: EQUAL
29974: IFFALSE 30030
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29976: LD_ADDR_EXP 55
29980: PUSH
29981: LD_STRING Connie
29983: PPUSH
29984: LD_INT 1
29986: PPUSH
29987: LD_STRING 14_
29989: PPUSH
29990: CALL 69591 0 3
29994: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29995: LD_EXP 55
29999: PPUSH
30000: LD_VAR 0 3
30004: PPUSH
30005: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30009: LD_VAR 0 3
30013: PPUSH
30014: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30018: LD_EXP 55
30022: PPUSH
30023: LD_STRING D10BW-Con-1
30025: PPUSH
30026: CALL_OW 94
// end ; end ;
30030: PPOPN 3
30032: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30033: LD_EXP 14
30037: PUSH
30038: LD_INT 94500
30040: GREATEREQUAL
30041: IFFALSE 30453
30043: GO 30045
30045: DISABLE
30046: LD_INT 0
30048: PPUSH
30049: PPUSH
30050: PPUSH
// begin tmp := PrepareStevensSquad ;
30051: LD_ADDR_VAR 0 3
30055: PUSH
30056: CALL 2323 0 0
30060: ST_TO_ADDR
// if not tmp then
30061: LD_VAR 0 3
30065: NOT
30066: IFFALSE 30070
// exit ;
30068: GO 30453
// uc_side := 1 ;
30070: LD_ADDR_OWVAR 20
30074: PUSH
30075: LD_INT 1
30077: ST_TO_ADDR
// uc_nation := 1 ;
30078: LD_ADDR_OWVAR 21
30082: PUSH
30083: LD_INT 1
30085: ST_TO_ADDR
// for i in tmp do
30086: LD_ADDR_VAR 0 1
30090: PUSH
30091: LD_VAR 0 3
30095: PUSH
30096: FOR_IN
30097: IFFALSE 30194
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30099: LD_INT 3
30101: PPUSH
30102: LD_INT 3
30104: PPUSH
30105: LD_INT 1
30107: PPUSH
30108: LD_INT 5
30110: PUSH
30111: LD_INT 9
30113: PUSH
30114: LD_INT 7
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 1
30124: PPUSH
30125: LD_INT 3
30127: PPUSH
30128: CALL_OW 12
30132: ARRAY
30133: PPUSH
30134: LD_INT 40
30136: PPUSH
30137: CALL 74431 0 5
// veh := CreateVehicle ;
30141: LD_ADDR_VAR 0 2
30145: PUSH
30146: CALL_OW 45
30150: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30151: LD_VAR 0 2
30155: PPUSH
30156: LD_INT 1
30158: PPUSH
30159: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30163: LD_VAR 0 2
30167: PPUSH
30168: LD_INT 19
30170: PPUSH
30171: LD_INT 0
30173: PPUSH
30174: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30178: LD_VAR 0 1
30182: PPUSH
30183: LD_VAR 0 2
30187: PPUSH
30188: CALL_OW 52
// end ;
30192: GO 30096
30194: POP
30195: POP
// missionStage := 8 ;
30196: LD_ADDR_EXP 15
30200: PUSH
30201: LD_INT 8
30203: ST_TO_ADDR
// DialogueOn ;
30204: CALL_OW 6
// if Stevens then
30208: LD_EXP 42
30212: IFFALSE 30326
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30214: LD_EXP 42
30218: PPUSH
30219: CALL_OW 310
30223: PPUSH
30224: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30228: LD_EXP 42
30232: PPUSH
30233: LD_STRING D8-Huck-1
30235: PPUSH
30236: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30240: LD_EXP 40
30244: PPUSH
30245: LD_STRING D8-JMM-1
30247: PPUSH
30248: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30252: LD_EXP 42
30256: PPUSH
30257: LD_STRING D8-Huck-2
30259: PPUSH
30260: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30264: LD_EXP 40
30268: PPUSH
30269: LD_STRING D8-JMM-2
30271: PPUSH
30272: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30276: LD_EXP 42
30280: PPUSH
30281: LD_STRING D8-Huck-3
30283: PPUSH
30284: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30288: LD_EXP 40
30292: PPUSH
30293: LD_STRING D8-JMM-3
30295: PPUSH
30296: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30300: LD_EXP 42
30304: PPUSH
30305: LD_STRING D8-Huck-4
30307: PPUSH
30308: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30312: LD_EXP 40
30316: PPUSH
30317: LD_STRING D8-JMM-4
30319: PPUSH
30320: CALL_OW 88
// end else
30324: GO 30436
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30326: LD_EXP 56
30330: PPUSH
30331: CALL_OW 310
30335: PPUSH
30336: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30340: LD_EXP 56
30344: PPUSH
30345: LD_STRING D8-Huck-1
30347: PPUSH
30348: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30352: LD_EXP 40
30356: PPUSH
30357: LD_STRING D8-JMM-1a
30359: PPUSH
30360: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30364: LD_EXP 56
30368: PPUSH
30369: LD_STRING D8-Huck-2
30371: PPUSH
30372: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30376: LD_EXP 40
30380: PPUSH
30381: LD_STRING D8-JMM-2
30383: PPUSH
30384: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30388: LD_EXP 56
30392: PPUSH
30393: LD_STRING D8-Huck-3
30395: PPUSH
30396: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30400: LD_EXP 40
30404: PPUSH
30405: LD_STRING D8-JMM-3
30407: PPUSH
30408: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30412: LD_EXP 56
30416: PPUSH
30417: LD_STRING D8-Huck-4
30419: PPUSH
30420: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30424: LD_EXP 40
30428: PPUSH
30429: LD_STRING D8-JMM-4
30431: PPUSH
30432: CALL_OW 88
// end ; DialogueOff ;
30436: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30440: LD_INT 25
30442: PPUSH
30443: LD_INT 1
30445: PPUSH
30446: LD_INT 1
30448: PPUSH
30449: CALL_OW 322
// end ;
30453: PPOPN 3
30455: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30456: LD_EXP 75
30460: PPUSH
30461: CALL_OW 302
30465: PUSH
30466: LD_INT 1
30468: PPUSH
30469: LD_EXP 75
30473: PPUSH
30474: CALL_OW 292
30478: AND
30479: IFFALSE 30730
30481: GO 30483
30483: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30484: LD_EXP 75
30488: PPUSH
30489: CALL_OW 87
// DialogueOn ;
30493: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30497: LD_EXP 40
30501: PPUSH
30502: LD_STRING D10nB-JMM-1
30504: PPUSH
30505: CALL_OW 88
// if BurlakStatus = 1 then
30509: LD_EXP 9
30513: PUSH
30514: LD_INT 1
30516: EQUAL
30517: IFFALSE 30531
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30519: LD_EXP 74
30523: PPUSH
30524: LD_STRING D10nB-Vse-1a
30526: PPUSH
30527: CALL_OW 94
// end ; if BurlakStatus = 0 then
30531: LD_EXP 9
30535: PUSH
30536: LD_INT 0
30538: EQUAL
30539: IFFALSE 30553
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30541: LD_EXP 74
30545: PPUSH
30546: LD_STRING D10nB-Vse-1
30548: PPUSH
30549: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30553: LD_EXP 40
30557: PPUSH
30558: LD_STRING D10nB-JMM-2
30560: PPUSH
30561: CALL_OW 88
// if KappaStatus then
30565: LD_EXP 2
30569: IFFALSE 30583
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30571: LD_EXP 74
30575: PPUSH
30576: LD_STRING D10nB-Vse-5a
30578: PPUSH
30579: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30583: LD_EXP 2
30587: NOT
30588: PUSH
30589: LD_EXP 6
30593: PUSH
30594: LD_INT 0
30596: EQUAL
30597: AND
30598: IFFALSE 30726
// begin if JMMGirl = 1 then
30600: LD_EXP 7
30604: PUSH
30605: LD_INT 1
30607: EQUAL
30608: IFFALSE 30658
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30610: LD_EXP 74
30614: PPUSH
30615: LD_STRING D10nB-Vse-2
30617: PPUSH
30618: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30622: LD_EXP 40
30626: PPUSH
30627: LD_STRING D10nB-JMM-3
30629: PPUSH
30630: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30634: LD_EXP 74
30638: PPUSH
30639: LD_STRING D10nB-Vse-3
30641: PPUSH
30642: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30646: LD_EXP 40
30650: PPUSH
30651: LD_STRING D10nB-JMM-4
30653: PPUSH
30654: CALL_OW 88
// end ; if JMMGirl = 2 then
30658: LD_EXP 7
30662: PUSH
30663: LD_INT 2
30665: EQUAL
30666: IFFALSE 30692
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30668: LD_EXP 74
30672: PPUSH
30673: LD_STRING D10nB-Vse-4
30675: PPUSH
30676: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30680: LD_EXP 40
30684: PPUSH
30685: LD_STRING D10nB-JMM-5
30687: PPUSH
30688: CALL_OW 88
// end ; if JMMGirl = 3 then
30692: LD_EXP 7
30696: PUSH
30697: LD_INT 3
30699: EQUAL
30700: IFFALSE 30726
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30702: LD_EXP 74
30706: PPUSH
30707: LD_STRING D10nB-Vse-5
30709: PPUSH
30710: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30714: LD_EXP 40
30718: PPUSH
30719: LD_STRING D10nB-JMM-6
30721: PPUSH
30722: CALL_OW 88
// end ; end ; DialogueOff ;
30726: CALL_OW 7
// end ;
30730: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30731: LD_EXP 14
30735: PUSH
30736: LD_INT 115500
30738: GREATEREQUAL
30739: PUSH
30740: LD_EXP 69
30744: PPUSH
30745: CALL_OW 302
30749: AND
30750: PUSH
30751: LD_INT 267
30753: PPUSH
30754: CALL_OW 302
30758: AND
30759: IFFALSE 31135
30761: GO 30763
30763: DISABLE
30764: LD_INT 0
30766: PPUSH
// begin missionStage := 10 ;
30767: LD_ADDR_EXP 15
30771: PUSH
30772: LD_INT 10
30774: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30775: LD_ADDR_VAR 0 1
30779: PUSH
30780: LD_INT 22
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 23
30792: PUSH
30793: LD_INT 1
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 26
30802: PUSH
30803: LD_INT 1
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 3
30812: PUSH
30813: LD_INT 25
30815: PUSH
30816: LD_INT 12
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 3
30829: PUSH
30830: LD_INT 25
30832: PUSH
30833: LD_INT 16
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: PPUSH
30851: CALL_OW 69
30855: PUSH
30856: LD_EXP 40
30860: PUSH
30861: LD_EXP 64
30865: PUSH
30866: LD_EXP 42
30870: PUSH
30871: LD_EXP 56
30875: PUSH
30876: LD_EXP 43
30880: PUSH
30881: LD_EXP 44
30885: PUSH
30886: LD_EXP 45
30890: PUSH
30891: LD_EXP 46
30895: PUSH
30896: LD_EXP 47
30900: PUSH
30901: LD_EXP 48
30905: PUSH
30906: LD_EXP 49
30910: PUSH
30911: LD_EXP 50
30915: PUSH
30916: LD_EXP 51
30920: PUSH
30921: LD_EXP 52
30925: PUSH
30926: LD_EXP 53
30930: PUSH
30931: LD_EXP 54
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: DIFF
30954: ST_TO_ADDR
// if not tmp and Brown then
30955: LD_VAR 0 1
30959: NOT
30960: PUSH
30961: LD_EXP 48
30965: AND
30966: IFFALSE 30981
// tmp := [ Brown ] ;
30968: LD_ADDR_VAR 0 1
30972: PUSH
30973: LD_EXP 48
30977: PUSH
30978: EMPTY
30979: LIST
30980: ST_TO_ADDR
// DialogueOn ;
30981: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30985: LD_VAR 0 1
30989: PUSH
30990: LD_INT 1
30992: ARRAY
30993: PPUSH
30994: LD_STRING D11-Sol1-1
30996: PPUSH
30997: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31001: LD_EXP 68
31005: PPUSH
31006: LD_STRING D11-Pla-1
31008: PPUSH
31009: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31013: LD_EXP 69
31017: PPUSH
31018: LD_STRING D11-Kov-1
31020: PPUSH
31021: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31025: LD_EXP 68
31029: PPUSH
31030: LD_STRING D11-Pla-2
31032: PPUSH
31033: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31037: LD_VAR 0 1
31041: PUSH
31042: LD_INT 1
31044: ARRAY
31045: PPUSH
31046: LD_STRING D11-Sol1-2
31048: PPUSH
31049: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31053: LD_EXP 40
31057: PPUSH
31058: LD_STRING D11-JMM-2
31060: PPUSH
31061: CALL_OW 88
// DialogueOff ;
31065: CALL_OW 7
// allowBehemothConstruct := true ;
31069: LD_ADDR_EXP 25
31073: PUSH
31074: LD_INT 1
31076: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31077: LD_STRING M4
31079: PPUSH
31080: CALL_OW 337
// BuildBehemoths ;
31084: CALL 8396 0 0
// repeat wait ( 15 15$00 ) ;
31088: LD_INT 31500
31090: PPUSH
31091: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31095: LD_EXP 27
31099: IFFALSE 31103
// break ;
31101: GO 31135
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31103: LD_INT 267
31105: PPUSH
31106: CALL_OW 274
31110: PPUSH
31111: LD_INT 1
31113: PPUSH
31114: CALL_OW 275
31118: PUSH
31119: LD_INT 1000
31121: GREATEREQUAL
31122: IFFALSE 31128
// BuildBehemoths ;
31124: CALL 8396 0 0
// until not behemothBuilders ;
31128: LD_EXP 77
31132: NOT
31133: IFFALSE 31088
// end ;
31135: PPOPN 1
31137: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31138: LD_EXP 77
31142: NOT
31143: PUSH
31144: LD_EXP 28
31148: NOT
31149: AND
31150: PUSH
31151: LD_EXP 25
31155: AND
31156: IFFALSE 31176
31158: GO 31160
31160: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31161: LD_STRING M4a
31163: PPUSH
31164: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31168: LD_ADDR_EXP 27
31172: PUSH
31173: LD_INT 1
31175: ST_TO_ADDR
// end ;
31176: END
// every 0 0$1 trigger behemothDone do
31177: LD_EXP 28
31181: IFFALSE 31193
31183: GO 31185
31185: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31186: LD_STRING M4b
31188: PPUSH
31189: CALL_OW 337
31193: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31194: LD_EXP 29
31198: NOT
31199: IFFALSE 31395
31201: GO 31203
31203: DISABLE
31204: LD_INT 0
31206: PPUSH
31207: PPUSH
// begin enable ;
31208: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31209: LD_ADDR_VAR 0 1
31213: PUSH
31214: LD_INT 3
31216: PPUSH
31217: CALL 107343 0 1
31221: ST_TO_ADDR
// if not tmp and not behemothDone then
31222: LD_VAR 0 1
31226: NOT
31227: PUSH
31228: LD_EXP 28
31232: NOT
31233: AND
31234: IFFALSE 31270
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31236: LD_ADDR_VAR 0 1
31240: PUSH
31241: LD_INT 22
31243: PUSH
31244: LD_INT 3
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 30
31253: PUSH
31254: LD_INT 37
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PPUSH
31265: CALL_OW 69
31269: ST_TO_ADDR
// if not tmp then
31270: LD_VAR 0 1
31274: NOT
31275: IFFALSE 31279
// exit ;
31277: GO 31395
// for i in tmp do
31279: LD_ADDR_VAR 0 2
31283: PUSH
31284: LD_VAR 0 1
31288: PUSH
31289: FOR_IN
31290: IFFALSE 31393
// if See ( 1 , i ) then
31292: LD_INT 1
31294: PPUSH
31295: LD_VAR 0 2
31299: PPUSH
31300: CALL_OW 292
31304: IFFALSE 31391
// begin if GetType ( i ) = unit_building then
31306: LD_VAR 0 2
31310: PPUSH
31311: CALL_OW 247
31315: PUSH
31316: LD_INT 3
31318: EQUAL
31319: IFFALSE 31357
// begin disable ;
31321: DISABLE
// CenterNowOnUnits ( i ) ;
31322: LD_VAR 0 2
31326: PPUSH
31327: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31331: LD_EXP 40
31335: PPUSH
31336: LD_STRING D17a-JMM-1
31338: PPUSH
31339: CALL_OW 88
// seeBehemoth := true ;
31343: LD_ADDR_EXP 29
31347: PUSH
31348: LD_INT 1
31350: ST_TO_ADDR
// exit ;
31351: POP
31352: POP
31353: GO 31395
// end else
31355: GO 31391
// begin disable ;
31357: DISABLE
// CenterNowOnUnits ( i ) ;
31358: LD_VAR 0 2
31362: PPUSH
31363: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31367: LD_EXP 40
31371: PPUSH
31372: LD_STRING D17b-JMM-1
31374: PPUSH
31375: CALL_OW 88
// seeBehemoth := true ;
31379: LD_ADDR_EXP 29
31383: PUSH
31384: LD_INT 1
31386: ST_TO_ADDR
// exit ;
31387: POP
31388: POP
31389: GO 31395
// end ; end ;
31391: GO 31289
31393: POP
31394: POP
// end ;
31395: PPOPN 2
31397: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31398: LD_EXP 14
31402: PUSH
31403: LD_INT 123200
31405: GREATEREQUAL
31406: IFFALSE 32606
31408: GO 31410
31410: DISABLE
31411: LD_INT 0
31413: PPUSH
31414: PPUSH
31415: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31416: LD_INT 2
31418: PPUSH
31419: LD_INT 23
31421: PUSH
31422: LD_INT 3
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: LD_INT 48
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: PUSH
31437: EMPTY
31438: LIST
31439: PPUSH
31440: CALL 63165 0 2
// repeat wait ( 0 0$1 ) ;
31444: LD_INT 35
31446: PPUSH
31447: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31451: LD_INT 22
31453: PUSH
31454: LD_INT 3
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 34
31463: PUSH
31464: LD_INT 48
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PPUSH
31475: CALL_OW 69
31479: IFFALSE 31444
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31481: LD_ADDR_VAR 0 1
31485: PUSH
31486: LD_INT 22
31488: PUSH
31489: LD_INT 3
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 34
31498: PUSH
31499: LD_INT 48
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PPUSH
31510: CALL_OW 69
31514: PUSH
31515: LD_INT 1
31517: ARRAY
31518: ST_TO_ADDR
// missionStage := 12 ;
31519: LD_ADDR_EXP 15
31523: PUSH
31524: LD_INT 12
31526: ST_TO_ADDR
// platonovHasBomb := true ;
31527: LD_ADDR_EXP 30
31531: PUSH
31532: LD_INT 1
31534: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31535: LD_VAR 0 1
31539: PPUSH
31540: LD_INT 181
31542: PPUSH
31543: LD_INT 86
31545: PPUSH
31546: CALL_OW 171
// AddComHold ( bomb ) ;
31550: LD_VAR 0 1
31554: PPUSH
31555: CALL_OW 200
// wait ( 0 0$10 ) ;
31559: LD_INT 350
31561: PPUSH
31562: CALL_OW 67
// DialogueOn ;
31566: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31570: LD_EXP 68
31574: PPUSH
31575: LD_STRING D15-Pla-1
31577: PPUSH
31578: CALL_OW 94
// dec := Query ( Q15a ) ;
31582: LD_ADDR_VAR 0 2
31586: PUSH
31587: LD_STRING Q15a
31589: PPUSH
31590: CALL_OW 97
31594: ST_TO_ADDR
// if dec = 1 then
31595: LD_VAR 0 2
31599: PUSH
31600: LD_INT 1
31602: EQUAL
31603: IFFALSE 31626
// begin Say ( JMM , D15a-JMM-1 ) ;
31605: LD_EXP 40
31609: PPUSH
31610: LD_STRING D15a-JMM-1
31612: PPUSH
31613: CALL_OW 88
// YouLost ( Surrender ) ;
31617: LD_STRING Surrender
31619: PPUSH
31620: CALL_OW 104
// exit ;
31624: GO 32606
// end ; if dec = 2 then
31626: LD_VAR 0 2
31630: PUSH
31631: LD_INT 2
31633: EQUAL
31634: IFFALSE 31703
// begin Say ( JMM , D15b-JMM-1 ) ;
31636: LD_EXP 40
31640: PPUSH
31641: LD_STRING D15b-JMM-1
31643: PPUSH
31644: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31648: LD_EXP 68
31652: PPUSH
31653: LD_STRING D15b-Pla-1
31655: PPUSH
31656: CALL_OW 94
// DialogueOff ;
31660: CALL_OW 7
// wait ( 3 3$00 ) ;
31664: LD_INT 6300
31666: PPUSH
31667: CALL_OW 67
// DialogueOn ;
31671: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31675: LD_EXP 40
31679: PPUSH
31680: LD_STRING D15d-JMM-1a
31682: PPUSH
31683: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31687: LD_EXP 68
31691: PPUSH
31692: LD_STRING D15d-Pla-1
31694: PPUSH
31695: CALL_OW 94
// DialogueOff ;
31699: CALL_OW 7
// end ; if dec = 3 then
31703: LD_VAR 0 2
31707: PUSH
31708: LD_INT 3
31710: EQUAL
31711: IFFALSE 31765
// begin Say ( JMM , D15c-JMM-1 ) ;
31713: LD_EXP 40
31717: PPUSH
31718: LD_STRING D15c-JMM-1
31720: PPUSH
31721: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31725: LD_EXP 68
31729: PPUSH
31730: LD_STRING D15c-Pla-1
31732: PPUSH
31733: CALL_OW 94
// DialogueOff ;
31737: CALL_OW 7
// wait ( 0 0$15 ) ;
31741: LD_INT 525
31743: PPUSH
31744: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31748: LD_VAR 0 1
31752: PPUSH
31753: LD_INT 60
31755: PPUSH
31756: LD_INT 95
31758: PPUSH
31759: CALL_OW 116
// exit ;
31763: GO 32606
// end ; if dec = 4 then
31765: LD_VAR 0 2
31769: PUSH
31770: LD_INT 4
31772: EQUAL
31773: IFFALSE 31803
// begin Say ( JMM , D15d-JMM-1 ) ;
31775: LD_EXP 40
31779: PPUSH
31780: LD_STRING D15d-JMM-1
31782: PPUSH
31783: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31787: LD_EXP 68
31791: PPUSH
31792: LD_STRING D15d-Pla-1
31794: PPUSH
31795: CALL_OW 94
// DialogueOff ;
31799: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31803: LD_EXP 66
31807: PPUSH
31808: CALL_OW 302
31812: PUSH
31813: LD_EXP 66
31817: PPUSH
31818: CALL_OW 255
31822: PUSH
31823: LD_INT 1
31825: EQUAL
31826: AND
31827: PUSH
31828: LD_INT 22
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 34
31840: PUSH
31841: LD_INT 8
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PPUSH
31852: CALL_OW 69
31856: NOT
31857: AND
31858: IFFALSE 32507
// begin SetSide ( Friend , 8 ) ;
31860: LD_EXP 66
31864: PPUSH
31865: LD_INT 8
31867: PPUSH
31868: CALL_OW 235
// if IsInUnit ( Friend ) then
31872: LD_EXP 66
31876: PPUSH
31877: CALL_OW 310
31881: IFFALSE 31892
// ComExitBuilding ( Friend ) ;
31883: LD_EXP 66
31887: PPUSH
31888: CALL_OW 122
// if IsDriver ( Friend ) then
31892: LD_EXP 66
31896: PPUSH
31897: CALL 104886 0 1
31901: IFFALSE 31912
// ComExitVehicle ( Friend ) ;
31903: LD_EXP 66
31907: PPUSH
31908: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31912: LD_EXP 66
31916: PPUSH
31917: LD_INT 9
31919: PPUSH
31920: LD_INT 2
31922: PPUSH
31923: CALL_OW 171
// wait ( 0 0$05 ) ;
31927: LD_INT 175
31929: PPUSH
31930: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31934: LD_EXP 66
31938: PPUSH
31939: CALL_OW 87
// DialogueOn ;
31943: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31947: LD_EXP 40
31951: PPUSH
31952: LD_STRING D16-JMM-1
31954: PPUSH
31955: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31959: LD_EXP 66
31963: PPUSH
31964: LD_STRING D16-Friend-1
31966: PPUSH
31967: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31971: LD_EXP 40
31975: PPUSH
31976: LD_STRING D16-JMM-2
31978: PPUSH
31979: CALL_OW 88
// DialogueOff ;
31983: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31987: LD_EXP 66
31991: PPUSH
31992: LD_INT 1
31994: PPUSH
31995: CALL_OW 235
// ComHold ( Friend ) ;
31999: LD_EXP 66
32003: PPUSH
32004: CALL_OW 140
// wait ( 0 0$20 ) ;
32008: LD_INT 700
32010: PPUSH
32011: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32015: LD_EXP 66
32019: PPUSH
32020: LD_INT 9
32022: PPUSH
32023: LD_INT 2
32025: PPUSH
32026: CALL_OW 297
32030: PUSH
32031: LD_INT 30
32033: LESS
32034: IFFALSE 32103
// begin SetSide ( Friend , 8 ) ;
32036: LD_EXP 66
32040: PPUSH
32041: LD_INT 8
32043: PPUSH
32044: CALL_OW 235
// if IsInUnit ( Friend ) then
32048: LD_EXP 66
32052: PPUSH
32053: CALL_OW 310
32057: IFFALSE 32068
// ComExitBuilding ( Friend ) ;
32059: LD_EXP 66
32063: PPUSH
32064: CALL_OW 122
// if IsDriver ( Friend ) then
32068: LD_EXP 66
32072: PPUSH
32073: CALL 104886 0 1
32077: IFFALSE 32088
// ComExitVehicle ( Friend ) ;
32079: LD_EXP 66
32083: PPUSH
32084: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32088: LD_EXP 66
32092: PPUSH
32093: LD_INT 9
32095: PPUSH
32096: LD_INT 2
32098: PPUSH
32099: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32103: LD_INT 1050
32105: PPUSH
32106: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32110: LD_INT 22
32112: PUSH
32113: LD_INT 1
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 34
32122: PUSH
32123: LD_INT 8
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PPUSH
32134: CALL_OW 69
32138: NOT
32139: IFFALSE 32485
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32141: LD_ADDR_VAR 0 3
32145: PUSH
32146: LD_INT 22
32148: PUSH
32149: LD_INT 1
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 26
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 3
32168: PUSH
32169: LD_INT 25
32171: PUSH
32172: LD_INT 12
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 25
32181: PUSH
32182: LD_INT 16
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: LIST
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: LIST
32198: PPUSH
32199: CALL_OW 69
32203: PUSH
32204: LD_EXP 40
32208: PUSH
32209: LD_EXP 42
32213: PUSH
32214: LD_EXP 56
32218: PUSH
32219: LD_EXP 43
32223: PUSH
32224: LD_EXP 44
32228: PUSH
32229: LD_EXP 45
32233: PUSH
32234: LD_EXP 46
32238: PUSH
32239: LD_EXP 47
32243: PUSH
32244: LD_EXP 48
32248: PUSH
32249: LD_EXP 49
32253: PUSH
32254: LD_EXP 50
32258: PUSH
32259: LD_EXP 51
32263: PUSH
32264: LD_EXP 52
32268: PUSH
32269: LD_EXP 53
32273: PUSH
32274: LD_EXP 54
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: DIFF
32296: ST_TO_ADDR
// DialogueOn ;
32297: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32301: LD_EXP 68
32305: PPUSH
32306: LD_STRING D16a-Pla-1
32308: PPUSH
32309: CALL_OW 94
// if Stevens then
32313: LD_EXP 42
32317: IFFALSE 32333
// Say ( Stevens , D16a-Huck-1 ) else
32319: LD_EXP 42
32323: PPUSH
32324: LD_STRING D16a-Huck-1
32326: PPUSH
32327: CALL_OW 88
32331: GO 32375
// if Baker then
32333: LD_EXP 56
32337: IFFALSE 32353
// Say ( Baker , D16a-Huck-1 ) else
32339: LD_EXP 56
32343: PPUSH
32344: LD_STRING D16a-Huck-1
32346: PPUSH
32347: CALL_OW 88
32351: GO 32375
// if tmp then
32353: LD_VAR 0 3
32357: IFFALSE 32375
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32359: LD_VAR 0 3
32363: PUSH
32364: LD_INT 1
32366: ARRAY
32367: PPUSH
32368: LD_STRING D16a-Sol1-1
32370: PPUSH
32371: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32375: LD_EXP 66
32379: PPUSH
32380: CALL_OW 255
32384: PUSH
32385: LD_INT 8
32387: EQUAL
32388: IFFALSE 32404
// Say ( JMM , D16a-JMM-1 ) else
32390: LD_EXP 40
32394: PPUSH
32395: LD_STRING D16a-JMM-1
32397: PPUSH
32398: CALL_OW 88
32402: GO 32464
// begin Say ( JMM , D16a-JMM-1a ) ;
32404: LD_EXP 40
32408: PPUSH
32409: LD_STRING D16a-JMM-1a
32411: PPUSH
32412: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32416: LD_EXP 66
32420: PPUSH
32421: LD_STRING D16a-Friend-1
32423: PPUSH
32424: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32428: LD_EXP 66
32432: PPUSH
32433: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32437: LD_EXP 66
32441: PPUSH
32442: LD_INT 191
32444: PPUSH
32445: LD_INT 103
32447: PPUSH
32448: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32452: LD_EXP 66
32456: PPUSH
32457: LD_INT 3
32459: PPUSH
32460: CALL_OW 235
// end ; DialogueOff ;
32464: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32468: LD_VAR 0 1
32472: PPUSH
32473: LD_INT 60
32475: PPUSH
32476: LD_INT 95
32478: PPUSH
32479: CALL_OW 116
// end else
32483: GO 32505
// begin DialogueOn ;
32485: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32489: LD_EXP 68
32493: PPUSH
32494: LD_STRING D16c-Pla-1
32496: PPUSH
32497: CALL_OW 94
// DialogueOff ;
32501: CALL_OW 7
// end ; end else
32505: GO 32606
// begin wait ( 3 3$00 ) ;
32507: LD_INT 6300
32509: PPUSH
32510: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32514: LD_INT 22
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 34
32526: PUSH
32527: LD_INT 8
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PPUSH
32538: CALL_OW 69
32542: NOT
32543: IFFALSE 32586
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32545: LD_EXP 68
32549: PPUSH
32550: LD_STRING D16b-Pla-1
32552: PPUSH
32553: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32557: LD_EXP 40
32561: PPUSH
32562: LD_STRING D16b-JMM-1
32564: PPUSH
32565: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32569: LD_VAR 0 1
32573: PPUSH
32574: LD_INT 60
32576: PPUSH
32577: LD_INT 95
32579: PPUSH
32580: CALL_OW 116
// end else
32584: GO 32606
// begin DialogueOn ;
32586: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32590: LD_EXP 68
32594: PPUSH
32595: LD_STRING D16c-Pla-1
32597: PPUSH
32598: CALL_OW 94
// DialogueOff ;
32602: CALL_OW 7
// end ; end ; end ;
32606: PPOPN 3
32608: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32609: LD_INT 25
32611: PPUSH
32612: LD_INT 1
32614: PPUSH
32615: CALL_OW 321
32619: PUSH
32620: LD_INT 2
32622: EQUAL
32623: PUSH
32624: LD_EXP 14
32628: PUSH
32629: LD_INT 126000
32631: GREATEREQUAL
32632: OR
32633: PUSH
32634: LD_EXP 23
32638: NOT
32639: AND
32640: PUSH
32641: LD_EXP 79
32645: PPUSH
32646: CALL_OW 302
32650: AND
32651: IFFALSE 33009
32653: GO 32655
32655: DISABLE
32656: LD_INT 0
32658: PPUSH
// begin missionStage := 11 ;
32659: LD_ADDR_EXP 15
32663: PUSH
32664: LD_INT 11
32666: ST_TO_ADDR
// DialogueOn ;
32667: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32671: LD_EXP 79
32675: PPUSH
32676: LD_STRING D9-Roth-1
32678: PPUSH
32679: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32683: LD_EXP 40
32687: PPUSH
32688: LD_STRING D9-JMM-1
32690: PPUSH
32691: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32695: LD_EXP 79
32699: PPUSH
32700: LD_STRING D9-Roth-2
32702: PPUSH
32703: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32707: LD_EXP 79
32711: PPUSH
32712: LD_STRING D9-Roth-2a
32714: PPUSH
32715: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32719: LD_EXP 68
32723: PPUSH
32724: LD_STRING D9-Pla-2
32726: PPUSH
32727: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32731: LD_EXP 79
32735: PPUSH
32736: LD_STRING D9-Roth-3
32738: PPUSH
32739: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32743: LD_EXP 68
32747: PPUSH
32748: LD_STRING D9-Pla-3
32750: PPUSH
32751: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32755: LD_EXP 79
32759: PPUSH
32760: LD_STRING D9-Roth-4
32762: PPUSH
32763: CALL_OW 94
// dec := Query ( Q9 ) ;
32767: LD_ADDR_VAR 0 1
32771: PUSH
32772: LD_STRING Q9
32774: PPUSH
32775: CALL_OW 97
32779: ST_TO_ADDR
// if dec = 1 then
32780: LD_VAR 0 1
32784: PUSH
32785: LD_INT 1
32787: EQUAL
32788: IFFALSE 32802
// SayRadio ( Roth , D9a-Roth-1 ) ;
32790: LD_EXP 79
32794: PPUSH
32795: LD_STRING D9a-Roth-1
32797: PPUSH
32798: CALL_OW 94
// if dec = 2 then
32802: LD_VAR 0 1
32806: PUSH
32807: LD_INT 2
32809: EQUAL
32810: IFFALSE 32836
// begin Say ( JMM , D9b-JMM-1 ) ;
32812: LD_EXP 40
32816: PPUSH
32817: LD_STRING D9b-JMM-1
32819: PPUSH
32820: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32824: LD_EXP 79
32828: PPUSH
32829: LD_STRING D9b-Roth-1
32831: PPUSH
32832: CALL_OW 94
// end ; if dec = 3 then
32836: LD_VAR 0 1
32840: PUSH
32841: LD_INT 3
32843: EQUAL
32844: IFFALSE 32906
// begin Say ( JMM , D9c-JMM-1 ) ;
32846: LD_EXP 40
32850: PPUSH
32851: LD_STRING D9c-JMM-1
32853: PPUSH
32854: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32858: LD_EXP 79
32862: PPUSH
32863: LD_STRING D9c-Roth-1
32865: PPUSH
32866: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32870: LD_EXP 40
32874: PPUSH
32875: LD_STRING D9c-JMM-2
32877: PPUSH
32878: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32882: LD_EXP 79
32886: PPUSH
32887: LD_STRING D9c-Roth-2
32889: PPUSH
32890: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32894: LD_EXP 40
32898: PPUSH
32899: LD_STRING D9c-JMM-3
32901: PPUSH
32902: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32906: LD_EXP 79
32910: PPUSH
32911: LD_STRING D9c-Roth-3
32913: PPUSH
32914: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32918: LD_EXP 79
32922: PPUSH
32923: LD_STRING D9cont-Roth-1
32925: PPUSH
32926: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32930: LD_EXP 40
32934: PPUSH
32935: LD_STRING D9cont-JMM-1
32937: PPUSH
32938: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32942: LD_EXP 79
32946: PPUSH
32947: LD_STRING D9cont-Roth-2
32949: PPUSH
32950: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32954: LD_EXP 40
32958: PPUSH
32959: LD_STRING D9cont-JMM-2
32961: PPUSH
32962: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32966: LD_EXP 79
32970: PPUSH
32971: LD_STRING D9cont-Roth-3
32973: PPUSH
32974: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32978: LD_EXP 40
32982: PPUSH
32983: LD_STRING D9cont-JMM-3
32985: PPUSH
32986: CALL_OW 88
// DialogueOff ;
32990: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32994: LD_STRING M3
32996: PPUSH
32997: CALL_OW 337
// allianceActive := true ;
33001: LD_ADDR_EXP 31
33005: PUSH
33006: LD_INT 1
33008: ST_TO_ADDR
// end ;
33009: PPOPN 1
33011: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33012: LD_INT 1
33014: PPUSH
33015: LD_INT 126
33017: PPUSH
33018: CALL_OW 292
33022: PUSH
33023: LD_EXP 68
33027: PPUSH
33028: CALL_OW 310
33032: AND
33033: IFFALSE 33186
33035: GO 33037
33037: DISABLE
33038: LD_INT 0
33040: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33041: LD_EXP 68
33045: PPUSH
33046: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33050: LD_ADDR_VAR 0 1
33054: PUSH
33055: LD_INT 4
33057: PPUSH
33058: LD_INT 22
33060: PUSH
33061: LD_INT 1
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PPUSH
33068: CALL_OW 70
33072: PPUSH
33073: LD_EXP 68
33077: PPUSH
33078: CALL_OW 74
33082: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33083: LD_EXP 68
33087: PPUSH
33088: LD_VAR 0 1
33092: PUSH
33093: LD_INT 1
33095: ARRAY
33096: PPUSH
33097: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33101: LD_EXP 68
33105: PPUSH
33106: LD_STRING D18-Pla-1
33108: PPUSH
33109: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33113: LD_INT 22
33115: PUSH
33116: LD_INT 3
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: PUSH
33123: LD_INT 34
33125: PUSH
33126: LD_INT 48
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PPUSH
33137: CALL_OW 69
33141: IFFALSE 33186
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33143: LD_INT 22
33145: PUSH
33146: LD_INT 3
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 34
33155: PUSH
33156: LD_INT 48
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PPUSH
33167: CALL_OW 69
33171: PUSH
33172: LD_INT 1
33174: ARRAY
33175: PPUSH
33176: LD_INT 111
33178: PPUSH
33179: LD_INT 97
33181: PPUSH
33182: CALL_OW 116
// end ;
33186: PPOPN 1
33188: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33189: LD_EXP 68
33193: PPUSH
33194: CALL_OW 301
33198: PUSH
33199: LD_EXP 71
33203: PPUSH
33204: CALL_OW 301
33208: AND
33209: PUSH
33210: LD_INT 22
33212: PUSH
33213: LD_INT 3
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: PUSH
33220: LD_INT 21
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 50
33232: PUSH
33233: EMPTY
33234: LIST
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: LIST
33240: PPUSH
33241: CALL_OW 69
33245: PUSH
33246: LD_INT 7
33248: PUSH
33249: LD_INT 8
33251: PUSH
33252: LD_INT 9
33254: PUSH
33255: LD_INT 10
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: PUSH
33264: LD_OWVAR 67
33268: ARRAY
33269: LESS
33270: AND
33271: IFFALSE 34070
33273: GO 33275
33275: DISABLE
33276: LD_INT 0
33278: PPUSH
33279: PPUSH
33280: PPUSH
33281: PPUSH
// begin MC_Kill ( 2 ) ;
33282: LD_INT 2
33284: PPUSH
33285: CALL 39140 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33289: LD_INT 1
33291: PPUSH
33292: LD_INT 3
33294: PPUSH
33295: LD_INT 1
33297: PPUSH
33298: LD_INT 1
33300: PPUSH
33301: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33305: LD_ADDR_VAR 0 2
33309: PUSH
33310: LD_INT 22
33312: PUSH
33313: LD_INT 3
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: LD_INT 21
33322: PUSH
33323: LD_INT 1
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 50
33332: PUSH
33333: EMPTY
33334: LIST
33335: PUSH
33336: LD_INT 26
33338: PUSH
33339: LD_INT 1
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: PPUSH
33352: CALL_OW 69
33356: ST_TO_ADDR
// if not tmp then
33357: LD_VAR 0 2
33361: NOT
33362: IFFALSE 33418
// begin uc_side = 3 ;
33364: LD_ADDR_OWVAR 20
33368: PUSH
33369: LD_INT 3
33371: ST_TO_ADDR
// uc_nation = 3 ;
33372: LD_ADDR_OWVAR 21
33376: PUSH
33377: LD_INT 3
33379: ST_TO_ADDR
// hc_name =  ;
33380: LD_ADDR_OWVAR 26
33384: PUSH
33385: LD_STRING 
33387: ST_TO_ADDR
// hc_gallery =  ;
33388: LD_ADDR_OWVAR 33
33392: PUSH
33393: LD_STRING 
33395: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33396: LD_INT 1
33398: PPUSH
33399: LD_INT 10
33401: PPUSH
33402: CALL_OW 381
// tmp = CreateHuman ;
33406: LD_ADDR_VAR 0 2
33410: PUSH
33411: CALL_OW 44
33415: ST_TO_ADDR
// end else
33416: GO 33432
// tmp := tmp [ 1 ] ;
33418: LD_ADDR_VAR 0 2
33422: PUSH
33423: LD_VAR 0 2
33427: PUSH
33428: LD_INT 1
33430: ARRAY
33431: ST_TO_ADDR
// DialogueOn ;
33432: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33436: LD_VAR 0 2
33440: PPUSH
33441: LD_STRING DSurrenderRussians-RSol1-1a
33443: PPUSH
33444: CALL_OW 94
// DialogueOff ;
33448: CALL_OW 7
// russianDestroyed := true ;
33452: LD_ADDR_EXP 21
33456: PUSH
33457: LD_INT 1
33459: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33460: LD_ADDR_VAR 0 1
33464: PUSH
33465: LD_INT 22
33467: PUSH
33468: LD_INT 6
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PPUSH
33475: CALL_OW 69
33479: PUSH
33480: FOR_IN
33481: IFFALSE 33494
// KillUnit ( i ) ;
33483: LD_VAR 0 1
33487: PPUSH
33488: CALL_OW 66
33492: GO 33480
33494: POP
33495: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33496: LD_INT 22
33498: PUSH
33499: LD_INT 3
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 21
33508: PUSH
33509: LD_INT 1
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PPUSH
33520: CALL_OW 69
33524: PPUSH
33525: CALL_OW 122
// wait ( 0 0$1 ) ;
33529: LD_INT 35
33531: PPUSH
33532: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33536: LD_INT 22
33538: PUSH
33539: LD_INT 3
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 21
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PPUSH
33560: CALL_OW 69
33564: PPUSH
33565: LD_INT 25
33567: PPUSH
33568: CALL_OW 173
// wait ( 0 0$35 ) ;
33572: LD_INT 1225
33574: PPUSH
33575: CALL_OW 67
// PrepareOmarInvasion ;
33579: CALL 16296 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33583: LD_ADDR_VAR 0 2
33587: PUSH
33588: LD_EXP 97
33592: PPUSH
33593: CALL_OW 250
33597: PUSH
33598: LD_EXP 97
33602: PPUSH
33603: CALL_OW 251
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33612: LD_VAR 0 2
33616: PUSH
33617: LD_INT 1
33619: ARRAY
33620: PPUSH
33621: LD_VAR 0 2
33625: PUSH
33626: LD_INT 2
33628: ARRAY
33629: PPUSH
33630: LD_INT 1
33632: PPUSH
33633: LD_INT 8
33635: NEG
33636: PPUSH
33637: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33641: LD_EXP 97
33645: PPUSH
33646: CALL_OW 87
// DialogueOn ;
33650: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33654: LD_EXP 40
33658: PPUSH
33659: LD_STRING D19-JMM-1
33661: PPUSH
33662: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33666: LD_ADDR_VAR 0 3
33670: PUSH
33671: LD_INT 22
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 26
33683: PUSH
33684: LD_INT 1
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 2
33693: PUSH
33694: LD_INT 25
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 25
33706: PUSH
33707: LD_INT 2
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 25
33716: PUSH
33717: LD_INT 3
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 25
33726: PUSH
33727: LD_INT 4
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 25
33736: PUSH
33737: LD_INT 5
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 25
33746: PUSH
33747: LD_INT 8
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: LIST
33767: PPUSH
33768: CALL_OW 69
33772: PUSH
33773: LD_EXP 40
33777: PUSH
33778: LD_EXP 41
33782: PUSH
33783: LD_EXP 64
33787: PUSH
33788: LD_EXP 42
33792: PUSH
33793: LD_EXP 43
33797: PUSH
33798: LD_EXP 44
33802: PUSH
33803: LD_EXP 45
33807: PUSH
33808: LD_EXP 46
33812: PUSH
33813: LD_EXP 47
33817: PUSH
33818: LD_EXP 48
33822: PUSH
33823: LD_EXP 49
33827: PUSH
33828: LD_EXP 50
33832: PUSH
33833: LD_EXP 51
33837: PUSH
33838: LD_EXP 52
33842: PUSH
33843: LD_EXP 53
33847: PUSH
33848: LD_EXP 54
33852: PUSH
33853: LD_EXP 55
33857: PUSH
33858: LD_EXP 56
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: DIFF
33883: ST_TO_ADDR
// if tmp2 then
33884: LD_VAR 0 3
33888: IFFALSE 33906
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33890: LD_VAR 0 3
33894: PUSH
33895: LD_INT 1
33897: ARRAY
33898: PPUSH
33899: LD_STRING D19-Sol1-1
33901: PPUSH
33902: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33906: LD_EXP 40
33910: PPUSH
33911: LD_STRING D19-JMM-2
33913: PPUSH
33914: CALL_OW 88
// DialogueOff ;
33918: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33922: LD_VAR 0 2
33926: PUSH
33927: LD_INT 1
33929: ARRAY
33930: PPUSH
33931: LD_VAR 0 2
33935: PUSH
33936: LD_INT 2
33938: ARRAY
33939: PPUSH
33940: LD_INT 1
33942: PPUSH
33943: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33947: LD_STRING M5
33949: PPUSH
33950: CALL_OW 337
// omarOnMotherLode := false ;
33954: LD_ADDR_VAR 0 4
33958: PUSH
33959: LD_INT 0
33961: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33962: LD_INT 35
33964: PPUSH
33965: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33969: LD_EXP 97
33973: PPUSH
33974: LD_INT 215
33976: PPUSH
33977: LD_INT 100
33979: PPUSH
33980: CALL_OW 297
33984: PUSH
33985: LD_INT 10
33987: LESS
33988: PUSH
33989: LD_VAR 0 4
33993: NOT
33994: AND
33995: IFFALSE 34029
// begin omarOnMotherLode := true ;
33997: LD_ADDR_VAR 0 4
34001: PUSH
34002: LD_INT 1
34004: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34005: LD_EXP 40
34009: PPUSH
34010: LD_STRING D19b-JMM-1
34012: PPUSH
34013: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34017: LD_EXP 97
34021: PPUSH
34022: LD_STRING DOmarContam-Omar-1
34024: PPUSH
34025: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34029: LD_EXP 97
34033: PPUSH
34034: CALL_OW 301
34038: IFFALSE 33962
// Say ( JMM , D19a-JMM-1 ) ;
34040: LD_EXP 40
34044: PPUSH
34045: LD_STRING D19a-JMM-1
34047: PPUSH
34048: CALL_OW 88
// if Heike then
34052: LD_EXP 98
34056: IFFALSE 34070
// Say ( Heike , D19a-Hke-1 ) ;
34058: LD_EXP 98
34062: PPUSH
34063: LD_STRING D19a-Hke-1
34065: PPUSH
34066: CALL_OW 88
// end ;
34070: PPOPN 4
34072: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34073: LD_INT 22
34075: PUSH
34076: LD_INT 3
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 21
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PPUSH
34097: CALL_OW 69
34101: PUSH
34102: LD_EXP 21
34106: AND
34107: IFFALSE 34175
34109: GO 34111
34111: DISABLE
34112: LD_INT 0
34114: PPUSH
34115: PPUSH
// begin enable ;
34116: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34117: LD_ADDR_VAR 0 2
34121: PUSH
34122: LD_INT 25
34124: PPUSH
34125: LD_INT 22
34127: PUSH
34128: LD_INT 3
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PPUSH
34135: CALL_OW 70
34139: ST_TO_ADDR
// if not tmp then
34140: LD_VAR 0 2
34144: NOT
34145: IFFALSE 34149
// exit ;
34147: GO 34175
// for i in tmp do
34149: LD_ADDR_VAR 0 1
34153: PUSH
34154: LD_VAR 0 2
34158: PUSH
34159: FOR_IN
34160: IFFALSE 34173
// RemoveUnit ( i ) ;
34162: LD_VAR 0 1
34166: PPUSH
34167: CALL_OW 64
34171: GO 34159
34173: POP
34174: POP
// end ;
34175: PPOPN 2
34177: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34178: LD_INT 22
34180: PUSH
34181: LD_INT 7
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 21
34190: PUSH
34191: LD_INT 1
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PPUSH
34202: CALL_OW 69
34206: PUSH
34207: LD_INT 6
34209: LESS
34210: IFFALSE 34678
34212: GO 34214
34214: DISABLE
34215: LD_INT 0
34217: PPUSH
34218: PPUSH
// begin MC_Kill ( 1 ) ;
34219: LD_INT 1
34221: PPUSH
34222: CALL 39140 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34226: LD_INT 7
34228: PPUSH
34229: LD_INT 1
34231: PPUSH
34232: LD_INT 1
34234: PPUSH
34235: LD_INT 1
34237: PPUSH
34238: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34242: LD_ADDR_VAR 0 1
34246: PUSH
34247: LD_INT 22
34249: PUSH
34250: LD_INT 7
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 26
34259: PUSH
34260: LD_INT 1
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PPUSH
34271: CALL_OW 69
34275: PUSH
34276: LD_EXP 79
34280: DIFF
34281: ST_TO_ADDR
// if tmp then
34282: LD_VAR 0 1
34286: IFFALSE 34304
// tmp := tmp [ 1 ] else
34288: LD_ADDR_VAR 0 1
34292: PUSH
34293: LD_VAR 0 1
34297: PUSH
34298: LD_INT 1
34300: ARRAY
34301: ST_TO_ADDR
34302: GO 34340
// begin uc_side := 7 ;
34304: LD_ADDR_OWVAR 20
34308: PUSH
34309: LD_INT 7
34311: ST_TO_ADDR
// uc_nation := 1 ;
34312: LD_ADDR_OWVAR 21
34316: PUSH
34317: LD_INT 1
34319: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34320: LD_INT 1
34322: PPUSH
34323: LD_INT 8
34325: PPUSH
34326: CALL_OW 384
// tmp := CreateHuman ;
34330: LD_ADDR_VAR 0 1
34334: PUSH
34335: CALL_OW 44
34339: ST_TO_ADDR
// end ; DialogueOn ;
34340: CALL_OW 6
// if IsOK ( Roth ) then
34344: LD_EXP 79
34348: PPUSH
34349: CALL_OW 302
34353: IFFALSE 34367
// Say ( JMM , DAb-JMM-1 ) ;
34355: LD_EXP 40
34359: PPUSH
34360: LD_STRING DAb-JMM-1
34362: PPUSH
34363: CALL_OW 88
// if IsOK ( Roth ) then
34367: LD_EXP 79
34371: PPUSH
34372: CALL_OW 302
34376: IFFALSE 34400
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34378: LD_EXP 79
34382: PPUSH
34383: LD_STRING DSurrenderAlliance-Roth-1
34385: PPUSH
34386: CALL_OW 88
// RothCaptured := true ;
34390: LD_ADDR_EXP 33
34394: PUSH
34395: LD_INT 1
34397: ST_TO_ADDR
// end else
34398: GO 34412
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34400: LD_VAR 0 1
34404: PPUSH
34405: LD_STRING DSurrenderAlliance-Sci1-1
34407: PPUSH
34408: CALL_OW 88
// DialogueOff ;
34412: CALL_OW 7
// allianceDestroyed := true ;
34416: LD_ADDR_EXP 23
34420: PUSH
34421: LD_INT 1
34423: ST_TO_ADDR
// if capturedUnit = 0 then
34424: LD_EXP 34
34428: PUSH
34429: LD_INT 0
34431: EQUAL
34432: IFFALSE 34441
// SetAchievement ( ACH_ALLIANCE ) ;
34434: LD_STRING ACH_ALLIANCE
34436: PPUSH
34437: CALL_OW 543
// if trueAmericans then
34441: LD_EXP 35
34445: IFFALSE 34521
// begin if trueAmericans = 1 then
34447: LD_EXP 35
34451: PUSH
34452: LD_INT 1
34454: EQUAL
34455: IFFALSE 34471
// Say ( JMM , DAb-JMM-1a ) else
34457: LD_EXP 40
34461: PPUSH
34462: LD_STRING DAb-JMM-1a
34464: PPUSH
34465: CALL_OW 88
34469: GO 34483
// Say ( JMM , DAb-JMM-1b ) ;
34471: LD_EXP 40
34475: PPUSH
34476: LD_STRING DAb-JMM-1b
34478: PPUSH
34479: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34483: LD_EXP 35
34487: PPUSH
34488: CALL_OW 87
// for i in trueAmericans do
34492: LD_ADDR_VAR 0 2
34496: PUSH
34497: LD_EXP 35
34501: PUSH
34502: FOR_IN
34503: IFFALSE 34519
// SetSide ( i , 1 ) ;
34505: LD_VAR 0 2
34509: PPUSH
34510: LD_INT 1
34512: PPUSH
34513: CALL_OW 235
34517: GO 34502
34519: POP
34520: POP
// end ; repeat wait ( 0 0$1 ) ;
34521: LD_INT 35
34523: PPUSH
34524: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34528: LD_ADDR_VAR 0 2
34532: PUSH
34533: LD_INT 22
34535: PUSH
34536: LD_INT 7
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 21
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PPUSH
34557: CALL_OW 69
34561: PUSH
34562: FOR_IN
34563: IFFALSE 34645
// begin if IsInUnit ( i ) then
34565: LD_VAR 0 2
34569: PPUSH
34570: CALL_OW 310
34574: IFFALSE 34585
// ComExitBuilding ( i ) ;
34576: LD_VAR 0 2
34580: PPUSH
34581: CALL_OW 122
// if IsDriver ( i ) then
34585: LD_VAR 0 2
34589: PPUSH
34590: CALL 104886 0 1
34594: IFFALSE 34605
// ComExitVehicle ( i ) ;
34596: LD_VAR 0 2
34600: PPUSH
34601: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34605: LD_VAR 0 2
34609: PPUSH
34610: LD_INT 26
34612: PPUSH
34613: CALL_OW 308
34617: NOT
34618: IFFALSE 34634
// AddComMoveToArea ( i , allianceEscapeArea ) else
34620: LD_VAR 0 2
34624: PPUSH
34625: LD_INT 26
34627: PPUSH
34628: CALL_OW 173
34632: GO 34643
// RemoveUnit ( i ) ;
34634: LD_VAR 0 2
34638: PPUSH
34639: CALL_OW 64
// end ;
34643: GO 34562
34645: POP
34646: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34647: LD_INT 22
34649: PUSH
34650: LD_INT 7
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 21
34659: PUSH
34660: LD_INT 1
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PPUSH
34671: CALL_OW 69
34675: NOT
34676: IFFALSE 34521
// end ;
34678: PPOPN 2
34680: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34681: LD_INT 0
34683: PPUSH
34684: PPUSH
// if not unit then
34685: LD_VAR 0 1
34689: NOT
34690: IFFALSE 34694
// exit ;
34692: GO 36208
// DoNotAttack ( 7 , unit ) ;
34694: LD_INT 7
34696: PPUSH
34697: LD_VAR 0 1
34701: PPUSH
34702: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34706: LD_VAR 0 1
34710: PPUSH
34711: LD_INT 260
34713: PPUSH
34714: LD_INT 235
34716: PPUSH
34717: LD_INT 3
34719: PPUSH
34720: LD_INT 1
34722: PPUSH
34723: CALL_OW 483
// SetSide ( unit , 4 ) ;
34727: LD_VAR 0 1
34731: PPUSH
34732: LD_INT 4
34734: PPUSH
34735: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34739: LD_ADDR_EXP 34
34743: PUSH
34744: LD_EXP 34
34748: PUSH
34749: LD_INT 1
34751: PLUS
34752: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34753: LD_INT 70
34755: PPUSH
34756: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34760: LD_INT 260
34762: PPUSH
34763: LD_INT 235
34765: PPUSH
34766: LD_INT 1
34768: PPUSH
34769: LD_INT 8
34771: NEG
34772: PPUSH
34773: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34777: LD_VAR 0 1
34781: PPUSH
34782: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34786: LD_VAR 0 1
34790: PPUSH
34791: LD_EXP 79
34795: PPUSH
34796: CALL_OW 119
// DialogueOn ;
34800: CALL_OW 6
// case unit of JMM :
34804: LD_VAR 0 1
34808: PUSH
34809: LD_EXP 40
34813: DOUBLE
34814: EQUAL
34815: IFTRUE 34819
34817: GO 34834
34819: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34820: LD_EXP 40
34824: PPUSH
34825: LD_STRING DA1-JMM-1
34827: PPUSH
34828: CALL_OW 91
34832: GO 35276
34834: LD_EXP 41
34838: DOUBLE
34839: EQUAL
34840: IFTRUE 34844
34842: GO 34859
34844: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34845: LD_EXP 41
34849: PPUSH
34850: LD_STRING DA1-Joan-1
34852: PPUSH
34853: CALL_OW 91
34857: GO 35276
34859: LD_EXP 43
34863: DOUBLE
34864: EQUAL
34865: IFTRUE 34869
34867: GO 34884
34869: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34870: LD_EXP 43
34874: PPUSH
34875: LD_STRING DA1-Lisa-1
34877: PPUSH
34878: CALL_OW 91
34882: GO 35276
34884: LD_EXP 44
34888: DOUBLE
34889: EQUAL
34890: IFTRUE 34894
34892: GO 34909
34894: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34895: LD_EXP 44
34899: PPUSH
34900: LD_STRING DA1-Don-1
34902: PPUSH
34903: CALL_OW 91
34907: GO 35276
34909: LD_EXP 51
34913: DOUBLE
34914: EQUAL
34915: IFTRUE 34919
34917: GO 34934
34919: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34920: LD_EXP 51
34924: PPUSH
34925: LD_STRING DA1-Corn-1
34927: PPUSH
34928: CALL_OW 91
34932: GO 35276
34934: LD_EXP 47
34938: DOUBLE
34939: EQUAL
34940: IFTRUE 34944
34942: GO 34959
34944: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34945: LD_EXP 47
34949: PPUSH
34950: LD_STRING DA1-Den-1
34952: PPUSH
34953: CALL_OW 91
34957: GO 35276
34959: LD_EXP 45
34963: DOUBLE
34964: EQUAL
34965: IFTRUE 34969
34967: GO 34984
34969: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34970: LD_EXP 45
34974: PPUSH
34975: LD_STRING DA1-Bobby-1
34977: PPUSH
34978: CALL_OW 91
34982: GO 35276
34984: LD_EXP 49
34988: DOUBLE
34989: EQUAL
34990: IFTRUE 34994
34992: GO 35009
34994: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34995: LD_EXP 49
34999: PPUSH
35000: LD_STRING DA1-Glad-1
35002: PPUSH
35003: CALL_OW 91
35007: GO 35276
35009: LD_EXP 46
35013: DOUBLE
35014: EQUAL
35015: IFTRUE 35019
35017: GO 35034
35019: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35020: LD_EXP 46
35024: PPUSH
35025: LD_STRING DA1-Cyrus-1
35027: PPUSH
35028: CALL_OW 91
35032: GO 35276
35034: LD_EXP 42
35038: DOUBLE
35039: EQUAL
35040: IFTRUE 35044
35042: GO 35059
35044: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35045: LD_EXP 42
35049: PPUSH
35050: LD_STRING DA1-Huck-1
35052: PPUSH
35053: CALL_OW 91
35057: GO 35276
35059: LD_EXP 56
35063: DOUBLE
35064: EQUAL
35065: IFTRUE 35069
35067: GO 35084
35069: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35070: LD_EXP 56
35074: PPUSH
35075: LD_STRING DA1-Huck-1
35077: PPUSH
35078: CALL_OW 91
35082: GO 35276
35084: LD_EXP 48
35088: DOUBLE
35089: EQUAL
35090: IFTRUE 35094
35092: GO 35109
35094: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35095: LD_EXP 48
35099: PPUSH
35100: LD_STRING DA1-Brown-1
35102: PPUSH
35103: CALL_OW 91
35107: GO 35276
35109: LD_EXP 52
35113: DOUBLE
35114: EQUAL
35115: IFTRUE 35119
35117: GO 35134
35119: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35120: LD_EXP 52
35124: PPUSH
35125: LD_STRING DA1-Gary-1
35127: PPUSH
35128: CALL_OW 91
35132: GO 35276
35134: LD_EXP 55
35138: DOUBLE
35139: EQUAL
35140: IFTRUE 35144
35142: GO 35159
35144: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35145: LD_EXP 55
35149: PPUSH
35150: LD_STRING DA1-Con-1
35152: PPUSH
35153: CALL_OW 91
35157: GO 35276
35159: LD_EXP 64
35163: DOUBLE
35164: EQUAL
35165: IFTRUE 35169
35167: GO 35184
35169: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35170: LD_EXP 64
35174: PPUSH
35175: LD_STRING DA1-Kurt-1
35177: PPUSH
35178: CALL_OW 91
35182: GO 35276
35184: LD_EXP 54
35188: DOUBLE
35189: EQUAL
35190: IFTRUE 35194
35192: GO 35209
35194: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35195: LD_EXP 54
35199: PPUSH
35200: LD_STRING DA1-Yam-1
35202: PPUSH
35203: CALL_OW 91
35207: GO 35276
35209: LD_EXP 53
35213: DOUBLE
35214: EQUAL
35215: IFTRUE 35219
35217: GO 35234
35219: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35220: LD_EXP 53
35224: PPUSH
35225: LD_STRING DA1-Frank-1
35227: PPUSH
35228: CALL_OW 91
35232: GO 35276
35234: POP
// begin if GetSex ( unit ) = sex_male then
35235: LD_VAR 0 1
35239: PPUSH
35240: CALL_OW 258
35244: PUSH
35245: LD_INT 1
35247: EQUAL
35248: IFFALSE 35264
// ForceSay ( unit , DA1-Sol1-1 ) else
35250: LD_VAR 0 1
35254: PPUSH
35255: LD_STRING DA1-Sol1-1
35257: PPUSH
35258: CALL_OW 91
35262: GO 35276
// ForceSay ( unit , DA1-FSol1-1 ) ;
35264: LD_VAR 0 1
35268: PPUSH
35269: LD_STRING DA1-FSol1-1
35271: PPUSH
35272: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35276: LD_EXP 79
35280: PPUSH
35281: LD_STRING DA-Roth-1
35283: PPUSH
35284: CALL_OW 88
// if capturedUnit = 1 then
35288: LD_EXP 34
35292: PUSH
35293: LD_INT 1
35295: EQUAL
35296: IFFALSE 35324
// begin Say ( Simms , DA-Sim-1 ) ;
35298: LD_EXP 80
35302: PPUSH
35303: LD_STRING DA-Sim-1
35305: PPUSH
35306: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35310: LD_EXP 79
35314: PPUSH
35315: LD_STRING DA-Roth-2
35317: PPUSH
35318: CALL_OW 88
// end else
35322: GO 35336
// Say ( Simms , DA-Sim-2 ) ;
35324: LD_EXP 80
35328: PPUSH
35329: LD_STRING DA-Sim-2
35331: PPUSH
35332: CALL_OW 88
// case unit of JMM :
35336: LD_VAR 0 1
35340: PUSH
35341: LD_EXP 40
35345: DOUBLE
35346: EQUAL
35347: IFTRUE 35351
35349: GO 35366
35351: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35352: LD_EXP 40
35356: PPUSH
35357: LD_STRING DA1-JMM-1a
35359: PPUSH
35360: CALL_OW 91
35364: GO 35883
35366: LD_EXP 41
35370: DOUBLE
35371: EQUAL
35372: IFTRUE 35376
35374: GO 35391
35376: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35377: LD_EXP 41
35381: PPUSH
35382: LD_STRING DA1-Joan-1a
35384: PPUSH
35385: CALL_OW 91
35389: GO 35883
35391: LD_EXP 43
35395: DOUBLE
35396: EQUAL
35397: IFTRUE 35401
35399: GO 35416
35401: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35402: LD_EXP 43
35406: PPUSH
35407: LD_STRING DA1-Lisa-1a
35409: PPUSH
35410: CALL_OW 91
35414: GO 35883
35416: LD_EXP 44
35420: DOUBLE
35421: EQUAL
35422: IFTRUE 35426
35424: GO 35441
35426: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35427: LD_EXP 44
35431: PPUSH
35432: LD_STRING DA1-Don-1a
35434: PPUSH
35435: CALL_OW 91
35439: GO 35883
35441: LD_EXP 51
35445: DOUBLE
35446: EQUAL
35447: IFTRUE 35451
35449: GO 35466
35451: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35452: LD_EXP 51
35456: PPUSH
35457: LD_STRING DA1-Corn-1a
35459: PPUSH
35460: CALL_OW 91
35464: GO 35883
35466: LD_EXP 47
35470: DOUBLE
35471: EQUAL
35472: IFTRUE 35476
35474: GO 35491
35476: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35477: LD_EXP 47
35481: PPUSH
35482: LD_STRING DA1-Den-1a
35484: PPUSH
35485: CALL_OW 91
35489: GO 35883
35491: LD_EXP 45
35495: DOUBLE
35496: EQUAL
35497: IFTRUE 35501
35499: GO 35516
35501: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35502: LD_EXP 45
35506: PPUSH
35507: LD_STRING DA1-Bobby-1a
35509: PPUSH
35510: CALL_OW 91
35514: GO 35883
35516: LD_EXP 49
35520: DOUBLE
35521: EQUAL
35522: IFTRUE 35526
35524: GO 35541
35526: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35527: LD_EXP 49
35531: PPUSH
35532: LD_STRING DA1-Glad-1a
35534: PPUSH
35535: CALL_OW 91
35539: GO 35883
35541: LD_EXP 46
35545: DOUBLE
35546: EQUAL
35547: IFTRUE 35551
35549: GO 35566
35551: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35552: LD_EXP 46
35556: PPUSH
35557: LD_STRING DA1-Cyrus-1a
35559: PPUSH
35560: CALL_OW 91
35564: GO 35883
35566: LD_EXP 42
35570: DOUBLE
35571: EQUAL
35572: IFTRUE 35576
35574: GO 35591
35576: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35577: LD_EXP 42
35581: PPUSH
35582: LD_STRING DA1-Huck-1a
35584: PPUSH
35585: CALL_OW 91
35589: GO 35883
35591: LD_EXP 56
35595: DOUBLE
35596: EQUAL
35597: IFTRUE 35601
35599: GO 35616
35601: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35602: LD_EXP 56
35606: PPUSH
35607: LD_STRING DA1-Huck-1a
35609: PPUSH
35610: CALL_OW 91
35614: GO 35883
35616: LD_EXP 48
35620: DOUBLE
35621: EQUAL
35622: IFTRUE 35626
35624: GO 35641
35626: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35627: LD_EXP 48
35631: PPUSH
35632: LD_STRING DA1-Brown-1a
35634: PPUSH
35635: CALL_OW 91
35639: GO 35883
35641: LD_EXP 52
35645: DOUBLE
35646: EQUAL
35647: IFTRUE 35651
35649: GO 35666
35651: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35652: LD_EXP 52
35656: PPUSH
35657: LD_STRING DA1-Gary-1a
35659: PPUSH
35660: CALL_OW 91
35664: GO 35883
35666: LD_EXP 55
35670: DOUBLE
35671: EQUAL
35672: IFTRUE 35676
35674: GO 35701
35676: POP
// if JMMGirl = 3 then
35677: LD_EXP 7
35681: PUSH
35682: LD_INT 3
35684: EQUAL
35685: IFFALSE 35699
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35687: LD_EXP 55
35691: PPUSH
35692: LD_STRING DA1-Con-1a
35694: PPUSH
35695: CALL_OW 91
35699: GO 35883
35701: LD_EXP 64
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35711
35709: GO 35726
35711: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35712: LD_EXP 64
35716: PPUSH
35717: LD_STRING DA1-Kurt-1a
35719: PPUSH
35720: CALL_OW 91
35724: GO 35883
35726: LD_EXP 54
35730: DOUBLE
35731: EQUAL
35732: IFTRUE 35736
35734: GO 35751
35736: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35737: LD_EXP 54
35741: PPUSH
35742: LD_STRING DA1-Yam-1a
35744: PPUSH
35745: CALL_OW 91
35749: GO 35883
35751: LD_EXP 53
35755: DOUBLE
35756: EQUAL
35757: IFTRUE 35761
35759: GO 35776
35761: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35762: LD_EXP 53
35766: PPUSH
35767: LD_STRING DA1-Frank-1a
35769: PPUSH
35770: CALL_OW 91
35774: GO 35883
35776: POP
// begin join := rand ( 0 , 1 ) ;
35777: LD_ADDR_VAR 0 3
35781: PUSH
35782: LD_INT 0
35784: PPUSH
35785: LD_INT 1
35787: PPUSH
35788: CALL_OW 12
35792: ST_TO_ADDR
// if join then
35793: LD_VAR 0 3
35797: IFFALSE 35842
// begin if GetSex ( unit ) = sex_male then
35799: LD_VAR 0 1
35803: PPUSH
35804: CALL_OW 258
35808: PUSH
35809: LD_INT 1
35811: EQUAL
35812: IFFALSE 35828
// ForceSay ( unit , DA1-Sol1-1b ) else
35814: LD_VAR 0 1
35818: PPUSH
35819: LD_STRING DA1-Sol1-1b
35821: PPUSH
35822: CALL_OW 91
35826: GO 35840
// ForceSay ( unit , DA1-FSol1-1b ) ;
35828: LD_VAR 0 1
35832: PPUSH
35833: LD_STRING DA1-FSol1-1b
35835: PPUSH
35836: CALL_OW 91
// end else
35840: GO 35883
// begin if GetSex ( unit ) = sex_male then
35842: LD_VAR 0 1
35846: PPUSH
35847: CALL_OW 258
35851: PUSH
35852: LD_INT 1
35854: EQUAL
35855: IFFALSE 35871
// ForceSay ( unit , DA1-Sol1-1a ) else
35857: LD_VAR 0 1
35861: PPUSH
35862: LD_STRING DA1-Sol1-1a
35864: PPUSH
35865: CALL_OW 91
35869: GO 35883
// ForceSay ( unit , DA1-FSol1-1a ) ;
35871: LD_VAR 0 1
35875: PPUSH
35876: LD_STRING DA1-FSol1-1a
35878: PPUSH
35879: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35883: LD_VAR 0 1
35887: PUSH
35888: LD_EXP 40
35892: EQUAL
35893: IFFALSE 35904
// begin YouLost ( JMMCaptured ) ;
35895: LD_STRING JMMCaptured
35897: PPUSH
35898: CALL_OW 104
// exit ;
35902: GO 36208
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
35904: LD_VAR 0 1
35908: PUSH
35909: LD_EXP 44
35913: PUSH
35914: LD_EXP 47
35918: PUSH
35919: LD_EXP 45
35923: PUSH
35924: LD_EXP 42
35928: PUSH
35929: LD_EXP 56
35933: PUSH
35934: LD_EXP 48
35938: PUSH
35939: LD_EXP 54
35943: PUSH
35944: LD_EXP 58
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: IN
35959: PUSH
35960: LD_VAR 0 3
35964: OR
35965: IFFALSE 36064
// begin Say ( Roth , DA-Roth-3 ) ;
35967: LD_EXP 79
35971: PPUSH
35972: LD_STRING DA-Roth-3
35974: PPUSH
35975: CALL_OW 88
// SetSide ( unit , 7 ) ;
35979: LD_VAR 0 1
35983: PPUSH
35984: LD_INT 7
35986: PPUSH
35987: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35991: LD_ADDR_EXP 102
35995: PUSH
35996: LD_EXP 102
36000: PPUSH
36001: LD_INT 1
36003: PPUSH
36004: LD_EXP 102
36008: PUSH
36009: LD_INT 1
36011: ARRAY
36012: PUSH
36013: LD_VAR 0 1
36017: ADD
36018: PPUSH
36019: CALL_OW 1
36023: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36024: LD_INT 260
36026: PPUSH
36027: LD_INT 235
36029: PPUSH
36030: LD_INT 1
36032: PPUSH
36033: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36037: LD_VAR 0 1
36041: PPUSH
36042: LD_INT 1000
36044: PPUSH
36045: CALL_OW 234
// DialogueOff ;
36049: CALL_OW 7
// ComFree ( unit ) ;
36053: LD_VAR 0 1
36057: PPUSH
36058: CALL_OW 139
// end else
36062: GO 36145
// begin Say ( Roth , DA-Roth-3a ) ;
36064: LD_EXP 79
36068: PPUSH
36069: LD_STRING DA-Roth-3a
36071: PPUSH
36072: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36076: LD_ADDR_EXP 35
36080: PUSH
36081: LD_EXP 35
36085: PUSH
36086: LD_VAR 0 1
36090: ADD
36091: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36092: LD_INT 260
36094: PPUSH
36095: LD_INT 235
36097: PPUSH
36098: LD_INT 1
36100: PPUSH
36101: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36105: LD_VAR 0 1
36109: PPUSH
36110: LD_INT 1000
36112: PPUSH
36113: CALL_OW 234
// DialogueOff ;
36117: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36121: LD_VAR 0 1
36125: PPUSH
36126: LD_INT 272
36128: PPUSH
36129: LD_INT 254
36131: PPUSH
36132: CALL_OW 111
// AddComHold ( unit ) ;
36136: LD_VAR 0 1
36140: PPUSH
36141: CALL_OW 200
// end ; if capturedUnit = 1 then
36145: LD_EXP 34
36149: PUSH
36150: LD_INT 1
36152: EQUAL
36153: IFFALSE 36208
// begin DialogueOn ;
36155: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36159: LD_EXP 40
36163: PPUSH
36164: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36168: LD_EXP 40
36172: PPUSH
36173: LD_STRING DAa-JMM-1
36175: PPUSH
36176: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36180: LD_EXP 40
36184: PPUSH
36185: LD_STRING DAa-JMM-1a
36187: PPUSH
36188: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36192: LD_EXP 40
36196: PPUSH
36197: LD_STRING DAa-JMM-1b
36199: PPUSH
36200: CALL_OW 88
// DialogueOff ;
36204: CALL_OW 7
// end ; end ;
36208: LD_VAR 0 2
36212: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36213: LD_EXP 15
36217: PUSH
36218: LD_INT 13
36220: GREATEREQUAL
36221: PUSH
36222: LD_INT 22
36224: PUSH
36225: LD_INT 2
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 21
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PPUSH
36246: CALL_OW 69
36250: PUSH
36251: LD_INT 0
36253: EQUAL
36254: AND
36255: PUSH
36256: LD_INT 22
36258: PUSH
36259: LD_INT 2
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 33
36268: PUSH
36269: LD_INT 5
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 21
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 50
36288: PUSH
36289: EMPTY
36290: LIST
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: PPUSH
36298: CALL_OW 69
36302: PUSH
36303: LD_INT 0
36305: EQUAL
36306: AND
36307: PUSH
36308: LD_EXP 21
36312: AND
36313: PUSH
36314: LD_EXP 22
36318: AND
36319: PUSH
36320: LD_EXP 23
36324: AND
36325: IFFALSE 37094
36327: GO 36329
36329: DISABLE
36330: LD_INT 0
36332: PPUSH
36333: PPUSH
36334: PPUSH
// begin wait ( 0 0$05 ) ;
36335: LD_INT 175
36337: PPUSH
36338: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
36342: LD_INT 22
36344: PUSH
36345: LD_INT 1
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 21
36354: PUSH
36355: LD_INT 1
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 23
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 50
36374: PUSH
36375: EMPTY
36376: LIST
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: LIST
36382: LIST
36383: PPUSH
36384: CALL_OW 69
36388: PPUSH
36389: CALL 71693 0 1
36393: PUSH
36394: LD_INT 2
36396: LESS
36397: IFFALSE 36408
// begin YouLost ( LostVictory ) ;
36399: LD_STRING LostVictory
36401: PPUSH
36402: CALL_OW 104
// exit ;
36406: GO 37094
// end ; m1 := false ;
36408: LD_ADDR_VAR 0 1
36412: PUSH
36413: LD_INT 0
36415: ST_TO_ADDR
// m2 := false ;
36416: LD_ADDR_VAR 0 2
36420: PUSH
36421: LD_INT 0
36423: ST_TO_ADDR
// m3 := false ;
36424: LD_ADDR_VAR 0 3
36428: PUSH
36429: LD_INT 0
36431: ST_TO_ADDR
// if not bombExploded then
36432: LD_EXP 37
36436: NOT
36437: IFFALSE 36446
// SetAchievement ( ACH_SIBROCKET ) ;
36439: LD_STRING ACH_SIBROCKET
36441: PPUSH
36442: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36446: LD_EXP 66
36450: PPUSH
36451: CALL_OW 255
36455: PUSH
36456: LD_INT 1
36458: EQUAL
36459: PUSH
36460: LD_EXP 66
36464: PPUSH
36465: CALL_OW 302
36469: AND
36470: IFFALSE 36486
// begin wait ( 3 ) ;
36472: LD_INT 3
36474: PPUSH
36475: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36479: LD_STRING ACH_OPO
36481: PPUSH
36482: CALL_OW 543
// end ; if tick <= 120 120$00 then
36486: LD_OWVAR 1
36490: PUSH
36491: LD_INT 252000
36493: LESSEQUAL
36494: IFFALSE 36510
// begin wait ( 3 ) ;
36496: LD_INT 3
36498: PPUSH
36499: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36503: LD_STRING ACH_ASPEED_15
36505: PPUSH
36506: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36510: LD_EXP 40
36514: PPUSH
36515: CALL_OW 87
// music_class := 5 ;
36519: LD_ADDR_OWVAR 72
36523: PUSH
36524: LD_INT 5
36526: ST_TO_ADDR
// music_nat := 5 ;
36527: LD_ADDR_OWVAR 71
36531: PUSH
36532: LD_INT 5
36534: ST_TO_ADDR
// DialogueOn ;
36535: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36539: LD_EXP 40
36543: PPUSH
36544: LD_STRING D20-JMM-1
36546: PPUSH
36547: CALL_OW 88
// if IsOK ( Joan ) then
36551: LD_EXP 41
36555: PPUSH
36556: CALL_OW 302
36560: IFFALSE 36574
// Say ( Joan , D20-Joan-1 ) ;
36562: LD_EXP 41
36566: PPUSH
36567: LD_STRING D20-Joan-1
36569: PPUSH
36570: CALL_OW 88
// if IsOk ( Lisa ) then
36574: LD_EXP 43
36578: PPUSH
36579: CALL_OW 302
36583: IFFALSE 36597
// Say ( Lisa , D20-Lisa-1 ) ;
36585: LD_EXP 43
36589: PPUSH
36590: LD_STRING D20-Lisa-1
36592: PPUSH
36593: CALL_OW 88
// if IsOk ( Donaldson ) then
36597: LD_EXP 44
36601: PPUSH
36602: CALL_OW 302
36606: IFFALSE 36620
// Say ( Donaldson , D20-Don-1 ) ;
36608: LD_EXP 44
36612: PPUSH
36613: LD_STRING D20-Don-1
36615: PPUSH
36616: CALL_OW 88
// if IsOK ( Cornel ) then
36620: LD_EXP 51
36624: PPUSH
36625: CALL_OW 302
36629: IFFALSE 36643
// Say ( Cornel , D20-Corn-1 ) ;
36631: LD_EXP 51
36635: PPUSH
36636: LD_STRING D20-Corn-1
36638: PPUSH
36639: CALL_OW 88
// if IsOk ( Denis ) then
36643: LD_EXP 47
36647: PPUSH
36648: CALL_OW 302
36652: IFFALSE 36666
// Say ( Denis , D20-Den-1 ) ;
36654: LD_EXP 47
36658: PPUSH
36659: LD_STRING D20-Den-1
36661: PPUSH
36662: CALL_OW 88
// if IsOk ( Bobby ) then
36666: LD_EXP 45
36670: PPUSH
36671: CALL_OW 302
36675: IFFALSE 36689
// Say ( Bobby , D20-Bobby-1 ) ;
36677: LD_EXP 45
36681: PPUSH
36682: LD_STRING D20-Bobby-1
36684: PPUSH
36685: CALL_OW 88
// if IsOk ( Gladstone ) then
36689: LD_EXP 49
36693: PPUSH
36694: CALL_OW 302
36698: IFFALSE 36712
// Say ( Gladstone , D20-Glad-1 ) ;
36700: LD_EXP 49
36704: PPUSH
36705: LD_STRING D20-Glad-1
36707: PPUSH
36708: CALL_OW 88
// if IsOk ( Cyrus ) then
36712: LD_EXP 46
36716: PPUSH
36717: CALL_OW 302
36721: IFFALSE 36735
// Say ( Cyrus , D20-Cyrus-1 ) ;
36723: LD_EXP 46
36727: PPUSH
36728: LD_STRING D20-Cyrus-1
36730: PPUSH
36731: CALL_OW 88
// if IsOk ( Stevens ) then
36735: LD_EXP 42
36739: PPUSH
36740: CALL_OW 302
36744: IFFALSE 36758
// Say ( Stevens , D20-Huck-1 ) ;
36746: LD_EXP 42
36750: PPUSH
36751: LD_STRING D20-Huck-1
36753: PPUSH
36754: CALL_OW 88
// if IsOk ( Brown ) then
36758: LD_EXP 48
36762: PPUSH
36763: CALL_OW 302
36767: IFFALSE 36781
// Say ( Brown , D20-Brown-1 ) ;
36769: LD_EXP 48
36773: PPUSH
36774: LD_STRING D20-Brown-1
36776: PPUSH
36777: CALL_OW 88
// if IsOk ( Gary ) then
36781: LD_EXP 52
36785: PPUSH
36786: CALL_OW 302
36790: IFFALSE 36804
// Say ( Gary , D20-Gary-1 ) ;
36792: LD_EXP 52
36796: PPUSH
36797: LD_STRING D20-Gary-1
36799: PPUSH
36800: CALL_OW 88
// if IsOk ( Connie ) then
36804: LD_EXP 55
36808: PPUSH
36809: CALL_OW 302
36813: IFFALSE 36827
// Say ( Connie , D20-Con-1 ) ;
36815: LD_EXP 55
36819: PPUSH
36820: LD_STRING D20-Con-1
36822: PPUSH
36823: CALL_OW 88
// if IsOk ( Kurt ) then
36827: LD_EXP 64
36831: PPUSH
36832: CALL_OW 302
36836: IFFALSE 36850
// Say ( Kurt , D20-Kurt-1 ) ;
36838: LD_EXP 64
36842: PPUSH
36843: LD_STRING D20-Kurt-1
36845: PPUSH
36846: CALL_OW 88
// if IsOk ( Kikuchi ) then
36850: LD_EXP 54
36854: PPUSH
36855: CALL_OW 302
36859: IFFALSE 36873
// Say ( Kikuchi , D20-Yam-1 ) ;
36861: LD_EXP 54
36865: PPUSH
36866: LD_STRING D20-Yam-1
36868: PPUSH
36869: CALL_OW 88
// if IsOk ( Frank ) then
36873: LD_EXP 53
36877: PPUSH
36878: CALL_OW 302
36882: IFFALSE 36896
// Say ( Frank , D20-Frank-1 ) ;
36884: LD_EXP 53
36888: PPUSH
36889: LD_STRING D20-Frank-1
36891: PPUSH
36892: CALL_OW 88
// DialogueOff ;
36896: CALL_OW 7
// if RothCaptured then
36900: LD_EXP 33
36904: IFFALSE 36926
// begin m1 := true ;
36906: LD_ADDR_VAR 0 1
36910: PUSH
36911: LD_INT 1
36913: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36914: LD_STRING Roth
36916: PPUSH
36917: LD_INT 1
36919: PPUSH
36920: CALL_OW 101
// end else
36924: GO 36937
// AddMedal ( Roth , - 1 ) ;
36926: LD_STRING Roth
36928: PPUSH
36929: LD_INT 1
36931: NEG
36932: PPUSH
36933: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36937: LD_EXP 25
36941: NOT
36942: PUSH
36943: LD_EXP 27
36947: OR
36948: PUSH
36949: LD_EXP 28
36953: NOT
36954: OR
36955: IFFALSE 36977
// begin m2 := true ;
36957: LD_ADDR_VAR 0 2
36961: PUSH
36962: LD_INT 1
36964: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36965: LD_STRING Project
36967: PPUSH
36968: LD_INT 1
36970: PPUSH
36971: CALL_OW 101
// end else
36975: GO 36988
// AddMedal ( Project , - 1 ) ;
36977: LD_STRING Project
36979: PPUSH
36980: LD_INT 1
36982: NEG
36983: PPUSH
36984: CALL_OW 101
// if lostCounter = 0 then
36988: LD_EXP 32
36992: PUSH
36993: LD_INT 0
36995: EQUAL
36996: IFFALSE 37018
// begin m3 := true ;
36998: LD_ADDR_VAR 0 3
37002: PUSH
37003: LD_INT 1
37005: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37006: LD_STRING NoLosses
37008: PPUSH
37009: LD_INT 1
37011: PPUSH
37012: CALL_OW 101
// end else
37016: GO 37029
// AddMedal ( NoLosses , - 1 ) ;
37018: LD_STRING NoLosses
37020: PPUSH
37021: LD_INT 1
37023: NEG
37024: PPUSH
37025: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37029: LD_VAR 0 1
37033: PUSH
37034: LD_VAR 0 2
37038: AND
37039: PUSH
37040: LD_VAR 0 3
37044: AND
37045: PUSH
37046: LD_OWVAR 67
37050: PUSH
37051: LD_INT 3
37053: GREATEREQUAL
37054: AND
37055: IFFALSE 37067
// SetAchievementEX ( ACH_AMER , 15 ) ;
37057: LD_STRING ACH_AMER
37059: PPUSH
37060: LD_INT 15
37062: PPUSH
37063: CALL_OW 564
// GiveMedals ( MAIN ) ;
37067: LD_STRING MAIN
37069: PPUSH
37070: CALL_OW 102
// music_class := 4 ;
37074: LD_ADDR_OWVAR 72
37078: PUSH
37079: LD_INT 4
37081: ST_TO_ADDR
// music_nat := 1 ;
37082: LD_ADDR_OWVAR 71
37086: PUSH
37087: LD_INT 1
37089: ST_TO_ADDR
// YouWin ;
37090: CALL_OW 103
// end ; end_of_file
37094: PPOPN 3
37096: END
// export function CustomEvent ( event ) ; begin
37097: LD_INT 0
37099: PPUSH
// end ;
37100: LD_VAR 0 2
37104: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37105: LD_VAR 0 1
37109: PUSH
37110: LD_INT 1
37112: EQUAL
37113: PUSH
37114: LD_VAR 0 2
37118: PUSH
37119: LD_INT 4
37121: EQUAL
37122: AND
37123: PUSH
37124: LD_EXP 61
37128: PPUSH
37129: CALL_OW 300
37133: AND
37134: IFFALSE 37150
// begin wait ( 0 0$2 ) ;
37136: LD_INT 70
37138: PPUSH
37139: CALL_OW 67
// YouLost ( Dismissed ) ;
37143: LD_STRING Dismissed
37145: PPUSH
37146: CALL_OW 104
// end ; end ;
37150: PPOPN 2
37152: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37153: LD_VAR 0 2
37157: PPUSH
37158: LD_VAR 0 3
37162: PPUSH
37163: LD_INT 18
37165: PPUSH
37166: CALL_OW 309
37170: IFFALSE 37179
// YouLost ( Motherlode3 ) ;
37172: LD_STRING Motherlode3
37174: PPUSH
37175: CALL_OW 104
// end ;
37179: PPOPN 3
37181: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37182: LD_EXP 27
37186: NOT
37187: IFFALSE 37197
// behemothDone := true ;
37189: LD_ADDR_EXP 28
37193: PUSH
37194: LD_INT 1
37196: ST_TO_ADDR
// end ;
37197: PPOPN 1
37199: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37200: LD_VAR 0 1
37204: PPUSH
37205: CALL_OW 255
37209: PUSH
37210: LD_INT 1
37212: EQUAL
37213: IFFALSE 37223
// bombExploded := true ;
37215: LD_ADDR_EXP 37
37219: PUSH
37220: LD_INT 1
37222: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37223: LD_VAR 0 1
37227: PPUSH
37228: CALL_OW 255
37232: PUSH
37233: LD_INT 3
37235: EQUAL
37236: IFFALSE 37266
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37238: LD_INT 2
37240: PPUSH
37241: LD_INT 23
37243: PUSH
37244: LD_INT 3
37246: PUSH
37247: LD_INT 3
37249: PUSH
37250: LD_INT 48
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: PUSH
37259: EMPTY
37260: LIST
37261: PPUSH
37262: CALL 63165 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37266: LD_VAR 0 1
37270: PPUSH
37271: CALL_OW 255
37275: PUSH
37276: LD_INT 1
37278: EQUAL
37279: PUSH
37280: LD_EXP 66
37284: PPUSH
37285: CALL_OW 255
37289: PUSH
37290: LD_INT 1
37292: EQUAL
37293: AND
37294: PUSH
37295: LD_EXP 66
37299: PPUSH
37300: CALL_OW 302
37304: AND
37305: PUSH
37306: LD_EXP 30
37310: AND
37311: PUSH
37312: LD_INT 22
37314: PUSH
37315: LD_INT 3
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 34
37324: PUSH
37325: LD_INT 48
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PPUSH
37336: CALL_OW 69
37340: AND
37341: PUSH
37342: LD_INT 22
37344: PUSH
37345: LD_INT 1
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 34
37354: PUSH
37355: LD_INT 8
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PPUSH
37366: CALL_OW 69
37370: NOT
37371: AND
37372: IFFALSE 37424
// begin wait ( 0 0$5 ) ;
37374: LD_INT 175
37376: PPUSH
37377: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37381: LD_INT 22
37383: PUSH
37384: LD_INT 3
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 34
37393: PUSH
37394: LD_INT 48
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PPUSH
37405: CALL_OW 69
37409: PUSH
37410: LD_INT 1
37412: ARRAY
37413: PPUSH
37414: LD_INT 60
37416: PPUSH
37417: LD_INT 95
37419: PPUSH
37420: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37424: LD_VAR 0 2
37428: PPUSH
37429: LD_VAR 0 3
37433: PPUSH
37434: LD_INT 18
37436: PPUSH
37437: CALL_OW 309
37441: PUSH
37442: LD_VAR 0 2
37446: PPUSH
37447: LD_VAR 0 3
37451: PPUSH
37452: LD_INT 18
37454: PPUSH
37455: CALL 111091 0 3
37459: OR
37460: IFFALSE 37507
// begin if GetSide ( unit ) = 1 then
37462: LD_VAR 0 1
37466: PPUSH
37467: CALL_OW 255
37471: PUSH
37472: LD_INT 1
37474: EQUAL
37475: IFFALSE 37493
// begin wait ( 0 0$6 ) ;
37477: LD_INT 210
37479: PPUSH
37480: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37484: LD_STRING Motherlode2
37486: PPUSH
37487: CALL_OW 104
// end else
37491: GO 37507
// begin wait ( 0 0$6 ) ;
37493: LD_INT 210
37495: PPUSH
37496: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37500: LD_STRING Motherlode1
37502: PPUSH
37503: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37507: LD_VAR 0 1
37511: PPUSH
37512: CALL_OW 255
37516: PUSH
37517: LD_INT 3
37519: EQUAL
37520: IFFALSE 37541
// begin wait ( 0 0$5 ) ;
37522: LD_INT 175
37524: PPUSH
37525: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37529: LD_EXP 68
37533: PPUSH
37534: LD_STRING D18-Pla-1
37536: PPUSH
37537: CALL_OW 94
// end ; end ;
37541: PPOPN 3
37543: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37544: LD_VAR 0 1
37548: PPUSH
37549: CALL 128181 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37553: LD_VAR 0 1
37557: PUSH
37558: LD_INT 22
37560: PUSH
37561: LD_INT 1
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 21
37570: PUSH
37571: LD_INT 1
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 23
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: LIST
37592: PPUSH
37593: CALL_OW 69
37597: IN
37598: IFFALSE 37614
// lostCounter := lostCounter + 1 ;
37600: LD_ADDR_EXP 32
37604: PUSH
37605: LD_EXP 32
37609: PUSH
37610: LD_INT 1
37612: PLUS
37613: ST_TO_ADDR
// if un in behemothBuilders then
37614: LD_VAR 0 1
37618: PUSH
37619: LD_EXP 77
37623: IN
37624: IFFALSE 37644
// begin behemothBuilders := behemothBuilders diff un ;
37626: LD_ADDR_EXP 77
37630: PUSH
37631: LD_EXP 77
37635: PUSH
37636: LD_VAR 0 1
37640: DIFF
37641: ST_TO_ADDR
// exit ;
37642: GO 37674
// end ; if un = JMM then
37644: LD_VAR 0 1
37648: PUSH
37649: LD_EXP 40
37653: EQUAL
37654: IFFALSE 37665
// begin YouLost ( JMM ) ;
37656: LD_STRING JMM
37658: PPUSH
37659: CALL_OW 104
// exit ;
37663: GO 37674
// end ; MCE_UnitDestroyed ( un ) ;
37665: LD_VAR 0 1
37669: PPUSH
37670: CALL 66607 0 1
// end ;
37674: PPOPN 1
37676: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37677: LD_VAR 0 1
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: CALL 68939 0 2
// end ;
37691: PPOPN 2
37693: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37694: LD_VAR 0 1
37698: PPUSH
37699: CALL 68007 0 1
// end ;
37703: PPOPN 1
37705: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37706: LD_VAR 0 1
37710: PUSH
37711: LD_INT 22
37713: PUSH
37714: LD_INT 8
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 30
37723: PUSH
37724: LD_INT 2
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 23
37733: PUSH
37734: LD_INT 3
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: LIST
37745: PPUSH
37746: CALL_OW 69
37750: IN
37751: IFFALSE 37778
// begin ComUpgrade ( building ) ;
37753: LD_VAR 0 1
37757: PPUSH
37758: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37762: LD_EXP 65
37766: PPUSH
37767: LD_VAR 0 1
37771: PPUSH
37772: CALL 77791 0 2
// exit ;
37776: GO 37787
// end ; MCE_BuildingComplete ( building ) ;
37778: LD_VAR 0 1
37782: PPUSH
37783: CALL 68248 0 1
// end ;
37787: PPOPN 1
37789: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37790: LD_VAR 0 1
37794: PPUSH
37795: LD_VAR 0 2
37799: PPUSH
37800: CALL 66303 0 2
// end ;
37804: PPOPN 2
37806: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37807: LD_VAR 0 1
37811: PPUSH
37812: LD_VAR 0 2
37816: PPUSH
37817: LD_VAR 0 3
37821: PPUSH
37822: LD_VAR 0 4
37826: PPUSH
37827: LD_VAR 0 5
37831: PPUSH
37832: CALL 65923 0 5
// end ;
37836: PPOPN 5
37838: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37839: LD_VAR 0 1
37843: PPUSH
37844: CALL_OW 255
37848: PUSH
37849: LD_INT 1
37851: EQUAL
37852: IFFALSE 37869
// amConstructCounter := Inc ( amConstructCounter ) ;
37854: LD_ADDR_EXP 39
37858: PUSH
37859: LD_EXP 39
37863: PPUSH
37864: CALL 108643 0 1
37868: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37869: LD_VAR 0 1
37873: PPUSH
37874: LD_VAR 0 2
37878: PPUSH
37879: CALL 128301 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37883: LD_VAR 0 1
37887: PPUSH
37888: LD_VAR 0 2
37892: PPUSH
37893: CALL 65476 0 2
// end ;
37897: PPOPN 2
37899: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37900: LD_VAR 0 1
37904: PPUSH
37905: LD_VAR 0 2
37909: PPUSH
37910: LD_VAR 0 3
37914: PPUSH
37915: LD_VAR 0 4
37919: PPUSH
37920: CALL 65314 0 4
// end ;
37924: PPOPN 4
37926: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37927: LD_VAR 0 1
37931: PPUSH
37932: LD_VAR 0 2
37936: PPUSH
37937: LD_VAR 0 3
37941: PPUSH
37942: CALL 65089 0 3
// end ;
37946: PPOPN 3
37948: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37949: LD_VAR 0 1
37953: PPUSH
37954: LD_VAR 0 2
37958: PPUSH
37959: CALL 64974 0 2
// end ;
37963: PPOPN 2
37965: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37966: LD_VAR 0 1
37970: PPUSH
37971: LD_VAR 0 2
37975: PPUSH
37976: CALL 69234 0 2
// end ;
37980: PPOPN 2
37982: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37983: LD_VAR 0 1
37987: PUSH
37988: LD_INT 460
37990: EQUAL
37991: IFFALSE 38013
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37993: LD_VAR 0 2
37997: PPUSH
37998: LD_INT 227
38000: PPUSH
38001: LD_INT 136
38003: PPUSH
38004: CALL_OW 428
38008: PPUSH
38009: CALL_OW 120
// end ;
38013: PPOPN 2
38015: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38016: LD_VAR 0 1
38020: PPUSH
38021: CALL_OW 255
38025: PUSH
38026: LD_INT 4
38028: EQUAL
38029: PUSH
38030: LD_VAR 0 1
38034: PUSH
38035: LD_EXP 18
38039: PUSH
38040: LD_INT 1
38042: ARRAY
38043: IN
38044: AND
38045: PUSH
38046: LD_EXP 19
38050: AND
38051: IFFALSE 38070
// begin ComMoveXY ( driver , 61 , 93 ) ;
38053: LD_VAR 0 1
38057: PPUSH
38058: LD_INT 61
38060: PPUSH
38061: LD_INT 93
38063: PPUSH
38064: CALL_OW 111
// exit ;
38068: GO 38139
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38070: LD_VAR 0 1
38074: PPUSH
38075: CALL_OW 255
38079: PUSH
38080: LD_INT 3
38082: EQUAL
38083: PUSH
38084: LD_VAR 0 1
38088: PPUSH
38089: CALL_OW 110
38093: PUSH
38094: LD_INT 105
38096: EQUAL
38097: AND
38098: IFFALSE 38115
// begin ComMoveXY ( driver , 187 , 92 ) ;
38100: LD_VAR 0 1
38104: PPUSH
38105: LD_INT 187
38107: PPUSH
38108: LD_INT 92
38110: PPUSH
38111: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38115: LD_VAR 0 1
38119: PPUSH
38120: LD_VAR 0 2
38124: PPUSH
38125: LD_VAR 0 3
38129: PPUSH
38130: LD_VAR 0 4
38134: PPUSH
38135: CALL 69450 0 4
// end ;
38139: PPOPN 4
38141: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38142: LD_VAR 0 1
38146: PPUSH
38147: LD_VAR 0 2
38151: PPUSH
38152: CALL 64783 0 2
// end ;
38156: PPOPN 2
38158: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38159: LD_VAR 0 1
38163: PPUSH
38164: CALL 128285 0 1
// end ; end_of_file
38168: PPOPN 1
38170: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38171: LD_EXP 15
38175: PUSH
38176: LD_INT 2
38178: EQUAL
38179: IFFALSE 38696
38181: GO 38183
38183: DISABLE
38184: LD_INT 0
38186: PPUSH
38187: PPUSH
// begin time := 0 0$35 ;
38188: LD_ADDR_VAR 0 2
38192: PUSH
38193: LD_INT 1225
38195: ST_TO_ADDR
// repeat wait ( time ) ;
38196: LD_VAR 0 2
38200: PPUSH
38201: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38205: LD_INT 1
38207: PPUSH
38208: LD_INT 5
38210: PPUSH
38211: CALL_OW 12
38215: PPUSH
38216: LD_INT 106
38218: PPUSH
38219: LD_INT 150
38221: PPUSH
38222: LD_INT 19
38224: PPUSH
38225: LD_INT 1
38227: PPUSH
38228: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38232: LD_INT 455
38234: PPUSH
38235: LD_INT 770
38237: PPUSH
38238: CALL_OW 12
38242: PPUSH
38243: CALL_OW 67
// if Prob ( 50 ) then
38247: LD_INT 50
38249: PPUSH
38250: CALL_OW 13
38254: IFFALSE 38283
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38256: LD_INT 1
38258: PPUSH
38259: LD_INT 5
38261: PPUSH
38262: CALL_OW 12
38266: PPUSH
38267: LD_INT 62
38269: PPUSH
38270: LD_INT 108
38272: PPUSH
38273: LD_INT 10
38275: PPUSH
38276: LD_INT 1
38278: PPUSH
38279: CALL_OW 56
// until missionStage > 4 ;
38283: LD_EXP 15
38287: PUSH
38288: LD_INT 4
38290: GREATER
38291: IFFALSE 38196
// repeat wait ( 0 0$1 ) ;
38293: LD_INT 35
38295: PPUSH
38296: CALL_OW 67
// until missionStage = 6 ;
38300: LD_EXP 15
38304: PUSH
38305: LD_INT 6
38307: EQUAL
38308: IFFALSE 38293
// time := 0 0$20 ;
38310: LD_ADDR_VAR 0 2
38314: PUSH
38315: LD_INT 700
38317: ST_TO_ADDR
// repeat wait ( time ) ;
38318: LD_VAR 0 2
38322: PPUSH
38323: CALL_OW 67
// if Prob ( 90 ) then
38327: LD_INT 90
38329: PPUSH
38330: CALL_OW 13
38334: IFFALSE 38377
// begin time := time + 0 0$2 ;
38336: LD_ADDR_VAR 0 2
38340: PUSH
38341: LD_VAR 0 2
38345: PUSH
38346: LD_INT 70
38348: PLUS
38349: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38350: LD_INT 1
38352: PPUSH
38353: LD_INT 5
38355: PPUSH
38356: CALL_OW 12
38360: PPUSH
38361: LD_INT 106
38363: PPUSH
38364: LD_INT 89
38366: PPUSH
38367: LD_INT 45
38369: PPUSH
38370: LD_INT 1
38372: PPUSH
38373: CALL_OW 56
// end ; if Prob ( 45 ) then
38377: LD_INT 45
38379: PPUSH
38380: CALL_OW 13
38384: IFFALSE 38440
// begin for i := 1 to 4 do
38386: LD_ADDR_VAR 0 1
38390: PUSH
38391: DOUBLE
38392: LD_INT 1
38394: DEC
38395: ST_TO_ADDR
38396: LD_INT 4
38398: PUSH
38399: FOR_TO
38400: IFFALSE 38438
// begin wait ( 0 0$5 ) ;
38402: LD_INT 175
38404: PPUSH
38405: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38409: LD_INT 1
38411: PPUSH
38412: LD_INT 5
38414: PPUSH
38415: CALL_OW 12
38419: PPUSH
38420: LD_INT 113
38422: PPUSH
38423: LD_INT 117
38425: PPUSH
38426: LD_INT 25
38428: PPUSH
38429: LD_INT 1
38431: PPUSH
38432: CALL_OW 56
// end ;
38436: GO 38399
38438: POP
38439: POP
// end ; if Prob ( 40 ) then
38440: LD_INT 40
38442: PPUSH
38443: CALL_OW 13
38447: IFFALSE 38493
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38449: LD_INT 385
38451: PPUSH
38452: LD_INT 945
38454: PPUSH
38455: CALL_OW 12
38459: PPUSH
38460: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38464: LD_INT 1
38466: PPUSH
38467: LD_INT 5
38469: PPUSH
38470: CALL_OW 12
38474: PPUSH
38475: LD_INT 21
38477: PPUSH
38478: LD_INT 26
38480: PPUSH
38481: LD_INT 12
38483: PPUSH
38484: LD_INT 1
38486: PPUSH
38487: CALL_OW 56
// end else
38491: GO 38529
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38493: LD_INT 700
38495: PPUSH
38496: LD_INT 1225
38498: PPUSH
38499: CALL_OW 12
38503: PPUSH
38504: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38508: LD_INT 1
38510: PPUSH
38511: LD_INT 5
38513: PPUSH
38514: CALL_OW 12
38518: PPUSH
38519: LD_INT 16
38521: PPUSH
38522: LD_INT 1
38524: PPUSH
38525: CALL_OW 55
// end ; if Prob ( 50 ) then
38529: LD_INT 50
38531: PPUSH
38532: CALL_OW 13
38536: IFFALSE 38582
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38538: LD_INT 700
38540: PPUSH
38541: LD_INT 1050
38543: PPUSH
38544: CALL_OW 12
38548: PPUSH
38549: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38553: LD_INT 1
38555: PPUSH
38556: LD_INT 5
38558: PPUSH
38559: CALL_OW 12
38563: PPUSH
38564: LD_INT 168
38566: PPUSH
38567: LD_INT 168
38569: PPUSH
38570: LD_INT 16
38572: PPUSH
38573: LD_INT 1
38575: PPUSH
38576: CALL_OW 56
// end else
38580: GO 38618
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38582: LD_INT 350
38584: PPUSH
38585: LD_INT 525
38587: PPUSH
38588: CALL_OW 12
38592: PPUSH
38593: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38597: LD_INT 1
38599: PPUSH
38600: LD_INT 5
38602: PPUSH
38603: CALL_OW 12
38607: PPUSH
38608: LD_INT 15
38610: PPUSH
38611: LD_INT 1
38613: PPUSH
38614: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38618: LD_INT 175
38620: PPUSH
38621: LD_INT 315
38623: PPUSH
38624: CALL_OW 12
38628: PPUSH
38629: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38633: LD_INT 1
38635: PPUSH
38636: LD_INT 5
38638: PPUSH
38639: CALL_OW 12
38643: PPUSH
38644: LD_INT 103
38646: PPUSH
38647: LD_INT 140
38649: PPUSH
38650: LD_INT 20
38652: PPUSH
38653: LD_INT 1
38655: PPUSH
38656: CALL_OW 56
// time := time + 0 0$2 ;
38660: LD_ADDR_VAR 0 2
38664: PUSH
38665: LD_VAR 0 2
38669: PUSH
38670: LD_INT 70
38672: PLUS
38673: ST_TO_ADDR
// if time > 1 1$20 then
38674: LD_VAR 0 2
38678: PUSH
38679: LD_INT 2800
38681: GREATER
38682: IFFALSE 38692
// time := 0 0$30 ;
38684: LD_ADDR_VAR 0 2
38688: PUSH
38689: LD_INT 1050
38691: ST_TO_ADDR
// until false ;
38692: LD_INT 0
38694: IFFALSE 38318
// end ; end_of_file
38696: PPOPN 2
38698: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38699: LD_EXP 13
38703: PUSH
38704: LD_EXP 15
38708: PUSH
38709: LD_INT 6
38711: GREATEREQUAL
38712: AND
38713: IFFALSE 38750
38715: GO 38717
38717: DISABLE
// begin enable ;
38718: ENABLE
// missionTime := missionTime + 0 0$1 ;
38719: LD_ADDR_EXP 14
38723: PUSH
38724: LD_EXP 14
38728: PUSH
38729: LD_INT 35
38731: PLUS
38732: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38733: LD_ADDR_OWVAR 47
38737: PUSH
38738: LD_STRING #Am15-1
38740: PUSH
38741: LD_EXP 14
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: ST_TO_ADDR
// end ; end_of_file
38750: END
// export function InitNature ; begin
38751: LD_INT 0
38753: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38754: LD_INT 3
38756: PPUSH
38757: LD_INT 3
38759: PPUSH
38760: LD_INT 2
38762: PPUSH
38763: LD_INT 1
38765: PPUSH
38766: LD_INT 1
38768: PPUSH
38769: LD_INT 0
38771: PPUSH
38772: LD_INT 0
38774: PPUSH
38775: LD_INT 20
38777: PPUSH
38778: LD_INT 0
38780: PPUSH
38781: CALL 103959 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38785: LD_INT 2
38787: PPUSH
38788: LD_INT 1
38790: PPUSH
38791: LD_INT 1
38793: PPUSH
38794: LD_INT 1
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: LD_INT 0
38802: PPUSH
38803: LD_INT 0
38805: PPUSH
38806: LD_INT 21
38808: PPUSH
38809: LD_INT 0
38811: PPUSH
38812: CALL 103959 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38816: LD_INT 4
38818: PPUSH
38819: LD_INT 1
38821: PPUSH
38822: LD_INT 2
38824: PPUSH
38825: LD_INT 4
38827: PPUSH
38828: LD_INT 2
38830: PPUSH
38831: LD_INT 1
38833: PPUSH
38834: LD_INT 0
38836: PPUSH
38837: LD_INT 22
38839: PPUSH
38840: LD_INT 0
38842: PPUSH
38843: CALL 103959 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38847: LD_INT 0
38849: PPUSH
38850: LD_INT 0
38852: PPUSH
38853: LD_INT 0
38855: PPUSH
38856: LD_INT 0
38858: PPUSH
38859: LD_INT 0
38861: PPUSH
38862: LD_INT 0
38864: PPUSH
38865: LD_INT 9
38867: PPUSH
38868: LD_INT 0
38870: PPUSH
38871: LD_INT 23
38873: PPUSH
38874: CALL 103959 0 9
// end ; end_of_file
38878: LD_VAR 0 1
38882: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38883: LD_INT 0
38885: PPUSH
38886: PPUSH
// skirmish := false ;
38887: LD_ADDR_EXP 100
38891: PUSH
38892: LD_INT 0
38894: ST_TO_ADDR
// debug_mc := false ;
38895: LD_ADDR_EXP 101
38899: PUSH
38900: LD_INT 0
38902: ST_TO_ADDR
// mc_bases := [ ] ;
38903: LD_ADDR_EXP 102
38907: PUSH
38908: EMPTY
38909: ST_TO_ADDR
// mc_sides := [ ] ;
38910: LD_ADDR_EXP 128
38914: PUSH
38915: EMPTY
38916: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38917: LD_ADDR_EXP 103
38921: PUSH
38922: EMPTY
38923: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38924: LD_ADDR_EXP 104
38928: PUSH
38929: EMPTY
38930: ST_TO_ADDR
// mc_need_heal := [ ] ;
38931: LD_ADDR_EXP 105
38935: PUSH
38936: EMPTY
38937: ST_TO_ADDR
// mc_healers := [ ] ;
38938: LD_ADDR_EXP 106
38942: PUSH
38943: EMPTY
38944: ST_TO_ADDR
// mc_build_list := [ ] ;
38945: LD_ADDR_EXP 107
38949: PUSH
38950: EMPTY
38951: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38952: LD_ADDR_EXP 134
38956: PUSH
38957: EMPTY
38958: ST_TO_ADDR
// mc_builders := [ ] ;
38959: LD_ADDR_EXP 108
38963: PUSH
38964: EMPTY
38965: ST_TO_ADDR
// mc_construct_list := [ ] ;
38966: LD_ADDR_EXP 109
38970: PUSH
38971: EMPTY
38972: ST_TO_ADDR
// mc_turret_list := [ ] ;
38973: LD_ADDR_EXP 110
38977: PUSH
38978: EMPTY
38979: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38980: LD_ADDR_EXP 111
38984: PUSH
38985: EMPTY
38986: ST_TO_ADDR
// mc_miners := [ ] ;
38987: LD_ADDR_EXP 116
38991: PUSH
38992: EMPTY
38993: ST_TO_ADDR
// mc_mines := [ ] ;
38994: LD_ADDR_EXP 115
38998: PUSH
38999: EMPTY
39000: ST_TO_ADDR
// mc_minefields := [ ] ;
39001: LD_ADDR_EXP 117
39005: PUSH
39006: EMPTY
39007: ST_TO_ADDR
// mc_crates := [ ] ;
39008: LD_ADDR_EXP 118
39012: PUSH
39013: EMPTY
39014: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39015: LD_ADDR_EXP 119
39019: PUSH
39020: EMPTY
39021: ST_TO_ADDR
// mc_crates_area := [ ] ;
39022: LD_ADDR_EXP 120
39026: PUSH
39027: EMPTY
39028: ST_TO_ADDR
// mc_vehicles := [ ] ;
39029: LD_ADDR_EXP 121
39033: PUSH
39034: EMPTY
39035: ST_TO_ADDR
// mc_attack := [ ] ;
39036: LD_ADDR_EXP 122
39040: PUSH
39041: EMPTY
39042: ST_TO_ADDR
// mc_produce := [ ] ;
39043: LD_ADDR_EXP 123
39047: PUSH
39048: EMPTY
39049: ST_TO_ADDR
// mc_defender := [ ] ;
39050: LD_ADDR_EXP 124
39054: PUSH
39055: EMPTY
39056: ST_TO_ADDR
// mc_parking := [ ] ;
39057: LD_ADDR_EXP 126
39061: PUSH
39062: EMPTY
39063: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39064: LD_ADDR_EXP 112
39068: PUSH
39069: EMPTY
39070: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39071: LD_ADDR_EXP 114
39075: PUSH
39076: EMPTY
39077: ST_TO_ADDR
// mc_scan := [ ] ;
39078: LD_ADDR_EXP 125
39082: PUSH
39083: EMPTY
39084: ST_TO_ADDR
// mc_scan_area := [ ] ;
39085: LD_ADDR_EXP 127
39089: PUSH
39090: EMPTY
39091: ST_TO_ADDR
// mc_tech := [ ] ;
39092: LD_ADDR_EXP 129
39096: PUSH
39097: EMPTY
39098: ST_TO_ADDR
// mc_class := [ ] ;
39099: LD_ADDR_EXP 143
39103: PUSH
39104: EMPTY
39105: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39106: LD_ADDR_EXP 144
39110: PUSH
39111: EMPTY
39112: ST_TO_ADDR
// mc_is_defending := [ ] ;
39113: LD_ADDR_EXP 145
39117: PUSH
39118: EMPTY
39119: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39120: LD_ADDR_EXP 136
39124: PUSH
39125: EMPTY
39126: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39127: LD_ADDR_EXP 146
39131: PUSH
39132: LD_INT 0
39134: ST_TO_ADDR
// end ;
39135: LD_VAR 0 1
39139: RET
// export function MC_Kill ( base ) ; begin
39140: LD_INT 0
39142: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39143: LD_ADDR_EXP 102
39147: PUSH
39148: LD_EXP 102
39152: PPUSH
39153: LD_VAR 0 1
39157: PPUSH
39158: EMPTY
39159: PPUSH
39160: CALL_OW 1
39164: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39165: LD_ADDR_EXP 103
39169: PUSH
39170: LD_EXP 103
39174: PPUSH
39175: LD_VAR 0 1
39179: PPUSH
39180: EMPTY
39181: PPUSH
39182: CALL_OW 1
39186: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39187: LD_ADDR_EXP 104
39191: PUSH
39192: LD_EXP 104
39196: PPUSH
39197: LD_VAR 0 1
39201: PPUSH
39202: EMPTY
39203: PPUSH
39204: CALL_OW 1
39208: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39209: LD_ADDR_EXP 105
39213: PUSH
39214: LD_EXP 105
39218: PPUSH
39219: LD_VAR 0 1
39223: PPUSH
39224: EMPTY
39225: PPUSH
39226: CALL_OW 1
39230: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39231: LD_ADDR_EXP 106
39235: PUSH
39236: LD_EXP 106
39240: PPUSH
39241: LD_VAR 0 1
39245: PPUSH
39246: EMPTY
39247: PPUSH
39248: CALL_OW 1
39252: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39253: LD_ADDR_EXP 107
39257: PUSH
39258: LD_EXP 107
39262: PPUSH
39263: LD_VAR 0 1
39267: PPUSH
39268: EMPTY
39269: PPUSH
39270: CALL_OW 1
39274: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39275: LD_ADDR_EXP 108
39279: PUSH
39280: LD_EXP 108
39284: PPUSH
39285: LD_VAR 0 1
39289: PPUSH
39290: EMPTY
39291: PPUSH
39292: CALL_OW 1
39296: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39297: LD_ADDR_EXP 109
39301: PUSH
39302: LD_EXP 109
39306: PPUSH
39307: LD_VAR 0 1
39311: PPUSH
39312: EMPTY
39313: PPUSH
39314: CALL_OW 1
39318: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39319: LD_ADDR_EXP 110
39323: PUSH
39324: LD_EXP 110
39328: PPUSH
39329: LD_VAR 0 1
39333: PPUSH
39334: EMPTY
39335: PPUSH
39336: CALL_OW 1
39340: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39341: LD_ADDR_EXP 111
39345: PUSH
39346: LD_EXP 111
39350: PPUSH
39351: LD_VAR 0 1
39355: PPUSH
39356: EMPTY
39357: PPUSH
39358: CALL_OW 1
39362: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39363: LD_ADDR_EXP 112
39367: PUSH
39368: LD_EXP 112
39372: PPUSH
39373: LD_VAR 0 1
39377: PPUSH
39378: EMPTY
39379: PPUSH
39380: CALL_OW 1
39384: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39385: LD_ADDR_EXP 113
39389: PUSH
39390: LD_EXP 113
39394: PPUSH
39395: LD_VAR 0 1
39399: PPUSH
39400: LD_INT 0
39402: PPUSH
39403: CALL_OW 1
39407: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39408: LD_ADDR_EXP 114
39412: PUSH
39413: LD_EXP 114
39417: PPUSH
39418: LD_VAR 0 1
39422: PPUSH
39423: EMPTY
39424: PPUSH
39425: CALL_OW 1
39429: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39430: LD_ADDR_EXP 115
39434: PUSH
39435: LD_EXP 115
39439: PPUSH
39440: LD_VAR 0 1
39444: PPUSH
39445: EMPTY
39446: PPUSH
39447: CALL_OW 1
39451: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39452: LD_ADDR_EXP 116
39456: PUSH
39457: LD_EXP 116
39461: PPUSH
39462: LD_VAR 0 1
39466: PPUSH
39467: EMPTY
39468: PPUSH
39469: CALL_OW 1
39473: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39474: LD_ADDR_EXP 117
39478: PUSH
39479: LD_EXP 117
39483: PPUSH
39484: LD_VAR 0 1
39488: PPUSH
39489: EMPTY
39490: PPUSH
39491: CALL_OW 1
39495: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39496: LD_ADDR_EXP 118
39500: PUSH
39501: LD_EXP 118
39505: PPUSH
39506: LD_VAR 0 1
39510: PPUSH
39511: EMPTY
39512: PPUSH
39513: CALL_OW 1
39517: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39518: LD_ADDR_EXP 119
39522: PUSH
39523: LD_EXP 119
39527: PPUSH
39528: LD_VAR 0 1
39532: PPUSH
39533: EMPTY
39534: PPUSH
39535: CALL_OW 1
39539: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39540: LD_ADDR_EXP 120
39544: PUSH
39545: LD_EXP 120
39549: PPUSH
39550: LD_VAR 0 1
39554: PPUSH
39555: EMPTY
39556: PPUSH
39557: CALL_OW 1
39561: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39562: LD_ADDR_EXP 121
39566: PUSH
39567: LD_EXP 121
39571: PPUSH
39572: LD_VAR 0 1
39576: PPUSH
39577: EMPTY
39578: PPUSH
39579: CALL_OW 1
39583: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39584: LD_ADDR_EXP 122
39588: PUSH
39589: LD_EXP 122
39593: PPUSH
39594: LD_VAR 0 1
39598: PPUSH
39599: EMPTY
39600: PPUSH
39601: CALL_OW 1
39605: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39606: LD_ADDR_EXP 123
39610: PUSH
39611: LD_EXP 123
39615: PPUSH
39616: LD_VAR 0 1
39620: PPUSH
39621: EMPTY
39622: PPUSH
39623: CALL_OW 1
39627: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39628: LD_ADDR_EXP 124
39632: PUSH
39633: LD_EXP 124
39637: PPUSH
39638: LD_VAR 0 1
39642: PPUSH
39643: EMPTY
39644: PPUSH
39645: CALL_OW 1
39649: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39650: LD_ADDR_EXP 125
39654: PUSH
39655: LD_EXP 125
39659: PPUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: EMPTY
39666: PPUSH
39667: CALL_OW 1
39671: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39672: LD_ADDR_EXP 126
39676: PUSH
39677: LD_EXP 126
39681: PPUSH
39682: LD_VAR 0 1
39686: PPUSH
39687: EMPTY
39688: PPUSH
39689: CALL_OW 1
39693: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39694: LD_ADDR_EXP 127
39698: PUSH
39699: LD_EXP 127
39703: PPUSH
39704: LD_VAR 0 1
39708: PPUSH
39709: EMPTY
39710: PPUSH
39711: CALL_OW 1
39715: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39716: LD_ADDR_EXP 129
39720: PUSH
39721: LD_EXP 129
39725: PPUSH
39726: LD_VAR 0 1
39730: PPUSH
39731: EMPTY
39732: PPUSH
39733: CALL_OW 1
39737: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39738: LD_ADDR_EXP 131
39742: PUSH
39743: LD_EXP 131
39747: PPUSH
39748: LD_VAR 0 1
39752: PPUSH
39753: EMPTY
39754: PPUSH
39755: CALL_OW 1
39759: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39760: LD_ADDR_EXP 132
39764: PUSH
39765: LD_EXP 132
39769: PPUSH
39770: LD_VAR 0 1
39774: PPUSH
39775: EMPTY
39776: PPUSH
39777: CALL_OW 1
39781: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39782: LD_ADDR_EXP 133
39786: PUSH
39787: LD_EXP 133
39791: PPUSH
39792: LD_VAR 0 1
39796: PPUSH
39797: EMPTY
39798: PPUSH
39799: CALL_OW 1
39803: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39804: LD_ADDR_EXP 134
39808: PUSH
39809: LD_EXP 134
39813: PPUSH
39814: LD_VAR 0 1
39818: PPUSH
39819: EMPTY
39820: PPUSH
39821: CALL_OW 1
39825: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39826: LD_ADDR_EXP 135
39830: PUSH
39831: LD_EXP 135
39835: PPUSH
39836: LD_VAR 0 1
39840: PPUSH
39841: EMPTY
39842: PPUSH
39843: CALL_OW 1
39847: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39848: LD_ADDR_EXP 136
39852: PUSH
39853: LD_EXP 136
39857: PPUSH
39858: LD_VAR 0 1
39862: PPUSH
39863: EMPTY
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39870: LD_ADDR_EXP 137
39874: PUSH
39875: LD_EXP 137
39879: PPUSH
39880: LD_VAR 0 1
39884: PPUSH
39885: EMPTY
39886: PPUSH
39887: CALL_OW 1
39891: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39892: LD_ADDR_EXP 138
39896: PUSH
39897: LD_EXP 138
39901: PPUSH
39902: LD_VAR 0 1
39906: PPUSH
39907: EMPTY
39908: PPUSH
39909: CALL_OW 1
39913: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39914: LD_ADDR_EXP 139
39918: PUSH
39919: LD_EXP 139
39923: PPUSH
39924: LD_VAR 0 1
39928: PPUSH
39929: EMPTY
39930: PPUSH
39931: CALL_OW 1
39935: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39936: LD_ADDR_EXP 140
39940: PUSH
39941: LD_EXP 140
39945: PPUSH
39946: LD_VAR 0 1
39950: PPUSH
39951: EMPTY
39952: PPUSH
39953: CALL_OW 1
39957: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39958: LD_ADDR_EXP 141
39962: PUSH
39963: LD_EXP 141
39967: PPUSH
39968: LD_VAR 0 1
39972: PPUSH
39973: EMPTY
39974: PPUSH
39975: CALL_OW 1
39979: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39980: LD_ADDR_EXP 142
39984: PUSH
39985: LD_EXP 142
39989: PPUSH
39990: LD_VAR 0 1
39994: PPUSH
39995: EMPTY
39996: PPUSH
39997: CALL_OW 1
40001: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40002: LD_ADDR_EXP 143
40006: PUSH
40007: LD_EXP 143
40011: PPUSH
40012: LD_VAR 0 1
40016: PPUSH
40017: EMPTY
40018: PPUSH
40019: CALL_OW 1
40023: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40024: LD_ADDR_EXP 144
40028: PUSH
40029: LD_EXP 144
40033: PPUSH
40034: LD_VAR 0 1
40038: PPUSH
40039: LD_INT 0
40041: PPUSH
40042: CALL_OW 1
40046: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40047: LD_ADDR_EXP 145
40051: PUSH
40052: LD_EXP 145
40056: PPUSH
40057: LD_VAR 0 1
40061: PPUSH
40062: LD_INT 0
40064: PPUSH
40065: CALL_OW 1
40069: ST_TO_ADDR
// end ;
40070: LD_VAR 0 2
40074: RET
// export function MC_Add ( side , units ) ; var base ; begin
40075: LD_INT 0
40077: PPUSH
40078: PPUSH
// base := mc_bases + 1 ;
40079: LD_ADDR_VAR 0 4
40083: PUSH
40084: LD_EXP 102
40088: PUSH
40089: LD_INT 1
40091: PLUS
40092: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40093: LD_ADDR_EXP 128
40097: PUSH
40098: LD_EXP 128
40102: PPUSH
40103: LD_VAR 0 4
40107: PPUSH
40108: LD_VAR 0 1
40112: PPUSH
40113: CALL_OW 1
40117: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40118: LD_ADDR_EXP 102
40122: PUSH
40123: LD_EXP 102
40127: PPUSH
40128: LD_VAR 0 4
40132: PPUSH
40133: LD_VAR 0 2
40137: PPUSH
40138: CALL_OW 1
40142: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40143: LD_ADDR_EXP 103
40147: PUSH
40148: LD_EXP 103
40152: PPUSH
40153: LD_VAR 0 4
40157: PPUSH
40158: EMPTY
40159: PPUSH
40160: CALL_OW 1
40164: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40165: LD_ADDR_EXP 104
40169: PUSH
40170: LD_EXP 104
40174: PPUSH
40175: LD_VAR 0 4
40179: PPUSH
40180: EMPTY
40181: PPUSH
40182: CALL_OW 1
40186: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40187: LD_ADDR_EXP 105
40191: PUSH
40192: LD_EXP 105
40196: PPUSH
40197: LD_VAR 0 4
40201: PPUSH
40202: EMPTY
40203: PPUSH
40204: CALL_OW 1
40208: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40209: LD_ADDR_EXP 106
40213: PUSH
40214: LD_EXP 106
40218: PPUSH
40219: LD_VAR 0 4
40223: PPUSH
40224: EMPTY
40225: PPUSH
40226: CALL_OW 1
40230: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40231: LD_ADDR_EXP 107
40235: PUSH
40236: LD_EXP 107
40240: PPUSH
40241: LD_VAR 0 4
40245: PPUSH
40246: EMPTY
40247: PPUSH
40248: CALL_OW 1
40252: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40253: LD_ADDR_EXP 108
40257: PUSH
40258: LD_EXP 108
40262: PPUSH
40263: LD_VAR 0 4
40267: PPUSH
40268: EMPTY
40269: PPUSH
40270: CALL_OW 1
40274: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40275: LD_ADDR_EXP 109
40279: PUSH
40280: LD_EXP 109
40284: PPUSH
40285: LD_VAR 0 4
40289: PPUSH
40290: EMPTY
40291: PPUSH
40292: CALL_OW 1
40296: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40297: LD_ADDR_EXP 110
40301: PUSH
40302: LD_EXP 110
40306: PPUSH
40307: LD_VAR 0 4
40311: PPUSH
40312: EMPTY
40313: PPUSH
40314: CALL_OW 1
40318: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40319: LD_ADDR_EXP 111
40323: PUSH
40324: LD_EXP 111
40328: PPUSH
40329: LD_VAR 0 4
40333: PPUSH
40334: EMPTY
40335: PPUSH
40336: CALL_OW 1
40340: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40341: LD_ADDR_EXP 112
40345: PUSH
40346: LD_EXP 112
40350: PPUSH
40351: LD_VAR 0 4
40355: PPUSH
40356: EMPTY
40357: PPUSH
40358: CALL_OW 1
40362: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40363: LD_ADDR_EXP 113
40367: PUSH
40368: LD_EXP 113
40372: PPUSH
40373: LD_VAR 0 4
40377: PPUSH
40378: LD_INT 0
40380: PPUSH
40381: CALL_OW 1
40385: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40386: LD_ADDR_EXP 114
40390: PUSH
40391: LD_EXP 114
40395: PPUSH
40396: LD_VAR 0 4
40400: PPUSH
40401: EMPTY
40402: PPUSH
40403: CALL_OW 1
40407: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40408: LD_ADDR_EXP 115
40412: PUSH
40413: LD_EXP 115
40417: PPUSH
40418: LD_VAR 0 4
40422: PPUSH
40423: EMPTY
40424: PPUSH
40425: CALL_OW 1
40429: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40430: LD_ADDR_EXP 116
40434: PUSH
40435: LD_EXP 116
40439: PPUSH
40440: LD_VAR 0 4
40444: PPUSH
40445: EMPTY
40446: PPUSH
40447: CALL_OW 1
40451: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40452: LD_ADDR_EXP 117
40456: PUSH
40457: LD_EXP 117
40461: PPUSH
40462: LD_VAR 0 4
40466: PPUSH
40467: EMPTY
40468: PPUSH
40469: CALL_OW 1
40473: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40474: LD_ADDR_EXP 118
40478: PUSH
40479: LD_EXP 118
40483: PPUSH
40484: LD_VAR 0 4
40488: PPUSH
40489: EMPTY
40490: PPUSH
40491: CALL_OW 1
40495: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40496: LD_ADDR_EXP 119
40500: PUSH
40501: LD_EXP 119
40505: PPUSH
40506: LD_VAR 0 4
40510: PPUSH
40511: EMPTY
40512: PPUSH
40513: CALL_OW 1
40517: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40518: LD_ADDR_EXP 120
40522: PUSH
40523: LD_EXP 120
40527: PPUSH
40528: LD_VAR 0 4
40532: PPUSH
40533: EMPTY
40534: PPUSH
40535: CALL_OW 1
40539: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40540: LD_ADDR_EXP 121
40544: PUSH
40545: LD_EXP 121
40549: PPUSH
40550: LD_VAR 0 4
40554: PPUSH
40555: EMPTY
40556: PPUSH
40557: CALL_OW 1
40561: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40562: LD_ADDR_EXP 122
40566: PUSH
40567: LD_EXP 122
40571: PPUSH
40572: LD_VAR 0 4
40576: PPUSH
40577: EMPTY
40578: PPUSH
40579: CALL_OW 1
40583: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40584: LD_ADDR_EXP 123
40588: PUSH
40589: LD_EXP 123
40593: PPUSH
40594: LD_VAR 0 4
40598: PPUSH
40599: EMPTY
40600: PPUSH
40601: CALL_OW 1
40605: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40606: LD_ADDR_EXP 124
40610: PUSH
40611: LD_EXP 124
40615: PPUSH
40616: LD_VAR 0 4
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL_OW 1
40627: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40628: LD_ADDR_EXP 125
40632: PUSH
40633: LD_EXP 125
40637: PPUSH
40638: LD_VAR 0 4
40642: PPUSH
40643: EMPTY
40644: PPUSH
40645: CALL_OW 1
40649: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40650: LD_ADDR_EXP 126
40654: PUSH
40655: LD_EXP 126
40659: PPUSH
40660: LD_VAR 0 4
40664: PPUSH
40665: EMPTY
40666: PPUSH
40667: CALL_OW 1
40671: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40672: LD_ADDR_EXP 127
40676: PUSH
40677: LD_EXP 127
40681: PPUSH
40682: LD_VAR 0 4
40686: PPUSH
40687: EMPTY
40688: PPUSH
40689: CALL_OW 1
40693: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40694: LD_ADDR_EXP 129
40698: PUSH
40699: LD_EXP 129
40703: PPUSH
40704: LD_VAR 0 4
40708: PPUSH
40709: EMPTY
40710: PPUSH
40711: CALL_OW 1
40715: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40716: LD_ADDR_EXP 131
40720: PUSH
40721: LD_EXP 131
40725: PPUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: EMPTY
40732: PPUSH
40733: CALL_OW 1
40737: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40738: LD_ADDR_EXP 132
40742: PUSH
40743: LD_EXP 132
40747: PPUSH
40748: LD_VAR 0 4
40752: PPUSH
40753: EMPTY
40754: PPUSH
40755: CALL_OW 1
40759: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40760: LD_ADDR_EXP 133
40764: PUSH
40765: LD_EXP 133
40769: PPUSH
40770: LD_VAR 0 4
40774: PPUSH
40775: EMPTY
40776: PPUSH
40777: CALL_OW 1
40781: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40782: LD_ADDR_EXP 134
40786: PUSH
40787: LD_EXP 134
40791: PPUSH
40792: LD_VAR 0 4
40796: PPUSH
40797: EMPTY
40798: PPUSH
40799: CALL_OW 1
40803: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40804: LD_ADDR_EXP 135
40808: PUSH
40809: LD_EXP 135
40813: PPUSH
40814: LD_VAR 0 4
40818: PPUSH
40819: EMPTY
40820: PPUSH
40821: CALL_OW 1
40825: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40826: LD_ADDR_EXP 136
40830: PUSH
40831: LD_EXP 136
40835: PPUSH
40836: LD_VAR 0 4
40840: PPUSH
40841: EMPTY
40842: PPUSH
40843: CALL_OW 1
40847: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40848: LD_ADDR_EXP 137
40852: PUSH
40853: LD_EXP 137
40857: PPUSH
40858: LD_VAR 0 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL_OW 1
40869: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40870: LD_ADDR_EXP 138
40874: PUSH
40875: LD_EXP 138
40879: PPUSH
40880: LD_VAR 0 4
40884: PPUSH
40885: EMPTY
40886: PPUSH
40887: CALL_OW 1
40891: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40892: LD_ADDR_EXP 139
40896: PUSH
40897: LD_EXP 139
40901: PPUSH
40902: LD_VAR 0 4
40906: PPUSH
40907: EMPTY
40908: PPUSH
40909: CALL_OW 1
40913: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40914: LD_ADDR_EXP 140
40918: PUSH
40919: LD_EXP 140
40923: PPUSH
40924: LD_VAR 0 4
40928: PPUSH
40929: EMPTY
40930: PPUSH
40931: CALL_OW 1
40935: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40936: LD_ADDR_EXP 141
40940: PUSH
40941: LD_EXP 141
40945: PPUSH
40946: LD_VAR 0 4
40950: PPUSH
40951: EMPTY
40952: PPUSH
40953: CALL_OW 1
40957: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40958: LD_ADDR_EXP 142
40962: PUSH
40963: LD_EXP 142
40967: PPUSH
40968: LD_VAR 0 4
40972: PPUSH
40973: EMPTY
40974: PPUSH
40975: CALL_OW 1
40979: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40980: LD_ADDR_EXP 143
40984: PUSH
40985: LD_EXP 143
40989: PPUSH
40990: LD_VAR 0 4
40994: PPUSH
40995: EMPTY
40996: PPUSH
40997: CALL_OW 1
41001: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41002: LD_ADDR_EXP 144
41006: PUSH
41007: LD_EXP 144
41011: PPUSH
41012: LD_VAR 0 4
41016: PPUSH
41017: LD_INT 0
41019: PPUSH
41020: CALL_OW 1
41024: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41025: LD_ADDR_EXP 145
41029: PUSH
41030: LD_EXP 145
41034: PPUSH
41035: LD_VAR 0 4
41039: PPUSH
41040: LD_INT 0
41042: PPUSH
41043: CALL_OW 1
41047: ST_TO_ADDR
// result := base ;
41048: LD_ADDR_VAR 0 3
41052: PUSH
41053: LD_VAR 0 4
41057: ST_TO_ADDR
// end ;
41058: LD_VAR 0 3
41062: RET
// export function MC_Start ( ) ; var i ; begin
41063: LD_INT 0
41065: PPUSH
41066: PPUSH
// for i = 1 to mc_bases do
41067: LD_ADDR_VAR 0 2
41071: PUSH
41072: DOUBLE
41073: LD_INT 1
41075: DEC
41076: ST_TO_ADDR
41077: LD_EXP 102
41081: PUSH
41082: FOR_TO
41083: IFFALSE 42183
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41085: LD_ADDR_EXP 102
41089: PUSH
41090: LD_EXP 102
41094: PPUSH
41095: LD_VAR 0 2
41099: PPUSH
41100: LD_EXP 102
41104: PUSH
41105: LD_VAR 0 2
41109: ARRAY
41110: PUSH
41111: LD_INT 0
41113: DIFF
41114: PPUSH
41115: CALL_OW 1
41119: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41120: LD_ADDR_EXP 103
41124: PUSH
41125: LD_EXP 103
41129: PPUSH
41130: LD_VAR 0 2
41134: PPUSH
41135: EMPTY
41136: PPUSH
41137: CALL_OW 1
41141: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41142: LD_ADDR_EXP 104
41146: PUSH
41147: LD_EXP 104
41151: PPUSH
41152: LD_VAR 0 2
41156: PPUSH
41157: EMPTY
41158: PPUSH
41159: CALL_OW 1
41163: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41164: LD_ADDR_EXP 105
41168: PUSH
41169: LD_EXP 105
41173: PPUSH
41174: LD_VAR 0 2
41178: PPUSH
41179: EMPTY
41180: PPUSH
41181: CALL_OW 1
41185: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41186: LD_ADDR_EXP 106
41190: PUSH
41191: LD_EXP 106
41195: PPUSH
41196: LD_VAR 0 2
41200: PPUSH
41201: EMPTY
41202: PUSH
41203: EMPTY
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PPUSH
41209: CALL_OW 1
41213: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41214: LD_ADDR_EXP 107
41218: PUSH
41219: LD_EXP 107
41223: PPUSH
41224: LD_VAR 0 2
41228: PPUSH
41229: EMPTY
41230: PPUSH
41231: CALL_OW 1
41235: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41236: LD_ADDR_EXP 134
41240: PUSH
41241: LD_EXP 134
41245: PPUSH
41246: LD_VAR 0 2
41250: PPUSH
41251: EMPTY
41252: PPUSH
41253: CALL_OW 1
41257: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41258: LD_ADDR_EXP 108
41262: PUSH
41263: LD_EXP 108
41267: PPUSH
41268: LD_VAR 0 2
41272: PPUSH
41273: EMPTY
41274: PPUSH
41275: CALL_OW 1
41279: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41280: LD_ADDR_EXP 109
41284: PUSH
41285: LD_EXP 109
41289: PPUSH
41290: LD_VAR 0 2
41294: PPUSH
41295: EMPTY
41296: PPUSH
41297: CALL_OW 1
41301: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41302: LD_ADDR_EXP 110
41306: PUSH
41307: LD_EXP 110
41311: PPUSH
41312: LD_VAR 0 2
41316: PPUSH
41317: LD_EXP 102
41321: PUSH
41322: LD_VAR 0 2
41326: ARRAY
41327: PPUSH
41328: LD_INT 2
41330: PUSH
41331: LD_INT 30
41333: PUSH
41334: LD_INT 32
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 30
41343: PUSH
41344: LD_INT 33
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: LIST
41355: PPUSH
41356: CALL_OW 72
41360: PPUSH
41361: CALL_OW 1
41365: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41366: LD_ADDR_EXP 111
41370: PUSH
41371: LD_EXP 111
41375: PPUSH
41376: LD_VAR 0 2
41380: PPUSH
41381: LD_EXP 102
41385: PUSH
41386: LD_VAR 0 2
41390: ARRAY
41391: PPUSH
41392: LD_INT 2
41394: PUSH
41395: LD_INT 30
41397: PUSH
41398: LD_INT 32
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 30
41407: PUSH
41408: LD_INT 31
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 58
41422: PUSH
41423: EMPTY
41424: LIST
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PPUSH
41430: CALL_OW 72
41434: PPUSH
41435: CALL_OW 1
41439: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41440: LD_ADDR_EXP 112
41444: PUSH
41445: LD_EXP 112
41449: PPUSH
41450: LD_VAR 0 2
41454: PPUSH
41455: EMPTY
41456: PPUSH
41457: CALL_OW 1
41461: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41462: LD_ADDR_EXP 116
41466: PUSH
41467: LD_EXP 116
41471: PPUSH
41472: LD_VAR 0 2
41476: PPUSH
41477: EMPTY
41478: PPUSH
41479: CALL_OW 1
41483: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41484: LD_ADDR_EXP 115
41488: PUSH
41489: LD_EXP 115
41493: PPUSH
41494: LD_VAR 0 2
41498: PPUSH
41499: EMPTY
41500: PPUSH
41501: CALL_OW 1
41505: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41506: LD_ADDR_EXP 117
41510: PUSH
41511: LD_EXP 117
41515: PPUSH
41516: LD_VAR 0 2
41520: PPUSH
41521: EMPTY
41522: PPUSH
41523: CALL_OW 1
41527: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41528: LD_ADDR_EXP 118
41532: PUSH
41533: LD_EXP 118
41537: PPUSH
41538: LD_VAR 0 2
41542: PPUSH
41543: EMPTY
41544: PPUSH
41545: CALL_OW 1
41549: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41550: LD_ADDR_EXP 119
41554: PUSH
41555: LD_EXP 119
41559: PPUSH
41560: LD_VAR 0 2
41564: PPUSH
41565: EMPTY
41566: PPUSH
41567: CALL_OW 1
41571: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41572: LD_ADDR_EXP 120
41576: PUSH
41577: LD_EXP 120
41581: PPUSH
41582: LD_VAR 0 2
41586: PPUSH
41587: EMPTY
41588: PPUSH
41589: CALL_OW 1
41593: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41594: LD_ADDR_EXP 121
41598: PUSH
41599: LD_EXP 121
41603: PPUSH
41604: LD_VAR 0 2
41608: PPUSH
41609: EMPTY
41610: PPUSH
41611: CALL_OW 1
41615: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41616: LD_ADDR_EXP 122
41620: PUSH
41621: LD_EXP 122
41625: PPUSH
41626: LD_VAR 0 2
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL_OW 1
41637: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41638: LD_ADDR_EXP 123
41642: PUSH
41643: LD_EXP 123
41647: PPUSH
41648: LD_VAR 0 2
41652: PPUSH
41653: EMPTY
41654: PPUSH
41655: CALL_OW 1
41659: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41660: LD_ADDR_EXP 124
41664: PUSH
41665: LD_EXP 124
41669: PPUSH
41670: LD_VAR 0 2
41674: PPUSH
41675: EMPTY
41676: PPUSH
41677: CALL_OW 1
41681: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41682: LD_ADDR_EXP 113
41686: PUSH
41687: LD_EXP 113
41691: PPUSH
41692: LD_VAR 0 2
41696: PPUSH
41697: LD_INT 0
41699: PPUSH
41700: CALL_OW 1
41704: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41705: LD_ADDR_EXP 126
41709: PUSH
41710: LD_EXP 126
41714: PPUSH
41715: LD_VAR 0 2
41719: PPUSH
41720: LD_INT 0
41722: PPUSH
41723: CALL_OW 1
41727: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41728: LD_ADDR_EXP 114
41732: PUSH
41733: LD_EXP 114
41737: PPUSH
41738: LD_VAR 0 2
41742: PPUSH
41743: EMPTY
41744: PPUSH
41745: CALL_OW 1
41749: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41750: LD_ADDR_EXP 125
41754: PUSH
41755: LD_EXP 125
41759: PPUSH
41760: LD_VAR 0 2
41764: PPUSH
41765: LD_INT 0
41767: PPUSH
41768: CALL_OW 1
41772: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41773: LD_ADDR_EXP 127
41777: PUSH
41778: LD_EXP 127
41782: PPUSH
41783: LD_VAR 0 2
41787: PPUSH
41788: EMPTY
41789: PPUSH
41790: CALL_OW 1
41794: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41795: LD_ADDR_EXP 130
41799: PUSH
41800: LD_EXP 130
41804: PPUSH
41805: LD_VAR 0 2
41809: PPUSH
41810: LD_INT 0
41812: PPUSH
41813: CALL_OW 1
41817: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41818: LD_ADDR_EXP 131
41822: PUSH
41823: LD_EXP 131
41827: PPUSH
41828: LD_VAR 0 2
41832: PPUSH
41833: EMPTY
41834: PPUSH
41835: CALL_OW 1
41839: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41840: LD_ADDR_EXP 132
41844: PUSH
41845: LD_EXP 132
41849: PPUSH
41850: LD_VAR 0 2
41854: PPUSH
41855: EMPTY
41856: PPUSH
41857: CALL_OW 1
41861: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41862: LD_ADDR_EXP 133
41866: PUSH
41867: LD_EXP 133
41871: PPUSH
41872: LD_VAR 0 2
41876: PPUSH
41877: EMPTY
41878: PPUSH
41879: CALL_OW 1
41883: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41884: LD_ADDR_EXP 135
41888: PUSH
41889: LD_EXP 135
41893: PPUSH
41894: LD_VAR 0 2
41898: PPUSH
41899: LD_EXP 102
41903: PUSH
41904: LD_VAR 0 2
41908: ARRAY
41909: PPUSH
41910: LD_INT 2
41912: PUSH
41913: LD_INT 30
41915: PUSH
41916: LD_INT 6
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 30
41925: PUSH
41926: LD_INT 7
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 30
41935: PUSH
41936: LD_INT 8
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: PPUSH
41949: CALL_OW 72
41953: PPUSH
41954: CALL_OW 1
41958: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41959: LD_ADDR_EXP 136
41963: PUSH
41964: LD_EXP 136
41968: PPUSH
41969: LD_VAR 0 2
41973: PPUSH
41974: EMPTY
41975: PPUSH
41976: CALL_OW 1
41980: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41981: LD_ADDR_EXP 137
41985: PUSH
41986: LD_EXP 137
41990: PPUSH
41991: LD_VAR 0 2
41995: PPUSH
41996: EMPTY
41997: PPUSH
41998: CALL_OW 1
42002: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42003: LD_ADDR_EXP 138
42007: PUSH
42008: LD_EXP 138
42012: PPUSH
42013: LD_VAR 0 2
42017: PPUSH
42018: EMPTY
42019: PPUSH
42020: CALL_OW 1
42024: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42025: LD_ADDR_EXP 139
42029: PUSH
42030: LD_EXP 139
42034: PPUSH
42035: LD_VAR 0 2
42039: PPUSH
42040: EMPTY
42041: PPUSH
42042: CALL_OW 1
42046: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42047: LD_ADDR_EXP 140
42051: PUSH
42052: LD_EXP 140
42056: PPUSH
42057: LD_VAR 0 2
42061: PPUSH
42062: EMPTY
42063: PPUSH
42064: CALL_OW 1
42068: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42069: LD_ADDR_EXP 141
42073: PUSH
42074: LD_EXP 141
42078: PPUSH
42079: LD_VAR 0 2
42083: PPUSH
42084: EMPTY
42085: PPUSH
42086: CALL_OW 1
42090: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42091: LD_ADDR_EXP 142
42095: PUSH
42096: LD_EXP 142
42100: PPUSH
42101: LD_VAR 0 2
42105: PPUSH
42106: EMPTY
42107: PPUSH
42108: CALL_OW 1
42112: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42113: LD_ADDR_EXP 143
42117: PUSH
42118: LD_EXP 143
42122: PPUSH
42123: LD_VAR 0 2
42127: PPUSH
42128: EMPTY
42129: PPUSH
42130: CALL_OW 1
42134: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42135: LD_ADDR_EXP 144
42139: PUSH
42140: LD_EXP 144
42144: PPUSH
42145: LD_VAR 0 2
42149: PPUSH
42150: LD_INT 0
42152: PPUSH
42153: CALL_OW 1
42157: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42158: LD_ADDR_EXP 145
42162: PUSH
42163: LD_EXP 145
42167: PPUSH
42168: LD_VAR 0 2
42172: PPUSH
42173: LD_INT 0
42175: PPUSH
42176: CALL_OW 1
42180: ST_TO_ADDR
// end ;
42181: GO 41082
42183: POP
42184: POP
// MC_InitSides ( ) ;
42185: CALL 42471 0 0
// MC_InitResearch ( ) ;
42189: CALL 42210 0 0
// CustomInitMacro ( ) ;
42193: CALL 475 0 0
// skirmish := true ;
42197: LD_ADDR_EXP 100
42201: PUSH
42202: LD_INT 1
42204: ST_TO_ADDR
// end ;
42205: LD_VAR 0 1
42209: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42210: LD_INT 0
42212: PPUSH
42213: PPUSH
42214: PPUSH
42215: PPUSH
42216: PPUSH
42217: PPUSH
// if not mc_bases then
42218: LD_EXP 102
42222: NOT
42223: IFFALSE 42227
// exit ;
42225: GO 42466
// for i = 1 to 8 do
42227: LD_ADDR_VAR 0 2
42231: PUSH
42232: DOUBLE
42233: LD_INT 1
42235: DEC
42236: ST_TO_ADDR
42237: LD_INT 8
42239: PUSH
42240: FOR_TO
42241: IFFALSE 42267
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42243: LD_ADDR_EXP 129
42247: PUSH
42248: LD_EXP 129
42252: PPUSH
42253: LD_VAR 0 2
42257: PPUSH
42258: EMPTY
42259: PPUSH
42260: CALL_OW 1
42264: ST_TO_ADDR
42265: GO 42240
42267: POP
42268: POP
// tmp := [ ] ;
42269: LD_ADDR_VAR 0 5
42273: PUSH
42274: EMPTY
42275: ST_TO_ADDR
// for i = 1 to mc_sides do
42276: LD_ADDR_VAR 0 2
42280: PUSH
42281: DOUBLE
42282: LD_INT 1
42284: DEC
42285: ST_TO_ADDR
42286: LD_EXP 128
42290: PUSH
42291: FOR_TO
42292: IFFALSE 42350
// if not mc_sides [ i ] in tmp then
42294: LD_EXP 128
42298: PUSH
42299: LD_VAR 0 2
42303: ARRAY
42304: PUSH
42305: LD_VAR 0 5
42309: IN
42310: NOT
42311: IFFALSE 42348
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42313: LD_ADDR_VAR 0 5
42317: PUSH
42318: LD_VAR 0 5
42322: PPUSH
42323: LD_VAR 0 5
42327: PUSH
42328: LD_INT 1
42330: PLUS
42331: PPUSH
42332: LD_EXP 128
42336: PUSH
42337: LD_VAR 0 2
42341: ARRAY
42342: PPUSH
42343: CALL_OW 2
42347: ST_TO_ADDR
42348: GO 42291
42350: POP
42351: POP
// if not tmp then
42352: LD_VAR 0 5
42356: NOT
42357: IFFALSE 42361
// exit ;
42359: GO 42466
// for j in tmp do
42361: LD_ADDR_VAR 0 3
42365: PUSH
42366: LD_VAR 0 5
42370: PUSH
42371: FOR_IN
42372: IFFALSE 42464
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42374: LD_ADDR_VAR 0 6
42378: PUSH
42379: LD_INT 22
42381: PUSH
42382: LD_VAR 0 3
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PPUSH
42391: CALL_OW 69
42395: ST_TO_ADDR
// if not un then
42396: LD_VAR 0 6
42400: NOT
42401: IFFALSE 42405
// continue ;
42403: GO 42371
// nation := GetNation ( un [ 1 ] ) ;
42405: LD_ADDR_VAR 0 4
42409: PUSH
42410: LD_VAR 0 6
42414: PUSH
42415: LD_INT 1
42417: ARRAY
42418: PPUSH
42419: CALL_OW 248
42423: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42424: LD_ADDR_EXP 129
42428: PUSH
42429: LD_EXP 129
42433: PPUSH
42434: LD_VAR 0 3
42438: PPUSH
42439: LD_VAR 0 3
42443: PPUSH
42444: LD_VAR 0 4
42448: PPUSH
42449: LD_INT 1
42451: PPUSH
42452: CALL 69654 0 3
42456: PPUSH
42457: CALL_OW 1
42461: ST_TO_ADDR
// end ;
42462: GO 42371
42464: POP
42465: POP
// end ;
42466: LD_VAR 0 1
42470: RET
// export function MC_InitSides ( ) ; var i ; begin
42471: LD_INT 0
42473: PPUSH
42474: PPUSH
// if not mc_bases then
42475: LD_EXP 102
42479: NOT
42480: IFFALSE 42484
// exit ;
42482: GO 42558
// for i = 1 to mc_bases do
42484: LD_ADDR_VAR 0 2
42488: PUSH
42489: DOUBLE
42490: LD_INT 1
42492: DEC
42493: ST_TO_ADDR
42494: LD_EXP 102
42498: PUSH
42499: FOR_TO
42500: IFFALSE 42556
// if mc_bases [ i ] then
42502: LD_EXP 102
42506: PUSH
42507: LD_VAR 0 2
42511: ARRAY
42512: IFFALSE 42554
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42514: LD_ADDR_EXP 128
42518: PUSH
42519: LD_EXP 128
42523: PPUSH
42524: LD_VAR 0 2
42528: PPUSH
42529: LD_EXP 102
42533: PUSH
42534: LD_VAR 0 2
42538: ARRAY
42539: PUSH
42540: LD_INT 1
42542: ARRAY
42543: PPUSH
42544: CALL_OW 255
42548: PPUSH
42549: CALL_OW 1
42553: ST_TO_ADDR
42554: GO 42499
42556: POP
42557: POP
// end ;
42558: LD_VAR 0 1
42562: RET
// every 0 0$03 trigger skirmish do
42563: LD_EXP 100
42567: IFFALSE 42721
42569: GO 42571
42571: DISABLE
// begin enable ;
42572: ENABLE
// MC_CheckBuildings ( ) ;
42573: CALL 47233 0 0
// MC_CheckPeopleLife ( ) ;
42577: CALL 47394 0 0
// RaiseSailEvent ( 100 ) ;
42581: LD_INT 100
42583: PPUSH
42584: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42588: LD_INT 103
42590: PPUSH
42591: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42595: LD_INT 104
42597: PPUSH
42598: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42602: LD_INT 105
42604: PPUSH
42605: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42609: LD_INT 106
42611: PPUSH
42612: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42616: LD_INT 107
42618: PPUSH
42619: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42623: LD_INT 108
42625: PPUSH
42626: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42630: LD_INT 109
42632: PPUSH
42633: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42637: LD_INT 110
42639: PPUSH
42640: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42644: LD_INT 111
42646: PPUSH
42647: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42651: LD_INT 112
42653: PPUSH
42654: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42658: LD_INT 113
42660: PPUSH
42661: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42665: LD_INT 120
42667: PPUSH
42668: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42672: LD_INT 121
42674: PPUSH
42675: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42679: LD_INT 122
42681: PPUSH
42682: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42686: LD_INT 123
42688: PPUSH
42689: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42693: LD_INT 124
42695: PPUSH
42696: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42700: LD_INT 125
42702: PPUSH
42703: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42707: LD_INT 126
42709: PPUSH
42710: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42714: LD_INT 200
42716: PPUSH
42717: CALL_OW 427
// end ;
42721: END
// on SailEvent ( event ) do begin if event < 100 then
42722: LD_VAR 0 1
42726: PUSH
42727: LD_INT 100
42729: LESS
42730: IFFALSE 42741
// CustomEvent ( event ) ;
42732: LD_VAR 0 1
42736: PPUSH
42737: CALL 37097 0 1
// if event = 100 then
42741: LD_VAR 0 1
42745: PUSH
42746: LD_INT 100
42748: EQUAL
42749: IFFALSE 42755
// MC_ClassManager ( ) ;
42751: CALL 43147 0 0
// if event = 101 then
42755: LD_VAR 0 1
42759: PUSH
42760: LD_INT 101
42762: EQUAL
42763: IFFALSE 42769
// MC_RepairBuildings ( ) ;
42765: CALL 47979 0 0
// if event = 102 then
42769: LD_VAR 0 1
42773: PUSH
42774: LD_INT 102
42776: EQUAL
42777: IFFALSE 42783
// MC_Heal ( ) ;
42779: CALL 48914 0 0
// if event = 103 then
42783: LD_VAR 0 1
42787: PUSH
42788: LD_INT 103
42790: EQUAL
42791: IFFALSE 42797
// MC_Build ( ) ;
42793: CALL 49336 0 0
// if event = 104 then
42797: LD_VAR 0 1
42801: PUSH
42802: LD_INT 104
42804: EQUAL
42805: IFFALSE 42811
// MC_TurretWeapon ( ) ;
42807: CALL 50970 0 0
// if event = 105 then
42811: LD_VAR 0 1
42815: PUSH
42816: LD_INT 105
42818: EQUAL
42819: IFFALSE 42825
// MC_BuildUpgrade ( ) ;
42821: CALL 50521 0 0
// if event = 106 then
42825: LD_VAR 0 1
42829: PUSH
42830: LD_INT 106
42832: EQUAL
42833: IFFALSE 42839
// MC_PlantMines ( ) ;
42835: CALL 51400 0 0
// if event = 107 then
42839: LD_VAR 0 1
42843: PUSH
42844: LD_INT 107
42846: EQUAL
42847: IFFALSE 42853
// MC_CollectCrates ( ) ;
42849: CALL 52198 0 0
// if event = 108 then
42853: LD_VAR 0 1
42857: PUSH
42858: LD_INT 108
42860: EQUAL
42861: IFFALSE 42867
// MC_LinkRemoteControl ( ) ;
42863: CALL 54048 0 0
// if event = 109 then
42867: LD_VAR 0 1
42871: PUSH
42872: LD_INT 109
42874: EQUAL
42875: IFFALSE 42881
// MC_ProduceVehicle ( ) ;
42877: CALL 54229 0 0
// if event = 110 then
42881: LD_VAR 0 1
42885: PUSH
42886: LD_INT 110
42888: EQUAL
42889: IFFALSE 42895
// MC_SendAttack ( ) ;
42891: CALL 54695 0 0
// if event = 111 then
42895: LD_VAR 0 1
42899: PUSH
42900: LD_INT 111
42902: EQUAL
42903: IFFALSE 42909
// MC_Defend ( ) ;
42905: CALL 54803 0 0
// if event = 112 then
42909: LD_VAR 0 1
42913: PUSH
42914: LD_INT 112
42916: EQUAL
42917: IFFALSE 42923
// MC_Research ( ) ;
42919: CALL 55683 0 0
// if event = 113 then
42923: LD_VAR 0 1
42927: PUSH
42928: LD_INT 113
42930: EQUAL
42931: IFFALSE 42937
// MC_MinesTrigger ( ) ;
42933: CALL 56797 0 0
// if event = 120 then
42937: LD_VAR 0 1
42941: PUSH
42942: LD_INT 120
42944: EQUAL
42945: IFFALSE 42951
// MC_RepairVehicle ( ) ;
42947: CALL 56896 0 0
// if event = 121 then
42951: LD_VAR 0 1
42955: PUSH
42956: LD_INT 121
42958: EQUAL
42959: IFFALSE 42965
// MC_TameApe ( ) ;
42961: CALL 57665 0 0
// if event = 122 then
42965: LD_VAR 0 1
42969: PUSH
42970: LD_INT 122
42972: EQUAL
42973: IFFALSE 42979
// MC_ChangeApeClass ( ) ;
42975: CALL 58494 0 0
// if event = 123 then
42979: LD_VAR 0 1
42983: PUSH
42984: LD_INT 123
42986: EQUAL
42987: IFFALSE 42993
// MC_Bazooka ( ) ;
42989: CALL 59144 0 0
// if event = 124 then
42993: LD_VAR 0 1
42997: PUSH
42998: LD_INT 124
43000: EQUAL
43001: IFFALSE 43007
// MC_TeleportExit ( ) ;
43003: CALL 59342 0 0
// if event = 125 then
43007: LD_VAR 0 1
43011: PUSH
43012: LD_INT 125
43014: EQUAL
43015: IFFALSE 43021
// MC_Deposits ( ) ;
43017: CALL 59989 0 0
// if event = 126 then
43021: LD_VAR 0 1
43025: PUSH
43026: LD_INT 126
43028: EQUAL
43029: IFFALSE 43035
// MC_RemoteDriver ( ) ;
43031: CALL 60614 0 0
// if event = 200 then
43035: LD_VAR 0 1
43039: PUSH
43040: LD_INT 200
43042: EQUAL
43043: IFFALSE 43049
// MC_Idle ( ) ;
43045: CALL 62521 0 0
// end ;
43049: PPOPN 1
43051: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43052: LD_INT 0
43054: PPUSH
43055: PPUSH
// if not mc_bases [ base ] or not tag then
43056: LD_EXP 102
43060: PUSH
43061: LD_VAR 0 1
43065: ARRAY
43066: NOT
43067: PUSH
43068: LD_VAR 0 2
43072: NOT
43073: OR
43074: IFFALSE 43078
// exit ;
43076: GO 43142
// for i in mc_bases [ base ] union mc_ape [ base ] do
43078: LD_ADDR_VAR 0 4
43082: PUSH
43083: LD_EXP 102
43087: PUSH
43088: LD_VAR 0 1
43092: ARRAY
43093: PUSH
43094: LD_EXP 131
43098: PUSH
43099: LD_VAR 0 1
43103: ARRAY
43104: UNION
43105: PUSH
43106: FOR_IN
43107: IFFALSE 43140
// if GetTag ( i ) = tag then
43109: LD_VAR 0 4
43113: PPUSH
43114: CALL_OW 110
43118: PUSH
43119: LD_VAR 0 2
43123: EQUAL
43124: IFFALSE 43138
// SetTag ( i , 0 ) ;
43126: LD_VAR 0 4
43130: PPUSH
43131: LD_INT 0
43133: PPUSH
43134: CALL_OW 109
43138: GO 43106
43140: POP
43141: POP
// end ;
43142: LD_VAR 0 3
43146: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43147: LD_INT 0
43149: PPUSH
43150: PPUSH
43151: PPUSH
43152: PPUSH
43153: PPUSH
43154: PPUSH
43155: PPUSH
43156: PPUSH
// if not mc_bases then
43157: LD_EXP 102
43161: NOT
43162: IFFALSE 43166
// exit ;
43164: GO 43615
// for i = 1 to mc_bases do
43166: LD_ADDR_VAR 0 2
43170: PUSH
43171: DOUBLE
43172: LD_INT 1
43174: DEC
43175: ST_TO_ADDR
43176: LD_EXP 102
43180: PUSH
43181: FOR_TO
43182: IFFALSE 43613
// begin tmp := MC_ClassCheckReq ( i ) ;
43184: LD_ADDR_VAR 0 4
43188: PUSH
43189: LD_VAR 0 2
43193: PPUSH
43194: CALL 43620 0 1
43198: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43199: LD_ADDR_EXP 143
43203: PUSH
43204: LD_EXP 143
43208: PPUSH
43209: LD_VAR 0 2
43213: PPUSH
43214: LD_VAR 0 4
43218: PPUSH
43219: CALL_OW 1
43223: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43224: LD_ADDR_VAR 0 6
43228: PUSH
43229: LD_EXP 102
43233: PUSH
43234: LD_VAR 0 2
43238: ARRAY
43239: PPUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 30
43245: PUSH
43246: LD_INT 4
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 30
43255: PUSH
43256: LD_INT 5
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: LIST
43267: PPUSH
43268: CALL_OW 72
43272: PUSH
43273: LD_EXP 102
43277: PUSH
43278: LD_VAR 0 2
43282: ARRAY
43283: PPUSH
43284: LD_INT 2
43286: PUSH
43287: LD_INT 30
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 30
43299: PUSH
43300: LD_INT 1
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: LIST
43311: PPUSH
43312: CALL_OW 72
43316: PUSH
43317: LD_EXP 102
43321: PUSH
43322: LD_VAR 0 2
43326: ARRAY
43327: PPUSH
43328: LD_INT 30
43330: PUSH
43331: LD_INT 3
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PPUSH
43338: CALL_OW 72
43342: PUSH
43343: LD_EXP 102
43347: PUSH
43348: LD_VAR 0 2
43352: ARRAY
43353: PPUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 30
43359: PUSH
43360: LD_INT 6
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 30
43369: PUSH
43370: LD_INT 7
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 30
43379: PUSH
43380: LD_INT 8
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: PPUSH
43393: CALL_OW 72
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: ST_TO_ADDR
// for j := 1 to 4 do
43404: LD_ADDR_VAR 0 3
43408: PUSH
43409: DOUBLE
43410: LD_INT 1
43412: DEC
43413: ST_TO_ADDR
43414: LD_INT 4
43416: PUSH
43417: FOR_TO
43418: IFFALSE 43609
// begin if not tmp [ j ] then
43420: LD_VAR 0 4
43424: PUSH
43425: LD_VAR 0 3
43429: ARRAY
43430: NOT
43431: IFFALSE 43435
// continue ;
43433: GO 43417
// for p in tmp [ j ] do
43435: LD_ADDR_VAR 0 5
43439: PUSH
43440: LD_VAR 0 4
43444: PUSH
43445: LD_VAR 0 3
43449: ARRAY
43450: PUSH
43451: FOR_IN
43452: IFFALSE 43605
// begin if not b [ j ] then
43454: LD_VAR 0 6
43458: PUSH
43459: LD_VAR 0 3
43463: ARRAY
43464: NOT
43465: IFFALSE 43469
// break ;
43467: GO 43605
// e := 0 ;
43469: LD_ADDR_VAR 0 7
43473: PUSH
43474: LD_INT 0
43476: ST_TO_ADDR
// for k in b [ j ] do
43477: LD_ADDR_VAR 0 8
43481: PUSH
43482: LD_VAR 0 6
43486: PUSH
43487: LD_VAR 0 3
43491: ARRAY
43492: PUSH
43493: FOR_IN
43494: IFFALSE 43521
// if IsNotFull ( k ) then
43496: LD_VAR 0 8
43500: PPUSH
43501: CALL 71775 0 1
43505: IFFALSE 43519
// begin e := k ;
43507: LD_ADDR_VAR 0 7
43511: PUSH
43512: LD_VAR 0 8
43516: ST_TO_ADDR
// break ;
43517: GO 43521
// end ;
43519: GO 43493
43521: POP
43522: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43523: LD_VAR 0 7
43527: PUSH
43528: LD_VAR 0 5
43532: PPUSH
43533: LD_VAR 0 7
43537: PPUSH
43538: CALL 105914 0 2
43542: NOT
43543: AND
43544: IFFALSE 43603
// begin if IsInUnit ( p ) then
43546: LD_VAR 0 5
43550: PPUSH
43551: CALL_OW 310
43555: IFFALSE 43566
// ComExitBuilding ( p ) ;
43557: LD_VAR 0 5
43561: PPUSH
43562: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43566: LD_VAR 0 5
43570: PPUSH
43571: LD_VAR 0 7
43575: PPUSH
43576: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43580: LD_VAR 0 5
43584: PPUSH
43585: LD_VAR 0 3
43589: PPUSH
43590: CALL_OW 183
// AddComExitBuilding ( p ) ;
43594: LD_VAR 0 5
43598: PPUSH
43599: CALL_OW 182
// end ; end ;
43603: GO 43451
43605: POP
43606: POP
// end ;
43607: GO 43417
43609: POP
43610: POP
// end ;
43611: GO 43181
43613: POP
43614: POP
// end ;
43615: LD_VAR 0 1
43619: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43620: LD_INT 0
43622: PPUSH
43623: PPUSH
43624: PPUSH
43625: PPUSH
43626: PPUSH
43627: PPUSH
43628: PPUSH
43629: PPUSH
43630: PPUSH
43631: PPUSH
43632: PPUSH
43633: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43634: LD_ADDR_VAR 0 2
43638: PUSH
43639: LD_INT 0
43641: PUSH
43642: LD_INT 0
43644: PUSH
43645: LD_INT 0
43647: PUSH
43648: LD_INT 0
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: LIST
43655: LIST
43656: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43657: LD_VAR 0 1
43661: NOT
43662: PUSH
43663: LD_EXP 102
43667: PUSH
43668: LD_VAR 0 1
43672: ARRAY
43673: NOT
43674: OR
43675: PUSH
43676: LD_EXP 102
43680: PUSH
43681: LD_VAR 0 1
43685: ARRAY
43686: PPUSH
43687: LD_INT 2
43689: PUSH
43690: LD_INT 30
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 30
43702: PUSH
43703: LD_INT 1
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: LIST
43714: PPUSH
43715: CALL_OW 72
43719: NOT
43720: OR
43721: IFFALSE 43725
// exit ;
43723: GO 47228
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43725: LD_ADDR_VAR 0 4
43729: PUSH
43730: LD_EXP 102
43734: PUSH
43735: LD_VAR 0 1
43739: ARRAY
43740: PPUSH
43741: LD_INT 2
43743: PUSH
43744: LD_INT 25
43746: PUSH
43747: LD_INT 1
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 25
43756: PUSH
43757: LD_INT 2
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 25
43766: PUSH
43767: LD_INT 3
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 25
43776: PUSH
43777: LD_INT 4
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: LD_INT 25
43786: PUSH
43787: LD_INT 5
43789: PUSH
43790: EMPTY
43791: LIST
43792: LIST
43793: PUSH
43794: LD_INT 25
43796: PUSH
43797: LD_INT 8
43799: PUSH
43800: EMPTY
43801: LIST
43802: LIST
43803: PUSH
43804: LD_INT 25
43806: PUSH
43807: LD_INT 9
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: PPUSH
43824: CALL_OW 72
43828: ST_TO_ADDR
// if not tmp then
43829: LD_VAR 0 4
43833: NOT
43834: IFFALSE 43838
// exit ;
43836: GO 47228
// for i in tmp do
43838: LD_ADDR_VAR 0 3
43842: PUSH
43843: LD_VAR 0 4
43847: PUSH
43848: FOR_IN
43849: IFFALSE 43880
// if GetTag ( i ) then
43851: LD_VAR 0 3
43855: PPUSH
43856: CALL_OW 110
43860: IFFALSE 43878
// tmp := tmp diff i ;
43862: LD_ADDR_VAR 0 4
43866: PUSH
43867: LD_VAR 0 4
43871: PUSH
43872: LD_VAR 0 3
43876: DIFF
43877: ST_TO_ADDR
43878: GO 43848
43880: POP
43881: POP
// if not tmp then
43882: LD_VAR 0 4
43886: NOT
43887: IFFALSE 43891
// exit ;
43889: GO 47228
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43891: LD_ADDR_VAR 0 5
43895: PUSH
43896: LD_EXP 102
43900: PUSH
43901: LD_VAR 0 1
43905: ARRAY
43906: PPUSH
43907: LD_INT 2
43909: PUSH
43910: LD_INT 25
43912: PUSH
43913: LD_INT 1
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 25
43922: PUSH
43923: LD_INT 5
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 25
43932: PUSH
43933: LD_INT 8
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 25
43942: PUSH
43943: LD_INT 9
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: PPUSH
43957: CALL_OW 72
43961: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43962: LD_ADDR_VAR 0 6
43966: PUSH
43967: LD_EXP 102
43971: PUSH
43972: LD_VAR 0 1
43976: ARRAY
43977: PPUSH
43978: LD_INT 25
43980: PUSH
43981: LD_INT 2
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PPUSH
43988: CALL_OW 72
43992: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43993: LD_ADDR_VAR 0 7
43997: PUSH
43998: LD_EXP 102
44002: PUSH
44003: LD_VAR 0 1
44007: ARRAY
44008: PPUSH
44009: LD_INT 25
44011: PUSH
44012: LD_INT 3
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44024: LD_ADDR_VAR 0 8
44028: PUSH
44029: LD_EXP 102
44033: PUSH
44034: LD_VAR 0 1
44038: ARRAY
44039: PPUSH
44040: LD_INT 25
44042: PUSH
44043: LD_INT 4
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 24
44052: PUSH
44053: LD_INT 251
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PPUSH
44064: CALL_OW 72
44068: ST_TO_ADDR
// if mc_is_defending [ base ] then
44069: LD_EXP 145
44073: PUSH
44074: LD_VAR 0 1
44078: ARRAY
44079: IFFALSE 44540
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44081: LD_ADDR_EXP 144
44085: PUSH
44086: LD_EXP 144
44090: PPUSH
44091: LD_VAR 0 1
44095: PPUSH
44096: LD_INT 4
44098: PPUSH
44099: CALL_OW 1
44103: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44104: LD_ADDR_VAR 0 12
44108: PUSH
44109: LD_EXP 102
44113: PUSH
44114: LD_VAR 0 1
44118: ARRAY
44119: PPUSH
44120: LD_INT 2
44122: PUSH
44123: LD_INT 30
44125: PUSH
44126: LD_INT 4
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 30
44135: PUSH
44136: LD_INT 5
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: LIST
44147: PPUSH
44148: CALL_OW 72
44152: ST_TO_ADDR
// if not b then
44153: LD_VAR 0 12
44157: NOT
44158: IFFALSE 44162
// exit ;
44160: GO 47228
// p := [ ] ;
44162: LD_ADDR_VAR 0 11
44166: PUSH
44167: EMPTY
44168: ST_TO_ADDR
// if sci >= 2 then
44169: LD_VAR 0 8
44173: PUSH
44174: LD_INT 2
44176: GREATEREQUAL
44177: IFFALSE 44208
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44179: LD_ADDR_VAR 0 8
44183: PUSH
44184: LD_VAR 0 8
44188: PUSH
44189: LD_INT 1
44191: ARRAY
44192: PUSH
44193: LD_VAR 0 8
44197: PUSH
44198: LD_INT 2
44200: ARRAY
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: ST_TO_ADDR
44206: GO 44269
// if sci = 1 then
44208: LD_VAR 0 8
44212: PUSH
44213: LD_INT 1
44215: EQUAL
44216: IFFALSE 44237
// sci := [ sci [ 1 ] ] else
44218: LD_ADDR_VAR 0 8
44222: PUSH
44223: LD_VAR 0 8
44227: PUSH
44228: LD_INT 1
44230: ARRAY
44231: PUSH
44232: EMPTY
44233: LIST
44234: ST_TO_ADDR
44235: GO 44269
// if sci = 0 then
44237: LD_VAR 0 8
44241: PUSH
44242: LD_INT 0
44244: EQUAL
44245: IFFALSE 44269
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44247: LD_ADDR_VAR 0 11
44251: PUSH
44252: LD_VAR 0 4
44256: PPUSH
44257: LD_INT 4
44259: PPUSH
44260: CALL 105786 0 2
44264: PUSH
44265: LD_INT 1
44267: ARRAY
44268: ST_TO_ADDR
// if eng > 4 then
44269: LD_VAR 0 6
44273: PUSH
44274: LD_INT 4
44276: GREATER
44277: IFFALSE 44323
// for i = eng downto 4 do
44279: LD_ADDR_VAR 0 3
44283: PUSH
44284: DOUBLE
44285: LD_VAR 0 6
44289: INC
44290: ST_TO_ADDR
44291: LD_INT 4
44293: PUSH
44294: FOR_DOWNTO
44295: IFFALSE 44321
// eng := eng diff eng [ i ] ;
44297: LD_ADDR_VAR 0 6
44301: PUSH
44302: LD_VAR 0 6
44306: PUSH
44307: LD_VAR 0 6
44311: PUSH
44312: LD_VAR 0 3
44316: ARRAY
44317: DIFF
44318: ST_TO_ADDR
44319: GO 44294
44321: POP
44322: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44323: LD_ADDR_VAR 0 4
44327: PUSH
44328: LD_VAR 0 4
44332: PUSH
44333: LD_VAR 0 5
44337: PUSH
44338: LD_VAR 0 6
44342: UNION
44343: PUSH
44344: LD_VAR 0 7
44348: UNION
44349: PUSH
44350: LD_VAR 0 8
44354: UNION
44355: DIFF
44356: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44357: LD_ADDR_VAR 0 13
44361: PUSH
44362: LD_EXP 102
44366: PUSH
44367: LD_VAR 0 1
44371: ARRAY
44372: PPUSH
44373: LD_INT 2
44375: PUSH
44376: LD_INT 30
44378: PUSH
44379: LD_INT 32
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 30
44388: PUSH
44389: LD_INT 31
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: LIST
44400: PPUSH
44401: CALL_OW 72
44405: PUSH
44406: LD_EXP 102
44410: PUSH
44411: LD_VAR 0 1
44415: ARRAY
44416: PPUSH
44417: LD_INT 2
44419: PUSH
44420: LD_INT 30
44422: PUSH
44423: LD_INT 4
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 30
44432: PUSH
44433: LD_INT 5
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: LIST
44444: PPUSH
44445: CALL_OW 72
44449: PUSH
44450: LD_INT 6
44452: MUL
44453: PLUS
44454: ST_TO_ADDR
// if bcount < tmp then
44455: LD_VAR 0 13
44459: PUSH
44460: LD_VAR 0 4
44464: LESS
44465: IFFALSE 44511
// for i = tmp downto bcount do
44467: LD_ADDR_VAR 0 3
44471: PUSH
44472: DOUBLE
44473: LD_VAR 0 4
44477: INC
44478: ST_TO_ADDR
44479: LD_VAR 0 13
44483: PUSH
44484: FOR_DOWNTO
44485: IFFALSE 44509
// tmp := Delete ( tmp , tmp ) ;
44487: LD_ADDR_VAR 0 4
44491: PUSH
44492: LD_VAR 0 4
44496: PPUSH
44497: LD_VAR 0 4
44501: PPUSH
44502: CALL_OW 3
44506: ST_TO_ADDR
44507: GO 44484
44509: POP
44510: POP
// result := [ tmp , 0 , 0 , p ] ;
44511: LD_ADDR_VAR 0 2
44515: PUSH
44516: LD_VAR 0 4
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: LD_INT 0
44526: PUSH
44527: LD_VAR 0 11
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: ST_TO_ADDR
// exit ;
44538: GO 47228
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44540: LD_EXP 102
44544: PUSH
44545: LD_VAR 0 1
44549: ARRAY
44550: PPUSH
44551: LD_INT 2
44553: PUSH
44554: LD_INT 30
44556: PUSH
44557: LD_INT 6
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 30
44566: PUSH
44567: LD_INT 7
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 30
44576: PUSH
44577: LD_INT 8
44579: PUSH
44580: EMPTY
44581: LIST
44582: LIST
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: LIST
44588: LIST
44589: PPUSH
44590: CALL_OW 72
44594: NOT
44595: PUSH
44596: LD_EXP 102
44600: PUSH
44601: LD_VAR 0 1
44605: ARRAY
44606: PPUSH
44607: LD_INT 30
44609: PUSH
44610: LD_INT 3
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PPUSH
44617: CALL_OW 72
44621: NOT
44622: AND
44623: IFFALSE 44695
// begin if eng = tmp then
44625: LD_VAR 0 6
44629: PUSH
44630: LD_VAR 0 4
44634: EQUAL
44635: IFFALSE 44639
// exit ;
44637: GO 47228
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44639: LD_ADDR_EXP 144
44643: PUSH
44644: LD_EXP 144
44648: PPUSH
44649: LD_VAR 0 1
44653: PPUSH
44654: LD_INT 1
44656: PPUSH
44657: CALL_OW 1
44661: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44662: LD_ADDR_VAR 0 2
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: LD_VAR 0 4
44674: PUSH
44675: LD_VAR 0 6
44679: DIFF
44680: PUSH
44681: LD_INT 0
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: ST_TO_ADDR
// exit ;
44693: GO 47228
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44695: LD_EXP 129
44699: PUSH
44700: LD_EXP 128
44704: PUSH
44705: LD_VAR 0 1
44709: ARRAY
44710: ARRAY
44711: PUSH
44712: LD_EXP 102
44716: PUSH
44717: LD_VAR 0 1
44721: ARRAY
44722: PPUSH
44723: LD_INT 2
44725: PUSH
44726: LD_INT 30
44728: PUSH
44729: LD_INT 6
44731: PUSH
44732: EMPTY
44733: LIST
44734: LIST
44735: PUSH
44736: LD_INT 30
44738: PUSH
44739: LD_INT 7
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 30
44748: PUSH
44749: LD_INT 8
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: PPUSH
44762: CALL_OW 72
44766: AND
44767: PUSH
44768: LD_EXP 102
44772: PUSH
44773: LD_VAR 0 1
44777: ARRAY
44778: PPUSH
44779: LD_INT 30
44781: PUSH
44782: LD_INT 3
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PPUSH
44789: CALL_OW 72
44793: NOT
44794: AND
44795: IFFALSE 45009
// begin if sci >= 6 then
44797: LD_VAR 0 8
44801: PUSH
44802: LD_INT 6
44804: GREATEREQUAL
44805: IFFALSE 44809
// exit ;
44807: GO 47228
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44809: LD_ADDR_EXP 144
44813: PUSH
44814: LD_EXP 144
44818: PPUSH
44819: LD_VAR 0 1
44823: PPUSH
44824: LD_INT 2
44826: PPUSH
44827: CALL_OW 1
44831: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44832: LD_ADDR_VAR 0 9
44836: PUSH
44837: LD_VAR 0 4
44841: PUSH
44842: LD_VAR 0 8
44846: DIFF
44847: PPUSH
44848: LD_INT 4
44850: PPUSH
44851: CALL 105786 0 2
44855: ST_TO_ADDR
// p := [ ] ;
44856: LD_ADDR_VAR 0 11
44860: PUSH
44861: EMPTY
44862: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44863: LD_VAR 0 8
44867: PUSH
44868: LD_INT 6
44870: LESS
44871: PUSH
44872: LD_VAR 0 9
44876: PUSH
44877: LD_INT 6
44879: GREATER
44880: AND
44881: IFFALSE 44962
// begin for i = 1 to 6 - sci do
44883: LD_ADDR_VAR 0 3
44887: PUSH
44888: DOUBLE
44889: LD_INT 1
44891: DEC
44892: ST_TO_ADDR
44893: LD_INT 6
44895: PUSH
44896: LD_VAR 0 8
44900: MINUS
44901: PUSH
44902: FOR_TO
44903: IFFALSE 44958
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44905: LD_ADDR_VAR 0 11
44909: PUSH
44910: LD_VAR 0 11
44914: PPUSH
44915: LD_VAR 0 11
44919: PUSH
44920: LD_INT 1
44922: PLUS
44923: PPUSH
44924: LD_VAR 0 9
44928: PUSH
44929: LD_INT 1
44931: ARRAY
44932: PPUSH
44933: CALL_OW 2
44937: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44938: LD_ADDR_VAR 0 9
44942: PUSH
44943: LD_VAR 0 9
44947: PPUSH
44948: LD_INT 1
44950: PPUSH
44951: CALL_OW 3
44955: ST_TO_ADDR
// end ;
44956: GO 44902
44958: POP
44959: POP
// end else
44960: GO 44982
// if sort then
44962: LD_VAR 0 9
44966: IFFALSE 44982
// p := sort [ 1 ] ;
44968: LD_ADDR_VAR 0 11
44972: PUSH
44973: LD_VAR 0 9
44977: PUSH
44978: LD_INT 1
44980: ARRAY
44981: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44982: LD_ADDR_VAR 0 2
44986: PUSH
44987: LD_INT 0
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_VAR 0 11
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: ST_TO_ADDR
// exit ;
45007: GO 47228
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45009: LD_EXP 129
45013: PUSH
45014: LD_EXP 128
45018: PUSH
45019: LD_VAR 0 1
45023: ARRAY
45024: ARRAY
45025: PUSH
45026: LD_EXP 102
45030: PUSH
45031: LD_VAR 0 1
45035: ARRAY
45036: PPUSH
45037: LD_INT 2
45039: PUSH
45040: LD_INT 30
45042: PUSH
45043: LD_INT 6
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 30
45052: PUSH
45053: LD_INT 7
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PUSH
45060: LD_INT 30
45062: PUSH
45063: LD_INT 8
45065: PUSH
45066: EMPTY
45067: LIST
45068: LIST
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: PPUSH
45076: CALL_OW 72
45080: AND
45081: PUSH
45082: LD_EXP 102
45086: PUSH
45087: LD_VAR 0 1
45091: ARRAY
45092: PPUSH
45093: LD_INT 30
45095: PUSH
45096: LD_INT 3
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PPUSH
45103: CALL_OW 72
45107: AND
45108: IFFALSE 45842
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45110: LD_ADDR_EXP 144
45114: PUSH
45115: LD_EXP 144
45119: PPUSH
45120: LD_VAR 0 1
45124: PPUSH
45125: LD_INT 3
45127: PPUSH
45128: CALL_OW 1
45132: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45133: LD_ADDR_VAR 0 2
45137: PUSH
45138: LD_INT 0
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: LD_INT 0
45146: PUSH
45147: LD_INT 0
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: ST_TO_ADDR
// if not eng then
45156: LD_VAR 0 6
45160: NOT
45161: IFFALSE 45224
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45163: LD_ADDR_VAR 0 11
45167: PUSH
45168: LD_VAR 0 4
45172: PPUSH
45173: LD_INT 2
45175: PPUSH
45176: CALL 105786 0 2
45180: PUSH
45181: LD_INT 1
45183: ARRAY
45184: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45185: LD_ADDR_VAR 0 2
45189: PUSH
45190: LD_VAR 0 2
45194: PPUSH
45195: LD_INT 2
45197: PPUSH
45198: LD_VAR 0 11
45202: PPUSH
45203: CALL_OW 1
45207: ST_TO_ADDR
// tmp := tmp diff p ;
45208: LD_ADDR_VAR 0 4
45212: PUSH
45213: LD_VAR 0 4
45217: PUSH
45218: LD_VAR 0 11
45222: DIFF
45223: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45224: LD_VAR 0 4
45228: PUSH
45229: LD_VAR 0 8
45233: PUSH
45234: LD_INT 6
45236: LESS
45237: AND
45238: IFFALSE 45426
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45240: LD_ADDR_VAR 0 9
45244: PUSH
45245: LD_VAR 0 4
45249: PUSH
45250: LD_VAR 0 8
45254: PUSH
45255: LD_VAR 0 7
45259: UNION
45260: DIFF
45261: PPUSH
45262: LD_INT 4
45264: PPUSH
45265: CALL 105786 0 2
45269: ST_TO_ADDR
// p := [ ] ;
45270: LD_ADDR_VAR 0 11
45274: PUSH
45275: EMPTY
45276: ST_TO_ADDR
// if sort then
45277: LD_VAR 0 9
45281: IFFALSE 45397
// for i = 1 to 6 - sci do
45283: LD_ADDR_VAR 0 3
45287: PUSH
45288: DOUBLE
45289: LD_INT 1
45291: DEC
45292: ST_TO_ADDR
45293: LD_INT 6
45295: PUSH
45296: LD_VAR 0 8
45300: MINUS
45301: PUSH
45302: FOR_TO
45303: IFFALSE 45395
// begin if i = sort then
45305: LD_VAR 0 3
45309: PUSH
45310: LD_VAR 0 9
45314: EQUAL
45315: IFFALSE 45319
// break ;
45317: GO 45395
// if GetClass ( i ) = 4 then
45319: LD_VAR 0 3
45323: PPUSH
45324: CALL_OW 257
45328: PUSH
45329: LD_INT 4
45331: EQUAL
45332: IFFALSE 45336
// continue ;
45334: GO 45302
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45336: LD_ADDR_VAR 0 11
45340: PUSH
45341: LD_VAR 0 11
45345: PPUSH
45346: LD_VAR 0 11
45350: PUSH
45351: LD_INT 1
45353: PLUS
45354: PPUSH
45355: LD_VAR 0 9
45359: PUSH
45360: LD_VAR 0 3
45364: ARRAY
45365: PPUSH
45366: CALL_OW 2
45370: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45371: LD_ADDR_VAR 0 4
45375: PUSH
45376: LD_VAR 0 4
45380: PUSH
45381: LD_VAR 0 9
45385: PUSH
45386: LD_VAR 0 3
45390: ARRAY
45391: DIFF
45392: ST_TO_ADDR
// end ;
45393: GO 45302
45395: POP
45396: POP
// if p then
45397: LD_VAR 0 11
45401: IFFALSE 45426
// result := Replace ( result , 4 , p ) ;
45403: LD_ADDR_VAR 0 2
45407: PUSH
45408: LD_VAR 0 2
45412: PPUSH
45413: LD_INT 4
45415: PPUSH
45416: LD_VAR 0 11
45420: PPUSH
45421: CALL_OW 1
45425: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45426: LD_VAR 0 4
45430: PUSH
45431: LD_VAR 0 7
45435: PUSH
45436: LD_INT 6
45438: LESS
45439: AND
45440: IFFALSE 45628
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45442: LD_ADDR_VAR 0 9
45446: PUSH
45447: LD_VAR 0 4
45451: PUSH
45452: LD_VAR 0 8
45456: PUSH
45457: LD_VAR 0 7
45461: UNION
45462: DIFF
45463: PPUSH
45464: LD_INT 3
45466: PPUSH
45467: CALL 105786 0 2
45471: ST_TO_ADDR
// p := [ ] ;
45472: LD_ADDR_VAR 0 11
45476: PUSH
45477: EMPTY
45478: ST_TO_ADDR
// if sort then
45479: LD_VAR 0 9
45483: IFFALSE 45599
// for i = 1 to 6 - mech do
45485: LD_ADDR_VAR 0 3
45489: PUSH
45490: DOUBLE
45491: LD_INT 1
45493: DEC
45494: ST_TO_ADDR
45495: LD_INT 6
45497: PUSH
45498: LD_VAR 0 7
45502: MINUS
45503: PUSH
45504: FOR_TO
45505: IFFALSE 45597
// begin if i = sort then
45507: LD_VAR 0 3
45511: PUSH
45512: LD_VAR 0 9
45516: EQUAL
45517: IFFALSE 45521
// break ;
45519: GO 45597
// if GetClass ( i ) = 3 then
45521: LD_VAR 0 3
45525: PPUSH
45526: CALL_OW 257
45530: PUSH
45531: LD_INT 3
45533: EQUAL
45534: IFFALSE 45538
// continue ;
45536: GO 45504
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45538: LD_ADDR_VAR 0 11
45542: PUSH
45543: LD_VAR 0 11
45547: PPUSH
45548: LD_VAR 0 11
45552: PUSH
45553: LD_INT 1
45555: PLUS
45556: PPUSH
45557: LD_VAR 0 9
45561: PUSH
45562: LD_VAR 0 3
45566: ARRAY
45567: PPUSH
45568: CALL_OW 2
45572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45573: LD_ADDR_VAR 0 4
45577: PUSH
45578: LD_VAR 0 4
45582: PUSH
45583: LD_VAR 0 9
45587: PUSH
45588: LD_VAR 0 3
45592: ARRAY
45593: DIFF
45594: ST_TO_ADDR
// end ;
45595: GO 45504
45597: POP
45598: POP
// if p then
45599: LD_VAR 0 11
45603: IFFALSE 45628
// result := Replace ( result , 3 , p ) ;
45605: LD_ADDR_VAR 0 2
45609: PUSH
45610: LD_VAR 0 2
45614: PPUSH
45615: LD_INT 3
45617: PPUSH
45618: LD_VAR 0 11
45622: PPUSH
45623: CALL_OW 1
45627: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45628: LD_VAR 0 4
45632: PUSH
45633: LD_INT 6
45635: GREATER
45636: PUSH
45637: LD_VAR 0 6
45641: PUSH
45642: LD_INT 6
45644: LESS
45645: AND
45646: IFFALSE 45840
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45648: LD_ADDR_VAR 0 9
45652: PUSH
45653: LD_VAR 0 4
45657: PUSH
45658: LD_VAR 0 8
45662: PUSH
45663: LD_VAR 0 7
45667: UNION
45668: PUSH
45669: LD_VAR 0 6
45673: UNION
45674: DIFF
45675: PPUSH
45676: LD_INT 2
45678: PPUSH
45679: CALL 105786 0 2
45683: ST_TO_ADDR
// p := [ ] ;
45684: LD_ADDR_VAR 0 11
45688: PUSH
45689: EMPTY
45690: ST_TO_ADDR
// if sort then
45691: LD_VAR 0 9
45695: IFFALSE 45811
// for i = 1 to 6 - eng do
45697: LD_ADDR_VAR 0 3
45701: PUSH
45702: DOUBLE
45703: LD_INT 1
45705: DEC
45706: ST_TO_ADDR
45707: LD_INT 6
45709: PUSH
45710: LD_VAR 0 6
45714: MINUS
45715: PUSH
45716: FOR_TO
45717: IFFALSE 45809
// begin if i = sort then
45719: LD_VAR 0 3
45723: PUSH
45724: LD_VAR 0 9
45728: EQUAL
45729: IFFALSE 45733
// break ;
45731: GO 45809
// if GetClass ( i ) = 2 then
45733: LD_VAR 0 3
45737: PPUSH
45738: CALL_OW 257
45742: PUSH
45743: LD_INT 2
45745: EQUAL
45746: IFFALSE 45750
// continue ;
45748: GO 45716
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45750: LD_ADDR_VAR 0 11
45754: PUSH
45755: LD_VAR 0 11
45759: PPUSH
45760: LD_VAR 0 11
45764: PUSH
45765: LD_INT 1
45767: PLUS
45768: PPUSH
45769: LD_VAR 0 9
45773: PUSH
45774: LD_VAR 0 3
45778: ARRAY
45779: PPUSH
45780: CALL_OW 2
45784: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45785: LD_ADDR_VAR 0 4
45789: PUSH
45790: LD_VAR 0 4
45794: PUSH
45795: LD_VAR 0 9
45799: PUSH
45800: LD_VAR 0 3
45804: ARRAY
45805: DIFF
45806: ST_TO_ADDR
// end ;
45807: GO 45716
45809: POP
45810: POP
// if p then
45811: LD_VAR 0 11
45815: IFFALSE 45840
// result := Replace ( result , 2 , p ) ;
45817: LD_ADDR_VAR 0 2
45821: PUSH
45822: LD_VAR 0 2
45826: PPUSH
45827: LD_INT 2
45829: PPUSH
45830: LD_VAR 0 11
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// end ; exit ;
45840: GO 47228
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45842: LD_EXP 129
45846: PUSH
45847: LD_EXP 128
45851: PUSH
45852: LD_VAR 0 1
45856: ARRAY
45857: ARRAY
45858: NOT
45859: PUSH
45860: LD_EXP 102
45864: PUSH
45865: LD_VAR 0 1
45869: ARRAY
45870: PPUSH
45871: LD_INT 30
45873: PUSH
45874: LD_INT 3
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PPUSH
45881: CALL_OW 72
45885: AND
45886: PUSH
45887: LD_EXP 107
45891: PUSH
45892: LD_VAR 0 1
45896: ARRAY
45897: AND
45898: IFFALSE 46506
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45900: LD_ADDR_EXP 144
45904: PUSH
45905: LD_EXP 144
45909: PPUSH
45910: LD_VAR 0 1
45914: PPUSH
45915: LD_INT 5
45917: PPUSH
45918: CALL_OW 1
45922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45923: LD_ADDR_VAR 0 2
45927: PUSH
45928: LD_INT 0
45930: PUSH
45931: LD_INT 0
45933: PUSH
45934: LD_INT 0
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: ST_TO_ADDR
// if sci > 1 then
45946: LD_VAR 0 8
45950: PUSH
45951: LD_INT 1
45953: GREATER
45954: IFFALSE 45982
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45956: LD_ADDR_VAR 0 4
45960: PUSH
45961: LD_VAR 0 4
45965: PUSH
45966: LD_VAR 0 8
45970: PUSH
45971: LD_VAR 0 8
45975: PUSH
45976: LD_INT 1
45978: ARRAY
45979: DIFF
45980: DIFF
45981: ST_TO_ADDR
// if tmp and not sci then
45982: LD_VAR 0 4
45986: PUSH
45987: LD_VAR 0 8
45991: NOT
45992: AND
45993: IFFALSE 46062
// begin sort := SortBySkill ( tmp , 4 ) ;
45995: LD_ADDR_VAR 0 9
45999: PUSH
46000: LD_VAR 0 4
46004: PPUSH
46005: LD_INT 4
46007: PPUSH
46008: CALL 105786 0 2
46012: ST_TO_ADDR
// if sort then
46013: LD_VAR 0 9
46017: IFFALSE 46033
// p := sort [ 1 ] ;
46019: LD_ADDR_VAR 0 11
46023: PUSH
46024: LD_VAR 0 9
46028: PUSH
46029: LD_INT 1
46031: ARRAY
46032: ST_TO_ADDR
// if p then
46033: LD_VAR 0 11
46037: IFFALSE 46062
// result := Replace ( result , 4 , p ) ;
46039: LD_ADDR_VAR 0 2
46043: PUSH
46044: LD_VAR 0 2
46048: PPUSH
46049: LD_INT 4
46051: PPUSH
46052: LD_VAR 0 11
46056: PPUSH
46057: CALL_OW 1
46061: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46062: LD_ADDR_VAR 0 4
46066: PUSH
46067: LD_VAR 0 4
46071: PUSH
46072: LD_VAR 0 7
46076: DIFF
46077: ST_TO_ADDR
// if tmp and mech < 6 then
46078: LD_VAR 0 4
46082: PUSH
46083: LD_VAR 0 7
46087: PUSH
46088: LD_INT 6
46090: LESS
46091: AND
46092: IFFALSE 46280
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46094: LD_ADDR_VAR 0 9
46098: PUSH
46099: LD_VAR 0 4
46103: PUSH
46104: LD_VAR 0 8
46108: PUSH
46109: LD_VAR 0 7
46113: UNION
46114: DIFF
46115: PPUSH
46116: LD_INT 3
46118: PPUSH
46119: CALL 105786 0 2
46123: ST_TO_ADDR
// p := [ ] ;
46124: LD_ADDR_VAR 0 11
46128: PUSH
46129: EMPTY
46130: ST_TO_ADDR
// if sort then
46131: LD_VAR 0 9
46135: IFFALSE 46251
// for i = 1 to 6 - mech do
46137: LD_ADDR_VAR 0 3
46141: PUSH
46142: DOUBLE
46143: LD_INT 1
46145: DEC
46146: ST_TO_ADDR
46147: LD_INT 6
46149: PUSH
46150: LD_VAR 0 7
46154: MINUS
46155: PUSH
46156: FOR_TO
46157: IFFALSE 46249
// begin if i = sort then
46159: LD_VAR 0 3
46163: PUSH
46164: LD_VAR 0 9
46168: EQUAL
46169: IFFALSE 46173
// break ;
46171: GO 46249
// if GetClass ( i ) = 3 then
46173: LD_VAR 0 3
46177: PPUSH
46178: CALL_OW 257
46182: PUSH
46183: LD_INT 3
46185: EQUAL
46186: IFFALSE 46190
// continue ;
46188: GO 46156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46190: LD_ADDR_VAR 0 11
46194: PUSH
46195: LD_VAR 0 11
46199: PPUSH
46200: LD_VAR 0 11
46204: PUSH
46205: LD_INT 1
46207: PLUS
46208: PPUSH
46209: LD_VAR 0 9
46213: PUSH
46214: LD_VAR 0 3
46218: ARRAY
46219: PPUSH
46220: CALL_OW 2
46224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46225: LD_ADDR_VAR 0 4
46229: PUSH
46230: LD_VAR 0 4
46234: PUSH
46235: LD_VAR 0 9
46239: PUSH
46240: LD_VAR 0 3
46244: ARRAY
46245: DIFF
46246: ST_TO_ADDR
// end ;
46247: GO 46156
46249: POP
46250: POP
// if p then
46251: LD_VAR 0 11
46255: IFFALSE 46280
// result := Replace ( result , 3 , p ) ;
46257: LD_ADDR_VAR 0 2
46261: PUSH
46262: LD_VAR 0 2
46266: PPUSH
46267: LD_INT 3
46269: PPUSH
46270: LD_VAR 0 11
46274: PPUSH
46275: CALL_OW 1
46279: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46280: LD_ADDR_VAR 0 4
46284: PUSH
46285: LD_VAR 0 4
46289: PUSH
46290: LD_VAR 0 6
46294: DIFF
46295: ST_TO_ADDR
// if tmp and eng < 6 then
46296: LD_VAR 0 4
46300: PUSH
46301: LD_VAR 0 6
46305: PUSH
46306: LD_INT 6
46308: LESS
46309: AND
46310: IFFALSE 46504
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46312: LD_ADDR_VAR 0 9
46316: PUSH
46317: LD_VAR 0 4
46321: PUSH
46322: LD_VAR 0 8
46326: PUSH
46327: LD_VAR 0 7
46331: UNION
46332: PUSH
46333: LD_VAR 0 6
46337: UNION
46338: DIFF
46339: PPUSH
46340: LD_INT 2
46342: PPUSH
46343: CALL 105786 0 2
46347: ST_TO_ADDR
// p := [ ] ;
46348: LD_ADDR_VAR 0 11
46352: PUSH
46353: EMPTY
46354: ST_TO_ADDR
// if sort then
46355: LD_VAR 0 9
46359: IFFALSE 46475
// for i = 1 to 6 - eng do
46361: LD_ADDR_VAR 0 3
46365: PUSH
46366: DOUBLE
46367: LD_INT 1
46369: DEC
46370: ST_TO_ADDR
46371: LD_INT 6
46373: PUSH
46374: LD_VAR 0 6
46378: MINUS
46379: PUSH
46380: FOR_TO
46381: IFFALSE 46473
// begin if i = sort then
46383: LD_VAR 0 3
46387: PUSH
46388: LD_VAR 0 9
46392: EQUAL
46393: IFFALSE 46397
// break ;
46395: GO 46473
// if GetClass ( i ) = 2 then
46397: LD_VAR 0 3
46401: PPUSH
46402: CALL_OW 257
46406: PUSH
46407: LD_INT 2
46409: EQUAL
46410: IFFALSE 46414
// continue ;
46412: GO 46380
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46414: LD_ADDR_VAR 0 11
46418: PUSH
46419: LD_VAR 0 11
46423: PPUSH
46424: LD_VAR 0 11
46428: PUSH
46429: LD_INT 1
46431: PLUS
46432: PPUSH
46433: LD_VAR 0 9
46437: PUSH
46438: LD_VAR 0 3
46442: ARRAY
46443: PPUSH
46444: CALL_OW 2
46448: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46449: LD_ADDR_VAR 0 4
46453: PUSH
46454: LD_VAR 0 4
46458: PUSH
46459: LD_VAR 0 9
46463: PUSH
46464: LD_VAR 0 3
46468: ARRAY
46469: DIFF
46470: ST_TO_ADDR
// end ;
46471: GO 46380
46473: POP
46474: POP
// if p then
46475: LD_VAR 0 11
46479: IFFALSE 46504
// result := Replace ( result , 2 , p ) ;
46481: LD_ADDR_VAR 0 2
46485: PUSH
46486: LD_VAR 0 2
46490: PPUSH
46491: LD_INT 2
46493: PPUSH
46494: LD_VAR 0 11
46498: PPUSH
46499: CALL_OW 1
46503: ST_TO_ADDR
// end ; exit ;
46504: GO 47228
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46506: LD_EXP 129
46510: PUSH
46511: LD_EXP 128
46515: PUSH
46516: LD_VAR 0 1
46520: ARRAY
46521: ARRAY
46522: NOT
46523: PUSH
46524: LD_EXP 102
46528: PUSH
46529: LD_VAR 0 1
46533: ARRAY
46534: PPUSH
46535: LD_INT 30
46537: PUSH
46538: LD_INT 3
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: PPUSH
46545: CALL_OW 72
46549: AND
46550: PUSH
46551: LD_EXP 107
46555: PUSH
46556: LD_VAR 0 1
46560: ARRAY
46561: NOT
46562: AND
46563: IFFALSE 47228
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46565: LD_ADDR_EXP 144
46569: PUSH
46570: LD_EXP 144
46574: PPUSH
46575: LD_VAR 0 1
46579: PPUSH
46580: LD_INT 6
46582: PPUSH
46583: CALL_OW 1
46587: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46588: LD_ADDR_VAR 0 2
46592: PUSH
46593: LD_INT 0
46595: PUSH
46596: LD_INT 0
46598: PUSH
46599: LD_INT 0
46601: PUSH
46602: LD_INT 0
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: ST_TO_ADDR
// if sci >= 1 then
46611: LD_VAR 0 8
46615: PUSH
46616: LD_INT 1
46618: GREATEREQUAL
46619: IFFALSE 46641
// tmp := tmp diff sci [ 1 ] ;
46621: LD_ADDR_VAR 0 4
46625: PUSH
46626: LD_VAR 0 4
46630: PUSH
46631: LD_VAR 0 8
46635: PUSH
46636: LD_INT 1
46638: ARRAY
46639: DIFF
46640: ST_TO_ADDR
// if tmp and not sci then
46641: LD_VAR 0 4
46645: PUSH
46646: LD_VAR 0 8
46650: NOT
46651: AND
46652: IFFALSE 46721
// begin sort := SortBySkill ( tmp , 4 ) ;
46654: LD_ADDR_VAR 0 9
46658: PUSH
46659: LD_VAR 0 4
46663: PPUSH
46664: LD_INT 4
46666: PPUSH
46667: CALL 105786 0 2
46671: ST_TO_ADDR
// if sort then
46672: LD_VAR 0 9
46676: IFFALSE 46692
// p := sort [ 1 ] ;
46678: LD_ADDR_VAR 0 11
46682: PUSH
46683: LD_VAR 0 9
46687: PUSH
46688: LD_INT 1
46690: ARRAY
46691: ST_TO_ADDR
// if p then
46692: LD_VAR 0 11
46696: IFFALSE 46721
// result := Replace ( result , 4 , p ) ;
46698: LD_ADDR_VAR 0 2
46702: PUSH
46703: LD_VAR 0 2
46707: PPUSH
46708: LD_INT 4
46710: PPUSH
46711: LD_VAR 0 11
46715: PPUSH
46716: CALL_OW 1
46720: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46721: LD_ADDR_VAR 0 4
46725: PUSH
46726: LD_VAR 0 4
46730: PUSH
46731: LD_VAR 0 7
46735: DIFF
46736: ST_TO_ADDR
// if tmp and mech < 6 then
46737: LD_VAR 0 4
46741: PUSH
46742: LD_VAR 0 7
46746: PUSH
46747: LD_INT 6
46749: LESS
46750: AND
46751: IFFALSE 46933
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46753: LD_ADDR_VAR 0 9
46757: PUSH
46758: LD_VAR 0 4
46762: PUSH
46763: LD_VAR 0 7
46767: DIFF
46768: PPUSH
46769: LD_INT 3
46771: PPUSH
46772: CALL 105786 0 2
46776: ST_TO_ADDR
// p := [ ] ;
46777: LD_ADDR_VAR 0 11
46781: PUSH
46782: EMPTY
46783: ST_TO_ADDR
// if sort then
46784: LD_VAR 0 9
46788: IFFALSE 46904
// for i = 1 to 6 - mech do
46790: LD_ADDR_VAR 0 3
46794: PUSH
46795: DOUBLE
46796: LD_INT 1
46798: DEC
46799: ST_TO_ADDR
46800: LD_INT 6
46802: PUSH
46803: LD_VAR 0 7
46807: MINUS
46808: PUSH
46809: FOR_TO
46810: IFFALSE 46902
// begin if i = sort then
46812: LD_VAR 0 3
46816: PUSH
46817: LD_VAR 0 9
46821: EQUAL
46822: IFFALSE 46826
// break ;
46824: GO 46902
// if GetClass ( i ) = 3 then
46826: LD_VAR 0 3
46830: PPUSH
46831: CALL_OW 257
46835: PUSH
46836: LD_INT 3
46838: EQUAL
46839: IFFALSE 46843
// continue ;
46841: GO 46809
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46843: LD_ADDR_VAR 0 11
46847: PUSH
46848: LD_VAR 0 11
46852: PPUSH
46853: LD_VAR 0 11
46857: PUSH
46858: LD_INT 1
46860: PLUS
46861: PPUSH
46862: LD_VAR 0 9
46866: PUSH
46867: LD_VAR 0 3
46871: ARRAY
46872: PPUSH
46873: CALL_OW 2
46877: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46878: LD_ADDR_VAR 0 4
46882: PUSH
46883: LD_VAR 0 4
46887: PUSH
46888: LD_VAR 0 9
46892: PUSH
46893: LD_VAR 0 3
46897: ARRAY
46898: DIFF
46899: ST_TO_ADDR
// end ;
46900: GO 46809
46902: POP
46903: POP
// if p then
46904: LD_VAR 0 11
46908: IFFALSE 46933
// result := Replace ( result , 3 , p ) ;
46910: LD_ADDR_VAR 0 2
46914: PUSH
46915: LD_VAR 0 2
46919: PPUSH
46920: LD_INT 3
46922: PPUSH
46923: LD_VAR 0 11
46927: PPUSH
46928: CALL_OW 1
46932: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46933: LD_ADDR_VAR 0 4
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_VAR 0 6
46947: DIFF
46948: ST_TO_ADDR
// if tmp and eng < 4 then
46949: LD_VAR 0 4
46953: PUSH
46954: LD_VAR 0 6
46958: PUSH
46959: LD_INT 4
46961: LESS
46962: AND
46963: IFFALSE 47153
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46965: LD_ADDR_VAR 0 9
46969: PUSH
46970: LD_VAR 0 4
46974: PUSH
46975: LD_VAR 0 7
46979: PUSH
46980: LD_VAR 0 6
46984: UNION
46985: DIFF
46986: PPUSH
46987: LD_INT 2
46989: PPUSH
46990: CALL 105786 0 2
46994: ST_TO_ADDR
// p := [ ] ;
46995: LD_ADDR_VAR 0 11
46999: PUSH
47000: EMPTY
47001: ST_TO_ADDR
// if sort then
47002: LD_VAR 0 9
47006: IFFALSE 47122
// for i = 1 to 4 - eng do
47008: LD_ADDR_VAR 0 3
47012: PUSH
47013: DOUBLE
47014: LD_INT 1
47016: DEC
47017: ST_TO_ADDR
47018: LD_INT 4
47020: PUSH
47021: LD_VAR 0 6
47025: MINUS
47026: PUSH
47027: FOR_TO
47028: IFFALSE 47120
// begin if i = sort then
47030: LD_VAR 0 3
47034: PUSH
47035: LD_VAR 0 9
47039: EQUAL
47040: IFFALSE 47044
// break ;
47042: GO 47120
// if GetClass ( i ) = 2 then
47044: LD_VAR 0 3
47048: PPUSH
47049: CALL_OW 257
47053: PUSH
47054: LD_INT 2
47056: EQUAL
47057: IFFALSE 47061
// continue ;
47059: GO 47027
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47061: LD_ADDR_VAR 0 11
47065: PUSH
47066: LD_VAR 0 11
47070: PPUSH
47071: LD_VAR 0 11
47075: PUSH
47076: LD_INT 1
47078: PLUS
47079: PPUSH
47080: LD_VAR 0 9
47084: PUSH
47085: LD_VAR 0 3
47089: ARRAY
47090: PPUSH
47091: CALL_OW 2
47095: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47096: LD_ADDR_VAR 0 4
47100: PUSH
47101: LD_VAR 0 4
47105: PUSH
47106: LD_VAR 0 9
47110: PUSH
47111: LD_VAR 0 3
47115: ARRAY
47116: DIFF
47117: ST_TO_ADDR
// end ;
47118: GO 47027
47120: POP
47121: POP
// if p then
47122: LD_VAR 0 11
47126: IFFALSE 47151
// result := Replace ( result , 2 , p ) ;
47128: LD_ADDR_VAR 0 2
47132: PUSH
47133: LD_VAR 0 2
47137: PPUSH
47138: LD_INT 2
47140: PPUSH
47141: LD_VAR 0 11
47145: PPUSH
47146: CALL_OW 1
47150: ST_TO_ADDR
// end else
47151: GO 47197
// for i = eng downto 5 do
47153: LD_ADDR_VAR 0 3
47157: PUSH
47158: DOUBLE
47159: LD_VAR 0 6
47163: INC
47164: ST_TO_ADDR
47165: LD_INT 5
47167: PUSH
47168: FOR_DOWNTO
47169: IFFALSE 47195
// tmp := tmp union eng [ i ] ;
47171: LD_ADDR_VAR 0 4
47175: PUSH
47176: LD_VAR 0 4
47180: PUSH
47181: LD_VAR 0 6
47185: PUSH
47186: LD_VAR 0 3
47190: ARRAY
47191: UNION
47192: ST_TO_ADDR
47193: GO 47168
47195: POP
47196: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47197: LD_ADDR_VAR 0 2
47201: PUSH
47202: LD_VAR 0 2
47206: PPUSH
47207: LD_INT 1
47209: PPUSH
47210: LD_VAR 0 4
47214: PUSH
47215: LD_VAR 0 5
47219: DIFF
47220: PPUSH
47221: CALL_OW 1
47225: ST_TO_ADDR
// exit ;
47226: GO 47228
// end ; end ;
47228: LD_VAR 0 2
47232: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47233: LD_INT 0
47235: PPUSH
47236: PPUSH
47237: PPUSH
// if not mc_bases then
47238: LD_EXP 102
47242: NOT
47243: IFFALSE 47247
// exit ;
47245: GO 47389
// for i = 1 to mc_bases do
47247: LD_ADDR_VAR 0 2
47251: PUSH
47252: DOUBLE
47253: LD_INT 1
47255: DEC
47256: ST_TO_ADDR
47257: LD_EXP 102
47261: PUSH
47262: FOR_TO
47263: IFFALSE 47380
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47265: LD_ADDR_VAR 0 3
47269: PUSH
47270: LD_EXP 102
47274: PUSH
47275: LD_VAR 0 2
47279: ARRAY
47280: PPUSH
47281: LD_INT 21
47283: PUSH
47284: LD_INT 3
47286: PUSH
47287: EMPTY
47288: LIST
47289: LIST
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: LD_INT 2
47296: PUSH
47297: LD_INT 30
47299: PUSH
47300: LD_INT 29
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 30
47309: PUSH
47310: LD_INT 30
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: LIST
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: LD_INT 3
47328: PUSH
47329: LD_INT 24
47331: PUSH
47332: LD_INT 1000
47334: PUSH
47335: EMPTY
47336: LIST
47337: LIST
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: LIST
47347: PPUSH
47348: CALL_OW 72
47352: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47353: LD_ADDR_EXP 103
47357: PUSH
47358: LD_EXP 103
47362: PPUSH
47363: LD_VAR 0 2
47367: PPUSH
47368: LD_VAR 0 3
47372: PPUSH
47373: CALL_OW 1
47377: ST_TO_ADDR
// end ;
47378: GO 47262
47380: POP
47381: POP
// RaiseSailEvent ( 101 ) ;
47382: LD_INT 101
47384: PPUSH
47385: CALL_OW 427
// end ;
47389: LD_VAR 0 1
47393: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47394: LD_INT 0
47396: PPUSH
47397: PPUSH
47398: PPUSH
47399: PPUSH
47400: PPUSH
47401: PPUSH
47402: PPUSH
// if not mc_bases then
47403: LD_EXP 102
47407: NOT
47408: IFFALSE 47412
// exit ;
47410: GO 47974
// for i = 1 to mc_bases do
47412: LD_ADDR_VAR 0 2
47416: PUSH
47417: DOUBLE
47418: LD_INT 1
47420: DEC
47421: ST_TO_ADDR
47422: LD_EXP 102
47426: PUSH
47427: FOR_TO
47428: IFFALSE 47965
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47430: LD_ADDR_VAR 0 5
47434: PUSH
47435: LD_EXP 102
47439: PUSH
47440: LD_VAR 0 2
47444: ARRAY
47445: PUSH
47446: LD_EXP 131
47450: PUSH
47451: LD_VAR 0 2
47455: ARRAY
47456: UNION
47457: PPUSH
47458: LD_INT 21
47460: PUSH
47461: LD_INT 1
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 1
47470: PUSH
47471: LD_INT 3
47473: PUSH
47474: LD_INT 54
47476: PUSH
47477: EMPTY
47478: LIST
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: PUSH
47484: LD_INT 3
47486: PUSH
47487: LD_INT 24
47489: PUSH
47490: LD_INT 1000
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: PUSH
47497: EMPTY
47498: LIST
47499: LIST
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: LIST
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PPUSH
47510: CALL_OW 72
47514: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47515: LD_ADDR_VAR 0 6
47519: PUSH
47520: LD_EXP 102
47524: PUSH
47525: LD_VAR 0 2
47529: ARRAY
47530: PPUSH
47531: LD_INT 21
47533: PUSH
47534: LD_INT 1
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: LD_INT 1
47543: PUSH
47544: LD_INT 3
47546: PUSH
47547: LD_INT 54
47549: PUSH
47550: EMPTY
47551: LIST
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: PUSH
47557: LD_INT 3
47559: PUSH
47560: LD_INT 24
47562: PUSH
47563: LD_INT 250
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: PUSH
47574: EMPTY
47575: LIST
47576: LIST
47577: LIST
47578: PUSH
47579: EMPTY
47580: LIST
47581: LIST
47582: PPUSH
47583: CALL_OW 72
47587: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47588: LD_ADDR_VAR 0 7
47592: PUSH
47593: LD_VAR 0 5
47597: PUSH
47598: LD_VAR 0 6
47602: DIFF
47603: ST_TO_ADDR
// if not need_heal_1 then
47604: LD_VAR 0 6
47608: NOT
47609: IFFALSE 47642
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47611: LD_ADDR_EXP 105
47615: PUSH
47616: LD_EXP 105
47620: PPUSH
47621: LD_VAR 0 2
47625: PUSH
47626: LD_INT 1
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: PPUSH
47633: EMPTY
47634: PPUSH
47635: CALL 74553 0 3
47639: ST_TO_ADDR
47640: GO 47712
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47642: LD_ADDR_EXP 105
47646: PUSH
47647: LD_EXP 105
47651: PPUSH
47652: LD_VAR 0 2
47656: PUSH
47657: LD_INT 1
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PPUSH
47664: LD_EXP 105
47668: PUSH
47669: LD_VAR 0 2
47673: ARRAY
47674: PUSH
47675: LD_INT 1
47677: ARRAY
47678: PPUSH
47679: LD_INT 3
47681: PUSH
47682: LD_INT 24
47684: PUSH
47685: LD_INT 1000
47687: PUSH
47688: EMPTY
47689: LIST
47690: LIST
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: PPUSH
47696: CALL_OW 72
47700: PUSH
47701: LD_VAR 0 6
47705: UNION
47706: PPUSH
47707: CALL 74553 0 3
47711: ST_TO_ADDR
// if not need_heal_2 then
47712: LD_VAR 0 7
47716: NOT
47717: IFFALSE 47750
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47719: LD_ADDR_EXP 105
47723: PUSH
47724: LD_EXP 105
47728: PPUSH
47729: LD_VAR 0 2
47733: PUSH
47734: LD_INT 2
47736: PUSH
47737: EMPTY
47738: LIST
47739: LIST
47740: PPUSH
47741: EMPTY
47742: PPUSH
47743: CALL 74553 0 3
47747: ST_TO_ADDR
47748: GO 47782
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47750: LD_ADDR_EXP 105
47754: PUSH
47755: LD_EXP 105
47759: PPUSH
47760: LD_VAR 0 2
47764: PUSH
47765: LD_INT 2
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PPUSH
47772: LD_VAR 0 7
47776: PPUSH
47777: CALL 74553 0 3
47781: ST_TO_ADDR
// if need_heal_2 then
47782: LD_VAR 0 7
47786: IFFALSE 47947
// for j in need_heal_2 do
47788: LD_ADDR_VAR 0 3
47792: PUSH
47793: LD_VAR 0 7
47797: PUSH
47798: FOR_IN
47799: IFFALSE 47945
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47801: LD_ADDR_VAR 0 5
47805: PUSH
47806: LD_EXP 102
47810: PUSH
47811: LD_VAR 0 2
47815: ARRAY
47816: PPUSH
47817: LD_INT 2
47819: PUSH
47820: LD_INT 30
47822: PUSH
47823: LD_INT 6
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 30
47832: PUSH
47833: LD_INT 7
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 30
47842: PUSH
47843: LD_INT 8
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PUSH
47850: LD_INT 30
47852: PUSH
47853: LD_INT 0
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: PUSH
47860: LD_INT 30
47862: PUSH
47863: LD_INT 1
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: PUSH
47870: EMPTY
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: PPUSH
47878: CALL_OW 72
47882: ST_TO_ADDR
// if tmp then
47883: LD_VAR 0 5
47887: IFFALSE 47943
// begin k := NearestUnitToUnit ( tmp , j ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_VAR 0 5
47898: PPUSH
47899: LD_VAR 0 3
47903: PPUSH
47904: CALL_OW 74
47908: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47909: LD_VAR 0 3
47913: PPUSH
47914: LD_VAR 0 4
47918: PPUSH
47919: CALL_OW 296
47923: PUSH
47924: LD_INT 5
47926: GREATER
47927: IFFALSE 47943
// ComMoveToNearbyEntrance ( j , k ) ;
47929: LD_VAR 0 3
47933: PPUSH
47934: LD_VAR 0 4
47938: PPUSH
47939: CALL 108159 0 2
// end ; end ;
47943: GO 47798
47945: POP
47946: POP
// if not need_heal_1 and not need_heal_2 then
47947: LD_VAR 0 6
47951: NOT
47952: PUSH
47953: LD_VAR 0 7
47957: NOT
47958: AND
47959: IFFALSE 47963
// continue ;
47961: GO 47427
// end ;
47963: GO 47427
47965: POP
47966: POP
// RaiseSailEvent ( 102 ) ;
47967: LD_INT 102
47969: PPUSH
47970: CALL_OW 427
// end ;
47974: LD_VAR 0 1
47978: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47979: LD_INT 0
47981: PPUSH
47982: PPUSH
47983: PPUSH
47984: PPUSH
47985: PPUSH
47986: PPUSH
47987: PPUSH
47988: PPUSH
// if not mc_bases then
47989: LD_EXP 102
47993: NOT
47994: IFFALSE 47998
// exit ;
47996: GO 48909
// for i = 1 to mc_bases do
47998: LD_ADDR_VAR 0 2
48002: PUSH
48003: DOUBLE
48004: LD_INT 1
48006: DEC
48007: ST_TO_ADDR
48008: LD_EXP 102
48012: PUSH
48013: FOR_TO
48014: IFFALSE 48907
// begin if not mc_building_need_repair [ i ] then
48016: LD_EXP 103
48020: PUSH
48021: LD_VAR 0 2
48025: ARRAY
48026: NOT
48027: IFFALSE 48212
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48029: LD_ADDR_VAR 0 6
48033: PUSH
48034: LD_EXP 121
48038: PUSH
48039: LD_VAR 0 2
48043: ARRAY
48044: PPUSH
48045: LD_INT 3
48047: PUSH
48048: LD_INT 24
48050: PUSH
48051: LD_INT 1000
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: LD_INT 2
48064: PUSH
48065: LD_INT 34
48067: PUSH
48068: LD_INT 13
48070: PUSH
48071: EMPTY
48072: LIST
48073: LIST
48074: PUSH
48075: LD_INT 34
48077: PUSH
48078: LD_INT 52
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PUSH
48085: LD_INT 34
48087: PUSH
48088: LD_INT 88
48090: PUSH
48091: EMPTY
48092: LIST
48093: LIST
48094: PUSH
48095: EMPTY
48096: LIST
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: EMPTY
48102: LIST
48103: LIST
48104: PPUSH
48105: CALL_OW 72
48109: ST_TO_ADDR
// if cranes then
48110: LD_VAR 0 6
48114: IFFALSE 48176
// for j in cranes do
48116: LD_ADDR_VAR 0 3
48120: PUSH
48121: LD_VAR 0 6
48125: PUSH
48126: FOR_IN
48127: IFFALSE 48174
// if not IsInArea ( j , mc_parking [ i ] ) then
48129: LD_VAR 0 3
48133: PPUSH
48134: LD_EXP 126
48138: PUSH
48139: LD_VAR 0 2
48143: ARRAY
48144: PPUSH
48145: CALL_OW 308
48149: NOT
48150: IFFALSE 48172
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48152: LD_VAR 0 3
48156: PPUSH
48157: LD_EXP 126
48161: PUSH
48162: LD_VAR 0 2
48166: ARRAY
48167: PPUSH
48168: CALL_OW 113
48172: GO 48126
48174: POP
48175: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48176: LD_ADDR_EXP 104
48180: PUSH
48181: LD_EXP 104
48185: PPUSH
48186: LD_VAR 0 2
48190: PPUSH
48191: EMPTY
48192: PPUSH
48193: CALL_OW 1
48197: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48198: LD_VAR 0 2
48202: PPUSH
48203: LD_INT 101
48205: PPUSH
48206: CALL 43052 0 2
// continue ;
48210: GO 48013
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48212: LD_ADDR_EXP 108
48216: PUSH
48217: LD_EXP 108
48221: PPUSH
48222: LD_VAR 0 2
48226: PPUSH
48227: EMPTY
48228: PPUSH
48229: CALL_OW 1
48233: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48234: LD_VAR 0 2
48238: PPUSH
48239: LD_INT 103
48241: PPUSH
48242: CALL 43052 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48246: LD_ADDR_VAR 0 5
48250: PUSH
48251: LD_EXP 102
48255: PUSH
48256: LD_VAR 0 2
48260: ARRAY
48261: PUSH
48262: LD_EXP 131
48266: PUSH
48267: LD_VAR 0 2
48271: ARRAY
48272: UNION
48273: PPUSH
48274: LD_INT 2
48276: PUSH
48277: LD_INT 25
48279: PUSH
48280: LD_INT 2
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 25
48289: PUSH
48290: LD_INT 16
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: LIST
48301: PUSH
48302: EMPTY
48303: LIST
48304: PPUSH
48305: CALL_OW 72
48309: ST_TO_ADDR
// if mc_need_heal [ i ] then
48310: LD_EXP 105
48314: PUSH
48315: LD_VAR 0 2
48319: ARRAY
48320: IFFALSE 48364
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48322: LD_ADDR_VAR 0 5
48326: PUSH
48327: LD_VAR 0 5
48331: PUSH
48332: LD_EXP 105
48336: PUSH
48337: LD_VAR 0 2
48341: ARRAY
48342: PUSH
48343: LD_INT 1
48345: ARRAY
48346: PUSH
48347: LD_EXP 105
48351: PUSH
48352: LD_VAR 0 2
48356: ARRAY
48357: PUSH
48358: LD_INT 2
48360: ARRAY
48361: UNION
48362: DIFF
48363: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48364: LD_ADDR_VAR 0 6
48368: PUSH
48369: LD_EXP 121
48373: PUSH
48374: LD_VAR 0 2
48378: ARRAY
48379: PPUSH
48380: LD_INT 2
48382: PUSH
48383: LD_INT 34
48385: PUSH
48386: LD_INT 13
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 34
48395: PUSH
48396: LD_INT 52
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 34
48405: PUSH
48406: LD_INT 88
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: PPUSH
48419: CALL_OW 72
48423: ST_TO_ADDR
// if cranes then
48424: LD_VAR 0 6
48428: IFFALSE 48596
// begin for j in cranes do
48430: LD_ADDR_VAR 0 3
48434: PUSH
48435: LD_VAR 0 6
48439: PUSH
48440: FOR_IN
48441: IFFALSE 48594
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48443: LD_VAR 0 3
48447: PPUSH
48448: CALL_OW 256
48452: PUSH
48453: LD_INT 1000
48455: EQUAL
48456: PUSH
48457: LD_VAR 0 3
48461: PPUSH
48462: CALL_OW 314
48466: NOT
48467: AND
48468: IFFALSE 48534
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48470: LD_ADDR_VAR 0 8
48474: PUSH
48475: LD_EXP 103
48479: PUSH
48480: LD_VAR 0 2
48484: ARRAY
48485: PPUSH
48486: LD_VAR 0 3
48490: PPUSH
48491: CALL_OW 74
48495: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48496: LD_VAR 0 8
48500: PPUSH
48501: LD_INT 16
48503: PPUSH
48504: CALL 77518 0 2
48508: PUSH
48509: LD_INT 4
48511: ARRAY
48512: PUSH
48513: LD_INT 10
48515: LESS
48516: IFFALSE 48532
// ComRepairBuilding ( j , to_repair ) ;
48518: LD_VAR 0 3
48522: PPUSH
48523: LD_VAR 0 8
48527: PPUSH
48528: CALL_OW 130
// end else
48532: GO 48592
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48534: LD_VAR 0 3
48538: PPUSH
48539: CALL_OW 256
48543: PUSH
48544: LD_INT 500
48546: LESS
48547: PUSH
48548: LD_VAR 0 3
48552: PPUSH
48553: LD_EXP 126
48557: PUSH
48558: LD_VAR 0 2
48562: ARRAY
48563: PPUSH
48564: CALL_OW 308
48568: NOT
48569: AND
48570: IFFALSE 48592
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48572: LD_VAR 0 3
48576: PPUSH
48577: LD_EXP 126
48581: PUSH
48582: LD_VAR 0 2
48586: ARRAY
48587: PPUSH
48588: CALL_OW 113
// end ;
48592: GO 48440
48594: POP
48595: POP
// end ; if tmp > 3 then
48596: LD_VAR 0 5
48600: PUSH
48601: LD_INT 3
48603: GREATER
48604: IFFALSE 48624
// tmp := ShrinkArray ( tmp , 4 ) ;
48606: LD_ADDR_VAR 0 5
48610: PUSH
48611: LD_VAR 0 5
48615: PPUSH
48616: LD_INT 4
48618: PPUSH
48619: CALL 107597 0 2
48623: ST_TO_ADDR
// if not tmp then
48624: LD_VAR 0 5
48628: NOT
48629: IFFALSE 48633
// continue ;
48631: GO 48013
// for j in tmp do
48633: LD_ADDR_VAR 0 3
48637: PUSH
48638: LD_VAR 0 5
48642: PUSH
48643: FOR_IN
48644: IFFALSE 48903
// begin if IsInUnit ( j ) then
48646: LD_VAR 0 3
48650: PPUSH
48651: CALL_OW 310
48655: IFFALSE 48666
// ComExitBuilding ( j ) ;
48657: LD_VAR 0 3
48661: PPUSH
48662: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48666: LD_VAR 0 3
48670: PUSH
48671: LD_EXP 104
48675: PUSH
48676: LD_VAR 0 2
48680: ARRAY
48681: IN
48682: NOT
48683: IFFALSE 48741
// begin SetTag ( j , 101 ) ;
48685: LD_VAR 0 3
48689: PPUSH
48690: LD_INT 101
48692: PPUSH
48693: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48697: LD_ADDR_EXP 104
48701: PUSH
48702: LD_EXP 104
48706: PPUSH
48707: LD_VAR 0 2
48711: PUSH
48712: LD_EXP 104
48716: PUSH
48717: LD_VAR 0 2
48721: ARRAY
48722: PUSH
48723: LD_INT 1
48725: PLUS
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PPUSH
48731: LD_VAR 0 3
48735: PPUSH
48736: CALL 74553 0 3
48740: ST_TO_ADDR
// end ; wait ( 1 ) ;
48741: LD_INT 1
48743: PPUSH
48744: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48748: LD_ADDR_VAR 0 7
48752: PUSH
48753: LD_EXP 103
48757: PUSH
48758: LD_VAR 0 2
48762: ARRAY
48763: ST_TO_ADDR
// if mc_scan [ i ] then
48764: LD_EXP 125
48768: PUSH
48769: LD_VAR 0 2
48773: ARRAY
48774: IFFALSE 48836
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48776: LD_ADDR_VAR 0 7
48780: PUSH
48781: LD_EXP 103
48785: PUSH
48786: LD_VAR 0 2
48790: ARRAY
48791: PPUSH
48792: LD_INT 3
48794: PUSH
48795: LD_INT 30
48797: PUSH
48798: LD_INT 32
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: LD_INT 30
48807: PUSH
48808: LD_INT 33
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PUSH
48815: LD_INT 30
48817: PUSH
48818: LD_INT 31
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: PPUSH
48831: CALL_OW 72
48835: ST_TO_ADDR
// if not to_repair_tmp then
48836: LD_VAR 0 7
48840: NOT
48841: IFFALSE 48845
// continue ;
48843: GO 48643
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48845: LD_ADDR_VAR 0 8
48849: PUSH
48850: LD_VAR 0 7
48854: PPUSH
48855: LD_VAR 0 3
48859: PPUSH
48860: CALL_OW 74
48864: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48865: LD_VAR 0 8
48869: PPUSH
48870: LD_INT 16
48872: PPUSH
48873: CALL 77518 0 2
48877: PUSH
48878: LD_INT 4
48880: ARRAY
48881: PUSH
48882: LD_INT 14
48884: LESS
48885: IFFALSE 48901
// ComRepairBuilding ( j , to_repair ) ;
48887: LD_VAR 0 3
48891: PPUSH
48892: LD_VAR 0 8
48896: PPUSH
48897: CALL_OW 130
// end ;
48901: GO 48643
48903: POP
48904: POP
// end ;
48905: GO 48013
48907: POP
48908: POP
// end ;
48909: LD_VAR 0 1
48913: RET
// export function MC_Heal ; var i , j , tmp ; begin
48914: LD_INT 0
48916: PPUSH
48917: PPUSH
48918: PPUSH
48919: PPUSH
// if not mc_bases then
48920: LD_EXP 102
48924: NOT
48925: IFFALSE 48929
// exit ;
48927: GO 49331
// for i = 1 to mc_bases do
48929: LD_ADDR_VAR 0 2
48933: PUSH
48934: DOUBLE
48935: LD_INT 1
48937: DEC
48938: ST_TO_ADDR
48939: LD_EXP 102
48943: PUSH
48944: FOR_TO
48945: IFFALSE 49329
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48947: LD_EXP 105
48951: PUSH
48952: LD_VAR 0 2
48956: ARRAY
48957: PUSH
48958: LD_INT 1
48960: ARRAY
48961: NOT
48962: PUSH
48963: LD_EXP 105
48967: PUSH
48968: LD_VAR 0 2
48972: ARRAY
48973: PUSH
48974: LD_INT 2
48976: ARRAY
48977: NOT
48978: AND
48979: IFFALSE 49017
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48981: LD_ADDR_EXP 106
48985: PUSH
48986: LD_EXP 106
48990: PPUSH
48991: LD_VAR 0 2
48995: PPUSH
48996: EMPTY
48997: PPUSH
48998: CALL_OW 1
49002: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49003: LD_VAR 0 2
49007: PPUSH
49008: LD_INT 102
49010: PPUSH
49011: CALL 43052 0 2
// continue ;
49015: GO 48944
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49017: LD_ADDR_VAR 0 4
49021: PUSH
49022: LD_EXP 102
49026: PUSH
49027: LD_VAR 0 2
49031: ARRAY
49032: PPUSH
49033: LD_INT 25
49035: PUSH
49036: LD_INT 4
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PPUSH
49043: CALL_OW 72
49047: ST_TO_ADDR
// if not tmp then
49048: LD_VAR 0 4
49052: NOT
49053: IFFALSE 49057
// continue ;
49055: GO 48944
// if mc_taming [ i ] then
49057: LD_EXP 133
49061: PUSH
49062: LD_VAR 0 2
49066: ARRAY
49067: IFFALSE 49091
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49069: LD_ADDR_EXP 133
49073: PUSH
49074: LD_EXP 133
49078: PPUSH
49079: LD_VAR 0 2
49083: PPUSH
49084: EMPTY
49085: PPUSH
49086: CALL_OW 1
49090: ST_TO_ADDR
// for j in tmp do
49091: LD_ADDR_VAR 0 3
49095: PUSH
49096: LD_VAR 0 4
49100: PUSH
49101: FOR_IN
49102: IFFALSE 49325
// begin if IsInUnit ( j ) then
49104: LD_VAR 0 3
49108: PPUSH
49109: CALL_OW 310
49113: IFFALSE 49124
// ComExitBuilding ( j ) ;
49115: LD_VAR 0 3
49119: PPUSH
49120: CALL_OW 122
// if not j in mc_healers [ i ] then
49124: LD_VAR 0 3
49128: PUSH
49129: LD_EXP 106
49133: PUSH
49134: LD_VAR 0 2
49138: ARRAY
49139: IN
49140: NOT
49141: IFFALSE 49187
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49143: LD_ADDR_EXP 106
49147: PUSH
49148: LD_EXP 106
49152: PPUSH
49153: LD_VAR 0 2
49157: PUSH
49158: LD_EXP 106
49162: PUSH
49163: LD_VAR 0 2
49167: ARRAY
49168: PUSH
49169: LD_INT 1
49171: PLUS
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PPUSH
49177: LD_VAR 0 3
49181: PPUSH
49182: CALL 74553 0 3
49186: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49187: LD_VAR 0 3
49191: PPUSH
49192: CALL_OW 110
49196: PUSH
49197: LD_INT 102
49199: NONEQUAL
49200: IFFALSE 49214
// SetTag ( j , 102 ) ;
49202: LD_VAR 0 3
49206: PPUSH
49207: LD_INT 102
49209: PPUSH
49210: CALL_OW 109
// Wait ( 3 ) ;
49214: LD_INT 3
49216: PPUSH
49217: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49221: LD_EXP 105
49225: PUSH
49226: LD_VAR 0 2
49230: ARRAY
49231: PUSH
49232: LD_INT 1
49234: ARRAY
49235: IFFALSE 49267
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49237: LD_VAR 0 3
49241: PPUSH
49242: LD_EXP 105
49246: PUSH
49247: LD_VAR 0 2
49251: ARRAY
49252: PUSH
49253: LD_INT 1
49255: ARRAY
49256: PUSH
49257: LD_INT 1
49259: ARRAY
49260: PPUSH
49261: CALL_OW 128
49265: GO 49323
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49267: LD_VAR 0 3
49271: PPUSH
49272: CALL_OW 314
49276: NOT
49277: PUSH
49278: LD_EXP 105
49282: PUSH
49283: LD_VAR 0 2
49287: ARRAY
49288: PUSH
49289: LD_INT 2
49291: ARRAY
49292: AND
49293: IFFALSE 49323
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49295: LD_VAR 0 3
49299: PPUSH
49300: LD_EXP 105
49304: PUSH
49305: LD_VAR 0 2
49309: ARRAY
49310: PUSH
49311: LD_INT 2
49313: ARRAY
49314: PUSH
49315: LD_INT 1
49317: ARRAY
49318: PPUSH
49319: CALL_OW 128
// end ;
49323: GO 49101
49325: POP
49326: POP
// end ;
49327: GO 48944
49329: POP
49330: POP
// end ;
49331: LD_VAR 0 1
49335: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49336: LD_INT 0
49338: PPUSH
49339: PPUSH
49340: PPUSH
49341: PPUSH
49342: PPUSH
49343: PPUSH
// if not mc_bases then
49344: LD_EXP 102
49348: NOT
49349: IFFALSE 49353
// exit ;
49351: GO 50516
// for i = 1 to mc_bases do
49353: LD_ADDR_VAR 0 2
49357: PUSH
49358: DOUBLE
49359: LD_INT 1
49361: DEC
49362: ST_TO_ADDR
49363: LD_EXP 102
49367: PUSH
49368: FOR_TO
49369: IFFALSE 50514
// begin if mc_scan [ i ] then
49371: LD_EXP 125
49375: PUSH
49376: LD_VAR 0 2
49380: ARRAY
49381: IFFALSE 49385
// continue ;
49383: GO 49368
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49385: LD_EXP 107
49389: PUSH
49390: LD_VAR 0 2
49394: ARRAY
49395: NOT
49396: PUSH
49397: LD_EXP 109
49401: PUSH
49402: LD_VAR 0 2
49406: ARRAY
49407: NOT
49408: AND
49409: PUSH
49410: LD_EXP 108
49414: PUSH
49415: LD_VAR 0 2
49419: ARRAY
49420: AND
49421: IFFALSE 49459
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49423: LD_ADDR_EXP 108
49427: PUSH
49428: LD_EXP 108
49432: PPUSH
49433: LD_VAR 0 2
49437: PPUSH
49438: EMPTY
49439: PPUSH
49440: CALL_OW 1
49444: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49445: LD_VAR 0 2
49449: PPUSH
49450: LD_INT 103
49452: PPUSH
49453: CALL 43052 0 2
// continue ;
49457: GO 49368
// end ; if mc_construct_list [ i ] then
49459: LD_EXP 109
49463: PUSH
49464: LD_VAR 0 2
49468: ARRAY
49469: IFFALSE 49689
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49471: LD_ADDR_VAR 0 5
49475: PUSH
49476: LD_EXP 102
49480: PUSH
49481: LD_VAR 0 2
49485: ARRAY
49486: PPUSH
49487: LD_INT 25
49489: PUSH
49490: LD_INT 2
49492: PUSH
49493: EMPTY
49494: LIST
49495: LIST
49496: PPUSH
49497: CALL_OW 72
49501: PUSH
49502: LD_EXP 104
49506: PUSH
49507: LD_VAR 0 2
49511: ARRAY
49512: DIFF
49513: ST_TO_ADDR
// if not tmp then
49514: LD_VAR 0 5
49518: NOT
49519: IFFALSE 49523
// continue ;
49521: GO 49368
// for j in tmp do
49523: LD_ADDR_VAR 0 3
49527: PUSH
49528: LD_VAR 0 5
49532: PUSH
49533: FOR_IN
49534: IFFALSE 49685
// begin if not mc_builders [ i ] then
49536: LD_EXP 108
49540: PUSH
49541: LD_VAR 0 2
49545: ARRAY
49546: NOT
49547: IFFALSE 49605
// begin SetTag ( j , 103 ) ;
49549: LD_VAR 0 3
49553: PPUSH
49554: LD_INT 103
49556: PPUSH
49557: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49561: LD_ADDR_EXP 108
49565: PUSH
49566: LD_EXP 108
49570: PPUSH
49571: LD_VAR 0 2
49575: PUSH
49576: LD_EXP 108
49580: PUSH
49581: LD_VAR 0 2
49585: ARRAY
49586: PUSH
49587: LD_INT 1
49589: PLUS
49590: PUSH
49591: EMPTY
49592: LIST
49593: LIST
49594: PPUSH
49595: LD_VAR 0 3
49599: PPUSH
49600: CALL 74553 0 3
49604: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49605: LD_VAR 0 3
49609: PPUSH
49610: CALL_OW 310
49614: IFFALSE 49625
// ComExitBuilding ( j ) ;
49616: LD_VAR 0 3
49620: PPUSH
49621: CALL_OW 122
// wait ( 3 ) ;
49625: LD_INT 3
49627: PPUSH
49628: CALL_OW 67
// if not mc_construct_list [ i ] then
49632: LD_EXP 109
49636: PUSH
49637: LD_VAR 0 2
49641: ARRAY
49642: NOT
49643: IFFALSE 49647
// break ;
49645: GO 49685
// if not HasTask ( j ) then
49647: LD_VAR 0 3
49651: PPUSH
49652: CALL_OW 314
49656: NOT
49657: IFFALSE 49683
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49659: LD_VAR 0 3
49663: PPUSH
49664: LD_EXP 109
49668: PUSH
49669: LD_VAR 0 2
49673: ARRAY
49674: PUSH
49675: LD_INT 1
49677: ARRAY
49678: PPUSH
49679: CALL 77791 0 2
// end ;
49683: GO 49533
49685: POP
49686: POP
// end else
49687: GO 50512
// if mc_build_list [ i ] then
49689: LD_EXP 107
49693: PUSH
49694: LD_VAR 0 2
49698: ARRAY
49699: IFFALSE 50512
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49701: LD_EXP 107
49705: PUSH
49706: LD_VAR 0 2
49710: ARRAY
49711: PUSH
49712: LD_INT 1
49714: ARRAY
49715: PUSH
49716: LD_INT 1
49718: ARRAY
49719: PPUSH
49720: CALL 77615 0 1
49724: PUSH
49725: LD_EXP 102
49729: PUSH
49730: LD_VAR 0 2
49734: ARRAY
49735: PPUSH
49736: LD_INT 2
49738: PUSH
49739: LD_INT 30
49741: PUSH
49742: LD_INT 2
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: LD_INT 30
49751: PUSH
49752: LD_INT 3
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: EMPTY
49760: LIST
49761: LIST
49762: LIST
49763: PPUSH
49764: CALL_OW 72
49768: NOT
49769: AND
49770: IFFALSE 49875
// begin for j = 1 to mc_build_list [ i ] do
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: DOUBLE
49778: LD_INT 1
49780: DEC
49781: ST_TO_ADDR
49782: LD_EXP 107
49786: PUSH
49787: LD_VAR 0 2
49791: ARRAY
49792: PUSH
49793: FOR_TO
49794: IFFALSE 49873
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49796: LD_EXP 107
49800: PUSH
49801: LD_VAR 0 2
49805: ARRAY
49806: PUSH
49807: LD_VAR 0 3
49811: ARRAY
49812: PUSH
49813: LD_INT 1
49815: ARRAY
49816: PUSH
49817: LD_INT 2
49819: EQUAL
49820: IFFALSE 49871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49822: LD_ADDR_EXP 107
49826: PUSH
49827: LD_EXP 107
49831: PPUSH
49832: LD_VAR 0 2
49836: PPUSH
49837: LD_EXP 107
49841: PUSH
49842: LD_VAR 0 2
49846: ARRAY
49847: PPUSH
49848: LD_VAR 0 3
49852: PPUSH
49853: LD_INT 1
49855: PPUSH
49856: LD_INT 0
49858: PPUSH
49859: CALL 73971 0 4
49863: PPUSH
49864: CALL_OW 1
49868: ST_TO_ADDR
// break ;
49869: GO 49873
// end ;
49871: GO 49793
49873: POP
49874: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49875: LD_ADDR_VAR 0 6
49879: PUSH
49880: LD_EXP 102
49884: PUSH
49885: LD_VAR 0 2
49889: ARRAY
49890: PPUSH
49891: LD_INT 2
49893: PUSH
49894: LD_INT 30
49896: PUSH
49897: LD_INT 0
49899: PUSH
49900: EMPTY
49901: LIST
49902: LIST
49903: PUSH
49904: LD_INT 30
49906: PUSH
49907: LD_INT 1
49909: PUSH
49910: EMPTY
49911: LIST
49912: LIST
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: LIST
49918: PPUSH
49919: CALL_OW 72
49923: ST_TO_ADDR
// for k := 1 to depot do
49924: LD_ADDR_VAR 0 4
49928: PUSH
49929: DOUBLE
49930: LD_INT 1
49932: DEC
49933: ST_TO_ADDR
49934: LD_VAR 0 6
49938: PUSH
49939: FOR_TO
49940: IFFALSE 50510
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49942: LD_EXP 107
49946: PUSH
49947: LD_VAR 0 2
49951: ARRAY
49952: PUSH
49953: LD_INT 1
49955: ARRAY
49956: PUSH
49957: LD_INT 1
49959: ARRAY
49960: PUSH
49961: LD_INT 0
49963: EQUAL
49964: PUSH
49965: LD_VAR 0 6
49969: PUSH
49970: LD_VAR 0 4
49974: ARRAY
49975: PPUSH
49976: LD_EXP 107
49980: PUSH
49981: LD_VAR 0 2
49985: ARRAY
49986: PUSH
49987: LD_INT 1
49989: ARRAY
49990: PUSH
49991: LD_INT 1
49993: ARRAY
49994: PPUSH
49995: LD_EXP 107
49999: PUSH
50000: LD_VAR 0 2
50004: ARRAY
50005: PUSH
50006: LD_INT 1
50008: ARRAY
50009: PUSH
50010: LD_INT 2
50012: ARRAY
50013: PPUSH
50014: LD_EXP 107
50018: PUSH
50019: LD_VAR 0 2
50023: ARRAY
50024: PUSH
50025: LD_INT 1
50027: ARRAY
50028: PUSH
50029: LD_INT 3
50031: ARRAY
50032: PPUSH
50033: LD_EXP 107
50037: PUSH
50038: LD_VAR 0 2
50042: ARRAY
50043: PUSH
50044: LD_INT 1
50046: ARRAY
50047: PUSH
50048: LD_INT 4
50050: ARRAY
50051: PPUSH
50052: CALL 83027 0 5
50056: OR
50057: IFFALSE 50338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50059: LD_ADDR_VAR 0 5
50063: PUSH
50064: LD_EXP 102
50068: PUSH
50069: LD_VAR 0 2
50073: ARRAY
50074: PPUSH
50075: LD_INT 25
50077: PUSH
50078: LD_INT 2
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PPUSH
50085: CALL_OW 72
50089: PUSH
50090: LD_EXP 104
50094: PUSH
50095: LD_VAR 0 2
50099: ARRAY
50100: DIFF
50101: ST_TO_ADDR
// if not tmp then
50102: LD_VAR 0 5
50106: NOT
50107: IFFALSE 50111
// continue ;
50109: GO 49939
// for j in tmp do
50111: LD_ADDR_VAR 0 3
50115: PUSH
50116: LD_VAR 0 5
50120: PUSH
50121: FOR_IN
50122: IFFALSE 50334
// begin if not mc_builders [ i ] then
50124: LD_EXP 108
50128: PUSH
50129: LD_VAR 0 2
50133: ARRAY
50134: NOT
50135: IFFALSE 50193
// begin SetTag ( j , 103 ) ;
50137: LD_VAR 0 3
50141: PPUSH
50142: LD_INT 103
50144: PPUSH
50145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50149: LD_ADDR_EXP 108
50153: PUSH
50154: LD_EXP 108
50158: PPUSH
50159: LD_VAR 0 2
50163: PUSH
50164: LD_EXP 108
50168: PUSH
50169: LD_VAR 0 2
50173: ARRAY
50174: PUSH
50175: LD_INT 1
50177: PLUS
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: PPUSH
50183: LD_VAR 0 3
50187: PPUSH
50188: CALL 74553 0 3
50192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50193: LD_VAR 0 3
50197: PPUSH
50198: CALL_OW 310
50202: IFFALSE 50213
// ComExitBuilding ( j ) ;
50204: LD_VAR 0 3
50208: PPUSH
50209: CALL_OW 122
// wait ( 3 ) ;
50213: LD_INT 3
50215: PPUSH
50216: CALL_OW 67
// if not mc_build_list [ i ] then
50220: LD_EXP 107
50224: PUSH
50225: LD_VAR 0 2
50229: ARRAY
50230: NOT
50231: IFFALSE 50235
// break ;
50233: GO 50334
// if not HasTask ( j ) then
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 314
50244: NOT
50245: IFFALSE 50332
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50247: LD_VAR 0 3
50251: PPUSH
50252: LD_EXP 107
50256: PUSH
50257: LD_VAR 0 2
50261: ARRAY
50262: PUSH
50263: LD_INT 1
50265: ARRAY
50266: PUSH
50267: LD_INT 1
50269: ARRAY
50270: PPUSH
50271: LD_EXP 107
50275: PUSH
50276: LD_VAR 0 2
50280: ARRAY
50281: PUSH
50282: LD_INT 1
50284: ARRAY
50285: PUSH
50286: LD_INT 2
50288: ARRAY
50289: PPUSH
50290: LD_EXP 107
50294: PUSH
50295: LD_VAR 0 2
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: ARRAY
50304: PUSH
50305: LD_INT 3
50307: ARRAY
50308: PPUSH
50309: LD_EXP 107
50313: PUSH
50314: LD_VAR 0 2
50318: ARRAY
50319: PUSH
50320: LD_INT 1
50322: ARRAY
50323: PUSH
50324: LD_INT 4
50326: ARRAY
50327: PPUSH
50328: CALL_OW 145
// end ;
50332: GO 50121
50334: POP
50335: POP
// end else
50336: GO 50508
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50338: LD_EXP 102
50342: PUSH
50343: LD_VAR 0 2
50347: ARRAY
50348: PPUSH
50349: LD_EXP 107
50353: PUSH
50354: LD_VAR 0 2
50358: ARRAY
50359: PUSH
50360: LD_INT 1
50362: ARRAY
50363: PUSH
50364: LD_INT 1
50366: ARRAY
50367: PPUSH
50368: LD_EXP 107
50372: PUSH
50373: LD_VAR 0 2
50377: ARRAY
50378: PUSH
50379: LD_INT 1
50381: ARRAY
50382: PUSH
50383: LD_INT 2
50385: ARRAY
50386: PPUSH
50387: LD_EXP 107
50391: PUSH
50392: LD_VAR 0 2
50396: ARRAY
50397: PUSH
50398: LD_INT 1
50400: ARRAY
50401: PUSH
50402: LD_INT 3
50404: ARRAY
50405: PPUSH
50406: LD_EXP 107
50410: PUSH
50411: LD_VAR 0 2
50415: ARRAY
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_INT 4
50423: ARRAY
50424: PPUSH
50425: LD_EXP 102
50429: PUSH
50430: LD_VAR 0 2
50434: ARRAY
50435: PPUSH
50436: LD_INT 21
50438: PUSH
50439: LD_INT 3
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: PPUSH
50446: CALL_OW 72
50450: PPUSH
50451: EMPTY
50452: PPUSH
50453: CALL 81781 0 7
50457: NOT
50458: IFFALSE 50508
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50460: LD_ADDR_EXP 107
50464: PUSH
50465: LD_EXP 107
50469: PPUSH
50470: LD_VAR 0 2
50474: PPUSH
50475: LD_EXP 107
50479: PUSH
50480: LD_VAR 0 2
50484: ARRAY
50485: PPUSH
50486: LD_INT 1
50488: PPUSH
50489: LD_INT 1
50491: NEG
50492: PPUSH
50493: LD_INT 0
50495: PPUSH
50496: CALL 73971 0 4
50500: PPUSH
50501: CALL_OW 1
50505: ST_TO_ADDR
// continue ;
50506: GO 49939
// end ; end ;
50508: GO 49939
50510: POP
50511: POP
// end ; end ;
50512: GO 49368
50514: POP
50515: POP
// end ;
50516: LD_VAR 0 1
50520: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50521: LD_INT 0
50523: PPUSH
50524: PPUSH
50525: PPUSH
50526: PPUSH
50527: PPUSH
50528: PPUSH
// if not mc_bases then
50529: LD_EXP 102
50533: NOT
50534: IFFALSE 50538
// exit ;
50536: GO 50965
// for i = 1 to mc_bases do
50538: LD_ADDR_VAR 0 2
50542: PUSH
50543: DOUBLE
50544: LD_INT 1
50546: DEC
50547: ST_TO_ADDR
50548: LD_EXP 102
50552: PUSH
50553: FOR_TO
50554: IFFALSE 50963
// begin tmp := mc_build_upgrade [ i ] ;
50556: LD_ADDR_VAR 0 4
50560: PUSH
50561: LD_EXP 134
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50572: LD_ADDR_VAR 0 6
50576: PUSH
50577: LD_EXP 135
50581: PUSH
50582: LD_VAR 0 2
50586: ARRAY
50587: PPUSH
50588: LD_INT 2
50590: PUSH
50591: LD_INT 30
50593: PUSH
50594: LD_INT 6
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PUSH
50601: LD_INT 30
50603: PUSH
50604: LD_INT 7
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: LIST
50615: PPUSH
50616: CALL_OW 72
50620: ST_TO_ADDR
// if not tmp and not lab then
50621: LD_VAR 0 4
50625: NOT
50626: PUSH
50627: LD_VAR 0 6
50631: NOT
50632: AND
50633: IFFALSE 50637
// continue ;
50635: GO 50553
// if tmp then
50637: LD_VAR 0 4
50641: IFFALSE 50761
// for j in tmp do
50643: LD_ADDR_VAR 0 3
50647: PUSH
50648: LD_VAR 0 4
50652: PUSH
50653: FOR_IN
50654: IFFALSE 50759
// begin if UpgradeCost ( j ) then
50656: LD_VAR 0 3
50660: PPUSH
50661: CALL 81441 0 1
50665: IFFALSE 50757
// begin ComUpgrade ( j ) ;
50667: LD_VAR 0 3
50671: PPUSH
50672: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50676: LD_ADDR_EXP 134
50680: PUSH
50681: LD_EXP 134
50685: PPUSH
50686: LD_VAR 0 2
50690: PPUSH
50691: LD_EXP 134
50695: PUSH
50696: LD_VAR 0 2
50700: ARRAY
50701: PUSH
50702: LD_VAR 0 3
50706: DIFF
50707: PPUSH
50708: CALL_OW 1
50712: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50713: LD_ADDR_EXP 109
50717: PUSH
50718: LD_EXP 109
50722: PPUSH
50723: LD_VAR 0 2
50727: PUSH
50728: LD_EXP 109
50732: PUSH
50733: LD_VAR 0 2
50737: ARRAY
50738: PUSH
50739: LD_INT 1
50741: PLUS
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PPUSH
50747: LD_VAR 0 3
50751: PPUSH
50752: CALL 74553 0 3
50756: ST_TO_ADDR
// end ; end ;
50757: GO 50653
50759: POP
50760: POP
// if not lab or not mc_lab_upgrade [ i ] then
50761: LD_VAR 0 6
50765: NOT
50766: PUSH
50767: LD_EXP 136
50771: PUSH
50772: LD_VAR 0 2
50776: ARRAY
50777: NOT
50778: OR
50779: IFFALSE 50783
// continue ;
50781: GO 50553
// for j in lab do
50783: LD_ADDR_VAR 0 3
50787: PUSH
50788: LD_VAR 0 6
50792: PUSH
50793: FOR_IN
50794: IFFALSE 50959
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50796: LD_VAR 0 3
50800: PPUSH
50801: CALL_OW 266
50805: PUSH
50806: LD_INT 6
50808: PUSH
50809: LD_INT 7
50811: PUSH
50812: EMPTY
50813: LIST
50814: LIST
50815: IN
50816: PUSH
50817: LD_VAR 0 3
50821: PPUSH
50822: CALL_OW 461
50826: PUSH
50827: LD_INT 1
50829: NONEQUAL
50830: AND
50831: IFFALSE 50957
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50833: LD_VAR 0 3
50837: PPUSH
50838: LD_EXP 136
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: LD_INT 1
50851: ARRAY
50852: PPUSH
50853: CALL 81646 0 2
50857: IFFALSE 50957
// begin ComCancel ( j ) ;
50859: LD_VAR 0 3
50863: PPUSH
50864: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50868: LD_VAR 0 3
50872: PPUSH
50873: LD_EXP 136
50877: PUSH
50878: LD_VAR 0 2
50882: ARRAY
50883: PUSH
50884: LD_INT 1
50886: ARRAY
50887: PPUSH
50888: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50892: LD_VAR 0 3
50896: PUSH
50897: LD_EXP 109
50901: PUSH
50902: LD_VAR 0 2
50906: ARRAY
50907: IN
50908: NOT
50909: IFFALSE 50955
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50911: LD_ADDR_EXP 109
50915: PUSH
50916: LD_EXP 109
50920: PPUSH
50921: LD_VAR 0 2
50925: PUSH
50926: LD_EXP 109
50930: PUSH
50931: LD_VAR 0 2
50935: ARRAY
50936: PUSH
50937: LD_INT 1
50939: PLUS
50940: PUSH
50941: EMPTY
50942: LIST
50943: LIST
50944: PPUSH
50945: LD_VAR 0 3
50949: PPUSH
50950: CALL 74553 0 3
50954: ST_TO_ADDR
// break ;
50955: GO 50959
// end ; end ; end ;
50957: GO 50793
50959: POP
50960: POP
// end ;
50961: GO 50553
50963: POP
50964: POP
// end ;
50965: LD_VAR 0 1
50969: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50970: LD_INT 0
50972: PPUSH
50973: PPUSH
50974: PPUSH
50975: PPUSH
50976: PPUSH
50977: PPUSH
50978: PPUSH
50979: PPUSH
50980: PPUSH
// if not mc_bases then
50981: LD_EXP 102
50985: NOT
50986: IFFALSE 50990
// exit ;
50988: GO 51395
// for i = 1 to mc_bases do
50990: LD_ADDR_VAR 0 2
50994: PUSH
50995: DOUBLE
50996: LD_INT 1
50998: DEC
50999: ST_TO_ADDR
51000: LD_EXP 102
51004: PUSH
51005: FOR_TO
51006: IFFALSE 51393
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51008: LD_EXP 110
51012: PUSH
51013: LD_VAR 0 2
51017: ARRAY
51018: NOT
51019: PUSH
51020: LD_EXP 102
51024: PUSH
51025: LD_VAR 0 2
51029: ARRAY
51030: PPUSH
51031: LD_INT 30
51033: PUSH
51034: LD_INT 3
51036: PUSH
51037: EMPTY
51038: LIST
51039: LIST
51040: PPUSH
51041: CALL_OW 72
51045: NOT
51046: OR
51047: IFFALSE 51051
// continue ;
51049: GO 51005
// busy := false ;
51051: LD_ADDR_VAR 0 8
51055: PUSH
51056: LD_INT 0
51058: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51059: LD_ADDR_VAR 0 4
51063: PUSH
51064: LD_EXP 102
51068: PUSH
51069: LD_VAR 0 2
51073: ARRAY
51074: PPUSH
51075: LD_INT 30
51077: PUSH
51078: LD_INT 3
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: PPUSH
51085: CALL_OW 72
51089: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51090: LD_ADDR_VAR 0 6
51094: PUSH
51095: LD_EXP 110
51099: PUSH
51100: LD_VAR 0 2
51104: ARRAY
51105: PPUSH
51106: LD_INT 2
51108: PUSH
51109: LD_INT 30
51111: PUSH
51112: LD_INT 32
51114: PUSH
51115: EMPTY
51116: LIST
51117: LIST
51118: PUSH
51119: LD_INT 30
51121: PUSH
51122: LD_INT 33
51124: PUSH
51125: EMPTY
51126: LIST
51127: LIST
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: LIST
51133: PPUSH
51134: CALL_OW 72
51138: ST_TO_ADDR
// if not t then
51139: LD_VAR 0 6
51143: NOT
51144: IFFALSE 51148
// continue ;
51146: GO 51005
// for j in tmp do
51148: LD_ADDR_VAR 0 3
51152: PUSH
51153: LD_VAR 0 4
51157: PUSH
51158: FOR_IN
51159: IFFALSE 51189
// if not BuildingStatus ( j ) = bs_idle then
51161: LD_VAR 0 3
51165: PPUSH
51166: CALL_OW 461
51170: PUSH
51171: LD_INT 2
51173: EQUAL
51174: NOT
51175: IFFALSE 51187
// begin busy := true ;
51177: LD_ADDR_VAR 0 8
51181: PUSH
51182: LD_INT 1
51184: ST_TO_ADDR
// break ;
51185: GO 51189
// end ;
51187: GO 51158
51189: POP
51190: POP
// if busy then
51191: LD_VAR 0 8
51195: IFFALSE 51199
// continue ;
51197: GO 51005
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51199: LD_ADDR_VAR 0 7
51203: PUSH
51204: LD_VAR 0 6
51208: PPUSH
51209: LD_INT 35
51211: PUSH
51212: LD_INT 0
51214: PUSH
51215: EMPTY
51216: LIST
51217: LIST
51218: PPUSH
51219: CALL_OW 72
51223: ST_TO_ADDR
// if tw then
51224: LD_VAR 0 7
51228: IFFALSE 51305
// begin tw := tw [ 1 ] ;
51230: LD_ADDR_VAR 0 7
51234: PUSH
51235: LD_VAR 0 7
51239: PUSH
51240: LD_INT 1
51242: ARRAY
51243: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51244: LD_ADDR_VAR 0 9
51248: PUSH
51249: LD_VAR 0 7
51253: PPUSH
51254: LD_EXP 127
51258: PUSH
51259: LD_VAR 0 2
51263: ARRAY
51264: PPUSH
51265: CALL 79938 0 2
51269: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51270: LD_EXP 141
51274: PUSH
51275: LD_VAR 0 2
51279: ARRAY
51280: IFFALSE 51303
// if not weapon in mc_allowed_tower_weapons [ i ] then
51282: LD_VAR 0 9
51286: PUSH
51287: LD_EXP 141
51291: PUSH
51292: LD_VAR 0 2
51296: ARRAY
51297: IN
51298: NOT
51299: IFFALSE 51303
// continue ;
51301: GO 51005
// end else
51303: GO 51368
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51305: LD_ADDR_VAR 0 5
51309: PUSH
51310: LD_EXP 110
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PPUSH
51321: LD_VAR 0 4
51325: PPUSH
51326: CALL 106830 0 2
51330: ST_TO_ADDR
// if not tmp2 then
51331: LD_VAR 0 5
51335: NOT
51336: IFFALSE 51340
// continue ;
51338: GO 51005
// tw := tmp2 [ 1 ] ;
51340: LD_ADDR_VAR 0 7
51344: PUSH
51345: LD_VAR 0 5
51349: PUSH
51350: LD_INT 1
51352: ARRAY
51353: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51354: LD_ADDR_VAR 0 9
51358: PUSH
51359: LD_VAR 0 5
51363: PUSH
51364: LD_INT 2
51366: ARRAY
51367: ST_TO_ADDR
// end ; if not weapon then
51368: LD_VAR 0 9
51372: NOT
51373: IFFALSE 51377
// continue ;
51375: GO 51005
// ComPlaceWeapon ( tw , weapon ) ;
51377: LD_VAR 0 7
51381: PPUSH
51382: LD_VAR 0 9
51386: PPUSH
51387: CALL_OW 148
// end ;
51391: GO 51005
51393: POP
51394: POP
// end ;
51395: LD_VAR 0 1
51399: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51400: LD_INT 0
51402: PPUSH
51403: PPUSH
51404: PPUSH
51405: PPUSH
51406: PPUSH
51407: PPUSH
51408: PPUSH
// if not mc_bases then
51409: LD_EXP 102
51413: NOT
51414: IFFALSE 51418
// exit ;
51416: GO 52193
// for i = 1 to mc_bases do
51418: LD_ADDR_VAR 0 2
51422: PUSH
51423: DOUBLE
51424: LD_INT 1
51426: DEC
51427: ST_TO_ADDR
51428: LD_EXP 102
51432: PUSH
51433: FOR_TO
51434: IFFALSE 52191
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51436: LD_EXP 115
51440: PUSH
51441: LD_VAR 0 2
51445: ARRAY
51446: NOT
51447: PUSH
51448: LD_EXP 115
51452: PUSH
51453: LD_VAR 0 2
51457: ARRAY
51458: PUSH
51459: LD_EXP 116
51463: PUSH
51464: LD_VAR 0 2
51468: ARRAY
51469: EQUAL
51470: OR
51471: PUSH
51472: LD_EXP 125
51476: PUSH
51477: LD_VAR 0 2
51481: ARRAY
51482: OR
51483: IFFALSE 51487
// continue ;
51485: GO 51433
// if mc_miners [ i ] then
51487: LD_EXP 116
51491: PUSH
51492: LD_VAR 0 2
51496: ARRAY
51497: IFFALSE 51878
// begin for j = mc_miners [ i ] downto 1 do
51499: LD_ADDR_VAR 0 3
51503: PUSH
51504: DOUBLE
51505: LD_EXP 116
51509: PUSH
51510: LD_VAR 0 2
51514: ARRAY
51515: INC
51516: ST_TO_ADDR
51517: LD_INT 1
51519: PUSH
51520: FOR_DOWNTO
51521: IFFALSE 51876
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51523: LD_EXP 116
51527: PUSH
51528: LD_VAR 0 2
51532: ARRAY
51533: PUSH
51534: LD_VAR 0 3
51538: ARRAY
51539: PPUSH
51540: CALL_OW 301
51544: PUSH
51545: LD_EXP 116
51549: PUSH
51550: LD_VAR 0 2
51554: ARRAY
51555: PUSH
51556: LD_VAR 0 3
51560: ARRAY
51561: PPUSH
51562: CALL_OW 257
51566: PUSH
51567: LD_INT 1
51569: NONEQUAL
51570: OR
51571: IFFALSE 51634
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51573: LD_ADDR_VAR 0 5
51577: PUSH
51578: LD_EXP 116
51582: PUSH
51583: LD_VAR 0 2
51587: ARRAY
51588: PUSH
51589: LD_EXP 116
51593: PUSH
51594: LD_VAR 0 2
51598: ARRAY
51599: PUSH
51600: LD_VAR 0 3
51604: ARRAY
51605: DIFF
51606: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51607: LD_ADDR_EXP 116
51611: PUSH
51612: LD_EXP 116
51616: PPUSH
51617: LD_VAR 0 2
51621: PPUSH
51622: LD_VAR 0 5
51626: PPUSH
51627: CALL_OW 1
51631: ST_TO_ADDR
// continue ;
51632: GO 51520
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51634: LD_EXP 116
51638: PUSH
51639: LD_VAR 0 2
51643: ARRAY
51644: PUSH
51645: LD_VAR 0 3
51649: ARRAY
51650: PPUSH
51651: CALL_OW 257
51655: PUSH
51656: LD_INT 1
51658: EQUAL
51659: PUSH
51660: LD_EXP 116
51664: PUSH
51665: LD_VAR 0 2
51669: ARRAY
51670: PUSH
51671: LD_VAR 0 3
51675: ARRAY
51676: PPUSH
51677: CALL_OW 459
51681: NOT
51682: AND
51683: PUSH
51684: LD_EXP 116
51688: PUSH
51689: LD_VAR 0 2
51693: ARRAY
51694: PUSH
51695: LD_VAR 0 3
51699: ARRAY
51700: PPUSH
51701: CALL_OW 314
51705: NOT
51706: AND
51707: IFFALSE 51874
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51709: LD_EXP 116
51713: PUSH
51714: LD_VAR 0 2
51718: ARRAY
51719: PUSH
51720: LD_VAR 0 3
51724: ARRAY
51725: PPUSH
51726: CALL_OW 310
51730: IFFALSE 51753
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51732: LD_EXP 116
51736: PUSH
51737: LD_VAR 0 2
51741: ARRAY
51742: PUSH
51743: LD_VAR 0 3
51747: ARRAY
51748: PPUSH
51749: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51753: LD_EXP 116
51757: PUSH
51758: LD_VAR 0 2
51762: ARRAY
51763: PUSH
51764: LD_VAR 0 3
51768: ARRAY
51769: PPUSH
51770: CALL_OW 314
51774: NOT
51775: IFFALSE 51874
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51777: LD_ADDR_VAR 0 7
51781: PUSH
51782: LD_VAR 0 3
51786: PUSH
51787: LD_EXP 115
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PPUSH
51798: CALL 71693 0 1
51802: MOD
51803: PUSH
51804: LD_INT 1
51806: PLUS
51807: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51808: LD_EXP 116
51812: PUSH
51813: LD_VAR 0 2
51817: ARRAY
51818: PUSH
51819: LD_VAR 0 3
51823: ARRAY
51824: PPUSH
51825: LD_EXP 115
51829: PUSH
51830: LD_VAR 0 2
51834: ARRAY
51835: PUSH
51836: LD_VAR 0 7
51840: ARRAY
51841: PUSH
51842: LD_INT 1
51844: ARRAY
51845: PPUSH
51846: LD_EXP 115
51850: PUSH
51851: LD_VAR 0 2
51855: ARRAY
51856: PUSH
51857: LD_VAR 0 7
51861: ARRAY
51862: PUSH
51863: LD_INT 2
51865: ARRAY
51866: PPUSH
51867: LD_INT 0
51869: PPUSH
51870: CALL_OW 193
// end ; end ; end ;
51874: GO 51520
51876: POP
51877: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51878: LD_ADDR_VAR 0 5
51882: PUSH
51883: LD_EXP 102
51887: PUSH
51888: LD_VAR 0 2
51892: ARRAY
51893: PPUSH
51894: LD_INT 2
51896: PUSH
51897: LD_INT 30
51899: PUSH
51900: LD_INT 4
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: PUSH
51907: LD_INT 30
51909: PUSH
51910: LD_INT 5
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: PUSH
51917: LD_INT 30
51919: PUSH
51920: LD_INT 32
51922: PUSH
51923: EMPTY
51924: LIST
51925: LIST
51926: PUSH
51927: EMPTY
51928: LIST
51929: LIST
51930: LIST
51931: LIST
51932: PPUSH
51933: CALL_OW 72
51937: ST_TO_ADDR
// if not tmp then
51938: LD_VAR 0 5
51942: NOT
51943: IFFALSE 51947
// continue ;
51945: GO 51433
// list := [ ] ;
51947: LD_ADDR_VAR 0 6
51951: PUSH
51952: EMPTY
51953: ST_TO_ADDR
// for j in tmp do
51954: LD_ADDR_VAR 0 3
51958: PUSH
51959: LD_VAR 0 5
51963: PUSH
51964: FOR_IN
51965: IFFALSE 52034
// begin for k in UnitsInside ( j ) do
51967: LD_ADDR_VAR 0 4
51971: PUSH
51972: LD_VAR 0 3
51976: PPUSH
51977: CALL_OW 313
51981: PUSH
51982: FOR_IN
51983: IFFALSE 52030
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51985: LD_VAR 0 4
51989: PPUSH
51990: CALL_OW 257
51994: PUSH
51995: LD_INT 1
51997: EQUAL
51998: PUSH
51999: LD_VAR 0 4
52003: PPUSH
52004: CALL_OW 459
52008: NOT
52009: AND
52010: IFFALSE 52028
// list := list ^ k ;
52012: LD_ADDR_VAR 0 6
52016: PUSH
52017: LD_VAR 0 6
52021: PUSH
52022: LD_VAR 0 4
52026: ADD
52027: ST_TO_ADDR
52028: GO 51982
52030: POP
52031: POP
// end ;
52032: GO 51964
52034: POP
52035: POP
// list := list diff mc_miners [ i ] ;
52036: LD_ADDR_VAR 0 6
52040: PUSH
52041: LD_VAR 0 6
52045: PUSH
52046: LD_EXP 116
52050: PUSH
52051: LD_VAR 0 2
52055: ARRAY
52056: DIFF
52057: ST_TO_ADDR
// if not list then
52058: LD_VAR 0 6
52062: NOT
52063: IFFALSE 52067
// continue ;
52065: GO 51433
// k := mc_mines [ i ] - mc_miners [ i ] ;
52067: LD_ADDR_VAR 0 4
52071: PUSH
52072: LD_EXP 115
52076: PUSH
52077: LD_VAR 0 2
52081: ARRAY
52082: PUSH
52083: LD_EXP 116
52087: PUSH
52088: LD_VAR 0 2
52092: ARRAY
52093: MINUS
52094: ST_TO_ADDR
// if k > list then
52095: LD_VAR 0 4
52099: PUSH
52100: LD_VAR 0 6
52104: GREATER
52105: IFFALSE 52117
// k := list ;
52107: LD_ADDR_VAR 0 4
52111: PUSH
52112: LD_VAR 0 6
52116: ST_TO_ADDR
// for j = 1 to k do
52117: LD_ADDR_VAR 0 3
52121: PUSH
52122: DOUBLE
52123: LD_INT 1
52125: DEC
52126: ST_TO_ADDR
52127: LD_VAR 0 4
52131: PUSH
52132: FOR_TO
52133: IFFALSE 52187
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52135: LD_ADDR_EXP 116
52139: PUSH
52140: LD_EXP 116
52144: PPUSH
52145: LD_VAR 0 2
52149: PUSH
52150: LD_EXP 116
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: PUSH
52161: LD_INT 1
52163: PLUS
52164: PUSH
52165: EMPTY
52166: LIST
52167: LIST
52168: PPUSH
52169: LD_VAR 0 6
52173: PUSH
52174: LD_VAR 0 3
52178: ARRAY
52179: PPUSH
52180: CALL 74553 0 3
52184: ST_TO_ADDR
52185: GO 52132
52187: POP
52188: POP
// end ;
52189: GO 51433
52191: POP
52192: POP
// end ;
52193: LD_VAR 0 1
52197: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52198: LD_INT 0
52200: PPUSH
52201: PPUSH
52202: PPUSH
52203: PPUSH
52204: PPUSH
52205: PPUSH
52206: PPUSH
52207: PPUSH
52208: PPUSH
52209: PPUSH
52210: PPUSH
// if not mc_bases then
52211: LD_EXP 102
52215: NOT
52216: IFFALSE 52220
// exit ;
52218: GO 54043
// for i = 1 to mc_bases do
52220: LD_ADDR_VAR 0 2
52224: PUSH
52225: DOUBLE
52226: LD_INT 1
52228: DEC
52229: ST_TO_ADDR
52230: LD_EXP 102
52234: PUSH
52235: FOR_TO
52236: IFFALSE 54041
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52238: LD_EXP 102
52242: PUSH
52243: LD_VAR 0 2
52247: ARRAY
52248: NOT
52249: PUSH
52250: LD_EXP 109
52254: PUSH
52255: LD_VAR 0 2
52259: ARRAY
52260: OR
52261: IFFALSE 52265
// continue ;
52263: GO 52235
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52265: LD_EXP 118
52269: PUSH
52270: LD_VAR 0 2
52274: ARRAY
52275: NOT
52276: PUSH
52277: LD_EXP 119
52281: PUSH
52282: LD_VAR 0 2
52286: ARRAY
52287: AND
52288: IFFALSE 52326
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52290: LD_ADDR_EXP 119
52294: PUSH
52295: LD_EXP 119
52299: PPUSH
52300: LD_VAR 0 2
52304: PPUSH
52305: EMPTY
52306: PPUSH
52307: CALL_OW 1
52311: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52312: LD_VAR 0 2
52316: PPUSH
52317: LD_INT 107
52319: PPUSH
52320: CALL 43052 0 2
// continue ;
52324: GO 52235
// end ; target := [ ] ;
52326: LD_ADDR_VAR 0 7
52330: PUSH
52331: EMPTY
52332: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52333: LD_ADDR_VAR 0 6
52337: PUSH
52338: LD_EXP 102
52342: PUSH
52343: LD_VAR 0 2
52347: ARRAY
52348: PUSH
52349: LD_INT 1
52351: ARRAY
52352: PPUSH
52353: CALL_OW 255
52357: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52358: LD_ADDR_VAR 0 9
52362: PUSH
52363: LD_EXP 102
52367: PUSH
52368: LD_VAR 0 2
52372: ARRAY
52373: PPUSH
52374: LD_INT 2
52376: PUSH
52377: LD_INT 30
52379: PUSH
52380: LD_INT 0
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: PUSH
52387: LD_INT 30
52389: PUSH
52390: LD_INT 1
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: LIST
52401: PPUSH
52402: CALL_OW 72
52406: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52407: LD_ADDR_VAR 0 3
52411: PUSH
52412: DOUBLE
52413: LD_EXP 118
52417: PUSH
52418: LD_VAR 0 2
52422: ARRAY
52423: INC
52424: ST_TO_ADDR
52425: LD_INT 1
52427: PUSH
52428: FOR_DOWNTO
52429: IFFALSE 52674
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52431: LD_EXP 118
52435: PUSH
52436: LD_VAR 0 2
52440: ARRAY
52441: PUSH
52442: LD_VAR 0 3
52446: ARRAY
52447: PUSH
52448: LD_INT 2
52450: ARRAY
52451: PPUSH
52452: LD_EXP 118
52456: PUSH
52457: LD_VAR 0 2
52461: ARRAY
52462: PUSH
52463: LD_VAR 0 3
52467: ARRAY
52468: PUSH
52469: LD_INT 3
52471: ARRAY
52472: PPUSH
52473: CALL_OW 488
52477: PUSH
52478: LD_EXP 118
52482: PUSH
52483: LD_VAR 0 2
52487: ARRAY
52488: PUSH
52489: LD_VAR 0 3
52493: ARRAY
52494: PUSH
52495: LD_INT 2
52497: ARRAY
52498: PPUSH
52499: LD_EXP 118
52503: PUSH
52504: LD_VAR 0 2
52508: ARRAY
52509: PUSH
52510: LD_VAR 0 3
52514: ARRAY
52515: PUSH
52516: LD_INT 3
52518: ARRAY
52519: PPUSH
52520: CALL_OW 284
52524: PUSH
52525: LD_INT 0
52527: EQUAL
52528: AND
52529: IFFALSE 52584
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52531: LD_ADDR_VAR 0 5
52535: PUSH
52536: LD_EXP 118
52540: PUSH
52541: LD_VAR 0 2
52545: ARRAY
52546: PPUSH
52547: LD_VAR 0 3
52551: PPUSH
52552: CALL_OW 3
52556: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52557: LD_ADDR_EXP 118
52561: PUSH
52562: LD_EXP 118
52566: PPUSH
52567: LD_VAR 0 2
52571: PPUSH
52572: LD_VAR 0 5
52576: PPUSH
52577: CALL_OW 1
52581: ST_TO_ADDR
// continue ;
52582: GO 52428
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52584: LD_VAR 0 6
52588: PPUSH
52589: LD_EXP 118
52593: PUSH
52594: LD_VAR 0 2
52598: ARRAY
52599: PUSH
52600: LD_VAR 0 3
52604: ARRAY
52605: PUSH
52606: LD_INT 2
52608: ARRAY
52609: PPUSH
52610: LD_EXP 118
52614: PUSH
52615: LD_VAR 0 2
52619: ARRAY
52620: PUSH
52621: LD_VAR 0 3
52625: ARRAY
52626: PUSH
52627: LD_INT 3
52629: ARRAY
52630: PPUSH
52631: LD_INT 30
52633: PPUSH
52634: CALL 75817 0 4
52638: PUSH
52639: LD_INT 4
52641: ARRAY
52642: PUSH
52643: LD_INT 0
52645: EQUAL
52646: IFFALSE 52672
// begin target := mc_crates [ i ] [ j ] ;
52648: LD_ADDR_VAR 0 7
52652: PUSH
52653: LD_EXP 118
52657: PUSH
52658: LD_VAR 0 2
52662: ARRAY
52663: PUSH
52664: LD_VAR 0 3
52668: ARRAY
52669: ST_TO_ADDR
// break ;
52670: GO 52674
// end ; end ;
52672: GO 52428
52674: POP
52675: POP
// if not target then
52676: LD_VAR 0 7
52680: NOT
52681: IFFALSE 52685
// continue ;
52683: GO 52235
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52685: LD_ADDR_VAR 0 8
52689: PUSH
52690: LD_EXP 121
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PPUSH
52701: LD_INT 2
52703: PUSH
52704: LD_INT 3
52706: PUSH
52707: LD_INT 58
52709: PUSH
52710: EMPTY
52711: LIST
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: PUSH
52717: LD_INT 61
52719: PUSH
52720: EMPTY
52721: LIST
52722: PUSH
52723: LD_INT 33
52725: PUSH
52726: LD_INT 5
52728: PUSH
52729: EMPTY
52730: LIST
52731: LIST
52732: PUSH
52733: LD_INT 33
52735: PUSH
52736: LD_INT 3
52738: PUSH
52739: EMPTY
52740: LIST
52741: LIST
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: LIST
52747: LIST
52748: LIST
52749: PUSH
52750: LD_INT 2
52752: PUSH
52753: LD_INT 34
52755: PUSH
52756: LD_INT 32
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: PUSH
52763: LD_INT 34
52765: PUSH
52766: LD_INT 51
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: PUSH
52773: LD_INT 34
52775: PUSH
52776: LD_INT 12
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: PPUSH
52793: CALL_OW 72
52797: ST_TO_ADDR
// if not cargo then
52798: LD_VAR 0 8
52802: NOT
52803: IFFALSE 53509
// begin if mc_crates_collector [ i ] < 5 then
52805: LD_EXP 119
52809: PUSH
52810: LD_VAR 0 2
52814: ARRAY
52815: PUSH
52816: LD_INT 5
52818: LESS
52819: IFFALSE 53185
// begin if mc_ape [ i ] then
52821: LD_EXP 131
52825: PUSH
52826: LD_VAR 0 2
52830: ARRAY
52831: IFFALSE 52878
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52833: LD_ADDR_VAR 0 5
52837: PUSH
52838: LD_EXP 131
52842: PUSH
52843: LD_VAR 0 2
52847: ARRAY
52848: PPUSH
52849: LD_INT 25
52851: PUSH
52852: LD_INT 16
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: PUSH
52859: LD_INT 24
52861: PUSH
52862: LD_INT 750
52864: PUSH
52865: EMPTY
52866: LIST
52867: LIST
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: PPUSH
52873: CALL_OW 72
52877: ST_TO_ADDR
// if not tmp then
52878: LD_VAR 0 5
52882: NOT
52883: IFFALSE 52930
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52885: LD_ADDR_VAR 0 5
52889: PUSH
52890: LD_EXP 102
52894: PUSH
52895: LD_VAR 0 2
52899: ARRAY
52900: PPUSH
52901: LD_INT 25
52903: PUSH
52904: LD_INT 2
52906: PUSH
52907: EMPTY
52908: LIST
52909: LIST
52910: PUSH
52911: LD_INT 24
52913: PUSH
52914: LD_INT 750
52916: PUSH
52917: EMPTY
52918: LIST
52919: LIST
52920: PUSH
52921: EMPTY
52922: LIST
52923: LIST
52924: PPUSH
52925: CALL_OW 72
52929: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52930: LD_EXP 131
52934: PUSH
52935: LD_VAR 0 2
52939: ARRAY
52940: PUSH
52941: LD_EXP 102
52945: PUSH
52946: LD_VAR 0 2
52950: ARRAY
52951: PPUSH
52952: LD_INT 25
52954: PUSH
52955: LD_INT 2
52957: PUSH
52958: EMPTY
52959: LIST
52960: LIST
52961: PUSH
52962: LD_INT 24
52964: PUSH
52965: LD_INT 750
52967: PUSH
52968: EMPTY
52969: LIST
52970: LIST
52971: PUSH
52972: EMPTY
52973: LIST
52974: LIST
52975: PPUSH
52976: CALL_OW 72
52980: AND
52981: PUSH
52982: LD_VAR 0 5
52986: PUSH
52987: LD_INT 5
52989: LESS
52990: AND
52991: IFFALSE 53073
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52993: LD_ADDR_VAR 0 3
52997: PUSH
52998: LD_EXP 102
53002: PUSH
53003: LD_VAR 0 2
53007: ARRAY
53008: PPUSH
53009: LD_INT 25
53011: PUSH
53012: LD_INT 2
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: PUSH
53019: LD_INT 24
53021: PUSH
53022: LD_INT 750
53024: PUSH
53025: EMPTY
53026: LIST
53027: LIST
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: PPUSH
53033: CALL_OW 72
53037: PUSH
53038: FOR_IN
53039: IFFALSE 53071
// begin tmp := tmp union j ;
53041: LD_ADDR_VAR 0 5
53045: PUSH
53046: LD_VAR 0 5
53050: PUSH
53051: LD_VAR 0 3
53055: UNION
53056: ST_TO_ADDR
// if tmp >= 5 then
53057: LD_VAR 0 5
53061: PUSH
53062: LD_INT 5
53064: GREATEREQUAL
53065: IFFALSE 53069
// break ;
53067: GO 53071
// end ;
53069: GO 53038
53071: POP
53072: POP
// end ; if not tmp then
53073: LD_VAR 0 5
53077: NOT
53078: IFFALSE 53082
// continue ;
53080: GO 52235
// for j in tmp do
53082: LD_ADDR_VAR 0 3
53086: PUSH
53087: LD_VAR 0 5
53091: PUSH
53092: FOR_IN
53093: IFFALSE 53183
// if not GetTag ( j ) then
53095: LD_VAR 0 3
53099: PPUSH
53100: CALL_OW 110
53104: NOT
53105: IFFALSE 53181
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53107: LD_ADDR_EXP 119
53111: PUSH
53112: LD_EXP 119
53116: PPUSH
53117: LD_VAR 0 2
53121: PUSH
53122: LD_EXP 119
53126: PUSH
53127: LD_VAR 0 2
53131: ARRAY
53132: PUSH
53133: LD_INT 1
53135: PLUS
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PPUSH
53141: LD_VAR 0 3
53145: PPUSH
53146: CALL 74553 0 3
53150: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53151: LD_VAR 0 3
53155: PPUSH
53156: LD_INT 107
53158: PPUSH
53159: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53163: LD_EXP 119
53167: PUSH
53168: LD_VAR 0 2
53172: ARRAY
53173: PUSH
53174: LD_INT 5
53176: GREATEREQUAL
53177: IFFALSE 53181
// break ;
53179: GO 53183
// end ;
53181: GO 53092
53183: POP
53184: POP
// end ; if mc_crates_collector [ i ] and target then
53185: LD_EXP 119
53189: PUSH
53190: LD_VAR 0 2
53194: ARRAY
53195: PUSH
53196: LD_VAR 0 7
53200: AND
53201: IFFALSE 53507
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53203: LD_EXP 119
53207: PUSH
53208: LD_VAR 0 2
53212: ARRAY
53213: PUSH
53214: LD_VAR 0 7
53218: PUSH
53219: LD_INT 1
53221: ARRAY
53222: LESS
53223: IFFALSE 53243
// tmp := mc_crates_collector [ i ] else
53225: LD_ADDR_VAR 0 5
53229: PUSH
53230: LD_EXP 119
53234: PUSH
53235: LD_VAR 0 2
53239: ARRAY
53240: ST_TO_ADDR
53241: GO 53257
// tmp := target [ 1 ] ;
53243: LD_ADDR_VAR 0 5
53247: PUSH
53248: LD_VAR 0 7
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: ST_TO_ADDR
// k := 0 ;
53257: LD_ADDR_VAR 0 4
53261: PUSH
53262: LD_INT 0
53264: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53265: LD_ADDR_VAR 0 3
53269: PUSH
53270: LD_EXP 119
53274: PUSH
53275: LD_VAR 0 2
53279: ARRAY
53280: PUSH
53281: FOR_IN
53282: IFFALSE 53505
// begin k := k + 1 ;
53284: LD_ADDR_VAR 0 4
53288: PUSH
53289: LD_VAR 0 4
53293: PUSH
53294: LD_INT 1
53296: PLUS
53297: ST_TO_ADDR
// if k > tmp then
53298: LD_VAR 0 4
53302: PUSH
53303: LD_VAR 0 5
53307: GREATER
53308: IFFALSE 53312
// break ;
53310: GO 53505
// if not GetClass ( j ) in [ 2 , 16 ] then
53312: LD_VAR 0 3
53316: PPUSH
53317: CALL_OW 257
53321: PUSH
53322: LD_INT 2
53324: PUSH
53325: LD_INT 16
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: IN
53332: NOT
53333: IFFALSE 53386
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53335: LD_ADDR_EXP 119
53339: PUSH
53340: LD_EXP 119
53344: PPUSH
53345: LD_VAR 0 2
53349: PPUSH
53350: LD_EXP 119
53354: PUSH
53355: LD_VAR 0 2
53359: ARRAY
53360: PUSH
53361: LD_VAR 0 3
53365: DIFF
53366: PPUSH
53367: CALL_OW 1
53371: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53372: LD_VAR 0 3
53376: PPUSH
53377: LD_INT 0
53379: PPUSH
53380: CALL_OW 109
// continue ;
53384: GO 53281
// end ; if IsInUnit ( j ) then
53386: LD_VAR 0 3
53390: PPUSH
53391: CALL_OW 310
53395: IFFALSE 53406
// ComExitBuilding ( j ) ;
53397: LD_VAR 0 3
53401: PPUSH
53402: CALL_OW 122
// wait ( 3 ) ;
53406: LD_INT 3
53408: PPUSH
53409: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53413: LD_VAR 0 3
53417: PPUSH
53418: CALL_OW 314
53422: PUSH
53423: LD_VAR 0 6
53427: PPUSH
53428: LD_VAR 0 7
53432: PUSH
53433: LD_INT 2
53435: ARRAY
53436: PPUSH
53437: LD_VAR 0 7
53441: PUSH
53442: LD_INT 3
53444: ARRAY
53445: PPUSH
53446: LD_INT 30
53448: PPUSH
53449: CALL 75817 0 4
53453: PUSH
53454: LD_INT 4
53456: ARRAY
53457: AND
53458: IFFALSE 53476
// ComStandNearbyBuilding ( j , depot ) else
53460: LD_VAR 0 3
53464: PPUSH
53465: LD_VAR 0 9
53469: PPUSH
53470: CALL 71155 0 2
53474: GO 53503
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53476: LD_VAR 0 3
53480: PPUSH
53481: LD_VAR 0 7
53485: PUSH
53486: LD_INT 2
53488: ARRAY
53489: PPUSH
53490: LD_VAR 0 7
53494: PUSH
53495: LD_INT 3
53497: ARRAY
53498: PPUSH
53499: CALL_OW 117
// end ;
53503: GO 53281
53505: POP
53506: POP
// end ; end else
53507: GO 54039
// begin for j in cargo do
53509: LD_ADDR_VAR 0 3
53513: PUSH
53514: LD_VAR 0 8
53518: PUSH
53519: FOR_IN
53520: IFFALSE 54037
// begin if GetTag ( j ) <> 0 then
53522: LD_VAR 0 3
53526: PPUSH
53527: CALL_OW 110
53531: PUSH
53532: LD_INT 0
53534: NONEQUAL
53535: IFFALSE 53539
// continue ;
53537: GO 53519
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53539: LD_VAR 0 3
53543: PPUSH
53544: CALL_OW 256
53548: PUSH
53549: LD_INT 1000
53551: LESS
53552: PUSH
53553: LD_VAR 0 3
53557: PPUSH
53558: LD_EXP 126
53562: PUSH
53563: LD_VAR 0 2
53567: ARRAY
53568: PPUSH
53569: CALL_OW 308
53573: NOT
53574: AND
53575: IFFALSE 53597
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53577: LD_VAR 0 3
53581: PPUSH
53582: LD_EXP 126
53586: PUSH
53587: LD_VAR 0 2
53591: ARRAY
53592: PPUSH
53593: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53597: LD_VAR 0 3
53601: PPUSH
53602: CALL_OW 256
53606: PUSH
53607: LD_INT 1000
53609: LESS
53610: PUSH
53611: LD_VAR 0 3
53615: PPUSH
53616: LD_EXP 126
53620: PUSH
53621: LD_VAR 0 2
53625: ARRAY
53626: PPUSH
53627: CALL_OW 308
53631: AND
53632: IFFALSE 53636
// continue ;
53634: GO 53519
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53636: LD_VAR 0 3
53640: PPUSH
53641: CALL_OW 262
53645: PUSH
53646: LD_INT 2
53648: EQUAL
53649: PUSH
53650: LD_VAR 0 3
53654: PPUSH
53655: CALL_OW 261
53659: PUSH
53660: LD_INT 15
53662: LESS
53663: AND
53664: IFFALSE 53668
// continue ;
53666: GO 53519
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53668: LD_VAR 0 3
53672: PPUSH
53673: CALL_OW 262
53677: PUSH
53678: LD_INT 1
53680: EQUAL
53681: PUSH
53682: LD_VAR 0 3
53686: PPUSH
53687: CALL_OW 261
53691: PUSH
53692: LD_INT 10
53694: LESS
53695: AND
53696: IFFALSE 53976
// begin if not depot then
53698: LD_VAR 0 9
53702: NOT
53703: IFFALSE 53707
// continue ;
53705: GO 53519
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53707: LD_VAR 0 3
53711: PPUSH
53712: LD_VAR 0 9
53716: PPUSH
53717: LD_VAR 0 3
53721: PPUSH
53722: CALL_OW 74
53726: PPUSH
53727: CALL_OW 296
53731: PUSH
53732: LD_INT 6
53734: LESS
53735: IFFALSE 53751
// SetFuel ( j , 100 ) else
53737: LD_VAR 0 3
53741: PPUSH
53742: LD_INT 100
53744: PPUSH
53745: CALL_OW 240
53749: GO 53976
// if GetFuel ( j ) = 0 then
53751: LD_VAR 0 3
53755: PPUSH
53756: CALL_OW 261
53760: PUSH
53761: LD_INT 0
53763: EQUAL
53764: IFFALSE 53976
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53766: LD_ADDR_EXP 121
53770: PUSH
53771: LD_EXP 121
53775: PPUSH
53776: LD_VAR 0 2
53780: PPUSH
53781: LD_EXP 121
53785: PUSH
53786: LD_VAR 0 2
53790: ARRAY
53791: PUSH
53792: LD_VAR 0 3
53796: DIFF
53797: PPUSH
53798: CALL_OW 1
53802: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53803: LD_VAR 0 3
53807: PPUSH
53808: CALL_OW 263
53812: PUSH
53813: LD_INT 1
53815: EQUAL
53816: IFFALSE 53832
// ComExitVehicle ( IsInUnit ( j ) ) ;
53818: LD_VAR 0 3
53822: PPUSH
53823: CALL_OW 310
53827: PPUSH
53828: CALL_OW 121
// if GetControl ( j ) = control_remote then
53832: LD_VAR 0 3
53836: PPUSH
53837: CALL_OW 263
53841: PUSH
53842: LD_INT 2
53844: EQUAL
53845: IFFALSE 53856
// ComUnlink ( j ) ;
53847: LD_VAR 0 3
53851: PPUSH
53852: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53856: LD_ADDR_VAR 0 10
53860: PUSH
53861: LD_VAR 0 2
53865: PPUSH
53866: LD_INT 3
53868: PPUSH
53869: CALL 63620 0 2
53873: ST_TO_ADDR
// if fac then
53874: LD_VAR 0 10
53878: IFFALSE 53974
// begin for k in fac do
53880: LD_ADDR_VAR 0 4
53884: PUSH
53885: LD_VAR 0 10
53889: PUSH
53890: FOR_IN
53891: IFFALSE 53972
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53893: LD_ADDR_VAR 0 11
53897: PUSH
53898: LD_VAR 0 10
53902: PPUSH
53903: LD_VAR 0 3
53907: PPUSH
53908: CALL_OW 265
53912: PPUSH
53913: LD_VAR 0 3
53917: PPUSH
53918: CALL_OW 262
53922: PPUSH
53923: LD_VAR 0 3
53927: PPUSH
53928: CALL_OW 263
53932: PPUSH
53933: LD_VAR 0 3
53937: PPUSH
53938: CALL_OW 264
53942: PPUSH
53943: CALL 72051 0 5
53947: ST_TO_ADDR
// if components then
53948: LD_VAR 0 11
53952: IFFALSE 53970
// begin MC_InsertProduceList ( i , components ) ;
53954: LD_VAR 0 2
53958: PPUSH
53959: LD_VAR 0 11
53963: PPUSH
53964: CALL 63165 0 2
// break ;
53968: GO 53972
// end ; end ;
53970: GO 53890
53972: POP
53973: POP
// end ; continue ;
53974: GO 53519
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53976: LD_VAR 0 3
53980: PPUSH
53981: LD_INT 1
53983: PPUSH
53984: CALL_OW 289
53988: PUSH
53989: LD_INT 100
53991: LESS
53992: PUSH
53993: LD_VAR 0 3
53997: PPUSH
53998: CALL_OW 314
54002: NOT
54003: AND
54004: IFFALSE 54033
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54006: LD_VAR 0 3
54010: PPUSH
54011: LD_VAR 0 7
54015: PUSH
54016: LD_INT 2
54018: ARRAY
54019: PPUSH
54020: LD_VAR 0 7
54024: PUSH
54025: LD_INT 3
54027: ARRAY
54028: PPUSH
54029: CALL_OW 117
// break ;
54033: GO 54037
// end ;
54035: GO 53519
54037: POP
54038: POP
// end ; end ;
54039: GO 52235
54041: POP
54042: POP
// end ;
54043: LD_VAR 0 1
54047: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54048: LD_INT 0
54050: PPUSH
54051: PPUSH
54052: PPUSH
54053: PPUSH
// if not mc_bases then
54054: LD_EXP 102
54058: NOT
54059: IFFALSE 54063
// exit ;
54061: GO 54224
// for i = 1 to mc_bases do
54063: LD_ADDR_VAR 0 2
54067: PUSH
54068: DOUBLE
54069: LD_INT 1
54071: DEC
54072: ST_TO_ADDR
54073: LD_EXP 102
54077: PUSH
54078: FOR_TO
54079: IFFALSE 54222
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54081: LD_ADDR_VAR 0 4
54085: PUSH
54086: LD_EXP 121
54090: PUSH
54091: LD_VAR 0 2
54095: ARRAY
54096: PUSH
54097: LD_EXP 124
54101: PUSH
54102: LD_VAR 0 2
54106: ARRAY
54107: UNION
54108: PPUSH
54109: LD_INT 33
54111: PUSH
54112: LD_INT 2
54114: PUSH
54115: EMPTY
54116: LIST
54117: LIST
54118: PPUSH
54119: CALL_OW 72
54123: ST_TO_ADDR
// if tmp then
54124: LD_VAR 0 4
54128: IFFALSE 54220
// for j in tmp do
54130: LD_ADDR_VAR 0 3
54134: PUSH
54135: LD_VAR 0 4
54139: PUSH
54140: FOR_IN
54141: IFFALSE 54218
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54143: LD_VAR 0 3
54147: PPUSH
54148: CALL_OW 312
54152: NOT
54153: PUSH
54154: LD_VAR 0 3
54158: PPUSH
54159: CALL_OW 256
54163: PUSH
54164: LD_INT 250
54166: GREATEREQUAL
54167: AND
54168: IFFALSE 54181
// Connect ( j ) else
54170: LD_VAR 0 3
54174: PPUSH
54175: CALL 77899 0 1
54179: GO 54216
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54181: LD_VAR 0 3
54185: PPUSH
54186: CALL_OW 256
54190: PUSH
54191: LD_INT 250
54193: LESS
54194: PUSH
54195: LD_VAR 0 3
54199: PPUSH
54200: CALL_OW 312
54204: AND
54205: IFFALSE 54216
// ComUnlink ( j ) ;
54207: LD_VAR 0 3
54211: PPUSH
54212: CALL_OW 136
54216: GO 54140
54218: POP
54219: POP
// end ;
54220: GO 54078
54222: POP
54223: POP
// end ;
54224: LD_VAR 0 1
54228: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54229: LD_INT 0
54231: PPUSH
54232: PPUSH
54233: PPUSH
54234: PPUSH
54235: PPUSH
// if not mc_bases then
54236: LD_EXP 102
54240: NOT
54241: IFFALSE 54245
// exit ;
54243: GO 54690
// for i = 1 to mc_bases do
54245: LD_ADDR_VAR 0 2
54249: PUSH
54250: DOUBLE
54251: LD_INT 1
54253: DEC
54254: ST_TO_ADDR
54255: LD_EXP 102
54259: PUSH
54260: FOR_TO
54261: IFFALSE 54688
// begin if not mc_produce [ i ] then
54263: LD_EXP 123
54267: PUSH
54268: LD_VAR 0 2
54272: ARRAY
54273: NOT
54274: IFFALSE 54278
// continue ;
54276: GO 54260
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54278: LD_ADDR_VAR 0 5
54282: PUSH
54283: LD_EXP 102
54287: PUSH
54288: LD_VAR 0 2
54292: ARRAY
54293: PPUSH
54294: LD_INT 30
54296: PUSH
54297: LD_INT 3
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: PPUSH
54304: CALL_OW 72
54308: ST_TO_ADDR
// if not fac then
54309: LD_VAR 0 5
54313: NOT
54314: IFFALSE 54318
// continue ;
54316: GO 54260
// for j in fac do
54318: LD_ADDR_VAR 0 3
54322: PUSH
54323: LD_VAR 0 5
54327: PUSH
54328: FOR_IN
54329: IFFALSE 54684
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54331: LD_VAR 0 3
54335: PPUSH
54336: CALL_OW 461
54340: PUSH
54341: LD_INT 2
54343: NONEQUAL
54344: PUSH
54345: LD_VAR 0 3
54349: PPUSH
54350: LD_INT 15
54352: PPUSH
54353: CALL 77518 0 2
54357: PUSH
54358: LD_INT 4
54360: ARRAY
54361: OR
54362: IFFALSE 54366
// continue ;
54364: GO 54328
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54366: LD_VAR 0 3
54370: PPUSH
54371: LD_EXP 123
54375: PUSH
54376: LD_VAR 0 2
54380: ARRAY
54381: PUSH
54382: LD_INT 1
54384: ARRAY
54385: PUSH
54386: LD_INT 1
54388: ARRAY
54389: PPUSH
54390: LD_EXP 123
54394: PUSH
54395: LD_VAR 0 2
54399: ARRAY
54400: PUSH
54401: LD_INT 1
54403: ARRAY
54404: PUSH
54405: LD_INT 2
54407: ARRAY
54408: PPUSH
54409: LD_EXP 123
54413: PUSH
54414: LD_VAR 0 2
54418: ARRAY
54419: PUSH
54420: LD_INT 1
54422: ARRAY
54423: PUSH
54424: LD_INT 3
54426: ARRAY
54427: PPUSH
54428: LD_EXP 123
54432: PUSH
54433: LD_VAR 0 2
54437: ARRAY
54438: PUSH
54439: LD_INT 1
54441: ARRAY
54442: PUSH
54443: LD_INT 4
54445: ARRAY
54446: PPUSH
54447: CALL_OW 448
54451: PUSH
54452: LD_VAR 0 3
54456: PPUSH
54457: LD_EXP 123
54461: PUSH
54462: LD_VAR 0 2
54466: ARRAY
54467: PUSH
54468: LD_INT 1
54470: ARRAY
54471: PUSH
54472: LD_INT 1
54474: ARRAY
54475: PUSH
54476: LD_EXP 123
54480: PUSH
54481: LD_VAR 0 2
54485: ARRAY
54486: PUSH
54487: LD_INT 1
54489: ARRAY
54490: PUSH
54491: LD_INT 2
54493: ARRAY
54494: PUSH
54495: LD_EXP 123
54499: PUSH
54500: LD_VAR 0 2
54504: ARRAY
54505: PUSH
54506: LD_INT 1
54508: ARRAY
54509: PUSH
54510: LD_INT 3
54512: ARRAY
54513: PUSH
54514: LD_EXP 123
54518: PUSH
54519: LD_VAR 0 2
54523: ARRAY
54524: PUSH
54525: LD_INT 1
54527: ARRAY
54528: PUSH
54529: LD_INT 4
54531: ARRAY
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: LIST
54538: PPUSH
54539: CALL 81294 0 2
54543: AND
54544: IFFALSE 54682
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54546: LD_VAR 0 3
54550: PPUSH
54551: LD_EXP 123
54555: PUSH
54556: LD_VAR 0 2
54560: ARRAY
54561: PUSH
54562: LD_INT 1
54564: ARRAY
54565: PUSH
54566: LD_INT 1
54568: ARRAY
54569: PPUSH
54570: LD_EXP 123
54574: PUSH
54575: LD_VAR 0 2
54579: ARRAY
54580: PUSH
54581: LD_INT 1
54583: ARRAY
54584: PUSH
54585: LD_INT 2
54587: ARRAY
54588: PPUSH
54589: LD_EXP 123
54593: PUSH
54594: LD_VAR 0 2
54598: ARRAY
54599: PUSH
54600: LD_INT 1
54602: ARRAY
54603: PUSH
54604: LD_INT 3
54606: ARRAY
54607: PPUSH
54608: LD_EXP 123
54612: PUSH
54613: LD_VAR 0 2
54617: ARRAY
54618: PUSH
54619: LD_INT 1
54621: ARRAY
54622: PUSH
54623: LD_INT 4
54625: ARRAY
54626: PPUSH
54627: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54631: LD_ADDR_VAR 0 4
54635: PUSH
54636: LD_EXP 123
54640: PUSH
54641: LD_VAR 0 2
54645: ARRAY
54646: PPUSH
54647: LD_INT 1
54649: PPUSH
54650: CALL_OW 3
54654: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54655: LD_ADDR_EXP 123
54659: PUSH
54660: LD_EXP 123
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_VAR 0 4
54674: PPUSH
54675: CALL_OW 1
54679: ST_TO_ADDR
// break ;
54680: GO 54684
// end ; end ;
54682: GO 54328
54684: POP
54685: POP
// end ;
54686: GO 54260
54688: POP
54689: POP
// end ;
54690: LD_VAR 0 1
54694: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54695: LD_INT 0
54697: PPUSH
54698: PPUSH
54699: PPUSH
// if not mc_bases then
54700: LD_EXP 102
54704: NOT
54705: IFFALSE 54709
// exit ;
54707: GO 54798
// for i = 1 to mc_bases do
54709: LD_ADDR_VAR 0 2
54713: PUSH
54714: DOUBLE
54715: LD_INT 1
54717: DEC
54718: ST_TO_ADDR
54719: LD_EXP 102
54723: PUSH
54724: FOR_TO
54725: IFFALSE 54796
// begin if mc_attack [ i ] then
54727: LD_EXP 122
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: IFFALSE 54794
// begin tmp := mc_attack [ i ] [ 1 ] ;
54739: LD_ADDR_VAR 0 3
54743: PUSH
54744: LD_EXP 122
54748: PUSH
54749: LD_VAR 0 2
54753: ARRAY
54754: PUSH
54755: LD_INT 1
54757: ARRAY
54758: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54759: LD_ADDR_EXP 122
54763: PUSH
54764: LD_EXP 122
54768: PPUSH
54769: LD_VAR 0 2
54773: PPUSH
54774: EMPTY
54775: PPUSH
54776: CALL_OW 1
54780: ST_TO_ADDR
// Attack ( tmp ) ;
54781: LD_VAR 0 3
54785: PPUSH
54786: CALL 133075 0 1
// exit ;
54790: POP
54791: POP
54792: GO 54798
// end ; end ;
54794: GO 54724
54796: POP
54797: POP
// end ;
54798: LD_VAR 0 1
54802: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54803: LD_INT 0
54805: PPUSH
54806: PPUSH
54807: PPUSH
54808: PPUSH
54809: PPUSH
54810: PPUSH
54811: PPUSH
// if not mc_bases then
54812: LD_EXP 102
54816: NOT
54817: IFFALSE 54821
// exit ;
54819: GO 55678
// for i = 1 to mc_bases do
54821: LD_ADDR_VAR 0 2
54825: PUSH
54826: DOUBLE
54827: LD_INT 1
54829: DEC
54830: ST_TO_ADDR
54831: LD_EXP 102
54835: PUSH
54836: FOR_TO
54837: IFFALSE 55676
// begin if not mc_bases [ i ] then
54839: LD_EXP 102
54843: PUSH
54844: LD_VAR 0 2
54848: ARRAY
54849: NOT
54850: IFFALSE 54854
// continue ;
54852: GO 54836
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54854: LD_ADDR_VAR 0 7
54858: PUSH
54859: LD_EXP 102
54863: PUSH
54864: LD_VAR 0 2
54868: ARRAY
54869: PUSH
54870: LD_INT 1
54872: ARRAY
54873: PPUSH
54874: CALL 71377 0 1
54878: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54879: LD_ADDR_EXP 125
54883: PUSH
54884: LD_EXP 125
54888: PPUSH
54889: LD_VAR 0 2
54893: PPUSH
54894: LD_EXP 102
54898: PUSH
54899: LD_VAR 0 2
54903: ARRAY
54904: PUSH
54905: LD_INT 1
54907: ARRAY
54908: PPUSH
54909: CALL_OW 255
54913: PPUSH
54914: LD_EXP 127
54918: PUSH
54919: LD_VAR 0 2
54923: ARRAY
54924: PPUSH
54925: CALL 71342 0 2
54929: PPUSH
54930: CALL_OW 1
54934: ST_TO_ADDR
// if not mc_scan [ i ] then
54935: LD_EXP 125
54939: PUSH
54940: LD_VAR 0 2
54944: ARRAY
54945: NOT
54946: IFFALSE 55124
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54948: LD_ADDR_EXP 145
54952: PUSH
54953: LD_EXP 145
54957: PPUSH
54958: LD_VAR 0 2
54962: PPUSH
54963: LD_INT 0
54965: PPUSH
54966: CALL_OW 1
54970: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54971: LD_ADDR_VAR 0 4
54975: PUSH
54976: LD_EXP 102
54980: PUSH
54981: LD_VAR 0 2
54985: ARRAY
54986: PPUSH
54987: LD_INT 2
54989: PUSH
54990: LD_INT 25
54992: PUSH
54993: LD_INT 5
54995: PUSH
54996: EMPTY
54997: LIST
54998: LIST
54999: PUSH
55000: LD_INT 25
55002: PUSH
55003: LD_INT 8
55005: PUSH
55006: EMPTY
55007: LIST
55008: LIST
55009: PUSH
55010: LD_INT 25
55012: PUSH
55013: LD_INT 9
55015: PUSH
55016: EMPTY
55017: LIST
55018: LIST
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: LIST
55024: LIST
55025: PPUSH
55026: CALL_OW 72
55030: ST_TO_ADDR
// if not tmp then
55031: LD_VAR 0 4
55035: NOT
55036: IFFALSE 55040
// continue ;
55038: GO 54836
// for j in tmp do
55040: LD_ADDR_VAR 0 3
55044: PUSH
55045: LD_VAR 0 4
55049: PUSH
55050: FOR_IN
55051: IFFALSE 55122
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55053: LD_VAR 0 3
55057: PPUSH
55058: CALL_OW 310
55062: PPUSH
55063: CALL_OW 266
55067: PUSH
55068: LD_INT 5
55070: EQUAL
55071: PUSH
55072: LD_VAR 0 3
55076: PPUSH
55077: CALL_OW 257
55081: PUSH
55082: LD_INT 1
55084: EQUAL
55085: AND
55086: PUSH
55087: LD_VAR 0 3
55091: PPUSH
55092: CALL_OW 459
55096: NOT
55097: AND
55098: PUSH
55099: LD_VAR 0 7
55103: AND
55104: IFFALSE 55120
// ComChangeProfession ( j , class ) ;
55106: LD_VAR 0 3
55110: PPUSH
55111: LD_VAR 0 7
55115: PPUSH
55116: CALL_OW 123
55120: GO 55050
55122: POP
55123: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55124: LD_EXP 125
55128: PUSH
55129: LD_VAR 0 2
55133: ARRAY
55134: PUSH
55135: LD_EXP 145
55139: PUSH
55140: LD_VAR 0 2
55144: ARRAY
55145: NOT
55146: AND
55147: PUSH
55148: LD_EXP 124
55152: PUSH
55153: LD_VAR 0 2
55157: ARRAY
55158: NOT
55159: AND
55160: PUSH
55161: LD_EXP 102
55165: PUSH
55166: LD_VAR 0 2
55170: ARRAY
55171: PPUSH
55172: LD_INT 50
55174: PUSH
55175: EMPTY
55176: LIST
55177: PUSH
55178: LD_INT 2
55180: PUSH
55181: LD_INT 30
55183: PUSH
55184: LD_INT 32
55186: PUSH
55187: EMPTY
55188: LIST
55189: LIST
55190: PUSH
55191: LD_INT 30
55193: PUSH
55194: LD_INT 33
55196: PUSH
55197: EMPTY
55198: LIST
55199: LIST
55200: PUSH
55201: LD_INT 30
55203: PUSH
55204: LD_INT 4
55206: PUSH
55207: EMPTY
55208: LIST
55209: LIST
55210: PUSH
55211: LD_INT 30
55213: PUSH
55214: LD_INT 5
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: PUSH
55221: EMPTY
55222: LIST
55223: LIST
55224: LIST
55225: LIST
55226: LIST
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: PPUSH
55232: CALL_OW 72
55236: PUSH
55237: LD_INT 4
55239: LESS
55240: PUSH
55241: LD_EXP 102
55245: PUSH
55246: LD_VAR 0 2
55250: ARRAY
55251: PPUSH
55252: LD_INT 3
55254: PUSH
55255: LD_INT 24
55257: PUSH
55258: LD_INT 1000
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: PUSH
55265: EMPTY
55266: LIST
55267: LIST
55268: PUSH
55269: LD_INT 2
55271: PUSH
55272: LD_INT 30
55274: PUSH
55275: LD_INT 0
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: PUSH
55282: LD_INT 30
55284: PUSH
55285: LD_INT 1
55287: PUSH
55288: EMPTY
55289: LIST
55290: LIST
55291: PUSH
55292: EMPTY
55293: LIST
55294: LIST
55295: LIST
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: PPUSH
55301: CALL_OW 72
55305: OR
55306: AND
55307: IFFALSE 55558
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55309: LD_ADDR_EXP 145
55313: PUSH
55314: LD_EXP 145
55318: PPUSH
55319: LD_VAR 0 2
55323: PPUSH
55324: LD_INT 1
55326: PPUSH
55327: CALL_OW 1
55331: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55332: LD_ADDR_VAR 0 4
55336: PUSH
55337: LD_EXP 102
55341: PUSH
55342: LD_VAR 0 2
55346: ARRAY
55347: PPUSH
55348: LD_INT 2
55350: PUSH
55351: LD_INT 25
55353: PUSH
55354: LD_INT 1
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: PUSH
55361: LD_INT 25
55363: PUSH
55364: LD_INT 5
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: LD_INT 25
55373: PUSH
55374: LD_INT 8
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: PUSH
55381: LD_INT 25
55383: PUSH
55384: LD_INT 9
55386: PUSH
55387: EMPTY
55388: LIST
55389: LIST
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: LIST
55395: LIST
55396: LIST
55397: PPUSH
55398: CALL_OW 72
55402: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55403: LD_ADDR_VAR 0 4
55407: PUSH
55408: LD_VAR 0 4
55412: PUSH
55413: LD_VAR 0 4
55417: PPUSH
55418: LD_INT 18
55420: PPUSH
55421: CALL 104851 0 2
55425: DIFF
55426: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55427: LD_VAR 0 4
55431: NOT
55432: PUSH
55433: LD_EXP 102
55437: PUSH
55438: LD_VAR 0 2
55442: ARRAY
55443: PPUSH
55444: LD_INT 2
55446: PUSH
55447: LD_INT 30
55449: PUSH
55450: LD_INT 4
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: PUSH
55457: LD_INT 30
55459: PUSH
55460: LD_INT 5
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: PUSH
55467: EMPTY
55468: LIST
55469: LIST
55470: LIST
55471: PPUSH
55472: CALL_OW 72
55476: NOT
55477: AND
55478: IFFALSE 55540
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55480: LD_ADDR_VAR 0 4
55484: PUSH
55485: LD_EXP 102
55489: PUSH
55490: LD_VAR 0 2
55494: ARRAY
55495: PPUSH
55496: LD_INT 2
55498: PUSH
55499: LD_INT 25
55501: PUSH
55502: LD_INT 2
55504: PUSH
55505: EMPTY
55506: LIST
55507: LIST
55508: PUSH
55509: LD_INT 25
55511: PUSH
55512: LD_INT 3
55514: PUSH
55515: EMPTY
55516: LIST
55517: LIST
55518: PUSH
55519: LD_INT 25
55521: PUSH
55522: LD_INT 4
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: LIST
55533: LIST
55534: PPUSH
55535: CALL_OW 72
55539: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55540: LD_VAR 0 2
55544: PPUSH
55545: LD_VAR 0 4
55549: PPUSH
55550: CALL 137784 0 2
// exit ;
55554: POP
55555: POP
55556: GO 55678
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55558: LD_EXP 125
55562: PUSH
55563: LD_VAR 0 2
55567: ARRAY
55568: PUSH
55569: LD_EXP 145
55573: PUSH
55574: LD_VAR 0 2
55578: ARRAY
55579: NOT
55580: AND
55581: PUSH
55582: LD_EXP 124
55586: PUSH
55587: LD_VAR 0 2
55591: ARRAY
55592: AND
55593: IFFALSE 55674
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55595: LD_ADDR_EXP 145
55599: PUSH
55600: LD_EXP 145
55604: PPUSH
55605: LD_VAR 0 2
55609: PPUSH
55610: LD_INT 1
55612: PPUSH
55613: CALL_OW 1
55617: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55618: LD_ADDR_VAR 0 4
55622: PUSH
55623: LD_EXP 124
55627: PUSH
55628: LD_VAR 0 2
55632: ARRAY
55633: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55634: LD_ADDR_EXP 124
55638: PUSH
55639: LD_EXP 124
55643: PPUSH
55644: LD_VAR 0 2
55648: PPUSH
55649: EMPTY
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// Defend ( i , tmp ) ;
55656: LD_VAR 0 2
55660: PPUSH
55661: LD_VAR 0 4
55665: PPUSH
55666: CALL 138380 0 2
// exit ;
55670: POP
55671: POP
55672: GO 55678
// end ; end ;
55674: GO 54836
55676: POP
55677: POP
// end ;
55678: LD_VAR 0 1
55682: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55683: LD_INT 0
55685: PPUSH
55686: PPUSH
55687: PPUSH
55688: PPUSH
55689: PPUSH
55690: PPUSH
55691: PPUSH
55692: PPUSH
55693: PPUSH
55694: PPUSH
55695: PPUSH
// if not mc_bases then
55696: LD_EXP 102
55700: NOT
55701: IFFALSE 55705
// exit ;
55703: GO 56792
// for i = 1 to mc_bases do
55705: LD_ADDR_VAR 0 2
55709: PUSH
55710: DOUBLE
55711: LD_INT 1
55713: DEC
55714: ST_TO_ADDR
55715: LD_EXP 102
55719: PUSH
55720: FOR_TO
55721: IFFALSE 56790
// begin tmp := mc_lab [ i ] ;
55723: LD_ADDR_VAR 0 6
55727: PUSH
55728: LD_EXP 135
55732: PUSH
55733: LD_VAR 0 2
55737: ARRAY
55738: ST_TO_ADDR
// if not tmp then
55739: LD_VAR 0 6
55743: NOT
55744: IFFALSE 55748
// continue ;
55746: GO 55720
// idle_lab := 0 ;
55748: LD_ADDR_VAR 0 11
55752: PUSH
55753: LD_INT 0
55755: ST_TO_ADDR
// for j in tmp do
55756: LD_ADDR_VAR 0 3
55760: PUSH
55761: LD_VAR 0 6
55765: PUSH
55766: FOR_IN
55767: IFFALSE 56786
// begin researching := false ;
55769: LD_ADDR_VAR 0 10
55773: PUSH
55774: LD_INT 0
55776: ST_TO_ADDR
// side := GetSide ( j ) ;
55777: LD_ADDR_VAR 0 4
55781: PUSH
55782: LD_VAR 0 3
55786: PPUSH
55787: CALL_OW 255
55791: ST_TO_ADDR
// if not mc_tech [ side ] then
55792: LD_EXP 129
55796: PUSH
55797: LD_VAR 0 4
55801: ARRAY
55802: NOT
55803: IFFALSE 55807
// continue ;
55805: GO 55766
// if BuildingStatus ( j ) = bs_idle then
55807: LD_VAR 0 3
55811: PPUSH
55812: CALL_OW 461
55816: PUSH
55817: LD_INT 2
55819: EQUAL
55820: IFFALSE 56008
// begin if idle_lab and UnitsInside ( j ) < 6 then
55822: LD_VAR 0 11
55826: PUSH
55827: LD_VAR 0 3
55831: PPUSH
55832: CALL_OW 313
55836: PUSH
55837: LD_INT 6
55839: LESS
55840: AND
55841: IFFALSE 55912
// begin tmp2 := UnitsInside ( idle_lab ) ;
55843: LD_ADDR_VAR 0 9
55847: PUSH
55848: LD_VAR 0 11
55852: PPUSH
55853: CALL_OW 313
55857: ST_TO_ADDR
// if tmp2 then
55858: LD_VAR 0 9
55862: IFFALSE 55904
// for x in tmp2 do
55864: LD_ADDR_VAR 0 7
55868: PUSH
55869: LD_VAR 0 9
55873: PUSH
55874: FOR_IN
55875: IFFALSE 55902
// begin ComExitBuilding ( x ) ;
55877: LD_VAR 0 7
55881: PPUSH
55882: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55886: LD_VAR 0 7
55890: PPUSH
55891: LD_VAR 0 3
55895: PPUSH
55896: CALL_OW 180
// end ;
55900: GO 55874
55902: POP
55903: POP
// idle_lab := 0 ;
55904: LD_ADDR_VAR 0 11
55908: PUSH
55909: LD_INT 0
55911: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55912: LD_ADDR_VAR 0 5
55916: PUSH
55917: LD_EXP 129
55921: PUSH
55922: LD_VAR 0 4
55926: ARRAY
55927: PUSH
55928: FOR_IN
55929: IFFALSE 55989
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55931: LD_VAR 0 3
55935: PPUSH
55936: LD_VAR 0 5
55940: PPUSH
55941: CALL_OW 430
55945: PUSH
55946: LD_VAR 0 4
55950: PPUSH
55951: LD_VAR 0 5
55955: PPUSH
55956: CALL 70447 0 2
55960: AND
55961: IFFALSE 55987
// begin researching := true ;
55963: LD_ADDR_VAR 0 10
55967: PUSH
55968: LD_INT 1
55970: ST_TO_ADDR
// ComResearch ( j , t ) ;
55971: LD_VAR 0 3
55975: PPUSH
55976: LD_VAR 0 5
55980: PPUSH
55981: CALL_OW 124
// break ;
55985: GO 55989
// end ;
55987: GO 55928
55989: POP
55990: POP
// if not researching then
55991: LD_VAR 0 10
55995: NOT
55996: IFFALSE 56008
// idle_lab := j ;
55998: LD_ADDR_VAR 0 11
56002: PUSH
56003: LD_VAR 0 3
56007: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56008: LD_VAR 0 3
56012: PPUSH
56013: CALL_OW 461
56017: PUSH
56018: LD_INT 10
56020: EQUAL
56021: IFFALSE 56609
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56023: LD_EXP 131
56027: PUSH
56028: LD_VAR 0 2
56032: ARRAY
56033: NOT
56034: PUSH
56035: LD_EXP 132
56039: PUSH
56040: LD_VAR 0 2
56044: ARRAY
56045: NOT
56046: AND
56047: PUSH
56048: LD_EXP 129
56052: PUSH
56053: LD_VAR 0 4
56057: ARRAY
56058: PUSH
56059: LD_INT 1
56061: GREATER
56062: AND
56063: IFFALSE 56194
// begin ComCancel ( j ) ;
56065: LD_VAR 0 3
56069: PPUSH
56070: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56074: LD_ADDR_EXP 129
56078: PUSH
56079: LD_EXP 129
56083: PPUSH
56084: LD_VAR 0 4
56088: PPUSH
56089: LD_EXP 129
56093: PUSH
56094: LD_VAR 0 4
56098: ARRAY
56099: PPUSH
56100: LD_EXP 129
56104: PUSH
56105: LD_VAR 0 4
56109: ARRAY
56110: PUSH
56111: LD_INT 1
56113: MINUS
56114: PPUSH
56115: LD_EXP 129
56119: PUSH
56120: LD_VAR 0 4
56124: ARRAY
56125: PPUSH
56126: LD_INT 0
56128: PPUSH
56129: CALL 73971 0 4
56133: PPUSH
56134: CALL_OW 1
56138: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56139: LD_ADDR_EXP 129
56143: PUSH
56144: LD_EXP 129
56148: PPUSH
56149: LD_VAR 0 4
56153: PPUSH
56154: LD_EXP 129
56158: PUSH
56159: LD_VAR 0 4
56163: ARRAY
56164: PPUSH
56165: LD_EXP 129
56169: PUSH
56170: LD_VAR 0 4
56174: ARRAY
56175: PPUSH
56176: LD_INT 1
56178: PPUSH
56179: LD_INT 0
56181: PPUSH
56182: CALL 73971 0 4
56186: PPUSH
56187: CALL_OW 1
56191: ST_TO_ADDR
// continue ;
56192: GO 55766
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56194: LD_EXP 131
56198: PUSH
56199: LD_VAR 0 2
56203: ARRAY
56204: PUSH
56205: LD_EXP 132
56209: PUSH
56210: LD_VAR 0 2
56214: ARRAY
56215: NOT
56216: AND
56217: IFFALSE 56344
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56219: LD_ADDR_EXP 132
56223: PUSH
56224: LD_EXP 132
56228: PPUSH
56229: LD_VAR 0 2
56233: PUSH
56234: LD_EXP 132
56238: PUSH
56239: LD_VAR 0 2
56243: ARRAY
56244: PUSH
56245: LD_INT 1
56247: PLUS
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: PPUSH
56253: LD_EXP 131
56257: PUSH
56258: LD_VAR 0 2
56262: ARRAY
56263: PUSH
56264: LD_INT 1
56266: ARRAY
56267: PPUSH
56268: CALL 74553 0 3
56272: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56273: LD_EXP 131
56277: PUSH
56278: LD_VAR 0 2
56282: ARRAY
56283: PUSH
56284: LD_INT 1
56286: ARRAY
56287: PPUSH
56288: LD_INT 112
56290: PPUSH
56291: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56295: LD_ADDR_VAR 0 9
56299: PUSH
56300: LD_EXP 131
56304: PUSH
56305: LD_VAR 0 2
56309: ARRAY
56310: PPUSH
56311: LD_INT 1
56313: PPUSH
56314: CALL_OW 3
56318: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56319: LD_ADDR_EXP 131
56323: PUSH
56324: LD_EXP 131
56328: PPUSH
56329: LD_VAR 0 2
56333: PPUSH
56334: LD_VAR 0 9
56338: PPUSH
56339: CALL_OW 1
56343: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56344: LD_EXP 131
56348: PUSH
56349: LD_VAR 0 2
56353: ARRAY
56354: PUSH
56355: LD_EXP 132
56359: PUSH
56360: LD_VAR 0 2
56364: ARRAY
56365: AND
56366: PUSH
56367: LD_EXP 132
56371: PUSH
56372: LD_VAR 0 2
56376: ARRAY
56377: PUSH
56378: LD_INT 1
56380: ARRAY
56381: PPUSH
56382: CALL_OW 310
56386: NOT
56387: AND
56388: PUSH
56389: LD_VAR 0 3
56393: PPUSH
56394: CALL_OW 313
56398: PUSH
56399: LD_INT 6
56401: EQUAL
56402: AND
56403: IFFALSE 56459
// begin tmp2 := UnitsInside ( j ) ;
56405: LD_ADDR_VAR 0 9
56409: PUSH
56410: LD_VAR 0 3
56414: PPUSH
56415: CALL_OW 313
56419: ST_TO_ADDR
// if tmp2 = 6 then
56420: LD_VAR 0 9
56424: PUSH
56425: LD_INT 6
56427: EQUAL
56428: IFFALSE 56459
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56430: LD_VAR 0 9
56434: PUSH
56435: LD_INT 1
56437: ARRAY
56438: PPUSH
56439: LD_INT 112
56441: PPUSH
56442: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56446: LD_VAR 0 9
56450: PUSH
56451: LD_INT 1
56453: ARRAY
56454: PPUSH
56455: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56459: LD_EXP 132
56463: PUSH
56464: LD_VAR 0 2
56468: ARRAY
56469: PUSH
56470: LD_EXP 132
56474: PUSH
56475: LD_VAR 0 2
56479: ARRAY
56480: PUSH
56481: LD_INT 1
56483: ARRAY
56484: PPUSH
56485: CALL_OW 314
56489: NOT
56490: AND
56491: PUSH
56492: LD_EXP 132
56496: PUSH
56497: LD_VAR 0 2
56501: ARRAY
56502: PUSH
56503: LD_INT 1
56505: ARRAY
56506: PPUSH
56507: CALL_OW 310
56511: NOT
56512: AND
56513: IFFALSE 56539
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56515: LD_EXP 132
56519: PUSH
56520: LD_VAR 0 2
56524: ARRAY
56525: PUSH
56526: LD_INT 1
56528: ARRAY
56529: PPUSH
56530: LD_VAR 0 3
56534: PPUSH
56535: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56539: LD_EXP 132
56543: PUSH
56544: LD_VAR 0 2
56548: ARRAY
56549: PUSH
56550: LD_INT 1
56552: ARRAY
56553: PPUSH
56554: CALL_OW 310
56558: PUSH
56559: LD_EXP 132
56563: PUSH
56564: LD_VAR 0 2
56568: ARRAY
56569: PUSH
56570: LD_INT 1
56572: ARRAY
56573: PPUSH
56574: CALL_OW 310
56578: PPUSH
56579: CALL_OW 461
56583: PUSH
56584: LD_INT 3
56586: NONEQUAL
56587: AND
56588: IFFALSE 56609
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56590: LD_EXP 132
56594: PUSH
56595: LD_VAR 0 2
56599: ARRAY
56600: PUSH
56601: LD_INT 1
56603: ARRAY
56604: PPUSH
56605: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56609: LD_VAR 0 3
56613: PPUSH
56614: CALL_OW 461
56618: PUSH
56619: LD_INT 6
56621: EQUAL
56622: PUSH
56623: LD_VAR 0 6
56627: PUSH
56628: LD_INT 1
56630: GREATER
56631: AND
56632: IFFALSE 56784
// begin sci := [ ] ;
56634: LD_ADDR_VAR 0 8
56638: PUSH
56639: EMPTY
56640: ST_TO_ADDR
// for x in ( tmp diff j ) do
56641: LD_ADDR_VAR 0 7
56645: PUSH
56646: LD_VAR 0 6
56650: PUSH
56651: LD_VAR 0 3
56655: DIFF
56656: PUSH
56657: FOR_IN
56658: IFFALSE 56710
// begin if sci = 6 then
56660: LD_VAR 0 8
56664: PUSH
56665: LD_INT 6
56667: EQUAL
56668: IFFALSE 56672
// break ;
56670: GO 56710
// if BuildingStatus ( x ) = bs_idle then
56672: LD_VAR 0 7
56676: PPUSH
56677: CALL_OW 461
56681: PUSH
56682: LD_INT 2
56684: EQUAL
56685: IFFALSE 56708
// sci := sci ^ UnitsInside ( x ) ;
56687: LD_ADDR_VAR 0 8
56691: PUSH
56692: LD_VAR 0 8
56696: PUSH
56697: LD_VAR 0 7
56701: PPUSH
56702: CALL_OW 313
56706: ADD
56707: ST_TO_ADDR
// end ;
56708: GO 56657
56710: POP
56711: POP
// if not sci then
56712: LD_VAR 0 8
56716: NOT
56717: IFFALSE 56721
// continue ;
56719: GO 55766
// for x in sci do
56721: LD_ADDR_VAR 0 7
56725: PUSH
56726: LD_VAR 0 8
56730: PUSH
56731: FOR_IN
56732: IFFALSE 56782
// if IsInUnit ( x ) and not HasTask ( x ) then
56734: LD_VAR 0 7
56738: PPUSH
56739: CALL_OW 310
56743: PUSH
56744: LD_VAR 0 7
56748: PPUSH
56749: CALL_OW 314
56753: NOT
56754: AND
56755: IFFALSE 56780
// begin ComExitBuilding ( x ) ;
56757: LD_VAR 0 7
56761: PPUSH
56762: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56766: LD_VAR 0 7
56770: PPUSH
56771: LD_VAR 0 3
56775: PPUSH
56776: CALL_OW 180
// end ;
56780: GO 56731
56782: POP
56783: POP
// end ; end ;
56784: GO 55766
56786: POP
56787: POP
// end ;
56788: GO 55720
56790: POP
56791: POP
// end ;
56792: LD_VAR 0 1
56796: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
// if not mc_bases then
56801: LD_EXP 102
56805: NOT
56806: IFFALSE 56810
// exit ;
56808: GO 56891
// for i = 1 to mc_bases do
56810: LD_ADDR_VAR 0 2
56814: PUSH
56815: DOUBLE
56816: LD_INT 1
56818: DEC
56819: ST_TO_ADDR
56820: LD_EXP 102
56824: PUSH
56825: FOR_TO
56826: IFFALSE 56889
// if mc_mines [ i ] and mc_miners [ i ] then
56828: LD_EXP 115
56832: PUSH
56833: LD_VAR 0 2
56837: ARRAY
56838: PUSH
56839: LD_EXP 116
56843: PUSH
56844: LD_VAR 0 2
56848: ARRAY
56849: AND
56850: IFFALSE 56887
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56852: LD_EXP 116
56856: PUSH
56857: LD_VAR 0 2
56861: ARRAY
56862: PUSH
56863: LD_INT 1
56865: ARRAY
56866: PPUSH
56867: CALL_OW 255
56871: PPUSH
56872: LD_EXP 115
56876: PUSH
56877: LD_VAR 0 2
56881: ARRAY
56882: PPUSH
56883: CALL 71530 0 2
56887: GO 56825
56889: POP
56890: POP
// end ;
56891: LD_VAR 0 1
56895: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56896: LD_INT 0
56898: PPUSH
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
56903: PPUSH
56904: PPUSH
56905: PPUSH
// if not mc_bases or not mc_parking then
56906: LD_EXP 102
56910: NOT
56911: PUSH
56912: LD_EXP 126
56916: NOT
56917: OR
56918: IFFALSE 56922
// exit ;
56920: GO 57660
// for i = 1 to mc_bases do
56922: LD_ADDR_VAR 0 2
56926: PUSH
56927: DOUBLE
56928: LD_INT 1
56930: DEC
56931: ST_TO_ADDR
56932: LD_EXP 102
56936: PUSH
56937: FOR_TO
56938: IFFALSE 57658
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56940: LD_EXP 102
56944: PUSH
56945: LD_VAR 0 2
56949: ARRAY
56950: NOT
56951: PUSH
56952: LD_EXP 126
56956: PUSH
56957: LD_VAR 0 2
56961: ARRAY
56962: NOT
56963: OR
56964: IFFALSE 56968
// continue ;
56966: GO 56937
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56968: LD_ADDR_VAR 0 5
56972: PUSH
56973: LD_EXP 102
56977: PUSH
56978: LD_VAR 0 2
56982: ARRAY
56983: PUSH
56984: LD_INT 1
56986: ARRAY
56987: PPUSH
56988: CALL_OW 255
56992: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56993: LD_ADDR_VAR 0 6
56997: PUSH
56998: LD_EXP 102
57002: PUSH
57003: LD_VAR 0 2
57007: ARRAY
57008: PPUSH
57009: LD_INT 30
57011: PUSH
57012: LD_INT 3
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: PPUSH
57019: CALL_OW 72
57023: ST_TO_ADDR
// if not fac then
57024: LD_VAR 0 6
57028: NOT
57029: IFFALSE 57080
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57031: LD_ADDR_VAR 0 6
57035: PUSH
57036: LD_EXP 102
57040: PUSH
57041: LD_VAR 0 2
57045: ARRAY
57046: PPUSH
57047: LD_INT 2
57049: PUSH
57050: LD_INT 30
57052: PUSH
57053: LD_INT 0
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: LD_INT 30
57062: PUSH
57063: LD_INT 1
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PUSH
57070: EMPTY
57071: LIST
57072: LIST
57073: LIST
57074: PPUSH
57075: CALL_OW 72
57079: ST_TO_ADDR
// if not fac then
57080: LD_VAR 0 6
57084: NOT
57085: IFFALSE 57089
// continue ;
57087: GO 56937
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57089: LD_ADDR_VAR 0 7
57093: PUSH
57094: LD_EXP 126
57098: PUSH
57099: LD_VAR 0 2
57103: ARRAY
57104: PPUSH
57105: LD_INT 22
57107: PUSH
57108: LD_VAR 0 5
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PUSH
57117: LD_INT 21
57119: PUSH
57120: LD_INT 2
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: PUSH
57127: LD_INT 3
57129: PUSH
57130: LD_INT 60
57132: PUSH
57133: EMPTY
57134: LIST
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: LD_INT 3
57142: PUSH
57143: LD_INT 24
57145: PUSH
57146: LD_INT 1000
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: LIST
57161: LIST
57162: PPUSH
57163: CALL_OW 70
57167: ST_TO_ADDR
// for j in fac do
57168: LD_ADDR_VAR 0 3
57172: PUSH
57173: LD_VAR 0 6
57177: PUSH
57178: FOR_IN
57179: IFFALSE 57274
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57181: LD_ADDR_VAR 0 7
57185: PUSH
57186: LD_VAR 0 7
57190: PUSH
57191: LD_INT 22
57193: PUSH
57194: LD_VAR 0 5
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: PUSH
57203: LD_INT 91
57205: PUSH
57206: LD_VAR 0 3
57210: PUSH
57211: LD_INT 15
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: LIST
57218: PUSH
57219: LD_INT 21
57221: PUSH
57222: LD_INT 2
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: PUSH
57229: LD_INT 3
57231: PUSH
57232: LD_INT 60
57234: PUSH
57235: EMPTY
57236: LIST
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: LD_INT 3
57244: PUSH
57245: LD_INT 24
57247: PUSH
57248: LD_INT 1000
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: EMPTY
57256: LIST
57257: LIST
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: LIST
57263: LIST
57264: LIST
57265: PPUSH
57266: CALL_OW 69
57270: UNION
57271: ST_TO_ADDR
57272: GO 57178
57274: POP
57275: POP
// if not vehs then
57276: LD_VAR 0 7
57280: NOT
57281: IFFALSE 57307
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57283: LD_ADDR_EXP 114
57287: PUSH
57288: LD_EXP 114
57292: PPUSH
57293: LD_VAR 0 2
57297: PPUSH
57298: EMPTY
57299: PPUSH
57300: CALL_OW 1
57304: ST_TO_ADDR
// continue ;
57305: GO 56937
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57307: LD_ADDR_VAR 0 8
57311: PUSH
57312: LD_EXP 102
57316: PUSH
57317: LD_VAR 0 2
57321: ARRAY
57322: PPUSH
57323: LD_INT 30
57325: PUSH
57326: LD_INT 3
57328: PUSH
57329: EMPTY
57330: LIST
57331: LIST
57332: PPUSH
57333: CALL_OW 72
57337: ST_TO_ADDR
// if tmp then
57338: LD_VAR 0 8
57342: IFFALSE 57445
// begin for j in tmp do
57344: LD_ADDR_VAR 0 3
57348: PUSH
57349: LD_VAR 0 8
57353: PUSH
57354: FOR_IN
57355: IFFALSE 57443
// for k in UnitsInside ( j ) do
57357: LD_ADDR_VAR 0 4
57361: PUSH
57362: LD_VAR 0 3
57366: PPUSH
57367: CALL_OW 313
57371: PUSH
57372: FOR_IN
57373: IFFALSE 57439
// if k then
57375: LD_VAR 0 4
57379: IFFALSE 57437
// if not k in mc_repair_vehicle [ i ] then
57381: LD_VAR 0 4
57385: PUSH
57386: LD_EXP 114
57390: PUSH
57391: LD_VAR 0 2
57395: ARRAY
57396: IN
57397: NOT
57398: IFFALSE 57437
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57400: LD_ADDR_EXP 114
57404: PUSH
57405: LD_EXP 114
57409: PPUSH
57410: LD_VAR 0 2
57414: PPUSH
57415: LD_EXP 114
57419: PUSH
57420: LD_VAR 0 2
57424: ARRAY
57425: PUSH
57426: LD_VAR 0 4
57430: UNION
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
57437: GO 57372
57439: POP
57440: POP
57441: GO 57354
57443: POP
57444: POP
// end ; if not mc_repair_vehicle [ i ] then
57445: LD_EXP 114
57449: PUSH
57450: LD_VAR 0 2
57454: ARRAY
57455: NOT
57456: IFFALSE 57460
// continue ;
57458: GO 56937
// for j in mc_repair_vehicle [ i ] do
57460: LD_ADDR_VAR 0 3
57464: PUSH
57465: LD_EXP 114
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: PUSH
57476: FOR_IN
57477: IFFALSE 57654
// begin if GetClass ( j ) <> 3 then
57479: LD_VAR 0 3
57483: PPUSH
57484: CALL_OW 257
57488: PUSH
57489: LD_INT 3
57491: NONEQUAL
57492: IFFALSE 57533
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57494: LD_ADDR_EXP 114
57498: PUSH
57499: LD_EXP 114
57503: PPUSH
57504: LD_VAR 0 2
57508: PPUSH
57509: LD_EXP 114
57513: PUSH
57514: LD_VAR 0 2
57518: ARRAY
57519: PUSH
57520: LD_VAR 0 3
57524: DIFF
57525: PPUSH
57526: CALL_OW 1
57530: ST_TO_ADDR
// continue ;
57531: GO 57476
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57533: LD_VAR 0 3
57537: PPUSH
57538: CALL_OW 311
57542: NOT
57543: PUSH
57544: LD_VAR 0 3
57548: PUSH
57549: LD_EXP 105
57553: PUSH
57554: LD_VAR 0 2
57558: ARRAY
57559: PUSH
57560: LD_INT 1
57562: ARRAY
57563: IN
57564: NOT
57565: AND
57566: PUSH
57567: LD_VAR 0 3
57571: PUSH
57572: LD_EXP 105
57576: PUSH
57577: LD_VAR 0 2
57581: ARRAY
57582: PUSH
57583: LD_INT 2
57585: ARRAY
57586: IN
57587: NOT
57588: AND
57589: IFFALSE 57652
// begin if IsInUnit ( j ) then
57591: LD_VAR 0 3
57595: PPUSH
57596: CALL_OW 310
57600: IFFALSE 57613
// ComExitBuilding ( j ) else
57602: LD_VAR 0 3
57606: PPUSH
57607: CALL_OW 122
57611: GO 57652
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57613: LD_VAR 0 3
57617: PPUSH
57618: LD_VAR 0 7
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: PPUSH
57627: CALL 109347 0 2
57631: NOT
57632: IFFALSE 57652
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57634: LD_VAR 0 3
57638: PPUSH
57639: LD_VAR 0 7
57643: PUSH
57644: LD_INT 1
57646: ARRAY
57647: PPUSH
57648: CALL_OW 129
// end ; end ;
57652: GO 57476
57654: POP
57655: POP
// end ;
57656: GO 56937
57658: POP
57659: POP
// end ;
57660: LD_VAR 0 1
57664: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57665: LD_INT 0
57667: PPUSH
57668: PPUSH
57669: PPUSH
57670: PPUSH
57671: PPUSH
57672: PPUSH
57673: PPUSH
57674: PPUSH
57675: PPUSH
57676: PPUSH
57677: PPUSH
// if not mc_bases then
57678: LD_EXP 102
57682: NOT
57683: IFFALSE 57687
// exit ;
57685: GO 58489
// for i = 1 to mc_bases do
57687: LD_ADDR_VAR 0 2
57691: PUSH
57692: DOUBLE
57693: LD_INT 1
57695: DEC
57696: ST_TO_ADDR
57697: LD_EXP 102
57701: PUSH
57702: FOR_TO
57703: IFFALSE 58487
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57705: LD_EXP 130
57709: PUSH
57710: LD_VAR 0 2
57714: ARRAY
57715: NOT
57716: PUSH
57717: LD_EXP 105
57721: PUSH
57722: LD_VAR 0 2
57726: ARRAY
57727: PUSH
57728: LD_INT 1
57730: ARRAY
57731: OR
57732: PUSH
57733: LD_EXP 105
57737: PUSH
57738: LD_VAR 0 2
57742: ARRAY
57743: PUSH
57744: LD_INT 2
57746: ARRAY
57747: OR
57748: PUSH
57749: LD_EXP 128
57753: PUSH
57754: LD_VAR 0 2
57758: ARRAY
57759: PPUSH
57760: LD_INT 1
57762: PPUSH
57763: CALL_OW 325
57767: NOT
57768: OR
57769: PUSH
57770: LD_EXP 125
57774: PUSH
57775: LD_VAR 0 2
57779: ARRAY
57780: OR
57781: IFFALSE 57785
// continue ;
57783: GO 57702
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57785: LD_ADDR_VAR 0 8
57789: PUSH
57790: LD_EXP 102
57794: PUSH
57795: LD_VAR 0 2
57799: ARRAY
57800: PPUSH
57801: LD_INT 25
57803: PUSH
57804: LD_INT 4
57806: PUSH
57807: EMPTY
57808: LIST
57809: LIST
57810: PUSH
57811: LD_INT 50
57813: PUSH
57814: EMPTY
57815: LIST
57816: PUSH
57817: LD_INT 3
57819: PUSH
57820: LD_INT 60
57822: PUSH
57823: EMPTY
57824: LIST
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: LIST
57834: PPUSH
57835: CALL_OW 72
57839: PUSH
57840: LD_EXP 106
57844: PUSH
57845: LD_VAR 0 2
57849: ARRAY
57850: DIFF
57851: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57852: LD_ADDR_VAR 0 9
57856: PUSH
57857: LD_EXP 102
57861: PUSH
57862: LD_VAR 0 2
57866: ARRAY
57867: PPUSH
57868: LD_INT 2
57870: PUSH
57871: LD_INT 30
57873: PUSH
57874: LD_INT 0
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: PUSH
57881: LD_INT 30
57883: PUSH
57884: LD_INT 1
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: LIST
57895: PPUSH
57896: CALL_OW 72
57900: ST_TO_ADDR
// if not tmp or not dep then
57901: LD_VAR 0 8
57905: NOT
57906: PUSH
57907: LD_VAR 0 9
57911: NOT
57912: OR
57913: IFFALSE 57917
// continue ;
57915: GO 57702
// side := GetSide ( tmp [ 1 ] ) ;
57917: LD_ADDR_VAR 0 11
57921: PUSH
57922: LD_VAR 0 8
57926: PUSH
57927: LD_INT 1
57929: ARRAY
57930: PPUSH
57931: CALL_OW 255
57935: ST_TO_ADDR
// dep := dep [ 1 ] ;
57936: LD_ADDR_VAR 0 9
57940: PUSH
57941: LD_VAR 0 9
57945: PUSH
57946: LD_INT 1
57948: ARRAY
57949: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57950: LD_ADDR_VAR 0 7
57954: PUSH
57955: LD_EXP 130
57959: PUSH
57960: LD_VAR 0 2
57964: ARRAY
57965: PPUSH
57966: LD_INT 22
57968: PUSH
57969: LD_INT 0
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: PUSH
57976: LD_INT 25
57978: PUSH
57979: LD_INT 12
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: PPUSH
57990: CALL_OW 70
57994: PUSH
57995: LD_INT 22
57997: PUSH
57998: LD_INT 0
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: LD_INT 25
58007: PUSH
58008: LD_INT 12
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: LD_INT 91
58017: PUSH
58018: LD_VAR 0 9
58022: PUSH
58023: LD_INT 20
58025: PUSH
58026: EMPTY
58027: LIST
58028: LIST
58029: LIST
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: LIST
58035: PPUSH
58036: CALL_OW 69
58040: UNION
58041: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58042: LD_ADDR_VAR 0 10
58046: PUSH
58047: LD_EXP 130
58051: PUSH
58052: LD_VAR 0 2
58056: ARRAY
58057: PPUSH
58058: LD_INT 81
58060: PUSH
58061: LD_VAR 0 11
58065: PUSH
58066: EMPTY
58067: LIST
58068: LIST
58069: PPUSH
58070: CALL_OW 70
58074: ST_TO_ADDR
// if not apes or danger_at_area then
58075: LD_VAR 0 7
58079: NOT
58080: PUSH
58081: LD_VAR 0 10
58085: OR
58086: IFFALSE 58136
// begin if mc_taming [ i ] then
58088: LD_EXP 133
58092: PUSH
58093: LD_VAR 0 2
58097: ARRAY
58098: IFFALSE 58134
// begin MC_Reset ( i , 121 ) ;
58100: LD_VAR 0 2
58104: PPUSH
58105: LD_INT 121
58107: PPUSH
58108: CALL 43052 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58112: LD_ADDR_EXP 133
58116: PUSH
58117: LD_EXP 133
58121: PPUSH
58122: LD_VAR 0 2
58126: PPUSH
58127: EMPTY
58128: PPUSH
58129: CALL_OW 1
58133: ST_TO_ADDR
// end ; continue ;
58134: GO 57702
// end ; for j in tmp do
58136: LD_ADDR_VAR 0 3
58140: PUSH
58141: LD_VAR 0 8
58145: PUSH
58146: FOR_IN
58147: IFFALSE 58483
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58149: LD_VAR 0 3
58153: PUSH
58154: LD_EXP 133
58158: PUSH
58159: LD_VAR 0 2
58163: ARRAY
58164: IN
58165: NOT
58166: PUSH
58167: LD_EXP 133
58171: PUSH
58172: LD_VAR 0 2
58176: ARRAY
58177: PUSH
58178: LD_INT 3
58180: LESS
58181: AND
58182: IFFALSE 58240
// begin SetTag ( j , 121 ) ;
58184: LD_VAR 0 3
58188: PPUSH
58189: LD_INT 121
58191: PPUSH
58192: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58196: LD_ADDR_EXP 133
58200: PUSH
58201: LD_EXP 133
58205: PPUSH
58206: LD_VAR 0 2
58210: PUSH
58211: LD_EXP 133
58215: PUSH
58216: LD_VAR 0 2
58220: ARRAY
58221: PUSH
58222: LD_INT 1
58224: PLUS
58225: PUSH
58226: EMPTY
58227: LIST
58228: LIST
58229: PPUSH
58230: LD_VAR 0 3
58234: PPUSH
58235: CALL 74553 0 3
58239: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58240: LD_VAR 0 3
58244: PUSH
58245: LD_EXP 133
58249: PUSH
58250: LD_VAR 0 2
58254: ARRAY
58255: IN
58256: IFFALSE 58481
// begin if GetClass ( j ) <> 4 then
58258: LD_VAR 0 3
58262: PPUSH
58263: CALL_OW 257
58267: PUSH
58268: LD_INT 4
58270: NONEQUAL
58271: IFFALSE 58324
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58273: LD_ADDR_EXP 133
58277: PUSH
58278: LD_EXP 133
58282: PPUSH
58283: LD_VAR 0 2
58287: PPUSH
58288: LD_EXP 133
58292: PUSH
58293: LD_VAR 0 2
58297: ARRAY
58298: PUSH
58299: LD_VAR 0 3
58303: DIFF
58304: PPUSH
58305: CALL_OW 1
58309: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58310: LD_VAR 0 3
58314: PPUSH
58315: LD_INT 0
58317: PPUSH
58318: CALL_OW 109
// continue ;
58322: GO 58146
// end ; if IsInUnit ( j ) then
58324: LD_VAR 0 3
58328: PPUSH
58329: CALL_OW 310
58333: IFFALSE 58344
// ComExitBuilding ( j ) ;
58335: LD_VAR 0 3
58339: PPUSH
58340: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58344: LD_ADDR_VAR 0 6
58348: PUSH
58349: LD_VAR 0 7
58353: PPUSH
58354: LD_VAR 0 3
58358: PPUSH
58359: CALL_OW 74
58363: ST_TO_ADDR
// if not ape then
58364: LD_VAR 0 6
58368: NOT
58369: IFFALSE 58373
// break ;
58371: GO 58483
// x := GetX ( ape ) ;
58373: LD_ADDR_VAR 0 4
58377: PUSH
58378: LD_VAR 0 6
58382: PPUSH
58383: CALL_OW 250
58387: ST_TO_ADDR
// y := GetY ( ape ) ;
58388: LD_ADDR_VAR 0 5
58392: PUSH
58393: LD_VAR 0 6
58397: PPUSH
58398: CALL_OW 251
58402: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58403: LD_VAR 0 4
58407: PPUSH
58408: LD_VAR 0 5
58412: PPUSH
58413: CALL_OW 488
58417: NOT
58418: PUSH
58419: LD_VAR 0 11
58423: PPUSH
58424: LD_VAR 0 4
58428: PPUSH
58429: LD_VAR 0 5
58433: PPUSH
58434: LD_INT 20
58436: PPUSH
58437: CALL 75817 0 4
58441: PUSH
58442: LD_INT 4
58444: ARRAY
58445: OR
58446: IFFALSE 58450
// break ;
58448: GO 58483
// if not HasTask ( j ) then
58450: LD_VAR 0 3
58454: PPUSH
58455: CALL_OW 314
58459: NOT
58460: IFFALSE 58481
// ComTameXY ( j , x , y ) ;
58462: LD_VAR 0 3
58466: PPUSH
58467: LD_VAR 0 4
58471: PPUSH
58472: LD_VAR 0 5
58476: PPUSH
58477: CALL_OW 131
// end ; end ;
58481: GO 58146
58483: POP
58484: POP
// end ;
58485: GO 57702
58487: POP
58488: POP
// end ;
58489: LD_VAR 0 1
58493: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58494: LD_INT 0
58496: PPUSH
58497: PPUSH
58498: PPUSH
58499: PPUSH
58500: PPUSH
58501: PPUSH
58502: PPUSH
58503: PPUSH
// if not mc_bases then
58504: LD_EXP 102
58508: NOT
58509: IFFALSE 58513
// exit ;
58511: GO 59139
// for i = 1 to mc_bases do
58513: LD_ADDR_VAR 0 2
58517: PUSH
58518: DOUBLE
58519: LD_INT 1
58521: DEC
58522: ST_TO_ADDR
58523: LD_EXP 102
58527: PUSH
58528: FOR_TO
58529: IFFALSE 59137
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58531: LD_EXP 131
58535: PUSH
58536: LD_VAR 0 2
58540: ARRAY
58541: NOT
58542: PUSH
58543: LD_EXP 131
58547: PUSH
58548: LD_VAR 0 2
58552: ARRAY
58553: PPUSH
58554: LD_INT 25
58556: PUSH
58557: LD_INT 12
58559: PUSH
58560: EMPTY
58561: LIST
58562: LIST
58563: PPUSH
58564: CALL_OW 72
58568: NOT
58569: OR
58570: IFFALSE 58574
// continue ;
58572: GO 58528
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58574: LD_ADDR_VAR 0 5
58578: PUSH
58579: LD_EXP 131
58583: PUSH
58584: LD_VAR 0 2
58588: ARRAY
58589: PUSH
58590: LD_INT 1
58592: ARRAY
58593: PPUSH
58594: CALL_OW 255
58598: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58599: LD_VAR 0 5
58603: PPUSH
58604: LD_INT 2
58606: PPUSH
58607: CALL_OW 325
58611: IFFALSE 58864
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58613: LD_ADDR_VAR 0 4
58617: PUSH
58618: LD_EXP 131
58622: PUSH
58623: LD_VAR 0 2
58627: ARRAY
58628: PPUSH
58629: LD_INT 25
58631: PUSH
58632: LD_INT 16
58634: PUSH
58635: EMPTY
58636: LIST
58637: LIST
58638: PPUSH
58639: CALL_OW 72
58643: ST_TO_ADDR
// if tmp < 6 then
58644: LD_VAR 0 4
58648: PUSH
58649: LD_INT 6
58651: LESS
58652: IFFALSE 58864
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58654: LD_ADDR_VAR 0 6
58658: PUSH
58659: LD_EXP 102
58663: PUSH
58664: LD_VAR 0 2
58668: ARRAY
58669: PPUSH
58670: LD_INT 2
58672: PUSH
58673: LD_INT 30
58675: PUSH
58676: LD_INT 0
58678: PUSH
58679: EMPTY
58680: LIST
58681: LIST
58682: PUSH
58683: LD_INT 30
58685: PUSH
58686: LD_INT 1
58688: PUSH
58689: EMPTY
58690: LIST
58691: LIST
58692: PUSH
58693: EMPTY
58694: LIST
58695: LIST
58696: LIST
58697: PPUSH
58698: CALL_OW 72
58702: ST_TO_ADDR
// if depot then
58703: LD_VAR 0 6
58707: IFFALSE 58864
// begin selected := 0 ;
58709: LD_ADDR_VAR 0 7
58713: PUSH
58714: LD_INT 0
58716: ST_TO_ADDR
// for j in depot do
58717: LD_ADDR_VAR 0 3
58721: PUSH
58722: LD_VAR 0 6
58726: PUSH
58727: FOR_IN
58728: IFFALSE 58759
// begin if UnitsInside ( j ) < 6 then
58730: LD_VAR 0 3
58734: PPUSH
58735: CALL_OW 313
58739: PUSH
58740: LD_INT 6
58742: LESS
58743: IFFALSE 58757
// begin selected := j ;
58745: LD_ADDR_VAR 0 7
58749: PUSH
58750: LD_VAR 0 3
58754: ST_TO_ADDR
// break ;
58755: GO 58759
// end ; end ;
58757: GO 58727
58759: POP
58760: POP
// if selected then
58761: LD_VAR 0 7
58765: IFFALSE 58864
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58767: LD_ADDR_VAR 0 3
58771: PUSH
58772: LD_EXP 131
58776: PUSH
58777: LD_VAR 0 2
58781: ARRAY
58782: PPUSH
58783: LD_INT 25
58785: PUSH
58786: LD_INT 12
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: PPUSH
58793: CALL_OW 72
58797: PUSH
58798: FOR_IN
58799: IFFALSE 58862
// if not HasTask ( j ) then
58801: LD_VAR 0 3
58805: PPUSH
58806: CALL_OW 314
58810: NOT
58811: IFFALSE 58860
// begin if not IsInUnit ( j ) then
58813: LD_VAR 0 3
58817: PPUSH
58818: CALL_OW 310
58822: NOT
58823: IFFALSE 58839
// ComEnterUnit ( j , selected ) ;
58825: LD_VAR 0 3
58829: PPUSH
58830: LD_VAR 0 7
58834: PPUSH
58835: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58839: LD_VAR 0 3
58843: PPUSH
58844: LD_INT 16
58846: PPUSH
58847: CALL_OW 183
// AddComExitBuilding ( j ) ;
58851: LD_VAR 0 3
58855: PPUSH
58856: CALL_OW 182
// end ;
58860: GO 58798
58862: POP
58863: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58864: LD_VAR 0 5
58868: PPUSH
58869: LD_INT 11
58871: PPUSH
58872: CALL_OW 325
58876: IFFALSE 59135
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58878: LD_ADDR_VAR 0 4
58882: PUSH
58883: LD_EXP 131
58887: PUSH
58888: LD_VAR 0 2
58892: ARRAY
58893: PPUSH
58894: LD_INT 25
58896: PUSH
58897: LD_INT 16
58899: PUSH
58900: EMPTY
58901: LIST
58902: LIST
58903: PPUSH
58904: CALL_OW 72
58908: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58909: LD_VAR 0 4
58913: PUSH
58914: LD_INT 6
58916: GREATEREQUAL
58917: PUSH
58918: LD_VAR 0 5
58922: PPUSH
58923: LD_INT 2
58925: PPUSH
58926: CALL_OW 325
58930: NOT
58931: OR
58932: IFFALSE 59135
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58934: LD_ADDR_VAR 0 8
58938: PUSH
58939: LD_EXP 102
58943: PUSH
58944: LD_VAR 0 2
58948: ARRAY
58949: PPUSH
58950: LD_INT 2
58952: PUSH
58953: LD_INT 30
58955: PUSH
58956: LD_INT 4
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: PUSH
58963: LD_INT 30
58965: PUSH
58966: LD_INT 5
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PUSH
58973: EMPTY
58974: LIST
58975: LIST
58976: LIST
58977: PPUSH
58978: CALL_OW 72
58982: ST_TO_ADDR
// if barracks then
58983: LD_VAR 0 8
58987: IFFALSE 59135
// begin selected := 0 ;
58989: LD_ADDR_VAR 0 7
58993: PUSH
58994: LD_INT 0
58996: ST_TO_ADDR
// for j in barracks do
58997: LD_ADDR_VAR 0 3
59001: PUSH
59002: LD_VAR 0 8
59006: PUSH
59007: FOR_IN
59008: IFFALSE 59039
// begin if UnitsInside ( j ) < 6 then
59010: LD_VAR 0 3
59014: PPUSH
59015: CALL_OW 313
59019: PUSH
59020: LD_INT 6
59022: LESS
59023: IFFALSE 59037
// begin selected := j ;
59025: LD_ADDR_VAR 0 7
59029: PUSH
59030: LD_VAR 0 3
59034: ST_TO_ADDR
// break ;
59035: GO 59039
// end ; end ;
59037: GO 59007
59039: POP
59040: POP
// if selected then
59041: LD_VAR 0 7
59045: IFFALSE 59135
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59047: LD_ADDR_VAR 0 3
59051: PUSH
59052: LD_EXP 131
59056: PUSH
59057: LD_VAR 0 2
59061: ARRAY
59062: PPUSH
59063: LD_INT 25
59065: PUSH
59066: LD_INT 12
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PPUSH
59073: CALL_OW 72
59077: PUSH
59078: FOR_IN
59079: IFFALSE 59133
// if not IsInUnit ( j ) and not HasTask ( j ) then
59081: LD_VAR 0 3
59085: PPUSH
59086: CALL_OW 310
59090: NOT
59091: PUSH
59092: LD_VAR 0 3
59096: PPUSH
59097: CALL_OW 314
59101: NOT
59102: AND
59103: IFFALSE 59131
// begin ComEnterUnit ( j , selected ) ;
59105: LD_VAR 0 3
59109: PPUSH
59110: LD_VAR 0 7
59114: PPUSH
59115: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59119: LD_VAR 0 3
59123: PPUSH
59124: LD_INT 15
59126: PPUSH
59127: CALL_OW 183
// end ;
59131: GO 59078
59133: POP
59134: POP
// end ; end ; end ; end ; end ;
59135: GO 58528
59137: POP
59138: POP
// end ;
59139: LD_VAR 0 1
59143: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59144: LD_INT 0
59146: PPUSH
59147: PPUSH
59148: PPUSH
59149: PPUSH
// if not mc_bases then
59150: LD_EXP 102
59154: NOT
59155: IFFALSE 59159
// exit ;
59157: GO 59337
// for i = 1 to mc_bases do
59159: LD_ADDR_VAR 0 2
59163: PUSH
59164: DOUBLE
59165: LD_INT 1
59167: DEC
59168: ST_TO_ADDR
59169: LD_EXP 102
59173: PUSH
59174: FOR_TO
59175: IFFALSE 59335
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59177: LD_ADDR_VAR 0 4
59181: PUSH
59182: LD_EXP 102
59186: PUSH
59187: LD_VAR 0 2
59191: ARRAY
59192: PPUSH
59193: LD_INT 25
59195: PUSH
59196: LD_INT 9
59198: PUSH
59199: EMPTY
59200: LIST
59201: LIST
59202: PPUSH
59203: CALL_OW 72
59207: ST_TO_ADDR
// if not tmp then
59208: LD_VAR 0 4
59212: NOT
59213: IFFALSE 59217
// continue ;
59215: GO 59174
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59217: LD_EXP 128
59221: PUSH
59222: LD_VAR 0 2
59226: ARRAY
59227: PPUSH
59228: LD_INT 29
59230: PPUSH
59231: CALL_OW 325
59235: NOT
59236: PUSH
59237: LD_EXP 128
59241: PUSH
59242: LD_VAR 0 2
59246: ARRAY
59247: PPUSH
59248: LD_INT 28
59250: PPUSH
59251: CALL_OW 325
59255: NOT
59256: AND
59257: IFFALSE 59261
// continue ;
59259: GO 59174
// for j in tmp do
59261: LD_ADDR_VAR 0 3
59265: PUSH
59266: LD_VAR 0 4
59270: PUSH
59271: FOR_IN
59272: IFFALSE 59331
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59274: LD_VAR 0 3
59278: PUSH
59279: LD_EXP 105
59283: PUSH
59284: LD_VAR 0 2
59288: ARRAY
59289: PUSH
59290: LD_INT 1
59292: ARRAY
59293: IN
59294: NOT
59295: PUSH
59296: LD_VAR 0 3
59300: PUSH
59301: LD_EXP 105
59305: PUSH
59306: LD_VAR 0 2
59310: ARRAY
59311: PUSH
59312: LD_INT 2
59314: ARRAY
59315: IN
59316: NOT
59317: AND
59318: IFFALSE 59329
// ComSpaceTimeShoot ( j ) ;
59320: LD_VAR 0 3
59324: PPUSH
59325: CALL 70538 0 1
59329: GO 59271
59331: POP
59332: POP
// end ;
59333: GO 59174
59335: POP
59336: POP
// end ;
59337: LD_VAR 0 1
59341: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59342: LD_INT 0
59344: PPUSH
59345: PPUSH
59346: PPUSH
59347: PPUSH
59348: PPUSH
59349: PPUSH
59350: PPUSH
59351: PPUSH
59352: PPUSH
// if not mc_bases then
59353: LD_EXP 102
59357: NOT
59358: IFFALSE 59362
// exit ;
59360: GO 59984
// for i = 1 to mc_bases do
59362: LD_ADDR_VAR 0 2
59366: PUSH
59367: DOUBLE
59368: LD_INT 1
59370: DEC
59371: ST_TO_ADDR
59372: LD_EXP 102
59376: PUSH
59377: FOR_TO
59378: IFFALSE 59982
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59380: LD_EXP 137
59384: PUSH
59385: LD_VAR 0 2
59389: ARRAY
59390: NOT
59391: PUSH
59392: LD_INT 38
59394: PPUSH
59395: LD_EXP 128
59399: PUSH
59400: LD_VAR 0 2
59404: ARRAY
59405: PPUSH
59406: CALL_OW 321
59410: PUSH
59411: LD_INT 2
59413: NONEQUAL
59414: OR
59415: IFFALSE 59419
// continue ;
59417: GO 59377
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59419: LD_ADDR_VAR 0 8
59423: PUSH
59424: LD_EXP 102
59428: PUSH
59429: LD_VAR 0 2
59433: ARRAY
59434: PPUSH
59435: LD_INT 30
59437: PUSH
59438: LD_INT 34
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PPUSH
59445: CALL_OW 72
59449: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59450: LD_ADDR_VAR 0 9
59454: PUSH
59455: LD_EXP 102
59459: PUSH
59460: LD_VAR 0 2
59464: ARRAY
59465: PPUSH
59466: LD_INT 25
59468: PUSH
59469: LD_INT 4
59471: PUSH
59472: EMPTY
59473: LIST
59474: LIST
59475: PPUSH
59476: CALL_OW 72
59480: PPUSH
59481: LD_INT 0
59483: PPUSH
59484: CALL 104851 0 2
59488: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59489: LD_VAR 0 9
59493: NOT
59494: PUSH
59495: LD_VAR 0 8
59499: NOT
59500: OR
59501: PUSH
59502: LD_EXP 102
59506: PUSH
59507: LD_VAR 0 2
59511: ARRAY
59512: PPUSH
59513: LD_INT 124
59515: PPUSH
59516: CALL 104851 0 2
59520: OR
59521: IFFALSE 59525
// continue ;
59523: GO 59377
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59525: LD_EXP 138
59529: PUSH
59530: LD_VAR 0 2
59534: ARRAY
59535: PUSH
59536: LD_EXP 137
59540: PUSH
59541: LD_VAR 0 2
59545: ARRAY
59546: LESS
59547: PUSH
59548: LD_EXP 138
59552: PUSH
59553: LD_VAR 0 2
59557: ARRAY
59558: PUSH
59559: LD_VAR 0 8
59563: LESS
59564: AND
59565: IFFALSE 59980
// begin tmp := sci [ 1 ] ;
59567: LD_ADDR_VAR 0 7
59571: PUSH
59572: LD_VAR 0 9
59576: PUSH
59577: LD_INT 1
59579: ARRAY
59580: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59581: LD_VAR 0 7
59585: PPUSH
59586: LD_INT 124
59588: PPUSH
59589: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59593: LD_ADDR_VAR 0 3
59597: PUSH
59598: DOUBLE
59599: LD_EXP 137
59603: PUSH
59604: LD_VAR 0 2
59608: ARRAY
59609: INC
59610: ST_TO_ADDR
59611: LD_EXP 137
59615: PUSH
59616: LD_VAR 0 2
59620: ARRAY
59621: PUSH
59622: FOR_DOWNTO
59623: IFFALSE 59966
// begin if IsInUnit ( tmp ) then
59625: LD_VAR 0 7
59629: PPUSH
59630: CALL_OW 310
59634: IFFALSE 59645
// ComExitBuilding ( tmp ) ;
59636: LD_VAR 0 7
59640: PPUSH
59641: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59645: LD_INT 35
59647: PPUSH
59648: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59652: LD_VAR 0 7
59656: PPUSH
59657: CALL_OW 310
59661: NOT
59662: PUSH
59663: LD_VAR 0 7
59667: PPUSH
59668: CALL_OW 314
59672: NOT
59673: AND
59674: IFFALSE 59645
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59676: LD_ADDR_VAR 0 6
59680: PUSH
59681: LD_VAR 0 7
59685: PPUSH
59686: CALL_OW 250
59690: PUSH
59691: LD_VAR 0 7
59695: PPUSH
59696: CALL_OW 251
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59705: LD_INT 35
59707: PPUSH
59708: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59712: LD_ADDR_VAR 0 4
59716: PUSH
59717: LD_EXP 137
59721: PUSH
59722: LD_VAR 0 2
59726: ARRAY
59727: PUSH
59728: LD_VAR 0 3
59732: ARRAY
59733: PUSH
59734: LD_INT 1
59736: ARRAY
59737: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59738: LD_ADDR_VAR 0 5
59742: PUSH
59743: LD_EXP 137
59747: PUSH
59748: LD_VAR 0 2
59752: ARRAY
59753: PUSH
59754: LD_VAR 0 3
59758: ARRAY
59759: PUSH
59760: LD_INT 2
59762: ARRAY
59763: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59764: LD_VAR 0 7
59768: PPUSH
59769: LD_INT 10
59771: PPUSH
59772: CALL 77518 0 2
59776: PUSH
59777: LD_INT 4
59779: ARRAY
59780: IFFALSE 59818
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59782: LD_VAR 0 7
59786: PPUSH
59787: LD_VAR 0 6
59791: PUSH
59792: LD_INT 1
59794: ARRAY
59795: PPUSH
59796: LD_VAR 0 6
59800: PUSH
59801: LD_INT 2
59803: ARRAY
59804: PPUSH
59805: CALL_OW 111
// wait ( 0 0$10 ) ;
59809: LD_INT 350
59811: PPUSH
59812: CALL_OW 67
// end else
59816: GO 59844
// begin ComMoveXY ( tmp , x , y ) ;
59818: LD_VAR 0 7
59822: PPUSH
59823: LD_VAR 0 4
59827: PPUSH
59828: LD_VAR 0 5
59832: PPUSH
59833: CALL_OW 111
// wait ( 0 0$3 ) ;
59837: LD_INT 105
59839: PPUSH
59840: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59844: LD_VAR 0 7
59848: PPUSH
59849: LD_VAR 0 4
59853: PPUSH
59854: LD_VAR 0 5
59858: PPUSH
59859: CALL_OW 307
59863: IFFALSE 59705
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59865: LD_VAR 0 7
59869: PPUSH
59870: LD_VAR 0 4
59874: PPUSH
59875: LD_VAR 0 5
59879: PPUSH
59880: LD_VAR 0 8
59884: PUSH
59885: LD_VAR 0 3
59889: ARRAY
59890: PPUSH
59891: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59895: LD_INT 35
59897: PPUSH
59898: CALL_OW 67
// until not HasTask ( tmp ) ;
59902: LD_VAR 0 7
59906: PPUSH
59907: CALL_OW 314
59911: NOT
59912: IFFALSE 59895
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59914: LD_ADDR_EXP 138
59918: PUSH
59919: LD_EXP 138
59923: PPUSH
59924: LD_VAR 0 2
59928: PUSH
59929: LD_EXP 138
59933: PUSH
59934: LD_VAR 0 2
59938: ARRAY
59939: PUSH
59940: LD_INT 1
59942: PLUS
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PPUSH
59948: LD_VAR 0 8
59952: PUSH
59953: LD_VAR 0 3
59957: ARRAY
59958: PPUSH
59959: CALL 74553 0 3
59963: ST_TO_ADDR
// end ;
59964: GO 59622
59966: POP
59967: POP
// MC_Reset ( i , 124 ) ;
59968: LD_VAR 0 2
59972: PPUSH
59973: LD_INT 124
59975: PPUSH
59976: CALL 43052 0 2
// end ; end ;
59980: GO 59377
59982: POP
59983: POP
// end ;
59984: LD_VAR 0 1
59988: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59989: LD_INT 0
59991: PPUSH
59992: PPUSH
59993: PPUSH
// if not mc_bases then
59994: LD_EXP 102
59998: NOT
59999: IFFALSE 60003
// exit ;
60001: GO 60609
// for i = 1 to mc_bases do
60003: LD_ADDR_VAR 0 2
60007: PUSH
60008: DOUBLE
60009: LD_INT 1
60011: DEC
60012: ST_TO_ADDR
60013: LD_EXP 102
60017: PUSH
60018: FOR_TO
60019: IFFALSE 60607
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60021: LD_ADDR_VAR 0 3
60025: PUSH
60026: LD_EXP 102
60030: PUSH
60031: LD_VAR 0 2
60035: ARRAY
60036: PPUSH
60037: LD_INT 25
60039: PUSH
60040: LD_INT 4
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: PPUSH
60047: CALL_OW 72
60051: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60052: LD_VAR 0 3
60056: NOT
60057: PUSH
60058: LD_EXP 139
60062: PUSH
60063: LD_VAR 0 2
60067: ARRAY
60068: NOT
60069: OR
60070: PUSH
60071: LD_EXP 102
60075: PUSH
60076: LD_VAR 0 2
60080: ARRAY
60081: PPUSH
60082: LD_INT 2
60084: PUSH
60085: LD_INT 30
60087: PUSH
60088: LD_INT 0
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: PUSH
60095: LD_INT 30
60097: PUSH
60098: LD_INT 1
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PUSH
60105: EMPTY
60106: LIST
60107: LIST
60108: LIST
60109: PPUSH
60110: CALL_OW 72
60114: NOT
60115: OR
60116: IFFALSE 60166
// begin if mc_deposits_finder [ i ] then
60118: LD_EXP 140
60122: PUSH
60123: LD_VAR 0 2
60127: ARRAY
60128: IFFALSE 60164
// begin MC_Reset ( i , 125 ) ;
60130: LD_VAR 0 2
60134: PPUSH
60135: LD_INT 125
60137: PPUSH
60138: CALL 43052 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60142: LD_ADDR_EXP 140
60146: PUSH
60147: LD_EXP 140
60151: PPUSH
60152: LD_VAR 0 2
60156: PPUSH
60157: EMPTY
60158: PPUSH
60159: CALL_OW 1
60163: ST_TO_ADDR
// end ; continue ;
60164: GO 60018
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60166: LD_EXP 139
60170: PUSH
60171: LD_VAR 0 2
60175: ARRAY
60176: PUSH
60177: LD_INT 1
60179: ARRAY
60180: PUSH
60181: LD_INT 3
60183: ARRAY
60184: PUSH
60185: LD_INT 1
60187: EQUAL
60188: PUSH
60189: LD_INT 20
60191: PPUSH
60192: LD_EXP 128
60196: PUSH
60197: LD_VAR 0 2
60201: ARRAY
60202: PPUSH
60203: CALL_OW 321
60207: PUSH
60208: LD_INT 2
60210: NONEQUAL
60211: AND
60212: IFFALSE 60262
// begin if mc_deposits_finder [ i ] then
60214: LD_EXP 140
60218: PUSH
60219: LD_VAR 0 2
60223: ARRAY
60224: IFFALSE 60260
// begin MC_Reset ( i , 125 ) ;
60226: LD_VAR 0 2
60230: PPUSH
60231: LD_INT 125
60233: PPUSH
60234: CALL 43052 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60238: LD_ADDR_EXP 140
60242: PUSH
60243: LD_EXP 140
60247: PPUSH
60248: LD_VAR 0 2
60252: PPUSH
60253: EMPTY
60254: PPUSH
60255: CALL_OW 1
60259: ST_TO_ADDR
// end ; continue ;
60260: GO 60018
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60262: LD_EXP 139
60266: PUSH
60267: LD_VAR 0 2
60271: ARRAY
60272: PUSH
60273: LD_INT 1
60275: ARRAY
60276: PUSH
60277: LD_INT 1
60279: ARRAY
60280: PPUSH
60281: LD_EXP 139
60285: PUSH
60286: LD_VAR 0 2
60290: ARRAY
60291: PUSH
60292: LD_INT 1
60294: ARRAY
60295: PUSH
60296: LD_INT 2
60298: ARRAY
60299: PPUSH
60300: LD_EXP 128
60304: PUSH
60305: LD_VAR 0 2
60309: ARRAY
60310: PPUSH
60311: CALL_OW 440
60315: IFFALSE 60358
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60317: LD_ADDR_EXP 139
60321: PUSH
60322: LD_EXP 139
60326: PPUSH
60327: LD_VAR 0 2
60331: PPUSH
60332: LD_EXP 139
60336: PUSH
60337: LD_VAR 0 2
60341: ARRAY
60342: PPUSH
60343: LD_INT 1
60345: PPUSH
60346: CALL_OW 3
60350: PPUSH
60351: CALL_OW 1
60355: ST_TO_ADDR
60356: GO 60605
// begin if not mc_deposits_finder [ i ] then
60358: LD_EXP 140
60362: PUSH
60363: LD_VAR 0 2
60367: ARRAY
60368: NOT
60369: IFFALSE 60421
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60371: LD_ADDR_EXP 140
60375: PUSH
60376: LD_EXP 140
60380: PPUSH
60381: LD_VAR 0 2
60385: PPUSH
60386: LD_VAR 0 3
60390: PUSH
60391: LD_INT 1
60393: ARRAY
60394: PUSH
60395: EMPTY
60396: LIST
60397: PPUSH
60398: CALL_OW 1
60402: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60403: LD_VAR 0 3
60407: PUSH
60408: LD_INT 1
60410: ARRAY
60411: PPUSH
60412: LD_INT 125
60414: PPUSH
60415: CALL_OW 109
// end else
60419: GO 60605
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60421: LD_EXP 140
60425: PUSH
60426: LD_VAR 0 2
60430: ARRAY
60431: PUSH
60432: LD_INT 1
60434: ARRAY
60435: PPUSH
60436: CALL_OW 310
60440: IFFALSE 60463
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60442: LD_EXP 140
60446: PUSH
60447: LD_VAR 0 2
60451: ARRAY
60452: PUSH
60453: LD_INT 1
60455: ARRAY
60456: PPUSH
60457: CALL_OW 122
60461: GO 60605
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60463: LD_EXP 140
60467: PUSH
60468: LD_VAR 0 2
60472: ARRAY
60473: PUSH
60474: LD_INT 1
60476: ARRAY
60477: PPUSH
60478: CALL_OW 314
60482: NOT
60483: PUSH
60484: LD_EXP 140
60488: PUSH
60489: LD_VAR 0 2
60493: ARRAY
60494: PUSH
60495: LD_INT 1
60497: ARRAY
60498: PPUSH
60499: LD_EXP 139
60503: PUSH
60504: LD_VAR 0 2
60508: ARRAY
60509: PUSH
60510: LD_INT 1
60512: ARRAY
60513: PUSH
60514: LD_INT 1
60516: ARRAY
60517: PPUSH
60518: LD_EXP 139
60522: PUSH
60523: LD_VAR 0 2
60527: ARRAY
60528: PUSH
60529: LD_INT 1
60531: ARRAY
60532: PUSH
60533: LD_INT 2
60535: ARRAY
60536: PPUSH
60537: CALL_OW 297
60541: PUSH
60542: LD_INT 6
60544: GREATER
60545: AND
60546: IFFALSE 60605
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60548: LD_EXP 140
60552: PUSH
60553: LD_VAR 0 2
60557: ARRAY
60558: PUSH
60559: LD_INT 1
60561: ARRAY
60562: PPUSH
60563: LD_EXP 139
60567: PUSH
60568: LD_VAR 0 2
60572: ARRAY
60573: PUSH
60574: LD_INT 1
60576: ARRAY
60577: PUSH
60578: LD_INT 1
60580: ARRAY
60581: PPUSH
60582: LD_EXP 139
60586: PUSH
60587: LD_VAR 0 2
60591: ARRAY
60592: PUSH
60593: LD_INT 1
60595: ARRAY
60596: PUSH
60597: LD_INT 2
60599: ARRAY
60600: PPUSH
60601: CALL_OW 111
// end ; end ; end ;
60605: GO 60018
60607: POP
60608: POP
// end ;
60609: LD_VAR 0 1
60613: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60614: LD_INT 0
60616: PPUSH
60617: PPUSH
60618: PPUSH
60619: PPUSH
60620: PPUSH
60621: PPUSH
60622: PPUSH
60623: PPUSH
60624: PPUSH
60625: PPUSH
60626: PPUSH
// if not mc_bases then
60627: LD_EXP 102
60631: NOT
60632: IFFALSE 60636
// exit ;
60634: GO 61576
// for i = 1 to mc_bases do
60636: LD_ADDR_VAR 0 2
60640: PUSH
60641: DOUBLE
60642: LD_INT 1
60644: DEC
60645: ST_TO_ADDR
60646: LD_EXP 102
60650: PUSH
60651: FOR_TO
60652: IFFALSE 61574
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60654: LD_EXP 102
60658: PUSH
60659: LD_VAR 0 2
60663: ARRAY
60664: NOT
60665: PUSH
60666: LD_EXP 125
60670: PUSH
60671: LD_VAR 0 2
60675: ARRAY
60676: OR
60677: IFFALSE 60681
// continue ;
60679: GO 60651
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60681: LD_ADDR_VAR 0 7
60685: PUSH
60686: LD_EXP 102
60690: PUSH
60691: LD_VAR 0 2
60695: ARRAY
60696: PUSH
60697: LD_INT 1
60699: ARRAY
60700: PPUSH
60701: CALL_OW 248
60705: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60706: LD_VAR 0 7
60710: PUSH
60711: LD_INT 3
60713: EQUAL
60714: PUSH
60715: LD_EXP 121
60719: PUSH
60720: LD_VAR 0 2
60724: ARRAY
60725: PUSH
60726: LD_EXP 124
60730: PUSH
60731: LD_VAR 0 2
60735: ARRAY
60736: UNION
60737: PPUSH
60738: LD_INT 33
60740: PUSH
60741: LD_INT 2
60743: PUSH
60744: EMPTY
60745: LIST
60746: LIST
60747: PPUSH
60748: CALL_OW 72
60752: NOT
60753: OR
60754: IFFALSE 60758
// continue ;
60756: GO 60651
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60758: LD_ADDR_VAR 0 9
60762: PUSH
60763: LD_EXP 102
60767: PUSH
60768: LD_VAR 0 2
60772: ARRAY
60773: PPUSH
60774: LD_INT 30
60776: PUSH
60777: LD_INT 36
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: PPUSH
60784: CALL_OW 72
60788: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60789: LD_ADDR_VAR 0 10
60793: PUSH
60794: LD_EXP 121
60798: PUSH
60799: LD_VAR 0 2
60803: ARRAY
60804: PPUSH
60805: LD_INT 34
60807: PUSH
60808: LD_INT 31
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PPUSH
60815: CALL_OW 72
60819: ST_TO_ADDR
// if not cts and not mcts then
60820: LD_VAR 0 9
60824: NOT
60825: PUSH
60826: LD_VAR 0 10
60830: NOT
60831: AND
60832: IFFALSE 60836
// continue ;
60834: GO 60651
// x := cts ;
60836: LD_ADDR_VAR 0 11
60840: PUSH
60841: LD_VAR 0 9
60845: ST_TO_ADDR
// if not x then
60846: LD_VAR 0 11
60850: NOT
60851: IFFALSE 60863
// x := mcts ;
60853: LD_ADDR_VAR 0 11
60857: PUSH
60858: LD_VAR 0 10
60862: ST_TO_ADDR
// if not x then
60863: LD_VAR 0 11
60867: NOT
60868: IFFALSE 60872
// continue ;
60870: GO 60651
// if mc_remote_driver [ i ] then
60872: LD_EXP 142
60876: PUSH
60877: LD_VAR 0 2
60881: ARRAY
60882: IFFALSE 61269
// for j in mc_remote_driver [ i ] do
60884: LD_ADDR_VAR 0 3
60888: PUSH
60889: LD_EXP 142
60893: PUSH
60894: LD_VAR 0 2
60898: ARRAY
60899: PUSH
60900: FOR_IN
60901: IFFALSE 61267
// begin if GetClass ( j ) <> 3 then
60903: LD_VAR 0 3
60907: PPUSH
60908: CALL_OW 257
60912: PUSH
60913: LD_INT 3
60915: NONEQUAL
60916: IFFALSE 60969
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60918: LD_ADDR_EXP 142
60922: PUSH
60923: LD_EXP 142
60927: PPUSH
60928: LD_VAR 0 2
60932: PPUSH
60933: LD_EXP 142
60937: PUSH
60938: LD_VAR 0 2
60942: ARRAY
60943: PUSH
60944: LD_VAR 0 3
60948: DIFF
60949: PPUSH
60950: CALL_OW 1
60954: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60955: LD_VAR 0 3
60959: PPUSH
60960: LD_INT 0
60962: PPUSH
60963: CALL_OW 109
// continue ;
60967: GO 60900
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60969: LD_EXP 121
60973: PUSH
60974: LD_VAR 0 2
60978: ARRAY
60979: PPUSH
60980: LD_INT 34
60982: PUSH
60983: LD_INT 31
60985: PUSH
60986: EMPTY
60987: LIST
60988: LIST
60989: PUSH
60990: LD_INT 58
60992: PUSH
60993: EMPTY
60994: LIST
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PPUSH
61000: CALL_OW 72
61004: PUSH
61005: LD_VAR 0 3
61009: PPUSH
61010: CALL 104886 0 1
61014: NOT
61015: AND
61016: IFFALSE 61087
// begin if IsInUnit ( j ) then
61018: LD_VAR 0 3
61022: PPUSH
61023: CALL_OW 310
61027: IFFALSE 61038
// ComExitBuilding ( j ) ;
61029: LD_VAR 0 3
61033: PPUSH
61034: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61038: LD_VAR 0 3
61042: PPUSH
61043: LD_EXP 121
61047: PUSH
61048: LD_VAR 0 2
61052: ARRAY
61053: PPUSH
61054: LD_INT 34
61056: PUSH
61057: LD_INT 31
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PUSH
61064: LD_INT 58
61066: PUSH
61067: EMPTY
61068: LIST
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PPUSH
61074: CALL_OW 72
61078: PUSH
61079: LD_INT 1
61081: ARRAY
61082: PPUSH
61083: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61087: LD_VAR 0 3
61091: PPUSH
61092: CALL_OW 310
61096: NOT
61097: PUSH
61098: LD_VAR 0 3
61102: PPUSH
61103: CALL_OW 310
61107: PPUSH
61108: CALL_OW 266
61112: PUSH
61113: LD_INT 36
61115: NONEQUAL
61116: PUSH
61117: LD_VAR 0 3
61121: PPUSH
61122: CALL 104886 0 1
61126: NOT
61127: AND
61128: OR
61129: IFFALSE 61265
// begin if IsInUnit ( j ) then
61131: LD_VAR 0 3
61135: PPUSH
61136: CALL_OW 310
61140: IFFALSE 61151
// ComExitBuilding ( j ) ;
61142: LD_VAR 0 3
61146: PPUSH
61147: CALL_OW 122
// ct := 0 ;
61151: LD_ADDR_VAR 0 8
61155: PUSH
61156: LD_INT 0
61158: ST_TO_ADDR
// for k in x do
61159: LD_ADDR_VAR 0 4
61163: PUSH
61164: LD_VAR 0 11
61168: PUSH
61169: FOR_IN
61170: IFFALSE 61243
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61172: LD_VAR 0 4
61176: PPUSH
61177: CALL_OW 264
61181: PUSH
61182: LD_INT 31
61184: EQUAL
61185: PUSH
61186: LD_VAR 0 4
61190: PPUSH
61191: CALL_OW 311
61195: NOT
61196: AND
61197: PUSH
61198: LD_VAR 0 4
61202: PPUSH
61203: CALL_OW 266
61207: PUSH
61208: LD_INT 36
61210: EQUAL
61211: PUSH
61212: LD_VAR 0 4
61216: PPUSH
61217: CALL_OW 313
61221: PUSH
61222: LD_INT 3
61224: LESS
61225: AND
61226: OR
61227: IFFALSE 61241
// begin ct := k ;
61229: LD_ADDR_VAR 0 8
61233: PUSH
61234: LD_VAR 0 4
61238: ST_TO_ADDR
// break ;
61239: GO 61243
// end ;
61241: GO 61169
61243: POP
61244: POP
// if ct then
61245: LD_VAR 0 8
61249: IFFALSE 61265
// ComEnterUnit ( j , ct ) ;
61251: LD_VAR 0 3
61255: PPUSH
61256: LD_VAR 0 8
61260: PPUSH
61261: CALL_OW 120
// end ; end ;
61265: GO 60900
61267: POP
61268: POP
// places := 0 ;
61269: LD_ADDR_VAR 0 5
61273: PUSH
61274: LD_INT 0
61276: ST_TO_ADDR
// for j = 1 to x do
61277: LD_ADDR_VAR 0 3
61281: PUSH
61282: DOUBLE
61283: LD_INT 1
61285: DEC
61286: ST_TO_ADDR
61287: LD_VAR 0 11
61291: PUSH
61292: FOR_TO
61293: IFFALSE 61369
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61295: LD_VAR 0 11
61299: PUSH
61300: LD_VAR 0 3
61304: ARRAY
61305: PPUSH
61306: CALL_OW 264
61310: PUSH
61311: LD_INT 31
61313: EQUAL
61314: IFFALSE 61332
// places := places + 1 else
61316: LD_ADDR_VAR 0 5
61320: PUSH
61321: LD_VAR 0 5
61325: PUSH
61326: LD_INT 1
61328: PLUS
61329: ST_TO_ADDR
61330: GO 61367
// if GetBType ( x [ j ] ) = b_control_tower then
61332: LD_VAR 0 11
61336: PUSH
61337: LD_VAR 0 3
61341: ARRAY
61342: PPUSH
61343: CALL_OW 266
61347: PUSH
61348: LD_INT 36
61350: EQUAL
61351: IFFALSE 61367
// places := places + 3 ;
61353: LD_ADDR_VAR 0 5
61357: PUSH
61358: LD_VAR 0 5
61362: PUSH
61363: LD_INT 3
61365: PLUS
61366: ST_TO_ADDR
61367: GO 61292
61369: POP
61370: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61371: LD_VAR 0 5
61375: PUSH
61376: LD_INT 0
61378: EQUAL
61379: PUSH
61380: LD_VAR 0 5
61384: PUSH
61385: LD_EXP 142
61389: PUSH
61390: LD_VAR 0 2
61394: ARRAY
61395: LESSEQUAL
61396: OR
61397: IFFALSE 61401
// continue ;
61399: GO 60651
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61401: LD_ADDR_VAR 0 6
61405: PUSH
61406: LD_EXP 102
61410: PUSH
61411: LD_VAR 0 2
61415: ARRAY
61416: PPUSH
61417: LD_INT 25
61419: PUSH
61420: LD_INT 3
61422: PUSH
61423: EMPTY
61424: LIST
61425: LIST
61426: PPUSH
61427: CALL_OW 72
61431: PUSH
61432: LD_EXP 142
61436: PUSH
61437: LD_VAR 0 2
61441: ARRAY
61442: DIFF
61443: PPUSH
61444: LD_INT 3
61446: PPUSH
61447: CALL 105786 0 2
61451: ST_TO_ADDR
// for j in tmp do
61452: LD_ADDR_VAR 0 3
61456: PUSH
61457: LD_VAR 0 6
61461: PUSH
61462: FOR_IN
61463: IFFALSE 61498
// if GetTag ( j ) > 0 then
61465: LD_VAR 0 3
61469: PPUSH
61470: CALL_OW 110
61474: PUSH
61475: LD_INT 0
61477: GREATER
61478: IFFALSE 61496
// tmp := tmp diff j ;
61480: LD_ADDR_VAR 0 6
61484: PUSH
61485: LD_VAR 0 6
61489: PUSH
61490: LD_VAR 0 3
61494: DIFF
61495: ST_TO_ADDR
61496: GO 61462
61498: POP
61499: POP
// if not tmp then
61500: LD_VAR 0 6
61504: NOT
61505: IFFALSE 61509
// continue ;
61507: GO 60651
// if places then
61509: LD_VAR 0 5
61513: IFFALSE 61572
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61515: LD_ADDR_EXP 142
61519: PUSH
61520: LD_EXP 142
61524: PPUSH
61525: LD_VAR 0 2
61529: PPUSH
61530: LD_EXP 142
61534: PUSH
61535: LD_VAR 0 2
61539: ARRAY
61540: PUSH
61541: LD_VAR 0 6
61545: PUSH
61546: LD_INT 1
61548: ARRAY
61549: UNION
61550: PPUSH
61551: CALL_OW 1
61555: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61556: LD_VAR 0 6
61560: PUSH
61561: LD_INT 1
61563: ARRAY
61564: PPUSH
61565: LD_INT 126
61567: PPUSH
61568: CALL_OW 109
// end ; end ;
61572: GO 60651
61574: POP
61575: POP
// end ;
61576: LD_VAR 0 1
61580: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61581: LD_INT 0
61583: PPUSH
61584: PPUSH
61585: PPUSH
61586: PPUSH
61587: PPUSH
61588: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61589: LD_VAR 0 1
61593: NOT
61594: PUSH
61595: LD_VAR 0 2
61599: NOT
61600: OR
61601: PUSH
61602: LD_VAR 0 3
61606: NOT
61607: OR
61608: PUSH
61609: LD_VAR 0 4
61613: PUSH
61614: LD_INT 1
61616: PUSH
61617: LD_INT 2
61619: PUSH
61620: LD_INT 3
61622: PUSH
61623: LD_INT 4
61625: PUSH
61626: LD_INT 5
61628: PUSH
61629: LD_INT 8
61631: PUSH
61632: LD_INT 9
61634: PUSH
61635: LD_INT 15
61637: PUSH
61638: LD_INT 16
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: LIST
61645: LIST
61646: LIST
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: IN
61652: NOT
61653: OR
61654: IFFALSE 61658
// exit ;
61656: GO 62516
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61658: LD_ADDR_VAR 0 2
61662: PUSH
61663: LD_VAR 0 2
61667: PPUSH
61668: LD_INT 21
61670: PUSH
61671: LD_INT 3
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PUSH
61678: LD_INT 24
61680: PUSH
61681: LD_INT 250
61683: PUSH
61684: EMPTY
61685: LIST
61686: LIST
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: CALL_OW 72
61696: ST_TO_ADDR
// case class of 1 , 15 :
61697: LD_VAR 0 4
61701: PUSH
61702: LD_INT 1
61704: DOUBLE
61705: EQUAL
61706: IFTRUE 61716
61708: LD_INT 15
61710: DOUBLE
61711: EQUAL
61712: IFTRUE 61716
61714: GO 61801
61716: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61717: LD_ADDR_VAR 0 8
61721: PUSH
61722: LD_VAR 0 2
61726: PPUSH
61727: LD_INT 2
61729: PUSH
61730: LD_INT 30
61732: PUSH
61733: LD_INT 32
61735: PUSH
61736: EMPTY
61737: LIST
61738: LIST
61739: PUSH
61740: LD_INT 30
61742: PUSH
61743: LD_INT 31
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: LIST
61754: PPUSH
61755: CALL_OW 72
61759: PUSH
61760: LD_VAR 0 2
61764: PPUSH
61765: LD_INT 2
61767: PUSH
61768: LD_INT 30
61770: PUSH
61771: LD_INT 4
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 30
61780: PUSH
61781: LD_INT 5
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: LIST
61792: PPUSH
61793: CALL_OW 72
61797: ADD
61798: ST_TO_ADDR
61799: GO 62047
61801: LD_INT 2
61803: DOUBLE
61804: EQUAL
61805: IFTRUE 61815
61807: LD_INT 16
61809: DOUBLE
61810: EQUAL
61811: IFTRUE 61815
61813: GO 61861
61815: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61816: LD_ADDR_VAR 0 8
61820: PUSH
61821: LD_VAR 0 2
61825: PPUSH
61826: LD_INT 2
61828: PUSH
61829: LD_INT 30
61831: PUSH
61832: LD_INT 0
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: PUSH
61839: LD_INT 30
61841: PUSH
61842: LD_INT 1
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: LIST
61853: PPUSH
61854: CALL_OW 72
61858: ST_TO_ADDR
61859: GO 62047
61861: LD_INT 3
61863: DOUBLE
61864: EQUAL
61865: IFTRUE 61869
61867: GO 61915
61869: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61870: LD_ADDR_VAR 0 8
61874: PUSH
61875: LD_VAR 0 2
61879: PPUSH
61880: LD_INT 2
61882: PUSH
61883: LD_INT 30
61885: PUSH
61886: LD_INT 2
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: PUSH
61893: LD_INT 30
61895: PUSH
61896: LD_INT 3
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: LIST
61907: PPUSH
61908: CALL_OW 72
61912: ST_TO_ADDR
61913: GO 62047
61915: LD_INT 4
61917: DOUBLE
61918: EQUAL
61919: IFTRUE 61923
61921: GO 61980
61923: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61924: LD_ADDR_VAR 0 8
61928: PUSH
61929: LD_VAR 0 2
61933: PPUSH
61934: LD_INT 2
61936: PUSH
61937: LD_INT 30
61939: PUSH
61940: LD_INT 6
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: PUSH
61947: LD_INT 30
61949: PUSH
61950: LD_INT 7
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PUSH
61957: LD_INT 30
61959: PUSH
61960: LD_INT 8
61962: PUSH
61963: EMPTY
61964: LIST
61965: LIST
61966: PUSH
61967: EMPTY
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: PPUSH
61973: CALL_OW 72
61977: ST_TO_ADDR
61978: GO 62047
61980: LD_INT 5
61982: DOUBLE
61983: EQUAL
61984: IFTRUE 62000
61986: LD_INT 8
61988: DOUBLE
61989: EQUAL
61990: IFTRUE 62000
61992: LD_INT 9
61994: DOUBLE
61995: EQUAL
61996: IFTRUE 62000
61998: GO 62046
62000: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62001: LD_ADDR_VAR 0 8
62005: PUSH
62006: LD_VAR 0 2
62010: PPUSH
62011: LD_INT 2
62013: PUSH
62014: LD_INT 30
62016: PUSH
62017: LD_INT 4
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PUSH
62024: LD_INT 30
62026: PUSH
62027: LD_INT 5
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: LIST
62038: PPUSH
62039: CALL_OW 72
62043: ST_TO_ADDR
62044: GO 62047
62046: POP
// if not tmp then
62047: LD_VAR 0 8
62051: NOT
62052: IFFALSE 62056
// exit ;
62054: GO 62516
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62056: LD_VAR 0 4
62060: PUSH
62061: LD_INT 1
62063: PUSH
62064: LD_INT 15
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: IN
62071: PUSH
62072: LD_EXP 111
62076: PUSH
62077: LD_VAR 0 1
62081: ARRAY
62082: AND
62083: IFFALSE 62239
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62085: LD_ADDR_VAR 0 9
62089: PUSH
62090: LD_EXP 111
62094: PUSH
62095: LD_VAR 0 1
62099: ARRAY
62100: PUSH
62101: LD_INT 1
62103: ARRAY
62104: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62105: LD_VAR 0 9
62109: PUSH
62110: LD_EXP 112
62114: PUSH
62115: LD_VAR 0 1
62119: ARRAY
62120: IN
62121: NOT
62122: IFFALSE 62237
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62124: LD_ADDR_EXP 112
62128: PUSH
62129: LD_EXP 112
62133: PPUSH
62134: LD_VAR 0 1
62138: PUSH
62139: LD_EXP 112
62143: PUSH
62144: LD_VAR 0 1
62148: ARRAY
62149: PUSH
62150: LD_INT 1
62152: PLUS
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: PPUSH
62158: LD_VAR 0 9
62162: PPUSH
62163: CALL 74553 0 3
62167: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62168: LD_ADDR_EXP 111
62172: PUSH
62173: LD_EXP 111
62177: PPUSH
62178: LD_VAR 0 1
62182: PPUSH
62183: LD_EXP 111
62187: PUSH
62188: LD_VAR 0 1
62192: ARRAY
62193: PUSH
62194: LD_VAR 0 9
62198: DIFF
62199: PPUSH
62200: CALL_OW 1
62204: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62205: LD_VAR 0 3
62209: PPUSH
62210: LD_EXP 112
62214: PUSH
62215: LD_VAR 0 1
62219: ARRAY
62220: PUSH
62221: LD_EXP 112
62225: PUSH
62226: LD_VAR 0 1
62230: ARRAY
62231: ARRAY
62232: PPUSH
62233: CALL_OW 120
// end ; exit ;
62237: GO 62516
// end ; if tmp > 1 then
62239: LD_VAR 0 8
62243: PUSH
62244: LD_INT 1
62246: GREATER
62247: IFFALSE 62351
// for i = 2 to tmp do
62249: LD_ADDR_VAR 0 6
62253: PUSH
62254: DOUBLE
62255: LD_INT 2
62257: DEC
62258: ST_TO_ADDR
62259: LD_VAR 0 8
62263: PUSH
62264: FOR_TO
62265: IFFALSE 62349
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62267: LD_VAR 0 8
62271: PUSH
62272: LD_VAR 0 6
62276: ARRAY
62277: PPUSH
62278: CALL_OW 461
62282: PUSH
62283: LD_INT 6
62285: EQUAL
62286: IFFALSE 62347
// begin x := tmp [ i ] ;
62288: LD_ADDR_VAR 0 9
62292: PUSH
62293: LD_VAR 0 8
62297: PUSH
62298: LD_VAR 0 6
62302: ARRAY
62303: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62304: LD_ADDR_VAR 0 8
62308: PUSH
62309: LD_VAR 0 8
62313: PPUSH
62314: LD_VAR 0 6
62318: PPUSH
62319: CALL_OW 3
62323: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62324: LD_ADDR_VAR 0 8
62328: PUSH
62329: LD_VAR 0 8
62333: PPUSH
62334: LD_INT 1
62336: PPUSH
62337: LD_VAR 0 9
62341: PPUSH
62342: CALL_OW 2
62346: ST_TO_ADDR
// end ;
62347: GO 62264
62349: POP
62350: POP
// for i in tmp do
62351: LD_ADDR_VAR 0 6
62355: PUSH
62356: LD_VAR 0 8
62360: PUSH
62361: FOR_IN
62362: IFFALSE 62389
// begin if IsNotFull ( i ) then
62364: LD_VAR 0 6
62368: PPUSH
62369: CALL 71775 0 1
62373: IFFALSE 62387
// begin j := i ;
62375: LD_ADDR_VAR 0 7
62379: PUSH
62380: LD_VAR 0 6
62384: ST_TO_ADDR
// break ;
62385: GO 62389
// end ; end ;
62387: GO 62361
62389: POP
62390: POP
// if j then
62391: LD_VAR 0 7
62395: IFFALSE 62413
// ComEnterUnit ( unit , j ) else
62397: LD_VAR 0 3
62401: PPUSH
62402: LD_VAR 0 7
62406: PPUSH
62407: CALL_OW 120
62411: GO 62516
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62413: LD_ADDR_VAR 0 10
62417: PUSH
62418: LD_VAR 0 2
62422: PPUSH
62423: LD_INT 2
62425: PUSH
62426: LD_INT 30
62428: PUSH
62429: LD_INT 0
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: PUSH
62436: LD_INT 30
62438: PUSH
62439: LD_INT 1
62441: PUSH
62442: EMPTY
62443: LIST
62444: LIST
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: LIST
62450: PPUSH
62451: CALL_OW 72
62455: ST_TO_ADDR
// if depot then
62456: LD_VAR 0 10
62460: IFFALSE 62516
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62462: LD_ADDR_VAR 0 10
62466: PUSH
62467: LD_VAR 0 10
62471: PPUSH
62472: LD_VAR 0 3
62476: PPUSH
62477: CALL_OW 74
62481: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62482: LD_VAR 0 3
62486: PPUSH
62487: LD_VAR 0 10
62491: PPUSH
62492: CALL_OW 296
62496: PUSH
62497: LD_INT 10
62499: GREATER
62500: IFFALSE 62516
// ComStandNearbyBuilding ( unit , depot ) ;
62502: LD_VAR 0 3
62506: PPUSH
62507: LD_VAR 0 10
62511: PPUSH
62512: CALL 71155 0 2
// end ; end ; end ;
62516: LD_VAR 0 5
62520: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62521: LD_INT 0
62523: PPUSH
62524: PPUSH
62525: PPUSH
62526: PPUSH
// if not mc_bases then
62527: LD_EXP 102
62531: NOT
62532: IFFALSE 62536
// exit ;
62534: GO 62775
// for i = 1 to mc_bases do
62536: LD_ADDR_VAR 0 2
62540: PUSH
62541: DOUBLE
62542: LD_INT 1
62544: DEC
62545: ST_TO_ADDR
62546: LD_EXP 102
62550: PUSH
62551: FOR_TO
62552: IFFALSE 62773
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62554: LD_ADDR_VAR 0 4
62558: PUSH
62559: LD_EXP 102
62563: PUSH
62564: LD_VAR 0 2
62568: ARRAY
62569: PPUSH
62570: LD_INT 21
62572: PUSH
62573: LD_INT 1
62575: PUSH
62576: EMPTY
62577: LIST
62578: LIST
62579: PPUSH
62580: CALL_OW 72
62584: PUSH
62585: LD_EXP 131
62589: PUSH
62590: LD_VAR 0 2
62594: ARRAY
62595: UNION
62596: ST_TO_ADDR
// if not tmp then
62597: LD_VAR 0 4
62601: NOT
62602: IFFALSE 62606
// continue ;
62604: GO 62551
// for j in tmp do
62606: LD_ADDR_VAR 0 3
62610: PUSH
62611: LD_VAR 0 4
62615: PUSH
62616: FOR_IN
62617: IFFALSE 62769
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62619: LD_VAR 0 3
62623: PPUSH
62624: CALL_OW 110
62628: NOT
62629: PUSH
62630: LD_VAR 0 3
62634: PPUSH
62635: CALL_OW 314
62639: NOT
62640: AND
62641: PUSH
62642: LD_VAR 0 3
62646: PPUSH
62647: CALL_OW 311
62651: NOT
62652: AND
62653: PUSH
62654: LD_VAR 0 3
62658: PPUSH
62659: CALL_OW 310
62663: NOT
62664: AND
62665: PUSH
62666: LD_VAR 0 3
62670: PUSH
62671: LD_EXP 105
62675: PUSH
62676: LD_VAR 0 2
62680: ARRAY
62681: PUSH
62682: LD_INT 1
62684: ARRAY
62685: IN
62686: NOT
62687: AND
62688: PUSH
62689: LD_VAR 0 3
62693: PUSH
62694: LD_EXP 105
62698: PUSH
62699: LD_VAR 0 2
62703: ARRAY
62704: PUSH
62705: LD_INT 2
62707: ARRAY
62708: IN
62709: NOT
62710: AND
62711: PUSH
62712: LD_VAR 0 3
62716: PUSH
62717: LD_EXP 114
62721: PUSH
62722: LD_VAR 0 2
62726: ARRAY
62727: IN
62728: NOT
62729: AND
62730: IFFALSE 62767
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62732: LD_VAR 0 2
62736: PPUSH
62737: LD_EXP 102
62741: PUSH
62742: LD_VAR 0 2
62746: ARRAY
62747: PPUSH
62748: LD_VAR 0 3
62752: PPUSH
62753: LD_VAR 0 3
62757: PPUSH
62758: CALL_OW 257
62762: PPUSH
62763: CALL 61581 0 4
// end ;
62767: GO 62616
62769: POP
62770: POP
// end ;
62771: GO 62551
62773: POP
62774: POP
// end ;
62775: LD_VAR 0 1
62779: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62780: LD_INT 0
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
// if not mc_bases [ base ] then
62788: LD_EXP 102
62792: PUSH
62793: LD_VAR 0 1
62797: ARRAY
62798: NOT
62799: IFFALSE 62803
// exit ;
62801: GO 63004
// tmp := [ ] ;
62803: LD_ADDR_VAR 0 6
62807: PUSH
62808: EMPTY
62809: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62810: LD_ADDR_VAR 0 7
62814: PUSH
62815: LD_VAR 0 3
62819: PPUSH
62820: LD_INT 0
62822: PPUSH
62823: CALL_OW 517
62827: ST_TO_ADDR
// if not list then
62828: LD_VAR 0 7
62832: NOT
62833: IFFALSE 62837
// exit ;
62835: GO 63004
// c := Count ( list [ 1 ] ) ;
62837: LD_ADDR_VAR 0 9
62841: PUSH
62842: LD_VAR 0 7
62846: PUSH
62847: LD_INT 1
62849: ARRAY
62850: PPUSH
62851: CALL 71693 0 1
62855: ST_TO_ADDR
// if amount > c then
62856: LD_VAR 0 2
62860: PUSH
62861: LD_VAR 0 9
62865: GREATER
62866: IFFALSE 62878
// amount := c ;
62868: LD_ADDR_VAR 0 2
62872: PUSH
62873: LD_VAR 0 9
62877: ST_TO_ADDR
// for i := 1 to amount do
62878: LD_ADDR_VAR 0 5
62882: PUSH
62883: DOUBLE
62884: LD_INT 1
62886: DEC
62887: ST_TO_ADDR
62888: LD_VAR 0 2
62892: PUSH
62893: FOR_TO
62894: IFFALSE 62952
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62896: LD_ADDR_VAR 0 6
62900: PUSH
62901: LD_VAR 0 6
62905: PPUSH
62906: LD_VAR 0 5
62910: PPUSH
62911: LD_VAR 0 7
62915: PUSH
62916: LD_INT 1
62918: ARRAY
62919: PUSH
62920: LD_VAR 0 5
62924: ARRAY
62925: PUSH
62926: LD_VAR 0 7
62930: PUSH
62931: LD_INT 2
62933: ARRAY
62934: PUSH
62935: LD_VAR 0 5
62939: ARRAY
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: PPUSH
62945: CALL_OW 1
62949: ST_TO_ADDR
62950: GO 62893
62952: POP
62953: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62954: LD_ADDR_EXP 115
62958: PUSH
62959: LD_EXP 115
62963: PPUSH
62964: LD_VAR 0 1
62968: PPUSH
62969: LD_VAR 0 6
62973: PPUSH
62974: CALL_OW 1
62978: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62979: LD_ADDR_EXP 117
62983: PUSH
62984: LD_EXP 117
62988: PPUSH
62989: LD_VAR 0 1
62993: PPUSH
62994: LD_VAR 0 3
62998: PPUSH
62999: CALL_OW 1
63003: ST_TO_ADDR
// end ;
63004: LD_VAR 0 4
63008: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63009: LD_INT 0
63011: PPUSH
// if not mc_bases [ base ] then
63012: LD_EXP 102
63016: PUSH
63017: LD_VAR 0 1
63021: ARRAY
63022: NOT
63023: IFFALSE 63027
// exit ;
63025: GO 63052
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63027: LD_ADDR_EXP 107
63031: PUSH
63032: LD_EXP 107
63036: PPUSH
63037: LD_VAR 0 1
63041: PPUSH
63042: LD_VAR 0 2
63046: PPUSH
63047: CALL_OW 1
63051: ST_TO_ADDR
// end ;
63052: LD_VAR 0 3
63056: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63057: LD_INT 0
63059: PPUSH
// if not mc_bases [ base ] then
63060: LD_EXP 102
63064: PUSH
63065: LD_VAR 0 1
63069: ARRAY
63070: NOT
63071: IFFALSE 63075
// exit ;
63073: GO 63112
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63075: LD_ADDR_EXP 107
63079: PUSH
63080: LD_EXP 107
63084: PPUSH
63085: LD_VAR 0 1
63089: PPUSH
63090: LD_EXP 107
63094: PUSH
63095: LD_VAR 0 1
63099: ARRAY
63100: PUSH
63101: LD_VAR 0 2
63105: UNION
63106: PPUSH
63107: CALL_OW 1
63111: ST_TO_ADDR
// end ;
63112: LD_VAR 0 3
63116: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63117: LD_INT 0
63119: PPUSH
// if not mc_bases [ base ] then
63120: LD_EXP 102
63124: PUSH
63125: LD_VAR 0 1
63129: ARRAY
63130: NOT
63131: IFFALSE 63135
// exit ;
63133: GO 63160
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63135: LD_ADDR_EXP 123
63139: PUSH
63140: LD_EXP 123
63144: PPUSH
63145: LD_VAR 0 1
63149: PPUSH
63150: LD_VAR 0 2
63154: PPUSH
63155: CALL_OW 1
63159: ST_TO_ADDR
// end ;
63160: LD_VAR 0 3
63164: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63165: LD_INT 0
63167: PPUSH
// if not mc_bases [ base ] then
63168: LD_EXP 102
63172: PUSH
63173: LD_VAR 0 1
63177: ARRAY
63178: NOT
63179: IFFALSE 63183
// exit ;
63181: GO 63220
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63183: LD_ADDR_EXP 123
63187: PUSH
63188: LD_EXP 123
63192: PPUSH
63193: LD_VAR 0 1
63197: PPUSH
63198: LD_EXP 123
63202: PUSH
63203: LD_VAR 0 1
63207: ARRAY
63208: PUSH
63209: LD_VAR 0 2
63213: ADD
63214: PPUSH
63215: CALL_OW 1
63219: ST_TO_ADDR
// end ;
63220: LD_VAR 0 3
63224: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63225: LD_INT 0
63227: PPUSH
// if not mc_bases [ base ] then
63228: LD_EXP 102
63232: PUSH
63233: LD_VAR 0 1
63237: ARRAY
63238: NOT
63239: IFFALSE 63243
// exit ;
63241: GO 63297
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63243: LD_ADDR_EXP 124
63247: PUSH
63248: LD_EXP 124
63252: PPUSH
63253: LD_VAR 0 1
63257: PPUSH
63258: LD_VAR 0 2
63262: PPUSH
63263: CALL_OW 1
63267: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63268: LD_ADDR_EXP 113
63272: PUSH
63273: LD_EXP 113
63277: PPUSH
63278: LD_VAR 0 1
63282: PPUSH
63283: LD_VAR 0 2
63287: PUSH
63288: LD_INT 0
63290: PLUS
63291: PPUSH
63292: CALL_OW 1
63296: ST_TO_ADDR
// end ;
63297: LD_VAR 0 3
63301: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63302: LD_INT 0
63304: PPUSH
// if not mc_bases [ base ] then
63305: LD_EXP 102
63309: PUSH
63310: LD_VAR 0 1
63314: ARRAY
63315: NOT
63316: IFFALSE 63320
// exit ;
63318: GO 63345
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63320: LD_ADDR_EXP 113
63324: PUSH
63325: LD_EXP 113
63329: PPUSH
63330: LD_VAR 0 1
63334: PPUSH
63335: LD_VAR 0 2
63339: PPUSH
63340: CALL_OW 1
63344: ST_TO_ADDR
// end ;
63345: LD_VAR 0 3
63349: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63350: LD_INT 0
63352: PPUSH
63353: PPUSH
63354: PPUSH
63355: PPUSH
// if not mc_bases [ base ] then
63356: LD_EXP 102
63360: PUSH
63361: LD_VAR 0 1
63365: ARRAY
63366: NOT
63367: IFFALSE 63371
// exit ;
63369: GO 63436
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63371: LD_ADDR_EXP 122
63375: PUSH
63376: LD_EXP 122
63380: PPUSH
63381: LD_VAR 0 1
63385: PUSH
63386: LD_EXP 122
63390: PUSH
63391: LD_VAR 0 1
63395: ARRAY
63396: PUSH
63397: LD_INT 1
63399: PLUS
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PPUSH
63405: LD_VAR 0 1
63409: PUSH
63410: LD_VAR 0 2
63414: PUSH
63415: LD_VAR 0 3
63419: PUSH
63420: LD_VAR 0 4
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: PPUSH
63431: CALL 74553 0 3
63435: ST_TO_ADDR
// end ;
63436: LD_VAR 0 5
63440: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63441: LD_INT 0
63443: PPUSH
// if not mc_bases [ base ] then
63444: LD_EXP 102
63448: PUSH
63449: LD_VAR 0 1
63453: ARRAY
63454: NOT
63455: IFFALSE 63459
// exit ;
63457: GO 63484
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63459: LD_ADDR_EXP 139
63463: PUSH
63464: LD_EXP 139
63468: PPUSH
63469: LD_VAR 0 1
63473: PPUSH
63474: LD_VAR 0 2
63478: PPUSH
63479: CALL_OW 1
63483: ST_TO_ADDR
// end ;
63484: LD_VAR 0 3
63488: RET
// export function MC_GetMinesField ( base ) ; begin
63489: LD_INT 0
63491: PPUSH
// result := mc_mines [ base ] ;
63492: LD_ADDR_VAR 0 2
63496: PUSH
63497: LD_EXP 115
63501: PUSH
63502: LD_VAR 0 1
63506: ARRAY
63507: ST_TO_ADDR
// end ;
63508: LD_VAR 0 2
63512: RET
// export function MC_GetProduceList ( base ) ; begin
63513: LD_INT 0
63515: PPUSH
// result := mc_produce [ base ] ;
63516: LD_ADDR_VAR 0 2
63520: PUSH
63521: LD_EXP 123
63525: PUSH
63526: LD_VAR 0 1
63530: ARRAY
63531: ST_TO_ADDR
// end ;
63532: LD_VAR 0 2
63536: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63537: LD_INT 0
63539: PPUSH
63540: PPUSH
// if not mc_bases then
63541: LD_EXP 102
63545: NOT
63546: IFFALSE 63550
// exit ;
63548: GO 63615
// if mc_bases [ base ] then
63550: LD_EXP 102
63554: PUSH
63555: LD_VAR 0 1
63559: ARRAY
63560: IFFALSE 63615
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63562: LD_ADDR_VAR 0 3
63566: PUSH
63567: LD_EXP 102
63571: PUSH
63572: LD_VAR 0 1
63576: ARRAY
63577: PPUSH
63578: LD_INT 30
63580: PUSH
63581: LD_VAR 0 2
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: PPUSH
63590: CALL_OW 72
63594: ST_TO_ADDR
// if result then
63595: LD_VAR 0 3
63599: IFFALSE 63615
// result := result [ 1 ] ;
63601: LD_ADDR_VAR 0 3
63605: PUSH
63606: LD_VAR 0 3
63610: PUSH
63611: LD_INT 1
63613: ARRAY
63614: ST_TO_ADDR
// end ; end ;
63615: LD_VAR 0 3
63619: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63620: LD_INT 0
63622: PPUSH
63623: PPUSH
// if not mc_bases then
63624: LD_EXP 102
63628: NOT
63629: IFFALSE 63633
// exit ;
63631: GO 63678
// if mc_bases [ base ] then
63633: LD_EXP 102
63637: PUSH
63638: LD_VAR 0 1
63642: ARRAY
63643: IFFALSE 63678
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63645: LD_ADDR_VAR 0 3
63649: PUSH
63650: LD_EXP 102
63654: PUSH
63655: LD_VAR 0 1
63659: ARRAY
63660: PPUSH
63661: LD_INT 30
63663: PUSH
63664: LD_VAR 0 2
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PPUSH
63673: CALL_OW 72
63677: ST_TO_ADDR
// end ;
63678: LD_VAR 0 3
63682: RET
// export function MC_SetTame ( base , area ) ; begin
63683: LD_INT 0
63685: PPUSH
// if not mc_bases or not base then
63686: LD_EXP 102
63690: NOT
63691: PUSH
63692: LD_VAR 0 1
63696: NOT
63697: OR
63698: IFFALSE 63702
// exit ;
63700: GO 63727
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63702: LD_ADDR_EXP 130
63706: PUSH
63707: LD_EXP 130
63711: PPUSH
63712: LD_VAR 0 1
63716: PPUSH
63717: LD_VAR 0 2
63721: PPUSH
63722: CALL_OW 1
63726: ST_TO_ADDR
// end ;
63727: LD_VAR 0 3
63731: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63732: LD_INT 0
63734: PPUSH
63735: PPUSH
// if not mc_bases or not base then
63736: LD_EXP 102
63740: NOT
63741: PUSH
63742: LD_VAR 0 1
63746: NOT
63747: OR
63748: IFFALSE 63752
// exit ;
63750: GO 63854
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63752: LD_ADDR_VAR 0 4
63756: PUSH
63757: LD_EXP 102
63761: PUSH
63762: LD_VAR 0 1
63766: ARRAY
63767: PPUSH
63768: LD_INT 30
63770: PUSH
63771: LD_VAR 0 2
63775: PUSH
63776: EMPTY
63777: LIST
63778: LIST
63779: PPUSH
63780: CALL_OW 72
63784: ST_TO_ADDR
// if not tmp then
63785: LD_VAR 0 4
63789: NOT
63790: IFFALSE 63794
// exit ;
63792: GO 63854
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63794: LD_ADDR_EXP 134
63798: PUSH
63799: LD_EXP 134
63803: PPUSH
63804: LD_VAR 0 1
63808: PPUSH
63809: LD_EXP 134
63813: PUSH
63814: LD_VAR 0 1
63818: ARRAY
63819: PPUSH
63820: LD_EXP 134
63824: PUSH
63825: LD_VAR 0 1
63829: ARRAY
63830: PUSH
63831: LD_INT 1
63833: PLUS
63834: PPUSH
63835: LD_VAR 0 4
63839: PUSH
63840: LD_INT 1
63842: ARRAY
63843: PPUSH
63844: CALL_OW 2
63848: PPUSH
63849: CALL_OW 1
63853: ST_TO_ADDR
// end ;
63854: LD_VAR 0 3
63858: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63859: LD_INT 0
63861: PPUSH
63862: PPUSH
// if not mc_bases or not base or not kinds then
63863: LD_EXP 102
63867: NOT
63868: PUSH
63869: LD_VAR 0 1
63873: NOT
63874: OR
63875: PUSH
63876: LD_VAR 0 2
63880: NOT
63881: OR
63882: IFFALSE 63886
// exit ;
63884: GO 63947
// for i in kinds do
63886: LD_ADDR_VAR 0 4
63890: PUSH
63891: LD_VAR 0 2
63895: PUSH
63896: FOR_IN
63897: IFFALSE 63945
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63899: LD_ADDR_EXP 136
63903: PUSH
63904: LD_EXP 136
63908: PPUSH
63909: LD_VAR 0 1
63913: PUSH
63914: LD_EXP 136
63918: PUSH
63919: LD_VAR 0 1
63923: ARRAY
63924: PUSH
63925: LD_INT 1
63927: PLUS
63928: PUSH
63929: EMPTY
63930: LIST
63931: LIST
63932: PPUSH
63933: LD_VAR 0 4
63937: PPUSH
63938: CALL 74553 0 3
63942: ST_TO_ADDR
63943: GO 63896
63945: POP
63946: POP
// end ;
63947: LD_VAR 0 3
63951: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63952: LD_INT 0
63954: PPUSH
// if not mc_bases or not base or not areas then
63955: LD_EXP 102
63959: NOT
63960: PUSH
63961: LD_VAR 0 1
63965: NOT
63966: OR
63967: PUSH
63968: LD_VAR 0 2
63972: NOT
63973: OR
63974: IFFALSE 63978
// exit ;
63976: GO 64003
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63978: LD_ADDR_EXP 120
63982: PUSH
63983: LD_EXP 120
63987: PPUSH
63988: LD_VAR 0 1
63992: PPUSH
63993: LD_VAR 0 2
63997: PPUSH
63998: CALL_OW 1
64002: ST_TO_ADDR
// end ;
64003: LD_VAR 0 3
64007: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64008: LD_INT 0
64010: PPUSH
// if not mc_bases or not base or not teleports_exit then
64011: LD_EXP 102
64015: NOT
64016: PUSH
64017: LD_VAR 0 1
64021: NOT
64022: OR
64023: PUSH
64024: LD_VAR 0 2
64028: NOT
64029: OR
64030: IFFALSE 64034
// exit ;
64032: GO 64059
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64034: LD_ADDR_EXP 137
64038: PUSH
64039: LD_EXP 137
64043: PPUSH
64044: LD_VAR 0 1
64048: PPUSH
64049: LD_VAR 0 2
64053: PPUSH
64054: CALL_OW 1
64058: ST_TO_ADDR
// end ;
64059: LD_VAR 0 3
64063: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64064: LD_INT 0
64066: PPUSH
64067: PPUSH
64068: PPUSH
// if not mc_bases or not base or not ext_list then
64069: LD_EXP 102
64073: NOT
64074: PUSH
64075: LD_VAR 0 1
64079: NOT
64080: OR
64081: PUSH
64082: LD_VAR 0 5
64086: NOT
64087: OR
64088: IFFALSE 64092
// exit ;
64090: GO 64265
// tmp := GetFacExtXYD ( x , y , d ) ;
64092: LD_ADDR_VAR 0 8
64096: PUSH
64097: LD_VAR 0 2
64101: PPUSH
64102: LD_VAR 0 3
64106: PPUSH
64107: LD_VAR 0 4
64111: PPUSH
64112: CALL 104916 0 3
64116: ST_TO_ADDR
// if not tmp then
64117: LD_VAR 0 8
64121: NOT
64122: IFFALSE 64126
// exit ;
64124: GO 64265
// for i in tmp do
64126: LD_ADDR_VAR 0 7
64130: PUSH
64131: LD_VAR 0 8
64135: PUSH
64136: FOR_IN
64137: IFFALSE 64263
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64139: LD_ADDR_EXP 107
64143: PUSH
64144: LD_EXP 107
64148: PPUSH
64149: LD_VAR 0 1
64153: PPUSH
64154: LD_EXP 107
64158: PUSH
64159: LD_VAR 0 1
64163: ARRAY
64164: PPUSH
64165: LD_EXP 107
64169: PUSH
64170: LD_VAR 0 1
64174: ARRAY
64175: PUSH
64176: LD_INT 1
64178: PLUS
64179: PPUSH
64180: LD_VAR 0 5
64184: PUSH
64185: LD_INT 1
64187: ARRAY
64188: PUSH
64189: LD_VAR 0 7
64193: PUSH
64194: LD_INT 1
64196: ARRAY
64197: PUSH
64198: LD_VAR 0 7
64202: PUSH
64203: LD_INT 2
64205: ARRAY
64206: PUSH
64207: LD_VAR 0 7
64211: PUSH
64212: LD_INT 3
64214: ARRAY
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: PPUSH
64222: CALL_OW 2
64226: PPUSH
64227: CALL_OW 1
64231: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64232: LD_ADDR_VAR 0 5
64236: PUSH
64237: LD_VAR 0 5
64241: PPUSH
64242: LD_INT 1
64244: PPUSH
64245: CALL_OW 3
64249: ST_TO_ADDR
// if not ext_list then
64250: LD_VAR 0 5
64254: NOT
64255: IFFALSE 64261
// exit ;
64257: POP
64258: POP
64259: GO 64265
// end ;
64261: GO 64136
64263: POP
64264: POP
// end ;
64265: LD_VAR 0 6
64269: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64270: LD_INT 0
64272: PPUSH
// if not mc_bases or not base or not weapon_list then
64273: LD_EXP 102
64277: NOT
64278: PUSH
64279: LD_VAR 0 1
64283: NOT
64284: OR
64285: PUSH
64286: LD_VAR 0 2
64290: NOT
64291: OR
64292: IFFALSE 64296
// exit ;
64294: GO 64321
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64296: LD_ADDR_EXP 141
64300: PUSH
64301: LD_EXP 141
64305: PPUSH
64306: LD_VAR 0 1
64310: PPUSH
64311: LD_VAR 0 2
64315: PPUSH
64316: CALL_OW 1
64320: ST_TO_ADDR
// end ;
64321: LD_VAR 0 3
64325: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64326: LD_INT 0
64328: PPUSH
// if not mc_bases or not base or not tech_list then
64329: LD_EXP 102
64333: NOT
64334: PUSH
64335: LD_VAR 0 1
64339: NOT
64340: OR
64341: PUSH
64342: LD_VAR 0 2
64346: NOT
64347: OR
64348: IFFALSE 64352
// exit ;
64350: GO 64377
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64352: LD_ADDR_EXP 129
64356: PUSH
64357: LD_EXP 129
64361: PPUSH
64362: LD_VAR 0 1
64366: PPUSH
64367: LD_VAR 0 2
64371: PPUSH
64372: CALL_OW 1
64376: ST_TO_ADDR
// end ;
64377: LD_VAR 0 3
64381: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64382: LD_INT 0
64384: PPUSH
// if not mc_bases or not parking_area or not base then
64385: LD_EXP 102
64389: NOT
64390: PUSH
64391: LD_VAR 0 2
64395: NOT
64396: OR
64397: PUSH
64398: LD_VAR 0 1
64402: NOT
64403: OR
64404: IFFALSE 64408
// exit ;
64406: GO 64433
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64408: LD_ADDR_EXP 126
64412: PUSH
64413: LD_EXP 126
64417: PPUSH
64418: LD_VAR 0 1
64422: PPUSH
64423: LD_VAR 0 2
64427: PPUSH
64428: CALL_OW 1
64432: ST_TO_ADDR
// end ;
64433: LD_VAR 0 3
64437: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64438: LD_INT 0
64440: PPUSH
// if not mc_bases or not base or not scan_area then
64441: LD_EXP 102
64445: NOT
64446: PUSH
64447: LD_VAR 0 1
64451: NOT
64452: OR
64453: PUSH
64454: LD_VAR 0 2
64458: NOT
64459: OR
64460: IFFALSE 64464
// exit ;
64462: GO 64489
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64464: LD_ADDR_EXP 127
64468: PUSH
64469: LD_EXP 127
64473: PPUSH
64474: LD_VAR 0 1
64478: PPUSH
64479: LD_VAR 0 2
64483: PPUSH
64484: CALL_OW 1
64488: ST_TO_ADDR
// end ;
64489: LD_VAR 0 3
64493: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64494: LD_INT 0
64496: PPUSH
64497: PPUSH
// if not mc_bases or not base then
64498: LD_EXP 102
64502: NOT
64503: PUSH
64504: LD_VAR 0 1
64508: NOT
64509: OR
64510: IFFALSE 64514
// exit ;
64512: GO 64578
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64514: LD_ADDR_VAR 0 3
64518: PUSH
64519: LD_INT 1
64521: PUSH
64522: LD_INT 2
64524: PUSH
64525: LD_INT 3
64527: PUSH
64528: LD_INT 4
64530: PUSH
64531: LD_INT 11
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64541: LD_ADDR_EXP 129
64545: PUSH
64546: LD_EXP 129
64550: PPUSH
64551: LD_VAR 0 1
64555: PPUSH
64556: LD_EXP 129
64560: PUSH
64561: LD_VAR 0 1
64565: ARRAY
64566: PUSH
64567: LD_VAR 0 3
64571: DIFF
64572: PPUSH
64573: CALL_OW 1
64577: ST_TO_ADDR
// end ;
64578: LD_VAR 0 2
64582: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64583: LD_INT 0
64585: PPUSH
// result := mc_vehicles [ base ] ;
64586: LD_ADDR_VAR 0 3
64590: PUSH
64591: LD_EXP 121
64595: PUSH
64596: LD_VAR 0 1
64600: ARRAY
64601: ST_TO_ADDR
// if onlyCombat then
64602: LD_VAR 0 2
64606: IFFALSE 64778
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64608: LD_ADDR_VAR 0 3
64612: PUSH
64613: LD_VAR 0 3
64617: PUSH
64618: LD_VAR 0 3
64622: PPUSH
64623: LD_INT 2
64625: PUSH
64626: LD_INT 34
64628: PUSH
64629: LD_INT 12
64631: PUSH
64632: EMPTY
64633: LIST
64634: LIST
64635: PUSH
64636: LD_INT 34
64638: PUSH
64639: LD_INT 51
64641: PUSH
64642: EMPTY
64643: LIST
64644: LIST
64645: PUSH
64646: LD_INT 34
64648: PUSH
64649: LD_INT 89
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 34
64658: PUSH
64659: LD_INT 32
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: LD_INT 34
64668: PUSH
64669: LD_INT 13
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 34
64678: PUSH
64679: LD_INT 52
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 34
64688: PUSH
64689: LD_INT 88
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 34
64698: PUSH
64699: LD_INT 14
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: LD_INT 34
64708: PUSH
64709: LD_INT 53
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 34
64718: PUSH
64719: LD_INT 98
64721: PUSH
64722: EMPTY
64723: LIST
64724: LIST
64725: PUSH
64726: LD_INT 34
64728: PUSH
64729: LD_INT 31
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 34
64738: PUSH
64739: LD_INT 48
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 34
64748: PUSH
64749: LD_INT 8
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: PPUSH
64772: CALL_OW 72
64776: DIFF
64777: ST_TO_ADDR
// end ; end_of_file
64778: LD_VAR 0 3
64782: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64783: LD_INT 0
64785: PPUSH
64786: PPUSH
64787: PPUSH
// if not mc_bases or not skirmish then
64788: LD_EXP 102
64792: NOT
64793: PUSH
64794: LD_EXP 100
64798: NOT
64799: OR
64800: IFFALSE 64804
// exit ;
64802: GO 64969
// for i = 1 to mc_bases do
64804: LD_ADDR_VAR 0 4
64808: PUSH
64809: DOUBLE
64810: LD_INT 1
64812: DEC
64813: ST_TO_ADDR
64814: LD_EXP 102
64818: PUSH
64819: FOR_TO
64820: IFFALSE 64967
// begin if sci in mc_bases [ i ] then
64822: LD_VAR 0 2
64826: PUSH
64827: LD_EXP 102
64831: PUSH
64832: LD_VAR 0 4
64836: ARRAY
64837: IN
64838: IFFALSE 64965
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64840: LD_ADDR_EXP 131
64844: PUSH
64845: LD_EXP 131
64849: PPUSH
64850: LD_VAR 0 4
64854: PUSH
64855: LD_EXP 131
64859: PUSH
64860: LD_VAR 0 4
64864: ARRAY
64865: PUSH
64866: LD_INT 1
64868: PLUS
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PPUSH
64874: LD_VAR 0 1
64878: PPUSH
64879: CALL 74553 0 3
64883: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64884: LD_ADDR_VAR 0 5
64888: PUSH
64889: LD_EXP 102
64893: PUSH
64894: LD_VAR 0 4
64898: ARRAY
64899: PPUSH
64900: LD_INT 2
64902: PUSH
64903: LD_INT 30
64905: PUSH
64906: LD_INT 0
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 30
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: LIST
64927: PPUSH
64928: CALL_OW 72
64932: PPUSH
64933: LD_VAR 0 1
64937: PPUSH
64938: CALL_OW 74
64942: ST_TO_ADDR
// if tmp then
64943: LD_VAR 0 5
64947: IFFALSE 64963
// ComStandNearbyBuilding ( ape , tmp ) ;
64949: LD_VAR 0 1
64953: PPUSH
64954: LD_VAR 0 5
64958: PPUSH
64959: CALL 71155 0 2
// break ;
64963: GO 64967
// end ; end ;
64965: GO 64819
64967: POP
64968: POP
// end ;
64969: LD_VAR 0 3
64973: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64974: LD_INT 0
64976: PPUSH
64977: PPUSH
64978: PPUSH
// if not mc_bases or not skirmish then
64979: LD_EXP 102
64983: NOT
64984: PUSH
64985: LD_EXP 100
64989: NOT
64990: OR
64991: IFFALSE 64995
// exit ;
64993: GO 65084
// for i = 1 to mc_bases do
64995: LD_ADDR_VAR 0 4
64999: PUSH
65000: DOUBLE
65001: LD_INT 1
65003: DEC
65004: ST_TO_ADDR
65005: LD_EXP 102
65009: PUSH
65010: FOR_TO
65011: IFFALSE 65082
// begin if building in mc_busy_turret_list [ i ] then
65013: LD_VAR 0 1
65017: PUSH
65018: LD_EXP 112
65022: PUSH
65023: LD_VAR 0 4
65027: ARRAY
65028: IN
65029: IFFALSE 65080
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65031: LD_ADDR_VAR 0 5
65035: PUSH
65036: LD_EXP 112
65040: PUSH
65041: LD_VAR 0 4
65045: ARRAY
65046: PUSH
65047: LD_VAR 0 1
65051: DIFF
65052: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65053: LD_ADDR_EXP 112
65057: PUSH
65058: LD_EXP 112
65062: PPUSH
65063: LD_VAR 0 4
65067: PPUSH
65068: LD_VAR 0 5
65072: PPUSH
65073: CALL_OW 1
65077: ST_TO_ADDR
// break ;
65078: GO 65082
// end ; end ;
65080: GO 65010
65082: POP
65083: POP
// end ;
65084: LD_VAR 0 3
65088: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65089: LD_INT 0
65091: PPUSH
65092: PPUSH
65093: PPUSH
// if not mc_bases or not skirmish then
65094: LD_EXP 102
65098: NOT
65099: PUSH
65100: LD_EXP 100
65104: NOT
65105: OR
65106: IFFALSE 65110
// exit ;
65108: GO 65309
// for i = 1 to mc_bases do
65110: LD_ADDR_VAR 0 5
65114: PUSH
65115: DOUBLE
65116: LD_INT 1
65118: DEC
65119: ST_TO_ADDR
65120: LD_EXP 102
65124: PUSH
65125: FOR_TO
65126: IFFALSE 65307
// if building in mc_bases [ i ] then
65128: LD_VAR 0 1
65132: PUSH
65133: LD_EXP 102
65137: PUSH
65138: LD_VAR 0 5
65142: ARRAY
65143: IN
65144: IFFALSE 65305
// begin tmp := mc_bases [ i ] diff building ;
65146: LD_ADDR_VAR 0 6
65150: PUSH
65151: LD_EXP 102
65155: PUSH
65156: LD_VAR 0 5
65160: ARRAY
65161: PUSH
65162: LD_VAR 0 1
65166: DIFF
65167: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65168: LD_ADDR_EXP 102
65172: PUSH
65173: LD_EXP 102
65177: PPUSH
65178: LD_VAR 0 5
65182: PPUSH
65183: LD_VAR 0 6
65187: PPUSH
65188: CALL_OW 1
65192: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65193: LD_VAR 0 1
65197: PUSH
65198: LD_EXP 110
65202: PUSH
65203: LD_VAR 0 5
65207: ARRAY
65208: IN
65209: IFFALSE 65248
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65211: LD_ADDR_EXP 110
65215: PUSH
65216: LD_EXP 110
65220: PPUSH
65221: LD_VAR 0 5
65225: PPUSH
65226: LD_EXP 110
65230: PUSH
65231: LD_VAR 0 5
65235: ARRAY
65236: PUSH
65237: LD_VAR 0 1
65241: DIFF
65242: PPUSH
65243: CALL_OW 1
65247: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65248: LD_VAR 0 1
65252: PUSH
65253: LD_EXP 111
65257: PUSH
65258: LD_VAR 0 5
65262: ARRAY
65263: IN
65264: IFFALSE 65303
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65266: LD_ADDR_EXP 111
65270: PUSH
65271: LD_EXP 111
65275: PPUSH
65276: LD_VAR 0 5
65280: PPUSH
65281: LD_EXP 111
65285: PUSH
65286: LD_VAR 0 5
65290: ARRAY
65291: PUSH
65292: LD_VAR 0 1
65296: DIFF
65297: PPUSH
65298: CALL_OW 1
65302: ST_TO_ADDR
// break ;
65303: GO 65307
// end ;
65305: GO 65125
65307: POP
65308: POP
// end ;
65309: LD_VAR 0 4
65313: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65314: LD_INT 0
65316: PPUSH
65317: PPUSH
65318: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65319: LD_EXP 102
65323: NOT
65324: PUSH
65325: LD_EXP 100
65329: NOT
65330: OR
65331: PUSH
65332: LD_VAR 0 3
65336: PUSH
65337: LD_EXP 128
65341: IN
65342: NOT
65343: OR
65344: IFFALSE 65348
// exit ;
65346: GO 65471
// for i = 1 to mc_vehicles do
65348: LD_ADDR_VAR 0 6
65352: PUSH
65353: DOUBLE
65354: LD_INT 1
65356: DEC
65357: ST_TO_ADDR
65358: LD_EXP 121
65362: PUSH
65363: FOR_TO
65364: IFFALSE 65469
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65366: LD_VAR 0 2
65370: PUSH
65371: LD_EXP 121
65375: PUSH
65376: LD_VAR 0 6
65380: ARRAY
65381: IN
65382: PUSH
65383: LD_VAR 0 1
65387: PUSH
65388: LD_EXP 121
65392: PUSH
65393: LD_VAR 0 6
65397: ARRAY
65398: IN
65399: OR
65400: IFFALSE 65467
// begin tmp := mc_vehicles [ i ] diff old ;
65402: LD_ADDR_VAR 0 7
65406: PUSH
65407: LD_EXP 121
65411: PUSH
65412: LD_VAR 0 6
65416: ARRAY
65417: PUSH
65418: LD_VAR 0 2
65422: DIFF
65423: ST_TO_ADDR
// tmp := tmp diff new ;
65424: LD_ADDR_VAR 0 7
65428: PUSH
65429: LD_VAR 0 7
65433: PUSH
65434: LD_VAR 0 1
65438: DIFF
65439: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65440: LD_ADDR_EXP 121
65444: PUSH
65445: LD_EXP 121
65449: PPUSH
65450: LD_VAR 0 6
65454: PPUSH
65455: LD_VAR 0 7
65459: PPUSH
65460: CALL_OW 1
65464: ST_TO_ADDR
// break ;
65465: GO 65469
// end ;
65467: GO 65363
65469: POP
65470: POP
// end ;
65471: LD_VAR 0 5
65475: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65476: LD_INT 0
65478: PPUSH
65479: PPUSH
65480: PPUSH
65481: PPUSH
// if not mc_bases or not skirmish then
65482: LD_EXP 102
65486: NOT
65487: PUSH
65488: LD_EXP 100
65492: NOT
65493: OR
65494: IFFALSE 65498
// exit ;
65496: GO 65918
// repeat wait ( 0 0$1 ) ;
65498: LD_INT 35
65500: PPUSH
65501: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65505: LD_EXP 146
65509: NOT
65510: IFFALSE 65498
// mc_block_vehicle_constructed_thread := true ;
65512: LD_ADDR_EXP 146
65516: PUSH
65517: LD_INT 1
65519: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65520: LD_ADDR_VAR 0 5
65524: PUSH
65525: LD_VAR 0 1
65529: PPUSH
65530: CALL_OW 255
65534: ST_TO_ADDR
// for i = 1 to mc_bases do
65535: LD_ADDR_VAR 0 4
65539: PUSH
65540: DOUBLE
65541: LD_INT 1
65543: DEC
65544: ST_TO_ADDR
65545: LD_EXP 102
65549: PUSH
65550: FOR_TO
65551: IFFALSE 65908
// begin if factory in mc_bases [ i ] then
65553: LD_VAR 0 2
65557: PUSH
65558: LD_EXP 102
65562: PUSH
65563: LD_VAR 0 4
65567: ARRAY
65568: IN
65569: IFFALSE 65906
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65571: LD_EXP 124
65575: PUSH
65576: LD_VAR 0 4
65580: ARRAY
65581: PUSH
65582: LD_EXP 113
65586: PUSH
65587: LD_VAR 0 4
65591: ARRAY
65592: LESS
65593: PUSH
65594: LD_VAR 0 1
65598: PPUSH
65599: CALL_OW 264
65603: PUSH
65604: LD_INT 31
65606: PUSH
65607: LD_INT 32
65609: PUSH
65610: LD_INT 51
65612: PUSH
65613: LD_INT 89
65615: PUSH
65616: LD_INT 12
65618: PUSH
65619: LD_INT 30
65621: PUSH
65622: LD_INT 98
65624: PUSH
65625: LD_INT 11
65627: PUSH
65628: LD_INT 53
65630: PUSH
65631: LD_INT 14
65633: PUSH
65634: LD_INT 91
65636: PUSH
65637: LD_INT 29
65639: PUSH
65640: LD_INT 99
65642: PUSH
65643: LD_INT 13
65645: PUSH
65646: LD_INT 52
65648: PUSH
65649: LD_INT 88
65651: PUSH
65652: LD_INT 48
65654: PUSH
65655: LD_INT 8
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: IN
65678: NOT
65679: AND
65680: IFFALSE 65728
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65682: LD_ADDR_EXP 124
65686: PUSH
65687: LD_EXP 124
65691: PPUSH
65692: LD_VAR 0 4
65696: PUSH
65697: LD_EXP 124
65701: PUSH
65702: LD_VAR 0 4
65706: ARRAY
65707: PUSH
65708: LD_INT 1
65710: PLUS
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PPUSH
65716: LD_VAR 0 1
65720: PPUSH
65721: CALL 74553 0 3
65725: ST_TO_ADDR
65726: GO 65772
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65728: LD_ADDR_EXP 121
65732: PUSH
65733: LD_EXP 121
65737: PPUSH
65738: LD_VAR 0 4
65742: PUSH
65743: LD_EXP 121
65747: PUSH
65748: LD_VAR 0 4
65752: ARRAY
65753: PUSH
65754: LD_INT 1
65756: PLUS
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PPUSH
65762: LD_VAR 0 1
65766: PPUSH
65767: CALL 74553 0 3
65771: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65772: LD_ADDR_EXP 146
65776: PUSH
65777: LD_INT 0
65779: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65780: LD_VAR 0 1
65784: PPUSH
65785: CALL_OW 263
65789: PUSH
65790: LD_INT 2
65792: EQUAL
65793: IFFALSE 65822
// begin repeat wait ( 0 0$3 ) ;
65795: LD_INT 105
65797: PPUSH
65798: CALL_OW 67
// Connect ( vehicle ) ;
65802: LD_VAR 0 1
65806: PPUSH
65807: CALL 77899 0 1
// until IsControledBy ( vehicle ) ;
65811: LD_VAR 0 1
65815: PPUSH
65816: CALL_OW 312
65820: IFFALSE 65795
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65822: LD_VAR 0 1
65826: PPUSH
65827: LD_EXP 126
65831: PUSH
65832: LD_VAR 0 4
65836: ARRAY
65837: PPUSH
65838: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65842: LD_VAR 0 1
65846: PPUSH
65847: CALL_OW 263
65851: PUSH
65852: LD_INT 1
65854: NONEQUAL
65855: IFFALSE 65859
// break ;
65857: GO 65908
// repeat wait ( 0 0$1 ) ;
65859: LD_INT 35
65861: PPUSH
65862: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65866: LD_VAR 0 1
65870: PPUSH
65871: LD_EXP 126
65875: PUSH
65876: LD_VAR 0 4
65880: ARRAY
65881: PPUSH
65882: CALL_OW 308
65886: IFFALSE 65859
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65888: LD_VAR 0 1
65892: PPUSH
65893: CALL_OW 311
65897: PPUSH
65898: CALL_OW 121
// exit ;
65902: POP
65903: POP
65904: GO 65918
// end ; end ;
65906: GO 65550
65908: POP
65909: POP
// mc_block_vehicle_constructed_thread := false ;
65910: LD_ADDR_EXP 146
65914: PUSH
65915: LD_INT 0
65917: ST_TO_ADDR
// end ;
65918: LD_VAR 0 3
65922: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65923: LD_INT 0
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
// if not mc_bases or not skirmish then
65929: LD_EXP 102
65933: NOT
65934: PUSH
65935: LD_EXP 100
65939: NOT
65940: OR
65941: IFFALSE 65945
// exit ;
65943: GO 66298
// repeat wait ( 0 0$1 ) ;
65945: LD_INT 35
65947: PPUSH
65948: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65952: LD_VAR 0 2
65956: PPUSH
65957: LD_VAR 0 3
65961: PPUSH
65962: CALL_OW 284
65966: IFFALSE 65945
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65968: LD_VAR 0 2
65972: PPUSH
65973: LD_VAR 0 3
65977: PPUSH
65978: CALL_OW 283
65982: PUSH
65983: LD_INT 4
65985: EQUAL
65986: IFFALSE 65990
// exit ;
65988: GO 66298
// for i = 1 to mc_bases do
65990: LD_ADDR_VAR 0 7
65994: PUSH
65995: DOUBLE
65996: LD_INT 1
65998: DEC
65999: ST_TO_ADDR
66000: LD_EXP 102
66004: PUSH
66005: FOR_TO
66006: IFFALSE 66296
// begin if mc_crates_area [ i ] then
66008: LD_EXP 120
66012: PUSH
66013: LD_VAR 0 7
66017: ARRAY
66018: IFFALSE 66129
// for j in mc_crates_area [ i ] do
66020: LD_ADDR_VAR 0 8
66024: PUSH
66025: LD_EXP 120
66029: PUSH
66030: LD_VAR 0 7
66034: ARRAY
66035: PUSH
66036: FOR_IN
66037: IFFALSE 66127
// if InArea ( x , y , j ) then
66039: LD_VAR 0 2
66043: PPUSH
66044: LD_VAR 0 3
66048: PPUSH
66049: LD_VAR 0 8
66053: PPUSH
66054: CALL_OW 309
66058: IFFALSE 66125
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66060: LD_ADDR_EXP 118
66064: PUSH
66065: LD_EXP 118
66069: PPUSH
66070: LD_VAR 0 7
66074: PUSH
66075: LD_EXP 118
66079: PUSH
66080: LD_VAR 0 7
66084: ARRAY
66085: PUSH
66086: LD_INT 1
66088: PLUS
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PPUSH
66094: LD_VAR 0 4
66098: PUSH
66099: LD_VAR 0 2
66103: PUSH
66104: LD_VAR 0 3
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: LIST
66113: PPUSH
66114: CALL 74553 0 3
66118: ST_TO_ADDR
// exit ;
66119: POP
66120: POP
66121: POP
66122: POP
66123: GO 66298
// end ;
66125: GO 66036
66127: POP
66128: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66129: LD_ADDR_VAR 0 9
66133: PUSH
66134: LD_EXP 102
66138: PUSH
66139: LD_VAR 0 7
66143: ARRAY
66144: PPUSH
66145: LD_INT 2
66147: PUSH
66148: LD_INT 30
66150: PUSH
66151: LD_INT 0
66153: PUSH
66154: EMPTY
66155: LIST
66156: LIST
66157: PUSH
66158: LD_INT 30
66160: PUSH
66161: LD_INT 1
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: LIST
66172: PPUSH
66173: CALL_OW 72
66177: ST_TO_ADDR
// if not depot then
66178: LD_VAR 0 9
66182: NOT
66183: IFFALSE 66187
// continue ;
66185: GO 66005
// for j in depot do
66187: LD_ADDR_VAR 0 8
66191: PUSH
66192: LD_VAR 0 9
66196: PUSH
66197: FOR_IN
66198: IFFALSE 66292
// if GetDistUnitXY ( j , x , y ) < 30 then
66200: LD_VAR 0 8
66204: PPUSH
66205: LD_VAR 0 2
66209: PPUSH
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 297
66219: PUSH
66220: LD_INT 30
66222: LESS
66223: IFFALSE 66290
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66225: LD_ADDR_EXP 118
66229: PUSH
66230: LD_EXP 118
66234: PPUSH
66235: LD_VAR 0 7
66239: PUSH
66240: LD_EXP 118
66244: PUSH
66245: LD_VAR 0 7
66249: ARRAY
66250: PUSH
66251: LD_INT 1
66253: PLUS
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PPUSH
66259: LD_VAR 0 4
66263: PUSH
66264: LD_VAR 0 2
66268: PUSH
66269: LD_VAR 0 3
66273: PUSH
66274: EMPTY
66275: LIST
66276: LIST
66277: LIST
66278: PPUSH
66279: CALL 74553 0 3
66283: ST_TO_ADDR
// exit ;
66284: POP
66285: POP
66286: POP
66287: POP
66288: GO 66298
// end ;
66290: GO 66197
66292: POP
66293: POP
// end ;
66294: GO 66005
66296: POP
66297: POP
// end ;
66298: LD_VAR 0 6
66302: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66303: LD_INT 0
66305: PPUSH
66306: PPUSH
66307: PPUSH
66308: PPUSH
// if not mc_bases or not skirmish then
66309: LD_EXP 102
66313: NOT
66314: PUSH
66315: LD_EXP 100
66319: NOT
66320: OR
66321: IFFALSE 66325
// exit ;
66323: GO 66602
// side := GetSide ( lab ) ;
66325: LD_ADDR_VAR 0 4
66329: PUSH
66330: LD_VAR 0 2
66334: PPUSH
66335: CALL_OW 255
66339: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66340: LD_VAR 0 4
66344: PUSH
66345: LD_EXP 128
66349: IN
66350: NOT
66351: PUSH
66352: LD_EXP 129
66356: NOT
66357: OR
66358: PUSH
66359: LD_EXP 102
66363: NOT
66364: OR
66365: IFFALSE 66369
// exit ;
66367: GO 66602
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66369: LD_ADDR_EXP 129
66373: PUSH
66374: LD_EXP 129
66378: PPUSH
66379: LD_VAR 0 4
66383: PPUSH
66384: LD_EXP 129
66388: PUSH
66389: LD_VAR 0 4
66393: ARRAY
66394: PUSH
66395: LD_VAR 0 1
66399: DIFF
66400: PPUSH
66401: CALL_OW 1
66405: ST_TO_ADDR
// for i = 1 to mc_bases do
66406: LD_ADDR_VAR 0 5
66410: PUSH
66411: DOUBLE
66412: LD_INT 1
66414: DEC
66415: ST_TO_ADDR
66416: LD_EXP 102
66420: PUSH
66421: FOR_TO
66422: IFFALSE 66600
// begin if lab in mc_bases [ i ] then
66424: LD_VAR 0 2
66428: PUSH
66429: LD_EXP 102
66433: PUSH
66434: LD_VAR 0 5
66438: ARRAY
66439: IN
66440: IFFALSE 66598
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66442: LD_VAR 0 1
66446: PUSH
66447: LD_INT 11
66449: PUSH
66450: LD_INT 4
66452: PUSH
66453: LD_INT 3
66455: PUSH
66456: LD_INT 2
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: IN
66465: PUSH
66466: LD_EXP 132
66470: PUSH
66471: LD_VAR 0 5
66475: ARRAY
66476: AND
66477: IFFALSE 66598
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66479: LD_ADDR_VAR 0 6
66483: PUSH
66484: LD_EXP 132
66488: PUSH
66489: LD_VAR 0 5
66493: ARRAY
66494: PUSH
66495: LD_INT 1
66497: ARRAY
66498: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66499: LD_ADDR_EXP 132
66503: PUSH
66504: LD_EXP 132
66508: PPUSH
66509: LD_VAR 0 5
66513: PPUSH
66514: EMPTY
66515: PPUSH
66516: CALL_OW 1
66520: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66521: LD_VAR 0 6
66525: PPUSH
66526: LD_INT 0
66528: PPUSH
66529: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66533: LD_VAR 0 6
66537: PPUSH
66538: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66542: LD_ADDR_EXP 131
66546: PUSH
66547: LD_EXP 131
66551: PPUSH
66552: LD_VAR 0 5
66556: PPUSH
66557: LD_EXP 131
66561: PUSH
66562: LD_VAR 0 5
66566: ARRAY
66567: PPUSH
66568: LD_INT 1
66570: PPUSH
66571: LD_VAR 0 6
66575: PPUSH
66576: CALL_OW 2
66580: PPUSH
66581: CALL_OW 1
66585: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66586: LD_VAR 0 5
66590: PPUSH
66591: LD_INT 112
66593: PPUSH
66594: CALL 43052 0 2
// end ; end ; end ;
66598: GO 66421
66600: POP
66601: POP
// end ;
66602: LD_VAR 0 3
66606: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66607: LD_INT 0
66609: PPUSH
66610: PPUSH
66611: PPUSH
66612: PPUSH
66613: PPUSH
66614: PPUSH
66615: PPUSH
66616: PPUSH
// if not mc_bases or not skirmish then
66617: LD_EXP 102
66621: NOT
66622: PUSH
66623: LD_EXP 100
66627: NOT
66628: OR
66629: IFFALSE 66633
// exit ;
66631: GO 68002
// for i = 1 to mc_bases do
66633: LD_ADDR_VAR 0 3
66637: PUSH
66638: DOUBLE
66639: LD_INT 1
66641: DEC
66642: ST_TO_ADDR
66643: LD_EXP 102
66647: PUSH
66648: FOR_TO
66649: IFFALSE 68000
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66651: LD_VAR 0 1
66655: PUSH
66656: LD_EXP 102
66660: PUSH
66661: LD_VAR 0 3
66665: ARRAY
66666: IN
66667: PUSH
66668: LD_VAR 0 1
66672: PUSH
66673: LD_EXP 109
66677: PUSH
66678: LD_VAR 0 3
66682: ARRAY
66683: IN
66684: OR
66685: PUSH
66686: LD_VAR 0 1
66690: PUSH
66691: LD_EXP 124
66695: PUSH
66696: LD_VAR 0 3
66700: ARRAY
66701: IN
66702: OR
66703: PUSH
66704: LD_VAR 0 1
66708: PUSH
66709: LD_EXP 121
66713: PUSH
66714: LD_VAR 0 3
66718: ARRAY
66719: IN
66720: OR
66721: PUSH
66722: LD_VAR 0 1
66726: PUSH
66727: LD_EXP 131
66731: PUSH
66732: LD_VAR 0 3
66736: ARRAY
66737: IN
66738: OR
66739: PUSH
66740: LD_VAR 0 1
66744: PUSH
66745: LD_EXP 132
66749: PUSH
66750: LD_VAR 0 3
66754: ARRAY
66755: IN
66756: OR
66757: IFFALSE 67998
// begin if un in mc_ape [ i ] then
66759: LD_VAR 0 1
66763: PUSH
66764: LD_EXP 131
66768: PUSH
66769: LD_VAR 0 3
66773: ARRAY
66774: IN
66775: IFFALSE 66814
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66777: LD_ADDR_EXP 131
66781: PUSH
66782: LD_EXP 131
66786: PPUSH
66787: LD_VAR 0 3
66791: PPUSH
66792: LD_EXP 131
66796: PUSH
66797: LD_VAR 0 3
66801: ARRAY
66802: PUSH
66803: LD_VAR 0 1
66807: DIFF
66808: PPUSH
66809: CALL_OW 1
66813: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66814: LD_VAR 0 1
66818: PUSH
66819: LD_EXP 132
66823: PUSH
66824: LD_VAR 0 3
66828: ARRAY
66829: IN
66830: IFFALSE 66854
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66832: LD_ADDR_EXP 132
66836: PUSH
66837: LD_EXP 132
66841: PPUSH
66842: LD_VAR 0 3
66846: PPUSH
66847: EMPTY
66848: PPUSH
66849: CALL_OW 1
66853: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66854: LD_VAR 0 1
66858: PPUSH
66859: CALL_OW 247
66863: PUSH
66864: LD_INT 2
66866: EQUAL
66867: PUSH
66868: LD_VAR 0 1
66872: PPUSH
66873: CALL_OW 110
66877: PUSH
66878: LD_INT 20
66880: EQUAL
66881: PUSH
66882: LD_VAR 0 1
66886: PUSH
66887: LD_EXP 124
66891: PUSH
66892: LD_VAR 0 3
66896: ARRAY
66897: IN
66898: OR
66899: PUSH
66900: LD_VAR 0 1
66904: PPUSH
66905: CALL_OW 264
66909: PUSH
66910: LD_INT 12
66912: PUSH
66913: LD_INT 51
66915: PUSH
66916: LD_INT 89
66918: PUSH
66919: LD_INT 32
66921: PUSH
66922: LD_INT 13
66924: PUSH
66925: LD_INT 52
66927: PUSH
66928: LD_INT 31
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: IN
66940: OR
66941: AND
66942: IFFALSE 67250
// begin if un in mc_defender [ i ] then
66944: LD_VAR 0 1
66948: PUSH
66949: LD_EXP 124
66953: PUSH
66954: LD_VAR 0 3
66958: ARRAY
66959: IN
66960: IFFALSE 66999
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66962: LD_ADDR_EXP 124
66966: PUSH
66967: LD_EXP 124
66971: PPUSH
66972: LD_VAR 0 3
66976: PPUSH
66977: LD_EXP 124
66981: PUSH
66982: LD_VAR 0 3
66986: ARRAY
66987: PUSH
66988: LD_VAR 0 1
66992: DIFF
66993: PPUSH
66994: CALL_OW 1
66998: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66999: LD_ADDR_VAR 0 8
67003: PUSH
67004: LD_VAR 0 3
67008: PPUSH
67009: LD_INT 3
67011: PPUSH
67012: CALL 63620 0 2
67016: ST_TO_ADDR
// if fac then
67017: LD_VAR 0 8
67021: IFFALSE 67250
// begin for j in fac do
67023: LD_ADDR_VAR 0 4
67027: PUSH
67028: LD_VAR 0 8
67032: PUSH
67033: FOR_IN
67034: IFFALSE 67248
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67036: LD_ADDR_VAR 0 9
67040: PUSH
67041: LD_VAR 0 8
67045: PPUSH
67046: LD_VAR 0 1
67050: PPUSH
67051: CALL_OW 265
67055: PPUSH
67056: LD_VAR 0 1
67060: PPUSH
67061: CALL_OW 262
67065: PPUSH
67066: LD_VAR 0 1
67070: PPUSH
67071: CALL_OW 263
67075: PPUSH
67076: LD_VAR 0 1
67080: PPUSH
67081: CALL_OW 264
67085: PPUSH
67086: CALL 72051 0 5
67090: ST_TO_ADDR
// if components then
67091: LD_VAR 0 9
67095: IFFALSE 67246
// begin if GetWeapon ( un ) = ar_control_tower then
67097: LD_VAR 0 1
67101: PPUSH
67102: CALL_OW 264
67106: PUSH
67107: LD_INT 31
67109: EQUAL
67110: IFFALSE 67227
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67112: LD_VAR 0 1
67116: PPUSH
67117: CALL_OW 311
67121: PPUSH
67122: LD_INT 0
67124: PPUSH
67125: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67129: LD_ADDR_EXP 142
67133: PUSH
67134: LD_EXP 142
67138: PPUSH
67139: LD_VAR 0 3
67143: PPUSH
67144: LD_EXP 142
67148: PUSH
67149: LD_VAR 0 3
67153: ARRAY
67154: PUSH
67155: LD_VAR 0 1
67159: PPUSH
67160: CALL_OW 311
67164: DIFF
67165: PPUSH
67166: CALL_OW 1
67170: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67171: LD_ADDR_VAR 0 7
67175: PUSH
67176: LD_EXP 123
67180: PUSH
67181: LD_VAR 0 3
67185: ARRAY
67186: PPUSH
67187: LD_INT 1
67189: PPUSH
67190: LD_VAR 0 9
67194: PPUSH
67195: CALL_OW 2
67199: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67200: LD_ADDR_EXP 123
67204: PUSH
67205: LD_EXP 123
67209: PPUSH
67210: LD_VAR 0 3
67214: PPUSH
67215: LD_VAR 0 7
67219: PPUSH
67220: CALL_OW 1
67224: ST_TO_ADDR
// end else
67225: GO 67244
// MC_InsertProduceList ( i , [ components ] ) ;
67227: LD_VAR 0 3
67231: PPUSH
67232: LD_VAR 0 9
67236: PUSH
67237: EMPTY
67238: LIST
67239: PPUSH
67240: CALL 63165 0 2
// break ;
67244: GO 67248
// end ; end ;
67246: GO 67033
67248: POP
67249: POP
// end ; end ; if GetType ( un ) = unit_building then
67250: LD_VAR 0 1
67254: PPUSH
67255: CALL_OW 247
67259: PUSH
67260: LD_INT 3
67262: EQUAL
67263: IFFALSE 67666
// begin btype := GetBType ( un ) ;
67265: LD_ADDR_VAR 0 5
67269: PUSH
67270: LD_VAR 0 1
67274: PPUSH
67275: CALL_OW 266
67279: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67280: LD_VAR 0 5
67284: PUSH
67285: LD_INT 29
67287: PUSH
67288: LD_INT 30
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: IN
67295: IFFALSE 67368
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67297: LD_VAR 0 1
67301: PPUSH
67302: CALL_OW 250
67306: PPUSH
67307: LD_VAR 0 1
67311: PPUSH
67312: CALL_OW 251
67316: PPUSH
67317: LD_VAR 0 1
67321: PPUSH
67322: CALL_OW 255
67326: PPUSH
67327: CALL_OW 440
67331: NOT
67332: IFFALSE 67368
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67334: LD_VAR 0 1
67338: PPUSH
67339: CALL_OW 250
67343: PPUSH
67344: LD_VAR 0 1
67348: PPUSH
67349: CALL_OW 251
67353: PPUSH
67354: LD_VAR 0 1
67358: PPUSH
67359: CALL_OW 255
67363: PPUSH
67364: CALL_OW 441
// end ; if btype = b_warehouse then
67368: LD_VAR 0 5
67372: PUSH
67373: LD_INT 1
67375: EQUAL
67376: IFFALSE 67394
// begin btype := b_depot ;
67378: LD_ADDR_VAR 0 5
67382: PUSH
67383: LD_INT 0
67385: ST_TO_ADDR
// pos := 1 ;
67386: LD_ADDR_VAR 0 6
67390: PUSH
67391: LD_INT 1
67393: ST_TO_ADDR
// end ; if btype = b_factory then
67394: LD_VAR 0 5
67398: PUSH
67399: LD_INT 3
67401: EQUAL
67402: IFFALSE 67420
// begin btype := b_workshop ;
67404: LD_ADDR_VAR 0 5
67408: PUSH
67409: LD_INT 2
67411: ST_TO_ADDR
// pos := 1 ;
67412: LD_ADDR_VAR 0 6
67416: PUSH
67417: LD_INT 1
67419: ST_TO_ADDR
// end ; if btype = b_barracks then
67420: LD_VAR 0 5
67424: PUSH
67425: LD_INT 5
67427: EQUAL
67428: IFFALSE 67438
// btype := b_armoury ;
67430: LD_ADDR_VAR 0 5
67434: PUSH
67435: LD_INT 4
67437: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67438: LD_VAR 0 5
67442: PUSH
67443: LD_INT 7
67445: PUSH
67446: LD_INT 8
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: IN
67453: IFFALSE 67463
// btype := b_lab ;
67455: LD_ADDR_VAR 0 5
67459: PUSH
67460: LD_INT 6
67462: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67463: LD_ADDR_EXP 107
67467: PUSH
67468: LD_EXP 107
67472: PPUSH
67473: LD_VAR 0 3
67477: PUSH
67478: LD_EXP 107
67482: PUSH
67483: LD_VAR 0 3
67487: ARRAY
67488: PUSH
67489: LD_INT 1
67491: PLUS
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PPUSH
67497: LD_VAR 0 5
67501: PUSH
67502: LD_VAR 0 1
67506: PPUSH
67507: CALL_OW 250
67511: PUSH
67512: LD_VAR 0 1
67516: PPUSH
67517: CALL_OW 251
67521: PUSH
67522: LD_VAR 0 1
67526: PPUSH
67527: CALL_OW 254
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: PPUSH
67538: CALL 74553 0 3
67542: ST_TO_ADDR
// if pos = 1 then
67543: LD_VAR 0 6
67547: PUSH
67548: LD_INT 1
67550: EQUAL
67551: IFFALSE 67666
// begin tmp := mc_build_list [ i ] ;
67553: LD_ADDR_VAR 0 7
67557: PUSH
67558: LD_EXP 107
67562: PUSH
67563: LD_VAR 0 3
67567: ARRAY
67568: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67569: LD_VAR 0 7
67573: PPUSH
67574: LD_INT 2
67576: PUSH
67577: LD_INT 30
67579: PUSH
67580: LD_INT 0
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 30
67589: PUSH
67590: LD_INT 1
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: LIST
67601: PPUSH
67602: CALL_OW 72
67606: IFFALSE 67616
// pos := 2 ;
67608: LD_ADDR_VAR 0 6
67612: PUSH
67613: LD_INT 2
67615: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67616: LD_ADDR_VAR 0 7
67620: PUSH
67621: LD_VAR 0 7
67625: PPUSH
67626: LD_VAR 0 6
67630: PPUSH
67631: LD_VAR 0 7
67635: PPUSH
67636: CALL 74879 0 3
67640: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67641: LD_ADDR_EXP 107
67645: PUSH
67646: LD_EXP 107
67650: PPUSH
67651: LD_VAR 0 3
67655: PPUSH
67656: LD_VAR 0 7
67660: PPUSH
67661: CALL_OW 1
67665: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67666: LD_VAR 0 1
67670: PUSH
67671: LD_EXP 102
67675: PUSH
67676: LD_VAR 0 3
67680: ARRAY
67681: IN
67682: IFFALSE 67721
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67684: LD_ADDR_EXP 102
67688: PUSH
67689: LD_EXP 102
67693: PPUSH
67694: LD_VAR 0 3
67698: PPUSH
67699: LD_EXP 102
67703: PUSH
67704: LD_VAR 0 3
67708: ARRAY
67709: PUSH
67710: LD_VAR 0 1
67714: DIFF
67715: PPUSH
67716: CALL_OW 1
67720: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67721: LD_VAR 0 1
67725: PUSH
67726: LD_EXP 109
67730: PUSH
67731: LD_VAR 0 3
67735: ARRAY
67736: IN
67737: IFFALSE 67776
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67739: LD_ADDR_EXP 109
67743: PUSH
67744: LD_EXP 109
67748: PPUSH
67749: LD_VAR 0 3
67753: PPUSH
67754: LD_EXP 109
67758: PUSH
67759: LD_VAR 0 3
67763: ARRAY
67764: PUSH
67765: LD_VAR 0 1
67769: DIFF
67770: PPUSH
67771: CALL_OW 1
67775: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67776: LD_VAR 0 1
67780: PUSH
67781: LD_EXP 121
67785: PUSH
67786: LD_VAR 0 3
67790: ARRAY
67791: IN
67792: IFFALSE 67831
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67794: LD_ADDR_EXP 121
67798: PUSH
67799: LD_EXP 121
67803: PPUSH
67804: LD_VAR 0 3
67808: PPUSH
67809: LD_EXP 121
67813: PUSH
67814: LD_VAR 0 3
67818: ARRAY
67819: PUSH
67820: LD_VAR 0 1
67824: DIFF
67825: PPUSH
67826: CALL_OW 1
67830: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67831: LD_VAR 0 1
67835: PUSH
67836: LD_EXP 124
67840: PUSH
67841: LD_VAR 0 3
67845: ARRAY
67846: IN
67847: IFFALSE 67886
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67849: LD_ADDR_EXP 124
67853: PUSH
67854: LD_EXP 124
67858: PPUSH
67859: LD_VAR 0 3
67863: PPUSH
67864: LD_EXP 124
67868: PUSH
67869: LD_VAR 0 3
67873: ARRAY
67874: PUSH
67875: LD_VAR 0 1
67879: DIFF
67880: PPUSH
67881: CALL_OW 1
67885: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67886: LD_VAR 0 1
67890: PUSH
67891: LD_EXP 111
67895: PUSH
67896: LD_VAR 0 3
67900: ARRAY
67901: IN
67902: IFFALSE 67941
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67904: LD_ADDR_EXP 111
67908: PUSH
67909: LD_EXP 111
67913: PPUSH
67914: LD_VAR 0 3
67918: PPUSH
67919: LD_EXP 111
67923: PUSH
67924: LD_VAR 0 3
67928: ARRAY
67929: PUSH
67930: LD_VAR 0 1
67934: DIFF
67935: PPUSH
67936: CALL_OW 1
67940: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67941: LD_VAR 0 1
67945: PUSH
67946: LD_EXP 110
67950: PUSH
67951: LD_VAR 0 3
67955: ARRAY
67956: IN
67957: IFFALSE 67996
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67959: LD_ADDR_EXP 110
67963: PUSH
67964: LD_EXP 110
67968: PPUSH
67969: LD_VAR 0 3
67973: PPUSH
67974: LD_EXP 110
67978: PUSH
67979: LD_VAR 0 3
67983: ARRAY
67984: PUSH
67985: LD_VAR 0 1
67989: DIFF
67990: PPUSH
67991: CALL_OW 1
67995: ST_TO_ADDR
// end ; break ;
67996: GO 68000
// end ;
67998: GO 66648
68000: POP
68001: POP
// end ;
68002: LD_VAR 0 2
68006: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68007: LD_INT 0
68009: PPUSH
68010: PPUSH
68011: PPUSH
// if not mc_bases or not skirmish then
68012: LD_EXP 102
68016: NOT
68017: PUSH
68018: LD_EXP 100
68022: NOT
68023: OR
68024: IFFALSE 68028
// exit ;
68026: GO 68243
// for i = 1 to mc_bases do
68028: LD_ADDR_VAR 0 3
68032: PUSH
68033: DOUBLE
68034: LD_INT 1
68036: DEC
68037: ST_TO_ADDR
68038: LD_EXP 102
68042: PUSH
68043: FOR_TO
68044: IFFALSE 68241
// begin if building in mc_construct_list [ i ] then
68046: LD_VAR 0 1
68050: PUSH
68051: LD_EXP 109
68055: PUSH
68056: LD_VAR 0 3
68060: ARRAY
68061: IN
68062: IFFALSE 68239
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68064: LD_ADDR_EXP 109
68068: PUSH
68069: LD_EXP 109
68073: PPUSH
68074: LD_VAR 0 3
68078: PPUSH
68079: LD_EXP 109
68083: PUSH
68084: LD_VAR 0 3
68088: ARRAY
68089: PUSH
68090: LD_VAR 0 1
68094: DIFF
68095: PPUSH
68096: CALL_OW 1
68100: ST_TO_ADDR
// if building in mc_lab [ i ] then
68101: LD_VAR 0 1
68105: PUSH
68106: LD_EXP 135
68110: PUSH
68111: LD_VAR 0 3
68115: ARRAY
68116: IN
68117: IFFALSE 68172
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68119: LD_ADDR_EXP 136
68123: PUSH
68124: LD_EXP 136
68128: PPUSH
68129: LD_VAR 0 3
68133: PPUSH
68134: LD_EXP 136
68138: PUSH
68139: LD_VAR 0 3
68143: ARRAY
68144: PPUSH
68145: LD_INT 1
68147: PPUSH
68148: LD_EXP 136
68152: PUSH
68153: LD_VAR 0 3
68157: ARRAY
68158: PPUSH
68159: LD_INT 0
68161: PPUSH
68162: CALL 73971 0 4
68166: PPUSH
68167: CALL_OW 1
68171: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68172: LD_VAR 0 1
68176: PUSH
68177: LD_EXP 102
68181: PUSH
68182: LD_VAR 0 3
68186: ARRAY
68187: IN
68188: NOT
68189: IFFALSE 68235
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68191: LD_ADDR_EXP 102
68195: PUSH
68196: LD_EXP 102
68200: PPUSH
68201: LD_VAR 0 3
68205: PUSH
68206: LD_EXP 102
68210: PUSH
68211: LD_VAR 0 3
68215: ARRAY
68216: PUSH
68217: LD_INT 1
68219: PLUS
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PPUSH
68225: LD_VAR 0 1
68229: PPUSH
68230: CALL 74553 0 3
68234: ST_TO_ADDR
// exit ;
68235: POP
68236: POP
68237: GO 68243
// end ; end ;
68239: GO 68043
68241: POP
68242: POP
// end ;
68243: LD_VAR 0 2
68247: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68248: LD_INT 0
68250: PPUSH
68251: PPUSH
68252: PPUSH
68253: PPUSH
68254: PPUSH
68255: PPUSH
68256: PPUSH
// if not mc_bases or not skirmish then
68257: LD_EXP 102
68261: NOT
68262: PUSH
68263: LD_EXP 100
68267: NOT
68268: OR
68269: IFFALSE 68273
// exit ;
68271: GO 68934
// for i = 1 to mc_bases do
68273: LD_ADDR_VAR 0 3
68277: PUSH
68278: DOUBLE
68279: LD_INT 1
68281: DEC
68282: ST_TO_ADDR
68283: LD_EXP 102
68287: PUSH
68288: FOR_TO
68289: IFFALSE 68932
// begin if building in mc_construct_list [ i ] then
68291: LD_VAR 0 1
68295: PUSH
68296: LD_EXP 109
68300: PUSH
68301: LD_VAR 0 3
68305: ARRAY
68306: IN
68307: IFFALSE 68930
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68309: LD_ADDR_EXP 109
68313: PUSH
68314: LD_EXP 109
68318: PPUSH
68319: LD_VAR 0 3
68323: PPUSH
68324: LD_EXP 109
68328: PUSH
68329: LD_VAR 0 3
68333: ARRAY
68334: PUSH
68335: LD_VAR 0 1
68339: DIFF
68340: PPUSH
68341: CALL_OW 1
68345: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68346: LD_ADDR_EXP 102
68350: PUSH
68351: LD_EXP 102
68355: PPUSH
68356: LD_VAR 0 3
68360: PUSH
68361: LD_EXP 102
68365: PUSH
68366: LD_VAR 0 3
68370: ARRAY
68371: PUSH
68372: LD_INT 1
68374: PLUS
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PPUSH
68380: LD_VAR 0 1
68384: PPUSH
68385: CALL 74553 0 3
68389: ST_TO_ADDR
// btype := GetBType ( building ) ;
68390: LD_ADDR_VAR 0 5
68394: PUSH
68395: LD_VAR 0 1
68399: PPUSH
68400: CALL_OW 266
68404: ST_TO_ADDR
// side := GetSide ( building ) ;
68405: LD_ADDR_VAR 0 8
68409: PUSH
68410: LD_VAR 0 1
68414: PPUSH
68415: CALL_OW 255
68419: ST_TO_ADDR
// if btype = b_lab then
68420: LD_VAR 0 5
68424: PUSH
68425: LD_INT 6
68427: EQUAL
68428: IFFALSE 68478
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68430: LD_ADDR_EXP 135
68434: PUSH
68435: LD_EXP 135
68439: PPUSH
68440: LD_VAR 0 3
68444: PUSH
68445: LD_EXP 135
68449: PUSH
68450: LD_VAR 0 3
68454: ARRAY
68455: PUSH
68456: LD_INT 1
68458: PLUS
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PPUSH
68464: LD_VAR 0 1
68468: PPUSH
68469: CALL 74553 0 3
68473: ST_TO_ADDR
// exit ;
68474: POP
68475: POP
68476: GO 68934
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68478: LD_VAR 0 5
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 2
68488: PUSH
68489: LD_INT 4
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: LIST
68496: IN
68497: IFFALSE 68621
// begin if btype = b_armoury then
68499: LD_VAR 0 5
68503: PUSH
68504: LD_INT 4
68506: EQUAL
68507: IFFALSE 68517
// btype := b_barracks ;
68509: LD_ADDR_VAR 0 5
68513: PUSH
68514: LD_INT 5
68516: ST_TO_ADDR
// if btype = b_depot then
68517: LD_VAR 0 5
68521: PUSH
68522: LD_INT 0
68524: EQUAL
68525: IFFALSE 68535
// btype := b_warehouse ;
68527: LD_ADDR_VAR 0 5
68531: PUSH
68532: LD_INT 1
68534: ST_TO_ADDR
// if btype = b_workshop then
68535: LD_VAR 0 5
68539: PUSH
68540: LD_INT 2
68542: EQUAL
68543: IFFALSE 68553
// btype := b_factory ;
68545: LD_ADDR_VAR 0 5
68549: PUSH
68550: LD_INT 3
68552: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68553: LD_VAR 0 5
68557: PPUSH
68558: LD_VAR 0 8
68562: PPUSH
68563: CALL_OW 323
68567: PUSH
68568: LD_INT 1
68570: EQUAL
68571: IFFALSE 68617
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68573: LD_ADDR_EXP 134
68577: PUSH
68578: LD_EXP 134
68582: PPUSH
68583: LD_VAR 0 3
68587: PUSH
68588: LD_EXP 134
68592: PUSH
68593: LD_VAR 0 3
68597: ARRAY
68598: PUSH
68599: LD_INT 1
68601: PLUS
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PPUSH
68607: LD_VAR 0 1
68611: PPUSH
68612: CALL 74553 0 3
68616: ST_TO_ADDR
// exit ;
68617: POP
68618: POP
68619: GO 68934
// end ; if btype in [ b_bunker , b_turret ] then
68621: LD_VAR 0 5
68625: PUSH
68626: LD_INT 32
68628: PUSH
68629: LD_INT 33
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: IN
68636: IFFALSE 68926
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68638: LD_ADDR_EXP 110
68642: PUSH
68643: LD_EXP 110
68647: PPUSH
68648: LD_VAR 0 3
68652: PUSH
68653: LD_EXP 110
68657: PUSH
68658: LD_VAR 0 3
68662: ARRAY
68663: PUSH
68664: LD_INT 1
68666: PLUS
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PPUSH
68672: LD_VAR 0 1
68676: PPUSH
68677: CALL 74553 0 3
68681: ST_TO_ADDR
// if btype = b_bunker then
68682: LD_VAR 0 5
68686: PUSH
68687: LD_INT 32
68689: EQUAL
68690: IFFALSE 68926
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68692: LD_ADDR_EXP 111
68696: PUSH
68697: LD_EXP 111
68701: PPUSH
68702: LD_VAR 0 3
68706: PUSH
68707: LD_EXP 111
68711: PUSH
68712: LD_VAR 0 3
68716: ARRAY
68717: PUSH
68718: LD_INT 1
68720: PLUS
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PPUSH
68726: LD_VAR 0 1
68730: PPUSH
68731: CALL 74553 0 3
68735: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68736: LD_ADDR_VAR 0 6
68740: PUSH
68741: LD_EXP 102
68745: PUSH
68746: LD_VAR 0 3
68750: ARRAY
68751: PPUSH
68752: LD_INT 25
68754: PUSH
68755: LD_INT 1
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 3
68764: PUSH
68765: LD_INT 54
68767: PUSH
68768: EMPTY
68769: LIST
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PPUSH
68779: CALL_OW 72
68783: ST_TO_ADDR
// if tmp then
68784: LD_VAR 0 6
68788: IFFALSE 68794
// exit ;
68790: POP
68791: POP
68792: GO 68934
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68794: LD_ADDR_VAR 0 6
68798: PUSH
68799: LD_EXP 102
68803: PUSH
68804: LD_VAR 0 3
68808: ARRAY
68809: PPUSH
68810: LD_INT 2
68812: PUSH
68813: LD_INT 30
68815: PUSH
68816: LD_INT 4
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PUSH
68823: LD_INT 30
68825: PUSH
68826: LD_INT 5
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: LIST
68837: PPUSH
68838: CALL_OW 72
68842: ST_TO_ADDR
// if not tmp then
68843: LD_VAR 0 6
68847: NOT
68848: IFFALSE 68854
// exit ;
68850: POP
68851: POP
68852: GO 68934
// for j in tmp do
68854: LD_ADDR_VAR 0 4
68858: PUSH
68859: LD_VAR 0 6
68863: PUSH
68864: FOR_IN
68865: IFFALSE 68924
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68867: LD_ADDR_VAR 0 7
68871: PUSH
68872: LD_VAR 0 4
68876: PPUSH
68877: CALL_OW 313
68881: PPUSH
68882: LD_INT 25
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PPUSH
68892: CALL_OW 72
68896: ST_TO_ADDR
// if units then
68897: LD_VAR 0 7
68901: IFFALSE 68922
// begin ComExitBuilding ( units [ 1 ] ) ;
68903: LD_VAR 0 7
68907: PUSH
68908: LD_INT 1
68910: ARRAY
68911: PPUSH
68912: CALL_OW 122
// exit ;
68916: POP
68917: POP
68918: POP
68919: POP
68920: GO 68934
// end ; end ;
68922: GO 68864
68924: POP
68925: POP
// end ; end ; exit ;
68926: POP
68927: POP
68928: GO 68934
// end ; end ;
68930: GO 68288
68932: POP
68933: POP
// end ;
68934: LD_VAR 0 2
68938: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68939: LD_INT 0
68941: PPUSH
68942: PPUSH
68943: PPUSH
68944: PPUSH
68945: PPUSH
68946: PPUSH
68947: PPUSH
// if not mc_bases or not skirmish then
68948: LD_EXP 102
68952: NOT
68953: PUSH
68954: LD_EXP 100
68958: NOT
68959: OR
68960: IFFALSE 68964
// exit ;
68962: GO 69229
// btype := GetBType ( building ) ;
68964: LD_ADDR_VAR 0 6
68968: PUSH
68969: LD_VAR 0 1
68973: PPUSH
68974: CALL_OW 266
68978: ST_TO_ADDR
// x := GetX ( building ) ;
68979: LD_ADDR_VAR 0 7
68983: PUSH
68984: LD_VAR 0 1
68988: PPUSH
68989: CALL_OW 250
68993: ST_TO_ADDR
// y := GetY ( building ) ;
68994: LD_ADDR_VAR 0 8
68998: PUSH
68999: LD_VAR 0 1
69003: PPUSH
69004: CALL_OW 251
69008: ST_TO_ADDR
// d := GetDir ( building ) ;
69009: LD_ADDR_VAR 0 9
69013: PUSH
69014: LD_VAR 0 1
69018: PPUSH
69019: CALL_OW 254
69023: ST_TO_ADDR
// for i = 1 to mc_bases do
69024: LD_ADDR_VAR 0 4
69028: PUSH
69029: DOUBLE
69030: LD_INT 1
69032: DEC
69033: ST_TO_ADDR
69034: LD_EXP 102
69038: PUSH
69039: FOR_TO
69040: IFFALSE 69227
// begin if not mc_build_list [ i ] then
69042: LD_EXP 107
69046: PUSH
69047: LD_VAR 0 4
69051: ARRAY
69052: NOT
69053: IFFALSE 69057
// continue ;
69055: GO 69039
// for j := 1 to mc_build_list [ i ] do
69057: LD_ADDR_VAR 0 5
69061: PUSH
69062: DOUBLE
69063: LD_INT 1
69065: DEC
69066: ST_TO_ADDR
69067: LD_EXP 107
69071: PUSH
69072: LD_VAR 0 4
69076: ARRAY
69077: PUSH
69078: FOR_TO
69079: IFFALSE 69223
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69081: LD_VAR 0 6
69085: PUSH
69086: LD_VAR 0 7
69090: PUSH
69091: LD_VAR 0 8
69095: PUSH
69096: LD_VAR 0 9
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: PPUSH
69107: LD_EXP 107
69111: PUSH
69112: LD_VAR 0 4
69116: ARRAY
69117: PUSH
69118: LD_VAR 0 5
69122: ARRAY
69123: PPUSH
69124: CALL 81110 0 2
69128: IFFALSE 69221
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69130: LD_ADDR_EXP 107
69134: PUSH
69135: LD_EXP 107
69139: PPUSH
69140: LD_VAR 0 4
69144: PPUSH
69145: LD_EXP 107
69149: PUSH
69150: LD_VAR 0 4
69154: ARRAY
69155: PPUSH
69156: LD_VAR 0 5
69160: PPUSH
69161: CALL_OW 3
69165: PPUSH
69166: CALL_OW 1
69170: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69171: LD_ADDR_EXP 109
69175: PUSH
69176: LD_EXP 109
69180: PPUSH
69181: LD_VAR 0 4
69185: PUSH
69186: LD_EXP 109
69190: PUSH
69191: LD_VAR 0 4
69195: ARRAY
69196: PUSH
69197: LD_INT 1
69199: PLUS
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PPUSH
69205: LD_VAR 0 1
69209: PPUSH
69210: CALL 74553 0 3
69214: ST_TO_ADDR
// exit ;
69215: POP
69216: POP
69217: POP
69218: POP
69219: GO 69229
// end ;
69221: GO 69078
69223: POP
69224: POP
// end ;
69225: GO 69039
69227: POP
69228: POP
// end ;
69229: LD_VAR 0 3
69233: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69234: LD_INT 0
69236: PPUSH
69237: PPUSH
69238: PPUSH
// if not mc_bases or not skirmish then
69239: LD_EXP 102
69243: NOT
69244: PUSH
69245: LD_EXP 100
69249: NOT
69250: OR
69251: IFFALSE 69255
// exit ;
69253: GO 69445
// for i = 1 to mc_bases do
69255: LD_ADDR_VAR 0 4
69259: PUSH
69260: DOUBLE
69261: LD_INT 1
69263: DEC
69264: ST_TO_ADDR
69265: LD_EXP 102
69269: PUSH
69270: FOR_TO
69271: IFFALSE 69358
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69273: LD_VAR 0 1
69277: PUSH
69278: LD_EXP 110
69282: PUSH
69283: LD_VAR 0 4
69287: ARRAY
69288: IN
69289: PUSH
69290: LD_VAR 0 1
69294: PUSH
69295: LD_EXP 111
69299: PUSH
69300: LD_VAR 0 4
69304: ARRAY
69305: IN
69306: NOT
69307: AND
69308: IFFALSE 69356
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69310: LD_ADDR_EXP 111
69314: PUSH
69315: LD_EXP 111
69319: PPUSH
69320: LD_VAR 0 4
69324: PUSH
69325: LD_EXP 111
69329: PUSH
69330: LD_VAR 0 4
69334: ARRAY
69335: PUSH
69336: LD_INT 1
69338: PLUS
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PPUSH
69344: LD_VAR 0 1
69348: PPUSH
69349: CALL 74553 0 3
69353: ST_TO_ADDR
// break ;
69354: GO 69358
// end ; end ;
69356: GO 69270
69358: POP
69359: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69360: LD_VAR 0 1
69364: PPUSH
69365: CALL_OW 257
69369: PUSH
69370: LD_EXP 128
69374: IN
69375: PUSH
69376: LD_VAR 0 1
69380: PPUSH
69381: CALL_OW 266
69385: PUSH
69386: LD_INT 5
69388: EQUAL
69389: AND
69390: PUSH
69391: LD_VAR 0 2
69395: PPUSH
69396: CALL_OW 110
69400: PUSH
69401: LD_INT 18
69403: NONEQUAL
69404: AND
69405: IFFALSE 69445
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69407: LD_VAR 0 2
69411: PPUSH
69412: CALL_OW 257
69416: PUSH
69417: LD_INT 5
69419: PUSH
69420: LD_INT 8
69422: PUSH
69423: LD_INT 9
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: LIST
69430: IN
69431: IFFALSE 69445
// SetClass ( unit , 1 ) ;
69433: LD_VAR 0 2
69437: PPUSH
69438: LD_INT 1
69440: PPUSH
69441: CALL_OW 336
// end ;
69445: LD_VAR 0 3
69449: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69450: LD_INT 0
69452: PPUSH
69453: PPUSH
// if not mc_bases or not skirmish then
69454: LD_EXP 102
69458: NOT
69459: PUSH
69460: LD_EXP 100
69464: NOT
69465: OR
69466: IFFALSE 69470
// exit ;
69468: GO 69586
// if GetLives ( abandoned_vehicle ) > 250 then
69470: LD_VAR 0 2
69474: PPUSH
69475: CALL_OW 256
69479: PUSH
69480: LD_INT 250
69482: GREATER
69483: IFFALSE 69487
// exit ;
69485: GO 69586
// for i = 1 to mc_bases do
69487: LD_ADDR_VAR 0 6
69491: PUSH
69492: DOUBLE
69493: LD_INT 1
69495: DEC
69496: ST_TO_ADDR
69497: LD_EXP 102
69501: PUSH
69502: FOR_TO
69503: IFFALSE 69584
// begin if driver in mc_bases [ i ] then
69505: LD_VAR 0 1
69509: PUSH
69510: LD_EXP 102
69514: PUSH
69515: LD_VAR 0 6
69519: ARRAY
69520: IN
69521: IFFALSE 69582
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69523: LD_VAR 0 1
69527: PPUSH
69528: LD_EXP 102
69532: PUSH
69533: LD_VAR 0 6
69537: ARRAY
69538: PPUSH
69539: LD_INT 2
69541: PUSH
69542: LD_INT 30
69544: PUSH
69545: LD_INT 0
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 30
69554: PUSH
69555: LD_INT 1
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: LIST
69566: PPUSH
69567: CALL_OW 72
69571: PUSH
69572: LD_INT 1
69574: ARRAY
69575: PPUSH
69576: CALL 108159 0 2
// break ;
69580: GO 69584
// end ; end ;
69582: GO 69502
69584: POP
69585: POP
// end ; end_of_file
69586: LD_VAR 0 5
69590: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69591: LD_INT 0
69593: PPUSH
69594: PPUSH
// if exist_mode then
69595: LD_VAR 0 2
69599: IFFALSE 69624
// unit := CreateCharacter ( prefix & ident ) else
69601: LD_ADDR_VAR 0 5
69605: PUSH
69606: LD_VAR 0 3
69610: PUSH
69611: LD_VAR 0 1
69615: STR
69616: PPUSH
69617: CALL_OW 34
69621: ST_TO_ADDR
69622: GO 69639
// unit := NewCharacter ( ident ) ;
69624: LD_ADDR_VAR 0 5
69628: PUSH
69629: LD_VAR 0 1
69633: PPUSH
69634: CALL_OW 25
69638: ST_TO_ADDR
// result := unit ;
69639: LD_ADDR_VAR 0 4
69643: PUSH
69644: LD_VAR 0 5
69648: ST_TO_ADDR
// end ;
69649: LD_VAR 0 4
69653: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69654: LD_INT 0
69656: PPUSH
69657: PPUSH
// if not side or not nation then
69658: LD_VAR 0 1
69662: NOT
69663: PUSH
69664: LD_VAR 0 2
69668: NOT
69669: OR
69670: IFFALSE 69674
// exit ;
69672: GO 70442
// case nation of nation_american :
69674: LD_VAR 0 2
69678: PUSH
69679: LD_INT 1
69681: DOUBLE
69682: EQUAL
69683: IFTRUE 69687
69685: GO 69901
69687: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69688: LD_ADDR_VAR 0 4
69692: PUSH
69693: LD_INT 35
69695: PUSH
69696: LD_INT 45
69698: PUSH
69699: LD_INT 46
69701: PUSH
69702: LD_INT 47
69704: PUSH
69705: LD_INT 82
69707: PUSH
69708: LD_INT 83
69710: PUSH
69711: LD_INT 84
69713: PUSH
69714: LD_INT 85
69716: PUSH
69717: LD_INT 86
69719: PUSH
69720: LD_INT 1
69722: PUSH
69723: LD_INT 2
69725: PUSH
69726: LD_INT 6
69728: PUSH
69729: LD_INT 15
69731: PUSH
69732: LD_INT 16
69734: PUSH
69735: LD_INT 7
69737: PUSH
69738: LD_INT 12
69740: PUSH
69741: LD_INT 13
69743: PUSH
69744: LD_INT 10
69746: PUSH
69747: LD_INT 14
69749: PUSH
69750: LD_INT 20
69752: PUSH
69753: LD_INT 21
69755: PUSH
69756: LD_INT 22
69758: PUSH
69759: LD_INT 25
69761: PUSH
69762: LD_INT 32
69764: PUSH
69765: LD_INT 27
69767: PUSH
69768: LD_INT 36
69770: PUSH
69771: LD_INT 69
69773: PUSH
69774: LD_INT 39
69776: PUSH
69777: LD_INT 34
69779: PUSH
69780: LD_INT 40
69782: PUSH
69783: LD_INT 48
69785: PUSH
69786: LD_INT 49
69788: PUSH
69789: LD_INT 50
69791: PUSH
69792: LD_INT 51
69794: PUSH
69795: LD_INT 52
69797: PUSH
69798: LD_INT 53
69800: PUSH
69801: LD_INT 54
69803: PUSH
69804: LD_INT 55
69806: PUSH
69807: LD_INT 56
69809: PUSH
69810: LD_INT 57
69812: PUSH
69813: LD_INT 58
69815: PUSH
69816: LD_INT 59
69818: PUSH
69819: LD_INT 60
69821: PUSH
69822: LD_INT 61
69824: PUSH
69825: LD_INT 62
69827: PUSH
69828: LD_INT 80
69830: PUSH
69831: LD_INT 82
69833: PUSH
69834: LD_INT 83
69836: PUSH
69837: LD_INT 84
69839: PUSH
69840: LD_INT 85
69842: PUSH
69843: LD_INT 86
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: LIST
69895: LIST
69896: LIST
69897: LIST
69898: ST_TO_ADDR
69899: GO 70366
69901: LD_INT 2
69903: DOUBLE
69904: EQUAL
69905: IFTRUE 69909
69907: GO 70135
69909: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69910: LD_ADDR_VAR 0 4
69914: PUSH
69915: LD_INT 35
69917: PUSH
69918: LD_INT 45
69920: PUSH
69921: LD_INT 46
69923: PUSH
69924: LD_INT 47
69926: PUSH
69927: LD_INT 82
69929: PUSH
69930: LD_INT 83
69932: PUSH
69933: LD_INT 84
69935: PUSH
69936: LD_INT 85
69938: PUSH
69939: LD_INT 87
69941: PUSH
69942: LD_INT 70
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: LD_INT 11
69950: PUSH
69951: LD_INT 3
69953: PUSH
69954: LD_INT 4
69956: PUSH
69957: LD_INT 5
69959: PUSH
69960: LD_INT 6
69962: PUSH
69963: LD_INT 15
69965: PUSH
69966: LD_INT 18
69968: PUSH
69969: LD_INT 7
69971: PUSH
69972: LD_INT 17
69974: PUSH
69975: LD_INT 8
69977: PUSH
69978: LD_INT 20
69980: PUSH
69981: LD_INT 21
69983: PUSH
69984: LD_INT 22
69986: PUSH
69987: LD_INT 72
69989: PUSH
69990: LD_INT 26
69992: PUSH
69993: LD_INT 69
69995: PUSH
69996: LD_INT 39
69998: PUSH
69999: LD_INT 40
70001: PUSH
70002: LD_INT 41
70004: PUSH
70005: LD_INT 42
70007: PUSH
70008: LD_INT 43
70010: PUSH
70011: LD_INT 48
70013: PUSH
70014: LD_INT 49
70016: PUSH
70017: LD_INT 50
70019: PUSH
70020: LD_INT 51
70022: PUSH
70023: LD_INT 52
70025: PUSH
70026: LD_INT 53
70028: PUSH
70029: LD_INT 54
70031: PUSH
70032: LD_INT 55
70034: PUSH
70035: LD_INT 56
70037: PUSH
70038: LD_INT 60
70040: PUSH
70041: LD_INT 61
70043: PUSH
70044: LD_INT 62
70046: PUSH
70047: LD_INT 66
70049: PUSH
70050: LD_INT 67
70052: PUSH
70053: LD_INT 68
70055: PUSH
70056: LD_INT 81
70058: PUSH
70059: LD_INT 82
70061: PUSH
70062: LD_INT 83
70064: PUSH
70065: LD_INT 84
70067: PUSH
70068: LD_INT 85
70070: PUSH
70071: LD_INT 87
70073: PUSH
70074: LD_INT 88
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: ST_TO_ADDR
70133: GO 70366
70135: LD_INT 3
70137: DOUBLE
70138: EQUAL
70139: IFTRUE 70143
70141: GO 70365
70143: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70144: LD_ADDR_VAR 0 4
70148: PUSH
70149: LD_INT 46
70151: PUSH
70152: LD_INT 47
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: LD_INT 2
70160: PUSH
70161: LD_INT 82
70163: PUSH
70164: LD_INT 83
70166: PUSH
70167: LD_INT 84
70169: PUSH
70170: LD_INT 85
70172: PUSH
70173: LD_INT 86
70175: PUSH
70176: LD_INT 11
70178: PUSH
70179: LD_INT 9
70181: PUSH
70182: LD_INT 20
70184: PUSH
70185: LD_INT 19
70187: PUSH
70188: LD_INT 21
70190: PUSH
70191: LD_INT 24
70193: PUSH
70194: LD_INT 22
70196: PUSH
70197: LD_INT 25
70199: PUSH
70200: LD_INT 28
70202: PUSH
70203: LD_INT 29
70205: PUSH
70206: LD_INT 30
70208: PUSH
70209: LD_INT 31
70211: PUSH
70212: LD_INT 37
70214: PUSH
70215: LD_INT 38
70217: PUSH
70218: LD_INT 32
70220: PUSH
70221: LD_INT 27
70223: PUSH
70224: LD_INT 33
70226: PUSH
70227: LD_INT 69
70229: PUSH
70230: LD_INT 39
70232: PUSH
70233: LD_INT 34
70235: PUSH
70236: LD_INT 40
70238: PUSH
70239: LD_INT 71
70241: PUSH
70242: LD_INT 23
70244: PUSH
70245: LD_INT 44
70247: PUSH
70248: LD_INT 48
70250: PUSH
70251: LD_INT 49
70253: PUSH
70254: LD_INT 50
70256: PUSH
70257: LD_INT 51
70259: PUSH
70260: LD_INT 52
70262: PUSH
70263: LD_INT 53
70265: PUSH
70266: LD_INT 54
70268: PUSH
70269: LD_INT 55
70271: PUSH
70272: LD_INT 56
70274: PUSH
70275: LD_INT 57
70277: PUSH
70278: LD_INT 58
70280: PUSH
70281: LD_INT 59
70283: PUSH
70284: LD_INT 63
70286: PUSH
70287: LD_INT 64
70289: PUSH
70290: LD_INT 65
70292: PUSH
70293: LD_INT 82
70295: PUSH
70296: LD_INT 83
70298: PUSH
70299: LD_INT 84
70301: PUSH
70302: LD_INT 85
70304: PUSH
70305: LD_INT 86
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: ST_TO_ADDR
70363: GO 70366
70365: POP
// if state > - 1 and state < 3 then
70366: LD_VAR 0 3
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: GREATER
70375: PUSH
70376: LD_VAR 0 3
70380: PUSH
70381: LD_INT 3
70383: LESS
70384: AND
70385: IFFALSE 70442
// for i in result do
70387: LD_ADDR_VAR 0 5
70391: PUSH
70392: LD_VAR 0 4
70396: PUSH
70397: FOR_IN
70398: IFFALSE 70440
// if GetTech ( i , side ) <> state then
70400: LD_VAR 0 5
70404: PPUSH
70405: LD_VAR 0 1
70409: PPUSH
70410: CALL_OW 321
70414: PUSH
70415: LD_VAR 0 3
70419: NONEQUAL
70420: IFFALSE 70438
// result := result diff i ;
70422: LD_ADDR_VAR 0 4
70426: PUSH
70427: LD_VAR 0 4
70431: PUSH
70432: LD_VAR 0 5
70436: DIFF
70437: ST_TO_ADDR
70438: GO 70397
70440: POP
70441: POP
// end ;
70442: LD_VAR 0 4
70446: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70447: LD_INT 0
70449: PPUSH
70450: PPUSH
70451: PPUSH
// result := true ;
70452: LD_ADDR_VAR 0 3
70456: PUSH
70457: LD_INT 1
70459: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70460: LD_ADDR_VAR 0 5
70464: PUSH
70465: LD_VAR 0 2
70469: PPUSH
70470: CALL_OW 480
70474: ST_TO_ADDR
// if not tmp then
70475: LD_VAR 0 5
70479: NOT
70480: IFFALSE 70484
// exit ;
70482: GO 70533
// for i in tmp do
70484: LD_ADDR_VAR 0 4
70488: PUSH
70489: LD_VAR 0 5
70493: PUSH
70494: FOR_IN
70495: IFFALSE 70531
// if GetTech ( i , side ) <> state_researched then
70497: LD_VAR 0 4
70501: PPUSH
70502: LD_VAR 0 1
70506: PPUSH
70507: CALL_OW 321
70511: PUSH
70512: LD_INT 2
70514: NONEQUAL
70515: IFFALSE 70529
// begin result := false ;
70517: LD_ADDR_VAR 0 3
70521: PUSH
70522: LD_INT 0
70524: ST_TO_ADDR
// exit ;
70525: POP
70526: POP
70527: GO 70533
// end ;
70529: GO 70494
70531: POP
70532: POP
// end ;
70533: LD_VAR 0 3
70537: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70538: LD_INT 0
70540: PPUSH
70541: PPUSH
70542: PPUSH
70543: PPUSH
70544: PPUSH
70545: PPUSH
70546: PPUSH
70547: PPUSH
70548: PPUSH
70549: PPUSH
70550: PPUSH
70551: PPUSH
70552: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70553: LD_VAR 0 1
70557: NOT
70558: PUSH
70559: LD_VAR 0 1
70563: PPUSH
70564: CALL_OW 257
70568: PUSH
70569: LD_INT 9
70571: NONEQUAL
70572: OR
70573: IFFALSE 70577
// exit ;
70575: GO 71150
// side := GetSide ( unit ) ;
70577: LD_ADDR_VAR 0 9
70581: PUSH
70582: LD_VAR 0 1
70586: PPUSH
70587: CALL_OW 255
70591: ST_TO_ADDR
// tech_space := tech_spacanom ;
70592: LD_ADDR_VAR 0 12
70596: PUSH
70597: LD_INT 29
70599: ST_TO_ADDR
// tech_time := tech_taurad ;
70600: LD_ADDR_VAR 0 13
70604: PUSH
70605: LD_INT 28
70607: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70608: LD_ADDR_VAR 0 11
70612: PUSH
70613: LD_VAR 0 1
70617: PPUSH
70618: CALL_OW 310
70622: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70623: LD_VAR 0 11
70627: PPUSH
70628: CALL_OW 247
70632: PUSH
70633: LD_INT 2
70635: EQUAL
70636: IFFALSE 70640
// exit ;
70638: GO 71150
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70640: LD_ADDR_VAR 0 8
70644: PUSH
70645: LD_INT 81
70647: PUSH
70648: LD_VAR 0 9
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 3
70659: PUSH
70660: LD_INT 21
70662: PUSH
70663: LD_INT 3
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PPUSH
70678: CALL_OW 69
70682: ST_TO_ADDR
// if not tmp then
70683: LD_VAR 0 8
70687: NOT
70688: IFFALSE 70692
// exit ;
70690: GO 71150
// if in_unit then
70692: LD_VAR 0 11
70696: IFFALSE 70720
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70698: LD_ADDR_VAR 0 10
70702: PUSH
70703: LD_VAR 0 8
70707: PPUSH
70708: LD_VAR 0 11
70712: PPUSH
70713: CALL_OW 74
70717: ST_TO_ADDR
70718: GO 70740
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70720: LD_ADDR_VAR 0 10
70724: PUSH
70725: LD_VAR 0 8
70729: PPUSH
70730: LD_VAR 0 1
70734: PPUSH
70735: CALL_OW 74
70739: ST_TO_ADDR
// if not enemy then
70740: LD_VAR 0 10
70744: NOT
70745: IFFALSE 70749
// exit ;
70747: GO 71150
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70749: LD_VAR 0 11
70753: PUSH
70754: LD_VAR 0 11
70758: PPUSH
70759: LD_VAR 0 10
70763: PPUSH
70764: CALL_OW 296
70768: PUSH
70769: LD_INT 13
70771: GREATER
70772: AND
70773: PUSH
70774: LD_VAR 0 1
70778: PPUSH
70779: LD_VAR 0 10
70783: PPUSH
70784: CALL_OW 296
70788: PUSH
70789: LD_INT 12
70791: GREATER
70792: OR
70793: IFFALSE 70797
// exit ;
70795: GO 71150
// missile := [ 1 ] ;
70797: LD_ADDR_VAR 0 14
70801: PUSH
70802: LD_INT 1
70804: PUSH
70805: EMPTY
70806: LIST
70807: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70808: LD_VAR 0 9
70812: PPUSH
70813: LD_VAR 0 12
70817: PPUSH
70818: CALL_OW 325
70822: IFFALSE 70851
// missile := Replace ( missile , missile + 1 , 2 ) ;
70824: LD_ADDR_VAR 0 14
70828: PUSH
70829: LD_VAR 0 14
70833: PPUSH
70834: LD_VAR 0 14
70838: PUSH
70839: LD_INT 1
70841: PLUS
70842: PPUSH
70843: LD_INT 2
70845: PPUSH
70846: CALL_OW 1
70850: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70851: LD_VAR 0 9
70855: PPUSH
70856: LD_VAR 0 13
70860: PPUSH
70861: CALL_OW 325
70865: PUSH
70866: LD_VAR 0 10
70870: PPUSH
70871: CALL_OW 255
70875: PPUSH
70876: LD_VAR 0 13
70880: PPUSH
70881: CALL_OW 325
70885: NOT
70886: AND
70887: IFFALSE 70916
// missile := Replace ( missile , missile + 1 , 3 ) ;
70889: LD_ADDR_VAR 0 14
70893: PUSH
70894: LD_VAR 0 14
70898: PPUSH
70899: LD_VAR 0 14
70903: PUSH
70904: LD_INT 1
70906: PLUS
70907: PPUSH
70908: LD_INT 3
70910: PPUSH
70911: CALL_OW 1
70915: ST_TO_ADDR
// if missile < 2 then
70916: LD_VAR 0 14
70920: PUSH
70921: LD_INT 2
70923: LESS
70924: IFFALSE 70928
// exit ;
70926: GO 71150
// x := GetX ( enemy ) ;
70928: LD_ADDR_VAR 0 4
70932: PUSH
70933: LD_VAR 0 10
70937: PPUSH
70938: CALL_OW 250
70942: ST_TO_ADDR
// y := GetY ( enemy ) ;
70943: LD_ADDR_VAR 0 5
70947: PUSH
70948: LD_VAR 0 10
70952: PPUSH
70953: CALL_OW 251
70957: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70958: LD_ADDR_VAR 0 6
70962: PUSH
70963: LD_VAR 0 4
70967: PUSH
70968: LD_INT 1
70970: NEG
70971: PPUSH
70972: LD_INT 1
70974: PPUSH
70975: CALL_OW 12
70979: PLUS
70980: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70981: LD_ADDR_VAR 0 7
70985: PUSH
70986: LD_VAR 0 5
70990: PUSH
70991: LD_INT 1
70993: NEG
70994: PPUSH
70995: LD_INT 1
70997: PPUSH
70998: CALL_OW 12
71002: PLUS
71003: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71004: LD_VAR 0 6
71008: PPUSH
71009: LD_VAR 0 7
71013: PPUSH
71014: CALL_OW 488
71018: NOT
71019: IFFALSE 71041
// begin _x := x ;
71021: LD_ADDR_VAR 0 6
71025: PUSH
71026: LD_VAR 0 4
71030: ST_TO_ADDR
// _y := y ;
71031: LD_ADDR_VAR 0 7
71035: PUSH
71036: LD_VAR 0 5
71040: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71041: LD_ADDR_VAR 0 3
71045: PUSH
71046: LD_INT 1
71048: PPUSH
71049: LD_VAR 0 14
71053: PPUSH
71054: CALL_OW 12
71058: ST_TO_ADDR
// case i of 1 :
71059: LD_VAR 0 3
71063: PUSH
71064: LD_INT 1
71066: DOUBLE
71067: EQUAL
71068: IFTRUE 71072
71070: GO 71089
71072: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71073: LD_VAR 0 1
71077: PPUSH
71078: LD_VAR 0 10
71082: PPUSH
71083: CALL_OW 115
71087: GO 71150
71089: LD_INT 2
71091: DOUBLE
71092: EQUAL
71093: IFTRUE 71097
71095: GO 71119
71097: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71098: LD_VAR 0 1
71102: PPUSH
71103: LD_VAR 0 6
71107: PPUSH
71108: LD_VAR 0 7
71112: PPUSH
71113: CALL_OW 153
71117: GO 71150
71119: LD_INT 3
71121: DOUBLE
71122: EQUAL
71123: IFTRUE 71127
71125: GO 71149
71127: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71128: LD_VAR 0 1
71132: PPUSH
71133: LD_VAR 0 6
71137: PPUSH
71138: LD_VAR 0 7
71142: PPUSH
71143: CALL_OW 154
71147: GO 71150
71149: POP
// end ;
71150: LD_VAR 0 2
71154: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71155: LD_INT 0
71157: PPUSH
71158: PPUSH
71159: PPUSH
71160: PPUSH
71161: PPUSH
71162: PPUSH
// if not unit or not building then
71163: LD_VAR 0 1
71167: NOT
71168: PUSH
71169: LD_VAR 0 2
71173: NOT
71174: OR
71175: IFFALSE 71179
// exit ;
71177: GO 71337
// x := GetX ( building ) ;
71179: LD_ADDR_VAR 0 5
71183: PUSH
71184: LD_VAR 0 2
71188: PPUSH
71189: CALL_OW 250
71193: ST_TO_ADDR
// y := GetY ( building ) ;
71194: LD_ADDR_VAR 0 6
71198: PUSH
71199: LD_VAR 0 2
71203: PPUSH
71204: CALL_OW 251
71208: ST_TO_ADDR
// for i = 0 to 5 do
71209: LD_ADDR_VAR 0 4
71213: PUSH
71214: DOUBLE
71215: LD_INT 0
71217: DEC
71218: ST_TO_ADDR
71219: LD_INT 5
71221: PUSH
71222: FOR_TO
71223: IFFALSE 71335
// begin _x := ShiftX ( x , i , 3 ) ;
71225: LD_ADDR_VAR 0 7
71229: PUSH
71230: LD_VAR 0 5
71234: PPUSH
71235: LD_VAR 0 4
71239: PPUSH
71240: LD_INT 3
71242: PPUSH
71243: CALL_OW 272
71247: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71248: LD_ADDR_VAR 0 8
71252: PUSH
71253: LD_VAR 0 6
71257: PPUSH
71258: LD_VAR 0 4
71262: PPUSH
71263: LD_INT 3
71265: PPUSH
71266: CALL_OW 273
71270: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71271: LD_VAR 0 7
71275: PPUSH
71276: LD_VAR 0 8
71280: PPUSH
71281: CALL_OW 488
71285: NOT
71286: IFFALSE 71290
// continue ;
71288: GO 71222
// if HexInfo ( _x , _y ) = 0 then
71290: LD_VAR 0 7
71294: PPUSH
71295: LD_VAR 0 8
71299: PPUSH
71300: CALL_OW 428
71304: PUSH
71305: LD_INT 0
71307: EQUAL
71308: IFFALSE 71333
// begin ComMoveXY ( unit , _x , _y ) ;
71310: LD_VAR 0 1
71314: PPUSH
71315: LD_VAR 0 7
71319: PPUSH
71320: LD_VAR 0 8
71324: PPUSH
71325: CALL_OW 111
// exit ;
71329: POP
71330: POP
71331: GO 71337
// end ; end ;
71333: GO 71222
71335: POP
71336: POP
// end ;
71337: LD_VAR 0 3
71341: RET
// export function ScanBase ( side , base_area ) ; begin
71342: LD_INT 0
71344: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71345: LD_ADDR_VAR 0 3
71349: PUSH
71350: LD_VAR 0 2
71354: PPUSH
71355: LD_INT 81
71357: PUSH
71358: LD_VAR 0 1
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PPUSH
71367: CALL_OW 70
71371: ST_TO_ADDR
// end ;
71372: LD_VAR 0 3
71376: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71377: LD_INT 0
71379: PPUSH
71380: PPUSH
71381: PPUSH
71382: PPUSH
// result := false ;
71383: LD_ADDR_VAR 0 2
71387: PUSH
71388: LD_INT 0
71390: ST_TO_ADDR
// side := GetSide ( unit ) ;
71391: LD_ADDR_VAR 0 3
71395: PUSH
71396: LD_VAR 0 1
71400: PPUSH
71401: CALL_OW 255
71405: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71406: LD_ADDR_VAR 0 4
71410: PUSH
71411: LD_VAR 0 1
71415: PPUSH
71416: CALL_OW 248
71420: ST_TO_ADDR
// case nat of 1 :
71421: LD_VAR 0 4
71425: PUSH
71426: LD_INT 1
71428: DOUBLE
71429: EQUAL
71430: IFTRUE 71434
71432: GO 71445
71434: POP
// tech := tech_lassight ; 2 :
71435: LD_ADDR_VAR 0 5
71439: PUSH
71440: LD_INT 12
71442: ST_TO_ADDR
71443: GO 71484
71445: LD_INT 2
71447: DOUBLE
71448: EQUAL
71449: IFTRUE 71453
71451: GO 71464
71453: POP
// tech := tech_mortar ; 3 :
71454: LD_ADDR_VAR 0 5
71458: PUSH
71459: LD_INT 41
71461: ST_TO_ADDR
71462: GO 71484
71464: LD_INT 3
71466: DOUBLE
71467: EQUAL
71468: IFTRUE 71472
71470: GO 71483
71472: POP
// tech := tech_bazooka ; end ;
71473: LD_ADDR_VAR 0 5
71477: PUSH
71478: LD_INT 44
71480: ST_TO_ADDR
71481: GO 71484
71483: POP
// if Researched ( side , tech ) then
71484: LD_VAR 0 3
71488: PPUSH
71489: LD_VAR 0 5
71493: PPUSH
71494: CALL_OW 325
71498: IFFALSE 71525
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71500: LD_ADDR_VAR 0 2
71504: PUSH
71505: LD_INT 5
71507: PUSH
71508: LD_INT 8
71510: PUSH
71511: LD_INT 9
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: LIST
71518: PUSH
71519: LD_VAR 0 4
71523: ARRAY
71524: ST_TO_ADDR
// end ;
71525: LD_VAR 0 2
71529: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71530: LD_INT 0
71532: PPUSH
71533: PPUSH
71534: PPUSH
// if not mines then
71535: LD_VAR 0 2
71539: NOT
71540: IFFALSE 71544
// exit ;
71542: GO 71688
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71544: LD_ADDR_VAR 0 5
71548: PUSH
71549: LD_INT 81
71551: PUSH
71552: LD_VAR 0 1
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 3
71563: PUSH
71564: LD_INT 21
71566: PUSH
71567: LD_INT 3
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PPUSH
71582: CALL_OW 69
71586: ST_TO_ADDR
// for i in mines do
71587: LD_ADDR_VAR 0 4
71591: PUSH
71592: LD_VAR 0 2
71596: PUSH
71597: FOR_IN
71598: IFFALSE 71686
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71600: LD_VAR 0 4
71604: PUSH
71605: LD_INT 1
71607: ARRAY
71608: PPUSH
71609: LD_VAR 0 4
71613: PUSH
71614: LD_INT 2
71616: ARRAY
71617: PPUSH
71618: CALL_OW 458
71622: NOT
71623: IFFALSE 71627
// continue ;
71625: GO 71597
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71627: LD_VAR 0 4
71631: PUSH
71632: LD_INT 1
71634: ARRAY
71635: PPUSH
71636: LD_VAR 0 4
71640: PUSH
71641: LD_INT 2
71643: ARRAY
71644: PPUSH
71645: CALL_OW 428
71649: PUSH
71650: LD_VAR 0 5
71654: IN
71655: IFFALSE 71684
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71657: LD_VAR 0 4
71661: PUSH
71662: LD_INT 1
71664: ARRAY
71665: PPUSH
71666: LD_VAR 0 4
71670: PUSH
71671: LD_INT 2
71673: ARRAY
71674: PPUSH
71675: LD_VAR 0 1
71679: PPUSH
71680: CALL_OW 456
// end ;
71684: GO 71597
71686: POP
71687: POP
// end ;
71688: LD_VAR 0 3
71692: RET
// export function Count ( array ) ; begin
71693: LD_INT 0
71695: PPUSH
// result := array + 0 ;
71696: LD_ADDR_VAR 0 2
71700: PUSH
71701: LD_VAR 0 1
71705: PUSH
71706: LD_INT 0
71708: PLUS
71709: ST_TO_ADDR
// end ;
71710: LD_VAR 0 2
71714: RET
// export function IsEmpty ( building ) ; begin
71715: LD_INT 0
71717: PPUSH
// if not building then
71718: LD_VAR 0 1
71722: NOT
71723: IFFALSE 71727
// exit ;
71725: GO 71770
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71727: LD_ADDR_VAR 0 2
71731: PUSH
71732: LD_VAR 0 1
71736: PUSH
71737: LD_INT 22
71739: PUSH
71740: LD_VAR 0 1
71744: PPUSH
71745: CALL_OW 255
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: PUSH
71754: LD_INT 58
71756: PUSH
71757: EMPTY
71758: LIST
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PPUSH
71764: CALL_OW 69
71768: IN
71769: ST_TO_ADDR
// end ;
71770: LD_VAR 0 2
71774: RET
// export function IsNotFull ( building ) ; var places ; begin
71775: LD_INT 0
71777: PPUSH
71778: PPUSH
// if not building then
71779: LD_VAR 0 1
71783: NOT
71784: IFFALSE 71788
// exit ;
71786: GO 71816
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71788: LD_ADDR_VAR 0 2
71792: PUSH
71793: LD_VAR 0 1
71797: PPUSH
71798: LD_INT 3
71800: PUSH
71801: LD_INT 62
71803: PUSH
71804: EMPTY
71805: LIST
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PPUSH
71811: CALL_OW 72
71815: ST_TO_ADDR
// end ;
71816: LD_VAR 0 2
71820: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71821: LD_INT 0
71823: PPUSH
71824: PPUSH
71825: PPUSH
71826: PPUSH
// tmp := [ ] ;
71827: LD_ADDR_VAR 0 3
71831: PUSH
71832: EMPTY
71833: ST_TO_ADDR
// list := [ ] ;
71834: LD_ADDR_VAR 0 5
71838: PUSH
71839: EMPTY
71840: ST_TO_ADDR
// for i = 16 to 25 do
71841: LD_ADDR_VAR 0 4
71845: PUSH
71846: DOUBLE
71847: LD_INT 16
71849: DEC
71850: ST_TO_ADDR
71851: LD_INT 25
71853: PUSH
71854: FOR_TO
71855: IFFALSE 71928
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71857: LD_ADDR_VAR 0 3
71861: PUSH
71862: LD_VAR 0 3
71866: PUSH
71867: LD_INT 22
71869: PUSH
71870: LD_VAR 0 1
71874: PPUSH
71875: CALL_OW 255
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 91
71886: PUSH
71887: LD_VAR 0 1
71891: PUSH
71892: LD_INT 6
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 30
71902: PUSH
71903: LD_VAR 0 4
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: EMPTY
71913: LIST
71914: LIST
71915: LIST
71916: PUSH
71917: EMPTY
71918: LIST
71919: PPUSH
71920: CALL_OW 69
71924: ADD
71925: ST_TO_ADDR
71926: GO 71854
71928: POP
71929: POP
// for i = 1 to tmp do
71930: LD_ADDR_VAR 0 4
71934: PUSH
71935: DOUBLE
71936: LD_INT 1
71938: DEC
71939: ST_TO_ADDR
71940: LD_VAR 0 3
71944: PUSH
71945: FOR_TO
71946: IFFALSE 72034
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71948: LD_ADDR_VAR 0 5
71952: PUSH
71953: LD_VAR 0 5
71957: PUSH
71958: LD_VAR 0 3
71962: PUSH
71963: LD_VAR 0 4
71967: ARRAY
71968: PPUSH
71969: CALL_OW 266
71973: PUSH
71974: LD_VAR 0 3
71978: PUSH
71979: LD_VAR 0 4
71983: ARRAY
71984: PPUSH
71985: CALL_OW 250
71989: PUSH
71990: LD_VAR 0 3
71994: PUSH
71995: LD_VAR 0 4
71999: ARRAY
72000: PPUSH
72001: CALL_OW 251
72005: PUSH
72006: LD_VAR 0 3
72010: PUSH
72011: LD_VAR 0 4
72015: ARRAY
72016: PPUSH
72017: CALL_OW 254
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: PUSH
72028: EMPTY
72029: LIST
72030: ADD
72031: ST_TO_ADDR
72032: GO 71945
72034: POP
72035: POP
// result := list ;
72036: LD_ADDR_VAR 0 2
72040: PUSH
72041: LD_VAR 0 5
72045: ST_TO_ADDR
// end ;
72046: LD_VAR 0 2
72050: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72051: LD_INT 0
72053: PPUSH
72054: PPUSH
72055: PPUSH
72056: PPUSH
72057: PPUSH
72058: PPUSH
72059: PPUSH
// if not factory then
72060: LD_VAR 0 1
72064: NOT
72065: IFFALSE 72069
// exit ;
72067: GO 72662
// if control = control_apeman then
72069: LD_VAR 0 4
72073: PUSH
72074: LD_INT 5
72076: EQUAL
72077: IFFALSE 72186
// begin tmp := UnitsInside ( factory ) ;
72079: LD_ADDR_VAR 0 8
72083: PUSH
72084: LD_VAR 0 1
72088: PPUSH
72089: CALL_OW 313
72093: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72094: LD_VAR 0 8
72098: PPUSH
72099: LD_INT 25
72101: PUSH
72102: LD_INT 12
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PPUSH
72109: CALL_OW 72
72113: NOT
72114: IFFALSE 72124
// control := control_manual ;
72116: LD_ADDR_VAR 0 4
72120: PUSH
72121: LD_INT 1
72123: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72124: LD_ADDR_VAR 0 8
72128: PUSH
72129: LD_VAR 0 1
72133: PPUSH
72134: CALL 71821 0 1
72138: ST_TO_ADDR
// if tmp then
72139: LD_VAR 0 8
72143: IFFALSE 72186
// begin for i in tmp do
72145: LD_ADDR_VAR 0 7
72149: PUSH
72150: LD_VAR 0 8
72154: PUSH
72155: FOR_IN
72156: IFFALSE 72184
// if i [ 1 ] = b_ext_radio then
72158: LD_VAR 0 7
72162: PUSH
72163: LD_INT 1
72165: ARRAY
72166: PUSH
72167: LD_INT 22
72169: EQUAL
72170: IFFALSE 72182
// begin control := control_remote ;
72172: LD_ADDR_VAR 0 4
72176: PUSH
72177: LD_INT 2
72179: ST_TO_ADDR
// break ;
72180: GO 72184
// end ;
72182: GO 72155
72184: POP
72185: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72186: LD_VAR 0 1
72190: PPUSH
72191: LD_VAR 0 2
72195: PPUSH
72196: LD_VAR 0 3
72200: PPUSH
72201: LD_VAR 0 4
72205: PPUSH
72206: LD_VAR 0 5
72210: PPUSH
72211: CALL_OW 448
72215: IFFALSE 72250
// begin result := [ chassis , engine , control , weapon ] ;
72217: LD_ADDR_VAR 0 6
72221: PUSH
72222: LD_VAR 0 2
72226: PUSH
72227: LD_VAR 0 3
72231: PUSH
72232: LD_VAR 0 4
72236: PUSH
72237: LD_VAR 0 5
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: ST_TO_ADDR
// exit ;
72248: GO 72662
// end ; _chassis := AvailableChassisList ( factory ) ;
72250: LD_ADDR_VAR 0 9
72254: PUSH
72255: LD_VAR 0 1
72259: PPUSH
72260: CALL_OW 475
72264: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72265: LD_ADDR_VAR 0 11
72269: PUSH
72270: LD_VAR 0 1
72274: PPUSH
72275: CALL_OW 476
72279: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72280: LD_ADDR_VAR 0 12
72284: PUSH
72285: LD_VAR 0 1
72289: PPUSH
72290: CALL_OW 477
72294: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72295: LD_ADDR_VAR 0 10
72299: PUSH
72300: LD_VAR 0 1
72304: PPUSH
72305: CALL_OW 478
72309: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72310: LD_VAR 0 9
72314: NOT
72315: PUSH
72316: LD_VAR 0 11
72320: NOT
72321: OR
72322: PUSH
72323: LD_VAR 0 12
72327: NOT
72328: OR
72329: PUSH
72330: LD_VAR 0 10
72334: NOT
72335: OR
72336: IFFALSE 72371
// begin result := [ chassis , engine , control , weapon ] ;
72338: LD_ADDR_VAR 0 6
72342: PUSH
72343: LD_VAR 0 2
72347: PUSH
72348: LD_VAR 0 3
72352: PUSH
72353: LD_VAR 0 4
72357: PUSH
72358: LD_VAR 0 5
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: ST_TO_ADDR
// exit ;
72369: GO 72662
// end ; if not chassis in _chassis then
72371: LD_VAR 0 2
72375: PUSH
72376: LD_VAR 0 9
72380: IN
72381: NOT
72382: IFFALSE 72408
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72384: LD_ADDR_VAR 0 2
72388: PUSH
72389: LD_VAR 0 9
72393: PUSH
72394: LD_INT 1
72396: PPUSH
72397: LD_VAR 0 9
72401: PPUSH
72402: CALL_OW 12
72406: ARRAY
72407: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72408: LD_VAR 0 2
72412: PPUSH
72413: LD_VAR 0 3
72417: PPUSH
72418: CALL 72667 0 2
72422: NOT
72423: IFFALSE 72482
// repeat engine := _engine [ 1 ] ;
72425: LD_ADDR_VAR 0 3
72429: PUSH
72430: LD_VAR 0 11
72434: PUSH
72435: LD_INT 1
72437: ARRAY
72438: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72439: LD_ADDR_VAR 0 11
72443: PUSH
72444: LD_VAR 0 11
72448: PPUSH
72449: LD_INT 1
72451: PPUSH
72452: CALL_OW 3
72456: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72457: LD_VAR 0 2
72461: PPUSH
72462: LD_VAR 0 3
72466: PPUSH
72467: CALL 72667 0 2
72471: PUSH
72472: LD_VAR 0 11
72476: PUSH
72477: EMPTY
72478: EQUAL
72479: OR
72480: IFFALSE 72425
// if not control in _control then
72482: LD_VAR 0 4
72486: PUSH
72487: LD_VAR 0 12
72491: IN
72492: NOT
72493: IFFALSE 72519
// control := _control [ rand ( 1 , _control ) ] ;
72495: LD_ADDR_VAR 0 4
72499: PUSH
72500: LD_VAR 0 12
72504: PUSH
72505: LD_INT 1
72507: PPUSH
72508: LD_VAR 0 12
72512: PPUSH
72513: CALL_OW 12
72517: ARRAY
72518: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72519: LD_VAR 0 2
72523: PPUSH
72524: LD_VAR 0 5
72528: PPUSH
72529: CALL 72887 0 2
72533: NOT
72534: IFFALSE 72593
// repeat weapon := _weapon [ 1 ] ;
72536: LD_ADDR_VAR 0 5
72540: PUSH
72541: LD_VAR 0 10
72545: PUSH
72546: LD_INT 1
72548: ARRAY
72549: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72550: LD_ADDR_VAR 0 10
72554: PUSH
72555: LD_VAR 0 10
72559: PPUSH
72560: LD_INT 1
72562: PPUSH
72563: CALL_OW 3
72567: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72568: LD_VAR 0 2
72572: PPUSH
72573: LD_VAR 0 5
72577: PPUSH
72578: CALL 72887 0 2
72582: PUSH
72583: LD_VAR 0 10
72587: PUSH
72588: EMPTY
72589: EQUAL
72590: OR
72591: IFFALSE 72536
// result := [ ] ;
72593: LD_ADDR_VAR 0 6
72597: PUSH
72598: EMPTY
72599: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72600: LD_VAR 0 1
72604: PPUSH
72605: LD_VAR 0 2
72609: PPUSH
72610: LD_VAR 0 3
72614: PPUSH
72615: LD_VAR 0 4
72619: PPUSH
72620: LD_VAR 0 5
72624: PPUSH
72625: CALL_OW 448
72629: IFFALSE 72662
// result := [ chassis , engine , control , weapon ] ;
72631: LD_ADDR_VAR 0 6
72635: PUSH
72636: LD_VAR 0 2
72640: PUSH
72641: LD_VAR 0 3
72645: PUSH
72646: LD_VAR 0 4
72650: PUSH
72651: LD_VAR 0 5
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: ST_TO_ADDR
// end ;
72662: LD_VAR 0 6
72666: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72667: LD_INT 0
72669: PPUSH
// if not chassis or not engine then
72670: LD_VAR 0 1
72674: NOT
72675: PUSH
72676: LD_VAR 0 2
72680: NOT
72681: OR
72682: IFFALSE 72686
// exit ;
72684: GO 72882
// case engine of engine_solar :
72686: LD_VAR 0 2
72690: PUSH
72691: LD_INT 2
72693: DOUBLE
72694: EQUAL
72695: IFTRUE 72699
72697: GO 72737
72699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72700: LD_ADDR_VAR 0 3
72704: PUSH
72705: LD_INT 11
72707: PUSH
72708: LD_INT 12
72710: PUSH
72711: LD_INT 13
72713: PUSH
72714: LD_INT 14
72716: PUSH
72717: LD_INT 1
72719: PUSH
72720: LD_INT 2
72722: PUSH
72723: LD_INT 3
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: ST_TO_ADDR
72735: GO 72866
72737: LD_INT 1
72739: DOUBLE
72740: EQUAL
72741: IFTRUE 72745
72743: GO 72807
72745: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_INT 11
72753: PUSH
72754: LD_INT 12
72756: PUSH
72757: LD_INT 13
72759: PUSH
72760: LD_INT 14
72762: PUSH
72763: LD_INT 1
72765: PUSH
72766: LD_INT 2
72768: PUSH
72769: LD_INT 3
72771: PUSH
72772: LD_INT 4
72774: PUSH
72775: LD_INT 5
72777: PUSH
72778: LD_INT 21
72780: PUSH
72781: LD_INT 23
72783: PUSH
72784: LD_INT 22
72786: PUSH
72787: LD_INT 24
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: ST_TO_ADDR
72805: GO 72866
72807: LD_INT 3
72809: DOUBLE
72810: EQUAL
72811: IFTRUE 72815
72813: GO 72865
72815: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72816: LD_ADDR_VAR 0 3
72820: PUSH
72821: LD_INT 13
72823: PUSH
72824: LD_INT 14
72826: PUSH
72827: LD_INT 2
72829: PUSH
72830: LD_INT 3
72832: PUSH
72833: LD_INT 4
72835: PUSH
72836: LD_INT 5
72838: PUSH
72839: LD_INT 21
72841: PUSH
72842: LD_INT 22
72844: PUSH
72845: LD_INT 23
72847: PUSH
72848: LD_INT 24
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: ST_TO_ADDR
72863: GO 72866
72865: POP
// result := ( chassis in result ) ;
72866: LD_ADDR_VAR 0 3
72870: PUSH
72871: LD_VAR 0 1
72875: PUSH
72876: LD_VAR 0 3
72880: IN
72881: ST_TO_ADDR
// end ;
72882: LD_VAR 0 3
72886: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72887: LD_INT 0
72889: PPUSH
// if not chassis or not weapon then
72890: LD_VAR 0 1
72894: NOT
72895: PUSH
72896: LD_VAR 0 2
72900: NOT
72901: OR
72902: IFFALSE 72906
// exit ;
72904: GO 73966
// case weapon of us_machine_gun :
72906: LD_VAR 0 2
72910: PUSH
72911: LD_INT 2
72913: DOUBLE
72914: EQUAL
72915: IFTRUE 72919
72917: GO 72949
72919: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72920: LD_ADDR_VAR 0 3
72924: PUSH
72925: LD_INT 1
72927: PUSH
72928: LD_INT 2
72930: PUSH
72931: LD_INT 3
72933: PUSH
72934: LD_INT 4
72936: PUSH
72937: LD_INT 5
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: ST_TO_ADDR
72947: GO 73950
72949: LD_INT 3
72951: DOUBLE
72952: EQUAL
72953: IFTRUE 72957
72955: GO 72987
72957: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72958: LD_ADDR_VAR 0 3
72962: PUSH
72963: LD_INT 1
72965: PUSH
72966: LD_INT 2
72968: PUSH
72969: LD_INT 3
72971: PUSH
72972: LD_INT 4
72974: PUSH
72975: LD_INT 5
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: ST_TO_ADDR
72985: GO 73950
72987: LD_INT 11
72989: DOUBLE
72990: EQUAL
72991: IFTRUE 72995
72993: GO 73025
72995: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72996: LD_ADDR_VAR 0 3
73000: PUSH
73001: LD_INT 1
73003: PUSH
73004: LD_INT 2
73006: PUSH
73007: LD_INT 3
73009: PUSH
73010: LD_INT 4
73012: PUSH
73013: LD_INT 5
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: ST_TO_ADDR
73023: GO 73950
73025: LD_INT 4
73027: DOUBLE
73028: EQUAL
73029: IFTRUE 73033
73031: GO 73059
73033: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73034: LD_ADDR_VAR 0 3
73038: PUSH
73039: LD_INT 2
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: LD_INT 4
73047: PUSH
73048: LD_INT 5
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: ST_TO_ADDR
73057: GO 73950
73059: LD_INT 5
73061: DOUBLE
73062: EQUAL
73063: IFTRUE 73067
73065: GO 73093
73067: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73068: LD_ADDR_VAR 0 3
73072: PUSH
73073: LD_INT 2
73075: PUSH
73076: LD_INT 3
73078: PUSH
73079: LD_INT 4
73081: PUSH
73082: LD_INT 5
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: ST_TO_ADDR
73091: GO 73950
73093: LD_INT 9
73095: DOUBLE
73096: EQUAL
73097: IFTRUE 73101
73099: GO 73127
73101: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73102: LD_ADDR_VAR 0 3
73106: PUSH
73107: LD_INT 2
73109: PUSH
73110: LD_INT 3
73112: PUSH
73113: LD_INT 4
73115: PUSH
73116: LD_INT 5
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: ST_TO_ADDR
73125: GO 73950
73127: LD_INT 7
73129: DOUBLE
73130: EQUAL
73131: IFTRUE 73135
73133: GO 73161
73135: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73136: LD_ADDR_VAR 0 3
73140: PUSH
73141: LD_INT 2
73143: PUSH
73144: LD_INT 3
73146: PUSH
73147: LD_INT 4
73149: PUSH
73150: LD_INT 5
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: ST_TO_ADDR
73159: GO 73950
73161: LD_INT 12
73163: DOUBLE
73164: EQUAL
73165: IFTRUE 73169
73167: GO 73195
73169: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73170: LD_ADDR_VAR 0 3
73174: PUSH
73175: LD_INT 2
73177: PUSH
73178: LD_INT 3
73180: PUSH
73181: LD_INT 4
73183: PUSH
73184: LD_INT 5
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: ST_TO_ADDR
73193: GO 73950
73195: LD_INT 13
73197: DOUBLE
73198: EQUAL
73199: IFTRUE 73203
73201: GO 73229
73203: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73204: LD_ADDR_VAR 0 3
73208: PUSH
73209: LD_INT 2
73211: PUSH
73212: LD_INT 3
73214: PUSH
73215: LD_INT 4
73217: PUSH
73218: LD_INT 5
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: ST_TO_ADDR
73227: GO 73950
73229: LD_INT 14
73231: DOUBLE
73232: EQUAL
73233: IFTRUE 73237
73235: GO 73255
73237: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73238: LD_ADDR_VAR 0 3
73242: PUSH
73243: LD_INT 4
73245: PUSH
73246: LD_INT 5
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: ST_TO_ADDR
73253: GO 73950
73255: LD_INT 6
73257: DOUBLE
73258: EQUAL
73259: IFTRUE 73263
73261: GO 73281
73263: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73264: LD_ADDR_VAR 0 3
73268: PUSH
73269: LD_INT 4
73271: PUSH
73272: LD_INT 5
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: ST_TO_ADDR
73279: GO 73950
73281: LD_INT 10
73283: DOUBLE
73284: EQUAL
73285: IFTRUE 73289
73287: GO 73307
73289: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73290: LD_ADDR_VAR 0 3
73294: PUSH
73295: LD_INT 4
73297: PUSH
73298: LD_INT 5
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: ST_TO_ADDR
73305: GO 73950
73307: LD_INT 22
73309: DOUBLE
73310: EQUAL
73311: IFTRUE 73315
73313: GO 73341
73315: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73316: LD_ADDR_VAR 0 3
73320: PUSH
73321: LD_INT 11
73323: PUSH
73324: LD_INT 12
73326: PUSH
73327: LD_INT 13
73329: PUSH
73330: LD_INT 14
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: ST_TO_ADDR
73339: GO 73950
73341: LD_INT 23
73343: DOUBLE
73344: EQUAL
73345: IFTRUE 73349
73347: GO 73375
73349: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73350: LD_ADDR_VAR 0 3
73354: PUSH
73355: LD_INT 11
73357: PUSH
73358: LD_INT 12
73360: PUSH
73361: LD_INT 13
73363: PUSH
73364: LD_INT 14
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: ST_TO_ADDR
73373: GO 73950
73375: LD_INT 24
73377: DOUBLE
73378: EQUAL
73379: IFTRUE 73383
73381: GO 73409
73383: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73384: LD_ADDR_VAR 0 3
73388: PUSH
73389: LD_INT 11
73391: PUSH
73392: LD_INT 12
73394: PUSH
73395: LD_INT 13
73397: PUSH
73398: LD_INT 14
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: LIST
73405: LIST
73406: ST_TO_ADDR
73407: GO 73950
73409: LD_INT 30
73411: DOUBLE
73412: EQUAL
73413: IFTRUE 73417
73415: GO 73443
73417: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73418: LD_ADDR_VAR 0 3
73422: PUSH
73423: LD_INT 11
73425: PUSH
73426: LD_INT 12
73428: PUSH
73429: LD_INT 13
73431: PUSH
73432: LD_INT 14
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: ST_TO_ADDR
73441: GO 73950
73443: LD_INT 25
73445: DOUBLE
73446: EQUAL
73447: IFTRUE 73451
73449: GO 73469
73451: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73452: LD_ADDR_VAR 0 3
73456: PUSH
73457: LD_INT 13
73459: PUSH
73460: LD_INT 14
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: ST_TO_ADDR
73467: GO 73950
73469: LD_INT 27
73471: DOUBLE
73472: EQUAL
73473: IFTRUE 73477
73475: GO 73495
73477: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73478: LD_ADDR_VAR 0 3
73482: PUSH
73483: LD_INT 13
73485: PUSH
73486: LD_INT 14
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: ST_TO_ADDR
73493: GO 73950
73495: LD_INT 92
73497: DOUBLE
73498: EQUAL
73499: IFTRUE 73503
73501: GO 73529
73503: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73504: LD_ADDR_VAR 0 3
73508: PUSH
73509: LD_INT 11
73511: PUSH
73512: LD_INT 12
73514: PUSH
73515: LD_INT 13
73517: PUSH
73518: LD_INT 14
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: ST_TO_ADDR
73527: GO 73950
73529: LD_INT 28
73531: DOUBLE
73532: EQUAL
73533: IFTRUE 73537
73535: GO 73555
73537: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73538: LD_ADDR_VAR 0 3
73542: PUSH
73543: LD_INT 13
73545: PUSH
73546: LD_INT 14
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: ST_TO_ADDR
73553: GO 73950
73555: LD_INT 29
73557: DOUBLE
73558: EQUAL
73559: IFTRUE 73563
73561: GO 73581
73563: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73564: LD_ADDR_VAR 0 3
73568: PUSH
73569: LD_INT 13
73571: PUSH
73572: LD_INT 14
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: ST_TO_ADDR
73579: GO 73950
73581: LD_INT 31
73583: DOUBLE
73584: EQUAL
73585: IFTRUE 73589
73587: GO 73607
73589: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73590: LD_ADDR_VAR 0 3
73594: PUSH
73595: LD_INT 13
73597: PUSH
73598: LD_INT 14
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: ST_TO_ADDR
73605: GO 73950
73607: LD_INT 26
73609: DOUBLE
73610: EQUAL
73611: IFTRUE 73615
73613: GO 73633
73615: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73616: LD_ADDR_VAR 0 3
73620: PUSH
73621: LD_INT 13
73623: PUSH
73624: LD_INT 14
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: ST_TO_ADDR
73631: GO 73950
73633: LD_INT 42
73635: DOUBLE
73636: EQUAL
73637: IFTRUE 73641
73639: GO 73667
73641: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73642: LD_ADDR_VAR 0 3
73646: PUSH
73647: LD_INT 21
73649: PUSH
73650: LD_INT 22
73652: PUSH
73653: LD_INT 23
73655: PUSH
73656: LD_INT 24
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: ST_TO_ADDR
73665: GO 73950
73667: LD_INT 43
73669: DOUBLE
73670: EQUAL
73671: IFTRUE 73675
73673: GO 73701
73675: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73676: LD_ADDR_VAR 0 3
73680: PUSH
73681: LD_INT 21
73683: PUSH
73684: LD_INT 22
73686: PUSH
73687: LD_INT 23
73689: PUSH
73690: LD_INT 24
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: LIST
73697: LIST
73698: ST_TO_ADDR
73699: GO 73950
73701: LD_INT 44
73703: DOUBLE
73704: EQUAL
73705: IFTRUE 73709
73707: GO 73735
73709: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73710: LD_ADDR_VAR 0 3
73714: PUSH
73715: LD_INT 21
73717: PUSH
73718: LD_INT 22
73720: PUSH
73721: LD_INT 23
73723: PUSH
73724: LD_INT 24
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: ST_TO_ADDR
73733: GO 73950
73735: LD_INT 45
73737: DOUBLE
73738: EQUAL
73739: IFTRUE 73743
73741: GO 73769
73743: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73744: LD_ADDR_VAR 0 3
73748: PUSH
73749: LD_INT 21
73751: PUSH
73752: LD_INT 22
73754: PUSH
73755: LD_INT 23
73757: PUSH
73758: LD_INT 24
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: ST_TO_ADDR
73767: GO 73950
73769: LD_INT 49
73771: DOUBLE
73772: EQUAL
73773: IFTRUE 73777
73775: GO 73803
73777: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73778: LD_ADDR_VAR 0 3
73782: PUSH
73783: LD_INT 21
73785: PUSH
73786: LD_INT 22
73788: PUSH
73789: LD_INT 23
73791: PUSH
73792: LD_INT 24
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: ST_TO_ADDR
73801: GO 73950
73803: LD_INT 51
73805: DOUBLE
73806: EQUAL
73807: IFTRUE 73811
73809: GO 73837
73811: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73812: LD_ADDR_VAR 0 3
73816: PUSH
73817: LD_INT 21
73819: PUSH
73820: LD_INT 22
73822: PUSH
73823: LD_INT 23
73825: PUSH
73826: LD_INT 24
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: ST_TO_ADDR
73835: GO 73950
73837: LD_INT 52
73839: DOUBLE
73840: EQUAL
73841: IFTRUE 73845
73843: GO 73871
73845: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73846: LD_ADDR_VAR 0 3
73850: PUSH
73851: LD_INT 21
73853: PUSH
73854: LD_INT 22
73856: PUSH
73857: LD_INT 23
73859: PUSH
73860: LD_INT 24
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: ST_TO_ADDR
73869: GO 73950
73871: LD_INT 53
73873: DOUBLE
73874: EQUAL
73875: IFTRUE 73879
73877: GO 73897
73879: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73880: LD_ADDR_VAR 0 3
73884: PUSH
73885: LD_INT 23
73887: PUSH
73888: LD_INT 24
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: ST_TO_ADDR
73895: GO 73950
73897: LD_INT 46
73899: DOUBLE
73900: EQUAL
73901: IFTRUE 73905
73903: GO 73923
73905: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73906: LD_ADDR_VAR 0 3
73910: PUSH
73911: LD_INT 23
73913: PUSH
73914: LD_INT 24
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: ST_TO_ADDR
73921: GO 73950
73923: LD_INT 47
73925: DOUBLE
73926: EQUAL
73927: IFTRUE 73931
73929: GO 73949
73931: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73932: LD_ADDR_VAR 0 3
73936: PUSH
73937: LD_INT 23
73939: PUSH
73940: LD_INT 24
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: ST_TO_ADDR
73947: GO 73950
73949: POP
// result := ( chassis in result ) ;
73950: LD_ADDR_VAR 0 3
73954: PUSH
73955: LD_VAR 0 1
73959: PUSH
73960: LD_VAR 0 3
73964: IN
73965: ST_TO_ADDR
// end ;
73966: LD_VAR 0 3
73970: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73971: LD_INT 0
73973: PPUSH
73974: PPUSH
73975: PPUSH
73976: PPUSH
73977: PPUSH
73978: PPUSH
73979: PPUSH
// result := array ;
73980: LD_ADDR_VAR 0 5
73984: PUSH
73985: LD_VAR 0 1
73989: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73990: LD_VAR 0 1
73994: NOT
73995: PUSH
73996: LD_VAR 0 2
74000: NOT
74001: OR
74002: PUSH
74003: LD_VAR 0 3
74007: NOT
74008: OR
74009: PUSH
74010: LD_VAR 0 2
74014: PUSH
74015: LD_VAR 0 1
74019: GREATER
74020: OR
74021: PUSH
74022: LD_VAR 0 3
74026: PUSH
74027: LD_VAR 0 1
74031: GREATER
74032: OR
74033: IFFALSE 74037
// exit ;
74035: GO 74333
// if direction then
74037: LD_VAR 0 4
74041: IFFALSE 74105
// begin d := 1 ;
74043: LD_ADDR_VAR 0 9
74047: PUSH
74048: LD_INT 1
74050: ST_TO_ADDR
// if i_from > i_to then
74051: LD_VAR 0 2
74055: PUSH
74056: LD_VAR 0 3
74060: GREATER
74061: IFFALSE 74087
// length := ( array - i_from ) + i_to else
74063: LD_ADDR_VAR 0 11
74067: PUSH
74068: LD_VAR 0 1
74072: PUSH
74073: LD_VAR 0 2
74077: MINUS
74078: PUSH
74079: LD_VAR 0 3
74083: PLUS
74084: ST_TO_ADDR
74085: GO 74103
// length := i_to - i_from ;
74087: LD_ADDR_VAR 0 11
74091: PUSH
74092: LD_VAR 0 3
74096: PUSH
74097: LD_VAR 0 2
74101: MINUS
74102: ST_TO_ADDR
// end else
74103: GO 74166
// begin d := - 1 ;
74105: LD_ADDR_VAR 0 9
74109: PUSH
74110: LD_INT 1
74112: NEG
74113: ST_TO_ADDR
// if i_from > i_to then
74114: LD_VAR 0 2
74118: PUSH
74119: LD_VAR 0 3
74123: GREATER
74124: IFFALSE 74144
// length := i_from - i_to else
74126: LD_ADDR_VAR 0 11
74130: PUSH
74131: LD_VAR 0 2
74135: PUSH
74136: LD_VAR 0 3
74140: MINUS
74141: ST_TO_ADDR
74142: GO 74166
// length := ( array - i_to ) + i_from ;
74144: LD_ADDR_VAR 0 11
74148: PUSH
74149: LD_VAR 0 1
74153: PUSH
74154: LD_VAR 0 3
74158: MINUS
74159: PUSH
74160: LD_VAR 0 2
74164: PLUS
74165: ST_TO_ADDR
// end ; if not length then
74166: LD_VAR 0 11
74170: NOT
74171: IFFALSE 74175
// exit ;
74173: GO 74333
// tmp := array ;
74175: LD_ADDR_VAR 0 10
74179: PUSH
74180: LD_VAR 0 1
74184: ST_TO_ADDR
// for i = 1 to length do
74185: LD_ADDR_VAR 0 6
74189: PUSH
74190: DOUBLE
74191: LD_INT 1
74193: DEC
74194: ST_TO_ADDR
74195: LD_VAR 0 11
74199: PUSH
74200: FOR_TO
74201: IFFALSE 74321
// begin for j = 1 to array do
74203: LD_ADDR_VAR 0 7
74207: PUSH
74208: DOUBLE
74209: LD_INT 1
74211: DEC
74212: ST_TO_ADDR
74213: LD_VAR 0 1
74217: PUSH
74218: FOR_TO
74219: IFFALSE 74307
// begin k := j + d ;
74221: LD_ADDR_VAR 0 8
74225: PUSH
74226: LD_VAR 0 7
74230: PUSH
74231: LD_VAR 0 9
74235: PLUS
74236: ST_TO_ADDR
// if k > array then
74237: LD_VAR 0 8
74241: PUSH
74242: LD_VAR 0 1
74246: GREATER
74247: IFFALSE 74257
// k := 1 ;
74249: LD_ADDR_VAR 0 8
74253: PUSH
74254: LD_INT 1
74256: ST_TO_ADDR
// if not k then
74257: LD_VAR 0 8
74261: NOT
74262: IFFALSE 74274
// k := array ;
74264: LD_ADDR_VAR 0 8
74268: PUSH
74269: LD_VAR 0 1
74273: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74274: LD_ADDR_VAR 0 10
74278: PUSH
74279: LD_VAR 0 10
74283: PPUSH
74284: LD_VAR 0 8
74288: PPUSH
74289: LD_VAR 0 1
74293: PUSH
74294: LD_VAR 0 7
74298: ARRAY
74299: PPUSH
74300: CALL_OW 1
74304: ST_TO_ADDR
// end ;
74305: GO 74218
74307: POP
74308: POP
// array := tmp ;
74309: LD_ADDR_VAR 0 1
74313: PUSH
74314: LD_VAR 0 10
74318: ST_TO_ADDR
// end ;
74319: GO 74200
74321: POP
74322: POP
// result := array ;
74323: LD_ADDR_VAR 0 5
74327: PUSH
74328: LD_VAR 0 1
74332: ST_TO_ADDR
// end ;
74333: LD_VAR 0 5
74337: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74338: LD_INT 0
74340: PPUSH
74341: PPUSH
// result := 0 ;
74342: LD_ADDR_VAR 0 3
74346: PUSH
74347: LD_INT 0
74349: ST_TO_ADDR
// if not array or not value in array then
74350: LD_VAR 0 1
74354: NOT
74355: PUSH
74356: LD_VAR 0 2
74360: PUSH
74361: LD_VAR 0 1
74365: IN
74366: NOT
74367: OR
74368: IFFALSE 74372
// exit ;
74370: GO 74426
// for i = 1 to array do
74372: LD_ADDR_VAR 0 4
74376: PUSH
74377: DOUBLE
74378: LD_INT 1
74380: DEC
74381: ST_TO_ADDR
74382: LD_VAR 0 1
74386: PUSH
74387: FOR_TO
74388: IFFALSE 74424
// if value = array [ i ] then
74390: LD_VAR 0 2
74394: PUSH
74395: LD_VAR 0 1
74399: PUSH
74400: LD_VAR 0 4
74404: ARRAY
74405: EQUAL
74406: IFFALSE 74422
// begin result := i ;
74408: LD_ADDR_VAR 0 3
74412: PUSH
74413: LD_VAR 0 4
74417: ST_TO_ADDR
// exit ;
74418: POP
74419: POP
74420: GO 74426
// end ;
74422: GO 74387
74424: POP
74425: POP
// end ;
74426: LD_VAR 0 3
74430: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74431: LD_INT 0
74433: PPUSH
// vc_chassis := chassis ;
74434: LD_ADDR_OWVAR 37
74438: PUSH
74439: LD_VAR 0 1
74443: ST_TO_ADDR
// vc_engine := engine ;
74444: LD_ADDR_OWVAR 39
74448: PUSH
74449: LD_VAR 0 2
74453: ST_TO_ADDR
// vc_control := control ;
74454: LD_ADDR_OWVAR 38
74458: PUSH
74459: LD_VAR 0 3
74463: ST_TO_ADDR
// vc_weapon := weapon ;
74464: LD_ADDR_OWVAR 40
74468: PUSH
74469: LD_VAR 0 4
74473: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74474: LD_ADDR_OWVAR 41
74478: PUSH
74479: LD_VAR 0 5
74483: ST_TO_ADDR
// end ;
74484: LD_VAR 0 6
74488: RET
// export function WantPlant ( unit ) ; var task ; begin
74489: LD_INT 0
74491: PPUSH
74492: PPUSH
// result := false ;
74493: LD_ADDR_VAR 0 2
74497: PUSH
74498: LD_INT 0
74500: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74501: LD_ADDR_VAR 0 3
74505: PUSH
74506: LD_VAR 0 1
74510: PPUSH
74511: CALL_OW 437
74515: ST_TO_ADDR
// if task then
74516: LD_VAR 0 3
74520: IFFALSE 74548
// if task [ 1 ] [ 1 ] = p then
74522: LD_VAR 0 3
74526: PUSH
74527: LD_INT 1
74529: ARRAY
74530: PUSH
74531: LD_INT 1
74533: ARRAY
74534: PUSH
74535: LD_STRING p
74537: EQUAL
74538: IFFALSE 74548
// result := true ;
74540: LD_ADDR_VAR 0 2
74544: PUSH
74545: LD_INT 1
74547: ST_TO_ADDR
// end ;
74548: LD_VAR 0 2
74552: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74553: LD_INT 0
74555: PPUSH
74556: PPUSH
74557: PPUSH
74558: PPUSH
// if pos < 1 then
74559: LD_VAR 0 2
74563: PUSH
74564: LD_INT 1
74566: LESS
74567: IFFALSE 74571
// exit ;
74569: GO 74874
// if pos = 1 then
74571: LD_VAR 0 2
74575: PUSH
74576: LD_INT 1
74578: EQUAL
74579: IFFALSE 74612
// result := Replace ( arr , pos [ 1 ] , value ) else
74581: LD_ADDR_VAR 0 4
74585: PUSH
74586: LD_VAR 0 1
74590: PPUSH
74591: LD_VAR 0 2
74595: PUSH
74596: LD_INT 1
74598: ARRAY
74599: PPUSH
74600: LD_VAR 0 3
74604: PPUSH
74605: CALL_OW 1
74609: ST_TO_ADDR
74610: GO 74874
// begin tmp := arr ;
74612: LD_ADDR_VAR 0 6
74616: PUSH
74617: LD_VAR 0 1
74621: ST_TO_ADDR
// s_arr := [ tmp ] ;
74622: LD_ADDR_VAR 0 7
74626: PUSH
74627: LD_VAR 0 6
74631: PUSH
74632: EMPTY
74633: LIST
74634: ST_TO_ADDR
// for i = 1 to pos - 1 do
74635: LD_ADDR_VAR 0 5
74639: PUSH
74640: DOUBLE
74641: LD_INT 1
74643: DEC
74644: ST_TO_ADDR
74645: LD_VAR 0 2
74649: PUSH
74650: LD_INT 1
74652: MINUS
74653: PUSH
74654: FOR_TO
74655: IFFALSE 74700
// begin tmp := tmp [ pos [ i ] ] ;
74657: LD_ADDR_VAR 0 6
74661: PUSH
74662: LD_VAR 0 6
74666: PUSH
74667: LD_VAR 0 2
74671: PUSH
74672: LD_VAR 0 5
74676: ARRAY
74677: ARRAY
74678: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74679: LD_ADDR_VAR 0 7
74683: PUSH
74684: LD_VAR 0 7
74688: PUSH
74689: LD_VAR 0 6
74693: PUSH
74694: EMPTY
74695: LIST
74696: ADD
74697: ST_TO_ADDR
// end ;
74698: GO 74654
74700: POP
74701: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74702: LD_ADDR_VAR 0 6
74706: PUSH
74707: LD_VAR 0 6
74711: PPUSH
74712: LD_VAR 0 2
74716: PUSH
74717: LD_VAR 0 2
74721: ARRAY
74722: PPUSH
74723: LD_VAR 0 3
74727: PPUSH
74728: CALL_OW 1
74732: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74733: LD_ADDR_VAR 0 7
74737: PUSH
74738: LD_VAR 0 7
74742: PPUSH
74743: LD_VAR 0 7
74747: PPUSH
74748: LD_VAR 0 6
74752: PPUSH
74753: CALL_OW 1
74757: ST_TO_ADDR
// for i = s_arr downto 2 do
74758: LD_ADDR_VAR 0 5
74762: PUSH
74763: DOUBLE
74764: LD_VAR 0 7
74768: INC
74769: ST_TO_ADDR
74770: LD_INT 2
74772: PUSH
74773: FOR_DOWNTO
74774: IFFALSE 74858
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74776: LD_ADDR_VAR 0 6
74780: PUSH
74781: LD_VAR 0 7
74785: PUSH
74786: LD_VAR 0 5
74790: PUSH
74791: LD_INT 1
74793: MINUS
74794: ARRAY
74795: PPUSH
74796: LD_VAR 0 2
74800: PUSH
74801: LD_VAR 0 5
74805: PUSH
74806: LD_INT 1
74808: MINUS
74809: ARRAY
74810: PPUSH
74811: LD_VAR 0 7
74815: PUSH
74816: LD_VAR 0 5
74820: ARRAY
74821: PPUSH
74822: CALL_OW 1
74826: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74827: LD_ADDR_VAR 0 7
74831: PUSH
74832: LD_VAR 0 7
74836: PPUSH
74837: LD_VAR 0 5
74841: PUSH
74842: LD_INT 1
74844: MINUS
74845: PPUSH
74846: LD_VAR 0 6
74850: PPUSH
74851: CALL_OW 1
74855: ST_TO_ADDR
// end ;
74856: GO 74773
74858: POP
74859: POP
// result := s_arr [ 1 ] ;
74860: LD_ADDR_VAR 0 4
74864: PUSH
74865: LD_VAR 0 7
74869: PUSH
74870: LD_INT 1
74872: ARRAY
74873: ST_TO_ADDR
// end ; end ;
74874: LD_VAR 0 4
74878: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74879: LD_INT 0
74881: PPUSH
74882: PPUSH
// if not list then
74883: LD_VAR 0 1
74887: NOT
74888: IFFALSE 74892
// exit ;
74890: GO 74983
// i := list [ pos1 ] ;
74892: LD_ADDR_VAR 0 5
74896: PUSH
74897: LD_VAR 0 1
74901: PUSH
74902: LD_VAR 0 2
74906: ARRAY
74907: ST_TO_ADDR
// if not i then
74908: LD_VAR 0 5
74912: NOT
74913: IFFALSE 74917
// exit ;
74915: GO 74983
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74917: LD_ADDR_VAR 0 1
74921: PUSH
74922: LD_VAR 0 1
74926: PPUSH
74927: LD_VAR 0 2
74931: PPUSH
74932: LD_VAR 0 1
74936: PUSH
74937: LD_VAR 0 3
74941: ARRAY
74942: PPUSH
74943: CALL_OW 1
74947: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74948: LD_ADDR_VAR 0 1
74952: PUSH
74953: LD_VAR 0 1
74957: PPUSH
74958: LD_VAR 0 3
74962: PPUSH
74963: LD_VAR 0 5
74967: PPUSH
74968: CALL_OW 1
74972: ST_TO_ADDR
// result := list ;
74973: LD_ADDR_VAR 0 4
74977: PUSH
74978: LD_VAR 0 1
74982: ST_TO_ADDR
// end ;
74983: LD_VAR 0 4
74987: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74988: LD_INT 0
74990: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74991: LD_ADDR_VAR 0 5
74995: PUSH
74996: LD_VAR 0 1
75000: PPUSH
75001: CALL_OW 250
75005: PPUSH
75006: LD_VAR 0 1
75010: PPUSH
75011: CALL_OW 251
75015: PPUSH
75016: LD_VAR 0 2
75020: PPUSH
75021: LD_VAR 0 3
75025: PPUSH
75026: LD_VAR 0 4
75030: PPUSH
75031: CALL 75409 0 5
75035: ST_TO_ADDR
// end ;
75036: LD_VAR 0 5
75040: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75041: LD_INT 0
75043: PPUSH
75044: PPUSH
75045: PPUSH
75046: PPUSH
// if not list or not unit then
75047: LD_VAR 0 2
75051: NOT
75052: PUSH
75053: LD_VAR 0 1
75057: NOT
75058: OR
75059: IFFALSE 75063
// exit ;
75061: GO 75404
// result := [ ] ;
75063: LD_ADDR_VAR 0 5
75067: PUSH
75068: EMPTY
75069: ST_TO_ADDR
// for i in list do
75070: LD_ADDR_VAR 0 6
75074: PUSH
75075: LD_VAR 0 2
75079: PUSH
75080: FOR_IN
75081: IFFALSE 75299
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75083: LD_ADDR_VAR 0 8
75087: PUSH
75088: LD_VAR 0 1
75092: PPUSH
75093: LD_VAR 0 6
75097: PUSH
75098: LD_INT 1
75100: ARRAY
75101: PPUSH
75102: LD_VAR 0 6
75106: PUSH
75107: LD_INT 2
75109: ARRAY
75110: PPUSH
75111: CALL_OW 297
75115: ST_TO_ADDR
// if not Count ( result ) then
75116: LD_VAR 0 5
75120: PPUSH
75121: CALL 71693 0 1
75125: NOT
75126: IFFALSE 75159
// begin result := Join ( result , [ i , tmp ] ) ;
75128: LD_ADDR_VAR 0 5
75132: PUSH
75133: LD_VAR 0 5
75137: PPUSH
75138: LD_VAR 0 6
75142: PUSH
75143: LD_VAR 0 8
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PPUSH
75152: CALL 107282 0 2
75156: ST_TO_ADDR
// continue ;
75157: GO 75080
// end ; if result [ result ] [ 2 ] <= tmp then
75159: LD_VAR 0 5
75163: PUSH
75164: LD_VAR 0 5
75168: ARRAY
75169: PUSH
75170: LD_INT 2
75172: ARRAY
75173: PUSH
75174: LD_VAR 0 8
75178: LESSEQUAL
75179: IFFALSE 75212
// result := Join ( result , [ i , tmp ] ) else
75181: LD_ADDR_VAR 0 5
75185: PUSH
75186: LD_VAR 0 5
75190: PPUSH
75191: LD_VAR 0 6
75195: PUSH
75196: LD_VAR 0 8
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PPUSH
75205: CALL 107282 0 2
75209: ST_TO_ADDR
75210: GO 75297
// begin for j := 1 to Count ( result ) do
75212: LD_ADDR_VAR 0 7
75216: PUSH
75217: DOUBLE
75218: LD_INT 1
75220: DEC
75221: ST_TO_ADDR
75222: LD_VAR 0 5
75226: PPUSH
75227: CALL 71693 0 1
75231: PUSH
75232: FOR_TO
75233: IFFALSE 75295
// begin if tmp < result [ j ] [ 2 ] then
75235: LD_VAR 0 8
75239: PUSH
75240: LD_VAR 0 5
75244: PUSH
75245: LD_VAR 0 7
75249: ARRAY
75250: PUSH
75251: LD_INT 2
75253: ARRAY
75254: LESS
75255: IFFALSE 75293
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75257: LD_ADDR_VAR 0 5
75261: PUSH
75262: LD_VAR 0 5
75266: PPUSH
75267: LD_VAR 0 7
75271: PPUSH
75272: LD_VAR 0 6
75276: PUSH
75277: LD_VAR 0 8
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PPUSH
75286: CALL_OW 2
75290: ST_TO_ADDR
// break ;
75291: GO 75295
// end ; end ;
75293: GO 75232
75295: POP
75296: POP
// end ; end ;
75297: GO 75080
75299: POP
75300: POP
// if result and not asc then
75301: LD_VAR 0 5
75305: PUSH
75306: LD_VAR 0 3
75310: NOT
75311: AND
75312: IFFALSE 75329
// result := ReverseArray ( result ) ;
75314: LD_ADDR_VAR 0 5
75318: PUSH
75319: LD_VAR 0 5
75323: PPUSH
75324: CALL 102569 0 1
75328: ST_TO_ADDR
// tmp := [ ] ;
75329: LD_ADDR_VAR 0 8
75333: PUSH
75334: EMPTY
75335: ST_TO_ADDR
// if mode then
75336: LD_VAR 0 4
75340: IFFALSE 75404
// begin for i := 1 to result do
75342: LD_ADDR_VAR 0 6
75346: PUSH
75347: DOUBLE
75348: LD_INT 1
75350: DEC
75351: ST_TO_ADDR
75352: LD_VAR 0 5
75356: PUSH
75357: FOR_TO
75358: IFFALSE 75392
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75360: LD_ADDR_VAR 0 8
75364: PUSH
75365: LD_VAR 0 8
75369: PPUSH
75370: LD_VAR 0 5
75374: PUSH
75375: LD_VAR 0 6
75379: ARRAY
75380: PUSH
75381: LD_INT 1
75383: ARRAY
75384: PPUSH
75385: CALL 107282 0 2
75389: ST_TO_ADDR
75390: GO 75357
75392: POP
75393: POP
// result := tmp ;
75394: LD_ADDR_VAR 0 5
75398: PUSH
75399: LD_VAR 0 8
75403: ST_TO_ADDR
// end ; end ;
75404: LD_VAR 0 5
75408: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75409: LD_INT 0
75411: PPUSH
75412: PPUSH
75413: PPUSH
75414: PPUSH
// if not list then
75415: LD_VAR 0 3
75419: NOT
75420: IFFALSE 75424
// exit ;
75422: GO 75812
// result := [ ] ;
75424: LD_ADDR_VAR 0 6
75428: PUSH
75429: EMPTY
75430: ST_TO_ADDR
// for i in list do
75431: LD_ADDR_VAR 0 7
75435: PUSH
75436: LD_VAR 0 3
75440: PUSH
75441: FOR_IN
75442: IFFALSE 75644
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75444: LD_ADDR_VAR 0 9
75448: PUSH
75449: LD_VAR 0 7
75453: PPUSH
75454: LD_VAR 0 1
75458: PPUSH
75459: LD_VAR 0 2
75463: PPUSH
75464: CALL_OW 297
75468: ST_TO_ADDR
// if not result then
75469: LD_VAR 0 6
75473: NOT
75474: IFFALSE 75500
// result := [ [ i , tmp ] ] else
75476: LD_ADDR_VAR 0 6
75480: PUSH
75481: LD_VAR 0 7
75485: PUSH
75486: LD_VAR 0 9
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: EMPTY
75496: LIST
75497: ST_TO_ADDR
75498: GO 75642
// begin if result [ result ] [ 2 ] < tmp then
75500: LD_VAR 0 6
75504: PUSH
75505: LD_VAR 0 6
75509: ARRAY
75510: PUSH
75511: LD_INT 2
75513: ARRAY
75514: PUSH
75515: LD_VAR 0 9
75519: LESS
75520: IFFALSE 75562
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75522: LD_ADDR_VAR 0 6
75526: PUSH
75527: LD_VAR 0 6
75531: PPUSH
75532: LD_VAR 0 6
75536: PUSH
75537: LD_INT 1
75539: PLUS
75540: PPUSH
75541: LD_VAR 0 7
75545: PUSH
75546: LD_VAR 0 9
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PPUSH
75555: CALL_OW 2
75559: ST_TO_ADDR
75560: GO 75642
// for j = 1 to result do
75562: LD_ADDR_VAR 0 8
75566: PUSH
75567: DOUBLE
75568: LD_INT 1
75570: DEC
75571: ST_TO_ADDR
75572: LD_VAR 0 6
75576: PUSH
75577: FOR_TO
75578: IFFALSE 75640
// begin if tmp < result [ j ] [ 2 ] then
75580: LD_VAR 0 9
75584: PUSH
75585: LD_VAR 0 6
75589: PUSH
75590: LD_VAR 0 8
75594: ARRAY
75595: PUSH
75596: LD_INT 2
75598: ARRAY
75599: LESS
75600: IFFALSE 75638
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75602: LD_ADDR_VAR 0 6
75606: PUSH
75607: LD_VAR 0 6
75611: PPUSH
75612: LD_VAR 0 8
75616: PPUSH
75617: LD_VAR 0 7
75621: PUSH
75622: LD_VAR 0 9
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PPUSH
75631: CALL_OW 2
75635: ST_TO_ADDR
// break ;
75636: GO 75640
// end ; end ;
75638: GO 75577
75640: POP
75641: POP
// end ; end ;
75642: GO 75441
75644: POP
75645: POP
// if result and not asc then
75646: LD_VAR 0 6
75650: PUSH
75651: LD_VAR 0 4
75655: NOT
75656: AND
75657: IFFALSE 75732
// begin tmp := result ;
75659: LD_ADDR_VAR 0 9
75663: PUSH
75664: LD_VAR 0 6
75668: ST_TO_ADDR
// for i = tmp downto 1 do
75669: LD_ADDR_VAR 0 7
75673: PUSH
75674: DOUBLE
75675: LD_VAR 0 9
75679: INC
75680: ST_TO_ADDR
75681: LD_INT 1
75683: PUSH
75684: FOR_DOWNTO
75685: IFFALSE 75730
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75687: LD_ADDR_VAR 0 6
75691: PUSH
75692: LD_VAR 0 6
75696: PPUSH
75697: LD_VAR 0 9
75701: PUSH
75702: LD_VAR 0 7
75706: MINUS
75707: PUSH
75708: LD_INT 1
75710: PLUS
75711: PPUSH
75712: LD_VAR 0 9
75716: PUSH
75717: LD_VAR 0 7
75721: ARRAY
75722: PPUSH
75723: CALL_OW 1
75727: ST_TO_ADDR
75728: GO 75684
75730: POP
75731: POP
// end ; tmp := [ ] ;
75732: LD_ADDR_VAR 0 9
75736: PUSH
75737: EMPTY
75738: ST_TO_ADDR
// if mode then
75739: LD_VAR 0 5
75743: IFFALSE 75812
// begin for i = 1 to result do
75745: LD_ADDR_VAR 0 7
75749: PUSH
75750: DOUBLE
75751: LD_INT 1
75753: DEC
75754: ST_TO_ADDR
75755: LD_VAR 0 6
75759: PUSH
75760: FOR_TO
75761: IFFALSE 75800
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75763: LD_ADDR_VAR 0 9
75767: PUSH
75768: LD_VAR 0 9
75772: PPUSH
75773: LD_VAR 0 7
75777: PPUSH
75778: LD_VAR 0 6
75782: PUSH
75783: LD_VAR 0 7
75787: ARRAY
75788: PUSH
75789: LD_INT 1
75791: ARRAY
75792: PPUSH
75793: CALL_OW 1
75797: ST_TO_ADDR
75798: GO 75760
75800: POP
75801: POP
// result := tmp ;
75802: LD_ADDR_VAR 0 6
75806: PUSH
75807: LD_VAR 0 9
75811: ST_TO_ADDR
// end ; end ;
75812: LD_VAR 0 6
75816: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75817: LD_INT 0
75819: PPUSH
75820: PPUSH
75821: PPUSH
75822: PPUSH
75823: PPUSH
75824: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75825: LD_ADDR_VAR 0 5
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: LD_INT 0
75835: PUSH
75836: LD_INT 0
75838: PUSH
75839: EMPTY
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: ST_TO_ADDR
// if not x or not y then
75847: LD_VAR 0 2
75851: NOT
75852: PUSH
75853: LD_VAR 0 3
75857: NOT
75858: OR
75859: IFFALSE 75863
// exit ;
75861: GO 77513
// if not range then
75863: LD_VAR 0 4
75867: NOT
75868: IFFALSE 75878
// range := 10 ;
75870: LD_ADDR_VAR 0 4
75874: PUSH
75875: LD_INT 10
75877: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75878: LD_ADDR_VAR 0 8
75882: PUSH
75883: LD_INT 81
75885: PUSH
75886: LD_VAR 0 1
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 92
75897: PUSH
75898: LD_VAR 0 2
75902: PUSH
75903: LD_VAR 0 3
75907: PUSH
75908: LD_VAR 0 4
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 3
75921: PUSH
75922: LD_INT 21
75924: PUSH
75925: LD_INT 3
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: LIST
75940: PPUSH
75941: CALL_OW 69
75945: ST_TO_ADDR
// if not tmp then
75946: LD_VAR 0 8
75950: NOT
75951: IFFALSE 75955
// exit ;
75953: GO 77513
// for i in tmp do
75955: LD_ADDR_VAR 0 6
75959: PUSH
75960: LD_VAR 0 8
75964: PUSH
75965: FOR_IN
75966: IFFALSE 77488
// begin points := [ 0 , 0 , 0 ] ;
75968: LD_ADDR_VAR 0 9
75972: PUSH
75973: LD_INT 0
75975: PUSH
75976: LD_INT 0
75978: PUSH
75979: LD_INT 0
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: LIST
75986: ST_TO_ADDR
// bpoints := 1 ;
75987: LD_ADDR_VAR 0 10
75991: PUSH
75992: LD_INT 1
75994: ST_TO_ADDR
// case GetType ( i ) of unit_human :
75995: LD_VAR 0 6
75999: PPUSH
76000: CALL_OW 247
76004: PUSH
76005: LD_INT 1
76007: DOUBLE
76008: EQUAL
76009: IFTRUE 76013
76011: GO 76591
76013: POP
// begin if GetClass ( i ) = 1 then
76014: LD_VAR 0 6
76018: PPUSH
76019: CALL_OW 257
76023: PUSH
76024: LD_INT 1
76026: EQUAL
76027: IFFALSE 76048
// points := [ 10 , 5 , 3 ] ;
76029: LD_ADDR_VAR 0 9
76033: PUSH
76034: LD_INT 10
76036: PUSH
76037: LD_INT 5
76039: PUSH
76040: LD_INT 3
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: LIST
76047: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76048: LD_VAR 0 6
76052: PPUSH
76053: CALL_OW 257
76057: PUSH
76058: LD_INT 2
76060: PUSH
76061: LD_INT 3
76063: PUSH
76064: LD_INT 4
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: LIST
76071: IN
76072: IFFALSE 76093
// points := [ 3 , 2 , 1 ] ;
76074: LD_ADDR_VAR 0 9
76078: PUSH
76079: LD_INT 3
76081: PUSH
76082: LD_INT 2
76084: PUSH
76085: LD_INT 1
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: LIST
76092: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76093: LD_VAR 0 6
76097: PPUSH
76098: CALL_OW 257
76102: PUSH
76103: LD_INT 5
76105: EQUAL
76106: IFFALSE 76127
// points := [ 130 , 5 , 2 ] ;
76108: LD_ADDR_VAR 0 9
76112: PUSH
76113: LD_INT 130
76115: PUSH
76116: LD_INT 5
76118: PUSH
76119: LD_INT 2
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: LIST
76126: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76127: LD_VAR 0 6
76131: PPUSH
76132: CALL_OW 257
76136: PUSH
76137: LD_INT 8
76139: EQUAL
76140: IFFALSE 76161
// points := [ 35 , 35 , 30 ] ;
76142: LD_ADDR_VAR 0 9
76146: PUSH
76147: LD_INT 35
76149: PUSH
76150: LD_INT 35
76152: PUSH
76153: LD_INT 30
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: LIST
76160: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76161: LD_VAR 0 6
76165: PPUSH
76166: CALL_OW 257
76170: PUSH
76171: LD_INT 9
76173: EQUAL
76174: IFFALSE 76195
// points := [ 20 , 55 , 40 ] ;
76176: LD_ADDR_VAR 0 9
76180: PUSH
76181: LD_INT 20
76183: PUSH
76184: LD_INT 55
76186: PUSH
76187: LD_INT 40
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: LIST
76194: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76195: LD_VAR 0 6
76199: PPUSH
76200: CALL_OW 257
76204: PUSH
76205: LD_INT 12
76207: PUSH
76208: LD_INT 16
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: IN
76215: IFFALSE 76236
// points := [ 5 , 3 , 2 ] ;
76217: LD_ADDR_VAR 0 9
76221: PUSH
76222: LD_INT 5
76224: PUSH
76225: LD_INT 3
76227: PUSH
76228: LD_INT 2
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: LIST
76235: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76236: LD_VAR 0 6
76240: PPUSH
76241: CALL_OW 257
76245: PUSH
76246: LD_INT 17
76248: EQUAL
76249: IFFALSE 76270
// points := [ 100 , 50 , 75 ] ;
76251: LD_ADDR_VAR 0 9
76255: PUSH
76256: LD_INT 100
76258: PUSH
76259: LD_INT 50
76261: PUSH
76262: LD_INT 75
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: LIST
76269: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76270: LD_VAR 0 6
76274: PPUSH
76275: CALL_OW 257
76279: PUSH
76280: LD_INT 15
76282: EQUAL
76283: IFFALSE 76304
// points := [ 10 , 5 , 3 ] ;
76285: LD_ADDR_VAR 0 9
76289: PUSH
76290: LD_INT 10
76292: PUSH
76293: LD_INT 5
76295: PUSH
76296: LD_INT 3
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: LIST
76303: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76304: LD_VAR 0 6
76308: PPUSH
76309: CALL_OW 257
76313: PUSH
76314: LD_INT 14
76316: EQUAL
76317: IFFALSE 76338
// points := [ 10 , 0 , 0 ] ;
76319: LD_ADDR_VAR 0 9
76323: PUSH
76324: LD_INT 10
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: LD_INT 0
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: LIST
76337: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76338: LD_VAR 0 6
76342: PPUSH
76343: CALL_OW 257
76347: PUSH
76348: LD_INT 11
76350: EQUAL
76351: IFFALSE 76372
// points := [ 30 , 10 , 5 ] ;
76353: LD_ADDR_VAR 0 9
76357: PUSH
76358: LD_INT 30
76360: PUSH
76361: LD_INT 10
76363: PUSH
76364: LD_INT 5
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: LIST
76371: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76372: LD_VAR 0 1
76376: PPUSH
76377: LD_INT 5
76379: PPUSH
76380: CALL_OW 321
76384: PUSH
76385: LD_INT 2
76387: EQUAL
76388: IFFALSE 76405
// bpoints := bpoints * 1.8 ;
76390: LD_ADDR_VAR 0 10
76394: PUSH
76395: LD_VAR 0 10
76399: PUSH
76400: LD_REAL  1.80000000000000E+0000
76403: MUL
76404: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76405: LD_VAR 0 6
76409: PPUSH
76410: CALL_OW 257
76414: PUSH
76415: LD_INT 1
76417: PUSH
76418: LD_INT 2
76420: PUSH
76421: LD_INT 3
76423: PUSH
76424: LD_INT 4
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: LIST
76431: LIST
76432: IN
76433: PUSH
76434: LD_VAR 0 1
76438: PPUSH
76439: LD_INT 51
76441: PPUSH
76442: CALL_OW 321
76446: PUSH
76447: LD_INT 2
76449: EQUAL
76450: AND
76451: IFFALSE 76468
// bpoints := bpoints * 1.2 ;
76453: LD_ADDR_VAR 0 10
76457: PUSH
76458: LD_VAR 0 10
76462: PUSH
76463: LD_REAL  1.20000000000000E+0000
76466: MUL
76467: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76468: LD_VAR 0 6
76472: PPUSH
76473: CALL_OW 257
76477: PUSH
76478: LD_INT 5
76480: PUSH
76481: LD_INT 7
76483: PUSH
76484: LD_INT 9
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: LIST
76491: IN
76492: PUSH
76493: LD_VAR 0 1
76497: PPUSH
76498: LD_INT 52
76500: PPUSH
76501: CALL_OW 321
76505: PUSH
76506: LD_INT 2
76508: EQUAL
76509: AND
76510: IFFALSE 76527
// bpoints := bpoints * 1.5 ;
76512: LD_ADDR_VAR 0 10
76516: PUSH
76517: LD_VAR 0 10
76521: PUSH
76522: LD_REAL  1.50000000000000E+0000
76525: MUL
76526: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76527: LD_VAR 0 1
76531: PPUSH
76532: LD_INT 66
76534: PPUSH
76535: CALL_OW 321
76539: PUSH
76540: LD_INT 2
76542: EQUAL
76543: IFFALSE 76560
// bpoints := bpoints * 1.1 ;
76545: LD_ADDR_VAR 0 10
76549: PUSH
76550: LD_VAR 0 10
76554: PUSH
76555: LD_REAL  1.10000000000000E+0000
76558: MUL
76559: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76560: LD_ADDR_VAR 0 10
76564: PUSH
76565: LD_VAR 0 10
76569: PUSH
76570: LD_VAR 0 6
76574: PPUSH
76575: LD_INT 1
76577: PPUSH
76578: CALL_OW 259
76582: PUSH
76583: LD_REAL  1.15000000000000E+0000
76586: MUL
76587: MUL
76588: ST_TO_ADDR
// end ; unit_vehicle :
76589: GO 77417
76591: LD_INT 2
76593: DOUBLE
76594: EQUAL
76595: IFTRUE 76599
76597: GO 77405
76599: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76600: LD_VAR 0 6
76604: PPUSH
76605: CALL_OW 264
76609: PUSH
76610: LD_INT 2
76612: PUSH
76613: LD_INT 42
76615: PUSH
76616: LD_INT 24
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: LIST
76623: IN
76624: IFFALSE 76645
// points := [ 25 , 5 , 3 ] ;
76626: LD_ADDR_VAR 0 9
76630: PUSH
76631: LD_INT 25
76633: PUSH
76634: LD_INT 5
76636: PUSH
76637: LD_INT 3
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76645: LD_VAR 0 6
76649: PPUSH
76650: CALL_OW 264
76654: PUSH
76655: LD_INT 4
76657: PUSH
76658: LD_INT 43
76660: PUSH
76661: LD_INT 25
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: LIST
76668: IN
76669: IFFALSE 76690
// points := [ 40 , 15 , 5 ] ;
76671: LD_ADDR_VAR 0 9
76675: PUSH
76676: LD_INT 40
76678: PUSH
76679: LD_INT 15
76681: PUSH
76682: LD_INT 5
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: LIST
76689: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76690: LD_VAR 0 6
76694: PPUSH
76695: CALL_OW 264
76699: PUSH
76700: LD_INT 3
76702: PUSH
76703: LD_INT 23
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: IN
76710: IFFALSE 76731
// points := [ 7 , 25 , 8 ] ;
76712: LD_ADDR_VAR 0 9
76716: PUSH
76717: LD_INT 7
76719: PUSH
76720: LD_INT 25
76722: PUSH
76723: LD_INT 8
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: LIST
76730: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76731: LD_VAR 0 6
76735: PPUSH
76736: CALL_OW 264
76740: PUSH
76741: LD_INT 5
76743: PUSH
76744: LD_INT 27
76746: PUSH
76747: LD_INT 44
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: LIST
76754: IN
76755: IFFALSE 76776
// points := [ 14 , 50 , 16 ] ;
76757: LD_ADDR_VAR 0 9
76761: PUSH
76762: LD_INT 14
76764: PUSH
76765: LD_INT 50
76767: PUSH
76768: LD_INT 16
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: LIST
76775: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76776: LD_VAR 0 6
76780: PPUSH
76781: CALL_OW 264
76785: PUSH
76786: LD_INT 6
76788: PUSH
76789: LD_INT 46
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: IN
76796: IFFALSE 76817
// points := [ 32 , 120 , 70 ] ;
76798: LD_ADDR_VAR 0 9
76802: PUSH
76803: LD_INT 32
76805: PUSH
76806: LD_INT 120
76808: PUSH
76809: LD_INT 70
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: LIST
76816: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76817: LD_VAR 0 6
76821: PPUSH
76822: CALL_OW 264
76826: PUSH
76827: LD_INT 7
76829: PUSH
76830: LD_INT 28
76832: PUSH
76833: LD_INT 45
76835: PUSH
76836: LD_INT 92
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: LIST
76843: LIST
76844: IN
76845: IFFALSE 76866
// points := [ 35 , 20 , 45 ] ;
76847: LD_ADDR_VAR 0 9
76851: PUSH
76852: LD_INT 35
76854: PUSH
76855: LD_INT 20
76857: PUSH
76858: LD_INT 45
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: LIST
76865: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76866: LD_VAR 0 6
76870: PPUSH
76871: CALL_OW 264
76875: PUSH
76876: LD_INT 47
76878: PUSH
76879: EMPTY
76880: LIST
76881: IN
76882: IFFALSE 76903
// points := [ 67 , 45 , 75 ] ;
76884: LD_ADDR_VAR 0 9
76888: PUSH
76889: LD_INT 67
76891: PUSH
76892: LD_INT 45
76894: PUSH
76895: LD_INT 75
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: LIST
76902: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76903: LD_VAR 0 6
76907: PPUSH
76908: CALL_OW 264
76912: PUSH
76913: LD_INT 26
76915: PUSH
76916: EMPTY
76917: LIST
76918: IN
76919: IFFALSE 76940
// points := [ 120 , 30 , 80 ] ;
76921: LD_ADDR_VAR 0 9
76925: PUSH
76926: LD_INT 120
76928: PUSH
76929: LD_INT 30
76931: PUSH
76932: LD_INT 80
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: LIST
76939: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
76940: LD_VAR 0 6
76944: PPUSH
76945: CALL_OW 264
76949: PUSH
76950: LD_INT 22
76952: PUSH
76953: EMPTY
76954: LIST
76955: IN
76956: IFFALSE 76977
// points := [ 40 , 1 , 1 ] ;
76958: LD_ADDR_VAR 0 9
76962: PUSH
76963: LD_INT 40
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 1
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: LIST
76976: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
76977: LD_VAR 0 6
76981: PPUSH
76982: CALL_OW 264
76986: PUSH
76987: LD_INT 29
76989: PUSH
76990: EMPTY
76991: LIST
76992: IN
76993: IFFALSE 77014
// points := [ 70 , 200 , 400 ] ;
76995: LD_ADDR_VAR 0 9
76999: PUSH
77000: LD_INT 70
77002: PUSH
77003: LD_INT 200
77005: PUSH
77006: LD_INT 400
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: LIST
77013: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77014: LD_VAR 0 6
77018: PPUSH
77019: CALL_OW 264
77023: PUSH
77024: LD_INT 14
77026: PUSH
77027: LD_INT 53
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: IN
77034: IFFALSE 77055
// points := [ 40 , 10 , 20 ] ;
77036: LD_ADDR_VAR 0 9
77040: PUSH
77041: LD_INT 40
77043: PUSH
77044: LD_INT 10
77046: PUSH
77047: LD_INT 20
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: LIST
77054: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77055: LD_VAR 0 6
77059: PPUSH
77060: CALL_OW 264
77064: PUSH
77065: LD_INT 9
77067: PUSH
77068: EMPTY
77069: LIST
77070: IN
77071: IFFALSE 77092
// points := [ 5 , 70 , 20 ] ;
77073: LD_ADDR_VAR 0 9
77077: PUSH
77078: LD_INT 5
77080: PUSH
77081: LD_INT 70
77083: PUSH
77084: LD_INT 20
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: LIST
77091: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77092: LD_VAR 0 6
77096: PPUSH
77097: CALL_OW 264
77101: PUSH
77102: LD_INT 10
77104: PUSH
77105: EMPTY
77106: LIST
77107: IN
77108: IFFALSE 77129
// points := [ 35 , 110 , 70 ] ;
77110: LD_ADDR_VAR 0 9
77114: PUSH
77115: LD_INT 35
77117: PUSH
77118: LD_INT 110
77120: PUSH
77121: LD_INT 70
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: LIST
77128: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77129: LD_VAR 0 6
77133: PPUSH
77134: CALL_OW 265
77138: PUSH
77139: LD_INT 25
77141: EQUAL
77142: IFFALSE 77163
// points := [ 80 , 65 , 100 ] ;
77144: LD_ADDR_VAR 0 9
77148: PUSH
77149: LD_INT 80
77151: PUSH
77152: LD_INT 65
77154: PUSH
77155: LD_INT 100
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: LIST
77162: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77163: LD_VAR 0 6
77167: PPUSH
77168: CALL_OW 263
77172: PUSH
77173: LD_INT 1
77175: EQUAL
77176: IFFALSE 77211
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77178: LD_ADDR_VAR 0 10
77182: PUSH
77183: LD_VAR 0 10
77187: PUSH
77188: LD_VAR 0 6
77192: PPUSH
77193: CALL_OW 311
77197: PPUSH
77198: LD_INT 3
77200: PPUSH
77201: CALL_OW 259
77205: PUSH
77206: LD_INT 4
77208: MUL
77209: MUL
77210: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77211: LD_VAR 0 6
77215: PPUSH
77216: CALL_OW 263
77220: PUSH
77221: LD_INT 2
77223: EQUAL
77224: IFFALSE 77275
// begin j := IsControledBy ( i ) ;
77226: LD_ADDR_VAR 0 7
77230: PUSH
77231: LD_VAR 0 6
77235: PPUSH
77236: CALL_OW 312
77240: ST_TO_ADDR
// if j then
77241: LD_VAR 0 7
77245: IFFALSE 77275
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77247: LD_ADDR_VAR 0 10
77251: PUSH
77252: LD_VAR 0 10
77256: PUSH
77257: LD_VAR 0 7
77261: PPUSH
77262: LD_INT 3
77264: PPUSH
77265: CALL_OW 259
77269: PUSH
77270: LD_INT 3
77272: MUL
77273: MUL
77274: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77275: LD_VAR 0 6
77279: PPUSH
77280: CALL_OW 264
77284: PUSH
77285: LD_INT 5
77287: PUSH
77288: LD_INT 6
77290: PUSH
77291: LD_INT 46
77293: PUSH
77294: LD_INT 44
77296: PUSH
77297: LD_INT 47
77299: PUSH
77300: LD_INT 45
77302: PUSH
77303: LD_INT 28
77305: PUSH
77306: LD_INT 7
77308: PUSH
77309: LD_INT 27
77311: PUSH
77312: LD_INT 29
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: LIST
77323: LIST
77324: LIST
77325: LIST
77326: IN
77327: PUSH
77328: LD_VAR 0 1
77332: PPUSH
77333: LD_INT 52
77335: PPUSH
77336: CALL_OW 321
77340: PUSH
77341: LD_INT 2
77343: EQUAL
77344: AND
77345: IFFALSE 77362
// bpoints := bpoints * 1.2 ;
77347: LD_ADDR_VAR 0 10
77351: PUSH
77352: LD_VAR 0 10
77356: PUSH
77357: LD_REAL  1.20000000000000E+0000
77360: MUL
77361: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77362: LD_VAR 0 6
77366: PPUSH
77367: CALL_OW 264
77371: PUSH
77372: LD_INT 6
77374: PUSH
77375: LD_INT 46
77377: PUSH
77378: LD_INT 47
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: LIST
77385: IN
77386: IFFALSE 77403
// bpoints := bpoints * 1.2 ;
77388: LD_ADDR_VAR 0 10
77392: PUSH
77393: LD_VAR 0 10
77397: PUSH
77398: LD_REAL  1.20000000000000E+0000
77401: MUL
77402: ST_TO_ADDR
// end ; unit_building :
77403: GO 77417
77405: LD_INT 3
77407: DOUBLE
77408: EQUAL
77409: IFTRUE 77413
77411: GO 77416
77413: POP
// ; end ;
77414: GO 77417
77416: POP
// for j = 1 to 3 do
77417: LD_ADDR_VAR 0 7
77421: PUSH
77422: DOUBLE
77423: LD_INT 1
77425: DEC
77426: ST_TO_ADDR
77427: LD_INT 3
77429: PUSH
77430: FOR_TO
77431: IFFALSE 77484
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77433: LD_ADDR_VAR 0 5
77437: PUSH
77438: LD_VAR 0 5
77442: PPUSH
77443: LD_VAR 0 7
77447: PPUSH
77448: LD_VAR 0 5
77452: PUSH
77453: LD_VAR 0 7
77457: ARRAY
77458: PUSH
77459: LD_VAR 0 9
77463: PUSH
77464: LD_VAR 0 7
77468: ARRAY
77469: PUSH
77470: LD_VAR 0 10
77474: MUL
77475: PLUS
77476: PPUSH
77477: CALL_OW 1
77481: ST_TO_ADDR
77482: GO 77430
77484: POP
77485: POP
// end ;
77486: GO 75965
77488: POP
77489: POP
// result := Replace ( result , 4 , tmp ) ;
77490: LD_ADDR_VAR 0 5
77494: PUSH
77495: LD_VAR 0 5
77499: PPUSH
77500: LD_INT 4
77502: PPUSH
77503: LD_VAR 0 8
77507: PPUSH
77508: CALL_OW 1
77512: ST_TO_ADDR
// end ;
77513: LD_VAR 0 5
77517: RET
// export function DangerAtRange ( unit , range ) ; begin
77518: LD_INT 0
77520: PPUSH
// if not unit then
77521: LD_VAR 0 1
77525: NOT
77526: IFFALSE 77530
// exit ;
77528: GO 77575
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77530: LD_ADDR_VAR 0 3
77534: PUSH
77535: LD_VAR 0 1
77539: PPUSH
77540: CALL_OW 255
77544: PPUSH
77545: LD_VAR 0 1
77549: PPUSH
77550: CALL_OW 250
77554: PPUSH
77555: LD_VAR 0 1
77559: PPUSH
77560: CALL_OW 251
77564: PPUSH
77565: LD_VAR 0 2
77569: PPUSH
77570: CALL 75817 0 4
77574: ST_TO_ADDR
// end ;
77575: LD_VAR 0 3
77579: RET
// export function DangerInArea ( side , area ) ; begin
77580: LD_INT 0
77582: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77583: LD_ADDR_VAR 0 3
77587: PUSH
77588: LD_VAR 0 2
77592: PPUSH
77593: LD_INT 81
77595: PUSH
77596: LD_VAR 0 1
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PPUSH
77605: CALL_OW 70
77609: ST_TO_ADDR
// end ;
77610: LD_VAR 0 3
77614: RET
// export function IsExtension ( b ) ; begin
77615: LD_INT 0
77617: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77618: LD_ADDR_VAR 0 2
77622: PUSH
77623: LD_VAR 0 1
77627: PUSH
77628: LD_INT 23
77630: PUSH
77631: LD_INT 20
77633: PUSH
77634: LD_INT 22
77636: PUSH
77637: LD_INT 17
77639: PUSH
77640: LD_INT 24
77642: PUSH
77643: LD_INT 21
77645: PUSH
77646: LD_INT 19
77648: PUSH
77649: LD_INT 16
77651: PUSH
77652: LD_INT 25
77654: PUSH
77655: LD_INT 18
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: IN
77670: ST_TO_ADDR
// end ;
77671: LD_VAR 0 2
77675: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77676: LD_INT 0
77678: PPUSH
77679: PPUSH
77680: PPUSH
// result := [ ] ;
77681: LD_ADDR_VAR 0 4
77685: PUSH
77686: EMPTY
77687: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77688: LD_ADDR_VAR 0 5
77692: PUSH
77693: LD_VAR 0 2
77697: PPUSH
77698: LD_INT 21
77700: PUSH
77701: LD_INT 3
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PPUSH
77708: CALL_OW 70
77712: ST_TO_ADDR
// if not tmp then
77713: LD_VAR 0 5
77717: NOT
77718: IFFALSE 77722
// exit ;
77720: GO 77786
// if checkLink then
77722: LD_VAR 0 3
77726: IFFALSE 77776
// begin for i in tmp do
77728: LD_ADDR_VAR 0 6
77732: PUSH
77733: LD_VAR 0 5
77737: PUSH
77738: FOR_IN
77739: IFFALSE 77774
// if GetBase ( i ) <> base then
77741: LD_VAR 0 6
77745: PPUSH
77746: CALL_OW 274
77750: PUSH
77751: LD_VAR 0 1
77755: NONEQUAL
77756: IFFALSE 77772
// ComLinkToBase ( base , i ) ;
77758: LD_VAR 0 1
77762: PPUSH
77763: LD_VAR 0 6
77767: PPUSH
77768: CALL_OW 169
77772: GO 77738
77774: POP
77775: POP
// end ; result := tmp ;
77776: LD_ADDR_VAR 0 4
77780: PUSH
77781: LD_VAR 0 5
77785: ST_TO_ADDR
// end ;
77786: LD_VAR 0 4
77790: RET
// export function ComComplete ( units , b ) ; var i ; begin
77791: LD_INT 0
77793: PPUSH
77794: PPUSH
// if not units then
77795: LD_VAR 0 1
77799: NOT
77800: IFFALSE 77804
// exit ;
77802: GO 77894
// for i in units do
77804: LD_ADDR_VAR 0 4
77808: PUSH
77809: LD_VAR 0 1
77813: PUSH
77814: FOR_IN
77815: IFFALSE 77892
// if BuildingStatus ( b ) = bs_build then
77817: LD_VAR 0 2
77821: PPUSH
77822: CALL_OW 461
77826: PUSH
77827: LD_INT 1
77829: EQUAL
77830: IFFALSE 77890
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77832: LD_VAR 0 4
77836: PPUSH
77837: LD_STRING h
77839: PUSH
77840: LD_VAR 0 2
77844: PPUSH
77845: CALL_OW 250
77849: PUSH
77850: LD_VAR 0 2
77854: PPUSH
77855: CALL_OW 251
77859: PUSH
77860: LD_VAR 0 2
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: LD_INT 0
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: LIST
77881: LIST
77882: PUSH
77883: EMPTY
77884: LIST
77885: PPUSH
77886: CALL_OW 446
77890: GO 77814
77892: POP
77893: POP
// end ;
77894: LD_VAR 0 3
77898: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77899: LD_INT 0
77901: PPUSH
77902: PPUSH
77903: PPUSH
77904: PPUSH
77905: PPUSH
77906: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77907: LD_VAR 0 1
77911: NOT
77912: PUSH
77913: LD_VAR 0 1
77917: PPUSH
77918: CALL_OW 263
77922: PUSH
77923: LD_INT 2
77925: NONEQUAL
77926: OR
77927: IFFALSE 77931
// exit ;
77929: GO 78247
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
77931: LD_ADDR_VAR 0 6
77935: PUSH
77936: LD_INT 22
77938: PUSH
77939: LD_VAR 0 1
77943: PPUSH
77944: CALL_OW 255
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 2
77955: PUSH
77956: LD_INT 30
77958: PUSH
77959: LD_INT 36
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 34
77968: PUSH
77969: LD_INT 31
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: LIST
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PPUSH
77985: CALL_OW 69
77989: ST_TO_ADDR
// if not tmp then
77990: LD_VAR 0 6
77994: NOT
77995: IFFALSE 77999
// exit ;
77997: GO 78247
// result := [ ] ;
77999: LD_ADDR_VAR 0 2
78003: PUSH
78004: EMPTY
78005: ST_TO_ADDR
// for i in tmp do
78006: LD_ADDR_VAR 0 3
78010: PUSH
78011: LD_VAR 0 6
78015: PUSH
78016: FOR_IN
78017: IFFALSE 78088
// begin t := UnitsInside ( i ) ;
78019: LD_ADDR_VAR 0 4
78023: PUSH
78024: LD_VAR 0 3
78028: PPUSH
78029: CALL_OW 313
78033: ST_TO_ADDR
// if t then
78034: LD_VAR 0 4
78038: IFFALSE 78086
// for j in t do
78040: LD_ADDR_VAR 0 7
78044: PUSH
78045: LD_VAR 0 4
78049: PUSH
78050: FOR_IN
78051: IFFALSE 78084
// result := Replace ( result , result + 1 , j ) ;
78053: LD_ADDR_VAR 0 2
78057: PUSH
78058: LD_VAR 0 2
78062: PPUSH
78063: LD_VAR 0 2
78067: PUSH
78068: LD_INT 1
78070: PLUS
78071: PPUSH
78072: LD_VAR 0 7
78076: PPUSH
78077: CALL_OW 1
78081: ST_TO_ADDR
78082: GO 78050
78084: POP
78085: POP
// end ;
78086: GO 78016
78088: POP
78089: POP
// if not result then
78090: LD_VAR 0 2
78094: NOT
78095: IFFALSE 78099
// exit ;
78097: GO 78247
// mech := result [ 1 ] ;
78099: LD_ADDR_VAR 0 5
78103: PUSH
78104: LD_VAR 0 2
78108: PUSH
78109: LD_INT 1
78111: ARRAY
78112: ST_TO_ADDR
// if result > 1 then
78113: LD_VAR 0 2
78117: PUSH
78118: LD_INT 1
78120: GREATER
78121: IFFALSE 78233
// begin for i = 2 to result do
78123: LD_ADDR_VAR 0 3
78127: PUSH
78128: DOUBLE
78129: LD_INT 2
78131: DEC
78132: ST_TO_ADDR
78133: LD_VAR 0 2
78137: PUSH
78138: FOR_TO
78139: IFFALSE 78231
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78141: LD_ADDR_VAR 0 4
78145: PUSH
78146: LD_VAR 0 2
78150: PUSH
78151: LD_VAR 0 3
78155: ARRAY
78156: PPUSH
78157: LD_INT 3
78159: PPUSH
78160: CALL_OW 259
78164: PUSH
78165: LD_VAR 0 2
78169: PUSH
78170: LD_VAR 0 3
78174: ARRAY
78175: PPUSH
78176: CALL_OW 432
78180: MINUS
78181: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78182: LD_VAR 0 4
78186: PUSH
78187: LD_VAR 0 5
78191: PPUSH
78192: LD_INT 3
78194: PPUSH
78195: CALL_OW 259
78199: PUSH
78200: LD_VAR 0 5
78204: PPUSH
78205: CALL_OW 432
78209: MINUS
78210: GREATEREQUAL
78211: IFFALSE 78229
// mech := result [ i ] ;
78213: LD_ADDR_VAR 0 5
78217: PUSH
78218: LD_VAR 0 2
78222: PUSH
78223: LD_VAR 0 3
78227: ARRAY
78228: ST_TO_ADDR
// end ;
78229: GO 78138
78231: POP
78232: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78233: LD_VAR 0 1
78237: PPUSH
78238: LD_VAR 0 5
78242: PPUSH
78243: CALL_OW 135
// end ;
78247: LD_VAR 0 2
78251: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78252: LD_INT 0
78254: PPUSH
78255: PPUSH
78256: PPUSH
78257: PPUSH
78258: PPUSH
78259: PPUSH
78260: PPUSH
78261: PPUSH
78262: PPUSH
78263: PPUSH
78264: PPUSH
78265: PPUSH
78266: PPUSH
// result := [ ] ;
78267: LD_ADDR_VAR 0 7
78271: PUSH
78272: EMPTY
78273: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78274: LD_VAR 0 1
78278: PPUSH
78279: CALL_OW 266
78283: PUSH
78284: LD_INT 0
78286: PUSH
78287: LD_INT 1
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: IN
78294: NOT
78295: IFFALSE 78299
// exit ;
78297: GO 79933
// if name then
78299: LD_VAR 0 3
78303: IFFALSE 78319
// SetBName ( base_dep , name ) ;
78305: LD_VAR 0 1
78309: PPUSH
78310: LD_VAR 0 3
78314: PPUSH
78315: CALL_OW 500
// base := GetBase ( base_dep ) ;
78319: LD_ADDR_VAR 0 15
78323: PUSH
78324: LD_VAR 0 1
78328: PPUSH
78329: CALL_OW 274
78333: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78334: LD_ADDR_VAR 0 16
78338: PUSH
78339: LD_VAR 0 1
78343: PPUSH
78344: CALL_OW 255
78348: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78349: LD_ADDR_VAR 0 17
78353: PUSH
78354: LD_VAR 0 1
78358: PPUSH
78359: CALL_OW 248
78363: ST_TO_ADDR
// if sources then
78364: LD_VAR 0 5
78368: IFFALSE 78415
// for i = 1 to 3 do
78370: LD_ADDR_VAR 0 8
78374: PUSH
78375: DOUBLE
78376: LD_INT 1
78378: DEC
78379: ST_TO_ADDR
78380: LD_INT 3
78382: PUSH
78383: FOR_TO
78384: IFFALSE 78413
// AddResourceType ( base , i , sources [ i ] ) ;
78386: LD_VAR 0 15
78390: PPUSH
78391: LD_VAR 0 8
78395: PPUSH
78396: LD_VAR 0 5
78400: PUSH
78401: LD_VAR 0 8
78405: ARRAY
78406: PPUSH
78407: CALL_OW 276
78411: GO 78383
78413: POP
78414: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78415: LD_ADDR_VAR 0 18
78419: PUSH
78420: LD_VAR 0 15
78424: PPUSH
78425: LD_VAR 0 2
78429: PPUSH
78430: LD_INT 1
78432: PPUSH
78433: CALL 77676 0 3
78437: ST_TO_ADDR
// InitHc ;
78438: CALL_OW 19
// InitUc ;
78442: CALL_OW 18
// uc_side := side ;
78446: LD_ADDR_OWVAR 20
78450: PUSH
78451: LD_VAR 0 16
78455: ST_TO_ADDR
// uc_nation := nation ;
78456: LD_ADDR_OWVAR 21
78460: PUSH
78461: LD_VAR 0 17
78465: ST_TO_ADDR
// if buildings then
78466: LD_VAR 0 18
78470: IFFALSE 79792
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78472: LD_ADDR_VAR 0 19
78476: PUSH
78477: LD_VAR 0 18
78481: PPUSH
78482: LD_INT 2
78484: PUSH
78485: LD_INT 30
78487: PUSH
78488: LD_INT 29
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 30
78497: PUSH
78498: LD_INT 30
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: LIST
78509: PPUSH
78510: CALL_OW 72
78514: ST_TO_ADDR
// if tmp then
78515: LD_VAR 0 19
78519: IFFALSE 78567
// for i in tmp do
78521: LD_ADDR_VAR 0 8
78525: PUSH
78526: LD_VAR 0 19
78530: PUSH
78531: FOR_IN
78532: IFFALSE 78565
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78534: LD_VAR 0 8
78538: PPUSH
78539: CALL_OW 250
78543: PPUSH
78544: LD_VAR 0 8
78548: PPUSH
78549: CALL_OW 251
78553: PPUSH
78554: LD_VAR 0 16
78558: PPUSH
78559: CALL_OW 441
78563: GO 78531
78565: POP
78566: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78567: LD_VAR 0 18
78571: PPUSH
78572: LD_INT 2
78574: PUSH
78575: LD_INT 30
78577: PUSH
78578: LD_INT 32
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 30
78587: PUSH
78588: LD_INT 33
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: LIST
78599: PPUSH
78600: CALL_OW 72
78604: IFFALSE 78692
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78606: LD_ADDR_VAR 0 8
78610: PUSH
78611: LD_VAR 0 18
78615: PPUSH
78616: LD_INT 2
78618: PUSH
78619: LD_INT 30
78621: PUSH
78622: LD_INT 32
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 30
78631: PUSH
78632: LD_INT 33
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: LIST
78643: PPUSH
78644: CALL_OW 72
78648: PUSH
78649: FOR_IN
78650: IFFALSE 78690
// begin if not GetBWeapon ( i ) then
78652: LD_VAR 0 8
78656: PPUSH
78657: CALL_OW 269
78661: NOT
78662: IFFALSE 78688
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78664: LD_VAR 0 8
78668: PPUSH
78669: LD_VAR 0 8
78673: PPUSH
78674: LD_VAR 0 2
78678: PPUSH
78679: CALL 79938 0 2
78683: PPUSH
78684: CALL_OW 431
// end ;
78688: GO 78649
78690: POP
78691: POP
// end ; for i = 1 to personel do
78692: LD_ADDR_VAR 0 8
78696: PUSH
78697: DOUBLE
78698: LD_INT 1
78700: DEC
78701: ST_TO_ADDR
78702: LD_VAR 0 6
78706: PUSH
78707: FOR_TO
78708: IFFALSE 79772
// begin if i > 4 then
78710: LD_VAR 0 8
78714: PUSH
78715: LD_INT 4
78717: GREATER
78718: IFFALSE 78722
// break ;
78720: GO 79772
// case i of 1 :
78722: LD_VAR 0 8
78726: PUSH
78727: LD_INT 1
78729: DOUBLE
78730: EQUAL
78731: IFTRUE 78735
78733: GO 78815
78735: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78736: LD_ADDR_VAR 0 12
78740: PUSH
78741: LD_VAR 0 18
78745: PPUSH
78746: LD_INT 22
78748: PUSH
78749: LD_VAR 0 16
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 58
78760: PUSH
78761: EMPTY
78762: LIST
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: LD_INT 30
78769: PUSH
78770: LD_INT 32
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 30
78779: PUSH
78780: LD_INT 4
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 30
78789: PUSH
78790: LD_INT 5
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: LIST
78807: PPUSH
78808: CALL_OW 72
78812: ST_TO_ADDR
78813: GO 79037
78815: LD_INT 2
78817: DOUBLE
78818: EQUAL
78819: IFTRUE 78823
78821: GO 78885
78823: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78824: LD_ADDR_VAR 0 12
78828: PUSH
78829: LD_VAR 0 18
78833: PPUSH
78834: LD_INT 22
78836: PUSH
78837: LD_VAR 0 16
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 2
78848: PUSH
78849: LD_INT 30
78851: PUSH
78852: LD_INT 0
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 30
78861: PUSH
78862: LD_INT 1
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: LIST
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PPUSH
78878: CALL_OW 72
78882: ST_TO_ADDR
78883: GO 79037
78885: LD_INT 3
78887: DOUBLE
78888: EQUAL
78889: IFTRUE 78893
78891: GO 78955
78893: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78894: LD_ADDR_VAR 0 12
78898: PUSH
78899: LD_VAR 0 18
78903: PPUSH
78904: LD_INT 22
78906: PUSH
78907: LD_VAR 0 16
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 2
78918: PUSH
78919: LD_INT 30
78921: PUSH
78922: LD_INT 2
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 30
78931: PUSH
78932: LD_INT 3
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: LIST
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PPUSH
78948: CALL_OW 72
78952: ST_TO_ADDR
78953: GO 79037
78955: LD_INT 4
78957: DOUBLE
78958: EQUAL
78959: IFTRUE 78963
78961: GO 79036
78963: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
78964: LD_ADDR_VAR 0 12
78968: PUSH
78969: LD_VAR 0 18
78973: PPUSH
78974: LD_INT 22
78976: PUSH
78977: LD_VAR 0 16
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 2
78988: PUSH
78989: LD_INT 30
78991: PUSH
78992: LD_INT 6
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 30
79001: PUSH
79002: LD_INT 7
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 30
79011: PUSH
79012: LD_INT 8
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PPUSH
79029: CALL_OW 72
79033: ST_TO_ADDR
79034: GO 79037
79036: POP
// if i = 1 then
79037: LD_VAR 0 8
79041: PUSH
79042: LD_INT 1
79044: EQUAL
79045: IFFALSE 79156
// begin tmp := [ ] ;
79047: LD_ADDR_VAR 0 19
79051: PUSH
79052: EMPTY
79053: ST_TO_ADDR
// for j in f do
79054: LD_ADDR_VAR 0 9
79058: PUSH
79059: LD_VAR 0 12
79063: PUSH
79064: FOR_IN
79065: IFFALSE 79138
// if GetBType ( j ) = b_bunker then
79067: LD_VAR 0 9
79071: PPUSH
79072: CALL_OW 266
79076: PUSH
79077: LD_INT 32
79079: EQUAL
79080: IFFALSE 79107
// tmp := Insert ( tmp , 1 , j ) else
79082: LD_ADDR_VAR 0 19
79086: PUSH
79087: LD_VAR 0 19
79091: PPUSH
79092: LD_INT 1
79094: PPUSH
79095: LD_VAR 0 9
79099: PPUSH
79100: CALL_OW 2
79104: ST_TO_ADDR
79105: GO 79136
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79107: LD_ADDR_VAR 0 19
79111: PUSH
79112: LD_VAR 0 19
79116: PPUSH
79117: LD_VAR 0 19
79121: PUSH
79122: LD_INT 1
79124: PLUS
79125: PPUSH
79126: LD_VAR 0 9
79130: PPUSH
79131: CALL_OW 2
79135: ST_TO_ADDR
79136: GO 79064
79138: POP
79139: POP
// if tmp then
79140: LD_VAR 0 19
79144: IFFALSE 79156
// f := tmp ;
79146: LD_ADDR_VAR 0 12
79150: PUSH
79151: LD_VAR 0 19
79155: ST_TO_ADDR
// end ; x := personel [ i ] ;
79156: LD_ADDR_VAR 0 13
79160: PUSH
79161: LD_VAR 0 6
79165: PUSH
79166: LD_VAR 0 8
79170: ARRAY
79171: ST_TO_ADDR
// if x = - 1 then
79172: LD_VAR 0 13
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: EQUAL
79181: IFFALSE 79390
// begin for j in f do
79183: LD_ADDR_VAR 0 9
79187: PUSH
79188: LD_VAR 0 12
79192: PUSH
79193: FOR_IN
79194: IFFALSE 79386
// repeat InitHc ;
79196: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79200: LD_VAR 0 9
79204: PPUSH
79205: CALL_OW 266
79209: PUSH
79210: LD_INT 5
79212: EQUAL
79213: IFFALSE 79283
// begin if UnitsInside ( j ) < 3 then
79215: LD_VAR 0 9
79219: PPUSH
79220: CALL_OW 313
79224: PUSH
79225: LD_INT 3
79227: LESS
79228: IFFALSE 79264
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79230: LD_INT 0
79232: PPUSH
79233: LD_INT 5
79235: PUSH
79236: LD_INT 8
79238: PUSH
79239: LD_INT 9
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: LIST
79246: PUSH
79247: LD_VAR 0 17
79251: ARRAY
79252: PPUSH
79253: LD_VAR 0 4
79257: PPUSH
79258: CALL_OW 380
79262: GO 79281
// PrepareHuman ( false , i , skill ) ;
79264: LD_INT 0
79266: PPUSH
79267: LD_VAR 0 8
79271: PPUSH
79272: LD_VAR 0 4
79276: PPUSH
79277: CALL_OW 380
// end else
79281: GO 79300
// PrepareHuman ( false , i , skill ) ;
79283: LD_INT 0
79285: PPUSH
79286: LD_VAR 0 8
79290: PPUSH
79291: LD_VAR 0 4
79295: PPUSH
79296: CALL_OW 380
// un := CreateHuman ;
79300: LD_ADDR_VAR 0 14
79304: PUSH
79305: CALL_OW 44
79309: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79310: LD_ADDR_VAR 0 7
79314: PUSH
79315: LD_VAR 0 7
79319: PPUSH
79320: LD_INT 1
79322: PPUSH
79323: LD_VAR 0 14
79327: PPUSH
79328: CALL_OW 2
79332: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79333: LD_VAR 0 14
79337: PPUSH
79338: LD_VAR 0 9
79342: PPUSH
79343: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79347: LD_VAR 0 9
79351: PPUSH
79352: CALL_OW 313
79356: PUSH
79357: LD_INT 6
79359: EQUAL
79360: PUSH
79361: LD_VAR 0 9
79365: PPUSH
79366: CALL_OW 266
79370: PUSH
79371: LD_INT 32
79373: PUSH
79374: LD_INT 31
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: IN
79381: OR
79382: IFFALSE 79196
79384: GO 79193
79386: POP
79387: POP
// end else
79388: GO 79770
// for j = 1 to x do
79390: LD_ADDR_VAR 0 9
79394: PUSH
79395: DOUBLE
79396: LD_INT 1
79398: DEC
79399: ST_TO_ADDR
79400: LD_VAR 0 13
79404: PUSH
79405: FOR_TO
79406: IFFALSE 79768
// begin InitHc ;
79408: CALL_OW 19
// if not f then
79412: LD_VAR 0 12
79416: NOT
79417: IFFALSE 79506
// begin PrepareHuman ( false , i , skill ) ;
79419: LD_INT 0
79421: PPUSH
79422: LD_VAR 0 8
79426: PPUSH
79427: LD_VAR 0 4
79431: PPUSH
79432: CALL_OW 380
// un := CreateHuman ;
79436: LD_ADDR_VAR 0 14
79440: PUSH
79441: CALL_OW 44
79445: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79446: LD_ADDR_VAR 0 7
79450: PUSH
79451: LD_VAR 0 7
79455: PPUSH
79456: LD_INT 1
79458: PPUSH
79459: LD_VAR 0 14
79463: PPUSH
79464: CALL_OW 2
79468: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79469: LD_VAR 0 14
79473: PPUSH
79474: LD_VAR 0 1
79478: PPUSH
79479: CALL_OW 250
79483: PPUSH
79484: LD_VAR 0 1
79488: PPUSH
79489: CALL_OW 251
79493: PPUSH
79494: LD_INT 10
79496: PPUSH
79497: LD_INT 0
79499: PPUSH
79500: CALL_OW 50
// continue ;
79504: GO 79405
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79506: LD_VAR 0 12
79510: PUSH
79511: LD_INT 1
79513: ARRAY
79514: PPUSH
79515: CALL_OW 313
79519: PUSH
79520: LD_VAR 0 12
79524: PUSH
79525: LD_INT 1
79527: ARRAY
79528: PPUSH
79529: CALL_OW 266
79533: PUSH
79534: LD_INT 32
79536: PUSH
79537: LD_INT 31
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: IN
79544: AND
79545: PUSH
79546: LD_VAR 0 12
79550: PUSH
79551: LD_INT 1
79553: ARRAY
79554: PPUSH
79555: CALL_OW 313
79559: PUSH
79560: LD_INT 6
79562: EQUAL
79563: OR
79564: IFFALSE 79584
// f := Delete ( f , 1 ) ;
79566: LD_ADDR_VAR 0 12
79570: PUSH
79571: LD_VAR 0 12
79575: PPUSH
79576: LD_INT 1
79578: PPUSH
79579: CALL_OW 3
79583: ST_TO_ADDR
// if not f then
79584: LD_VAR 0 12
79588: NOT
79589: IFFALSE 79607
// begin x := x + 2 ;
79591: LD_ADDR_VAR 0 13
79595: PUSH
79596: LD_VAR 0 13
79600: PUSH
79601: LD_INT 2
79603: PLUS
79604: ST_TO_ADDR
// continue ;
79605: GO 79405
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79607: LD_VAR 0 12
79611: PUSH
79612: LD_INT 1
79614: ARRAY
79615: PPUSH
79616: CALL_OW 266
79620: PUSH
79621: LD_INT 5
79623: EQUAL
79624: IFFALSE 79698
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79626: LD_VAR 0 12
79630: PUSH
79631: LD_INT 1
79633: ARRAY
79634: PPUSH
79635: CALL_OW 313
79639: PUSH
79640: LD_INT 3
79642: LESS
79643: IFFALSE 79679
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79645: LD_INT 0
79647: PPUSH
79648: LD_INT 5
79650: PUSH
79651: LD_INT 8
79653: PUSH
79654: LD_INT 9
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: LIST
79661: PUSH
79662: LD_VAR 0 17
79666: ARRAY
79667: PPUSH
79668: LD_VAR 0 4
79672: PPUSH
79673: CALL_OW 380
79677: GO 79696
// PrepareHuman ( false , i , skill ) ;
79679: LD_INT 0
79681: PPUSH
79682: LD_VAR 0 8
79686: PPUSH
79687: LD_VAR 0 4
79691: PPUSH
79692: CALL_OW 380
// end else
79696: GO 79715
// PrepareHuman ( false , i , skill ) ;
79698: LD_INT 0
79700: PPUSH
79701: LD_VAR 0 8
79705: PPUSH
79706: LD_VAR 0 4
79710: PPUSH
79711: CALL_OW 380
// un := CreateHuman ;
79715: LD_ADDR_VAR 0 14
79719: PUSH
79720: CALL_OW 44
79724: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79725: LD_ADDR_VAR 0 7
79729: PUSH
79730: LD_VAR 0 7
79734: PPUSH
79735: LD_INT 1
79737: PPUSH
79738: LD_VAR 0 14
79742: PPUSH
79743: CALL_OW 2
79747: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79748: LD_VAR 0 14
79752: PPUSH
79753: LD_VAR 0 12
79757: PUSH
79758: LD_INT 1
79760: ARRAY
79761: PPUSH
79762: CALL_OW 52
// end ;
79766: GO 79405
79768: POP
79769: POP
// end ;
79770: GO 78707
79772: POP
79773: POP
// result := result ^ buildings ;
79774: LD_ADDR_VAR 0 7
79778: PUSH
79779: LD_VAR 0 7
79783: PUSH
79784: LD_VAR 0 18
79788: ADD
79789: ST_TO_ADDR
// end else
79790: GO 79933
// begin for i = 1 to personel do
79792: LD_ADDR_VAR 0 8
79796: PUSH
79797: DOUBLE
79798: LD_INT 1
79800: DEC
79801: ST_TO_ADDR
79802: LD_VAR 0 6
79806: PUSH
79807: FOR_TO
79808: IFFALSE 79931
// begin if i > 4 then
79810: LD_VAR 0 8
79814: PUSH
79815: LD_INT 4
79817: GREATER
79818: IFFALSE 79822
// break ;
79820: GO 79931
// x := personel [ i ] ;
79822: LD_ADDR_VAR 0 13
79826: PUSH
79827: LD_VAR 0 6
79831: PUSH
79832: LD_VAR 0 8
79836: ARRAY
79837: ST_TO_ADDR
// if x = - 1 then
79838: LD_VAR 0 13
79842: PUSH
79843: LD_INT 1
79845: NEG
79846: EQUAL
79847: IFFALSE 79851
// continue ;
79849: GO 79807
// PrepareHuman ( false , i , skill ) ;
79851: LD_INT 0
79853: PPUSH
79854: LD_VAR 0 8
79858: PPUSH
79859: LD_VAR 0 4
79863: PPUSH
79864: CALL_OW 380
// un := CreateHuman ;
79868: LD_ADDR_VAR 0 14
79872: PUSH
79873: CALL_OW 44
79877: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79878: LD_VAR 0 14
79882: PPUSH
79883: LD_VAR 0 1
79887: PPUSH
79888: CALL_OW 250
79892: PPUSH
79893: LD_VAR 0 1
79897: PPUSH
79898: CALL_OW 251
79902: PPUSH
79903: LD_INT 10
79905: PPUSH
79906: LD_INT 0
79908: PPUSH
79909: CALL_OW 50
// result := result ^ un ;
79913: LD_ADDR_VAR 0 7
79917: PUSH
79918: LD_VAR 0 7
79922: PUSH
79923: LD_VAR 0 14
79927: ADD
79928: ST_TO_ADDR
// end ;
79929: GO 79807
79931: POP
79932: POP
// end ; end ;
79933: LD_VAR 0 7
79937: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
79938: LD_INT 0
79940: PPUSH
79941: PPUSH
79942: PPUSH
79943: PPUSH
79944: PPUSH
79945: PPUSH
79946: PPUSH
79947: PPUSH
79948: PPUSH
79949: PPUSH
79950: PPUSH
79951: PPUSH
79952: PPUSH
79953: PPUSH
79954: PPUSH
79955: PPUSH
// result := false ;
79956: LD_ADDR_VAR 0 3
79960: PUSH
79961: LD_INT 0
79963: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
79964: LD_VAR 0 1
79968: NOT
79969: PUSH
79970: LD_VAR 0 1
79974: PPUSH
79975: CALL_OW 266
79979: PUSH
79980: LD_INT 32
79982: PUSH
79983: LD_INT 33
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: IN
79990: NOT
79991: OR
79992: IFFALSE 79996
// exit ;
79994: GO 81105
// nat := GetNation ( tower ) ;
79996: LD_ADDR_VAR 0 12
80000: PUSH
80001: LD_VAR 0 1
80005: PPUSH
80006: CALL_OW 248
80010: ST_TO_ADDR
// side := GetSide ( tower ) ;
80011: LD_ADDR_VAR 0 16
80015: PUSH
80016: LD_VAR 0 1
80020: PPUSH
80021: CALL_OW 255
80025: ST_TO_ADDR
// x := GetX ( tower ) ;
80026: LD_ADDR_VAR 0 10
80030: PUSH
80031: LD_VAR 0 1
80035: PPUSH
80036: CALL_OW 250
80040: ST_TO_ADDR
// y := GetY ( tower ) ;
80041: LD_ADDR_VAR 0 11
80045: PUSH
80046: LD_VAR 0 1
80050: PPUSH
80051: CALL_OW 251
80055: ST_TO_ADDR
// if not x or not y then
80056: LD_VAR 0 10
80060: NOT
80061: PUSH
80062: LD_VAR 0 11
80066: NOT
80067: OR
80068: IFFALSE 80072
// exit ;
80070: GO 81105
// weapon := 0 ;
80072: LD_ADDR_VAR 0 18
80076: PUSH
80077: LD_INT 0
80079: ST_TO_ADDR
// fac_list := [ ] ;
80080: LD_ADDR_VAR 0 17
80084: PUSH
80085: EMPTY
80086: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80087: LD_ADDR_VAR 0 6
80091: PUSH
80092: LD_VAR 0 1
80096: PPUSH
80097: CALL_OW 274
80101: PPUSH
80102: LD_VAR 0 2
80106: PPUSH
80107: LD_INT 0
80109: PPUSH
80110: CALL 77676 0 3
80114: PPUSH
80115: LD_INT 30
80117: PUSH
80118: LD_INT 3
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PPUSH
80125: CALL_OW 72
80129: ST_TO_ADDR
// if not factories then
80130: LD_VAR 0 6
80134: NOT
80135: IFFALSE 80139
// exit ;
80137: GO 81105
// for i in factories do
80139: LD_ADDR_VAR 0 8
80143: PUSH
80144: LD_VAR 0 6
80148: PUSH
80149: FOR_IN
80150: IFFALSE 80175
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80152: LD_ADDR_VAR 0 17
80156: PUSH
80157: LD_VAR 0 17
80161: PUSH
80162: LD_VAR 0 8
80166: PPUSH
80167: CALL_OW 478
80171: UNION
80172: ST_TO_ADDR
80173: GO 80149
80175: POP
80176: POP
// if not fac_list then
80177: LD_VAR 0 17
80181: NOT
80182: IFFALSE 80186
// exit ;
80184: GO 81105
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80186: LD_ADDR_VAR 0 5
80190: PUSH
80191: LD_INT 4
80193: PUSH
80194: LD_INT 5
80196: PUSH
80197: LD_INT 9
80199: PUSH
80200: LD_INT 10
80202: PUSH
80203: LD_INT 6
80205: PUSH
80206: LD_INT 7
80208: PUSH
80209: LD_INT 11
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 27
80223: PUSH
80224: LD_INT 28
80226: PUSH
80227: LD_INT 26
80229: PUSH
80230: LD_INT 30
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 43
80241: PUSH
80242: LD_INT 44
80244: PUSH
80245: LD_INT 46
80247: PUSH
80248: LD_INT 45
80250: PUSH
80251: LD_INT 47
80253: PUSH
80254: LD_INT 49
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: LIST
80269: PUSH
80270: LD_VAR 0 12
80274: ARRAY
80275: ST_TO_ADDR
// list := list isect fac_list ;
80276: LD_ADDR_VAR 0 5
80280: PUSH
80281: LD_VAR 0 5
80285: PUSH
80286: LD_VAR 0 17
80290: ISECT
80291: ST_TO_ADDR
// if not list then
80292: LD_VAR 0 5
80296: NOT
80297: IFFALSE 80301
// exit ;
80299: GO 81105
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80301: LD_VAR 0 12
80305: PUSH
80306: LD_INT 3
80308: EQUAL
80309: PUSH
80310: LD_INT 49
80312: PUSH
80313: LD_VAR 0 5
80317: IN
80318: AND
80319: PUSH
80320: LD_INT 31
80322: PPUSH
80323: LD_VAR 0 16
80327: PPUSH
80328: CALL_OW 321
80332: PUSH
80333: LD_INT 2
80335: EQUAL
80336: AND
80337: IFFALSE 80397
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80339: LD_INT 22
80341: PUSH
80342: LD_VAR 0 16
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 35
80353: PUSH
80354: LD_INT 49
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 91
80363: PUSH
80364: LD_VAR 0 1
80368: PUSH
80369: LD_INT 10
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: LIST
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: LIST
80381: PPUSH
80382: CALL_OW 69
80386: NOT
80387: IFFALSE 80397
// weapon := ru_time_lapser ;
80389: LD_ADDR_VAR 0 18
80393: PUSH
80394: LD_INT 49
80396: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80397: LD_VAR 0 12
80401: PUSH
80402: LD_INT 1
80404: PUSH
80405: LD_INT 2
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: IN
80412: PUSH
80413: LD_INT 11
80415: PUSH
80416: LD_VAR 0 5
80420: IN
80421: PUSH
80422: LD_INT 30
80424: PUSH
80425: LD_VAR 0 5
80429: IN
80430: OR
80431: AND
80432: PUSH
80433: LD_INT 6
80435: PPUSH
80436: LD_VAR 0 16
80440: PPUSH
80441: CALL_OW 321
80445: PUSH
80446: LD_INT 2
80448: EQUAL
80449: AND
80450: IFFALSE 80615
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80452: LD_INT 22
80454: PUSH
80455: LD_VAR 0 16
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: PUSH
80464: LD_INT 2
80466: PUSH
80467: LD_INT 35
80469: PUSH
80470: LD_INT 11
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 35
80479: PUSH
80480: LD_INT 30
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 91
80494: PUSH
80495: LD_VAR 0 1
80499: PUSH
80500: LD_INT 18
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: LIST
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: LIST
80512: PPUSH
80513: CALL_OW 69
80517: NOT
80518: PUSH
80519: LD_INT 22
80521: PUSH
80522: LD_VAR 0 16
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 2
80533: PUSH
80534: LD_INT 30
80536: PUSH
80537: LD_INT 32
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 30
80546: PUSH
80547: LD_INT 33
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 91
80561: PUSH
80562: LD_VAR 0 1
80566: PUSH
80567: LD_INT 12
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: LIST
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: LIST
80579: PUSH
80580: EMPTY
80581: LIST
80582: PPUSH
80583: CALL_OW 69
80587: PUSH
80588: LD_INT 2
80590: GREATER
80591: AND
80592: IFFALSE 80615
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80594: LD_ADDR_VAR 0 18
80598: PUSH
80599: LD_INT 11
80601: PUSH
80602: LD_INT 30
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_VAR 0 12
80613: ARRAY
80614: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80615: LD_VAR 0 18
80619: NOT
80620: PUSH
80621: LD_INT 40
80623: PPUSH
80624: LD_VAR 0 16
80628: PPUSH
80629: CALL_OW 321
80633: PUSH
80634: LD_INT 2
80636: EQUAL
80637: AND
80638: PUSH
80639: LD_INT 7
80641: PUSH
80642: LD_VAR 0 5
80646: IN
80647: PUSH
80648: LD_INT 28
80650: PUSH
80651: LD_VAR 0 5
80655: IN
80656: OR
80657: PUSH
80658: LD_INT 45
80660: PUSH
80661: LD_VAR 0 5
80665: IN
80666: OR
80667: AND
80668: IFFALSE 80922
// begin hex := GetHexInfo ( x , y ) ;
80670: LD_ADDR_VAR 0 4
80674: PUSH
80675: LD_VAR 0 10
80679: PPUSH
80680: LD_VAR 0 11
80684: PPUSH
80685: CALL_OW 546
80689: ST_TO_ADDR
// if hex [ 1 ] then
80690: LD_VAR 0 4
80694: PUSH
80695: LD_INT 1
80697: ARRAY
80698: IFFALSE 80702
// exit ;
80700: GO 81105
// height := hex [ 2 ] ;
80702: LD_ADDR_VAR 0 15
80706: PUSH
80707: LD_VAR 0 4
80711: PUSH
80712: LD_INT 2
80714: ARRAY
80715: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80716: LD_ADDR_VAR 0 14
80720: PUSH
80721: LD_INT 0
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: LD_INT 3
80729: PUSH
80730: LD_INT 5
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: ST_TO_ADDR
// for i in tmp do
80739: LD_ADDR_VAR 0 8
80743: PUSH
80744: LD_VAR 0 14
80748: PUSH
80749: FOR_IN
80750: IFFALSE 80920
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80752: LD_ADDR_VAR 0 9
80756: PUSH
80757: LD_VAR 0 10
80761: PPUSH
80762: LD_VAR 0 8
80766: PPUSH
80767: LD_INT 5
80769: PPUSH
80770: CALL_OW 272
80774: PUSH
80775: LD_VAR 0 11
80779: PPUSH
80780: LD_VAR 0 8
80784: PPUSH
80785: LD_INT 5
80787: PPUSH
80788: CALL_OW 273
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80797: LD_VAR 0 9
80801: PUSH
80802: LD_INT 1
80804: ARRAY
80805: PPUSH
80806: LD_VAR 0 9
80810: PUSH
80811: LD_INT 2
80813: ARRAY
80814: PPUSH
80815: CALL_OW 488
80819: IFFALSE 80918
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80821: LD_ADDR_VAR 0 4
80825: PUSH
80826: LD_VAR 0 9
80830: PUSH
80831: LD_INT 1
80833: ARRAY
80834: PPUSH
80835: LD_VAR 0 9
80839: PUSH
80840: LD_INT 2
80842: ARRAY
80843: PPUSH
80844: CALL_OW 546
80848: ST_TO_ADDR
// if hex [ 1 ] then
80849: LD_VAR 0 4
80853: PUSH
80854: LD_INT 1
80856: ARRAY
80857: IFFALSE 80861
// continue ;
80859: GO 80749
// h := hex [ 2 ] ;
80861: LD_ADDR_VAR 0 13
80865: PUSH
80866: LD_VAR 0 4
80870: PUSH
80871: LD_INT 2
80873: ARRAY
80874: ST_TO_ADDR
// if h + 7 < height then
80875: LD_VAR 0 13
80879: PUSH
80880: LD_INT 7
80882: PLUS
80883: PUSH
80884: LD_VAR 0 15
80888: LESS
80889: IFFALSE 80918
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80891: LD_ADDR_VAR 0 18
80895: PUSH
80896: LD_INT 7
80898: PUSH
80899: LD_INT 28
80901: PUSH
80902: LD_INT 45
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: LIST
80909: PUSH
80910: LD_VAR 0 12
80914: ARRAY
80915: ST_TO_ADDR
// break ;
80916: GO 80920
// end ; end ; end ;
80918: GO 80749
80920: POP
80921: POP
// end ; if not weapon then
80922: LD_VAR 0 18
80926: NOT
80927: IFFALSE 80987
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
80929: LD_ADDR_VAR 0 5
80933: PUSH
80934: LD_VAR 0 5
80938: PUSH
80939: LD_INT 11
80941: PUSH
80942: LD_INT 30
80944: PUSH
80945: LD_INT 49
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: LIST
80952: DIFF
80953: ST_TO_ADDR
// if not list then
80954: LD_VAR 0 5
80958: NOT
80959: IFFALSE 80963
// exit ;
80961: GO 81105
// weapon := list [ rand ( 1 , list ) ] ;
80963: LD_ADDR_VAR 0 18
80967: PUSH
80968: LD_VAR 0 5
80972: PUSH
80973: LD_INT 1
80975: PPUSH
80976: LD_VAR 0 5
80980: PPUSH
80981: CALL_OW 12
80985: ARRAY
80986: ST_TO_ADDR
// end ; if weapon then
80987: LD_VAR 0 18
80991: IFFALSE 81105
// begin tmp := CostOfWeapon ( weapon ) ;
80993: LD_ADDR_VAR 0 14
80997: PUSH
80998: LD_VAR 0 18
81002: PPUSH
81003: CALL_OW 451
81007: ST_TO_ADDR
// j := GetBase ( tower ) ;
81008: LD_ADDR_VAR 0 9
81012: PUSH
81013: LD_VAR 0 1
81017: PPUSH
81018: CALL_OW 274
81022: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81023: LD_VAR 0 9
81027: PPUSH
81028: LD_INT 1
81030: PPUSH
81031: CALL_OW 275
81035: PUSH
81036: LD_VAR 0 14
81040: PUSH
81041: LD_INT 1
81043: ARRAY
81044: GREATEREQUAL
81045: PUSH
81046: LD_VAR 0 9
81050: PPUSH
81051: LD_INT 2
81053: PPUSH
81054: CALL_OW 275
81058: PUSH
81059: LD_VAR 0 14
81063: PUSH
81064: LD_INT 2
81066: ARRAY
81067: GREATEREQUAL
81068: AND
81069: PUSH
81070: LD_VAR 0 9
81074: PPUSH
81075: LD_INT 3
81077: PPUSH
81078: CALL_OW 275
81082: PUSH
81083: LD_VAR 0 14
81087: PUSH
81088: LD_INT 3
81090: ARRAY
81091: GREATEREQUAL
81092: AND
81093: IFFALSE 81105
// result := weapon ;
81095: LD_ADDR_VAR 0 3
81099: PUSH
81100: LD_VAR 0 18
81104: ST_TO_ADDR
// end ; end ;
81105: LD_VAR 0 3
81109: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81110: LD_INT 0
81112: PPUSH
81113: PPUSH
// result := true ;
81114: LD_ADDR_VAR 0 3
81118: PUSH
81119: LD_INT 1
81121: ST_TO_ADDR
// if array1 = array2 then
81122: LD_VAR 0 1
81126: PUSH
81127: LD_VAR 0 2
81131: EQUAL
81132: IFFALSE 81192
// begin for i = 1 to array1 do
81134: LD_ADDR_VAR 0 4
81138: PUSH
81139: DOUBLE
81140: LD_INT 1
81142: DEC
81143: ST_TO_ADDR
81144: LD_VAR 0 1
81148: PUSH
81149: FOR_TO
81150: IFFALSE 81188
// if array1 [ i ] <> array2 [ i ] then
81152: LD_VAR 0 1
81156: PUSH
81157: LD_VAR 0 4
81161: ARRAY
81162: PUSH
81163: LD_VAR 0 2
81167: PUSH
81168: LD_VAR 0 4
81172: ARRAY
81173: NONEQUAL
81174: IFFALSE 81186
// begin result := false ;
81176: LD_ADDR_VAR 0 3
81180: PUSH
81181: LD_INT 0
81183: ST_TO_ADDR
// break ;
81184: GO 81188
// end ;
81186: GO 81149
81188: POP
81189: POP
// end else
81190: GO 81200
// result := false ;
81192: LD_ADDR_VAR 0 3
81196: PUSH
81197: LD_INT 0
81199: ST_TO_ADDR
// end ;
81200: LD_VAR 0 3
81204: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81205: LD_INT 0
81207: PPUSH
81208: PPUSH
// if not array1 or not array2 then
81209: LD_VAR 0 1
81213: NOT
81214: PUSH
81215: LD_VAR 0 2
81219: NOT
81220: OR
81221: IFFALSE 81225
// exit ;
81223: GO 81289
// result := true ;
81225: LD_ADDR_VAR 0 3
81229: PUSH
81230: LD_INT 1
81232: ST_TO_ADDR
// for i = 1 to array1 do
81233: LD_ADDR_VAR 0 4
81237: PUSH
81238: DOUBLE
81239: LD_INT 1
81241: DEC
81242: ST_TO_ADDR
81243: LD_VAR 0 1
81247: PUSH
81248: FOR_TO
81249: IFFALSE 81287
// if array1 [ i ] <> array2 [ i ] then
81251: LD_VAR 0 1
81255: PUSH
81256: LD_VAR 0 4
81260: ARRAY
81261: PUSH
81262: LD_VAR 0 2
81266: PUSH
81267: LD_VAR 0 4
81271: ARRAY
81272: NONEQUAL
81273: IFFALSE 81285
// begin result := false ;
81275: LD_ADDR_VAR 0 3
81279: PUSH
81280: LD_INT 0
81282: ST_TO_ADDR
// break ;
81283: GO 81287
// end ;
81285: GO 81248
81287: POP
81288: POP
// end ;
81289: LD_VAR 0 3
81293: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81294: LD_INT 0
81296: PPUSH
81297: PPUSH
81298: PPUSH
// pom := GetBase ( fac ) ;
81299: LD_ADDR_VAR 0 5
81303: PUSH
81304: LD_VAR 0 1
81308: PPUSH
81309: CALL_OW 274
81313: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81314: LD_ADDR_VAR 0 4
81318: PUSH
81319: LD_VAR 0 2
81323: PUSH
81324: LD_INT 1
81326: ARRAY
81327: PPUSH
81328: LD_VAR 0 2
81332: PUSH
81333: LD_INT 2
81335: ARRAY
81336: PPUSH
81337: LD_VAR 0 2
81341: PUSH
81342: LD_INT 3
81344: ARRAY
81345: PPUSH
81346: LD_VAR 0 2
81350: PUSH
81351: LD_INT 4
81353: ARRAY
81354: PPUSH
81355: CALL_OW 449
81359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81360: LD_ADDR_VAR 0 3
81364: PUSH
81365: LD_VAR 0 5
81369: PPUSH
81370: LD_INT 1
81372: PPUSH
81373: CALL_OW 275
81377: PUSH
81378: LD_VAR 0 4
81382: PUSH
81383: LD_INT 1
81385: ARRAY
81386: GREATEREQUAL
81387: PUSH
81388: LD_VAR 0 5
81392: PPUSH
81393: LD_INT 2
81395: PPUSH
81396: CALL_OW 275
81400: PUSH
81401: LD_VAR 0 4
81405: PUSH
81406: LD_INT 2
81408: ARRAY
81409: GREATEREQUAL
81410: AND
81411: PUSH
81412: LD_VAR 0 5
81416: PPUSH
81417: LD_INT 3
81419: PPUSH
81420: CALL_OW 275
81424: PUSH
81425: LD_VAR 0 4
81429: PUSH
81430: LD_INT 3
81432: ARRAY
81433: GREATEREQUAL
81434: AND
81435: ST_TO_ADDR
// end ;
81436: LD_VAR 0 3
81440: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81441: LD_INT 0
81443: PPUSH
81444: PPUSH
81445: PPUSH
81446: PPUSH
// pom := GetBase ( building ) ;
81447: LD_ADDR_VAR 0 3
81451: PUSH
81452: LD_VAR 0 1
81456: PPUSH
81457: CALL_OW 274
81461: ST_TO_ADDR
// if not pom then
81462: LD_VAR 0 3
81466: NOT
81467: IFFALSE 81471
// exit ;
81469: GO 81641
// btype := GetBType ( building ) ;
81471: LD_ADDR_VAR 0 5
81475: PUSH
81476: LD_VAR 0 1
81480: PPUSH
81481: CALL_OW 266
81485: ST_TO_ADDR
// if btype = b_armoury then
81486: LD_VAR 0 5
81490: PUSH
81491: LD_INT 4
81493: EQUAL
81494: IFFALSE 81504
// btype := b_barracks ;
81496: LD_ADDR_VAR 0 5
81500: PUSH
81501: LD_INT 5
81503: ST_TO_ADDR
// if btype = b_depot then
81504: LD_VAR 0 5
81508: PUSH
81509: LD_INT 0
81511: EQUAL
81512: IFFALSE 81522
// btype := b_warehouse ;
81514: LD_ADDR_VAR 0 5
81518: PUSH
81519: LD_INT 1
81521: ST_TO_ADDR
// if btype = b_workshop then
81522: LD_VAR 0 5
81526: PUSH
81527: LD_INT 2
81529: EQUAL
81530: IFFALSE 81540
// btype := b_factory ;
81532: LD_ADDR_VAR 0 5
81536: PUSH
81537: LD_INT 3
81539: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81540: LD_ADDR_VAR 0 4
81544: PUSH
81545: LD_VAR 0 5
81549: PPUSH
81550: LD_VAR 0 1
81554: PPUSH
81555: CALL_OW 248
81559: PPUSH
81560: CALL_OW 450
81564: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81565: LD_ADDR_VAR 0 2
81569: PUSH
81570: LD_VAR 0 3
81574: PPUSH
81575: LD_INT 1
81577: PPUSH
81578: CALL_OW 275
81582: PUSH
81583: LD_VAR 0 4
81587: PUSH
81588: LD_INT 1
81590: ARRAY
81591: GREATEREQUAL
81592: PUSH
81593: LD_VAR 0 3
81597: PPUSH
81598: LD_INT 2
81600: PPUSH
81601: CALL_OW 275
81605: PUSH
81606: LD_VAR 0 4
81610: PUSH
81611: LD_INT 2
81613: ARRAY
81614: GREATEREQUAL
81615: AND
81616: PUSH
81617: LD_VAR 0 3
81621: PPUSH
81622: LD_INT 3
81624: PPUSH
81625: CALL_OW 275
81629: PUSH
81630: LD_VAR 0 4
81634: PUSH
81635: LD_INT 3
81637: ARRAY
81638: GREATEREQUAL
81639: AND
81640: ST_TO_ADDR
// end ;
81641: LD_VAR 0 2
81645: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81646: LD_INT 0
81648: PPUSH
81649: PPUSH
81650: PPUSH
// pom := GetBase ( building ) ;
81651: LD_ADDR_VAR 0 4
81655: PUSH
81656: LD_VAR 0 1
81660: PPUSH
81661: CALL_OW 274
81665: ST_TO_ADDR
// if not pom then
81666: LD_VAR 0 4
81670: NOT
81671: IFFALSE 81675
// exit ;
81673: GO 81776
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81675: LD_ADDR_VAR 0 5
81679: PUSH
81680: LD_VAR 0 2
81684: PPUSH
81685: LD_VAR 0 1
81689: PPUSH
81690: CALL_OW 248
81694: PPUSH
81695: CALL_OW 450
81699: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81700: LD_ADDR_VAR 0 3
81704: PUSH
81705: LD_VAR 0 4
81709: PPUSH
81710: LD_INT 1
81712: PPUSH
81713: CALL_OW 275
81717: PUSH
81718: LD_VAR 0 5
81722: PUSH
81723: LD_INT 1
81725: ARRAY
81726: GREATEREQUAL
81727: PUSH
81728: LD_VAR 0 4
81732: PPUSH
81733: LD_INT 2
81735: PPUSH
81736: CALL_OW 275
81740: PUSH
81741: LD_VAR 0 5
81745: PUSH
81746: LD_INT 2
81748: ARRAY
81749: GREATEREQUAL
81750: AND
81751: PUSH
81752: LD_VAR 0 4
81756: PPUSH
81757: LD_INT 3
81759: PPUSH
81760: CALL_OW 275
81764: PUSH
81765: LD_VAR 0 5
81769: PUSH
81770: LD_INT 3
81772: ARRAY
81773: GREATEREQUAL
81774: AND
81775: ST_TO_ADDR
// end ;
81776: LD_VAR 0 3
81780: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81781: LD_INT 0
81783: PPUSH
81784: PPUSH
81785: PPUSH
81786: PPUSH
81787: PPUSH
81788: PPUSH
81789: PPUSH
81790: PPUSH
81791: PPUSH
81792: PPUSH
81793: PPUSH
// result := false ;
81794: LD_ADDR_VAR 0 8
81798: PUSH
81799: LD_INT 0
81801: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81802: LD_VAR 0 5
81806: NOT
81807: PUSH
81808: LD_VAR 0 1
81812: NOT
81813: OR
81814: PUSH
81815: LD_VAR 0 2
81819: NOT
81820: OR
81821: PUSH
81822: LD_VAR 0 3
81826: NOT
81827: OR
81828: IFFALSE 81832
// exit ;
81830: GO 82646
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81832: LD_ADDR_VAR 0 14
81836: PUSH
81837: LD_VAR 0 1
81841: PPUSH
81842: LD_VAR 0 2
81846: PPUSH
81847: LD_VAR 0 3
81851: PPUSH
81852: LD_VAR 0 4
81856: PPUSH
81857: LD_VAR 0 5
81861: PUSH
81862: LD_INT 1
81864: ARRAY
81865: PPUSH
81866: CALL_OW 248
81870: PPUSH
81871: LD_INT 0
81873: PPUSH
81874: CALL 83899 0 6
81878: ST_TO_ADDR
// if not hexes then
81879: LD_VAR 0 14
81883: NOT
81884: IFFALSE 81888
// exit ;
81886: GO 82646
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81888: LD_ADDR_VAR 0 17
81892: PUSH
81893: LD_VAR 0 5
81897: PPUSH
81898: LD_INT 22
81900: PUSH
81901: LD_VAR 0 13
81905: PPUSH
81906: CALL_OW 255
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 2
81917: PUSH
81918: LD_INT 30
81920: PUSH
81921: LD_INT 0
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 30
81930: PUSH
81931: LD_INT 1
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: LIST
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PPUSH
81947: CALL_OW 72
81951: ST_TO_ADDR
// for i = 1 to hexes do
81952: LD_ADDR_VAR 0 9
81956: PUSH
81957: DOUBLE
81958: LD_INT 1
81960: DEC
81961: ST_TO_ADDR
81962: LD_VAR 0 14
81966: PUSH
81967: FOR_TO
81968: IFFALSE 82644
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81970: LD_ADDR_VAR 0 13
81974: PUSH
81975: LD_VAR 0 14
81979: PUSH
81980: LD_VAR 0 9
81984: ARRAY
81985: PUSH
81986: LD_INT 1
81988: ARRAY
81989: PPUSH
81990: LD_VAR 0 14
81994: PUSH
81995: LD_VAR 0 9
81999: ARRAY
82000: PUSH
82001: LD_INT 2
82003: ARRAY
82004: PPUSH
82005: CALL_OW 428
82009: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82010: LD_VAR 0 14
82014: PUSH
82015: LD_VAR 0 9
82019: ARRAY
82020: PUSH
82021: LD_INT 1
82023: ARRAY
82024: PPUSH
82025: LD_VAR 0 14
82029: PUSH
82030: LD_VAR 0 9
82034: ARRAY
82035: PUSH
82036: LD_INT 2
82038: ARRAY
82039: PPUSH
82040: CALL_OW 351
82044: PUSH
82045: LD_VAR 0 14
82049: PUSH
82050: LD_VAR 0 9
82054: ARRAY
82055: PUSH
82056: LD_INT 1
82058: ARRAY
82059: PPUSH
82060: LD_VAR 0 14
82064: PUSH
82065: LD_VAR 0 9
82069: ARRAY
82070: PUSH
82071: LD_INT 2
82073: ARRAY
82074: PPUSH
82075: CALL_OW 488
82079: NOT
82080: OR
82081: PUSH
82082: LD_VAR 0 13
82086: PPUSH
82087: CALL_OW 247
82091: PUSH
82092: LD_INT 3
82094: EQUAL
82095: OR
82096: IFFALSE 82102
// exit ;
82098: POP
82099: POP
82100: GO 82646
// if not tmp then
82102: LD_VAR 0 13
82106: NOT
82107: IFFALSE 82111
// continue ;
82109: GO 81967
// result := true ;
82111: LD_ADDR_VAR 0 8
82115: PUSH
82116: LD_INT 1
82118: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82119: LD_VAR 0 6
82123: PUSH
82124: LD_VAR 0 13
82128: PPUSH
82129: CALL_OW 247
82133: PUSH
82134: LD_INT 2
82136: EQUAL
82137: AND
82138: PUSH
82139: LD_VAR 0 13
82143: PPUSH
82144: CALL_OW 263
82148: PUSH
82149: LD_INT 1
82151: EQUAL
82152: AND
82153: IFFALSE 82317
// begin if IsDrivenBy ( tmp ) then
82155: LD_VAR 0 13
82159: PPUSH
82160: CALL_OW 311
82164: IFFALSE 82168
// continue ;
82166: GO 81967
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82168: LD_VAR 0 6
82172: PPUSH
82173: LD_INT 3
82175: PUSH
82176: LD_INT 60
82178: PUSH
82179: EMPTY
82180: LIST
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 3
82188: PUSH
82189: LD_INT 55
82191: PUSH
82192: EMPTY
82193: LIST
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PPUSH
82203: CALL_OW 72
82207: IFFALSE 82315
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82209: LD_ADDR_VAR 0 18
82213: PUSH
82214: LD_VAR 0 6
82218: PPUSH
82219: LD_INT 3
82221: PUSH
82222: LD_INT 60
82224: PUSH
82225: EMPTY
82226: LIST
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 3
82234: PUSH
82235: LD_INT 55
82237: PUSH
82238: EMPTY
82239: LIST
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PPUSH
82249: CALL_OW 72
82253: PUSH
82254: LD_INT 1
82256: ARRAY
82257: ST_TO_ADDR
// if IsInUnit ( driver ) then
82258: LD_VAR 0 18
82262: PPUSH
82263: CALL_OW 310
82267: IFFALSE 82278
// ComExit ( driver ) ;
82269: LD_VAR 0 18
82273: PPUSH
82274: CALL 107680 0 1
// AddComEnterUnit ( driver , tmp ) ;
82278: LD_VAR 0 18
82282: PPUSH
82283: LD_VAR 0 13
82287: PPUSH
82288: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82292: LD_VAR 0 18
82296: PPUSH
82297: LD_VAR 0 7
82301: PPUSH
82302: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82306: LD_VAR 0 18
82310: PPUSH
82311: CALL_OW 181
// end ; continue ;
82315: GO 81967
// end ; if not cleaners or not tmp in cleaners then
82317: LD_VAR 0 6
82321: NOT
82322: PUSH
82323: LD_VAR 0 13
82327: PUSH
82328: LD_VAR 0 6
82332: IN
82333: NOT
82334: OR
82335: IFFALSE 82642
// begin if dep then
82337: LD_VAR 0 17
82341: IFFALSE 82477
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82343: LD_ADDR_VAR 0 16
82347: PUSH
82348: LD_VAR 0 17
82352: PUSH
82353: LD_INT 1
82355: ARRAY
82356: PPUSH
82357: CALL_OW 250
82361: PPUSH
82362: LD_VAR 0 17
82366: PUSH
82367: LD_INT 1
82369: ARRAY
82370: PPUSH
82371: CALL_OW 254
82375: PPUSH
82376: LD_INT 5
82378: PPUSH
82379: CALL_OW 272
82383: PUSH
82384: LD_VAR 0 17
82388: PUSH
82389: LD_INT 1
82391: ARRAY
82392: PPUSH
82393: CALL_OW 251
82397: PPUSH
82398: LD_VAR 0 17
82402: PUSH
82403: LD_INT 1
82405: ARRAY
82406: PPUSH
82407: CALL_OW 254
82411: PPUSH
82412: LD_INT 5
82414: PPUSH
82415: CALL_OW 273
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82424: LD_VAR 0 16
82428: PUSH
82429: LD_INT 1
82431: ARRAY
82432: PPUSH
82433: LD_VAR 0 16
82437: PUSH
82438: LD_INT 2
82440: ARRAY
82441: PPUSH
82442: CALL_OW 488
82446: IFFALSE 82477
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82448: LD_VAR 0 13
82452: PPUSH
82453: LD_VAR 0 16
82457: PUSH
82458: LD_INT 1
82460: ARRAY
82461: PPUSH
82462: LD_VAR 0 16
82466: PUSH
82467: LD_INT 2
82469: ARRAY
82470: PPUSH
82471: CALL_OW 111
// continue ;
82475: GO 81967
// end ; end ; r := GetDir ( tmp ) ;
82477: LD_ADDR_VAR 0 15
82481: PUSH
82482: LD_VAR 0 13
82486: PPUSH
82487: CALL_OW 254
82491: ST_TO_ADDR
// if r = 5 then
82492: LD_VAR 0 15
82496: PUSH
82497: LD_INT 5
82499: EQUAL
82500: IFFALSE 82510
// r := 0 ;
82502: LD_ADDR_VAR 0 15
82506: PUSH
82507: LD_INT 0
82509: ST_TO_ADDR
// for j = r to 5 do
82510: LD_ADDR_VAR 0 10
82514: PUSH
82515: DOUBLE
82516: LD_VAR 0 15
82520: DEC
82521: ST_TO_ADDR
82522: LD_INT 5
82524: PUSH
82525: FOR_TO
82526: IFFALSE 82640
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82528: LD_ADDR_VAR 0 11
82532: PUSH
82533: LD_VAR 0 13
82537: PPUSH
82538: CALL_OW 250
82542: PPUSH
82543: LD_VAR 0 10
82547: PPUSH
82548: LD_INT 2
82550: PPUSH
82551: CALL_OW 272
82555: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82556: LD_ADDR_VAR 0 12
82560: PUSH
82561: LD_VAR 0 13
82565: PPUSH
82566: CALL_OW 251
82570: PPUSH
82571: LD_VAR 0 10
82575: PPUSH
82576: LD_INT 2
82578: PPUSH
82579: CALL_OW 273
82583: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82584: LD_VAR 0 11
82588: PPUSH
82589: LD_VAR 0 12
82593: PPUSH
82594: CALL_OW 488
82598: PUSH
82599: LD_VAR 0 11
82603: PPUSH
82604: LD_VAR 0 12
82608: PPUSH
82609: CALL_OW 428
82613: NOT
82614: AND
82615: IFFALSE 82638
// begin ComMoveXY ( tmp , _x , _y ) ;
82617: LD_VAR 0 13
82621: PPUSH
82622: LD_VAR 0 11
82626: PPUSH
82627: LD_VAR 0 12
82631: PPUSH
82632: CALL_OW 111
// break ;
82636: GO 82640
// end ; end ;
82638: GO 82525
82640: POP
82641: POP
// end ; end ;
82642: GO 81967
82644: POP
82645: POP
// end ;
82646: LD_VAR 0 8
82650: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82651: LD_INT 0
82653: PPUSH
// result := true ;
82654: LD_ADDR_VAR 0 3
82658: PUSH
82659: LD_INT 1
82661: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82662: LD_VAR 0 2
82666: PUSH
82667: LD_INT 24
82669: DOUBLE
82670: EQUAL
82671: IFTRUE 82681
82673: LD_INT 33
82675: DOUBLE
82676: EQUAL
82677: IFTRUE 82681
82679: GO 82706
82681: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82682: LD_ADDR_VAR 0 3
82686: PUSH
82687: LD_INT 32
82689: PPUSH
82690: LD_VAR 0 1
82694: PPUSH
82695: CALL_OW 321
82699: PUSH
82700: LD_INT 2
82702: EQUAL
82703: ST_TO_ADDR
82704: GO 83022
82706: LD_INT 20
82708: DOUBLE
82709: EQUAL
82710: IFTRUE 82714
82712: GO 82739
82714: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82715: LD_ADDR_VAR 0 3
82719: PUSH
82720: LD_INT 6
82722: PPUSH
82723: LD_VAR 0 1
82727: PPUSH
82728: CALL_OW 321
82732: PUSH
82733: LD_INT 2
82735: EQUAL
82736: ST_TO_ADDR
82737: GO 83022
82739: LD_INT 22
82741: DOUBLE
82742: EQUAL
82743: IFTRUE 82753
82745: LD_INT 36
82747: DOUBLE
82748: EQUAL
82749: IFTRUE 82753
82751: GO 82778
82753: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82754: LD_ADDR_VAR 0 3
82758: PUSH
82759: LD_INT 15
82761: PPUSH
82762: LD_VAR 0 1
82766: PPUSH
82767: CALL_OW 321
82771: PUSH
82772: LD_INT 2
82774: EQUAL
82775: ST_TO_ADDR
82776: GO 83022
82778: LD_INT 30
82780: DOUBLE
82781: EQUAL
82782: IFTRUE 82786
82784: GO 82811
82786: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82787: LD_ADDR_VAR 0 3
82791: PUSH
82792: LD_INT 20
82794: PPUSH
82795: LD_VAR 0 1
82799: PPUSH
82800: CALL_OW 321
82804: PUSH
82805: LD_INT 2
82807: EQUAL
82808: ST_TO_ADDR
82809: GO 83022
82811: LD_INT 28
82813: DOUBLE
82814: EQUAL
82815: IFTRUE 82825
82817: LD_INT 21
82819: DOUBLE
82820: EQUAL
82821: IFTRUE 82825
82823: GO 82850
82825: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82826: LD_ADDR_VAR 0 3
82830: PUSH
82831: LD_INT 21
82833: PPUSH
82834: LD_VAR 0 1
82838: PPUSH
82839: CALL_OW 321
82843: PUSH
82844: LD_INT 2
82846: EQUAL
82847: ST_TO_ADDR
82848: GO 83022
82850: LD_INT 16
82852: DOUBLE
82853: EQUAL
82854: IFTRUE 82858
82856: GO 82883
82858: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82859: LD_ADDR_VAR 0 3
82863: PUSH
82864: LD_INT 84
82866: PPUSH
82867: LD_VAR 0 1
82871: PPUSH
82872: CALL_OW 321
82876: PUSH
82877: LD_INT 2
82879: EQUAL
82880: ST_TO_ADDR
82881: GO 83022
82883: LD_INT 19
82885: DOUBLE
82886: EQUAL
82887: IFTRUE 82897
82889: LD_INT 23
82891: DOUBLE
82892: EQUAL
82893: IFTRUE 82897
82895: GO 82922
82897: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82898: LD_ADDR_VAR 0 3
82902: PUSH
82903: LD_INT 83
82905: PPUSH
82906: LD_VAR 0 1
82910: PPUSH
82911: CALL_OW 321
82915: PUSH
82916: LD_INT 2
82918: EQUAL
82919: ST_TO_ADDR
82920: GO 83022
82922: LD_INT 17
82924: DOUBLE
82925: EQUAL
82926: IFTRUE 82930
82928: GO 82955
82930: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
82931: LD_ADDR_VAR 0 3
82935: PUSH
82936: LD_INT 39
82938: PPUSH
82939: LD_VAR 0 1
82943: PPUSH
82944: CALL_OW 321
82948: PUSH
82949: LD_INT 2
82951: EQUAL
82952: ST_TO_ADDR
82953: GO 83022
82955: LD_INT 18
82957: DOUBLE
82958: EQUAL
82959: IFTRUE 82963
82961: GO 82988
82963: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
82964: LD_ADDR_VAR 0 3
82968: PUSH
82969: LD_INT 40
82971: PPUSH
82972: LD_VAR 0 1
82976: PPUSH
82977: CALL_OW 321
82981: PUSH
82982: LD_INT 2
82984: EQUAL
82985: ST_TO_ADDR
82986: GO 83022
82988: LD_INT 27
82990: DOUBLE
82991: EQUAL
82992: IFTRUE 82996
82994: GO 83021
82996: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
82997: LD_ADDR_VAR 0 3
83001: PUSH
83002: LD_INT 35
83004: PPUSH
83005: LD_VAR 0 1
83009: PPUSH
83010: CALL_OW 321
83014: PUSH
83015: LD_INT 2
83017: EQUAL
83018: ST_TO_ADDR
83019: GO 83022
83021: POP
// end ;
83022: LD_VAR 0 3
83026: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83027: LD_INT 0
83029: PPUSH
83030: PPUSH
83031: PPUSH
83032: PPUSH
83033: PPUSH
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
// result := false ;
83040: LD_ADDR_VAR 0 6
83044: PUSH
83045: LD_INT 0
83047: ST_TO_ADDR
// if btype = b_depot then
83048: LD_VAR 0 2
83052: PUSH
83053: LD_INT 0
83055: EQUAL
83056: IFFALSE 83068
// begin result := true ;
83058: LD_ADDR_VAR 0 6
83062: PUSH
83063: LD_INT 1
83065: ST_TO_ADDR
// exit ;
83066: GO 83894
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83068: LD_VAR 0 1
83072: NOT
83073: PUSH
83074: LD_VAR 0 1
83078: PPUSH
83079: CALL_OW 266
83083: PUSH
83084: LD_INT 0
83086: PUSH
83087: LD_INT 1
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: IN
83094: NOT
83095: OR
83096: PUSH
83097: LD_VAR 0 2
83101: NOT
83102: OR
83103: PUSH
83104: LD_VAR 0 5
83108: PUSH
83109: LD_INT 0
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: LD_INT 2
83117: PUSH
83118: LD_INT 3
83120: PUSH
83121: LD_INT 4
83123: PUSH
83124: LD_INT 5
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: IN
83135: NOT
83136: OR
83137: PUSH
83138: LD_VAR 0 3
83142: PPUSH
83143: LD_VAR 0 4
83147: PPUSH
83148: CALL_OW 488
83152: NOT
83153: OR
83154: IFFALSE 83158
// exit ;
83156: GO 83894
// side := GetSide ( depot ) ;
83158: LD_ADDR_VAR 0 9
83162: PUSH
83163: LD_VAR 0 1
83167: PPUSH
83168: CALL_OW 255
83172: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83173: LD_VAR 0 9
83177: PPUSH
83178: LD_VAR 0 2
83182: PPUSH
83183: CALL 82651 0 2
83187: NOT
83188: IFFALSE 83192
// exit ;
83190: GO 83894
// pom := GetBase ( depot ) ;
83192: LD_ADDR_VAR 0 10
83196: PUSH
83197: LD_VAR 0 1
83201: PPUSH
83202: CALL_OW 274
83206: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83207: LD_ADDR_VAR 0 11
83211: PUSH
83212: LD_VAR 0 2
83216: PPUSH
83217: LD_VAR 0 1
83221: PPUSH
83222: CALL_OW 248
83226: PPUSH
83227: CALL_OW 450
83231: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83232: LD_VAR 0 10
83236: PPUSH
83237: LD_INT 1
83239: PPUSH
83240: CALL_OW 275
83244: PUSH
83245: LD_VAR 0 11
83249: PUSH
83250: LD_INT 1
83252: ARRAY
83253: GREATEREQUAL
83254: PUSH
83255: LD_VAR 0 10
83259: PPUSH
83260: LD_INT 2
83262: PPUSH
83263: CALL_OW 275
83267: PUSH
83268: LD_VAR 0 11
83272: PUSH
83273: LD_INT 2
83275: ARRAY
83276: GREATEREQUAL
83277: AND
83278: PUSH
83279: LD_VAR 0 10
83283: PPUSH
83284: LD_INT 3
83286: PPUSH
83287: CALL_OW 275
83291: PUSH
83292: LD_VAR 0 11
83296: PUSH
83297: LD_INT 3
83299: ARRAY
83300: GREATEREQUAL
83301: AND
83302: NOT
83303: IFFALSE 83307
// exit ;
83305: GO 83894
// if GetBType ( depot ) = b_depot then
83307: LD_VAR 0 1
83311: PPUSH
83312: CALL_OW 266
83316: PUSH
83317: LD_INT 0
83319: EQUAL
83320: IFFALSE 83332
// dist := 28 else
83322: LD_ADDR_VAR 0 14
83326: PUSH
83327: LD_INT 28
83329: ST_TO_ADDR
83330: GO 83340
// dist := 36 ;
83332: LD_ADDR_VAR 0 14
83336: PUSH
83337: LD_INT 36
83339: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83340: LD_VAR 0 1
83344: PPUSH
83345: LD_VAR 0 3
83349: PPUSH
83350: LD_VAR 0 4
83354: PPUSH
83355: CALL_OW 297
83359: PUSH
83360: LD_VAR 0 14
83364: GREATER
83365: IFFALSE 83369
// exit ;
83367: GO 83894
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83369: LD_ADDR_VAR 0 12
83373: PUSH
83374: LD_VAR 0 2
83378: PPUSH
83379: LD_VAR 0 3
83383: PPUSH
83384: LD_VAR 0 4
83388: PPUSH
83389: LD_VAR 0 5
83393: PPUSH
83394: LD_VAR 0 1
83398: PPUSH
83399: CALL_OW 248
83403: PPUSH
83404: LD_INT 0
83406: PPUSH
83407: CALL 83899 0 6
83411: ST_TO_ADDR
// if not hexes then
83412: LD_VAR 0 12
83416: NOT
83417: IFFALSE 83421
// exit ;
83419: GO 83894
// hex := GetHexInfo ( x , y ) ;
83421: LD_ADDR_VAR 0 15
83425: PUSH
83426: LD_VAR 0 3
83430: PPUSH
83431: LD_VAR 0 4
83435: PPUSH
83436: CALL_OW 546
83440: ST_TO_ADDR
// if hex [ 1 ] then
83441: LD_VAR 0 15
83445: PUSH
83446: LD_INT 1
83448: ARRAY
83449: IFFALSE 83453
// exit ;
83451: GO 83894
// height := hex [ 2 ] ;
83453: LD_ADDR_VAR 0 13
83457: PUSH
83458: LD_VAR 0 15
83462: PUSH
83463: LD_INT 2
83465: ARRAY
83466: ST_TO_ADDR
// for i = 1 to hexes do
83467: LD_ADDR_VAR 0 7
83471: PUSH
83472: DOUBLE
83473: LD_INT 1
83475: DEC
83476: ST_TO_ADDR
83477: LD_VAR 0 12
83481: PUSH
83482: FOR_TO
83483: IFFALSE 83813
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83485: LD_VAR 0 12
83489: PUSH
83490: LD_VAR 0 7
83494: ARRAY
83495: PUSH
83496: LD_INT 1
83498: ARRAY
83499: PPUSH
83500: LD_VAR 0 12
83504: PUSH
83505: LD_VAR 0 7
83509: ARRAY
83510: PUSH
83511: LD_INT 2
83513: ARRAY
83514: PPUSH
83515: CALL_OW 488
83519: NOT
83520: PUSH
83521: LD_VAR 0 12
83525: PUSH
83526: LD_VAR 0 7
83530: ARRAY
83531: PUSH
83532: LD_INT 1
83534: ARRAY
83535: PPUSH
83536: LD_VAR 0 12
83540: PUSH
83541: LD_VAR 0 7
83545: ARRAY
83546: PUSH
83547: LD_INT 2
83549: ARRAY
83550: PPUSH
83551: CALL_OW 428
83555: PUSH
83556: LD_INT 0
83558: GREATER
83559: OR
83560: PUSH
83561: LD_VAR 0 12
83565: PUSH
83566: LD_VAR 0 7
83570: ARRAY
83571: PUSH
83572: LD_INT 1
83574: ARRAY
83575: PPUSH
83576: LD_VAR 0 12
83580: PUSH
83581: LD_VAR 0 7
83585: ARRAY
83586: PUSH
83587: LD_INT 2
83589: ARRAY
83590: PPUSH
83591: CALL_OW 351
83595: OR
83596: IFFALSE 83602
// exit ;
83598: POP
83599: POP
83600: GO 83894
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83602: LD_ADDR_VAR 0 8
83606: PUSH
83607: LD_VAR 0 12
83611: PUSH
83612: LD_VAR 0 7
83616: ARRAY
83617: PUSH
83618: LD_INT 1
83620: ARRAY
83621: PPUSH
83622: LD_VAR 0 12
83626: PUSH
83627: LD_VAR 0 7
83631: ARRAY
83632: PUSH
83633: LD_INT 2
83635: ARRAY
83636: PPUSH
83637: CALL_OW 546
83641: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83642: LD_VAR 0 8
83646: PUSH
83647: LD_INT 1
83649: ARRAY
83650: PUSH
83651: LD_VAR 0 8
83655: PUSH
83656: LD_INT 2
83658: ARRAY
83659: PUSH
83660: LD_VAR 0 13
83664: PUSH
83665: LD_INT 2
83667: PLUS
83668: GREATER
83669: OR
83670: PUSH
83671: LD_VAR 0 8
83675: PUSH
83676: LD_INT 2
83678: ARRAY
83679: PUSH
83680: LD_VAR 0 13
83684: PUSH
83685: LD_INT 2
83687: MINUS
83688: LESS
83689: OR
83690: PUSH
83691: LD_VAR 0 8
83695: PUSH
83696: LD_INT 3
83698: ARRAY
83699: PUSH
83700: LD_INT 0
83702: PUSH
83703: LD_INT 8
83705: PUSH
83706: LD_INT 9
83708: PUSH
83709: LD_INT 10
83711: PUSH
83712: LD_INT 11
83714: PUSH
83715: LD_INT 12
83717: PUSH
83718: LD_INT 13
83720: PUSH
83721: LD_INT 16
83723: PUSH
83724: LD_INT 17
83726: PUSH
83727: LD_INT 18
83729: PUSH
83730: LD_INT 19
83732: PUSH
83733: LD_INT 20
83735: PUSH
83736: LD_INT 21
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: IN
83754: NOT
83755: OR
83756: PUSH
83757: LD_VAR 0 8
83761: PUSH
83762: LD_INT 5
83764: ARRAY
83765: NOT
83766: OR
83767: PUSH
83768: LD_VAR 0 8
83772: PUSH
83773: LD_INT 6
83775: ARRAY
83776: PUSH
83777: LD_INT 1
83779: PUSH
83780: LD_INT 2
83782: PUSH
83783: LD_INT 7
83785: PUSH
83786: LD_INT 9
83788: PUSH
83789: LD_INT 10
83791: PUSH
83792: LD_INT 11
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: IN
83803: NOT
83804: OR
83805: IFFALSE 83811
// exit ;
83807: POP
83808: POP
83809: GO 83894
// end ;
83811: GO 83482
83813: POP
83814: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83815: LD_VAR 0 9
83819: PPUSH
83820: LD_VAR 0 3
83824: PPUSH
83825: LD_VAR 0 4
83829: PPUSH
83830: LD_INT 20
83832: PPUSH
83833: CALL 75817 0 4
83837: PUSH
83838: LD_INT 4
83840: ARRAY
83841: IFFALSE 83845
// exit ;
83843: GO 83894
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83845: LD_VAR 0 2
83849: PUSH
83850: LD_INT 29
83852: PUSH
83853: LD_INT 30
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: IN
83860: PUSH
83861: LD_VAR 0 3
83865: PPUSH
83866: LD_VAR 0 4
83870: PPUSH
83871: LD_VAR 0 9
83875: PPUSH
83876: CALL_OW 440
83880: NOT
83881: AND
83882: IFFALSE 83886
// exit ;
83884: GO 83894
// result := true ;
83886: LD_ADDR_VAR 0 6
83890: PUSH
83891: LD_INT 1
83893: ST_TO_ADDR
// end ;
83894: LD_VAR 0 6
83898: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83899: LD_INT 0
83901: PPUSH
83902: PPUSH
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
83907: PPUSH
83908: PPUSH
83909: PPUSH
83910: PPUSH
83911: PPUSH
83912: PPUSH
83913: PPUSH
83914: PPUSH
83915: PPUSH
83916: PPUSH
83917: PPUSH
83918: PPUSH
83919: PPUSH
83920: PPUSH
83921: PPUSH
83922: PPUSH
83923: PPUSH
83924: PPUSH
83925: PPUSH
83926: PPUSH
83927: PPUSH
83928: PPUSH
83929: PPUSH
83930: PPUSH
83931: PPUSH
83932: PPUSH
83933: PPUSH
83934: PPUSH
83935: PPUSH
83936: PPUSH
83937: PPUSH
83938: PPUSH
83939: PPUSH
83940: PPUSH
83941: PPUSH
83942: PPUSH
83943: PPUSH
83944: PPUSH
83945: PPUSH
83946: PPUSH
83947: PPUSH
83948: PPUSH
83949: PPUSH
83950: PPUSH
83951: PPUSH
83952: PPUSH
83953: PPUSH
83954: PPUSH
83955: PPUSH
83956: PPUSH
83957: PPUSH
83958: PPUSH
// result = [ ] ;
83959: LD_ADDR_VAR 0 7
83963: PUSH
83964: EMPTY
83965: ST_TO_ADDR
// temp_list = [ ] ;
83966: LD_ADDR_VAR 0 9
83970: PUSH
83971: EMPTY
83972: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
83973: LD_VAR 0 4
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: LD_INT 1
83983: PUSH
83984: LD_INT 2
83986: PUSH
83987: LD_INT 3
83989: PUSH
83990: LD_INT 4
83992: PUSH
83993: LD_INT 5
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: IN
84004: NOT
84005: PUSH
84006: LD_VAR 0 1
84010: PUSH
84011: LD_INT 0
84013: PUSH
84014: LD_INT 1
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: IN
84021: PUSH
84022: LD_VAR 0 5
84026: PUSH
84027: LD_INT 1
84029: PUSH
84030: LD_INT 2
84032: PUSH
84033: LD_INT 3
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: LIST
84040: IN
84041: NOT
84042: AND
84043: OR
84044: IFFALSE 84048
// exit ;
84046: GO 102439
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84048: LD_VAR 0 1
84052: PUSH
84053: LD_INT 6
84055: PUSH
84056: LD_INT 7
84058: PUSH
84059: LD_INT 8
84061: PUSH
84062: LD_INT 13
84064: PUSH
84065: LD_INT 12
84067: PUSH
84068: LD_INT 15
84070: PUSH
84071: LD_INT 11
84073: PUSH
84074: LD_INT 14
84076: PUSH
84077: LD_INT 10
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: IN
84091: IFFALSE 84101
// btype = b_lab ;
84093: LD_ADDR_VAR 0 1
84097: PUSH
84098: LD_INT 6
84100: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84101: LD_VAR 0 6
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: LD_INT 2
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: LIST
84119: IN
84120: NOT
84121: PUSH
84122: LD_VAR 0 1
84126: PUSH
84127: LD_INT 0
84129: PUSH
84130: LD_INT 1
84132: PUSH
84133: LD_INT 2
84135: PUSH
84136: LD_INT 3
84138: PUSH
84139: LD_INT 6
84141: PUSH
84142: LD_INT 36
84144: PUSH
84145: LD_INT 4
84147: PUSH
84148: LD_INT 5
84150: PUSH
84151: LD_INT 31
84153: PUSH
84154: LD_INT 32
84156: PUSH
84157: LD_INT 33
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: IN
84173: NOT
84174: PUSH
84175: LD_VAR 0 6
84179: PUSH
84180: LD_INT 1
84182: EQUAL
84183: AND
84184: OR
84185: PUSH
84186: LD_VAR 0 1
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: LD_INT 3
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: IN
84201: NOT
84202: PUSH
84203: LD_VAR 0 6
84207: PUSH
84208: LD_INT 2
84210: EQUAL
84211: AND
84212: OR
84213: IFFALSE 84223
// mode = 0 ;
84215: LD_ADDR_VAR 0 6
84219: PUSH
84220: LD_INT 0
84222: ST_TO_ADDR
// case mode of 0 :
84223: LD_VAR 0 6
84227: PUSH
84228: LD_INT 0
84230: DOUBLE
84231: EQUAL
84232: IFTRUE 84236
84234: GO 95689
84236: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84237: LD_ADDR_VAR 0 11
84241: PUSH
84242: LD_INT 0
84244: PUSH
84245: LD_INT 0
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 0
84254: PUSH
84255: LD_INT 1
84257: NEG
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: LD_INT 1
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 0
84285: PUSH
84286: LD_INT 1
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 1
84295: NEG
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 1
84306: NEG
84307: PUSH
84308: LD_INT 1
84310: NEG
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 2
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: LD_INT 2
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 1
84344: NEG
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: LD_INT 2
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 0
84362: PUSH
84363: LD_INT 2
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 1
84372: NEG
84373: PUSH
84374: LD_INT 1
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 1
84383: PUSH
84384: LD_INT 3
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 3
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: LD_INT 2
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84430: LD_ADDR_VAR 0 12
84434: PUSH
84435: LD_INT 0
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 0
84447: PUSH
84448: LD_INT 1
84450: NEG
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 1
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 0
84478: PUSH
84479: LD_INT 1
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PUSH
84486: LD_INT 1
84488: NEG
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 1
84499: NEG
84500: PUSH
84501: LD_INT 1
84503: NEG
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 1
84511: PUSH
84512: LD_INT 1
84514: NEG
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 2
84522: PUSH
84523: LD_INT 0
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 2
84532: PUSH
84533: LD_INT 1
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 1
84542: NEG
84543: PUSH
84544: LD_INT 1
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 2
84553: NEG
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 2
84576: NEG
84577: PUSH
84578: LD_INT 1
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 3
84587: NEG
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 3
84598: NEG
84599: PUSH
84600: LD_INT 1
84602: NEG
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84626: LD_ADDR_VAR 0 13
84630: PUSH
84631: LD_INT 0
84633: PUSH
84634: LD_INT 0
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 0
84643: PUSH
84644: LD_INT 1
84646: NEG
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: LD_INT 0
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: PUSH
84662: LD_INT 1
84664: PUSH
84665: LD_INT 1
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 0
84674: PUSH
84675: LD_INT 1
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 1
84684: NEG
84685: PUSH
84686: LD_INT 0
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 1
84695: NEG
84696: PUSH
84697: LD_INT 1
84699: NEG
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 1
84707: NEG
84708: PUSH
84709: LD_INT 2
84711: NEG
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 2
84719: PUSH
84720: LD_INT 1
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PUSH
84727: LD_INT 2
84729: PUSH
84730: LD_INT 2
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 1
84739: PUSH
84740: LD_INT 2
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: PUSH
84747: LD_INT 2
84749: NEG
84750: PUSH
84751: LD_INT 1
84753: NEG
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 2
84761: NEG
84762: PUSH
84763: LD_INT 2
84765: NEG
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 2
84773: NEG
84774: PUSH
84775: LD_INT 3
84777: NEG
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 3
84785: NEG
84786: PUSH
84787: LD_INT 2
84789: NEG
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 3
84797: NEG
84798: PUSH
84799: LD_INT 3
84801: NEG
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84825: LD_ADDR_VAR 0 14
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: LD_INT 0
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 0
84842: PUSH
84843: LD_INT 1
84845: NEG
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 1
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 1
84863: PUSH
84864: LD_INT 1
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 0
84873: PUSH
84874: LD_INT 1
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 1
84883: NEG
84884: PUSH
84885: LD_INT 0
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: LD_INT 1
84898: NEG
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 1
84906: NEG
84907: PUSH
84908: LD_INT 2
84910: NEG
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: LD_INT 2
84921: NEG
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 1
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: LD_INT 2
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 0
84950: PUSH
84951: LD_INT 2
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 1
84960: NEG
84961: PUSH
84962: LD_INT 1
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 1
84971: NEG
84972: PUSH
84973: LD_INT 3
84975: NEG
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 0
84983: PUSH
84984: LD_INT 3
84986: NEG
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: LD_INT 2
84997: NEG
84998: PUSH
84999: EMPTY
85000: LIST
85001: LIST
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85021: LD_ADDR_VAR 0 15
85025: PUSH
85026: LD_INT 0
85028: PUSH
85029: LD_INT 0
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 0
85038: PUSH
85039: LD_INT 1
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 1
85049: PUSH
85050: LD_INT 0
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 1
85059: PUSH
85060: LD_INT 1
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 1
85079: NEG
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 1
85090: NEG
85091: PUSH
85092: LD_INT 1
85094: NEG
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 1
85102: PUSH
85103: LD_INT 1
85105: NEG
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 2
85113: PUSH
85114: LD_INT 0
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 2
85123: PUSH
85124: LD_INT 1
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: LD_INT 1
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 2
85144: NEG
85145: PUSH
85146: LD_INT 0
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 2
85155: NEG
85156: PUSH
85157: LD_INT 1
85159: NEG
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 2
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 3
85178: PUSH
85179: LD_INT 0
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 3
85188: PUSH
85189: LD_INT 1
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85214: LD_ADDR_VAR 0 16
85218: PUSH
85219: LD_INT 0
85221: PUSH
85222: LD_INT 0
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 0
85231: PUSH
85232: LD_INT 1
85234: NEG
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 1
85242: PUSH
85243: LD_INT 0
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 1
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: LD_INT 0
85262: PUSH
85263: LD_INT 1
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 1
85272: NEG
85273: PUSH
85274: LD_INT 0
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: LD_INT 1
85283: NEG
85284: PUSH
85285: LD_INT 1
85287: NEG
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: LD_INT 2
85299: NEG
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 2
85307: PUSH
85308: LD_INT 1
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 2
85317: PUSH
85318: LD_INT 2
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 1
85327: PUSH
85328: LD_INT 2
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: PUSH
85335: LD_INT 2
85337: NEG
85338: PUSH
85339: LD_INT 1
85341: NEG
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 2
85349: NEG
85350: PUSH
85351: LD_INT 2
85353: NEG
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: PUSH
85359: LD_INT 3
85361: PUSH
85362: LD_INT 2
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 3
85371: PUSH
85372: LD_INT 3
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 2
85381: PUSH
85382: LD_INT 3
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85407: LD_ADDR_VAR 0 17
85411: PUSH
85412: LD_INT 0
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: LD_INT 1
85427: NEG
85428: PUSH
85429: EMPTY
85430: LIST
85431: LIST
85432: PUSH
85433: LD_INT 1
85435: PUSH
85436: LD_INT 0
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: LD_INT 1
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: LD_INT 1
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 1
85465: NEG
85466: PUSH
85467: LD_INT 0
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 1
85476: NEG
85477: PUSH
85478: LD_INT 1
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: LD_INT 2
85492: NEG
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: LD_INT 0
85500: PUSH
85501: LD_INT 2
85503: NEG
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 1
85511: PUSH
85512: LD_INT 1
85514: NEG
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 2
85522: PUSH
85523: LD_INT 0
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 2
85532: PUSH
85533: LD_INT 1
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 2
85542: PUSH
85543: LD_INT 2
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 1
85552: PUSH
85553: LD_INT 2
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: LD_INT 2
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 1
85572: NEG
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 2
85583: NEG
85584: PUSH
85585: LD_INT 0
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 2
85594: NEG
85595: PUSH
85596: LD_INT 1
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 2
85606: NEG
85607: PUSH
85608: LD_INT 2
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85637: LD_ADDR_VAR 0 18
85641: PUSH
85642: LD_INT 0
85644: PUSH
85645: LD_INT 0
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: LD_INT 1
85657: NEG
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: LD_INT 1
85665: PUSH
85666: LD_INT 0
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 1
85675: PUSH
85676: LD_INT 1
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: LD_INT 1
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: NEG
85696: PUSH
85697: LD_INT 0
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: PUSH
85704: LD_INT 1
85706: NEG
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 1
85718: NEG
85719: PUSH
85720: LD_INT 2
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 0
85730: PUSH
85731: LD_INT 2
85733: NEG
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 1
85741: PUSH
85742: LD_INT 1
85744: NEG
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 2
85752: PUSH
85753: LD_INT 0
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: LD_INT 1
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 2
85772: PUSH
85773: LD_INT 2
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 1
85782: PUSH
85783: LD_INT 2
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: LD_INT 2
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: NEG
85803: PUSH
85804: LD_INT 1
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 2
85813: NEG
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 2
85824: NEG
85825: PUSH
85826: LD_INT 1
85828: NEG
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: PUSH
85834: LD_INT 2
85836: NEG
85837: PUSH
85838: LD_INT 2
85840: NEG
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85867: LD_ADDR_VAR 0 19
85871: PUSH
85872: LD_INT 0
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 0
85884: PUSH
85885: LD_INT 1
85887: NEG
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: LD_INT 1
85895: PUSH
85896: LD_INT 0
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: PUSH
85903: LD_INT 1
85905: PUSH
85906: LD_INT 1
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: LD_INT 1
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: LD_INT 0
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 1
85936: NEG
85937: PUSH
85938: LD_INT 1
85940: NEG
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: LD_INT 1
85948: NEG
85949: PUSH
85950: LD_INT 2
85952: NEG
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: LD_INT 2
85963: NEG
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: PUSH
85969: LD_INT 1
85971: PUSH
85972: LD_INT 1
85974: NEG
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: PUSH
85980: LD_INT 2
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 2
85992: PUSH
85993: LD_INT 1
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: PUSH
86000: LD_INT 2
86002: PUSH
86003: LD_INT 2
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: LD_INT 2
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 0
86022: PUSH
86023: LD_INT 2
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: PUSH
86034: LD_INT 1
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 2
86043: NEG
86044: PUSH
86045: LD_INT 0
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 2
86054: NEG
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 2
86066: NEG
86067: PUSH
86068: LD_INT 2
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86097: LD_ADDR_VAR 0 20
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: LD_INT 0
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 0
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 0
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 0
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: NEG
86156: PUSH
86157: LD_INT 0
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 1
86166: NEG
86167: PUSH
86168: LD_INT 1
86170: NEG
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: LD_INT 2
86182: NEG
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 0
86190: PUSH
86191: LD_INT 2
86193: NEG
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 1
86201: PUSH
86202: LD_INT 1
86204: NEG
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: LD_INT 2
86212: PUSH
86213: LD_INT 0
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: LD_INT 2
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: PUSH
86230: LD_INT 2
86232: PUSH
86233: LD_INT 2
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 1
86242: PUSH
86243: LD_INT 2
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: LD_INT 2
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: LD_INT 1
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 2
86273: NEG
86274: PUSH
86275: LD_INT 0
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 2
86284: NEG
86285: PUSH
86286: LD_INT 1
86288: NEG
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: PUSH
86294: LD_INT 2
86296: NEG
86297: PUSH
86298: LD_INT 2
86300: NEG
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86327: LD_ADDR_VAR 0 21
86331: PUSH
86332: LD_INT 0
86334: PUSH
86335: LD_INT 0
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: LD_INT 1
86347: NEG
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: PUSH
86356: LD_INT 0
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 1
86365: PUSH
86366: LD_INT 1
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 0
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 1
86385: NEG
86386: PUSH
86387: LD_INT 0
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 1
86396: NEG
86397: PUSH
86398: LD_INT 1
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 2
86412: NEG
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 0
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 1
86431: PUSH
86432: LD_INT 1
86434: NEG
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 2
86442: PUSH
86443: LD_INT 0
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 2
86452: PUSH
86453: LD_INT 1
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 2
86462: PUSH
86463: LD_INT 2
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 1
86472: PUSH
86473: LD_INT 2
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: LD_INT 2
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 1
86492: NEG
86493: PUSH
86494: LD_INT 1
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 2
86503: NEG
86504: PUSH
86505: LD_INT 0
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 2
86514: NEG
86515: PUSH
86516: LD_INT 1
86518: NEG
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 2
86526: NEG
86527: PUSH
86528: LD_INT 2
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86557: LD_ADDR_VAR 0 22
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: LD_INT 0
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: PUSH
86572: LD_INT 0
86574: PUSH
86575: LD_INT 1
86577: NEG
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: LD_INT 0
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: LD_INT 1
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: LD_INT 0
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 1
86615: NEG
86616: PUSH
86617: LD_INT 0
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: LD_INT 1
86630: NEG
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: LD_INT 2
86642: NEG
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: LD_INT 2
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 1
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 2
86672: PUSH
86673: LD_INT 0
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 2
86682: PUSH
86683: LD_INT 1
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: LD_INT 2
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PUSH
86700: LD_INT 1
86702: PUSH
86703: LD_INT 2
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: LD_INT 2
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: LD_INT 1
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 2
86733: NEG
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 2
86744: NEG
86745: PUSH
86746: LD_INT 1
86748: NEG
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: NEG
86757: PUSH
86758: LD_INT 2
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86787: LD_ADDR_VAR 0 23
86791: PUSH
86792: LD_INT 0
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 1
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 1
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 0
86835: PUSH
86836: LD_INT 1
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 1
86845: NEG
86846: PUSH
86847: LD_INT 0
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: PUSH
86854: LD_INT 1
86856: NEG
86857: PUSH
86858: LD_INT 1
86860: NEG
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: NEG
86869: PUSH
86870: LD_INT 2
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 0
86880: PUSH
86881: LD_INT 2
86883: NEG
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: PUSH
86889: LD_INT 1
86891: PUSH
86892: LD_INT 1
86894: NEG
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 2
86902: PUSH
86903: LD_INT 0
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 2
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 2
86922: PUSH
86923: LD_INT 2
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 1
86932: PUSH
86933: LD_INT 2
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: LD_INT 2
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 1
86952: NEG
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 2
86963: NEG
86964: PUSH
86965: LD_INT 0
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: LD_INT 2
86974: NEG
86975: PUSH
86976: LD_INT 1
86978: NEG
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 2
86986: NEG
86987: PUSH
86988: LD_INT 2
86990: NEG
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 2
86998: NEG
86999: PUSH
87000: LD_INT 3
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 1
87010: NEG
87011: PUSH
87012: LD_INT 3
87014: NEG
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 1
87022: PUSH
87023: LD_INT 2
87025: NEG
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 2
87033: PUSH
87034: LD_INT 1
87036: NEG
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87067: LD_ADDR_VAR 0 24
87071: PUSH
87072: LD_INT 0
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 0
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 1
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 1
87105: PUSH
87106: LD_INT 1
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 1
87125: NEG
87126: PUSH
87127: LD_INT 0
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 1
87136: NEG
87137: PUSH
87138: LD_INT 1
87140: NEG
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 1
87148: NEG
87149: PUSH
87150: LD_INT 2
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: LD_INT 2
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 1
87171: PUSH
87172: LD_INT 1
87174: NEG
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 2
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 2
87192: PUSH
87193: LD_INT 1
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 2
87202: PUSH
87203: LD_INT 2
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 1
87212: PUSH
87213: LD_INT 2
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 0
87222: PUSH
87223: LD_INT 2
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: NEG
87233: PUSH
87234: LD_INT 1
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 2
87243: NEG
87244: PUSH
87245: LD_INT 0
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 2
87254: NEG
87255: PUSH
87256: LD_INT 1
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: NEG
87267: PUSH
87268: LD_INT 2
87270: NEG
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 1
87278: PUSH
87279: LD_INT 2
87281: NEG
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 2
87289: PUSH
87290: LD_INT 1
87292: NEG
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 3
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 3
87310: PUSH
87311: LD_INT 2
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87343: LD_ADDR_VAR 0 25
87347: PUSH
87348: LD_INT 0
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 0
87360: PUSH
87361: LD_INT 1
87363: NEG
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 1
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: LD_INT 1
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 0
87391: PUSH
87392: LD_INT 1
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 1
87401: NEG
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 1
87412: NEG
87413: PUSH
87414: LD_INT 1
87416: NEG
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 1
87424: NEG
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: LD_INT 2
87439: NEG
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 1
87447: PUSH
87448: LD_INT 1
87450: NEG
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 2
87458: PUSH
87459: LD_INT 0
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 2
87468: PUSH
87469: LD_INT 1
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 2
87478: PUSH
87479: LD_INT 2
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 1
87488: PUSH
87489: LD_INT 2
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: LD_INT 2
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 1
87508: NEG
87509: PUSH
87510: LD_INT 1
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 2
87519: NEG
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 2
87530: NEG
87531: PUSH
87532: LD_INT 1
87534: NEG
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 2
87542: NEG
87543: PUSH
87544: LD_INT 2
87546: NEG
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 3
87554: PUSH
87555: LD_INT 1
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 3
87564: PUSH
87565: LD_INT 2
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: LD_INT 3
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: LD_INT 3
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87617: LD_ADDR_VAR 0 26
87621: PUSH
87622: LD_INT 0
87624: PUSH
87625: LD_INT 0
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 0
87634: PUSH
87635: LD_INT 1
87637: NEG
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: LD_INT 0
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 1
87655: PUSH
87656: LD_INT 1
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 0
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: EMPTY
87670: LIST
87671: LIST
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: LD_INT 0
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: LD_INT 1
87690: NEG
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 1
87698: NEG
87699: PUSH
87700: LD_INT 2
87702: NEG
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 0
87710: PUSH
87711: LD_INT 2
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: LD_INT 1
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 2
87732: PUSH
87733: LD_INT 0
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 2
87742: PUSH
87743: LD_INT 1
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 2
87752: PUSH
87753: LD_INT 2
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 1
87762: PUSH
87763: LD_INT 2
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: LD_INT 2
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: NEG
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 2
87793: NEG
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: NEG
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 2
87816: NEG
87817: PUSH
87818: LD_INT 2
87820: NEG
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: LD_INT 2
87828: PUSH
87829: LD_INT 3
87831: PUSH
87832: EMPTY
87833: LIST
87834: LIST
87835: PUSH
87836: LD_INT 1
87838: PUSH
87839: LD_INT 3
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 1
87848: NEG
87849: PUSH
87850: LD_INT 2
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 2
87859: NEG
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87893: LD_ADDR_VAR 0 27
87897: PUSH
87898: LD_INT 0
87900: PUSH
87901: LD_INT 0
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: LD_INT 1
87913: NEG
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 1
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 0
87941: PUSH
87942: LD_INT 1
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 1
87951: NEG
87952: PUSH
87953: LD_INT 0
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 1
87962: NEG
87963: PUSH
87964: LD_INT 1
87966: NEG
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 1
87974: NEG
87975: PUSH
87976: LD_INT 2
87978: NEG
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 2
87989: NEG
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: LD_INT 1
88000: NEG
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: PUSH
88006: LD_INT 2
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: PUSH
88016: LD_INT 2
88018: PUSH
88019: LD_INT 1
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: LD_INT 2
88028: PUSH
88029: LD_INT 2
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 1
88038: PUSH
88039: LD_INT 2
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 0
88048: PUSH
88049: LD_INT 2
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: LD_INT 1
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 2
88069: NEG
88070: PUSH
88071: LD_INT 0
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 2
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 2
88092: NEG
88093: PUSH
88094: LD_INT 2
88096: NEG
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 1
88104: NEG
88105: PUSH
88106: LD_INT 2
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 2
88115: NEG
88116: PUSH
88117: LD_INT 1
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 3
88126: NEG
88127: PUSH
88128: LD_INT 1
88130: NEG
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 3
88138: NEG
88139: PUSH
88140: LD_INT 2
88142: NEG
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88173: LD_ADDR_VAR 0 28
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 0
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 0
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: NEG
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: EMPTY
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: LD_INT 2
88258: NEG
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 0
88266: PUSH
88267: LD_INT 2
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 2
88288: PUSH
88289: LD_INT 0
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 2
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 2
88308: PUSH
88309: LD_INT 2
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: LD_INT 2
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 0
88328: PUSH
88329: LD_INT 2
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 1
88338: NEG
88339: PUSH
88340: LD_INT 1
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 2
88349: NEG
88350: PUSH
88351: LD_INT 0
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 2
88360: NEG
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 2
88372: NEG
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 2
88384: NEG
88385: PUSH
88386: LD_INT 3
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 1
88396: NEG
88397: PUSH
88398: LD_INT 3
88400: NEG
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PUSH
88406: LD_INT 3
88408: NEG
88409: PUSH
88410: LD_INT 1
88412: NEG
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 3
88420: NEG
88421: PUSH
88422: LD_INT 2
88424: NEG
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88455: LD_ADDR_VAR 0 29
88459: PUSH
88460: LD_INT 0
88462: PUSH
88463: LD_INT 0
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 1
88483: PUSH
88484: LD_INT 0
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: LD_INT 1
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: PUSH
88501: LD_INT 0
88503: PUSH
88504: LD_INT 1
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 1
88513: NEG
88514: PUSH
88515: LD_INT 0
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: LD_INT 1
88528: NEG
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 1
88536: NEG
88537: PUSH
88538: LD_INT 2
88540: NEG
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 0
88548: PUSH
88549: LD_INT 2
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 1
88559: PUSH
88560: LD_INT 1
88562: NEG
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 2
88570: PUSH
88571: LD_INT 0
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 2
88580: PUSH
88581: LD_INT 1
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 1
88590: PUSH
88591: LD_INT 2
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 0
88600: PUSH
88601: LD_INT 2
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 1
88610: NEG
88611: PUSH
88612: LD_INT 1
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 2
88621: NEG
88622: PUSH
88623: LD_INT 1
88625: NEG
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 2
88633: NEG
88634: PUSH
88635: LD_INT 2
88637: NEG
88638: PUSH
88639: EMPTY
88640: LIST
88641: LIST
88642: PUSH
88643: LD_INT 2
88645: NEG
88646: PUSH
88647: LD_INT 3
88649: NEG
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: PUSH
88655: LD_INT 2
88657: PUSH
88658: LD_INT 1
88660: NEG
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 3
88668: PUSH
88669: LD_INT 1
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: LD_INT 3
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 1
88688: NEG
88689: PUSH
88690: LD_INT 2
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 3
88699: NEG
88700: PUSH
88701: LD_INT 2
88703: NEG
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88734: LD_ADDR_VAR 0 30
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 0
88751: PUSH
88752: LD_INT 1
88754: NEG
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 1
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 1
88772: PUSH
88773: LD_INT 1
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 0
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 1
88792: NEG
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 1
88803: NEG
88804: PUSH
88805: LD_INT 1
88807: NEG
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: LD_INT 2
88819: NEG
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 0
88827: PUSH
88828: LD_INT 2
88830: NEG
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 1
88838: PUSH
88839: LD_INT 1
88841: NEG
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: PUSH
88847: LD_INT 2
88849: PUSH
88850: LD_INT 0
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 2
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 2
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: EMPTY
88874: LIST
88875: LIST
88876: PUSH
88877: LD_INT 1
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: NEG
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 2
88900: NEG
88901: PUSH
88902: LD_INT 0
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 2
88911: NEG
88912: PUSH
88913: LD_INT 1
88915: NEG
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 1
88923: NEG
88924: PUSH
88925: LD_INT 3
88927: NEG
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PUSH
88933: LD_INT 1
88935: PUSH
88936: LD_INT 2
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 3
88946: PUSH
88947: LD_INT 2
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 2
88956: PUSH
88957: LD_INT 3
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 2
88966: NEG
88967: PUSH
88968: LD_INT 1
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: LD_INT 3
88977: NEG
88978: PUSH
88979: LD_INT 1
88981: NEG
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89012: LD_ADDR_VAR 0 31
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: LD_INT 0
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 0
89029: PUSH
89030: LD_INT 1
89032: NEG
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 1
89040: PUSH
89041: LD_INT 0
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 1
89050: PUSH
89051: LD_INT 1
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: LD_INT 1
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 1
89070: NEG
89071: PUSH
89072: LD_INT 0
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 1
89081: NEG
89082: PUSH
89083: LD_INT 1
89085: NEG
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 1
89093: NEG
89094: PUSH
89095: LD_INT 2
89097: NEG
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: LD_INT 1
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: PUSH
89114: LD_INT 2
89116: PUSH
89117: LD_INT 0
89119: PUSH
89120: EMPTY
89121: LIST
89122: LIST
89123: PUSH
89124: LD_INT 2
89126: PUSH
89127: LD_INT 1
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 2
89136: PUSH
89137: LD_INT 2
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 1
89146: PUSH
89147: LD_INT 2
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: LD_INT 2
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: LD_INT 1
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 2
89177: NEG
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 2
89189: NEG
89190: PUSH
89191: LD_INT 2
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 2
89201: NEG
89202: PUSH
89203: LD_INT 3
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 2
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 3
89224: PUSH
89225: LD_INT 1
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 3
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: LD_INT 2
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 3
89255: NEG
89256: PUSH
89257: LD_INT 2
89259: NEG
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89290: LD_ADDR_VAR 0 32
89294: PUSH
89295: LD_INT 0
89297: PUSH
89298: LD_INT 0
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 0
89307: PUSH
89308: LD_INT 1
89310: NEG
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 1
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 1
89328: PUSH
89329: LD_INT 1
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 0
89338: PUSH
89339: LD_INT 1
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: NEG
89349: PUSH
89350: LD_INT 0
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 1
89359: NEG
89360: PUSH
89361: LD_INT 1
89363: NEG
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 1
89371: NEG
89372: PUSH
89373: LD_INT 2
89375: NEG
89376: PUSH
89377: EMPTY
89378: LIST
89379: LIST
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: LD_INT 2
89386: NEG
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: LD_INT 1
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 2
89405: PUSH
89406: LD_INT 1
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 2
89415: PUSH
89416: LD_INT 2
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 1
89425: PUSH
89426: LD_INT 2
89428: PUSH
89429: EMPTY
89430: LIST
89431: LIST
89432: PUSH
89433: LD_INT 0
89435: PUSH
89436: LD_INT 2
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 1
89445: NEG
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 2
89456: NEG
89457: PUSH
89458: LD_INT 0
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 2
89467: NEG
89468: PUSH
89469: LD_INT 1
89471: NEG
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 1
89479: NEG
89480: PUSH
89481: LD_INT 3
89483: NEG
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 1
89491: PUSH
89492: LD_INT 2
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 3
89502: PUSH
89503: LD_INT 2
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 2
89512: PUSH
89513: LD_INT 3
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 2
89522: NEG
89523: PUSH
89524: LD_INT 1
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 3
89533: NEG
89534: PUSH
89535: LD_INT 1
89537: NEG
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89568: LD_ADDR_VAR 0 33
89572: PUSH
89573: LD_INT 0
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: LD_INT 1
89588: NEG
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: LD_INT 0
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: LD_INT 1
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: LD_INT 1
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: LD_INT 0
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: NEG
89638: PUSH
89639: LD_INT 1
89641: NEG
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 1
89649: NEG
89650: PUSH
89651: LD_INT 2
89653: NEG
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: LD_INT 1
89664: NEG
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 2
89672: PUSH
89673: LD_INT 0
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 2
89682: PUSH
89683: LD_INT 1
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: PUSH
89690: LD_INT 1
89692: PUSH
89693: LD_INT 2
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 0
89702: PUSH
89703: LD_INT 2
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 1
89712: NEG
89713: PUSH
89714: LD_INT 1
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 2
89723: NEG
89724: PUSH
89725: LD_INT 0
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 2
89734: NEG
89735: PUSH
89736: LD_INT 1
89738: NEG
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 2
89746: NEG
89747: PUSH
89748: LD_INT 2
89750: NEG
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 2
89758: NEG
89759: PUSH
89760: LD_INT 3
89762: NEG
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 2
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 3
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 1
89791: PUSH
89792: LD_INT 3
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 1
89801: NEG
89802: PUSH
89803: LD_INT 2
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 3
89812: NEG
89813: PUSH
89814: LD_INT 2
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89847: LD_ADDR_VAR 0 34
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: LD_INT 0
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 0
89864: PUSH
89865: LD_INT 1
89867: NEG
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: PUSH
89873: LD_INT 1
89875: PUSH
89876: LD_INT 0
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 1
89885: PUSH
89886: LD_INT 1
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: LD_INT 1
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 1
89905: NEG
89906: PUSH
89907: LD_INT 0
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 1
89916: NEG
89917: PUSH
89918: LD_INT 1
89920: NEG
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 1
89928: NEG
89929: PUSH
89930: LD_INT 2
89932: NEG
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: LD_INT 0
89940: PUSH
89941: LD_INT 2
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 1
89951: PUSH
89952: LD_INT 1
89954: NEG
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: LD_INT 2
89962: PUSH
89963: LD_INT 1
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 2
89972: PUSH
89973: LD_INT 2
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 1
89982: PUSH
89983: LD_INT 2
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 1
89992: NEG
89993: PUSH
89994: LD_INT 1
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: LD_INT 2
90003: NEG
90004: PUSH
90005: LD_INT 0
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 2
90014: NEG
90015: PUSH
90016: LD_INT 1
90018: NEG
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 2
90026: NEG
90027: PUSH
90028: LD_INT 2
90030: NEG
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 1
90038: NEG
90039: PUSH
90040: LD_INT 3
90042: NEG
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 1
90050: PUSH
90051: LD_INT 2
90053: NEG
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 3
90061: PUSH
90062: LD_INT 2
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 2
90071: PUSH
90072: LD_INT 3
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: NEG
90082: PUSH
90083: LD_INT 1
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: LD_INT 3
90092: NEG
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90127: LD_ADDR_VAR 0 35
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: LD_INT 0
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 0
90144: PUSH
90145: LD_INT 1
90147: NEG
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 1
90165: PUSH
90166: LD_INT 1
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 0
90175: PUSH
90176: LD_INT 1
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: LD_INT 1
90185: NEG
90186: PUSH
90187: LD_INT 0
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 1
90196: NEG
90197: PUSH
90198: LD_INT 1
90200: NEG
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 2
90208: PUSH
90209: LD_INT 1
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 2
90218: NEG
90219: PUSH
90220: LD_INT 1
90222: NEG
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90239: LD_ADDR_VAR 0 36
90243: PUSH
90244: LD_INT 0
90246: PUSH
90247: LD_INT 0
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 0
90256: PUSH
90257: LD_INT 1
90259: NEG
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 1
90267: PUSH
90268: LD_INT 0
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 1
90277: PUSH
90278: LD_INT 1
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: LD_INT 1
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 1
90297: NEG
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 1
90308: NEG
90309: PUSH
90310: LD_INT 1
90312: NEG
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 1
90320: NEG
90321: PUSH
90322: LD_INT 2
90324: NEG
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 1
90332: PUSH
90333: LD_INT 2
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90351: LD_ADDR_VAR 0 37
90355: PUSH
90356: LD_INT 0
90358: PUSH
90359: LD_INT 0
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 0
90368: PUSH
90369: LD_INT 1
90371: NEG
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 1
90379: PUSH
90380: LD_INT 0
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 1
90389: PUSH
90390: LD_INT 1
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 0
90399: PUSH
90400: LD_INT 1
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 1
90420: NEG
90421: PUSH
90422: LD_INT 1
90424: NEG
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 1
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 1
90443: NEG
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90463: LD_ADDR_VAR 0 38
90467: PUSH
90468: LD_INT 0
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 0
90480: PUSH
90481: LD_INT 1
90483: NEG
90484: PUSH
90485: EMPTY
90486: LIST
90487: LIST
90488: PUSH
90489: LD_INT 1
90491: PUSH
90492: LD_INT 0
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: PUSH
90499: LD_INT 1
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 0
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 1
90521: NEG
90522: PUSH
90523: LD_INT 0
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: LD_INT 1
90532: NEG
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: LD_INT 1
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 2
90554: NEG
90555: PUSH
90556: LD_INT 1
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90575: LD_ADDR_VAR 0 39
90579: PUSH
90580: LD_INT 0
90582: PUSH
90583: LD_INT 0
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 0
90592: PUSH
90593: LD_INT 1
90595: NEG
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: PUSH
90604: LD_INT 0
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 1
90613: PUSH
90614: LD_INT 1
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 1
90633: NEG
90634: PUSH
90635: LD_INT 0
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 1
90644: NEG
90645: PUSH
90646: LD_INT 1
90648: NEG
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: NEG
90657: PUSH
90658: LD_INT 2
90660: NEG
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 1
90668: PUSH
90669: LD_INT 2
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90687: LD_ADDR_VAR 0 40
90691: PUSH
90692: LD_INT 0
90694: PUSH
90695: LD_INT 0
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: PUSH
90702: LD_INT 0
90704: PUSH
90705: LD_INT 1
90707: NEG
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: LD_INT 0
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 1
90725: PUSH
90726: LD_INT 1
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 0
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: NEG
90746: PUSH
90747: LD_INT 0
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 1
90756: NEG
90757: PUSH
90758: LD_INT 1
90760: NEG
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 1
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: LD_INT 1
90779: NEG
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90799: LD_ADDR_VAR 0 41
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 0
90816: PUSH
90817: LD_INT 1
90819: NEG
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 1
90827: PUSH
90828: LD_INT 0
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 1
90837: PUSH
90838: LD_INT 1
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 0
90847: PUSH
90848: LD_INT 1
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 1
90857: NEG
90858: PUSH
90859: LD_INT 0
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 1
90868: NEG
90869: PUSH
90870: LD_INT 1
90872: NEG
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 1
90880: NEG
90881: PUSH
90882: LD_INT 2
90884: NEG
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 1
90892: PUSH
90893: LD_INT 1
90895: NEG
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 2
90903: PUSH
90904: LD_INT 0
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: LD_INT 1
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 2
90923: PUSH
90924: LD_INT 2
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 1
90933: PUSH
90934: LD_INT 2
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 1
90943: NEG
90944: PUSH
90945: LD_INT 1
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 2
90954: NEG
90955: PUSH
90956: LD_INT 0
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 2
90965: NEG
90966: PUSH
90967: LD_INT 1
90969: NEG
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 2
90977: NEG
90978: PUSH
90979: LD_INT 2
90981: NEG
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 2
90989: NEG
90990: PUSH
90991: LD_INT 3
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 2
91001: PUSH
91002: LD_INT 1
91004: NEG
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 3
91012: PUSH
91013: LD_INT 0
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 3
91022: PUSH
91023: LD_INT 1
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 3
91032: PUSH
91033: LD_INT 2
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 3
91042: PUSH
91043: LD_INT 3
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 2
91052: PUSH
91053: LD_INT 3
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 2
91062: NEG
91063: PUSH
91064: LD_INT 1
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 3
91073: NEG
91074: PUSH
91075: LD_INT 0
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 3
91084: NEG
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 3
91096: NEG
91097: PUSH
91098: LD_INT 2
91100: NEG
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 3
91108: NEG
91109: PUSH
91110: LD_INT 3
91112: NEG
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91149: LD_ADDR_VAR 0 42
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: LD_INT 0
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: LD_INT 0
91166: PUSH
91167: LD_INT 1
91169: NEG
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 1
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 1
91187: PUSH
91188: LD_INT 1
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: LD_INT 1
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: NEG
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 1
91218: NEG
91219: PUSH
91220: LD_INT 1
91222: NEG
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 1
91230: NEG
91231: PUSH
91232: LD_INT 2
91234: NEG
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 0
91242: PUSH
91243: LD_INT 2
91245: NEG
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 1
91253: PUSH
91254: LD_INT 1
91256: NEG
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: LD_INT 1
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 2
91274: PUSH
91275: LD_INT 2
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 1
91284: PUSH
91285: LD_INT 2
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: LD_INT 2
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 2
91315: NEG
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 2
91327: NEG
91328: PUSH
91329: LD_INT 2
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 2
91339: NEG
91340: PUSH
91341: LD_INT 3
91343: NEG
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: NEG
91352: PUSH
91353: LD_INT 3
91355: NEG
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 0
91363: PUSH
91364: LD_INT 3
91366: NEG
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 1
91374: PUSH
91375: LD_INT 2
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 3
91385: PUSH
91386: LD_INT 2
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 3
91395: PUSH
91396: LD_INT 3
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 2
91405: PUSH
91406: LD_INT 3
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: LD_INT 3
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 0
91425: PUSH
91426: LD_INT 3
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 1
91435: NEG
91436: PUSH
91437: LD_INT 2
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 3
91446: NEG
91447: PUSH
91448: LD_INT 2
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 3
91458: NEG
91459: PUSH
91460: LD_INT 3
91462: NEG
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91499: LD_ADDR_VAR 0 43
91503: PUSH
91504: LD_INT 0
91506: PUSH
91507: LD_INT 0
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 0
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 1
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: LD_INT 0
91547: PUSH
91548: LD_INT 1
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 1
91557: NEG
91558: PUSH
91559: LD_INT 0
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: LD_INT 1
91568: NEG
91569: PUSH
91570: LD_INT 1
91572: NEG
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 1
91580: NEG
91581: PUSH
91582: LD_INT 2
91584: NEG
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: LD_INT 0
91592: PUSH
91593: LD_INT 2
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 1
91603: PUSH
91604: LD_INT 1
91606: NEG
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 2
91614: PUSH
91615: LD_INT 0
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 2
91624: PUSH
91625: LD_INT 1
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 1
91634: PUSH
91635: LD_INT 2
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 0
91644: PUSH
91645: LD_INT 2
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 1
91654: NEG
91655: PUSH
91656: LD_INT 1
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: PUSH
91663: LD_INT 2
91665: NEG
91666: PUSH
91667: LD_INT 0
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 2
91676: NEG
91677: PUSH
91678: LD_INT 1
91680: NEG
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: LD_INT 3
91692: NEG
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: LD_INT 0
91700: PUSH
91701: LD_INT 3
91703: NEG
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 1
91711: PUSH
91712: LD_INT 2
91714: NEG
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 2
91722: PUSH
91723: LD_INT 1
91725: NEG
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: PUSH
91731: LD_INT 3
91733: PUSH
91734: LD_INT 0
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 3
91743: PUSH
91744: LD_INT 1
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: LD_INT 3
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PUSH
91761: LD_INT 0
91763: PUSH
91764: LD_INT 3
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 1
91773: NEG
91774: PUSH
91775: LD_INT 2
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: PUSH
91782: LD_INT 2
91784: NEG
91785: PUSH
91786: LD_INT 1
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 3
91795: NEG
91796: PUSH
91797: LD_INT 0
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 3
91806: NEG
91807: PUSH
91808: LD_INT 1
91810: NEG
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91847: LD_ADDR_VAR 0 44
91851: PUSH
91852: LD_INT 0
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 0
91864: PUSH
91865: LD_INT 1
91867: NEG
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 1
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 1
91885: PUSH
91886: LD_INT 1
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 0
91895: PUSH
91896: LD_INT 1
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 1
91905: NEG
91906: PUSH
91907: LD_INT 0
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 1
91916: NEG
91917: PUSH
91918: LD_INT 1
91920: NEG
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: PUSH
91926: LD_INT 1
91928: NEG
91929: PUSH
91930: LD_INT 2
91932: NEG
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 1
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 2
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: PUSH
91959: LD_INT 2
91961: PUSH
91962: LD_INT 1
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 2
91971: PUSH
91972: LD_INT 2
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: PUSH
91979: LD_INT 1
91981: PUSH
91982: LD_INT 2
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 1
91991: NEG
91992: PUSH
91993: LD_INT 1
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: PUSH
92000: LD_INT 2
92002: NEG
92003: PUSH
92004: LD_INT 0
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 2
92013: NEG
92014: PUSH
92015: LD_INT 1
92017: NEG
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 2
92025: NEG
92026: PUSH
92027: LD_INT 2
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 2
92037: NEG
92038: PUSH
92039: LD_INT 3
92041: NEG
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 2
92049: PUSH
92050: LD_INT 1
92052: NEG
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 3
92060: PUSH
92061: LD_INT 0
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: LD_INT 3
92070: PUSH
92071: LD_INT 1
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 3
92080: PUSH
92081: LD_INT 2
92083: PUSH
92084: EMPTY
92085: LIST
92086: LIST
92087: PUSH
92088: LD_INT 3
92090: PUSH
92091: LD_INT 3
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 2
92100: PUSH
92101: LD_INT 3
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 2
92110: NEG
92111: PUSH
92112: LD_INT 1
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 3
92121: NEG
92122: PUSH
92123: LD_INT 0
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PUSH
92130: LD_INT 3
92132: NEG
92133: PUSH
92134: LD_INT 1
92136: NEG
92137: PUSH
92138: EMPTY
92139: LIST
92140: LIST
92141: PUSH
92142: LD_INT 3
92144: NEG
92145: PUSH
92146: LD_INT 2
92148: NEG
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: LD_INT 3
92156: NEG
92157: PUSH
92158: LD_INT 3
92160: NEG
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92197: LD_ADDR_VAR 0 45
92201: PUSH
92202: LD_INT 0
92204: PUSH
92205: LD_INT 0
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 0
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 1
92225: PUSH
92226: LD_INT 0
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 1
92235: PUSH
92236: LD_INT 1
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 0
92245: PUSH
92246: LD_INT 1
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 1
92255: NEG
92256: PUSH
92257: LD_INT 0
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 1
92266: NEG
92267: PUSH
92268: LD_INT 1
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 1
92278: NEG
92279: PUSH
92280: LD_INT 2
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 0
92290: PUSH
92291: LD_INT 2
92293: NEG
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 1
92301: PUSH
92302: LD_INT 1
92304: NEG
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 2
92312: PUSH
92313: LD_INT 1
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 2
92322: PUSH
92323: LD_INT 2
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 1
92332: PUSH
92333: LD_INT 2
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 0
92342: PUSH
92343: LD_INT 2
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 1
92352: NEG
92353: PUSH
92354: LD_INT 1
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 2
92363: NEG
92364: PUSH
92365: LD_INT 1
92367: NEG
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: LD_INT 2
92375: NEG
92376: PUSH
92377: LD_INT 2
92379: NEG
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 2
92387: NEG
92388: PUSH
92389: LD_INT 3
92391: NEG
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 1
92399: NEG
92400: PUSH
92401: LD_INT 3
92403: NEG
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 0
92411: PUSH
92412: LD_INT 3
92414: NEG
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: LD_INT 1
92422: PUSH
92423: LD_INT 2
92425: NEG
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 3
92433: PUSH
92434: LD_INT 2
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 3
92443: PUSH
92444: LD_INT 3
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 2
92453: PUSH
92454: LD_INT 3
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: LD_INT 3
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 0
92473: PUSH
92474: LD_INT 3
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 1
92483: NEG
92484: PUSH
92485: LD_INT 2
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 3
92494: NEG
92495: PUSH
92496: LD_INT 2
92498: NEG
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 3
92506: NEG
92507: PUSH
92508: LD_INT 3
92510: NEG
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92547: LD_ADDR_VAR 0 46
92551: PUSH
92552: LD_INT 0
92554: PUSH
92555: LD_INT 0
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 0
92564: PUSH
92565: LD_INT 1
92567: NEG
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 1
92575: PUSH
92576: LD_INT 0
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 1
92585: PUSH
92586: LD_INT 1
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 0
92595: PUSH
92596: LD_INT 1
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 1
92605: NEG
92606: PUSH
92607: LD_INT 0
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 1
92616: NEG
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 1
92628: NEG
92629: PUSH
92630: LD_INT 2
92632: NEG
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 0
92640: PUSH
92641: LD_INT 2
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 1
92651: PUSH
92652: LD_INT 1
92654: NEG
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: LD_INT 0
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 2
92672: PUSH
92673: LD_INT 1
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 1
92682: PUSH
92683: LD_INT 2
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 0
92692: PUSH
92693: LD_INT 2
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 1
92702: NEG
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 2
92713: NEG
92714: PUSH
92715: LD_INT 0
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 2
92724: NEG
92725: PUSH
92726: LD_INT 1
92728: NEG
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: LD_INT 1
92736: NEG
92737: PUSH
92738: LD_INT 3
92740: NEG
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: LD_INT 2
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 2
92770: PUSH
92771: LD_INT 1
92773: NEG
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 3
92781: PUSH
92782: LD_INT 0
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 3
92791: PUSH
92792: LD_INT 1
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 1
92801: PUSH
92802: LD_INT 3
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 0
92811: PUSH
92812: LD_INT 3
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 1
92821: NEG
92822: PUSH
92823: LD_INT 2
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 2
92832: NEG
92833: PUSH
92834: LD_INT 1
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 3
92843: NEG
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 3
92854: NEG
92855: PUSH
92856: LD_INT 1
92858: NEG
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92895: LD_ADDR_VAR 0 47
92899: PUSH
92900: LD_INT 0
92902: PUSH
92903: LD_INT 0
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: LD_INT 0
92912: PUSH
92913: LD_INT 1
92915: NEG
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PUSH
92921: LD_INT 1
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 1
92933: PUSH
92934: LD_INT 1
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 0
92943: PUSH
92944: LD_INT 1
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: NEG
92954: PUSH
92955: LD_INT 0
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 1
92964: NEG
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 1
92976: NEG
92977: PUSH
92978: LD_INT 2
92980: NEG
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: PUSH
92986: LD_INT 0
92988: PUSH
92989: LD_INT 2
92991: NEG
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: LD_INT 1
92999: PUSH
93000: LD_INT 1
93002: NEG
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 2
93010: NEG
93011: PUSH
93012: LD_INT 1
93014: NEG
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 2
93022: NEG
93023: PUSH
93024: LD_INT 2
93026: NEG
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93046: LD_ADDR_VAR 0 48
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 0
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: LD_INT 1
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: LD_INT 0
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 1
93084: PUSH
93085: LD_INT 1
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 0
93094: PUSH
93095: LD_INT 1
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 1
93104: NEG
93105: PUSH
93106: LD_INT 0
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 1
93115: NEG
93116: PUSH
93117: LD_INT 1
93119: NEG
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 1
93127: NEG
93128: PUSH
93129: LD_INT 2
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 0
93139: PUSH
93140: LD_INT 2
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 1
93150: PUSH
93151: LD_INT 1
93153: NEG
93154: PUSH
93155: EMPTY
93156: LIST
93157: LIST
93158: PUSH
93159: LD_INT 2
93161: PUSH
93162: LD_INT 0
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: PUSH
93169: LD_INT 2
93171: PUSH
93172: LD_INT 1
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93193: LD_ADDR_VAR 0 49
93197: PUSH
93198: LD_INT 0
93200: PUSH
93201: LD_INT 0
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: LD_INT 0
93210: PUSH
93211: LD_INT 1
93213: NEG
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: PUSH
93219: LD_INT 1
93221: PUSH
93222: LD_INT 0
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 1
93231: PUSH
93232: LD_INT 1
93234: PUSH
93235: EMPTY
93236: LIST
93237: LIST
93238: PUSH
93239: LD_INT 0
93241: PUSH
93242: LD_INT 1
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 1
93251: NEG
93252: PUSH
93253: LD_INT 0
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 1
93262: NEG
93263: PUSH
93264: LD_INT 1
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: LD_INT 1
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 2
93285: PUSH
93286: LD_INT 0
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: PUSH
93293: LD_INT 2
93295: PUSH
93296: LD_INT 1
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PUSH
93303: LD_INT 2
93305: PUSH
93306: LD_INT 2
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 1
93315: PUSH
93316: LD_INT 2
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93337: LD_ADDR_VAR 0 50
93341: PUSH
93342: LD_INT 0
93344: PUSH
93345: LD_INT 0
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 0
93354: PUSH
93355: LD_INT 1
93357: NEG
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 1
93365: PUSH
93366: LD_INT 0
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 1
93375: PUSH
93376: LD_INT 1
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: LD_INT 0
93385: PUSH
93386: LD_INT 1
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 1
93395: NEG
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 1
93406: NEG
93407: PUSH
93408: LD_INT 1
93410: NEG
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: LD_INT 2
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 2
93428: PUSH
93429: LD_INT 2
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 1
93438: PUSH
93439: LD_INT 2
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: PUSH
93446: LD_INT 0
93448: PUSH
93449: LD_INT 2
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 1
93458: NEG
93459: PUSH
93460: LD_INT 1
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93481: LD_ADDR_VAR 0 51
93485: PUSH
93486: LD_INT 0
93488: PUSH
93489: LD_INT 0
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 0
93498: PUSH
93499: LD_INT 1
93501: NEG
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 1
93509: PUSH
93510: LD_INT 0
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 1
93519: PUSH
93520: LD_INT 1
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 0
93529: PUSH
93530: LD_INT 1
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 1
93539: NEG
93540: PUSH
93541: LD_INT 0
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 1
93550: NEG
93551: PUSH
93552: LD_INT 1
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 1
93562: PUSH
93563: LD_INT 2
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 0
93572: PUSH
93573: LD_INT 2
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: LD_INT 1
93582: NEG
93583: PUSH
93584: LD_INT 1
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 2
93593: NEG
93594: PUSH
93595: LD_INT 0
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 2
93604: NEG
93605: PUSH
93606: LD_INT 1
93608: NEG
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93628: LD_ADDR_VAR 0 52
93632: PUSH
93633: LD_INT 0
93635: PUSH
93636: LD_INT 0
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 0
93645: PUSH
93646: LD_INT 1
93648: NEG
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 1
93656: PUSH
93657: LD_INT 0
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 1
93666: PUSH
93667: LD_INT 1
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 0
93676: PUSH
93677: LD_INT 1
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 1
93686: NEG
93687: PUSH
93688: LD_INT 0
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 1
93697: NEG
93698: PUSH
93699: LD_INT 1
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 1
93709: NEG
93710: PUSH
93711: LD_INT 2
93713: NEG
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: LD_INT 1
93721: NEG
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 2
93732: NEG
93733: PUSH
93734: LD_INT 0
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 2
93743: NEG
93744: PUSH
93745: LD_INT 1
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 2
93755: NEG
93756: PUSH
93757: LD_INT 2
93759: NEG
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93779: LD_ADDR_VAR 0 53
93783: PUSH
93784: LD_INT 0
93786: PUSH
93787: LD_INT 0
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 0
93796: PUSH
93797: LD_INT 1
93799: NEG
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 1
93807: PUSH
93808: LD_INT 0
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 1
93817: PUSH
93818: LD_INT 1
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 0
93827: PUSH
93828: LD_INT 1
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 1
93837: NEG
93838: PUSH
93839: LD_INT 0
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 1
93848: NEG
93849: PUSH
93850: LD_INT 1
93852: NEG
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: LD_INT 1
93860: NEG
93861: PUSH
93862: LD_INT 2
93864: NEG
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 0
93872: PUSH
93873: LD_INT 2
93875: NEG
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 1
93883: PUSH
93884: LD_INT 1
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 2
93894: PUSH
93895: LD_INT 0
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 2
93904: PUSH
93905: LD_INT 1
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 2
93914: PUSH
93915: LD_INT 2
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 1
93924: PUSH
93925: LD_INT 2
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 0
93934: PUSH
93935: LD_INT 2
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 1
93944: NEG
93945: PUSH
93946: LD_INT 1
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: LD_INT 0
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 2
93966: NEG
93967: PUSH
93968: LD_INT 1
93970: NEG
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: LD_INT 2
93978: NEG
93979: PUSH
93980: LD_INT 2
93982: NEG
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94009: LD_ADDR_VAR 0 54
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: LD_INT 0
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 0
94026: PUSH
94027: LD_INT 1
94029: NEG
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: LD_INT 1
94037: PUSH
94038: LD_INT 0
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 1
94047: PUSH
94048: LD_INT 1
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 0
94057: PUSH
94058: LD_INT 1
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 1
94067: NEG
94068: PUSH
94069: LD_INT 0
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 1
94078: NEG
94079: PUSH
94080: LD_INT 1
94082: NEG
94083: PUSH
94084: EMPTY
94085: LIST
94086: LIST
94087: PUSH
94088: LD_INT 1
94090: NEG
94091: PUSH
94092: LD_INT 2
94094: NEG
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: LD_INT 2
94105: NEG
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: LD_INT 1
94116: NEG
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 2
94124: PUSH
94125: LD_INT 0
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: LD_INT 2
94134: PUSH
94135: LD_INT 1
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 2
94144: PUSH
94145: LD_INT 2
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 1
94154: PUSH
94155: LD_INT 2
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 0
94164: PUSH
94165: LD_INT 2
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 1
94174: NEG
94175: PUSH
94176: LD_INT 1
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 2
94185: NEG
94186: PUSH
94187: LD_INT 0
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 2
94196: NEG
94197: PUSH
94198: LD_INT 1
94200: NEG
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 2
94208: NEG
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94239: LD_ADDR_VAR 0 55
94243: PUSH
94244: LD_INT 0
94246: PUSH
94247: LD_INT 0
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 0
94256: PUSH
94257: LD_INT 1
94259: NEG
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 1
94267: PUSH
94268: LD_INT 0
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 1
94277: PUSH
94278: LD_INT 1
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 0
94287: PUSH
94288: LD_INT 1
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 1
94297: NEG
94298: PUSH
94299: LD_INT 0
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 1
94308: NEG
94309: PUSH
94310: LD_INT 1
94312: NEG
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 1
94320: NEG
94321: PUSH
94322: LD_INT 2
94324: NEG
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 0
94332: PUSH
94333: LD_INT 2
94335: NEG
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 1
94343: PUSH
94344: LD_INT 1
94346: NEG
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: LD_INT 0
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 2
94364: PUSH
94365: LD_INT 1
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 2
94374: PUSH
94375: LD_INT 2
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 1
94384: PUSH
94385: LD_INT 2
94387: PUSH
94388: EMPTY
94389: LIST
94390: LIST
94391: PUSH
94392: LD_INT 0
94394: PUSH
94395: LD_INT 2
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 1
94404: NEG
94405: PUSH
94406: LD_INT 1
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 2
94415: NEG
94416: PUSH
94417: LD_INT 0
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 2
94426: NEG
94427: PUSH
94428: LD_INT 1
94430: NEG
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 2
94438: NEG
94439: PUSH
94440: LD_INT 2
94442: NEG
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: EMPTY
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94469: LD_ADDR_VAR 0 56
94473: PUSH
94474: LD_INT 0
94476: PUSH
94477: LD_INT 0
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 0
94486: PUSH
94487: LD_INT 1
94489: NEG
94490: PUSH
94491: EMPTY
94492: LIST
94493: LIST
94494: PUSH
94495: LD_INT 1
94497: PUSH
94498: LD_INT 0
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: LD_INT 1
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 0
94517: PUSH
94518: LD_INT 1
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 1
94527: NEG
94528: PUSH
94529: LD_INT 0
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 1
94538: NEG
94539: PUSH
94540: LD_INT 1
94542: NEG
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 1
94550: NEG
94551: PUSH
94552: LD_INT 2
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 0
94562: PUSH
94563: LD_INT 2
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 1
94573: PUSH
94574: LD_INT 1
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 2
94584: PUSH
94585: LD_INT 0
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 2
94594: PUSH
94595: LD_INT 1
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 2
94604: PUSH
94605: LD_INT 2
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 1
94614: PUSH
94615: LD_INT 2
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 0
94624: PUSH
94625: LD_INT 2
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 1
94634: NEG
94635: PUSH
94636: LD_INT 1
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 2
94645: NEG
94646: PUSH
94647: LD_INT 0
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 2
94656: NEG
94657: PUSH
94658: LD_INT 1
94660: NEG
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: LD_INT 2
94668: NEG
94669: PUSH
94670: LD_INT 2
94672: NEG
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94699: LD_ADDR_VAR 0 57
94703: PUSH
94704: LD_INT 0
94706: PUSH
94707: LD_INT 0
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: LD_INT 0
94716: PUSH
94717: LD_INT 1
94719: NEG
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: PUSH
94725: LD_INT 1
94727: PUSH
94728: LD_INT 0
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 1
94737: PUSH
94738: LD_INT 1
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: LD_INT 0
94747: PUSH
94748: LD_INT 1
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 1
94757: NEG
94758: PUSH
94759: LD_INT 0
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: LD_INT 1
94768: NEG
94769: PUSH
94770: LD_INT 1
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 1
94780: NEG
94781: PUSH
94782: LD_INT 2
94784: NEG
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 0
94792: PUSH
94793: LD_INT 2
94795: NEG
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 1
94803: PUSH
94804: LD_INT 1
94806: NEG
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 2
94814: PUSH
94815: LD_INT 0
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 2
94824: PUSH
94825: LD_INT 1
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 2
94834: PUSH
94835: LD_INT 2
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 1
94844: PUSH
94845: LD_INT 2
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 0
94854: PUSH
94855: LD_INT 2
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 1
94864: NEG
94865: PUSH
94866: LD_INT 1
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 2
94875: NEG
94876: PUSH
94877: LD_INT 0
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 2
94886: NEG
94887: PUSH
94888: LD_INT 1
94890: NEG
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 2
94898: NEG
94899: PUSH
94900: LD_INT 2
94902: NEG
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94929: LD_ADDR_VAR 0 58
94933: PUSH
94934: LD_INT 0
94936: PUSH
94937: LD_INT 0
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 0
94946: PUSH
94947: LD_INT 1
94949: NEG
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 1
94957: PUSH
94958: LD_INT 0
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 1
94967: PUSH
94968: LD_INT 1
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 0
94977: PUSH
94978: LD_INT 1
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 1
94987: NEG
94988: PUSH
94989: LD_INT 0
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: NEG
94999: PUSH
95000: LD_INT 1
95002: NEG
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 1
95010: NEG
95011: PUSH
95012: LD_INT 2
95014: NEG
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 0
95022: PUSH
95023: LD_INT 2
95025: NEG
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: LD_INT 1
95033: PUSH
95034: LD_INT 1
95036: NEG
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: PUSH
95042: LD_INT 2
95044: PUSH
95045: LD_INT 0
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 2
95054: PUSH
95055: LD_INT 1
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 2
95064: PUSH
95065: LD_INT 2
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: LD_INT 2
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 0
95084: PUSH
95085: LD_INT 2
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 1
95094: NEG
95095: PUSH
95096: LD_INT 1
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 2
95105: NEG
95106: PUSH
95107: LD_INT 0
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 2
95116: NEG
95117: PUSH
95118: LD_INT 1
95120: NEG
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 2
95128: NEG
95129: PUSH
95130: LD_INT 2
95132: NEG
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95159: LD_ADDR_VAR 0 59
95163: PUSH
95164: LD_INT 0
95166: PUSH
95167: LD_INT 0
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: PUSH
95174: LD_INT 0
95176: PUSH
95177: LD_INT 1
95179: NEG
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 1
95187: PUSH
95188: LD_INT 0
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 1
95197: PUSH
95198: LD_INT 1
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 0
95207: PUSH
95208: LD_INT 1
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 1
95217: NEG
95218: PUSH
95219: LD_INT 0
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 1
95228: NEG
95229: PUSH
95230: LD_INT 1
95232: NEG
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95247: LD_ADDR_VAR 0 60
95251: PUSH
95252: LD_INT 0
95254: PUSH
95255: LD_INT 0
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: LD_INT 0
95264: PUSH
95265: LD_INT 1
95267: NEG
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 1
95275: PUSH
95276: LD_INT 0
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 1
95285: PUSH
95286: LD_INT 1
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 0
95295: PUSH
95296: LD_INT 1
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 1
95305: NEG
95306: PUSH
95307: LD_INT 0
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 1
95316: NEG
95317: PUSH
95318: LD_INT 1
95320: NEG
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95335: LD_ADDR_VAR 0 61
95339: PUSH
95340: LD_INT 0
95342: PUSH
95343: LD_INT 0
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 0
95352: PUSH
95353: LD_INT 1
95355: NEG
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: LD_INT 1
95363: PUSH
95364: LD_INT 0
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 1
95373: PUSH
95374: LD_INT 1
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 0
95383: PUSH
95384: LD_INT 1
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 1
95393: NEG
95394: PUSH
95395: LD_INT 0
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: LD_INT 1
95404: NEG
95405: PUSH
95406: LD_INT 1
95408: NEG
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95423: LD_ADDR_VAR 0 62
95427: PUSH
95428: LD_INT 0
95430: PUSH
95431: LD_INT 0
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 0
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 1
95451: PUSH
95452: LD_INT 0
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 1
95461: PUSH
95462: LD_INT 1
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 0
95471: PUSH
95472: LD_INT 1
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 1
95481: NEG
95482: PUSH
95483: LD_INT 0
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 1
95492: NEG
95493: PUSH
95494: LD_INT 1
95496: NEG
95497: PUSH
95498: EMPTY
95499: LIST
95500: LIST
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95511: LD_ADDR_VAR 0 63
95515: PUSH
95516: LD_INT 0
95518: PUSH
95519: LD_INT 0
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: LD_INT 0
95528: PUSH
95529: LD_INT 1
95531: NEG
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 1
95539: PUSH
95540: LD_INT 0
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 1
95549: PUSH
95550: LD_INT 1
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 0
95559: PUSH
95560: LD_INT 1
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 1
95569: NEG
95570: PUSH
95571: LD_INT 0
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: LD_INT 1
95580: NEG
95581: PUSH
95582: LD_INT 1
95584: NEG
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95599: LD_ADDR_VAR 0 64
95603: PUSH
95604: LD_INT 0
95606: PUSH
95607: LD_INT 0
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 0
95616: PUSH
95617: LD_INT 1
95619: NEG
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 1
95627: PUSH
95628: LD_INT 0
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 1
95637: PUSH
95638: LD_INT 1
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 0
95647: PUSH
95648: LD_INT 1
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 1
95657: NEG
95658: PUSH
95659: LD_INT 0
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 1
95668: NEG
95669: PUSH
95670: LD_INT 1
95672: NEG
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: ST_TO_ADDR
// end ; 1 :
95687: GO 101584
95689: LD_INT 1
95691: DOUBLE
95692: EQUAL
95693: IFTRUE 95697
95695: GO 98320
95697: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95698: LD_ADDR_VAR 0 11
95702: PUSH
95703: LD_INT 1
95705: NEG
95706: PUSH
95707: LD_INT 3
95709: NEG
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: LD_INT 3
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 1
95728: PUSH
95729: LD_INT 2
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: LIST
95741: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95742: LD_ADDR_VAR 0 12
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: LD_INT 1
95752: NEG
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 3
95760: PUSH
95761: LD_INT 0
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 3
95770: PUSH
95771: LD_INT 1
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: LIST
95782: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95783: LD_ADDR_VAR 0 13
95787: PUSH
95788: LD_INT 3
95790: PUSH
95791: LD_INT 2
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: LD_INT 3
95800: PUSH
95801: LD_INT 3
95803: PUSH
95804: EMPTY
95805: LIST
95806: LIST
95807: PUSH
95808: LD_INT 2
95810: PUSH
95811: LD_INT 3
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: LIST
95822: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95823: LD_ADDR_VAR 0 14
95827: PUSH
95828: LD_INT 1
95830: PUSH
95831: LD_INT 3
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 0
95840: PUSH
95841: LD_INT 3
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 1
95850: NEG
95851: PUSH
95852: LD_INT 2
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: LIST
95863: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95864: LD_ADDR_VAR 0 15
95868: PUSH
95869: LD_INT 2
95871: NEG
95872: PUSH
95873: LD_INT 1
95875: PUSH
95876: EMPTY
95877: LIST
95878: LIST
95879: PUSH
95880: LD_INT 3
95882: NEG
95883: PUSH
95884: LD_INT 0
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 3
95893: NEG
95894: PUSH
95895: LD_INT 1
95897: NEG
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: LIST
95907: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95908: LD_ADDR_VAR 0 16
95912: PUSH
95913: LD_INT 2
95915: NEG
95916: PUSH
95917: LD_INT 3
95919: NEG
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 3
95927: NEG
95928: PUSH
95929: LD_INT 2
95931: NEG
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 3
95939: NEG
95940: PUSH
95941: LD_INT 3
95943: NEG
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: LIST
95953: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95954: LD_ADDR_VAR 0 17
95958: PUSH
95959: LD_INT 1
95961: NEG
95962: PUSH
95963: LD_INT 3
95965: NEG
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: LD_INT 3
95976: NEG
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PUSH
95982: LD_INT 1
95984: PUSH
95985: LD_INT 2
95987: NEG
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: LIST
95997: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95998: LD_ADDR_VAR 0 18
96002: PUSH
96003: LD_INT 2
96005: PUSH
96006: LD_INT 1
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 3
96016: PUSH
96017: LD_INT 0
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: LD_INT 3
96026: PUSH
96027: LD_INT 1
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: LIST
96038: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96039: LD_ADDR_VAR 0 19
96043: PUSH
96044: LD_INT 3
96046: PUSH
96047: LD_INT 2
96049: PUSH
96050: EMPTY
96051: LIST
96052: LIST
96053: PUSH
96054: LD_INT 3
96056: PUSH
96057: LD_INT 3
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 2
96066: PUSH
96067: LD_INT 3
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: LIST
96078: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96079: LD_ADDR_VAR 0 20
96083: PUSH
96084: LD_INT 1
96086: PUSH
96087: LD_INT 3
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 0
96096: PUSH
96097: LD_INT 3
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 1
96106: NEG
96107: PUSH
96108: LD_INT 2
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: LIST
96119: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96120: LD_ADDR_VAR 0 21
96124: PUSH
96125: LD_INT 2
96127: NEG
96128: PUSH
96129: LD_INT 1
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: PUSH
96136: LD_INT 3
96138: NEG
96139: PUSH
96140: LD_INT 0
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PUSH
96147: LD_INT 3
96149: NEG
96150: PUSH
96151: LD_INT 1
96153: NEG
96154: PUSH
96155: EMPTY
96156: LIST
96157: LIST
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: LIST
96163: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96164: LD_ADDR_VAR 0 22
96168: PUSH
96169: LD_INT 2
96171: NEG
96172: PUSH
96173: LD_INT 3
96175: NEG
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 3
96183: NEG
96184: PUSH
96185: LD_INT 2
96187: NEG
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 3
96195: NEG
96196: PUSH
96197: LD_INT 3
96199: NEG
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: LIST
96209: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96210: LD_ADDR_VAR 0 23
96214: PUSH
96215: LD_INT 0
96217: PUSH
96218: LD_INT 3
96220: NEG
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 1
96228: NEG
96229: PUSH
96230: LD_INT 4
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 1
96240: PUSH
96241: LD_INT 3
96243: NEG
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: LIST
96253: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96254: LD_ADDR_VAR 0 24
96258: PUSH
96259: LD_INT 3
96261: PUSH
96262: LD_INT 0
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 3
96271: PUSH
96272: LD_INT 1
96274: NEG
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 4
96282: PUSH
96283: LD_INT 1
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: LIST
96294: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96295: LD_ADDR_VAR 0 25
96299: PUSH
96300: LD_INT 3
96302: PUSH
96303: LD_INT 3
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 4
96312: PUSH
96313: LD_INT 3
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: PUSH
96320: LD_INT 3
96322: PUSH
96323: LD_INT 4
96325: PUSH
96326: EMPTY
96327: LIST
96328: LIST
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: LIST
96334: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96335: LD_ADDR_VAR 0 26
96339: PUSH
96340: LD_INT 0
96342: PUSH
96343: LD_INT 3
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: PUSH
96350: LD_INT 1
96352: PUSH
96353: LD_INT 4
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: PUSH
96360: LD_INT 1
96362: NEG
96363: PUSH
96364: LD_INT 3
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: LIST
96375: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96376: LD_ADDR_VAR 0 27
96380: PUSH
96381: LD_INT 3
96383: NEG
96384: PUSH
96385: LD_INT 0
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 3
96394: NEG
96395: PUSH
96396: LD_INT 1
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 4
96405: NEG
96406: PUSH
96407: LD_INT 1
96409: NEG
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: LIST
96419: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96420: LD_ADDR_VAR 0 28
96424: PUSH
96425: LD_INT 3
96427: NEG
96428: PUSH
96429: LD_INT 3
96431: NEG
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 3
96439: NEG
96440: PUSH
96441: LD_INT 4
96443: NEG
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 4
96451: NEG
96452: PUSH
96453: LD_INT 3
96455: NEG
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: PUSH
96461: EMPTY
96462: LIST
96463: LIST
96464: LIST
96465: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96466: LD_ADDR_VAR 0 29
96470: PUSH
96471: LD_INT 1
96473: NEG
96474: PUSH
96475: LD_INT 3
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 0
96485: PUSH
96486: LD_INT 3
96488: NEG
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PUSH
96494: LD_INT 1
96496: PUSH
96497: LD_INT 2
96499: NEG
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 1
96507: NEG
96508: PUSH
96509: LD_INT 4
96511: NEG
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 0
96519: PUSH
96520: LD_INT 4
96522: NEG
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 1
96530: PUSH
96531: LD_INT 3
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: LD_INT 5
96545: NEG
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_INT 0
96553: PUSH
96554: LD_INT 5
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 1
96564: PUSH
96565: LD_INT 4
96567: NEG
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: LD_INT 1
96575: NEG
96576: PUSH
96577: LD_INT 6
96579: NEG
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 0
96587: PUSH
96588: LD_INT 6
96590: NEG
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: PUSH
96596: LD_INT 1
96598: PUSH
96599: LD_INT 5
96601: NEG
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96621: LD_ADDR_VAR 0 30
96625: PUSH
96626: LD_INT 2
96628: PUSH
96629: LD_INT 1
96631: NEG
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 3
96639: PUSH
96640: LD_INT 0
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: PUSH
96647: LD_INT 3
96649: PUSH
96650: LD_INT 1
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PUSH
96657: LD_INT 3
96659: PUSH
96660: LD_INT 1
96662: NEG
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 4
96670: PUSH
96671: LD_INT 0
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 4
96680: PUSH
96681: LD_INT 1
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 4
96690: PUSH
96691: LD_INT 1
96693: NEG
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: PUSH
96699: LD_INT 5
96701: PUSH
96702: LD_INT 0
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 5
96711: PUSH
96712: LD_INT 1
96714: PUSH
96715: EMPTY
96716: LIST
96717: LIST
96718: PUSH
96719: LD_INT 5
96721: PUSH
96722: LD_INT 1
96724: NEG
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 6
96732: PUSH
96733: LD_INT 0
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 6
96742: PUSH
96743: LD_INT 1
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96764: LD_ADDR_VAR 0 31
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: LD_INT 2
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PUSH
96779: LD_INT 3
96781: PUSH
96782: LD_INT 3
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: LD_INT 2
96791: PUSH
96792: LD_INT 3
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: PUSH
96799: LD_INT 4
96801: PUSH
96802: LD_INT 3
96804: PUSH
96805: EMPTY
96806: LIST
96807: LIST
96808: PUSH
96809: LD_INT 4
96811: PUSH
96812: LD_INT 4
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: LD_INT 3
96821: PUSH
96822: LD_INT 4
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PUSH
96829: LD_INT 5
96831: PUSH
96832: LD_INT 4
96834: PUSH
96835: EMPTY
96836: LIST
96837: LIST
96838: PUSH
96839: LD_INT 5
96841: PUSH
96842: LD_INT 5
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 4
96851: PUSH
96852: LD_INT 5
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 6
96861: PUSH
96862: LD_INT 5
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 6
96871: PUSH
96872: LD_INT 6
96874: PUSH
96875: EMPTY
96876: LIST
96877: LIST
96878: PUSH
96879: LD_INT 5
96881: PUSH
96882: LD_INT 6
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96903: LD_ADDR_VAR 0 32
96907: PUSH
96908: LD_INT 1
96910: PUSH
96911: LD_INT 3
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 0
96920: PUSH
96921: LD_INT 3
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 1
96930: NEG
96931: PUSH
96932: LD_INT 2
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: PUSH
96939: LD_INT 1
96941: PUSH
96942: LD_INT 4
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 0
96951: PUSH
96952: LD_INT 4
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: PUSH
96959: LD_INT 1
96961: NEG
96962: PUSH
96963: LD_INT 3
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_INT 1
96972: PUSH
96973: LD_INT 5
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: PUSH
96980: LD_INT 0
96982: PUSH
96983: LD_INT 5
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: PUSH
96990: LD_INT 1
96992: NEG
96993: PUSH
96994: LD_INT 4
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 1
97003: PUSH
97004: LD_INT 6
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: LD_INT 0
97013: PUSH
97014: LD_INT 6
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 1
97023: NEG
97024: PUSH
97025: LD_INT 5
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97046: LD_ADDR_VAR 0 33
97050: PUSH
97051: LD_INT 2
97053: NEG
97054: PUSH
97055: LD_INT 1
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 3
97064: NEG
97065: PUSH
97066: LD_INT 0
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 3
97075: NEG
97076: PUSH
97077: LD_INT 1
97079: NEG
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 3
97087: NEG
97088: PUSH
97089: LD_INT 1
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 4
97098: NEG
97099: PUSH
97100: LD_INT 0
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 4
97109: NEG
97110: PUSH
97111: LD_INT 1
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 4
97121: NEG
97122: PUSH
97123: LD_INT 1
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 5
97132: NEG
97133: PUSH
97134: LD_INT 0
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 5
97143: NEG
97144: PUSH
97145: LD_INT 1
97147: NEG
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: PUSH
97153: LD_INT 5
97155: NEG
97156: PUSH
97157: LD_INT 1
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: PUSH
97164: LD_INT 6
97166: NEG
97167: PUSH
97168: LD_INT 0
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 6
97177: NEG
97178: PUSH
97179: LD_INT 1
97181: NEG
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97201: LD_ADDR_VAR 0 34
97205: PUSH
97206: LD_INT 2
97208: NEG
97209: PUSH
97210: LD_INT 3
97212: NEG
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 3
97220: NEG
97221: PUSH
97222: LD_INT 2
97224: NEG
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 3
97232: NEG
97233: PUSH
97234: LD_INT 3
97236: NEG
97237: PUSH
97238: EMPTY
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 3
97244: NEG
97245: PUSH
97246: LD_INT 4
97248: NEG
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 4
97256: NEG
97257: PUSH
97258: LD_INT 3
97260: NEG
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 4
97268: NEG
97269: PUSH
97270: LD_INT 4
97272: NEG
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 4
97280: NEG
97281: PUSH
97282: LD_INT 5
97284: NEG
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 5
97292: NEG
97293: PUSH
97294: LD_INT 4
97296: NEG
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 5
97304: NEG
97305: PUSH
97306: LD_INT 5
97308: NEG
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: LD_INT 5
97316: NEG
97317: PUSH
97318: LD_INT 6
97320: NEG
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 6
97328: NEG
97329: PUSH
97330: LD_INT 5
97332: NEG
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 6
97340: NEG
97341: PUSH
97342: LD_INT 6
97344: NEG
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97364: LD_ADDR_VAR 0 41
97368: PUSH
97369: LD_INT 0
97371: PUSH
97372: LD_INT 2
97374: NEG
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_INT 1
97382: NEG
97383: PUSH
97384: LD_INT 3
97386: NEG
97387: PUSH
97388: EMPTY
97389: LIST
97390: LIST
97391: PUSH
97392: LD_INT 1
97394: PUSH
97395: LD_INT 2
97397: NEG
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: LIST
97407: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97408: LD_ADDR_VAR 0 42
97412: PUSH
97413: LD_INT 2
97415: PUSH
97416: LD_INT 0
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PUSH
97423: LD_INT 2
97425: PUSH
97426: LD_INT 1
97428: NEG
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: LD_INT 3
97436: PUSH
97437: LD_INT 1
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: LIST
97448: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97449: LD_ADDR_VAR 0 43
97453: PUSH
97454: LD_INT 2
97456: PUSH
97457: LD_INT 2
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: PUSH
97464: LD_INT 3
97466: PUSH
97467: LD_INT 2
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PUSH
97474: LD_INT 2
97476: PUSH
97477: LD_INT 3
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: LIST
97488: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97489: LD_ADDR_VAR 0 44
97493: PUSH
97494: LD_INT 0
97496: PUSH
97497: LD_INT 2
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PUSH
97504: LD_INT 1
97506: PUSH
97507: LD_INT 3
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PUSH
97514: LD_INT 1
97516: NEG
97517: PUSH
97518: LD_INT 2
97520: PUSH
97521: EMPTY
97522: LIST
97523: LIST
97524: PUSH
97525: EMPTY
97526: LIST
97527: LIST
97528: LIST
97529: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97530: LD_ADDR_VAR 0 45
97534: PUSH
97535: LD_INT 2
97537: NEG
97538: PUSH
97539: LD_INT 0
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: LD_INT 2
97548: NEG
97549: PUSH
97550: LD_INT 1
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PUSH
97557: LD_INT 3
97559: NEG
97560: PUSH
97561: LD_INT 1
97563: NEG
97564: PUSH
97565: EMPTY
97566: LIST
97567: LIST
97568: PUSH
97569: EMPTY
97570: LIST
97571: LIST
97572: LIST
97573: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97574: LD_ADDR_VAR 0 46
97578: PUSH
97579: LD_INT 2
97581: NEG
97582: PUSH
97583: LD_INT 2
97585: NEG
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 2
97593: NEG
97594: PUSH
97595: LD_INT 3
97597: NEG
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: LD_INT 3
97605: NEG
97606: PUSH
97607: LD_INT 2
97609: NEG
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: LIST
97619: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97620: LD_ADDR_VAR 0 47
97624: PUSH
97625: LD_INT 2
97627: NEG
97628: PUSH
97629: LD_INT 3
97631: NEG
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: PUSH
97637: LD_INT 1
97639: NEG
97640: PUSH
97641: LD_INT 3
97643: NEG
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97653: LD_ADDR_VAR 0 48
97657: PUSH
97658: LD_INT 1
97660: PUSH
97661: LD_INT 2
97663: NEG
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: LD_INT 2
97671: PUSH
97672: LD_INT 1
97674: NEG
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97684: LD_ADDR_VAR 0 49
97688: PUSH
97689: LD_INT 3
97691: PUSH
97692: LD_INT 1
97694: PUSH
97695: EMPTY
97696: LIST
97697: LIST
97698: PUSH
97699: LD_INT 3
97701: PUSH
97702: LD_INT 2
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: PUSH
97709: EMPTY
97710: LIST
97711: LIST
97712: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97713: LD_ADDR_VAR 0 50
97717: PUSH
97718: LD_INT 2
97720: PUSH
97721: LD_INT 3
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 1
97730: PUSH
97731: LD_INT 3
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97742: LD_ADDR_VAR 0 51
97746: PUSH
97747: LD_INT 1
97749: NEG
97750: PUSH
97751: LD_INT 2
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 2
97760: NEG
97761: PUSH
97762: LD_INT 1
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: EMPTY
97770: LIST
97771: LIST
97772: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97773: LD_ADDR_VAR 0 52
97777: PUSH
97778: LD_INT 3
97780: NEG
97781: PUSH
97782: LD_INT 1
97784: NEG
97785: PUSH
97786: EMPTY
97787: LIST
97788: LIST
97789: PUSH
97790: LD_INT 3
97792: NEG
97793: PUSH
97794: LD_INT 2
97796: NEG
97797: PUSH
97798: EMPTY
97799: LIST
97800: LIST
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97806: LD_ADDR_VAR 0 53
97810: PUSH
97811: LD_INT 1
97813: NEG
97814: PUSH
97815: LD_INT 3
97817: NEG
97818: PUSH
97819: EMPTY
97820: LIST
97821: LIST
97822: PUSH
97823: LD_INT 0
97825: PUSH
97826: LD_INT 3
97828: NEG
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PUSH
97834: LD_INT 1
97836: PUSH
97837: LD_INT 2
97839: NEG
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: PUSH
97845: EMPTY
97846: LIST
97847: LIST
97848: LIST
97849: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97850: LD_ADDR_VAR 0 54
97854: PUSH
97855: LD_INT 2
97857: PUSH
97858: LD_INT 1
97860: NEG
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 3
97868: PUSH
97869: LD_INT 0
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: PUSH
97876: LD_INT 3
97878: PUSH
97879: LD_INT 1
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: LIST
97890: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97891: LD_ADDR_VAR 0 55
97895: PUSH
97896: LD_INT 3
97898: PUSH
97899: LD_INT 2
97901: PUSH
97902: EMPTY
97903: LIST
97904: LIST
97905: PUSH
97906: LD_INT 3
97908: PUSH
97909: LD_INT 3
97911: PUSH
97912: EMPTY
97913: LIST
97914: LIST
97915: PUSH
97916: LD_INT 2
97918: PUSH
97919: LD_INT 3
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: LIST
97930: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97931: LD_ADDR_VAR 0 56
97935: PUSH
97936: LD_INT 1
97938: PUSH
97939: LD_INT 3
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 0
97948: PUSH
97949: LD_INT 3
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: LD_INT 1
97958: NEG
97959: PUSH
97960: LD_INT 2
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: LIST
97971: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97972: LD_ADDR_VAR 0 57
97976: PUSH
97977: LD_INT 2
97979: NEG
97980: PUSH
97981: LD_INT 1
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PUSH
97988: LD_INT 3
97990: NEG
97991: PUSH
97992: LD_INT 0
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PUSH
97999: LD_INT 3
98001: NEG
98002: PUSH
98003: LD_INT 1
98005: NEG
98006: PUSH
98007: EMPTY
98008: LIST
98009: LIST
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: LIST
98015: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98016: LD_ADDR_VAR 0 58
98020: PUSH
98021: LD_INT 2
98023: NEG
98024: PUSH
98025: LD_INT 3
98027: NEG
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 3
98035: NEG
98036: PUSH
98037: LD_INT 2
98039: NEG
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 3
98047: NEG
98048: PUSH
98049: LD_INT 3
98051: NEG
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: LIST
98061: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98062: LD_ADDR_VAR 0 59
98066: PUSH
98067: LD_INT 1
98069: NEG
98070: PUSH
98071: LD_INT 2
98073: NEG
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 0
98081: PUSH
98082: LD_INT 2
98084: NEG
98085: PUSH
98086: EMPTY
98087: LIST
98088: LIST
98089: PUSH
98090: LD_INT 1
98092: PUSH
98093: LD_INT 1
98095: NEG
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: LIST
98105: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98106: LD_ADDR_VAR 0 60
98110: PUSH
98111: LD_INT 1
98113: PUSH
98114: LD_INT 1
98116: NEG
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 2
98124: PUSH
98125: LD_INT 0
98127: PUSH
98128: EMPTY
98129: LIST
98130: LIST
98131: PUSH
98132: LD_INT 2
98134: PUSH
98135: LD_INT 1
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PUSH
98142: EMPTY
98143: LIST
98144: LIST
98145: LIST
98146: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98147: LD_ADDR_VAR 0 61
98151: PUSH
98152: LD_INT 2
98154: PUSH
98155: LD_INT 1
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: LD_INT 2
98164: PUSH
98165: LD_INT 2
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: PUSH
98172: LD_INT 1
98174: PUSH
98175: LD_INT 2
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: LIST
98186: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98187: LD_ADDR_VAR 0 62
98191: PUSH
98192: LD_INT 1
98194: PUSH
98195: LD_INT 2
98197: PUSH
98198: EMPTY
98199: LIST
98200: LIST
98201: PUSH
98202: LD_INT 0
98204: PUSH
98205: LD_INT 2
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 1
98214: NEG
98215: PUSH
98216: LD_INT 1
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: LIST
98227: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98228: LD_ADDR_VAR 0 63
98232: PUSH
98233: LD_INT 1
98235: NEG
98236: PUSH
98237: LD_INT 1
98239: PUSH
98240: EMPTY
98241: LIST
98242: LIST
98243: PUSH
98244: LD_INT 2
98246: NEG
98247: PUSH
98248: LD_INT 0
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 2
98257: NEG
98258: PUSH
98259: LD_INT 1
98261: NEG
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: LIST
98271: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98272: LD_ADDR_VAR 0 64
98276: PUSH
98277: LD_INT 1
98279: NEG
98280: PUSH
98281: LD_INT 2
98283: NEG
98284: PUSH
98285: EMPTY
98286: LIST
98287: LIST
98288: PUSH
98289: LD_INT 2
98291: NEG
98292: PUSH
98293: LD_INT 1
98295: NEG
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: PUSH
98301: LD_INT 2
98303: NEG
98304: PUSH
98305: LD_INT 2
98307: NEG
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PUSH
98313: EMPTY
98314: LIST
98315: LIST
98316: LIST
98317: ST_TO_ADDR
// end ; 2 :
98318: GO 101584
98320: LD_INT 2
98322: DOUBLE
98323: EQUAL
98324: IFTRUE 98328
98326: GO 101583
98328: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98329: LD_ADDR_VAR 0 29
98333: PUSH
98334: LD_INT 4
98336: PUSH
98337: LD_INT 0
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: PUSH
98344: LD_INT 4
98346: PUSH
98347: LD_INT 1
98349: NEG
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: PUSH
98355: LD_INT 5
98357: PUSH
98358: LD_INT 0
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 5
98367: PUSH
98368: LD_INT 1
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: LD_INT 4
98377: PUSH
98378: LD_INT 1
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: PUSH
98385: LD_INT 3
98387: PUSH
98388: LD_INT 0
98390: PUSH
98391: EMPTY
98392: LIST
98393: LIST
98394: PUSH
98395: LD_INT 3
98397: PUSH
98398: LD_INT 1
98400: NEG
98401: PUSH
98402: EMPTY
98403: LIST
98404: LIST
98405: PUSH
98406: LD_INT 3
98408: PUSH
98409: LD_INT 2
98411: NEG
98412: PUSH
98413: EMPTY
98414: LIST
98415: LIST
98416: PUSH
98417: LD_INT 5
98419: PUSH
98420: LD_INT 2
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: PUSH
98427: LD_INT 3
98429: PUSH
98430: LD_INT 3
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PUSH
98437: LD_INT 3
98439: PUSH
98440: LD_INT 2
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PUSH
98447: LD_INT 4
98449: PUSH
98450: LD_INT 3
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PUSH
98457: LD_INT 4
98459: PUSH
98460: LD_INT 4
98462: PUSH
98463: EMPTY
98464: LIST
98465: LIST
98466: PUSH
98467: LD_INT 3
98469: PUSH
98470: LD_INT 4
98472: PUSH
98473: EMPTY
98474: LIST
98475: LIST
98476: PUSH
98477: LD_INT 2
98479: PUSH
98480: LD_INT 3
98482: PUSH
98483: EMPTY
98484: LIST
98485: LIST
98486: PUSH
98487: LD_INT 2
98489: PUSH
98490: LD_INT 2
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 4
98499: PUSH
98500: LD_INT 2
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: PUSH
98507: LD_INT 2
98509: PUSH
98510: LD_INT 4
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: LD_INT 0
98519: PUSH
98520: LD_INT 4
98522: PUSH
98523: EMPTY
98524: LIST
98525: LIST
98526: PUSH
98527: LD_INT 0
98529: PUSH
98530: LD_INT 3
98532: PUSH
98533: EMPTY
98534: LIST
98535: LIST
98536: PUSH
98537: LD_INT 1
98539: PUSH
98540: LD_INT 4
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: PUSH
98547: LD_INT 1
98549: PUSH
98550: LD_INT 5
98552: PUSH
98553: EMPTY
98554: LIST
98555: LIST
98556: PUSH
98557: LD_INT 0
98559: PUSH
98560: LD_INT 5
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 1
98569: NEG
98570: PUSH
98571: LD_INT 4
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 1
98580: NEG
98581: PUSH
98582: LD_INT 3
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: LD_INT 2
98591: PUSH
98592: LD_INT 5
98594: PUSH
98595: EMPTY
98596: LIST
98597: LIST
98598: PUSH
98599: LD_INT 2
98601: NEG
98602: PUSH
98603: LD_INT 3
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: PUSH
98610: LD_INT 3
98612: NEG
98613: PUSH
98614: LD_INT 0
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_INT 3
98623: NEG
98624: PUSH
98625: LD_INT 1
98627: NEG
98628: PUSH
98629: EMPTY
98630: LIST
98631: LIST
98632: PUSH
98633: LD_INT 2
98635: NEG
98636: PUSH
98637: LD_INT 0
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: LD_INT 2
98646: NEG
98647: PUSH
98648: LD_INT 1
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: PUSH
98655: LD_INT 3
98657: NEG
98658: PUSH
98659: LD_INT 1
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: PUSH
98666: LD_INT 4
98668: NEG
98669: PUSH
98670: LD_INT 0
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: PUSH
98677: LD_INT 4
98679: NEG
98680: PUSH
98681: LD_INT 1
98683: NEG
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: PUSH
98689: LD_INT 4
98691: NEG
98692: PUSH
98693: LD_INT 2
98695: NEG
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: PUSH
98701: LD_INT 2
98703: NEG
98704: PUSH
98705: LD_INT 2
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 4
98714: NEG
98715: PUSH
98716: LD_INT 4
98718: NEG
98719: PUSH
98720: EMPTY
98721: LIST
98722: LIST
98723: PUSH
98724: LD_INT 4
98726: NEG
98727: PUSH
98728: LD_INT 5
98730: NEG
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 3
98738: NEG
98739: PUSH
98740: LD_INT 4
98742: NEG
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: LD_INT 3
98750: NEG
98751: PUSH
98752: LD_INT 3
98754: NEG
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 4
98762: NEG
98763: PUSH
98764: LD_INT 3
98766: NEG
98767: PUSH
98768: EMPTY
98769: LIST
98770: LIST
98771: PUSH
98772: LD_INT 5
98774: NEG
98775: PUSH
98776: LD_INT 4
98778: NEG
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: LD_INT 5
98786: NEG
98787: PUSH
98788: LD_INT 5
98790: NEG
98791: PUSH
98792: EMPTY
98793: LIST
98794: LIST
98795: PUSH
98796: LD_INT 3
98798: NEG
98799: PUSH
98800: LD_INT 5
98802: NEG
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: PUSH
98808: LD_INT 5
98810: NEG
98811: PUSH
98812: LD_INT 3
98814: NEG
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: EMPTY
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98867: LD_ADDR_VAR 0 30
98871: PUSH
98872: LD_INT 4
98874: PUSH
98875: LD_INT 4
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: LD_INT 4
98884: PUSH
98885: LD_INT 3
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 5
98894: PUSH
98895: LD_INT 4
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: LD_INT 5
98904: PUSH
98905: LD_INT 5
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: PUSH
98912: LD_INT 4
98914: PUSH
98915: LD_INT 5
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: LD_INT 3
98924: PUSH
98925: LD_INT 4
98927: PUSH
98928: EMPTY
98929: LIST
98930: LIST
98931: PUSH
98932: LD_INT 3
98934: PUSH
98935: LD_INT 3
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: PUSH
98942: LD_INT 5
98944: PUSH
98945: LD_INT 3
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: PUSH
98952: LD_INT 3
98954: PUSH
98955: LD_INT 5
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 0
98964: PUSH
98965: LD_INT 3
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: LD_INT 0
98974: PUSH
98975: LD_INT 2
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 1
98984: PUSH
98985: LD_INT 3
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: PUSH
98992: LD_INT 1
98994: PUSH
98995: LD_INT 4
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 0
99004: PUSH
99005: LD_INT 4
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: PUSH
99012: LD_INT 1
99014: NEG
99015: PUSH
99016: LD_INT 3
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: PUSH
99023: LD_INT 1
99025: NEG
99026: PUSH
99027: LD_INT 2
99029: PUSH
99030: EMPTY
99031: LIST
99032: LIST
99033: PUSH
99034: LD_INT 2
99036: PUSH
99037: LD_INT 4
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PUSH
99044: LD_INT 2
99046: NEG
99047: PUSH
99048: LD_INT 2
99050: PUSH
99051: EMPTY
99052: LIST
99053: LIST
99054: PUSH
99055: LD_INT 4
99057: NEG
99058: PUSH
99059: LD_INT 0
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 4
99068: NEG
99069: PUSH
99070: LD_INT 1
99072: NEG
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: PUSH
99078: LD_INT 3
99080: NEG
99081: PUSH
99082: LD_INT 0
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 3
99091: NEG
99092: PUSH
99093: LD_INT 1
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: LD_INT 4
99102: NEG
99103: PUSH
99104: LD_INT 1
99106: PUSH
99107: EMPTY
99108: LIST
99109: LIST
99110: PUSH
99111: LD_INT 5
99113: NEG
99114: PUSH
99115: LD_INT 0
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: PUSH
99122: LD_INT 5
99124: NEG
99125: PUSH
99126: LD_INT 1
99128: NEG
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: LD_INT 5
99136: NEG
99137: PUSH
99138: LD_INT 2
99140: NEG
99141: PUSH
99142: EMPTY
99143: LIST
99144: LIST
99145: PUSH
99146: LD_INT 3
99148: NEG
99149: PUSH
99150: LD_INT 2
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PUSH
99157: LD_INT 3
99159: NEG
99160: PUSH
99161: LD_INT 3
99163: NEG
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: LD_INT 3
99171: NEG
99172: PUSH
99173: LD_INT 4
99175: NEG
99176: PUSH
99177: EMPTY
99178: LIST
99179: LIST
99180: PUSH
99181: LD_INT 2
99183: NEG
99184: PUSH
99185: LD_INT 3
99187: NEG
99188: PUSH
99189: EMPTY
99190: LIST
99191: LIST
99192: PUSH
99193: LD_INT 2
99195: NEG
99196: PUSH
99197: LD_INT 2
99199: NEG
99200: PUSH
99201: EMPTY
99202: LIST
99203: LIST
99204: PUSH
99205: LD_INT 3
99207: NEG
99208: PUSH
99209: LD_INT 2
99211: NEG
99212: PUSH
99213: EMPTY
99214: LIST
99215: LIST
99216: PUSH
99217: LD_INT 4
99219: NEG
99220: PUSH
99221: LD_INT 3
99223: NEG
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 4
99231: NEG
99232: PUSH
99233: LD_INT 4
99235: NEG
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: LD_INT 2
99243: NEG
99244: PUSH
99245: LD_INT 4
99247: NEG
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: LD_INT 4
99255: NEG
99256: PUSH
99257: LD_INT 2
99259: NEG
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PUSH
99265: LD_INT 0
99267: PUSH
99268: LD_INT 4
99270: NEG
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: PUSH
99276: LD_INT 0
99278: PUSH
99279: LD_INT 5
99281: NEG
99282: PUSH
99283: EMPTY
99284: LIST
99285: LIST
99286: PUSH
99287: LD_INT 1
99289: PUSH
99290: LD_INT 4
99292: NEG
99293: PUSH
99294: EMPTY
99295: LIST
99296: LIST
99297: PUSH
99298: LD_INT 1
99300: PUSH
99301: LD_INT 3
99303: NEG
99304: PUSH
99305: EMPTY
99306: LIST
99307: LIST
99308: PUSH
99309: LD_INT 0
99311: PUSH
99312: LD_INT 3
99314: NEG
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 1
99322: NEG
99323: PUSH
99324: LD_INT 4
99326: NEG
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: LD_INT 1
99334: NEG
99335: PUSH
99336: LD_INT 5
99338: NEG
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 2
99346: PUSH
99347: LD_INT 3
99349: NEG
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PUSH
99355: LD_INT 2
99357: NEG
99358: PUSH
99359: LD_INT 5
99361: NEG
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: EMPTY
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99414: LD_ADDR_VAR 0 31
99418: PUSH
99419: LD_INT 0
99421: PUSH
99422: LD_INT 4
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: PUSH
99429: LD_INT 0
99431: PUSH
99432: LD_INT 3
99434: PUSH
99435: EMPTY
99436: LIST
99437: LIST
99438: PUSH
99439: LD_INT 1
99441: PUSH
99442: LD_INT 4
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: PUSH
99449: LD_INT 1
99451: PUSH
99452: LD_INT 5
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: PUSH
99459: LD_INT 0
99461: PUSH
99462: LD_INT 5
99464: PUSH
99465: EMPTY
99466: LIST
99467: LIST
99468: PUSH
99469: LD_INT 1
99471: NEG
99472: PUSH
99473: LD_INT 4
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PUSH
99480: LD_INT 1
99482: NEG
99483: PUSH
99484: LD_INT 3
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: LD_INT 2
99493: PUSH
99494: LD_INT 5
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: LD_INT 2
99503: NEG
99504: PUSH
99505: LD_INT 3
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: PUSH
99512: LD_INT 3
99514: NEG
99515: PUSH
99516: LD_INT 0
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: PUSH
99523: LD_INT 3
99525: NEG
99526: PUSH
99527: LD_INT 1
99529: NEG
99530: PUSH
99531: EMPTY
99532: LIST
99533: LIST
99534: PUSH
99535: LD_INT 2
99537: NEG
99538: PUSH
99539: LD_INT 0
99541: PUSH
99542: EMPTY
99543: LIST
99544: LIST
99545: PUSH
99546: LD_INT 2
99548: NEG
99549: PUSH
99550: LD_INT 1
99552: PUSH
99553: EMPTY
99554: LIST
99555: LIST
99556: PUSH
99557: LD_INT 3
99559: NEG
99560: PUSH
99561: LD_INT 1
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: PUSH
99568: LD_INT 4
99570: NEG
99571: PUSH
99572: LD_INT 0
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: PUSH
99579: LD_INT 4
99581: NEG
99582: PUSH
99583: LD_INT 1
99585: NEG
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 4
99593: NEG
99594: PUSH
99595: LD_INT 2
99597: NEG
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: PUSH
99603: LD_INT 2
99605: NEG
99606: PUSH
99607: LD_INT 2
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: PUSH
99614: LD_INT 4
99616: NEG
99617: PUSH
99618: LD_INT 4
99620: NEG
99621: PUSH
99622: EMPTY
99623: LIST
99624: LIST
99625: PUSH
99626: LD_INT 4
99628: NEG
99629: PUSH
99630: LD_INT 5
99632: NEG
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: PUSH
99638: LD_INT 3
99640: NEG
99641: PUSH
99642: LD_INT 4
99644: NEG
99645: PUSH
99646: EMPTY
99647: LIST
99648: LIST
99649: PUSH
99650: LD_INT 3
99652: NEG
99653: PUSH
99654: LD_INT 3
99656: NEG
99657: PUSH
99658: EMPTY
99659: LIST
99660: LIST
99661: PUSH
99662: LD_INT 4
99664: NEG
99665: PUSH
99666: LD_INT 3
99668: NEG
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PUSH
99674: LD_INT 5
99676: NEG
99677: PUSH
99678: LD_INT 4
99680: NEG
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PUSH
99686: LD_INT 5
99688: NEG
99689: PUSH
99690: LD_INT 5
99692: NEG
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PUSH
99698: LD_INT 3
99700: NEG
99701: PUSH
99702: LD_INT 5
99704: NEG
99705: PUSH
99706: EMPTY
99707: LIST
99708: LIST
99709: PUSH
99710: LD_INT 5
99712: NEG
99713: PUSH
99714: LD_INT 3
99716: NEG
99717: PUSH
99718: EMPTY
99719: LIST
99720: LIST
99721: PUSH
99722: LD_INT 0
99724: PUSH
99725: LD_INT 3
99727: NEG
99728: PUSH
99729: EMPTY
99730: LIST
99731: LIST
99732: PUSH
99733: LD_INT 0
99735: PUSH
99736: LD_INT 4
99738: NEG
99739: PUSH
99740: EMPTY
99741: LIST
99742: LIST
99743: PUSH
99744: LD_INT 1
99746: PUSH
99747: LD_INT 3
99749: NEG
99750: PUSH
99751: EMPTY
99752: LIST
99753: LIST
99754: PUSH
99755: LD_INT 1
99757: PUSH
99758: LD_INT 2
99760: NEG
99761: PUSH
99762: EMPTY
99763: LIST
99764: LIST
99765: PUSH
99766: LD_INT 0
99768: PUSH
99769: LD_INT 2
99771: NEG
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: PUSH
99777: LD_INT 1
99779: NEG
99780: PUSH
99781: LD_INT 3
99783: NEG
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 1
99791: NEG
99792: PUSH
99793: LD_INT 4
99795: NEG
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PUSH
99801: LD_INT 2
99803: PUSH
99804: LD_INT 2
99806: NEG
99807: PUSH
99808: EMPTY
99809: LIST
99810: LIST
99811: PUSH
99812: LD_INT 2
99814: NEG
99815: PUSH
99816: LD_INT 4
99818: NEG
99819: PUSH
99820: EMPTY
99821: LIST
99822: LIST
99823: PUSH
99824: LD_INT 4
99826: PUSH
99827: LD_INT 0
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PUSH
99834: LD_INT 4
99836: PUSH
99837: LD_INT 1
99839: NEG
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PUSH
99845: LD_INT 5
99847: PUSH
99848: LD_INT 0
99850: PUSH
99851: EMPTY
99852: LIST
99853: LIST
99854: PUSH
99855: LD_INT 5
99857: PUSH
99858: LD_INT 1
99860: PUSH
99861: EMPTY
99862: LIST
99863: LIST
99864: PUSH
99865: LD_INT 4
99867: PUSH
99868: LD_INT 1
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: PUSH
99875: LD_INT 3
99877: PUSH
99878: LD_INT 0
99880: PUSH
99881: EMPTY
99882: LIST
99883: LIST
99884: PUSH
99885: LD_INT 3
99887: PUSH
99888: LD_INT 1
99890: NEG
99891: PUSH
99892: EMPTY
99893: LIST
99894: LIST
99895: PUSH
99896: LD_INT 3
99898: PUSH
99899: LD_INT 2
99901: NEG
99902: PUSH
99903: EMPTY
99904: LIST
99905: LIST
99906: PUSH
99907: LD_INT 5
99909: PUSH
99910: LD_INT 2
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: PUSH
99917: EMPTY
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
99964: LD_ADDR_VAR 0 32
99968: PUSH
99969: LD_INT 4
99971: NEG
99972: PUSH
99973: LD_INT 0
99975: PUSH
99976: EMPTY
99977: LIST
99978: LIST
99979: PUSH
99980: LD_INT 4
99982: NEG
99983: PUSH
99984: LD_INT 1
99986: NEG
99987: PUSH
99988: EMPTY
99989: LIST
99990: LIST
99991: PUSH
99992: LD_INT 3
99994: NEG
99995: PUSH
99996: LD_INT 0
99998: PUSH
99999: EMPTY
100000: LIST
100001: LIST
100002: PUSH
100003: LD_INT 3
100005: NEG
100006: PUSH
100007: LD_INT 1
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: PUSH
100014: LD_INT 4
100016: NEG
100017: PUSH
100018: LD_INT 1
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: LD_INT 5
100027: NEG
100028: PUSH
100029: LD_INT 0
100031: PUSH
100032: EMPTY
100033: LIST
100034: LIST
100035: PUSH
100036: LD_INT 5
100038: NEG
100039: PUSH
100040: LD_INT 1
100042: NEG
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: PUSH
100048: LD_INT 5
100050: NEG
100051: PUSH
100052: LD_INT 2
100054: NEG
100055: PUSH
100056: EMPTY
100057: LIST
100058: LIST
100059: PUSH
100060: LD_INT 3
100062: NEG
100063: PUSH
100064: LD_INT 2
100066: PUSH
100067: EMPTY
100068: LIST
100069: LIST
100070: PUSH
100071: LD_INT 3
100073: NEG
100074: PUSH
100075: LD_INT 3
100077: NEG
100078: PUSH
100079: EMPTY
100080: LIST
100081: LIST
100082: PUSH
100083: LD_INT 3
100085: NEG
100086: PUSH
100087: LD_INT 4
100089: NEG
100090: PUSH
100091: EMPTY
100092: LIST
100093: LIST
100094: PUSH
100095: LD_INT 2
100097: NEG
100098: PUSH
100099: LD_INT 3
100101: NEG
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PUSH
100107: LD_INT 2
100109: NEG
100110: PUSH
100111: LD_INT 2
100113: NEG
100114: PUSH
100115: EMPTY
100116: LIST
100117: LIST
100118: PUSH
100119: LD_INT 3
100121: NEG
100122: PUSH
100123: LD_INT 2
100125: NEG
100126: PUSH
100127: EMPTY
100128: LIST
100129: LIST
100130: PUSH
100131: LD_INT 4
100133: NEG
100134: PUSH
100135: LD_INT 3
100137: NEG
100138: PUSH
100139: EMPTY
100140: LIST
100141: LIST
100142: PUSH
100143: LD_INT 4
100145: NEG
100146: PUSH
100147: LD_INT 4
100149: NEG
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PUSH
100155: LD_INT 2
100157: NEG
100158: PUSH
100159: LD_INT 4
100161: NEG
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: PUSH
100167: LD_INT 4
100169: NEG
100170: PUSH
100171: LD_INT 2
100173: NEG
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: PUSH
100179: LD_INT 0
100181: PUSH
100182: LD_INT 4
100184: NEG
100185: PUSH
100186: EMPTY
100187: LIST
100188: LIST
100189: PUSH
100190: LD_INT 0
100192: PUSH
100193: LD_INT 5
100195: NEG
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: LD_INT 1
100203: PUSH
100204: LD_INT 4
100206: NEG
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PUSH
100212: LD_INT 1
100214: PUSH
100215: LD_INT 3
100217: NEG
100218: PUSH
100219: EMPTY
100220: LIST
100221: LIST
100222: PUSH
100223: LD_INT 0
100225: PUSH
100226: LD_INT 3
100228: NEG
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: PUSH
100234: LD_INT 1
100236: NEG
100237: PUSH
100238: LD_INT 4
100240: NEG
100241: PUSH
100242: EMPTY
100243: LIST
100244: LIST
100245: PUSH
100246: LD_INT 1
100248: NEG
100249: PUSH
100250: LD_INT 5
100252: NEG
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 2
100260: PUSH
100261: LD_INT 3
100263: NEG
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: LD_INT 2
100271: NEG
100272: PUSH
100273: LD_INT 5
100275: NEG
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PUSH
100281: LD_INT 3
100283: PUSH
100284: LD_INT 0
100286: PUSH
100287: EMPTY
100288: LIST
100289: LIST
100290: PUSH
100291: LD_INT 3
100293: PUSH
100294: LD_INT 1
100296: NEG
100297: PUSH
100298: EMPTY
100299: LIST
100300: LIST
100301: PUSH
100302: LD_INT 4
100304: PUSH
100305: LD_INT 0
100307: PUSH
100308: EMPTY
100309: LIST
100310: LIST
100311: PUSH
100312: LD_INT 4
100314: PUSH
100315: LD_INT 1
100317: PUSH
100318: EMPTY
100319: LIST
100320: LIST
100321: PUSH
100322: LD_INT 3
100324: PUSH
100325: LD_INT 1
100327: PUSH
100328: EMPTY
100329: LIST
100330: LIST
100331: PUSH
100332: LD_INT 2
100334: PUSH
100335: LD_INT 0
100337: PUSH
100338: EMPTY
100339: LIST
100340: LIST
100341: PUSH
100342: LD_INT 2
100344: PUSH
100345: LD_INT 1
100347: NEG
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PUSH
100353: LD_INT 2
100355: PUSH
100356: LD_INT 2
100358: NEG
100359: PUSH
100360: EMPTY
100361: LIST
100362: LIST
100363: PUSH
100364: LD_INT 4
100366: PUSH
100367: LD_INT 2
100369: PUSH
100370: EMPTY
100371: LIST
100372: LIST
100373: PUSH
100374: LD_INT 4
100376: PUSH
100377: LD_INT 4
100379: PUSH
100380: EMPTY
100381: LIST
100382: LIST
100383: PUSH
100384: LD_INT 4
100386: PUSH
100387: LD_INT 3
100389: PUSH
100390: EMPTY
100391: LIST
100392: LIST
100393: PUSH
100394: LD_INT 5
100396: PUSH
100397: LD_INT 4
100399: PUSH
100400: EMPTY
100401: LIST
100402: LIST
100403: PUSH
100404: LD_INT 5
100406: PUSH
100407: LD_INT 5
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: PUSH
100414: LD_INT 4
100416: PUSH
100417: LD_INT 5
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: LD_INT 3
100426: PUSH
100427: LD_INT 4
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: PUSH
100434: LD_INT 3
100436: PUSH
100437: LD_INT 3
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: LD_INT 5
100446: PUSH
100447: LD_INT 3
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: PUSH
100454: LD_INT 3
100456: PUSH
100457: LD_INT 5
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100511: LD_ADDR_VAR 0 33
100515: PUSH
100516: LD_INT 4
100518: NEG
100519: PUSH
100520: LD_INT 4
100522: NEG
100523: PUSH
100524: EMPTY
100525: LIST
100526: LIST
100527: PUSH
100528: LD_INT 4
100530: NEG
100531: PUSH
100532: LD_INT 5
100534: NEG
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PUSH
100540: LD_INT 3
100542: NEG
100543: PUSH
100544: LD_INT 4
100546: NEG
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: LD_INT 3
100554: NEG
100555: PUSH
100556: LD_INT 3
100558: NEG
100559: PUSH
100560: EMPTY
100561: LIST
100562: LIST
100563: PUSH
100564: LD_INT 4
100566: NEG
100567: PUSH
100568: LD_INT 3
100570: NEG
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: PUSH
100576: LD_INT 5
100578: NEG
100579: PUSH
100580: LD_INT 4
100582: NEG
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 5
100590: NEG
100591: PUSH
100592: LD_INT 5
100594: NEG
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PUSH
100600: LD_INT 3
100602: NEG
100603: PUSH
100604: LD_INT 5
100606: NEG
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_INT 5
100614: NEG
100615: PUSH
100616: LD_INT 3
100618: NEG
100619: PUSH
100620: EMPTY
100621: LIST
100622: LIST
100623: PUSH
100624: LD_INT 0
100626: PUSH
100627: LD_INT 3
100629: NEG
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: PUSH
100635: LD_INT 0
100637: PUSH
100638: LD_INT 4
100640: NEG
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: PUSH
100646: LD_INT 1
100648: PUSH
100649: LD_INT 3
100651: NEG
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PUSH
100657: LD_INT 1
100659: PUSH
100660: LD_INT 2
100662: NEG
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: PUSH
100668: LD_INT 0
100670: PUSH
100671: LD_INT 2
100673: NEG
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: PUSH
100679: LD_INT 1
100681: NEG
100682: PUSH
100683: LD_INT 3
100685: NEG
100686: PUSH
100687: EMPTY
100688: LIST
100689: LIST
100690: PUSH
100691: LD_INT 1
100693: NEG
100694: PUSH
100695: LD_INT 4
100697: NEG
100698: PUSH
100699: EMPTY
100700: LIST
100701: LIST
100702: PUSH
100703: LD_INT 2
100705: PUSH
100706: LD_INT 2
100708: NEG
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PUSH
100714: LD_INT 2
100716: NEG
100717: PUSH
100718: LD_INT 4
100720: NEG
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PUSH
100726: LD_INT 4
100728: PUSH
100729: LD_INT 0
100731: PUSH
100732: EMPTY
100733: LIST
100734: LIST
100735: PUSH
100736: LD_INT 4
100738: PUSH
100739: LD_INT 1
100741: NEG
100742: PUSH
100743: EMPTY
100744: LIST
100745: LIST
100746: PUSH
100747: LD_INT 5
100749: PUSH
100750: LD_INT 0
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 5
100759: PUSH
100760: LD_INT 1
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: LD_INT 4
100769: PUSH
100770: LD_INT 1
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: PUSH
100777: LD_INT 3
100779: PUSH
100780: LD_INT 0
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PUSH
100787: LD_INT 3
100789: PUSH
100790: LD_INT 1
100792: NEG
100793: PUSH
100794: EMPTY
100795: LIST
100796: LIST
100797: PUSH
100798: LD_INT 3
100800: PUSH
100801: LD_INT 2
100803: NEG
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 5
100811: PUSH
100812: LD_INT 2
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 3
100821: PUSH
100822: LD_INT 3
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: PUSH
100829: LD_INT 3
100831: PUSH
100832: LD_INT 2
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: PUSH
100839: LD_INT 4
100841: PUSH
100842: LD_INT 3
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: PUSH
100849: LD_INT 4
100851: PUSH
100852: LD_INT 4
100854: PUSH
100855: EMPTY
100856: LIST
100857: LIST
100858: PUSH
100859: LD_INT 3
100861: PUSH
100862: LD_INT 4
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: PUSH
100869: LD_INT 2
100871: PUSH
100872: LD_INT 3
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PUSH
100879: LD_INT 2
100881: PUSH
100882: LD_INT 2
100884: PUSH
100885: EMPTY
100886: LIST
100887: LIST
100888: PUSH
100889: LD_INT 4
100891: PUSH
100892: LD_INT 2
100894: PUSH
100895: EMPTY
100896: LIST
100897: LIST
100898: PUSH
100899: LD_INT 2
100901: PUSH
100902: LD_INT 4
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: PUSH
100909: LD_INT 0
100911: PUSH
100912: LD_INT 4
100914: PUSH
100915: EMPTY
100916: LIST
100917: LIST
100918: PUSH
100919: LD_INT 0
100921: PUSH
100922: LD_INT 3
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PUSH
100929: LD_INT 1
100931: PUSH
100932: LD_INT 4
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: PUSH
100939: LD_INT 1
100941: PUSH
100942: LD_INT 5
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: PUSH
100949: LD_INT 0
100951: PUSH
100952: LD_INT 5
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PUSH
100959: LD_INT 1
100961: NEG
100962: PUSH
100963: LD_INT 4
100965: PUSH
100966: EMPTY
100967: LIST
100968: LIST
100969: PUSH
100970: LD_INT 1
100972: NEG
100973: PUSH
100974: LD_INT 3
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: PUSH
100981: LD_INT 2
100983: PUSH
100984: LD_INT 5
100986: PUSH
100987: EMPTY
100988: LIST
100989: LIST
100990: PUSH
100991: LD_INT 2
100993: NEG
100994: PUSH
100995: LD_INT 3
100997: PUSH
100998: EMPTY
100999: LIST
101000: LIST
101001: PUSH
101002: EMPTY
101003: LIST
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: LIST
101032: LIST
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: LIST
101047: LIST
101048: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101049: LD_ADDR_VAR 0 34
101053: PUSH
101054: LD_INT 0
101056: PUSH
101057: LD_INT 4
101059: NEG
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: PUSH
101065: LD_INT 0
101067: PUSH
101068: LD_INT 5
101070: NEG
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PUSH
101076: LD_INT 1
101078: PUSH
101079: LD_INT 4
101081: NEG
101082: PUSH
101083: EMPTY
101084: LIST
101085: LIST
101086: PUSH
101087: LD_INT 1
101089: PUSH
101090: LD_INT 3
101092: NEG
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PUSH
101098: LD_INT 0
101100: PUSH
101101: LD_INT 3
101103: NEG
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: PUSH
101109: LD_INT 1
101111: NEG
101112: PUSH
101113: LD_INT 4
101115: NEG
101116: PUSH
101117: EMPTY
101118: LIST
101119: LIST
101120: PUSH
101121: LD_INT 1
101123: NEG
101124: PUSH
101125: LD_INT 5
101127: NEG
101128: PUSH
101129: EMPTY
101130: LIST
101131: LIST
101132: PUSH
101133: LD_INT 2
101135: PUSH
101136: LD_INT 3
101138: NEG
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 2
101146: NEG
101147: PUSH
101148: LD_INT 5
101150: NEG
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PUSH
101156: LD_INT 3
101158: PUSH
101159: LD_INT 0
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PUSH
101166: LD_INT 3
101168: PUSH
101169: LD_INT 1
101171: NEG
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: PUSH
101177: LD_INT 4
101179: PUSH
101180: LD_INT 0
101182: PUSH
101183: EMPTY
101184: LIST
101185: LIST
101186: PUSH
101187: LD_INT 4
101189: PUSH
101190: LD_INT 1
101192: PUSH
101193: EMPTY
101194: LIST
101195: LIST
101196: PUSH
101197: LD_INT 3
101199: PUSH
101200: LD_INT 1
101202: PUSH
101203: EMPTY
101204: LIST
101205: LIST
101206: PUSH
101207: LD_INT 2
101209: PUSH
101210: LD_INT 0
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: PUSH
101217: LD_INT 2
101219: PUSH
101220: LD_INT 1
101222: NEG
101223: PUSH
101224: EMPTY
101225: LIST
101226: LIST
101227: PUSH
101228: LD_INT 2
101230: PUSH
101231: LD_INT 2
101233: NEG
101234: PUSH
101235: EMPTY
101236: LIST
101237: LIST
101238: PUSH
101239: LD_INT 4
101241: PUSH
101242: LD_INT 2
101244: PUSH
101245: EMPTY
101246: LIST
101247: LIST
101248: PUSH
101249: LD_INT 4
101251: PUSH
101252: LD_INT 4
101254: PUSH
101255: EMPTY
101256: LIST
101257: LIST
101258: PUSH
101259: LD_INT 4
101261: PUSH
101262: LD_INT 3
101264: PUSH
101265: EMPTY
101266: LIST
101267: LIST
101268: PUSH
101269: LD_INT 5
101271: PUSH
101272: LD_INT 4
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: PUSH
101279: LD_INT 5
101281: PUSH
101282: LD_INT 5
101284: PUSH
101285: EMPTY
101286: LIST
101287: LIST
101288: PUSH
101289: LD_INT 4
101291: PUSH
101292: LD_INT 5
101294: PUSH
101295: EMPTY
101296: LIST
101297: LIST
101298: PUSH
101299: LD_INT 3
101301: PUSH
101302: LD_INT 4
101304: PUSH
101305: EMPTY
101306: LIST
101307: LIST
101308: PUSH
101309: LD_INT 3
101311: PUSH
101312: LD_INT 3
101314: PUSH
101315: EMPTY
101316: LIST
101317: LIST
101318: PUSH
101319: LD_INT 5
101321: PUSH
101322: LD_INT 3
101324: PUSH
101325: EMPTY
101326: LIST
101327: LIST
101328: PUSH
101329: LD_INT 3
101331: PUSH
101332: LD_INT 5
101334: PUSH
101335: EMPTY
101336: LIST
101337: LIST
101338: PUSH
101339: LD_INT 0
101341: PUSH
101342: LD_INT 3
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PUSH
101349: LD_INT 0
101351: PUSH
101352: LD_INT 2
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: PUSH
101359: LD_INT 1
101361: PUSH
101362: LD_INT 3
101364: PUSH
101365: EMPTY
101366: LIST
101367: LIST
101368: PUSH
101369: LD_INT 1
101371: PUSH
101372: LD_INT 4
101374: PUSH
101375: EMPTY
101376: LIST
101377: LIST
101378: PUSH
101379: LD_INT 0
101381: PUSH
101382: LD_INT 4
101384: PUSH
101385: EMPTY
101386: LIST
101387: LIST
101388: PUSH
101389: LD_INT 1
101391: NEG
101392: PUSH
101393: LD_INT 3
101395: PUSH
101396: EMPTY
101397: LIST
101398: LIST
101399: PUSH
101400: LD_INT 1
101402: NEG
101403: PUSH
101404: LD_INT 2
101406: PUSH
101407: EMPTY
101408: LIST
101409: LIST
101410: PUSH
101411: LD_INT 2
101413: PUSH
101414: LD_INT 4
101416: PUSH
101417: EMPTY
101418: LIST
101419: LIST
101420: PUSH
101421: LD_INT 2
101423: NEG
101424: PUSH
101425: LD_INT 2
101427: PUSH
101428: EMPTY
101429: LIST
101430: LIST
101431: PUSH
101432: LD_INT 4
101434: NEG
101435: PUSH
101436: LD_INT 0
101438: PUSH
101439: EMPTY
101440: LIST
101441: LIST
101442: PUSH
101443: LD_INT 4
101445: NEG
101446: PUSH
101447: LD_INT 1
101449: NEG
101450: PUSH
101451: EMPTY
101452: LIST
101453: LIST
101454: PUSH
101455: LD_INT 3
101457: NEG
101458: PUSH
101459: LD_INT 0
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: PUSH
101466: LD_INT 3
101468: NEG
101469: PUSH
101470: LD_INT 1
101472: PUSH
101473: EMPTY
101474: LIST
101475: LIST
101476: PUSH
101477: LD_INT 4
101479: NEG
101480: PUSH
101481: LD_INT 1
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: PUSH
101488: LD_INT 5
101490: NEG
101491: PUSH
101492: LD_INT 0
101494: PUSH
101495: EMPTY
101496: LIST
101497: LIST
101498: PUSH
101499: LD_INT 5
101501: NEG
101502: PUSH
101503: LD_INT 1
101505: NEG
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PUSH
101511: LD_INT 5
101513: NEG
101514: PUSH
101515: LD_INT 2
101517: NEG
101518: PUSH
101519: EMPTY
101520: LIST
101521: LIST
101522: PUSH
101523: LD_INT 3
101525: NEG
101526: PUSH
101527: LD_INT 2
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: LIST
101547: LIST
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: LIST
101564: LIST
101565: LIST
101566: LIST
101567: LIST
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: LIST
101578: LIST
101579: LIST
101580: ST_TO_ADDR
// end ; end ;
101581: GO 101584
101583: POP
// case btype of b_depot , b_warehouse :
101584: LD_VAR 0 1
101588: PUSH
101589: LD_INT 0
101591: DOUBLE
101592: EQUAL
101593: IFTRUE 101603
101595: LD_INT 1
101597: DOUBLE
101598: EQUAL
101599: IFTRUE 101603
101601: GO 101804
101603: POP
// case nation of nation_american :
101604: LD_VAR 0 5
101608: PUSH
101609: LD_INT 1
101611: DOUBLE
101612: EQUAL
101613: IFTRUE 101617
101615: GO 101673
101617: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101618: LD_ADDR_VAR 0 9
101622: PUSH
101623: LD_VAR 0 11
101627: PUSH
101628: LD_VAR 0 12
101632: PUSH
101633: LD_VAR 0 13
101637: PUSH
101638: LD_VAR 0 14
101642: PUSH
101643: LD_VAR 0 15
101647: PUSH
101648: LD_VAR 0 16
101652: PUSH
101653: EMPTY
101654: LIST
101655: LIST
101656: LIST
101657: LIST
101658: LIST
101659: LIST
101660: PUSH
101661: LD_VAR 0 4
101665: PUSH
101666: LD_INT 1
101668: PLUS
101669: ARRAY
101670: ST_TO_ADDR
101671: GO 101802
101673: LD_INT 2
101675: DOUBLE
101676: EQUAL
101677: IFTRUE 101681
101679: GO 101737
101681: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101682: LD_ADDR_VAR 0 9
101686: PUSH
101687: LD_VAR 0 17
101691: PUSH
101692: LD_VAR 0 18
101696: PUSH
101697: LD_VAR 0 19
101701: PUSH
101702: LD_VAR 0 20
101706: PUSH
101707: LD_VAR 0 21
101711: PUSH
101712: LD_VAR 0 22
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: PUSH
101725: LD_VAR 0 4
101729: PUSH
101730: LD_INT 1
101732: PLUS
101733: ARRAY
101734: ST_TO_ADDR
101735: GO 101802
101737: LD_INT 3
101739: DOUBLE
101740: EQUAL
101741: IFTRUE 101745
101743: GO 101801
101745: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101746: LD_ADDR_VAR 0 9
101750: PUSH
101751: LD_VAR 0 23
101755: PUSH
101756: LD_VAR 0 24
101760: PUSH
101761: LD_VAR 0 25
101765: PUSH
101766: LD_VAR 0 26
101770: PUSH
101771: LD_VAR 0 27
101775: PUSH
101776: LD_VAR 0 28
101780: PUSH
101781: EMPTY
101782: LIST
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: PUSH
101789: LD_VAR 0 4
101793: PUSH
101794: LD_INT 1
101796: PLUS
101797: ARRAY
101798: ST_TO_ADDR
101799: GO 101802
101801: POP
101802: GO 102357
101804: LD_INT 2
101806: DOUBLE
101807: EQUAL
101808: IFTRUE 101818
101810: LD_INT 3
101812: DOUBLE
101813: EQUAL
101814: IFTRUE 101818
101816: GO 101874
101818: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101819: LD_ADDR_VAR 0 9
101823: PUSH
101824: LD_VAR 0 29
101828: PUSH
101829: LD_VAR 0 30
101833: PUSH
101834: LD_VAR 0 31
101838: PUSH
101839: LD_VAR 0 32
101843: PUSH
101844: LD_VAR 0 33
101848: PUSH
101849: LD_VAR 0 34
101853: PUSH
101854: EMPTY
101855: LIST
101856: LIST
101857: LIST
101858: LIST
101859: LIST
101860: LIST
101861: PUSH
101862: LD_VAR 0 4
101866: PUSH
101867: LD_INT 1
101869: PLUS
101870: ARRAY
101871: ST_TO_ADDR
101872: GO 102357
101874: LD_INT 16
101876: DOUBLE
101877: EQUAL
101878: IFTRUE 101936
101880: LD_INT 17
101882: DOUBLE
101883: EQUAL
101884: IFTRUE 101936
101886: LD_INT 18
101888: DOUBLE
101889: EQUAL
101890: IFTRUE 101936
101892: LD_INT 19
101894: DOUBLE
101895: EQUAL
101896: IFTRUE 101936
101898: LD_INT 22
101900: DOUBLE
101901: EQUAL
101902: IFTRUE 101936
101904: LD_INT 20
101906: DOUBLE
101907: EQUAL
101908: IFTRUE 101936
101910: LD_INT 21
101912: DOUBLE
101913: EQUAL
101914: IFTRUE 101936
101916: LD_INT 23
101918: DOUBLE
101919: EQUAL
101920: IFTRUE 101936
101922: LD_INT 24
101924: DOUBLE
101925: EQUAL
101926: IFTRUE 101936
101928: LD_INT 25
101930: DOUBLE
101931: EQUAL
101932: IFTRUE 101936
101934: GO 101992
101936: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
101937: LD_ADDR_VAR 0 9
101941: PUSH
101942: LD_VAR 0 35
101946: PUSH
101947: LD_VAR 0 36
101951: PUSH
101952: LD_VAR 0 37
101956: PUSH
101957: LD_VAR 0 38
101961: PUSH
101962: LD_VAR 0 39
101966: PUSH
101967: LD_VAR 0 40
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: PUSH
101980: LD_VAR 0 4
101984: PUSH
101985: LD_INT 1
101987: PLUS
101988: ARRAY
101989: ST_TO_ADDR
101990: GO 102357
101992: LD_INT 6
101994: DOUBLE
101995: EQUAL
101996: IFTRUE 102048
101998: LD_INT 7
102000: DOUBLE
102001: EQUAL
102002: IFTRUE 102048
102004: LD_INT 8
102006: DOUBLE
102007: EQUAL
102008: IFTRUE 102048
102010: LD_INT 13
102012: DOUBLE
102013: EQUAL
102014: IFTRUE 102048
102016: LD_INT 12
102018: DOUBLE
102019: EQUAL
102020: IFTRUE 102048
102022: LD_INT 15
102024: DOUBLE
102025: EQUAL
102026: IFTRUE 102048
102028: LD_INT 11
102030: DOUBLE
102031: EQUAL
102032: IFTRUE 102048
102034: LD_INT 14
102036: DOUBLE
102037: EQUAL
102038: IFTRUE 102048
102040: LD_INT 10
102042: DOUBLE
102043: EQUAL
102044: IFTRUE 102048
102046: GO 102104
102048: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102049: LD_ADDR_VAR 0 9
102053: PUSH
102054: LD_VAR 0 41
102058: PUSH
102059: LD_VAR 0 42
102063: PUSH
102064: LD_VAR 0 43
102068: PUSH
102069: LD_VAR 0 44
102073: PUSH
102074: LD_VAR 0 45
102078: PUSH
102079: LD_VAR 0 46
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: LIST
102091: PUSH
102092: LD_VAR 0 4
102096: PUSH
102097: LD_INT 1
102099: PLUS
102100: ARRAY
102101: ST_TO_ADDR
102102: GO 102357
102104: LD_INT 36
102106: DOUBLE
102107: EQUAL
102108: IFTRUE 102112
102110: GO 102168
102112: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102113: LD_ADDR_VAR 0 9
102117: PUSH
102118: LD_VAR 0 47
102122: PUSH
102123: LD_VAR 0 48
102127: PUSH
102128: LD_VAR 0 49
102132: PUSH
102133: LD_VAR 0 50
102137: PUSH
102138: LD_VAR 0 51
102142: PUSH
102143: LD_VAR 0 52
102147: PUSH
102148: EMPTY
102149: LIST
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: LIST
102155: PUSH
102156: LD_VAR 0 4
102160: PUSH
102161: LD_INT 1
102163: PLUS
102164: ARRAY
102165: ST_TO_ADDR
102166: GO 102357
102168: LD_INT 4
102170: DOUBLE
102171: EQUAL
102172: IFTRUE 102194
102174: LD_INT 5
102176: DOUBLE
102177: EQUAL
102178: IFTRUE 102194
102180: LD_INT 34
102182: DOUBLE
102183: EQUAL
102184: IFTRUE 102194
102186: LD_INT 37
102188: DOUBLE
102189: EQUAL
102190: IFTRUE 102194
102192: GO 102250
102194: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102195: LD_ADDR_VAR 0 9
102199: PUSH
102200: LD_VAR 0 53
102204: PUSH
102205: LD_VAR 0 54
102209: PUSH
102210: LD_VAR 0 55
102214: PUSH
102215: LD_VAR 0 56
102219: PUSH
102220: LD_VAR 0 57
102224: PUSH
102225: LD_VAR 0 58
102229: PUSH
102230: EMPTY
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: PUSH
102238: LD_VAR 0 4
102242: PUSH
102243: LD_INT 1
102245: PLUS
102246: ARRAY
102247: ST_TO_ADDR
102248: GO 102357
102250: LD_INT 31
102252: DOUBLE
102253: EQUAL
102254: IFTRUE 102300
102256: LD_INT 32
102258: DOUBLE
102259: EQUAL
102260: IFTRUE 102300
102262: LD_INT 33
102264: DOUBLE
102265: EQUAL
102266: IFTRUE 102300
102268: LD_INT 27
102270: DOUBLE
102271: EQUAL
102272: IFTRUE 102300
102274: LD_INT 26
102276: DOUBLE
102277: EQUAL
102278: IFTRUE 102300
102280: LD_INT 28
102282: DOUBLE
102283: EQUAL
102284: IFTRUE 102300
102286: LD_INT 29
102288: DOUBLE
102289: EQUAL
102290: IFTRUE 102300
102292: LD_INT 30
102294: DOUBLE
102295: EQUAL
102296: IFTRUE 102300
102298: GO 102356
102300: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102301: LD_ADDR_VAR 0 9
102305: PUSH
102306: LD_VAR 0 59
102310: PUSH
102311: LD_VAR 0 60
102315: PUSH
102316: LD_VAR 0 61
102320: PUSH
102321: LD_VAR 0 62
102325: PUSH
102326: LD_VAR 0 63
102330: PUSH
102331: LD_VAR 0 64
102335: PUSH
102336: EMPTY
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: LIST
102342: LIST
102343: PUSH
102344: LD_VAR 0 4
102348: PUSH
102349: LD_INT 1
102351: PLUS
102352: ARRAY
102353: ST_TO_ADDR
102354: GO 102357
102356: POP
// temp_list2 = [ ] ;
102357: LD_ADDR_VAR 0 10
102361: PUSH
102362: EMPTY
102363: ST_TO_ADDR
// for i in temp_list do
102364: LD_ADDR_VAR 0 8
102368: PUSH
102369: LD_VAR 0 9
102373: PUSH
102374: FOR_IN
102375: IFFALSE 102427
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102377: LD_ADDR_VAR 0 10
102381: PUSH
102382: LD_VAR 0 10
102386: PUSH
102387: LD_VAR 0 8
102391: PUSH
102392: LD_INT 1
102394: ARRAY
102395: PUSH
102396: LD_VAR 0 2
102400: PLUS
102401: PUSH
102402: LD_VAR 0 8
102406: PUSH
102407: LD_INT 2
102409: ARRAY
102410: PUSH
102411: LD_VAR 0 3
102415: PLUS
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: PUSH
102421: EMPTY
102422: LIST
102423: ADD
102424: ST_TO_ADDR
102425: GO 102374
102427: POP
102428: POP
// result = temp_list2 ;
102429: LD_ADDR_VAR 0 7
102433: PUSH
102434: LD_VAR 0 10
102438: ST_TO_ADDR
// end ;
102439: LD_VAR 0 7
102443: RET
// export function EnemyInRange ( unit , dist ) ; begin
102444: LD_INT 0
102446: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102447: LD_ADDR_VAR 0 3
102451: PUSH
102452: LD_VAR 0 1
102456: PPUSH
102457: CALL_OW 255
102461: PPUSH
102462: LD_VAR 0 1
102466: PPUSH
102467: CALL_OW 250
102471: PPUSH
102472: LD_VAR 0 1
102476: PPUSH
102477: CALL_OW 251
102481: PPUSH
102482: LD_VAR 0 2
102486: PPUSH
102487: CALL 75817 0 4
102491: PUSH
102492: LD_INT 4
102494: ARRAY
102495: ST_TO_ADDR
// end ;
102496: LD_VAR 0 3
102500: RET
// export function PlayerSeeMe ( unit ) ; begin
102501: LD_INT 0
102503: PPUSH
// result := See ( your_side , unit ) ;
102504: LD_ADDR_VAR 0 2
102508: PUSH
102509: LD_OWVAR 2
102513: PPUSH
102514: LD_VAR 0 1
102518: PPUSH
102519: CALL_OW 292
102523: ST_TO_ADDR
// end ;
102524: LD_VAR 0 2
102528: RET
// export function ReverseDir ( unit ) ; begin
102529: LD_INT 0
102531: PPUSH
// if not unit then
102532: LD_VAR 0 1
102536: NOT
102537: IFFALSE 102541
// exit ;
102539: GO 102564
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102541: LD_ADDR_VAR 0 2
102545: PUSH
102546: LD_VAR 0 1
102550: PPUSH
102551: CALL_OW 254
102555: PUSH
102556: LD_INT 3
102558: PLUS
102559: PUSH
102560: LD_INT 6
102562: MOD
102563: ST_TO_ADDR
// end ;
102564: LD_VAR 0 2
102568: RET
// export function ReverseArray ( array ) ; var i ; begin
102569: LD_INT 0
102571: PPUSH
102572: PPUSH
// if not array then
102573: LD_VAR 0 1
102577: NOT
102578: IFFALSE 102582
// exit ;
102580: GO 102637
// result := [ ] ;
102582: LD_ADDR_VAR 0 2
102586: PUSH
102587: EMPTY
102588: ST_TO_ADDR
// for i := array downto 1 do
102589: LD_ADDR_VAR 0 3
102593: PUSH
102594: DOUBLE
102595: LD_VAR 0 1
102599: INC
102600: ST_TO_ADDR
102601: LD_INT 1
102603: PUSH
102604: FOR_DOWNTO
102605: IFFALSE 102635
// result := Join ( result , array [ i ] ) ;
102607: LD_ADDR_VAR 0 2
102611: PUSH
102612: LD_VAR 0 2
102616: PPUSH
102617: LD_VAR 0 1
102621: PUSH
102622: LD_VAR 0 3
102626: ARRAY
102627: PPUSH
102628: CALL 107282 0 2
102632: ST_TO_ADDR
102633: GO 102604
102635: POP
102636: POP
// end ;
102637: LD_VAR 0 2
102641: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102642: LD_INT 0
102644: PPUSH
102645: PPUSH
102646: PPUSH
102647: PPUSH
102648: PPUSH
102649: PPUSH
// if not unit or not hexes then
102650: LD_VAR 0 1
102654: NOT
102655: PUSH
102656: LD_VAR 0 2
102660: NOT
102661: OR
102662: IFFALSE 102666
// exit ;
102664: GO 102789
// dist := 9999 ;
102666: LD_ADDR_VAR 0 5
102670: PUSH
102671: LD_INT 9999
102673: ST_TO_ADDR
// for i = 1 to hexes do
102674: LD_ADDR_VAR 0 4
102678: PUSH
102679: DOUBLE
102680: LD_INT 1
102682: DEC
102683: ST_TO_ADDR
102684: LD_VAR 0 2
102688: PUSH
102689: FOR_TO
102690: IFFALSE 102777
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102692: LD_ADDR_VAR 0 6
102696: PUSH
102697: LD_VAR 0 1
102701: PPUSH
102702: LD_VAR 0 2
102706: PUSH
102707: LD_VAR 0 4
102711: ARRAY
102712: PUSH
102713: LD_INT 1
102715: ARRAY
102716: PPUSH
102717: LD_VAR 0 2
102721: PUSH
102722: LD_VAR 0 4
102726: ARRAY
102727: PUSH
102728: LD_INT 2
102730: ARRAY
102731: PPUSH
102732: CALL_OW 297
102736: ST_TO_ADDR
// if tdist < dist then
102737: LD_VAR 0 6
102741: PUSH
102742: LD_VAR 0 5
102746: LESS
102747: IFFALSE 102775
// begin hex := hexes [ i ] ;
102749: LD_ADDR_VAR 0 8
102753: PUSH
102754: LD_VAR 0 2
102758: PUSH
102759: LD_VAR 0 4
102763: ARRAY
102764: ST_TO_ADDR
// dist := tdist ;
102765: LD_ADDR_VAR 0 5
102769: PUSH
102770: LD_VAR 0 6
102774: ST_TO_ADDR
// end ; end ;
102775: GO 102689
102777: POP
102778: POP
// result := hex ;
102779: LD_ADDR_VAR 0 3
102783: PUSH
102784: LD_VAR 0 8
102788: ST_TO_ADDR
// end ;
102789: LD_VAR 0 3
102793: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102794: LD_INT 0
102796: PPUSH
102797: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102798: LD_VAR 0 1
102802: NOT
102803: PUSH
102804: LD_VAR 0 1
102808: PUSH
102809: LD_INT 21
102811: PUSH
102812: LD_INT 2
102814: PUSH
102815: EMPTY
102816: LIST
102817: LIST
102818: PUSH
102819: LD_INT 23
102821: PUSH
102822: LD_INT 2
102824: PUSH
102825: EMPTY
102826: LIST
102827: LIST
102828: PUSH
102829: EMPTY
102830: LIST
102831: LIST
102832: PPUSH
102833: CALL_OW 69
102837: IN
102838: NOT
102839: OR
102840: IFFALSE 102844
// exit ;
102842: GO 102891
// for i = 1 to 3 do
102844: LD_ADDR_VAR 0 3
102848: PUSH
102849: DOUBLE
102850: LD_INT 1
102852: DEC
102853: ST_TO_ADDR
102854: LD_INT 3
102856: PUSH
102857: FOR_TO
102858: IFFALSE 102889
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102860: LD_VAR 0 1
102864: PPUSH
102865: CALL_OW 250
102869: PPUSH
102870: LD_VAR 0 1
102874: PPUSH
102875: CALL_OW 251
102879: PPUSH
102880: LD_INT 1
102882: PPUSH
102883: CALL_OW 453
102887: GO 102857
102889: POP
102890: POP
// end ;
102891: LD_VAR 0 2
102895: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102896: LD_INT 0
102898: PPUSH
102899: PPUSH
102900: PPUSH
102901: PPUSH
102902: PPUSH
102903: PPUSH
// if not unit or not enemy_unit then
102904: LD_VAR 0 1
102908: NOT
102909: PUSH
102910: LD_VAR 0 2
102914: NOT
102915: OR
102916: IFFALSE 102920
// exit ;
102918: GO 103387
// if GetLives ( i ) < 250 then
102920: LD_VAR 0 4
102924: PPUSH
102925: CALL_OW 256
102929: PUSH
102930: LD_INT 250
102932: LESS
102933: IFFALSE 102946
// begin ComAutodestruct ( i ) ;
102935: LD_VAR 0 4
102939: PPUSH
102940: CALL 102794 0 1
// exit ;
102944: GO 103387
// end ; x := GetX ( enemy_unit ) ;
102946: LD_ADDR_VAR 0 7
102950: PUSH
102951: LD_VAR 0 2
102955: PPUSH
102956: CALL_OW 250
102960: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
102961: LD_ADDR_VAR 0 8
102965: PUSH
102966: LD_VAR 0 2
102970: PPUSH
102971: CALL_OW 251
102975: ST_TO_ADDR
// if not x or not y then
102976: LD_VAR 0 7
102980: NOT
102981: PUSH
102982: LD_VAR 0 8
102986: NOT
102987: OR
102988: IFFALSE 102992
// exit ;
102990: GO 103387
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
102992: LD_ADDR_VAR 0 6
102996: PUSH
102997: LD_VAR 0 7
103001: PPUSH
103002: LD_INT 0
103004: PPUSH
103005: LD_INT 4
103007: PPUSH
103008: CALL_OW 272
103012: PUSH
103013: LD_VAR 0 8
103017: PPUSH
103018: LD_INT 0
103020: PPUSH
103021: LD_INT 4
103023: PPUSH
103024: CALL_OW 273
103028: PUSH
103029: EMPTY
103030: LIST
103031: LIST
103032: PUSH
103033: LD_VAR 0 7
103037: PPUSH
103038: LD_INT 1
103040: PPUSH
103041: LD_INT 4
103043: PPUSH
103044: CALL_OW 272
103048: PUSH
103049: LD_VAR 0 8
103053: PPUSH
103054: LD_INT 1
103056: PPUSH
103057: LD_INT 4
103059: PPUSH
103060: CALL_OW 273
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: PUSH
103069: LD_VAR 0 7
103073: PPUSH
103074: LD_INT 2
103076: PPUSH
103077: LD_INT 4
103079: PPUSH
103080: CALL_OW 272
103084: PUSH
103085: LD_VAR 0 8
103089: PPUSH
103090: LD_INT 2
103092: PPUSH
103093: LD_INT 4
103095: PPUSH
103096: CALL_OW 273
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: PUSH
103105: LD_VAR 0 7
103109: PPUSH
103110: LD_INT 3
103112: PPUSH
103113: LD_INT 4
103115: PPUSH
103116: CALL_OW 272
103120: PUSH
103121: LD_VAR 0 8
103125: PPUSH
103126: LD_INT 3
103128: PPUSH
103129: LD_INT 4
103131: PPUSH
103132: CALL_OW 273
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: PUSH
103141: LD_VAR 0 7
103145: PPUSH
103146: LD_INT 4
103148: PPUSH
103149: LD_INT 4
103151: PPUSH
103152: CALL_OW 272
103156: PUSH
103157: LD_VAR 0 8
103161: PPUSH
103162: LD_INT 4
103164: PPUSH
103165: LD_INT 4
103167: PPUSH
103168: CALL_OW 273
103172: PUSH
103173: EMPTY
103174: LIST
103175: LIST
103176: PUSH
103177: LD_VAR 0 7
103181: PPUSH
103182: LD_INT 5
103184: PPUSH
103185: LD_INT 4
103187: PPUSH
103188: CALL_OW 272
103192: PUSH
103193: LD_VAR 0 8
103197: PPUSH
103198: LD_INT 5
103200: PPUSH
103201: LD_INT 4
103203: PPUSH
103204: CALL_OW 273
103208: PUSH
103209: EMPTY
103210: LIST
103211: LIST
103212: PUSH
103213: EMPTY
103214: LIST
103215: LIST
103216: LIST
103217: LIST
103218: LIST
103219: LIST
103220: ST_TO_ADDR
// for i = tmp downto 1 do
103221: LD_ADDR_VAR 0 4
103225: PUSH
103226: DOUBLE
103227: LD_VAR 0 6
103231: INC
103232: ST_TO_ADDR
103233: LD_INT 1
103235: PUSH
103236: FOR_DOWNTO
103237: IFFALSE 103338
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103239: LD_VAR 0 6
103243: PUSH
103244: LD_VAR 0 4
103248: ARRAY
103249: PUSH
103250: LD_INT 1
103252: ARRAY
103253: PPUSH
103254: LD_VAR 0 6
103258: PUSH
103259: LD_VAR 0 4
103263: ARRAY
103264: PUSH
103265: LD_INT 2
103267: ARRAY
103268: PPUSH
103269: CALL_OW 488
103273: NOT
103274: PUSH
103275: LD_VAR 0 6
103279: PUSH
103280: LD_VAR 0 4
103284: ARRAY
103285: PUSH
103286: LD_INT 1
103288: ARRAY
103289: PPUSH
103290: LD_VAR 0 6
103294: PUSH
103295: LD_VAR 0 4
103299: ARRAY
103300: PUSH
103301: LD_INT 2
103303: ARRAY
103304: PPUSH
103305: CALL_OW 428
103309: PUSH
103310: LD_INT 0
103312: NONEQUAL
103313: OR
103314: IFFALSE 103336
// tmp := Delete ( tmp , i ) ;
103316: LD_ADDR_VAR 0 6
103320: PUSH
103321: LD_VAR 0 6
103325: PPUSH
103326: LD_VAR 0 4
103330: PPUSH
103331: CALL_OW 3
103335: ST_TO_ADDR
103336: GO 103236
103338: POP
103339: POP
// j := GetClosestHex ( unit , tmp ) ;
103340: LD_ADDR_VAR 0 5
103344: PUSH
103345: LD_VAR 0 1
103349: PPUSH
103350: LD_VAR 0 6
103354: PPUSH
103355: CALL 102642 0 2
103359: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103360: LD_VAR 0 1
103364: PPUSH
103365: LD_VAR 0 5
103369: PUSH
103370: LD_INT 1
103372: ARRAY
103373: PPUSH
103374: LD_VAR 0 5
103378: PUSH
103379: LD_INT 2
103381: ARRAY
103382: PPUSH
103383: CALL_OW 111
// end ;
103387: LD_VAR 0 3
103391: RET
// export function PrepareApemanSoldier ( ) ; begin
103392: LD_INT 0
103394: PPUSH
// uc_nation := 0 ;
103395: LD_ADDR_OWVAR 21
103399: PUSH
103400: LD_INT 0
103402: ST_TO_ADDR
// hc_sex := sex_male ;
103403: LD_ADDR_OWVAR 27
103407: PUSH
103408: LD_INT 1
103410: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103411: LD_ADDR_OWVAR 28
103415: PUSH
103416: LD_INT 15
103418: ST_TO_ADDR
// hc_gallery :=  ;
103419: LD_ADDR_OWVAR 33
103423: PUSH
103424: LD_STRING 
103426: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103427: LD_ADDR_OWVAR 31
103431: PUSH
103432: LD_INT 0
103434: PPUSH
103435: LD_INT 3
103437: PPUSH
103438: CALL_OW 12
103442: PUSH
103443: LD_INT 0
103445: PPUSH
103446: LD_INT 3
103448: PPUSH
103449: CALL_OW 12
103453: PUSH
103454: LD_INT 0
103456: PUSH
103457: LD_INT 0
103459: PUSH
103460: EMPTY
103461: LIST
103462: LIST
103463: LIST
103464: LIST
103465: ST_TO_ADDR
// end ;
103466: LD_VAR 0 1
103470: RET
// export function PrepareApemanEngineer ( ) ; begin
103471: LD_INT 0
103473: PPUSH
// uc_nation := 0 ;
103474: LD_ADDR_OWVAR 21
103478: PUSH
103479: LD_INT 0
103481: ST_TO_ADDR
// hc_sex := sex_male ;
103482: LD_ADDR_OWVAR 27
103486: PUSH
103487: LD_INT 1
103489: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103490: LD_ADDR_OWVAR 28
103494: PUSH
103495: LD_INT 16
103497: ST_TO_ADDR
// hc_gallery :=  ;
103498: LD_ADDR_OWVAR 33
103502: PUSH
103503: LD_STRING 
103505: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103506: LD_ADDR_OWVAR 31
103510: PUSH
103511: LD_INT 0
103513: PPUSH
103514: LD_INT 3
103516: PPUSH
103517: CALL_OW 12
103521: PUSH
103522: LD_INT 0
103524: PPUSH
103525: LD_INT 3
103527: PPUSH
103528: CALL_OW 12
103532: PUSH
103533: LD_INT 0
103535: PUSH
103536: LD_INT 0
103538: PUSH
103539: EMPTY
103540: LIST
103541: LIST
103542: LIST
103543: LIST
103544: ST_TO_ADDR
// end ;
103545: LD_VAR 0 1
103549: RET
// export function PrepareApeman ( agressivity ) ; begin
103550: LD_INT 0
103552: PPUSH
// uc_side := 0 ;
103553: LD_ADDR_OWVAR 20
103557: PUSH
103558: LD_INT 0
103560: ST_TO_ADDR
// uc_nation := 0 ;
103561: LD_ADDR_OWVAR 21
103565: PUSH
103566: LD_INT 0
103568: ST_TO_ADDR
// hc_sex := sex_male ;
103569: LD_ADDR_OWVAR 27
103573: PUSH
103574: LD_INT 1
103576: ST_TO_ADDR
// hc_class := class_apeman ;
103577: LD_ADDR_OWVAR 28
103581: PUSH
103582: LD_INT 12
103584: ST_TO_ADDR
// hc_gallery :=  ;
103585: LD_ADDR_OWVAR 33
103589: PUSH
103590: LD_STRING 
103592: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103593: LD_ADDR_OWVAR 35
103597: PUSH
103598: LD_VAR 0 1
103602: NEG
103603: PPUSH
103604: LD_VAR 0 1
103608: PPUSH
103609: CALL_OW 12
103613: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103614: LD_ADDR_OWVAR 31
103618: PUSH
103619: LD_INT 0
103621: PPUSH
103622: LD_INT 3
103624: PPUSH
103625: CALL_OW 12
103629: PUSH
103630: LD_INT 0
103632: PPUSH
103633: LD_INT 3
103635: PPUSH
103636: CALL_OW 12
103640: PUSH
103641: LD_INT 0
103643: PUSH
103644: LD_INT 0
103646: PUSH
103647: EMPTY
103648: LIST
103649: LIST
103650: LIST
103651: LIST
103652: ST_TO_ADDR
// end ;
103653: LD_VAR 0 2
103657: RET
// export function PrepareTiger ( agressivity ) ; begin
103658: LD_INT 0
103660: PPUSH
// uc_side := 0 ;
103661: LD_ADDR_OWVAR 20
103665: PUSH
103666: LD_INT 0
103668: ST_TO_ADDR
// uc_nation := 0 ;
103669: LD_ADDR_OWVAR 21
103673: PUSH
103674: LD_INT 0
103676: ST_TO_ADDR
// hc_class := class_tiger ;
103677: LD_ADDR_OWVAR 28
103681: PUSH
103682: LD_INT 14
103684: ST_TO_ADDR
// hc_gallery :=  ;
103685: LD_ADDR_OWVAR 33
103689: PUSH
103690: LD_STRING 
103692: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103693: LD_ADDR_OWVAR 35
103697: PUSH
103698: LD_VAR 0 1
103702: NEG
103703: PPUSH
103704: LD_VAR 0 1
103708: PPUSH
103709: CALL_OW 12
103713: ST_TO_ADDR
// end ;
103714: LD_VAR 0 2
103718: RET
// export function PrepareEnchidna ( ) ; begin
103719: LD_INT 0
103721: PPUSH
// uc_side := 0 ;
103722: LD_ADDR_OWVAR 20
103726: PUSH
103727: LD_INT 0
103729: ST_TO_ADDR
// uc_nation := 0 ;
103730: LD_ADDR_OWVAR 21
103734: PUSH
103735: LD_INT 0
103737: ST_TO_ADDR
// hc_class := class_baggie ;
103738: LD_ADDR_OWVAR 28
103742: PUSH
103743: LD_INT 13
103745: ST_TO_ADDR
// hc_gallery :=  ;
103746: LD_ADDR_OWVAR 33
103750: PUSH
103751: LD_STRING 
103753: ST_TO_ADDR
// end ;
103754: LD_VAR 0 1
103758: RET
// export function PrepareFrog ( ) ; begin
103759: LD_INT 0
103761: PPUSH
// uc_side := 0 ;
103762: LD_ADDR_OWVAR 20
103766: PUSH
103767: LD_INT 0
103769: ST_TO_ADDR
// uc_nation := 0 ;
103770: LD_ADDR_OWVAR 21
103774: PUSH
103775: LD_INT 0
103777: ST_TO_ADDR
// hc_class := class_frog ;
103778: LD_ADDR_OWVAR 28
103782: PUSH
103783: LD_INT 19
103785: ST_TO_ADDR
// hc_gallery :=  ;
103786: LD_ADDR_OWVAR 33
103790: PUSH
103791: LD_STRING 
103793: ST_TO_ADDR
// end ;
103794: LD_VAR 0 1
103798: RET
// export function PrepareFish ( ) ; begin
103799: LD_INT 0
103801: PPUSH
// uc_side := 0 ;
103802: LD_ADDR_OWVAR 20
103806: PUSH
103807: LD_INT 0
103809: ST_TO_ADDR
// uc_nation := 0 ;
103810: LD_ADDR_OWVAR 21
103814: PUSH
103815: LD_INT 0
103817: ST_TO_ADDR
// hc_class := class_fish ;
103818: LD_ADDR_OWVAR 28
103822: PUSH
103823: LD_INT 20
103825: ST_TO_ADDR
// hc_gallery :=  ;
103826: LD_ADDR_OWVAR 33
103830: PUSH
103831: LD_STRING 
103833: ST_TO_ADDR
// end ;
103834: LD_VAR 0 1
103838: RET
// export function PrepareBird ( ) ; begin
103839: LD_INT 0
103841: PPUSH
// uc_side := 0 ;
103842: LD_ADDR_OWVAR 20
103846: PUSH
103847: LD_INT 0
103849: ST_TO_ADDR
// uc_nation := 0 ;
103850: LD_ADDR_OWVAR 21
103854: PUSH
103855: LD_INT 0
103857: ST_TO_ADDR
// hc_class := class_phororhacos ;
103858: LD_ADDR_OWVAR 28
103862: PUSH
103863: LD_INT 18
103865: ST_TO_ADDR
// hc_gallery :=  ;
103866: LD_ADDR_OWVAR 33
103870: PUSH
103871: LD_STRING 
103873: ST_TO_ADDR
// end ;
103874: LD_VAR 0 1
103878: RET
// export function PrepareHorse ( ) ; begin
103879: LD_INT 0
103881: PPUSH
// uc_side := 0 ;
103882: LD_ADDR_OWVAR 20
103886: PUSH
103887: LD_INT 0
103889: ST_TO_ADDR
// uc_nation := 0 ;
103890: LD_ADDR_OWVAR 21
103894: PUSH
103895: LD_INT 0
103897: ST_TO_ADDR
// hc_class := class_horse ;
103898: LD_ADDR_OWVAR 28
103902: PUSH
103903: LD_INT 21
103905: ST_TO_ADDR
// hc_gallery :=  ;
103906: LD_ADDR_OWVAR 33
103910: PUSH
103911: LD_STRING 
103913: ST_TO_ADDR
// end ;
103914: LD_VAR 0 1
103918: RET
// export function PrepareMastodont ( ) ; begin
103919: LD_INT 0
103921: PPUSH
// uc_side := 0 ;
103922: LD_ADDR_OWVAR 20
103926: PUSH
103927: LD_INT 0
103929: ST_TO_ADDR
// uc_nation := 0 ;
103930: LD_ADDR_OWVAR 21
103934: PUSH
103935: LD_INT 0
103937: ST_TO_ADDR
// vc_chassis := class_mastodont ;
103938: LD_ADDR_OWVAR 37
103942: PUSH
103943: LD_INT 31
103945: ST_TO_ADDR
// vc_control := control_rider ;
103946: LD_ADDR_OWVAR 38
103950: PUSH
103951: LD_INT 4
103953: ST_TO_ADDR
// end ;
103954: LD_VAR 0 1
103958: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
103959: LD_INT 0
103961: PPUSH
103962: PPUSH
103963: PPUSH
// uc_side = 0 ;
103964: LD_ADDR_OWVAR 20
103968: PUSH
103969: LD_INT 0
103971: ST_TO_ADDR
// uc_nation = 0 ;
103972: LD_ADDR_OWVAR 21
103976: PUSH
103977: LD_INT 0
103979: ST_TO_ADDR
// InitHc_All ( ) ;
103980: CALL_OW 584
// InitVc ;
103984: CALL_OW 20
// if mastodonts then
103988: LD_VAR 0 6
103992: IFFALSE 104059
// for i = 1 to mastodonts do
103994: LD_ADDR_VAR 0 11
103998: PUSH
103999: DOUBLE
104000: LD_INT 1
104002: DEC
104003: ST_TO_ADDR
104004: LD_VAR 0 6
104008: PUSH
104009: FOR_TO
104010: IFFALSE 104057
// begin vc_chassis := 31 ;
104012: LD_ADDR_OWVAR 37
104016: PUSH
104017: LD_INT 31
104019: ST_TO_ADDR
// vc_control := control_rider ;
104020: LD_ADDR_OWVAR 38
104024: PUSH
104025: LD_INT 4
104027: ST_TO_ADDR
// animal := CreateVehicle ;
104028: LD_ADDR_VAR 0 12
104032: PUSH
104033: CALL_OW 45
104037: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104038: LD_VAR 0 12
104042: PPUSH
104043: LD_VAR 0 8
104047: PPUSH
104048: LD_INT 0
104050: PPUSH
104051: CALL 106187 0 3
// end ;
104055: GO 104009
104057: POP
104058: POP
// if horses then
104059: LD_VAR 0 5
104063: IFFALSE 104130
// for i = 1 to horses do
104065: LD_ADDR_VAR 0 11
104069: PUSH
104070: DOUBLE
104071: LD_INT 1
104073: DEC
104074: ST_TO_ADDR
104075: LD_VAR 0 5
104079: PUSH
104080: FOR_TO
104081: IFFALSE 104128
// begin hc_class := 21 ;
104083: LD_ADDR_OWVAR 28
104087: PUSH
104088: LD_INT 21
104090: ST_TO_ADDR
// hc_gallery :=  ;
104091: LD_ADDR_OWVAR 33
104095: PUSH
104096: LD_STRING 
104098: ST_TO_ADDR
// animal := CreateHuman ;
104099: LD_ADDR_VAR 0 12
104103: PUSH
104104: CALL_OW 44
104108: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104109: LD_VAR 0 12
104113: PPUSH
104114: LD_VAR 0 8
104118: PPUSH
104119: LD_INT 0
104121: PPUSH
104122: CALL 106187 0 3
// end ;
104126: GO 104080
104128: POP
104129: POP
// if birds then
104130: LD_VAR 0 1
104134: IFFALSE 104201
// for i = 1 to birds do
104136: LD_ADDR_VAR 0 11
104140: PUSH
104141: DOUBLE
104142: LD_INT 1
104144: DEC
104145: ST_TO_ADDR
104146: LD_VAR 0 1
104150: PUSH
104151: FOR_TO
104152: IFFALSE 104199
// begin hc_class := 18 ;
104154: LD_ADDR_OWVAR 28
104158: PUSH
104159: LD_INT 18
104161: ST_TO_ADDR
// hc_gallery =  ;
104162: LD_ADDR_OWVAR 33
104166: PUSH
104167: LD_STRING 
104169: ST_TO_ADDR
// animal := CreateHuman ;
104170: LD_ADDR_VAR 0 12
104174: PUSH
104175: CALL_OW 44
104179: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104180: LD_VAR 0 12
104184: PPUSH
104185: LD_VAR 0 8
104189: PPUSH
104190: LD_INT 0
104192: PPUSH
104193: CALL 106187 0 3
// end ;
104197: GO 104151
104199: POP
104200: POP
// if tigers then
104201: LD_VAR 0 2
104205: IFFALSE 104289
// for i = 1 to tigers do
104207: LD_ADDR_VAR 0 11
104211: PUSH
104212: DOUBLE
104213: LD_INT 1
104215: DEC
104216: ST_TO_ADDR
104217: LD_VAR 0 2
104221: PUSH
104222: FOR_TO
104223: IFFALSE 104287
// begin hc_class = class_tiger ;
104225: LD_ADDR_OWVAR 28
104229: PUSH
104230: LD_INT 14
104232: ST_TO_ADDR
// hc_gallery =  ;
104233: LD_ADDR_OWVAR 33
104237: PUSH
104238: LD_STRING 
104240: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104241: LD_ADDR_OWVAR 35
104245: PUSH
104246: LD_INT 7
104248: NEG
104249: PPUSH
104250: LD_INT 7
104252: PPUSH
104253: CALL_OW 12
104257: ST_TO_ADDR
// animal := CreateHuman ;
104258: LD_ADDR_VAR 0 12
104262: PUSH
104263: CALL_OW 44
104267: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104268: LD_VAR 0 12
104272: PPUSH
104273: LD_VAR 0 8
104277: PPUSH
104278: LD_INT 0
104280: PPUSH
104281: CALL 106187 0 3
// end ;
104285: GO 104222
104287: POP
104288: POP
// if apemans then
104289: LD_VAR 0 3
104293: IFFALSE 104416
// for i = 1 to apemans do
104295: LD_ADDR_VAR 0 11
104299: PUSH
104300: DOUBLE
104301: LD_INT 1
104303: DEC
104304: ST_TO_ADDR
104305: LD_VAR 0 3
104309: PUSH
104310: FOR_TO
104311: IFFALSE 104414
// begin hc_class = class_apeman ;
104313: LD_ADDR_OWVAR 28
104317: PUSH
104318: LD_INT 12
104320: ST_TO_ADDR
// hc_gallery =  ;
104321: LD_ADDR_OWVAR 33
104325: PUSH
104326: LD_STRING 
104328: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104329: LD_ADDR_OWVAR 35
104333: PUSH
104334: LD_INT 2
104336: NEG
104337: PPUSH
104338: LD_INT 2
104340: PPUSH
104341: CALL_OW 12
104345: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104346: LD_ADDR_OWVAR 31
104350: PUSH
104351: LD_INT 1
104353: PPUSH
104354: LD_INT 3
104356: PPUSH
104357: CALL_OW 12
104361: PUSH
104362: LD_INT 1
104364: PPUSH
104365: LD_INT 3
104367: PPUSH
104368: CALL_OW 12
104372: PUSH
104373: LD_INT 0
104375: PUSH
104376: LD_INT 0
104378: PUSH
104379: EMPTY
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: ST_TO_ADDR
// animal := CreateHuman ;
104385: LD_ADDR_VAR 0 12
104389: PUSH
104390: CALL_OW 44
104394: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104395: LD_VAR 0 12
104399: PPUSH
104400: LD_VAR 0 8
104404: PPUSH
104405: LD_INT 0
104407: PPUSH
104408: CALL 106187 0 3
// end ;
104412: GO 104310
104414: POP
104415: POP
// if enchidnas then
104416: LD_VAR 0 4
104420: IFFALSE 104487
// for i = 1 to enchidnas do
104422: LD_ADDR_VAR 0 11
104426: PUSH
104427: DOUBLE
104428: LD_INT 1
104430: DEC
104431: ST_TO_ADDR
104432: LD_VAR 0 4
104436: PUSH
104437: FOR_TO
104438: IFFALSE 104485
// begin hc_class = 13 ;
104440: LD_ADDR_OWVAR 28
104444: PUSH
104445: LD_INT 13
104447: ST_TO_ADDR
// hc_gallery =  ;
104448: LD_ADDR_OWVAR 33
104452: PUSH
104453: LD_STRING 
104455: ST_TO_ADDR
// animal := CreateHuman ;
104456: LD_ADDR_VAR 0 12
104460: PUSH
104461: CALL_OW 44
104465: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104466: LD_VAR 0 12
104470: PPUSH
104471: LD_VAR 0 8
104475: PPUSH
104476: LD_INT 0
104478: PPUSH
104479: CALL 106187 0 3
// end ;
104483: GO 104437
104485: POP
104486: POP
// if fishes then
104487: LD_VAR 0 7
104491: IFFALSE 104558
// for i = 1 to fishes do
104493: LD_ADDR_VAR 0 11
104497: PUSH
104498: DOUBLE
104499: LD_INT 1
104501: DEC
104502: ST_TO_ADDR
104503: LD_VAR 0 7
104507: PUSH
104508: FOR_TO
104509: IFFALSE 104556
// begin hc_class = 20 ;
104511: LD_ADDR_OWVAR 28
104515: PUSH
104516: LD_INT 20
104518: ST_TO_ADDR
// hc_gallery =  ;
104519: LD_ADDR_OWVAR 33
104523: PUSH
104524: LD_STRING 
104526: ST_TO_ADDR
// animal := CreateHuman ;
104527: LD_ADDR_VAR 0 12
104531: PUSH
104532: CALL_OW 44
104536: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104537: LD_VAR 0 12
104541: PPUSH
104542: LD_VAR 0 9
104546: PPUSH
104547: LD_INT 0
104549: PPUSH
104550: CALL 106187 0 3
// end ;
104554: GO 104508
104556: POP
104557: POP
// end ;
104558: LD_VAR 0 10
104562: RET
// export function WantHeal ( sci , unit ) ; begin
104563: LD_INT 0
104565: PPUSH
// if GetTaskList ( sci ) > 0 then
104566: LD_VAR 0 1
104570: PPUSH
104571: CALL_OW 437
104575: PUSH
104576: LD_INT 0
104578: GREATER
104579: IFFALSE 104649
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104581: LD_VAR 0 1
104585: PPUSH
104586: CALL_OW 437
104590: PUSH
104591: LD_INT 1
104593: ARRAY
104594: PUSH
104595: LD_INT 1
104597: ARRAY
104598: PUSH
104599: LD_STRING l
104601: EQUAL
104602: PUSH
104603: LD_VAR 0 1
104607: PPUSH
104608: CALL_OW 437
104612: PUSH
104613: LD_INT 1
104615: ARRAY
104616: PUSH
104617: LD_INT 4
104619: ARRAY
104620: PUSH
104621: LD_VAR 0 2
104625: EQUAL
104626: AND
104627: IFFALSE 104639
// result := true else
104629: LD_ADDR_VAR 0 3
104633: PUSH
104634: LD_INT 1
104636: ST_TO_ADDR
104637: GO 104647
// result := false ;
104639: LD_ADDR_VAR 0 3
104643: PUSH
104644: LD_INT 0
104646: ST_TO_ADDR
// end else
104647: GO 104657
// result := false ;
104649: LD_ADDR_VAR 0 3
104653: PUSH
104654: LD_INT 0
104656: ST_TO_ADDR
// end ;
104657: LD_VAR 0 3
104661: RET
// export function HealTarget ( sci ) ; begin
104662: LD_INT 0
104664: PPUSH
// if not sci then
104665: LD_VAR 0 1
104669: NOT
104670: IFFALSE 104674
// exit ;
104672: GO 104739
// result := 0 ;
104674: LD_ADDR_VAR 0 2
104678: PUSH
104679: LD_INT 0
104681: ST_TO_ADDR
// if GetTaskList ( sci ) then
104682: LD_VAR 0 1
104686: PPUSH
104687: CALL_OW 437
104691: IFFALSE 104739
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104693: LD_VAR 0 1
104697: PPUSH
104698: CALL_OW 437
104702: PUSH
104703: LD_INT 1
104705: ARRAY
104706: PUSH
104707: LD_INT 1
104709: ARRAY
104710: PUSH
104711: LD_STRING l
104713: EQUAL
104714: IFFALSE 104739
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104716: LD_ADDR_VAR 0 2
104720: PUSH
104721: LD_VAR 0 1
104725: PPUSH
104726: CALL_OW 437
104730: PUSH
104731: LD_INT 1
104733: ARRAY
104734: PUSH
104735: LD_INT 4
104737: ARRAY
104738: ST_TO_ADDR
// end ;
104739: LD_VAR 0 2
104743: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104744: LD_INT 0
104746: PPUSH
104747: PPUSH
104748: PPUSH
104749: PPUSH
// if not base_units then
104750: LD_VAR 0 1
104754: NOT
104755: IFFALSE 104759
// exit ;
104757: GO 104846
// result := false ;
104759: LD_ADDR_VAR 0 2
104763: PUSH
104764: LD_INT 0
104766: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104767: LD_ADDR_VAR 0 5
104771: PUSH
104772: LD_VAR 0 1
104776: PPUSH
104777: LD_INT 21
104779: PUSH
104780: LD_INT 3
104782: PUSH
104783: EMPTY
104784: LIST
104785: LIST
104786: PPUSH
104787: CALL_OW 72
104791: ST_TO_ADDR
// if not tmp then
104792: LD_VAR 0 5
104796: NOT
104797: IFFALSE 104801
// exit ;
104799: GO 104846
// for i in tmp do
104801: LD_ADDR_VAR 0 3
104805: PUSH
104806: LD_VAR 0 5
104810: PUSH
104811: FOR_IN
104812: IFFALSE 104844
// begin result := EnemyInRange ( i , 22 ) ;
104814: LD_ADDR_VAR 0 2
104818: PUSH
104819: LD_VAR 0 3
104823: PPUSH
104824: LD_INT 22
104826: PPUSH
104827: CALL 102444 0 2
104831: ST_TO_ADDR
// if result then
104832: LD_VAR 0 2
104836: IFFALSE 104842
// exit ;
104838: POP
104839: POP
104840: GO 104846
// end ;
104842: GO 104811
104844: POP
104845: POP
// end ;
104846: LD_VAR 0 2
104850: RET
// export function FilterByTag ( units , tag ) ; begin
104851: LD_INT 0
104853: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104854: LD_ADDR_VAR 0 3
104858: PUSH
104859: LD_VAR 0 1
104863: PPUSH
104864: LD_INT 120
104866: PUSH
104867: LD_VAR 0 2
104871: PUSH
104872: EMPTY
104873: LIST
104874: LIST
104875: PPUSH
104876: CALL_OW 72
104880: ST_TO_ADDR
// end ;
104881: LD_VAR 0 3
104885: RET
// export function IsDriver ( un ) ; begin
104886: LD_INT 0
104888: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104889: LD_ADDR_VAR 0 2
104893: PUSH
104894: LD_VAR 0 1
104898: PUSH
104899: LD_INT 55
104901: PUSH
104902: EMPTY
104903: LIST
104904: PPUSH
104905: CALL_OW 69
104909: IN
104910: ST_TO_ADDR
// end ;
104911: LD_VAR 0 2
104915: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104916: LD_INT 0
104918: PPUSH
104919: PPUSH
// list := [ ] ;
104920: LD_ADDR_VAR 0 5
104924: PUSH
104925: EMPTY
104926: ST_TO_ADDR
// case d of 0 :
104927: LD_VAR 0 3
104931: PUSH
104932: LD_INT 0
104934: DOUBLE
104935: EQUAL
104936: IFTRUE 104940
104938: GO 105073
104940: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104941: LD_ADDR_VAR 0 5
104945: PUSH
104946: LD_VAR 0 1
104950: PUSH
104951: LD_INT 4
104953: MINUS
104954: PUSH
104955: LD_VAR 0 2
104959: PUSH
104960: LD_INT 4
104962: MINUS
104963: PUSH
104964: LD_INT 2
104966: PUSH
104967: EMPTY
104968: LIST
104969: LIST
104970: LIST
104971: PUSH
104972: LD_VAR 0 1
104976: PUSH
104977: LD_INT 3
104979: MINUS
104980: PUSH
104981: LD_VAR 0 2
104985: PUSH
104986: LD_INT 1
104988: PUSH
104989: EMPTY
104990: LIST
104991: LIST
104992: LIST
104993: PUSH
104994: LD_VAR 0 1
104998: PUSH
104999: LD_INT 4
105001: PLUS
105002: PUSH
105003: LD_VAR 0 2
105007: PUSH
105008: LD_INT 4
105010: PUSH
105011: EMPTY
105012: LIST
105013: LIST
105014: LIST
105015: PUSH
105016: LD_VAR 0 1
105020: PUSH
105021: LD_INT 3
105023: PLUS
105024: PUSH
105025: LD_VAR 0 2
105029: PUSH
105030: LD_INT 3
105032: PLUS
105033: PUSH
105034: LD_INT 5
105036: PUSH
105037: EMPTY
105038: LIST
105039: LIST
105040: LIST
105041: PUSH
105042: LD_VAR 0 1
105046: PUSH
105047: LD_VAR 0 2
105051: PUSH
105052: LD_INT 4
105054: PLUS
105055: PUSH
105056: LD_INT 0
105058: PUSH
105059: EMPTY
105060: LIST
105061: LIST
105062: LIST
105063: PUSH
105064: EMPTY
105065: LIST
105066: LIST
105067: LIST
105068: LIST
105069: LIST
105070: ST_TO_ADDR
// end ; 1 :
105071: GO 105771
105073: LD_INT 1
105075: DOUBLE
105076: EQUAL
105077: IFTRUE 105081
105079: GO 105214
105081: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105082: LD_ADDR_VAR 0 5
105086: PUSH
105087: LD_VAR 0 1
105091: PUSH
105092: LD_VAR 0 2
105096: PUSH
105097: LD_INT 4
105099: MINUS
105100: PUSH
105101: LD_INT 3
105103: PUSH
105104: EMPTY
105105: LIST
105106: LIST
105107: LIST
105108: PUSH
105109: LD_VAR 0 1
105113: PUSH
105114: LD_INT 3
105116: MINUS
105117: PUSH
105118: LD_VAR 0 2
105122: PUSH
105123: LD_INT 3
105125: MINUS
105126: PUSH
105127: LD_INT 2
105129: PUSH
105130: EMPTY
105131: LIST
105132: LIST
105133: LIST
105134: PUSH
105135: LD_VAR 0 1
105139: PUSH
105140: LD_INT 4
105142: MINUS
105143: PUSH
105144: LD_VAR 0 2
105148: PUSH
105149: LD_INT 1
105151: PUSH
105152: EMPTY
105153: LIST
105154: LIST
105155: LIST
105156: PUSH
105157: LD_VAR 0 1
105161: PUSH
105162: LD_VAR 0 2
105166: PUSH
105167: LD_INT 3
105169: PLUS
105170: PUSH
105171: LD_INT 0
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: LIST
105178: PUSH
105179: LD_VAR 0 1
105183: PUSH
105184: LD_INT 4
105186: PLUS
105187: PUSH
105188: LD_VAR 0 2
105192: PUSH
105193: LD_INT 4
105195: PLUS
105196: PUSH
105197: LD_INT 5
105199: PUSH
105200: EMPTY
105201: LIST
105202: LIST
105203: LIST
105204: PUSH
105205: EMPTY
105206: LIST
105207: LIST
105208: LIST
105209: LIST
105210: LIST
105211: ST_TO_ADDR
// end ; 2 :
105212: GO 105771
105214: LD_INT 2
105216: DOUBLE
105217: EQUAL
105218: IFTRUE 105222
105220: GO 105351
105222: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105223: LD_ADDR_VAR 0 5
105227: PUSH
105228: LD_VAR 0 1
105232: PUSH
105233: LD_VAR 0 2
105237: PUSH
105238: LD_INT 3
105240: MINUS
105241: PUSH
105242: LD_INT 3
105244: PUSH
105245: EMPTY
105246: LIST
105247: LIST
105248: LIST
105249: PUSH
105250: LD_VAR 0 1
105254: PUSH
105255: LD_INT 4
105257: PLUS
105258: PUSH
105259: LD_VAR 0 2
105263: PUSH
105264: LD_INT 4
105266: PUSH
105267: EMPTY
105268: LIST
105269: LIST
105270: LIST
105271: PUSH
105272: LD_VAR 0 1
105276: PUSH
105277: LD_VAR 0 2
105281: PUSH
105282: LD_INT 4
105284: PLUS
105285: PUSH
105286: LD_INT 0
105288: PUSH
105289: EMPTY
105290: LIST
105291: LIST
105292: LIST
105293: PUSH
105294: LD_VAR 0 1
105298: PUSH
105299: LD_INT 3
105301: MINUS
105302: PUSH
105303: LD_VAR 0 2
105307: PUSH
105308: LD_INT 1
105310: PUSH
105311: EMPTY
105312: LIST
105313: LIST
105314: LIST
105315: PUSH
105316: LD_VAR 0 1
105320: PUSH
105321: LD_INT 4
105323: MINUS
105324: PUSH
105325: LD_VAR 0 2
105329: PUSH
105330: LD_INT 4
105332: MINUS
105333: PUSH
105334: LD_INT 2
105336: PUSH
105337: EMPTY
105338: LIST
105339: LIST
105340: LIST
105341: PUSH
105342: EMPTY
105343: LIST
105344: LIST
105345: LIST
105346: LIST
105347: LIST
105348: ST_TO_ADDR
// end ; 3 :
105349: GO 105771
105351: LD_INT 3
105353: DOUBLE
105354: EQUAL
105355: IFTRUE 105359
105357: GO 105492
105359: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105360: LD_ADDR_VAR 0 5
105364: PUSH
105365: LD_VAR 0 1
105369: PUSH
105370: LD_INT 3
105372: PLUS
105373: PUSH
105374: LD_VAR 0 2
105378: PUSH
105379: LD_INT 4
105381: PUSH
105382: EMPTY
105383: LIST
105384: LIST
105385: LIST
105386: PUSH
105387: LD_VAR 0 1
105391: PUSH
105392: LD_INT 4
105394: PLUS
105395: PUSH
105396: LD_VAR 0 2
105400: PUSH
105401: LD_INT 4
105403: PLUS
105404: PUSH
105405: LD_INT 5
105407: PUSH
105408: EMPTY
105409: LIST
105410: LIST
105411: LIST
105412: PUSH
105413: LD_VAR 0 1
105417: PUSH
105418: LD_INT 4
105420: MINUS
105421: PUSH
105422: LD_VAR 0 2
105426: PUSH
105427: LD_INT 1
105429: PUSH
105430: EMPTY
105431: LIST
105432: LIST
105433: LIST
105434: PUSH
105435: LD_VAR 0 1
105439: PUSH
105440: LD_VAR 0 2
105444: PUSH
105445: LD_INT 4
105447: MINUS
105448: PUSH
105449: LD_INT 3
105451: PUSH
105452: EMPTY
105453: LIST
105454: LIST
105455: LIST
105456: PUSH
105457: LD_VAR 0 1
105461: PUSH
105462: LD_INT 3
105464: MINUS
105465: PUSH
105466: LD_VAR 0 2
105470: PUSH
105471: LD_INT 3
105473: MINUS
105474: PUSH
105475: LD_INT 2
105477: PUSH
105478: EMPTY
105479: LIST
105480: LIST
105481: LIST
105482: PUSH
105483: EMPTY
105484: LIST
105485: LIST
105486: LIST
105487: LIST
105488: LIST
105489: ST_TO_ADDR
// end ; 4 :
105490: GO 105771
105492: LD_INT 4
105494: DOUBLE
105495: EQUAL
105496: IFTRUE 105500
105498: GO 105633
105500: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105501: LD_ADDR_VAR 0 5
105505: PUSH
105506: LD_VAR 0 1
105510: PUSH
105511: LD_VAR 0 2
105515: PUSH
105516: LD_INT 4
105518: PLUS
105519: PUSH
105520: LD_INT 0
105522: PUSH
105523: EMPTY
105524: LIST
105525: LIST
105526: LIST
105527: PUSH
105528: LD_VAR 0 1
105532: PUSH
105533: LD_INT 3
105535: PLUS
105536: PUSH
105537: LD_VAR 0 2
105541: PUSH
105542: LD_INT 3
105544: PLUS
105545: PUSH
105546: LD_INT 5
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: LIST
105553: PUSH
105554: LD_VAR 0 1
105558: PUSH
105559: LD_INT 4
105561: PLUS
105562: PUSH
105563: LD_VAR 0 2
105567: PUSH
105568: LD_INT 4
105570: PUSH
105571: EMPTY
105572: LIST
105573: LIST
105574: LIST
105575: PUSH
105576: LD_VAR 0 1
105580: PUSH
105581: LD_VAR 0 2
105585: PUSH
105586: LD_INT 3
105588: MINUS
105589: PUSH
105590: LD_INT 3
105592: PUSH
105593: EMPTY
105594: LIST
105595: LIST
105596: LIST
105597: PUSH
105598: LD_VAR 0 1
105602: PUSH
105603: LD_INT 4
105605: MINUS
105606: PUSH
105607: LD_VAR 0 2
105611: PUSH
105612: LD_INT 4
105614: MINUS
105615: PUSH
105616: LD_INT 2
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: LIST
105623: PUSH
105624: EMPTY
105625: LIST
105626: LIST
105627: LIST
105628: LIST
105629: LIST
105630: ST_TO_ADDR
// end ; 5 :
105631: GO 105771
105633: LD_INT 5
105635: DOUBLE
105636: EQUAL
105637: IFTRUE 105641
105639: GO 105770
105641: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105642: LD_ADDR_VAR 0 5
105646: PUSH
105647: LD_VAR 0 1
105651: PUSH
105652: LD_INT 4
105654: MINUS
105655: PUSH
105656: LD_VAR 0 2
105660: PUSH
105661: LD_INT 1
105663: PUSH
105664: EMPTY
105665: LIST
105666: LIST
105667: LIST
105668: PUSH
105669: LD_VAR 0 1
105673: PUSH
105674: LD_VAR 0 2
105678: PUSH
105679: LD_INT 4
105681: MINUS
105682: PUSH
105683: LD_INT 3
105685: PUSH
105686: EMPTY
105687: LIST
105688: LIST
105689: LIST
105690: PUSH
105691: LD_VAR 0 1
105695: PUSH
105696: LD_INT 4
105698: PLUS
105699: PUSH
105700: LD_VAR 0 2
105704: PUSH
105705: LD_INT 4
105707: PLUS
105708: PUSH
105709: LD_INT 5
105711: PUSH
105712: EMPTY
105713: LIST
105714: LIST
105715: LIST
105716: PUSH
105717: LD_VAR 0 1
105721: PUSH
105722: LD_INT 3
105724: PLUS
105725: PUSH
105726: LD_VAR 0 2
105730: PUSH
105731: LD_INT 4
105733: PUSH
105734: EMPTY
105735: LIST
105736: LIST
105737: LIST
105738: PUSH
105739: LD_VAR 0 1
105743: PUSH
105744: LD_VAR 0 2
105748: PUSH
105749: LD_INT 3
105751: PLUS
105752: PUSH
105753: LD_INT 0
105755: PUSH
105756: EMPTY
105757: LIST
105758: LIST
105759: LIST
105760: PUSH
105761: EMPTY
105762: LIST
105763: LIST
105764: LIST
105765: LIST
105766: LIST
105767: ST_TO_ADDR
// end ; end ;
105768: GO 105771
105770: POP
// result := list ;
105771: LD_ADDR_VAR 0 4
105775: PUSH
105776: LD_VAR 0 5
105780: ST_TO_ADDR
// end ;
105781: LD_VAR 0 4
105785: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105786: LD_INT 0
105788: PPUSH
105789: PPUSH
105790: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105791: LD_VAR 0 1
105795: NOT
105796: PUSH
105797: LD_VAR 0 2
105801: PUSH
105802: LD_INT 1
105804: PUSH
105805: LD_INT 2
105807: PUSH
105808: LD_INT 3
105810: PUSH
105811: LD_INT 4
105813: PUSH
105814: EMPTY
105815: LIST
105816: LIST
105817: LIST
105818: LIST
105819: IN
105820: NOT
105821: OR
105822: IFFALSE 105826
// exit ;
105824: GO 105909
// tmp := [ ] ;
105826: LD_ADDR_VAR 0 5
105830: PUSH
105831: EMPTY
105832: ST_TO_ADDR
// for i in units do
105833: LD_ADDR_VAR 0 4
105837: PUSH
105838: LD_VAR 0 1
105842: PUSH
105843: FOR_IN
105844: IFFALSE 105878
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105846: LD_ADDR_VAR 0 5
105850: PUSH
105851: LD_VAR 0 5
105855: PPUSH
105856: LD_VAR 0 4
105860: PPUSH
105861: LD_VAR 0 2
105865: PPUSH
105866: CALL_OW 259
105870: PPUSH
105871: CALL 107282 0 2
105875: ST_TO_ADDR
105876: GO 105843
105878: POP
105879: POP
// if not tmp then
105880: LD_VAR 0 5
105884: NOT
105885: IFFALSE 105889
// exit ;
105887: GO 105909
// result := SortListByListDesc ( units , tmp ) ;
105889: LD_ADDR_VAR 0 3
105893: PUSH
105894: LD_VAR 0 1
105898: PPUSH
105899: LD_VAR 0 5
105903: PPUSH
105904: CALL_OW 77
105908: ST_TO_ADDR
// end ;
105909: LD_VAR 0 3
105913: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105914: LD_INT 0
105916: PPUSH
105917: PPUSH
105918: PPUSH
// result := false ;
105919: LD_ADDR_VAR 0 3
105923: PUSH
105924: LD_INT 0
105926: ST_TO_ADDR
// if not building then
105927: LD_VAR 0 2
105931: NOT
105932: IFFALSE 105936
// exit ;
105934: GO 106074
// x := GetX ( building ) ;
105936: LD_ADDR_VAR 0 4
105940: PUSH
105941: LD_VAR 0 2
105945: PPUSH
105946: CALL_OW 250
105950: ST_TO_ADDR
// y := GetY ( building ) ;
105951: LD_ADDR_VAR 0 5
105955: PUSH
105956: LD_VAR 0 2
105960: PPUSH
105961: CALL_OW 251
105965: ST_TO_ADDR
// if not x or not y then
105966: LD_VAR 0 4
105970: NOT
105971: PUSH
105972: LD_VAR 0 5
105976: NOT
105977: OR
105978: IFFALSE 105982
// exit ;
105980: GO 106074
// if GetTaskList ( unit ) then
105982: LD_VAR 0 1
105986: PPUSH
105987: CALL_OW 437
105991: IFFALSE 106074
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105993: LD_STRING e
105995: PUSH
105996: LD_VAR 0 1
106000: PPUSH
106001: CALL_OW 437
106005: PUSH
106006: LD_INT 1
106008: ARRAY
106009: PUSH
106010: LD_INT 1
106012: ARRAY
106013: EQUAL
106014: PUSH
106015: LD_VAR 0 4
106019: PUSH
106020: LD_VAR 0 1
106024: PPUSH
106025: CALL_OW 437
106029: PUSH
106030: LD_INT 1
106032: ARRAY
106033: PUSH
106034: LD_INT 2
106036: ARRAY
106037: EQUAL
106038: AND
106039: PUSH
106040: LD_VAR 0 5
106044: PUSH
106045: LD_VAR 0 1
106049: PPUSH
106050: CALL_OW 437
106054: PUSH
106055: LD_INT 1
106057: ARRAY
106058: PUSH
106059: LD_INT 3
106061: ARRAY
106062: EQUAL
106063: AND
106064: IFFALSE 106074
// result := true end ;
106066: LD_ADDR_VAR 0 3
106070: PUSH
106071: LD_INT 1
106073: ST_TO_ADDR
// end ;
106074: LD_VAR 0 3
106078: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106079: LD_INT 0
106081: PPUSH
// result := false ;
106082: LD_ADDR_VAR 0 4
106086: PUSH
106087: LD_INT 0
106089: ST_TO_ADDR
// if GetTaskList ( unit ) then
106090: LD_VAR 0 1
106094: PPUSH
106095: CALL_OW 437
106099: IFFALSE 106182
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106101: LD_STRING M
106103: PUSH
106104: LD_VAR 0 1
106108: PPUSH
106109: CALL_OW 437
106113: PUSH
106114: LD_INT 1
106116: ARRAY
106117: PUSH
106118: LD_INT 1
106120: ARRAY
106121: EQUAL
106122: PUSH
106123: LD_VAR 0 2
106127: PUSH
106128: LD_VAR 0 1
106132: PPUSH
106133: CALL_OW 437
106137: PUSH
106138: LD_INT 1
106140: ARRAY
106141: PUSH
106142: LD_INT 2
106144: ARRAY
106145: EQUAL
106146: AND
106147: PUSH
106148: LD_VAR 0 3
106152: PUSH
106153: LD_VAR 0 1
106157: PPUSH
106158: CALL_OW 437
106162: PUSH
106163: LD_INT 1
106165: ARRAY
106166: PUSH
106167: LD_INT 3
106169: ARRAY
106170: EQUAL
106171: AND
106172: IFFALSE 106182
// result := true ;
106174: LD_ADDR_VAR 0 4
106178: PUSH
106179: LD_INT 1
106181: ST_TO_ADDR
// end ; end ;
106182: LD_VAR 0 4
106186: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106187: LD_INT 0
106189: PPUSH
106190: PPUSH
106191: PPUSH
106192: PPUSH
// if not unit or not area then
106193: LD_VAR 0 1
106197: NOT
106198: PUSH
106199: LD_VAR 0 2
106203: NOT
106204: OR
106205: IFFALSE 106209
// exit ;
106207: GO 106385
// tmp := AreaToList ( area , i ) ;
106209: LD_ADDR_VAR 0 6
106213: PUSH
106214: LD_VAR 0 2
106218: PPUSH
106219: LD_VAR 0 5
106223: PPUSH
106224: CALL_OW 517
106228: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106229: LD_ADDR_VAR 0 5
106233: PUSH
106234: DOUBLE
106235: LD_INT 1
106237: DEC
106238: ST_TO_ADDR
106239: LD_VAR 0 6
106243: PUSH
106244: LD_INT 1
106246: ARRAY
106247: PUSH
106248: FOR_TO
106249: IFFALSE 106383
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106251: LD_ADDR_VAR 0 7
106255: PUSH
106256: LD_VAR 0 6
106260: PUSH
106261: LD_INT 1
106263: ARRAY
106264: PUSH
106265: LD_VAR 0 5
106269: ARRAY
106270: PUSH
106271: LD_VAR 0 6
106275: PUSH
106276: LD_INT 2
106278: ARRAY
106279: PUSH
106280: LD_VAR 0 5
106284: ARRAY
106285: PUSH
106286: EMPTY
106287: LIST
106288: LIST
106289: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106290: LD_INT 92
106292: PUSH
106293: LD_VAR 0 7
106297: PUSH
106298: LD_INT 1
106300: ARRAY
106301: PUSH
106302: LD_VAR 0 7
106306: PUSH
106307: LD_INT 2
106309: ARRAY
106310: PUSH
106311: LD_INT 2
106313: PUSH
106314: EMPTY
106315: LIST
106316: LIST
106317: LIST
106318: LIST
106319: PPUSH
106320: CALL_OW 69
106324: PUSH
106325: LD_INT 0
106327: EQUAL
106328: IFFALSE 106381
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106330: LD_VAR 0 1
106334: PPUSH
106335: LD_VAR 0 7
106339: PUSH
106340: LD_INT 1
106342: ARRAY
106343: PPUSH
106344: LD_VAR 0 7
106348: PUSH
106349: LD_INT 2
106351: ARRAY
106352: PPUSH
106353: LD_VAR 0 3
106357: PPUSH
106358: CALL_OW 48
// result := IsPlaced ( unit ) ;
106362: LD_ADDR_VAR 0 4
106366: PUSH
106367: LD_VAR 0 1
106371: PPUSH
106372: CALL_OW 305
106376: ST_TO_ADDR
// exit ;
106377: POP
106378: POP
106379: GO 106385
// end ; end ;
106381: GO 106248
106383: POP
106384: POP
// end ;
106385: LD_VAR 0 4
106389: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106390: LD_INT 0
106392: PPUSH
106393: PPUSH
106394: PPUSH
// if not side or side > 8 then
106395: LD_VAR 0 1
106399: NOT
106400: PUSH
106401: LD_VAR 0 1
106405: PUSH
106406: LD_INT 8
106408: GREATER
106409: OR
106410: IFFALSE 106414
// exit ;
106412: GO 106601
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106414: LD_ADDR_VAR 0 4
106418: PUSH
106419: LD_INT 22
106421: PUSH
106422: LD_VAR 0 1
106426: PUSH
106427: EMPTY
106428: LIST
106429: LIST
106430: PUSH
106431: LD_INT 21
106433: PUSH
106434: LD_INT 3
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: PPUSH
106445: CALL_OW 69
106449: ST_TO_ADDR
// if not tmp then
106450: LD_VAR 0 4
106454: NOT
106455: IFFALSE 106459
// exit ;
106457: GO 106601
// enable_addtolog := true ;
106459: LD_ADDR_OWVAR 81
106463: PUSH
106464: LD_INT 1
106466: ST_TO_ADDR
// AddToLog ( [ ) ;
106467: LD_STRING [
106469: PPUSH
106470: CALL_OW 561
// for i in tmp do
106474: LD_ADDR_VAR 0 3
106478: PUSH
106479: LD_VAR 0 4
106483: PUSH
106484: FOR_IN
106485: IFFALSE 106592
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106487: LD_STRING [
106489: PUSH
106490: LD_VAR 0 3
106494: PPUSH
106495: CALL_OW 266
106499: STR
106500: PUSH
106501: LD_STRING , 
106503: STR
106504: PUSH
106505: LD_VAR 0 3
106509: PPUSH
106510: CALL_OW 250
106514: STR
106515: PUSH
106516: LD_STRING , 
106518: STR
106519: PUSH
106520: LD_VAR 0 3
106524: PPUSH
106525: CALL_OW 251
106529: STR
106530: PUSH
106531: LD_STRING , 
106533: STR
106534: PUSH
106535: LD_VAR 0 3
106539: PPUSH
106540: CALL_OW 254
106544: STR
106545: PUSH
106546: LD_STRING , 
106548: STR
106549: PUSH
106550: LD_VAR 0 3
106554: PPUSH
106555: LD_INT 1
106557: PPUSH
106558: CALL_OW 268
106562: STR
106563: PUSH
106564: LD_STRING , 
106566: STR
106567: PUSH
106568: LD_VAR 0 3
106572: PPUSH
106573: LD_INT 2
106575: PPUSH
106576: CALL_OW 268
106580: STR
106581: PUSH
106582: LD_STRING ],
106584: STR
106585: PPUSH
106586: CALL_OW 561
// end ;
106590: GO 106484
106592: POP
106593: POP
// AddToLog ( ]; ) ;
106594: LD_STRING ];
106596: PPUSH
106597: CALL_OW 561
// end ;
106601: LD_VAR 0 2
106605: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106606: LD_INT 0
106608: PPUSH
106609: PPUSH
106610: PPUSH
106611: PPUSH
106612: PPUSH
// if not area or not rate or not max then
106613: LD_VAR 0 1
106617: NOT
106618: PUSH
106619: LD_VAR 0 2
106623: NOT
106624: OR
106625: PUSH
106626: LD_VAR 0 4
106630: NOT
106631: OR
106632: IFFALSE 106636
// exit ;
106634: GO 106825
// while 1 do
106636: LD_INT 1
106638: IFFALSE 106825
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106640: LD_ADDR_VAR 0 9
106644: PUSH
106645: LD_VAR 0 1
106649: PPUSH
106650: LD_INT 1
106652: PPUSH
106653: CALL_OW 287
106657: PUSH
106658: LD_INT 10
106660: MUL
106661: ST_TO_ADDR
// r := rate / 10 ;
106662: LD_ADDR_VAR 0 7
106666: PUSH
106667: LD_VAR 0 2
106671: PUSH
106672: LD_INT 10
106674: DIVREAL
106675: ST_TO_ADDR
// time := 1 1$00 ;
106676: LD_ADDR_VAR 0 8
106680: PUSH
106681: LD_INT 2100
106683: ST_TO_ADDR
// if amount < min then
106684: LD_VAR 0 9
106688: PUSH
106689: LD_VAR 0 3
106693: LESS
106694: IFFALSE 106712
// r := r * 2 else
106696: LD_ADDR_VAR 0 7
106700: PUSH
106701: LD_VAR 0 7
106705: PUSH
106706: LD_INT 2
106708: MUL
106709: ST_TO_ADDR
106710: GO 106738
// if amount > max then
106712: LD_VAR 0 9
106716: PUSH
106717: LD_VAR 0 4
106721: GREATER
106722: IFFALSE 106738
// r := r / 2 ;
106724: LD_ADDR_VAR 0 7
106728: PUSH
106729: LD_VAR 0 7
106733: PUSH
106734: LD_INT 2
106736: DIVREAL
106737: ST_TO_ADDR
// time := time / r ;
106738: LD_ADDR_VAR 0 8
106742: PUSH
106743: LD_VAR 0 8
106747: PUSH
106748: LD_VAR 0 7
106752: DIVREAL
106753: ST_TO_ADDR
// if time < 0 then
106754: LD_VAR 0 8
106758: PUSH
106759: LD_INT 0
106761: LESS
106762: IFFALSE 106779
// time := time * - 1 ;
106764: LD_ADDR_VAR 0 8
106768: PUSH
106769: LD_VAR 0 8
106773: PUSH
106774: LD_INT 1
106776: NEG
106777: MUL
106778: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106779: LD_VAR 0 8
106783: PUSH
106784: LD_INT 35
106786: PPUSH
106787: LD_INT 875
106789: PPUSH
106790: CALL_OW 12
106794: PLUS
106795: PPUSH
106796: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106800: LD_INT 1
106802: PPUSH
106803: LD_INT 5
106805: PPUSH
106806: CALL_OW 12
106810: PPUSH
106811: LD_VAR 0 1
106815: PPUSH
106816: LD_INT 1
106818: PPUSH
106819: CALL_OW 55
// end ;
106823: GO 106636
// end ;
106825: LD_VAR 0 5
106829: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106830: LD_INT 0
106832: PPUSH
106833: PPUSH
106834: PPUSH
106835: PPUSH
106836: PPUSH
106837: PPUSH
106838: PPUSH
106839: PPUSH
// if not turrets or not factories then
106840: LD_VAR 0 1
106844: NOT
106845: PUSH
106846: LD_VAR 0 2
106850: NOT
106851: OR
106852: IFFALSE 106856
// exit ;
106854: GO 107163
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106856: LD_ADDR_VAR 0 10
106860: PUSH
106861: LD_INT 5
106863: PUSH
106864: LD_INT 6
106866: PUSH
106867: EMPTY
106868: LIST
106869: LIST
106870: PUSH
106871: LD_INT 2
106873: PUSH
106874: LD_INT 4
106876: PUSH
106877: EMPTY
106878: LIST
106879: LIST
106880: PUSH
106881: LD_INT 3
106883: PUSH
106884: LD_INT 5
106886: PUSH
106887: EMPTY
106888: LIST
106889: LIST
106890: PUSH
106891: EMPTY
106892: LIST
106893: LIST
106894: LIST
106895: PUSH
106896: LD_INT 24
106898: PUSH
106899: LD_INT 25
106901: PUSH
106902: EMPTY
106903: LIST
106904: LIST
106905: PUSH
106906: LD_INT 23
106908: PUSH
106909: LD_INT 27
106911: PUSH
106912: EMPTY
106913: LIST
106914: LIST
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: LD_INT 42
106922: PUSH
106923: LD_INT 43
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: PUSH
106930: LD_INT 44
106932: PUSH
106933: LD_INT 46
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: PUSH
106940: LD_INT 45
106942: PUSH
106943: LD_INT 47
106945: PUSH
106946: EMPTY
106947: LIST
106948: LIST
106949: PUSH
106950: EMPTY
106951: LIST
106952: LIST
106953: LIST
106954: PUSH
106955: EMPTY
106956: LIST
106957: LIST
106958: LIST
106959: ST_TO_ADDR
// result := [ ] ;
106960: LD_ADDR_VAR 0 3
106964: PUSH
106965: EMPTY
106966: ST_TO_ADDR
// for i in turrets do
106967: LD_ADDR_VAR 0 4
106971: PUSH
106972: LD_VAR 0 1
106976: PUSH
106977: FOR_IN
106978: IFFALSE 107161
// begin nat := GetNation ( i ) ;
106980: LD_ADDR_VAR 0 7
106984: PUSH
106985: LD_VAR 0 4
106989: PPUSH
106990: CALL_OW 248
106994: ST_TO_ADDR
// weapon := 0 ;
106995: LD_ADDR_VAR 0 8
106999: PUSH
107000: LD_INT 0
107002: ST_TO_ADDR
// if not nat then
107003: LD_VAR 0 7
107007: NOT
107008: IFFALSE 107012
// continue ;
107010: GO 106977
// for j in list [ nat ] do
107012: LD_ADDR_VAR 0 5
107016: PUSH
107017: LD_VAR 0 10
107021: PUSH
107022: LD_VAR 0 7
107026: ARRAY
107027: PUSH
107028: FOR_IN
107029: IFFALSE 107070
// if GetBWeapon ( i ) = j [ 1 ] then
107031: LD_VAR 0 4
107035: PPUSH
107036: CALL_OW 269
107040: PUSH
107041: LD_VAR 0 5
107045: PUSH
107046: LD_INT 1
107048: ARRAY
107049: EQUAL
107050: IFFALSE 107068
// begin weapon := j [ 2 ] ;
107052: LD_ADDR_VAR 0 8
107056: PUSH
107057: LD_VAR 0 5
107061: PUSH
107062: LD_INT 2
107064: ARRAY
107065: ST_TO_ADDR
// break ;
107066: GO 107070
// end ;
107068: GO 107028
107070: POP
107071: POP
// if not weapon then
107072: LD_VAR 0 8
107076: NOT
107077: IFFALSE 107081
// continue ;
107079: GO 106977
// for k in factories do
107081: LD_ADDR_VAR 0 6
107085: PUSH
107086: LD_VAR 0 2
107090: PUSH
107091: FOR_IN
107092: IFFALSE 107157
// begin weapons := AvailableWeaponList ( k ) ;
107094: LD_ADDR_VAR 0 9
107098: PUSH
107099: LD_VAR 0 6
107103: PPUSH
107104: CALL_OW 478
107108: ST_TO_ADDR
// if not weapons then
107109: LD_VAR 0 9
107113: NOT
107114: IFFALSE 107118
// continue ;
107116: GO 107091
// if weapon in weapons then
107118: LD_VAR 0 8
107122: PUSH
107123: LD_VAR 0 9
107127: IN
107128: IFFALSE 107155
// begin result := [ i , weapon ] ;
107130: LD_ADDR_VAR 0 3
107134: PUSH
107135: LD_VAR 0 4
107139: PUSH
107140: LD_VAR 0 8
107144: PUSH
107145: EMPTY
107146: LIST
107147: LIST
107148: ST_TO_ADDR
// exit ;
107149: POP
107150: POP
107151: POP
107152: POP
107153: GO 107163
// end ; end ;
107155: GO 107091
107157: POP
107158: POP
// end ;
107159: GO 106977
107161: POP
107162: POP
// end ;
107163: LD_VAR 0 3
107167: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107168: LD_INT 0
107170: PPUSH
// if not side or side > 8 then
107171: LD_VAR 0 3
107175: NOT
107176: PUSH
107177: LD_VAR 0 3
107181: PUSH
107182: LD_INT 8
107184: GREATER
107185: OR
107186: IFFALSE 107190
// exit ;
107188: GO 107249
// if not range then
107190: LD_VAR 0 4
107194: NOT
107195: IFFALSE 107206
// range := - 12 ;
107197: LD_ADDR_VAR 0 4
107201: PUSH
107202: LD_INT 12
107204: NEG
107205: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107206: LD_VAR 0 1
107210: PPUSH
107211: LD_VAR 0 2
107215: PPUSH
107216: LD_VAR 0 3
107220: PPUSH
107221: LD_VAR 0 4
107225: PPUSH
107226: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107230: LD_VAR 0 1
107234: PPUSH
107235: LD_VAR 0 2
107239: PPUSH
107240: LD_VAR 0 3
107244: PPUSH
107245: CALL_OW 331
// end ;
107249: LD_VAR 0 5
107253: RET
// export function Video ( mode ) ; begin
107254: LD_INT 0
107256: PPUSH
// ingame_video = mode ;
107257: LD_ADDR_OWVAR 52
107261: PUSH
107262: LD_VAR 0 1
107266: ST_TO_ADDR
// interface_hidden = mode ;
107267: LD_ADDR_OWVAR 54
107271: PUSH
107272: LD_VAR 0 1
107276: ST_TO_ADDR
// end ;
107277: LD_VAR 0 2
107281: RET
// export function Join ( array , element ) ; begin
107282: LD_INT 0
107284: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107285: LD_ADDR_VAR 0 3
107289: PUSH
107290: LD_VAR 0 1
107294: PPUSH
107295: LD_VAR 0 1
107299: PUSH
107300: LD_INT 1
107302: PLUS
107303: PPUSH
107304: LD_VAR 0 2
107308: PPUSH
107309: CALL_OW 1
107313: ST_TO_ADDR
// end ;
107314: LD_VAR 0 3
107318: RET
// export function JoinUnion ( array , element ) ; begin
107319: LD_INT 0
107321: PPUSH
// result := array union element ;
107322: LD_ADDR_VAR 0 3
107326: PUSH
107327: LD_VAR 0 1
107331: PUSH
107332: LD_VAR 0 2
107336: UNION
107337: ST_TO_ADDR
// end ;
107338: LD_VAR 0 3
107342: RET
// export function GetBehemoths ( side ) ; begin
107343: LD_INT 0
107345: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107346: LD_ADDR_VAR 0 2
107350: PUSH
107351: LD_INT 22
107353: PUSH
107354: LD_VAR 0 1
107358: PUSH
107359: EMPTY
107360: LIST
107361: LIST
107362: PUSH
107363: LD_INT 31
107365: PUSH
107366: LD_INT 25
107368: PUSH
107369: EMPTY
107370: LIST
107371: LIST
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: PPUSH
107377: CALL_OW 69
107381: ST_TO_ADDR
// end ;
107382: LD_VAR 0 2
107386: RET
// export function Shuffle ( array ) ; var i , index ; begin
107387: LD_INT 0
107389: PPUSH
107390: PPUSH
107391: PPUSH
// result := [ ] ;
107392: LD_ADDR_VAR 0 2
107396: PUSH
107397: EMPTY
107398: ST_TO_ADDR
// if not array then
107399: LD_VAR 0 1
107403: NOT
107404: IFFALSE 107408
// exit ;
107406: GO 107507
// Randomize ;
107408: CALL_OW 10
// for i = array downto 1 do
107412: LD_ADDR_VAR 0 3
107416: PUSH
107417: DOUBLE
107418: LD_VAR 0 1
107422: INC
107423: ST_TO_ADDR
107424: LD_INT 1
107426: PUSH
107427: FOR_DOWNTO
107428: IFFALSE 107505
// begin index := rand ( 1 , array ) ;
107430: LD_ADDR_VAR 0 4
107434: PUSH
107435: LD_INT 1
107437: PPUSH
107438: LD_VAR 0 1
107442: PPUSH
107443: CALL_OW 12
107447: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107448: LD_ADDR_VAR 0 2
107452: PUSH
107453: LD_VAR 0 2
107457: PPUSH
107458: LD_VAR 0 2
107462: PUSH
107463: LD_INT 1
107465: PLUS
107466: PPUSH
107467: LD_VAR 0 1
107471: PUSH
107472: LD_VAR 0 4
107476: ARRAY
107477: PPUSH
107478: CALL_OW 2
107482: ST_TO_ADDR
// array := Delete ( array , index ) ;
107483: LD_ADDR_VAR 0 1
107487: PUSH
107488: LD_VAR 0 1
107492: PPUSH
107493: LD_VAR 0 4
107497: PPUSH
107498: CALL_OW 3
107502: ST_TO_ADDR
// end ;
107503: GO 107427
107505: POP
107506: POP
// end ;
107507: LD_VAR 0 2
107511: RET
// export function GetBaseMaterials ( base ) ; begin
107512: LD_INT 0
107514: PPUSH
// result := [ 0 , 0 , 0 ] ;
107515: LD_ADDR_VAR 0 2
107519: PUSH
107520: LD_INT 0
107522: PUSH
107523: LD_INT 0
107525: PUSH
107526: LD_INT 0
107528: PUSH
107529: EMPTY
107530: LIST
107531: LIST
107532: LIST
107533: ST_TO_ADDR
// if not base then
107534: LD_VAR 0 1
107538: NOT
107539: IFFALSE 107543
// exit ;
107541: GO 107592
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107543: LD_ADDR_VAR 0 2
107547: PUSH
107548: LD_VAR 0 1
107552: PPUSH
107553: LD_INT 1
107555: PPUSH
107556: CALL_OW 275
107560: PUSH
107561: LD_VAR 0 1
107565: PPUSH
107566: LD_INT 2
107568: PPUSH
107569: CALL_OW 275
107573: PUSH
107574: LD_VAR 0 1
107578: PPUSH
107579: LD_INT 3
107581: PPUSH
107582: CALL_OW 275
107586: PUSH
107587: EMPTY
107588: LIST
107589: LIST
107590: LIST
107591: ST_TO_ADDR
// end ;
107592: LD_VAR 0 2
107596: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107597: LD_INT 0
107599: PPUSH
107600: PPUSH
// result := array ;
107601: LD_ADDR_VAR 0 3
107605: PUSH
107606: LD_VAR 0 1
107610: ST_TO_ADDR
// if size >= result then
107611: LD_VAR 0 2
107615: PUSH
107616: LD_VAR 0 3
107620: GREATEREQUAL
107621: IFFALSE 107625
// exit ;
107623: GO 107675
// if size then
107625: LD_VAR 0 2
107629: IFFALSE 107675
// for i := array downto size do
107631: LD_ADDR_VAR 0 4
107635: PUSH
107636: DOUBLE
107637: LD_VAR 0 1
107641: INC
107642: ST_TO_ADDR
107643: LD_VAR 0 2
107647: PUSH
107648: FOR_DOWNTO
107649: IFFALSE 107673
// result := Delete ( result , result ) ;
107651: LD_ADDR_VAR 0 3
107655: PUSH
107656: LD_VAR 0 3
107660: PPUSH
107661: LD_VAR 0 3
107665: PPUSH
107666: CALL_OW 3
107670: ST_TO_ADDR
107671: GO 107648
107673: POP
107674: POP
// end ;
107675: LD_VAR 0 3
107679: RET
// export function ComExit ( unit ) ; var tmp ; begin
107680: LD_INT 0
107682: PPUSH
107683: PPUSH
// if not IsInUnit ( unit ) then
107684: LD_VAR 0 1
107688: PPUSH
107689: CALL_OW 310
107693: NOT
107694: IFFALSE 107698
// exit ;
107696: GO 107758
// tmp := IsInUnit ( unit ) ;
107698: LD_ADDR_VAR 0 3
107702: PUSH
107703: LD_VAR 0 1
107707: PPUSH
107708: CALL_OW 310
107712: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107713: LD_VAR 0 3
107717: PPUSH
107718: CALL_OW 247
107722: PUSH
107723: LD_INT 2
107725: EQUAL
107726: IFFALSE 107739
// ComExitVehicle ( unit ) else
107728: LD_VAR 0 1
107732: PPUSH
107733: CALL_OW 121
107737: GO 107748
// ComExitBuilding ( unit ) ;
107739: LD_VAR 0 1
107743: PPUSH
107744: CALL_OW 122
// result := tmp ;
107748: LD_ADDR_VAR 0 2
107752: PUSH
107753: LD_VAR 0 3
107757: ST_TO_ADDR
// end ;
107758: LD_VAR 0 2
107762: RET
// export function ComExitAll ( units ) ; var i ; begin
107763: LD_INT 0
107765: PPUSH
107766: PPUSH
// if not units then
107767: LD_VAR 0 1
107771: NOT
107772: IFFALSE 107776
// exit ;
107774: GO 107802
// for i in units do
107776: LD_ADDR_VAR 0 3
107780: PUSH
107781: LD_VAR 0 1
107785: PUSH
107786: FOR_IN
107787: IFFALSE 107800
// ComExit ( i ) ;
107789: LD_VAR 0 3
107793: PPUSH
107794: CALL 107680 0 1
107798: GO 107786
107800: POP
107801: POP
// end ;
107802: LD_VAR 0 2
107806: RET
// export function ResetHc ; begin
107807: LD_INT 0
107809: PPUSH
// InitHc ;
107810: CALL_OW 19
// hc_importance := 0 ;
107814: LD_ADDR_OWVAR 32
107818: PUSH
107819: LD_INT 0
107821: ST_TO_ADDR
// end ;
107822: LD_VAR 0 1
107826: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107827: LD_INT 0
107829: PPUSH
107830: PPUSH
107831: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107832: LD_ADDR_VAR 0 6
107836: PUSH
107837: LD_VAR 0 1
107841: PUSH
107842: LD_VAR 0 3
107846: PLUS
107847: PUSH
107848: LD_INT 2
107850: DIV
107851: ST_TO_ADDR
// if _x < 0 then
107852: LD_VAR 0 6
107856: PUSH
107857: LD_INT 0
107859: LESS
107860: IFFALSE 107877
// _x := _x * - 1 ;
107862: LD_ADDR_VAR 0 6
107866: PUSH
107867: LD_VAR 0 6
107871: PUSH
107872: LD_INT 1
107874: NEG
107875: MUL
107876: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107877: LD_ADDR_VAR 0 7
107881: PUSH
107882: LD_VAR 0 2
107886: PUSH
107887: LD_VAR 0 4
107891: PLUS
107892: PUSH
107893: LD_INT 2
107895: DIV
107896: ST_TO_ADDR
// if _y < 0 then
107897: LD_VAR 0 7
107901: PUSH
107902: LD_INT 0
107904: LESS
107905: IFFALSE 107922
// _y := _y * - 1 ;
107907: LD_ADDR_VAR 0 7
107911: PUSH
107912: LD_VAR 0 7
107916: PUSH
107917: LD_INT 1
107919: NEG
107920: MUL
107921: ST_TO_ADDR
// result := [ _x , _y ] ;
107922: LD_ADDR_VAR 0 5
107926: PUSH
107927: LD_VAR 0 6
107931: PUSH
107932: LD_VAR 0 7
107936: PUSH
107937: EMPTY
107938: LIST
107939: LIST
107940: ST_TO_ADDR
// end ;
107941: LD_VAR 0 5
107945: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
107946: LD_INT 0
107948: PPUSH
107949: PPUSH
107950: PPUSH
107951: PPUSH
// task := GetTaskList ( unit ) ;
107952: LD_ADDR_VAR 0 7
107956: PUSH
107957: LD_VAR 0 1
107961: PPUSH
107962: CALL_OW 437
107966: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
107967: LD_VAR 0 7
107971: NOT
107972: PUSH
107973: LD_VAR 0 1
107977: PPUSH
107978: LD_VAR 0 2
107982: PPUSH
107983: CALL_OW 308
107987: NOT
107988: AND
107989: IFFALSE 107993
// exit ;
107991: GO 108111
// if IsInArea ( unit , area ) then
107993: LD_VAR 0 1
107997: PPUSH
107998: LD_VAR 0 2
108002: PPUSH
108003: CALL_OW 308
108007: IFFALSE 108025
// begin ComMoveToArea ( unit , goAway ) ;
108009: LD_VAR 0 1
108013: PPUSH
108014: LD_VAR 0 3
108018: PPUSH
108019: CALL_OW 113
// exit ;
108023: GO 108111
// end ; if task [ 1 ] [ 1 ] <> M then
108025: LD_VAR 0 7
108029: PUSH
108030: LD_INT 1
108032: ARRAY
108033: PUSH
108034: LD_INT 1
108036: ARRAY
108037: PUSH
108038: LD_STRING M
108040: NONEQUAL
108041: IFFALSE 108045
// exit ;
108043: GO 108111
// x := task [ 1 ] [ 2 ] ;
108045: LD_ADDR_VAR 0 5
108049: PUSH
108050: LD_VAR 0 7
108054: PUSH
108055: LD_INT 1
108057: ARRAY
108058: PUSH
108059: LD_INT 2
108061: ARRAY
108062: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108063: LD_ADDR_VAR 0 6
108067: PUSH
108068: LD_VAR 0 7
108072: PUSH
108073: LD_INT 1
108075: ARRAY
108076: PUSH
108077: LD_INT 3
108079: ARRAY
108080: ST_TO_ADDR
// if InArea ( x , y , area ) then
108081: LD_VAR 0 5
108085: PPUSH
108086: LD_VAR 0 6
108090: PPUSH
108091: LD_VAR 0 2
108095: PPUSH
108096: CALL_OW 309
108100: IFFALSE 108111
// ComStop ( unit ) ;
108102: LD_VAR 0 1
108106: PPUSH
108107: CALL_OW 141
// end ;
108111: LD_VAR 0 4
108115: RET
// export function Abs ( value ) ; begin
108116: LD_INT 0
108118: PPUSH
// result := value ;
108119: LD_ADDR_VAR 0 2
108123: PUSH
108124: LD_VAR 0 1
108128: ST_TO_ADDR
// if value < 0 then
108129: LD_VAR 0 1
108133: PUSH
108134: LD_INT 0
108136: LESS
108137: IFFALSE 108154
// result := value * - 1 ;
108139: LD_ADDR_VAR 0 2
108143: PUSH
108144: LD_VAR 0 1
108148: PUSH
108149: LD_INT 1
108151: NEG
108152: MUL
108153: ST_TO_ADDR
// end ;
108154: LD_VAR 0 2
108158: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108159: LD_INT 0
108161: PPUSH
108162: PPUSH
108163: PPUSH
108164: PPUSH
108165: PPUSH
108166: PPUSH
108167: PPUSH
108168: PPUSH
// if not unit or not building then
108169: LD_VAR 0 1
108173: NOT
108174: PUSH
108175: LD_VAR 0 2
108179: NOT
108180: OR
108181: IFFALSE 108185
// exit ;
108183: GO 108411
// x := GetX ( building ) ;
108185: LD_ADDR_VAR 0 4
108189: PUSH
108190: LD_VAR 0 2
108194: PPUSH
108195: CALL_OW 250
108199: ST_TO_ADDR
// y := GetY ( building ) ;
108200: LD_ADDR_VAR 0 6
108204: PUSH
108205: LD_VAR 0 2
108209: PPUSH
108210: CALL_OW 251
108214: ST_TO_ADDR
// d := GetDir ( building ) ;
108215: LD_ADDR_VAR 0 8
108219: PUSH
108220: LD_VAR 0 2
108224: PPUSH
108225: CALL_OW 254
108229: ST_TO_ADDR
// r := 4 ;
108230: LD_ADDR_VAR 0 9
108234: PUSH
108235: LD_INT 4
108237: ST_TO_ADDR
// for i := 1 to 5 do
108238: LD_ADDR_VAR 0 10
108242: PUSH
108243: DOUBLE
108244: LD_INT 1
108246: DEC
108247: ST_TO_ADDR
108248: LD_INT 5
108250: PUSH
108251: FOR_TO
108252: IFFALSE 108409
// begin _x := ShiftX ( x , d , r + i ) ;
108254: LD_ADDR_VAR 0 5
108258: PUSH
108259: LD_VAR 0 4
108263: PPUSH
108264: LD_VAR 0 8
108268: PPUSH
108269: LD_VAR 0 9
108273: PUSH
108274: LD_VAR 0 10
108278: PLUS
108279: PPUSH
108280: CALL_OW 272
108284: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108285: LD_ADDR_VAR 0 7
108289: PUSH
108290: LD_VAR 0 6
108294: PPUSH
108295: LD_VAR 0 8
108299: PPUSH
108300: LD_VAR 0 9
108304: PUSH
108305: LD_VAR 0 10
108309: PLUS
108310: PPUSH
108311: CALL_OW 273
108315: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108316: LD_VAR 0 5
108320: PPUSH
108321: LD_VAR 0 7
108325: PPUSH
108326: CALL_OW 488
108330: PUSH
108331: LD_VAR 0 5
108335: PPUSH
108336: LD_VAR 0 7
108340: PPUSH
108341: CALL_OW 428
108345: PPUSH
108346: CALL_OW 247
108350: PUSH
108351: LD_INT 3
108353: PUSH
108354: LD_INT 2
108356: PUSH
108357: EMPTY
108358: LIST
108359: LIST
108360: IN
108361: NOT
108362: AND
108363: IFFALSE 108407
// begin ComMoveXY ( unit , _x , _y ) ;
108365: LD_VAR 0 1
108369: PPUSH
108370: LD_VAR 0 5
108374: PPUSH
108375: LD_VAR 0 7
108379: PPUSH
108380: CALL_OW 111
// result := [ _x , _y ] ;
108384: LD_ADDR_VAR 0 3
108388: PUSH
108389: LD_VAR 0 5
108393: PUSH
108394: LD_VAR 0 7
108398: PUSH
108399: EMPTY
108400: LIST
108401: LIST
108402: ST_TO_ADDR
// exit ;
108403: POP
108404: POP
108405: GO 108411
// end ; end ;
108407: GO 108251
108409: POP
108410: POP
// end ;
108411: LD_VAR 0 3
108415: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108416: LD_INT 0
108418: PPUSH
108419: PPUSH
108420: PPUSH
// result := 0 ;
108421: LD_ADDR_VAR 0 3
108425: PUSH
108426: LD_INT 0
108428: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108429: LD_VAR 0 1
108433: PUSH
108434: LD_INT 0
108436: LESS
108437: PUSH
108438: LD_VAR 0 1
108442: PUSH
108443: LD_INT 8
108445: GREATER
108446: OR
108447: PUSH
108448: LD_VAR 0 2
108452: PUSH
108453: LD_INT 0
108455: LESS
108456: OR
108457: PUSH
108458: LD_VAR 0 2
108462: PUSH
108463: LD_INT 8
108465: GREATER
108466: OR
108467: IFFALSE 108471
// exit ;
108469: GO 108546
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108471: LD_ADDR_VAR 0 4
108475: PUSH
108476: LD_INT 22
108478: PUSH
108479: LD_VAR 0 2
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: PPUSH
108488: CALL_OW 69
108492: PUSH
108493: FOR_IN
108494: IFFALSE 108544
// begin un := UnitShoot ( i ) ;
108496: LD_ADDR_VAR 0 5
108500: PUSH
108501: LD_VAR 0 4
108505: PPUSH
108506: CALL_OW 504
108510: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108511: LD_VAR 0 5
108515: PPUSH
108516: CALL_OW 255
108520: PUSH
108521: LD_VAR 0 1
108525: EQUAL
108526: IFFALSE 108542
// begin result := un ;
108528: LD_ADDR_VAR 0 3
108532: PUSH
108533: LD_VAR 0 5
108537: ST_TO_ADDR
// exit ;
108538: POP
108539: POP
108540: GO 108546
// end ; end ;
108542: GO 108493
108544: POP
108545: POP
// end ;
108546: LD_VAR 0 3
108550: RET
// export function GetCargoBay ( units ) ; begin
108551: LD_INT 0
108553: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108554: LD_ADDR_VAR 0 2
108558: PUSH
108559: LD_VAR 0 1
108563: PPUSH
108564: LD_INT 2
108566: PUSH
108567: LD_INT 34
108569: PUSH
108570: LD_INT 12
108572: PUSH
108573: EMPTY
108574: LIST
108575: LIST
108576: PUSH
108577: LD_INT 34
108579: PUSH
108580: LD_INT 51
108582: PUSH
108583: EMPTY
108584: LIST
108585: LIST
108586: PUSH
108587: LD_INT 34
108589: PUSH
108590: LD_INT 32
108592: PUSH
108593: EMPTY
108594: LIST
108595: LIST
108596: PUSH
108597: LD_INT 34
108599: PUSH
108600: LD_INT 89
108602: PUSH
108603: EMPTY
108604: LIST
108605: LIST
108606: PUSH
108607: EMPTY
108608: LIST
108609: LIST
108610: LIST
108611: LIST
108612: LIST
108613: PPUSH
108614: CALL_OW 72
108618: ST_TO_ADDR
// end ;
108619: LD_VAR 0 2
108623: RET
// export function Negate ( value ) ; begin
108624: LD_INT 0
108626: PPUSH
// result := not value ;
108627: LD_ADDR_VAR 0 2
108631: PUSH
108632: LD_VAR 0 1
108636: NOT
108637: ST_TO_ADDR
// end ;
108638: LD_VAR 0 2
108642: RET
// export function Inc ( value ) ; begin
108643: LD_INT 0
108645: PPUSH
// result := value + 1 ;
108646: LD_ADDR_VAR 0 2
108650: PUSH
108651: LD_VAR 0 1
108655: PUSH
108656: LD_INT 1
108658: PLUS
108659: ST_TO_ADDR
// end ;
108660: LD_VAR 0 2
108664: RET
// export function Dec ( value ) ; begin
108665: LD_INT 0
108667: PPUSH
// result := value - 1 ;
108668: LD_ADDR_VAR 0 2
108672: PUSH
108673: LD_VAR 0 1
108677: PUSH
108678: LD_INT 1
108680: MINUS
108681: ST_TO_ADDR
// end ;
108682: LD_VAR 0 2
108686: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108687: LD_INT 0
108689: PPUSH
108690: PPUSH
108691: PPUSH
108692: PPUSH
108693: PPUSH
108694: PPUSH
108695: PPUSH
108696: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108697: LD_VAR 0 1
108701: PPUSH
108702: LD_VAR 0 2
108706: PPUSH
108707: CALL_OW 488
108711: NOT
108712: PUSH
108713: LD_VAR 0 3
108717: PPUSH
108718: LD_VAR 0 4
108722: PPUSH
108723: CALL_OW 488
108727: NOT
108728: OR
108729: IFFALSE 108742
// begin result := - 1 ;
108731: LD_ADDR_VAR 0 5
108735: PUSH
108736: LD_INT 1
108738: NEG
108739: ST_TO_ADDR
// exit ;
108740: GO 108977
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108742: LD_ADDR_VAR 0 12
108746: PUSH
108747: LD_VAR 0 1
108751: PPUSH
108752: LD_VAR 0 2
108756: PPUSH
108757: LD_VAR 0 3
108761: PPUSH
108762: LD_VAR 0 4
108766: PPUSH
108767: CALL 107827 0 4
108771: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108772: LD_ADDR_VAR 0 11
108776: PUSH
108777: LD_VAR 0 1
108781: PPUSH
108782: LD_VAR 0 2
108786: PPUSH
108787: LD_VAR 0 12
108791: PUSH
108792: LD_INT 1
108794: ARRAY
108795: PPUSH
108796: LD_VAR 0 12
108800: PUSH
108801: LD_INT 2
108803: ARRAY
108804: PPUSH
108805: CALL_OW 298
108809: ST_TO_ADDR
// distance := 9999 ;
108810: LD_ADDR_VAR 0 10
108814: PUSH
108815: LD_INT 9999
108817: ST_TO_ADDR
// for i := 0 to 5 do
108818: LD_ADDR_VAR 0 6
108822: PUSH
108823: DOUBLE
108824: LD_INT 0
108826: DEC
108827: ST_TO_ADDR
108828: LD_INT 5
108830: PUSH
108831: FOR_TO
108832: IFFALSE 108975
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108834: LD_ADDR_VAR 0 7
108838: PUSH
108839: LD_VAR 0 1
108843: PPUSH
108844: LD_VAR 0 6
108848: PPUSH
108849: LD_VAR 0 11
108853: PPUSH
108854: CALL_OW 272
108858: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108859: LD_ADDR_VAR 0 8
108863: PUSH
108864: LD_VAR 0 2
108868: PPUSH
108869: LD_VAR 0 6
108873: PPUSH
108874: LD_VAR 0 11
108878: PPUSH
108879: CALL_OW 273
108883: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108884: LD_VAR 0 7
108888: PPUSH
108889: LD_VAR 0 8
108893: PPUSH
108894: CALL_OW 488
108898: NOT
108899: IFFALSE 108903
// continue ;
108901: GO 108831
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108903: LD_ADDR_VAR 0 9
108907: PUSH
108908: LD_VAR 0 12
108912: PUSH
108913: LD_INT 1
108915: ARRAY
108916: PPUSH
108917: LD_VAR 0 12
108921: PUSH
108922: LD_INT 2
108924: ARRAY
108925: PPUSH
108926: LD_VAR 0 7
108930: PPUSH
108931: LD_VAR 0 8
108935: PPUSH
108936: CALL_OW 298
108940: ST_TO_ADDR
// if tmp < distance then
108941: LD_VAR 0 9
108945: PUSH
108946: LD_VAR 0 10
108950: LESS
108951: IFFALSE 108973
// begin result := i ;
108953: LD_ADDR_VAR 0 5
108957: PUSH
108958: LD_VAR 0 6
108962: ST_TO_ADDR
// distance := tmp ;
108963: LD_ADDR_VAR 0 10
108967: PUSH
108968: LD_VAR 0 9
108972: ST_TO_ADDR
// end ; end ;
108973: GO 108831
108975: POP
108976: POP
// end ;
108977: LD_VAR 0 5
108981: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108982: LD_INT 0
108984: PPUSH
108985: PPUSH
// if not driver or not IsInUnit ( driver ) then
108986: LD_VAR 0 1
108990: NOT
108991: PUSH
108992: LD_VAR 0 1
108996: PPUSH
108997: CALL_OW 310
109001: NOT
109002: OR
109003: IFFALSE 109007
// exit ;
109005: GO 109097
// vehicle := IsInUnit ( driver ) ;
109007: LD_ADDR_VAR 0 3
109011: PUSH
109012: LD_VAR 0 1
109016: PPUSH
109017: CALL_OW 310
109021: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109022: LD_VAR 0 1
109026: PPUSH
109027: LD_STRING \
109029: PUSH
109030: LD_INT 0
109032: PUSH
109033: LD_INT 0
109035: PUSH
109036: LD_INT 0
109038: PUSH
109039: LD_INT 0
109041: PUSH
109042: LD_INT 0
109044: PUSH
109045: LD_INT 0
109047: PUSH
109048: EMPTY
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: LIST
109056: PUSH
109057: LD_STRING E
109059: PUSH
109060: LD_INT 0
109062: PUSH
109063: LD_INT 0
109065: PUSH
109066: LD_VAR 0 3
109070: PUSH
109071: LD_INT 0
109073: PUSH
109074: LD_INT 0
109076: PUSH
109077: LD_INT 0
109079: PUSH
109080: EMPTY
109081: LIST
109082: LIST
109083: LIST
109084: LIST
109085: LIST
109086: LIST
109087: LIST
109088: PUSH
109089: EMPTY
109090: LIST
109091: LIST
109092: PPUSH
109093: CALL_OW 446
// end ;
109097: LD_VAR 0 2
109101: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109102: LD_INT 0
109104: PPUSH
109105: PPUSH
// if not driver or not IsInUnit ( driver ) then
109106: LD_VAR 0 1
109110: NOT
109111: PUSH
109112: LD_VAR 0 1
109116: PPUSH
109117: CALL_OW 310
109121: NOT
109122: OR
109123: IFFALSE 109127
// exit ;
109125: GO 109217
// vehicle := IsInUnit ( driver ) ;
109127: LD_ADDR_VAR 0 3
109131: PUSH
109132: LD_VAR 0 1
109136: PPUSH
109137: CALL_OW 310
109141: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109142: LD_VAR 0 1
109146: PPUSH
109147: LD_STRING \
109149: PUSH
109150: LD_INT 0
109152: PUSH
109153: LD_INT 0
109155: PUSH
109156: LD_INT 0
109158: PUSH
109159: LD_INT 0
109161: PUSH
109162: LD_INT 0
109164: PUSH
109165: LD_INT 0
109167: PUSH
109168: EMPTY
109169: LIST
109170: LIST
109171: LIST
109172: LIST
109173: LIST
109174: LIST
109175: LIST
109176: PUSH
109177: LD_STRING E
109179: PUSH
109180: LD_INT 0
109182: PUSH
109183: LD_INT 0
109185: PUSH
109186: LD_VAR 0 3
109190: PUSH
109191: LD_INT 0
109193: PUSH
109194: LD_INT 0
109196: PUSH
109197: LD_INT 0
109199: PUSH
109200: EMPTY
109201: LIST
109202: LIST
109203: LIST
109204: LIST
109205: LIST
109206: LIST
109207: LIST
109208: PUSH
109209: EMPTY
109210: LIST
109211: LIST
109212: PPUSH
109213: CALL_OW 447
// end ;
109217: LD_VAR 0 2
109221: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109222: LD_INT 0
109224: PPUSH
109225: PPUSH
109226: PPUSH
// tmp := [ ] ;
109227: LD_ADDR_VAR 0 5
109231: PUSH
109232: EMPTY
109233: ST_TO_ADDR
// for i in units do
109234: LD_ADDR_VAR 0 4
109238: PUSH
109239: LD_VAR 0 1
109243: PUSH
109244: FOR_IN
109245: IFFALSE 109283
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109247: LD_ADDR_VAR 0 5
109251: PUSH
109252: LD_VAR 0 5
109256: PPUSH
109257: LD_VAR 0 5
109261: PUSH
109262: LD_INT 1
109264: PLUS
109265: PPUSH
109266: LD_VAR 0 4
109270: PPUSH
109271: CALL_OW 256
109275: PPUSH
109276: CALL_OW 2
109280: ST_TO_ADDR
109281: GO 109244
109283: POP
109284: POP
// if not tmp then
109285: LD_VAR 0 5
109289: NOT
109290: IFFALSE 109294
// exit ;
109292: GO 109342
// if asc then
109294: LD_VAR 0 2
109298: IFFALSE 109322
// result := SortListByListAsc ( units , tmp ) else
109300: LD_ADDR_VAR 0 3
109304: PUSH
109305: LD_VAR 0 1
109309: PPUSH
109310: LD_VAR 0 5
109314: PPUSH
109315: CALL_OW 76
109319: ST_TO_ADDR
109320: GO 109342
// result := SortListByListDesc ( units , tmp ) ;
109322: LD_ADDR_VAR 0 3
109326: PUSH
109327: LD_VAR 0 1
109331: PPUSH
109332: LD_VAR 0 5
109336: PPUSH
109337: CALL_OW 77
109341: ST_TO_ADDR
// end ;
109342: LD_VAR 0 3
109346: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109347: LD_INT 0
109349: PPUSH
109350: PPUSH
// task := GetTaskList ( mech ) ;
109351: LD_ADDR_VAR 0 4
109355: PUSH
109356: LD_VAR 0 1
109360: PPUSH
109361: CALL_OW 437
109365: ST_TO_ADDR
// if not task then
109366: LD_VAR 0 4
109370: NOT
109371: IFFALSE 109375
// exit ;
109373: GO 109417
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109375: LD_ADDR_VAR 0 3
109379: PUSH
109380: LD_VAR 0 4
109384: PUSH
109385: LD_INT 1
109387: ARRAY
109388: PUSH
109389: LD_INT 1
109391: ARRAY
109392: PUSH
109393: LD_STRING r
109395: EQUAL
109396: PUSH
109397: LD_VAR 0 4
109401: PUSH
109402: LD_INT 1
109404: ARRAY
109405: PUSH
109406: LD_INT 4
109408: ARRAY
109409: PUSH
109410: LD_VAR 0 2
109414: EQUAL
109415: AND
109416: ST_TO_ADDR
// end ;
109417: LD_VAR 0 3
109421: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109422: LD_INT 0
109424: PPUSH
// SetDir ( unit , d ) ;
109425: LD_VAR 0 1
109429: PPUSH
109430: LD_VAR 0 4
109434: PPUSH
109435: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109439: LD_VAR 0 1
109443: PPUSH
109444: LD_VAR 0 2
109448: PPUSH
109449: LD_VAR 0 3
109453: PPUSH
109454: LD_VAR 0 5
109458: PPUSH
109459: CALL_OW 48
// end ;
109463: LD_VAR 0 6
109467: RET
// export function ToNaturalNumber ( number ) ; begin
109468: LD_INT 0
109470: PPUSH
// result := number div 1 ;
109471: LD_ADDR_VAR 0 2
109475: PUSH
109476: LD_VAR 0 1
109480: PUSH
109481: LD_INT 1
109483: DIV
109484: ST_TO_ADDR
// if number < 0 then
109485: LD_VAR 0 1
109489: PUSH
109490: LD_INT 0
109492: LESS
109493: IFFALSE 109503
// result := 0 ;
109495: LD_ADDR_VAR 0 2
109499: PUSH
109500: LD_INT 0
109502: ST_TO_ADDR
// end ;
109503: LD_VAR 0 2
109507: RET
// export function SortByClass ( units , class ) ; var un ; begin
109508: LD_INT 0
109510: PPUSH
109511: PPUSH
// if not units or not class then
109512: LD_VAR 0 1
109516: NOT
109517: PUSH
109518: LD_VAR 0 2
109522: NOT
109523: OR
109524: IFFALSE 109528
// exit ;
109526: GO 109623
// result := [ ] ;
109528: LD_ADDR_VAR 0 3
109532: PUSH
109533: EMPTY
109534: ST_TO_ADDR
// for un in units do
109535: LD_ADDR_VAR 0 4
109539: PUSH
109540: LD_VAR 0 1
109544: PUSH
109545: FOR_IN
109546: IFFALSE 109621
// if GetClass ( un ) = class then
109548: LD_VAR 0 4
109552: PPUSH
109553: CALL_OW 257
109557: PUSH
109558: LD_VAR 0 2
109562: EQUAL
109563: IFFALSE 109590
// result := Insert ( result , 1 , un ) else
109565: LD_ADDR_VAR 0 3
109569: PUSH
109570: LD_VAR 0 3
109574: PPUSH
109575: LD_INT 1
109577: PPUSH
109578: LD_VAR 0 4
109582: PPUSH
109583: CALL_OW 2
109587: ST_TO_ADDR
109588: GO 109619
// result := Replace ( result , result + 1 , un ) ;
109590: LD_ADDR_VAR 0 3
109594: PUSH
109595: LD_VAR 0 3
109599: PPUSH
109600: LD_VAR 0 3
109604: PUSH
109605: LD_INT 1
109607: PLUS
109608: PPUSH
109609: LD_VAR 0 4
109613: PPUSH
109614: CALL_OW 1
109618: ST_TO_ADDR
109619: GO 109545
109621: POP
109622: POP
// end ;
109623: LD_VAR 0 3
109627: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109628: LD_INT 0
109630: PPUSH
109631: PPUSH
109632: PPUSH
109633: PPUSH
109634: PPUSH
109635: PPUSH
109636: PPUSH
// result := [ ] ;
109637: LD_ADDR_VAR 0 4
109641: PUSH
109642: EMPTY
109643: ST_TO_ADDR
// if x - r < 0 then
109644: LD_VAR 0 1
109648: PUSH
109649: LD_VAR 0 3
109653: MINUS
109654: PUSH
109655: LD_INT 0
109657: LESS
109658: IFFALSE 109670
// min_x := 0 else
109660: LD_ADDR_VAR 0 8
109664: PUSH
109665: LD_INT 0
109667: ST_TO_ADDR
109668: GO 109686
// min_x := x - r ;
109670: LD_ADDR_VAR 0 8
109674: PUSH
109675: LD_VAR 0 1
109679: PUSH
109680: LD_VAR 0 3
109684: MINUS
109685: ST_TO_ADDR
// if y - r < 0 then
109686: LD_VAR 0 2
109690: PUSH
109691: LD_VAR 0 3
109695: MINUS
109696: PUSH
109697: LD_INT 0
109699: LESS
109700: IFFALSE 109712
// min_y := 0 else
109702: LD_ADDR_VAR 0 7
109706: PUSH
109707: LD_INT 0
109709: ST_TO_ADDR
109710: GO 109728
// min_y := y - r ;
109712: LD_ADDR_VAR 0 7
109716: PUSH
109717: LD_VAR 0 2
109721: PUSH
109722: LD_VAR 0 3
109726: MINUS
109727: ST_TO_ADDR
// max_x := x + r ;
109728: LD_ADDR_VAR 0 9
109732: PUSH
109733: LD_VAR 0 1
109737: PUSH
109738: LD_VAR 0 3
109742: PLUS
109743: ST_TO_ADDR
// max_y := y + r ;
109744: LD_ADDR_VAR 0 10
109748: PUSH
109749: LD_VAR 0 2
109753: PUSH
109754: LD_VAR 0 3
109758: PLUS
109759: ST_TO_ADDR
// for _x = min_x to max_x do
109760: LD_ADDR_VAR 0 5
109764: PUSH
109765: DOUBLE
109766: LD_VAR 0 8
109770: DEC
109771: ST_TO_ADDR
109772: LD_VAR 0 9
109776: PUSH
109777: FOR_TO
109778: IFFALSE 109879
// for _y = min_y to max_y do
109780: LD_ADDR_VAR 0 6
109784: PUSH
109785: DOUBLE
109786: LD_VAR 0 7
109790: DEC
109791: ST_TO_ADDR
109792: LD_VAR 0 10
109796: PUSH
109797: FOR_TO
109798: IFFALSE 109875
// begin if not ValidHex ( _x , _y ) then
109800: LD_VAR 0 5
109804: PPUSH
109805: LD_VAR 0 6
109809: PPUSH
109810: CALL_OW 488
109814: NOT
109815: IFFALSE 109819
// continue ;
109817: GO 109797
// if GetResourceTypeXY ( _x , _y ) then
109819: LD_VAR 0 5
109823: PPUSH
109824: LD_VAR 0 6
109828: PPUSH
109829: CALL_OW 283
109833: IFFALSE 109873
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109835: LD_ADDR_VAR 0 4
109839: PUSH
109840: LD_VAR 0 4
109844: PPUSH
109845: LD_VAR 0 4
109849: PUSH
109850: LD_INT 1
109852: PLUS
109853: PPUSH
109854: LD_VAR 0 5
109858: PUSH
109859: LD_VAR 0 6
109863: PUSH
109864: EMPTY
109865: LIST
109866: LIST
109867: PPUSH
109868: CALL_OW 1
109872: ST_TO_ADDR
// end ;
109873: GO 109797
109875: POP
109876: POP
109877: GO 109777
109879: POP
109880: POP
// end ;
109881: LD_VAR 0 4
109885: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109886: LD_INT 0
109888: PPUSH
109889: PPUSH
109890: PPUSH
109891: PPUSH
109892: PPUSH
109893: PPUSH
109894: PPUSH
109895: PPUSH
// if not units then
109896: LD_VAR 0 1
109900: NOT
109901: IFFALSE 109905
// exit ;
109903: GO 110429
// result := UnitFilter ( units , [ f_ok ] ) ;
109905: LD_ADDR_VAR 0 3
109909: PUSH
109910: LD_VAR 0 1
109914: PPUSH
109915: LD_INT 50
109917: PUSH
109918: EMPTY
109919: LIST
109920: PPUSH
109921: CALL_OW 72
109925: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
109926: LD_ADDR_VAR 0 8
109930: PUSH
109931: LD_VAR 0 1
109935: PUSH
109936: LD_INT 1
109938: ARRAY
109939: PPUSH
109940: CALL_OW 255
109944: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
109945: LD_ADDR_VAR 0 10
109949: PUSH
109950: LD_INT 29
109952: PUSH
109953: LD_INT 91
109955: PUSH
109956: LD_INT 49
109958: PUSH
109959: EMPTY
109960: LIST
109961: LIST
109962: LIST
109963: ST_TO_ADDR
// if not result then
109964: LD_VAR 0 3
109968: NOT
109969: IFFALSE 109973
// exit ;
109971: GO 110429
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
109973: LD_ADDR_VAR 0 5
109977: PUSH
109978: LD_INT 81
109980: PUSH
109981: LD_VAR 0 8
109985: PUSH
109986: EMPTY
109987: LIST
109988: LIST
109989: PPUSH
109990: CALL_OW 69
109994: ST_TO_ADDR
// for i in result do
109995: LD_ADDR_VAR 0 4
109999: PUSH
110000: LD_VAR 0 3
110004: PUSH
110005: FOR_IN
110006: IFFALSE 110427
// begin tag := GetTag ( i ) + 1 ;
110008: LD_ADDR_VAR 0 9
110012: PUSH
110013: LD_VAR 0 4
110017: PPUSH
110018: CALL_OW 110
110022: PUSH
110023: LD_INT 1
110025: PLUS
110026: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
110027: LD_ADDR_VAR 0 7
110031: PUSH
110032: LD_VAR 0 4
110036: PPUSH
110037: CALL_OW 250
110041: PPUSH
110042: LD_VAR 0 4
110046: PPUSH
110047: CALL_OW 251
110051: PPUSH
110052: LD_INT 6
110054: PPUSH
110055: CALL 109628 0 3
110059: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
110060: LD_VAR 0 4
110064: PPUSH
110065: CALL_OW 247
110069: PUSH
110070: LD_INT 2
110072: EQUAL
110073: PUSH
110074: LD_VAR 0 7
110078: AND
110079: PUSH
110080: LD_VAR 0 4
110084: PPUSH
110085: CALL_OW 264
110089: PUSH
110090: LD_VAR 0 10
110094: IN
110095: NOT
110096: AND
110097: IFFALSE 110136
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110099: LD_VAR 0 4
110103: PPUSH
110104: LD_VAR 0 7
110108: PUSH
110109: LD_INT 1
110111: ARRAY
110112: PUSH
110113: LD_INT 1
110115: ARRAY
110116: PPUSH
110117: LD_VAR 0 7
110121: PUSH
110122: LD_INT 1
110124: ARRAY
110125: PUSH
110126: LD_INT 2
110128: ARRAY
110129: PPUSH
110130: CALL_OW 116
110134: GO 110425
// if path > tag then
110136: LD_VAR 0 2
110140: PUSH
110141: LD_VAR 0 9
110145: GREATER
110146: IFFALSE 110354
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110148: LD_ADDR_VAR 0 6
110152: PUSH
110153: LD_VAR 0 5
110157: PPUSH
110158: LD_INT 91
110160: PUSH
110161: LD_VAR 0 4
110165: PUSH
110166: LD_INT 8
110168: PUSH
110169: EMPTY
110170: LIST
110171: LIST
110172: LIST
110173: PPUSH
110174: CALL_OW 72
110178: ST_TO_ADDR
// if nearEnemy then
110179: LD_VAR 0 6
110183: IFFALSE 110252
// begin if GetWeapon ( i ) = ru_time_lapser then
110185: LD_VAR 0 4
110189: PPUSH
110190: CALL_OW 264
110194: PUSH
110195: LD_INT 49
110197: EQUAL
110198: IFFALSE 110226
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110200: LD_VAR 0 4
110204: PPUSH
110205: LD_VAR 0 6
110209: PPUSH
110210: LD_VAR 0 4
110214: PPUSH
110215: CALL_OW 74
110219: PPUSH
110220: CALL_OW 112
110224: GO 110250
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110226: LD_VAR 0 4
110230: PPUSH
110231: LD_VAR 0 6
110235: PPUSH
110236: LD_VAR 0 4
110240: PPUSH
110241: CALL_OW 74
110245: PPUSH
110246: CALL 111500 0 2
// end else
110250: GO 110352
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110252: LD_VAR 0 4
110256: PPUSH
110257: LD_VAR 0 2
110261: PUSH
110262: LD_VAR 0 9
110266: ARRAY
110267: PUSH
110268: LD_INT 1
110270: ARRAY
110271: PPUSH
110272: LD_VAR 0 2
110276: PUSH
110277: LD_VAR 0 9
110281: ARRAY
110282: PUSH
110283: LD_INT 2
110285: ARRAY
110286: PPUSH
110287: CALL_OW 297
110291: PUSH
110292: LD_INT 6
110294: GREATER
110295: IFFALSE 110338
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110297: LD_VAR 0 4
110301: PPUSH
110302: LD_VAR 0 2
110306: PUSH
110307: LD_VAR 0 9
110311: ARRAY
110312: PUSH
110313: LD_INT 1
110315: ARRAY
110316: PPUSH
110317: LD_VAR 0 2
110321: PUSH
110322: LD_VAR 0 9
110326: ARRAY
110327: PUSH
110328: LD_INT 2
110330: ARRAY
110331: PPUSH
110332: CALL_OW 114
110336: GO 110352
// SetTag ( i , tag ) ;
110338: LD_VAR 0 4
110342: PPUSH
110343: LD_VAR 0 9
110347: PPUSH
110348: CALL_OW 109
// end else
110352: GO 110425
// if enemy then
110354: LD_VAR 0 5
110358: IFFALSE 110425
// begin if GetWeapon ( i ) = ru_time_lapser then
110360: LD_VAR 0 4
110364: PPUSH
110365: CALL_OW 264
110369: PUSH
110370: LD_INT 49
110372: EQUAL
110373: IFFALSE 110401
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110375: LD_VAR 0 4
110379: PPUSH
110380: LD_VAR 0 5
110384: PPUSH
110385: LD_VAR 0 4
110389: PPUSH
110390: CALL_OW 74
110394: PPUSH
110395: CALL_OW 112
110399: GO 110425
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110401: LD_VAR 0 4
110405: PPUSH
110406: LD_VAR 0 5
110410: PPUSH
110411: LD_VAR 0 4
110415: PPUSH
110416: CALL_OW 74
110420: PPUSH
110421: CALL 111500 0 2
// end ; end ;
110425: GO 110005
110427: POP
110428: POP
// end ;
110429: LD_VAR 0 3
110433: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110434: LD_INT 0
110436: PPUSH
110437: PPUSH
110438: PPUSH
// if not unit or IsInUnit ( unit ) then
110439: LD_VAR 0 1
110443: NOT
110444: PUSH
110445: LD_VAR 0 1
110449: PPUSH
110450: CALL_OW 310
110454: OR
110455: IFFALSE 110459
// exit ;
110457: GO 110550
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110459: LD_ADDR_VAR 0 4
110463: PUSH
110464: LD_VAR 0 1
110468: PPUSH
110469: CALL_OW 250
110473: PPUSH
110474: LD_VAR 0 2
110478: PPUSH
110479: LD_INT 1
110481: PPUSH
110482: CALL_OW 272
110486: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110487: LD_ADDR_VAR 0 5
110491: PUSH
110492: LD_VAR 0 1
110496: PPUSH
110497: CALL_OW 251
110501: PPUSH
110502: LD_VAR 0 2
110506: PPUSH
110507: LD_INT 1
110509: PPUSH
110510: CALL_OW 273
110514: ST_TO_ADDR
// if ValidHex ( x , y ) then
110515: LD_VAR 0 4
110519: PPUSH
110520: LD_VAR 0 5
110524: PPUSH
110525: CALL_OW 488
110529: IFFALSE 110550
// ComTurnXY ( unit , x , y ) ;
110531: LD_VAR 0 1
110535: PPUSH
110536: LD_VAR 0 4
110540: PPUSH
110541: LD_VAR 0 5
110545: PPUSH
110546: CALL_OW 118
// end ;
110550: LD_VAR 0 3
110554: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110555: LD_INT 0
110557: PPUSH
110558: PPUSH
// result := false ;
110559: LD_ADDR_VAR 0 3
110563: PUSH
110564: LD_INT 0
110566: ST_TO_ADDR
// if not units then
110567: LD_VAR 0 2
110571: NOT
110572: IFFALSE 110576
// exit ;
110574: GO 110621
// for i in units do
110576: LD_ADDR_VAR 0 4
110580: PUSH
110581: LD_VAR 0 2
110585: PUSH
110586: FOR_IN
110587: IFFALSE 110619
// if See ( side , i ) then
110589: LD_VAR 0 1
110593: PPUSH
110594: LD_VAR 0 4
110598: PPUSH
110599: CALL_OW 292
110603: IFFALSE 110617
// begin result := true ;
110605: LD_ADDR_VAR 0 3
110609: PUSH
110610: LD_INT 1
110612: ST_TO_ADDR
// exit ;
110613: POP
110614: POP
110615: GO 110621
// end ;
110617: GO 110586
110619: POP
110620: POP
// end ;
110621: LD_VAR 0 3
110625: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110626: LD_INT 0
110628: PPUSH
110629: PPUSH
110630: PPUSH
110631: PPUSH
// if not unit or not points then
110632: LD_VAR 0 1
110636: NOT
110637: PUSH
110638: LD_VAR 0 2
110642: NOT
110643: OR
110644: IFFALSE 110648
// exit ;
110646: GO 110738
// dist := 99999 ;
110648: LD_ADDR_VAR 0 5
110652: PUSH
110653: LD_INT 99999
110655: ST_TO_ADDR
// for i in points do
110656: LD_ADDR_VAR 0 4
110660: PUSH
110661: LD_VAR 0 2
110665: PUSH
110666: FOR_IN
110667: IFFALSE 110736
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110669: LD_ADDR_VAR 0 6
110673: PUSH
110674: LD_VAR 0 1
110678: PPUSH
110679: LD_VAR 0 4
110683: PUSH
110684: LD_INT 1
110686: ARRAY
110687: PPUSH
110688: LD_VAR 0 4
110692: PUSH
110693: LD_INT 2
110695: ARRAY
110696: PPUSH
110697: CALL_OW 297
110701: ST_TO_ADDR
// if tmpDist < dist then
110702: LD_VAR 0 6
110706: PUSH
110707: LD_VAR 0 5
110711: LESS
110712: IFFALSE 110734
// begin result := i ;
110714: LD_ADDR_VAR 0 3
110718: PUSH
110719: LD_VAR 0 4
110723: ST_TO_ADDR
// dist := tmpDist ;
110724: LD_ADDR_VAR 0 5
110728: PUSH
110729: LD_VAR 0 6
110733: ST_TO_ADDR
// end ; end ;
110734: GO 110666
110736: POP
110737: POP
// end ;
110738: LD_VAR 0 3
110742: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110743: LD_INT 0
110745: PPUSH
// uc_side := side ;
110746: LD_ADDR_OWVAR 20
110750: PUSH
110751: LD_VAR 0 1
110755: ST_TO_ADDR
// uc_nation := 3 ;
110756: LD_ADDR_OWVAR 21
110760: PUSH
110761: LD_INT 3
110763: ST_TO_ADDR
// vc_chassis := 25 ;
110764: LD_ADDR_OWVAR 37
110768: PUSH
110769: LD_INT 25
110771: ST_TO_ADDR
// vc_engine := engine_siberite ;
110772: LD_ADDR_OWVAR 39
110776: PUSH
110777: LD_INT 3
110779: ST_TO_ADDR
// vc_control := control_computer ;
110780: LD_ADDR_OWVAR 38
110784: PUSH
110785: LD_INT 3
110787: ST_TO_ADDR
// vc_weapon := 59 ;
110788: LD_ADDR_OWVAR 40
110792: PUSH
110793: LD_INT 59
110795: ST_TO_ADDR
// result := CreateVehicle ;
110796: LD_ADDR_VAR 0 5
110800: PUSH
110801: CALL_OW 45
110805: ST_TO_ADDR
// SetDir ( result , d ) ;
110806: LD_VAR 0 5
110810: PPUSH
110811: LD_VAR 0 4
110815: PPUSH
110816: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110820: LD_VAR 0 5
110824: PPUSH
110825: LD_VAR 0 2
110829: PPUSH
110830: LD_VAR 0 3
110834: PPUSH
110835: LD_INT 0
110837: PPUSH
110838: CALL_OW 48
// end ;
110842: LD_VAR 0 5
110846: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110847: LD_INT 0
110849: PPUSH
110850: PPUSH
110851: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110852: LD_ADDR_VAR 0 2
110856: PUSH
110857: LD_INT 0
110859: PUSH
110860: LD_INT 0
110862: PUSH
110863: LD_INT 0
110865: PUSH
110866: LD_INT 0
110868: PUSH
110869: EMPTY
110870: LIST
110871: LIST
110872: LIST
110873: LIST
110874: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110875: LD_VAR 0 1
110879: NOT
110880: PUSH
110881: LD_VAR 0 1
110885: PPUSH
110886: CALL_OW 264
110890: PUSH
110891: LD_INT 12
110893: PUSH
110894: LD_INT 51
110896: PUSH
110897: LD_INT 32
110899: PUSH
110900: LD_INT 89
110902: PUSH
110903: EMPTY
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: IN
110909: NOT
110910: OR
110911: IFFALSE 110915
// exit ;
110913: GO 111013
// for i := 1 to 3 do
110915: LD_ADDR_VAR 0 3
110919: PUSH
110920: DOUBLE
110921: LD_INT 1
110923: DEC
110924: ST_TO_ADDR
110925: LD_INT 3
110927: PUSH
110928: FOR_TO
110929: IFFALSE 111011
// begin tmp := GetCargo ( cargo , i ) ;
110931: LD_ADDR_VAR 0 4
110935: PUSH
110936: LD_VAR 0 1
110940: PPUSH
110941: LD_VAR 0 3
110945: PPUSH
110946: CALL_OW 289
110950: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
110951: LD_ADDR_VAR 0 2
110955: PUSH
110956: LD_VAR 0 2
110960: PPUSH
110961: LD_VAR 0 3
110965: PPUSH
110966: LD_VAR 0 4
110970: PPUSH
110971: CALL_OW 1
110975: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
110976: LD_ADDR_VAR 0 2
110980: PUSH
110981: LD_VAR 0 2
110985: PPUSH
110986: LD_INT 4
110988: PPUSH
110989: LD_VAR 0 2
110993: PUSH
110994: LD_INT 4
110996: ARRAY
110997: PUSH
110998: LD_VAR 0 4
111002: PLUS
111003: PPUSH
111004: CALL_OW 1
111008: ST_TO_ADDR
// end ;
111009: GO 110928
111011: POP
111012: POP
// end ;
111013: LD_VAR 0 2
111017: RET
// export function Length ( array ) ; begin
111018: LD_INT 0
111020: PPUSH
// result := array + 0 ;
111021: LD_ADDR_VAR 0 2
111025: PUSH
111026: LD_VAR 0 1
111030: PUSH
111031: LD_INT 0
111033: PLUS
111034: ST_TO_ADDR
// end ;
111035: LD_VAR 0 2
111039: RET
// export function PrepareArray ( array ) ; begin
111040: LD_INT 0
111042: PPUSH
// result := array diff 0 ;
111043: LD_ADDR_VAR 0 2
111047: PUSH
111048: LD_VAR 0 1
111052: PUSH
111053: LD_INT 0
111055: DIFF
111056: ST_TO_ADDR
// if not result [ 1 ] then
111057: LD_VAR 0 2
111061: PUSH
111062: LD_INT 1
111064: ARRAY
111065: NOT
111066: IFFALSE 111086
// result := Delete ( result , 1 ) ;
111068: LD_ADDR_VAR 0 2
111072: PUSH
111073: LD_VAR 0 2
111077: PPUSH
111078: LD_INT 1
111080: PPUSH
111081: CALL_OW 3
111085: ST_TO_ADDR
// end ;
111086: LD_VAR 0 2
111090: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111091: LD_INT 0
111093: PPUSH
111094: PPUSH
111095: PPUSH
111096: PPUSH
// sibRocketRange := 25 ;
111097: LD_ADDR_VAR 0 6
111101: PUSH
111102: LD_INT 25
111104: ST_TO_ADDR
// result := false ;
111105: LD_ADDR_VAR 0 4
111109: PUSH
111110: LD_INT 0
111112: ST_TO_ADDR
// for i := 0 to 5 do
111113: LD_ADDR_VAR 0 5
111117: PUSH
111118: DOUBLE
111119: LD_INT 0
111121: DEC
111122: ST_TO_ADDR
111123: LD_INT 5
111125: PUSH
111126: FOR_TO
111127: IFFALSE 111194
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111129: LD_VAR 0 1
111133: PPUSH
111134: LD_VAR 0 5
111138: PPUSH
111139: LD_VAR 0 6
111143: PPUSH
111144: CALL_OW 272
111148: PPUSH
111149: LD_VAR 0 2
111153: PPUSH
111154: LD_VAR 0 5
111158: PPUSH
111159: LD_VAR 0 6
111163: PPUSH
111164: CALL_OW 273
111168: PPUSH
111169: LD_VAR 0 3
111173: PPUSH
111174: CALL_OW 309
111178: IFFALSE 111192
// begin result := true ;
111180: LD_ADDR_VAR 0 4
111184: PUSH
111185: LD_INT 1
111187: ST_TO_ADDR
// exit ;
111188: POP
111189: POP
111190: GO 111196
// end ;
111192: GO 111126
111194: POP
111195: POP
// end ;
111196: LD_VAR 0 4
111200: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111201: LD_INT 0
111203: PPUSH
111204: PPUSH
111205: PPUSH
// if btype = b_depot then
111206: LD_VAR 0 2
111210: PUSH
111211: LD_INT 0
111213: EQUAL
111214: IFFALSE 111226
// begin result := true ;
111216: LD_ADDR_VAR 0 3
111220: PUSH
111221: LD_INT 1
111223: ST_TO_ADDR
// exit ;
111224: GO 111342
// end ; pom := GetBase ( depot ) ;
111226: LD_ADDR_VAR 0 4
111230: PUSH
111231: LD_VAR 0 1
111235: PPUSH
111236: CALL_OW 274
111240: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111241: LD_ADDR_VAR 0 5
111245: PUSH
111246: LD_VAR 0 2
111250: PPUSH
111251: LD_VAR 0 1
111255: PPUSH
111256: CALL_OW 248
111260: PPUSH
111261: CALL_OW 450
111265: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111266: LD_ADDR_VAR 0 3
111270: PUSH
111271: LD_VAR 0 4
111275: PPUSH
111276: LD_INT 1
111278: PPUSH
111279: CALL_OW 275
111283: PUSH
111284: LD_VAR 0 5
111288: PUSH
111289: LD_INT 1
111291: ARRAY
111292: GREATEREQUAL
111293: PUSH
111294: LD_VAR 0 4
111298: PPUSH
111299: LD_INT 2
111301: PPUSH
111302: CALL_OW 275
111306: PUSH
111307: LD_VAR 0 5
111311: PUSH
111312: LD_INT 2
111314: ARRAY
111315: GREATEREQUAL
111316: AND
111317: PUSH
111318: LD_VAR 0 4
111322: PPUSH
111323: LD_INT 3
111325: PPUSH
111326: CALL_OW 275
111330: PUSH
111331: LD_VAR 0 5
111335: PUSH
111336: LD_INT 3
111338: ARRAY
111339: GREATEREQUAL
111340: AND
111341: ST_TO_ADDR
// end ;
111342: LD_VAR 0 3
111346: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111347: LD_INT 0
111349: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111350: LD_VAR 0 1
111354: PPUSH
111355: LD_VAR 0 2
111359: PPUSH
111360: LD_INT 0
111362: PPUSH
111363: LD_INT 0
111365: PPUSH
111366: LD_INT 1
111368: PPUSH
111369: LD_INT 0
111371: PPUSH
111372: CALL_OW 587
// end ;
111376: LD_VAR 0 3
111380: RET
// export function CenterOnNow ( unit ) ; begin
111381: LD_INT 0
111383: PPUSH
// result := IsInUnit ( unit ) ;
111384: LD_ADDR_VAR 0 2
111388: PUSH
111389: LD_VAR 0 1
111393: PPUSH
111394: CALL_OW 310
111398: ST_TO_ADDR
// if not result then
111399: LD_VAR 0 2
111403: NOT
111404: IFFALSE 111416
// result := unit ;
111406: LD_ADDR_VAR 0 2
111410: PUSH
111411: LD_VAR 0 1
111415: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111416: LD_VAR 0 1
111420: PPUSH
111421: CALL_OW 87
// end ;
111425: LD_VAR 0 2
111429: RET
// export function ComMoveHex ( unit , hex ) ; begin
111430: LD_INT 0
111432: PPUSH
// if not hex then
111433: LD_VAR 0 2
111437: NOT
111438: IFFALSE 111442
// exit ;
111440: GO 111495
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111442: LD_VAR 0 2
111446: PUSH
111447: LD_INT 1
111449: ARRAY
111450: PPUSH
111451: LD_VAR 0 2
111455: PUSH
111456: LD_INT 2
111458: ARRAY
111459: PPUSH
111460: CALL_OW 428
111464: IFFALSE 111468
// exit ;
111466: GO 111495
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111468: LD_VAR 0 1
111472: PPUSH
111473: LD_VAR 0 2
111477: PUSH
111478: LD_INT 1
111480: ARRAY
111481: PPUSH
111482: LD_VAR 0 2
111486: PUSH
111487: LD_INT 2
111489: ARRAY
111490: PPUSH
111491: CALL_OW 111
// end ;
111495: LD_VAR 0 3
111499: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111500: LD_INT 0
111502: PPUSH
111503: PPUSH
111504: PPUSH
// if not unit or not enemy then
111505: LD_VAR 0 1
111509: NOT
111510: PUSH
111511: LD_VAR 0 2
111515: NOT
111516: OR
111517: IFFALSE 111521
// exit ;
111519: GO 111645
// x := GetX ( enemy ) ;
111521: LD_ADDR_VAR 0 4
111525: PUSH
111526: LD_VAR 0 2
111530: PPUSH
111531: CALL_OW 250
111535: ST_TO_ADDR
// y := GetY ( enemy ) ;
111536: LD_ADDR_VAR 0 5
111540: PUSH
111541: LD_VAR 0 2
111545: PPUSH
111546: CALL_OW 251
111550: ST_TO_ADDR
// if ValidHex ( x , y ) then
111551: LD_VAR 0 4
111555: PPUSH
111556: LD_VAR 0 5
111560: PPUSH
111561: CALL_OW 488
111565: IFFALSE 111645
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
111567: LD_VAR 0 2
111571: PPUSH
111572: CALL_OW 247
111576: PUSH
111577: LD_INT 3
111579: PUSH
111580: LD_INT 2
111582: PUSH
111583: EMPTY
111584: LIST
111585: LIST
111586: IN
111587: PUSH
111588: LD_VAR 0 1
111592: PPUSH
111593: CALL_OW 255
111597: PPUSH
111598: LD_VAR 0 2
111602: PPUSH
111603: CALL_OW 292
111607: OR
111608: IFFALSE 111626
// ComAttackUnit ( unit , enemy ) else
111610: LD_VAR 0 1
111614: PPUSH
111615: LD_VAR 0 2
111619: PPUSH
111620: CALL_OW 115
111624: GO 111645
// ComAgressiveMove ( unit , x , y ) ;
111626: LD_VAR 0 1
111630: PPUSH
111631: LD_VAR 0 4
111635: PPUSH
111636: LD_VAR 0 5
111640: PPUSH
111641: CALL_OW 114
// end ;
111645: LD_VAR 0 3
111649: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111650: LD_INT 0
111652: PPUSH
111653: PPUSH
111654: PPUSH
// list := AreaToList ( area , 0 ) ;
111655: LD_ADDR_VAR 0 5
111659: PUSH
111660: LD_VAR 0 1
111664: PPUSH
111665: LD_INT 0
111667: PPUSH
111668: CALL_OW 517
111672: ST_TO_ADDR
// if not list then
111673: LD_VAR 0 5
111677: NOT
111678: IFFALSE 111682
// exit ;
111680: GO 111812
// if all then
111682: LD_VAR 0 2
111686: IFFALSE 111774
// begin for i := 1 to list [ 1 ] do
111688: LD_ADDR_VAR 0 4
111692: PUSH
111693: DOUBLE
111694: LD_INT 1
111696: DEC
111697: ST_TO_ADDR
111698: LD_VAR 0 5
111702: PUSH
111703: LD_INT 1
111705: ARRAY
111706: PUSH
111707: FOR_TO
111708: IFFALSE 111770
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111710: LD_ADDR_VAR 0 3
111714: PUSH
111715: LD_VAR 0 3
111719: PPUSH
111720: LD_VAR 0 3
111724: PUSH
111725: LD_INT 1
111727: PLUS
111728: PPUSH
111729: LD_VAR 0 5
111733: PUSH
111734: LD_INT 1
111736: ARRAY
111737: PUSH
111738: LD_VAR 0 4
111742: ARRAY
111743: PUSH
111744: LD_VAR 0 5
111748: PUSH
111749: LD_INT 2
111751: ARRAY
111752: PUSH
111753: LD_VAR 0 4
111757: ARRAY
111758: PUSH
111759: EMPTY
111760: LIST
111761: LIST
111762: PPUSH
111763: CALL_OW 1
111767: ST_TO_ADDR
111768: GO 111707
111770: POP
111771: POP
// exit ;
111772: GO 111812
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111774: LD_ADDR_VAR 0 3
111778: PUSH
111779: LD_VAR 0 5
111783: PUSH
111784: LD_INT 1
111786: ARRAY
111787: PUSH
111788: LD_INT 1
111790: ARRAY
111791: PUSH
111792: LD_VAR 0 5
111796: PUSH
111797: LD_INT 2
111799: ARRAY
111800: PUSH
111801: LD_INT 1
111803: ARRAY
111804: PUSH
111805: EMPTY
111806: LIST
111807: LIST
111808: PUSH
111809: EMPTY
111810: LIST
111811: ST_TO_ADDR
// end ;
111812: LD_VAR 0 3
111816: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111817: LD_INT 0
111819: PPUSH
111820: PPUSH
// list := AreaToList ( area , 0 ) ;
111821: LD_ADDR_VAR 0 4
111825: PUSH
111826: LD_VAR 0 1
111830: PPUSH
111831: LD_INT 0
111833: PPUSH
111834: CALL_OW 517
111838: ST_TO_ADDR
// if not list then
111839: LD_VAR 0 4
111843: NOT
111844: IFFALSE 111848
// exit ;
111846: GO 111889
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111848: LD_ADDR_VAR 0 3
111852: PUSH
111853: LD_VAR 0 4
111857: PUSH
111858: LD_INT 1
111860: ARRAY
111861: PUSH
111862: LD_INT 1
111864: ARRAY
111865: PUSH
111866: LD_VAR 0 4
111870: PUSH
111871: LD_INT 2
111873: ARRAY
111874: PUSH
111875: LD_INT 1
111877: ARRAY
111878: PUSH
111879: LD_VAR 0 2
111883: PUSH
111884: EMPTY
111885: LIST
111886: LIST
111887: LIST
111888: ST_TO_ADDR
// end ;
111889: LD_VAR 0 3
111893: RET
// export function First ( array ) ; begin
111894: LD_INT 0
111896: PPUSH
// if not array then
111897: LD_VAR 0 1
111901: NOT
111902: IFFALSE 111906
// exit ;
111904: GO 111920
// result := array [ 1 ] ;
111906: LD_ADDR_VAR 0 2
111910: PUSH
111911: LD_VAR 0 1
111915: PUSH
111916: LD_INT 1
111918: ARRAY
111919: ST_TO_ADDR
// end ;
111920: LD_VAR 0 2
111924: RET
// export function Last ( array ) ; begin
111925: LD_INT 0
111927: PPUSH
// if not array then
111928: LD_VAR 0 1
111932: NOT
111933: IFFALSE 111937
// exit ;
111935: GO 111953
// result := array [ array ] ;
111937: LD_ADDR_VAR 0 2
111941: PUSH
111942: LD_VAR 0 1
111946: PUSH
111947: LD_VAR 0 1
111951: ARRAY
111952: ST_TO_ADDR
// end ;
111953: LD_VAR 0 2
111957: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
111958: LD_INT 0
111960: PPUSH
111961: PPUSH
// result := [ ] ;
111962: LD_ADDR_VAR 0 5
111966: PUSH
111967: EMPTY
111968: ST_TO_ADDR
// if not array then
111969: LD_VAR 0 1
111973: NOT
111974: IFFALSE 111978
// exit ;
111976: GO 112090
// for i := 1 to array do
111978: LD_ADDR_VAR 0 6
111982: PUSH
111983: DOUBLE
111984: LD_INT 1
111986: DEC
111987: ST_TO_ADDR
111988: LD_VAR 0 1
111992: PUSH
111993: FOR_TO
111994: IFFALSE 112088
// if array [ i ] [ index ] = value then
111996: LD_VAR 0 1
112000: PUSH
112001: LD_VAR 0 6
112005: ARRAY
112006: PUSH
112007: LD_VAR 0 2
112011: ARRAY
112012: PUSH
112013: LD_VAR 0 3
112017: EQUAL
112018: IFFALSE 112086
// begin if indexColumn then
112020: LD_VAR 0 4
112024: IFFALSE 112060
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112026: LD_ADDR_VAR 0 5
112030: PUSH
112031: LD_VAR 0 5
112035: PPUSH
112036: LD_VAR 0 1
112040: PUSH
112041: LD_VAR 0 6
112045: ARRAY
112046: PUSH
112047: LD_VAR 0 4
112051: ARRAY
112052: PPUSH
112053: CALL 107282 0 2
112057: ST_TO_ADDR
112058: GO 112086
// result := Join ( result , array [ i ] ) ;
112060: LD_ADDR_VAR 0 5
112064: PUSH
112065: LD_VAR 0 5
112069: PPUSH
112070: LD_VAR 0 1
112074: PUSH
112075: LD_VAR 0 6
112079: ARRAY
112080: PPUSH
112081: CALL 107282 0 2
112085: ST_TO_ADDR
// end ;
112086: GO 111993
112088: POP
112089: POP
// end ;
112090: LD_VAR 0 5
112094: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112095: LD_INT 0
112097: PPUSH
// if not vehicles or not parkingPoint then
112098: LD_VAR 0 1
112102: NOT
112103: PUSH
112104: LD_VAR 0 2
112108: NOT
112109: OR
112110: IFFALSE 112114
// exit ;
112112: GO 112212
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112114: LD_ADDR_VAR 0 1
112118: PUSH
112119: LD_VAR 0 1
112123: PPUSH
112124: LD_INT 50
112126: PUSH
112127: EMPTY
112128: LIST
112129: PUSH
112130: LD_INT 3
112132: PUSH
112133: LD_INT 92
112135: PUSH
112136: LD_VAR 0 2
112140: PUSH
112141: LD_INT 1
112143: ARRAY
112144: PUSH
112145: LD_VAR 0 2
112149: PUSH
112150: LD_INT 2
112152: ARRAY
112153: PUSH
112154: LD_INT 8
112156: PUSH
112157: EMPTY
112158: LIST
112159: LIST
112160: LIST
112161: LIST
112162: PUSH
112163: EMPTY
112164: LIST
112165: LIST
112166: PUSH
112167: EMPTY
112168: LIST
112169: LIST
112170: PPUSH
112171: CALL_OW 72
112175: ST_TO_ADDR
// if not vehicles then
112176: LD_VAR 0 1
112180: NOT
112181: IFFALSE 112185
// exit ;
112183: GO 112212
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112185: LD_VAR 0 1
112189: PPUSH
112190: LD_VAR 0 2
112194: PUSH
112195: LD_INT 1
112197: ARRAY
112198: PPUSH
112199: LD_VAR 0 2
112203: PUSH
112204: LD_INT 2
112206: ARRAY
112207: PPUSH
112208: CALL_OW 111
// end ;
112212: LD_VAR 0 3
112216: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112217: LD_INT 0
112219: PPUSH
112220: PPUSH
112221: PPUSH
// if not side or not area then
112222: LD_VAR 0 1
112226: NOT
112227: PUSH
112228: LD_VAR 0 2
112232: NOT
112233: OR
112234: IFFALSE 112238
// exit ;
112236: GO 112357
// tmp := AreaToList ( area , 0 ) ;
112238: LD_ADDR_VAR 0 5
112242: PUSH
112243: LD_VAR 0 2
112247: PPUSH
112248: LD_INT 0
112250: PPUSH
112251: CALL_OW 517
112255: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112256: LD_ADDR_VAR 0 4
112260: PUSH
112261: DOUBLE
112262: LD_INT 1
112264: DEC
112265: ST_TO_ADDR
112266: LD_VAR 0 5
112270: PUSH
112271: LD_INT 1
112273: ARRAY
112274: PUSH
112275: FOR_TO
112276: IFFALSE 112355
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112278: LD_VAR 0 5
112282: PUSH
112283: LD_INT 1
112285: ARRAY
112286: PUSH
112287: LD_VAR 0 4
112291: ARRAY
112292: PPUSH
112293: LD_VAR 0 5
112297: PUSH
112298: LD_INT 2
112300: ARRAY
112301: PUSH
112302: LD_VAR 0 4
112306: ARRAY
112307: PPUSH
112308: CALL_OW 351
112312: IFFALSE 112353
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
112314: LD_VAR 0 5
112318: PUSH
112319: LD_INT 1
112321: ARRAY
112322: PUSH
112323: LD_VAR 0 4
112327: ARRAY
112328: PPUSH
112329: LD_VAR 0 5
112333: PUSH
112334: LD_INT 2
112336: ARRAY
112337: PUSH
112338: LD_VAR 0 4
112342: ARRAY
112343: PPUSH
112344: LD_VAR 0 1
112348: PPUSH
112349: CALL_OW 244
// end ;
112353: GO 112275
112355: POP
112356: POP
// end ; end_of_file end_of_file
112357: LD_VAR 0 3
112361: RET
// export globalGameSaveCounter ; every 0 0$1 do
112362: GO 112364
112364: DISABLE
// begin enable ;
112365: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
112366: LD_STRING updateTimer(
112368: PUSH
112369: LD_OWVAR 1
112373: STR
112374: PUSH
112375: LD_STRING );
112377: STR
112378: PPUSH
112379: CALL_OW 559
// end ;
112383: END
// every 0 0$1 do
112384: GO 112386
112386: DISABLE
// begin globalGameSaveCounter := 0 ;
112387: LD_ADDR_EXP 147
112391: PUSH
112392: LD_INT 0
112394: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
112395: LD_STRING setGameSaveCounter(0)
112397: PPUSH
112398: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
112402: LD_STRING initStreamRollete();
112404: PPUSH
112405: CALL_OW 559
// InitStreamMode ;
112409: CALL 113752 0 0
// DefineStreamItems ( false ) ;
112413: LD_INT 0
112415: PPUSH
112416: CALL 114216 0 1
// end ;
112420: END
// export function SOS_MapStart ( ) ; begin
112421: LD_INT 0
112423: PPUSH
// if streamModeActive then
112424: LD_EXP 148
112428: IFFALSE 112437
// DefineStreamItems ( true ) ;
112430: LD_INT 1
112432: PPUSH
112433: CALL 114216 0 1
// UpdateLuaVariables ( ) ;
112437: CALL 112454 0 0
// UpdateFactoryWaypoints ( ) ;
112441: CALL 127085 0 0
// UpdateWarehouseGatheringPoints ( ) ;
112445: CALL 127342 0 0
// end ;
112449: LD_VAR 0 1
112453: RET
// function UpdateLuaVariables ( ) ; begin
112454: LD_INT 0
112456: PPUSH
// if globalGameSaveCounter then
112457: LD_EXP 147
112461: IFFALSE 112495
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
112463: LD_ADDR_EXP 147
112467: PUSH
112468: LD_EXP 147
112472: PPUSH
112473: CALL 108643 0 1
112477: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112478: LD_STRING setGameSaveCounter(
112480: PUSH
112481: LD_EXP 147
112485: STR
112486: PUSH
112487: LD_STRING )
112489: STR
112490: PPUSH
112491: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
112495: LD_STRING setGameDifficulty(
112497: PUSH
112498: LD_OWVAR 67
112502: STR
112503: PUSH
112504: LD_STRING )
112506: STR
112507: PPUSH
112508: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
112512: LD_STRING displayDifficulty(
112514: PUSH
112515: LD_OWVAR 67
112519: STR
112520: PUSH
112521: LD_STRING )
112523: STR
112524: PPUSH
112525: CALL_OW 559
// end ;
112529: LD_VAR 0 1
112533: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112534: LD_INT 0
112536: PPUSH
// if p2 = stream_mode then
112537: LD_VAR 0 2
112541: PUSH
112542: LD_INT 100
112544: EQUAL
112545: IFFALSE 113548
// begin if not StreamModeActive then
112547: LD_EXP 148
112551: NOT
112552: IFFALSE 112562
// StreamModeActive := true ;
112554: LD_ADDR_EXP 148
112558: PUSH
112559: LD_INT 1
112561: ST_TO_ADDR
// if p3 = 0 then
112562: LD_VAR 0 3
112566: PUSH
112567: LD_INT 0
112569: EQUAL
112570: IFFALSE 112576
// InitStreamMode ;
112572: CALL 113752 0 0
// if p3 = 1 then
112576: LD_VAR 0 3
112580: PUSH
112581: LD_INT 1
112583: EQUAL
112584: IFFALSE 112594
// sRocket := true ;
112586: LD_ADDR_EXP 153
112590: PUSH
112591: LD_INT 1
112593: ST_TO_ADDR
// if p3 = 2 then
112594: LD_VAR 0 3
112598: PUSH
112599: LD_INT 2
112601: EQUAL
112602: IFFALSE 112612
// sSpeed := true ;
112604: LD_ADDR_EXP 152
112608: PUSH
112609: LD_INT 1
112611: ST_TO_ADDR
// if p3 = 3 then
112612: LD_VAR 0 3
112616: PUSH
112617: LD_INT 3
112619: EQUAL
112620: IFFALSE 112630
// sEngine := true ;
112622: LD_ADDR_EXP 154
112626: PUSH
112627: LD_INT 1
112629: ST_TO_ADDR
// if p3 = 4 then
112630: LD_VAR 0 3
112634: PUSH
112635: LD_INT 4
112637: EQUAL
112638: IFFALSE 112648
// sSpec := true ;
112640: LD_ADDR_EXP 151
112644: PUSH
112645: LD_INT 1
112647: ST_TO_ADDR
// if p3 = 5 then
112648: LD_VAR 0 3
112652: PUSH
112653: LD_INT 5
112655: EQUAL
112656: IFFALSE 112666
// sLevel := true ;
112658: LD_ADDR_EXP 155
112662: PUSH
112663: LD_INT 1
112665: ST_TO_ADDR
// if p3 = 6 then
112666: LD_VAR 0 3
112670: PUSH
112671: LD_INT 6
112673: EQUAL
112674: IFFALSE 112684
// sArmoury := true ;
112676: LD_ADDR_EXP 156
112680: PUSH
112681: LD_INT 1
112683: ST_TO_ADDR
// if p3 = 7 then
112684: LD_VAR 0 3
112688: PUSH
112689: LD_INT 7
112691: EQUAL
112692: IFFALSE 112702
// sRadar := true ;
112694: LD_ADDR_EXP 157
112698: PUSH
112699: LD_INT 1
112701: ST_TO_ADDR
// if p3 = 8 then
112702: LD_VAR 0 3
112706: PUSH
112707: LD_INT 8
112709: EQUAL
112710: IFFALSE 112720
// sBunker := true ;
112712: LD_ADDR_EXP 158
112716: PUSH
112717: LD_INT 1
112719: ST_TO_ADDR
// if p3 = 9 then
112720: LD_VAR 0 3
112724: PUSH
112725: LD_INT 9
112727: EQUAL
112728: IFFALSE 112738
// sHack := true ;
112730: LD_ADDR_EXP 159
112734: PUSH
112735: LD_INT 1
112737: ST_TO_ADDR
// if p3 = 10 then
112738: LD_VAR 0 3
112742: PUSH
112743: LD_INT 10
112745: EQUAL
112746: IFFALSE 112756
// sFire := true ;
112748: LD_ADDR_EXP 160
112752: PUSH
112753: LD_INT 1
112755: ST_TO_ADDR
// if p3 = 11 then
112756: LD_VAR 0 3
112760: PUSH
112761: LD_INT 11
112763: EQUAL
112764: IFFALSE 112774
// sRefresh := true ;
112766: LD_ADDR_EXP 161
112770: PUSH
112771: LD_INT 1
112773: ST_TO_ADDR
// if p3 = 12 then
112774: LD_VAR 0 3
112778: PUSH
112779: LD_INT 12
112781: EQUAL
112782: IFFALSE 112792
// sExp := true ;
112784: LD_ADDR_EXP 162
112788: PUSH
112789: LD_INT 1
112791: ST_TO_ADDR
// if p3 = 13 then
112792: LD_VAR 0 3
112796: PUSH
112797: LD_INT 13
112799: EQUAL
112800: IFFALSE 112810
// sDepot := true ;
112802: LD_ADDR_EXP 163
112806: PUSH
112807: LD_INT 1
112809: ST_TO_ADDR
// if p3 = 14 then
112810: LD_VAR 0 3
112814: PUSH
112815: LD_INT 14
112817: EQUAL
112818: IFFALSE 112828
// sFlag := true ;
112820: LD_ADDR_EXP 164
112824: PUSH
112825: LD_INT 1
112827: ST_TO_ADDR
// if p3 = 15 then
112828: LD_VAR 0 3
112832: PUSH
112833: LD_INT 15
112835: EQUAL
112836: IFFALSE 112846
// sKamikadze := true ;
112838: LD_ADDR_EXP 172
112842: PUSH
112843: LD_INT 1
112845: ST_TO_ADDR
// if p3 = 16 then
112846: LD_VAR 0 3
112850: PUSH
112851: LD_INT 16
112853: EQUAL
112854: IFFALSE 112864
// sTroll := true ;
112856: LD_ADDR_EXP 173
112860: PUSH
112861: LD_INT 1
112863: ST_TO_ADDR
// if p3 = 17 then
112864: LD_VAR 0 3
112868: PUSH
112869: LD_INT 17
112871: EQUAL
112872: IFFALSE 112882
// sSlow := true ;
112874: LD_ADDR_EXP 174
112878: PUSH
112879: LD_INT 1
112881: ST_TO_ADDR
// if p3 = 18 then
112882: LD_VAR 0 3
112886: PUSH
112887: LD_INT 18
112889: EQUAL
112890: IFFALSE 112900
// sLack := true ;
112892: LD_ADDR_EXP 175
112896: PUSH
112897: LD_INT 1
112899: ST_TO_ADDR
// if p3 = 19 then
112900: LD_VAR 0 3
112904: PUSH
112905: LD_INT 19
112907: EQUAL
112908: IFFALSE 112918
// sTank := true ;
112910: LD_ADDR_EXP 177
112914: PUSH
112915: LD_INT 1
112917: ST_TO_ADDR
// if p3 = 20 then
112918: LD_VAR 0 3
112922: PUSH
112923: LD_INT 20
112925: EQUAL
112926: IFFALSE 112936
// sRemote := true ;
112928: LD_ADDR_EXP 178
112932: PUSH
112933: LD_INT 1
112935: ST_TO_ADDR
// if p3 = 21 then
112936: LD_VAR 0 3
112940: PUSH
112941: LD_INT 21
112943: EQUAL
112944: IFFALSE 112954
// sPowell := true ;
112946: LD_ADDR_EXP 179
112950: PUSH
112951: LD_INT 1
112953: ST_TO_ADDR
// if p3 = 22 then
112954: LD_VAR 0 3
112958: PUSH
112959: LD_INT 22
112961: EQUAL
112962: IFFALSE 112972
// sTeleport := true ;
112964: LD_ADDR_EXP 182
112968: PUSH
112969: LD_INT 1
112971: ST_TO_ADDR
// if p3 = 23 then
112972: LD_VAR 0 3
112976: PUSH
112977: LD_INT 23
112979: EQUAL
112980: IFFALSE 112990
// sOilTower := true ;
112982: LD_ADDR_EXP 184
112986: PUSH
112987: LD_INT 1
112989: ST_TO_ADDR
// if p3 = 24 then
112990: LD_VAR 0 3
112994: PUSH
112995: LD_INT 24
112997: EQUAL
112998: IFFALSE 113008
// sShovel := true ;
113000: LD_ADDR_EXP 185
113004: PUSH
113005: LD_INT 1
113007: ST_TO_ADDR
// if p3 = 25 then
113008: LD_VAR 0 3
113012: PUSH
113013: LD_INT 25
113015: EQUAL
113016: IFFALSE 113026
// sSheik := true ;
113018: LD_ADDR_EXP 186
113022: PUSH
113023: LD_INT 1
113025: ST_TO_ADDR
// if p3 = 26 then
113026: LD_VAR 0 3
113030: PUSH
113031: LD_INT 26
113033: EQUAL
113034: IFFALSE 113044
// sEarthquake := true ;
113036: LD_ADDR_EXP 188
113040: PUSH
113041: LD_INT 1
113043: ST_TO_ADDR
// if p3 = 27 then
113044: LD_VAR 0 3
113048: PUSH
113049: LD_INT 27
113051: EQUAL
113052: IFFALSE 113062
// sAI := true ;
113054: LD_ADDR_EXP 189
113058: PUSH
113059: LD_INT 1
113061: ST_TO_ADDR
// if p3 = 28 then
113062: LD_VAR 0 3
113066: PUSH
113067: LD_INT 28
113069: EQUAL
113070: IFFALSE 113080
// sCargo := true ;
113072: LD_ADDR_EXP 192
113076: PUSH
113077: LD_INT 1
113079: ST_TO_ADDR
// if p3 = 29 then
113080: LD_VAR 0 3
113084: PUSH
113085: LD_INT 29
113087: EQUAL
113088: IFFALSE 113098
// sDLaser := true ;
113090: LD_ADDR_EXP 193
113094: PUSH
113095: LD_INT 1
113097: ST_TO_ADDR
// if p3 = 30 then
113098: LD_VAR 0 3
113102: PUSH
113103: LD_INT 30
113105: EQUAL
113106: IFFALSE 113116
// sExchange := true ;
113108: LD_ADDR_EXP 194
113112: PUSH
113113: LD_INT 1
113115: ST_TO_ADDR
// if p3 = 31 then
113116: LD_VAR 0 3
113120: PUSH
113121: LD_INT 31
113123: EQUAL
113124: IFFALSE 113134
// sFac := true ;
113126: LD_ADDR_EXP 195
113130: PUSH
113131: LD_INT 1
113133: ST_TO_ADDR
// if p3 = 32 then
113134: LD_VAR 0 3
113138: PUSH
113139: LD_INT 32
113141: EQUAL
113142: IFFALSE 113152
// sPower := true ;
113144: LD_ADDR_EXP 196
113148: PUSH
113149: LD_INT 1
113151: ST_TO_ADDR
// if p3 = 33 then
113152: LD_VAR 0 3
113156: PUSH
113157: LD_INT 33
113159: EQUAL
113160: IFFALSE 113170
// sRandom := true ;
113162: LD_ADDR_EXP 197
113166: PUSH
113167: LD_INT 1
113169: ST_TO_ADDR
// if p3 = 34 then
113170: LD_VAR 0 3
113174: PUSH
113175: LD_INT 34
113177: EQUAL
113178: IFFALSE 113188
// sShield := true ;
113180: LD_ADDR_EXP 198
113184: PUSH
113185: LD_INT 1
113187: ST_TO_ADDR
// if p3 = 35 then
113188: LD_VAR 0 3
113192: PUSH
113193: LD_INT 35
113195: EQUAL
113196: IFFALSE 113206
// sTime := true ;
113198: LD_ADDR_EXP 199
113202: PUSH
113203: LD_INT 1
113205: ST_TO_ADDR
// if p3 = 36 then
113206: LD_VAR 0 3
113210: PUSH
113211: LD_INT 36
113213: EQUAL
113214: IFFALSE 113224
// sTools := true ;
113216: LD_ADDR_EXP 200
113220: PUSH
113221: LD_INT 1
113223: ST_TO_ADDR
// if p3 = 101 then
113224: LD_VAR 0 3
113228: PUSH
113229: LD_INT 101
113231: EQUAL
113232: IFFALSE 113242
// sSold := true ;
113234: LD_ADDR_EXP 165
113238: PUSH
113239: LD_INT 1
113241: ST_TO_ADDR
// if p3 = 102 then
113242: LD_VAR 0 3
113246: PUSH
113247: LD_INT 102
113249: EQUAL
113250: IFFALSE 113260
// sDiff := true ;
113252: LD_ADDR_EXP 166
113256: PUSH
113257: LD_INT 1
113259: ST_TO_ADDR
// if p3 = 103 then
113260: LD_VAR 0 3
113264: PUSH
113265: LD_INT 103
113267: EQUAL
113268: IFFALSE 113278
// sFog := true ;
113270: LD_ADDR_EXP 169
113274: PUSH
113275: LD_INT 1
113277: ST_TO_ADDR
// if p3 = 104 then
113278: LD_VAR 0 3
113282: PUSH
113283: LD_INT 104
113285: EQUAL
113286: IFFALSE 113296
// sReset := true ;
113288: LD_ADDR_EXP 170
113292: PUSH
113293: LD_INT 1
113295: ST_TO_ADDR
// if p3 = 105 then
113296: LD_VAR 0 3
113300: PUSH
113301: LD_INT 105
113303: EQUAL
113304: IFFALSE 113314
// sSun := true ;
113306: LD_ADDR_EXP 171
113310: PUSH
113311: LD_INT 1
113313: ST_TO_ADDR
// if p3 = 106 then
113314: LD_VAR 0 3
113318: PUSH
113319: LD_INT 106
113321: EQUAL
113322: IFFALSE 113332
// sTiger := true ;
113324: LD_ADDR_EXP 167
113328: PUSH
113329: LD_INT 1
113331: ST_TO_ADDR
// if p3 = 107 then
113332: LD_VAR 0 3
113336: PUSH
113337: LD_INT 107
113339: EQUAL
113340: IFFALSE 113350
// sBomb := true ;
113342: LD_ADDR_EXP 168
113346: PUSH
113347: LD_INT 1
113349: ST_TO_ADDR
// if p3 = 108 then
113350: LD_VAR 0 3
113354: PUSH
113355: LD_INT 108
113357: EQUAL
113358: IFFALSE 113368
// sWound := true ;
113360: LD_ADDR_EXP 176
113364: PUSH
113365: LD_INT 1
113367: ST_TO_ADDR
// if p3 = 109 then
113368: LD_VAR 0 3
113372: PUSH
113373: LD_INT 109
113375: EQUAL
113376: IFFALSE 113386
// sBetray := true ;
113378: LD_ADDR_EXP 180
113382: PUSH
113383: LD_INT 1
113385: ST_TO_ADDR
// if p3 = 110 then
113386: LD_VAR 0 3
113390: PUSH
113391: LD_INT 110
113393: EQUAL
113394: IFFALSE 113404
// sContamin := true ;
113396: LD_ADDR_EXP 181
113400: PUSH
113401: LD_INT 1
113403: ST_TO_ADDR
// if p3 = 111 then
113404: LD_VAR 0 3
113408: PUSH
113409: LD_INT 111
113411: EQUAL
113412: IFFALSE 113422
// sOil := true ;
113414: LD_ADDR_EXP 183
113418: PUSH
113419: LD_INT 1
113421: ST_TO_ADDR
// if p3 = 112 then
113422: LD_VAR 0 3
113426: PUSH
113427: LD_INT 112
113429: EQUAL
113430: IFFALSE 113440
// sStu := true ;
113432: LD_ADDR_EXP 187
113436: PUSH
113437: LD_INT 1
113439: ST_TO_ADDR
// if p3 = 113 then
113440: LD_VAR 0 3
113444: PUSH
113445: LD_INT 113
113447: EQUAL
113448: IFFALSE 113458
// sBazooka := true ;
113450: LD_ADDR_EXP 190
113454: PUSH
113455: LD_INT 1
113457: ST_TO_ADDR
// if p3 = 114 then
113458: LD_VAR 0 3
113462: PUSH
113463: LD_INT 114
113465: EQUAL
113466: IFFALSE 113476
// sMortar := true ;
113468: LD_ADDR_EXP 191
113472: PUSH
113473: LD_INT 1
113475: ST_TO_ADDR
// if p3 = 115 then
113476: LD_VAR 0 3
113480: PUSH
113481: LD_INT 115
113483: EQUAL
113484: IFFALSE 113494
// sRanger := true ;
113486: LD_ADDR_EXP 201
113490: PUSH
113491: LD_INT 1
113493: ST_TO_ADDR
// if p3 = 116 then
113494: LD_VAR 0 3
113498: PUSH
113499: LD_INT 116
113501: EQUAL
113502: IFFALSE 113512
// sComputer := true ;
113504: LD_ADDR_EXP 202
113508: PUSH
113509: LD_INT 1
113511: ST_TO_ADDR
// if p3 = 117 then
113512: LD_VAR 0 3
113516: PUSH
113517: LD_INT 117
113519: EQUAL
113520: IFFALSE 113530
// s30 := true ;
113522: LD_ADDR_EXP 203
113526: PUSH
113527: LD_INT 1
113529: ST_TO_ADDR
// if p3 = 118 then
113530: LD_VAR 0 3
113534: PUSH
113535: LD_INT 118
113537: EQUAL
113538: IFFALSE 113548
// s60 := true ;
113540: LD_ADDR_EXP 204
113544: PUSH
113545: LD_INT 1
113547: ST_TO_ADDR
// end ; if p2 = hack_mode then
113548: LD_VAR 0 2
113552: PUSH
113553: LD_INT 101
113555: EQUAL
113556: IFFALSE 113684
// begin case p3 of 1 :
113558: LD_VAR 0 3
113562: PUSH
113563: LD_INT 1
113565: DOUBLE
113566: EQUAL
113567: IFTRUE 113571
113569: GO 113578
113571: POP
// hHackUnlimitedResources ; 2 :
113572: CALL 125831 0 0
113576: GO 113684
113578: LD_INT 2
113580: DOUBLE
113581: EQUAL
113582: IFTRUE 113586
113584: GO 113593
113586: POP
// hHackSetLevel10 ; 3 :
113587: CALL 125964 0 0
113591: GO 113684
113593: LD_INT 3
113595: DOUBLE
113596: EQUAL
113597: IFTRUE 113601
113599: GO 113608
113601: POP
// hHackSetLevel10YourUnits ; 4 :
113602: CALL 126049 0 0
113606: GO 113684
113608: LD_INT 4
113610: DOUBLE
113611: EQUAL
113612: IFTRUE 113616
113614: GO 113623
113616: POP
// hHackInvincible ; 5 :
113617: CALL 126497 0 0
113621: GO 113684
113623: LD_INT 5
113625: DOUBLE
113626: EQUAL
113627: IFTRUE 113631
113629: GO 113638
113631: POP
// hHackInvisible ; 6 :
113632: CALL 126608 0 0
113636: GO 113684
113638: LD_INT 6
113640: DOUBLE
113641: EQUAL
113642: IFTRUE 113646
113644: GO 113653
113646: POP
// hHackChangeYourSide ; 7 :
113647: CALL 126665 0 0
113651: GO 113684
113653: LD_INT 7
113655: DOUBLE
113656: EQUAL
113657: IFTRUE 113661
113659: GO 113668
113661: POP
// hHackChangeUnitSide ; 8 :
113662: CALL 126707 0 0
113666: GO 113684
113668: LD_INT 8
113670: DOUBLE
113671: EQUAL
113672: IFTRUE 113676
113674: GO 113683
113676: POP
// hHackFog ; end ;
113677: CALL 126808 0 0
113681: GO 113684
113683: POP
// end ; if p2 = game_save_mode then
113684: LD_VAR 0 2
113688: PUSH
113689: LD_INT 102
113691: EQUAL
113692: IFFALSE 113747
// begin if p3 = 1 then
113694: LD_VAR 0 3
113698: PUSH
113699: LD_INT 1
113701: EQUAL
113702: IFFALSE 113714
// globalGameSaveCounter := p4 ;
113704: LD_ADDR_EXP 147
113708: PUSH
113709: LD_VAR 0 4
113713: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113714: LD_VAR 0 3
113718: PUSH
113719: LD_INT 2
113721: EQUAL
113722: PUSH
113723: LD_EXP 147
113727: AND
113728: IFFALSE 113747
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113730: LD_STRING setGameSaveCounter(
113732: PUSH
113733: LD_EXP 147
113737: STR
113738: PUSH
113739: LD_STRING )
113741: STR
113742: PPUSH
113743: CALL_OW 559
// end ; end ;
113747: LD_VAR 0 7
113751: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113752: LD_INT 0
113754: PPUSH
// streamModeActive := false ;
113755: LD_ADDR_EXP 148
113759: PUSH
113760: LD_INT 0
113762: ST_TO_ADDR
// normalCounter := 36 ;
113763: LD_ADDR_EXP 149
113767: PUSH
113768: LD_INT 36
113770: ST_TO_ADDR
// hardcoreCounter := 18 ;
113771: LD_ADDR_EXP 150
113775: PUSH
113776: LD_INT 18
113778: ST_TO_ADDR
// sRocket := false ;
113779: LD_ADDR_EXP 153
113783: PUSH
113784: LD_INT 0
113786: ST_TO_ADDR
// sSpeed := false ;
113787: LD_ADDR_EXP 152
113791: PUSH
113792: LD_INT 0
113794: ST_TO_ADDR
// sEngine := false ;
113795: LD_ADDR_EXP 154
113799: PUSH
113800: LD_INT 0
113802: ST_TO_ADDR
// sSpec := false ;
113803: LD_ADDR_EXP 151
113807: PUSH
113808: LD_INT 0
113810: ST_TO_ADDR
// sLevel := false ;
113811: LD_ADDR_EXP 155
113815: PUSH
113816: LD_INT 0
113818: ST_TO_ADDR
// sArmoury := false ;
113819: LD_ADDR_EXP 156
113823: PUSH
113824: LD_INT 0
113826: ST_TO_ADDR
// sRadar := false ;
113827: LD_ADDR_EXP 157
113831: PUSH
113832: LD_INT 0
113834: ST_TO_ADDR
// sBunker := false ;
113835: LD_ADDR_EXP 158
113839: PUSH
113840: LD_INT 0
113842: ST_TO_ADDR
// sHack := false ;
113843: LD_ADDR_EXP 159
113847: PUSH
113848: LD_INT 0
113850: ST_TO_ADDR
// sFire := false ;
113851: LD_ADDR_EXP 160
113855: PUSH
113856: LD_INT 0
113858: ST_TO_ADDR
// sRefresh := false ;
113859: LD_ADDR_EXP 161
113863: PUSH
113864: LD_INT 0
113866: ST_TO_ADDR
// sExp := false ;
113867: LD_ADDR_EXP 162
113871: PUSH
113872: LD_INT 0
113874: ST_TO_ADDR
// sDepot := false ;
113875: LD_ADDR_EXP 163
113879: PUSH
113880: LD_INT 0
113882: ST_TO_ADDR
// sFlag := false ;
113883: LD_ADDR_EXP 164
113887: PUSH
113888: LD_INT 0
113890: ST_TO_ADDR
// sKamikadze := false ;
113891: LD_ADDR_EXP 172
113895: PUSH
113896: LD_INT 0
113898: ST_TO_ADDR
// sTroll := false ;
113899: LD_ADDR_EXP 173
113903: PUSH
113904: LD_INT 0
113906: ST_TO_ADDR
// sSlow := false ;
113907: LD_ADDR_EXP 174
113911: PUSH
113912: LD_INT 0
113914: ST_TO_ADDR
// sLack := false ;
113915: LD_ADDR_EXP 175
113919: PUSH
113920: LD_INT 0
113922: ST_TO_ADDR
// sTank := false ;
113923: LD_ADDR_EXP 177
113927: PUSH
113928: LD_INT 0
113930: ST_TO_ADDR
// sRemote := false ;
113931: LD_ADDR_EXP 178
113935: PUSH
113936: LD_INT 0
113938: ST_TO_ADDR
// sPowell := false ;
113939: LD_ADDR_EXP 179
113943: PUSH
113944: LD_INT 0
113946: ST_TO_ADDR
// sTeleport := false ;
113947: LD_ADDR_EXP 182
113951: PUSH
113952: LD_INT 0
113954: ST_TO_ADDR
// sOilTower := false ;
113955: LD_ADDR_EXP 184
113959: PUSH
113960: LD_INT 0
113962: ST_TO_ADDR
// sShovel := false ;
113963: LD_ADDR_EXP 185
113967: PUSH
113968: LD_INT 0
113970: ST_TO_ADDR
// sSheik := false ;
113971: LD_ADDR_EXP 186
113975: PUSH
113976: LD_INT 0
113978: ST_TO_ADDR
// sEarthquake := false ;
113979: LD_ADDR_EXP 188
113983: PUSH
113984: LD_INT 0
113986: ST_TO_ADDR
// sAI := false ;
113987: LD_ADDR_EXP 189
113991: PUSH
113992: LD_INT 0
113994: ST_TO_ADDR
// sCargo := false ;
113995: LD_ADDR_EXP 192
113999: PUSH
114000: LD_INT 0
114002: ST_TO_ADDR
// sDLaser := false ;
114003: LD_ADDR_EXP 193
114007: PUSH
114008: LD_INT 0
114010: ST_TO_ADDR
// sExchange := false ;
114011: LD_ADDR_EXP 194
114015: PUSH
114016: LD_INT 0
114018: ST_TO_ADDR
// sFac := false ;
114019: LD_ADDR_EXP 195
114023: PUSH
114024: LD_INT 0
114026: ST_TO_ADDR
// sPower := false ;
114027: LD_ADDR_EXP 196
114031: PUSH
114032: LD_INT 0
114034: ST_TO_ADDR
// sRandom := false ;
114035: LD_ADDR_EXP 197
114039: PUSH
114040: LD_INT 0
114042: ST_TO_ADDR
// sShield := false ;
114043: LD_ADDR_EXP 198
114047: PUSH
114048: LD_INT 0
114050: ST_TO_ADDR
// sTime := false ;
114051: LD_ADDR_EXP 199
114055: PUSH
114056: LD_INT 0
114058: ST_TO_ADDR
// sTools := false ;
114059: LD_ADDR_EXP 200
114063: PUSH
114064: LD_INT 0
114066: ST_TO_ADDR
// sSold := false ;
114067: LD_ADDR_EXP 165
114071: PUSH
114072: LD_INT 0
114074: ST_TO_ADDR
// sDiff := false ;
114075: LD_ADDR_EXP 166
114079: PUSH
114080: LD_INT 0
114082: ST_TO_ADDR
// sFog := false ;
114083: LD_ADDR_EXP 169
114087: PUSH
114088: LD_INT 0
114090: ST_TO_ADDR
// sReset := false ;
114091: LD_ADDR_EXP 170
114095: PUSH
114096: LD_INT 0
114098: ST_TO_ADDR
// sSun := false ;
114099: LD_ADDR_EXP 171
114103: PUSH
114104: LD_INT 0
114106: ST_TO_ADDR
// sTiger := false ;
114107: LD_ADDR_EXP 167
114111: PUSH
114112: LD_INT 0
114114: ST_TO_ADDR
// sBomb := false ;
114115: LD_ADDR_EXP 168
114119: PUSH
114120: LD_INT 0
114122: ST_TO_ADDR
// sWound := false ;
114123: LD_ADDR_EXP 176
114127: PUSH
114128: LD_INT 0
114130: ST_TO_ADDR
// sBetray := false ;
114131: LD_ADDR_EXP 180
114135: PUSH
114136: LD_INT 0
114138: ST_TO_ADDR
// sContamin := false ;
114139: LD_ADDR_EXP 181
114143: PUSH
114144: LD_INT 0
114146: ST_TO_ADDR
// sOil := false ;
114147: LD_ADDR_EXP 183
114151: PUSH
114152: LD_INT 0
114154: ST_TO_ADDR
// sStu := false ;
114155: LD_ADDR_EXP 187
114159: PUSH
114160: LD_INT 0
114162: ST_TO_ADDR
// sBazooka := false ;
114163: LD_ADDR_EXP 190
114167: PUSH
114168: LD_INT 0
114170: ST_TO_ADDR
// sMortar := false ;
114171: LD_ADDR_EXP 191
114175: PUSH
114176: LD_INT 0
114178: ST_TO_ADDR
// sRanger := false ;
114179: LD_ADDR_EXP 201
114183: PUSH
114184: LD_INT 0
114186: ST_TO_ADDR
// sComputer := false ;
114187: LD_ADDR_EXP 202
114191: PUSH
114192: LD_INT 0
114194: ST_TO_ADDR
// s30 := false ;
114195: LD_ADDR_EXP 203
114199: PUSH
114200: LD_INT 0
114202: ST_TO_ADDR
// s60 := false ;
114203: LD_ADDR_EXP 204
114207: PUSH
114208: LD_INT 0
114210: ST_TO_ADDR
// end ;
114211: LD_VAR 0 1
114215: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114216: LD_INT 0
114218: PPUSH
114219: PPUSH
114220: PPUSH
114221: PPUSH
114222: PPUSH
114223: PPUSH
114224: PPUSH
// result := [ ] ;
114225: LD_ADDR_VAR 0 2
114229: PUSH
114230: EMPTY
114231: ST_TO_ADDR
// if campaign_id = 1 then
114232: LD_OWVAR 69
114236: PUSH
114237: LD_INT 1
114239: EQUAL
114240: IFFALSE 117406
// begin case mission_number of 1 :
114242: LD_OWVAR 70
114246: PUSH
114247: LD_INT 1
114249: DOUBLE
114250: EQUAL
114251: IFTRUE 114255
114253: GO 114331
114255: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114256: LD_ADDR_VAR 0 2
114260: PUSH
114261: LD_INT 2
114263: PUSH
114264: LD_INT 4
114266: PUSH
114267: LD_INT 11
114269: PUSH
114270: LD_INT 12
114272: PUSH
114273: LD_INT 15
114275: PUSH
114276: LD_INT 16
114278: PUSH
114279: LD_INT 22
114281: PUSH
114282: LD_INT 23
114284: PUSH
114285: LD_INT 26
114287: PUSH
114288: EMPTY
114289: LIST
114290: LIST
114291: LIST
114292: LIST
114293: LIST
114294: LIST
114295: LIST
114296: LIST
114297: LIST
114298: PUSH
114299: LD_INT 101
114301: PUSH
114302: LD_INT 102
114304: PUSH
114305: LD_INT 106
114307: PUSH
114308: LD_INT 116
114310: PUSH
114311: LD_INT 117
114313: PUSH
114314: LD_INT 118
114316: PUSH
114317: EMPTY
114318: LIST
114319: LIST
114320: LIST
114321: LIST
114322: LIST
114323: LIST
114324: PUSH
114325: EMPTY
114326: LIST
114327: LIST
114328: ST_TO_ADDR
114329: GO 117404
114331: LD_INT 2
114333: DOUBLE
114334: EQUAL
114335: IFTRUE 114339
114337: GO 114423
114339: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
114340: LD_ADDR_VAR 0 2
114344: PUSH
114345: LD_INT 2
114347: PUSH
114348: LD_INT 4
114350: PUSH
114351: LD_INT 11
114353: PUSH
114354: LD_INT 12
114356: PUSH
114357: LD_INT 15
114359: PUSH
114360: LD_INT 16
114362: PUSH
114363: LD_INT 22
114365: PUSH
114366: LD_INT 23
114368: PUSH
114369: LD_INT 26
114371: PUSH
114372: EMPTY
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: LIST
114378: LIST
114379: LIST
114380: LIST
114381: LIST
114382: PUSH
114383: LD_INT 101
114385: PUSH
114386: LD_INT 102
114388: PUSH
114389: LD_INT 105
114391: PUSH
114392: LD_INT 106
114394: PUSH
114395: LD_INT 108
114397: PUSH
114398: LD_INT 116
114400: PUSH
114401: LD_INT 117
114403: PUSH
114404: LD_INT 118
114406: PUSH
114407: EMPTY
114408: LIST
114409: LIST
114410: LIST
114411: LIST
114412: LIST
114413: LIST
114414: LIST
114415: LIST
114416: PUSH
114417: EMPTY
114418: LIST
114419: LIST
114420: ST_TO_ADDR
114421: GO 117404
114423: LD_INT 3
114425: DOUBLE
114426: EQUAL
114427: IFTRUE 114431
114429: GO 114519
114431: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
114432: LD_ADDR_VAR 0 2
114436: PUSH
114437: LD_INT 2
114439: PUSH
114440: LD_INT 4
114442: PUSH
114443: LD_INT 5
114445: PUSH
114446: LD_INT 11
114448: PUSH
114449: LD_INT 12
114451: PUSH
114452: LD_INT 15
114454: PUSH
114455: LD_INT 16
114457: PUSH
114458: LD_INT 22
114460: PUSH
114461: LD_INT 26
114463: PUSH
114464: LD_INT 36
114466: PUSH
114467: EMPTY
114468: LIST
114469: LIST
114470: LIST
114471: LIST
114472: LIST
114473: LIST
114474: LIST
114475: LIST
114476: LIST
114477: LIST
114478: PUSH
114479: LD_INT 101
114481: PUSH
114482: LD_INT 102
114484: PUSH
114485: LD_INT 105
114487: PUSH
114488: LD_INT 106
114490: PUSH
114491: LD_INT 108
114493: PUSH
114494: LD_INT 116
114496: PUSH
114497: LD_INT 117
114499: PUSH
114500: LD_INT 118
114502: PUSH
114503: EMPTY
114504: LIST
114505: LIST
114506: LIST
114507: LIST
114508: LIST
114509: LIST
114510: LIST
114511: LIST
114512: PUSH
114513: EMPTY
114514: LIST
114515: LIST
114516: ST_TO_ADDR
114517: GO 117404
114519: LD_INT 4
114521: DOUBLE
114522: EQUAL
114523: IFTRUE 114527
114525: GO 114623
114527: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
114528: LD_ADDR_VAR 0 2
114532: PUSH
114533: LD_INT 2
114535: PUSH
114536: LD_INT 4
114538: PUSH
114539: LD_INT 5
114541: PUSH
114542: LD_INT 8
114544: PUSH
114545: LD_INT 11
114547: PUSH
114548: LD_INT 12
114550: PUSH
114551: LD_INT 15
114553: PUSH
114554: LD_INT 16
114556: PUSH
114557: LD_INT 22
114559: PUSH
114560: LD_INT 23
114562: PUSH
114563: LD_INT 26
114565: PUSH
114566: LD_INT 36
114568: PUSH
114569: EMPTY
114570: LIST
114571: LIST
114572: LIST
114573: LIST
114574: LIST
114575: LIST
114576: LIST
114577: LIST
114578: LIST
114579: LIST
114580: LIST
114581: LIST
114582: PUSH
114583: LD_INT 101
114585: PUSH
114586: LD_INT 102
114588: PUSH
114589: LD_INT 105
114591: PUSH
114592: LD_INT 106
114594: PUSH
114595: LD_INT 108
114597: PUSH
114598: LD_INT 116
114600: PUSH
114601: LD_INT 117
114603: PUSH
114604: LD_INT 118
114606: PUSH
114607: EMPTY
114608: LIST
114609: LIST
114610: LIST
114611: LIST
114612: LIST
114613: LIST
114614: LIST
114615: LIST
114616: PUSH
114617: EMPTY
114618: LIST
114619: LIST
114620: ST_TO_ADDR
114621: GO 117404
114623: LD_INT 5
114625: DOUBLE
114626: EQUAL
114627: IFTRUE 114631
114629: GO 114743
114631: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
114632: LD_ADDR_VAR 0 2
114636: PUSH
114637: LD_INT 2
114639: PUSH
114640: LD_INT 4
114642: PUSH
114643: LD_INT 5
114645: PUSH
114646: LD_INT 6
114648: PUSH
114649: LD_INT 8
114651: PUSH
114652: LD_INT 11
114654: PUSH
114655: LD_INT 12
114657: PUSH
114658: LD_INT 15
114660: PUSH
114661: LD_INT 16
114663: PUSH
114664: LD_INT 22
114666: PUSH
114667: LD_INT 23
114669: PUSH
114670: LD_INT 25
114672: PUSH
114673: LD_INT 26
114675: PUSH
114676: LD_INT 36
114678: PUSH
114679: EMPTY
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: LIST
114694: PUSH
114695: LD_INT 101
114697: PUSH
114698: LD_INT 102
114700: PUSH
114701: LD_INT 105
114703: PUSH
114704: LD_INT 106
114706: PUSH
114707: LD_INT 108
114709: PUSH
114710: LD_INT 109
114712: PUSH
114713: LD_INT 112
114715: PUSH
114716: LD_INT 116
114718: PUSH
114719: LD_INT 117
114721: PUSH
114722: LD_INT 118
114724: PUSH
114725: EMPTY
114726: LIST
114727: LIST
114728: LIST
114729: LIST
114730: LIST
114731: LIST
114732: LIST
114733: LIST
114734: LIST
114735: LIST
114736: PUSH
114737: EMPTY
114738: LIST
114739: LIST
114740: ST_TO_ADDR
114741: GO 117404
114743: LD_INT 6
114745: DOUBLE
114746: EQUAL
114747: IFTRUE 114751
114749: GO 114883
114751: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114752: LD_ADDR_VAR 0 2
114756: PUSH
114757: LD_INT 2
114759: PUSH
114760: LD_INT 4
114762: PUSH
114763: LD_INT 5
114765: PUSH
114766: LD_INT 6
114768: PUSH
114769: LD_INT 8
114771: PUSH
114772: LD_INT 11
114774: PUSH
114775: LD_INT 12
114777: PUSH
114778: LD_INT 15
114780: PUSH
114781: LD_INT 16
114783: PUSH
114784: LD_INT 20
114786: PUSH
114787: LD_INT 21
114789: PUSH
114790: LD_INT 22
114792: PUSH
114793: LD_INT 23
114795: PUSH
114796: LD_INT 25
114798: PUSH
114799: LD_INT 26
114801: PUSH
114802: LD_INT 30
114804: PUSH
114805: LD_INT 31
114807: PUSH
114808: LD_INT 32
114810: PUSH
114811: LD_INT 36
114813: PUSH
114814: EMPTY
114815: LIST
114816: LIST
114817: LIST
114818: LIST
114819: LIST
114820: LIST
114821: LIST
114822: LIST
114823: LIST
114824: LIST
114825: LIST
114826: LIST
114827: LIST
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: LIST
114834: PUSH
114835: LD_INT 101
114837: PUSH
114838: LD_INT 102
114840: PUSH
114841: LD_INT 105
114843: PUSH
114844: LD_INT 106
114846: PUSH
114847: LD_INT 108
114849: PUSH
114850: LD_INT 109
114852: PUSH
114853: LD_INT 112
114855: PUSH
114856: LD_INT 116
114858: PUSH
114859: LD_INT 117
114861: PUSH
114862: LD_INT 118
114864: PUSH
114865: EMPTY
114866: LIST
114867: LIST
114868: LIST
114869: LIST
114870: LIST
114871: LIST
114872: LIST
114873: LIST
114874: LIST
114875: LIST
114876: PUSH
114877: EMPTY
114878: LIST
114879: LIST
114880: ST_TO_ADDR
114881: GO 117404
114883: LD_INT 7
114885: DOUBLE
114886: EQUAL
114887: IFTRUE 114891
114889: GO 115003
114891: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
114892: LD_ADDR_VAR 0 2
114896: PUSH
114897: LD_INT 2
114899: PUSH
114900: LD_INT 4
114902: PUSH
114903: LD_INT 5
114905: PUSH
114906: LD_INT 7
114908: PUSH
114909: LD_INT 11
114911: PUSH
114912: LD_INT 12
114914: PUSH
114915: LD_INT 15
114917: PUSH
114918: LD_INT 16
114920: PUSH
114921: LD_INT 20
114923: PUSH
114924: LD_INT 21
114926: PUSH
114927: LD_INT 22
114929: PUSH
114930: LD_INT 23
114932: PUSH
114933: LD_INT 25
114935: PUSH
114936: LD_INT 26
114938: PUSH
114939: EMPTY
114940: LIST
114941: LIST
114942: LIST
114943: LIST
114944: LIST
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: LIST
114951: LIST
114952: LIST
114953: LIST
114954: PUSH
114955: LD_INT 101
114957: PUSH
114958: LD_INT 102
114960: PUSH
114961: LD_INT 103
114963: PUSH
114964: LD_INT 105
114966: PUSH
114967: LD_INT 106
114969: PUSH
114970: LD_INT 108
114972: PUSH
114973: LD_INT 112
114975: PUSH
114976: LD_INT 116
114978: PUSH
114979: LD_INT 117
114981: PUSH
114982: LD_INT 118
114984: PUSH
114985: EMPTY
114986: LIST
114987: LIST
114988: LIST
114989: LIST
114990: LIST
114991: LIST
114992: LIST
114993: LIST
114994: LIST
114995: LIST
114996: PUSH
114997: EMPTY
114998: LIST
114999: LIST
115000: ST_TO_ADDR
115001: GO 117404
115003: LD_INT 8
115005: DOUBLE
115006: EQUAL
115007: IFTRUE 115011
115009: GO 115151
115011: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115012: LD_ADDR_VAR 0 2
115016: PUSH
115017: LD_INT 2
115019: PUSH
115020: LD_INT 4
115022: PUSH
115023: LD_INT 5
115025: PUSH
115026: LD_INT 6
115028: PUSH
115029: LD_INT 7
115031: PUSH
115032: LD_INT 8
115034: PUSH
115035: LD_INT 11
115037: PUSH
115038: LD_INT 12
115040: PUSH
115041: LD_INT 15
115043: PUSH
115044: LD_INT 16
115046: PUSH
115047: LD_INT 20
115049: PUSH
115050: LD_INT 21
115052: PUSH
115053: LD_INT 22
115055: PUSH
115056: LD_INT 23
115058: PUSH
115059: LD_INT 25
115061: PUSH
115062: LD_INT 26
115064: PUSH
115065: LD_INT 30
115067: PUSH
115068: LD_INT 31
115070: PUSH
115071: LD_INT 32
115073: PUSH
115074: LD_INT 36
115076: PUSH
115077: EMPTY
115078: LIST
115079: LIST
115080: LIST
115081: LIST
115082: LIST
115083: LIST
115084: LIST
115085: LIST
115086: LIST
115087: LIST
115088: LIST
115089: LIST
115090: LIST
115091: LIST
115092: LIST
115093: LIST
115094: LIST
115095: LIST
115096: LIST
115097: LIST
115098: PUSH
115099: LD_INT 101
115101: PUSH
115102: LD_INT 102
115104: PUSH
115105: LD_INT 103
115107: PUSH
115108: LD_INT 105
115110: PUSH
115111: LD_INT 106
115113: PUSH
115114: LD_INT 108
115116: PUSH
115117: LD_INT 109
115119: PUSH
115120: LD_INT 112
115122: PUSH
115123: LD_INT 116
115125: PUSH
115126: LD_INT 117
115128: PUSH
115129: LD_INT 118
115131: PUSH
115132: EMPTY
115133: LIST
115134: LIST
115135: LIST
115136: LIST
115137: LIST
115138: LIST
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: LIST
115144: PUSH
115145: EMPTY
115146: LIST
115147: LIST
115148: ST_TO_ADDR
115149: GO 117404
115151: LD_INT 9
115153: DOUBLE
115154: EQUAL
115155: IFTRUE 115159
115157: GO 115307
115159: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115160: LD_ADDR_VAR 0 2
115164: PUSH
115165: LD_INT 2
115167: PUSH
115168: LD_INT 4
115170: PUSH
115171: LD_INT 5
115173: PUSH
115174: LD_INT 6
115176: PUSH
115177: LD_INT 7
115179: PUSH
115180: LD_INT 8
115182: PUSH
115183: LD_INT 11
115185: PUSH
115186: LD_INT 12
115188: PUSH
115189: LD_INT 15
115191: PUSH
115192: LD_INT 16
115194: PUSH
115195: LD_INT 20
115197: PUSH
115198: LD_INT 21
115200: PUSH
115201: LD_INT 22
115203: PUSH
115204: LD_INT 23
115206: PUSH
115207: LD_INT 25
115209: PUSH
115210: LD_INT 26
115212: PUSH
115213: LD_INT 28
115215: PUSH
115216: LD_INT 30
115218: PUSH
115219: LD_INT 31
115221: PUSH
115222: LD_INT 32
115224: PUSH
115225: LD_INT 36
115227: PUSH
115228: EMPTY
115229: LIST
115230: LIST
115231: LIST
115232: LIST
115233: LIST
115234: LIST
115235: LIST
115236: LIST
115237: LIST
115238: LIST
115239: LIST
115240: LIST
115241: LIST
115242: LIST
115243: LIST
115244: LIST
115245: LIST
115246: LIST
115247: LIST
115248: LIST
115249: LIST
115250: PUSH
115251: LD_INT 101
115253: PUSH
115254: LD_INT 102
115256: PUSH
115257: LD_INT 103
115259: PUSH
115260: LD_INT 105
115262: PUSH
115263: LD_INT 106
115265: PUSH
115266: LD_INT 108
115268: PUSH
115269: LD_INT 109
115271: PUSH
115272: LD_INT 112
115274: PUSH
115275: LD_INT 114
115277: PUSH
115278: LD_INT 116
115280: PUSH
115281: LD_INT 117
115283: PUSH
115284: LD_INT 118
115286: PUSH
115287: EMPTY
115288: LIST
115289: LIST
115290: LIST
115291: LIST
115292: LIST
115293: LIST
115294: LIST
115295: LIST
115296: LIST
115297: LIST
115298: LIST
115299: LIST
115300: PUSH
115301: EMPTY
115302: LIST
115303: LIST
115304: ST_TO_ADDR
115305: GO 117404
115307: LD_INT 10
115309: DOUBLE
115310: EQUAL
115311: IFTRUE 115315
115313: GO 115511
115315: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
115316: LD_ADDR_VAR 0 2
115320: PUSH
115321: LD_INT 2
115323: PUSH
115324: LD_INT 4
115326: PUSH
115327: LD_INT 5
115329: PUSH
115330: LD_INT 6
115332: PUSH
115333: LD_INT 7
115335: PUSH
115336: LD_INT 8
115338: PUSH
115339: LD_INT 9
115341: PUSH
115342: LD_INT 10
115344: PUSH
115345: LD_INT 11
115347: PUSH
115348: LD_INT 12
115350: PUSH
115351: LD_INT 13
115353: PUSH
115354: LD_INT 14
115356: PUSH
115357: LD_INT 15
115359: PUSH
115360: LD_INT 16
115362: PUSH
115363: LD_INT 17
115365: PUSH
115366: LD_INT 18
115368: PUSH
115369: LD_INT 19
115371: PUSH
115372: LD_INT 20
115374: PUSH
115375: LD_INT 21
115377: PUSH
115378: LD_INT 22
115380: PUSH
115381: LD_INT 23
115383: PUSH
115384: LD_INT 24
115386: PUSH
115387: LD_INT 25
115389: PUSH
115390: LD_INT 26
115392: PUSH
115393: LD_INT 28
115395: PUSH
115396: LD_INT 30
115398: PUSH
115399: LD_INT 31
115401: PUSH
115402: LD_INT 32
115404: PUSH
115405: LD_INT 36
115407: PUSH
115408: EMPTY
115409: LIST
115410: LIST
115411: LIST
115412: LIST
115413: LIST
115414: LIST
115415: LIST
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: LIST
115421: LIST
115422: LIST
115423: LIST
115424: LIST
115425: LIST
115426: LIST
115427: LIST
115428: LIST
115429: LIST
115430: LIST
115431: LIST
115432: LIST
115433: LIST
115434: LIST
115435: LIST
115436: LIST
115437: LIST
115438: PUSH
115439: LD_INT 101
115441: PUSH
115442: LD_INT 102
115444: PUSH
115445: LD_INT 103
115447: PUSH
115448: LD_INT 104
115450: PUSH
115451: LD_INT 105
115453: PUSH
115454: LD_INT 106
115456: PUSH
115457: LD_INT 107
115459: PUSH
115460: LD_INT 108
115462: PUSH
115463: LD_INT 109
115465: PUSH
115466: LD_INT 110
115468: PUSH
115469: LD_INT 111
115471: PUSH
115472: LD_INT 112
115474: PUSH
115475: LD_INT 114
115477: PUSH
115478: LD_INT 116
115480: PUSH
115481: LD_INT 117
115483: PUSH
115484: LD_INT 118
115486: PUSH
115487: EMPTY
115488: LIST
115489: LIST
115490: LIST
115491: LIST
115492: LIST
115493: LIST
115494: LIST
115495: LIST
115496: LIST
115497: LIST
115498: LIST
115499: LIST
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: PUSH
115505: EMPTY
115506: LIST
115507: LIST
115508: ST_TO_ADDR
115509: GO 117404
115511: LD_INT 11
115513: DOUBLE
115514: EQUAL
115515: IFTRUE 115519
115517: GO 115723
115519: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
115520: LD_ADDR_VAR 0 2
115524: PUSH
115525: LD_INT 2
115527: PUSH
115528: LD_INT 3
115530: PUSH
115531: LD_INT 4
115533: PUSH
115534: LD_INT 5
115536: PUSH
115537: LD_INT 6
115539: PUSH
115540: LD_INT 7
115542: PUSH
115543: LD_INT 8
115545: PUSH
115546: LD_INT 9
115548: PUSH
115549: LD_INT 10
115551: PUSH
115552: LD_INT 11
115554: PUSH
115555: LD_INT 12
115557: PUSH
115558: LD_INT 13
115560: PUSH
115561: LD_INT 14
115563: PUSH
115564: LD_INT 15
115566: PUSH
115567: LD_INT 16
115569: PUSH
115570: LD_INT 17
115572: PUSH
115573: LD_INT 18
115575: PUSH
115576: LD_INT 19
115578: PUSH
115579: LD_INT 20
115581: PUSH
115582: LD_INT 21
115584: PUSH
115585: LD_INT 22
115587: PUSH
115588: LD_INT 23
115590: PUSH
115591: LD_INT 24
115593: PUSH
115594: LD_INT 25
115596: PUSH
115597: LD_INT 26
115599: PUSH
115600: LD_INT 28
115602: PUSH
115603: LD_INT 30
115605: PUSH
115606: LD_INT 31
115608: PUSH
115609: LD_INT 32
115611: PUSH
115612: LD_INT 34
115614: PUSH
115615: LD_INT 36
115617: PUSH
115618: EMPTY
115619: LIST
115620: LIST
115621: LIST
115622: LIST
115623: LIST
115624: LIST
115625: LIST
115626: LIST
115627: LIST
115628: LIST
115629: LIST
115630: LIST
115631: LIST
115632: LIST
115633: LIST
115634: LIST
115635: LIST
115636: LIST
115637: LIST
115638: LIST
115639: LIST
115640: LIST
115641: LIST
115642: LIST
115643: LIST
115644: LIST
115645: LIST
115646: LIST
115647: LIST
115648: LIST
115649: LIST
115650: PUSH
115651: LD_INT 101
115653: PUSH
115654: LD_INT 102
115656: PUSH
115657: LD_INT 103
115659: PUSH
115660: LD_INT 104
115662: PUSH
115663: LD_INT 105
115665: PUSH
115666: LD_INT 106
115668: PUSH
115669: LD_INT 107
115671: PUSH
115672: LD_INT 108
115674: PUSH
115675: LD_INT 109
115677: PUSH
115678: LD_INT 110
115680: PUSH
115681: LD_INT 111
115683: PUSH
115684: LD_INT 112
115686: PUSH
115687: LD_INT 114
115689: PUSH
115690: LD_INT 116
115692: PUSH
115693: LD_INT 117
115695: PUSH
115696: LD_INT 118
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: LIST
115705: LIST
115706: LIST
115707: LIST
115708: LIST
115709: LIST
115710: LIST
115711: LIST
115712: LIST
115713: LIST
115714: LIST
115715: LIST
115716: PUSH
115717: EMPTY
115718: LIST
115719: LIST
115720: ST_TO_ADDR
115721: GO 117404
115723: LD_INT 12
115725: DOUBLE
115726: EQUAL
115727: IFTRUE 115731
115729: GO 115951
115731: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115732: LD_ADDR_VAR 0 2
115736: PUSH
115737: LD_INT 1
115739: PUSH
115740: LD_INT 2
115742: PUSH
115743: LD_INT 3
115745: PUSH
115746: LD_INT 4
115748: PUSH
115749: LD_INT 5
115751: PUSH
115752: LD_INT 6
115754: PUSH
115755: LD_INT 7
115757: PUSH
115758: LD_INT 8
115760: PUSH
115761: LD_INT 9
115763: PUSH
115764: LD_INT 10
115766: PUSH
115767: LD_INT 11
115769: PUSH
115770: LD_INT 12
115772: PUSH
115773: LD_INT 13
115775: PUSH
115776: LD_INT 14
115778: PUSH
115779: LD_INT 15
115781: PUSH
115782: LD_INT 16
115784: PUSH
115785: LD_INT 17
115787: PUSH
115788: LD_INT 18
115790: PUSH
115791: LD_INT 19
115793: PUSH
115794: LD_INT 20
115796: PUSH
115797: LD_INT 21
115799: PUSH
115800: LD_INT 22
115802: PUSH
115803: LD_INT 23
115805: PUSH
115806: LD_INT 24
115808: PUSH
115809: LD_INT 25
115811: PUSH
115812: LD_INT 26
115814: PUSH
115815: LD_INT 27
115817: PUSH
115818: LD_INT 28
115820: PUSH
115821: LD_INT 30
115823: PUSH
115824: LD_INT 31
115826: PUSH
115827: LD_INT 32
115829: PUSH
115830: LD_INT 33
115832: PUSH
115833: LD_INT 34
115835: PUSH
115836: LD_INT 36
115838: PUSH
115839: EMPTY
115840: LIST
115841: LIST
115842: LIST
115843: LIST
115844: LIST
115845: LIST
115846: LIST
115847: LIST
115848: LIST
115849: LIST
115850: LIST
115851: LIST
115852: LIST
115853: LIST
115854: LIST
115855: LIST
115856: LIST
115857: LIST
115858: LIST
115859: LIST
115860: LIST
115861: LIST
115862: LIST
115863: LIST
115864: LIST
115865: LIST
115866: LIST
115867: LIST
115868: LIST
115869: LIST
115870: LIST
115871: LIST
115872: LIST
115873: LIST
115874: PUSH
115875: LD_INT 101
115877: PUSH
115878: LD_INT 102
115880: PUSH
115881: LD_INT 103
115883: PUSH
115884: LD_INT 104
115886: PUSH
115887: LD_INT 105
115889: PUSH
115890: LD_INT 106
115892: PUSH
115893: LD_INT 107
115895: PUSH
115896: LD_INT 108
115898: PUSH
115899: LD_INT 109
115901: PUSH
115902: LD_INT 110
115904: PUSH
115905: LD_INT 111
115907: PUSH
115908: LD_INT 112
115910: PUSH
115911: LD_INT 113
115913: PUSH
115914: LD_INT 114
115916: PUSH
115917: LD_INT 116
115919: PUSH
115920: LD_INT 117
115922: PUSH
115923: LD_INT 118
115925: PUSH
115926: EMPTY
115927: LIST
115928: LIST
115929: LIST
115930: LIST
115931: LIST
115932: LIST
115933: LIST
115934: LIST
115935: LIST
115936: LIST
115937: LIST
115938: LIST
115939: LIST
115940: LIST
115941: LIST
115942: LIST
115943: LIST
115944: PUSH
115945: EMPTY
115946: LIST
115947: LIST
115948: ST_TO_ADDR
115949: GO 117404
115951: LD_INT 13
115953: DOUBLE
115954: EQUAL
115955: IFTRUE 115959
115957: GO 116167
115959: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
115960: LD_ADDR_VAR 0 2
115964: PUSH
115965: LD_INT 1
115967: PUSH
115968: LD_INT 2
115970: PUSH
115971: LD_INT 3
115973: PUSH
115974: LD_INT 4
115976: PUSH
115977: LD_INT 5
115979: PUSH
115980: LD_INT 8
115982: PUSH
115983: LD_INT 9
115985: PUSH
115986: LD_INT 10
115988: PUSH
115989: LD_INT 11
115991: PUSH
115992: LD_INT 12
115994: PUSH
115995: LD_INT 14
115997: PUSH
115998: LD_INT 15
116000: PUSH
116001: LD_INT 16
116003: PUSH
116004: LD_INT 17
116006: PUSH
116007: LD_INT 18
116009: PUSH
116010: LD_INT 19
116012: PUSH
116013: LD_INT 20
116015: PUSH
116016: LD_INT 21
116018: PUSH
116019: LD_INT 22
116021: PUSH
116022: LD_INT 23
116024: PUSH
116025: LD_INT 24
116027: PUSH
116028: LD_INT 25
116030: PUSH
116031: LD_INT 26
116033: PUSH
116034: LD_INT 27
116036: PUSH
116037: LD_INT 28
116039: PUSH
116040: LD_INT 30
116042: PUSH
116043: LD_INT 31
116045: PUSH
116046: LD_INT 32
116048: PUSH
116049: LD_INT 33
116051: PUSH
116052: LD_INT 34
116054: PUSH
116055: LD_INT 36
116057: PUSH
116058: EMPTY
116059: LIST
116060: LIST
116061: LIST
116062: LIST
116063: LIST
116064: LIST
116065: LIST
116066: LIST
116067: LIST
116068: LIST
116069: LIST
116070: LIST
116071: LIST
116072: LIST
116073: LIST
116074: LIST
116075: LIST
116076: LIST
116077: LIST
116078: LIST
116079: LIST
116080: LIST
116081: LIST
116082: LIST
116083: LIST
116084: LIST
116085: LIST
116086: LIST
116087: LIST
116088: LIST
116089: LIST
116090: PUSH
116091: LD_INT 101
116093: PUSH
116094: LD_INT 102
116096: PUSH
116097: LD_INT 103
116099: PUSH
116100: LD_INT 104
116102: PUSH
116103: LD_INT 105
116105: PUSH
116106: LD_INT 106
116108: PUSH
116109: LD_INT 107
116111: PUSH
116112: LD_INT 108
116114: PUSH
116115: LD_INT 109
116117: PUSH
116118: LD_INT 110
116120: PUSH
116121: LD_INT 111
116123: PUSH
116124: LD_INT 112
116126: PUSH
116127: LD_INT 113
116129: PUSH
116130: LD_INT 114
116132: PUSH
116133: LD_INT 116
116135: PUSH
116136: LD_INT 117
116138: PUSH
116139: LD_INT 118
116141: PUSH
116142: EMPTY
116143: LIST
116144: LIST
116145: LIST
116146: LIST
116147: LIST
116148: LIST
116149: LIST
116150: LIST
116151: LIST
116152: LIST
116153: LIST
116154: LIST
116155: LIST
116156: LIST
116157: LIST
116158: LIST
116159: LIST
116160: PUSH
116161: EMPTY
116162: LIST
116163: LIST
116164: ST_TO_ADDR
116165: GO 117404
116167: LD_INT 14
116169: DOUBLE
116170: EQUAL
116171: IFTRUE 116175
116173: GO 116399
116175: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116176: LD_ADDR_VAR 0 2
116180: PUSH
116181: LD_INT 1
116183: PUSH
116184: LD_INT 2
116186: PUSH
116187: LD_INT 3
116189: PUSH
116190: LD_INT 4
116192: PUSH
116193: LD_INT 5
116195: PUSH
116196: LD_INT 6
116198: PUSH
116199: LD_INT 7
116201: PUSH
116202: LD_INT 8
116204: PUSH
116205: LD_INT 9
116207: PUSH
116208: LD_INT 10
116210: PUSH
116211: LD_INT 11
116213: PUSH
116214: LD_INT 12
116216: PUSH
116217: LD_INT 13
116219: PUSH
116220: LD_INT 14
116222: PUSH
116223: LD_INT 15
116225: PUSH
116226: LD_INT 16
116228: PUSH
116229: LD_INT 17
116231: PUSH
116232: LD_INT 18
116234: PUSH
116235: LD_INT 19
116237: PUSH
116238: LD_INT 20
116240: PUSH
116241: LD_INT 21
116243: PUSH
116244: LD_INT 22
116246: PUSH
116247: LD_INT 23
116249: PUSH
116250: LD_INT 24
116252: PUSH
116253: LD_INT 25
116255: PUSH
116256: LD_INT 26
116258: PUSH
116259: LD_INT 27
116261: PUSH
116262: LD_INT 28
116264: PUSH
116265: LD_INT 29
116267: PUSH
116268: LD_INT 30
116270: PUSH
116271: LD_INT 31
116273: PUSH
116274: LD_INT 32
116276: PUSH
116277: LD_INT 33
116279: PUSH
116280: LD_INT 34
116282: PUSH
116283: LD_INT 36
116285: PUSH
116286: EMPTY
116287: LIST
116288: LIST
116289: LIST
116290: LIST
116291: LIST
116292: LIST
116293: LIST
116294: LIST
116295: LIST
116296: LIST
116297: LIST
116298: LIST
116299: LIST
116300: LIST
116301: LIST
116302: LIST
116303: LIST
116304: LIST
116305: LIST
116306: LIST
116307: LIST
116308: LIST
116309: LIST
116310: LIST
116311: LIST
116312: LIST
116313: LIST
116314: LIST
116315: LIST
116316: LIST
116317: LIST
116318: LIST
116319: LIST
116320: LIST
116321: LIST
116322: PUSH
116323: LD_INT 101
116325: PUSH
116326: LD_INT 102
116328: PUSH
116329: LD_INT 103
116331: PUSH
116332: LD_INT 104
116334: PUSH
116335: LD_INT 105
116337: PUSH
116338: LD_INT 106
116340: PUSH
116341: LD_INT 107
116343: PUSH
116344: LD_INT 108
116346: PUSH
116347: LD_INT 109
116349: PUSH
116350: LD_INT 110
116352: PUSH
116353: LD_INT 111
116355: PUSH
116356: LD_INT 112
116358: PUSH
116359: LD_INT 113
116361: PUSH
116362: LD_INT 114
116364: PUSH
116365: LD_INT 116
116367: PUSH
116368: LD_INT 117
116370: PUSH
116371: LD_INT 118
116373: PUSH
116374: EMPTY
116375: LIST
116376: LIST
116377: LIST
116378: LIST
116379: LIST
116380: LIST
116381: LIST
116382: LIST
116383: LIST
116384: LIST
116385: LIST
116386: LIST
116387: LIST
116388: LIST
116389: LIST
116390: LIST
116391: LIST
116392: PUSH
116393: EMPTY
116394: LIST
116395: LIST
116396: ST_TO_ADDR
116397: GO 117404
116399: LD_INT 15
116401: DOUBLE
116402: EQUAL
116403: IFTRUE 116407
116405: GO 116631
116407: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
116408: LD_ADDR_VAR 0 2
116412: PUSH
116413: LD_INT 1
116415: PUSH
116416: LD_INT 2
116418: PUSH
116419: LD_INT 3
116421: PUSH
116422: LD_INT 4
116424: PUSH
116425: LD_INT 5
116427: PUSH
116428: LD_INT 6
116430: PUSH
116431: LD_INT 7
116433: PUSH
116434: LD_INT 8
116436: PUSH
116437: LD_INT 9
116439: PUSH
116440: LD_INT 10
116442: PUSH
116443: LD_INT 11
116445: PUSH
116446: LD_INT 12
116448: PUSH
116449: LD_INT 13
116451: PUSH
116452: LD_INT 14
116454: PUSH
116455: LD_INT 15
116457: PUSH
116458: LD_INT 16
116460: PUSH
116461: LD_INT 17
116463: PUSH
116464: LD_INT 18
116466: PUSH
116467: LD_INT 19
116469: PUSH
116470: LD_INT 20
116472: PUSH
116473: LD_INT 21
116475: PUSH
116476: LD_INT 22
116478: PUSH
116479: LD_INT 23
116481: PUSH
116482: LD_INT 24
116484: PUSH
116485: LD_INT 25
116487: PUSH
116488: LD_INT 26
116490: PUSH
116491: LD_INT 27
116493: PUSH
116494: LD_INT 28
116496: PUSH
116497: LD_INT 29
116499: PUSH
116500: LD_INT 30
116502: PUSH
116503: LD_INT 31
116505: PUSH
116506: LD_INT 32
116508: PUSH
116509: LD_INT 33
116511: PUSH
116512: LD_INT 34
116514: PUSH
116515: LD_INT 36
116517: PUSH
116518: EMPTY
116519: LIST
116520: LIST
116521: LIST
116522: LIST
116523: LIST
116524: LIST
116525: LIST
116526: LIST
116527: LIST
116528: LIST
116529: LIST
116530: LIST
116531: LIST
116532: LIST
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: LIST
116546: LIST
116547: LIST
116548: LIST
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: LIST
116554: PUSH
116555: LD_INT 101
116557: PUSH
116558: LD_INT 102
116560: PUSH
116561: LD_INT 103
116563: PUSH
116564: LD_INT 104
116566: PUSH
116567: LD_INT 105
116569: PUSH
116570: LD_INT 106
116572: PUSH
116573: LD_INT 107
116575: PUSH
116576: LD_INT 108
116578: PUSH
116579: LD_INT 109
116581: PUSH
116582: LD_INT 110
116584: PUSH
116585: LD_INT 111
116587: PUSH
116588: LD_INT 112
116590: PUSH
116591: LD_INT 113
116593: PUSH
116594: LD_INT 114
116596: PUSH
116597: LD_INT 116
116599: PUSH
116600: LD_INT 117
116602: PUSH
116603: LD_INT 118
116605: PUSH
116606: EMPTY
116607: LIST
116608: LIST
116609: LIST
116610: LIST
116611: LIST
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: LIST
116618: LIST
116619: LIST
116620: LIST
116621: LIST
116622: LIST
116623: LIST
116624: PUSH
116625: EMPTY
116626: LIST
116627: LIST
116628: ST_TO_ADDR
116629: GO 117404
116631: LD_INT 16
116633: DOUBLE
116634: EQUAL
116635: IFTRUE 116639
116637: GO 116775
116639: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
116640: LD_ADDR_VAR 0 2
116644: PUSH
116645: LD_INT 2
116647: PUSH
116648: LD_INT 4
116650: PUSH
116651: LD_INT 5
116653: PUSH
116654: LD_INT 7
116656: PUSH
116657: LD_INT 11
116659: PUSH
116660: LD_INT 12
116662: PUSH
116663: LD_INT 15
116665: PUSH
116666: LD_INT 16
116668: PUSH
116669: LD_INT 20
116671: PUSH
116672: LD_INT 21
116674: PUSH
116675: LD_INT 22
116677: PUSH
116678: LD_INT 23
116680: PUSH
116681: LD_INT 25
116683: PUSH
116684: LD_INT 26
116686: PUSH
116687: LD_INT 30
116689: PUSH
116690: LD_INT 31
116692: PUSH
116693: LD_INT 32
116695: PUSH
116696: LD_INT 33
116698: PUSH
116699: LD_INT 34
116701: PUSH
116702: EMPTY
116703: LIST
116704: LIST
116705: LIST
116706: LIST
116707: LIST
116708: LIST
116709: LIST
116710: LIST
116711: LIST
116712: LIST
116713: LIST
116714: LIST
116715: LIST
116716: LIST
116717: LIST
116718: LIST
116719: LIST
116720: LIST
116721: LIST
116722: PUSH
116723: LD_INT 101
116725: PUSH
116726: LD_INT 102
116728: PUSH
116729: LD_INT 103
116731: PUSH
116732: LD_INT 106
116734: PUSH
116735: LD_INT 108
116737: PUSH
116738: LD_INT 112
116740: PUSH
116741: LD_INT 113
116743: PUSH
116744: LD_INT 114
116746: PUSH
116747: LD_INT 116
116749: PUSH
116750: LD_INT 117
116752: PUSH
116753: LD_INT 118
116755: PUSH
116756: EMPTY
116757: LIST
116758: LIST
116759: LIST
116760: LIST
116761: LIST
116762: LIST
116763: LIST
116764: LIST
116765: LIST
116766: LIST
116767: LIST
116768: PUSH
116769: EMPTY
116770: LIST
116771: LIST
116772: ST_TO_ADDR
116773: GO 117404
116775: LD_INT 17
116777: DOUBLE
116778: EQUAL
116779: IFTRUE 116783
116781: GO 117007
116783: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116784: LD_ADDR_VAR 0 2
116788: PUSH
116789: LD_INT 1
116791: PUSH
116792: LD_INT 2
116794: PUSH
116795: LD_INT 3
116797: PUSH
116798: LD_INT 4
116800: PUSH
116801: LD_INT 5
116803: PUSH
116804: LD_INT 6
116806: PUSH
116807: LD_INT 7
116809: PUSH
116810: LD_INT 8
116812: PUSH
116813: LD_INT 9
116815: PUSH
116816: LD_INT 10
116818: PUSH
116819: LD_INT 11
116821: PUSH
116822: LD_INT 12
116824: PUSH
116825: LD_INT 13
116827: PUSH
116828: LD_INT 14
116830: PUSH
116831: LD_INT 15
116833: PUSH
116834: LD_INT 16
116836: PUSH
116837: LD_INT 17
116839: PUSH
116840: LD_INT 18
116842: PUSH
116843: LD_INT 19
116845: PUSH
116846: LD_INT 20
116848: PUSH
116849: LD_INT 21
116851: PUSH
116852: LD_INT 22
116854: PUSH
116855: LD_INT 23
116857: PUSH
116858: LD_INT 24
116860: PUSH
116861: LD_INT 25
116863: PUSH
116864: LD_INT 26
116866: PUSH
116867: LD_INT 27
116869: PUSH
116870: LD_INT 28
116872: PUSH
116873: LD_INT 29
116875: PUSH
116876: LD_INT 30
116878: PUSH
116879: LD_INT 31
116881: PUSH
116882: LD_INT 32
116884: PUSH
116885: LD_INT 33
116887: PUSH
116888: LD_INT 34
116890: PUSH
116891: LD_INT 36
116893: PUSH
116894: EMPTY
116895: LIST
116896: LIST
116897: LIST
116898: LIST
116899: LIST
116900: LIST
116901: LIST
116902: LIST
116903: LIST
116904: LIST
116905: LIST
116906: LIST
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: LIST
116912: LIST
116913: LIST
116914: LIST
116915: LIST
116916: LIST
116917: LIST
116918: LIST
116919: LIST
116920: LIST
116921: LIST
116922: LIST
116923: LIST
116924: LIST
116925: LIST
116926: LIST
116927: LIST
116928: LIST
116929: LIST
116930: PUSH
116931: LD_INT 101
116933: PUSH
116934: LD_INT 102
116936: PUSH
116937: LD_INT 103
116939: PUSH
116940: LD_INT 104
116942: PUSH
116943: LD_INT 105
116945: PUSH
116946: LD_INT 106
116948: PUSH
116949: LD_INT 107
116951: PUSH
116952: LD_INT 108
116954: PUSH
116955: LD_INT 109
116957: PUSH
116958: LD_INT 110
116960: PUSH
116961: LD_INT 111
116963: PUSH
116964: LD_INT 112
116966: PUSH
116967: LD_INT 113
116969: PUSH
116970: LD_INT 114
116972: PUSH
116973: LD_INT 116
116975: PUSH
116976: LD_INT 117
116978: PUSH
116979: LD_INT 118
116981: PUSH
116982: EMPTY
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: LIST
116993: LIST
116994: LIST
116995: LIST
116996: LIST
116997: LIST
116998: LIST
116999: LIST
117000: PUSH
117001: EMPTY
117002: LIST
117003: LIST
117004: ST_TO_ADDR
117005: GO 117404
117007: LD_INT 18
117009: DOUBLE
117010: EQUAL
117011: IFTRUE 117015
117013: GO 117163
117015: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117016: LD_ADDR_VAR 0 2
117020: PUSH
117021: LD_INT 2
117023: PUSH
117024: LD_INT 4
117026: PUSH
117027: LD_INT 5
117029: PUSH
117030: LD_INT 7
117032: PUSH
117033: LD_INT 11
117035: PUSH
117036: LD_INT 12
117038: PUSH
117039: LD_INT 15
117041: PUSH
117042: LD_INT 16
117044: PUSH
117045: LD_INT 20
117047: PUSH
117048: LD_INT 21
117050: PUSH
117051: LD_INT 22
117053: PUSH
117054: LD_INT 23
117056: PUSH
117057: LD_INT 25
117059: PUSH
117060: LD_INT 26
117062: PUSH
117063: LD_INT 30
117065: PUSH
117066: LD_INT 31
117068: PUSH
117069: LD_INT 32
117071: PUSH
117072: LD_INT 33
117074: PUSH
117075: LD_INT 34
117077: PUSH
117078: LD_INT 35
117080: PUSH
117081: LD_INT 36
117083: PUSH
117084: EMPTY
117085: LIST
117086: LIST
117087: LIST
117088: LIST
117089: LIST
117090: LIST
117091: LIST
117092: LIST
117093: LIST
117094: LIST
117095: LIST
117096: LIST
117097: LIST
117098: LIST
117099: LIST
117100: LIST
117101: LIST
117102: LIST
117103: LIST
117104: LIST
117105: LIST
117106: PUSH
117107: LD_INT 101
117109: PUSH
117110: LD_INT 102
117112: PUSH
117113: LD_INT 103
117115: PUSH
117116: LD_INT 106
117118: PUSH
117119: LD_INT 108
117121: PUSH
117122: LD_INT 112
117124: PUSH
117125: LD_INT 113
117127: PUSH
117128: LD_INT 114
117130: PUSH
117131: LD_INT 115
117133: PUSH
117134: LD_INT 116
117136: PUSH
117137: LD_INT 117
117139: PUSH
117140: LD_INT 118
117142: PUSH
117143: EMPTY
117144: LIST
117145: LIST
117146: LIST
117147: LIST
117148: LIST
117149: LIST
117150: LIST
117151: LIST
117152: LIST
117153: LIST
117154: LIST
117155: LIST
117156: PUSH
117157: EMPTY
117158: LIST
117159: LIST
117160: ST_TO_ADDR
117161: GO 117404
117163: LD_INT 19
117165: DOUBLE
117166: EQUAL
117167: IFTRUE 117171
117169: GO 117403
117171: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117172: LD_ADDR_VAR 0 2
117176: PUSH
117177: LD_INT 1
117179: PUSH
117180: LD_INT 2
117182: PUSH
117183: LD_INT 3
117185: PUSH
117186: LD_INT 4
117188: PUSH
117189: LD_INT 5
117191: PUSH
117192: LD_INT 6
117194: PUSH
117195: LD_INT 7
117197: PUSH
117198: LD_INT 8
117200: PUSH
117201: LD_INT 9
117203: PUSH
117204: LD_INT 10
117206: PUSH
117207: LD_INT 11
117209: PUSH
117210: LD_INT 12
117212: PUSH
117213: LD_INT 13
117215: PUSH
117216: LD_INT 14
117218: PUSH
117219: LD_INT 15
117221: PUSH
117222: LD_INT 16
117224: PUSH
117225: LD_INT 17
117227: PUSH
117228: LD_INT 18
117230: PUSH
117231: LD_INT 19
117233: PUSH
117234: LD_INT 20
117236: PUSH
117237: LD_INT 21
117239: PUSH
117240: LD_INT 22
117242: PUSH
117243: LD_INT 23
117245: PUSH
117246: LD_INT 24
117248: PUSH
117249: LD_INT 25
117251: PUSH
117252: LD_INT 26
117254: PUSH
117255: LD_INT 27
117257: PUSH
117258: LD_INT 28
117260: PUSH
117261: LD_INT 29
117263: PUSH
117264: LD_INT 30
117266: PUSH
117267: LD_INT 31
117269: PUSH
117270: LD_INT 32
117272: PUSH
117273: LD_INT 33
117275: PUSH
117276: LD_INT 34
117278: PUSH
117279: LD_INT 35
117281: PUSH
117282: LD_INT 36
117284: PUSH
117285: EMPTY
117286: LIST
117287: LIST
117288: LIST
117289: LIST
117290: LIST
117291: LIST
117292: LIST
117293: LIST
117294: LIST
117295: LIST
117296: LIST
117297: LIST
117298: LIST
117299: LIST
117300: LIST
117301: LIST
117302: LIST
117303: LIST
117304: LIST
117305: LIST
117306: LIST
117307: LIST
117308: LIST
117309: LIST
117310: LIST
117311: LIST
117312: LIST
117313: LIST
117314: LIST
117315: LIST
117316: LIST
117317: LIST
117318: LIST
117319: LIST
117320: LIST
117321: LIST
117322: PUSH
117323: LD_INT 101
117325: PUSH
117326: LD_INT 102
117328: PUSH
117329: LD_INT 103
117331: PUSH
117332: LD_INT 104
117334: PUSH
117335: LD_INT 105
117337: PUSH
117338: LD_INT 106
117340: PUSH
117341: LD_INT 107
117343: PUSH
117344: LD_INT 108
117346: PUSH
117347: LD_INT 109
117349: PUSH
117350: LD_INT 110
117352: PUSH
117353: LD_INT 111
117355: PUSH
117356: LD_INT 112
117358: PUSH
117359: LD_INT 113
117361: PUSH
117362: LD_INT 114
117364: PUSH
117365: LD_INT 115
117367: PUSH
117368: LD_INT 116
117370: PUSH
117371: LD_INT 117
117373: PUSH
117374: LD_INT 118
117376: PUSH
117377: EMPTY
117378: LIST
117379: LIST
117380: LIST
117381: LIST
117382: LIST
117383: LIST
117384: LIST
117385: LIST
117386: LIST
117387: LIST
117388: LIST
117389: LIST
117390: LIST
117391: LIST
117392: LIST
117393: LIST
117394: LIST
117395: LIST
117396: PUSH
117397: EMPTY
117398: LIST
117399: LIST
117400: ST_TO_ADDR
117401: GO 117404
117403: POP
// end else
117404: GO 117635
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
117406: LD_ADDR_VAR 0 2
117410: PUSH
117411: LD_INT 1
117413: PUSH
117414: LD_INT 2
117416: PUSH
117417: LD_INT 3
117419: PUSH
117420: LD_INT 4
117422: PUSH
117423: LD_INT 5
117425: PUSH
117426: LD_INT 6
117428: PUSH
117429: LD_INT 7
117431: PUSH
117432: LD_INT 8
117434: PUSH
117435: LD_INT 9
117437: PUSH
117438: LD_INT 10
117440: PUSH
117441: LD_INT 11
117443: PUSH
117444: LD_INT 12
117446: PUSH
117447: LD_INT 13
117449: PUSH
117450: LD_INT 14
117452: PUSH
117453: LD_INT 15
117455: PUSH
117456: LD_INT 16
117458: PUSH
117459: LD_INT 17
117461: PUSH
117462: LD_INT 18
117464: PUSH
117465: LD_INT 19
117467: PUSH
117468: LD_INT 20
117470: PUSH
117471: LD_INT 21
117473: PUSH
117474: LD_INT 22
117476: PUSH
117477: LD_INT 23
117479: PUSH
117480: LD_INT 24
117482: PUSH
117483: LD_INT 25
117485: PUSH
117486: LD_INT 26
117488: PUSH
117489: LD_INT 27
117491: PUSH
117492: LD_INT 28
117494: PUSH
117495: LD_INT 29
117497: PUSH
117498: LD_INT 30
117500: PUSH
117501: LD_INT 31
117503: PUSH
117504: LD_INT 32
117506: PUSH
117507: LD_INT 33
117509: PUSH
117510: LD_INT 34
117512: PUSH
117513: LD_INT 35
117515: PUSH
117516: LD_INT 36
117518: PUSH
117519: EMPTY
117520: LIST
117521: LIST
117522: LIST
117523: LIST
117524: LIST
117525: LIST
117526: LIST
117527: LIST
117528: LIST
117529: LIST
117530: LIST
117531: LIST
117532: LIST
117533: LIST
117534: LIST
117535: LIST
117536: LIST
117537: LIST
117538: LIST
117539: LIST
117540: LIST
117541: LIST
117542: LIST
117543: LIST
117544: LIST
117545: LIST
117546: LIST
117547: LIST
117548: LIST
117549: LIST
117550: LIST
117551: LIST
117552: LIST
117553: LIST
117554: LIST
117555: LIST
117556: PUSH
117557: LD_INT 101
117559: PUSH
117560: LD_INT 102
117562: PUSH
117563: LD_INT 103
117565: PUSH
117566: LD_INT 104
117568: PUSH
117569: LD_INT 105
117571: PUSH
117572: LD_INT 106
117574: PUSH
117575: LD_INT 107
117577: PUSH
117578: LD_INT 108
117580: PUSH
117581: LD_INT 109
117583: PUSH
117584: LD_INT 110
117586: PUSH
117587: LD_INT 111
117589: PUSH
117590: LD_INT 112
117592: PUSH
117593: LD_INT 113
117595: PUSH
117596: LD_INT 114
117598: PUSH
117599: LD_INT 115
117601: PUSH
117602: LD_INT 116
117604: PUSH
117605: LD_INT 117
117607: PUSH
117608: LD_INT 118
117610: PUSH
117611: EMPTY
117612: LIST
117613: LIST
117614: LIST
117615: LIST
117616: LIST
117617: LIST
117618: LIST
117619: LIST
117620: LIST
117621: LIST
117622: LIST
117623: LIST
117624: LIST
117625: LIST
117626: LIST
117627: LIST
117628: LIST
117629: LIST
117630: PUSH
117631: EMPTY
117632: LIST
117633: LIST
117634: ST_TO_ADDR
// if result then
117635: LD_VAR 0 2
117639: IFFALSE 118425
// begin normal :=  ;
117641: LD_ADDR_VAR 0 5
117645: PUSH
117646: LD_STRING 
117648: ST_TO_ADDR
// hardcore :=  ;
117649: LD_ADDR_VAR 0 6
117653: PUSH
117654: LD_STRING 
117656: ST_TO_ADDR
// active :=  ;
117657: LD_ADDR_VAR 0 7
117661: PUSH
117662: LD_STRING 
117664: ST_TO_ADDR
// for i = 1 to normalCounter do
117665: LD_ADDR_VAR 0 8
117669: PUSH
117670: DOUBLE
117671: LD_INT 1
117673: DEC
117674: ST_TO_ADDR
117675: LD_EXP 149
117679: PUSH
117680: FOR_TO
117681: IFFALSE 117782
// begin tmp := 0 ;
117683: LD_ADDR_VAR 0 3
117687: PUSH
117688: LD_STRING 0
117690: ST_TO_ADDR
// if result [ 1 ] then
117691: LD_VAR 0 2
117695: PUSH
117696: LD_INT 1
117698: ARRAY
117699: IFFALSE 117764
// if result [ 1 ] [ 1 ] = i then
117701: LD_VAR 0 2
117705: PUSH
117706: LD_INT 1
117708: ARRAY
117709: PUSH
117710: LD_INT 1
117712: ARRAY
117713: PUSH
117714: LD_VAR 0 8
117718: EQUAL
117719: IFFALSE 117764
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117721: LD_ADDR_VAR 0 2
117725: PUSH
117726: LD_VAR 0 2
117730: PPUSH
117731: LD_INT 1
117733: PPUSH
117734: LD_VAR 0 2
117738: PUSH
117739: LD_INT 1
117741: ARRAY
117742: PPUSH
117743: LD_INT 1
117745: PPUSH
117746: CALL_OW 3
117750: PPUSH
117751: CALL_OW 1
117755: ST_TO_ADDR
// tmp := 1 ;
117756: LD_ADDR_VAR 0 3
117760: PUSH
117761: LD_STRING 1
117763: ST_TO_ADDR
// end ; normal := normal & tmp ;
117764: LD_ADDR_VAR 0 5
117768: PUSH
117769: LD_VAR 0 5
117773: PUSH
117774: LD_VAR 0 3
117778: STR
117779: ST_TO_ADDR
// end ;
117780: GO 117680
117782: POP
117783: POP
// for i = 1 to hardcoreCounter do
117784: LD_ADDR_VAR 0 8
117788: PUSH
117789: DOUBLE
117790: LD_INT 1
117792: DEC
117793: ST_TO_ADDR
117794: LD_EXP 150
117798: PUSH
117799: FOR_TO
117800: IFFALSE 117905
// begin tmp := 0 ;
117802: LD_ADDR_VAR 0 3
117806: PUSH
117807: LD_STRING 0
117809: ST_TO_ADDR
// if result [ 2 ] then
117810: LD_VAR 0 2
117814: PUSH
117815: LD_INT 2
117817: ARRAY
117818: IFFALSE 117887
// if result [ 2 ] [ 1 ] = 100 + i then
117820: LD_VAR 0 2
117824: PUSH
117825: LD_INT 2
117827: ARRAY
117828: PUSH
117829: LD_INT 1
117831: ARRAY
117832: PUSH
117833: LD_INT 100
117835: PUSH
117836: LD_VAR 0 8
117840: PLUS
117841: EQUAL
117842: IFFALSE 117887
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117844: LD_ADDR_VAR 0 2
117848: PUSH
117849: LD_VAR 0 2
117853: PPUSH
117854: LD_INT 2
117856: PPUSH
117857: LD_VAR 0 2
117861: PUSH
117862: LD_INT 2
117864: ARRAY
117865: PPUSH
117866: LD_INT 1
117868: PPUSH
117869: CALL_OW 3
117873: PPUSH
117874: CALL_OW 1
117878: ST_TO_ADDR
// tmp := 1 ;
117879: LD_ADDR_VAR 0 3
117883: PUSH
117884: LD_STRING 1
117886: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
117887: LD_ADDR_VAR 0 6
117891: PUSH
117892: LD_VAR 0 6
117896: PUSH
117897: LD_VAR 0 3
117901: STR
117902: ST_TO_ADDR
// end ;
117903: GO 117799
117905: POP
117906: POP
// if isGameLoad then
117907: LD_VAR 0 1
117911: IFFALSE 118386
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
117913: LD_ADDR_VAR 0 4
117917: PUSH
117918: LD_EXP 153
117922: PUSH
117923: LD_EXP 152
117927: PUSH
117928: LD_EXP 154
117932: PUSH
117933: LD_EXP 151
117937: PUSH
117938: LD_EXP 155
117942: PUSH
117943: LD_EXP 156
117947: PUSH
117948: LD_EXP 157
117952: PUSH
117953: LD_EXP 158
117957: PUSH
117958: LD_EXP 159
117962: PUSH
117963: LD_EXP 160
117967: PUSH
117968: LD_EXP 161
117972: PUSH
117973: LD_EXP 162
117977: PUSH
117978: LD_EXP 163
117982: PUSH
117983: LD_EXP 164
117987: PUSH
117988: LD_EXP 172
117992: PUSH
117993: LD_EXP 173
117997: PUSH
117998: LD_EXP 174
118002: PUSH
118003: LD_EXP 175
118007: PUSH
118008: LD_EXP 177
118012: PUSH
118013: LD_EXP 178
118017: PUSH
118018: LD_EXP 179
118022: PUSH
118023: LD_EXP 182
118027: PUSH
118028: LD_EXP 184
118032: PUSH
118033: LD_EXP 185
118037: PUSH
118038: LD_EXP 186
118042: PUSH
118043: LD_EXP 188
118047: PUSH
118048: LD_EXP 189
118052: PUSH
118053: LD_EXP 192
118057: PUSH
118058: LD_EXP 193
118062: PUSH
118063: LD_EXP 194
118067: PUSH
118068: LD_EXP 195
118072: PUSH
118073: LD_EXP 196
118077: PUSH
118078: LD_EXP 197
118082: PUSH
118083: LD_EXP 198
118087: PUSH
118088: LD_EXP 199
118092: PUSH
118093: LD_EXP 200
118097: PUSH
118098: LD_EXP 165
118102: PUSH
118103: LD_EXP 166
118107: PUSH
118108: LD_EXP 169
118112: PUSH
118113: LD_EXP 170
118117: PUSH
118118: LD_EXP 171
118122: PUSH
118123: LD_EXP 167
118127: PUSH
118128: LD_EXP 168
118132: PUSH
118133: LD_EXP 176
118137: PUSH
118138: LD_EXP 180
118142: PUSH
118143: LD_EXP 181
118147: PUSH
118148: LD_EXP 183
118152: PUSH
118153: LD_EXP 187
118157: PUSH
118158: LD_EXP 190
118162: PUSH
118163: LD_EXP 191
118167: PUSH
118168: LD_EXP 201
118172: PUSH
118173: LD_EXP 202
118177: PUSH
118178: LD_EXP 203
118182: PUSH
118183: LD_EXP 204
118187: PUSH
118188: EMPTY
118189: LIST
118190: LIST
118191: LIST
118192: LIST
118193: LIST
118194: LIST
118195: LIST
118196: LIST
118197: LIST
118198: LIST
118199: LIST
118200: LIST
118201: LIST
118202: LIST
118203: LIST
118204: LIST
118205: LIST
118206: LIST
118207: LIST
118208: LIST
118209: LIST
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: LIST
118221: LIST
118222: LIST
118223: LIST
118224: LIST
118225: LIST
118226: LIST
118227: LIST
118228: LIST
118229: LIST
118230: LIST
118231: LIST
118232: LIST
118233: LIST
118234: LIST
118235: LIST
118236: LIST
118237: LIST
118238: LIST
118239: LIST
118240: LIST
118241: LIST
118242: LIST
118243: ST_TO_ADDR
// tmp :=  ;
118244: LD_ADDR_VAR 0 3
118248: PUSH
118249: LD_STRING 
118251: ST_TO_ADDR
// for i = 1 to normalCounter do
118252: LD_ADDR_VAR 0 8
118256: PUSH
118257: DOUBLE
118258: LD_INT 1
118260: DEC
118261: ST_TO_ADDR
118262: LD_EXP 149
118266: PUSH
118267: FOR_TO
118268: IFFALSE 118304
// begin if flags [ i ] then
118270: LD_VAR 0 4
118274: PUSH
118275: LD_VAR 0 8
118279: ARRAY
118280: IFFALSE 118302
// tmp := tmp & i & ; ;
118282: LD_ADDR_VAR 0 3
118286: PUSH
118287: LD_VAR 0 3
118291: PUSH
118292: LD_VAR 0 8
118296: STR
118297: PUSH
118298: LD_STRING ;
118300: STR
118301: ST_TO_ADDR
// end ;
118302: GO 118267
118304: POP
118305: POP
// for i = 1 to hardcoreCounter do
118306: LD_ADDR_VAR 0 8
118310: PUSH
118311: DOUBLE
118312: LD_INT 1
118314: DEC
118315: ST_TO_ADDR
118316: LD_EXP 150
118320: PUSH
118321: FOR_TO
118322: IFFALSE 118368
// begin if flags [ normalCounter + i ] then
118324: LD_VAR 0 4
118328: PUSH
118329: LD_EXP 149
118333: PUSH
118334: LD_VAR 0 8
118338: PLUS
118339: ARRAY
118340: IFFALSE 118366
// tmp := tmp & ( 100 + i ) & ; ;
118342: LD_ADDR_VAR 0 3
118346: PUSH
118347: LD_VAR 0 3
118351: PUSH
118352: LD_INT 100
118354: PUSH
118355: LD_VAR 0 8
118359: PLUS
118360: STR
118361: PUSH
118362: LD_STRING ;
118364: STR
118365: ST_TO_ADDR
// end ;
118366: GO 118321
118368: POP
118369: POP
// if tmp then
118370: LD_VAR 0 3
118374: IFFALSE 118386
// active := tmp ;
118376: LD_ADDR_VAR 0 7
118380: PUSH
118381: LD_VAR 0 3
118385: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
118386: LD_STRING getStreamItemsFromMission("
118388: PUSH
118389: LD_VAR 0 5
118393: STR
118394: PUSH
118395: LD_STRING ","
118397: STR
118398: PUSH
118399: LD_VAR 0 6
118403: STR
118404: PUSH
118405: LD_STRING ","
118407: STR
118408: PUSH
118409: LD_VAR 0 7
118413: STR
118414: PUSH
118415: LD_STRING ")
118417: STR
118418: PPUSH
118419: CALL_OW 559
// end else
118423: GO 118432
// ToLua ( getStreamItemsFromMission("","","") ) ;
118425: LD_STRING getStreamItemsFromMission("","","")
118427: PPUSH
118428: CALL_OW 559
// end ;
118432: LD_VAR 0 2
118436: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
118437: LD_EXP 148
118441: PUSH
118442: LD_EXP 153
118446: AND
118447: IFFALSE 118571
118449: GO 118451
118451: DISABLE
118452: LD_INT 0
118454: PPUSH
118455: PPUSH
// begin enable ;
118456: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
118457: LD_ADDR_VAR 0 2
118461: PUSH
118462: LD_INT 22
118464: PUSH
118465: LD_OWVAR 2
118469: PUSH
118470: EMPTY
118471: LIST
118472: LIST
118473: PUSH
118474: LD_INT 2
118476: PUSH
118477: LD_INT 34
118479: PUSH
118480: LD_INT 7
118482: PUSH
118483: EMPTY
118484: LIST
118485: LIST
118486: PUSH
118487: LD_INT 34
118489: PUSH
118490: LD_INT 45
118492: PUSH
118493: EMPTY
118494: LIST
118495: LIST
118496: PUSH
118497: LD_INT 34
118499: PUSH
118500: LD_INT 28
118502: PUSH
118503: EMPTY
118504: LIST
118505: LIST
118506: PUSH
118507: LD_INT 34
118509: PUSH
118510: LD_INT 47
118512: PUSH
118513: EMPTY
118514: LIST
118515: LIST
118516: PUSH
118517: EMPTY
118518: LIST
118519: LIST
118520: LIST
118521: LIST
118522: LIST
118523: PUSH
118524: EMPTY
118525: LIST
118526: LIST
118527: PPUSH
118528: CALL_OW 69
118532: ST_TO_ADDR
// if not tmp then
118533: LD_VAR 0 2
118537: NOT
118538: IFFALSE 118542
// exit ;
118540: GO 118571
// for i in tmp do
118542: LD_ADDR_VAR 0 1
118546: PUSH
118547: LD_VAR 0 2
118551: PUSH
118552: FOR_IN
118553: IFFALSE 118569
// begin SetLives ( i , 0 ) ;
118555: LD_VAR 0 1
118559: PPUSH
118560: LD_INT 0
118562: PPUSH
118563: CALL_OW 234
// end ;
118567: GO 118552
118569: POP
118570: POP
// end ;
118571: PPOPN 2
118573: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
118574: LD_EXP 148
118578: PUSH
118579: LD_EXP 154
118583: AND
118584: IFFALSE 118668
118586: GO 118588
118588: DISABLE
118589: LD_INT 0
118591: PPUSH
118592: PPUSH
// begin enable ;
118593: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
118594: LD_ADDR_VAR 0 2
118598: PUSH
118599: LD_INT 22
118601: PUSH
118602: LD_OWVAR 2
118606: PUSH
118607: EMPTY
118608: LIST
118609: LIST
118610: PUSH
118611: LD_INT 32
118613: PUSH
118614: LD_INT 3
118616: PUSH
118617: EMPTY
118618: LIST
118619: LIST
118620: PUSH
118621: EMPTY
118622: LIST
118623: LIST
118624: PPUSH
118625: CALL_OW 69
118629: ST_TO_ADDR
// if not tmp then
118630: LD_VAR 0 2
118634: NOT
118635: IFFALSE 118639
// exit ;
118637: GO 118668
// for i in tmp do
118639: LD_ADDR_VAR 0 1
118643: PUSH
118644: LD_VAR 0 2
118648: PUSH
118649: FOR_IN
118650: IFFALSE 118666
// begin SetLives ( i , 0 ) ;
118652: LD_VAR 0 1
118656: PPUSH
118657: LD_INT 0
118659: PPUSH
118660: CALL_OW 234
// end ;
118664: GO 118649
118666: POP
118667: POP
// end ;
118668: PPOPN 2
118670: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
118671: LD_EXP 148
118675: PUSH
118676: LD_EXP 151
118680: AND
118681: IFFALSE 118774
118683: GO 118685
118685: DISABLE
118686: LD_INT 0
118688: PPUSH
// begin enable ;
118689: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
118690: LD_ADDR_VAR 0 1
118694: PUSH
118695: LD_INT 22
118697: PUSH
118698: LD_OWVAR 2
118702: PUSH
118703: EMPTY
118704: LIST
118705: LIST
118706: PUSH
118707: LD_INT 2
118709: PUSH
118710: LD_INT 25
118712: PUSH
118713: LD_INT 5
118715: PUSH
118716: EMPTY
118717: LIST
118718: LIST
118719: PUSH
118720: LD_INT 25
118722: PUSH
118723: LD_INT 9
118725: PUSH
118726: EMPTY
118727: LIST
118728: LIST
118729: PUSH
118730: LD_INT 25
118732: PUSH
118733: LD_INT 8
118735: PUSH
118736: EMPTY
118737: LIST
118738: LIST
118739: PUSH
118740: EMPTY
118741: LIST
118742: LIST
118743: LIST
118744: LIST
118745: PUSH
118746: EMPTY
118747: LIST
118748: LIST
118749: PPUSH
118750: CALL_OW 69
118754: PUSH
118755: FOR_IN
118756: IFFALSE 118772
// begin SetClass ( i , 1 ) ;
118758: LD_VAR 0 1
118762: PPUSH
118763: LD_INT 1
118765: PPUSH
118766: CALL_OW 336
// end ;
118770: GO 118755
118772: POP
118773: POP
// end ;
118774: PPOPN 1
118776: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118777: LD_EXP 148
118781: PUSH
118782: LD_EXP 152
118786: AND
118787: PUSH
118788: LD_OWVAR 65
118792: PUSH
118793: LD_INT 7
118795: LESS
118796: AND
118797: IFFALSE 118811
118799: GO 118801
118801: DISABLE
// begin enable ;
118802: ENABLE
// game_speed := 7 ;
118803: LD_ADDR_OWVAR 65
118807: PUSH
118808: LD_INT 7
118810: ST_TO_ADDR
// end ;
118811: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118812: LD_EXP 148
118816: PUSH
118817: LD_EXP 155
118821: AND
118822: IFFALSE 119024
118824: GO 118826
118826: DISABLE
118827: LD_INT 0
118829: PPUSH
118830: PPUSH
118831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118832: LD_ADDR_VAR 0 3
118836: PUSH
118837: LD_INT 81
118839: PUSH
118840: LD_OWVAR 2
118844: PUSH
118845: EMPTY
118846: LIST
118847: LIST
118848: PUSH
118849: LD_INT 21
118851: PUSH
118852: LD_INT 1
118854: PUSH
118855: EMPTY
118856: LIST
118857: LIST
118858: PUSH
118859: EMPTY
118860: LIST
118861: LIST
118862: PPUSH
118863: CALL_OW 69
118867: ST_TO_ADDR
// if not tmp then
118868: LD_VAR 0 3
118872: NOT
118873: IFFALSE 118877
// exit ;
118875: GO 119024
// if tmp > 5 then
118877: LD_VAR 0 3
118881: PUSH
118882: LD_INT 5
118884: GREATER
118885: IFFALSE 118897
// k := 5 else
118887: LD_ADDR_VAR 0 2
118891: PUSH
118892: LD_INT 5
118894: ST_TO_ADDR
118895: GO 118907
// k := tmp ;
118897: LD_ADDR_VAR 0 2
118901: PUSH
118902: LD_VAR 0 3
118906: ST_TO_ADDR
// for i := 1 to k do
118907: LD_ADDR_VAR 0 1
118911: PUSH
118912: DOUBLE
118913: LD_INT 1
118915: DEC
118916: ST_TO_ADDR
118917: LD_VAR 0 2
118921: PUSH
118922: FOR_TO
118923: IFFALSE 119022
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
118925: LD_VAR 0 3
118929: PUSH
118930: LD_VAR 0 1
118934: ARRAY
118935: PPUSH
118936: LD_VAR 0 1
118940: PUSH
118941: LD_INT 4
118943: MOD
118944: PUSH
118945: LD_INT 1
118947: PLUS
118948: PPUSH
118949: CALL_OW 259
118953: PUSH
118954: LD_INT 10
118956: LESS
118957: IFFALSE 119020
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
118959: LD_VAR 0 3
118963: PUSH
118964: LD_VAR 0 1
118968: ARRAY
118969: PPUSH
118970: LD_VAR 0 1
118974: PUSH
118975: LD_INT 4
118977: MOD
118978: PUSH
118979: LD_INT 1
118981: PLUS
118982: PPUSH
118983: LD_VAR 0 3
118987: PUSH
118988: LD_VAR 0 1
118992: ARRAY
118993: PPUSH
118994: LD_VAR 0 1
118998: PUSH
118999: LD_INT 4
119001: MOD
119002: PUSH
119003: LD_INT 1
119005: PLUS
119006: PPUSH
119007: CALL_OW 259
119011: PUSH
119012: LD_INT 1
119014: PLUS
119015: PPUSH
119016: CALL_OW 237
119020: GO 118922
119022: POP
119023: POP
// end ;
119024: PPOPN 3
119026: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119027: LD_EXP 148
119031: PUSH
119032: LD_EXP 156
119036: AND
119037: IFFALSE 119057
119039: GO 119041
119041: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119042: LD_INT 4
119044: PPUSH
119045: LD_OWVAR 2
119049: PPUSH
119050: LD_INT 0
119052: PPUSH
119053: CALL_OW 324
119057: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119058: LD_EXP 148
119062: PUSH
119063: LD_EXP 185
119067: AND
119068: IFFALSE 119088
119070: GO 119072
119072: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119073: LD_INT 19
119075: PPUSH
119076: LD_OWVAR 2
119080: PPUSH
119081: LD_INT 0
119083: PPUSH
119084: CALL_OW 324
119088: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119089: LD_EXP 148
119093: PUSH
119094: LD_EXP 157
119098: AND
119099: IFFALSE 119201
119101: GO 119103
119103: DISABLE
119104: LD_INT 0
119106: PPUSH
119107: PPUSH
// begin enable ;
119108: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119109: LD_ADDR_VAR 0 2
119113: PUSH
119114: LD_INT 22
119116: PUSH
119117: LD_OWVAR 2
119121: PUSH
119122: EMPTY
119123: LIST
119124: LIST
119125: PUSH
119126: LD_INT 2
119128: PUSH
119129: LD_INT 34
119131: PUSH
119132: LD_INT 11
119134: PUSH
119135: EMPTY
119136: LIST
119137: LIST
119138: PUSH
119139: LD_INT 34
119141: PUSH
119142: LD_INT 30
119144: PUSH
119145: EMPTY
119146: LIST
119147: LIST
119148: PUSH
119149: EMPTY
119150: LIST
119151: LIST
119152: LIST
119153: PUSH
119154: EMPTY
119155: LIST
119156: LIST
119157: PPUSH
119158: CALL_OW 69
119162: ST_TO_ADDR
// if not tmp then
119163: LD_VAR 0 2
119167: NOT
119168: IFFALSE 119172
// exit ;
119170: GO 119201
// for i in tmp do
119172: LD_ADDR_VAR 0 1
119176: PUSH
119177: LD_VAR 0 2
119181: PUSH
119182: FOR_IN
119183: IFFALSE 119199
// begin SetLives ( i , 0 ) ;
119185: LD_VAR 0 1
119189: PPUSH
119190: LD_INT 0
119192: PPUSH
119193: CALL_OW 234
// end ;
119197: GO 119182
119199: POP
119200: POP
// end ;
119201: PPOPN 2
119203: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119204: LD_EXP 148
119208: PUSH
119209: LD_EXP 158
119213: AND
119214: IFFALSE 119234
119216: GO 119218
119218: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119219: LD_INT 32
119221: PPUSH
119222: LD_OWVAR 2
119226: PPUSH
119227: LD_INT 0
119229: PPUSH
119230: CALL_OW 324
119234: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119235: LD_EXP 148
119239: PUSH
119240: LD_EXP 159
119244: AND
119245: IFFALSE 119426
119247: GO 119249
119249: DISABLE
119250: LD_INT 0
119252: PPUSH
119253: PPUSH
119254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119255: LD_ADDR_VAR 0 2
119259: PUSH
119260: LD_INT 22
119262: PUSH
119263: LD_OWVAR 2
119267: PUSH
119268: EMPTY
119269: LIST
119270: LIST
119271: PUSH
119272: LD_INT 33
119274: PUSH
119275: LD_INT 3
119277: PUSH
119278: EMPTY
119279: LIST
119280: LIST
119281: PUSH
119282: EMPTY
119283: LIST
119284: LIST
119285: PPUSH
119286: CALL_OW 69
119290: ST_TO_ADDR
// if not tmp then
119291: LD_VAR 0 2
119295: NOT
119296: IFFALSE 119300
// exit ;
119298: GO 119426
// side := 0 ;
119300: LD_ADDR_VAR 0 3
119304: PUSH
119305: LD_INT 0
119307: ST_TO_ADDR
// for i := 1 to 8 do
119308: LD_ADDR_VAR 0 1
119312: PUSH
119313: DOUBLE
119314: LD_INT 1
119316: DEC
119317: ST_TO_ADDR
119318: LD_INT 8
119320: PUSH
119321: FOR_TO
119322: IFFALSE 119370
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
119324: LD_OWVAR 2
119328: PUSH
119329: LD_VAR 0 1
119333: NONEQUAL
119334: PUSH
119335: LD_OWVAR 2
119339: PPUSH
119340: LD_VAR 0 1
119344: PPUSH
119345: CALL_OW 81
119349: PUSH
119350: LD_INT 2
119352: EQUAL
119353: AND
119354: IFFALSE 119368
// begin side := i ;
119356: LD_ADDR_VAR 0 3
119360: PUSH
119361: LD_VAR 0 1
119365: ST_TO_ADDR
// break ;
119366: GO 119370
// end ;
119368: GO 119321
119370: POP
119371: POP
// if not side then
119372: LD_VAR 0 3
119376: NOT
119377: IFFALSE 119381
// exit ;
119379: GO 119426
// for i := 1 to tmp do
119381: LD_ADDR_VAR 0 1
119385: PUSH
119386: DOUBLE
119387: LD_INT 1
119389: DEC
119390: ST_TO_ADDR
119391: LD_VAR 0 2
119395: PUSH
119396: FOR_TO
119397: IFFALSE 119424
// if Prob ( 60 ) then
119399: LD_INT 60
119401: PPUSH
119402: CALL_OW 13
119406: IFFALSE 119422
// SetSide ( i , side ) ;
119408: LD_VAR 0 1
119412: PPUSH
119413: LD_VAR 0 3
119417: PPUSH
119418: CALL_OW 235
119422: GO 119396
119424: POP
119425: POP
// end ;
119426: PPOPN 3
119428: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
119429: LD_EXP 148
119433: PUSH
119434: LD_EXP 161
119438: AND
119439: IFFALSE 119558
119441: GO 119443
119443: DISABLE
119444: LD_INT 0
119446: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
119447: LD_ADDR_VAR 0 1
119451: PUSH
119452: LD_INT 22
119454: PUSH
119455: LD_OWVAR 2
119459: PUSH
119460: EMPTY
119461: LIST
119462: LIST
119463: PUSH
119464: LD_INT 21
119466: PUSH
119467: LD_INT 1
119469: PUSH
119470: EMPTY
119471: LIST
119472: LIST
119473: PUSH
119474: LD_INT 3
119476: PUSH
119477: LD_INT 23
119479: PUSH
119480: LD_INT 0
119482: PUSH
119483: EMPTY
119484: LIST
119485: LIST
119486: PUSH
119487: EMPTY
119488: LIST
119489: LIST
119490: PUSH
119491: EMPTY
119492: LIST
119493: LIST
119494: LIST
119495: PPUSH
119496: CALL_OW 69
119500: PUSH
119501: FOR_IN
119502: IFFALSE 119556
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
119504: LD_VAR 0 1
119508: PPUSH
119509: CALL_OW 257
119513: PUSH
119514: LD_INT 1
119516: PUSH
119517: LD_INT 2
119519: PUSH
119520: LD_INT 3
119522: PUSH
119523: LD_INT 4
119525: PUSH
119526: EMPTY
119527: LIST
119528: LIST
119529: LIST
119530: LIST
119531: IN
119532: IFFALSE 119554
// SetClass ( un , rand ( 1 , 4 ) ) ;
119534: LD_VAR 0 1
119538: PPUSH
119539: LD_INT 1
119541: PPUSH
119542: LD_INT 4
119544: PPUSH
119545: CALL_OW 12
119549: PPUSH
119550: CALL_OW 336
119554: GO 119501
119556: POP
119557: POP
// end ;
119558: PPOPN 1
119560: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
119561: LD_EXP 148
119565: PUSH
119566: LD_EXP 160
119570: AND
119571: IFFALSE 119650
119573: GO 119575
119575: DISABLE
119576: LD_INT 0
119578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119579: LD_ADDR_VAR 0 1
119583: PUSH
119584: LD_INT 22
119586: PUSH
119587: LD_OWVAR 2
119591: PUSH
119592: EMPTY
119593: LIST
119594: LIST
119595: PUSH
119596: LD_INT 21
119598: PUSH
119599: LD_INT 3
119601: PUSH
119602: EMPTY
119603: LIST
119604: LIST
119605: PUSH
119606: EMPTY
119607: LIST
119608: LIST
119609: PPUSH
119610: CALL_OW 69
119614: ST_TO_ADDR
// if not tmp then
119615: LD_VAR 0 1
119619: NOT
119620: IFFALSE 119624
// exit ;
119622: GO 119650
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
119624: LD_VAR 0 1
119628: PUSH
119629: LD_INT 1
119631: PPUSH
119632: LD_VAR 0 1
119636: PPUSH
119637: CALL_OW 12
119641: ARRAY
119642: PPUSH
119643: LD_INT 100
119645: PPUSH
119646: CALL_OW 234
// end ;
119650: PPOPN 1
119652: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
119653: LD_EXP 148
119657: PUSH
119658: LD_EXP 162
119662: AND
119663: IFFALSE 119761
119665: GO 119667
119667: DISABLE
119668: LD_INT 0
119670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119671: LD_ADDR_VAR 0 1
119675: PUSH
119676: LD_INT 22
119678: PUSH
119679: LD_OWVAR 2
119683: PUSH
119684: EMPTY
119685: LIST
119686: LIST
119687: PUSH
119688: LD_INT 21
119690: PUSH
119691: LD_INT 1
119693: PUSH
119694: EMPTY
119695: LIST
119696: LIST
119697: PUSH
119698: EMPTY
119699: LIST
119700: LIST
119701: PPUSH
119702: CALL_OW 69
119706: ST_TO_ADDR
// if not tmp then
119707: LD_VAR 0 1
119711: NOT
119712: IFFALSE 119716
// exit ;
119714: GO 119761
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119716: LD_VAR 0 1
119720: PUSH
119721: LD_INT 1
119723: PPUSH
119724: LD_VAR 0 1
119728: PPUSH
119729: CALL_OW 12
119733: ARRAY
119734: PPUSH
119735: LD_INT 1
119737: PPUSH
119738: LD_INT 4
119740: PPUSH
119741: CALL_OW 12
119745: PPUSH
119746: LD_INT 3000
119748: PPUSH
119749: LD_INT 9000
119751: PPUSH
119752: CALL_OW 12
119756: PPUSH
119757: CALL_OW 492
// end ;
119761: PPOPN 1
119763: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119764: LD_EXP 148
119768: PUSH
119769: LD_EXP 163
119773: AND
119774: IFFALSE 119794
119776: GO 119778
119778: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119779: LD_INT 1
119781: PPUSH
119782: LD_OWVAR 2
119786: PPUSH
119787: LD_INT 0
119789: PPUSH
119790: CALL_OW 324
119794: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119795: LD_EXP 148
119799: PUSH
119800: LD_EXP 164
119804: AND
119805: IFFALSE 119888
119807: GO 119809
119809: DISABLE
119810: LD_INT 0
119812: PPUSH
119813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119814: LD_ADDR_VAR 0 2
119818: PUSH
119819: LD_INT 22
119821: PUSH
119822: LD_OWVAR 2
119826: PUSH
119827: EMPTY
119828: LIST
119829: LIST
119830: PUSH
119831: LD_INT 21
119833: PUSH
119834: LD_INT 3
119836: PUSH
119837: EMPTY
119838: LIST
119839: LIST
119840: PUSH
119841: EMPTY
119842: LIST
119843: LIST
119844: PPUSH
119845: CALL_OW 69
119849: ST_TO_ADDR
// if not tmp then
119850: LD_VAR 0 2
119854: NOT
119855: IFFALSE 119859
// exit ;
119857: GO 119888
// for i in tmp do
119859: LD_ADDR_VAR 0 1
119863: PUSH
119864: LD_VAR 0 2
119868: PUSH
119869: FOR_IN
119870: IFFALSE 119886
// SetBLevel ( i , 10 ) ;
119872: LD_VAR 0 1
119876: PPUSH
119877: LD_INT 10
119879: PPUSH
119880: CALL_OW 241
119884: GO 119869
119886: POP
119887: POP
// end ;
119888: PPOPN 2
119890: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
119891: LD_EXP 148
119895: PUSH
119896: LD_EXP 165
119900: AND
119901: IFFALSE 120012
119903: GO 119905
119905: DISABLE
119906: LD_INT 0
119908: PPUSH
119909: PPUSH
119910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119911: LD_ADDR_VAR 0 3
119915: PUSH
119916: LD_INT 22
119918: PUSH
119919: LD_OWVAR 2
119923: PUSH
119924: EMPTY
119925: LIST
119926: LIST
119927: PUSH
119928: LD_INT 25
119930: PUSH
119931: LD_INT 1
119933: PUSH
119934: EMPTY
119935: LIST
119936: LIST
119937: PUSH
119938: EMPTY
119939: LIST
119940: LIST
119941: PPUSH
119942: CALL_OW 69
119946: ST_TO_ADDR
// if not tmp then
119947: LD_VAR 0 3
119951: NOT
119952: IFFALSE 119956
// exit ;
119954: GO 120012
// un := tmp [ rand ( 1 , tmp ) ] ;
119956: LD_ADDR_VAR 0 2
119960: PUSH
119961: LD_VAR 0 3
119965: PUSH
119966: LD_INT 1
119968: PPUSH
119969: LD_VAR 0 3
119973: PPUSH
119974: CALL_OW 12
119978: ARRAY
119979: ST_TO_ADDR
// if Crawls ( un ) then
119980: LD_VAR 0 2
119984: PPUSH
119985: CALL_OW 318
119989: IFFALSE 120000
// ComWalk ( un ) ;
119991: LD_VAR 0 2
119995: PPUSH
119996: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120000: LD_VAR 0 2
120004: PPUSH
120005: LD_INT 5
120007: PPUSH
120008: CALL_OW 336
// end ;
120012: PPOPN 3
120014: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120015: LD_EXP 148
120019: PUSH
120020: LD_EXP 166
120024: AND
120025: PUSH
120026: LD_OWVAR 67
120030: PUSH
120031: LD_INT 4
120033: LESS
120034: AND
120035: IFFALSE 120054
120037: GO 120039
120039: DISABLE
// begin Difficulty := Difficulty + 1 ;
120040: LD_ADDR_OWVAR 67
120044: PUSH
120045: LD_OWVAR 67
120049: PUSH
120050: LD_INT 1
120052: PLUS
120053: ST_TO_ADDR
// end ;
120054: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120055: LD_EXP 148
120059: PUSH
120060: LD_EXP 167
120064: AND
120065: IFFALSE 120168
120067: GO 120069
120069: DISABLE
120070: LD_INT 0
120072: PPUSH
// begin for i := 1 to 5 do
120073: LD_ADDR_VAR 0 1
120077: PUSH
120078: DOUBLE
120079: LD_INT 1
120081: DEC
120082: ST_TO_ADDR
120083: LD_INT 5
120085: PUSH
120086: FOR_TO
120087: IFFALSE 120166
// begin uc_nation := nation_nature ;
120089: LD_ADDR_OWVAR 21
120093: PUSH
120094: LD_INT 0
120096: ST_TO_ADDR
// uc_side := 0 ;
120097: LD_ADDR_OWVAR 20
120101: PUSH
120102: LD_INT 0
120104: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120105: LD_ADDR_OWVAR 29
120109: PUSH
120110: LD_INT 12
120112: PUSH
120113: LD_INT 12
120115: PUSH
120116: EMPTY
120117: LIST
120118: LIST
120119: ST_TO_ADDR
// hc_agressivity := 20 ;
120120: LD_ADDR_OWVAR 35
120124: PUSH
120125: LD_INT 20
120127: ST_TO_ADDR
// hc_class := class_tiger ;
120128: LD_ADDR_OWVAR 28
120132: PUSH
120133: LD_INT 14
120135: ST_TO_ADDR
// hc_gallery :=  ;
120136: LD_ADDR_OWVAR 33
120140: PUSH
120141: LD_STRING 
120143: ST_TO_ADDR
// hc_name :=  ;
120144: LD_ADDR_OWVAR 26
120148: PUSH
120149: LD_STRING 
120151: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120152: CALL_OW 44
120156: PPUSH
120157: LD_INT 0
120159: PPUSH
120160: CALL_OW 51
// end ;
120164: GO 120086
120166: POP
120167: POP
// end ;
120168: PPOPN 1
120170: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120171: LD_EXP 148
120175: PUSH
120176: LD_EXP 168
120180: AND
120181: IFFALSE 120190
120183: GO 120185
120185: DISABLE
// StreamSibBomb ;
120186: CALL 120191 0 0
120190: END
// export function StreamSibBomb ; var i , x , y ; begin
120191: LD_INT 0
120193: PPUSH
120194: PPUSH
120195: PPUSH
120196: PPUSH
// result := false ;
120197: LD_ADDR_VAR 0 1
120201: PUSH
120202: LD_INT 0
120204: ST_TO_ADDR
// for i := 1 to 16 do
120205: LD_ADDR_VAR 0 2
120209: PUSH
120210: DOUBLE
120211: LD_INT 1
120213: DEC
120214: ST_TO_ADDR
120215: LD_INT 16
120217: PUSH
120218: FOR_TO
120219: IFFALSE 120418
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120221: LD_ADDR_VAR 0 3
120225: PUSH
120226: LD_INT 10
120228: PUSH
120229: LD_INT 20
120231: PUSH
120232: LD_INT 30
120234: PUSH
120235: LD_INT 40
120237: PUSH
120238: LD_INT 50
120240: PUSH
120241: LD_INT 60
120243: PUSH
120244: LD_INT 70
120246: PUSH
120247: LD_INT 80
120249: PUSH
120250: LD_INT 90
120252: PUSH
120253: LD_INT 100
120255: PUSH
120256: LD_INT 110
120258: PUSH
120259: LD_INT 120
120261: PUSH
120262: LD_INT 130
120264: PUSH
120265: LD_INT 140
120267: PUSH
120268: LD_INT 150
120270: PUSH
120271: EMPTY
120272: LIST
120273: LIST
120274: LIST
120275: LIST
120276: LIST
120277: LIST
120278: LIST
120279: LIST
120280: LIST
120281: LIST
120282: LIST
120283: LIST
120284: LIST
120285: LIST
120286: LIST
120287: PUSH
120288: LD_INT 1
120290: PPUSH
120291: LD_INT 15
120293: PPUSH
120294: CALL_OW 12
120298: ARRAY
120299: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120300: LD_ADDR_VAR 0 4
120304: PUSH
120305: LD_INT 10
120307: PUSH
120308: LD_INT 20
120310: PUSH
120311: LD_INT 30
120313: PUSH
120314: LD_INT 40
120316: PUSH
120317: LD_INT 50
120319: PUSH
120320: LD_INT 60
120322: PUSH
120323: LD_INT 70
120325: PUSH
120326: LD_INT 80
120328: PUSH
120329: LD_INT 90
120331: PUSH
120332: LD_INT 100
120334: PUSH
120335: LD_INT 110
120337: PUSH
120338: LD_INT 120
120340: PUSH
120341: LD_INT 130
120343: PUSH
120344: LD_INT 140
120346: PUSH
120347: LD_INT 150
120349: PUSH
120350: EMPTY
120351: LIST
120352: LIST
120353: LIST
120354: LIST
120355: LIST
120356: LIST
120357: LIST
120358: LIST
120359: LIST
120360: LIST
120361: LIST
120362: LIST
120363: LIST
120364: LIST
120365: LIST
120366: PUSH
120367: LD_INT 1
120369: PPUSH
120370: LD_INT 15
120372: PPUSH
120373: CALL_OW 12
120377: ARRAY
120378: ST_TO_ADDR
// if ValidHex ( x , y ) then
120379: LD_VAR 0 3
120383: PPUSH
120384: LD_VAR 0 4
120388: PPUSH
120389: CALL_OW 488
120393: IFFALSE 120416
// begin result := [ x , y ] ;
120395: LD_ADDR_VAR 0 1
120399: PUSH
120400: LD_VAR 0 3
120404: PUSH
120405: LD_VAR 0 4
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: ST_TO_ADDR
// break ;
120414: GO 120418
// end ; end ;
120416: GO 120218
120418: POP
120419: POP
// if result then
120420: LD_VAR 0 1
120424: IFFALSE 120484
// begin ToLua ( playSibBomb() ) ;
120426: LD_STRING playSibBomb()
120428: PPUSH
120429: CALL_OW 559
// wait ( 0 0$14 ) ;
120433: LD_INT 490
120435: PPUSH
120436: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
120440: LD_VAR 0 1
120444: PUSH
120445: LD_INT 1
120447: ARRAY
120448: PPUSH
120449: LD_VAR 0 1
120453: PUSH
120454: LD_INT 2
120456: ARRAY
120457: PPUSH
120458: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
120462: LD_VAR 0 1
120466: PUSH
120467: LD_INT 1
120469: ARRAY
120470: PPUSH
120471: LD_VAR 0 1
120475: PUSH
120476: LD_INT 2
120478: ARRAY
120479: PPUSH
120480: CALL_OW 429
// end ; end ;
120484: LD_VAR 0 1
120488: RET
// every 0 0$1 trigger StreamModeActive and sReset do
120489: LD_EXP 148
120493: PUSH
120494: LD_EXP 170
120498: AND
120499: IFFALSE 120511
120501: GO 120503
120503: DISABLE
// YouLost (  ) ;
120504: LD_STRING 
120506: PPUSH
120507: CALL_OW 104
120511: END
// every 0 0$1 trigger StreamModeActive and sFog do
120512: LD_EXP 148
120516: PUSH
120517: LD_EXP 169
120521: AND
120522: IFFALSE 120536
120524: GO 120526
120526: DISABLE
// FogOff ( your_side ) ;
120527: LD_OWVAR 2
120531: PPUSH
120532: CALL_OW 344
120536: END
// every 0 0$1 trigger StreamModeActive and sSun do
120537: LD_EXP 148
120541: PUSH
120542: LD_EXP 171
120546: AND
120547: IFFALSE 120575
120549: GO 120551
120551: DISABLE
// begin solar_recharge_percent := 0 ;
120552: LD_ADDR_OWVAR 79
120556: PUSH
120557: LD_INT 0
120559: ST_TO_ADDR
// wait ( 5 5$00 ) ;
120560: LD_INT 10500
120562: PPUSH
120563: CALL_OW 67
// solar_recharge_percent := 100 ;
120567: LD_ADDR_OWVAR 79
120571: PUSH
120572: LD_INT 100
120574: ST_TO_ADDR
// end ;
120575: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
120576: LD_EXP 148
120580: PUSH
120581: LD_EXP 172
120585: AND
120586: IFFALSE 120825
120588: GO 120590
120590: DISABLE
120591: LD_INT 0
120593: PPUSH
120594: PPUSH
120595: PPUSH
// begin tmp := [ ] ;
120596: LD_ADDR_VAR 0 3
120600: PUSH
120601: EMPTY
120602: ST_TO_ADDR
// for i := 1 to 6 do
120603: LD_ADDR_VAR 0 1
120607: PUSH
120608: DOUBLE
120609: LD_INT 1
120611: DEC
120612: ST_TO_ADDR
120613: LD_INT 6
120615: PUSH
120616: FOR_TO
120617: IFFALSE 120722
// begin uc_nation := nation_nature ;
120619: LD_ADDR_OWVAR 21
120623: PUSH
120624: LD_INT 0
120626: ST_TO_ADDR
// uc_side := 0 ;
120627: LD_ADDR_OWVAR 20
120631: PUSH
120632: LD_INT 0
120634: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120635: LD_ADDR_OWVAR 29
120639: PUSH
120640: LD_INT 12
120642: PUSH
120643: LD_INT 12
120645: PUSH
120646: EMPTY
120647: LIST
120648: LIST
120649: ST_TO_ADDR
// hc_agressivity := 20 ;
120650: LD_ADDR_OWVAR 35
120654: PUSH
120655: LD_INT 20
120657: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
120658: LD_ADDR_OWVAR 28
120662: PUSH
120663: LD_INT 17
120665: ST_TO_ADDR
// hc_gallery :=  ;
120666: LD_ADDR_OWVAR 33
120670: PUSH
120671: LD_STRING 
120673: ST_TO_ADDR
// hc_name :=  ;
120674: LD_ADDR_OWVAR 26
120678: PUSH
120679: LD_STRING 
120681: ST_TO_ADDR
// un := CreateHuman ;
120682: LD_ADDR_VAR 0 2
120686: PUSH
120687: CALL_OW 44
120691: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
120692: LD_VAR 0 2
120696: PPUSH
120697: LD_INT 1
120699: PPUSH
120700: CALL_OW 51
// tmp := tmp ^ un ;
120704: LD_ADDR_VAR 0 3
120708: PUSH
120709: LD_VAR 0 3
120713: PUSH
120714: LD_VAR 0 2
120718: ADD
120719: ST_TO_ADDR
// end ;
120720: GO 120616
120722: POP
120723: POP
// repeat wait ( 0 0$1 ) ;
120724: LD_INT 35
120726: PPUSH
120727: CALL_OW 67
// for un in tmp do
120731: LD_ADDR_VAR 0 2
120735: PUSH
120736: LD_VAR 0 3
120740: PUSH
120741: FOR_IN
120742: IFFALSE 120816
// begin if IsDead ( un ) then
120744: LD_VAR 0 2
120748: PPUSH
120749: CALL_OW 301
120753: IFFALSE 120773
// begin tmp := tmp diff un ;
120755: LD_ADDR_VAR 0 3
120759: PUSH
120760: LD_VAR 0 3
120764: PUSH
120765: LD_VAR 0 2
120769: DIFF
120770: ST_TO_ADDR
// continue ;
120771: GO 120741
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120773: LD_VAR 0 2
120777: PPUSH
120778: LD_INT 3
120780: PUSH
120781: LD_INT 22
120783: PUSH
120784: LD_INT 0
120786: PUSH
120787: EMPTY
120788: LIST
120789: LIST
120790: PUSH
120791: EMPTY
120792: LIST
120793: LIST
120794: PPUSH
120795: CALL_OW 69
120799: PPUSH
120800: LD_VAR 0 2
120804: PPUSH
120805: CALL_OW 74
120809: PPUSH
120810: CALL_OW 115
// end ;
120814: GO 120741
120816: POP
120817: POP
// until not tmp ;
120818: LD_VAR 0 3
120822: NOT
120823: IFFALSE 120724
// end ;
120825: PPOPN 3
120827: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120828: LD_EXP 148
120832: PUSH
120833: LD_EXP 173
120837: AND
120838: IFFALSE 120892
120840: GO 120842
120842: DISABLE
// begin ToLua ( displayTroll(); ) ;
120843: LD_STRING displayTroll();
120845: PPUSH
120846: CALL_OW 559
// wait ( 3 3$00 ) ;
120850: LD_INT 6300
120852: PPUSH
120853: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120857: LD_STRING hideTroll();
120859: PPUSH
120860: CALL_OW 559
// wait ( 1 1$00 ) ;
120864: LD_INT 2100
120866: PPUSH
120867: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120871: LD_STRING displayTroll();
120873: PPUSH
120874: CALL_OW 559
// wait ( 1 1$00 ) ;
120878: LD_INT 2100
120880: PPUSH
120881: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120885: LD_STRING hideTroll();
120887: PPUSH
120888: CALL_OW 559
// end ;
120892: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
120893: LD_EXP 148
120897: PUSH
120898: LD_EXP 174
120902: AND
120903: IFFALSE 120966
120905: GO 120907
120907: DISABLE
120908: LD_INT 0
120910: PPUSH
// begin p := 0 ;
120911: LD_ADDR_VAR 0 1
120915: PUSH
120916: LD_INT 0
120918: ST_TO_ADDR
// repeat game_speed := 1 ;
120919: LD_ADDR_OWVAR 65
120923: PUSH
120924: LD_INT 1
120926: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120927: LD_INT 35
120929: PPUSH
120930: CALL_OW 67
// p := p + 1 ;
120934: LD_ADDR_VAR 0 1
120938: PUSH
120939: LD_VAR 0 1
120943: PUSH
120944: LD_INT 1
120946: PLUS
120947: ST_TO_ADDR
// until p >= 60 ;
120948: LD_VAR 0 1
120952: PUSH
120953: LD_INT 60
120955: GREATEREQUAL
120956: IFFALSE 120919
// game_speed := 4 ;
120958: LD_ADDR_OWVAR 65
120962: PUSH
120963: LD_INT 4
120965: ST_TO_ADDR
// end ;
120966: PPOPN 1
120968: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
120969: LD_EXP 148
120973: PUSH
120974: LD_EXP 175
120978: AND
120979: IFFALSE 121125
120981: GO 120983
120983: DISABLE
120984: LD_INT 0
120986: PPUSH
120987: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120988: LD_ADDR_VAR 0 1
120992: PUSH
120993: LD_INT 22
120995: PUSH
120996: LD_OWVAR 2
121000: PUSH
121001: EMPTY
121002: LIST
121003: LIST
121004: PUSH
121005: LD_INT 2
121007: PUSH
121008: LD_INT 30
121010: PUSH
121011: LD_INT 0
121013: PUSH
121014: EMPTY
121015: LIST
121016: LIST
121017: PUSH
121018: LD_INT 30
121020: PUSH
121021: LD_INT 1
121023: PUSH
121024: EMPTY
121025: LIST
121026: LIST
121027: PUSH
121028: EMPTY
121029: LIST
121030: LIST
121031: LIST
121032: PUSH
121033: EMPTY
121034: LIST
121035: LIST
121036: PPUSH
121037: CALL_OW 69
121041: ST_TO_ADDR
// if not depot then
121042: LD_VAR 0 1
121046: NOT
121047: IFFALSE 121051
// exit ;
121049: GO 121125
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121051: LD_ADDR_VAR 0 2
121055: PUSH
121056: LD_VAR 0 1
121060: PUSH
121061: LD_INT 1
121063: PPUSH
121064: LD_VAR 0 1
121068: PPUSH
121069: CALL_OW 12
121073: ARRAY
121074: PPUSH
121075: CALL_OW 274
121079: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121080: LD_VAR 0 2
121084: PPUSH
121085: LD_INT 1
121087: PPUSH
121088: LD_INT 0
121090: PPUSH
121091: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121095: LD_VAR 0 2
121099: PPUSH
121100: LD_INT 2
121102: PPUSH
121103: LD_INT 0
121105: PPUSH
121106: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121110: LD_VAR 0 2
121114: PPUSH
121115: LD_INT 3
121117: PPUSH
121118: LD_INT 0
121120: PPUSH
121121: CALL_OW 277
// end ;
121125: PPOPN 2
121127: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121128: LD_EXP 148
121132: PUSH
121133: LD_EXP 176
121137: AND
121138: IFFALSE 121235
121140: GO 121142
121142: DISABLE
121143: LD_INT 0
121145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121146: LD_ADDR_VAR 0 1
121150: PUSH
121151: LD_INT 22
121153: PUSH
121154: LD_OWVAR 2
121158: PUSH
121159: EMPTY
121160: LIST
121161: LIST
121162: PUSH
121163: LD_INT 21
121165: PUSH
121166: LD_INT 1
121168: PUSH
121169: EMPTY
121170: LIST
121171: LIST
121172: PUSH
121173: LD_INT 3
121175: PUSH
121176: LD_INT 23
121178: PUSH
121179: LD_INT 0
121181: PUSH
121182: EMPTY
121183: LIST
121184: LIST
121185: PUSH
121186: EMPTY
121187: LIST
121188: LIST
121189: PUSH
121190: EMPTY
121191: LIST
121192: LIST
121193: LIST
121194: PPUSH
121195: CALL_OW 69
121199: ST_TO_ADDR
// if not tmp then
121200: LD_VAR 0 1
121204: NOT
121205: IFFALSE 121209
// exit ;
121207: GO 121235
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121209: LD_VAR 0 1
121213: PUSH
121214: LD_INT 1
121216: PPUSH
121217: LD_VAR 0 1
121221: PPUSH
121222: CALL_OW 12
121226: ARRAY
121227: PPUSH
121228: LD_INT 200
121230: PPUSH
121231: CALL_OW 234
// end ;
121235: PPOPN 1
121237: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121238: LD_EXP 148
121242: PUSH
121243: LD_EXP 177
121247: AND
121248: IFFALSE 121327
121250: GO 121252
121252: DISABLE
121253: LD_INT 0
121255: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121256: LD_ADDR_VAR 0 1
121260: PUSH
121261: LD_INT 22
121263: PUSH
121264: LD_OWVAR 2
121268: PUSH
121269: EMPTY
121270: LIST
121271: LIST
121272: PUSH
121273: LD_INT 21
121275: PUSH
121276: LD_INT 2
121278: PUSH
121279: EMPTY
121280: LIST
121281: LIST
121282: PUSH
121283: EMPTY
121284: LIST
121285: LIST
121286: PPUSH
121287: CALL_OW 69
121291: ST_TO_ADDR
// if not tmp then
121292: LD_VAR 0 1
121296: NOT
121297: IFFALSE 121301
// exit ;
121299: GO 121327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121301: LD_VAR 0 1
121305: PUSH
121306: LD_INT 1
121308: PPUSH
121309: LD_VAR 0 1
121313: PPUSH
121314: CALL_OW 12
121318: ARRAY
121319: PPUSH
121320: LD_INT 60
121322: PPUSH
121323: CALL_OW 234
// end ;
121327: PPOPN 1
121329: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
121330: LD_EXP 148
121334: PUSH
121335: LD_EXP 178
121339: AND
121340: IFFALSE 121439
121342: GO 121344
121344: DISABLE
121345: LD_INT 0
121347: PPUSH
121348: PPUSH
// begin enable ;
121349: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
121350: LD_ADDR_VAR 0 1
121354: PUSH
121355: LD_INT 22
121357: PUSH
121358: LD_OWVAR 2
121362: PUSH
121363: EMPTY
121364: LIST
121365: LIST
121366: PUSH
121367: LD_INT 61
121369: PUSH
121370: EMPTY
121371: LIST
121372: PUSH
121373: LD_INT 33
121375: PUSH
121376: LD_INT 2
121378: PUSH
121379: EMPTY
121380: LIST
121381: LIST
121382: PUSH
121383: EMPTY
121384: LIST
121385: LIST
121386: LIST
121387: PPUSH
121388: CALL_OW 69
121392: ST_TO_ADDR
// if not tmp then
121393: LD_VAR 0 1
121397: NOT
121398: IFFALSE 121402
// exit ;
121400: GO 121439
// for i in tmp do
121402: LD_ADDR_VAR 0 2
121406: PUSH
121407: LD_VAR 0 1
121411: PUSH
121412: FOR_IN
121413: IFFALSE 121437
// if IsControledBy ( i ) then
121415: LD_VAR 0 2
121419: PPUSH
121420: CALL_OW 312
121424: IFFALSE 121435
// ComUnlink ( i ) ;
121426: LD_VAR 0 2
121430: PPUSH
121431: CALL_OW 136
121435: GO 121412
121437: POP
121438: POP
// end ;
121439: PPOPN 2
121441: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
121442: LD_EXP 148
121446: PUSH
121447: LD_EXP 179
121451: AND
121452: IFFALSE 121592
121454: GO 121456
121456: DISABLE
121457: LD_INT 0
121459: PPUSH
121460: PPUSH
// begin ToLua ( displayPowell(); ) ;
121461: LD_STRING displayPowell();
121463: PPUSH
121464: CALL_OW 559
// uc_side := 0 ;
121468: LD_ADDR_OWVAR 20
121472: PUSH
121473: LD_INT 0
121475: ST_TO_ADDR
// uc_nation := 2 ;
121476: LD_ADDR_OWVAR 21
121480: PUSH
121481: LD_INT 2
121483: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
121484: LD_ADDR_OWVAR 37
121488: PUSH
121489: LD_INT 14
121491: ST_TO_ADDR
// vc_engine := engine_siberite ;
121492: LD_ADDR_OWVAR 39
121496: PUSH
121497: LD_INT 3
121499: ST_TO_ADDR
// vc_control := control_apeman ;
121500: LD_ADDR_OWVAR 38
121504: PUSH
121505: LD_INT 5
121507: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
121508: LD_ADDR_OWVAR 40
121512: PUSH
121513: LD_INT 29
121515: ST_TO_ADDR
// un := CreateVehicle ;
121516: LD_ADDR_VAR 0 2
121520: PUSH
121521: CALL_OW 45
121525: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121526: LD_VAR 0 2
121530: PPUSH
121531: LD_INT 1
121533: PPUSH
121534: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121538: LD_INT 35
121540: PPUSH
121541: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121545: LD_VAR 0 2
121549: PPUSH
121550: LD_INT 22
121552: PUSH
121553: LD_OWVAR 2
121557: PUSH
121558: EMPTY
121559: LIST
121560: LIST
121561: PPUSH
121562: CALL_OW 69
121566: PPUSH
121567: LD_VAR 0 2
121571: PPUSH
121572: CALL_OW 74
121576: PPUSH
121577: CALL_OW 115
// until IsDead ( un ) ;
121581: LD_VAR 0 2
121585: PPUSH
121586: CALL_OW 301
121590: IFFALSE 121538
// end ;
121592: PPOPN 2
121594: END
// every 0 0$1 trigger StreamModeActive and sStu do
121595: LD_EXP 148
121599: PUSH
121600: LD_EXP 187
121604: AND
121605: IFFALSE 121621
121607: GO 121609
121609: DISABLE
// begin ToLua ( displayStucuk(); ) ;
121610: LD_STRING displayStucuk();
121612: PPUSH
121613: CALL_OW 559
// ResetFog ;
121617: CALL_OW 335
// end ;
121621: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
121622: LD_EXP 148
121626: PUSH
121627: LD_EXP 180
121631: AND
121632: IFFALSE 121773
121634: GO 121636
121636: DISABLE
121637: LD_INT 0
121639: PPUSH
121640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121641: LD_ADDR_VAR 0 2
121645: PUSH
121646: LD_INT 22
121648: PUSH
121649: LD_OWVAR 2
121653: PUSH
121654: EMPTY
121655: LIST
121656: LIST
121657: PUSH
121658: LD_INT 21
121660: PUSH
121661: LD_INT 1
121663: PUSH
121664: EMPTY
121665: LIST
121666: LIST
121667: PUSH
121668: EMPTY
121669: LIST
121670: LIST
121671: PPUSH
121672: CALL_OW 69
121676: ST_TO_ADDR
// if not tmp then
121677: LD_VAR 0 2
121681: NOT
121682: IFFALSE 121686
// exit ;
121684: GO 121773
// un := tmp [ rand ( 1 , tmp ) ] ;
121686: LD_ADDR_VAR 0 1
121690: PUSH
121691: LD_VAR 0 2
121695: PUSH
121696: LD_INT 1
121698: PPUSH
121699: LD_VAR 0 2
121703: PPUSH
121704: CALL_OW 12
121708: ARRAY
121709: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121710: LD_VAR 0 1
121714: PPUSH
121715: LD_INT 0
121717: PPUSH
121718: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121722: LD_VAR 0 1
121726: PPUSH
121727: LD_OWVAR 3
121731: PUSH
121732: LD_VAR 0 1
121736: DIFF
121737: PPUSH
121738: LD_VAR 0 1
121742: PPUSH
121743: CALL_OW 74
121747: PPUSH
121748: CALL_OW 115
// wait ( 0 0$20 ) ;
121752: LD_INT 700
121754: PPUSH
121755: CALL_OW 67
// SetSide ( un , your_side ) ;
121759: LD_VAR 0 1
121763: PPUSH
121764: LD_OWVAR 2
121768: PPUSH
121769: CALL_OW 235
// end ;
121773: PPOPN 2
121775: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121776: LD_EXP 148
121780: PUSH
121781: LD_EXP 181
121785: AND
121786: IFFALSE 121892
121788: GO 121790
121790: DISABLE
121791: LD_INT 0
121793: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121794: LD_ADDR_VAR 0 1
121798: PUSH
121799: LD_INT 22
121801: PUSH
121802: LD_OWVAR 2
121806: PUSH
121807: EMPTY
121808: LIST
121809: LIST
121810: PUSH
121811: LD_INT 2
121813: PUSH
121814: LD_INT 30
121816: PUSH
121817: LD_INT 0
121819: PUSH
121820: EMPTY
121821: LIST
121822: LIST
121823: PUSH
121824: LD_INT 30
121826: PUSH
121827: LD_INT 1
121829: PUSH
121830: EMPTY
121831: LIST
121832: LIST
121833: PUSH
121834: EMPTY
121835: LIST
121836: LIST
121837: LIST
121838: PUSH
121839: EMPTY
121840: LIST
121841: LIST
121842: PPUSH
121843: CALL_OW 69
121847: ST_TO_ADDR
// if not depot then
121848: LD_VAR 0 1
121852: NOT
121853: IFFALSE 121857
// exit ;
121855: GO 121892
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121857: LD_VAR 0 1
121861: PUSH
121862: LD_INT 1
121864: ARRAY
121865: PPUSH
121866: CALL_OW 250
121870: PPUSH
121871: LD_VAR 0 1
121875: PUSH
121876: LD_INT 1
121878: ARRAY
121879: PPUSH
121880: CALL_OW 251
121884: PPUSH
121885: LD_INT 70
121887: PPUSH
121888: CALL_OW 495
// end ;
121892: PPOPN 1
121894: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
121895: LD_EXP 148
121899: PUSH
121900: LD_EXP 182
121904: AND
121905: IFFALSE 122116
121907: GO 121909
121909: DISABLE
121910: LD_INT 0
121912: PPUSH
121913: PPUSH
121914: PPUSH
121915: PPUSH
121916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121917: LD_ADDR_VAR 0 5
121921: PUSH
121922: LD_INT 22
121924: PUSH
121925: LD_OWVAR 2
121929: PUSH
121930: EMPTY
121931: LIST
121932: LIST
121933: PUSH
121934: LD_INT 21
121936: PUSH
121937: LD_INT 1
121939: PUSH
121940: EMPTY
121941: LIST
121942: LIST
121943: PUSH
121944: EMPTY
121945: LIST
121946: LIST
121947: PPUSH
121948: CALL_OW 69
121952: ST_TO_ADDR
// if not tmp then
121953: LD_VAR 0 5
121957: NOT
121958: IFFALSE 121962
// exit ;
121960: GO 122116
// for i in tmp do
121962: LD_ADDR_VAR 0 1
121966: PUSH
121967: LD_VAR 0 5
121971: PUSH
121972: FOR_IN
121973: IFFALSE 122114
// begin d := rand ( 0 , 5 ) ;
121975: LD_ADDR_VAR 0 4
121979: PUSH
121980: LD_INT 0
121982: PPUSH
121983: LD_INT 5
121985: PPUSH
121986: CALL_OW 12
121990: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
121991: LD_ADDR_VAR 0 2
121995: PUSH
121996: LD_VAR 0 1
122000: PPUSH
122001: CALL_OW 250
122005: PPUSH
122006: LD_VAR 0 4
122010: PPUSH
122011: LD_INT 3
122013: PPUSH
122014: LD_INT 12
122016: PPUSH
122017: CALL_OW 12
122021: PPUSH
122022: CALL_OW 272
122026: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122027: LD_ADDR_VAR 0 3
122031: PUSH
122032: LD_VAR 0 1
122036: PPUSH
122037: CALL_OW 251
122041: PPUSH
122042: LD_VAR 0 4
122046: PPUSH
122047: LD_INT 3
122049: PPUSH
122050: LD_INT 12
122052: PPUSH
122053: CALL_OW 12
122057: PPUSH
122058: CALL_OW 273
122062: ST_TO_ADDR
// if ValidHex ( x , y ) then
122063: LD_VAR 0 2
122067: PPUSH
122068: LD_VAR 0 3
122072: PPUSH
122073: CALL_OW 488
122077: IFFALSE 122112
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122079: LD_VAR 0 1
122083: PPUSH
122084: LD_VAR 0 2
122088: PPUSH
122089: LD_VAR 0 3
122093: PPUSH
122094: LD_INT 3
122096: PPUSH
122097: LD_INT 6
122099: PPUSH
122100: CALL_OW 12
122104: PPUSH
122105: LD_INT 1
122107: PPUSH
122108: CALL_OW 483
// end ;
122112: GO 121972
122114: POP
122115: POP
// end ;
122116: PPOPN 5
122118: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122119: LD_EXP 148
122123: PUSH
122124: LD_EXP 183
122128: AND
122129: IFFALSE 122223
122131: GO 122133
122133: DISABLE
122134: LD_INT 0
122136: PPUSH
122137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122138: LD_ADDR_VAR 0 2
122142: PUSH
122143: LD_INT 22
122145: PUSH
122146: LD_OWVAR 2
122150: PUSH
122151: EMPTY
122152: LIST
122153: LIST
122154: PUSH
122155: LD_INT 32
122157: PUSH
122158: LD_INT 1
122160: PUSH
122161: EMPTY
122162: LIST
122163: LIST
122164: PUSH
122165: LD_INT 21
122167: PUSH
122168: LD_INT 2
122170: PUSH
122171: EMPTY
122172: LIST
122173: LIST
122174: PUSH
122175: EMPTY
122176: LIST
122177: LIST
122178: LIST
122179: PPUSH
122180: CALL_OW 69
122184: ST_TO_ADDR
// if not tmp then
122185: LD_VAR 0 2
122189: NOT
122190: IFFALSE 122194
// exit ;
122192: GO 122223
// for i in tmp do
122194: LD_ADDR_VAR 0 1
122198: PUSH
122199: LD_VAR 0 2
122203: PUSH
122204: FOR_IN
122205: IFFALSE 122221
// SetFuel ( i , 0 ) ;
122207: LD_VAR 0 1
122211: PPUSH
122212: LD_INT 0
122214: PPUSH
122215: CALL_OW 240
122219: GO 122204
122221: POP
122222: POP
// end ;
122223: PPOPN 2
122225: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122226: LD_EXP 148
122230: PUSH
122231: LD_EXP 184
122235: AND
122236: IFFALSE 122302
122238: GO 122240
122240: DISABLE
122241: LD_INT 0
122243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122244: LD_ADDR_VAR 0 1
122248: PUSH
122249: LD_INT 22
122251: PUSH
122252: LD_OWVAR 2
122256: PUSH
122257: EMPTY
122258: LIST
122259: LIST
122260: PUSH
122261: LD_INT 30
122263: PUSH
122264: LD_INT 29
122266: PUSH
122267: EMPTY
122268: LIST
122269: LIST
122270: PUSH
122271: EMPTY
122272: LIST
122273: LIST
122274: PPUSH
122275: CALL_OW 69
122279: ST_TO_ADDR
// if not tmp then
122280: LD_VAR 0 1
122284: NOT
122285: IFFALSE 122289
// exit ;
122287: GO 122302
// DestroyUnit ( tmp [ 1 ] ) ;
122289: LD_VAR 0 1
122293: PUSH
122294: LD_INT 1
122296: ARRAY
122297: PPUSH
122298: CALL_OW 65
// end ;
122302: PPOPN 1
122304: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
122305: LD_EXP 148
122309: PUSH
122310: LD_EXP 186
122314: AND
122315: IFFALSE 122444
122317: GO 122319
122319: DISABLE
122320: LD_INT 0
122322: PPUSH
// begin uc_side := 0 ;
122323: LD_ADDR_OWVAR 20
122327: PUSH
122328: LD_INT 0
122330: ST_TO_ADDR
// uc_nation := nation_arabian ;
122331: LD_ADDR_OWVAR 21
122335: PUSH
122336: LD_INT 2
122338: ST_TO_ADDR
// hc_gallery :=  ;
122339: LD_ADDR_OWVAR 33
122343: PUSH
122344: LD_STRING 
122346: ST_TO_ADDR
// hc_name :=  ;
122347: LD_ADDR_OWVAR 26
122351: PUSH
122352: LD_STRING 
122354: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
122355: LD_INT 1
122357: PPUSH
122358: LD_INT 11
122360: PPUSH
122361: LD_INT 10
122363: PPUSH
122364: CALL_OW 380
// un := CreateHuman ;
122368: LD_ADDR_VAR 0 1
122372: PUSH
122373: CALL_OW 44
122377: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122378: LD_VAR 0 1
122382: PPUSH
122383: LD_INT 1
122385: PPUSH
122386: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122390: LD_INT 35
122392: PPUSH
122393: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122397: LD_VAR 0 1
122401: PPUSH
122402: LD_INT 22
122404: PUSH
122405: LD_OWVAR 2
122409: PUSH
122410: EMPTY
122411: LIST
122412: LIST
122413: PPUSH
122414: CALL_OW 69
122418: PPUSH
122419: LD_VAR 0 1
122423: PPUSH
122424: CALL_OW 74
122428: PPUSH
122429: CALL_OW 115
// until IsDead ( un ) ;
122433: LD_VAR 0 1
122437: PPUSH
122438: CALL_OW 301
122442: IFFALSE 122390
// end ;
122444: PPOPN 1
122446: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
122447: LD_EXP 148
122451: PUSH
122452: LD_EXP 188
122456: AND
122457: IFFALSE 122469
122459: GO 122461
122461: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
122462: LD_STRING earthquake(getX(game), 0, 32)
122464: PPUSH
122465: CALL_OW 559
122469: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
122470: LD_EXP 148
122474: PUSH
122475: LD_EXP 189
122479: AND
122480: IFFALSE 122571
122482: GO 122484
122484: DISABLE
122485: LD_INT 0
122487: PPUSH
// begin enable ;
122488: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
122489: LD_ADDR_VAR 0 1
122493: PUSH
122494: LD_INT 22
122496: PUSH
122497: LD_OWVAR 2
122501: PUSH
122502: EMPTY
122503: LIST
122504: LIST
122505: PUSH
122506: LD_INT 21
122508: PUSH
122509: LD_INT 2
122511: PUSH
122512: EMPTY
122513: LIST
122514: LIST
122515: PUSH
122516: LD_INT 33
122518: PUSH
122519: LD_INT 3
122521: PUSH
122522: EMPTY
122523: LIST
122524: LIST
122525: PUSH
122526: EMPTY
122527: LIST
122528: LIST
122529: LIST
122530: PPUSH
122531: CALL_OW 69
122535: ST_TO_ADDR
// if not tmp then
122536: LD_VAR 0 1
122540: NOT
122541: IFFALSE 122545
// exit ;
122543: GO 122571
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122545: LD_VAR 0 1
122549: PUSH
122550: LD_INT 1
122552: PPUSH
122553: LD_VAR 0 1
122557: PPUSH
122558: CALL_OW 12
122562: ARRAY
122563: PPUSH
122564: LD_INT 1
122566: PPUSH
122567: CALL_OW 234
// end ;
122571: PPOPN 1
122573: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
122574: LD_EXP 148
122578: PUSH
122579: LD_EXP 190
122583: AND
122584: IFFALSE 122725
122586: GO 122588
122588: DISABLE
122589: LD_INT 0
122591: PPUSH
122592: PPUSH
122593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122594: LD_ADDR_VAR 0 3
122598: PUSH
122599: LD_INT 22
122601: PUSH
122602: LD_OWVAR 2
122606: PUSH
122607: EMPTY
122608: LIST
122609: LIST
122610: PUSH
122611: LD_INT 25
122613: PUSH
122614: LD_INT 1
122616: PUSH
122617: EMPTY
122618: LIST
122619: LIST
122620: PUSH
122621: EMPTY
122622: LIST
122623: LIST
122624: PPUSH
122625: CALL_OW 69
122629: ST_TO_ADDR
// if not tmp then
122630: LD_VAR 0 3
122634: NOT
122635: IFFALSE 122639
// exit ;
122637: GO 122725
// un := tmp [ rand ( 1 , tmp ) ] ;
122639: LD_ADDR_VAR 0 2
122643: PUSH
122644: LD_VAR 0 3
122648: PUSH
122649: LD_INT 1
122651: PPUSH
122652: LD_VAR 0 3
122656: PPUSH
122657: CALL_OW 12
122661: ARRAY
122662: ST_TO_ADDR
// if Crawls ( un ) then
122663: LD_VAR 0 2
122667: PPUSH
122668: CALL_OW 318
122672: IFFALSE 122683
// ComWalk ( un ) ;
122674: LD_VAR 0 2
122678: PPUSH
122679: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
122683: LD_VAR 0 2
122687: PPUSH
122688: LD_INT 9
122690: PPUSH
122691: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
122695: LD_INT 28
122697: PPUSH
122698: LD_OWVAR 2
122702: PPUSH
122703: LD_INT 2
122705: PPUSH
122706: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122710: LD_INT 29
122712: PPUSH
122713: LD_OWVAR 2
122717: PPUSH
122718: LD_INT 2
122720: PPUSH
122721: CALL_OW 322
// end ;
122725: PPOPN 3
122727: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122728: LD_EXP 148
122732: PUSH
122733: LD_EXP 191
122737: AND
122738: IFFALSE 122849
122740: GO 122742
122742: DISABLE
122743: LD_INT 0
122745: PPUSH
122746: PPUSH
122747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122748: LD_ADDR_VAR 0 3
122752: PUSH
122753: LD_INT 22
122755: PUSH
122756: LD_OWVAR 2
122760: PUSH
122761: EMPTY
122762: LIST
122763: LIST
122764: PUSH
122765: LD_INT 25
122767: PUSH
122768: LD_INT 1
122770: PUSH
122771: EMPTY
122772: LIST
122773: LIST
122774: PUSH
122775: EMPTY
122776: LIST
122777: LIST
122778: PPUSH
122779: CALL_OW 69
122783: ST_TO_ADDR
// if not tmp then
122784: LD_VAR 0 3
122788: NOT
122789: IFFALSE 122793
// exit ;
122791: GO 122849
// un := tmp [ rand ( 1 , tmp ) ] ;
122793: LD_ADDR_VAR 0 2
122797: PUSH
122798: LD_VAR 0 3
122802: PUSH
122803: LD_INT 1
122805: PPUSH
122806: LD_VAR 0 3
122810: PPUSH
122811: CALL_OW 12
122815: ARRAY
122816: ST_TO_ADDR
// if Crawls ( un ) then
122817: LD_VAR 0 2
122821: PPUSH
122822: CALL_OW 318
122826: IFFALSE 122837
// ComWalk ( un ) ;
122828: LD_VAR 0 2
122832: PPUSH
122833: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122837: LD_VAR 0 2
122841: PPUSH
122842: LD_INT 8
122844: PPUSH
122845: CALL_OW 336
// end ;
122849: PPOPN 3
122851: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122852: LD_EXP 148
122856: PUSH
122857: LD_EXP 192
122861: AND
122862: IFFALSE 123006
122864: GO 122866
122866: DISABLE
122867: LD_INT 0
122869: PPUSH
122870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122871: LD_ADDR_VAR 0 2
122875: PUSH
122876: LD_INT 22
122878: PUSH
122879: LD_OWVAR 2
122883: PUSH
122884: EMPTY
122885: LIST
122886: LIST
122887: PUSH
122888: LD_INT 21
122890: PUSH
122891: LD_INT 2
122893: PUSH
122894: EMPTY
122895: LIST
122896: LIST
122897: PUSH
122898: LD_INT 2
122900: PUSH
122901: LD_INT 34
122903: PUSH
122904: LD_INT 12
122906: PUSH
122907: EMPTY
122908: LIST
122909: LIST
122910: PUSH
122911: LD_INT 34
122913: PUSH
122914: LD_INT 51
122916: PUSH
122917: EMPTY
122918: LIST
122919: LIST
122920: PUSH
122921: LD_INT 34
122923: PUSH
122924: LD_INT 32
122926: PUSH
122927: EMPTY
122928: LIST
122929: LIST
122930: PUSH
122931: EMPTY
122932: LIST
122933: LIST
122934: LIST
122935: LIST
122936: PUSH
122937: EMPTY
122938: LIST
122939: LIST
122940: LIST
122941: PPUSH
122942: CALL_OW 69
122946: ST_TO_ADDR
// if not tmp then
122947: LD_VAR 0 2
122951: NOT
122952: IFFALSE 122956
// exit ;
122954: GO 123006
// for i in tmp do
122956: LD_ADDR_VAR 0 1
122960: PUSH
122961: LD_VAR 0 2
122965: PUSH
122966: FOR_IN
122967: IFFALSE 123004
// if GetCargo ( i , mat_artifact ) = 0 then
122969: LD_VAR 0 1
122973: PPUSH
122974: LD_INT 4
122976: PPUSH
122977: CALL_OW 289
122981: PUSH
122982: LD_INT 0
122984: EQUAL
122985: IFFALSE 123002
// SetCargo ( i , mat_siberit , 100 ) ;
122987: LD_VAR 0 1
122991: PPUSH
122992: LD_INT 3
122994: PPUSH
122995: LD_INT 100
122997: PPUSH
122998: CALL_OW 290
123002: GO 122966
123004: POP
123005: POP
// end ;
123006: PPOPN 2
123008: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123009: LD_EXP 148
123013: PUSH
123014: LD_EXP 193
123018: AND
123019: IFFALSE 123202
123021: GO 123023
123023: DISABLE
123024: LD_INT 0
123026: PPUSH
123027: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123028: LD_ADDR_VAR 0 2
123032: PUSH
123033: LD_INT 22
123035: PUSH
123036: LD_OWVAR 2
123040: PUSH
123041: EMPTY
123042: LIST
123043: LIST
123044: PPUSH
123045: CALL_OW 69
123049: ST_TO_ADDR
// if not tmp then
123050: LD_VAR 0 2
123054: NOT
123055: IFFALSE 123059
// exit ;
123057: GO 123202
// for i := 1 to 2 do
123059: LD_ADDR_VAR 0 1
123063: PUSH
123064: DOUBLE
123065: LD_INT 1
123067: DEC
123068: ST_TO_ADDR
123069: LD_INT 2
123071: PUSH
123072: FOR_TO
123073: IFFALSE 123200
// begin uc_side := your_side ;
123075: LD_ADDR_OWVAR 20
123079: PUSH
123080: LD_OWVAR 2
123084: ST_TO_ADDR
// uc_nation := nation_american ;
123085: LD_ADDR_OWVAR 21
123089: PUSH
123090: LD_INT 1
123092: ST_TO_ADDR
// vc_chassis := us_morphling ;
123093: LD_ADDR_OWVAR 37
123097: PUSH
123098: LD_INT 5
123100: ST_TO_ADDR
// vc_engine := engine_siberite ;
123101: LD_ADDR_OWVAR 39
123105: PUSH
123106: LD_INT 3
123108: ST_TO_ADDR
// vc_control := control_computer ;
123109: LD_ADDR_OWVAR 38
123113: PUSH
123114: LD_INT 3
123116: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123117: LD_ADDR_OWVAR 40
123121: PUSH
123122: LD_INT 10
123124: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123125: LD_VAR 0 2
123129: PUSH
123130: LD_INT 1
123132: ARRAY
123133: PPUSH
123134: CALL_OW 310
123138: NOT
123139: IFFALSE 123186
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123141: CALL_OW 45
123145: PPUSH
123146: LD_VAR 0 2
123150: PUSH
123151: LD_INT 1
123153: ARRAY
123154: PPUSH
123155: CALL_OW 250
123159: PPUSH
123160: LD_VAR 0 2
123164: PUSH
123165: LD_INT 1
123167: ARRAY
123168: PPUSH
123169: CALL_OW 251
123173: PPUSH
123174: LD_INT 12
123176: PPUSH
123177: LD_INT 1
123179: PPUSH
123180: CALL_OW 50
123184: GO 123198
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123186: CALL_OW 45
123190: PPUSH
123191: LD_INT 1
123193: PPUSH
123194: CALL_OW 51
// end ;
123198: GO 123072
123200: POP
123201: POP
// end ;
123202: PPOPN 2
123204: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123205: LD_EXP 148
123209: PUSH
123210: LD_EXP 194
123214: AND
123215: IFFALSE 123437
123217: GO 123219
123219: DISABLE
123220: LD_INT 0
123222: PPUSH
123223: PPUSH
123224: PPUSH
123225: PPUSH
123226: PPUSH
123227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123228: LD_ADDR_VAR 0 6
123232: PUSH
123233: LD_INT 22
123235: PUSH
123236: LD_OWVAR 2
123240: PUSH
123241: EMPTY
123242: LIST
123243: LIST
123244: PUSH
123245: LD_INT 21
123247: PUSH
123248: LD_INT 1
123250: PUSH
123251: EMPTY
123252: LIST
123253: LIST
123254: PUSH
123255: LD_INT 3
123257: PUSH
123258: LD_INT 23
123260: PUSH
123261: LD_INT 0
123263: PUSH
123264: EMPTY
123265: LIST
123266: LIST
123267: PUSH
123268: EMPTY
123269: LIST
123270: LIST
123271: PUSH
123272: EMPTY
123273: LIST
123274: LIST
123275: LIST
123276: PPUSH
123277: CALL_OW 69
123281: ST_TO_ADDR
// if not tmp then
123282: LD_VAR 0 6
123286: NOT
123287: IFFALSE 123291
// exit ;
123289: GO 123437
// s1 := rand ( 1 , 4 ) ;
123291: LD_ADDR_VAR 0 2
123295: PUSH
123296: LD_INT 1
123298: PPUSH
123299: LD_INT 4
123301: PPUSH
123302: CALL_OW 12
123306: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
123307: LD_ADDR_VAR 0 4
123311: PUSH
123312: LD_VAR 0 6
123316: PUSH
123317: LD_INT 1
123319: ARRAY
123320: PPUSH
123321: LD_VAR 0 2
123325: PPUSH
123326: CALL_OW 259
123330: ST_TO_ADDR
// if s1 = 1 then
123331: LD_VAR 0 2
123335: PUSH
123336: LD_INT 1
123338: EQUAL
123339: IFFALSE 123359
// s2 := rand ( 2 , 4 ) else
123341: LD_ADDR_VAR 0 3
123345: PUSH
123346: LD_INT 2
123348: PPUSH
123349: LD_INT 4
123351: PPUSH
123352: CALL_OW 12
123356: ST_TO_ADDR
123357: GO 123367
// s2 := 1 ;
123359: LD_ADDR_VAR 0 3
123363: PUSH
123364: LD_INT 1
123366: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
123367: LD_ADDR_VAR 0 5
123371: PUSH
123372: LD_VAR 0 6
123376: PUSH
123377: LD_INT 1
123379: ARRAY
123380: PPUSH
123381: LD_VAR 0 3
123385: PPUSH
123386: CALL_OW 259
123390: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
123391: LD_VAR 0 6
123395: PUSH
123396: LD_INT 1
123398: ARRAY
123399: PPUSH
123400: LD_VAR 0 2
123404: PPUSH
123405: LD_VAR 0 5
123409: PPUSH
123410: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
123414: LD_VAR 0 6
123418: PUSH
123419: LD_INT 1
123421: ARRAY
123422: PPUSH
123423: LD_VAR 0 3
123427: PPUSH
123428: LD_VAR 0 4
123432: PPUSH
123433: CALL_OW 237
// end ;
123437: PPOPN 6
123439: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
123440: LD_EXP 148
123444: PUSH
123445: LD_EXP 195
123449: AND
123450: IFFALSE 123529
123452: GO 123454
123454: DISABLE
123455: LD_INT 0
123457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
123458: LD_ADDR_VAR 0 1
123462: PUSH
123463: LD_INT 22
123465: PUSH
123466: LD_OWVAR 2
123470: PUSH
123471: EMPTY
123472: LIST
123473: LIST
123474: PUSH
123475: LD_INT 30
123477: PUSH
123478: LD_INT 3
123480: PUSH
123481: EMPTY
123482: LIST
123483: LIST
123484: PUSH
123485: EMPTY
123486: LIST
123487: LIST
123488: PPUSH
123489: CALL_OW 69
123493: ST_TO_ADDR
// if not tmp then
123494: LD_VAR 0 1
123498: NOT
123499: IFFALSE 123503
// exit ;
123501: GO 123529
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123503: LD_VAR 0 1
123507: PUSH
123508: LD_INT 1
123510: PPUSH
123511: LD_VAR 0 1
123515: PPUSH
123516: CALL_OW 12
123520: ARRAY
123521: PPUSH
123522: LD_INT 1
123524: PPUSH
123525: CALL_OW 234
// end ;
123529: PPOPN 1
123531: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
123532: LD_EXP 148
123536: PUSH
123537: LD_EXP 196
123541: AND
123542: IFFALSE 123654
123544: GO 123546
123546: DISABLE
123547: LD_INT 0
123549: PPUSH
123550: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
123551: LD_ADDR_VAR 0 2
123555: PUSH
123556: LD_INT 22
123558: PUSH
123559: LD_OWVAR 2
123563: PUSH
123564: EMPTY
123565: LIST
123566: LIST
123567: PUSH
123568: LD_INT 2
123570: PUSH
123571: LD_INT 30
123573: PUSH
123574: LD_INT 27
123576: PUSH
123577: EMPTY
123578: LIST
123579: LIST
123580: PUSH
123581: LD_INT 30
123583: PUSH
123584: LD_INT 26
123586: PUSH
123587: EMPTY
123588: LIST
123589: LIST
123590: PUSH
123591: LD_INT 30
123593: PUSH
123594: LD_INT 28
123596: PUSH
123597: EMPTY
123598: LIST
123599: LIST
123600: PUSH
123601: EMPTY
123602: LIST
123603: LIST
123604: LIST
123605: LIST
123606: PUSH
123607: EMPTY
123608: LIST
123609: LIST
123610: PPUSH
123611: CALL_OW 69
123615: ST_TO_ADDR
// if not tmp then
123616: LD_VAR 0 2
123620: NOT
123621: IFFALSE 123625
// exit ;
123623: GO 123654
// for i in tmp do
123625: LD_ADDR_VAR 0 1
123629: PUSH
123630: LD_VAR 0 2
123634: PUSH
123635: FOR_IN
123636: IFFALSE 123652
// SetLives ( i , 1 ) ;
123638: LD_VAR 0 1
123642: PPUSH
123643: LD_INT 1
123645: PPUSH
123646: CALL_OW 234
123650: GO 123635
123652: POP
123653: POP
// end ;
123654: PPOPN 2
123656: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
123657: LD_EXP 148
123661: PUSH
123662: LD_EXP 197
123666: AND
123667: IFFALSE 123954
123669: GO 123671
123671: DISABLE
123672: LD_INT 0
123674: PPUSH
123675: PPUSH
123676: PPUSH
// begin i := rand ( 1 , 7 ) ;
123677: LD_ADDR_VAR 0 1
123681: PUSH
123682: LD_INT 1
123684: PPUSH
123685: LD_INT 7
123687: PPUSH
123688: CALL_OW 12
123692: ST_TO_ADDR
// case i of 1 :
123693: LD_VAR 0 1
123697: PUSH
123698: LD_INT 1
123700: DOUBLE
123701: EQUAL
123702: IFTRUE 123706
123704: GO 123716
123706: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123707: LD_STRING earthquake(getX(game), 0, 32)
123709: PPUSH
123710: CALL_OW 559
123714: GO 123954
123716: LD_INT 2
123718: DOUBLE
123719: EQUAL
123720: IFTRUE 123724
123722: GO 123738
123724: POP
// begin ToLua ( displayStucuk(); ) ;
123725: LD_STRING displayStucuk();
123727: PPUSH
123728: CALL_OW 559
// ResetFog ;
123732: CALL_OW 335
// end ; 3 :
123736: GO 123954
123738: LD_INT 3
123740: DOUBLE
123741: EQUAL
123742: IFTRUE 123746
123744: GO 123850
123746: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123747: LD_ADDR_VAR 0 2
123751: PUSH
123752: LD_INT 22
123754: PUSH
123755: LD_OWVAR 2
123759: PUSH
123760: EMPTY
123761: LIST
123762: LIST
123763: PUSH
123764: LD_INT 25
123766: PUSH
123767: LD_INT 1
123769: PUSH
123770: EMPTY
123771: LIST
123772: LIST
123773: PUSH
123774: EMPTY
123775: LIST
123776: LIST
123777: PPUSH
123778: CALL_OW 69
123782: ST_TO_ADDR
// if not tmp then
123783: LD_VAR 0 2
123787: NOT
123788: IFFALSE 123792
// exit ;
123790: GO 123954
// un := tmp [ rand ( 1 , tmp ) ] ;
123792: LD_ADDR_VAR 0 3
123796: PUSH
123797: LD_VAR 0 2
123801: PUSH
123802: LD_INT 1
123804: PPUSH
123805: LD_VAR 0 2
123809: PPUSH
123810: CALL_OW 12
123814: ARRAY
123815: ST_TO_ADDR
// if Crawls ( un ) then
123816: LD_VAR 0 3
123820: PPUSH
123821: CALL_OW 318
123825: IFFALSE 123836
// ComWalk ( un ) ;
123827: LD_VAR 0 3
123831: PPUSH
123832: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123836: LD_VAR 0 3
123840: PPUSH
123841: LD_INT 8
123843: PPUSH
123844: CALL_OW 336
// end ; 4 :
123848: GO 123954
123850: LD_INT 4
123852: DOUBLE
123853: EQUAL
123854: IFTRUE 123858
123856: GO 123932
123858: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123859: LD_ADDR_VAR 0 2
123863: PUSH
123864: LD_INT 22
123866: PUSH
123867: LD_OWVAR 2
123871: PUSH
123872: EMPTY
123873: LIST
123874: LIST
123875: PUSH
123876: LD_INT 30
123878: PUSH
123879: LD_INT 29
123881: PUSH
123882: EMPTY
123883: LIST
123884: LIST
123885: PUSH
123886: EMPTY
123887: LIST
123888: LIST
123889: PPUSH
123890: CALL_OW 69
123894: ST_TO_ADDR
// if not tmp then
123895: LD_VAR 0 2
123899: NOT
123900: IFFALSE 123904
// exit ;
123902: GO 123954
// CenterNowOnUnits ( tmp [ 1 ] ) ;
123904: LD_VAR 0 2
123908: PUSH
123909: LD_INT 1
123911: ARRAY
123912: PPUSH
123913: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
123917: LD_VAR 0 2
123921: PUSH
123922: LD_INT 1
123924: ARRAY
123925: PPUSH
123926: CALL_OW 65
// end ; 5 .. 7 :
123930: GO 123954
123932: LD_INT 5
123934: DOUBLE
123935: GREATEREQUAL
123936: IFFALSE 123944
123938: LD_INT 7
123940: DOUBLE
123941: LESSEQUAL
123942: IFTRUE 123946
123944: GO 123953
123946: POP
// StreamSibBomb ; end ;
123947: CALL 120191 0 0
123951: GO 123954
123953: POP
// end ;
123954: PPOPN 3
123956: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
123957: LD_EXP 148
123961: PUSH
123962: LD_EXP 198
123966: AND
123967: IFFALSE 124123
123969: GO 123971
123971: DISABLE
123972: LD_INT 0
123974: PPUSH
123975: PPUSH
123976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
123977: LD_ADDR_VAR 0 2
123981: PUSH
123982: LD_INT 81
123984: PUSH
123985: LD_OWVAR 2
123989: PUSH
123990: EMPTY
123991: LIST
123992: LIST
123993: PUSH
123994: LD_INT 2
123996: PUSH
123997: LD_INT 21
123999: PUSH
124000: LD_INT 1
124002: PUSH
124003: EMPTY
124004: LIST
124005: LIST
124006: PUSH
124007: LD_INT 21
124009: PUSH
124010: LD_INT 2
124012: PUSH
124013: EMPTY
124014: LIST
124015: LIST
124016: PUSH
124017: EMPTY
124018: LIST
124019: LIST
124020: LIST
124021: PUSH
124022: EMPTY
124023: LIST
124024: LIST
124025: PPUSH
124026: CALL_OW 69
124030: ST_TO_ADDR
// if not tmp then
124031: LD_VAR 0 2
124035: NOT
124036: IFFALSE 124040
// exit ;
124038: GO 124123
// p := 0 ;
124040: LD_ADDR_VAR 0 3
124044: PUSH
124045: LD_INT 0
124047: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124048: LD_INT 35
124050: PPUSH
124051: CALL_OW 67
// p := p + 1 ;
124055: LD_ADDR_VAR 0 3
124059: PUSH
124060: LD_VAR 0 3
124064: PUSH
124065: LD_INT 1
124067: PLUS
124068: ST_TO_ADDR
// for i in tmp do
124069: LD_ADDR_VAR 0 1
124073: PUSH
124074: LD_VAR 0 2
124078: PUSH
124079: FOR_IN
124080: IFFALSE 124111
// if GetLives ( i ) < 1000 then
124082: LD_VAR 0 1
124086: PPUSH
124087: CALL_OW 256
124091: PUSH
124092: LD_INT 1000
124094: LESS
124095: IFFALSE 124109
// SetLives ( i , 1000 ) ;
124097: LD_VAR 0 1
124101: PPUSH
124102: LD_INT 1000
124104: PPUSH
124105: CALL_OW 234
124109: GO 124079
124111: POP
124112: POP
// until p > 20 ;
124113: LD_VAR 0 3
124117: PUSH
124118: LD_INT 20
124120: GREATER
124121: IFFALSE 124048
// end ;
124123: PPOPN 3
124125: END
// every 0 0$1 trigger StreamModeActive and sTime do
124126: LD_EXP 148
124130: PUSH
124131: LD_EXP 199
124135: AND
124136: IFFALSE 124171
124138: GO 124140
124140: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124141: LD_INT 28
124143: PPUSH
124144: LD_OWVAR 2
124148: PPUSH
124149: LD_INT 2
124151: PPUSH
124152: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124156: LD_INT 30
124158: PPUSH
124159: LD_OWVAR 2
124163: PPUSH
124164: LD_INT 2
124166: PPUSH
124167: CALL_OW 322
// end ;
124171: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124172: LD_EXP 148
124176: PUSH
124177: LD_EXP 200
124181: AND
124182: IFFALSE 124303
124184: GO 124186
124186: DISABLE
124187: LD_INT 0
124189: PPUSH
124190: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124191: LD_ADDR_VAR 0 2
124195: PUSH
124196: LD_INT 22
124198: PUSH
124199: LD_OWVAR 2
124203: PUSH
124204: EMPTY
124205: LIST
124206: LIST
124207: PUSH
124208: LD_INT 21
124210: PUSH
124211: LD_INT 1
124213: PUSH
124214: EMPTY
124215: LIST
124216: LIST
124217: PUSH
124218: LD_INT 3
124220: PUSH
124221: LD_INT 23
124223: PUSH
124224: LD_INT 0
124226: PUSH
124227: EMPTY
124228: LIST
124229: LIST
124230: PUSH
124231: EMPTY
124232: LIST
124233: LIST
124234: PUSH
124235: EMPTY
124236: LIST
124237: LIST
124238: LIST
124239: PPUSH
124240: CALL_OW 69
124244: ST_TO_ADDR
// if not tmp then
124245: LD_VAR 0 2
124249: NOT
124250: IFFALSE 124254
// exit ;
124252: GO 124303
// for i in tmp do
124254: LD_ADDR_VAR 0 1
124258: PUSH
124259: LD_VAR 0 2
124263: PUSH
124264: FOR_IN
124265: IFFALSE 124301
// begin if Crawls ( i ) then
124267: LD_VAR 0 1
124271: PPUSH
124272: CALL_OW 318
124276: IFFALSE 124287
// ComWalk ( i ) ;
124278: LD_VAR 0 1
124282: PPUSH
124283: CALL_OW 138
// SetClass ( i , 2 ) ;
124287: LD_VAR 0 1
124291: PPUSH
124292: LD_INT 2
124294: PPUSH
124295: CALL_OW 336
// end ;
124299: GO 124264
124301: POP
124302: POP
// end ;
124303: PPOPN 2
124305: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
124306: LD_EXP 148
124310: PUSH
124311: LD_EXP 201
124315: AND
124316: IFFALSE 124604
124318: GO 124320
124320: DISABLE
124321: LD_INT 0
124323: PPUSH
124324: PPUSH
124325: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
124326: LD_OWVAR 2
124330: PPUSH
124331: LD_INT 9
124333: PPUSH
124334: LD_INT 1
124336: PPUSH
124337: LD_INT 1
124339: PPUSH
124340: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
124344: LD_INT 9
124346: PPUSH
124347: LD_OWVAR 2
124351: PPUSH
124352: CALL_OW 343
// uc_side := 9 ;
124356: LD_ADDR_OWVAR 20
124360: PUSH
124361: LD_INT 9
124363: ST_TO_ADDR
// uc_nation := 2 ;
124364: LD_ADDR_OWVAR 21
124368: PUSH
124369: LD_INT 2
124371: ST_TO_ADDR
// hc_name := Dark Warrior ;
124372: LD_ADDR_OWVAR 26
124376: PUSH
124377: LD_STRING Dark Warrior
124379: ST_TO_ADDR
// hc_gallery :=  ;
124380: LD_ADDR_OWVAR 33
124384: PUSH
124385: LD_STRING 
124387: ST_TO_ADDR
// hc_noskilllimit := true ;
124388: LD_ADDR_OWVAR 76
124392: PUSH
124393: LD_INT 1
124395: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
124396: LD_ADDR_OWVAR 31
124400: PUSH
124401: LD_INT 30
124403: PUSH
124404: LD_INT 30
124406: PUSH
124407: LD_INT 30
124409: PUSH
124410: LD_INT 30
124412: PUSH
124413: EMPTY
124414: LIST
124415: LIST
124416: LIST
124417: LIST
124418: ST_TO_ADDR
// un := CreateHuman ;
124419: LD_ADDR_VAR 0 3
124423: PUSH
124424: CALL_OW 44
124428: ST_TO_ADDR
// hc_noskilllimit := false ;
124429: LD_ADDR_OWVAR 76
124433: PUSH
124434: LD_INT 0
124436: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124437: LD_VAR 0 3
124441: PPUSH
124442: LD_INT 1
124444: PPUSH
124445: CALL_OW 51
// ToLua ( playRanger() ) ;
124449: LD_STRING playRanger()
124451: PPUSH
124452: CALL_OW 559
// p := 0 ;
124456: LD_ADDR_VAR 0 2
124460: PUSH
124461: LD_INT 0
124463: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124464: LD_INT 35
124466: PPUSH
124467: CALL_OW 67
// p := p + 1 ;
124471: LD_ADDR_VAR 0 2
124475: PUSH
124476: LD_VAR 0 2
124480: PUSH
124481: LD_INT 1
124483: PLUS
124484: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
124485: LD_VAR 0 3
124489: PPUSH
124490: CALL_OW 256
124494: PUSH
124495: LD_INT 1000
124497: LESS
124498: IFFALSE 124512
// SetLives ( un , 1000 ) ;
124500: LD_VAR 0 3
124504: PPUSH
124505: LD_INT 1000
124507: PPUSH
124508: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
124512: LD_VAR 0 3
124516: PPUSH
124517: LD_INT 81
124519: PUSH
124520: LD_OWVAR 2
124524: PUSH
124525: EMPTY
124526: LIST
124527: LIST
124528: PUSH
124529: LD_INT 91
124531: PUSH
124532: LD_VAR 0 3
124536: PUSH
124537: LD_INT 30
124539: PUSH
124540: EMPTY
124541: LIST
124542: LIST
124543: LIST
124544: PUSH
124545: EMPTY
124546: LIST
124547: LIST
124548: PPUSH
124549: CALL_OW 69
124553: PPUSH
124554: LD_VAR 0 3
124558: PPUSH
124559: CALL_OW 74
124563: PPUSH
124564: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
124568: LD_VAR 0 2
124572: PUSH
124573: LD_INT 80
124575: GREATER
124576: PUSH
124577: LD_VAR 0 3
124581: PPUSH
124582: CALL_OW 301
124586: OR
124587: IFFALSE 124464
// if un then
124589: LD_VAR 0 3
124593: IFFALSE 124604
// RemoveUnit ( un ) ;
124595: LD_VAR 0 3
124599: PPUSH
124600: CALL_OW 64
// end ;
124604: PPOPN 3
124606: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
124607: LD_EXP 202
124611: IFFALSE 124727
124613: GO 124615
124615: DISABLE
124616: LD_INT 0
124618: PPUSH
124619: PPUSH
124620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
124621: LD_ADDR_VAR 0 2
124625: PUSH
124626: LD_INT 81
124628: PUSH
124629: LD_OWVAR 2
124633: PUSH
124634: EMPTY
124635: LIST
124636: LIST
124637: PUSH
124638: LD_INT 21
124640: PUSH
124641: LD_INT 1
124643: PUSH
124644: EMPTY
124645: LIST
124646: LIST
124647: PUSH
124648: EMPTY
124649: LIST
124650: LIST
124651: PPUSH
124652: CALL_OW 69
124656: ST_TO_ADDR
// ToLua ( playComputer() ) ;
124657: LD_STRING playComputer()
124659: PPUSH
124660: CALL_OW 559
// if not tmp then
124664: LD_VAR 0 2
124668: NOT
124669: IFFALSE 124673
// exit ;
124671: GO 124727
// for i in tmp do
124673: LD_ADDR_VAR 0 1
124677: PUSH
124678: LD_VAR 0 2
124682: PUSH
124683: FOR_IN
124684: IFFALSE 124725
// for j := 1 to 4 do
124686: LD_ADDR_VAR 0 3
124690: PUSH
124691: DOUBLE
124692: LD_INT 1
124694: DEC
124695: ST_TO_ADDR
124696: LD_INT 4
124698: PUSH
124699: FOR_TO
124700: IFFALSE 124721
// SetSkill ( i , j , 10 ) ;
124702: LD_VAR 0 1
124706: PPUSH
124707: LD_VAR 0 3
124711: PPUSH
124712: LD_INT 10
124714: PPUSH
124715: CALL_OW 237
124719: GO 124699
124721: POP
124722: POP
124723: GO 124683
124725: POP
124726: POP
// end ;
124727: PPOPN 3
124729: END
// every 0 0$1 trigger s30 do var i , tmp ;
124730: LD_EXP 203
124734: IFFALSE 124803
124736: GO 124738
124738: DISABLE
124739: LD_INT 0
124741: PPUSH
124742: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124743: LD_ADDR_VAR 0 2
124747: PUSH
124748: LD_INT 22
124750: PUSH
124751: LD_OWVAR 2
124755: PUSH
124756: EMPTY
124757: LIST
124758: LIST
124759: PPUSH
124760: CALL_OW 69
124764: ST_TO_ADDR
// if not tmp then
124765: LD_VAR 0 2
124769: NOT
124770: IFFALSE 124774
// exit ;
124772: GO 124803
// for i in tmp do
124774: LD_ADDR_VAR 0 1
124778: PUSH
124779: LD_VAR 0 2
124783: PUSH
124784: FOR_IN
124785: IFFALSE 124801
// SetLives ( i , 300 ) ;
124787: LD_VAR 0 1
124791: PPUSH
124792: LD_INT 300
124794: PPUSH
124795: CALL_OW 234
124799: GO 124784
124801: POP
124802: POP
// end ;
124803: PPOPN 2
124805: END
// every 0 0$1 trigger s60 do var i , tmp ;
124806: LD_EXP 204
124810: IFFALSE 124879
124812: GO 124814
124814: DISABLE
124815: LD_INT 0
124817: PPUSH
124818: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124819: LD_ADDR_VAR 0 2
124823: PUSH
124824: LD_INT 22
124826: PUSH
124827: LD_OWVAR 2
124831: PUSH
124832: EMPTY
124833: LIST
124834: LIST
124835: PPUSH
124836: CALL_OW 69
124840: ST_TO_ADDR
// if not tmp then
124841: LD_VAR 0 2
124845: NOT
124846: IFFALSE 124850
// exit ;
124848: GO 124879
// for i in tmp do
124850: LD_ADDR_VAR 0 1
124854: PUSH
124855: LD_VAR 0 2
124859: PUSH
124860: FOR_IN
124861: IFFALSE 124877
// SetLives ( i , 600 ) ;
124863: LD_VAR 0 1
124867: PPUSH
124868: LD_INT 600
124870: PPUSH
124871: CALL_OW 234
124875: GO 124860
124877: POP
124878: POP
// end ;
124879: PPOPN 2
124881: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
124882: LD_INT 0
124884: PPUSH
// case cmd of 301 :
124885: LD_VAR 0 1
124889: PUSH
124890: LD_INT 301
124892: DOUBLE
124893: EQUAL
124894: IFTRUE 124898
124896: GO 124930
124898: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
124899: LD_VAR 0 6
124903: PPUSH
124904: LD_VAR 0 7
124908: PPUSH
124909: LD_VAR 0 8
124913: PPUSH
124914: LD_VAR 0 4
124918: PPUSH
124919: LD_VAR 0 5
124923: PPUSH
124924: CALL 126139 0 5
124928: GO 125051
124930: LD_INT 302
124932: DOUBLE
124933: EQUAL
124934: IFTRUE 124938
124936: GO 124975
124938: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
124939: LD_VAR 0 6
124943: PPUSH
124944: LD_VAR 0 7
124948: PPUSH
124949: LD_VAR 0 8
124953: PPUSH
124954: LD_VAR 0 9
124958: PPUSH
124959: LD_VAR 0 4
124963: PPUSH
124964: LD_VAR 0 5
124968: PPUSH
124969: CALL 126230 0 6
124973: GO 125051
124975: LD_INT 303
124977: DOUBLE
124978: EQUAL
124979: IFTRUE 124983
124981: GO 125020
124983: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
124984: LD_VAR 0 6
124988: PPUSH
124989: LD_VAR 0 7
124993: PPUSH
124994: LD_VAR 0 8
124998: PPUSH
124999: LD_VAR 0 9
125003: PPUSH
125004: LD_VAR 0 4
125008: PPUSH
125009: LD_VAR 0 5
125013: PPUSH
125014: CALL 125056 0 6
125018: GO 125051
125020: LD_INT 304
125022: DOUBLE
125023: EQUAL
125024: IFTRUE 125028
125026: GO 125050
125028: POP
// hHackTeleport ( unit , x , y ) ; end ;
125029: LD_VAR 0 2
125033: PPUSH
125034: LD_VAR 0 4
125038: PPUSH
125039: LD_VAR 0 5
125043: PPUSH
125044: CALL 126823 0 3
125048: GO 125051
125050: POP
// end ;
125051: LD_VAR 0 12
125055: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125056: LD_INT 0
125058: PPUSH
125059: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125060: LD_VAR 0 1
125064: PUSH
125065: LD_INT 1
125067: LESS
125068: PUSH
125069: LD_VAR 0 1
125073: PUSH
125074: LD_INT 3
125076: GREATER
125077: OR
125078: PUSH
125079: LD_VAR 0 5
125083: PPUSH
125084: LD_VAR 0 6
125088: PPUSH
125089: CALL_OW 428
125093: OR
125094: IFFALSE 125098
// exit ;
125096: GO 125826
// uc_side := your_side ;
125098: LD_ADDR_OWVAR 20
125102: PUSH
125103: LD_OWVAR 2
125107: ST_TO_ADDR
// uc_nation := nation ;
125108: LD_ADDR_OWVAR 21
125112: PUSH
125113: LD_VAR 0 1
125117: ST_TO_ADDR
// bc_level = 1 ;
125118: LD_ADDR_OWVAR 43
125122: PUSH
125123: LD_INT 1
125125: ST_TO_ADDR
// case btype of 1 :
125126: LD_VAR 0 2
125130: PUSH
125131: LD_INT 1
125133: DOUBLE
125134: EQUAL
125135: IFTRUE 125139
125137: GO 125150
125139: POP
// bc_type := b_depot ; 2 :
125140: LD_ADDR_OWVAR 42
125144: PUSH
125145: LD_INT 0
125147: ST_TO_ADDR
125148: GO 125770
125150: LD_INT 2
125152: DOUBLE
125153: EQUAL
125154: IFTRUE 125158
125156: GO 125169
125158: POP
// bc_type := b_warehouse ; 3 :
125159: LD_ADDR_OWVAR 42
125163: PUSH
125164: LD_INT 1
125166: ST_TO_ADDR
125167: GO 125770
125169: LD_INT 3
125171: DOUBLE
125172: EQUAL
125173: IFTRUE 125177
125175: GO 125188
125177: POP
// bc_type := b_lab ; 4 .. 9 :
125178: LD_ADDR_OWVAR 42
125182: PUSH
125183: LD_INT 6
125185: ST_TO_ADDR
125186: GO 125770
125188: LD_INT 4
125190: DOUBLE
125191: GREATEREQUAL
125192: IFFALSE 125200
125194: LD_INT 9
125196: DOUBLE
125197: LESSEQUAL
125198: IFTRUE 125202
125200: GO 125262
125202: POP
// begin bc_type := b_lab_half ;
125203: LD_ADDR_OWVAR 42
125207: PUSH
125208: LD_INT 7
125210: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125211: LD_ADDR_OWVAR 44
125215: PUSH
125216: LD_INT 10
125218: PUSH
125219: LD_INT 11
125221: PUSH
125222: LD_INT 12
125224: PUSH
125225: LD_INT 15
125227: PUSH
125228: LD_INT 14
125230: PUSH
125231: LD_INT 13
125233: PUSH
125234: EMPTY
125235: LIST
125236: LIST
125237: LIST
125238: LIST
125239: LIST
125240: LIST
125241: PUSH
125242: LD_VAR 0 2
125246: PUSH
125247: LD_INT 3
125249: MINUS
125250: ARRAY
125251: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125252: LD_ADDR_OWVAR 45
125256: PUSH
125257: LD_INT 9
125259: ST_TO_ADDR
// end ; 10 .. 13 :
125260: GO 125770
125262: LD_INT 10
125264: DOUBLE
125265: GREATEREQUAL
125266: IFFALSE 125274
125268: LD_INT 13
125270: DOUBLE
125271: LESSEQUAL
125272: IFTRUE 125276
125274: GO 125353
125276: POP
// begin bc_type := b_lab_full ;
125277: LD_ADDR_OWVAR 42
125281: PUSH
125282: LD_INT 8
125284: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125285: LD_ADDR_OWVAR 44
125289: PUSH
125290: LD_INT 10
125292: PUSH
125293: LD_INT 12
125295: PUSH
125296: LD_INT 14
125298: PUSH
125299: LD_INT 13
125301: PUSH
125302: EMPTY
125303: LIST
125304: LIST
125305: LIST
125306: LIST
125307: PUSH
125308: LD_VAR 0 2
125312: PUSH
125313: LD_INT 9
125315: MINUS
125316: ARRAY
125317: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
125318: LD_ADDR_OWVAR 45
125322: PUSH
125323: LD_INT 11
125325: PUSH
125326: LD_INT 15
125328: PUSH
125329: LD_INT 12
125331: PUSH
125332: LD_INT 15
125334: PUSH
125335: EMPTY
125336: LIST
125337: LIST
125338: LIST
125339: LIST
125340: PUSH
125341: LD_VAR 0 2
125345: PUSH
125346: LD_INT 9
125348: MINUS
125349: ARRAY
125350: ST_TO_ADDR
// end ; 14 :
125351: GO 125770
125353: LD_INT 14
125355: DOUBLE
125356: EQUAL
125357: IFTRUE 125361
125359: GO 125372
125361: POP
// bc_type := b_workshop ; 15 :
125362: LD_ADDR_OWVAR 42
125366: PUSH
125367: LD_INT 2
125369: ST_TO_ADDR
125370: GO 125770
125372: LD_INT 15
125374: DOUBLE
125375: EQUAL
125376: IFTRUE 125380
125378: GO 125391
125380: POP
// bc_type := b_factory ; 16 :
125381: LD_ADDR_OWVAR 42
125385: PUSH
125386: LD_INT 3
125388: ST_TO_ADDR
125389: GO 125770
125391: LD_INT 16
125393: DOUBLE
125394: EQUAL
125395: IFTRUE 125399
125397: GO 125410
125399: POP
// bc_type := b_ext_gun ; 17 :
125400: LD_ADDR_OWVAR 42
125404: PUSH
125405: LD_INT 17
125407: ST_TO_ADDR
125408: GO 125770
125410: LD_INT 17
125412: DOUBLE
125413: EQUAL
125414: IFTRUE 125418
125416: GO 125446
125418: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
125419: LD_ADDR_OWVAR 42
125423: PUSH
125424: LD_INT 19
125426: PUSH
125427: LD_INT 23
125429: PUSH
125430: LD_INT 19
125432: PUSH
125433: EMPTY
125434: LIST
125435: LIST
125436: LIST
125437: PUSH
125438: LD_VAR 0 1
125442: ARRAY
125443: ST_TO_ADDR
125444: GO 125770
125446: LD_INT 18
125448: DOUBLE
125449: EQUAL
125450: IFTRUE 125454
125452: GO 125465
125454: POP
// bc_type := b_ext_radar ; 19 :
125455: LD_ADDR_OWVAR 42
125459: PUSH
125460: LD_INT 20
125462: ST_TO_ADDR
125463: GO 125770
125465: LD_INT 19
125467: DOUBLE
125468: EQUAL
125469: IFTRUE 125473
125471: GO 125484
125473: POP
// bc_type := b_ext_radio ; 20 :
125474: LD_ADDR_OWVAR 42
125478: PUSH
125479: LD_INT 22
125481: ST_TO_ADDR
125482: GO 125770
125484: LD_INT 20
125486: DOUBLE
125487: EQUAL
125488: IFTRUE 125492
125490: GO 125503
125492: POP
// bc_type := b_ext_siberium ; 21 :
125493: LD_ADDR_OWVAR 42
125497: PUSH
125498: LD_INT 21
125500: ST_TO_ADDR
125501: GO 125770
125503: LD_INT 21
125505: DOUBLE
125506: EQUAL
125507: IFTRUE 125511
125509: GO 125522
125511: POP
// bc_type := b_ext_computer ; 22 :
125512: LD_ADDR_OWVAR 42
125516: PUSH
125517: LD_INT 24
125519: ST_TO_ADDR
125520: GO 125770
125522: LD_INT 22
125524: DOUBLE
125525: EQUAL
125526: IFTRUE 125530
125528: GO 125541
125530: POP
// bc_type := b_ext_track ; 23 :
125531: LD_ADDR_OWVAR 42
125535: PUSH
125536: LD_INT 16
125538: ST_TO_ADDR
125539: GO 125770
125541: LD_INT 23
125543: DOUBLE
125544: EQUAL
125545: IFTRUE 125549
125547: GO 125560
125549: POP
// bc_type := b_ext_laser ; 24 :
125550: LD_ADDR_OWVAR 42
125554: PUSH
125555: LD_INT 25
125557: ST_TO_ADDR
125558: GO 125770
125560: LD_INT 24
125562: DOUBLE
125563: EQUAL
125564: IFTRUE 125568
125566: GO 125579
125568: POP
// bc_type := b_control_tower ; 25 :
125569: LD_ADDR_OWVAR 42
125573: PUSH
125574: LD_INT 36
125576: ST_TO_ADDR
125577: GO 125770
125579: LD_INT 25
125581: DOUBLE
125582: EQUAL
125583: IFTRUE 125587
125585: GO 125598
125587: POP
// bc_type := b_breastwork ; 26 :
125588: LD_ADDR_OWVAR 42
125592: PUSH
125593: LD_INT 31
125595: ST_TO_ADDR
125596: GO 125770
125598: LD_INT 26
125600: DOUBLE
125601: EQUAL
125602: IFTRUE 125606
125604: GO 125617
125606: POP
// bc_type := b_bunker ; 27 :
125607: LD_ADDR_OWVAR 42
125611: PUSH
125612: LD_INT 32
125614: ST_TO_ADDR
125615: GO 125770
125617: LD_INT 27
125619: DOUBLE
125620: EQUAL
125621: IFTRUE 125625
125623: GO 125636
125625: POP
// bc_type := b_turret ; 28 :
125626: LD_ADDR_OWVAR 42
125630: PUSH
125631: LD_INT 33
125633: ST_TO_ADDR
125634: GO 125770
125636: LD_INT 28
125638: DOUBLE
125639: EQUAL
125640: IFTRUE 125644
125642: GO 125655
125644: POP
// bc_type := b_armoury ; 29 :
125645: LD_ADDR_OWVAR 42
125649: PUSH
125650: LD_INT 4
125652: ST_TO_ADDR
125653: GO 125770
125655: LD_INT 29
125657: DOUBLE
125658: EQUAL
125659: IFTRUE 125663
125661: GO 125674
125663: POP
// bc_type := b_barracks ; 30 :
125664: LD_ADDR_OWVAR 42
125668: PUSH
125669: LD_INT 5
125671: ST_TO_ADDR
125672: GO 125770
125674: LD_INT 30
125676: DOUBLE
125677: EQUAL
125678: IFTRUE 125682
125680: GO 125693
125682: POP
// bc_type := b_solar_power ; 31 :
125683: LD_ADDR_OWVAR 42
125687: PUSH
125688: LD_INT 27
125690: ST_TO_ADDR
125691: GO 125770
125693: LD_INT 31
125695: DOUBLE
125696: EQUAL
125697: IFTRUE 125701
125699: GO 125712
125701: POP
// bc_type := b_oil_power ; 32 :
125702: LD_ADDR_OWVAR 42
125706: PUSH
125707: LD_INT 26
125709: ST_TO_ADDR
125710: GO 125770
125712: LD_INT 32
125714: DOUBLE
125715: EQUAL
125716: IFTRUE 125720
125718: GO 125731
125720: POP
// bc_type := b_siberite_power ; 33 :
125721: LD_ADDR_OWVAR 42
125725: PUSH
125726: LD_INT 28
125728: ST_TO_ADDR
125729: GO 125770
125731: LD_INT 33
125733: DOUBLE
125734: EQUAL
125735: IFTRUE 125739
125737: GO 125750
125739: POP
// bc_type := b_oil_mine ; 34 :
125740: LD_ADDR_OWVAR 42
125744: PUSH
125745: LD_INT 29
125747: ST_TO_ADDR
125748: GO 125770
125750: LD_INT 34
125752: DOUBLE
125753: EQUAL
125754: IFTRUE 125758
125756: GO 125769
125758: POP
// bc_type := b_siberite_mine ; end ;
125759: LD_ADDR_OWVAR 42
125763: PUSH
125764: LD_INT 30
125766: ST_TO_ADDR
125767: GO 125770
125769: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125770: LD_ADDR_VAR 0 8
125774: PUSH
125775: LD_VAR 0 5
125779: PPUSH
125780: LD_VAR 0 6
125784: PPUSH
125785: LD_VAR 0 3
125789: PPUSH
125790: CALL_OW 47
125794: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125795: LD_OWVAR 42
125799: PUSH
125800: LD_INT 32
125802: PUSH
125803: LD_INT 33
125805: PUSH
125806: EMPTY
125807: LIST
125808: LIST
125809: IN
125810: IFFALSE 125826
// PlaceWeaponTurret ( b , weapon ) ;
125812: LD_VAR 0 8
125816: PPUSH
125817: LD_VAR 0 4
125821: PPUSH
125822: CALL_OW 431
// end ;
125826: LD_VAR 0 7
125830: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125831: LD_INT 0
125833: PPUSH
125834: PPUSH
125835: PPUSH
125836: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125837: LD_ADDR_VAR 0 4
125841: PUSH
125842: LD_INT 22
125844: PUSH
125845: LD_OWVAR 2
125849: PUSH
125850: EMPTY
125851: LIST
125852: LIST
125853: PUSH
125854: LD_INT 2
125856: PUSH
125857: LD_INT 30
125859: PUSH
125860: LD_INT 0
125862: PUSH
125863: EMPTY
125864: LIST
125865: LIST
125866: PUSH
125867: LD_INT 30
125869: PUSH
125870: LD_INT 1
125872: PUSH
125873: EMPTY
125874: LIST
125875: LIST
125876: PUSH
125877: EMPTY
125878: LIST
125879: LIST
125880: LIST
125881: PUSH
125882: EMPTY
125883: LIST
125884: LIST
125885: PPUSH
125886: CALL_OW 69
125890: ST_TO_ADDR
// if not tmp then
125891: LD_VAR 0 4
125895: NOT
125896: IFFALSE 125900
// exit ;
125898: GO 125959
// for i in tmp do
125900: LD_ADDR_VAR 0 2
125904: PUSH
125905: LD_VAR 0 4
125909: PUSH
125910: FOR_IN
125911: IFFALSE 125957
// for j = 1 to 3 do
125913: LD_ADDR_VAR 0 3
125917: PUSH
125918: DOUBLE
125919: LD_INT 1
125921: DEC
125922: ST_TO_ADDR
125923: LD_INT 3
125925: PUSH
125926: FOR_TO
125927: IFFALSE 125953
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
125929: LD_VAR 0 2
125933: PPUSH
125934: CALL_OW 274
125938: PPUSH
125939: LD_VAR 0 3
125943: PPUSH
125944: LD_INT 99999
125946: PPUSH
125947: CALL_OW 277
125951: GO 125926
125953: POP
125954: POP
125955: GO 125910
125957: POP
125958: POP
// end ;
125959: LD_VAR 0 1
125963: RET
// export function hHackSetLevel10 ; var i , j ; begin
125964: LD_INT 0
125966: PPUSH
125967: PPUSH
125968: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125969: LD_ADDR_VAR 0 2
125973: PUSH
125974: LD_INT 21
125976: PUSH
125977: LD_INT 1
125979: PUSH
125980: EMPTY
125981: LIST
125982: LIST
125983: PPUSH
125984: CALL_OW 69
125988: PUSH
125989: FOR_IN
125990: IFFALSE 126042
// if IsSelected ( i ) then
125992: LD_VAR 0 2
125996: PPUSH
125997: CALL_OW 306
126001: IFFALSE 126040
// begin for j := 1 to 4 do
126003: LD_ADDR_VAR 0 3
126007: PUSH
126008: DOUBLE
126009: LD_INT 1
126011: DEC
126012: ST_TO_ADDR
126013: LD_INT 4
126015: PUSH
126016: FOR_TO
126017: IFFALSE 126038
// SetSkill ( i , j , 10 ) ;
126019: LD_VAR 0 2
126023: PPUSH
126024: LD_VAR 0 3
126028: PPUSH
126029: LD_INT 10
126031: PPUSH
126032: CALL_OW 237
126036: GO 126016
126038: POP
126039: POP
// end ;
126040: GO 125989
126042: POP
126043: POP
// end ;
126044: LD_VAR 0 1
126048: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126049: LD_INT 0
126051: PPUSH
126052: PPUSH
126053: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126054: LD_ADDR_VAR 0 2
126058: PUSH
126059: LD_INT 22
126061: PUSH
126062: LD_OWVAR 2
126066: PUSH
126067: EMPTY
126068: LIST
126069: LIST
126070: PUSH
126071: LD_INT 21
126073: PUSH
126074: LD_INT 1
126076: PUSH
126077: EMPTY
126078: LIST
126079: LIST
126080: PUSH
126081: EMPTY
126082: LIST
126083: LIST
126084: PPUSH
126085: CALL_OW 69
126089: PUSH
126090: FOR_IN
126091: IFFALSE 126132
// begin for j := 1 to 4 do
126093: LD_ADDR_VAR 0 3
126097: PUSH
126098: DOUBLE
126099: LD_INT 1
126101: DEC
126102: ST_TO_ADDR
126103: LD_INT 4
126105: PUSH
126106: FOR_TO
126107: IFFALSE 126128
// SetSkill ( i , j , 10 ) ;
126109: LD_VAR 0 2
126113: PPUSH
126114: LD_VAR 0 3
126118: PPUSH
126119: LD_INT 10
126121: PPUSH
126122: CALL_OW 237
126126: GO 126106
126128: POP
126129: POP
// end ;
126130: GO 126090
126132: POP
126133: POP
// end ;
126134: LD_VAR 0 1
126138: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126139: LD_INT 0
126141: PPUSH
// uc_side := your_side ;
126142: LD_ADDR_OWVAR 20
126146: PUSH
126147: LD_OWVAR 2
126151: ST_TO_ADDR
// uc_nation := nation ;
126152: LD_ADDR_OWVAR 21
126156: PUSH
126157: LD_VAR 0 1
126161: ST_TO_ADDR
// InitHc ;
126162: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126166: LD_INT 0
126168: PPUSH
126169: LD_VAR 0 2
126173: PPUSH
126174: LD_VAR 0 3
126178: PPUSH
126179: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126183: LD_VAR 0 4
126187: PPUSH
126188: LD_VAR 0 5
126192: PPUSH
126193: CALL_OW 428
126197: PUSH
126198: LD_INT 0
126200: EQUAL
126201: IFFALSE 126225
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126203: CALL_OW 44
126207: PPUSH
126208: LD_VAR 0 4
126212: PPUSH
126213: LD_VAR 0 5
126217: PPUSH
126218: LD_INT 1
126220: PPUSH
126221: CALL_OW 48
// end ;
126225: LD_VAR 0 6
126229: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126230: LD_INT 0
126232: PPUSH
126233: PPUSH
// uc_side := your_side ;
126234: LD_ADDR_OWVAR 20
126238: PUSH
126239: LD_OWVAR 2
126243: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126244: LD_VAR 0 1
126248: PUSH
126249: LD_INT 1
126251: PUSH
126252: LD_INT 2
126254: PUSH
126255: LD_INT 3
126257: PUSH
126258: LD_INT 4
126260: PUSH
126261: LD_INT 5
126263: PUSH
126264: EMPTY
126265: LIST
126266: LIST
126267: LIST
126268: LIST
126269: LIST
126270: IN
126271: IFFALSE 126283
// uc_nation := nation_american else
126273: LD_ADDR_OWVAR 21
126277: PUSH
126278: LD_INT 1
126280: ST_TO_ADDR
126281: GO 126326
// if chassis in [ 11 , 12 , 13 , 14 ] then
126283: LD_VAR 0 1
126287: PUSH
126288: LD_INT 11
126290: PUSH
126291: LD_INT 12
126293: PUSH
126294: LD_INT 13
126296: PUSH
126297: LD_INT 14
126299: PUSH
126300: EMPTY
126301: LIST
126302: LIST
126303: LIST
126304: LIST
126305: IN
126306: IFFALSE 126318
// uc_nation := nation_arabian else
126308: LD_ADDR_OWVAR 21
126312: PUSH
126313: LD_INT 2
126315: ST_TO_ADDR
126316: GO 126326
// uc_nation := nation_russian ;
126318: LD_ADDR_OWVAR 21
126322: PUSH
126323: LD_INT 3
126325: ST_TO_ADDR
// vc_chassis := chassis ;
126326: LD_ADDR_OWVAR 37
126330: PUSH
126331: LD_VAR 0 1
126335: ST_TO_ADDR
// vc_engine := engine ;
126336: LD_ADDR_OWVAR 39
126340: PUSH
126341: LD_VAR 0 2
126345: ST_TO_ADDR
// vc_control := control ;
126346: LD_ADDR_OWVAR 38
126350: PUSH
126351: LD_VAR 0 3
126355: ST_TO_ADDR
// vc_weapon := weapon ;
126356: LD_ADDR_OWVAR 40
126360: PUSH
126361: LD_VAR 0 4
126365: ST_TO_ADDR
// un := CreateVehicle ;
126366: LD_ADDR_VAR 0 8
126370: PUSH
126371: CALL_OW 45
126375: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
126376: LD_VAR 0 8
126380: PPUSH
126381: LD_INT 0
126383: PPUSH
126384: LD_INT 5
126386: PPUSH
126387: CALL_OW 12
126391: PPUSH
126392: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
126396: LD_VAR 0 8
126400: PPUSH
126401: LD_VAR 0 5
126405: PPUSH
126406: LD_VAR 0 6
126410: PPUSH
126411: LD_INT 1
126413: PPUSH
126414: CALL_OW 48
// end ;
126418: LD_VAR 0 7
126422: RET
// export hInvincible ; every 1 do
126423: GO 126425
126425: DISABLE
// hInvincible := [ ] ;
126426: LD_ADDR_EXP 205
126430: PUSH
126431: EMPTY
126432: ST_TO_ADDR
126433: END
// every 10 do var i ;
126434: GO 126436
126436: DISABLE
126437: LD_INT 0
126439: PPUSH
// begin enable ;
126440: ENABLE
// if not hInvincible then
126441: LD_EXP 205
126445: NOT
126446: IFFALSE 126450
// exit ;
126448: GO 126494
// for i in hInvincible do
126450: LD_ADDR_VAR 0 1
126454: PUSH
126455: LD_EXP 205
126459: PUSH
126460: FOR_IN
126461: IFFALSE 126492
// if GetLives ( i ) < 1000 then
126463: LD_VAR 0 1
126467: PPUSH
126468: CALL_OW 256
126472: PUSH
126473: LD_INT 1000
126475: LESS
126476: IFFALSE 126490
// SetLives ( i , 1000 ) ;
126478: LD_VAR 0 1
126482: PPUSH
126483: LD_INT 1000
126485: PPUSH
126486: CALL_OW 234
126490: GO 126460
126492: POP
126493: POP
// end ;
126494: PPOPN 1
126496: END
// export function hHackInvincible ; var i ; begin
126497: LD_INT 0
126499: PPUSH
126500: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
126501: LD_ADDR_VAR 0 2
126505: PUSH
126506: LD_INT 2
126508: PUSH
126509: LD_INT 21
126511: PUSH
126512: LD_INT 1
126514: PUSH
126515: EMPTY
126516: LIST
126517: LIST
126518: PUSH
126519: LD_INT 21
126521: PUSH
126522: LD_INT 2
126524: PUSH
126525: EMPTY
126526: LIST
126527: LIST
126528: PUSH
126529: EMPTY
126530: LIST
126531: LIST
126532: LIST
126533: PPUSH
126534: CALL_OW 69
126538: PUSH
126539: FOR_IN
126540: IFFALSE 126601
// if IsSelected ( i ) then
126542: LD_VAR 0 2
126546: PPUSH
126547: CALL_OW 306
126551: IFFALSE 126599
// begin if i in hInvincible then
126553: LD_VAR 0 2
126557: PUSH
126558: LD_EXP 205
126562: IN
126563: IFFALSE 126583
// hInvincible := hInvincible diff i else
126565: LD_ADDR_EXP 205
126569: PUSH
126570: LD_EXP 205
126574: PUSH
126575: LD_VAR 0 2
126579: DIFF
126580: ST_TO_ADDR
126581: GO 126599
// hInvincible := hInvincible union i ;
126583: LD_ADDR_EXP 205
126587: PUSH
126588: LD_EXP 205
126592: PUSH
126593: LD_VAR 0 2
126597: UNION
126598: ST_TO_ADDR
// end ;
126599: GO 126539
126601: POP
126602: POP
// end ;
126603: LD_VAR 0 1
126607: RET
// export function hHackInvisible ; var i , j ; begin
126608: LD_INT 0
126610: PPUSH
126611: PPUSH
126612: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126613: LD_ADDR_VAR 0 2
126617: PUSH
126618: LD_INT 21
126620: PUSH
126621: LD_INT 1
126623: PUSH
126624: EMPTY
126625: LIST
126626: LIST
126627: PPUSH
126628: CALL_OW 69
126632: PUSH
126633: FOR_IN
126634: IFFALSE 126658
// if IsSelected ( i ) then
126636: LD_VAR 0 2
126640: PPUSH
126641: CALL_OW 306
126645: IFFALSE 126656
// ComForceInvisible ( i ) ;
126647: LD_VAR 0 2
126651: PPUSH
126652: CALL_OW 496
126656: GO 126633
126658: POP
126659: POP
// end ;
126660: LD_VAR 0 1
126664: RET
// export function hHackChangeYourSide ; begin
126665: LD_INT 0
126667: PPUSH
// if your_side = 8 then
126668: LD_OWVAR 2
126672: PUSH
126673: LD_INT 8
126675: EQUAL
126676: IFFALSE 126688
// your_side := 0 else
126678: LD_ADDR_OWVAR 2
126682: PUSH
126683: LD_INT 0
126685: ST_TO_ADDR
126686: GO 126702
// your_side := your_side + 1 ;
126688: LD_ADDR_OWVAR 2
126692: PUSH
126693: LD_OWVAR 2
126697: PUSH
126698: LD_INT 1
126700: PLUS
126701: ST_TO_ADDR
// end ;
126702: LD_VAR 0 1
126706: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126707: LD_INT 0
126709: PPUSH
126710: PPUSH
126711: PPUSH
// for i in all_units do
126712: LD_ADDR_VAR 0 2
126716: PUSH
126717: LD_OWVAR 3
126721: PUSH
126722: FOR_IN
126723: IFFALSE 126801
// if IsSelected ( i ) then
126725: LD_VAR 0 2
126729: PPUSH
126730: CALL_OW 306
126734: IFFALSE 126799
// begin j := GetSide ( i ) ;
126736: LD_ADDR_VAR 0 3
126740: PUSH
126741: LD_VAR 0 2
126745: PPUSH
126746: CALL_OW 255
126750: ST_TO_ADDR
// if j = 8 then
126751: LD_VAR 0 3
126755: PUSH
126756: LD_INT 8
126758: EQUAL
126759: IFFALSE 126771
// j := 0 else
126761: LD_ADDR_VAR 0 3
126765: PUSH
126766: LD_INT 0
126768: ST_TO_ADDR
126769: GO 126785
// j := j + 1 ;
126771: LD_ADDR_VAR 0 3
126775: PUSH
126776: LD_VAR 0 3
126780: PUSH
126781: LD_INT 1
126783: PLUS
126784: ST_TO_ADDR
// SetSide ( i , j ) ;
126785: LD_VAR 0 2
126789: PPUSH
126790: LD_VAR 0 3
126794: PPUSH
126795: CALL_OW 235
// end ;
126799: GO 126722
126801: POP
126802: POP
// end ;
126803: LD_VAR 0 1
126807: RET
// export function hHackFog ; begin
126808: LD_INT 0
126810: PPUSH
// FogOff ( true ) ;
126811: LD_INT 1
126813: PPUSH
126814: CALL_OW 344
// end ;
126818: LD_VAR 0 1
126822: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126823: LD_INT 0
126825: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126826: LD_VAR 0 1
126830: PPUSH
126831: LD_VAR 0 2
126835: PPUSH
126836: LD_VAR 0 3
126840: PPUSH
126841: LD_INT 1
126843: PPUSH
126844: LD_INT 1
126846: PPUSH
126847: CALL_OW 483
// CenterOnXY ( x , y ) ;
126851: LD_VAR 0 2
126855: PPUSH
126856: LD_VAR 0 3
126860: PPUSH
126861: CALL_OW 84
// end ;
126865: LD_VAR 0 4
126869: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126870: LD_INT 0
126872: PPUSH
126873: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
126874: LD_VAR 0 1
126878: NOT
126879: PUSH
126880: LD_VAR 0 2
126884: PPUSH
126885: LD_VAR 0 3
126889: PPUSH
126890: CALL_OW 488
126894: NOT
126895: OR
126896: PUSH
126897: LD_VAR 0 1
126901: PPUSH
126902: CALL_OW 266
126906: PUSH
126907: LD_INT 3
126909: NONEQUAL
126910: PUSH
126911: LD_VAR 0 1
126915: PPUSH
126916: CALL_OW 247
126920: PUSH
126921: LD_INT 1
126923: EQUAL
126924: NOT
126925: AND
126926: OR
126927: IFFALSE 126931
// exit ;
126929: GO 127080
// if GetType ( factory ) = unit_human then
126931: LD_VAR 0 1
126935: PPUSH
126936: CALL_OW 247
126940: PUSH
126941: LD_INT 1
126943: EQUAL
126944: IFFALSE 126961
// factory := IsInUnit ( factory ) ;
126946: LD_ADDR_VAR 0 1
126950: PUSH
126951: LD_VAR 0 1
126955: PPUSH
126956: CALL_OW 310
126960: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
126961: LD_VAR 0 1
126965: PPUSH
126966: CALL_OW 266
126970: PUSH
126971: LD_INT 3
126973: NONEQUAL
126974: IFFALSE 126978
// exit ;
126976: GO 127080
// if HexInfo ( x , y ) = factory then
126978: LD_VAR 0 2
126982: PPUSH
126983: LD_VAR 0 3
126987: PPUSH
126988: CALL_OW 428
126992: PUSH
126993: LD_VAR 0 1
126997: EQUAL
126998: IFFALSE 127025
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
127000: LD_ADDR_EXP 206
127004: PUSH
127005: LD_EXP 206
127009: PPUSH
127010: LD_VAR 0 1
127014: PPUSH
127015: LD_INT 0
127017: PPUSH
127018: CALL_OW 1
127022: ST_TO_ADDR
127023: GO 127076
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
127025: LD_ADDR_EXP 206
127029: PUSH
127030: LD_EXP 206
127034: PPUSH
127035: LD_VAR 0 1
127039: PPUSH
127040: LD_VAR 0 1
127044: PPUSH
127045: CALL_OW 255
127049: PUSH
127050: LD_VAR 0 1
127054: PUSH
127055: LD_VAR 0 2
127059: PUSH
127060: LD_VAR 0 3
127064: PUSH
127065: EMPTY
127066: LIST
127067: LIST
127068: LIST
127069: LIST
127070: PPUSH
127071: CALL_OW 1
127075: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127076: CALL 127085 0 0
// end ;
127080: LD_VAR 0 4
127084: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127085: LD_INT 0
127087: PPUSH
127088: PPUSH
127089: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127090: LD_STRING resetFactoryWaypoint();
127092: PPUSH
127093: CALL_OW 559
// if factoryWaypoints then
127097: LD_EXP 206
127101: IFFALSE 127227
// begin list := PrepareArray ( factoryWaypoints ) ;
127103: LD_ADDR_VAR 0 3
127107: PUSH
127108: LD_EXP 206
127112: PPUSH
127113: CALL 111040 0 1
127117: ST_TO_ADDR
// for i := 1 to list do
127118: LD_ADDR_VAR 0 2
127122: PUSH
127123: DOUBLE
127124: LD_INT 1
127126: DEC
127127: ST_TO_ADDR
127128: LD_VAR 0 3
127132: PUSH
127133: FOR_TO
127134: IFFALSE 127225
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127136: LD_STRING setFactoryWaypointXY(
127138: PUSH
127139: LD_VAR 0 3
127143: PUSH
127144: LD_VAR 0 2
127148: ARRAY
127149: PUSH
127150: LD_INT 1
127152: ARRAY
127153: STR
127154: PUSH
127155: LD_STRING ,
127157: STR
127158: PUSH
127159: LD_VAR 0 3
127163: PUSH
127164: LD_VAR 0 2
127168: ARRAY
127169: PUSH
127170: LD_INT 2
127172: ARRAY
127173: STR
127174: PUSH
127175: LD_STRING ,
127177: STR
127178: PUSH
127179: LD_VAR 0 3
127183: PUSH
127184: LD_VAR 0 2
127188: ARRAY
127189: PUSH
127190: LD_INT 3
127192: ARRAY
127193: STR
127194: PUSH
127195: LD_STRING ,
127197: STR
127198: PUSH
127199: LD_VAR 0 3
127203: PUSH
127204: LD_VAR 0 2
127208: ARRAY
127209: PUSH
127210: LD_INT 4
127212: ARRAY
127213: STR
127214: PUSH
127215: LD_STRING )
127217: STR
127218: PPUSH
127219: CALL_OW 559
127223: GO 127133
127225: POP
127226: POP
// end ; end ;
127227: LD_VAR 0 1
127231: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127232: LD_INT 0
127234: PPUSH
// if HexInfo ( x , y ) = warehouse then
127235: LD_VAR 0 2
127239: PPUSH
127240: LD_VAR 0 3
127244: PPUSH
127245: CALL_OW 428
127249: PUSH
127250: LD_VAR 0 1
127254: EQUAL
127255: IFFALSE 127282
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127257: LD_ADDR_EXP 207
127261: PUSH
127262: LD_EXP 207
127266: PPUSH
127267: LD_VAR 0 1
127271: PPUSH
127272: LD_INT 0
127274: PPUSH
127275: CALL_OW 1
127279: ST_TO_ADDR
127280: GO 127333
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127282: LD_ADDR_EXP 207
127286: PUSH
127287: LD_EXP 207
127291: PPUSH
127292: LD_VAR 0 1
127296: PPUSH
127297: LD_VAR 0 1
127301: PPUSH
127302: CALL_OW 255
127306: PUSH
127307: LD_VAR 0 1
127311: PUSH
127312: LD_VAR 0 2
127316: PUSH
127317: LD_VAR 0 3
127321: PUSH
127322: EMPTY
127323: LIST
127324: LIST
127325: LIST
127326: LIST
127327: PPUSH
127328: CALL_OW 1
127332: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
127333: CALL 127342 0 0
// end ;
127337: LD_VAR 0 4
127341: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
127342: LD_INT 0
127344: PPUSH
127345: PPUSH
127346: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
127347: LD_STRING resetWarehouseGatheringPoints();
127349: PPUSH
127350: CALL_OW 559
// if warehouseGatheringPoints then
127354: LD_EXP 207
127358: IFFALSE 127484
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
127360: LD_ADDR_VAR 0 3
127364: PUSH
127365: LD_EXP 207
127369: PPUSH
127370: CALL 111040 0 1
127374: ST_TO_ADDR
// for i := 1 to list do
127375: LD_ADDR_VAR 0 2
127379: PUSH
127380: DOUBLE
127381: LD_INT 1
127383: DEC
127384: ST_TO_ADDR
127385: LD_VAR 0 3
127389: PUSH
127390: FOR_TO
127391: IFFALSE 127482
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127393: LD_STRING setWarehouseGatheringPointXY(
127395: PUSH
127396: LD_VAR 0 3
127400: PUSH
127401: LD_VAR 0 2
127405: ARRAY
127406: PUSH
127407: LD_INT 1
127409: ARRAY
127410: STR
127411: PUSH
127412: LD_STRING ,
127414: STR
127415: PUSH
127416: LD_VAR 0 3
127420: PUSH
127421: LD_VAR 0 2
127425: ARRAY
127426: PUSH
127427: LD_INT 2
127429: ARRAY
127430: STR
127431: PUSH
127432: LD_STRING ,
127434: STR
127435: PUSH
127436: LD_VAR 0 3
127440: PUSH
127441: LD_VAR 0 2
127445: ARRAY
127446: PUSH
127447: LD_INT 3
127449: ARRAY
127450: STR
127451: PUSH
127452: LD_STRING ,
127454: STR
127455: PUSH
127456: LD_VAR 0 3
127460: PUSH
127461: LD_VAR 0 2
127465: ARRAY
127466: PUSH
127467: LD_INT 4
127469: ARRAY
127470: STR
127471: PUSH
127472: LD_STRING )
127474: STR
127475: PPUSH
127476: CALL_OW 559
127480: GO 127390
127482: POP
127483: POP
// end ; end ;
127484: LD_VAR 0 1
127488: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
127489: LD_EXP 207
127493: IFFALSE 128178
127495: GO 127497
127497: DISABLE
127498: LD_INT 0
127500: PPUSH
127501: PPUSH
127502: PPUSH
127503: PPUSH
127504: PPUSH
127505: PPUSH
127506: PPUSH
127507: PPUSH
127508: PPUSH
// begin enable ;
127509: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
127510: LD_ADDR_VAR 0 3
127514: PUSH
127515: LD_EXP 207
127519: PPUSH
127520: CALL 111040 0 1
127524: ST_TO_ADDR
// if not list then
127525: LD_VAR 0 3
127529: NOT
127530: IFFALSE 127534
// exit ;
127532: GO 128178
// for i := 1 to list do
127534: LD_ADDR_VAR 0 1
127538: PUSH
127539: DOUBLE
127540: LD_INT 1
127542: DEC
127543: ST_TO_ADDR
127544: LD_VAR 0 3
127548: PUSH
127549: FOR_TO
127550: IFFALSE 128176
// begin depot := list [ i ] [ 2 ] ;
127552: LD_ADDR_VAR 0 8
127556: PUSH
127557: LD_VAR 0 3
127561: PUSH
127562: LD_VAR 0 1
127566: ARRAY
127567: PUSH
127568: LD_INT 2
127570: ARRAY
127571: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
127572: LD_ADDR_VAR 0 5
127576: PUSH
127577: LD_VAR 0 3
127581: PUSH
127582: LD_VAR 0 1
127586: ARRAY
127587: PUSH
127588: LD_INT 1
127590: ARRAY
127591: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
127592: LD_VAR 0 8
127596: PPUSH
127597: CALL_OW 301
127601: PUSH
127602: LD_VAR 0 5
127606: PUSH
127607: LD_VAR 0 8
127611: PPUSH
127612: CALL_OW 255
127616: NONEQUAL
127617: OR
127618: IFFALSE 127647
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
127620: LD_ADDR_EXP 207
127624: PUSH
127625: LD_EXP 207
127629: PPUSH
127630: LD_VAR 0 8
127634: PPUSH
127635: LD_INT 0
127637: PPUSH
127638: CALL_OW 1
127642: ST_TO_ADDR
// exit ;
127643: POP
127644: POP
127645: GO 128178
// end ; x := list [ i ] [ 3 ] ;
127647: LD_ADDR_VAR 0 6
127651: PUSH
127652: LD_VAR 0 3
127656: PUSH
127657: LD_VAR 0 1
127661: ARRAY
127662: PUSH
127663: LD_INT 3
127665: ARRAY
127666: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
127667: LD_ADDR_VAR 0 7
127671: PUSH
127672: LD_VAR 0 3
127676: PUSH
127677: LD_VAR 0 1
127681: ARRAY
127682: PUSH
127683: LD_INT 4
127685: ARRAY
127686: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
127687: LD_ADDR_VAR 0 9
127691: PUSH
127692: LD_VAR 0 6
127696: PPUSH
127697: LD_VAR 0 7
127701: PPUSH
127702: LD_INT 16
127704: PPUSH
127705: CALL 109628 0 3
127709: ST_TO_ADDR
// if not cratesNearbyPoint then
127710: LD_VAR 0 9
127714: NOT
127715: IFFALSE 127721
// exit ;
127717: POP
127718: POP
127719: GO 128178
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127721: LD_ADDR_VAR 0 4
127725: PUSH
127726: LD_INT 22
127728: PUSH
127729: LD_VAR 0 5
127733: PUSH
127734: EMPTY
127735: LIST
127736: LIST
127737: PUSH
127738: LD_INT 3
127740: PUSH
127741: LD_INT 60
127743: PUSH
127744: EMPTY
127745: LIST
127746: PUSH
127747: EMPTY
127748: LIST
127749: LIST
127750: PUSH
127751: LD_INT 91
127753: PUSH
127754: LD_VAR 0 8
127758: PUSH
127759: LD_INT 6
127761: PUSH
127762: EMPTY
127763: LIST
127764: LIST
127765: LIST
127766: PUSH
127767: LD_INT 2
127769: PUSH
127770: LD_INT 25
127772: PUSH
127773: LD_INT 2
127775: PUSH
127776: EMPTY
127777: LIST
127778: LIST
127779: PUSH
127780: LD_INT 25
127782: PUSH
127783: LD_INT 16
127785: PUSH
127786: EMPTY
127787: LIST
127788: LIST
127789: PUSH
127790: EMPTY
127791: LIST
127792: LIST
127793: LIST
127794: PUSH
127795: EMPTY
127796: LIST
127797: LIST
127798: LIST
127799: LIST
127800: PPUSH
127801: CALL_OW 69
127805: PUSH
127806: LD_VAR 0 8
127810: PPUSH
127811: CALL_OW 313
127815: PPUSH
127816: LD_INT 3
127818: PUSH
127819: LD_INT 60
127821: PUSH
127822: EMPTY
127823: LIST
127824: PUSH
127825: EMPTY
127826: LIST
127827: LIST
127828: PUSH
127829: LD_INT 2
127831: PUSH
127832: LD_INT 25
127834: PUSH
127835: LD_INT 2
127837: PUSH
127838: EMPTY
127839: LIST
127840: LIST
127841: PUSH
127842: LD_INT 25
127844: PUSH
127845: LD_INT 16
127847: PUSH
127848: EMPTY
127849: LIST
127850: LIST
127851: PUSH
127852: EMPTY
127853: LIST
127854: LIST
127855: LIST
127856: PUSH
127857: EMPTY
127858: LIST
127859: LIST
127860: PPUSH
127861: CALL_OW 72
127865: UNION
127866: ST_TO_ADDR
// if tmp then
127867: LD_VAR 0 4
127871: IFFALSE 127951
// begin tmp := ShrinkArray ( tmp , 3 ) ;
127873: LD_ADDR_VAR 0 4
127877: PUSH
127878: LD_VAR 0 4
127882: PPUSH
127883: LD_INT 3
127885: PPUSH
127886: CALL 107597 0 2
127890: ST_TO_ADDR
// for j in tmp do
127891: LD_ADDR_VAR 0 2
127895: PUSH
127896: LD_VAR 0 4
127900: PUSH
127901: FOR_IN
127902: IFFALSE 127945
// begin if IsInUnit ( j ) then
127904: LD_VAR 0 2
127908: PPUSH
127909: CALL_OW 310
127913: IFFALSE 127924
// ComExit ( j ) ;
127915: LD_VAR 0 2
127919: PPUSH
127920: CALL 107680 0 1
// AddComCollect ( j , x , y ) ;
127924: LD_VAR 0 2
127928: PPUSH
127929: LD_VAR 0 6
127933: PPUSH
127934: LD_VAR 0 7
127938: PPUSH
127939: CALL_OW 177
// end ;
127943: GO 127901
127945: POP
127946: POP
// exit ;
127947: POP
127948: POP
127949: GO 128178
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
127951: LD_ADDR_VAR 0 4
127955: PUSH
127956: LD_INT 22
127958: PUSH
127959: LD_VAR 0 5
127963: PUSH
127964: EMPTY
127965: LIST
127966: LIST
127967: PUSH
127968: LD_INT 91
127970: PUSH
127971: LD_VAR 0 8
127975: PUSH
127976: LD_INT 8
127978: PUSH
127979: EMPTY
127980: LIST
127981: LIST
127982: LIST
127983: PUSH
127984: LD_INT 2
127986: PUSH
127987: LD_INT 34
127989: PUSH
127990: LD_INT 12
127992: PUSH
127993: EMPTY
127994: LIST
127995: LIST
127996: PUSH
127997: LD_INT 34
127999: PUSH
128000: LD_INT 51
128002: PUSH
128003: EMPTY
128004: LIST
128005: LIST
128006: PUSH
128007: LD_INT 34
128009: PUSH
128010: LD_INT 32
128012: PUSH
128013: EMPTY
128014: LIST
128015: LIST
128016: PUSH
128017: LD_INT 34
128019: PUSH
128020: LD_INT 89
128022: PUSH
128023: EMPTY
128024: LIST
128025: LIST
128026: PUSH
128027: EMPTY
128028: LIST
128029: LIST
128030: LIST
128031: LIST
128032: LIST
128033: PUSH
128034: EMPTY
128035: LIST
128036: LIST
128037: LIST
128038: PPUSH
128039: CALL_OW 69
128043: ST_TO_ADDR
// if tmp then
128044: LD_VAR 0 4
128048: IFFALSE 128174
// begin for j in tmp do
128050: LD_ADDR_VAR 0 2
128054: PUSH
128055: LD_VAR 0 4
128059: PUSH
128060: FOR_IN
128061: IFFALSE 128172
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128063: LD_VAR 0 2
128067: PPUSH
128068: CALL_OW 262
128072: PUSH
128073: LD_INT 3
128075: EQUAL
128076: PUSH
128077: LD_VAR 0 2
128081: PPUSH
128082: CALL_OW 261
128086: PUSH
128087: LD_INT 20
128089: GREATER
128090: OR
128091: PUSH
128092: LD_VAR 0 2
128096: PPUSH
128097: CALL_OW 314
128101: NOT
128102: AND
128103: PUSH
128104: LD_VAR 0 2
128108: PPUSH
128109: CALL_OW 263
128113: PUSH
128114: LD_INT 1
128116: NONEQUAL
128117: PUSH
128118: LD_VAR 0 2
128122: PPUSH
128123: CALL_OW 311
128127: OR
128128: AND
128129: IFFALSE 128170
// begin ComCollect ( j , x , y ) ;
128131: LD_VAR 0 2
128135: PPUSH
128136: LD_VAR 0 6
128140: PPUSH
128141: LD_VAR 0 7
128145: PPUSH
128146: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128150: LD_VAR 0 2
128154: PPUSH
128155: LD_VAR 0 8
128159: PPUSH
128160: CALL_OW 172
// exit ;
128164: POP
128165: POP
128166: POP
128167: POP
128168: GO 128178
// end ;
128170: GO 128060
128172: POP
128173: POP
// end ; end ;
128174: GO 127549
128176: POP
128177: POP
// end ; end_of_file
128178: PPOPN 9
128180: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
128181: LD_INT 0
128183: PPUSH
128184: PPUSH
128185: PPUSH
128186: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
128187: LD_VAR 0 1
128191: PPUSH
128192: CALL_OW 264
128196: PUSH
128197: LD_INT 91
128199: EQUAL
128200: IFFALSE 128272
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
128202: LD_INT 68
128204: PPUSH
128205: LD_VAR 0 1
128209: PPUSH
128210: CALL_OW 255
128214: PPUSH
128215: CALL_OW 321
128219: PUSH
128220: LD_INT 2
128222: EQUAL
128223: IFFALSE 128235
// eff := 70 else
128225: LD_ADDR_VAR 0 4
128229: PUSH
128230: LD_INT 70
128232: ST_TO_ADDR
128233: GO 128243
// eff := 30 ;
128235: LD_ADDR_VAR 0 4
128239: PUSH
128240: LD_INT 30
128242: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
128243: LD_VAR 0 1
128247: PPUSH
128248: CALL_OW 250
128252: PPUSH
128253: LD_VAR 0 1
128257: PPUSH
128258: CALL_OW 251
128262: PPUSH
128263: LD_VAR 0 4
128267: PPUSH
128268: CALL_OW 495
// end ; end ;
128272: LD_VAR 0 2
128276: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128277: LD_INT 0
128279: PPUSH
// end ;
128280: LD_VAR 0 4
128284: RET
// export function SOS_Command ( cmd ) ; begin
128285: LD_INT 0
128287: PPUSH
// end ;
128288: LD_VAR 0 2
128292: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128293: LD_INT 0
128295: PPUSH
// end ;
128296: LD_VAR 0 6
128300: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
128301: LD_INT 0
128303: PPUSH
128304: PPUSH
// if not vehicle or not factory then
128305: LD_VAR 0 1
128309: NOT
128310: PUSH
128311: LD_VAR 0 2
128315: NOT
128316: OR
128317: IFFALSE 128321
// exit ;
128319: GO 128552
// if factoryWaypoints >= factory then
128321: LD_EXP 206
128325: PUSH
128326: LD_VAR 0 2
128330: GREATEREQUAL
128331: IFFALSE 128552
// if factoryWaypoints [ factory ] then
128333: LD_EXP 206
128337: PUSH
128338: LD_VAR 0 2
128342: ARRAY
128343: IFFALSE 128552
// begin if GetControl ( vehicle ) = control_manual then
128345: LD_VAR 0 1
128349: PPUSH
128350: CALL_OW 263
128354: PUSH
128355: LD_INT 1
128357: EQUAL
128358: IFFALSE 128439
// begin driver := IsDrivenBy ( vehicle ) ;
128360: LD_ADDR_VAR 0 4
128364: PUSH
128365: LD_VAR 0 1
128369: PPUSH
128370: CALL_OW 311
128374: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128375: LD_VAR 0 4
128379: PPUSH
128380: LD_EXP 206
128384: PUSH
128385: LD_VAR 0 2
128389: ARRAY
128390: PUSH
128391: LD_INT 3
128393: ARRAY
128394: PPUSH
128395: LD_EXP 206
128399: PUSH
128400: LD_VAR 0 2
128404: ARRAY
128405: PUSH
128406: LD_INT 4
128408: ARRAY
128409: PPUSH
128410: CALL_OW 171
// AddComExitVehicle ( driver ) ;
128414: LD_VAR 0 4
128418: PPUSH
128419: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
128423: LD_VAR 0 4
128427: PPUSH
128428: LD_VAR 0 2
128432: PPUSH
128433: CALL_OW 180
// end else
128437: GO 128552
// if GetControl ( vehicle ) = control_remote then
128439: LD_VAR 0 1
128443: PPUSH
128444: CALL_OW 263
128448: PUSH
128449: LD_INT 2
128451: EQUAL
128452: IFFALSE 128513
// begin wait ( 0 0$2 ) ;
128454: LD_INT 70
128456: PPUSH
128457: CALL_OW 67
// if Connect ( vehicle ) then
128461: LD_VAR 0 1
128465: PPUSH
128466: CALL 77899 0 1
128470: IFFALSE 128511
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128472: LD_VAR 0 1
128476: PPUSH
128477: LD_EXP 206
128481: PUSH
128482: LD_VAR 0 2
128486: ARRAY
128487: PUSH
128488: LD_INT 3
128490: ARRAY
128491: PPUSH
128492: LD_EXP 206
128496: PUSH
128497: LD_VAR 0 2
128501: ARRAY
128502: PUSH
128503: LD_INT 4
128505: ARRAY
128506: PPUSH
128507: CALL_OW 171
// end else
128511: GO 128552
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128513: LD_VAR 0 1
128517: PPUSH
128518: LD_EXP 206
128522: PUSH
128523: LD_VAR 0 2
128527: ARRAY
128528: PUSH
128529: LD_INT 3
128531: ARRAY
128532: PPUSH
128533: LD_EXP 206
128537: PUSH
128538: LD_VAR 0 2
128542: ARRAY
128543: PUSH
128544: LD_INT 4
128546: ARRAY
128547: PPUSH
128548: CALL_OW 171
// end ; end ;
128552: LD_VAR 0 3
128556: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
128557: LD_INT 0
128559: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
128560: LD_VAR 0 1
128564: PUSH
128565: LD_INT 250
128567: EQUAL
128568: PUSH
128569: LD_VAR 0 2
128573: PPUSH
128574: CALL_OW 264
128578: PUSH
128579: LD_INT 81
128581: EQUAL
128582: AND
128583: IFFALSE 128604
// MinerPlaceMine ( unit , x , y ) ;
128585: LD_VAR 0 2
128589: PPUSH
128590: LD_VAR 0 4
128594: PPUSH
128595: LD_VAR 0 5
128599: PPUSH
128600: CALL 131594 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
128604: LD_VAR 0 1
128608: PUSH
128609: LD_INT 251
128611: EQUAL
128612: PUSH
128613: LD_VAR 0 2
128617: PPUSH
128618: CALL_OW 264
128622: PUSH
128623: LD_INT 81
128625: EQUAL
128626: AND
128627: IFFALSE 128648
// MinerDetonateMine ( unit , x , y ) ;
128629: LD_VAR 0 2
128633: PPUSH
128634: LD_VAR 0 4
128638: PPUSH
128639: LD_VAR 0 5
128643: PPUSH
128644: CALL 131869 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
128648: LD_VAR 0 1
128652: PUSH
128653: LD_INT 252
128655: EQUAL
128656: PUSH
128657: LD_VAR 0 2
128661: PPUSH
128662: CALL_OW 264
128666: PUSH
128667: LD_INT 81
128669: EQUAL
128670: AND
128671: IFFALSE 128692
// MinerCreateMinefield ( unit , x , y ) ;
128673: LD_VAR 0 2
128677: PPUSH
128678: LD_VAR 0 4
128682: PPUSH
128683: LD_VAR 0 5
128687: PPUSH
128688: CALL 132286 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
128692: LD_VAR 0 1
128696: PUSH
128697: LD_INT 253
128699: EQUAL
128700: PUSH
128701: LD_VAR 0 2
128705: PPUSH
128706: CALL_OW 257
128710: PUSH
128711: LD_INT 5
128713: EQUAL
128714: AND
128715: IFFALSE 128736
// ComBinocular ( unit , x , y ) ;
128717: LD_VAR 0 2
128721: PPUSH
128722: LD_VAR 0 4
128726: PPUSH
128727: LD_VAR 0 5
128731: PPUSH
128732: CALL 132655 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128736: LD_VAR 0 1
128740: PUSH
128741: LD_INT 254
128743: EQUAL
128744: PUSH
128745: LD_VAR 0 2
128749: PPUSH
128750: CALL_OW 264
128754: PUSH
128755: LD_INT 99
128757: EQUAL
128758: AND
128759: PUSH
128760: LD_VAR 0 3
128764: PPUSH
128765: CALL_OW 263
128769: PUSH
128770: LD_INT 3
128772: EQUAL
128773: AND
128774: IFFALSE 128790
// HackDestroyVehicle ( unit , selectedUnit ) ;
128776: LD_VAR 0 2
128780: PPUSH
128781: LD_VAR 0 3
128785: PPUSH
128786: CALL 130958 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128790: LD_VAR 0 1
128794: PUSH
128795: LD_INT 255
128797: EQUAL
128798: PUSH
128799: LD_VAR 0 2
128803: PPUSH
128804: CALL_OW 264
128808: PUSH
128809: LD_INT 14
128811: PUSH
128812: LD_INT 53
128814: PUSH
128815: EMPTY
128816: LIST
128817: LIST
128818: IN
128819: AND
128820: PUSH
128821: LD_VAR 0 4
128825: PPUSH
128826: LD_VAR 0 5
128830: PPUSH
128831: CALL_OW 488
128835: AND
128836: IFFALSE 128860
// CutTreeXYR ( unit , x , y , 12 ) ;
128838: LD_VAR 0 2
128842: PPUSH
128843: LD_VAR 0 4
128847: PPUSH
128848: LD_VAR 0 5
128852: PPUSH
128853: LD_INT 12
128855: PPUSH
128856: CALL 128955 0 4
// if cmd = 256 then
128860: LD_VAR 0 1
128864: PUSH
128865: LD_INT 256
128867: EQUAL
128868: IFFALSE 128889
// SetFactoryWaypoint ( unit , x , y ) ;
128870: LD_VAR 0 2
128874: PPUSH
128875: LD_VAR 0 4
128879: PPUSH
128880: LD_VAR 0 5
128884: PPUSH
128885: CALL 126870 0 3
// if cmd = 257 then
128889: LD_VAR 0 1
128893: PUSH
128894: LD_INT 257
128896: EQUAL
128897: IFFALSE 128918
// SetWarehouseGatheringPoint ( unit , x , y ) ;
128899: LD_VAR 0 2
128903: PPUSH
128904: LD_VAR 0 4
128908: PPUSH
128909: LD_VAR 0 5
128913: PPUSH
128914: CALL 127232 0 3
// if cmd = 258 then
128918: LD_VAR 0 1
128922: PUSH
128923: LD_INT 258
128925: EQUAL
128926: IFFALSE 128950
// BurnTreeXYR ( unit , x , y , 8 ) ;
128928: LD_VAR 0 2
128932: PPUSH
128933: LD_VAR 0 4
128937: PPUSH
128938: LD_VAR 0 5
128942: PPUSH
128943: LD_INT 8
128945: PPUSH
128946: CALL 129349 0 4
// end ;
128950: LD_VAR 0 6
128954: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
128955: LD_INT 0
128957: PPUSH
128958: PPUSH
128959: PPUSH
128960: PPUSH
128961: PPUSH
128962: PPUSH
128963: PPUSH
128964: PPUSH
128965: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
128966: LD_VAR 0 1
128970: PPUSH
128971: CALL_OW 302
128975: NOT
128976: PUSH
128977: LD_VAR 0 2
128981: PPUSH
128982: LD_VAR 0 3
128986: PPUSH
128987: CALL_OW 488
128991: NOT
128992: OR
128993: PUSH
128994: LD_VAR 0 4
128998: NOT
128999: OR
129000: IFFALSE 129004
// exit ;
129002: GO 129344
// list := [ ] ;
129004: LD_ADDR_VAR 0 13
129008: PUSH
129009: EMPTY
129010: ST_TO_ADDR
// if x - r < 0 then
129011: LD_VAR 0 2
129015: PUSH
129016: LD_VAR 0 4
129020: MINUS
129021: PUSH
129022: LD_INT 0
129024: LESS
129025: IFFALSE 129037
// min_x := 0 else
129027: LD_ADDR_VAR 0 7
129031: PUSH
129032: LD_INT 0
129034: ST_TO_ADDR
129035: GO 129053
// min_x := x - r ;
129037: LD_ADDR_VAR 0 7
129041: PUSH
129042: LD_VAR 0 2
129046: PUSH
129047: LD_VAR 0 4
129051: MINUS
129052: ST_TO_ADDR
// if y - r < 0 then
129053: LD_VAR 0 3
129057: PUSH
129058: LD_VAR 0 4
129062: MINUS
129063: PUSH
129064: LD_INT 0
129066: LESS
129067: IFFALSE 129079
// min_y := 0 else
129069: LD_ADDR_VAR 0 8
129073: PUSH
129074: LD_INT 0
129076: ST_TO_ADDR
129077: GO 129095
// min_y := y - r ;
129079: LD_ADDR_VAR 0 8
129083: PUSH
129084: LD_VAR 0 3
129088: PUSH
129089: LD_VAR 0 4
129093: MINUS
129094: ST_TO_ADDR
// max_x := x + r ;
129095: LD_ADDR_VAR 0 9
129099: PUSH
129100: LD_VAR 0 2
129104: PUSH
129105: LD_VAR 0 4
129109: PLUS
129110: ST_TO_ADDR
// max_y := y + r ;
129111: LD_ADDR_VAR 0 10
129115: PUSH
129116: LD_VAR 0 3
129120: PUSH
129121: LD_VAR 0 4
129125: PLUS
129126: ST_TO_ADDR
// for _x = min_x to max_x do
129127: LD_ADDR_VAR 0 11
129131: PUSH
129132: DOUBLE
129133: LD_VAR 0 7
129137: DEC
129138: ST_TO_ADDR
129139: LD_VAR 0 9
129143: PUSH
129144: FOR_TO
129145: IFFALSE 129262
// for _y = min_y to max_y do
129147: LD_ADDR_VAR 0 12
129151: PUSH
129152: DOUBLE
129153: LD_VAR 0 8
129157: DEC
129158: ST_TO_ADDR
129159: LD_VAR 0 10
129163: PUSH
129164: FOR_TO
129165: IFFALSE 129258
// begin if not ValidHex ( _x , _y ) then
129167: LD_VAR 0 11
129171: PPUSH
129172: LD_VAR 0 12
129176: PPUSH
129177: CALL_OW 488
129181: NOT
129182: IFFALSE 129186
// continue ;
129184: GO 129164
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129186: LD_VAR 0 11
129190: PPUSH
129191: LD_VAR 0 12
129195: PPUSH
129196: CALL_OW 351
129200: PUSH
129201: LD_VAR 0 11
129205: PPUSH
129206: LD_VAR 0 12
129210: PPUSH
129211: CALL_OW 554
129215: AND
129216: IFFALSE 129256
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129218: LD_ADDR_VAR 0 13
129222: PUSH
129223: LD_VAR 0 13
129227: PPUSH
129228: LD_VAR 0 13
129232: PUSH
129233: LD_INT 1
129235: PLUS
129236: PPUSH
129237: LD_VAR 0 11
129241: PUSH
129242: LD_VAR 0 12
129246: PUSH
129247: EMPTY
129248: LIST
129249: LIST
129250: PPUSH
129251: CALL_OW 2
129255: ST_TO_ADDR
// end ;
129256: GO 129164
129258: POP
129259: POP
129260: GO 129144
129262: POP
129263: POP
// if not list then
129264: LD_VAR 0 13
129268: NOT
129269: IFFALSE 129273
// exit ;
129271: GO 129344
// for i in list do
129273: LD_ADDR_VAR 0 6
129277: PUSH
129278: LD_VAR 0 13
129282: PUSH
129283: FOR_IN
129284: IFFALSE 129342
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
129286: LD_VAR 0 1
129290: PPUSH
129291: LD_STRING M
129293: PUSH
129294: LD_VAR 0 6
129298: PUSH
129299: LD_INT 1
129301: ARRAY
129302: PUSH
129303: LD_VAR 0 6
129307: PUSH
129308: LD_INT 2
129310: ARRAY
129311: PUSH
129312: LD_INT 0
129314: PUSH
129315: LD_INT 0
129317: PUSH
129318: LD_INT 0
129320: PUSH
129321: LD_INT 0
129323: PUSH
129324: EMPTY
129325: LIST
129326: LIST
129327: LIST
129328: LIST
129329: LIST
129330: LIST
129331: LIST
129332: PUSH
129333: EMPTY
129334: LIST
129335: PPUSH
129336: CALL_OW 447
129340: GO 129283
129342: POP
129343: POP
// end ;
129344: LD_VAR 0 5
129348: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
129349: LD_INT 0
129351: PPUSH
129352: PPUSH
129353: PPUSH
129354: PPUSH
129355: PPUSH
129356: PPUSH
129357: PPUSH
129358: PPUSH
129359: PPUSH
129360: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
129361: LD_VAR 0 1
129365: PPUSH
129366: CALL_OW 302
129370: NOT
129371: PUSH
129372: LD_VAR 0 2
129376: PPUSH
129377: LD_VAR 0 3
129381: PPUSH
129382: CALL_OW 488
129386: NOT
129387: OR
129388: PUSH
129389: LD_VAR 0 4
129393: NOT
129394: OR
129395: IFFALSE 129399
// exit ;
129397: GO 129912
// list := [ ] ;
129399: LD_ADDR_VAR 0 13
129403: PUSH
129404: EMPTY
129405: ST_TO_ADDR
// if x - r < 0 then
129406: LD_VAR 0 2
129410: PUSH
129411: LD_VAR 0 4
129415: MINUS
129416: PUSH
129417: LD_INT 0
129419: LESS
129420: IFFALSE 129432
// min_x := 0 else
129422: LD_ADDR_VAR 0 7
129426: PUSH
129427: LD_INT 0
129429: ST_TO_ADDR
129430: GO 129448
// min_x := x - r ;
129432: LD_ADDR_VAR 0 7
129436: PUSH
129437: LD_VAR 0 2
129441: PUSH
129442: LD_VAR 0 4
129446: MINUS
129447: ST_TO_ADDR
// if y - r < 0 then
129448: LD_VAR 0 3
129452: PUSH
129453: LD_VAR 0 4
129457: MINUS
129458: PUSH
129459: LD_INT 0
129461: LESS
129462: IFFALSE 129474
// min_y := 0 else
129464: LD_ADDR_VAR 0 8
129468: PUSH
129469: LD_INT 0
129471: ST_TO_ADDR
129472: GO 129490
// min_y := y - r ;
129474: LD_ADDR_VAR 0 8
129478: PUSH
129479: LD_VAR 0 3
129483: PUSH
129484: LD_VAR 0 4
129488: MINUS
129489: ST_TO_ADDR
// max_x := x + r ;
129490: LD_ADDR_VAR 0 9
129494: PUSH
129495: LD_VAR 0 2
129499: PUSH
129500: LD_VAR 0 4
129504: PLUS
129505: ST_TO_ADDR
// max_y := y + r ;
129506: LD_ADDR_VAR 0 10
129510: PUSH
129511: LD_VAR 0 3
129515: PUSH
129516: LD_VAR 0 4
129520: PLUS
129521: ST_TO_ADDR
// for _x = min_x to max_x do
129522: LD_ADDR_VAR 0 11
129526: PUSH
129527: DOUBLE
129528: LD_VAR 0 7
129532: DEC
129533: ST_TO_ADDR
129534: LD_VAR 0 9
129538: PUSH
129539: FOR_TO
129540: IFFALSE 129657
// for _y = min_y to max_y do
129542: LD_ADDR_VAR 0 12
129546: PUSH
129547: DOUBLE
129548: LD_VAR 0 8
129552: DEC
129553: ST_TO_ADDR
129554: LD_VAR 0 10
129558: PUSH
129559: FOR_TO
129560: IFFALSE 129653
// begin if not ValidHex ( _x , _y ) then
129562: LD_VAR 0 11
129566: PPUSH
129567: LD_VAR 0 12
129571: PPUSH
129572: CALL_OW 488
129576: NOT
129577: IFFALSE 129581
// continue ;
129579: GO 129559
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129581: LD_VAR 0 11
129585: PPUSH
129586: LD_VAR 0 12
129590: PPUSH
129591: CALL_OW 351
129595: PUSH
129596: LD_VAR 0 11
129600: PPUSH
129601: LD_VAR 0 12
129605: PPUSH
129606: CALL_OW 554
129610: AND
129611: IFFALSE 129651
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129613: LD_ADDR_VAR 0 13
129617: PUSH
129618: LD_VAR 0 13
129622: PPUSH
129623: LD_VAR 0 13
129627: PUSH
129628: LD_INT 1
129630: PLUS
129631: PPUSH
129632: LD_VAR 0 11
129636: PUSH
129637: LD_VAR 0 12
129641: PUSH
129642: EMPTY
129643: LIST
129644: LIST
129645: PPUSH
129646: CALL_OW 2
129650: ST_TO_ADDR
// end ;
129651: GO 129559
129653: POP
129654: POP
129655: GO 129539
129657: POP
129658: POP
// if not list then
129659: LD_VAR 0 13
129663: NOT
129664: IFFALSE 129668
// exit ;
129666: GO 129912
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
129668: LD_ADDR_VAR 0 13
129672: PUSH
129673: LD_VAR 0 1
129677: PPUSH
129678: LD_VAR 0 13
129682: PPUSH
129683: LD_INT 1
129685: PPUSH
129686: LD_INT 1
129688: PPUSH
129689: CALL 75041 0 4
129693: ST_TO_ADDR
// ComStop ( flame ) ;
129694: LD_VAR 0 1
129698: PPUSH
129699: CALL_OW 141
// for i in list do
129703: LD_ADDR_VAR 0 6
129707: PUSH
129708: LD_VAR 0 13
129712: PUSH
129713: FOR_IN
129714: IFFALSE 129745
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129716: LD_VAR 0 1
129720: PPUSH
129721: LD_VAR 0 6
129725: PUSH
129726: LD_INT 1
129728: ARRAY
129729: PPUSH
129730: LD_VAR 0 6
129734: PUSH
129735: LD_INT 2
129737: ARRAY
129738: PPUSH
129739: CALL_OW 176
129743: GO 129713
129745: POP
129746: POP
// repeat wait ( 0 0$1 ) ;
129747: LD_INT 35
129749: PPUSH
129750: CALL_OW 67
// task := GetTaskList ( flame ) ;
129754: LD_ADDR_VAR 0 14
129758: PUSH
129759: LD_VAR 0 1
129763: PPUSH
129764: CALL_OW 437
129768: ST_TO_ADDR
// if not task then
129769: LD_VAR 0 14
129773: NOT
129774: IFFALSE 129778
// exit ;
129776: GO 129912
// if task [ 1 ] [ 1 ] <> | then
129778: LD_VAR 0 14
129782: PUSH
129783: LD_INT 1
129785: ARRAY
129786: PUSH
129787: LD_INT 1
129789: ARRAY
129790: PUSH
129791: LD_STRING |
129793: NONEQUAL
129794: IFFALSE 129798
// exit ;
129796: GO 129912
// _x := task [ 1 ] [ 2 ] ;
129798: LD_ADDR_VAR 0 11
129802: PUSH
129803: LD_VAR 0 14
129807: PUSH
129808: LD_INT 1
129810: ARRAY
129811: PUSH
129812: LD_INT 2
129814: ARRAY
129815: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129816: LD_ADDR_VAR 0 12
129820: PUSH
129821: LD_VAR 0 14
129825: PUSH
129826: LD_INT 1
129828: ARRAY
129829: PUSH
129830: LD_INT 3
129832: ARRAY
129833: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129834: LD_VAR 0 11
129838: PPUSH
129839: LD_VAR 0 12
129843: PPUSH
129844: CALL_OW 351
129848: NOT
129849: PUSH
129850: LD_VAR 0 11
129854: PPUSH
129855: LD_VAR 0 12
129859: PPUSH
129860: CALL_OW 554
129864: NOT
129865: OR
129866: IFFALSE 129900
// begin task := Delete ( task , 1 ) ;
129868: LD_ADDR_VAR 0 14
129872: PUSH
129873: LD_VAR 0 14
129877: PPUSH
129878: LD_INT 1
129880: PPUSH
129881: CALL_OW 3
129885: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
129886: LD_VAR 0 1
129890: PPUSH
129891: LD_VAR 0 14
129895: PPUSH
129896: CALL_OW 446
// end ; until not HasTask ( flame ) ;
129900: LD_VAR 0 1
129904: PPUSH
129905: CALL_OW 314
129909: NOT
129910: IFFALSE 129747
// end ;
129912: LD_VAR 0 5
129916: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
129917: LD_EXP 209
129921: NOT
129922: IFFALSE 129972
129924: GO 129926
129926: DISABLE
// begin initHack := true ;
129927: LD_ADDR_EXP 209
129931: PUSH
129932: LD_INT 1
129934: ST_TO_ADDR
// hackTanks := [ ] ;
129935: LD_ADDR_EXP 210
129939: PUSH
129940: EMPTY
129941: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
129942: LD_ADDR_EXP 211
129946: PUSH
129947: EMPTY
129948: ST_TO_ADDR
// hackLimit := 3 ;
129949: LD_ADDR_EXP 212
129953: PUSH
129954: LD_INT 3
129956: ST_TO_ADDR
// hackDist := 12 ;
129957: LD_ADDR_EXP 213
129961: PUSH
129962: LD_INT 12
129964: ST_TO_ADDR
// hackCounter := [ ] ;
129965: LD_ADDR_EXP 214
129969: PUSH
129970: EMPTY
129971: ST_TO_ADDR
// end ;
129972: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
129973: LD_EXP 209
129977: PUSH
129978: LD_INT 34
129980: PUSH
129981: LD_INT 99
129983: PUSH
129984: EMPTY
129985: LIST
129986: LIST
129987: PPUSH
129988: CALL_OW 69
129992: AND
129993: IFFALSE 130246
129995: GO 129997
129997: DISABLE
129998: LD_INT 0
130000: PPUSH
130001: PPUSH
// begin enable ;
130002: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
130003: LD_ADDR_VAR 0 1
130007: PUSH
130008: LD_INT 34
130010: PUSH
130011: LD_INT 99
130013: PUSH
130014: EMPTY
130015: LIST
130016: LIST
130017: PPUSH
130018: CALL_OW 69
130022: PUSH
130023: FOR_IN
130024: IFFALSE 130244
// begin if not i in hackTanks then
130026: LD_VAR 0 1
130030: PUSH
130031: LD_EXP 210
130035: IN
130036: NOT
130037: IFFALSE 130120
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
130039: LD_ADDR_EXP 210
130043: PUSH
130044: LD_EXP 210
130048: PPUSH
130049: LD_EXP 210
130053: PUSH
130054: LD_INT 1
130056: PLUS
130057: PPUSH
130058: LD_VAR 0 1
130062: PPUSH
130063: CALL_OW 1
130067: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
130068: LD_ADDR_EXP 211
130072: PUSH
130073: LD_EXP 211
130077: PPUSH
130078: LD_EXP 211
130082: PUSH
130083: LD_INT 1
130085: PLUS
130086: PPUSH
130087: EMPTY
130088: PPUSH
130089: CALL_OW 1
130093: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
130094: LD_ADDR_EXP 214
130098: PUSH
130099: LD_EXP 214
130103: PPUSH
130104: LD_EXP 214
130108: PUSH
130109: LD_INT 1
130111: PLUS
130112: PPUSH
130113: EMPTY
130114: PPUSH
130115: CALL_OW 1
130119: ST_TO_ADDR
// end ; if not IsOk ( i ) then
130120: LD_VAR 0 1
130124: PPUSH
130125: CALL_OW 302
130129: NOT
130130: IFFALSE 130143
// begin HackUnlinkAll ( i ) ;
130132: LD_VAR 0 1
130136: PPUSH
130137: CALL 130249 0 1
// continue ;
130141: GO 130023
// end ; HackCheckCapturedStatus ( i ) ;
130143: LD_VAR 0 1
130147: PPUSH
130148: CALL 130692 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
130152: LD_ADDR_VAR 0 2
130156: PUSH
130157: LD_INT 81
130159: PUSH
130160: LD_VAR 0 1
130164: PPUSH
130165: CALL_OW 255
130169: PUSH
130170: EMPTY
130171: LIST
130172: LIST
130173: PUSH
130174: LD_INT 33
130176: PUSH
130177: LD_INT 3
130179: PUSH
130180: EMPTY
130181: LIST
130182: LIST
130183: PUSH
130184: LD_INT 91
130186: PUSH
130187: LD_VAR 0 1
130191: PUSH
130192: LD_EXP 213
130196: PUSH
130197: EMPTY
130198: LIST
130199: LIST
130200: LIST
130201: PUSH
130202: LD_INT 50
130204: PUSH
130205: EMPTY
130206: LIST
130207: PUSH
130208: EMPTY
130209: LIST
130210: LIST
130211: LIST
130212: LIST
130213: PPUSH
130214: CALL_OW 69
130218: ST_TO_ADDR
// if not tmp then
130219: LD_VAR 0 2
130223: NOT
130224: IFFALSE 130228
// continue ;
130226: GO 130023
// HackLink ( i , tmp ) ;
130228: LD_VAR 0 1
130232: PPUSH
130233: LD_VAR 0 2
130237: PPUSH
130238: CALL 130385 0 2
// end ;
130242: GO 130023
130244: POP
130245: POP
// end ;
130246: PPOPN 2
130248: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
130249: LD_INT 0
130251: PPUSH
130252: PPUSH
130253: PPUSH
// if not hack in hackTanks then
130254: LD_VAR 0 1
130258: PUSH
130259: LD_EXP 210
130263: IN
130264: NOT
130265: IFFALSE 130269
// exit ;
130267: GO 130380
// index := GetElementIndex ( hackTanks , hack ) ;
130269: LD_ADDR_VAR 0 4
130273: PUSH
130274: LD_EXP 210
130278: PPUSH
130279: LD_VAR 0 1
130283: PPUSH
130284: CALL 74338 0 2
130288: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
130289: LD_EXP 211
130293: PUSH
130294: LD_VAR 0 4
130298: ARRAY
130299: IFFALSE 130380
// begin for i in hackTanksCaptured [ index ] do
130301: LD_ADDR_VAR 0 3
130305: PUSH
130306: LD_EXP 211
130310: PUSH
130311: LD_VAR 0 4
130315: ARRAY
130316: PUSH
130317: FOR_IN
130318: IFFALSE 130344
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
130320: LD_VAR 0 3
130324: PUSH
130325: LD_INT 1
130327: ARRAY
130328: PPUSH
130329: LD_VAR 0 3
130333: PUSH
130334: LD_INT 2
130336: ARRAY
130337: PPUSH
130338: CALL_OW 235
130342: GO 130317
130344: POP
130345: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
130346: LD_ADDR_EXP 211
130350: PUSH
130351: LD_EXP 211
130355: PPUSH
130356: LD_VAR 0 4
130360: PPUSH
130361: EMPTY
130362: PPUSH
130363: CALL_OW 1
130367: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
130368: LD_VAR 0 1
130372: PPUSH
130373: LD_INT 0
130375: PPUSH
130376: CALL_OW 505
// end ; end ;
130380: LD_VAR 0 2
130384: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
130385: LD_INT 0
130387: PPUSH
130388: PPUSH
130389: PPUSH
// if not hack in hackTanks or not vehicles then
130390: LD_VAR 0 1
130394: PUSH
130395: LD_EXP 210
130399: IN
130400: NOT
130401: PUSH
130402: LD_VAR 0 2
130406: NOT
130407: OR
130408: IFFALSE 130412
// exit ;
130410: GO 130687
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
130412: LD_ADDR_VAR 0 2
130416: PUSH
130417: LD_VAR 0 1
130421: PPUSH
130422: LD_VAR 0 2
130426: PPUSH
130427: LD_INT 1
130429: PPUSH
130430: LD_INT 1
130432: PPUSH
130433: CALL 74988 0 4
130437: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
130438: LD_ADDR_VAR 0 5
130442: PUSH
130443: LD_EXP 210
130447: PPUSH
130448: LD_VAR 0 1
130452: PPUSH
130453: CALL 74338 0 2
130457: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
130458: LD_EXP 211
130462: PUSH
130463: LD_VAR 0 5
130467: ARRAY
130468: PUSH
130469: LD_EXP 212
130473: LESS
130474: IFFALSE 130663
// begin for i := 1 to vehicles do
130476: LD_ADDR_VAR 0 4
130480: PUSH
130481: DOUBLE
130482: LD_INT 1
130484: DEC
130485: ST_TO_ADDR
130486: LD_VAR 0 2
130490: PUSH
130491: FOR_TO
130492: IFFALSE 130661
// begin if hackTanksCaptured [ index ] = hackLimit then
130494: LD_EXP 211
130498: PUSH
130499: LD_VAR 0 5
130503: ARRAY
130504: PUSH
130505: LD_EXP 212
130509: EQUAL
130510: IFFALSE 130514
// break ;
130512: GO 130661
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
130514: LD_ADDR_EXP 214
130518: PUSH
130519: LD_EXP 214
130523: PPUSH
130524: LD_VAR 0 5
130528: PPUSH
130529: LD_EXP 214
130533: PUSH
130534: LD_VAR 0 5
130538: ARRAY
130539: PUSH
130540: LD_INT 1
130542: PLUS
130543: PPUSH
130544: CALL_OW 1
130548: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
130549: LD_ADDR_EXP 211
130553: PUSH
130554: LD_EXP 211
130558: PPUSH
130559: LD_VAR 0 5
130563: PUSH
130564: LD_EXP 211
130568: PUSH
130569: LD_VAR 0 5
130573: ARRAY
130574: PUSH
130575: LD_INT 1
130577: PLUS
130578: PUSH
130579: EMPTY
130580: LIST
130581: LIST
130582: PPUSH
130583: LD_VAR 0 2
130587: PUSH
130588: LD_VAR 0 4
130592: ARRAY
130593: PUSH
130594: LD_VAR 0 2
130598: PUSH
130599: LD_VAR 0 4
130603: ARRAY
130604: PPUSH
130605: CALL_OW 255
130609: PUSH
130610: EMPTY
130611: LIST
130612: LIST
130613: PPUSH
130614: CALL 74553 0 3
130618: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
130619: LD_VAR 0 2
130623: PUSH
130624: LD_VAR 0 4
130628: ARRAY
130629: PPUSH
130630: LD_VAR 0 1
130634: PPUSH
130635: CALL_OW 255
130639: PPUSH
130640: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
130644: LD_VAR 0 2
130648: PUSH
130649: LD_VAR 0 4
130653: ARRAY
130654: PPUSH
130655: CALL_OW 141
// end ;
130659: GO 130491
130661: POP
130662: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130663: LD_VAR 0 1
130667: PPUSH
130668: LD_EXP 211
130672: PUSH
130673: LD_VAR 0 5
130677: ARRAY
130678: PUSH
130679: LD_INT 0
130681: PLUS
130682: PPUSH
130683: CALL_OW 505
// end ;
130687: LD_VAR 0 3
130691: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
130692: LD_INT 0
130694: PPUSH
130695: PPUSH
130696: PPUSH
130697: PPUSH
// if not hack in hackTanks then
130698: LD_VAR 0 1
130702: PUSH
130703: LD_EXP 210
130707: IN
130708: NOT
130709: IFFALSE 130713
// exit ;
130711: GO 130953
// index := GetElementIndex ( hackTanks , hack ) ;
130713: LD_ADDR_VAR 0 4
130717: PUSH
130718: LD_EXP 210
130722: PPUSH
130723: LD_VAR 0 1
130727: PPUSH
130728: CALL 74338 0 2
130732: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130733: LD_ADDR_VAR 0 3
130737: PUSH
130738: DOUBLE
130739: LD_EXP 211
130743: PUSH
130744: LD_VAR 0 4
130748: ARRAY
130749: INC
130750: ST_TO_ADDR
130751: LD_INT 1
130753: PUSH
130754: FOR_DOWNTO
130755: IFFALSE 130927
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130757: LD_ADDR_VAR 0 5
130761: PUSH
130762: LD_EXP 211
130766: PUSH
130767: LD_VAR 0 4
130771: ARRAY
130772: PUSH
130773: LD_VAR 0 3
130777: ARRAY
130778: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130779: LD_VAR 0 5
130783: PUSH
130784: LD_INT 1
130786: ARRAY
130787: PPUSH
130788: CALL_OW 302
130792: NOT
130793: PUSH
130794: LD_VAR 0 5
130798: PUSH
130799: LD_INT 1
130801: ARRAY
130802: PPUSH
130803: CALL_OW 255
130807: PUSH
130808: LD_VAR 0 1
130812: PPUSH
130813: CALL_OW 255
130817: NONEQUAL
130818: OR
130819: IFFALSE 130925
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130821: LD_VAR 0 5
130825: PUSH
130826: LD_INT 1
130828: ARRAY
130829: PPUSH
130830: CALL_OW 305
130834: PUSH
130835: LD_VAR 0 5
130839: PUSH
130840: LD_INT 1
130842: ARRAY
130843: PPUSH
130844: CALL_OW 255
130848: PUSH
130849: LD_VAR 0 1
130853: PPUSH
130854: CALL_OW 255
130858: EQUAL
130859: AND
130860: IFFALSE 130884
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130862: LD_VAR 0 5
130866: PUSH
130867: LD_INT 1
130869: ARRAY
130870: PPUSH
130871: LD_VAR 0 5
130875: PUSH
130876: LD_INT 2
130878: ARRAY
130879: PPUSH
130880: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
130884: LD_ADDR_EXP 211
130888: PUSH
130889: LD_EXP 211
130893: PPUSH
130894: LD_VAR 0 4
130898: PPUSH
130899: LD_EXP 211
130903: PUSH
130904: LD_VAR 0 4
130908: ARRAY
130909: PPUSH
130910: LD_VAR 0 3
130914: PPUSH
130915: CALL_OW 3
130919: PPUSH
130920: CALL_OW 1
130924: ST_TO_ADDR
// end ; end ;
130925: GO 130754
130927: POP
130928: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130929: LD_VAR 0 1
130933: PPUSH
130934: LD_EXP 211
130938: PUSH
130939: LD_VAR 0 4
130943: ARRAY
130944: PUSH
130945: LD_INT 0
130947: PLUS
130948: PPUSH
130949: CALL_OW 505
// end ;
130953: LD_VAR 0 2
130957: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
130958: LD_INT 0
130960: PPUSH
130961: PPUSH
130962: PPUSH
130963: PPUSH
// if not hack in hackTanks then
130964: LD_VAR 0 1
130968: PUSH
130969: LD_EXP 210
130973: IN
130974: NOT
130975: IFFALSE 130979
// exit ;
130977: GO 131064
// index := GetElementIndex ( hackTanks , hack ) ;
130979: LD_ADDR_VAR 0 5
130983: PUSH
130984: LD_EXP 210
130988: PPUSH
130989: LD_VAR 0 1
130993: PPUSH
130994: CALL 74338 0 2
130998: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
130999: LD_ADDR_VAR 0 4
131003: PUSH
131004: DOUBLE
131005: LD_INT 1
131007: DEC
131008: ST_TO_ADDR
131009: LD_EXP 211
131013: PUSH
131014: LD_VAR 0 5
131018: ARRAY
131019: PUSH
131020: FOR_TO
131021: IFFALSE 131062
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
131023: LD_EXP 211
131027: PUSH
131028: LD_VAR 0 5
131032: ARRAY
131033: PUSH
131034: LD_VAR 0 4
131038: ARRAY
131039: PUSH
131040: LD_INT 1
131042: ARRAY
131043: PUSH
131044: LD_VAR 0 2
131048: EQUAL
131049: IFFALSE 131060
// KillUnit ( vehicle ) ;
131051: LD_VAR 0 2
131055: PPUSH
131056: CALL_OW 66
131060: GO 131020
131062: POP
131063: POP
// end ;
131064: LD_VAR 0 3
131068: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
131069: LD_EXP 215
131073: NOT
131074: IFFALSE 131109
131076: GO 131078
131078: DISABLE
// begin initMiner := true ;
131079: LD_ADDR_EXP 215
131083: PUSH
131084: LD_INT 1
131086: ST_TO_ADDR
// minersList := [ ] ;
131087: LD_ADDR_EXP 216
131091: PUSH
131092: EMPTY
131093: ST_TO_ADDR
// minerMinesList := [ ] ;
131094: LD_ADDR_EXP 217
131098: PUSH
131099: EMPTY
131100: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
131101: LD_ADDR_EXP 218
131105: PUSH
131106: LD_INT 5
131108: ST_TO_ADDR
// end ;
131109: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
131110: LD_EXP 215
131114: PUSH
131115: LD_INT 34
131117: PUSH
131118: LD_INT 81
131120: PUSH
131121: EMPTY
131122: LIST
131123: LIST
131124: PPUSH
131125: CALL_OW 69
131129: AND
131130: IFFALSE 131591
131132: GO 131134
131134: DISABLE
131135: LD_INT 0
131137: PPUSH
131138: PPUSH
131139: PPUSH
131140: PPUSH
// begin enable ;
131141: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
131142: LD_ADDR_VAR 0 1
131146: PUSH
131147: LD_INT 34
131149: PUSH
131150: LD_INT 81
131152: PUSH
131153: EMPTY
131154: LIST
131155: LIST
131156: PPUSH
131157: CALL_OW 69
131161: PUSH
131162: FOR_IN
131163: IFFALSE 131235
// begin if not i in minersList then
131165: LD_VAR 0 1
131169: PUSH
131170: LD_EXP 216
131174: IN
131175: NOT
131176: IFFALSE 131233
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
131178: LD_ADDR_EXP 216
131182: PUSH
131183: LD_EXP 216
131187: PPUSH
131188: LD_EXP 216
131192: PUSH
131193: LD_INT 1
131195: PLUS
131196: PPUSH
131197: LD_VAR 0 1
131201: PPUSH
131202: CALL_OW 1
131206: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
131207: LD_ADDR_EXP 217
131211: PUSH
131212: LD_EXP 217
131216: PPUSH
131217: LD_EXP 217
131221: PUSH
131222: LD_INT 1
131224: PLUS
131225: PPUSH
131226: EMPTY
131227: PPUSH
131228: CALL_OW 1
131232: ST_TO_ADDR
// end end ;
131233: GO 131162
131235: POP
131236: POP
// for i := minerMinesList downto 1 do
131237: LD_ADDR_VAR 0 1
131241: PUSH
131242: DOUBLE
131243: LD_EXP 217
131247: INC
131248: ST_TO_ADDR
131249: LD_INT 1
131251: PUSH
131252: FOR_DOWNTO
131253: IFFALSE 131589
// begin if IsLive ( minersList [ i ] ) then
131255: LD_EXP 216
131259: PUSH
131260: LD_VAR 0 1
131264: ARRAY
131265: PPUSH
131266: CALL_OW 300
131270: IFFALSE 131298
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
131272: LD_EXP 216
131276: PUSH
131277: LD_VAR 0 1
131281: ARRAY
131282: PPUSH
131283: LD_EXP 217
131287: PUSH
131288: LD_VAR 0 1
131292: ARRAY
131293: PPUSH
131294: CALL_OW 505
// if not minerMinesList [ i ] then
131298: LD_EXP 217
131302: PUSH
131303: LD_VAR 0 1
131307: ARRAY
131308: NOT
131309: IFFALSE 131313
// continue ;
131311: GO 131252
// for j := minerMinesList [ i ] downto 1 do
131313: LD_ADDR_VAR 0 2
131317: PUSH
131318: DOUBLE
131319: LD_EXP 217
131323: PUSH
131324: LD_VAR 0 1
131328: ARRAY
131329: INC
131330: ST_TO_ADDR
131331: LD_INT 1
131333: PUSH
131334: FOR_DOWNTO
131335: IFFALSE 131585
// begin side := GetSide ( minersList [ i ] ) ;
131337: LD_ADDR_VAR 0 3
131341: PUSH
131342: LD_EXP 216
131346: PUSH
131347: LD_VAR 0 1
131351: ARRAY
131352: PPUSH
131353: CALL_OW 255
131357: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
131358: LD_ADDR_VAR 0 4
131362: PUSH
131363: LD_EXP 217
131367: PUSH
131368: LD_VAR 0 1
131372: ARRAY
131373: PUSH
131374: LD_VAR 0 2
131378: ARRAY
131379: PUSH
131380: LD_INT 1
131382: ARRAY
131383: PPUSH
131384: LD_EXP 217
131388: PUSH
131389: LD_VAR 0 1
131393: ARRAY
131394: PUSH
131395: LD_VAR 0 2
131399: ARRAY
131400: PUSH
131401: LD_INT 2
131403: ARRAY
131404: PPUSH
131405: CALL_OW 428
131409: ST_TO_ADDR
// if not tmp then
131410: LD_VAR 0 4
131414: NOT
131415: IFFALSE 131419
// continue ;
131417: GO 131334
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
131419: LD_VAR 0 4
131423: PUSH
131424: LD_INT 81
131426: PUSH
131427: LD_VAR 0 3
131431: PUSH
131432: EMPTY
131433: LIST
131434: LIST
131435: PPUSH
131436: CALL_OW 69
131440: IN
131441: PUSH
131442: LD_EXP 217
131446: PUSH
131447: LD_VAR 0 1
131451: ARRAY
131452: PUSH
131453: LD_VAR 0 2
131457: ARRAY
131458: PUSH
131459: LD_INT 1
131461: ARRAY
131462: PPUSH
131463: LD_EXP 217
131467: PUSH
131468: LD_VAR 0 1
131472: ARRAY
131473: PUSH
131474: LD_VAR 0 2
131478: ARRAY
131479: PUSH
131480: LD_INT 2
131482: ARRAY
131483: PPUSH
131484: CALL_OW 458
131488: AND
131489: IFFALSE 131583
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
131491: LD_EXP 217
131495: PUSH
131496: LD_VAR 0 1
131500: ARRAY
131501: PUSH
131502: LD_VAR 0 2
131506: ARRAY
131507: PUSH
131508: LD_INT 1
131510: ARRAY
131511: PPUSH
131512: LD_EXP 217
131516: PUSH
131517: LD_VAR 0 1
131521: ARRAY
131522: PUSH
131523: LD_VAR 0 2
131527: ARRAY
131528: PUSH
131529: LD_INT 2
131531: ARRAY
131532: PPUSH
131533: LD_VAR 0 3
131537: PPUSH
131538: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
131542: LD_ADDR_EXP 217
131546: PUSH
131547: LD_EXP 217
131551: PPUSH
131552: LD_VAR 0 1
131556: PPUSH
131557: LD_EXP 217
131561: PUSH
131562: LD_VAR 0 1
131566: ARRAY
131567: PPUSH
131568: LD_VAR 0 2
131572: PPUSH
131573: CALL_OW 3
131577: PPUSH
131578: CALL_OW 1
131582: ST_TO_ADDR
// end ; end ;
131583: GO 131334
131585: POP
131586: POP
// end ;
131587: GO 131252
131589: POP
131590: POP
// end ;
131591: PPOPN 4
131593: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
131594: LD_INT 0
131596: PPUSH
131597: PPUSH
// result := false ;
131598: LD_ADDR_VAR 0 4
131602: PUSH
131603: LD_INT 0
131605: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
131606: LD_VAR 0 1
131610: PPUSH
131611: CALL_OW 264
131615: PUSH
131616: LD_INT 81
131618: EQUAL
131619: NOT
131620: IFFALSE 131624
// exit ;
131622: GO 131864
// index := GetElementIndex ( minersList , unit ) ;
131624: LD_ADDR_VAR 0 5
131628: PUSH
131629: LD_EXP 216
131633: PPUSH
131634: LD_VAR 0 1
131638: PPUSH
131639: CALL 74338 0 2
131643: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
131644: LD_EXP 217
131648: PUSH
131649: LD_VAR 0 5
131653: ARRAY
131654: PUSH
131655: LD_EXP 218
131659: GREATEREQUAL
131660: IFFALSE 131664
// exit ;
131662: GO 131864
// ComMoveXY ( unit , x , y ) ;
131664: LD_VAR 0 1
131668: PPUSH
131669: LD_VAR 0 2
131673: PPUSH
131674: LD_VAR 0 3
131678: PPUSH
131679: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131683: LD_INT 35
131685: PPUSH
131686: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
131690: LD_VAR 0 1
131694: PPUSH
131695: LD_VAR 0 2
131699: PPUSH
131700: LD_VAR 0 3
131704: PPUSH
131705: CALL 106079 0 3
131709: NOT
131710: PUSH
131711: LD_VAR 0 1
131715: PPUSH
131716: CALL_OW 314
131720: AND
131721: IFFALSE 131725
// exit ;
131723: GO 131864
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131725: LD_VAR 0 2
131729: PPUSH
131730: LD_VAR 0 3
131734: PPUSH
131735: CALL_OW 428
131739: PUSH
131740: LD_VAR 0 1
131744: EQUAL
131745: PUSH
131746: LD_VAR 0 1
131750: PPUSH
131751: CALL_OW 314
131755: NOT
131756: AND
131757: IFFALSE 131683
// PlaySoundXY ( x , y , PlantMine ) ;
131759: LD_VAR 0 2
131763: PPUSH
131764: LD_VAR 0 3
131768: PPUSH
131769: LD_STRING PlantMine
131771: PPUSH
131772: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131776: LD_VAR 0 2
131780: PPUSH
131781: LD_VAR 0 3
131785: PPUSH
131786: LD_VAR 0 1
131790: PPUSH
131791: CALL_OW 255
131795: PPUSH
131796: LD_INT 0
131798: PPUSH
131799: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131803: LD_ADDR_EXP 217
131807: PUSH
131808: LD_EXP 217
131812: PPUSH
131813: LD_VAR 0 5
131817: PUSH
131818: LD_EXP 217
131822: PUSH
131823: LD_VAR 0 5
131827: ARRAY
131828: PUSH
131829: LD_INT 1
131831: PLUS
131832: PUSH
131833: EMPTY
131834: LIST
131835: LIST
131836: PPUSH
131837: LD_VAR 0 2
131841: PUSH
131842: LD_VAR 0 3
131846: PUSH
131847: EMPTY
131848: LIST
131849: LIST
131850: PPUSH
131851: CALL 74553 0 3
131855: ST_TO_ADDR
// result := true ;
131856: LD_ADDR_VAR 0 4
131860: PUSH
131861: LD_INT 1
131863: ST_TO_ADDR
// end ;
131864: LD_VAR 0 4
131868: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131869: LD_INT 0
131871: PPUSH
131872: PPUSH
131873: PPUSH
// if not unit in minersList then
131874: LD_VAR 0 1
131878: PUSH
131879: LD_EXP 216
131883: IN
131884: NOT
131885: IFFALSE 131889
// exit ;
131887: GO 132281
// index := GetElementIndex ( minersList , unit ) ;
131889: LD_ADDR_VAR 0 6
131893: PUSH
131894: LD_EXP 216
131898: PPUSH
131899: LD_VAR 0 1
131903: PPUSH
131904: CALL 74338 0 2
131908: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
131909: LD_ADDR_VAR 0 5
131913: PUSH
131914: DOUBLE
131915: LD_EXP 217
131919: PUSH
131920: LD_VAR 0 6
131924: ARRAY
131925: INC
131926: ST_TO_ADDR
131927: LD_INT 1
131929: PUSH
131930: FOR_DOWNTO
131931: IFFALSE 132092
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
131933: LD_EXP 217
131937: PUSH
131938: LD_VAR 0 6
131942: ARRAY
131943: PUSH
131944: LD_VAR 0 5
131948: ARRAY
131949: PUSH
131950: LD_INT 1
131952: ARRAY
131953: PUSH
131954: LD_VAR 0 2
131958: EQUAL
131959: PUSH
131960: LD_EXP 217
131964: PUSH
131965: LD_VAR 0 6
131969: ARRAY
131970: PUSH
131971: LD_VAR 0 5
131975: ARRAY
131976: PUSH
131977: LD_INT 2
131979: ARRAY
131980: PUSH
131981: LD_VAR 0 3
131985: EQUAL
131986: AND
131987: IFFALSE 132090
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131989: LD_EXP 217
131993: PUSH
131994: LD_VAR 0 6
131998: ARRAY
131999: PUSH
132000: LD_VAR 0 5
132004: ARRAY
132005: PUSH
132006: LD_INT 1
132008: ARRAY
132009: PPUSH
132010: LD_EXP 217
132014: PUSH
132015: LD_VAR 0 6
132019: ARRAY
132020: PUSH
132021: LD_VAR 0 5
132025: ARRAY
132026: PUSH
132027: LD_INT 2
132029: ARRAY
132030: PPUSH
132031: LD_VAR 0 1
132035: PPUSH
132036: CALL_OW 255
132040: PPUSH
132041: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132045: LD_ADDR_EXP 217
132049: PUSH
132050: LD_EXP 217
132054: PPUSH
132055: LD_VAR 0 6
132059: PPUSH
132060: LD_EXP 217
132064: PUSH
132065: LD_VAR 0 6
132069: ARRAY
132070: PPUSH
132071: LD_VAR 0 5
132075: PPUSH
132076: CALL_OW 3
132080: PPUSH
132081: CALL_OW 1
132085: ST_TO_ADDR
// exit ;
132086: POP
132087: POP
132088: GO 132281
// end ; end ;
132090: GO 131930
132092: POP
132093: POP
// for i := minerMinesList [ index ] downto 1 do
132094: LD_ADDR_VAR 0 5
132098: PUSH
132099: DOUBLE
132100: LD_EXP 217
132104: PUSH
132105: LD_VAR 0 6
132109: ARRAY
132110: INC
132111: ST_TO_ADDR
132112: LD_INT 1
132114: PUSH
132115: FOR_DOWNTO
132116: IFFALSE 132279
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
132118: LD_EXP 217
132122: PUSH
132123: LD_VAR 0 6
132127: ARRAY
132128: PUSH
132129: LD_VAR 0 5
132133: ARRAY
132134: PUSH
132135: LD_INT 1
132137: ARRAY
132138: PPUSH
132139: LD_EXP 217
132143: PUSH
132144: LD_VAR 0 6
132148: ARRAY
132149: PUSH
132150: LD_VAR 0 5
132154: ARRAY
132155: PUSH
132156: LD_INT 2
132158: ARRAY
132159: PPUSH
132160: LD_VAR 0 2
132164: PPUSH
132165: LD_VAR 0 3
132169: PPUSH
132170: CALL_OW 298
132174: PUSH
132175: LD_INT 6
132177: LESS
132178: IFFALSE 132277
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132180: LD_EXP 217
132184: PUSH
132185: LD_VAR 0 6
132189: ARRAY
132190: PUSH
132191: LD_VAR 0 5
132195: ARRAY
132196: PUSH
132197: LD_INT 1
132199: ARRAY
132200: PPUSH
132201: LD_EXP 217
132205: PUSH
132206: LD_VAR 0 6
132210: ARRAY
132211: PUSH
132212: LD_VAR 0 5
132216: ARRAY
132217: PUSH
132218: LD_INT 2
132220: ARRAY
132221: PPUSH
132222: LD_VAR 0 1
132226: PPUSH
132227: CALL_OW 255
132231: PPUSH
132232: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132236: LD_ADDR_EXP 217
132240: PUSH
132241: LD_EXP 217
132245: PPUSH
132246: LD_VAR 0 6
132250: PPUSH
132251: LD_EXP 217
132255: PUSH
132256: LD_VAR 0 6
132260: ARRAY
132261: PPUSH
132262: LD_VAR 0 5
132266: PPUSH
132267: CALL_OW 3
132271: PPUSH
132272: CALL_OW 1
132276: ST_TO_ADDR
// end ; end ;
132277: GO 132115
132279: POP
132280: POP
// end ;
132281: LD_VAR 0 4
132285: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
132286: LD_INT 0
132288: PPUSH
132289: PPUSH
132290: PPUSH
132291: PPUSH
132292: PPUSH
132293: PPUSH
132294: PPUSH
132295: PPUSH
132296: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
132297: LD_VAR 0 1
132301: PPUSH
132302: CALL_OW 264
132306: PUSH
132307: LD_INT 81
132309: EQUAL
132310: NOT
132311: PUSH
132312: LD_VAR 0 1
132316: PUSH
132317: LD_EXP 216
132321: IN
132322: NOT
132323: OR
132324: IFFALSE 132328
// exit ;
132326: GO 132650
// index := GetElementIndex ( minersList , unit ) ;
132328: LD_ADDR_VAR 0 6
132332: PUSH
132333: LD_EXP 216
132337: PPUSH
132338: LD_VAR 0 1
132342: PPUSH
132343: CALL 74338 0 2
132347: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
132348: LD_ADDR_VAR 0 8
132352: PUSH
132353: LD_EXP 218
132357: PUSH
132358: LD_EXP 217
132362: PUSH
132363: LD_VAR 0 6
132367: ARRAY
132368: MINUS
132369: ST_TO_ADDR
// if not minesFreeAmount then
132370: LD_VAR 0 8
132374: NOT
132375: IFFALSE 132379
// exit ;
132377: GO 132650
// tmp := [ ] ;
132379: LD_ADDR_VAR 0 7
132383: PUSH
132384: EMPTY
132385: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
132386: LD_ADDR_VAR 0 5
132390: PUSH
132391: DOUBLE
132392: LD_INT 1
132394: DEC
132395: ST_TO_ADDR
132396: LD_VAR 0 8
132400: PUSH
132401: FOR_TO
132402: IFFALSE 132597
// begin _d := rand ( 0 , 5 ) ;
132404: LD_ADDR_VAR 0 11
132408: PUSH
132409: LD_INT 0
132411: PPUSH
132412: LD_INT 5
132414: PPUSH
132415: CALL_OW 12
132419: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
132420: LD_ADDR_VAR 0 12
132424: PUSH
132425: LD_INT 2
132427: PPUSH
132428: LD_INT 6
132430: PPUSH
132431: CALL_OW 12
132435: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
132436: LD_ADDR_VAR 0 9
132440: PUSH
132441: LD_VAR 0 2
132445: PPUSH
132446: LD_VAR 0 11
132450: PPUSH
132451: LD_VAR 0 12
132455: PPUSH
132456: CALL_OW 272
132460: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
132461: LD_ADDR_VAR 0 10
132465: PUSH
132466: LD_VAR 0 3
132470: PPUSH
132471: LD_VAR 0 11
132475: PPUSH
132476: LD_VAR 0 12
132480: PPUSH
132481: CALL_OW 273
132485: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
132486: LD_VAR 0 9
132490: PPUSH
132491: LD_VAR 0 10
132495: PPUSH
132496: CALL_OW 488
132500: PUSH
132501: LD_VAR 0 9
132505: PUSH
132506: LD_VAR 0 10
132510: PUSH
132511: EMPTY
132512: LIST
132513: LIST
132514: PUSH
132515: LD_VAR 0 7
132519: IN
132520: NOT
132521: AND
132522: PUSH
132523: LD_VAR 0 9
132527: PPUSH
132528: LD_VAR 0 10
132532: PPUSH
132533: CALL_OW 458
132537: NOT
132538: AND
132539: IFFALSE 132581
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
132541: LD_ADDR_VAR 0 7
132545: PUSH
132546: LD_VAR 0 7
132550: PPUSH
132551: LD_VAR 0 7
132555: PUSH
132556: LD_INT 1
132558: PLUS
132559: PPUSH
132560: LD_VAR 0 9
132564: PUSH
132565: LD_VAR 0 10
132569: PUSH
132570: EMPTY
132571: LIST
132572: LIST
132573: PPUSH
132574: CALL_OW 1
132578: ST_TO_ADDR
132579: GO 132595
// i := i - 1 ;
132581: LD_ADDR_VAR 0 5
132585: PUSH
132586: LD_VAR 0 5
132590: PUSH
132591: LD_INT 1
132593: MINUS
132594: ST_TO_ADDR
// end ;
132595: GO 132401
132597: POP
132598: POP
// for i in tmp do
132599: LD_ADDR_VAR 0 5
132603: PUSH
132604: LD_VAR 0 7
132608: PUSH
132609: FOR_IN
132610: IFFALSE 132648
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
132612: LD_VAR 0 1
132616: PPUSH
132617: LD_VAR 0 5
132621: PUSH
132622: LD_INT 1
132624: ARRAY
132625: PPUSH
132626: LD_VAR 0 5
132630: PUSH
132631: LD_INT 2
132633: ARRAY
132634: PPUSH
132635: CALL 131594 0 3
132639: NOT
132640: IFFALSE 132646
// exit ;
132642: POP
132643: POP
132644: GO 132650
132646: GO 132609
132648: POP
132649: POP
// end ;
132650: LD_VAR 0 4
132654: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
132655: LD_INT 0
132657: PPUSH
132658: PPUSH
132659: PPUSH
132660: PPUSH
132661: PPUSH
132662: PPUSH
132663: PPUSH
// if not GetClass ( unit ) = class_sniper then
132664: LD_VAR 0 1
132668: PPUSH
132669: CALL_OW 257
132673: PUSH
132674: LD_INT 5
132676: EQUAL
132677: NOT
132678: IFFALSE 132682
// exit ;
132680: GO 133070
// dist := 8 ;
132682: LD_ADDR_VAR 0 5
132686: PUSH
132687: LD_INT 8
132689: ST_TO_ADDR
// viewRange := 12 ;
132690: LD_ADDR_VAR 0 7
132694: PUSH
132695: LD_INT 12
132697: ST_TO_ADDR
// side := GetSide ( unit ) ;
132698: LD_ADDR_VAR 0 6
132702: PUSH
132703: LD_VAR 0 1
132707: PPUSH
132708: CALL_OW 255
132712: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132713: LD_INT 61
132715: PPUSH
132716: LD_VAR 0 6
132720: PPUSH
132721: CALL_OW 321
132725: PUSH
132726: LD_INT 2
132728: EQUAL
132729: IFFALSE 132739
// viewRange := 16 ;
132731: LD_ADDR_VAR 0 7
132735: PUSH
132736: LD_INT 16
132738: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132739: LD_VAR 0 1
132743: PPUSH
132744: LD_VAR 0 2
132748: PPUSH
132749: LD_VAR 0 3
132753: PPUSH
132754: CALL_OW 297
132758: PUSH
132759: LD_VAR 0 5
132763: GREATER
132764: IFFALSE 132843
// begin ComMoveXY ( unit , x , y ) ;
132766: LD_VAR 0 1
132770: PPUSH
132771: LD_VAR 0 2
132775: PPUSH
132776: LD_VAR 0 3
132780: PPUSH
132781: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132785: LD_INT 35
132787: PPUSH
132788: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132792: LD_VAR 0 1
132796: PPUSH
132797: LD_VAR 0 2
132801: PPUSH
132802: LD_VAR 0 3
132806: PPUSH
132807: CALL 106079 0 3
132811: NOT
132812: IFFALSE 132816
// exit ;
132814: GO 133070
// until GetDistUnitXY ( unit , x , y ) < dist ;
132816: LD_VAR 0 1
132820: PPUSH
132821: LD_VAR 0 2
132825: PPUSH
132826: LD_VAR 0 3
132830: PPUSH
132831: CALL_OW 297
132835: PUSH
132836: LD_VAR 0 5
132840: LESS
132841: IFFALSE 132785
// end ; ComTurnXY ( unit , x , y ) ;
132843: LD_VAR 0 1
132847: PPUSH
132848: LD_VAR 0 2
132852: PPUSH
132853: LD_VAR 0 3
132857: PPUSH
132858: CALL_OW 118
// wait ( 5 ) ;
132862: LD_INT 5
132864: PPUSH
132865: CALL_OW 67
// _d := GetDir ( unit ) ;
132869: LD_ADDR_VAR 0 10
132873: PUSH
132874: LD_VAR 0 1
132878: PPUSH
132879: CALL_OW 254
132883: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
132884: LD_ADDR_VAR 0 8
132888: PUSH
132889: LD_VAR 0 1
132893: PPUSH
132894: CALL_OW 250
132898: PPUSH
132899: LD_VAR 0 10
132903: PPUSH
132904: LD_VAR 0 5
132908: PPUSH
132909: CALL_OW 272
132913: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
132914: LD_ADDR_VAR 0 9
132918: PUSH
132919: LD_VAR 0 1
132923: PPUSH
132924: CALL_OW 251
132928: PPUSH
132929: LD_VAR 0 10
132933: PPUSH
132934: LD_VAR 0 5
132938: PPUSH
132939: CALL_OW 273
132943: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
132944: LD_VAR 0 8
132948: PPUSH
132949: LD_VAR 0 9
132953: PPUSH
132954: CALL_OW 488
132958: NOT
132959: IFFALSE 132963
// exit ;
132961: GO 133070
// ComAnimCustom ( unit , 1 ) ;
132963: LD_VAR 0 1
132967: PPUSH
132968: LD_INT 1
132970: PPUSH
132971: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
132975: LD_VAR 0 8
132979: PPUSH
132980: LD_VAR 0 9
132984: PPUSH
132985: LD_VAR 0 6
132989: PPUSH
132990: LD_VAR 0 7
132994: PPUSH
132995: CALL_OW 330
// repeat wait ( 1 ) ;
132999: LD_INT 1
133001: PPUSH
133002: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
133006: LD_VAR 0 1
133010: PPUSH
133011: CALL_OW 316
133015: PUSH
133016: LD_VAR 0 1
133020: PPUSH
133021: CALL_OW 314
133025: OR
133026: PUSH
133027: LD_VAR 0 1
133031: PPUSH
133032: CALL_OW 302
133036: NOT
133037: OR
133038: PUSH
133039: LD_VAR 0 1
133043: PPUSH
133044: CALL_OW 301
133048: OR
133049: IFFALSE 132999
// RemoveSeeing ( _x , _y , side ) ;
133051: LD_VAR 0 8
133055: PPUSH
133056: LD_VAR 0 9
133060: PPUSH
133061: LD_VAR 0 6
133065: PPUSH
133066: CALL_OW 331
// end ; end_of_file
133070: LD_VAR 0 4
133074: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
133075: LD_INT 0
133077: PPUSH
133078: PPUSH
133079: PPUSH
133080: PPUSH
133081: PPUSH
133082: PPUSH
133083: PPUSH
133084: PPUSH
133085: PPUSH
133086: PPUSH
133087: PPUSH
133088: PPUSH
133089: PPUSH
133090: PPUSH
133091: PPUSH
133092: PPUSH
133093: PPUSH
133094: PPUSH
133095: PPUSH
133096: PPUSH
133097: PPUSH
133098: PPUSH
133099: PPUSH
133100: PPUSH
133101: PPUSH
133102: PPUSH
133103: PPUSH
133104: PPUSH
133105: PPUSH
133106: PPUSH
133107: PPUSH
133108: PPUSH
133109: PPUSH
133110: PPUSH
// if not list then
133111: LD_VAR 0 1
133115: NOT
133116: IFFALSE 133120
// exit ;
133118: GO 137779
// base := list [ 1 ] ;
133120: LD_ADDR_VAR 0 3
133124: PUSH
133125: LD_VAR 0 1
133129: PUSH
133130: LD_INT 1
133132: ARRAY
133133: ST_TO_ADDR
// group := list [ 2 ] ;
133134: LD_ADDR_VAR 0 4
133138: PUSH
133139: LD_VAR 0 1
133143: PUSH
133144: LD_INT 2
133146: ARRAY
133147: ST_TO_ADDR
// path := list [ 3 ] ;
133148: LD_ADDR_VAR 0 5
133152: PUSH
133153: LD_VAR 0 1
133157: PUSH
133158: LD_INT 3
133160: ARRAY
133161: ST_TO_ADDR
// flags := list [ 4 ] ;
133162: LD_ADDR_VAR 0 6
133166: PUSH
133167: LD_VAR 0 1
133171: PUSH
133172: LD_INT 4
133174: ARRAY
133175: ST_TO_ADDR
// mined := [ ] ;
133176: LD_ADDR_VAR 0 27
133180: PUSH
133181: EMPTY
133182: ST_TO_ADDR
// bombed := [ ] ;
133183: LD_ADDR_VAR 0 28
133187: PUSH
133188: EMPTY
133189: ST_TO_ADDR
// healers := [ ] ;
133190: LD_ADDR_VAR 0 31
133194: PUSH
133195: EMPTY
133196: ST_TO_ADDR
// to_heal := [ ] ;
133197: LD_ADDR_VAR 0 30
133201: PUSH
133202: EMPTY
133203: ST_TO_ADDR
// repairs := [ ] ;
133204: LD_ADDR_VAR 0 33
133208: PUSH
133209: EMPTY
133210: ST_TO_ADDR
// to_repair := [ ] ;
133211: LD_ADDR_VAR 0 32
133215: PUSH
133216: EMPTY
133217: ST_TO_ADDR
// if not group or not path then
133218: LD_VAR 0 4
133222: NOT
133223: PUSH
133224: LD_VAR 0 5
133228: NOT
133229: OR
133230: IFFALSE 133234
// exit ;
133232: GO 137779
// side := GetSide ( group [ 1 ] ) ;
133234: LD_ADDR_VAR 0 35
133238: PUSH
133239: LD_VAR 0 4
133243: PUSH
133244: LD_INT 1
133246: ARRAY
133247: PPUSH
133248: CALL_OW 255
133252: ST_TO_ADDR
// if flags then
133253: LD_VAR 0 6
133257: IFFALSE 133401
// begin f_ignore_area := flags [ 1 ] ;
133259: LD_ADDR_VAR 0 17
133263: PUSH
133264: LD_VAR 0 6
133268: PUSH
133269: LD_INT 1
133271: ARRAY
133272: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
133273: LD_ADDR_VAR 0 18
133277: PUSH
133278: LD_VAR 0 6
133282: PUSH
133283: LD_INT 2
133285: ARRAY
133286: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
133287: LD_ADDR_VAR 0 19
133291: PUSH
133292: LD_VAR 0 6
133296: PUSH
133297: LD_INT 3
133299: ARRAY
133300: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
133301: LD_ADDR_VAR 0 20
133305: PUSH
133306: LD_VAR 0 6
133310: PUSH
133311: LD_INT 4
133313: ARRAY
133314: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
133315: LD_ADDR_VAR 0 21
133319: PUSH
133320: LD_VAR 0 6
133324: PUSH
133325: LD_INT 5
133327: ARRAY
133328: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
133329: LD_ADDR_VAR 0 22
133333: PUSH
133334: LD_VAR 0 6
133338: PUSH
133339: LD_INT 6
133341: ARRAY
133342: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
133343: LD_ADDR_VAR 0 23
133347: PUSH
133348: LD_VAR 0 6
133352: PUSH
133353: LD_INT 7
133355: ARRAY
133356: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
133357: LD_ADDR_VAR 0 24
133361: PUSH
133362: LD_VAR 0 6
133366: PUSH
133367: LD_INT 8
133369: ARRAY
133370: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
133371: LD_ADDR_VAR 0 25
133375: PUSH
133376: LD_VAR 0 6
133380: PUSH
133381: LD_INT 9
133383: ARRAY
133384: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
133385: LD_ADDR_VAR 0 26
133389: PUSH
133390: LD_VAR 0 6
133394: PUSH
133395: LD_INT 10
133397: ARRAY
133398: ST_TO_ADDR
// end else
133399: GO 133481
// begin f_ignore_area := false ;
133401: LD_ADDR_VAR 0 17
133405: PUSH
133406: LD_INT 0
133408: ST_TO_ADDR
// f_capture := false ;
133409: LD_ADDR_VAR 0 18
133413: PUSH
133414: LD_INT 0
133416: ST_TO_ADDR
// f_ignore_civ := false ;
133417: LD_ADDR_VAR 0 19
133421: PUSH
133422: LD_INT 0
133424: ST_TO_ADDR
// f_murder := false ;
133425: LD_ADDR_VAR 0 20
133429: PUSH
133430: LD_INT 0
133432: ST_TO_ADDR
// f_mines := false ;
133433: LD_ADDR_VAR 0 21
133437: PUSH
133438: LD_INT 0
133440: ST_TO_ADDR
// f_repair := false ;
133441: LD_ADDR_VAR 0 22
133445: PUSH
133446: LD_INT 0
133448: ST_TO_ADDR
// f_heal := false ;
133449: LD_ADDR_VAR 0 23
133453: PUSH
133454: LD_INT 0
133456: ST_TO_ADDR
// f_spacetime := false ;
133457: LD_ADDR_VAR 0 24
133461: PUSH
133462: LD_INT 0
133464: ST_TO_ADDR
// f_attack_depot := false ;
133465: LD_ADDR_VAR 0 25
133469: PUSH
133470: LD_INT 0
133472: ST_TO_ADDR
// f_crawl := false ;
133473: LD_ADDR_VAR 0 26
133477: PUSH
133478: LD_INT 0
133480: ST_TO_ADDR
// end ; if f_heal then
133481: LD_VAR 0 23
133485: IFFALSE 133512
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
133487: LD_ADDR_VAR 0 31
133491: PUSH
133492: LD_VAR 0 4
133496: PPUSH
133497: LD_INT 25
133499: PUSH
133500: LD_INT 4
133502: PUSH
133503: EMPTY
133504: LIST
133505: LIST
133506: PPUSH
133507: CALL_OW 72
133511: ST_TO_ADDR
// if f_repair then
133512: LD_VAR 0 22
133516: IFFALSE 133543
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
133518: LD_ADDR_VAR 0 33
133522: PUSH
133523: LD_VAR 0 4
133527: PPUSH
133528: LD_INT 25
133530: PUSH
133531: LD_INT 3
133533: PUSH
133534: EMPTY
133535: LIST
133536: LIST
133537: PPUSH
133538: CALL_OW 72
133542: ST_TO_ADDR
// units_path := [ ] ;
133543: LD_ADDR_VAR 0 16
133547: PUSH
133548: EMPTY
133549: ST_TO_ADDR
// for i = 1 to group do
133550: LD_ADDR_VAR 0 7
133554: PUSH
133555: DOUBLE
133556: LD_INT 1
133558: DEC
133559: ST_TO_ADDR
133560: LD_VAR 0 4
133564: PUSH
133565: FOR_TO
133566: IFFALSE 133595
// units_path := Replace ( units_path , i , path ) ;
133568: LD_ADDR_VAR 0 16
133572: PUSH
133573: LD_VAR 0 16
133577: PPUSH
133578: LD_VAR 0 7
133582: PPUSH
133583: LD_VAR 0 5
133587: PPUSH
133588: CALL_OW 1
133592: ST_TO_ADDR
133593: GO 133565
133595: POP
133596: POP
// repeat for i = group downto 1 do
133597: LD_ADDR_VAR 0 7
133601: PUSH
133602: DOUBLE
133603: LD_VAR 0 4
133607: INC
133608: ST_TO_ADDR
133609: LD_INT 1
133611: PUSH
133612: FOR_DOWNTO
133613: IFFALSE 137735
// begin wait ( 5 ) ;
133615: LD_INT 5
133617: PPUSH
133618: CALL_OW 67
// tmp := [ ] ;
133622: LD_ADDR_VAR 0 14
133626: PUSH
133627: EMPTY
133628: ST_TO_ADDR
// attacking := false ;
133629: LD_ADDR_VAR 0 29
133633: PUSH
133634: LD_INT 0
133636: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
133637: LD_VAR 0 4
133641: PUSH
133642: LD_VAR 0 7
133646: ARRAY
133647: PPUSH
133648: CALL_OW 301
133652: PUSH
133653: LD_VAR 0 4
133657: PUSH
133658: LD_VAR 0 7
133662: ARRAY
133663: NOT
133664: OR
133665: IFFALSE 133774
// begin if GetType ( group [ i ] ) = unit_human then
133667: LD_VAR 0 4
133671: PUSH
133672: LD_VAR 0 7
133676: ARRAY
133677: PPUSH
133678: CALL_OW 247
133682: PUSH
133683: LD_INT 1
133685: EQUAL
133686: IFFALSE 133732
// begin to_heal := to_heal diff group [ i ] ;
133688: LD_ADDR_VAR 0 30
133692: PUSH
133693: LD_VAR 0 30
133697: PUSH
133698: LD_VAR 0 4
133702: PUSH
133703: LD_VAR 0 7
133707: ARRAY
133708: DIFF
133709: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133710: LD_ADDR_VAR 0 31
133714: PUSH
133715: LD_VAR 0 31
133719: PUSH
133720: LD_VAR 0 4
133724: PUSH
133725: LD_VAR 0 7
133729: ARRAY
133730: DIFF
133731: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133732: LD_ADDR_VAR 0 4
133736: PUSH
133737: LD_VAR 0 4
133741: PPUSH
133742: LD_VAR 0 7
133746: PPUSH
133747: CALL_OW 3
133751: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133752: LD_ADDR_VAR 0 16
133756: PUSH
133757: LD_VAR 0 16
133761: PPUSH
133762: LD_VAR 0 7
133766: PPUSH
133767: CALL_OW 3
133771: ST_TO_ADDR
// continue ;
133772: GO 133612
// end ; if f_repair then
133774: LD_VAR 0 22
133778: IFFALSE 134267
// begin if GetType ( group [ i ] ) = unit_vehicle then
133780: LD_VAR 0 4
133784: PUSH
133785: LD_VAR 0 7
133789: ARRAY
133790: PPUSH
133791: CALL_OW 247
133795: PUSH
133796: LD_INT 2
133798: EQUAL
133799: IFFALSE 133989
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133801: LD_VAR 0 4
133805: PUSH
133806: LD_VAR 0 7
133810: ARRAY
133811: PPUSH
133812: CALL_OW 256
133816: PUSH
133817: LD_INT 700
133819: LESS
133820: PUSH
133821: LD_VAR 0 4
133825: PUSH
133826: LD_VAR 0 7
133830: ARRAY
133831: PUSH
133832: LD_VAR 0 32
133836: IN
133837: NOT
133838: AND
133839: IFFALSE 133863
// to_repair := to_repair union group [ i ] ;
133841: LD_ADDR_VAR 0 32
133845: PUSH
133846: LD_VAR 0 32
133850: PUSH
133851: LD_VAR 0 4
133855: PUSH
133856: LD_VAR 0 7
133860: ARRAY
133861: UNION
133862: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133863: LD_VAR 0 4
133867: PUSH
133868: LD_VAR 0 7
133872: ARRAY
133873: PPUSH
133874: CALL_OW 256
133878: PUSH
133879: LD_INT 1000
133881: EQUAL
133882: PUSH
133883: LD_VAR 0 4
133887: PUSH
133888: LD_VAR 0 7
133892: ARRAY
133893: PUSH
133894: LD_VAR 0 32
133898: IN
133899: AND
133900: IFFALSE 133924
// to_repair := to_repair diff group [ i ] ;
133902: LD_ADDR_VAR 0 32
133906: PUSH
133907: LD_VAR 0 32
133911: PUSH
133912: LD_VAR 0 4
133916: PUSH
133917: LD_VAR 0 7
133921: ARRAY
133922: DIFF
133923: ST_TO_ADDR
// if group [ i ] in to_repair then
133924: LD_VAR 0 4
133928: PUSH
133929: LD_VAR 0 7
133933: ARRAY
133934: PUSH
133935: LD_VAR 0 32
133939: IN
133940: IFFALSE 133987
// begin if not IsInArea ( group [ i ] , f_repair ) then
133942: LD_VAR 0 4
133946: PUSH
133947: LD_VAR 0 7
133951: ARRAY
133952: PPUSH
133953: LD_VAR 0 22
133957: PPUSH
133958: CALL_OW 308
133962: NOT
133963: IFFALSE 133985
// ComMoveToArea ( group [ i ] , f_repair ) ;
133965: LD_VAR 0 4
133969: PUSH
133970: LD_VAR 0 7
133974: ARRAY
133975: PPUSH
133976: LD_VAR 0 22
133980: PPUSH
133981: CALL_OW 113
// continue ;
133985: GO 133612
// end ; end else
133987: GO 134267
// if group [ i ] in repairs then
133989: LD_VAR 0 4
133993: PUSH
133994: LD_VAR 0 7
133998: ARRAY
133999: PUSH
134000: LD_VAR 0 33
134004: IN
134005: IFFALSE 134267
// begin if IsInUnit ( group [ i ] ) then
134007: LD_VAR 0 4
134011: PUSH
134012: LD_VAR 0 7
134016: ARRAY
134017: PPUSH
134018: CALL_OW 310
134022: IFFALSE 134090
// begin z := IsInUnit ( group [ i ] ) ;
134024: LD_ADDR_VAR 0 13
134028: PUSH
134029: LD_VAR 0 4
134033: PUSH
134034: LD_VAR 0 7
134038: ARRAY
134039: PPUSH
134040: CALL_OW 310
134044: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
134045: LD_VAR 0 13
134049: PUSH
134050: LD_VAR 0 32
134054: IN
134055: PUSH
134056: LD_VAR 0 13
134060: PPUSH
134061: LD_VAR 0 22
134065: PPUSH
134066: CALL_OW 308
134070: AND
134071: IFFALSE 134088
// ComExitVehicle ( group [ i ] ) ;
134073: LD_VAR 0 4
134077: PUSH
134078: LD_VAR 0 7
134082: ARRAY
134083: PPUSH
134084: CALL_OW 121
// end else
134088: GO 134267
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
134090: LD_ADDR_VAR 0 13
134094: PUSH
134095: LD_VAR 0 4
134099: PPUSH
134100: LD_INT 95
134102: PUSH
134103: LD_VAR 0 22
134107: PUSH
134108: EMPTY
134109: LIST
134110: LIST
134111: PUSH
134112: LD_INT 58
134114: PUSH
134115: EMPTY
134116: LIST
134117: PUSH
134118: EMPTY
134119: LIST
134120: LIST
134121: PPUSH
134122: CALL_OW 72
134126: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
134127: LD_VAR 0 4
134131: PUSH
134132: LD_VAR 0 7
134136: ARRAY
134137: PPUSH
134138: CALL_OW 314
134142: NOT
134143: IFFALSE 134265
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
134145: LD_ADDR_VAR 0 10
134149: PUSH
134150: LD_VAR 0 13
134154: PPUSH
134155: LD_VAR 0 4
134159: PUSH
134160: LD_VAR 0 7
134164: ARRAY
134165: PPUSH
134166: CALL_OW 74
134170: ST_TO_ADDR
// if not x then
134171: LD_VAR 0 10
134175: NOT
134176: IFFALSE 134180
// continue ;
134178: GO 133612
// if GetLives ( x ) < 1000 then
134180: LD_VAR 0 10
134184: PPUSH
134185: CALL_OW 256
134189: PUSH
134190: LD_INT 1000
134192: LESS
134193: IFFALSE 134217
// ComRepairVehicle ( group [ i ] , x ) else
134195: LD_VAR 0 4
134199: PUSH
134200: LD_VAR 0 7
134204: ARRAY
134205: PPUSH
134206: LD_VAR 0 10
134210: PPUSH
134211: CALL_OW 129
134215: GO 134265
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
134217: LD_VAR 0 23
134221: PUSH
134222: LD_VAR 0 4
134226: PUSH
134227: LD_VAR 0 7
134231: ARRAY
134232: PPUSH
134233: CALL_OW 256
134237: PUSH
134238: LD_INT 1000
134240: LESS
134241: AND
134242: NOT
134243: IFFALSE 134265
// ComEnterUnit ( group [ i ] , x ) ;
134245: LD_VAR 0 4
134249: PUSH
134250: LD_VAR 0 7
134254: ARRAY
134255: PPUSH
134256: LD_VAR 0 10
134260: PPUSH
134261: CALL_OW 120
// end ; continue ;
134265: GO 133612
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
134267: LD_VAR 0 23
134271: PUSH
134272: LD_VAR 0 4
134276: PUSH
134277: LD_VAR 0 7
134281: ARRAY
134282: PPUSH
134283: CALL_OW 247
134287: PUSH
134288: LD_INT 1
134290: EQUAL
134291: AND
134292: IFFALSE 134770
// begin if group [ i ] in healers then
134294: LD_VAR 0 4
134298: PUSH
134299: LD_VAR 0 7
134303: ARRAY
134304: PUSH
134305: LD_VAR 0 31
134309: IN
134310: IFFALSE 134583
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
134312: LD_VAR 0 4
134316: PUSH
134317: LD_VAR 0 7
134321: ARRAY
134322: PPUSH
134323: LD_VAR 0 23
134327: PPUSH
134328: CALL_OW 308
134332: NOT
134333: PUSH
134334: LD_VAR 0 4
134338: PUSH
134339: LD_VAR 0 7
134343: ARRAY
134344: PPUSH
134345: CALL_OW 314
134349: NOT
134350: AND
134351: IFFALSE 134375
// ComMoveToArea ( group [ i ] , f_heal ) else
134353: LD_VAR 0 4
134357: PUSH
134358: LD_VAR 0 7
134362: ARRAY
134363: PPUSH
134364: LD_VAR 0 23
134368: PPUSH
134369: CALL_OW 113
134373: GO 134581
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
134375: LD_VAR 0 4
134379: PUSH
134380: LD_VAR 0 7
134384: ARRAY
134385: PPUSH
134386: CALL 104662 0 1
134390: PPUSH
134391: CALL_OW 256
134395: PUSH
134396: LD_INT 1000
134398: EQUAL
134399: IFFALSE 134418
// ComStop ( group [ i ] ) else
134401: LD_VAR 0 4
134405: PUSH
134406: LD_VAR 0 7
134410: ARRAY
134411: PPUSH
134412: CALL_OW 141
134416: GO 134581
// if not HasTask ( group [ i ] ) and to_heal then
134418: LD_VAR 0 4
134422: PUSH
134423: LD_VAR 0 7
134427: ARRAY
134428: PPUSH
134429: CALL_OW 314
134433: NOT
134434: PUSH
134435: LD_VAR 0 30
134439: AND
134440: IFFALSE 134581
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
134442: LD_ADDR_VAR 0 13
134446: PUSH
134447: LD_VAR 0 30
134451: PPUSH
134452: LD_INT 3
134454: PUSH
134455: LD_INT 54
134457: PUSH
134458: EMPTY
134459: LIST
134460: PUSH
134461: EMPTY
134462: LIST
134463: LIST
134464: PPUSH
134465: CALL_OW 72
134469: PPUSH
134470: LD_VAR 0 4
134474: PUSH
134475: LD_VAR 0 7
134479: ARRAY
134480: PPUSH
134481: CALL_OW 74
134485: ST_TO_ADDR
// if z then
134486: LD_VAR 0 13
134490: IFFALSE 134581
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
134492: LD_INT 91
134494: PUSH
134495: LD_VAR 0 13
134499: PUSH
134500: LD_INT 10
134502: PUSH
134503: EMPTY
134504: LIST
134505: LIST
134506: LIST
134507: PUSH
134508: LD_INT 81
134510: PUSH
134511: LD_VAR 0 13
134515: PPUSH
134516: CALL_OW 255
134520: PUSH
134521: EMPTY
134522: LIST
134523: LIST
134524: PUSH
134525: EMPTY
134526: LIST
134527: LIST
134528: PPUSH
134529: CALL_OW 69
134533: PUSH
134534: LD_INT 0
134536: EQUAL
134537: IFFALSE 134561
// ComHeal ( group [ i ] , z ) else
134539: LD_VAR 0 4
134543: PUSH
134544: LD_VAR 0 7
134548: ARRAY
134549: PPUSH
134550: LD_VAR 0 13
134554: PPUSH
134555: CALL_OW 128
134559: GO 134581
// ComMoveToArea ( group [ i ] , f_heal ) ;
134561: LD_VAR 0 4
134565: PUSH
134566: LD_VAR 0 7
134570: ARRAY
134571: PPUSH
134572: LD_VAR 0 23
134576: PPUSH
134577: CALL_OW 113
// end ; continue ;
134581: GO 133612
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
134583: LD_VAR 0 4
134587: PUSH
134588: LD_VAR 0 7
134592: ARRAY
134593: PPUSH
134594: CALL_OW 256
134598: PUSH
134599: LD_INT 700
134601: LESS
134602: PUSH
134603: LD_VAR 0 4
134607: PUSH
134608: LD_VAR 0 7
134612: ARRAY
134613: PUSH
134614: LD_VAR 0 30
134618: IN
134619: NOT
134620: AND
134621: IFFALSE 134645
// to_heal := to_heal union group [ i ] ;
134623: LD_ADDR_VAR 0 30
134627: PUSH
134628: LD_VAR 0 30
134632: PUSH
134633: LD_VAR 0 4
134637: PUSH
134638: LD_VAR 0 7
134642: ARRAY
134643: UNION
134644: ST_TO_ADDR
// if group [ i ] in to_heal then
134645: LD_VAR 0 4
134649: PUSH
134650: LD_VAR 0 7
134654: ARRAY
134655: PUSH
134656: LD_VAR 0 30
134660: IN
134661: IFFALSE 134770
// begin if GetLives ( group [ i ] ) = 1000 then
134663: LD_VAR 0 4
134667: PUSH
134668: LD_VAR 0 7
134672: ARRAY
134673: PPUSH
134674: CALL_OW 256
134678: PUSH
134679: LD_INT 1000
134681: EQUAL
134682: IFFALSE 134708
// to_heal := to_heal diff group [ i ] else
134684: LD_ADDR_VAR 0 30
134688: PUSH
134689: LD_VAR 0 30
134693: PUSH
134694: LD_VAR 0 4
134698: PUSH
134699: LD_VAR 0 7
134703: ARRAY
134704: DIFF
134705: ST_TO_ADDR
134706: GO 134770
// begin if not IsInArea ( group [ i ] , to_heal ) then
134708: LD_VAR 0 4
134712: PUSH
134713: LD_VAR 0 7
134717: ARRAY
134718: PPUSH
134719: LD_VAR 0 30
134723: PPUSH
134724: CALL_OW 308
134728: NOT
134729: IFFALSE 134753
// ComMoveToArea ( group [ i ] , f_heal ) else
134731: LD_VAR 0 4
134735: PUSH
134736: LD_VAR 0 7
134740: ARRAY
134741: PPUSH
134742: LD_VAR 0 23
134746: PPUSH
134747: CALL_OW 113
134751: GO 134768
// ComHold ( group [ i ] ) ;
134753: LD_VAR 0 4
134757: PUSH
134758: LD_VAR 0 7
134762: ARRAY
134763: PPUSH
134764: CALL_OW 140
// continue ;
134768: GO 133612
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134770: LD_VAR 0 4
134774: PUSH
134775: LD_VAR 0 7
134779: ARRAY
134780: PPUSH
134781: LD_INT 10
134783: PPUSH
134784: CALL 102444 0 2
134788: NOT
134789: PUSH
134790: LD_VAR 0 16
134794: PUSH
134795: LD_VAR 0 7
134799: ARRAY
134800: PUSH
134801: EMPTY
134802: EQUAL
134803: NOT
134804: AND
134805: IFFALSE 135071
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134807: LD_VAR 0 4
134811: PUSH
134812: LD_VAR 0 7
134816: ARRAY
134817: PPUSH
134818: CALL_OW 262
134822: PUSH
134823: LD_INT 1
134825: PUSH
134826: LD_INT 2
134828: PUSH
134829: EMPTY
134830: LIST
134831: LIST
134832: IN
134833: IFFALSE 134874
// if GetFuel ( group [ i ] ) < 10 then
134835: LD_VAR 0 4
134839: PUSH
134840: LD_VAR 0 7
134844: ARRAY
134845: PPUSH
134846: CALL_OW 261
134850: PUSH
134851: LD_INT 10
134853: LESS
134854: IFFALSE 134874
// SetFuel ( group [ i ] , 12 ) ;
134856: LD_VAR 0 4
134860: PUSH
134861: LD_VAR 0 7
134865: ARRAY
134866: PPUSH
134867: LD_INT 12
134869: PPUSH
134870: CALL_OW 240
// if units_path [ i ] then
134874: LD_VAR 0 16
134878: PUSH
134879: LD_VAR 0 7
134883: ARRAY
134884: IFFALSE 135069
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
134886: LD_VAR 0 4
134890: PUSH
134891: LD_VAR 0 7
134895: ARRAY
134896: PPUSH
134897: LD_VAR 0 16
134901: PUSH
134902: LD_VAR 0 7
134906: ARRAY
134907: PUSH
134908: LD_INT 1
134910: ARRAY
134911: PUSH
134912: LD_INT 1
134914: ARRAY
134915: PPUSH
134916: LD_VAR 0 16
134920: PUSH
134921: LD_VAR 0 7
134925: ARRAY
134926: PUSH
134927: LD_INT 1
134929: ARRAY
134930: PUSH
134931: LD_INT 2
134933: ARRAY
134934: PPUSH
134935: CALL_OW 297
134939: PUSH
134940: LD_INT 6
134942: GREATER
134943: IFFALSE 135018
// begin if not HasTask ( group [ i ] ) then
134945: LD_VAR 0 4
134949: PUSH
134950: LD_VAR 0 7
134954: ARRAY
134955: PPUSH
134956: CALL_OW 314
134960: NOT
134961: IFFALSE 135016
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
134963: LD_VAR 0 4
134967: PUSH
134968: LD_VAR 0 7
134972: ARRAY
134973: PPUSH
134974: LD_VAR 0 16
134978: PUSH
134979: LD_VAR 0 7
134983: ARRAY
134984: PUSH
134985: LD_INT 1
134987: ARRAY
134988: PUSH
134989: LD_INT 1
134991: ARRAY
134992: PPUSH
134993: LD_VAR 0 16
134997: PUSH
134998: LD_VAR 0 7
135002: ARRAY
135003: PUSH
135004: LD_INT 1
135006: ARRAY
135007: PUSH
135008: LD_INT 2
135010: ARRAY
135011: PPUSH
135012: CALL_OW 114
// end else
135016: GO 135069
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
135018: LD_ADDR_VAR 0 15
135022: PUSH
135023: LD_VAR 0 16
135027: PUSH
135028: LD_VAR 0 7
135032: ARRAY
135033: PPUSH
135034: LD_INT 1
135036: PPUSH
135037: CALL_OW 3
135041: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
135042: LD_ADDR_VAR 0 16
135046: PUSH
135047: LD_VAR 0 16
135051: PPUSH
135052: LD_VAR 0 7
135056: PPUSH
135057: LD_VAR 0 15
135061: PPUSH
135062: CALL_OW 1
135066: ST_TO_ADDR
// continue ;
135067: GO 133612
// end ; end ; end else
135069: GO 137733
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
135071: LD_ADDR_VAR 0 14
135075: PUSH
135076: LD_INT 81
135078: PUSH
135079: LD_VAR 0 4
135083: PUSH
135084: LD_VAR 0 7
135088: ARRAY
135089: PPUSH
135090: CALL_OW 255
135094: PUSH
135095: EMPTY
135096: LIST
135097: LIST
135098: PPUSH
135099: CALL_OW 69
135103: ST_TO_ADDR
// if not tmp then
135104: LD_VAR 0 14
135108: NOT
135109: IFFALSE 135113
// continue ;
135111: GO 133612
// if f_ignore_area then
135113: LD_VAR 0 17
135117: IFFALSE 135205
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
135119: LD_ADDR_VAR 0 15
135123: PUSH
135124: LD_VAR 0 14
135128: PPUSH
135129: LD_INT 3
135131: PUSH
135132: LD_INT 92
135134: PUSH
135135: LD_VAR 0 17
135139: PUSH
135140: LD_INT 1
135142: ARRAY
135143: PUSH
135144: LD_VAR 0 17
135148: PUSH
135149: LD_INT 2
135151: ARRAY
135152: PUSH
135153: LD_VAR 0 17
135157: PUSH
135158: LD_INT 3
135160: ARRAY
135161: PUSH
135162: EMPTY
135163: LIST
135164: LIST
135165: LIST
135166: LIST
135167: PUSH
135168: EMPTY
135169: LIST
135170: LIST
135171: PPUSH
135172: CALL_OW 72
135176: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135177: LD_VAR 0 14
135181: PUSH
135182: LD_VAR 0 15
135186: DIFF
135187: IFFALSE 135205
// tmp := tmp diff tmp2 ;
135189: LD_ADDR_VAR 0 14
135193: PUSH
135194: LD_VAR 0 14
135198: PUSH
135199: LD_VAR 0 15
135203: DIFF
135204: ST_TO_ADDR
// end ; if not f_murder then
135205: LD_VAR 0 20
135209: NOT
135210: IFFALSE 135268
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
135212: LD_ADDR_VAR 0 15
135216: PUSH
135217: LD_VAR 0 14
135221: PPUSH
135222: LD_INT 3
135224: PUSH
135225: LD_INT 50
135227: PUSH
135228: EMPTY
135229: LIST
135230: PUSH
135231: EMPTY
135232: LIST
135233: LIST
135234: PPUSH
135235: CALL_OW 72
135239: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135240: LD_VAR 0 14
135244: PUSH
135245: LD_VAR 0 15
135249: DIFF
135250: IFFALSE 135268
// tmp := tmp diff tmp2 ;
135252: LD_ADDR_VAR 0 14
135256: PUSH
135257: LD_VAR 0 14
135261: PUSH
135262: LD_VAR 0 15
135266: DIFF
135267: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
135268: LD_ADDR_VAR 0 14
135272: PUSH
135273: LD_VAR 0 4
135277: PUSH
135278: LD_VAR 0 7
135282: ARRAY
135283: PPUSH
135284: LD_VAR 0 14
135288: PPUSH
135289: LD_INT 1
135291: PPUSH
135292: LD_INT 1
135294: PPUSH
135295: CALL 74988 0 4
135299: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
135300: LD_VAR 0 4
135304: PUSH
135305: LD_VAR 0 7
135309: ARRAY
135310: PPUSH
135311: CALL_OW 257
135315: PUSH
135316: LD_INT 1
135318: EQUAL
135319: IFFALSE 135767
// begin if WantPlant ( group [ i ] ) then
135321: LD_VAR 0 4
135325: PUSH
135326: LD_VAR 0 7
135330: ARRAY
135331: PPUSH
135332: CALL 74489 0 1
135336: IFFALSE 135340
// continue ;
135338: GO 133612
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
135340: LD_VAR 0 18
135344: PUSH
135345: LD_VAR 0 4
135349: PUSH
135350: LD_VAR 0 7
135354: ARRAY
135355: PPUSH
135356: CALL_OW 310
135360: NOT
135361: AND
135362: PUSH
135363: LD_VAR 0 14
135367: PUSH
135368: LD_INT 1
135370: ARRAY
135371: PUSH
135372: LD_VAR 0 14
135376: PPUSH
135377: LD_INT 21
135379: PUSH
135380: LD_INT 2
135382: PUSH
135383: EMPTY
135384: LIST
135385: LIST
135386: PUSH
135387: LD_INT 58
135389: PUSH
135390: EMPTY
135391: LIST
135392: PUSH
135393: EMPTY
135394: LIST
135395: LIST
135396: PPUSH
135397: CALL_OW 72
135401: IN
135402: AND
135403: IFFALSE 135439
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
135405: LD_VAR 0 4
135409: PUSH
135410: LD_VAR 0 7
135414: ARRAY
135415: PPUSH
135416: LD_VAR 0 14
135420: PUSH
135421: LD_INT 1
135423: ARRAY
135424: PPUSH
135425: CALL_OW 120
// attacking := true ;
135429: LD_ADDR_VAR 0 29
135433: PUSH
135434: LD_INT 1
135436: ST_TO_ADDR
// continue ;
135437: GO 133612
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
135439: LD_VAR 0 26
135443: PUSH
135444: LD_VAR 0 4
135448: PUSH
135449: LD_VAR 0 7
135453: ARRAY
135454: PPUSH
135455: CALL_OW 257
135459: PUSH
135460: LD_INT 1
135462: EQUAL
135463: AND
135464: PUSH
135465: LD_VAR 0 4
135469: PUSH
135470: LD_VAR 0 7
135474: ARRAY
135475: PPUSH
135476: CALL_OW 256
135480: PUSH
135481: LD_INT 800
135483: LESS
135484: AND
135485: PUSH
135486: LD_VAR 0 4
135490: PUSH
135491: LD_VAR 0 7
135495: ARRAY
135496: PPUSH
135497: CALL_OW 318
135501: NOT
135502: AND
135503: IFFALSE 135520
// ComCrawl ( group [ i ] ) ;
135505: LD_VAR 0 4
135509: PUSH
135510: LD_VAR 0 7
135514: ARRAY
135515: PPUSH
135516: CALL_OW 137
// if f_mines then
135520: LD_VAR 0 21
135524: IFFALSE 135767
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
135526: LD_VAR 0 14
135530: PUSH
135531: LD_INT 1
135533: ARRAY
135534: PPUSH
135535: CALL_OW 247
135539: PUSH
135540: LD_INT 3
135542: EQUAL
135543: PUSH
135544: LD_VAR 0 14
135548: PUSH
135549: LD_INT 1
135551: ARRAY
135552: PUSH
135553: LD_VAR 0 27
135557: IN
135558: NOT
135559: AND
135560: IFFALSE 135767
// begin x := GetX ( tmp [ 1 ] ) ;
135562: LD_ADDR_VAR 0 10
135566: PUSH
135567: LD_VAR 0 14
135571: PUSH
135572: LD_INT 1
135574: ARRAY
135575: PPUSH
135576: CALL_OW 250
135580: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
135581: LD_ADDR_VAR 0 11
135585: PUSH
135586: LD_VAR 0 14
135590: PUSH
135591: LD_INT 1
135593: ARRAY
135594: PPUSH
135595: CALL_OW 251
135599: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
135600: LD_ADDR_VAR 0 12
135604: PUSH
135605: LD_VAR 0 4
135609: PUSH
135610: LD_VAR 0 7
135614: ARRAY
135615: PPUSH
135616: CALL 102529 0 1
135620: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
135621: LD_VAR 0 4
135625: PUSH
135626: LD_VAR 0 7
135630: ARRAY
135631: PPUSH
135632: LD_VAR 0 10
135636: PPUSH
135637: LD_VAR 0 11
135641: PPUSH
135642: LD_VAR 0 14
135646: PUSH
135647: LD_INT 1
135649: ARRAY
135650: PPUSH
135651: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
135655: LD_VAR 0 4
135659: PUSH
135660: LD_VAR 0 7
135664: ARRAY
135665: PPUSH
135666: LD_VAR 0 10
135670: PPUSH
135671: LD_VAR 0 12
135675: PPUSH
135676: LD_INT 7
135678: PPUSH
135679: CALL_OW 272
135683: PPUSH
135684: LD_VAR 0 11
135688: PPUSH
135689: LD_VAR 0 12
135693: PPUSH
135694: LD_INT 7
135696: PPUSH
135697: CALL_OW 273
135701: PPUSH
135702: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135706: LD_VAR 0 4
135710: PUSH
135711: LD_VAR 0 7
135715: ARRAY
135716: PPUSH
135717: LD_INT 71
135719: PPUSH
135720: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135724: LD_ADDR_VAR 0 27
135728: PUSH
135729: LD_VAR 0 27
135733: PPUSH
135734: LD_VAR 0 27
135738: PUSH
135739: LD_INT 1
135741: PLUS
135742: PPUSH
135743: LD_VAR 0 14
135747: PUSH
135748: LD_INT 1
135750: ARRAY
135751: PPUSH
135752: CALL_OW 1
135756: ST_TO_ADDR
// attacking := true ;
135757: LD_ADDR_VAR 0 29
135761: PUSH
135762: LD_INT 1
135764: ST_TO_ADDR
// continue ;
135765: GO 133612
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135767: LD_VAR 0 4
135771: PUSH
135772: LD_VAR 0 7
135776: ARRAY
135777: PPUSH
135778: CALL_OW 257
135782: PUSH
135783: LD_INT 17
135785: EQUAL
135786: PUSH
135787: LD_VAR 0 4
135791: PUSH
135792: LD_VAR 0 7
135796: ARRAY
135797: PPUSH
135798: CALL_OW 110
135802: PUSH
135803: LD_INT 71
135805: EQUAL
135806: NOT
135807: AND
135808: IFFALSE 135954
// begin attacking := false ;
135810: LD_ADDR_VAR 0 29
135814: PUSH
135815: LD_INT 0
135817: ST_TO_ADDR
// k := 5 ;
135818: LD_ADDR_VAR 0 9
135822: PUSH
135823: LD_INT 5
135825: ST_TO_ADDR
// if tmp < k then
135826: LD_VAR 0 14
135830: PUSH
135831: LD_VAR 0 9
135835: LESS
135836: IFFALSE 135848
// k := tmp ;
135838: LD_ADDR_VAR 0 9
135842: PUSH
135843: LD_VAR 0 14
135847: ST_TO_ADDR
// for j = 1 to k do
135848: LD_ADDR_VAR 0 8
135852: PUSH
135853: DOUBLE
135854: LD_INT 1
135856: DEC
135857: ST_TO_ADDR
135858: LD_VAR 0 9
135862: PUSH
135863: FOR_TO
135864: IFFALSE 135952
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135866: LD_VAR 0 14
135870: PUSH
135871: LD_VAR 0 8
135875: ARRAY
135876: PUSH
135877: LD_VAR 0 14
135881: PPUSH
135882: LD_INT 58
135884: PUSH
135885: EMPTY
135886: LIST
135887: PPUSH
135888: CALL_OW 72
135892: IN
135893: NOT
135894: IFFALSE 135950
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135896: LD_VAR 0 4
135900: PUSH
135901: LD_VAR 0 7
135905: ARRAY
135906: PPUSH
135907: LD_VAR 0 14
135911: PUSH
135912: LD_VAR 0 8
135916: ARRAY
135917: PPUSH
135918: CALL_OW 115
// attacking := true ;
135922: LD_ADDR_VAR 0 29
135926: PUSH
135927: LD_INT 1
135929: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
135930: LD_VAR 0 4
135934: PUSH
135935: LD_VAR 0 7
135939: ARRAY
135940: PPUSH
135941: LD_INT 71
135943: PPUSH
135944: CALL_OW 109
// continue ;
135948: GO 135863
// end ; end ;
135950: GO 135863
135952: POP
135953: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
135954: LD_VAR 0 4
135958: PUSH
135959: LD_VAR 0 7
135963: ARRAY
135964: PPUSH
135965: CALL_OW 257
135969: PUSH
135970: LD_INT 8
135972: EQUAL
135973: PUSH
135974: LD_VAR 0 4
135978: PUSH
135979: LD_VAR 0 7
135983: ARRAY
135984: PPUSH
135985: CALL_OW 264
135989: PUSH
135990: LD_INT 28
135992: PUSH
135993: LD_INT 45
135995: PUSH
135996: LD_INT 7
135998: PUSH
135999: LD_INT 47
136001: PUSH
136002: EMPTY
136003: LIST
136004: LIST
136005: LIST
136006: LIST
136007: IN
136008: OR
136009: IFFALSE 136265
// begin attacking := false ;
136011: LD_ADDR_VAR 0 29
136015: PUSH
136016: LD_INT 0
136018: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
136019: LD_VAR 0 14
136023: PUSH
136024: LD_INT 1
136026: ARRAY
136027: PPUSH
136028: CALL_OW 266
136032: PUSH
136033: LD_INT 32
136035: PUSH
136036: LD_INT 31
136038: PUSH
136039: LD_INT 33
136041: PUSH
136042: LD_INT 4
136044: PUSH
136045: LD_INT 5
136047: PUSH
136048: EMPTY
136049: LIST
136050: LIST
136051: LIST
136052: LIST
136053: LIST
136054: IN
136055: IFFALSE 136241
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
136057: LD_ADDR_VAR 0 9
136061: PUSH
136062: LD_VAR 0 14
136066: PUSH
136067: LD_INT 1
136069: ARRAY
136070: PPUSH
136071: CALL_OW 266
136075: PPUSH
136076: LD_VAR 0 14
136080: PUSH
136081: LD_INT 1
136083: ARRAY
136084: PPUSH
136085: CALL_OW 250
136089: PPUSH
136090: LD_VAR 0 14
136094: PUSH
136095: LD_INT 1
136097: ARRAY
136098: PPUSH
136099: CALL_OW 251
136103: PPUSH
136104: LD_VAR 0 14
136108: PUSH
136109: LD_INT 1
136111: ARRAY
136112: PPUSH
136113: CALL_OW 254
136117: PPUSH
136118: LD_VAR 0 14
136122: PUSH
136123: LD_INT 1
136125: ARRAY
136126: PPUSH
136127: CALL_OW 248
136131: PPUSH
136132: LD_INT 0
136134: PPUSH
136135: CALL 83899 0 6
136139: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
136140: LD_ADDR_VAR 0 8
136144: PUSH
136145: LD_VAR 0 4
136149: PUSH
136150: LD_VAR 0 7
136154: ARRAY
136155: PPUSH
136156: LD_VAR 0 9
136160: PPUSH
136161: CALL 102642 0 2
136165: ST_TO_ADDR
// if j then
136166: LD_VAR 0 8
136170: IFFALSE 136239
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
136172: LD_VAR 0 8
136176: PUSH
136177: LD_INT 1
136179: ARRAY
136180: PPUSH
136181: LD_VAR 0 8
136185: PUSH
136186: LD_INT 2
136188: ARRAY
136189: PPUSH
136190: CALL_OW 488
136194: IFFALSE 136239
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
136196: LD_VAR 0 4
136200: PUSH
136201: LD_VAR 0 7
136205: ARRAY
136206: PPUSH
136207: LD_VAR 0 8
136211: PUSH
136212: LD_INT 1
136214: ARRAY
136215: PPUSH
136216: LD_VAR 0 8
136220: PUSH
136221: LD_INT 2
136223: ARRAY
136224: PPUSH
136225: CALL_OW 116
// attacking := true ;
136229: LD_ADDR_VAR 0 29
136233: PUSH
136234: LD_INT 1
136236: ST_TO_ADDR
// continue ;
136237: GO 133612
// end ; end else
136239: GO 136265
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136241: LD_VAR 0 4
136245: PUSH
136246: LD_VAR 0 7
136250: ARRAY
136251: PPUSH
136252: LD_VAR 0 14
136256: PUSH
136257: LD_INT 1
136259: ARRAY
136260: PPUSH
136261: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
136265: LD_VAR 0 4
136269: PUSH
136270: LD_VAR 0 7
136274: ARRAY
136275: PPUSH
136276: CALL_OW 265
136280: PUSH
136281: LD_INT 11
136283: EQUAL
136284: IFFALSE 136562
// begin k := 10 ;
136286: LD_ADDR_VAR 0 9
136290: PUSH
136291: LD_INT 10
136293: ST_TO_ADDR
// x := 0 ;
136294: LD_ADDR_VAR 0 10
136298: PUSH
136299: LD_INT 0
136301: ST_TO_ADDR
// if tmp < k then
136302: LD_VAR 0 14
136306: PUSH
136307: LD_VAR 0 9
136311: LESS
136312: IFFALSE 136324
// k := tmp ;
136314: LD_ADDR_VAR 0 9
136318: PUSH
136319: LD_VAR 0 14
136323: ST_TO_ADDR
// for j = k downto 1 do
136324: LD_ADDR_VAR 0 8
136328: PUSH
136329: DOUBLE
136330: LD_VAR 0 9
136334: INC
136335: ST_TO_ADDR
136336: LD_INT 1
136338: PUSH
136339: FOR_DOWNTO
136340: IFFALSE 136415
// begin if GetType ( tmp [ j ] ) = unit_human then
136342: LD_VAR 0 14
136346: PUSH
136347: LD_VAR 0 8
136351: ARRAY
136352: PPUSH
136353: CALL_OW 247
136357: PUSH
136358: LD_INT 1
136360: EQUAL
136361: IFFALSE 136413
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
136363: LD_VAR 0 4
136367: PUSH
136368: LD_VAR 0 7
136372: ARRAY
136373: PPUSH
136374: LD_VAR 0 14
136378: PUSH
136379: LD_VAR 0 8
136383: ARRAY
136384: PPUSH
136385: CALL 102896 0 2
// x := tmp [ j ] ;
136389: LD_ADDR_VAR 0 10
136393: PUSH
136394: LD_VAR 0 14
136398: PUSH
136399: LD_VAR 0 8
136403: ARRAY
136404: ST_TO_ADDR
// attacking := true ;
136405: LD_ADDR_VAR 0 29
136409: PUSH
136410: LD_INT 1
136412: ST_TO_ADDR
// end ; end ;
136413: GO 136339
136415: POP
136416: POP
// if not x then
136417: LD_VAR 0 10
136421: NOT
136422: IFFALSE 136562
// begin attacking := true ;
136424: LD_ADDR_VAR 0 29
136428: PUSH
136429: LD_INT 1
136431: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
136432: LD_VAR 0 4
136436: PUSH
136437: LD_VAR 0 7
136441: ARRAY
136442: PPUSH
136443: CALL_OW 250
136447: PPUSH
136448: LD_VAR 0 4
136452: PUSH
136453: LD_VAR 0 7
136457: ARRAY
136458: PPUSH
136459: CALL_OW 251
136463: PPUSH
136464: CALL_OW 546
136468: PUSH
136469: LD_INT 2
136471: ARRAY
136472: PUSH
136473: LD_VAR 0 14
136477: PUSH
136478: LD_INT 1
136480: ARRAY
136481: PPUSH
136482: CALL_OW 250
136486: PPUSH
136487: LD_VAR 0 14
136491: PUSH
136492: LD_INT 1
136494: ARRAY
136495: PPUSH
136496: CALL_OW 251
136500: PPUSH
136501: CALL_OW 546
136505: PUSH
136506: LD_INT 2
136508: ARRAY
136509: EQUAL
136510: IFFALSE 136538
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
136512: LD_VAR 0 4
136516: PUSH
136517: LD_VAR 0 7
136521: ARRAY
136522: PPUSH
136523: LD_VAR 0 14
136527: PUSH
136528: LD_INT 1
136530: ARRAY
136531: PPUSH
136532: CALL 102896 0 2
136536: GO 136562
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136538: LD_VAR 0 4
136542: PUSH
136543: LD_VAR 0 7
136547: ARRAY
136548: PPUSH
136549: LD_VAR 0 14
136553: PUSH
136554: LD_INT 1
136556: ARRAY
136557: PPUSH
136558: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
136562: LD_VAR 0 4
136566: PUSH
136567: LD_VAR 0 7
136571: ARRAY
136572: PPUSH
136573: CALL_OW 264
136577: PUSH
136578: LD_INT 29
136580: EQUAL
136581: IFFALSE 136947
// begin if WantsToAttack ( group [ i ] ) in bombed then
136583: LD_VAR 0 4
136587: PUSH
136588: LD_VAR 0 7
136592: ARRAY
136593: PPUSH
136594: CALL_OW 319
136598: PUSH
136599: LD_VAR 0 28
136603: IN
136604: IFFALSE 136608
// continue ;
136606: GO 133612
// k := 8 ;
136608: LD_ADDR_VAR 0 9
136612: PUSH
136613: LD_INT 8
136615: ST_TO_ADDR
// x := 0 ;
136616: LD_ADDR_VAR 0 10
136620: PUSH
136621: LD_INT 0
136623: ST_TO_ADDR
// if tmp < k then
136624: LD_VAR 0 14
136628: PUSH
136629: LD_VAR 0 9
136633: LESS
136634: IFFALSE 136646
// k := tmp ;
136636: LD_ADDR_VAR 0 9
136640: PUSH
136641: LD_VAR 0 14
136645: ST_TO_ADDR
// for j = 1 to k do
136646: LD_ADDR_VAR 0 8
136650: PUSH
136651: DOUBLE
136652: LD_INT 1
136654: DEC
136655: ST_TO_ADDR
136656: LD_VAR 0 9
136660: PUSH
136661: FOR_TO
136662: IFFALSE 136794
// begin if GetType ( tmp [ j ] ) = unit_building then
136664: LD_VAR 0 14
136668: PUSH
136669: LD_VAR 0 8
136673: ARRAY
136674: PPUSH
136675: CALL_OW 247
136679: PUSH
136680: LD_INT 3
136682: EQUAL
136683: IFFALSE 136792
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
136685: LD_VAR 0 14
136689: PUSH
136690: LD_VAR 0 8
136694: ARRAY
136695: PUSH
136696: LD_VAR 0 28
136700: IN
136701: NOT
136702: PUSH
136703: LD_VAR 0 14
136707: PUSH
136708: LD_VAR 0 8
136712: ARRAY
136713: PPUSH
136714: CALL_OW 313
136718: AND
136719: IFFALSE 136792
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136721: LD_VAR 0 4
136725: PUSH
136726: LD_VAR 0 7
136730: ARRAY
136731: PPUSH
136732: LD_VAR 0 14
136736: PUSH
136737: LD_VAR 0 8
136741: ARRAY
136742: PPUSH
136743: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136747: LD_ADDR_VAR 0 28
136751: PUSH
136752: LD_VAR 0 28
136756: PPUSH
136757: LD_VAR 0 28
136761: PUSH
136762: LD_INT 1
136764: PLUS
136765: PPUSH
136766: LD_VAR 0 14
136770: PUSH
136771: LD_VAR 0 8
136775: ARRAY
136776: PPUSH
136777: CALL_OW 1
136781: ST_TO_ADDR
// attacking := true ;
136782: LD_ADDR_VAR 0 29
136786: PUSH
136787: LD_INT 1
136789: ST_TO_ADDR
// break ;
136790: GO 136794
// end ; end ;
136792: GO 136661
136794: POP
136795: POP
// if not attacking and f_attack_depot then
136796: LD_VAR 0 29
136800: NOT
136801: PUSH
136802: LD_VAR 0 25
136806: AND
136807: IFFALSE 136902
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136809: LD_ADDR_VAR 0 13
136813: PUSH
136814: LD_VAR 0 14
136818: PPUSH
136819: LD_INT 2
136821: PUSH
136822: LD_INT 30
136824: PUSH
136825: LD_INT 0
136827: PUSH
136828: EMPTY
136829: LIST
136830: LIST
136831: PUSH
136832: LD_INT 30
136834: PUSH
136835: LD_INT 1
136837: PUSH
136838: EMPTY
136839: LIST
136840: LIST
136841: PUSH
136842: EMPTY
136843: LIST
136844: LIST
136845: LIST
136846: PPUSH
136847: CALL_OW 72
136851: ST_TO_ADDR
// if z then
136852: LD_VAR 0 13
136856: IFFALSE 136902
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136858: LD_VAR 0 4
136862: PUSH
136863: LD_VAR 0 7
136867: ARRAY
136868: PPUSH
136869: LD_VAR 0 13
136873: PPUSH
136874: LD_VAR 0 4
136878: PUSH
136879: LD_VAR 0 7
136883: ARRAY
136884: PPUSH
136885: CALL_OW 74
136889: PPUSH
136890: CALL_OW 115
// attacking := true ;
136894: LD_ADDR_VAR 0 29
136898: PUSH
136899: LD_INT 1
136901: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
136902: LD_VAR 0 4
136906: PUSH
136907: LD_VAR 0 7
136911: ARRAY
136912: PPUSH
136913: CALL_OW 256
136917: PUSH
136918: LD_INT 500
136920: LESS
136921: IFFALSE 136947
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136923: LD_VAR 0 4
136927: PUSH
136928: LD_VAR 0 7
136932: ARRAY
136933: PPUSH
136934: LD_VAR 0 14
136938: PUSH
136939: LD_INT 1
136941: ARRAY
136942: PPUSH
136943: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
136947: LD_VAR 0 4
136951: PUSH
136952: LD_VAR 0 7
136956: ARRAY
136957: PPUSH
136958: CALL_OW 264
136962: PUSH
136963: LD_INT 49
136965: EQUAL
136966: IFFALSE 137087
// begin if not HasTask ( group [ i ] ) then
136968: LD_VAR 0 4
136972: PUSH
136973: LD_VAR 0 7
136977: ARRAY
136978: PPUSH
136979: CALL_OW 314
136983: NOT
136984: IFFALSE 137087
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
136986: LD_ADDR_VAR 0 9
136990: PUSH
136991: LD_INT 81
136993: PUSH
136994: LD_VAR 0 4
136998: PUSH
136999: LD_VAR 0 7
137003: ARRAY
137004: PPUSH
137005: CALL_OW 255
137009: PUSH
137010: EMPTY
137011: LIST
137012: LIST
137013: PPUSH
137014: CALL_OW 69
137018: PPUSH
137019: LD_VAR 0 4
137023: PUSH
137024: LD_VAR 0 7
137028: ARRAY
137029: PPUSH
137030: CALL_OW 74
137034: ST_TO_ADDR
// if k then
137035: LD_VAR 0 9
137039: IFFALSE 137087
// if GetDistUnits ( group [ i ] , k ) > 10 then
137041: LD_VAR 0 4
137045: PUSH
137046: LD_VAR 0 7
137050: ARRAY
137051: PPUSH
137052: LD_VAR 0 9
137056: PPUSH
137057: CALL_OW 296
137061: PUSH
137062: LD_INT 10
137064: GREATER
137065: IFFALSE 137087
// ComMoveUnit ( group [ i ] , k ) ;
137067: LD_VAR 0 4
137071: PUSH
137072: LD_VAR 0 7
137076: ARRAY
137077: PPUSH
137078: LD_VAR 0 9
137082: PPUSH
137083: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
137087: LD_VAR 0 4
137091: PUSH
137092: LD_VAR 0 7
137096: ARRAY
137097: PPUSH
137098: CALL_OW 256
137102: PUSH
137103: LD_INT 250
137105: LESS
137106: PUSH
137107: LD_VAR 0 4
137111: PUSH
137112: LD_VAR 0 7
137116: ARRAY
137117: PUSH
137118: LD_INT 21
137120: PUSH
137121: LD_INT 2
137123: PUSH
137124: EMPTY
137125: LIST
137126: LIST
137127: PUSH
137128: LD_INT 23
137130: PUSH
137131: LD_INT 2
137133: PUSH
137134: EMPTY
137135: LIST
137136: LIST
137137: PUSH
137138: EMPTY
137139: LIST
137140: LIST
137141: PPUSH
137142: CALL_OW 69
137146: IN
137147: AND
137148: IFFALSE 137273
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
137150: LD_ADDR_VAR 0 9
137154: PUSH
137155: LD_OWVAR 3
137159: PUSH
137160: LD_VAR 0 4
137164: PUSH
137165: LD_VAR 0 7
137169: ARRAY
137170: DIFF
137171: PPUSH
137172: LD_VAR 0 4
137176: PUSH
137177: LD_VAR 0 7
137181: ARRAY
137182: PPUSH
137183: CALL_OW 74
137187: ST_TO_ADDR
// if not k then
137188: LD_VAR 0 9
137192: NOT
137193: IFFALSE 137197
// continue ;
137195: GO 133612
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
137197: LD_VAR 0 9
137201: PUSH
137202: LD_INT 81
137204: PUSH
137205: LD_VAR 0 4
137209: PUSH
137210: LD_VAR 0 7
137214: ARRAY
137215: PPUSH
137216: CALL_OW 255
137220: PUSH
137221: EMPTY
137222: LIST
137223: LIST
137224: PPUSH
137225: CALL_OW 69
137229: IN
137230: PUSH
137231: LD_VAR 0 9
137235: PPUSH
137236: LD_VAR 0 4
137240: PUSH
137241: LD_VAR 0 7
137245: ARRAY
137246: PPUSH
137247: CALL_OW 296
137251: PUSH
137252: LD_INT 5
137254: LESS
137255: AND
137256: IFFALSE 137273
// ComAutodestruct ( group [ i ] ) ;
137258: LD_VAR 0 4
137262: PUSH
137263: LD_VAR 0 7
137267: ARRAY
137268: PPUSH
137269: CALL 102794 0 1
// end ; if f_attack_depot then
137273: LD_VAR 0 25
137277: IFFALSE 137389
// begin k := 6 ;
137279: LD_ADDR_VAR 0 9
137283: PUSH
137284: LD_INT 6
137286: ST_TO_ADDR
// if tmp < k then
137287: LD_VAR 0 14
137291: PUSH
137292: LD_VAR 0 9
137296: LESS
137297: IFFALSE 137309
// k := tmp ;
137299: LD_ADDR_VAR 0 9
137303: PUSH
137304: LD_VAR 0 14
137308: ST_TO_ADDR
// for j = 1 to k do
137309: LD_ADDR_VAR 0 8
137313: PUSH
137314: DOUBLE
137315: LD_INT 1
137317: DEC
137318: ST_TO_ADDR
137319: LD_VAR 0 9
137323: PUSH
137324: FOR_TO
137325: IFFALSE 137387
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
137327: LD_VAR 0 8
137331: PPUSH
137332: CALL_OW 266
137336: PUSH
137337: LD_INT 0
137339: PUSH
137340: LD_INT 1
137342: PUSH
137343: EMPTY
137344: LIST
137345: LIST
137346: IN
137347: IFFALSE 137385
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137349: LD_VAR 0 4
137353: PUSH
137354: LD_VAR 0 7
137358: ARRAY
137359: PPUSH
137360: LD_VAR 0 14
137364: PUSH
137365: LD_VAR 0 8
137369: ARRAY
137370: PPUSH
137371: CALL_OW 115
// attacking := true ;
137375: LD_ADDR_VAR 0 29
137379: PUSH
137380: LD_INT 1
137382: ST_TO_ADDR
// break ;
137383: GO 137387
// end ;
137385: GO 137324
137387: POP
137388: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
137389: LD_VAR 0 4
137393: PUSH
137394: LD_VAR 0 7
137398: ARRAY
137399: PPUSH
137400: CALL_OW 302
137404: PUSH
137405: LD_VAR 0 29
137409: NOT
137410: AND
137411: IFFALSE 137733
// begin if GetTag ( group [ i ] ) = 71 then
137413: LD_VAR 0 4
137417: PUSH
137418: LD_VAR 0 7
137422: ARRAY
137423: PPUSH
137424: CALL_OW 110
137428: PUSH
137429: LD_INT 71
137431: EQUAL
137432: IFFALSE 137473
// begin if HasTask ( group [ i ] ) then
137434: LD_VAR 0 4
137438: PUSH
137439: LD_VAR 0 7
137443: ARRAY
137444: PPUSH
137445: CALL_OW 314
137449: IFFALSE 137455
// continue else
137451: GO 133612
137453: GO 137473
// SetTag ( group [ i ] , 0 ) ;
137455: LD_VAR 0 4
137459: PUSH
137460: LD_VAR 0 7
137464: ARRAY
137465: PPUSH
137466: LD_INT 0
137468: PPUSH
137469: CALL_OW 109
// end ; k := 8 ;
137473: LD_ADDR_VAR 0 9
137477: PUSH
137478: LD_INT 8
137480: ST_TO_ADDR
// x := 0 ;
137481: LD_ADDR_VAR 0 10
137485: PUSH
137486: LD_INT 0
137488: ST_TO_ADDR
// if tmp < k then
137489: LD_VAR 0 14
137493: PUSH
137494: LD_VAR 0 9
137498: LESS
137499: IFFALSE 137511
// k := tmp ;
137501: LD_ADDR_VAR 0 9
137505: PUSH
137506: LD_VAR 0 14
137510: ST_TO_ADDR
// for j = 1 to k do
137511: LD_ADDR_VAR 0 8
137515: PUSH
137516: DOUBLE
137517: LD_INT 1
137519: DEC
137520: ST_TO_ADDR
137521: LD_VAR 0 9
137525: PUSH
137526: FOR_TO
137527: IFFALSE 137625
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
137529: LD_VAR 0 14
137533: PUSH
137534: LD_VAR 0 8
137538: ARRAY
137539: PPUSH
137540: CALL_OW 247
137544: PUSH
137545: LD_INT 1
137547: EQUAL
137548: PUSH
137549: LD_VAR 0 14
137553: PUSH
137554: LD_VAR 0 8
137558: ARRAY
137559: PPUSH
137560: CALL_OW 256
137564: PUSH
137565: LD_INT 250
137567: LESS
137568: PUSH
137569: LD_VAR 0 20
137573: AND
137574: PUSH
137575: LD_VAR 0 20
137579: NOT
137580: PUSH
137581: LD_VAR 0 14
137585: PUSH
137586: LD_VAR 0 8
137590: ARRAY
137591: PPUSH
137592: CALL_OW 256
137596: PUSH
137597: LD_INT 250
137599: GREATEREQUAL
137600: AND
137601: OR
137602: AND
137603: IFFALSE 137623
// begin x := tmp [ j ] ;
137605: LD_ADDR_VAR 0 10
137609: PUSH
137610: LD_VAR 0 14
137614: PUSH
137615: LD_VAR 0 8
137619: ARRAY
137620: ST_TO_ADDR
// break ;
137621: GO 137625
// end ;
137623: GO 137526
137625: POP
137626: POP
// if x then
137627: LD_VAR 0 10
137631: IFFALSE 137655
// ComAttackUnit ( group [ i ] , x ) else
137633: LD_VAR 0 4
137637: PUSH
137638: LD_VAR 0 7
137642: ARRAY
137643: PPUSH
137644: LD_VAR 0 10
137648: PPUSH
137649: CALL_OW 115
137653: GO 137679
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137655: LD_VAR 0 4
137659: PUSH
137660: LD_VAR 0 7
137664: ARRAY
137665: PPUSH
137666: LD_VAR 0 14
137670: PUSH
137671: LD_INT 1
137673: ARRAY
137674: PPUSH
137675: CALL_OW 115
// if not HasTask ( group [ i ] ) then
137679: LD_VAR 0 4
137683: PUSH
137684: LD_VAR 0 7
137688: ARRAY
137689: PPUSH
137690: CALL_OW 314
137694: NOT
137695: IFFALSE 137733
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
137697: LD_VAR 0 4
137701: PUSH
137702: LD_VAR 0 7
137706: ARRAY
137707: PPUSH
137708: LD_VAR 0 14
137712: PPUSH
137713: LD_VAR 0 4
137717: PUSH
137718: LD_VAR 0 7
137722: ARRAY
137723: PPUSH
137724: CALL_OW 74
137728: PPUSH
137729: CALL_OW 115
// end ; end ; end ;
137733: GO 133612
137735: POP
137736: POP
// wait ( 0 0$2 ) ;
137737: LD_INT 70
137739: PPUSH
137740: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137744: LD_VAR 0 4
137748: NOT
137749: PUSH
137750: LD_VAR 0 4
137754: PUSH
137755: EMPTY
137756: EQUAL
137757: OR
137758: PUSH
137759: LD_INT 81
137761: PUSH
137762: LD_VAR 0 35
137766: PUSH
137767: EMPTY
137768: LIST
137769: LIST
137770: PPUSH
137771: CALL_OW 69
137775: NOT
137776: OR
137777: IFFALSE 133597
// end ;
137779: LD_VAR 0 2
137783: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137784: LD_INT 0
137786: PPUSH
137787: PPUSH
137788: PPUSH
137789: PPUSH
137790: PPUSH
137791: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137792: LD_VAR 0 1
137796: NOT
137797: PUSH
137798: LD_EXP 102
137802: PUSH
137803: LD_VAR 0 1
137807: ARRAY
137808: NOT
137809: OR
137810: PUSH
137811: LD_VAR 0 2
137815: NOT
137816: OR
137817: IFFALSE 137821
// exit ;
137819: GO 138375
// side := mc_sides [ base ] ;
137821: LD_ADDR_VAR 0 6
137825: PUSH
137826: LD_EXP 128
137830: PUSH
137831: LD_VAR 0 1
137835: ARRAY
137836: ST_TO_ADDR
// if not side then
137837: LD_VAR 0 6
137841: NOT
137842: IFFALSE 137846
// exit ;
137844: GO 138375
// for i in solds do
137846: LD_ADDR_VAR 0 7
137850: PUSH
137851: LD_VAR 0 2
137855: PUSH
137856: FOR_IN
137857: IFFALSE 137918
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137859: LD_VAR 0 7
137863: PPUSH
137864: CALL_OW 310
137868: PPUSH
137869: CALL_OW 266
137873: PUSH
137874: LD_INT 32
137876: PUSH
137877: LD_INT 31
137879: PUSH
137880: EMPTY
137881: LIST
137882: LIST
137883: IN
137884: IFFALSE 137904
// solds := solds diff i else
137886: LD_ADDR_VAR 0 2
137890: PUSH
137891: LD_VAR 0 2
137895: PUSH
137896: LD_VAR 0 7
137900: DIFF
137901: ST_TO_ADDR
137902: GO 137916
// SetTag ( i , 18 ) ;
137904: LD_VAR 0 7
137908: PPUSH
137909: LD_INT 18
137911: PPUSH
137912: CALL_OW 109
137916: GO 137856
137918: POP
137919: POP
// if not solds then
137920: LD_VAR 0 2
137924: NOT
137925: IFFALSE 137929
// exit ;
137927: GO 138375
// repeat wait ( 0 0$2 ) ;
137929: LD_INT 70
137931: PPUSH
137932: CALL_OW 67
// enemy := mc_scan [ base ] ;
137936: LD_ADDR_VAR 0 4
137940: PUSH
137941: LD_EXP 125
137945: PUSH
137946: LD_VAR 0 1
137950: ARRAY
137951: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137952: LD_EXP 102
137956: PUSH
137957: LD_VAR 0 1
137961: ARRAY
137962: NOT
137963: PUSH
137964: LD_EXP 102
137968: PUSH
137969: LD_VAR 0 1
137973: ARRAY
137974: PUSH
137975: EMPTY
137976: EQUAL
137977: OR
137978: IFFALSE 138015
// begin for i in solds do
137980: LD_ADDR_VAR 0 7
137984: PUSH
137985: LD_VAR 0 2
137989: PUSH
137990: FOR_IN
137991: IFFALSE 138004
// ComStop ( i ) ;
137993: LD_VAR 0 7
137997: PPUSH
137998: CALL_OW 141
138002: GO 137990
138004: POP
138005: POP
// solds := [ ] ;
138006: LD_ADDR_VAR 0 2
138010: PUSH
138011: EMPTY
138012: ST_TO_ADDR
// exit ;
138013: GO 138375
// end ; for i in solds do
138015: LD_ADDR_VAR 0 7
138019: PUSH
138020: LD_VAR 0 2
138024: PUSH
138025: FOR_IN
138026: IFFALSE 138347
// begin if IsInUnit ( i ) then
138028: LD_VAR 0 7
138032: PPUSH
138033: CALL_OW 310
138037: IFFALSE 138048
// ComExitBuilding ( i ) ;
138039: LD_VAR 0 7
138043: PPUSH
138044: CALL_OW 122
// if GetLives ( i ) > 500 then
138048: LD_VAR 0 7
138052: PPUSH
138053: CALL_OW 256
138057: PUSH
138058: LD_INT 500
138060: GREATER
138061: IFFALSE 138114
// begin e := NearestUnitToUnit ( enemy , i ) ;
138063: LD_ADDR_VAR 0 5
138067: PUSH
138068: LD_VAR 0 4
138072: PPUSH
138073: LD_VAR 0 7
138077: PPUSH
138078: CALL_OW 74
138082: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
138083: LD_VAR 0 7
138087: PPUSH
138088: LD_VAR 0 5
138092: PPUSH
138093: CALL_OW 250
138097: PPUSH
138098: LD_VAR 0 5
138102: PPUSH
138103: CALL_OW 251
138107: PPUSH
138108: CALL_OW 114
// end else
138112: GO 138345
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
138114: LD_VAR 0 7
138118: PPUSH
138119: LD_EXP 102
138123: PUSH
138124: LD_VAR 0 1
138128: ARRAY
138129: PPUSH
138130: LD_INT 2
138132: PUSH
138133: LD_INT 30
138135: PUSH
138136: LD_INT 0
138138: PUSH
138139: EMPTY
138140: LIST
138141: LIST
138142: PUSH
138143: LD_INT 30
138145: PUSH
138146: LD_INT 1
138148: PUSH
138149: EMPTY
138150: LIST
138151: LIST
138152: PUSH
138153: LD_INT 30
138155: PUSH
138156: LD_INT 6
138158: PUSH
138159: EMPTY
138160: LIST
138161: LIST
138162: PUSH
138163: EMPTY
138164: LIST
138165: LIST
138166: LIST
138167: LIST
138168: PPUSH
138169: CALL_OW 72
138173: PPUSH
138174: LD_VAR 0 7
138178: PPUSH
138179: CALL_OW 74
138183: PPUSH
138184: CALL_OW 296
138188: PUSH
138189: LD_INT 10
138191: GREATER
138192: IFFALSE 138345
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
138194: LD_ADDR_VAR 0 8
138198: PUSH
138199: LD_EXP 102
138203: PUSH
138204: LD_VAR 0 1
138208: ARRAY
138209: PPUSH
138210: LD_INT 2
138212: PUSH
138213: LD_INT 30
138215: PUSH
138216: LD_INT 0
138218: PUSH
138219: EMPTY
138220: LIST
138221: LIST
138222: PUSH
138223: LD_INT 30
138225: PUSH
138226: LD_INT 1
138228: PUSH
138229: EMPTY
138230: LIST
138231: LIST
138232: PUSH
138233: LD_INT 30
138235: PUSH
138236: LD_INT 6
138238: PUSH
138239: EMPTY
138240: LIST
138241: LIST
138242: PUSH
138243: EMPTY
138244: LIST
138245: LIST
138246: LIST
138247: LIST
138248: PPUSH
138249: CALL_OW 72
138253: PPUSH
138254: LD_VAR 0 7
138258: PPUSH
138259: CALL_OW 74
138263: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
138264: LD_VAR 0 7
138268: PPUSH
138269: LD_VAR 0 8
138273: PPUSH
138274: CALL_OW 250
138278: PPUSH
138279: LD_INT 3
138281: PPUSH
138282: LD_INT 5
138284: PPUSH
138285: CALL_OW 272
138289: PPUSH
138290: LD_VAR 0 8
138294: PPUSH
138295: CALL_OW 251
138299: PPUSH
138300: LD_INT 3
138302: PPUSH
138303: LD_INT 5
138305: PPUSH
138306: CALL_OW 273
138310: PPUSH
138311: CALL_OW 111
// SetTag ( i , 0 ) ;
138315: LD_VAR 0 7
138319: PPUSH
138320: LD_INT 0
138322: PPUSH
138323: CALL_OW 109
// solds := solds diff i ;
138327: LD_ADDR_VAR 0 2
138331: PUSH
138332: LD_VAR 0 2
138336: PUSH
138337: LD_VAR 0 7
138341: DIFF
138342: ST_TO_ADDR
// continue ;
138343: GO 138025
// end ; end ;
138345: GO 138025
138347: POP
138348: POP
// until not solds or not enemy ;
138349: LD_VAR 0 2
138353: NOT
138354: PUSH
138355: LD_VAR 0 4
138359: NOT
138360: OR
138361: IFFALSE 137929
// MC_Reset ( base , 18 ) ;
138363: LD_VAR 0 1
138367: PPUSH
138368: LD_INT 18
138370: PPUSH
138371: CALL 43052 0 2
// end ;
138375: LD_VAR 0 3
138379: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
138380: LD_INT 0
138382: PPUSH
138383: PPUSH
138384: PPUSH
138385: PPUSH
138386: PPUSH
138387: PPUSH
138388: PPUSH
138389: PPUSH
138390: PPUSH
138391: PPUSH
138392: PPUSH
138393: PPUSH
138394: PPUSH
138395: PPUSH
138396: PPUSH
138397: PPUSH
138398: PPUSH
138399: PPUSH
138400: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
138401: LD_ADDR_VAR 0 12
138405: PUSH
138406: LD_EXP 102
138410: PUSH
138411: LD_VAR 0 1
138415: ARRAY
138416: PPUSH
138417: LD_INT 25
138419: PUSH
138420: LD_INT 3
138422: PUSH
138423: EMPTY
138424: LIST
138425: LIST
138426: PPUSH
138427: CALL_OW 72
138431: ST_TO_ADDR
// if mc_remote_driver [ base ] then
138432: LD_EXP 142
138436: PUSH
138437: LD_VAR 0 1
138441: ARRAY
138442: IFFALSE 138466
// mechs := mechs diff mc_remote_driver [ base ] ;
138444: LD_ADDR_VAR 0 12
138448: PUSH
138449: LD_VAR 0 12
138453: PUSH
138454: LD_EXP 142
138458: PUSH
138459: LD_VAR 0 1
138463: ARRAY
138464: DIFF
138465: ST_TO_ADDR
// for i in mechs do
138466: LD_ADDR_VAR 0 4
138470: PUSH
138471: LD_VAR 0 12
138475: PUSH
138476: FOR_IN
138477: IFFALSE 138512
// if GetTag ( i ) > 0 then
138479: LD_VAR 0 4
138483: PPUSH
138484: CALL_OW 110
138488: PUSH
138489: LD_INT 0
138491: GREATER
138492: IFFALSE 138510
// mechs := mechs diff i ;
138494: LD_ADDR_VAR 0 12
138498: PUSH
138499: LD_VAR 0 12
138503: PUSH
138504: LD_VAR 0 4
138508: DIFF
138509: ST_TO_ADDR
138510: GO 138476
138512: POP
138513: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138514: LD_ADDR_VAR 0 8
138518: PUSH
138519: LD_EXP 102
138523: PUSH
138524: LD_VAR 0 1
138528: ARRAY
138529: PPUSH
138530: LD_INT 2
138532: PUSH
138533: LD_INT 25
138535: PUSH
138536: LD_INT 1
138538: PUSH
138539: EMPTY
138540: LIST
138541: LIST
138542: PUSH
138543: LD_INT 25
138545: PUSH
138546: LD_INT 5
138548: PUSH
138549: EMPTY
138550: LIST
138551: LIST
138552: PUSH
138553: LD_INT 25
138555: PUSH
138556: LD_INT 8
138558: PUSH
138559: EMPTY
138560: LIST
138561: LIST
138562: PUSH
138563: LD_INT 25
138565: PUSH
138566: LD_INT 9
138568: PUSH
138569: EMPTY
138570: LIST
138571: LIST
138572: PUSH
138573: EMPTY
138574: LIST
138575: LIST
138576: LIST
138577: LIST
138578: LIST
138579: PPUSH
138580: CALL_OW 72
138584: ST_TO_ADDR
// if not defenders and not solds then
138585: LD_VAR 0 2
138589: NOT
138590: PUSH
138591: LD_VAR 0 8
138595: NOT
138596: AND
138597: IFFALSE 138601
// exit ;
138599: GO 140371
// depot_under_attack := false ;
138601: LD_ADDR_VAR 0 16
138605: PUSH
138606: LD_INT 0
138608: ST_TO_ADDR
// sold_defenders := [ ] ;
138609: LD_ADDR_VAR 0 17
138613: PUSH
138614: EMPTY
138615: ST_TO_ADDR
// if mechs then
138616: LD_VAR 0 12
138620: IFFALSE 138773
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
138622: LD_ADDR_VAR 0 4
138626: PUSH
138627: LD_VAR 0 2
138631: PPUSH
138632: LD_INT 21
138634: PUSH
138635: LD_INT 2
138637: PUSH
138638: EMPTY
138639: LIST
138640: LIST
138641: PPUSH
138642: CALL_OW 72
138646: PUSH
138647: FOR_IN
138648: IFFALSE 138771
// begin if GetTag ( i ) <> 20 then
138650: LD_VAR 0 4
138654: PPUSH
138655: CALL_OW 110
138659: PUSH
138660: LD_INT 20
138662: NONEQUAL
138663: IFFALSE 138677
// SetTag ( i , 20 ) ;
138665: LD_VAR 0 4
138669: PPUSH
138670: LD_INT 20
138672: PPUSH
138673: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
138677: LD_VAR 0 4
138681: PPUSH
138682: CALL_OW 263
138686: PUSH
138687: LD_INT 1
138689: EQUAL
138690: PUSH
138691: LD_VAR 0 4
138695: PPUSH
138696: CALL_OW 311
138700: NOT
138701: AND
138702: IFFALSE 138769
// begin un := mechs [ 1 ] ;
138704: LD_ADDR_VAR 0 10
138708: PUSH
138709: LD_VAR 0 12
138713: PUSH
138714: LD_INT 1
138716: ARRAY
138717: ST_TO_ADDR
// ComExit ( un ) ;
138718: LD_VAR 0 10
138722: PPUSH
138723: CALL 107680 0 1
// AddComEnterUnit ( un , i ) ;
138727: LD_VAR 0 10
138731: PPUSH
138732: LD_VAR 0 4
138736: PPUSH
138737: CALL_OW 180
// SetTag ( un , 19 ) ;
138741: LD_VAR 0 10
138745: PPUSH
138746: LD_INT 19
138748: PPUSH
138749: CALL_OW 109
// mechs := mechs diff un ;
138753: LD_ADDR_VAR 0 12
138757: PUSH
138758: LD_VAR 0 12
138762: PUSH
138763: LD_VAR 0 10
138767: DIFF
138768: ST_TO_ADDR
// end ; end ;
138769: GO 138647
138771: POP
138772: POP
// if solds then
138773: LD_VAR 0 8
138777: IFFALSE 138836
// for i in solds do
138779: LD_ADDR_VAR 0 4
138783: PUSH
138784: LD_VAR 0 8
138788: PUSH
138789: FOR_IN
138790: IFFALSE 138834
// if not GetTag ( i ) then
138792: LD_VAR 0 4
138796: PPUSH
138797: CALL_OW 110
138801: NOT
138802: IFFALSE 138832
// begin defenders := defenders union i ;
138804: LD_ADDR_VAR 0 2
138808: PUSH
138809: LD_VAR 0 2
138813: PUSH
138814: LD_VAR 0 4
138818: UNION
138819: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138820: LD_VAR 0 4
138824: PPUSH
138825: LD_INT 18
138827: PPUSH
138828: CALL_OW 109
// end ;
138832: GO 138789
138834: POP
138835: POP
// repeat wait ( 0 0$2 ) ;
138836: LD_INT 70
138838: PPUSH
138839: CALL_OW 67
// enemy := mc_scan [ base ] ;
138843: LD_ADDR_VAR 0 21
138847: PUSH
138848: LD_EXP 125
138852: PUSH
138853: LD_VAR 0 1
138857: ARRAY
138858: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138859: LD_EXP 102
138863: PUSH
138864: LD_VAR 0 1
138868: ARRAY
138869: NOT
138870: PUSH
138871: LD_EXP 102
138875: PUSH
138876: LD_VAR 0 1
138880: ARRAY
138881: PUSH
138882: EMPTY
138883: EQUAL
138884: OR
138885: IFFALSE 138922
// begin for i in defenders do
138887: LD_ADDR_VAR 0 4
138891: PUSH
138892: LD_VAR 0 2
138896: PUSH
138897: FOR_IN
138898: IFFALSE 138911
// ComStop ( i ) ;
138900: LD_VAR 0 4
138904: PPUSH
138905: CALL_OW 141
138909: GO 138897
138911: POP
138912: POP
// defenders := [ ] ;
138913: LD_ADDR_VAR 0 2
138917: PUSH
138918: EMPTY
138919: ST_TO_ADDR
// exit ;
138920: GO 140371
// end ; for i in defenders do
138922: LD_ADDR_VAR 0 4
138926: PUSH
138927: LD_VAR 0 2
138931: PUSH
138932: FOR_IN
138933: IFFALSE 139831
// begin e := NearestUnitToUnit ( enemy , i ) ;
138935: LD_ADDR_VAR 0 13
138939: PUSH
138940: LD_VAR 0 21
138944: PPUSH
138945: LD_VAR 0 4
138949: PPUSH
138950: CALL_OW 74
138954: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138955: LD_ADDR_VAR 0 7
138959: PUSH
138960: LD_EXP 102
138964: PUSH
138965: LD_VAR 0 1
138969: ARRAY
138970: PPUSH
138971: LD_INT 2
138973: PUSH
138974: LD_INT 30
138976: PUSH
138977: LD_INT 0
138979: PUSH
138980: EMPTY
138981: LIST
138982: LIST
138983: PUSH
138984: LD_INT 30
138986: PUSH
138987: LD_INT 1
138989: PUSH
138990: EMPTY
138991: LIST
138992: LIST
138993: PUSH
138994: EMPTY
138995: LIST
138996: LIST
138997: LIST
138998: PPUSH
138999: CALL_OW 72
139003: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
139004: LD_ADDR_VAR 0 16
139008: PUSH
139009: LD_VAR 0 7
139013: NOT
139014: PUSH
139015: LD_VAR 0 7
139019: PPUSH
139020: LD_INT 3
139022: PUSH
139023: LD_INT 24
139025: PUSH
139026: LD_INT 600
139028: PUSH
139029: EMPTY
139030: LIST
139031: LIST
139032: PUSH
139033: EMPTY
139034: LIST
139035: LIST
139036: PPUSH
139037: CALL_OW 72
139041: OR
139042: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
139043: LD_VAR 0 4
139047: PPUSH
139048: CALL_OW 247
139052: PUSH
139053: LD_INT 2
139055: DOUBLE
139056: EQUAL
139057: IFTRUE 139061
139059: GO 139457
139061: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
139062: LD_VAR 0 4
139066: PPUSH
139067: CALL_OW 256
139071: PUSH
139072: LD_INT 1000
139074: EQUAL
139075: PUSH
139076: LD_VAR 0 4
139080: PPUSH
139081: LD_VAR 0 13
139085: PPUSH
139086: CALL_OW 296
139090: PUSH
139091: LD_INT 40
139093: LESS
139094: PUSH
139095: LD_VAR 0 13
139099: PPUSH
139100: LD_EXP 127
139104: PUSH
139105: LD_VAR 0 1
139109: ARRAY
139110: PPUSH
139111: CALL_OW 308
139115: OR
139116: AND
139117: IFFALSE 139239
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
139119: LD_VAR 0 4
139123: PPUSH
139124: CALL_OW 262
139128: PUSH
139129: LD_INT 1
139131: EQUAL
139132: PUSH
139133: LD_VAR 0 4
139137: PPUSH
139138: CALL_OW 261
139142: PUSH
139143: LD_INT 30
139145: LESS
139146: AND
139147: PUSH
139148: LD_VAR 0 7
139152: AND
139153: IFFALSE 139223
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
139155: LD_VAR 0 4
139159: PPUSH
139160: LD_VAR 0 7
139164: PPUSH
139165: LD_VAR 0 4
139169: PPUSH
139170: CALL_OW 74
139174: PPUSH
139175: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
139179: LD_VAR 0 4
139183: PPUSH
139184: LD_VAR 0 7
139188: PPUSH
139189: LD_VAR 0 4
139193: PPUSH
139194: CALL_OW 74
139198: PPUSH
139199: CALL_OW 296
139203: PUSH
139204: LD_INT 6
139206: LESS
139207: IFFALSE 139221
// SetFuel ( i , 100 ) ;
139209: LD_VAR 0 4
139213: PPUSH
139214: LD_INT 100
139216: PPUSH
139217: CALL_OW 240
// end else
139221: GO 139237
// ComAttackUnit ( i , e ) ;
139223: LD_VAR 0 4
139227: PPUSH
139228: LD_VAR 0 13
139232: PPUSH
139233: CALL_OW 115
// end else
139237: GO 139340
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
139239: LD_VAR 0 13
139243: PPUSH
139244: LD_EXP 127
139248: PUSH
139249: LD_VAR 0 1
139253: ARRAY
139254: PPUSH
139255: CALL_OW 308
139259: NOT
139260: PUSH
139261: LD_VAR 0 4
139265: PPUSH
139266: LD_VAR 0 13
139270: PPUSH
139271: CALL_OW 296
139275: PUSH
139276: LD_INT 40
139278: GREATEREQUAL
139279: AND
139280: PUSH
139281: LD_VAR 0 4
139285: PPUSH
139286: CALL_OW 256
139290: PUSH
139291: LD_INT 650
139293: LESSEQUAL
139294: OR
139295: PUSH
139296: LD_VAR 0 4
139300: PPUSH
139301: LD_EXP 126
139305: PUSH
139306: LD_VAR 0 1
139310: ARRAY
139311: PPUSH
139312: CALL_OW 308
139316: NOT
139317: AND
139318: IFFALSE 139340
// ComMoveToArea ( i , mc_parking [ base ] ) ;
139320: LD_VAR 0 4
139324: PPUSH
139325: LD_EXP 126
139329: PUSH
139330: LD_VAR 0 1
139334: ARRAY
139335: PPUSH
139336: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
139340: LD_VAR 0 4
139344: PPUSH
139345: CALL_OW 256
139349: PUSH
139350: LD_INT 1000
139352: LESS
139353: PUSH
139354: LD_VAR 0 4
139358: PPUSH
139359: CALL_OW 263
139363: PUSH
139364: LD_INT 1
139366: EQUAL
139367: AND
139368: PUSH
139369: LD_VAR 0 4
139373: PPUSH
139374: CALL_OW 311
139378: AND
139379: PUSH
139380: LD_VAR 0 4
139384: PPUSH
139385: LD_EXP 126
139389: PUSH
139390: LD_VAR 0 1
139394: ARRAY
139395: PPUSH
139396: CALL_OW 308
139400: AND
139401: IFFALSE 139455
// begin mech := IsDrivenBy ( i ) ;
139403: LD_ADDR_VAR 0 9
139407: PUSH
139408: LD_VAR 0 4
139412: PPUSH
139413: CALL_OW 311
139417: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
139418: LD_VAR 0 9
139422: PPUSH
139423: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
139427: LD_VAR 0 9
139431: PPUSH
139432: LD_VAR 0 4
139436: PPUSH
139437: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
139441: LD_VAR 0 9
139445: PPUSH
139446: LD_VAR 0 4
139450: PPUSH
139451: CALL_OW 180
// end ; end ; unit_human :
139455: GO 139802
139457: LD_INT 1
139459: DOUBLE
139460: EQUAL
139461: IFTRUE 139465
139463: GO 139801
139465: POP
// begin b := IsInUnit ( i ) ;
139466: LD_ADDR_VAR 0 18
139470: PUSH
139471: LD_VAR 0 4
139475: PPUSH
139476: CALL_OW 310
139480: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
139481: LD_ADDR_VAR 0 19
139485: PUSH
139486: LD_VAR 0 18
139490: NOT
139491: PUSH
139492: LD_VAR 0 18
139496: PPUSH
139497: CALL_OW 266
139501: PUSH
139502: LD_INT 32
139504: PUSH
139505: LD_INT 31
139507: PUSH
139508: EMPTY
139509: LIST
139510: LIST
139511: IN
139512: OR
139513: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
139514: LD_VAR 0 18
139518: PPUSH
139519: CALL_OW 266
139523: PUSH
139524: LD_INT 5
139526: EQUAL
139527: PUSH
139528: LD_VAR 0 4
139532: PPUSH
139533: CALL_OW 257
139537: PUSH
139538: LD_INT 1
139540: PUSH
139541: LD_INT 2
139543: PUSH
139544: LD_INT 3
139546: PUSH
139547: LD_INT 4
139549: PUSH
139550: EMPTY
139551: LIST
139552: LIST
139553: LIST
139554: LIST
139555: IN
139556: AND
139557: IFFALSE 139594
// begin class := AllowSpecClass ( i ) ;
139559: LD_ADDR_VAR 0 20
139563: PUSH
139564: LD_VAR 0 4
139568: PPUSH
139569: CALL 71377 0 1
139573: ST_TO_ADDR
// if class then
139574: LD_VAR 0 20
139578: IFFALSE 139594
// ComChangeProfession ( i , class ) ;
139580: LD_VAR 0 4
139584: PPUSH
139585: LD_VAR 0 20
139589: PPUSH
139590: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
139594: LD_VAR 0 16
139598: PUSH
139599: LD_VAR 0 2
139603: PPUSH
139604: LD_INT 21
139606: PUSH
139607: LD_INT 2
139609: PUSH
139610: EMPTY
139611: LIST
139612: LIST
139613: PPUSH
139614: CALL_OW 72
139618: PUSH
139619: LD_INT 1
139621: LESSEQUAL
139622: OR
139623: PUSH
139624: LD_VAR 0 19
139628: AND
139629: PUSH
139630: LD_VAR 0 4
139634: PUSH
139635: LD_VAR 0 17
139639: IN
139640: NOT
139641: AND
139642: IFFALSE 139735
// begin if b then
139644: LD_VAR 0 18
139648: IFFALSE 139697
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
139650: LD_VAR 0 18
139654: PPUSH
139655: LD_VAR 0 21
139659: PPUSH
139660: LD_VAR 0 18
139664: PPUSH
139665: CALL_OW 74
139669: PPUSH
139670: CALL_OW 296
139674: PUSH
139675: LD_INT 10
139677: LESS
139678: PUSH
139679: LD_VAR 0 18
139683: PPUSH
139684: CALL_OW 461
139688: PUSH
139689: LD_INT 7
139691: NONEQUAL
139692: AND
139693: IFFALSE 139697
// continue ;
139695: GO 138932
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
139697: LD_ADDR_VAR 0 17
139701: PUSH
139702: LD_VAR 0 17
139706: PPUSH
139707: LD_VAR 0 17
139711: PUSH
139712: LD_INT 1
139714: PLUS
139715: PPUSH
139716: LD_VAR 0 4
139720: PPUSH
139721: CALL_OW 1
139725: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139726: LD_VAR 0 4
139730: PPUSH
139731: CALL_OW 122
// end ; if sold_defenders then
139735: LD_VAR 0 17
139739: IFFALSE 139799
// if i in sold_defenders then
139741: LD_VAR 0 4
139745: PUSH
139746: LD_VAR 0 17
139750: IN
139751: IFFALSE 139799
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139753: LD_VAR 0 4
139757: PPUSH
139758: CALL_OW 314
139762: NOT
139763: PUSH
139764: LD_VAR 0 4
139768: PPUSH
139769: LD_VAR 0 13
139773: PPUSH
139774: CALL_OW 296
139778: PUSH
139779: LD_INT 30
139781: LESS
139782: AND
139783: IFFALSE 139799
// ComAttackUnit ( i , e ) ;
139785: LD_VAR 0 4
139789: PPUSH
139790: LD_VAR 0 13
139794: PPUSH
139795: CALL_OW 115
// end ; end ; end ;
139799: GO 139802
139801: POP
// if IsDead ( i ) then
139802: LD_VAR 0 4
139806: PPUSH
139807: CALL_OW 301
139811: IFFALSE 139829
// defenders := defenders diff i ;
139813: LD_ADDR_VAR 0 2
139817: PUSH
139818: LD_VAR 0 2
139822: PUSH
139823: LD_VAR 0 4
139827: DIFF
139828: ST_TO_ADDR
// end ;
139829: GO 138932
139831: POP
139832: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139833: LD_VAR 0 21
139837: NOT
139838: PUSH
139839: LD_VAR 0 2
139843: NOT
139844: OR
139845: PUSH
139846: LD_EXP 102
139850: PUSH
139851: LD_VAR 0 1
139855: ARRAY
139856: NOT
139857: OR
139858: IFFALSE 138836
// MC_Reset ( base , 18 ) ;
139860: LD_VAR 0 1
139864: PPUSH
139865: LD_INT 18
139867: PPUSH
139868: CALL 43052 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139872: LD_ADDR_VAR 0 2
139876: PUSH
139877: LD_VAR 0 2
139881: PUSH
139882: LD_VAR 0 2
139886: PPUSH
139887: LD_INT 2
139889: PUSH
139890: LD_INT 25
139892: PUSH
139893: LD_INT 1
139895: PUSH
139896: EMPTY
139897: LIST
139898: LIST
139899: PUSH
139900: LD_INT 25
139902: PUSH
139903: LD_INT 5
139905: PUSH
139906: EMPTY
139907: LIST
139908: LIST
139909: PUSH
139910: LD_INT 25
139912: PUSH
139913: LD_INT 8
139915: PUSH
139916: EMPTY
139917: LIST
139918: LIST
139919: PUSH
139920: LD_INT 25
139922: PUSH
139923: LD_INT 9
139925: PUSH
139926: EMPTY
139927: LIST
139928: LIST
139929: PUSH
139930: EMPTY
139931: LIST
139932: LIST
139933: LIST
139934: LIST
139935: LIST
139936: PPUSH
139937: CALL_OW 72
139941: DIFF
139942: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
139943: LD_VAR 0 21
139947: NOT
139948: PUSH
139949: LD_VAR 0 2
139953: PPUSH
139954: LD_INT 21
139956: PUSH
139957: LD_INT 2
139959: PUSH
139960: EMPTY
139961: LIST
139962: LIST
139963: PPUSH
139964: CALL_OW 72
139968: AND
139969: IFFALSE 140307
// begin tmp := FilterByTag ( defenders , 19 ) ;
139971: LD_ADDR_VAR 0 11
139975: PUSH
139976: LD_VAR 0 2
139980: PPUSH
139981: LD_INT 19
139983: PPUSH
139984: CALL 104851 0 2
139988: ST_TO_ADDR
// if tmp then
139989: LD_VAR 0 11
139993: IFFALSE 140063
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
139995: LD_ADDR_VAR 0 11
139999: PUSH
140000: LD_VAR 0 11
140004: PPUSH
140005: LD_INT 25
140007: PUSH
140008: LD_INT 3
140010: PUSH
140011: EMPTY
140012: LIST
140013: LIST
140014: PPUSH
140015: CALL_OW 72
140019: ST_TO_ADDR
// if tmp then
140020: LD_VAR 0 11
140024: IFFALSE 140063
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
140026: LD_ADDR_EXP 114
140030: PUSH
140031: LD_EXP 114
140035: PPUSH
140036: LD_VAR 0 1
140040: PPUSH
140041: LD_EXP 114
140045: PUSH
140046: LD_VAR 0 1
140050: ARRAY
140051: PUSH
140052: LD_VAR 0 11
140056: UNION
140057: PPUSH
140058: CALL_OW 1
140062: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
140063: LD_VAR 0 1
140067: PPUSH
140068: LD_INT 19
140070: PPUSH
140071: CALL 43052 0 2
// repeat wait ( 0 0$1 ) ;
140075: LD_INT 35
140077: PPUSH
140078: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140082: LD_EXP 102
140086: PUSH
140087: LD_VAR 0 1
140091: ARRAY
140092: NOT
140093: PUSH
140094: LD_EXP 102
140098: PUSH
140099: LD_VAR 0 1
140103: ARRAY
140104: PUSH
140105: EMPTY
140106: EQUAL
140107: OR
140108: IFFALSE 140145
// begin for i in defenders do
140110: LD_ADDR_VAR 0 4
140114: PUSH
140115: LD_VAR 0 2
140119: PUSH
140120: FOR_IN
140121: IFFALSE 140134
// ComStop ( i ) ;
140123: LD_VAR 0 4
140127: PPUSH
140128: CALL_OW 141
140132: GO 140120
140134: POP
140135: POP
// defenders := [ ] ;
140136: LD_ADDR_VAR 0 2
140140: PUSH
140141: EMPTY
140142: ST_TO_ADDR
// exit ;
140143: GO 140371
// end ; for i in defenders do
140145: LD_ADDR_VAR 0 4
140149: PUSH
140150: LD_VAR 0 2
140154: PUSH
140155: FOR_IN
140156: IFFALSE 140245
// begin if not IsInArea ( i , mc_parking [ base ] ) then
140158: LD_VAR 0 4
140162: PPUSH
140163: LD_EXP 126
140167: PUSH
140168: LD_VAR 0 1
140172: ARRAY
140173: PPUSH
140174: CALL_OW 308
140178: NOT
140179: IFFALSE 140203
// ComMoveToArea ( i , mc_parking [ base ] ) else
140181: LD_VAR 0 4
140185: PPUSH
140186: LD_EXP 126
140190: PUSH
140191: LD_VAR 0 1
140195: ARRAY
140196: PPUSH
140197: CALL_OW 113
140201: GO 140243
// if GetControl ( i ) = control_manual then
140203: LD_VAR 0 4
140207: PPUSH
140208: CALL_OW 263
140212: PUSH
140213: LD_INT 1
140215: EQUAL
140216: IFFALSE 140243
// if IsDrivenBy ( i ) then
140218: LD_VAR 0 4
140222: PPUSH
140223: CALL_OW 311
140227: IFFALSE 140243
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
140229: LD_VAR 0 4
140233: PPUSH
140234: CALL_OW 311
140238: PPUSH
140239: CALL_OW 121
// end ;
140243: GO 140155
140245: POP
140246: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
140247: LD_VAR 0 2
140251: PPUSH
140252: LD_INT 95
140254: PUSH
140255: LD_EXP 126
140259: PUSH
140260: LD_VAR 0 1
140264: ARRAY
140265: PUSH
140266: EMPTY
140267: LIST
140268: LIST
140269: PPUSH
140270: CALL_OW 72
140274: PUSH
140275: LD_VAR 0 2
140279: EQUAL
140280: PUSH
140281: LD_EXP 125
140285: PUSH
140286: LD_VAR 0 1
140290: ARRAY
140291: OR
140292: PUSH
140293: LD_EXP 102
140297: PUSH
140298: LD_VAR 0 1
140302: ARRAY
140303: NOT
140304: OR
140305: IFFALSE 140075
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
140307: LD_ADDR_EXP 124
140311: PUSH
140312: LD_EXP 124
140316: PPUSH
140317: LD_VAR 0 1
140321: PPUSH
140322: LD_VAR 0 2
140326: PPUSH
140327: LD_INT 21
140329: PUSH
140330: LD_INT 2
140332: PUSH
140333: EMPTY
140334: LIST
140335: LIST
140336: PPUSH
140337: CALL_OW 72
140341: PPUSH
140342: CALL_OW 1
140346: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
140347: LD_VAR 0 1
140351: PPUSH
140352: LD_INT 19
140354: PPUSH
140355: CALL 43052 0 2
// MC_Reset ( base , 20 ) ;
140359: LD_VAR 0 1
140363: PPUSH
140364: LD_INT 20
140366: PPUSH
140367: CALL 43052 0 2
// end ; end_of_file
140371: LD_VAR 0 3
140375: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
140376: LD_VAR 0 1
140380: PUSH
140381: LD_INT 200
140383: DOUBLE
140384: GREATEREQUAL
140385: IFFALSE 140393
140387: LD_INT 299
140389: DOUBLE
140390: LESSEQUAL
140391: IFTRUE 140395
140393: GO 140427
140395: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
140396: LD_VAR 0 1
140400: PPUSH
140401: LD_VAR 0 2
140405: PPUSH
140406: LD_VAR 0 3
140410: PPUSH
140411: LD_VAR 0 4
140415: PPUSH
140416: LD_VAR 0 5
140420: PPUSH
140421: CALL 128557 0 5
140425: GO 140504
140427: LD_INT 300
140429: DOUBLE
140430: GREATEREQUAL
140431: IFFALSE 140439
140433: LD_INT 399
140435: DOUBLE
140436: LESSEQUAL
140437: IFTRUE 140441
140439: GO 140503
140441: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
140442: LD_VAR 0 1
140446: PPUSH
140447: LD_VAR 0 2
140451: PPUSH
140452: LD_VAR 0 3
140456: PPUSH
140457: LD_VAR 0 4
140461: PPUSH
140462: LD_VAR 0 5
140466: PPUSH
140467: LD_VAR 0 6
140471: PPUSH
140472: LD_VAR 0 7
140476: PPUSH
140477: LD_VAR 0 8
140481: PPUSH
140482: LD_VAR 0 9
140486: PPUSH
140487: LD_VAR 0 10
140491: PPUSH
140492: LD_VAR 0 11
140496: PPUSH
140497: CALL 124882 0 11
140501: GO 140504
140503: POP
// end ;
140504: PPOPN 11
140506: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
140507: LD_VAR 0 1
140511: PPUSH
140512: LD_VAR 0 2
140516: PPUSH
140517: LD_VAR 0 3
140521: PPUSH
140522: LD_VAR 0 4
140526: PPUSH
140527: LD_VAR 0 5
140531: PPUSH
140532: CALL 128293 0 5
// end ; end_of_file
140536: PPOPN 5
140538: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
140539: LD_VAR 0 1
140543: PPUSH
140544: LD_VAR 0 2
140548: PPUSH
140549: LD_VAR 0 3
140553: PPUSH
140554: LD_VAR 0 4
140558: PPUSH
140559: LD_VAR 0 5
140563: PPUSH
140564: LD_VAR 0 6
140568: PPUSH
140569: CALL 112534 0 6
// end ;
140573: PPOPN 6
140575: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
140576: LD_INT 0
140578: PPUSH
// begin if not units then
140579: LD_VAR 0 1
140583: NOT
140584: IFFALSE 140588
// exit ;
140586: GO 140588
// end ;
140588: PPOPN 7
140590: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
140591: CALL 112421 0 0
// end ;
140595: PPOPN 1
140597: END
