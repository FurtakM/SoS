// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34229 0 0
// InitNature ;
  19: CALL 34053 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10958 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2935 0 0
// PrepareAmerican ;
  52: CALL 1707 0 0
// Action ;
  56: CALL 14865 0 0
// MC_Start ( ) ;
  60: CALL 36341 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58722 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58815 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 58165 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57980 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58722 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58815 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57980 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 58165 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58595 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57662 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58722 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58815 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57980 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58722 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58815 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57872 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 59133 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58304 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58595 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58595 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58927 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57980 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58546 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// every 0 0$1 trigger allianceDestroyed and not capturedUnit do
1683: LD_EXP 23
1687: PUSH
1688: LD_EXP 34
1692: NOT
1693: AND
1694: IFFALSE 1706
1696: GO 1698
1698: DISABLE
// SetAchievement ( ACH_ALLIANCE ) ; end_of_file
1699: LD_STRING ACH_ALLIANCE
1701: PPUSH
1702: CALL_OW 543
1706: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1707: LD_INT 0
1709: PPUSH
// uc_side := 1 ;
1710: LD_ADDR_OWVAR 20
1714: PUSH
1715: LD_INT 1
1717: ST_TO_ADDR
// uc_nation := 1 ;
1718: LD_ADDR_OWVAR 21
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1726: LD_ADDR_EXP 38
1730: PUSH
1731: LD_STRING JMM
1733: PPUSH
1734: LD_EXP 1
1738: NOT
1739: PPUSH
1740: LD_STRING 14_
1742: PPUSH
1743: CALL 64372 0 3
1747: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1748: LD_EXP 4
1752: NOT
1753: PUSH
1754: LD_EXP 4
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PUSH
1763: LD_INT 1
1765: ARRAY
1766: NOT
1767: OR
1768: IFFALSE 1791
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 1
1778: PPUSH
1779: LD_INT 5
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 71487 0 5
1789: GO 1850
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1791: LD_EXP 4
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PUSH
1800: LD_INT 1
1802: ARRAY
1803: PPUSH
1804: LD_EXP 4
1808: PUSH
1809: LD_INT 2
1811: ARRAY
1812: PUSH
1813: LD_INT 1
1815: ARRAY
1816: PPUSH
1817: LD_EXP 4
1821: PUSH
1822: LD_INT 3
1824: ARRAY
1825: PUSH
1826: LD_INT 1
1828: ARRAY
1829: PPUSH
1830: LD_EXP 4
1834: PUSH
1835: LD_INT 4
1837: ARRAY
1838: PUSH
1839: LD_INT 1
1841: ARRAY
1842: PPUSH
1843: LD_INT 30
1845: PPUSH
1846: CALL 71487 0 5
// JMMNewVeh := CreateVehicle ;
1850: LD_ADDR_EXP 55
1854: PUSH
1855: CALL_OW 45
1859: ST_TO_ADDR
// if not JMMNewVeh then
1860: LD_EXP 55
1864: NOT
1865: IFFALSE 1896
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 1
1875: PPUSH
1876: LD_INT 5
1878: PPUSH
1879: LD_INT 100
1881: PPUSH
1882: CALL 71487 0 5
// JMMNewVeh := CreateVehicle ;
1886: LD_ADDR_EXP 55
1890: PUSH
1891: CALL_OW 45
1895: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1896: LD_EXP 55
1900: PPUSH
1901: LD_INT 4
1903: PPUSH
1904: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1908: LD_EXP 55
1912: PPUSH
1913: LD_INT 79
1915: PPUSH
1916: LD_INT 91
1918: PPUSH
1919: LD_INT 0
1921: PPUSH
1922: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1926: LD_EXP 38
1930: PPUSH
1931: LD_EXP 55
1935: PPUSH
1936: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1940: LD_EXP 6
1944: PUSH
1945: LD_EXP 2
1949: NOT
1950: AND
1951: IFFALSE 2209
// begin if not JMMGirlVeh then
1953: LD_EXP 5
1957: NOT
1958: IFFALSE 1981
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1960: LD_INT 3
1962: PPUSH
1963: LD_INT 3
1965: PPUSH
1966: LD_INT 1
1968: PPUSH
1969: LD_INT 9
1971: PPUSH
1972: LD_INT 100
1974: PPUSH
1975: CALL 71487 0 5
1979: GO 2040
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1981: LD_EXP 5
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_EXP 5
1998: PUSH
1999: LD_INT 2
2001: ARRAY
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: PPUSH
2007: LD_EXP 5
2011: PUSH
2012: LD_INT 3
2014: ARRAY
2015: PUSH
2016: LD_INT 1
2018: ARRAY
2019: PPUSH
2020: LD_EXP 5
2024: PUSH
2025: LD_INT 4
2027: ARRAY
2028: PUSH
2029: LD_INT 1
2031: ARRAY
2032: PPUSH
2033: LD_INT 30
2035: PPUSH
2036: CALL 71487 0 5
// GirlNewVeh := CreateVehicle ;
2040: LD_ADDR_EXP 56
2044: PUSH
2045: CALL_OW 45
2049: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2050: LD_EXP 56
2054: PPUSH
2055: LD_INT 4
2057: PPUSH
2058: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2062: LD_EXP 56
2066: PPUSH
2067: LD_INT 82
2069: PPUSH
2070: LD_INT 96
2072: PPUSH
2073: LD_INT 0
2075: PPUSH
2076: CALL_OW 48
// if JMMGirl = 1 then
2080: LD_EXP 7
2084: PUSH
2085: LD_INT 1
2087: EQUAL
2088: IFFALSE 2123
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2090: LD_ADDR_EXP 39
2094: PUSH
2095: LD_STRING Joan
2097: PPUSH
2098: LD_INT 1
2100: PPUSH
2101: LD_STRING 14_
2103: PPUSH
2104: CALL 64372 0 3
2108: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2109: LD_EXP 39
2113: PPUSH
2114: LD_EXP 56
2118: PPUSH
2119: CALL_OW 52
// end ; if JMMGirl = 2 then
2123: LD_EXP 7
2127: PUSH
2128: LD_INT 2
2130: EQUAL
2131: IFFALSE 2166
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2133: LD_ADDR_EXP 41
2137: PUSH
2138: LD_STRING Lisa
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: LD_STRING 14_
2146: PPUSH
2147: CALL 64372 0 3
2151: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2152: LD_EXP 41
2156: PPUSH
2157: LD_EXP 56
2161: PPUSH
2162: CALL_OW 52
// end ; if JMMGirl = 3 then
2166: LD_EXP 7
2170: PUSH
2171: LD_INT 3
2173: EQUAL
2174: IFFALSE 2209
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2176: LD_ADDR_EXP 53
2180: PUSH
2181: LD_STRING Connie
2183: PPUSH
2184: LD_INT 1
2186: PPUSH
2187: LD_STRING 14_
2189: PPUSH
2190: CALL 64372 0 3
2194: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2195: LD_EXP 53
2199: PPUSH
2200: LD_EXP 56
2204: PPUSH
2205: CALL_OW 52
// end ; end ; end ;
2209: LD_VAR 0 1
2213: RET
// export function PrepareStevensSquad ; var tmp ; begin
2214: LD_INT 0
2216: PPUSH
2217: PPUSH
// uc_side := 1 ;
2218: LD_ADDR_OWVAR 20
2222: PUSH
2223: LD_INT 1
2225: ST_TO_ADDR
// uc_nation := 1 ;
2226: LD_ADDR_OWVAR 21
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// tmp := [ ] ;
2234: LD_ADDR_VAR 0 2
2238: PUSH
2239: EMPTY
2240: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2241: LD_ADDR_EXP 40
2245: PUSH
2246: LD_STRING Stevens
2248: PPUSH
2249: LD_EXP 1
2253: NOT
2254: PPUSH
2255: LD_STRING 13f_
2257: PPUSH
2258: CALL 64372 0 3
2262: ST_TO_ADDR
// if not Stevens then
2263: LD_EXP 40
2267: NOT
2268: IFFALSE 2324
// begin hc_name = Baker Smith ;
2270: LD_ADDR_OWVAR 26
2274: PUSH
2275: LD_STRING Baker Smith
2277: ST_TO_ADDR
// hc_gallery =  ;
2278: LD_ADDR_OWVAR 33
2282: PUSH
2283: LD_STRING 
2285: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2286: LD_INT 1
2288: PPUSH
2289: LD_INT 10
2291: PPUSH
2292: CALL_OW 384
// Baker = CreateHuman ;
2296: LD_ADDR_EXP 54
2300: PUSH
2301: CALL_OW 44
2305: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2306: LD_ADDR_VAR 0 2
2310: PUSH
2311: LD_VAR 0 2
2315: PUSH
2316: LD_EXP 54
2320: ADD
2321: ST_TO_ADDR
// end else
2322: GO 2340
// tmp := tmp ^ Stevens ;
2324: LD_ADDR_VAR 0 2
2328: PUSH
2329: LD_VAR 0 2
2333: PUSH
2334: LD_EXP 40
2338: ADD
2339: ST_TO_ADDR
// if not Lisa then
2340: LD_EXP 41
2344: NOT
2345: IFFALSE 2391
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2347: LD_ADDR_EXP 41
2351: PUSH
2352: LD_STRING Lisa
2354: PPUSH
2355: LD_EXP 1
2359: NOT
2360: PPUSH
2361: LD_STRING 13f_
2363: PPUSH
2364: CALL 64372 0 3
2368: ST_TO_ADDR
// if Lisa then
2369: LD_EXP 41
2373: IFFALSE 2391
// tmp := tmp ^ Lisa ;
2375: LD_ADDR_VAR 0 2
2379: PUSH
2380: LD_VAR 0 2
2384: PUSH
2385: LD_EXP 41
2389: ADD
2390: ST_TO_ADDR
// end ; if not Donaldson then
2391: LD_EXP 42
2395: NOT
2396: IFFALSE 2442
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2398: LD_ADDR_EXP 42
2402: PUSH
2403: LD_STRING Donaldson
2405: PPUSH
2406: LD_EXP 1
2410: NOT
2411: PPUSH
2412: LD_STRING 13f_
2414: PPUSH
2415: CALL 64372 0 3
2419: ST_TO_ADDR
// if Donaldson then
2420: LD_EXP 42
2424: IFFALSE 2442
// tmp := tmp ^ Donaldson ;
2426: LD_ADDR_VAR 0 2
2430: PUSH
2431: LD_VAR 0 2
2435: PUSH
2436: LD_EXP 42
2440: ADD
2441: ST_TO_ADDR
// end ; if not Bobby then
2442: LD_EXP 43
2446: NOT
2447: IFFALSE 2493
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2449: LD_ADDR_EXP 43
2453: PUSH
2454: LD_STRING Bobby
2456: PPUSH
2457: LD_EXP 1
2461: NOT
2462: PPUSH
2463: LD_STRING 13f_
2465: PPUSH
2466: CALL 64372 0 3
2470: ST_TO_ADDR
// if Bobby then
2471: LD_EXP 43
2475: IFFALSE 2493
// tmp := tmp ^ Bobby ;
2477: LD_ADDR_VAR 0 2
2481: PUSH
2482: LD_VAR 0 2
2486: PUSH
2487: LD_EXP 43
2491: ADD
2492: ST_TO_ADDR
// end ; if not Cyrus then
2493: LD_EXP 44
2497: NOT
2498: IFFALSE 2544
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2500: LD_ADDR_EXP 44
2504: PUSH
2505: LD_STRING Cyrus
2507: PPUSH
2508: LD_EXP 1
2512: NOT
2513: PPUSH
2514: LD_STRING 13f_
2516: PPUSH
2517: CALL 64372 0 3
2521: ST_TO_ADDR
// if Cyrus then
2522: LD_EXP 44
2526: IFFALSE 2544
// tmp := tmp ^ Cyrus ;
2528: LD_ADDR_VAR 0 2
2532: PUSH
2533: LD_VAR 0 2
2537: PUSH
2538: LD_EXP 44
2542: ADD
2543: ST_TO_ADDR
// end ; if not Brown then
2544: LD_EXP 46
2548: NOT
2549: IFFALSE 2595
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2551: LD_ADDR_EXP 46
2555: PUSH
2556: LD_STRING Brown
2558: PPUSH
2559: LD_EXP 1
2563: NOT
2564: PPUSH
2565: LD_STRING 13f_
2567: PPUSH
2568: CALL 64372 0 3
2572: ST_TO_ADDR
// if Brown then
2573: LD_EXP 46
2577: IFFALSE 2595
// tmp := tmp ^ Brown ;
2579: LD_ADDR_VAR 0 2
2583: PUSH
2584: LD_VAR 0 2
2588: PUSH
2589: LD_EXP 46
2593: ADD
2594: ST_TO_ADDR
// end ; if not Gladstone then
2595: LD_EXP 47
2599: NOT
2600: IFFALSE 2646
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2602: LD_ADDR_EXP 47
2606: PUSH
2607: LD_STRING Gladstone
2609: PPUSH
2610: LD_EXP 1
2614: NOT
2615: PPUSH
2616: LD_STRING 13f_
2618: PPUSH
2619: CALL 64372 0 3
2623: ST_TO_ADDR
// if Gladstone then
2624: LD_EXP 47
2628: IFFALSE 2646
// tmp := tmp ^ Gladstone ;
2630: LD_ADDR_VAR 0 2
2634: PUSH
2635: LD_VAR 0 2
2639: PUSH
2640: LD_EXP 47
2644: ADD
2645: ST_TO_ADDR
// end ; if not Houten then
2646: LD_EXP 48
2650: NOT
2651: IFFALSE 2697
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2653: LD_ADDR_EXP 48
2657: PUSH
2658: LD_STRING Houten
2660: PPUSH
2661: LD_EXP 1
2665: NOT
2666: PPUSH
2667: LD_STRING 13f_
2669: PPUSH
2670: CALL 64372 0 3
2674: ST_TO_ADDR
// if Houten then
2675: LD_EXP 48
2679: IFFALSE 2697
// tmp := tmp ^ Houten ;
2681: LD_ADDR_VAR 0 2
2685: PUSH
2686: LD_VAR 0 2
2690: PUSH
2691: LD_EXP 48
2695: ADD
2696: ST_TO_ADDR
// end ; if not Cornel then
2697: LD_EXP 49
2701: NOT
2702: IFFALSE 2748
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2704: LD_ADDR_EXP 49
2708: PUSH
2709: LD_STRING Cornel
2711: PPUSH
2712: LD_EXP 1
2716: NOT
2717: PPUSH
2718: LD_STRING 13f_
2720: PPUSH
2721: CALL 64372 0 3
2725: ST_TO_ADDR
// if Cornel then
2726: LD_EXP 49
2730: IFFALSE 2748
// tmp := tmp ^ Cornel ;
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 2
2741: PUSH
2742: LD_EXP 49
2746: ADD
2747: ST_TO_ADDR
// end ; if not Gary then
2748: LD_EXP 50
2752: NOT
2753: IFFALSE 2799
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2755: LD_ADDR_EXP 50
2759: PUSH
2760: LD_STRING Gary
2762: PPUSH
2763: LD_EXP 1
2767: NOT
2768: PPUSH
2769: LD_STRING 13f_
2771: PPUSH
2772: CALL 64372 0 3
2776: ST_TO_ADDR
// if Gary then
2777: LD_EXP 50
2781: IFFALSE 2799
// tmp := tmp ^ Gary ;
2783: LD_ADDR_VAR 0 2
2787: PUSH
2788: LD_VAR 0 2
2792: PUSH
2793: LD_EXP 50
2797: ADD
2798: ST_TO_ADDR
// end ; if not Frank then
2799: LD_EXP 51
2803: NOT
2804: IFFALSE 2850
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2806: LD_ADDR_EXP 51
2810: PUSH
2811: LD_STRING Frank
2813: PPUSH
2814: LD_EXP 1
2818: NOT
2819: PPUSH
2820: LD_STRING 13f_
2822: PPUSH
2823: CALL 64372 0 3
2827: ST_TO_ADDR
// if Frank then
2828: LD_EXP 51
2832: IFFALSE 2850
// tmp := tmp ^ Frank ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_EXP 51
2848: ADD
2849: ST_TO_ADDR
// end ; if not Kikuchi then
2850: LD_EXP 52
2854: NOT
2855: IFFALSE 2901
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2857: LD_ADDR_EXP 52
2861: PUSH
2862: LD_STRING Kikuchi
2864: PPUSH
2865: LD_EXP 1
2869: NOT
2870: PPUSH
2871: LD_STRING 13f_
2873: PPUSH
2874: CALL 64372 0 3
2878: ST_TO_ADDR
// if Kikuchi then
2879: LD_EXP 52
2883: IFFALSE 2901
// tmp := tmp ^ Kikuchi ;
2885: LD_ADDR_VAR 0 2
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: LD_EXP 52
2899: ADD
2900: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2901: LD_ADDR_VAR 0 2
2905: PUSH
2906: LD_VAR 0 2
2910: PUSH
2911: LD_STRING 13_other_survivors
2913: PPUSH
2914: CALL_OW 31
2918: UNION
2919: ST_TO_ADDR
// result := tmp ;
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: ST_TO_ADDR
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
2943: PPUSH
2944: PPUSH
2945: PPUSH
2946: PPUSH
// uc_side := 4 ;
2947: LD_ADDR_OWVAR 20
2951: PUSH
2952: LD_INT 4
2954: ST_TO_ADDR
// uc_nation := 1 ;
2955: LD_ADDR_OWVAR 21
2959: PUSH
2960: LD_INT 1
2962: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2963: LD_INT 387
2965: PPUSH
2966: CALL_OW 274
2970: PPUSH
2971: LD_INT 1
2973: PPUSH
2974: LD_INT 2500
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 57
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 57
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 57
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 58
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 41
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64372 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 41
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 41
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 42
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64372 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 42
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 42
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 43
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64372 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 43
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 43
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 44
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64372 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 44
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 44
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 45
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64372 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 45
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 45
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64372 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 45
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 45
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 46
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64372 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 46
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 46
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 47
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64372 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 47
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 47
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 48
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64372 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 48
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 48
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 49
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64372 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 49
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 49
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 50
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64372 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 50
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 50
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 51
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64372 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 51
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 51
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 52
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64372 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 52
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 52
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 58
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 71487 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 59
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64372 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 59
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64372 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 59
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 59
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 59
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 60
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64372 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 60
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 60
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 74896 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 101
4699: PUSH
4700: LD_EXP 101
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 59
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 61
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 71487 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 62
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 62
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 60
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 60
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 60
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 60
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 60
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 60
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 60
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 60
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 60
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 60
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 60
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 60
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 60
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58165 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58028 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 59446 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58028 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58028 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 59446 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 59446 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 120
5983: PUSH
5984: LD_EXP 120
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 120
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 71487 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 63
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 64
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7120: LD_ADDR_EXP 66
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: CALL_OW 25
7132: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7133: LD_ADDR_EXP 65
7137: PUSH
7138: LD_STRING Bystrov
7140: PPUSH
7141: CALL_OW 25
7145: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7146: LD_ADDR_EXP 67
7150: PUSH
7151: LD_STRING Gleb
7153: PPUSH
7154: CALL_OW 25
7158: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7159: LD_STRING 03_Cornel
7161: PPUSH
7162: CALL_OW 28
7166: IFFALSE 7214
// begin Bierezov := NewCharacter ( Mikhail ) ;
7168: LD_ADDR_EXP 68
7172: PUSH
7173: LD_STRING Mikhail
7175: PPUSH
7176: CALL_OW 25
7180: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7181: LD_EXP 68
7185: PPUSH
7186: LD_INT 197
7188: PPUSH
7189: LD_INT 111
7191: PPUSH
7192: LD_INT 9
7194: PPUSH
7195: LD_INT 0
7197: PPUSH
7198: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7202: LD_EXP 68
7206: PPUSH
7207: LD_INT 3
7209: PPUSH
7210: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7214: LD_EXP 63
7218: PPUSH
7219: LD_INT 126
7221: PPUSH
7222: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7226: LD_EXP 64
7230: PPUSH
7231: LD_INT 134
7233: PPUSH
7234: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7238: LD_EXP 66
7242: PPUSH
7243: LD_INT 197
7245: PPUSH
7246: LD_INT 111
7248: PPUSH
7249: LD_INT 9
7251: PPUSH
7252: LD_INT 0
7254: PPUSH
7255: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7259: LD_EXP 65
7263: PPUSH
7264: LD_INT 197
7266: PPUSH
7267: LD_INT 111
7269: PPUSH
7270: LD_INT 9
7272: PPUSH
7273: LD_INT 0
7275: PPUSH
7276: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7280: LD_EXP 67
7284: PPUSH
7285: LD_INT 197
7287: PPUSH
7288: LD_INT 111
7290: PPUSH
7291: LD_INT 9
7293: PPUSH
7294: LD_INT 0
7296: PPUSH
7297: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7301: LD_ADDR_VAR 0 5
7305: PUSH
7306: LD_INT 126
7308: PPUSH
7309: LD_INT 4
7311: PPUSH
7312: LD_STRING zhukov
7314: PPUSH
7315: LD_INT 9
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: PUSH
7329: LD_OWVAR 67
7333: ARRAY
7334: PPUSH
7335: LD_INT 90000
7337: PUSH
7338: LD_INT 1000
7340: PUSH
7341: LD_INT 300
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: PPUSH
7349: LD_INT 21
7351: PUSH
7352: LD_INT 8
7354: PUSH
7355: LD_INT 13
7357: PUSH
7358: LD_INT 8
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PPUSH
7367: CALL 74896 0 6
7371: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7372: LD_ADDR_VAR 0 4
7376: PUSH
7377: LD_INT 267
7379: PPUSH
7380: CALL_OW 274
7384: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7385: LD_VAR 0 4
7389: PPUSH
7390: LD_INT 1
7392: PPUSH
7393: LD_INT 5000
7395: PPUSH
7396: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7400: LD_VAR 0 4
7404: PPUSH
7405: LD_INT 2
7407: PPUSH
7408: LD_INT 200
7410: PPUSH
7411: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7415: LD_VAR 0 4
7419: PPUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 200
7425: PPUSH
7426: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7430: LD_ADDR_EXP 101
7434: PUSH
7435: LD_EXP 101
7439: PPUSH
7440: LD_INT 2
7442: PPUSH
7443: LD_VAR 0 5
7447: PUSH
7448: LD_INT 22
7450: PUSH
7451: LD_VAR 0 6
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 3
7462: PUSH
7463: LD_INT 21
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PPUSH
7481: CALL_OW 69
7485: UNION
7486: PUSH
7487: LD_EXP 63
7491: DIFF
7492: PPUSH
7493: CALL_OW 1
7497: ST_TO_ADDR
// behemoths := [ ] ;
7498: LD_ADDR_EXP 71
7502: PUSH
7503: EMPTY
7504: ST_TO_ADDR
// behemothBuilders := [ ] ;
7505: LD_ADDR_EXP 72
7509: PUSH
7510: EMPTY
7511: ST_TO_ADDR
// if Kovalyuk then
7512: LD_EXP 64
7516: IFFALSE 7538
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7518: LD_ADDR_EXP 72
7522: PUSH
7523: LD_EXP 72
7527: PPUSH
7528: LD_EXP 64
7532: PPUSH
7533: CALL 107232 0 2
7537: ST_TO_ADDR
// j := 3 ;
7538: LD_ADDR_VAR 0 3
7542: PUSH
7543: LD_INT 3
7545: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7546: LD_ADDR_VAR 0 2
7550: PUSH
7551: LD_INT 22
7553: PUSH
7554: LD_INT 3
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 25
7563: PUSH
7564: LD_INT 3
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PPUSH
7575: CALL_OW 69
7579: PUSH
7580: LD_EXP 64
7584: DIFF
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7637
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7589: LD_ADDR_EXP 72
7593: PUSH
7594: LD_EXP 72
7598: PPUSH
7599: LD_VAR 0 2
7603: PPUSH
7604: CALL 107232 0 2
7608: ST_TO_ADDR
// j := j - 1 ;
7609: LD_ADDR_VAR 0 3
7613: PUSH
7614: LD_VAR 0 3
7618: PUSH
7619: LD_INT 1
7621: MINUS
7622: ST_TO_ADDR
// if j = 0 then
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 0
7630: EQUAL
7631: IFFALSE 7635
// break ;
7633: GO 7637
// end ;
7635: GO 7586
7637: POP
7638: POP
// end ;
7639: LD_VAR 0 1
7643: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7644: LD_INT 0
7646: PPUSH
7647: PPUSH
7648: PPUSH
7649: PPUSH
7650: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7651: LD_ADDR_VAR 0 4
7655: PUSH
7656: LD_INT 209
7658: PUSH
7659: LD_INT 149
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: LD_INT 219
7668: PUSH
7669: LD_INT 154
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PUSH
7676: LD_INT 223
7678: PUSH
7679: LD_INT 149
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 232
7688: PUSH
7689: LD_INT 155
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
// if not behemothBuilders then
7702: LD_EXP 72
7706: NOT
7707: IFFALSE 7711
// exit ;
7709: GO 7815
// j := 1 ;
7711: LD_ADDR_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: ST_TO_ADDR
// for i in behemothBuilders do
7719: LD_ADDR_VAR 0 2
7723: PUSH
7724: LD_EXP 72
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7813
// begin if IsInUnit ( i ) then
7732: LD_VAR 0 2
7736: PPUSH
7737: CALL_OW 310
7741: IFFALSE 7752
// ComExitBuilding ( i ) ;
7743: LD_VAR 0 2
7747: PPUSH
7748: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: LD_INT 37
7759: PPUSH
7760: LD_VAR 0 4
7764: PUSH
7765: LD_VAR 0 3
7769: ARRAY
7770: PUSH
7771: LD_INT 1
7773: ARRAY
7774: PPUSH
7775: LD_VAR 0 4
7779: PUSH
7780: LD_VAR 0 3
7784: ARRAY
7785: PUSH
7786: LD_INT 2
7788: ARRAY
7789: PPUSH
7790: LD_INT 0
7792: PPUSH
7793: CALL_OW 230
// j := j + 1 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_VAR 0 3
7806: PUSH
7807: LD_INT 1
7809: PLUS
7810: ST_TO_ADDR
// end ;
7811: GO 7729
7813: POP
7814: POP
// end ;
7815: LD_VAR 0 1
7819: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7820: LD_INT 24
7822: PPUSH
7823: LD_INT 30
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 70
7837: IFFALSE 7850
7839: GO 7841
7841: DISABLE
// behemothUnderConstruct := true ;
7842: LD_ADDR_EXP 26
7846: PUSH
7847: LD_INT 1
7849: ST_TO_ADDR
7850: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7851: LD_INT 3
7853: PPUSH
7854: CALL 107280 0 1
7858: PUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 3
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PUSH
7869: LD_INT 30
7871: PUSH
7872: LD_INT 37
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PPUSH
7883: CALL_OW 69
7887: NOT
7888: AND
7889: IFFALSE 8075
7891: GO 7893
7893: DISABLE
7894: LD_INT 0
7896: PPUSH
7897: PPUSH
// begin enable ;
7898: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7899: LD_ADDR_VAR 0 2
7903: PUSH
7904: LD_INT 3
7906: PPUSH
7907: CALL 107280 0 1
7911: ST_TO_ADDR
// for i in tmp do
7912: LD_ADDR_VAR 0 1
7916: PUSH
7917: LD_VAR 0 2
7921: PUSH
7922: FOR_IN
7923: IFFALSE 8073
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7925: LD_VAR 0 1
7929: PPUSH
7930: LD_INT 9
7932: PPUSH
7933: CALL_OW 308
7937: PUSH
7938: LD_VAR 0 1
7942: PPUSH
7943: CALL_OW 110
7947: PUSH
7948: LD_INT 2
7950: EQUAL
7951: NOT
7952: AND
7953: IFFALSE 7967
// SetTag ( i , 2 ) ;
7955: LD_VAR 0 1
7959: PPUSH
7960: LD_INT 2
7962: PPUSH
7963: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7967: LD_INT 81
7969: PUSH
7970: LD_INT 3
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PUSH
7977: LD_INT 91
7979: PUSH
7980: LD_VAR 0 1
7984: PUSH
7985: LD_INT 12
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: PPUSH
7997: CALL_OW 69
8001: NOT
8002: PUSH
8003: LD_VAR 0 1
8007: PPUSH
8008: CALL_OW 110
8012: PUSH
8013: LD_INT 2
8015: EQUAL
8016: NOT
8017: AND
8018: IFFALSE 8037
// ComAgressiveMove ( i , 64 , 93 ) else
8020: LD_VAR 0 1
8024: PPUSH
8025: LD_INT 64
8027: PPUSH
8028: LD_INT 93
8030: PPUSH
8031: CALL_OW 114
8035: GO 8071
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8037: LD_VAR 0 1
8041: PPUSH
8042: LD_INT 81
8044: PUSH
8045: LD_INT 3
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PPUSH
8052: CALL_OW 69
8056: PPUSH
8057: LD_VAR 0 1
8061: PPUSH
8062: CALL_OW 74
8066: PPUSH
8067: CALL_OW 115
// end ;
8071: GO 7922
8073: POP
8074: POP
// end ;
8075: PPOPN 2
8077: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8078: LD_INT 0
8080: PPUSH
8081: PPUSH
8082: PPUSH
// result := [ ] ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: EMPTY
8089: ST_TO_ADDR
// uc_side := 6 ;
8090: LD_ADDR_OWVAR 20
8094: PUSH
8095: LD_INT 6
8097: ST_TO_ADDR
// uc_nation := 3 ;
8098: LD_ADDR_OWVAR 21
8102: PUSH
8103: LD_INT 3
8105: ST_TO_ADDR
// case strength of 1 :
8106: LD_VAR 0 1
8110: PUSH
8111: LD_INT 1
8113: DOUBLE
8114: EQUAL
8115: IFTRUE 8119
8117: GO 8257
8119: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8120: LD_ADDR_VAR 0 3
8124: PUSH
8125: DOUBLE
8126: LD_INT 1
8128: DEC
8129: ST_TO_ADDR
8130: LD_INT 4
8132: PUSH
8133: LD_INT 5
8135: PUSH
8136: LD_INT 6
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8253
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8153: LD_INT 22
8155: PUSH
8156: LD_INT 24
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_INT 2
8170: MOD
8171: PUSH
8172: LD_INT 1
8174: PLUS
8175: ARRAY
8176: PPUSH
8177: LD_INT 1
8179: PUSH
8180: LD_INT 3
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 1
8189: PPUSH
8190: LD_INT 2
8192: PPUSH
8193: CALL_OW 12
8197: ARRAY
8198: PPUSH
8199: LD_INT 3
8201: PPUSH
8202: LD_INT 43
8204: PUSH
8205: LD_INT 44
8207: PUSH
8208: LD_INT 45
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: PUSH
8216: LD_INT 1
8218: PPUSH
8219: LD_INT 3
8221: PPUSH
8222: CALL_OW 12
8226: ARRAY
8227: PPUSH
8228: LD_INT 80
8230: PPUSH
8231: CALL 71487 0 5
// result := result union CreateVehicle ;
8235: LD_ADDR_VAR 0 2
8239: PUSH
8240: LD_VAR 0 2
8244: PUSH
8245: CALL_OW 45
8249: UNION
8250: ST_TO_ADDR
// end ;
8251: GO 8150
8253: POP
8254: POP
// end ; 2 :
8255: GO 9201
8257: LD_INT 2
8259: DOUBLE
8260: EQUAL
8261: IFTRUE 8265
8263: GO 8421
8265: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8266: LD_ADDR_VAR 0 3
8270: PUSH
8271: DOUBLE
8272: LD_INT 1
8274: DEC
8275: ST_TO_ADDR
8276: LD_INT 5
8278: PUSH
8279: LD_INT 6
8281: PUSH
8282: LD_INT 7
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: LIST
8289: PUSH
8290: LD_OWVAR 67
8294: ARRAY
8295: PUSH
8296: FOR_TO
8297: IFFALSE 8417
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8299: LD_INT 22
8301: PUSH
8302: LD_INT 24
8304: PUSH
8305: LD_INT 24
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: LIST
8312: PUSH
8313: LD_VAR 0 3
8317: PUSH
8318: LD_INT 3
8320: MOD
8321: PUSH
8322: LD_INT 1
8324: PLUS
8325: ARRAY
8326: PPUSH
8327: LD_INT 1
8329: PUSH
8330: LD_INT 3
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_INT 1
8339: PPUSH
8340: LD_INT 2
8342: PPUSH
8343: CALL_OW 12
8347: ARRAY
8348: PPUSH
8349: LD_INT 3
8351: PPUSH
8352: LD_INT 43
8354: PUSH
8355: LD_INT 44
8357: PUSH
8358: LD_INT 45
8360: PUSH
8361: LD_INT 44
8363: PUSH
8364: LD_INT 46
8366: PUSH
8367: LD_INT 46
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: PUSH
8378: LD_VAR 0 3
8382: PUSH
8383: LD_INT 6
8385: MOD
8386: PUSH
8387: LD_INT 1
8389: PLUS
8390: ARRAY
8391: PPUSH
8392: LD_INT 80
8394: PPUSH
8395: CALL 71487 0 5
// result := result union CreateVehicle ;
8399: LD_ADDR_VAR 0 2
8403: PUSH
8404: LD_VAR 0 2
8408: PUSH
8409: CALL_OW 45
8413: UNION
8414: ST_TO_ADDR
// end ;
8415: GO 8296
8417: POP
8418: POP
// end ; 3 :
8419: GO 9201
8421: LD_INT 3
8423: DOUBLE
8424: EQUAL
8425: IFTRUE 8429
8427: GO 8585
8429: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8430: LD_ADDR_VAR 0 3
8434: PUSH
8435: DOUBLE
8436: LD_INT 1
8438: DEC
8439: ST_TO_ADDR
8440: LD_INT 5
8442: PUSH
8443: LD_INT 7
8445: PUSH
8446: LD_INT 8
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: LIST
8453: PUSH
8454: LD_OWVAR 67
8458: ARRAY
8459: PUSH
8460: FOR_TO
8461: IFFALSE 8581
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8463: LD_INT 22
8465: PUSH
8466: LD_INT 24
8468: PUSH
8469: LD_INT 24
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_VAR 0 3
8481: PUSH
8482: LD_INT 3
8484: MOD
8485: PUSH
8486: LD_INT 1
8488: PLUS
8489: ARRAY
8490: PPUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: LD_INT 1
8503: PPUSH
8504: LD_INT 2
8506: PPUSH
8507: CALL_OW 12
8511: ARRAY
8512: PPUSH
8513: LD_INT 3
8515: PPUSH
8516: LD_INT 43
8518: PUSH
8519: LD_INT 47
8521: PUSH
8522: LD_INT 45
8524: PUSH
8525: LD_INT 45
8527: PUSH
8528: LD_INT 46
8530: PUSH
8531: LD_INT 46
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: LIST
8540: LIST
8541: PUSH
8542: LD_VAR 0 3
8546: PUSH
8547: LD_INT 6
8549: MOD
8550: PUSH
8551: LD_INT 1
8553: PLUS
8554: ARRAY
8555: PPUSH
8556: LD_INT 80
8558: PPUSH
8559: CALL 71487 0 5
// result := result union CreateVehicle ;
8563: LD_ADDR_VAR 0 2
8567: PUSH
8568: LD_VAR 0 2
8572: PUSH
8573: CALL_OW 45
8577: UNION
8578: ST_TO_ADDR
// end ;
8579: GO 8460
8581: POP
8582: POP
// end ; 4 :
8583: GO 9201
8585: LD_INT 4
8587: DOUBLE
8588: EQUAL
8589: IFTRUE 8593
8591: GO 9200
8593: POP
// begin uc_nation := 3 ;
8594: LD_ADDR_OWVAR 21
8598: PUSH
8599: LD_INT 3
8601: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8602: LD_ADDR_VAR 0 3
8606: PUSH
8607: DOUBLE
8608: LD_INT 1
8610: DEC
8611: ST_TO_ADDR
8612: LD_INT 6
8614: PUSH
8615: LD_INT 8
8617: PUSH
8618: LD_INT 9
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: PUSH
8626: LD_OWVAR 67
8630: ARRAY
8631: PUSH
8632: FOR_TO
8633: IFFALSE 8753
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8635: LD_INT 22
8637: PUSH
8638: LD_INT 24
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: LIST
8648: PUSH
8649: LD_VAR 0 3
8653: PUSH
8654: LD_INT 3
8656: MOD
8657: PUSH
8658: LD_INT 1
8660: PLUS
8661: ARRAY
8662: PPUSH
8663: LD_INT 1
8665: PUSH
8666: LD_INT 3
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: PUSH
8673: LD_INT 1
8675: PPUSH
8676: LD_INT 2
8678: PPUSH
8679: CALL_OW 12
8683: ARRAY
8684: PPUSH
8685: LD_INT 3
8687: PPUSH
8688: LD_INT 45
8690: PUSH
8691: LD_INT 47
8693: PUSH
8694: LD_INT 47
8696: PUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 46
8702: PUSH
8703: LD_INT 46
8705: PUSH
8706: EMPTY
8707: LIST
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_VAR 0 3
8718: PUSH
8719: LD_INT 6
8721: MOD
8722: PUSH
8723: LD_INT 1
8725: PLUS
8726: ARRAY
8727: PPUSH
8728: LD_INT 80
8730: PPUSH
8731: CALL 71487 0 5
// result := result union CreateVehicle ;
8735: LD_ADDR_VAR 0 2
8739: PUSH
8740: LD_VAR 0 2
8744: PUSH
8745: CALL_OW 45
8749: UNION
8750: ST_TO_ADDR
// end ;
8751: GO 8632
8753: POP
8754: POP
// if not KappaStatus then
8755: LD_EXP 2
8759: NOT
8760: IFFALSE 8995
// begin uc_nation := 1 ;
8762: LD_ADDR_OWVAR 21
8766: PUSH
8767: LD_INT 1
8769: ST_TO_ADDR
// for i = 1 to 3 do
8770: LD_ADDR_VAR 0 3
8774: PUSH
8775: DOUBLE
8776: LD_INT 1
8778: DEC
8779: ST_TO_ADDR
8780: LD_INT 3
8782: PUSH
8783: FOR_TO
8784: IFFALSE 8920
// begin j := rand ( 0 , 1 ) ;
8786: LD_ADDR_VAR 0 4
8790: PUSH
8791: LD_INT 0
8793: PPUSH
8794: LD_INT 1
8796: PPUSH
8797: CALL_OW 12
8801: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8802: LD_INT 3
8804: PUSH
8805: LD_INT 5
8807: PUSH
8808: LD_INT 5
8810: PUSH
8811: LD_INT 4
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: PUSH
8820: LD_VAR 0 4
8824: PUSH
8825: LD_INT 1
8827: PPUSH
8828: LD_INT 3
8830: PPUSH
8831: CALL_OW 12
8835: PLUS
8836: ARRAY
8837: PPUSH
8838: LD_INT 1
8840: PUSH
8841: LD_INT 3
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 1
8850: PPUSH
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 12
8858: ARRAY
8859: PPUSH
8860: LD_INT 3
8862: PPUSH
8863: LD_INT 9
8865: PUSH
8866: LD_INT 7
8868: PUSH
8869: LD_INT 6
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: LIST
8876: PUSH
8877: LD_VAR 0 4
8881: PUSH
8882: LD_INT 1
8884: PPUSH
8885: LD_INT 2
8887: PPUSH
8888: CALL_OW 12
8892: PLUS
8893: ARRAY
8894: PPUSH
8895: LD_INT 85
8897: PPUSH
8898: CALL 71487 0 5
// result := result union CreateVehicle ;
8902: LD_ADDR_VAR 0 2
8906: PUSH
8907: LD_VAR 0 2
8911: PUSH
8912: CALL_OW 45
8916: UNION
8917: ST_TO_ADDR
// end ;
8918: GO 8783
8920: POP
8921: POP
// if vsevolodFirstAttack then
8922: LD_EXP 24
8926: IFFALSE 8993
// begin vsevolodFirstAttack := false ;
8928: LD_ADDR_EXP 24
8932: PUSH
8933: LD_INT 0
8935: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8936: LD_INT 5
8938: PPUSH
8939: LD_INT 3
8941: PPUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 6
8947: PPUSH
8948: LD_INT 100
8950: PPUSH
8951: CALL 71487 0 5
// sewiVeh := CreateVehicle ;
8955: LD_ADDR_EXP 70
8959: PUSH
8960: CALL_OW 45
8964: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8965: LD_EXP 70
8969: PPUSH
8970: LD_INT 1
8972: PPUSH
8973: CALL_OW 242
// result := result union sewiVeh ;
8977: LD_ADDR_VAR 0 2
8981: PUSH
8982: LD_VAR 0 2
8986: PUSH
8987: LD_EXP 70
8991: UNION
8992: ST_TO_ADDR
// end ; end else
8993: GO 9198
// if vsevolodFirstAttack then
8995: LD_EXP 24
8999: IFFALSE 9198
// begin vsevolodFirstAttack := false ;
9001: LD_ADDR_EXP 24
9005: PUSH
9006: LD_INT 0
9008: ST_TO_ADDR
// uc_nation := 3 ;
9009: LD_ADDR_OWVAR 21
9013: PUSH
9014: LD_INT 3
9016: ST_TO_ADDR
// for i = 1 to 3 do
9017: LD_ADDR_VAR 0 3
9021: PUSH
9022: DOUBLE
9023: LD_INT 1
9025: DEC
9026: ST_TO_ADDR
9027: LD_INT 3
9029: PUSH
9030: FOR_TO
9031: IFFALSE 9139
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9033: LD_INT 22
9035: PUSH
9036: LD_INT 24
9038: PUSH
9039: LD_INT 24
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: LIST
9046: PUSH
9047: LD_VAR 0 3
9051: PUSH
9052: LD_INT 3
9054: MOD
9055: PUSH
9056: LD_INT 1
9058: PLUS
9059: ARRAY
9060: PPUSH
9061: LD_INT 1
9063: PUSH
9064: LD_INT 3
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: LD_INT 1
9073: PPUSH
9074: LD_INT 2
9076: PPUSH
9077: CALL_OW 12
9081: ARRAY
9082: PPUSH
9083: LD_INT 3
9085: PPUSH
9086: LD_INT 45
9088: PUSH
9089: LD_INT 47
9091: PUSH
9092: LD_INT 47
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: PUSH
9100: LD_VAR 0 3
9104: PUSH
9105: LD_INT 3
9107: MOD
9108: PUSH
9109: LD_INT 1
9111: PLUS
9112: ARRAY
9113: PPUSH
9114: LD_INT 80
9116: PPUSH
9117: CALL 71487 0 5
// result := result union CreateVehicle ;
9121: LD_ADDR_VAR 0 2
9125: PUSH
9126: LD_VAR 0 2
9130: PUSH
9131: CALL_OW 45
9135: UNION
9136: ST_TO_ADDR
// end ;
9137: GO 9030
9139: POP
9140: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9141: LD_INT 24
9143: PPUSH
9144: LD_INT 3
9146: PPUSH
9147: LD_INT 1
9149: PPUSH
9150: LD_INT 47
9152: PPUSH
9153: LD_INT 100
9155: PPUSH
9156: CALL 71487 0 5
// sewiVeh := CreateVehicle ;
9160: LD_ADDR_EXP 70
9164: PUSH
9165: CALL_OW 45
9169: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9170: LD_EXP 70
9174: PPUSH
9175: LD_INT 1
9177: PPUSH
9178: CALL_OW 242
// result := result union sewiVeh ;
9182: LD_ADDR_VAR 0 2
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: LD_EXP 70
9196: UNION
9197: ST_TO_ADDR
// end ; end ; end ;
9198: GO 9201
9200: POP
// end ;
9201: LD_VAR 0 2
9205: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9206: LD_EXP 16
9210: IFFALSE 9968
9212: GO 9214
9214: DISABLE
9215: LD_INT 0
9217: PPUSH
9218: PPUSH
9219: PPUSH
9220: PPUSH
9221: PPUSH
9222: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9223: LD_ADDR_VAR 0 4
9227: PUSH
9228: LD_INT 11
9230: PUSH
9231: LD_INT 12
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9238: LD_ADDR_VAR 0 3
9242: PUSH
9243: LD_INT 9100
9245: PUSH
9246: LD_INT 7350
9248: PUSH
9249: LD_INT 6650
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: LIST
9256: PUSH
9257: LD_OWVAR 67
9261: ARRAY
9262: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9263: LD_ADDR_VAR 0 6
9267: PUSH
9268: LD_INT 70
9270: PUSH
9271: LD_INT 118
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PUSH
9278: LD_INT 78
9280: PUSH
9281: LD_INT 31
9283: PUSH
9284: EMPTY
9285: LIST
9286: LIST
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: ST_TO_ADDR
// repeat if missionStage = 2 then
9292: LD_EXP 15
9296: PUSH
9297: LD_INT 2
9299: EQUAL
9300: IFFALSE 9311
// wait ( 1 1$30 ) else
9302: LD_INT 3150
9304: PPUSH
9305: CALL_OW 67
9309: GO 9320
// wait ( time ) ;
9311: LD_VAR 0 3
9315: PPUSH
9316: CALL_OW 67
// if missionStage = 6 then
9320: LD_EXP 15
9324: PUSH
9325: LD_INT 6
9327: EQUAL
9328: IFFALSE 9356
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9330: LD_INT 51
9332: PPUSH
9333: LD_INT 6
9335: PPUSH
9336: LD_INT 2
9338: PPUSH
9339: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9343: LD_INT 57
9345: PPUSH
9346: LD_INT 6
9348: PPUSH
9349: LD_INT 2
9351: PPUSH
9352: CALL_OW 322
// end ; if missionStage = 8 then
9356: LD_EXP 15
9360: PUSH
9361: LD_INT 8
9363: EQUAL
9364: IFFALSE 9392
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9366: LD_INT 52
9368: PPUSH
9369: LD_INT 6
9371: PPUSH
9372: LD_INT 2
9374: PPUSH
9375: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9379: LD_INT 58
9381: PPUSH
9382: LD_INT 6
9384: PPUSH
9385: LD_INT 2
9387: PPUSH
9388: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9392: LD_EXP 15
9396: PUSH
9397: LD_INT 10
9399: EQUAL
9400: PUSH
9401: LD_OWVAR 67
9405: PUSH
9406: LD_INT 1
9408: GREATER
9409: AND
9410: IFFALSE 9438
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9412: LD_INT 53
9414: PPUSH
9415: LD_INT 6
9417: PPUSH
9418: LD_INT 2
9420: PPUSH
9421: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9425: LD_INT 59
9427: PPUSH
9428: LD_INT 6
9430: PPUSH
9431: LD_INT 2
9433: PPUSH
9434: CALL_OW 322
// end ; if activeAttacks then
9438: LD_EXP 16
9442: IFFALSE 9962
// begin if missionStage = 2 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 2
9451: EQUAL
9452: IFFALSE 9462
// strength := 1 ;
9454: LD_ADDR_VAR 0 5
9458: PUSH
9459: LD_INT 1
9461: ST_TO_ADDR
// if missionStage > 2 then
9462: LD_EXP 15
9466: PUSH
9467: LD_INT 2
9469: GREATER
9470: IFFALSE 9480
// strength := 2 ;
9472: LD_ADDR_VAR 0 5
9476: PUSH
9477: LD_INT 2
9479: ST_TO_ADDR
// if missionStage > 6 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 6
9487: GREATER
9488: IFFALSE 9498
// strength := 3 ;
9490: LD_ADDR_VAR 0 5
9494: PUSH
9495: LD_INT 3
9497: ST_TO_ADDR
// if missionStage > 10 then
9498: LD_EXP 15
9502: PUSH
9503: LD_INT 10
9505: GREATER
9506: IFFALSE 9516
// strength := 4 ;
9508: LD_ADDR_VAR 0 5
9512: PUSH
9513: LD_INT 4
9515: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9516: LD_ADDR_VAR 0 2
9520: PUSH
9521: LD_VAR 0 5
9525: PPUSH
9526: CALL 8078 0 1
9530: ST_TO_ADDR
// for i in tmp do
9531: LD_ADDR_VAR 0 1
9535: PUSH
9536: LD_VAR 0 2
9540: PUSH
9541: FOR_IN
9542: IFFALSE 9642
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9544: LD_VAR 0 1
9548: PPUSH
9549: LD_VAR 0 4
9553: PUSH
9554: LD_INT 1
9556: PPUSH
9557: LD_INT 2
9559: PPUSH
9560: CALL_OW 12
9564: ARRAY
9565: PPUSH
9566: LD_INT 0
9568: PPUSH
9569: CALL_OW 49
// if i = sewiVeh then
9573: LD_VAR 0 1
9577: PUSH
9578: LD_EXP 70
9582: EQUAL
9583: IFFALSE 9618
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9585: LD_ADDR_EXP 69
9589: PUSH
9590: LD_STRING Vsevolod
9592: PPUSH
9593: LD_INT 0
9595: PPUSH
9596: LD_STRING 
9598: PPUSH
9599: CALL 64372 0 3
9603: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9604: LD_EXP 69
9608: PPUSH
9609: LD_VAR 0 1
9613: PPUSH
9614: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9618: LD_VAR 0 1
9622: PPUSH
9623: LD_INT 111
9625: PPUSH
9626: LD_INT 197
9628: PPUSH
9629: CALL_OW 111
// wait ( 0 0$2 ) ;
9633: LD_INT 70
9635: PPUSH
9636: CALL_OW 67
// end ;
9640: GO 9541
9642: POP
9643: POP
// repeat wait ( 0 0$1 ) ;
9644: LD_INT 35
9646: PPUSH
9647: CALL_OW 67
// for i in tmp do
9651: LD_ADDR_VAR 0 1
9655: PUSH
9656: LD_VAR 0 2
9660: PUSH
9661: FOR_IN
9662: IFFALSE 9943
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9664: LD_INT 81
9666: PUSH
9667: LD_INT 6
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 91
9676: PUSH
9677: LD_VAR 0 1
9681: PUSH
9682: LD_INT 12
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: LIST
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PPUSH
9694: CALL_OW 69
9698: IFFALSE 9756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9700: LD_VAR 0 1
9704: PPUSH
9705: LD_INT 81
9707: PUSH
9708: LD_INT 6
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PUSH
9715: LD_INT 91
9717: PUSH
9718: LD_VAR 0 1
9722: PUSH
9723: LD_INT 12
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: LIST
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PPUSH
9735: CALL_OW 69
9739: PPUSH
9740: LD_VAR 0 1
9744: PPUSH
9745: CALL_OW 74
9749: PPUSH
9750: CALL_OW 115
9754: GO 9941
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9756: LD_INT 9
9758: PPUSH
9759: LD_INT 81
9761: PUSH
9762: LD_INT 6
9764: PUSH
9765: EMPTY
9766: LIST
9767: LIST
9768: PPUSH
9769: CALL_OW 70
9773: IFFALSE 9907
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_VAR 0 6
9784: PUSH
9785: LD_INT 1
9787: ARRAY
9788: PUSH
9789: LD_INT 1
9791: ARRAY
9792: PPUSH
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 1
9800: ARRAY
9801: PUSH
9802: LD_INT 2
9804: ARRAY
9805: PPUSH
9806: CALL_OW 297
9810: PUSH
9811: LD_INT 10
9813: GREATER
9814: PUSH
9815: LD_VAR 0 1
9819: PPUSH
9820: LD_INT 9
9822: PPUSH
9823: CALL_OW 308
9827: NOT
9828: AND
9829: IFFALSE 9868
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9831: LD_VAR 0 1
9835: PPUSH
9836: LD_VAR 0 6
9840: PUSH
9841: LD_INT 1
9843: ARRAY
9844: PUSH
9845: LD_INT 1
9847: ARRAY
9848: PPUSH
9849: LD_VAR 0 6
9853: PUSH
9854: LD_INT 1
9856: ARRAY
9857: PUSH
9858: LD_INT 2
9860: ARRAY
9861: PPUSH
9862: CALL_OW 114
9866: GO 9905
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9868: LD_VAR 0 1
9872: PPUSH
9873: LD_INT 9
9875: PPUSH
9876: LD_INT 81
9878: PUSH
9879: LD_INT 6
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PPUSH
9886: CALL_OW 70
9890: PPUSH
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 74
9900: PPUSH
9901: CALL_OW 115
// end else
9905: GO 9941
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PPUSH
9922: CALL_OW 69
9926: PPUSH
9927: LD_VAR 0 1
9931: PPUSH
9932: CALL_OW 74
9936: PPUSH
9937: CALL_OW 115
// end ;
9941: GO 9661
9943: POP
9944: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9945: LD_INT 22
9947: PUSH
9948: LD_INT 6
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: PPUSH
9955: CALL_OW 69
9959: NOT
9960: IFFALSE 9644
// end ; until russianDestroyed ;
9962: LD_EXP 21
9966: IFFALSE 9292
// end ;
9968: PPOPN 6
9970: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9971: LD_EXP 21
9975: NOT
9976: PUSH
9977: LD_EXP 15
9981: PUSH
9982: LD_INT 6
9984: GREATEREQUAL
9985: AND
9986: PUSH
9987: LD_INT 2
9989: PPUSH
9990: LD_INT 1
9992: PPUSH
9993: CALL 59446 0 2
9997: NOT
9998: AND
9999: IFFALSE 10955
10001: GO 10003
10003: DISABLE
10004: LD_INT 0
10006: PPUSH
10007: PPUSH
10008: PPUSH
10009: PPUSH
// begin enable ;
10010: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 30
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PPUSH
10035: CALL_OW 69
10039: NOT
10040: IFFALSE 10044
// exit ;
10042: GO 10955
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10044: LD_ADDR_VAR 0 4
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: EMPTY
10056: LIST
10057: LIST
10058: PUSH
10059: LD_INT 30
10061: PUSH
10062: LD_INT 34
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: ST_TO_ADDR
// if Prob ( 40 ) then
10078: LD_INT 40
10080: PPUSH
10081: CALL_OW 13
10085: IFFALSE 10212
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10087: LD_INT 2
10089: PPUSH
10090: LD_INT 22
10092: PUSH
10093: LD_INT 3
10095: PUSH
10096: LD_INT 3
10098: PUSH
10099: LD_INT 49
10101: PUSH
10102: EMPTY
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: PUSH
10108: LD_INT 22
10110: PUSH
10111: LD_INT 3
10113: PUSH
10114: LD_INT 3
10116: PUSH
10117: LD_INT 49
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: PUSH
10126: LD_INT 22
10128: PUSH
10129: LD_INT 3
10131: PUSH
10132: LD_INT 3
10134: PUSH
10135: LD_INT 49
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_INT 24
10146: PUSH
10147: LD_INT 3
10149: PUSH
10150: LD_INT 3
10152: PUSH
10153: LD_INT 46
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: PUSH
10162: LD_INT 24
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: LD_INT 3
10170: PUSH
10171: LD_INT 46
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: LD_INT 24
10182: PUSH
10183: LD_INT 3
10185: PUSH
10186: LD_INT 3
10188: PUSH
10189: LD_INT 46
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: PPUSH
10206: CALL 58028 0 2
// end else
10210: GO 10335
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10212: LD_INT 2
10214: PPUSH
10215: LD_INT 24
10217: PUSH
10218: LD_INT 3
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: LD_INT 47
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: PUSH
10233: LD_INT 24
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: LD_INT 47
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 24
10253: PUSH
10254: LD_INT 3
10256: PUSH
10257: LD_INT 3
10259: PUSH
10260: LD_INT 47
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: PUSH
10269: LD_INT 24
10271: PUSH
10272: LD_INT 3
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: LD_INT 46
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: PUSH
10287: LD_INT 24
10289: PUSH
10290: LD_INT 3
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: LD_INT 46
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PUSH
10305: LD_INT 24
10307: PUSH
10308: LD_INT 3
10310: PUSH
10311: LD_INT 3
10313: PUSH
10314: LD_INT 46
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: PPUSH
10331: CALL 58028 0 2
// end ; if Difficulty > 1 then
10335: LD_OWVAR 67
10339: PUSH
10340: LD_INT 1
10342: GREATER
10343: IFFALSE 10373
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10345: LD_INT 2
10347: PPUSH
10348: LD_INT 24
10350: PUSH
10351: LD_INT 3
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 47
10359: PUSH
10360: EMPTY
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: PUSH
10366: EMPTY
10367: LIST
10368: PPUSH
10369: CALL 58028 0 2
// repeat wait ( 0 0$1 ) ;
10373: LD_INT 35
10375: PPUSH
10376: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10380: LD_INT 2
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL 59446 0 2
10390: PUSH
10391: LD_INT 6
10393: PUSH
10394: LD_INT 7
10396: PUSH
10397: LD_INT 7
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: LD_OWVAR 67
10409: ARRAY
10410: GREATEREQUAL
10411: IFFALSE 10373
// wait ( 0 0$30 ) ;
10413: LD_INT 1050
10415: PPUSH
10416: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10420: LD_ADDR_VAR 0 2
10424: PUSH
10425: LD_INT 2
10427: PPUSH
10428: LD_INT 1
10430: PPUSH
10431: CALL 59446 0 2
10435: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10436: LD_ADDR_EXP 120
10440: PUSH
10441: LD_EXP 120
10445: PPUSH
10446: LD_INT 2
10448: PPUSH
10449: LD_EXP 120
10453: PUSH
10454: LD_INT 2
10456: ARRAY
10457: PUSH
10458: LD_VAR 0 2
10462: DIFF
10463: PPUSH
10464: CALL_OW 1
10468: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10469: LD_ADDR_VAR 0 3
10473: PUSH
10474: LD_INT 0
10476: PPUSH
10477: LD_INT 1
10479: PPUSH
10480: CALL_OW 12
10484: ST_TO_ADDR
// if target then
10485: LD_VAR 0 3
10489: IFFALSE 10617
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10491: LD_ADDR_VAR 0 2
10495: PUSH
10496: LD_VAR 0 2
10500: PPUSH
10501: LD_INT 24
10503: PUSH
10504: LD_INT 250
10506: PUSH
10507: EMPTY
10508: LIST
10509: LIST
10510: PPUSH
10511: CALL_OW 72
10515: ST_TO_ADDR
// for i in tmp do
10516: LD_ADDR_VAR 0 1
10520: PUSH
10521: LD_VAR 0 2
10525: PUSH
10526: FOR_IN
10527: IFFALSE 10567
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10529: LD_VAR 0 1
10533: PPUSH
10534: LD_INT 139
10536: PPUSH
10537: LD_INT 89
10539: PPUSH
10540: CALL_OW 297
10544: PUSH
10545: LD_INT 9
10547: GREATER
10548: IFFALSE 10565
// ComMoveXY ( i , 139 , 89 ) ;
10550: LD_VAR 0 1
10554: PPUSH
10555: LD_INT 139
10557: PPUSH
10558: LD_INT 89
10560: PPUSH
10561: CALL_OW 111
10565: GO 10526
10567: POP
10568: POP
// wait ( 0 0$1 ) ;
10569: LD_INT 35
10571: PPUSH
10572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10576: LD_VAR 0 2
10580: PPUSH
10581: LD_INT 92
10583: PUSH
10584: LD_INT 139
10586: PUSH
10587: LD_INT 89
10589: PUSH
10590: LD_INT 9
10592: PUSH
10593: EMPTY
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: PPUSH
10599: CALL_OW 72
10603: PUSH
10604: LD_VAR 0 2
10608: PUSH
10609: LD_INT 1
10611: MINUS
10612: GREATEREQUAL
10613: IFFALSE 10491
// end else
10615: GO 10759
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_VAR 0 4
10626: PUSH
10627: LD_INT 1
10629: ARRAY
10630: PPUSH
10631: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10635: LD_ADDR_VAR 0 2
10639: PUSH
10640: LD_VAR 0 2
10644: PPUSH
10645: LD_INT 24
10647: PUSH
10648: LD_INT 250
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 72
10659: ST_TO_ADDR
// for i in tmp do
10660: LD_ADDR_VAR 0 1
10664: PUSH
10665: LD_VAR 0 2
10669: PUSH
10670: FOR_IN
10671: IFFALSE 10711
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_INT 124
10680: PPUSH
10681: LD_INT 139
10683: PPUSH
10684: CALL_OW 297
10688: PUSH
10689: LD_INT 9
10691: GREATER
10692: IFFALSE 10709
// ComMoveXY ( i , 124 , 139 ) ;
10694: LD_VAR 0 1
10698: PPUSH
10699: LD_INT 124
10701: PPUSH
10702: LD_INT 139
10704: PPUSH
10705: CALL_OW 111
10709: GO 10670
10711: POP
10712: POP
// wait ( 0 0$1 ) ;
10713: LD_INT 35
10715: PPUSH
10716: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10720: LD_VAR 0 2
10724: PPUSH
10725: LD_INT 92
10727: PUSH
10728: LD_INT 124
10730: PUSH
10731: LD_INT 139
10733: PUSH
10734: LD_INT 9
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 72
10747: PUSH
10748: LD_VAR 0 2
10752: PUSH
10753: LD_INT 1
10755: MINUS
10756: GREATEREQUAL
10757: IFFALSE 10635
// end ; repeat wait ( 0 0$1 ) ;
10759: LD_INT 35
10761: PPUSH
10762: CALL_OW 67
// for i in tmp do
10766: LD_ADDR_VAR 0 1
10770: PUSH
10771: LD_VAR 0 2
10775: PUSH
10776: FOR_IN
10777: IFFALSE 10946
// begin if GetLives ( i ) > 251 then
10779: LD_VAR 0 1
10783: PPUSH
10784: CALL_OW 256
10788: PUSH
10789: LD_INT 251
10791: GREATER
10792: IFFALSE 10917
// begin if GetWeapon ( i ) = ru_time_lapser then
10794: LD_VAR 0 1
10798: PPUSH
10799: CALL_OW 264
10803: PUSH
10804: LD_INT 49
10806: EQUAL
10807: IFFALSE 10863
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10809: LD_VAR 0 1
10813: PPUSH
10814: LD_INT 2
10816: PUSH
10817: LD_INT 22
10819: PUSH
10820: LD_INT 1
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 22
10829: PUSH
10830: LD_INT 8
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 69
10846: PPUSH
10847: LD_VAR 0 1
10851: PPUSH
10852: CALL_OW 74
10856: PPUSH
10857: CALL_OW 112
10861: GO 10915
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10863: LD_VAR 0 1
10867: PPUSH
10868: LD_INT 2
10870: PUSH
10871: LD_INT 22
10873: PUSH
10874: LD_INT 1
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: LD_INT 22
10883: PUSH
10884: LD_INT 8
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: LIST
10895: PPUSH
10896: CALL_OW 69
10900: PPUSH
10901: LD_VAR 0 1
10905: PPUSH
10906: CALL_OW 74
10910: PPUSH
10911: CALL_OW 115
// end else
10915: GO 10944
// if IsDead ( i ) then
10917: LD_VAR 0 1
10921: PPUSH
10922: CALL_OW 301
10926: IFFALSE 10944
// tmp := tmp diff i ;
10928: LD_ADDR_VAR 0 2
10932: PUSH
10933: LD_VAR 0 2
10937: PUSH
10938: LD_VAR 0 1
10942: DIFF
10943: ST_TO_ADDR
// end ;
10944: GO 10776
10946: POP
10947: POP
// until not tmp ;
10948: LD_VAR 0 2
10952: NOT
10953: IFFALSE 10759
// end ; end_of_file
10955: PPOPN 4
10957: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10958: LD_INT 0
10960: PPUSH
10961: PPUSH
10962: PPUSH
10963: PPUSH
10964: PPUSH
10965: PPUSH
// side := 7 ;
10966: LD_ADDR_VAR 0 5
10970: PUSH
10971: LD_INT 7
10973: ST_TO_ADDR
// uc_side := side ;
10974: LD_ADDR_OWVAR 20
10978: PUSH
10979: LD_VAR 0 5
10983: ST_TO_ADDR
// uc_nation := 1 ;
10984: LD_ADDR_OWVAR 21
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10992: LD_ADDR_VAR 0 2
10996: PUSH
10997: LD_INT 22
10999: PUSH
11000: LD_VAR 0 5
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: PUSH
11009: LD_INT 21
11011: PUSH
11012: LD_INT 3
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: PPUSH
11023: CALL_OW 69
11027: PUSH
11028: FOR_IN
11029: IFFALSE 11045
// SetBLevel ( i , 10 ) ;
11031: LD_VAR 0 2
11035: PPUSH
11036: LD_INT 10
11038: PPUSH
11039: CALL_OW 241
11043: GO 11028
11045: POP
11046: POP
// base := GetBase ( al_depot ) ;
11047: LD_ADDR_VAR 0 4
11051: PUSH
11052: LD_INT 2
11054: PPUSH
11055: CALL_OW 274
11059: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11060: LD_ADDR_VAR 0 6
11064: PUSH
11065: LD_INT 22
11067: PUSH
11068: LD_VAR 0 5
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: PUSH
11077: LD_INT 30
11079: PUSH
11080: LD_INT 34
11082: PUSH
11083: EMPTY
11084: LIST
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PPUSH
11091: CALL_OW 69
11095: ST_TO_ADDR
// if teleport then
11096: LD_VAR 0 6
11100: IFFALSE 11121
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11102: LD_VAR 0 6
11106: PUSH
11107: LD_INT 1
11109: ARRAY
11110: PPUSH
11111: LD_INT 262
11113: PPUSH
11114: LD_INT 119
11116: PPUSH
11117: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11121: LD_VAR 0 4
11125: PPUSH
11126: LD_INT 1
11128: PPUSH
11129: LD_INT 19500
11131: PPUSH
11132: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11136: LD_VAR 0 4
11140: PPUSH
11141: LD_INT 2
11143: PPUSH
11144: LD_INT 200
11146: PPUSH
11147: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11151: LD_VAR 0 4
11155: PPUSH
11156: LD_INT 3
11158: PPUSH
11159: LD_INT 650
11161: PPUSH
11162: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11166: LD_ADDR_EXP 73
11170: PUSH
11171: LD_STRING Roth
11173: PPUSH
11174: CALL_OW 25
11178: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11179: LD_ADDR_EXP 74
11183: PUSH
11184: LD_STRING Simms
11186: PPUSH
11187: LD_EXP 1
11191: NOT
11192: PPUSH
11193: LD_STRING 10c_
11195: PPUSH
11196: CALL 64372 0 3
11200: ST_TO_ADDR
// if not Simms then
11201: LD_EXP 74
11205: NOT
11206: IFFALSE 11236
// begin uc_nation := 1 ;
11208: LD_ADDR_OWVAR 21
11212: PUSH
11213: LD_INT 1
11215: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11216: LD_INT 2
11218: PPUSH
11219: LD_INT 10
11221: PPUSH
11222: CALL_OW 384
// Simms := CreateHuman ;
11226: LD_ADDR_EXP 74
11230: PUSH
11231: CALL_OW 44
11235: ST_TO_ADDR
// end ; uc_nation := 3 ;
11236: LD_ADDR_OWVAR 21
11240: PUSH
11241: LD_INT 3
11243: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11244: LD_ADDR_EXP 75
11248: PUSH
11249: LD_STRING Kirilenkova
11251: PPUSH
11252: CALL_OW 25
11256: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11257: LD_ADDR_EXP 89
11261: PUSH
11262: LD_STRING Oblukov
11264: PPUSH
11265: CALL_OW 25
11269: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11270: LD_ADDR_EXP 76
11274: PUSH
11275: LD_STRING Dolgov
11277: PPUSH
11278: CALL_OW 25
11282: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11283: LD_ADDR_EXP 77
11287: PUSH
11288: LD_STRING Petrosyan
11290: PPUSH
11291: CALL_OW 25
11295: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11296: LD_ADDR_EXP 88
11300: PUSH
11301: LD_STRING Scholtze
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11309: LD_ADDR_EXP 87
11313: PUSH
11314: LD_STRING Kapitsova
11316: PPUSH
11317: CALL_OW 25
11321: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11322: LD_ADDR_EXP 78
11326: PUSH
11327: LD_STRING Petrovova
11329: PPUSH
11330: CALL_OW 25
11334: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11335: LD_ADDR_EXP 79
11339: PUSH
11340: LD_STRING Kuzmov
11342: PPUSH
11343: CALL_OW 25
11347: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11348: LD_ADDR_EXP 86
11352: PUSH
11353: LD_STRING Karamazov
11355: PPUSH
11356: CALL_OW 25
11360: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11361: LD_STRING 13_Lipshchin_1
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: CALL_OW 30
11371: IFFALSE 11386
// Lipshchin := NewCharacter ( Lipshchin ) ;
11373: LD_ADDR_EXP 80
11377: PUSH
11378: LD_STRING Lipshchin
11380: PPUSH
11381: CALL_OW 25
11385: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11386: LD_STRING 13_Titov_1
11388: PPUSH
11389: LD_INT 0
11391: PPUSH
11392: CALL_OW 30
11396: IFFALSE 11411
// Titov := NewCharacter ( Titov ) ;
11398: LD_ADDR_EXP 82
11402: PUSH
11403: LD_STRING Titov
11405: PPUSH
11406: CALL_OW 25
11410: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11411: LD_STRING 13_Gnyevko_1
11413: PPUSH
11414: LD_INT 0
11416: PPUSH
11417: CALL_OW 30
11421: IFFALSE 11436
// Gnyevko := NewCharacter ( Gnyevko ) ;
11423: LD_ADDR_EXP 81
11427: PUSH
11428: LD_STRING Gnyevko
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11436: LD_STRING 13_Xavier_1
11438: PPUSH
11439: LD_INT 0
11441: PPUSH
11442: CALL_OW 30
11446: IFFALSE 11461
// Xavier := NewCharacter ( Xavier2 ) ;
11448: LD_ADDR_EXP 83
11452: PUSH
11453: LD_STRING Xavier2
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11461: LD_STRING 13_Belkov_1
11463: PPUSH
11464: LD_INT 0
11466: PPUSH
11467: CALL_OW 30
11471: IFFALSE 11486
// Belkov := NewCharacter ( Belkov ) ;
11473: LD_ADDR_EXP 84
11477: PUSH
11478: LD_STRING Belkov
11480: PPUSH
11481: CALL_OW 25
11485: ST_TO_ADDR
// if not BurlakStatus then
11486: LD_EXP 9
11490: NOT
11491: IFFALSE 11506
// Burlak = NewCharacter ( Burlak ) ;
11493: LD_ADDR_EXP 85
11497: PUSH
11498: LD_STRING Burlak
11500: PPUSH
11501: CALL_OW 25
11505: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11506: LD_ADDR_VAR 0 3
11510: PUSH
11511: LD_EXP 73
11515: PUSH
11516: LD_EXP 75
11520: PUSH
11521: LD_EXP 89
11525: PUSH
11526: LD_EXP 76
11530: PUSH
11531: LD_EXP 77
11535: PUSH
11536: LD_EXP 88
11540: PUSH
11541: LD_EXP 87
11545: PUSH
11546: LD_EXP 78
11550: PUSH
11551: LD_EXP 79
11555: PUSH
11556: LD_EXP 86
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: LIST
11572: ST_TO_ADDR
// if Simms then
11573: LD_EXP 74
11577: IFFALSE 11595
// tmp := tmp ^ Simms ;
11579: LD_ADDR_VAR 0 3
11583: PUSH
11584: LD_VAR 0 3
11588: PUSH
11589: LD_EXP 74
11593: ADD
11594: ST_TO_ADDR
// if Titov then
11595: LD_EXP 82
11599: IFFALSE 11617
// tmp := tmp ^ Titov ;
11601: LD_ADDR_VAR 0 3
11605: PUSH
11606: LD_VAR 0 3
11610: PUSH
11611: LD_EXP 82
11615: ADD
11616: ST_TO_ADDR
// if Lipshchin then
11617: LD_EXP 80
11621: IFFALSE 11639
// tmp := tmp ^ Lipshchin ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: LD_EXP 80
11637: ADD
11638: ST_TO_ADDR
// if Gnyevko then
11639: LD_EXP 81
11643: IFFALSE 11661
// tmp := tmp ^ Gnyevko ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_VAR 0 3
11654: PUSH
11655: LD_EXP 81
11659: ADD
11660: ST_TO_ADDR
// if Xavier then
11661: LD_EXP 83
11665: IFFALSE 11683
// tmp := tmp ^ Xavier ;
11667: LD_ADDR_VAR 0 3
11671: PUSH
11672: LD_VAR 0 3
11676: PUSH
11677: LD_EXP 83
11681: ADD
11682: ST_TO_ADDR
// if Belkov then
11683: LD_EXP 84
11687: IFFALSE 11705
// tmp := tmp ^ Belkov ;
11689: LD_ADDR_VAR 0 3
11693: PUSH
11694: LD_VAR 0 3
11698: PUSH
11699: LD_EXP 84
11703: ADD
11704: ST_TO_ADDR
// if Burlak then
11705: LD_EXP 85
11709: IFFALSE 11727
// tmp := tmp ^ Burlak ;
11711: LD_ADDR_VAR 0 3
11715: PUSH
11716: LD_VAR 0 3
11720: PUSH
11721: LD_EXP 85
11725: ADD
11726: ST_TO_ADDR
// for i = 1 to 8 do
11727: LD_ADDR_VAR 0 2
11731: PUSH
11732: DOUBLE
11733: LD_INT 1
11735: DEC
11736: ST_TO_ADDR
11737: LD_INT 8
11739: PUSH
11740: FOR_TO
11741: IFFALSE 11807
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11743: LD_ADDR_OWVAR 21
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: LD_INT 3
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 1
11760: PPUSH
11761: LD_INT 2
11763: PPUSH
11764: CALL_OW 12
11768: ARRAY
11769: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11770: LD_INT 0
11772: PPUSH
11773: LD_VAR 0 2
11777: PUSH
11778: LD_INT 2
11780: DIV
11781: PPUSH
11782: LD_INT 10
11784: PPUSH
11785: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_VAR 0 3
11798: PUSH
11799: CALL_OW 44
11803: ADD
11804: ST_TO_ADDR
// end ;
11805: GO 11740
11807: POP
11808: POP
// for i in tmp do
11809: LD_ADDR_VAR 0 2
11813: PUSH
11814: LD_VAR 0 3
11818: PUSH
11819: FOR_IN
11820: IFFALSE 11845
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11822: LD_VAR 0 2
11826: PPUSH
11827: LD_INT 260
11829: PPUSH
11830: LD_INT 235
11832: PPUSH
11833: LD_INT 8
11835: PPUSH
11836: LD_INT 0
11838: PPUSH
11839: CALL_OW 50
11843: GO 11819
11845: POP
11846: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11847: LD_ADDR_EXP 101
11851: PUSH
11852: LD_EXP 101
11856: PPUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 22
11862: PUSH
11863: LD_VAR 0 5
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 3
11874: PUSH
11875: LD_INT 21
11877: PUSH
11878: LD_INT 2
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PPUSH
11893: CALL_OW 69
11897: PUSH
11898: LD_EXP 73
11902: PUSH
11903: LD_EXP 74
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: DIFF
11912: PPUSH
11913: CALL_OW 1
11917: ST_TO_ADDR
// uc_side := 0 ;
11918: LD_ADDR_OWVAR 20
11922: PUSH
11923: LD_INT 0
11925: ST_TO_ADDR
// uc_nation := 0 ;
11926: LD_ADDR_OWVAR 21
11930: PUSH
11931: LD_INT 0
11933: ST_TO_ADDR
// for i = 1 to 5 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 5
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11985
// begin InitHc ;
11950: CALL_OW 19
// hc_class := class_apeman ;
11954: LD_ADDR_OWVAR 28
11958: PUSH
11959: LD_INT 12
11961: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11962: CALL_OW 44
11966: PPUSH
11967: LD_INT 299
11969: PPUSH
11970: LD_INT 229
11972: PPUSH
11973: LD_INT 10
11975: PPUSH
11976: LD_INT 0
11978: PPUSH
11979: CALL_OW 50
// end ;
11983: GO 11947
11985: POP
11986: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11987: LD_EXP 73
11991: PPUSH
11992: LD_INT 259
11994: PPUSH
11995: LD_INT 235
11997: PPUSH
11998: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12002: LD_EXP 73
12006: PPUSH
12007: LD_INT 262
12009: PPUSH
12010: LD_INT 235
12012: PPUSH
12013: CALL_OW 178
// if Simms then
12017: LD_EXP 74
12021: IFFALSE 12052
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12023: LD_EXP 74
12027: PPUSH
12028: LD_INT 262
12030: PPUSH
12031: LD_INT 235
12033: PPUSH
12034: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12038: LD_EXP 74
12042: PPUSH
12043: LD_EXP 73
12047: PPUSH
12048: CALL_OW 179
// end ; end ;
12052: LD_VAR 0 1
12056: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12057: LD_EXP 31
12061: PUSH
12062: LD_EXP 23
12066: NOT
12067: AND
12068: IFFALSE 12244
12070: GO 12072
12072: DISABLE
12073: LD_INT 0
12075: PPUSH
12076: PPUSH
12077: PPUSH
// begin enable ;
12078: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12079: LD_ADDR_VAR 0 2
12083: PUSH
12084: LD_INT 81
12086: PUSH
12087: LD_INT 7
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 2
12096: PUSH
12097: LD_INT 32
12099: PUSH
12100: LD_INT 3
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 30
12109: PUSH
12110: LD_INT 30
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 30
12119: PUSH
12120: LD_INT 28
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: LD_INT 34
12129: PUSH
12130: LD_INT 49
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 34
12139: PUSH
12140: LD_INT 10
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 34
12149: PUSH
12150: LD_INT 8
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: ST_TO_ADDR
// if not tmp then
12175: LD_VAR 0 2
12179: NOT
12180: IFFALSE 12184
// exit ;
12182: GO 12244
// target := tmp [ rand ( 1 , tmp ) ] ;
12184: LD_ADDR_VAR 0 3
12188: PUSH
12189: LD_VAR 0 2
12193: PUSH
12194: LD_INT 1
12196: PPUSH
12197: LD_VAR 0 2
12201: PPUSH
12202: CALL_OW 12
12206: ARRAY
12207: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12208: LD_VAR 0 3
12212: PPUSH
12213: CALL_OW 255
12217: PUSH
12218: LD_INT 1
12220: EQUAL
12221: IFFALSE 12232
// CenterNowOnUnits ( target ) ;
12223: LD_VAR 0 3
12227: PPUSH
12228: CALL_OW 87
// SetLives ( target , 0 ) ;
12232: LD_VAR 0 3
12236: PPUSH
12237: LD_INT 0
12239: PPUSH
12240: CALL_OW 234
// end ;
12244: PPOPN 3
12246: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12247: LD_EXP 23
12251: NOT
12252: PUSH
12253: LD_EXP 31
12257: AND
12258: IFFALSE 12780
12260: GO 12262
12262: DISABLE
12263: LD_INT 0
12265: PPUSH
12266: PPUSH
12267: PPUSH
// begin uc_side := 7 ;
12268: LD_ADDR_OWVAR 20
12272: PUSH
12273: LD_INT 7
12275: ST_TO_ADDR
// uc_nation := 1 ;
12276: LD_ADDR_OWVAR 21
12280: PUSH
12281: LD_INT 1
12283: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: LD_INT 125
12291: PUSH
12292: LD_INT 163
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 185
12301: PUSH
12302: LD_INT 168
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: LD_INT 111
12311: PUSH
12312: LD_INT 97
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: LIST
12323: PPUSH
12324: CALL 107324 0 1
12328: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12329: LD_ADDR_EXP 90
12333: PUSH
12334: EMPTY
12335: ST_TO_ADDR
// for i = 1 to Difficulty do
12336: LD_ADDR_VAR 0 1
12340: PUSH
12341: DOUBLE
12342: LD_INT 1
12344: DEC
12345: ST_TO_ADDR
12346: LD_OWVAR 67
12350: PUSH
12351: FOR_TO
12352: IFFALSE 12510
// begin InitHc ;
12354: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12358: LD_INT 0
12360: PPUSH
12361: LD_INT 8
12363: PPUSH
12364: CALL_OW 381
// un := CreateHuman ;
12368: LD_ADDR_VAR 0 2
12372: PUSH
12373: CALL_OW 44
12377: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12378: LD_VAR 0 2
12382: PPUSH
12383: LD_INT 258
12385: PPUSH
12386: LD_INT 267
12388: PPUSH
12389: LD_INT 4
12391: PPUSH
12392: LD_INT 0
12394: PPUSH
12395: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12399: LD_ADDR_EXP 90
12403: PUSH
12404: LD_EXP 90
12408: PUSH
12409: LD_VAR 0 2
12413: UNION
12414: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12415: LD_VAR 0 2
12419: PPUSH
12420: LD_VAR 0 3
12424: PUSH
12425: LD_VAR 0 1
12429: ARRAY
12430: PUSH
12431: LD_INT 1
12433: ARRAY
12434: PPUSH
12435: LD_VAR 0 3
12439: PUSH
12440: LD_VAR 0 1
12444: ARRAY
12445: PUSH
12446: LD_INT 2
12448: ARRAY
12449: PPUSH
12450: LD_INT 4
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12460: LD_VAR 0 2
12464: PPUSH
12465: LD_VAR 0 3
12469: PUSH
12470: LD_VAR 0 1
12474: ARRAY
12475: PUSH
12476: LD_INT 1
12478: ARRAY
12479: PPUSH
12480: LD_VAR 0 3
12484: PUSH
12485: LD_VAR 0 1
12489: ARRAY
12490: PUSH
12491: LD_INT 2
12493: ARRAY
12494: PPUSH
12495: CALL_OW 171
// AddComInvisible ( un ) ;
12499: LD_VAR 0 2
12503: PPUSH
12504: CALL_OW 212
// end ;
12508: GO 12351
12510: POP
12511: POP
// repeat wait ( 0 0$20 ) ;
12512: LD_INT 700
12514: PPUSH
12515: CALL_OW 67
// for i in allianceSpecialForce do
12519: LD_ADDR_VAR 0 1
12523: PUSH
12524: LD_EXP 90
12528: PUSH
12529: FOR_IN
12530: IFFALSE 12765
// begin if IsInvisible ( i ) then
12532: LD_VAR 0 1
12536: PPUSH
12537: CALL_OW 571
12541: IFFALSE 12734
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12543: LD_ADDR_VAR 0 3
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_INT 1
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PUSH
12558: LD_INT 50
12560: PUSH
12561: EMPTY
12562: LIST
12563: PUSH
12564: LD_INT 56
12566: PUSH
12567: EMPTY
12568: LIST
12569: PUSH
12570: LD_INT 91
12572: PUSH
12573: LD_VAR 0 1
12577: PUSH
12578: LD_INT 25
12580: PUSH
12581: LD_INT 30
12583: PUSH
12584: LD_INT 35
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: LIST
12591: PUSH
12592: LD_OWVAR 67
12596: ARRAY
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: PUSH
12603: LD_INT 2
12605: PUSH
12606: LD_INT 25
12608: PUSH
12609: LD_INT 1
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PUSH
12616: LD_INT 25
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 25
12628: PUSH
12629: LD_INT 3
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 25
12638: PUSH
12639: LD_INT 4
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: LD_INT 25
12648: PUSH
12649: LD_INT 5
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: PUSH
12656: LD_INT 25
12658: PUSH
12659: LD_INT 8
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: ST_TO_ADDR
// if not tmp then
12687: LD_VAR 0 3
12691: NOT
12692: IFFALSE 12696
// continue ;
12694: GO 12529
// if Prob ( 30 * Difficulty ) then
12696: LD_INT 30
12698: PUSH
12699: LD_OWVAR 67
12703: MUL
12704: PPUSH
12705: CALL_OW 13
12709: IFFALSE 12734
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12711: LD_VAR 0 3
12715: PUSH
12716: LD_INT 1
12718: PPUSH
12719: LD_VAR 0 3
12723: PPUSH
12724: CALL_OW 12
12728: ARRAY
12729: PPUSH
12730: CALL 30374 0 1
// end ; if IsDead ( i ) then
12734: LD_VAR 0 1
12738: PPUSH
12739: CALL_OW 301
12743: IFFALSE 12763
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12745: LD_ADDR_EXP 90
12749: PUSH
12750: LD_EXP 90
12754: PUSH
12755: LD_VAR 0 1
12759: DIFF
12760: ST_TO_ADDR
// continue ;
12761: GO 12529
// end ; end ;
12763: GO 12529
12765: POP
12766: POP
// until allianceDestroyed or not allianceSpecialForce ;
12767: LD_EXP 23
12771: PUSH
12772: LD_EXP 90
12776: NOT
12777: OR
12778: IFFALSE 12512
// end ;
12780: PPOPN 3
12782: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12783: LD_EXP 23
12787: NOT
12788: PUSH
12789: LD_EXP 31
12793: AND
12794: PUSH
12795: LD_INT 1
12797: PPUSH
12798: LD_INT 1
12800: PPUSH
12801: CALL 59446 0 2
12805: NOT
12806: AND
12807: IFFALSE 13774
12809: GO 12811
12811: DISABLE
12812: LD_INT 0
12814: PPUSH
12815: PPUSH
12816: PPUSH
12817: PPUSH
// begin enable ;
12818: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12819: LD_INT 22
12821: PUSH
12822: LD_INT 7
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: LD_INT 30
12831: PUSH
12832: LD_INT 3
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PPUSH
12843: CALL_OW 69
12847: NOT
12848: IFFALSE 12852
// exit ;
12850: GO 13774
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12852: LD_ADDR_VAR 0 4
12856: PUSH
12857: LD_INT 22
12859: PUSH
12860: LD_INT 7
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 30
12869: PUSH
12870: LD_INT 34
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: ST_TO_ADDR
// if Prob ( 40 ) then
12886: LD_INT 40
12888: PPUSH
12889: CALL_OW 13
12893: IFFALSE 13020
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 5
12900: PUSH
12901: LD_INT 3
12903: PUSH
12904: LD_INT 2
12906: PUSH
12907: LD_INT 6
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 5
12918: PUSH
12919: LD_INT 3
12921: PUSH
12922: LD_INT 2
12924: PUSH
12925: LD_INT 6
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 5
12936: PUSH
12937: LD_INT 3
12939: PUSH
12940: LD_INT 2
12942: PUSH
12943: LD_INT 6
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: PUSH
12952: LD_INT 24
12954: PUSH
12955: LD_INT 3
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: LD_INT 45
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 24
12972: PUSH
12973: LD_INT 3
12975: PUSH
12976: LD_INT 3
12978: PUSH
12979: LD_INT 47
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 24
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: LD_INT 3
12996: PUSH
12997: LD_INT 45
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: PPUSH
13014: CALL 58028 0 2
// end else
13018: GO 13143
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13020: LD_INT 1
13022: PPUSH
13023: LD_INT 24
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: LD_INT 3
13031: PUSH
13032: LD_INT 47
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: PUSH
13041: LD_INT 24
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 47
13052: PUSH
13053: EMPTY
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 5
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 9
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 5
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 2
13085: PUSH
13086: LD_INT 9
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: PUSH
13095: LD_INT 24
13097: PUSH
13098: LD_INT 1
13100: PUSH
13101: LD_INT 3
13103: PUSH
13104: LD_INT 45
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: PUSH
13113: LD_INT 24
13115: PUSH
13116: LD_INT 1
13118: PUSH
13119: LD_INT 3
13121: PUSH
13122: LD_INT 45
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL 58028 0 2
// end ; if Difficulty > 1 then
13143: LD_OWVAR 67
13147: PUSH
13148: LD_INT 1
13150: GREATER
13151: IFFALSE 13181
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13153: LD_INT 1
13155: PPUSH
13156: LD_INT 24
13158: PUSH
13159: LD_INT 3
13161: PUSH
13162: LD_INT 3
13164: PUSH
13165: LD_INT 47
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: PPUSH
13177: CALL 58028 0 2
// repeat wait ( 0 0$1 ) ;
13181: LD_INT 35
13183: PPUSH
13184: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13188: LD_INT 1
13190: PPUSH
13191: LD_INT 1
13193: PPUSH
13194: CALL 59446 0 2
13198: PUSH
13199: LD_INT 6
13201: PUSH
13202: LD_INT 7
13204: PUSH
13205: LD_INT 7
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: PUSH
13213: LD_OWVAR 67
13217: ARRAY
13218: GREATEREQUAL
13219: IFFALSE 13181
// wait ( 0 0$40 ) ;
13221: LD_INT 1400
13223: PPUSH
13224: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13228: LD_ADDR_VAR 0 2
13232: PUSH
13233: LD_INT 1
13235: PPUSH
13236: LD_INT 1
13238: PPUSH
13239: CALL 59446 0 2
13243: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13244: LD_ADDR_EXP 120
13248: PUSH
13249: LD_EXP 120
13253: PPUSH
13254: LD_INT 1
13256: PPUSH
13257: LD_EXP 120
13261: PUSH
13262: LD_INT 1
13264: ARRAY
13265: PUSH
13266: LD_VAR 0 2
13270: DIFF
13271: PPUSH
13272: CALL_OW 1
13276: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_INT 0
13284: PPUSH
13285: LD_INT 1
13287: PPUSH
13288: CALL_OW 12
13292: ST_TO_ADDR
// if target then
13293: LD_VAR 0 3
13297: IFFALSE 13463
// begin for i in tmp do
13299: LD_ADDR_VAR 0 1
13303: PUSH
13304: LD_VAR 0 2
13308: PUSH
13309: FOR_IN
13310: IFFALSE 13335
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13312: LD_VAR 0 1
13316: PPUSH
13317: LD_INT 179
13319: PPUSH
13320: LD_INT 209
13322: PPUSH
13323: LD_INT 8
13325: PPUSH
13326: LD_INT 1
13328: PPUSH
13329: CALL_OW 483
13333: GO 13309
13335: POP
13336: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13337: LD_ADDR_VAR 0 2
13341: PUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: LD_INT 24
13349: PUSH
13350: LD_INT 250
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PPUSH
13357: CALL_OW 72
13361: ST_TO_ADDR
// for i in tmp do
13362: LD_ADDR_VAR 0 1
13366: PUSH
13367: LD_VAR 0 2
13371: PUSH
13372: FOR_IN
13373: IFFALSE 13413
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13375: LD_VAR 0 1
13379: PPUSH
13380: LD_INT 179
13382: PPUSH
13383: LD_INT 209
13385: PPUSH
13386: CALL_OW 297
13390: PUSH
13391: LD_INT 9
13393: GREATER
13394: IFFALSE 13411
// ComMoveXY ( i , 179 , 209 ) ;
13396: LD_VAR 0 1
13400: PPUSH
13401: LD_INT 179
13403: PPUSH
13404: LD_INT 209
13406: PPUSH
13407: CALL_OW 111
13411: GO 13372
13413: POP
13414: POP
// wait ( 0 0$1 ) ;
13415: LD_INT 35
13417: PPUSH
13418: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13422: LD_VAR 0 2
13426: PPUSH
13427: LD_INT 92
13429: PUSH
13430: LD_INT 179
13432: PUSH
13433: LD_INT 209
13435: PUSH
13436: LD_INT 9
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: PPUSH
13445: CALL_OW 72
13449: PUSH
13450: LD_VAR 0 2
13454: PUSH
13455: LD_INT 1
13457: MINUS
13458: GREATEREQUAL
13459: IFFALSE 13337
// end else
13461: GO 13625
// begin for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13499
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 285
13483: PPUSH
13484: LD_INT 163
13486: PPUSH
13487: LD_INT 8
13489: PPUSH
13490: LD_INT 1
13492: PPUSH
13493: CALL_OW 483
13497: GO 13473
13499: POP
13500: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13501: LD_ADDR_VAR 0 2
13505: PUSH
13506: LD_VAR 0 2
13510: PPUSH
13511: LD_INT 24
13513: PUSH
13514: LD_INT 250
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PPUSH
13521: CALL_OW 72
13525: ST_TO_ADDR
// for i in tmp do
13526: LD_ADDR_VAR 0 1
13530: PUSH
13531: LD_VAR 0 2
13535: PUSH
13536: FOR_IN
13537: IFFALSE 13577
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_INT 285
13546: PPUSH
13547: LD_INT 163
13549: PPUSH
13550: CALL_OW 297
13554: PUSH
13555: LD_INT 9
13557: GREATER
13558: IFFALSE 13575
// ComMoveXY ( i , 285 , 163 ) ;
13560: LD_VAR 0 1
13564: PPUSH
13565: LD_INT 285
13567: PPUSH
13568: LD_INT 163
13570: PPUSH
13571: CALL_OW 111
13575: GO 13536
13577: POP
13578: POP
// wait ( 0 0$1 ) ;
13579: LD_INT 35
13581: PPUSH
13582: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13586: LD_VAR 0 2
13590: PPUSH
13591: LD_INT 92
13593: PUSH
13594: LD_INT 285
13596: PUSH
13597: LD_INT 163
13599: PUSH
13600: LD_INT 9
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: PPUSH
13609: CALL_OW 72
13613: PUSH
13614: LD_VAR 0 2
13618: PUSH
13619: LD_INT 1
13621: MINUS
13622: GREATEREQUAL
13623: IFFALSE 13501
// end ; repeat wait ( 0 0$1 ) ;
13625: LD_INT 35
13627: PPUSH
13628: CALL_OW 67
// for i in tmp do
13632: LD_ADDR_VAR 0 1
13636: PUSH
13637: LD_VAR 0 2
13641: PUSH
13642: FOR_IN
13643: IFFALSE 13765
// if GetLives ( i ) > 251 then
13645: LD_VAR 0 1
13649: PPUSH
13650: CALL_OW 256
13654: PUSH
13655: LD_INT 251
13657: GREATER
13658: IFFALSE 13747
// begin if GetWeapon ( i ) = ru_time_lapser then
13660: LD_VAR 0 1
13664: PPUSH
13665: CALL_OW 264
13669: PUSH
13670: LD_INT 49
13672: EQUAL
13673: IFFALSE 13711
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13675: LD_VAR 0 1
13679: PPUSH
13680: LD_INT 81
13682: PUSH
13683: LD_INT 7
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PPUSH
13690: CALL_OW 69
13694: PPUSH
13695: LD_VAR 0 1
13699: PPUSH
13700: CALL_OW 74
13704: PPUSH
13705: CALL_OW 112
13709: GO 13745
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13711: LD_VAR 0 1
13715: PPUSH
13716: LD_INT 81
13718: PUSH
13719: LD_INT 7
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 69
13730: PPUSH
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 74
13740: PPUSH
13741: CALL_OW 115
// end else
13745: GO 13763
// tmp := tmp diff i ;
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: LD_VAR 0 2
13756: PUSH
13757: LD_VAR 0 1
13761: DIFF
13762: ST_TO_ADDR
13763: GO 13642
13765: POP
13766: POP
// until not tmp ;
13767: LD_VAR 0 2
13771: NOT
13772: IFFALSE 13625
// end ; end_of_file
13774: PPOPN 4
13776: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13777: LD_INT 0
13779: PPUSH
13780: PPUSH
13781: PPUSH
13782: PPUSH
// missionStage := 13 ;
13783: LD_ADDR_EXP 15
13787: PUSH
13788: LD_INT 13
13790: ST_TO_ADDR
// uc_side := 2 ;
13791: LD_ADDR_OWVAR 20
13795: PUSH
13796: LD_INT 2
13798: ST_TO_ADDR
// uc_nation := 2 ;
13799: LD_ADDR_OWVAR 21
13803: PUSH
13804: LD_INT 2
13806: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13807: LD_ADDR_EXP 91
13811: PUSH
13812: LD_STRING Omar
13814: PPUSH
13815: CALL_OW 25
13819: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13820: LD_EXP 91
13824: PPUSH
13825: LD_INT 4
13827: PPUSH
13828: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13832: LD_EXP 91
13836: PPUSH
13837: LD_INT 242
13839: PPUSH
13840: LD_INT 75
13842: PPUSH
13843: LD_INT 0
13845: PPUSH
13846: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13850: LD_ADDR_EXP 92
13854: PUSH
13855: LD_STRING Heike
13857: PPUSH
13858: CALL_OW 25
13862: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13863: LD_INT 14
13865: PPUSH
13866: LD_INT 3
13868: PPUSH
13869: LD_INT 1
13871: PPUSH
13872: LD_INT 27
13874: PPUSH
13875: LD_INT 100
13877: PPUSH
13878: CALL 71487 0 5
// veh := CreateVehicle ;
13882: LD_ADDR_VAR 0 3
13886: PUSH
13887: CALL_OW 45
13891: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13892: LD_VAR 0 3
13896: PPUSH
13897: LD_INT 1
13899: PPUSH
13900: CALL_OW 242
// SetDir ( veh , 4 ) ;
13904: LD_VAR 0 3
13908: PPUSH
13909: LD_INT 4
13911: PPUSH
13912: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13916: LD_VAR 0 3
13920: PPUSH
13921: LD_INT 241
13923: PPUSH
13924: LD_INT 72
13926: PPUSH
13927: LD_INT 0
13929: PPUSH
13930: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13934: LD_EXP 92
13938: PPUSH
13939: LD_VAR 0 3
13943: PPUSH
13944: CALL_OW 52
// if KhatamStatus then
13948: LD_EXP 8
13952: IFFALSE 14003
// begin Khatam := NewCharacter ( Khatam ) ;
13954: LD_ADDR_EXP 93
13958: PUSH
13959: LD_STRING Khatam
13961: PPUSH
13962: CALL_OW 25
13966: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13967: LD_EXP 93
13971: PPUSH
13972: LD_INT 245
13974: PPUSH
13975: LD_INT 78
13977: PPUSH
13978: LD_INT 3
13980: PPUSH
13981: LD_INT 0
13983: PPUSH
13984: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13988: LD_EXP 93
13992: PPUSH
13993: LD_INT 4
13995: PPUSH
13996: LD_INT 10
13998: PPUSH
13999: CALL_OW 237
// end ; for i = 1 to Difficulty do
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: DOUBLE
14009: LD_INT 1
14011: DEC
14012: ST_TO_ADDR
14013: LD_OWVAR 67
14017: PUSH
14018: FOR_TO
14019: IFFALSE 14085
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14021: LD_INT 0
14023: PPUSH
14024: LD_INT 7
14026: PUSH
14027: LD_OWVAR 67
14031: PLUS
14032: PPUSH
14033: CALL_OW 384
// un := CreateHuman ;
14037: LD_ADDR_VAR 0 4
14041: PUSH
14042: CALL_OW 44
14046: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14047: LD_VAR 0 4
14051: PPUSH
14052: LD_INT 28
14054: PUSH
14055: LD_INT 29
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: LD_VAR 0 2
14066: PUSH
14067: LD_INT 2
14069: MOD
14070: PUSH
14071: LD_INT 1
14073: PLUS
14074: ARRAY
14075: PPUSH
14076: LD_INT 0
14078: PPUSH
14079: CALL_OW 49
// end ;
14083: GO 14018
14085: POP
14086: POP
// for i = 1 to 6 do
14087: LD_ADDR_VAR 0 2
14091: PUSH
14092: DOUBLE
14093: LD_INT 1
14095: DEC
14096: ST_TO_ADDR
14097: LD_INT 6
14099: PUSH
14100: FOR_TO
14101: IFFALSE 14146
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14103: LD_INT 0
14105: PPUSH
14106: LD_INT 7
14108: PUSH
14109: LD_OWVAR 67
14113: PLUS
14114: PPUSH
14115: CALL_OW 381
// un := CreateHuman ;
14119: LD_ADDR_VAR 0 4
14123: PUSH
14124: CALL_OW 44
14128: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14129: LD_VAR 0 4
14133: PPUSH
14134: LD_INT 28
14136: PPUSH
14137: LD_INT 0
14139: PPUSH
14140: CALL_OW 49
// end ;
14144: GO 14100
14146: POP
14147: POP
// for i = 1 to 3 do
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: DOUBLE
14154: LD_INT 1
14156: DEC
14157: ST_TO_ADDR
14158: LD_INT 3
14160: PUSH
14161: FOR_TO
14162: IFFALSE 14210
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14164: LD_INT 0
14166: PPUSH
14167: LD_INT 8
14169: PPUSH
14170: LD_INT 7
14172: PUSH
14173: LD_OWVAR 67
14177: PLUS
14178: PPUSH
14179: CALL_OW 380
// un := CreateHuman ;
14183: LD_ADDR_VAR 0 4
14187: PUSH
14188: CALL_OW 44
14192: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14193: LD_VAR 0 4
14197: PPUSH
14198: LD_INT 28
14200: PPUSH
14201: LD_INT 0
14203: PPUSH
14204: CALL_OW 49
// end ;
14208: GO 14161
14210: POP
14211: POP
// for i = 1 to 3 do
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: DOUBLE
14218: LD_INT 1
14220: DEC
14221: ST_TO_ADDR
14222: LD_INT 3
14224: PUSH
14225: FOR_TO
14226: IFFALSE 14316
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14228: LD_INT 14
14230: PPUSH
14231: LD_INT 2
14233: PPUSH
14234: LD_INT 1
14236: PPUSH
14237: LD_INT 28
14239: PPUSH
14240: LD_INT 80
14242: PPUSH
14243: CALL 71487 0 5
// veh := CreateVehicle ;
14247: LD_ADDR_VAR 0 3
14251: PUSH
14252: CALL_OW 45
14256: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14257: LD_VAR 0 3
14261: PPUSH
14262: LD_INT 3
14264: PPUSH
14265: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14269: LD_VAR 0 3
14273: PPUSH
14274: LD_INT 29
14276: PPUSH
14277: LD_INT 0
14279: PPUSH
14280: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14284: LD_INT 0
14286: PPUSH
14287: LD_INT 7
14289: PUSH
14290: LD_OWVAR 67
14294: PLUS
14295: PPUSH
14296: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14300: CALL_OW 44
14304: PPUSH
14305: LD_VAR 0 3
14309: PPUSH
14310: CALL_OW 52
// end ;
14314: GO 14225
14316: POP
14317: POP
// for i = 1 to 5 + Difficulty do
14318: LD_ADDR_VAR 0 2
14322: PUSH
14323: DOUBLE
14324: LD_INT 1
14326: DEC
14327: ST_TO_ADDR
14328: LD_INT 5
14330: PUSH
14331: LD_OWVAR 67
14335: PLUS
14336: PUSH
14337: FOR_TO
14338: IFFALSE 14465
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14340: LD_INT 14
14342: PPUSH
14343: LD_INT 1
14345: PPUSH
14346: LD_INT 3
14348: PPUSH
14349: CALL_OW 12
14353: PPUSH
14354: LD_INT 1
14356: PPUSH
14357: LD_INT 28
14359: PUSH
14360: LD_INT 26
14362: PUSH
14363: LD_INT 27
14365: PUSH
14366: LD_INT 25
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: PUSH
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 4
14382: MOD
14383: PUSH
14384: LD_INT 1
14386: PLUS
14387: ARRAY
14388: PPUSH
14389: LD_INT 80
14391: PPUSH
14392: CALL 71487 0 5
// veh := CreateVehicle ;
14396: LD_ADDR_VAR 0 3
14400: PUSH
14401: CALL_OW 45
14405: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14406: LD_VAR 0 3
14410: PPUSH
14411: LD_INT 4
14413: PPUSH
14414: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14418: LD_VAR 0 3
14422: PPUSH
14423: LD_INT 28
14425: PPUSH
14426: LD_INT 0
14428: PPUSH
14429: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14433: LD_INT 0
14435: PPUSH
14436: LD_INT 7
14438: PUSH
14439: LD_OWVAR 67
14443: PLUS
14444: PPUSH
14445: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14449: CALL_OW 44
14453: PPUSH
14454: LD_VAR 0 3
14458: PPUSH
14459: CALL_OW 52
// end ;
14463: GO 14337
14465: POP
14466: POP
// for i = 1 to 3 do
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: DOUBLE
14473: LD_INT 1
14475: DEC
14476: ST_TO_ADDR
14477: LD_INT 3
14479: PUSH
14480: FOR_TO
14481: IFFALSE 14541
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14483: LD_INT 14
14485: PPUSH
14486: LD_INT 3
14488: PPUSH
14489: LD_INT 5
14491: PPUSH
14492: LD_INT 29
14494: PPUSH
14495: LD_INT 80
14497: PPUSH
14498: CALL 71487 0 5
// veh := CreateVehicle ;
14502: LD_ADDR_VAR 0 3
14506: PUSH
14507: CALL_OW 45
14511: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14512: LD_VAR 0 3
14516: PPUSH
14517: LD_INT 4
14519: PPUSH
14520: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14524: LD_VAR 0 3
14528: PPUSH
14529: LD_INT 28
14531: PPUSH
14532: LD_INT 0
14534: PPUSH
14535: CALL_OW 49
// end ;
14539: GO 14480
14541: POP
14542: POP
// end ;
14543: LD_VAR 0 1
14547: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14548: LD_INT 22
14550: PUSH
14551: LD_INT 2
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 69
14562: IFFALSE 14862
14564: GO 14566
14566: DISABLE
14567: LD_INT 0
14569: PPUSH
14570: PPUSH
14571: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14572: LD_ADDR_VAR 0 3
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 2
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 25
14589: PUSH
14590: LD_INT 4
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_EXP 93
14610: DIFF
14611: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14612: LD_ADDR_VAR 0 2
14616: PUSH
14617: LD_INT 22
14619: PUSH
14620: LD_INT 2
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PPUSH
14627: CALL_OW 69
14631: PUSH
14632: LD_EXP 93
14636: PUSH
14637: LD_VAR 0 3
14641: UNION
14642: DIFF
14643: ST_TO_ADDR
// if Khatam then
14644: LD_EXP 93
14648: IFFALSE 14665
// ComMoveXY ( Khatam , 211 , 92 ) ;
14650: LD_EXP 93
14654: PPUSH
14655: LD_INT 211
14657: PPUSH
14658: LD_INT 92
14660: PPUSH
14661: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14665: LD_INT 197
14667: PPUSH
14668: LD_INT 80
14670: PPUSH
14671: LD_INT 2
14673: PPUSH
14674: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14678: LD_INT 213
14680: PPUSH
14681: LD_INT 90
14683: PPUSH
14684: LD_INT 2
14686: PPUSH
14687: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14691: LD_INT 215
14693: PPUSH
14694: LD_INT 129
14696: PPUSH
14697: LD_INT 2
14699: PPUSH
14700: CALL_OW 441
// if sci then
14704: LD_VAR 0 3
14708: IFFALSE 14729
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14710: LD_VAR 0 3
14714: PUSH
14715: LD_INT 1
14717: ARRAY
14718: PPUSH
14719: LD_INT 197
14721: PPUSH
14722: LD_INT 80
14724: PPUSH
14725: CALL_OW 158
// if sci > 1 then
14729: LD_VAR 0 3
14733: PUSH
14734: LD_INT 1
14736: GREATER
14737: IFFALSE 14758
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14739: LD_VAR 0 3
14743: PUSH
14744: LD_INT 2
14746: ARRAY
14747: PPUSH
14748: LD_INT 213
14750: PPUSH
14751: LD_INT 90
14753: PPUSH
14754: CALL_OW 158
// if sci > 2 then
14758: LD_VAR 0 3
14762: PUSH
14763: LD_INT 2
14765: GREATER
14766: IFFALSE 14787
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14768: LD_VAR 0 3
14772: PUSH
14773: LD_INT 3
14775: ARRAY
14776: PPUSH
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14787: LD_INT 35
14789: PPUSH
14790: CALL_OW 67
// for i in tmp do
14794: LD_ADDR_VAR 0 1
14798: PUSH
14799: LD_VAR 0 2
14803: PUSH
14804: FOR_IN
14805: IFFALSE 14843
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_INT 81
14814: PUSH
14815: LD_INT 2
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PPUSH
14822: CALL_OW 69
14826: PPUSH
14827: LD_VAR 0 1
14831: PPUSH
14832: CALL_OW 74
14836: PPUSH
14837: CALL_OW 115
14841: GO 14804
14843: POP
14844: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14845: LD_INT 22
14847: PUSH
14848: LD_INT 2
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PPUSH
14855: CALL_OW 69
14859: NOT
14860: IFFALSE 14787
// end ; end_of_file
14862: PPOPN 3
14864: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14865: LD_INT 0
14867: PPUSH
14868: PPUSH
14869: PPUSH
14870: PPUSH
14871: PPUSH
14872: PPUSH
14873: PPUSH
14874: PPUSH
14875: PPUSH
// Video ( true ) ;
14876: LD_INT 1
14878: PPUSH
14879: CALL 107204 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14883: LD_ADDR_VAR 0 5
14887: PUSH
14888: LD_INT 7
14890: PPUSH
14891: LD_INT 0
14893: PPUSH
14894: CALL_OW 517
14898: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14899: LD_ADDR_VAR 0 2
14903: PUSH
14904: DOUBLE
14905: LD_INT 1
14907: DEC
14908: ST_TO_ADDR
14909: LD_VAR 0 5
14913: PUSH
14914: LD_INT 1
14916: ARRAY
14917: PUSH
14918: FOR_TO
14919: IFFALSE 14964
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14921: LD_VAR 0 5
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: PUSH
14930: LD_VAR 0 2
14934: ARRAY
14935: PPUSH
14936: LD_VAR 0 5
14940: PUSH
14941: LD_INT 2
14943: ARRAY
14944: PUSH
14945: LD_VAR 0 2
14949: ARRAY
14950: PPUSH
14951: LD_INT 1
14953: PPUSH
14954: LD_INT 15
14956: NEG
14957: PPUSH
14958: CALL 107118 0 4
14962: GO 14918
14964: POP
14965: POP
// CenterNowOnUnits ( Powell ) ;
14966: LD_EXP 57
14970: PPUSH
14971: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14975: LD_ADDR_VAR 0 5
14979: PUSH
14980: LD_EXP 55
14984: PUSH
14985: EMPTY
14986: LIST
14987: ST_TO_ADDR
// if GirlNewVeh then
14988: LD_EXP 56
14992: IFFALSE 15010
// tmp := tmp ^ GirlNewVeh ;
14994: LD_ADDR_VAR 0 5
14998: PUSH
14999: LD_VAR 0 5
15003: PUSH
15004: LD_EXP 56
15008: ADD
15009: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15010: LD_VAR 0 5
15014: PPUSH
15015: LD_INT 60
15017: PPUSH
15018: LD_INT 109
15020: PPUSH
15021: CALL_OW 111
// if KappaStatus then
15025: LD_EXP 2
15029: IFFALSE 15081
// begin Say ( JMM , D1nT-JMM-1 ) ;
15031: LD_EXP 38
15035: PPUSH
15036: LD_STRING D1nT-JMM-1
15038: PPUSH
15039: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15043: LD_EXP 57
15047: PPUSH
15048: LD_STRING D1T-Pow-1
15050: PPUSH
15051: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15055: LD_EXP 38
15059: PPUSH
15060: LD_STRING D1T-JMM-2
15062: PPUSH
15063: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15067: LD_EXP 57
15071: PPUSH
15072: LD_STRING D1T-Pow-2
15074: PPUSH
15075: CALL_OW 88
// end else
15079: GO 15287
// if JMMGirlStatus then
15081: LD_EXP 6
15085: IFFALSE 15230
// begin Say ( JMM , D1T-JMM-1 ) ;
15087: LD_EXP 38
15091: PPUSH
15092: LD_STRING D1T-JMM-1
15094: PPUSH
15095: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15099: LD_EXP 57
15103: PPUSH
15104: LD_STRING D1T-Pow-1
15106: PPUSH
15107: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15111: LD_EXP 38
15115: PPUSH
15116: LD_STRING D1T-JMM-3
15118: PPUSH
15119: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15123: LD_EXP 57
15127: PPUSH
15128: LD_STRING D1T-Pow-3
15130: PPUSH
15131: CALL_OW 88
// if JMMGirl then
15135: LD_EXP 7
15139: IFFALSE 15228
// begin case JMMGirl of 1 :
15141: LD_EXP 7
15145: PUSH
15146: LD_INT 1
15148: DOUBLE
15149: EQUAL
15150: IFTRUE 15154
15152: GO 15169
15154: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15155: LD_EXP 39
15159: PPUSH
15160: LD_STRING D1T-Joan-3
15162: PPUSH
15163: CALL_OW 88
15167: GO 15216
15169: LD_INT 2
15171: DOUBLE
15172: EQUAL
15173: IFTRUE 15177
15175: GO 15192
15177: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15178: LD_EXP 41
15182: PPUSH
15183: LD_STRING D1T-Lisa-3
15185: PPUSH
15186: CALL_OW 88
15190: GO 15216
15192: LD_INT 3
15194: DOUBLE
15195: EQUAL
15196: IFTRUE 15200
15198: GO 15215
15200: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15201: LD_EXP 53
15205: PPUSH
15206: LD_STRING D1T-Con-3
15208: PPUSH
15209: CALL_OW 88
15213: GO 15216
15215: POP
// Say ( Powell , D1T-Pow-4 ) ;
15216: LD_EXP 57
15220: PPUSH
15221: LD_STRING D1T-Pow-4
15223: PPUSH
15224: CALL_OW 88
// end ; end else
15228: GO 15287
// if not FastEnd then
15230: LD_EXP 11
15234: NOT
15235: IFFALSE 15263
// begin Say ( JMM , D1T-JMM-4 ) ;
15237: LD_EXP 38
15241: PPUSH
15242: LD_STRING D1T-JMM-4
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15249: LD_EXP 57
15253: PPUSH
15254: LD_STRING D1T-Pow-5
15256: PPUSH
15257: CALL_OW 88
// end else
15261: GO 15287
// begin Say ( JMM , D1nT-JMM-1 ) ;
15263: LD_EXP 38
15267: PPUSH
15268: LD_STRING D1nT-JMM-1
15270: PPUSH
15271: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15275: LD_EXP 57
15279: PPUSH
15280: LD_STRING D1nT-Pow-1
15282: PPUSH
15283: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15294: LD_EXP 55
15298: PPUSH
15299: CALL_OW 314
15303: NOT
15304: IFFALSE 15287
// ComExitVehicle ( JMM ) ;
15306: LD_EXP 38
15310: PPUSH
15311: CALL_OW 121
// wait ( 3 ) ;
15315: LD_INT 3
15317: PPUSH
15318: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15322: LD_EXP 38
15326: PPUSH
15327: LD_INT 60
15329: PPUSH
15330: LD_INT 94
15332: PPUSH
15333: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15337: LD_EXP 38
15341: PPUSH
15342: LD_EXP 57
15346: PPUSH
15347: CALL_OW 179
// if Joan then
15351: LD_EXP 39
15355: IFFALSE 15409
// begin ComExitVehicle ( Joan ) ;
15357: LD_EXP 39
15361: PPUSH
15362: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15366: LD_EXP 39
15370: PPUSH
15371: LD_INT 35
15373: PPUSH
15374: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15378: LD_EXP 39
15382: PPUSH
15383: LD_INT 65
15385: PPUSH
15386: LD_INT 104
15388: PPUSH
15389: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15393: LD_EXP 39
15397: PPUSH
15398: LD_EXP 38
15402: PPUSH
15403: CALL_OW 179
// end else
15407: GO 15543
// if Lisa and JMMGirl = 2 then
15409: LD_EXP 41
15413: PUSH
15414: LD_EXP 7
15418: PUSH
15419: LD_INT 2
15421: EQUAL
15422: AND
15423: IFFALSE 15477
// begin ComExitVehicle ( Lisa ) ;
15425: LD_EXP 41
15429: PPUSH
15430: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15434: LD_EXP 41
15438: PPUSH
15439: LD_INT 35
15441: PPUSH
15442: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15446: LD_EXP 41
15450: PPUSH
15451: LD_INT 65
15453: PPUSH
15454: LD_INT 104
15456: PPUSH
15457: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15461: LD_EXP 41
15465: PPUSH
15466: LD_EXP 38
15470: PPUSH
15471: CALL_OW 179
// end else
15475: GO 15543
// if Connie and JMMGirl = 3 then
15477: LD_EXP 53
15481: PUSH
15482: LD_EXP 7
15486: PUSH
15487: LD_INT 3
15489: EQUAL
15490: AND
15491: IFFALSE 15543
// begin ComExitVehicle ( Connie ) ;
15493: LD_EXP 53
15497: PPUSH
15498: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15502: LD_EXP 53
15506: PPUSH
15507: LD_INT 35
15509: PPUSH
15510: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15514: LD_EXP 53
15518: PPUSH
15519: LD_INT 65
15521: PPUSH
15522: LD_INT 104
15524: PPUSH
15525: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15529: LD_EXP 53
15533: PPUSH
15534: LD_EXP 38
15538: PPUSH
15539: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15543: LD_INT 35
15545: PPUSH
15546: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15550: LD_EXP 38
15554: PPUSH
15555: LD_EXP 57
15559: PPUSH
15560: CALL_OW 296
15564: PUSH
15565: LD_INT 6
15567: LESS
15568: IFFALSE 15543
// wait ( 0 0$0.5 ) ;
15570: LD_INT 18
15572: PPUSH
15573: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15577: LD_EXP 38
15581: PPUSH
15582: LD_STRING D1-JMM-1
15584: PPUSH
15585: CALL_OW 88
// async ;
15589: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15590: LD_EXP 57
15594: PPUSH
15595: LD_STRING D1-Pow-1
15597: PPUSH
15598: CALL_OW 88
// if not dialogue_skipped then
15602: LD_OWVAR 59
15606: NOT
15607: IFFALSE 15616
// wait ( 0 0$2 ) ;
15609: LD_INT 70
15611: PPUSH
15612: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15616: LD_INT 170
15618: PPUSH
15619: LD_INT 99
15621: PPUSH
15622: LD_INT 1
15624: PPUSH
15625: LD_INT 6
15627: NEG
15628: PPUSH
15629: CALL 107118 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15633: LD_INT 174
15635: PPUSH
15636: LD_INT 115
15638: PPUSH
15639: LD_INT 1
15641: PPUSH
15642: LD_INT 6
15644: NEG
15645: PPUSH
15646: CALL 107118 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15650: LD_INT 169
15652: PPUSH
15653: LD_INT 71
15655: PPUSH
15656: LD_INT 1
15658: PPUSH
15659: LD_INT 6
15661: NEG
15662: PPUSH
15663: CALL 107118 0 4
// if not dialogue_skipped then
15667: LD_OWVAR 59
15671: NOT
15672: IFFALSE 15691
// begin CenterOnXY ( 170 , 99 ) ;
15674: LD_INT 170
15676: PPUSH
15677: LD_INT 99
15679: PPUSH
15680: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15684: LD_INT 80
15686: PPUSH
15687: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15691: LD_INT 75
15693: PPUSH
15694: LD_INT 53
15696: PPUSH
15697: LD_INT 1
15699: PPUSH
15700: LD_INT 9
15702: NEG
15703: PPUSH
15704: CALL 107118 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15708: LD_INT 54
15710: PPUSH
15711: LD_INT 42
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: LD_INT 9
15719: NEG
15720: PPUSH
15721: CALL 107118 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15725: LD_INT 62
15727: PPUSH
15728: LD_INT 51
15730: PPUSH
15731: LD_INT 1
15733: PPUSH
15734: LD_INT 9
15736: NEG
15737: PPUSH
15738: CALL 107118 0 4
// if not dialogue_skipped then
15742: LD_OWVAR 59
15746: NOT
15747: IFFALSE 15766
// begin CenterOnXY ( 75 , 53 ) ;
15749: LD_INT 75
15751: PPUSH
15752: LD_INT 53
15754: PPUSH
15755: CALL_OW 84
// wait ( 0 0$4 ) ;
15759: LD_INT 140
15761: PPUSH
15762: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15766: LD_EXP 57
15770: PPUSH
15771: CALL_OW 87
// if not dialogue_skipped then
15775: LD_OWVAR 59
15779: NOT
15780: IFFALSE 15789
// wait ( 0 0$2 ) ;
15782: LD_INT 70
15784: PPUSH
15785: CALL_OW 67
// sync ;
15789: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15790: LD_EXP 38
15794: PPUSH
15795: LD_STRING D1-JMM-2
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15802: LD_EXP 57
15806: PPUSH
15807: LD_STRING D1-Pow-2
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15814: LD_EXP 38
15818: PPUSH
15819: LD_STRING D1-JMM-3
15821: PPUSH
15822: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15826: LD_EXP 57
15830: PPUSH
15831: LD_STRING D1-Pow-3
15833: PPUSH
15834: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15838: LD_EXP 38
15842: PPUSH
15843: LD_STRING D1-JMM-4
15845: PPUSH
15846: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15850: LD_EXP 57
15854: PPUSH
15855: LD_STRING D1-Pow-4
15857: PPUSH
15858: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15862: LD_EXP 38
15866: PPUSH
15867: LD_STRING D1-JMM-5
15869: PPUSH
15870: CALL_OW 88
// async ;
15874: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15875: LD_EXP 57
15879: PPUSH
15880: LD_STRING D1-Pow-5
15882: PPUSH
15883: CALL_OW 88
// if not dialogue_skipped then
15887: LD_OWVAR 59
15891: NOT
15892: IFFALSE 15901
// wait ( 0 0$3.6 ) ;
15894: LD_INT 126
15896: PPUSH
15897: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15901: LD_INT 134
15903: PPUSH
15904: LD_INT 210
15906: PPUSH
15907: LD_INT 1
15909: PPUSH
15910: LD_INT 11
15912: NEG
15913: PPUSH
15914: CALL 107118 0 4
// if not dialogue_skipped then
15918: LD_OWVAR 59
15922: NOT
15923: IFFALSE 15942
// begin CenterOnXY ( 134 , 210 ) ;
15925: LD_INT 134
15927: PPUSH
15928: LD_INT 210
15930: PPUSH
15931: CALL_OW 84
// wait ( 0 0$2 ) ;
15935: LD_INT 70
15937: PPUSH
15938: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15942: LD_INT 101
15944: PPUSH
15945: LD_INT 159
15947: PPUSH
15948: LD_INT 1
15950: PPUSH
15951: LD_INT 10
15953: NEG
15954: PPUSH
15955: CALL 107118 0 4
// if not dialogue_skipped then
15959: LD_OWVAR 59
15963: NOT
15964: IFFALSE 15983
// begin CenterOnXY ( 101 , 159 ) ;
15966: LD_INT 101
15968: PPUSH
15969: LD_INT 159
15971: PPUSH
15972: CALL_OW 84
// wait ( 0 0$2 ) ;
15976: LD_INT 70
15978: PPUSH
15979: CALL_OW 67
// end ; sync ;
15983: SYNC
// CenterNowOnUnits ( Powell ) ;
15984: LD_EXP 57
15988: PPUSH
15989: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15993: LD_ADDR_VAR 0 6
15997: PUSH
15998: LD_INT 1
16000: PUSH
16001: LD_INT 2
16003: PUSH
16004: LD_INT 3
16006: PUSH
16007: LD_INT 4
16009: PUSH
16010: LD_INT 5
16012: PUSH
16013: LD_INT 6
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: ST_TO_ADDR
// if not dialogue_skipped then
16024: LD_OWVAR 59
16028: NOT
16029: IFFALSE 16198
// begin game_speed := 4 ;
16031: LD_ADDR_OWVAR 65
16035: PUSH
16036: LD_INT 4
16038: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16039: LD_INT 210
16041: PPUSH
16042: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16046: LD_ADDR_VAR 0 7
16050: PUSH
16051: LD_STRING Q1
16053: PPUSH
16054: LD_VAR 0 6
16058: PPUSH
16059: CALL_OW 98
16063: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16064: LD_ADDR_VAR 0 7
16068: PUSH
16069: LD_STRING Q1
16071: PPUSH
16072: LD_VAR 0 6
16076: PPUSH
16077: CALL_OW 98
16081: ST_TO_ADDR
// options = options diff dec ;
16082: LD_ADDR_VAR 0 6
16086: PUSH
16087: LD_VAR 0 6
16091: PUSH
16092: LD_VAR 0 7
16096: DIFF
16097: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16098: LD_VAR 0 7
16102: PPUSH
16103: LD_VAR 0 6
16107: PPUSH
16108: CALL 17670 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16112: LD_VAR 0 7
16116: PUSH
16117: LD_INT 5
16119: PUSH
16120: LD_INT 6
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: IN
16127: PUSH
16128: LD_VAR 0 6
16132: PUSH
16133: LD_INT 2
16135: EQUAL
16136: OR
16137: IFFALSE 16064
// if not ( dec in [ 5 , 6 ] ) then
16139: LD_VAR 0 7
16143: PUSH
16144: LD_INT 5
16146: PUSH
16147: LD_INT 6
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: IN
16154: NOT
16155: IFFALSE 16198
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16157: LD_ADDR_VAR 0 7
16161: PUSH
16162: LD_STRING Q1a
16164: PPUSH
16165: LD_INT 1
16167: PUSH
16168: LD_INT 2
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: PPUSH
16175: CALL_OW 98
16179: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16180: LD_VAR 0 7
16184: PUSH
16185: LD_INT 4
16187: PLUS
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17670 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16198: LD_INT 81
16200: PPUSH
16201: LD_INT 127
16203: PPUSH
16204: CALL_OW 84
// amount := 5 ;
16208: LD_ADDR_VAR 0 8
16212: PUSH
16213: LD_INT 5
16215: ST_TO_ADDR
// macmilan_squad := [ ] ;
16216: LD_ADDR_VAR 0 9
16220: PUSH
16221: EMPTY
16222: ST_TO_ADDR
// if vip < amount then
16223: LD_EXP 58
16227: PUSH
16228: LD_VAR 0 8
16232: LESS
16233: IFFALSE 16277
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16235: LD_ADDR_VAR 0 5
16239: PUSH
16240: LD_EXP 58
16244: PUSH
16245: LD_INT 22
16247: PUSH
16248: LD_INT 4
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: PUSH
16255: LD_INT 21
16257: PUSH
16258: LD_INT 1
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PPUSH
16269: CALL_OW 69
16273: UNION
16274: ST_TO_ADDR
16275: GO 16287
// tmp := vip ;
16277: LD_ADDR_VAR 0 5
16281: PUSH
16282: LD_EXP 58
16286: ST_TO_ADDR
// tmp := tmp diff Powell ;
16287: LD_ADDR_VAR 0 5
16291: PUSH
16292: LD_VAR 0 5
16296: PUSH
16297: LD_EXP 57
16301: DIFF
16302: ST_TO_ADDR
// if tmp < amount then
16303: LD_VAR 0 5
16307: PUSH
16308: LD_VAR 0 8
16312: LESS
16313: IFFALSE 16325
// amount := tmp ;
16315: LD_ADDR_VAR 0 8
16319: PUSH
16320: LD_VAR 0 5
16324: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16325: LD_VAR 0 5
16329: PUSH
16330: LD_INT 1
16332: ARRAY
16333: PPUSH
16334: CALL_OW 257
16338: PUSH
16339: LD_INT 2
16341: NONEQUAL
16342: IFFALSE 16404
// begin if IsInUnit ( tmp [ 1 ] ) then
16344: LD_VAR 0 5
16348: PUSH
16349: LD_INT 1
16351: ARRAY
16352: PPUSH
16353: CALL_OW 310
16357: IFFALSE 16372
// ComExitBuilding ( tmp [ 1 ] ) ;
16359: LD_VAR 0 5
16363: PUSH
16364: LD_INT 1
16366: ARRAY
16367: PPUSH
16368: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16372: LD_VAR 0 5
16376: PUSH
16377: LD_INT 1
16379: ARRAY
16380: PPUSH
16381: LD_INT 387
16383: PPUSH
16384: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16388: LD_VAR 0 5
16392: PUSH
16393: LD_INT 1
16395: ARRAY
16396: PPUSH
16397: LD_INT 2
16399: PPUSH
16400: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16404: LD_EXP 38
16408: PPUSH
16409: LD_INT 82
16411: PPUSH
16412: LD_INT 129
16414: PPUSH
16415: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16419: LD_EXP 38
16423: PPUSH
16424: LD_EXP 57
16428: PPUSH
16429: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16433: LD_INT 22
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL_OW 69
16447: PUSH
16448: LD_EXP 38
16452: DIFF
16453: PPUSH
16454: LD_INT 84
16456: PPUSH
16457: LD_INT 128
16459: PPUSH
16460: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16464: LD_INT 22
16466: PUSH
16467: LD_INT 1
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 69
16478: PUSH
16479: LD_EXP 38
16483: DIFF
16484: PPUSH
16485: LD_EXP 38
16489: PPUSH
16490: CALL_OW 179
// for i = 1 to amount do
16494: LD_ADDR_VAR 0 2
16498: PUSH
16499: DOUBLE
16500: LD_INT 1
16502: DEC
16503: ST_TO_ADDR
16504: LD_VAR 0 8
16508: PUSH
16509: FOR_TO
16510: IFFALSE 16678
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16512: LD_ADDR_VAR 0 9
16516: PUSH
16517: LD_VAR 0 9
16521: PUSH
16522: LD_VAR 0 5
16526: PUSH
16527: LD_VAR 0 2
16531: ARRAY
16532: ADD
16533: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16534: LD_VAR 0 5
16538: PUSH
16539: LD_VAR 0 2
16543: ARRAY
16544: PPUSH
16545: CALL_OW 310
16549: IFFALSE 16566
// AddComExitBuilding ( tmp [ i ] ) ;
16551: LD_VAR 0 5
16555: PUSH
16556: LD_VAR 0 2
16560: ARRAY
16561: PPUSH
16562: CALL_OW 182
// if i = 2 and JMMNewVeh then
16566: LD_VAR 0 2
16570: PUSH
16571: LD_INT 2
16573: EQUAL
16574: PUSH
16575: LD_EXP 55
16579: AND
16580: IFFALSE 16638
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16582: LD_VAR 0 5
16586: PUSH
16587: LD_VAR 0 2
16591: ARRAY
16592: PPUSH
16593: LD_EXP 55
16597: PPUSH
16598: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16602: LD_VAR 0 5
16606: PUSH
16607: LD_VAR 0 2
16611: ARRAY
16612: PPUSH
16613: LD_INT 86
16615: PPUSH
16616: LD_INT 133
16618: PPUSH
16619: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: PPUSH
16634: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16638: LD_VAR 0 5
16642: PUSH
16643: LD_VAR 0 2
16647: ARRAY
16648: PPUSH
16649: LD_INT 8
16651: PPUSH
16652: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16656: LD_VAR 0 5
16660: PUSH
16661: LD_VAR 0 2
16665: ARRAY
16666: PPUSH
16667: LD_EXP 38
16671: PPUSH
16672: CALL_OW 179
// end ;
16676: GO 16509
16678: POP
16679: POP
// if GirlNewVeh then
16680: LD_EXP 56
16684: IFFALSE 16698
// SetSide ( GirlNewVeh , 4 ) ;
16686: LD_EXP 56
16690: PPUSH
16691: LD_INT 4
16693: PPUSH
16694: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16698: LD_INT 35
16700: PPUSH
16701: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16705: LD_VAR 0 9
16709: PPUSH
16710: LD_INT 95
16712: PUSH
16713: LD_INT 9
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PPUSH
16720: CALL_OW 72
16724: PUSH
16725: LD_INT 0
16727: EQUAL
16728: PUSH
16729: LD_EXP 38
16733: PPUSH
16734: LD_INT 9
16736: PPUSH
16737: CALL_OW 308
16741: NOT
16742: AND
16743: IFFALSE 16698
// wait ( 0 0$2 ) ;
16745: LD_INT 70
16747: PPUSH
16748: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16752: LD_VAR 0 9
16756: PPUSH
16757: LD_INT 1
16759: PPUSH
16760: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16764: LD_INT 21
16766: PUSH
16767: LD_INT 2
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: PUSH
16774: LD_INT 92
16776: PUSH
16777: LD_INT 83
16779: PUSH
16780: LD_INT 130
16782: PUSH
16783: LD_INT 10
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: PPUSH
16796: CALL_OW 69
16800: PPUSH
16801: LD_INT 1
16803: PPUSH
16804: CALL_OW 235
// Video ( false ) ;
16808: LD_INT 0
16810: PPUSH
16811: CALL 107204 0 1
// ChangeMissionObjectives ( M1 ) ;
16815: LD_STRING M1
16817: PPUSH
16818: CALL_OW 337
// SaveForQuickRestart ;
16822: CALL_OW 22
// missionStart := true ;
16826: LD_ADDR_EXP 13
16830: PUSH
16831: LD_INT 1
16833: ST_TO_ADDR
// missionStage := 2 ;
16834: LD_ADDR_EXP 15
16838: PUSH
16839: LD_INT 2
16841: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16842: LD_INT 105
16844: PPUSH
16845: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16849: LD_ADDR_VAR 0 5
16853: PUSH
16854: LD_INT 22
16856: PUSH
16857: LD_INT 4
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: LD_INT 21
16866: PUSH
16867: LD_INT 1
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PPUSH
16878: CALL_OW 69
16882: PUSH
16883: LD_EXP 57
16887: DIFF
16888: ST_TO_ADDR
// if not tmp then
16889: LD_VAR 0 5
16893: NOT
16894: IFFALSE 16909
// tmp := [ Powell ] ;
16896: LD_ADDR_VAR 0 5
16900: PUSH
16901: LD_EXP 57
16905: PUSH
16906: EMPTY
16907: LIST
16908: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16909: LD_ADDR_EXP 101
16913: PUSH
16914: LD_EXP 101
16918: PPUSH
16919: LD_INT 4
16921: PPUSH
16922: LD_INT 22
16924: PUSH
16925: LD_INT 4
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 23
16934: PUSH
16935: LD_INT 1
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PUSH
16942: LD_INT 3
16944: PUSH
16945: LD_INT 21
16947: PUSH
16948: LD_INT 2
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 57
16973: DIFF
16974: PPUSH
16975: CALL_OW 1
16979: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16980: LD_ADDR_VAR 0 4
16984: PUSH
16985: LD_INT 22
16987: PUSH
16988: LD_INT 4
16990: PUSH
16991: EMPTY
16992: LIST
16993: LIST
16994: PUSH
16995: LD_INT 34
16997: PUSH
16998: LD_INT 12
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: PPUSH
17009: CALL_OW 69
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17018: LD_VAR 0 5
17022: PUSH
17023: LD_INT 1
17025: ARRAY
17026: PPUSH
17027: CALL_OW 310
17031: IFFALSE 17046
// ComExitBuilding ( tmp [ 1 ] ) ;
17033: LD_VAR 0 5
17037: PUSH
17038: LD_INT 1
17040: ARRAY
17041: PPUSH
17042: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17046: LD_VAR 0 5
17050: PUSH
17051: LD_INT 1
17053: ARRAY
17054: PPUSH
17055: LD_VAR 0 4
17059: PPUSH
17060: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17064: LD_VAR 0 5
17068: PUSH
17069: LD_INT 1
17071: ARRAY
17072: PPUSH
17073: LD_INT 80
17075: PPUSH
17076: LD_INT 136
17078: PPUSH
17079: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17083: LD_VAR 0 5
17087: PUSH
17088: LD_INT 1
17090: ARRAY
17091: PPUSH
17092: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17096: LD_VAR 0 5
17100: PUSH
17101: LD_INT 1
17103: ARRAY
17104: PPUSH
17105: LD_INT 59
17107: PPUSH
17108: LD_INT 112
17110: PPUSH
17111: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17115: LD_VAR 0 5
17119: PUSH
17120: LD_INT 1
17122: ARRAY
17123: PPUSH
17124: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17128: LD_EXP 39
17132: PUSH
17133: LD_EXP 39
17137: PPUSH
17138: CALL_OW 255
17142: PUSH
17143: LD_INT 1
17145: EQUAL
17146: AND
17147: IFFALSE 17173
// begin Say ( Joan , D3W-Joan-1 ) ;
17149: LD_EXP 39
17153: PPUSH
17154: LD_STRING D3W-Joan-1
17156: PPUSH
17157: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17161: LD_EXP 38
17165: PPUSH
17166: LD_STRING D3W-JMM-1
17168: PPUSH
17169: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17173: LD_EXP 41
17177: PUSH
17178: LD_EXP 41
17182: PPUSH
17183: CALL_OW 255
17187: PUSH
17188: LD_INT 1
17190: EQUAL
17191: AND
17192: PUSH
17193: LD_EXP 41
17197: PUSH
17198: LD_EXP 58
17202: IN
17203: NOT
17204: AND
17205: IFFALSE 17231
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17207: LD_EXP 41
17211: PPUSH
17212: LD_STRING D3W-Lisa-1
17214: PPUSH
17215: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17219: LD_EXP 38
17223: PPUSH
17224: LD_STRING D3W-JMM-1
17226: PPUSH
17227: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17231: LD_EXP 53
17235: PUSH
17236: LD_EXP 53
17240: PPUSH
17241: CALL_OW 255
17245: PUSH
17246: LD_INT 1
17248: EQUAL
17249: AND
17250: IFFALSE 17276
// begin Say ( Connie , D3W-Con-1 ) ;
17252: LD_EXP 53
17256: PPUSH
17257: LD_STRING D3W-Con-1
17259: PPUSH
17260: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17264: LD_EXP 38
17268: PPUSH
17269: LD_STRING D3W-JMM-1
17271: PPUSH
17272: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17276: LD_EXP 41
17280: PUSH
17281: LD_EXP 58
17285: IN
17286: PUSH
17287: LD_EXP 41
17291: PPUSH
17292: CALL_OW 255
17296: PUSH
17297: LD_INT 1
17299: EQUAL
17300: AND
17301: IFFALSE 17317
// Say ( Lisa , D3nW-Lisa-1 ) else
17303: LD_EXP 41
17307: PPUSH
17308: LD_STRING D3nW-Lisa-1
17310: PPUSH
17311: CALL_OW 88
17315: GO 17561
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17317: LD_EXP 44
17321: PUSH
17322: LD_EXP 58
17326: IN
17327: PUSH
17328: LD_EXP 44
17332: PPUSH
17333: CALL_OW 255
17337: PUSH
17338: LD_INT 1
17340: EQUAL
17341: AND
17342: IFFALSE 17358
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17344: LD_EXP 44
17348: PPUSH
17349: LD_STRING D3nW-Cyrus-1
17351: PPUSH
17352: CALL_OW 88
17356: GO 17561
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17358: LD_EXP 43
17362: PUSH
17363: LD_EXP 58
17367: IN
17368: PUSH
17369: LD_EXP 43
17373: PPUSH
17374: CALL_OW 255
17378: PUSH
17379: LD_INT 1
17381: EQUAL
17382: AND
17383: IFFALSE 17399
// Say ( Bobby , D3nW-Bobby-1 ) else
17385: LD_EXP 43
17389: PPUSH
17390: LD_STRING D3nW-Bobby-1
17392: PPUSH
17393: CALL_OW 88
17397: GO 17561
// if Gary in vip and GetSide ( Gary ) = 1 then
17399: LD_EXP 50
17403: PUSH
17404: LD_EXP 58
17408: IN
17409: PUSH
17410: LD_EXP 50
17414: PPUSH
17415: CALL_OW 255
17419: PUSH
17420: LD_INT 1
17422: EQUAL
17423: AND
17424: IFFALSE 17440
// Say ( Gary , D3nW-Gary-1 ) else
17426: LD_EXP 50
17430: PPUSH
17431: LD_STRING D3nW-Gary-1
17433: PPUSH
17434: CALL_OW 88
17438: GO 17561
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17440: LD_EXP 42
17444: PUSH
17445: LD_EXP 58
17449: IN
17450: PUSH
17451: LD_EXP 42
17455: PPUSH
17456: CALL_OW 255
17460: PUSH
17461: LD_INT 1
17463: EQUAL
17464: AND
17465: IFFALSE 17481
// Say ( Donaldson , D3nW-Don-1 ) else
17467: LD_EXP 42
17471: PPUSH
17472: LD_STRING D3nW-Don-1
17474: PPUSH
17475: CALL_OW 88
17479: GO 17561
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17481: LD_EXP 49
17485: PUSH
17486: LD_EXP 58
17490: IN
17491: PUSH
17492: LD_EXP 49
17496: PPUSH
17497: CALL_OW 255
17501: PUSH
17502: LD_INT 1
17504: EQUAL
17505: AND
17506: IFFALSE 17522
// Say ( Cornel , D3nW-Corn-1 ) else
17508: LD_EXP 49
17512: PPUSH
17513: LD_STRING D3nW-Corn-1
17515: PPUSH
17516: CALL_OW 88
17520: GO 17561
// if Frank in vip and GetSide ( Frank ) = 1 then
17522: LD_EXP 51
17526: PUSH
17527: LD_EXP 58
17531: IN
17532: PUSH
17533: LD_EXP 51
17537: PPUSH
17538: CALL_OW 255
17542: PUSH
17543: LD_INT 1
17545: EQUAL
17546: AND
17547: IFFALSE 17561
// Say ( Frank , D3nW-Frank-1 ) ;
17549: LD_EXP 51
17553: PPUSH
17554: LD_STRING D3nW-Frank-1
17556: PPUSH
17557: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17561: LD_EXP 58
17565: PPUSH
17566: LD_INT 22
17568: PUSH
17569: LD_INT 1
17571: PUSH
17572: EMPTY
17573: LIST
17574: LIST
17575: PPUSH
17576: CALL_OW 72
17580: IFFALSE 17606
// begin Say ( JMM , D3nW-JMM-1 ) ;
17582: LD_EXP 38
17586: PPUSH
17587: LD_STRING D3nW-JMM-1
17589: PPUSH
17590: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17594: LD_EXP 38
17598: PPUSH
17599: LD_STRING D3nW-JMM-1a
17601: PPUSH
17602: CALL_OW 88
// end ; t := 0 0$00 ;
17606: LD_ADDR_VAR 0 3
17610: PUSH
17611: LD_INT 0
17613: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17614: LD_INT 35
17616: PPUSH
17617: CALL_OW 67
// t := t + 0 0$1 ;
17621: LD_ADDR_VAR 0 3
17625: PUSH
17626: LD_VAR 0 3
17630: PUSH
17631: LD_INT 35
17633: PLUS
17634: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17635: LD_INT 59
17637: PPUSH
17638: LD_INT 112
17640: PPUSH
17641: CALL_OW 428
17645: PUSH
17646: LD_VAR 0 3
17650: PUSH
17651: LD_INT 2100
17653: GREATER
17654: OR
17655: IFFALSE 17614
// activeAttacks := true ;
17657: LD_ADDR_EXP 16
17661: PUSH
17662: LD_INT 1
17664: ST_TO_ADDR
// end ;
17665: LD_VAR 0 1
17669: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17670: LD_INT 0
17672: PPUSH
// case question of 1 :
17673: LD_VAR 0 1
17677: PUSH
17678: LD_INT 1
17680: DOUBLE
17681: EQUAL
17682: IFTRUE 17686
17684: GO 17737
17686: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17687: LD_EXP 38
17691: PPUSH
17692: LD_STRING D2Mot-JMM-1
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17699: LD_EXP 57
17703: PPUSH
17704: LD_STRING D2Mot-Pow-1
17706: PPUSH
17707: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17711: LD_EXP 38
17715: PPUSH
17716: LD_STRING D2Mot-JMM-2
17718: PPUSH
17719: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17723: LD_EXP 57
17727: PPUSH
17728: LD_STRING D2Mot-Pow-2
17730: PPUSH
17731: CALL_OW 88
// end ; 2 :
17735: GO 18088
17737: LD_INT 2
17739: DOUBLE
17740: EQUAL
17741: IFTRUE 17745
17743: GO 17821
17745: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17746: LD_EXP 38
17750: PPUSH
17751: LD_STRING D2Rus-JMM-1
17753: PPUSH
17754: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17758: LD_EXP 57
17762: PPUSH
17763: LD_STRING D2Rus-Pow-1
17765: PPUSH
17766: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17770: LD_EXP 38
17774: PPUSH
17775: LD_STRING D2Rus-JMM-2
17777: PPUSH
17778: CALL_OW 88
// if not ( 3 in list_of_q ) then
17782: LD_INT 3
17784: PUSH
17785: LD_VAR 0 2
17789: IN
17790: NOT
17791: IFFALSE 17807
// Say ( Powell , D2Rus-Pow-2 ) else
17793: LD_EXP 57
17797: PPUSH
17798: LD_STRING D2Rus-Pow-2
17800: PPUSH
17801: CALL_OW 88
17805: GO 17819
// Say ( Powell , D2Rus-Pow-2a ) ;
17807: LD_EXP 57
17811: PPUSH
17812: LD_STRING D2Rus-Pow-2a
17814: PPUSH
17815: CALL_OW 88
// end ; 3 :
17819: GO 18088
17821: LD_INT 3
17823: DOUBLE
17824: EQUAL
17825: IFTRUE 17829
17827: GO 17914
17829: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17830: LD_EXP 38
17834: PPUSH
17835: LD_STRING D2Leg-JMM-1
17837: PPUSH
17838: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17842: LD_EXP 57
17846: PPUSH
17847: LD_STRING D2Leg-Pow-1
17849: PPUSH
17850: CALL_OW 88
// if 2 in list_of_q then
17854: LD_INT 2
17856: PUSH
17857: LD_VAR 0 2
17861: IN
17862: IFFALSE 17888
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17864: LD_EXP 38
17868: PPUSH
17869: LD_STRING D2Leg-JMM-2
17871: PPUSH
17872: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17876: LD_EXP 57
17880: PPUSH
17881: LD_STRING D2Leg-Pow-2
17883: PPUSH
17884: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17888: LD_EXP 38
17892: PPUSH
17893: LD_STRING D2Leg-JMM-3
17895: PPUSH
17896: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17900: LD_EXP 57
17904: PPUSH
17905: LD_STRING D2Leg-Pow-3
17907: PPUSH
17908: CALL_OW 88
// end ; 4 :
17912: GO 18088
17914: LD_INT 4
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17997
17922: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17923: LD_EXP 38
17927: PPUSH
17928: LD_STRING D2Ar-JMM-1
17930: PPUSH
17931: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17935: LD_EXP 57
17939: PPUSH
17940: LD_STRING D2Ar-Pow-1
17942: PPUSH
17943: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17947: LD_EXP 38
17951: PPUSH
17952: LD_STRING D2Ar-JMM-2
17954: PPUSH
17955: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17959: LD_EXP 57
17963: PPUSH
17964: LD_STRING D2Ar-Pow-2
17966: PPUSH
17967: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17971: LD_EXP 38
17975: PPUSH
17976: LD_STRING D2Ar-JMM-3
17978: PPUSH
17979: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17983: LD_EXP 57
17987: PPUSH
17988: LD_STRING D2Ar-Pow-3
17990: PPUSH
17991: CALL_OW 88
// end ; 5 :
17995: GO 18088
17997: LD_INT 5
17999: DOUBLE
18000: EQUAL
18001: IFTRUE 18005
18003: GO 18020
18005: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18006: LD_EXP 38
18010: PPUSH
18011: LD_STRING D2Conf-JMM-1
18013: PPUSH
18014: CALL_OW 88
18018: GO 18088
18020: LD_INT 6
18022: DOUBLE
18023: EQUAL
18024: IFTRUE 18028
18026: GO 18087
18028: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18029: LD_EXP 38
18033: PPUSH
18034: LD_STRING D2Com-JMM-1
18036: PPUSH
18037: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18041: LD_EXP 57
18045: PPUSH
18046: LD_STRING D2Com-Pow-1
18048: PPUSH
18049: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18053: LD_EXP 38
18057: PPUSH
18058: LD_STRING D2Com-JMM-2
18060: PPUSH
18061: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18065: LD_EXP 57
18069: PPUSH
18070: LD_STRING D2Com-Pow-2
18072: PPUSH
18073: CALL_OW 88
// powellAngerQuery := true ;
18077: LD_ADDR_EXP 36
18081: PUSH
18082: LD_INT 1
18084: ST_TO_ADDR
// end ; end ;
18085: GO 18088
18087: POP
// end ;
18088: LD_VAR 0 3
18092: RET
// every 0 0$5 trigger missionStart do var tmp ;
18093: LD_EXP 13
18097: IFFALSE 18380
18099: GO 18101
18101: DISABLE
18102: LD_INT 0
18104: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18105: LD_INT 35
18107: PPUSH
18108: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18112: LD_INT 14
18114: PPUSH
18115: LD_INT 22
18117: PUSH
18118: LD_INT 1
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PPUSH
18125: CALL_OW 70
18129: PUSH
18130: LD_EXP 15
18134: PUSH
18135: LD_INT 2
18137: PUSH
18138: LD_INT 3
18140: PUSH
18141: LD_INT 4
18143: PUSH
18144: LD_INT 5
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: LIST
18151: LIST
18152: IN
18153: AND
18154: IFFALSE 18370
// begin powellAnger := powellAnger + 1 ;
18156: LD_ADDR_EXP 17
18160: PUSH
18161: LD_EXP 17
18165: PUSH
18166: LD_INT 1
18168: PLUS
18169: ST_TO_ADDR
// Video ( true ) ;
18170: LD_INT 1
18172: PPUSH
18173: CALL 107204 0 1
// CenterNowOnUnits ( tmp ) ;
18177: LD_VAR 0 1
18181: PPUSH
18182: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18186: LD_INT 14
18188: PPUSH
18189: LD_INT 22
18191: PUSH
18192: LD_INT 1
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: PPUSH
18199: CALL_OW 70
18203: PPUSH
18204: LD_INT 86
18206: PPUSH
18207: LD_INT 133
18209: PPUSH
18210: CALL_OW 111
// async ;
18214: ASYNC
// case powellAnger of 1 :
18215: LD_EXP 17
18219: PUSH
18220: LD_INT 1
18222: DOUBLE
18223: EQUAL
18224: IFTRUE 18228
18226: GO 18243
18228: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18229: LD_EXP 57
18233: PPUSH
18234: LD_STRING DBack1-Pow-1
18236: PPUSH
18237: CALL_OW 88
18241: GO 18290
18243: LD_INT 2
18245: DOUBLE
18246: EQUAL
18247: IFTRUE 18251
18249: GO 18266
18251: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18252: LD_EXP 57
18256: PPUSH
18257: LD_STRING DBack2-Pow-1
18259: PPUSH
18260: CALL_OW 88
18264: GO 18290
18266: LD_INT 3
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18289
18274: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18275: LD_EXP 57
18279: PPUSH
18280: LD_STRING DBack3-Pow-1
18282: PPUSH
18283: CALL_OW 88
18287: GO 18290
18289: POP
// sync ;
18290: SYNC
// repeat wait ( 0 0$1 ) ;
18291: LD_INT 35
18293: PPUSH
18294: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18298: LD_INT 14
18300: PPUSH
18301: LD_INT 22
18303: PUSH
18304: LD_INT 1
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: PPUSH
18311: CALL_OW 70
18315: PPUSH
18316: LD_INT 86
18318: PPUSH
18319: LD_INT 133
18321: PPUSH
18322: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18326: LD_INT 14
18328: PPUSH
18329: LD_INT 22
18331: PUSH
18332: LD_INT 1
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PPUSH
18339: CALL_OW 70
18343: NOT
18344: IFFALSE 18291
// if powellAnger >= 3 then
18346: LD_EXP 17
18350: PUSH
18351: LD_INT 3
18353: GREATEREQUAL
18354: IFFALSE 18363
// YouLost ( Dismissed ) ;
18356: LD_STRING Dismissed
18358: PPUSH
18359: CALL_OW 104
// Video ( false ) ;
18363: LD_INT 0
18365: PPUSH
18366: CALL 107204 0 1
// end ; until missionStage > 5 ;
18370: LD_EXP 15
18374: PUSH
18375: LD_INT 5
18377: GREATER
18378: IFFALSE 18105
// end ;
18380: PPOPN 1
18382: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18383: LD_EXP 13
18387: PUSH
18388: LD_INT 22
18390: PUSH
18391: LD_INT 4
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 21
18400: PUSH
18401: LD_INT 2
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 69
18416: PUSH
18417: LD_INT 4
18419: GREATEREQUAL
18420: AND
18421: PUSH
18422: LD_EXP 15
18426: PUSH
18427: LD_INT 2
18429: EQUAL
18430: AND
18431: IFFALSE 20254
18433: GO 18435
18435: DISABLE
18436: LD_INT 0
18438: PPUSH
18439: PPUSH
18440: PPUSH
18441: PPUSH
18442: PPUSH
18443: PPUSH
18444: PPUSH
18445: PPUSH
// begin missionStage := 3 ;
18446: LD_ADDR_EXP 15
18450: PUSH
18451: LD_INT 3
18453: ST_TO_ADDR
// retreat := false ;
18454: LD_ADDR_VAR 0 4
18458: PUSH
18459: LD_INT 0
18461: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18462: LD_ADDR_VAR 0 5
18466: PUSH
18467: LD_INT 22
18469: PUSH
18470: LD_INT 4
18472: PUSH
18473: EMPTY
18474: LIST
18475: LIST
18476: PUSH
18477: LD_INT 30
18479: PUSH
18480: LD_INT 4
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: EMPTY
18488: LIST
18489: LIST
18490: PPUSH
18491: CALL_OW 69
18495: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18496: LD_ADDR_VAR 0 6
18500: PUSH
18501: LD_INT 22
18503: PUSH
18504: LD_INT 4
18506: PUSH
18507: EMPTY
18508: LIST
18509: LIST
18510: PUSH
18511: LD_INT 30
18513: PUSH
18514: LD_INT 5
18516: PUSH
18517: EMPTY
18518: LIST
18519: LIST
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: PPUSH
18525: CALL_OW 69
18529: ST_TO_ADDR
// if not bar then
18530: LD_VAR 0 6
18534: NOT
18535: IFFALSE 18588
// begin repeat wait ( 0 0$1 ) ;
18537: LD_INT 35
18539: PPUSH
18540: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18544: LD_INT 22
18546: PUSH
18547: LD_INT 4
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: LD_INT 3
18556: PUSH
18557: LD_INT 57
18559: PUSH
18560: EMPTY
18561: LIST
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: PUSH
18567: LD_INT 30
18569: PUSH
18570: LD_INT 5
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PUSH
18577: EMPTY
18578: LIST
18579: LIST
18580: LIST
18581: PPUSH
18582: CALL_OW 69
18586: IFFALSE 18537
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18588: LD_ADDR_VAR 0 6
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 5
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18622: LD_INT 35
18624: PPUSH
18625: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18629: LD_EXP 120
18633: PUSH
18634: LD_INT 4
18636: ARRAY
18637: PUSH
18638: LD_INT 4
18640: GREATEREQUAL
18641: IFFALSE 18622
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18643: LD_ADDR_VAR 0 2
18647: PUSH
18648: LD_INT 22
18650: PUSH
18651: LD_INT 4
18653: PUSH
18654: EMPTY
18655: LIST
18656: LIST
18657: PUSH
18658: LD_INT 2
18660: PUSH
18661: LD_INT 25
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PUSH
18671: LD_INT 25
18673: PUSH
18674: LD_INT 2
18676: PUSH
18677: EMPTY
18678: LIST
18679: LIST
18680: PUSH
18681: LD_INT 25
18683: PUSH
18684: LD_INT 3
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 25
18693: PUSH
18694: LD_INT 4
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: LD_INT 25
18703: PUSH
18704: LD_INT 5
18706: PUSH
18707: EMPTY
18708: LIST
18709: LIST
18710: PUSH
18711: EMPTY
18712: LIST
18713: LIST
18714: LIST
18715: LIST
18716: LIST
18717: LIST
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL_OW 69
18727: PUSH
18728: LD_EXP 57
18732: PUSH
18733: LD_EXP 58
18737: ADD
18738: DIFF
18739: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18740: LD_ADDR_VAR 0 3
18744: PUSH
18745: LD_VAR 0 2
18749: PPUSH
18750: LD_INT 26
18752: PUSH
18753: LD_INT 1
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PPUSH
18760: CALL_OW 72
18764: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18765: LD_ADDR_VAR 0 2
18769: PUSH
18770: LD_VAR 0 2
18774: PUSH
18775: LD_VAR 0 3
18779: DIFF
18780: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18781: LD_ADDR_VAR 0 2
18785: PUSH
18786: LD_VAR 0 2
18790: PPUSH
18791: LD_INT 1
18793: PPUSH
18794: CALL 105857 0 2
18798: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18799: LD_ADDR_VAR 0 3
18803: PUSH
18804: LD_VAR 0 3
18808: PPUSH
18809: LD_INT 1
18811: PPUSH
18812: CALL 105857 0 2
18816: ST_TO_ADDR
// for i = 1 to 4 do
18817: LD_ADDR_VAR 0 1
18821: PUSH
18822: DOUBLE
18823: LD_INT 1
18825: DEC
18826: ST_TO_ADDR
18827: LD_INT 4
18829: PUSH
18830: FOR_TO
18831: IFFALSE 18997
// begin if tmp2 then
18833: LD_VAR 0 3
18837: IFFALSE 18918
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18839: LD_ADDR_EXP 18
18843: PUSH
18844: LD_EXP 18
18848: PPUSH
18849: LD_INT 1
18851: PPUSH
18852: LD_EXP 18
18856: PUSH
18857: LD_INT 1
18859: ARRAY
18860: PUSH
18861: LD_VAR 0 3
18865: PUSH
18866: LD_VAR 0 3
18870: ARRAY
18871: ADD
18872: PPUSH
18873: CALL_OW 1
18877: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18878: LD_VAR 0 3
18882: PUSH
18883: LD_VAR 0 3
18887: ARRAY
18888: PPUSH
18889: LD_INT 1
18891: PPUSH
18892: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18896: LD_ADDR_VAR 0 3
18900: PUSH
18901: LD_VAR 0 3
18905: PPUSH
18906: LD_VAR 0 3
18910: PPUSH
18911: CALL_OW 3
18915: ST_TO_ADDR
// end else
18916: GO 18995
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18918: LD_ADDR_EXP 18
18922: PUSH
18923: LD_EXP 18
18927: PPUSH
18928: LD_INT 1
18930: PPUSH
18931: LD_EXP 18
18935: PUSH
18936: LD_INT 1
18938: ARRAY
18939: PUSH
18940: LD_VAR 0 2
18944: PUSH
18945: LD_VAR 0 2
18949: ARRAY
18950: ADD
18951: PPUSH
18952: CALL_OW 1
18956: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18957: LD_VAR 0 2
18961: PUSH
18962: LD_VAR 0 2
18966: ARRAY
18967: PPUSH
18968: LD_INT 1
18970: PPUSH
18971: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18975: LD_ADDR_VAR 0 2
18979: PUSH
18980: LD_VAR 0 2
18984: PPUSH
18985: LD_VAR 0 2
18989: PPUSH
18990: CALL_OW 3
18994: ST_TO_ADDR
// end ; end ;
18995: GO 18830
18997: POP
18998: POP
// if tmp2 then
18999: LD_VAR 0 3
19003: IFFALSE 19021
// tmp := tmp union tmp2 ;
19005: LD_ADDR_VAR 0 2
19009: PUSH
19010: LD_VAR 0 2
19014: PUSH
19015: LD_VAR 0 3
19019: UNION
19020: ST_TO_ADDR
// for i = 1 to 4 do
19021: LD_ADDR_VAR 0 1
19025: PUSH
19026: DOUBLE
19027: LD_INT 1
19029: DEC
19030: ST_TO_ADDR
19031: LD_INT 4
19033: PUSH
19034: FOR_TO
19035: IFFALSE 19084
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19037: LD_ADDR_EXP 18
19041: PUSH
19042: LD_EXP 18
19046: PPUSH
19047: LD_INT 2
19049: PPUSH
19050: LD_EXP 18
19054: PUSH
19055: LD_INT 2
19057: ARRAY
19058: PUSH
19059: LD_VAR 0 2
19063: PUSH
19064: LD_VAR 0 2
19068: PUSH
19069: LD_VAR 0 1
19073: MINUS
19074: ARRAY
19075: ADD
19076: PPUSH
19077: CALL_OW 1
19081: ST_TO_ADDR
19082: GO 19034
19084: POP
19085: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19086: LD_ADDR_EXP 101
19090: PUSH
19091: LD_EXP 101
19095: PPUSH
19096: LD_INT 4
19098: PPUSH
19099: LD_EXP 101
19103: PUSH
19104: LD_INT 4
19106: ARRAY
19107: PUSH
19108: LD_EXP 18
19112: PUSH
19113: LD_INT 1
19115: ARRAY
19116: DIFF
19117: PPUSH
19118: CALL_OW 1
19122: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19123: LD_VAR 0 5
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PPUSH
19132: CALL_OW 313
19136: IFFALSE 19191
// begin for i in UnitsInside ( arm [ 1 ] ) do
19138: LD_ADDR_VAR 0 1
19142: PUSH
19143: LD_VAR 0 5
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: PPUSH
19152: CALL_OW 313
19156: PUSH
19157: FOR_IN
19158: IFFALSE 19189
// begin ComExitBuilding ( i ) ;
19160: LD_VAR 0 1
19164: PPUSH
19165: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19169: LD_VAR 0 1
19173: PPUSH
19174: LD_VAR 0 6
19178: PUSH
19179: LD_INT 1
19181: ARRAY
19182: PPUSH
19183: CALL_OW 180
// end ;
19187: GO 19157
19189: POP
19190: POP
// end ; wait ( 0 0$3 ) ;
19191: LD_INT 105
19193: PPUSH
19194: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19198: LD_ADDR_VAR 0 1
19202: PUSH
19203: LD_EXP 18
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: PUSH
19212: FOR_IN
19213: IFFALSE 19320
// begin if IsInUnit ( i ) then
19215: LD_VAR 0 1
19219: PPUSH
19220: CALL_OW 310
19224: IFFALSE 19235
// ComExitBuilding ( i ) ;
19226: LD_VAR 0 1
19230: PPUSH
19231: CALL_OW 122
// if GetClass ( i ) <> 1 then
19235: LD_VAR 0 1
19239: PPUSH
19240: CALL_OW 257
19244: PUSH
19245: LD_INT 1
19247: NONEQUAL
19248: IFFALSE 19289
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19250: LD_VAR 0 1
19254: PPUSH
19255: LD_VAR 0 5
19259: PUSH
19260: LD_INT 1
19262: ARRAY
19263: PPUSH
19264: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19268: LD_VAR 0 1
19272: PPUSH
19273: LD_INT 1
19275: PPUSH
19276: CALL_OW 183
// AddComExitBuilding ( i ) ;
19280: LD_VAR 0 1
19284: PPUSH
19285: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19289: LD_VAR 0 1
19293: PPUSH
19294: LD_INT 60
19296: PPUSH
19297: LD_INT 94
19299: PPUSH
19300: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19304: LD_VAR 0 1
19308: PPUSH
19309: LD_EXP 57
19313: PPUSH
19314: CALL_OW 179
// end ;
19318: GO 19212
19320: POP
19321: POP
// wait ( 0 0$15 ) ;
19322: LD_INT 525
19324: PPUSH
19325: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19329: LD_EXP 57
19333: PPUSH
19334: LD_STRING D4-Pow-1
19336: PPUSH
19337: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19341: LD_ADDR_VAR 0 2
19345: PUSH
19346: LD_EXP 18
19350: PUSH
19351: LD_INT 1
19353: ARRAY
19354: PPUSH
19355: LD_INT 26
19357: PUSH
19358: LD_INT 1
19360: PUSH
19361: EMPTY
19362: LIST
19363: LIST
19364: PPUSH
19365: CALL_OW 72
19369: ST_TO_ADDR
// if tmp then
19370: LD_VAR 0 2
19374: IFFALSE 19392
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19376: LD_VAR 0 2
19380: PUSH
19381: LD_INT 1
19383: ARRAY
19384: PPUSH
19385: LD_STRING D4-Sol1-1
19387: PPUSH
19388: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19392: LD_EXP 57
19396: PPUSH
19397: LD_STRING D4-Pow-2
19399: PPUSH
19400: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19404: LD_ADDR_VAR 0 1
19408: PUSH
19409: DOUBLE
19410: LD_INT 1
19412: DEC
19413: ST_TO_ADDR
19414: LD_EXP 18
19418: PUSH
19419: LD_INT 1
19421: ARRAY
19422: PUSH
19423: FOR_TO
19424: IFFALSE 19517
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19426: LD_EXP 18
19430: PUSH
19431: LD_INT 1
19433: ARRAY
19434: PUSH
19435: LD_VAR 0 1
19439: ARRAY
19440: PPUSH
19441: LD_EXP 120
19445: PUSH
19446: LD_INT 4
19448: ARRAY
19449: PUSH
19450: LD_INT 1
19452: ARRAY
19453: PPUSH
19454: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19458: LD_ADDR_EXP 120
19462: PUSH
19463: LD_EXP 120
19467: PPUSH
19468: LD_INT 4
19470: PPUSH
19471: LD_EXP 120
19475: PUSH
19476: LD_INT 4
19478: ARRAY
19479: PPUSH
19480: LD_INT 1
19482: PPUSH
19483: CALL_OW 3
19487: PPUSH
19488: CALL_OW 1
19492: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19493: LD_INT 8
19495: PPUSH
19496: LD_EXP 18
19500: PUSH
19501: LD_INT 1
19503: ARRAY
19504: PUSH
19505: LD_VAR 0 1
19509: ARRAY
19510: PPUSH
19511: CALL_OW 471
// end ;
19515: GO 19423
19517: POP
19518: POP
// repeat wait ( 0 0$1 ) ;
19519: LD_INT 35
19521: PPUSH
19522: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19526: LD_EXP 18
19530: PUSH
19531: LD_INT 1
19533: ARRAY
19534: PPUSH
19535: LD_INT 55
19537: PUSH
19538: EMPTY
19539: LIST
19540: PPUSH
19541: CALL_OW 72
19545: PUSH
19546: LD_INT 4
19548: GREATEREQUAL
19549: IFFALSE 19519
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19551: LD_EXP 18
19555: PUSH
19556: LD_INT 1
19558: ARRAY
19559: PPUSH
19560: LD_INT 69
19562: PPUSH
19563: LD_INT 94
19565: PPUSH
19566: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19570: LD_EXP 18
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: LD_INT 82
19581: PPUSH
19582: LD_INT 83
19584: PPUSH
19585: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19589: LD_EXP 18
19593: PUSH
19594: LD_INT 1
19596: ARRAY
19597: PPUSH
19598: LD_INT 77
19600: PPUSH
19601: LD_INT 69
19603: PPUSH
19604: CALL_OW 174
// repeat wait ( 3 ) ;
19608: LD_INT 3
19610: PPUSH
19611: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19615: LD_ADDR_VAR 0 1
19619: PUSH
19620: LD_EXP 18
19624: PUSH
19625: LD_INT 1
19627: ARRAY
19628: PUSH
19629: FOR_IN
19630: IFFALSE 19766
// begin if GetLives ( i ) < 990 then
19632: LD_VAR 0 1
19636: PPUSH
19637: CALL_OW 256
19641: PUSH
19642: LD_INT 990
19644: LESS
19645: IFFALSE 19659
// SetLives ( i , 1000 ) ;
19647: LD_VAR 0 1
19651: PPUSH
19652: LD_INT 1000
19654: PPUSH
19655: CALL_OW 234
// if not IsInUnit ( i ) then
19659: LD_VAR 0 1
19663: PPUSH
19664: CALL_OW 310
19668: NOT
19669: IFFALSE 19764
// begin if not HasTask ( i ) then
19671: LD_VAR 0 1
19675: PPUSH
19676: CALL_OW 314
19680: NOT
19681: IFFALSE 19698
// ComMoveXY ( i , 64 , 93 ) ;
19683: LD_VAR 0 1
19687: PPUSH
19688: LD_INT 64
19690: PPUSH
19691: LD_INT 93
19693: PPUSH
19694: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19698: LD_VAR 0 4
19702: NOT
19703: PUSH
19704: LD_VAR 0 1
19708: PPUSH
19709: CALL_OW 258
19713: PUSH
19714: LD_INT 1
19716: EQUAL
19717: AND
19718: IFFALSE 19764
// begin retreat := true ;
19720: LD_ADDR_VAR 0 4
19724: PUSH
19725: LD_INT 1
19727: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19728: LD_VAR 0 1
19732: PPUSH
19733: LD_INT 2
19735: PPUSH
19736: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19740: LD_VAR 0 1
19744: PPUSH
19745: LD_STRING D4a-Sol1-1
19747: PPUSH
19748: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19752: LD_EXP 57
19756: PPUSH
19757: LD_STRING D4a-Pow-1
19759: PPUSH
19760: CALL_OW 88
// end ; end ; end ;
19764: GO 19629
19766: POP
19767: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19768: LD_EXP 18
19772: PUSH
19773: LD_INT 1
19775: ARRAY
19776: PPUSH
19777: LD_INT 95
19779: PUSH
19780: LD_INT 9
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: PUSH
19787: LD_INT 3
19789: PUSH
19790: LD_INT 55
19792: PUSH
19793: EMPTY
19794: LIST
19795: PUSH
19796: EMPTY
19797: LIST
19798: LIST
19799: PUSH
19800: EMPTY
19801: LIST
19802: LIST
19803: PPUSH
19804: CALL_OW 72
19808: PUSH
19809: LD_INT 4
19811: GREATEREQUAL
19812: IFFALSE 19608
// for i in powellSquadAttack [ 1 ] do
19814: LD_ADDR_VAR 0 1
19818: PUSH
19819: LD_EXP 18
19823: PUSH
19824: LD_INT 1
19826: ARRAY
19827: PUSH
19828: FOR_IN
19829: IFFALSE 19965
// begin if GetTag ( i ) = 2 then
19831: LD_VAR 0 1
19835: PPUSH
19836: CALL_OW 110
19840: PUSH
19841: LD_INT 2
19843: EQUAL
19844: IFFALSE 19906
// begin ComMoveXY ( i , 60 , 94 ) ;
19846: LD_VAR 0 1
19850: PPUSH
19851: LD_INT 60
19853: PPUSH
19854: LD_INT 94
19856: PPUSH
19857: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19861: LD_VAR 0 1
19865: PPUSH
19866: LD_EXP 57
19870: PPUSH
19871: CALL_OW 179
// wait ( 0 0$3 ) ;
19875: LD_INT 105
19877: PPUSH
19878: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_STRING D4a-Sol1-2
19889: PPUSH
19890: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19894: LD_EXP 57
19898: PPUSH
19899: LD_STRING D4a-Pow-2
19901: PPUSH
19902: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19906: LD_VAR 0 1
19910: PPUSH
19911: LD_INT 0
19913: PPUSH
19914: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19918: LD_ADDR_EXP 101
19922: PUSH
19923: LD_EXP 101
19927: PPUSH
19928: LD_INT 4
19930: PPUSH
19931: LD_EXP 101
19935: PUSH
19936: LD_INT 4
19938: ARRAY
19939: PUSH
19940: LD_VAR 0 1
19944: UNION
19945: PPUSH
19946: CALL_OW 1
19950: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19951: LD_INT 8
19953: PPUSH
19954: LD_VAR 0 1
19958: PPUSH
19959: CALL_OW 472
// end ;
19963: GO 19828
19965: POP
19966: POP
// wait ( 4 4$00 ) ;
19967: LD_INT 8400
19969: PPUSH
19970: CALL_OW 67
// uc_side := 6 ;
19974: LD_ADDR_OWVAR 20
19978: PUSH
19979: LD_INT 6
19981: ST_TO_ADDR
// uc_nation := 3 ;
19982: LD_ADDR_OWVAR 21
19986: PUSH
19987: LD_INT 3
19989: ST_TO_ADDR
// ru := [ ] ;
19990: LD_ADDR_VAR 0 7
19994: PUSH
19995: EMPTY
19996: ST_TO_ADDR
// for i = 1 to 4 do
19997: LD_ADDR_VAR 0 1
20001: PUSH
20002: DOUBLE
20003: LD_INT 1
20005: DEC
20006: ST_TO_ADDR
20007: LD_INT 4
20009: PUSH
20010: FOR_TO
20011: IFFALSE 20112
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20013: LD_INT 22
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: LD_INT 3
20021: PPUSH
20022: LD_INT 43
20024: PUSH
20025: LD_INT 44
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 1
20034: PPUSH
20035: LD_INT 2
20037: PPUSH
20038: CALL_OW 12
20042: ARRAY
20043: PPUSH
20044: LD_INT 89
20046: PPUSH
20047: CALL 71487 0 5
// un := CreateVehicle ;
20051: LD_ADDR_VAR 0 8
20055: PUSH
20056: CALL_OW 45
20060: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20061: LD_VAR 0 8
20065: PPUSH
20066: LD_INT 4
20068: PPUSH
20069: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20073: LD_VAR 0 8
20077: PPUSH
20078: LD_INT 136
20080: PPUSH
20081: LD_INT 90
20083: PPUSH
20084: LD_INT 8
20086: PPUSH
20087: LD_INT 0
20089: PPUSH
20090: CALL_OW 50
// ru := ru ^ un ;
20094: LD_ADDR_VAR 0 7
20098: PUSH
20099: LD_VAR 0 7
20103: PUSH
20104: LD_VAR 0 8
20108: ADD
20109: ST_TO_ADDR
// end ;
20110: GO 20010
20112: POP
20113: POP
// if ru then
20114: LD_VAR 0 7
20118: IFFALSE 20135
// ComAgressiveMove ( ru , 80 , 92 ) ;
20120: LD_VAR 0 7
20124: PPUSH
20125: LD_INT 80
20127: PPUSH
20128: LD_INT 92
20130: PPUSH
20131: CALL_OW 114
// wait ( 8 8$00 ) ;
20135: LD_INT 16800
20137: PPUSH
20138: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20142: LD_INT 4
20144: PPUSH
20145: LD_INT 3
20147: PUSH
20148: LD_INT 1
20150: PUSH
20151: LD_INT 1
20153: PUSH
20154: LD_INT 5
20156: PUSH
20157: EMPTY
20158: LIST
20159: LIST
20160: LIST
20161: LIST
20162: PUSH
20163: LD_INT 4
20165: PUSH
20166: LD_INT 1
20168: PUSH
20169: LD_INT 1
20171: PUSH
20172: LD_INT 6
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 4
20183: PUSH
20184: LD_INT 1
20186: PUSH
20187: LD_INT 1
20189: PUSH
20190: LD_INT 7
20192: PUSH
20193: EMPTY
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: PUSH
20199: LD_INT 3
20201: PUSH
20202: LD_INT 1
20204: PUSH
20205: LD_INT 1
20207: PUSH
20208: LD_INT 7
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: PUSH
20217: LD_INT 3
20219: PUSH
20220: LD_INT 1
20222: PUSH
20223: LD_INT 1
20225: PUSH
20226: LD_INT 5
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: LIST
20233: LIST
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: LIST
20239: LIST
20240: LIST
20241: PPUSH
20242: CALL 57980 0 2
// missionStage := 4 ;
20246: LD_ADDR_EXP 15
20250: PUSH
20251: LD_INT 4
20253: ST_TO_ADDR
// end ;
20254: PPOPN 8
20256: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20257: LD_EXP 15
20261: PUSH
20262: LD_INT 4
20264: EQUAL
20265: PUSH
20266: LD_INT 22
20268: PUSH
20269: LD_INT 4
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: PUSH
20276: LD_INT 21
20278: PUSH
20279: LD_INT 2
20281: PUSH
20282: EMPTY
20283: LIST
20284: LIST
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PPUSH
20290: CALL_OW 69
20294: PUSH
20295: LD_INT 5
20297: GREATEREQUAL
20298: AND
20299: IFFALSE 24404
20301: GO 20303
20303: DISABLE
20304: LD_INT 0
20306: PPUSH
20307: PPUSH
20308: PPUSH
20309: PPUSH
20310: PPUSH
20311: PPUSH
20312: PPUSH
20313: PPUSH
20314: PPUSH
20315: PPUSH
20316: PPUSH
20317: PPUSH
20318: PPUSH
// begin missionStage := 5 ;
20319: LD_ADDR_EXP 15
20323: PUSH
20324: LD_INT 5
20326: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20327: LD_ADDR_VAR 0 10
20331: PUSH
20332: LD_INT 22
20334: PUSH
20335: LD_INT 4
20337: PUSH
20338: EMPTY
20339: LIST
20340: LIST
20341: PUSH
20342: LD_INT 2
20344: PUSH
20345: LD_INT 30
20347: PUSH
20348: LD_INT 4
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: PUSH
20355: LD_INT 30
20357: PUSH
20358: LD_INT 5
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: LIST
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: PPUSH
20374: CALL_OW 69
20378: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20379: LD_ADDR_VAR 0 6
20383: PUSH
20384: LD_INT 22
20386: PUSH
20387: LD_INT 4
20389: PUSH
20390: EMPTY
20391: LIST
20392: LIST
20393: PUSH
20394: LD_INT 21
20396: PUSH
20397: LD_INT 1
20399: PUSH
20400: EMPTY
20401: LIST
20402: LIST
20403: PUSH
20404: LD_INT 3
20406: PUSH
20407: LD_INT 25
20409: PUSH
20410: LD_INT 16
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: PUSH
20421: LD_INT 3
20423: PUSH
20424: LD_INT 25
20426: PUSH
20427: LD_INT 12
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: LIST
20443: PPUSH
20444: CALL_OW 69
20448: PUSH
20449: LD_EXP 57
20453: DIFF
20454: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20455: LD_ADDR_VAR 0 9
20459: PUSH
20460: LD_INT 22
20462: PUSH
20463: LD_INT 4
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: LD_INT 3
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PPUSH
20484: CALL_OW 69
20488: PUSH
20489: LD_INT 1
20491: ARRAY
20492: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20493: LD_INT 35
20495: PPUSH
20496: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20500: LD_EXP 120
20504: PUSH
20505: LD_INT 4
20507: ARRAY
20508: PUSH
20509: LD_INT 5
20511: GREATEREQUAL
20512: PUSH
20513: LD_EXP 120
20517: PUSH
20518: LD_INT 4
20520: ARRAY
20521: PPUSH
20522: LD_INT 58
20524: PUSH
20525: EMPTY
20526: LIST
20527: PPUSH
20528: CALL_OW 72
20532: PUSH
20533: LD_INT 5
20535: GREATEREQUAL
20536: AND
20537: IFFALSE 20493
// powellAllowRetreat := false ;
20539: LD_ADDR_EXP 19
20543: PUSH
20544: LD_INT 0
20546: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20547: LD_INT 700
20549: PPUSH
20550: CALL_OW 67
// activeAttacks := false ;
20554: LD_ADDR_EXP 16
20558: PUSH
20559: LD_INT 0
20561: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20562: LD_INT 35
20564: PPUSH
20565: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20569: LD_INT 22
20571: PUSH
20572: LD_INT 6
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: PPUSH
20579: CALL_OW 69
20583: PUSH
20584: LD_INT 0
20586: EQUAL
20587: IFFALSE 20562
// tmp := mc_vehicles [ 4 ] ;
20589: LD_ADDR_VAR 0 3
20593: PUSH
20594: LD_EXP 120
20598: PUSH
20599: LD_INT 4
20601: ARRAY
20602: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20603: LD_ADDR_VAR 0 1
20607: PUSH
20608: DOUBLE
20609: LD_INT 1
20611: DEC
20612: ST_TO_ADDR
20613: LD_EXP 18
20617: PUSH
20618: FOR_TO
20619: IFFALSE 20880
// begin for j in powellSquadAttack [ i ] do
20621: LD_ADDR_VAR 0 2
20625: PUSH
20626: LD_EXP 18
20630: PUSH
20631: LD_VAR 0 1
20635: ARRAY
20636: PUSH
20637: FOR_IN
20638: IFFALSE 20876
// begin forces := forces diff j ;
20640: LD_ADDR_VAR 0 6
20644: PUSH
20645: LD_VAR 0 6
20649: PUSH
20650: LD_VAR 0 2
20654: DIFF
20655: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20656: LD_VAR 0 2
20660: PPUSH
20661: LD_INT 1
20663: PPUSH
20664: CALL_OW 109
// wait ( 0 0$2 ) ;
20668: LD_INT 70
20670: PPUSH
20671: CALL_OW 67
// if IsInUnit ( j ) then
20675: LD_VAR 0 2
20679: PPUSH
20680: CALL_OW 310
20684: IFFALSE 20695
// ComExitBuilding ( j ) ;
20686: LD_VAR 0 2
20690: PPUSH
20691: CALL_OW 122
// if GetClass ( j ) <> 1 then
20695: LD_VAR 0 2
20699: PPUSH
20700: CALL_OW 257
20704: PUSH
20705: LD_INT 1
20707: NONEQUAL
20708: IFFALSE 20788
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20710: LD_VAR 0 10
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PPUSH
20719: CALL_OW 313
20723: PUSH
20724: LD_INT 5
20726: GREATEREQUAL
20727: IFFALSE 20749
// AddComEnterUnit ( j , arm [ 2 ] ) else
20729: LD_VAR 0 2
20733: PPUSH
20734: LD_VAR 0 10
20738: PUSH
20739: LD_INT 2
20741: ARRAY
20742: PPUSH
20743: CALL_OW 180
20747: GO 20767
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20749: LD_VAR 0 2
20753: PPUSH
20754: LD_VAR 0 10
20758: PUSH
20759: LD_INT 1
20761: ARRAY
20762: PPUSH
20763: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20767: LD_VAR 0 2
20771: PPUSH
20772: LD_INT 1
20774: PPUSH
20775: CALL_OW 183
// AddComExitBuilding ( j ) ;
20779: LD_VAR 0 2
20783: PPUSH
20784: CALL_OW 182
// end ; if i = 2 then
20788: LD_VAR 0 1
20792: PUSH
20793: LD_INT 2
20795: EQUAL
20796: IFFALSE 20813
// AddComMoveXY ( j , 61 , 93 ) ;
20798: LD_VAR 0 2
20802: PPUSH
20803: LD_INT 61
20805: PPUSH
20806: LD_INT 93
20808: PPUSH
20809: CALL_OW 171
// if i = 1 then
20813: LD_VAR 0 1
20817: PUSH
20818: LD_INT 1
20820: EQUAL
20821: IFFALSE 20874
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20823: LD_VAR 0 2
20827: PPUSH
20828: LD_VAR 0 3
20832: PUSH
20833: LD_INT 1
20835: ARRAY
20836: PPUSH
20837: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20841: LD_ADDR_VAR 0 3
20845: PUSH
20846: LD_VAR 0 3
20850: PPUSH
20851: LD_INT 1
20853: PPUSH
20854: CALL_OW 3
20858: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20859: LD_VAR 0 2
20863: PPUSH
20864: LD_INT 69
20866: PPUSH
20867: LD_INT 94
20869: PPUSH
20870: CALL_OW 171
// end ; end ;
20874: GO 20637
20876: POP
20877: POP
// end ;
20878: GO 20618
20880: POP
20881: POP
// wait ( 0 0$55 ) ;
20882: LD_INT 1925
20884: PPUSH
20885: CALL_OW 67
// MC_Kill ( 4 ) ;
20889: LD_INT 4
20891: PPUSH
20892: CALL 34464 0 1
// tmp := UnitsInside ( fac ) ;
20896: LD_ADDR_VAR 0 3
20900: PUSH
20901: LD_VAR 0 9
20905: PPUSH
20906: CALL_OW 313
20910: ST_TO_ADDR
// if tmp then
20911: LD_VAR 0 3
20915: IFFALSE 21036
// for i in tmp do
20917: LD_ADDR_VAR 0 1
20921: PUSH
20922: LD_VAR 0 3
20926: PUSH
20927: FOR_IN
20928: IFFALSE 21034
// begin ComExitBuilding ( i ) ;
20930: LD_VAR 0 1
20934: PPUSH
20935: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20939: LD_VAR 0 10
20943: PUSH
20944: LD_INT 2
20946: ARRAY
20947: PPUSH
20948: CALL_OW 313
20952: PUSH
20953: LD_INT 6
20955: LESS
20956: IFFALSE 20978
// AddComEnterUnit ( i , arm [ 2 ] ) else
20958: LD_VAR 0 1
20962: PPUSH
20963: LD_VAR 0 10
20967: PUSH
20968: LD_INT 2
20970: ARRAY
20971: PPUSH
20972: CALL_OW 180
20976: GO 21032
// if UnitsInside ( arm [ 1 ] ) < 6 then
20978: LD_VAR 0 10
20982: PUSH
20983: LD_INT 1
20985: ARRAY
20986: PPUSH
20987: CALL_OW 313
20991: PUSH
20992: LD_INT 6
20994: LESS
20995: IFFALSE 21017
// AddComEnterUnit ( i , arm [ 1 ] ) else
20997: LD_VAR 0 1
21001: PPUSH
21002: LD_VAR 0 10
21006: PUSH
21007: LD_INT 1
21009: ARRAY
21010: PPUSH
21011: CALL_OW 180
21015: GO 21032
// AddComMoveXY ( i , 37 , 68 ) ;
21017: LD_VAR 0 1
21021: PPUSH
21022: LD_INT 37
21024: PPUSH
21025: LD_INT 68
21027: PPUSH
21028: CALL_OW 171
// end ;
21032: GO 20927
21034: POP
21035: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21036: LD_ADDR_VAR 0 11
21040: PUSH
21041: LD_VAR 0 6
21045: PPUSH
21046: LD_INT 26
21048: PUSH
21049: LD_INT 1
21051: PUSH
21052: EMPTY
21053: LIST
21054: LIST
21055: PPUSH
21056: CALL_OW 72
21060: PUSH
21061: LD_EXP 58
21065: DIFF
21066: ST_TO_ADDR
// if not speaker then
21067: LD_VAR 0 11
21071: NOT
21072: IFFALSE 21099
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21074: LD_ADDR_VAR 0 11
21078: PUSH
21079: LD_VAR 0 6
21083: PPUSH
21084: LD_INT 26
21086: PUSH
21087: LD_INT 1
21089: PUSH
21090: EMPTY
21091: LIST
21092: LIST
21093: PPUSH
21094: CALL_OW 72
21098: ST_TO_ADDR
// if speaker then
21099: LD_VAR 0 11
21103: IFFALSE 21119
// speaker := speaker [ 1 ] ;
21105: LD_ADDR_VAR 0 11
21109: PUSH
21110: LD_VAR 0 11
21114: PUSH
21115: LD_INT 1
21117: ARRAY
21118: ST_TO_ADDR
// Video ( true ) ;
21119: LD_INT 1
21121: PPUSH
21122: CALL 107204 0 1
// CenterNowOnUnits ( Powell ) ;
21126: LD_EXP 57
21130: PPUSH
21131: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21135: LD_ADDR_VAR 0 3
21139: PUSH
21140: LD_VAR 0 6
21144: PPUSH
21145: LD_INT 3
21147: PUSH
21148: LD_INT 25
21150: PUSH
21151: LD_INT 1
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PPUSH
21162: CALL_OW 72
21166: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21167: LD_ADDR_VAR 0 12
21171: PUSH
21172: LD_INT 22
21174: PUSH
21175: LD_INT 4
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PUSH
21182: LD_INT 30
21184: PUSH
21185: LD_INT 32
21187: PUSH
21188: EMPTY
21189: LIST
21190: LIST
21191: PUSH
21192: LD_INT 58
21194: PUSH
21195: EMPTY
21196: LIST
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: LIST
21202: PPUSH
21203: CALL_OW 69
21207: ST_TO_ADDR
// for i = 1 to 6 do
21208: LD_ADDR_VAR 0 1
21212: PUSH
21213: DOUBLE
21214: LD_INT 1
21216: DEC
21217: ST_TO_ADDR
21218: LD_INT 6
21220: PUSH
21221: FOR_TO
21222: IFFALSE 21363
// begin if IsInUnit ( tmp [ i ] ) then
21224: LD_VAR 0 3
21228: PUSH
21229: LD_VAR 0 1
21233: ARRAY
21234: PPUSH
21235: CALL_OW 310
21239: IFFALSE 21256
// ComExitBuilding ( tmp [ i ] ) ;
21241: LD_VAR 0 3
21245: PUSH
21246: LD_VAR 0 1
21250: ARRAY
21251: PPUSH
21252: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21256: LD_VAR 0 3
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PPUSH
21267: LD_VAR 0 10
21271: PUSH
21272: LD_INT 1
21274: ARRAY
21275: PPUSH
21276: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21280: LD_VAR 0 3
21284: PUSH
21285: LD_VAR 0 1
21289: ARRAY
21290: PPUSH
21291: LD_INT 1
21293: PPUSH
21294: CALL_OW 183
// if emp_towers then
21298: LD_VAR 0 12
21302: IFFALSE 21361
// begin AddComExitBuilding ( tmp [ i ] ) ;
21304: LD_VAR 0 3
21308: PUSH
21309: LD_VAR 0 1
21313: ARRAY
21314: PPUSH
21315: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21319: LD_VAR 0 3
21323: PUSH
21324: LD_VAR 0 1
21328: ARRAY
21329: PPUSH
21330: LD_VAR 0 12
21334: PUSH
21335: LD_INT 1
21337: ARRAY
21338: PPUSH
21339: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21343: LD_ADDR_VAR 0 12
21347: PUSH
21348: LD_VAR 0 12
21352: PPUSH
21353: LD_INT 1
21355: PPUSH
21356: CALL_OW 3
21360: ST_TO_ADDR
// end ; end ;
21361: GO 21221
21363: POP
21364: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21365: LD_ADDR_VAR 0 3
21369: PUSH
21370: LD_EXP 18
21374: PUSH
21375: LD_INT 1
21377: ARRAY
21378: PUSH
21379: LD_EXP 18
21383: PUSH
21384: LD_INT 2
21386: ARRAY
21387: ADD
21388: PPUSH
21389: LD_INT 26
21391: PUSH
21392: LD_INT 1
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PPUSH
21399: CALL_OW 72
21403: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21404: LD_ADDR_VAR 0 1
21408: PUSH
21409: LD_EXP 18
21413: PUSH
21414: LD_INT 2
21416: ARRAY
21417: PUSH
21418: FOR_IN
21419: IFFALSE 21437
// ComTurnUnit ( i , Powell ) ;
21421: LD_VAR 0 1
21425: PPUSH
21426: LD_EXP 57
21430: PPUSH
21431: CALL_OW 119
21435: GO 21418
21437: POP
21438: POP
// Say ( Powell , D5-Pow-1 ) ;
21439: LD_EXP 57
21443: PPUSH
21444: LD_STRING D5-Pow-1
21446: PPUSH
21447: CALL_OW 88
// if tmp then
21451: LD_VAR 0 3
21455: IFFALSE 21473
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21457: LD_VAR 0 3
21461: PUSH
21462: LD_INT 1
21464: ARRAY
21465: PPUSH
21466: LD_STRING D5-Sol2-1
21468: PPUSH
21469: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21473: LD_EXP 57
21477: PPUSH
21478: LD_STRING D5-Pow-2
21480: PPUSH
21481: CALL_OW 88
// if tmp > 1 then
21485: LD_VAR 0 3
21489: PUSH
21490: LD_INT 1
21492: GREATER
21493: IFFALSE 21511
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21495: LD_VAR 0 3
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PPUSH
21504: LD_STRING D5-Sol2-2
21506: PPUSH
21507: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21511: LD_EXP 57
21515: PPUSH
21516: LD_STRING D5-Pow-3
21518: PPUSH
21519: CALL_OW 88
// wait ( 0 0$1 ) ;
21523: LD_INT 35
21525: PPUSH
21526: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21530: LD_ADDR_VAR 0 3
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 1
21542: ARRAY
21543: PUSH
21544: LD_EXP 18
21548: PUSH
21549: LD_INT 2
21551: ARRAY
21552: UNION
21553: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21554: LD_VAR 0 3
21558: PPUSH
21559: LD_INT 80
21561: PPUSH
21562: LD_INT 67
21564: PPUSH
21565: CALL_OW 114
// wait ( 0 0$2 ) ;
21569: LD_INT 70
21571: PPUSH
21572: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21576: LD_INT 79
21578: PPUSH
21579: LD_INT 72
21581: PPUSH
21582: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21586: LD_INT 35
21588: PPUSH
21589: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21593: LD_VAR 0 3
21597: PPUSH
21598: LD_INT 3
21600: PUSH
21601: LD_INT 24
21603: PUSH
21604: LD_INT 1000
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PUSH
21611: EMPTY
21612: LIST
21613: LIST
21614: PPUSH
21615: CALL_OW 72
21619: IFFALSE 21586
// Say ( Powell , D5a-Pow-1 ) ;
21621: LD_EXP 57
21625: PPUSH
21626: LD_STRING D5a-Pow-1
21628: PPUSH
21629: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21633: LD_EXP 57
21637: PPUSH
21638: LD_STRING D5a-Pow-1a
21640: PPUSH
21641: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21645: LD_INT 10
21647: PPUSH
21648: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21652: LD_EXP 57
21656: PPUSH
21657: LD_STRING D5a-Pow-1b
21659: PPUSH
21660: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21664: LD_EXP 57
21668: PPUSH
21669: LD_STRING D5a-Pow-1c
21671: PPUSH
21672: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21676: LD_EXP 57
21680: PPUSH
21681: LD_STRING D5a-Pow-1d
21683: PPUSH
21684: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21688: LD_INT 35
21690: PPUSH
21691: CALL_OW 67
// if not HasTask ( tmp ) then
21695: LD_VAR 0 3
21699: PPUSH
21700: CALL_OW 314
21704: NOT
21705: IFFALSE 21722
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21707: LD_VAR 0 3
21711: PPUSH
21712: LD_INT 80
21714: PPUSH
21715: LD_INT 67
21717: PPUSH
21718: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21722: LD_VAR 0 3
21726: PPUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PPUSH
21737: CALL_OW 72
21741: NOT
21742: IFFALSE 21688
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21744: LD_ADDR_VAR 0 3
21748: PUSH
21749: LD_INT 22
21751: PUSH
21752: LD_INT 4
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 92
21761: PUSH
21762: LD_INT 60
21764: PUSH
21765: LD_INT 93
21767: PUSH
21768: LD_INT 10
21770: PUSH
21771: EMPTY
21772: LIST
21773: LIST
21774: LIST
21775: LIST
21776: PUSH
21777: LD_INT 3
21779: PUSH
21780: LD_INT 54
21782: PUSH
21783: EMPTY
21784: LIST
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: LIST
21794: PPUSH
21795: CALL_OW 69
21799: PUSH
21800: LD_EXP 57
21804: DIFF
21805: ST_TO_ADDR
// if tmp then
21806: LD_VAR 0 3
21810: IFFALSE 21844
// for i in tmp do
21812: LD_ADDR_VAR 0 1
21816: PUSH
21817: LD_VAR 0 3
21821: PUSH
21822: FOR_IN
21823: IFFALSE 21842
// ComMoveXY ( i , 36 , 67 ) ;
21825: LD_VAR 0 1
21829: PPUSH
21830: LD_INT 36
21832: PPUSH
21833: LD_INT 67
21835: PPUSH
21836: CALL_OW 111
21840: GO 21822
21842: POP
21843: POP
// wait ( 0 0$3 ) ;
21844: LD_INT 105
21846: PPUSH
21847: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21851: LD_VAR 0 11
21855: PPUSH
21856: LD_STRING D6-Sol3-1
21858: PPUSH
21859: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21863: LD_EXP 57
21867: PPUSH
21868: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21872: LD_EXP 57
21876: PPUSH
21877: LD_STRING D6-Pow-1
21879: PPUSH
21880: CALL_OW 88
// tmp := [ ] ;
21884: LD_ADDR_VAR 0 3
21888: PUSH
21889: EMPTY
21890: ST_TO_ADDR
// for i = 1 to 2 do
21891: LD_ADDR_VAR 0 1
21895: PUSH
21896: DOUBLE
21897: LD_INT 1
21899: DEC
21900: ST_TO_ADDR
21901: LD_INT 2
21903: PUSH
21904: FOR_TO
21905: IFFALSE 22019
// begin uc_side := 8 ;
21907: LD_ADDR_OWVAR 20
21911: PUSH
21912: LD_INT 8
21914: ST_TO_ADDR
// uc_nation := 2 ;
21915: LD_ADDR_OWVAR 21
21919: PUSH
21920: LD_INT 2
21922: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21923: LD_INT 14
21925: PPUSH
21926: LD_INT 3
21928: PPUSH
21929: LD_INT 2
21931: PPUSH
21932: LD_INT 29
21934: PPUSH
21935: LD_INT 100
21937: PPUSH
21938: CALL 71487 0 5
// veh := CreateVehicle ;
21942: LD_ADDR_VAR 0 13
21946: PUSH
21947: CALL_OW 45
21951: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21952: LD_VAR 0 13
21956: PPUSH
21957: LD_INT 4
21959: PPUSH
21960: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21964: LD_VAR 0 13
21968: PPUSH
21969: LD_INT 99
21971: PPUSH
21972: LD_INT 83
21974: PPUSH
21975: LD_INT 6
21977: PPUSH
21978: LD_INT 0
21980: PPUSH
21981: CALL_OW 50
// wait ( 3 ) ;
21985: LD_INT 3
21987: PPUSH
21988: CALL_OW 67
// Connect ( veh ) ;
21992: LD_VAR 0 13
21996: PPUSH
21997: CALL 74542 0 1
// tmp := tmp ^ veh ;
22001: LD_ADDR_VAR 0 3
22005: PUSH
22006: LD_VAR 0 3
22010: PUSH
22011: LD_VAR 0 13
22015: ADD
22016: ST_TO_ADDR
// end ;
22017: GO 21904
22019: POP
22020: POP
// wait ( 0 0$1 ) ;
22021: LD_INT 35
22023: PPUSH
22024: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22028: LD_INT 99
22030: PPUSH
22031: LD_INT 83
22033: PPUSH
22034: LD_INT 1
22036: PPUSH
22037: LD_INT 10
22039: PPUSH
22040: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22044: LD_INT 99
22046: PPUSH
22047: LD_INT 83
22049: PPUSH
22050: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22054: LD_VAR 0 11
22058: PPUSH
22059: LD_STRING D6-Sol3-2
22061: PPUSH
22062: CALL_OW 88
// async ;
22066: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22067: LD_EXP 57
22071: PPUSH
22072: LD_STRING D6-Pow-2
22074: PPUSH
22075: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22079: LD_VAR 0 3
22083: PUSH
22084: LD_INT 1
22086: ARRAY
22087: PPUSH
22088: LD_VAR 0 9
22092: PPUSH
22093: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22097: LD_VAR 0 3
22101: PUSH
22102: LD_INT 2
22104: ARRAY
22105: PPUSH
22106: LD_INT 22
22108: PUSH
22109: LD_INT 4
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: PUSH
22116: LD_INT 21
22118: PUSH
22119: LD_INT 3
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PPUSH
22130: CALL_OW 69
22134: PPUSH
22135: LD_VAR 0 3
22139: PUSH
22140: LD_INT 2
22142: ARRAY
22143: PPUSH
22144: CALL_OW 74
22148: PPUSH
22149: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22153: LD_EXP 57
22157: PPUSH
22158: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22162: LD_INT 99
22164: PPUSH
22165: LD_INT 83
22167: PPUSH
22168: LD_INT 1
22170: PPUSH
22171: CALL_OW 331
// repeat wait ( 4 ) ;
22175: LD_INT 4
22177: PPUSH
22178: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22182: LD_VAR 0 3
22186: PUSH
22187: LD_INT 1
22189: ARRAY
22190: PPUSH
22191: CALL_OW 256
22195: PUSH
22196: LD_INT 1000
22198: LESS
22199: IFFALSE 22217
// SetLives ( tmp [ 1 ] , 1000 ) ;
22201: LD_VAR 0 3
22205: PUSH
22206: LD_INT 1
22208: ARRAY
22209: PPUSH
22210: LD_INT 1000
22212: PPUSH
22213: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22217: LD_INT 22
22219: PUSH
22220: LD_INT 4
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: LD_INT 30
22229: PUSH
22230: LD_INT 3
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: PPUSH
22241: CALL_OW 69
22245: PUSH
22246: LD_INT 0
22248: EQUAL
22249: IFFALSE 22175
// sync ;
22251: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22252: LD_EXP 57
22256: PPUSH
22257: LD_STRING D6a-Pow-1
22259: PPUSH
22260: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22264: LD_VAR 0 11
22268: PPUSH
22269: LD_STRING D6a-Sol3-1
22271: PPUSH
22272: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22276: LD_EXP 57
22280: PPUSH
22281: LD_STRING D6a-Pow-2
22283: PPUSH
22284: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22288: LD_VAR 0 11
22292: PPUSH
22293: LD_STRING D6a-Sol3-2
22295: PPUSH
22296: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22300: LD_EXP 57
22304: PPUSH
22305: LD_STRING D6a-Pow-3
22307: PPUSH
22308: CALL_OW 88
// powellCenterCameraMode := true ;
22312: LD_ADDR_EXP 20
22316: PUSH
22317: LD_INT 1
22319: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22320: LD_ADDR_VAR 0 1
22324: PUSH
22325: LD_INT 22
22327: PUSH
22328: LD_INT 8
22330: PUSH
22331: EMPTY
22332: LIST
22333: LIST
22334: PUSH
22335: LD_INT 25
22337: PUSH
22338: LD_INT 2
22340: PUSH
22341: EMPTY
22342: LIST
22343: LIST
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: PPUSH
22349: CALL_OW 69
22353: PUSH
22354: FOR_IN
22355: IFFALSE 22410
// begin SetTag ( i , 1 ) ;
22357: LD_VAR 0 1
22361: PPUSH
22362: LD_INT 1
22364: PPUSH
22365: CALL_OW 109
// ComExitBuilding ( i ) ;
22369: LD_VAR 0 1
22373: PPUSH
22374: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22378: LD_VAR 0 1
22382: PPUSH
22383: LD_INT 35
22385: PPUSH
22386: LD_INT 6
22388: PPUSH
22389: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22393: LD_VAR 0 1
22397: PPUSH
22398: LD_INT 53
22400: PPUSH
22401: LD_INT 4
22403: PPUSH
22404: CALL_OW 171
// end ;
22408: GO 22354
22410: POP
22411: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22412: LD_ADDR_VAR 0 3
22416: PUSH
22417: LD_INT 22
22419: PUSH
22420: LD_INT 4
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: PUSH
22427: LD_INT 21
22429: PUSH
22430: LD_INT 2
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: LD_INT 3
22439: PUSH
22440: LD_INT 34
22442: PUSH
22443: LD_INT 12
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: LIST
22458: PPUSH
22459: CALL_OW 69
22463: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22464: LD_EXP 57
22468: PPUSH
22469: LD_VAR 0 3
22473: PPUSH
22474: LD_EXP 57
22478: PPUSH
22479: CALL_OW 74
22483: PPUSH
22484: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22488: LD_EXP 57
22492: PPUSH
22493: LD_INT 100
22495: PPUSH
22496: LD_INT 88
22498: PPUSH
22499: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22503: LD_EXP 57
22507: PPUSH
22508: LD_INT 100
22510: PPUSH
22511: LD_INT 75
22513: PPUSH
22514: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22518: LD_EXP 57
22522: PPUSH
22523: LD_INT 88
22525: PPUSH
22526: LD_INT 53
22528: PPUSH
22529: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22533: LD_INT 8
22535: PPUSH
22536: LD_EXP 57
22540: PPUSH
22541: CALL_OW 471
// repeat wait ( 3 ) ;
22545: LD_INT 3
22547: PPUSH
22548: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22552: LD_INT 22
22554: PUSH
22555: LD_INT 4
22557: PUSH
22558: EMPTY
22559: LIST
22560: LIST
22561: PUSH
22562: LD_INT 92
22564: PUSH
22565: LD_INT 100
22567: PUSH
22568: LD_INT 75
22570: PUSH
22571: LD_INT 6
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: PPUSH
22584: CALL_OW 69
22588: IFFALSE 22545
// async ;
22590: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22591: LD_EXP 57
22595: PPUSH
22596: LD_STRING D6b-Pow-1
22598: PPUSH
22599: CALL_OW 88
// repeat wait ( 3 ) ;
22603: LD_INT 3
22605: PPUSH
22606: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22610: LD_EXP 57
22614: PPUSH
22615: CALL_OW 310
22619: PPUSH
22620: CALL_OW 256
22624: PUSH
22625: LD_INT 1000
22627: LESS
22628: IFFALSE 22647
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22630: LD_EXP 57
22634: PPUSH
22635: CALL_OW 310
22639: PPUSH
22640: LD_INT 1000
22642: PPUSH
22643: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22647: LD_EXP 57
22651: PPUSH
22652: CALL_OW 256
22656: PUSH
22657: LD_INT 1000
22659: LESS
22660: IFFALSE 22674
// SetLives ( Powell , 1000 ) ;
22662: LD_EXP 57
22666: PPUSH
22667: LD_INT 1000
22669: PPUSH
22670: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22674: LD_EXP 57
22678: PPUSH
22679: LD_EXP 62
22683: PPUSH
22684: CALL_OW 296
22688: PUSH
22689: LD_INT 5
22691: LESS
22692: PUSH
22693: LD_EXP 57
22697: PPUSH
22698: CALL_OW 310
22702: PPUSH
22703: LD_EXP 62
22707: PPUSH
22708: CALL_OW 296
22712: PUSH
22713: LD_INT 5
22715: LESS
22716: OR
22717: IFFALSE 22736
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22719: LD_EXP 57
22723: PPUSH
22724: CALL_OW 310
22728: PPUSH
22729: LD_INT 100
22731: PPUSH
22732: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22736: LD_EXP 57
22740: PPUSH
22741: CALL_OW 310
22745: NOT
22746: IFFALSE 22603
// DoNotAttack ( 8 , powellBomb ) ;
22748: LD_INT 8
22750: PPUSH
22751: LD_EXP 62
22755: PPUSH
22756: CALL_OW 471
// game_speed := 4 ;
22760: LD_ADDR_OWVAR 65
22764: PUSH
22765: LD_INT 4
22767: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22768: LD_EXP 57
22772: PPUSH
22773: LD_STRING D6b-Pow-1a
22775: PPUSH
22776: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22780: LD_EXP 57
22784: PPUSH
22785: LD_EXP 62
22789: PPUSH
22790: CALL_OW 180
// sync ;
22794: SYNC
// repeat wait ( 0 0$1 ) ;
22795: LD_INT 35
22797: PPUSH
22798: CALL_OW 67
// until IsInUnit ( Powell ) ;
22802: LD_EXP 57
22806: PPUSH
22807: CALL_OW 310
22811: IFFALSE 22795
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22813: LD_INT 8
22815: PPUSH
22816: LD_EXP 57
22820: PPUSH
22821: CALL_OW 310
22825: PPUSH
22826: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22830: LD_EXP 57
22834: PPUSH
22835: LD_INT 91
22837: PPUSH
22838: LD_INT 44
22840: PPUSH
22841: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22845: LD_EXP 57
22849: PPUSH
22850: LD_INT 96
22852: PPUSH
22853: LD_INT 44
22855: PPUSH
22856: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22860: LD_EXP 57
22864: PPUSH
22865: LD_INT 96
22867: PPUSH
22868: LD_INT 41
22870: PPUSH
22871: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22875: LD_EXP 57
22879: PPUSH
22880: LD_INT 92
22882: PPUSH
22883: LD_INT 39
22885: PPUSH
22886: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22890: LD_EXP 57
22894: PPUSH
22895: LD_INT 88
22897: PPUSH
22898: LD_INT 41
22900: PPUSH
22901: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22905: LD_EXP 57
22909: PPUSH
22910: LD_INT 91
22912: PPUSH
22913: LD_INT 44
22915: PPUSH
22916: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22920: LD_EXP 57
22924: PPUSH
22925: LD_INT 96
22927: PPUSH
22928: LD_INT 44
22930: PPUSH
22931: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22935: LD_EXP 57
22939: PPUSH
22940: LD_INT 96
22942: PPUSH
22943: LD_INT 41
22945: PPUSH
22946: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22950: LD_EXP 57
22954: PPUSH
22955: LD_INT 92
22957: PPUSH
22958: LD_INT 39
22960: PPUSH
22961: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22965: LD_EXP 57
22969: PPUSH
22970: LD_INT 88
22972: PPUSH
22973: LD_INT 41
22975: PPUSH
22976: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22980: LD_EXP 57
22984: PPUSH
22985: LD_INT 91
22987: PPUSH
22988: LD_INT 44
22990: PPUSH
22991: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22995: LD_EXP 57
22999: PPUSH
23000: LD_INT 93
23002: PPUSH
23003: LD_INT 39
23005: PPUSH
23006: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23010: LD_EXP 57
23014: PPUSH
23015: LD_INT 93
23017: PPUSH
23018: LD_INT 36
23020: PPUSH
23021: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23025: LD_INT 122
23027: PPUSH
23028: CALL_OW 67
// game_speed := 4 ;
23032: LD_ADDR_OWVAR 65
23036: PUSH
23037: LD_INT 4
23039: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23040: LD_EXP 57
23044: PPUSH
23045: LD_STRING D6b-Pow-1b
23047: PPUSH
23048: CALL_OW 88
// tmp := [ ] ;
23052: LD_ADDR_VAR 0 3
23056: PUSH
23057: EMPTY
23058: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23059: LD_ADDR_VAR 0 5
23063: PUSH
23064: LD_INT 78
23066: PUSH
23067: LD_INT 47
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: PUSH
23074: LD_INT 106
23076: PUSH
23077: LD_INT 53
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: PUSH
23084: EMPTY
23085: LIST
23086: LIST
23087: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23088: LD_ADDR_VAR 0 1
23092: PUSH
23093: LD_INT 22
23095: PUSH
23096: LD_INT 8
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: PUSH
23103: LD_INT 21
23105: PUSH
23106: LD_INT 3
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PUSH
23113: LD_INT 92
23115: PUSH
23116: LD_INT 90
23118: PUSH
23119: LD_INT 52
23121: PUSH
23122: LD_INT 12
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: LIST
23129: LIST
23130: PUSH
23131: EMPTY
23132: LIST
23133: LIST
23134: LIST
23135: PPUSH
23136: CALL_OW 69
23140: PUSH
23141: FOR_IN
23142: IFFALSE 23167
// tmp := tmp ^ UnitsInside ( i ) ;
23144: LD_ADDR_VAR 0 3
23148: PUSH
23149: LD_VAR 0 3
23153: PUSH
23154: LD_VAR 0 1
23158: PPUSH
23159: CALL_OW 313
23163: ADD
23164: ST_TO_ADDR
23165: GO 23141
23167: POP
23168: POP
// for i in tmp do
23169: LD_ADDR_VAR 0 1
23173: PUSH
23174: LD_VAR 0 3
23178: PUSH
23179: FOR_IN
23180: IFFALSE 23342
// begin dist := 9999 ;
23182: LD_ADDR_VAR 0 8
23186: PUSH
23187: LD_INT 9999
23189: ST_TO_ADDR
// _xy := [ ] ;
23190: LD_ADDR_VAR 0 7
23194: PUSH
23195: EMPTY
23196: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23197: LD_VAR 0 1
23201: PPUSH
23202: LD_INT 1
23204: PPUSH
23205: CALL_OW 109
// ComExitBuilding ( i ) ;
23209: LD_VAR 0 1
23213: PPUSH
23214: CALL_OW 122
// for j in xy do
23218: LD_ADDR_VAR 0 2
23222: PUSH
23223: LD_VAR 0 5
23227: PUSH
23228: FOR_IN
23229: IFFALSE 23311
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23231: LD_VAR 0 1
23235: PPUSH
23236: LD_VAR 0 2
23240: PUSH
23241: LD_INT 1
23243: ARRAY
23244: PPUSH
23245: LD_VAR 0 2
23249: PUSH
23250: LD_INT 2
23252: ARRAY
23253: PPUSH
23254: CALL_OW 297
23258: PUSH
23259: LD_VAR 0 8
23263: LESS
23264: IFFALSE 23309
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23266: LD_ADDR_VAR 0 8
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: LD_VAR 0 2
23280: PUSH
23281: LD_INT 1
23283: ARRAY
23284: PPUSH
23285: LD_VAR 0 2
23289: PUSH
23290: LD_INT 2
23292: ARRAY
23293: PPUSH
23294: CALL_OW 297
23298: ST_TO_ADDR
// _xy := j ;
23299: LD_ADDR_VAR 0 7
23303: PUSH
23304: LD_VAR 0 2
23308: ST_TO_ADDR
// end ;
23309: GO 23228
23311: POP
23312: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23313: LD_VAR 0 1
23317: PPUSH
23318: LD_VAR 0 7
23322: PUSH
23323: LD_INT 1
23325: ARRAY
23326: PPUSH
23327: LD_VAR 0 7
23331: PUSH
23332: LD_INT 2
23334: ARRAY
23335: PPUSH
23336: CALL_OW 171
// end ;
23340: GO 23179
23342: POP
23343: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23344: LD_ADDR_VAR 0 4
23348: PUSH
23349: LD_VAR 0 3
23353: PPUSH
23354: LD_INT 26
23356: PUSH
23357: LD_INT 1
23359: PUSH
23360: EMPTY
23361: LIST
23362: LIST
23363: PUSH
23364: LD_INT 25
23366: PUSH
23367: LD_INT 1
23369: PUSH
23370: EMPTY
23371: LIST
23372: LIST
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PPUSH
23378: CALL_OW 72
23382: ST_TO_ADDR
// if tmp2 < 2 then
23383: LD_VAR 0 4
23387: PUSH
23388: LD_INT 2
23390: LESS
23391: IFFALSE 23460
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23393: LD_ADDR_VAR 0 4
23397: PUSH
23398: LD_INT 22
23400: PUSH
23401: LD_INT 8
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: LD_INT 26
23410: PUSH
23411: LD_INT 1
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: PUSH
23418: LD_INT 3
23420: PUSH
23421: LD_INT 25
23423: PUSH
23424: LD_INT 15
23426: PUSH
23427: EMPTY
23428: LIST
23429: LIST
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: LIST
23439: PPUSH
23440: CALL_OW 69
23444: PUSH
23445: LD_EXP 59
23449: PUSH
23450: LD_EXP 60
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: DIFF
23459: ST_TO_ADDR
// if tmp2 then
23460: LD_VAR 0 4
23464: IFFALSE 23482
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23466: LD_VAR 0 4
23470: PUSH
23471: LD_INT 1
23473: ARRAY
23474: PPUSH
23475: LD_STRING D6b-ArSol1-1
23477: PPUSH
23478: CALL_OW 88
// async ;
23482: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23483: LD_EXP 57
23487: PPUSH
23488: LD_STRING D6b-Pow-2
23490: PPUSH
23491: CALL_OW 88
// wait ( 0 0$1 ) ;
23495: LD_INT 35
23497: PPUSH
23498: CALL_OW 67
// if tmp2 > 1 then
23502: LD_VAR 0 4
23506: PUSH
23507: LD_INT 1
23509: GREATER
23510: IFFALSE 23528
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23512: LD_VAR 0 4
23516: PUSH
23517: LD_INT 2
23519: ARRAY
23520: PPUSH
23521: LD_STRING D6b-ArSol2-1
23523: PPUSH
23524: CALL_OW 88
// sync ;
23528: SYNC
// repeat wait ( 5 ) ;
23529: LD_INT 5
23531: PPUSH
23532: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23536: LD_INT 93
23538: PPUSH
23539: LD_INT 36
23541: PPUSH
23542: CALL_OW 428
23546: PPUSH
23547: CALL_OW 255
23551: PUSH
23552: LD_INT 4
23554: EQUAL
23555: IFFALSE 23529
// DialogueOn ;
23557: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23561: LD_INT 10
23563: PPUSH
23564: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23568: LD_EXP 57
23572: PPUSH
23573: LD_STRING D6b-Pow-2a
23575: PPUSH
23576: CALL_OW 88
// DialogueOff ;
23580: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23584: LD_EXP 57
23588: PPUSH
23589: CALL_OW 310
23593: PPUSH
23594: LD_INT 332
23596: PPUSH
23597: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23601: LD_INT 93
23603: PPUSH
23604: LD_INT 35
23606: PPUSH
23607: LD_INT 1
23609: PPUSH
23610: LD_INT 6
23612: NEG
23613: PPUSH
23614: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23618: LD_INT 35
23620: PPUSH
23621: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23625: LD_INT 332
23627: PPUSH
23628: CALL_OW 256
23632: PUSH
23633: LD_INT 1000
23635: LESS
23636: PUSH
23637: LD_INT 332
23639: PPUSH
23640: CALL_OW 300
23644: AND
23645: IFFALSE 23657
// SetLives ( kozlov_fac , 0 ) ;
23647: LD_INT 332
23649: PPUSH
23650: LD_INT 0
23652: PPUSH
23653: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23657: LD_INT 332
23659: PPUSH
23660: CALL_OW 301
23664: PUSH
23665: LD_EXP 57
23669: PPUSH
23670: CALL_OW 301
23674: OR
23675: IFFALSE 23618
// game_speed := 4 ;
23677: LD_ADDR_OWVAR 65
23681: PUSH
23682: LD_INT 4
23684: ST_TO_ADDR
// powellCenterCameraMode := false ;
23685: LD_ADDR_EXP 20
23689: PUSH
23690: LD_INT 0
23692: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23693: LD_ADDR_VAR 0 1
23697: PUSH
23698: LD_VAR 0 3
23702: PUSH
23703: LD_INT 22
23705: PUSH
23706: LD_INT 8
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: PUSH
23713: LD_INT 25
23715: PUSH
23716: LD_INT 2
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PPUSH
23727: CALL_OW 69
23731: UNION
23732: PUSH
23733: FOR_IN
23734: IFFALSE 23750
// SetTag ( i , 0 ) ;
23736: LD_VAR 0 1
23740: PPUSH
23741: LD_INT 0
23743: PPUSH
23744: CALL_OW 109
23748: GO 23733
23750: POP
23751: POP
// wait ( 0 0$3 ) ;
23752: LD_INT 105
23754: PPUSH
23755: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23759: LD_INT 93
23761: PPUSH
23762: LD_INT 35
23764: PPUSH
23765: LD_INT 1
23767: PPUSH
23768: CALL_OW 331
// DialogueOn ;
23772: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23776: LD_VAR 0 11
23780: PPUSH
23781: LD_STRING D6c-Sol3-1
23783: PPUSH
23784: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23788: LD_INT 10
23790: PPUSH
23791: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23795: LD_EXP 38
23799: PPUSH
23800: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23804: LD_EXP 38
23808: PPUSH
23809: LD_STRING D6c-JMM-1
23811: PPUSH
23812: CALL_OW 88
// if Cyrus then
23816: LD_EXP 44
23820: IFFALSE 23834
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23822: LD_EXP 44
23826: PPUSH
23827: LD_STRING D6c-Cyrus-1
23829: PPUSH
23830: CALL_OW 88
// if Bobby then
23834: LD_EXP 43
23838: IFFALSE 23852
// Say ( Bobby , D6c-Bobby-1 ) ;
23840: LD_EXP 43
23844: PPUSH
23845: LD_STRING D6c-Bobby-1
23847: PPUSH
23848: CALL_OW 88
// if Cornel then
23852: LD_EXP 49
23856: IFFALSE 23870
// Say ( Cornel , D6c-Corn-1 ) ;
23858: LD_EXP 49
23862: PPUSH
23863: LD_STRING D6c-Corn-1
23865: PPUSH
23866: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23870: LD_ADDR_VAR 0 4
23874: PUSH
23875: LD_INT 2
23877: PUSH
23878: LD_INT 22
23880: PUSH
23881: LD_INT 1
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 22
23890: PUSH
23891: LD_INT 4
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: LIST
23902: PUSH
23903: LD_INT 26
23905: PUSH
23906: LD_INT 1
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: PUSH
23913: LD_INT 3
23915: PUSH
23916: LD_INT 25
23918: PUSH
23919: LD_INT 16
23921: PUSH
23922: EMPTY
23923: LIST
23924: LIST
23925: PUSH
23926: LD_INT 25
23928: PUSH
23929: LD_INT 12
23931: PUSH
23932: EMPTY
23933: LIST
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: PPUSH
23946: CALL_OW 69
23950: PUSH
23951: LD_VAR 0 11
23955: PUSH
23956: LD_EXP 38
23960: UNION
23961: PUSH
23962: LD_EXP 58
23966: UNION
23967: PUSH
23968: EMPTY
23969: LIST
23970: DIFF
23971: ST_TO_ADDR
// if tmp2 then
23972: LD_VAR 0 4
23976: IFFALSE 23994
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23978: LD_VAR 0 4
23982: PUSH
23983: LD_INT 1
23985: ARRAY
23986: PPUSH
23987: LD_STRING D6c-Sol1-1
23989: PPUSH
23990: CALL_OW 88
// if Lisa then
23994: LD_EXP 41
23998: IFFALSE 24012
// Say ( Lisa , D6c-Lisa-1 ) ;
24000: LD_EXP 41
24004: PPUSH
24005: LD_STRING D6c-Lisa-1
24007: PPUSH
24008: CALL_OW 88
// if Gary then
24012: LD_EXP 50
24016: IFFALSE 24030
// Say ( Gary , D6c-Gary-1 ) ;
24018: LD_EXP 50
24022: PPUSH
24023: LD_STRING D6c-Gary-1
24025: PPUSH
24026: CALL_OW 88
// if Donaldson then
24030: LD_EXP 42
24034: IFFALSE 24048
// Say ( Donaldson , D6c-Don-1 ) ;
24036: LD_EXP 42
24040: PPUSH
24041: LD_STRING D6c-Don-1
24043: PPUSH
24044: CALL_OW 88
// if tmp2 > 1 then
24048: LD_VAR 0 4
24052: PUSH
24053: LD_INT 1
24055: GREATER
24056: IFFALSE 24074
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24058: LD_VAR 0 4
24062: PUSH
24063: LD_INT 2
24065: ARRAY
24066: PPUSH
24067: LD_STRING D6c-Sol2-1
24069: PPUSH
24070: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24074: LD_VAR 0 11
24078: PPUSH
24079: LD_STRING D6c-Sol3-2
24081: PPUSH
24082: CALL_OW 88
// dwait ( 0 0$1 ) ;
24086: LD_INT 35
24088: PPUSH
24089: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24093: LD_EXP 38
24097: PPUSH
24098: LD_STRING D6c-JMM-2
24100: PPUSH
24101: CALL_OW 88
// DialogueOff ;
24105: CALL_OW 7
// Video ( false ) ;
24109: LD_INT 0
24111: PPUSH
24112: CALL 107204 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24116: LD_INT 22
24118: PUSH
24119: LD_INT 4
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PPUSH
24126: CALL_OW 69
24130: PPUSH
24131: LD_INT 1
24133: PPUSH
24134: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24138: LD_INT 4
24140: PPUSH
24141: LD_INT 4
24143: PPUSH
24144: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24148: LD_ADDR_VAR 0 1
24152: PUSH
24153: LD_INT 4
24155: PPUSH
24156: LD_INT 1
24158: PPUSH
24159: LD_INT 2
24161: PPUSH
24162: CALL 64435 0 3
24166: PUSH
24167: FOR_IN
24168: IFFALSE 24205
// if GetTech ( i , 1 ) <> state_researched then
24170: LD_VAR 0 1
24174: PPUSH
24175: LD_INT 1
24177: PPUSH
24178: CALL_OW 321
24182: PUSH
24183: LD_INT 2
24185: NONEQUAL
24186: IFFALSE 24203
// SetTech ( i , 1 , state_researched ) ;
24188: LD_VAR 0 1
24192: PPUSH
24193: LD_INT 1
24195: PPUSH
24196: LD_INT 2
24198: PPUSH
24199: CALL_OW 322
24203: GO 24167
24205: POP
24206: POP
// missionStage := 6 ;
24207: LD_ADDR_EXP 15
24211: PUSH
24212: LD_INT 6
24214: ST_TO_ADDR
// activeAttacks := true ;
24215: LD_ADDR_EXP 16
24219: PUSH
24220: LD_INT 1
24222: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24223: LD_STRING M2
24225: PPUSH
24226: CALL_OW 337
// SaveForQuickRestart ;
24230: CALL_OW 22
// wait ( 0 0$40 ) ;
24234: LD_INT 1400
24236: PPUSH
24237: CALL_OW 67
// DialogueOn ;
24241: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24245: LD_EXP 61
24249: PPUSH
24250: LD_STRING D7-Friend-1
24252: PPUSH
24253: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24257: LD_EXP 38
24261: PPUSH
24262: LD_STRING D7-JMM-1
24264: PPUSH
24265: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24269: LD_EXP 61
24273: PPUSH
24274: LD_STRING D7-Friend-2
24276: PPUSH
24277: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24281: LD_EXP 38
24285: PPUSH
24286: LD_STRING D7-JMM-2
24288: PPUSH
24289: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24293: LD_EXP 61
24297: PPUSH
24298: LD_STRING D7-Friend-3
24300: PPUSH
24301: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24305: LD_EXP 38
24309: PPUSH
24310: LD_STRING D7-JMM-3
24312: PPUSH
24313: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24317: LD_EXP 61
24321: PPUSH
24322: LD_STRING D7-Friend-4
24324: PPUSH
24325: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24329: LD_EXP 38
24333: PPUSH
24334: LD_STRING D7-JMM-4
24336: PPUSH
24337: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24341: LD_EXP 61
24345: PPUSH
24346: LD_STRING D7-Friend-5
24348: PPUSH
24349: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24353: LD_EXP 38
24357: PPUSH
24358: LD_STRING D7-JMM-5
24360: PPUSH
24361: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24365: LD_EXP 61
24369: PPUSH
24370: LD_STRING D7-Friend-6
24372: PPUSH
24373: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24377: LD_EXP 38
24381: PPUSH
24382: LD_STRING D7-JMM-6
24384: PPUSH
24385: CALL_OW 88
// DialogueOff ;
24389: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24393: LD_STRING Mlegion
24395: PPUSH
24396: CALL_OW 337
// RebuildKozlovFactory ;
24400: CALL 4840 0 0
// end ;
24404: PPOPN 13
24406: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24407: LD_EXP 20
24411: PUSH
24412: LD_EXP 57
24416: PPUSH
24417: CALL_OW 300
24421: AND
24422: IFFALSE 24464
24424: GO 24426
24426: DISABLE
// begin enable ;
24427: ENABLE
// if IsInUnit ( Powell ) then
24428: LD_EXP 57
24432: PPUSH
24433: CALL_OW 310
24437: IFFALSE 24455
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24439: LD_EXP 57
24443: PPUSH
24444: CALL_OW 310
24448: PPUSH
24449: CALL_OW 85
24453: GO 24464
// CenterOnUnits ( Powell ) ;
24455: LD_EXP 57
24459: PPUSH
24460: CALL_OW 85
// end ;
24464: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24465: LD_INT 22
24467: PUSH
24468: LD_INT 8
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PUSH
24475: LD_INT 34
24477: PUSH
24478: LD_INT 48
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: PPUSH
24489: CALL_OW 69
24493: IFFALSE 24756
24495: GO 24497
24497: DISABLE
24498: LD_INT 0
24500: PPUSH
24501: PPUSH
// begin if missionStage < 9 then
24502: LD_EXP 15
24506: PUSH
24507: LD_INT 9
24509: LESS
24510: IFFALSE 24520
// missionStage := 9 ;
24512: LD_ADDR_EXP 15
24516: PUSH
24517: LD_INT 9
24519: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24520: LD_ADDR_VAR 0 1
24524: PUSH
24525: LD_INT 22
24527: PUSH
24528: LD_INT 8
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 34
24537: PUSH
24538: LD_INT 48
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PPUSH
24549: CALL_OW 69
24553: PUSH
24554: LD_INT 1
24556: ARRAY
24557: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24558: LD_INT 175
24560: PPUSH
24561: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24565: LD_EXP 12
24569: PUSH
24570: LD_EXP 3
24574: PUSH
24575: LD_INT 0
24577: PUSH
24578: LD_INT 2
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: IN
24585: OR
24586: IFFALSE 24609
// target := [ 68 , 108 , 1 ] else
24588: LD_ADDR_VAR 0 2
24592: PUSH
24593: LD_INT 68
24595: PUSH
24596: LD_INT 108
24598: PUSH
24599: LD_INT 1
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: LIST
24606: ST_TO_ADDR
24607: GO 24628
// target := [ 181 , 88 , 2 ] ;
24609: LD_ADDR_VAR 0 2
24613: PUSH
24614: LD_INT 181
24616: PUSH
24617: LD_INT 88
24619: PUSH
24620: LD_INT 2
24622: PUSH
24623: EMPTY
24624: LIST
24625: LIST
24626: LIST
24627: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24628: LD_VAR 0 1
24632: PPUSH
24633: LD_VAR 0 2
24637: PUSH
24638: LD_INT 1
24640: ARRAY
24641: PPUSH
24642: LD_VAR 0 2
24646: PUSH
24647: LD_INT 2
24649: ARRAY
24650: PPUSH
24651: CALL_OW 176
// if target [ 3 ] = 1 then
24655: LD_VAR 0 2
24659: PUSH
24660: LD_INT 3
24662: ARRAY
24663: PUSH
24664: LD_INT 1
24666: EQUAL
24667: IFFALSE 24683
// SayRadio ( Kurt , D12-Kurt-1 ) else
24669: LD_EXP 59
24673: PPUSH
24674: LD_STRING D12-Kurt-1
24676: PPUSH
24677: CALL_OW 94
24681: GO 24707
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24683: LD_EXP 59
24687: PPUSH
24688: LD_STRING D12a-Kurt-1
24690: PPUSH
24691: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24695: LD_EXP 73
24699: PPUSH
24700: LD_STRING D12a-Roth-1
24702: PPUSH
24703: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24707: LD_INT 350
24709: PPUSH
24710: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_INT 22
24721: PUSH
24722: LD_INT 8
24724: PUSH
24725: EMPTY
24726: LIST
24727: LIST
24728: PUSH
24729: LD_INT 30
24731: PUSH
24732: LD_INT 3
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PPUSH
24743: CALL_OW 69
24747: PUSH
24748: LD_INT 1
24750: ARRAY
24751: PPUSH
24752: CALL_OW 228
// end ;
24756: PPOPN 2
24758: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24759: LD_INT 22
24761: PUSH
24762: LD_INT 8
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 21
24771: PUSH
24772: LD_INT 1
24774: PUSH
24775: EMPTY
24776: LIST
24777: LIST
24778: PUSH
24779: LD_INT 23
24781: PUSH
24782: LD_INT 2
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: LIST
24793: PPUSH
24794: CALL_OW 69
24798: PUSH
24799: LD_INT 9
24801: PUSH
24802: LD_INT 8
24804: PUSH
24805: LD_INT 7
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: LIST
24812: PUSH
24813: LD_OWVAR 67
24817: ARRAY
24818: LESSEQUAL
24819: PUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 34
24832: PUSH
24833: LD_INT 48
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 69
24848: NOT
24849: AND
24850: PUSH
24851: LD_EXP 59
24855: PPUSH
24856: CALL_OW 302
24860: AND
24861: IFFALSE 25166
24863: GO 24865
24865: DISABLE
// begin DialogueOn ;
24866: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24870: LD_EXP 38
24874: PPUSH
24875: LD_STRING D13-JMM-1
24877: PPUSH
24878: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24882: LD_EXP 59
24886: PPUSH
24887: LD_STRING D13-Kurt-1
24889: PPUSH
24890: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24894: LD_EXP 38
24898: PPUSH
24899: LD_STRING D13-JMM-2
24901: PPUSH
24902: CALL_OW 88
// if FakeInfo then
24906: LD_EXP 12
24910: IFFALSE 24930
// begin Say ( Kurt , D13-Kurt-2 ) ;
24912: LD_EXP 59
24916: PPUSH
24917: LD_STRING D13-Kurt-2
24919: PPUSH
24920: CALL_OW 88
// DialogueOff ;
24924: CALL_OW 7
// exit ;
24928: GO 25166
// end ; if not KurtStatus then
24930: LD_EXP 3
24934: NOT
24935: IFFALSE 24951
// Say ( Kurt , D13-Kurt-2b ) else
24937: LD_EXP 59
24941: PPUSH
24942: LD_STRING D13-Kurt-2b
24944: PPUSH
24945: CALL_OW 88
24949: GO 24963
// Say ( Kurt , D13-Kurt-2a ) ;
24951: LD_EXP 59
24955: PPUSH
24956: LD_STRING D13-Kurt-2a
24958: PPUSH
24959: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24963: LD_EXP 38
24967: PPUSH
24968: LD_STRING D13-JMM-3
24970: PPUSH
24971: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24975: LD_EXP 59
24979: PPUSH
24980: LD_STRING D13-Kurt-3
24982: PPUSH
24983: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24987: LD_EXP 38
24991: PPUSH
24992: LD_STRING D13-JMM-4
24994: PPUSH
24995: CALL_OW 88
// DialogueOff ;
24999: CALL_OW 7
// MC_Kill ( 3 ) ;
25003: LD_INT 3
25005: PPUSH
25006: CALL 34464 0 1
// KillUnit ( Kozlov ) ;
25010: LD_EXP 60
25014: PPUSH
25015: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25019: LD_INT 22
25021: PUSH
25022: LD_INT 8
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 21
25031: PUSH
25032: LD_INT 3
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 23
25041: PUSH
25042: LD_INT 3
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 30
25051: PUSH
25052: LD_INT 3
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: LIST
25063: LIST
25064: PPUSH
25065: CALL_OW 69
25069: PUSH
25070: LD_INT 1
25072: ARRAY
25073: PPUSH
25074: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25078: LD_INT 8
25080: PPUSH
25081: LD_INT 1
25083: PPUSH
25084: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
25088: LD_INT 22
25090: PUSH
25091: LD_INT 8
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: PPUSH
25098: CALL_OW 69
25102: PPUSH
25103: LD_INT 1
25105: PPUSH
25106: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25110: LD_INT 8
25112: PPUSH
25113: LD_INT 1
25115: PPUSH
25116: LD_INT 1
25118: PPUSH
25119: LD_INT 1
25121: PPUSH
25122: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25126: LD_EXP 61
25130: PPUSH
25131: LD_INT 37
25133: PPUSH
25134: LD_INT 1
25136: PPUSH
25137: LD_INT 0
25139: PPUSH
25140: CALL_OW 48
// wait ( 0 0$1 ) ;
25144: LD_INT 35
25146: PPUSH
25147: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25151: LD_EXP 61
25155: PPUSH
25156: LD_INT 60
25158: PPUSH
25159: LD_INT 95
25161: PPUSH
25162: CALL_OW 111
// end ;
25166: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25167: LD_INT 22
25169: PUSH
25170: LD_INT 8
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 21
25179: PUSH
25180: LD_INT 1
25182: PUSH
25183: EMPTY
25184: LIST
25185: LIST
25186: PUSH
25187: EMPTY
25188: LIST
25189: LIST
25190: PPUSH
25191: CALL_OW 69
25195: PUSH
25196: LD_INT 0
25198: EQUAL
25199: IFFALSE 25219
25201: GO 25203
25203: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25204: LD_STRING MlegionOut
25206: PPUSH
25207: CALL_OW 337
// legionDestroyed := true ;
25211: LD_ADDR_EXP 22
25215: PUSH
25216: LD_INT 1
25218: ST_TO_ADDR
// end ;
25219: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25220: LD_INT 1
25222: PPUSH
25223: LD_EXP 61
25227: PPUSH
25228: CALL_OW 292
25232: IFFALSE 25532
25234: GO 25236
25236: DISABLE
25237: LD_INT 0
25239: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
25240: LD_EXP 61
25244: PPUSH
25245: CALL_OW 87
// DialogueOn ;
25249: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25253: LD_EXP 38
25257: PPUSH
25258: LD_STRING D14-JMM-1
25260: PPUSH
25261: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25265: LD_EXP 61
25269: PPUSH
25270: LD_STRING D14-Friend-1
25272: PPUSH
25273: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25277: LD_EXP 38
25281: PPUSH
25282: LD_STRING D14-JMM-2
25284: PPUSH
25285: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25289: LD_EXP 61
25293: PPUSH
25294: LD_STRING D14-Friend-2
25296: PPUSH
25297: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25301: LD_EXP 38
25305: PPUSH
25306: LD_STRING D14-JMM-3
25308: PPUSH
25309: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25313: LD_EXP 61
25317: PPUSH
25318: LD_STRING D14-Friend-3
25320: PPUSH
25321: CALL_OW 88
// DialogueOff ;
25325: CALL_OW 7
// dec = Query ( Q14 ) ;
25329: LD_ADDR_VAR 0 1
25333: PUSH
25334: LD_STRING Q14
25336: PPUSH
25337: CALL_OW 97
25341: ST_TO_ADDR
// if dec = 1 then
25342: LD_VAR 0 1
25346: PUSH
25347: LD_INT 1
25349: EQUAL
25350: IFFALSE 25384
// begin DialogueOn ;
25352: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25356: LD_EXP 38
25360: PPUSH
25361: LD_STRING D14a-JMM-1
25363: PPUSH
25364: CALL_OW 88
// DialogueOff ;
25368: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25372: LD_EXP 61
25376: PPUSH
25377: LD_INT 1
25379: PPUSH
25380: CALL_OW 235
// end ; if dec = 2 then
25384: LD_VAR 0 1
25388: PUSH
25389: LD_INT 2
25391: EQUAL
25392: IFFALSE 25438
// begin DialogueOn ;
25394: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25398: LD_EXP 38
25402: PPUSH
25403: LD_STRING D14b-JMM-1
25405: PPUSH
25406: CALL_OW 88
// DialogueOff ;
25410: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25414: LD_EXP 61
25418: PPUSH
25419: LD_INT 9
25421: PPUSH
25422: LD_INT 2
25424: PPUSH
25425: CALL_OW 111
// AddComHold ( Friend ) ;
25429: LD_EXP 61
25433: PPUSH
25434: CALL_OW 200
// end ; if dec = 3 then
25438: LD_VAR 0 1
25442: PUSH
25443: LD_INT 3
25445: EQUAL
25446: IFFALSE 25532
// begin DialogueOn ;
25448: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25452: LD_EXP 38
25456: PPUSH
25457: LD_STRING D14c-JMM-1
25459: PPUSH
25460: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25464: LD_EXP 61
25468: PPUSH
25469: LD_STRING D14c-Friend-1
25471: PPUSH
25472: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25476: LD_EXP 38
25480: PPUSH
25481: LD_STRING D14c-JMM-2
25483: PPUSH
25484: CALL_OW 88
// DialogueOff ;
25488: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25492: LD_INT 8
25494: PPUSH
25495: LD_INT 1
25497: PPUSH
25498: LD_INT 2
25500: PPUSH
25501: LD_INT 1
25503: PPUSH
25504: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25508: LD_EXP 61
25512: PPUSH
25513: LD_INT 9
25515: PPUSH
25516: LD_INT 2
25518: PPUSH
25519: CALL_OW 111
// AddComHold ( Friend ) ;
25523: LD_EXP 61
25527: PPUSH
25528: CALL_OW 200
// end ; end ;
25532: PPOPN 1
25534: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25535: LD_INT 9
25537: PPUSH
25538: LD_INT 2
25540: PPUSH
25541: CALL_OW 428
25545: PUSH
25546: LD_EXP 61
25550: EQUAL
25551: PUSH
25552: LD_EXP 61
25556: PPUSH
25557: CALL_OW 255
25561: PUSH
25562: LD_INT 8
25564: EQUAL
25565: AND
25566: IFFALSE 25580
25568: GO 25570
25570: DISABLE
// RemoveUnit ( Friend ) ;
25571: LD_EXP 61
25575: PPUSH
25576: CALL_OW 64
25580: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25581: LD_EXP 14
25585: PUSH
25586: LD_INT 31500
25588: GREATEREQUAL
25589: PUSH
25590: LD_EXP 7
25594: AND
25595: PUSH
25596: LD_EXP 2
25600: AND
25601: IFFALSE 26031
25603: GO 25605
25605: DISABLE
25606: LD_INT 0
25608: PPUSH
25609: PPUSH
25610: PPUSH
// begin missionStage := 7 ;
25611: LD_ADDR_EXP 15
25615: PUSH
25616: LD_INT 7
25618: ST_TO_ADDR
// uc_side = 1 ;
25619: LD_ADDR_OWVAR 20
25623: PUSH
25624: LD_INT 1
25626: ST_TO_ADDR
// uc_nation = 1 ;
25627: LD_ADDR_OWVAR 21
25631: PUSH
25632: LD_INT 1
25634: ST_TO_ADDR
// for i = 1 to 5 do
25635: LD_ADDR_VAR 0 1
25639: PUSH
25640: DOUBLE
25641: LD_INT 1
25643: DEC
25644: ST_TO_ADDR
25645: LD_INT 5
25647: PUSH
25648: FOR_TO
25649: IFFALSE 25745
// begin vc_engine = 3 ;
25651: LD_ADDR_OWVAR 39
25655: PUSH
25656: LD_INT 3
25658: ST_TO_ADDR
// vc_control = 3 ;
25659: LD_ADDR_OWVAR 38
25663: PUSH
25664: LD_INT 3
25666: ST_TO_ADDR
// vc_chassis = 3 ;
25667: LD_ADDR_OWVAR 37
25671: PUSH
25672: LD_INT 3
25674: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25675: LD_ADDR_OWVAR 40
25679: PUSH
25680: LD_INT 5
25682: PUSH
25683: LD_INT 9
25685: PUSH
25686: LD_INT 7
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: LIST
25693: PUSH
25694: LD_INT 1
25696: PPUSH
25697: LD_INT 3
25699: PPUSH
25700: CALL_OW 12
25704: ARRAY
25705: ST_TO_ADDR
// veh = CreateVehicle ;
25706: LD_ADDR_VAR 0 2
25710: PUSH
25711: CALL_OW 45
25715: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25716: LD_VAR 0 2
25720: PPUSH
25721: LD_INT 1
25723: PPUSH
25724: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25728: LD_VAR 0 2
25732: PPUSH
25733: LD_INT 19
25735: PPUSH
25736: LD_INT 0
25738: PPUSH
25739: CALL_OW 49
// end ;
25743: GO 25648
25745: POP
25746: POP
// vc_engine = 3 ;
25747: LD_ADDR_OWVAR 39
25751: PUSH
25752: LD_INT 3
25754: ST_TO_ADDR
// vc_control = 1 ;
25755: LD_ADDR_OWVAR 38
25759: PUSH
25760: LD_INT 1
25762: ST_TO_ADDR
// vc_chassis = 3 ;
25763: LD_ADDR_OWVAR 37
25767: PUSH
25768: LD_INT 3
25770: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25771: LD_ADDR_OWVAR 40
25775: PUSH
25776: LD_INT 5
25778: PUSH
25779: LD_INT 9
25781: PUSH
25782: LD_INT 7
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: LIST
25789: PUSH
25790: LD_INT 1
25792: PPUSH
25793: LD_INT 3
25795: PPUSH
25796: CALL_OW 12
25800: ARRAY
25801: ST_TO_ADDR
// vehG = CreateVehicle ;
25802: LD_ADDR_VAR 0 3
25806: PUSH
25807: CALL_OW 45
25811: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25812: LD_VAR 0 3
25816: PPUSH
25817: LD_INT 1
25819: PPUSH
25820: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25824: LD_VAR 0 3
25828: PPUSH
25829: LD_INT 19
25831: PPUSH
25832: LD_INT 0
25834: PPUSH
25835: CALL_OW 49
// if JMMGirl = 1 then
25839: LD_EXP 7
25843: PUSH
25844: LD_INT 1
25846: EQUAL
25847: IFFALSE 25903
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25849: LD_ADDR_EXP 39
25853: PUSH
25854: LD_STRING Joan
25856: PPUSH
25857: LD_INT 1
25859: PPUSH
25860: LD_STRING 14_
25862: PPUSH
25863: CALL 64372 0 3
25867: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25868: LD_EXP 39
25872: PPUSH
25873: LD_VAR 0 3
25877: PPUSH
25878: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25882: LD_VAR 0 3
25886: PPUSH
25887: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25891: LD_EXP 39
25895: PPUSH
25896: LD_STRING D10BW-Joan-1
25898: PPUSH
25899: CALL_OW 94
// end ; if JMMGirl = 2 then
25903: LD_EXP 7
25907: PUSH
25908: LD_INT 2
25910: EQUAL
25911: IFFALSE 25967
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25913: LD_ADDR_EXP 41
25917: PUSH
25918: LD_STRING Lisa
25920: PPUSH
25921: LD_INT 1
25923: PPUSH
25924: LD_STRING 14_
25926: PPUSH
25927: CALL 64372 0 3
25931: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25932: LD_EXP 41
25936: PPUSH
25937: LD_VAR 0 3
25941: PPUSH
25942: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25946: LD_VAR 0 3
25950: PPUSH
25951: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25955: LD_EXP 41
25959: PPUSH
25960: LD_STRING D10BW-Lisa-1
25962: PPUSH
25963: CALL_OW 94
// end ; if JMMGirl = 3 then
25967: LD_EXP 7
25971: PUSH
25972: LD_INT 3
25974: EQUAL
25975: IFFALSE 26031
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25977: LD_ADDR_EXP 53
25981: PUSH
25982: LD_STRING Connie
25984: PPUSH
25985: LD_INT 1
25987: PPUSH
25988: LD_STRING 14_
25990: PPUSH
25991: CALL 64372 0 3
25995: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25996: LD_EXP 53
26000: PPUSH
26001: LD_VAR 0 3
26005: PPUSH
26006: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26010: LD_VAR 0 3
26014: PPUSH
26015: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26019: LD_EXP 53
26023: PPUSH
26024: LD_STRING D10BW-Con-1
26026: PPUSH
26027: CALL_OW 94
// end ; end ;
26031: PPOPN 3
26033: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26034: LD_EXP 14
26038: PUSH
26039: LD_INT 94500
26041: GREATEREQUAL
26042: IFFALSE 26454
26044: GO 26046
26046: DISABLE
26047: LD_INT 0
26049: PPUSH
26050: PPUSH
26051: PPUSH
// begin tmp := PrepareStevensSquad ;
26052: LD_ADDR_VAR 0 3
26056: PUSH
26057: CALL 2214 0 0
26061: ST_TO_ADDR
// if not tmp then
26062: LD_VAR 0 3
26066: NOT
26067: IFFALSE 26071
// exit ;
26069: GO 26454
// uc_side := 1 ;
26071: LD_ADDR_OWVAR 20
26075: PUSH
26076: LD_INT 1
26078: ST_TO_ADDR
// uc_nation := 1 ;
26079: LD_ADDR_OWVAR 21
26083: PUSH
26084: LD_INT 1
26086: ST_TO_ADDR
// for i in tmp do
26087: LD_ADDR_VAR 0 1
26091: PUSH
26092: LD_VAR 0 3
26096: PUSH
26097: FOR_IN
26098: IFFALSE 26195
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26100: LD_INT 3
26102: PPUSH
26103: LD_INT 3
26105: PPUSH
26106: LD_INT 1
26108: PPUSH
26109: LD_INT 5
26111: PUSH
26112: LD_INT 9
26114: PUSH
26115: LD_INT 7
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: PPUSH
26126: LD_INT 3
26128: PPUSH
26129: CALL_OW 12
26133: ARRAY
26134: PPUSH
26135: LD_INT 40
26137: PPUSH
26138: CALL 71487 0 5
// veh := CreateVehicle ;
26142: LD_ADDR_VAR 0 2
26146: PUSH
26147: CALL_OW 45
26151: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26152: LD_VAR 0 2
26156: PPUSH
26157: LD_INT 1
26159: PPUSH
26160: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26164: LD_VAR 0 2
26168: PPUSH
26169: LD_INT 19
26171: PPUSH
26172: LD_INT 0
26174: PPUSH
26175: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26179: LD_VAR 0 1
26183: PPUSH
26184: LD_VAR 0 2
26188: PPUSH
26189: CALL_OW 52
// end ;
26193: GO 26097
26195: POP
26196: POP
// missionStage := 8 ;
26197: LD_ADDR_EXP 15
26201: PUSH
26202: LD_INT 8
26204: ST_TO_ADDR
// DialogueOn ;
26205: CALL_OW 6
// if Stevens then
26209: LD_EXP 40
26213: IFFALSE 26327
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26215: LD_EXP 40
26219: PPUSH
26220: CALL_OW 310
26224: PPUSH
26225: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26229: LD_EXP 40
26233: PPUSH
26234: LD_STRING D8-Huck-1
26236: PPUSH
26237: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26241: LD_EXP 38
26245: PPUSH
26246: LD_STRING D8-JMM-1
26248: PPUSH
26249: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26253: LD_EXP 40
26257: PPUSH
26258: LD_STRING D8-Huck-2
26260: PPUSH
26261: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26265: LD_EXP 38
26269: PPUSH
26270: LD_STRING D8-JMM-2
26272: PPUSH
26273: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26277: LD_EXP 40
26281: PPUSH
26282: LD_STRING D8-Huck-3
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26289: LD_EXP 38
26293: PPUSH
26294: LD_STRING D8-JMM-3
26296: PPUSH
26297: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26301: LD_EXP 40
26305: PPUSH
26306: LD_STRING D8-Huck-4
26308: PPUSH
26309: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26313: LD_EXP 38
26317: PPUSH
26318: LD_STRING D8-JMM-4
26320: PPUSH
26321: CALL_OW 88
// end else
26325: GO 26437
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26327: LD_EXP 54
26331: PPUSH
26332: CALL_OW 310
26336: PPUSH
26337: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26341: LD_EXP 54
26345: PPUSH
26346: LD_STRING D8-Huck-1
26348: PPUSH
26349: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26353: LD_EXP 38
26357: PPUSH
26358: LD_STRING D8-JMM-1a
26360: PPUSH
26361: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26365: LD_EXP 54
26369: PPUSH
26370: LD_STRING D8-Huck-2
26372: PPUSH
26373: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26377: LD_EXP 38
26381: PPUSH
26382: LD_STRING D8-JMM-2
26384: PPUSH
26385: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26389: LD_EXP 54
26393: PPUSH
26394: LD_STRING D8-Huck-3
26396: PPUSH
26397: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26401: LD_EXP 38
26405: PPUSH
26406: LD_STRING D8-JMM-3
26408: PPUSH
26409: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26413: LD_EXP 54
26417: PPUSH
26418: LD_STRING D8-Huck-4
26420: PPUSH
26421: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26425: LD_EXP 38
26429: PPUSH
26430: LD_STRING D8-JMM-4
26432: PPUSH
26433: CALL_OW 88
// end ; DialogueOff ;
26437: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26441: LD_INT 25
26443: PPUSH
26444: LD_INT 1
26446: PPUSH
26447: LD_INT 1
26449: PPUSH
26450: CALL_OW 322
// end ;
26454: PPOPN 3
26456: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26457: LD_INT 1
26459: PPUSH
26460: LD_EXP 70
26464: PPUSH
26465: CALL_OW 292
26469: IFFALSE 26720
26471: GO 26473
26473: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26474: LD_EXP 70
26478: PPUSH
26479: CALL_OW 87
// DialogueOn ;
26483: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26487: LD_EXP 38
26491: PPUSH
26492: LD_STRING D10nB-JMM-1
26494: PPUSH
26495: CALL_OW 88
// if BurlakStatus = 1 then
26499: LD_EXP 9
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26521
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26509: LD_EXP 69
26513: PPUSH
26514: LD_STRING D10nB-Vse-1a
26516: PPUSH
26517: CALL_OW 94
// end ; if BurlakStatus = 0 then
26521: LD_EXP 9
26525: PUSH
26526: LD_INT 0
26528: EQUAL
26529: IFFALSE 26543
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26531: LD_EXP 69
26535: PPUSH
26536: LD_STRING D10nB-Vse-1
26538: PPUSH
26539: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26543: LD_EXP 38
26547: PPUSH
26548: LD_STRING D10nB-JMM-2
26550: PPUSH
26551: CALL_OW 88
// if KappaStatus then
26555: LD_EXP 2
26559: IFFALSE 26573
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26561: LD_EXP 69
26565: PPUSH
26566: LD_STRING D10nB-Vse-5a
26568: PPUSH
26569: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26573: LD_EXP 2
26577: NOT
26578: PUSH
26579: LD_EXP 6
26583: PUSH
26584: LD_INT 0
26586: EQUAL
26587: AND
26588: IFFALSE 26716
// begin if JMMGirl = 1 then
26590: LD_EXP 7
26594: PUSH
26595: LD_INT 1
26597: EQUAL
26598: IFFALSE 26648
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26600: LD_EXP 69
26604: PPUSH
26605: LD_STRING D10nB-Vse-2
26607: PPUSH
26608: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26612: LD_EXP 38
26616: PPUSH
26617: LD_STRING D10nB-JMM-3
26619: PPUSH
26620: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26624: LD_EXP 69
26628: PPUSH
26629: LD_STRING D10nB-Vse-3
26631: PPUSH
26632: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26636: LD_EXP 38
26640: PPUSH
26641: LD_STRING D10nB-JMM-4
26643: PPUSH
26644: CALL_OW 88
// end ; if JMMGirl = 2 then
26648: LD_EXP 7
26652: PUSH
26653: LD_INT 2
26655: EQUAL
26656: IFFALSE 26682
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26658: LD_EXP 69
26662: PPUSH
26663: LD_STRING D10nB-Vse-4
26665: PPUSH
26666: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26670: LD_EXP 38
26674: PPUSH
26675: LD_STRING D10nB-JMM-5
26677: PPUSH
26678: CALL_OW 88
// end ; if JMMGirl = 3 then
26682: LD_EXP 7
26686: PUSH
26687: LD_INT 3
26689: EQUAL
26690: IFFALSE 26716
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26692: LD_EXP 69
26696: PPUSH
26697: LD_STRING D10nB-Vse-5
26699: PPUSH
26700: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26704: LD_EXP 38
26708: PPUSH
26709: LD_STRING D10nB-JMM-6
26711: PPUSH
26712: CALL_OW 88
// end ; end ; DialogueOff ;
26716: CALL_OW 7
// end ;
26720: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26721: LD_EXP 14
26725: PUSH
26726: LD_INT 115500
26728: GREATEREQUAL
26729: IFFALSE 27094
26731: GO 26733
26733: DISABLE
26734: LD_INT 0
26736: PPUSH
// begin missionStage := 10 ;
26737: LD_ADDR_EXP 15
26741: PUSH
26742: LD_INT 10
26744: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26745: LD_ADDR_VAR 0 1
26749: PUSH
26750: LD_INT 22
26752: PUSH
26753: LD_INT 1
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 26
26762: PUSH
26763: LD_INT 1
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: LD_INT 3
26772: PUSH
26773: LD_INT 25
26775: PUSH
26776: LD_INT 12
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: PUSH
26787: LD_INT 3
26789: PUSH
26790: LD_INT 25
26792: PUSH
26793: LD_INT 16
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: PPUSH
26810: CALL_OW 69
26814: PUSH
26815: LD_EXP 38
26819: PUSH
26820: LD_EXP 59
26824: PUSH
26825: LD_EXP 40
26829: PUSH
26830: LD_EXP 54
26834: PUSH
26835: LD_EXP 41
26839: PUSH
26840: LD_EXP 42
26844: PUSH
26845: LD_EXP 43
26849: PUSH
26850: LD_EXP 44
26854: PUSH
26855: LD_EXP 45
26859: PUSH
26860: LD_EXP 46
26864: PUSH
26865: LD_EXP 47
26869: PUSH
26870: LD_EXP 48
26874: PUSH
26875: LD_EXP 49
26879: PUSH
26880: LD_EXP 50
26884: PUSH
26885: LD_EXP 51
26889: PUSH
26890: LD_EXP 52
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: DIFF
26913: ST_TO_ADDR
// if not tmp and Brown then
26914: LD_VAR 0 1
26918: NOT
26919: PUSH
26920: LD_EXP 46
26924: AND
26925: IFFALSE 26940
// tmp := [ Brown ] ;
26927: LD_ADDR_VAR 0 1
26931: PUSH
26932: LD_EXP 46
26936: PUSH
26937: EMPTY
26938: LIST
26939: ST_TO_ADDR
// DialogueOn ;
26940: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26944: LD_VAR 0 1
26948: PUSH
26949: LD_INT 1
26951: ARRAY
26952: PPUSH
26953: LD_STRING D11-Sol1-1
26955: PPUSH
26956: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26960: LD_EXP 63
26964: PPUSH
26965: LD_STRING D11-Pla-1
26967: PPUSH
26968: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26972: LD_EXP 64
26976: PPUSH
26977: LD_STRING D11-Kov-1
26979: PPUSH
26980: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26984: LD_EXP 63
26988: PPUSH
26989: LD_STRING D11-Pla-2
26991: PPUSH
26992: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26996: LD_VAR 0 1
27000: PUSH
27001: LD_INT 1
27003: ARRAY
27004: PPUSH
27005: LD_STRING D11-Sol1-2
27007: PPUSH
27008: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27012: LD_EXP 38
27016: PPUSH
27017: LD_STRING D11-JMM-2
27019: PPUSH
27020: CALL_OW 88
// DialogueOff ;
27024: CALL_OW 7
// allowBehemothConstruct := true ;
27028: LD_ADDR_EXP 25
27032: PUSH
27033: LD_INT 1
27035: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27036: LD_STRING M4
27038: PPUSH
27039: CALL_OW 337
// BuildBehemoths ;
27043: CALL 7644 0 0
// repeat wait ( 15 15$00 ) ;
27047: LD_INT 31500
27049: PPUSH
27050: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27054: LD_EXP 27
27058: IFFALSE 27062
// break ;
27060: GO 27094
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27062: LD_INT 267
27064: PPUSH
27065: CALL_OW 274
27069: PPUSH
27070: LD_INT 1
27072: PPUSH
27073: CALL_OW 275
27077: PUSH
27078: LD_INT 1000
27080: GREATEREQUAL
27081: IFFALSE 27087
// BuildBehemoths ;
27083: CALL 7644 0 0
// until not behemothBuilders ;
27087: LD_EXP 72
27091: NOT
27092: IFFALSE 27047
// end ;
27094: PPOPN 1
27096: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27097: LD_EXP 72
27101: NOT
27102: PUSH
27103: LD_EXP 28
27107: NOT
27108: AND
27109: PUSH
27110: LD_EXP 25
27114: AND
27115: IFFALSE 27135
27117: GO 27119
27119: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27120: LD_STRING M4a
27122: PPUSH
27123: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27127: LD_ADDR_EXP 27
27131: PUSH
27132: LD_INT 1
27134: ST_TO_ADDR
// end ;
27135: END
// every 0 0$1 trigger behemothDone do
27136: LD_EXP 28
27140: IFFALSE 27152
27142: GO 27144
27144: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27145: LD_STRING M4b
27147: PPUSH
27148: CALL_OW 337
27152: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27153: LD_EXP 29
27157: NOT
27158: IFFALSE 27354
27160: GO 27162
27162: DISABLE
27163: LD_INT 0
27165: PPUSH
27166: PPUSH
// begin enable ;
27167: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27168: LD_ADDR_VAR 0 1
27172: PUSH
27173: LD_INT 3
27175: PPUSH
27176: CALL 107280 0 1
27180: ST_TO_ADDR
// if not tmp and not behemothDone then
27181: LD_VAR 0 1
27185: NOT
27186: PUSH
27187: LD_EXP 28
27191: NOT
27192: AND
27193: IFFALSE 27229
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27195: LD_ADDR_VAR 0 1
27199: PUSH
27200: LD_INT 22
27202: PUSH
27203: LD_INT 3
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 30
27212: PUSH
27213: LD_INT 37
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PPUSH
27224: CALL_OW 69
27228: ST_TO_ADDR
// if not tmp then
27229: LD_VAR 0 1
27233: NOT
27234: IFFALSE 27238
// exit ;
27236: GO 27354
// for i in tmp do
27238: LD_ADDR_VAR 0 2
27242: PUSH
27243: LD_VAR 0 1
27247: PUSH
27248: FOR_IN
27249: IFFALSE 27352
// if See ( 1 , i ) then
27251: LD_INT 1
27253: PPUSH
27254: LD_VAR 0 2
27258: PPUSH
27259: CALL_OW 292
27263: IFFALSE 27350
// begin if GetType ( i ) = unit_building then
27265: LD_VAR 0 2
27269: PPUSH
27270: CALL_OW 247
27274: PUSH
27275: LD_INT 3
27277: EQUAL
27278: IFFALSE 27316
// begin CenterNowOnUnits ( i ) ;
27280: LD_VAR 0 2
27284: PPUSH
27285: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27289: LD_EXP 38
27293: PPUSH
27294: LD_STRING D17a-JMM-1
27296: PPUSH
27297: CALL_OW 88
// seeBehemoth := true ;
27301: LD_ADDR_EXP 29
27305: PUSH
27306: LD_INT 1
27308: ST_TO_ADDR
// disable ;
27309: DISABLE
// exit ;
27310: POP
27311: POP
27312: GO 27354
// end else
27314: GO 27350
// begin CenterNowOnUnits ( i ) ;
27316: LD_VAR 0 2
27320: PPUSH
27321: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27325: LD_EXP 38
27329: PPUSH
27330: LD_STRING D17b-JMM-1
27332: PPUSH
27333: CALL_OW 88
// seeBehemoth := true ;
27337: LD_ADDR_EXP 29
27341: PUSH
27342: LD_INT 1
27344: ST_TO_ADDR
// disable ;
27345: DISABLE
// exit ;
27346: POP
27347: POP
27348: GO 27354
// end ; end ;
27350: GO 27248
27352: POP
27353: POP
// end ;
27354: PPOPN 2
27356: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27357: LD_EXP 14
27361: PUSH
27362: LD_INT 116550
27364: GREATEREQUAL
27365: IFFALSE 28541
27367: GO 27369
27369: DISABLE
27370: LD_INT 0
27372: PPUSH
27373: PPUSH
27374: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27375: LD_INT 2
27377: PPUSH
27378: LD_INT 23
27380: PUSH
27381: LD_INT 3
27383: PUSH
27384: LD_INT 3
27386: PUSH
27387: LD_INT 48
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: PUSH
27396: EMPTY
27397: LIST
27398: PPUSH
27399: CALL 58028 0 2
// repeat wait ( 0 0$1 ) ;
27403: LD_INT 35
27405: PPUSH
27406: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27410: LD_INT 22
27412: PUSH
27413: LD_INT 3
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 34
27422: PUSH
27423: LD_INT 48
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PPUSH
27434: CALL_OW 69
27438: IFFALSE 27403
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27440: LD_ADDR_VAR 0 1
27444: PUSH
27445: LD_INT 22
27447: PUSH
27448: LD_INT 3
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 34
27457: PUSH
27458: LD_INT 48
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PPUSH
27469: CALL_OW 69
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: ST_TO_ADDR
// missionStage := 12 ;
27478: LD_ADDR_EXP 15
27482: PUSH
27483: LD_INT 12
27485: ST_TO_ADDR
// platonovHasBomb := true ;
27486: LD_ADDR_EXP 30
27490: PUSH
27491: LD_INT 1
27493: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27494: LD_VAR 0 1
27498: PPUSH
27499: LD_INT 181
27501: PPUSH
27502: LD_INT 86
27504: PPUSH
27505: CALL_OW 171
// AddComHold ( bomb ) ;
27509: LD_VAR 0 1
27513: PPUSH
27514: CALL_OW 200
// wait ( 0 0$10 ) ;
27518: LD_INT 350
27520: PPUSH
27521: CALL_OW 67
// DialogueOn ;
27525: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27529: LD_EXP 63
27533: PPUSH
27534: LD_STRING D15-Pla-1
27536: PPUSH
27537: CALL_OW 94
// dec = Query ( Q15a ) ;
27541: LD_ADDR_VAR 0 2
27545: PUSH
27546: LD_STRING Q15a
27548: PPUSH
27549: CALL_OW 97
27553: ST_TO_ADDR
// if dec = 1 then
27554: LD_VAR 0 2
27558: PUSH
27559: LD_INT 1
27561: EQUAL
27562: IFFALSE 27585
// begin Say ( JMM , D15a-JMM-1 ) ;
27564: LD_EXP 38
27568: PPUSH
27569: LD_STRING D15a-JMM-1
27571: PPUSH
27572: CALL_OW 88
// YouLost ( Surrender ) ;
27576: LD_STRING Surrender
27578: PPUSH
27579: CALL_OW 104
// exit ;
27583: GO 28541
// end ; if dec = 2 then
27585: LD_VAR 0 2
27589: PUSH
27590: LD_INT 2
27592: EQUAL
27593: IFFALSE 27662
// begin Say ( JMM , D15b-JMM-1 ) ;
27595: LD_EXP 38
27599: PPUSH
27600: LD_STRING D15b-JMM-1
27602: PPUSH
27603: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27607: LD_EXP 63
27611: PPUSH
27612: LD_STRING D15b-Pla-1
27614: PPUSH
27615: CALL_OW 94
// DialogueOff ;
27619: CALL_OW 7
// wait ( 3 3$00 ) ;
27623: LD_INT 6300
27625: PPUSH
27626: CALL_OW 67
// DialogueOn ;
27630: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27634: LD_EXP 38
27638: PPUSH
27639: LD_STRING D15d-JMM-1a
27641: PPUSH
27642: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27646: LD_EXP 63
27650: PPUSH
27651: LD_STRING D15d-Pla-1
27653: PPUSH
27654: CALL_OW 94
// DialogueOff ;
27658: CALL_OW 7
// end ; if dec = 3 then
27662: LD_VAR 0 2
27666: PUSH
27667: LD_INT 3
27669: EQUAL
27670: IFFALSE 27724
// begin Say ( JMM , D15c-JMM-1 ) ;
27672: LD_EXP 38
27676: PPUSH
27677: LD_STRING D15c-JMM-1
27679: PPUSH
27680: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27684: LD_EXP 63
27688: PPUSH
27689: LD_STRING D15c-Pla-1
27691: PPUSH
27692: CALL_OW 94
// DialogueOff ;
27696: CALL_OW 7
// wait ( 0 0$15 ) ;
27700: LD_INT 525
27702: PPUSH
27703: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27707: LD_VAR 0 1
27711: PPUSH
27712: LD_INT 60
27714: PPUSH
27715: LD_INT 95
27717: PPUSH
27718: CALL_OW 116
// exit ;
27722: GO 28541
// end ; if dec = 4 then
27724: LD_VAR 0 2
27728: PUSH
27729: LD_INT 4
27731: EQUAL
27732: IFFALSE 27762
// begin Say ( JMM , D15d-JMM-1 ) ;
27734: LD_EXP 38
27738: PPUSH
27739: LD_STRING D15d-JMM-1
27741: PPUSH
27742: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27746: LD_EXP 63
27750: PPUSH
27751: LD_STRING D15d-Pla-1
27753: PPUSH
27754: CALL_OW 94
// DialogueOff ;
27758: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27762: LD_EXP 61
27766: PPUSH
27767: CALL_OW 302
27771: PUSH
27772: LD_EXP 61
27776: PPUSH
27777: CALL_OW 255
27781: PUSH
27782: LD_INT 1
27784: EQUAL
27785: AND
27786: PUSH
27787: LD_INT 22
27789: PUSH
27790: LD_INT 1
27792: PUSH
27793: EMPTY
27794: LIST
27795: LIST
27796: PUSH
27797: LD_INT 34
27799: PUSH
27800: LD_INT 8
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PPUSH
27811: CALL_OW 69
27815: NOT
27816: AND
27817: IFFALSE 28442
// begin SetSide ( Friend , 8 ) ;
27819: LD_EXP 61
27823: PPUSH
27824: LD_INT 8
27826: PPUSH
27827: CALL_OW 235
// if IsInUnit ( Friend ) then
27831: LD_EXP 61
27835: PPUSH
27836: CALL_OW 310
27840: IFFALSE 27851
// ComExitBuilding ( Friend ) ;
27842: LD_EXP 61
27846: PPUSH
27847: CALL_OW 122
// if IsDriver ( Friend ) then
27851: LD_EXP 61
27855: PPUSH
27856: CALL 104957 0 1
27860: IFFALSE 27871
// ComExitVehicle ( Friend ) ;
27862: LD_EXP 61
27866: PPUSH
27867: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27871: LD_EXP 61
27875: PPUSH
27876: LD_INT 9
27878: PPUSH
27879: LD_INT 2
27881: PPUSH
27882: CALL_OW 171
// wait ( 0 0$05 ) ;
27886: LD_INT 175
27888: PPUSH
27889: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27893: LD_EXP 61
27897: PPUSH
27898: CALL_OW 87
// DialogueOn ;
27902: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27906: LD_EXP 38
27910: PPUSH
27911: LD_STRING D16-JMM-1
27913: PPUSH
27914: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27918: LD_EXP 61
27922: PPUSH
27923: LD_STRING D16-Friend-1
27925: PPUSH
27926: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27930: LD_EXP 38
27934: PPUSH
27935: LD_STRING D16-JMM-2
27937: PPUSH
27938: CALL_OW 88
// DialogueOff ;
27942: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27946: LD_EXP 61
27950: PPUSH
27951: LD_INT 1
27953: PPUSH
27954: CALL_OW 235
// ComHold ( Friend ) ;
27958: LD_EXP 61
27962: PPUSH
27963: CALL_OW 140
// wait ( 0 0$20 ) ;
27967: LD_INT 700
27969: PPUSH
27970: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27974: LD_EXP 61
27978: PPUSH
27979: LD_INT 9
27981: PPUSH
27982: LD_INT 2
27984: PPUSH
27985: CALL_OW 297
27989: PUSH
27990: LD_INT 30
27992: LESS
27993: IFFALSE 28062
// begin SetSide ( Friend , 8 ) ;
27995: LD_EXP 61
27999: PPUSH
28000: LD_INT 8
28002: PPUSH
28003: CALL_OW 235
// if IsInUnit ( Friend ) then
28007: LD_EXP 61
28011: PPUSH
28012: CALL_OW 310
28016: IFFALSE 28027
// ComExitBuilding ( Friend ) ;
28018: LD_EXP 61
28022: PPUSH
28023: CALL_OW 122
// if IsDriver ( Friend ) then
28027: LD_EXP 61
28031: PPUSH
28032: CALL 104957 0 1
28036: IFFALSE 28047
// ComExitVehicle ( Friend ) ;
28038: LD_EXP 61
28042: PPUSH
28043: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28047: LD_EXP 61
28051: PPUSH
28052: LD_INT 9
28054: PPUSH
28055: LD_INT 2
28057: PPUSH
28058: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28062: LD_INT 1050
28064: PPUSH
28065: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28069: LD_INT 22
28071: PUSH
28072: LD_INT 1
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 34
28081: PUSH
28082: LD_INT 8
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PPUSH
28093: CALL_OW 69
28097: NOT
28098: IFFALSE 28420
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28100: LD_ADDR_VAR 0 3
28104: PUSH
28105: LD_INT 22
28107: PUSH
28108: LD_INT 1
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PUSH
28115: LD_INT 26
28117: PUSH
28118: LD_INT 1
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 3
28127: PUSH
28128: LD_INT 25
28130: PUSH
28131: LD_INT 12
28133: PUSH
28134: EMPTY
28135: LIST
28136: LIST
28137: PUSH
28138: LD_INT 25
28140: PUSH
28141: LD_INT 16
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: LIST
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: LIST
28157: PPUSH
28158: CALL_OW 69
28162: PUSH
28163: LD_EXP 38
28167: PUSH
28168: LD_EXP 40
28172: PUSH
28173: LD_EXP 54
28177: PUSH
28178: LD_EXP 41
28182: PUSH
28183: LD_EXP 42
28187: PUSH
28188: LD_EXP 43
28192: PUSH
28193: LD_EXP 44
28197: PUSH
28198: LD_EXP 45
28202: PUSH
28203: LD_EXP 46
28207: PUSH
28208: LD_EXP 47
28212: PUSH
28213: LD_EXP 48
28217: PUSH
28218: LD_EXP 49
28222: PUSH
28223: LD_EXP 50
28227: PUSH
28228: LD_EXP 51
28232: PUSH
28233: LD_EXP 52
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: DIFF
28255: ST_TO_ADDR
// DialogueOn ;
28256: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28260: LD_EXP 63
28264: PPUSH
28265: LD_STRING D16a-Pla-1
28267: PPUSH
28268: CALL_OW 94
// if Stevens then
28272: LD_EXP 40
28276: IFFALSE 28292
// Say ( Stevens , D16a-Huck-1 ) else
28278: LD_EXP 40
28282: PPUSH
28283: LD_STRING D16a-Huck-1
28285: PPUSH
28286: CALL_OW 88
28290: GO 28334
// if Baker then
28292: LD_EXP 54
28296: IFFALSE 28312
// Say ( Baker , D16a-Huck-1 ) else
28298: LD_EXP 54
28302: PPUSH
28303: LD_STRING D16a-Huck-1
28305: PPUSH
28306: CALL_OW 88
28310: GO 28334
// if tmp then
28312: LD_VAR 0 3
28316: IFFALSE 28334
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28318: LD_VAR 0 3
28322: PUSH
28323: LD_INT 1
28325: ARRAY
28326: PPUSH
28327: LD_STRING D16a-Sol1-1
28329: PPUSH
28330: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28334: LD_EXP 61
28338: PPUSH
28339: CALL_OW 255
28343: PUSH
28344: LD_INT 8
28346: EQUAL
28347: IFFALSE 28363
// Say ( JMM , D16a-JMM-1 ) else
28349: LD_EXP 38
28353: PPUSH
28354: LD_STRING D16a-JMM-1
28356: PPUSH
28357: CALL_OW 88
28361: GO 28399
// begin Say ( JMM , D16a-JMM-1a ) ;
28363: LD_EXP 38
28367: PPUSH
28368: LD_STRING D16a-JMM-1a
28370: PPUSH
28371: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28375: LD_EXP 61
28379: PPUSH
28380: LD_STRING D16a-Friend-1
28382: PPUSH
28383: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28387: LD_EXP 61
28391: PPUSH
28392: LD_INT 3
28394: PPUSH
28395: CALL_OW 235
// end ; DialogueOff ;
28399: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28403: LD_VAR 0 1
28407: PPUSH
28408: LD_INT 60
28410: PPUSH
28411: LD_INT 95
28413: PPUSH
28414: CALL_OW 116
// end else
28418: GO 28440
// begin DialogueOn ;
28420: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28424: LD_EXP 63
28428: PPUSH
28429: LD_STRING D16c-Pla-
28431: PPUSH
28432: CALL_OW 94
// DialogueOff ;
28436: CALL_OW 7
// end ; end else
28440: GO 28541
// begin wait ( 3 3$00 ) ;
28442: LD_INT 6300
28444: PPUSH
28445: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28449: LD_INT 22
28451: PUSH
28452: LD_INT 1
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: LD_INT 34
28461: PUSH
28462: LD_INT 8
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PPUSH
28473: CALL_OW 69
28477: NOT
28478: IFFALSE 28521
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28480: LD_EXP 63
28484: PPUSH
28485: LD_STRING D16b-Pla-1
28487: PPUSH
28488: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28492: LD_EXP 38
28496: PPUSH
28497: LD_STRING D16b-JMM-
28499: PPUSH
28500: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28504: LD_VAR 0 1
28508: PPUSH
28509: LD_INT 60
28511: PPUSH
28512: LD_INT 95
28514: PPUSH
28515: CALL_OW 116
// end else
28519: GO 28541
// begin DialogueOn ;
28521: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28525: LD_EXP 63
28529: PPUSH
28530: LD_STRING D16c-Pla-
28532: PPUSH
28533: CALL_OW 94
// DialogueOff ;
28537: CALL_OW 7
// end ; end ; end ;
28541: PPOPN 3
28543: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28544: LD_EXP 14
28548: PUSH
28549: LD_INT 126000
28551: GREATEREQUAL
28552: PUSH
28553: LD_EXP 23
28557: NOT
28558: AND
28559: PUSH
28560: LD_EXP 73
28564: PPUSH
28565: CALL_OW 302
28569: AND
28570: IFFALSE 28928
28572: GO 28574
28574: DISABLE
28575: LD_INT 0
28577: PPUSH
// begin missionStage = 11 ;
28578: LD_ADDR_EXP 15
28582: PUSH
28583: LD_INT 11
28585: ST_TO_ADDR
// DialogueOn ;
28586: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28590: LD_EXP 73
28594: PPUSH
28595: LD_STRING D9-Roth-1
28597: PPUSH
28598: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28602: LD_EXP 38
28606: PPUSH
28607: LD_STRING D9-JMM-1
28609: PPUSH
28610: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28614: LD_EXP 73
28618: PPUSH
28619: LD_STRING D9-Roth-2
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28626: LD_EXP 73
28630: PPUSH
28631: LD_STRING D9-Roth-2a
28633: PPUSH
28634: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28638: LD_EXP 63
28642: PPUSH
28643: LD_STRING D9-Pla-2
28645: PPUSH
28646: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28650: LD_EXP 73
28654: PPUSH
28655: LD_STRING D9-Roth-3
28657: PPUSH
28658: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28662: LD_EXP 63
28666: PPUSH
28667: LD_STRING D9-Pla-3
28669: PPUSH
28670: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28674: LD_EXP 73
28678: PPUSH
28679: LD_STRING D9-Roth-4
28681: PPUSH
28682: CALL_OW 94
// dec = Query ( Q9 ) ;
28686: LD_ADDR_VAR 0 1
28690: PUSH
28691: LD_STRING Q9
28693: PPUSH
28694: CALL_OW 97
28698: ST_TO_ADDR
// if dec = 1 then
28699: LD_VAR 0 1
28703: PUSH
28704: LD_INT 1
28706: EQUAL
28707: IFFALSE 28721
// SayRadio ( Roth , D9a-Roth-1 ) ;
28709: LD_EXP 73
28713: PPUSH
28714: LD_STRING D9a-Roth-1
28716: PPUSH
28717: CALL_OW 94
// if dec = 2 then
28721: LD_VAR 0 1
28725: PUSH
28726: LD_INT 2
28728: EQUAL
28729: IFFALSE 28755
// begin Say ( JMM , D9b-JMM-1 ) ;
28731: LD_EXP 38
28735: PPUSH
28736: LD_STRING D9b-JMM-1
28738: PPUSH
28739: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28743: LD_EXP 73
28747: PPUSH
28748: LD_STRING D9b-Roth-1
28750: PPUSH
28751: CALL_OW 94
// end ; if dec = 3 then
28755: LD_VAR 0 1
28759: PUSH
28760: LD_INT 3
28762: EQUAL
28763: IFFALSE 28825
// begin Say ( JMM , D9c-JMM-1 ) ;
28765: LD_EXP 38
28769: PPUSH
28770: LD_STRING D9c-JMM-1
28772: PPUSH
28773: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28777: LD_EXP 73
28781: PPUSH
28782: LD_STRING D9c-Roth-1
28784: PPUSH
28785: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28789: LD_EXP 38
28793: PPUSH
28794: LD_STRING D9c-JMM-2
28796: PPUSH
28797: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28801: LD_EXP 73
28805: PPUSH
28806: LD_STRING D9c-Roth-2
28808: PPUSH
28809: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28813: LD_EXP 38
28817: PPUSH
28818: LD_STRING D9c-JMM-3
28820: PPUSH
28821: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28825: LD_EXP 73
28829: PPUSH
28830: LD_STRING D9c-Roth-3
28832: PPUSH
28833: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28837: LD_EXP 73
28841: PPUSH
28842: LD_STRING D9cont-Roth-1
28844: PPUSH
28845: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28849: LD_EXP 38
28853: PPUSH
28854: LD_STRING D9cont-JMM-1
28856: PPUSH
28857: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28861: LD_EXP 73
28865: PPUSH
28866: LD_STRING D9cont-Roth-2
28868: PPUSH
28869: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28873: LD_EXP 38
28877: PPUSH
28878: LD_STRING D9cont-JMM-2
28880: PPUSH
28881: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28885: LD_EXP 73
28889: PPUSH
28890: LD_STRING D9cont-Roth-3
28892: PPUSH
28893: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28897: LD_EXP 38
28901: PPUSH
28902: LD_STRING D9cont-JMM-3
28904: PPUSH
28905: CALL_OW 88
// DialogueOff ;
28909: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28913: LD_STRING M3
28915: PPUSH
28916: CALL_OW 337
// allianceActive := true ;
28920: LD_ADDR_EXP 31
28924: PUSH
28925: LD_INT 1
28927: ST_TO_ADDR
// end ;
28928: PPOPN 1
28930: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28931: LD_EXP 63
28935: PPUSH
28936: CALL_OW 301
28940: PUSH
28941: LD_EXP 66
28945: PPUSH
28946: CALL_OW 301
28950: AND
28951: PUSH
28952: LD_INT 22
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 21
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 50
28974: PUSH
28975: EMPTY
28976: LIST
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: LIST
28982: PPUSH
28983: CALL_OW 69
28987: PUSH
28988: LD_INT 7
28990: PUSH
28991: LD_INT 8
28993: PUSH
28994: LD_INT 9
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: LIST
29001: PUSH
29002: LD_OWVAR 67
29006: ARRAY
29007: LESS
29008: AND
29009: IFFALSE 29780
29011: GO 29013
29013: DISABLE
29014: LD_INT 0
29016: PPUSH
29017: PPUSH
29018: PPUSH
29019: PPUSH
// begin MC_Kill ( 1 ) ;
29020: LD_INT 1
29022: PPUSH
29023: CALL 34464 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29027: LD_INT 1
29029: PPUSH
29030: LD_INT 3
29032: PPUSH
29033: LD_INT 1
29035: PPUSH
29036: LD_INT 1
29038: PPUSH
29039: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29043: LD_ADDR_VAR 0 1
29047: PUSH
29048: LD_INT 22
29050: PUSH
29051: LD_INT 3
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 21
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 24
29070: PUSH
29071: LD_INT 900
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: LIST
29082: PPUSH
29083: CALL_OW 69
29087: PUSH
29088: FOR_IN
29089: IFFALSE 29120
// if GetSex ( i ) = sex_male then
29091: LD_VAR 0 1
29095: PPUSH
29096: CALL_OW 258
29100: PUSH
29101: LD_INT 1
29103: EQUAL
29104: IFFALSE 29118
// begin tmp = i ;
29106: LD_ADDR_VAR 0 2
29110: PUSH
29111: LD_VAR 0 1
29115: ST_TO_ADDR
// break ;
29116: GO 29120
// end ;
29118: GO 29088
29120: POP
29121: POP
// if tmp = 0 then
29122: LD_VAR 0 2
29126: PUSH
29127: LD_INT 0
29129: EQUAL
29130: IFFALSE 29184
// begin uc_side = 3 ;
29132: LD_ADDR_OWVAR 20
29136: PUSH
29137: LD_INT 3
29139: ST_TO_ADDR
// uc_nation = 3 ;
29140: LD_ADDR_OWVAR 21
29144: PUSH
29145: LD_INT 3
29147: ST_TO_ADDR
// hc_name =  ;
29148: LD_ADDR_OWVAR 26
29152: PUSH
29153: LD_STRING 
29155: ST_TO_ADDR
// hc_gallery =  ;
29156: LD_ADDR_OWVAR 33
29160: PUSH
29161: LD_STRING 
29163: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29164: LD_INT 1
29166: PPUSH
29167: LD_INT 10
29169: PPUSH
29170: CALL_OW 381
// tmp = CreateHuman ;
29174: LD_ADDR_VAR 0 2
29178: PUSH
29179: CALL_OW 44
29183: ST_TO_ADDR
// end ; DialogueOn ;
29184: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29188: LD_VAR 0 2
29192: PPUSH
29193: LD_STRING DSurrenderRussians-RSol1-1a
29195: PPUSH
29196: CALL_OW 94
// DialogueOff ;
29200: CALL_OW 7
// russianDestroyed := true ;
29204: LD_ADDR_EXP 21
29208: PUSH
29209: LD_INT 1
29211: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29212: LD_INT 22
29214: PUSH
29215: LD_INT 3
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 21
29224: PUSH
29225: LD_INT 1
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PPUSH
29236: CALL_OW 69
29240: PPUSH
29241: CALL_OW 122
// wait ( 0 0$1 ) ;
29245: LD_INT 35
29247: PPUSH
29248: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29252: LD_INT 22
29254: PUSH
29255: LD_INT 3
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 21
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PPUSH
29276: CALL_OW 69
29280: PPUSH
29281: LD_INT 25
29283: PPUSH
29284: CALL_OW 173
// wait ( 0 0$10 ) ;
29288: LD_INT 350
29290: PPUSH
29291: CALL_OW 67
// PrepareOmarInvasion ;
29295: CALL 13777 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29299: LD_ADDR_VAR 0 2
29303: PUSH
29304: LD_EXP 91
29308: PPUSH
29309: CALL_OW 250
29313: PUSH
29314: LD_EXP 91
29318: PPUSH
29319: CALL_OW 251
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29328: LD_VAR 0 2
29332: PUSH
29333: LD_INT 1
29335: ARRAY
29336: PPUSH
29337: LD_VAR 0 2
29341: PUSH
29342: LD_INT 2
29344: ARRAY
29345: PPUSH
29346: LD_INT 1
29348: PPUSH
29349: LD_INT 8
29351: NEG
29352: PPUSH
29353: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29357: LD_EXP 91
29361: PPUSH
29362: CALL_OW 87
// DialogueOn ;
29366: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29370: LD_EXP 38
29374: PPUSH
29375: LD_STRING D19-JMM-1
29377: PPUSH
29378: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29382: LD_ADDR_VAR 0 3
29386: PUSH
29387: LD_INT 22
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 26
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 2
29409: PUSH
29410: LD_INT 25
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 25
29422: PUSH
29423: LD_INT 2
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 25
29432: PUSH
29433: LD_INT 3
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 25
29442: PUSH
29443: LD_INT 4
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 25
29452: PUSH
29453: LD_INT 5
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PUSH
29460: LD_INT 25
29462: PUSH
29463: LD_INT 8
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: PUSH
29479: EMPTY
29480: LIST
29481: LIST
29482: LIST
29483: PPUSH
29484: CALL_OW 69
29488: PUSH
29489: LD_EXP 38
29493: PUSH
29494: LD_EXP 39
29498: PUSH
29499: LD_EXP 40
29503: PUSH
29504: LD_EXP 41
29508: PUSH
29509: LD_EXP 42
29513: PUSH
29514: LD_EXP 43
29518: PUSH
29519: LD_EXP 44
29523: PUSH
29524: LD_EXP 45
29528: PUSH
29529: LD_EXP 46
29533: PUSH
29534: LD_EXP 47
29538: PUSH
29539: LD_EXP 48
29543: PUSH
29544: LD_EXP 49
29548: PUSH
29549: LD_EXP 50
29553: PUSH
29554: LD_EXP 51
29558: PUSH
29559: LD_EXP 52
29563: PUSH
29564: LD_EXP 53
29568: PUSH
29569: LD_EXP 54
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: LIST
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: DIFF
29593: ST_TO_ADDR
// if tmp2 then
29594: LD_VAR 0 3
29598: IFFALSE 29616
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29600: LD_VAR 0 3
29604: PUSH
29605: LD_INT 1
29607: ARRAY
29608: PPUSH
29609: LD_STRING D19-Sol1-1
29611: PPUSH
29612: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29616: LD_EXP 38
29620: PPUSH
29621: LD_STRING D19-JMM-2
29623: PPUSH
29624: CALL_OW 88
// DialogueOff ;
29628: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29632: LD_VAR 0 2
29636: PUSH
29637: LD_INT 1
29639: ARRAY
29640: PPUSH
29641: LD_VAR 0 2
29645: PUSH
29646: LD_INT 2
29648: ARRAY
29649: PPUSH
29650: LD_INT 1
29652: PPUSH
29653: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29657: LD_STRING M5
29659: PPUSH
29660: CALL_OW 337
// omarOnMotherLode := false ;
29664: LD_ADDR_VAR 0 4
29668: PUSH
29669: LD_INT 0
29671: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29672: LD_INT 35
29674: PPUSH
29675: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29679: LD_EXP 91
29683: PPUSH
29684: LD_INT 215
29686: PPUSH
29687: LD_INT 100
29689: PPUSH
29690: CALL_OW 297
29694: PUSH
29695: LD_INT 10
29697: LESS
29698: PUSH
29699: LD_VAR 0 4
29703: NOT
29704: AND
29705: IFFALSE 29739
// begin omarOnMotherLode := true ;
29707: LD_ADDR_VAR 0 4
29711: PUSH
29712: LD_INT 1
29714: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29715: LD_EXP 38
29719: PPUSH
29720: LD_STRING D19b-JMM-1
29722: PPUSH
29723: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29727: LD_EXP 91
29731: PPUSH
29732: LD_STRING DOmarContam-Omar-1
29734: PPUSH
29735: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29739: LD_EXP 91
29743: PPUSH
29744: CALL_OW 301
29748: IFFALSE 29672
// Say ( JMM , D19a-JMM-1 ) ;
29750: LD_EXP 38
29754: PPUSH
29755: LD_STRING D19a-JMM-1
29757: PPUSH
29758: CALL_OW 88
// if Heike then
29762: LD_EXP 92
29766: IFFALSE 29780
// Say ( Heike , D19a-Hke-1 ) ;
29768: LD_EXP 92
29772: PPUSH
29773: LD_STRING D19a-Hke-1
29775: PPUSH
29776: CALL_OW 88
// end ;
29780: PPOPN 4
29782: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29783: LD_INT 22
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: LD_INT 21
29795: PUSH
29796: LD_INT 1
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PPUSH
29807: CALL_OW 69
29811: PUSH
29812: LD_EXP 21
29816: AND
29817: IFFALSE 29885
29819: GO 29821
29821: DISABLE
29822: LD_INT 0
29824: PPUSH
29825: PPUSH
// begin enable ;
29826: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29827: LD_ADDR_VAR 0 2
29831: PUSH
29832: LD_INT 25
29834: PPUSH
29835: LD_INT 22
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PPUSH
29845: CALL_OW 70
29849: ST_TO_ADDR
// if not tmp then
29850: LD_VAR 0 2
29854: NOT
29855: IFFALSE 29859
// exit ;
29857: GO 29885
// for i in tmp do
29859: LD_ADDR_VAR 0 1
29863: PUSH
29864: LD_VAR 0 2
29868: PUSH
29869: FOR_IN
29870: IFFALSE 29883
// RemoveUnit ( i ) ;
29872: LD_VAR 0 1
29876: PPUSH
29877: CALL_OW 64
29881: GO 29869
29883: POP
29884: POP
// end ;
29885: PPOPN 2
29887: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29888: LD_INT 22
29890: PUSH
29891: LD_INT 7
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 21
29900: PUSH
29901: LD_INT 1
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PPUSH
29912: CALL_OW 69
29916: PUSH
29917: LD_INT 6
29919: LESS
29920: IFFALSE 30371
29922: GO 29924
29924: DISABLE
29925: LD_INT 0
29927: PPUSH
29928: PPUSH
// begin MC_Kill ( 1 ) ;
29929: LD_INT 1
29931: PPUSH
29932: CALL 34464 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29936: LD_INT 7
29938: PPUSH
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 1
29944: PPUSH
29945: LD_INT 1
29947: PPUSH
29948: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29952: LD_ADDR_VAR 0 1
29956: PUSH
29957: LD_INT 22
29959: PUSH
29960: LD_INT 7
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 26
29969: PUSH
29970: LD_INT 1
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: EMPTY
29978: LIST
29979: LIST
29980: PPUSH
29981: CALL_OW 69
29985: PUSH
29986: LD_EXP 73
29990: DIFF
29991: ST_TO_ADDR
// if tmp then
29992: LD_VAR 0 1
29996: IFFALSE 30014
// tmp := tmp [ 1 ] else
29998: LD_ADDR_VAR 0 1
30002: PUSH
30003: LD_VAR 0 1
30007: PUSH
30008: LD_INT 1
30010: ARRAY
30011: ST_TO_ADDR
30012: GO 30050
// begin uc_side := 7 ;
30014: LD_ADDR_OWVAR 20
30018: PUSH
30019: LD_INT 7
30021: ST_TO_ADDR
// uc_nation := 1 ;
30022: LD_ADDR_OWVAR 21
30026: PUSH
30027: LD_INT 1
30029: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30030: LD_INT 1
30032: PPUSH
30033: LD_INT 8
30035: PPUSH
30036: CALL_OW 384
// tmp := CreateHuman ;
30040: LD_ADDR_VAR 0 1
30044: PUSH
30045: CALL_OW 44
30049: ST_TO_ADDR
// end ; DialogueOn ;
30050: CALL_OW 6
// if IsOK ( Roth ) then
30054: LD_EXP 73
30058: PPUSH
30059: CALL_OW 302
30063: IFFALSE 30077
// Say ( JMM , DAb-JMM-1 ) ;
30065: LD_EXP 38
30069: PPUSH
30070: LD_STRING DAb-JMM-1
30072: PPUSH
30073: CALL_OW 88
// if IsOK ( Roth ) then
30077: LD_EXP 73
30081: PPUSH
30082: CALL_OW 302
30086: IFFALSE 30110
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30088: LD_EXP 73
30092: PPUSH
30093: LD_STRING DSurrenderAlliance-Roth-1
30095: PPUSH
30096: CALL_OW 88
// RothCaptured := true ;
30100: LD_ADDR_EXP 33
30104: PUSH
30105: LD_INT 1
30107: ST_TO_ADDR
// end else
30108: GO 30122
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30110: LD_VAR 0 1
30114: PPUSH
30115: LD_STRING DSurrenderAlliance-Sci1-1
30117: PPUSH
30118: CALL_OW 88
// DialogueOff ;
30122: CALL_OW 7
// allianceDestroyed := true ;
30126: LD_ADDR_EXP 23
30130: PUSH
30131: LD_INT 1
30133: ST_TO_ADDR
// if trueAmericans then
30134: LD_EXP 35
30138: IFFALSE 30214
// begin if trueAmericans = 1 then
30140: LD_EXP 35
30144: PUSH
30145: LD_INT 1
30147: EQUAL
30148: IFFALSE 30164
// Say ( JMM , DAb-JMM-1a ) else
30150: LD_EXP 38
30154: PPUSH
30155: LD_STRING DAb-JMM-1a
30157: PPUSH
30158: CALL_OW 88
30162: GO 30176
// Say ( JMM , DAb-JMM-1b ) ;
30164: LD_EXP 38
30168: PPUSH
30169: LD_STRING DAb-JMM-1b
30171: PPUSH
30172: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30176: LD_EXP 35
30180: PPUSH
30181: CALL_OW 87
// for i in trueAmericans do
30185: LD_ADDR_VAR 0 2
30189: PUSH
30190: LD_EXP 35
30194: PUSH
30195: FOR_IN
30196: IFFALSE 30212
// SetSide ( i , 1 ) ;
30198: LD_VAR 0 2
30202: PPUSH
30203: LD_INT 1
30205: PPUSH
30206: CALL_OW 235
30210: GO 30195
30212: POP
30213: POP
// end ; repeat wait ( 0 0$1 ) ;
30214: LD_INT 35
30216: PPUSH
30217: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30221: LD_ADDR_VAR 0 2
30225: PUSH
30226: LD_INT 22
30228: PUSH
30229: LD_INT 7
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 21
30238: PUSH
30239: LD_INT 1
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PPUSH
30250: CALL_OW 69
30254: PUSH
30255: FOR_IN
30256: IFFALSE 30338
// begin if IsInUnit ( i ) then
30258: LD_VAR 0 2
30262: PPUSH
30263: CALL_OW 310
30267: IFFALSE 30278
// ComExitBuilding ( i ) ;
30269: LD_VAR 0 2
30273: PPUSH
30274: CALL_OW 122
// if IsDriver ( i ) then
30278: LD_VAR 0 2
30282: PPUSH
30283: CALL 104957 0 1
30287: IFFALSE 30298
// ComExitVehicle ( i ) ;
30289: LD_VAR 0 2
30293: PPUSH
30294: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30298: LD_VAR 0 2
30302: PPUSH
30303: LD_INT 26
30305: PPUSH
30306: CALL_OW 308
30310: NOT
30311: IFFALSE 30327
// AddComMoveToArea ( i , allianceEscapeArea ) else
30313: LD_VAR 0 2
30317: PPUSH
30318: LD_INT 26
30320: PPUSH
30321: CALL_OW 173
30325: GO 30336
// RemoveUnit ( i ) ;
30327: LD_VAR 0 2
30331: PPUSH
30332: CALL_OW 64
// end ;
30336: GO 30255
30338: POP
30339: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30340: LD_INT 22
30342: PUSH
30343: LD_INT 7
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 21
30352: PUSH
30353: LD_INT 1
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PPUSH
30364: CALL_OW 69
30368: NOT
30369: IFFALSE 30214
// end ;
30371: PPOPN 2
30373: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30374: LD_INT 0
30376: PPUSH
30377: PPUSH
// if not unit then
30378: LD_VAR 0 1
30382: NOT
30383: IFFALSE 30387
// exit ;
30385: GO 31885
// DoNotAttack ( 7 , unit ) ;
30387: LD_INT 7
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30399: LD_VAR 0 1
30403: PPUSH
30404: LD_INT 260
30406: PPUSH
30407: LD_INT 235
30409: PPUSH
30410: LD_INT 3
30412: PPUSH
30413: LD_INT 1
30415: PPUSH
30416: CALL_OW 483
// SetSide ( unit , 4 ) ;
30420: LD_VAR 0 1
30424: PPUSH
30425: LD_INT 4
30427: PPUSH
30428: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30432: LD_ADDR_EXP 34
30436: PUSH
30437: LD_EXP 34
30441: PUSH
30442: LD_INT 1
30444: PLUS
30445: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30446: LD_INT 70
30448: PPUSH
30449: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30453: LD_INT 260
30455: PPUSH
30456: LD_INT 235
30458: PPUSH
30459: LD_INT 1
30461: PPUSH
30462: LD_INT 8
30464: NEG
30465: PPUSH
30466: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30470: LD_VAR 0 1
30474: PPUSH
30475: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30479: LD_VAR 0 1
30483: PPUSH
30484: LD_EXP 73
30488: PPUSH
30489: CALL_OW 119
// DialogueOn ;
30493: CALL_OW 6
// case unit of JMM :
30497: LD_VAR 0 1
30501: PUSH
30502: LD_EXP 38
30506: DOUBLE
30507: EQUAL
30508: IFTRUE 30512
30510: GO 30527
30512: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30513: LD_EXP 38
30517: PPUSH
30518: LD_STRING DA1-JMM-1
30520: PPUSH
30521: CALL_OW 91
30525: GO 30969
30527: LD_EXP 39
30531: DOUBLE
30532: EQUAL
30533: IFTRUE 30537
30535: GO 30552
30537: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30538: LD_EXP 39
30542: PPUSH
30543: LD_STRING DA1-Joan-1
30545: PPUSH
30546: CALL_OW 91
30550: GO 30969
30552: LD_EXP 41
30556: DOUBLE
30557: EQUAL
30558: IFTRUE 30562
30560: GO 30577
30562: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30563: LD_EXP 41
30567: PPUSH
30568: LD_STRING DA1-Lisa-1
30570: PPUSH
30571: CALL_OW 91
30575: GO 30969
30577: LD_EXP 42
30581: DOUBLE
30582: EQUAL
30583: IFTRUE 30587
30585: GO 30602
30587: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30588: LD_EXP 42
30592: PPUSH
30593: LD_STRING DA1-Don-1
30595: PPUSH
30596: CALL_OW 91
30600: GO 30969
30602: LD_EXP 49
30606: DOUBLE
30607: EQUAL
30608: IFTRUE 30612
30610: GO 30627
30612: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30613: LD_EXP 49
30617: PPUSH
30618: LD_STRING DA1-Corn-1
30620: PPUSH
30621: CALL_OW 91
30625: GO 30969
30627: LD_EXP 45
30631: DOUBLE
30632: EQUAL
30633: IFTRUE 30637
30635: GO 30652
30637: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30638: LD_EXP 45
30642: PPUSH
30643: LD_STRING DA1-Den-1
30645: PPUSH
30646: CALL_OW 91
30650: GO 30969
30652: LD_EXP 43
30656: DOUBLE
30657: EQUAL
30658: IFTRUE 30662
30660: GO 30677
30662: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30663: LD_EXP 43
30667: PPUSH
30668: LD_STRING DA1-Bobby-1
30670: PPUSH
30671: CALL_OW 91
30675: GO 30969
30677: LD_EXP 47
30681: DOUBLE
30682: EQUAL
30683: IFTRUE 30687
30685: GO 30702
30687: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30688: LD_EXP 47
30692: PPUSH
30693: LD_STRING DA1-Glad-1
30695: PPUSH
30696: CALL_OW 91
30700: GO 30969
30702: LD_EXP 44
30706: DOUBLE
30707: EQUAL
30708: IFTRUE 30712
30710: GO 30727
30712: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30713: LD_EXP 44
30717: PPUSH
30718: LD_STRING DA1-Cyrus-1
30720: PPUSH
30721: CALL_OW 91
30725: GO 30969
30727: LD_EXP 40
30731: DOUBLE
30732: EQUAL
30733: IFTRUE 30737
30735: GO 30752
30737: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30738: LD_EXP 40
30742: PPUSH
30743: LD_STRING DA1-Huck-1
30745: PPUSH
30746: CALL_OW 91
30750: GO 30969
30752: LD_EXP 54
30756: DOUBLE
30757: EQUAL
30758: IFTRUE 30762
30760: GO 30777
30762: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30763: LD_EXP 54
30767: PPUSH
30768: LD_STRING DA1-Huck-1
30770: PPUSH
30771: CALL_OW 91
30775: GO 30969
30777: LD_EXP 46
30781: DOUBLE
30782: EQUAL
30783: IFTRUE 30787
30785: GO 30802
30787: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30788: LD_EXP 46
30792: PPUSH
30793: LD_STRING DA1-Brown-1
30795: PPUSH
30796: CALL_OW 91
30800: GO 30969
30802: LD_EXP 50
30806: DOUBLE
30807: EQUAL
30808: IFTRUE 30812
30810: GO 30827
30812: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30813: LD_EXP 50
30817: PPUSH
30818: LD_STRING DA1-Gary-1
30820: PPUSH
30821: CALL_OW 91
30825: GO 30969
30827: LD_EXP 53
30831: DOUBLE
30832: EQUAL
30833: IFTRUE 30837
30835: GO 30852
30837: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30838: LD_EXP 53
30842: PPUSH
30843: LD_STRING DA1-Con-1
30845: PPUSH
30846: CALL_OW 91
30850: GO 30969
30852: LD_EXP 59
30856: DOUBLE
30857: EQUAL
30858: IFTRUE 30862
30860: GO 30877
30862: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30863: LD_EXP 59
30867: PPUSH
30868: LD_STRING DA1-Kurt-1
30870: PPUSH
30871: CALL_OW 91
30875: GO 30969
30877: LD_EXP 52
30881: DOUBLE
30882: EQUAL
30883: IFTRUE 30887
30885: GO 30902
30887: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30888: LD_EXP 52
30892: PPUSH
30893: LD_STRING DA1-Yam-1
30895: PPUSH
30896: CALL_OW 91
30900: GO 30969
30902: LD_EXP 51
30906: DOUBLE
30907: EQUAL
30908: IFTRUE 30912
30910: GO 30927
30912: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30913: LD_EXP 51
30917: PPUSH
30918: LD_STRING DA1-Frank-1
30920: PPUSH
30921: CALL_OW 91
30925: GO 30969
30927: POP
// begin if GetSex ( unit ) = sex_male then
30928: LD_VAR 0 1
30932: PPUSH
30933: CALL_OW 258
30937: PUSH
30938: LD_INT 1
30940: EQUAL
30941: IFFALSE 30957
// ForceSay ( unit , DA1-Sol1-1 ) else
30943: LD_VAR 0 1
30947: PPUSH
30948: LD_STRING DA1-Sol1-1
30950: PPUSH
30951: CALL_OW 91
30955: GO 30969
// ForceSay ( unit , DA1-FSol1-1 ) ;
30957: LD_VAR 0 1
30961: PPUSH
30962: LD_STRING DA1-FSol1-1
30964: PPUSH
30965: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30969: LD_EXP 73
30973: PPUSH
30974: LD_STRING DA-Roth-1
30976: PPUSH
30977: CALL_OW 88
// if capturedUnit = 1 then
30981: LD_EXP 34
30985: PUSH
30986: LD_INT 1
30988: EQUAL
30989: IFFALSE 31017
// begin Say ( Simms , DA-Sim-1 ) ;
30991: LD_EXP 74
30995: PPUSH
30996: LD_STRING DA-Sim-1
30998: PPUSH
30999: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31003: LD_EXP 73
31007: PPUSH
31008: LD_STRING DA-Roth-2
31010: PPUSH
31011: CALL_OW 88
// end else
31015: GO 31029
// Say ( Simms , DA-Sim-2 ) ;
31017: LD_EXP 74
31021: PPUSH
31022: LD_STRING DA-Sim-2
31024: PPUSH
31025: CALL_OW 88
// case unit of JMM :
31029: LD_VAR 0 1
31033: PUSH
31034: LD_EXP 38
31038: DOUBLE
31039: EQUAL
31040: IFTRUE 31044
31042: GO 31059
31044: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31045: LD_EXP 38
31049: PPUSH
31050: LD_STRING DA1-JMM-1a
31052: PPUSH
31053: CALL_OW 91
31057: GO 31566
31059: LD_EXP 39
31063: DOUBLE
31064: EQUAL
31065: IFTRUE 31069
31067: GO 31084
31069: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31070: LD_EXP 39
31074: PPUSH
31075: LD_STRING DA1-Joan-1a
31077: PPUSH
31078: CALL_OW 91
31082: GO 31566
31084: LD_EXP 41
31088: DOUBLE
31089: EQUAL
31090: IFTRUE 31094
31092: GO 31109
31094: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31095: LD_EXP 41
31099: PPUSH
31100: LD_STRING DA1-Lisa-1a
31102: PPUSH
31103: CALL_OW 91
31107: GO 31566
31109: LD_EXP 42
31113: DOUBLE
31114: EQUAL
31115: IFTRUE 31119
31117: GO 31134
31119: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31120: LD_EXP 42
31124: PPUSH
31125: LD_STRING DA1-Don-1a
31127: PPUSH
31128: CALL_OW 91
31132: GO 31566
31134: LD_EXP 49
31138: DOUBLE
31139: EQUAL
31140: IFTRUE 31144
31142: GO 31159
31144: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31145: LD_EXP 49
31149: PPUSH
31150: LD_STRING DA1-Corn-1a
31152: PPUSH
31153: CALL_OW 91
31157: GO 31566
31159: LD_EXP 45
31163: DOUBLE
31164: EQUAL
31165: IFTRUE 31169
31167: GO 31184
31169: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31170: LD_EXP 45
31174: PPUSH
31175: LD_STRING DA1-Den-1a
31177: PPUSH
31178: CALL_OW 91
31182: GO 31566
31184: LD_EXP 43
31188: DOUBLE
31189: EQUAL
31190: IFTRUE 31194
31192: GO 31209
31194: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31195: LD_EXP 43
31199: PPUSH
31200: LD_STRING DA1-Bobby-1a
31202: PPUSH
31203: CALL_OW 91
31207: GO 31566
31209: LD_EXP 47
31213: DOUBLE
31214: EQUAL
31215: IFTRUE 31219
31217: GO 31234
31219: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31220: LD_EXP 47
31224: PPUSH
31225: LD_STRING DA1-Glad-1a
31227: PPUSH
31228: CALL_OW 91
31232: GO 31566
31234: LD_EXP 44
31238: DOUBLE
31239: EQUAL
31240: IFTRUE 31244
31242: GO 31259
31244: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31245: LD_EXP 44
31249: PPUSH
31250: LD_STRING DA1-Cyrus-1a
31252: PPUSH
31253: CALL_OW 91
31257: GO 31566
31259: LD_EXP 40
31263: DOUBLE
31264: EQUAL
31265: IFTRUE 31269
31267: GO 31284
31269: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31270: LD_EXP 40
31274: PPUSH
31275: LD_STRING DA1-Huck-1a
31277: PPUSH
31278: CALL_OW 91
31282: GO 31566
31284: LD_EXP 54
31288: DOUBLE
31289: EQUAL
31290: IFTRUE 31294
31292: GO 31309
31294: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31295: LD_EXP 54
31299: PPUSH
31300: LD_STRING DA1-Huck-1a
31302: PPUSH
31303: CALL_OW 91
31307: GO 31566
31309: LD_EXP 46
31313: DOUBLE
31314: EQUAL
31315: IFTRUE 31319
31317: GO 31334
31319: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31320: LD_EXP 46
31324: PPUSH
31325: LD_STRING DA1-Brown-1a
31327: PPUSH
31328: CALL_OW 91
31332: GO 31566
31334: LD_EXP 50
31338: DOUBLE
31339: EQUAL
31340: IFTRUE 31344
31342: GO 31359
31344: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31345: LD_EXP 50
31349: PPUSH
31350: LD_STRING DA1-Gary-1a
31352: PPUSH
31353: CALL_OW 91
31357: GO 31566
31359: LD_EXP 53
31363: DOUBLE
31364: EQUAL
31365: IFTRUE 31369
31367: GO 31384
31369: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31370: LD_EXP 53
31374: PPUSH
31375: LD_STRING DA1-Con-1a
31377: PPUSH
31378: CALL_OW 91
31382: GO 31566
31384: LD_EXP 59
31388: DOUBLE
31389: EQUAL
31390: IFTRUE 31394
31392: GO 31409
31394: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31395: LD_EXP 59
31399: PPUSH
31400: LD_STRING DA1-Kurt-1a
31402: PPUSH
31403: CALL_OW 91
31407: GO 31566
31409: LD_EXP 52
31413: DOUBLE
31414: EQUAL
31415: IFTRUE 31419
31417: GO 31434
31419: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31420: LD_EXP 52
31424: PPUSH
31425: LD_STRING DA1-Yam-1a
31427: PPUSH
31428: CALL_OW 91
31432: GO 31566
31434: LD_EXP 51
31438: DOUBLE
31439: EQUAL
31440: IFTRUE 31444
31442: GO 31459
31444: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31445: LD_EXP 51
31449: PPUSH
31450: LD_STRING DA1-Frank-1a
31452: PPUSH
31453: CALL_OW 91
31457: GO 31566
31459: POP
// begin join := rand ( 0 , 1 ) ;
31460: LD_ADDR_VAR 0 3
31464: PUSH
31465: LD_INT 0
31467: PPUSH
31468: LD_INT 1
31470: PPUSH
31471: CALL_OW 12
31475: ST_TO_ADDR
// if join then
31476: LD_VAR 0 3
31480: IFFALSE 31525
// begin if GetSex ( unit ) = sex_male then
31482: LD_VAR 0 1
31486: PPUSH
31487: CALL_OW 258
31491: PUSH
31492: LD_INT 1
31494: EQUAL
31495: IFFALSE 31511
// ForceSay ( unit , DA1-Sol1-1b ) else
31497: LD_VAR 0 1
31501: PPUSH
31502: LD_STRING DA1-Sol1-1b
31504: PPUSH
31505: CALL_OW 91
31509: GO 31523
// ForceSay ( unit , DA1-FSol1-1b ) ;
31511: LD_VAR 0 1
31515: PPUSH
31516: LD_STRING DA1-FSol1-1b
31518: PPUSH
31519: CALL_OW 91
// end else
31523: GO 31566
// begin if GetSex ( unit ) = sex_male then
31525: LD_VAR 0 1
31529: PPUSH
31530: CALL_OW 258
31534: PUSH
31535: LD_INT 1
31537: EQUAL
31538: IFFALSE 31554
// ForceSay ( unit , DA1-Sol1-1a ) else
31540: LD_VAR 0 1
31544: PPUSH
31545: LD_STRING DA1-Sol1-1a
31547: PPUSH
31548: CALL_OW 91
31552: GO 31566
// ForceSay ( unit , DA1-FSol1-1a ) ;
31554: LD_VAR 0 1
31558: PPUSH
31559: LD_STRING DA1-FSol1-1a
31561: PPUSH
31562: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31566: LD_VAR 0 1
31570: PUSH
31571: LD_EXP 38
31575: EQUAL
31576: IFFALSE 31587
// begin YouLost ( JMMCaptured ) ;
31578: LD_STRING JMMCaptured
31580: PPUSH
31581: CALL_OW 104
// exit ;
31585: GO 31885
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31587: LD_VAR 0 1
31591: PUSH
31592: LD_EXP 42
31596: PUSH
31597: LD_EXP 45
31601: PUSH
31602: LD_EXP 43
31606: PUSH
31607: LD_EXP 40
31611: PUSH
31612: LD_EXP 54
31616: PUSH
31617: LD_EXP 46
31621: PUSH
31622: LD_EXP 52
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: IN
31636: PUSH
31637: LD_VAR 0 3
31641: OR
31642: IFFALSE 31741
// begin Say ( Roth , DA-Roth-3 ) ;
31644: LD_EXP 73
31648: PPUSH
31649: LD_STRING DA-Roth-3
31651: PPUSH
31652: CALL_OW 88
// SetSide ( unit , 7 ) ;
31656: LD_VAR 0 1
31660: PPUSH
31661: LD_INT 7
31663: PPUSH
31664: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31668: LD_ADDR_EXP 101
31672: PUSH
31673: LD_EXP 101
31677: PPUSH
31678: LD_INT 1
31680: PPUSH
31681: LD_EXP 101
31685: PUSH
31686: LD_INT 1
31688: ARRAY
31689: PUSH
31690: LD_VAR 0 1
31694: ADD
31695: PPUSH
31696: CALL_OW 1
31700: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31701: LD_INT 260
31703: PPUSH
31704: LD_INT 235
31706: PPUSH
31707: LD_INT 1
31709: PPUSH
31710: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31714: LD_VAR 0 1
31718: PPUSH
31719: LD_INT 1000
31721: PPUSH
31722: CALL_OW 234
// DialogueOff ;
31726: CALL_OW 7
// ComFree ( unit ) ;
31730: LD_VAR 0 1
31734: PPUSH
31735: CALL_OW 139
// end else
31739: GO 31822
// begin Say ( Roth , DA-Roth-3a ) ;
31741: LD_EXP 73
31745: PPUSH
31746: LD_STRING DA-Roth-3a
31748: PPUSH
31749: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31753: LD_ADDR_EXP 35
31757: PUSH
31758: LD_EXP 35
31762: PUSH
31763: LD_VAR 0 1
31767: ADD
31768: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31769: LD_INT 260
31771: PPUSH
31772: LD_INT 235
31774: PPUSH
31775: LD_INT 1
31777: PPUSH
31778: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31782: LD_VAR 0 1
31786: PPUSH
31787: LD_INT 1000
31789: PPUSH
31790: CALL_OW 234
// DialogueOff ;
31794: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31798: LD_VAR 0 1
31802: PPUSH
31803: LD_INT 272
31805: PPUSH
31806: LD_INT 254
31808: PPUSH
31809: CALL_OW 111
// AddComHold ( unit ) ;
31813: LD_VAR 0 1
31817: PPUSH
31818: CALL_OW 200
// end ; if capturedUnit = 1 then
31822: LD_EXP 34
31826: PUSH
31827: LD_INT 1
31829: EQUAL
31830: IFFALSE 31885
// begin DialogueOn ;
31832: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31836: LD_EXP 38
31840: PPUSH
31841: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31845: LD_EXP 38
31849: PPUSH
31850: LD_STRING DAa-JMM-1
31852: PPUSH
31853: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31857: LD_EXP 38
31861: PPUSH
31862: LD_STRING DAa-JMM-1a
31864: PPUSH
31865: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31869: LD_EXP 38
31873: PPUSH
31874: LD_STRING DAa-JMM-1b
31876: PPUSH
31877: CALL_OW 88
// DialogueOff ;
31881: CALL_OW 7
// end ; end ;
31885: LD_VAR 0 2
31889: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31890: LD_EXP 15
31894: PUSH
31895: LD_INT 13
31897: GREATEREQUAL
31898: PUSH
31899: LD_INT 22
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 21
31911: PUSH
31912: LD_INT 1
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PPUSH
31923: CALL_OW 69
31927: PUSH
31928: LD_INT 0
31930: EQUAL
31931: AND
31932: PUSH
31933: LD_INT 22
31935: PUSH
31936: LD_INT 2
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 21
31945: PUSH
31946: LD_INT 2
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: LD_INT 50
31955: PUSH
31956: EMPTY
31957: LIST
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: LIST
31963: PPUSH
31964: CALL_OW 69
31968: PUSH
31969: LD_INT 0
31971: EQUAL
31972: AND
31973: PUSH
31974: LD_EXP 21
31978: AND
31979: PUSH
31980: LD_EXP 22
31984: AND
31985: PUSH
31986: LD_EXP 23
31990: AND
31991: IFFALSE 32633
31993: GO 31995
31995: DISABLE
31996: LD_INT 0
31998: PPUSH
31999: PPUSH
32000: PPUSH
// begin m1 := false ;
32001: LD_ADDR_VAR 0 1
32005: PUSH
32006: LD_INT 0
32008: ST_TO_ADDR
// m2 := false ;
32009: LD_ADDR_VAR 0 2
32013: PUSH
32014: LD_INT 0
32016: ST_TO_ADDR
// m3 := false ;
32017: LD_ADDR_VAR 0 3
32021: PUSH
32022: LD_INT 0
32024: ST_TO_ADDR
// if not bombExploded then
32025: LD_EXP 37
32029: NOT
32030: IFFALSE 32039
// SetAchievement ( ACH_SIBROCKET ) ;
32032: LD_STRING ACH_SIBROCKET
32034: PPUSH
32035: CALL_OW 543
// if tick <= 120 120$00 then
32039: LD_OWVAR 1
32043: PUSH
32044: LD_INT 252000
32046: LESSEQUAL
32047: IFFALSE 32063
// begin wait ( 3 ) ;
32049: LD_INT 3
32051: PPUSH
32052: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32056: LD_STRING ACH_ASPEED_15
32058: PPUSH
32059: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32063: LD_EXP 38
32067: PPUSH
32068: CALL_OW 87
// music_class := 5 ;
32072: LD_ADDR_OWVAR 72
32076: PUSH
32077: LD_INT 5
32079: ST_TO_ADDR
// music_nat := 5 ;
32080: LD_ADDR_OWVAR 71
32084: PUSH
32085: LD_INT 5
32087: ST_TO_ADDR
// DialogueOn ;
32088: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32092: LD_EXP 38
32096: PPUSH
32097: LD_STRING D20-JMM-1
32099: PPUSH
32100: CALL_OW 88
// if IsOK ( Joan ) then
32104: LD_EXP 39
32108: PPUSH
32109: CALL_OW 302
32113: IFFALSE 32127
// Say ( Joan , D20-Joan-1 ) ;
32115: LD_EXP 39
32119: PPUSH
32120: LD_STRING D20-Joan-1
32122: PPUSH
32123: CALL_OW 88
// if IsOk ( Lisa ) then
32127: LD_EXP 41
32131: PPUSH
32132: CALL_OW 302
32136: IFFALSE 32150
// Say ( Lisa , D20-Lisa-1 ) ;
32138: LD_EXP 41
32142: PPUSH
32143: LD_STRING D20-Lisa-1
32145: PPUSH
32146: CALL_OW 88
// if IsOk ( Donaldson ) then
32150: LD_EXP 42
32154: PPUSH
32155: CALL_OW 302
32159: IFFALSE 32173
// Say ( Donaldson , D20-Don-1 ) ;
32161: LD_EXP 42
32165: PPUSH
32166: LD_STRING D20-Don-1
32168: PPUSH
32169: CALL_OW 88
// if IsOK ( Cornel ) then
32173: LD_EXP 49
32177: PPUSH
32178: CALL_OW 302
32182: IFFALSE 32196
// Say ( Cornel , D20-Corn-1 ) ;
32184: LD_EXP 49
32188: PPUSH
32189: LD_STRING D20-Corn-1
32191: PPUSH
32192: CALL_OW 88
// if IsOk ( Denis ) then
32196: LD_EXP 45
32200: PPUSH
32201: CALL_OW 302
32205: IFFALSE 32219
// Say ( Denis , D20-Den-1 ) ;
32207: LD_EXP 45
32211: PPUSH
32212: LD_STRING D20-Den-1
32214: PPUSH
32215: CALL_OW 88
// if IsOk ( Bobby ) then
32219: LD_EXP 43
32223: PPUSH
32224: CALL_OW 302
32228: IFFALSE 32242
// Say ( Bobby , D20-Bobby-1 ) ;
32230: LD_EXP 43
32234: PPUSH
32235: LD_STRING D20-Bobby-1
32237: PPUSH
32238: CALL_OW 88
// if IsOk ( Gladstone ) then
32242: LD_EXP 47
32246: PPUSH
32247: CALL_OW 302
32251: IFFALSE 32265
// Say ( Gladstone , D20-Glad-1 ) ;
32253: LD_EXP 47
32257: PPUSH
32258: LD_STRING D20-Glad-1
32260: PPUSH
32261: CALL_OW 88
// if IsOk ( Cyrus ) then
32265: LD_EXP 44
32269: PPUSH
32270: CALL_OW 302
32274: IFFALSE 32288
// Say ( Cyrus , D20-Cyrus-1 ) ;
32276: LD_EXP 44
32280: PPUSH
32281: LD_STRING D20-Cyrus-1
32283: PPUSH
32284: CALL_OW 88
// if IsOk ( Stevens ) then
32288: LD_EXP 40
32292: PPUSH
32293: CALL_OW 302
32297: IFFALSE 32311
// Say ( Stevens , D20-Huck-1 ) ;
32299: LD_EXP 40
32303: PPUSH
32304: LD_STRING D20-Huck-1
32306: PPUSH
32307: CALL_OW 88
// if IsOk ( Brown ) then
32311: LD_EXP 46
32315: PPUSH
32316: CALL_OW 302
32320: IFFALSE 32334
// Say ( Brown , D20-Brown-1 ) ;
32322: LD_EXP 46
32326: PPUSH
32327: LD_STRING D20-Brown-1
32329: PPUSH
32330: CALL_OW 88
// if IsOk ( Gary ) then
32334: LD_EXP 50
32338: PPUSH
32339: CALL_OW 302
32343: IFFALSE 32357
// Say ( Gary , D20-Gary-1 ) ;
32345: LD_EXP 50
32349: PPUSH
32350: LD_STRING D20-Gary-1
32352: PPUSH
32353: CALL_OW 88
// if IsOk ( Connie ) then
32357: LD_EXP 53
32361: PPUSH
32362: CALL_OW 302
32366: IFFALSE 32380
// Say ( Connie , D20-Con-1 ) ;
32368: LD_EXP 53
32372: PPUSH
32373: LD_STRING D20-Con-1
32375: PPUSH
32376: CALL_OW 88
// if IsOk ( Kurt ) then
32380: LD_EXP 59
32384: PPUSH
32385: CALL_OW 302
32389: IFFALSE 32403
// Say ( Kurt , D20-Kurt-1 ) ;
32391: LD_EXP 59
32395: PPUSH
32396: LD_STRING D20-Kurt-1
32398: PPUSH
32399: CALL_OW 88
// if IsOk ( Kikuchi ) then
32403: LD_EXP 52
32407: PPUSH
32408: CALL_OW 302
32412: IFFALSE 32426
// Say ( Kikuchi , D20-Yam-1 ) ;
32414: LD_EXP 52
32418: PPUSH
32419: LD_STRING D20-Yam-1
32421: PPUSH
32422: CALL_OW 88
// if IsOk ( Frank ) then
32426: LD_EXP 51
32430: PPUSH
32431: CALL_OW 302
32435: IFFALSE 32449
// Say ( Frank , D20-Frank-1 ) ;
32437: LD_EXP 51
32441: PPUSH
32442: LD_STRING D20-Frank-1
32444: PPUSH
32445: CALL_OW 88
// DialogueOff ;
32449: CALL_OW 7
// if RothCaptured then
32453: LD_EXP 33
32457: IFFALSE 32479
// begin m1 := true ;
32459: LD_ADDR_VAR 0 1
32463: PUSH
32464: LD_INT 1
32466: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32467: LD_STRING Roth
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: CALL_OW 101
// end else
32477: GO 32490
// AddMedal ( Roth , - 1 ) ;
32479: LD_STRING Roth
32481: PPUSH
32482: LD_INT 1
32484: NEG
32485: PPUSH
32486: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32490: LD_EXP 27
32494: IFFALSE 32516
// begin m2 := true ;
32496: LD_ADDR_VAR 0 2
32500: PUSH
32501: LD_INT 1
32503: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32504: LD_STRING Project
32506: PPUSH
32507: LD_INT 1
32509: PPUSH
32510: CALL_OW 101
// end else
32514: GO 32527
// AddMedal ( Project , - 1 ) ;
32516: LD_STRING Project
32518: PPUSH
32519: LD_INT 1
32521: NEG
32522: PPUSH
32523: CALL_OW 101
// if lostCounter = 0 then
32527: LD_EXP 32
32531: PUSH
32532: LD_INT 0
32534: EQUAL
32535: IFFALSE 32557
// begin m3 := true ;
32537: LD_ADDR_VAR 0 3
32541: PUSH
32542: LD_INT 1
32544: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32545: LD_STRING NoLosses
32547: PPUSH
32548: LD_INT 1
32550: PPUSH
32551: CALL_OW 101
// end else
32555: GO 32568
// AddMedal ( NoLosses , - 1 ) ;
32557: LD_STRING NoLosses
32559: PPUSH
32560: LD_INT 1
32562: NEG
32563: PPUSH
32564: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32568: LD_VAR 0 1
32572: PUSH
32573: LD_VAR 0 2
32577: AND
32578: PUSH
32579: LD_VAR 0 3
32583: AND
32584: PUSH
32585: LD_OWVAR 67
32589: PUSH
32590: LD_INT 3
32592: EQUAL
32593: AND
32594: IFFALSE 32606
// SetAchievementEX ( ACH_AMER , 15 ) ;
32596: LD_STRING ACH_AMER
32598: PPUSH
32599: LD_INT 15
32601: PPUSH
32602: CALL_OW 564
// GiveMedals ( MAIN ) ;
32606: LD_STRING MAIN
32608: PPUSH
32609: CALL_OW 102
// music_class := 4 ;
32613: LD_ADDR_OWVAR 72
32617: PUSH
32618: LD_INT 4
32620: ST_TO_ADDR
// music_nat := 1 ;
32621: LD_ADDR_OWVAR 71
32625: PUSH
32626: LD_INT 1
32628: ST_TO_ADDR
// YouWin ;
32629: CALL_OW 103
// end ; end_of_file
32633: PPOPN 3
32635: END
// export function CustomEvent ( event ) ; begin
32636: LD_INT 0
32638: PPUSH
// end ;
32639: LD_VAR 0 2
32643: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32644: LD_VAR 0 1
32648: PUSH
32649: LD_INT 1
32651: EQUAL
32652: PUSH
32653: LD_VAR 0 2
32657: PUSH
32658: LD_INT 4
32660: EQUAL
32661: AND
32662: PUSH
32663: LD_EXP 57
32667: PPUSH
32668: CALL_OW 300
32672: AND
32673: IFFALSE 32689
// begin wait ( 0 0$2 ) ;
32675: LD_INT 70
32677: PPUSH
32678: CALL_OW 67
// YouLost ( Dismissed ) ;
32682: LD_STRING Dismissed
32684: PPUSH
32685: CALL_OW 104
// end ; end ;
32689: PPOPN 2
32691: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32692: LD_VAR 0 2
32696: PPUSH
32697: LD_VAR 0 3
32701: PPUSH
32702: LD_INT 18
32704: PPUSH
32705: CALL_OW 309
32709: IFFALSE 32718
// YouLost ( Motherlode3 ) ;
32711: LD_STRING Motherlode3
32713: PPUSH
32714: CALL_OW 104
// end ;
32718: PPOPN 3
32720: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32721: LD_EXP 27
32725: NOT
32726: IFFALSE 32736
// behemothDone := true ;
32728: LD_ADDR_EXP 28
32732: PUSH
32733: LD_INT 1
32735: ST_TO_ADDR
// end ;
32736: PPOPN 1
32738: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 255
32748: PUSH
32749: LD_INT 1
32751: EQUAL
32752: IFFALSE 32762
// bombExploded := true ;
32754: LD_ADDR_EXP 37
32758: PUSH
32759: LD_INT 1
32761: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32762: LD_VAR 0 1
32766: PPUSH
32767: CALL_OW 255
32771: PUSH
32772: LD_INT 1
32774: EQUAL
32775: PUSH
32776: LD_EXP 30
32780: AND
32781: PUSH
32782: LD_INT 22
32784: PUSH
32785: LD_INT 3
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 34
32794: PUSH
32795: LD_INT 48
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PPUSH
32806: CALL_OW 69
32810: AND
32811: PUSH
32812: LD_INT 22
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 34
32824: PUSH
32825: LD_INT 8
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PPUSH
32836: CALL_OW 69
32840: NOT
32841: AND
32842: IFFALSE 32894
// begin wait ( 0 0$5 ) ;
32844: LD_INT 175
32846: PPUSH
32847: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32851: LD_INT 22
32853: PUSH
32854: LD_INT 3
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 34
32863: PUSH
32864: LD_INT 48
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PPUSH
32875: CALL_OW 69
32879: PUSH
32880: LD_INT 1
32882: ARRAY
32883: PPUSH
32884: LD_INT 60
32886: PPUSH
32887: LD_INT 95
32889: PPUSH
32890: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32894: LD_VAR 0 2
32898: PPUSH
32899: LD_VAR 0 3
32903: PPUSH
32904: LD_INT 18
32906: PPUSH
32907: CALL_OW 309
32911: IFFALSE 32971
// begin if GetSide ( unit ) = 1 then
32913: LD_VAR 0 1
32917: PPUSH
32918: CALL_OW 255
32922: PUSH
32923: LD_INT 1
32925: EQUAL
32926: IFFALSE 32942
// begin wait ( 0 0$6 ) ;
32928: LD_INT 210
32930: PPUSH
32931: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32935: LD_STRING Motherlode2
32937: PPUSH
32938: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32942: LD_VAR 0 1
32946: PPUSH
32947: CALL_OW 255
32951: PUSH
32952: LD_INT 8
32954: EQUAL
32955: IFFALSE 32971
// begin wait ( 0 0$6 ) ;
32957: LD_INT 210
32959: PPUSH
32960: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32964: LD_STRING Motherlode1
32966: PPUSH
32967: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32971: LD_VAR 0 1
32975: PPUSH
32976: CALL_OW 255
32980: PUSH
32981: LD_INT 3
32983: EQUAL
32984: IFFALSE 33005
// begin wait ( 0 0$5 ) ;
32986: LD_INT 175
32988: PPUSH
32989: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32993: LD_EXP 63
32997: PPUSH
32998: LD_STRING D18-Pla-1
33000: PPUSH
33001: CALL_OW 94
// end ; end ;
33005: PPOPN 3
33007: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33008: LD_VAR 0 1
33012: PUSH
33013: LD_EXP 72
33017: IN
33018: IFFALSE 33038
// begin behemothBuilders := behemothBuilders diff un ;
33020: LD_ADDR_EXP 72
33024: PUSH
33025: LD_EXP 72
33029: PUSH
33030: LD_VAR 0 1
33034: DIFF
33035: ST_TO_ADDR
// exit ;
33036: GO 33136
// end ; if un = JMM then
33038: LD_VAR 0 1
33042: PUSH
33043: LD_EXP 38
33047: EQUAL
33048: IFFALSE 33059
// begin YouLost ( JMM ) ;
33050: LD_STRING JMM
33052: PPUSH
33053: CALL_OW 104
// exit ;
33057: GO 33136
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33059: LD_VAR 0 1
33063: PUSH
33064: LD_INT 22
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 3
33076: PUSH
33077: LD_INT 25
33079: PUSH
33080: LD_INT 16
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 25
33089: PUSH
33090: LD_INT 12
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: LIST
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PPUSH
33106: CALL_OW 69
33110: IN
33111: IFFALSE 33127
// lostCounter := lostCounter + 1 ;
33113: LD_ADDR_EXP 32
33117: PUSH
33118: LD_EXP 32
33122: PUSH
33123: LD_INT 1
33125: PLUS
33126: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33127: LD_VAR 0 1
33131: PPUSH
33132: CALL 61420 0 1
// end ;
33136: PPOPN 1
33138: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33139: LD_VAR 0 1
33143: PPUSH
33144: LD_VAR 0 2
33148: PPUSH
33149: CALL 63754 0 2
// end ;
33153: PPOPN 2
33155: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33156: LD_VAR 0 1
33160: PPUSH
33161: CALL 62822 0 1
// end ;
33165: PPOPN 1
33167: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33168: LD_VAR 0 1
33172: PUSH
33173: LD_INT 22
33175: PUSH
33176: LD_INT 8
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 30
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 23
33195: PUSH
33196: LD_INT 3
33198: PUSH
33199: EMPTY
33200: LIST
33201: LIST
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: LIST
33207: PPUSH
33208: CALL_OW 69
33212: IN
33213: IFFALSE 33240
// begin ComUpgrade ( building ) ;
33215: LD_VAR 0 1
33219: PPUSH
33220: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33224: LD_EXP 60
33228: PPUSH
33229: LD_VAR 0 1
33233: PPUSH
33234: CALL 74460 0 2
// exit ;
33238: GO 33249
// end ; MCE_BuildingComplete ( building ) ;
33240: LD_VAR 0 1
33244: PPUSH
33245: CALL 63063 0 1
// end ;
33249: PPOPN 1
33251: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33252: LD_VAR 0 1
33256: PPUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: CALL 61116 0 2
// end ;
33266: PPOPN 2
33268: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33269: LD_VAR 0 1
33273: PPUSH
33274: LD_VAR 0 2
33278: PPUSH
33279: LD_VAR 0 3
33283: PPUSH
33284: LD_VAR 0 4
33288: PPUSH
33289: LD_VAR 0 5
33293: PPUSH
33294: CALL 60736 0 5
// end ;
33298: PPOPN 5
33300: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33301: LD_VAR 0 1
33305: PPUSH
33306: LD_VAR 0 2
33310: PPUSH
33311: CALL 60332 0 2
// end ;
33315: PPOPN 2
33317: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33318: LD_VAR 0 1
33322: PPUSH
33323: LD_VAR 0 2
33327: PPUSH
33328: LD_VAR 0 3
33332: PPUSH
33333: LD_VAR 0 4
33337: PPUSH
33338: CALL 60170 0 4
// end ;
33342: PPOPN 4
33344: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33345: LD_VAR 0 1
33349: PPUSH
33350: LD_VAR 0 2
33354: PPUSH
33355: LD_VAR 0 3
33359: PPUSH
33360: CALL 59945 0 3
// end ;
33364: PPOPN 3
33366: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33367: LD_VAR 0 1
33371: PPUSH
33372: LD_VAR 0 2
33376: PPUSH
33377: CALL 59830 0 2
// end ;
33381: PPOPN 2
33383: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33384: LD_VAR 0 1
33388: PPUSH
33389: LD_VAR 0 2
33393: PPUSH
33394: CALL 64015 0 2
// end ;
33398: PPOPN 2
33400: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33401: LD_VAR 0 1
33405: PPUSH
33406: CALL_OW 255
33410: PUSH
33411: LD_INT 4
33413: EQUAL
33414: PUSH
33415: LD_VAR 0 1
33419: PUSH
33420: LD_EXP 18
33424: PUSH
33425: LD_INT 1
33427: ARRAY
33428: IN
33429: AND
33430: PUSH
33431: LD_EXP 19
33435: AND
33436: IFFALSE 33455
// begin ComMoveXY ( driver , 61 , 93 ) ;
33438: LD_VAR 0 1
33442: PPUSH
33443: LD_INT 61
33445: PPUSH
33446: LD_INT 93
33448: PPUSH
33449: CALL_OW 111
// exit ;
33453: GO 33479
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33455: LD_VAR 0 1
33459: PPUSH
33460: LD_VAR 0 2
33464: PPUSH
33465: LD_VAR 0 3
33469: PPUSH
33470: LD_VAR 0 4
33474: PPUSH
33475: CALL 64231 0 4
// end ;
33479: PPOPN 4
33481: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33482: LD_VAR 0 1
33486: PPUSH
33487: LD_VAR 0 2
33491: PPUSH
33492: CALL 59639 0 2
// end ;
33496: PPOPN 2
33498: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33499: LD_VAR 0 1
33503: PPUSH
33504: CALL 107632 0 1
// end ; end_of_file
33508: PPOPN 1
33510: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33511: LD_EXP 15
33515: PUSH
33516: LD_INT 2
33518: EQUAL
33519: IFFALSE 33998
33521: GO 33523
33523: DISABLE
33524: LD_INT 0
33526: PPUSH
// begin time := 0 0$40 ;
33527: LD_ADDR_VAR 0 1
33531: PUSH
33532: LD_INT 1400
33534: ST_TO_ADDR
// repeat wait ( time ) ;
33535: LD_VAR 0 1
33539: PPUSH
33540: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33544: LD_INT 1
33546: PPUSH
33547: LD_INT 5
33549: PPUSH
33550: CALL_OW 12
33554: PPUSH
33555: LD_INT 106
33557: PPUSH
33558: LD_INT 150
33560: PPUSH
33561: LD_INT 19
33563: PPUSH
33564: LD_INT 1
33566: PPUSH
33567: CALL_OW 56
// time := time + 0 0$9 ;
33571: LD_ADDR_VAR 0 1
33575: PUSH
33576: LD_VAR 0 1
33580: PUSH
33581: LD_INT 315
33583: PLUS
33584: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33585: LD_INT 455
33587: PPUSH
33588: LD_INT 840
33590: PPUSH
33591: CALL_OW 12
33595: PPUSH
33596: CALL_OW 67
// if Prob ( 50 ) then
33600: LD_INT 50
33602: PPUSH
33603: CALL_OW 13
33607: IFFALSE 33636
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33609: LD_INT 1
33611: PPUSH
33612: LD_INT 5
33614: PPUSH
33615: CALL_OW 12
33619: PPUSH
33620: LD_INT 62
33622: PPUSH
33623: LD_INT 108
33625: PPUSH
33626: LD_INT 10
33628: PPUSH
33629: LD_INT 1
33631: PPUSH
33632: CALL_OW 56
// until missionStage > 4 ;
33636: LD_EXP 15
33640: PUSH
33641: LD_INT 4
33643: GREATER
33644: IFFALSE 33535
// repeat wait ( 0 0$1 ) ;
33646: LD_INT 35
33648: PPUSH
33649: CALL_OW 67
// until missionStage = 6 ;
33653: LD_EXP 15
33657: PUSH
33658: LD_INT 6
33660: EQUAL
33661: IFFALSE 33646
// time := 0 0$50 ;
33663: LD_ADDR_VAR 0 1
33667: PUSH
33668: LD_INT 1750
33670: ST_TO_ADDR
// repeat wait ( time ) ;
33671: LD_VAR 0 1
33675: PPUSH
33676: CALL_OW 67
// if Prob ( 50 ) then
33680: LD_INT 50
33682: PPUSH
33683: CALL_OW 13
33687: IFFALSE 33716
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33689: LD_INT 1
33691: PPUSH
33692: LD_INT 5
33694: PPUSH
33695: CALL_OW 12
33699: PPUSH
33700: LD_INT 106
33702: PPUSH
33703: LD_INT 89
33705: PPUSH
33706: LD_INT 45
33708: PPUSH
33709: LD_INT 1
33711: PPUSH
33712: CALL_OW 56
// time := time + 0 0$3 ;
33716: LD_ADDR_VAR 0 1
33720: PUSH
33721: LD_VAR 0 1
33725: PUSH
33726: LD_INT 105
33728: PLUS
33729: ST_TO_ADDR
// if Prob ( 30 ) then
33730: LD_INT 30
33732: PPUSH
33733: CALL_OW 13
33737: IFFALSE 33783
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33739: LD_INT 525
33741: PPUSH
33742: LD_INT 735
33744: PPUSH
33745: CALL_OW 12
33749: PPUSH
33750: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33754: LD_INT 1
33756: PPUSH
33757: LD_INT 5
33759: PPUSH
33760: CALL_OW 12
33764: PPUSH
33765: LD_INT 21
33767: PPUSH
33768: LD_INT 26
33770: PPUSH
33771: LD_INT 12
33773: PPUSH
33774: LD_INT 1
33776: PPUSH
33777: CALL_OW 56
// end else
33781: GO 33819
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33783: LD_INT 700
33785: PPUSH
33786: LD_INT 1225
33788: PPUSH
33789: CALL_OW 12
33793: PPUSH
33794: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33798: LD_INT 1
33800: PPUSH
33801: LD_INT 5
33803: PPUSH
33804: CALL_OW 12
33808: PPUSH
33809: LD_INT 16
33811: PPUSH
33812: LD_INT 1
33814: PPUSH
33815: CALL_OW 55
// end ; if Prob ( 50 ) then
33819: LD_INT 50
33821: PPUSH
33822: CALL_OW 13
33826: IFFALSE 33872
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33828: LD_INT 700
33830: PPUSH
33831: LD_INT 1050
33833: PPUSH
33834: CALL_OW 12
33838: PPUSH
33839: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33843: LD_INT 1
33845: PPUSH
33846: LD_INT 5
33848: PPUSH
33849: CALL_OW 12
33853: PPUSH
33854: LD_INT 181
33856: PPUSH
33857: LD_INT 218
33859: PPUSH
33860: LD_INT 16
33862: PPUSH
33863: LD_INT 1
33865: PPUSH
33866: CALL_OW 56
// end else
33870: GO 33908
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33872: LD_INT 350
33874: PPUSH
33875: LD_INT 525
33877: PPUSH
33878: CALL_OW 12
33882: PPUSH
33883: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33887: LD_INT 1
33889: PPUSH
33890: LD_INT 5
33892: PPUSH
33893: CALL_OW 12
33897: PPUSH
33898: LD_INT 15
33900: PPUSH
33901: LD_INT 1
33903: PPUSH
33904: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33908: LD_INT 45
33910: PUSH
33911: LD_INT 32
33913: PUSH
33914: LD_INT 25
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: LIST
33921: PUSH
33922: LD_OWVAR 67
33926: ARRAY
33927: PPUSH
33928: CALL_OW 13
33932: IFFALSE 33976
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33934: LD_INT 525
33936: PPUSH
33937: LD_INT 875
33939: PPUSH
33940: CALL_OW 12
33944: PPUSH
33945: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33949: LD_INT 1
33951: PPUSH
33952: LD_INT 5
33954: PPUSH
33955: CALL_OW 12
33959: PPUSH
33960: LD_INT 103
33962: PPUSH
33963: LD_INT 140
33965: PPUSH
33966: LD_INT 20
33968: PPUSH
33969: LD_INT 1
33971: PPUSH
33972: CALL_OW 56
// end ; if time > 2 2$20 then
33976: LD_VAR 0 1
33980: PUSH
33981: LD_INT 4900
33983: GREATER
33984: IFFALSE 33994
// time := 0 0$50 ;
33986: LD_ADDR_VAR 0 1
33990: PUSH
33991: LD_INT 1750
33993: ST_TO_ADDR
// until false ;
33994: LD_INT 0
33996: IFFALSE 33671
// end ; end_of_file
33998: PPOPN 1
34000: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34001: LD_EXP 13
34005: PUSH
34006: LD_EXP 15
34010: PUSH
34011: LD_INT 6
34013: GREATEREQUAL
34014: AND
34015: IFFALSE 34052
34017: GO 34019
34019: DISABLE
// begin enable ;
34020: ENABLE
// missionTime := missionTime + 0 0$1 ;
34021: LD_ADDR_EXP 14
34025: PUSH
34026: LD_EXP 14
34030: PUSH
34031: LD_INT 35
34033: PLUS
34034: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34035: LD_ADDR_OWVAR 47
34039: PUSH
34040: LD_STRING #Am15-1
34042: PUSH
34043: LD_EXP 14
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: ST_TO_ADDR
// end ; end_of_file
34052: END
// export function InitNature ; begin
34053: LD_INT 0
34055: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34056: LD_INT 3
34058: PPUSH
34059: LD_INT 3
34061: PPUSH
34062: LD_INT 2
34064: PPUSH
34065: LD_INT 1
34067: PPUSH
34068: LD_INT 1
34070: PPUSH
34071: LD_INT 0
34073: PPUSH
34074: LD_INT 0
34076: PPUSH
34077: LD_INT 20
34079: PPUSH
34080: LD_INT 0
34082: PPUSH
34083: CALL 99301 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34087: LD_INT 2
34089: PPUSH
34090: LD_INT 1
34092: PPUSH
34093: LD_INT 1
34095: PPUSH
34096: LD_INT 1
34098: PPUSH
34099: LD_INT 1
34101: PPUSH
34102: LD_INT 0
34104: PPUSH
34105: LD_INT 0
34107: PPUSH
34108: LD_INT 21
34110: PPUSH
34111: LD_INT 0
34113: PPUSH
34114: CALL 99301 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34118: LD_INT 4
34120: PPUSH
34121: LD_INT 1
34123: PPUSH
34124: LD_INT 2
34126: PPUSH
34127: LD_INT 4
34129: PPUSH
34130: LD_INT 2
34132: PPUSH
34133: LD_INT 1
34135: PPUSH
34136: LD_INT 0
34138: PPUSH
34139: LD_INT 22
34141: PPUSH
34142: LD_INT 0
34144: PPUSH
34145: CALL 99301 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34149: LD_INT 0
34151: PPUSH
34152: LD_INT 0
34154: PPUSH
34155: LD_INT 0
34157: PPUSH
34158: LD_INT 0
34160: PPUSH
34161: LD_INT 0
34163: PPUSH
34164: LD_INT 0
34166: PPUSH
34167: LD_INT 9
34169: PPUSH
34170: LD_INT 0
34172: PPUSH
34173: LD_INT 23
34175: PPUSH
34176: CALL 99301 0 9
// end ; end_of_file
34180: LD_VAR 0 1
34184: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34185: GO 34187
34187: DISABLE
// begin ru_radar := 98 ;
34188: LD_ADDR_EXP 94
34192: PUSH
34193: LD_INT 98
34195: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34196: LD_ADDR_EXP 95
34200: PUSH
34201: LD_INT 89
34203: ST_TO_ADDR
// us_hack := 99 ;
34204: LD_ADDR_EXP 96
34208: PUSH
34209: LD_INT 99
34211: ST_TO_ADDR
// us_artillery := 97 ;
34212: LD_ADDR_EXP 97
34216: PUSH
34217: LD_INT 97
34219: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34220: LD_ADDR_EXP 98
34224: PUSH
34225: LD_INT 91
34227: ST_TO_ADDR
// end ; end_of_file
34228: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34229: LD_INT 0
34231: PPUSH
34232: PPUSH
// skirmish := false ;
34233: LD_ADDR_EXP 99
34237: PUSH
34238: LD_INT 0
34240: ST_TO_ADDR
// debug_mc := false ;
34241: LD_ADDR_EXP 100
34245: PUSH
34246: LD_INT 0
34248: ST_TO_ADDR
// mc_bases := [ ] ;
34249: LD_ADDR_EXP 101
34253: PUSH
34254: EMPTY
34255: ST_TO_ADDR
// mc_sides := [ ] ;
34256: LD_ADDR_EXP 127
34260: PUSH
34261: EMPTY
34262: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34263: LD_ADDR_EXP 102
34267: PUSH
34268: EMPTY
34269: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34270: LD_ADDR_EXP 103
34274: PUSH
34275: EMPTY
34276: ST_TO_ADDR
// mc_need_heal := [ ] ;
34277: LD_ADDR_EXP 104
34281: PUSH
34282: EMPTY
34283: ST_TO_ADDR
// mc_healers := [ ] ;
34284: LD_ADDR_EXP 105
34288: PUSH
34289: EMPTY
34290: ST_TO_ADDR
// mc_build_list := [ ] ;
34291: LD_ADDR_EXP 106
34295: PUSH
34296: EMPTY
34297: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34298: LD_ADDR_EXP 133
34302: PUSH
34303: EMPTY
34304: ST_TO_ADDR
// mc_builders := [ ] ;
34305: LD_ADDR_EXP 107
34309: PUSH
34310: EMPTY
34311: ST_TO_ADDR
// mc_construct_list := [ ] ;
34312: LD_ADDR_EXP 108
34316: PUSH
34317: EMPTY
34318: ST_TO_ADDR
// mc_turret_list := [ ] ;
34319: LD_ADDR_EXP 109
34323: PUSH
34324: EMPTY
34325: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34326: LD_ADDR_EXP 110
34330: PUSH
34331: EMPTY
34332: ST_TO_ADDR
// mc_miners := [ ] ;
34333: LD_ADDR_EXP 115
34337: PUSH
34338: EMPTY
34339: ST_TO_ADDR
// mc_mines := [ ] ;
34340: LD_ADDR_EXP 114
34344: PUSH
34345: EMPTY
34346: ST_TO_ADDR
// mc_minefields := [ ] ;
34347: LD_ADDR_EXP 116
34351: PUSH
34352: EMPTY
34353: ST_TO_ADDR
// mc_crates := [ ] ;
34354: LD_ADDR_EXP 117
34358: PUSH
34359: EMPTY
34360: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34361: LD_ADDR_EXP 118
34365: PUSH
34366: EMPTY
34367: ST_TO_ADDR
// mc_crates_area := [ ] ;
34368: LD_ADDR_EXP 119
34372: PUSH
34373: EMPTY
34374: ST_TO_ADDR
// mc_vehicles := [ ] ;
34375: LD_ADDR_EXP 120
34379: PUSH
34380: EMPTY
34381: ST_TO_ADDR
// mc_attack := [ ] ;
34382: LD_ADDR_EXP 121
34386: PUSH
34387: EMPTY
34388: ST_TO_ADDR
// mc_produce := [ ] ;
34389: LD_ADDR_EXP 122
34393: PUSH
34394: EMPTY
34395: ST_TO_ADDR
// mc_defender := [ ] ;
34396: LD_ADDR_EXP 123
34400: PUSH
34401: EMPTY
34402: ST_TO_ADDR
// mc_parking := [ ] ;
34403: LD_ADDR_EXP 125
34407: PUSH
34408: EMPTY
34409: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34410: LD_ADDR_EXP 111
34414: PUSH
34415: EMPTY
34416: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34417: LD_ADDR_EXP 113
34421: PUSH
34422: EMPTY
34423: ST_TO_ADDR
// mc_scan := [ ] ;
34424: LD_ADDR_EXP 124
34428: PUSH
34429: EMPTY
34430: ST_TO_ADDR
// mc_scan_area := [ ] ;
34431: LD_ADDR_EXP 126
34435: PUSH
34436: EMPTY
34437: ST_TO_ADDR
// mc_tech := [ ] ;
34438: LD_ADDR_EXP 128
34442: PUSH
34443: EMPTY
34444: ST_TO_ADDR
// mc_class := [ ] ;
34445: LD_ADDR_EXP 142
34449: PUSH
34450: EMPTY
34451: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34452: LD_ADDR_EXP 143
34456: PUSH
34457: EMPTY
34458: ST_TO_ADDR
// end ;
34459: LD_VAR 0 1
34463: RET
// export function MC_Kill ( base ) ; begin
34464: LD_INT 0
34466: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34467: LD_ADDR_EXP 101
34471: PUSH
34472: LD_EXP 101
34476: PPUSH
34477: LD_VAR 0 1
34481: PPUSH
34482: EMPTY
34483: PPUSH
34484: CALL_OW 1
34488: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34489: LD_ADDR_EXP 102
34493: PUSH
34494: LD_EXP 102
34498: PPUSH
34499: LD_VAR 0 1
34503: PPUSH
34504: EMPTY
34505: PPUSH
34506: CALL_OW 1
34510: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34511: LD_ADDR_EXP 103
34515: PUSH
34516: LD_EXP 103
34520: PPUSH
34521: LD_VAR 0 1
34525: PPUSH
34526: EMPTY
34527: PPUSH
34528: CALL_OW 1
34532: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34533: LD_ADDR_EXP 104
34537: PUSH
34538: LD_EXP 104
34542: PPUSH
34543: LD_VAR 0 1
34547: PPUSH
34548: EMPTY
34549: PPUSH
34550: CALL_OW 1
34554: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34555: LD_ADDR_EXP 105
34559: PUSH
34560: LD_EXP 105
34564: PPUSH
34565: LD_VAR 0 1
34569: PPUSH
34570: EMPTY
34571: PPUSH
34572: CALL_OW 1
34576: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34577: LD_ADDR_EXP 106
34581: PUSH
34582: LD_EXP 106
34586: PPUSH
34587: LD_VAR 0 1
34591: PPUSH
34592: EMPTY
34593: PPUSH
34594: CALL_OW 1
34598: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34599: LD_ADDR_EXP 107
34603: PUSH
34604: LD_EXP 107
34608: PPUSH
34609: LD_VAR 0 1
34613: PPUSH
34614: EMPTY
34615: PPUSH
34616: CALL_OW 1
34620: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34621: LD_ADDR_EXP 108
34625: PUSH
34626: LD_EXP 108
34630: PPUSH
34631: LD_VAR 0 1
34635: PPUSH
34636: EMPTY
34637: PPUSH
34638: CALL_OW 1
34642: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34643: LD_ADDR_EXP 109
34647: PUSH
34648: LD_EXP 109
34652: PPUSH
34653: LD_VAR 0 1
34657: PPUSH
34658: EMPTY
34659: PPUSH
34660: CALL_OW 1
34664: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34665: LD_ADDR_EXP 110
34669: PUSH
34670: LD_EXP 110
34674: PPUSH
34675: LD_VAR 0 1
34679: PPUSH
34680: EMPTY
34681: PPUSH
34682: CALL_OW 1
34686: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34687: LD_ADDR_EXP 111
34691: PUSH
34692: LD_EXP 111
34696: PPUSH
34697: LD_VAR 0 1
34701: PPUSH
34702: EMPTY
34703: PPUSH
34704: CALL_OW 1
34708: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34709: LD_ADDR_EXP 112
34713: PUSH
34714: LD_EXP 112
34718: PPUSH
34719: LD_VAR 0 1
34723: PPUSH
34724: LD_INT 0
34726: PPUSH
34727: CALL_OW 1
34731: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34732: LD_ADDR_EXP 113
34736: PUSH
34737: LD_EXP 113
34741: PPUSH
34742: LD_VAR 0 1
34746: PPUSH
34747: EMPTY
34748: PPUSH
34749: CALL_OW 1
34753: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34754: LD_ADDR_EXP 114
34758: PUSH
34759: LD_EXP 114
34763: PPUSH
34764: LD_VAR 0 1
34768: PPUSH
34769: EMPTY
34770: PPUSH
34771: CALL_OW 1
34775: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34776: LD_ADDR_EXP 115
34780: PUSH
34781: LD_EXP 115
34785: PPUSH
34786: LD_VAR 0 1
34790: PPUSH
34791: EMPTY
34792: PPUSH
34793: CALL_OW 1
34797: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34798: LD_ADDR_EXP 116
34802: PUSH
34803: LD_EXP 116
34807: PPUSH
34808: LD_VAR 0 1
34812: PPUSH
34813: EMPTY
34814: PPUSH
34815: CALL_OW 1
34819: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34820: LD_ADDR_EXP 117
34824: PUSH
34825: LD_EXP 117
34829: PPUSH
34830: LD_VAR 0 1
34834: PPUSH
34835: EMPTY
34836: PPUSH
34837: CALL_OW 1
34841: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34842: LD_ADDR_EXP 118
34846: PUSH
34847: LD_EXP 118
34851: PPUSH
34852: LD_VAR 0 1
34856: PPUSH
34857: EMPTY
34858: PPUSH
34859: CALL_OW 1
34863: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34864: LD_ADDR_EXP 119
34868: PUSH
34869: LD_EXP 119
34873: PPUSH
34874: LD_VAR 0 1
34878: PPUSH
34879: EMPTY
34880: PPUSH
34881: CALL_OW 1
34885: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34886: LD_ADDR_EXP 120
34890: PUSH
34891: LD_EXP 120
34895: PPUSH
34896: LD_VAR 0 1
34900: PPUSH
34901: EMPTY
34902: PPUSH
34903: CALL_OW 1
34907: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34908: LD_ADDR_EXP 121
34912: PUSH
34913: LD_EXP 121
34917: PPUSH
34918: LD_VAR 0 1
34922: PPUSH
34923: EMPTY
34924: PPUSH
34925: CALL_OW 1
34929: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34930: LD_ADDR_EXP 122
34934: PUSH
34935: LD_EXP 122
34939: PPUSH
34940: LD_VAR 0 1
34944: PPUSH
34945: EMPTY
34946: PPUSH
34947: CALL_OW 1
34951: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34952: LD_ADDR_EXP 123
34956: PUSH
34957: LD_EXP 123
34961: PPUSH
34962: LD_VAR 0 1
34966: PPUSH
34967: EMPTY
34968: PPUSH
34969: CALL_OW 1
34973: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34974: LD_ADDR_EXP 124
34978: PUSH
34979: LD_EXP 124
34983: PPUSH
34984: LD_VAR 0 1
34988: PPUSH
34989: EMPTY
34990: PPUSH
34991: CALL_OW 1
34995: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34996: LD_ADDR_EXP 125
35000: PUSH
35001: LD_EXP 125
35005: PPUSH
35006: LD_VAR 0 1
35010: PPUSH
35011: EMPTY
35012: PPUSH
35013: CALL_OW 1
35017: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35018: LD_ADDR_EXP 126
35022: PUSH
35023: LD_EXP 126
35027: PPUSH
35028: LD_VAR 0 1
35032: PPUSH
35033: EMPTY
35034: PPUSH
35035: CALL_OW 1
35039: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35040: LD_ADDR_EXP 128
35044: PUSH
35045: LD_EXP 128
35049: PPUSH
35050: LD_VAR 0 1
35054: PPUSH
35055: EMPTY
35056: PPUSH
35057: CALL_OW 1
35061: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35062: LD_ADDR_EXP 130
35066: PUSH
35067: LD_EXP 130
35071: PPUSH
35072: LD_VAR 0 1
35076: PPUSH
35077: EMPTY
35078: PPUSH
35079: CALL_OW 1
35083: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35084: LD_ADDR_EXP 131
35088: PUSH
35089: LD_EXP 131
35093: PPUSH
35094: LD_VAR 0 1
35098: PPUSH
35099: EMPTY
35100: PPUSH
35101: CALL_OW 1
35105: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35106: LD_ADDR_EXP 132
35110: PUSH
35111: LD_EXP 132
35115: PPUSH
35116: LD_VAR 0 1
35120: PPUSH
35121: EMPTY
35122: PPUSH
35123: CALL_OW 1
35127: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35128: LD_ADDR_EXP 133
35132: PUSH
35133: LD_EXP 133
35137: PPUSH
35138: LD_VAR 0 1
35142: PPUSH
35143: EMPTY
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35150: LD_ADDR_EXP 134
35154: PUSH
35155: LD_EXP 134
35159: PPUSH
35160: LD_VAR 0 1
35164: PPUSH
35165: EMPTY
35166: PPUSH
35167: CALL_OW 1
35171: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35172: LD_ADDR_EXP 135
35176: PUSH
35177: LD_EXP 135
35181: PPUSH
35182: LD_VAR 0 1
35186: PPUSH
35187: EMPTY
35188: PPUSH
35189: CALL_OW 1
35193: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35194: LD_ADDR_EXP 136
35198: PUSH
35199: LD_EXP 136
35203: PPUSH
35204: LD_VAR 0 1
35208: PPUSH
35209: EMPTY
35210: PPUSH
35211: CALL_OW 1
35215: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35216: LD_ADDR_EXP 137
35220: PUSH
35221: LD_EXP 137
35225: PPUSH
35226: LD_VAR 0 1
35230: PPUSH
35231: EMPTY
35232: PPUSH
35233: CALL_OW 1
35237: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35238: LD_ADDR_EXP 138
35242: PUSH
35243: LD_EXP 138
35247: PPUSH
35248: LD_VAR 0 1
35252: PPUSH
35253: EMPTY
35254: PPUSH
35255: CALL_OW 1
35259: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35260: LD_ADDR_EXP 139
35264: PUSH
35265: LD_EXP 139
35269: PPUSH
35270: LD_VAR 0 1
35274: PPUSH
35275: EMPTY
35276: PPUSH
35277: CALL_OW 1
35281: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35282: LD_ADDR_EXP 140
35286: PUSH
35287: LD_EXP 140
35291: PPUSH
35292: LD_VAR 0 1
35296: PPUSH
35297: EMPTY
35298: PPUSH
35299: CALL_OW 1
35303: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35304: LD_ADDR_EXP 141
35308: PUSH
35309: LD_EXP 141
35313: PPUSH
35314: LD_VAR 0 1
35318: PPUSH
35319: EMPTY
35320: PPUSH
35321: CALL_OW 1
35325: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35326: LD_ADDR_EXP 142
35330: PUSH
35331: LD_EXP 142
35335: PPUSH
35336: LD_VAR 0 1
35340: PPUSH
35341: EMPTY
35342: PPUSH
35343: CALL_OW 1
35347: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35348: LD_ADDR_EXP 143
35352: PUSH
35353: LD_EXP 143
35357: PPUSH
35358: LD_VAR 0 1
35362: PPUSH
35363: LD_INT 0
35365: PPUSH
35366: CALL_OW 1
35370: ST_TO_ADDR
// end ;
35371: LD_VAR 0 2
35375: RET
// export function MC_Add ( side , units ) ; var base ; begin
35376: LD_INT 0
35378: PPUSH
35379: PPUSH
// base := mc_bases + 1 ;
35380: LD_ADDR_VAR 0 4
35384: PUSH
35385: LD_EXP 101
35389: PUSH
35390: LD_INT 1
35392: PLUS
35393: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35394: LD_ADDR_EXP 127
35398: PUSH
35399: LD_EXP 127
35403: PPUSH
35404: LD_VAR 0 4
35408: PPUSH
35409: LD_VAR 0 1
35413: PPUSH
35414: CALL_OW 1
35418: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35419: LD_ADDR_EXP 101
35423: PUSH
35424: LD_EXP 101
35428: PPUSH
35429: LD_VAR 0 4
35433: PPUSH
35434: LD_VAR 0 2
35438: PPUSH
35439: CALL_OW 1
35443: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35444: LD_ADDR_EXP 102
35448: PUSH
35449: LD_EXP 102
35453: PPUSH
35454: LD_VAR 0 4
35458: PPUSH
35459: EMPTY
35460: PPUSH
35461: CALL_OW 1
35465: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35466: LD_ADDR_EXP 103
35470: PUSH
35471: LD_EXP 103
35475: PPUSH
35476: LD_VAR 0 4
35480: PPUSH
35481: EMPTY
35482: PPUSH
35483: CALL_OW 1
35487: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35488: LD_ADDR_EXP 104
35492: PUSH
35493: LD_EXP 104
35497: PPUSH
35498: LD_VAR 0 4
35502: PPUSH
35503: EMPTY
35504: PPUSH
35505: CALL_OW 1
35509: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35510: LD_ADDR_EXP 105
35514: PUSH
35515: LD_EXP 105
35519: PPUSH
35520: LD_VAR 0 4
35524: PPUSH
35525: EMPTY
35526: PPUSH
35527: CALL_OW 1
35531: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35532: LD_ADDR_EXP 106
35536: PUSH
35537: LD_EXP 106
35541: PPUSH
35542: LD_VAR 0 4
35546: PPUSH
35547: EMPTY
35548: PPUSH
35549: CALL_OW 1
35553: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35554: LD_ADDR_EXP 107
35558: PUSH
35559: LD_EXP 107
35563: PPUSH
35564: LD_VAR 0 4
35568: PPUSH
35569: EMPTY
35570: PPUSH
35571: CALL_OW 1
35575: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35576: LD_ADDR_EXP 108
35580: PUSH
35581: LD_EXP 108
35585: PPUSH
35586: LD_VAR 0 4
35590: PPUSH
35591: EMPTY
35592: PPUSH
35593: CALL_OW 1
35597: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35598: LD_ADDR_EXP 109
35602: PUSH
35603: LD_EXP 109
35607: PPUSH
35608: LD_VAR 0 4
35612: PPUSH
35613: EMPTY
35614: PPUSH
35615: CALL_OW 1
35619: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35620: LD_ADDR_EXP 110
35624: PUSH
35625: LD_EXP 110
35629: PPUSH
35630: LD_VAR 0 4
35634: PPUSH
35635: EMPTY
35636: PPUSH
35637: CALL_OW 1
35641: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35642: LD_ADDR_EXP 111
35646: PUSH
35647: LD_EXP 111
35651: PPUSH
35652: LD_VAR 0 4
35656: PPUSH
35657: EMPTY
35658: PPUSH
35659: CALL_OW 1
35663: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35664: LD_ADDR_EXP 112
35668: PUSH
35669: LD_EXP 112
35673: PPUSH
35674: LD_VAR 0 4
35678: PPUSH
35679: LD_INT 0
35681: PPUSH
35682: CALL_OW 1
35686: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35687: LD_ADDR_EXP 113
35691: PUSH
35692: LD_EXP 113
35696: PPUSH
35697: LD_VAR 0 4
35701: PPUSH
35702: EMPTY
35703: PPUSH
35704: CALL_OW 1
35708: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35709: LD_ADDR_EXP 114
35713: PUSH
35714: LD_EXP 114
35718: PPUSH
35719: LD_VAR 0 4
35723: PPUSH
35724: EMPTY
35725: PPUSH
35726: CALL_OW 1
35730: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35731: LD_ADDR_EXP 115
35735: PUSH
35736: LD_EXP 115
35740: PPUSH
35741: LD_VAR 0 4
35745: PPUSH
35746: EMPTY
35747: PPUSH
35748: CALL_OW 1
35752: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35753: LD_ADDR_EXP 116
35757: PUSH
35758: LD_EXP 116
35762: PPUSH
35763: LD_VAR 0 4
35767: PPUSH
35768: EMPTY
35769: PPUSH
35770: CALL_OW 1
35774: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35775: LD_ADDR_EXP 117
35779: PUSH
35780: LD_EXP 117
35784: PPUSH
35785: LD_VAR 0 4
35789: PPUSH
35790: EMPTY
35791: PPUSH
35792: CALL_OW 1
35796: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35797: LD_ADDR_EXP 118
35801: PUSH
35802: LD_EXP 118
35806: PPUSH
35807: LD_VAR 0 4
35811: PPUSH
35812: EMPTY
35813: PPUSH
35814: CALL_OW 1
35818: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35819: LD_ADDR_EXP 119
35823: PUSH
35824: LD_EXP 119
35828: PPUSH
35829: LD_VAR 0 4
35833: PPUSH
35834: EMPTY
35835: PPUSH
35836: CALL_OW 1
35840: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35841: LD_ADDR_EXP 120
35845: PUSH
35846: LD_EXP 120
35850: PPUSH
35851: LD_VAR 0 4
35855: PPUSH
35856: EMPTY
35857: PPUSH
35858: CALL_OW 1
35862: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35863: LD_ADDR_EXP 121
35867: PUSH
35868: LD_EXP 121
35872: PPUSH
35873: LD_VAR 0 4
35877: PPUSH
35878: EMPTY
35879: PPUSH
35880: CALL_OW 1
35884: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35885: LD_ADDR_EXP 122
35889: PUSH
35890: LD_EXP 122
35894: PPUSH
35895: LD_VAR 0 4
35899: PPUSH
35900: EMPTY
35901: PPUSH
35902: CALL_OW 1
35906: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35907: LD_ADDR_EXP 123
35911: PUSH
35912: LD_EXP 123
35916: PPUSH
35917: LD_VAR 0 4
35921: PPUSH
35922: EMPTY
35923: PPUSH
35924: CALL_OW 1
35928: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35929: LD_ADDR_EXP 124
35933: PUSH
35934: LD_EXP 124
35938: PPUSH
35939: LD_VAR 0 4
35943: PPUSH
35944: EMPTY
35945: PPUSH
35946: CALL_OW 1
35950: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35951: LD_ADDR_EXP 125
35955: PUSH
35956: LD_EXP 125
35960: PPUSH
35961: LD_VAR 0 4
35965: PPUSH
35966: EMPTY
35967: PPUSH
35968: CALL_OW 1
35972: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35973: LD_ADDR_EXP 126
35977: PUSH
35978: LD_EXP 126
35982: PPUSH
35983: LD_VAR 0 4
35987: PPUSH
35988: EMPTY
35989: PPUSH
35990: CALL_OW 1
35994: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35995: LD_ADDR_EXP 128
35999: PUSH
36000: LD_EXP 128
36004: PPUSH
36005: LD_VAR 0 4
36009: PPUSH
36010: EMPTY
36011: PPUSH
36012: CALL_OW 1
36016: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36017: LD_ADDR_EXP 130
36021: PUSH
36022: LD_EXP 130
36026: PPUSH
36027: LD_VAR 0 4
36031: PPUSH
36032: EMPTY
36033: PPUSH
36034: CALL_OW 1
36038: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36039: LD_ADDR_EXP 131
36043: PUSH
36044: LD_EXP 131
36048: PPUSH
36049: LD_VAR 0 4
36053: PPUSH
36054: EMPTY
36055: PPUSH
36056: CALL_OW 1
36060: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36061: LD_ADDR_EXP 132
36065: PUSH
36066: LD_EXP 132
36070: PPUSH
36071: LD_VAR 0 4
36075: PPUSH
36076: EMPTY
36077: PPUSH
36078: CALL_OW 1
36082: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36083: LD_ADDR_EXP 133
36087: PUSH
36088: LD_EXP 133
36092: PPUSH
36093: LD_VAR 0 4
36097: PPUSH
36098: EMPTY
36099: PPUSH
36100: CALL_OW 1
36104: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36105: LD_ADDR_EXP 134
36109: PUSH
36110: LD_EXP 134
36114: PPUSH
36115: LD_VAR 0 4
36119: PPUSH
36120: EMPTY
36121: PPUSH
36122: CALL_OW 1
36126: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36127: LD_ADDR_EXP 135
36131: PUSH
36132: LD_EXP 135
36136: PPUSH
36137: LD_VAR 0 4
36141: PPUSH
36142: EMPTY
36143: PPUSH
36144: CALL_OW 1
36148: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36149: LD_ADDR_EXP 136
36153: PUSH
36154: LD_EXP 136
36158: PPUSH
36159: LD_VAR 0 4
36163: PPUSH
36164: EMPTY
36165: PPUSH
36166: CALL_OW 1
36170: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36171: LD_ADDR_EXP 137
36175: PUSH
36176: LD_EXP 137
36180: PPUSH
36181: LD_VAR 0 4
36185: PPUSH
36186: EMPTY
36187: PPUSH
36188: CALL_OW 1
36192: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36193: LD_ADDR_EXP 138
36197: PUSH
36198: LD_EXP 138
36202: PPUSH
36203: LD_VAR 0 4
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL_OW 1
36214: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36215: LD_ADDR_EXP 139
36219: PUSH
36220: LD_EXP 139
36224: PPUSH
36225: LD_VAR 0 4
36229: PPUSH
36230: EMPTY
36231: PPUSH
36232: CALL_OW 1
36236: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36237: LD_ADDR_EXP 140
36241: PUSH
36242: LD_EXP 140
36246: PPUSH
36247: LD_VAR 0 4
36251: PPUSH
36252: EMPTY
36253: PPUSH
36254: CALL_OW 1
36258: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36259: LD_ADDR_EXP 141
36263: PUSH
36264: LD_EXP 141
36268: PPUSH
36269: LD_VAR 0 4
36273: PPUSH
36274: EMPTY
36275: PPUSH
36276: CALL_OW 1
36280: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36281: LD_ADDR_EXP 142
36285: PUSH
36286: LD_EXP 142
36290: PPUSH
36291: LD_VAR 0 4
36295: PPUSH
36296: EMPTY
36297: PPUSH
36298: CALL_OW 1
36302: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36303: LD_ADDR_EXP 143
36307: PUSH
36308: LD_EXP 143
36312: PPUSH
36313: LD_VAR 0 4
36317: PPUSH
36318: LD_INT 0
36320: PPUSH
36321: CALL_OW 1
36325: ST_TO_ADDR
// result := base ;
36326: LD_ADDR_VAR 0 3
36330: PUSH
36331: LD_VAR 0 4
36335: ST_TO_ADDR
// end ;
36336: LD_VAR 0 3
36340: RET
// export function MC_Start ( ) ; var i ; begin
36341: LD_INT 0
36343: PPUSH
36344: PPUSH
// for i = 1 to mc_bases do
36345: LD_ADDR_VAR 0 2
36349: PUSH
36350: DOUBLE
36351: LD_INT 1
36353: DEC
36354: ST_TO_ADDR
36355: LD_EXP 101
36359: PUSH
36360: FOR_TO
36361: IFFALSE 37438
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36363: LD_ADDR_EXP 101
36367: PUSH
36368: LD_EXP 101
36372: PPUSH
36373: LD_VAR 0 2
36377: PPUSH
36378: LD_EXP 101
36382: PUSH
36383: LD_VAR 0 2
36387: ARRAY
36388: PUSH
36389: LD_INT 0
36391: DIFF
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36398: LD_ADDR_EXP 102
36402: PUSH
36403: LD_EXP 102
36407: PPUSH
36408: LD_VAR 0 2
36412: PPUSH
36413: EMPTY
36414: PPUSH
36415: CALL_OW 1
36419: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36420: LD_ADDR_EXP 103
36424: PUSH
36425: LD_EXP 103
36429: PPUSH
36430: LD_VAR 0 2
36434: PPUSH
36435: EMPTY
36436: PPUSH
36437: CALL_OW 1
36441: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36442: LD_ADDR_EXP 104
36446: PUSH
36447: LD_EXP 104
36451: PPUSH
36452: LD_VAR 0 2
36456: PPUSH
36457: EMPTY
36458: PPUSH
36459: CALL_OW 1
36463: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36464: LD_ADDR_EXP 105
36468: PUSH
36469: LD_EXP 105
36473: PPUSH
36474: LD_VAR 0 2
36478: PPUSH
36479: EMPTY
36480: PUSH
36481: EMPTY
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PPUSH
36487: CALL_OW 1
36491: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36492: LD_ADDR_EXP 106
36496: PUSH
36497: LD_EXP 106
36501: PPUSH
36502: LD_VAR 0 2
36506: PPUSH
36507: EMPTY
36508: PPUSH
36509: CALL_OW 1
36513: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36514: LD_ADDR_EXP 133
36518: PUSH
36519: LD_EXP 133
36523: PPUSH
36524: LD_VAR 0 2
36528: PPUSH
36529: EMPTY
36530: PPUSH
36531: CALL_OW 1
36535: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36536: LD_ADDR_EXP 107
36540: PUSH
36541: LD_EXP 107
36545: PPUSH
36546: LD_VAR 0 2
36550: PPUSH
36551: EMPTY
36552: PPUSH
36553: CALL_OW 1
36557: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36558: LD_ADDR_EXP 108
36562: PUSH
36563: LD_EXP 108
36567: PPUSH
36568: LD_VAR 0 2
36572: PPUSH
36573: EMPTY
36574: PPUSH
36575: CALL_OW 1
36579: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36580: LD_ADDR_EXP 109
36584: PUSH
36585: LD_EXP 109
36589: PPUSH
36590: LD_VAR 0 2
36594: PPUSH
36595: LD_EXP 101
36599: PUSH
36600: LD_VAR 0 2
36604: ARRAY
36605: PPUSH
36606: LD_INT 2
36608: PUSH
36609: LD_INT 30
36611: PUSH
36612: LD_INT 32
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 30
36621: PUSH
36622: LD_INT 33
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: LIST
36633: PPUSH
36634: CALL_OW 72
36638: PPUSH
36639: CALL_OW 1
36643: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36644: LD_ADDR_EXP 110
36648: PUSH
36649: LD_EXP 110
36653: PPUSH
36654: LD_VAR 0 2
36658: PPUSH
36659: LD_EXP 101
36663: PUSH
36664: LD_VAR 0 2
36668: ARRAY
36669: PPUSH
36670: LD_INT 2
36672: PUSH
36673: LD_INT 30
36675: PUSH
36676: LD_INT 32
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 30
36685: PUSH
36686: LD_INT 31
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 58
36700: PUSH
36701: EMPTY
36702: LIST
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PPUSH
36708: CALL_OW 72
36712: PPUSH
36713: CALL_OW 1
36717: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36718: LD_ADDR_EXP 111
36722: PUSH
36723: LD_EXP 111
36727: PPUSH
36728: LD_VAR 0 2
36732: PPUSH
36733: EMPTY
36734: PPUSH
36735: CALL_OW 1
36739: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36740: LD_ADDR_EXP 115
36744: PUSH
36745: LD_EXP 115
36749: PPUSH
36750: LD_VAR 0 2
36754: PPUSH
36755: EMPTY
36756: PPUSH
36757: CALL_OW 1
36761: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36762: LD_ADDR_EXP 114
36766: PUSH
36767: LD_EXP 114
36771: PPUSH
36772: LD_VAR 0 2
36776: PPUSH
36777: EMPTY
36778: PPUSH
36779: CALL_OW 1
36783: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36784: LD_ADDR_EXP 116
36788: PUSH
36789: LD_EXP 116
36793: PPUSH
36794: LD_VAR 0 2
36798: PPUSH
36799: EMPTY
36800: PPUSH
36801: CALL_OW 1
36805: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36806: LD_ADDR_EXP 117
36810: PUSH
36811: LD_EXP 117
36815: PPUSH
36816: LD_VAR 0 2
36820: PPUSH
36821: EMPTY
36822: PPUSH
36823: CALL_OW 1
36827: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36828: LD_ADDR_EXP 118
36832: PUSH
36833: LD_EXP 118
36837: PPUSH
36838: LD_VAR 0 2
36842: PPUSH
36843: EMPTY
36844: PPUSH
36845: CALL_OW 1
36849: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36850: LD_ADDR_EXP 119
36854: PUSH
36855: LD_EXP 119
36859: PPUSH
36860: LD_VAR 0 2
36864: PPUSH
36865: EMPTY
36866: PPUSH
36867: CALL_OW 1
36871: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36872: LD_ADDR_EXP 120
36876: PUSH
36877: LD_EXP 120
36881: PPUSH
36882: LD_VAR 0 2
36886: PPUSH
36887: EMPTY
36888: PPUSH
36889: CALL_OW 1
36893: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36894: LD_ADDR_EXP 121
36898: PUSH
36899: LD_EXP 121
36903: PPUSH
36904: LD_VAR 0 2
36908: PPUSH
36909: EMPTY
36910: PPUSH
36911: CALL_OW 1
36915: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36916: LD_ADDR_EXP 122
36920: PUSH
36921: LD_EXP 122
36925: PPUSH
36926: LD_VAR 0 2
36930: PPUSH
36931: EMPTY
36932: PPUSH
36933: CALL_OW 1
36937: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36938: LD_ADDR_EXP 123
36942: PUSH
36943: LD_EXP 123
36947: PPUSH
36948: LD_VAR 0 2
36952: PPUSH
36953: EMPTY
36954: PPUSH
36955: CALL_OW 1
36959: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36960: LD_ADDR_EXP 112
36964: PUSH
36965: LD_EXP 112
36969: PPUSH
36970: LD_VAR 0 2
36974: PPUSH
36975: LD_INT 0
36977: PPUSH
36978: CALL_OW 1
36982: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36983: LD_ADDR_EXP 125
36987: PUSH
36988: LD_EXP 125
36992: PPUSH
36993: LD_VAR 0 2
36997: PPUSH
36998: LD_INT 0
37000: PPUSH
37001: CALL_OW 1
37005: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37006: LD_ADDR_EXP 113
37010: PUSH
37011: LD_EXP 113
37015: PPUSH
37016: LD_VAR 0 2
37020: PPUSH
37021: EMPTY
37022: PPUSH
37023: CALL_OW 1
37027: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37028: LD_ADDR_EXP 124
37032: PUSH
37033: LD_EXP 124
37037: PPUSH
37038: LD_VAR 0 2
37042: PPUSH
37043: LD_INT 0
37045: PPUSH
37046: CALL_OW 1
37050: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37051: LD_ADDR_EXP 126
37055: PUSH
37056: LD_EXP 126
37060: PPUSH
37061: LD_VAR 0 2
37065: PPUSH
37066: EMPTY
37067: PPUSH
37068: CALL_OW 1
37072: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37073: LD_ADDR_EXP 129
37077: PUSH
37078: LD_EXP 129
37082: PPUSH
37083: LD_VAR 0 2
37087: PPUSH
37088: LD_INT 0
37090: PPUSH
37091: CALL_OW 1
37095: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37096: LD_ADDR_EXP 130
37100: PUSH
37101: LD_EXP 130
37105: PPUSH
37106: LD_VAR 0 2
37110: PPUSH
37111: EMPTY
37112: PPUSH
37113: CALL_OW 1
37117: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37118: LD_ADDR_EXP 131
37122: PUSH
37123: LD_EXP 131
37127: PPUSH
37128: LD_VAR 0 2
37132: PPUSH
37133: EMPTY
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37140: LD_ADDR_EXP 132
37144: PUSH
37145: LD_EXP 132
37149: PPUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: EMPTY
37156: PPUSH
37157: CALL_OW 1
37161: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37162: LD_ADDR_EXP 134
37166: PUSH
37167: LD_EXP 134
37171: PPUSH
37172: LD_VAR 0 2
37176: PPUSH
37177: LD_EXP 101
37181: PUSH
37182: LD_VAR 0 2
37186: ARRAY
37187: PPUSH
37188: LD_INT 2
37190: PUSH
37191: LD_INT 30
37193: PUSH
37194: LD_INT 6
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 30
37203: PUSH
37204: LD_INT 7
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PUSH
37211: LD_INT 30
37213: PUSH
37214: LD_INT 8
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: PPUSH
37227: CALL_OW 72
37231: PPUSH
37232: CALL_OW 1
37236: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37237: LD_ADDR_EXP 135
37241: PUSH
37242: LD_EXP 135
37246: PPUSH
37247: LD_VAR 0 2
37251: PPUSH
37252: EMPTY
37253: PPUSH
37254: CALL_OW 1
37258: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37259: LD_ADDR_EXP 136
37263: PUSH
37264: LD_EXP 136
37268: PPUSH
37269: LD_VAR 0 2
37273: PPUSH
37274: EMPTY
37275: PPUSH
37276: CALL_OW 1
37280: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37281: LD_ADDR_EXP 137
37285: PUSH
37286: LD_EXP 137
37290: PPUSH
37291: LD_VAR 0 2
37295: PPUSH
37296: EMPTY
37297: PPUSH
37298: CALL_OW 1
37302: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37303: LD_ADDR_EXP 138
37307: PUSH
37308: LD_EXP 138
37312: PPUSH
37313: LD_VAR 0 2
37317: PPUSH
37318: EMPTY
37319: PPUSH
37320: CALL_OW 1
37324: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37325: LD_ADDR_EXP 139
37329: PUSH
37330: LD_EXP 139
37334: PPUSH
37335: LD_VAR 0 2
37339: PPUSH
37340: EMPTY
37341: PPUSH
37342: CALL_OW 1
37346: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37347: LD_ADDR_EXP 140
37351: PUSH
37352: LD_EXP 140
37356: PPUSH
37357: LD_VAR 0 2
37361: PPUSH
37362: EMPTY
37363: PPUSH
37364: CALL_OW 1
37368: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37369: LD_ADDR_EXP 141
37373: PUSH
37374: LD_EXP 141
37378: PPUSH
37379: LD_VAR 0 2
37383: PPUSH
37384: EMPTY
37385: PPUSH
37386: CALL_OW 1
37390: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37391: LD_ADDR_EXP 142
37395: PUSH
37396: LD_EXP 142
37400: PPUSH
37401: LD_VAR 0 2
37405: PPUSH
37406: EMPTY
37407: PPUSH
37408: CALL_OW 1
37412: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37413: LD_ADDR_EXP 143
37417: PUSH
37418: LD_EXP 143
37422: PPUSH
37423: LD_VAR 0 2
37427: PPUSH
37428: LD_INT 0
37430: PPUSH
37431: CALL_OW 1
37435: ST_TO_ADDR
// end ;
37436: GO 36360
37438: POP
37439: POP
// MC_InitSides ( ) ;
37440: CALL 37726 0 0
// MC_InitResearch ( ) ;
37444: CALL 37465 0 0
// CustomInitMacro ( ) ;
37448: CALL 460 0 0
// skirmish := true ;
37452: LD_ADDR_EXP 99
37456: PUSH
37457: LD_INT 1
37459: ST_TO_ADDR
// end ;
37460: LD_VAR 0 1
37464: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37465: LD_INT 0
37467: PPUSH
37468: PPUSH
37469: PPUSH
37470: PPUSH
37471: PPUSH
37472: PPUSH
// if not mc_bases then
37473: LD_EXP 101
37477: NOT
37478: IFFALSE 37482
// exit ;
37480: GO 37721
// for i = 1 to 8 do
37482: LD_ADDR_VAR 0 2
37486: PUSH
37487: DOUBLE
37488: LD_INT 1
37490: DEC
37491: ST_TO_ADDR
37492: LD_INT 8
37494: PUSH
37495: FOR_TO
37496: IFFALSE 37522
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37498: LD_ADDR_EXP 128
37502: PUSH
37503: LD_EXP 128
37507: PPUSH
37508: LD_VAR 0 2
37512: PPUSH
37513: EMPTY
37514: PPUSH
37515: CALL_OW 1
37519: ST_TO_ADDR
37520: GO 37495
37522: POP
37523: POP
// tmp := [ ] ;
37524: LD_ADDR_VAR 0 5
37528: PUSH
37529: EMPTY
37530: ST_TO_ADDR
// for i = 1 to mc_sides do
37531: LD_ADDR_VAR 0 2
37535: PUSH
37536: DOUBLE
37537: LD_INT 1
37539: DEC
37540: ST_TO_ADDR
37541: LD_EXP 127
37545: PUSH
37546: FOR_TO
37547: IFFALSE 37605
// if not mc_sides [ i ] in tmp then
37549: LD_EXP 127
37553: PUSH
37554: LD_VAR 0 2
37558: ARRAY
37559: PUSH
37560: LD_VAR 0 5
37564: IN
37565: NOT
37566: IFFALSE 37603
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37568: LD_ADDR_VAR 0 5
37572: PUSH
37573: LD_VAR 0 5
37577: PPUSH
37578: LD_VAR 0 5
37582: PUSH
37583: LD_INT 1
37585: PLUS
37586: PPUSH
37587: LD_EXP 127
37591: PUSH
37592: LD_VAR 0 2
37596: ARRAY
37597: PPUSH
37598: CALL_OW 2
37602: ST_TO_ADDR
37603: GO 37546
37605: POP
37606: POP
// if not tmp then
37607: LD_VAR 0 5
37611: NOT
37612: IFFALSE 37616
// exit ;
37614: GO 37721
// for j in tmp do
37616: LD_ADDR_VAR 0 3
37620: PUSH
37621: LD_VAR 0 5
37625: PUSH
37626: FOR_IN
37627: IFFALSE 37719
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37629: LD_ADDR_VAR 0 6
37633: PUSH
37634: LD_INT 22
37636: PUSH
37637: LD_VAR 0 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PPUSH
37646: CALL_OW 69
37650: ST_TO_ADDR
// if not un then
37651: LD_VAR 0 6
37655: NOT
37656: IFFALSE 37660
// continue ;
37658: GO 37626
// nation := GetNation ( un [ 1 ] ) ;
37660: LD_ADDR_VAR 0 4
37664: PUSH
37665: LD_VAR 0 6
37669: PUSH
37670: LD_INT 1
37672: ARRAY
37673: PPUSH
37674: CALL_OW 248
37678: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37679: LD_ADDR_EXP 128
37683: PUSH
37684: LD_EXP 128
37688: PPUSH
37689: LD_VAR 0 3
37693: PPUSH
37694: LD_VAR 0 3
37698: PPUSH
37699: LD_VAR 0 4
37703: PPUSH
37704: LD_INT 1
37706: PPUSH
37707: CALL 64435 0 3
37711: PPUSH
37712: CALL_OW 1
37716: ST_TO_ADDR
// end ;
37717: GO 37626
37719: POP
37720: POP
// end ;
37721: LD_VAR 0 1
37725: RET
// export function MC_InitSides ( ) ; var i ; begin
37726: LD_INT 0
37728: PPUSH
37729: PPUSH
// if not mc_bases then
37730: LD_EXP 101
37734: NOT
37735: IFFALSE 37739
// exit ;
37737: GO 37813
// for i = 1 to mc_bases do
37739: LD_ADDR_VAR 0 2
37743: PUSH
37744: DOUBLE
37745: LD_INT 1
37747: DEC
37748: ST_TO_ADDR
37749: LD_EXP 101
37753: PUSH
37754: FOR_TO
37755: IFFALSE 37811
// if mc_bases [ i ] then
37757: LD_EXP 101
37761: PUSH
37762: LD_VAR 0 2
37766: ARRAY
37767: IFFALSE 37809
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37769: LD_ADDR_EXP 127
37773: PUSH
37774: LD_EXP 127
37778: PPUSH
37779: LD_VAR 0 2
37783: PPUSH
37784: LD_EXP 101
37788: PUSH
37789: LD_VAR 0 2
37793: ARRAY
37794: PUSH
37795: LD_INT 1
37797: ARRAY
37798: PPUSH
37799: CALL_OW 255
37803: PPUSH
37804: CALL_OW 1
37808: ST_TO_ADDR
37809: GO 37754
37811: POP
37812: POP
// end ;
37813: LD_VAR 0 1
37817: RET
// every 0 0$01 trigger skirmish do
37818: LD_EXP 99
37822: IFFALSE 37976
37824: GO 37826
37826: DISABLE
// begin enable ;
37827: ENABLE
// MC_CheckBuildings ( ) ;
37828: CALL 42474 0 0
// MC_CheckPeopleLife ( ) ;
37832: CALL 42599 0 0
// RaiseSailEvent ( 100 ) ;
37836: LD_INT 100
37838: PPUSH
37839: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37843: LD_INT 103
37845: PPUSH
37846: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37850: LD_INT 104
37852: PPUSH
37853: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37857: LD_INT 105
37859: PPUSH
37860: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37864: LD_INT 106
37866: PPUSH
37867: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37871: LD_INT 107
37873: PPUSH
37874: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37878: LD_INT 108
37880: PPUSH
37881: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37885: LD_INT 109
37887: PPUSH
37888: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37892: LD_INT 110
37894: PPUSH
37895: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37899: LD_INT 111
37901: PPUSH
37902: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37906: LD_INT 112
37908: PPUSH
37909: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37913: LD_INT 113
37915: PPUSH
37916: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37920: LD_INT 120
37922: PPUSH
37923: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37927: LD_INT 121
37929: PPUSH
37930: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37934: LD_INT 122
37936: PPUSH
37937: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37941: LD_INT 123
37943: PPUSH
37944: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37948: LD_INT 124
37950: PPUSH
37951: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37955: LD_INT 125
37957: PPUSH
37958: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37962: LD_INT 126
37964: PPUSH
37965: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37969: LD_INT 200
37971: PPUSH
37972: CALL_OW 427
// end ;
37976: END
// on SailEvent ( event ) do begin if event < 100 then
37977: LD_VAR 0 1
37981: PUSH
37982: LD_INT 100
37984: LESS
37985: IFFALSE 37996
// CustomEvent ( event ) ;
37987: LD_VAR 0 1
37991: PPUSH
37992: CALL 32636 0 1
// if event = 100 then
37996: LD_VAR 0 1
38000: PUSH
38001: LD_INT 100
38003: EQUAL
38004: IFFALSE 38010
// MC_ClassManager ( ) ;
38006: CALL 38402 0 0
// if event = 101 then
38010: LD_VAR 0 1
38014: PUSH
38015: LD_INT 101
38017: EQUAL
38018: IFFALSE 38024
// MC_RepairBuildings ( ) ;
38020: CALL 43195 0 0
// if event = 102 then
38024: LD_VAR 0 1
38028: PUSH
38029: LD_INT 102
38031: EQUAL
38032: IFFALSE 38038
// MC_Heal ( ) ;
38034: CALL 43927 0 0
// if event = 103 then
38038: LD_VAR 0 1
38042: PUSH
38043: LD_INT 103
38045: EQUAL
38046: IFFALSE 38052
// MC_Build ( ) ;
38048: CALL 44349 0 0
// if event = 104 then
38052: LD_VAR 0 1
38056: PUSH
38057: LD_INT 104
38059: EQUAL
38060: IFFALSE 38066
// MC_TurretWeapon ( ) ;
38062: CALL 45962 0 0
// if event = 105 then
38066: LD_VAR 0 1
38070: PUSH
38071: LD_INT 105
38073: EQUAL
38074: IFFALSE 38080
// MC_BuildUpgrade ( ) ;
38076: CALL 45513 0 0
// if event = 106 then
38080: LD_VAR 0 1
38084: PUSH
38085: LD_INT 106
38087: EQUAL
38088: IFFALSE 38094
// MC_PlantMines ( ) ;
38090: CALL 46392 0 0
// if event = 107 then
38094: LD_VAR 0 1
38098: PUSH
38099: LD_INT 107
38101: EQUAL
38102: IFFALSE 38108
// MC_CollectCrates ( ) ;
38104: CALL 47426 0 0
// if event = 108 then
38108: LD_VAR 0 1
38112: PUSH
38113: LD_INT 108
38115: EQUAL
38116: IFFALSE 38122
// MC_LinkRemoteControl ( ) ;
38118: CALL 49202 0 0
// if event = 109 then
38122: LD_VAR 0 1
38126: PUSH
38127: LD_INT 109
38129: EQUAL
38130: IFFALSE 38136
// MC_ProduceVehicle ( ) ;
38132: CALL 49383 0 0
// if event = 110 then
38136: LD_VAR 0 1
38140: PUSH
38141: LD_INT 110
38143: EQUAL
38144: IFFALSE 38150
// MC_SendAttack ( ) ;
38146: CALL 49849 0 0
// if event = 111 then
38150: LD_VAR 0 1
38154: PUSH
38155: LD_INT 111
38157: EQUAL
38158: IFFALSE 38164
// MC_Defend ( ) ;
38160: CALL 49957 0 0
// if event = 112 then
38164: LD_VAR 0 1
38168: PUSH
38169: LD_INT 112
38171: EQUAL
38172: IFFALSE 38178
// MC_Research ( ) ;
38174: CALL 50562 0 0
// if event = 113 then
38178: LD_VAR 0 1
38182: PUSH
38183: LD_INT 113
38185: EQUAL
38186: IFFALSE 38192
// MC_MinesTrigger ( ) ;
38188: CALL 51676 0 0
// if event = 120 then
38192: LD_VAR 0 1
38196: PUSH
38197: LD_INT 120
38199: EQUAL
38200: IFFALSE 38206
// MC_RepairVehicle ( ) ;
38202: CALL 51775 0 0
// if event = 121 then
38206: LD_VAR 0 1
38210: PUSH
38211: LD_INT 121
38213: EQUAL
38214: IFFALSE 38220
// MC_TameApe ( ) ;
38216: CALL 52505 0 0
// if event = 122 then
38220: LD_VAR 0 1
38224: PUSH
38225: LD_INT 122
38227: EQUAL
38228: IFFALSE 38234
// MC_ChangeApeClass ( ) ;
38230: CALL 53334 0 0
// if event = 123 then
38234: LD_VAR 0 1
38238: PUSH
38239: LD_INT 123
38241: EQUAL
38242: IFFALSE 38248
// MC_Bazooka ( ) ;
38244: CALL 53984 0 0
// if event = 124 then
38248: LD_VAR 0 1
38252: PUSH
38253: LD_INT 124
38255: EQUAL
38256: IFFALSE 38262
// MC_TeleportExit ( ) ;
38258: CALL 54182 0 0
// if event = 125 then
38262: LD_VAR 0 1
38266: PUSH
38267: LD_INT 125
38269: EQUAL
38270: IFFALSE 38276
// MC_Deposits ( ) ;
38272: CALL 54829 0 0
// if event = 126 then
38276: LD_VAR 0 1
38280: PUSH
38281: LD_INT 126
38283: EQUAL
38284: IFFALSE 38290
// MC_RemoteDriver ( ) ;
38286: CALL 55454 0 0
// if event = 200 then
38290: LD_VAR 0 1
38294: PUSH
38295: LD_INT 200
38297: EQUAL
38298: IFFALSE 38304
// MC_Idle ( ) ;
38300: CALL 57403 0 0
// end ;
38304: PPOPN 1
38306: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38307: LD_INT 0
38309: PPUSH
38310: PPUSH
// if not mc_bases [ base ] or not tag then
38311: LD_EXP 101
38315: PUSH
38316: LD_VAR 0 1
38320: ARRAY
38321: NOT
38322: PUSH
38323: LD_VAR 0 2
38327: NOT
38328: OR
38329: IFFALSE 38333
// exit ;
38331: GO 38397
// for i in mc_bases [ base ] union mc_ape [ base ] do
38333: LD_ADDR_VAR 0 4
38337: PUSH
38338: LD_EXP 101
38342: PUSH
38343: LD_VAR 0 1
38347: ARRAY
38348: PUSH
38349: LD_EXP 130
38353: PUSH
38354: LD_VAR 0 1
38358: ARRAY
38359: UNION
38360: PUSH
38361: FOR_IN
38362: IFFALSE 38395
// if GetTag ( i ) = tag then
38364: LD_VAR 0 4
38368: PPUSH
38369: CALL_OW 110
38373: PUSH
38374: LD_VAR 0 2
38378: EQUAL
38379: IFFALSE 38393
// SetTag ( i , 0 ) ;
38381: LD_VAR 0 4
38385: PPUSH
38386: LD_INT 0
38388: PPUSH
38389: CALL_OW 109
38393: GO 38361
38395: POP
38396: POP
// end ;
38397: LD_VAR 0 3
38401: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38402: LD_INT 0
38404: PPUSH
38405: PPUSH
38406: PPUSH
38407: PPUSH
38408: PPUSH
38409: PPUSH
38410: PPUSH
38411: PPUSH
// if not mc_bases then
38412: LD_EXP 101
38416: NOT
38417: IFFALSE 38421
// exit ;
38419: GO 38879
// for i = 1 to mc_bases do
38421: LD_ADDR_VAR 0 2
38425: PUSH
38426: DOUBLE
38427: LD_INT 1
38429: DEC
38430: ST_TO_ADDR
38431: LD_EXP 101
38435: PUSH
38436: FOR_TO
38437: IFFALSE 38877
// begin tmp := MC_ClassCheckReq ( i ) ;
38439: LD_ADDR_VAR 0 4
38443: PUSH
38444: LD_VAR 0 2
38448: PPUSH
38449: CALL 38884 0 1
38453: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38454: LD_ADDR_EXP 142
38458: PUSH
38459: LD_EXP 142
38463: PPUSH
38464: LD_VAR 0 2
38468: PPUSH
38469: LD_VAR 0 4
38473: PPUSH
38474: CALL_OW 1
38478: ST_TO_ADDR
// if not tmp then
38479: LD_VAR 0 4
38483: NOT
38484: IFFALSE 38488
// continue ;
38486: GO 38436
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38488: LD_ADDR_VAR 0 6
38492: PUSH
38493: LD_EXP 101
38497: PUSH
38498: LD_VAR 0 2
38502: ARRAY
38503: PPUSH
38504: LD_INT 2
38506: PUSH
38507: LD_INT 30
38509: PUSH
38510: LD_INT 4
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 30
38519: PUSH
38520: LD_INT 5
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: PPUSH
38532: CALL_OW 72
38536: PUSH
38537: LD_EXP 101
38541: PUSH
38542: LD_VAR 0 2
38546: ARRAY
38547: PPUSH
38548: LD_INT 2
38550: PUSH
38551: LD_INT 30
38553: PUSH
38554: LD_INT 0
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 30
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: PPUSH
38576: CALL_OW 72
38580: PUSH
38581: LD_EXP 101
38585: PUSH
38586: LD_VAR 0 2
38590: ARRAY
38591: PPUSH
38592: LD_INT 30
38594: PUSH
38595: LD_INT 3
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PPUSH
38602: CALL_OW 72
38606: PUSH
38607: LD_EXP 101
38611: PUSH
38612: LD_VAR 0 2
38616: ARRAY
38617: PPUSH
38618: LD_INT 2
38620: PUSH
38621: LD_INT 30
38623: PUSH
38624: LD_INT 6
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 30
38633: PUSH
38634: LD_INT 7
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 30
38643: PUSH
38644: LD_INT 8
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: PPUSH
38657: CALL_OW 72
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: ST_TO_ADDR
// for j = 1 to 4 do
38668: LD_ADDR_VAR 0 3
38672: PUSH
38673: DOUBLE
38674: LD_INT 1
38676: DEC
38677: ST_TO_ADDR
38678: LD_INT 4
38680: PUSH
38681: FOR_TO
38682: IFFALSE 38873
// begin if not tmp [ j ] then
38684: LD_VAR 0 4
38688: PUSH
38689: LD_VAR 0 3
38693: ARRAY
38694: NOT
38695: IFFALSE 38699
// continue ;
38697: GO 38681
// for p in tmp [ j ] do
38699: LD_ADDR_VAR 0 5
38703: PUSH
38704: LD_VAR 0 4
38708: PUSH
38709: LD_VAR 0 3
38713: ARRAY
38714: PUSH
38715: FOR_IN
38716: IFFALSE 38869
// begin if not b [ j ] then
38718: LD_VAR 0 6
38722: PUSH
38723: LD_VAR 0 3
38727: ARRAY
38728: NOT
38729: IFFALSE 38733
// break ;
38731: GO 38869
// e := 0 ;
38733: LD_ADDR_VAR 0 7
38737: PUSH
38738: LD_INT 0
38740: ST_TO_ADDR
// for k in b [ j ] do
38741: LD_ADDR_VAR 0 8
38745: PUSH
38746: LD_VAR 0 6
38750: PUSH
38751: LD_VAR 0 3
38755: ARRAY
38756: PUSH
38757: FOR_IN
38758: IFFALSE 38785
// if IsNotFull ( k ) then
38760: LD_VAR 0 8
38764: PPUSH
38765: CALL 68875 0 1
38769: IFFALSE 38783
// begin e := k ;
38771: LD_ADDR_VAR 0 7
38775: PUSH
38776: LD_VAR 0 8
38780: ST_TO_ADDR
// break ;
38781: GO 38785
// end ;
38783: GO 38757
38785: POP
38786: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38787: LD_VAR 0 7
38791: PUSH
38792: LD_VAR 0 5
38796: PPUSH
38797: LD_VAR 0 7
38801: PPUSH
38802: CALL 105994 0 2
38806: NOT
38807: AND
38808: IFFALSE 38867
// begin if IsInUnit ( p ) then
38810: LD_VAR 0 5
38814: PPUSH
38815: CALL_OW 310
38819: IFFALSE 38830
// ComExitBuilding ( p ) ;
38821: LD_VAR 0 5
38825: PPUSH
38826: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38830: LD_VAR 0 5
38834: PPUSH
38835: LD_VAR 0 7
38839: PPUSH
38840: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38844: LD_VAR 0 5
38848: PPUSH
38849: LD_VAR 0 3
38853: PPUSH
38854: CALL_OW 183
// AddComExitBuilding ( p ) ;
38858: LD_VAR 0 5
38862: PPUSH
38863: CALL_OW 182
// end ; end ;
38867: GO 38715
38869: POP
38870: POP
// end ;
38871: GO 38681
38873: POP
38874: POP
// end ;
38875: GO 38436
38877: POP
38878: POP
// end ;
38879: LD_VAR 0 1
38883: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38884: LD_INT 0
38886: PPUSH
38887: PPUSH
38888: PPUSH
38889: PPUSH
38890: PPUSH
38891: PPUSH
38892: PPUSH
38893: PPUSH
38894: PPUSH
38895: PPUSH
38896: PPUSH
38897: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38898: LD_VAR 0 1
38902: NOT
38903: PUSH
38904: LD_EXP 101
38908: PUSH
38909: LD_VAR 0 1
38913: ARRAY
38914: NOT
38915: OR
38916: PUSH
38917: LD_EXP 101
38921: PUSH
38922: LD_VAR 0 1
38926: ARRAY
38927: PPUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 30
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 30
38943: PUSH
38944: LD_INT 1
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: LIST
38955: PPUSH
38956: CALL_OW 72
38960: NOT
38961: OR
38962: IFFALSE 38966
// exit ;
38964: GO 42469
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38966: LD_ADDR_VAR 0 4
38970: PUSH
38971: LD_EXP 101
38975: PUSH
38976: LD_VAR 0 1
38980: ARRAY
38981: PPUSH
38982: LD_INT 2
38984: PUSH
38985: LD_INT 25
38987: PUSH
38988: LD_INT 1
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 25
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 25
39007: PUSH
39008: LD_INT 3
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 25
39017: PUSH
39018: LD_INT 4
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 25
39027: PUSH
39028: LD_INT 5
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 25
39037: PUSH
39038: LD_INT 8
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 25
39047: PUSH
39048: LD_INT 9
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: PPUSH
39065: CALL_OW 72
39069: ST_TO_ADDR
// if not tmp then
39070: LD_VAR 0 4
39074: NOT
39075: IFFALSE 39079
// exit ;
39077: GO 42469
// for i in tmp do
39079: LD_ADDR_VAR 0 3
39083: PUSH
39084: LD_VAR 0 4
39088: PUSH
39089: FOR_IN
39090: IFFALSE 39121
// if GetTag ( i ) then
39092: LD_VAR 0 3
39096: PPUSH
39097: CALL_OW 110
39101: IFFALSE 39119
// tmp := tmp diff i ;
39103: LD_ADDR_VAR 0 4
39107: PUSH
39108: LD_VAR 0 4
39112: PUSH
39113: LD_VAR 0 3
39117: DIFF
39118: ST_TO_ADDR
39119: GO 39089
39121: POP
39122: POP
// if not tmp then
39123: LD_VAR 0 4
39127: NOT
39128: IFFALSE 39132
// exit ;
39130: GO 42469
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39132: LD_ADDR_VAR 0 5
39136: PUSH
39137: LD_EXP 101
39141: PUSH
39142: LD_VAR 0 1
39146: ARRAY
39147: PPUSH
39148: LD_INT 2
39150: PUSH
39151: LD_INT 25
39153: PUSH
39154: LD_INT 1
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: LD_INT 25
39163: PUSH
39164: LD_INT 5
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 25
39173: PUSH
39174: LD_INT 8
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 25
39183: PUSH
39184: LD_INT 9
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: PPUSH
39198: CALL_OW 72
39202: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39203: LD_ADDR_VAR 0 6
39207: PUSH
39208: LD_EXP 101
39212: PUSH
39213: LD_VAR 0 1
39217: ARRAY
39218: PPUSH
39219: LD_INT 25
39221: PUSH
39222: LD_INT 2
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PPUSH
39229: CALL_OW 72
39233: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39234: LD_ADDR_VAR 0 7
39238: PUSH
39239: LD_EXP 101
39243: PUSH
39244: LD_VAR 0 1
39248: ARRAY
39249: PPUSH
39250: LD_INT 25
39252: PUSH
39253: LD_INT 3
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PPUSH
39260: CALL_OW 72
39264: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39265: LD_ADDR_VAR 0 8
39269: PUSH
39270: LD_EXP 101
39274: PUSH
39275: LD_VAR 0 1
39279: ARRAY
39280: PPUSH
39281: LD_INT 25
39283: PUSH
39284: LD_INT 4
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 24
39293: PUSH
39294: LD_INT 251
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PPUSH
39305: CALL_OW 72
39309: ST_TO_ADDR
// if mc_scan [ base ] then
39310: LD_EXP 124
39314: PUSH
39315: LD_VAR 0 1
39319: ARRAY
39320: IFFALSE 39781
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39322: LD_ADDR_EXP 143
39326: PUSH
39327: LD_EXP 143
39331: PPUSH
39332: LD_VAR 0 1
39336: PPUSH
39337: LD_INT 4
39339: PPUSH
39340: CALL_OW 1
39344: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39345: LD_ADDR_VAR 0 12
39349: PUSH
39350: LD_EXP 101
39354: PUSH
39355: LD_VAR 0 1
39359: ARRAY
39360: PPUSH
39361: LD_INT 2
39363: PUSH
39364: LD_INT 30
39366: PUSH
39367: LD_INT 4
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 30
39376: PUSH
39377: LD_INT 5
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: LIST
39388: PPUSH
39389: CALL_OW 72
39393: ST_TO_ADDR
// if not b then
39394: LD_VAR 0 12
39398: NOT
39399: IFFALSE 39403
// exit ;
39401: GO 42469
// p := [ ] ;
39403: LD_ADDR_VAR 0 11
39407: PUSH
39408: EMPTY
39409: ST_TO_ADDR
// if sci >= 2 then
39410: LD_VAR 0 8
39414: PUSH
39415: LD_INT 2
39417: GREATEREQUAL
39418: IFFALSE 39449
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39420: LD_ADDR_VAR 0 8
39424: PUSH
39425: LD_VAR 0 8
39429: PUSH
39430: LD_INT 1
39432: ARRAY
39433: PUSH
39434: LD_VAR 0 8
39438: PUSH
39439: LD_INT 2
39441: ARRAY
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: ST_TO_ADDR
39447: GO 39510
// if sci = 1 then
39449: LD_VAR 0 8
39453: PUSH
39454: LD_INT 1
39456: EQUAL
39457: IFFALSE 39478
// sci := [ sci [ 1 ] ] else
39459: LD_ADDR_VAR 0 8
39463: PUSH
39464: LD_VAR 0 8
39468: PUSH
39469: LD_INT 1
39471: ARRAY
39472: PUSH
39473: EMPTY
39474: LIST
39475: ST_TO_ADDR
39476: GO 39510
// if sci = 0 then
39478: LD_VAR 0 8
39482: PUSH
39483: LD_INT 0
39485: EQUAL
39486: IFFALSE 39510
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39488: LD_ADDR_VAR 0 11
39492: PUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_INT 4
39500: PPUSH
39501: CALL 105857 0 2
39505: PUSH
39506: LD_INT 1
39508: ARRAY
39509: ST_TO_ADDR
// if eng > 4 then
39510: LD_VAR 0 6
39514: PUSH
39515: LD_INT 4
39517: GREATER
39518: IFFALSE 39564
// for i = eng downto 4 do
39520: LD_ADDR_VAR 0 3
39524: PUSH
39525: DOUBLE
39526: LD_VAR 0 6
39530: INC
39531: ST_TO_ADDR
39532: LD_INT 4
39534: PUSH
39535: FOR_DOWNTO
39536: IFFALSE 39562
// eng := eng diff eng [ i ] ;
39538: LD_ADDR_VAR 0 6
39542: PUSH
39543: LD_VAR 0 6
39547: PUSH
39548: LD_VAR 0 6
39552: PUSH
39553: LD_VAR 0 3
39557: ARRAY
39558: DIFF
39559: ST_TO_ADDR
39560: GO 39535
39562: POP
39563: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39564: LD_ADDR_VAR 0 4
39568: PUSH
39569: LD_VAR 0 4
39573: PUSH
39574: LD_VAR 0 5
39578: PUSH
39579: LD_VAR 0 6
39583: UNION
39584: PUSH
39585: LD_VAR 0 7
39589: UNION
39590: PUSH
39591: LD_VAR 0 8
39595: UNION
39596: DIFF
39597: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39598: LD_ADDR_VAR 0 13
39602: PUSH
39603: LD_EXP 101
39607: PUSH
39608: LD_VAR 0 1
39612: ARRAY
39613: PPUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 30
39619: PUSH
39620: LD_INT 32
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 30
39629: PUSH
39630: LD_INT 31
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: PPUSH
39642: CALL_OW 72
39646: PUSH
39647: LD_EXP 101
39651: PUSH
39652: LD_VAR 0 1
39656: ARRAY
39657: PPUSH
39658: LD_INT 2
39660: PUSH
39661: LD_INT 30
39663: PUSH
39664: LD_INT 4
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 30
39673: PUSH
39674: LD_INT 5
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: LIST
39685: PPUSH
39686: CALL_OW 72
39690: PUSH
39691: LD_INT 6
39693: MUL
39694: PLUS
39695: ST_TO_ADDR
// if bcount < tmp then
39696: LD_VAR 0 13
39700: PUSH
39701: LD_VAR 0 4
39705: LESS
39706: IFFALSE 39752
// for i = tmp downto bcount do
39708: LD_ADDR_VAR 0 3
39712: PUSH
39713: DOUBLE
39714: LD_VAR 0 4
39718: INC
39719: ST_TO_ADDR
39720: LD_VAR 0 13
39724: PUSH
39725: FOR_DOWNTO
39726: IFFALSE 39750
// tmp := Delete ( tmp , tmp ) ;
39728: LD_ADDR_VAR 0 4
39732: PUSH
39733: LD_VAR 0 4
39737: PPUSH
39738: LD_VAR 0 4
39742: PPUSH
39743: CALL_OW 3
39747: ST_TO_ADDR
39748: GO 39725
39750: POP
39751: POP
// result := [ tmp , 0 , 0 , p ] ;
39752: LD_ADDR_VAR 0 2
39756: PUSH
39757: LD_VAR 0 4
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: LD_INT 0
39767: PUSH
39768: LD_VAR 0 11
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: ST_TO_ADDR
// exit ;
39779: GO 42469
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39781: LD_EXP 101
39785: PUSH
39786: LD_VAR 0 1
39790: ARRAY
39791: PPUSH
39792: LD_INT 2
39794: PUSH
39795: LD_INT 30
39797: PUSH
39798: LD_INT 6
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 30
39807: PUSH
39808: LD_INT 7
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 30
39817: PUSH
39818: LD_INT 8
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: PPUSH
39831: CALL_OW 72
39835: NOT
39836: PUSH
39837: LD_EXP 101
39841: PUSH
39842: LD_VAR 0 1
39846: ARRAY
39847: PPUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 3
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PPUSH
39858: CALL_OW 72
39862: NOT
39863: AND
39864: IFFALSE 39936
// begin if eng = tmp then
39866: LD_VAR 0 6
39870: PUSH
39871: LD_VAR 0 4
39875: EQUAL
39876: IFFALSE 39880
// exit ;
39878: GO 42469
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39880: LD_ADDR_EXP 143
39884: PUSH
39885: LD_EXP 143
39889: PPUSH
39890: LD_VAR 0 1
39894: PPUSH
39895: LD_INT 1
39897: PPUSH
39898: CALL_OW 1
39902: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39903: LD_ADDR_VAR 0 2
39907: PUSH
39908: LD_INT 0
39910: PUSH
39911: LD_VAR 0 4
39915: PUSH
39916: LD_VAR 0 6
39920: DIFF
39921: PUSH
39922: LD_INT 0
39924: PUSH
39925: LD_INT 0
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: ST_TO_ADDR
// exit ;
39934: GO 42469
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39936: LD_EXP 128
39940: PUSH
39941: LD_EXP 127
39945: PUSH
39946: LD_VAR 0 1
39950: ARRAY
39951: ARRAY
39952: PUSH
39953: LD_EXP 101
39957: PUSH
39958: LD_VAR 0 1
39962: ARRAY
39963: PPUSH
39964: LD_INT 2
39966: PUSH
39967: LD_INT 30
39969: PUSH
39970: LD_INT 6
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 30
39979: PUSH
39980: LD_INT 7
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 30
39989: PUSH
39990: LD_INT 8
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: PPUSH
40003: CALL_OW 72
40007: AND
40008: PUSH
40009: LD_EXP 101
40013: PUSH
40014: LD_VAR 0 1
40018: ARRAY
40019: PPUSH
40020: LD_INT 30
40022: PUSH
40023: LD_INT 3
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PPUSH
40030: CALL_OW 72
40034: NOT
40035: AND
40036: IFFALSE 40250
// begin if sci >= 6 then
40038: LD_VAR 0 8
40042: PUSH
40043: LD_INT 6
40045: GREATEREQUAL
40046: IFFALSE 40050
// exit ;
40048: GO 42469
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40050: LD_ADDR_EXP 143
40054: PUSH
40055: LD_EXP 143
40059: PPUSH
40060: LD_VAR 0 1
40064: PPUSH
40065: LD_INT 2
40067: PPUSH
40068: CALL_OW 1
40072: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40073: LD_ADDR_VAR 0 9
40077: PUSH
40078: LD_VAR 0 4
40082: PUSH
40083: LD_VAR 0 8
40087: DIFF
40088: PPUSH
40089: LD_INT 4
40091: PPUSH
40092: CALL 105857 0 2
40096: ST_TO_ADDR
// p := [ ] ;
40097: LD_ADDR_VAR 0 11
40101: PUSH
40102: EMPTY
40103: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40104: LD_VAR 0 8
40108: PUSH
40109: LD_INT 6
40111: LESS
40112: PUSH
40113: LD_VAR 0 9
40117: PUSH
40118: LD_INT 6
40120: GREATER
40121: AND
40122: IFFALSE 40203
// begin for i = 1 to 6 - sci do
40124: LD_ADDR_VAR 0 3
40128: PUSH
40129: DOUBLE
40130: LD_INT 1
40132: DEC
40133: ST_TO_ADDR
40134: LD_INT 6
40136: PUSH
40137: LD_VAR 0 8
40141: MINUS
40142: PUSH
40143: FOR_TO
40144: IFFALSE 40199
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40146: LD_ADDR_VAR 0 11
40150: PUSH
40151: LD_VAR 0 11
40155: PPUSH
40156: LD_VAR 0 11
40160: PUSH
40161: LD_INT 1
40163: PLUS
40164: PPUSH
40165: LD_VAR 0 9
40169: PUSH
40170: LD_INT 1
40172: ARRAY
40173: PPUSH
40174: CALL_OW 2
40178: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40179: LD_ADDR_VAR 0 9
40183: PUSH
40184: LD_VAR 0 9
40188: PPUSH
40189: LD_INT 1
40191: PPUSH
40192: CALL_OW 3
40196: ST_TO_ADDR
// end ;
40197: GO 40143
40199: POP
40200: POP
// end else
40201: GO 40223
// if sort then
40203: LD_VAR 0 9
40207: IFFALSE 40223
// p := sort [ 1 ] ;
40209: LD_ADDR_VAR 0 11
40213: PUSH
40214: LD_VAR 0 9
40218: PUSH
40219: LD_INT 1
40221: ARRAY
40222: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40223: LD_ADDR_VAR 0 2
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: LD_INT 0
40233: PUSH
40234: LD_INT 0
40236: PUSH
40237: LD_VAR 0 11
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: ST_TO_ADDR
// exit ;
40248: GO 42469
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40250: LD_EXP 128
40254: PUSH
40255: LD_EXP 127
40259: PUSH
40260: LD_VAR 0 1
40264: ARRAY
40265: ARRAY
40266: PUSH
40267: LD_EXP 101
40271: PUSH
40272: LD_VAR 0 1
40276: ARRAY
40277: PPUSH
40278: LD_INT 2
40280: PUSH
40281: LD_INT 30
40283: PUSH
40284: LD_INT 6
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 30
40293: PUSH
40294: LD_INT 7
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 30
40303: PUSH
40304: LD_INT 8
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: PPUSH
40317: CALL_OW 72
40321: AND
40322: PUSH
40323: LD_EXP 101
40327: PUSH
40328: LD_VAR 0 1
40332: ARRAY
40333: PPUSH
40334: LD_INT 30
40336: PUSH
40337: LD_INT 3
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PPUSH
40344: CALL_OW 72
40348: AND
40349: IFFALSE 41083
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40351: LD_ADDR_EXP 143
40355: PUSH
40356: LD_EXP 143
40360: PPUSH
40361: LD_VAR 0 1
40365: PPUSH
40366: LD_INT 3
40368: PPUSH
40369: CALL_OW 1
40373: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40374: LD_ADDR_VAR 0 2
40378: PUSH
40379: LD_INT 0
40381: PUSH
40382: LD_INT 0
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: ST_TO_ADDR
// if not eng then
40397: LD_VAR 0 6
40401: NOT
40402: IFFALSE 40465
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40404: LD_ADDR_VAR 0 11
40408: PUSH
40409: LD_VAR 0 4
40413: PPUSH
40414: LD_INT 2
40416: PPUSH
40417: CALL 105857 0 2
40421: PUSH
40422: LD_INT 1
40424: ARRAY
40425: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40426: LD_ADDR_VAR 0 2
40430: PUSH
40431: LD_VAR 0 2
40435: PPUSH
40436: LD_INT 2
40438: PPUSH
40439: LD_VAR 0 11
40443: PPUSH
40444: CALL_OW 1
40448: ST_TO_ADDR
// tmp := tmp diff p ;
40449: LD_ADDR_VAR 0 4
40453: PUSH
40454: LD_VAR 0 4
40458: PUSH
40459: LD_VAR 0 11
40463: DIFF
40464: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40465: LD_VAR 0 4
40469: PUSH
40470: LD_VAR 0 8
40474: PUSH
40475: LD_INT 6
40477: LESS
40478: AND
40479: IFFALSE 40667
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40481: LD_ADDR_VAR 0 9
40485: PUSH
40486: LD_VAR 0 4
40490: PUSH
40491: LD_VAR 0 8
40495: PUSH
40496: LD_VAR 0 7
40500: UNION
40501: DIFF
40502: PPUSH
40503: LD_INT 4
40505: PPUSH
40506: CALL 105857 0 2
40510: ST_TO_ADDR
// p := [ ] ;
40511: LD_ADDR_VAR 0 11
40515: PUSH
40516: EMPTY
40517: ST_TO_ADDR
// if sort then
40518: LD_VAR 0 9
40522: IFFALSE 40638
// for i = 1 to 6 - sci do
40524: LD_ADDR_VAR 0 3
40528: PUSH
40529: DOUBLE
40530: LD_INT 1
40532: DEC
40533: ST_TO_ADDR
40534: LD_INT 6
40536: PUSH
40537: LD_VAR 0 8
40541: MINUS
40542: PUSH
40543: FOR_TO
40544: IFFALSE 40636
// begin if i = sort then
40546: LD_VAR 0 3
40550: PUSH
40551: LD_VAR 0 9
40555: EQUAL
40556: IFFALSE 40560
// break ;
40558: GO 40636
// if GetClass ( i ) = 4 then
40560: LD_VAR 0 3
40564: PPUSH
40565: CALL_OW 257
40569: PUSH
40570: LD_INT 4
40572: EQUAL
40573: IFFALSE 40577
// continue ;
40575: GO 40543
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40577: LD_ADDR_VAR 0 11
40581: PUSH
40582: LD_VAR 0 11
40586: PPUSH
40587: LD_VAR 0 11
40591: PUSH
40592: LD_INT 1
40594: PLUS
40595: PPUSH
40596: LD_VAR 0 9
40600: PUSH
40601: LD_VAR 0 3
40605: ARRAY
40606: PPUSH
40607: CALL_OW 2
40611: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40612: LD_ADDR_VAR 0 4
40616: PUSH
40617: LD_VAR 0 4
40621: PUSH
40622: LD_VAR 0 9
40626: PUSH
40627: LD_VAR 0 3
40631: ARRAY
40632: DIFF
40633: ST_TO_ADDR
// end ;
40634: GO 40543
40636: POP
40637: POP
// if p then
40638: LD_VAR 0 11
40642: IFFALSE 40667
// result := Replace ( result , 4 , p ) ;
40644: LD_ADDR_VAR 0 2
40648: PUSH
40649: LD_VAR 0 2
40653: PPUSH
40654: LD_INT 4
40656: PPUSH
40657: LD_VAR 0 11
40661: PPUSH
40662: CALL_OW 1
40666: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40667: LD_VAR 0 4
40671: PUSH
40672: LD_VAR 0 7
40676: PUSH
40677: LD_INT 6
40679: LESS
40680: AND
40681: IFFALSE 40869
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40683: LD_ADDR_VAR 0 9
40687: PUSH
40688: LD_VAR 0 4
40692: PUSH
40693: LD_VAR 0 8
40697: PUSH
40698: LD_VAR 0 7
40702: UNION
40703: DIFF
40704: PPUSH
40705: LD_INT 3
40707: PPUSH
40708: CALL 105857 0 2
40712: ST_TO_ADDR
// p := [ ] ;
40713: LD_ADDR_VAR 0 11
40717: PUSH
40718: EMPTY
40719: ST_TO_ADDR
// if sort then
40720: LD_VAR 0 9
40724: IFFALSE 40840
// for i = 1 to 6 - mech do
40726: LD_ADDR_VAR 0 3
40730: PUSH
40731: DOUBLE
40732: LD_INT 1
40734: DEC
40735: ST_TO_ADDR
40736: LD_INT 6
40738: PUSH
40739: LD_VAR 0 7
40743: MINUS
40744: PUSH
40745: FOR_TO
40746: IFFALSE 40838
// begin if i = sort then
40748: LD_VAR 0 3
40752: PUSH
40753: LD_VAR 0 9
40757: EQUAL
40758: IFFALSE 40762
// break ;
40760: GO 40838
// if GetClass ( i ) = 3 then
40762: LD_VAR 0 3
40766: PPUSH
40767: CALL_OW 257
40771: PUSH
40772: LD_INT 3
40774: EQUAL
40775: IFFALSE 40779
// continue ;
40777: GO 40745
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40779: LD_ADDR_VAR 0 11
40783: PUSH
40784: LD_VAR 0 11
40788: PPUSH
40789: LD_VAR 0 11
40793: PUSH
40794: LD_INT 1
40796: PLUS
40797: PPUSH
40798: LD_VAR 0 9
40802: PUSH
40803: LD_VAR 0 3
40807: ARRAY
40808: PPUSH
40809: CALL_OW 2
40813: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40814: LD_ADDR_VAR 0 4
40818: PUSH
40819: LD_VAR 0 4
40823: PUSH
40824: LD_VAR 0 9
40828: PUSH
40829: LD_VAR 0 3
40833: ARRAY
40834: DIFF
40835: ST_TO_ADDR
// end ;
40836: GO 40745
40838: POP
40839: POP
// if p then
40840: LD_VAR 0 11
40844: IFFALSE 40869
// result := Replace ( result , 3 , p ) ;
40846: LD_ADDR_VAR 0 2
40850: PUSH
40851: LD_VAR 0 2
40855: PPUSH
40856: LD_INT 3
40858: PPUSH
40859: LD_VAR 0 11
40863: PPUSH
40864: CALL_OW 1
40868: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40869: LD_VAR 0 4
40873: PUSH
40874: LD_INT 6
40876: GREATER
40877: PUSH
40878: LD_VAR 0 6
40882: PUSH
40883: LD_INT 6
40885: LESS
40886: AND
40887: IFFALSE 41081
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40889: LD_ADDR_VAR 0 9
40893: PUSH
40894: LD_VAR 0 4
40898: PUSH
40899: LD_VAR 0 8
40903: PUSH
40904: LD_VAR 0 7
40908: UNION
40909: PUSH
40910: LD_VAR 0 6
40914: UNION
40915: DIFF
40916: PPUSH
40917: LD_INT 2
40919: PPUSH
40920: CALL 105857 0 2
40924: ST_TO_ADDR
// p := [ ] ;
40925: LD_ADDR_VAR 0 11
40929: PUSH
40930: EMPTY
40931: ST_TO_ADDR
// if sort then
40932: LD_VAR 0 9
40936: IFFALSE 41052
// for i = 1 to 6 - eng do
40938: LD_ADDR_VAR 0 3
40942: PUSH
40943: DOUBLE
40944: LD_INT 1
40946: DEC
40947: ST_TO_ADDR
40948: LD_INT 6
40950: PUSH
40951: LD_VAR 0 6
40955: MINUS
40956: PUSH
40957: FOR_TO
40958: IFFALSE 41050
// begin if i = sort then
40960: LD_VAR 0 3
40964: PUSH
40965: LD_VAR 0 9
40969: EQUAL
40970: IFFALSE 40974
// break ;
40972: GO 41050
// if GetClass ( i ) = 2 then
40974: LD_VAR 0 3
40978: PPUSH
40979: CALL_OW 257
40983: PUSH
40984: LD_INT 2
40986: EQUAL
40987: IFFALSE 40991
// continue ;
40989: GO 40957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40991: LD_ADDR_VAR 0 11
40995: PUSH
40996: LD_VAR 0 11
41000: PPUSH
41001: LD_VAR 0 11
41005: PUSH
41006: LD_INT 1
41008: PLUS
41009: PPUSH
41010: LD_VAR 0 9
41014: PUSH
41015: LD_VAR 0 3
41019: ARRAY
41020: PPUSH
41021: CALL_OW 2
41025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41026: LD_ADDR_VAR 0 4
41030: PUSH
41031: LD_VAR 0 4
41035: PUSH
41036: LD_VAR 0 9
41040: PUSH
41041: LD_VAR 0 3
41045: ARRAY
41046: DIFF
41047: ST_TO_ADDR
// end ;
41048: GO 40957
41050: POP
41051: POP
// if p then
41052: LD_VAR 0 11
41056: IFFALSE 41081
// result := Replace ( result , 2 , p ) ;
41058: LD_ADDR_VAR 0 2
41062: PUSH
41063: LD_VAR 0 2
41067: PPUSH
41068: LD_INT 2
41070: PPUSH
41071: LD_VAR 0 11
41075: PPUSH
41076: CALL_OW 1
41080: ST_TO_ADDR
// end ; exit ;
41081: GO 42469
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41083: LD_EXP 128
41087: PUSH
41088: LD_EXP 127
41092: PUSH
41093: LD_VAR 0 1
41097: ARRAY
41098: ARRAY
41099: NOT
41100: PUSH
41101: LD_EXP 101
41105: PUSH
41106: LD_VAR 0 1
41110: ARRAY
41111: PPUSH
41112: LD_INT 30
41114: PUSH
41115: LD_INT 3
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PPUSH
41122: CALL_OW 72
41126: AND
41127: PUSH
41128: LD_EXP 106
41132: PUSH
41133: LD_VAR 0 1
41137: ARRAY
41138: AND
41139: IFFALSE 41747
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41141: LD_ADDR_EXP 143
41145: PUSH
41146: LD_EXP 143
41150: PPUSH
41151: LD_VAR 0 1
41155: PPUSH
41156: LD_INT 5
41158: PPUSH
41159: CALL_OW 1
41163: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41164: LD_ADDR_VAR 0 2
41168: PUSH
41169: LD_INT 0
41171: PUSH
41172: LD_INT 0
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 0
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: LIST
41185: LIST
41186: ST_TO_ADDR
// if sci > 1 then
41187: LD_VAR 0 8
41191: PUSH
41192: LD_INT 1
41194: GREATER
41195: IFFALSE 41223
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41197: LD_ADDR_VAR 0 4
41201: PUSH
41202: LD_VAR 0 4
41206: PUSH
41207: LD_VAR 0 8
41211: PUSH
41212: LD_VAR 0 8
41216: PUSH
41217: LD_INT 1
41219: ARRAY
41220: DIFF
41221: DIFF
41222: ST_TO_ADDR
// if tmp and not sci then
41223: LD_VAR 0 4
41227: PUSH
41228: LD_VAR 0 8
41232: NOT
41233: AND
41234: IFFALSE 41303
// begin sort := SortBySkill ( tmp , 4 ) ;
41236: LD_ADDR_VAR 0 9
41240: PUSH
41241: LD_VAR 0 4
41245: PPUSH
41246: LD_INT 4
41248: PPUSH
41249: CALL 105857 0 2
41253: ST_TO_ADDR
// if sort then
41254: LD_VAR 0 9
41258: IFFALSE 41274
// p := sort [ 1 ] ;
41260: LD_ADDR_VAR 0 11
41264: PUSH
41265: LD_VAR 0 9
41269: PUSH
41270: LD_INT 1
41272: ARRAY
41273: ST_TO_ADDR
// if p then
41274: LD_VAR 0 11
41278: IFFALSE 41303
// result := Replace ( result , 4 , p ) ;
41280: LD_ADDR_VAR 0 2
41284: PUSH
41285: LD_VAR 0 2
41289: PPUSH
41290: LD_INT 4
41292: PPUSH
41293: LD_VAR 0 11
41297: PPUSH
41298: CALL_OW 1
41302: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41303: LD_ADDR_VAR 0 4
41307: PUSH
41308: LD_VAR 0 4
41312: PUSH
41313: LD_VAR 0 7
41317: DIFF
41318: ST_TO_ADDR
// if tmp and mech < 6 then
41319: LD_VAR 0 4
41323: PUSH
41324: LD_VAR 0 7
41328: PUSH
41329: LD_INT 6
41331: LESS
41332: AND
41333: IFFALSE 41521
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41335: LD_ADDR_VAR 0 9
41339: PUSH
41340: LD_VAR 0 4
41344: PUSH
41345: LD_VAR 0 8
41349: PUSH
41350: LD_VAR 0 7
41354: UNION
41355: DIFF
41356: PPUSH
41357: LD_INT 3
41359: PPUSH
41360: CALL 105857 0 2
41364: ST_TO_ADDR
// p := [ ] ;
41365: LD_ADDR_VAR 0 11
41369: PUSH
41370: EMPTY
41371: ST_TO_ADDR
// if sort then
41372: LD_VAR 0 9
41376: IFFALSE 41492
// for i = 1 to 6 - mech do
41378: LD_ADDR_VAR 0 3
41382: PUSH
41383: DOUBLE
41384: LD_INT 1
41386: DEC
41387: ST_TO_ADDR
41388: LD_INT 6
41390: PUSH
41391: LD_VAR 0 7
41395: MINUS
41396: PUSH
41397: FOR_TO
41398: IFFALSE 41490
// begin if i = sort then
41400: LD_VAR 0 3
41404: PUSH
41405: LD_VAR 0 9
41409: EQUAL
41410: IFFALSE 41414
// break ;
41412: GO 41490
// if GetClass ( i ) = 3 then
41414: LD_VAR 0 3
41418: PPUSH
41419: CALL_OW 257
41423: PUSH
41424: LD_INT 3
41426: EQUAL
41427: IFFALSE 41431
// continue ;
41429: GO 41397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41431: LD_ADDR_VAR 0 11
41435: PUSH
41436: LD_VAR 0 11
41440: PPUSH
41441: LD_VAR 0 11
41445: PUSH
41446: LD_INT 1
41448: PLUS
41449: PPUSH
41450: LD_VAR 0 9
41454: PUSH
41455: LD_VAR 0 3
41459: ARRAY
41460: PPUSH
41461: CALL_OW 2
41465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41466: LD_ADDR_VAR 0 4
41470: PUSH
41471: LD_VAR 0 4
41475: PUSH
41476: LD_VAR 0 9
41480: PUSH
41481: LD_VAR 0 3
41485: ARRAY
41486: DIFF
41487: ST_TO_ADDR
// end ;
41488: GO 41397
41490: POP
41491: POP
// if p then
41492: LD_VAR 0 11
41496: IFFALSE 41521
// result := Replace ( result , 3 , p ) ;
41498: LD_ADDR_VAR 0 2
41502: PUSH
41503: LD_VAR 0 2
41507: PPUSH
41508: LD_INT 3
41510: PPUSH
41511: LD_VAR 0 11
41515: PPUSH
41516: CALL_OW 1
41520: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41521: LD_ADDR_VAR 0 4
41525: PUSH
41526: LD_VAR 0 4
41530: PUSH
41531: LD_VAR 0 6
41535: DIFF
41536: ST_TO_ADDR
// if tmp and eng < 6 then
41537: LD_VAR 0 4
41541: PUSH
41542: LD_VAR 0 6
41546: PUSH
41547: LD_INT 6
41549: LESS
41550: AND
41551: IFFALSE 41745
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41553: LD_ADDR_VAR 0 9
41557: PUSH
41558: LD_VAR 0 4
41562: PUSH
41563: LD_VAR 0 8
41567: PUSH
41568: LD_VAR 0 7
41572: UNION
41573: PUSH
41574: LD_VAR 0 6
41578: UNION
41579: DIFF
41580: PPUSH
41581: LD_INT 2
41583: PPUSH
41584: CALL 105857 0 2
41588: ST_TO_ADDR
// p := [ ] ;
41589: LD_ADDR_VAR 0 11
41593: PUSH
41594: EMPTY
41595: ST_TO_ADDR
// if sort then
41596: LD_VAR 0 9
41600: IFFALSE 41716
// for i = 1 to 6 - eng do
41602: LD_ADDR_VAR 0 3
41606: PUSH
41607: DOUBLE
41608: LD_INT 1
41610: DEC
41611: ST_TO_ADDR
41612: LD_INT 6
41614: PUSH
41615: LD_VAR 0 6
41619: MINUS
41620: PUSH
41621: FOR_TO
41622: IFFALSE 41714
// begin if i = sort then
41624: LD_VAR 0 3
41628: PUSH
41629: LD_VAR 0 9
41633: EQUAL
41634: IFFALSE 41638
// break ;
41636: GO 41714
// if GetClass ( i ) = 2 then
41638: LD_VAR 0 3
41642: PPUSH
41643: CALL_OW 257
41647: PUSH
41648: LD_INT 2
41650: EQUAL
41651: IFFALSE 41655
// continue ;
41653: GO 41621
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41655: LD_ADDR_VAR 0 11
41659: PUSH
41660: LD_VAR 0 11
41664: PPUSH
41665: LD_VAR 0 11
41669: PUSH
41670: LD_INT 1
41672: PLUS
41673: PPUSH
41674: LD_VAR 0 9
41678: PUSH
41679: LD_VAR 0 3
41683: ARRAY
41684: PPUSH
41685: CALL_OW 2
41689: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41690: LD_ADDR_VAR 0 4
41694: PUSH
41695: LD_VAR 0 4
41699: PUSH
41700: LD_VAR 0 9
41704: PUSH
41705: LD_VAR 0 3
41709: ARRAY
41710: DIFF
41711: ST_TO_ADDR
// end ;
41712: GO 41621
41714: POP
41715: POP
// if p then
41716: LD_VAR 0 11
41720: IFFALSE 41745
// result := Replace ( result , 2 , p ) ;
41722: LD_ADDR_VAR 0 2
41726: PUSH
41727: LD_VAR 0 2
41731: PPUSH
41732: LD_INT 2
41734: PPUSH
41735: LD_VAR 0 11
41739: PPUSH
41740: CALL_OW 1
41744: ST_TO_ADDR
// end ; exit ;
41745: GO 42469
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41747: LD_EXP 128
41751: PUSH
41752: LD_EXP 127
41756: PUSH
41757: LD_VAR 0 1
41761: ARRAY
41762: ARRAY
41763: NOT
41764: PUSH
41765: LD_EXP 101
41769: PUSH
41770: LD_VAR 0 1
41774: ARRAY
41775: PPUSH
41776: LD_INT 30
41778: PUSH
41779: LD_INT 3
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PPUSH
41786: CALL_OW 72
41790: AND
41791: PUSH
41792: LD_EXP 106
41796: PUSH
41797: LD_VAR 0 1
41801: ARRAY
41802: NOT
41803: AND
41804: IFFALSE 42469
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41806: LD_ADDR_EXP 143
41810: PUSH
41811: LD_EXP 143
41815: PPUSH
41816: LD_VAR 0 1
41820: PPUSH
41821: LD_INT 6
41823: PPUSH
41824: CALL_OW 1
41828: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41829: LD_ADDR_VAR 0 2
41833: PUSH
41834: LD_INT 0
41836: PUSH
41837: LD_INT 0
41839: PUSH
41840: LD_INT 0
41842: PUSH
41843: LD_INT 0
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: LIST
41850: LIST
41851: ST_TO_ADDR
// if sci >= 1 then
41852: LD_VAR 0 8
41856: PUSH
41857: LD_INT 1
41859: GREATEREQUAL
41860: IFFALSE 41882
// tmp := tmp diff sci [ 1 ] ;
41862: LD_ADDR_VAR 0 4
41866: PUSH
41867: LD_VAR 0 4
41871: PUSH
41872: LD_VAR 0 8
41876: PUSH
41877: LD_INT 1
41879: ARRAY
41880: DIFF
41881: ST_TO_ADDR
// if tmp and not sci then
41882: LD_VAR 0 4
41886: PUSH
41887: LD_VAR 0 8
41891: NOT
41892: AND
41893: IFFALSE 41962
// begin sort := SortBySkill ( tmp , 4 ) ;
41895: LD_ADDR_VAR 0 9
41899: PUSH
41900: LD_VAR 0 4
41904: PPUSH
41905: LD_INT 4
41907: PPUSH
41908: CALL 105857 0 2
41912: ST_TO_ADDR
// if sort then
41913: LD_VAR 0 9
41917: IFFALSE 41933
// p := sort [ 1 ] ;
41919: LD_ADDR_VAR 0 11
41923: PUSH
41924: LD_VAR 0 9
41928: PUSH
41929: LD_INT 1
41931: ARRAY
41932: ST_TO_ADDR
// if p then
41933: LD_VAR 0 11
41937: IFFALSE 41962
// result := Replace ( result , 4 , p ) ;
41939: LD_ADDR_VAR 0 2
41943: PUSH
41944: LD_VAR 0 2
41948: PPUSH
41949: LD_INT 4
41951: PPUSH
41952: LD_VAR 0 11
41956: PPUSH
41957: CALL_OW 1
41961: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41962: LD_ADDR_VAR 0 4
41966: PUSH
41967: LD_VAR 0 4
41971: PUSH
41972: LD_VAR 0 7
41976: DIFF
41977: ST_TO_ADDR
// if tmp and mech < 6 then
41978: LD_VAR 0 4
41982: PUSH
41983: LD_VAR 0 7
41987: PUSH
41988: LD_INT 6
41990: LESS
41991: AND
41992: IFFALSE 42174
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41994: LD_ADDR_VAR 0 9
41998: PUSH
41999: LD_VAR 0 4
42003: PUSH
42004: LD_VAR 0 7
42008: DIFF
42009: PPUSH
42010: LD_INT 3
42012: PPUSH
42013: CALL 105857 0 2
42017: ST_TO_ADDR
// p := [ ] ;
42018: LD_ADDR_VAR 0 11
42022: PUSH
42023: EMPTY
42024: ST_TO_ADDR
// if sort then
42025: LD_VAR 0 9
42029: IFFALSE 42145
// for i = 1 to 6 - mech do
42031: LD_ADDR_VAR 0 3
42035: PUSH
42036: DOUBLE
42037: LD_INT 1
42039: DEC
42040: ST_TO_ADDR
42041: LD_INT 6
42043: PUSH
42044: LD_VAR 0 7
42048: MINUS
42049: PUSH
42050: FOR_TO
42051: IFFALSE 42143
// begin if i = sort then
42053: LD_VAR 0 3
42057: PUSH
42058: LD_VAR 0 9
42062: EQUAL
42063: IFFALSE 42067
// break ;
42065: GO 42143
// if GetClass ( i ) = 3 then
42067: LD_VAR 0 3
42071: PPUSH
42072: CALL_OW 257
42076: PUSH
42077: LD_INT 3
42079: EQUAL
42080: IFFALSE 42084
// continue ;
42082: GO 42050
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42084: LD_ADDR_VAR 0 11
42088: PUSH
42089: LD_VAR 0 11
42093: PPUSH
42094: LD_VAR 0 11
42098: PUSH
42099: LD_INT 1
42101: PLUS
42102: PPUSH
42103: LD_VAR 0 9
42107: PUSH
42108: LD_VAR 0 3
42112: ARRAY
42113: PPUSH
42114: CALL_OW 2
42118: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42119: LD_ADDR_VAR 0 4
42123: PUSH
42124: LD_VAR 0 4
42128: PUSH
42129: LD_VAR 0 9
42133: PUSH
42134: LD_VAR 0 3
42138: ARRAY
42139: DIFF
42140: ST_TO_ADDR
// end ;
42141: GO 42050
42143: POP
42144: POP
// if p then
42145: LD_VAR 0 11
42149: IFFALSE 42174
// result := Replace ( result , 3 , p ) ;
42151: LD_ADDR_VAR 0 2
42155: PUSH
42156: LD_VAR 0 2
42160: PPUSH
42161: LD_INT 3
42163: PPUSH
42164: LD_VAR 0 11
42168: PPUSH
42169: CALL_OW 1
42173: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42174: LD_ADDR_VAR 0 4
42178: PUSH
42179: LD_VAR 0 4
42183: PUSH
42184: LD_VAR 0 6
42188: DIFF
42189: ST_TO_ADDR
// if tmp and eng < 4 then
42190: LD_VAR 0 4
42194: PUSH
42195: LD_VAR 0 6
42199: PUSH
42200: LD_INT 4
42202: LESS
42203: AND
42204: IFFALSE 42394
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42206: LD_ADDR_VAR 0 9
42210: PUSH
42211: LD_VAR 0 4
42215: PUSH
42216: LD_VAR 0 7
42220: PUSH
42221: LD_VAR 0 6
42225: UNION
42226: DIFF
42227: PPUSH
42228: LD_INT 2
42230: PPUSH
42231: CALL 105857 0 2
42235: ST_TO_ADDR
// p := [ ] ;
42236: LD_ADDR_VAR 0 11
42240: PUSH
42241: EMPTY
42242: ST_TO_ADDR
// if sort then
42243: LD_VAR 0 9
42247: IFFALSE 42363
// for i = 1 to 4 - eng do
42249: LD_ADDR_VAR 0 3
42253: PUSH
42254: DOUBLE
42255: LD_INT 1
42257: DEC
42258: ST_TO_ADDR
42259: LD_INT 4
42261: PUSH
42262: LD_VAR 0 6
42266: MINUS
42267: PUSH
42268: FOR_TO
42269: IFFALSE 42361
// begin if i = sort then
42271: LD_VAR 0 3
42275: PUSH
42276: LD_VAR 0 9
42280: EQUAL
42281: IFFALSE 42285
// break ;
42283: GO 42361
// if GetClass ( i ) = 2 then
42285: LD_VAR 0 3
42289: PPUSH
42290: CALL_OW 257
42294: PUSH
42295: LD_INT 2
42297: EQUAL
42298: IFFALSE 42302
// continue ;
42300: GO 42268
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42302: LD_ADDR_VAR 0 11
42306: PUSH
42307: LD_VAR 0 11
42311: PPUSH
42312: LD_VAR 0 11
42316: PUSH
42317: LD_INT 1
42319: PLUS
42320: PPUSH
42321: LD_VAR 0 9
42325: PUSH
42326: LD_VAR 0 3
42330: ARRAY
42331: PPUSH
42332: CALL_OW 2
42336: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42337: LD_ADDR_VAR 0 4
42341: PUSH
42342: LD_VAR 0 4
42346: PUSH
42347: LD_VAR 0 9
42351: PUSH
42352: LD_VAR 0 3
42356: ARRAY
42357: DIFF
42358: ST_TO_ADDR
// end ;
42359: GO 42268
42361: POP
42362: POP
// if p then
42363: LD_VAR 0 11
42367: IFFALSE 42392
// result := Replace ( result , 2 , p ) ;
42369: LD_ADDR_VAR 0 2
42373: PUSH
42374: LD_VAR 0 2
42378: PPUSH
42379: LD_INT 2
42381: PPUSH
42382: LD_VAR 0 11
42386: PPUSH
42387: CALL_OW 1
42391: ST_TO_ADDR
// end else
42392: GO 42438
// for i = eng downto 5 do
42394: LD_ADDR_VAR 0 3
42398: PUSH
42399: DOUBLE
42400: LD_VAR 0 6
42404: INC
42405: ST_TO_ADDR
42406: LD_INT 5
42408: PUSH
42409: FOR_DOWNTO
42410: IFFALSE 42436
// tmp := tmp union eng [ i ] ;
42412: LD_ADDR_VAR 0 4
42416: PUSH
42417: LD_VAR 0 4
42421: PUSH
42422: LD_VAR 0 6
42426: PUSH
42427: LD_VAR 0 3
42431: ARRAY
42432: UNION
42433: ST_TO_ADDR
42434: GO 42409
42436: POP
42437: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42438: LD_ADDR_VAR 0 2
42442: PUSH
42443: LD_VAR 0 2
42447: PPUSH
42448: LD_INT 1
42450: PPUSH
42451: LD_VAR 0 4
42455: PUSH
42456: LD_VAR 0 5
42460: DIFF
42461: PPUSH
42462: CALL_OW 1
42466: ST_TO_ADDR
// exit ;
42467: GO 42469
// end ; end ;
42469: LD_VAR 0 2
42473: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42474: LD_INT 0
42476: PPUSH
42477: PPUSH
42478: PPUSH
// if not mc_bases then
42479: LD_EXP 101
42483: NOT
42484: IFFALSE 42488
// exit ;
42486: GO 42594
// for i = 1 to mc_bases do
42488: LD_ADDR_VAR 0 2
42492: PUSH
42493: DOUBLE
42494: LD_INT 1
42496: DEC
42497: ST_TO_ADDR
42498: LD_EXP 101
42502: PUSH
42503: FOR_TO
42504: IFFALSE 42585
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42506: LD_ADDR_VAR 0 3
42510: PUSH
42511: LD_EXP 101
42515: PUSH
42516: LD_VAR 0 2
42520: ARRAY
42521: PPUSH
42522: LD_INT 21
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 3
42534: PUSH
42535: LD_INT 24
42537: PUSH
42538: LD_INT 1000
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PPUSH
42553: CALL_OW 72
42557: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42558: LD_ADDR_EXP 102
42562: PUSH
42563: LD_EXP 102
42567: PPUSH
42568: LD_VAR 0 2
42572: PPUSH
42573: LD_VAR 0 3
42577: PPUSH
42578: CALL_OW 1
42582: ST_TO_ADDR
// end ;
42583: GO 42503
42585: POP
42586: POP
// RaiseSailEvent ( 101 ) ;
42587: LD_INT 101
42589: PPUSH
42590: CALL_OW 427
// end ;
42594: LD_VAR 0 1
42598: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42599: LD_INT 0
42601: PPUSH
42602: PPUSH
42603: PPUSH
42604: PPUSH
42605: PPUSH
42606: PPUSH
42607: PPUSH
// if not mc_bases then
42608: LD_EXP 101
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 43190
// for i = 1 to mc_bases do
42617: LD_ADDR_VAR 0 2
42621: PUSH
42622: DOUBLE
42623: LD_INT 1
42625: DEC
42626: ST_TO_ADDR
42627: LD_EXP 101
42631: PUSH
42632: FOR_TO
42633: IFFALSE 43181
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42635: LD_ADDR_VAR 0 5
42639: PUSH
42640: LD_EXP 101
42644: PUSH
42645: LD_VAR 0 2
42649: ARRAY
42650: PUSH
42651: LD_EXP 130
42655: PUSH
42656: LD_VAR 0 2
42660: ARRAY
42661: UNION
42662: PPUSH
42663: LD_INT 21
42665: PUSH
42666: LD_INT 1
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: PUSH
42676: LD_INT 3
42678: PUSH
42679: LD_INT 54
42681: PUSH
42682: EMPTY
42683: LIST
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 24
42694: PUSH
42695: LD_INT 800
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PPUSH
42715: CALL_OW 72
42719: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42720: LD_ADDR_VAR 0 6
42724: PUSH
42725: LD_EXP 101
42729: PUSH
42730: LD_VAR 0 2
42734: ARRAY
42735: PPUSH
42736: LD_INT 21
42738: PUSH
42739: LD_INT 1
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 1
42748: PUSH
42749: LD_INT 3
42751: PUSH
42752: LD_INT 54
42754: PUSH
42755: EMPTY
42756: LIST
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 3
42764: PUSH
42765: LD_INT 24
42767: PUSH
42768: LD_INT 250
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: LIST
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PPUSH
42788: CALL_OW 72
42792: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42793: LD_ADDR_VAR 0 7
42797: PUSH
42798: LD_VAR 0 5
42802: PUSH
42803: LD_VAR 0 6
42807: DIFF
42808: ST_TO_ADDR
// if not need_heal_1 then
42809: LD_VAR 0 6
42813: NOT
42814: IFFALSE 42847
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42816: LD_ADDR_EXP 104
42820: PUSH
42821: LD_EXP 104
42825: PPUSH
42826: LD_VAR 0 2
42830: PUSH
42831: LD_INT 1
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PPUSH
42838: EMPTY
42839: PPUSH
42840: CALL 71609 0 3
42844: ST_TO_ADDR
42845: GO 42917
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42847: LD_ADDR_EXP 104
42851: PUSH
42852: LD_EXP 104
42856: PPUSH
42857: LD_VAR 0 2
42861: PUSH
42862: LD_INT 1
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PPUSH
42869: LD_EXP 104
42873: PUSH
42874: LD_VAR 0 2
42878: ARRAY
42879: PUSH
42880: LD_INT 1
42882: ARRAY
42883: PPUSH
42884: LD_INT 3
42886: PUSH
42887: LD_INT 24
42889: PUSH
42890: LD_INT 1000
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PPUSH
42901: CALL_OW 72
42905: PUSH
42906: LD_VAR 0 6
42910: UNION
42911: PPUSH
42912: CALL 71609 0 3
42916: ST_TO_ADDR
// if not need_heal_2 then
42917: LD_VAR 0 7
42921: NOT
42922: IFFALSE 42955
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42924: LD_ADDR_EXP 104
42928: PUSH
42929: LD_EXP 104
42933: PPUSH
42934: LD_VAR 0 2
42938: PUSH
42939: LD_INT 2
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PPUSH
42946: EMPTY
42947: PPUSH
42948: CALL 71609 0 3
42952: ST_TO_ADDR
42953: GO 42987
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42955: LD_ADDR_EXP 104
42959: PUSH
42960: LD_EXP 104
42964: PPUSH
42965: LD_VAR 0 2
42969: PUSH
42970: LD_INT 2
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: PPUSH
42977: LD_VAR 0 7
42981: PPUSH
42982: CALL 71609 0 3
42986: ST_TO_ADDR
// if need_heal_2 then
42987: LD_VAR 0 7
42991: IFFALSE 43163
// for j in need_heal_2 do
42993: LD_ADDR_VAR 0 3
42997: PUSH
42998: LD_VAR 0 7
43002: PUSH
43003: FOR_IN
43004: IFFALSE 43161
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43006: LD_ADDR_VAR 0 5
43010: PUSH
43011: LD_EXP 101
43015: PUSH
43016: LD_VAR 0 2
43020: ARRAY
43021: PPUSH
43022: LD_INT 2
43024: PUSH
43025: LD_INT 30
43027: PUSH
43028: LD_INT 6
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 30
43037: PUSH
43038: LD_INT 7
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 30
43047: PUSH
43048: LD_INT 8
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 30
43057: PUSH
43058: LD_INT 0
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 30
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 25
43077: PUSH
43078: LD_INT 4
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: LIST
43089: LIST
43090: LIST
43091: LIST
43092: LIST
43093: PPUSH
43094: CALL_OW 72
43098: ST_TO_ADDR
// if tmp then
43099: LD_VAR 0 5
43103: IFFALSE 43159
// begin k := NearestUnitToUnit ( tmp , j ) ;
43105: LD_ADDR_VAR 0 4
43109: PUSH
43110: LD_VAR 0 5
43114: PPUSH
43115: LD_VAR 0 3
43119: PPUSH
43120: CALL_OW 74
43124: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43125: LD_VAR 0 3
43129: PPUSH
43130: LD_VAR 0 4
43134: PPUSH
43135: CALL_OW 296
43139: PUSH
43140: LD_INT 7
43142: GREATER
43143: IFFALSE 43159
// ComMoveUnit ( j , k ) ;
43145: LD_VAR 0 3
43149: PPUSH
43150: LD_VAR 0 4
43154: PPUSH
43155: CALL_OW 112
// end ; end ;
43159: GO 43003
43161: POP
43162: POP
// if not need_heal_1 and not need_heal_2 then
43163: LD_VAR 0 6
43167: NOT
43168: PUSH
43169: LD_VAR 0 7
43173: NOT
43174: AND
43175: IFFALSE 43179
// continue ;
43177: GO 42632
// end ;
43179: GO 42632
43181: POP
43182: POP
// RaiseSailEvent ( 102 ) ;
43183: LD_INT 102
43185: PPUSH
43186: CALL_OW 427
// end ;
43190: LD_VAR 0 1
43194: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
43195: LD_INT 0
43197: PPUSH
43198: PPUSH
43199: PPUSH
43200: PPUSH
43201: PPUSH
43202: PPUSH
// if not mc_bases then
43203: LD_EXP 101
43207: NOT
43208: IFFALSE 43212
// exit ;
43210: GO 43922
// for i = 1 to mc_bases do
43212: LD_ADDR_VAR 0 2
43216: PUSH
43217: DOUBLE
43218: LD_INT 1
43220: DEC
43221: ST_TO_ADDR
43222: LD_EXP 101
43226: PUSH
43227: FOR_TO
43228: IFFALSE 43920
// begin if not mc_building_need_repair [ i ] then
43230: LD_EXP 102
43234: PUSH
43235: LD_VAR 0 2
43239: ARRAY
43240: NOT
43241: IFFALSE 43415
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43243: LD_ADDR_VAR 0 6
43247: PUSH
43248: LD_EXP 120
43252: PUSH
43253: LD_VAR 0 2
43257: ARRAY
43258: PPUSH
43259: LD_INT 3
43261: PUSH
43262: LD_INT 24
43264: PUSH
43265: LD_INT 1000
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: PUSH
43276: LD_INT 2
43278: PUSH
43279: LD_INT 34
43281: PUSH
43282: LD_INT 13
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 34
43291: PUSH
43292: LD_INT 52
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: LIST
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PPUSH
43308: CALL_OW 72
43312: ST_TO_ADDR
// if cranes then
43313: LD_VAR 0 6
43317: IFFALSE 43379
// for j in cranes do
43319: LD_ADDR_VAR 0 3
43323: PUSH
43324: LD_VAR 0 6
43328: PUSH
43329: FOR_IN
43330: IFFALSE 43377
// if not IsInArea ( j , mc_parking [ i ] ) then
43332: LD_VAR 0 3
43336: PPUSH
43337: LD_EXP 125
43341: PUSH
43342: LD_VAR 0 2
43346: ARRAY
43347: PPUSH
43348: CALL_OW 308
43352: NOT
43353: IFFALSE 43375
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43355: LD_VAR 0 3
43359: PPUSH
43360: LD_EXP 125
43364: PUSH
43365: LD_VAR 0 2
43369: ARRAY
43370: PPUSH
43371: CALL_OW 113
43375: GO 43329
43377: POP
43378: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43379: LD_ADDR_EXP 103
43383: PUSH
43384: LD_EXP 103
43388: PPUSH
43389: LD_VAR 0 2
43393: PPUSH
43394: EMPTY
43395: PPUSH
43396: CALL_OW 1
43400: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43401: LD_VAR 0 2
43405: PPUSH
43406: LD_INT 101
43408: PPUSH
43409: CALL 38307 0 2
// continue ;
43413: GO 43227
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43415: LD_ADDR_EXP 107
43419: PUSH
43420: LD_EXP 107
43424: PPUSH
43425: LD_VAR 0 2
43429: PPUSH
43430: EMPTY
43431: PPUSH
43432: CALL_OW 1
43436: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43437: LD_VAR 0 2
43441: PPUSH
43442: LD_INT 103
43444: PPUSH
43445: CALL 38307 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43449: LD_ADDR_VAR 0 5
43453: PUSH
43454: LD_EXP 101
43458: PUSH
43459: LD_VAR 0 2
43463: ARRAY
43464: PUSH
43465: LD_EXP 130
43469: PUSH
43470: LD_VAR 0 2
43474: ARRAY
43475: UNION
43476: PPUSH
43477: LD_INT 2
43479: PUSH
43480: LD_INT 25
43482: PUSH
43483: LD_INT 2
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 25
43492: PUSH
43493: LD_INT 16
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: LIST
43504: PUSH
43505: EMPTY
43506: LIST
43507: PPUSH
43508: CALL_OW 72
43512: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43513: LD_ADDR_VAR 0 6
43517: PUSH
43518: LD_EXP 120
43522: PUSH
43523: LD_VAR 0 2
43527: ARRAY
43528: PPUSH
43529: LD_INT 2
43531: PUSH
43532: LD_INT 34
43534: PUSH
43535: LD_INT 13
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 34
43544: PUSH
43545: LD_INT 52
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: LIST
43556: PPUSH
43557: CALL_OW 72
43561: ST_TO_ADDR
// if cranes then
43562: LD_VAR 0 6
43566: IFFALSE 43702
// begin for j in cranes do
43568: LD_ADDR_VAR 0 3
43572: PUSH
43573: LD_VAR 0 6
43577: PUSH
43578: FOR_IN
43579: IFFALSE 43700
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43581: LD_VAR 0 3
43585: PPUSH
43586: CALL_OW 256
43590: PUSH
43591: LD_INT 500
43593: GREATEREQUAL
43594: PUSH
43595: LD_VAR 0 3
43599: PPUSH
43600: CALL_OW 314
43604: NOT
43605: AND
43606: IFFALSE 43640
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43608: LD_VAR 0 3
43612: PPUSH
43613: LD_EXP 102
43617: PUSH
43618: LD_VAR 0 2
43622: ARRAY
43623: PPUSH
43624: LD_VAR 0 3
43628: PPUSH
43629: CALL_OW 74
43633: PPUSH
43634: CALL_OW 130
43638: GO 43698
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43640: LD_VAR 0 3
43644: PPUSH
43645: CALL_OW 256
43649: PUSH
43650: LD_INT 500
43652: LESS
43653: PUSH
43654: LD_VAR 0 3
43658: PPUSH
43659: LD_EXP 125
43663: PUSH
43664: LD_VAR 0 2
43668: ARRAY
43669: PPUSH
43670: CALL_OW 308
43674: NOT
43675: AND
43676: IFFALSE 43698
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43678: LD_VAR 0 3
43682: PPUSH
43683: LD_EXP 125
43687: PUSH
43688: LD_VAR 0 2
43692: ARRAY
43693: PPUSH
43694: CALL_OW 113
43698: GO 43578
43700: POP
43701: POP
// end ; if not tmp then
43702: LD_VAR 0 5
43706: NOT
43707: IFFALSE 43711
// continue ;
43709: GO 43227
// for j in tmp do
43711: LD_ADDR_VAR 0 3
43715: PUSH
43716: LD_VAR 0 5
43720: PUSH
43721: FOR_IN
43722: IFFALSE 43916
// begin if mc_need_heal [ i ] then
43724: LD_EXP 104
43728: PUSH
43729: LD_VAR 0 2
43733: ARRAY
43734: IFFALSE 43782
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43736: LD_VAR 0 3
43740: PUSH
43741: LD_EXP 104
43745: PUSH
43746: LD_VAR 0 2
43750: ARRAY
43751: PUSH
43752: LD_INT 1
43754: ARRAY
43755: IN
43756: PUSH
43757: LD_VAR 0 3
43761: PUSH
43762: LD_EXP 104
43766: PUSH
43767: LD_VAR 0 2
43771: ARRAY
43772: PUSH
43773: LD_INT 2
43775: ARRAY
43776: IN
43777: OR
43778: IFFALSE 43782
// continue ;
43780: GO 43721
// if IsInUnit ( j ) then
43782: LD_VAR 0 3
43786: PPUSH
43787: CALL_OW 310
43791: IFFALSE 43802
// ComExitBuilding ( j ) ;
43793: LD_VAR 0 3
43797: PPUSH
43798: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43802: LD_VAR 0 3
43806: PUSH
43807: LD_EXP 103
43811: PUSH
43812: LD_VAR 0 2
43816: ARRAY
43817: IN
43818: NOT
43819: IFFALSE 43877
// begin SetTag ( j , 101 ) ;
43821: LD_VAR 0 3
43825: PPUSH
43826: LD_INT 101
43828: PPUSH
43829: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43833: LD_ADDR_EXP 103
43837: PUSH
43838: LD_EXP 103
43842: PPUSH
43843: LD_VAR 0 2
43847: PUSH
43848: LD_EXP 103
43852: PUSH
43853: LD_VAR 0 2
43857: ARRAY
43858: PUSH
43859: LD_INT 1
43861: PLUS
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PPUSH
43867: LD_VAR 0 3
43871: PPUSH
43872: CALL 71609 0 3
43876: ST_TO_ADDR
// end ; wait ( 1 ) ;
43877: LD_INT 1
43879: PPUSH
43880: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43884: LD_VAR 0 3
43888: PPUSH
43889: LD_EXP 102
43893: PUSH
43894: LD_VAR 0 2
43898: ARRAY
43899: PPUSH
43900: LD_VAR 0 3
43904: PPUSH
43905: CALL_OW 74
43909: PPUSH
43910: CALL_OW 130
// end ;
43914: GO 43721
43916: POP
43917: POP
// end ;
43918: GO 43227
43920: POP
43921: POP
// end ;
43922: LD_VAR 0 1
43926: RET
// export function MC_Heal ; var i , j , tmp ; begin
43927: LD_INT 0
43929: PPUSH
43930: PPUSH
43931: PPUSH
43932: PPUSH
// if not mc_bases then
43933: LD_EXP 101
43937: NOT
43938: IFFALSE 43942
// exit ;
43940: GO 44344
// for i = 1 to mc_bases do
43942: LD_ADDR_VAR 0 2
43946: PUSH
43947: DOUBLE
43948: LD_INT 1
43950: DEC
43951: ST_TO_ADDR
43952: LD_EXP 101
43956: PUSH
43957: FOR_TO
43958: IFFALSE 44342
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43960: LD_EXP 104
43964: PUSH
43965: LD_VAR 0 2
43969: ARRAY
43970: PUSH
43971: LD_INT 1
43973: ARRAY
43974: NOT
43975: PUSH
43976: LD_EXP 104
43980: PUSH
43981: LD_VAR 0 2
43985: ARRAY
43986: PUSH
43987: LD_INT 2
43989: ARRAY
43990: NOT
43991: AND
43992: IFFALSE 44030
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43994: LD_ADDR_EXP 105
43998: PUSH
43999: LD_EXP 105
44003: PPUSH
44004: LD_VAR 0 2
44008: PPUSH
44009: EMPTY
44010: PPUSH
44011: CALL_OW 1
44015: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44016: LD_VAR 0 2
44020: PPUSH
44021: LD_INT 102
44023: PPUSH
44024: CALL 38307 0 2
// continue ;
44028: GO 43957
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44030: LD_ADDR_VAR 0 4
44034: PUSH
44035: LD_EXP 101
44039: PUSH
44040: LD_VAR 0 2
44044: ARRAY
44045: PPUSH
44046: LD_INT 25
44048: PUSH
44049: LD_INT 4
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PPUSH
44056: CALL_OW 72
44060: ST_TO_ADDR
// if not tmp then
44061: LD_VAR 0 4
44065: NOT
44066: IFFALSE 44070
// continue ;
44068: GO 43957
// if mc_taming [ i ] then
44070: LD_EXP 132
44074: PUSH
44075: LD_VAR 0 2
44079: ARRAY
44080: IFFALSE 44104
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44082: LD_ADDR_EXP 132
44086: PUSH
44087: LD_EXP 132
44091: PPUSH
44092: LD_VAR 0 2
44096: PPUSH
44097: EMPTY
44098: PPUSH
44099: CALL_OW 1
44103: ST_TO_ADDR
// for j in tmp do
44104: LD_ADDR_VAR 0 3
44108: PUSH
44109: LD_VAR 0 4
44113: PUSH
44114: FOR_IN
44115: IFFALSE 44338
// begin if IsInUnit ( j ) then
44117: LD_VAR 0 3
44121: PPUSH
44122: CALL_OW 310
44126: IFFALSE 44137
// ComExitBuilding ( j ) ;
44128: LD_VAR 0 3
44132: PPUSH
44133: CALL_OW 122
// if not j in mc_healers [ i ] then
44137: LD_VAR 0 3
44141: PUSH
44142: LD_EXP 105
44146: PUSH
44147: LD_VAR 0 2
44151: ARRAY
44152: IN
44153: NOT
44154: IFFALSE 44200
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44156: LD_ADDR_EXP 105
44160: PUSH
44161: LD_EXP 105
44165: PPUSH
44166: LD_VAR 0 2
44170: PUSH
44171: LD_EXP 105
44175: PUSH
44176: LD_VAR 0 2
44180: ARRAY
44181: PUSH
44182: LD_INT 1
44184: PLUS
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PPUSH
44190: LD_VAR 0 3
44194: PPUSH
44195: CALL 71609 0 3
44199: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44200: LD_VAR 0 3
44204: PPUSH
44205: CALL_OW 110
44209: PUSH
44210: LD_INT 102
44212: NONEQUAL
44213: IFFALSE 44227
// SetTag ( j , 102 ) ;
44215: LD_VAR 0 3
44219: PPUSH
44220: LD_INT 102
44222: PPUSH
44223: CALL_OW 109
// Wait ( 3 ) ;
44227: LD_INT 3
44229: PPUSH
44230: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44234: LD_EXP 104
44238: PUSH
44239: LD_VAR 0 2
44243: ARRAY
44244: PUSH
44245: LD_INT 1
44247: ARRAY
44248: IFFALSE 44280
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44250: LD_VAR 0 3
44254: PPUSH
44255: LD_EXP 104
44259: PUSH
44260: LD_VAR 0 2
44264: ARRAY
44265: PUSH
44266: LD_INT 1
44268: ARRAY
44269: PUSH
44270: LD_INT 1
44272: ARRAY
44273: PPUSH
44274: CALL_OW 128
44278: GO 44336
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44280: LD_VAR 0 3
44284: PPUSH
44285: CALL_OW 314
44289: NOT
44290: PUSH
44291: LD_EXP 104
44295: PUSH
44296: LD_VAR 0 2
44300: ARRAY
44301: PUSH
44302: LD_INT 2
44304: ARRAY
44305: AND
44306: IFFALSE 44336
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44308: LD_VAR 0 3
44312: PPUSH
44313: LD_EXP 104
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PUSH
44324: LD_INT 2
44326: ARRAY
44327: PUSH
44328: LD_INT 1
44330: ARRAY
44331: PPUSH
44332: CALL_OW 128
// end ;
44336: GO 44114
44338: POP
44339: POP
// end ;
44340: GO 43957
44342: POP
44343: POP
// end ;
44344: LD_VAR 0 1
44348: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44349: LD_INT 0
44351: PPUSH
44352: PPUSH
44353: PPUSH
44354: PPUSH
44355: PPUSH
// if not mc_bases then
44356: LD_EXP 101
44360: NOT
44361: IFFALSE 44365
// exit ;
44363: GO 45508
// for i = 1 to mc_bases do
44365: LD_ADDR_VAR 0 2
44369: PUSH
44370: DOUBLE
44371: LD_INT 1
44373: DEC
44374: ST_TO_ADDR
44375: LD_EXP 101
44379: PUSH
44380: FOR_TO
44381: IFFALSE 45506
// begin if mc_scan [ i ] then
44383: LD_EXP 124
44387: PUSH
44388: LD_VAR 0 2
44392: ARRAY
44393: IFFALSE 44397
// continue ;
44395: GO 44380
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44397: LD_EXP 106
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: NOT
44408: PUSH
44409: LD_EXP 108
44413: PUSH
44414: LD_VAR 0 2
44418: ARRAY
44419: NOT
44420: AND
44421: PUSH
44422: LD_EXP 107
44426: PUSH
44427: LD_VAR 0 2
44431: ARRAY
44432: AND
44433: IFFALSE 44471
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44435: LD_ADDR_EXP 107
44439: PUSH
44440: LD_EXP 107
44444: PPUSH
44445: LD_VAR 0 2
44449: PPUSH
44450: EMPTY
44451: PPUSH
44452: CALL_OW 1
44456: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44457: LD_VAR 0 2
44461: PPUSH
44462: LD_INT 103
44464: PPUSH
44465: CALL 38307 0 2
// continue ;
44469: GO 44380
// end ; if mc_construct_list [ i ] then
44471: LD_EXP 108
44475: PUSH
44476: LD_VAR 0 2
44480: ARRAY
44481: IFFALSE 44701
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44483: LD_ADDR_VAR 0 4
44487: PUSH
44488: LD_EXP 101
44492: PUSH
44493: LD_VAR 0 2
44497: ARRAY
44498: PPUSH
44499: LD_INT 25
44501: PUSH
44502: LD_INT 2
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PPUSH
44509: CALL_OW 72
44513: PUSH
44514: LD_EXP 103
44518: PUSH
44519: LD_VAR 0 2
44523: ARRAY
44524: DIFF
44525: ST_TO_ADDR
// if not tmp then
44526: LD_VAR 0 4
44530: NOT
44531: IFFALSE 44535
// continue ;
44533: GO 44380
// for j in tmp do
44535: LD_ADDR_VAR 0 3
44539: PUSH
44540: LD_VAR 0 4
44544: PUSH
44545: FOR_IN
44546: IFFALSE 44697
// begin if not mc_builders [ i ] then
44548: LD_EXP 107
44552: PUSH
44553: LD_VAR 0 2
44557: ARRAY
44558: NOT
44559: IFFALSE 44617
// begin SetTag ( j , 103 ) ;
44561: LD_VAR 0 3
44565: PPUSH
44566: LD_INT 103
44568: PPUSH
44569: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44573: LD_ADDR_EXP 107
44577: PUSH
44578: LD_EXP 107
44582: PPUSH
44583: LD_VAR 0 2
44587: PUSH
44588: LD_EXP 107
44592: PUSH
44593: LD_VAR 0 2
44597: ARRAY
44598: PUSH
44599: LD_INT 1
44601: PLUS
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PPUSH
44607: LD_VAR 0 3
44611: PPUSH
44612: CALL 71609 0 3
44616: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44617: LD_VAR 0 3
44621: PPUSH
44622: CALL_OW 310
44626: IFFALSE 44637
// ComExitBuilding ( j ) ;
44628: LD_VAR 0 3
44632: PPUSH
44633: CALL_OW 122
// wait ( 3 ) ;
44637: LD_INT 3
44639: PPUSH
44640: CALL_OW 67
// if not mc_construct_list [ i ] then
44644: LD_EXP 108
44648: PUSH
44649: LD_VAR 0 2
44653: ARRAY
44654: NOT
44655: IFFALSE 44659
// break ;
44657: GO 44697
// if not HasTask ( j ) then
44659: LD_VAR 0 3
44663: PPUSH
44664: CALL_OW 314
44668: NOT
44669: IFFALSE 44695
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44671: LD_VAR 0 3
44675: PPUSH
44676: LD_EXP 108
44680: PUSH
44681: LD_VAR 0 2
44685: ARRAY
44686: PUSH
44687: LD_INT 1
44689: ARRAY
44690: PPUSH
44691: CALL 74460 0 2
// end ;
44695: GO 44545
44697: POP
44698: POP
// end else
44699: GO 45504
// if mc_build_list [ i ] then
44701: LD_EXP 106
44705: PUSH
44706: LD_VAR 0 2
44710: ARRAY
44711: IFFALSE 45504
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44713: LD_ADDR_VAR 0 5
44717: PUSH
44718: LD_EXP 101
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PPUSH
44729: LD_INT 2
44731: PUSH
44732: LD_INT 30
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 30
44744: PUSH
44745: LD_INT 1
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: LIST
44756: PPUSH
44757: CALL_OW 72
44761: ST_TO_ADDR
// if depot then
44762: LD_VAR 0 5
44766: IFFALSE 44784
// depot := depot [ 1 ] else
44768: LD_ADDR_VAR 0 5
44772: PUSH
44773: LD_VAR 0 5
44777: PUSH
44778: LD_INT 1
44780: ARRAY
44781: ST_TO_ADDR
44782: GO 44792
// depot := 0 ;
44784: LD_ADDR_VAR 0 5
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44792: LD_EXP 106
44796: PUSH
44797: LD_VAR 0 2
44801: ARRAY
44802: PUSH
44803: LD_INT 1
44805: ARRAY
44806: PUSH
44807: LD_INT 1
44809: ARRAY
44810: PPUSH
44811: CALL 74290 0 1
44815: PUSH
44816: LD_EXP 101
44820: PUSH
44821: LD_VAR 0 2
44825: ARRAY
44826: PPUSH
44827: LD_INT 2
44829: PUSH
44830: LD_INT 30
44832: PUSH
44833: LD_INT 2
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 30
44842: PUSH
44843: LD_INT 3
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: LIST
44854: PPUSH
44855: CALL_OW 72
44859: NOT
44860: AND
44861: IFFALSE 44966
// begin for j = 1 to mc_build_list [ i ] do
44863: LD_ADDR_VAR 0 3
44867: PUSH
44868: DOUBLE
44869: LD_INT 1
44871: DEC
44872: ST_TO_ADDR
44873: LD_EXP 106
44877: PUSH
44878: LD_VAR 0 2
44882: ARRAY
44883: PUSH
44884: FOR_TO
44885: IFFALSE 44964
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44887: LD_EXP 106
44891: PUSH
44892: LD_VAR 0 2
44896: ARRAY
44897: PUSH
44898: LD_VAR 0 3
44902: ARRAY
44903: PUSH
44904: LD_INT 1
44906: ARRAY
44907: PUSH
44908: LD_INT 2
44910: EQUAL
44911: IFFALSE 44962
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44913: LD_ADDR_EXP 106
44917: PUSH
44918: LD_EXP 106
44922: PPUSH
44923: LD_VAR 0 2
44927: PPUSH
44928: LD_EXP 106
44932: PUSH
44933: LD_VAR 0 2
44937: ARRAY
44938: PPUSH
44939: LD_VAR 0 3
44943: PPUSH
44944: LD_INT 1
44946: PPUSH
44947: LD_INT 0
44949: PPUSH
44950: CALL 71027 0 4
44954: PPUSH
44955: CALL_OW 1
44959: ST_TO_ADDR
// break ;
44960: GO 44964
// end ;
44962: GO 44884
44964: POP
44965: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44966: LD_EXP 106
44970: PUSH
44971: LD_VAR 0 2
44975: ARRAY
44976: PUSH
44977: LD_INT 1
44979: ARRAY
44980: PUSH
44981: LD_INT 1
44983: ARRAY
44984: PUSH
44985: LD_INT 0
44987: EQUAL
44988: PUSH
44989: LD_VAR 0 5
44993: PUSH
44994: LD_VAR 0 5
44998: PPUSH
44999: LD_EXP 106
45003: PUSH
45004: LD_VAR 0 2
45008: ARRAY
45009: PUSH
45010: LD_INT 1
45012: ARRAY
45013: PUSH
45014: LD_INT 1
45016: ARRAY
45017: PPUSH
45018: LD_EXP 106
45022: PUSH
45023: LD_VAR 0 2
45027: ARRAY
45028: PUSH
45029: LD_INT 1
45031: ARRAY
45032: PUSH
45033: LD_INT 2
45035: ARRAY
45036: PPUSH
45037: LD_EXP 106
45041: PUSH
45042: LD_VAR 0 2
45046: ARRAY
45047: PUSH
45048: LD_INT 1
45050: ARRAY
45051: PUSH
45052: LD_INT 3
45054: ARRAY
45055: PPUSH
45056: LD_EXP 106
45060: PUSH
45061: LD_VAR 0 2
45065: ARRAY
45066: PUSH
45067: LD_INT 1
45069: ARRAY
45070: PUSH
45071: LD_INT 4
45073: ARRAY
45074: PPUSH
45075: CALL 79024 0 5
45079: AND
45080: OR
45081: IFFALSE 45362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45083: LD_ADDR_VAR 0 4
45087: PUSH
45088: LD_EXP 101
45092: PUSH
45093: LD_VAR 0 2
45097: ARRAY
45098: PPUSH
45099: LD_INT 25
45101: PUSH
45102: LD_INT 2
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PPUSH
45109: CALL_OW 72
45113: PUSH
45114: LD_EXP 103
45118: PUSH
45119: LD_VAR 0 2
45123: ARRAY
45124: DIFF
45125: ST_TO_ADDR
// if not tmp then
45126: LD_VAR 0 4
45130: NOT
45131: IFFALSE 45135
// continue ;
45133: GO 44380
// for j in tmp do
45135: LD_ADDR_VAR 0 3
45139: PUSH
45140: LD_VAR 0 4
45144: PUSH
45145: FOR_IN
45146: IFFALSE 45358
// begin if not mc_builders [ i ] then
45148: LD_EXP 107
45152: PUSH
45153: LD_VAR 0 2
45157: ARRAY
45158: NOT
45159: IFFALSE 45217
// begin SetTag ( j , 103 ) ;
45161: LD_VAR 0 3
45165: PPUSH
45166: LD_INT 103
45168: PPUSH
45169: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45173: LD_ADDR_EXP 107
45177: PUSH
45178: LD_EXP 107
45182: PPUSH
45183: LD_VAR 0 2
45187: PUSH
45188: LD_EXP 107
45192: PUSH
45193: LD_VAR 0 2
45197: ARRAY
45198: PUSH
45199: LD_INT 1
45201: PLUS
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PPUSH
45207: LD_VAR 0 3
45211: PPUSH
45212: CALL 71609 0 3
45216: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45217: LD_VAR 0 3
45221: PPUSH
45222: CALL_OW 310
45226: IFFALSE 45237
// ComExitBuilding ( j ) ;
45228: LD_VAR 0 3
45232: PPUSH
45233: CALL_OW 122
// wait ( 3 ) ;
45237: LD_INT 3
45239: PPUSH
45240: CALL_OW 67
// if not mc_build_list [ i ] then
45244: LD_EXP 106
45248: PUSH
45249: LD_VAR 0 2
45253: ARRAY
45254: NOT
45255: IFFALSE 45259
// break ;
45257: GO 45358
// if not HasTask ( j ) then
45259: LD_VAR 0 3
45263: PPUSH
45264: CALL_OW 314
45268: NOT
45269: IFFALSE 45356
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45271: LD_VAR 0 3
45275: PPUSH
45276: LD_EXP 106
45280: PUSH
45281: LD_VAR 0 2
45285: ARRAY
45286: PUSH
45287: LD_INT 1
45289: ARRAY
45290: PUSH
45291: LD_INT 1
45293: ARRAY
45294: PPUSH
45295: LD_EXP 106
45299: PUSH
45300: LD_VAR 0 2
45304: ARRAY
45305: PUSH
45306: LD_INT 1
45308: ARRAY
45309: PUSH
45310: LD_INT 2
45312: ARRAY
45313: PPUSH
45314: LD_EXP 106
45318: PUSH
45319: LD_VAR 0 2
45323: ARRAY
45324: PUSH
45325: LD_INT 1
45327: ARRAY
45328: PUSH
45329: LD_INT 3
45331: ARRAY
45332: PPUSH
45333: LD_EXP 106
45337: PUSH
45338: LD_VAR 0 2
45342: ARRAY
45343: PUSH
45344: LD_INT 1
45346: ARRAY
45347: PUSH
45348: LD_INT 4
45350: ARRAY
45351: PPUSH
45352: CALL_OW 145
// end ;
45356: GO 45145
45358: POP
45359: POP
// end else
45360: GO 45504
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45362: LD_EXP 101
45366: PUSH
45367: LD_VAR 0 2
45371: ARRAY
45372: PPUSH
45373: LD_EXP 106
45377: PUSH
45378: LD_VAR 0 2
45382: ARRAY
45383: PUSH
45384: LD_INT 1
45386: ARRAY
45387: PUSH
45388: LD_INT 1
45390: ARRAY
45391: PPUSH
45392: LD_EXP 106
45396: PUSH
45397: LD_VAR 0 2
45401: ARRAY
45402: PUSH
45403: LD_INT 1
45405: ARRAY
45406: PUSH
45407: LD_INT 2
45409: ARRAY
45410: PPUSH
45411: LD_EXP 106
45415: PUSH
45416: LD_VAR 0 2
45420: ARRAY
45421: PUSH
45422: LD_INT 1
45424: ARRAY
45425: PUSH
45426: LD_INT 3
45428: ARRAY
45429: PPUSH
45430: LD_EXP 106
45434: PUSH
45435: LD_VAR 0 2
45439: ARRAY
45440: PUSH
45441: LD_INT 1
45443: ARRAY
45444: PUSH
45445: LD_INT 4
45447: ARRAY
45448: PPUSH
45449: CALL 78360 0 5
45453: NOT
45454: IFFALSE 45504
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45456: LD_ADDR_EXP 106
45460: PUSH
45461: LD_EXP 106
45465: PPUSH
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_EXP 106
45475: PUSH
45476: LD_VAR 0 2
45480: ARRAY
45481: PPUSH
45482: LD_INT 1
45484: PPUSH
45485: LD_INT 1
45487: NEG
45488: PPUSH
45489: LD_INT 0
45491: PPUSH
45492: CALL 71027 0 4
45496: PPUSH
45497: CALL_OW 1
45501: ST_TO_ADDR
// continue ;
45502: GO 44380
// end ; end ; end ;
45504: GO 44380
45506: POP
45507: POP
// end ;
45508: LD_VAR 0 1
45512: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45513: LD_INT 0
45515: PPUSH
45516: PPUSH
45517: PPUSH
45518: PPUSH
45519: PPUSH
45520: PPUSH
// if not mc_bases then
45521: LD_EXP 101
45525: NOT
45526: IFFALSE 45530
// exit ;
45528: GO 45957
// for i = 1 to mc_bases do
45530: LD_ADDR_VAR 0 2
45534: PUSH
45535: DOUBLE
45536: LD_INT 1
45538: DEC
45539: ST_TO_ADDR
45540: LD_EXP 101
45544: PUSH
45545: FOR_TO
45546: IFFALSE 45955
// begin tmp := mc_build_upgrade [ i ] ;
45548: LD_ADDR_VAR 0 4
45552: PUSH
45553: LD_EXP 133
45557: PUSH
45558: LD_VAR 0 2
45562: ARRAY
45563: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45564: LD_ADDR_VAR 0 6
45568: PUSH
45569: LD_EXP 134
45573: PUSH
45574: LD_VAR 0 2
45578: ARRAY
45579: PPUSH
45580: LD_INT 2
45582: PUSH
45583: LD_INT 30
45585: PUSH
45586: LD_INT 6
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 30
45595: PUSH
45596: LD_INT 7
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: LIST
45607: PPUSH
45608: CALL_OW 72
45612: ST_TO_ADDR
// if not tmp and not lab then
45613: LD_VAR 0 4
45617: NOT
45618: PUSH
45619: LD_VAR 0 6
45623: NOT
45624: AND
45625: IFFALSE 45629
// continue ;
45627: GO 45545
// if tmp then
45629: LD_VAR 0 4
45633: IFFALSE 45753
// for j in tmp do
45635: LD_ADDR_VAR 0 3
45639: PUSH
45640: LD_VAR 0 4
45644: PUSH
45645: FOR_IN
45646: IFFALSE 45751
// begin if UpgradeCost ( j ) then
45648: LD_VAR 0 3
45652: PPUSH
45653: CALL 78020 0 1
45657: IFFALSE 45749
// begin ComUpgrade ( j ) ;
45659: LD_VAR 0 3
45663: PPUSH
45664: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45668: LD_ADDR_EXP 133
45672: PUSH
45673: LD_EXP 133
45677: PPUSH
45678: LD_VAR 0 2
45682: PPUSH
45683: LD_EXP 133
45687: PUSH
45688: LD_VAR 0 2
45692: ARRAY
45693: PUSH
45694: LD_VAR 0 3
45698: DIFF
45699: PPUSH
45700: CALL_OW 1
45704: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45705: LD_ADDR_EXP 108
45709: PUSH
45710: LD_EXP 108
45714: PPUSH
45715: LD_VAR 0 2
45719: PUSH
45720: LD_EXP 108
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: PUSH
45731: LD_INT 1
45733: PLUS
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PPUSH
45739: LD_VAR 0 3
45743: PPUSH
45744: CALL 71609 0 3
45748: ST_TO_ADDR
// end ; end ;
45749: GO 45645
45751: POP
45752: POP
// if not lab or not mc_lab_upgrade [ i ] then
45753: LD_VAR 0 6
45757: NOT
45758: PUSH
45759: LD_EXP 135
45763: PUSH
45764: LD_VAR 0 2
45768: ARRAY
45769: NOT
45770: OR
45771: IFFALSE 45775
// continue ;
45773: GO 45545
// for j in lab do
45775: LD_ADDR_VAR 0 3
45779: PUSH
45780: LD_VAR 0 6
45784: PUSH
45785: FOR_IN
45786: IFFALSE 45951
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45788: LD_VAR 0 3
45792: PPUSH
45793: CALL_OW 266
45797: PUSH
45798: LD_INT 6
45800: PUSH
45801: LD_INT 7
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: IN
45808: PUSH
45809: LD_VAR 0 3
45813: PPUSH
45814: CALL_OW 461
45818: PUSH
45819: LD_INT 1
45821: NONEQUAL
45822: AND
45823: IFFALSE 45949
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45825: LD_VAR 0 3
45829: PPUSH
45830: LD_EXP 135
45834: PUSH
45835: LD_VAR 0 2
45839: ARRAY
45840: PUSH
45841: LD_INT 1
45843: ARRAY
45844: PPUSH
45845: CALL 78225 0 2
45849: IFFALSE 45949
// begin ComCancel ( j ) ;
45851: LD_VAR 0 3
45855: PPUSH
45856: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45860: LD_VAR 0 3
45864: PPUSH
45865: LD_EXP 135
45869: PUSH
45870: LD_VAR 0 2
45874: ARRAY
45875: PUSH
45876: LD_INT 1
45878: ARRAY
45879: PPUSH
45880: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45884: LD_VAR 0 3
45888: PUSH
45889: LD_EXP 108
45893: PUSH
45894: LD_VAR 0 2
45898: ARRAY
45899: IN
45900: NOT
45901: IFFALSE 45947
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45903: LD_ADDR_EXP 108
45907: PUSH
45908: LD_EXP 108
45912: PPUSH
45913: LD_VAR 0 2
45917: PUSH
45918: LD_EXP 108
45922: PUSH
45923: LD_VAR 0 2
45927: ARRAY
45928: PUSH
45929: LD_INT 1
45931: PLUS
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PPUSH
45937: LD_VAR 0 3
45941: PPUSH
45942: CALL 71609 0 3
45946: ST_TO_ADDR
// break ;
45947: GO 45951
// end ; end ; end ;
45949: GO 45785
45951: POP
45952: POP
// end ;
45953: GO 45545
45955: POP
45956: POP
// end ;
45957: LD_VAR 0 1
45961: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45962: LD_INT 0
45964: PPUSH
45965: PPUSH
45966: PPUSH
45967: PPUSH
45968: PPUSH
45969: PPUSH
45970: PPUSH
45971: PPUSH
45972: PPUSH
// if not mc_bases then
45973: LD_EXP 101
45977: NOT
45978: IFFALSE 45982
// exit ;
45980: GO 46387
// for i = 1 to mc_bases do
45982: LD_ADDR_VAR 0 2
45986: PUSH
45987: DOUBLE
45988: LD_INT 1
45990: DEC
45991: ST_TO_ADDR
45992: LD_EXP 101
45996: PUSH
45997: FOR_TO
45998: IFFALSE 46385
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46000: LD_EXP 109
46004: PUSH
46005: LD_VAR 0 2
46009: ARRAY
46010: NOT
46011: PUSH
46012: LD_EXP 101
46016: PUSH
46017: LD_VAR 0 2
46021: ARRAY
46022: PPUSH
46023: LD_INT 30
46025: PUSH
46026: LD_INT 3
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PPUSH
46033: CALL_OW 72
46037: NOT
46038: OR
46039: IFFALSE 46043
// continue ;
46041: GO 45997
// busy := false ;
46043: LD_ADDR_VAR 0 8
46047: PUSH
46048: LD_INT 0
46050: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46051: LD_ADDR_VAR 0 4
46055: PUSH
46056: LD_EXP 101
46060: PUSH
46061: LD_VAR 0 2
46065: ARRAY
46066: PPUSH
46067: LD_INT 30
46069: PUSH
46070: LD_INT 3
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PPUSH
46077: CALL_OW 72
46081: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46082: LD_ADDR_VAR 0 6
46086: PUSH
46087: LD_EXP 109
46091: PUSH
46092: LD_VAR 0 2
46096: ARRAY
46097: PPUSH
46098: LD_INT 2
46100: PUSH
46101: LD_INT 30
46103: PUSH
46104: LD_INT 32
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 30
46113: PUSH
46114: LD_INT 33
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: LIST
46125: PPUSH
46126: CALL_OW 72
46130: ST_TO_ADDR
// if not t then
46131: LD_VAR 0 6
46135: NOT
46136: IFFALSE 46140
// continue ;
46138: GO 45997
// for j in tmp do
46140: LD_ADDR_VAR 0 3
46144: PUSH
46145: LD_VAR 0 4
46149: PUSH
46150: FOR_IN
46151: IFFALSE 46181
// if not BuildingStatus ( j ) = bs_idle then
46153: LD_VAR 0 3
46157: PPUSH
46158: CALL_OW 461
46162: PUSH
46163: LD_INT 2
46165: EQUAL
46166: NOT
46167: IFFALSE 46179
// begin busy := true ;
46169: LD_ADDR_VAR 0 8
46173: PUSH
46174: LD_INT 1
46176: ST_TO_ADDR
// break ;
46177: GO 46181
// end ;
46179: GO 46150
46181: POP
46182: POP
// if busy then
46183: LD_VAR 0 8
46187: IFFALSE 46191
// continue ;
46189: GO 45997
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46191: LD_ADDR_VAR 0 7
46195: PUSH
46196: LD_VAR 0 6
46200: PPUSH
46201: LD_INT 35
46203: PUSH
46204: LD_INT 0
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PPUSH
46211: CALL_OW 72
46215: ST_TO_ADDR
// if tw then
46216: LD_VAR 0 7
46220: IFFALSE 46297
// begin tw := tw [ 1 ] ;
46222: LD_ADDR_VAR 0 7
46226: PUSH
46227: LD_VAR 0 7
46231: PUSH
46232: LD_INT 1
46234: ARRAY
46235: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46236: LD_ADDR_VAR 0 9
46240: PUSH
46241: LD_VAR 0 7
46245: PPUSH
46246: LD_EXP 126
46250: PUSH
46251: LD_VAR 0 2
46255: ARRAY
46256: PPUSH
46257: CALL 76579 0 2
46261: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46262: LD_EXP 140
46266: PUSH
46267: LD_VAR 0 2
46271: ARRAY
46272: IFFALSE 46295
// if not weapon in mc_allowed_tower_weapons [ i ] then
46274: LD_VAR 0 9
46278: PUSH
46279: LD_EXP 140
46283: PUSH
46284: LD_VAR 0 2
46288: ARRAY
46289: IN
46290: NOT
46291: IFFALSE 46295
// continue ;
46293: GO 45997
// end else
46295: GO 46360
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46297: LD_ADDR_VAR 0 5
46301: PUSH
46302: LD_EXP 109
46306: PUSH
46307: LD_VAR 0 2
46311: ARRAY
46312: PPUSH
46313: LD_VAR 0 4
46317: PPUSH
46318: CALL 106780 0 2
46322: ST_TO_ADDR
// if not tmp2 then
46323: LD_VAR 0 5
46327: NOT
46328: IFFALSE 46332
// continue ;
46330: GO 45997
// tw := tmp2 [ 1 ] ;
46332: LD_ADDR_VAR 0 7
46336: PUSH
46337: LD_VAR 0 5
46341: PUSH
46342: LD_INT 1
46344: ARRAY
46345: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46346: LD_ADDR_VAR 0 9
46350: PUSH
46351: LD_VAR 0 5
46355: PUSH
46356: LD_INT 2
46358: ARRAY
46359: ST_TO_ADDR
// end ; if not weapon then
46360: LD_VAR 0 9
46364: NOT
46365: IFFALSE 46369
// continue ;
46367: GO 45997
// ComPlaceWeapon ( tw , weapon ) ;
46369: LD_VAR 0 7
46373: PPUSH
46374: LD_VAR 0 9
46378: PPUSH
46379: CALL_OW 148
// end ;
46383: GO 45997
46385: POP
46386: POP
// end ;
46387: LD_VAR 0 1
46391: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46392: LD_INT 0
46394: PPUSH
46395: PPUSH
46396: PPUSH
46397: PPUSH
46398: PPUSH
46399: PPUSH
// if not mc_bases then
46400: LD_EXP 101
46404: NOT
46405: IFFALSE 46409
// exit ;
46407: GO 47421
// for i = 1 to mc_bases do
46409: LD_ADDR_VAR 0 2
46413: PUSH
46414: DOUBLE
46415: LD_INT 1
46417: DEC
46418: ST_TO_ADDR
46419: LD_EXP 101
46423: PUSH
46424: FOR_TO
46425: IFFALSE 47419
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46427: LD_EXP 114
46431: PUSH
46432: LD_VAR 0 2
46436: ARRAY
46437: NOT
46438: PUSH
46439: LD_EXP 114
46443: PUSH
46444: LD_VAR 0 2
46448: ARRAY
46449: PUSH
46450: LD_EXP 115
46454: PUSH
46455: LD_VAR 0 2
46459: ARRAY
46460: EQUAL
46461: OR
46462: IFFALSE 46466
// continue ;
46464: GO 46424
// if mc_miners [ i ] then
46466: LD_EXP 115
46470: PUSH
46471: LD_VAR 0 2
46475: ARRAY
46476: IFFALSE 47106
// begin k := 1 ;
46478: LD_ADDR_VAR 0 4
46482: PUSH
46483: LD_INT 1
46485: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46486: LD_ADDR_VAR 0 3
46490: PUSH
46491: DOUBLE
46492: LD_EXP 115
46496: PUSH
46497: LD_VAR 0 2
46501: ARRAY
46502: INC
46503: ST_TO_ADDR
46504: LD_INT 1
46506: PUSH
46507: FOR_DOWNTO
46508: IFFALSE 47104
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46510: LD_EXP 115
46514: PUSH
46515: LD_VAR 0 2
46519: ARRAY
46520: PUSH
46521: LD_VAR 0 3
46525: ARRAY
46526: PPUSH
46527: CALL_OW 301
46531: PUSH
46532: LD_EXP 115
46536: PUSH
46537: LD_VAR 0 2
46541: ARRAY
46542: PUSH
46543: LD_VAR 0 3
46547: ARRAY
46548: PPUSH
46549: CALL_OW 257
46553: PUSH
46554: LD_INT 1
46556: NONEQUAL
46557: OR
46558: IFFALSE 46621
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46560: LD_ADDR_VAR 0 5
46564: PUSH
46565: LD_EXP 115
46569: PUSH
46570: LD_VAR 0 2
46574: ARRAY
46575: PUSH
46576: LD_EXP 115
46580: PUSH
46581: LD_VAR 0 2
46585: ARRAY
46586: PUSH
46587: LD_VAR 0 3
46591: ARRAY
46592: DIFF
46593: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46594: LD_ADDR_EXP 115
46598: PUSH
46599: LD_EXP 115
46603: PPUSH
46604: LD_VAR 0 2
46608: PPUSH
46609: LD_VAR 0 5
46613: PPUSH
46614: CALL_OW 1
46618: ST_TO_ADDR
// continue ;
46619: GO 46507
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46621: LD_EXP 115
46625: PUSH
46626: LD_VAR 0 2
46630: ARRAY
46631: PUSH
46632: LD_VAR 0 3
46636: ARRAY
46637: PPUSH
46638: CALL 71545 0 1
46642: PUSH
46643: LD_EXP 115
46647: PUSH
46648: LD_VAR 0 2
46652: ARRAY
46653: PUSH
46654: LD_VAR 0 3
46658: ARRAY
46659: PPUSH
46660: CALL_OW 255
46664: PPUSH
46665: LD_EXP 114
46669: PUSH
46670: LD_VAR 0 2
46674: ARRAY
46675: PUSH
46676: LD_VAR 0 4
46680: ARRAY
46681: PUSH
46682: LD_INT 1
46684: ARRAY
46685: PPUSH
46686: LD_EXP 114
46690: PUSH
46691: LD_VAR 0 2
46695: ARRAY
46696: PUSH
46697: LD_VAR 0 4
46701: ARRAY
46702: PUSH
46703: LD_INT 2
46705: ARRAY
46706: PPUSH
46707: LD_INT 15
46709: PPUSH
46710: CALL 72505 0 4
46714: PUSH
46715: LD_INT 4
46717: ARRAY
46718: PUSH
46719: LD_EXP 115
46723: PUSH
46724: LD_VAR 0 2
46728: ARRAY
46729: PUSH
46730: LD_VAR 0 3
46734: ARRAY
46735: PPUSH
46736: LD_INT 10
46738: PPUSH
46739: CALL 74202 0 2
46743: PUSH
46744: LD_INT 4
46746: ARRAY
46747: OR
46748: AND
46749: IFFALSE 46772
// ComStop ( mc_miners [ i ] [ j ] ) ;
46751: LD_EXP 115
46755: PUSH
46756: LD_VAR 0 2
46760: ARRAY
46761: PUSH
46762: LD_VAR 0 3
46766: ARRAY
46767: PPUSH
46768: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46772: LD_EXP 115
46776: PUSH
46777: LD_VAR 0 2
46781: ARRAY
46782: PUSH
46783: LD_VAR 0 3
46787: ARRAY
46788: PPUSH
46789: CALL_OW 257
46793: PUSH
46794: LD_INT 1
46796: EQUAL
46797: PUSH
46798: LD_EXP 115
46802: PUSH
46803: LD_VAR 0 2
46807: ARRAY
46808: PUSH
46809: LD_VAR 0 3
46813: ARRAY
46814: PPUSH
46815: CALL_OW 459
46819: NOT
46820: AND
46821: PUSH
46822: LD_EXP 115
46826: PUSH
46827: LD_VAR 0 2
46831: ARRAY
46832: PUSH
46833: LD_VAR 0 3
46837: ARRAY
46838: PPUSH
46839: CALL_OW 255
46843: PPUSH
46844: LD_EXP 114
46848: PUSH
46849: LD_VAR 0 2
46853: ARRAY
46854: PUSH
46855: LD_VAR 0 4
46859: ARRAY
46860: PUSH
46861: LD_INT 1
46863: ARRAY
46864: PPUSH
46865: LD_EXP 114
46869: PUSH
46870: LD_VAR 0 2
46874: ARRAY
46875: PUSH
46876: LD_VAR 0 4
46880: ARRAY
46881: PUSH
46882: LD_INT 2
46884: ARRAY
46885: PPUSH
46886: LD_INT 15
46888: PPUSH
46889: CALL 72505 0 4
46893: PUSH
46894: LD_INT 4
46896: ARRAY
46897: PUSH
46898: LD_INT 0
46900: EQUAL
46901: AND
46902: PUSH
46903: LD_EXP 115
46907: PUSH
46908: LD_VAR 0 2
46912: ARRAY
46913: PUSH
46914: LD_VAR 0 3
46918: ARRAY
46919: PPUSH
46920: CALL_OW 314
46924: NOT
46925: AND
46926: IFFALSE 47102
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46928: LD_EXP 115
46932: PUSH
46933: LD_VAR 0 2
46937: ARRAY
46938: PUSH
46939: LD_VAR 0 3
46943: ARRAY
46944: PPUSH
46945: CALL_OW 310
46949: IFFALSE 46972
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46951: LD_EXP 115
46955: PUSH
46956: LD_VAR 0 2
46960: ARRAY
46961: PUSH
46962: LD_VAR 0 3
46966: ARRAY
46967: PPUSH
46968: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46972: LD_EXP 115
46976: PUSH
46977: LD_VAR 0 2
46981: ARRAY
46982: PUSH
46983: LD_VAR 0 3
46987: ARRAY
46988: PPUSH
46989: CALL_OW 314
46993: NOT
46994: IFFALSE 47062
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46996: LD_EXP 115
47000: PUSH
47001: LD_VAR 0 2
47005: ARRAY
47006: PUSH
47007: LD_VAR 0 3
47011: ARRAY
47012: PPUSH
47013: LD_EXP 114
47017: PUSH
47018: LD_VAR 0 2
47022: ARRAY
47023: PUSH
47024: LD_VAR 0 4
47028: ARRAY
47029: PUSH
47030: LD_INT 1
47032: ARRAY
47033: PPUSH
47034: LD_EXP 114
47038: PUSH
47039: LD_VAR 0 2
47043: ARRAY
47044: PUSH
47045: LD_VAR 0 4
47049: ARRAY
47050: PUSH
47051: LD_INT 2
47053: ARRAY
47054: PPUSH
47055: LD_INT 0
47057: PPUSH
47058: CALL_OW 193
// k := k + 1 ;
47062: LD_ADDR_VAR 0 4
47066: PUSH
47067: LD_VAR 0 4
47071: PUSH
47072: LD_INT 1
47074: PLUS
47075: ST_TO_ADDR
// if k > mc_mines [ i ] then
47076: LD_VAR 0 4
47080: PUSH
47081: LD_EXP 114
47085: PUSH
47086: LD_VAR 0 2
47090: ARRAY
47091: GREATER
47092: IFFALSE 47102
// k := 1 ;
47094: LD_ADDR_VAR 0 4
47098: PUSH
47099: LD_INT 1
47101: ST_TO_ADDR
// end ; end ;
47102: GO 46507
47104: POP
47105: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47106: LD_ADDR_VAR 0 5
47110: PUSH
47111: LD_EXP 101
47115: PUSH
47116: LD_VAR 0 2
47120: ARRAY
47121: PPUSH
47122: LD_INT 2
47124: PUSH
47125: LD_INT 30
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 30
47137: PUSH
47138: LD_INT 5
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 32
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: PPUSH
47161: CALL_OW 72
47165: ST_TO_ADDR
// if not tmp then
47166: LD_VAR 0 5
47170: NOT
47171: IFFALSE 47175
// continue ;
47173: GO 46424
// list := [ ] ;
47175: LD_ADDR_VAR 0 6
47179: PUSH
47180: EMPTY
47181: ST_TO_ADDR
// for j in tmp do
47182: LD_ADDR_VAR 0 3
47186: PUSH
47187: LD_VAR 0 5
47191: PUSH
47192: FOR_IN
47193: IFFALSE 47262
// begin for k in UnitsInside ( j ) do
47195: LD_ADDR_VAR 0 4
47199: PUSH
47200: LD_VAR 0 3
47204: PPUSH
47205: CALL_OW 313
47209: PUSH
47210: FOR_IN
47211: IFFALSE 47258
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47213: LD_VAR 0 4
47217: PPUSH
47218: CALL_OW 257
47222: PUSH
47223: LD_INT 1
47225: EQUAL
47226: PUSH
47227: LD_VAR 0 4
47231: PPUSH
47232: CALL_OW 459
47236: NOT
47237: AND
47238: IFFALSE 47256
// list := list ^ k ;
47240: LD_ADDR_VAR 0 6
47244: PUSH
47245: LD_VAR 0 6
47249: PUSH
47250: LD_VAR 0 4
47254: ADD
47255: ST_TO_ADDR
47256: GO 47210
47258: POP
47259: POP
// end ;
47260: GO 47192
47262: POP
47263: POP
// list := list diff mc_miners [ i ] ;
47264: LD_ADDR_VAR 0 6
47268: PUSH
47269: LD_VAR 0 6
47273: PUSH
47274: LD_EXP 115
47278: PUSH
47279: LD_VAR 0 2
47283: ARRAY
47284: DIFF
47285: ST_TO_ADDR
// if not list then
47286: LD_VAR 0 6
47290: NOT
47291: IFFALSE 47295
// continue ;
47293: GO 46424
// k := mc_mines [ i ] - mc_miners [ i ] ;
47295: LD_ADDR_VAR 0 4
47299: PUSH
47300: LD_EXP 114
47304: PUSH
47305: LD_VAR 0 2
47309: ARRAY
47310: PUSH
47311: LD_EXP 115
47315: PUSH
47316: LD_VAR 0 2
47320: ARRAY
47321: MINUS
47322: ST_TO_ADDR
// if k > list then
47323: LD_VAR 0 4
47327: PUSH
47328: LD_VAR 0 6
47332: GREATER
47333: IFFALSE 47345
// k := list ;
47335: LD_ADDR_VAR 0 4
47339: PUSH
47340: LD_VAR 0 6
47344: ST_TO_ADDR
// for j = 1 to k do
47345: LD_ADDR_VAR 0 3
47349: PUSH
47350: DOUBLE
47351: LD_INT 1
47353: DEC
47354: ST_TO_ADDR
47355: LD_VAR 0 4
47359: PUSH
47360: FOR_TO
47361: IFFALSE 47415
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47363: LD_ADDR_EXP 115
47367: PUSH
47368: LD_EXP 115
47372: PPUSH
47373: LD_VAR 0 2
47377: PUSH
47378: LD_EXP 115
47382: PUSH
47383: LD_VAR 0 2
47387: ARRAY
47388: PUSH
47389: LD_INT 1
47391: PLUS
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PPUSH
47397: LD_VAR 0 6
47401: PUSH
47402: LD_VAR 0 3
47406: ARRAY
47407: PPUSH
47408: CALL 71609 0 3
47412: ST_TO_ADDR
47413: GO 47360
47415: POP
47416: POP
// end ;
47417: GO 46424
47419: POP
47420: POP
// end ;
47421: LD_VAR 0 1
47425: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47426: LD_INT 0
47428: PPUSH
47429: PPUSH
47430: PPUSH
47431: PPUSH
47432: PPUSH
47433: PPUSH
47434: PPUSH
47435: PPUSH
47436: PPUSH
47437: PPUSH
// if not mc_bases then
47438: LD_EXP 101
47442: NOT
47443: IFFALSE 47447
// exit ;
47445: GO 49197
// for i = 1 to mc_bases do
47447: LD_ADDR_VAR 0 2
47451: PUSH
47452: DOUBLE
47453: LD_INT 1
47455: DEC
47456: ST_TO_ADDR
47457: LD_EXP 101
47461: PUSH
47462: FOR_TO
47463: IFFALSE 49195
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47465: LD_EXP 101
47469: PUSH
47470: LD_VAR 0 2
47474: ARRAY
47475: NOT
47476: PUSH
47477: LD_EXP 108
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: OR
47488: IFFALSE 47492
// continue ;
47490: GO 47462
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47492: LD_EXP 117
47496: PUSH
47497: LD_VAR 0 2
47501: ARRAY
47502: NOT
47503: PUSH
47504: LD_EXP 118
47508: PUSH
47509: LD_VAR 0 2
47513: ARRAY
47514: AND
47515: IFFALSE 47553
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47517: LD_ADDR_EXP 118
47521: PUSH
47522: LD_EXP 118
47526: PPUSH
47527: LD_VAR 0 2
47531: PPUSH
47532: EMPTY
47533: PPUSH
47534: CALL_OW 1
47538: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47539: LD_VAR 0 2
47543: PPUSH
47544: LD_INT 107
47546: PPUSH
47547: CALL 38307 0 2
// continue ;
47551: GO 47462
// end ; target := [ ] ;
47553: LD_ADDR_VAR 0 6
47557: PUSH
47558: EMPTY
47559: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47560: LD_ADDR_VAR 0 3
47564: PUSH
47565: DOUBLE
47566: LD_EXP 117
47570: PUSH
47571: LD_VAR 0 2
47575: ARRAY
47576: INC
47577: ST_TO_ADDR
47578: LD_INT 1
47580: PUSH
47581: FOR_DOWNTO
47582: IFFALSE 47842
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47584: LD_EXP 117
47588: PUSH
47589: LD_VAR 0 2
47593: ARRAY
47594: PUSH
47595: LD_VAR 0 3
47599: ARRAY
47600: PUSH
47601: LD_INT 2
47603: ARRAY
47604: PPUSH
47605: LD_EXP 117
47609: PUSH
47610: LD_VAR 0 2
47614: ARRAY
47615: PUSH
47616: LD_VAR 0 3
47620: ARRAY
47621: PUSH
47622: LD_INT 3
47624: ARRAY
47625: PPUSH
47626: CALL_OW 488
47630: PUSH
47631: LD_EXP 117
47635: PUSH
47636: LD_VAR 0 2
47640: ARRAY
47641: PUSH
47642: LD_VAR 0 3
47646: ARRAY
47647: PUSH
47648: LD_INT 2
47650: ARRAY
47651: PPUSH
47652: LD_EXP 117
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: PUSH
47669: LD_INT 3
47671: ARRAY
47672: PPUSH
47673: CALL_OW 284
47677: PUSH
47678: LD_INT 0
47680: EQUAL
47681: AND
47682: IFFALSE 47737
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47684: LD_ADDR_VAR 0 5
47688: PUSH
47689: LD_EXP 117
47693: PUSH
47694: LD_VAR 0 2
47698: ARRAY
47699: PPUSH
47700: LD_VAR 0 3
47704: PPUSH
47705: CALL_OW 3
47709: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47710: LD_ADDR_EXP 117
47714: PUSH
47715: LD_EXP 117
47719: PPUSH
47720: LD_VAR 0 2
47724: PPUSH
47725: LD_VAR 0 5
47729: PPUSH
47730: CALL_OW 1
47734: ST_TO_ADDR
// continue ;
47735: GO 47581
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47737: LD_EXP 101
47741: PUSH
47742: LD_VAR 0 2
47746: ARRAY
47747: PUSH
47748: LD_INT 1
47750: ARRAY
47751: PPUSH
47752: CALL_OW 255
47756: PPUSH
47757: LD_EXP 117
47761: PUSH
47762: LD_VAR 0 2
47766: ARRAY
47767: PUSH
47768: LD_VAR 0 3
47772: ARRAY
47773: PUSH
47774: LD_INT 2
47776: ARRAY
47777: PPUSH
47778: LD_EXP 117
47782: PUSH
47783: LD_VAR 0 2
47787: ARRAY
47788: PUSH
47789: LD_VAR 0 3
47793: ARRAY
47794: PUSH
47795: LD_INT 3
47797: ARRAY
47798: PPUSH
47799: LD_INT 30
47801: PPUSH
47802: CALL 72505 0 4
47806: PUSH
47807: LD_INT 4
47809: ARRAY
47810: PUSH
47811: LD_INT 0
47813: EQUAL
47814: IFFALSE 47840
// begin target := mc_crates [ i ] [ j ] ;
47816: LD_ADDR_VAR 0 6
47820: PUSH
47821: LD_EXP 117
47825: PUSH
47826: LD_VAR 0 2
47830: ARRAY
47831: PUSH
47832: LD_VAR 0 3
47836: ARRAY
47837: ST_TO_ADDR
// break ;
47838: GO 47842
// end ; end ;
47840: GO 47581
47842: POP
47843: POP
// if not target then
47844: LD_VAR 0 6
47848: NOT
47849: IFFALSE 47853
// continue ;
47851: GO 47462
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47853: LD_ADDR_VAR 0 7
47857: PUSH
47858: LD_EXP 120
47862: PUSH
47863: LD_VAR 0 2
47867: ARRAY
47868: PPUSH
47869: LD_INT 2
47871: PUSH
47872: LD_INT 3
47874: PUSH
47875: LD_INT 58
47877: PUSH
47878: EMPTY
47879: LIST
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 61
47887: PUSH
47888: EMPTY
47889: LIST
47890: PUSH
47891: LD_INT 33
47893: PUSH
47894: LD_INT 5
47896: PUSH
47897: EMPTY
47898: LIST
47899: LIST
47900: PUSH
47901: LD_INT 33
47903: PUSH
47904: LD_INT 3
47906: PUSH
47907: EMPTY
47908: LIST
47909: LIST
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: LIST
47917: PUSH
47918: LD_INT 2
47920: PUSH
47921: LD_INT 34
47923: PUSH
47924: LD_INT 32
47926: PUSH
47927: EMPTY
47928: LIST
47929: LIST
47930: PUSH
47931: LD_INT 34
47933: PUSH
47934: LD_INT 51
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PUSH
47941: LD_INT 34
47943: PUSH
47944: LD_INT 12
47946: PUSH
47947: EMPTY
47948: LIST
47949: LIST
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: PPUSH
47961: CALL_OW 72
47965: ST_TO_ADDR
// if not cargo then
47966: LD_VAR 0 7
47970: NOT
47971: IFFALSE 48614
// begin if mc_crates_collector [ i ] < 5 then
47973: LD_EXP 118
47977: PUSH
47978: LD_VAR 0 2
47982: ARRAY
47983: PUSH
47984: LD_INT 5
47986: LESS
47987: IFFALSE 48353
// begin if mc_ape [ i ] then
47989: LD_EXP 130
47993: PUSH
47994: LD_VAR 0 2
47998: ARRAY
47999: IFFALSE 48046
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48001: LD_ADDR_VAR 0 5
48005: PUSH
48006: LD_EXP 130
48010: PUSH
48011: LD_VAR 0 2
48015: ARRAY
48016: PPUSH
48017: LD_INT 25
48019: PUSH
48020: LD_INT 16
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 24
48029: PUSH
48030: LD_INT 750
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PPUSH
48041: CALL_OW 72
48045: ST_TO_ADDR
// if not tmp then
48046: LD_VAR 0 5
48050: NOT
48051: IFFALSE 48098
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48053: LD_ADDR_VAR 0 5
48057: PUSH
48058: LD_EXP 101
48062: PUSH
48063: LD_VAR 0 2
48067: ARRAY
48068: PPUSH
48069: LD_INT 25
48071: PUSH
48072: LD_INT 2
48074: PUSH
48075: EMPTY
48076: LIST
48077: LIST
48078: PUSH
48079: LD_INT 24
48081: PUSH
48082: LD_INT 750
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PPUSH
48093: CALL_OW 72
48097: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48098: LD_EXP 130
48102: PUSH
48103: LD_VAR 0 2
48107: ARRAY
48108: PUSH
48109: LD_EXP 101
48113: PUSH
48114: LD_VAR 0 2
48118: ARRAY
48119: PPUSH
48120: LD_INT 25
48122: PUSH
48123: LD_INT 2
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: LD_INT 24
48132: PUSH
48133: LD_INT 750
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PPUSH
48144: CALL_OW 72
48148: AND
48149: PUSH
48150: LD_VAR 0 5
48154: PUSH
48155: LD_INT 5
48157: LESS
48158: AND
48159: IFFALSE 48241
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48161: LD_ADDR_VAR 0 3
48165: PUSH
48166: LD_EXP 101
48170: PUSH
48171: LD_VAR 0 2
48175: ARRAY
48176: PPUSH
48177: LD_INT 25
48179: PUSH
48180: LD_INT 2
48182: PUSH
48183: EMPTY
48184: LIST
48185: LIST
48186: PUSH
48187: LD_INT 24
48189: PUSH
48190: LD_INT 750
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PPUSH
48201: CALL_OW 72
48205: PUSH
48206: FOR_IN
48207: IFFALSE 48239
// begin tmp := tmp union j ;
48209: LD_ADDR_VAR 0 5
48213: PUSH
48214: LD_VAR 0 5
48218: PUSH
48219: LD_VAR 0 3
48223: UNION
48224: ST_TO_ADDR
// if tmp >= 5 then
48225: LD_VAR 0 5
48229: PUSH
48230: LD_INT 5
48232: GREATEREQUAL
48233: IFFALSE 48237
// break ;
48235: GO 48239
// end ;
48237: GO 48206
48239: POP
48240: POP
// end ; if not tmp then
48241: LD_VAR 0 5
48245: NOT
48246: IFFALSE 48250
// continue ;
48248: GO 47462
// for j in tmp do
48250: LD_ADDR_VAR 0 3
48254: PUSH
48255: LD_VAR 0 5
48259: PUSH
48260: FOR_IN
48261: IFFALSE 48351
// if not GetTag ( j ) then
48263: LD_VAR 0 3
48267: PPUSH
48268: CALL_OW 110
48272: NOT
48273: IFFALSE 48349
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48275: LD_ADDR_EXP 118
48279: PUSH
48280: LD_EXP 118
48284: PPUSH
48285: LD_VAR 0 2
48289: PUSH
48290: LD_EXP 118
48294: PUSH
48295: LD_VAR 0 2
48299: ARRAY
48300: PUSH
48301: LD_INT 1
48303: PLUS
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PPUSH
48309: LD_VAR 0 3
48313: PPUSH
48314: CALL 71609 0 3
48318: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48319: LD_VAR 0 3
48323: PPUSH
48324: LD_INT 107
48326: PPUSH
48327: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48331: LD_EXP 118
48335: PUSH
48336: LD_VAR 0 2
48340: ARRAY
48341: PUSH
48342: LD_INT 5
48344: GREATEREQUAL
48345: IFFALSE 48349
// break ;
48347: GO 48351
// end ;
48349: GO 48260
48351: POP
48352: POP
// end ; if mc_crates_collector [ i ] and target then
48353: LD_EXP 118
48357: PUSH
48358: LD_VAR 0 2
48362: ARRAY
48363: PUSH
48364: LD_VAR 0 6
48368: AND
48369: IFFALSE 48612
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48371: LD_EXP 118
48375: PUSH
48376: LD_VAR 0 2
48380: ARRAY
48381: PUSH
48382: LD_VAR 0 6
48386: PUSH
48387: LD_INT 1
48389: ARRAY
48390: LESS
48391: IFFALSE 48411
// tmp := mc_crates_collector [ i ] else
48393: LD_ADDR_VAR 0 5
48397: PUSH
48398: LD_EXP 118
48402: PUSH
48403: LD_VAR 0 2
48407: ARRAY
48408: ST_TO_ADDR
48409: GO 48425
// tmp := target [ 1 ] ;
48411: LD_ADDR_VAR 0 5
48415: PUSH
48416: LD_VAR 0 6
48420: PUSH
48421: LD_INT 1
48423: ARRAY
48424: ST_TO_ADDR
// k := 0 ;
48425: LD_ADDR_VAR 0 4
48429: PUSH
48430: LD_INT 0
48432: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48433: LD_ADDR_VAR 0 3
48437: PUSH
48438: LD_EXP 118
48442: PUSH
48443: LD_VAR 0 2
48447: ARRAY
48448: PUSH
48449: FOR_IN
48450: IFFALSE 48610
// begin k := k + 1 ;
48452: LD_ADDR_VAR 0 4
48456: PUSH
48457: LD_VAR 0 4
48461: PUSH
48462: LD_INT 1
48464: PLUS
48465: ST_TO_ADDR
// if k > tmp then
48466: LD_VAR 0 4
48470: PUSH
48471: LD_VAR 0 5
48475: GREATER
48476: IFFALSE 48480
// break ;
48478: GO 48610
// if not GetClass ( j ) in [ 2 , 16 ] then
48480: LD_VAR 0 3
48484: PPUSH
48485: CALL_OW 257
48489: PUSH
48490: LD_INT 2
48492: PUSH
48493: LD_INT 16
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: IN
48500: NOT
48501: IFFALSE 48554
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48503: LD_ADDR_EXP 118
48507: PUSH
48508: LD_EXP 118
48512: PPUSH
48513: LD_VAR 0 2
48517: PPUSH
48518: LD_EXP 118
48522: PUSH
48523: LD_VAR 0 2
48527: ARRAY
48528: PUSH
48529: LD_VAR 0 3
48533: DIFF
48534: PPUSH
48535: CALL_OW 1
48539: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48540: LD_VAR 0 3
48544: PPUSH
48545: LD_INT 0
48547: PPUSH
48548: CALL_OW 109
// continue ;
48552: GO 48449
// end ; if IsInUnit ( j ) then
48554: LD_VAR 0 3
48558: PPUSH
48559: CALL_OW 310
48563: IFFALSE 48574
// ComExitBuilding ( j ) ;
48565: LD_VAR 0 3
48569: PPUSH
48570: CALL_OW 122
// wait ( 3 ) ;
48574: LD_INT 3
48576: PPUSH
48577: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48581: LD_VAR 0 3
48585: PPUSH
48586: LD_VAR 0 6
48590: PUSH
48591: LD_INT 2
48593: ARRAY
48594: PPUSH
48595: LD_VAR 0 6
48599: PUSH
48600: LD_INT 3
48602: ARRAY
48603: PPUSH
48604: CALL_OW 117
// end ;
48608: GO 48449
48610: POP
48611: POP
// end ; end else
48612: GO 49193
// begin for j in cargo do
48614: LD_ADDR_VAR 0 3
48618: PUSH
48619: LD_VAR 0 7
48623: PUSH
48624: FOR_IN
48625: IFFALSE 49191
// begin if GetTag ( j ) <> 0 then
48627: LD_VAR 0 3
48631: PPUSH
48632: CALL_OW 110
48636: PUSH
48637: LD_INT 0
48639: NONEQUAL
48640: IFFALSE 48644
// continue ;
48642: GO 48624
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48644: LD_VAR 0 3
48648: PPUSH
48649: CALL_OW 256
48653: PUSH
48654: LD_INT 1000
48656: LESS
48657: PUSH
48658: LD_VAR 0 3
48662: PPUSH
48663: LD_EXP 125
48667: PUSH
48668: LD_VAR 0 2
48672: ARRAY
48673: PPUSH
48674: CALL_OW 308
48678: NOT
48679: AND
48680: IFFALSE 48702
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48682: LD_VAR 0 3
48686: PPUSH
48687: LD_EXP 125
48691: PUSH
48692: LD_VAR 0 2
48696: ARRAY
48697: PPUSH
48698: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48702: LD_VAR 0 3
48706: PPUSH
48707: CALL_OW 256
48711: PUSH
48712: LD_INT 1000
48714: LESS
48715: PUSH
48716: LD_VAR 0 3
48720: PPUSH
48721: LD_EXP 125
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: PPUSH
48732: CALL_OW 308
48736: AND
48737: IFFALSE 48741
// continue ;
48739: GO 48624
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48741: LD_VAR 0 3
48745: PPUSH
48746: CALL_OW 262
48750: PUSH
48751: LD_INT 2
48753: EQUAL
48754: PUSH
48755: LD_VAR 0 3
48759: PPUSH
48760: CALL_OW 261
48764: PUSH
48765: LD_INT 15
48767: LESS
48768: AND
48769: IFFALSE 48773
// continue ;
48771: GO 48624
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48773: LD_VAR 0 3
48777: PPUSH
48778: CALL_OW 262
48782: PUSH
48783: LD_INT 1
48785: EQUAL
48786: PUSH
48787: LD_VAR 0 3
48791: PPUSH
48792: CALL_OW 261
48796: PUSH
48797: LD_INT 10
48799: LESS
48800: AND
48801: IFFALSE 49130
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48803: LD_ADDR_VAR 0 8
48807: PUSH
48808: LD_EXP 101
48812: PUSH
48813: LD_VAR 0 2
48817: ARRAY
48818: PPUSH
48819: LD_INT 2
48821: PUSH
48822: LD_INT 30
48824: PUSH
48825: LD_INT 0
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PUSH
48832: LD_INT 30
48834: PUSH
48835: LD_INT 1
48837: PUSH
48838: EMPTY
48839: LIST
48840: LIST
48841: PUSH
48842: EMPTY
48843: LIST
48844: LIST
48845: LIST
48846: PPUSH
48847: CALL_OW 72
48851: ST_TO_ADDR
// if not depot then
48852: LD_VAR 0 8
48856: NOT
48857: IFFALSE 48861
// continue ;
48859: GO 48624
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48861: LD_VAR 0 3
48865: PPUSH
48866: LD_VAR 0 8
48870: PPUSH
48871: LD_VAR 0 3
48875: PPUSH
48876: CALL_OW 74
48880: PPUSH
48881: CALL_OW 296
48885: PUSH
48886: LD_INT 6
48888: LESS
48889: IFFALSE 48905
// SetFuel ( j , 100 ) else
48891: LD_VAR 0 3
48895: PPUSH
48896: LD_INT 100
48898: PPUSH
48899: CALL_OW 240
48903: GO 49130
// if GetFuel ( j ) = 0 then
48905: LD_VAR 0 3
48909: PPUSH
48910: CALL_OW 261
48914: PUSH
48915: LD_INT 0
48917: EQUAL
48918: IFFALSE 49130
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48920: LD_ADDR_EXP 120
48924: PUSH
48925: LD_EXP 120
48929: PPUSH
48930: LD_VAR 0 2
48934: PPUSH
48935: LD_EXP 120
48939: PUSH
48940: LD_VAR 0 2
48944: ARRAY
48945: PUSH
48946: LD_VAR 0 3
48950: DIFF
48951: PPUSH
48952: CALL_OW 1
48956: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48957: LD_VAR 0 3
48961: PPUSH
48962: CALL_OW 263
48966: PUSH
48967: LD_INT 1
48969: EQUAL
48970: IFFALSE 48986
// ComExitVehicle ( IsInUnit ( j ) ) ;
48972: LD_VAR 0 3
48976: PPUSH
48977: CALL_OW 310
48981: PPUSH
48982: CALL_OW 121
// if GetControl ( j ) = control_remote then
48986: LD_VAR 0 3
48990: PPUSH
48991: CALL_OW 263
48995: PUSH
48996: LD_INT 2
48998: EQUAL
48999: IFFALSE 49010
// ComUnlink ( j ) ;
49001: LD_VAR 0 3
49005: PPUSH
49006: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49010: LD_ADDR_VAR 0 9
49014: PUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: LD_INT 3
49022: PPUSH
49023: CALL 58483 0 2
49027: ST_TO_ADDR
// if fac then
49028: LD_VAR 0 9
49032: IFFALSE 49128
// begin for k in fac do
49034: LD_ADDR_VAR 0 4
49038: PUSH
49039: LD_VAR 0 9
49043: PUSH
49044: FOR_IN
49045: IFFALSE 49126
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49047: LD_ADDR_VAR 0 10
49051: PUSH
49052: LD_VAR 0 9
49056: PPUSH
49057: LD_VAR 0 3
49061: PPUSH
49062: CALL_OW 265
49066: PPUSH
49067: LD_VAR 0 3
49071: PPUSH
49072: CALL_OW 262
49076: PPUSH
49077: LD_VAR 0 3
49081: PPUSH
49082: CALL_OW 263
49086: PPUSH
49087: LD_VAR 0 3
49091: PPUSH
49092: CALL_OW 264
49096: PPUSH
49097: CALL 69141 0 5
49101: ST_TO_ADDR
// if components then
49102: LD_VAR 0 10
49106: IFFALSE 49124
// begin MC_InsertProduceList ( i , components ) ;
49108: LD_VAR 0 2
49112: PPUSH
49113: LD_VAR 0 10
49117: PPUSH
49118: CALL 58028 0 2
// break ;
49122: GO 49126
// end ; end ;
49124: GO 49044
49126: POP
49127: POP
// end ; continue ;
49128: GO 48624
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49130: LD_VAR 0 3
49134: PPUSH
49135: LD_INT 1
49137: PPUSH
49138: CALL_OW 289
49142: PUSH
49143: LD_INT 100
49145: LESS
49146: PUSH
49147: LD_VAR 0 3
49151: PPUSH
49152: CALL_OW 314
49156: NOT
49157: AND
49158: IFFALSE 49187
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49160: LD_VAR 0 3
49164: PPUSH
49165: LD_VAR 0 6
49169: PUSH
49170: LD_INT 2
49172: ARRAY
49173: PPUSH
49174: LD_VAR 0 6
49178: PUSH
49179: LD_INT 3
49181: ARRAY
49182: PPUSH
49183: CALL_OW 117
// break ;
49187: GO 49191
// end ;
49189: GO 48624
49191: POP
49192: POP
// end ; end ;
49193: GO 47462
49195: POP
49196: POP
// end ;
49197: LD_VAR 0 1
49201: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49202: LD_INT 0
49204: PPUSH
49205: PPUSH
49206: PPUSH
49207: PPUSH
// if not mc_bases then
49208: LD_EXP 101
49212: NOT
49213: IFFALSE 49217
// exit ;
49215: GO 49378
// for i = 1 to mc_bases do
49217: LD_ADDR_VAR 0 2
49221: PUSH
49222: DOUBLE
49223: LD_INT 1
49225: DEC
49226: ST_TO_ADDR
49227: LD_EXP 101
49231: PUSH
49232: FOR_TO
49233: IFFALSE 49376
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49235: LD_ADDR_VAR 0 4
49239: PUSH
49240: LD_EXP 120
49244: PUSH
49245: LD_VAR 0 2
49249: ARRAY
49250: PUSH
49251: LD_EXP 123
49255: PUSH
49256: LD_VAR 0 2
49260: ARRAY
49261: UNION
49262: PPUSH
49263: LD_INT 33
49265: PUSH
49266: LD_INT 2
49268: PUSH
49269: EMPTY
49270: LIST
49271: LIST
49272: PPUSH
49273: CALL_OW 72
49277: ST_TO_ADDR
// if tmp then
49278: LD_VAR 0 4
49282: IFFALSE 49374
// for j in tmp do
49284: LD_ADDR_VAR 0 3
49288: PUSH
49289: LD_VAR 0 4
49293: PUSH
49294: FOR_IN
49295: IFFALSE 49372
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49297: LD_VAR 0 3
49301: PPUSH
49302: CALL_OW 312
49306: NOT
49307: PUSH
49308: LD_VAR 0 3
49312: PPUSH
49313: CALL_OW 256
49317: PUSH
49318: LD_INT 250
49320: GREATEREQUAL
49321: AND
49322: IFFALSE 49335
// Connect ( j ) else
49324: LD_VAR 0 3
49328: PPUSH
49329: CALL 74542 0 1
49333: GO 49370
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49335: LD_VAR 0 3
49339: PPUSH
49340: CALL_OW 256
49344: PUSH
49345: LD_INT 250
49347: LESS
49348: PUSH
49349: LD_VAR 0 3
49353: PPUSH
49354: CALL_OW 312
49358: AND
49359: IFFALSE 49370
// ComUnlink ( j ) ;
49361: LD_VAR 0 3
49365: PPUSH
49366: CALL_OW 136
49370: GO 49294
49372: POP
49373: POP
// end ;
49374: GO 49232
49376: POP
49377: POP
// end ;
49378: LD_VAR 0 1
49382: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49383: LD_INT 0
49385: PPUSH
49386: PPUSH
49387: PPUSH
49388: PPUSH
49389: PPUSH
// if not mc_bases then
49390: LD_EXP 101
49394: NOT
49395: IFFALSE 49399
// exit ;
49397: GO 49844
// for i = 1 to mc_bases do
49399: LD_ADDR_VAR 0 2
49403: PUSH
49404: DOUBLE
49405: LD_INT 1
49407: DEC
49408: ST_TO_ADDR
49409: LD_EXP 101
49413: PUSH
49414: FOR_TO
49415: IFFALSE 49842
// begin if not mc_produce [ i ] then
49417: LD_EXP 122
49421: PUSH
49422: LD_VAR 0 2
49426: ARRAY
49427: NOT
49428: IFFALSE 49432
// continue ;
49430: GO 49414
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49432: LD_ADDR_VAR 0 5
49436: PUSH
49437: LD_EXP 101
49441: PUSH
49442: LD_VAR 0 2
49446: ARRAY
49447: PPUSH
49448: LD_INT 30
49450: PUSH
49451: LD_INT 3
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: PPUSH
49458: CALL_OW 72
49462: ST_TO_ADDR
// if not fac then
49463: LD_VAR 0 5
49467: NOT
49468: IFFALSE 49472
// continue ;
49470: GO 49414
// for j in fac do
49472: LD_ADDR_VAR 0 3
49476: PUSH
49477: LD_VAR 0 5
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49838
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49485: LD_VAR 0 3
49489: PPUSH
49490: CALL_OW 461
49494: PUSH
49495: LD_INT 2
49497: NONEQUAL
49498: PUSH
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_INT 15
49506: PPUSH
49507: CALL 74202 0 2
49511: PUSH
49512: LD_INT 4
49514: ARRAY
49515: OR
49516: IFFALSE 49520
// continue ;
49518: GO 49482
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49520: LD_VAR 0 3
49524: PPUSH
49525: LD_EXP 122
49529: PUSH
49530: LD_VAR 0 2
49534: ARRAY
49535: PUSH
49536: LD_INT 1
49538: ARRAY
49539: PUSH
49540: LD_INT 1
49542: ARRAY
49543: PPUSH
49544: LD_EXP 122
49548: PUSH
49549: LD_VAR 0 2
49553: ARRAY
49554: PUSH
49555: LD_INT 1
49557: ARRAY
49558: PUSH
49559: LD_INT 2
49561: ARRAY
49562: PPUSH
49563: LD_EXP 122
49567: PUSH
49568: LD_VAR 0 2
49572: ARRAY
49573: PUSH
49574: LD_INT 1
49576: ARRAY
49577: PUSH
49578: LD_INT 3
49580: ARRAY
49581: PPUSH
49582: LD_EXP 122
49586: PUSH
49587: LD_VAR 0 2
49591: ARRAY
49592: PUSH
49593: LD_INT 1
49595: ARRAY
49596: PUSH
49597: LD_INT 4
49599: ARRAY
49600: PPUSH
49601: CALL_OW 448
49605: PUSH
49606: LD_VAR 0 3
49610: PPUSH
49611: LD_EXP 122
49615: PUSH
49616: LD_VAR 0 2
49620: ARRAY
49621: PUSH
49622: LD_INT 1
49624: ARRAY
49625: PUSH
49626: LD_INT 1
49628: ARRAY
49629: PUSH
49630: LD_EXP 122
49634: PUSH
49635: LD_VAR 0 2
49639: ARRAY
49640: PUSH
49641: LD_INT 1
49643: ARRAY
49644: PUSH
49645: LD_INT 2
49647: ARRAY
49648: PUSH
49649: LD_EXP 122
49653: PUSH
49654: LD_VAR 0 2
49658: ARRAY
49659: PUSH
49660: LD_INT 1
49662: ARRAY
49663: PUSH
49664: LD_INT 3
49666: ARRAY
49667: PUSH
49668: LD_EXP 122
49672: PUSH
49673: LD_VAR 0 2
49677: ARRAY
49678: PUSH
49679: LD_INT 1
49681: ARRAY
49682: PUSH
49683: LD_INT 4
49685: ARRAY
49686: PUSH
49687: EMPTY
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: PPUSH
49693: CALL 77873 0 2
49697: AND
49698: IFFALSE 49836
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49700: LD_VAR 0 3
49704: PPUSH
49705: LD_EXP 122
49709: PUSH
49710: LD_VAR 0 2
49714: ARRAY
49715: PUSH
49716: LD_INT 1
49718: ARRAY
49719: PUSH
49720: LD_INT 1
49722: ARRAY
49723: PPUSH
49724: LD_EXP 122
49728: PUSH
49729: LD_VAR 0 2
49733: ARRAY
49734: PUSH
49735: LD_INT 1
49737: ARRAY
49738: PUSH
49739: LD_INT 2
49741: ARRAY
49742: PPUSH
49743: LD_EXP 122
49747: PUSH
49748: LD_VAR 0 2
49752: ARRAY
49753: PUSH
49754: LD_INT 1
49756: ARRAY
49757: PUSH
49758: LD_INT 3
49760: ARRAY
49761: PPUSH
49762: LD_EXP 122
49766: PUSH
49767: LD_VAR 0 2
49771: ARRAY
49772: PUSH
49773: LD_INT 1
49775: ARRAY
49776: PUSH
49777: LD_INT 4
49779: ARRAY
49780: PPUSH
49781: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49785: LD_ADDR_VAR 0 4
49789: PUSH
49790: LD_EXP 122
49794: PUSH
49795: LD_VAR 0 2
49799: ARRAY
49800: PPUSH
49801: LD_INT 1
49803: PPUSH
49804: CALL_OW 3
49808: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49809: LD_ADDR_EXP 122
49813: PUSH
49814: LD_EXP 122
49818: PPUSH
49819: LD_VAR 0 2
49823: PPUSH
49824: LD_VAR 0 4
49828: PPUSH
49829: CALL_OW 1
49833: ST_TO_ADDR
// break ;
49834: GO 49838
// end ; end ;
49836: GO 49482
49838: POP
49839: POP
// end ;
49840: GO 49414
49842: POP
49843: POP
// end ;
49844: LD_VAR 0 1
49848: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49849: LD_INT 0
49851: PPUSH
49852: PPUSH
49853: PPUSH
// if not mc_bases then
49854: LD_EXP 101
49858: NOT
49859: IFFALSE 49863
// exit ;
49861: GO 49952
// for i = 1 to mc_bases do
49863: LD_ADDR_VAR 0 2
49867: PUSH
49868: DOUBLE
49869: LD_INT 1
49871: DEC
49872: ST_TO_ADDR
49873: LD_EXP 101
49877: PUSH
49878: FOR_TO
49879: IFFALSE 49950
// begin if mc_attack [ i ] then
49881: LD_EXP 121
49885: PUSH
49886: LD_VAR 0 2
49890: ARRAY
49891: IFFALSE 49948
// begin tmp := mc_attack [ i ] [ 1 ] ;
49893: LD_ADDR_VAR 0 3
49897: PUSH
49898: LD_EXP 121
49902: PUSH
49903: LD_VAR 0 2
49907: ARRAY
49908: PUSH
49909: LD_INT 1
49911: ARRAY
49912: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49913: LD_ADDR_EXP 121
49917: PUSH
49918: LD_EXP 121
49922: PPUSH
49923: LD_VAR 0 2
49927: PPUSH
49928: EMPTY
49929: PPUSH
49930: CALL_OW 1
49934: ST_TO_ADDR
// Attack ( tmp ) ;
49935: LD_VAR 0 3
49939: PPUSH
49940: CALL 100086 0 1
// exit ;
49944: POP
49945: POP
49946: GO 49952
// end ; end ;
49948: GO 49878
49950: POP
49951: POP
// end ;
49952: LD_VAR 0 1
49956: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49957: LD_INT 0
49959: PPUSH
49960: PPUSH
49961: PPUSH
49962: PPUSH
49963: PPUSH
49964: PPUSH
49965: PPUSH
// if not mc_bases then
49966: LD_EXP 101
49970: NOT
49971: IFFALSE 49975
// exit ;
49973: GO 50557
// for i = 1 to mc_bases do
49975: LD_ADDR_VAR 0 2
49979: PUSH
49980: DOUBLE
49981: LD_INT 1
49983: DEC
49984: ST_TO_ADDR
49985: LD_EXP 101
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50555
// begin if not mc_bases [ i ] then
49993: LD_EXP 101
49997: PUSH
49998: LD_VAR 0 2
50002: ARRAY
50003: NOT
50004: IFFALSE 50008
// continue ;
50006: GO 49990
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50008: LD_ADDR_VAR 0 7
50012: PUSH
50013: LD_EXP 101
50017: PUSH
50018: LD_VAR 0 2
50022: ARRAY
50023: PUSH
50024: LD_INT 1
50026: ARRAY
50027: PPUSH
50028: CALL 68445 0 1
50032: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50033: LD_ADDR_EXP 124
50037: PUSH
50038: LD_EXP 124
50042: PPUSH
50043: LD_VAR 0 2
50047: PPUSH
50048: LD_EXP 101
50052: PUSH
50053: LD_VAR 0 2
50057: ARRAY
50058: PUSH
50059: LD_INT 1
50061: ARRAY
50062: PPUSH
50063: CALL_OW 255
50067: PPUSH
50068: LD_EXP 126
50072: PUSH
50073: LD_VAR 0 2
50077: ARRAY
50078: PPUSH
50079: CALL 65999 0 2
50083: PPUSH
50084: CALL_OW 1
50088: ST_TO_ADDR
// if not mc_scan [ i ] then
50089: LD_EXP 124
50093: PUSH
50094: LD_VAR 0 2
50098: ARRAY
50099: NOT
50100: IFFALSE 50255
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50102: LD_ADDR_VAR 0 4
50106: PUSH
50107: LD_EXP 101
50111: PUSH
50112: LD_VAR 0 2
50116: ARRAY
50117: PPUSH
50118: LD_INT 2
50120: PUSH
50121: LD_INT 25
50123: PUSH
50124: LD_INT 5
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: LD_INT 25
50133: PUSH
50134: LD_INT 8
50136: PUSH
50137: EMPTY
50138: LIST
50139: LIST
50140: PUSH
50141: LD_INT 25
50143: PUSH
50144: LD_INT 9
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: LIST
50155: LIST
50156: PPUSH
50157: CALL_OW 72
50161: ST_TO_ADDR
// if not tmp then
50162: LD_VAR 0 4
50166: NOT
50167: IFFALSE 50171
// continue ;
50169: GO 49990
// for j in tmp do
50171: LD_ADDR_VAR 0 3
50175: PUSH
50176: LD_VAR 0 4
50180: PUSH
50181: FOR_IN
50182: IFFALSE 50253
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50184: LD_VAR 0 3
50188: PPUSH
50189: CALL_OW 310
50193: PPUSH
50194: CALL_OW 266
50198: PUSH
50199: LD_INT 5
50201: EQUAL
50202: PUSH
50203: LD_VAR 0 3
50207: PPUSH
50208: CALL_OW 257
50212: PUSH
50213: LD_INT 1
50215: EQUAL
50216: AND
50217: PUSH
50218: LD_VAR 0 3
50222: PPUSH
50223: CALL_OW 459
50227: NOT
50228: AND
50229: PUSH
50230: LD_VAR 0 7
50234: AND
50235: IFFALSE 50251
// ComChangeProfession ( j , class ) ;
50237: LD_VAR 0 3
50241: PPUSH
50242: LD_VAR 0 7
50246: PPUSH
50247: CALL_OW 123
50251: GO 50181
50253: POP
50254: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50255: LD_EXP 124
50259: PUSH
50260: LD_VAR 0 2
50264: ARRAY
50265: PUSH
50266: LD_EXP 123
50270: PUSH
50271: LD_VAR 0 2
50275: ARRAY
50276: NOT
50277: AND
50278: PUSH
50279: LD_EXP 101
50283: PUSH
50284: LD_VAR 0 2
50288: ARRAY
50289: PPUSH
50290: LD_INT 30
50292: PUSH
50293: LD_INT 32
50295: PUSH
50296: EMPTY
50297: LIST
50298: LIST
50299: PPUSH
50300: CALL_OW 72
50304: NOT
50305: AND
50306: PUSH
50307: LD_EXP 101
50311: PUSH
50312: LD_VAR 0 2
50316: ARRAY
50317: PPUSH
50318: LD_INT 2
50320: PUSH
50321: LD_INT 30
50323: PUSH
50324: LD_INT 4
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 30
50333: PUSH
50334: LD_INT 5
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: LIST
50345: PPUSH
50346: CALL_OW 72
50350: NOT
50351: AND
50352: IFFALSE 50484
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50354: LD_ADDR_VAR 0 4
50358: PUSH
50359: LD_EXP 101
50363: PUSH
50364: LD_VAR 0 2
50368: ARRAY
50369: PPUSH
50370: LD_INT 2
50372: PUSH
50373: LD_INT 25
50375: PUSH
50376: LD_INT 1
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: LD_INT 25
50385: PUSH
50386: LD_INT 5
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 25
50395: PUSH
50396: LD_INT 8
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: LD_INT 25
50405: PUSH
50406: LD_INT 9
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: LIST
50419: PPUSH
50420: CALL_OW 72
50424: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50425: LD_ADDR_VAR 0 4
50429: PUSH
50430: LD_VAR 0 4
50434: PUSH
50435: LD_VAR 0 4
50439: PPUSH
50440: LD_INT 18
50442: PPUSH
50443: CALL 104869 0 2
50447: DIFF
50448: ST_TO_ADDR
// if tmp then
50449: LD_VAR 0 4
50453: IFFALSE 50484
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50455: LD_VAR 0 2
50459: PPUSH
50460: LD_VAR 0 4
50464: PPUSH
50465: LD_EXP 126
50469: PUSH
50470: LD_VAR 0 2
50474: ARRAY
50475: PPUSH
50476: CALL 66034 0 3
// exit ;
50480: POP
50481: POP
50482: GO 50557
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50484: LD_EXP 124
50488: PUSH
50489: LD_VAR 0 2
50493: ARRAY
50494: PUSH
50495: LD_EXP 123
50499: PUSH
50500: LD_VAR 0 2
50504: ARRAY
50505: AND
50506: IFFALSE 50553
// begin tmp := mc_defender [ i ] ;
50508: LD_ADDR_VAR 0 4
50512: PUSH
50513: LD_EXP 123
50517: PUSH
50518: LD_VAR 0 2
50522: ARRAY
50523: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50524: LD_VAR 0 2
50528: PPUSH
50529: LD_VAR 0 4
50533: PPUSH
50534: LD_EXP 124
50538: PUSH
50539: LD_VAR 0 2
50543: ARRAY
50544: PPUSH
50545: CALL 66595 0 3
// exit ;
50549: POP
50550: POP
50551: GO 50557
// end ; end ;
50553: GO 49990
50555: POP
50556: POP
// end ;
50557: LD_VAR 0 1
50561: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50562: LD_INT 0
50564: PPUSH
50565: PPUSH
50566: PPUSH
50567: PPUSH
50568: PPUSH
50569: PPUSH
50570: PPUSH
50571: PPUSH
50572: PPUSH
50573: PPUSH
50574: PPUSH
// if not mc_bases then
50575: LD_EXP 101
50579: NOT
50580: IFFALSE 50584
// exit ;
50582: GO 51671
// for i = 1 to mc_bases do
50584: LD_ADDR_VAR 0 2
50588: PUSH
50589: DOUBLE
50590: LD_INT 1
50592: DEC
50593: ST_TO_ADDR
50594: LD_EXP 101
50598: PUSH
50599: FOR_TO
50600: IFFALSE 51669
// begin tmp := mc_lab [ i ] ;
50602: LD_ADDR_VAR 0 6
50606: PUSH
50607: LD_EXP 134
50611: PUSH
50612: LD_VAR 0 2
50616: ARRAY
50617: ST_TO_ADDR
// if not tmp then
50618: LD_VAR 0 6
50622: NOT
50623: IFFALSE 50627
// continue ;
50625: GO 50599
// idle_lab := 0 ;
50627: LD_ADDR_VAR 0 11
50631: PUSH
50632: LD_INT 0
50634: ST_TO_ADDR
// for j in tmp do
50635: LD_ADDR_VAR 0 3
50639: PUSH
50640: LD_VAR 0 6
50644: PUSH
50645: FOR_IN
50646: IFFALSE 51665
// begin researching := false ;
50648: LD_ADDR_VAR 0 10
50652: PUSH
50653: LD_INT 0
50655: ST_TO_ADDR
// side := GetSide ( j ) ;
50656: LD_ADDR_VAR 0 4
50660: PUSH
50661: LD_VAR 0 3
50665: PPUSH
50666: CALL_OW 255
50670: ST_TO_ADDR
// if not mc_tech [ side ] then
50671: LD_EXP 128
50675: PUSH
50676: LD_VAR 0 4
50680: ARRAY
50681: NOT
50682: IFFALSE 50686
// continue ;
50684: GO 50645
// if BuildingStatus ( j ) = bs_idle then
50686: LD_VAR 0 3
50690: PPUSH
50691: CALL_OW 461
50695: PUSH
50696: LD_INT 2
50698: EQUAL
50699: IFFALSE 50887
// begin if idle_lab and UnitsInside ( j ) < 6 then
50701: LD_VAR 0 11
50705: PUSH
50706: LD_VAR 0 3
50710: PPUSH
50711: CALL_OW 313
50715: PUSH
50716: LD_INT 6
50718: LESS
50719: AND
50720: IFFALSE 50791
// begin tmp2 := UnitsInside ( idle_lab ) ;
50722: LD_ADDR_VAR 0 9
50726: PUSH
50727: LD_VAR 0 11
50731: PPUSH
50732: CALL_OW 313
50736: ST_TO_ADDR
// if tmp2 then
50737: LD_VAR 0 9
50741: IFFALSE 50783
// for x in tmp2 do
50743: LD_ADDR_VAR 0 7
50747: PUSH
50748: LD_VAR 0 9
50752: PUSH
50753: FOR_IN
50754: IFFALSE 50781
// begin ComExitBuilding ( x ) ;
50756: LD_VAR 0 7
50760: PPUSH
50761: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50765: LD_VAR 0 7
50769: PPUSH
50770: LD_VAR 0 3
50774: PPUSH
50775: CALL_OW 180
// end ;
50779: GO 50753
50781: POP
50782: POP
// idle_lab := 0 ;
50783: LD_ADDR_VAR 0 11
50787: PUSH
50788: LD_INT 0
50790: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50791: LD_ADDR_VAR 0 5
50795: PUSH
50796: LD_EXP 128
50800: PUSH
50801: LD_VAR 0 4
50805: ARRAY
50806: PUSH
50807: FOR_IN
50808: IFFALSE 50868
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50810: LD_VAR 0 3
50814: PPUSH
50815: LD_VAR 0 5
50819: PPUSH
50820: CALL_OW 430
50824: PUSH
50825: LD_VAR 0 4
50829: PPUSH
50830: LD_VAR 0 5
50834: PPUSH
50835: CALL 65104 0 2
50839: AND
50840: IFFALSE 50866
// begin researching := true ;
50842: LD_ADDR_VAR 0 10
50846: PUSH
50847: LD_INT 1
50849: ST_TO_ADDR
// ComResearch ( j , t ) ;
50850: LD_VAR 0 3
50854: PPUSH
50855: LD_VAR 0 5
50859: PPUSH
50860: CALL_OW 124
// break ;
50864: GO 50868
// end ;
50866: GO 50807
50868: POP
50869: POP
// if not researching then
50870: LD_VAR 0 10
50874: NOT
50875: IFFALSE 50887
// idle_lab := j ;
50877: LD_ADDR_VAR 0 11
50881: PUSH
50882: LD_VAR 0 3
50886: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50887: LD_VAR 0 3
50891: PPUSH
50892: CALL_OW 461
50896: PUSH
50897: LD_INT 10
50899: EQUAL
50900: IFFALSE 51488
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50902: LD_EXP 130
50906: PUSH
50907: LD_VAR 0 2
50911: ARRAY
50912: NOT
50913: PUSH
50914: LD_EXP 131
50918: PUSH
50919: LD_VAR 0 2
50923: ARRAY
50924: NOT
50925: AND
50926: PUSH
50927: LD_EXP 128
50931: PUSH
50932: LD_VAR 0 4
50936: ARRAY
50937: PUSH
50938: LD_INT 1
50940: GREATER
50941: AND
50942: IFFALSE 51073
// begin ComCancel ( j ) ;
50944: LD_VAR 0 3
50948: PPUSH
50949: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50953: LD_ADDR_EXP 128
50957: PUSH
50958: LD_EXP 128
50962: PPUSH
50963: LD_VAR 0 4
50967: PPUSH
50968: LD_EXP 128
50972: PUSH
50973: LD_VAR 0 4
50977: ARRAY
50978: PPUSH
50979: LD_EXP 128
50983: PUSH
50984: LD_VAR 0 4
50988: ARRAY
50989: PUSH
50990: LD_INT 1
50992: MINUS
50993: PPUSH
50994: LD_EXP 128
50998: PUSH
50999: LD_VAR 0 4
51003: ARRAY
51004: PPUSH
51005: LD_INT 0
51007: PPUSH
51008: CALL 71027 0 4
51012: PPUSH
51013: CALL_OW 1
51017: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51018: LD_ADDR_EXP 128
51022: PUSH
51023: LD_EXP 128
51027: PPUSH
51028: LD_VAR 0 4
51032: PPUSH
51033: LD_EXP 128
51037: PUSH
51038: LD_VAR 0 4
51042: ARRAY
51043: PPUSH
51044: LD_EXP 128
51048: PUSH
51049: LD_VAR 0 4
51053: ARRAY
51054: PPUSH
51055: LD_INT 1
51057: PPUSH
51058: LD_INT 0
51060: PPUSH
51061: CALL 71027 0 4
51065: PPUSH
51066: CALL_OW 1
51070: ST_TO_ADDR
// continue ;
51071: GO 50645
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51073: LD_EXP 130
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PUSH
51084: LD_EXP 131
51088: PUSH
51089: LD_VAR 0 2
51093: ARRAY
51094: NOT
51095: AND
51096: IFFALSE 51223
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51098: LD_ADDR_EXP 131
51102: PUSH
51103: LD_EXP 131
51107: PPUSH
51108: LD_VAR 0 2
51112: PUSH
51113: LD_EXP 131
51117: PUSH
51118: LD_VAR 0 2
51122: ARRAY
51123: PUSH
51124: LD_INT 1
51126: PLUS
51127: PUSH
51128: EMPTY
51129: LIST
51130: LIST
51131: PPUSH
51132: LD_EXP 130
51136: PUSH
51137: LD_VAR 0 2
51141: ARRAY
51142: PUSH
51143: LD_INT 1
51145: ARRAY
51146: PPUSH
51147: CALL 71609 0 3
51151: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51152: LD_EXP 130
51156: PUSH
51157: LD_VAR 0 2
51161: ARRAY
51162: PUSH
51163: LD_INT 1
51165: ARRAY
51166: PPUSH
51167: LD_INT 112
51169: PPUSH
51170: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51174: LD_ADDR_VAR 0 9
51178: PUSH
51179: LD_EXP 130
51183: PUSH
51184: LD_VAR 0 2
51188: ARRAY
51189: PPUSH
51190: LD_INT 1
51192: PPUSH
51193: CALL_OW 3
51197: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51198: LD_ADDR_EXP 130
51202: PUSH
51203: LD_EXP 130
51207: PPUSH
51208: LD_VAR 0 2
51212: PPUSH
51213: LD_VAR 0 9
51217: PPUSH
51218: CALL_OW 1
51222: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51223: LD_EXP 130
51227: PUSH
51228: LD_VAR 0 2
51232: ARRAY
51233: PUSH
51234: LD_EXP 131
51238: PUSH
51239: LD_VAR 0 2
51243: ARRAY
51244: AND
51245: PUSH
51246: LD_EXP 131
51250: PUSH
51251: LD_VAR 0 2
51255: ARRAY
51256: PUSH
51257: LD_INT 1
51259: ARRAY
51260: PPUSH
51261: CALL_OW 310
51265: NOT
51266: AND
51267: PUSH
51268: LD_VAR 0 3
51272: PPUSH
51273: CALL_OW 313
51277: PUSH
51278: LD_INT 6
51280: EQUAL
51281: AND
51282: IFFALSE 51338
// begin tmp2 := UnitsInside ( j ) ;
51284: LD_ADDR_VAR 0 9
51288: PUSH
51289: LD_VAR 0 3
51293: PPUSH
51294: CALL_OW 313
51298: ST_TO_ADDR
// if tmp2 = 6 then
51299: LD_VAR 0 9
51303: PUSH
51304: LD_INT 6
51306: EQUAL
51307: IFFALSE 51338
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51309: LD_VAR 0 9
51313: PUSH
51314: LD_INT 1
51316: ARRAY
51317: PPUSH
51318: LD_INT 112
51320: PPUSH
51321: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51325: LD_VAR 0 9
51329: PUSH
51330: LD_INT 1
51332: ARRAY
51333: PPUSH
51334: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51338: LD_EXP 131
51342: PUSH
51343: LD_VAR 0 2
51347: ARRAY
51348: PUSH
51349: LD_EXP 131
51353: PUSH
51354: LD_VAR 0 2
51358: ARRAY
51359: PUSH
51360: LD_INT 1
51362: ARRAY
51363: PPUSH
51364: CALL_OW 314
51368: NOT
51369: AND
51370: PUSH
51371: LD_EXP 131
51375: PUSH
51376: LD_VAR 0 2
51380: ARRAY
51381: PUSH
51382: LD_INT 1
51384: ARRAY
51385: PPUSH
51386: CALL_OW 310
51390: NOT
51391: AND
51392: IFFALSE 51418
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51394: LD_EXP 131
51398: PUSH
51399: LD_VAR 0 2
51403: ARRAY
51404: PUSH
51405: LD_INT 1
51407: ARRAY
51408: PPUSH
51409: LD_VAR 0 3
51413: PPUSH
51414: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51418: LD_EXP 131
51422: PUSH
51423: LD_VAR 0 2
51427: ARRAY
51428: PUSH
51429: LD_INT 1
51431: ARRAY
51432: PPUSH
51433: CALL_OW 310
51437: PUSH
51438: LD_EXP 131
51442: PUSH
51443: LD_VAR 0 2
51447: ARRAY
51448: PUSH
51449: LD_INT 1
51451: ARRAY
51452: PPUSH
51453: CALL_OW 310
51457: PPUSH
51458: CALL_OW 461
51462: PUSH
51463: LD_INT 3
51465: NONEQUAL
51466: AND
51467: IFFALSE 51488
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51469: LD_EXP 131
51473: PUSH
51474: LD_VAR 0 2
51478: ARRAY
51479: PUSH
51480: LD_INT 1
51482: ARRAY
51483: PPUSH
51484: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51488: LD_VAR 0 3
51492: PPUSH
51493: CALL_OW 461
51497: PUSH
51498: LD_INT 6
51500: EQUAL
51501: PUSH
51502: LD_VAR 0 6
51506: PUSH
51507: LD_INT 1
51509: GREATER
51510: AND
51511: IFFALSE 51663
// begin sci := [ ] ;
51513: LD_ADDR_VAR 0 8
51517: PUSH
51518: EMPTY
51519: ST_TO_ADDR
// for x in ( tmp diff j ) do
51520: LD_ADDR_VAR 0 7
51524: PUSH
51525: LD_VAR 0 6
51529: PUSH
51530: LD_VAR 0 3
51534: DIFF
51535: PUSH
51536: FOR_IN
51537: IFFALSE 51589
// begin if sci = 6 then
51539: LD_VAR 0 8
51543: PUSH
51544: LD_INT 6
51546: EQUAL
51547: IFFALSE 51551
// break ;
51549: GO 51589
// if BuildingStatus ( x ) = bs_idle then
51551: LD_VAR 0 7
51555: PPUSH
51556: CALL_OW 461
51560: PUSH
51561: LD_INT 2
51563: EQUAL
51564: IFFALSE 51587
// sci := sci ^ UnitsInside ( x ) ;
51566: LD_ADDR_VAR 0 8
51570: PUSH
51571: LD_VAR 0 8
51575: PUSH
51576: LD_VAR 0 7
51580: PPUSH
51581: CALL_OW 313
51585: ADD
51586: ST_TO_ADDR
// end ;
51587: GO 51536
51589: POP
51590: POP
// if not sci then
51591: LD_VAR 0 8
51595: NOT
51596: IFFALSE 51600
// continue ;
51598: GO 50645
// for x in sci do
51600: LD_ADDR_VAR 0 7
51604: PUSH
51605: LD_VAR 0 8
51609: PUSH
51610: FOR_IN
51611: IFFALSE 51661
// if IsInUnit ( x ) and not HasTask ( x ) then
51613: LD_VAR 0 7
51617: PPUSH
51618: CALL_OW 310
51622: PUSH
51623: LD_VAR 0 7
51627: PPUSH
51628: CALL_OW 314
51632: NOT
51633: AND
51634: IFFALSE 51659
// begin ComExitBuilding ( x ) ;
51636: LD_VAR 0 7
51640: PPUSH
51641: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51645: LD_VAR 0 7
51649: PPUSH
51650: LD_VAR 0 3
51654: PPUSH
51655: CALL_OW 180
// end ;
51659: GO 51610
51661: POP
51662: POP
// end ; end ;
51663: GO 50645
51665: POP
51666: POP
// end ;
51667: GO 50599
51669: POP
51670: POP
// end ;
51671: LD_VAR 0 1
51675: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51676: LD_INT 0
51678: PPUSH
51679: PPUSH
// if not mc_bases then
51680: LD_EXP 101
51684: NOT
51685: IFFALSE 51689
// exit ;
51687: GO 51770
// for i = 1 to mc_bases do
51689: LD_ADDR_VAR 0 2
51693: PUSH
51694: DOUBLE
51695: LD_INT 1
51697: DEC
51698: ST_TO_ADDR
51699: LD_EXP 101
51703: PUSH
51704: FOR_TO
51705: IFFALSE 51768
// if mc_mines [ i ] and mc_miners [ i ] then
51707: LD_EXP 114
51711: PUSH
51712: LD_VAR 0 2
51716: ARRAY
51717: PUSH
51718: LD_EXP 115
51722: PUSH
51723: LD_VAR 0 2
51727: ARRAY
51728: AND
51729: IFFALSE 51766
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51731: LD_EXP 115
51735: PUSH
51736: LD_VAR 0 2
51740: ARRAY
51741: PUSH
51742: LD_INT 1
51744: ARRAY
51745: PPUSH
51746: CALL_OW 255
51750: PPUSH
51751: LD_EXP 114
51755: PUSH
51756: LD_VAR 0 2
51760: ARRAY
51761: PPUSH
51762: CALL 68598 0 2
51766: GO 51704
51768: POP
51769: POP
// end ;
51770: LD_VAR 0 1
51774: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51775: LD_INT 0
51777: PPUSH
51778: PPUSH
51779: PPUSH
51780: PPUSH
51781: PPUSH
51782: PPUSH
51783: PPUSH
51784: PPUSH
// if not mc_bases or not mc_parking then
51785: LD_EXP 101
51789: NOT
51790: PUSH
51791: LD_EXP 125
51795: NOT
51796: OR
51797: IFFALSE 51801
// exit ;
51799: GO 52500
// for i = 1 to mc_bases do
51801: LD_ADDR_VAR 0 2
51805: PUSH
51806: DOUBLE
51807: LD_INT 1
51809: DEC
51810: ST_TO_ADDR
51811: LD_EXP 101
51815: PUSH
51816: FOR_TO
51817: IFFALSE 52498
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51819: LD_EXP 101
51823: PUSH
51824: LD_VAR 0 2
51828: ARRAY
51829: NOT
51830: PUSH
51831: LD_EXP 125
51835: PUSH
51836: LD_VAR 0 2
51840: ARRAY
51841: NOT
51842: OR
51843: IFFALSE 51847
// continue ;
51845: GO 51816
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51847: LD_ADDR_VAR 0 5
51851: PUSH
51852: LD_EXP 101
51856: PUSH
51857: LD_VAR 0 2
51861: ARRAY
51862: PUSH
51863: LD_INT 1
51865: ARRAY
51866: PPUSH
51867: CALL_OW 255
51871: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51872: LD_ADDR_VAR 0 6
51876: PUSH
51877: LD_EXP 101
51881: PUSH
51882: LD_VAR 0 2
51886: ARRAY
51887: PPUSH
51888: LD_INT 30
51890: PUSH
51891: LD_INT 3
51893: PUSH
51894: EMPTY
51895: LIST
51896: LIST
51897: PPUSH
51898: CALL_OW 72
51902: ST_TO_ADDR
// if not fac then
51903: LD_VAR 0 6
51907: NOT
51908: IFFALSE 51959
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51910: LD_ADDR_VAR 0 6
51914: PUSH
51915: LD_EXP 101
51919: PUSH
51920: LD_VAR 0 2
51924: ARRAY
51925: PPUSH
51926: LD_INT 2
51928: PUSH
51929: LD_INT 30
51931: PUSH
51932: LD_INT 0
51934: PUSH
51935: EMPTY
51936: LIST
51937: LIST
51938: PUSH
51939: LD_INT 30
51941: PUSH
51942: LD_INT 1
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: PUSH
51949: EMPTY
51950: LIST
51951: LIST
51952: LIST
51953: PPUSH
51954: CALL_OW 72
51958: ST_TO_ADDR
// if not fac then
51959: LD_VAR 0 6
51963: NOT
51964: IFFALSE 51968
// continue ;
51966: GO 51816
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51968: LD_ADDR_VAR 0 7
51972: PUSH
51973: LD_EXP 125
51977: PUSH
51978: LD_VAR 0 2
51982: ARRAY
51983: PPUSH
51984: LD_INT 22
51986: PUSH
51987: LD_VAR 0 5
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: PUSH
51996: LD_INT 21
51998: PUSH
51999: LD_INT 2
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: PUSH
52006: LD_INT 3
52008: PUSH
52009: LD_INT 24
52011: PUSH
52012: LD_INT 1000
52014: PUSH
52015: EMPTY
52016: LIST
52017: LIST
52018: PUSH
52019: EMPTY
52020: LIST
52021: LIST
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: LIST
52027: PPUSH
52028: CALL_OW 70
52032: ST_TO_ADDR
// for j in fac do
52033: LD_ADDR_VAR 0 3
52037: PUSH
52038: LD_VAR 0 6
52042: PUSH
52043: FOR_IN
52044: IFFALSE 52125
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52046: LD_ADDR_VAR 0 7
52050: PUSH
52051: LD_VAR 0 7
52055: PUSH
52056: LD_INT 22
52058: PUSH
52059: LD_VAR 0 5
52063: PUSH
52064: EMPTY
52065: LIST
52066: LIST
52067: PUSH
52068: LD_INT 91
52070: PUSH
52071: LD_VAR 0 3
52075: PUSH
52076: LD_INT 15
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: LIST
52083: PUSH
52084: LD_INT 21
52086: PUSH
52087: LD_INT 2
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: PUSH
52094: LD_INT 3
52096: PUSH
52097: LD_INT 24
52099: PUSH
52100: LD_INT 1000
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PUSH
52107: EMPTY
52108: LIST
52109: LIST
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: LIST
52115: LIST
52116: PPUSH
52117: CALL_OW 69
52121: UNION
52122: ST_TO_ADDR
52123: GO 52043
52125: POP
52126: POP
// if not vehs then
52127: LD_VAR 0 7
52131: NOT
52132: IFFALSE 52158
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52134: LD_ADDR_EXP 113
52138: PUSH
52139: LD_EXP 113
52143: PPUSH
52144: LD_VAR 0 2
52148: PPUSH
52149: EMPTY
52150: PPUSH
52151: CALL_OW 1
52155: ST_TO_ADDR
// continue ;
52156: GO 51816
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52158: LD_ADDR_VAR 0 8
52162: PUSH
52163: LD_EXP 101
52167: PUSH
52168: LD_VAR 0 2
52172: ARRAY
52173: PPUSH
52174: LD_INT 30
52176: PUSH
52177: LD_INT 3
52179: PUSH
52180: EMPTY
52181: LIST
52182: LIST
52183: PPUSH
52184: CALL_OW 72
52188: ST_TO_ADDR
// if tmp then
52189: LD_VAR 0 8
52193: IFFALSE 52296
// begin for j in tmp do
52195: LD_ADDR_VAR 0 3
52199: PUSH
52200: LD_VAR 0 8
52204: PUSH
52205: FOR_IN
52206: IFFALSE 52294
// for k in UnitsInside ( j ) do
52208: LD_ADDR_VAR 0 4
52212: PUSH
52213: LD_VAR 0 3
52217: PPUSH
52218: CALL_OW 313
52222: PUSH
52223: FOR_IN
52224: IFFALSE 52290
// if k then
52226: LD_VAR 0 4
52230: IFFALSE 52288
// if not k in mc_repair_vehicle [ i ] then
52232: LD_VAR 0 4
52236: PUSH
52237: LD_EXP 113
52241: PUSH
52242: LD_VAR 0 2
52246: ARRAY
52247: IN
52248: NOT
52249: IFFALSE 52288
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52251: LD_ADDR_EXP 113
52255: PUSH
52256: LD_EXP 113
52260: PPUSH
52261: LD_VAR 0 2
52265: PPUSH
52266: LD_EXP 113
52270: PUSH
52271: LD_VAR 0 2
52275: ARRAY
52276: PUSH
52277: LD_VAR 0 4
52281: UNION
52282: PPUSH
52283: CALL_OW 1
52287: ST_TO_ADDR
52288: GO 52223
52290: POP
52291: POP
52292: GO 52205
52294: POP
52295: POP
// end ; if not mc_repair_vehicle [ i ] then
52296: LD_EXP 113
52300: PUSH
52301: LD_VAR 0 2
52305: ARRAY
52306: NOT
52307: IFFALSE 52311
// continue ;
52309: GO 51816
// for j in mc_repair_vehicle [ i ] do
52311: LD_ADDR_VAR 0 3
52315: PUSH
52316: LD_EXP 113
52320: PUSH
52321: LD_VAR 0 2
52325: ARRAY
52326: PUSH
52327: FOR_IN
52328: IFFALSE 52494
// begin if GetClass ( j ) <> 3 then
52330: LD_VAR 0 3
52334: PPUSH
52335: CALL_OW 257
52339: PUSH
52340: LD_INT 3
52342: NONEQUAL
52343: IFFALSE 52384
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52345: LD_ADDR_EXP 113
52349: PUSH
52350: LD_EXP 113
52354: PPUSH
52355: LD_VAR 0 2
52359: PPUSH
52360: LD_EXP 113
52364: PUSH
52365: LD_VAR 0 2
52369: ARRAY
52370: PUSH
52371: LD_VAR 0 3
52375: DIFF
52376: PPUSH
52377: CALL_OW 1
52381: ST_TO_ADDR
// continue ;
52382: GO 52327
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52384: LD_VAR 0 3
52388: PPUSH
52389: CALL_OW 311
52393: NOT
52394: PUSH
52395: LD_VAR 0 3
52399: PUSH
52400: LD_EXP 104
52404: PUSH
52405: LD_VAR 0 2
52409: ARRAY
52410: PUSH
52411: LD_INT 1
52413: ARRAY
52414: IN
52415: NOT
52416: AND
52417: PUSH
52418: LD_VAR 0 3
52422: PUSH
52423: LD_EXP 104
52427: PUSH
52428: LD_VAR 0 2
52432: ARRAY
52433: PUSH
52434: LD_INT 2
52436: ARRAY
52437: IN
52438: NOT
52439: AND
52440: IFFALSE 52492
// begin if IsInUnit ( j ) then
52442: LD_VAR 0 3
52446: PPUSH
52447: CALL_OW 310
52451: IFFALSE 52462
// ComExitBuilding ( j ) ;
52453: LD_VAR 0 3
52457: PPUSH
52458: CALL_OW 122
// if not HasTask ( j ) then
52462: LD_VAR 0 3
52466: PPUSH
52467: CALL_OW 314
52471: NOT
52472: IFFALSE 52492
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52474: LD_VAR 0 3
52478: PPUSH
52479: LD_VAR 0 7
52483: PUSH
52484: LD_INT 1
52486: ARRAY
52487: PPUSH
52488: CALL_OW 189
// end ; end ;
52492: GO 52327
52494: POP
52495: POP
// end ;
52496: GO 51816
52498: POP
52499: POP
// end ;
52500: LD_VAR 0 1
52504: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52505: LD_INT 0
52507: PPUSH
52508: PPUSH
52509: PPUSH
52510: PPUSH
52511: PPUSH
52512: PPUSH
52513: PPUSH
52514: PPUSH
52515: PPUSH
52516: PPUSH
52517: PPUSH
// if not mc_bases then
52518: LD_EXP 101
52522: NOT
52523: IFFALSE 52527
// exit ;
52525: GO 53329
// for i = 1 to mc_bases do
52527: LD_ADDR_VAR 0 2
52531: PUSH
52532: DOUBLE
52533: LD_INT 1
52535: DEC
52536: ST_TO_ADDR
52537: LD_EXP 101
52541: PUSH
52542: FOR_TO
52543: IFFALSE 53327
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52545: LD_EXP 129
52549: PUSH
52550: LD_VAR 0 2
52554: ARRAY
52555: NOT
52556: PUSH
52557: LD_EXP 104
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: PUSH
52568: LD_INT 1
52570: ARRAY
52571: OR
52572: PUSH
52573: LD_EXP 104
52577: PUSH
52578: LD_VAR 0 2
52582: ARRAY
52583: PUSH
52584: LD_INT 2
52586: ARRAY
52587: OR
52588: PUSH
52589: LD_EXP 127
52593: PUSH
52594: LD_VAR 0 2
52598: ARRAY
52599: PPUSH
52600: LD_INT 1
52602: PPUSH
52603: CALL_OW 325
52607: NOT
52608: OR
52609: PUSH
52610: LD_EXP 124
52614: PUSH
52615: LD_VAR 0 2
52619: ARRAY
52620: OR
52621: IFFALSE 52625
// continue ;
52623: GO 52542
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52625: LD_ADDR_VAR 0 8
52629: PUSH
52630: LD_EXP 101
52634: PUSH
52635: LD_VAR 0 2
52639: ARRAY
52640: PPUSH
52641: LD_INT 25
52643: PUSH
52644: LD_INT 4
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: PUSH
52651: LD_INT 50
52653: PUSH
52654: EMPTY
52655: LIST
52656: PUSH
52657: LD_INT 3
52659: PUSH
52660: LD_INT 60
52662: PUSH
52663: EMPTY
52664: LIST
52665: PUSH
52666: EMPTY
52667: LIST
52668: LIST
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: LIST
52674: PPUSH
52675: CALL_OW 72
52679: PUSH
52680: LD_EXP 105
52684: PUSH
52685: LD_VAR 0 2
52689: ARRAY
52690: DIFF
52691: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52692: LD_ADDR_VAR 0 9
52696: PUSH
52697: LD_EXP 101
52701: PUSH
52702: LD_VAR 0 2
52706: ARRAY
52707: PPUSH
52708: LD_INT 2
52710: PUSH
52711: LD_INT 30
52713: PUSH
52714: LD_INT 0
52716: PUSH
52717: EMPTY
52718: LIST
52719: LIST
52720: PUSH
52721: LD_INT 30
52723: PUSH
52724: LD_INT 1
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PUSH
52731: EMPTY
52732: LIST
52733: LIST
52734: LIST
52735: PPUSH
52736: CALL_OW 72
52740: ST_TO_ADDR
// if not tmp or not dep then
52741: LD_VAR 0 8
52745: NOT
52746: PUSH
52747: LD_VAR 0 9
52751: NOT
52752: OR
52753: IFFALSE 52757
// continue ;
52755: GO 52542
// side := GetSide ( tmp [ 1 ] ) ;
52757: LD_ADDR_VAR 0 11
52761: PUSH
52762: LD_VAR 0 8
52766: PUSH
52767: LD_INT 1
52769: ARRAY
52770: PPUSH
52771: CALL_OW 255
52775: ST_TO_ADDR
// dep := dep [ 1 ] ;
52776: LD_ADDR_VAR 0 9
52780: PUSH
52781: LD_VAR 0 9
52785: PUSH
52786: LD_INT 1
52788: ARRAY
52789: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52790: LD_ADDR_VAR 0 7
52794: PUSH
52795: LD_EXP 129
52799: PUSH
52800: LD_VAR 0 2
52804: ARRAY
52805: PPUSH
52806: LD_INT 22
52808: PUSH
52809: LD_INT 0
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: PUSH
52816: LD_INT 25
52818: PUSH
52819: LD_INT 12
52821: PUSH
52822: EMPTY
52823: LIST
52824: LIST
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: PPUSH
52830: CALL_OW 70
52834: PUSH
52835: LD_INT 22
52837: PUSH
52838: LD_INT 0
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: PUSH
52845: LD_INT 25
52847: PUSH
52848: LD_INT 12
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: PUSH
52855: LD_INT 91
52857: PUSH
52858: LD_VAR 0 9
52862: PUSH
52863: LD_INT 20
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: LIST
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: LIST
52875: PPUSH
52876: CALL_OW 69
52880: UNION
52881: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52882: LD_ADDR_VAR 0 10
52886: PUSH
52887: LD_EXP 129
52891: PUSH
52892: LD_VAR 0 2
52896: ARRAY
52897: PPUSH
52898: LD_INT 81
52900: PUSH
52901: LD_VAR 0 11
52905: PUSH
52906: EMPTY
52907: LIST
52908: LIST
52909: PPUSH
52910: CALL_OW 70
52914: ST_TO_ADDR
// if not apes or danger_at_area then
52915: LD_VAR 0 7
52919: NOT
52920: PUSH
52921: LD_VAR 0 10
52925: OR
52926: IFFALSE 52976
// begin if mc_taming [ i ] then
52928: LD_EXP 132
52932: PUSH
52933: LD_VAR 0 2
52937: ARRAY
52938: IFFALSE 52974
// begin MC_Reset ( i , 121 ) ;
52940: LD_VAR 0 2
52944: PPUSH
52945: LD_INT 121
52947: PPUSH
52948: CALL 38307 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52952: LD_ADDR_EXP 132
52956: PUSH
52957: LD_EXP 132
52961: PPUSH
52962: LD_VAR 0 2
52966: PPUSH
52967: EMPTY
52968: PPUSH
52969: CALL_OW 1
52973: ST_TO_ADDR
// end ; continue ;
52974: GO 52542
// end ; for j in tmp do
52976: LD_ADDR_VAR 0 3
52980: PUSH
52981: LD_VAR 0 8
52985: PUSH
52986: FOR_IN
52987: IFFALSE 53323
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52989: LD_VAR 0 3
52993: PUSH
52994: LD_EXP 132
52998: PUSH
52999: LD_VAR 0 2
53003: ARRAY
53004: IN
53005: NOT
53006: PUSH
53007: LD_EXP 132
53011: PUSH
53012: LD_VAR 0 2
53016: ARRAY
53017: PUSH
53018: LD_INT 3
53020: LESS
53021: AND
53022: IFFALSE 53080
// begin SetTag ( j , 121 ) ;
53024: LD_VAR 0 3
53028: PPUSH
53029: LD_INT 121
53031: PPUSH
53032: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53036: LD_ADDR_EXP 132
53040: PUSH
53041: LD_EXP 132
53045: PPUSH
53046: LD_VAR 0 2
53050: PUSH
53051: LD_EXP 132
53055: PUSH
53056: LD_VAR 0 2
53060: ARRAY
53061: PUSH
53062: LD_INT 1
53064: PLUS
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: PPUSH
53070: LD_VAR 0 3
53074: PPUSH
53075: CALL 71609 0 3
53079: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53080: LD_VAR 0 3
53084: PUSH
53085: LD_EXP 132
53089: PUSH
53090: LD_VAR 0 2
53094: ARRAY
53095: IN
53096: IFFALSE 53321
// begin if GetClass ( j ) <> 4 then
53098: LD_VAR 0 3
53102: PPUSH
53103: CALL_OW 257
53107: PUSH
53108: LD_INT 4
53110: NONEQUAL
53111: IFFALSE 53164
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53113: LD_ADDR_EXP 132
53117: PUSH
53118: LD_EXP 132
53122: PPUSH
53123: LD_VAR 0 2
53127: PPUSH
53128: LD_EXP 132
53132: PUSH
53133: LD_VAR 0 2
53137: ARRAY
53138: PUSH
53139: LD_VAR 0 3
53143: DIFF
53144: PPUSH
53145: CALL_OW 1
53149: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53150: LD_VAR 0 3
53154: PPUSH
53155: LD_INT 0
53157: PPUSH
53158: CALL_OW 109
// continue ;
53162: GO 52986
// end ; if IsInUnit ( j ) then
53164: LD_VAR 0 3
53168: PPUSH
53169: CALL_OW 310
53173: IFFALSE 53184
// ComExitBuilding ( j ) ;
53175: LD_VAR 0 3
53179: PPUSH
53180: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53184: LD_ADDR_VAR 0 6
53188: PUSH
53189: LD_VAR 0 7
53193: PPUSH
53194: LD_VAR 0 3
53198: PPUSH
53199: CALL_OW 74
53203: ST_TO_ADDR
// if not ape then
53204: LD_VAR 0 6
53208: NOT
53209: IFFALSE 53213
// break ;
53211: GO 53323
// x := GetX ( ape ) ;
53213: LD_ADDR_VAR 0 4
53217: PUSH
53218: LD_VAR 0 6
53222: PPUSH
53223: CALL_OW 250
53227: ST_TO_ADDR
// y := GetY ( ape ) ;
53228: LD_ADDR_VAR 0 5
53232: PUSH
53233: LD_VAR 0 6
53237: PPUSH
53238: CALL_OW 251
53242: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53243: LD_VAR 0 4
53247: PPUSH
53248: LD_VAR 0 5
53252: PPUSH
53253: CALL_OW 488
53257: NOT
53258: PUSH
53259: LD_VAR 0 11
53263: PPUSH
53264: LD_VAR 0 4
53268: PPUSH
53269: LD_VAR 0 5
53273: PPUSH
53274: LD_INT 20
53276: PPUSH
53277: CALL 72505 0 4
53281: PUSH
53282: LD_INT 4
53284: ARRAY
53285: OR
53286: IFFALSE 53290
// break ;
53288: GO 53323
// if not HasTask ( j ) then
53290: LD_VAR 0 3
53294: PPUSH
53295: CALL_OW 314
53299: NOT
53300: IFFALSE 53321
// ComTameXY ( j , x , y ) ;
53302: LD_VAR 0 3
53306: PPUSH
53307: LD_VAR 0 4
53311: PPUSH
53312: LD_VAR 0 5
53316: PPUSH
53317: CALL_OW 131
// end ; end ;
53321: GO 52986
53323: POP
53324: POP
// end ;
53325: GO 52542
53327: POP
53328: POP
// end ;
53329: LD_VAR 0 1
53333: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53334: LD_INT 0
53336: PPUSH
53337: PPUSH
53338: PPUSH
53339: PPUSH
53340: PPUSH
53341: PPUSH
53342: PPUSH
53343: PPUSH
// if not mc_bases then
53344: LD_EXP 101
53348: NOT
53349: IFFALSE 53353
// exit ;
53351: GO 53979
// for i = 1 to mc_bases do
53353: LD_ADDR_VAR 0 2
53357: PUSH
53358: DOUBLE
53359: LD_INT 1
53361: DEC
53362: ST_TO_ADDR
53363: LD_EXP 101
53367: PUSH
53368: FOR_TO
53369: IFFALSE 53977
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53371: LD_EXP 130
53375: PUSH
53376: LD_VAR 0 2
53380: ARRAY
53381: NOT
53382: PUSH
53383: LD_EXP 130
53387: PUSH
53388: LD_VAR 0 2
53392: ARRAY
53393: PPUSH
53394: LD_INT 25
53396: PUSH
53397: LD_INT 12
53399: PUSH
53400: EMPTY
53401: LIST
53402: LIST
53403: PPUSH
53404: CALL_OW 72
53408: NOT
53409: OR
53410: IFFALSE 53414
// continue ;
53412: GO 53368
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53414: LD_ADDR_VAR 0 5
53418: PUSH
53419: LD_EXP 130
53423: PUSH
53424: LD_VAR 0 2
53428: ARRAY
53429: PUSH
53430: LD_INT 1
53432: ARRAY
53433: PPUSH
53434: CALL_OW 255
53438: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53439: LD_VAR 0 5
53443: PPUSH
53444: LD_INT 2
53446: PPUSH
53447: CALL_OW 325
53451: IFFALSE 53704
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53453: LD_ADDR_VAR 0 4
53457: PUSH
53458: LD_EXP 130
53462: PUSH
53463: LD_VAR 0 2
53467: ARRAY
53468: PPUSH
53469: LD_INT 25
53471: PUSH
53472: LD_INT 16
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PPUSH
53479: CALL_OW 72
53483: ST_TO_ADDR
// if tmp < 6 then
53484: LD_VAR 0 4
53488: PUSH
53489: LD_INT 6
53491: LESS
53492: IFFALSE 53704
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53494: LD_ADDR_VAR 0 6
53498: PUSH
53499: LD_EXP 101
53503: PUSH
53504: LD_VAR 0 2
53508: ARRAY
53509: PPUSH
53510: LD_INT 2
53512: PUSH
53513: LD_INT 30
53515: PUSH
53516: LD_INT 0
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: PUSH
53523: LD_INT 30
53525: PUSH
53526: LD_INT 1
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: PUSH
53533: EMPTY
53534: LIST
53535: LIST
53536: LIST
53537: PPUSH
53538: CALL_OW 72
53542: ST_TO_ADDR
// if depot then
53543: LD_VAR 0 6
53547: IFFALSE 53704
// begin selected := 0 ;
53549: LD_ADDR_VAR 0 7
53553: PUSH
53554: LD_INT 0
53556: ST_TO_ADDR
// for j in depot do
53557: LD_ADDR_VAR 0 3
53561: PUSH
53562: LD_VAR 0 6
53566: PUSH
53567: FOR_IN
53568: IFFALSE 53599
// begin if UnitsInside ( j ) < 6 then
53570: LD_VAR 0 3
53574: PPUSH
53575: CALL_OW 313
53579: PUSH
53580: LD_INT 6
53582: LESS
53583: IFFALSE 53597
// begin selected := j ;
53585: LD_ADDR_VAR 0 7
53589: PUSH
53590: LD_VAR 0 3
53594: ST_TO_ADDR
// break ;
53595: GO 53599
// end ; end ;
53597: GO 53567
53599: POP
53600: POP
// if selected then
53601: LD_VAR 0 7
53605: IFFALSE 53704
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53607: LD_ADDR_VAR 0 3
53611: PUSH
53612: LD_EXP 130
53616: PUSH
53617: LD_VAR 0 2
53621: ARRAY
53622: PPUSH
53623: LD_INT 25
53625: PUSH
53626: LD_INT 12
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: PPUSH
53633: CALL_OW 72
53637: PUSH
53638: FOR_IN
53639: IFFALSE 53702
// if not HasTask ( j ) then
53641: LD_VAR 0 3
53645: PPUSH
53646: CALL_OW 314
53650: NOT
53651: IFFALSE 53700
// begin if not IsInUnit ( j ) then
53653: LD_VAR 0 3
53657: PPUSH
53658: CALL_OW 310
53662: NOT
53663: IFFALSE 53679
// ComEnterUnit ( j , selected ) ;
53665: LD_VAR 0 3
53669: PPUSH
53670: LD_VAR 0 7
53674: PPUSH
53675: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53679: LD_VAR 0 3
53683: PPUSH
53684: LD_INT 16
53686: PPUSH
53687: CALL_OW 183
// AddComExitBuilding ( j ) ;
53691: LD_VAR 0 3
53695: PPUSH
53696: CALL_OW 182
// end ;
53700: GO 53638
53702: POP
53703: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53704: LD_VAR 0 5
53708: PPUSH
53709: LD_INT 11
53711: PPUSH
53712: CALL_OW 325
53716: IFFALSE 53975
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53718: LD_ADDR_VAR 0 4
53722: PUSH
53723: LD_EXP 130
53727: PUSH
53728: LD_VAR 0 2
53732: ARRAY
53733: PPUSH
53734: LD_INT 25
53736: PUSH
53737: LD_INT 16
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: PPUSH
53744: CALL_OW 72
53748: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53749: LD_VAR 0 4
53753: PUSH
53754: LD_INT 6
53756: GREATEREQUAL
53757: PUSH
53758: LD_VAR 0 5
53762: PPUSH
53763: LD_INT 2
53765: PPUSH
53766: CALL_OW 325
53770: NOT
53771: OR
53772: IFFALSE 53975
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53774: LD_ADDR_VAR 0 8
53778: PUSH
53779: LD_EXP 101
53783: PUSH
53784: LD_VAR 0 2
53788: ARRAY
53789: PPUSH
53790: LD_INT 2
53792: PUSH
53793: LD_INT 30
53795: PUSH
53796: LD_INT 4
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: PUSH
53803: LD_INT 30
53805: PUSH
53806: LD_INT 5
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: LIST
53817: PPUSH
53818: CALL_OW 72
53822: ST_TO_ADDR
// if barracks then
53823: LD_VAR 0 8
53827: IFFALSE 53975
// begin selected := 0 ;
53829: LD_ADDR_VAR 0 7
53833: PUSH
53834: LD_INT 0
53836: ST_TO_ADDR
// for j in barracks do
53837: LD_ADDR_VAR 0 3
53841: PUSH
53842: LD_VAR 0 8
53846: PUSH
53847: FOR_IN
53848: IFFALSE 53879
// begin if UnitsInside ( j ) < 6 then
53850: LD_VAR 0 3
53854: PPUSH
53855: CALL_OW 313
53859: PUSH
53860: LD_INT 6
53862: LESS
53863: IFFALSE 53877
// begin selected := j ;
53865: LD_ADDR_VAR 0 7
53869: PUSH
53870: LD_VAR 0 3
53874: ST_TO_ADDR
// break ;
53875: GO 53879
// end ; end ;
53877: GO 53847
53879: POP
53880: POP
// if selected then
53881: LD_VAR 0 7
53885: IFFALSE 53975
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53887: LD_ADDR_VAR 0 3
53891: PUSH
53892: LD_EXP 130
53896: PUSH
53897: LD_VAR 0 2
53901: ARRAY
53902: PPUSH
53903: LD_INT 25
53905: PUSH
53906: LD_INT 12
53908: PUSH
53909: EMPTY
53910: LIST
53911: LIST
53912: PPUSH
53913: CALL_OW 72
53917: PUSH
53918: FOR_IN
53919: IFFALSE 53973
// if not IsInUnit ( j ) and not HasTask ( j ) then
53921: LD_VAR 0 3
53925: PPUSH
53926: CALL_OW 310
53930: NOT
53931: PUSH
53932: LD_VAR 0 3
53936: PPUSH
53937: CALL_OW 314
53941: NOT
53942: AND
53943: IFFALSE 53971
// begin ComEnterUnit ( j , selected ) ;
53945: LD_VAR 0 3
53949: PPUSH
53950: LD_VAR 0 7
53954: PPUSH
53955: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53959: LD_VAR 0 3
53963: PPUSH
53964: LD_INT 15
53966: PPUSH
53967: CALL_OW 183
// end ;
53971: GO 53918
53973: POP
53974: POP
// end ; end ; end ; end ; end ;
53975: GO 53368
53977: POP
53978: POP
// end ;
53979: LD_VAR 0 1
53983: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53984: LD_INT 0
53986: PPUSH
53987: PPUSH
53988: PPUSH
53989: PPUSH
// if not mc_bases then
53990: LD_EXP 101
53994: NOT
53995: IFFALSE 53999
// exit ;
53997: GO 54177
// for i = 1 to mc_bases do
53999: LD_ADDR_VAR 0 2
54003: PUSH
54004: DOUBLE
54005: LD_INT 1
54007: DEC
54008: ST_TO_ADDR
54009: LD_EXP 101
54013: PUSH
54014: FOR_TO
54015: IFFALSE 54175
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54017: LD_ADDR_VAR 0 4
54021: PUSH
54022: LD_EXP 101
54026: PUSH
54027: LD_VAR 0 2
54031: ARRAY
54032: PPUSH
54033: LD_INT 25
54035: PUSH
54036: LD_INT 9
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PPUSH
54043: CALL_OW 72
54047: ST_TO_ADDR
// if not tmp then
54048: LD_VAR 0 4
54052: NOT
54053: IFFALSE 54057
// continue ;
54055: GO 54014
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54057: LD_EXP 127
54061: PUSH
54062: LD_VAR 0 2
54066: ARRAY
54067: PPUSH
54068: LD_INT 29
54070: PPUSH
54071: CALL_OW 325
54075: NOT
54076: PUSH
54077: LD_EXP 127
54081: PUSH
54082: LD_VAR 0 2
54086: ARRAY
54087: PPUSH
54088: LD_INT 28
54090: PPUSH
54091: CALL_OW 325
54095: NOT
54096: AND
54097: IFFALSE 54101
// continue ;
54099: GO 54014
// for j in tmp do
54101: LD_ADDR_VAR 0 3
54105: PUSH
54106: LD_VAR 0 4
54110: PUSH
54111: FOR_IN
54112: IFFALSE 54171
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54114: LD_VAR 0 3
54118: PUSH
54119: LD_EXP 104
54123: PUSH
54124: LD_VAR 0 2
54128: ARRAY
54129: PUSH
54130: LD_INT 1
54132: ARRAY
54133: IN
54134: NOT
54135: PUSH
54136: LD_VAR 0 3
54140: PUSH
54141: LD_EXP 104
54145: PUSH
54146: LD_VAR 0 2
54150: ARRAY
54151: PUSH
54152: LD_INT 2
54154: ARRAY
54155: IN
54156: NOT
54157: AND
54158: IFFALSE 54169
// ComSpaceTimeShoot ( j ) ;
54160: LD_VAR 0 3
54164: PPUSH
54165: CALL 65195 0 1
54169: GO 54111
54171: POP
54172: POP
// end ;
54173: GO 54014
54175: POP
54176: POP
// end ;
54177: LD_VAR 0 1
54181: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54182: LD_INT 0
54184: PPUSH
54185: PPUSH
54186: PPUSH
54187: PPUSH
54188: PPUSH
54189: PPUSH
54190: PPUSH
54191: PPUSH
54192: PPUSH
// if not mc_bases then
54193: LD_EXP 101
54197: NOT
54198: IFFALSE 54202
// exit ;
54200: GO 54824
// for i = 1 to mc_bases do
54202: LD_ADDR_VAR 0 2
54206: PUSH
54207: DOUBLE
54208: LD_INT 1
54210: DEC
54211: ST_TO_ADDR
54212: LD_EXP 101
54216: PUSH
54217: FOR_TO
54218: IFFALSE 54822
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54220: LD_EXP 136
54224: PUSH
54225: LD_VAR 0 2
54229: ARRAY
54230: NOT
54231: PUSH
54232: LD_INT 38
54234: PPUSH
54235: LD_EXP 127
54239: PUSH
54240: LD_VAR 0 2
54244: ARRAY
54245: PPUSH
54246: CALL_OW 321
54250: PUSH
54251: LD_INT 2
54253: NONEQUAL
54254: OR
54255: IFFALSE 54259
// continue ;
54257: GO 54217
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54259: LD_ADDR_VAR 0 8
54263: PUSH
54264: LD_EXP 101
54268: PUSH
54269: LD_VAR 0 2
54273: ARRAY
54274: PPUSH
54275: LD_INT 30
54277: PUSH
54278: LD_INT 34
54280: PUSH
54281: EMPTY
54282: LIST
54283: LIST
54284: PPUSH
54285: CALL_OW 72
54289: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54290: LD_ADDR_VAR 0 9
54294: PUSH
54295: LD_EXP 101
54299: PUSH
54300: LD_VAR 0 2
54304: ARRAY
54305: PPUSH
54306: LD_INT 25
54308: PUSH
54309: LD_INT 4
54311: PUSH
54312: EMPTY
54313: LIST
54314: LIST
54315: PPUSH
54316: CALL_OW 72
54320: PPUSH
54321: LD_INT 0
54323: PPUSH
54324: CALL 104869 0 2
54328: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54329: LD_VAR 0 9
54333: NOT
54334: PUSH
54335: LD_VAR 0 8
54339: NOT
54340: OR
54341: PUSH
54342: LD_EXP 101
54346: PUSH
54347: LD_VAR 0 2
54351: ARRAY
54352: PPUSH
54353: LD_INT 124
54355: PPUSH
54356: CALL 104869 0 2
54360: OR
54361: IFFALSE 54365
// continue ;
54363: GO 54217
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54365: LD_EXP 137
54369: PUSH
54370: LD_VAR 0 2
54374: ARRAY
54375: PUSH
54376: LD_EXP 136
54380: PUSH
54381: LD_VAR 0 2
54385: ARRAY
54386: LESS
54387: PUSH
54388: LD_EXP 137
54392: PUSH
54393: LD_VAR 0 2
54397: ARRAY
54398: PUSH
54399: LD_VAR 0 8
54403: LESS
54404: AND
54405: IFFALSE 54820
// begin tmp := sci [ 1 ] ;
54407: LD_ADDR_VAR 0 7
54411: PUSH
54412: LD_VAR 0 9
54416: PUSH
54417: LD_INT 1
54419: ARRAY
54420: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54421: LD_VAR 0 7
54425: PPUSH
54426: LD_INT 124
54428: PPUSH
54429: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54433: LD_ADDR_VAR 0 3
54437: PUSH
54438: DOUBLE
54439: LD_EXP 136
54443: PUSH
54444: LD_VAR 0 2
54448: ARRAY
54449: INC
54450: ST_TO_ADDR
54451: LD_EXP 136
54455: PUSH
54456: LD_VAR 0 2
54460: ARRAY
54461: PUSH
54462: FOR_DOWNTO
54463: IFFALSE 54806
// begin if IsInUnit ( tmp ) then
54465: LD_VAR 0 7
54469: PPUSH
54470: CALL_OW 310
54474: IFFALSE 54485
// ComExitBuilding ( tmp ) ;
54476: LD_VAR 0 7
54480: PPUSH
54481: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54485: LD_INT 35
54487: PPUSH
54488: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54492: LD_VAR 0 7
54496: PPUSH
54497: CALL_OW 310
54501: NOT
54502: PUSH
54503: LD_VAR 0 7
54507: PPUSH
54508: CALL_OW 314
54512: NOT
54513: AND
54514: IFFALSE 54485
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54516: LD_ADDR_VAR 0 6
54520: PUSH
54521: LD_VAR 0 7
54525: PPUSH
54526: CALL_OW 250
54530: PUSH
54531: LD_VAR 0 7
54535: PPUSH
54536: CALL_OW 251
54540: PUSH
54541: EMPTY
54542: LIST
54543: LIST
54544: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54545: LD_INT 35
54547: PPUSH
54548: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54552: LD_ADDR_VAR 0 4
54556: PUSH
54557: LD_EXP 136
54561: PUSH
54562: LD_VAR 0 2
54566: ARRAY
54567: PUSH
54568: LD_VAR 0 3
54572: ARRAY
54573: PUSH
54574: LD_INT 1
54576: ARRAY
54577: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54578: LD_ADDR_VAR 0 5
54582: PUSH
54583: LD_EXP 136
54587: PUSH
54588: LD_VAR 0 2
54592: ARRAY
54593: PUSH
54594: LD_VAR 0 3
54598: ARRAY
54599: PUSH
54600: LD_INT 2
54602: ARRAY
54603: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54604: LD_VAR 0 7
54608: PPUSH
54609: LD_INT 10
54611: PPUSH
54612: CALL 74202 0 2
54616: PUSH
54617: LD_INT 4
54619: ARRAY
54620: IFFALSE 54658
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54622: LD_VAR 0 7
54626: PPUSH
54627: LD_VAR 0 6
54631: PUSH
54632: LD_INT 1
54634: ARRAY
54635: PPUSH
54636: LD_VAR 0 6
54640: PUSH
54641: LD_INT 2
54643: ARRAY
54644: PPUSH
54645: CALL_OW 111
// wait ( 0 0$10 ) ;
54649: LD_INT 350
54651: PPUSH
54652: CALL_OW 67
// end else
54656: GO 54684
// begin ComMoveXY ( tmp , x , y ) ;
54658: LD_VAR 0 7
54662: PPUSH
54663: LD_VAR 0 4
54667: PPUSH
54668: LD_VAR 0 5
54672: PPUSH
54673: CALL_OW 111
// wait ( 0 0$3 ) ;
54677: LD_INT 105
54679: PPUSH
54680: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54684: LD_VAR 0 7
54688: PPUSH
54689: LD_VAR 0 4
54693: PPUSH
54694: LD_VAR 0 5
54698: PPUSH
54699: CALL_OW 307
54703: IFFALSE 54545
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54705: LD_VAR 0 7
54709: PPUSH
54710: LD_VAR 0 4
54714: PPUSH
54715: LD_VAR 0 5
54719: PPUSH
54720: LD_VAR 0 8
54724: PUSH
54725: LD_VAR 0 3
54729: ARRAY
54730: PPUSH
54731: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54735: LD_INT 35
54737: PPUSH
54738: CALL_OW 67
// until not HasTask ( tmp ) ;
54742: LD_VAR 0 7
54746: PPUSH
54747: CALL_OW 314
54751: NOT
54752: IFFALSE 54735
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54754: LD_ADDR_EXP 137
54758: PUSH
54759: LD_EXP 137
54763: PPUSH
54764: LD_VAR 0 2
54768: PUSH
54769: LD_EXP 137
54773: PUSH
54774: LD_VAR 0 2
54778: ARRAY
54779: PUSH
54780: LD_INT 1
54782: PLUS
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: PPUSH
54788: LD_VAR 0 8
54792: PUSH
54793: LD_VAR 0 3
54797: ARRAY
54798: PPUSH
54799: CALL 71609 0 3
54803: ST_TO_ADDR
// end ;
54804: GO 54462
54806: POP
54807: POP
// MC_Reset ( i , 124 ) ;
54808: LD_VAR 0 2
54812: PPUSH
54813: LD_INT 124
54815: PPUSH
54816: CALL 38307 0 2
// end ; end ;
54820: GO 54217
54822: POP
54823: POP
// end ;
54824: LD_VAR 0 1
54828: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54829: LD_INT 0
54831: PPUSH
54832: PPUSH
54833: PPUSH
// if not mc_bases then
54834: LD_EXP 101
54838: NOT
54839: IFFALSE 54843
// exit ;
54841: GO 55449
// for i = 1 to mc_bases do
54843: LD_ADDR_VAR 0 2
54847: PUSH
54848: DOUBLE
54849: LD_INT 1
54851: DEC
54852: ST_TO_ADDR
54853: LD_EXP 101
54857: PUSH
54858: FOR_TO
54859: IFFALSE 55447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54861: LD_ADDR_VAR 0 3
54865: PUSH
54866: LD_EXP 101
54870: PUSH
54871: LD_VAR 0 2
54875: ARRAY
54876: PPUSH
54877: LD_INT 25
54879: PUSH
54880: LD_INT 4
54882: PUSH
54883: EMPTY
54884: LIST
54885: LIST
54886: PPUSH
54887: CALL_OW 72
54891: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54892: LD_VAR 0 3
54896: NOT
54897: PUSH
54898: LD_EXP 138
54902: PUSH
54903: LD_VAR 0 2
54907: ARRAY
54908: NOT
54909: OR
54910: PUSH
54911: LD_EXP 101
54915: PUSH
54916: LD_VAR 0 2
54920: ARRAY
54921: PPUSH
54922: LD_INT 2
54924: PUSH
54925: LD_INT 30
54927: PUSH
54928: LD_INT 0
54930: PUSH
54931: EMPTY
54932: LIST
54933: LIST
54934: PUSH
54935: LD_INT 30
54937: PUSH
54938: LD_INT 1
54940: PUSH
54941: EMPTY
54942: LIST
54943: LIST
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: LIST
54949: PPUSH
54950: CALL_OW 72
54954: NOT
54955: OR
54956: IFFALSE 55006
// begin if mc_deposits_finder [ i ] then
54958: LD_EXP 139
54962: PUSH
54963: LD_VAR 0 2
54967: ARRAY
54968: IFFALSE 55004
// begin MC_Reset ( i , 125 ) ;
54970: LD_VAR 0 2
54974: PPUSH
54975: LD_INT 125
54977: PPUSH
54978: CALL 38307 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54982: LD_ADDR_EXP 139
54986: PUSH
54987: LD_EXP 139
54991: PPUSH
54992: LD_VAR 0 2
54996: PPUSH
54997: EMPTY
54998: PPUSH
54999: CALL_OW 1
55003: ST_TO_ADDR
// end ; continue ;
55004: GO 54858
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55006: LD_EXP 138
55010: PUSH
55011: LD_VAR 0 2
55015: ARRAY
55016: PUSH
55017: LD_INT 1
55019: ARRAY
55020: PUSH
55021: LD_INT 3
55023: ARRAY
55024: PUSH
55025: LD_INT 1
55027: EQUAL
55028: PUSH
55029: LD_INT 20
55031: PPUSH
55032: LD_EXP 127
55036: PUSH
55037: LD_VAR 0 2
55041: ARRAY
55042: PPUSH
55043: CALL_OW 321
55047: PUSH
55048: LD_INT 2
55050: NONEQUAL
55051: AND
55052: IFFALSE 55102
// begin if mc_deposits_finder [ i ] then
55054: LD_EXP 139
55058: PUSH
55059: LD_VAR 0 2
55063: ARRAY
55064: IFFALSE 55100
// begin MC_Reset ( i , 125 ) ;
55066: LD_VAR 0 2
55070: PPUSH
55071: LD_INT 125
55073: PPUSH
55074: CALL 38307 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55078: LD_ADDR_EXP 139
55082: PUSH
55083: LD_EXP 139
55087: PPUSH
55088: LD_VAR 0 2
55092: PPUSH
55093: EMPTY
55094: PPUSH
55095: CALL_OW 1
55099: ST_TO_ADDR
// end ; continue ;
55100: GO 54858
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55102: LD_EXP 138
55106: PUSH
55107: LD_VAR 0 2
55111: ARRAY
55112: PUSH
55113: LD_INT 1
55115: ARRAY
55116: PUSH
55117: LD_INT 1
55119: ARRAY
55120: PPUSH
55121: LD_EXP 138
55125: PUSH
55126: LD_VAR 0 2
55130: ARRAY
55131: PUSH
55132: LD_INT 1
55134: ARRAY
55135: PUSH
55136: LD_INT 2
55138: ARRAY
55139: PPUSH
55140: LD_EXP 127
55144: PUSH
55145: LD_VAR 0 2
55149: ARRAY
55150: PPUSH
55151: CALL_OW 440
55155: IFFALSE 55198
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55157: LD_ADDR_EXP 138
55161: PUSH
55162: LD_EXP 138
55166: PPUSH
55167: LD_VAR 0 2
55171: PPUSH
55172: LD_EXP 138
55176: PUSH
55177: LD_VAR 0 2
55181: ARRAY
55182: PPUSH
55183: LD_INT 1
55185: PPUSH
55186: CALL_OW 3
55190: PPUSH
55191: CALL_OW 1
55195: ST_TO_ADDR
55196: GO 55445
// begin if not mc_deposits_finder [ i ] then
55198: LD_EXP 139
55202: PUSH
55203: LD_VAR 0 2
55207: ARRAY
55208: NOT
55209: IFFALSE 55261
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55211: LD_ADDR_EXP 139
55215: PUSH
55216: LD_EXP 139
55220: PPUSH
55221: LD_VAR 0 2
55225: PPUSH
55226: LD_VAR 0 3
55230: PUSH
55231: LD_INT 1
55233: ARRAY
55234: PUSH
55235: EMPTY
55236: LIST
55237: PPUSH
55238: CALL_OW 1
55242: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55243: LD_VAR 0 3
55247: PUSH
55248: LD_INT 1
55250: ARRAY
55251: PPUSH
55252: LD_INT 125
55254: PPUSH
55255: CALL_OW 109
// end else
55259: GO 55445
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55261: LD_EXP 139
55265: PUSH
55266: LD_VAR 0 2
55270: ARRAY
55271: PUSH
55272: LD_INT 1
55274: ARRAY
55275: PPUSH
55276: CALL_OW 310
55280: IFFALSE 55303
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55282: LD_EXP 139
55286: PUSH
55287: LD_VAR 0 2
55291: ARRAY
55292: PUSH
55293: LD_INT 1
55295: ARRAY
55296: PPUSH
55297: CALL_OW 122
55301: GO 55445
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55303: LD_EXP 139
55307: PUSH
55308: LD_VAR 0 2
55312: ARRAY
55313: PUSH
55314: LD_INT 1
55316: ARRAY
55317: PPUSH
55318: CALL_OW 314
55322: NOT
55323: PUSH
55324: LD_EXP 139
55328: PUSH
55329: LD_VAR 0 2
55333: ARRAY
55334: PUSH
55335: LD_INT 1
55337: ARRAY
55338: PPUSH
55339: LD_EXP 138
55343: PUSH
55344: LD_VAR 0 2
55348: ARRAY
55349: PUSH
55350: LD_INT 1
55352: ARRAY
55353: PUSH
55354: LD_INT 1
55356: ARRAY
55357: PPUSH
55358: LD_EXP 138
55362: PUSH
55363: LD_VAR 0 2
55367: ARRAY
55368: PUSH
55369: LD_INT 1
55371: ARRAY
55372: PUSH
55373: LD_INT 2
55375: ARRAY
55376: PPUSH
55377: CALL_OW 297
55381: PUSH
55382: LD_INT 6
55384: GREATER
55385: AND
55386: IFFALSE 55445
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55388: LD_EXP 139
55392: PUSH
55393: LD_VAR 0 2
55397: ARRAY
55398: PUSH
55399: LD_INT 1
55401: ARRAY
55402: PPUSH
55403: LD_EXP 138
55407: PUSH
55408: LD_VAR 0 2
55412: ARRAY
55413: PUSH
55414: LD_INT 1
55416: ARRAY
55417: PUSH
55418: LD_INT 1
55420: ARRAY
55421: PPUSH
55422: LD_EXP 138
55426: PUSH
55427: LD_VAR 0 2
55431: ARRAY
55432: PUSH
55433: LD_INT 1
55435: ARRAY
55436: PUSH
55437: LD_INT 2
55439: ARRAY
55440: PPUSH
55441: CALL_OW 111
// end ; end ; end ;
55445: GO 54858
55447: POP
55448: POP
// end ;
55449: LD_VAR 0 1
55453: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55454: LD_INT 0
55456: PPUSH
55457: PPUSH
55458: PPUSH
55459: PPUSH
55460: PPUSH
55461: PPUSH
55462: PPUSH
55463: PPUSH
55464: PPUSH
55465: PPUSH
55466: PPUSH
// if not mc_bases then
55467: LD_EXP 101
55471: NOT
55472: IFFALSE 55476
// exit ;
55474: GO 56416
// for i = 1 to mc_bases do
55476: LD_ADDR_VAR 0 2
55480: PUSH
55481: DOUBLE
55482: LD_INT 1
55484: DEC
55485: ST_TO_ADDR
55486: LD_EXP 101
55490: PUSH
55491: FOR_TO
55492: IFFALSE 56414
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55494: LD_EXP 101
55498: PUSH
55499: LD_VAR 0 2
55503: ARRAY
55504: NOT
55505: PUSH
55506: LD_EXP 124
55510: PUSH
55511: LD_VAR 0 2
55515: ARRAY
55516: OR
55517: IFFALSE 55521
// continue ;
55519: GO 55491
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55521: LD_ADDR_VAR 0 7
55525: PUSH
55526: LD_EXP 101
55530: PUSH
55531: LD_VAR 0 2
55535: ARRAY
55536: PUSH
55537: LD_INT 1
55539: ARRAY
55540: PPUSH
55541: CALL_OW 248
55545: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55546: LD_VAR 0 7
55550: PUSH
55551: LD_INT 3
55553: EQUAL
55554: PUSH
55555: LD_EXP 120
55559: PUSH
55560: LD_VAR 0 2
55564: ARRAY
55565: PUSH
55566: LD_EXP 123
55570: PUSH
55571: LD_VAR 0 2
55575: ARRAY
55576: UNION
55577: PPUSH
55578: LD_INT 33
55580: PUSH
55581: LD_INT 2
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: PPUSH
55588: CALL_OW 72
55592: NOT
55593: OR
55594: IFFALSE 55598
// continue ;
55596: GO 55491
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55598: LD_ADDR_VAR 0 9
55602: PUSH
55603: LD_EXP 101
55607: PUSH
55608: LD_VAR 0 2
55612: ARRAY
55613: PPUSH
55614: LD_INT 30
55616: PUSH
55617: LD_INT 36
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PPUSH
55624: CALL_OW 72
55628: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55629: LD_ADDR_VAR 0 10
55633: PUSH
55634: LD_EXP 120
55638: PUSH
55639: LD_VAR 0 2
55643: ARRAY
55644: PPUSH
55645: LD_INT 34
55647: PUSH
55648: LD_INT 31
55650: PUSH
55651: EMPTY
55652: LIST
55653: LIST
55654: PPUSH
55655: CALL_OW 72
55659: ST_TO_ADDR
// if not cts and not mcts then
55660: LD_VAR 0 9
55664: NOT
55665: PUSH
55666: LD_VAR 0 10
55670: NOT
55671: AND
55672: IFFALSE 55676
// continue ;
55674: GO 55491
// x := cts ;
55676: LD_ADDR_VAR 0 11
55680: PUSH
55681: LD_VAR 0 9
55685: ST_TO_ADDR
// if not x then
55686: LD_VAR 0 11
55690: NOT
55691: IFFALSE 55703
// x := mcts ;
55693: LD_ADDR_VAR 0 11
55697: PUSH
55698: LD_VAR 0 10
55702: ST_TO_ADDR
// if not x then
55703: LD_VAR 0 11
55707: NOT
55708: IFFALSE 55712
// continue ;
55710: GO 55491
// if mc_remote_driver [ i ] then
55712: LD_EXP 141
55716: PUSH
55717: LD_VAR 0 2
55721: ARRAY
55722: IFFALSE 56109
// for j in mc_remote_driver [ i ] do
55724: LD_ADDR_VAR 0 3
55728: PUSH
55729: LD_EXP 141
55733: PUSH
55734: LD_VAR 0 2
55738: ARRAY
55739: PUSH
55740: FOR_IN
55741: IFFALSE 56107
// begin if GetClass ( j ) <> 3 then
55743: LD_VAR 0 3
55747: PPUSH
55748: CALL_OW 257
55752: PUSH
55753: LD_INT 3
55755: NONEQUAL
55756: IFFALSE 55809
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55758: LD_ADDR_EXP 141
55762: PUSH
55763: LD_EXP 141
55767: PPUSH
55768: LD_VAR 0 2
55772: PPUSH
55773: LD_EXP 141
55777: PUSH
55778: LD_VAR 0 2
55782: ARRAY
55783: PUSH
55784: LD_VAR 0 3
55788: DIFF
55789: PPUSH
55790: CALL_OW 1
55794: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55795: LD_VAR 0 3
55799: PPUSH
55800: LD_INT 0
55802: PPUSH
55803: CALL_OW 109
// continue ;
55807: GO 55740
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55809: LD_EXP 120
55813: PUSH
55814: LD_VAR 0 2
55818: ARRAY
55819: PPUSH
55820: LD_INT 34
55822: PUSH
55823: LD_INT 31
55825: PUSH
55826: EMPTY
55827: LIST
55828: LIST
55829: PUSH
55830: LD_INT 58
55832: PUSH
55833: EMPTY
55834: LIST
55835: PUSH
55836: EMPTY
55837: LIST
55838: LIST
55839: PPUSH
55840: CALL_OW 72
55844: PUSH
55845: LD_VAR 0 3
55849: PPUSH
55850: CALL 104957 0 1
55854: NOT
55855: AND
55856: IFFALSE 55927
// begin if IsInUnit ( j ) then
55858: LD_VAR 0 3
55862: PPUSH
55863: CALL_OW 310
55867: IFFALSE 55878
// ComExitBuilding ( j ) ;
55869: LD_VAR 0 3
55873: PPUSH
55874: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55878: LD_VAR 0 3
55882: PPUSH
55883: LD_EXP 120
55887: PUSH
55888: LD_VAR 0 2
55892: ARRAY
55893: PPUSH
55894: LD_INT 34
55896: PUSH
55897: LD_INT 31
55899: PUSH
55900: EMPTY
55901: LIST
55902: LIST
55903: PUSH
55904: LD_INT 58
55906: PUSH
55907: EMPTY
55908: LIST
55909: PUSH
55910: EMPTY
55911: LIST
55912: LIST
55913: PPUSH
55914: CALL_OW 72
55918: PUSH
55919: LD_INT 1
55921: ARRAY
55922: PPUSH
55923: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55927: LD_VAR 0 3
55931: PPUSH
55932: CALL_OW 310
55936: NOT
55937: PUSH
55938: LD_VAR 0 3
55942: PPUSH
55943: CALL_OW 310
55947: PPUSH
55948: CALL_OW 266
55952: PUSH
55953: LD_INT 36
55955: NONEQUAL
55956: PUSH
55957: LD_VAR 0 3
55961: PPUSH
55962: CALL 104957 0 1
55966: NOT
55967: AND
55968: OR
55969: IFFALSE 56105
// begin if IsInUnit ( j ) then
55971: LD_VAR 0 3
55975: PPUSH
55976: CALL_OW 310
55980: IFFALSE 55991
// ComExitBuilding ( j ) ;
55982: LD_VAR 0 3
55986: PPUSH
55987: CALL_OW 122
// ct := 0 ;
55991: LD_ADDR_VAR 0 8
55995: PUSH
55996: LD_INT 0
55998: ST_TO_ADDR
// for k in x do
55999: LD_ADDR_VAR 0 4
56003: PUSH
56004: LD_VAR 0 11
56008: PUSH
56009: FOR_IN
56010: IFFALSE 56083
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56012: LD_VAR 0 4
56016: PPUSH
56017: CALL_OW 264
56021: PUSH
56022: LD_INT 31
56024: EQUAL
56025: PUSH
56026: LD_VAR 0 4
56030: PPUSH
56031: CALL_OW 311
56035: NOT
56036: AND
56037: PUSH
56038: LD_VAR 0 4
56042: PPUSH
56043: CALL_OW 266
56047: PUSH
56048: LD_INT 36
56050: EQUAL
56051: PUSH
56052: LD_VAR 0 4
56056: PPUSH
56057: CALL_OW 313
56061: PUSH
56062: LD_INT 3
56064: LESS
56065: AND
56066: OR
56067: IFFALSE 56081
// begin ct := k ;
56069: LD_ADDR_VAR 0 8
56073: PUSH
56074: LD_VAR 0 4
56078: ST_TO_ADDR
// break ;
56079: GO 56083
// end ;
56081: GO 56009
56083: POP
56084: POP
// if ct then
56085: LD_VAR 0 8
56089: IFFALSE 56105
// ComEnterUnit ( j , ct ) ;
56091: LD_VAR 0 3
56095: PPUSH
56096: LD_VAR 0 8
56100: PPUSH
56101: CALL_OW 120
// end ; end ;
56105: GO 55740
56107: POP
56108: POP
// places := 0 ;
56109: LD_ADDR_VAR 0 5
56113: PUSH
56114: LD_INT 0
56116: ST_TO_ADDR
// for j = 1 to x do
56117: LD_ADDR_VAR 0 3
56121: PUSH
56122: DOUBLE
56123: LD_INT 1
56125: DEC
56126: ST_TO_ADDR
56127: LD_VAR 0 11
56131: PUSH
56132: FOR_TO
56133: IFFALSE 56209
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56135: LD_VAR 0 11
56139: PUSH
56140: LD_VAR 0 3
56144: ARRAY
56145: PPUSH
56146: CALL_OW 264
56150: PUSH
56151: LD_INT 31
56153: EQUAL
56154: IFFALSE 56172
// places := places + 1 else
56156: LD_ADDR_VAR 0 5
56160: PUSH
56161: LD_VAR 0 5
56165: PUSH
56166: LD_INT 1
56168: PLUS
56169: ST_TO_ADDR
56170: GO 56207
// if GetBType ( x [ j ] ) = b_control_tower then
56172: LD_VAR 0 11
56176: PUSH
56177: LD_VAR 0 3
56181: ARRAY
56182: PPUSH
56183: CALL_OW 266
56187: PUSH
56188: LD_INT 36
56190: EQUAL
56191: IFFALSE 56207
// places := places + 3 ;
56193: LD_ADDR_VAR 0 5
56197: PUSH
56198: LD_VAR 0 5
56202: PUSH
56203: LD_INT 3
56205: PLUS
56206: ST_TO_ADDR
56207: GO 56132
56209: POP
56210: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56211: LD_VAR 0 5
56215: PUSH
56216: LD_INT 0
56218: EQUAL
56219: PUSH
56220: LD_VAR 0 5
56224: PUSH
56225: LD_EXP 141
56229: PUSH
56230: LD_VAR 0 2
56234: ARRAY
56235: LESSEQUAL
56236: OR
56237: IFFALSE 56241
// continue ;
56239: GO 55491
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56241: LD_ADDR_VAR 0 6
56245: PUSH
56246: LD_EXP 101
56250: PUSH
56251: LD_VAR 0 2
56255: ARRAY
56256: PPUSH
56257: LD_INT 25
56259: PUSH
56260: LD_INT 3
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PPUSH
56267: CALL_OW 72
56271: PUSH
56272: LD_EXP 141
56276: PUSH
56277: LD_VAR 0 2
56281: ARRAY
56282: DIFF
56283: PPUSH
56284: LD_INT 3
56286: PPUSH
56287: CALL 105857 0 2
56291: ST_TO_ADDR
// for j in tmp do
56292: LD_ADDR_VAR 0 3
56296: PUSH
56297: LD_VAR 0 6
56301: PUSH
56302: FOR_IN
56303: IFFALSE 56338
// if GetTag ( j ) > 0 then
56305: LD_VAR 0 3
56309: PPUSH
56310: CALL_OW 110
56314: PUSH
56315: LD_INT 0
56317: GREATER
56318: IFFALSE 56336
// tmp := tmp diff j ;
56320: LD_ADDR_VAR 0 6
56324: PUSH
56325: LD_VAR 0 6
56329: PUSH
56330: LD_VAR 0 3
56334: DIFF
56335: ST_TO_ADDR
56336: GO 56302
56338: POP
56339: POP
// if not tmp then
56340: LD_VAR 0 6
56344: NOT
56345: IFFALSE 56349
// continue ;
56347: GO 55491
// if places then
56349: LD_VAR 0 5
56353: IFFALSE 56412
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56355: LD_ADDR_EXP 141
56359: PUSH
56360: LD_EXP 141
56364: PPUSH
56365: LD_VAR 0 2
56369: PPUSH
56370: LD_EXP 141
56374: PUSH
56375: LD_VAR 0 2
56379: ARRAY
56380: PUSH
56381: LD_VAR 0 6
56385: PUSH
56386: LD_INT 1
56388: ARRAY
56389: UNION
56390: PPUSH
56391: CALL_OW 1
56395: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56396: LD_VAR 0 6
56400: PUSH
56401: LD_INT 1
56403: ARRAY
56404: PPUSH
56405: LD_INT 126
56407: PPUSH
56408: CALL_OW 109
// end ; end ;
56412: GO 55491
56414: POP
56415: POP
// end ;
56416: LD_VAR 0 1
56420: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56421: LD_INT 0
56423: PPUSH
56424: PPUSH
56425: PPUSH
56426: PPUSH
56427: PPUSH
56428: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56429: LD_VAR 0 1
56433: NOT
56434: PUSH
56435: LD_VAR 0 2
56439: NOT
56440: OR
56441: PUSH
56442: LD_VAR 0 3
56446: NOT
56447: OR
56448: PUSH
56449: LD_VAR 0 4
56453: PUSH
56454: LD_INT 1
56456: PUSH
56457: LD_INT 2
56459: PUSH
56460: LD_INT 3
56462: PUSH
56463: LD_INT 4
56465: PUSH
56466: LD_INT 5
56468: PUSH
56469: LD_INT 8
56471: PUSH
56472: LD_INT 9
56474: PUSH
56475: LD_INT 15
56477: PUSH
56478: LD_INT 16
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: LIST
56485: LIST
56486: LIST
56487: LIST
56488: LIST
56489: LIST
56490: LIST
56491: IN
56492: NOT
56493: OR
56494: IFFALSE 56498
// exit ;
56496: GO 57398
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56498: LD_ADDR_VAR 0 2
56502: PUSH
56503: LD_VAR 0 2
56507: PPUSH
56508: LD_INT 21
56510: PUSH
56511: LD_INT 3
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: PUSH
56518: LD_INT 24
56520: PUSH
56521: LD_INT 250
56523: PUSH
56524: EMPTY
56525: LIST
56526: LIST
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PPUSH
56532: CALL_OW 72
56536: ST_TO_ADDR
// case class of 1 , 15 :
56537: LD_VAR 0 4
56541: PUSH
56542: LD_INT 1
56544: DOUBLE
56545: EQUAL
56546: IFTRUE 56556
56548: LD_INT 15
56550: DOUBLE
56551: EQUAL
56552: IFTRUE 56556
56554: GO 56641
56556: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56557: LD_ADDR_VAR 0 8
56561: PUSH
56562: LD_VAR 0 2
56566: PPUSH
56567: LD_INT 2
56569: PUSH
56570: LD_INT 30
56572: PUSH
56573: LD_INT 32
56575: PUSH
56576: EMPTY
56577: LIST
56578: LIST
56579: PUSH
56580: LD_INT 30
56582: PUSH
56583: LD_INT 31
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: LIST
56594: PPUSH
56595: CALL_OW 72
56599: PUSH
56600: LD_VAR 0 2
56604: PPUSH
56605: LD_INT 2
56607: PUSH
56608: LD_INT 30
56610: PUSH
56611: LD_INT 4
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: PUSH
56618: LD_INT 30
56620: PUSH
56621: LD_INT 5
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: PUSH
56628: EMPTY
56629: LIST
56630: LIST
56631: LIST
56632: PPUSH
56633: CALL_OW 72
56637: ADD
56638: ST_TO_ADDR
56639: GO 56887
56641: LD_INT 2
56643: DOUBLE
56644: EQUAL
56645: IFTRUE 56655
56647: LD_INT 16
56649: DOUBLE
56650: EQUAL
56651: IFTRUE 56655
56653: GO 56701
56655: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56656: LD_ADDR_VAR 0 8
56660: PUSH
56661: LD_VAR 0 2
56665: PPUSH
56666: LD_INT 2
56668: PUSH
56669: LD_INT 30
56671: PUSH
56672: LD_INT 0
56674: PUSH
56675: EMPTY
56676: LIST
56677: LIST
56678: PUSH
56679: LD_INT 30
56681: PUSH
56682: LD_INT 1
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: PUSH
56689: EMPTY
56690: LIST
56691: LIST
56692: LIST
56693: PPUSH
56694: CALL_OW 72
56698: ST_TO_ADDR
56699: GO 56887
56701: LD_INT 3
56703: DOUBLE
56704: EQUAL
56705: IFTRUE 56709
56707: GO 56755
56709: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56710: LD_ADDR_VAR 0 8
56714: PUSH
56715: LD_VAR 0 2
56719: PPUSH
56720: LD_INT 2
56722: PUSH
56723: LD_INT 30
56725: PUSH
56726: LD_INT 2
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: PUSH
56733: LD_INT 30
56735: PUSH
56736: LD_INT 3
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: LIST
56747: PPUSH
56748: CALL_OW 72
56752: ST_TO_ADDR
56753: GO 56887
56755: LD_INT 4
56757: DOUBLE
56758: EQUAL
56759: IFTRUE 56763
56761: GO 56820
56763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56764: LD_ADDR_VAR 0 8
56768: PUSH
56769: LD_VAR 0 2
56773: PPUSH
56774: LD_INT 2
56776: PUSH
56777: LD_INT 30
56779: PUSH
56780: LD_INT 6
56782: PUSH
56783: EMPTY
56784: LIST
56785: LIST
56786: PUSH
56787: LD_INT 30
56789: PUSH
56790: LD_INT 7
56792: PUSH
56793: EMPTY
56794: LIST
56795: LIST
56796: PUSH
56797: LD_INT 30
56799: PUSH
56800: LD_INT 8
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: PUSH
56807: EMPTY
56808: LIST
56809: LIST
56810: LIST
56811: LIST
56812: PPUSH
56813: CALL_OW 72
56817: ST_TO_ADDR
56818: GO 56887
56820: LD_INT 5
56822: DOUBLE
56823: EQUAL
56824: IFTRUE 56840
56826: LD_INT 8
56828: DOUBLE
56829: EQUAL
56830: IFTRUE 56840
56832: LD_INT 9
56834: DOUBLE
56835: EQUAL
56836: IFTRUE 56840
56838: GO 56886
56840: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56841: LD_ADDR_VAR 0 8
56845: PUSH
56846: LD_VAR 0 2
56850: PPUSH
56851: LD_INT 2
56853: PUSH
56854: LD_INT 30
56856: PUSH
56857: LD_INT 4
56859: PUSH
56860: EMPTY
56861: LIST
56862: LIST
56863: PUSH
56864: LD_INT 30
56866: PUSH
56867: LD_INT 5
56869: PUSH
56870: EMPTY
56871: LIST
56872: LIST
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: LIST
56878: PPUSH
56879: CALL_OW 72
56883: ST_TO_ADDR
56884: GO 56887
56886: POP
// if not tmp then
56887: LD_VAR 0 8
56891: NOT
56892: IFFALSE 56896
// exit ;
56894: GO 57398
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56896: LD_VAR 0 4
56900: PUSH
56901: LD_INT 1
56903: PUSH
56904: LD_INT 15
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: IN
56911: PUSH
56912: LD_EXP 110
56916: PUSH
56917: LD_VAR 0 1
56921: ARRAY
56922: AND
56923: IFFALSE 57079
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56925: LD_ADDR_VAR 0 9
56929: PUSH
56930: LD_EXP 110
56934: PUSH
56935: LD_VAR 0 1
56939: ARRAY
56940: PUSH
56941: LD_INT 1
56943: ARRAY
56944: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56945: LD_VAR 0 9
56949: PUSH
56950: LD_EXP 111
56954: PUSH
56955: LD_VAR 0 1
56959: ARRAY
56960: IN
56961: NOT
56962: IFFALSE 57077
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56964: LD_ADDR_EXP 111
56968: PUSH
56969: LD_EXP 111
56973: PPUSH
56974: LD_VAR 0 1
56978: PUSH
56979: LD_EXP 111
56983: PUSH
56984: LD_VAR 0 1
56988: ARRAY
56989: PUSH
56990: LD_INT 1
56992: PLUS
56993: PUSH
56994: EMPTY
56995: LIST
56996: LIST
56997: PPUSH
56998: LD_VAR 0 9
57002: PPUSH
57003: CALL 71609 0 3
57007: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57008: LD_ADDR_EXP 110
57012: PUSH
57013: LD_EXP 110
57017: PPUSH
57018: LD_VAR 0 1
57022: PPUSH
57023: LD_EXP 110
57027: PUSH
57028: LD_VAR 0 1
57032: ARRAY
57033: PUSH
57034: LD_VAR 0 9
57038: DIFF
57039: PPUSH
57040: CALL_OW 1
57044: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57045: LD_VAR 0 3
57049: PPUSH
57050: LD_EXP 111
57054: PUSH
57055: LD_VAR 0 1
57059: ARRAY
57060: PUSH
57061: LD_EXP 111
57065: PUSH
57066: LD_VAR 0 1
57070: ARRAY
57071: ARRAY
57072: PPUSH
57073: CALL_OW 120
// end ; exit ;
57077: GO 57398
// end ; if tmp > 1 then
57079: LD_VAR 0 8
57083: PUSH
57084: LD_INT 1
57086: GREATER
57087: IFFALSE 57191
// for i = 2 to tmp do
57089: LD_ADDR_VAR 0 6
57093: PUSH
57094: DOUBLE
57095: LD_INT 2
57097: DEC
57098: ST_TO_ADDR
57099: LD_VAR 0 8
57103: PUSH
57104: FOR_TO
57105: IFFALSE 57189
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57107: LD_VAR 0 8
57111: PUSH
57112: LD_VAR 0 6
57116: ARRAY
57117: PPUSH
57118: CALL_OW 461
57122: PUSH
57123: LD_INT 6
57125: EQUAL
57126: IFFALSE 57187
// begin x := tmp [ i ] ;
57128: LD_ADDR_VAR 0 9
57132: PUSH
57133: LD_VAR 0 8
57137: PUSH
57138: LD_VAR 0 6
57142: ARRAY
57143: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57144: LD_ADDR_VAR 0 8
57148: PUSH
57149: LD_VAR 0 8
57153: PPUSH
57154: LD_VAR 0 6
57158: PPUSH
57159: CALL_OW 3
57163: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57164: LD_ADDR_VAR 0 8
57168: PUSH
57169: LD_VAR 0 8
57173: PPUSH
57174: LD_INT 1
57176: PPUSH
57177: LD_VAR 0 9
57181: PPUSH
57182: CALL_OW 2
57186: ST_TO_ADDR
// end ;
57187: GO 57104
57189: POP
57190: POP
// for i in tmp do
57191: LD_ADDR_VAR 0 6
57195: PUSH
57196: LD_VAR 0 8
57200: PUSH
57201: FOR_IN
57202: IFFALSE 57271
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57204: LD_VAR 0 6
57208: PPUSH
57209: CALL_OW 313
57213: PUSH
57214: LD_INT 6
57216: LESS
57217: PUSH
57218: LD_VAR 0 6
57222: PPUSH
57223: CALL_OW 266
57227: PUSH
57228: LD_INT 31
57230: PUSH
57231: LD_INT 32
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: IN
57238: NOT
57239: AND
57240: PUSH
57241: LD_VAR 0 6
57245: PPUSH
57246: CALL_OW 313
57250: PUSH
57251: LD_INT 0
57253: EQUAL
57254: OR
57255: IFFALSE 57269
// begin j := i ;
57257: LD_ADDR_VAR 0 7
57261: PUSH
57262: LD_VAR 0 6
57266: ST_TO_ADDR
// break ;
57267: GO 57271
// end ; end ;
57269: GO 57201
57271: POP
57272: POP
// if j then
57273: LD_VAR 0 7
57277: IFFALSE 57295
// ComEnterUnit ( unit , j ) else
57279: LD_VAR 0 3
57283: PPUSH
57284: LD_VAR 0 7
57288: PPUSH
57289: CALL_OW 120
57293: GO 57398
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57295: LD_ADDR_VAR 0 10
57299: PUSH
57300: LD_VAR 0 2
57304: PPUSH
57305: LD_INT 2
57307: PUSH
57308: LD_INT 30
57310: PUSH
57311: LD_INT 0
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: PUSH
57318: LD_INT 30
57320: PUSH
57321: LD_INT 1
57323: PUSH
57324: EMPTY
57325: LIST
57326: LIST
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: LIST
57332: PPUSH
57333: CALL_OW 72
57337: ST_TO_ADDR
// if depot then
57338: LD_VAR 0 10
57342: IFFALSE 57398
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57344: LD_ADDR_VAR 0 10
57348: PUSH
57349: LD_VAR 0 10
57353: PPUSH
57354: LD_VAR 0 3
57358: PPUSH
57359: CALL_OW 74
57363: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57364: LD_VAR 0 3
57368: PPUSH
57369: LD_VAR 0 10
57373: PPUSH
57374: CALL_OW 296
57378: PUSH
57379: LD_INT 10
57381: GREATER
57382: IFFALSE 57398
// ComStandNearbyBuilding ( unit , depot ) ;
57384: LD_VAR 0 3
57388: PPUSH
57389: LD_VAR 0 10
57393: PPUSH
57394: CALL 65812 0 2
// end ; end ; end ;
57398: LD_VAR 0 5
57402: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57403: LD_INT 0
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
// if not mc_bases then
57409: LD_EXP 101
57413: NOT
57414: IFFALSE 57418
// exit ;
57416: GO 57657
// for i = 1 to mc_bases do
57418: LD_ADDR_VAR 0 2
57422: PUSH
57423: DOUBLE
57424: LD_INT 1
57426: DEC
57427: ST_TO_ADDR
57428: LD_EXP 101
57432: PUSH
57433: FOR_TO
57434: IFFALSE 57655
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57436: LD_ADDR_VAR 0 4
57440: PUSH
57441: LD_EXP 101
57445: PUSH
57446: LD_VAR 0 2
57450: ARRAY
57451: PPUSH
57452: LD_INT 21
57454: PUSH
57455: LD_INT 1
57457: PUSH
57458: EMPTY
57459: LIST
57460: LIST
57461: PPUSH
57462: CALL_OW 72
57466: PUSH
57467: LD_EXP 130
57471: PUSH
57472: LD_VAR 0 2
57476: ARRAY
57477: UNION
57478: ST_TO_ADDR
// if not tmp then
57479: LD_VAR 0 4
57483: NOT
57484: IFFALSE 57488
// continue ;
57486: GO 57433
// for j in tmp do
57488: LD_ADDR_VAR 0 3
57492: PUSH
57493: LD_VAR 0 4
57497: PUSH
57498: FOR_IN
57499: IFFALSE 57651
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57501: LD_VAR 0 3
57505: PPUSH
57506: CALL_OW 110
57510: NOT
57511: PUSH
57512: LD_VAR 0 3
57516: PPUSH
57517: CALL_OW 314
57521: NOT
57522: AND
57523: PUSH
57524: LD_VAR 0 3
57528: PPUSH
57529: CALL_OW 311
57533: NOT
57534: AND
57535: PUSH
57536: LD_VAR 0 3
57540: PPUSH
57541: CALL_OW 310
57545: NOT
57546: AND
57547: PUSH
57548: LD_VAR 0 3
57552: PUSH
57553: LD_EXP 104
57557: PUSH
57558: LD_VAR 0 2
57562: ARRAY
57563: PUSH
57564: LD_INT 1
57566: ARRAY
57567: IN
57568: NOT
57569: AND
57570: PUSH
57571: LD_VAR 0 3
57575: PUSH
57576: LD_EXP 104
57580: PUSH
57581: LD_VAR 0 2
57585: ARRAY
57586: PUSH
57587: LD_INT 2
57589: ARRAY
57590: IN
57591: NOT
57592: AND
57593: PUSH
57594: LD_VAR 0 3
57598: PUSH
57599: LD_EXP 113
57603: PUSH
57604: LD_VAR 0 2
57608: ARRAY
57609: IN
57610: NOT
57611: AND
57612: IFFALSE 57649
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57614: LD_VAR 0 2
57618: PPUSH
57619: LD_EXP 101
57623: PUSH
57624: LD_VAR 0 2
57628: ARRAY
57629: PPUSH
57630: LD_VAR 0 3
57634: PPUSH
57635: LD_VAR 0 3
57639: PPUSH
57640: CALL_OW 257
57644: PPUSH
57645: CALL 56421 0 4
// end ;
57649: GO 57498
57651: POP
57652: POP
// end ;
57653: GO 57433
57655: POP
57656: POP
// end ;
57657: LD_VAR 0 1
57661: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57662: LD_INT 0
57664: PPUSH
57665: PPUSH
57666: PPUSH
57667: PPUSH
57668: PPUSH
57669: PPUSH
// if not mc_bases [ base ] then
57670: LD_EXP 101
57674: PUSH
57675: LD_VAR 0 1
57679: ARRAY
57680: NOT
57681: IFFALSE 57685
// exit ;
57683: GO 57867
// tmp := [ ] ;
57685: LD_ADDR_VAR 0 6
57689: PUSH
57690: EMPTY
57691: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57692: LD_ADDR_VAR 0 7
57696: PUSH
57697: LD_VAR 0 3
57701: PPUSH
57702: LD_INT 0
57704: PPUSH
57705: CALL_OW 517
57709: ST_TO_ADDR
// if not list then
57710: LD_VAR 0 7
57714: NOT
57715: IFFALSE 57719
// exit ;
57717: GO 57867
// for i = 1 to amount do
57719: LD_ADDR_VAR 0 5
57723: PUSH
57724: DOUBLE
57725: LD_INT 1
57727: DEC
57728: ST_TO_ADDR
57729: LD_VAR 0 2
57733: PUSH
57734: FOR_TO
57735: IFFALSE 57815
// begin x := rand ( 1 , list [ 1 ] ) ;
57737: LD_ADDR_VAR 0 8
57741: PUSH
57742: LD_INT 1
57744: PPUSH
57745: LD_VAR 0 7
57749: PUSH
57750: LD_INT 1
57752: ARRAY
57753: PPUSH
57754: CALL_OW 12
57758: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57759: LD_ADDR_VAR 0 6
57763: PUSH
57764: LD_VAR 0 6
57768: PPUSH
57769: LD_VAR 0 5
57773: PPUSH
57774: LD_VAR 0 7
57778: PUSH
57779: LD_INT 1
57781: ARRAY
57782: PUSH
57783: LD_VAR 0 8
57787: ARRAY
57788: PUSH
57789: LD_VAR 0 7
57793: PUSH
57794: LD_INT 2
57796: ARRAY
57797: PUSH
57798: LD_VAR 0 8
57802: ARRAY
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PPUSH
57808: CALL_OW 1
57812: ST_TO_ADDR
// end ;
57813: GO 57734
57815: POP
57816: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57817: LD_ADDR_EXP 114
57821: PUSH
57822: LD_EXP 114
57826: PPUSH
57827: LD_VAR 0 1
57831: PPUSH
57832: LD_VAR 0 6
57836: PPUSH
57837: CALL_OW 1
57841: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57842: LD_ADDR_EXP 116
57846: PUSH
57847: LD_EXP 116
57851: PPUSH
57852: LD_VAR 0 1
57856: PPUSH
57857: LD_VAR 0 3
57861: PPUSH
57862: CALL_OW 1
57866: ST_TO_ADDR
// end ;
57867: LD_VAR 0 4
57871: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57872: LD_INT 0
57874: PPUSH
// if not mc_bases [ base ] then
57875: LD_EXP 101
57879: PUSH
57880: LD_VAR 0 1
57884: ARRAY
57885: NOT
57886: IFFALSE 57890
// exit ;
57888: GO 57915
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57890: LD_ADDR_EXP 106
57894: PUSH
57895: LD_EXP 106
57899: PPUSH
57900: LD_VAR 0 1
57904: PPUSH
57905: LD_VAR 0 2
57909: PPUSH
57910: CALL_OW 1
57914: ST_TO_ADDR
// end ;
57915: LD_VAR 0 3
57919: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57920: LD_INT 0
57922: PPUSH
// if not mc_bases [ base ] then
57923: LD_EXP 101
57927: PUSH
57928: LD_VAR 0 1
57932: ARRAY
57933: NOT
57934: IFFALSE 57938
// exit ;
57936: GO 57975
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57938: LD_ADDR_EXP 106
57942: PUSH
57943: LD_EXP 106
57947: PPUSH
57948: LD_VAR 0 1
57952: PPUSH
57953: LD_EXP 106
57957: PUSH
57958: LD_VAR 0 1
57962: ARRAY
57963: PUSH
57964: LD_VAR 0 2
57968: UNION
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
// end ;
57975: LD_VAR 0 3
57979: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57980: LD_INT 0
57982: PPUSH
// if not mc_bases [ base ] then
57983: LD_EXP 101
57987: PUSH
57988: LD_VAR 0 1
57992: ARRAY
57993: NOT
57994: IFFALSE 57998
// exit ;
57996: GO 58023
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57998: LD_ADDR_EXP 122
58002: PUSH
58003: LD_EXP 122
58007: PPUSH
58008: LD_VAR 0 1
58012: PPUSH
58013: LD_VAR 0 2
58017: PPUSH
58018: CALL_OW 1
58022: ST_TO_ADDR
// end ;
58023: LD_VAR 0 3
58027: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58028: LD_INT 0
58030: PPUSH
// if not mc_bases [ base ] then
58031: LD_EXP 101
58035: PUSH
58036: LD_VAR 0 1
58040: ARRAY
58041: NOT
58042: IFFALSE 58046
// exit ;
58044: GO 58083
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58046: LD_ADDR_EXP 122
58050: PUSH
58051: LD_EXP 122
58055: PPUSH
58056: LD_VAR 0 1
58060: PPUSH
58061: LD_EXP 122
58065: PUSH
58066: LD_VAR 0 1
58070: ARRAY
58071: PUSH
58072: LD_VAR 0 2
58076: ADD
58077: PPUSH
58078: CALL_OW 1
58082: ST_TO_ADDR
// end ;
58083: LD_VAR 0 3
58087: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58088: LD_INT 0
58090: PPUSH
// if not mc_bases [ base ] then
58091: LD_EXP 101
58095: PUSH
58096: LD_VAR 0 1
58100: ARRAY
58101: NOT
58102: IFFALSE 58106
// exit ;
58104: GO 58160
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58106: LD_ADDR_EXP 123
58110: PUSH
58111: LD_EXP 123
58115: PPUSH
58116: LD_VAR 0 1
58120: PPUSH
58121: LD_VAR 0 2
58125: PPUSH
58126: CALL_OW 1
58130: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58131: LD_ADDR_EXP 112
58135: PUSH
58136: LD_EXP 112
58140: PPUSH
58141: LD_VAR 0 1
58145: PPUSH
58146: LD_VAR 0 2
58150: PUSH
58151: LD_INT 0
58153: PLUS
58154: PPUSH
58155: CALL_OW 1
58159: ST_TO_ADDR
// end ;
58160: LD_VAR 0 3
58164: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58165: LD_INT 0
58167: PPUSH
// if not mc_bases [ base ] then
58168: LD_EXP 101
58172: PUSH
58173: LD_VAR 0 1
58177: ARRAY
58178: NOT
58179: IFFALSE 58183
// exit ;
58181: GO 58208
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58183: LD_ADDR_EXP 112
58187: PUSH
58188: LD_EXP 112
58192: PPUSH
58193: LD_VAR 0 1
58197: PPUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: CALL_OW 1
58207: ST_TO_ADDR
// end ;
58208: LD_VAR 0 3
58212: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58213: LD_INT 0
58215: PPUSH
58216: PPUSH
58217: PPUSH
58218: PPUSH
// if not mc_bases [ base ] then
58219: LD_EXP 101
58223: PUSH
58224: LD_VAR 0 1
58228: ARRAY
58229: NOT
58230: IFFALSE 58234
// exit ;
58232: GO 58299
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58234: LD_ADDR_EXP 121
58238: PUSH
58239: LD_EXP 121
58243: PPUSH
58244: LD_VAR 0 1
58248: PUSH
58249: LD_EXP 121
58253: PUSH
58254: LD_VAR 0 1
58258: ARRAY
58259: PUSH
58260: LD_INT 1
58262: PLUS
58263: PUSH
58264: EMPTY
58265: LIST
58266: LIST
58267: PPUSH
58268: LD_VAR 0 1
58272: PUSH
58273: LD_VAR 0 2
58277: PUSH
58278: LD_VAR 0 3
58282: PUSH
58283: LD_VAR 0 4
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: LIST
58292: LIST
58293: PPUSH
58294: CALL 71609 0 3
58298: ST_TO_ADDR
// end ;
58299: LD_VAR 0 5
58303: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58304: LD_INT 0
58306: PPUSH
// if not mc_bases [ base ] then
58307: LD_EXP 101
58311: PUSH
58312: LD_VAR 0 1
58316: ARRAY
58317: NOT
58318: IFFALSE 58322
// exit ;
58320: GO 58347
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58322: LD_ADDR_EXP 138
58326: PUSH
58327: LD_EXP 138
58331: PPUSH
58332: LD_VAR 0 1
58336: PPUSH
58337: LD_VAR 0 2
58341: PPUSH
58342: CALL_OW 1
58346: ST_TO_ADDR
// end ;
58347: LD_VAR 0 3
58351: RET
// export function MC_GetMinesField ( base ) ; begin
58352: LD_INT 0
58354: PPUSH
// result := mc_mines [ base ] ;
58355: LD_ADDR_VAR 0 2
58359: PUSH
58360: LD_EXP 114
58364: PUSH
58365: LD_VAR 0 1
58369: ARRAY
58370: ST_TO_ADDR
// end ;
58371: LD_VAR 0 2
58375: RET
// export function MC_GetProduceList ( base ) ; begin
58376: LD_INT 0
58378: PPUSH
// result := mc_produce [ base ] ;
58379: LD_ADDR_VAR 0 2
58383: PUSH
58384: LD_EXP 122
58388: PUSH
58389: LD_VAR 0 1
58393: ARRAY
58394: ST_TO_ADDR
// end ;
58395: LD_VAR 0 2
58399: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58400: LD_INT 0
58402: PPUSH
58403: PPUSH
// if not mc_bases then
58404: LD_EXP 101
58408: NOT
58409: IFFALSE 58413
// exit ;
58411: GO 58478
// if mc_bases [ base ] then
58413: LD_EXP 101
58417: PUSH
58418: LD_VAR 0 1
58422: ARRAY
58423: IFFALSE 58478
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58425: LD_ADDR_VAR 0 3
58429: PUSH
58430: LD_EXP 101
58434: PUSH
58435: LD_VAR 0 1
58439: ARRAY
58440: PPUSH
58441: LD_INT 30
58443: PUSH
58444: LD_VAR 0 2
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PPUSH
58453: CALL_OW 72
58457: ST_TO_ADDR
// if result then
58458: LD_VAR 0 3
58462: IFFALSE 58478
// result := result [ 1 ] ;
58464: LD_ADDR_VAR 0 3
58468: PUSH
58469: LD_VAR 0 3
58473: PUSH
58474: LD_INT 1
58476: ARRAY
58477: ST_TO_ADDR
// end ; end ;
58478: LD_VAR 0 3
58482: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58483: LD_INT 0
58485: PPUSH
58486: PPUSH
// if not mc_bases then
58487: LD_EXP 101
58491: NOT
58492: IFFALSE 58496
// exit ;
58494: GO 58541
// if mc_bases [ base ] then
58496: LD_EXP 101
58500: PUSH
58501: LD_VAR 0 1
58505: ARRAY
58506: IFFALSE 58541
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58508: LD_ADDR_VAR 0 3
58512: PUSH
58513: LD_EXP 101
58517: PUSH
58518: LD_VAR 0 1
58522: ARRAY
58523: PPUSH
58524: LD_INT 30
58526: PUSH
58527: LD_VAR 0 2
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PPUSH
58536: CALL_OW 72
58540: ST_TO_ADDR
// end ;
58541: LD_VAR 0 3
58545: RET
// export function MC_SetTame ( base , area ) ; begin
58546: LD_INT 0
58548: PPUSH
// if not mc_bases or not base then
58549: LD_EXP 101
58553: NOT
58554: PUSH
58555: LD_VAR 0 1
58559: NOT
58560: OR
58561: IFFALSE 58565
// exit ;
58563: GO 58590
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58565: LD_ADDR_EXP 129
58569: PUSH
58570: LD_EXP 129
58574: PPUSH
58575: LD_VAR 0 1
58579: PPUSH
58580: LD_VAR 0 2
58584: PPUSH
58585: CALL_OW 1
58589: ST_TO_ADDR
// end ;
58590: LD_VAR 0 3
58594: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58595: LD_INT 0
58597: PPUSH
58598: PPUSH
// if not mc_bases or not base then
58599: LD_EXP 101
58603: NOT
58604: PUSH
58605: LD_VAR 0 1
58609: NOT
58610: OR
58611: IFFALSE 58615
// exit ;
58613: GO 58717
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58615: LD_ADDR_VAR 0 4
58619: PUSH
58620: LD_EXP 101
58624: PUSH
58625: LD_VAR 0 1
58629: ARRAY
58630: PPUSH
58631: LD_INT 30
58633: PUSH
58634: LD_VAR 0 2
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: PPUSH
58643: CALL_OW 72
58647: ST_TO_ADDR
// if not tmp then
58648: LD_VAR 0 4
58652: NOT
58653: IFFALSE 58657
// exit ;
58655: GO 58717
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58657: LD_ADDR_EXP 133
58661: PUSH
58662: LD_EXP 133
58666: PPUSH
58667: LD_VAR 0 1
58671: PPUSH
58672: LD_EXP 133
58676: PUSH
58677: LD_VAR 0 1
58681: ARRAY
58682: PPUSH
58683: LD_EXP 133
58687: PUSH
58688: LD_VAR 0 1
58692: ARRAY
58693: PUSH
58694: LD_INT 1
58696: PLUS
58697: PPUSH
58698: LD_VAR 0 4
58702: PUSH
58703: LD_INT 1
58705: ARRAY
58706: PPUSH
58707: CALL_OW 2
58711: PPUSH
58712: CALL_OW 1
58716: ST_TO_ADDR
// end ;
58717: LD_VAR 0 3
58721: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58722: LD_INT 0
58724: PPUSH
58725: PPUSH
// if not mc_bases or not base or not kinds then
58726: LD_EXP 101
58730: NOT
58731: PUSH
58732: LD_VAR 0 1
58736: NOT
58737: OR
58738: PUSH
58739: LD_VAR 0 2
58743: NOT
58744: OR
58745: IFFALSE 58749
// exit ;
58747: GO 58810
// for i in kinds do
58749: LD_ADDR_VAR 0 4
58753: PUSH
58754: LD_VAR 0 2
58758: PUSH
58759: FOR_IN
58760: IFFALSE 58808
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58762: LD_ADDR_EXP 135
58766: PUSH
58767: LD_EXP 135
58771: PPUSH
58772: LD_VAR 0 1
58776: PUSH
58777: LD_EXP 135
58781: PUSH
58782: LD_VAR 0 1
58786: ARRAY
58787: PUSH
58788: LD_INT 1
58790: PLUS
58791: PUSH
58792: EMPTY
58793: LIST
58794: LIST
58795: PPUSH
58796: LD_VAR 0 4
58800: PPUSH
58801: CALL 71609 0 3
58805: ST_TO_ADDR
58806: GO 58759
58808: POP
58809: POP
// end ;
58810: LD_VAR 0 3
58814: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58815: LD_INT 0
58817: PPUSH
// if not mc_bases or not base or not areas then
58818: LD_EXP 101
58822: NOT
58823: PUSH
58824: LD_VAR 0 1
58828: NOT
58829: OR
58830: PUSH
58831: LD_VAR 0 2
58835: NOT
58836: OR
58837: IFFALSE 58841
// exit ;
58839: GO 58866
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58841: LD_ADDR_EXP 119
58845: PUSH
58846: LD_EXP 119
58850: PPUSH
58851: LD_VAR 0 1
58855: PPUSH
58856: LD_VAR 0 2
58860: PPUSH
58861: CALL_OW 1
58865: ST_TO_ADDR
// end ;
58866: LD_VAR 0 3
58870: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58871: LD_INT 0
58873: PPUSH
// if not mc_bases or not base or not teleports_exit then
58874: LD_EXP 101
58878: NOT
58879: PUSH
58880: LD_VAR 0 1
58884: NOT
58885: OR
58886: PUSH
58887: LD_VAR 0 2
58891: NOT
58892: OR
58893: IFFALSE 58897
// exit ;
58895: GO 58922
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58897: LD_ADDR_EXP 136
58901: PUSH
58902: LD_EXP 136
58906: PPUSH
58907: LD_VAR 0 1
58911: PPUSH
58912: LD_VAR 0 2
58916: PPUSH
58917: CALL_OW 1
58921: ST_TO_ADDR
// end ;
58922: LD_VAR 0 3
58926: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58927: LD_INT 0
58929: PPUSH
58930: PPUSH
58931: PPUSH
// if not mc_bases or not base or not ext_list then
58932: LD_EXP 101
58936: NOT
58937: PUSH
58938: LD_VAR 0 1
58942: NOT
58943: OR
58944: PUSH
58945: LD_VAR 0 5
58949: NOT
58950: OR
58951: IFFALSE 58955
// exit ;
58953: GO 59128
// tmp := GetFacExtXYD ( x , y , d ) ;
58955: LD_ADDR_VAR 0 8
58959: PUSH
58960: LD_VAR 0 2
58964: PPUSH
58965: LD_VAR 0 3
58969: PPUSH
58970: LD_VAR 0 4
58974: PPUSH
58975: CALL 104987 0 3
58979: ST_TO_ADDR
// if not tmp then
58980: LD_VAR 0 8
58984: NOT
58985: IFFALSE 58989
// exit ;
58987: GO 59128
// for i in tmp do
58989: LD_ADDR_VAR 0 7
58993: PUSH
58994: LD_VAR 0 8
58998: PUSH
58999: FOR_IN
59000: IFFALSE 59126
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59002: LD_ADDR_EXP 106
59006: PUSH
59007: LD_EXP 106
59011: PPUSH
59012: LD_VAR 0 1
59016: PPUSH
59017: LD_EXP 106
59021: PUSH
59022: LD_VAR 0 1
59026: ARRAY
59027: PPUSH
59028: LD_EXP 106
59032: PUSH
59033: LD_VAR 0 1
59037: ARRAY
59038: PUSH
59039: LD_INT 1
59041: PLUS
59042: PPUSH
59043: LD_VAR 0 5
59047: PUSH
59048: LD_INT 1
59050: ARRAY
59051: PUSH
59052: LD_VAR 0 7
59056: PUSH
59057: LD_INT 1
59059: ARRAY
59060: PUSH
59061: LD_VAR 0 7
59065: PUSH
59066: LD_INT 2
59068: ARRAY
59069: PUSH
59070: LD_VAR 0 7
59074: PUSH
59075: LD_INT 3
59077: ARRAY
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: LIST
59083: LIST
59084: PPUSH
59085: CALL_OW 2
59089: PPUSH
59090: CALL_OW 1
59094: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59095: LD_ADDR_VAR 0 5
59099: PUSH
59100: LD_VAR 0 5
59104: PPUSH
59105: LD_INT 1
59107: PPUSH
59108: CALL_OW 3
59112: ST_TO_ADDR
// if not ext_list then
59113: LD_VAR 0 5
59117: NOT
59118: IFFALSE 59124
// exit ;
59120: POP
59121: POP
59122: GO 59128
// end ;
59124: GO 58999
59126: POP
59127: POP
// end ;
59128: LD_VAR 0 6
59132: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59133: LD_INT 0
59135: PPUSH
// if not mc_bases or not base or not weapon_list then
59136: LD_EXP 101
59140: NOT
59141: PUSH
59142: LD_VAR 0 1
59146: NOT
59147: OR
59148: PUSH
59149: LD_VAR 0 2
59153: NOT
59154: OR
59155: IFFALSE 59159
// exit ;
59157: GO 59184
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59159: LD_ADDR_EXP 140
59163: PUSH
59164: LD_EXP 140
59168: PPUSH
59169: LD_VAR 0 1
59173: PPUSH
59174: LD_VAR 0 2
59178: PPUSH
59179: CALL_OW 1
59183: ST_TO_ADDR
// end ;
59184: LD_VAR 0 3
59188: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59189: LD_INT 0
59191: PPUSH
// if not mc_bases or not base or not tech_list then
59192: LD_EXP 101
59196: NOT
59197: PUSH
59198: LD_VAR 0 1
59202: NOT
59203: OR
59204: PUSH
59205: LD_VAR 0 2
59209: NOT
59210: OR
59211: IFFALSE 59215
// exit ;
59213: GO 59240
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59215: LD_ADDR_EXP 128
59219: PUSH
59220: LD_EXP 128
59224: PPUSH
59225: LD_VAR 0 1
59229: PPUSH
59230: LD_VAR 0 2
59234: PPUSH
59235: CALL_OW 1
59239: ST_TO_ADDR
// end ;
59240: LD_VAR 0 3
59244: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59245: LD_INT 0
59247: PPUSH
// if not mc_bases or not parking_area or not base then
59248: LD_EXP 101
59252: NOT
59253: PUSH
59254: LD_VAR 0 2
59258: NOT
59259: OR
59260: PUSH
59261: LD_VAR 0 1
59265: NOT
59266: OR
59267: IFFALSE 59271
// exit ;
59269: GO 59296
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59271: LD_ADDR_EXP 125
59275: PUSH
59276: LD_EXP 125
59280: PPUSH
59281: LD_VAR 0 1
59285: PPUSH
59286: LD_VAR 0 2
59290: PPUSH
59291: CALL_OW 1
59295: ST_TO_ADDR
// end ;
59296: LD_VAR 0 3
59300: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59301: LD_INT 0
59303: PPUSH
// if not mc_bases or not base or not scan_area then
59304: LD_EXP 101
59308: NOT
59309: PUSH
59310: LD_VAR 0 1
59314: NOT
59315: OR
59316: PUSH
59317: LD_VAR 0 2
59321: NOT
59322: OR
59323: IFFALSE 59327
// exit ;
59325: GO 59352
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59327: LD_ADDR_EXP 126
59331: PUSH
59332: LD_EXP 126
59336: PPUSH
59337: LD_VAR 0 1
59341: PPUSH
59342: LD_VAR 0 2
59346: PPUSH
59347: CALL_OW 1
59351: ST_TO_ADDR
// end ;
59352: LD_VAR 0 3
59356: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59357: LD_INT 0
59359: PPUSH
59360: PPUSH
// if not mc_bases or not base then
59361: LD_EXP 101
59365: NOT
59366: PUSH
59367: LD_VAR 0 1
59371: NOT
59372: OR
59373: IFFALSE 59377
// exit ;
59375: GO 59441
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59377: LD_ADDR_VAR 0 3
59381: PUSH
59382: LD_INT 1
59384: PUSH
59385: LD_INT 2
59387: PUSH
59388: LD_INT 3
59390: PUSH
59391: LD_INT 4
59393: PUSH
59394: LD_INT 11
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: LIST
59401: LIST
59402: LIST
59403: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59404: LD_ADDR_EXP 128
59408: PUSH
59409: LD_EXP 128
59413: PPUSH
59414: LD_VAR 0 1
59418: PPUSH
59419: LD_EXP 128
59423: PUSH
59424: LD_VAR 0 1
59428: ARRAY
59429: PUSH
59430: LD_VAR 0 3
59434: DIFF
59435: PPUSH
59436: CALL_OW 1
59440: ST_TO_ADDR
// end ;
59441: LD_VAR 0 2
59445: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59446: LD_INT 0
59448: PPUSH
// result := mc_vehicles [ base ] ;
59449: LD_ADDR_VAR 0 3
59453: PUSH
59454: LD_EXP 120
59458: PUSH
59459: LD_VAR 0 1
59463: ARRAY
59464: ST_TO_ADDR
// if onlyCombat then
59465: LD_VAR 0 2
59469: IFFALSE 59634
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59471: LD_ADDR_VAR 0 3
59475: PUSH
59476: LD_VAR 0 3
59480: PUSH
59481: LD_VAR 0 3
59485: PPUSH
59486: LD_INT 2
59488: PUSH
59489: LD_INT 34
59491: PUSH
59492: LD_INT 12
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: LD_INT 34
59501: PUSH
59502: LD_INT 51
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: PUSH
59509: LD_INT 34
59511: PUSH
59512: LD_EXP 95
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: PUSH
59521: LD_INT 34
59523: PUSH
59524: LD_INT 32
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PUSH
59531: LD_INT 34
59533: PUSH
59534: LD_INT 13
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: PUSH
59541: LD_INT 34
59543: PUSH
59544: LD_INT 52
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: PUSH
59551: LD_INT 34
59553: PUSH
59554: LD_INT 14
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: PUSH
59561: LD_INT 34
59563: PUSH
59564: LD_INT 53
59566: PUSH
59567: EMPTY
59568: LIST
59569: LIST
59570: PUSH
59571: LD_INT 34
59573: PUSH
59574: LD_EXP 94
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: PUSH
59583: LD_INT 34
59585: PUSH
59586: LD_INT 31
59588: PUSH
59589: EMPTY
59590: LIST
59591: LIST
59592: PUSH
59593: LD_INT 34
59595: PUSH
59596: LD_INT 48
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: PUSH
59603: LD_INT 34
59605: PUSH
59606: LD_INT 8
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: PUSH
59613: EMPTY
59614: LIST
59615: LIST
59616: LIST
59617: LIST
59618: LIST
59619: LIST
59620: LIST
59621: LIST
59622: LIST
59623: LIST
59624: LIST
59625: LIST
59626: LIST
59627: PPUSH
59628: CALL_OW 72
59632: DIFF
59633: ST_TO_ADDR
// end ; end_of_file
59634: LD_VAR 0 3
59638: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59639: LD_INT 0
59641: PPUSH
59642: PPUSH
59643: PPUSH
// if not mc_bases or not skirmish then
59644: LD_EXP 101
59648: NOT
59649: PUSH
59650: LD_EXP 99
59654: NOT
59655: OR
59656: IFFALSE 59660
// exit ;
59658: GO 59825
// for i = 1 to mc_bases do
59660: LD_ADDR_VAR 0 4
59664: PUSH
59665: DOUBLE
59666: LD_INT 1
59668: DEC
59669: ST_TO_ADDR
59670: LD_EXP 101
59674: PUSH
59675: FOR_TO
59676: IFFALSE 59823
// begin if sci in mc_bases [ i ] then
59678: LD_VAR 0 2
59682: PUSH
59683: LD_EXP 101
59687: PUSH
59688: LD_VAR 0 4
59692: ARRAY
59693: IN
59694: IFFALSE 59821
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59696: LD_ADDR_EXP 130
59700: PUSH
59701: LD_EXP 130
59705: PPUSH
59706: LD_VAR 0 4
59710: PUSH
59711: LD_EXP 130
59715: PUSH
59716: LD_VAR 0 4
59720: ARRAY
59721: PUSH
59722: LD_INT 1
59724: PLUS
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: PPUSH
59730: LD_VAR 0 1
59734: PPUSH
59735: CALL 71609 0 3
59739: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59740: LD_ADDR_VAR 0 5
59744: PUSH
59745: LD_EXP 101
59749: PUSH
59750: LD_VAR 0 4
59754: ARRAY
59755: PPUSH
59756: LD_INT 2
59758: PUSH
59759: LD_INT 30
59761: PUSH
59762: LD_INT 0
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: PUSH
59769: LD_INT 30
59771: PUSH
59772: LD_INT 1
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: PUSH
59779: EMPTY
59780: LIST
59781: LIST
59782: LIST
59783: PPUSH
59784: CALL_OW 72
59788: PPUSH
59789: LD_VAR 0 1
59793: PPUSH
59794: CALL_OW 74
59798: ST_TO_ADDR
// if tmp then
59799: LD_VAR 0 5
59803: IFFALSE 59819
// ComStandNearbyBuilding ( ape , tmp ) ;
59805: LD_VAR 0 1
59809: PPUSH
59810: LD_VAR 0 5
59814: PPUSH
59815: CALL 65812 0 2
// break ;
59819: GO 59823
// end ; end ;
59821: GO 59675
59823: POP
59824: POP
// end ;
59825: LD_VAR 0 3
59829: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59830: LD_INT 0
59832: PPUSH
59833: PPUSH
59834: PPUSH
// if not mc_bases or not skirmish then
59835: LD_EXP 101
59839: NOT
59840: PUSH
59841: LD_EXP 99
59845: NOT
59846: OR
59847: IFFALSE 59851
// exit ;
59849: GO 59940
// for i = 1 to mc_bases do
59851: LD_ADDR_VAR 0 4
59855: PUSH
59856: DOUBLE
59857: LD_INT 1
59859: DEC
59860: ST_TO_ADDR
59861: LD_EXP 101
59865: PUSH
59866: FOR_TO
59867: IFFALSE 59938
// begin if building in mc_busy_turret_list [ i ] then
59869: LD_VAR 0 1
59873: PUSH
59874: LD_EXP 111
59878: PUSH
59879: LD_VAR 0 4
59883: ARRAY
59884: IN
59885: IFFALSE 59936
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59887: LD_ADDR_VAR 0 5
59891: PUSH
59892: LD_EXP 111
59896: PUSH
59897: LD_VAR 0 4
59901: ARRAY
59902: PUSH
59903: LD_VAR 0 1
59907: DIFF
59908: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59909: LD_ADDR_EXP 111
59913: PUSH
59914: LD_EXP 111
59918: PPUSH
59919: LD_VAR 0 4
59923: PPUSH
59924: LD_VAR 0 5
59928: PPUSH
59929: CALL_OW 1
59933: ST_TO_ADDR
// break ;
59934: GO 59938
// end ; end ;
59936: GO 59866
59938: POP
59939: POP
// end ;
59940: LD_VAR 0 3
59944: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59945: LD_INT 0
59947: PPUSH
59948: PPUSH
59949: PPUSH
// if not mc_bases or not skirmish then
59950: LD_EXP 101
59954: NOT
59955: PUSH
59956: LD_EXP 99
59960: NOT
59961: OR
59962: IFFALSE 59966
// exit ;
59964: GO 60165
// for i = 1 to mc_bases do
59966: LD_ADDR_VAR 0 5
59970: PUSH
59971: DOUBLE
59972: LD_INT 1
59974: DEC
59975: ST_TO_ADDR
59976: LD_EXP 101
59980: PUSH
59981: FOR_TO
59982: IFFALSE 60163
// if building in mc_bases [ i ] then
59984: LD_VAR 0 1
59988: PUSH
59989: LD_EXP 101
59993: PUSH
59994: LD_VAR 0 5
59998: ARRAY
59999: IN
60000: IFFALSE 60161
// begin tmp := mc_bases [ i ] diff building ;
60002: LD_ADDR_VAR 0 6
60006: PUSH
60007: LD_EXP 101
60011: PUSH
60012: LD_VAR 0 5
60016: ARRAY
60017: PUSH
60018: LD_VAR 0 1
60022: DIFF
60023: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60024: LD_ADDR_EXP 101
60028: PUSH
60029: LD_EXP 101
60033: PPUSH
60034: LD_VAR 0 5
60038: PPUSH
60039: LD_VAR 0 6
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60049: LD_VAR 0 1
60053: PUSH
60054: LD_EXP 109
60058: PUSH
60059: LD_VAR 0 5
60063: ARRAY
60064: IN
60065: IFFALSE 60104
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60067: LD_ADDR_EXP 109
60071: PUSH
60072: LD_EXP 109
60076: PPUSH
60077: LD_VAR 0 5
60081: PPUSH
60082: LD_EXP 109
60086: PUSH
60087: LD_VAR 0 5
60091: ARRAY
60092: PUSH
60093: LD_VAR 0 1
60097: DIFF
60098: PPUSH
60099: CALL_OW 1
60103: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60104: LD_VAR 0 1
60108: PUSH
60109: LD_EXP 110
60113: PUSH
60114: LD_VAR 0 5
60118: ARRAY
60119: IN
60120: IFFALSE 60159
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60122: LD_ADDR_EXP 110
60126: PUSH
60127: LD_EXP 110
60131: PPUSH
60132: LD_VAR 0 5
60136: PPUSH
60137: LD_EXP 110
60141: PUSH
60142: LD_VAR 0 5
60146: ARRAY
60147: PUSH
60148: LD_VAR 0 1
60152: DIFF
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// break ;
60159: GO 60163
// end ;
60161: GO 59981
60163: POP
60164: POP
// end ;
60165: LD_VAR 0 4
60169: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60170: LD_INT 0
60172: PPUSH
60173: PPUSH
60174: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60175: LD_EXP 101
60179: NOT
60180: PUSH
60181: LD_EXP 99
60185: NOT
60186: OR
60187: PUSH
60188: LD_VAR 0 3
60192: PUSH
60193: LD_EXP 127
60197: IN
60198: NOT
60199: OR
60200: IFFALSE 60204
// exit ;
60202: GO 60327
// for i = 1 to mc_vehicles do
60204: LD_ADDR_VAR 0 6
60208: PUSH
60209: DOUBLE
60210: LD_INT 1
60212: DEC
60213: ST_TO_ADDR
60214: LD_EXP 120
60218: PUSH
60219: FOR_TO
60220: IFFALSE 60325
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60222: LD_VAR 0 2
60226: PUSH
60227: LD_EXP 120
60231: PUSH
60232: LD_VAR 0 6
60236: ARRAY
60237: IN
60238: PUSH
60239: LD_VAR 0 1
60243: PUSH
60244: LD_EXP 120
60248: PUSH
60249: LD_VAR 0 6
60253: ARRAY
60254: IN
60255: OR
60256: IFFALSE 60323
// begin tmp := mc_vehicles [ i ] diff old ;
60258: LD_ADDR_VAR 0 7
60262: PUSH
60263: LD_EXP 120
60267: PUSH
60268: LD_VAR 0 6
60272: ARRAY
60273: PUSH
60274: LD_VAR 0 2
60278: DIFF
60279: ST_TO_ADDR
// tmp := tmp diff new ;
60280: LD_ADDR_VAR 0 7
60284: PUSH
60285: LD_VAR 0 7
60289: PUSH
60290: LD_VAR 0 1
60294: DIFF
60295: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60296: LD_ADDR_EXP 120
60300: PUSH
60301: LD_EXP 120
60305: PPUSH
60306: LD_VAR 0 6
60310: PPUSH
60311: LD_VAR 0 7
60315: PPUSH
60316: CALL_OW 1
60320: ST_TO_ADDR
// break ;
60321: GO 60325
// end ;
60323: GO 60219
60325: POP
60326: POP
// end ;
60327: LD_VAR 0 5
60331: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60332: LD_INT 0
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
// if not mc_bases or not skirmish then
60338: LD_EXP 101
60342: NOT
60343: PUSH
60344: LD_EXP 99
60348: NOT
60349: OR
60350: IFFALSE 60354
// exit ;
60352: GO 60731
// side := GetSide ( vehicle ) ;
60354: LD_ADDR_VAR 0 5
60358: PUSH
60359: LD_VAR 0 1
60363: PPUSH
60364: CALL_OW 255
60368: ST_TO_ADDR
// for i = 1 to mc_bases do
60369: LD_ADDR_VAR 0 4
60373: PUSH
60374: DOUBLE
60375: LD_INT 1
60377: DEC
60378: ST_TO_ADDR
60379: LD_EXP 101
60383: PUSH
60384: FOR_TO
60385: IFFALSE 60729
// begin if factory in mc_bases [ i ] then
60387: LD_VAR 0 2
60391: PUSH
60392: LD_EXP 101
60396: PUSH
60397: LD_VAR 0 4
60401: ARRAY
60402: IN
60403: IFFALSE 60727
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60405: LD_EXP 123
60409: PUSH
60410: LD_VAR 0 4
60414: ARRAY
60415: PUSH
60416: LD_EXP 112
60420: PUSH
60421: LD_VAR 0 4
60425: ARRAY
60426: LESS
60427: PUSH
60428: LD_VAR 0 1
60432: PPUSH
60433: CALL_OW 264
60437: PUSH
60438: LD_INT 31
60440: PUSH
60441: LD_INT 32
60443: PUSH
60444: LD_INT 51
60446: PUSH
60447: LD_EXP 95
60451: PUSH
60452: LD_INT 12
60454: PUSH
60455: LD_INT 30
60457: PUSH
60458: LD_EXP 94
60462: PUSH
60463: LD_INT 11
60465: PUSH
60466: LD_INT 53
60468: PUSH
60469: LD_INT 14
60471: PUSH
60472: LD_EXP 98
60476: PUSH
60477: LD_INT 29
60479: PUSH
60480: LD_EXP 96
60484: PUSH
60485: LD_INT 13
60487: PUSH
60488: LD_INT 52
60490: PUSH
60491: LD_INT 48
60493: PUSH
60494: LD_INT 8
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: LIST
60501: LIST
60502: LIST
60503: LIST
60504: LIST
60505: LIST
60506: LIST
60507: LIST
60508: LIST
60509: LIST
60510: LIST
60511: LIST
60512: LIST
60513: LIST
60514: LIST
60515: IN
60516: NOT
60517: AND
60518: IFFALSE 60566
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60520: LD_ADDR_EXP 123
60524: PUSH
60525: LD_EXP 123
60529: PPUSH
60530: LD_VAR 0 4
60534: PUSH
60535: LD_EXP 123
60539: PUSH
60540: LD_VAR 0 4
60544: ARRAY
60545: PUSH
60546: LD_INT 1
60548: PLUS
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: PPUSH
60554: LD_VAR 0 1
60558: PPUSH
60559: CALL 71609 0 3
60563: ST_TO_ADDR
60564: GO 60610
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60566: LD_ADDR_EXP 120
60570: PUSH
60571: LD_EXP 120
60575: PPUSH
60576: LD_VAR 0 4
60580: PUSH
60581: LD_EXP 120
60585: PUSH
60586: LD_VAR 0 4
60590: ARRAY
60591: PUSH
60592: LD_INT 1
60594: PLUS
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: PPUSH
60600: LD_VAR 0 1
60604: PPUSH
60605: CALL 71609 0 3
60609: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60610: LD_VAR 0 1
60614: PPUSH
60615: CALL_OW 263
60619: PUSH
60620: LD_INT 2
60622: EQUAL
60623: IFFALSE 60643
// begin repeat wait ( 0 0$1 ) ;
60625: LD_INT 35
60627: PPUSH
60628: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60632: LD_VAR 0 1
60636: PPUSH
60637: CALL_OW 312
60641: IFFALSE 60625
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60643: LD_VAR 0 1
60647: PPUSH
60648: LD_EXP 125
60652: PUSH
60653: LD_VAR 0 4
60657: ARRAY
60658: PPUSH
60659: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60663: LD_VAR 0 1
60667: PPUSH
60668: CALL_OW 263
60672: PUSH
60673: LD_INT 1
60675: NONEQUAL
60676: IFFALSE 60680
// break ;
60678: GO 60729
// repeat wait ( 0 0$1 ) ;
60680: LD_INT 35
60682: PPUSH
60683: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60687: LD_VAR 0 1
60691: PPUSH
60692: LD_EXP 125
60696: PUSH
60697: LD_VAR 0 4
60701: ARRAY
60702: PPUSH
60703: CALL_OW 308
60707: IFFALSE 60680
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60709: LD_VAR 0 1
60713: PPUSH
60714: CALL_OW 311
60718: PPUSH
60719: CALL_OW 121
// exit ;
60723: POP
60724: POP
60725: GO 60731
// end ; end ;
60727: GO 60384
60729: POP
60730: POP
// end ;
60731: LD_VAR 0 3
60735: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60736: LD_INT 0
60738: PPUSH
60739: PPUSH
60740: PPUSH
60741: PPUSH
// if not mc_bases or not skirmish then
60742: LD_EXP 101
60746: NOT
60747: PUSH
60748: LD_EXP 99
60752: NOT
60753: OR
60754: IFFALSE 60758
// exit ;
60756: GO 61111
// repeat wait ( 0 0$1 ) ;
60758: LD_INT 35
60760: PPUSH
60761: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60765: LD_VAR 0 2
60769: PPUSH
60770: LD_VAR 0 3
60774: PPUSH
60775: CALL_OW 284
60779: IFFALSE 60758
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60781: LD_VAR 0 2
60785: PPUSH
60786: LD_VAR 0 3
60790: PPUSH
60791: CALL_OW 283
60795: PUSH
60796: LD_INT 4
60798: EQUAL
60799: IFFALSE 60803
// exit ;
60801: GO 61111
// for i = 1 to mc_bases do
60803: LD_ADDR_VAR 0 7
60807: PUSH
60808: DOUBLE
60809: LD_INT 1
60811: DEC
60812: ST_TO_ADDR
60813: LD_EXP 101
60817: PUSH
60818: FOR_TO
60819: IFFALSE 61109
// begin if mc_crates_area [ i ] then
60821: LD_EXP 119
60825: PUSH
60826: LD_VAR 0 7
60830: ARRAY
60831: IFFALSE 60942
// for j in mc_crates_area [ i ] do
60833: LD_ADDR_VAR 0 8
60837: PUSH
60838: LD_EXP 119
60842: PUSH
60843: LD_VAR 0 7
60847: ARRAY
60848: PUSH
60849: FOR_IN
60850: IFFALSE 60940
// if InArea ( x , y , j ) then
60852: LD_VAR 0 2
60856: PPUSH
60857: LD_VAR 0 3
60861: PPUSH
60862: LD_VAR 0 8
60866: PPUSH
60867: CALL_OW 309
60871: IFFALSE 60938
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60873: LD_ADDR_EXP 117
60877: PUSH
60878: LD_EXP 117
60882: PPUSH
60883: LD_VAR 0 7
60887: PUSH
60888: LD_EXP 117
60892: PUSH
60893: LD_VAR 0 7
60897: ARRAY
60898: PUSH
60899: LD_INT 1
60901: PLUS
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: PPUSH
60907: LD_VAR 0 4
60911: PUSH
60912: LD_VAR 0 2
60916: PUSH
60917: LD_VAR 0 3
60921: PUSH
60922: EMPTY
60923: LIST
60924: LIST
60925: LIST
60926: PPUSH
60927: CALL 71609 0 3
60931: ST_TO_ADDR
// exit ;
60932: POP
60933: POP
60934: POP
60935: POP
60936: GO 61111
// end ;
60938: GO 60849
60940: POP
60941: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60942: LD_ADDR_VAR 0 9
60946: PUSH
60947: LD_EXP 101
60951: PUSH
60952: LD_VAR 0 7
60956: ARRAY
60957: PPUSH
60958: LD_INT 2
60960: PUSH
60961: LD_INT 30
60963: PUSH
60964: LD_INT 0
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: PUSH
60971: LD_INT 30
60973: PUSH
60974: LD_INT 1
60976: PUSH
60977: EMPTY
60978: LIST
60979: LIST
60980: PUSH
60981: EMPTY
60982: LIST
60983: LIST
60984: LIST
60985: PPUSH
60986: CALL_OW 72
60990: ST_TO_ADDR
// if not depot then
60991: LD_VAR 0 9
60995: NOT
60996: IFFALSE 61000
// continue ;
60998: GO 60818
// for j in depot do
61000: LD_ADDR_VAR 0 8
61004: PUSH
61005: LD_VAR 0 9
61009: PUSH
61010: FOR_IN
61011: IFFALSE 61105
// if GetDistUnitXY ( j , x , y ) < 30 then
61013: LD_VAR 0 8
61017: PPUSH
61018: LD_VAR 0 2
61022: PPUSH
61023: LD_VAR 0 3
61027: PPUSH
61028: CALL_OW 297
61032: PUSH
61033: LD_INT 30
61035: LESS
61036: IFFALSE 61103
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61038: LD_ADDR_EXP 117
61042: PUSH
61043: LD_EXP 117
61047: PPUSH
61048: LD_VAR 0 7
61052: PUSH
61053: LD_EXP 117
61057: PUSH
61058: LD_VAR 0 7
61062: ARRAY
61063: PUSH
61064: LD_INT 1
61066: PLUS
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PPUSH
61072: LD_VAR 0 4
61076: PUSH
61077: LD_VAR 0 2
61081: PUSH
61082: LD_VAR 0 3
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: LIST
61091: PPUSH
61092: CALL 71609 0 3
61096: ST_TO_ADDR
// exit ;
61097: POP
61098: POP
61099: POP
61100: POP
61101: GO 61111
// end ;
61103: GO 61010
61105: POP
61106: POP
// end ;
61107: GO 60818
61109: POP
61110: POP
// end ;
61111: LD_VAR 0 6
61115: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61116: LD_INT 0
61118: PPUSH
61119: PPUSH
61120: PPUSH
61121: PPUSH
// if not mc_bases or not skirmish then
61122: LD_EXP 101
61126: NOT
61127: PUSH
61128: LD_EXP 99
61132: NOT
61133: OR
61134: IFFALSE 61138
// exit ;
61136: GO 61415
// side := GetSide ( lab ) ;
61138: LD_ADDR_VAR 0 4
61142: PUSH
61143: LD_VAR 0 2
61147: PPUSH
61148: CALL_OW 255
61152: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61153: LD_VAR 0 4
61157: PUSH
61158: LD_EXP 127
61162: IN
61163: NOT
61164: PUSH
61165: LD_EXP 128
61169: NOT
61170: OR
61171: PUSH
61172: LD_EXP 101
61176: NOT
61177: OR
61178: IFFALSE 61182
// exit ;
61180: GO 61415
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61182: LD_ADDR_EXP 128
61186: PUSH
61187: LD_EXP 128
61191: PPUSH
61192: LD_VAR 0 4
61196: PPUSH
61197: LD_EXP 128
61201: PUSH
61202: LD_VAR 0 4
61206: ARRAY
61207: PUSH
61208: LD_VAR 0 1
61212: DIFF
61213: PPUSH
61214: CALL_OW 1
61218: ST_TO_ADDR
// for i = 1 to mc_bases do
61219: LD_ADDR_VAR 0 5
61223: PUSH
61224: DOUBLE
61225: LD_INT 1
61227: DEC
61228: ST_TO_ADDR
61229: LD_EXP 101
61233: PUSH
61234: FOR_TO
61235: IFFALSE 61413
// begin if lab in mc_bases [ i ] then
61237: LD_VAR 0 2
61241: PUSH
61242: LD_EXP 101
61246: PUSH
61247: LD_VAR 0 5
61251: ARRAY
61252: IN
61253: IFFALSE 61411
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61255: LD_VAR 0 1
61259: PUSH
61260: LD_INT 11
61262: PUSH
61263: LD_INT 4
61265: PUSH
61266: LD_INT 3
61268: PUSH
61269: LD_INT 2
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: LIST
61276: LIST
61277: IN
61278: PUSH
61279: LD_EXP 131
61283: PUSH
61284: LD_VAR 0 5
61288: ARRAY
61289: AND
61290: IFFALSE 61411
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61292: LD_ADDR_VAR 0 6
61296: PUSH
61297: LD_EXP 131
61301: PUSH
61302: LD_VAR 0 5
61306: ARRAY
61307: PUSH
61308: LD_INT 1
61310: ARRAY
61311: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61312: LD_ADDR_EXP 131
61316: PUSH
61317: LD_EXP 131
61321: PPUSH
61322: LD_VAR 0 5
61326: PPUSH
61327: EMPTY
61328: PPUSH
61329: CALL_OW 1
61333: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61334: LD_VAR 0 6
61338: PPUSH
61339: LD_INT 0
61341: PPUSH
61342: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61346: LD_VAR 0 6
61350: PPUSH
61351: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61355: LD_ADDR_EXP 130
61359: PUSH
61360: LD_EXP 130
61364: PPUSH
61365: LD_VAR 0 5
61369: PPUSH
61370: LD_EXP 130
61374: PUSH
61375: LD_VAR 0 5
61379: ARRAY
61380: PPUSH
61381: LD_INT 1
61383: PPUSH
61384: LD_VAR 0 6
61388: PPUSH
61389: CALL_OW 2
61393: PPUSH
61394: CALL_OW 1
61398: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61399: LD_VAR 0 5
61403: PPUSH
61404: LD_INT 112
61406: PPUSH
61407: CALL 38307 0 2
// end ; end ; end ;
61411: GO 61234
61413: POP
61414: POP
// end ;
61415: LD_VAR 0 3
61419: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61420: LD_INT 0
61422: PPUSH
61423: PPUSH
61424: PPUSH
61425: PPUSH
61426: PPUSH
61427: PPUSH
61428: PPUSH
61429: PPUSH
// if not mc_bases or not skirmish then
61430: LD_EXP 101
61434: NOT
61435: PUSH
61436: LD_EXP 99
61440: NOT
61441: OR
61442: IFFALSE 61446
// exit ;
61444: GO 62817
// for i = 1 to mc_bases do
61446: LD_ADDR_VAR 0 3
61450: PUSH
61451: DOUBLE
61452: LD_INT 1
61454: DEC
61455: ST_TO_ADDR
61456: LD_EXP 101
61460: PUSH
61461: FOR_TO
61462: IFFALSE 62815
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61464: LD_VAR 0 1
61468: PUSH
61469: LD_EXP 101
61473: PUSH
61474: LD_VAR 0 3
61478: ARRAY
61479: IN
61480: PUSH
61481: LD_VAR 0 1
61485: PUSH
61486: LD_EXP 108
61490: PUSH
61491: LD_VAR 0 3
61495: ARRAY
61496: IN
61497: OR
61498: PUSH
61499: LD_VAR 0 1
61503: PUSH
61504: LD_EXP 123
61508: PUSH
61509: LD_VAR 0 3
61513: ARRAY
61514: IN
61515: OR
61516: PUSH
61517: LD_VAR 0 1
61521: PUSH
61522: LD_EXP 120
61526: PUSH
61527: LD_VAR 0 3
61531: ARRAY
61532: IN
61533: OR
61534: PUSH
61535: LD_VAR 0 1
61539: PUSH
61540: LD_EXP 130
61544: PUSH
61545: LD_VAR 0 3
61549: ARRAY
61550: IN
61551: OR
61552: PUSH
61553: LD_VAR 0 1
61557: PUSH
61558: LD_EXP 131
61562: PUSH
61563: LD_VAR 0 3
61567: ARRAY
61568: IN
61569: OR
61570: IFFALSE 62813
// begin if un in mc_ape [ i ] then
61572: LD_VAR 0 1
61576: PUSH
61577: LD_EXP 130
61581: PUSH
61582: LD_VAR 0 3
61586: ARRAY
61587: IN
61588: IFFALSE 61627
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61590: LD_ADDR_EXP 130
61594: PUSH
61595: LD_EXP 130
61599: PPUSH
61600: LD_VAR 0 3
61604: PPUSH
61605: LD_EXP 130
61609: PUSH
61610: LD_VAR 0 3
61614: ARRAY
61615: PUSH
61616: LD_VAR 0 1
61620: DIFF
61621: PPUSH
61622: CALL_OW 1
61626: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61627: LD_VAR 0 1
61631: PUSH
61632: LD_EXP 131
61636: PUSH
61637: LD_VAR 0 3
61641: ARRAY
61642: IN
61643: IFFALSE 61667
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61645: LD_ADDR_EXP 131
61649: PUSH
61650: LD_EXP 131
61654: PPUSH
61655: LD_VAR 0 3
61659: PPUSH
61660: EMPTY
61661: PPUSH
61662: CALL_OW 1
61666: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61667: LD_VAR 0 1
61671: PPUSH
61672: CALL_OW 247
61676: PUSH
61677: LD_INT 2
61679: EQUAL
61680: PUSH
61681: LD_VAR 0 1
61685: PPUSH
61686: CALL_OW 110
61690: PUSH
61691: LD_INT 20
61693: EQUAL
61694: PUSH
61695: LD_VAR 0 1
61699: PUSH
61700: LD_EXP 123
61704: PUSH
61705: LD_VAR 0 3
61709: ARRAY
61710: IN
61711: OR
61712: PUSH
61713: LD_VAR 0 1
61717: PPUSH
61718: CALL_OW 264
61722: PUSH
61723: LD_INT 12
61725: PUSH
61726: LD_INT 51
61728: PUSH
61729: LD_EXP 95
61733: PUSH
61734: LD_INT 32
61736: PUSH
61737: LD_INT 13
61739: PUSH
61740: LD_INT 52
61742: PUSH
61743: LD_INT 31
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: IN
61755: OR
61756: AND
61757: IFFALSE 62065
// begin if un in mc_defender [ i ] then
61759: LD_VAR 0 1
61763: PUSH
61764: LD_EXP 123
61768: PUSH
61769: LD_VAR 0 3
61773: ARRAY
61774: IN
61775: IFFALSE 61814
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61777: LD_ADDR_EXP 123
61781: PUSH
61782: LD_EXP 123
61786: PPUSH
61787: LD_VAR 0 3
61791: PPUSH
61792: LD_EXP 123
61796: PUSH
61797: LD_VAR 0 3
61801: ARRAY
61802: PUSH
61803: LD_VAR 0 1
61807: DIFF
61808: PPUSH
61809: CALL_OW 1
61813: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61814: LD_ADDR_VAR 0 8
61818: PUSH
61819: LD_VAR 0 3
61823: PPUSH
61824: LD_INT 3
61826: PPUSH
61827: CALL 58483 0 2
61831: ST_TO_ADDR
// if fac then
61832: LD_VAR 0 8
61836: IFFALSE 62065
// begin for j in fac do
61838: LD_ADDR_VAR 0 4
61842: PUSH
61843: LD_VAR 0 8
61847: PUSH
61848: FOR_IN
61849: IFFALSE 62063
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61851: LD_ADDR_VAR 0 9
61855: PUSH
61856: LD_VAR 0 8
61860: PPUSH
61861: LD_VAR 0 1
61865: PPUSH
61866: CALL_OW 265
61870: PPUSH
61871: LD_VAR 0 1
61875: PPUSH
61876: CALL_OW 262
61880: PPUSH
61881: LD_VAR 0 1
61885: PPUSH
61886: CALL_OW 263
61890: PPUSH
61891: LD_VAR 0 1
61895: PPUSH
61896: CALL_OW 264
61900: PPUSH
61901: CALL 69141 0 5
61905: ST_TO_ADDR
// if components then
61906: LD_VAR 0 9
61910: IFFALSE 62061
// begin if GetWeapon ( un ) = ar_control_tower then
61912: LD_VAR 0 1
61916: PPUSH
61917: CALL_OW 264
61921: PUSH
61922: LD_INT 31
61924: EQUAL
61925: IFFALSE 62042
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61927: LD_VAR 0 1
61931: PPUSH
61932: CALL_OW 311
61936: PPUSH
61937: LD_INT 0
61939: PPUSH
61940: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61944: LD_ADDR_EXP 141
61948: PUSH
61949: LD_EXP 141
61953: PPUSH
61954: LD_VAR 0 3
61958: PPUSH
61959: LD_EXP 141
61963: PUSH
61964: LD_VAR 0 3
61968: ARRAY
61969: PUSH
61970: LD_VAR 0 1
61974: PPUSH
61975: CALL_OW 311
61979: DIFF
61980: PPUSH
61981: CALL_OW 1
61985: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61986: LD_ADDR_VAR 0 7
61990: PUSH
61991: LD_EXP 122
61995: PUSH
61996: LD_VAR 0 3
62000: ARRAY
62001: PPUSH
62002: LD_INT 1
62004: PPUSH
62005: LD_VAR 0 9
62009: PPUSH
62010: CALL_OW 2
62014: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62015: LD_ADDR_EXP 122
62019: PUSH
62020: LD_EXP 122
62024: PPUSH
62025: LD_VAR 0 3
62029: PPUSH
62030: LD_VAR 0 7
62034: PPUSH
62035: CALL_OW 1
62039: ST_TO_ADDR
// end else
62040: GO 62059
// MC_InsertProduceList ( i , [ components ] ) ;
62042: LD_VAR 0 3
62046: PPUSH
62047: LD_VAR 0 9
62051: PUSH
62052: EMPTY
62053: LIST
62054: PPUSH
62055: CALL 58028 0 2
// break ;
62059: GO 62063
// end ; end ;
62061: GO 61848
62063: POP
62064: POP
// end ; end ; if GetType ( un ) = unit_building then
62065: LD_VAR 0 1
62069: PPUSH
62070: CALL_OW 247
62074: PUSH
62075: LD_INT 3
62077: EQUAL
62078: IFFALSE 62481
// begin btype := GetBType ( un ) ;
62080: LD_ADDR_VAR 0 5
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 266
62094: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62095: LD_VAR 0 5
62099: PUSH
62100: LD_INT 29
62102: PUSH
62103: LD_INT 30
62105: PUSH
62106: EMPTY
62107: LIST
62108: LIST
62109: IN
62110: IFFALSE 62183
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62112: LD_VAR 0 1
62116: PPUSH
62117: CALL_OW 250
62121: PPUSH
62122: LD_VAR 0 1
62126: PPUSH
62127: CALL_OW 251
62131: PPUSH
62132: LD_VAR 0 1
62136: PPUSH
62137: CALL_OW 255
62141: PPUSH
62142: CALL_OW 440
62146: NOT
62147: IFFALSE 62183
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62149: LD_VAR 0 1
62153: PPUSH
62154: CALL_OW 250
62158: PPUSH
62159: LD_VAR 0 1
62163: PPUSH
62164: CALL_OW 251
62168: PPUSH
62169: LD_VAR 0 1
62173: PPUSH
62174: CALL_OW 255
62178: PPUSH
62179: CALL_OW 441
// end ; if btype = b_warehouse then
62183: LD_VAR 0 5
62187: PUSH
62188: LD_INT 1
62190: EQUAL
62191: IFFALSE 62209
// begin btype := b_depot ;
62193: LD_ADDR_VAR 0 5
62197: PUSH
62198: LD_INT 0
62200: ST_TO_ADDR
// pos := 1 ;
62201: LD_ADDR_VAR 0 6
62205: PUSH
62206: LD_INT 1
62208: ST_TO_ADDR
// end ; if btype = b_factory then
62209: LD_VAR 0 5
62213: PUSH
62214: LD_INT 3
62216: EQUAL
62217: IFFALSE 62235
// begin btype := b_workshop ;
62219: LD_ADDR_VAR 0 5
62223: PUSH
62224: LD_INT 2
62226: ST_TO_ADDR
// pos := 1 ;
62227: LD_ADDR_VAR 0 6
62231: PUSH
62232: LD_INT 1
62234: ST_TO_ADDR
// end ; if btype = b_barracks then
62235: LD_VAR 0 5
62239: PUSH
62240: LD_INT 5
62242: EQUAL
62243: IFFALSE 62253
// btype := b_armoury ;
62245: LD_ADDR_VAR 0 5
62249: PUSH
62250: LD_INT 4
62252: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62253: LD_VAR 0 5
62257: PUSH
62258: LD_INT 7
62260: PUSH
62261: LD_INT 8
62263: PUSH
62264: EMPTY
62265: LIST
62266: LIST
62267: IN
62268: IFFALSE 62278
// btype := b_lab ;
62270: LD_ADDR_VAR 0 5
62274: PUSH
62275: LD_INT 6
62277: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62278: LD_ADDR_EXP 106
62282: PUSH
62283: LD_EXP 106
62287: PPUSH
62288: LD_VAR 0 3
62292: PUSH
62293: LD_EXP 106
62297: PUSH
62298: LD_VAR 0 3
62302: ARRAY
62303: PUSH
62304: LD_INT 1
62306: PLUS
62307: PUSH
62308: EMPTY
62309: LIST
62310: LIST
62311: PPUSH
62312: LD_VAR 0 5
62316: PUSH
62317: LD_VAR 0 1
62321: PPUSH
62322: CALL_OW 250
62326: PUSH
62327: LD_VAR 0 1
62331: PPUSH
62332: CALL_OW 251
62336: PUSH
62337: LD_VAR 0 1
62341: PPUSH
62342: CALL_OW 254
62346: PUSH
62347: EMPTY
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: PPUSH
62353: CALL 71609 0 3
62357: ST_TO_ADDR
// if pos = 1 then
62358: LD_VAR 0 6
62362: PUSH
62363: LD_INT 1
62365: EQUAL
62366: IFFALSE 62481
// begin tmp := mc_build_list [ i ] ;
62368: LD_ADDR_VAR 0 7
62372: PUSH
62373: LD_EXP 106
62377: PUSH
62378: LD_VAR 0 3
62382: ARRAY
62383: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62384: LD_VAR 0 7
62388: PPUSH
62389: LD_INT 2
62391: PUSH
62392: LD_INT 30
62394: PUSH
62395: LD_INT 0
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: PUSH
62402: LD_INT 30
62404: PUSH
62405: LD_INT 1
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: LIST
62416: PPUSH
62417: CALL_OW 72
62421: IFFALSE 62431
// pos := 2 ;
62423: LD_ADDR_VAR 0 6
62427: PUSH
62428: LD_INT 2
62430: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62431: LD_ADDR_VAR 0 7
62435: PUSH
62436: LD_VAR 0 7
62440: PPUSH
62441: LD_VAR 0 6
62445: PPUSH
62446: LD_VAR 0 7
62450: PPUSH
62451: CALL 71935 0 3
62455: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62456: LD_ADDR_EXP 106
62460: PUSH
62461: LD_EXP 106
62465: PPUSH
62466: LD_VAR 0 3
62470: PPUSH
62471: LD_VAR 0 7
62475: PPUSH
62476: CALL_OW 1
62480: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62481: LD_VAR 0 1
62485: PUSH
62486: LD_EXP 101
62490: PUSH
62491: LD_VAR 0 3
62495: ARRAY
62496: IN
62497: IFFALSE 62536
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62499: LD_ADDR_EXP 101
62503: PUSH
62504: LD_EXP 101
62508: PPUSH
62509: LD_VAR 0 3
62513: PPUSH
62514: LD_EXP 101
62518: PUSH
62519: LD_VAR 0 3
62523: ARRAY
62524: PUSH
62525: LD_VAR 0 1
62529: DIFF
62530: PPUSH
62531: CALL_OW 1
62535: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62536: LD_VAR 0 1
62540: PUSH
62541: LD_EXP 108
62545: PUSH
62546: LD_VAR 0 3
62550: ARRAY
62551: IN
62552: IFFALSE 62591
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62554: LD_ADDR_EXP 108
62558: PUSH
62559: LD_EXP 108
62563: PPUSH
62564: LD_VAR 0 3
62568: PPUSH
62569: LD_EXP 108
62573: PUSH
62574: LD_VAR 0 3
62578: ARRAY
62579: PUSH
62580: LD_VAR 0 1
62584: DIFF
62585: PPUSH
62586: CALL_OW 1
62590: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62591: LD_VAR 0 1
62595: PUSH
62596: LD_EXP 120
62600: PUSH
62601: LD_VAR 0 3
62605: ARRAY
62606: IN
62607: IFFALSE 62646
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62609: LD_ADDR_EXP 120
62613: PUSH
62614: LD_EXP 120
62618: PPUSH
62619: LD_VAR 0 3
62623: PPUSH
62624: LD_EXP 120
62628: PUSH
62629: LD_VAR 0 3
62633: ARRAY
62634: PUSH
62635: LD_VAR 0 1
62639: DIFF
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62646: LD_VAR 0 1
62650: PUSH
62651: LD_EXP 123
62655: PUSH
62656: LD_VAR 0 3
62660: ARRAY
62661: IN
62662: IFFALSE 62701
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62664: LD_ADDR_EXP 123
62668: PUSH
62669: LD_EXP 123
62673: PPUSH
62674: LD_VAR 0 3
62678: PPUSH
62679: LD_EXP 123
62683: PUSH
62684: LD_VAR 0 3
62688: ARRAY
62689: PUSH
62690: LD_VAR 0 1
62694: DIFF
62695: PPUSH
62696: CALL_OW 1
62700: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62701: LD_VAR 0 1
62705: PUSH
62706: LD_EXP 110
62710: PUSH
62711: LD_VAR 0 3
62715: ARRAY
62716: IN
62717: IFFALSE 62756
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62719: LD_ADDR_EXP 110
62723: PUSH
62724: LD_EXP 110
62728: PPUSH
62729: LD_VAR 0 3
62733: PPUSH
62734: LD_EXP 110
62738: PUSH
62739: LD_VAR 0 3
62743: ARRAY
62744: PUSH
62745: LD_VAR 0 1
62749: DIFF
62750: PPUSH
62751: CALL_OW 1
62755: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62756: LD_VAR 0 1
62760: PUSH
62761: LD_EXP 109
62765: PUSH
62766: LD_VAR 0 3
62770: ARRAY
62771: IN
62772: IFFALSE 62811
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62774: LD_ADDR_EXP 109
62778: PUSH
62779: LD_EXP 109
62783: PPUSH
62784: LD_VAR 0 3
62788: PPUSH
62789: LD_EXP 109
62793: PUSH
62794: LD_VAR 0 3
62798: ARRAY
62799: PUSH
62800: LD_VAR 0 1
62804: DIFF
62805: PPUSH
62806: CALL_OW 1
62810: ST_TO_ADDR
// end ; break ;
62811: GO 62815
// end ;
62813: GO 61461
62815: POP
62816: POP
// end ;
62817: LD_VAR 0 2
62821: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62822: LD_INT 0
62824: PPUSH
62825: PPUSH
62826: PPUSH
// if not mc_bases or not skirmish then
62827: LD_EXP 101
62831: NOT
62832: PUSH
62833: LD_EXP 99
62837: NOT
62838: OR
62839: IFFALSE 62843
// exit ;
62841: GO 63058
// for i = 1 to mc_bases do
62843: LD_ADDR_VAR 0 3
62847: PUSH
62848: DOUBLE
62849: LD_INT 1
62851: DEC
62852: ST_TO_ADDR
62853: LD_EXP 101
62857: PUSH
62858: FOR_TO
62859: IFFALSE 63056
// begin if building in mc_construct_list [ i ] then
62861: LD_VAR 0 1
62865: PUSH
62866: LD_EXP 108
62870: PUSH
62871: LD_VAR 0 3
62875: ARRAY
62876: IN
62877: IFFALSE 63054
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62879: LD_ADDR_EXP 108
62883: PUSH
62884: LD_EXP 108
62888: PPUSH
62889: LD_VAR 0 3
62893: PPUSH
62894: LD_EXP 108
62898: PUSH
62899: LD_VAR 0 3
62903: ARRAY
62904: PUSH
62905: LD_VAR 0 1
62909: DIFF
62910: PPUSH
62911: CALL_OW 1
62915: ST_TO_ADDR
// if building in mc_lab [ i ] then
62916: LD_VAR 0 1
62920: PUSH
62921: LD_EXP 134
62925: PUSH
62926: LD_VAR 0 3
62930: ARRAY
62931: IN
62932: IFFALSE 62987
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62934: LD_ADDR_EXP 135
62938: PUSH
62939: LD_EXP 135
62943: PPUSH
62944: LD_VAR 0 3
62948: PPUSH
62949: LD_EXP 135
62953: PUSH
62954: LD_VAR 0 3
62958: ARRAY
62959: PPUSH
62960: LD_INT 1
62962: PPUSH
62963: LD_EXP 135
62967: PUSH
62968: LD_VAR 0 3
62972: ARRAY
62973: PPUSH
62974: LD_INT 0
62976: PPUSH
62977: CALL 71027 0 4
62981: PPUSH
62982: CALL_OW 1
62986: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62987: LD_VAR 0 1
62991: PUSH
62992: LD_EXP 101
62996: PUSH
62997: LD_VAR 0 3
63001: ARRAY
63002: IN
63003: NOT
63004: IFFALSE 63050
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63006: LD_ADDR_EXP 101
63010: PUSH
63011: LD_EXP 101
63015: PPUSH
63016: LD_VAR 0 3
63020: PUSH
63021: LD_EXP 101
63025: PUSH
63026: LD_VAR 0 3
63030: ARRAY
63031: PUSH
63032: LD_INT 1
63034: PLUS
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PPUSH
63040: LD_VAR 0 1
63044: PPUSH
63045: CALL 71609 0 3
63049: ST_TO_ADDR
// exit ;
63050: POP
63051: POP
63052: GO 63058
// end ; end ;
63054: GO 62858
63056: POP
63057: POP
// end ;
63058: LD_VAR 0 2
63062: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63063: LD_INT 0
63065: PPUSH
63066: PPUSH
63067: PPUSH
63068: PPUSH
63069: PPUSH
63070: PPUSH
63071: PPUSH
// if not mc_bases or not skirmish then
63072: LD_EXP 101
63076: NOT
63077: PUSH
63078: LD_EXP 99
63082: NOT
63083: OR
63084: IFFALSE 63088
// exit ;
63086: GO 63749
// for i = 1 to mc_bases do
63088: LD_ADDR_VAR 0 3
63092: PUSH
63093: DOUBLE
63094: LD_INT 1
63096: DEC
63097: ST_TO_ADDR
63098: LD_EXP 101
63102: PUSH
63103: FOR_TO
63104: IFFALSE 63747
// begin if building in mc_construct_list [ i ] then
63106: LD_VAR 0 1
63110: PUSH
63111: LD_EXP 108
63115: PUSH
63116: LD_VAR 0 3
63120: ARRAY
63121: IN
63122: IFFALSE 63745
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63124: LD_ADDR_EXP 108
63128: PUSH
63129: LD_EXP 108
63133: PPUSH
63134: LD_VAR 0 3
63138: PPUSH
63139: LD_EXP 108
63143: PUSH
63144: LD_VAR 0 3
63148: ARRAY
63149: PUSH
63150: LD_VAR 0 1
63154: DIFF
63155: PPUSH
63156: CALL_OW 1
63160: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63161: LD_ADDR_EXP 101
63165: PUSH
63166: LD_EXP 101
63170: PPUSH
63171: LD_VAR 0 3
63175: PUSH
63176: LD_EXP 101
63180: PUSH
63181: LD_VAR 0 3
63185: ARRAY
63186: PUSH
63187: LD_INT 1
63189: PLUS
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PPUSH
63195: LD_VAR 0 1
63199: PPUSH
63200: CALL 71609 0 3
63204: ST_TO_ADDR
// btype := GetBType ( building ) ;
63205: LD_ADDR_VAR 0 5
63209: PUSH
63210: LD_VAR 0 1
63214: PPUSH
63215: CALL_OW 266
63219: ST_TO_ADDR
// side := GetSide ( building ) ;
63220: LD_ADDR_VAR 0 8
63224: PUSH
63225: LD_VAR 0 1
63229: PPUSH
63230: CALL_OW 255
63234: ST_TO_ADDR
// if btype = b_lab then
63235: LD_VAR 0 5
63239: PUSH
63240: LD_INT 6
63242: EQUAL
63243: IFFALSE 63293
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63245: LD_ADDR_EXP 134
63249: PUSH
63250: LD_EXP 134
63254: PPUSH
63255: LD_VAR 0 3
63259: PUSH
63260: LD_EXP 134
63264: PUSH
63265: LD_VAR 0 3
63269: ARRAY
63270: PUSH
63271: LD_INT 1
63273: PLUS
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PPUSH
63279: LD_VAR 0 1
63283: PPUSH
63284: CALL 71609 0 3
63288: ST_TO_ADDR
// exit ;
63289: POP
63290: POP
63291: GO 63749
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63293: LD_VAR 0 5
63297: PUSH
63298: LD_INT 0
63300: PUSH
63301: LD_INT 2
63303: PUSH
63304: LD_INT 4
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: LIST
63311: IN
63312: IFFALSE 63436
// begin if btype = b_armoury then
63314: LD_VAR 0 5
63318: PUSH
63319: LD_INT 4
63321: EQUAL
63322: IFFALSE 63332
// btype := b_barracks ;
63324: LD_ADDR_VAR 0 5
63328: PUSH
63329: LD_INT 5
63331: ST_TO_ADDR
// if btype = b_depot then
63332: LD_VAR 0 5
63336: PUSH
63337: LD_INT 0
63339: EQUAL
63340: IFFALSE 63350
// btype := b_warehouse ;
63342: LD_ADDR_VAR 0 5
63346: PUSH
63347: LD_INT 1
63349: ST_TO_ADDR
// if btype = b_workshop then
63350: LD_VAR 0 5
63354: PUSH
63355: LD_INT 2
63357: EQUAL
63358: IFFALSE 63368
// btype := b_factory ;
63360: LD_ADDR_VAR 0 5
63364: PUSH
63365: LD_INT 3
63367: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63368: LD_VAR 0 5
63372: PPUSH
63373: LD_VAR 0 8
63377: PPUSH
63378: CALL_OW 323
63382: PUSH
63383: LD_INT 1
63385: EQUAL
63386: IFFALSE 63432
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63388: LD_ADDR_EXP 133
63392: PUSH
63393: LD_EXP 133
63397: PPUSH
63398: LD_VAR 0 3
63402: PUSH
63403: LD_EXP 133
63407: PUSH
63408: LD_VAR 0 3
63412: ARRAY
63413: PUSH
63414: LD_INT 1
63416: PLUS
63417: PUSH
63418: EMPTY
63419: LIST
63420: LIST
63421: PPUSH
63422: LD_VAR 0 1
63426: PPUSH
63427: CALL 71609 0 3
63431: ST_TO_ADDR
// exit ;
63432: POP
63433: POP
63434: GO 63749
// end ; if btype in [ b_bunker , b_turret ] then
63436: LD_VAR 0 5
63440: PUSH
63441: LD_INT 32
63443: PUSH
63444: LD_INT 33
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: IN
63451: IFFALSE 63741
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63453: LD_ADDR_EXP 109
63457: PUSH
63458: LD_EXP 109
63462: PPUSH
63463: LD_VAR 0 3
63467: PUSH
63468: LD_EXP 109
63472: PUSH
63473: LD_VAR 0 3
63477: ARRAY
63478: PUSH
63479: LD_INT 1
63481: PLUS
63482: PUSH
63483: EMPTY
63484: LIST
63485: LIST
63486: PPUSH
63487: LD_VAR 0 1
63491: PPUSH
63492: CALL 71609 0 3
63496: ST_TO_ADDR
// if btype = b_bunker then
63497: LD_VAR 0 5
63501: PUSH
63502: LD_INT 32
63504: EQUAL
63505: IFFALSE 63741
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63507: LD_ADDR_EXP 110
63511: PUSH
63512: LD_EXP 110
63516: PPUSH
63517: LD_VAR 0 3
63521: PUSH
63522: LD_EXP 110
63526: PUSH
63527: LD_VAR 0 3
63531: ARRAY
63532: PUSH
63533: LD_INT 1
63535: PLUS
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: PPUSH
63541: LD_VAR 0 1
63545: PPUSH
63546: CALL 71609 0 3
63550: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63551: LD_ADDR_VAR 0 6
63555: PUSH
63556: LD_EXP 101
63560: PUSH
63561: LD_VAR 0 3
63565: ARRAY
63566: PPUSH
63567: LD_INT 25
63569: PUSH
63570: LD_INT 1
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 3
63579: PUSH
63580: LD_INT 54
63582: PUSH
63583: EMPTY
63584: LIST
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PPUSH
63594: CALL_OW 72
63598: ST_TO_ADDR
// if tmp then
63599: LD_VAR 0 6
63603: IFFALSE 63609
// exit ;
63605: POP
63606: POP
63607: GO 63749
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63609: LD_ADDR_VAR 0 6
63613: PUSH
63614: LD_EXP 101
63618: PUSH
63619: LD_VAR 0 3
63623: ARRAY
63624: PPUSH
63625: LD_INT 2
63627: PUSH
63628: LD_INT 30
63630: PUSH
63631: LD_INT 4
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: PUSH
63638: LD_INT 30
63640: PUSH
63641: LD_INT 5
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: LIST
63652: PPUSH
63653: CALL_OW 72
63657: ST_TO_ADDR
// if not tmp then
63658: LD_VAR 0 6
63662: NOT
63663: IFFALSE 63669
// exit ;
63665: POP
63666: POP
63667: GO 63749
// for j in tmp do
63669: LD_ADDR_VAR 0 4
63673: PUSH
63674: LD_VAR 0 6
63678: PUSH
63679: FOR_IN
63680: IFFALSE 63739
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63682: LD_ADDR_VAR 0 7
63686: PUSH
63687: LD_VAR 0 4
63691: PPUSH
63692: CALL_OW 313
63696: PPUSH
63697: LD_INT 25
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PPUSH
63707: CALL_OW 72
63711: ST_TO_ADDR
// if units then
63712: LD_VAR 0 7
63716: IFFALSE 63737
// begin ComExitBuilding ( units [ 1 ] ) ;
63718: LD_VAR 0 7
63722: PUSH
63723: LD_INT 1
63725: ARRAY
63726: PPUSH
63727: CALL_OW 122
// exit ;
63731: POP
63732: POP
63733: POP
63734: POP
63735: GO 63749
// end ; end ;
63737: GO 63679
63739: POP
63740: POP
// end ; end ; exit ;
63741: POP
63742: POP
63743: GO 63749
// end ; end ;
63745: GO 63103
63747: POP
63748: POP
// end ;
63749: LD_VAR 0 2
63753: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63754: LD_INT 0
63756: PPUSH
63757: PPUSH
63758: PPUSH
63759: PPUSH
63760: PPUSH
63761: PPUSH
63762: PPUSH
// if not mc_bases or not skirmish then
63763: LD_EXP 101
63767: NOT
63768: PUSH
63769: LD_EXP 99
63773: NOT
63774: OR
63775: IFFALSE 63779
// exit ;
63777: GO 64010
// btype := GetBType ( building ) ;
63779: LD_ADDR_VAR 0 6
63783: PUSH
63784: LD_VAR 0 1
63788: PPUSH
63789: CALL_OW 266
63793: ST_TO_ADDR
// x := GetX ( building ) ;
63794: LD_ADDR_VAR 0 7
63798: PUSH
63799: LD_VAR 0 1
63803: PPUSH
63804: CALL_OW 250
63808: ST_TO_ADDR
// y := GetY ( building ) ;
63809: LD_ADDR_VAR 0 8
63813: PUSH
63814: LD_VAR 0 1
63818: PPUSH
63819: CALL_OW 251
63823: ST_TO_ADDR
// d := GetDir ( building ) ;
63824: LD_ADDR_VAR 0 9
63828: PUSH
63829: LD_VAR 0 1
63833: PPUSH
63834: CALL_OW 254
63838: ST_TO_ADDR
// for i = 1 to mc_bases do
63839: LD_ADDR_VAR 0 4
63843: PUSH
63844: DOUBLE
63845: LD_INT 1
63847: DEC
63848: ST_TO_ADDR
63849: LD_EXP 101
63853: PUSH
63854: FOR_TO
63855: IFFALSE 64008
// begin if not mc_build_list [ i ] then
63857: LD_EXP 106
63861: PUSH
63862: LD_VAR 0 4
63866: ARRAY
63867: NOT
63868: IFFALSE 63872
// continue ;
63870: GO 63854
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63872: LD_VAR 0 6
63876: PUSH
63877: LD_VAR 0 7
63881: PUSH
63882: LD_VAR 0 8
63886: PUSH
63887: LD_VAR 0 9
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: PPUSH
63898: LD_EXP 106
63902: PUSH
63903: LD_VAR 0 4
63907: ARRAY
63908: PUSH
63909: LD_INT 1
63911: ARRAY
63912: PPUSH
63913: CALL 77778 0 2
63917: IFFALSE 64006
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63919: LD_ADDR_EXP 106
63923: PUSH
63924: LD_EXP 106
63928: PPUSH
63929: LD_VAR 0 4
63933: PPUSH
63934: LD_EXP 106
63938: PUSH
63939: LD_VAR 0 4
63943: ARRAY
63944: PPUSH
63945: LD_INT 1
63947: PPUSH
63948: CALL_OW 3
63952: PPUSH
63953: CALL_OW 1
63957: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63958: LD_ADDR_EXP 108
63962: PUSH
63963: LD_EXP 108
63967: PPUSH
63968: LD_VAR 0 4
63972: PUSH
63973: LD_EXP 108
63977: PUSH
63978: LD_VAR 0 4
63982: ARRAY
63983: PUSH
63984: LD_INT 1
63986: PLUS
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PPUSH
63992: LD_VAR 0 1
63996: PPUSH
63997: CALL 71609 0 3
64001: ST_TO_ADDR
// exit ;
64002: POP
64003: POP
64004: GO 64010
// end ; end ;
64006: GO 63854
64008: POP
64009: POP
// end ;
64010: LD_VAR 0 3
64014: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64015: LD_INT 0
64017: PPUSH
64018: PPUSH
64019: PPUSH
// if not mc_bases or not skirmish then
64020: LD_EXP 101
64024: NOT
64025: PUSH
64026: LD_EXP 99
64030: NOT
64031: OR
64032: IFFALSE 64036
// exit ;
64034: GO 64226
// for i = 1 to mc_bases do
64036: LD_ADDR_VAR 0 4
64040: PUSH
64041: DOUBLE
64042: LD_INT 1
64044: DEC
64045: ST_TO_ADDR
64046: LD_EXP 101
64050: PUSH
64051: FOR_TO
64052: IFFALSE 64139
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64054: LD_VAR 0 1
64058: PUSH
64059: LD_EXP 109
64063: PUSH
64064: LD_VAR 0 4
64068: ARRAY
64069: IN
64070: PUSH
64071: LD_VAR 0 1
64075: PUSH
64076: LD_EXP 110
64080: PUSH
64081: LD_VAR 0 4
64085: ARRAY
64086: IN
64087: NOT
64088: AND
64089: IFFALSE 64137
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64091: LD_ADDR_EXP 110
64095: PUSH
64096: LD_EXP 110
64100: PPUSH
64101: LD_VAR 0 4
64105: PUSH
64106: LD_EXP 110
64110: PUSH
64111: LD_VAR 0 4
64115: ARRAY
64116: PUSH
64117: LD_INT 1
64119: PLUS
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: PPUSH
64125: LD_VAR 0 1
64129: PPUSH
64130: CALL 71609 0 3
64134: ST_TO_ADDR
// break ;
64135: GO 64139
// end ; end ;
64137: GO 64051
64139: POP
64140: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64141: LD_VAR 0 1
64145: PPUSH
64146: CALL_OW 257
64150: PUSH
64151: LD_EXP 127
64155: IN
64156: PUSH
64157: LD_VAR 0 1
64161: PPUSH
64162: CALL_OW 266
64166: PUSH
64167: LD_INT 5
64169: EQUAL
64170: AND
64171: PUSH
64172: LD_VAR 0 2
64176: PPUSH
64177: CALL_OW 110
64181: PUSH
64182: LD_INT 18
64184: NONEQUAL
64185: AND
64186: IFFALSE 64226
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64188: LD_VAR 0 2
64192: PPUSH
64193: CALL_OW 257
64197: PUSH
64198: LD_INT 5
64200: PUSH
64201: LD_INT 8
64203: PUSH
64204: LD_INT 9
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: LIST
64211: IN
64212: IFFALSE 64226
// SetClass ( unit , 1 ) ;
64214: LD_VAR 0 2
64218: PPUSH
64219: LD_INT 1
64221: PPUSH
64222: CALL_OW 336
// end ;
64226: LD_VAR 0 3
64230: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64231: LD_INT 0
64233: PPUSH
64234: PPUSH
// if not mc_bases or not skirmish then
64235: LD_EXP 101
64239: NOT
64240: PUSH
64241: LD_EXP 99
64245: NOT
64246: OR
64247: IFFALSE 64251
// exit ;
64249: GO 64367
// if GetLives ( abandoned_vehicle ) > 250 then
64251: LD_VAR 0 2
64255: PPUSH
64256: CALL_OW 256
64260: PUSH
64261: LD_INT 250
64263: GREATER
64264: IFFALSE 64268
// exit ;
64266: GO 64367
// for i = 1 to mc_bases do
64268: LD_ADDR_VAR 0 6
64272: PUSH
64273: DOUBLE
64274: LD_INT 1
64276: DEC
64277: ST_TO_ADDR
64278: LD_EXP 101
64282: PUSH
64283: FOR_TO
64284: IFFALSE 64365
// begin if driver in mc_bases [ i ] then
64286: LD_VAR 0 1
64290: PUSH
64291: LD_EXP 101
64295: PUSH
64296: LD_VAR 0 6
64300: ARRAY
64301: IN
64302: IFFALSE 64363
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64304: LD_VAR 0 1
64308: PPUSH
64309: LD_EXP 101
64313: PUSH
64314: LD_VAR 0 6
64318: ARRAY
64319: PPUSH
64320: LD_INT 2
64322: PUSH
64323: LD_INT 30
64325: PUSH
64326: LD_INT 0
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PUSH
64333: LD_INT 30
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: EMPTY
64340: LIST
64341: LIST
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: LIST
64347: PPUSH
64348: CALL_OW 72
64352: PUSH
64353: LD_INT 1
64355: ARRAY
64356: PPUSH
64357: CALL_OW 112
// break ;
64361: GO 64365
// end ; end ;
64363: GO 64283
64365: POP
64366: POP
// end ; end_of_file
64367: LD_VAR 0 5
64371: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64372: LD_INT 0
64374: PPUSH
64375: PPUSH
// if exist_mode then
64376: LD_VAR 0 2
64380: IFFALSE 64405
// unit := CreateCharacter ( prefix & ident ) else
64382: LD_ADDR_VAR 0 5
64386: PUSH
64387: LD_VAR 0 3
64391: PUSH
64392: LD_VAR 0 1
64396: STR
64397: PPUSH
64398: CALL_OW 34
64402: ST_TO_ADDR
64403: GO 64420
// unit := NewCharacter ( ident ) ;
64405: LD_ADDR_VAR 0 5
64409: PUSH
64410: LD_VAR 0 1
64414: PPUSH
64415: CALL_OW 25
64419: ST_TO_ADDR
// result := unit ;
64420: LD_ADDR_VAR 0 4
64424: PUSH
64425: LD_VAR 0 5
64429: ST_TO_ADDR
// end ;
64430: LD_VAR 0 4
64434: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64435: LD_INT 0
64437: PPUSH
64438: PPUSH
// if not side or not nation then
64439: LD_VAR 0 1
64443: NOT
64444: PUSH
64445: LD_VAR 0 2
64449: NOT
64450: OR
64451: IFFALSE 64455
// exit ;
64453: GO 65099
// case nation of nation_american :
64455: LD_VAR 0 2
64459: PUSH
64460: LD_INT 1
64462: DOUBLE
64463: EQUAL
64464: IFTRUE 64468
64466: GO 64642
64468: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64469: LD_ADDR_VAR 0 4
64473: PUSH
64474: LD_INT 35
64476: PUSH
64477: LD_INT 45
64479: PUSH
64480: LD_INT 46
64482: PUSH
64483: LD_INT 47
64485: PUSH
64486: LD_INT 1
64488: PUSH
64489: LD_INT 2
64491: PUSH
64492: LD_INT 6
64494: PUSH
64495: LD_INT 15
64497: PUSH
64498: LD_INT 16
64500: PUSH
64501: LD_INT 7
64503: PUSH
64504: LD_INT 12
64506: PUSH
64507: LD_INT 13
64509: PUSH
64510: LD_INT 10
64512: PUSH
64513: LD_INT 14
64515: PUSH
64516: LD_INT 20
64518: PUSH
64519: LD_INT 21
64521: PUSH
64522: LD_INT 22
64524: PUSH
64525: LD_INT 25
64527: PUSH
64528: LD_INT 32
64530: PUSH
64531: LD_INT 27
64533: PUSH
64534: LD_INT 36
64536: PUSH
64537: LD_INT 69
64539: PUSH
64540: LD_INT 39
64542: PUSH
64543: LD_INT 34
64545: PUSH
64546: LD_INT 40
64548: PUSH
64549: LD_INT 48
64551: PUSH
64552: LD_INT 49
64554: PUSH
64555: LD_INT 50
64557: PUSH
64558: LD_INT 51
64560: PUSH
64561: LD_INT 52
64563: PUSH
64564: LD_INT 53
64566: PUSH
64567: LD_INT 54
64569: PUSH
64570: LD_INT 55
64572: PUSH
64573: LD_INT 56
64575: PUSH
64576: LD_INT 57
64578: PUSH
64579: LD_INT 58
64581: PUSH
64582: LD_INT 59
64584: PUSH
64585: LD_INT 60
64587: PUSH
64588: LD_INT 61
64590: PUSH
64591: LD_INT 62
64593: PUSH
64594: LD_INT 80
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: ST_TO_ADDR
64640: GO 65023
64642: LD_INT 2
64644: DOUBLE
64645: EQUAL
64646: IFTRUE 64650
64648: GO 64832
64650: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64651: LD_ADDR_VAR 0 4
64655: PUSH
64656: LD_INT 35
64658: PUSH
64659: LD_INT 45
64661: PUSH
64662: LD_INT 46
64664: PUSH
64665: LD_INT 47
64667: PUSH
64668: LD_INT 70
64670: PUSH
64671: LD_INT 1
64673: PUSH
64674: LD_INT 11
64676: PUSH
64677: LD_INT 3
64679: PUSH
64680: LD_INT 4
64682: PUSH
64683: LD_INT 5
64685: PUSH
64686: LD_INT 6
64688: PUSH
64689: LD_INT 15
64691: PUSH
64692: LD_INT 18
64694: PUSH
64695: LD_INT 7
64697: PUSH
64698: LD_INT 17
64700: PUSH
64701: LD_INT 8
64703: PUSH
64704: LD_INT 20
64706: PUSH
64707: LD_INT 21
64709: PUSH
64710: LD_INT 22
64712: PUSH
64713: LD_INT 72
64715: PUSH
64716: LD_INT 26
64718: PUSH
64719: LD_INT 69
64721: PUSH
64722: LD_INT 39
64724: PUSH
64725: LD_INT 40
64727: PUSH
64728: LD_INT 41
64730: PUSH
64731: LD_INT 42
64733: PUSH
64734: LD_INT 43
64736: PUSH
64737: LD_INT 48
64739: PUSH
64740: LD_INT 49
64742: PUSH
64743: LD_INT 50
64745: PUSH
64746: LD_INT 51
64748: PUSH
64749: LD_INT 52
64751: PUSH
64752: LD_INT 53
64754: PUSH
64755: LD_INT 54
64757: PUSH
64758: LD_INT 55
64760: PUSH
64761: LD_INT 56
64763: PUSH
64764: LD_INT 60
64766: PUSH
64767: LD_INT 61
64769: PUSH
64770: LD_INT 62
64772: PUSH
64773: LD_INT 66
64775: PUSH
64776: LD_INT 67
64778: PUSH
64779: LD_INT 68
64781: PUSH
64782: LD_INT 81
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: LIST
64789: LIST
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: LIST
64806: LIST
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: LIST
64828: LIST
64829: ST_TO_ADDR
64830: GO 65023
64832: LD_INT 3
64834: DOUBLE
64835: EQUAL
64836: IFTRUE 64840
64838: GO 65022
64840: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64841: LD_ADDR_VAR 0 4
64845: PUSH
64846: LD_INT 46
64848: PUSH
64849: LD_INT 47
64851: PUSH
64852: LD_INT 1
64854: PUSH
64855: LD_INT 2
64857: PUSH
64858: LD_INT 11
64860: PUSH
64861: LD_INT 9
64863: PUSH
64864: LD_INT 20
64866: PUSH
64867: LD_INT 19
64869: PUSH
64870: LD_INT 21
64872: PUSH
64873: LD_INT 24
64875: PUSH
64876: LD_INT 22
64878: PUSH
64879: LD_INT 25
64881: PUSH
64882: LD_INT 28
64884: PUSH
64885: LD_INT 29
64887: PUSH
64888: LD_INT 30
64890: PUSH
64891: LD_INT 31
64893: PUSH
64894: LD_INT 37
64896: PUSH
64897: LD_INT 38
64899: PUSH
64900: LD_INT 32
64902: PUSH
64903: LD_INT 27
64905: PUSH
64906: LD_INT 33
64908: PUSH
64909: LD_INT 69
64911: PUSH
64912: LD_INT 39
64914: PUSH
64915: LD_INT 34
64917: PUSH
64918: LD_INT 40
64920: PUSH
64921: LD_INT 71
64923: PUSH
64924: LD_INT 23
64926: PUSH
64927: LD_INT 44
64929: PUSH
64930: LD_INT 48
64932: PUSH
64933: LD_INT 49
64935: PUSH
64936: LD_INT 50
64938: PUSH
64939: LD_INT 51
64941: PUSH
64942: LD_INT 52
64944: PUSH
64945: LD_INT 53
64947: PUSH
64948: LD_INT 54
64950: PUSH
64951: LD_INT 55
64953: PUSH
64954: LD_INT 56
64956: PUSH
64957: LD_INT 57
64959: PUSH
64960: LD_INT 58
64962: PUSH
64963: LD_INT 59
64965: PUSH
64966: LD_INT 63
64968: PUSH
64969: LD_INT 64
64971: PUSH
64972: LD_INT 65
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: ST_TO_ADDR
65020: GO 65023
65022: POP
// if state > - 1 and state < 3 then
65023: LD_VAR 0 3
65027: PUSH
65028: LD_INT 1
65030: NEG
65031: GREATER
65032: PUSH
65033: LD_VAR 0 3
65037: PUSH
65038: LD_INT 3
65040: LESS
65041: AND
65042: IFFALSE 65099
// for i in result do
65044: LD_ADDR_VAR 0 5
65048: PUSH
65049: LD_VAR 0 4
65053: PUSH
65054: FOR_IN
65055: IFFALSE 65097
// if GetTech ( i , side ) <> state then
65057: LD_VAR 0 5
65061: PPUSH
65062: LD_VAR 0 1
65066: PPUSH
65067: CALL_OW 321
65071: PUSH
65072: LD_VAR 0 3
65076: NONEQUAL
65077: IFFALSE 65095
// result := result diff i ;
65079: LD_ADDR_VAR 0 4
65083: PUSH
65084: LD_VAR 0 4
65088: PUSH
65089: LD_VAR 0 5
65093: DIFF
65094: ST_TO_ADDR
65095: GO 65054
65097: POP
65098: POP
// end ;
65099: LD_VAR 0 4
65103: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65104: LD_INT 0
65106: PPUSH
65107: PPUSH
65108: PPUSH
// result := true ;
65109: LD_ADDR_VAR 0 3
65113: PUSH
65114: LD_INT 1
65116: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65117: LD_ADDR_VAR 0 5
65121: PUSH
65122: LD_VAR 0 2
65126: PPUSH
65127: CALL_OW 480
65131: ST_TO_ADDR
// if not tmp then
65132: LD_VAR 0 5
65136: NOT
65137: IFFALSE 65141
// exit ;
65139: GO 65190
// for i in tmp do
65141: LD_ADDR_VAR 0 4
65145: PUSH
65146: LD_VAR 0 5
65150: PUSH
65151: FOR_IN
65152: IFFALSE 65188
// if GetTech ( i , side ) <> state_researched then
65154: LD_VAR 0 4
65158: PPUSH
65159: LD_VAR 0 1
65163: PPUSH
65164: CALL_OW 321
65168: PUSH
65169: LD_INT 2
65171: NONEQUAL
65172: IFFALSE 65186
// begin result := false ;
65174: LD_ADDR_VAR 0 3
65178: PUSH
65179: LD_INT 0
65181: ST_TO_ADDR
// exit ;
65182: POP
65183: POP
65184: GO 65190
// end ;
65186: GO 65151
65188: POP
65189: POP
// end ;
65190: LD_VAR 0 3
65194: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65195: LD_INT 0
65197: PPUSH
65198: PPUSH
65199: PPUSH
65200: PPUSH
65201: PPUSH
65202: PPUSH
65203: PPUSH
65204: PPUSH
65205: PPUSH
65206: PPUSH
65207: PPUSH
65208: PPUSH
65209: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65210: LD_VAR 0 1
65214: NOT
65215: PUSH
65216: LD_VAR 0 1
65220: PPUSH
65221: CALL_OW 257
65225: PUSH
65226: LD_INT 9
65228: NONEQUAL
65229: OR
65230: IFFALSE 65234
// exit ;
65232: GO 65807
// side := GetSide ( unit ) ;
65234: LD_ADDR_VAR 0 9
65238: PUSH
65239: LD_VAR 0 1
65243: PPUSH
65244: CALL_OW 255
65248: ST_TO_ADDR
// tech_space := tech_spacanom ;
65249: LD_ADDR_VAR 0 12
65253: PUSH
65254: LD_INT 29
65256: ST_TO_ADDR
// tech_time := tech_taurad ;
65257: LD_ADDR_VAR 0 13
65261: PUSH
65262: LD_INT 28
65264: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65265: LD_ADDR_VAR 0 11
65269: PUSH
65270: LD_VAR 0 1
65274: PPUSH
65275: CALL_OW 310
65279: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65280: LD_VAR 0 11
65284: PPUSH
65285: CALL_OW 247
65289: PUSH
65290: LD_INT 2
65292: EQUAL
65293: IFFALSE 65297
// exit ;
65295: GO 65807
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65297: LD_ADDR_VAR 0 8
65301: PUSH
65302: LD_INT 81
65304: PUSH
65305: LD_VAR 0 9
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 3
65316: PUSH
65317: LD_INT 21
65319: PUSH
65320: LD_INT 3
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PPUSH
65335: CALL_OW 69
65339: ST_TO_ADDR
// if not tmp then
65340: LD_VAR 0 8
65344: NOT
65345: IFFALSE 65349
// exit ;
65347: GO 65807
// if in_unit then
65349: LD_VAR 0 11
65353: IFFALSE 65377
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65355: LD_ADDR_VAR 0 10
65359: PUSH
65360: LD_VAR 0 8
65364: PPUSH
65365: LD_VAR 0 11
65369: PPUSH
65370: CALL_OW 74
65374: ST_TO_ADDR
65375: GO 65397
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65377: LD_ADDR_VAR 0 10
65381: PUSH
65382: LD_VAR 0 8
65386: PPUSH
65387: LD_VAR 0 1
65391: PPUSH
65392: CALL_OW 74
65396: ST_TO_ADDR
// if not enemy then
65397: LD_VAR 0 10
65401: NOT
65402: IFFALSE 65406
// exit ;
65404: GO 65807
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65406: LD_VAR 0 11
65410: PUSH
65411: LD_VAR 0 11
65415: PPUSH
65416: LD_VAR 0 10
65420: PPUSH
65421: CALL_OW 296
65425: PUSH
65426: LD_INT 13
65428: GREATER
65429: AND
65430: PUSH
65431: LD_VAR 0 1
65435: PPUSH
65436: LD_VAR 0 10
65440: PPUSH
65441: CALL_OW 296
65445: PUSH
65446: LD_INT 12
65448: GREATER
65449: OR
65450: IFFALSE 65454
// exit ;
65452: GO 65807
// missile := [ 1 ] ;
65454: LD_ADDR_VAR 0 14
65458: PUSH
65459: LD_INT 1
65461: PUSH
65462: EMPTY
65463: LIST
65464: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65465: LD_VAR 0 9
65469: PPUSH
65470: LD_VAR 0 12
65474: PPUSH
65475: CALL_OW 325
65479: IFFALSE 65508
// missile := Insert ( missile , missile + 1 , 2 ) ;
65481: LD_ADDR_VAR 0 14
65485: PUSH
65486: LD_VAR 0 14
65490: PPUSH
65491: LD_VAR 0 14
65495: PUSH
65496: LD_INT 1
65498: PLUS
65499: PPUSH
65500: LD_INT 2
65502: PPUSH
65503: CALL_OW 2
65507: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65508: LD_VAR 0 9
65512: PPUSH
65513: LD_VAR 0 13
65517: PPUSH
65518: CALL_OW 325
65522: PUSH
65523: LD_VAR 0 10
65527: PPUSH
65528: CALL_OW 255
65532: PPUSH
65533: LD_VAR 0 13
65537: PPUSH
65538: CALL_OW 325
65542: NOT
65543: AND
65544: IFFALSE 65573
// missile := Insert ( missile , missile + 1 , 3 ) ;
65546: LD_ADDR_VAR 0 14
65550: PUSH
65551: LD_VAR 0 14
65555: PPUSH
65556: LD_VAR 0 14
65560: PUSH
65561: LD_INT 1
65563: PLUS
65564: PPUSH
65565: LD_INT 3
65567: PPUSH
65568: CALL_OW 2
65572: ST_TO_ADDR
// if missile < 2 then
65573: LD_VAR 0 14
65577: PUSH
65578: LD_INT 2
65580: LESS
65581: IFFALSE 65585
// exit ;
65583: GO 65807
// x := GetX ( enemy ) ;
65585: LD_ADDR_VAR 0 4
65589: PUSH
65590: LD_VAR 0 10
65594: PPUSH
65595: CALL_OW 250
65599: ST_TO_ADDR
// y := GetY ( enemy ) ;
65600: LD_ADDR_VAR 0 5
65604: PUSH
65605: LD_VAR 0 10
65609: PPUSH
65610: CALL_OW 251
65614: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65615: LD_ADDR_VAR 0 6
65619: PUSH
65620: LD_VAR 0 4
65624: PUSH
65625: LD_INT 1
65627: NEG
65628: PPUSH
65629: LD_INT 1
65631: PPUSH
65632: CALL_OW 12
65636: PLUS
65637: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65638: LD_ADDR_VAR 0 7
65642: PUSH
65643: LD_VAR 0 5
65647: PUSH
65648: LD_INT 1
65650: NEG
65651: PPUSH
65652: LD_INT 1
65654: PPUSH
65655: CALL_OW 12
65659: PLUS
65660: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65661: LD_VAR 0 6
65665: PPUSH
65666: LD_VAR 0 7
65670: PPUSH
65671: CALL_OW 488
65675: NOT
65676: IFFALSE 65698
// begin _x := x ;
65678: LD_ADDR_VAR 0 6
65682: PUSH
65683: LD_VAR 0 4
65687: ST_TO_ADDR
// _y := y ;
65688: LD_ADDR_VAR 0 7
65692: PUSH
65693: LD_VAR 0 5
65697: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65698: LD_ADDR_VAR 0 3
65702: PUSH
65703: LD_INT 1
65705: PPUSH
65706: LD_VAR 0 14
65710: PPUSH
65711: CALL_OW 12
65715: ST_TO_ADDR
// case i of 1 :
65716: LD_VAR 0 3
65720: PUSH
65721: LD_INT 1
65723: DOUBLE
65724: EQUAL
65725: IFTRUE 65729
65727: GO 65746
65729: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65730: LD_VAR 0 1
65734: PPUSH
65735: LD_VAR 0 10
65739: PPUSH
65740: CALL_OW 115
65744: GO 65807
65746: LD_INT 2
65748: DOUBLE
65749: EQUAL
65750: IFTRUE 65754
65752: GO 65776
65754: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65755: LD_VAR 0 1
65759: PPUSH
65760: LD_VAR 0 6
65764: PPUSH
65765: LD_VAR 0 7
65769: PPUSH
65770: CALL_OW 153
65774: GO 65807
65776: LD_INT 3
65778: DOUBLE
65779: EQUAL
65780: IFTRUE 65784
65782: GO 65806
65784: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65785: LD_VAR 0 1
65789: PPUSH
65790: LD_VAR 0 6
65794: PPUSH
65795: LD_VAR 0 7
65799: PPUSH
65800: CALL_OW 154
65804: GO 65807
65806: POP
// end ;
65807: LD_VAR 0 2
65811: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65812: LD_INT 0
65814: PPUSH
65815: PPUSH
65816: PPUSH
65817: PPUSH
65818: PPUSH
65819: PPUSH
// if not unit or not building then
65820: LD_VAR 0 1
65824: NOT
65825: PUSH
65826: LD_VAR 0 2
65830: NOT
65831: OR
65832: IFFALSE 65836
// exit ;
65834: GO 65994
// x := GetX ( building ) ;
65836: LD_ADDR_VAR 0 5
65840: PUSH
65841: LD_VAR 0 2
65845: PPUSH
65846: CALL_OW 250
65850: ST_TO_ADDR
// y := GetY ( building ) ;
65851: LD_ADDR_VAR 0 6
65855: PUSH
65856: LD_VAR 0 2
65860: PPUSH
65861: CALL_OW 251
65865: ST_TO_ADDR
// for i = 0 to 5 do
65866: LD_ADDR_VAR 0 4
65870: PUSH
65871: DOUBLE
65872: LD_INT 0
65874: DEC
65875: ST_TO_ADDR
65876: LD_INT 5
65878: PUSH
65879: FOR_TO
65880: IFFALSE 65992
// begin _x := ShiftX ( x , i , 3 ) ;
65882: LD_ADDR_VAR 0 7
65886: PUSH
65887: LD_VAR 0 5
65891: PPUSH
65892: LD_VAR 0 4
65896: PPUSH
65897: LD_INT 3
65899: PPUSH
65900: CALL_OW 272
65904: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65905: LD_ADDR_VAR 0 8
65909: PUSH
65910: LD_VAR 0 6
65914: PPUSH
65915: LD_VAR 0 4
65919: PPUSH
65920: LD_INT 3
65922: PPUSH
65923: CALL_OW 273
65927: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65928: LD_VAR 0 7
65932: PPUSH
65933: LD_VAR 0 8
65937: PPUSH
65938: CALL_OW 488
65942: NOT
65943: IFFALSE 65947
// continue ;
65945: GO 65879
// if HexInfo ( _x , _y ) = 0 then
65947: LD_VAR 0 7
65951: PPUSH
65952: LD_VAR 0 8
65956: PPUSH
65957: CALL_OW 428
65961: PUSH
65962: LD_INT 0
65964: EQUAL
65965: IFFALSE 65990
// begin ComMoveXY ( unit , _x , _y ) ;
65967: LD_VAR 0 1
65971: PPUSH
65972: LD_VAR 0 7
65976: PPUSH
65977: LD_VAR 0 8
65981: PPUSH
65982: CALL_OW 111
// exit ;
65986: POP
65987: POP
65988: GO 65994
// end ; end ;
65990: GO 65879
65992: POP
65993: POP
// end ;
65994: LD_VAR 0 3
65998: RET
// export function ScanBase ( side , base_area ) ; begin
65999: LD_INT 0
66001: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66002: LD_ADDR_VAR 0 3
66006: PUSH
66007: LD_VAR 0 2
66011: PPUSH
66012: LD_INT 81
66014: PUSH
66015: LD_VAR 0 1
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PPUSH
66024: CALL_OW 70
66028: ST_TO_ADDR
// end ;
66029: LD_VAR 0 3
66033: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66034: LD_INT 0
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66041: LD_VAR 0 1
66045: NOT
66046: PUSH
66047: LD_EXP 101
66051: PUSH
66052: LD_VAR 0 1
66056: ARRAY
66057: NOT
66058: OR
66059: PUSH
66060: LD_VAR 0 2
66064: NOT
66065: OR
66066: PUSH
66067: LD_VAR 0 3
66071: NOT
66072: OR
66073: IFFALSE 66077
// exit ;
66075: GO 66590
// side := mc_sides [ base ] ;
66077: LD_ADDR_VAR 0 6
66081: PUSH
66082: LD_EXP 127
66086: PUSH
66087: LD_VAR 0 1
66091: ARRAY
66092: ST_TO_ADDR
// if not side then
66093: LD_VAR 0 6
66097: NOT
66098: IFFALSE 66102
// exit ;
66100: GO 66590
// for i in solds do
66102: LD_ADDR_VAR 0 7
66106: PUSH
66107: LD_VAR 0 2
66111: PUSH
66112: FOR_IN
66113: IFFALSE 66174
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66115: LD_VAR 0 7
66119: PPUSH
66120: CALL_OW 310
66124: PPUSH
66125: CALL_OW 266
66129: PUSH
66130: LD_INT 32
66132: PUSH
66133: LD_INT 31
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: IN
66140: IFFALSE 66160
// solds := solds diff i else
66142: LD_ADDR_VAR 0 2
66146: PUSH
66147: LD_VAR 0 2
66151: PUSH
66152: LD_VAR 0 7
66156: DIFF
66157: ST_TO_ADDR
66158: GO 66172
// SetTag ( i , 18 ) ;
66160: LD_VAR 0 7
66164: PPUSH
66165: LD_INT 18
66167: PPUSH
66168: CALL_OW 109
66172: GO 66112
66174: POP
66175: POP
// if not solds then
66176: LD_VAR 0 2
66180: NOT
66181: IFFALSE 66185
// exit ;
66183: GO 66590
// repeat wait ( 0 0$1 ) ;
66185: LD_INT 35
66187: PPUSH
66188: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66192: LD_ADDR_VAR 0 5
66196: PUSH
66197: LD_VAR 0 6
66201: PPUSH
66202: LD_VAR 0 3
66206: PPUSH
66207: CALL 65999 0 2
66211: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66212: LD_EXP 101
66216: PUSH
66217: LD_VAR 0 1
66221: ARRAY
66222: NOT
66223: PUSH
66224: LD_EXP 101
66228: PUSH
66229: LD_VAR 0 1
66233: ARRAY
66234: PUSH
66235: EMPTY
66236: EQUAL
66237: OR
66238: IFFALSE 66275
// begin for i in solds do
66240: LD_ADDR_VAR 0 7
66244: PUSH
66245: LD_VAR 0 2
66249: PUSH
66250: FOR_IN
66251: IFFALSE 66264
// ComStop ( i ) ;
66253: LD_VAR 0 7
66257: PPUSH
66258: CALL_OW 141
66262: GO 66250
66264: POP
66265: POP
// solds := [ ] ;
66266: LD_ADDR_VAR 0 2
66270: PUSH
66271: EMPTY
66272: ST_TO_ADDR
// exit ;
66273: GO 66590
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66275: LD_VAR 0 5
66279: NOT
66280: PUSH
66281: LD_VAR 0 5
66285: PUSH
66286: LD_INT 3
66288: GREATER
66289: OR
66290: PUSH
66291: LD_EXP 123
66295: PUSH
66296: LD_VAR 0 1
66300: ARRAY
66301: OR
66302: IFFALSE 66343
// begin for i in solds do
66304: LD_ADDR_VAR 0 7
66308: PUSH
66309: LD_VAR 0 2
66313: PUSH
66314: FOR_IN
66315: IFFALSE 66339
// if HasTask ( i ) then
66317: LD_VAR 0 7
66321: PPUSH
66322: CALL_OW 314
66326: IFFALSE 66337
// ComStop ( i ) ;
66328: LD_VAR 0 7
66332: PPUSH
66333: CALL_OW 141
66337: GO 66314
66339: POP
66340: POP
// break ;
66341: GO 66578
// end ; for i in solds do
66343: LD_ADDR_VAR 0 7
66347: PUSH
66348: LD_VAR 0 2
66352: PUSH
66353: FOR_IN
66354: IFFALSE 66570
// begin if IsInUnit ( i ) then
66356: LD_VAR 0 7
66360: PPUSH
66361: CALL_OW 310
66365: IFFALSE 66376
// ComExitBuilding ( i ) ;
66367: LD_VAR 0 7
66371: PPUSH
66372: CALL_OW 122
// if GetLives ( i ) > 333 then
66376: LD_VAR 0 7
66380: PPUSH
66381: CALL_OW 256
66385: PUSH
66386: LD_INT 333
66388: GREATER
66389: IFFALSE 66417
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66391: LD_VAR 0 7
66395: PPUSH
66396: LD_VAR 0 5
66400: PPUSH
66401: LD_VAR 0 7
66405: PPUSH
66406: CALL_OW 74
66410: PPUSH
66411: CALL_OW 115
66415: GO 66568
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66417: LD_ADDR_VAR 0 8
66421: PUSH
66422: LD_EXP 101
66426: PUSH
66427: LD_VAR 0 1
66431: ARRAY
66432: PPUSH
66433: LD_INT 2
66435: PUSH
66436: LD_INT 30
66438: PUSH
66439: LD_INT 0
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: LD_INT 30
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 30
66458: PUSH
66459: LD_INT 6
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: PPUSH
66472: CALL_OW 72
66476: PPUSH
66477: LD_VAR 0 7
66481: PPUSH
66482: CALL_OW 74
66486: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66487: LD_VAR 0 7
66491: PPUSH
66492: LD_VAR 0 8
66496: PPUSH
66497: CALL_OW 250
66501: PPUSH
66502: LD_INT 3
66504: PPUSH
66505: LD_INT 5
66507: PPUSH
66508: CALL_OW 272
66512: PPUSH
66513: LD_VAR 0 8
66517: PPUSH
66518: CALL_OW 251
66522: PPUSH
66523: LD_INT 3
66525: PPUSH
66526: LD_INT 5
66528: PPUSH
66529: CALL_OW 273
66533: PPUSH
66534: CALL_OW 111
// SetTag ( i , 0 ) ;
66538: LD_VAR 0 7
66542: PPUSH
66543: LD_INT 0
66545: PPUSH
66546: CALL_OW 109
// solds := solds diff i ;
66550: LD_ADDR_VAR 0 2
66554: PUSH
66555: LD_VAR 0 2
66559: PUSH
66560: LD_VAR 0 7
66564: DIFF
66565: ST_TO_ADDR
// continue ;
66566: GO 66353
// end ; end ;
66568: GO 66353
66570: POP
66571: POP
// until solds ;
66572: LD_VAR 0 2
66576: IFFALSE 66185
// MC_Reset ( base , 18 ) ;
66578: LD_VAR 0 1
66582: PPUSH
66583: LD_INT 18
66585: PPUSH
66586: CALL 38307 0 2
// end ;
66590: LD_VAR 0 4
66594: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66595: LD_INT 0
66597: PPUSH
66598: PPUSH
66599: PPUSH
66600: PPUSH
66601: PPUSH
66602: PPUSH
66603: PPUSH
66604: PPUSH
66605: PPUSH
66606: PPUSH
66607: PPUSH
66608: PPUSH
66609: PPUSH
66610: PPUSH
66611: PPUSH
66612: PPUSH
66613: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66614: LD_ADDR_VAR 0 13
66618: PUSH
66619: LD_EXP 101
66623: PUSH
66624: LD_VAR 0 1
66628: ARRAY
66629: PPUSH
66630: LD_INT 25
66632: PUSH
66633: LD_INT 3
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PPUSH
66640: CALL_OW 72
66644: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66645: LD_EXP 141
66649: PUSH
66650: LD_VAR 0 1
66654: ARRAY
66655: IFFALSE 66679
// mechs := mechs diff mc_remote_driver [ base ] ;
66657: LD_ADDR_VAR 0 13
66661: PUSH
66662: LD_VAR 0 13
66666: PUSH
66667: LD_EXP 141
66671: PUSH
66672: LD_VAR 0 1
66676: ARRAY
66677: DIFF
66678: ST_TO_ADDR
// for i in mechs do
66679: LD_ADDR_VAR 0 5
66683: PUSH
66684: LD_VAR 0 13
66688: PUSH
66689: FOR_IN
66690: IFFALSE 66725
// if GetTag ( i ) > 0 then
66692: LD_VAR 0 5
66696: PPUSH
66697: CALL_OW 110
66701: PUSH
66702: LD_INT 0
66704: GREATER
66705: IFFALSE 66723
// mechs := mechs diff i ;
66707: LD_ADDR_VAR 0 13
66711: PUSH
66712: LD_VAR 0 13
66716: PUSH
66717: LD_VAR 0 5
66721: DIFF
66722: ST_TO_ADDR
66723: GO 66689
66725: POP
66726: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66727: LD_ADDR_VAR 0 9
66731: PUSH
66732: LD_EXP 101
66736: PUSH
66737: LD_VAR 0 1
66741: ARRAY
66742: PPUSH
66743: LD_INT 2
66745: PUSH
66746: LD_INT 25
66748: PUSH
66749: LD_INT 1
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 25
66758: PUSH
66759: LD_INT 5
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 25
66768: PUSH
66769: LD_INT 8
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 25
66778: PUSH
66779: LD_INT 9
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: PPUSH
66793: CALL_OW 72
66797: ST_TO_ADDR
// if not defenders and not solds then
66798: LD_VAR 0 2
66802: NOT
66803: PUSH
66804: LD_VAR 0 9
66808: NOT
66809: AND
66810: IFFALSE 66814
// exit ;
66812: GO 68440
// depot_under_attack := false ;
66814: LD_ADDR_VAR 0 17
66818: PUSH
66819: LD_INT 0
66821: ST_TO_ADDR
// sold_defenders := [ ] ;
66822: LD_ADDR_VAR 0 18
66826: PUSH
66827: EMPTY
66828: ST_TO_ADDR
// if mechs then
66829: LD_VAR 0 13
66833: IFFALSE 66962
// for i in defenders do
66835: LD_ADDR_VAR 0 5
66839: PUSH
66840: LD_VAR 0 2
66844: PUSH
66845: FOR_IN
66846: IFFALSE 66960
// begin SetTag ( i , 20 ) ;
66848: LD_VAR 0 5
66852: PPUSH
66853: LD_INT 20
66855: PPUSH
66856: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66860: LD_VAR 0 5
66864: PPUSH
66865: CALL_OW 263
66869: PUSH
66870: LD_INT 1
66872: EQUAL
66873: PUSH
66874: LD_VAR 0 5
66878: PPUSH
66879: CALL_OW 311
66883: NOT
66884: AND
66885: PUSH
66886: LD_VAR 0 13
66890: AND
66891: IFFALSE 66958
// begin un := mechs [ 1 ] ;
66893: LD_ADDR_VAR 0 11
66897: PUSH
66898: LD_VAR 0 13
66902: PUSH
66903: LD_INT 1
66905: ARRAY
66906: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66907: LD_VAR 0 11
66911: PPUSH
66912: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66916: LD_VAR 0 11
66920: PPUSH
66921: LD_VAR 0 5
66925: PPUSH
66926: CALL_OW 180
// SetTag ( un , 19 ) ;
66930: LD_VAR 0 11
66934: PPUSH
66935: LD_INT 19
66937: PPUSH
66938: CALL_OW 109
// mechs := mechs diff un ;
66942: LD_ADDR_VAR 0 13
66946: PUSH
66947: LD_VAR 0 13
66951: PUSH
66952: LD_VAR 0 11
66956: DIFF
66957: ST_TO_ADDR
// end ; end ;
66958: GO 66845
66960: POP
66961: POP
// if solds then
66962: LD_VAR 0 9
66966: IFFALSE 67025
// for i in solds do
66968: LD_ADDR_VAR 0 5
66972: PUSH
66973: LD_VAR 0 9
66977: PUSH
66978: FOR_IN
66979: IFFALSE 67023
// if not GetTag ( i ) then
66981: LD_VAR 0 5
66985: PPUSH
66986: CALL_OW 110
66990: NOT
66991: IFFALSE 67021
// begin defenders := defenders union i ;
66993: LD_ADDR_VAR 0 2
66997: PUSH
66998: LD_VAR 0 2
67002: PUSH
67003: LD_VAR 0 5
67007: UNION
67008: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67009: LD_VAR 0 5
67013: PPUSH
67014: LD_INT 18
67016: PPUSH
67017: CALL_OW 109
// end ;
67021: GO 66978
67023: POP
67024: POP
// repeat wait ( 0 0$1 ) ;
67025: LD_INT 35
67027: PPUSH
67028: CALL_OW 67
// enemy := mc_scan [ base ] ;
67032: LD_ADDR_VAR 0 3
67036: PUSH
67037: LD_EXP 124
67041: PUSH
67042: LD_VAR 0 1
67046: ARRAY
67047: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67048: LD_EXP 101
67052: PUSH
67053: LD_VAR 0 1
67057: ARRAY
67058: NOT
67059: PUSH
67060: LD_EXP 101
67064: PUSH
67065: LD_VAR 0 1
67069: ARRAY
67070: PUSH
67071: EMPTY
67072: EQUAL
67073: OR
67074: IFFALSE 67111
// begin for i in defenders do
67076: LD_ADDR_VAR 0 5
67080: PUSH
67081: LD_VAR 0 2
67085: PUSH
67086: FOR_IN
67087: IFFALSE 67100
// ComStop ( i ) ;
67089: LD_VAR 0 5
67093: PPUSH
67094: CALL_OW 141
67098: GO 67086
67100: POP
67101: POP
// defenders := [ ] ;
67102: LD_ADDR_VAR 0 2
67106: PUSH
67107: EMPTY
67108: ST_TO_ADDR
// exit ;
67109: GO 68440
// end ; for i in defenders do
67111: LD_ADDR_VAR 0 5
67115: PUSH
67116: LD_VAR 0 2
67120: PUSH
67121: FOR_IN
67122: IFFALSE 67940
// begin e := NearestUnitToUnit ( enemy , i ) ;
67124: LD_ADDR_VAR 0 14
67128: PUSH
67129: LD_VAR 0 3
67133: PPUSH
67134: LD_VAR 0 5
67138: PPUSH
67139: CALL_OW 74
67143: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67144: LD_ADDR_VAR 0 8
67148: PUSH
67149: LD_EXP 101
67153: PUSH
67154: LD_VAR 0 1
67158: ARRAY
67159: PPUSH
67160: LD_INT 2
67162: PUSH
67163: LD_INT 30
67165: PUSH
67166: LD_INT 0
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 30
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: LIST
67187: PPUSH
67188: CALL_OW 72
67192: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67193: LD_ADDR_VAR 0 17
67197: PUSH
67198: LD_VAR 0 8
67202: NOT
67203: PUSH
67204: LD_VAR 0 8
67208: PPUSH
67209: LD_INT 3
67211: PUSH
67212: LD_INT 24
67214: PUSH
67215: LD_INT 600
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PPUSH
67226: CALL_OW 72
67230: OR
67231: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67232: LD_VAR 0 5
67236: PPUSH
67237: CALL_OW 247
67241: PUSH
67242: LD_INT 2
67244: DOUBLE
67245: EQUAL
67246: IFTRUE 67250
67248: GO 67646
67250: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67251: LD_VAR 0 5
67255: PPUSH
67256: CALL_OW 256
67260: PUSH
67261: LD_INT 650
67263: GREATER
67264: PUSH
67265: LD_VAR 0 5
67269: PPUSH
67270: LD_VAR 0 14
67274: PPUSH
67275: CALL_OW 296
67279: PUSH
67280: LD_INT 40
67282: LESS
67283: PUSH
67284: LD_VAR 0 14
67288: PPUSH
67289: LD_EXP 126
67293: PUSH
67294: LD_VAR 0 1
67298: ARRAY
67299: PPUSH
67300: CALL_OW 308
67304: OR
67305: AND
67306: IFFALSE 67428
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67308: LD_VAR 0 5
67312: PPUSH
67313: CALL_OW 262
67317: PUSH
67318: LD_INT 1
67320: EQUAL
67321: PUSH
67322: LD_VAR 0 5
67326: PPUSH
67327: CALL_OW 261
67331: PUSH
67332: LD_INT 30
67334: LESS
67335: AND
67336: PUSH
67337: LD_VAR 0 8
67341: AND
67342: IFFALSE 67412
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67344: LD_VAR 0 5
67348: PPUSH
67349: LD_VAR 0 8
67353: PPUSH
67354: LD_VAR 0 5
67358: PPUSH
67359: CALL_OW 74
67363: PPUSH
67364: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67368: LD_VAR 0 5
67372: PPUSH
67373: LD_VAR 0 8
67377: PPUSH
67378: LD_VAR 0 5
67382: PPUSH
67383: CALL_OW 74
67387: PPUSH
67388: CALL_OW 296
67392: PUSH
67393: LD_INT 6
67395: LESS
67396: IFFALSE 67410
// SetFuel ( i , 100 ) ;
67398: LD_VAR 0 5
67402: PPUSH
67403: LD_INT 100
67405: PPUSH
67406: CALL_OW 240
// end else
67410: GO 67426
// ComAttackUnit ( i , e ) ;
67412: LD_VAR 0 5
67416: PPUSH
67417: LD_VAR 0 14
67421: PPUSH
67422: CALL_OW 115
// end else
67426: GO 67529
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67428: LD_VAR 0 14
67432: PPUSH
67433: LD_EXP 126
67437: PUSH
67438: LD_VAR 0 1
67442: ARRAY
67443: PPUSH
67444: CALL_OW 308
67448: NOT
67449: PUSH
67450: LD_VAR 0 5
67454: PPUSH
67455: LD_VAR 0 14
67459: PPUSH
67460: CALL_OW 296
67464: PUSH
67465: LD_INT 40
67467: GREATEREQUAL
67468: AND
67469: PUSH
67470: LD_VAR 0 5
67474: PPUSH
67475: CALL_OW 256
67479: PUSH
67480: LD_INT 650
67482: LESSEQUAL
67483: OR
67484: PUSH
67485: LD_VAR 0 5
67489: PPUSH
67490: LD_EXP 125
67494: PUSH
67495: LD_VAR 0 1
67499: ARRAY
67500: PPUSH
67501: CALL_OW 308
67505: NOT
67506: AND
67507: IFFALSE 67529
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67509: LD_VAR 0 5
67513: PPUSH
67514: LD_EXP 125
67518: PUSH
67519: LD_VAR 0 1
67523: ARRAY
67524: PPUSH
67525: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67529: LD_VAR 0 5
67533: PPUSH
67534: CALL_OW 256
67538: PUSH
67539: LD_INT 998
67541: LESS
67542: PUSH
67543: LD_VAR 0 5
67547: PPUSH
67548: CALL_OW 263
67552: PUSH
67553: LD_INT 1
67555: EQUAL
67556: AND
67557: PUSH
67558: LD_VAR 0 5
67562: PPUSH
67563: CALL_OW 311
67567: AND
67568: PUSH
67569: LD_VAR 0 5
67573: PPUSH
67574: LD_EXP 125
67578: PUSH
67579: LD_VAR 0 1
67583: ARRAY
67584: PPUSH
67585: CALL_OW 308
67589: AND
67590: IFFALSE 67644
// begin mech := IsDrivenBy ( i ) ;
67592: LD_ADDR_VAR 0 10
67596: PUSH
67597: LD_VAR 0 5
67601: PPUSH
67602: CALL_OW 311
67606: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67607: LD_VAR 0 10
67611: PPUSH
67612: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67616: LD_VAR 0 10
67620: PPUSH
67621: LD_VAR 0 5
67625: PPUSH
67626: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67630: LD_VAR 0 10
67634: PPUSH
67635: LD_VAR 0 5
67639: PPUSH
67640: CALL_OW 180
// end ; end ; unit_human :
67644: GO 67911
67646: LD_INT 1
67648: DOUBLE
67649: EQUAL
67650: IFTRUE 67654
67652: GO 67910
67654: POP
// begin b := IsInUnit ( i ) ;
67655: LD_ADDR_VAR 0 19
67659: PUSH
67660: LD_VAR 0 5
67664: PPUSH
67665: CALL_OW 310
67669: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67670: LD_ADDR_VAR 0 20
67674: PUSH
67675: LD_VAR 0 19
67679: NOT
67680: PUSH
67681: LD_VAR 0 19
67685: PPUSH
67686: CALL_OW 266
67690: PUSH
67691: LD_INT 32
67693: PUSH
67694: LD_INT 31
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: IN
67701: OR
67702: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67703: LD_VAR 0 17
67707: PUSH
67708: LD_VAR 0 2
67712: PPUSH
67713: LD_INT 21
67715: PUSH
67716: LD_INT 2
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PPUSH
67723: CALL_OW 72
67727: PUSH
67728: LD_INT 1
67730: LESSEQUAL
67731: OR
67732: PUSH
67733: LD_VAR 0 20
67737: AND
67738: PUSH
67739: LD_VAR 0 5
67743: PUSH
67744: LD_VAR 0 18
67748: IN
67749: NOT
67750: AND
67751: IFFALSE 67844
// begin if b then
67753: LD_VAR 0 19
67757: IFFALSE 67806
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67759: LD_VAR 0 19
67763: PPUSH
67764: LD_VAR 0 3
67768: PPUSH
67769: LD_VAR 0 19
67773: PPUSH
67774: CALL_OW 74
67778: PPUSH
67779: CALL_OW 296
67783: PUSH
67784: LD_INT 10
67786: LESS
67787: PUSH
67788: LD_VAR 0 19
67792: PPUSH
67793: CALL_OW 461
67797: PUSH
67798: LD_INT 7
67800: NONEQUAL
67801: AND
67802: IFFALSE 67806
// continue ;
67804: GO 67121
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67806: LD_ADDR_VAR 0 18
67810: PUSH
67811: LD_VAR 0 18
67815: PPUSH
67816: LD_VAR 0 18
67820: PUSH
67821: LD_INT 1
67823: PLUS
67824: PPUSH
67825: LD_VAR 0 5
67829: PPUSH
67830: CALL_OW 1
67834: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67835: LD_VAR 0 5
67839: PPUSH
67840: CALL_OW 122
// end ; if sold_defenders then
67844: LD_VAR 0 18
67848: IFFALSE 67908
// if i in sold_defenders then
67850: LD_VAR 0 5
67854: PUSH
67855: LD_VAR 0 18
67859: IN
67860: IFFALSE 67908
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67862: LD_VAR 0 5
67866: PPUSH
67867: CALL_OW 314
67871: NOT
67872: PUSH
67873: LD_VAR 0 5
67877: PPUSH
67878: LD_VAR 0 14
67882: PPUSH
67883: CALL_OW 296
67887: PUSH
67888: LD_INT 30
67890: LESS
67891: AND
67892: IFFALSE 67908
// ComAttackUnit ( i , e ) ;
67894: LD_VAR 0 5
67898: PPUSH
67899: LD_VAR 0 14
67903: PPUSH
67904: CALL_OW 115
// end ; end ; end ;
67908: GO 67911
67910: POP
// if IsDead ( i ) then
67911: LD_VAR 0 5
67915: PPUSH
67916: CALL_OW 301
67920: IFFALSE 67938
// defenders := defenders diff i ;
67922: LD_ADDR_VAR 0 2
67926: PUSH
67927: LD_VAR 0 2
67931: PUSH
67932: LD_VAR 0 5
67936: DIFF
67937: ST_TO_ADDR
// end ;
67938: GO 67121
67940: POP
67941: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67942: LD_VAR 0 3
67946: NOT
67947: PUSH
67948: LD_VAR 0 2
67952: NOT
67953: OR
67954: PUSH
67955: LD_EXP 101
67959: PUSH
67960: LD_VAR 0 1
67964: ARRAY
67965: NOT
67966: OR
67967: IFFALSE 67025
// MC_Reset ( base , 18 ) ;
67969: LD_VAR 0 1
67973: PPUSH
67974: LD_INT 18
67976: PPUSH
67977: CALL 38307 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67981: LD_ADDR_VAR 0 2
67985: PUSH
67986: LD_VAR 0 2
67990: PUSH
67991: LD_VAR 0 2
67995: PPUSH
67996: LD_INT 2
67998: PUSH
67999: LD_INT 25
68001: PUSH
68002: LD_INT 1
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 25
68011: PUSH
68012: LD_INT 5
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 25
68021: PUSH
68022: LD_INT 8
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 25
68031: PUSH
68032: LD_INT 9
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: PPUSH
68046: CALL_OW 72
68050: DIFF
68051: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68052: LD_VAR 0 3
68056: NOT
68057: PUSH
68058: LD_VAR 0 2
68062: PPUSH
68063: LD_INT 21
68065: PUSH
68066: LD_INT 2
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PPUSH
68073: CALL_OW 72
68077: AND
68078: IFFALSE 68416
// begin tmp := FilterByTag ( defenders , 19 ) ;
68080: LD_ADDR_VAR 0 12
68084: PUSH
68085: LD_VAR 0 2
68089: PPUSH
68090: LD_INT 19
68092: PPUSH
68093: CALL 104869 0 2
68097: ST_TO_ADDR
// if tmp then
68098: LD_VAR 0 12
68102: IFFALSE 68172
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68104: LD_ADDR_VAR 0 12
68108: PUSH
68109: LD_VAR 0 12
68113: PPUSH
68114: LD_INT 25
68116: PUSH
68117: LD_INT 3
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PPUSH
68124: CALL_OW 72
68128: ST_TO_ADDR
// if tmp then
68129: LD_VAR 0 12
68133: IFFALSE 68172
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68135: LD_ADDR_EXP 113
68139: PUSH
68140: LD_EXP 113
68144: PPUSH
68145: LD_VAR 0 1
68149: PPUSH
68150: LD_EXP 113
68154: PUSH
68155: LD_VAR 0 1
68159: ARRAY
68160: PUSH
68161: LD_VAR 0 12
68165: UNION
68166: PPUSH
68167: CALL_OW 1
68171: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68172: LD_VAR 0 1
68176: PPUSH
68177: LD_INT 19
68179: PPUSH
68180: CALL 38307 0 2
// repeat wait ( 0 0$1 ) ;
68184: LD_INT 35
68186: PPUSH
68187: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68191: LD_EXP 101
68195: PUSH
68196: LD_VAR 0 1
68200: ARRAY
68201: NOT
68202: PUSH
68203: LD_EXP 101
68207: PUSH
68208: LD_VAR 0 1
68212: ARRAY
68213: PUSH
68214: EMPTY
68215: EQUAL
68216: OR
68217: IFFALSE 68254
// begin for i in defenders do
68219: LD_ADDR_VAR 0 5
68223: PUSH
68224: LD_VAR 0 2
68228: PUSH
68229: FOR_IN
68230: IFFALSE 68243
// ComStop ( i ) ;
68232: LD_VAR 0 5
68236: PPUSH
68237: CALL_OW 141
68241: GO 68229
68243: POP
68244: POP
// defenders := [ ] ;
68245: LD_ADDR_VAR 0 2
68249: PUSH
68250: EMPTY
68251: ST_TO_ADDR
// exit ;
68252: GO 68440
// end ; for i in defenders do
68254: LD_ADDR_VAR 0 5
68258: PUSH
68259: LD_VAR 0 2
68263: PUSH
68264: FOR_IN
68265: IFFALSE 68354
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68267: LD_VAR 0 5
68271: PPUSH
68272: LD_EXP 125
68276: PUSH
68277: LD_VAR 0 1
68281: ARRAY
68282: PPUSH
68283: CALL_OW 308
68287: NOT
68288: IFFALSE 68312
// ComMoveToArea ( i , mc_parking [ base ] ) else
68290: LD_VAR 0 5
68294: PPUSH
68295: LD_EXP 125
68299: PUSH
68300: LD_VAR 0 1
68304: ARRAY
68305: PPUSH
68306: CALL_OW 113
68310: GO 68352
// if GetControl ( i ) = control_manual then
68312: LD_VAR 0 5
68316: PPUSH
68317: CALL_OW 263
68321: PUSH
68322: LD_INT 1
68324: EQUAL
68325: IFFALSE 68352
// if IsDrivenBy ( i ) then
68327: LD_VAR 0 5
68331: PPUSH
68332: CALL_OW 311
68336: IFFALSE 68352
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68338: LD_VAR 0 5
68342: PPUSH
68343: CALL_OW 311
68347: PPUSH
68348: CALL_OW 121
// end ;
68352: GO 68264
68354: POP
68355: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68356: LD_VAR 0 2
68360: PPUSH
68361: LD_INT 95
68363: PUSH
68364: LD_EXP 125
68368: PUSH
68369: LD_VAR 0 1
68373: ARRAY
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PPUSH
68379: CALL_OW 72
68383: PUSH
68384: LD_VAR 0 2
68388: EQUAL
68389: PUSH
68390: LD_EXP 124
68394: PUSH
68395: LD_VAR 0 1
68399: ARRAY
68400: OR
68401: PUSH
68402: LD_EXP 101
68406: PUSH
68407: LD_VAR 0 1
68411: ARRAY
68412: NOT
68413: OR
68414: IFFALSE 68184
// end ; MC_Reset ( base , 19 ) ;
68416: LD_VAR 0 1
68420: PPUSH
68421: LD_INT 19
68423: PPUSH
68424: CALL 38307 0 2
// MC_Reset ( base , 20 ) ;
68428: LD_VAR 0 1
68432: PPUSH
68433: LD_INT 20
68435: PPUSH
68436: CALL 38307 0 2
// end ;
68440: LD_VAR 0 4
68444: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68445: LD_INT 0
68447: PPUSH
68448: PPUSH
68449: PPUSH
68450: PPUSH
// result := false ;
68451: LD_ADDR_VAR 0 2
68455: PUSH
68456: LD_INT 0
68458: ST_TO_ADDR
// side := GetSide ( unit ) ;
68459: LD_ADDR_VAR 0 3
68463: PUSH
68464: LD_VAR 0 1
68468: PPUSH
68469: CALL_OW 255
68473: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68474: LD_ADDR_VAR 0 4
68478: PUSH
68479: LD_VAR 0 1
68483: PPUSH
68484: CALL_OW 248
68488: ST_TO_ADDR
// case nat of 1 :
68489: LD_VAR 0 4
68493: PUSH
68494: LD_INT 1
68496: DOUBLE
68497: EQUAL
68498: IFTRUE 68502
68500: GO 68513
68502: POP
// tech := tech_lassight ; 2 :
68503: LD_ADDR_VAR 0 5
68507: PUSH
68508: LD_INT 12
68510: ST_TO_ADDR
68511: GO 68552
68513: LD_INT 2
68515: DOUBLE
68516: EQUAL
68517: IFTRUE 68521
68519: GO 68532
68521: POP
// tech := tech_mortar ; 3 :
68522: LD_ADDR_VAR 0 5
68526: PUSH
68527: LD_INT 41
68529: ST_TO_ADDR
68530: GO 68552
68532: LD_INT 3
68534: DOUBLE
68535: EQUAL
68536: IFTRUE 68540
68538: GO 68551
68540: POP
// tech := tech_bazooka ; end ;
68541: LD_ADDR_VAR 0 5
68545: PUSH
68546: LD_INT 44
68548: ST_TO_ADDR
68549: GO 68552
68551: POP
// if Researched ( side , tech ) then
68552: LD_VAR 0 3
68556: PPUSH
68557: LD_VAR 0 5
68561: PPUSH
68562: CALL_OW 325
68566: IFFALSE 68593
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68568: LD_ADDR_VAR 0 2
68572: PUSH
68573: LD_INT 5
68575: PUSH
68576: LD_INT 8
68578: PUSH
68579: LD_INT 9
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: LIST
68586: PUSH
68587: LD_VAR 0 4
68591: ARRAY
68592: ST_TO_ADDR
// end ;
68593: LD_VAR 0 2
68597: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68598: LD_INT 0
68600: PPUSH
68601: PPUSH
68602: PPUSH
// if not mines then
68603: LD_VAR 0 2
68607: NOT
68608: IFFALSE 68612
// exit ;
68610: GO 68756
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68612: LD_ADDR_VAR 0 5
68616: PUSH
68617: LD_INT 81
68619: PUSH
68620: LD_VAR 0 1
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 3
68631: PUSH
68632: LD_INT 21
68634: PUSH
68635: LD_INT 3
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PPUSH
68650: CALL_OW 69
68654: ST_TO_ADDR
// for i in mines do
68655: LD_ADDR_VAR 0 4
68659: PUSH
68660: LD_VAR 0 2
68664: PUSH
68665: FOR_IN
68666: IFFALSE 68754
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68668: LD_VAR 0 4
68672: PUSH
68673: LD_INT 1
68675: ARRAY
68676: PPUSH
68677: LD_VAR 0 4
68681: PUSH
68682: LD_INT 2
68684: ARRAY
68685: PPUSH
68686: CALL_OW 458
68690: NOT
68691: IFFALSE 68695
// continue ;
68693: GO 68665
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68695: LD_VAR 0 4
68699: PUSH
68700: LD_INT 1
68702: ARRAY
68703: PPUSH
68704: LD_VAR 0 4
68708: PUSH
68709: LD_INT 2
68711: ARRAY
68712: PPUSH
68713: CALL_OW 428
68717: PUSH
68718: LD_VAR 0 5
68722: IN
68723: IFFALSE 68752
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68725: LD_VAR 0 4
68729: PUSH
68730: LD_INT 1
68732: ARRAY
68733: PPUSH
68734: LD_VAR 0 4
68738: PUSH
68739: LD_INT 2
68741: ARRAY
68742: PPUSH
68743: LD_VAR 0 1
68747: PPUSH
68748: CALL_OW 456
// end ;
68752: GO 68665
68754: POP
68755: POP
// end ;
68756: LD_VAR 0 3
68760: RET
// export function Count ( array ) ; var i ; begin
68761: LD_INT 0
68763: PPUSH
68764: PPUSH
// result := 0 ;
68765: LD_ADDR_VAR 0 2
68769: PUSH
68770: LD_INT 0
68772: ST_TO_ADDR
// for i in array do
68773: LD_ADDR_VAR 0 3
68777: PUSH
68778: LD_VAR 0 1
68782: PUSH
68783: FOR_IN
68784: IFFALSE 68808
// if i then
68786: LD_VAR 0 3
68790: IFFALSE 68806
// result := result + 1 ;
68792: LD_ADDR_VAR 0 2
68796: PUSH
68797: LD_VAR 0 2
68801: PUSH
68802: LD_INT 1
68804: PLUS
68805: ST_TO_ADDR
68806: GO 68783
68808: POP
68809: POP
// end ;
68810: LD_VAR 0 2
68814: RET
// export function IsEmpty ( building ) ; begin
68815: LD_INT 0
68817: PPUSH
// if not building then
68818: LD_VAR 0 1
68822: NOT
68823: IFFALSE 68827
// exit ;
68825: GO 68870
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68827: LD_ADDR_VAR 0 2
68831: PUSH
68832: LD_VAR 0 1
68836: PUSH
68837: LD_INT 22
68839: PUSH
68840: LD_VAR 0 1
68844: PPUSH
68845: CALL_OW 255
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 58
68856: PUSH
68857: EMPTY
68858: LIST
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PPUSH
68864: CALL_OW 69
68868: IN
68869: ST_TO_ADDR
// end ;
68870: LD_VAR 0 2
68874: RET
// export function IsNotFull ( building ) ; begin
68875: LD_INT 0
68877: PPUSH
// if not building then
68878: LD_VAR 0 1
68882: NOT
68883: IFFALSE 68887
// exit ;
68885: GO 68906
// result := UnitsInside ( building ) < 6 ;
68887: LD_ADDR_VAR 0 2
68891: PUSH
68892: LD_VAR 0 1
68896: PPUSH
68897: CALL_OW 313
68901: PUSH
68902: LD_INT 6
68904: LESS
68905: ST_TO_ADDR
// end ;
68906: LD_VAR 0 2
68910: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68911: LD_INT 0
68913: PPUSH
68914: PPUSH
68915: PPUSH
68916: PPUSH
// tmp := [ ] ;
68917: LD_ADDR_VAR 0 3
68921: PUSH
68922: EMPTY
68923: ST_TO_ADDR
// list := [ ] ;
68924: LD_ADDR_VAR 0 5
68928: PUSH
68929: EMPTY
68930: ST_TO_ADDR
// for i = 16 to 25 do
68931: LD_ADDR_VAR 0 4
68935: PUSH
68936: DOUBLE
68937: LD_INT 16
68939: DEC
68940: ST_TO_ADDR
68941: LD_INT 25
68943: PUSH
68944: FOR_TO
68945: IFFALSE 69018
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68947: LD_ADDR_VAR 0 3
68951: PUSH
68952: LD_VAR 0 3
68956: PUSH
68957: LD_INT 22
68959: PUSH
68960: LD_VAR 0 1
68964: PPUSH
68965: CALL_OW 255
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 91
68976: PUSH
68977: LD_VAR 0 1
68981: PUSH
68982: LD_INT 6
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: LIST
68989: PUSH
68990: LD_INT 30
68992: PUSH
68993: LD_VAR 0 4
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: LIST
69006: PUSH
69007: EMPTY
69008: LIST
69009: PPUSH
69010: CALL_OW 69
69014: ADD
69015: ST_TO_ADDR
69016: GO 68944
69018: POP
69019: POP
// for i = 1 to tmp do
69020: LD_ADDR_VAR 0 4
69024: PUSH
69025: DOUBLE
69026: LD_INT 1
69028: DEC
69029: ST_TO_ADDR
69030: LD_VAR 0 3
69034: PUSH
69035: FOR_TO
69036: IFFALSE 69124
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69038: LD_ADDR_VAR 0 5
69042: PUSH
69043: LD_VAR 0 5
69047: PUSH
69048: LD_VAR 0 3
69052: PUSH
69053: LD_VAR 0 4
69057: ARRAY
69058: PPUSH
69059: CALL_OW 266
69063: PUSH
69064: LD_VAR 0 3
69068: PUSH
69069: LD_VAR 0 4
69073: ARRAY
69074: PPUSH
69075: CALL_OW 250
69079: PUSH
69080: LD_VAR 0 3
69084: PUSH
69085: LD_VAR 0 4
69089: ARRAY
69090: PPUSH
69091: CALL_OW 251
69095: PUSH
69096: LD_VAR 0 3
69100: PUSH
69101: LD_VAR 0 4
69105: ARRAY
69106: PPUSH
69107: CALL_OW 254
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: PUSH
69118: EMPTY
69119: LIST
69120: ADD
69121: ST_TO_ADDR
69122: GO 69035
69124: POP
69125: POP
// result := list ;
69126: LD_ADDR_VAR 0 2
69130: PUSH
69131: LD_VAR 0 5
69135: ST_TO_ADDR
// end ;
69136: LD_VAR 0 2
69140: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69141: LD_INT 0
69143: PPUSH
69144: PPUSH
69145: PPUSH
69146: PPUSH
69147: PPUSH
69148: PPUSH
69149: PPUSH
// if not factory then
69150: LD_VAR 0 1
69154: NOT
69155: IFFALSE 69159
// exit ;
69157: GO 69752
// if control = control_apeman then
69159: LD_VAR 0 4
69163: PUSH
69164: LD_INT 5
69166: EQUAL
69167: IFFALSE 69276
// begin tmp := UnitsInside ( factory ) ;
69169: LD_ADDR_VAR 0 8
69173: PUSH
69174: LD_VAR 0 1
69178: PPUSH
69179: CALL_OW 313
69183: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69184: LD_VAR 0 8
69188: PPUSH
69189: LD_INT 25
69191: PUSH
69192: LD_INT 12
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PPUSH
69199: CALL_OW 72
69203: NOT
69204: IFFALSE 69214
// control := control_manual ;
69206: LD_ADDR_VAR 0 4
69210: PUSH
69211: LD_INT 1
69213: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69214: LD_ADDR_VAR 0 8
69218: PUSH
69219: LD_VAR 0 1
69223: PPUSH
69224: CALL 68911 0 1
69228: ST_TO_ADDR
// if tmp then
69229: LD_VAR 0 8
69233: IFFALSE 69276
// begin for i in tmp do
69235: LD_ADDR_VAR 0 7
69239: PUSH
69240: LD_VAR 0 8
69244: PUSH
69245: FOR_IN
69246: IFFALSE 69274
// if i [ 1 ] = b_ext_radio then
69248: LD_VAR 0 7
69252: PUSH
69253: LD_INT 1
69255: ARRAY
69256: PUSH
69257: LD_INT 22
69259: EQUAL
69260: IFFALSE 69272
// begin control := control_remote ;
69262: LD_ADDR_VAR 0 4
69266: PUSH
69267: LD_INT 2
69269: ST_TO_ADDR
// break ;
69270: GO 69274
// end ;
69272: GO 69245
69274: POP
69275: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69276: LD_VAR 0 1
69280: PPUSH
69281: LD_VAR 0 2
69285: PPUSH
69286: LD_VAR 0 3
69290: PPUSH
69291: LD_VAR 0 4
69295: PPUSH
69296: LD_VAR 0 5
69300: PPUSH
69301: CALL_OW 448
69305: IFFALSE 69340
// begin result := [ chassis , engine , control , weapon ] ;
69307: LD_ADDR_VAR 0 6
69311: PUSH
69312: LD_VAR 0 2
69316: PUSH
69317: LD_VAR 0 3
69321: PUSH
69322: LD_VAR 0 4
69326: PUSH
69327: LD_VAR 0 5
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: ST_TO_ADDR
// exit ;
69338: GO 69752
// end ; _chassis := AvailableChassisList ( factory ) ;
69340: LD_ADDR_VAR 0 9
69344: PUSH
69345: LD_VAR 0 1
69349: PPUSH
69350: CALL_OW 475
69354: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69355: LD_ADDR_VAR 0 11
69359: PUSH
69360: LD_VAR 0 1
69364: PPUSH
69365: CALL_OW 476
69369: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69370: LD_ADDR_VAR 0 12
69374: PUSH
69375: LD_VAR 0 1
69379: PPUSH
69380: CALL_OW 477
69384: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69385: LD_ADDR_VAR 0 10
69389: PUSH
69390: LD_VAR 0 1
69394: PPUSH
69395: CALL_OW 478
69399: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69400: LD_VAR 0 9
69404: NOT
69405: PUSH
69406: LD_VAR 0 11
69410: NOT
69411: OR
69412: PUSH
69413: LD_VAR 0 12
69417: NOT
69418: OR
69419: PUSH
69420: LD_VAR 0 10
69424: NOT
69425: OR
69426: IFFALSE 69461
// begin result := [ chassis , engine , control , weapon ] ;
69428: LD_ADDR_VAR 0 6
69432: PUSH
69433: LD_VAR 0 2
69437: PUSH
69438: LD_VAR 0 3
69442: PUSH
69443: LD_VAR 0 4
69447: PUSH
69448: LD_VAR 0 5
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: ST_TO_ADDR
// exit ;
69459: GO 69752
// end ; if not chassis in _chassis then
69461: LD_VAR 0 2
69465: PUSH
69466: LD_VAR 0 9
69470: IN
69471: NOT
69472: IFFALSE 69498
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69474: LD_ADDR_VAR 0 2
69478: PUSH
69479: LD_VAR 0 9
69483: PUSH
69484: LD_INT 1
69486: PPUSH
69487: LD_VAR 0 9
69491: PPUSH
69492: CALL_OW 12
69496: ARRAY
69497: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69498: LD_VAR 0 2
69502: PPUSH
69503: LD_VAR 0 3
69507: PPUSH
69508: CALL 69757 0 2
69512: NOT
69513: IFFALSE 69572
// repeat engine := _engine [ 1 ] ;
69515: LD_ADDR_VAR 0 3
69519: PUSH
69520: LD_VAR 0 11
69524: PUSH
69525: LD_INT 1
69527: ARRAY
69528: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69529: LD_ADDR_VAR 0 11
69533: PUSH
69534: LD_VAR 0 11
69538: PPUSH
69539: LD_INT 1
69541: PPUSH
69542: CALL_OW 3
69546: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69547: LD_VAR 0 2
69551: PPUSH
69552: LD_VAR 0 3
69556: PPUSH
69557: CALL 69757 0 2
69561: PUSH
69562: LD_VAR 0 11
69566: PUSH
69567: EMPTY
69568: EQUAL
69569: OR
69570: IFFALSE 69515
// if not control in _control then
69572: LD_VAR 0 4
69576: PUSH
69577: LD_VAR 0 12
69581: IN
69582: NOT
69583: IFFALSE 69609
// control := _control [ rand ( 1 , _control ) ] ;
69585: LD_ADDR_VAR 0 4
69589: PUSH
69590: LD_VAR 0 12
69594: PUSH
69595: LD_INT 1
69597: PPUSH
69598: LD_VAR 0 12
69602: PPUSH
69603: CALL_OW 12
69607: ARRAY
69608: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69609: LD_VAR 0 2
69613: PPUSH
69614: LD_VAR 0 5
69618: PPUSH
69619: CALL 69977 0 2
69623: NOT
69624: IFFALSE 69683
// repeat weapon := _weapon [ 1 ] ;
69626: LD_ADDR_VAR 0 5
69630: PUSH
69631: LD_VAR 0 10
69635: PUSH
69636: LD_INT 1
69638: ARRAY
69639: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69640: LD_ADDR_VAR 0 10
69644: PUSH
69645: LD_VAR 0 10
69649: PPUSH
69650: LD_INT 1
69652: PPUSH
69653: CALL_OW 3
69657: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69658: LD_VAR 0 2
69662: PPUSH
69663: LD_VAR 0 5
69667: PPUSH
69668: CALL 69977 0 2
69672: PUSH
69673: LD_VAR 0 10
69677: PUSH
69678: EMPTY
69679: EQUAL
69680: OR
69681: IFFALSE 69626
// result := [ ] ;
69683: LD_ADDR_VAR 0 6
69687: PUSH
69688: EMPTY
69689: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69690: LD_VAR 0 1
69694: PPUSH
69695: LD_VAR 0 2
69699: PPUSH
69700: LD_VAR 0 3
69704: PPUSH
69705: LD_VAR 0 4
69709: PPUSH
69710: LD_VAR 0 5
69714: PPUSH
69715: CALL_OW 448
69719: IFFALSE 69752
// result := [ chassis , engine , control , weapon ] ;
69721: LD_ADDR_VAR 0 6
69725: PUSH
69726: LD_VAR 0 2
69730: PUSH
69731: LD_VAR 0 3
69735: PUSH
69736: LD_VAR 0 4
69740: PUSH
69741: LD_VAR 0 5
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: ST_TO_ADDR
// end ;
69752: LD_VAR 0 6
69756: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69757: LD_INT 0
69759: PPUSH
// if not chassis or not engine then
69760: LD_VAR 0 1
69764: NOT
69765: PUSH
69766: LD_VAR 0 2
69770: NOT
69771: OR
69772: IFFALSE 69776
// exit ;
69774: GO 69972
// case engine of engine_solar :
69776: LD_VAR 0 2
69780: PUSH
69781: LD_INT 2
69783: DOUBLE
69784: EQUAL
69785: IFTRUE 69789
69787: GO 69827
69789: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69790: LD_ADDR_VAR 0 3
69794: PUSH
69795: LD_INT 11
69797: PUSH
69798: LD_INT 12
69800: PUSH
69801: LD_INT 13
69803: PUSH
69804: LD_INT 14
69806: PUSH
69807: LD_INT 1
69809: PUSH
69810: LD_INT 2
69812: PUSH
69813: LD_INT 3
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: ST_TO_ADDR
69825: GO 69956
69827: LD_INT 1
69829: DOUBLE
69830: EQUAL
69831: IFTRUE 69835
69833: GO 69897
69835: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69836: LD_ADDR_VAR 0 3
69840: PUSH
69841: LD_INT 11
69843: PUSH
69844: LD_INT 12
69846: PUSH
69847: LD_INT 13
69849: PUSH
69850: LD_INT 14
69852: PUSH
69853: LD_INT 1
69855: PUSH
69856: LD_INT 2
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: LD_INT 4
69864: PUSH
69865: LD_INT 5
69867: PUSH
69868: LD_INT 21
69870: PUSH
69871: LD_INT 23
69873: PUSH
69874: LD_INT 22
69876: PUSH
69877: LD_INT 24
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: ST_TO_ADDR
69895: GO 69956
69897: LD_INT 3
69899: DOUBLE
69900: EQUAL
69901: IFTRUE 69905
69903: GO 69955
69905: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69906: LD_ADDR_VAR 0 3
69910: PUSH
69911: LD_INT 13
69913: PUSH
69914: LD_INT 14
69916: PUSH
69917: LD_INT 2
69919: PUSH
69920: LD_INT 3
69922: PUSH
69923: LD_INT 4
69925: PUSH
69926: LD_INT 5
69928: PUSH
69929: LD_INT 21
69931: PUSH
69932: LD_INT 22
69934: PUSH
69935: LD_INT 23
69937: PUSH
69938: LD_INT 24
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: ST_TO_ADDR
69953: GO 69956
69955: POP
// result := ( chassis in result ) ;
69956: LD_ADDR_VAR 0 3
69960: PUSH
69961: LD_VAR 0 1
69965: PUSH
69966: LD_VAR 0 3
69970: IN
69971: ST_TO_ADDR
// end ;
69972: LD_VAR 0 3
69976: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69977: LD_INT 0
69979: PPUSH
// if not chassis or not weapon then
69980: LD_VAR 0 1
69984: NOT
69985: PUSH
69986: LD_VAR 0 2
69990: NOT
69991: OR
69992: IFFALSE 69996
// exit ;
69994: GO 71022
// case weapon of us_machine_gun :
69996: LD_VAR 0 2
70000: PUSH
70001: LD_INT 2
70003: DOUBLE
70004: EQUAL
70005: IFTRUE 70009
70007: GO 70039
70009: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70010: LD_ADDR_VAR 0 3
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: LD_INT 3
70023: PUSH
70024: LD_INT 4
70026: PUSH
70027: LD_INT 5
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: ST_TO_ADDR
70037: GO 71006
70039: LD_INT 3
70041: DOUBLE
70042: EQUAL
70043: IFTRUE 70047
70045: GO 70077
70047: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70048: LD_ADDR_VAR 0 3
70052: PUSH
70053: LD_INT 1
70055: PUSH
70056: LD_INT 2
70058: PUSH
70059: LD_INT 3
70061: PUSH
70062: LD_INT 4
70064: PUSH
70065: LD_INT 5
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: ST_TO_ADDR
70075: GO 71006
70077: LD_INT 11
70079: DOUBLE
70080: EQUAL
70081: IFTRUE 70085
70083: GO 70115
70085: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70086: LD_ADDR_VAR 0 3
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: LD_INT 2
70096: PUSH
70097: LD_INT 3
70099: PUSH
70100: LD_INT 4
70102: PUSH
70103: LD_INT 5
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: ST_TO_ADDR
70113: GO 71006
70115: LD_INT 4
70117: DOUBLE
70118: EQUAL
70119: IFTRUE 70123
70121: GO 70149
70123: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70124: LD_ADDR_VAR 0 3
70128: PUSH
70129: LD_INT 2
70131: PUSH
70132: LD_INT 3
70134: PUSH
70135: LD_INT 4
70137: PUSH
70138: LD_INT 5
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: ST_TO_ADDR
70147: GO 71006
70149: LD_INT 5
70151: DOUBLE
70152: EQUAL
70153: IFTRUE 70157
70155: GO 70183
70157: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70158: LD_ADDR_VAR 0 3
70162: PUSH
70163: LD_INT 2
70165: PUSH
70166: LD_INT 3
70168: PUSH
70169: LD_INT 4
70171: PUSH
70172: LD_INT 5
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: LIST
70179: LIST
70180: ST_TO_ADDR
70181: GO 71006
70183: LD_INT 9
70185: DOUBLE
70186: EQUAL
70187: IFTRUE 70191
70189: GO 70217
70191: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70192: LD_ADDR_VAR 0 3
70196: PUSH
70197: LD_INT 2
70199: PUSH
70200: LD_INT 3
70202: PUSH
70203: LD_INT 4
70205: PUSH
70206: LD_INT 5
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: ST_TO_ADDR
70215: GO 71006
70217: LD_INT 7
70219: DOUBLE
70220: EQUAL
70221: IFTRUE 70225
70223: GO 70251
70225: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70226: LD_ADDR_VAR 0 3
70230: PUSH
70231: LD_INT 2
70233: PUSH
70234: LD_INT 3
70236: PUSH
70237: LD_INT 4
70239: PUSH
70240: LD_INT 5
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: ST_TO_ADDR
70249: GO 71006
70251: LD_INT 12
70253: DOUBLE
70254: EQUAL
70255: IFTRUE 70259
70257: GO 70285
70259: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70260: LD_ADDR_VAR 0 3
70264: PUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 3
70270: PUSH
70271: LD_INT 4
70273: PUSH
70274: LD_INT 5
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: ST_TO_ADDR
70283: GO 71006
70285: LD_INT 13
70287: DOUBLE
70288: EQUAL
70289: IFTRUE 70293
70291: GO 70319
70293: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70294: LD_ADDR_VAR 0 3
70298: PUSH
70299: LD_INT 2
70301: PUSH
70302: LD_INT 3
70304: PUSH
70305: LD_INT 4
70307: PUSH
70308: LD_INT 5
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: ST_TO_ADDR
70317: GO 71006
70319: LD_INT 14
70321: DOUBLE
70322: EQUAL
70323: IFTRUE 70327
70325: GO 70345
70327: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70328: LD_ADDR_VAR 0 3
70332: PUSH
70333: LD_INT 4
70335: PUSH
70336: LD_INT 5
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: ST_TO_ADDR
70343: GO 71006
70345: LD_INT 6
70347: DOUBLE
70348: EQUAL
70349: IFTRUE 70353
70351: GO 70371
70353: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70354: LD_ADDR_VAR 0 3
70358: PUSH
70359: LD_INT 4
70361: PUSH
70362: LD_INT 5
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: ST_TO_ADDR
70369: GO 71006
70371: LD_INT 10
70373: DOUBLE
70374: EQUAL
70375: IFTRUE 70379
70377: GO 70397
70379: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70380: LD_ADDR_VAR 0 3
70384: PUSH
70385: LD_INT 4
70387: PUSH
70388: LD_INT 5
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: ST_TO_ADDR
70395: GO 71006
70397: LD_INT 22
70399: DOUBLE
70400: EQUAL
70401: IFTRUE 70405
70403: GO 70431
70405: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70406: LD_ADDR_VAR 0 3
70410: PUSH
70411: LD_INT 11
70413: PUSH
70414: LD_INT 12
70416: PUSH
70417: LD_INT 13
70419: PUSH
70420: LD_INT 14
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: ST_TO_ADDR
70429: GO 71006
70431: LD_INT 23
70433: DOUBLE
70434: EQUAL
70435: IFTRUE 70439
70437: GO 70465
70439: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70440: LD_ADDR_VAR 0 3
70444: PUSH
70445: LD_INT 11
70447: PUSH
70448: LD_INT 12
70450: PUSH
70451: LD_INT 13
70453: PUSH
70454: LD_INT 14
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: ST_TO_ADDR
70463: GO 71006
70465: LD_INT 24
70467: DOUBLE
70468: EQUAL
70469: IFTRUE 70473
70471: GO 70499
70473: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70474: LD_ADDR_VAR 0 3
70478: PUSH
70479: LD_INT 11
70481: PUSH
70482: LD_INT 12
70484: PUSH
70485: LD_INT 13
70487: PUSH
70488: LD_INT 14
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: LIST
70495: LIST
70496: ST_TO_ADDR
70497: GO 71006
70499: LD_INT 30
70501: DOUBLE
70502: EQUAL
70503: IFTRUE 70507
70505: GO 70533
70507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70508: LD_ADDR_VAR 0 3
70512: PUSH
70513: LD_INT 11
70515: PUSH
70516: LD_INT 12
70518: PUSH
70519: LD_INT 13
70521: PUSH
70522: LD_INT 14
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: ST_TO_ADDR
70531: GO 71006
70533: LD_INT 25
70535: DOUBLE
70536: EQUAL
70537: IFTRUE 70541
70539: GO 70559
70541: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70542: LD_ADDR_VAR 0 3
70546: PUSH
70547: LD_INT 13
70549: PUSH
70550: LD_INT 14
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: ST_TO_ADDR
70557: GO 71006
70559: LD_INT 27
70561: DOUBLE
70562: EQUAL
70563: IFTRUE 70567
70565: GO 70585
70567: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70568: LD_ADDR_VAR 0 3
70572: PUSH
70573: LD_INT 13
70575: PUSH
70576: LD_INT 14
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: ST_TO_ADDR
70583: GO 71006
70585: LD_INT 28
70587: DOUBLE
70588: EQUAL
70589: IFTRUE 70593
70591: GO 70611
70593: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70594: LD_ADDR_VAR 0 3
70598: PUSH
70599: LD_INT 13
70601: PUSH
70602: LD_INT 14
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: ST_TO_ADDR
70609: GO 71006
70611: LD_INT 29
70613: DOUBLE
70614: EQUAL
70615: IFTRUE 70619
70617: GO 70637
70619: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70620: LD_ADDR_VAR 0 3
70624: PUSH
70625: LD_INT 13
70627: PUSH
70628: LD_INT 14
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: ST_TO_ADDR
70635: GO 71006
70637: LD_INT 31
70639: DOUBLE
70640: EQUAL
70641: IFTRUE 70645
70643: GO 70663
70645: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70646: LD_ADDR_VAR 0 3
70650: PUSH
70651: LD_INT 13
70653: PUSH
70654: LD_INT 14
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: ST_TO_ADDR
70661: GO 71006
70663: LD_INT 26
70665: DOUBLE
70666: EQUAL
70667: IFTRUE 70671
70669: GO 70689
70671: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70672: LD_ADDR_VAR 0 3
70676: PUSH
70677: LD_INT 13
70679: PUSH
70680: LD_INT 14
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: ST_TO_ADDR
70687: GO 71006
70689: LD_INT 42
70691: DOUBLE
70692: EQUAL
70693: IFTRUE 70697
70695: GO 70723
70697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70698: LD_ADDR_VAR 0 3
70702: PUSH
70703: LD_INT 21
70705: PUSH
70706: LD_INT 22
70708: PUSH
70709: LD_INT 23
70711: PUSH
70712: LD_INT 24
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: ST_TO_ADDR
70721: GO 71006
70723: LD_INT 43
70725: DOUBLE
70726: EQUAL
70727: IFTRUE 70731
70729: GO 70757
70731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70732: LD_ADDR_VAR 0 3
70736: PUSH
70737: LD_INT 21
70739: PUSH
70740: LD_INT 22
70742: PUSH
70743: LD_INT 23
70745: PUSH
70746: LD_INT 24
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: ST_TO_ADDR
70755: GO 71006
70757: LD_INT 44
70759: DOUBLE
70760: EQUAL
70761: IFTRUE 70765
70763: GO 70791
70765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70766: LD_ADDR_VAR 0 3
70770: PUSH
70771: LD_INT 21
70773: PUSH
70774: LD_INT 22
70776: PUSH
70777: LD_INT 23
70779: PUSH
70780: LD_INT 24
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: ST_TO_ADDR
70789: GO 71006
70791: LD_INT 45
70793: DOUBLE
70794: EQUAL
70795: IFTRUE 70799
70797: GO 70825
70799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70800: LD_ADDR_VAR 0 3
70804: PUSH
70805: LD_INT 21
70807: PUSH
70808: LD_INT 22
70810: PUSH
70811: LD_INT 23
70813: PUSH
70814: LD_INT 24
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: ST_TO_ADDR
70823: GO 71006
70825: LD_INT 49
70827: DOUBLE
70828: EQUAL
70829: IFTRUE 70833
70831: GO 70859
70833: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70834: LD_ADDR_VAR 0 3
70838: PUSH
70839: LD_INT 21
70841: PUSH
70842: LD_INT 22
70844: PUSH
70845: LD_INT 23
70847: PUSH
70848: LD_INT 24
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: ST_TO_ADDR
70857: GO 71006
70859: LD_INT 51
70861: DOUBLE
70862: EQUAL
70863: IFTRUE 70867
70865: GO 70893
70867: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70868: LD_ADDR_VAR 0 3
70872: PUSH
70873: LD_INT 21
70875: PUSH
70876: LD_INT 22
70878: PUSH
70879: LD_INT 23
70881: PUSH
70882: LD_INT 24
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: ST_TO_ADDR
70891: GO 71006
70893: LD_INT 52
70895: DOUBLE
70896: EQUAL
70897: IFTRUE 70901
70899: GO 70927
70901: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70902: LD_ADDR_VAR 0 3
70906: PUSH
70907: LD_INT 21
70909: PUSH
70910: LD_INT 22
70912: PUSH
70913: LD_INT 23
70915: PUSH
70916: LD_INT 24
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: ST_TO_ADDR
70925: GO 71006
70927: LD_INT 53
70929: DOUBLE
70930: EQUAL
70931: IFTRUE 70935
70933: GO 70953
70935: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70936: LD_ADDR_VAR 0 3
70940: PUSH
70941: LD_INT 23
70943: PUSH
70944: LD_INT 24
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: ST_TO_ADDR
70951: GO 71006
70953: LD_INT 46
70955: DOUBLE
70956: EQUAL
70957: IFTRUE 70961
70959: GO 70979
70961: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70962: LD_ADDR_VAR 0 3
70966: PUSH
70967: LD_INT 23
70969: PUSH
70970: LD_INT 24
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: ST_TO_ADDR
70977: GO 71006
70979: LD_INT 47
70981: DOUBLE
70982: EQUAL
70983: IFTRUE 70987
70985: GO 71005
70987: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70988: LD_ADDR_VAR 0 3
70992: PUSH
70993: LD_INT 23
70995: PUSH
70996: LD_INT 24
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: ST_TO_ADDR
71003: GO 71006
71005: POP
// result := ( chassis in result ) ;
71006: LD_ADDR_VAR 0 3
71010: PUSH
71011: LD_VAR 0 1
71015: PUSH
71016: LD_VAR 0 3
71020: IN
71021: ST_TO_ADDR
// end ;
71022: LD_VAR 0 3
71026: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71027: LD_INT 0
71029: PPUSH
71030: PPUSH
71031: PPUSH
71032: PPUSH
71033: PPUSH
71034: PPUSH
71035: PPUSH
// result := array ;
71036: LD_ADDR_VAR 0 5
71040: PUSH
71041: LD_VAR 0 1
71045: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71046: LD_VAR 0 1
71050: NOT
71051: PUSH
71052: LD_VAR 0 2
71056: NOT
71057: OR
71058: PUSH
71059: LD_VAR 0 3
71063: NOT
71064: OR
71065: PUSH
71066: LD_VAR 0 2
71070: PUSH
71071: LD_VAR 0 1
71075: GREATER
71076: OR
71077: PUSH
71078: LD_VAR 0 3
71082: PUSH
71083: LD_VAR 0 1
71087: GREATER
71088: OR
71089: IFFALSE 71093
// exit ;
71091: GO 71389
// if direction then
71093: LD_VAR 0 4
71097: IFFALSE 71161
// begin d := 1 ;
71099: LD_ADDR_VAR 0 9
71103: PUSH
71104: LD_INT 1
71106: ST_TO_ADDR
// if i_from > i_to then
71107: LD_VAR 0 2
71111: PUSH
71112: LD_VAR 0 3
71116: GREATER
71117: IFFALSE 71143
// length := ( array - i_from ) + i_to else
71119: LD_ADDR_VAR 0 11
71123: PUSH
71124: LD_VAR 0 1
71128: PUSH
71129: LD_VAR 0 2
71133: MINUS
71134: PUSH
71135: LD_VAR 0 3
71139: PLUS
71140: ST_TO_ADDR
71141: GO 71159
// length := i_to - i_from ;
71143: LD_ADDR_VAR 0 11
71147: PUSH
71148: LD_VAR 0 3
71152: PUSH
71153: LD_VAR 0 2
71157: MINUS
71158: ST_TO_ADDR
// end else
71159: GO 71222
// begin d := - 1 ;
71161: LD_ADDR_VAR 0 9
71165: PUSH
71166: LD_INT 1
71168: NEG
71169: ST_TO_ADDR
// if i_from > i_to then
71170: LD_VAR 0 2
71174: PUSH
71175: LD_VAR 0 3
71179: GREATER
71180: IFFALSE 71200
// length := i_from - i_to else
71182: LD_ADDR_VAR 0 11
71186: PUSH
71187: LD_VAR 0 2
71191: PUSH
71192: LD_VAR 0 3
71196: MINUS
71197: ST_TO_ADDR
71198: GO 71222
// length := ( array - i_to ) + i_from ;
71200: LD_ADDR_VAR 0 11
71204: PUSH
71205: LD_VAR 0 1
71209: PUSH
71210: LD_VAR 0 3
71214: MINUS
71215: PUSH
71216: LD_VAR 0 2
71220: PLUS
71221: ST_TO_ADDR
// end ; if not length then
71222: LD_VAR 0 11
71226: NOT
71227: IFFALSE 71231
// exit ;
71229: GO 71389
// tmp := array ;
71231: LD_ADDR_VAR 0 10
71235: PUSH
71236: LD_VAR 0 1
71240: ST_TO_ADDR
// for i = 1 to length do
71241: LD_ADDR_VAR 0 6
71245: PUSH
71246: DOUBLE
71247: LD_INT 1
71249: DEC
71250: ST_TO_ADDR
71251: LD_VAR 0 11
71255: PUSH
71256: FOR_TO
71257: IFFALSE 71377
// begin for j = 1 to array do
71259: LD_ADDR_VAR 0 7
71263: PUSH
71264: DOUBLE
71265: LD_INT 1
71267: DEC
71268: ST_TO_ADDR
71269: LD_VAR 0 1
71273: PUSH
71274: FOR_TO
71275: IFFALSE 71363
// begin k := j + d ;
71277: LD_ADDR_VAR 0 8
71281: PUSH
71282: LD_VAR 0 7
71286: PUSH
71287: LD_VAR 0 9
71291: PLUS
71292: ST_TO_ADDR
// if k > array then
71293: LD_VAR 0 8
71297: PUSH
71298: LD_VAR 0 1
71302: GREATER
71303: IFFALSE 71313
// k := 1 ;
71305: LD_ADDR_VAR 0 8
71309: PUSH
71310: LD_INT 1
71312: ST_TO_ADDR
// if not k then
71313: LD_VAR 0 8
71317: NOT
71318: IFFALSE 71330
// k := array ;
71320: LD_ADDR_VAR 0 8
71324: PUSH
71325: LD_VAR 0 1
71329: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71330: LD_ADDR_VAR 0 10
71334: PUSH
71335: LD_VAR 0 10
71339: PPUSH
71340: LD_VAR 0 8
71344: PPUSH
71345: LD_VAR 0 1
71349: PUSH
71350: LD_VAR 0 7
71354: ARRAY
71355: PPUSH
71356: CALL_OW 1
71360: ST_TO_ADDR
// end ;
71361: GO 71274
71363: POP
71364: POP
// array := tmp ;
71365: LD_ADDR_VAR 0 1
71369: PUSH
71370: LD_VAR 0 10
71374: ST_TO_ADDR
// end ;
71375: GO 71256
71377: POP
71378: POP
// result := array ;
71379: LD_ADDR_VAR 0 5
71383: PUSH
71384: LD_VAR 0 1
71388: ST_TO_ADDR
// end ;
71389: LD_VAR 0 5
71393: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71394: LD_INT 0
71396: PPUSH
71397: PPUSH
// result := 0 ;
71398: LD_ADDR_VAR 0 3
71402: PUSH
71403: LD_INT 0
71405: ST_TO_ADDR
// if not array or not value in array then
71406: LD_VAR 0 1
71410: NOT
71411: PUSH
71412: LD_VAR 0 2
71416: PUSH
71417: LD_VAR 0 1
71421: IN
71422: NOT
71423: OR
71424: IFFALSE 71428
// exit ;
71426: GO 71482
// for i = 1 to array do
71428: LD_ADDR_VAR 0 4
71432: PUSH
71433: DOUBLE
71434: LD_INT 1
71436: DEC
71437: ST_TO_ADDR
71438: LD_VAR 0 1
71442: PUSH
71443: FOR_TO
71444: IFFALSE 71480
// if value = array [ i ] then
71446: LD_VAR 0 2
71450: PUSH
71451: LD_VAR 0 1
71455: PUSH
71456: LD_VAR 0 4
71460: ARRAY
71461: EQUAL
71462: IFFALSE 71478
// begin result := i ;
71464: LD_ADDR_VAR 0 3
71468: PUSH
71469: LD_VAR 0 4
71473: ST_TO_ADDR
// exit ;
71474: POP
71475: POP
71476: GO 71482
// end ;
71478: GO 71443
71480: POP
71481: POP
// end ;
71482: LD_VAR 0 3
71486: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71487: LD_INT 0
71489: PPUSH
// vc_chassis := chassis ;
71490: LD_ADDR_OWVAR 37
71494: PUSH
71495: LD_VAR 0 1
71499: ST_TO_ADDR
// vc_engine := engine ;
71500: LD_ADDR_OWVAR 39
71504: PUSH
71505: LD_VAR 0 2
71509: ST_TO_ADDR
// vc_control := control ;
71510: LD_ADDR_OWVAR 38
71514: PUSH
71515: LD_VAR 0 3
71519: ST_TO_ADDR
// vc_weapon := weapon ;
71520: LD_ADDR_OWVAR 40
71524: PUSH
71525: LD_VAR 0 4
71529: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71530: LD_ADDR_OWVAR 41
71534: PUSH
71535: LD_VAR 0 5
71539: ST_TO_ADDR
// end ;
71540: LD_VAR 0 6
71544: RET
// export function WantPlant ( unit ) ; var task ; begin
71545: LD_INT 0
71547: PPUSH
71548: PPUSH
// result := false ;
71549: LD_ADDR_VAR 0 2
71553: PUSH
71554: LD_INT 0
71556: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71557: LD_ADDR_VAR 0 3
71561: PUSH
71562: LD_VAR 0 1
71566: PPUSH
71567: CALL_OW 437
71571: ST_TO_ADDR
// if task then
71572: LD_VAR 0 3
71576: IFFALSE 71604
// if task [ 1 ] [ 1 ] = p then
71578: LD_VAR 0 3
71582: PUSH
71583: LD_INT 1
71585: ARRAY
71586: PUSH
71587: LD_INT 1
71589: ARRAY
71590: PUSH
71591: LD_STRING p
71593: EQUAL
71594: IFFALSE 71604
// result := true ;
71596: LD_ADDR_VAR 0 2
71600: PUSH
71601: LD_INT 1
71603: ST_TO_ADDR
// end ;
71604: LD_VAR 0 2
71608: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71609: LD_INT 0
71611: PPUSH
71612: PPUSH
71613: PPUSH
71614: PPUSH
// if pos < 1 then
71615: LD_VAR 0 2
71619: PUSH
71620: LD_INT 1
71622: LESS
71623: IFFALSE 71627
// exit ;
71625: GO 71930
// if pos = 1 then
71627: LD_VAR 0 2
71631: PUSH
71632: LD_INT 1
71634: EQUAL
71635: IFFALSE 71668
// result := Replace ( arr , pos [ 1 ] , value ) else
71637: LD_ADDR_VAR 0 4
71641: PUSH
71642: LD_VAR 0 1
71646: PPUSH
71647: LD_VAR 0 2
71651: PUSH
71652: LD_INT 1
71654: ARRAY
71655: PPUSH
71656: LD_VAR 0 3
71660: PPUSH
71661: CALL_OW 1
71665: ST_TO_ADDR
71666: GO 71930
// begin tmp := arr ;
71668: LD_ADDR_VAR 0 6
71672: PUSH
71673: LD_VAR 0 1
71677: ST_TO_ADDR
// s_arr := [ tmp ] ;
71678: LD_ADDR_VAR 0 7
71682: PUSH
71683: LD_VAR 0 6
71687: PUSH
71688: EMPTY
71689: LIST
71690: ST_TO_ADDR
// for i = 1 to pos - 1 do
71691: LD_ADDR_VAR 0 5
71695: PUSH
71696: DOUBLE
71697: LD_INT 1
71699: DEC
71700: ST_TO_ADDR
71701: LD_VAR 0 2
71705: PUSH
71706: LD_INT 1
71708: MINUS
71709: PUSH
71710: FOR_TO
71711: IFFALSE 71756
// begin tmp := tmp [ pos [ i ] ] ;
71713: LD_ADDR_VAR 0 6
71717: PUSH
71718: LD_VAR 0 6
71722: PUSH
71723: LD_VAR 0 2
71727: PUSH
71728: LD_VAR 0 5
71732: ARRAY
71733: ARRAY
71734: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71735: LD_ADDR_VAR 0 7
71739: PUSH
71740: LD_VAR 0 7
71744: PUSH
71745: LD_VAR 0 6
71749: PUSH
71750: EMPTY
71751: LIST
71752: ADD
71753: ST_TO_ADDR
// end ;
71754: GO 71710
71756: POP
71757: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71758: LD_ADDR_VAR 0 6
71762: PUSH
71763: LD_VAR 0 6
71767: PPUSH
71768: LD_VAR 0 2
71772: PUSH
71773: LD_VAR 0 2
71777: ARRAY
71778: PPUSH
71779: LD_VAR 0 3
71783: PPUSH
71784: CALL_OW 1
71788: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71789: LD_ADDR_VAR 0 7
71793: PUSH
71794: LD_VAR 0 7
71798: PPUSH
71799: LD_VAR 0 7
71803: PPUSH
71804: LD_VAR 0 6
71808: PPUSH
71809: CALL_OW 1
71813: ST_TO_ADDR
// for i = s_arr downto 2 do
71814: LD_ADDR_VAR 0 5
71818: PUSH
71819: DOUBLE
71820: LD_VAR 0 7
71824: INC
71825: ST_TO_ADDR
71826: LD_INT 2
71828: PUSH
71829: FOR_DOWNTO
71830: IFFALSE 71914
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71832: LD_ADDR_VAR 0 6
71836: PUSH
71837: LD_VAR 0 7
71841: PUSH
71842: LD_VAR 0 5
71846: PUSH
71847: LD_INT 1
71849: MINUS
71850: ARRAY
71851: PPUSH
71852: LD_VAR 0 2
71856: PUSH
71857: LD_VAR 0 5
71861: PUSH
71862: LD_INT 1
71864: MINUS
71865: ARRAY
71866: PPUSH
71867: LD_VAR 0 7
71871: PUSH
71872: LD_VAR 0 5
71876: ARRAY
71877: PPUSH
71878: CALL_OW 1
71882: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71883: LD_ADDR_VAR 0 7
71887: PUSH
71888: LD_VAR 0 7
71892: PPUSH
71893: LD_VAR 0 5
71897: PUSH
71898: LD_INT 1
71900: MINUS
71901: PPUSH
71902: LD_VAR 0 6
71906: PPUSH
71907: CALL_OW 1
71911: ST_TO_ADDR
// end ;
71912: GO 71829
71914: POP
71915: POP
// result := s_arr [ 1 ] ;
71916: LD_ADDR_VAR 0 4
71920: PUSH
71921: LD_VAR 0 7
71925: PUSH
71926: LD_INT 1
71928: ARRAY
71929: ST_TO_ADDR
// end ; end ;
71930: LD_VAR 0 4
71934: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71935: LD_INT 0
71937: PPUSH
71938: PPUSH
// if not list then
71939: LD_VAR 0 1
71943: NOT
71944: IFFALSE 71948
// exit ;
71946: GO 72039
// i := list [ pos1 ] ;
71948: LD_ADDR_VAR 0 5
71952: PUSH
71953: LD_VAR 0 1
71957: PUSH
71958: LD_VAR 0 2
71962: ARRAY
71963: ST_TO_ADDR
// if not i then
71964: LD_VAR 0 5
71968: NOT
71969: IFFALSE 71973
// exit ;
71971: GO 72039
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71973: LD_ADDR_VAR 0 1
71977: PUSH
71978: LD_VAR 0 1
71982: PPUSH
71983: LD_VAR 0 2
71987: PPUSH
71988: LD_VAR 0 1
71992: PUSH
71993: LD_VAR 0 3
71997: ARRAY
71998: PPUSH
71999: CALL_OW 1
72003: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72004: LD_ADDR_VAR 0 1
72008: PUSH
72009: LD_VAR 0 1
72013: PPUSH
72014: LD_VAR 0 3
72018: PPUSH
72019: LD_VAR 0 5
72023: PPUSH
72024: CALL_OW 1
72028: ST_TO_ADDR
// result := list ;
72029: LD_ADDR_VAR 0 4
72033: PUSH
72034: LD_VAR 0 1
72038: ST_TO_ADDR
// end ;
72039: LD_VAR 0 4
72043: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72044: LD_INT 0
72046: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72047: LD_ADDR_VAR 0 5
72051: PUSH
72052: LD_VAR 0 1
72056: PPUSH
72057: CALL_OW 250
72061: PPUSH
72062: LD_VAR 0 1
72066: PPUSH
72067: CALL_OW 251
72071: PPUSH
72072: LD_VAR 0 2
72076: PPUSH
72077: LD_VAR 0 3
72081: PPUSH
72082: LD_VAR 0 4
72086: PPUSH
72087: CALL 72097 0 5
72091: ST_TO_ADDR
// end ;
72092: LD_VAR 0 5
72096: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72097: LD_INT 0
72099: PPUSH
72100: PPUSH
72101: PPUSH
72102: PPUSH
// if not list then
72103: LD_VAR 0 3
72107: NOT
72108: IFFALSE 72112
// exit ;
72110: GO 72500
// result := [ ] ;
72112: LD_ADDR_VAR 0 6
72116: PUSH
72117: EMPTY
72118: ST_TO_ADDR
// for i in list do
72119: LD_ADDR_VAR 0 7
72123: PUSH
72124: LD_VAR 0 3
72128: PUSH
72129: FOR_IN
72130: IFFALSE 72332
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72132: LD_ADDR_VAR 0 9
72136: PUSH
72137: LD_VAR 0 7
72141: PPUSH
72142: LD_VAR 0 1
72146: PPUSH
72147: LD_VAR 0 2
72151: PPUSH
72152: CALL_OW 297
72156: ST_TO_ADDR
// if not result then
72157: LD_VAR 0 6
72161: NOT
72162: IFFALSE 72188
// result := [ [ i , tmp ] ] else
72164: LD_ADDR_VAR 0 6
72168: PUSH
72169: LD_VAR 0 7
72173: PUSH
72174: LD_VAR 0 9
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: EMPTY
72184: LIST
72185: ST_TO_ADDR
72186: GO 72330
// begin if result [ result ] [ 2 ] < tmp then
72188: LD_VAR 0 6
72192: PUSH
72193: LD_VAR 0 6
72197: ARRAY
72198: PUSH
72199: LD_INT 2
72201: ARRAY
72202: PUSH
72203: LD_VAR 0 9
72207: LESS
72208: IFFALSE 72250
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72210: LD_ADDR_VAR 0 6
72214: PUSH
72215: LD_VAR 0 6
72219: PPUSH
72220: LD_VAR 0 6
72224: PUSH
72225: LD_INT 1
72227: PLUS
72228: PPUSH
72229: LD_VAR 0 7
72233: PUSH
72234: LD_VAR 0 9
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PPUSH
72243: CALL_OW 2
72247: ST_TO_ADDR
72248: GO 72330
// for j = 1 to result do
72250: LD_ADDR_VAR 0 8
72254: PUSH
72255: DOUBLE
72256: LD_INT 1
72258: DEC
72259: ST_TO_ADDR
72260: LD_VAR 0 6
72264: PUSH
72265: FOR_TO
72266: IFFALSE 72328
// begin if tmp < result [ j ] [ 2 ] then
72268: LD_VAR 0 9
72272: PUSH
72273: LD_VAR 0 6
72277: PUSH
72278: LD_VAR 0 8
72282: ARRAY
72283: PUSH
72284: LD_INT 2
72286: ARRAY
72287: LESS
72288: IFFALSE 72326
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72290: LD_ADDR_VAR 0 6
72294: PUSH
72295: LD_VAR 0 6
72299: PPUSH
72300: LD_VAR 0 8
72304: PPUSH
72305: LD_VAR 0 7
72309: PUSH
72310: LD_VAR 0 9
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PPUSH
72319: CALL_OW 2
72323: ST_TO_ADDR
// break ;
72324: GO 72328
// end ; end ;
72326: GO 72265
72328: POP
72329: POP
// end ; end ;
72330: GO 72129
72332: POP
72333: POP
// if result and not asc then
72334: LD_VAR 0 6
72338: PUSH
72339: LD_VAR 0 4
72343: NOT
72344: AND
72345: IFFALSE 72420
// begin tmp := result ;
72347: LD_ADDR_VAR 0 9
72351: PUSH
72352: LD_VAR 0 6
72356: ST_TO_ADDR
// for i = tmp downto 1 do
72357: LD_ADDR_VAR 0 7
72361: PUSH
72362: DOUBLE
72363: LD_VAR 0 9
72367: INC
72368: ST_TO_ADDR
72369: LD_INT 1
72371: PUSH
72372: FOR_DOWNTO
72373: IFFALSE 72418
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72375: LD_ADDR_VAR 0 6
72379: PUSH
72380: LD_VAR 0 6
72384: PPUSH
72385: LD_VAR 0 9
72389: PUSH
72390: LD_VAR 0 7
72394: MINUS
72395: PUSH
72396: LD_INT 1
72398: PLUS
72399: PPUSH
72400: LD_VAR 0 9
72404: PUSH
72405: LD_VAR 0 7
72409: ARRAY
72410: PPUSH
72411: CALL_OW 1
72415: ST_TO_ADDR
72416: GO 72372
72418: POP
72419: POP
// end ; tmp := [ ] ;
72420: LD_ADDR_VAR 0 9
72424: PUSH
72425: EMPTY
72426: ST_TO_ADDR
// if mode then
72427: LD_VAR 0 5
72431: IFFALSE 72500
// begin for i = 1 to result do
72433: LD_ADDR_VAR 0 7
72437: PUSH
72438: DOUBLE
72439: LD_INT 1
72441: DEC
72442: ST_TO_ADDR
72443: LD_VAR 0 6
72447: PUSH
72448: FOR_TO
72449: IFFALSE 72488
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72451: LD_ADDR_VAR 0 9
72455: PUSH
72456: LD_VAR 0 9
72460: PPUSH
72461: LD_VAR 0 7
72465: PPUSH
72466: LD_VAR 0 6
72470: PUSH
72471: LD_VAR 0 7
72475: ARRAY
72476: PUSH
72477: LD_INT 1
72479: ARRAY
72480: PPUSH
72481: CALL_OW 1
72485: ST_TO_ADDR
72486: GO 72448
72488: POP
72489: POP
// result := tmp ;
72490: LD_ADDR_VAR 0 6
72494: PUSH
72495: LD_VAR 0 9
72499: ST_TO_ADDR
// end ; end ;
72500: LD_VAR 0 6
72504: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72505: LD_INT 0
72507: PPUSH
72508: PPUSH
72509: PPUSH
72510: PPUSH
72511: PPUSH
72512: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72513: LD_ADDR_VAR 0 5
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: LD_INT 0
72523: PUSH
72524: LD_INT 0
72526: PUSH
72527: EMPTY
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: LIST
72533: LIST
72534: ST_TO_ADDR
// if not x or not y then
72535: LD_VAR 0 2
72539: NOT
72540: PUSH
72541: LD_VAR 0 3
72545: NOT
72546: OR
72547: IFFALSE 72551
// exit ;
72549: GO 74197
// if not range then
72551: LD_VAR 0 4
72555: NOT
72556: IFFALSE 72566
// range := 10 ;
72558: LD_ADDR_VAR 0 4
72562: PUSH
72563: LD_INT 10
72565: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72566: LD_ADDR_VAR 0 8
72570: PUSH
72571: LD_INT 81
72573: PUSH
72574: LD_VAR 0 1
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 92
72585: PUSH
72586: LD_VAR 0 2
72590: PUSH
72591: LD_VAR 0 3
72595: PUSH
72596: LD_VAR 0 4
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: LIST
72605: LIST
72606: PUSH
72607: LD_INT 3
72609: PUSH
72610: LD_INT 21
72612: PUSH
72613: LD_INT 3
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: LIST
72628: PPUSH
72629: CALL_OW 69
72633: ST_TO_ADDR
// if not tmp then
72634: LD_VAR 0 8
72638: NOT
72639: IFFALSE 72643
// exit ;
72641: GO 74197
// for i in tmp do
72643: LD_ADDR_VAR 0 6
72647: PUSH
72648: LD_VAR 0 8
72652: PUSH
72653: FOR_IN
72654: IFFALSE 74172
// begin points := [ 0 , 0 , 0 ] ;
72656: LD_ADDR_VAR 0 9
72660: PUSH
72661: LD_INT 0
72663: PUSH
72664: LD_INT 0
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: LIST
72674: ST_TO_ADDR
// bpoints := 1 ;
72675: LD_ADDR_VAR 0 10
72679: PUSH
72680: LD_INT 1
72682: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72683: LD_VAR 0 6
72687: PPUSH
72688: CALL_OW 247
72692: PUSH
72693: LD_INT 1
72695: DOUBLE
72696: EQUAL
72697: IFTRUE 72701
72699: GO 73279
72701: POP
// begin if GetClass ( i ) = 1 then
72702: LD_VAR 0 6
72706: PPUSH
72707: CALL_OW 257
72711: PUSH
72712: LD_INT 1
72714: EQUAL
72715: IFFALSE 72736
// points := [ 10 , 5 , 3 ] ;
72717: LD_ADDR_VAR 0 9
72721: PUSH
72722: LD_INT 10
72724: PUSH
72725: LD_INT 5
72727: PUSH
72728: LD_INT 3
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: LIST
72735: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72736: LD_VAR 0 6
72740: PPUSH
72741: CALL_OW 257
72745: PUSH
72746: LD_INT 2
72748: PUSH
72749: LD_INT 3
72751: PUSH
72752: LD_INT 4
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: LIST
72759: IN
72760: IFFALSE 72781
// points := [ 3 , 2 , 1 ] ;
72762: LD_ADDR_VAR 0 9
72766: PUSH
72767: LD_INT 3
72769: PUSH
72770: LD_INT 2
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: LIST
72780: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72781: LD_VAR 0 6
72785: PPUSH
72786: CALL_OW 257
72790: PUSH
72791: LD_INT 5
72793: EQUAL
72794: IFFALSE 72815
// points := [ 130 , 5 , 2 ] ;
72796: LD_ADDR_VAR 0 9
72800: PUSH
72801: LD_INT 130
72803: PUSH
72804: LD_INT 5
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: LIST
72814: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72815: LD_VAR 0 6
72819: PPUSH
72820: CALL_OW 257
72824: PUSH
72825: LD_INT 8
72827: EQUAL
72828: IFFALSE 72849
// points := [ 35 , 35 , 30 ] ;
72830: LD_ADDR_VAR 0 9
72834: PUSH
72835: LD_INT 35
72837: PUSH
72838: LD_INT 35
72840: PUSH
72841: LD_INT 30
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: LIST
72848: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72849: LD_VAR 0 6
72853: PPUSH
72854: CALL_OW 257
72858: PUSH
72859: LD_INT 9
72861: EQUAL
72862: IFFALSE 72883
// points := [ 20 , 55 , 40 ] ;
72864: LD_ADDR_VAR 0 9
72868: PUSH
72869: LD_INT 20
72871: PUSH
72872: LD_INT 55
72874: PUSH
72875: LD_INT 40
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: LIST
72882: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72883: LD_VAR 0 6
72887: PPUSH
72888: CALL_OW 257
72892: PUSH
72893: LD_INT 12
72895: PUSH
72896: LD_INT 16
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: IN
72903: IFFALSE 72924
// points := [ 5 , 3 , 2 ] ;
72905: LD_ADDR_VAR 0 9
72909: PUSH
72910: LD_INT 5
72912: PUSH
72913: LD_INT 3
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: LIST
72923: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72924: LD_VAR 0 6
72928: PPUSH
72929: CALL_OW 257
72933: PUSH
72934: LD_INT 17
72936: EQUAL
72937: IFFALSE 72958
// points := [ 100 , 50 , 75 ] ;
72939: LD_ADDR_VAR 0 9
72943: PUSH
72944: LD_INT 100
72946: PUSH
72947: LD_INT 50
72949: PUSH
72950: LD_INT 75
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: LIST
72957: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72958: LD_VAR 0 6
72962: PPUSH
72963: CALL_OW 257
72967: PUSH
72968: LD_INT 15
72970: EQUAL
72971: IFFALSE 72992
// points := [ 10 , 5 , 3 ] ;
72973: LD_ADDR_VAR 0 9
72977: PUSH
72978: LD_INT 10
72980: PUSH
72981: LD_INT 5
72983: PUSH
72984: LD_INT 3
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: LIST
72991: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72992: LD_VAR 0 6
72996: PPUSH
72997: CALL_OW 257
73001: PUSH
73002: LD_INT 14
73004: EQUAL
73005: IFFALSE 73026
// points := [ 10 , 0 , 0 ] ;
73007: LD_ADDR_VAR 0 9
73011: PUSH
73012: LD_INT 10
73014: PUSH
73015: LD_INT 0
73017: PUSH
73018: LD_INT 0
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: LIST
73025: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73026: LD_VAR 0 6
73030: PPUSH
73031: CALL_OW 257
73035: PUSH
73036: LD_INT 11
73038: EQUAL
73039: IFFALSE 73060
// points := [ 30 , 10 , 5 ] ;
73041: LD_ADDR_VAR 0 9
73045: PUSH
73046: LD_INT 30
73048: PUSH
73049: LD_INT 10
73051: PUSH
73052: LD_INT 5
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: LIST
73059: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73060: LD_VAR 0 1
73064: PPUSH
73065: LD_INT 5
73067: PPUSH
73068: CALL_OW 321
73072: PUSH
73073: LD_INT 2
73075: EQUAL
73076: IFFALSE 73093
// bpoints := bpoints * 1.8 ;
73078: LD_ADDR_VAR 0 10
73082: PUSH
73083: LD_VAR 0 10
73087: PUSH
73088: LD_REAL  1.80000000000000E+0000
73091: MUL
73092: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73093: LD_VAR 0 6
73097: PPUSH
73098: CALL_OW 257
73102: PUSH
73103: LD_INT 1
73105: PUSH
73106: LD_INT 2
73108: PUSH
73109: LD_INT 3
73111: PUSH
73112: LD_INT 4
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: IN
73121: PUSH
73122: LD_VAR 0 1
73126: PPUSH
73127: LD_INT 51
73129: PPUSH
73130: CALL_OW 321
73134: PUSH
73135: LD_INT 2
73137: EQUAL
73138: AND
73139: IFFALSE 73156
// bpoints := bpoints * 1.2 ;
73141: LD_ADDR_VAR 0 10
73145: PUSH
73146: LD_VAR 0 10
73150: PUSH
73151: LD_REAL  1.20000000000000E+0000
73154: MUL
73155: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73156: LD_VAR 0 6
73160: PPUSH
73161: CALL_OW 257
73165: PUSH
73166: LD_INT 5
73168: PUSH
73169: LD_INT 7
73171: PUSH
73172: LD_INT 9
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: LIST
73179: IN
73180: PUSH
73181: LD_VAR 0 1
73185: PPUSH
73186: LD_INT 52
73188: PPUSH
73189: CALL_OW 321
73193: PUSH
73194: LD_INT 2
73196: EQUAL
73197: AND
73198: IFFALSE 73215
// bpoints := bpoints * 1.5 ;
73200: LD_ADDR_VAR 0 10
73204: PUSH
73205: LD_VAR 0 10
73209: PUSH
73210: LD_REAL  1.50000000000000E+0000
73213: MUL
73214: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73215: LD_VAR 0 1
73219: PPUSH
73220: LD_INT 66
73222: PPUSH
73223: CALL_OW 321
73227: PUSH
73228: LD_INT 2
73230: EQUAL
73231: IFFALSE 73248
// bpoints := bpoints * 1.1 ;
73233: LD_ADDR_VAR 0 10
73237: PUSH
73238: LD_VAR 0 10
73242: PUSH
73243: LD_REAL  1.10000000000000E+0000
73246: MUL
73247: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73248: LD_ADDR_VAR 0 10
73252: PUSH
73253: LD_VAR 0 10
73257: PUSH
73258: LD_VAR 0 6
73262: PPUSH
73263: LD_INT 1
73265: PPUSH
73266: CALL_OW 259
73270: PUSH
73271: LD_REAL  1.15000000000000E+0000
73274: MUL
73275: MUL
73276: ST_TO_ADDR
// end ; unit_vehicle :
73277: GO 74101
73279: LD_INT 2
73281: DOUBLE
73282: EQUAL
73283: IFTRUE 73287
73285: GO 74089
73287: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73288: LD_VAR 0 6
73292: PPUSH
73293: CALL_OW 264
73297: PUSH
73298: LD_INT 2
73300: PUSH
73301: LD_INT 42
73303: PUSH
73304: LD_INT 24
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: LIST
73311: IN
73312: IFFALSE 73333
// points := [ 25 , 5 , 3 ] ;
73314: LD_ADDR_VAR 0 9
73318: PUSH
73319: LD_INT 25
73321: PUSH
73322: LD_INT 5
73324: PUSH
73325: LD_INT 3
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: LIST
73332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73333: LD_VAR 0 6
73337: PPUSH
73338: CALL_OW 264
73342: PUSH
73343: LD_INT 4
73345: PUSH
73346: LD_INT 43
73348: PUSH
73349: LD_INT 25
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: LIST
73356: IN
73357: IFFALSE 73378
// points := [ 40 , 15 , 5 ] ;
73359: LD_ADDR_VAR 0 9
73363: PUSH
73364: LD_INT 40
73366: PUSH
73367: LD_INT 15
73369: PUSH
73370: LD_INT 5
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: LIST
73377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73378: LD_VAR 0 6
73382: PPUSH
73383: CALL_OW 264
73387: PUSH
73388: LD_INT 3
73390: PUSH
73391: LD_INT 23
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: IN
73398: IFFALSE 73419
// points := [ 7 , 25 , 8 ] ;
73400: LD_ADDR_VAR 0 9
73404: PUSH
73405: LD_INT 7
73407: PUSH
73408: LD_INT 25
73410: PUSH
73411: LD_INT 8
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: LIST
73418: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73419: LD_VAR 0 6
73423: PPUSH
73424: CALL_OW 264
73428: PUSH
73429: LD_INT 5
73431: PUSH
73432: LD_INT 27
73434: PUSH
73435: LD_INT 44
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: LIST
73442: IN
73443: IFFALSE 73464
// points := [ 14 , 50 , 16 ] ;
73445: LD_ADDR_VAR 0 9
73449: PUSH
73450: LD_INT 14
73452: PUSH
73453: LD_INT 50
73455: PUSH
73456: LD_INT 16
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73464: LD_VAR 0 6
73468: PPUSH
73469: CALL_OW 264
73473: PUSH
73474: LD_INT 6
73476: PUSH
73477: LD_INT 46
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: IN
73484: IFFALSE 73505
// points := [ 32 , 120 , 70 ] ;
73486: LD_ADDR_VAR 0 9
73490: PUSH
73491: LD_INT 32
73493: PUSH
73494: LD_INT 120
73496: PUSH
73497: LD_INT 70
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: LIST
73504: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73505: LD_VAR 0 6
73509: PPUSH
73510: CALL_OW 264
73514: PUSH
73515: LD_INT 7
73517: PUSH
73518: LD_INT 28
73520: PUSH
73521: LD_INT 45
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: LIST
73528: IN
73529: IFFALSE 73550
// points := [ 35 , 20 , 45 ] ;
73531: LD_ADDR_VAR 0 9
73535: PUSH
73536: LD_INT 35
73538: PUSH
73539: LD_INT 20
73541: PUSH
73542: LD_INT 45
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: LIST
73549: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73550: LD_VAR 0 6
73554: PPUSH
73555: CALL_OW 264
73559: PUSH
73560: LD_INT 47
73562: PUSH
73563: EMPTY
73564: LIST
73565: IN
73566: IFFALSE 73587
// points := [ 67 , 45 , 75 ] ;
73568: LD_ADDR_VAR 0 9
73572: PUSH
73573: LD_INT 67
73575: PUSH
73576: LD_INT 45
73578: PUSH
73579: LD_INT 75
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: LIST
73586: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73587: LD_VAR 0 6
73591: PPUSH
73592: CALL_OW 264
73596: PUSH
73597: LD_INT 26
73599: PUSH
73600: EMPTY
73601: LIST
73602: IN
73603: IFFALSE 73624
// points := [ 120 , 30 , 80 ] ;
73605: LD_ADDR_VAR 0 9
73609: PUSH
73610: LD_INT 120
73612: PUSH
73613: LD_INT 30
73615: PUSH
73616: LD_INT 80
73618: PUSH
73619: EMPTY
73620: LIST
73621: LIST
73622: LIST
73623: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73624: LD_VAR 0 6
73628: PPUSH
73629: CALL_OW 264
73633: PUSH
73634: LD_INT 22
73636: PUSH
73637: EMPTY
73638: LIST
73639: IN
73640: IFFALSE 73661
// points := [ 40 , 1 , 1 ] ;
73642: LD_ADDR_VAR 0 9
73646: PUSH
73647: LD_INT 40
73649: PUSH
73650: LD_INT 1
73652: PUSH
73653: LD_INT 1
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: LIST
73660: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73661: LD_VAR 0 6
73665: PPUSH
73666: CALL_OW 264
73670: PUSH
73671: LD_INT 29
73673: PUSH
73674: EMPTY
73675: LIST
73676: IN
73677: IFFALSE 73698
// points := [ 70 , 200 , 400 ] ;
73679: LD_ADDR_VAR 0 9
73683: PUSH
73684: LD_INT 70
73686: PUSH
73687: LD_INT 200
73689: PUSH
73690: LD_INT 400
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: LIST
73697: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73698: LD_VAR 0 6
73702: PPUSH
73703: CALL_OW 264
73707: PUSH
73708: LD_INT 14
73710: PUSH
73711: LD_INT 53
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: IN
73718: IFFALSE 73739
// points := [ 40 , 10 , 20 ] ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_INT 40
73727: PUSH
73728: LD_INT 10
73730: PUSH
73731: LD_INT 20
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: LIST
73738: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73739: LD_VAR 0 6
73743: PPUSH
73744: CALL_OW 264
73748: PUSH
73749: LD_INT 9
73751: PUSH
73752: EMPTY
73753: LIST
73754: IN
73755: IFFALSE 73776
// points := [ 5 , 70 , 20 ] ;
73757: LD_ADDR_VAR 0 9
73761: PUSH
73762: LD_INT 5
73764: PUSH
73765: LD_INT 70
73767: PUSH
73768: LD_INT 20
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: LIST
73775: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73776: LD_VAR 0 6
73780: PPUSH
73781: CALL_OW 264
73785: PUSH
73786: LD_INT 10
73788: PUSH
73789: EMPTY
73790: LIST
73791: IN
73792: IFFALSE 73813
// points := [ 35 , 110 , 70 ] ;
73794: LD_ADDR_VAR 0 9
73798: PUSH
73799: LD_INT 35
73801: PUSH
73802: LD_INT 110
73804: PUSH
73805: LD_INT 70
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: LIST
73812: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73813: LD_VAR 0 6
73817: PPUSH
73818: CALL_OW 265
73822: PUSH
73823: LD_INT 25
73825: EQUAL
73826: IFFALSE 73847
// points := [ 80 , 65 , 100 ] ;
73828: LD_ADDR_VAR 0 9
73832: PUSH
73833: LD_INT 80
73835: PUSH
73836: LD_INT 65
73838: PUSH
73839: LD_INT 100
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: LIST
73846: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73847: LD_VAR 0 6
73851: PPUSH
73852: CALL_OW 263
73856: PUSH
73857: LD_INT 1
73859: EQUAL
73860: IFFALSE 73895
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73862: LD_ADDR_VAR 0 10
73866: PUSH
73867: LD_VAR 0 10
73871: PUSH
73872: LD_VAR 0 6
73876: PPUSH
73877: CALL_OW 311
73881: PPUSH
73882: LD_INT 3
73884: PPUSH
73885: CALL_OW 259
73889: PUSH
73890: LD_INT 4
73892: MUL
73893: MUL
73894: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73895: LD_VAR 0 6
73899: PPUSH
73900: CALL_OW 263
73904: PUSH
73905: LD_INT 2
73907: EQUAL
73908: IFFALSE 73959
// begin j := IsControledBy ( i ) ;
73910: LD_ADDR_VAR 0 7
73914: PUSH
73915: LD_VAR 0 6
73919: PPUSH
73920: CALL_OW 312
73924: ST_TO_ADDR
// if j then
73925: LD_VAR 0 7
73929: IFFALSE 73959
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73931: LD_ADDR_VAR 0 10
73935: PUSH
73936: LD_VAR 0 10
73940: PUSH
73941: LD_VAR 0 7
73945: PPUSH
73946: LD_INT 3
73948: PPUSH
73949: CALL_OW 259
73953: PUSH
73954: LD_INT 3
73956: MUL
73957: MUL
73958: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73959: LD_VAR 0 6
73963: PPUSH
73964: CALL_OW 264
73968: PUSH
73969: LD_INT 5
73971: PUSH
73972: LD_INT 6
73974: PUSH
73975: LD_INT 46
73977: PUSH
73978: LD_INT 44
73980: PUSH
73981: LD_INT 47
73983: PUSH
73984: LD_INT 45
73986: PUSH
73987: LD_INT 28
73989: PUSH
73990: LD_INT 7
73992: PUSH
73993: LD_INT 27
73995: PUSH
73996: LD_INT 29
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: IN
74011: PUSH
74012: LD_VAR 0 1
74016: PPUSH
74017: LD_INT 52
74019: PPUSH
74020: CALL_OW 321
74024: PUSH
74025: LD_INT 2
74027: EQUAL
74028: AND
74029: IFFALSE 74046
// bpoints := bpoints * 1.2 ;
74031: LD_ADDR_VAR 0 10
74035: PUSH
74036: LD_VAR 0 10
74040: PUSH
74041: LD_REAL  1.20000000000000E+0000
74044: MUL
74045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74046: LD_VAR 0 6
74050: PPUSH
74051: CALL_OW 264
74055: PUSH
74056: LD_INT 6
74058: PUSH
74059: LD_INT 46
74061: PUSH
74062: LD_INT 47
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: LIST
74069: IN
74070: IFFALSE 74087
// bpoints := bpoints * 1.2 ;
74072: LD_ADDR_VAR 0 10
74076: PUSH
74077: LD_VAR 0 10
74081: PUSH
74082: LD_REAL  1.20000000000000E+0000
74085: MUL
74086: ST_TO_ADDR
// end ; unit_building :
74087: GO 74101
74089: LD_INT 3
74091: DOUBLE
74092: EQUAL
74093: IFTRUE 74097
74095: GO 74100
74097: POP
// ; end ;
74098: GO 74101
74100: POP
// for j = 1 to 3 do
74101: LD_ADDR_VAR 0 7
74105: PUSH
74106: DOUBLE
74107: LD_INT 1
74109: DEC
74110: ST_TO_ADDR
74111: LD_INT 3
74113: PUSH
74114: FOR_TO
74115: IFFALSE 74168
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74117: LD_ADDR_VAR 0 5
74121: PUSH
74122: LD_VAR 0 5
74126: PPUSH
74127: LD_VAR 0 7
74131: PPUSH
74132: LD_VAR 0 5
74136: PUSH
74137: LD_VAR 0 7
74141: ARRAY
74142: PUSH
74143: LD_VAR 0 9
74147: PUSH
74148: LD_VAR 0 7
74152: ARRAY
74153: PUSH
74154: LD_VAR 0 10
74158: MUL
74159: PLUS
74160: PPUSH
74161: CALL_OW 1
74165: ST_TO_ADDR
74166: GO 74114
74168: POP
74169: POP
// end ;
74170: GO 72653
74172: POP
74173: POP
// result := Replace ( result , 4 , tmp ) ;
74174: LD_ADDR_VAR 0 5
74178: PUSH
74179: LD_VAR 0 5
74183: PPUSH
74184: LD_INT 4
74186: PPUSH
74187: LD_VAR 0 8
74191: PPUSH
74192: CALL_OW 1
74196: ST_TO_ADDR
// end ;
74197: LD_VAR 0 5
74201: RET
// export function DangerAtRange ( unit , range ) ; begin
74202: LD_INT 0
74204: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74205: LD_ADDR_VAR 0 3
74209: PUSH
74210: LD_VAR 0 1
74214: PPUSH
74215: CALL_OW 255
74219: PPUSH
74220: LD_VAR 0 1
74224: PPUSH
74225: CALL_OW 250
74229: PPUSH
74230: LD_VAR 0 1
74234: PPUSH
74235: CALL_OW 251
74239: PPUSH
74240: LD_VAR 0 2
74244: PPUSH
74245: CALL 72505 0 4
74249: ST_TO_ADDR
// end ;
74250: LD_VAR 0 3
74254: RET
// export function DangerInArea ( side , area ) ; begin
74255: LD_INT 0
74257: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74258: LD_ADDR_VAR 0 3
74262: PUSH
74263: LD_VAR 0 2
74267: PPUSH
74268: LD_INT 81
74270: PUSH
74271: LD_VAR 0 1
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PPUSH
74280: CALL_OW 70
74284: ST_TO_ADDR
// end ;
74285: LD_VAR 0 3
74289: RET
// export function IsExtension ( b ) ; begin
74290: LD_INT 0
74292: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74293: LD_ADDR_VAR 0 2
74297: PUSH
74298: LD_VAR 0 1
74302: PUSH
74303: LD_INT 23
74305: PUSH
74306: LD_INT 20
74308: PUSH
74309: LD_INT 22
74311: PUSH
74312: LD_INT 17
74314: PUSH
74315: LD_INT 24
74317: PUSH
74318: LD_INT 21
74320: PUSH
74321: LD_INT 19
74323: PUSH
74324: LD_INT 16
74326: PUSH
74327: LD_INT 25
74329: PUSH
74330: LD_INT 18
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: IN
74345: ST_TO_ADDR
// end ;
74346: LD_VAR 0 2
74350: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74351: LD_INT 0
74353: PPUSH
74354: PPUSH
74355: PPUSH
// result := [ ] ;
74356: LD_ADDR_VAR 0 3
74360: PUSH
74361: EMPTY
74362: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74363: LD_ADDR_VAR 0 4
74367: PUSH
74368: LD_VAR 0 2
74372: PPUSH
74373: LD_INT 21
74375: PUSH
74376: LD_INT 3
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PPUSH
74383: CALL_OW 70
74387: ST_TO_ADDR
// if not tmp then
74388: LD_VAR 0 4
74392: NOT
74393: IFFALSE 74397
// exit ;
74395: GO 74455
// for i in tmp do
74397: LD_ADDR_VAR 0 5
74401: PUSH
74402: LD_VAR 0 4
74406: PUSH
74407: FOR_IN
74408: IFFALSE 74443
// if GetBase ( i ) <> base then
74410: LD_VAR 0 5
74414: PPUSH
74415: CALL_OW 274
74419: PUSH
74420: LD_VAR 0 1
74424: NONEQUAL
74425: IFFALSE 74441
// ComLinkToBase ( base , i ) ;
74427: LD_VAR 0 1
74431: PPUSH
74432: LD_VAR 0 5
74436: PPUSH
74437: CALL_OW 169
74441: GO 74407
74443: POP
74444: POP
// result := tmp ;
74445: LD_ADDR_VAR 0 3
74449: PUSH
74450: LD_VAR 0 4
74454: ST_TO_ADDR
// end ;
74455: LD_VAR 0 3
74459: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74460: LD_INT 0
74462: PPUSH
74463: PPUSH
// if BuildingStatus ( b ) = bs_build then
74464: LD_VAR 0 2
74468: PPUSH
74469: CALL_OW 461
74473: PUSH
74474: LD_INT 1
74476: EQUAL
74477: IFFALSE 74537
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74479: LD_VAR 0 1
74483: PPUSH
74484: LD_STRING h
74486: PUSH
74487: LD_VAR 0 2
74491: PPUSH
74492: CALL_OW 250
74496: PUSH
74497: LD_VAR 0 2
74501: PPUSH
74502: CALL_OW 251
74506: PUSH
74507: LD_VAR 0 2
74511: PUSH
74512: LD_INT 0
74514: PUSH
74515: LD_INT 0
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: PUSH
74530: EMPTY
74531: LIST
74532: PPUSH
74533: CALL_OW 446
// end ;
74537: LD_VAR 0 3
74541: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74542: LD_INT 0
74544: PPUSH
74545: PPUSH
74546: PPUSH
74547: PPUSH
74548: PPUSH
74549: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74550: LD_VAR 0 1
74554: NOT
74555: PUSH
74556: LD_VAR 0 1
74560: PPUSH
74561: CALL_OW 263
74565: PUSH
74566: LD_INT 2
74568: EQUAL
74569: NOT
74570: OR
74571: IFFALSE 74575
// exit ;
74573: GO 74891
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74575: LD_ADDR_VAR 0 6
74579: PUSH
74580: LD_INT 22
74582: PUSH
74583: LD_VAR 0 1
74587: PPUSH
74588: CALL_OW 255
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 2
74599: PUSH
74600: LD_INT 30
74602: PUSH
74603: LD_INT 36
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 34
74612: PUSH
74613: LD_INT 31
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: LIST
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: PPUSH
74629: CALL_OW 69
74633: ST_TO_ADDR
// if not tmp then
74634: LD_VAR 0 6
74638: NOT
74639: IFFALSE 74643
// exit ;
74641: GO 74891
// result := [ ] ;
74643: LD_ADDR_VAR 0 2
74647: PUSH
74648: EMPTY
74649: ST_TO_ADDR
// for i in tmp do
74650: LD_ADDR_VAR 0 3
74654: PUSH
74655: LD_VAR 0 6
74659: PUSH
74660: FOR_IN
74661: IFFALSE 74732
// begin t := UnitsInside ( i ) ;
74663: LD_ADDR_VAR 0 4
74667: PUSH
74668: LD_VAR 0 3
74672: PPUSH
74673: CALL_OW 313
74677: ST_TO_ADDR
// if t then
74678: LD_VAR 0 4
74682: IFFALSE 74730
// for j in t do
74684: LD_ADDR_VAR 0 7
74688: PUSH
74689: LD_VAR 0 4
74693: PUSH
74694: FOR_IN
74695: IFFALSE 74728
// result := Insert ( result , result + 1 , j ) ;
74697: LD_ADDR_VAR 0 2
74701: PUSH
74702: LD_VAR 0 2
74706: PPUSH
74707: LD_VAR 0 2
74711: PUSH
74712: LD_INT 1
74714: PLUS
74715: PPUSH
74716: LD_VAR 0 7
74720: PPUSH
74721: CALL_OW 2
74725: ST_TO_ADDR
74726: GO 74694
74728: POP
74729: POP
// end ;
74730: GO 74660
74732: POP
74733: POP
// if not result then
74734: LD_VAR 0 2
74738: NOT
74739: IFFALSE 74743
// exit ;
74741: GO 74891
// mech := result [ 1 ] ;
74743: LD_ADDR_VAR 0 5
74747: PUSH
74748: LD_VAR 0 2
74752: PUSH
74753: LD_INT 1
74755: ARRAY
74756: ST_TO_ADDR
// if result > 1 then
74757: LD_VAR 0 2
74761: PUSH
74762: LD_INT 1
74764: GREATER
74765: IFFALSE 74877
// for i = 2 to result do
74767: LD_ADDR_VAR 0 3
74771: PUSH
74772: DOUBLE
74773: LD_INT 2
74775: DEC
74776: ST_TO_ADDR
74777: LD_VAR 0 2
74781: PUSH
74782: FOR_TO
74783: IFFALSE 74875
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74785: LD_ADDR_VAR 0 4
74789: PUSH
74790: LD_VAR 0 2
74794: PUSH
74795: LD_VAR 0 3
74799: ARRAY
74800: PPUSH
74801: LD_INT 3
74803: PPUSH
74804: CALL_OW 259
74808: PUSH
74809: LD_VAR 0 2
74813: PUSH
74814: LD_VAR 0 3
74818: ARRAY
74819: PPUSH
74820: CALL_OW 432
74824: MINUS
74825: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74826: LD_VAR 0 4
74830: PUSH
74831: LD_VAR 0 5
74835: PPUSH
74836: LD_INT 3
74838: PPUSH
74839: CALL_OW 259
74843: PUSH
74844: LD_VAR 0 5
74848: PPUSH
74849: CALL_OW 432
74853: MINUS
74854: GREATEREQUAL
74855: IFFALSE 74873
// mech := result [ i ] ;
74857: LD_ADDR_VAR 0 5
74861: PUSH
74862: LD_VAR 0 2
74866: PUSH
74867: LD_VAR 0 3
74871: ARRAY
74872: ST_TO_ADDR
// end ;
74873: GO 74782
74875: POP
74876: POP
// ComLinkTo ( vehicle , mech ) ;
74877: LD_VAR 0 1
74881: PPUSH
74882: LD_VAR 0 5
74886: PPUSH
74887: CALL_OW 135
// end ;
74891: LD_VAR 0 2
74895: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74896: LD_INT 0
74898: PPUSH
74899: PPUSH
74900: PPUSH
74901: PPUSH
74902: PPUSH
74903: PPUSH
74904: PPUSH
74905: PPUSH
74906: PPUSH
74907: PPUSH
74908: PPUSH
74909: PPUSH
74910: PPUSH
// result := [ ] ;
74911: LD_ADDR_VAR 0 7
74915: PUSH
74916: EMPTY
74917: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74918: LD_VAR 0 1
74922: PPUSH
74923: CALL_OW 266
74927: PUSH
74928: LD_INT 0
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: IN
74938: NOT
74939: IFFALSE 74943
// exit ;
74941: GO 76574
// if name then
74943: LD_VAR 0 3
74947: IFFALSE 74963
// SetBName ( base_dep , name ) ;
74949: LD_VAR 0 1
74953: PPUSH
74954: LD_VAR 0 3
74958: PPUSH
74959: CALL_OW 500
// base := GetBase ( base_dep ) ;
74963: LD_ADDR_VAR 0 15
74967: PUSH
74968: LD_VAR 0 1
74972: PPUSH
74973: CALL_OW 274
74977: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74978: LD_ADDR_VAR 0 16
74982: PUSH
74983: LD_VAR 0 1
74987: PPUSH
74988: CALL_OW 255
74992: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74993: LD_ADDR_VAR 0 17
74997: PUSH
74998: LD_VAR 0 1
75002: PPUSH
75003: CALL_OW 248
75007: ST_TO_ADDR
// if sources then
75008: LD_VAR 0 5
75012: IFFALSE 75059
// for i = 1 to 3 do
75014: LD_ADDR_VAR 0 8
75018: PUSH
75019: DOUBLE
75020: LD_INT 1
75022: DEC
75023: ST_TO_ADDR
75024: LD_INT 3
75026: PUSH
75027: FOR_TO
75028: IFFALSE 75057
// AddResourceType ( base , i , sources [ i ] ) ;
75030: LD_VAR 0 15
75034: PPUSH
75035: LD_VAR 0 8
75039: PPUSH
75040: LD_VAR 0 5
75044: PUSH
75045: LD_VAR 0 8
75049: ARRAY
75050: PPUSH
75051: CALL_OW 276
75055: GO 75027
75057: POP
75058: POP
// buildings := GetBaseBuildings ( base , area ) ;
75059: LD_ADDR_VAR 0 18
75063: PUSH
75064: LD_VAR 0 15
75068: PPUSH
75069: LD_VAR 0 2
75073: PPUSH
75074: CALL 74351 0 2
75078: ST_TO_ADDR
// InitHc ;
75079: CALL_OW 19
// InitUc ;
75083: CALL_OW 18
// uc_side := side ;
75087: LD_ADDR_OWVAR 20
75091: PUSH
75092: LD_VAR 0 16
75096: ST_TO_ADDR
// uc_nation := nation ;
75097: LD_ADDR_OWVAR 21
75101: PUSH
75102: LD_VAR 0 17
75106: ST_TO_ADDR
// if buildings then
75107: LD_VAR 0 18
75111: IFFALSE 76433
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75113: LD_ADDR_VAR 0 19
75117: PUSH
75118: LD_VAR 0 18
75122: PPUSH
75123: LD_INT 2
75125: PUSH
75126: LD_INT 30
75128: PUSH
75129: LD_INT 29
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 30
75138: PUSH
75139: LD_INT 30
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: LIST
75150: PPUSH
75151: CALL_OW 72
75155: ST_TO_ADDR
// if tmp then
75156: LD_VAR 0 19
75160: IFFALSE 75208
// for i in tmp do
75162: LD_ADDR_VAR 0 8
75166: PUSH
75167: LD_VAR 0 19
75171: PUSH
75172: FOR_IN
75173: IFFALSE 75206
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75175: LD_VAR 0 8
75179: PPUSH
75180: CALL_OW 250
75184: PPUSH
75185: LD_VAR 0 8
75189: PPUSH
75190: CALL_OW 251
75194: PPUSH
75195: LD_VAR 0 16
75199: PPUSH
75200: CALL_OW 441
75204: GO 75172
75206: POP
75207: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75208: LD_VAR 0 18
75212: PPUSH
75213: LD_INT 2
75215: PUSH
75216: LD_INT 30
75218: PUSH
75219: LD_INT 32
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 30
75228: PUSH
75229: LD_INT 33
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: LIST
75240: PPUSH
75241: CALL_OW 72
75245: IFFALSE 75333
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75247: LD_ADDR_VAR 0 8
75251: PUSH
75252: LD_VAR 0 18
75256: PPUSH
75257: LD_INT 2
75259: PUSH
75260: LD_INT 30
75262: PUSH
75263: LD_INT 32
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 30
75272: PUSH
75273: LD_INT 33
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: LIST
75284: PPUSH
75285: CALL_OW 72
75289: PUSH
75290: FOR_IN
75291: IFFALSE 75331
// begin if not GetBWeapon ( i ) then
75293: LD_VAR 0 8
75297: PPUSH
75298: CALL_OW 269
75302: NOT
75303: IFFALSE 75329
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75305: LD_VAR 0 8
75309: PPUSH
75310: LD_VAR 0 8
75314: PPUSH
75315: LD_VAR 0 2
75319: PPUSH
75320: CALL 76579 0 2
75324: PPUSH
75325: CALL_OW 431
// end ;
75329: GO 75290
75331: POP
75332: POP
// end ; for i = 1 to personel do
75333: LD_ADDR_VAR 0 8
75337: PUSH
75338: DOUBLE
75339: LD_INT 1
75341: DEC
75342: ST_TO_ADDR
75343: LD_VAR 0 6
75347: PUSH
75348: FOR_TO
75349: IFFALSE 76413
// begin if i > 4 then
75351: LD_VAR 0 8
75355: PUSH
75356: LD_INT 4
75358: GREATER
75359: IFFALSE 75363
// break ;
75361: GO 76413
// case i of 1 :
75363: LD_VAR 0 8
75367: PUSH
75368: LD_INT 1
75370: DOUBLE
75371: EQUAL
75372: IFTRUE 75376
75374: GO 75456
75376: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75377: LD_ADDR_VAR 0 12
75381: PUSH
75382: LD_VAR 0 18
75386: PPUSH
75387: LD_INT 22
75389: PUSH
75390: LD_VAR 0 16
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 58
75401: PUSH
75402: EMPTY
75403: LIST
75404: PUSH
75405: LD_INT 2
75407: PUSH
75408: LD_INT 30
75410: PUSH
75411: LD_INT 32
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 30
75420: PUSH
75421: LD_INT 4
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 30
75430: PUSH
75431: LD_INT 5
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: LIST
75448: PPUSH
75449: CALL_OW 72
75453: ST_TO_ADDR
75454: GO 75678
75456: LD_INT 2
75458: DOUBLE
75459: EQUAL
75460: IFTRUE 75464
75462: GO 75526
75464: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75465: LD_ADDR_VAR 0 12
75469: PUSH
75470: LD_VAR 0 18
75474: PPUSH
75475: LD_INT 22
75477: PUSH
75478: LD_VAR 0 16
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 2
75489: PUSH
75490: LD_INT 30
75492: PUSH
75493: LD_INT 0
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: PUSH
75500: LD_INT 30
75502: PUSH
75503: LD_INT 1
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: LIST
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PPUSH
75519: CALL_OW 72
75523: ST_TO_ADDR
75524: GO 75678
75526: LD_INT 3
75528: DOUBLE
75529: EQUAL
75530: IFTRUE 75534
75532: GO 75596
75534: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75535: LD_ADDR_VAR 0 12
75539: PUSH
75540: LD_VAR 0 18
75544: PPUSH
75545: LD_INT 22
75547: PUSH
75548: LD_VAR 0 16
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 2
75559: PUSH
75560: LD_INT 30
75562: PUSH
75563: LD_INT 2
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 30
75572: PUSH
75573: LD_INT 3
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: LIST
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PPUSH
75589: CALL_OW 72
75593: ST_TO_ADDR
75594: GO 75678
75596: LD_INT 4
75598: DOUBLE
75599: EQUAL
75600: IFTRUE 75604
75602: GO 75677
75604: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75605: LD_ADDR_VAR 0 12
75609: PUSH
75610: LD_VAR 0 18
75614: PPUSH
75615: LD_INT 22
75617: PUSH
75618: LD_VAR 0 16
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 2
75629: PUSH
75630: LD_INT 30
75632: PUSH
75633: LD_INT 6
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 30
75642: PUSH
75643: LD_INT 7
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: PUSH
75650: LD_INT 30
75652: PUSH
75653: LD_INT 8
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PPUSH
75670: CALL_OW 72
75674: ST_TO_ADDR
75675: GO 75678
75677: POP
// if i = 1 then
75678: LD_VAR 0 8
75682: PUSH
75683: LD_INT 1
75685: EQUAL
75686: IFFALSE 75797
// begin tmp := [ ] ;
75688: LD_ADDR_VAR 0 19
75692: PUSH
75693: EMPTY
75694: ST_TO_ADDR
// for j in f do
75695: LD_ADDR_VAR 0 9
75699: PUSH
75700: LD_VAR 0 12
75704: PUSH
75705: FOR_IN
75706: IFFALSE 75779
// if GetBType ( j ) = b_bunker then
75708: LD_VAR 0 9
75712: PPUSH
75713: CALL_OW 266
75717: PUSH
75718: LD_INT 32
75720: EQUAL
75721: IFFALSE 75748
// tmp := Insert ( tmp , 1 , j ) else
75723: LD_ADDR_VAR 0 19
75727: PUSH
75728: LD_VAR 0 19
75732: PPUSH
75733: LD_INT 1
75735: PPUSH
75736: LD_VAR 0 9
75740: PPUSH
75741: CALL_OW 2
75745: ST_TO_ADDR
75746: GO 75777
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75748: LD_ADDR_VAR 0 19
75752: PUSH
75753: LD_VAR 0 19
75757: PPUSH
75758: LD_VAR 0 19
75762: PUSH
75763: LD_INT 1
75765: PLUS
75766: PPUSH
75767: LD_VAR 0 9
75771: PPUSH
75772: CALL_OW 2
75776: ST_TO_ADDR
75777: GO 75705
75779: POP
75780: POP
// if tmp then
75781: LD_VAR 0 19
75785: IFFALSE 75797
// f := tmp ;
75787: LD_ADDR_VAR 0 12
75791: PUSH
75792: LD_VAR 0 19
75796: ST_TO_ADDR
// end ; x := personel [ i ] ;
75797: LD_ADDR_VAR 0 13
75801: PUSH
75802: LD_VAR 0 6
75806: PUSH
75807: LD_VAR 0 8
75811: ARRAY
75812: ST_TO_ADDR
// if x = - 1 then
75813: LD_VAR 0 13
75817: PUSH
75818: LD_INT 1
75820: NEG
75821: EQUAL
75822: IFFALSE 76031
// begin for j in f do
75824: LD_ADDR_VAR 0 9
75828: PUSH
75829: LD_VAR 0 12
75833: PUSH
75834: FOR_IN
75835: IFFALSE 76027
// repeat InitHc ;
75837: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75841: LD_VAR 0 9
75845: PPUSH
75846: CALL_OW 266
75850: PUSH
75851: LD_INT 5
75853: EQUAL
75854: IFFALSE 75924
// begin if UnitsInside ( j ) < 3 then
75856: LD_VAR 0 9
75860: PPUSH
75861: CALL_OW 313
75865: PUSH
75866: LD_INT 3
75868: LESS
75869: IFFALSE 75905
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75871: LD_INT 0
75873: PPUSH
75874: LD_INT 5
75876: PUSH
75877: LD_INT 8
75879: PUSH
75880: LD_INT 9
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: LIST
75887: PUSH
75888: LD_VAR 0 17
75892: ARRAY
75893: PPUSH
75894: LD_VAR 0 4
75898: PPUSH
75899: CALL_OW 380
75903: GO 75922
// PrepareHuman ( false , i , skill ) ;
75905: LD_INT 0
75907: PPUSH
75908: LD_VAR 0 8
75912: PPUSH
75913: LD_VAR 0 4
75917: PPUSH
75918: CALL_OW 380
// end else
75922: GO 75941
// PrepareHuman ( false , i , skill ) ;
75924: LD_INT 0
75926: PPUSH
75927: LD_VAR 0 8
75931: PPUSH
75932: LD_VAR 0 4
75936: PPUSH
75937: CALL_OW 380
// un := CreateHuman ;
75941: LD_ADDR_VAR 0 14
75945: PUSH
75946: CALL_OW 44
75950: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75951: LD_ADDR_VAR 0 7
75955: PUSH
75956: LD_VAR 0 7
75960: PPUSH
75961: LD_INT 1
75963: PPUSH
75964: LD_VAR 0 14
75968: PPUSH
75969: CALL_OW 2
75973: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75974: LD_VAR 0 14
75978: PPUSH
75979: LD_VAR 0 9
75983: PPUSH
75984: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75988: LD_VAR 0 9
75992: PPUSH
75993: CALL_OW 313
75997: PUSH
75998: LD_INT 6
76000: EQUAL
76001: PUSH
76002: LD_VAR 0 9
76006: PPUSH
76007: CALL_OW 266
76011: PUSH
76012: LD_INT 32
76014: PUSH
76015: LD_INT 31
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: IN
76022: OR
76023: IFFALSE 75837
76025: GO 75834
76027: POP
76028: POP
// end else
76029: GO 76411
// for j = 1 to x do
76031: LD_ADDR_VAR 0 9
76035: PUSH
76036: DOUBLE
76037: LD_INT 1
76039: DEC
76040: ST_TO_ADDR
76041: LD_VAR 0 13
76045: PUSH
76046: FOR_TO
76047: IFFALSE 76409
// begin InitHc ;
76049: CALL_OW 19
// if not f then
76053: LD_VAR 0 12
76057: NOT
76058: IFFALSE 76147
// begin PrepareHuman ( false , i , skill ) ;
76060: LD_INT 0
76062: PPUSH
76063: LD_VAR 0 8
76067: PPUSH
76068: LD_VAR 0 4
76072: PPUSH
76073: CALL_OW 380
// un := CreateHuman ;
76077: LD_ADDR_VAR 0 14
76081: PUSH
76082: CALL_OW 44
76086: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76087: LD_ADDR_VAR 0 7
76091: PUSH
76092: LD_VAR 0 7
76096: PPUSH
76097: LD_INT 1
76099: PPUSH
76100: LD_VAR 0 14
76104: PPUSH
76105: CALL_OW 2
76109: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76110: LD_VAR 0 14
76114: PPUSH
76115: LD_VAR 0 1
76119: PPUSH
76120: CALL_OW 250
76124: PPUSH
76125: LD_VAR 0 1
76129: PPUSH
76130: CALL_OW 251
76134: PPUSH
76135: LD_INT 10
76137: PPUSH
76138: LD_INT 0
76140: PPUSH
76141: CALL_OW 50
// continue ;
76145: GO 76046
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76147: LD_VAR 0 12
76151: PUSH
76152: LD_INT 1
76154: ARRAY
76155: PPUSH
76156: CALL_OW 313
76160: PUSH
76161: LD_VAR 0 12
76165: PUSH
76166: LD_INT 1
76168: ARRAY
76169: PPUSH
76170: CALL_OW 266
76174: PUSH
76175: LD_INT 32
76177: PUSH
76178: LD_INT 31
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: IN
76185: AND
76186: PUSH
76187: LD_VAR 0 12
76191: PUSH
76192: LD_INT 1
76194: ARRAY
76195: PPUSH
76196: CALL_OW 313
76200: PUSH
76201: LD_INT 6
76203: EQUAL
76204: OR
76205: IFFALSE 76225
// f := Delete ( f , 1 ) ;
76207: LD_ADDR_VAR 0 12
76211: PUSH
76212: LD_VAR 0 12
76216: PPUSH
76217: LD_INT 1
76219: PPUSH
76220: CALL_OW 3
76224: ST_TO_ADDR
// if not f then
76225: LD_VAR 0 12
76229: NOT
76230: IFFALSE 76248
// begin x := x + 2 ;
76232: LD_ADDR_VAR 0 13
76236: PUSH
76237: LD_VAR 0 13
76241: PUSH
76242: LD_INT 2
76244: PLUS
76245: ST_TO_ADDR
// continue ;
76246: GO 76046
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76248: LD_VAR 0 12
76252: PUSH
76253: LD_INT 1
76255: ARRAY
76256: PPUSH
76257: CALL_OW 266
76261: PUSH
76262: LD_INT 5
76264: EQUAL
76265: IFFALSE 76339
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76267: LD_VAR 0 12
76271: PUSH
76272: LD_INT 1
76274: ARRAY
76275: PPUSH
76276: CALL_OW 313
76280: PUSH
76281: LD_INT 3
76283: LESS
76284: IFFALSE 76320
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76286: LD_INT 0
76288: PPUSH
76289: LD_INT 5
76291: PUSH
76292: LD_INT 8
76294: PUSH
76295: LD_INT 9
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: LIST
76302: PUSH
76303: LD_VAR 0 17
76307: ARRAY
76308: PPUSH
76309: LD_VAR 0 4
76313: PPUSH
76314: CALL_OW 380
76318: GO 76337
// PrepareHuman ( false , i , skill ) ;
76320: LD_INT 0
76322: PPUSH
76323: LD_VAR 0 8
76327: PPUSH
76328: LD_VAR 0 4
76332: PPUSH
76333: CALL_OW 380
// end else
76337: GO 76356
// PrepareHuman ( false , i , skill ) ;
76339: LD_INT 0
76341: PPUSH
76342: LD_VAR 0 8
76346: PPUSH
76347: LD_VAR 0 4
76351: PPUSH
76352: CALL_OW 380
// un := CreateHuman ;
76356: LD_ADDR_VAR 0 14
76360: PUSH
76361: CALL_OW 44
76365: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76366: LD_ADDR_VAR 0 7
76370: PUSH
76371: LD_VAR 0 7
76375: PPUSH
76376: LD_INT 1
76378: PPUSH
76379: LD_VAR 0 14
76383: PPUSH
76384: CALL_OW 2
76388: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76389: LD_VAR 0 14
76393: PPUSH
76394: LD_VAR 0 12
76398: PUSH
76399: LD_INT 1
76401: ARRAY
76402: PPUSH
76403: CALL_OW 52
// end ;
76407: GO 76046
76409: POP
76410: POP
// end ;
76411: GO 75348
76413: POP
76414: POP
// result := result ^ buildings ;
76415: LD_ADDR_VAR 0 7
76419: PUSH
76420: LD_VAR 0 7
76424: PUSH
76425: LD_VAR 0 18
76429: ADD
76430: ST_TO_ADDR
// end else
76431: GO 76574
// begin for i = 1 to personel do
76433: LD_ADDR_VAR 0 8
76437: PUSH
76438: DOUBLE
76439: LD_INT 1
76441: DEC
76442: ST_TO_ADDR
76443: LD_VAR 0 6
76447: PUSH
76448: FOR_TO
76449: IFFALSE 76572
// begin if i > 4 then
76451: LD_VAR 0 8
76455: PUSH
76456: LD_INT 4
76458: GREATER
76459: IFFALSE 76463
// break ;
76461: GO 76572
// x := personel [ i ] ;
76463: LD_ADDR_VAR 0 13
76467: PUSH
76468: LD_VAR 0 6
76472: PUSH
76473: LD_VAR 0 8
76477: ARRAY
76478: ST_TO_ADDR
// if x = - 1 then
76479: LD_VAR 0 13
76483: PUSH
76484: LD_INT 1
76486: NEG
76487: EQUAL
76488: IFFALSE 76492
// continue ;
76490: GO 76448
// PrepareHuman ( false , i , skill ) ;
76492: LD_INT 0
76494: PPUSH
76495: LD_VAR 0 8
76499: PPUSH
76500: LD_VAR 0 4
76504: PPUSH
76505: CALL_OW 380
// un := CreateHuman ;
76509: LD_ADDR_VAR 0 14
76513: PUSH
76514: CALL_OW 44
76518: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76519: LD_VAR 0 14
76523: PPUSH
76524: LD_VAR 0 1
76528: PPUSH
76529: CALL_OW 250
76533: PPUSH
76534: LD_VAR 0 1
76538: PPUSH
76539: CALL_OW 251
76543: PPUSH
76544: LD_INT 10
76546: PPUSH
76547: LD_INT 0
76549: PPUSH
76550: CALL_OW 50
// result := result ^ un ;
76554: LD_ADDR_VAR 0 7
76558: PUSH
76559: LD_VAR 0 7
76563: PUSH
76564: LD_VAR 0 14
76568: ADD
76569: ST_TO_ADDR
// end ;
76570: GO 76448
76572: POP
76573: POP
// end ; end ;
76574: LD_VAR 0 7
76578: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76579: LD_INT 0
76581: PPUSH
76582: PPUSH
76583: PPUSH
76584: PPUSH
76585: PPUSH
76586: PPUSH
76587: PPUSH
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
76592: PPUSH
76593: PPUSH
76594: PPUSH
76595: PPUSH
76596: PPUSH
// result := false ;
76597: LD_ADDR_VAR 0 3
76601: PUSH
76602: LD_INT 0
76604: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76605: LD_VAR 0 1
76609: NOT
76610: PUSH
76611: LD_VAR 0 1
76615: PPUSH
76616: CALL_OW 266
76620: PUSH
76621: LD_INT 32
76623: PUSH
76624: LD_INT 33
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: IN
76631: NOT
76632: OR
76633: IFFALSE 76637
// exit ;
76635: GO 77773
// nat := GetNation ( tower ) ;
76637: LD_ADDR_VAR 0 12
76641: PUSH
76642: LD_VAR 0 1
76646: PPUSH
76647: CALL_OW 248
76651: ST_TO_ADDR
// side := GetSide ( tower ) ;
76652: LD_ADDR_VAR 0 16
76656: PUSH
76657: LD_VAR 0 1
76661: PPUSH
76662: CALL_OW 255
76666: ST_TO_ADDR
// x := GetX ( tower ) ;
76667: LD_ADDR_VAR 0 10
76671: PUSH
76672: LD_VAR 0 1
76676: PPUSH
76677: CALL_OW 250
76681: ST_TO_ADDR
// y := GetY ( tower ) ;
76682: LD_ADDR_VAR 0 11
76686: PUSH
76687: LD_VAR 0 1
76691: PPUSH
76692: CALL_OW 251
76696: ST_TO_ADDR
// if not x or not y then
76697: LD_VAR 0 10
76701: NOT
76702: PUSH
76703: LD_VAR 0 11
76707: NOT
76708: OR
76709: IFFALSE 76713
// exit ;
76711: GO 77773
// weapon := 0 ;
76713: LD_ADDR_VAR 0 18
76717: PUSH
76718: LD_INT 0
76720: ST_TO_ADDR
// fac_list := [ ] ;
76721: LD_ADDR_VAR 0 17
76725: PUSH
76726: EMPTY
76727: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76728: LD_ADDR_VAR 0 6
76732: PUSH
76733: LD_VAR 0 1
76737: PPUSH
76738: CALL_OW 274
76742: PPUSH
76743: LD_VAR 0 2
76747: PPUSH
76748: CALL 74351 0 2
76752: PPUSH
76753: LD_INT 30
76755: PUSH
76756: LD_INT 3
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PPUSH
76763: CALL_OW 72
76767: ST_TO_ADDR
// if not factories then
76768: LD_VAR 0 6
76772: NOT
76773: IFFALSE 76777
// exit ;
76775: GO 77773
// for i in factories do
76777: LD_ADDR_VAR 0 8
76781: PUSH
76782: LD_VAR 0 6
76786: PUSH
76787: FOR_IN
76788: IFFALSE 76813
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76790: LD_ADDR_VAR 0 17
76794: PUSH
76795: LD_VAR 0 17
76799: PUSH
76800: LD_VAR 0 8
76804: PPUSH
76805: CALL_OW 478
76809: UNION
76810: ST_TO_ADDR
76811: GO 76787
76813: POP
76814: POP
// if not fac_list then
76815: LD_VAR 0 17
76819: NOT
76820: IFFALSE 76824
// exit ;
76822: GO 77773
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76824: LD_ADDR_VAR 0 5
76828: PUSH
76829: LD_INT 4
76831: PUSH
76832: LD_INT 5
76834: PUSH
76835: LD_INT 9
76837: PUSH
76838: LD_INT 10
76840: PUSH
76841: LD_INT 6
76843: PUSH
76844: LD_INT 7
76846: PUSH
76847: LD_INT 11
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 27
76861: PUSH
76862: LD_INT 28
76864: PUSH
76865: LD_INT 26
76867: PUSH
76868: LD_INT 30
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 43
76879: PUSH
76880: LD_INT 44
76882: PUSH
76883: LD_INT 46
76885: PUSH
76886: LD_INT 45
76888: PUSH
76889: LD_INT 47
76891: PUSH
76892: LD_INT 49
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: LIST
76907: PUSH
76908: LD_VAR 0 12
76912: ARRAY
76913: ST_TO_ADDR
// for i in list do
76914: LD_ADDR_VAR 0 8
76918: PUSH
76919: LD_VAR 0 5
76923: PUSH
76924: FOR_IN
76925: IFFALSE 76958
// if not i in fac_list then
76927: LD_VAR 0 8
76931: PUSH
76932: LD_VAR 0 17
76936: IN
76937: NOT
76938: IFFALSE 76956
// list := list diff i ;
76940: LD_ADDR_VAR 0 5
76944: PUSH
76945: LD_VAR 0 5
76949: PUSH
76950: LD_VAR 0 8
76954: DIFF
76955: ST_TO_ADDR
76956: GO 76924
76958: POP
76959: POP
// if not list then
76960: LD_VAR 0 5
76964: NOT
76965: IFFALSE 76969
// exit ;
76967: GO 77773
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76969: LD_VAR 0 12
76973: PUSH
76974: LD_INT 3
76976: EQUAL
76977: PUSH
76978: LD_INT 49
76980: PUSH
76981: LD_VAR 0 5
76985: IN
76986: AND
76987: PUSH
76988: LD_INT 31
76990: PPUSH
76991: LD_VAR 0 16
76995: PPUSH
76996: CALL_OW 321
77000: PUSH
77001: LD_INT 2
77003: EQUAL
77004: AND
77005: IFFALSE 77065
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77007: LD_INT 22
77009: PUSH
77010: LD_VAR 0 16
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 35
77021: PUSH
77022: LD_INT 49
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 91
77031: PUSH
77032: LD_VAR 0 1
77036: PUSH
77037: LD_INT 10
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: LIST
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: LIST
77049: PPUSH
77050: CALL_OW 69
77054: NOT
77055: IFFALSE 77065
// weapon := ru_time_lapser ;
77057: LD_ADDR_VAR 0 18
77061: PUSH
77062: LD_INT 49
77064: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77065: LD_VAR 0 12
77069: PUSH
77070: LD_INT 1
77072: PUSH
77073: LD_INT 2
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: IN
77080: PUSH
77081: LD_INT 11
77083: PUSH
77084: LD_VAR 0 5
77088: IN
77089: PUSH
77090: LD_INT 30
77092: PUSH
77093: LD_VAR 0 5
77097: IN
77098: OR
77099: AND
77100: PUSH
77101: LD_INT 6
77103: PPUSH
77104: LD_VAR 0 16
77108: PPUSH
77109: CALL_OW 321
77113: PUSH
77114: LD_INT 2
77116: EQUAL
77117: AND
77118: IFFALSE 77283
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77120: LD_INT 22
77122: PUSH
77123: LD_VAR 0 16
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 2
77134: PUSH
77135: LD_INT 35
77137: PUSH
77138: LD_INT 11
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 35
77147: PUSH
77148: LD_INT 30
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: LIST
77159: PUSH
77160: LD_INT 91
77162: PUSH
77163: LD_VAR 0 1
77167: PUSH
77168: LD_INT 18
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: LIST
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: LIST
77180: PPUSH
77181: CALL_OW 69
77185: NOT
77186: PUSH
77187: LD_INT 22
77189: PUSH
77190: LD_VAR 0 16
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 2
77201: PUSH
77202: LD_INT 30
77204: PUSH
77205: LD_INT 32
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 30
77214: PUSH
77215: LD_INT 33
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 91
77229: PUSH
77230: LD_VAR 0 1
77234: PUSH
77235: LD_INT 12
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: LIST
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: LIST
77247: PUSH
77248: EMPTY
77249: LIST
77250: PPUSH
77251: CALL_OW 69
77255: PUSH
77256: LD_INT 2
77258: GREATER
77259: AND
77260: IFFALSE 77283
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77262: LD_ADDR_VAR 0 18
77266: PUSH
77267: LD_INT 11
77269: PUSH
77270: LD_INT 30
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: PUSH
77277: LD_VAR 0 12
77281: ARRAY
77282: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77283: LD_VAR 0 18
77287: NOT
77288: PUSH
77289: LD_INT 40
77291: PPUSH
77292: LD_VAR 0 16
77296: PPUSH
77297: CALL_OW 321
77301: PUSH
77302: LD_INT 2
77304: EQUAL
77305: AND
77306: PUSH
77307: LD_INT 7
77309: PUSH
77310: LD_VAR 0 5
77314: IN
77315: PUSH
77316: LD_INT 28
77318: PUSH
77319: LD_VAR 0 5
77323: IN
77324: OR
77325: PUSH
77326: LD_INT 45
77328: PUSH
77329: LD_VAR 0 5
77333: IN
77334: OR
77335: AND
77336: IFFALSE 77590
// begin hex := GetHexInfo ( x , y ) ;
77338: LD_ADDR_VAR 0 4
77342: PUSH
77343: LD_VAR 0 10
77347: PPUSH
77348: LD_VAR 0 11
77352: PPUSH
77353: CALL_OW 546
77357: ST_TO_ADDR
// if hex [ 1 ] then
77358: LD_VAR 0 4
77362: PUSH
77363: LD_INT 1
77365: ARRAY
77366: IFFALSE 77370
// exit ;
77368: GO 77773
// height := hex [ 2 ] ;
77370: LD_ADDR_VAR 0 15
77374: PUSH
77375: LD_VAR 0 4
77379: PUSH
77380: LD_INT 2
77382: ARRAY
77383: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77384: LD_ADDR_VAR 0 14
77388: PUSH
77389: LD_INT 0
77391: PUSH
77392: LD_INT 2
77394: PUSH
77395: LD_INT 3
77397: PUSH
77398: LD_INT 5
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: ST_TO_ADDR
// for i in tmp do
77407: LD_ADDR_VAR 0 8
77411: PUSH
77412: LD_VAR 0 14
77416: PUSH
77417: FOR_IN
77418: IFFALSE 77588
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77420: LD_ADDR_VAR 0 9
77424: PUSH
77425: LD_VAR 0 10
77429: PPUSH
77430: LD_VAR 0 8
77434: PPUSH
77435: LD_INT 5
77437: PPUSH
77438: CALL_OW 272
77442: PUSH
77443: LD_VAR 0 11
77447: PPUSH
77448: LD_VAR 0 8
77452: PPUSH
77453: LD_INT 5
77455: PPUSH
77456: CALL_OW 273
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77465: LD_VAR 0 9
77469: PUSH
77470: LD_INT 1
77472: ARRAY
77473: PPUSH
77474: LD_VAR 0 9
77478: PUSH
77479: LD_INT 2
77481: ARRAY
77482: PPUSH
77483: CALL_OW 488
77487: IFFALSE 77586
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77489: LD_ADDR_VAR 0 4
77493: PUSH
77494: LD_VAR 0 9
77498: PUSH
77499: LD_INT 1
77501: ARRAY
77502: PPUSH
77503: LD_VAR 0 9
77507: PUSH
77508: LD_INT 2
77510: ARRAY
77511: PPUSH
77512: CALL_OW 546
77516: ST_TO_ADDR
// if hex [ 1 ] then
77517: LD_VAR 0 4
77521: PUSH
77522: LD_INT 1
77524: ARRAY
77525: IFFALSE 77529
// continue ;
77527: GO 77417
// h := hex [ 2 ] ;
77529: LD_ADDR_VAR 0 13
77533: PUSH
77534: LD_VAR 0 4
77538: PUSH
77539: LD_INT 2
77541: ARRAY
77542: ST_TO_ADDR
// if h + 7 < height then
77543: LD_VAR 0 13
77547: PUSH
77548: LD_INT 7
77550: PLUS
77551: PUSH
77552: LD_VAR 0 15
77556: LESS
77557: IFFALSE 77586
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77559: LD_ADDR_VAR 0 18
77563: PUSH
77564: LD_INT 7
77566: PUSH
77567: LD_INT 28
77569: PUSH
77570: LD_INT 45
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: LIST
77577: PUSH
77578: LD_VAR 0 12
77582: ARRAY
77583: ST_TO_ADDR
// break ;
77584: GO 77588
// end ; end ; end ;
77586: GO 77417
77588: POP
77589: POP
// end ; if not weapon then
77590: LD_VAR 0 18
77594: NOT
77595: IFFALSE 77655
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77597: LD_ADDR_VAR 0 5
77601: PUSH
77602: LD_VAR 0 5
77606: PUSH
77607: LD_INT 11
77609: PUSH
77610: LD_INT 30
77612: PUSH
77613: LD_INT 49
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: LIST
77620: DIFF
77621: ST_TO_ADDR
// if not list then
77622: LD_VAR 0 5
77626: NOT
77627: IFFALSE 77631
// exit ;
77629: GO 77773
// weapon := list [ rand ( 1 , list ) ] ;
77631: LD_ADDR_VAR 0 18
77635: PUSH
77636: LD_VAR 0 5
77640: PUSH
77641: LD_INT 1
77643: PPUSH
77644: LD_VAR 0 5
77648: PPUSH
77649: CALL_OW 12
77653: ARRAY
77654: ST_TO_ADDR
// end ; if weapon then
77655: LD_VAR 0 18
77659: IFFALSE 77773
// begin tmp := CostOfWeapon ( weapon ) ;
77661: LD_ADDR_VAR 0 14
77665: PUSH
77666: LD_VAR 0 18
77670: PPUSH
77671: CALL_OW 451
77675: ST_TO_ADDR
// j := GetBase ( tower ) ;
77676: LD_ADDR_VAR 0 9
77680: PUSH
77681: LD_VAR 0 1
77685: PPUSH
77686: CALL_OW 274
77690: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77691: LD_VAR 0 9
77695: PPUSH
77696: LD_INT 1
77698: PPUSH
77699: CALL_OW 275
77703: PUSH
77704: LD_VAR 0 14
77708: PUSH
77709: LD_INT 1
77711: ARRAY
77712: GREATEREQUAL
77713: PUSH
77714: LD_VAR 0 9
77718: PPUSH
77719: LD_INT 2
77721: PPUSH
77722: CALL_OW 275
77726: PUSH
77727: LD_VAR 0 14
77731: PUSH
77732: LD_INT 2
77734: ARRAY
77735: GREATEREQUAL
77736: AND
77737: PUSH
77738: LD_VAR 0 9
77742: PPUSH
77743: LD_INT 3
77745: PPUSH
77746: CALL_OW 275
77750: PUSH
77751: LD_VAR 0 14
77755: PUSH
77756: LD_INT 3
77758: ARRAY
77759: GREATEREQUAL
77760: AND
77761: IFFALSE 77773
// result := weapon ;
77763: LD_ADDR_VAR 0 3
77767: PUSH
77768: LD_VAR 0 18
77772: ST_TO_ADDR
// end ; end ;
77773: LD_VAR 0 3
77777: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77778: LD_INT 0
77780: PPUSH
77781: PPUSH
// result := true ;
77782: LD_ADDR_VAR 0 3
77786: PUSH
77787: LD_INT 1
77789: ST_TO_ADDR
// if array1 = array2 then
77790: LD_VAR 0 1
77794: PUSH
77795: LD_VAR 0 2
77799: EQUAL
77800: IFFALSE 77860
// begin for i = 1 to array1 do
77802: LD_ADDR_VAR 0 4
77806: PUSH
77807: DOUBLE
77808: LD_INT 1
77810: DEC
77811: ST_TO_ADDR
77812: LD_VAR 0 1
77816: PUSH
77817: FOR_TO
77818: IFFALSE 77856
// if array1 [ i ] <> array2 [ i ] then
77820: LD_VAR 0 1
77824: PUSH
77825: LD_VAR 0 4
77829: ARRAY
77830: PUSH
77831: LD_VAR 0 2
77835: PUSH
77836: LD_VAR 0 4
77840: ARRAY
77841: NONEQUAL
77842: IFFALSE 77854
// begin result := false ;
77844: LD_ADDR_VAR 0 3
77848: PUSH
77849: LD_INT 0
77851: ST_TO_ADDR
// break ;
77852: GO 77856
// end ;
77854: GO 77817
77856: POP
77857: POP
// end else
77858: GO 77868
// result := false ;
77860: LD_ADDR_VAR 0 3
77864: PUSH
77865: LD_INT 0
77867: ST_TO_ADDR
// end ;
77868: LD_VAR 0 3
77872: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77873: LD_INT 0
77875: PPUSH
77876: PPUSH
77877: PPUSH
// pom := GetBase ( fac ) ;
77878: LD_ADDR_VAR 0 5
77882: PUSH
77883: LD_VAR 0 1
77887: PPUSH
77888: CALL_OW 274
77892: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77893: LD_ADDR_VAR 0 4
77897: PUSH
77898: LD_VAR 0 2
77902: PUSH
77903: LD_INT 1
77905: ARRAY
77906: PPUSH
77907: LD_VAR 0 2
77911: PUSH
77912: LD_INT 2
77914: ARRAY
77915: PPUSH
77916: LD_VAR 0 2
77920: PUSH
77921: LD_INT 3
77923: ARRAY
77924: PPUSH
77925: LD_VAR 0 2
77929: PUSH
77930: LD_INT 4
77932: ARRAY
77933: PPUSH
77934: CALL_OW 449
77938: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77939: LD_ADDR_VAR 0 3
77943: PUSH
77944: LD_VAR 0 5
77948: PPUSH
77949: LD_INT 1
77951: PPUSH
77952: CALL_OW 275
77956: PUSH
77957: LD_VAR 0 4
77961: PUSH
77962: LD_INT 1
77964: ARRAY
77965: GREATEREQUAL
77966: PUSH
77967: LD_VAR 0 5
77971: PPUSH
77972: LD_INT 2
77974: PPUSH
77975: CALL_OW 275
77979: PUSH
77980: LD_VAR 0 4
77984: PUSH
77985: LD_INT 2
77987: ARRAY
77988: GREATEREQUAL
77989: AND
77990: PUSH
77991: LD_VAR 0 5
77995: PPUSH
77996: LD_INT 3
77998: PPUSH
77999: CALL_OW 275
78003: PUSH
78004: LD_VAR 0 4
78008: PUSH
78009: LD_INT 3
78011: ARRAY
78012: GREATEREQUAL
78013: AND
78014: ST_TO_ADDR
// end ;
78015: LD_VAR 0 3
78019: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78020: LD_INT 0
78022: PPUSH
78023: PPUSH
78024: PPUSH
78025: PPUSH
// pom := GetBase ( building ) ;
78026: LD_ADDR_VAR 0 3
78030: PUSH
78031: LD_VAR 0 1
78035: PPUSH
78036: CALL_OW 274
78040: ST_TO_ADDR
// if not pom then
78041: LD_VAR 0 3
78045: NOT
78046: IFFALSE 78050
// exit ;
78048: GO 78220
// btype := GetBType ( building ) ;
78050: LD_ADDR_VAR 0 5
78054: PUSH
78055: LD_VAR 0 1
78059: PPUSH
78060: CALL_OW 266
78064: ST_TO_ADDR
// if btype = b_armoury then
78065: LD_VAR 0 5
78069: PUSH
78070: LD_INT 4
78072: EQUAL
78073: IFFALSE 78083
// btype := b_barracks ;
78075: LD_ADDR_VAR 0 5
78079: PUSH
78080: LD_INT 5
78082: ST_TO_ADDR
// if btype = b_depot then
78083: LD_VAR 0 5
78087: PUSH
78088: LD_INT 0
78090: EQUAL
78091: IFFALSE 78101
// btype := b_warehouse ;
78093: LD_ADDR_VAR 0 5
78097: PUSH
78098: LD_INT 1
78100: ST_TO_ADDR
// if btype = b_workshop then
78101: LD_VAR 0 5
78105: PUSH
78106: LD_INT 2
78108: EQUAL
78109: IFFALSE 78119
// btype := b_factory ;
78111: LD_ADDR_VAR 0 5
78115: PUSH
78116: LD_INT 3
78118: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78119: LD_ADDR_VAR 0 4
78123: PUSH
78124: LD_VAR 0 5
78128: PPUSH
78129: LD_VAR 0 1
78133: PPUSH
78134: CALL_OW 248
78138: PPUSH
78139: CALL_OW 450
78143: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78144: LD_ADDR_VAR 0 2
78148: PUSH
78149: LD_VAR 0 3
78153: PPUSH
78154: LD_INT 1
78156: PPUSH
78157: CALL_OW 275
78161: PUSH
78162: LD_VAR 0 4
78166: PUSH
78167: LD_INT 1
78169: ARRAY
78170: GREATEREQUAL
78171: PUSH
78172: LD_VAR 0 3
78176: PPUSH
78177: LD_INT 2
78179: PPUSH
78180: CALL_OW 275
78184: PUSH
78185: LD_VAR 0 4
78189: PUSH
78190: LD_INT 2
78192: ARRAY
78193: GREATEREQUAL
78194: AND
78195: PUSH
78196: LD_VAR 0 3
78200: PPUSH
78201: LD_INT 3
78203: PPUSH
78204: CALL_OW 275
78208: PUSH
78209: LD_VAR 0 4
78213: PUSH
78214: LD_INT 3
78216: ARRAY
78217: GREATEREQUAL
78218: AND
78219: ST_TO_ADDR
// end ;
78220: LD_VAR 0 2
78224: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78225: LD_INT 0
78227: PPUSH
78228: PPUSH
78229: PPUSH
// pom := GetBase ( building ) ;
78230: LD_ADDR_VAR 0 4
78234: PUSH
78235: LD_VAR 0 1
78239: PPUSH
78240: CALL_OW 274
78244: ST_TO_ADDR
// if not pom then
78245: LD_VAR 0 4
78249: NOT
78250: IFFALSE 78254
// exit ;
78252: GO 78355
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78254: LD_ADDR_VAR 0 5
78258: PUSH
78259: LD_VAR 0 2
78263: PPUSH
78264: LD_VAR 0 1
78268: PPUSH
78269: CALL_OW 248
78273: PPUSH
78274: CALL_OW 450
78278: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78279: LD_ADDR_VAR 0 3
78283: PUSH
78284: LD_VAR 0 4
78288: PPUSH
78289: LD_INT 1
78291: PPUSH
78292: CALL_OW 275
78296: PUSH
78297: LD_VAR 0 5
78301: PUSH
78302: LD_INT 1
78304: ARRAY
78305: GREATEREQUAL
78306: PUSH
78307: LD_VAR 0 4
78311: PPUSH
78312: LD_INT 2
78314: PPUSH
78315: CALL_OW 275
78319: PUSH
78320: LD_VAR 0 5
78324: PUSH
78325: LD_INT 2
78327: ARRAY
78328: GREATEREQUAL
78329: AND
78330: PUSH
78331: LD_VAR 0 4
78335: PPUSH
78336: LD_INT 3
78338: PPUSH
78339: CALL_OW 275
78343: PUSH
78344: LD_VAR 0 5
78348: PUSH
78349: LD_INT 3
78351: ARRAY
78352: GREATEREQUAL
78353: AND
78354: ST_TO_ADDR
// end ;
78355: LD_VAR 0 3
78359: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78360: LD_INT 0
78362: PPUSH
78363: PPUSH
78364: PPUSH
78365: PPUSH
78366: PPUSH
78367: PPUSH
78368: PPUSH
78369: PPUSH
78370: PPUSH
78371: PPUSH
// result := false ;
78372: LD_ADDR_VAR 0 6
78376: PUSH
78377: LD_INT 0
78379: ST_TO_ADDR
// if not base or not btype or not x or not y then
78380: LD_VAR 0 1
78384: NOT
78385: PUSH
78386: LD_VAR 0 2
78390: NOT
78391: OR
78392: PUSH
78393: LD_VAR 0 3
78397: NOT
78398: OR
78399: PUSH
78400: LD_VAR 0 4
78404: NOT
78405: OR
78406: IFFALSE 78410
// exit ;
78408: GO 79019
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78410: LD_ADDR_VAR 0 12
78414: PUSH
78415: LD_VAR 0 2
78419: PPUSH
78420: LD_VAR 0 3
78424: PPUSH
78425: LD_VAR 0 4
78429: PPUSH
78430: LD_VAR 0 5
78434: PPUSH
78435: LD_VAR 0 1
78439: PUSH
78440: LD_INT 1
78442: ARRAY
78443: PPUSH
78444: CALL_OW 248
78448: PPUSH
78449: LD_INT 0
78451: PPUSH
78452: CALL 79856 0 6
78456: ST_TO_ADDR
// if not hexes then
78457: LD_VAR 0 12
78461: NOT
78462: IFFALSE 78466
// exit ;
78464: GO 79019
// for i = 1 to hexes do
78466: LD_ADDR_VAR 0 7
78470: PUSH
78471: DOUBLE
78472: LD_INT 1
78474: DEC
78475: ST_TO_ADDR
78476: LD_VAR 0 12
78480: PUSH
78481: FOR_TO
78482: IFFALSE 79017
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78484: LD_ADDR_VAR 0 11
78488: PUSH
78489: LD_VAR 0 12
78493: PUSH
78494: LD_VAR 0 7
78498: ARRAY
78499: PUSH
78500: LD_INT 1
78502: ARRAY
78503: PPUSH
78504: LD_VAR 0 12
78508: PUSH
78509: LD_VAR 0 7
78513: ARRAY
78514: PUSH
78515: LD_INT 2
78517: ARRAY
78518: PPUSH
78519: CALL_OW 428
78523: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78524: LD_VAR 0 12
78528: PUSH
78529: LD_VAR 0 7
78533: ARRAY
78534: PUSH
78535: LD_INT 1
78537: ARRAY
78538: PPUSH
78539: LD_VAR 0 12
78543: PUSH
78544: LD_VAR 0 7
78548: ARRAY
78549: PUSH
78550: LD_INT 2
78552: ARRAY
78553: PPUSH
78554: CALL_OW 351
78558: PUSH
78559: LD_VAR 0 12
78563: PUSH
78564: LD_VAR 0 7
78568: ARRAY
78569: PUSH
78570: LD_INT 1
78572: ARRAY
78573: PPUSH
78574: LD_VAR 0 12
78578: PUSH
78579: LD_VAR 0 7
78583: ARRAY
78584: PUSH
78585: LD_INT 2
78587: ARRAY
78588: PPUSH
78589: CALL_OW 488
78593: NOT
78594: OR
78595: PUSH
78596: LD_VAR 0 11
78600: PPUSH
78601: CALL_OW 247
78605: PUSH
78606: LD_INT 3
78608: EQUAL
78609: OR
78610: IFFALSE 78616
// exit ;
78612: POP
78613: POP
78614: GO 79019
// if not tmp or not tmp in base then
78616: LD_VAR 0 11
78620: NOT
78621: PUSH
78622: LD_VAR 0 11
78626: PUSH
78627: LD_VAR 0 1
78631: IN
78632: NOT
78633: OR
78634: IFFALSE 78638
// continue ;
78636: GO 78481
// result := true ;
78638: LD_ADDR_VAR 0 6
78642: PUSH
78643: LD_INT 1
78645: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78646: LD_ADDR_VAR 0 15
78650: PUSH
78651: LD_VAR 0 1
78655: PPUSH
78656: LD_INT 22
78658: PUSH
78659: LD_VAR 0 11
78663: PPUSH
78664: CALL_OW 255
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 2
78675: PUSH
78676: LD_INT 30
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 30
78688: PUSH
78689: LD_INT 1
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: LIST
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PPUSH
78705: CALL_OW 72
78709: ST_TO_ADDR
// if dep then
78710: LD_VAR 0 15
78714: IFFALSE 78850
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78716: LD_ADDR_VAR 0 14
78720: PUSH
78721: LD_VAR 0 15
78725: PUSH
78726: LD_INT 1
78728: ARRAY
78729: PPUSH
78730: CALL_OW 250
78734: PPUSH
78735: LD_VAR 0 15
78739: PUSH
78740: LD_INT 1
78742: ARRAY
78743: PPUSH
78744: CALL_OW 254
78748: PPUSH
78749: LD_INT 5
78751: PPUSH
78752: CALL_OW 272
78756: PUSH
78757: LD_VAR 0 15
78761: PUSH
78762: LD_INT 1
78764: ARRAY
78765: PPUSH
78766: CALL_OW 251
78770: PPUSH
78771: LD_VAR 0 15
78775: PUSH
78776: LD_INT 1
78778: ARRAY
78779: PPUSH
78780: CALL_OW 254
78784: PPUSH
78785: LD_INT 5
78787: PPUSH
78788: CALL_OW 273
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78797: LD_VAR 0 14
78801: PUSH
78802: LD_INT 1
78804: ARRAY
78805: PPUSH
78806: LD_VAR 0 14
78810: PUSH
78811: LD_INT 2
78813: ARRAY
78814: PPUSH
78815: CALL_OW 488
78819: IFFALSE 78850
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78821: LD_VAR 0 11
78825: PPUSH
78826: LD_VAR 0 14
78830: PUSH
78831: LD_INT 1
78833: ARRAY
78834: PPUSH
78835: LD_VAR 0 14
78839: PUSH
78840: LD_INT 2
78842: ARRAY
78843: PPUSH
78844: CALL_OW 111
// continue ;
78848: GO 78481
// end ; end ; r := GetDir ( tmp ) ;
78850: LD_ADDR_VAR 0 13
78854: PUSH
78855: LD_VAR 0 11
78859: PPUSH
78860: CALL_OW 254
78864: ST_TO_ADDR
// if r = 5 then
78865: LD_VAR 0 13
78869: PUSH
78870: LD_INT 5
78872: EQUAL
78873: IFFALSE 78883
// r := 0 ;
78875: LD_ADDR_VAR 0 13
78879: PUSH
78880: LD_INT 0
78882: ST_TO_ADDR
// for j = r to 5 do
78883: LD_ADDR_VAR 0 8
78887: PUSH
78888: DOUBLE
78889: LD_VAR 0 13
78893: DEC
78894: ST_TO_ADDR
78895: LD_INT 5
78897: PUSH
78898: FOR_TO
78899: IFFALSE 79013
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78901: LD_ADDR_VAR 0 9
78905: PUSH
78906: LD_VAR 0 11
78910: PPUSH
78911: CALL_OW 250
78915: PPUSH
78916: LD_VAR 0 8
78920: PPUSH
78921: LD_INT 2
78923: PPUSH
78924: CALL_OW 272
78928: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78929: LD_ADDR_VAR 0 10
78933: PUSH
78934: LD_VAR 0 11
78938: PPUSH
78939: CALL_OW 251
78943: PPUSH
78944: LD_VAR 0 8
78948: PPUSH
78949: LD_INT 2
78951: PPUSH
78952: CALL_OW 273
78956: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78957: LD_VAR 0 9
78961: PPUSH
78962: LD_VAR 0 10
78966: PPUSH
78967: CALL_OW 488
78971: PUSH
78972: LD_VAR 0 9
78976: PPUSH
78977: LD_VAR 0 10
78981: PPUSH
78982: CALL_OW 428
78986: NOT
78987: AND
78988: IFFALSE 79011
// begin ComMoveXY ( tmp , _x , _y ) ;
78990: LD_VAR 0 11
78994: PPUSH
78995: LD_VAR 0 9
78999: PPUSH
79000: LD_VAR 0 10
79004: PPUSH
79005: CALL_OW 111
// break ;
79009: GO 79013
// end ; end ;
79011: GO 78898
79013: POP
79014: POP
// end ;
79015: GO 78481
79017: POP
79018: POP
// end ;
79019: LD_VAR 0 6
79023: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79024: LD_INT 0
79026: PPUSH
79027: PPUSH
79028: PPUSH
79029: PPUSH
79030: PPUSH
79031: PPUSH
79032: PPUSH
79033: PPUSH
79034: PPUSH
79035: PPUSH
// result := false ;
79036: LD_ADDR_VAR 0 6
79040: PUSH
79041: LD_INT 0
79043: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79044: LD_VAR 0 1
79048: NOT
79049: PUSH
79050: LD_VAR 0 1
79054: PPUSH
79055: CALL_OW 266
79059: PUSH
79060: LD_INT 0
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: IN
79070: NOT
79071: OR
79072: PUSH
79073: LD_VAR 0 2
79077: NOT
79078: OR
79079: PUSH
79080: LD_VAR 0 5
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: LD_INT 1
79090: PUSH
79091: LD_INT 2
79093: PUSH
79094: LD_INT 3
79096: PUSH
79097: LD_INT 4
79099: PUSH
79100: LD_INT 5
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: IN
79111: NOT
79112: OR
79113: PUSH
79114: LD_VAR 0 3
79118: PPUSH
79119: LD_VAR 0 4
79123: PPUSH
79124: CALL_OW 488
79128: NOT
79129: OR
79130: IFFALSE 79134
// exit ;
79132: GO 79851
// pom := GetBase ( depot ) ;
79134: LD_ADDR_VAR 0 10
79138: PUSH
79139: LD_VAR 0 1
79143: PPUSH
79144: CALL_OW 274
79148: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79149: LD_ADDR_VAR 0 11
79153: PUSH
79154: LD_VAR 0 2
79158: PPUSH
79159: LD_VAR 0 1
79163: PPUSH
79164: CALL_OW 248
79168: PPUSH
79169: CALL_OW 450
79173: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79174: LD_VAR 0 10
79178: PPUSH
79179: LD_INT 1
79181: PPUSH
79182: CALL_OW 275
79186: PUSH
79187: LD_VAR 0 11
79191: PUSH
79192: LD_INT 1
79194: ARRAY
79195: GREATEREQUAL
79196: PUSH
79197: LD_VAR 0 10
79201: PPUSH
79202: LD_INT 2
79204: PPUSH
79205: CALL_OW 275
79209: PUSH
79210: LD_VAR 0 11
79214: PUSH
79215: LD_INT 2
79217: ARRAY
79218: GREATEREQUAL
79219: AND
79220: PUSH
79221: LD_VAR 0 10
79225: PPUSH
79226: LD_INT 3
79228: PPUSH
79229: CALL_OW 275
79233: PUSH
79234: LD_VAR 0 11
79238: PUSH
79239: LD_INT 3
79241: ARRAY
79242: GREATEREQUAL
79243: AND
79244: NOT
79245: IFFALSE 79249
// exit ;
79247: GO 79851
// if GetBType ( depot ) = b_depot then
79249: LD_VAR 0 1
79253: PPUSH
79254: CALL_OW 266
79258: PUSH
79259: LD_INT 0
79261: EQUAL
79262: IFFALSE 79274
// dist := 28 else
79264: LD_ADDR_VAR 0 14
79268: PUSH
79269: LD_INT 28
79271: ST_TO_ADDR
79272: GO 79282
// dist := 36 ;
79274: LD_ADDR_VAR 0 14
79278: PUSH
79279: LD_INT 36
79281: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79282: LD_VAR 0 1
79286: PPUSH
79287: LD_VAR 0 3
79291: PPUSH
79292: LD_VAR 0 4
79296: PPUSH
79297: CALL_OW 297
79301: PUSH
79302: LD_VAR 0 14
79306: GREATER
79307: IFFALSE 79311
// exit ;
79309: GO 79851
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79311: LD_ADDR_VAR 0 12
79315: PUSH
79316: LD_VAR 0 2
79320: PPUSH
79321: LD_VAR 0 3
79325: PPUSH
79326: LD_VAR 0 4
79330: PPUSH
79331: LD_VAR 0 5
79335: PPUSH
79336: LD_VAR 0 1
79340: PPUSH
79341: CALL_OW 248
79345: PPUSH
79346: LD_INT 0
79348: PPUSH
79349: CALL 79856 0 6
79353: ST_TO_ADDR
// if not hexes then
79354: LD_VAR 0 12
79358: NOT
79359: IFFALSE 79363
// exit ;
79361: GO 79851
// hex := GetHexInfo ( x , y ) ;
79363: LD_ADDR_VAR 0 15
79367: PUSH
79368: LD_VAR 0 3
79372: PPUSH
79373: LD_VAR 0 4
79377: PPUSH
79378: CALL_OW 546
79382: ST_TO_ADDR
// if hex [ 1 ] then
79383: LD_VAR 0 15
79387: PUSH
79388: LD_INT 1
79390: ARRAY
79391: IFFALSE 79395
// exit ;
79393: GO 79851
// height := hex [ 2 ] ;
79395: LD_ADDR_VAR 0 13
79399: PUSH
79400: LD_VAR 0 15
79404: PUSH
79405: LD_INT 2
79407: ARRAY
79408: ST_TO_ADDR
// for i = 1 to hexes do
79409: LD_ADDR_VAR 0 7
79413: PUSH
79414: DOUBLE
79415: LD_INT 1
79417: DEC
79418: ST_TO_ADDR
79419: LD_VAR 0 12
79423: PUSH
79424: FOR_TO
79425: IFFALSE 79755
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79427: LD_VAR 0 12
79431: PUSH
79432: LD_VAR 0 7
79436: ARRAY
79437: PUSH
79438: LD_INT 1
79440: ARRAY
79441: PPUSH
79442: LD_VAR 0 12
79446: PUSH
79447: LD_VAR 0 7
79451: ARRAY
79452: PUSH
79453: LD_INT 2
79455: ARRAY
79456: PPUSH
79457: CALL_OW 488
79461: NOT
79462: PUSH
79463: LD_VAR 0 12
79467: PUSH
79468: LD_VAR 0 7
79472: ARRAY
79473: PUSH
79474: LD_INT 1
79476: ARRAY
79477: PPUSH
79478: LD_VAR 0 12
79482: PUSH
79483: LD_VAR 0 7
79487: ARRAY
79488: PUSH
79489: LD_INT 2
79491: ARRAY
79492: PPUSH
79493: CALL_OW 428
79497: PUSH
79498: LD_INT 0
79500: GREATER
79501: OR
79502: PUSH
79503: LD_VAR 0 12
79507: PUSH
79508: LD_VAR 0 7
79512: ARRAY
79513: PUSH
79514: LD_INT 1
79516: ARRAY
79517: PPUSH
79518: LD_VAR 0 12
79522: PUSH
79523: LD_VAR 0 7
79527: ARRAY
79528: PUSH
79529: LD_INT 2
79531: ARRAY
79532: PPUSH
79533: CALL_OW 351
79537: OR
79538: IFFALSE 79544
// exit ;
79540: POP
79541: POP
79542: GO 79851
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79544: LD_ADDR_VAR 0 8
79548: PUSH
79549: LD_VAR 0 12
79553: PUSH
79554: LD_VAR 0 7
79558: ARRAY
79559: PUSH
79560: LD_INT 1
79562: ARRAY
79563: PPUSH
79564: LD_VAR 0 12
79568: PUSH
79569: LD_VAR 0 7
79573: ARRAY
79574: PUSH
79575: LD_INT 2
79577: ARRAY
79578: PPUSH
79579: CALL_OW 546
79583: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79584: LD_VAR 0 8
79588: PUSH
79589: LD_INT 1
79591: ARRAY
79592: PUSH
79593: LD_VAR 0 8
79597: PUSH
79598: LD_INT 2
79600: ARRAY
79601: PUSH
79602: LD_VAR 0 13
79606: PUSH
79607: LD_INT 2
79609: PLUS
79610: GREATER
79611: OR
79612: PUSH
79613: LD_VAR 0 8
79617: PUSH
79618: LD_INT 2
79620: ARRAY
79621: PUSH
79622: LD_VAR 0 13
79626: PUSH
79627: LD_INT 2
79629: MINUS
79630: LESS
79631: OR
79632: PUSH
79633: LD_VAR 0 8
79637: PUSH
79638: LD_INT 3
79640: ARRAY
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 8
79647: PUSH
79648: LD_INT 9
79650: PUSH
79651: LD_INT 10
79653: PUSH
79654: LD_INT 11
79656: PUSH
79657: LD_INT 12
79659: PUSH
79660: LD_INT 13
79662: PUSH
79663: LD_INT 16
79665: PUSH
79666: LD_INT 17
79668: PUSH
79669: LD_INT 18
79671: PUSH
79672: LD_INT 19
79674: PUSH
79675: LD_INT 20
79677: PUSH
79678: LD_INT 21
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: LIST
79694: LIST
79695: IN
79696: NOT
79697: OR
79698: PUSH
79699: LD_VAR 0 8
79703: PUSH
79704: LD_INT 5
79706: ARRAY
79707: NOT
79708: OR
79709: PUSH
79710: LD_VAR 0 8
79714: PUSH
79715: LD_INT 6
79717: ARRAY
79718: PUSH
79719: LD_INT 1
79721: PUSH
79722: LD_INT 2
79724: PUSH
79725: LD_INT 7
79727: PUSH
79728: LD_INT 9
79730: PUSH
79731: LD_INT 10
79733: PUSH
79734: LD_INT 11
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: LIST
79743: LIST
79744: IN
79745: NOT
79746: OR
79747: IFFALSE 79753
// exit ;
79749: POP
79750: POP
79751: GO 79851
// end ;
79753: GO 79424
79755: POP
79756: POP
// side := GetSide ( depot ) ;
79757: LD_ADDR_VAR 0 9
79761: PUSH
79762: LD_VAR 0 1
79766: PPUSH
79767: CALL_OW 255
79771: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79772: LD_VAR 0 9
79776: PPUSH
79777: LD_VAR 0 3
79781: PPUSH
79782: LD_VAR 0 4
79786: PPUSH
79787: LD_INT 20
79789: PPUSH
79790: CALL 72505 0 4
79794: PUSH
79795: LD_INT 4
79797: ARRAY
79798: IFFALSE 79802
// exit ;
79800: GO 79851
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79802: LD_VAR 0 2
79806: PUSH
79807: LD_INT 29
79809: PUSH
79810: LD_INT 30
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: IN
79817: PUSH
79818: LD_VAR 0 3
79822: PPUSH
79823: LD_VAR 0 4
79827: PPUSH
79828: LD_VAR 0 9
79832: PPUSH
79833: CALL_OW 440
79837: NOT
79838: AND
79839: IFFALSE 79843
// exit ;
79841: GO 79851
// result := true ;
79843: LD_ADDR_VAR 0 6
79847: PUSH
79848: LD_INT 1
79850: ST_TO_ADDR
// end ;
79851: LD_VAR 0 6
79855: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79856: LD_INT 0
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
79878: PPUSH
79879: PPUSH
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
79886: PPUSH
79887: PPUSH
79888: PPUSH
79889: PPUSH
79890: PPUSH
79891: PPUSH
79892: PPUSH
79893: PPUSH
79894: PPUSH
79895: PPUSH
79896: PPUSH
79897: PPUSH
79898: PPUSH
79899: PPUSH
79900: PPUSH
79901: PPUSH
79902: PPUSH
79903: PPUSH
79904: PPUSH
79905: PPUSH
79906: PPUSH
79907: PPUSH
79908: PPUSH
79909: PPUSH
79910: PPUSH
79911: PPUSH
79912: PPUSH
79913: PPUSH
79914: PPUSH
79915: PPUSH
// result = [ ] ;
79916: LD_ADDR_VAR 0 7
79920: PUSH
79921: EMPTY
79922: ST_TO_ADDR
// temp_list = [ ] ;
79923: LD_ADDR_VAR 0 9
79927: PUSH
79928: EMPTY
79929: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79930: LD_VAR 0 4
79934: PUSH
79935: LD_INT 0
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: LD_INT 2
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: LD_INT 4
79949: PUSH
79950: LD_INT 5
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: IN
79961: NOT
79962: PUSH
79963: LD_VAR 0 1
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: IN
79978: PUSH
79979: LD_VAR 0 5
79983: PUSH
79984: LD_INT 1
79986: PUSH
79987: LD_INT 2
79989: PUSH
79990: LD_INT 3
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: LIST
79997: IN
79998: NOT
79999: AND
80000: OR
80001: IFFALSE 80005
// exit ;
80003: GO 98396
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80005: LD_VAR 0 1
80009: PUSH
80010: LD_INT 6
80012: PUSH
80013: LD_INT 7
80015: PUSH
80016: LD_INT 8
80018: PUSH
80019: LD_INT 13
80021: PUSH
80022: LD_INT 12
80024: PUSH
80025: LD_INT 15
80027: PUSH
80028: LD_INT 11
80030: PUSH
80031: LD_INT 14
80033: PUSH
80034: LD_INT 10
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: IN
80048: IFFALSE 80058
// btype = b_lab ;
80050: LD_ADDR_VAR 0 1
80054: PUSH
80055: LD_INT 6
80057: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80058: LD_VAR 0 6
80062: PUSH
80063: LD_INT 0
80065: PUSH
80066: LD_INT 1
80068: PUSH
80069: LD_INT 2
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: LIST
80076: IN
80077: NOT
80078: PUSH
80079: LD_VAR 0 1
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: LD_INT 1
80089: PUSH
80090: LD_INT 2
80092: PUSH
80093: LD_INT 3
80095: PUSH
80096: LD_INT 6
80098: PUSH
80099: LD_INT 36
80101: PUSH
80102: LD_INT 4
80104: PUSH
80105: LD_INT 5
80107: PUSH
80108: LD_INT 31
80110: PUSH
80111: LD_INT 32
80113: PUSH
80114: LD_INT 33
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: IN
80130: NOT
80131: PUSH
80132: LD_VAR 0 6
80136: PUSH
80137: LD_INT 1
80139: EQUAL
80140: AND
80141: OR
80142: PUSH
80143: LD_VAR 0 1
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: LD_INT 3
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: IN
80158: NOT
80159: PUSH
80160: LD_VAR 0 6
80164: PUSH
80165: LD_INT 2
80167: EQUAL
80168: AND
80169: OR
80170: IFFALSE 80180
// mode = 0 ;
80172: LD_ADDR_VAR 0 6
80176: PUSH
80177: LD_INT 0
80179: ST_TO_ADDR
// case mode of 0 :
80180: LD_VAR 0 6
80184: PUSH
80185: LD_INT 0
80187: DOUBLE
80188: EQUAL
80189: IFTRUE 80193
80191: GO 91646
80193: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80194: LD_ADDR_VAR 0 11
80198: PUSH
80199: LD_INT 0
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 0
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: LD_INT 0
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: LD_INT 1
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 0
80242: PUSH
80243: LD_INT 1
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 1
80252: NEG
80253: PUSH
80254: LD_INT 0
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: LD_INT 1
80267: NEG
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 1
80275: NEG
80276: PUSH
80277: LD_INT 2
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 0
80287: PUSH
80288: LD_INT 2
80290: NEG
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 1
80298: PUSH
80299: LD_INT 1
80301: NEG
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 1
80309: PUSH
80310: LD_INT 2
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: LD_INT 2
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 1
80329: NEG
80330: PUSH
80331: LD_INT 1
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 1
80340: PUSH
80341: LD_INT 3
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 0
80350: PUSH
80351: LD_INT 3
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: LD_INT 2
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80387: LD_ADDR_VAR 0 12
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 0
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: PUSH
80416: LD_INT 0
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 1
80425: PUSH
80426: LD_INT 1
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 0
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: LD_INT 0
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 1
80456: NEG
80457: PUSH
80458: LD_INT 1
80460: NEG
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 1
80468: PUSH
80469: LD_INT 1
80471: NEG
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 2
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 2
80489: PUSH
80490: LD_INT 1
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 1
80499: NEG
80500: PUSH
80501: LD_INT 1
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 2
80510: NEG
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 2
80521: NEG
80522: PUSH
80523: LD_INT 1
80525: NEG
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 2
80533: NEG
80534: PUSH
80535: LD_INT 1
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 3
80544: NEG
80545: PUSH
80546: LD_INT 0
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 3
80555: NEG
80556: PUSH
80557: LD_INT 1
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80583: LD_ADDR_VAR 0 13
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 0
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 1
80621: PUSH
80622: LD_INT 1
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 0
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 1
80641: NEG
80642: PUSH
80643: LD_INT 0
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 1
80652: NEG
80653: PUSH
80654: LD_INT 1
80656: NEG
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 2
80676: PUSH
80677: LD_INT 1
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 2
80686: PUSH
80687: LD_INT 2
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: LD_INT 2
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 2
80706: NEG
80707: PUSH
80708: LD_INT 1
80710: NEG
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 2
80718: NEG
80719: PUSH
80720: LD_INT 2
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 2
80730: NEG
80731: PUSH
80732: LD_INT 3
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: LD_INT 2
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 3
80754: NEG
80755: PUSH
80756: LD_INT 3
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80782: LD_ADDR_VAR 0 14
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: LD_INT 0
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 1
80820: PUSH
80821: LD_INT 1
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 0
80830: PUSH
80831: LD_INT 1
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: LD_INT 2
80867: NEG
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 0
80875: PUSH
80876: LD_INT 2
80878: NEG
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 1
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 1
80897: PUSH
80898: LD_INT 2
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 0
80907: PUSH
80908: LD_INT 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: NEG
80918: PUSH
80919: LD_INT 1
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 1
80928: NEG
80929: PUSH
80930: LD_INT 3
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: LD_INT 3
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: LD_INT 2
80954: NEG
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80978: LD_ADDR_VAR 0 15
80982: PUSH
80983: LD_INT 0
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 0
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: PUSH
81007: LD_INT 0
81009: PUSH
81010: EMPTY
81011: LIST
81012: LIST
81013: PUSH
81014: LD_INT 1
81016: PUSH
81017: LD_INT 1
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 0
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 1
81036: NEG
81037: PUSH
81038: LD_INT 0
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: LD_INT 1
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: LD_INT 1
81062: NEG
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 2
81070: PUSH
81071: LD_INT 0
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: LD_INT 1
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 1
81090: NEG
81091: PUSH
81092: LD_INT 1
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: PUSH
81099: LD_INT 2
81101: NEG
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 2
81112: NEG
81113: PUSH
81114: LD_INT 1
81116: NEG
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PUSH
81122: LD_INT 2
81124: PUSH
81125: LD_INT 1
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 3
81135: PUSH
81136: LD_INT 0
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 3
81145: PUSH
81146: LD_INT 1
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81171: LD_ADDR_VAR 0 16
81175: PUSH
81176: LD_INT 0
81178: PUSH
81179: LD_INT 0
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 0
81188: PUSH
81189: LD_INT 1
81191: NEG
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 1
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 1
81209: PUSH
81210: LD_INT 1
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 0
81219: PUSH
81220: LD_INT 1
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 1
81229: NEG
81230: PUSH
81231: LD_INT 0
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 1
81240: NEG
81241: PUSH
81242: LD_INT 1
81244: NEG
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 1
81252: NEG
81253: PUSH
81254: LD_INT 2
81256: NEG
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 2
81264: PUSH
81265: LD_INT 1
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: LD_INT 2
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: LD_INT 1
81284: PUSH
81285: LD_INT 2
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: LD_INT 1
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 2
81306: NEG
81307: PUSH
81308: LD_INT 2
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 3
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 3
81328: PUSH
81329: LD_INT 3
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: PUSH
81339: LD_INT 3
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81364: LD_ADDR_VAR 0 17
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 0
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: LD_INT 1
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 0
81412: PUSH
81413: LD_INT 1
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 1
81422: NEG
81423: PUSH
81424: LD_INT 0
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 1
81433: NEG
81434: PUSH
81435: LD_INT 1
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 1
81445: NEG
81446: PUSH
81447: LD_INT 2
81449: NEG
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 0
81457: PUSH
81458: LD_INT 2
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: LD_INT 1
81471: NEG
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: LD_INT 0
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: LD_INT 2
81489: PUSH
81490: LD_INT 1
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 2
81499: PUSH
81500: LD_INT 2
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: LD_INT 2
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 0
81519: PUSH
81520: LD_INT 2
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 1
81529: NEG
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 2
81540: NEG
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 2
81551: NEG
81552: PUSH
81553: LD_INT 1
81555: NEG
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 2
81563: NEG
81564: PUSH
81565: LD_INT 2
81567: NEG
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81594: LD_ADDR_VAR 0 18
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 0
81611: PUSH
81612: LD_INT 1
81614: NEG
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 1
81622: PUSH
81623: LD_INT 0
81625: PUSH
81626: EMPTY
81627: LIST
81628: LIST
81629: PUSH
81630: LD_INT 1
81632: PUSH
81633: LD_INT 1
81635: PUSH
81636: EMPTY
81637: LIST
81638: LIST
81639: PUSH
81640: LD_INT 0
81642: PUSH
81643: LD_INT 1
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 1
81652: NEG
81653: PUSH
81654: LD_INT 0
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 1
81663: NEG
81664: PUSH
81665: LD_INT 1
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: LD_INT 2
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 0
81687: PUSH
81688: LD_INT 2
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 1
81698: PUSH
81699: LD_INT 1
81701: NEG
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 2
81709: PUSH
81710: LD_INT 0
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 2
81719: PUSH
81720: LD_INT 1
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 2
81729: PUSH
81730: LD_INT 2
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 1
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 0
81749: PUSH
81750: LD_INT 2
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: NEG
81760: PUSH
81761: LD_INT 1
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 2
81770: NEG
81771: PUSH
81772: LD_INT 0
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 2
81781: NEG
81782: PUSH
81783: LD_INT 1
81785: NEG
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 2
81793: NEG
81794: PUSH
81795: LD_INT 2
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81824: LD_ADDR_VAR 0 19
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 0
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: PUSH
81853: LD_INT 0
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 1
81862: PUSH
81863: LD_INT 1
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 0
81872: PUSH
81873: LD_INT 1
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 1
81882: NEG
81883: PUSH
81884: LD_INT 0
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: LD_INT 1
81897: NEG
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 1
81905: NEG
81906: PUSH
81907: LD_INT 2
81909: NEG
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 0
81917: PUSH
81918: LD_INT 2
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: LD_INT 1
81931: NEG
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 2
81939: PUSH
81940: LD_INT 0
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 2
81949: PUSH
81950: LD_INT 1
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 2
81959: PUSH
81960: LD_INT 2
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 1
81969: PUSH
81970: LD_INT 2
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 0
81979: PUSH
81980: LD_INT 2
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 1
81989: NEG
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 2
82000: NEG
82001: PUSH
82002: LD_INT 0
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 2
82011: NEG
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 2
82023: NEG
82024: PUSH
82025: LD_INT 2
82027: NEG
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82054: LD_ADDR_VAR 0 20
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: LD_INT 1
82074: NEG
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: PUSH
82083: LD_INT 0
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 1
82092: PUSH
82093: LD_INT 1
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 0
82102: PUSH
82103: LD_INT 1
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 1
82112: NEG
82113: PUSH
82114: LD_INT 0
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: LD_INT 1
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: LD_INT 2
82139: NEG
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 0
82147: PUSH
82148: LD_INT 2
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: LD_INT 1
82161: NEG
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: LD_INT 0
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: PUSH
82180: LD_INT 1
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 2
82189: PUSH
82190: LD_INT 2
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: LD_INT 2
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 0
82209: PUSH
82210: LD_INT 2
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 1
82219: NEG
82220: PUSH
82221: LD_INT 1
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: NEG
82231: PUSH
82232: LD_INT 0
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PUSH
82239: LD_INT 2
82241: NEG
82242: PUSH
82243: LD_INT 1
82245: NEG
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 2
82253: NEG
82254: PUSH
82255: LD_INT 2
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82284: LD_ADDR_VAR 0 21
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 0
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: PUSH
82313: LD_INT 0
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: LD_INT 1
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 0
82332: PUSH
82333: LD_INT 1
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 1
82342: NEG
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: LD_INT 1
82357: NEG
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 1
82365: NEG
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 0
82377: PUSH
82378: LD_INT 2
82380: NEG
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 1
82388: PUSH
82389: LD_INT 1
82391: NEG
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 2
82399: PUSH
82400: LD_INT 0
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 2
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 2
82419: PUSH
82420: LD_INT 2
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 1
82429: PUSH
82430: LD_INT 2
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 1
82449: NEG
82450: PUSH
82451: LD_INT 1
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 2
82460: NEG
82461: PUSH
82462: LD_INT 0
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 2
82471: NEG
82472: PUSH
82473: LD_INT 1
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 2
82483: NEG
82484: PUSH
82485: LD_INT 2
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82514: LD_ADDR_VAR 0 22
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 0
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: PUSH
82543: LD_INT 0
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 1
82552: PUSH
82553: LD_INT 1
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 0
82562: PUSH
82563: LD_INT 1
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 1
82572: NEG
82573: PUSH
82574: LD_INT 0
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 1
82583: NEG
82584: PUSH
82585: LD_INT 1
82587: NEG
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: LD_INT 2
82599: NEG
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 0
82607: PUSH
82608: LD_INT 2
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 2
82629: PUSH
82630: LD_INT 0
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 2
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 2
82649: PUSH
82650: LD_INT 2
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 1
82659: PUSH
82660: LD_INT 2
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 0
82669: PUSH
82670: LD_INT 2
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 1
82679: NEG
82680: PUSH
82681: LD_INT 1
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 2
82690: NEG
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 2
82701: NEG
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: NEG
82714: PUSH
82715: LD_INT 2
82717: NEG
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82744: LD_ADDR_VAR 0 23
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: PUSH
82773: LD_INT 0
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 1
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 0
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: LD_INT 1
82817: NEG
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: NEG
82826: PUSH
82827: LD_INT 2
82829: NEG
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: LD_INT 2
82840: NEG
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 1
82848: PUSH
82849: LD_INT 1
82851: NEG
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 2
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 2
82869: PUSH
82870: LD_INT 1
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 2
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 1
82889: PUSH
82890: LD_INT 2
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 0
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 1
82909: NEG
82910: PUSH
82911: LD_INT 1
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 2
82920: NEG
82921: PUSH
82922: LD_INT 0
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 2
82931: NEG
82932: PUSH
82933: LD_INT 1
82935: NEG
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 2
82943: NEG
82944: PUSH
82945: LD_INT 2
82947: NEG
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 2
82955: NEG
82956: PUSH
82957: LD_INT 3
82959: NEG
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 1
82967: NEG
82968: PUSH
82969: LD_INT 3
82971: NEG
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 1
82979: PUSH
82980: LD_INT 2
82982: NEG
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 2
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83024: LD_ADDR_VAR 0 24
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: LD_INT 0
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 1
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 0
83072: PUSH
83073: LD_INT 1
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 1
83082: NEG
83083: PUSH
83084: LD_INT 0
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: LD_INT 1
83097: NEG
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 1
83105: NEG
83106: PUSH
83107: LD_INT 2
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 0
83117: PUSH
83118: LD_INT 2
83120: NEG
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 1
83128: PUSH
83129: LD_INT 1
83131: NEG
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 2
83139: PUSH
83140: LD_INT 0
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 2
83149: PUSH
83150: LD_INT 1
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 2
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: LD_INT 2
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 0
83179: PUSH
83180: LD_INT 2
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: LD_INT 1
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: LD_INT 0
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 2
83211: NEG
83212: PUSH
83213: LD_INT 1
83215: NEG
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 2
83223: NEG
83224: PUSH
83225: LD_INT 2
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 1
83235: PUSH
83236: LD_INT 2
83238: NEG
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 2
83246: PUSH
83247: LD_INT 1
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 3
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 3
83267: PUSH
83268: LD_INT 2
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83300: LD_ADDR_VAR 0 25
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 1
83328: PUSH
83329: LD_INT 0
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 0
83348: PUSH
83349: LD_INT 1
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 1
83358: NEG
83359: PUSH
83360: LD_INT 0
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 1
83381: NEG
83382: PUSH
83383: LD_INT 2
83385: NEG
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 0
83393: PUSH
83394: LD_INT 2
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 1
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 2
83415: PUSH
83416: LD_INT 0
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: LD_INT 1
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: LD_INT 2
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 1
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 0
83455: PUSH
83456: LD_INT 2
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 1
83465: NEG
83466: PUSH
83467: LD_INT 1
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 2
83476: NEG
83477: PUSH
83478: LD_INT 0
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 2
83487: NEG
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 2
83499: NEG
83500: PUSH
83501: LD_INT 2
83503: NEG
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 3
83511: PUSH
83512: LD_INT 1
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 3
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: LD_INT 3
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 1
83541: PUSH
83542: LD_INT 3
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83574: LD_ADDR_VAR 0 26
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 0
83591: PUSH
83592: LD_INT 1
83594: NEG
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 1
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 1
83612: PUSH
83613: LD_INT 1
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 0
83622: PUSH
83623: LD_INT 1
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 1
83632: NEG
83633: PUSH
83634: LD_INT 0
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: LD_INT 1
83643: NEG
83644: PUSH
83645: LD_INT 1
83647: NEG
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 1
83655: NEG
83656: PUSH
83657: LD_INT 2
83659: NEG
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 0
83667: PUSH
83668: LD_INT 2
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 1
83678: PUSH
83679: LD_INT 1
83681: NEG
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: LD_INT 0
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 2
83699: PUSH
83700: LD_INT 1
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 2
83709: PUSH
83710: LD_INT 2
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 1
83719: PUSH
83720: LD_INT 2
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 0
83729: PUSH
83730: LD_INT 2
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 1
83739: NEG
83740: PUSH
83741: LD_INT 1
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: LD_INT 2
83750: NEG
83751: PUSH
83752: LD_INT 0
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 2
83761: NEG
83762: PUSH
83763: LD_INT 1
83765: NEG
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 2
83773: NEG
83774: PUSH
83775: LD_INT 2
83777: NEG
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 2
83785: PUSH
83786: LD_INT 3
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 1
83795: PUSH
83796: LD_INT 3
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 1
83805: NEG
83806: PUSH
83807: LD_INT 2
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 2
83816: NEG
83817: PUSH
83818: LD_INT 1
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83850: LD_ADDR_VAR 0 27
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 0
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 1
83878: PUSH
83879: LD_INT 0
83881: PUSH
83882: EMPTY
83883: LIST
83884: LIST
83885: PUSH
83886: LD_INT 1
83888: PUSH
83889: LD_INT 1
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 0
83898: PUSH
83899: LD_INT 1
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 1
83908: NEG
83909: PUSH
83910: LD_INT 0
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 1
83919: NEG
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 1
83931: NEG
83932: PUSH
83933: LD_INT 2
83935: NEG
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 0
83943: PUSH
83944: LD_INT 2
83946: NEG
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 1
83954: PUSH
83955: LD_INT 1
83957: NEG
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 2
83965: PUSH
83966: LD_INT 0
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 2
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 2
83985: PUSH
83986: LD_INT 2
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: LD_INT 1
83995: PUSH
83996: LD_INT 2
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: LD_INT 2
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: LD_INT 1
84015: NEG
84016: PUSH
84017: LD_INT 1
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 2
84026: NEG
84027: PUSH
84028: LD_INT 0
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 2
84037: NEG
84038: PUSH
84039: LD_INT 1
84041: NEG
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 2
84049: NEG
84050: PUSH
84051: LD_INT 2
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 1
84061: NEG
84062: PUSH
84063: LD_INT 2
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 2
84072: NEG
84073: PUSH
84074: LD_INT 1
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 3
84083: NEG
84084: PUSH
84085: LD_INT 1
84087: NEG
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 3
84095: NEG
84096: PUSH
84097: LD_INT 2
84099: NEG
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84130: LD_ADDR_VAR 0 28
84134: PUSH
84135: LD_INT 0
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 0
84147: PUSH
84148: LD_INT 1
84150: NEG
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 1
84158: PUSH
84159: LD_INT 0
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 1
84168: PUSH
84169: LD_INT 1
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 0
84178: PUSH
84179: LD_INT 1
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 1
84188: NEG
84189: PUSH
84190: LD_INT 0
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 1
84199: NEG
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 1
84211: NEG
84212: PUSH
84213: LD_INT 2
84215: NEG
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 0
84223: PUSH
84224: LD_INT 2
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: LD_INT 1
84237: NEG
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 2
84245: PUSH
84246: LD_INT 0
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 2
84255: PUSH
84256: LD_INT 1
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 2
84265: PUSH
84266: LD_INT 2
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: LD_INT 2
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 0
84285: PUSH
84286: LD_INT 2
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 1
84295: NEG
84296: PUSH
84297: LD_INT 1
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 2
84306: NEG
84307: PUSH
84308: LD_INT 0
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 2
84317: NEG
84318: PUSH
84319: LD_INT 1
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 2
84329: NEG
84330: PUSH
84331: LD_INT 2
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 2
84341: NEG
84342: PUSH
84343: LD_INT 3
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: LD_INT 3
84357: NEG
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 3
84365: NEG
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 3
84377: NEG
84378: PUSH
84379: LD_INT 2
84381: NEG
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84412: LD_ADDR_VAR 0 29
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: LD_INT 0
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 0
84429: PUSH
84430: LD_INT 1
84432: NEG
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: LD_INT 0
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: LD_INT 1
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: LD_INT 1
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 1
84470: NEG
84471: PUSH
84472: LD_INT 0
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: LD_INT 1
84485: NEG
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: LD_INT 2
84497: NEG
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: LD_INT 2
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 1
84516: PUSH
84517: LD_INT 1
84519: NEG
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 2
84527: PUSH
84528: LD_INT 0
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: LD_INT 2
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: LD_INT 2
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 1
84567: NEG
84568: PUSH
84569: LD_INT 1
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 2
84578: NEG
84579: PUSH
84580: LD_INT 1
84582: NEG
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 2
84590: NEG
84591: PUSH
84592: LD_INT 2
84594: NEG
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 2
84602: NEG
84603: PUSH
84604: LD_INT 3
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 2
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 3
84625: PUSH
84626: LD_INT 1
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 3
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: LD_INT 2
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 3
84656: NEG
84657: PUSH
84658: LD_INT 2
84660: NEG
84661: PUSH
84662: EMPTY
84663: LIST
84664: LIST
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84691: LD_ADDR_VAR 0 30
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: PUSH
84706: LD_INT 0
84708: PUSH
84709: LD_INT 1
84711: NEG
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PUSH
84727: LD_INT 1
84729: PUSH
84730: LD_INT 1
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 0
84739: PUSH
84740: LD_INT 1
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: PUSH
84747: LD_INT 1
84749: NEG
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: LD_INT 1
84764: NEG
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 1
84772: NEG
84773: PUSH
84774: LD_INT 2
84776: NEG
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: LD_INT 2
84787: NEG
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: PUSH
84796: LD_INT 1
84798: NEG
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 2
84806: PUSH
84807: LD_INT 0
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 2
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: LD_INT 2
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: LD_INT 1
84836: PUSH
84837: LD_INT 2
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 1
84846: NEG
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 2
84857: NEG
84858: PUSH
84859: LD_INT 0
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 2
84868: NEG
84869: PUSH
84870: LD_INT 1
84872: NEG
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: LD_INT 3
84884: NEG
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: LD_INT 2
84895: NEG
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 3
84903: PUSH
84904: LD_INT 2
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 2
84913: PUSH
84914: LD_INT 3
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: PUSH
84921: LD_INT 2
84923: NEG
84924: PUSH
84925: LD_INT 1
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 3
84934: NEG
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84969: LD_ADDR_VAR 0 31
84973: PUSH
84974: LD_INT 0
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 0
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 1
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 0
85017: PUSH
85018: LD_INT 1
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: LD_INT 0
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: NEG
85039: PUSH
85040: LD_INT 1
85042: NEG
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: LD_INT 2
85054: NEG
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 1
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 2
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 2
85083: PUSH
85084: LD_INT 1
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 2
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 2
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: LD_INT 2
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 2
85134: NEG
85135: PUSH
85136: LD_INT 1
85138: NEG
85139: PUSH
85140: EMPTY
85141: LIST
85142: LIST
85143: PUSH
85144: LD_INT 2
85146: NEG
85147: PUSH
85148: LD_INT 2
85150: NEG
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 2
85158: NEG
85159: PUSH
85160: LD_INT 3
85162: NEG
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 2
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 3
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 1
85191: PUSH
85192: LD_INT 3
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 1
85201: NEG
85202: PUSH
85203: LD_INT 2
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 3
85212: NEG
85213: PUSH
85214: LD_INT 2
85216: NEG
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85247: LD_ADDR_VAR 0 32
85251: PUSH
85252: LD_INT 0
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 0
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: PUSH
85276: LD_INT 0
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 1
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: LD_INT 0
85295: PUSH
85296: LD_INT 1
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_INT 1
85305: NEG
85306: PUSH
85307: LD_INT 0
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: LD_INT 1
85320: NEG
85321: PUSH
85322: EMPTY
85323: LIST
85324: LIST
85325: PUSH
85326: LD_INT 1
85328: NEG
85329: PUSH
85330: LD_INT 2
85332: NEG
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 0
85340: PUSH
85341: LD_INT 2
85343: NEG
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 1
85351: PUSH
85352: LD_INT 1
85354: NEG
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 2
85362: PUSH
85363: LD_INT 1
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 2
85372: PUSH
85373: LD_INT 2
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 1
85382: PUSH
85383: LD_INT 2
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: LD_INT 2
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: LD_INT 1
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 2
85413: NEG
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 2
85424: NEG
85425: PUSH
85426: LD_INT 1
85428: NEG
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 1
85436: NEG
85437: PUSH
85438: LD_INT 3
85440: NEG
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 1
85448: PUSH
85449: LD_INT 2
85451: NEG
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 3
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 2
85469: PUSH
85470: LD_INT 3
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 2
85479: NEG
85480: PUSH
85481: LD_INT 1
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 3
85490: NEG
85491: PUSH
85492: LD_INT 1
85494: NEG
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85525: LD_ADDR_VAR 0 33
85529: PUSH
85530: LD_INT 0
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 0
85542: PUSH
85543: LD_INT 1
85545: NEG
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: PUSH
85554: LD_INT 0
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 1
85563: PUSH
85564: LD_INT 1
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 0
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: LD_INT 0
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 1
85594: NEG
85595: PUSH
85596: LD_INT 1
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: LD_INT 2
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: LD_INT 1
85621: NEG
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 2
85629: PUSH
85630: LD_INT 0
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 2
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 1
85649: PUSH
85650: LD_INT 2
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: LD_INT 2
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: LD_INT 1
85669: NEG
85670: PUSH
85671: LD_INT 1
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 2
85680: NEG
85681: PUSH
85682: LD_INT 0
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: LD_INT 2
85691: NEG
85692: PUSH
85693: LD_INT 1
85695: NEG
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 2
85703: NEG
85704: PUSH
85705: LD_INT 2
85707: NEG
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: LD_INT 2
85715: NEG
85716: PUSH
85717: LD_INT 3
85719: NEG
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 2
85727: PUSH
85728: LD_INT 1
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 3
85738: PUSH
85739: LD_INT 1
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 1
85748: PUSH
85749: LD_INT 3
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 3
85769: NEG
85770: PUSH
85771: LD_INT 2
85773: NEG
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85804: LD_ADDR_VAR 0 34
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 0
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 0
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: LD_INT 0
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: LD_INT 1
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: LD_INT 1
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 1
85862: NEG
85863: PUSH
85864: LD_INT 0
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 1
85873: NEG
85874: PUSH
85875: LD_INT 1
85877: NEG
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 1
85885: NEG
85886: PUSH
85887: LD_INT 2
85889: NEG
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 0
85897: PUSH
85898: LD_INT 2
85900: NEG
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 1
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 2
85919: PUSH
85920: LD_INT 1
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 2
85929: PUSH
85930: LD_INT 2
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: LD_INT 2
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 1
85949: NEG
85950: PUSH
85951: LD_INT 1
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 2
85960: NEG
85961: PUSH
85962: LD_INT 0
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: PUSH
85969: LD_INT 2
85971: NEG
85972: PUSH
85973: LD_INT 1
85975: NEG
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 2
85983: NEG
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: LD_INT 3
85999: NEG
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 1
86007: PUSH
86008: LD_INT 2
86010: NEG
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: LD_INT 3
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 2
86028: PUSH
86029: LD_INT 3
86031: PUSH
86032: EMPTY
86033: LIST
86034: LIST
86035: PUSH
86036: LD_INT 2
86038: NEG
86039: PUSH
86040: LD_INT 1
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: PUSH
86047: LD_INT 3
86049: NEG
86050: PUSH
86051: LD_INT 1
86053: NEG
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86084: LD_ADDR_VAR 0 35
86088: PUSH
86089: LD_INT 0
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 0
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: PUSH
86113: LD_INT 0
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 0
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 1
86142: NEG
86143: PUSH
86144: LD_INT 0
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 1
86153: NEG
86154: PUSH
86155: LD_INT 1
86157: NEG
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 2
86165: PUSH
86166: LD_INT 1
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 2
86175: NEG
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86196: LD_ADDR_VAR 0 36
86200: PUSH
86201: LD_INT 0
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 1
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PUSH
86252: LD_INT 1
86254: NEG
86255: PUSH
86256: LD_INT 0
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 1
86265: NEG
86266: PUSH
86267: LD_INT 1
86269: NEG
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: NEG
86278: PUSH
86279: LD_INT 2
86281: NEG
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: PUSH
86290: LD_INT 2
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86308: LD_ADDR_VAR 0 37
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: LD_INT 1
86328: NEG
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PUSH
86334: LD_INT 1
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 1
86346: PUSH
86347: LD_INT 1
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 1
86366: NEG
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 1
86377: NEG
86378: PUSH
86379: LD_INT 1
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: PUSH
86390: LD_INT 1
86392: NEG
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 1
86400: NEG
86401: PUSH
86402: LD_INT 1
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86420: LD_ADDR_VAR 0 38
86424: PUSH
86425: LD_INT 0
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 0
86437: PUSH
86438: LD_INT 1
86440: NEG
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: LD_INT 0
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 1
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 0
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 1
86478: NEG
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 2
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 2
86511: NEG
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86532: LD_ADDR_VAR 0 39
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 0
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: LD_INT 1
86605: NEG
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: PUSH
86626: LD_INT 2
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86644: LD_ADDR_VAR 0 40
86648: PUSH
86649: LD_INT 0
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 0
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: LD_INT 0
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 1
86682: PUSH
86683: LD_INT 1
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 0
86692: PUSH
86693: LD_INT 1
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PUSH
86700: LD_INT 1
86702: NEG
86703: PUSH
86704: LD_INT 0
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: LD_INT 1
86713: NEG
86714: PUSH
86715: LD_INT 1
86717: NEG
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 1
86725: PUSH
86726: LD_INT 1
86728: NEG
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: LD_INT 1
86736: NEG
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86756: LD_ADDR_VAR 0 41
86760: PUSH
86761: LD_INT 0
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 1
86784: PUSH
86785: LD_INT 0
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 1
86794: PUSH
86795: LD_INT 1
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 1
86825: NEG
86826: PUSH
86827: LD_INT 1
86829: NEG
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 1
86837: NEG
86838: PUSH
86839: LD_INT 2
86841: NEG
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: PUSH
86850: LD_INT 1
86852: NEG
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: PUSH
86861: LD_INT 0
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 1
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 2
86880: PUSH
86881: LD_INT 2
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 1
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 1
86900: NEG
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 2
86911: NEG
86912: PUSH
86913: LD_INT 0
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 2
86922: NEG
86923: PUSH
86924: LD_INT 1
86926: NEG
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 2
86934: NEG
86935: PUSH
86936: LD_INT 2
86938: NEG
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 2
86946: NEG
86947: PUSH
86948: LD_INT 3
86950: NEG
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 2
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 3
86969: PUSH
86970: LD_INT 0
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 3
86979: PUSH
86980: LD_INT 1
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 3
86989: PUSH
86990: LD_INT 2
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 3
86999: PUSH
87000: LD_INT 3
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 2
87009: PUSH
87010: LD_INT 3
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: LD_INT 1
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 3
87030: NEG
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 3
87041: NEG
87042: PUSH
87043: LD_INT 1
87045: NEG
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 3
87053: NEG
87054: PUSH
87055: LD_INT 2
87057: NEG
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 3
87065: NEG
87066: PUSH
87067: LD_INT 3
87069: NEG
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87106: LD_ADDR_VAR 0 42
87110: PUSH
87111: LD_INT 0
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 0
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 1
87134: PUSH
87135: LD_INT 0
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 1
87144: PUSH
87145: LD_INT 1
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: LD_INT 0
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 0
87199: PUSH
87200: LD_INT 2
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 1
87210: PUSH
87211: LD_INT 1
87213: NEG
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 2
87221: PUSH
87222: LD_INT 1
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 2
87231: PUSH
87232: LD_INT 2
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 1
87241: PUSH
87242: LD_INT 2
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PUSH
87249: LD_INT 0
87251: PUSH
87252: LD_INT 2
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 1
87261: NEG
87262: PUSH
87263: LD_INT 1
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 2
87272: NEG
87273: PUSH
87274: LD_INT 1
87276: NEG
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 2
87284: NEG
87285: PUSH
87286: LD_INT 2
87288: NEG
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: LD_INT 3
87300: NEG
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 1
87308: NEG
87309: PUSH
87310: LD_INT 3
87312: NEG
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 0
87320: PUSH
87321: LD_INT 3
87323: NEG
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: PUSH
87332: LD_INT 2
87334: NEG
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 3
87342: PUSH
87343: LD_INT 2
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 3
87352: PUSH
87353: LD_INT 3
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 2
87362: PUSH
87363: LD_INT 3
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: PUSH
87373: LD_INT 3
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: LD_INT 3
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 1
87392: NEG
87393: PUSH
87394: LD_INT 2
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 3
87403: NEG
87404: PUSH
87405: LD_INT 2
87407: NEG
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 3
87415: NEG
87416: PUSH
87417: LD_INT 3
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87456: LD_ADDR_VAR 0 43
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 0
87473: PUSH
87474: LD_INT 1
87476: NEG
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 1
87484: PUSH
87485: LD_INT 0
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 0
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: NEG
87515: PUSH
87516: LD_INT 0
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: LD_INT 2
87541: NEG
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 0
87549: PUSH
87550: LD_INT 2
87552: NEG
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: LD_INT 1
87563: NEG
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 2
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 2
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 1
87591: PUSH
87592: LD_INT 2
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: LD_INT 2
87604: PUSH
87605: EMPTY
87606: LIST
87607: LIST
87608: PUSH
87609: LD_INT 1
87611: NEG
87612: PUSH
87613: LD_INT 1
87615: PUSH
87616: EMPTY
87617: LIST
87618: LIST
87619: PUSH
87620: LD_INT 2
87622: NEG
87623: PUSH
87624: LD_INT 0
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 2
87633: NEG
87634: PUSH
87635: LD_INT 1
87637: NEG
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: NEG
87646: PUSH
87647: LD_INT 3
87649: NEG
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 0
87657: PUSH
87658: LD_INT 3
87660: NEG
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: LD_INT 2
87671: NEG
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 2
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 3
87690: PUSH
87691: LD_INT 0
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 3
87700: PUSH
87701: LD_INT 1
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: LD_INT 3
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: LD_INT 0
87720: PUSH
87721: LD_INT 3
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 1
87730: NEG
87731: PUSH
87732: LD_INT 2
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 2
87741: NEG
87742: PUSH
87743: LD_INT 1
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 3
87752: NEG
87753: PUSH
87754: LD_INT 0
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 3
87763: NEG
87764: PUSH
87765: LD_INT 1
87767: NEG
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87804: LD_ADDR_VAR 0 44
87808: PUSH
87809: LD_INT 0
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 0
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PUSH
87830: LD_INT 1
87832: PUSH
87833: LD_INT 0
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 1
87842: PUSH
87843: LD_INT 1
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 1
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: NEG
87874: PUSH
87875: LD_INT 1
87877: NEG
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 1
87885: NEG
87886: PUSH
87887: LD_INT 2
87889: NEG
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: LD_INT 1
87900: NEG
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 2
87908: PUSH
87909: LD_INT 0
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 2
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 2
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: LD_INT 2
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: NEG
87949: PUSH
87950: LD_INT 1
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 2
87959: NEG
87960: PUSH
87961: LD_INT 0
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 2
87970: NEG
87971: PUSH
87972: LD_INT 1
87974: NEG
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 2
87982: NEG
87983: PUSH
87984: LD_INT 2
87986: NEG
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 2
87994: NEG
87995: PUSH
87996: LD_INT 3
87998: NEG
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: PUSH
88004: LD_INT 2
88006: PUSH
88007: LD_INT 1
88009: NEG
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 3
88017: PUSH
88018: LD_INT 0
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 3
88027: PUSH
88028: LD_INT 1
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 3
88037: PUSH
88038: LD_INT 2
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 3
88047: PUSH
88048: LD_INT 3
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: LD_INT 3
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 3
88078: NEG
88079: PUSH
88080: LD_INT 0
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 3
88089: NEG
88090: PUSH
88091: LD_INT 1
88093: NEG
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 3
88101: NEG
88102: PUSH
88103: LD_INT 2
88105: NEG
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 3
88113: NEG
88114: PUSH
88115: LD_INT 3
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88154: LD_ADDR_VAR 0 45
88158: PUSH
88159: LD_INT 0
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 0
88171: PUSH
88172: LD_INT 1
88174: NEG
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: PUSH
88183: LD_INT 0
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: PUSH
88190: LD_INT 1
88192: PUSH
88193: LD_INT 1
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 0
88202: PUSH
88203: LD_INT 1
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 1
88212: NEG
88213: PUSH
88214: LD_INT 0
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 1
88235: NEG
88236: PUSH
88237: LD_INT 2
88239: NEG
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 0
88247: PUSH
88248: LD_INT 2
88250: NEG
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 1
88258: PUSH
88259: LD_INT 1
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 2
88269: PUSH
88270: LD_INT 1
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 2
88279: PUSH
88280: LD_INT 2
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 1
88289: PUSH
88290: LD_INT 2
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_INT 0
88299: PUSH
88300: LD_INT 2
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 1
88309: NEG
88310: PUSH
88311: LD_INT 1
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 2
88320: NEG
88321: PUSH
88322: LD_INT 1
88324: NEG
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 2
88332: NEG
88333: PUSH
88334: LD_INT 2
88336: NEG
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: LD_INT 3
88348: NEG
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 3
88360: NEG
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: LD_INT 3
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: PUSH
88380: LD_INT 2
88382: NEG
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 3
88390: PUSH
88391: LD_INT 2
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 3
88400: PUSH
88401: LD_INT 3
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 2
88410: PUSH
88411: LD_INT 3
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 1
88420: PUSH
88421: LD_INT 3
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 0
88430: PUSH
88431: LD_INT 3
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 1
88440: NEG
88441: PUSH
88442: LD_INT 2
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 3
88451: NEG
88452: PUSH
88453: LD_INT 2
88455: NEG
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 3
88463: NEG
88464: PUSH
88465: LD_INT 3
88467: NEG
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88504: LD_ADDR_VAR 0 46
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 0
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: PUSH
88533: LD_INT 0
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: LD_INT 1
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 0
88552: PUSH
88553: LD_INT 1
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 1
88562: NEG
88563: PUSH
88564: LD_INT 0
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: LD_INT 1
88577: NEG
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: PUSH
88583: LD_INT 1
88585: NEG
88586: PUSH
88587: LD_INT 2
88589: NEG
88590: PUSH
88591: EMPTY
88592: LIST
88593: LIST
88594: PUSH
88595: LD_INT 0
88597: PUSH
88598: LD_INT 2
88600: NEG
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 1
88608: PUSH
88609: LD_INT 1
88611: NEG
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 2
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 2
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 1
88639: PUSH
88640: LD_INT 2
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 0
88649: PUSH
88650: LD_INT 2
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 1
88659: NEG
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: PUSH
88668: LD_INT 2
88670: NEG
88671: PUSH
88672: LD_INT 0
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 2
88681: NEG
88682: PUSH
88683: LD_INT 1
88685: NEG
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 1
88693: NEG
88694: PUSH
88695: LD_INT 3
88697: NEG
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: LD_INT 3
88708: NEG
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 1
88716: PUSH
88717: LD_INT 2
88719: NEG
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 2
88727: PUSH
88728: LD_INT 1
88730: NEG
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 3
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 3
88748: PUSH
88749: LD_INT 1
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 1
88758: PUSH
88759: LD_INT 3
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: LD_INT 0
88768: PUSH
88769: LD_INT 3
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 1
88778: NEG
88779: PUSH
88780: LD_INT 2
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 2
88789: NEG
88790: PUSH
88791: LD_INT 1
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 3
88800: NEG
88801: PUSH
88802: LD_INT 0
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 3
88811: NEG
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88852: LD_ADDR_VAR 0 47
88856: PUSH
88857: LD_INT 0
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 0
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 1
88880: PUSH
88881: LD_INT 0
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 1
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 0
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 1
88910: NEG
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 1
88921: NEG
88922: PUSH
88923: LD_INT 1
88925: NEG
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: LD_INT 2
88937: NEG
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: LD_INT 2
88948: NEG
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 1
88956: PUSH
88957: LD_INT 1
88959: NEG
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 2
88967: NEG
88968: PUSH
88969: LD_INT 1
88971: NEG
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: NEG
88980: PUSH
88981: LD_INT 2
88983: NEG
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89003: LD_ADDR_VAR 0 48
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 0
89020: PUSH
89021: LD_INT 1
89023: NEG
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: PUSH
89032: LD_INT 0
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 1
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 0
89051: PUSH
89052: LD_INT 1
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 1
89061: NEG
89062: PUSH
89063: LD_INT 0
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PUSH
89070: LD_INT 1
89072: NEG
89073: PUSH
89074: LD_INT 1
89076: NEG
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: PUSH
89086: LD_INT 2
89088: NEG
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 0
89096: PUSH
89097: LD_INT 2
89099: NEG
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: PUSH
89108: LD_INT 1
89110: NEG
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 2
89118: PUSH
89119: LD_INT 0
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 2
89128: PUSH
89129: LD_INT 1
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: EMPTY
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89150: LD_ADDR_VAR 0 49
89154: PUSH
89155: LD_INT 0
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: LD_INT 0
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 1
89178: PUSH
89179: LD_INT 0
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 1
89188: PUSH
89189: LD_INT 1
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: LD_INT 1
89201: PUSH
89202: EMPTY
89203: LIST
89204: LIST
89205: PUSH
89206: LD_INT 1
89208: NEG
89209: PUSH
89210: LD_INT 0
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: LD_INT 1
89219: NEG
89220: PUSH
89221: LD_INT 1
89223: NEG
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 1
89231: PUSH
89232: LD_INT 1
89234: NEG
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 2
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 2
89252: PUSH
89253: LD_INT 1
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 2
89262: PUSH
89263: LD_INT 2
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: LD_INT 2
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89294: LD_ADDR_VAR 0 50
89298: PUSH
89299: LD_INT 0
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 0
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: PUSH
89323: LD_INT 0
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 1
89332: PUSH
89333: LD_INT 1
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 0
89342: PUSH
89343: LD_INT 1
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 1
89352: NEG
89353: PUSH
89354: LD_INT 0
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 1
89363: NEG
89364: PUSH
89365: LD_INT 1
89367: NEG
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 2
89375: PUSH
89376: LD_INT 1
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 2
89385: PUSH
89386: LD_INT 2
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 1
89395: PUSH
89396: LD_INT 2
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 0
89405: PUSH
89406: LD_INT 2
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 1
89415: NEG
89416: PUSH
89417: LD_INT 1
89419: PUSH
89420: EMPTY
89421: LIST
89422: LIST
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89438: LD_ADDR_VAR 0 51
89442: PUSH
89443: LD_INT 0
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 0
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: LD_INT 1
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 0
89486: PUSH
89487: LD_INT 1
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 0
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 1
89507: NEG
89508: PUSH
89509: LD_INT 1
89511: NEG
89512: PUSH
89513: EMPTY
89514: LIST
89515: LIST
89516: PUSH
89517: LD_INT 1
89519: PUSH
89520: LD_INT 2
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 0
89529: PUSH
89530: LD_INT 2
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: PUSH
89537: LD_INT 1
89539: NEG
89540: PUSH
89541: LD_INT 1
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 2
89550: NEG
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 2
89561: NEG
89562: PUSH
89563: LD_INT 1
89565: NEG
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89585: LD_ADDR_VAR 0 52
89589: PUSH
89590: LD_INT 0
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 0
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 1
89623: PUSH
89624: LD_INT 1
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 0
89633: PUSH
89634: LD_INT 1
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: LD_INT 1
89658: NEG
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: LD_INT 2
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: NEG
89679: PUSH
89680: LD_INT 1
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 2
89689: NEG
89690: PUSH
89691: LD_INT 0
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: LD_INT 1
89704: NEG
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 2
89712: NEG
89713: PUSH
89714: LD_INT 2
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89736: LD_ADDR_VAR 0 53
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 0
89753: PUSH
89754: LD_INT 1
89756: NEG
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: LD_INT 0
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: LD_INT 1
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 0
89784: PUSH
89785: LD_INT 1
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 1
89794: NEG
89795: PUSH
89796: LD_INT 0
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: LD_INT 1
89809: NEG
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 1
89817: NEG
89818: PUSH
89819: LD_INT 2
89821: NEG
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 0
89829: PUSH
89830: LD_INT 2
89832: NEG
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: LD_INT 1
89843: NEG
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 2
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 2
89861: PUSH
89862: LD_INT 1
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 2
89871: PUSH
89872: LD_INT 2
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 1
89881: PUSH
89882: LD_INT 2
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 0
89891: PUSH
89892: LD_INT 2
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: NEG
89902: PUSH
89903: LD_INT 1
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 2
89912: NEG
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PUSH
89921: LD_INT 2
89923: NEG
89924: PUSH
89925: LD_INT 1
89927: NEG
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 2
89935: NEG
89936: PUSH
89937: LD_INT 2
89939: NEG
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89966: LD_ADDR_VAR 0 54
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 0
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 0
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 1
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 0
90014: PUSH
90015: LD_INT 1
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 1
90024: NEG
90025: PUSH
90026: LD_INT 0
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: LD_INT 1
90039: NEG
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: LD_INT 2
90051: NEG
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: LD_INT 2
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 1
90070: PUSH
90071: LD_INT 1
90073: NEG
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: PUSH
90082: LD_INT 0
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 2
90091: PUSH
90092: LD_INT 1
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 2
90101: PUSH
90102: LD_INT 2
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 1
90111: PUSH
90112: LD_INT 2
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: LD_INT 2
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: LD_INT 1
90131: NEG
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 2
90142: NEG
90143: PUSH
90144: LD_INT 0
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 2
90153: NEG
90154: PUSH
90155: LD_INT 1
90157: NEG
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 2
90165: NEG
90166: PUSH
90167: LD_INT 2
90169: NEG
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90196: LD_ADDR_VAR 0 55
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 0
90213: PUSH
90214: LD_INT 1
90216: NEG
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 1
90224: PUSH
90225: LD_INT 0
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: LD_INT 1
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: PUSH
90242: LD_INT 0
90244: PUSH
90245: LD_INT 1
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: PUSH
90252: LD_INT 1
90254: NEG
90255: PUSH
90256: LD_INT 0
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 1
90265: NEG
90266: PUSH
90267: LD_INT 1
90269: NEG
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: LD_INT 2
90281: NEG
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 0
90289: PUSH
90290: LD_INT 2
90292: NEG
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 1
90300: PUSH
90301: LD_INT 1
90303: NEG
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 2
90311: PUSH
90312: LD_INT 0
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: LD_INT 2
90321: PUSH
90322: LD_INT 1
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 2
90331: PUSH
90332: LD_INT 2
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 1
90341: PUSH
90342: LD_INT 2
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 0
90351: PUSH
90352: LD_INT 2
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 1
90361: NEG
90362: PUSH
90363: LD_INT 1
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: LD_INT 2
90372: NEG
90373: PUSH
90374: LD_INT 0
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: PUSH
90381: LD_INT 2
90383: NEG
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 2
90395: NEG
90396: PUSH
90397: LD_INT 2
90399: NEG
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90426: LD_ADDR_VAR 0 56
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 0
90443: PUSH
90444: LD_INT 1
90446: NEG
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 1
90464: PUSH
90465: LD_INT 1
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: LD_INT 1
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: LD_INT 0
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: LD_INT 1
90499: NEG
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: LD_INT 2
90511: NEG
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 0
90519: PUSH
90520: LD_INT 2
90522: NEG
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: PUSH
90528: LD_INT 1
90530: PUSH
90531: LD_INT 1
90533: NEG
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 2
90541: PUSH
90542: LD_INT 0
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 2
90551: PUSH
90552: LD_INT 1
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 2
90561: PUSH
90562: LD_INT 2
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 1
90571: PUSH
90572: LD_INT 2
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 0
90581: PUSH
90582: LD_INT 2
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 1
90591: NEG
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 2
90602: NEG
90603: PUSH
90604: LD_INT 0
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 2
90613: NEG
90614: PUSH
90615: LD_INT 1
90617: NEG
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 2
90625: NEG
90626: PUSH
90627: LD_INT 2
90629: NEG
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90656: LD_ADDR_VAR 0 57
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 0
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 1
90684: PUSH
90685: LD_INT 0
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 1
90694: PUSH
90695: LD_INT 1
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: PUSH
90702: LD_INT 0
90704: PUSH
90705: LD_INT 1
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PUSH
90712: LD_INT 1
90714: NEG
90715: PUSH
90716: LD_INT 0
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: LD_INT 1
90729: NEG
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: LD_INT 2
90741: NEG
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: LD_INT 0
90749: PUSH
90750: LD_INT 2
90752: NEG
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 1
90760: PUSH
90761: LD_INT 1
90763: NEG
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 2
90771: PUSH
90772: LD_INT 0
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 2
90781: PUSH
90782: LD_INT 1
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 2
90791: PUSH
90792: LD_INT 2
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 1
90801: PUSH
90802: LD_INT 2
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 0
90811: PUSH
90812: LD_INT 2
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 1
90821: NEG
90822: PUSH
90823: LD_INT 1
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 2
90832: NEG
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 2
90843: NEG
90844: PUSH
90845: LD_INT 1
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 2
90855: NEG
90856: PUSH
90857: LD_INT 2
90859: NEG
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90886: LD_ADDR_VAR 0 58
90890: PUSH
90891: LD_INT 0
90893: PUSH
90894: LD_INT 0
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 0
90903: PUSH
90904: LD_INT 1
90906: NEG
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 1
90914: PUSH
90915: LD_INT 0
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: PUSH
90922: LD_INT 1
90924: PUSH
90925: LD_INT 1
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 0
90934: PUSH
90935: LD_INT 1
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: NEG
90945: PUSH
90946: LD_INT 0
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 1
90955: NEG
90956: PUSH
90957: LD_INT 1
90959: NEG
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 1
90967: NEG
90968: PUSH
90969: LD_INT 2
90971: NEG
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: LD_INT 2
90982: NEG
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 1
90990: PUSH
90991: LD_INT 1
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 2
91001: PUSH
91002: LD_INT 0
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: LD_INT 2
91011: PUSH
91012: LD_INT 1
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 2
91021: PUSH
91022: LD_INT 2
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 1
91031: PUSH
91032: LD_INT 2
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 0
91041: PUSH
91042: LD_INT 2
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: PUSH
91049: LD_INT 1
91051: NEG
91052: PUSH
91053: LD_INT 1
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 2
91062: NEG
91063: PUSH
91064: LD_INT 0
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 2
91073: NEG
91074: PUSH
91075: LD_INT 1
91077: NEG
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 2
91085: NEG
91086: PUSH
91087: LD_INT 2
91089: NEG
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91116: LD_ADDR_VAR 0 59
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 0
91133: PUSH
91134: LD_INT 1
91136: NEG
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: LD_INT 0
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 1
91154: PUSH
91155: LD_INT 1
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 0
91164: PUSH
91165: LD_INT 1
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 1
91185: NEG
91186: PUSH
91187: LD_INT 1
91189: NEG
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91204: LD_ADDR_VAR 0 60
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: PUSH
91243: LD_INT 1
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 0
91252: PUSH
91253: LD_INT 1
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 1
91273: NEG
91274: PUSH
91275: LD_INT 1
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91292: LD_ADDR_VAR 0 61
91296: PUSH
91297: LD_INT 0
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: LD_INT 1
91312: NEG
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: PUSH
91321: LD_INT 0
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PUSH
91328: LD_INT 1
91330: PUSH
91331: LD_INT 1
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 0
91340: PUSH
91341: LD_INT 1
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 1
91350: NEG
91351: PUSH
91352: LD_INT 0
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 1
91361: NEG
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91380: LD_ADDR_VAR 0 62
91384: PUSH
91385: LD_INT 0
91387: PUSH
91388: LD_INT 0
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 0
91397: PUSH
91398: LD_INT 1
91400: NEG
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 1
91408: PUSH
91409: LD_INT 0
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 1
91418: PUSH
91419: LD_INT 1
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 0
91428: PUSH
91429: LD_INT 1
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 1
91438: NEG
91439: PUSH
91440: LD_INT 0
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 1
91449: NEG
91450: PUSH
91451: LD_INT 1
91453: NEG
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91468: LD_ADDR_VAR 0 63
91472: PUSH
91473: LD_INT 0
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 0
91485: PUSH
91486: LD_INT 1
91488: NEG
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 1
91496: PUSH
91497: LD_INT 0
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 1
91506: PUSH
91507: LD_INT 1
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 0
91516: PUSH
91517: LD_INT 1
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 1
91537: NEG
91538: PUSH
91539: LD_INT 1
91541: NEG
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91556: LD_ADDR_VAR 0 64
91560: PUSH
91561: LD_INT 0
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 0
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 1
91584: PUSH
91585: LD_INT 0
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 1
91594: PUSH
91595: LD_INT 1
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PUSH
91602: LD_INT 0
91604: PUSH
91605: LD_INT 1
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 1
91614: NEG
91615: PUSH
91616: LD_INT 0
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 1
91625: NEG
91626: PUSH
91627: LD_INT 1
91629: NEG
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: ST_TO_ADDR
// end ; 1 :
91644: GO 97541
91646: LD_INT 1
91648: DOUBLE
91649: EQUAL
91650: IFTRUE 91654
91652: GO 94277
91654: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91655: LD_ADDR_VAR 0 11
91659: PUSH
91660: LD_INT 1
91662: NEG
91663: PUSH
91664: LD_INT 3
91666: NEG
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 0
91674: PUSH
91675: LD_INT 3
91677: NEG
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 1
91685: PUSH
91686: LD_INT 2
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: LIST
91698: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91699: LD_ADDR_VAR 0 12
91703: PUSH
91704: LD_INT 2
91706: PUSH
91707: LD_INT 1
91709: NEG
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: PUSH
91715: LD_INT 3
91717: PUSH
91718: LD_INT 0
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: LD_INT 1
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: LIST
91739: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91740: LD_ADDR_VAR 0 13
91744: PUSH
91745: LD_INT 3
91747: PUSH
91748: LD_INT 2
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 3
91757: PUSH
91758: LD_INT 3
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 2
91767: PUSH
91768: LD_INT 3
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: LIST
91779: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91780: LD_ADDR_VAR 0 14
91784: PUSH
91785: LD_INT 1
91787: PUSH
91788: LD_INT 3
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 0
91797: PUSH
91798: LD_INT 3
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 1
91807: NEG
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: LIST
91820: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91821: LD_ADDR_VAR 0 15
91825: PUSH
91826: LD_INT 2
91828: NEG
91829: PUSH
91830: LD_INT 1
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PUSH
91837: LD_INT 3
91839: NEG
91840: PUSH
91841: LD_INT 0
91843: PUSH
91844: EMPTY
91845: LIST
91846: LIST
91847: PUSH
91848: LD_INT 3
91850: NEG
91851: PUSH
91852: LD_INT 1
91854: NEG
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: LIST
91864: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91865: LD_ADDR_VAR 0 16
91869: PUSH
91870: LD_INT 2
91872: NEG
91873: PUSH
91874: LD_INT 3
91876: NEG
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: LD_INT 2
91888: NEG
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: LD_INT 3
91896: NEG
91897: PUSH
91898: LD_INT 3
91900: NEG
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: LIST
91910: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91911: LD_ADDR_VAR 0 17
91915: PUSH
91916: LD_INT 1
91918: NEG
91919: PUSH
91920: LD_INT 3
91922: NEG
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 0
91930: PUSH
91931: LD_INT 3
91933: NEG
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 1
91941: PUSH
91942: LD_INT 2
91944: NEG
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: LIST
91954: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91955: LD_ADDR_VAR 0 18
91959: PUSH
91960: LD_INT 2
91962: PUSH
91963: LD_INT 1
91965: NEG
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: LD_INT 3
91973: PUSH
91974: LD_INT 0
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: PUSH
91984: LD_INT 1
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: LIST
91995: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91996: LD_ADDR_VAR 0 19
92000: PUSH
92001: LD_INT 3
92003: PUSH
92004: LD_INT 2
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 3
92013: PUSH
92014: LD_INT 3
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 2
92023: PUSH
92024: LD_INT 3
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: LIST
92035: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92036: LD_ADDR_VAR 0 20
92040: PUSH
92041: LD_INT 1
92043: PUSH
92044: LD_INT 3
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 0
92053: PUSH
92054: LD_INT 3
92056: PUSH
92057: EMPTY
92058: LIST
92059: LIST
92060: PUSH
92061: LD_INT 1
92063: NEG
92064: PUSH
92065: LD_INT 2
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: LIST
92076: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92077: LD_ADDR_VAR 0 21
92081: PUSH
92082: LD_INT 2
92084: NEG
92085: PUSH
92086: LD_INT 1
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 3
92095: NEG
92096: PUSH
92097: LD_INT 0
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 3
92106: NEG
92107: PUSH
92108: LD_INT 1
92110: NEG
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: LIST
92120: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92121: LD_ADDR_VAR 0 22
92125: PUSH
92126: LD_INT 2
92128: NEG
92129: PUSH
92130: LD_INT 3
92132: NEG
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 3
92140: NEG
92141: PUSH
92142: LD_INT 2
92144: NEG
92145: PUSH
92146: EMPTY
92147: LIST
92148: LIST
92149: PUSH
92150: LD_INT 3
92152: NEG
92153: PUSH
92154: LD_INT 3
92156: NEG
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: LIST
92166: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92167: LD_ADDR_VAR 0 23
92171: PUSH
92172: LD_INT 0
92174: PUSH
92175: LD_INT 3
92177: NEG
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 1
92185: NEG
92186: PUSH
92187: LD_INT 4
92189: NEG
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 1
92197: PUSH
92198: LD_INT 3
92200: NEG
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: EMPTY
92207: LIST
92208: LIST
92209: LIST
92210: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92211: LD_ADDR_VAR 0 24
92215: PUSH
92216: LD_INT 3
92218: PUSH
92219: LD_INT 0
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: LD_INT 3
92228: PUSH
92229: LD_INT 1
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 4
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: LIST
92251: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92252: LD_ADDR_VAR 0 25
92256: PUSH
92257: LD_INT 3
92259: PUSH
92260: LD_INT 3
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: LD_INT 4
92269: PUSH
92270: LD_INT 3
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 3
92279: PUSH
92280: LD_INT 4
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: LIST
92291: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92292: LD_ADDR_VAR 0 26
92296: PUSH
92297: LD_INT 0
92299: PUSH
92300: LD_INT 3
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 1
92309: PUSH
92310: LD_INT 4
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 1
92319: NEG
92320: PUSH
92321: LD_INT 3
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: LIST
92332: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92333: LD_ADDR_VAR 0 27
92337: PUSH
92338: LD_INT 3
92340: NEG
92341: PUSH
92342: LD_INT 0
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: PUSH
92349: LD_INT 3
92351: NEG
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 4
92362: NEG
92363: PUSH
92364: LD_INT 1
92366: NEG
92367: PUSH
92368: EMPTY
92369: LIST
92370: LIST
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: LIST
92376: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92377: LD_ADDR_VAR 0 28
92381: PUSH
92382: LD_INT 3
92384: NEG
92385: PUSH
92386: LD_INT 3
92388: NEG
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: PUSH
92394: LD_INT 3
92396: NEG
92397: PUSH
92398: LD_INT 4
92400: NEG
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 4
92408: NEG
92409: PUSH
92410: LD_INT 3
92412: NEG
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: LIST
92422: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92423: LD_ADDR_VAR 0 29
92427: PUSH
92428: LD_INT 1
92430: NEG
92431: PUSH
92432: LD_INT 3
92434: NEG
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PUSH
92440: LD_INT 0
92442: PUSH
92443: LD_INT 3
92445: NEG
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 1
92453: PUSH
92454: LD_INT 2
92456: NEG
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 1
92464: NEG
92465: PUSH
92466: LD_INT 4
92468: NEG
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 0
92476: PUSH
92477: LD_INT 4
92479: NEG
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 1
92487: PUSH
92488: LD_INT 3
92490: NEG
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 1
92498: NEG
92499: PUSH
92500: LD_INT 5
92502: NEG
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 0
92510: PUSH
92511: LD_INT 5
92513: NEG
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: PUSH
92519: LD_INT 1
92521: PUSH
92522: LD_INT 4
92524: NEG
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 1
92532: NEG
92533: PUSH
92534: LD_INT 6
92536: NEG
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: LD_INT 6
92547: NEG
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 1
92555: PUSH
92556: LD_INT 5
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92578: LD_ADDR_VAR 0 30
92582: PUSH
92583: LD_INT 2
92585: PUSH
92586: LD_INT 1
92588: NEG
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 3
92596: PUSH
92597: LD_INT 0
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 3
92606: PUSH
92607: LD_INT 1
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 3
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 4
92627: PUSH
92628: LD_INT 0
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 4
92637: PUSH
92638: LD_INT 1
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 4
92647: PUSH
92648: LD_INT 1
92650: NEG
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 5
92658: PUSH
92659: LD_INT 0
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 5
92668: PUSH
92669: LD_INT 1
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 5
92678: PUSH
92679: LD_INT 1
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 6
92689: PUSH
92690: LD_INT 0
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 6
92699: PUSH
92700: LD_INT 1
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92721: LD_ADDR_VAR 0 31
92725: PUSH
92726: LD_INT 3
92728: PUSH
92729: LD_INT 2
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 3
92738: PUSH
92739: LD_INT 3
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 2
92748: PUSH
92749: LD_INT 3
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 4
92758: PUSH
92759: LD_INT 3
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 4
92768: PUSH
92769: LD_INT 4
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 3
92778: PUSH
92779: LD_INT 4
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 5
92788: PUSH
92789: LD_INT 4
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: LD_INT 5
92798: PUSH
92799: LD_INT 5
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 4
92808: PUSH
92809: LD_INT 5
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 6
92818: PUSH
92819: LD_INT 5
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 6
92828: PUSH
92829: LD_INT 6
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 5
92838: PUSH
92839: LD_INT 6
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92860: LD_ADDR_VAR 0 32
92864: PUSH
92865: LD_INT 1
92867: PUSH
92868: LD_INT 3
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 0
92877: PUSH
92878: LD_INT 3
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 1
92887: NEG
92888: PUSH
92889: LD_INT 2
92891: PUSH
92892: EMPTY
92893: LIST
92894: LIST
92895: PUSH
92896: LD_INT 1
92898: PUSH
92899: LD_INT 4
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 0
92908: PUSH
92909: LD_INT 4
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 1
92918: NEG
92919: PUSH
92920: LD_INT 3
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 1
92929: PUSH
92930: LD_INT 5
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 0
92939: PUSH
92940: LD_INT 5
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PUSH
92947: LD_INT 1
92949: NEG
92950: PUSH
92951: LD_INT 4
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: PUSH
92958: LD_INT 1
92960: PUSH
92961: LD_INT 6
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 0
92970: PUSH
92971: LD_INT 6
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 1
92980: NEG
92981: PUSH
92982: LD_INT 5
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93003: LD_ADDR_VAR 0 33
93007: PUSH
93008: LD_INT 2
93010: NEG
93011: PUSH
93012: LD_INT 1
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 3
93021: NEG
93022: PUSH
93023: LD_INT 0
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 3
93032: NEG
93033: PUSH
93034: LD_INT 1
93036: NEG
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 3
93044: NEG
93045: PUSH
93046: LD_INT 1
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 4
93055: NEG
93056: PUSH
93057: LD_INT 0
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 4
93066: NEG
93067: PUSH
93068: LD_INT 1
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 4
93078: NEG
93079: PUSH
93080: LD_INT 1
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 5
93089: NEG
93090: PUSH
93091: LD_INT 0
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: PUSH
93098: LD_INT 5
93100: NEG
93101: PUSH
93102: LD_INT 1
93104: NEG
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 5
93112: NEG
93113: PUSH
93114: LD_INT 1
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: PUSH
93121: LD_INT 6
93123: NEG
93124: PUSH
93125: LD_INT 0
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 6
93134: NEG
93135: PUSH
93136: LD_INT 1
93138: NEG
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93158: LD_ADDR_VAR 0 34
93162: PUSH
93163: LD_INT 2
93165: NEG
93166: PUSH
93167: LD_INT 3
93169: NEG
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 3
93177: NEG
93178: PUSH
93179: LD_INT 2
93181: NEG
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 3
93189: NEG
93190: PUSH
93191: LD_INT 3
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 3
93201: NEG
93202: PUSH
93203: LD_INT 4
93205: NEG
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 4
93213: NEG
93214: PUSH
93215: LD_INT 3
93217: NEG
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 4
93225: NEG
93226: PUSH
93227: LD_INT 4
93229: NEG
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PUSH
93235: LD_INT 4
93237: NEG
93238: PUSH
93239: LD_INT 5
93241: NEG
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 5
93249: NEG
93250: PUSH
93251: LD_INT 4
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 5
93261: NEG
93262: PUSH
93263: LD_INT 5
93265: NEG
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 5
93273: NEG
93274: PUSH
93275: LD_INT 6
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 6
93285: NEG
93286: PUSH
93287: LD_INT 5
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 6
93297: NEG
93298: PUSH
93299: LD_INT 6
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93321: LD_ADDR_VAR 0 41
93325: PUSH
93326: LD_INT 0
93328: PUSH
93329: LD_INT 2
93331: NEG
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 1
93339: NEG
93340: PUSH
93341: LD_INT 3
93343: NEG
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 1
93351: PUSH
93352: LD_INT 2
93354: NEG
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93365: LD_ADDR_VAR 0 42
93369: PUSH
93370: LD_INT 2
93372: PUSH
93373: LD_INT 0
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 2
93382: PUSH
93383: LD_INT 1
93385: NEG
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93406: LD_ADDR_VAR 0 43
93410: PUSH
93411: LD_INT 2
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 3
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 2
93433: PUSH
93434: LD_INT 3
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: LIST
93445: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93446: LD_ADDR_VAR 0 44
93450: PUSH
93451: LD_INT 0
93453: PUSH
93454: LD_INT 2
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 1
93463: PUSH
93464: LD_INT 3
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: LD_INT 1
93473: NEG
93474: PUSH
93475: LD_INT 2
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: LIST
93486: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93487: LD_ADDR_VAR 0 45
93491: PUSH
93492: LD_INT 2
93494: NEG
93495: PUSH
93496: LD_INT 0
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 2
93505: NEG
93506: PUSH
93507: LD_INT 1
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 3
93516: NEG
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: LIST
93530: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93531: LD_ADDR_VAR 0 46
93535: PUSH
93536: LD_INT 2
93538: NEG
93539: PUSH
93540: LD_INT 2
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 2
93550: NEG
93551: PUSH
93552: LD_INT 3
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 3
93562: NEG
93563: PUSH
93564: LD_INT 2
93566: NEG
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: LIST
93576: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93577: LD_ADDR_VAR 0 47
93581: PUSH
93582: LD_INT 2
93584: NEG
93585: PUSH
93586: LD_INT 3
93588: NEG
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 1
93596: NEG
93597: PUSH
93598: LD_INT 3
93600: NEG
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93610: LD_ADDR_VAR 0 48
93614: PUSH
93615: LD_INT 1
93617: PUSH
93618: LD_INT 2
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 2
93628: PUSH
93629: LD_INT 1
93631: NEG
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93641: LD_ADDR_VAR 0 49
93645: PUSH
93646: LD_INT 3
93648: PUSH
93649: LD_INT 1
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: PUSH
93656: LD_INT 3
93658: PUSH
93659: LD_INT 2
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93670: LD_ADDR_VAR 0 50
93674: PUSH
93675: LD_INT 2
93677: PUSH
93678: LD_INT 3
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 1
93687: PUSH
93688: LD_INT 3
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93699: LD_ADDR_VAR 0 51
93703: PUSH
93704: LD_INT 1
93706: NEG
93707: PUSH
93708: LD_INT 2
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 2
93717: NEG
93718: PUSH
93719: LD_INT 1
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93730: LD_ADDR_VAR 0 52
93734: PUSH
93735: LD_INT 3
93737: NEG
93738: PUSH
93739: LD_INT 1
93741: NEG
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: NEG
93750: PUSH
93751: LD_INT 2
93753: NEG
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93763: LD_ADDR_VAR 0 53
93767: PUSH
93768: LD_INT 1
93770: NEG
93771: PUSH
93772: LD_INT 3
93774: NEG
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: LD_INT 0
93782: PUSH
93783: LD_INT 3
93785: NEG
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 1
93793: PUSH
93794: LD_INT 2
93796: NEG
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: LIST
93806: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93807: LD_ADDR_VAR 0 54
93811: PUSH
93812: LD_INT 2
93814: PUSH
93815: LD_INT 1
93817: NEG
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 0
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 3
93835: PUSH
93836: LD_INT 1
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: LIST
93847: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93848: LD_ADDR_VAR 0 55
93852: PUSH
93853: LD_INT 3
93855: PUSH
93856: LD_INT 2
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: LD_INT 3
93865: PUSH
93866: LD_INT 3
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 2
93875: PUSH
93876: LD_INT 3
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: LIST
93887: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93888: LD_ADDR_VAR 0 56
93892: PUSH
93893: LD_INT 1
93895: PUSH
93896: LD_INT 3
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 0
93905: PUSH
93906: LD_INT 3
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 1
93915: NEG
93916: PUSH
93917: LD_INT 2
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: LIST
93928: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93929: LD_ADDR_VAR 0 57
93933: PUSH
93934: LD_INT 2
93936: NEG
93937: PUSH
93938: LD_INT 1
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 3
93947: NEG
93948: PUSH
93949: LD_INT 0
93951: PUSH
93952: EMPTY
93953: LIST
93954: LIST
93955: PUSH
93956: LD_INT 3
93958: NEG
93959: PUSH
93960: LD_INT 1
93962: NEG
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: LIST
93972: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93973: LD_ADDR_VAR 0 58
93977: PUSH
93978: LD_INT 2
93980: NEG
93981: PUSH
93982: LD_INT 3
93984: NEG
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 3
93992: NEG
93993: PUSH
93994: LD_INT 2
93996: NEG
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: LD_INT 3
94004: NEG
94005: PUSH
94006: LD_INT 3
94008: NEG
94009: PUSH
94010: EMPTY
94011: LIST
94012: LIST
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: LIST
94018: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94019: LD_ADDR_VAR 0 59
94023: PUSH
94024: LD_INT 1
94026: NEG
94027: PUSH
94028: LD_INT 2
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 0
94038: PUSH
94039: LD_INT 2
94041: NEG
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 1
94049: PUSH
94050: LD_INT 1
94052: NEG
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: LIST
94062: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94063: LD_ADDR_VAR 0 60
94067: PUSH
94068: LD_INT 1
94070: PUSH
94071: LD_INT 1
94073: NEG
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 2
94081: PUSH
94082: LD_INT 0
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 2
94091: PUSH
94092: LD_INT 1
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: LIST
94103: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94104: LD_ADDR_VAR 0 61
94108: PUSH
94109: LD_INT 2
94111: PUSH
94112: LD_INT 1
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 2
94121: PUSH
94122: LD_INT 2
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 1
94131: PUSH
94132: LD_INT 2
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: LIST
94143: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94144: LD_ADDR_VAR 0 62
94148: PUSH
94149: LD_INT 1
94151: PUSH
94152: LD_INT 2
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 0
94161: PUSH
94162: LD_INT 2
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 1
94171: NEG
94172: PUSH
94173: LD_INT 1
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: LIST
94184: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94185: LD_ADDR_VAR 0 63
94189: PUSH
94190: LD_INT 1
94192: NEG
94193: PUSH
94194: LD_INT 1
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 2
94203: NEG
94204: PUSH
94205: LD_INT 0
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 2
94214: NEG
94215: PUSH
94216: LD_INT 1
94218: NEG
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: LIST
94228: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94229: LD_ADDR_VAR 0 64
94233: PUSH
94234: LD_INT 1
94236: NEG
94237: PUSH
94238: LD_INT 2
94240: NEG
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 2
94248: NEG
94249: PUSH
94250: LD_INT 1
94252: NEG
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 2
94260: NEG
94261: PUSH
94262: LD_INT 2
94264: NEG
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: LIST
94274: ST_TO_ADDR
// end ; 2 :
94275: GO 97541
94277: LD_INT 2
94279: DOUBLE
94280: EQUAL
94281: IFTRUE 94285
94283: GO 97540
94285: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94286: LD_ADDR_VAR 0 29
94290: PUSH
94291: LD_INT 4
94293: PUSH
94294: LD_INT 0
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 4
94303: PUSH
94304: LD_INT 1
94306: NEG
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 5
94314: PUSH
94315: LD_INT 0
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 5
94324: PUSH
94325: LD_INT 1
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 4
94334: PUSH
94335: LD_INT 1
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 3
94344: PUSH
94345: LD_INT 0
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: LD_INT 3
94354: PUSH
94355: LD_INT 1
94357: NEG
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 3
94365: PUSH
94366: LD_INT 2
94368: NEG
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 5
94376: PUSH
94377: LD_INT 2
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: LD_INT 3
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: LD_INT 2
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 4
94406: PUSH
94407: LD_INT 3
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 4
94416: PUSH
94417: LD_INT 4
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 3
94426: PUSH
94427: LD_INT 4
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: PUSH
94437: LD_INT 3
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 2
94446: PUSH
94447: LD_INT 2
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 4
94456: PUSH
94457: LD_INT 2
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: LD_INT 2
94466: PUSH
94467: LD_INT 4
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 0
94476: PUSH
94477: LD_INT 4
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 0
94486: PUSH
94487: LD_INT 3
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 1
94496: PUSH
94497: LD_INT 4
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: LD_INT 1
94506: PUSH
94507: LD_INT 5
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 0
94516: PUSH
94517: LD_INT 5
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 1
94526: NEG
94527: PUSH
94528: LD_INT 4
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 1
94537: NEG
94538: PUSH
94539: LD_INT 3
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 2
94548: PUSH
94549: LD_INT 5
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 2
94558: NEG
94559: PUSH
94560: LD_INT 3
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 3
94569: NEG
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 3
94580: NEG
94581: PUSH
94582: LD_INT 1
94584: NEG
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 2
94592: NEG
94593: PUSH
94594: LD_INT 0
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 2
94603: NEG
94604: PUSH
94605: LD_INT 1
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: LD_INT 1
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: LD_INT 0
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 4
94636: NEG
94637: PUSH
94638: LD_INT 1
94640: NEG
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 4
94648: NEG
94649: PUSH
94650: LD_INT 2
94652: NEG
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 2
94660: NEG
94661: PUSH
94662: LD_INT 2
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 4
94671: NEG
94672: PUSH
94673: LD_INT 4
94675: NEG
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: LD_INT 4
94683: NEG
94684: PUSH
94685: LD_INT 5
94687: NEG
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 3
94695: NEG
94696: PUSH
94697: LD_INT 4
94699: NEG
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 3
94707: NEG
94708: PUSH
94709: LD_INT 3
94711: NEG
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: PUSH
94717: LD_INT 4
94719: NEG
94720: PUSH
94721: LD_INT 3
94723: NEG
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: LD_INT 5
94731: NEG
94732: PUSH
94733: LD_INT 4
94735: NEG
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 5
94743: NEG
94744: PUSH
94745: LD_INT 5
94747: NEG
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 3
94755: NEG
94756: PUSH
94757: LD_INT 5
94759: NEG
94760: PUSH
94761: EMPTY
94762: LIST
94763: LIST
94764: PUSH
94765: LD_INT 5
94767: NEG
94768: PUSH
94769: LD_INT 3
94771: NEG
94772: PUSH
94773: EMPTY
94774: LIST
94775: LIST
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94824: LD_ADDR_VAR 0 30
94828: PUSH
94829: LD_INT 4
94831: PUSH
94832: LD_INT 4
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PUSH
94839: LD_INT 4
94841: PUSH
94842: LD_INT 3
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 5
94851: PUSH
94852: LD_INT 4
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 5
94861: PUSH
94862: LD_INT 5
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 4
94871: PUSH
94872: LD_INT 5
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 3
94881: PUSH
94882: LD_INT 4
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 3
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 5
94901: PUSH
94902: LD_INT 3
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 3
94911: PUSH
94912: LD_INT 5
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 0
94921: PUSH
94922: LD_INT 3
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 0
94931: PUSH
94932: LD_INT 2
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: PUSH
94942: LD_INT 3
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 1
94951: PUSH
94952: LD_INT 4
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: PUSH
94959: LD_INT 0
94961: PUSH
94962: LD_INT 4
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 1
94971: NEG
94972: PUSH
94973: LD_INT 3
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 1
94982: NEG
94983: PUSH
94984: LD_INT 2
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: PUSH
94991: LD_INT 2
94993: PUSH
94994: LD_INT 4
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: LD_INT 2
95003: NEG
95004: PUSH
95005: LD_INT 2
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: LD_INT 4
95014: NEG
95015: PUSH
95016: LD_INT 0
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 4
95025: NEG
95026: PUSH
95027: LD_INT 1
95029: NEG
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 3
95037: NEG
95038: PUSH
95039: LD_INT 0
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 3
95048: NEG
95049: PUSH
95050: LD_INT 1
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 4
95059: NEG
95060: PUSH
95061: LD_INT 1
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 5
95070: NEG
95071: PUSH
95072: LD_INT 0
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 5
95081: NEG
95082: PUSH
95083: LD_INT 1
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 5
95093: NEG
95094: PUSH
95095: LD_INT 2
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 3
95105: NEG
95106: PUSH
95107: LD_INT 2
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 3
95116: NEG
95117: PUSH
95118: LD_INT 3
95120: NEG
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: LD_INT 3
95128: NEG
95129: PUSH
95130: LD_INT 4
95132: NEG
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 2
95140: NEG
95141: PUSH
95142: LD_INT 3
95144: NEG
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: LD_INT 2
95152: NEG
95153: PUSH
95154: LD_INT 2
95156: NEG
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 3
95164: NEG
95165: PUSH
95166: LD_INT 2
95168: NEG
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: PUSH
95174: LD_INT 4
95176: NEG
95177: PUSH
95178: LD_INT 3
95180: NEG
95181: PUSH
95182: EMPTY
95183: LIST
95184: LIST
95185: PUSH
95186: LD_INT 4
95188: NEG
95189: PUSH
95190: LD_INT 4
95192: NEG
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: PUSH
95198: LD_INT 2
95200: NEG
95201: PUSH
95202: LD_INT 4
95204: NEG
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: LD_INT 4
95212: NEG
95213: PUSH
95214: LD_INT 2
95216: NEG
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 0
95224: PUSH
95225: LD_INT 4
95227: NEG
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 0
95235: PUSH
95236: LD_INT 5
95238: NEG
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 1
95246: PUSH
95247: LD_INT 4
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 1
95257: PUSH
95258: LD_INT 3
95260: NEG
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: LD_INT 0
95268: PUSH
95269: LD_INT 3
95271: NEG
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PUSH
95277: LD_INT 1
95279: NEG
95280: PUSH
95281: LD_INT 4
95283: NEG
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 1
95291: NEG
95292: PUSH
95293: LD_INT 5
95295: NEG
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 2
95303: PUSH
95304: LD_INT 3
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 2
95314: NEG
95315: PUSH
95316: LD_INT 5
95318: NEG
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95371: LD_ADDR_VAR 0 31
95375: PUSH
95376: LD_INT 0
95378: PUSH
95379: LD_INT 4
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: LD_INT 3
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 1
95398: PUSH
95399: LD_INT 4
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 1
95408: PUSH
95409: LD_INT 5
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: LD_INT 0
95418: PUSH
95419: LD_INT 5
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 1
95428: NEG
95429: PUSH
95430: LD_INT 4
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 1
95439: NEG
95440: PUSH
95441: LD_INT 3
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: LD_INT 2
95450: PUSH
95451: LD_INT 5
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: PUSH
95458: LD_INT 2
95460: NEG
95461: PUSH
95462: LD_INT 3
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 3
95471: NEG
95472: PUSH
95473: LD_INT 0
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 3
95482: NEG
95483: PUSH
95484: LD_INT 1
95486: NEG
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: LD_INT 2
95494: NEG
95495: PUSH
95496: LD_INT 0
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 2
95505: NEG
95506: PUSH
95507: LD_INT 1
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 3
95516: NEG
95517: PUSH
95518: LD_INT 1
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: PUSH
95525: LD_INT 4
95527: NEG
95528: PUSH
95529: LD_INT 0
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: PUSH
95536: LD_INT 4
95538: NEG
95539: PUSH
95540: LD_INT 1
95542: NEG
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 4
95550: NEG
95551: PUSH
95552: LD_INT 2
95554: NEG
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: LD_INT 2
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 4
95573: NEG
95574: PUSH
95575: LD_INT 4
95577: NEG
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 4
95585: NEG
95586: PUSH
95587: LD_INT 5
95589: NEG
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 3
95597: NEG
95598: PUSH
95599: LD_INT 4
95601: NEG
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 3
95609: NEG
95610: PUSH
95611: LD_INT 3
95613: NEG
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 4
95621: NEG
95622: PUSH
95623: LD_INT 3
95625: NEG
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 5
95633: NEG
95634: PUSH
95635: LD_INT 4
95637: NEG
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 5
95645: NEG
95646: PUSH
95647: LD_INT 5
95649: NEG
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 3
95657: NEG
95658: PUSH
95659: LD_INT 5
95661: NEG
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 5
95669: NEG
95670: PUSH
95671: LD_INT 3
95673: NEG
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 0
95681: PUSH
95682: LD_INT 3
95684: NEG
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: LD_INT 0
95692: PUSH
95693: LD_INT 4
95695: NEG
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 1
95703: PUSH
95704: LD_INT 3
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 1
95714: PUSH
95715: LD_INT 2
95717: NEG
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: LD_INT 0
95725: PUSH
95726: LD_INT 2
95728: NEG
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: LD_INT 1
95736: NEG
95737: PUSH
95738: LD_INT 3
95740: NEG
95741: PUSH
95742: EMPTY
95743: LIST
95744: LIST
95745: PUSH
95746: LD_INT 1
95748: NEG
95749: PUSH
95750: LD_INT 4
95752: NEG
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 2
95760: PUSH
95761: LD_INT 2
95763: NEG
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: PUSH
95769: LD_INT 2
95771: NEG
95772: PUSH
95773: LD_INT 4
95775: NEG
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 4
95783: PUSH
95784: LD_INT 0
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 4
95793: PUSH
95794: LD_INT 1
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 5
95804: PUSH
95805: LD_INT 0
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 5
95814: PUSH
95815: LD_INT 1
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 4
95824: PUSH
95825: LD_INT 1
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PUSH
95832: LD_INT 3
95834: PUSH
95835: LD_INT 0
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 3
95844: PUSH
95845: LD_INT 1
95847: NEG
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 3
95855: PUSH
95856: LD_INT 2
95858: NEG
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 5
95866: PUSH
95867: LD_INT 2
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: EMPTY
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95921: LD_ADDR_VAR 0 32
95925: PUSH
95926: LD_INT 4
95928: NEG
95929: PUSH
95930: LD_INT 0
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 4
95939: NEG
95940: PUSH
95941: LD_INT 1
95943: NEG
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 3
95951: NEG
95952: PUSH
95953: LD_INT 0
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 3
95962: NEG
95963: PUSH
95964: LD_INT 1
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 4
95973: NEG
95974: PUSH
95975: LD_INT 1
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PUSH
95982: LD_INT 5
95984: NEG
95985: PUSH
95986: LD_INT 0
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 5
95995: NEG
95996: PUSH
95997: LD_INT 1
95999: NEG
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 5
96007: NEG
96008: PUSH
96009: LD_INT 2
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 3
96019: NEG
96020: PUSH
96021: LD_INT 2
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 3
96030: NEG
96031: PUSH
96032: LD_INT 3
96034: NEG
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 3
96042: NEG
96043: PUSH
96044: LD_INT 4
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 2
96054: NEG
96055: PUSH
96056: LD_INT 3
96058: NEG
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 2
96066: NEG
96067: PUSH
96068: LD_INT 2
96070: NEG
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 3
96078: NEG
96079: PUSH
96080: LD_INT 2
96082: NEG
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 4
96090: NEG
96091: PUSH
96092: LD_INT 3
96094: NEG
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 4
96102: NEG
96103: PUSH
96104: LD_INT 4
96106: NEG
96107: PUSH
96108: EMPTY
96109: LIST
96110: LIST
96111: PUSH
96112: LD_INT 2
96114: NEG
96115: PUSH
96116: LD_INT 4
96118: NEG
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 4
96126: NEG
96127: PUSH
96128: LD_INT 2
96130: NEG
96131: PUSH
96132: EMPTY
96133: LIST
96134: LIST
96135: PUSH
96136: LD_INT 0
96138: PUSH
96139: LD_INT 4
96141: NEG
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PUSH
96147: LD_INT 0
96149: PUSH
96150: LD_INT 5
96152: NEG
96153: PUSH
96154: EMPTY
96155: LIST
96156: LIST
96157: PUSH
96158: LD_INT 1
96160: PUSH
96161: LD_INT 4
96163: NEG
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 1
96171: PUSH
96172: LD_INT 3
96174: NEG
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 0
96182: PUSH
96183: LD_INT 3
96185: NEG
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 1
96193: NEG
96194: PUSH
96195: LD_INT 4
96197: NEG
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 1
96205: NEG
96206: PUSH
96207: LD_INT 5
96209: NEG
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 2
96217: PUSH
96218: LD_INT 3
96220: NEG
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 2
96228: NEG
96229: PUSH
96230: LD_INT 5
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 3
96240: PUSH
96241: LD_INT 0
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 3
96250: PUSH
96251: LD_INT 1
96253: NEG
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 4
96261: PUSH
96262: LD_INT 0
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 4
96271: PUSH
96272: LD_INT 1
96274: PUSH
96275: EMPTY
96276: LIST
96277: LIST
96278: PUSH
96279: LD_INT 3
96281: PUSH
96282: LD_INT 1
96284: PUSH
96285: EMPTY
96286: LIST
96287: LIST
96288: PUSH
96289: LD_INT 2
96291: PUSH
96292: LD_INT 0
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: LD_INT 2
96301: PUSH
96302: LD_INT 1
96304: NEG
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 2
96312: PUSH
96313: LD_INT 2
96315: NEG
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 4
96323: PUSH
96324: LD_INT 2
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 4
96333: PUSH
96334: LD_INT 4
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 4
96343: PUSH
96344: LD_INT 3
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 5
96353: PUSH
96354: LD_INT 4
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 5
96363: PUSH
96364: LD_INT 5
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 4
96373: PUSH
96374: LD_INT 5
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 4
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: LD_INT 3
96393: PUSH
96394: LD_INT 3
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: PUSH
96401: LD_INT 5
96403: PUSH
96404: LD_INT 3
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 3
96413: PUSH
96414: LD_INT 5
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: EMPTY
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96468: LD_ADDR_VAR 0 33
96472: PUSH
96473: LD_INT 4
96475: NEG
96476: PUSH
96477: LD_INT 4
96479: NEG
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PUSH
96485: LD_INT 4
96487: NEG
96488: PUSH
96489: LD_INT 5
96491: NEG
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: PUSH
96497: LD_INT 3
96499: NEG
96500: PUSH
96501: LD_INT 4
96503: NEG
96504: PUSH
96505: EMPTY
96506: LIST
96507: LIST
96508: PUSH
96509: LD_INT 3
96511: NEG
96512: PUSH
96513: LD_INT 3
96515: NEG
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 4
96523: NEG
96524: PUSH
96525: LD_INT 3
96527: NEG
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: LD_INT 5
96535: NEG
96536: PUSH
96537: LD_INT 4
96539: NEG
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: LD_INT 5
96547: NEG
96548: PUSH
96549: LD_INT 5
96551: NEG
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 3
96559: NEG
96560: PUSH
96561: LD_INT 5
96563: NEG
96564: PUSH
96565: EMPTY
96566: LIST
96567: LIST
96568: PUSH
96569: LD_INT 5
96571: NEG
96572: PUSH
96573: LD_INT 3
96575: NEG
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 0
96583: PUSH
96584: LD_INT 3
96586: NEG
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PUSH
96592: LD_INT 0
96594: PUSH
96595: LD_INT 4
96597: NEG
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: LD_INT 1
96605: PUSH
96606: LD_INT 3
96608: NEG
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 1
96616: PUSH
96617: LD_INT 2
96619: NEG
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 0
96627: PUSH
96628: LD_INT 2
96630: NEG
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 1
96638: NEG
96639: PUSH
96640: LD_INT 3
96642: NEG
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 1
96650: NEG
96651: PUSH
96652: LD_INT 4
96654: NEG
96655: PUSH
96656: EMPTY
96657: LIST
96658: LIST
96659: PUSH
96660: LD_INT 2
96662: PUSH
96663: LD_INT 2
96665: NEG
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: LD_INT 2
96673: NEG
96674: PUSH
96675: LD_INT 4
96677: NEG
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: PUSH
96683: LD_INT 4
96685: PUSH
96686: LD_INT 0
96688: PUSH
96689: EMPTY
96690: LIST
96691: LIST
96692: PUSH
96693: LD_INT 4
96695: PUSH
96696: LD_INT 1
96698: NEG
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: PUSH
96704: LD_INT 5
96706: PUSH
96707: LD_INT 0
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 5
96716: PUSH
96717: LD_INT 1
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: PUSH
96724: LD_INT 4
96726: PUSH
96727: LD_INT 1
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: LD_INT 3
96736: PUSH
96737: LD_INT 0
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PUSH
96744: LD_INT 3
96746: PUSH
96747: LD_INT 1
96749: NEG
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 3
96757: PUSH
96758: LD_INT 2
96760: NEG
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 5
96768: PUSH
96769: LD_INT 2
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 3
96778: PUSH
96779: LD_INT 3
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 3
96788: PUSH
96789: LD_INT 2
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 4
96798: PUSH
96799: LD_INT 3
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 4
96808: PUSH
96809: LD_INT 4
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 3
96818: PUSH
96819: LD_INT 4
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 2
96828: PUSH
96829: LD_INT 3
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 2
96838: PUSH
96839: LD_INT 2
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 4
96848: PUSH
96849: LD_INT 2
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 2
96858: PUSH
96859: LD_INT 4
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 0
96868: PUSH
96869: LD_INT 4
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 0
96878: PUSH
96879: LD_INT 3
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 1
96888: PUSH
96889: LD_INT 4
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 1
96898: PUSH
96899: LD_INT 5
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 0
96908: PUSH
96909: LD_INT 5
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 1
96918: NEG
96919: PUSH
96920: LD_INT 4
96922: PUSH
96923: EMPTY
96924: LIST
96925: LIST
96926: PUSH
96927: LD_INT 1
96929: NEG
96930: PUSH
96931: LD_INT 3
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 2
96940: PUSH
96941: LD_INT 5
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 2
96950: NEG
96951: PUSH
96952: LD_INT 3
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: LIST
97002: LIST
97003: LIST
97004: LIST
97005: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97006: LD_ADDR_VAR 0 34
97010: PUSH
97011: LD_INT 0
97013: PUSH
97014: LD_INT 4
97016: NEG
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 0
97024: PUSH
97025: LD_INT 5
97027: NEG
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: PUSH
97033: LD_INT 1
97035: PUSH
97036: LD_INT 4
97038: NEG
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PUSH
97044: LD_INT 1
97046: PUSH
97047: LD_INT 3
97049: NEG
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 0
97057: PUSH
97058: LD_INT 3
97060: NEG
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 1
97068: NEG
97069: PUSH
97070: LD_INT 4
97072: NEG
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 1
97080: NEG
97081: PUSH
97082: LD_INT 5
97084: NEG
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: LD_INT 2
97092: PUSH
97093: LD_INT 3
97095: NEG
97096: PUSH
97097: EMPTY
97098: LIST
97099: LIST
97100: PUSH
97101: LD_INT 2
97103: NEG
97104: PUSH
97105: LD_INT 5
97107: NEG
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_INT 3
97115: PUSH
97116: LD_INT 0
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: PUSH
97123: LD_INT 3
97125: PUSH
97126: LD_INT 1
97128: NEG
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: PUSH
97134: LD_INT 4
97136: PUSH
97137: LD_INT 0
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PUSH
97144: LD_INT 4
97146: PUSH
97147: LD_INT 1
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PUSH
97154: LD_INT 3
97156: PUSH
97157: LD_INT 1
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: PUSH
97164: LD_INT 2
97166: PUSH
97167: LD_INT 0
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: PUSH
97174: LD_INT 2
97176: PUSH
97177: LD_INT 1
97179: NEG
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 2
97187: PUSH
97188: LD_INT 2
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 4
97198: PUSH
97199: LD_INT 2
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 4
97208: PUSH
97209: LD_INT 4
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 4
97218: PUSH
97219: LD_INT 3
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 5
97228: PUSH
97229: LD_INT 4
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 5
97238: PUSH
97239: LD_INT 5
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 4
97248: PUSH
97249: LD_INT 5
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 3
97258: PUSH
97259: LD_INT 4
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 3
97268: PUSH
97269: LD_INT 3
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 5
97278: PUSH
97279: LD_INT 3
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 3
97288: PUSH
97289: LD_INT 5
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 0
97298: PUSH
97299: LD_INT 3
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 0
97308: PUSH
97309: LD_INT 2
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 1
97318: PUSH
97319: LD_INT 3
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 1
97328: PUSH
97329: LD_INT 4
97331: PUSH
97332: EMPTY
97333: LIST
97334: LIST
97335: PUSH
97336: LD_INT 0
97338: PUSH
97339: LD_INT 4
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: LD_INT 1
97348: NEG
97349: PUSH
97350: LD_INT 3
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 1
97359: NEG
97360: PUSH
97361: LD_INT 2
97363: PUSH
97364: EMPTY
97365: LIST
97366: LIST
97367: PUSH
97368: LD_INT 2
97370: PUSH
97371: LD_INT 4
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PUSH
97378: LD_INT 2
97380: NEG
97381: PUSH
97382: LD_INT 2
97384: PUSH
97385: EMPTY
97386: LIST
97387: LIST
97388: PUSH
97389: LD_INT 4
97391: NEG
97392: PUSH
97393: LD_INT 0
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PUSH
97400: LD_INT 4
97402: NEG
97403: PUSH
97404: LD_INT 1
97406: NEG
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_INT 3
97414: NEG
97415: PUSH
97416: LD_INT 0
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PUSH
97423: LD_INT 3
97425: NEG
97426: PUSH
97427: LD_INT 1
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: LD_INT 4
97436: NEG
97437: PUSH
97438: LD_INT 1
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: PUSH
97445: LD_INT 5
97447: NEG
97448: PUSH
97449: LD_INT 0
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: PUSH
97456: LD_INT 5
97458: NEG
97459: PUSH
97460: LD_INT 1
97462: NEG
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: LD_INT 5
97470: NEG
97471: PUSH
97472: LD_INT 2
97474: NEG
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 3
97482: NEG
97483: PUSH
97484: LD_INT 2
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: ST_TO_ADDR
// end ; end ;
97538: GO 97541
97540: POP
// case btype of b_depot , b_warehouse :
97541: LD_VAR 0 1
97545: PUSH
97546: LD_INT 0
97548: DOUBLE
97549: EQUAL
97550: IFTRUE 97560
97552: LD_INT 1
97554: DOUBLE
97555: EQUAL
97556: IFTRUE 97560
97558: GO 97761
97560: POP
// case nation of nation_american :
97561: LD_VAR 0 5
97565: PUSH
97566: LD_INT 1
97568: DOUBLE
97569: EQUAL
97570: IFTRUE 97574
97572: GO 97630
97574: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97575: LD_ADDR_VAR 0 9
97579: PUSH
97580: LD_VAR 0 11
97584: PUSH
97585: LD_VAR 0 12
97589: PUSH
97590: LD_VAR 0 13
97594: PUSH
97595: LD_VAR 0 14
97599: PUSH
97600: LD_VAR 0 15
97604: PUSH
97605: LD_VAR 0 16
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: LIST
97617: PUSH
97618: LD_VAR 0 4
97622: PUSH
97623: LD_INT 1
97625: PLUS
97626: ARRAY
97627: ST_TO_ADDR
97628: GO 97759
97630: LD_INT 2
97632: DOUBLE
97633: EQUAL
97634: IFTRUE 97638
97636: GO 97694
97638: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97639: LD_ADDR_VAR 0 9
97643: PUSH
97644: LD_VAR 0 17
97648: PUSH
97649: LD_VAR 0 18
97653: PUSH
97654: LD_VAR 0 19
97658: PUSH
97659: LD_VAR 0 20
97663: PUSH
97664: LD_VAR 0 21
97668: PUSH
97669: LD_VAR 0 22
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: PUSH
97682: LD_VAR 0 4
97686: PUSH
97687: LD_INT 1
97689: PLUS
97690: ARRAY
97691: ST_TO_ADDR
97692: GO 97759
97694: LD_INT 3
97696: DOUBLE
97697: EQUAL
97698: IFTRUE 97702
97700: GO 97758
97702: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97703: LD_ADDR_VAR 0 9
97707: PUSH
97708: LD_VAR 0 23
97712: PUSH
97713: LD_VAR 0 24
97717: PUSH
97718: LD_VAR 0 25
97722: PUSH
97723: LD_VAR 0 26
97727: PUSH
97728: LD_VAR 0 27
97732: PUSH
97733: LD_VAR 0 28
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: PUSH
97746: LD_VAR 0 4
97750: PUSH
97751: LD_INT 1
97753: PLUS
97754: ARRAY
97755: ST_TO_ADDR
97756: GO 97759
97758: POP
97759: GO 98314
97761: LD_INT 2
97763: DOUBLE
97764: EQUAL
97765: IFTRUE 97775
97767: LD_INT 3
97769: DOUBLE
97770: EQUAL
97771: IFTRUE 97775
97773: GO 97831
97775: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97776: LD_ADDR_VAR 0 9
97780: PUSH
97781: LD_VAR 0 29
97785: PUSH
97786: LD_VAR 0 30
97790: PUSH
97791: LD_VAR 0 31
97795: PUSH
97796: LD_VAR 0 32
97800: PUSH
97801: LD_VAR 0 33
97805: PUSH
97806: LD_VAR 0 34
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: PUSH
97819: LD_VAR 0 4
97823: PUSH
97824: LD_INT 1
97826: PLUS
97827: ARRAY
97828: ST_TO_ADDR
97829: GO 98314
97831: LD_INT 16
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97893
97837: LD_INT 17
97839: DOUBLE
97840: EQUAL
97841: IFTRUE 97893
97843: LD_INT 18
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97893
97849: LD_INT 19
97851: DOUBLE
97852: EQUAL
97853: IFTRUE 97893
97855: LD_INT 22
97857: DOUBLE
97858: EQUAL
97859: IFTRUE 97893
97861: LD_INT 20
97863: DOUBLE
97864: EQUAL
97865: IFTRUE 97893
97867: LD_INT 21
97869: DOUBLE
97870: EQUAL
97871: IFTRUE 97893
97873: LD_INT 23
97875: DOUBLE
97876: EQUAL
97877: IFTRUE 97893
97879: LD_INT 24
97881: DOUBLE
97882: EQUAL
97883: IFTRUE 97893
97885: LD_INT 25
97887: DOUBLE
97888: EQUAL
97889: IFTRUE 97893
97891: GO 97949
97893: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97894: LD_ADDR_VAR 0 9
97898: PUSH
97899: LD_VAR 0 35
97903: PUSH
97904: LD_VAR 0 36
97908: PUSH
97909: LD_VAR 0 37
97913: PUSH
97914: LD_VAR 0 38
97918: PUSH
97919: LD_VAR 0 39
97923: PUSH
97924: LD_VAR 0 40
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: PUSH
97937: LD_VAR 0 4
97941: PUSH
97942: LD_INT 1
97944: PLUS
97945: ARRAY
97946: ST_TO_ADDR
97947: GO 98314
97949: LD_INT 6
97951: DOUBLE
97952: EQUAL
97953: IFTRUE 98005
97955: LD_INT 7
97957: DOUBLE
97958: EQUAL
97959: IFTRUE 98005
97961: LD_INT 8
97963: DOUBLE
97964: EQUAL
97965: IFTRUE 98005
97967: LD_INT 13
97969: DOUBLE
97970: EQUAL
97971: IFTRUE 98005
97973: LD_INT 12
97975: DOUBLE
97976: EQUAL
97977: IFTRUE 98005
97979: LD_INT 15
97981: DOUBLE
97982: EQUAL
97983: IFTRUE 98005
97985: LD_INT 11
97987: DOUBLE
97988: EQUAL
97989: IFTRUE 98005
97991: LD_INT 14
97993: DOUBLE
97994: EQUAL
97995: IFTRUE 98005
97997: LD_INT 10
97999: DOUBLE
98000: EQUAL
98001: IFTRUE 98005
98003: GO 98061
98005: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98006: LD_ADDR_VAR 0 9
98010: PUSH
98011: LD_VAR 0 41
98015: PUSH
98016: LD_VAR 0 42
98020: PUSH
98021: LD_VAR 0 43
98025: PUSH
98026: LD_VAR 0 44
98030: PUSH
98031: LD_VAR 0 45
98035: PUSH
98036: LD_VAR 0 46
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: PUSH
98049: LD_VAR 0 4
98053: PUSH
98054: LD_INT 1
98056: PLUS
98057: ARRAY
98058: ST_TO_ADDR
98059: GO 98314
98061: LD_INT 36
98063: DOUBLE
98064: EQUAL
98065: IFTRUE 98069
98067: GO 98125
98069: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98070: LD_ADDR_VAR 0 9
98074: PUSH
98075: LD_VAR 0 47
98079: PUSH
98080: LD_VAR 0 48
98084: PUSH
98085: LD_VAR 0 49
98089: PUSH
98090: LD_VAR 0 50
98094: PUSH
98095: LD_VAR 0 51
98099: PUSH
98100: LD_VAR 0 52
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: PUSH
98113: LD_VAR 0 4
98117: PUSH
98118: LD_INT 1
98120: PLUS
98121: ARRAY
98122: ST_TO_ADDR
98123: GO 98314
98125: LD_INT 4
98127: DOUBLE
98128: EQUAL
98129: IFTRUE 98151
98131: LD_INT 5
98133: DOUBLE
98134: EQUAL
98135: IFTRUE 98151
98137: LD_INT 34
98139: DOUBLE
98140: EQUAL
98141: IFTRUE 98151
98143: LD_INT 37
98145: DOUBLE
98146: EQUAL
98147: IFTRUE 98151
98149: GO 98207
98151: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98152: LD_ADDR_VAR 0 9
98156: PUSH
98157: LD_VAR 0 53
98161: PUSH
98162: LD_VAR 0 54
98166: PUSH
98167: LD_VAR 0 55
98171: PUSH
98172: LD_VAR 0 56
98176: PUSH
98177: LD_VAR 0 57
98181: PUSH
98182: LD_VAR 0 58
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: PUSH
98195: LD_VAR 0 4
98199: PUSH
98200: LD_INT 1
98202: PLUS
98203: ARRAY
98204: ST_TO_ADDR
98205: GO 98314
98207: LD_INT 31
98209: DOUBLE
98210: EQUAL
98211: IFTRUE 98257
98213: LD_INT 32
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98257
98219: LD_INT 33
98221: DOUBLE
98222: EQUAL
98223: IFTRUE 98257
98225: LD_INT 27
98227: DOUBLE
98228: EQUAL
98229: IFTRUE 98257
98231: LD_INT 26
98233: DOUBLE
98234: EQUAL
98235: IFTRUE 98257
98237: LD_INT 28
98239: DOUBLE
98240: EQUAL
98241: IFTRUE 98257
98243: LD_INT 29
98245: DOUBLE
98246: EQUAL
98247: IFTRUE 98257
98249: LD_INT 30
98251: DOUBLE
98252: EQUAL
98253: IFTRUE 98257
98255: GO 98313
98257: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98258: LD_ADDR_VAR 0 9
98262: PUSH
98263: LD_VAR 0 59
98267: PUSH
98268: LD_VAR 0 60
98272: PUSH
98273: LD_VAR 0 61
98277: PUSH
98278: LD_VAR 0 62
98282: PUSH
98283: LD_VAR 0 63
98287: PUSH
98288: LD_VAR 0 64
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: PUSH
98301: LD_VAR 0 4
98305: PUSH
98306: LD_INT 1
98308: PLUS
98309: ARRAY
98310: ST_TO_ADDR
98311: GO 98314
98313: POP
// temp_list2 = [ ] ;
98314: LD_ADDR_VAR 0 10
98318: PUSH
98319: EMPTY
98320: ST_TO_ADDR
// for i in temp_list do
98321: LD_ADDR_VAR 0 8
98325: PUSH
98326: LD_VAR 0 9
98330: PUSH
98331: FOR_IN
98332: IFFALSE 98384
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98334: LD_ADDR_VAR 0 10
98338: PUSH
98339: LD_VAR 0 10
98343: PUSH
98344: LD_VAR 0 8
98348: PUSH
98349: LD_INT 1
98351: ARRAY
98352: PUSH
98353: LD_VAR 0 2
98357: PLUS
98358: PUSH
98359: LD_VAR 0 8
98363: PUSH
98364: LD_INT 2
98366: ARRAY
98367: PUSH
98368: LD_VAR 0 3
98372: PLUS
98373: PUSH
98374: EMPTY
98375: LIST
98376: LIST
98377: PUSH
98378: EMPTY
98379: LIST
98380: ADD
98381: ST_TO_ADDR
98382: GO 98331
98384: POP
98385: POP
// result = temp_list2 ;
98386: LD_ADDR_VAR 0 7
98390: PUSH
98391: LD_VAR 0 10
98395: ST_TO_ADDR
// end ;
98396: LD_VAR 0 7
98400: RET
// export function EnemyInRange ( unit , dist ) ; begin
98401: LD_INT 0
98403: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98404: LD_ADDR_VAR 0 3
98408: PUSH
98409: LD_VAR 0 1
98413: PPUSH
98414: CALL_OW 255
98418: PPUSH
98419: LD_VAR 0 1
98423: PPUSH
98424: CALL_OW 250
98428: PPUSH
98429: LD_VAR 0 1
98433: PPUSH
98434: CALL_OW 251
98438: PPUSH
98439: LD_VAR 0 2
98443: PPUSH
98444: CALL 72505 0 4
98448: PUSH
98449: LD_INT 4
98451: ARRAY
98452: ST_TO_ADDR
// end ;
98453: LD_VAR 0 3
98457: RET
// export function PlayerSeeMe ( unit ) ; begin
98458: LD_INT 0
98460: PPUSH
// result := See ( your_side , unit ) ;
98461: LD_ADDR_VAR 0 2
98465: PUSH
98466: LD_OWVAR 2
98470: PPUSH
98471: LD_VAR 0 1
98475: PPUSH
98476: CALL_OW 292
98480: ST_TO_ADDR
// end ;
98481: LD_VAR 0 2
98485: RET
// export function ReverseDir ( unit ) ; begin
98486: LD_INT 0
98488: PPUSH
// if not unit then
98489: LD_VAR 0 1
98493: NOT
98494: IFFALSE 98498
// exit ;
98496: GO 98544
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98498: LD_ADDR_VAR 0 2
98502: PUSH
98503: LD_INT 3
98505: PUSH
98506: LD_INT 4
98508: PUSH
98509: LD_INT 5
98511: PUSH
98512: LD_INT 0
98514: PUSH
98515: LD_INT 1
98517: PUSH
98518: LD_INT 2
98520: PUSH
98521: EMPTY
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: PUSH
98529: LD_VAR 0 1
98533: PPUSH
98534: CALL_OW 254
98538: PUSH
98539: LD_INT 1
98541: PLUS
98542: ARRAY
98543: ST_TO_ADDR
// end ;
98544: LD_VAR 0 2
98548: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98549: LD_INT 0
98551: PPUSH
98552: PPUSH
98553: PPUSH
98554: PPUSH
98555: PPUSH
// if not hexes then
98556: LD_VAR 0 2
98560: NOT
98561: IFFALSE 98565
// exit ;
98563: GO 98713
// dist := 9999 ;
98565: LD_ADDR_VAR 0 5
98569: PUSH
98570: LD_INT 9999
98572: ST_TO_ADDR
// for i = 1 to hexes do
98573: LD_ADDR_VAR 0 4
98577: PUSH
98578: DOUBLE
98579: LD_INT 1
98581: DEC
98582: ST_TO_ADDR
98583: LD_VAR 0 2
98587: PUSH
98588: FOR_TO
98589: IFFALSE 98701
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98591: LD_VAR 0 1
98595: PPUSH
98596: LD_VAR 0 2
98600: PUSH
98601: LD_VAR 0 4
98605: ARRAY
98606: PUSH
98607: LD_INT 1
98609: ARRAY
98610: PPUSH
98611: LD_VAR 0 2
98615: PUSH
98616: LD_VAR 0 4
98620: ARRAY
98621: PUSH
98622: LD_INT 2
98624: ARRAY
98625: PPUSH
98626: CALL_OW 297
98630: PUSH
98631: LD_VAR 0 5
98635: LESS
98636: IFFALSE 98699
// begin hex := hexes [ i ] ;
98638: LD_ADDR_VAR 0 7
98642: PUSH
98643: LD_VAR 0 2
98647: PUSH
98648: LD_VAR 0 4
98652: ARRAY
98653: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98654: LD_ADDR_VAR 0 5
98658: PUSH
98659: LD_VAR 0 1
98663: PPUSH
98664: LD_VAR 0 2
98668: PUSH
98669: LD_VAR 0 4
98673: ARRAY
98674: PUSH
98675: LD_INT 1
98677: ARRAY
98678: PPUSH
98679: LD_VAR 0 2
98683: PUSH
98684: LD_VAR 0 4
98688: ARRAY
98689: PUSH
98690: LD_INT 2
98692: ARRAY
98693: PPUSH
98694: CALL_OW 297
98698: ST_TO_ADDR
// end ; end ;
98699: GO 98588
98701: POP
98702: POP
// result := hex ;
98703: LD_ADDR_VAR 0 3
98707: PUSH
98708: LD_VAR 0 7
98712: ST_TO_ADDR
// end ;
98713: LD_VAR 0 3
98717: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98718: LD_INT 0
98720: PPUSH
98721: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98722: LD_VAR 0 1
98726: NOT
98727: PUSH
98728: LD_VAR 0 1
98732: PUSH
98733: LD_INT 21
98735: PUSH
98736: LD_INT 2
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: LD_INT 23
98745: PUSH
98746: LD_INT 2
98748: PUSH
98749: EMPTY
98750: LIST
98751: LIST
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PPUSH
98757: CALL_OW 69
98761: IN
98762: NOT
98763: OR
98764: IFFALSE 98768
// exit ;
98766: GO 98815
// for i = 1 to 3 do
98768: LD_ADDR_VAR 0 3
98772: PUSH
98773: DOUBLE
98774: LD_INT 1
98776: DEC
98777: ST_TO_ADDR
98778: LD_INT 3
98780: PUSH
98781: FOR_TO
98782: IFFALSE 98813
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98784: LD_VAR 0 1
98788: PPUSH
98789: CALL_OW 250
98793: PPUSH
98794: LD_VAR 0 1
98798: PPUSH
98799: CALL_OW 251
98803: PPUSH
98804: LD_INT 1
98806: PPUSH
98807: CALL_OW 453
98811: GO 98781
98813: POP
98814: POP
// end ;
98815: LD_VAR 0 2
98819: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98820: LD_INT 0
98822: PPUSH
98823: PPUSH
98824: PPUSH
98825: PPUSH
98826: PPUSH
98827: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98828: LD_VAR 0 1
98832: NOT
98833: PUSH
98834: LD_VAR 0 2
98838: NOT
98839: OR
98840: PUSH
98841: LD_VAR 0 1
98845: PPUSH
98846: CALL_OW 314
98850: OR
98851: IFFALSE 98855
// exit ;
98853: GO 99296
// x := GetX ( enemy_unit ) ;
98855: LD_ADDR_VAR 0 7
98859: PUSH
98860: LD_VAR 0 2
98864: PPUSH
98865: CALL_OW 250
98869: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98870: LD_ADDR_VAR 0 8
98874: PUSH
98875: LD_VAR 0 2
98879: PPUSH
98880: CALL_OW 251
98884: ST_TO_ADDR
// if not x or not y then
98885: LD_VAR 0 7
98889: NOT
98890: PUSH
98891: LD_VAR 0 8
98895: NOT
98896: OR
98897: IFFALSE 98901
// exit ;
98899: GO 99296
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98901: LD_ADDR_VAR 0 6
98905: PUSH
98906: LD_VAR 0 7
98910: PPUSH
98911: LD_INT 0
98913: PPUSH
98914: LD_INT 4
98916: PPUSH
98917: CALL_OW 272
98921: PUSH
98922: LD_VAR 0 8
98926: PPUSH
98927: LD_INT 0
98929: PPUSH
98930: LD_INT 4
98932: PPUSH
98933: CALL_OW 273
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: PUSH
98942: LD_VAR 0 7
98946: PPUSH
98947: LD_INT 1
98949: PPUSH
98950: LD_INT 4
98952: PPUSH
98953: CALL_OW 272
98957: PUSH
98958: LD_VAR 0 8
98962: PPUSH
98963: LD_INT 1
98965: PPUSH
98966: LD_INT 4
98968: PPUSH
98969: CALL_OW 273
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: PUSH
98978: LD_VAR 0 7
98982: PPUSH
98983: LD_INT 2
98985: PPUSH
98986: LD_INT 4
98988: PPUSH
98989: CALL_OW 272
98993: PUSH
98994: LD_VAR 0 8
98998: PPUSH
98999: LD_INT 2
99001: PPUSH
99002: LD_INT 4
99004: PPUSH
99005: CALL_OW 273
99009: PUSH
99010: EMPTY
99011: LIST
99012: LIST
99013: PUSH
99014: LD_VAR 0 7
99018: PPUSH
99019: LD_INT 3
99021: PPUSH
99022: LD_INT 4
99024: PPUSH
99025: CALL_OW 272
99029: PUSH
99030: LD_VAR 0 8
99034: PPUSH
99035: LD_INT 3
99037: PPUSH
99038: LD_INT 4
99040: PPUSH
99041: CALL_OW 273
99045: PUSH
99046: EMPTY
99047: LIST
99048: LIST
99049: PUSH
99050: LD_VAR 0 7
99054: PPUSH
99055: LD_INT 4
99057: PPUSH
99058: LD_INT 4
99060: PPUSH
99061: CALL_OW 272
99065: PUSH
99066: LD_VAR 0 8
99070: PPUSH
99071: LD_INT 4
99073: PPUSH
99074: LD_INT 4
99076: PPUSH
99077: CALL_OW 273
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: PUSH
99086: LD_VAR 0 7
99090: PPUSH
99091: LD_INT 5
99093: PPUSH
99094: LD_INT 4
99096: PPUSH
99097: CALL_OW 272
99101: PUSH
99102: LD_VAR 0 8
99106: PPUSH
99107: LD_INT 5
99109: PPUSH
99110: LD_INT 4
99112: PPUSH
99113: CALL_OW 273
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: ST_TO_ADDR
// for i = tmp downto 1 do
99130: LD_ADDR_VAR 0 4
99134: PUSH
99135: DOUBLE
99136: LD_VAR 0 6
99140: INC
99141: ST_TO_ADDR
99142: LD_INT 1
99144: PUSH
99145: FOR_DOWNTO
99146: IFFALSE 99247
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99148: LD_VAR 0 6
99152: PUSH
99153: LD_VAR 0 4
99157: ARRAY
99158: PUSH
99159: LD_INT 1
99161: ARRAY
99162: PPUSH
99163: LD_VAR 0 6
99167: PUSH
99168: LD_VAR 0 4
99172: ARRAY
99173: PUSH
99174: LD_INT 2
99176: ARRAY
99177: PPUSH
99178: CALL_OW 488
99182: NOT
99183: PUSH
99184: LD_VAR 0 6
99188: PUSH
99189: LD_VAR 0 4
99193: ARRAY
99194: PUSH
99195: LD_INT 1
99197: ARRAY
99198: PPUSH
99199: LD_VAR 0 6
99203: PUSH
99204: LD_VAR 0 4
99208: ARRAY
99209: PUSH
99210: LD_INT 2
99212: ARRAY
99213: PPUSH
99214: CALL_OW 428
99218: PUSH
99219: LD_INT 0
99221: NONEQUAL
99222: OR
99223: IFFALSE 99245
// tmp := Delete ( tmp , i ) ;
99225: LD_ADDR_VAR 0 6
99229: PUSH
99230: LD_VAR 0 6
99234: PPUSH
99235: LD_VAR 0 4
99239: PPUSH
99240: CALL_OW 3
99244: ST_TO_ADDR
99245: GO 99145
99247: POP
99248: POP
// j := GetClosestHex ( unit , tmp ) ;
99249: LD_ADDR_VAR 0 5
99253: PUSH
99254: LD_VAR 0 1
99258: PPUSH
99259: LD_VAR 0 6
99263: PPUSH
99264: CALL 98549 0 2
99268: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99269: LD_VAR 0 1
99273: PPUSH
99274: LD_VAR 0 5
99278: PUSH
99279: LD_INT 1
99281: ARRAY
99282: PPUSH
99283: LD_VAR 0 5
99287: PUSH
99288: LD_INT 2
99290: ARRAY
99291: PPUSH
99292: CALL_OW 111
// end ;
99296: LD_VAR 0 3
99300: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99301: LD_INT 0
99303: PPUSH
99304: PPUSH
99305: PPUSH
// uc_side = 0 ;
99306: LD_ADDR_OWVAR 20
99310: PUSH
99311: LD_INT 0
99313: ST_TO_ADDR
// uc_nation = 0 ;
99314: LD_ADDR_OWVAR 21
99318: PUSH
99319: LD_INT 0
99321: ST_TO_ADDR
// InitHc ;
99322: CALL_OW 19
// InitVc ;
99326: CALL_OW 20
// if mastodonts then
99330: LD_VAR 0 6
99334: IFFALSE 99401
// for i = 1 to mastodonts do
99336: LD_ADDR_VAR 0 11
99340: PUSH
99341: DOUBLE
99342: LD_INT 1
99344: DEC
99345: ST_TO_ADDR
99346: LD_VAR 0 6
99350: PUSH
99351: FOR_TO
99352: IFFALSE 99399
// begin vc_chassis := 31 ;
99354: LD_ADDR_OWVAR 37
99358: PUSH
99359: LD_INT 31
99361: ST_TO_ADDR
// vc_control := control_rider ;
99362: LD_ADDR_OWVAR 38
99366: PUSH
99367: LD_INT 4
99369: ST_TO_ADDR
// animal := CreateVehicle ;
99370: LD_ADDR_VAR 0 12
99374: PUSH
99375: CALL_OW 45
99379: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99380: LD_VAR 0 12
99384: PPUSH
99385: LD_VAR 0 8
99389: PPUSH
99390: LD_INT 0
99392: PPUSH
99393: CALL 106146 0 3
// end ;
99397: GO 99351
99399: POP
99400: POP
// if horses then
99401: LD_VAR 0 5
99405: IFFALSE 99472
// for i = 1 to horses do
99407: LD_ADDR_VAR 0 11
99411: PUSH
99412: DOUBLE
99413: LD_INT 1
99415: DEC
99416: ST_TO_ADDR
99417: LD_VAR 0 5
99421: PUSH
99422: FOR_TO
99423: IFFALSE 99470
// begin hc_class := 21 ;
99425: LD_ADDR_OWVAR 28
99429: PUSH
99430: LD_INT 21
99432: ST_TO_ADDR
// hc_gallery :=  ;
99433: LD_ADDR_OWVAR 33
99437: PUSH
99438: LD_STRING 
99440: ST_TO_ADDR
// animal := CreateHuman ;
99441: LD_ADDR_VAR 0 12
99445: PUSH
99446: CALL_OW 44
99450: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99451: LD_VAR 0 12
99455: PPUSH
99456: LD_VAR 0 8
99460: PPUSH
99461: LD_INT 0
99463: PPUSH
99464: CALL 106146 0 3
// end ;
99468: GO 99422
99470: POP
99471: POP
// if birds then
99472: LD_VAR 0 1
99476: IFFALSE 99543
// for i = 1 to birds do
99478: LD_ADDR_VAR 0 11
99482: PUSH
99483: DOUBLE
99484: LD_INT 1
99486: DEC
99487: ST_TO_ADDR
99488: LD_VAR 0 1
99492: PUSH
99493: FOR_TO
99494: IFFALSE 99541
// begin hc_class = 18 ;
99496: LD_ADDR_OWVAR 28
99500: PUSH
99501: LD_INT 18
99503: ST_TO_ADDR
// hc_gallery =  ;
99504: LD_ADDR_OWVAR 33
99508: PUSH
99509: LD_STRING 
99511: ST_TO_ADDR
// animal := CreateHuman ;
99512: LD_ADDR_VAR 0 12
99516: PUSH
99517: CALL_OW 44
99521: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99522: LD_VAR 0 12
99526: PPUSH
99527: LD_VAR 0 8
99531: PPUSH
99532: LD_INT 0
99534: PPUSH
99535: CALL 106146 0 3
// end ;
99539: GO 99493
99541: POP
99542: POP
// if tigers then
99543: LD_VAR 0 2
99547: IFFALSE 99631
// for i = 1 to tigers do
99549: LD_ADDR_VAR 0 11
99553: PUSH
99554: DOUBLE
99555: LD_INT 1
99557: DEC
99558: ST_TO_ADDR
99559: LD_VAR 0 2
99563: PUSH
99564: FOR_TO
99565: IFFALSE 99629
// begin hc_class = class_tiger ;
99567: LD_ADDR_OWVAR 28
99571: PUSH
99572: LD_INT 14
99574: ST_TO_ADDR
// hc_gallery =  ;
99575: LD_ADDR_OWVAR 33
99579: PUSH
99580: LD_STRING 
99582: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99583: LD_ADDR_OWVAR 35
99587: PUSH
99588: LD_INT 7
99590: NEG
99591: PPUSH
99592: LD_INT 7
99594: PPUSH
99595: CALL_OW 12
99599: ST_TO_ADDR
// animal := CreateHuman ;
99600: LD_ADDR_VAR 0 12
99604: PUSH
99605: CALL_OW 44
99609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99610: LD_VAR 0 12
99614: PPUSH
99615: LD_VAR 0 8
99619: PPUSH
99620: LD_INT 0
99622: PPUSH
99623: CALL 106146 0 3
// end ;
99627: GO 99564
99629: POP
99630: POP
// if apemans then
99631: LD_VAR 0 3
99635: IFFALSE 99758
// for i = 1 to apemans do
99637: LD_ADDR_VAR 0 11
99641: PUSH
99642: DOUBLE
99643: LD_INT 1
99645: DEC
99646: ST_TO_ADDR
99647: LD_VAR 0 3
99651: PUSH
99652: FOR_TO
99653: IFFALSE 99756
// begin hc_class = class_apeman ;
99655: LD_ADDR_OWVAR 28
99659: PUSH
99660: LD_INT 12
99662: ST_TO_ADDR
// hc_gallery =  ;
99663: LD_ADDR_OWVAR 33
99667: PUSH
99668: LD_STRING 
99670: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99671: LD_ADDR_OWVAR 35
99675: PUSH
99676: LD_INT 5
99678: NEG
99679: PPUSH
99680: LD_INT 5
99682: PPUSH
99683: CALL_OW 12
99687: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99688: LD_ADDR_OWVAR 31
99692: PUSH
99693: LD_INT 1
99695: PPUSH
99696: LD_INT 3
99698: PPUSH
99699: CALL_OW 12
99703: PUSH
99704: LD_INT 1
99706: PPUSH
99707: LD_INT 3
99709: PPUSH
99710: CALL_OW 12
99714: PUSH
99715: LD_INT 0
99717: PUSH
99718: LD_INT 0
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: ST_TO_ADDR
// animal := CreateHuman ;
99727: LD_ADDR_VAR 0 12
99731: PUSH
99732: CALL_OW 44
99736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99737: LD_VAR 0 12
99741: PPUSH
99742: LD_VAR 0 8
99746: PPUSH
99747: LD_INT 0
99749: PPUSH
99750: CALL 106146 0 3
// end ;
99754: GO 99652
99756: POP
99757: POP
// if enchidnas then
99758: LD_VAR 0 4
99762: IFFALSE 99829
// for i = 1 to enchidnas do
99764: LD_ADDR_VAR 0 11
99768: PUSH
99769: DOUBLE
99770: LD_INT 1
99772: DEC
99773: ST_TO_ADDR
99774: LD_VAR 0 4
99778: PUSH
99779: FOR_TO
99780: IFFALSE 99827
// begin hc_class = 13 ;
99782: LD_ADDR_OWVAR 28
99786: PUSH
99787: LD_INT 13
99789: ST_TO_ADDR
// hc_gallery =  ;
99790: LD_ADDR_OWVAR 33
99794: PUSH
99795: LD_STRING 
99797: ST_TO_ADDR
// animal := CreateHuman ;
99798: LD_ADDR_VAR 0 12
99802: PUSH
99803: CALL_OW 44
99807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99808: LD_VAR 0 12
99812: PPUSH
99813: LD_VAR 0 8
99817: PPUSH
99818: LD_INT 0
99820: PPUSH
99821: CALL 106146 0 3
// end ;
99825: GO 99779
99827: POP
99828: POP
// if fishes then
99829: LD_VAR 0 7
99833: IFFALSE 99900
// for i = 1 to fishes do
99835: LD_ADDR_VAR 0 11
99839: PUSH
99840: DOUBLE
99841: LD_INT 1
99843: DEC
99844: ST_TO_ADDR
99845: LD_VAR 0 7
99849: PUSH
99850: FOR_TO
99851: IFFALSE 99898
// begin hc_class = 20 ;
99853: LD_ADDR_OWVAR 28
99857: PUSH
99858: LD_INT 20
99860: ST_TO_ADDR
// hc_gallery =  ;
99861: LD_ADDR_OWVAR 33
99865: PUSH
99866: LD_STRING 
99868: ST_TO_ADDR
// animal := CreateHuman ;
99869: LD_ADDR_VAR 0 12
99873: PUSH
99874: CALL_OW 44
99878: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99879: LD_VAR 0 12
99883: PPUSH
99884: LD_VAR 0 9
99888: PPUSH
99889: LD_INT 0
99891: PPUSH
99892: CALL 106146 0 3
// end ;
99896: GO 99850
99898: POP
99899: POP
// end ;
99900: LD_VAR 0 10
99904: RET
// export function WantHeal ( sci , unit ) ; begin
99905: LD_INT 0
99907: PPUSH
// if GetTaskList ( sci ) > 0 then
99908: LD_VAR 0 1
99912: PPUSH
99913: CALL_OW 437
99917: PUSH
99918: LD_INT 0
99920: GREATER
99921: IFFALSE 99991
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99923: LD_VAR 0 1
99927: PPUSH
99928: CALL_OW 437
99932: PUSH
99933: LD_INT 1
99935: ARRAY
99936: PUSH
99937: LD_INT 1
99939: ARRAY
99940: PUSH
99941: LD_STRING l
99943: EQUAL
99944: PUSH
99945: LD_VAR 0 1
99949: PPUSH
99950: CALL_OW 437
99954: PUSH
99955: LD_INT 1
99957: ARRAY
99958: PUSH
99959: LD_INT 4
99961: ARRAY
99962: PUSH
99963: LD_VAR 0 2
99967: EQUAL
99968: AND
99969: IFFALSE 99981
// result := true else
99971: LD_ADDR_VAR 0 3
99975: PUSH
99976: LD_INT 1
99978: ST_TO_ADDR
99979: GO 99989
// result := false ;
99981: LD_ADDR_VAR 0 3
99985: PUSH
99986: LD_INT 0
99988: ST_TO_ADDR
// end else
99989: GO 99999
// result := false ;
99991: LD_ADDR_VAR 0 3
99995: PUSH
99996: LD_INT 0
99998: ST_TO_ADDR
// end ;
99999: LD_VAR 0 3
100003: RET
// export function HealTarget ( sci ) ; begin
100004: LD_INT 0
100006: PPUSH
// if not sci then
100007: LD_VAR 0 1
100011: NOT
100012: IFFALSE 100016
// exit ;
100014: GO 100081
// result := 0 ;
100016: LD_ADDR_VAR 0 2
100020: PUSH
100021: LD_INT 0
100023: ST_TO_ADDR
// if GetTaskList ( sci ) then
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 437
100033: IFFALSE 100081
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100035: LD_VAR 0 1
100039: PPUSH
100040: CALL_OW 437
100044: PUSH
100045: LD_INT 1
100047: ARRAY
100048: PUSH
100049: LD_INT 1
100051: ARRAY
100052: PUSH
100053: LD_STRING l
100055: EQUAL
100056: IFFALSE 100081
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100058: LD_ADDR_VAR 0 2
100062: PUSH
100063: LD_VAR 0 1
100067: PPUSH
100068: CALL_OW 437
100072: PUSH
100073: LD_INT 1
100075: ARRAY
100076: PUSH
100077: LD_INT 4
100079: ARRAY
100080: ST_TO_ADDR
// end ;
100081: LD_VAR 0 2
100085: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100086: LD_INT 0
100088: PPUSH
100089: PPUSH
100090: PPUSH
100091: PPUSH
100092: PPUSH
100093: PPUSH
100094: PPUSH
100095: PPUSH
100096: PPUSH
100097: PPUSH
100098: PPUSH
100099: PPUSH
100100: PPUSH
100101: PPUSH
100102: PPUSH
100103: PPUSH
100104: PPUSH
100105: PPUSH
100106: PPUSH
100107: PPUSH
100108: PPUSH
100109: PPUSH
100110: PPUSH
100111: PPUSH
100112: PPUSH
100113: PPUSH
100114: PPUSH
100115: PPUSH
100116: PPUSH
100117: PPUSH
100118: PPUSH
100119: PPUSH
100120: PPUSH
100121: PPUSH
// if not list then
100122: LD_VAR 0 1
100126: NOT
100127: IFFALSE 100131
// exit ;
100129: GO 104757
// base := list [ 1 ] ;
100131: LD_ADDR_VAR 0 3
100135: PUSH
100136: LD_VAR 0 1
100140: PUSH
100141: LD_INT 1
100143: ARRAY
100144: ST_TO_ADDR
// group := list [ 2 ] ;
100145: LD_ADDR_VAR 0 4
100149: PUSH
100150: LD_VAR 0 1
100154: PUSH
100155: LD_INT 2
100157: ARRAY
100158: ST_TO_ADDR
// path := list [ 3 ] ;
100159: LD_ADDR_VAR 0 5
100163: PUSH
100164: LD_VAR 0 1
100168: PUSH
100169: LD_INT 3
100171: ARRAY
100172: ST_TO_ADDR
// flags := list [ 4 ] ;
100173: LD_ADDR_VAR 0 6
100177: PUSH
100178: LD_VAR 0 1
100182: PUSH
100183: LD_INT 4
100185: ARRAY
100186: ST_TO_ADDR
// mined := [ ] ;
100187: LD_ADDR_VAR 0 27
100191: PUSH
100192: EMPTY
100193: ST_TO_ADDR
// bombed := [ ] ;
100194: LD_ADDR_VAR 0 28
100198: PUSH
100199: EMPTY
100200: ST_TO_ADDR
// healers := [ ] ;
100201: LD_ADDR_VAR 0 31
100205: PUSH
100206: EMPTY
100207: ST_TO_ADDR
// to_heal := [ ] ;
100208: LD_ADDR_VAR 0 30
100212: PUSH
100213: EMPTY
100214: ST_TO_ADDR
// repairs := [ ] ;
100215: LD_ADDR_VAR 0 33
100219: PUSH
100220: EMPTY
100221: ST_TO_ADDR
// to_repair := [ ] ;
100222: LD_ADDR_VAR 0 32
100226: PUSH
100227: EMPTY
100228: ST_TO_ADDR
// if not group or not path then
100229: LD_VAR 0 4
100233: NOT
100234: PUSH
100235: LD_VAR 0 5
100239: NOT
100240: OR
100241: IFFALSE 100245
// exit ;
100243: GO 104757
// side := GetSide ( group [ 1 ] ) ;
100245: LD_ADDR_VAR 0 35
100249: PUSH
100250: LD_VAR 0 4
100254: PUSH
100255: LD_INT 1
100257: ARRAY
100258: PPUSH
100259: CALL_OW 255
100263: ST_TO_ADDR
// if flags then
100264: LD_VAR 0 6
100268: IFFALSE 100412
// begin f_ignore_area := flags [ 1 ] ;
100270: LD_ADDR_VAR 0 17
100274: PUSH
100275: LD_VAR 0 6
100279: PUSH
100280: LD_INT 1
100282: ARRAY
100283: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100284: LD_ADDR_VAR 0 18
100288: PUSH
100289: LD_VAR 0 6
100293: PUSH
100294: LD_INT 2
100296: ARRAY
100297: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100298: LD_ADDR_VAR 0 19
100302: PUSH
100303: LD_VAR 0 6
100307: PUSH
100308: LD_INT 3
100310: ARRAY
100311: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100312: LD_ADDR_VAR 0 20
100316: PUSH
100317: LD_VAR 0 6
100321: PUSH
100322: LD_INT 4
100324: ARRAY
100325: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100326: LD_ADDR_VAR 0 21
100330: PUSH
100331: LD_VAR 0 6
100335: PUSH
100336: LD_INT 5
100338: ARRAY
100339: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100340: LD_ADDR_VAR 0 22
100344: PUSH
100345: LD_VAR 0 6
100349: PUSH
100350: LD_INT 6
100352: ARRAY
100353: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100354: LD_ADDR_VAR 0 23
100358: PUSH
100359: LD_VAR 0 6
100363: PUSH
100364: LD_INT 7
100366: ARRAY
100367: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100368: LD_ADDR_VAR 0 24
100372: PUSH
100373: LD_VAR 0 6
100377: PUSH
100378: LD_INT 8
100380: ARRAY
100381: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100382: LD_ADDR_VAR 0 25
100386: PUSH
100387: LD_VAR 0 6
100391: PUSH
100392: LD_INT 9
100394: ARRAY
100395: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100396: LD_ADDR_VAR 0 26
100400: PUSH
100401: LD_VAR 0 6
100405: PUSH
100406: LD_INT 10
100408: ARRAY
100409: ST_TO_ADDR
// end else
100410: GO 100492
// begin f_ignore_area := false ;
100412: LD_ADDR_VAR 0 17
100416: PUSH
100417: LD_INT 0
100419: ST_TO_ADDR
// f_capture := false ;
100420: LD_ADDR_VAR 0 18
100424: PUSH
100425: LD_INT 0
100427: ST_TO_ADDR
// f_ignore_civ := false ;
100428: LD_ADDR_VAR 0 19
100432: PUSH
100433: LD_INT 0
100435: ST_TO_ADDR
// f_murder := false ;
100436: LD_ADDR_VAR 0 20
100440: PUSH
100441: LD_INT 0
100443: ST_TO_ADDR
// f_mines := false ;
100444: LD_ADDR_VAR 0 21
100448: PUSH
100449: LD_INT 0
100451: ST_TO_ADDR
// f_repair := false ;
100452: LD_ADDR_VAR 0 22
100456: PUSH
100457: LD_INT 0
100459: ST_TO_ADDR
// f_heal := false ;
100460: LD_ADDR_VAR 0 23
100464: PUSH
100465: LD_INT 0
100467: ST_TO_ADDR
// f_spacetime := false ;
100468: LD_ADDR_VAR 0 24
100472: PUSH
100473: LD_INT 0
100475: ST_TO_ADDR
// f_attack_depot := false ;
100476: LD_ADDR_VAR 0 25
100480: PUSH
100481: LD_INT 0
100483: ST_TO_ADDR
// f_crawl := false ;
100484: LD_ADDR_VAR 0 26
100488: PUSH
100489: LD_INT 0
100491: ST_TO_ADDR
// end ; if f_heal then
100492: LD_VAR 0 23
100496: IFFALSE 100523
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100498: LD_ADDR_VAR 0 31
100502: PUSH
100503: LD_VAR 0 4
100507: PPUSH
100508: LD_INT 25
100510: PUSH
100511: LD_INT 4
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PPUSH
100518: CALL_OW 72
100522: ST_TO_ADDR
// if f_repair then
100523: LD_VAR 0 22
100527: IFFALSE 100554
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100529: LD_ADDR_VAR 0 33
100533: PUSH
100534: LD_VAR 0 4
100538: PPUSH
100539: LD_INT 25
100541: PUSH
100542: LD_INT 3
100544: PUSH
100545: EMPTY
100546: LIST
100547: LIST
100548: PPUSH
100549: CALL_OW 72
100553: ST_TO_ADDR
// units_path := [ ] ;
100554: LD_ADDR_VAR 0 16
100558: PUSH
100559: EMPTY
100560: ST_TO_ADDR
// for i = 1 to group do
100561: LD_ADDR_VAR 0 7
100565: PUSH
100566: DOUBLE
100567: LD_INT 1
100569: DEC
100570: ST_TO_ADDR
100571: LD_VAR 0 4
100575: PUSH
100576: FOR_TO
100577: IFFALSE 100606
// units_path := Replace ( units_path , i , path ) ;
100579: LD_ADDR_VAR 0 16
100583: PUSH
100584: LD_VAR 0 16
100588: PPUSH
100589: LD_VAR 0 7
100593: PPUSH
100594: LD_VAR 0 5
100598: PPUSH
100599: CALL_OW 1
100603: ST_TO_ADDR
100604: GO 100576
100606: POP
100607: POP
// repeat for i = group downto 1 do
100608: LD_ADDR_VAR 0 7
100612: PUSH
100613: DOUBLE
100614: LD_VAR 0 4
100618: INC
100619: ST_TO_ADDR
100620: LD_INT 1
100622: PUSH
100623: FOR_DOWNTO
100624: IFFALSE 104720
// begin wait ( 5 ) ;
100626: LD_INT 5
100628: PPUSH
100629: CALL_OW 67
// tmp := [ ] ;
100633: LD_ADDR_VAR 0 14
100637: PUSH
100638: EMPTY
100639: ST_TO_ADDR
// attacking := false ;
100640: LD_ADDR_VAR 0 29
100644: PUSH
100645: LD_INT 0
100647: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100648: LD_VAR 0 4
100652: PUSH
100653: LD_VAR 0 7
100657: ARRAY
100658: PPUSH
100659: CALL_OW 301
100663: PUSH
100664: LD_VAR 0 4
100668: PUSH
100669: LD_VAR 0 7
100673: ARRAY
100674: NOT
100675: OR
100676: IFFALSE 100785
// begin if GetType ( group [ i ] ) = unit_human then
100678: LD_VAR 0 4
100682: PUSH
100683: LD_VAR 0 7
100687: ARRAY
100688: PPUSH
100689: CALL_OW 247
100693: PUSH
100694: LD_INT 1
100696: EQUAL
100697: IFFALSE 100743
// begin to_heal := to_heal diff group [ i ] ;
100699: LD_ADDR_VAR 0 30
100703: PUSH
100704: LD_VAR 0 30
100708: PUSH
100709: LD_VAR 0 4
100713: PUSH
100714: LD_VAR 0 7
100718: ARRAY
100719: DIFF
100720: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100721: LD_ADDR_VAR 0 31
100725: PUSH
100726: LD_VAR 0 31
100730: PUSH
100731: LD_VAR 0 4
100735: PUSH
100736: LD_VAR 0 7
100740: ARRAY
100741: DIFF
100742: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100743: LD_ADDR_VAR 0 4
100747: PUSH
100748: LD_VAR 0 4
100752: PPUSH
100753: LD_VAR 0 7
100757: PPUSH
100758: CALL_OW 3
100762: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100763: LD_ADDR_VAR 0 16
100767: PUSH
100768: LD_VAR 0 16
100772: PPUSH
100773: LD_VAR 0 7
100777: PPUSH
100778: CALL_OW 3
100782: ST_TO_ADDR
// continue ;
100783: GO 100623
// end ; if f_repair then
100785: LD_VAR 0 22
100789: IFFALSE 101278
// begin if GetType ( group [ i ] ) = unit_vehicle then
100791: LD_VAR 0 4
100795: PUSH
100796: LD_VAR 0 7
100800: ARRAY
100801: PPUSH
100802: CALL_OW 247
100806: PUSH
100807: LD_INT 2
100809: EQUAL
100810: IFFALSE 101000
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100812: LD_VAR 0 4
100816: PUSH
100817: LD_VAR 0 7
100821: ARRAY
100822: PPUSH
100823: CALL_OW 256
100827: PUSH
100828: LD_INT 700
100830: LESS
100831: PUSH
100832: LD_VAR 0 4
100836: PUSH
100837: LD_VAR 0 7
100841: ARRAY
100842: PUSH
100843: LD_VAR 0 32
100847: IN
100848: NOT
100849: AND
100850: IFFALSE 100874
// to_repair := to_repair union group [ i ] ;
100852: LD_ADDR_VAR 0 32
100856: PUSH
100857: LD_VAR 0 32
100861: PUSH
100862: LD_VAR 0 4
100866: PUSH
100867: LD_VAR 0 7
100871: ARRAY
100872: UNION
100873: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100874: LD_VAR 0 4
100878: PUSH
100879: LD_VAR 0 7
100883: ARRAY
100884: PPUSH
100885: CALL_OW 256
100889: PUSH
100890: LD_INT 1000
100892: EQUAL
100893: PUSH
100894: LD_VAR 0 4
100898: PUSH
100899: LD_VAR 0 7
100903: ARRAY
100904: PUSH
100905: LD_VAR 0 32
100909: IN
100910: AND
100911: IFFALSE 100935
// to_repair := to_repair diff group [ i ] ;
100913: LD_ADDR_VAR 0 32
100917: PUSH
100918: LD_VAR 0 32
100922: PUSH
100923: LD_VAR 0 4
100927: PUSH
100928: LD_VAR 0 7
100932: ARRAY
100933: DIFF
100934: ST_TO_ADDR
// if group [ i ] in to_repair then
100935: LD_VAR 0 4
100939: PUSH
100940: LD_VAR 0 7
100944: ARRAY
100945: PUSH
100946: LD_VAR 0 32
100950: IN
100951: IFFALSE 100998
// begin if not IsInArea ( group [ i ] , f_repair ) then
100953: LD_VAR 0 4
100957: PUSH
100958: LD_VAR 0 7
100962: ARRAY
100963: PPUSH
100964: LD_VAR 0 22
100968: PPUSH
100969: CALL_OW 308
100973: NOT
100974: IFFALSE 100996
// ComMoveToArea ( group [ i ] , f_repair ) ;
100976: LD_VAR 0 4
100980: PUSH
100981: LD_VAR 0 7
100985: ARRAY
100986: PPUSH
100987: LD_VAR 0 22
100991: PPUSH
100992: CALL_OW 113
// continue ;
100996: GO 100623
// end ; end else
100998: GO 101278
// if group [ i ] in repairs then
101000: LD_VAR 0 4
101004: PUSH
101005: LD_VAR 0 7
101009: ARRAY
101010: PUSH
101011: LD_VAR 0 33
101015: IN
101016: IFFALSE 101278
// begin if IsInUnit ( group [ i ] ) then
101018: LD_VAR 0 4
101022: PUSH
101023: LD_VAR 0 7
101027: ARRAY
101028: PPUSH
101029: CALL_OW 310
101033: IFFALSE 101101
// begin z := IsInUnit ( group [ i ] ) ;
101035: LD_ADDR_VAR 0 13
101039: PUSH
101040: LD_VAR 0 4
101044: PUSH
101045: LD_VAR 0 7
101049: ARRAY
101050: PPUSH
101051: CALL_OW 310
101055: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101056: LD_VAR 0 13
101060: PUSH
101061: LD_VAR 0 32
101065: IN
101066: PUSH
101067: LD_VAR 0 13
101071: PPUSH
101072: LD_VAR 0 22
101076: PPUSH
101077: CALL_OW 308
101081: AND
101082: IFFALSE 101099
// ComExitVehicle ( group [ i ] ) ;
101084: LD_VAR 0 4
101088: PUSH
101089: LD_VAR 0 7
101093: ARRAY
101094: PPUSH
101095: CALL_OW 121
// end else
101099: GO 101278
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101101: LD_ADDR_VAR 0 13
101105: PUSH
101106: LD_VAR 0 4
101110: PPUSH
101111: LD_INT 95
101113: PUSH
101114: LD_VAR 0 22
101118: PUSH
101119: EMPTY
101120: LIST
101121: LIST
101122: PUSH
101123: LD_INT 58
101125: PUSH
101126: EMPTY
101127: LIST
101128: PUSH
101129: EMPTY
101130: LIST
101131: LIST
101132: PPUSH
101133: CALL_OW 72
101137: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101138: LD_VAR 0 4
101142: PUSH
101143: LD_VAR 0 7
101147: ARRAY
101148: PPUSH
101149: CALL_OW 314
101153: NOT
101154: IFFALSE 101276
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101156: LD_ADDR_VAR 0 10
101160: PUSH
101161: LD_VAR 0 13
101165: PPUSH
101166: LD_VAR 0 4
101170: PUSH
101171: LD_VAR 0 7
101175: ARRAY
101176: PPUSH
101177: CALL_OW 74
101181: ST_TO_ADDR
// if not x then
101182: LD_VAR 0 10
101186: NOT
101187: IFFALSE 101191
// continue ;
101189: GO 100623
// if GetLives ( x ) < 1000 then
101191: LD_VAR 0 10
101195: PPUSH
101196: CALL_OW 256
101200: PUSH
101201: LD_INT 1000
101203: LESS
101204: IFFALSE 101228
// ComRepairVehicle ( group [ i ] , x ) else
101206: LD_VAR 0 4
101210: PUSH
101211: LD_VAR 0 7
101215: ARRAY
101216: PPUSH
101217: LD_VAR 0 10
101221: PPUSH
101222: CALL_OW 129
101226: GO 101276
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101228: LD_VAR 0 23
101232: PUSH
101233: LD_VAR 0 4
101237: PUSH
101238: LD_VAR 0 7
101242: ARRAY
101243: PPUSH
101244: CALL_OW 256
101248: PUSH
101249: LD_INT 1000
101251: LESS
101252: AND
101253: NOT
101254: IFFALSE 101276
// ComEnterUnit ( group [ i ] , x ) ;
101256: LD_VAR 0 4
101260: PUSH
101261: LD_VAR 0 7
101265: ARRAY
101266: PPUSH
101267: LD_VAR 0 10
101271: PPUSH
101272: CALL_OW 120
// end ; continue ;
101276: GO 100623
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101278: LD_VAR 0 23
101282: PUSH
101283: LD_VAR 0 4
101287: PUSH
101288: LD_VAR 0 7
101292: ARRAY
101293: PPUSH
101294: CALL_OW 247
101298: PUSH
101299: LD_INT 1
101301: EQUAL
101302: AND
101303: IFFALSE 101781
// begin if group [ i ] in healers then
101305: LD_VAR 0 4
101309: PUSH
101310: LD_VAR 0 7
101314: ARRAY
101315: PUSH
101316: LD_VAR 0 31
101320: IN
101321: IFFALSE 101594
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101323: LD_VAR 0 4
101327: PUSH
101328: LD_VAR 0 7
101332: ARRAY
101333: PPUSH
101334: LD_VAR 0 23
101338: PPUSH
101339: CALL_OW 308
101343: NOT
101344: PUSH
101345: LD_VAR 0 4
101349: PUSH
101350: LD_VAR 0 7
101354: ARRAY
101355: PPUSH
101356: CALL_OW 314
101360: NOT
101361: AND
101362: IFFALSE 101386
// ComMoveToArea ( group [ i ] , f_heal ) else
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 7
101373: ARRAY
101374: PPUSH
101375: LD_VAR 0 23
101379: PPUSH
101380: CALL_OW 113
101384: GO 101592
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101386: LD_VAR 0 4
101390: PUSH
101391: LD_VAR 0 7
101395: ARRAY
101396: PPUSH
101397: CALL 100004 0 1
101401: PPUSH
101402: CALL_OW 256
101406: PUSH
101407: LD_INT 1000
101409: EQUAL
101410: IFFALSE 101429
// ComStop ( group [ i ] ) else
101412: LD_VAR 0 4
101416: PUSH
101417: LD_VAR 0 7
101421: ARRAY
101422: PPUSH
101423: CALL_OW 141
101427: GO 101592
// if not HasTask ( group [ i ] ) and to_heal then
101429: LD_VAR 0 4
101433: PUSH
101434: LD_VAR 0 7
101438: ARRAY
101439: PPUSH
101440: CALL_OW 314
101444: NOT
101445: PUSH
101446: LD_VAR 0 30
101450: AND
101451: IFFALSE 101592
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101453: LD_ADDR_VAR 0 13
101457: PUSH
101458: LD_VAR 0 30
101462: PPUSH
101463: LD_INT 3
101465: PUSH
101466: LD_INT 54
101468: PUSH
101469: EMPTY
101470: LIST
101471: PUSH
101472: EMPTY
101473: LIST
101474: LIST
101475: PPUSH
101476: CALL_OW 72
101480: PPUSH
101481: LD_VAR 0 4
101485: PUSH
101486: LD_VAR 0 7
101490: ARRAY
101491: PPUSH
101492: CALL_OW 74
101496: ST_TO_ADDR
// if z then
101497: LD_VAR 0 13
101501: IFFALSE 101592
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101503: LD_INT 91
101505: PUSH
101506: LD_VAR 0 13
101510: PUSH
101511: LD_INT 10
101513: PUSH
101514: EMPTY
101515: LIST
101516: LIST
101517: LIST
101518: PUSH
101519: LD_INT 81
101521: PUSH
101522: LD_VAR 0 13
101526: PPUSH
101527: CALL_OW 255
101531: PUSH
101532: EMPTY
101533: LIST
101534: LIST
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: PPUSH
101540: CALL_OW 69
101544: PUSH
101545: LD_INT 0
101547: EQUAL
101548: IFFALSE 101572
// ComHeal ( group [ i ] , z ) else
101550: LD_VAR 0 4
101554: PUSH
101555: LD_VAR 0 7
101559: ARRAY
101560: PPUSH
101561: LD_VAR 0 13
101565: PPUSH
101566: CALL_OW 128
101570: GO 101592
// ComMoveToArea ( group [ i ] , f_heal ) ;
101572: LD_VAR 0 4
101576: PUSH
101577: LD_VAR 0 7
101581: ARRAY
101582: PPUSH
101583: LD_VAR 0 23
101587: PPUSH
101588: CALL_OW 113
// end ; continue ;
101592: GO 100623
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101594: LD_VAR 0 4
101598: PUSH
101599: LD_VAR 0 7
101603: ARRAY
101604: PPUSH
101605: CALL_OW 256
101609: PUSH
101610: LD_INT 700
101612: LESS
101613: PUSH
101614: LD_VAR 0 4
101618: PUSH
101619: LD_VAR 0 7
101623: ARRAY
101624: PUSH
101625: LD_VAR 0 30
101629: IN
101630: NOT
101631: AND
101632: IFFALSE 101656
// to_heal := to_heal union group [ i ] ;
101634: LD_ADDR_VAR 0 30
101638: PUSH
101639: LD_VAR 0 30
101643: PUSH
101644: LD_VAR 0 4
101648: PUSH
101649: LD_VAR 0 7
101653: ARRAY
101654: UNION
101655: ST_TO_ADDR
// if group [ i ] in to_heal then
101656: LD_VAR 0 4
101660: PUSH
101661: LD_VAR 0 7
101665: ARRAY
101666: PUSH
101667: LD_VAR 0 30
101671: IN
101672: IFFALSE 101781
// begin if GetLives ( group [ i ] ) = 1000 then
101674: LD_VAR 0 4
101678: PUSH
101679: LD_VAR 0 7
101683: ARRAY
101684: PPUSH
101685: CALL_OW 256
101689: PUSH
101690: LD_INT 1000
101692: EQUAL
101693: IFFALSE 101719
// to_heal := to_heal diff group [ i ] else
101695: LD_ADDR_VAR 0 30
101699: PUSH
101700: LD_VAR 0 30
101704: PUSH
101705: LD_VAR 0 4
101709: PUSH
101710: LD_VAR 0 7
101714: ARRAY
101715: DIFF
101716: ST_TO_ADDR
101717: GO 101781
// begin if not IsInArea ( group [ i ] , to_heal ) then
101719: LD_VAR 0 4
101723: PUSH
101724: LD_VAR 0 7
101728: ARRAY
101729: PPUSH
101730: LD_VAR 0 30
101734: PPUSH
101735: CALL_OW 308
101739: NOT
101740: IFFALSE 101764
// ComMoveToArea ( group [ i ] , f_heal ) else
101742: LD_VAR 0 4
101746: PUSH
101747: LD_VAR 0 7
101751: ARRAY
101752: PPUSH
101753: LD_VAR 0 23
101757: PPUSH
101758: CALL_OW 113
101762: GO 101779
// ComHold ( group [ i ] ) ;
101764: LD_VAR 0 4
101768: PUSH
101769: LD_VAR 0 7
101773: ARRAY
101774: PPUSH
101775: CALL_OW 140
// continue ;
101779: GO 100623
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101781: LD_VAR 0 4
101785: PUSH
101786: LD_VAR 0 7
101790: ARRAY
101791: PPUSH
101792: LD_INT 10
101794: PPUSH
101795: CALL 98401 0 2
101799: NOT
101800: PUSH
101801: LD_VAR 0 16
101805: PUSH
101806: LD_VAR 0 7
101810: ARRAY
101811: PUSH
101812: EMPTY
101813: EQUAL
101814: NOT
101815: AND
101816: IFFALSE 102082
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101818: LD_VAR 0 4
101822: PUSH
101823: LD_VAR 0 7
101827: ARRAY
101828: PPUSH
101829: CALL_OW 262
101833: PUSH
101834: LD_INT 1
101836: PUSH
101837: LD_INT 2
101839: PUSH
101840: EMPTY
101841: LIST
101842: LIST
101843: IN
101844: IFFALSE 101885
// if GetFuel ( group [ i ] ) < 10 then
101846: LD_VAR 0 4
101850: PUSH
101851: LD_VAR 0 7
101855: ARRAY
101856: PPUSH
101857: CALL_OW 261
101861: PUSH
101862: LD_INT 10
101864: LESS
101865: IFFALSE 101885
// SetFuel ( group [ i ] , 12 ) ;
101867: LD_VAR 0 4
101871: PUSH
101872: LD_VAR 0 7
101876: ARRAY
101877: PPUSH
101878: LD_INT 12
101880: PPUSH
101881: CALL_OW 240
// if units_path [ i ] then
101885: LD_VAR 0 16
101889: PUSH
101890: LD_VAR 0 7
101894: ARRAY
101895: IFFALSE 102080
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101897: LD_VAR 0 4
101901: PUSH
101902: LD_VAR 0 7
101906: ARRAY
101907: PPUSH
101908: LD_VAR 0 16
101912: PUSH
101913: LD_VAR 0 7
101917: ARRAY
101918: PUSH
101919: LD_INT 1
101921: ARRAY
101922: PUSH
101923: LD_INT 1
101925: ARRAY
101926: PPUSH
101927: LD_VAR 0 16
101931: PUSH
101932: LD_VAR 0 7
101936: ARRAY
101937: PUSH
101938: LD_INT 1
101940: ARRAY
101941: PUSH
101942: LD_INT 2
101944: ARRAY
101945: PPUSH
101946: CALL_OW 297
101950: PUSH
101951: LD_INT 6
101953: GREATER
101954: IFFALSE 102029
// begin if not HasTask ( group [ i ] ) then
101956: LD_VAR 0 4
101960: PUSH
101961: LD_VAR 0 7
101965: ARRAY
101966: PPUSH
101967: CALL_OW 314
101971: NOT
101972: IFFALSE 102027
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101974: LD_VAR 0 4
101978: PUSH
101979: LD_VAR 0 7
101983: ARRAY
101984: PPUSH
101985: LD_VAR 0 16
101989: PUSH
101990: LD_VAR 0 7
101994: ARRAY
101995: PUSH
101996: LD_INT 1
101998: ARRAY
101999: PUSH
102000: LD_INT 1
102002: ARRAY
102003: PPUSH
102004: LD_VAR 0 16
102008: PUSH
102009: LD_VAR 0 7
102013: ARRAY
102014: PUSH
102015: LD_INT 1
102017: ARRAY
102018: PUSH
102019: LD_INT 2
102021: ARRAY
102022: PPUSH
102023: CALL_OW 114
// end else
102027: GO 102080
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102029: LD_ADDR_VAR 0 15
102033: PUSH
102034: LD_VAR 0 16
102038: PUSH
102039: LD_VAR 0 7
102043: ARRAY
102044: PPUSH
102045: LD_INT 1
102047: PPUSH
102048: CALL_OW 3
102052: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102053: LD_ADDR_VAR 0 16
102057: PUSH
102058: LD_VAR 0 16
102062: PPUSH
102063: LD_VAR 0 7
102067: PPUSH
102068: LD_VAR 0 15
102072: PPUSH
102073: CALL_OW 1
102077: ST_TO_ADDR
// continue ;
102078: GO 100623
// end ; end ; end else
102080: GO 104718
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102082: LD_ADDR_VAR 0 14
102086: PUSH
102087: LD_INT 81
102089: PUSH
102090: LD_VAR 0 4
102094: PUSH
102095: LD_VAR 0 7
102099: ARRAY
102100: PPUSH
102101: CALL_OW 255
102105: PUSH
102106: EMPTY
102107: LIST
102108: LIST
102109: PPUSH
102110: CALL_OW 69
102114: ST_TO_ADDR
// if not tmp then
102115: LD_VAR 0 14
102119: NOT
102120: IFFALSE 102124
// continue ;
102122: GO 100623
// if f_ignore_area then
102124: LD_VAR 0 17
102128: IFFALSE 102216
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102130: LD_ADDR_VAR 0 15
102134: PUSH
102135: LD_VAR 0 14
102139: PPUSH
102140: LD_INT 3
102142: PUSH
102143: LD_INT 92
102145: PUSH
102146: LD_VAR 0 17
102150: PUSH
102151: LD_INT 1
102153: ARRAY
102154: PUSH
102155: LD_VAR 0 17
102159: PUSH
102160: LD_INT 2
102162: ARRAY
102163: PUSH
102164: LD_VAR 0 17
102168: PUSH
102169: LD_INT 3
102171: ARRAY
102172: PUSH
102173: EMPTY
102174: LIST
102175: LIST
102176: LIST
102177: LIST
102178: PUSH
102179: EMPTY
102180: LIST
102181: LIST
102182: PPUSH
102183: CALL_OW 72
102187: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102188: LD_VAR 0 14
102192: PUSH
102193: LD_VAR 0 15
102197: DIFF
102198: IFFALSE 102216
// tmp := tmp diff tmp2 ;
102200: LD_ADDR_VAR 0 14
102204: PUSH
102205: LD_VAR 0 14
102209: PUSH
102210: LD_VAR 0 15
102214: DIFF
102215: ST_TO_ADDR
// end ; if not f_murder then
102216: LD_VAR 0 20
102220: NOT
102221: IFFALSE 102279
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102223: LD_ADDR_VAR 0 15
102227: PUSH
102228: LD_VAR 0 14
102232: PPUSH
102233: LD_INT 3
102235: PUSH
102236: LD_INT 50
102238: PUSH
102239: EMPTY
102240: LIST
102241: PUSH
102242: EMPTY
102243: LIST
102244: LIST
102245: PPUSH
102246: CALL_OW 72
102250: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102251: LD_VAR 0 14
102255: PUSH
102256: LD_VAR 0 15
102260: DIFF
102261: IFFALSE 102279
// tmp := tmp diff tmp2 ;
102263: LD_ADDR_VAR 0 14
102267: PUSH
102268: LD_VAR 0 14
102272: PUSH
102273: LD_VAR 0 15
102277: DIFF
102278: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102279: LD_ADDR_VAR 0 14
102283: PUSH
102284: LD_VAR 0 4
102288: PUSH
102289: LD_VAR 0 7
102293: ARRAY
102294: PPUSH
102295: LD_VAR 0 14
102299: PPUSH
102300: LD_INT 1
102302: PPUSH
102303: LD_INT 1
102305: PPUSH
102306: CALL 72044 0 4
102310: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102311: LD_VAR 0 4
102315: PUSH
102316: LD_VAR 0 7
102320: ARRAY
102321: PPUSH
102322: CALL_OW 257
102326: PUSH
102327: LD_INT 1
102329: EQUAL
102330: IFFALSE 102778
// begin if WantPlant ( group [ i ] ) then
102332: LD_VAR 0 4
102336: PUSH
102337: LD_VAR 0 7
102341: ARRAY
102342: PPUSH
102343: CALL 71545 0 1
102347: IFFALSE 102351
// continue ;
102349: GO 100623
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102351: LD_VAR 0 18
102355: PUSH
102356: LD_VAR 0 4
102360: PUSH
102361: LD_VAR 0 7
102365: ARRAY
102366: PPUSH
102367: CALL_OW 310
102371: NOT
102372: AND
102373: PUSH
102374: LD_VAR 0 14
102378: PUSH
102379: LD_INT 1
102381: ARRAY
102382: PUSH
102383: LD_VAR 0 14
102387: PPUSH
102388: LD_INT 21
102390: PUSH
102391: LD_INT 2
102393: PUSH
102394: EMPTY
102395: LIST
102396: LIST
102397: PUSH
102398: LD_INT 58
102400: PUSH
102401: EMPTY
102402: LIST
102403: PUSH
102404: EMPTY
102405: LIST
102406: LIST
102407: PPUSH
102408: CALL_OW 72
102412: IN
102413: AND
102414: IFFALSE 102450
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102416: LD_VAR 0 4
102420: PUSH
102421: LD_VAR 0 7
102425: ARRAY
102426: PPUSH
102427: LD_VAR 0 14
102431: PUSH
102432: LD_INT 1
102434: ARRAY
102435: PPUSH
102436: CALL_OW 120
// attacking := true ;
102440: LD_ADDR_VAR 0 29
102444: PUSH
102445: LD_INT 1
102447: ST_TO_ADDR
// continue ;
102448: GO 100623
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102450: LD_VAR 0 26
102454: PUSH
102455: LD_VAR 0 4
102459: PUSH
102460: LD_VAR 0 7
102464: ARRAY
102465: PPUSH
102466: CALL_OW 257
102470: PUSH
102471: LD_INT 1
102473: EQUAL
102474: AND
102475: PUSH
102476: LD_VAR 0 4
102480: PUSH
102481: LD_VAR 0 7
102485: ARRAY
102486: PPUSH
102487: CALL_OW 256
102491: PUSH
102492: LD_INT 800
102494: LESS
102495: AND
102496: PUSH
102497: LD_VAR 0 4
102501: PUSH
102502: LD_VAR 0 7
102506: ARRAY
102507: PPUSH
102508: CALL_OW 318
102512: NOT
102513: AND
102514: IFFALSE 102531
// ComCrawl ( group [ i ] ) ;
102516: LD_VAR 0 4
102520: PUSH
102521: LD_VAR 0 7
102525: ARRAY
102526: PPUSH
102527: CALL_OW 137
// if f_mines then
102531: LD_VAR 0 21
102535: IFFALSE 102778
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102537: LD_VAR 0 14
102541: PUSH
102542: LD_INT 1
102544: ARRAY
102545: PPUSH
102546: CALL_OW 247
102550: PUSH
102551: LD_INT 3
102553: EQUAL
102554: PUSH
102555: LD_VAR 0 14
102559: PUSH
102560: LD_INT 1
102562: ARRAY
102563: PUSH
102564: LD_VAR 0 27
102568: IN
102569: NOT
102570: AND
102571: IFFALSE 102778
// begin x := GetX ( tmp [ 1 ] ) ;
102573: LD_ADDR_VAR 0 10
102577: PUSH
102578: LD_VAR 0 14
102582: PUSH
102583: LD_INT 1
102585: ARRAY
102586: PPUSH
102587: CALL_OW 250
102591: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102592: LD_ADDR_VAR 0 11
102596: PUSH
102597: LD_VAR 0 14
102601: PUSH
102602: LD_INT 1
102604: ARRAY
102605: PPUSH
102606: CALL_OW 251
102610: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102611: LD_ADDR_VAR 0 12
102615: PUSH
102616: LD_VAR 0 4
102620: PUSH
102621: LD_VAR 0 7
102625: ARRAY
102626: PPUSH
102627: CALL 98486 0 1
102631: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102632: LD_VAR 0 4
102636: PUSH
102637: LD_VAR 0 7
102641: ARRAY
102642: PPUSH
102643: LD_VAR 0 10
102647: PPUSH
102648: LD_VAR 0 11
102652: PPUSH
102653: LD_VAR 0 14
102657: PUSH
102658: LD_INT 1
102660: ARRAY
102661: PPUSH
102662: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102666: LD_VAR 0 4
102670: PUSH
102671: LD_VAR 0 7
102675: ARRAY
102676: PPUSH
102677: LD_VAR 0 10
102681: PPUSH
102682: LD_VAR 0 12
102686: PPUSH
102687: LD_INT 7
102689: PPUSH
102690: CALL_OW 272
102694: PPUSH
102695: LD_VAR 0 11
102699: PPUSH
102700: LD_VAR 0 12
102704: PPUSH
102705: LD_INT 7
102707: PPUSH
102708: CALL_OW 273
102712: PPUSH
102713: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102717: LD_VAR 0 4
102721: PUSH
102722: LD_VAR 0 7
102726: ARRAY
102727: PPUSH
102728: LD_INT 71
102730: PPUSH
102731: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102735: LD_ADDR_VAR 0 27
102739: PUSH
102740: LD_VAR 0 27
102744: PPUSH
102745: LD_VAR 0 27
102749: PUSH
102750: LD_INT 1
102752: PLUS
102753: PPUSH
102754: LD_VAR 0 14
102758: PUSH
102759: LD_INT 1
102761: ARRAY
102762: PPUSH
102763: CALL_OW 1
102767: ST_TO_ADDR
// attacking := true ;
102768: LD_ADDR_VAR 0 29
102772: PUSH
102773: LD_INT 1
102775: ST_TO_ADDR
// continue ;
102776: GO 100623
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102778: LD_VAR 0 4
102782: PUSH
102783: LD_VAR 0 7
102787: ARRAY
102788: PPUSH
102789: CALL_OW 257
102793: PUSH
102794: LD_INT 17
102796: EQUAL
102797: PUSH
102798: LD_VAR 0 4
102802: PUSH
102803: LD_VAR 0 7
102807: ARRAY
102808: PPUSH
102809: CALL_OW 110
102813: PUSH
102814: LD_INT 71
102816: EQUAL
102817: NOT
102818: AND
102819: IFFALSE 102965
// begin attacking := false ;
102821: LD_ADDR_VAR 0 29
102825: PUSH
102826: LD_INT 0
102828: ST_TO_ADDR
// k := 5 ;
102829: LD_ADDR_VAR 0 9
102833: PUSH
102834: LD_INT 5
102836: ST_TO_ADDR
// if tmp < k then
102837: LD_VAR 0 14
102841: PUSH
102842: LD_VAR 0 9
102846: LESS
102847: IFFALSE 102859
// k := tmp ;
102849: LD_ADDR_VAR 0 9
102853: PUSH
102854: LD_VAR 0 14
102858: ST_TO_ADDR
// for j = 1 to k do
102859: LD_ADDR_VAR 0 8
102863: PUSH
102864: DOUBLE
102865: LD_INT 1
102867: DEC
102868: ST_TO_ADDR
102869: LD_VAR 0 9
102873: PUSH
102874: FOR_TO
102875: IFFALSE 102963
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102877: LD_VAR 0 14
102881: PUSH
102882: LD_VAR 0 8
102886: ARRAY
102887: PUSH
102888: LD_VAR 0 14
102892: PPUSH
102893: LD_INT 58
102895: PUSH
102896: EMPTY
102897: LIST
102898: PPUSH
102899: CALL_OW 72
102903: IN
102904: NOT
102905: IFFALSE 102961
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102907: LD_VAR 0 4
102911: PUSH
102912: LD_VAR 0 7
102916: ARRAY
102917: PPUSH
102918: LD_VAR 0 14
102922: PUSH
102923: LD_VAR 0 8
102927: ARRAY
102928: PPUSH
102929: CALL_OW 115
// attacking := true ;
102933: LD_ADDR_VAR 0 29
102937: PUSH
102938: LD_INT 1
102940: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102941: LD_VAR 0 4
102945: PUSH
102946: LD_VAR 0 7
102950: ARRAY
102951: PPUSH
102952: LD_INT 71
102954: PPUSH
102955: CALL_OW 109
// continue ;
102959: GO 102874
// end ; end ;
102961: GO 102874
102963: POP
102964: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102965: LD_VAR 0 4
102969: PUSH
102970: LD_VAR 0 7
102974: ARRAY
102975: PPUSH
102976: CALL_OW 257
102980: PUSH
102981: LD_INT 8
102983: EQUAL
102984: PUSH
102985: LD_VAR 0 4
102989: PUSH
102990: LD_VAR 0 7
102994: ARRAY
102995: PPUSH
102996: CALL_OW 264
103000: PUSH
103001: LD_INT 28
103003: PUSH
103004: LD_INT 45
103006: PUSH
103007: LD_INT 7
103009: PUSH
103010: LD_INT 47
103012: PUSH
103013: EMPTY
103014: LIST
103015: LIST
103016: LIST
103017: LIST
103018: IN
103019: OR
103020: IFFALSE 103250
// begin attacking := false ;
103022: LD_ADDR_VAR 0 29
103026: PUSH
103027: LD_INT 0
103029: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103030: LD_VAR 0 14
103034: PUSH
103035: LD_INT 1
103037: ARRAY
103038: PPUSH
103039: CALL_OW 266
103043: PUSH
103044: LD_INT 32
103046: PUSH
103047: LD_INT 31
103049: PUSH
103050: LD_INT 33
103052: PUSH
103053: LD_INT 4
103055: PUSH
103056: LD_INT 5
103058: PUSH
103059: EMPTY
103060: LIST
103061: LIST
103062: LIST
103063: LIST
103064: LIST
103065: IN
103066: IFFALSE 103250
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103068: LD_ADDR_VAR 0 9
103072: PUSH
103073: LD_VAR 0 14
103077: PUSH
103078: LD_INT 1
103080: ARRAY
103081: PPUSH
103082: CALL_OW 266
103086: PPUSH
103087: LD_VAR 0 14
103091: PUSH
103092: LD_INT 1
103094: ARRAY
103095: PPUSH
103096: CALL_OW 250
103100: PPUSH
103101: LD_VAR 0 14
103105: PUSH
103106: LD_INT 1
103108: ARRAY
103109: PPUSH
103110: CALL_OW 251
103114: PPUSH
103115: LD_VAR 0 14
103119: PUSH
103120: LD_INT 1
103122: ARRAY
103123: PPUSH
103124: CALL_OW 254
103128: PPUSH
103129: LD_VAR 0 14
103133: PUSH
103134: LD_INT 1
103136: ARRAY
103137: PPUSH
103138: CALL_OW 248
103142: PPUSH
103143: LD_INT 0
103145: PPUSH
103146: CALL 79856 0 6
103150: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103151: LD_ADDR_VAR 0 8
103155: PUSH
103156: LD_VAR 0 4
103160: PUSH
103161: LD_VAR 0 7
103165: ARRAY
103166: PPUSH
103167: LD_VAR 0 9
103171: PPUSH
103172: CALL 98549 0 2
103176: ST_TO_ADDR
// if j then
103177: LD_VAR 0 8
103181: IFFALSE 103250
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103183: LD_VAR 0 8
103187: PUSH
103188: LD_INT 1
103190: ARRAY
103191: PPUSH
103192: LD_VAR 0 8
103196: PUSH
103197: LD_INT 2
103199: ARRAY
103200: PPUSH
103201: CALL_OW 488
103205: IFFALSE 103250
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103207: LD_VAR 0 4
103211: PUSH
103212: LD_VAR 0 7
103216: ARRAY
103217: PPUSH
103218: LD_VAR 0 8
103222: PUSH
103223: LD_INT 1
103225: ARRAY
103226: PPUSH
103227: LD_VAR 0 8
103231: PUSH
103232: LD_INT 2
103234: ARRAY
103235: PPUSH
103236: CALL_OW 116
// attacking := true ;
103240: LD_ADDR_VAR 0 29
103244: PUSH
103245: LD_INT 1
103247: ST_TO_ADDR
// continue ;
103248: GO 100623
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103250: LD_VAR 0 4
103254: PUSH
103255: LD_VAR 0 7
103259: ARRAY
103260: PPUSH
103261: CALL_OW 265
103265: PUSH
103266: LD_INT 11
103268: EQUAL
103269: IFFALSE 103547
// begin k := 10 ;
103271: LD_ADDR_VAR 0 9
103275: PUSH
103276: LD_INT 10
103278: ST_TO_ADDR
// x := 0 ;
103279: LD_ADDR_VAR 0 10
103283: PUSH
103284: LD_INT 0
103286: ST_TO_ADDR
// if tmp < k then
103287: LD_VAR 0 14
103291: PUSH
103292: LD_VAR 0 9
103296: LESS
103297: IFFALSE 103309
// k := tmp ;
103299: LD_ADDR_VAR 0 9
103303: PUSH
103304: LD_VAR 0 14
103308: ST_TO_ADDR
// for j = k downto 1 do
103309: LD_ADDR_VAR 0 8
103313: PUSH
103314: DOUBLE
103315: LD_VAR 0 9
103319: INC
103320: ST_TO_ADDR
103321: LD_INT 1
103323: PUSH
103324: FOR_DOWNTO
103325: IFFALSE 103400
// begin if GetType ( tmp [ j ] ) = unit_human then
103327: LD_VAR 0 14
103331: PUSH
103332: LD_VAR 0 8
103336: ARRAY
103337: PPUSH
103338: CALL_OW 247
103342: PUSH
103343: LD_INT 1
103345: EQUAL
103346: IFFALSE 103398
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103348: LD_VAR 0 4
103352: PUSH
103353: LD_VAR 0 7
103357: ARRAY
103358: PPUSH
103359: LD_VAR 0 14
103363: PUSH
103364: LD_VAR 0 8
103368: ARRAY
103369: PPUSH
103370: CALL 98820 0 2
// x := tmp [ j ] ;
103374: LD_ADDR_VAR 0 10
103378: PUSH
103379: LD_VAR 0 14
103383: PUSH
103384: LD_VAR 0 8
103388: ARRAY
103389: ST_TO_ADDR
// attacking := true ;
103390: LD_ADDR_VAR 0 29
103394: PUSH
103395: LD_INT 1
103397: ST_TO_ADDR
// end ; end ;
103398: GO 103324
103400: POP
103401: POP
// if not x then
103402: LD_VAR 0 10
103406: NOT
103407: IFFALSE 103547
// begin attacking := true ;
103409: LD_ADDR_VAR 0 29
103413: PUSH
103414: LD_INT 1
103416: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103417: LD_VAR 0 4
103421: PUSH
103422: LD_VAR 0 7
103426: ARRAY
103427: PPUSH
103428: CALL_OW 250
103432: PPUSH
103433: LD_VAR 0 4
103437: PUSH
103438: LD_VAR 0 7
103442: ARRAY
103443: PPUSH
103444: CALL_OW 251
103448: PPUSH
103449: CALL_OW 546
103453: PUSH
103454: LD_INT 2
103456: ARRAY
103457: PUSH
103458: LD_VAR 0 14
103462: PUSH
103463: LD_INT 1
103465: ARRAY
103466: PPUSH
103467: CALL_OW 250
103471: PPUSH
103472: LD_VAR 0 14
103476: PUSH
103477: LD_INT 1
103479: ARRAY
103480: PPUSH
103481: CALL_OW 251
103485: PPUSH
103486: CALL_OW 546
103490: PUSH
103491: LD_INT 2
103493: ARRAY
103494: EQUAL
103495: IFFALSE 103523
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103497: LD_VAR 0 4
103501: PUSH
103502: LD_VAR 0 7
103506: ARRAY
103507: PPUSH
103508: LD_VAR 0 14
103512: PUSH
103513: LD_INT 1
103515: ARRAY
103516: PPUSH
103517: CALL 98820 0 2
103521: GO 103547
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103523: LD_VAR 0 4
103527: PUSH
103528: LD_VAR 0 7
103532: ARRAY
103533: PPUSH
103534: LD_VAR 0 14
103538: PUSH
103539: LD_INT 1
103541: ARRAY
103542: PPUSH
103543: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103547: LD_VAR 0 4
103551: PUSH
103552: LD_VAR 0 7
103556: ARRAY
103557: PPUSH
103558: CALL_OW 264
103562: PUSH
103563: LD_INT 29
103565: EQUAL
103566: IFFALSE 103932
// begin if WantsToAttack ( group [ i ] ) in bombed then
103568: LD_VAR 0 4
103572: PUSH
103573: LD_VAR 0 7
103577: ARRAY
103578: PPUSH
103579: CALL_OW 319
103583: PUSH
103584: LD_VAR 0 28
103588: IN
103589: IFFALSE 103593
// continue ;
103591: GO 100623
// k := 8 ;
103593: LD_ADDR_VAR 0 9
103597: PUSH
103598: LD_INT 8
103600: ST_TO_ADDR
// x := 0 ;
103601: LD_ADDR_VAR 0 10
103605: PUSH
103606: LD_INT 0
103608: ST_TO_ADDR
// if tmp < k then
103609: LD_VAR 0 14
103613: PUSH
103614: LD_VAR 0 9
103618: LESS
103619: IFFALSE 103631
// k := tmp ;
103621: LD_ADDR_VAR 0 9
103625: PUSH
103626: LD_VAR 0 14
103630: ST_TO_ADDR
// for j = 1 to k do
103631: LD_ADDR_VAR 0 8
103635: PUSH
103636: DOUBLE
103637: LD_INT 1
103639: DEC
103640: ST_TO_ADDR
103641: LD_VAR 0 9
103645: PUSH
103646: FOR_TO
103647: IFFALSE 103779
// begin if GetType ( tmp [ j ] ) = unit_building then
103649: LD_VAR 0 14
103653: PUSH
103654: LD_VAR 0 8
103658: ARRAY
103659: PPUSH
103660: CALL_OW 247
103664: PUSH
103665: LD_INT 3
103667: EQUAL
103668: IFFALSE 103777
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103670: LD_VAR 0 14
103674: PUSH
103675: LD_VAR 0 8
103679: ARRAY
103680: PUSH
103681: LD_VAR 0 28
103685: IN
103686: NOT
103687: PUSH
103688: LD_VAR 0 14
103692: PUSH
103693: LD_VAR 0 8
103697: ARRAY
103698: PPUSH
103699: CALL_OW 313
103703: AND
103704: IFFALSE 103777
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103706: LD_VAR 0 4
103710: PUSH
103711: LD_VAR 0 7
103715: ARRAY
103716: PPUSH
103717: LD_VAR 0 14
103721: PUSH
103722: LD_VAR 0 8
103726: ARRAY
103727: PPUSH
103728: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103732: LD_ADDR_VAR 0 28
103736: PUSH
103737: LD_VAR 0 28
103741: PPUSH
103742: LD_VAR 0 28
103746: PUSH
103747: LD_INT 1
103749: PLUS
103750: PPUSH
103751: LD_VAR 0 14
103755: PUSH
103756: LD_VAR 0 8
103760: ARRAY
103761: PPUSH
103762: CALL_OW 1
103766: ST_TO_ADDR
// attacking := true ;
103767: LD_ADDR_VAR 0 29
103771: PUSH
103772: LD_INT 1
103774: ST_TO_ADDR
// break ;
103775: GO 103779
// end ; end ;
103777: GO 103646
103779: POP
103780: POP
// if not attacking and f_attack_depot then
103781: LD_VAR 0 29
103785: NOT
103786: PUSH
103787: LD_VAR 0 25
103791: AND
103792: IFFALSE 103887
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103794: LD_ADDR_VAR 0 13
103798: PUSH
103799: LD_VAR 0 14
103803: PPUSH
103804: LD_INT 2
103806: PUSH
103807: LD_INT 30
103809: PUSH
103810: LD_INT 0
103812: PUSH
103813: EMPTY
103814: LIST
103815: LIST
103816: PUSH
103817: LD_INT 30
103819: PUSH
103820: LD_INT 1
103822: PUSH
103823: EMPTY
103824: LIST
103825: LIST
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: LIST
103831: PPUSH
103832: CALL_OW 72
103836: ST_TO_ADDR
// if z then
103837: LD_VAR 0 13
103841: IFFALSE 103887
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103843: LD_VAR 0 4
103847: PUSH
103848: LD_VAR 0 7
103852: ARRAY
103853: PPUSH
103854: LD_VAR 0 13
103858: PPUSH
103859: LD_VAR 0 4
103863: PUSH
103864: LD_VAR 0 7
103868: ARRAY
103869: PPUSH
103870: CALL_OW 74
103874: PPUSH
103875: CALL_OW 115
// attacking := true ;
103879: LD_ADDR_VAR 0 29
103883: PUSH
103884: LD_INT 1
103886: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103887: LD_VAR 0 4
103891: PUSH
103892: LD_VAR 0 7
103896: ARRAY
103897: PPUSH
103898: CALL_OW 256
103902: PUSH
103903: LD_INT 500
103905: LESS
103906: IFFALSE 103932
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: LD_VAR 0 14
103923: PUSH
103924: LD_INT 1
103926: ARRAY
103927: PPUSH
103928: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103932: LD_VAR 0 4
103936: PUSH
103937: LD_VAR 0 7
103941: ARRAY
103942: PPUSH
103943: CALL_OW 264
103947: PUSH
103948: LD_INT 49
103950: EQUAL
103951: IFFALSE 104072
// begin if not HasTask ( group [ i ] ) then
103953: LD_VAR 0 4
103957: PUSH
103958: LD_VAR 0 7
103962: ARRAY
103963: PPUSH
103964: CALL_OW 314
103968: NOT
103969: IFFALSE 104072
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103971: LD_ADDR_VAR 0 9
103975: PUSH
103976: LD_INT 81
103978: PUSH
103979: LD_VAR 0 4
103983: PUSH
103984: LD_VAR 0 7
103988: ARRAY
103989: PPUSH
103990: CALL_OW 255
103994: PUSH
103995: EMPTY
103996: LIST
103997: LIST
103998: PPUSH
103999: CALL_OW 69
104003: PPUSH
104004: LD_VAR 0 4
104008: PUSH
104009: LD_VAR 0 7
104013: ARRAY
104014: PPUSH
104015: CALL_OW 74
104019: ST_TO_ADDR
// if k then
104020: LD_VAR 0 9
104024: IFFALSE 104072
// if GetDistUnits ( group [ i ] , k ) > 10 then
104026: LD_VAR 0 4
104030: PUSH
104031: LD_VAR 0 7
104035: ARRAY
104036: PPUSH
104037: LD_VAR 0 9
104041: PPUSH
104042: CALL_OW 296
104046: PUSH
104047: LD_INT 10
104049: GREATER
104050: IFFALSE 104072
// ComMoveUnit ( group [ i ] , k ) ;
104052: LD_VAR 0 4
104056: PUSH
104057: LD_VAR 0 7
104061: ARRAY
104062: PPUSH
104063: LD_VAR 0 9
104067: PPUSH
104068: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104072: LD_VAR 0 4
104076: PUSH
104077: LD_VAR 0 7
104081: ARRAY
104082: PPUSH
104083: CALL_OW 256
104087: PUSH
104088: LD_INT 250
104090: LESS
104091: PUSH
104092: LD_VAR 0 4
104096: PUSH
104097: LD_VAR 0 7
104101: ARRAY
104102: PUSH
104103: LD_INT 21
104105: PUSH
104106: LD_INT 2
104108: PUSH
104109: EMPTY
104110: LIST
104111: LIST
104112: PUSH
104113: LD_INT 23
104115: PUSH
104116: LD_INT 2
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: PUSH
104123: EMPTY
104124: LIST
104125: LIST
104126: PPUSH
104127: CALL_OW 69
104131: IN
104132: AND
104133: IFFALSE 104258
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104135: LD_ADDR_VAR 0 9
104139: PUSH
104140: LD_OWVAR 3
104144: PUSH
104145: LD_VAR 0 4
104149: PUSH
104150: LD_VAR 0 7
104154: ARRAY
104155: DIFF
104156: PPUSH
104157: LD_VAR 0 4
104161: PUSH
104162: LD_VAR 0 7
104166: ARRAY
104167: PPUSH
104168: CALL_OW 74
104172: ST_TO_ADDR
// if not k then
104173: LD_VAR 0 9
104177: NOT
104178: IFFALSE 104182
// continue ;
104180: GO 100623
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104182: LD_VAR 0 9
104186: PUSH
104187: LD_INT 81
104189: PUSH
104190: LD_VAR 0 4
104194: PUSH
104195: LD_VAR 0 7
104199: ARRAY
104200: PPUSH
104201: CALL_OW 255
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: PPUSH
104210: CALL_OW 69
104214: IN
104215: PUSH
104216: LD_VAR 0 9
104220: PPUSH
104221: LD_VAR 0 4
104225: PUSH
104226: LD_VAR 0 7
104230: ARRAY
104231: PPUSH
104232: CALL_OW 296
104236: PUSH
104237: LD_INT 5
104239: LESS
104240: AND
104241: IFFALSE 104258
// ComAutodestruct ( group [ i ] ) ;
104243: LD_VAR 0 4
104247: PUSH
104248: LD_VAR 0 7
104252: ARRAY
104253: PPUSH
104254: CALL 98718 0 1
// end ; if f_attack_depot then
104258: LD_VAR 0 25
104262: IFFALSE 104374
// begin k := 6 ;
104264: LD_ADDR_VAR 0 9
104268: PUSH
104269: LD_INT 6
104271: ST_TO_ADDR
// if tmp < k then
104272: LD_VAR 0 14
104276: PUSH
104277: LD_VAR 0 9
104281: LESS
104282: IFFALSE 104294
// k := tmp ;
104284: LD_ADDR_VAR 0 9
104288: PUSH
104289: LD_VAR 0 14
104293: ST_TO_ADDR
// for j = 1 to k do
104294: LD_ADDR_VAR 0 8
104298: PUSH
104299: DOUBLE
104300: LD_INT 1
104302: DEC
104303: ST_TO_ADDR
104304: LD_VAR 0 9
104308: PUSH
104309: FOR_TO
104310: IFFALSE 104372
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104312: LD_VAR 0 8
104316: PPUSH
104317: CALL_OW 266
104321: PUSH
104322: LD_INT 0
104324: PUSH
104325: LD_INT 1
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: IN
104332: IFFALSE 104370
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104334: LD_VAR 0 4
104338: PUSH
104339: LD_VAR 0 7
104343: ARRAY
104344: PPUSH
104345: LD_VAR 0 14
104349: PUSH
104350: LD_VAR 0 8
104354: ARRAY
104355: PPUSH
104356: CALL_OW 115
// attacking := true ;
104360: LD_ADDR_VAR 0 29
104364: PUSH
104365: LD_INT 1
104367: ST_TO_ADDR
// break ;
104368: GO 104372
// end ;
104370: GO 104309
104372: POP
104373: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104374: LD_VAR 0 4
104378: PUSH
104379: LD_VAR 0 7
104383: ARRAY
104384: PPUSH
104385: CALL_OW 302
104389: PUSH
104390: LD_VAR 0 29
104394: NOT
104395: AND
104396: IFFALSE 104718
// begin if GetTag ( group [ i ] ) = 71 then
104398: LD_VAR 0 4
104402: PUSH
104403: LD_VAR 0 7
104407: ARRAY
104408: PPUSH
104409: CALL_OW 110
104413: PUSH
104414: LD_INT 71
104416: EQUAL
104417: IFFALSE 104458
// begin if HasTask ( group [ i ] ) then
104419: LD_VAR 0 4
104423: PUSH
104424: LD_VAR 0 7
104428: ARRAY
104429: PPUSH
104430: CALL_OW 314
104434: IFFALSE 104440
// continue else
104436: GO 100623
104438: GO 104458
// SetTag ( group [ i ] , 0 ) ;
104440: LD_VAR 0 4
104444: PUSH
104445: LD_VAR 0 7
104449: ARRAY
104450: PPUSH
104451: LD_INT 0
104453: PPUSH
104454: CALL_OW 109
// end ; k := 8 ;
104458: LD_ADDR_VAR 0 9
104462: PUSH
104463: LD_INT 8
104465: ST_TO_ADDR
// x := 0 ;
104466: LD_ADDR_VAR 0 10
104470: PUSH
104471: LD_INT 0
104473: ST_TO_ADDR
// if tmp < k then
104474: LD_VAR 0 14
104478: PUSH
104479: LD_VAR 0 9
104483: LESS
104484: IFFALSE 104496
// k := tmp ;
104486: LD_ADDR_VAR 0 9
104490: PUSH
104491: LD_VAR 0 14
104495: ST_TO_ADDR
// for j = 1 to k do
104496: LD_ADDR_VAR 0 8
104500: PUSH
104501: DOUBLE
104502: LD_INT 1
104504: DEC
104505: ST_TO_ADDR
104506: LD_VAR 0 9
104510: PUSH
104511: FOR_TO
104512: IFFALSE 104610
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104514: LD_VAR 0 14
104518: PUSH
104519: LD_VAR 0 8
104523: ARRAY
104524: PPUSH
104525: CALL_OW 247
104529: PUSH
104530: LD_INT 1
104532: EQUAL
104533: PUSH
104534: LD_VAR 0 14
104538: PUSH
104539: LD_VAR 0 8
104543: ARRAY
104544: PPUSH
104545: CALL_OW 256
104549: PUSH
104550: LD_INT 250
104552: LESS
104553: PUSH
104554: LD_VAR 0 20
104558: AND
104559: PUSH
104560: LD_VAR 0 20
104564: NOT
104565: PUSH
104566: LD_VAR 0 14
104570: PUSH
104571: LD_VAR 0 8
104575: ARRAY
104576: PPUSH
104577: CALL_OW 256
104581: PUSH
104582: LD_INT 250
104584: GREATEREQUAL
104585: AND
104586: OR
104587: AND
104588: IFFALSE 104608
// begin x := tmp [ j ] ;
104590: LD_ADDR_VAR 0 10
104594: PUSH
104595: LD_VAR 0 14
104599: PUSH
104600: LD_VAR 0 8
104604: ARRAY
104605: ST_TO_ADDR
// break ;
104606: GO 104610
// end ;
104608: GO 104511
104610: POP
104611: POP
// if x then
104612: LD_VAR 0 10
104616: IFFALSE 104640
// ComAttackUnit ( group [ i ] , x ) else
104618: LD_VAR 0 4
104622: PUSH
104623: LD_VAR 0 7
104627: ARRAY
104628: PPUSH
104629: LD_VAR 0 10
104633: PPUSH
104634: CALL_OW 115
104638: GO 104664
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104640: LD_VAR 0 4
104644: PUSH
104645: LD_VAR 0 7
104649: ARRAY
104650: PPUSH
104651: LD_VAR 0 14
104655: PUSH
104656: LD_INT 1
104658: ARRAY
104659: PPUSH
104660: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104664: LD_VAR 0 4
104668: PUSH
104669: LD_VAR 0 7
104673: ARRAY
104674: PPUSH
104675: CALL_OW 314
104679: NOT
104680: IFFALSE 104718
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104682: LD_VAR 0 4
104686: PUSH
104687: LD_VAR 0 7
104691: ARRAY
104692: PPUSH
104693: LD_VAR 0 14
104697: PPUSH
104698: LD_VAR 0 4
104702: PUSH
104703: LD_VAR 0 7
104707: ARRAY
104708: PPUSH
104709: CALL_OW 74
104713: PPUSH
104714: CALL_OW 115
// end ; end ; end ;
104718: GO 100623
104720: POP
104721: POP
// wait ( 0 0$1 ) ;
104722: LD_INT 35
104724: PPUSH
104725: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104729: LD_VAR 0 4
104733: PUSH
104734: EMPTY
104735: EQUAL
104736: PUSH
104737: LD_INT 81
104739: PUSH
104740: LD_VAR 0 35
104744: PUSH
104745: EMPTY
104746: LIST
104747: LIST
104748: PPUSH
104749: CALL_OW 69
104753: NOT
104754: OR
104755: IFFALSE 100608
// end ;
104757: LD_VAR 0 2
104761: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104762: LD_INT 0
104764: PPUSH
104765: PPUSH
104766: PPUSH
104767: PPUSH
// if not base_units then
104768: LD_VAR 0 1
104772: NOT
104773: IFFALSE 104777
// exit ;
104775: GO 104864
// result := false ;
104777: LD_ADDR_VAR 0 2
104781: PUSH
104782: LD_INT 0
104784: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104785: LD_ADDR_VAR 0 5
104789: PUSH
104790: LD_VAR 0 1
104794: PPUSH
104795: LD_INT 21
104797: PUSH
104798: LD_INT 3
104800: PUSH
104801: EMPTY
104802: LIST
104803: LIST
104804: PPUSH
104805: CALL_OW 72
104809: ST_TO_ADDR
// if not tmp then
104810: LD_VAR 0 5
104814: NOT
104815: IFFALSE 104819
// exit ;
104817: GO 104864
// for i in tmp do
104819: LD_ADDR_VAR 0 3
104823: PUSH
104824: LD_VAR 0 5
104828: PUSH
104829: FOR_IN
104830: IFFALSE 104862
// begin result := EnemyInRange ( i , 22 ) ;
104832: LD_ADDR_VAR 0 2
104836: PUSH
104837: LD_VAR 0 3
104841: PPUSH
104842: LD_INT 22
104844: PPUSH
104845: CALL 98401 0 2
104849: ST_TO_ADDR
// if result then
104850: LD_VAR 0 2
104854: IFFALSE 104860
// exit ;
104856: POP
104857: POP
104858: GO 104864
// end ;
104860: GO 104829
104862: POP
104863: POP
// end ;
104864: LD_VAR 0 2
104868: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104869: LD_INT 0
104871: PPUSH
104872: PPUSH
// if not units then
104873: LD_VAR 0 1
104877: NOT
104878: IFFALSE 104882
// exit ;
104880: GO 104952
// result := [ ] ;
104882: LD_ADDR_VAR 0 3
104886: PUSH
104887: EMPTY
104888: ST_TO_ADDR
// for i in units do
104889: LD_ADDR_VAR 0 4
104893: PUSH
104894: LD_VAR 0 1
104898: PUSH
104899: FOR_IN
104900: IFFALSE 104950
// if GetTag ( i ) = tag then
104902: LD_VAR 0 4
104906: PPUSH
104907: CALL_OW 110
104911: PUSH
104912: LD_VAR 0 2
104916: EQUAL
104917: IFFALSE 104948
// result := Insert ( result , result + 1 , i ) ;
104919: LD_ADDR_VAR 0 3
104923: PUSH
104924: LD_VAR 0 3
104928: PPUSH
104929: LD_VAR 0 3
104933: PUSH
104934: LD_INT 1
104936: PLUS
104937: PPUSH
104938: LD_VAR 0 4
104942: PPUSH
104943: CALL_OW 2
104947: ST_TO_ADDR
104948: GO 104899
104950: POP
104951: POP
// end ;
104952: LD_VAR 0 3
104956: RET
// export function IsDriver ( un ) ; begin
104957: LD_INT 0
104959: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104960: LD_ADDR_VAR 0 2
104964: PUSH
104965: LD_VAR 0 1
104969: PUSH
104970: LD_INT 55
104972: PUSH
104973: EMPTY
104974: LIST
104975: PPUSH
104976: CALL_OW 69
104980: IN
104981: ST_TO_ADDR
// end ;
104982: LD_VAR 0 2
104986: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104987: LD_INT 0
104989: PPUSH
104990: PPUSH
// list := [ ] ;
104991: LD_ADDR_VAR 0 5
104995: PUSH
104996: EMPTY
104997: ST_TO_ADDR
// case d of 0 :
104998: LD_VAR 0 3
105002: PUSH
105003: LD_INT 0
105005: DOUBLE
105006: EQUAL
105007: IFTRUE 105011
105009: GO 105144
105011: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105012: LD_ADDR_VAR 0 5
105016: PUSH
105017: LD_VAR 0 1
105021: PUSH
105022: LD_INT 4
105024: MINUS
105025: PUSH
105026: LD_VAR 0 2
105030: PUSH
105031: LD_INT 4
105033: MINUS
105034: PUSH
105035: LD_INT 2
105037: PUSH
105038: EMPTY
105039: LIST
105040: LIST
105041: LIST
105042: PUSH
105043: LD_VAR 0 1
105047: PUSH
105048: LD_INT 3
105050: MINUS
105051: PUSH
105052: LD_VAR 0 2
105056: PUSH
105057: LD_INT 1
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: LIST
105064: PUSH
105065: LD_VAR 0 1
105069: PUSH
105070: LD_INT 4
105072: PLUS
105073: PUSH
105074: LD_VAR 0 2
105078: PUSH
105079: LD_INT 4
105081: PUSH
105082: EMPTY
105083: LIST
105084: LIST
105085: LIST
105086: PUSH
105087: LD_VAR 0 1
105091: PUSH
105092: LD_INT 3
105094: PLUS
105095: PUSH
105096: LD_VAR 0 2
105100: PUSH
105101: LD_INT 3
105103: PLUS
105104: PUSH
105105: LD_INT 5
105107: PUSH
105108: EMPTY
105109: LIST
105110: LIST
105111: LIST
105112: PUSH
105113: LD_VAR 0 1
105117: PUSH
105118: LD_VAR 0 2
105122: PUSH
105123: LD_INT 4
105125: PLUS
105126: PUSH
105127: LD_INT 0
105129: PUSH
105130: EMPTY
105131: LIST
105132: LIST
105133: LIST
105134: PUSH
105135: EMPTY
105136: LIST
105137: LIST
105138: LIST
105139: LIST
105140: LIST
105141: ST_TO_ADDR
// end ; 1 :
105142: GO 105842
105144: LD_INT 1
105146: DOUBLE
105147: EQUAL
105148: IFTRUE 105152
105150: GO 105285
105152: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105153: LD_ADDR_VAR 0 5
105157: PUSH
105158: LD_VAR 0 1
105162: PUSH
105163: LD_VAR 0 2
105167: PUSH
105168: LD_INT 4
105170: MINUS
105171: PUSH
105172: LD_INT 3
105174: PUSH
105175: EMPTY
105176: LIST
105177: LIST
105178: LIST
105179: PUSH
105180: LD_VAR 0 1
105184: PUSH
105185: LD_INT 3
105187: MINUS
105188: PUSH
105189: LD_VAR 0 2
105193: PUSH
105194: LD_INT 3
105196: MINUS
105197: PUSH
105198: LD_INT 2
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: LIST
105205: PUSH
105206: LD_VAR 0 1
105210: PUSH
105211: LD_INT 4
105213: MINUS
105214: PUSH
105215: LD_VAR 0 2
105219: PUSH
105220: LD_INT 1
105222: PUSH
105223: EMPTY
105224: LIST
105225: LIST
105226: LIST
105227: PUSH
105228: LD_VAR 0 1
105232: PUSH
105233: LD_VAR 0 2
105237: PUSH
105238: LD_INT 3
105240: PLUS
105241: PUSH
105242: LD_INT 0
105244: PUSH
105245: EMPTY
105246: LIST
105247: LIST
105248: LIST
105249: PUSH
105250: LD_VAR 0 1
105254: PUSH
105255: LD_INT 4
105257: PLUS
105258: PUSH
105259: LD_VAR 0 2
105263: PUSH
105264: LD_INT 4
105266: PLUS
105267: PUSH
105268: LD_INT 5
105270: PUSH
105271: EMPTY
105272: LIST
105273: LIST
105274: LIST
105275: PUSH
105276: EMPTY
105277: LIST
105278: LIST
105279: LIST
105280: LIST
105281: LIST
105282: ST_TO_ADDR
// end ; 2 :
105283: GO 105842
105285: LD_INT 2
105287: DOUBLE
105288: EQUAL
105289: IFTRUE 105293
105291: GO 105422
105293: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105294: LD_ADDR_VAR 0 5
105298: PUSH
105299: LD_VAR 0 1
105303: PUSH
105304: LD_VAR 0 2
105308: PUSH
105309: LD_INT 3
105311: MINUS
105312: PUSH
105313: LD_INT 3
105315: PUSH
105316: EMPTY
105317: LIST
105318: LIST
105319: LIST
105320: PUSH
105321: LD_VAR 0 1
105325: PUSH
105326: LD_INT 4
105328: PLUS
105329: PUSH
105330: LD_VAR 0 2
105334: PUSH
105335: LD_INT 4
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: LIST
105342: PUSH
105343: LD_VAR 0 1
105347: PUSH
105348: LD_VAR 0 2
105352: PUSH
105353: LD_INT 4
105355: PLUS
105356: PUSH
105357: LD_INT 0
105359: PUSH
105360: EMPTY
105361: LIST
105362: LIST
105363: LIST
105364: PUSH
105365: LD_VAR 0 1
105369: PUSH
105370: LD_INT 3
105372: MINUS
105373: PUSH
105374: LD_VAR 0 2
105378: PUSH
105379: LD_INT 1
105381: PUSH
105382: EMPTY
105383: LIST
105384: LIST
105385: LIST
105386: PUSH
105387: LD_VAR 0 1
105391: PUSH
105392: LD_INT 4
105394: MINUS
105395: PUSH
105396: LD_VAR 0 2
105400: PUSH
105401: LD_INT 4
105403: MINUS
105404: PUSH
105405: LD_INT 2
105407: PUSH
105408: EMPTY
105409: LIST
105410: LIST
105411: LIST
105412: PUSH
105413: EMPTY
105414: LIST
105415: LIST
105416: LIST
105417: LIST
105418: LIST
105419: ST_TO_ADDR
// end ; 3 :
105420: GO 105842
105422: LD_INT 3
105424: DOUBLE
105425: EQUAL
105426: IFTRUE 105430
105428: GO 105563
105430: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105431: LD_ADDR_VAR 0 5
105435: PUSH
105436: LD_VAR 0 1
105440: PUSH
105441: LD_INT 3
105443: PLUS
105444: PUSH
105445: LD_VAR 0 2
105449: PUSH
105450: LD_INT 4
105452: PUSH
105453: EMPTY
105454: LIST
105455: LIST
105456: LIST
105457: PUSH
105458: LD_VAR 0 1
105462: PUSH
105463: LD_INT 4
105465: PLUS
105466: PUSH
105467: LD_VAR 0 2
105471: PUSH
105472: LD_INT 4
105474: PLUS
105475: PUSH
105476: LD_INT 5
105478: PUSH
105479: EMPTY
105480: LIST
105481: LIST
105482: LIST
105483: PUSH
105484: LD_VAR 0 1
105488: PUSH
105489: LD_INT 4
105491: MINUS
105492: PUSH
105493: LD_VAR 0 2
105497: PUSH
105498: LD_INT 1
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: LIST
105505: PUSH
105506: LD_VAR 0 1
105510: PUSH
105511: LD_VAR 0 2
105515: PUSH
105516: LD_INT 4
105518: MINUS
105519: PUSH
105520: LD_INT 3
105522: PUSH
105523: EMPTY
105524: LIST
105525: LIST
105526: LIST
105527: PUSH
105528: LD_VAR 0 1
105532: PUSH
105533: LD_INT 3
105535: MINUS
105536: PUSH
105537: LD_VAR 0 2
105541: PUSH
105542: LD_INT 3
105544: MINUS
105545: PUSH
105546: LD_INT 2
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: LIST
105553: PUSH
105554: EMPTY
105555: LIST
105556: LIST
105557: LIST
105558: LIST
105559: LIST
105560: ST_TO_ADDR
// end ; 4 :
105561: GO 105842
105563: LD_INT 4
105565: DOUBLE
105566: EQUAL
105567: IFTRUE 105571
105569: GO 105704
105571: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105572: LD_ADDR_VAR 0 5
105576: PUSH
105577: LD_VAR 0 1
105581: PUSH
105582: LD_VAR 0 2
105586: PUSH
105587: LD_INT 4
105589: PLUS
105590: PUSH
105591: LD_INT 0
105593: PUSH
105594: EMPTY
105595: LIST
105596: LIST
105597: LIST
105598: PUSH
105599: LD_VAR 0 1
105603: PUSH
105604: LD_INT 3
105606: PLUS
105607: PUSH
105608: LD_VAR 0 2
105612: PUSH
105613: LD_INT 3
105615: PLUS
105616: PUSH
105617: LD_INT 5
105619: PUSH
105620: EMPTY
105621: LIST
105622: LIST
105623: LIST
105624: PUSH
105625: LD_VAR 0 1
105629: PUSH
105630: LD_INT 4
105632: PLUS
105633: PUSH
105634: LD_VAR 0 2
105638: PUSH
105639: LD_INT 4
105641: PUSH
105642: EMPTY
105643: LIST
105644: LIST
105645: LIST
105646: PUSH
105647: LD_VAR 0 1
105651: PUSH
105652: LD_VAR 0 2
105656: PUSH
105657: LD_INT 3
105659: MINUS
105660: PUSH
105661: LD_INT 3
105663: PUSH
105664: EMPTY
105665: LIST
105666: LIST
105667: LIST
105668: PUSH
105669: LD_VAR 0 1
105673: PUSH
105674: LD_INT 4
105676: MINUS
105677: PUSH
105678: LD_VAR 0 2
105682: PUSH
105683: LD_INT 4
105685: MINUS
105686: PUSH
105687: LD_INT 2
105689: PUSH
105690: EMPTY
105691: LIST
105692: LIST
105693: LIST
105694: PUSH
105695: EMPTY
105696: LIST
105697: LIST
105698: LIST
105699: LIST
105700: LIST
105701: ST_TO_ADDR
// end ; 5 :
105702: GO 105842
105704: LD_INT 5
105706: DOUBLE
105707: EQUAL
105708: IFTRUE 105712
105710: GO 105841
105712: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105713: LD_ADDR_VAR 0 5
105717: PUSH
105718: LD_VAR 0 1
105722: PUSH
105723: LD_INT 4
105725: MINUS
105726: PUSH
105727: LD_VAR 0 2
105731: PUSH
105732: LD_INT 1
105734: PUSH
105735: EMPTY
105736: LIST
105737: LIST
105738: LIST
105739: PUSH
105740: LD_VAR 0 1
105744: PUSH
105745: LD_VAR 0 2
105749: PUSH
105750: LD_INT 4
105752: MINUS
105753: PUSH
105754: LD_INT 3
105756: PUSH
105757: EMPTY
105758: LIST
105759: LIST
105760: LIST
105761: PUSH
105762: LD_VAR 0 1
105766: PUSH
105767: LD_INT 4
105769: PLUS
105770: PUSH
105771: LD_VAR 0 2
105775: PUSH
105776: LD_INT 4
105778: PLUS
105779: PUSH
105780: LD_INT 5
105782: PUSH
105783: EMPTY
105784: LIST
105785: LIST
105786: LIST
105787: PUSH
105788: LD_VAR 0 1
105792: PUSH
105793: LD_INT 3
105795: PLUS
105796: PUSH
105797: LD_VAR 0 2
105801: PUSH
105802: LD_INT 4
105804: PUSH
105805: EMPTY
105806: LIST
105807: LIST
105808: LIST
105809: PUSH
105810: LD_VAR 0 1
105814: PUSH
105815: LD_VAR 0 2
105819: PUSH
105820: LD_INT 3
105822: PLUS
105823: PUSH
105824: LD_INT 0
105826: PUSH
105827: EMPTY
105828: LIST
105829: LIST
105830: LIST
105831: PUSH
105832: EMPTY
105833: LIST
105834: LIST
105835: LIST
105836: LIST
105837: LIST
105838: ST_TO_ADDR
// end ; end ;
105839: GO 105842
105841: POP
// result := list ;
105842: LD_ADDR_VAR 0 4
105846: PUSH
105847: LD_VAR 0 5
105851: ST_TO_ADDR
// end ;
105852: LD_VAR 0 4
105856: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105857: LD_INT 0
105859: PPUSH
105860: PPUSH
105861: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105862: LD_VAR 0 1
105866: NOT
105867: PUSH
105868: LD_VAR 0 2
105872: PUSH
105873: LD_INT 1
105875: PUSH
105876: LD_INT 2
105878: PUSH
105879: LD_INT 3
105881: PUSH
105882: LD_INT 4
105884: PUSH
105885: EMPTY
105886: LIST
105887: LIST
105888: LIST
105889: LIST
105890: IN
105891: NOT
105892: OR
105893: IFFALSE 105897
// exit ;
105895: GO 105989
// tmp := [ ] ;
105897: LD_ADDR_VAR 0 5
105901: PUSH
105902: EMPTY
105903: ST_TO_ADDR
// for i in units do
105904: LD_ADDR_VAR 0 4
105908: PUSH
105909: LD_VAR 0 1
105913: PUSH
105914: FOR_IN
105915: IFFALSE 105958
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105917: LD_ADDR_VAR 0 5
105921: PUSH
105922: LD_VAR 0 5
105926: PPUSH
105927: LD_VAR 0 5
105931: PUSH
105932: LD_INT 1
105934: PLUS
105935: PPUSH
105936: LD_VAR 0 4
105940: PPUSH
105941: LD_VAR 0 2
105945: PPUSH
105946: CALL_OW 259
105950: PPUSH
105951: CALL_OW 2
105955: ST_TO_ADDR
105956: GO 105914
105958: POP
105959: POP
// if not tmp then
105960: LD_VAR 0 5
105964: NOT
105965: IFFALSE 105969
// exit ;
105967: GO 105989
// result := SortListByListDesc ( units , tmp ) ;
105969: LD_ADDR_VAR 0 3
105973: PUSH
105974: LD_VAR 0 1
105978: PPUSH
105979: LD_VAR 0 5
105983: PPUSH
105984: CALL_OW 77
105988: ST_TO_ADDR
// end ;
105989: LD_VAR 0 3
105993: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105994: LD_INT 0
105996: PPUSH
105997: PPUSH
105998: PPUSH
// x := GetX ( building ) ;
105999: LD_ADDR_VAR 0 4
106003: PUSH
106004: LD_VAR 0 2
106008: PPUSH
106009: CALL_OW 250
106013: ST_TO_ADDR
// y := GetY ( building ) ;
106014: LD_ADDR_VAR 0 5
106018: PUSH
106019: LD_VAR 0 2
106023: PPUSH
106024: CALL_OW 251
106028: ST_TO_ADDR
// if GetTaskList ( unit ) then
106029: LD_VAR 0 1
106033: PPUSH
106034: CALL_OW 437
106038: IFFALSE 106133
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106040: LD_STRING e
106042: PUSH
106043: LD_VAR 0 1
106047: PPUSH
106048: CALL_OW 437
106052: PUSH
106053: LD_INT 1
106055: ARRAY
106056: PUSH
106057: LD_INT 1
106059: ARRAY
106060: EQUAL
106061: PUSH
106062: LD_VAR 0 4
106066: PUSH
106067: LD_VAR 0 1
106071: PPUSH
106072: CALL_OW 437
106076: PUSH
106077: LD_INT 1
106079: ARRAY
106080: PUSH
106081: LD_INT 2
106083: ARRAY
106084: EQUAL
106085: AND
106086: PUSH
106087: LD_VAR 0 5
106091: PUSH
106092: LD_VAR 0 1
106096: PPUSH
106097: CALL_OW 437
106101: PUSH
106102: LD_INT 1
106104: ARRAY
106105: PUSH
106106: LD_INT 3
106108: ARRAY
106109: EQUAL
106110: AND
106111: IFFALSE 106123
// result := true else
106113: LD_ADDR_VAR 0 3
106117: PUSH
106118: LD_INT 1
106120: ST_TO_ADDR
106121: GO 106131
// result := false ;
106123: LD_ADDR_VAR 0 3
106127: PUSH
106128: LD_INT 0
106130: ST_TO_ADDR
// end else
106131: GO 106141
// result := false ;
106133: LD_ADDR_VAR 0 3
106137: PUSH
106138: LD_INT 0
106140: ST_TO_ADDR
// end ;
106141: LD_VAR 0 3
106145: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106146: LD_INT 0
106148: PPUSH
106149: PPUSH
106150: PPUSH
106151: PPUSH
// if not unit or not area then
106152: LD_VAR 0 1
106156: NOT
106157: PUSH
106158: LD_VAR 0 2
106162: NOT
106163: OR
106164: IFFALSE 106168
// exit ;
106166: GO 106332
// tmp := AreaToList ( area , i ) ;
106168: LD_ADDR_VAR 0 6
106172: PUSH
106173: LD_VAR 0 2
106177: PPUSH
106178: LD_VAR 0 5
106182: PPUSH
106183: CALL_OW 517
106187: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106188: LD_ADDR_VAR 0 5
106192: PUSH
106193: DOUBLE
106194: LD_INT 1
106196: DEC
106197: ST_TO_ADDR
106198: LD_VAR 0 6
106202: PUSH
106203: LD_INT 1
106205: ARRAY
106206: PUSH
106207: FOR_TO
106208: IFFALSE 106330
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106210: LD_ADDR_VAR 0 7
106214: PUSH
106215: LD_VAR 0 6
106219: PUSH
106220: LD_INT 1
106222: ARRAY
106223: PUSH
106224: LD_VAR 0 5
106228: ARRAY
106229: PUSH
106230: LD_VAR 0 6
106234: PUSH
106235: LD_INT 2
106237: ARRAY
106238: PUSH
106239: LD_VAR 0 5
106243: ARRAY
106244: PUSH
106245: EMPTY
106246: LIST
106247: LIST
106248: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106249: LD_VAR 0 7
106253: PUSH
106254: LD_INT 1
106256: ARRAY
106257: PPUSH
106258: LD_VAR 0 7
106262: PUSH
106263: LD_INT 2
106265: ARRAY
106266: PPUSH
106267: CALL_OW 428
106271: PUSH
106272: LD_INT 0
106274: EQUAL
106275: IFFALSE 106328
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106277: LD_VAR 0 1
106281: PPUSH
106282: LD_VAR 0 7
106286: PUSH
106287: LD_INT 1
106289: ARRAY
106290: PPUSH
106291: LD_VAR 0 7
106295: PUSH
106296: LD_INT 2
106298: ARRAY
106299: PPUSH
106300: LD_VAR 0 3
106304: PPUSH
106305: CALL_OW 48
// result := IsPlaced ( unit ) ;
106309: LD_ADDR_VAR 0 4
106313: PUSH
106314: LD_VAR 0 1
106318: PPUSH
106319: CALL_OW 305
106323: ST_TO_ADDR
// exit ;
106324: POP
106325: POP
106326: GO 106332
// end ; end ;
106328: GO 106207
106330: POP
106331: POP
// end ;
106332: LD_VAR 0 4
106336: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106337: LD_INT 0
106339: PPUSH
106340: PPUSH
106341: PPUSH
// if not side or side > 8 then
106342: LD_VAR 0 1
106346: NOT
106347: PUSH
106348: LD_VAR 0 1
106352: PUSH
106353: LD_INT 8
106355: GREATER
106356: OR
106357: IFFALSE 106361
// exit ;
106359: GO 106548
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106361: LD_ADDR_VAR 0 4
106365: PUSH
106366: LD_INT 22
106368: PUSH
106369: LD_VAR 0 1
106373: PUSH
106374: EMPTY
106375: LIST
106376: LIST
106377: PUSH
106378: LD_INT 21
106380: PUSH
106381: LD_INT 3
106383: PUSH
106384: EMPTY
106385: LIST
106386: LIST
106387: PUSH
106388: EMPTY
106389: LIST
106390: LIST
106391: PPUSH
106392: CALL_OW 69
106396: ST_TO_ADDR
// if not tmp then
106397: LD_VAR 0 4
106401: NOT
106402: IFFALSE 106406
// exit ;
106404: GO 106548
// enable_addtolog := true ;
106406: LD_ADDR_OWVAR 81
106410: PUSH
106411: LD_INT 1
106413: ST_TO_ADDR
// AddToLog ( [ ) ;
106414: LD_STRING [
106416: PPUSH
106417: CALL_OW 561
// for i in tmp do
106421: LD_ADDR_VAR 0 3
106425: PUSH
106426: LD_VAR 0 4
106430: PUSH
106431: FOR_IN
106432: IFFALSE 106539
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106434: LD_STRING [
106436: PUSH
106437: LD_VAR 0 3
106441: PPUSH
106442: CALL_OW 266
106446: STR
106447: PUSH
106448: LD_STRING , 
106450: STR
106451: PUSH
106452: LD_VAR 0 3
106456: PPUSH
106457: CALL_OW 250
106461: STR
106462: PUSH
106463: LD_STRING , 
106465: STR
106466: PUSH
106467: LD_VAR 0 3
106471: PPUSH
106472: CALL_OW 251
106476: STR
106477: PUSH
106478: LD_STRING , 
106480: STR
106481: PUSH
106482: LD_VAR 0 3
106486: PPUSH
106487: CALL_OW 254
106491: STR
106492: PUSH
106493: LD_STRING , 
106495: STR
106496: PUSH
106497: LD_VAR 0 3
106501: PPUSH
106502: LD_INT 1
106504: PPUSH
106505: CALL_OW 268
106509: STR
106510: PUSH
106511: LD_STRING , 
106513: STR
106514: PUSH
106515: LD_VAR 0 3
106519: PPUSH
106520: LD_INT 2
106522: PPUSH
106523: CALL_OW 268
106527: STR
106528: PUSH
106529: LD_STRING ],
106531: STR
106532: PPUSH
106533: CALL_OW 561
// end ;
106537: GO 106431
106539: POP
106540: POP
// AddToLog ( ]; ) ;
106541: LD_STRING ];
106543: PPUSH
106544: CALL_OW 561
// end ;
106548: LD_VAR 0 2
106552: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106553: LD_INT 0
106555: PPUSH
106556: PPUSH
106557: PPUSH
106558: PPUSH
106559: PPUSH
// if not area or not rate or not max then
106560: LD_VAR 0 1
106564: NOT
106565: PUSH
106566: LD_VAR 0 2
106570: NOT
106571: OR
106572: PUSH
106573: LD_VAR 0 4
106577: NOT
106578: OR
106579: IFFALSE 106583
// exit ;
106581: GO 106775
// while 1 do
106583: LD_INT 1
106585: IFFALSE 106775
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106587: LD_ADDR_VAR 0 9
106591: PUSH
106592: LD_VAR 0 1
106596: PPUSH
106597: LD_INT 1
106599: PPUSH
106600: CALL_OW 287
106604: PUSH
106605: LD_INT 10
106607: MUL
106608: ST_TO_ADDR
// r := rate / 10 ;
106609: LD_ADDR_VAR 0 7
106613: PUSH
106614: LD_VAR 0 2
106618: PUSH
106619: LD_INT 10
106621: DIVREAL
106622: ST_TO_ADDR
// time := 1 1$00 ;
106623: LD_ADDR_VAR 0 8
106627: PUSH
106628: LD_INT 2100
106630: ST_TO_ADDR
// if amount < min then
106631: LD_VAR 0 9
106635: PUSH
106636: LD_VAR 0 3
106640: LESS
106641: IFFALSE 106659
// r := r * 2 else
106643: LD_ADDR_VAR 0 7
106647: PUSH
106648: LD_VAR 0 7
106652: PUSH
106653: LD_INT 2
106655: MUL
106656: ST_TO_ADDR
106657: GO 106685
// if amount > max then
106659: LD_VAR 0 9
106663: PUSH
106664: LD_VAR 0 4
106668: GREATER
106669: IFFALSE 106685
// r := r / 2 ;
106671: LD_ADDR_VAR 0 7
106675: PUSH
106676: LD_VAR 0 7
106680: PUSH
106681: LD_INT 2
106683: DIVREAL
106684: ST_TO_ADDR
// time := time / r ;
106685: LD_ADDR_VAR 0 8
106689: PUSH
106690: LD_VAR 0 8
106694: PUSH
106695: LD_VAR 0 7
106699: DIVREAL
106700: ST_TO_ADDR
// if time < 0 then
106701: LD_VAR 0 8
106705: PUSH
106706: LD_INT 0
106708: LESS
106709: IFFALSE 106726
// time := time * - 1 ;
106711: LD_ADDR_VAR 0 8
106715: PUSH
106716: LD_VAR 0 8
106720: PUSH
106721: LD_INT 1
106723: NEG
106724: MUL
106725: ST_TO_ADDR
// wait ( time ) ;
106726: LD_VAR 0 8
106730: PPUSH
106731: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106735: LD_INT 35
106737: PPUSH
106738: LD_INT 875
106740: PPUSH
106741: CALL_OW 12
106745: PPUSH
106746: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106750: LD_INT 1
106752: PPUSH
106753: LD_INT 5
106755: PPUSH
106756: CALL_OW 12
106760: PPUSH
106761: LD_VAR 0 1
106765: PPUSH
106766: LD_INT 1
106768: PPUSH
106769: CALL_OW 55
// end ;
106773: GO 106583
// end ;
106775: LD_VAR 0 5
106779: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106780: LD_INT 0
106782: PPUSH
106783: PPUSH
106784: PPUSH
106785: PPUSH
106786: PPUSH
106787: PPUSH
106788: PPUSH
106789: PPUSH
// if not turrets or not factories then
106790: LD_VAR 0 1
106794: NOT
106795: PUSH
106796: LD_VAR 0 2
106800: NOT
106801: OR
106802: IFFALSE 106806
// exit ;
106804: GO 107113
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106806: LD_ADDR_VAR 0 10
106810: PUSH
106811: LD_INT 5
106813: PUSH
106814: LD_INT 6
106816: PUSH
106817: EMPTY
106818: LIST
106819: LIST
106820: PUSH
106821: LD_INT 2
106823: PUSH
106824: LD_INT 4
106826: PUSH
106827: EMPTY
106828: LIST
106829: LIST
106830: PUSH
106831: LD_INT 3
106833: PUSH
106834: LD_INT 5
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: PUSH
106841: EMPTY
106842: LIST
106843: LIST
106844: LIST
106845: PUSH
106846: LD_INT 24
106848: PUSH
106849: LD_INT 25
106851: PUSH
106852: EMPTY
106853: LIST
106854: LIST
106855: PUSH
106856: LD_INT 23
106858: PUSH
106859: LD_INT 27
106861: PUSH
106862: EMPTY
106863: LIST
106864: LIST
106865: PUSH
106866: EMPTY
106867: LIST
106868: LIST
106869: PUSH
106870: LD_INT 42
106872: PUSH
106873: LD_INT 43
106875: PUSH
106876: EMPTY
106877: LIST
106878: LIST
106879: PUSH
106880: LD_INT 44
106882: PUSH
106883: LD_INT 46
106885: PUSH
106886: EMPTY
106887: LIST
106888: LIST
106889: PUSH
106890: LD_INT 45
106892: PUSH
106893: LD_INT 47
106895: PUSH
106896: EMPTY
106897: LIST
106898: LIST
106899: PUSH
106900: EMPTY
106901: LIST
106902: LIST
106903: LIST
106904: PUSH
106905: EMPTY
106906: LIST
106907: LIST
106908: LIST
106909: ST_TO_ADDR
// result := [ ] ;
106910: LD_ADDR_VAR 0 3
106914: PUSH
106915: EMPTY
106916: ST_TO_ADDR
// for i in turrets do
106917: LD_ADDR_VAR 0 4
106921: PUSH
106922: LD_VAR 0 1
106926: PUSH
106927: FOR_IN
106928: IFFALSE 107111
// begin nat := GetNation ( i ) ;
106930: LD_ADDR_VAR 0 7
106934: PUSH
106935: LD_VAR 0 4
106939: PPUSH
106940: CALL_OW 248
106944: ST_TO_ADDR
// weapon := 0 ;
106945: LD_ADDR_VAR 0 8
106949: PUSH
106950: LD_INT 0
106952: ST_TO_ADDR
// if not nat then
106953: LD_VAR 0 7
106957: NOT
106958: IFFALSE 106962
// continue ;
106960: GO 106927
// for j in list [ nat ] do
106962: LD_ADDR_VAR 0 5
106966: PUSH
106967: LD_VAR 0 10
106971: PUSH
106972: LD_VAR 0 7
106976: ARRAY
106977: PUSH
106978: FOR_IN
106979: IFFALSE 107020
// if GetBWeapon ( i ) = j [ 1 ] then
106981: LD_VAR 0 4
106985: PPUSH
106986: CALL_OW 269
106990: PUSH
106991: LD_VAR 0 5
106995: PUSH
106996: LD_INT 1
106998: ARRAY
106999: EQUAL
107000: IFFALSE 107018
// begin weapon := j [ 2 ] ;
107002: LD_ADDR_VAR 0 8
107006: PUSH
107007: LD_VAR 0 5
107011: PUSH
107012: LD_INT 2
107014: ARRAY
107015: ST_TO_ADDR
// break ;
107016: GO 107020
// end ;
107018: GO 106978
107020: POP
107021: POP
// if not weapon then
107022: LD_VAR 0 8
107026: NOT
107027: IFFALSE 107031
// continue ;
107029: GO 106927
// for k in factories do
107031: LD_ADDR_VAR 0 6
107035: PUSH
107036: LD_VAR 0 2
107040: PUSH
107041: FOR_IN
107042: IFFALSE 107107
// begin weapons := AvailableWeaponList ( k ) ;
107044: LD_ADDR_VAR 0 9
107048: PUSH
107049: LD_VAR 0 6
107053: PPUSH
107054: CALL_OW 478
107058: ST_TO_ADDR
// if not weapons then
107059: LD_VAR 0 9
107063: NOT
107064: IFFALSE 107068
// continue ;
107066: GO 107041
// if weapon in weapons then
107068: LD_VAR 0 8
107072: PUSH
107073: LD_VAR 0 9
107077: IN
107078: IFFALSE 107105
// begin result := [ i , weapon ] ;
107080: LD_ADDR_VAR 0 3
107084: PUSH
107085: LD_VAR 0 4
107089: PUSH
107090: LD_VAR 0 8
107094: PUSH
107095: EMPTY
107096: LIST
107097: LIST
107098: ST_TO_ADDR
// exit ;
107099: POP
107100: POP
107101: POP
107102: POP
107103: GO 107113
// end ; end ;
107105: GO 107041
107107: POP
107108: POP
// end ;
107109: GO 106927
107111: POP
107112: POP
// end ;
107113: LD_VAR 0 3
107117: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107118: LD_INT 0
107120: PPUSH
// if not side or side > 8 then
107121: LD_VAR 0 3
107125: NOT
107126: PUSH
107127: LD_VAR 0 3
107131: PUSH
107132: LD_INT 8
107134: GREATER
107135: OR
107136: IFFALSE 107140
// exit ;
107138: GO 107199
// if not range then
107140: LD_VAR 0 4
107144: NOT
107145: IFFALSE 107156
// range := - 12 ;
107147: LD_ADDR_VAR 0 4
107151: PUSH
107152: LD_INT 12
107154: NEG
107155: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107156: LD_VAR 0 1
107160: PPUSH
107161: LD_VAR 0 2
107165: PPUSH
107166: LD_VAR 0 3
107170: PPUSH
107171: LD_VAR 0 4
107175: PPUSH
107176: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107180: LD_VAR 0 1
107184: PPUSH
107185: LD_VAR 0 2
107189: PPUSH
107190: LD_VAR 0 3
107194: PPUSH
107195: CALL_OW 331
// end ;
107199: LD_VAR 0 5
107203: RET
// export function Video ( mode ) ; begin
107204: LD_INT 0
107206: PPUSH
// ingame_video = mode ;
107207: LD_ADDR_OWVAR 52
107211: PUSH
107212: LD_VAR 0 1
107216: ST_TO_ADDR
// interface_hidden = mode ;
107217: LD_ADDR_OWVAR 54
107221: PUSH
107222: LD_VAR 0 1
107226: ST_TO_ADDR
// end ;
107227: LD_VAR 0 2
107231: RET
// export function Join ( array , element ) ; begin
107232: LD_INT 0
107234: PPUSH
// result := array ^ element ;
107235: LD_ADDR_VAR 0 3
107239: PUSH
107240: LD_VAR 0 1
107244: PUSH
107245: LD_VAR 0 2
107249: ADD
107250: ST_TO_ADDR
// end ;
107251: LD_VAR 0 3
107255: RET
// export function JoinUnion ( array , element ) ; begin
107256: LD_INT 0
107258: PPUSH
// result := array union element ;
107259: LD_ADDR_VAR 0 3
107263: PUSH
107264: LD_VAR 0 1
107268: PUSH
107269: LD_VAR 0 2
107273: UNION
107274: ST_TO_ADDR
// end ;
107275: LD_VAR 0 3
107279: RET
// export function GetBehemoths ( side ) ; begin
107280: LD_INT 0
107282: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107283: LD_ADDR_VAR 0 2
107287: PUSH
107288: LD_INT 22
107290: PUSH
107291: LD_VAR 0 1
107295: PUSH
107296: EMPTY
107297: LIST
107298: LIST
107299: PUSH
107300: LD_INT 31
107302: PUSH
107303: LD_INT 25
107305: PUSH
107306: EMPTY
107307: LIST
107308: LIST
107309: PUSH
107310: EMPTY
107311: LIST
107312: LIST
107313: PPUSH
107314: CALL_OW 69
107318: ST_TO_ADDR
// end ;
107319: LD_VAR 0 2
107323: RET
// export function Shuffle ( array ) ; var i , index ; begin
107324: LD_INT 0
107326: PPUSH
107327: PPUSH
107328: PPUSH
// result := [ ] ;
107329: LD_ADDR_VAR 0 2
107333: PUSH
107334: EMPTY
107335: ST_TO_ADDR
// if not array then
107336: LD_VAR 0 1
107340: NOT
107341: IFFALSE 107345
// exit ;
107343: GO 107444
// Randomize ;
107345: CALL_OW 10
// for i = array downto 1 do
107349: LD_ADDR_VAR 0 3
107353: PUSH
107354: DOUBLE
107355: LD_VAR 0 1
107359: INC
107360: ST_TO_ADDR
107361: LD_INT 1
107363: PUSH
107364: FOR_DOWNTO
107365: IFFALSE 107442
// begin index := rand ( 1 , array ) ;
107367: LD_ADDR_VAR 0 4
107371: PUSH
107372: LD_INT 1
107374: PPUSH
107375: LD_VAR 0 1
107379: PPUSH
107380: CALL_OW 12
107384: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107385: LD_ADDR_VAR 0 2
107389: PUSH
107390: LD_VAR 0 2
107394: PPUSH
107395: LD_VAR 0 2
107399: PUSH
107400: LD_INT 1
107402: PLUS
107403: PPUSH
107404: LD_VAR 0 1
107408: PUSH
107409: LD_VAR 0 4
107413: ARRAY
107414: PPUSH
107415: CALL_OW 2
107419: ST_TO_ADDR
// array := Delete ( array , index ) ;
107420: LD_ADDR_VAR 0 1
107424: PUSH
107425: LD_VAR 0 1
107429: PPUSH
107430: LD_VAR 0 4
107434: PPUSH
107435: CALL_OW 3
107439: ST_TO_ADDR
// end ;
107440: GO 107364
107442: POP
107443: POP
// end ;
107444: LD_VAR 0 2
107448: RET
// export function GetBaseMaterials ( base ) ; begin
107449: LD_INT 0
107451: PPUSH
// result := [ 0 , 0 , 0 ] ;
107452: LD_ADDR_VAR 0 2
107456: PUSH
107457: LD_INT 0
107459: PUSH
107460: LD_INT 0
107462: PUSH
107463: LD_INT 0
107465: PUSH
107466: EMPTY
107467: LIST
107468: LIST
107469: LIST
107470: ST_TO_ADDR
// if not base then
107471: LD_VAR 0 1
107475: NOT
107476: IFFALSE 107480
// exit ;
107478: GO 107529
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107480: LD_ADDR_VAR 0 2
107484: PUSH
107485: LD_VAR 0 1
107489: PPUSH
107490: LD_INT 1
107492: PPUSH
107493: CALL_OW 275
107497: PUSH
107498: LD_VAR 0 1
107502: PPUSH
107503: LD_INT 2
107505: PPUSH
107506: CALL_OW 275
107510: PUSH
107511: LD_VAR 0 1
107515: PPUSH
107516: LD_INT 3
107518: PPUSH
107519: CALL_OW 275
107523: PUSH
107524: EMPTY
107525: LIST
107526: LIST
107527: LIST
107528: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107529: LD_VAR 0 2
107533: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107534: LD_INT 0
107536: PPUSH
107537: PPUSH
107538: PPUSH
107539: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107540: LD_VAR 0 1
107544: PPUSH
107545: CALL_OW 264
107549: PUSH
107550: LD_EXP 98
107554: EQUAL
107555: IFFALSE 107627
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107557: LD_INT 68
107559: PPUSH
107560: LD_VAR 0 1
107564: PPUSH
107565: CALL_OW 255
107569: PPUSH
107570: CALL_OW 321
107574: PUSH
107575: LD_INT 2
107577: EQUAL
107578: IFFALSE 107590
// eff := 70 else
107580: LD_ADDR_VAR 0 6
107584: PUSH
107585: LD_INT 70
107587: ST_TO_ADDR
107588: GO 107598
// eff := 30 ;
107590: LD_ADDR_VAR 0 6
107594: PUSH
107595: LD_INT 30
107597: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107598: LD_VAR 0 1
107602: PPUSH
107603: CALL_OW 250
107607: PPUSH
107608: LD_VAR 0 1
107612: PPUSH
107613: CALL_OW 251
107617: PPUSH
107618: LD_VAR 0 6
107622: PPUSH
107623: CALL_OW 495
// end ; end ;
107627: LD_VAR 0 4
107631: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107632: LD_INT 0
107634: PPUSH
107635: PPUSH
107636: PPUSH
107637: PPUSH
107638: PPUSH
107639: PPUSH
// if cmd = 124 then
107640: LD_VAR 0 1
107644: PUSH
107645: LD_INT 124
107647: EQUAL
107648: IFFALSE 107854
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107650: LD_ADDR_VAR 0 5
107654: PUSH
107655: LD_INT 2
107657: PUSH
107658: LD_INT 34
107660: PUSH
107661: LD_INT 53
107663: PUSH
107664: EMPTY
107665: LIST
107666: LIST
107667: PUSH
107668: LD_INT 34
107670: PUSH
107671: LD_INT 14
107673: PUSH
107674: EMPTY
107675: LIST
107676: LIST
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: LIST
107682: PPUSH
107683: CALL_OW 69
107687: ST_TO_ADDR
// if not tmp then
107688: LD_VAR 0 5
107692: NOT
107693: IFFALSE 107697
// exit ;
107695: GO 107854
// for i in tmp do
107697: LD_ADDR_VAR 0 3
107701: PUSH
107702: LD_VAR 0 5
107706: PUSH
107707: FOR_IN
107708: IFFALSE 107852
// begin taskList := GetTaskList ( i ) ;
107710: LD_ADDR_VAR 0 6
107714: PUSH
107715: LD_VAR 0 3
107719: PPUSH
107720: CALL_OW 437
107724: ST_TO_ADDR
// if not taskList then
107725: LD_VAR 0 6
107729: NOT
107730: IFFALSE 107734
// continue ;
107732: GO 107707
// for j = 1 to taskList do
107734: LD_ADDR_VAR 0 4
107738: PUSH
107739: DOUBLE
107740: LD_INT 1
107742: DEC
107743: ST_TO_ADDR
107744: LD_VAR 0 6
107748: PUSH
107749: FOR_TO
107750: IFFALSE 107848
// if taskList [ j ] [ 1 ] = | then
107752: LD_VAR 0 6
107756: PUSH
107757: LD_VAR 0 4
107761: ARRAY
107762: PUSH
107763: LD_INT 1
107765: ARRAY
107766: PUSH
107767: LD_STRING |
107769: EQUAL
107770: IFFALSE 107846
// begin _taskList := Delete ( taskList , 1 ) ;
107772: LD_ADDR_VAR 0 7
107776: PUSH
107777: LD_VAR 0 6
107781: PPUSH
107782: LD_INT 1
107784: PPUSH
107785: CALL_OW 3
107789: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107790: LD_VAR 0 3
107794: PPUSH
107795: LD_VAR 0 7
107799: PPUSH
107800: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107804: LD_VAR 0 3
107808: PPUSH
107809: LD_VAR 0 6
107813: PUSH
107814: LD_VAR 0 4
107818: ARRAY
107819: PUSH
107820: LD_INT 2
107822: ARRAY
107823: PPUSH
107824: LD_VAR 0 6
107828: PUSH
107829: LD_VAR 0 4
107833: ARRAY
107834: PUSH
107835: LD_INT 3
107837: ARRAY
107838: PPUSH
107839: LD_INT 8
107841: PPUSH
107842: CALL 107859 0 4
// end ;
107846: GO 107749
107848: POP
107849: POP
// end ;
107850: GO 107707
107852: POP
107853: POP
// end ; end ;
107854: LD_VAR 0 2
107858: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107859: LD_INT 0
107861: PPUSH
107862: PPUSH
107863: PPUSH
107864: PPUSH
107865: PPUSH
107866: PPUSH
107867: PPUSH
107868: PPUSH
107869: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107870: LD_VAR 0 1
107874: NOT
107875: PUSH
107876: LD_VAR 0 2
107880: PPUSH
107881: LD_VAR 0 3
107885: PPUSH
107886: CALL_OW 488
107890: NOT
107891: OR
107892: PUSH
107893: LD_VAR 0 4
107897: NOT
107898: OR
107899: IFFALSE 107903
// exit ;
107901: GO 108243
// list := [ ] ;
107903: LD_ADDR_VAR 0 13
107907: PUSH
107908: EMPTY
107909: ST_TO_ADDR
// if x - r < 0 then
107910: LD_VAR 0 2
107914: PUSH
107915: LD_VAR 0 4
107919: MINUS
107920: PUSH
107921: LD_INT 0
107923: LESS
107924: IFFALSE 107936
// min_x := 0 else
107926: LD_ADDR_VAR 0 7
107930: PUSH
107931: LD_INT 0
107933: ST_TO_ADDR
107934: GO 107952
// min_x := x - r ;
107936: LD_ADDR_VAR 0 7
107940: PUSH
107941: LD_VAR 0 2
107945: PUSH
107946: LD_VAR 0 4
107950: MINUS
107951: ST_TO_ADDR
// if y - r < 0 then
107952: LD_VAR 0 3
107956: PUSH
107957: LD_VAR 0 4
107961: MINUS
107962: PUSH
107963: LD_INT 0
107965: LESS
107966: IFFALSE 107978
// min_y := 0 else
107968: LD_ADDR_VAR 0 8
107972: PUSH
107973: LD_INT 0
107975: ST_TO_ADDR
107976: GO 107994
// min_y := y - r ;
107978: LD_ADDR_VAR 0 8
107982: PUSH
107983: LD_VAR 0 3
107987: PUSH
107988: LD_VAR 0 4
107992: MINUS
107993: ST_TO_ADDR
// max_x := x + r ;
107994: LD_ADDR_VAR 0 9
107998: PUSH
107999: LD_VAR 0 2
108003: PUSH
108004: LD_VAR 0 4
108008: PLUS
108009: ST_TO_ADDR
// max_y := y + r ;
108010: LD_ADDR_VAR 0 10
108014: PUSH
108015: LD_VAR 0 3
108019: PUSH
108020: LD_VAR 0 4
108024: PLUS
108025: ST_TO_ADDR
// for _x = min_x to max_x do
108026: LD_ADDR_VAR 0 11
108030: PUSH
108031: DOUBLE
108032: LD_VAR 0 7
108036: DEC
108037: ST_TO_ADDR
108038: LD_VAR 0 9
108042: PUSH
108043: FOR_TO
108044: IFFALSE 108161
// for _y = min_y to max_y do
108046: LD_ADDR_VAR 0 12
108050: PUSH
108051: DOUBLE
108052: LD_VAR 0 8
108056: DEC
108057: ST_TO_ADDR
108058: LD_VAR 0 10
108062: PUSH
108063: FOR_TO
108064: IFFALSE 108157
// begin if not ValidHex ( _x , _y ) then
108066: LD_VAR 0 11
108070: PPUSH
108071: LD_VAR 0 12
108075: PPUSH
108076: CALL_OW 488
108080: NOT
108081: IFFALSE 108085
// continue ;
108083: GO 108063
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108085: LD_VAR 0 11
108089: PPUSH
108090: LD_VAR 0 12
108094: PPUSH
108095: CALL_OW 351
108099: PUSH
108100: LD_VAR 0 11
108104: PPUSH
108105: LD_VAR 0 12
108109: PPUSH
108110: CALL_OW 554
108114: AND
108115: IFFALSE 108155
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108117: LD_ADDR_VAR 0 13
108121: PUSH
108122: LD_VAR 0 13
108126: PPUSH
108127: LD_VAR 0 13
108131: PUSH
108132: LD_INT 1
108134: PLUS
108135: PPUSH
108136: LD_VAR 0 11
108140: PUSH
108141: LD_VAR 0 12
108145: PUSH
108146: EMPTY
108147: LIST
108148: LIST
108149: PPUSH
108150: CALL_OW 2
108154: ST_TO_ADDR
// end ;
108155: GO 108063
108157: POP
108158: POP
108159: GO 108043
108161: POP
108162: POP
// if not list then
108163: LD_VAR 0 13
108167: NOT
108168: IFFALSE 108172
// exit ;
108170: GO 108243
// for i in list do
108172: LD_ADDR_VAR 0 6
108176: PUSH
108177: LD_VAR 0 13
108181: PUSH
108182: FOR_IN
108183: IFFALSE 108241
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108185: LD_VAR 0 1
108189: PPUSH
108190: LD_STRING M
108192: PUSH
108193: LD_VAR 0 6
108197: PUSH
108198: LD_INT 1
108200: ARRAY
108201: PUSH
108202: LD_VAR 0 6
108206: PUSH
108207: LD_INT 2
108209: ARRAY
108210: PUSH
108211: LD_INT 0
108213: PUSH
108214: LD_INT 0
108216: PUSH
108217: LD_INT 0
108219: PUSH
108220: LD_INT 0
108222: PUSH
108223: EMPTY
108224: LIST
108225: LIST
108226: LIST
108227: LIST
108228: LIST
108229: LIST
108230: LIST
108231: PUSH
108232: EMPTY
108233: LIST
108234: PPUSH
108235: CALL_OW 447
108239: GO 108182
108241: POP
108242: POP
// end ;
108243: LD_VAR 0 5
108247: RET
