// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34247 0 0
// InitNature ;
  19: CALL 34071 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10934 0 0
// PrepareRussian ;
  40: CALL 6917 0 0
// PrepareLegion ;
  44: CALL 4157 0 0
// PreparePowell ;
  48: CALL 2911 0 0
// PrepareAmerican ;
  52: CALL 1683 0 0
// Action ;
  56: CALL 14841 0 0
// MC_Start ( ) ;
  60: CALL 36359 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58636 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58729 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 58079 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57894 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58636 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58729 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57894 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 58079 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58509 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57576 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58636 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58729 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57894 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58636 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58729 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57786 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 59047 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58218 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58509 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58509 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58841 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57894 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58460 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1683: LD_INT 0
1685: PPUSH
// uc_side := 1 ;
1686: LD_ADDR_OWVAR 20
1690: PUSH
1691: LD_INT 1
1693: ST_TO_ADDR
// uc_nation := 1 ;
1694: LD_ADDR_OWVAR 21
1698: PUSH
1699: LD_INT 1
1701: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1702: LD_ADDR_EXP 38
1706: PUSH
1707: LD_STRING JMM
1709: PPUSH
1710: LD_EXP 1
1714: NOT
1715: PPUSH
1716: LD_STRING 14_
1718: PPUSH
1719: CALL 64286 0 3
1723: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1724: LD_EXP 4
1728: NOT
1729: PUSH
1730: LD_EXP 4
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PUSH
1739: LD_INT 1
1741: ARRAY
1742: NOT
1743: OR
1744: IFFALSE 1767
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1746: LD_INT 3
1748: PPUSH
1749: LD_INT 3
1751: PPUSH
1752: LD_INT 1
1754: PPUSH
1755: LD_INT 5
1757: PPUSH
1758: LD_INT 100
1760: PPUSH
1761: CALL 71401 0 5
1765: GO 1826
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1767: LD_EXP 4
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PUSH
1776: LD_INT 1
1778: ARRAY
1779: PPUSH
1780: LD_EXP 4
1784: PUSH
1785: LD_INT 2
1787: ARRAY
1788: PUSH
1789: LD_INT 1
1791: ARRAY
1792: PPUSH
1793: LD_EXP 4
1797: PUSH
1798: LD_INT 3
1800: ARRAY
1801: PUSH
1802: LD_INT 1
1804: ARRAY
1805: PPUSH
1806: LD_EXP 4
1810: PUSH
1811: LD_INT 4
1813: ARRAY
1814: PUSH
1815: LD_INT 1
1817: ARRAY
1818: PPUSH
1819: LD_INT 30
1821: PPUSH
1822: CALL 71401 0 5
// JMMNewVeh := CreateVehicle ;
1826: LD_ADDR_EXP 55
1830: PUSH
1831: CALL_OW 45
1835: ST_TO_ADDR
// if not JMMNewVeh then
1836: LD_EXP 55
1840: NOT
1841: IFFALSE 1872
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1843: LD_INT 3
1845: PPUSH
1846: LD_INT 3
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 100
1857: PPUSH
1858: CALL 71401 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 55
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1872: LD_EXP 55
1876: PPUSH
1877: LD_INT 4
1879: PPUSH
1880: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1884: LD_EXP 55
1888: PPUSH
1889: LD_INT 79
1891: PPUSH
1892: LD_INT 91
1894: PPUSH
1895: LD_INT 0
1897: PPUSH
1898: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1902: LD_EXP 38
1906: PPUSH
1907: LD_EXP 55
1911: PPUSH
1912: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1916: LD_EXP 6
1920: PUSH
1921: LD_EXP 2
1925: NOT
1926: AND
1927: IFFALSE 2185
// begin if not JMMGirlVeh then
1929: LD_EXP 5
1933: NOT
1934: IFFALSE 1957
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1936: LD_INT 3
1938: PPUSH
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_INT 9
1947: PPUSH
1948: LD_INT 100
1950: PPUSH
1951: CALL 71401 0 5
1955: GO 2016
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1957: LD_EXP 5
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PPUSH
1970: LD_EXP 5
1974: PUSH
1975: LD_INT 2
1977: ARRAY
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PPUSH
1983: LD_EXP 5
1987: PUSH
1988: LD_INT 3
1990: ARRAY
1991: PUSH
1992: LD_INT 1
1994: ARRAY
1995: PPUSH
1996: LD_EXP 5
2000: PUSH
2001: LD_INT 4
2003: ARRAY
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PPUSH
2009: LD_INT 30
2011: PPUSH
2012: CALL 71401 0 5
// GirlNewVeh := CreateVehicle ;
2016: LD_ADDR_EXP 56
2020: PUSH
2021: CALL_OW 45
2025: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2026: LD_EXP 56
2030: PPUSH
2031: LD_INT 4
2033: PPUSH
2034: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2038: LD_EXP 56
2042: PPUSH
2043: LD_INT 82
2045: PPUSH
2046: LD_INT 96
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 48
// if JMMGirl = 1 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: IFFALSE 2099
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Joan
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64286 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 56
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 2 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 2
2106: EQUAL
2107: IFFALSE 2142
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2109: LD_ADDR_EXP 41
2113: PUSH
2114: LD_STRING Lisa
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64286 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2128: LD_EXP 41
2132: PPUSH
2133: LD_EXP 56
2137: PPUSH
2138: CALL_OW 52
// end ; if JMMGirl = 3 then
2142: LD_EXP 7
2146: PUSH
2147: LD_INT 3
2149: EQUAL
2150: IFFALSE 2185
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2152: LD_ADDR_EXP 53
2156: PUSH
2157: LD_STRING Connie
2159: PPUSH
2160: LD_INT 1
2162: PPUSH
2163: LD_STRING 14_
2165: PPUSH
2166: CALL 64286 0 3
2170: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2171: LD_EXP 53
2175: PPUSH
2176: LD_EXP 56
2180: PPUSH
2181: CALL_OW 52
// end ; end ; end ;
2185: LD_VAR 0 1
2189: RET
// export function PrepareStevensSquad ; var tmp ; begin
2190: LD_INT 0
2192: PPUSH
2193: PPUSH
// uc_side := 1 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// tmp := [ ] ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: EMPTY
2216: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2217: LD_ADDR_EXP 40
2221: PUSH
2222: LD_STRING Stevens
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: LD_STRING 13f_
2233: PPUSH
2234: CALL 64286 0 3
2238: ST_TO_ADDR
// if not Stevens then
2239: LD_EXP 40
2243: NOT
2244: IFFALSE 2300
// begin hc_name = Baker Smith ;
2246: LD_ADDR_OWVAR 26
2250: PUSH
2251: LD_STRING Baker Smith
2253: ST_TO_ADDR
// hc_gallery =  ;
2254: LD_ADDR_OWVAR 33
2258: PUSH
2259: LD_STRING 
2261: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 10
2267: PPUSH
2268: CALL_OW 384
// Baker = CreateHuman ;
2272: LD_ADDR_EXP 54
2276: PUSH
2277: CALL_OW 44
2281: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2282: LD_ADDR_VAR 0 2
2286: PUSH
2287: LD_VAR 0 2
2291: PUSH
2292: LD_EXP 54
2296: ADD
2297: ST_TO_ADDR
// end else
2298: GO 2316
// tmp := tmp ^ Stevens ;
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 2
2309: PUSH
2310: LD_EXP 40
2314: ADD
2315: ST_TO_ADDR
// if not Lisa then
2316: LD_EXP 41
2320: NOT
2321: IFFALSE 2367
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2323: LD_ADDR_EXP 41
2327: PUSH
2328: LD_STRING Lisa
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13f_
2339: PPUSH
2340: CALL 64286 0 3
2344: ST_TO_ADDR
// if Lisa then
2345: LD_EXP 41
2349: IFFALSE 2367
// tmp := tmp ^ Lisa ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 41
2365: ADD
2366: ST_TO_ADDR
// end ; if not Donaldson then
2367: LD_EXP 42
2371: NOT
2372: IFFALSE 2418
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2374: LD_ADDR_EXP 42
2378: PUSH
2379: LD_STRING Donaldson
2381: PPUSH
2382: LD_EXP 1
2386: NOT
2387: PPUSH
2388: LD_STRING 13f_
2390: PPUSH
2391: CALL 64286 0 3
2395: ST_TO_ADDR
// if Donaldson then
2396: LD_EXP 42
2400: IFFALSE 2418
// tmp := tmp ^ Donaldson ;
2402: LD_ADDR_VAR 0 2
2406: PUSH
2407: LD_VAR 0 2
2411: PUSH
2412: LD_EXP 42
2416: ADD
2417: ST_TO_ADDR
// end ; if not Bobby then
2418: LD_EXP 43
2422: NOT
2423: IFFALSE 2469
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2425: LD_ADDR_EXP 43
2429: PUSH
2430: LD_STRING Bobby
2432: PPUSH
2433: LD_EXP 1
2437: NOT
2438: PPUSH
2439: LD_STRING 13f_
2441: PPUSH
2442: CALL 64286 0 3
2446: ST_TO_ADDR
// if Bobby then
2447: LD_EXP 43
2451: IFFALSE 2469
// tmp := tmp ^ Bobby ;
2453: LD_ADDR_VAR 0 2
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_EXP 43
2467: ADD
2468: ST_TO_ADDR
// end ; if not Cyrus then
2469: LD_EXP 44
2473: NOT
2474: IFFALSE 2520
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2476: LD_ADDR_EXP 44
2480: PUSH
2481: LD_STRING Cyrus
2483: PPUSH
2484: LD_EXP 1
2488: NOT
2489: PPUSH
2490: LD_STRING 13f_
2492: PPUSH
2493: CALL 64286 0 3
2497: ST_TO_ADDR
// if Cyrus then
2498: LD_EXP 44
2502: IFFALSE 2520
// tmp := tmp ^ Cyrus ;
2504: LD_ADDR_VAR 0 2
2508: PUSH
2509: LD_VAR 0 2
2513: PUSH
2514: LD_EXP 44
2518: ADD
2519: ST_TO_ADDR
// end ; if not Brown then
2520: LD_EXP 46
2524: NOT
2525: IFFALSE 2571
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2527: LD_ADDR_EXP 46
2531: PUSH
2532: LD_STRING Brown
2534: PPUSH
2535: LD_EXP 1
2539: NOT
2540: PPUSH
2541: LD_STRING 13f_
2543: PPUSH
2544: CALL 64286 0 3
2548: ST_TO_ADDR
// if Brown then
2549: LD_EXP 46
2553: IFFALSE 2571
// tmp := tmp ^ Brown ;
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: LD_VAR 0 2
2564: PUSH
2565: LD_EXP 46
2569: ADD
2570: ST_TO_ADDR
// end ; if not Gladstone then
2571: LD_EXP 47
2575: NOT
2576: IFFALSE 2622
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2578: LD_ADDR_EXP 47
2582: PUSH
2583: LD_STRING Gladstone
2585: PPUSH
2586: LD_EXP 1
2590: NOT
2591: PPUSH
2592: LD_STRING 13f_
2594: PPUSH
2595: CALL 64286 0 3
2599: ST_TO_ADDR
// if Gladstone then
2600: LD_EXP 47
2604: IFFALSE 2622
// tmp := tmp ^ Gladstone ;
2606: LD_ADDR_VAR 0 2
2610: PUSH
2611: LD_VAR 0 2
2615: PUSH
2616: LD_EXP 47
2620: ADD
2621: ST_TO_ADDR
// end ; if not Houten then
2622: LD_EXP 48
2626: NOT
2627: IFFALSE 2673
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2629: LD_ADDR_EXP 48
2633: PUSH
2634: LD_STRING Houten
2636: PPUSH
2637: LD_EXP 1
2641: NOT
2642: PPUSH
2643: LD_STRING 13f_
2645: PPUSH
2646: CALL 64286 0 3
2650: ST_TO_ADDR
// if Houten then
2651: LD_EXP 48
2655: IFFALSE 2673
// tmp := tmp ^ Houten ;
2657: LD_ADDR_VAR 0 2
2661: PUSH
2662: LD_VAR 0 2
2666: PUSH
2667: LD_EXP 48
2671: ADD
2672: ST_TO_ADDR
// end ; if not Cornel then
2673: LD_EXP 49
2677: NOT
2678: IFFALSE 2724
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2680: LD_ADDR_EXP 49
2684: PUSH
2685: LD_STRING Cornell
2687: PPUSH
2688: LD_EXP 1
2692: NOT
2693: PPUSH
2694: LD_STRING 13f_
2696: PPUSH
2697: CALL 64286 0 3
2701: ST_TO_ADDR
// if Cornel then
2702: LD_EXP 49
2706: IFFALSE 2724
// tmp := tmp ^ Cornel ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 2
2717: PUSH
2718: LD_EXP 49
2722: ADD
2723: ST_TO_ADDR
// end ; if not Gary then
2724: LD_EXP 50
2728: NOT
2729: IFFALSE 2775
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2731: LD_ADDR_EXP 50
2735: PUSH
2736: LD_STRING Gary
2738: PPUSH
2739: LD_EXP 1
2743: NOT
2744: PPUSH
2745: LD_STRING 13f_
2747: PPUSH
2748: CALL 64286 0 3
2752: ST_TO_ADDR
// if Gary then
2753: LD_EXP 50
2757: IFFALSE 2775
// tmp := tmp ^ Gary ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_EXP 50
2773: ADD
2774: ST_TO_ADDR
// end ; if not Frank then
2775: LD_EXP 51
2779: NOT
2780: IFFALSE 2826
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2782: LD_ADDR_EXP 51
2786: PUSH
2787: LD_STRING Frank
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_STRING 13f_
2798: PPUSH
2799: CALL 64286 0 3
2803: ST_TO_ADDR
// if Frank then
2804: LD_EXP 51
2808: IFFALSE 2826
// tmp := tmp ^ Frank ;
2810: LD_ADDR_VAR 0 2
2814: PUSH
2815: LD_VAR 0 2
2819: PUSH
2820: LD_EXP 51
2824: ADD
2825: ST_TO_ADDR
// end ; if not Kikuchi then
2826: LD_EXP 52
2830: NOT
2831: IFFALSE 2877
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2833: LD_ADDR_EXP 52
2837: PUSH
2838: LD_STRING Kikuchi
2840: PPUSH
2841: LD_EXP 1
2845: NOT
2846: PPUSH
2847: LD_STRING 13f_
2849: PPUSH
2850: CALL 64286 0 3
2854: ST_TO_ADDR
// if Kikuchi then
2855: LD_EXP 52
2859: IFFALSE 2877
// tmp := tmp ^ Kikuchi ;
2861: LD_ADDR_VAR 0 2
2865: PUSH
2866: LD_VAR 0 2
2870: PUSH
2871: LD_EXP 52
2875: ADD
2876: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2877: LD_ADDR_VAR 0 2
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: LD_STRING 13_other_survivors
2889: PPUSH
2890: CALL_OW 31
2894: UNION
2895: ST_TO_ADDR
// result := tmp ;
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_VAR 0 2
2905: ST_TO_ADDR
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side := 4 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 4
2930: ST_TO_ADDR
// uc_nation := 1 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 1
2938: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2939: LD_INT 387
2941: PPUSH
2942: CALL_OW 274
2946: PPUSH
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 2500
2952: PPUSH
2953: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2957: LD_INT 387
2959: PPUSH
2960: CALL_OW 274
2964: PPUSH
2965: LD_INT 2
2967: PPUSH
2968: LD_INT 400
2970: PPUSH
2971: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 3
2985: PPUSH
2986: LD_INT 10
2988: PPUSH
2989: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2993: LD_ADDR_EXP 57
2997: PUSH
2998: LD_STRING Powell
3000: PPUSH
3001: CALL_OW 25
3005: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3006: LD_EXP 57
3010: PPUSH
3011: LD_INT 57
3013: PPUSH
3014: LD_INT 94
3016: PPUSH
3017: LD_INT 0
3019: PPUSH
3020: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3024: LD_EXP 57
3028: PPUSH
3029: LD_INT 58
3031: PPUSH
3032: LD_INT 94
3034: PPUSH
3035: CALL_OW 118
// vip := [ ] ;
3039: LD_ADDR_EXP 58
3043: PUSH
3044: EMPTY
3045: ST_TO_ADDR
// tmp := [ ] ;
3046: LD_ADDR_VAR 0 6
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if JMMGirl <> 2 then
3053: LD_EXP 7
3057: PUSH
3058: LD_INT 2
3060: NONEQUAL
3061: IFFALSE 3085
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 41
3067: PUSH
3068: LD_STRING Lisa
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 64286 0 3
3084: ST_TO_ADDR
// if Lisa then
3085: LD_EXP 41
3089: IFFALSE 3107
// tmp := tmp ^ Lisa ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 41
3105: ADD
3106: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 42
3111: PUSH
3112: LD_STRING Donaldson
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 64286 0 3
3128: ST_TO_ADDR
// if Donaldson then
3129: LD_EXP 42
3133: IFFALSE 3151
// tmp := tmp ^ Donaldson ;
3135: LD_ADDR_VAR 0 6
3139: PUSH
3140: LD_VAR 0 6
3144: PUSH
3145: LD_EXP 42
3149: ADD
3150: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3151: LD_ADDR_EXP 43
3155: PUSH
3156: LD_STRING Bobby
3158: PPUSH
3159: LD_EXP 1
3163: NOT
3164: PPUSH
3165: LD_STRING 13s_
3167: PPUSH
3168: CALL 64286 0 3
3172: ST_TO_ADDR
// if Bobby then
3173: LD_EXP 43
3177: IFFALSE 3195
// tmp := tmp ^ Bobby ;
3179: LD_ADDR_VAR 0 6
3183: PUSH
3184: LD_VAR 0 6
3188: PUSH
3189: LD_EXP 43
3193: ADD
3194: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3195: LD_ADDR_EXP 44
3199: PUSH
3200: LD_STRING Cyrus
3202: PPUSH
3203: LD_EXP 1
3207: NOT
3208: PPUSH
3209: LD_STRING 13s_
3211: PPUSH
3212: CALL 64286 0 3
3216: ST_TO_ADDR
// if Cyrus then
3217: LD_EXP 44
3221: IFFALSE 3239
// tmp := tmp ^ Cyrus ;
3223: LD_ADDR_VAR 0 6
3227: PUSH
3228: LD_VAR 0 6
3232: PUSH
3233: LD_EXP 44
3237: ADD
3238: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 45
3243: PUSH
3244: LD_STRING Denis
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 64286 0 3
3260: ST_TO_ADDR
// if not Denis then
3261: LD_EXP 45
3265: NOT
3266: IFFALSE 3290
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3268: LD_ADDR_EXP 45
3272: PUSH
3273: LD_STRING Denis
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13f_
3284: PPUSH
3285: CALL 64286 0 3
3289: ST_TO_ADDR
// if Denis then
3290: LD_EXP 45
3294: IFFALSE 3312
// tmp := tmp ^ Denis ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 45
3310: ADD
3311: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 46
3316: PUSH
3317: LD_STRING Brown
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 64286 0 3
3333: ST_TO_ADDR
// if Brown then
3334: LD_EXP 46
3338: IFFALSE 3356
// tmp := tmp ^ Brown ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 46
3354: ADD
3355: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 47
3360: PUSH
3361: LD_STRING Gladstone
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 64286 0 3
3377: ST_TO_ADDR
// if Gladstone then
3378: LD_EXP 47
3382: IFFALSE 3400
// tmp := tmp ^ Gladstone ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 47
3398: ADD
3399: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 48
3404: PUSH
3405: LD_STRING Houten
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 64286 0 3
3421: ST_TO_ADDR
// if Houten then
3422: LD_EXP 48
3426: IFFALSE 3444
// tmp := tmp ^ Houten ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 48
3442: ADD
3443: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 49
3448: PUSH
3449: LD_STRING Cornel
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 64286 0 3
3465: ST_TO_ADDR
// if Cornel then
3466: LD_EXP 49
3470: IFFALSE 3488
// tmp := tmp ^ Cornel ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 49
3486: ADD
3487: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3488: LD_ADDR_EXP 50
3492: PUSH
3493: LD_STRING Gary
3495: PPUSH
3496: LD_EXP 1
3500: NOT
3501: PPUSH
3502: LD_STRING 13s_
3504: PPUSH
3505: CALL 64286 0 3
3509: ST_TO_ADDR
// if Gary then
3510: LD_EXP 50
3514: IFFALSE 3532
// tmp := tmp ^ Gary ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: LD_EXP 50
3530: ADD
3531: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3532: LD_ADDR_EXP 51
3536: PUSH
3537: LD_STRING Frank
3539: PPUSH
3540: LD_EXP 1
3544: NOT
3545: PPUSH
3546: LD_STRING 13s_
3548: PPUSH
3549: CALL 64286 0 3
3553: ST_TO_ADDR
// if Frank then
3554: LD_EXP 51
3558: IFFALSE 3576
// tmp := tmp ^ Frank ;
3560: LD_ADDR_VAR 0 6
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: LD_EXP 51
3574: ADD
3575: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3576: LD_ADDR_EXP 52
3580: PUSH
3581: LD_STRING Kikuchi
3583: PPUSH
3584: LD_EXP 1
3588: NOT
3589: PPUSH
3590: LD_STRING 13s_
3592: PPUSH
3593: CALL 64286 0 3
3597: ST_TO_ADDR
// if Kikuchi then
3598: LD_EXP 52
3602: IFFALSE 3620
// tmp := tmp ^ Kikuchi ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_VAR 0 6
3613: PUSH
3614: LD_EXP 52
3618: ADD
3619: ST_TO_ADDR
// vip := tmp ;
3620: LD_ADDR_EXP 58
3624: PUSH
3625: LD_VAR 0 6
3629: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3630: LD_ADDR_VAR 0 6
3634: PUSH
3635: LD_VAR 0 6
3639: PUSH
3640: LD_STRING 13s_others
3642: PPUSH
3643: CALL_OW 31
3647: UNION
3648: ST_TO_ADDR
// if tmp < 20 then
3649: LD_VAR 0 6
3653: PUSH
3654: LD_INT 20
3656: LESS
3657: IFFALSE 3724
// for i = 1 to 20 - tmp do
3659: LD_ADDR_VAR 0 2
3663: PUSH
3664: DOUBLE
3665: LD_INT 1
3667: DEC
3668: ST_TO_ADDR
3669: LD_INT 20
3671: PUSH
3672: LD_VAR 0 6
3676: MINUS
3677: PUSH
3678: FOR_TO
3679: IFFALSE 3722
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3681: LD_INT 1
3683: PPUSH
3684: LD_VAR 0 2
3688: PUSH
3689: LD_INT 4
3691: MOD
3692: PUSH
3693: LD_INT 1
3695: PLUS
3696: PPUSH
3697: LD_INT 5
3699: PPUSH
3700: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3704: LD_ADDR_VAR 0 6
3708: PUSH
3709: LD_VAR 0 6
3713: PUSH
3714: CALL_OW 44
3718: ADD
3719: ST_TO_ADDR
// end ;
3720: GO 3678
3722: POP
3723: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3724: LD_ADDR_VAR 0 7
3728: PUSH
3729: LD_INT 22
3731: PUSH
3732: LD_INT 4
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 30
3741: PUSH
3742: LD_INT 0
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 69
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3762: LD_ADDR_VAR 0 8
3766: PUSH
3767: LD_INT 22
3769: PUSH
3770: LD_INT 4
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 30
3779: PUSH
3780: LD_INT 6
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PPUSH
3791: CALL_OW 69
3795: PUSH
3796: LD_INT 1
3798: ARRAY
3799: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3800: LD_ADDR_VAR 0 9
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 30
3817: PUSH
3818: LD_INT 4
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PPUSH
3829: CALL_OW 69
3833: PUSH
3834: LD_INT 1
3836: ARRAY
3837: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3838: LD_ADDR_VAR 0 10
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_INT 4
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 30
3855: PUSH
3856: LD_INT 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: CALL_OW 69
3871: PUSH
3872: LD_INT 1
3874: ARRAY
3875: ST_TO_ADDR
// for i in tmp do
3876: LD_ADDR_VAR 0 2
3880: PUSH
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_IN
3887: IFFALSE 4013
// begin cl := GetClass ( i ) ;
3889: LD_ADDR_VAR 0 5
3893: PUSH
3894: LD_VAR 0 2
3898: PPUSH
3899: CALL_OW 257
3903: ST_TO_ADDR
// if cl > 4 then
3904: LD_VAR 0 5
3908: PUSH
3909: LD_INT 4
3911: GREATER
3912: IFFALSE 3922
// cl := 1 ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_INT 1
3921: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3922: LD_ADDR_VAR 0 3
3926: PUSH
3927: LD_VAR 0 9
3931: PUSH
3932: LD_VAR 0 7
3936: PUSH
3937: LD_VAR 0 10
3941: PUSH
3942: LD_VAR 0 8
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: PUSH
3953: LD_VAR 0 5
3957: ARRAY
3958: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3959: LD_VAR 0 3
3963: PPUSH
3964: CALL_OW 313
3968: PUSH
3969: LD_INT 5
3971: LESS
3972: IFFALSE 3990
// PlaceHumanInUnit ( i , b ) else
3974: LD_VAR 0 2
3978: PPUSH
3979: LD_VAR 0 3
3983: PPUSH
3984: CALL_OW 52
3988: GO 4011
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 58
3997: PPUSH
3998: LD_INT 91
4000: PPUSH
4001: LD_INT 6
4003: PPUSH
4004: LD_INT 0
4006: PPUSH
4007: CALL_OW 50
// end ;
4011: GO 3886
4013: POP
4014: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4015: LD_INT 2
4017: PPUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 12
4026: PPUSH
4027: LD_INT 100
4029: PPUSH
4030: CALL 71401 0 5
// veh := CreateVehicle ;
4034: LD_ADDR_VAR 0 4
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4044: LD_VAR 0 4
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 49
4063: PPUSH
4064: LD_INT 88
4066: PPUSH
4067: LD_INT 0
4069: PPUSH
4070: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4074: LD_VAR 0 4
4078: PPUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 100
4084: PPUSH
4085: CALL_OW 290
// uc_side := 0 ;
4089: LD_ADDR_OWVAR 20
4093: PUSH
4094: LD_INT 0
4096: ST_TO_ADDR
// uc_nation := 0 ;
4097: LD_ADDR_OWVAR 21
4101: PUSH
4102: LD_INT 0
4104: ST_TO_ADDR
// for i = 1 to 4 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 4
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4150
// begin InitHc ;
4121: CALL_OW 19
// hc_class := class_apeman ;
4125: LD_ADDR_OWVAR 28
4129: PUSH
4130: LD_INT 12
4132: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4133: CALL_OW 44
4137: PPUSH
4138: LD_INT 13
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 49
// end ;
4148: GO 4118
4150: POP
4151: POP
// end ; end_of_file
4152: LD_VAR 0 1
4156: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4157: LD_INT 0
4159: PPUSH
4160: PPUSH
4161: PPUSH
4162: PPUSH
4163: PPUSH
// side := 8 ;
4164: LD_ADDR_VAR 0 3
4168: PUSH
4169: LD_INT 8
4171: ST_TO_ADDR
// uc_side := side ;
4172: LD_ADDR_OWVAR 20
4176: PUSH
4177: LD_VAR 0 3
4181: ST_TO_ADDR
// uc_nation := 2 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 2
4189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_INT 22
4197: PUSH
4198: LD_VAR 0 3
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: PUSH
4226: FOR_IN
4227: IFFALSE 4243
// SetBLevel ( i , 10 ) ;
4229: LD_VAR 0 2
4233: PPUSH
4234: LD_INT 10
4236: PPUSH
4237: CALL_OW 241
4241: GO 4226
4243: POP
4244: POP
// if KurtStatus then
4245: LD_EXP 3
4249: IFFALSE 4272
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4251: LD_ADDR_EXP 59
4255: PUSH
4256: LD_STRING Kurt
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: LD_STRING 
4264: PPUSH
4265: CALL 64286 0 3
4269: ST_TO_ADDR
4270: GO 4294
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4272: LD_ADDR_EXP 59
4276: PUSH
4277: LD_STRING AltKurt
4279: PPUSH
4280: LD_EXP 1
4284: NOT
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64286 0 3
4293: ST_TO_ADDR
// if not Kurt then
4294: LD_EXP 59
4298: NOT
4299: IFFALSE 4325
// begin InitHc ;
4301: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4305: LD_INT 1
4307: PPUSH
4308: LD_INT 10
4310: PPUSH
4311: CALL_OW 381
// Kurt := CreateHuman ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: CALL_OW 44
4324: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4325: LD_EXP 59
4329: PPUSH
4330: LD_INT 324
4332: PPUSH
4333: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4337: LD_ADDR_EXP 60
4341: PUSH
4342: LD_STRING Kozlov
4344: PPUSH
4345: LD_INT 0
4347: PPUSH
4348: LD_STRING 
4350: PPUSH
4351: CALL 64286 0 3
4355: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4356: LD_EXP 60
4360: PPUSH
4361: LD_INT 22
4363: PUSH
4364: LD_INT 8
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 23
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 30
4383: PUSH
4384: LD_INT 8
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: PUSH
4401: LD_INT 1
4403: ARRAY
4404: PPUSH
4405: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4409: LD_EXP 60
4413: PPUSH
4414: LD_INT 3
4416: PPUSH
4417: LD_INT 10
4419: PPUSH
4420: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4424: LD_ADDR_VAR 0 5
4428: PUSH
4429: LD_INT 22
4431: PUSH
4432: LD_VAR 0 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 30
4443: PUSH
4444: LD_INT 32
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 58
4453: PUSH
4454: EMPTY
4455: LIST
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ST_TO_ADDR
// for i = 1 to 10 do
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: DOUBLE
4473: LD_INT 1
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 10
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4553
// begin uc_nation := nation_nature ;
4483: LD_ADDR_OWVAR 21
4487: PUSH
4488: LD_INT 0
4490: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4491: LD_ADDR_OWVAR 28
4495: PUSH
4496: LD_INT 15
4498: ST_TO_ADDR
// hc_gallery :=  ;
4499: LD_ADDR_OWVAR 33
4503: PUSH
4504: LD_STRING 
4506: ST_TO_ADDR
// hc_name :=  ;
4507: LD_ADDR_OWVAR 26
4511: PUSH
4512: LD_STRING 
4514: ST_TO_ADDR
// un := CreateHuman ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 44
4524: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4525: LD_VAR 0 4
4529: PPUSH
4530: LD_VAR 0 5
4534: PUSH
4535: LD_VAR 0 5
4539: PUSH
4540: LD_VAR 0 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: CALL_OW 52
// end ;
4551: GO 4480
4553: POP
4554: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_STRING 12_kurt_squad
4562: PPUSH
4563: CALL_OW 31
4567: ST_TO_ADDR
// if tmp then
4568: LD_VAR 0 5
4572: IFFALSE 4606
// for i in tmp do
4574: LD_ADDR_VAR 0 2
4578: PUSH
4579: LD_VAR 0 5
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4604
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4587: LD_VAR 0 2
4591: PPUSH
4592: LD_INT 5
4594: PPUSH
4595: LD_INT 0
4597: PPUSH
4598: CALL_OW 49
4602: GO 4584
4604: POP
4605: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4606: LD_INT 324
4608: PPUSH
4609: LD_INT 5
4611: PPUSH
4612: LD_STRING 
4614: PPUSH
4615: LD_INT 8
4617: PUSH
4618: LD_INT 9
4620: PUSH
4621: LD_INT 10
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: LD_OWVAR 67
4633: ARRAY
4634: PPUSH
4635: LD_INT 3000
4637: PUSH
4638: LD_INT 500
4640: PUSH
4641: LD_INT 150
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: PPUSH
4649: LD_INT 16
4651: PUSH
4652: LD_INT 6
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 8
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: PPUSH
4667: CALL 74810 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4671: LD_ADDR_EXP 101
4675: PUSH
4676: LD_EXP 101
4680: PPUSH
4681: LD_INT 3
4683: PPUSH
4684: LD_INT 22
4686: PUSH
4687: LD_VAR 0 3
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: LD_INT 23
4698: PUSH
4699: LD_INT 2
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 3
4708: PUSH
4709: LD_INT 21
4711: PUSH
4712: LD_INT 2
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: LIST
4727: PPUSH
4728: CALL_OW 69
4732: PUSH
4733: LD_EXP 59
4737: DIFF
4738: PPUSH
4739: CALL_OW 1
4743: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 7
4749: PPUSH
4750: CALL_OW 383
// Friend := CreateHuman ;
4754: LD_ADDR_EXP 61
4758: PUSH
4759: CALL_OW 44
4763: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4764: LD_INT 14
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 29
4775: PPUSH
4776: LD_INT 100
4778: PPUSH
4779: CALL 71401 0 5
// powellBomb := CreateVehicle ;
4783: LD_ADDR_EXP 62
4787: PUSH
4788: CALL_OW 45
4792: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4793: LD_EXP 62
4797: PPUSH
4798: LD_INT 90
4800: PPUSH
4801: LD_INT 51
4803: PPUSH
4804: LD_INT 0
4806: PPUSH
4807: CALL_OW 48
// end ;
4811: LD_VAR 0 1
4815: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4816: LD_INT 0
4818: PPUSH
4819: PPUSH
4820: PPUSH
// if IsLive ( kozlov_fac ) then
4821: LD_INT 332
4823: PPUSH
4824: CALL_OW 300
4828: IFFALSE 4832
// exit ;
4830: GO 5399
// ComExitBuilding ( Kozlov ) ;
4832: LD_EXP 60
4836: PPUSH
4837: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4841: LD_EXP 60
4845: PPUSH
4846: CALL_OW 257
4850: PUSH
4851: LD_INT 2
4853: NONEQUAL
4854: IFFALSE 4889
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4856: LD_EXP 60
4860: PPUSH
4861: LD_INT 324
4863: PPUSH
4864: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4868: LD_EXP 60
4872: PPUSH
4873: LD_INT 2
4875: PPUSH
4876: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4880: LD_EXP 60
4884: PPUSH
4885: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4889: LD_EXP 60
4893: PPUSH
4894: LD_INT 2
4896: PPUSH
4897: LD_INT 93
4899: PPUSH
4900: LD_INT 32
4902: PPUSH
4903: LD_INT 3
4905: PPUSH
4906: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4910: LD_INT 35
4912: PPUSH
4913: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4917: LD_INT 22
4919: PUSH
4920: LD_INT 8
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: LD_INT 30
4929: PUSH
4930: LD_INT 3
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 23
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 57
4949: PUSH
4950: EMPTY
4951: LIST
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: PPUSH
4959: CALL_OW 69
4963: IFFALSE 4910
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4965: LD_ADDR_VAR 0 2
4969: PUSH
4970: LD_INT 22
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 30
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 23
4992: PUSH
4993: LD_INT 3
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 57
5002: PUSH
5003: EMPTY
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: PPUSH
5012: CALL_OW 69
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 23
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 30
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: NOT
5061: IFFALSE 5139
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5063: LD_EXP 60
5067: PPUSH
5068: LD_INT 21
5070: PPUSH
5071: LD_INT 97
5073: PPUSH
5074: LD_INT 36
5076: PPUSH
5077: LD_INT 5
5079: PPUSH
5080: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5091: LD_INT 22
5093: PUSH
5094: LD_INT 8
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 23
5103: PUSH
5104: LD_INT 3
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 30
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 57
5123: PUSH
5124: EMPTY
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: PPUSH
5133: CALL_OW 69
5137: IFFALSE 5084
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5139: LD_INT 22
5141: PUSH
5142: LD_INT 8
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 23
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 18
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: NOT
5179: IFFALSE 5257
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5181: LD_EXP 60
5185: PPUSH
5186: LD_INT 18
5188: PPUSH
5189: LD_INT 89
5191: PPUSH
5192: LD_INT 32
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5202: LD_INT 35
5204: PPUSH
5205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5209: LD_INT 22
5211: PUSH
5212: LD_INT 8
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 23
5221: PUSH
5222: LD_INT 3
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 30
5231: PUSH
5232: LD_INT 18
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: LD_INT 57
5241: PUSH
5242: EMPTY
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PPUSH
5251: CALL_OW 69
5255: IFFALSE 5202
// end ; lab := kozlov_lab ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: LD_INT 336
5264: ST_TO_ADDR
// if not lab then
5265: LD_VAR 0 3
5269: NOT
5270: IFFALSE 5274
// exit ;
5272: GO 5399
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5274: LD_EXP 60
5278: PPUSH
5279: LD_VAR 0 3
5283: PUSH
5284: LD_INT 1
5286: ARRAY
5287: PPUSH
5288: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5292: LD_EXP 60
5296: PPUSH
5297: LD_INT 4
5299: PPUSH
5300: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5304: LD_VAR 0 3
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_INT 25
5315: PPUSH
5316: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5320: LD_INT 35
5322: PPUSH
5323: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5327: LD_INT 25
5329: PPUSH
5330: LD_INT 8
5332: PPUSH
5333: CALL_OW 321
5337: PUSH
5338: LD_INT 2
5340: EQUAL
5341: IFFALSE 5320
// ComExitBuilding ( Kozlov ) ;
5343: LD_EXP 60
5347: PPUSH
5348: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5352: LD_EXP 60
5356: PPUSH
5357: LD_VAR 0 2
5361: PPUSH
5362: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5366: LD_EXP 60
5370: PPUSH
5371: LD_INT 3
5373: PPUSH
5374: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 23
5385: PPUSH
5386: LD_INT 3
5388: PPUSH
5389: LD_INT 1
5391: PPUSH
5392: LD_INT 48
5394: PPUSH
5395: CALL_OW 125
// end ;
5399: LD_VAR 0 1
5403: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5404: LD_EXP 22
5408: NOT
5409: PUSH
5410: LD_EXP 15
5414: PUSH
5415: LD_INT 6
5417: GREATEREQUAL
5418: AND
5419: IFFALSE 5500
5421: GO 5423
5423: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 3
5429: PPUSH
5430: CALL 58079 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5434: LD_INT 3
5436: PPUSH
5437: LD_INT 14
5439: PUSH
5440: LD_INT 1
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 28
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 14
5457: PUSH
5458: LD_INT 1
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 28
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 14
5475: PUSH
5476: LD_INT 1
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 28
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PPUSH
5496: CALL 57942 0 2
// end ;
5500: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5501: LD_EXP 22
5505: NOT
5506: PUSH
5507: LD_EXP 15
5511: PUSH
5512: LD_INT 6
5514: GREATEREQUAL
5515: AND
5516: PUSH
5517: LD_INT 3
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL 59360 0 2
5527: NOT
5528: AND
5529: IFFALSE 6369
5531: GO 5533
5533: DISABLE
5534: LD_INT 0
5536: PPUSH
5537: PPUSH
5538: PPUSH
// begin enable ;
5539: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 23
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 30
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: PPUSH
5575: CALL_OW 69
5579: NOT
5580: IFFALSE 5584
// exit ;
5582: GO 6369
// if Prob ( 40 ) then
5584: LD_INT 40
5586: PPUSH
5587: CALL_OW 13
5591: IFFALSE 5718
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 14
5598: PUSH
5599: LD_INT 1
5601: PUSH
5602: LD_INT 2
5604: PUSH
5605: LD_INT 28
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 14
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 28
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 14
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 28
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 14
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 28
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 14
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 28
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 14
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 26
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL 57942 0 2
// end else
5716: GO 5909
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5718: LD_INT 3
5720: PPUSH
5721: LD_INT 14
5723: PUSH
5724: LD_INT 1
5726: PUSH
5727: LD_INT 2
5729: PUSH
5730: LD_INT 27
5732: PUSH
5733: LD_INT 26
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 14
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 2
5764: PUSH
5765: LD_INT 27
5767: PUSH
5768: LD_INT 26
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: PUSH
5779: LD_OWVAR 67
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 14
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 29
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: LD_OWVAR 67
5818: ARRAY
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 13
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: LD_INT 29
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_OWVAR 67
5853: ARRAY
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 13
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 14
5881: PUSH
5882: LD_INT 1
5884: PUSH
5885: LD_INT 2
5887: PUSH
5888: LD_INT 26
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PPUSH
5905: CALL 57942 0 2
// end ; repeat wait ( 0 0$1 ) ;
5909: LD_INT 35
5911: PPUSH
5912: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5916: LD_INT 3
5918: PPUSH
5919: LD_INT 1
5921: PPUSH
5922: CALL 59360 0 2
5926: PUSH
5927: LD_INT 6
5929: GREATEREQUAL
5930: IFFALSE 5909
// wait ( 0 0$30 ) ;
5932: LD_INT 1050
5934: PPUSH
5935: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: LD_INT 3
5946: PPUSH
5947: LD_INT 1
5949: PPUSH
5950: CALL 59360 0 2
5954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5955: LD_ADDR_EXP 120
5959: PUSH
5960: LD_EXP 120
5964: PPUSH
5965: LD_INT 3
5967: PPUSH
5968: LD_EXP 120
5972: PUSH
5973: LD_INT 3
5975: ARRAY
5976: PUSH
5977: LD_VAR 0 2
5981: DIFF
5982: PPUSH
5983: CALL_OW 1
5987: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5988: LD_ADDR_VAR 0 3
5992: PUSH
5993: LD_INT 0
5995: PPUSH
5996: LD_INT 2
5998: PPUSH
5999: CALL_OW 12
6003: ST_TO_ADDR
// if target then
6004: LD_VAR 0 3
6008: IFFALSE 6136
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6010: LD_ADDR_VAR 0 2
6014: PUSH
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 24
6022: PUSH
6023: LD_INT 250
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// for i in tmp do
6035: LD_ADDR_VAR 0 1
6039: PUSH
6040: LD_VAR 0 2
6044: PUSH
6045: FOR_IN
6046: IFFALSE 6086
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6048: LD_VAR 0 1
6052: PPUSH
6053: LD_INT 89
6055: PPUSH
6056: LD_INT 71
6058: PPUSH
6059: CALL_OW 297
6063: PUSH
6064: LD_INT 9
6066: GREATER
6067: IFFALSE 6084
// ComMoveXY ( i , 89 , 71 ) ;
6069: LD_VAR 0 1
6073: PPUSH
6074: LD_INT 89
6076: PPUSH
6077: LD_INT 71
6079: PPUSH
6080: CALL_OW 111
6084: GO 6045
6086: POP
6087: POP
// wait ( 0 0$1 ) ;
6088: LD_INT 35
6090: PPUSH
6091: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6095: LD_VAR 0 2
6099: PPUSH
6100: LD_INT 92
6102: PUSH
6103: LD_INT 89
6105: PUSH
6106: LD_INT 71
6108: PUSH
6109: LD_INT 9
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PPUSH
6118: CALL_OW 72
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: LD_INT 1
6130: MINUS
6131: GREATEREQUAL
6132: IFFALSE 6010
// end else
6134: GO 6260
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6136: LD_ADDR_VAR 0 2
6140: PUSH
6141: LD_VAR 0 2
6145: PPUSH
6146: LD_INT 24
6148: PUSH
6149: LD_INT 250
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 72
6160: ST_TO_ADDR
// for i in tmp do
6161: LD_ADDR_VAR 0 1
6165: PUSH
6166: LD_VAR 0 2
6170: PUSH
6171: FOR_IN
6172: IFFALSE 6212
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 125
6181: PPUSH
6182: LD_INT 129
6184: PPUSH
6185: CALL_OW 297
6189: PUSH
6190: LD_INT 9
6192: GREATER
6193: IFFALSE 6210
// ComMoveXY ( i , 125 , 129 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 125
6202: PPUSH
6203: LD_INT 129
6205: PPUSH
6206: CALL_OW 111
6210: GO 6171
6212: POP
6213: POP
// wait ( 0 0$1 ) ;
6214: LD_INT 35
6216: PPUSH
6217: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6221: LD_VAR 0 2
6225: PPUSH
6226: LD_INT 92
6228: PUSH
6229: LD_INT 125
6231: PUSH
6232: LD_INT 129
6234: PUSH
6235: LD_INT 9
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: CALL_OW 72
6248: PUSH
6249: LD_VAR 0 2
6253: PUSH
6254: LD_INT 1
6256: MINUS
6257: GREATEREQUAL
6258: IFFALSE 6136
// end ; repeat wait ( 0 0$1 ) ;
6260: LD_INT 35
6262: PPUSH
6263: CALL_OW 67
// for i in tmp do
6267: LD_ADDR_VAR 0 1
6271: PUSH
6272: LD_VAR 0 2
6276: PUSH
6277: FOR_IN
6278: IFFALSE 6360
// begin if GetLives ( i ) > 251 then
6280: LD_VAR 0 1
6284: PPUSH
6285: CALL_OW 256
6289: PUSH
6290: LD_INT 251
6292: GREATER
6293: IFFALSE 6331
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6295: LD_VAR 0 1
6299: PPUSH
6300: LD_INT 81
6302: PUSH
6303: LD_INT 8
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PPUSH
6310: CALL_OW 69
6314: PPUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 74
6324: PPUSH
6325: CALL_OW 115
6329: GO 6358
// if IsDead ( i ) then
6331: LD_VAR 0 1
6335: PPUSH
6336: CALL_OW 301
6340: IFFALSE 6358
// tmp := tmp diff i ;
6342: LD_ADDR_VAR 0 2
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: LD_VAR 0 1
6356: DIFF
6357: ST_TO_ADDR
// end ;
6358: GO 6277
6360: POP
6361: POP
// until not tmp ;
6362: LD_VAR 0 2
6366: NOT
6367: IFFALSE 6260
// end ;
6369: PPOPN 3
6371: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6372: LD_EXP 22
6376: NOT
6377: PUSH
6378: LD_EXP 15
6382: PUSH
6383: LD_INT 6
6385: GREATEREQUAL
6386: AND
6387: PUSH
6388: LD_OWVAR 67
6392: PUSH
6393: LD_INT 1
6395: GREATER
6396: AND
6397: IFFALSE 6914
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
// begin enable ;
6407: ENABLE
// tmp := [ ] ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: EMPTY
6414: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: DOUBLE
6421: LD_INT 1
6423: DEC
6424: ST_TO_ADDR
6425: LD_INT 4
6427: PUSH
6428: LD_INT 6
6430: PUSH
6431: LD_INT 7
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: PUSH
6439: LD_OWVAR 67
6443: ARRAY
6444: PUSH
6445: FOR_TO
6446: IFFALSE 6606
// begin uc_side := 8 ;
6448: LD_ADDR_OWVAR 20
6452: PUSH
6453: LD_INT 8
6455: ST_TO_ADDR
// uc_nation := 2 ;
6456: LD_ADDR_OWVAR 21
6460: PUSH
6461: LD_INT 2
6463: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6464: LD_INT 13
6466: PUSH
6467: LD_INT 14
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 1
6488: PPUSH
6489: LD_INT 5
6491: PPUSH
6492: LD_INT 27
6494: PUSH
6495: LD_INT 28
6497: PUSH
6498: LD_INT 26
6500: PUSH
6501: LD_INT 25
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 4
6515: PPUSH
6516: CALL_OW 12
6520: ARRAY
6521: PPUSH
6522: LD_INT 88
6524: PPUSH
6525: CALL 71401 0 5
// un := CreateVehicle ;
6529: LD_ADDR_VAR 0 2
6533: PUSH
6534: CALL_OW 45
6538: ST_TO_ADDR
// tmp := tmp ^ un ;
6539: LD_ADDR_VAR 0 3
6543: PUSH
6544: LD_VAR 0 3
6548: PUSH
6549: LD_VAR 0 2
6553: ADD
6554: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6555: LD_VAR 0 2
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6567: LD_VAR 0 2
6571: PPUSH
6572: LD_INT 30
6574: PPUSH
6575: LD_INT 0
6577: PPUSH
6578: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6582: LD_VAR 0 2
6586: PPUSH
6587: LD_INT 16
6589: PPUSH
6590: LD_INT 11
6592: PPUSH
6593: CALL_OW 111
// wait ( 0 0$2 ) ;
6597: LD_INT 70
6599: PPUSH
6600: CALL_OW 67
// end ;
6604: GO 6445
6606: POP
6607: POP
// for i = 1 to Difficulty do
6608: LD_ADDR_VAR 0 1
6612: PUSH
6613: DOUBLE
6614: LD_INT 1
6616: DEC
6617: ST_TO_ADDR
6618: LD_OWVAR 67
6622: PUSH
6623: FOR_TO
6624: IFFALSE 6749
// begin uc_side := 8 ;
6626: LD_ADDR_OWVAR 20
6630: PUSH
6631: LD_INT 8
6633: ST_TO_ADDR
// uc_nation := 2 ;
6634: LD_ADDR_OWVAR 21
6638: PUSH
6639: LD_INT 2
6641: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6642: LD_INT 0
6644: PPUSH
6645: LD_INT 8
6647: PPUSH
6648: LD_INT 8
6650: PUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 9
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_OWVAR 67
6666: ARRAY
6667: PPUSH
6668: CALL_OW 380
// un := CreateHuman ;
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: CALL_OW 44
6681: ST_TO_ADDR
// tmp := tmp ^ un ;
6682: LD_ADDR_VAR 0 3
6686: PUSH
6687: LD_VAR 0 3
6691: PUSH
6692: LD_VAR 0 2
6696: ADD
6697: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6698: LD_VAR 0 2
6702: PPUSH
6703: LD_INT 3
6705: PPUSH
6706: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6710: LD_VAR 0 2
6714: PPUSH
6715: LD_INT 30
6717: PPUSH
6718: LD_INT 0
6720: PPUSH
6721: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6725: LD_VAR 0 2
6729: PPUSH
6730: LD_INT 16
6732: PPUSH
6733: LD_INT 11
6735: PPUSH
6736: CALL_OW 111
// wait ( 0 0$2 ) ;
6740: LD_INT 70
6742: PPUSH
6743: CALL_OW 67
// end ;
6747: GO 6623
6749: POP
6750: POP
// repeat wait ( 0 0$1 ) ;
6751: LD_INT 35
6753: PPUSH
6754: CALL_OW 67
// for i in tmp do
6758: LD_ADDR_VAR 0 1
6762: PUSH
6763: LD_VAR 0 3
6767: PUSH
6768: FOR_IN
6769: IFFALSE 6905
// begin if GetLives ( i ) > 250 then
6771: LD_VAR 0 1
6775: PPUSH
6776: CALL_OW 256
6780: PUSH
6781: LD_INT 250
6783: GREATER
6784: IFFALSE 6876
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6786: LD_INT 81
6788: PUSH
6789: LD_INT 8
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 91
6798: PUSH
6799: LD_VAR 0 1
6803: PUSH
6804: LD_INT 10
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: NOT
6821: IFFALSE 6840
// ComAgressiveMove ( i , 67 , 110 ) else
6823: LD_VAR 0 1
6827: PPUSH
6828: LD_INT 67
6830: PPUSH
6831: LD_INT 110
6833: PPUSH
6834: CALL_OW 114
6838: GO 6874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: LD_INT 81
6847: PUSH
6848: LD_INT 8
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: PPUSH
6860: LD_VAR 0 1
6864: PPUSH
6865: CALL_OW 74
6869: PPUSH
6870: CALL_OW 115
// end else
6874: GO 6903
// if IsDead ( i ) then
6876: LD_VAR 0 1
6880: PPUSH
6881: CALL_OW 301
6885: IFFALSE 6903
// tmp := tmp diff i ;
6887: LD_ADDR_VAR 0 3
6891: PUSH
6892: LD_VAR 0 3
6896: PUSH
6897: LD_VAR 0 1
6901: DIFF
6902: ST_TO_ADDR
// end ;
6903: GO 6768
6905: POP
6906: POP
// until not tmp ;
6907: LD_VAR 0 3
6911: NOT
6912: IFFALSE 6751
// end ; end_of_file
6914: PPOPN 3
6916: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
// side := 3 ;
6928: LD_ADDR_VAR 0 6
6932: PUSH
6933: LD_INT 3
6935: ST_TO_ADDR
// uc_side := side ;
6936: LD_ADDR_OWVAR 20
6940: PUSH
6941: LD_VAR 0 6
6945: ST_TO_ADDR
// uc_nation := 3 ;
6946: LD_ADDR_OWVAR 21
6950: PUSH
6951: LD_INT 3
6953: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_VAR 0 6
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 21
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: FOR_IN
6991: IFFALSE 7007
// SetBLevel ( i , 10 ) ;
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_INT 10
7000: PPUSH
7001: CALL_OW 241
7005: GO 6990
7007: POP
7008: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7009: LD_ADDR_VAR 0 9
7013: PUSH
7014: LD_INT 22
7016: PUSH
7017: LD_VAR 0 6
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 30
7028: PUSH
7029: LD_INT 34
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PPUSH
7040: CALL_OW 69
7044: ST_TO_ADDR
// if teleport then
7045: LD_VAR 0 9
7049: IFFALSE 7070
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7051: LD_VAR 0 9
7055: PUSH
7056: LD_INT 1
7058: ARRAY
7059: PPUSH
7060: LD_INT 123
7062: PPUSH
7063: LD_INT 122
7065: PPUSH
7066: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7070: LD_ADDR_EXP 63
7074: PUSH
7075: LD_STRING Platonov
7077: PPUSH
7078: CALL_OW 25
7082: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7083: LD_ADDR_EXP 64
7087: PUSH
7088: LD_STRING Kovalyuk
7090: PPUSH
7091: CALL_OW 25
7095: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7096: LD_ADDR_EXP 66
7100: PUSH
7101: LD_STRING Yakotich
7103: PPUSH
7104: CALL_OW 25
7108: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7109: LD_ADDR_EXP 65
7113: PUSH
7114: LD_STRING Bystrov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7122: LD_ADDR_EXP 67
7126: PUSH
7127: LD_STRING Gleb
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7135: LD_STRING 03_Cornel
7137: PPUSH
7138: CALL_OW 28
7142: IFFALSE 7190
// begin Bierezov := NewCharacter ( Mikhail ) ;
7144: LD_ADDR_EXP 68
7148: PUSH
7149: LD_STRING Mikhail
7151: PPUSH
7152: CALL_OW 25
7156: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7157: LD_EXP 68
7161: PPUSH
7162: LD_INT 197
7164: PPUSH
7165: LD_INT 111
7167: PPUSH
7168: LD_INT 9
7170: PPUSH
7171: LD_INT 0
7173: PPUSH
7174: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7178: LD_EXP 68
7182: PPUSH
7183: LD_INT 3
7185: PPUSH
7186: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7190: LD_EXP 63
7194: PPUSH
7195: LD_INT 126
7197: PPUSH
7198: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 134
7209: PPUSH
7210: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7214: LD_EXP 66
7218: PPUSH
7219: LD_INT 197
7221: PPUSH
7222: LD_INT 111
7224: PPUSH
7225: LD_INT 9
7227: PPUSH
7228: LD_INT 0
7230: PPUSH
7231: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 197
7242: PPUSH
7243: LD_INT 111
7245: PPUSH
7246: LD_INT 9
7248: PPUSH
7249: LD_INT 0
7251: PPUSH
7252: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7256: LD_EXP 67
7260: PPUSH
7261: LD_INT 197
7263: PPUSH
7264: LD_INT 111
7266: PPUSH
7267: LD_INT 9
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7277: LD_ADDR_VAR 0 5
7281: PUSH
7282: LD_INT 126
7284: PPUSH
7285: LD_INT 4
7287: PPUSH
7288: LD_STRING zhukov
7290: PPUSH
7291: LD_INT 9
7293: PUSH
7294: LD_INT 10
7296: PUSH
7297: LD_INT 10
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: LIST
7304: PUSH
7305: LD_OWVAR 67
7309: ARRAY
7310: PPUSH
7311: LD_INT 90000
7313: PUSH
7314: LD_INT 1000
7316: PUSH
7317: LD_INT 300
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: PPUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 8
7330: PUSH
7331: LD_INT 13
7333: PUSH
7334: LD_INT 8
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL 74810 0 6
7347: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7348: LD_ADDR_VAR 0 4
7352: PUSH
7353: LD_INT 267
7355: PPUSH
7356: CALL_OW 274
7360: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7361: LD_VAR 0 4
7365: PPUSH
7366: LD_INT 1
7368: PPUSH
7369: LD_INT 5000
7371: PPUSH
7372: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7376: LD_VAR 0 4
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: LD_INT 200
7386: PPUSH
7387: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7391: LD_VAR 0 4
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 200
7401: PPUSH
7402: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7406: LD_ADDR_EXP 101
7410: PUSH
7411: LD_EXP 101
7415: PPUSH
7416: LD_INT 2
7418: PPUSH
7419: LD_VAR 0 5
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_VAR 0 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 3
7438: PUSH
7439: LD_INT 21
7441: PUSH
7442: LD_INT 2
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 69
7461: UNION
7462: PUSH
7463: LD_EXP 63
7467: DIFF
7468: PPUSH
7469: CALL_OW 1
7473: ST_TO_ADDR
// behemoths := [ ] ;
7474: LD_ADDR_EXP 71
7478: PUSH
7479: EMPTY
7480: ST_TO_ADDR
// behemothBuilders := [ ] ;
7481: LD_ADDR_EXP 72
7485: PUSH
7486: EMPTY
7487: ST_TO_ADDR
// if Kovalyuk then
7488: LD_EXP 64
7492: IFFALSE 7514
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7494: LD_ADDR_EXP 72
7498: PUSH
7499: LD_EXP 72
7503: PPUSH
7504: LD_EXP 64
7508: PPUSH
7509: CALL 107149 0 2
7513: ST_TO_ADDR
// j := 3 ;
7514: LD_ADDR_VAR 0 3
7518: PUSH
7519: LD_INT 3
7521: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 3
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 69
7555: PUSH
7556: LD_EXP 64
7560: DIFF
7561: PUSH
7562: FOR_IN
7563: IFFALSE 7613
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7565: LD_ADDR_EXP 72
7569: PUSH
7570: LD_EXP 72
7574: PPUSH
7575: LD_VAR 0 2
7579: PPUSH
7580: CALL 107149 0 2
7584: ST_TO_ADDR
// j := j - 1 ;
7585: LD_ADDR_VAR 0 3
7589: PUSH
7590: LD_VAR 0 3
7594: PUSH
7595: LD_INT 1
7597: MINUS
7598: ST_TO_ADDR
// if j = 0 then
7599: LD_VAR 0 3
7603: PUSH
7604: LD_INT 0
7606: EQUAL
7607: IFFALSE 7611
// break ;
7609: GO 7613
// end ;
7611: GO 7562
7613: POP
7614: POP
// end ;
7615: LD_VAR 0 1
7619: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 209
7634: PUSH
7635: LD_INT 149
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 219
7644: PUSH
7645: LD_INT 154
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: PUSH
7652: LD_INT 223
7654: PUSH
7655: LD_INT 149
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 232
7664: PUSH
7665: LD_INT 155
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: ST_TO_ADDR
// if not behemothBuilders then
7678: LD_EXP 72
7682: NOT
7683: IFFALSE 7687
// exit ;
7685: GO 7791
// j := 1 ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i in behemothBuilders do
7695: LD_ADDR_VAR 0 2
7699: PUSH
7700: LD_EXP 72
7704: PUSH
7705: FOR_IN
7706: IFFALSE 7789
// begin if IsInUnit ( i ) then
7708: LD_VAR 0 2
7712: PPUSH
7713: CALL_OW 310
7717: IFFALSE 7728
// ComExitBuilding ( i ) ;
7719: LD_VAR 0 2
7723: PPUSH
7724: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7728: LD_VAR 0 2
7732: PPUSH
7733: LD_INT 37
7735: PPUSH
7736: LD_VAR 0 4
7740: PUSH
7741: LD_VAR 0 3
7745: ARRAY
7746: PUSH
7747: LD_INT 1
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 3
7760: ARRAY
7761: PUSH
7762: LD_INT 2
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 230
// j := j + 1 ;
7773: LD_ADDR_VAR 0 3
7777: PUSH
7778: LD_VAR 0 3
7782: PUSH
7783: LD_INT 1
7785: PLUS
7786: ST_TO_ADDR
// end ;
7787: GO 7705
7789: POP
7790: POP
// end ;
7791: LD_VAR 0 1
7795: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7796: LD_INT 24
7798: PPUSH
7799: LD_INT 30
7801: PUSH
7802: LD_INT 37
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 70
7813: IFFALSE 7826
7815: GO 7817
7817: DISABLE
// behemothUnderConstruct := true ;
7818: LD_ADDR_EXP 26
7822: PUSH
7823: LD_INT 1
7825: ST_TO_ADDR
7826: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7827: LD_INT 3
7829: PPUSH
7830: CALL 107197 0 1
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 3
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: LD_INT 30
7847: PUSH
7848: LD_INT 37
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: PPUSH
7859: CALL_OW 69
7863: NOT
7864: AND
7865: IFFALSE 8051
7867: GO 7869
7869: DISABLE
7870: LD_INT 0
7872: PPUSH
7873: PPUSH
// begin enable ;
7874: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7875: LD_ADDR_VAR 0 2
7879: PUSH
7880: LD_INT 3
7882: PPUSH
7883: CALL 107197 0 1
7887: ST_TO_ADDR
// for i in tmp do
7888: LD_ADDR_VAR 0 1
7892: PUSH
7893: LD_VAR 0 2
7897: PUSH
7898: FOR_IN
7899: IFFALSE 8049
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7901: LD_VAR 0 1
7905: PPUSH
7906: LD_INT 9
7908: PPUSH
7909: CALL_OW 308
7913: PUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 110
7923: PUSH
7924: LD_INT 2
7926: EQUAL
7927: NOT
7928: AND
7929: IFFALSE 7943
// SetTag ( i , 2 ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 2
7938: PPUSH
7939: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7943: LD_INT 81
7945: PUSH
7946: LD_INT 3
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 91
7955: PUSH
7956: LD_VAR 0 1
7960: PUSH
7961: LD_INT 12
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 69
7977: NOT
7978: PUSH
7979: LD_VAR 0 1
7983: PPUSH
7984: CALL_OW 110
7988: PUSH
7989: LD_INT 2
7991: EQUAL
7992: NOT
7993: AND
7994: IFFALSE 8013
// ComAgressiveMove ( i , 64 , 93 ) else
7996: LD_VAR 0 1
8000: PPUSH
8001: LD_INT 64
8003: PPUSH
8004: LD_INT 93
8006: PPUSH
8007: CALL_OW 114
8011: GO 8047
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 3
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
// end ;
8047: GO 7898
8049: POP
8050: POP
// end ;
8051: PPOPN 2
8053: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8054: LD_INT 0
8056: PPUSH
8057: PPUSH
8058: PPUSH
// result := [ ] ;
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: EMPTY
8065: ST_TO_ADDR
// uc_side := 6 ;
8066: LD_ADDR_OWVAR 20
8070: PUSH
8071: LD_INT 6
8073: ST_TO_ADDR
// uc_nation := 3 ;
8074: LD_ADDR_OWVAR 21
8078: PUSH
8079: LD_INT 3
8081: ST_TO_ADDR
// case strength of 1 :
8082: LD_VAR 0 1
8086: PUSH
8087: LD_INT 1
8089: DOUBLE
8090: EQUAL
8091: IFTRUE 8095
8093: GO 8233
8095: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 4
8108: PUSH
8109: LD_INT 5
8111: PUSH
8112: LD_INT 6
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PUSH
8126: FOR_TO
8127: IFFALSE 8229
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8129: LD_INT 22
8131: PUSH
8132: LD_INT 24
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_VAR 0 3
8143: PUSH
8144: LD_INT 2
8146: MOD
8147: PUSH
8148: LD_INT 1
8150: PLUS
8151: ARRAY
8152: PPUSH
8153: LD_INT 1
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 1
8165: PPUSH
8166: LD_INT 2
8168: PPUSH
8169: CALL_OW 12
8173: ARRAY
8174: PPUSH
8175: LD_INT 3
8177: PPUSH
8178: LD_INT 43
8180: PUSH
8181: LD_INT 44
8183: PUSH
8184: LD_INT 45
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: LIST
8191: PUSH
8192: LD_INT 1
8194: PPUSH
8195: LD_INT 3
8197: PPUSH
8198: CALL_OW 12
8202: ARRAY
8203: PPUSH
8204: LD_INT 80
8206: PPUSH
8207: CALL 71401 0 5
// result := result union CreateVehicle ;
8211: LD_ADDR_VAR 0 2
8215: PUSH
8216: LD_VAR 0 2
8220: PUSH
8221: CALL_OW 45
8225: UNION
8226: ST_TO_ADDR
// end ;
8227: GO 8126
8229: POP
8230: POP
// end ; 2 :
8231: GO 9177
8233: LD_INT 2
8235: DOUBLE
8236: EQUAL
8237: IFTRUE 8241
8239: GO 8397
8241: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: DOUBLE
8248: LD_INT 1
8250: DEC
8251: ST_TO_ADDR
8252: LD_INT 5
8254: PUSH
8255: LD_INT 6
8257: PUSH
8258: LD_INT 7
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PUSH
8266: LD_OWVAR 67
8270: ARRAY
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8393
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8275: LD_INT 22
8277: PUSH
8278: LD_INT 24
8280: PUSH
8281: LD_INT 24
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: LIST
8288: PUSH
8289: LD_VAR 0 3
8293: PUSH
8294: LD_INT 3
8296: MOD
8297: PUSH
8298: LD_INT 1
8300: PLUS
8301: ARRAY
8302: PPUSH
8303: LD_INT 1
8305: PUSH
8306: LD_INT 3
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PUSH
8313: LD_INT 1
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: CALL_OW 12
8323: ARRAY
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 43
8330: PUSH
8331: LD_INT 44
8333: PUSH
8334: LD_INT 45
8336: PUSH
8337: LD_INT 44
8339: PUSH
8340: LD_INT 46
8342: PUSH
8343: LD_INT 46
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: LIST
8350: LIST
8351: LIST
8352: LIST
8353: PUSH
8354: LD_VAR 0 3
8358: PUSH
8359: LD_INT 6
8361: MOD
8362: PUSH
8363: LD_INT 1
8365: PLUS
8366: ARRAY
8367: PPUSH
8368: LD_INT 80
8370: PPUSH
8371: CALL 71401 0 5
// result := result union CreateVehicle ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PUSH
8385: CALL_OW 45
8389: UNION
8390: ST_TO_ADDR
// end ;
8391: GO 8272
8393: POP
8394: POP
// end ; 3 :
8395: GO 9177
8397: LD_INT 3
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8561
8405: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 5
8418: PUSH
8419: LD_INT 7
8421: PUSH
8422: LD_INT 8
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: LIST
8429: PUSH
8430: LD_OWVAR 67
8434: ARRAY
8435: PUSH
8436: FOR_TO
8437: IFFALSE 8557
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8439: LD_INT 22
8441: PUSH
8442: LD_INT 24
8444: PUSH
8445: LD_INT 24
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 3
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 47
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: LD_INT 45
8503: PUSH
8504: LD_INT 46
8506: PUSH
8507: LD_INT 46
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_VAR 0 3
8522: PUSH
8523: LD_INT 6
8525: MOD
8526: PUSH
8527: LD_INT 1
8529: PLUS
8530: ARRAY
8531: PPUSH
8532: LD_INT 80
8534: PPUSH
8535: CALL 71401 0 5
// result := result union CreateVehicle ;
8539: LD_ADDR_VAR 0 2
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: CALL_OW 45
8553: UNION
8554: ST_TO_ADDR
// end ;
8555: GO 8436
8557: POP
8558: POP
// end ; 4 :
8559: GO 9177
8561: LD_INT 4
8563: DOUBLE
8564: EQUAL
8565: IFTRUE 8569
8567: GO 9176
8569: POP
// begin uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: DOUBLE
8584: LD_INT 1
8586: DEC
8587: ST_TO_ADDR
8588: LD_INT 6
8590: PUSH
8591: LD_INT 8
8593: PUSH
8594: LD_INT 9
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: LIST
8601: PUSH
8602: LD_OWVAR 67
8606: ARRAY
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8729
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8611: LD_INT 22
8613: PUSH
8614: LD_INT 24
8616: PUSH
8617: LD_INT 24
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: PUSH
8625: LD_VAR 0 3
8629: PUSH
8630: LD_INT 3
8632: MOD
8633: PUSH
8634: LD_INT 1
8636: PLUS
8637: ARRAY
8638: PPUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 1
8651: PPUSH
8652: LD_INT 2
8654: PPUSH
8655: CALL_OW 12
8659: ARRAY
8660: PPUSH
8661: LD_INT 3
8663: PPUSH
8664: LD_INT 45
8666: PUSH
8667: LD_INT 47
8669: PUSH
8670: LD_INT 47
8672: PUSH
8673: LD_INT 45
8675: PUSH
8676: LD_INT 46
8678: PUSH
8679: LD_INT 46
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 6
8697: MOD
8698: PUSH
8699: LD_INT 1
8701: PLUS
8702: ARRAY
8703: PPUSH
8704: LD_INT 80
8706: PPUSH
8707: CALL 71401 0 5
// result := result union CreateVehicle ;
8711: LD_ADDR_VAR 0 2
8715: PUSH
8716: LD_VAR 0 2
8720: PUSH
8721: CALL_OW 45
8725: UNION
8726: ST_TO_ADDR
// end ;
8727: GO 8608
8729: POP
8730: POP
// if not KappaStatus then
8731: LD_EXP 2
8735: NOT
8736: IFFALSE 8971
// begin uc_nation := 1 ;
8738: LD_ADDR_OWVAR 21
8742: PUSH
8743: LD_INT 1
8745: ST_TO_ADDR
// for i = 1 to 3 do
8746: LD_ADDR_VAR 0 3
8750: PUSH
8751: DOUBLE
8752: LD_INT 1
8754: DEC
8755: ST_TO_ADDR
8756: LD_INT 3
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8896
// begin j := rand ( 0 , 1 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 0
8769: PPUSH
8770: LD_INT 1
8772: PPUSH
8773: CALL_OW 12
8777: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8778: LD_INT 3
8780: PUSH
8781: LD_INT 5
8783: PUSH
8784: LD_INT 5
8786: PUSH
8787: LD_INT 4
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: LIST
8794: LIST
8795: PUSH
8796: LD_VAR 0 4
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 3
8806: PPUSH
8807: CALL_OW 12
8811: PLUS
8812: ARRAY
8813: PPUSH
8814: LD_INT 1
8816: PUSH
8817: LD_INT 3
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 2
8829: PPUSH
8830: CALL_OW 12
8834: ARRAY
8835: PPUSH
8836: LD_INT 3
8838: PPUSH
8839: LD_INT 9
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 6
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_VAR 0 4
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 2
8863: PPUSH
8864: CALL_OW 12
8868: PLUS
8869: ARRAY
8870: PPUSH
8871: LD_INT 85
8873: PPUSH
8874: CALL 71401 0 5
// result := result union CreateVehicle ;
8878: LD_ADDR_VAR 0 2
8882: PUSH
8883: LD_VAR 0 2
8887: PUSH
8888: CALL_OW 45
8892: UNION
8893: ST_TO_ADDR
// end ;
8894: GO 8759
8896: POP
8897: POP
// if vsevolodFirstAttack then
8898: LD_EXP 24
8902: IFFALSE 8969
// begin vsevolodFirstAttack := false ;
8904: LD_ADDR_EXP 24
8908: PUSH
8909: LD_INT 0
8911: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8912: LD_INT 5
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: LD_INT 1
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: LD_INT 100
8926: PPUSH
8927: CALL 71401 0 5
// sewiVeh := CreateVehicle ;
8931: LD_ADDR_EXP 70
8935: PUSH
8936: CALL_OW 45
8940: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8941: LD_EXP 70
8945: PPUSH
8946: LD_INT 1
8948: PPUSH
8949: CALL_OW 242
// result := result union sewiVeh ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_EXP 70
8967: UNION
8968: ST_TO_ADDR
// end ; end else
8969: GO 9174
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9174
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// uc_nation := 3 ;
8985: LD_ADDR_OWVAR 21
8989: PUSH
8990: LD_INT 3
8992: ST_TO_ADDR
// for i = 1 to 3 do
8993: LD_ADDR_VAR 0 3
8997: PUSH
8998: DOUBLE
8999: LD_INT 1
9001: DEC
9002: ST_TO_ADDR
9003: LD_INT 3
9005: PUSH
9006: FOR_TO
9007: IFFALSE 9115
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9009: LD_INT 22
9011: PUSH
9012: LD_INT 24
9014: PUSH
9015: LD_INT 24
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 3
9030: MOD
9031: PUSH
9032: LD_INT 1
9034: PLUS
9035: ARRAY
9036: PPUSH
9037: LD_INT 1
9039: PUSH
9040: LD_INT 3
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 2
9052: PPUSH
9053: CALL_OW 12
9057: ARRAY
9058: PPUSH
9059: LD_INT 3
9061: PPUSH
9062: LD_INT 45
9064: PUSH
9065: LD_INT 47
9067: PUSH
9068: LD_INT 47
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_VAR 0 3
9080: PUSH
9081: LD_INT 3
9083: MOD
9084: PUSH
9085: LD_INT 1
9087: PLUS
9088: ARRAY
9089: PPUSH
9090: LD_INT 80
9092: PPUSH
9093: CALL 71401 0 5
// result := result union CreateVehicle ;
9097: LD_ADDR_VAR 0 2
9101: PUSH
9102: LD_VAR 0 2
9106: PUSH
9107: CALL_OW 45
9111: UNION
9112: ST_TO_ADDR
// end ;
9113: GO 9006
9115: POP
9116: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9117: LD_INT 24
9119: PPUSH
9120: LD_INT 3
9122: PPUSH
9123: LD_INT 1
9125: PPUSH
9126: LD_INT 47
9128: PPUSH
9129: LD_INT 100
9131: PPUSH
9132: CALL 71401 0 5
// sewiVeh := CreateVehicle ;
9136: LD_ADDR_EXP 70
9140: PUSH
9141: CALL_OW 45
9145: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9146: LD_EXP 70
9150: PPUSH
9151: LD_INT 1
9153: PPUSH
9154: CALL_OW 242
// result := result union sewiVeh ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_EXP 70
9172: UNION
9173: ST_TO_ADDR
// end ; end ; end ;
9174: GO 9177
9176: POP
// end ;
9177: LD_VAR 0 2
9181: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9182: LD_EXP 16
9186: IFFALSE 9944
9188: GO 9190
9190: DISABLE
9191: LD_INT 0
9193: PPUSH
9194: PPUSH
9195: PPUSH
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9199: LD_ADDR_VAR 0 4
9203: PUSH
9204: LD_INT 11
9206: PUSH
9207: LD_INT 12
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: LD_INT 9100
9221: PUSH
9222: LD_INT 7350
9224: PUSH
9225: LD_INT 6650
9227: PUSH
9228: EMPTY
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_OWVAR 67
9237: ARRAY
9238: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9239: LD_ADDR_VAR 0 6
9243: PUSH
9244: LD_INT 70
9246: PUSH
9247: LD_INT 118
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 78
9256: PUSH
9257: LD_INT 31
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: ST_TO_ADDR
// repeat if missionStage = 2 then
9268: LD_EXP 15
9272: PUSH
9273: LD_INT 2
9275: EQUAL
9276: IFFALSE 9287
// wait ( 1 1$30 ) else
9278: LD_INT 3150
9280: PPUSH
9281: CALL_OW 67
9285: GO 9296
// wait ( time ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: CALL_OW 67
// if missionStage = 6 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 6
9303: EQUAL
9304: IFFALSE 9332
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9306: LD_INT 51
9308: PPUSH
9309: LD_INT 6
9311: PPUSH
9312: LD_INT 2
9314: PPUSH
9315: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9319: LD_INT 57
9321: PPUSH
9322: LD_INT 6
9324: PPUSH
9325: LD_INT 2
9327: PPUSH
9328: CALL_OW 322
// end ; if missionStage = 8 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 8
9339: EQUAL
9340: IFFALSE 9368
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9342: LD_INT 52
9344: PPUSH
9345: LD_INT 6
9347: PPUSH
9348: LD_INT 2
9350: PPUSH
9351: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9355: LD_INT 58
9357: PPUSH
9358: LD_INT 6
9360: PPUSH
9361: LD_INT 2
9363: PPUSH
9364: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9368: LD_EXP 15
9372: PUSH
9373: LD_INT 10
9375: EQUAL
9376: PUSH
9377: LD_OWVAR 67
9381: PUSH
9382: LD_INT 1
9384: GREATER
9385: AND
9386: IFFALSE 9414
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9388: LD_INT 53
9390: PPUSH
9391: LD_INT 6
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9401: LD_INT 59
9403: PPUSH
9404: LD_INT 6
9406: PPUSH
9407: LD_INT 2
9409: PPUSH
9410: CALL_OW 322
// end ; if activeAttacks then
9414: LD_EXP 16
9418: IFFALSE 9938
// begin if missionStage = 2 then
9420: LD_EXP 15
9424: PUSH
9425: LD_INT 2
9427: EQUAL
9428: IFFALSE 9438
// strength := 1 ;
9430: LD_ADDR_VAR 0 5
9434: PUSH
9435: LD_INT 1
9437: ST_TO_ADDR
// if missionStage > 2 then
9438: LD_EXP 15
9442: PUSH
9443: LD_INT 2
9445: GREATER
9446: IFFALSE 9456
// strength := 2 ;
9448: LD_ADDR_VAR 0 5
9452: PUSH
9453: LD_INT 2
9455: ST_TO_ADDR
// if missionStage > 6 then
9456: LD_EXP 15
9460: PUSH
9461: LD_INT 6
9463: GREATER
9464: IFFALSE 9474
// strength := 3 ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 3
9473: ST_TO_ADDR
// if missionStage > 10 then
9474: LD_EXP 15
9478: PUSH
9479: LD_INT 10
9481: GREATER
9482: IFFALSE 9492
// strength := 4 ;
9484: LD_ADDR_VAR 0 5
9488: PUSH
9489: LD_INT 4
9491: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9492: LD_ADDR_VAR 0 2
9496: PUSH
9497: LD_VAR 0 5
9501: PPUSH
9502: CALL 8054 0 1
9506: ST_TO_ADDR
// for i in tmp do
9507: LD_ADDR_VAR 0 1
9511: PUSH
9512: LD_VAR 0 2
9516: PUSH
9517: FOR_IN
9518: IFFALSE 9618
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9520: LD_VAR 0 1
9524: PPUSH
9525: LD_VAR 0 4
9529: PUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 2
9535: PPUSH
9536: CALL_OW 12
9540: ARRAY
9541: PPUSH
9542: LD_INT 0
9544: PPUSH
9545: CALL_OW 49
// if i = sewiVeh then
9549: LD_VAR 0 1
9553: PUSH
9554: LD_EXP 70
9558: EQUAL
9559: IFFALSE 9594
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9561: LD_ADDR_EXP 69
9565: PUSH
9566: LD_STRING Vsevolod
9568: PPUSH
9569: LD_INT 0
9571: PPUSH
9572: LD_STRING 
9574: PPUSH
9575: CALL 64286 0 3
9579: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9580: LD_EXP 69
9584: PPUSH
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9594: LD_VAR 0 1
9598: PPUSH
9599: LD_INT 111
9601: PPUSH
9602: LD_INT 197
9604: PPUSH
9605: CALL_OW 111
// wait ( 0 0$2 ) ;
9609: LD_INT 70
9611: PPUSH
9612: CALL_OW 67
// end ;
9616: GO 9517
9618: POP
9619: POP
// repeat wait ( 0 0$1 ) ;
9620: LD_INT 35
9622: PPUSH
9623: CALL_OW 67
// for i in tmp do
9627: LD_ADDR_VAR 0 1
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: FOR_IN
9638: IFFALSE 9919
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9640: LD_INT 81
9642: PUSH
9643: LD_INT 6
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 91
9652: PUSH
9653: LD_VAR 0 1
9657: PUSH
9658: LD_INT 12
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 69
9674: IFFALSE 9732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_INT 81
9683: PUSH
9684: LD_INT 6
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 91
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 12
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PPUSH
9711: CALL_OW 69
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 74
9725: PPUSH
9726: CALL_OW 115
9730: GO 9917
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9732: LD_INT 9
9734: PPUSH
9735: LD_INT 81
9737: PUSH
9738: LD_INT 6
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PPUSH
9745: CALL_OW 70
9749: IFFALSE 9883
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9751: LD_VAR 0 1
9755: PPUSH
9756: LD_VAR 0 6
9760: PUSH
9761: LD_INT 1
9763: ARRAY
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 2
9780: ARRAY
9781: PPUSH
9782: CALL_OW 297
9786: PUSH
9787: LD_INT 10
9789: GREATER
9790: PUSH
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: CALL_OW 308
9803: NOT
9804: AND
9805: IFFALSE 9844
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 6
9816: PUSH
9817: LD_INT 1
9819: ARRAY
9820: PUSH
9821: LD_INT 1
9823: ARRAY
9824: PPUSH
9825: LD_VAR 0 6
9829: PUSH
9830: LD_INT 1
9832: ARRAY
9833: PUSH
9834: LD_INT 2
9836: ARRAY
9837: PPUSH
9838: CALL_OW 114
9842: GO 9881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 9
9851: PPUSH
9852: LD_INT 81
9854: PUSH
9855: LD_INT 6
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 70
9866: PPUSH
9867: LD_VAR 0 1
9871: PPUSH
9872: CALL_OW 74
9876: PPUSH
9877: CALL_OW 115
// end else
9881: GO 9917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 81
9890: PUSH
9891: LD_INT 6
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 69
9902: PPUSH
9903: LD_VAR 0 1
9907: PPUSH
9908: CALL_OW 74
9912: PPUSH
9913: CALL_OW 115
// end ;
9917: GO 9637
9919: POP
9920: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9921: LD_INT 22
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PPUSH
9931: CALL_OW 69
9935: NOT
9936: IFFALSE 9620
// end ; until russianDestroyed ;
9938: LD_EXP 21
9942: IFFALSE 9268
// end ;
9944: PPOPN 6
9946: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9947: LD_EXP 21
9951: NOT
9952: PUSH
9953: LD_EXP 15
9957: PUSH
9958: LD_INT 6
9960: GREATEREQUAL
9961: AND
9962: PUSH
9963: LD_INT 2
9965: PPUSH
9966: LD_INT 1
9968: PPUSH
9969: CALL 59360 0 2
9973: NOT
9974: AND
9975: IFFALSE 10931
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
// begin enable ;
9986: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9987: LD_INT 22
9989: PUSH
9990: LD_INT 3
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 30
9999: PUSH
10000: LD_INT 3
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PPUSH
10011: CALL_OW 69
10015: NOT
10016: IFFALSE 10020
// exit ;
10018: GO 10931
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10020: LD_ADDR_VAR 0 4
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 34
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: ST_TO_ADDR
// if Prob ( 40 ) then
10054: LD_INT 40
10056: PPUSH
10057: CALL_OW 13
10061: IFFALSE 10188
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10063: LD_INT 2
10065: PPUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: LD_INT 3
10074: PUSH
10075: LD_INT 49
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 22
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: LD_INT 3
10092: PUSH
10093: LD_INT 49
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 22
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 3
10110: PUSH
10111: LD_INT 49
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 46
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 46
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 46
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL 57942 0 2
// end else
10186: GO 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10188: LD_INT 2
10190: PPUSH
10191: LD_INT 24
10193: PUSH
10194: LD_INT 3
10196: PUSH
10197: LD_INT 3
10199: PUSH
10200: LD_INT 47
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: PUSH
10209: LD_INT 24
10211: PUSH
10212: LD_INT 3
10214: PUSH
10215: LD_INT 3
10217: PUSH
10218: LD_INT 47
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 3
10232: PUSH
10233: LD_INT 3
10235: PUSH
10236: LD_INT 47
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 24
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: LD_INT 46
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 24
10265: PUSH
10266: LD_INT 3
10268: PUSH
10269: LD_INT 3
10271: PUSH
10272: LD_INT 46
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: PUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PPUSH
10307: CALL 57942 0 2
// end ; if Difficulty > 1 then
10311: LD_OWVAR 67
10315: PUSH
10316: LD_INT 1
10318: GREATER
10319: IFFALSE 10349
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10321: LD_INT 2
10323: PPUSH
10324: LD_INT 24
10326: PUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 47
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: PPUSH
10345: CALL 57942 0 2
// repeat wait ( 0 0$1 ) ;
10349: LD_INT 35
10351: PPUSH
10352: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10356: LD_INT 2
10358: PPUSH
10359: LD_INT 1
10361: PPUSH
10362: CALL 59360 0 2
10366: PUSH
10367: LD_INT 6
10369: PUSH
10370: LD_INT 7
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_OWVAR 67
10385: ARRAY
10386: GREATEREQUAL
10387: IFFALSE 10349
// wait ( 0 0$30 ) ;
10389: LD_INT 1050
10391: PPUSH
10392: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10396: LD_ADDR_VAR 0 2
10400: PUSH
10401: LD_INT 2
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 59360 0 2
10411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10412: LD_ADDR_EXP 120
10416: PUSH
10417: LD_EXP 120
10421: PPUSH
10422: LD_INT 2
10424: PPUSH
10425: LD_EXP 120
10429: PUSH
10430: LD_INT 2
10432: ARRAY
10433: PUSH
10434: LD_VAR 0 2
10438: DIFF
10439: PPUSH
10440: CALL_OW 1
10444: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10445: LD_ADDR_VAR 0 3
10449: PUSH
10450: LD_INT 0
10452: PPUSH
10453: LD_INT 1
10455: PPUSH
10456: CALL_OW 12
10460: ST_TO_ADDR
// if target then
10461: LD_VAR 0 3
10465: IFFALSE 10593
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10467: LD_ADDR_VAR 0 2
10471: PUSH
10472: LD_VAR 0 2
10476: PPUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 250
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// for i in tmp do
10492: LD_ADDR_VAR 0 1
10496: PUSH
10497: LD_VAR 0 2
10501: PUSH
10502: FOR_IN
10503: IFFALSE 10543
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 139
10512: PPUSH
10513: LD_INT 89
10515: PPUSH
10516: CALL_OW 297
10520: PUSH
10521: LD_INT 9
10523: GREATER
10524: IFFALSE 10541
// ComMoveXY ( i , 139 , 89 ) ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 139
10533: PPUSH
10534: LD_INT 89
10536: PPUSH
10537: CALL_OW 111
10541: GO 10502
10543: POP
10544: POP
// wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_INT 92
10559: PUSH
10560: LD_INT 139
10562: PUSH
10563: LD_INT 89
10565: PUSH
10566: LD_INT 9
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 1
10587: MINUS
10588: GREATEREQUAL
10589: IFFALSE 10467
// end else
10591: GO 10735
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: PPUSH
10607: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10611: LD_ADDR_VAR 0 2
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 24
10623: PUSH
10624: LD_INT 250
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: ST_TO_ADDR
// for i in tmp do
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_VAR 0 2
10645: PUSH
10646: FOR_IN
10647: IFFALSE 10687
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 124
10656: PPUSH
10657: LD_INT 139
10659: PPUSH
10660: CALL_OW 297
10664: PUSH
10665: LD_INT 9
10667: GREATER
10668: IFFALSE 10685
// ComMoveXY ( i , 124 , 139 ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_INT 124
10677: PPUSH
10678: LD_INT 139
10680: PPUSH
10681: CALL_OW 111
10685: GO 10646
10687: POP
10688: POP
// wait ( 0 0$1 ) ;
10689: LD_INT 35
10691: PPUSH
10692: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10696: LD_VAR 0 2
10700: PPUSH
10701: LD_INT 92
10703: PUSH
10704: LD_INT 124
10706: PUSH
10707: LD_INT 139
10709: PUSH
10710: LD_INT 9
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: PPUSH
10719: CALL_OW 72
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: LD_INT 1
10731: MINUS
10732: GREATEREQUAL
10733: IFFALSE 10611
// end ; repeat wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// for i in tmp do
10742: LD_ADDR_VAR 0 1
10746: PUSH
10747: LD_VAR 0 2
10751: PUSH
10752: FOR_IN
10753: IFFALSE 10922
// begin if GetLives ( i ) > 251 then
10755: LD_VAR 0 1
10759: PPUSH
10760: CALL_OW 256
10764: PUSH
10765: LD_INT 251
10767: GREATER
10768: IFFALSE 10893
// begin if GetWeapon ( i ) = ru_time_lapser then
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 264
10779: PUSH
10780: LD_INT 49
10782: EQUAL
10783: IFFALSE 10839
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_INT 2
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PUSH
10803: LD_INT 22
10805: PUSH
10806: LD_INT 8
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PPUSH
10823: LD_VAR 0 1
10827: PPUSH
10828: CALL_OW 74
10832: PPUSH
10833: CALL_OW 112
10837: GO 10891
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 2
10846: PUSH
10847: LD_INT 22
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 8
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: PPUSH
10872: CALL_OW 69
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 74
10886: PPUSH
10887: CALL_OW 115
// end else
10891: GO 10920
// if IsDead ( i ) then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 301
10902: IFFALSE 10920
// tmp := tmp diff i ;
10904: LD_ADDR_VAR 0 2
10908: PUSH
10909: LD_VAR 0 2
10913: PUSH
10914: LD_VAR 0 1
10918: DIFF
10919: ST_TO_ADDR
// end ;
10920: GO 10752
10922: POP
10923: POP
// until not tmp ;
10924: LD_VAR 0 2
10928: NOT
10929: IFFALSE 10735
// end ; end_of_file
10931: PPOPN 4
10933: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
10939: PPUSH
10940: PPUSH
10941: PPUSH
// side := 7 ;
10942: LD_ADDR_VAR 0 5
10946: PUSH
10947: LD_INT 7
10949: ST_TO_ADDR
// uc_side := side ;
10950: LD_ADDR_OWVAR 20
10954: PUSH
10955: LD_VAR 0 5
10959: ST_TO_ADDR
// uc_nation := 1 ;
10960: LD_ADDR_OWVAR 21
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10968: LD_ADDR_VAR 0 2
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: FOR_IN
11005: IFFALSE 11021
// SetBLevel ( i , 10 ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 10
11014: PPUSH
11015: CALL_OW 241
11019: GO 11004
11021: POP
11022: POP
// base := GetBase ( al_depot ) ;
11023: LD_ADDR_VAR 0 4
11027: PUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 274
11035: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11036: LD_ADDR_VAR 0 6
11040: PUSH
11041: LD_INT 22
11043: PUSH
11044: LD_VAR 0 5
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PUSH
11053: LD_INT 30
11055: PUSH
11056: LD_INT 34
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 69
11071: ST_TO_ADDR
// if teleport then
11072: LD_VAR 0 6
11076: IFFALSE 11097
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11078: LD_VAR 0 6
11082: PUSH
11083: LD_INT 1
11085: ARRAY
11086: PPUSH
11087: LD_INT 262
11089: PPUSH
11090: LD_INT 119
11092: PPUSH
11093: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11097: LD_VAR 0 4
11101: PPUSH
11102: LD_INT 1
11104: PPUSH
11105: LD_INT 19500
11107: PPUSH
11108: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11112: LD_VAR 0 4
11116: PPUSH
11117: LD_INT 2
11119: PPUSH
11120: LD_INT 200
11122: PPUSH
11123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11127: LD_VAR 0 4
11131: PPUSH
11132: LD_INT 3
11134: PPUSH
11135: LD_INT 650
11137: PPUSH
11138: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11142: LD_ADDR_EXP 73
11146: PUSH
11147: LD_STRING Roth
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Simms
11162: PPUSH
11163: LD_EXP 1
11167: NOT
11168: PPUSH
11169: LD_STRING 10c_
11171: PPUSH
11172: CALL 64286 0 3
11176: ST_TO_ADDR
// if not Simms then
11177: LD_EXP 74
11181: NOT
11182: IFFALSE 11212
// begin uc_nation := 1 ;
11184: LD_ADDR_OWVAR 21
11188: PUSH
11189: LD_INT 1
11191: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11192: LD_INT 2
11194: PPUSH
11195: LD_INT 10
11197: PPUSH
11198: CALL_OW 384
// Simms := CreateHuman ;
11202: LD_ADDR_EXP 74
11206: PUSH
11207: CALL_OW 44
11211: ST_TO_ADDR
// end ; uc_nation := 3 ;
11212: LD_ADDR_OWVAR 21
11216: PUSH
11217: LD_INT 3
11219: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11220: LD_ADDR_EXP 75
11224: PUSH
11225: LD_STRING Kirilenkova
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11233: LD_ADDR_EXP 89
11237: PUSH
11238: LD_STRING Oblukov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11246: LD_ADDR_EXP 76
11250: PUSH
11251: LD_STRING Dolgov
11253: PPUSH
11254: CALL_OW 25
11258: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11259: LD_ADDR_EXP 77
11263: PUSH
11264: LD_STRING Petrosyan
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11272: LD_ADDR_EXP 88
11276: PUSH
11277: LD_STRING Scholtze
11279: PPUSH
11280: CALL_OW 25
11284: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11285: LD_ADDR_EXP 87
11289: PUSH
11290: LD_STRING Kapitsova
11292: PPUSH
11293: CALL_OW 25
11297: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11298: LD_ADDR_EXP 78
11302: PUSH
11303: LD_STRING Petrovova
11305: PPUSH
11306: CALL_OW 25
11310: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11311: LD_ADDR_EXP 79
11315: PUSH
11316: LD_STRING Kuzmov
11318: PPUSH
11319: CALL_OW 25
11323: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11324: LD_ADDR_EXP 86
11328: PUSH
11329: LD_STRING Karamazov
11331: PPUSH
11332: CALL_OW 25
11336: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11337: LD_STRING 13_Lipshchin_1
11339: PPUSH
11340: LD_INT 0
11342: PPUSH
11343: CALL_OW 30
11347: IFFALSE 11362
// Lipshchin := NewCharacter ( Lipshchin ) ;
11349: LD_ADDR_EXP 80
11353: PUSH
11354: LD_STRING Lipshchin
11356: PPUSH
11357: CALL_OW 25
11361: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11362: LD_STRING 13_Titov_1
11364: PPUSH
11365: LD_INT 0
11367: PPUSH
11368: CALL_OW 30
11372: IFFALSE 11387
// Titov := NewCharacter ( Titov ) ;
11374: LD_ADDR_EXP 82
11378: PUSH
11379: LD_STRING Titov
11381: PPUSH
11382: CALL_OW 25
11386: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11387: LD_STRING 13_Gnyevko_1
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 30
11397: IFFALSE 11412
// Gnyevko := NewCharacter ( Gnyevko ) ;
11399: LD_ADDR_EXP 81
11403: PUSH
11404: LD_STRING Gnyevko
11406: PPUSH
11407: CALL_OW 25
11411: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11412: LD_STRING 13_Xavier_1
11414: PPUSH
11415: LD_INT 0
11417: PPUSH
11418: CALL_OW 30
11422: IFFALSE 11437
// Xavier := NewCharacter ( Xavier2 ) ;
11424: LD_ADDR_EXP 83
11428: PUSH
11429: LD_STRING Xavier2
11431: PPUSH
11432: CALL_OW 25
11436: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11437: LD_STRING 13_Belkov_1
11439: PPUSH
11440: LD_INT 0
11442: PPUSH
11443: CALL_OW 30
11447: IFFALSE 11462
// Belkov := NewCharacter ( Belkov ) ;
11449: LD_ADDR_EXP 84
11453: PUSH
11454: LD_STRING Belkov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// if not BurlakStatus then
11462: LD_EXP 9
11466: NOT
11467: IFFALSE 11482
// Burlak = NewCharacter ( Burlak ) ;
11469: LD_ADDR_EXP 85
11473: PUSH
11474: LD_STRING Burlak
11476: PPUSH
11477: CALL_OW 25
11481: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11482: LD_ADDR_VAR 0 3
11486: PUSH
11487: LD_EXP 73
11491: PUSH
11492: LD_EXP 75
11496: PUSH
11497: LD_EXP 89
11501: PUSH
11502: LD_EXP 76
11506: PUSH
11507: LD_EXP 77
11511: PUSH
11512: LD_EXP 88
11516: PUSH
11517: LD_EXP 87
11521: PUSH
11522: LD_EXP 78
11526: PUSH
11527: LD_EXP 79
11531: PUSH
11532: LD_EXP 86
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// if Simms then
11549: LD_EXP 74
11553: IFFALSE 11571
// tmp := tmp ^ Simms ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_VAR 0 3
11564: PUSH
11565: LD_EXP 74
11569: ADD
11570: ST_TO_ADDR
// if Titov then
11571: LD_EXP 82
11575: IFFALSE 11593
// tmp := tmp ^ Titov ;
11577: LD_ADDR_VAR 0 3
11581: PUSH
11582: LD_VAR 0 3
11586: PUSH
11587: LD_EXP 82
11591: ADD
11592: ST_TO_ADDR
// if Lipshchin then
11593: LD_EXP 80
11597: IFFALSE 11615
// tmp := tmp ^ Lipshchin ;
11599: LD_ADDR_VAR 0 3
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_EXP 80
11613: ADD
11614: ST_TO_ADDR
// if Gnyevko then
11615: LD_EXP 81
11619: IFFALSE 11637
// tmp := tmp ^ Gnyevko ;
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: LD_VAR 0 3
11630: PUSH
11631: LD_EXP 81
11635: ADD
11636: ST_TO_ADDR
// if Xavier then
11637: LD_EXP 83
11641: IFFALSE 11659
// tmp := tmp ^ Xavier ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: LD_EXP 83
11657: ADD
11658: ST_TO_ADDR
// if Belkov then
11659: LD_EXP 84
11663: IFFALSE 11681
// tmp := tmp ^ Belkov ;
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_VAR 0 3
11674: PUSH
11675: LD_EXP 84
11679: ADD
11680: ST_TO_ADDR
// if Burlak then
11681: LD_EXP 85
11685: IFFALSE 11703
// tmp := tmp ^ Burlak ;
11687: LD_ADDR_VAR 0 3
11691: PUSH
11692: LD_VAR 0 3
11696: PUSH
11697: LD_EXP 85
11701: ADD
11702: ST_TO_ADDR
// for i = 1 to 8 do
11703: LD_ADDR_VAR 0 2
11707: PUSH
11708: DOUBLE
11709: LD_INT 1
11711: DEC
11712: ST_TO_ADDR
11713: LD_INT 8
11715: PUSH
11716: FOR_TO
11717: IFFALSE 11783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11719: LD_ADDR_OWVAR 21
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 1
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 2
11753: PUSH
11754: LD_INT 2
11756: DIV
11757: PPUSH
11758: LD_INT 10
11760: PPUSH
11761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11765: LD_ADDR_VAR 0 3
11769: PUSH
11770: LD_VAR 0 3
11774: PUSH
11775: CALL_OW 44
11779: ADD
11780: ST_TO_ADDR
// end ;
11781: GO 11716
11783: POP
11784: POP
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11821
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_INT 260
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: LD_INT 8
11811: PPUSH
11812: LD_INT 0
11814: PPUSH
11815: CALL_OW 50
11819: GO 11795
11821: POP
11822: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11823: LD_ADDR_EXP 101
11827: PUSH
11828: LD_EXP 101
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: LD_INT 22
11838: PUSH
11839: LD_VAR 0 5
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 21
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 69
11873: PUSH
11874: LD_EXP 73
11878: PUSH
11879: LD_EXP 74
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: DIFF
11888: PPUSH
11889: CALL_OW 1
11893: ST_TO_ADDR
// uc_side := 0 ;
11894: LD_ADDR_OWVAR 20
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// uc_nation := 0 ;
11902: LD_ADDR_OWVAR 21
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// for i = 1 to 5 do
11910: LD_ADDR_VAR 0 2
11914: PUSH
11915: DOUBLE
11916: LD_INT 1
11918: DEC
11919: ST_TO_ADDR
11920: LD_INT 5
11922: PUSH
11923: FOR_TO
11924: IFFALSE 11961
// begin InitHc ;
11926: CALL_OW 19
// hc_class := class_apeman ;
11930: LD_ADDR_OWVAR 28
11934: PUSH
11935: LD_INT 12
11937: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11938: CALL_OW 44
11942: PPUSH
11943: LD_INT 299
11945: PPUSH
11946: LD_INT 229
11948: PPUSH
11949: LD_INT 10
11951: PPUSH
11952: LD_INT 0
11954: PPUSH
11955: CALL_OW 50
// end ;
11959: GO 11923
11961: POP
11962: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11963: LD_EXP 73
11967: PPUSH
11968: LD_INT 259
11970: PPUSH
11971: LD_INT 235
11973: PPUSH
11974: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11978: LD_EXP 73
11982: PPUSH
11983: LD_INT 262
11985: PPUSH
11986: LD_INT 235
11988: PPUSH
11989: CALL_OW 178
// if Simms then
11993: LD_EXP 74
11997: IFFALSE 12028
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11999: LD_EXP 74
12003: PPUSH
12004: LD_INT 262
12006: PPUSH
12007: LD_INT 235
12009: PPUSH
12010: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12014: LD_EXP 74
12018: PPUSH
12019: LD_EXP 73
12023: PPUSH
12024: CALL_OW 179
// end ; end ;
12028: LD_VAR 0 1
12032: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12033: LD_EXP 31
12037: PUSH
12038: LD_EXP 23
12042: NOT
12043: AND
12044: IFFALSE 12220
12046: GO 12048
12048: DISABLE
12049: LD_INT 0
12051: PPUSH
12052: PPUSH
12053: PPUSH
// begin enable ;
12054: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 81
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 2
12072: PUSH
12073: LD_INT 32
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 30
12085: PUSH
12086: LD_INT 30
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 28
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 49
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 34
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 34
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 69
12150: ST_TO_ADDR
// if not tmp then
12151: LD_VAR 0 2
12155: NOT
12156: IFFALSE 12160
// exit ;
12158: GO 12220
// target := tmp [ rand ( 1 , tmp ) ] ;
12160: LD_ADDR_VAR 0 3
12164: PUSH
12165: LD_VAR 0 2
12169: PUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_VAR 0 2
12177: PPUSH
12178: CALL_OW 12
12182: ARRAY
12183: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12184: LD_VAR 0 3
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 1
12196: EQUAL
12197: IFFALSE 12208
// CenterNowOnUnits ( target ) ;
12199: LD_VAR 0 3
12203: PPUSH
12204: CALL_OW 87
// SetLives ( target , 0 ) ;
12208: LD_VAR 0 3
12212: PPUSH
12213: LD_INT 0
12215: PPUSH
12216: CALL_OW 234
// end ;
12220: PPOPN 3
12222: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12223: LD_EXP 23
12227: NOT
12228: PUSH
12229: LD_EXP 31
12233: AND
12234: IFFALSE 12756
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin uc_side := 7 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 7
12251: ST_TO_ADDR
// uc_nation := 1 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 125
12267: PUSH
12268: LD_INT 163
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 185
12277: PUSH
12278: LD_INT 168
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 111
12287: PUSH
12288: LD_INT 97
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: PPUSH
12300: CALL 107241 0 1
12304: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12305: LD_ADDR_EXP 90
12309: PUSH
12310: EMPTY
12311: ST_TO_ADDR
// for i = 1 to Difficulty do
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: DOUBLE
12318: LD_INT 1
12320: DEC
12321: ST_TO_ADDR
12322: LD_OWVAR 67
12326: PUSH
12327: FOR_TO
12328: IFFALSE 12486
// begin InitHc ;
12330: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12334: LD_INT 0
12336: PPUSH
12337: LD_INT 8
12339: PPUSH
12340: CALL_OW 381
// un := CreateHuman ;
12344: LD_ADDR_VAR 0 2
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 258
12361: PPUSH
12362: LD_INT 267
12364: PPUSH
12365: LD_INT 4
12367: PPUSH
12368: LD_INT 0
12370: PPUSH
12371: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12375: LD_ADDR_EXP 90
12379: PUSH
12380: LD_EXP 90
12384: PUSH
12385: LD_VAR 0 2
12389: UNION
12390: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12391: LD_VAR 0 2
12395: PPUSH
12396: LD_VAR 0 3
12400: PUSH
12401: LD_VAR 0 1
12405: ARRAY
12406: PUSH
12407: LD_INT 1
12409: ARRAY
12410: PPUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_VAR 0 1
12420: ARRAY
12421: PUSH
12422: LD_INT 2
12424: ARRAY
12425: PPUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ARRAY
12451: PUSH
12452: LD_INT 1
12454: ARRAY
12455: PPUSH
12456: LD_VAR 0 3
12460: PUSH
12461: LD_VAR 0 1
12465: ARRAY
12466: PUSH
12467: LD_INT 2
12469: ARRAY
12470: PPUSH
12471: CALL_OW 171
// AddComInvisible ( un ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL_OW 212
// end ;
12484: GO 12327
12486: POP
12487: POP
// repeat wait ( 0 0$20 ) ;
12488: LD_INT 700
12490: PPUSH
12491: CALL_OW 67
// for i in allianceSpecialForce do
12495: LD_ADDR_VAR 0 1
12499: PUSH
12500: LD_EXP 90
12504: PUSH
12505: FOR_IN
12506: IFFALSE 12741
// begin if IsInvisible ( i ) then
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 571
12517: IFFALSE 12710
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 50
12536: PUSH
12537: EMPTY
12538: LIST
12539: PUSH
12540: LD_INT 56
12542: PUSH
12543: EMPTY
12544: LIST
12545: PUSH
12546: LD_INT 91
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 30
12559: PUSH
12560: LD_INT 35
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: LIST
12567: PUSH
12568: LD_OWVAR 67
12572: ARRAY
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 2
12581: PUSH
12582: LD_INT 25
12584: PUSH
12585: LD_INT 1
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 25
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 3
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 25
12614: PUSH
12615: LD_INT 4
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 25
12624: PUSH
12625: LD_INT 5
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 8
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if not tmp then
12663: LD_VAR 0 3
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12505
// if Prob ( 30 * Difficulty ) then
12672: LD_INT 30
12674: PUSH
12675: LD_OWVAR 67
12679: MUL
12680: PPUSH
12681: CALL_OW 13
12685: IFFALSE 12710
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12687: LD_VAR 0 3
12691: PUSH
12692: LD_INT 1
12694: PPUSH
12695: LD_VAR 0 3
12699: PPUSH
12700: CALL_OW 12
12704: ARRAY
12705: PPUSH
12706: CALL 30392 0 1
// end ; if IsDead ( i ) then
12710: LD_VAR 0 1
12714: PPUSH
12715: CALL_OW 301
12719: IFFALSE 12739
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12721: LD_ADDR_EXP 90
12725: PUSH
12726: LD_EXP 90
12730: PUSH
12731: LD_VAR 0 1
12735: DIFF
12736: ST_TO_ADDR
// continue ;
12737: GO 12505
// end ; end ;
12739: GO 12505
12741: POP
12742: POP
// until allianceDestroyed or not allianceSpecialForce ;
12743: LD_EXP 23
12747: PUSH
12748: LD_EXP 90
12752: NOT
12753: OR
12754: IFFALSE 12488
// end ;
12756: PPOPN 3
12758: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12759: LD_EXP 23
12763: NOT
12764: PUSH
12765: LD_EXP 31
12769: AND
12770: PUSH
12771: LD_INT 1
12773: PPUSH
12774: LD_INT 1
12776: PPUSH
12777: CALL 59360 0 2
12781: NOT
12782: AND
12783: IFFALSE 13750
12785: GO 12787
12787: DISABLE
12788: LD_INT 0
12790: PPUSH
12791: PPUSH
12792: PPUSH
12793: PPUSH
// begin enable ;
12794: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12795: LD_INT 22
12797: PUSH
12798: LD_INT 7
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 30
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: NOT
12824: IFFALSE 12828
// exit ;
12826: GO 13750
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12828: LD_ADDR_VAR 0 4
12832: PUSH
12833: LD_INT 22
12835: PUSH
12836: LD_INT 7
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 30
12845: PUSH
12846: LD_INT 34
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 69
12861: ST_TO_ADDR
// if Prob ( 40 ) then
12862: LD_INT 40
12864: PPUSH
12865: CALL_OW 13
12869: IFFALSE 12996
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 5
12876: PUSH
12877: LD_INT 3
12879: PUSH
12880: LD_INT 2
12882: PUSH
12883: LD_INT 6
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 5
12894: PUSH
12895: LD_INT 3
12897: PUSH
12898: LD_INT 2
12900: PUSH
12901: LD_INT 6
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 5
12912: PUSH
12913: LD_INT 3
12915: PUSH
12916: LD_INT 2
12918: PUSH
12919: LD_INT 6
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 24
12930: PUSH
12931: LD_INT 3
12933: PUSH
12934: LD_INT 3
12936: PUSH
12937: LD_INT 45
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 45
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: PPUSH
12990: CALL 57942 0 2
// end else
12994: GO 13119
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 24
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 47
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 24
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 47
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 9
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 2
13061: PUSH
13062: LD_INT 9
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 1
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 45
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 57942 0 2
// end ; if Difficulty > 1 then
13119: LD_OWVAR 67
13123: PUSH
13124: LD_INT 1
13126: GREATER
13127: IFFALSE 13157
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13129: LD_INT 1
13131: PPUSH
13132: LD_INT 24
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: LD_INT 47
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: PUSH
13150: EMPTY
13151: LIST
13152: PPUSH
13153: CALL 57942 0 2
// repeat wait ( 0 0$1 ) ;
13157: LD_INT 35
13159: PPUSH
13160: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13164: LD_INT 1
13166: PPUSH
13167: LD_INT 1
13169: PPUSH
13170: CALL 59360 0 2
13174: PUSH
13175: LD_INT 6
13177: PUSH
13178: LD_INT 7
13180: PUSH
13181: LD_INT 7
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: LD_OWVAR 67
13193: ARRAY
13194: GREATEREQUAL
13195: IFFALSE 13157
// wait ( 0 0$40 ) ;
13197: LD_INT 1400
13199: PPUSH
13200: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13204: LD_ADDR_VAR 0 2
13208: PUSH
13209: LD_INT 1
13211: PPUSH
13212: LD_INT 1
13214: PPUSH
13215: CALL 59360 0 2
13219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13220: LD_ADDR_EXP 120
13224: PUSH
13225: LD_EXP 120
13229: PPUSH
13230: LD_INT 1
13232: PPUSH
13233: LD_EXP 120
13237: PUSH
13238: LD_INT 1
13240: ARRAY
13241: PUSH
13242: LD_VAR 0 2
13246: DIFF
13247: PPUSH
13248: CALL_OW 1
13252: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_INT 0
13260: PPUSH
13261: LD_INT 1
13263: PPUSH
13264: CALL_OW 12
13268: ST_TO_ADDR
// if target then
13269: LD_VAR 0 3
13273: IFFALSE 13439
// begin for i in tmp do
13275: LD_ADDR_VAR 0 1
13279: PUSH
13280: LD_VAR 0 2
13284: PUSH
13285: FOR_IN
13286: IFFALSE 13311
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13288: LD_VAR 0 1
13292: PPUSH
13293: LD_INT 179
13295: PPUSH
13296: LD_INT 209
13298: PPUSH
13299: LD_INT 8
13301: PPUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 483
13309: GO 13285
13311: POP
13312: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13313: LD_ADDR_VAR 0 2
13317: PUSH
13318: LD_VAR 0 2
13322: PPUSH
13323: LD_INT 24
13325: PUSH
13326: LD_INT 250
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 72
13337: ST_TO_ADDR
// for i in tmp do
13338: LD_ADDR_VAR 0 1
13342: PUSH
13343: LD_VAR 0 2
13347: PUSH
13348: FOR_IN
13349: IFFALSE 13389
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13351: LD_VAR 0 1
13355: PPUSH
13356: LD_INT 179
13358: PPUSH
13359: LD_INT 209
13361: PPUSH
13362: CALL_OW 297
13366: PUSH
13367: LD_INT 9
13369: GREATER
13370: IFFALSE 13387
// ComMoveXY ( i , 179 , 209 ) ;
13372: LD_VAR 0 1
13376: PPUSH
13377: LD_INT 179
13379: PPUSH
13380: LD_INT 209
13382: PPUSH
13383: CALL_OW 111
13387: GO 13348
13389: POP
13390: POP
// wait ( 0 0$1 ) ;
13391: LD_INT 35
13393: PPUSH
13394: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13398: LD_VAR 0 2
13402: PPUSH
13403: LD_INT 92
13405: PUSH
13406: LD_INT 179
13408: PUSH
13409: LD_INT 209
13411: PUSH
13412: LD_INT 9
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: PPUSH
13421: CALL_OW 72
13425: PUSH
13426: LD_VAR 0 2
13430: PUSH
13431: LD_INT 1
13433: MINUS
13434: GREATEREQUAL
13435: IFFALSE 13313
// end else
13437: GO 13601
// begin for i in tmp do
13439: LD_ADDR_VAR 0 1
13443: PUSH
13444: LD_VAR 0 2
13448: PUSH
13449: FOR_IN
13450: IFFALSE 13475
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13452: LD_VAR 0 1
13456: PPUSH
13457: LD_INT 285
13459: PPUSH
13460: LD_INT 163
13462: PPUSH
13463: LD_INT 8
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 483
13473: GO 13449
13475: POP
13476: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13477: LD_ADDR_VAR 0 2
13481: PUSH
13482: LD_VAR 0 2
13486: PPUSH
13487: LD_INT 24
13489: PUSH
13490: LD_INT 250
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PPUSH
13497: CALL_OW 72
13501: ST_TO_ADDR
// for i in tmp do
13502: LD_ADDR_VAR 0 1
13506: PUSH
13507: LD_VAR 0 2
13511: PUSH
13512: FOR_IN
13513: IFFALSE 13553
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13515: LD_VAR 0 1
13519: PPUSH
13520: LD_INT 285
13522: PPUSH
13523: LD_INT 163
13525: PPUSH
13526: CALL_OW 297
13530: PUSH
13531: LD_INT 9
13533: GREATER
13534: IFFALSE 13551
// ComMoveXY ( i , 285 , 163 ) ;
13536: LD_VAR 0 1
13540: PPUSH
13541: LD_INT 285
13543: PPUSH
13544: LD_INT 163
13546: PPUSH
13547: CALL_OW 111
13551: GO 13512
13553: POP
13554: POP
// wait ( 0 0$1 ) ;
13555: LD_INT 35
13557: PPUSH
13558: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13562: LD_VAR 0 2
13566: PPUSH
13567: LD_INT 92
13569: PUSH
13570: LD_INT 285
13572: PUSH
13573: LD_INT 163
13575: PUSH
13576: LD_INT 9
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: PPUSH
13585: CALL_OW 72
13589: PUSH
13590: LD_VAR 0 2
13594: PUSH
13595: LD_INT 1
13597: MINUS
13598: GREATEREQUAL
13599: IFFALSE 13477
// end ; repeat wait ( 0 0$1 ) ;
13601: LD_INT 35
13603: PPUSH
13604: CALL_OW 67
// for i in tmp do
13608: LD_ADDR_VAR 0 1
13612: PUSH
13613: LD_VAR 0 2
13617: PUSH
13618: FOR_IN
13619: IFFALSE 13741
// if GetLives ( i ) > 251 then
13621: LD_VAR 0 1
13625: PPUSH
13626: CALL_OW 256
13630: PUSH
13631: LD_INT 251
13633: GREATER
13634: IFFALSE 13723
// begin if GetWeapon ( i ) = ru_time_lapser then
13636: LD_VAR 0 1
13640: PPUSH
13641: CALL_OW 264
13645: PUSH
13646: LD_INT 49
13648: EQUAL
13649: IFFALSE 13687
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_INT 81
13658: PUSH
13659: LD_INT 7
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PPUSH
13671: LD_VAR 0 1
13675: PPUSH
13676: CALL_OW 74
13680: PPUSH
13681: CALL_OW 112
13685: GO 13721
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_INT 81
13694: PUSH
13695: LD_INT 7
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 69
13706: PPUSH
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 74
13716: PPUSH
13717: CALL_OW 115
// end else
13721: GO 13739
// tmp := tmp diff i ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_VAR 0 2
13732: PUSH
13733: LD_VAR 0 1
13737: DIFF
13738: ST_TO_ADDR
13739: GO 13618
13741: POP
13742: POP
// until not tmp ;
13743: LD_VAR 0 2
13747: NOT
13748: IFFALSE 13601
// end ; end_of_file
13750: PPOPN 4
13752: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13753: LD_INT 0
13755: PPUSH
13756: PPUSH
13757: PPUSH
13758: PPUSH
// missionStage := 13 ;
13759: LD_ADDR_EXP 15
13763: PUSH
13764: LD_INT 13
13766: ST_TO_ADDR
// uc_side := 2 ;
13767: LD_ADDR_OWVAR 20
13771: PUSH
13772: LD_INT 2
13774: ST_TO_ADDR
// uc_nation := 2 ;
13775: LD_ADDR_OWVAR 21
13779: PUSH
13780: LD_INT 2
13782: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13783: LD_ADDR_EXP 91
13787: PUSH
13788: LD_STRING Omar
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13796: LD_EXP 91
13800: PPUSH
13801: LD_INT 4
13803: PPUSH
13804: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13808: LD_EXP 91
13812: PPUSH
13813: LD_INT 242
13815: PPUSH
13816: LD_INT 75
13818: PPUSH
13819: LD_INT 0
13821: PPUSH
13822: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13826: LD_ADDR_EXP 92
13830: PUSH
13831: LD_STRING Heike
13833: PPUSH
13834: CALL_OW 25
13838: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13839: LD_INT 14
13841: PPUSH
13842: LD_INT 3
13844: PPUSH
13845: LD_INT 1
13847: PPUSH
13848: LD_INT 27
13850: PPUSH
13851: LD_INT 100
13853: PPUSH
13854: CALL 71401 0 5
// veh := CreateVehicle ;
13858: LD_ADDR_VAR 0 3
13862: PUSH
13863: CALL_OW 45
13867: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13868: LD_VAR 0 3
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL_OW 242
// SetDir ( veh , 4 ) ;
13880: LD_VAR 0 3
13884: PPUSH
13885: LD_INT 4
13887: PPUSH
13888: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13892: LD_VAR 0 3
13896: PPUSH
13897: LD_INT 241
13899: PPUSH
13900: LD_INT 72
13902: PPUSH
13903: LD_INT 0
13905: PPUSH
13906: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13910: LD_EXP 92
13914: PPUSH
13915: LD_VAR 0 3
13919: PPUSH
13920: CALL_OW 52
// if KhatamStatus then
13924: LD_EXP 8
13928: IFFALSE 13979
// begin Khatam := NewCharacter ( Khatam ) ;
13930: LD_ADDR_EXP 93
13934: PUSH
13935: LD_STRING Khatam
13937: PPUSH
13938: CALL_OW 25
13942: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13943: LD_EXP 93
13947: PPUSH
13948: LD_INT 245
13950: PPUSH
13951: LD_INT 78
13953: PPUSH
13954: LD_INT 3
13956: PPUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13964: LD_EXP 93
13968: PPUSH
13969: LD_INT 4
13971: PPUSH
13972: LD_INT 10
13974: PPUSH
13975: CALL_OW 237
// end ; for i = 1 to Difficulty do
13979: LD_ADDR_VAR 0 2
13983: PUSH
13984: DOUBLE
13985: LD_INT 1
13987: DEC
13988: ST_TO_ADDR
13989: LD_OWVAR 67
13993: PUSH
13994: FOR_TO
13995: IFFALSE 14061
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13997: LD_INT 0
13999: PPUSH
14000: LD_INT 7
14002: PUSH
14003: LD_OWVAR 67
14007: PLUS
14008: PPUSH
14009: CALL_OW 384
// un := CreateHuman ;
14013: LD_ADDR_VAR 0 4
14017: PUSH
14018: CALL_OW 44
14022: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14023: LD_VAR 0 4
14027: PPUSH
14028: LD_INT 28
14030: PUSH
14031: LD_INT 29
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PUSH
14038: LD_VAR 0 2
14042: PUSH
14043: LD_INT 2
14045: MOD
14046: PUSH
14047: LD_INT 1
14049: PLUS
14050: ARRAY
14051: PPUSH
14052: LD_INT 0
14054: PPUSH
14055: CALL_OW 49
// end ;
14059: GO 13994
14061: POP
14062: POP
// for i = 1 to 6 do
14063: LD_ADDR_VAR 0 2
14067: PUSH
14068: DOUBLE
14069: LD_INT 1
14071: DEC
14072: ST_TO_ADDR
14073: LD_INT 6
14075: PUSH
14076: FOR_TO
14077: IFFALSE 14122
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14079: LD_INT 0
14081: PPUSH
14082: LD_INT 7
14084: PUSH
14085: LD_OWVAR 67
14089: PLUS
14090: PPUSH
14091: CALL_OW 381
// un := CreateHuman ;
14095: LD_ADDR_VAR 0 4
14099: PUSH
14100: CALL_OW 44
14104: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14105: LD_VAR 0 4
14109: PPUSH
14110: LD_INT 28
14112: PPUSH
14113: LD_INT 0
14115: PPUSH
14116: CALL_OW 49
// end ;
14120: GO 14076
14122: POP
14123: POP
// for i = 1 to 3 do
14124: LD_ADDR_VAR 0 2
14128: PUSH
14129: DOUBLE
14130: LD_INT 1
14132: DEC
14133: ST_TO_ADDR
14134: LD_INT 3
14136: PUSH
14137: FOR_TO
14138: IFFALSE 14186
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14140: LD_INT 0
14142: PPUSH
14143: LD_INT 8
14145: PPUSH
14146: LD_INT 7
14148: PUSH
14149: LD_OWVAR 67
14153: PLUS
14154: PPUSH
14155: CALL_OW 380
// un := CreateHuman ;
14159: LD_ADDR_VAR 0 4
14163: PUSH
14164: CALL_OW 44
14168: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14169: LD_VAR 0 4
14173: PPUSH
14174: LD_INT 28
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14137
14186: POP
14187: POP
// for i = 1 to 3 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 3
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14292
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14204: LD_INT 14
14206: PPUSH
14207: LD_INT 2
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 28
14215: PPUSH
14216: LD_INT 80
14218: PPUSH
14219: CALL 71401 0 5
// veh := CreateVehicle ;
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: CALL_OW 45
14232: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14233: LD_VAR 0 3
14237: PPUSH
14238: LD_INT 3
14240: PPUSH
14241: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14245: LD_VAR 0 3
14249: PPUSH
14250: LD_INT 29
14252: PPUSH
14253: LD_INT 0
14255: PPUSH
14256: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 7
14265: PUSH
14266: LD_OWVAR 67
14270: PLUS
14271: PPUSH
14272: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14276: CALL_OW 44
14280: PPUSH
14281: LD_VAR 0 3
14285: PPUSH
14286: CALL_OW 52
// end ;
14290: GO 14201
14292: POP
14293: POP
// for i = 1 to 5 + Difficulty do
14294: LD_ADDR_VAR 0 2
14298: PUSH
14299: DOUBLE
14300: LD_INT 1
14302: DEC
14303: ST_TO_ADDR
14304: LD_INT 5
14306: PUSH
14307: LD_OWVAR 67
14311: PLUS
14312: PUSH
14313: FOR_TO
14314: IFFALSE 14441
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14316: LD_INT 14
14318: PPUSH
14319: LD_INT 1
14321: PPUSH
14322: LD_INT 3
14324: PPUSH
14325: CALL_OW 12
14329: PPUSH
14330: LD_INT 1
14332: PPUSH
14333: LD_INT 28
14335: PUSH
14336: LD_INT 26
14338: PUSH
14339: LD_INT 27
14341: PUSH
14342: LD_INT 25
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: PUSH
14351: LD_VAR 0 2
14355: PUSH
14356: LD_INT 4
14358: MOD
14359: PUSH
14360: LD_INT 1
14362: PLUS
14363: ARRAY
14364: PPUSH
14365: LD_INT 80
14367: PPUSH
14368: CALL 71401 0 5
// veh := CreateVehicle ;
14372: LD_ADDR_VAR 0 3
14376: PUSH
14377: CALL_OW 45
14381: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14382: LD_VAR 0 3
14386: PPUSH
14387: LD_INT 4
14389: PPUSH
14390: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14394: LD_VAR 0 3
14398: PPUSH
14399: LD_INT 28
14401: PPUSH
14402: LD_INT 0
14404: PPUSH
14405: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14409: LD_INT 0
14411: PPUSH
14412: LD_INT 7
14414: PUSH
14415: LD_OWVAR 67
14419: PLUS
14420: PPUSH
14421: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14425: CALL_OW 44
14429: PPUSH
14430: LD_VAR 0 3
14434: PPUSH
14435: CALL_OW 52
// end ;
14439: GO 14313
14441: POP
14442: POP
// for i = 1 to 3 do
14443: LD_ADDR_VAR 0 2
14447: PUSH
14448: DOUBLE
14449: LD_INT 1
14451: DEC
14452: ST_TO_ADDR
14453: LD_INT 3
14455: PUSH
14456: FOR_TO
14457: IFFALSE 14517
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14459: LD_INT 14
14461: PPUSH
14462: LD_INT 3
14464: PPUSH
14465: LD_INT 5
14467: PPUSH
14468: LD_INT 29
14470: PPUSH
14471: LD_INT 80
14473: PPUSH
14474: CALL 71401 0 5
// veh := CreateVehicle ;
14478: LD_ADDR_VAR 0 3
14482: PUSH
14483: CALL_OW 45
14487: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: LD_INT 4
14495: PPUSH
14496: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14500: LD_VAR 0 3
14504: PPUSH
14505: LD_INT 28
14507: PPUSH
14508: LD_INT 0
14510: PPUSH
14511: CALL_OW 49
// end ;
14515: GO 14456
14517: POP
14518: POP
// end ;
14519: LD_VAR 0 1
14523: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14524: LD_INT 22
14526: PUSH
14527: LD_INT 2
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: IFFALSE 14838
14540: GO 14542
14542: DISABLE
14543: LD_INT 0
14545: PPUSH
14546: PPUSH
14547: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14548: LD_ADDR_VAR 0 3
14552: PUSH
14553: LD_INT 22
14555: PUSH
14556: LD_INT 2
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PUSH
14563: LD_INT 25
14565: PUSH
14566: LD_INT 4
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PPUSH
14577: CALL_OW 69
14581: PUSH
14582: LD_EXP 93
14586: DIFF
14587: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14588: LD_ADDR_VAR 0 2
14592: PUSH
14593: LD_INT 22
14595: PUSH
14596: LD_INT 2
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 69
14607: PUSH
14608: LD_EXP 93
14612: PUSH
14613: LD_VAR 0 3
14617: UNION
14618: DIFF
14619: ST_TO_ADDR
// if Khatam then
14620: LD_EXP 93
14624: IFFALSE 14641
// ComMoveXY ( Khatam , 211 , 92 ) ;
14626: LD_EXP 93
14630: PPUSH
14631: LD_INT 211
14633: PPUSH
14634: LD_INT 92
14636: PPUSH
14637: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14641: LD_INT 197
14643: PPUSH
14644: LD_INT 80
14646: PPUSH
14647: LD_INT 2
14649: PPUSH
14650: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14654: LD_INT 213
14656: PPUSH
14657: LD_INT 90
14659: PPUSH
14660: LD_INT 2
14662: PPUSH
14663: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14667: LD_INT 215
14669: PPUSH
14670: LD_INT 129
14672: PPUSH
14673: LD_INT 2
14675: PPUSH
14676: CALL_OW 441
// if sci then
14680: LD_VAR 0 3
14684: IFFALSE 14705
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14686: LD_VAR 0 3
14690: PUSH
14691: LD_INT 1
14693: ARRAY
14694: PPUSH
14695: LD_INT 197
14697: PPUSH
14698: LD_INT 80
14700: PPUSH
14701: CALL_OW 158
// if sci > 1 then
14705: LD_VAR 0 3
14709: PUSH
14710: LD_INT 1
14712: GREATER
14713: IFFALSE 14734
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14715: LD_VAR 0 3
14719: PUSH
14720: LD_INT 2
14722: ARRAY
14723: PPUSH
14724: LD_INT 213
14726: PPUSH
14727: LD_INT 90
14729: PPUSH
14730: CALL_OW 158
// if sci > 2 then
14734: LD_VAR 0 3
14738: PUSH
14739: LD_INT 2
14741: GREATER
14742: IFFALSE 14763
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14744: LD_VAR 0 3
14748: PUSH
14749: LD_INT 3
14751: ARRAY
14752: PPUSH
14753: LD_INT 215
14755: PPUSH
14756: LD_INT 129
14758: PPUSH
14759: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14763: LD_INT 35
14765: PPUSH
14766: CALL_OW 67
// for i in tmp do
14770: LD_ADDR_VAR 0 1
14774: PUSH
14775: LD_VAR 0 2
14779: PUSH
14780: FOR_IN
14781: IFFALSE 14819
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14783: LD_VAR 0 1
14787: PPUSH
14788: LD_INT 81
14790: PUSH
14791: LD_INT 2
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PPUSH
14798: CALL_OW 69
14802: PPUSH
14803: LD_VAR 0 1
14807: PPUSH
14808: CALL_OW 74
14812: PPUSH
14813: CALL_OW 115
14817: GO 14780
14819: POP
14820: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14821: LD_INT 22
14823: PUSH
14824: LD_INT 2
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PPUSH
14831: CALL_OW 69
14835: NOT
14836: IFFALSE 14763
// end ; end_of_file
14838: PPOPN 3
14840: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14841: LD_INT 0
14843: PPUSH
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
14851: PPUSH
// Video ( true ) ;
14852: LD_INT 1
14854: PPUSH
14855: CALL 107121 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14859: LD_ADDR_VAR 0 5
14863: PUSH
14864: LD_INT 7
14866: PPUSH
14867: LD_INT 0
14869: PPUSH
14870: CALL_OW 517
14874: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14875: LD_ADDR_VAR 0 2
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_VAR 0 5
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: PUSH
14894: FOR_TO
14895: IFFALSE 14940
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14897: LD_VAR 0 5
14901: PUSH
14902: LD_INT 1
14904: ARRAY
14905: PUSH
14906: LD_VAR 0 2
14910: ARRAY
14911: PPUSH
14912: LD_VAR 0 5
14916: PUSH
14917: LD_INT 2
14919: ARRAY
14920: PUSH
14921: LD_VAR 0 2
14925: ARRAY
14926: PPUSH
14927: LD_INT 1
14929: PPUSH
14930: LD_INT 15
14932: NEG
14933: PPUSH
14934: CALL 107035 0 4
14938: GO 14894
14940: POP
14941: POP
// CenterNowOnUnits ( Powell ) ;
14942: LD_EXP 57
14946: PPUSH
14947: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14951: LD_ADDR_VAR 0 5
14955: PUSH
14956: LD_EXP 55
14960: PUSH
14961: EMPTY
14962: LIST
14963: ST_TO_ADDR
// if GirlNewVeh then
14964: LD_EXP 56
14968: IFFALSE 14986
// tmp := tmp ^ GirlNewVeh ;
14970: LD_ADDR_VAR 0 5
14974: PUSH
14975: LD_VAR 0 5
14979: PUSH
14980: LD_EXP 56
14984: ADD
14985: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14986: LD_VAR 0 5
14990: PPUSH
14991: LD_INT 60
14993: PPUSH
14994: LD_INT 109
14996: PPUSH
14997: CALL_OW 111
// if KappaStatus then
15001: LD_EXP 2
15005: IFFALSE 15057
// begin Say ( JMM , D1nT-JMM-1 ) ;
15007: LD_EXP 38
15011: PPUSH
15012: LD_STRING D1nT-JMM-1
15014: PPUSH
15015: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15019: LD_EXP 57
15023: PPUSH
15024: LD_STRING D1T-Pow-1
15026: PPUSH
15027: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15031: LD_EXP 38
15035: PPUSH
15036: LD_STRING D1T-JMM-2
15038: PPUSH
15039: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15043: LD_EXP 57
15047: PPUSH
15048: LD_STRING D1T-Pow-2
15050: PPUSH
15051: CALL_OW 88
// end else
15055: GO 15263
// if JMMGirlStatus then
15057: LD_EXP 6
15061: IFFALSE 15206
// begin Say ( JMM , D1T-JMM-1 ) ;
15063: LD_EXP 38
15067: PPUSH
15068: LD_STRING D1T-JMM-1
15070: PPUSH
15071: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15075: LD_EXP 57
15079: PPUSH
15080: LD_STRING D1T-Pow-1
15082: PPUSH
15083: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15087: LD_EXP 38
15091: PPUSH
15092: LD_STRING D1T-JMM-3
15094: PPUSH
15095: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15099: LD_EXP 57
15103: PPUSH
15104: LD_STRING D1T-Pow-3
15106: PPUSH
15107: CALL_OW 88
// if JMMGirl then
15111: LD_EXP 7
15115: IFFALSE 15204
// begin case JMMGirl of 1 :
15117: LD_EXP 7
15121: PUSH
15122: LD_INT 1
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15145
15130: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15131: LD_EXP 39
15135: PPUSH
15136: LD_STRING D1T-Joan-3
15138: PPUSH
15139: CALL_OW 88
15143: GO 15192
15145: LD_INT 2
15147: DOUBLE
15148: EQUAL
15149: IFTRUE 15153
15151: GO 15168
15153: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15154: LD_EXP 41
15158: PPUSH
15159: LD_STRING D1T-Lisa-3
15161: PPUSH
15162: CALL_OW 88
15166: GO 15192
15168: LD_INT 3
15170: DOUBLE
15171: EQUAL
15172: IFTRUE 15176
15174: GO 15191
15176: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15177: LD_EXP 53
15181: PPUSH
15182: LD_STRING D1T-Con-3
15184: PPUSH
15185: CALL_OW 88
15189: GO 15192
15191: POP
// Say ( Powell , D1T-Pow-4 ) ;
15192: LD_EXP 57
15196: PPUSH
15197: LD_STRING D1T-Pow-4
15199: PPUSH
15200: CALL_OW 88
// end ; end else
15204: GO 15263
// if not FastEnd then
15206: LD_EXP 11
15210: NOT
15211: IFFALSE 15239
// begin Say ( JMM , D1T-JMM-4 ) ;
15213: LD_EXP 38
15217: PPUSH
15218: LD_STRING D1T-JMM-4
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15225: LD_EXP 57
15229: PPUSH
15230: LD_STRING D1T-Pow-5
15232: PPUSH
15233: CALL_OW 88
// end else
15237: GO 15263
// begin Say ( JMM , D1nT-JMM-1 ) ;
15239: LD_EXP 38
15243: PPUSH
15244: LD_STRING D1nT-JMM-1
15246: PPUSH
15247: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15251: LD_EXP 57
15255: PPUSH
15256: LD_STRING D1nT-Pow-1
15258: PPUSH
15259: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15263: LD_INT 35
15265: PPUSH
15266: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15270: LD_EXP 55
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: IFFALSE 15263
// ComExitVehicle ( JMM ) ;
15282: LD_EXP 38
15286: PPUSH
15287: CALL_OW 121
// wait ( 3 ) ;
15291: LD_INT 3
15293: PPUSH
15294: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15298: LD_EXP 38
15302: PPUSH
15303: LD_INT 60
15305: PPUSH
15306: LD_INT 94
15308: PPUSH
15309: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15313: LD_EXP 38
15317: PPUSH
15318: LD_EXP 57
15322: PPUSH
15323: CALL_OW 179
// if Joan then
15327: LD_EXP 39
15331: IFFALSE 15385
// begin ComExitVehicle ( Joan ) ;
15333: LD_EXP 39
15337: PPUSH
15338: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15342: LD_EXP 39
15346: PPUSH
15347: LD_INT 35
15349: PPUSH
15350: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15354: LD_EXP 39
15358: PPUSH
15359: LD_INT 65
15361: PPUSH
15362: LD_INT 104
15364: PPUSH
15365: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_EXP 38
15378: PPUSH
15379: CALL_OW 179
// end else
15383: GO 15519
// if Lisa and JMMGirl = 2 then
15385: LD_EXP 41
15389: PUSH
15390: LD_EXP 7
15394: PUSH
15395: LD_INT 2
15397: EQUAL
15398: AND
15399: IFFALSE 15453
// begin ComExitVehicle ( Lisa ) ;
15401: LD_EXP 41
15405: PPUSH
15406: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15410: LD_EXP 41
15414: PPUSH
15415: LD_INT 35
15417: PPUSH
15418: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15422: LD_EXP 41
15426: PPUSH
15427: LD_INT 65
15429: PPUSH
15430: LD_INT 104
15432: PPUSH
15433: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15437: LD_EXP 41
15441: PPUSH
15442: LD_EXP 38
15446: PPUSH
15447: CALL_OW 179
// end else
15451: GO 15519
// if Connie and JMMGirl = 3 then
15453: LD_EXP 53
15457: PUSH
15458: LD_EXP 7
15462: PUSH
15463: LD_INT 3
15465: EQUAL
15466: AND
15467: IFFALSE 15519
// begin ComExitVehicle ( Connie ) ;
15469: LD_EXP 53
15473: PPUSH
15474: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15478: LD_EXP 53
15482: PPUSH
15483: LD_INT 35
15485: PPUSH
15486: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15490: LD_EXP 53
15494: PPUSH
15495: LD_INT 65
15497: PPUSH
15498: LD_INT 104
15500: PPUSH
15501: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15505: LD_EXP 53
15509: PPUSH
15510: LD_EXP 38
15514: PPUSH
15515: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15519: LD_INT 35
15521: PPUSH
15522: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15526: LD_EXP 38
15530: PPUSH
15531: LD_EXP 57
15535: PPUSH
15536: CALL_OW 296
15540: PUSH
15541: LD_INT 6
15543: LESS
15544: IFFALSE 15519
// wait ( 0 0$0.5 ) ;
15546: LD_INT 18
15548: PPUSH
15549: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15553: LD_EXP 38
15557: PPUSH
15558: LD_STRING D1-JMM-1
15560: PPUSH
15561: CALL_OW 88
// async ;
15565: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15566: LD_EXP 57
15570: PPUSH
15571: LD_STRING D1-Pow-1
15573: PPUSH
15574: CALL_OW 88
// if not dialogue_skipped then
15578: LD_OWVAR 59
15582: NOT
15583: IFFALSE 15592
// wait ( 0 0$2 ) ;
15585: LD_INT 70
15587: PPUSH
15588: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15592: LD_INT 170
15594: PPUSH
15595: LD_INT 99
15597: PPUSH
15598: LD_INT 1
15600: PPUSH
15601: LD_INT 6
15603: NEG
15604: PPUSH
15605: CALL 107035 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15609: LD_INT 174
15611: PPUSH
15612: LD_INT 115
15614: PPUSH
15615: LD_INT 1
15617: PPUSH
15618: LD_INT 6
15620: NEG
15621: PPUSH
15622: CALL 107035 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15626: LD_INT 169
15628: PPUSH
15629: LD_INT 71
15631: PPUSH
15632: LD_INT 1
15634: PPUSH
15635: LD_INT 6
15637: NEG
15638: PPUSH
15639: CALL 107035 0 4
// if not dialogue_skipped then
15643: LD_OWVAR 59
15647: NOT
15648: IFFALSE 15667
// begin CenterOnXY ( 170 , 99 ) ;
15650: LD_INT 170
15652: PPUSH
15653: LD_INT 99
15655: PPUSH
15656: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15660: LD_INT 80
15662: PPUSH
15663: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15667: LD_INT 75
15669: PPUSH
15670: LD_INT 53
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_INT 9
15678: NEG
15679: PPUSH
15680: CALL 107035 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15684: LD_INT 54
15686: PPUSH
15687: LD_INT 42
15689: PPUSH
15690: LD_INT 1
15692: PPUSH
15693: LD_INT 9
15695: NEG
15696: PPUSH
15697: CALL 107035 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15701: LD_INT 62
15703: PPUSH
15704: LD_INT 51
15706: PPUSH
15707: LD_INT 1
15709: PPUSH
15710: LD_INT 9
15712: NEG
15713: PPUSH
15714: CALL 107035 0 4
// if not dialogue_skipped then
15718: LD_OWVAR 59
15722: NOT
15723: IFFALSE 15742
// begin CenterOnXY ( 75 , 53 ) ;
15725: LD_INT 75
15727: PPUSH
15728: LD_INT 53
15730: PPUSH
15731: CALL_OW 84
// wait ( 0 0$4 ) ;
15735: LD_INT 140
15737: PPUSH
15738: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15742: LD_EXP 57
15746: PPUSH
15747: CALL_OW 87
// if not dialogue_skipped then
15751: LD_OWVAR 59
15755: NOT
15756: IFFALSE 15765
// wait ( 0 0$2 ) ;
15758: LD_INT 70
15760: PPUSH
15761: CALL_OW 67
// sync ;
15765: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15766: LD_EXP 38
15770: PPUSH
15771: LD_STRING D1-JMM-2
15773: PPUSH
15774: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15778: LD_EXP 57
15782: PPUSH
15783: LD_STRING D1-Pow-2
15785: PPUSH
15786: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15790: LD_EXP 38
15794: PPUSH
15795: LD_STRING D1-JMM-3
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15802: LD_EXP 57
15806: PPUSH
15807: LD_STRING D1-Pow-3
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15814: LD_EXP 38
15818: PPUSH
15819: LD_STRING D1-JMM-4
15821: PPUSH
15822: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15826: LD_EXP 57
15830: PPUSH
15831: LD_STRING D1-Pow-4
15833: PPUSH
15834: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15838: LD_EXP 38
15842: PPUSH
15843: LD_STRING D1-JMM-5
15845: PPUSH
15846: CALL_OW 88
// async ;
15850: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15851: LD_EXP 57
15855: PPUSH
15856: LD_STRING D1-Pow-5
15858: PPUSH
15859: CALL_OW 88
// if not dialogue_skipped then
15863: LD_OWVAR 59
15867: NOT
15868: IFFALSE 15877
// wait ( 0 0$3.6 ) ;
15870: LD_INT 126
15872: PPUSH
15873: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15877: LD_INT 134
15879: PPUSH
15880: LD_INT 210
15882: PPUSH
15883: LD_INT 1
15885: PPUSH
15886: LD_INT 11
15888: NEG
15889: PPUSH
15890: CALL 107035 0 4
// if not dialogue_skipped then
15894: LD_OWVAR 59
15898: NOT
15899: IFFALSE 15918
// begin CenterOnXY ( 134 , 210 ) ;
15901: LD_INT 134
15903: PPUSH
15904: LD_INT 210
15906: PPUSH
15907: CALL_OW 84
// wait ( 0 0$2 ) ;
15911: LD_INT 70
15913: PPUSH
15914: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15918: LD_INT 101
15920: PPUSH
15921: LD_INT 159
15923: PPUSH
15924: LD_INT 1
15926: PPUSH
15927: LD_INT 10
15929: NEG
15930: PPUSH
15931: CALL 107035 0 4
// if not dialogue_skipped then
15935: LD_OWVAR 59
15939: NOT
15940: IFFALSE 15959
// begin CenterOnXY ( 101 , 159 ) ;
15942: LD_INT 101
15944: PPUSH
15945: LD_INT 159
15947: PPUSH
15948: CALL_OW 84
// wait ( 0 0$2 ) ;
15952: LD_INT 70
15954: PPUSH
15955: CALL_OW 67
// end ; sync ;
15959: SYNC
// CenterNowOnUnits ( Powell ) ;
15960: LD_EXP 57
15964: PPUSH
15965: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15969: LD_ADDR_VAR 0 6
15973: PUSH
15974: LD_INT 1
15976: PUSH
15977: LD_INT 2
15979: PUSH
15980: LD_INT 3
15982: PUSH
15983: LD_INT 4
15985: PUSH
15986: LD_INT 5
15988: PUSH
15989: LD_INT 6
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: ST_TO_ADDR
// if not dialogue_skipped then
16000: LD_OWVAR 59
16004: NOT
16005: IFFALSE 16174
// begin game_speed := 4 ;
16007: LD_ADDR_OWVAR 65
16011: PUSH
16012: LD_INT 4
16014: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16015: LD_INT 210
16017: PPUSH
16018: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16022: LD_ADDR_VAR 0 7
16026: PUSH
16027: LD_STRING Q1
16029: PPUSH
16030: LD_VAR 0 6
16034: PPUSH
16035: CALL_OW 98
16039: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16040: LD_ADDR_VAR 0 7
16044: PUSH
16045: LD_STRING Q1
16047: PPUSH
16048: LD_VAR 0 6
16052: PPUSH
16053: CALL_OW 98
16057: ST_TO_ADDR
// options = options diff dec ;
16058: LD_ADDR_VAR 0 6
16062: PUSH
16063: LD_VAR 0 6
16067: PUSH
16068: LD_VAR 0 7
16072: DIFF
16073: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16074: LD_VAR 0 7
16078: PPUSH
16079: LD_VAR 0 6
16083: PPUSH
16084: CALL 17646 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16088: LD_VAR 0 7
16092: PUSH
16093: LD_INT 5
16095: PUSH
16096: LD_INT 6
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: IN
16103: PUSH
16104: LD_VAR 0 6
16108: PUSH
16109: LD_INT 2
16111: EQUAL
16112: OR
16113: IFFALSE 16040
// if not ( dec in [ 5 , 6 ] ) then
16115: LD_VAR 0 7
16119: PUSH
16120: LD_INT 5
16122: PUSH
16123: LD_INT 6
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: IN
16130: NOT
16131: IFFALSE 16174
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16133: LD_ADDR_VAR 0 7
16137: PUSH
16138: LD_STRING Q1a
16140: PPUSH
16141: LD_INT 1
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 98
16155: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16156: LD_VAR 0 7
16160: PUSH
16161: LD_INT 4
16163: PLUS
16164: PPUSH
16165: LD_VAR 0 6
16169: PPUSH
16170: CALL 17646 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16174: LD_INT 81
16176: PPUSH
16177: LD_INT 127
16179: PPUSH
16180: CALL_OW 84
// amount := 5 ;
16184: LD_ADDR_VAR 0 8
16188: PUSH
16189: LD_INT 5
16191: ST_TO_ADDR
// macmilan_squad := [ ] ;
16192: LD_ADDR_VAR 0 9
16196: PUSH
16197: EMPTY
16198: ST_TO_ADDR
// if vip < amount then
16199: LD_EXP 58
16203: PUSH
16204: LD_VAR 0 8
16208: LESS
16209: IFFALSE 16253
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16211: LD_ADDR_VAR 0 5
16215: PUSH
16216: LD_EXP 58
16220: PUSH
16221: LD_INT 22
16223: PUSH
16224: LD_INT 4
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 21
16233: PUSH
16234: LD_INT 1
16236: PUSH
16237: EMPTY
16238: LIST
16239: LIST
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PPUSH
16245: CALL_OW 69
16249: UNION
16250: ST_TO_ADDR
16251: GO 16263
// tmp := vip ;
16253: LD_ADDR_VAR 0 5
16257: PUSH
16258: LD_EXP 58
16262: ST_TO_ADDR
// tmp := tmp diff Powell ;
16263: LD_ADDR_VAR 0 5
16267: PUSH
16268: LD_VAR 0 5
16272: PUSH
16273: LD_EXP 57
16277: DIFF
16278: ST_TO_ADDR
// if tmp < amount then
16279: LD_VAR 0 5
16283: PUSH
16284: LD_VAR 0 8
16288: LESS
16289: IFFALSE 16301
// amount := tmp ;
16291: LD_ADDR_VAR 0 8
16295: PUSH
16296: LD_VAR 0 5
16300: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16301: LD_VAR 0 5
16305: PUSH
16306: LD_INT 1
16308: ARRAY
16309: PPUSH
16310: CALL_OW 257
16314: PUSH
16315: LD_INT 2
16317: NONEQUAL
16318: IFFALSE 16380
// begin if IsInUnit ( tmp [ 1 ] ) then
16320: LD_VAR 0 5
16324: PUSH
16325: LD_INT 1
16327: ARRAY
16328: PPUSH
16329: CALL_OW 310
16333: IFFALSE 16348
// ComExitBuilding ( tmp [ 1 ] ) ;
16335: LD_VAR 0 5
16339: PUSH
16340: LD_INT 1
16342: ARRAY
16343: PPUSH
16344: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16348: LD_VAR 0 5
16352: PUSH
16353: LD_INT 1
16355: ARRAY
16356: PPUSH
16357: LD_INT 387
16359: PPUSH
16360: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16364: LD_VAR 0 5
16368: PUSH
16369: LD_INT 1
16371: ARRAY
16372: PPUSH
16373: LD_INT 2
16375: PPUSH
16376: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16380: LD_EXP 38
16384: PPUSH
16385: LD_INT 82
16387: PPUSH
16388: LD_INT 129
16390: PPUSH
16391: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16395: LD_EXP 38
16399: PPUSH
16400: LD_EXP 57
16404: PPUSH
16405: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16409: LD_INT 22
16411: PUSH
16412: LD_INT 1
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PPUSH
16419: CALL_OW 69
16423: PUSH
16424: LD_EXP 38
16428: DIFF
16429: PPUSH
16430: LD_INT 84
16432: PPUSH
16433: LD_INT 128
16435: PPUSH
16436: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16440: LD_INT 22
16442: PUSH
16443: LD_INT 1
16445: PUSH
16446: EMPTY
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_EXP 38
16459: DIFF
16460: PPUSH
16461: LD_EXP 38
16465: PPUSH
16466: CALL_OW 179
// for i = 1 to amount do
16470: LD_ADDR_VAR 0 2
16474: PUSH
16475: DOUBLE
16476: LD_INT 1
16478: DEC
16479: ST_TO_ADDR
16480: LD_VAR 0 8
16484: PUSH
16485: FOR_TO
16486: IFFALSE 16654
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16488: LD_ADDR_VAR 0 9
16492: PUSH
16493: LD_VAR 0 9
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_VAR 0 2
16507: ARRAY
16508: ADD
16509: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16510: LD_VAR 0 5
16514: PUSH
16515: LD_VAR 0 2
16519: ARRAY
16520: PPUSH
16521: CALL_OW 310
16525: IFFALSE 16542
// AddComExitBuilding ( tmp [ i ] ) ;
16527: LD_VAR 0 5
16531: PUSH
16532: LD_VAR 0 2
16536: ARRAY
16537: PPUSH
16538: CALL_OW 182
// if i = 2 and JMMNewVeh then
16542: LD_VAR 0 2
16546: PUSH
16547: LD_INT 2
16549: EQUAL
16550: PUSH
16551: LD_EXP 55
16555: AND
16556: IFFALSE 16614
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16558: LD_VAR 0 5
16562: PUSH
16563: LD_VAR 0 2
16567: ARRAY
16568: PPUSH
16569: LD_EXP 55
16573: PPUSH
16574: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_VAR 0 2
16587: ARRAY
16588: PPUSH
16589: LD_INT 86
16591: PPUSH
16592: LD_INT 133
16594: PPUSH
16595: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16599: LD_VAR 0 5
16603: PUSH
16604: LD_VAR 0 2
16608: ARRAY
16609: PPUSH
16610: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16614: LD_VAR 0 5
16618: PUSH
16619: LD_VAR 0 2
16623: ARRAY
16624: PPUSH
16625: LD_INT 8
16627: PPUSH
16628: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16632: LD_VAR 0 5
16636: PUSH
16637: LD_VAR 0 2
16641: ARRAY
16642: PPUSH
16643: LD_EXP 38
16647: PPUSH
16648: CALL_OW 179
// end ;
16652: GO 16485
16654: POP
16655: POP
// if GirlNewVeh then
16656: LD_EXP 56
16660: IFFALSE 16674
// SetSide ( GirlNewVeh , 4 ) ;
16662: LD_EXP 56
16666: PPUSH
16667: LD_INT 4
16669: PPUSH
16670: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16674: LD_INT 35
16676: PPUSH
16677: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16681: LD_VAR 0 9
16685: PPUSH
16686: LD_INT 95
16688: PUSH
16689: LD_INT 9
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PPUSH
16696: CALL_OW 72
16700: PUSH
16701: LD_INT 0
16703: EQUAL
16704: PUSH
16705: LD_EXP 38
16709: PPUSH
16710: LD_INT 9
16712: PPUSH
16713: CALL_OW 308
16717: NOT
16718: AND
16719: IFFALSE 16674
// wait ( 0 0$2 ) ;
16721: LD_INT 70
16723: PPUSH
16724: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16728: LD_VAR 0 9
16732: PPUSH
16733: LD_INT 1
16735: PPUSH
16736: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16740: LD_INT 21
16742: PUSH
16743: LD_INT 2
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: PUSH
16750: LD_INT 92
16752: PUSH
16753: LD_INT 83
16755: PUSH
16756: LD_INT 130
16758: PUSH
16759: LD_INT 10
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PPUSH
16772: CALL_OW 69
16776: PPUSH
16777: LD_INT 1
16779: PPUSH
16780: CALL_OW 235
// Video ( false ) ;
16784: LD_INT 0
16786: PPUSH
16787: CALL 107121 0 1
// ChangeMissionObjectives ( M1 ) ;
16791: LD_STRING M1
16793: PPUSH
16794: CALL_OW 337
// SaveForQuickRestart ;
16798: CALL_OW 22
// missionStart := true ;
16802: LD_ADDR_EXP 13
16806: PUSH
16807: LD_INT 1
16809: ST_TO_ADDR
// missionStage := 2 ;
16810: LD_ADDR_EXP 15
16814: PUSH
16815: LD_INT 2
16817: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16818: LD_INT 105
16820: PPUSH
16821: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16825: LD_ADDR_VAR 0 5
16829: PUSH
16830: LD_INT 22
16832: PUSH
16833: LD_INT 4
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 21
16842: PUSH
16843: LD_INT 1
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 69
16858: PUSH
16859: LD_EXP 57
16863: DIFF
16864: ST_TO_ADDR
// if not tmp then
16865: LD_VAR 0 5
16869: NOT
16870: IFFALSE 16885
// tmp := [ Powell ] ;
16872: LD_ADDR_VAR 0 5
16876: PUSH
16877: LD_EXP 57
16881: PUSH
16882: EMPTY
16883: LIST
16884: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16885: LD_ADDR_EXP 101
16889: PUSH
16890: LD_EXP 101
16894: PPUSH
16895: LD_INT 4
16897: PPUSH
16898: LD_INT 22
16900: PUSH
16901: LD_INT 4
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 23
16910: PUSH
16911: LD_INT 1
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: LD_INT 21
16923: PUSH
16924: LD_INT 2
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: LIST
16939: PPUSH
16940: CALL_OW 69
16944: PUSH
16945: LD_EXP 57
16949: DIFF
16950: PPUSH
16951: CALL_OW 1
16955: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16956: LD_ADDR_VAR 0 4
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 4
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 34
16973: PUSH
16974: LD_INT 12
16976: PUSH
16977: EMPTY
16978: LIST
16979: LIST
16980: PUSH
16981: EMPTY
16982: LIST
16983: LIST
16984: PPUSH
16985: CALL_OW 69
16989: PUSH
16990: LD_INT 1
16992: ARRAY
16993: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16994: LD_VAR 0 5
16998: PUSH
16999: LD_INT 1
17001: ARRAY
17002: PPUSH
17003: CALL_OW 310
17007: IFFALSE 17022
// ComExitBuilding ( tmp [ 1 ] ) ;
17009: LD_VAR 0 5
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17022: LD_VAR 0 5
17026: PUSH
17027: LD_INT 1
17029: ARRAY
17030: PPUSH
17031: LD_VAR 0 4
17035: PPUSH
17036: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17040: LD_VAR 0 5
17044: PUSH
17045: LD_INT 1
17047: ARRAY
17048: PPUSH
17049: LD_INT 80
17051: PPUSH
17052: LD_INT 136
17054: PPUSH
17055: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17059: LD_VAR 0 5
17063: PUSH
17064: LD_INT 1
17066: ARRAY
17067: PPUSH
17068: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17072: LD_VAR 0 5
17076: PUSH
17077: LD_INT 1
17079: ARRAY
17080: PPUSH
17081: LD_INT 59
17083: PPUSH
17084: LD_INT 112
17086: PPUSH
17087: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17091: LD_VAR 0 5
17095: PUSH
17096: LD_INT 1
17098: ARRAY
17099: PPUSH
17100: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17104: LD_EXP 39
17108: PUSH
17109: LD_EXP 39
17113: PPUSH
17114: CALL_OW 255
17118: PUSH
17119: LD_INT 1
17121: EQUAL
17122: AND
17123: IFFALSE 17149
// begin Say ( Joan , D3W-Joan-1 ) ;
17125: LD_EXP 39
17129: PPUSH
17130: LD_STRING D3W-Joan-1
17132: PPUSH
17133: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17137: LD_EXP 38
17141: PPUSH
17142: LD_STRING D3W-JMM-1
17144: PPUSH
17145: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17149: LD_EXP 41
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: PUSH
17169: LD_EXP 41
17173: PUSH
17174: LD_EXP 58
17178: IN
17179: NOT
17180: AND
17181: IFFALSE 17207
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17183: LD_EXP 41
17187: PPUSH
17188: LD_STRING D3W-Lisa-1
17190: PPUSH
17191: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17195: LD_EXP 38
17199: PPUSH
17200: LD_STRING D3W-JMM-1
17202: PPUSH
17203: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17207: LD_EXP 53
17211: PUSH
17212: LD_EXP 53
17216: PPUSH
17217: CALL_OW 255
17221: PUSH
17222: LD_INT 1
17224: EQUAL
17225: AND
17226: IFFALSE 17252
// begin Say ( Connie , D3W-Con-1 ) ;
17228: LD_EXP 53
17232: PPUSH
17233: LD_STRING D3W-Con-1
17235: PPUSH
17236: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17240: LD_EXP 38
17244: PPUSH
17245: LD_STRING D3W-JMM-1
17247: PPUSH
17248: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17252: LD_EXP 41
17256: PUSH
17257: LD_EXP 58
17261: IN
17262: PUSH
17263: LD_EXP 41
17267: PPUSH
17268: CALL_OW 255
17272: PUSH
17273: LD_INT 1
17275: EQUAL
17276: AND
17277: IFFALSE 17293
// Say ( Lisa , D3nW-Lisa-1 ) else
17279: LD_EXP 41
17283: PPUSH
17284: LD_STRING D3nW-Lisa-1
17286: PPUSH
17287: CALL_OW 88
17291: GO 17537
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17293: LD_EXP 44
17297: PUSH
17298: LD_EXP 58
17302: IN
17303: PUSH
17304: LD_EXP 44
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: IFFALSE 17334
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17320: LD_EXP 44
17324: PPUSH
17325: LD_STRING D3nW-Cyrus-1
17327: PPUSH
17328: CALL_OW 88
17332: GO 17537
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17334: LD_EXP 43
17338: PUSH
17339: LD_EXP 58
17343: IN
17344: PUSH
17345: LD_EXP 43
17349: PPUSH
17350: CALL_OW 255
17354: PUSH
17355: LD_INT 1
17357: EQUAL
17358: AND
17359: IFFALSE 17375
// Say ( Bobby , D3nW-Bobby-1 ) else
17361: LD_EXP 43
17365: PPUSH
17366: LD_STRING D3nW-Bobby-1
17368: PPUSH
17369: CALL_OW 88
17373: GO 17537
// if Gary in vip and GetSide ( Gary ) = 1 then
17375: LD_EXP 50
17379: PUSH
17380: LD_EXP 58
17384: IN
17385: PUSH
17386: LD_EXP 50
17390: PPUSH
17391: CALL_OW 255
17395: PUSH
17396: LD_INT 1
17398: EQUAL
17399: AND
17400: IFFALSE 17416
// Say ( Gary , D3nW-Gary-1 ) else
17402: LD_EXP 50
17406: PPUSH
17407: LD_STRING D3nW-Gary-1
17409: PPUSH
17410: CALL_OW 88
17414: GO 17537
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17416: LD_EXP 42
17420: PUSH
17421: LD_EXP 58
17425: IN
17426: PUSH
17427: LD_EXP 42
17431: PPUSH
17432: CALL_OW 255
17436: PUSH
17437: LD_INT 1
17439: EQUAL
17440: AND
17441: IFFALSE 17457
// Say ( Donaldson , D3nW-Don-1 ) else
17443: LD_EXP 42
17447: PPUSH
17448: LD_STRING D3nW-Don-1
17450: PPUSH
17451: CALL_OW 88
17455: GO 17537
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17457: LD_EXP 49
17461: PUSH
17462: LD_EXP 58
17466: IN
17467: PUSH
17468: LD_EXP 49
17472: PPUSH
17473: CALL_OW 255
17477: PUSH
17478: LD_INT 1
17480: EQUAL
17481: AND
17482: IFFALSE 17498
// Say ( Cornel , D3nW-Corn-1 ) else
17484: LD_EXP 49
17488: PPUSH
17489: LD_STRING D3nW-Corn-1
17491: PPUSH
17492: CALL_OW 88
17496: GO 17537
// if Frank in vip and GetSide ( Frank ) = 1 then
17498: LD_EXP 51
17502: PUSH
17503: LD_EXP 58
17507: IN
17508: PUSH
17509: LD_EXP 51
17513: PPUSH
17514: CALL_OW 255
17518: PUSH
17519: LD_INT 1
17521: EQUAL
17522: AND
17523: IFFALSE 17537
// Say ( Frank , D3nW-Frank-1 ) ;
17525: LD_EXP 51
17529: PPUSH
17530: LD_STRING D3nW-Frank-1
17532: PPUSH
17533: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17537: LD_EXP 58
17541: PPUSH
17542: LD_INT 22
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 72
17556: IFFALSE 17582
// begin Say ( JMM , D3nW-JMM-1 ) ;
17558: LD_EXP 38
17562: PPUSH
17563: LD_STRING D3nW-JMM-1
17565: PPUSH
17566: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17570: LD_EXP 38
17574: PPUSH
17575: LD_STRING D3nW-JMM-1a
17577: PPUSH
17578: CALL_OW 88
// end ; t := 0 0$00 ;
17582: LD_ADDR_VAR 0 3
17586: PUSH
17587: LD_INT 0
17589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17590: LD_INT 35
17592: PPUSH
17593: CALL_OW 67
// t := t + 0 0$1 ;
17597: LD_ADDR_VAR 0 3
17601: PUSH
17602: LD_VAR 0 3
17606: PUSH
17607: LD_INT 35
17609: PLUS
17610: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17611: LD_INT 59
17613: PPUSH
17614: LD_INT 112
17616: PPUSH
17617: CALL_OW 428
17621: PUSH
17622: LD_VAR 0 3
17626: PUSH
17627: LD_INT 2100
17629: GREATER
17630: OR
17631: IFFALSE 17590
// activeAttacks := true ;
17633: LD_ADDR_EXP 16
17637: PUSH
17638: LD_INT 1
17640: ST_TO_ADDR
// end ;
17641: LD_VAR 0 1
17645: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17646: LD_INT 0
17648: PPUSH
// case question of 1 :
17649: LD_VAR 0 1
17653: PUSH
17654: LD_INT 1
17656: DOUBLE
17657: EQUAL
17658: IFTRUE 17662
17660: GO 17713
17662: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17663: LD_EXP 38
17667: PPUSH
17668: LD_STRING D2Mot-JMM-1
17670: PPUSH
17671: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17675: LD_EXP 57
17679: PPUSH
17680: LD_STRING D2Mot-Pow-1
17682: PPUSH
17683: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17687: LD_EXP 38
17691: PPUSH
17692: LD_STRING D2Mot-JMM-2
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17699: LD_EXP 57
17703: PPUSH
17704: LD_STRING D2Mot-Pow-2
17706: PPUSH
17707: CALL_OW 88
// end ; 2 :
17711: GO 18064
17713: LD_INT 2
17715: DOUBLE
17716: EQUAL
17717: IFTRUE 17721
17719: GO 17797
17721: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17722: LD_EXP 38
17726: PPUSH
17727: LD_STRING D2Rus-JMM-1
17729: PPUSH
17730: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17734: LD_EXP 57
17738: PPUSH
17739: LD_STRING D2Rus-Pow-1
17741: PPUSH
17742: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17746: LD_EXP 38
17750: PPUSH
17751: LD_STRING D2Rus-JMM-2
17753: PPUSH
17754: CALL_OW 88
// if not ( 3 in list_of_q ) then
17758: LD_INT 3
17760: PUSH
17761: LD_VAR 0 2
17765: IN
17766: NOT
17767: IFFALSE 17783
// Say ( Powell , D2Rus-Pow-2 ) else
17769: LD_EXP 57
17773: PPUSH
17774: LD_STRING D2Rus-Pow-2
17776: PPUSH
17777: CALL_OW 88
17781: GO 17795
// Say ( Powell , D2Rus-Pow-2a ) ;
17783: LD_EXP 57
17787: PPUSH
17788: LD_STRING D2Rus-Pow-2a
17790: PPUSH
17791: CALL_OW 88
// end ; 3 :
17795: GO 18064
17797: LD_INT 3
17799: DOUBLE
17800: EQUAL
17801: IFTRUE 17805
17803: GO 17890
17805: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17806: LD_EXP 38
17810: PPUSH
17811: LD_STRING D2Leg-JMM-1
17813: PPUSH
17814: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17818: LD_EXP 57
17822: PPUSH
17823: LD_STRING D2Leg-Pow-1
17825: PPUSH
17826: CALL_OW 88
// if 2 in list_of_q then
17830: LD_INT 2
17832: PUSH
17833: LD_VAR 0 2
17837: IN
17838: IFFALSE 17864
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17840: LD_EXP 38
17844: PPUSH
17845: LD_STRING D2Leg-JMM-2
17847: PPUSH
17848: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17852: LD_EXP 57
17856: PPUSH
17857: LD_STRING D2Leg-Pow-2
17859: PPUSH
17860: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17864: LD_EXP 38
17868: PPUSH
17869: LD_STRING D2Leg-JMM-3
17871: PPUSH
17872: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17876: LD_EXP 57
17880: PPUSH
17881: LD_STRING D2Leg-Pow-3
17883: PPUSH
17884: CALL_OW 88
// end ; 4 :
17888: GO 18064
17890: LD_INT 4
17892: DOUBLE
17893: EQUAL
17894: IFTRUE 17898
17896: GO 17973
17898: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17899: LD_EXP 38
17903: PPUSH
17904: LD_STRING D2Ar-JMM-1
17906: PPUSH
17907: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17911: LD_EXP 57
17915: PPUSH
17916: LD_STRING D2Ar-Pow-1
17918: PPUSH
17919: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17923: LD_EXP 38
17927: PPUSH
17928: LD_STRING D2Ar-JMM-2
17930: PPUSH
17931: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17935: LD_EXP 57
17939: PPUSH
17940: LD_STRING D2Ar-Pow-2
17942: PPUSH
17943: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17947: LD_EXP 38
17951: PPUSH
17952: LD_STRING D2Ar-JMM-3
17954: PPUSH
17955: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17959: LD_EXP 57
17963: PPUSH
17964: LD_STRING D2Ar-Pow-3
17966: PPUSH
17967: CALL_OW 88
// end ; 5 :
17971: GO 18064
17973: LD_INT 5
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17996
17981: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17982: LD_EXP 38
17986: PPUSH
17987: LD_STRING D2Conf-JMM-1
17989: PPUSH
17990: CALL_OW 88
17994: GO 18064
17996: LD_INT 6
17998: DOUBLE
17999: EQUAL
18000: IFTRUE 18004
18002: GO 18063
18004: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18005: LD_EXP 38
18009: PPUSH
18010: LD_STRING D2Com-JMM-1
18012: PPUSH
18013: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18017: LD_EXP 57
18021: PPUSH
18022: LD_STRING D2Com-Pow-1
18024: PPUSH
18025: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18029: LD_EXP 38
18033: PPUSH
18034: LD_STRING D2Com-JMM-2
18036: PPUSH
18037: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18041: LD_EXP 57
18045: PPUSH
18046: LD_STRING D2Com-Pow-2
18048: PPUSH
18049: CALL_OW 88
// powellAngerQuery := true ;
18053: LD_ADDR_EXP 36
18057: PUSH
18058: LD_INT 1
18060: ST_TO_ADDR
// end ; end ;
18061: GO 18064
18063: POP
// end ;
18064: LD_VAR 0 3
18068: RET
// every 0 0$5 trigger missionStart do var tmp ;
18069: LD_EXP 13
18073: IFFALSE 18356
18075: GO 18077
18077: DISABLE
18078: LD_INT 0
18080: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18081: LD_INT 35
18083: PPUSH
18084: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18088: LD_INT 14
18090: PPUSH
18091: LD_INT 22
18093: PUSH
18094: LD_INT 1
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PPUSH
18101: CALL_OW 70
18105: PUSH
18106: LD_EXP 15
18110: PUSH
18111: LD_INT 2
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 4
18119: PUSH
18120: LD_INT 5
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: IN
18129: AND
18130: IFFALSE 18346
// begin powellAnger := powellAnger + 1 ;
18132: LD_ADDR_EXP 17
18136: PUSH
18137: LD_EXP 17
18141: PUSH
18142: LD_INT 1
18144: PLUS
18145: ST_TO_ADDR
// Video ( true ) ;
18146: LD_INT 1
18148: PPUSH
18149: CALL 107121 0 1
// CenterNowOnUnits ( tmp ) ;
18153: LD_VAR 0 1
18157: PPUSH
18158: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18162: LD_INT 14
18164: PPUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PPUSH
18175: CALL_OW 70
18179: PPUSH
18180: LD_INT 86
18182: PPUSH
18183: LD_INT 133
18185: PPUSH
18186: CALL_OW 111
// async ;
18190: ASYNC
// case powellAnger of 1 :
18191: LD_EXP 17
18195: PUSH
18196: LD_INT 1
18198: DOUBLE
18199: EQUAL
18200: IFTRUE 18204
18202: GO 18219
18204: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18205: LD_EXP 57
18209: PPUSH
18210: LD_STRING DBack1-Pow-1
18212: PPUSH
18213: CALL_OW 88
18217: GO 18266
18219: LD_INT 2
18221: DOUBLE
18222: EQUAL
18223: IFTRUE 18227
18225: GO 18242
18227: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18228: LD_EXP 57
18232: PPUSH
18233: LD_STRING DBack2-Pow-1
18235: PPUSH
18236: CALL_OW 88
18240: GO 18266
18242: LD_INT 3
18244: DOUBLE
18245: EQUAL
18246: IFTRUE 18250
18248: GO 18265
18250: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18251: LD_EXP 57
18255: PPUSH
18256: LD_STRING DBack3-Pow-1
18258: PPUSH
18259: CALL_OW 88
18263: GO 18266
18265: POP
// sync ;
18266: SYNC
// repeat wait ( 0 0$1 ) ;
18267: LD_INT 35
18269: PPUSH
18270: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18274: LD_INT 14
18276: PPUSH
18277: LD_INT 22
18279: PUSH
18280: LD_INT 1
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PPUSH
18287: CALL_OW 70
18291: PPUSH
18292: LD_INT 86
18294: PPUSH
18295: LD_INT 133
18297: PPUSH
18298: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18302: LD_INT 14
18304: PPUSH
18305: LD_INT 22
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PPUSH
18315: CALL_OW 70
18319: NOT
18320: IFFALSE 18267
// if powellAnger >= 3 then
18322: LD_EXP 17
18326: PUSH
18327: LD_INT 3
18329: GREATEREQUAL
18330: IFFALSE 18339
// YouLost ( Dismissed ) ;
18332: LD_STRING Dismissed
18334: PPUSH
18335: CALL_OW 104
// Video ( false ) ;
18339: LD_INT 0
18341: PPUSH
18342: CALL 107121 0 1
// end ; until missionStage > 5 ;
18346: LD_EXP 15
18350: PUSH
18351: LD_INT 5
18353: GREATER
18354: IFFALSE 18081
// end ;
18356: PPOPN 1
18358: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18359: LD_EXP 13
18363: PUSH
18364: LD_INT 22
18366: PUSH
18367: LD_INT 4
18369: PUSH
18370: EMPTY
18371: LIST
18372: LIST
18373: PUSH
18374: LD_INT 21
18376: PUSH
18377: LD_INT 2
18379: PUSH
18380: EMPTY
18381: LIST
18382: LIST
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: PPUSH
18388: CALL_OW 69
18392: PUSH
18393: LD_INT 4
18395: GREATEREQUAL
18396: AND
18397: PUSH
18398: LD_EXP 15
18402: PUSH
18403: LD_INT 2
18405: EQUAL
18406: AND
18407: IFFALSE 20230
18409: GO 18411
18411: DISABLE
18412: LD_INT 0
18414: PPUSH
18415: PPUSH
18416: PPUSH
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
18421: PPUSH
// begin missionStage := 3 ;
18422: LD_ADDR_EXP 15
18426: PUSH
18427: LD_INT 3
18429: ST_TO_ADDR
// retreat := false ;
18430: LD_ADDR_VAR 0 4
18434: PUSH
18435: LD_INT 0
18437: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18438: LD_ADDR_VAR 0 5
18442: PUSH
18443: LD_INT 22
18445: PUSH
18446: LD_INT 4
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 30
18455: PUSH
18456: LD_INT 4
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PPUSH
18467: CALL_OW 69
18471: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18472: LD_ADDR_VAR 0 6
18476: PUSH
18477: LD_INT 22
18479: PUSH
18480: LD_INT 4
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: LD_INT 30
18489: PUSH
18490: LD_INT 5
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: PUSH
18497: EMPTY
18498: LIST
18499: LIST
18500: PPUSH
18501: CALL_OW 69
18505: ST_TO_ADDR
// if not bar then
18506: LD_VAR 0 6
18510: NOT
18511: IFFALSE 18564
// begin repeat wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18520: LD_INT 22
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 3
18532: PUSH
18533: LD_INT 57
18535: PUSH
18536: EMPTY
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PUSH
18543: LD_INT 30
18545: PUSH
18546: LD_INT 5
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: LIST
18557: PPUSH
18558: CALL_OW 69
18562: IFFALSE 18513
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18564: LD_ADDR_VAR 0 6
18568: PUSH
18569: LD_INT 22
18571: PUSH
18572: LD_INT 4
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 30
18581: PUSH
18582: LD_INT 5
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PPUSH
18593: CALL_OW 69
18597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18598: LD_INT 35
18600: PPUSH
18601: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18605: LD_EXP 120
18609: PUSH
18610: LD_INT 4
18612: ARRAY
18613: PUSH
18614: LD_INT 4
18616: GREATEREQUAL
18617: IFFALSE 18598
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18619: LD_ADDR_VAR 0 2
18623: PUSH
18624: LD_INT 22
18626: PUSH
18627: LD_INT 4
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: PUSH
18634: LD_INT 2
18636: PUSH
18637: LD_INT 25
18639: PUSH
18640: LD_INT 1
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 25
18649: PUSH
18650: LD_INT 2
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: LD_INT 25
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 25
18669: PUSH
18670: LD_INT 4
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 25
18679: PUSH
18680: LD_INT 5
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PPUSH
18699: CALL_OW 69
18703: PUSH
18704: LD_EXP 57
18708: PUSH
18709: LD_EXP 58
18713: ADD
18714: DIFF
18715: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18716: LD_ADDR_VAR 0 3
18720: PUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_INT 26
18728: PUSH
18729: LD_INT 1
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: PPUSH
18736: CALL_OW 72
18740: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18741: LD_ADDR_VAR 0 2
18745: PUSH
18746: LD_VAR 0 2
18750: PUSH
18751: LD_VAR 0 3
18755: DIFF
18756: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18757: LD_ADDR_VAR 0 2
18761: PUSH
18762: LD_VAR 0 2
18766: PPUSH
18767: LD_INT 1
18769: PPUSH
18770: CALL 105774 0 2
18774: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_VAR 0 3
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL 105774 0 2
18792: ST_TO_ADDR
// for i = 1 to 4 do
18793: LD_ADDR_VAR 0 1
18797: PUSH
18798: DOUBLE
18799: LD_INT 1
18801: DEC
18802: ST_TO_ADDR
18803: LD_INT 4
18805: PUSH
18806: FOR_TO
18807: IFFALSE 18973
// begin if tmp2 then
18809: LD_VAR 0 3
18813: IFFALSE 18894
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18815: LD_ADDR_EXP 18
18819: PUSH
18820: LD_EXP 18
18824: PPUSH
18825: LD_INT 1
18827: PPUSH
18828: LD_EXP 18
18832: PUSH
18833: LD_INT 1
18835: ARRAY
18836: PUSH
18837: LD_VAR 0 3
18841: PUSH
18842: LD_VAR 0 3
18846: ARRAY
18847: ADD
18848: PPUSH
18849: CALL_OW 1
18853: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18854: LD_VAR 0 3
18858: PUSH
18859: LD_VAR 0 3
18863: ARRAY
18864: PPUSH
18865: LD_INT 1
18867: PPUSH
18868: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18872: LD_ADDR_VAR 0 3
18876: PUSH
18877: LD_VAR 0 3
18881: PPUSH
18882: LD_VAR 0 3
18886: PPUSH
18887: CALL_OW 3
18891: ST_TO_ADDR
// end else
18892: GO 18971
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18894: LD_ADDR_EXP 18
18898: PUSH
18899: LD_EXP 18
18903: PPUSH
18904: LD_INT 1
18906: PPUSH
18907: LD_EXP 18
18911: PUSH
18912: LD_INT 1
18914: ARRAY
18915: PUSH
18916: LD_VAR 0 2
18920: PUSH
18921: LD_VAR 0 2
18925: ARRAY
18926: ADD
18927: PPUSH
18928: CALL_OW 1
18932: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18933: LD_VAR 0 2
18937: PUSH
18938: LD_VAR 0 2
18942: ARRAY
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18951: LD_ADDR_VAR 0 2
18955: PUSH
18956: LD_VAR 0 2
18960: PPUSH
18961: LD_VAR 0 2
18965: PPUSH
18966: CALL_OW 3
18970: ST_TO_ADDR
// end ; end ;
18971: GO 18806
18973: POP
18974: POP
// if tmp2 then
18975: LD_VAR 0 3
18979: IFFALSE 18997
// tmp := tmp union tmp2 ;
18981: LD_ADDR_VAR 0 2
18985: PUSH
18986: LD_VAR 0 2
18990: PUSH
18991: LD_VAR 0 3
18995: UNION
18996: ST_TO_ADDR
// for i = 1 to 4 do
18997: LD_ADDR_VAR 0 1
19001: PUSH
19002: DOUBLE
19003: LD_INT 1
19005: DEC
19006: ST_TO_ADDR
19007: LD_INT 4
19009: PUSH
19010: FOR_TO
19011: IFFALSE 19060
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19013: LD_ADDR_EXP 18
19017: PUSH
19018: LD_EXP 18
19022: PPUSH
19023: LD_INT 2
19025: PPUSH
19026: LD_EXP 18
19030: PUSH
19031: LD_INT 2
19033: ARRAY
19034: PUSH
19035: LD_VAR 0 2
19039: PUSH
19040: LD_VAR 0 2
19044: PUSH
19045: LD_VAR 0 1
19049: MINUS
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
19058: GO 19010
19060: POP
19061: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19062: LD_ADDR_EXP 101
19066: PUSH
19067: LD_EXP 101
19071: PPUSH
19072: LD_INT 4
19074: PPUSH
19075: LD_EXP 101
19079: PUSH
19080: LD_INT 4
19082: ARRAY
19083: PUSH
19084: LD_EXP 18
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: DIFF
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19099: LD_VAR 0 5
19103: PUSH
19104: LD_INT 1
19106: ARRAY
19107: PPUSH
19108: CALL_OW 313
19112: IFFALSE 19167
// begin for i in UnitsInside ( arm [ 1 ] ) do
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_VAR 0 5
19123: PUSH
19124: LD_INT 1
19126: ARRAY
19127: PPUSH
19128: CALL_OW 313
19132: PUSH
19133: FOR_IN
19134: IFFALSE 19165
// begin ComExitBuilding ( i ) ;
19136: LD_VAR 0 1
19140: PPUSH
19141: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19145: LD_VAR 0 1
19149: PPUSH
19150: LD_VAR 0 6
19154: PUSH
19155: LD_INT 1
19157: ARRAY
19158: PPUSH
19159: CALL_OW 180
// end ;
19163: GO 19133
19165: POP
19166: POP
// end ; wait ( 0 0$3 ) ;
19167: LD_INT 105
19169: PPUSH
19170: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_EXP 18
19183: PUSH
19184: LD_INT 1
19186: ARRAY
19187: PUSH
19188: FOR_IN
19189: IFFALSE 19296
// begin if IsInUnit ( i ) then
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 310
19200: IFFALSE 19211
// ComExitBuilding ( i ) ;
19202: LD_VAR 0 1
19206: PPUSH
19207: CALL_OW 122
// if GetClass ( i ) <> 1 then
19211: LD_VAR 0 1
19215: PPUSH
19216: CALL_OW 257
19220: PUSH
19221: LD_INT 1
19223: NONEQUAL
19224: IFFALSE 19265
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19226: LD_VAR 0 1
19230: PPUSH
19231: LD_VAR 0 5
19235: PUSH
19236: LD_INT 1
19238: ARRAY
19239: PPUSH
19240: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_INT 1
19251: PPUSH
19252: CALL_OW 183
// AddComExitBuilding ( i ) ;
19256: LD_VAR 0 1
19260: PPUSH
19261: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19265: LD_VAR 0 1
19269: PPUSH
19270: LD_INT 60
19272: PPUSH
19273: LD_INT 94
19275: PPUSH
19276: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19280: LD_VAR 0 1
19284: PPUSH
19285: LD_EXP 57
19289: PPUSH
19290: CALL_OW 179
// end ;
19294: GO 19188
19296: POP
19297: POP
// wait ( 0 0$15 ) ;
19298: LD_INT 525
19300: PPUSH
19301: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19305: LD_EXP 57
19309: PPUSH
19310: LD_STRING D4-Pow-1
19312: PPUSH
19313: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19317: LD_ADDR_VAR 0 2
19321: PUSH
19322: LD_EXP 18
19326: PUSH
19327: LD_INT 1
19329: ARRAY
19330: PPUSH
19331: LD_INT 26
19333: PUSH
19334: LD_INT 1
19336: PUSH
19337: EMPTY
19338: LIST
19339: LIST
19340: PPUSH
19341: CALL_OW 72
19345: ST_TO_ADDR
// if tmp then
19346: LD_VAR 0 2
19350: IFFALSE 19368
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19352: LD_VAR 0 2
19356: PUSH
19357: LD_INT 1
19359: ARRAY
19360: PPUSH
19361: LD_STRING D4-Sol1-1
19363: PPUSH
19364: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19368: LD_EXP 57
19372: PPUSH
19373: LD_STRING D4-Pow-2
19375: PPUSH
19376: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19380: LD_ADDR_VAR 0 1
19384: PUSH
19385: DOUBLE
19386: LD_INT 1
19388: DEC
19389: ST_TO_ADDR
19390: LD_EXP 18
19394: PUSH
19395: LD_INT 1
19397: ARRAY
19398: PUSH
19399: FOR_TO
19400: IFFALSE 19493
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19402: LD_EXP 18
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_VAR 0 1
19415: ARRAY
19416: PPUSH
19417: LD_EXP 120
19421: PUSH
19422: LD_INT 4
19424: ARRAY
19425: PUSH
19426: LD_INT 1
19428: ARRAY
19429: PPUSH
19430: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19434: LD_ADDR_EXP 120
19438: PUSH
19439: LD_EXP 120
19443: PPUSH
19444: LD_INT 4
19446: PPUSH
19447: LD_EXP 120
19451: PUSH
19452: LD_INT 4
19454: ARRAY
19455: PPUSH
19456: LD_INT 1
19458: PPUSH
19459: CALL_OW 3
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19469: LD_INT 8
19471: PPUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PUSH
19481: LD_VAR 0 1
19485: ARRAY
19486: PPUSH
19487: CALL_OW 471
// end ;
19491: GO 19399
19493: POP
19494: POP
// repeat wait ( 0 0$1 ) ;
19495: LD_INT 35
19497: PPUSH
19498: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19502: LD_EXP 18
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_INT 55
19513: PUSH
19514: EMPTY
19515: LIST
19516: PPUSH
19517: CALL_OW 72
19521: PUSH
19522: LD_INT 4
19524: GREATEREQUAL
19525: IFFALSE 19495
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PPUSH
19536: LD_INT 69
19538: PPUSH
19539: LD_INT 94
19541: PPUSH
19542: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19546: LD_EXP 18
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: LD_INT 82
19557: PPUSH
19558: LD_INT 83
19560: PPUSH
19561: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PPUSH
19574: LD_INT 77
19576: PPUSH
19577: LD_INT 69
19579: PPUSH
19580: CALL_OW 174
// repeat wait ( 3 ) ;
19584: LD_INT 3
19586: PPUSH
19587: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19591: LD_ADDR_VAR 0 1
19595: PUSH
19596: LD_EXP 18
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PUSH
19605: FOR_IN
19606: IFFALSE 19742
// begin if GetLives ( i ) < 990 then
19608: LD_VAR 0 1
19612: PPUSH
19613: CALL_OW 256
19617: PUSH
19618: LD_INT 990
19620: LESS
19621: IFFALSE 19635
// SetLives ( i , 1000 ) ;
19623: LD_VAR 0 1
19627: PPUSH
19628: LD_INT 1000
19630: PPUSH
19631: CALL_OW 234
// if not IsInUnit ( i ) then
19635: LD_VAR 0 1
19639: PPUSH
19640: CALL_OW 310
19644: NOT
19645: IFFALSE 19740
// begin if not HasTask ( i ) then
19647: LD_VAR 0 1
19651: PPUSH
19652: CALL_OW 314
19656: NOT
19657: IFFALSE 19674
// ComMoveXY ( i , 64 , 93 ) ;
19659: LD_VAR 0 1
19663: PPUSH
19664: LD_INT 64
19666: PPUSH
19667: LD_INT 93
19669: PPUSH
19670: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19674: LD_VAR 0 4
19678: NOT
19679: PUSH
19680: LD_VAR 0 1
19684: PPUSH
19685: CALL_OW 258
19689: PUSH
19690: LD_INT 1
19692: EQUAL
19693: AND
19694: IFFALSE 19740
// begin retreat := true ;
19696: LD_ADDR_VAR 0 4
19700: PUSH
19701: LD_INT 1
19703: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19704: LD_VAR 0 1
19708: PPUSH
19709: LD_INT 2
19711: PPUSH
19712: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19716: LD_VAR 0 1
19720: PPUSH
19721: LD_STRING D4a-Sol1-1
19723: PPUSH
19724: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19728: LD_EXP 57
19732: PPUSH
19733: LD_STRING D4a-Pow-1
19735: PPUSH
19736: CALL_OW 88
// end ; end ; end ;
19740: GO 19605
19742: POP
19743: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19744: LD_EXP 18
19748: PUSH
19749: LD_INT 1
19751: ARRAY
19752: PPUSH
19753: LD_INT 95
19755: PUSH
19756: LD_INT 9
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: LD_INT 55
19768: PUSH
19769: EMPTY
19770: LIST
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: PPUSH
19780: CALL_OW 72
19784: PUSH
19785: LD_INT 4
19787: GREATEREQUAL
19788: IFFALSE 19584
// for i in powellSquadAttack [ 1 ] do
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PUSH
19804: FOR_IN
19805: IFFALSE 19941
// begin if GetTag ( i ) = 2 then
19807: LD_VAR 0 1
19811: PPUSH
19812: CALL_OW 110
19816: PUSH
19817: LD_INT 2
19819: EQUAL
19820: IFFALSE 19882
// begin ComMoveXY ( i , 60 , 94 ) ;
19822: LD_VAR 0 1
19826: PPUSH
19827: LD_INT 60
19829: PPUSH
19830: LD_INT 94
19832: PPUSH
19833: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19837: LD_VAR 0 1
19841: PPUSH
19842: LD_EXP 57
19846: PPUSH
19847: CALL_OW 179
// wait ( 0 0$3 ) ;
19851: LD_INT 105
19853: PPUSH
19854: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19858: LD_VAR 0 1
19862: PPUSH
19863: LD_STRING D4a-Sol1-2
19865: PPUSH
19866: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19870: LD_EXP 57
19874: PPUSH
19875: LD_STRING D4a-Pow-2
19877: PPUSH
19878: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_INT 0
19889: PPUSH
19890: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19894: LD_ADDR_EXP 101
19898: PUSH
19899: LD_EXP 101
19903: PPUSH
19904: LD_INT 4
19906: PPUSH
19907: LD_EXP 101
19911: PUSH
19912: LD_INT 4
19914: ARRAY
19915: PUSH
19916: LD_VAR 0 1
19920: UNION
19921: PPUSH
19922: CALL_OW 1
19926: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19927: LD_INT 8
19929: PPUSH
19930: LD_VAR 0 1
19934: PPUSH
19935: CALL_OW 472
// end ;
19939: GO 19804
19941: POP
19942: POP
// wait ( 4 4$00 ) ;
19943: LD_INT 8400
19945: PPUSH
19946: CALL_OW 67
// uc_side := 6 ;
19950: LD_ADDR_OWVAR 20
19954: PUSH
19955: LD_INT 6
19957: ST_TO_ADDR
// uc_nation := 3 ;
19958: LD_ADDR_OWVAR 21
19962: PUSH
19963: LD_INT 3
19965: ST_TO_ADDR
// ru := [ ] ;
19966: LD_ADDR_VAR 0 7
19970: PUSH
19971: EMPTY
19972: ST_TO_ADDR
// for i = 1 to 4 do
19973: LD_ADDR_VAR 0 1
19977: PUSH
19978: DOUBLE
19979: LD_INT 1
19981: DEC
19982: ST_TO_ADDR
19983: LD_INT 4
19985: PUSH
19986: FOR_TO
19987: IFFALSE 20088
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19989: LD_INT 22
19991: PPUSH
19992: LD_INT 1
19994: PPUSH
19995: LD_INT 3
19997: PPUSH
19998: LD_INT 43
20000: PUSH
20001: LD_INT 44
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: PUSH
20008: LD_INT 1
20010: PPUSH
20011: LD_INT 2
20013: PPUSH
20014: CALL_OW 12
20018: ARRAY
20019: PPUSH
20020: LD_INT 89
20022: PPUSH
20023: CALL 71401 0 5
// un := CreateVehicle ;
20027: LD_ADDR_VAR 0 8
20031: PUSH
20032: CALL_OW 45
20036: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20037: LD_VAR 0 8
20041: PPUSH
20042: LD_INT 4
20044: PPUSH
20045: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20049: LD_VAR 0 8
20053: PPUSH
20054: LD_INT 136
20056: PPUSH
20057: LD_INT 90
20059: PPUSH
20060: LD_INT 8
20062: PPUSH
20063: LD_INT 0
20065: PPUSH
20066: CALL_OW 50
// ru := ru ^ un ;
20070: LD_ADDR_VAR 0 7
20074: PUSH
20075: LD_VAR 0 7
20079: PUSH
20080: LD_VAR 0 8
20084: ADD
20085: ST_TO_ADDR
// end ;
20086: GO 19986
20088: POP
20089: POP
// if ru then
20090: LD_VAR 0 7
20094: IFFALSE 20111
// ComAgressiveMove ( ru , 80 , 92 ) ;
20096: LD_VAR 0 7
20100: PPUSH
20101: LD_INT 80
20103: PPUSH
20104: LD_INT 92
20106: PPUSH
20107: CALL_OW 114
// wait ( 8 8$00 ) ;
20111: LD_INT 16800
20113: PPUSH
20114: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20118: LD_INT 4
20120: PPUSH
20121: LD_INT 3
20123: PUSH
20124: LD_INT 1
20126: PUSH
20127: LD_INT 1
20129: PUSH
20130: LD_INT 5
20132: PUSH
20133: EMPTY
20134: LIST
20135: LIST
20136: LIST
20137: LIST
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 1
20144: PUSH
20145: LD_INT 1
20147: PUSH
20148: LD_INT 6
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 1
20162: PUSH
20163: LD_INT 1
20165: PUSH
20166: LD_INT 7
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: PUSH
20175: LD_INT 3
20177: PUSH
20178: LD_INT 1
20180: PUSH
20181: LD_INT 1
20183: PUSH
20184: LD_INT 7
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 3
20195: PUSH
20196: LD_INT 1
20198: PUSH
20199: LD_INT 1
20201: PUSH
20202: LD_INT 5
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: PPUSH
20218: CALL 57894 0 2
// missionStage := 4 ;
20222: LD_ADDR_EXP 15
20226: PUSH
20227: LD_INT 4
20229: ST_TO_ADDR
// end ;
20230: PPOPN 8
20232: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20233: LD_EXP 15
20237: PUSH
20238: LD_INT 4
20240: EQUAL
20241: PUSH
20242: LD_INT 22
20244: PUSH
20245: LD_INT 4
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: LD_INT 21
20254: PUSH
20255: LD_INT 2
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: PPUSH
20266: CALL_OW 69
20270: PUSH
20271: LD_INT 5
20273: GREATEREQUAL
20274: AND
20275: IFFALSE 24380
20277: GO 20279
20279: DISABLE
20280: LD_INT 0
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
// begin missionStage := 5 ;
20295: LD_ADDR_EXP 15
20299: PUSH
20300: LD_INT 5
20302: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20303: LD_ADDR_VAR 0 10
20307: PUSH
20308: LD_INT 22
20310: PUSH
20311: LD_INT 4
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 30
20323: PUSH
20324: LD_INT 4
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: LD_INT 5
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PPUSH
20350: CALL_OW 69
20354: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20355: LD_ADDR_VAR 0 6
20359: PUSH
20360: LD_INT 22
20362: PUSH
20363: LD_INT 4
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 21
20372: PUSH
20373: LD_INT 1
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 3
20382: PUSH
20383: LD_INT 25
20385: PUSH
20386: LD_INT 16
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 3
20399: PUSH
20400: LD_INT 25
20402: PUSH
20403: LD_INT 12
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: PPUSH
20420: CALL_OW 69
20424: PUSH
20425: LD_EXP 57
20429: DIFF
20430: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20431: LD_ADDR_VAR 0 9
20435: PUSH
20436: LD_INT 22
20438: PUSH
20439: LD_INT 4
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 3
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: PUSH
20465: LD_INT 1
20467: ARRAY
20468: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20469: LD_INT 35
20471: PPUSH
20472: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20476: LD_EXP 120
20480: PUSH
20481: LD_INT 4
20483: ARRAY
20484: PUSH
20485: LD_INT 5
20487: GREATEREQUAL
20488: PUSH
20489: LD_EXP 120
20493: PUSH
20494: LD_INT 4
20496: ARRAY
20497: PPUSH
20498: LD_INT 58
20500: PUSH
20501: EMPTY
20502: LIST
20503: PPUSH
20504: CALL_OW 72
20508: PUSH
20509: LD_INT 5
20511: GREATEREQUAL
20512: AND
20513: IFFALSE 20469
// powellAllowRetreat := false ;
20515: LD_ADDR_EXP 19
20519: PUSH
20520: LD_INT 0
20522: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20523: LD_INT 700
20525: PPUSH
20526: CALL_OW 67
// activeAttacks := false ;
20530: LD_ADDR_EXP 16
20534: PUSH
20535: LD_INT 0
20537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20538: LD_INT 35
20540: PPUSH
20541: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20545: LD_INT 22
20547: PUSH
20548: LD_INT 6
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PPUSH
20555: CALL_OW 69
20559: PUSH
20560: LD_INT 0
20562: EQUAL
20563: IFFALSE 20538
// tmp := mc_vehicles [ 4 ] ;
20565: LD_ADDR_VAR 0 3
20569: PUSH
20570: LD_EXP 120
20574: PUSH
20575: LD_INT 4
20577: ARRAY
20578: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20579: LD_ADDR_VAR 0 1
20583: PUSH
20584: DOUBLE
20585: LD_INT 1
20587: DEC
20588: ST_TO_ADDR
20589: LD_EXP 18
20593: PUSH
20594: FOR_TO
20595: IFFALSE 20856
// begin for j in powellSquadAttack [ i ] do
20597: LD_ADDR_VAR 0 2
20601: PUSH
20602: LD_EXP 18
20606: PUSH
20607: LD_VAR 0 1
20611: ARRAY
20612: PUSH
20613: FOR_IN
20614: IFFALSE 20852
// begin forces := forces diff j ;
20616: LD_ADDR_VAR 0 6
20620: PUSH
20621: LD_VAR 0 6
20625: PUSH
20626: LD_VAR 0 2
20630: DIFF
20631: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20632: LD_VAR 0 2
20636: PPUSH
20637: LD_INT 1
20639: PPUSH
20640: CALL_OW 109
// wait ( 0 0$2 ) ;
20644: LD_INT 70
20646: PPUSH
20647: CALL_OW 67
// if IsInUnit ( j ) then
20651: LD_VAR 0 2
20655: PPUSH
20656: CALL_OW 310
20660: IFFALSE 20671
// ComExitBuilding ( j ) ;
20662: LD_VAR 0 2
20666: PPUSH
20667: CALL_OW 122
// if GetClass ( j ) <> 1 then
20671: LD_VAR 0 2
20675: PPUSH
20676: CALL_OW 257
20680: PUSH
20681: LD_INT 1
20683: NONEQUAL
20684: IFFALSE 20764
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20686: LD_VAR 0 10
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_INT 5
20702: GREATEREQUAL
20703: IFFALSE 20725
// AddComEnterUnit ( j , arm [ 2 ] ) else
20705: LD_VAR 0 2
20709: PPUSH
20710: LD_VAR 0 10
20714: PUSH
20715: LD_INT 2
20717: ARRAY
20718: PPUSH
20719: CALL_OW 180
20723: GO 20743
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20725: LD_VAR 0 2
20729: PPUSH
20730: LD_VAR 0 10
20734: PUSH
20735: LD_INT 1
20737: ARRAY
20738: PPUSH
20739: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20743: LD_VAR 0 2
20747: PPUSH
20748: LD_INT 1
20750: PPUSH
20751: CALL_OW 183
// AddComExitBuilding ( j ) ;
20755: LD_VAR 0 2
20759: PPUSH
20760: CALL_OW 182
// end ; if i = 2 then
20764: LD_VAR 0 1
20768: PUSH
20769: LD_INT 2
20771: EQUAL
20772: IFFALSE 20789
// AddComMoveXY ( j , 61 , 93 ) ;
20774: LD_VAR 0 2
20778: PPUSH
20779: LD_INT 61
20781: PPUSH
20782: LD_INT 93
20784: PPUSH
20785: CALL_OW 171
// if i = 1 then
20789: LD_VAR 0 1
20793: PUSH
20794: LD_INT 1
20796: EQUAL
20797: IFFALSE 20850
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20799: LD_VAR 0 2
20803: PPUSH
20804: LD_VAR 0 3
20808: PUSH
20809: LD_INT 1
20811: ARRAY
20812: PPUSH
20813: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20817: LD_ADDR_VAR 0 3
20821: PUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_INT 1
20829: PPUSH
20830: CALL_OW 3
20834: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_INT 69
20842: PPUSH
20843: LD_INT 94
20845: PPUSH
20846: CALL_OW 171
// end ; end ;
20850: GO 20613
20852: POP
20853: POP
// end ;
20854: GO 20594
20856: POP
20857: POP
// wait ( 0 0$55 ) ;
20858: LD_INT 1925
20860: PPUSH
20861: CALL_OW 67
// MC_Kill ( 4 ) ;
20865: LD_INT 4
20867: PPUSH
20868: CALL 34482 0 1
// tmp := UnitsInside ( fac ) ;
20872: LD_ADDR_VAR 0 3
20876: PUSH
20877: LD_VAR 0 9
20881: PPUSH
20882: CALL_OW 313
20886: ST_TO_ADDR
// if tmp then
20887: LD_VAR 0 3
20891: IFFALSE 21012
// for i in tmp do
20893: LD_ADDR_VAR 0 1
20897: PUSH
20898: LD_VAR 0 3
20902: PUSH
20903: FOR_IN
20904: IFFALSE 21010
// begin ComExitBuilding ( i ) ;
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20915: LD_VAR 0 10
20919: PUSH
20920: LD_INT 2
20922: ARRAY
20923: PPUSH
20924: CALL_OW 313
20928: PUSH
20929: LD_INT 6
20931: LESS
20932: IFFALSE 20954
// AddComEnterUnit ( i , arm [ 2 ] ) else
20934: LD_VAR 0 1
20938: PPUSH
20939: LD_VAR 0 10
20943: PUSH
20944: LD_INT 2
20946: ARRAY
20947: PPUSH
20948: CALL_OW 180
20952: GO 21008
// if UnitsInside ( arm [ 1 ] ) < 6 then
20954: LD_VAR 0 10
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 313
20967: PUSH
20968: LD_INT 6
20970: LESS
20971: IFFALSE 20993
// AddComEnterUnit ( i , arm [ 1 ] ) else
20973: LD_VAR 0 1
20977: PPUSH
20978: LD_VAR 0 10
20982: PUSH
20983: LD_INT 1
20985: ARRAY
20986: PPUSH
20987: CALL_OW 180
20991: GO 21008
// AddComMoveXY ( i , 37 , 68 ) ;
20993: LD_VAR 0 1
20997: PPUSH
20998: LD_INT 37
21000: PPUSH
21001: LD_INT 68
21003: PPUSH
21004: CALL_OW 171
// end ;
21008: GO 20903
21010: POP
21011: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21012: LD_ADDR_VAR 0 11
21016: PUSH
21017: LD_VAR 0 6
21021: PPUSH
21022: LD_INT 26
21024: PUSH
21025: LD_INT 1
21027: PUSH
21028: EMPTY
21029: LIST
21030: LIST
21031: PPUSH
21032: CALL_OW 72
21036: PUSH
21037: LD_EXP 58
21041: DIFF
21042: ST_TO_ADDR
// if not speaker then
21043: LD_VAR 0 11
21047: NOT
21048: IFFALSE 21075
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21050: LD_ADDR_VAR 0 11
21054: PUSH
21055: LD_VAR 0 6
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// if speaker then
21075: LD_VAR 0 11
21079: IFFALSE 21095
// speaker := speaker [ 1 ] ;
21081: LD_ADDR_VAR 0 11
21085: PUSH
21086: LD_VAR 0 11
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// Video ( true ) ;
21095: LD_INT 1
21097: PPUSH
21098: CALL 107121 0 1
// CenterNowOnUnits ( Powell ) ;
21102: LD_EXP 57
21106: PPUSH
21107: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_VAR 0 6
21120: PPUSH
21121: LD_INT 3
21123: PUSH
21124: LD_INT 25
21126: PUSH
21127: LD_INT 1
21129: PUSH
21130: EMPTY
21131: LIST
21132: LIST
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PPUSH
21138: CALL_OW 72
21142: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21143: LD_ADDR_VAR 0 12
21147: PUSH
21148: LD_INT 22
21150: PUSH
21151: LD_INT 4
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: LD_INT 30
21160: PUSH
21161: LD_INT 32
21163: PUSH
21164: EMPTY
21165: LIST
21166: LIST
21167: PUSH
21168: LD_INT 58
21170: PUSH
21171: EMPTY
21172: LIST
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: PPUSH
21179: CALL_OW 69
21183: ST_TO_ADDR
// for i = 1 to 6 do
21184: LD_ADDR_VAR 0 1
21188: PUSH
21189: DOUBLE
21190: LD_INT 1
21192: DEC
21193: ST_TO_ADDR
21194: LD_INT 6
21196: PUSH
21197: FOR_TO
21198: IFFALSE 21339
// begin if IsInUnit ( tmp [ i ] ) then
21200: LD_VAR 0 3
21204: PUSH
21205: LD_VAR 0 1
21209: ARRAY
21210: PPUSH
21211: CALL_OW 310
21215: IFFALSE 21232
// ComExitBuilding ( tmp [ i ] ) ;
21217: LD_VAR 0 3
21221: PUSH
21222: LD_VAR 0 1
21226: ARRAY
21227: PPUSH
21228: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21232: LD_VAR 0 3
21236: PUSH
21237: LD_VAR 0 1
21241: ARRAY
21242: PPUSH
21243: LD_VAR 0 10
21247: PUSH
21248: LD_INT 1
21250: ARRAY
21251: PPUSH
21252: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21256: LD_VAR 0 3
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: CALL_OW 183
// if emp_towers then
21274: LD_VAR 0 12
21278: IFFALSE 21337
// begin AddComExitBuilding ( tmp [ i ] ) ;
21280: LD_VAR 0 3
21284: PUSH
21285: LD_VAR 0 1
21289: ARRAY
21290: PPUSH
21291: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21295: LD_VAR 0 3
21299: PUSH
21300: LD_VAR 0 1
21304: ARRAY
21305: PPUSH
21306: LD_VAR 0 12
21310: PUSH
21311: LD_INT 1
21313: ARRAY
21314: PPUSH
21315: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21319: LD_ADDR_VAR 0 12
21323: PUSH
21324: LD_VAR 0 12
21328: PPUSH
21329: LD_INT 1
21331: PPUSH
21332: CALL_OW 3
21336: ST_TO_ADDR
// end ; end ;
21337: GO 21197
21339: POP
21340: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_EXP 18
21350: PUSH
21351: LD_INT 1
21353: ARRAY
21354: PUSH
21355: LD_EXP 18
21359: PUSH
21360: LD_INT 2
21362: ARRAY
21363: ADD
21364: PPUSH
21365: LD_INT 26
21367: PUSH
21368: LD_INT 1
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 72
21379: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21380: LD_ADDR_VAR 0 1
21384: PUSH
21385: LD_EXP 18
21389: PUSH
21390: LD_INT 2
21392: ARRAY
21393: PUSH
21394: FOR_IN
21395: IFFALSE 21413
// ComTurnUnit ( i , Powell ) ;
21397: LD_VAR 0 1
21401: PPUSH
21402: LD_EXP 57
21406: PPUSH
21407: CALL_OW 119
21411: GO 21394
21413: POP
21414: POP
// Say ( Powell , D5-Pow-1 ) ;
21415: LD_EXP 57
21419: PPUSH
21420: LD_STRING D5-Pow-1
21422: PPUSH
21423: CALL_OW 88
// if tmp then
21427: LD_VAR 0 3
21431: IFFALSE 21449
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21433: LD_VAR 0 3
21437: PUSH
21438: LD_INT 1
21440: ARRAY
21441: PPUSH
21442: LD_STRING D5-Sol2-1
21444: PPUSH
21445: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21449: LD_EXP 57
21453: PPUSH
21454: LD_STRING D5-Pow-2
21456: PPUSH
21457: CALL_OW 88
// if tmp > 1 then
21461: LD_VAR 0 3
21465: PUSH
21466: LD_INT 1
21468: GREATER
21469: IFFALSE 21487
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21471: LD_VAR 0 3
21475: PUSH
21476: LD_INT 2
21478: ARRAY
21479: PPUSH
21480: LD_STRING D5-Sol2-2
21482: PPUSH
21483: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21487: LD_EXP 57
21491: PPUSH
21492: LD_STRING D5-Pow-3
21494: PPUSH
21495: CALL_OW 88
// wait ( 0 0$1 ) ;
21499: LD_INT 35
21501: PPUSH
21502: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21506: LD_ADDR_VAR 0 3
21510: PUSH
21511: LD_EXP 18
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PUSH
21520: LD_EXP 18
21524: PUSH
21525: LD_INT 2
21527: ARRAY
21528: UNION
21529: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21530: LD_VAR 0 3
21534: PPUSH
21535: LD_INT 80
21537: PPUSH
21538: LD_INT 67
21540: PPUSH
21541: CALL_OW 114
// wait ( 0 0$2 ) ;
21545: LD_INT 70
21547: PPUSH
21548: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21552: LD_INT 79
21554: PPUSH
21555: LD_INT 72
21557: PPUSH
21558: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21562: LD_INT 35
21564: PPUSH
21565: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21569: LD_VAR 0 3
21573: PPUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 24
21579: PUSH
21580: LD_INT 1000
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PPUSH
21591: CALL_OW 72
21595: IFFALSE 21562
// Say ( Powell , D5a-Pow-1 ) ;
21597: LD_EXP 57
21601: PPUSH
21602: LD_STRING D5a-Pow-1
21604: PPUSH
21605: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21609: LD_EXP 57
21613: PPUSH
21614: LD_STRING D5a-Pow-1a
21616: PPUSH
21617: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21621: LD_INT 10
21623: PPUSH
21624: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21628: LD_EXP 57
21632: PPUSH
21633: LD_STRING D5a-Pow-1b
21635: PPUSH
21636: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21640: LD_EXP 57
21644: PPUSH
21645: LD_STRING D5a-Pow-1c
21647: PPUSH
21648: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21652: LD_EXP 57
21656: PPUSH
21657: LD_STRING D5a-Pow-1d
21659: PPUSH
21660: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21664: LD_INT 35
21666: PPUSH
21667: CALL_OW 67
// if not HasTask ( tmp ) then
21671: LD_VAR 0 3
21675: PPUSH
21676: CALL_OW 314
21680: NOT
21681: IFFALSE 21698
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21683: LD_VAR 0 3
21687: PPUSH
21688: LD_INT 80
21690: PPUSH
21691: LD_INT 67
21693: PPUSH
21694: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21698: LD_VAR 0 3
21702: PPUSH
21703: LD_INT 24
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PPUSH
21713: CALL_OW 72
21717: NOT
21718: IFFALSE 21664
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21720: LD_ADDR_VAR 0 3
21724: PUSH
21725: LD_INT 22
21727: PUSH
21728: LD_INT 4
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 92
21737: PUSH
21738: LD_INT 60
21740: PUSH
21741: LD_INT 93
21743: PUSH
21744: LD_INT 10
21746: PUSH
21747: EMPTY
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 3
21755: PUSH
21756: LD_INT 54
21758: PUSH
21759: EMPTY
21760: LIST
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: LIST
21770: PPUSH
21771: CALL_OW 69
21775: PUSH
21776: LD_EXP 57
21780: DIFF
21781: ST_TO_ADDR
// if tmp then
21782: LD_VAR 0 3
21786: IFFALSE 21820
// for i in tmp do
21788: LD_ADDR_VAR 0 1
21792: PUSH
21793: LD_VAR 0 3
21797: PUSH
21798: FOR_IN
21799: IFFALSE 21818
// ComMoveXY ( i , 36 , 67 ) ;
21801: LD_VAR 0 1
21805: PPUSH
21806: LD_INT 36
21808: PPUSH
21809: LD_INT 67
21811: PPUSH
21812: CALL_OW 111
21816: GO 21798
21818: POP
21819: POP
// wait ( 0 0$3 ) ;
21820: LD_INT 105
21822: PPUSH
21823: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21827: LD_VAR 0 11
21831: PPUSH
21832: LD_STRING D6-Sol3-1
21834: PPUSH
21835: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21839: LD_EXP 57
21843: PPUSH
21844: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21848: LD_EXP 57
21852: PPUSH
21853: LD_STRING D6-Pow-1
21855: PPUSH
21856: CALL_OW 88
// tmp := [ ] ;
21860: LD_ADDR_VAR 0 3
21864: PUSH
21865: EMPTY
21866: ST_TO_ADDR
// for i = 1 to 2 do
21867: LD_ADDR_VAR 0 1
21871: PUSH
21872: DOUBLE
21873: LD_INT 1
21875: DEC
21876: ST_TO_ADDR
21877: LD_INT 2
21879: PUSH
21880: FOR_TO
21881: IFFALSE 21995
// begin uc_side := 8 ;
21883: LD_ADDR_OWVAR 20
21887: PUSH
21888: LD_INT 8
21890: ST_TO_ADDR
// uc_nation := 2 ;
21891: LD_ADDR_OWVAR 21
21895: PUSH
21896: LD_INT 2
21898: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21899: LD_INT 14
21901: PPUSH
21902: LD_INT 3
21904: PPUSH
21905: LD_INT 2
21907: PPUSH
21908: LD_INT 29
21910: PPUSH
21911: LD_INT 100
21913: PPUSH
21914: CALL 71401 0 5
// veh := CreateVehicle ;
21918: LD_ADDR_VAR 0 13
21922: PUSH
21923: CALL_OW 45
21927: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21928: LD_VAR 0 13
21932: PPUSH
21933: LD_INT 4
21935: PPUSH
21936: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21940: LD_VAR 0 13
21944: PPUSH
21945: LD_INT 99
21947: PPUSH
21948: LD_INT 83
21950: PPUSH
21951: LD_INT 6
21953: PPUSH
21954: LD_INT 0
21956: PPUSH
21957: CALL_OW 50
// wait ( 3 ) ;
21961: LD_INT 3
21963: PPUSH
21964: CALL_OW 67
// Connect ( veh ) ;
21968: LD_VAR 0 13
21972: PPUSH
21973: CALL 74456 0 1
// tmp := tmp ^ veh ;
21977: LD_ADDR_VAR 0 3
21981: PUSH
21982: LD_VAR 0 3
21986: PUSH
21987: LD_VAR 0 13
21991: ADD
21992: ST_TO_ADDR
// end ;
21993: GO 21880
21995: POP
21996: POP
// wait ( 0 0$1 ) ;
21997: LD_INT 35
21999: PPUSH
22000: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22004: LD_INT 99
22006: PPUSH
22007: LD_INT 83
22009: PPUSH
22010: LD_INT 1
22012: PPUSH
22013: LD_INT 10
22015: PPUSH
22016: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22020: LD_INT 99
22022: PPUSH
22023: LD_INT 83
22025: PPUSH
22026: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22030: LD_VAR 0 11
22034: PPUSH
22035: LD_STRING D6-Sol3-2
22037: PPUSH
22038: CALL_OW 88
// async ;
22042: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22043: LD_EXP 57
22047: PPUSH
22048: LD_STRING D6-Pow-2
22050: PPUSH
22051: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22055: LD_VAR 0 3
22059: PUSH
22060: LD_INT 1
22062: ARRAY
22063: PPUSH
22064: LD_VAR 0 9
22068: PPUSH
22069: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22073: LD_VAR 0 3
22077: PUSH
22078: LD_INT 2
22080: ARRAY
22081: PPUSH
22082: LD_INT 22
22084: PUSH
22085: LD_INT 4
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: LD_INT 21
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: EMPTY
22099: LIST
22100: LIST
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PPUSH
22106: CALL_OW 69
22110: PPUSH
22111: LD_VAR 0 3
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PPUSH
22120: CALL_OW 74
22124: PPUSH
22125: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22129: LD_EXP 57
22133: PPUSH
22134: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22138: LD_INT 99
22140: PPUSH
22141: LD_INT 83
22143: PPUSH
22144: LD_INT 1
22146: PPUSH
22147: CALL_OW 331
// repeat wait ( 4 ) ;
22151: LD_INT 4
22153: PPUSH
22154: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22158: LD_VAR 0 3
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: PPUSH
22167: CALL_OW 256
22171: PUSH
22172: LD_INT 1000
22174: LESS
22175: IFFALSE 22193
// SetLives ( tmp [ 1 ] , 1000 ) ;
22177: LD_VAR 0 3
22181: PUSH
22182: LD_INT 1
22184: ARRAY
22185: PPUSH
22186: LD_INT 1000
22188: PPUSH
22189: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22193: LD_INT 22
22195: PUSH
22196: LD_INT 4
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_INT 3
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 69
22221: PUSH
22222: LD_INT 0
22224: EQUAL
22225: IFFALSE 22151
// sync ;
22227: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22228: LD_EXP 57
22232: PPUSH
22233: LD_STRING D6a-Pow-1
22235: PPUSH
22236: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22240: LD_VAR 0 11
22244: PPUSH
22245: LD_STRING D6a-Sol3-1
22247: PPUSH
22248: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22252: LD_EXP 57
22256: PPUSH
22257: LD_STRING D6a-Pow-2
22259: PPUSH
22260: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22264: LD_VAR 0 11
22268: PPUSH
22269: LD_STRING D6a-Sol3-2
22271: PPUSH
22272: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22276: LD_EXP 57
22280: PPUSH
22281: LD_STRING D6a-Pow-3
22283: PPUSH
22284: CALL_OW 88
// powellCenterCameraMode := true ;
22288: LD_ADDR_EXP 20
22292: PUSH
22293: LD_INT 1
22295: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22296: LD_ADDR_VAR 0 1
22300: PUSH
22301: LD_INT 22
22303: PUSH
22304: LD_INT 8
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PUSH
22311: LD_INT 25
22313: PUSH
22314: LD_INT 2
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: PPUSH
22325: CALL_OW 69
22329: PUSH
22330: FOR_IN
22331: IFFALSE 22386
// begin SetTag ( i , 1 ) ;
22333: LD_VAR 0 1
22337: PPUSH
22338: LD_INT 1
22340: PPUSH
22341: CALL_OW 109
// ComExitBuilding ( i ) ;
22345: LD_VAR 0 1
22349: PPUSH
22350: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22354: LD_VAR 0 1
22358: PPUSH
22359: LD_INT 35
22361: PPUSH
22362: LD_INT 6
22364: PPUSH
22365: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22369: LD_VAR 0 1
22373: PPUSH
22374: LD_INT 53
22376: PPUSH
22377: LD_INT 4
22379: PPUSH
22380: CALL_OW 171
// end ;
22384: GO 22330
22386: POP
22387: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22388: LD_ADDR_VAR 0 3
22392: PUSH
22393: LD_INT 22
22395: PUSH
22396: LD_INT 4
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 21
22405: PUSH
22406: LD_INT 2
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: LD_INT 3
22415: PUSH
22416: LD_INT 34
22418: PUSH
22419: LD_INT 12
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22440: LD_EXP 57
22444: PPUSH
22445: LD_VAR 0 3
22449: PPUSH
22450: LD_EXP 57
22454: PPUSH
22455: CALL_OW 74
22459: PPUSH
22460: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22464: LD_EXP 57
22468: PPUSH
22469: LD_INT 100
22471: PPUSH
22472: LD_INT 88
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22479: LD_EXP 57
22483: PPUSH
22484: LD_INT 100
22486: PPUSH
22487: LD_INT 75
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22494: LD_EXP 57
22498: PPUSH
22499: LD_INT 88
22501: PPUSH
22502: LD_INT 53
22504: PPUSH
22505: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22509: LD_INT 8
22511: PPUSH
22512: LD_EXP 57
22516: PPUSH
22517: CALL_OW 471
// repeat wait ( 3 ) ;
22521: LD_INT 3
22523: PPUSH
22524: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22528: LD_INT 22
22530: PUSH
22531: LD_INT 4
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 92
22540: PUSH
22541: LD_INT 100
22543: PUSH
22544: LD_INT 75
22546: PUSH
22547: LD_INT 6
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: IFFALSE 22521
// async ;
22566: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22567: LD_EXP 57
22571: PPUSH
22572: LD_STRING D6b-Pow-1
22574: PPUSH
22575: CALL_OW 88
// repeat wait ( 3 ) ;
22579: LD_INT 3
22581: PPUSH
22582: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22586: LD_EXP 57
22590: PPUSH
22591: CALL_OW 310
22595: PPUSH
22596: CALL_OW 256
22600: PUSH
22601: LD_INT 1000
22603: LESS
22604: IFFALSE 22623
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22606: LD_EXP 57
22610: PPUSH
22611: CALL_OW 310
22615: PPUSH
22616: LD_INT 1000
22618: PPUSH
22619: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22623: LD_EXP 57
22627: PPUSH
22628: CALL_OW 256
22632: PUSH
22633: LD_INT 1000
22635: LESS
22636: IFFALSE 22650
// SetLives ( Powell , 1000 ) ;
22638: LD_EXP 57
22642: PPUSH
22643: LD_INT 1000
22645: PPUSH
22646: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22650: LD_EXP 57
22654: PPUSH
22655: LD_EXP 62
22659: PPUSH
22660: CALL_OW 296
22664: PUSH
22665: LD_INT 5
22667: LESS
22668: PUSH
22669: LD_EXP 57
22673: PPUSH
22674: CALL_OW 310
22678: PPUSH
22679: LD_EXP 62
22683: PPUSH
22684: CALL_OW 296
22688: PUSH
22689: LD_INT 5
22691: LESS
22692: OR
22693: IFFALSE 22712
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22695: LD_EXP 57
22699: PPUSH
22700: CALL_OW 310
22704: PPUSH
22705: LD_INT 100
22707: PPUSH
22708: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22712: LD_EXP 57
22716: PPUSH
22717: CALL_OW 310
22721: NOT
22722: IFFALSE 22579
// DoNotAttack ( 8 , powellBomb ) ;
22724: LD_INT 8
22726: PPUSH
22727: LD_EXP 62
22731: PPUSH
22732: CALL_OW 471
// game_speed := 4 ;
22736: LD_ADDR_OWVAR 65
22740: PUSH
22741: LD_INT 4
22743: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22744: LD_EXP 57
22748: PPUSH
22749: LD_STRING D6b-Pow-1a
22751: PPUSH
22752: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22756: LD_EXP 57
22760: PPUSH
22761: LD_EXP 62
22765: PPUSH
22766: CALL_OW 180
// sync ;
22770: SYNC
// repeat wait ( 0 0$1 ) ;
22771: LD_INT 35
22773: PPUSH
22774: CALL_OW 67
// until IsInUnit ( Powell ) ;
22778: LD_EXP 57
22782: PPUSH
22783: CALL_OW 310
22787: IFFALSE 22771
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22789: LD_INT 8
22791: PPUSH
22792: LD_EXP 57
22796: PPUSH
22797: CALL_OW 310
22801: PPUSH
22802: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22806: LD_EXP 57
22810: PPUSH
22811: LD_INT 91
22813: PPUSH
22814: LD_INT 44
22816: PPUSH
22817: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22821: LD_EXP 57
22825: PPUSH
22826: LD_INT 96
22828: PPUSH
22829: LD_INT 44
22831: PPUSH
22832: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22836: LD_EXP 57
22840: PPUSH
22841: LD_INT 96
22843: PPUSH
22844: LD_INT 41
22846: PPUSH
22847: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22851: LD_EXP 57
22855: PPUSH
22856: LD_INT 92
22858: PPUSH
22859: LD_INT 39
22861: PPUSH
22862: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22866: LD_EXP 57
22870: PPUSH
22871: LD_INT 88
22873: PPUSH
22874: LD_INT 41
22876: PPUSH
22877: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22881: LD_EXP 57
22885: PPUSH
22886: LD_INT 91
22888: PPUSH
22889: LD_INT 44
22891: PPUSH
22892: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22896: LD_EXP 57
22900: PPUSH
22901: LD_INT 96
22903: PPUSH
22904: LD_INT 44
22906: PPUSH
22907: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22911: LD_EXP 57
22915: PPUSH
22916: LD_INT 96
22918: PPUSH
22919: LD_INT 41
22921: PPUSH
22922: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22926: LD_EXP 57
22930: PPUSH
22931: LD_INT 92
22933: PPUSH
22934: LD_INT 39
22936: PPUSH
22937: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22941: LD_EXP 57
22945: PPUSH
22946: LD_INT 88
22948: PPUSH
22949: LD_INT 41
22951: PPUSH
22952: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 57
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22971: LD_EXP 57
22975: PPUSH
22976: LD_INT 93
22978: PPUSH
22979: LD_INT 39
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22986: LD_EXP 57
22990: PPUSH
22991: LD_INT 93
22993: PPUSH
22994: LD_INT 36
22996: PPUSH
22997: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23001: LD_INT 122
23003: PPUSH
23004: CALL_OW 67
// game_speed := 4 ;
23008: LD_ADDR_OWVAR 65
23012: PUSH
23013: LD_INT 4
23015: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23016: LD_EXP 57
23020: PPUSH
23021: LD_STRING D6b-Pow-1b
23023: PPUSH
23024: CALL_OW 88
// tmp := [ ] ;
23028: LD_ADDR_VAR 0 3
23032: PUSH
23033: EMPTY
23034: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23035: LD_ADDR_VAR 0 5
23039: PUSH
23040: LD_INT 78
23042: PUSH
23043: LD_INT 47
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: PUSH
23050: LD_INT 106
23052: PUSH
23053: LD_INT 53
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23064: LD_ADDR_VAR 0 1
23068: PUSH
23069: LD_INT 22
23071: PUSH
23072: LD_INT 8
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 21
23081: PUSH
23082: LD_INT 3
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 92
23091: PUSH
23092: LD_INT 90
23094: PUSH
23095: LD_INT 52
23097: PUSH
23098: LD_INT 12
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 69
23116: PUSH
23117: FOR_IN
23118: IFFALSE 23143
// tmp := tmp ^ UnitsInside ( i ) ;
23120: LD_ADDR_VAR 0 3
23124: PUSH
23125: LD_VAR 0 3
23129: PUSH
23130: LD_VAR 0 1
23134: PPUSH
23135: CALL_OW 313
23139: ADD
23140: ST_TO_ADDR
23141: GO 23117
23143: POP
23144: POP
// for i in tmp do
23145: LD_ADDR_VAR 0 1
23149: PUSH
23150: LD_VAR 0 3
23154: PUSH
23155: FOR_IN
23156: IFFALSE 23318
// begin dist := 9999 ;
23158: LD_ADDR_VAR 0 8
23162: PUSH
23163: LD_INT 9999
23165: ST_TO_ADDR
// _xy := [ ] ;
23166: LD_ADDR_VAR 0 7
23170: PUSH
23171: EMPTY
23172: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23173: LD_VAR 0 1
23177: PPUSH
23178: LD_INT 1
23180: PPUSH
23181: CALL_OW 109
// ComExitBuilding ( i ) ;
23185: LD_VAR 0 1
23189: PPUSH
23190: CALL_OW 122
// for j in xy do
23194: LD_ADDR_VAR 0 2
23198: PUSH
23199: LD_VAR 0 5
23203: PUSH
23204: FOR_IN
23205: IFFALSE 23287
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_VAR 0 2
23216: PUSH
23217: LD_INT 1
23219: ARRAY
23220: PPUSH
23221: LD_VAR 0 2
23225: PUSH
23226: LD_INT 2
23228: ARRAY
23229: PPUSH
23230: CALL_OW 297
23234: PUSH
23235: LD_VAR 0 8
23239: LESS
23240: IFFALSE 23285
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23242: LD_ADDR_VAR 0 8
23246: PUSH
23247: LD_VAR 0 1
23251: PPUSH
23252: LD_VAR 0 2
23256: PUSH
23257: LD_INT 1
23259: ARRAY
23260: PPUSH
23261: LD_VAR 0 2
23265: PUSH
23266: LD_INT 2
23268: ARRAY
23269: PPUSH
23270: CALL_OW 297
23274: ST_TO_ADDR
// _xy := j ;
23275: LD_ADDR_VAR 0 7
23279: PUSH
23280: LD_VAR 0 2
23284: ST_TO_ADDR
// end ;
23285: GO 23204
23287: POP
23288: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23289: LD_VAR 0 1
23293: PPUSH
23294: LD_VAR 0 7
23298: PUSH
23299: LD_INT 1
23301: ARRAY
23302: PPUSH
23303: LD_VAR 0 7
23307: PUSH
23308: LD_INT 2
23310: ARRAY
23311: PPUSH
23312: CALL_OW 171
// end ;
23316: GO 23155
23318: POP
23319: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23320: LD_ADDR_VAR 0 4
23324: PUSH
23325: LD_VAR 0 3
23329: PPUSH
23330: LD_INT 26
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 25
23342: PUSH
23343: LD_INT 1
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: PPUSH
23354: CALL_OW 72
23358: ST_TO_ADDR
// if tmp2 < 2 then
23359: LD_VAR 0 4
23363: PUSH
23364: LD_INT 2
23366: LESS
23367: IFFALSE 23436
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23369: LD_ADDR_VAR 0 4
23373: PUSH
23374: LD_INT 22
23376: PUSH
23377: LD_INT 8
23379: PUSH
23380: EMPTY
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 26
23386: PUSH
23387: LD_INT 1
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PUSH
23394: LD_INT 3
23396: PUSH
23397: LD_INT 25
23399: PUSH
23400: LD_INT 15
23402: PUSH
23403: EMPTY
23404: LIST
23405: LIST
23406: PUSH
23407: EMPTY
23408: LIST
23409: LIST
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 69
23420: PUSH
23421: LD_EXP 59
23425: PUSH
23426: LD_EXP 60
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: DIFF
23435: ST_TO_ADDR
// if tmp2 then
23436: LD_VAR 0 4
23440: IFFALSE 23458
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23442: LD_VAR 0 4
23446: PUSH
23447: LD_INT 1
23449: ARRAY
23450: PPUSH
23451: LD_STRING D6b-ArSol1-1
23453: PPUSH
23454: CALL_OW 88
// async ;
23458: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23459: LD_EXP 57
23463: PPUSH
23464: LD_STRING D6b-Pow-2
23466: PPUSH
23467: CALL_OW 88
// wait ( 0 0$1 ) ;
23471: LD_INT 35
23473: PPUSH
23474: CALL_OW 67
// if tmp2 > 1 then
23478: LD_VAR 0 4
23482: PUSH
23483: LD_INT 1
23485: GREATER
23486: IFFALSE 23504
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23488: LD_VAR 0 4
23492: PUSH
23493: LD_INT 2
23495: ARRAY
23496: PPUSH
23497: LD_STRING D6b-ArSol2-1
23499: PPUSH
23500: CALL_OW 88
// sync ;
23504: SYNC
// repeat wait ( 5 ) ;
23505: LD_INT 5
23507: PPUSH
23508: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23512: LD_INT 93
23514: PPUSH
23515: LD_INT 36
23517: PPUSH
23518: CALL_OW 428
23522: PPUSH
23523: CALL_OW 255
23527: PUSH
23528: LD_INT 4
23530: EQUAL
23531: IFFALSE 23505
// DialogueOn ;
23533: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23537: LD_INT 10
23539: PPUSH
23540: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23544: LD_EXP 57
23548: PPUSH
23549: LD_STRING D6b-Pow-2a
23551: PPUSH
23552: CALL_OW 88
// DialogueOff ;
23556: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23560: LD_EXP 57
23564: PPUSH
23565: CALL_OW 310
23569: PPUSH
23570: LD_INT 332
23572: PPUSH
23573: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23577: LD_INT 93
23579: PPUSH
23580: LD_INT 35
23582: PPUSH
23583: LD_INT 1
23585: PPUSH
23586: LD_INT 6
23588: NEG
23589: PPUSH
23590: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23594: LD_INT 35
23596: PPUSH
23597: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23601: LD_INT 332
23603: PPUSH
23604: CALL_OW 256
23608: PUSH
23609: LD_INT 1000
23611: LESS
23612: PUSH
23613: LD_INT 332
23615: PPUSH
23616: CALL_OW 300
23620: AND
23621: IFFALSE 23633
// SetLives ( kozlov_fac , 0 ) ;
23623: LD_INT 332
23625: PPUSH
23626: LD_INT 0
23628: PPUSH
23629: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23633: LD_INT 332
23635: PPUSH
23636: CALL_OW 301
23640: PUSH
23641: LD_EXP 57
23645: PPUSH
23646: CALL_OW 301
23650: OR
23651: IFFALSE 23594
// game_speed := 4 ;
23653: LD_ADDR_OWVAR 65
23657: PUSH
23658: LD_INT 4
23660: ST_TO_ADDR
// powellCenterCameraMode := false ;
23661: LD_ADDR_EXP 20
23665: PUSH
23666: LD_INT 0
23668: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23669: LD_ADDR_VAR 0 1
23673: PUSH
23674: LD_VAR 0 3
23678: PUSH
23679: LD_INT 22
23681: PUSH
23682: LD_INT 8
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 25
23691: PUSH
23692: LD_INT 2
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PPUSH
23703: CALL_OW 69
23707: UNION
23708: PUSH
23709: FOR_IN
23710: IFFALSE 23726
// SetTag ( i , 0 ) ;
23712: LD_VAR 0 1
23716: PPUSH
23717: LD_INT 0
23719: PPUSH
23720: CALL_OW 109
23724: GO 23709
23726: POP
23727: POP
// wait ( 0 0$3 ) ;
23728: LD_INT 105
23730: PPUSH
23731: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23735: LD_INT 93
23737: PPUSH
23738: LD_INT 35
23740: PPUSH
23741: LD_INT 1
23743: PPUSH
23744: CALL_OW 331
// DialogueOn ;
23748: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23752: LD_VAR 0 11
23756: PPUSH
23757: LD_STRING D6c-Sol3-1
23759: PPUSH
23760: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23764: LD_INT 10
23766: PPUSH
23767: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23771: LD_EXP 38
23775: PPUSH
23776: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23780: LD_EXP 38
23784: PPUSH
23785: LD_STRING D6c-JMM-1
23787: PPUSH
23788: CALL_OW 88
// if Cyrus then
23792: LD_EXP 44
23796: IFFALSE 23810
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23798: LD_EXP 44
23802: PPUSH
23803: LD_STRING D6c-Cyrus-1
23805: PPUSH
23806: CALL_OW 88
// if Bobby then
23810: LD_EXP 43
23814: IFFALSE 23828
// Say ( Bobby , D6c-Bobby-1 ) ;
23816: LD_EXP 43
23820: PPUSH
23821: LD_STRING D6c-Bobby-1
23823: PPUSH
23824: CALL_OW 88
// if Cornel then
23828: LD_EXP 49
23832: IFFALSE 23846
// Say ( Cornel , D6c-Corn-1 ) ;
23834: LD_EXP 49
23838: PPUSH
23839: LD_STRING D6c-Corn-1
23841: PPUSH
23842: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23846: LD_ADDR_VAR 0 4
23850: PUSH
23851: LD_INT 2
23853: PUSH
23854: LD_INT 22
23856: PUSH
23857: LD_INT 1
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 22
23866: PUSH
23867: LD_INT 4
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 26
23881: PUSH
23882: LD_INT 1
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 3
23891: PUSH
23892: LD_INT 25
23894: PUSH
23895: LD_INT 16
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PUSH
23902: LD_INT 25
23904: PUSH
23905: LD_INT 12
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PPUSH
23922: CALL_OW 69
23926: PUSH
23927: LD_VAR 0 11
23931: PUSH
23932: LD_EXP 38
23936: UNION
23937: PUSH
23938: LD_EXP 58
23942: UNION
23943: PUSH
23944: EMPTY
23945: LIST
23946: DIFF
23947: ST_TO_ADDR
// if tmp2 then
23948: LD_VAR 0 4
23952: IFFALSE 23970
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23954: LD_VAR 0 4
23958: PUSH
23959: LD_INT 1
23961: ARRAY
23962: PPUSH
23963: LD_STRING D6c-Sol1-1
23965: PPUSH
23966: CALL_OW 88
// if Lisa then
23970: LD_EXP 41
23974: IFFALSE 23988
// Say ( Lisa , D6c-Lisa-1 ) ;
23976: LD_EXP 41
23980: PPUSH
23981: LD_STRING D6c-Lisa-1
23983: PPUSH
23984: CALL_OW 88
// if Gary then
23988: LD_EXP 50
23992: IFFALSE 24006
// Say ( Gary , D6c-Gary-1 ) ;
23994: LD_EXP 50
23998: PPUSH
23999: LD_STRING D6c-Gary-1
24001: PPUSH
24002: CALL_OW 88
// if Donaldson then
24006: LD_EXP 42
24010: IFFALSE 24024
// Say ( Donaldson , D6c-Don-1 ) ;
24012: LD_EXP 42
24016: PPUSH
24017: LD_STRING D6c-Don-1
24019: PPUSH
24020: CALL_OW 88
// if tmp2 > 1 then
24024: LD_VAR 0 4
24028: PUSH
24029: LD_INT 1
24031: GREATER
24032: IFFALSE 24050
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24034: LD_VAR 0 4
24038: PUSH
24039: LD_INT 2
24041: ARRAY
24042: PPUSH
24043: LD_STRING D6c-Sol2-1
24045: PPUSH
24046: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24050: LD_VAR 0 11
24054: PPUSH
24055: LD_STRING D6c-Sol3-2
24057: PPUSH
24058: CALL_OW 88
// dwait ( 0 0$1 ) ;
24062: LD_INT 35
24064: PPUSH
24065: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24069: LD_EXP 38
24073: PPUSH
24074: LD_STRING D6c-JMM-2
24076: PPUSH
24077: CALL_OW 88
// DialogueOff ;
24081: CALL_OW 7
// Video ( false ) ;
24085: LD_INT 0
24087: PPUSH
24088: CALL 107121 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24092: LD_INT 22
24094: PUSH
24095: LD_INT 4
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 69
24106: PPUSH
24107: LD_INT 1
24109: PPUSH
24110: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24114: LD_INT 4
24116: PPUSH
24117: LD_INT 4
24119: PPUSH
24120: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24124: LD_ADDR_VAR 0 1
24128: PUSH
24129: LD_INT 4
24131: PPUSH
24132: LD_INT 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: CALL 64349 0 3
24142: PUSH
24143: FOR_IN
24144: IFFALSE 24181
// if GetTech ( i , 1 ) <> state_researched then
24146: LD_VAR 0 1
24150: PPUSH
24151: LD_INT 1
24153: PPUSH
24154: CALL_OW 321
24158: PUSH
24159: LD_INT 2
24161: NONEQUAL
24162: IFFALSE 24179
// SetTech ( i , 1 , state_researched ) ;
24164: LD_VAR 0 1
24168: PPUSH
24169: LD_INT 1
24171: PPUSH
24172: LD_INT 2
24174: PPUSH
24175: CALL_OW 322
24179: GO 24143
24181: POP
24182: POP
// missionStage := 6 ;
24183: LD_ADDR_EXP 15
24187: PUSH
24188: LD_INT 6
24190: ST_TO_ADDR
// activeAttacks := true ;
24191: LD_ADDR_EXP 16
24195: PUSH
24196: LD_INT 1
24198: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24199: LD_STRING M2
24201: PPUSH
24202: CALL_OW 337
// SaveForQuickRestart ;
24206: CALL_OW 22
// wait ( 0 0$40 ) ;
24210: LD_INT 1400
24212: PPUSH
24213: CALL_OW 67
// DialogueOn ;
24217: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24221: LD_EXP 61
24225: PPUSH
24226: LD_STRING D7-Friend-1
24228: PPUSH
24229: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24233: LD_EXP 38
24237: PPUSH
24238: LD_STRING D7-JMM-1
24240: PPUSH
24241: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24245: LD_EXP 61
24249: PPUSH
24250: LD_STRING D7-Friend-2
24252: PPUSH
24253: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24257: LD_EXP 38
24261: PPUSH
24262: LD_STRING D7-JMM-2
24264: PPUSH
24265: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24269: LD_EXP 61
24273: PPUSH
24274: LD_STRING D7-Friend-3
24276: PPUSH
24277: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24281: LD_EXP 38
24285: PPUSH
24286: LD_STRING D7-JMM-3
24288: PPUSH
24289: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24293: LD_EXP 61
24297: PPUSH
24298: LD_STRING D7-Friend-4
24300: PPUSH
24301: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24305: LD_EXP 38
24309: PPUSH
24310: LD_STRING D7-JMM-4
24312: PPUSH
24313: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24317: LD_EXP 61
24321: PPUSH
24322: LD_STRING D7-Friend-5
24324: PPUSH
24325: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24329: LD_EXP 38
24333: PPUSH
24334: LD_STRING D7-JMM-5
24336: PPUSH
24337: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24341: LD_EXP 61
24345: PPUSH
24346: LD_STRING D7-Friend-6
24348: PPUSH
24349: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24353: LD_EXP 38
24357: PPUSH
24358: LD_STRING D7-JMM-6
24360: PPUSH
24361: CALL_OW 88
// DialogueOff ;
24365: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24369: LD_STRING Mlegion
24371: PPUSH
24372: CALL_OW 337
// RebuildKozlovFactory ;
24376: CALL 4816 0 0
// end ;
24380: PPOPN 13
24382: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24383: LD_EXP 20
24387: PUSH
24388: LD_EXP 57
24392: PPUSH
24393: CALL_OW 300
24397: AND
24398: IFFALSE 24440
24400: GO 24402
24402: DISABLE
// begin enable ;
24403: ENABLE
// if IsInUnit ( Powell ) then
24404: LD_EXP 57
24408: PPUSH
24409: CALL_OW 310
24413: IFFALSE 24431
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24415: LD_EXP 57
24419: PPUSH
24420: CALL_OW 310
24424: PPUSH
24425: CALL_OW 85
24429: GO 24440
// CenterOnUnits ( Powell ) ;
24431: LD_EXP 57
24435: PPUSH
24436: CALL_OW 85
// end ;
24440: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24441: LD_INT 22
24443: PUSH
24444: LD_INT 8
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: LD_INT 34
24453: PUSH
24454: LD_INT 48
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PPUSH
24465: CALL_OW 69
24469: IFFALSE 24732
24471: GO 24473
24473: DISABLE
24474: LD_INT 0
24476: PPUSH
24477: PPUSH
// begin if missionStage < 9 then
24478: LD_EXP 15
24482: PUSH
24483: LD_INT 9
24485: LESS
24486: IFFALSE 24496
// missionStage := 9 ;
24488: LD_ADDR_EXP 15
24492: PUSH
24493: LD_INT 9
24495: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24496: LD_ADDR_VAR 0 1
24500: PUSH
24501: LD_INT 22
24503: PUSH
24504: LD_INT 8
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: PUSH
24511: LD_INT 34
24513: PUSH
24514: LD_INT 48
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PPUSH
24525: CALL_OW 69
24529: PUSH
24530: LD_INT 1
24532: ARRAY
24533: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24534: LD_INT 175
24536: PPUSH
24537: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24541: LD_EXP 12
24545: PUSH
24546: LD_EXP 3
24550: PUSH
24551: LD_INT 0
24553: PUSH
24554: LD_INT 2
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: IN
24561: OR
24562: IFFALSE 24585
// target := [ 68 , 108 , 1 ] else
24564: LD_ADDR_VAR 0 2
24568: PUSH
24569: LD_INT 68
24571: PUSH
24572: LD_INT 108
24574: PUSH
24575: LD_INT 1
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: ST_TO_ADDR
24583: GO 24604
// target := [ 181 , 88 , 2 ] ;
24585: LD_ADDR_VAR 0 2
24589: PUSH
24590: LD_INT 181
24592: PUSH
24593: LD_INT 88
24595: PUSH
24596: LD_INT 2
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: LIST
24603: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24604: LD_VAR 0 1
24608: PPUSH
24609: LD_VAR 0 2
24613: PUSH
24614: LD_INT 1
24616: ARRAY
24617: PPUSH
24618: LD_VAR 0 2
24622: PUSH
24623: LD_INT 2
24625: ARRAY
24626: PPUSH
24627: CALL_OW 176
// if target [ 3 ] = 1 then
24631: LD_VAR 0 2
24635: PUSH
24636: LD_INT 3
24638: ARRAY
24639: PUSH
24640: LD_INT 1
24642: EQUAL
24643: IFFALSE 24659
// SayRadio ( Kurt , D12-Kurt-1 ) else
24645: LD_EXP 59
24649: PPUSH
24650: LD_STRING D12-Kurt-1
24652: PPUSH
24653: CALL_OW 94
24657: GO 24683
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24659: LD_EXP 59
24663: PPUSH
24664: LD_STRING D12a-Kurt-1
24666: PPUSH
24667: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24671: LD_EXP 73
24675: PPUSH
24676: LD_STRING D12a-Roth-1
24678: PPUSH
24679: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24683: LD_INT 350
24685: PPUSH
24686: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24690: LD_VAR 0 1
24694: PPUSH
24695: LD_INT 22
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 30
24707: PUSH
24708: LD_INT 3
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PPUSH
24719: CALL_OW 69
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: CALL_OW 228
// end ;
24732: PPOPN 2
24734: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24735: LD_INT 22
24737: PUSH
24738: LD_INT 8
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 21
24747: PUSH
24748: LD_INT 1
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 23
24757: PUSH
24758: LD_INT 2
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: LIST
24769: PPUSH
24770: CALL_OW 69
24774: PUSH
24775: LD_INT 9
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: LD_INT 7
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_OWVAR 67
24793: ARRAY
24794: LESSEQUAL
24795: PUSH
24796: LD_INT 22
24798: PUSH
24799: LD_INT 8
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: LD_INT 34
24808: PUSH
24809: LD_INT 48
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 69
24824: NOT
24825: AND
24826: PUSH
24827: LD_EXP 59
24831: PPUSH
24832: CALL_OW 302
24836: AND
24837: IFFALSE 25142
24839: GO 24841
24841: DISABLE
// begin DialogueOn ;
24842: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24846: LD_EXP 38
24850: PPUSH
24851: LD_STRING D13-JMM-1
24853: PPUSH
24854: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24858: LD_EXP 59
24862: PPUSH
24863: LD_STRING D13-Kurt-1
24865: PPUSH
24866: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24870: LD_EXP 38
24874: PPUSH
24875: LD_STRING D13-JMM-2
24877: PPUSH
24878: CALL_OW 88
// if FakeInfo then
24882: LD_EXP 12
24886: IFFALSE 24906
// begin Say ( Kurt , D13-Kurt-2 ) ;
24888: LD_EXP 59
24892: PPUSH
24893: LD_STRING D13-Kurt-2
24895: PPUSH
24896: CALL_OW 88
// DialogueOff ;
24900: CALL_OW 7
// exit ;
24904: GO 25142
// end ; if not KurtStatus then
24906: LD_EXP 3
24910: NOT
24911: IFFALSE 24927
// Say ( Kurt , D13-Kurt-2b ) else
24913: LD_EXP 59
24917: PPUSH
24918: LD_STRING D13-Kurt-2b
24920: PPUSH
24921: CALL_OW 88
24925: GO 24939
// Say ( Kurt , D13-Kurt-2a ) ;
24927: LD_EXP 59
24931: PPUSH
24932: LD_STRING D13-Kurt-2a
24934: PPUSH
24935: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24939: LD_EXP 38
24943: PPUSH
24944: LD_STRING D13-JMM-3
24946: PPUSH
24947: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24951: LD_EXP 59
24955: PPUSH
24956: LD_STRING D13-Kurt-3
24958: PPUSH
24959: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24963: LD_EXP 38
24967: PPUSH
24968: LD_STRING D13-JMM-4
24970: PPUSH
24971: CALL_OW 88
// DialogueOff ;
24975: CALL_OW 7
// MC_Kill ( 3 ) ;
24979: LD_INT 3
24981: PPUSH
24982: CALL 34482 0 1
// KillUnit ( Kozlov ) ;
24986: LD_EXP 60
24990: PPUSH
24991: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24995: LD_INT 22
24997: PUSH
24998: LD_INT 8
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: PUSH
25005: LD_INT 21
25007: PUSH
25008: LD_INT 3
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 23
25017: PUSH
25018: LD_INT 3
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PUSH
25025: LD_INT 30
25027: PUSH
25028: LD_INT 3
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: PPUSH
25050: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25054: LD_INT 8
25056: PPUSH
25057: LD_INT 1
25059: PPUSH
25060: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
25064: LD_INT 22
25066: PUSH
25067: LD_INT 8
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PPUSH
25074: CALL_OW 69
25078: PPUSH
25079: LD_INT 1
25081: PPUSH
25082: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25086: LD_INT 8
25088: PPUSH
25089: LD_INT 1
25091: PPUSH
25092: LD_INT 1
25094: PPUSH
25095: LD_INT 1
25097: PPUSH
25098: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25102: LD_EXP 61
25106: PPUSH
25107: LD_INT 37
25109: PPUSH
25110: LD_INT 1
25112: PPUSH
25113: LD_INT 0
25115: PPUSH
25116: CALL_OW 48
// wait ( 0 0$1 ) ;
25120: LD_INT 35
25122: PPUSH
25123: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25127: LD_EXP 61
25131: PPUSH
25132: LD_INT 60
25134: PPUSH
25135: LD_INT 95
25137: PPUSH
25138: CALL_OW 111
// end ;
25142: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25143: LD_INT 22
25145: PUSH
25146: LD_INT 8
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 21
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PPUSH
25167: CALL_OW 69
25171: PUSH
25172: LD_INT 0
25174: EQUAL
25175: IFFALSE 25195
25177: GO 25179
25179: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25180: LD_STRING MlegionOut
25182: PPUSH
25183: CALL_OW 337
// legionDestroyed := true ;
25187: LD_ADDR_EXP 22
25191: PUSH
25192: LD_INT 1
25194: ST_TO_ADDR
// end ;
25195: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25196: LD_INT 1
25198: PPUSH
25199: LD_EXP 61
25203: PPUSH
25204: CALL_OW 292
25208: IFFALSE 25522
25210: GO 25212
25212: DISABLE
25213: LD_INT 0
25215: PPUSH
// begin wait ( 0 0$2 ) ;
25216: LD_INT 70
25218: PPUSH
25219: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25223: LD_EXP 61
25227: PPUSH
25228: CALL_OW 87
// DialogueOn ;
25232: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25236: LD_EXP 38
25240: PPUSH
25241: LD_STRING D14-JMM-1
25243: PPUSH
25244: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25248: LD_EXP 61
25252: PPUSH
25253: LD_STRING D14-Friend-1
25255: PPUSH
25256: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25260: LD_EXP 38
25264: PPUSH
25265: LD_STRING D14-JMM-2
25267: PPUSH
25268: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25272: LD_EXP 61
25276: PPUSH
25277: LD_STRING D14-Friend-2
25279: PPUSH
25280: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25284: LD_EXP 38
25288: PPUSH
25289: LD_STRING D14-JMM-3
25291: PPUSH
25292: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25296: LD_EXP 61
25300: PPUSH
25301: LD_STRING D14-Friend-3
25303: PPUSH
25304: CALL_OW 88
// DialogueOff ;
25308: CALL_OW 7
// dec = Query ( Q14 ) ;
25312: LD_ADDR_VAR 0 1
25316: PUSH
25317: LD_STRING Q14
25319: PPUSH
25320: CALL_OW 97
25324: ST_TO_ADDR
// if dec = 1 then
25325: LD_VAR 0 1
25329: PUSH
25330: LD_INT 1
25332: EQUAL
25333: IFFALSE 25367
// begin DialogueOn ;
25335: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25339: LD_EXP 38
25343: PPUSH
25344: LD_STRING D14a-JMM-1
25346: PPUSH
25347: CALL_OW 88
// DialogueOff ;
25351: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25355: LD_EXP 61
25359: PPUSH
25360: LD_INT 1
25362: PPUSH
25363: CALL_OW 235
// end ; if dec = 2 then
25367: LD_VAR 0 1
25371: PUSH
25372: LD_INT 2
25374: EQUAL
25375: IFFALSE 25428
// begin DialogueOn ;
25377: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25381: LD_EXP 38
25385: PPUSH
25386: LD_STRING D14b-JMM-1
25388: PPUSH
25389: CALL_OW 88
// DialogueOff ;
25393: CALL_OW 7
// wait ( 0 0$1 ) ;
25397: LD_INT 35
25399: PPUSH
25400: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25404: LD_EXP 61
25408: PPUSH
25409: LD_INT 9
25411: PPUSH
25412: LD_INT 2
25414: PPUSH
25415: CALL_OW 111
// AddComHold ( Friend ) ;
25419: LD_EXP 61
25423: PPUSH
25424: CALL_OW 200
// end ; if dec = 3 then
25428: LD_VAR 0 1
25432: PUSH
25433: LD_INT 3
25435: EQUAL
25436: IFFALSE 25522
// begin DialogueOn ;
25438: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25442: LD_EXP 38
25446: PPUSH
25447: LD_STRING D14c-JMM-1
25449: PPUSH
25450: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25454: LD_EXP 61
25458: PPUSH
25459: LD_STRING D14c-Friend-1
25461: PPUSH
25462: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25466: LD_EXP 38
25470: PPUSH
25471: LD_STRING D14c-JMM-2
25473: PPUSH
25474: CALL_OW 88
// DialogueOff ;
25478: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25482: LD_INT 8
25484: PPUSH
25485: LD_INT 1
25487: PPUSH
25488: LD_INT 2
25490: PPUSH
25491: LD_INT 1
25493: PPUSH
25494: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25498: LD_EXP 61
25502: PPUSH
25503: LD_INT 9
25505: PPUSH
25506: LD_INT 2
25508: PPUSH
25509: CALL_OW 111
// AddComHold ( Friend ) ;
25513: LD_EXP 61
25517: PPUSH
25518: CALL_OW 200
// end ; end ;
25522: PPOPN 1
25524: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25525: LD_INT 9
25527: PPUSH
25528: LD_INT 2
25530: PPUSH
25531: CALL_OW 428
25535: PUSH
25536: LD_EXP 61
25540: EQUAL
25541: PUSH
25542: LD_EXP 61
25546: PPUSH
25547: CALL_OW 255
25551: PUSH
25552: LD_INT 8
25554: EQUAL
25555: AND
25556: IFFALSE 25570
25558: GO 25560
25560: DISABLE
// RemoveUnit ( Friend ) ;
25561: LD_EXP 61
25565: PPUSH
25566: CALL_OW 64
25570: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25571: LD_EXP 14
25575: PUSH
25576: LD_INT 31500
25578: GREATEREQUAL
25579: PUSH
25580: LD_EXP 7
25584: AND
25585: PUSH
25586: LD_EXP 2
25590: AND
25591: IFFALSE 26021
25593: GO 25595
25595: DISABLE
25596: LD_INT 0
25598: PPUSH
25599: PPUSH
25600: PPUSH
// begin missionStage := 7 ;
25601: LD_ADDR_EXP 15
25605: PUSH
25606: LD_INT 7
25608: ST_TO_ADDR
// uc_side = 1 ;
25609: LD_ADDR_OWVAR 20
25613: PUSH
25614: LD_INT 1
25616: ST_TO_ADDR
// uc_nation = 1 ;
25617: LD_ADDR_OWVAR 21
25621: PUSH
25622: LD_INT 1
25624: ST_TO_ADDR
// for i = 1 to 5 do
25625: LD_ADDR_VAR 0 1
25629: PUSH
25630: DOUBLE
25631: LD_INT 1
25633: DEC
25634: ST_TO_ADDR
25635: LD_INT 5
25637: PUSH
25638: FOR_TO
25639: IFFALSE 25735
// begin vc_engine = 3 ;
25641: LD_ADDR_OWVAR 39
25645: PUSH
25646: LD_INT 3
25648: ST_TO_ADDR
// vc_control = 3 ;
25649: LD_ADDR_OWVAR 38
25653: PUSH
25654: LD_INT 3
25656: ST_TO_ADDR
// vc_chassis = 3 ;
25657: LD_ADDR_OWVAR 37
25661: PUSH
25662: LD_INT 3
25664: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25665: LD_ADDR_OWVAR 40
25669: PUSH
25670: LD_INT 5
25672: PUSH
25673: LD_INT 9
25675: PUSH
25676: LD_INT 7
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 1
25686: PPUSH
25687: LD_INT 3
25689: PPUSH
25690: CALL_OW 12
25694: ARRAY
25695: ST_TO_ADDR
// veh = CreateVehicle ;
25696: LD_ADDR_VAR 0 2
25700: PUSH
25701: CALL_OW 45
25705: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25706: LD_VAR 0 2
25710: PPUSH
25711: LD_INT 1
25713: PPUSH
25714: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25718: LD_VAR 0 2
25722: PPUSH
25723: LD_INT 19
25725: PPUSH
25726: LD_INT 0
25728: PPUSH
25729: CALL_OW 49
// end ;
25733: GO 25638
25735: POP
25736: POP
// vc_engine = 3 ;
25737: LD_ADDR_OWVAR 39
25741: PUSH
25742: LD_INT 3
25744: ST_TO_ADDR
// vc_control = 1 ;
25745: LD_ADDR_OWVAR 38
25749: PUSH
25750: LD_INT 1
25752: ST_TO_ADDR
// vc_chassis = 3 ;
25753: LD_ADDR_OWVAR 37
25757: PUSH
25758: LD_INT 3
25760: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25761: LD_ADDR_OWVAR 40
25765: PUSH
25766: LD_INT 5
25768: PUSH
25769: LD_INT 9
25771: PUSH
25772: LD_INT 7
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: PUSH
25780: LD_INT 1
25782: PPUSH
25783: LD_INT 3
25785: PPUSH
25786: CALL_OW 12
25790: ARRAY
25791: ST_TO_ADDR
// vehG = CreateVehicle ;
25792: LD_ADDR_VAR 0 3
25796: PUSH
25797: CALL_OW 45
25801: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25802: LD_VAR 0 3
25806: PPUSH
25807: LD_INT 1
25809: PPUSH
25810: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25814: LD_VAR 0 3
25818: PPUSH
25819: LD_INT 19
25821: PPUSH
25822: LD_INT 0
25824: PPUSH
25825: CALL_OW 49
// if JMMGirl = 1 then
25829: LD_EXP 7
25833: PUSH
25834: LD_INT 1
25836: EQUAL
25837: IFFALSE 25893
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25839: LD_ADDR_EXP 39
25843: PUSH
25844: LD_STRING Joan
25846: PPUSH
25847: LD_INT 1
25849: PPUSH
25850: LD_STRING 14_
25852: PPUSH
25853: CALL 64286 0 3
25857: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25858: LD_EXP 39
25862: PPUSH
25863: LD_VAR 0 3
25867: PPUSH
25868: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25872: LD_VAR 0 3
25876: PPUSH
25877: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25881: LD_EXP 39
25885: PPUSH
25886: LD_STRING D10BW-Joan-1
25888: PPUSH
25889: CALL_OW 94
// end ; if JMMGirl = 2 then
25893: LD_EXP 7
25897: PUSH
25898: LD_INT 2
25900: EQUAL
25901: IFFALSE 25957
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25903: LD_ADDR_EXP 41
25907: PUSH
25908: LD_STRING Lisa
25910: PPUSH
25911: LD_INT 1
25913: PPUSH
25914: LD_STRING 14_
25916: PPUSH
25917: CALL 64286 0 3
25921: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25922: LD_EXP 41
25926: PPUSH
25927: LD_VAR 0 3
25931: PPUSH
25932: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25936: LD_VAR 0 3
25940: PPUSH
25941: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25945: LD_EXP 41
25949: PPUSH
25950: LD_STRING D10BW-Lisa-1
25952: PPUSH
25953: CALL_OW 94
// end ; if JMMGirl = 3 then
25957: LD_EXP 7
25961: PUSH
25962: LD_INT 3
25964: EQUAL
25965: IFFALSE 26021
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25967: LD_ADDR_EXP 53
25971: PUSH
25972: LD_STRING Connie
25974: PPUSH
25975: LD_INT 1
25977: PPUSH
25978: LD_STRING 14_
25980: PPUSH
25981: CALL 64286 0 3
25985: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25986: LD_EXP 53
25990: PPUSH
25991: LD_VAR 0 3
25995: PPUSH
25996: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26000: LD_VAR 0 3
26004: PPUSH
26005: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26009: LD_EXP 53
26013: PPUSH
26014: LD_STRING D10BW-Con-1
26016: PPUSH
26017: CALL_OW 94
// end ; end ;
26021: PPOPN 3
26023: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26024: LD_EXP 14
26028: PUSH
26029: LD_INT 94500
26031: GREATEREQUAL
26032: IFFALSE 26444
26034: GO 26036
26036: DISABLE
26037: LD_INT 0
26039: PPUSH
26040: PPUSH
26041: PPUSH
// begin tmp := PrepareStevensSquad ;
26042: LD_ADDR_VAR 0 3
26046: PUSH
26047: CALL 2190 0 0
26051: ST_TO_ADDR
// if not tmp then
26052: LD_VAR 0 3
26056: NOT
26057: IFFALSE 26061
// exit ;
26059: GO 26444
// uc_side := 1 ;
26061: LD_ADDR_OWVAR 20
26065: PUSH
26066: LD_INT 1
26068: ST_TO_ADDR
// uc_nation := 1 ;
26069: LD_ADDR_OWVAR 21
26073: PUSH
26074: LD_INT 1
26076: ST_TO_ADDR
// for i in tmp do
26077: LD_ADDR_VAR 0 1
26081: PUSH
26082: LD_VAR 0 3
26086: PUSH
26087: FOR_IN
26088: IFFALSE 26185
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26090: LD_INT 3
26092: PPUSH
26093: LD_INT 3
26095: PPUSH
26096: LD_INT 1
26098: PPUSH
26099: LD_INT 5
26101: PUSH
26102: LD_INT 9
26104: PUSH
26105: LD_INT 7
26107: PUSH
26108: EMPTY
26109: LIST
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 1
26115: PPUSH
26116: LD_INT 3
26118: PPUSH
26119: CALL_OW 12
26123: ARRAY
26124: PPUSH
26125: LD_INT 40
26127: PPUSH
26128: CALL 71401 0 5
// veh := CreateVehicle ;
26132: LD_ADDR_VAR 0 2
26136: PUSH
26137: CALL_OW 45
26141: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26142: LD_VAR 0 2
26146: PPUSH
26147: LD_INT 1
26149: PPUSH
26150: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26154: LD_VAR 0 2
26158: PPUSH
26159: LD_INT 19
26161: PPUSH
26162: LD_INT 0
26164: PPUSH
26165: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26169: LD_VAR 0 1
26173: PPUSH
26174: LD_VAR 0 2
26178: PPUSH
26179: CALL_OW 52
// end ;
26183: GO 26087
26185: POP
26186: POP
// missionStage := 8 ;
26187: LD_ADDR_EXP 15
26191: PUSH
26192: LD_INT 8
26194: ST_TO_ADDR
// DialogueOn ;
26195: CALL_OW 6
// if Stevens then
26199: LD_EXP 40
26203: IFFALSE 26317
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26205: LD_EXP 40
26209: PPUSH
26210: CALL_OW 310
26214: PPUSH
26215: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26219: LD_EXP 40
26223: PPUSH
26224: LD_STRING D8-Huck-1
26226: PPUSH
26227: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26231: LD_EXP 38
26235: PPUSH
26236: LD_STRING D8-JMM-1
26238: PPUSH
26239: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26243: LD_EXP 40
26247: PPUSH
26248: LD_STRING D8-Huck-2
26250: PPUSH
26251: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26255: LD_EXP 38
26259: PPUSH
26260: LD_STRING D8-JMM-2
26262: PPUSH
26263: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26267: LD_EXP 40
26271: PPUSH
26272: LD_STRING D8-Huck-3
26274: PPUSH
26275: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26279: LD_EXP 38
26283: PPUSH
26284: LD_STRING D8-JMM-3
26286: PPUSH
26287: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26291: LD_EXP 40
26295: PPUSH
26296: LD_STRING D8-Huck-4
26298: PPUSH
26299: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26303: LD_EXP 38
26307: PPUSH
26308: LD_STRING D8-JMM-4
26310: PPUSH
26311: CALL_OW 88
// end else
26315: GO 26427
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26317: LD_EXP 54
26321: PPUSH
26322: CALL_OW 310
26326: PPUSH
26327: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26331: LD_EXP 54
26335: PPUSH
26336: LD_STRING D8-Huck-1
26338: PPUSH
26339: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26343: LD_EXP 38
26347: PPUSH
26348: LD_STRING D8-JMM-1a
26350: PPUSH
26351: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26355: LD_EXP 54
26359: PPUSH
26360: LD_STRING D8-Huck-2
26362: PPUSH
26363: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26367: LD_EXP 38
26371: PPUSH
26372: LD_STRING D8-JMM-2
26374: PPUSH
26375: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26379: LD_EXP 54
26383: PPUSH
26384: LD_STRING D8-Huck-3
26386: PPUSH
26387: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26391: LD_EXP 38
26395: PPUSH
26396: LD_STRING D8-JMM-3
26398: PPUSH
26399: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26403: LD_EXP 54
26407: PPUSH
26408: LD_STRING D8-Huck-4
26410: PPUSH
26411: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26415: LD_EXP 38
26419: PPUSH
26420: LD_STRING D8-JMM-4
26422: PPUSH
26423: CALL_OW 88
// end ; DialogueOff ;
26427: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26431: LD_INT 25
26433: PPUSH
26434: LD_INT 1
26436: PPUSH
26437: LD_INT 1
26439: PPUSH
26440: CALL_OW 322
// end ;
26444: PPOPN 3
26446: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26447: LD_INT 1
26449: PPUSH
26450: LD_EXP 70
26454: PPUSH
26455: CALL_OW 292
26459: IFFALSE 26710
26461: GO 26463
26463: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26464: LD_EXP 70
26468: PPUSH
26469: CALL_OW 87
// DialogueOn ;
26473: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26477: LD_EXP 38
26481: PPUSH
26482: LD_STRING D10nB-JMM-1
26484: PPUSH
26485: CALL_OW 88
// if BurlakStatus = 1 then
26489: LD_EXP 9
26493: PUSH
26494: LD_INT 1
26496: EQUAL
26497: IFFALSE 26511
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26499: LD_EXP 69
26503: PPUSH
26504: LD_STRING D10nB-Vse-1a
26506: PPUSH
26507: CALL_OW 94
// end ; if BurlakStatus = 0 then
26511: LD_EXP 9
26515: PUSH
26516: LD_INT 0
26518: EQUAL
26519: IFFALSE 26533
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26521: LD_EXP 69
26525: PPUSH
26526: LD_STRING D10nB-Vse-1
26528: PPUSH
26529: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26533: LD_EXP 38
26537: PPUSH
26538: LD_STRING D10nB-JMM-2
26540: PPUSH
26541: CALL_OW 88
// if KappaStatus then
26545: LD_EXP 2
26549: IFFALSE 26563
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26551: LD_EXP 69
26555: PPUSH
26556: LD_STRING D10nB-Vse-5a
26558: PPUSH
26559: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26563: LD_EXP 2
26567: NOT
26568: PUSH
26569: LD_EXP 6
26573: PUSH
26574: LD_INT 0
26576: EQUAL
26577: AND
26578: IFFALSE 26706
// begin if JMMGirl = 1 then
26580: LD_EXP 7
26584: PUSH
26585: LD_INT 1
26587: EQUAL
26588: IFFALSE 26638
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26590: LD_EXP 69
26594: PPUSH
26595: LD_STRING D10nB-Vse-2
26597: PPUSH
26598: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26602: LD_EXP 38
26606: PPUSH
26607: LD_STRING D10nB-JMM-3
26609: PPUSH
26610: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26614: LD_EXP 69
26618: PPUSH
26619: LD_STRING D10nB-Vse-3
26621: PPUSH
26622: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26626: LD_EXP 38
26630: PPUSH
26631: LD_STRING D10nB-JMM-4
26633: PPUSH
26634: CALL_OW 88
// end ; if JMMGirl = 2 then
26638: LD_EXP 7
26642: PUSH
26643: LD_INT 2
26645: EQUAL
26646: IFFALSE 26672
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26648: LD_EXP 69
26652: PPUSH
26653: LD_STRING D10nB-Vse-4
26655: PPUSH
26656: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26660: LD_EXP 38
26664: PPUSH
26665: LD_STRING D10nB-JMM-5
26667: PPUSH
26668: CALL_OW 88
// end ; if JMMGirl = 3 then
26672: LD_EXP 7
26676: PUSH
26677: LD_INT 3
26679: EQUAL
26680: IFFALSE 26706
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26682: LD_EXP 69
26686: PPUSH
26687: LD_STRING D10nB-Vse-5
26689: PPUSH
26690: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26694: LD_EXP 38
26698: PPUSH
26699: LD_STRING D10nB-JMM-6
26701: PPUSH
26702: CALL_OW 88
// end ; end ; DialogueOff ;
26706: CALL_OW 7
// end ;
26710: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26711: LD_EXP 14
26715: PUSH
26716: LD_INT 115500
26718: GREATEREQUAL
26719: IFFALSE 27095
26721: GO 26723
26723: DISABLE
26724: LD_INT 0
26726: PPUSH
// begin missionStage := 10 ;
26727: LD_ADDR_EXP 15
26731: PUSH
26732: LD_INT 10
26734: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26735: LD_ADDR_VAR 0 1
26739: PUSH
26740: LD_INT 22
26742: PUSH
26743: LD_INT 1
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 23
26752: PUSH
26753: LD_INT 1
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 26
26762: PUSH
26763: LD_INT 1
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: LD_INT 3
26772: PUSH
26773: LD_INT 25
26775: PUSH
26776: LD_INT 12
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: PUSH
26787: LD_INT 3
26789: PUSH
26790: LD_INT 25
26792: PUSH
26793: LD_INT 16
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: LIST
26810: PPUSH
26811: CALL_OW 69
26815: PUSH
26816: LD_EXP 38
26820: PUSH
26821: LD_EXP 59
26825: PUSH
26826: LD_EXP 40
26830: PUSH
26831: LD_EXP 54
26835: PUSH
26836: LD_EXP 41
26840: PUSH
26841: LD_EXP 42
26845: PUSH
26846: LD_EXP 43
26850: PUSH
26851: LD_EXP 44
26855: PUSH
26856: LD_EXP 45
26860: PUSH
26861: LD_EXP 46
26865: PUSH
26866: LD_EXP 47
26870: PUSH
26871: LD_EXP 48
26875: PUSH
26876: LD_EXP 49
26880: PUSH
26881: LD_EXP 50
26885: PUSH
26886: LD_EXP 51
26890: PUSH
26891: LD_EXP 52
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: LIST
26913: DIFF
26914: ST_TO_ADDR
// if not tmp and Brown then
26915: LD_VAR 0 1
26919: NOT
26920: PUSH
26921: LD_EXP 46
26925: AND
26926: IFFALSE 26941
// tmp := [ Brown ] ;
26928: LD_ADDR_VAR 0 1
26932: PUSH
26933: LD_EXP 46
26937: PUSH
26938: EMPTY
26939: LIST
26940: ST_TO_ADDR
// DialogueOn ;
26941: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26945: LD_VAR 0 1
26949: PUSH
26950: LD_INT 1
26952: ARRAY
26953: PPUSH
26954: LD_STRING D11-Sol1-1
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26961: LD_EXP 63
26965: PPUSH
26966: LD_STRING D11-Pla-1
26968: PPUSH
26969: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26973: LD_EXP 64
26977: PPUSH
26978: LD_STRING D11-Kov-1
26980: PPUSH
26981: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26985: LD_EXP 63
26989: PPUSH
26990: LD_STRING D11-Pla-2
26992: PPUSH
26993: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26997: LD_VAR 0 1
27001: PUSH
27002: LD_INT 1
27004: ARRAY
27005: PPUSH
27006: LD_STRING D11-Sol1-2
27008: PPUSH
27009: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27013: LD_EXP 38
27017: PPUSH
27018: LD_STRING D11-JMM-2
27020: PPUSH
27021: CALL_OW 88
// DialogueOff ;
27025: CALL_OW 7
// allowBehemothConstruct := true ;
27029: LD_ADDR_EXP 25
27033: PUSH
27034: LD_INT 1
27036: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27037: LD_STRING M4
27039: PPUSH
27040: CALL_OW 337
// BuildBehemoths ;
27044: CALL 7620 0 0
// repeat wait ( 15 15$00 ) ;
27048: LD_INT 31500
27050: PPUSH
27051: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27055: LD_EXP 27
27059: IFFALSE 27063
// break ;
27061: GO 27095
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27063: LD_INT 267
27065: PPUSH
27066: CALL_OW 274
27070: PPUSH
27071: LD_INT 1
27073: PPUSH
27074: CALL_OW 275
27078: PUSH
27079: LD_INT 1000
27081: GREATEREQUAL
27082: IFFALSE 27088
// BuildBehemoths ;
27084: CALL 7620 0 0
// until not behemothBuilders ;
27088: LD_EXP 72
27092: NOT
27093: IFFALSE 27048
// end ;
27095: PPOPN 1
27097: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27098: LD_EXP 72
27102: NOT
27103: PUSH
27104: LD_EXP 28
27108: NOT
27109: AND
27110: PUSH
27111: LD_EXP 25
27115: AND
27116: IFFALSE 27136
27118: GO 27120
27120: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27121: LD_STRING M4a
27123: PPUSH
27124: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27128: LD_ADDR_EXP 27
27132: PUSH
27133: LD_INT 1
27135: ST_TO_ADDR
// end ;
27136: END
// every 0 0$1 trigger behemothDone do
27137: LD_EXP 28
27141: IFFALSE 27153
27143: GO 27145
27145: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27146: LD_STRING M4b
27148: PPUSH
27149: CALL_OW 337
27153: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27154: LD_EXP 29
27158: NOT
27159: IFFALSE 27355
27161: GO 27163
27163: DISABLE
27164: LD_INT 0
27166: PPUSH
27167: PPUSH
// begin enable ;
27168: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27169: LD_ADDR_VAR 0 1
27173: PUSH
27174: LD_INT 3
27176: PPUSH
27177: CALL 107197 0 1
27181: ST_TO_ADDR
// if not tmp and not behemothDone then
27182: LD_VAR 0 1
27186: NOT
27187: PUSH
27188: LD_EXP 28
27192: NOT
27193: AND
27194: IFFALSE 27230
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27196: LD_ADDR_VAR 0 1
27200: PUSH
27201: LD_INT 22
27203: PUSH
27204: LD_INT 3
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 30
27213: PUSH
27214: LD_INT 37
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PPUSH
27225: CALL_OW 69
27229: ST_TO_ADDR
// if not tmp then
27230: LD_VAR 0 1
27234: NOT
27235: IFFALSE 27239
// exit ;
27237: GO 27355
// for i in tmp do
27239: LD_ADDR_VAR 0 2
27243: PUSH
27244: LD_VAR 0 1
27248: PUSH
27249: FOR_IN
27250: IFFALSE 27353
// if See ( 1 , i ) then
27252: LD_INT 1
27254: PPUSH
27255: LD_VAR 0 2
27259: PPUSH
27260: CALL_OW 292
27264: IFFALSE 27351
// begin if GetType ( i ) = unit_building then
27266: LD_VAR 0 2
27270: PPUSH
27271: CALL_OW 247
27275: PUSH
27276: LD_INT 3
27278: EQUAL
27279: IFFALSE 27317
// begin CenterNowOnUnits ( i ) ;
27281: LD_VAR 0 2
27285: PPUSH
27286: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27290: LD_EXP 38
27294: PPUSH
27295: LD_STRING D17a-JMM-1
27297: PPUSH
27298: CALL_OW 88
// seeBehemoth := true ;
27302: LD_ADDR_EXP 29
27306: PUSH
27307: LD_INT 1
27309: ST_TO_ADDR
// disable ;
27310: DISABLE
// exit ;
27311: POP
27312: POP
27313: GO 27355
// end else
27315: GO 27351
// begin CenterNowOnUnits ( i ) ;
27317: LD_VAR 0 2
27321: PPUSH
27322: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27326: LD_EXP 38
27330: PPUSH
27331: LD_STRING D17b-JMM-1
27333: PPUSH
27334: CALL_OW 88
// seeBehemoth := true ;
27338: LD_ADDR_EXP 29
27342: PUSH
27343: LD_INT 1
27345: ST_TO_ADDR
// disable ;
27346: DISABLE
// exit ;
27347: POP
27348: POP
27349: GO 27355
// end ; end ;
27351: GO 27249
27353: POP
27354: POP
// end ;
27355: PPOPN 2
27357: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27358: LD_EXP 14
27362: PUSH
27363: LD_INT 116550
27365: GREATEREQUAL
27366: IFFALSE 28542
27368: GO 27370
27370: DISABLE
27371: LD_INT 0
27373: PPUSH
27374: PPUSH
27375: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27376: LD_INT 2
27378: PPUSH
27379: LD_INT 23
27381: PUSH
27382: LD_INT 3
27384: PUSH
27385: LD_INT 3
27387: PUSH
27388: LD_INT 48
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: PUSH
27397: EMPTY
27398: LIST
27399: PPUSH
27400: CALL 57942 0 2
// repeat wait ( 0 0$1 ) ;
27404: LD_INT 35
27406: PPUSH
27407: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27411: LD_INT 22
27413: PUSH
27414: LD_INT 3
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 34
27423: PUSH
27424: LD_INT 48
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PPUSH
27435: CALL_OW 69
27439: IFFALSE 27404
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27441: LD_ADDR_VAR 0 1
27445: PUSH
27446: LD_INT 22
27448: PUSH
27449: LD_INT 3
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 34
27458: PUSH
27459: LD_INT 48
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PPUSH
27470: CALL_OW 69
27474: PUSH
27475: LD_INT 1
27477: ARRAY
27478: ST_TO_ADDR
// missionStage := 12 ;
27479: LD_ADDR_EXP 15
27483: PUSH
27484: LD_INT 12
27486: ST_TO_ADDR
// platonovHasBomb := true ;
27487: LD_ADDR_EXP 30
27491: PUSH
27492: LD_INT 1
27494: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27495: LD_VAR 0 1
27499: PPUSH
27500: LD_INT 181
27502: PPUSH
27503: LD_INT 86
27505: PPUSH
27506: CALL_OW 171
// AddComHold ( bomb ) ;
27510: LD_VAR 0 1
27514: PPUSH
27515: CALL_OW 200
// wait ( 0 0$10 ) ;
27519: LD_INT 350
27521: PPUSH
27522: CALL_OW 67
// DialogueOn ;
27526: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27530: LD_EXP 63
27534: PPUSH
27535: LD_STRING D15-Pla-1
27537: PPUSH
27538: CALL_OW 94
// dec = Query ( Q15a ) ;
27542: LD_ADDR_VAR 0 2
27546: PUSH
27547: LD_STRING Q15a
27549: PPUSH
27550: CALL_OW 97
27554: ST_TO_ADDR
// if dec = 1 then
27555: LD_VAR 0 2
27559: PUSH
27560: LD_INT 1
27562: EQUAL
27563: IFFALSE 27586
// begin Say ( JMM , D15a-JMM-1 ) ;
27565: LD_EXP 38
27569: PPUSH
27570: LD_STRING D15a-JMM-1
27572: PPUSH
27573: CALL_OW 88
// YouLost ( Surrender ) ;
27577: LD_STRING Surrender
27579: PPUSH
27580: CALL_OW 104
// exit ;
27584: GO 28542
// end ; if dec = 2 then
27586: LD_VAR 0 2
27590: PUSH
27591: LD_INT 2
27593: EQUAL
27594: IFFALSE 27663
// begin Say ( JMM , D15b-JMM-1 ) ;
27596: LD_EXP 38
27600: PPUSH
27601: LD_STRING D15b-JMM-1
27603: PPUSH
27604: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27608: LD_EXP 63
27612: PPUSH
27613: LD_STRING D15b-Pla-1
27615: PPUSH
27616: CALL_OW 94
// DialogueOff ;
27620: CALL_OW 7
// wait ( 3 3$00 ) ;
27624: LD_INT 6300
27626: PPUSH
27627: CALL_OW 67
// DialogueOn ;
27631: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27635: LD_EXP 38
27639: PPUSH
27640: LD_STRING D15d-JMM-1a
27642: PPUSH
27643: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27647: LD_EXP 63
27651: PPUSH
27652: LD_STRING D15d-Pla-1
27654: PPUSH
27655: CALL_OW 94
// DialogueOff ;
27659: CALL_OW 7
// end ; if dec = 3 then
27663: LD_VAR 0 2
27667: PUSH
27668: LD_INT 3
27670: EQUAL
27671: IFFALSE 27725
// begin Say ( JMM , D15c-JMM-1 ) ;
27673: LD_EXP 38
27677: PPUSH
27678: LD_STRING D15c-JMM-1
27680: PPUSH
27681: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27685: LD_EXP 63
27689: PPUSH
27690: LD_STRING D15c-Pla-1
27692: PPUSH
27693: CALL_OW 94
// DialogueOff ;
27697: CALL_OW 7
// wait ( 0 0$15 ) ;
27701: LD_INT 525
27703: PPUSH
27704: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27708: LD_VAR 0 1
27712: PPUSH
27713: LD_INT 60
27715: PPUSH
27716: LD_INT 95
27718: PPUSH
27719: CALL_OW 116
// exit ;
27723: GO 28542
// end ; if dec = 4 then
27725: LD_VAR 0 2
27729: PUSH
27730: LD_INT 4
27732: EQUAL
27733: IFFALSE 27763
// begin Say ( JMM , D15d-JMM-1 ) ;
27735: LD_EXP 38
27739: PPUSH
27740: LD_STRING D15d-JMM-1
27742: PPUSH
27743: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27747: LD_EXP 63
27751: PPUSH
27752: LD_STRING D15d-Pla-1
27754: PPUSH
27755: CALL_OW 94
// DialogueOff ;
27759: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27763: LD_EXP 61
27767: PPUSH
27768: CALL_OW 302
27772: PUSH
27773: LD_EXP 61
27777: PPUSH
27778: CALL_OW 255
27782: PUSH
27783: LD_INT 1
27785: EQUAL
27786: AND
27787: PUSH
27788: LD_INT 22
27790: PUSH
27791: LD_INT 1
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 34
27800: PUSH
27801: LD_INT 8
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PPUSH
27812: CALL_OW 69
27816: NOT
27817: AND
27818: IFFALSE 28443
// begin SetSide ( Friend , 8 ) ;
27820: LD_EXP 61
27824: PPUSH
27825: LD_INT 8
27827: PPUSH
27828: CALL_OW 235
// if IsInUnit ( Friend ) then
27832: LD_EXP 61
27836: PPUSH
27837: CALL_OW 310
27841: IFFALSE 27852
// ComExitBuilding ( Friend ) ;
27843: LD_EXP 61
27847: PPUSH
27848: CALL_OW 122
// if IsDriver ( Friend ) then
27852: LD_EXP 61
27856: PPUSH
27857: CALL 104874 0 1
27861: IFFALSE 27872
// ComExitVehicle ( Friend ) ;
27863: LD_EXP 61
27867: PPUSH
27868: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27872: LD_EXP 61
27876: PPUSH
27877: LD_INT 9
27879: PPUSH
27880: LD_INT 2
27882: PPUSH
27883: CALL_OW 171
// wait ( 0 0$05 ) ;
27887: LD_INT 175
27889: PPUSH
27890: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27894: LD_EXP 61
27898: PPUSH
27899: CALL_OW 87
// DialogueOn ;
27903: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27907: LD_EXP 38
27911: PPUSH
27912: LD_STRING D16-JMM-1
27914: PPUSH
27915: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27919: LD_EXP 61
27923: PPUSH
27924: LD_STRING D16-Friend-1
27926: PPUSH
27927: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27931: LD_EXP 38
27935: PPUSH
27936: LD_STRING D16-JMM-2
27938: PPUSH
27939: CALL_OW 88
// DialogueOff ;
27943: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27947: LD_EXP 61
27951: PPUSH
27952: LD_INT 1
27954: PPUSH
27955: CALL_OW 235
// ComHold ( Friend ) ;
27959: LD_EXP 61
27963: PPUSH
27964: CALL_OW 140
// wait ( 0 0$20 ) ;
27968: LD_INT 700
27970: PPUSH
27971: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27975: LD_EXP 61
27979: PPUSH
27980: LD_INT 9
27982: PPUSH
27983: LD_INT 2
27985: PPUSH
27986: CALL_OW 297
27990: PUSH
27991: LD_INT 30
27993: LESS
27994: IFFALSE 28063
// begin SetSide ( Friend , 8 ) ;
27996: LD_EXP 61
28000: PPUSH
28001: LD_INT 8
28003: PPUSH
28004: CALL_OW 235
// if IsInUnit ( Friend ) then
28008: LD_EXP 61
28012: PPUSH
28013: CALL_OW 310
28017: IFFALSE 28028
// ComExitBuilding ( Friend ) ;
28019: LD_EXP 61
28023: PPUSH
28024: CALL_OW 122
// if IsDriver ( Friend ) then
28028: LD_EXP 61
28032: PPUSH
28033: CALL 104874 0 1
28037: IFFALSE 28048
// ComExitVehicle ( Friend ) ;
28039: LD_EXP 61
28043: PPUSH
28044: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28048: LD_EXP 61
28052: PPUSH
28053: LD_INT 9
28055: PPUSH
28056: LD_INT 2
28058: PPUSH
28059: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28063: LD_INT 1050
28065: PPUSH
28066: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28070: LD_INT 22
28072: PUSH
28073: LD_INT 1
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 34
28082: PUSH
28083: LD_INT 8
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: PPUSH
28094: CALL_OW 69
28098: NOT
28099: IFFALSE 28421
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28101: LD_ADDR_VAR 0 3
28105: PUSH
28106: LD_INT 22
28108: PUSH
28109: LD_INT 1
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 26
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 3
28128: PUSH
28129: LD_INT 25
28131: PUSH
28132: LD_INT 12
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 25
28141: PUSH
28142: LD_INT 16
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: LIST
28153: PUSH
28154: EMPTY
28155: LIST
28156: LIST
28157: LIST
28158: PPUSH
28159: CALL_OW 69
28163: PUSH
28164: LD_EXP 38
28168: PUSH
28169: LD_EXP 40
28173: PUSH
28174: LD_EXP 54
28178: PUSH
28179: LD_EXP 41
28183: PUSH
28184: LD_EXP 42
28188: PUSH
28189: LD_EXP 43
28193: PUSH
28194: LD_EXP 44
28198: PUSH
28199: LD_EXP 45
28203: PUSH
28204: LD_EXP 46
28208: PUSH
28209: LD_EXP 47
28213: PUSH
28214: LD_EXP 48
28218: PUSH
28219: LD_EXP 49
28223: PUSH
28224: LD_EXP 50
28228: PUSH
28229: LD_EXP 51
28233: PUSH
28234: LD_EXP 52
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: DIFF
28256: ST_TO_ADDR
// DialogueOn ;
28257: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28261: LD_EXP 63
28265: PPUSH
28266: LD_STRING D16a-Pla-1
28268: PPUSH
28269: CALL_OW 94
// if Stevens then
28273: LD_EXP 40
28277: IFFALSE 28293
// Say ( Stevens , D16a-Huck-1 ) else
28279: LD_EXP 40
28283: PPUSH
28284: LD_STRING D16a-Huck-1
28286: PPUSH
28287: CALL_OW 88
28291: GO 28335
// if Baker then
28293: LD_EXP 54
28297: IFFALSE 28313
// Say ( Baker , D16a-Huck-1 ) else
28299: LD_EXP 54
28303: PPUSH
28304: LD_STRING D16a-Huck-1
28306: PPUSH
28307: CALL_OW 88
28311: GO 28335
// if tmp then
28313: LD_VAR 0 3
28317: IFFALSE 28335
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28319: LD_VAR 0 3
28323: PUSH
28324: LD_INT 1
28326: ARRAY
28327: PPUSH
28328: LD_STRING D16a-Sol1-1
28330: PPUSH
28331: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28335: LD_EXP 61
28339: PPUSH
28340: CALL_OW 255
28344: PUSH
28345: LD_INT 8
28347: EQUAL
28348: IFFALSE 28364
// Say ( JMM , D16a-JMM-1 ) else
28350: LD_EXP 38
28354: PPUSH
28355: LD_STRING D16a-JMM-1
28357: PPUSH
28358: CALL_OW 88
28362: GO 28400
// begin Say ( JMM , D16a-JMM-1a ) ;
28364: LD_EXP 38
28368: PPUSH
28369: LD_STRING D16a-JMM-1a
28371: PPUSH
28372: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28376: LD_EXP 61
28380: PPUSH
28381: LD_STRING D16a-Friend-1
28383: PPUSH
28384: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28388: LD_EXP 61
28392: PPUSH
28393: LD_INT 3
28395: PPUSH
28396: CALL_OW 235
// end ; DialogueOff ;
28400: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28404: LD_VAR 0 1
28408: PPUSH
28409: LD_INT 60
28411: PPUSH
28412: LD_INT 95
28414: PPUSH
28415: CALL_OW 116
// end else
28419: GO 28441
// begin DialogueOn ;
28421: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28425: LD_EXP 63
28429: PPUSH
28430: LD_STRING D16c-Pla-
28432: PPUSH
28433: CALL_OW 94
// DialogueOff ;
28437: CALL_OW 7
// end ; end else
28441: GO 28542
// begin wait ( 3 3$00 ) ;
28443: LD_INT 6300
28445: PPUSH
28446: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28450: LD_INT 22
28452: PUSH
28453: LD_INT 1
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 34
28462: PUSH
28463: LD_INT 8
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PPUSH
28474: CALL_OW 69
28478: NOT
28479: IFFALSE 28522
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28481: LD_EXP 63
28485: PPUSH
28486: LD_STRING D16b-Pla-1
28488: PPUSH
28489: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28493: LD_EXP 38
28497: PPUSH
28498: LD_STRING D16b-JMM-
28500: PPUSH
28501: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28505: LD_VAR 0 1
28509: PPUSH
28510: LD_INT 60
28512: PPUSH
28513: LD_INT 95
28515: PPUSH
28516: CALL_OW 116
// end else
28520: GO 28542
// begin DialogueOn ;
28522: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28526: LD_EXP 63
28530: PPUSH
28531: LD_STRING D16c-Pla-
28533: PPUSH
28534: CALL_OW 94
// DialogueOff ;
28538: CALL_OW 7
// end ; end ; end ;
28542: PPOPN 3
28544: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28545: LD_EXP 14
28549: PUSH
28550: LD_INT 126000
28552: GREATEREQUAL
28553: PUSH
28554: LD_EXP 23
28558: NOT
28559: AND
28560: PUSH
28561: LD_EXP 73
28565: PPUSH
28566: CALL_OW 302
28570: AND
28571: IFFALSE 28929
28573: GO 28575
28575: DISABLE
28576: LD_INT 0
28578: PPUSH
// begin missionStage = 11 ;
28579: LD_ADDR_EXP 15
28583: PUSH
28584: LD_INT 11
28586: ST_TO_ADDR
// DialogueOn ;
28587: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28591: LD_EXP 73
28595: PPUSH
28596: LD_STRING D9-Roth-1
28598: PPUSH
28599: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28603: LD_EXP 38
28607: PPUSH
28608: LD_STRING D9-JMM-1
28610: PPUSH
28611: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28615: LD_EXP 73
28619: PPUSH
28620: LD_STRING D9-Roth-2
28622: PPUSH
28623: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28627: LD_EXP 73
28631: PPUSH
28632: LD_STRING D9-Roth-2a
28634: PPUSH
28635: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28639: LD_EXP 63
28643: PPUSH
28644: LD_STRING D9-Pla-2
28646: PPUSH
28647: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28651: LD_EXP 73
28655: PPUSH
28656: LD_STRING D9-Roth-3
28658: PPUSH
28659: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28663: LD_EXP 63
28667: PPUSH
28668: LD_STRING D9-Pla-3
28670: PPUSH
28671: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28675: LD_EXP 73
28679: PPUSH
28680: LD_STRING D9-Roth-4
28682: PPUSH
28683: CALL_OW 94
// dec = Query ( Q9 ) ;
28687: LD_ADDR_VAR 0 1
28691: PUSH
28692: LD_STRING Q9
28694: PPUSH
28695: CALL_OW 97
28699: ST_TO_ADDR
// if dec = 1 then
28700: LD_VAR 0 1
28704: PUSH
28705: LD_INT 1
28707: EQUAL
28708: IFFALSE 28722
// SayRadio ( Roth , D9a-Roth-1 ) ;
28710: LD_EXP 73
28714: PPUSH
28715: LD_STRING D9a-Roth-1
28717: PPUSH
28718: CALL_OW 94
// if dec = 2 then
28722: LD_VAR 0 1
28726: PUSH
28727: LD_INT 2
28729: EQUAL
28730: IFFALSE 28756
// begin Say ( JMM , D9b-JMM-1 ) ;
28732: LD_EXP 38
28736: PPUSH
28737: LD_STRING D9b-JMM-1
28739: PPUSH
28740: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28744: LD_EXP 73
28748: PPUSH
28749: LD_STRING D9b-Roth-1
28751: PPUSH
28752: CALL_OW 94
// end ; if dec = 3 then
28756: LD_VAR 0 1
28760: PUSH
28761: LD_INT 3
28763: EQUAL
28764: IFFALSE 28826
// begin Say ( JMM , D9c-JMM-1 ) ;
28766: LD_EXP 38
28770: PPUSH
28771: LD_STRING D9c-JMM-1
28773: PPUSH
28774: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28778: LD_EXP 73
28782: PPUSH
28783: LD_STRING D9c-Roth-1
28785: PPUSH
28786: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28790: LD_EXP 38
28794: PPUSH
28795: LD_STRING D9c-JMM-2
28797: PPUSH
28798: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28802: LD_EXP 73
28806: PPUSH
28807: LD_STRING D9c-Roth-2
28809: PPUSH
28810: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28814: LD_EXP 38
28818: PPUSH
28819: LD_STRING D9c-JMM-3
28821: PPUSH
28822: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28826: LD_EXP 73
28830: PPUSH
28831: LD_STRING D9c-Roth-3
28833: PPUSH
28834: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28838: LD_EXP 73
28842: PPUSH
28843: LD_STRING D9cont-Roth-1
28845: PPUSH
28846: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28850: LD_EXP 38
28854: PPUSH
28855: LD_STRING D9cont-JMM-1
28857: PPUSH
28858: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28862: LD_EXP 73
28866: PPUSH
28867: LD_STRING D9cont-Roth-2
28869: PPUSH
28870: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28874: LD_EXP 38
28878: PPUSH
28879: LD_STRING D9cont-JMM-2
28881: PPUSH
28882: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28886: LD_EXP 73
28890: PPUSH
28891: LD_STRING D9cont-Roth-3
28893: PPUSH
28894: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28898: LD_EXP 38
28902: PPUSH
28903: LD_STRING D9cont-JMM-3
28905: PPUSH
28906: CALL_OW 88
// DialogueOff ;
28910: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28914: LD_STRING M3
28916: PPUSH
28917: CALL_OW 337
// allianceActive := true ;
28921: LD_ADDR_EXP 31
28925: PUSH
28926: LD_INT 1
28928: ST_TO_ADDR
// end ;
28929: PPOPN 1
28931: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28932: LD_EXP 63
28936: PPUSH
28937: CALL_OW 301
28941: PUSH
28942: LD_EXP 66
28946: PPUSH
28947: CALL_OW 301
28951: AND
28952: PUSH
28953: LD_INT 22
28955: PUSH
28956: LD_INT 3
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: LD_INT 21
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PUSH
28973: LD_INT 50
28975: PUSH
28976: EMPTY
28977: LIST
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: LIST
28983: PPUSH
28984: CALL_OW 69
28988: PUSH
28989: LD_INT 7
28991: PUSH
28992: LD_INT 8
28994: PUSH
28995: LD_INT 9
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: LIST
29002: PUSH
29003: LD_OWVAR 67
29007: ARRAY
29008: LESS
29009: AND
29010: IFFALSE 29781
29012: GO 29014
29014: DISABLE
29015: LD_INT 0
29017: PPUSH
29018: PPUSH
29019: PPUSH
29020: PPUSH
// begin MC_Kill ( 1 ) ;
29021: LD_INT 1
29023: PPUSH
29024: CALL 34482 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29028: LD_INT 1
29030: PPUSH
29031: LD_INT 3
29033: PPUSH
29034: LD_INT 1
29036: PPUSH
29037: LD_INT 1
29039: PPUSH
29040: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29044: LD_ADDR_VAR 0 1
29048: PUSH
29049: LD_INT 22
29051: PUSH
29052: LD_INT 3
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 21
29061: PUSH
29062: LD_INT 1
29064: PUSH
29065: EMPTY
29066: LIST
29067: LIST
29068: PUSH
29069: LD_INT 24
29071: PUSH
29072: LD_INT 900
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: LIST
29083: PPUSH
29084: CALL_OW 69
29088: PUSH
29089: FOR_IN
29090: IFFALSE 29121
// if GetSex ( i ) = sex_male then
29092: LD_VAR 0 1
29096: PPUSH
29097: CALL_OW 258
29101: PUSH
29102: LD_INT 1
29104: EQUAL
29105: IFFALSE 29119
// begin tmp = i ;
29107: LD_ADDR_VAR 0 2
29111: PUSH
29112: LD_VAR 0 1
29116: ST_TO_ADDR
// break ;
29117: GO 29121
// end ;
29119: GO 29089
29121: POP
29122: POP
// if tmp = 0 then
29123: LD_VAR 0 2
29127: PUSH
29128: LD_INT 0
29130: EQUAL
29131: IFFALSE 29185
// begin uc_side = 3 ;
29133: LD_ADDR_OWVAR 20
29137: PUSH
29138: LD_INT 3
29140: ST_TO_ADDR
// uc_nation = 3 ;
29141: LD_ADDR_OWVAR 21
29145: PUSH
29146: LD_INT 3
29148: ST_TO_ADDR
// hc_name =  ;
29149: LD_ADDR_OWVAR 26
29153: PUSH
29154: LD_STRING 
29156: ST_TO_ADDR
// hc_gallery =  ;
29157: LD_ADDR_OWVAR 33
29161: PUSH
29162: LD_STRING 
29164: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29165: LD_INT 1
29167: PPUSH
29168: LD_INT 10
29170: PPUSH
29171: CALL_OW 381
// tmp = CreateHuman ;
29175: LD_ADDR_VAR 0 2
29179: PUSH
29180: CALL_OW 44
29184: ST_TO_ADDR
// end ; DialogueOn ;
29185: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29189: LD_VAR 0 2
29193: PPUSH
29194: LD_STRING DSurrenderRussians-RSol1-1a
29196: PPUSH
29197: CALL_OW 94
// DialogueOff ;
29201: CALL_OW 7
// russianDestroyed := true ;
29205: LD_ADDR_EXP 21
29209: PUSH
29210: LD_INT 1
29212: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29213: LD_INT 22
29215: PUSH
29216: LD_INT 3
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 21
29225: PUSH
29226: LD_INT 1
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PPUSH
29237: CALL_OW 69
29241: PPUSH
29242: CALL_OW 122
// wait ( 0 0$1 ) ;
29246: LD_INT 35
29248: PPUSH
29249: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29253: LD_INT 22
29255: PUSH
29256: LD_INT 3
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 21
29265: PUSH
29266: LD_INT 1
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PPUSH
29277: CALL_OW 69
29281: PPUSH
29282: LD_INT 25
29284: PPUSH
29285: CALL_OW 173
// wait ( 0 0$10 ) ;
29289: LD_INT 350
29291: PPUSH
29292: CALL_OW 67
// PrepareOmarInvasion ;
29296: CALL 13753 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29300: LD_ADDR_VAR 0 2
29304: PUSH
29305: LD_EXP 91
29309: PPUSH
29310: CALL_OW 250
29314: PUSH
29315: LD_EXP 91
29319: PPUSH
29320: CALL_OW 251
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29329: LD_VAR 0 2
29333: PUSH
29334: LD_INT 1
29336: ARRAY
29337: PPUSH
29338: LD_VAR 0 2
29342: PUSH
29343: LD_INT 2
29345: ARRAY
29346: PPUSH
29347: LD_INT 1
29349: PPUSH
29350: LD_INT 8
29352: NEG
29353: PPUSH
29354: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29358: LD_EXP 91
29362: PPUSH
29363: CALL_OW 87
// DialogueOn ;
29367: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29371: LD_EXP 38
29375: PPUSH
29376: LD_STRING D19-JMM-1
29378: PPUSH
29379: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29383: LD_ADDR_VAR 0 3
29387: PUSH
29388: LD_INT 22
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 26
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: PUSH
29411: LD_INT 25
29413: PUSH
29414: LD_INT 1
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 25
29423: PUSH
29424: LD_INT 2
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 25
29433: PUSH
29434: LD_INT 3
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 25
29443: PUSH
29444: LD_INT 4
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 25
29453: PUSH
29454: LD_INT 5
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 25
29463: PUSH
29464: LD_INT 8
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: LIST
29484: PPUSH
29485: CALL_OW 69
29489: PUSH
29490: LD_EXP 38
29494: PUSH
29495: LD_EXP 39
29499: PUSH
29500: LD_EXP 40
29504: PUSH
29505: LD_EXP 41
29509: PUSH
29510: LD_EXP 42
29514: PUSH
29515: LD_EXP 43
29519: PUSH
29520: LD_EXP 44
29524: PUSH
29525: LD_EXP 45
29529: PUSH
29530: LD_EXP 46
29534: PUSH
29535: LD_EXP 47
29539: PUSH
29540: LD_EXP 48
29544: PUSH
29545: LD_EXP 49
29549: PUSH
29550: LD_EXP 50
29554: PUSH
29555: LD_EXP 51
29559: PUSH
29560: LD_EXP 52
29564: PUSH
29565: LD_EXP 53
29569: PUSH
29570: LD_EXP 54
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: LIST
29579: LIST
29580: LIST
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: DIFF
29594: ST_TO_ADDR
// if tmp2 then
29595: LD_VAR 0 3
29599: IFFALSE 29617
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29601: LD_VAR 0 3
29605: PUSH
29606: LD_INT 1
29608: ARRAY
29609: PPUSH
29610: LD_STRING D19-Sol1-1
29612: PPUSH
29613: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29617: LD_EXP 38
29621: PPUSH
29622: LD_STRING D19-JMM-2
29624: PPUSH
29625: CALL_OW 88
// DialogueOff ;
29629: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29633: LD_VAR 0 2
29637: PUSH
29638: LD_INT 1
29640: ARRAY
29641: PPUSH
29642: LD_VAR 0 2
29646: PUSH
29647: LD_INT 2
29649: ARRAY
29650: PPUSH
29651: LD_INT 1
29653: PPUSH
29654: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29658: LD_STRING M5
29660: PPUSH
29661: CALL_OW 337
// omarOnMotherLode := false ;
29665: LD_ADDR_VAR 0 4
29669: PUSH
29670: LD_INT 0
29672: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29673: LD_INT 35
29675: PPUSH
29676: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29680: LD_EXP 91
29684: PPUSH
29685: LD_INT 215
29687: PPUSH
29688: LD_INT 100
29690: PPUSH
29691: CALL_OW 297
29695: PUSH
29696: LD_INT 10
29698: LESS
29699: PUSH
29700: LD_VAR 0 4
29704: NOT
29705: AND
29706: IFFALSE 29740
// begin omarOnMotherLode := true ;
29708: LD_ADDR_VAR 0 4
29712: PUSH
29713: LD_INT 1
29715: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29716: LD_EXP 38
29720: PPUSH
29721: LD_STRING D19b-JMM-1
29723: PPUSH
29724: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29728: LD_EXP 91
29732: PPUSH
29733: LD_STRING DOmarContam-Omar-1
29735: PPUSH
29736: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29740: LD_EXP 91
29744: PPUSH
29745: CALL_OW 301
29749: IFFALSE 29673
// Say ( JMM , D19a-JMM-1 ) ;
29751: LD_EXP 38
29755: PPUSH
29756: LD_STRING D19a-JMM-1
29758: PPUSH
29759: CALL_OW 88
// if Heike then
29763: LD_EXP 92
29767: IFFALSE 29781
// Say ( Heike , D19a-Hke-1 ) ;
29769: LD_EXP 92
29773: PPUSH
29774: LD_STRING D19a-Hke-1
29776: PPUSH
29777: CALL_OW 88
// end ;
29781: PPOPN 4
29783: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29784: LD_INT 22
29786: PUSH
29787: LD_INT 3
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 21
29796: PUSH
29797: LD_INT 1
29799: PUSH
29800: EMPTY
29801: LIST
29802: LIST
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PPUSH
29808: CALL_OW 69
29812: PUSH
29813: LD_EXP 21
29817: AND
29818: IFFALSE 29886
29820: GO 29822
29822: DISABLE
29823: LD_INT 0
29825: PPUSH
29826: PPUSH
// begin enable ;
29827: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29828: LD_ADDR_VAR 0 2
29832: PUSH
29833: LD_INT 25
29835: PPUSH
29836: LD_INT 22
29838: PUSH
29839: LD_INT 3
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PPUSH
29846: CALL_OW 70
29850: ST_TO_ADDR
// if not tmp then
29851: LD_VAR 0 2
29855: NOT
29856: IFFALSE 29860
// exit ;
29858: GO 29886
// for i in tmp do
29860: LD_ADDR_VAR 0 1
29864: PUSH
29865: LD_VAR 0 2
29869: PUSH
29870: FOR_IN
29871: IFFALSE 29884
// RemoveUnit ( i ) ;
29873: LD_VAR 0 1
29877: PPUSH
29878: CALL_OW 64
29882: GO 29870
29884: POP
29885: POP
// end ;
29886: PPOPN 2
29888: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29889: LD_INT 22
29891: PUSH
29892: LD_INT 7
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 21
29901: PUSH
29902: LD_INT 1
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PPUSH
29913: CALL_OW 69
29917: PUSH
29918: LD_INT 6
29920: LESS
29921: IFFALSE 30389
29923: GO 29925
29925: DISABLE
29926: LD_INT 0
29928: PPUSH
29929: PPUSH
// begin MC_Kill ( 1 ) ;
29930: LD_INT 1
29932: PPUSH
29933: CALL 34482 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29937: LD_INT 7
29939: PPUSH
29940: LD_INT 1
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: LD_INT 1
29948: PPUSH
29949: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29953: LD_ADDR_VAR 0 1
29957: PUSH
29958: LD_INT 22
29960: PUSH
29961: LD_INT 7
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 26
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PPUSH
29982: CALL_OW 69
29986: PUSH
29987: LD_EXP 73
29991: DIFF
29992: ST_TO_ADDR
// if tmp then
29993: LD_VAR 0 1
29997: IFFALSE 30015
// tmp := tmp [ 1 ] else
29999: LD_ADDR_VAR 0 1
30003: PUSH
30004: LD_VAR 0 1
30008: PUSH
30009: LD_INT 1
30011: ARRAY
30012: ST_TO_ADDR
30013: GO 30051
// begin uc_side := 7 ;
30015: LD_ADDR_OWVAR 20
30019: PUSH
30020: LD_INT 7
30022: ST_TO_ADDR
// uc_nation := 1 ;
30023: LD_ADDR_OWVAR 21
30027: PUSH
30028: LD_INT 1
30030: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30031: LD_INT 1
30033: PPUSH
30034: LD_INT 8
30036: PPUSH
30037: CALL_OW 384
// tmp := CreateHuman ;
30041: LD_ADDR_VAR 0 1
30045: PUSH
30046: CALL_OW 44
30050: ST_TO_ADDR
// end ; DialogueOn ;
30051: CALL_OW 6
// if IsOK ( Roth ) then
30055: LD_EXP 73
30059: PPUSH
30060: CALL_OW 302
30064: IFFALSE 30078
// Say ( JMM , DAb-JMM-1 ) ;
30066: LD_EXP 38
30070: PPUSH
30071: LD_STRING DAb-JMM-1
30073: PPUSH
30074: CALL_OW 88
// if IsOK ( Roth ) then
30078: LD_EXP 73
30082: PPUSH
30083: CALL_OW 302
30087: IFFALSE 30111
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30089: LD_EXP 73
30093: PPUSH
30094: LD_STRING DSurrenderAlliance-Roth-1
30096: PPUSH
30097: CALL_OW 88
// RothCaptured := true ;
30101: LD_ADDR_EXP 33
30105: PUSH
30106: LD_INT 1
30108: ST_TO_ADDR
// end else
30109: GO 30123
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30111: LD_VAR 0 1
30115: PPUSH
30116: LD_STRING DSurrenderAlliance-Sci1-1
30118: PPUSH
30119: CALL_OW 88
// DialogueOff ;
30123: CALL_OW 7
// allianceDestroyed := true ;
30127: LD_ADDR_EXP 23
30131: PUSH
30132: LD_INT 1
30134: ST_TO_ADDR
// if capturedUnit = 0 then
30135: LD_EXP 34
30139: PUSH
30140: LD_INT 0
30142: EQUAL
30143: IFFALSE 30152
// SetAchievement ( ACH_ALLIANCE ) ;
30145: LD_STRING ACH_ALLIANCE
30147: PPUSH
30148: CALL_OW 543
// if trueAmericans then
30152: LD_EXP 35
30156: IFFALSE 30232
// begin if trueAmericans = 1 then
30158: LD_EXP 35
30162: PUSH
30163: LD_INT 1
30165: EQUAL
30166: IFFALSE 30182
// Say ( JMM , DAb-JMM-1a ) else
30168: LD_EXP 38
30172: PPUSH
30173: LD_STRING DAb-JMM-1a
30175: PPUSH
30176: CALL_OW 88
30180: GO 30194
// Say ( JMM , DAb-JMM-1b ) ;
30182: LD_EXP 38
30186: PPUSH
30187: LD_STRING DAb-JMM-1b
30189: PPUSH
30190: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30194: LD_EXP 35
30198: PPUSH
30199: CALL_OW 87
// for i in trueAmericans do
30203: LD_ADDR_VAR 0 2
30207: PUSH
30208: LD_EXP 35
30212: PUSH
30213: FOR_IN
30214: IFFALSE 30230
// SetSide ( i , 1 ) ;
30216: LD_VAR 0 2
30220: PPUSH
30221: LD_INT 1
30223: PPUSH
30224: CALL_OW 235
30228: GO 30213
30230: POP
30231: POP
// end ; repeat wait ( 0 0$1 ) ;
30232: LD_INT 35
30234: PPUSH
30235: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30239: LD_ADDR_VAR 0 2
30243: PUSH
30244: LD_INT 22
30246: PUSH
30247: LD_INT 7
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 21
30256: PUSH
30257: LD_INT 1
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PPUSH
30268: CALL_OW 69
30272: PUSH
30273: FOR_IN
30274: IFFALSE 30356
// begin if IsInUnit ( i ) then
30276: LD_VAR 0 2
30280: PPUSH
30281: CALL_OW 310
30285: IFFALSE 30296
// ComExitBuilding ( i ) ;
30287: LD_VAR 0 2
30291: PPUSH
30292: CALL_OW 122
// if IsDriver ( i ) then
30296: LD_VAR 0 2
30300: PPUSH
30301: CALL 104874 0 1
30305: IFFALSE 30316
// ComExitVehicle ( i ) ;
30307: LD_VAR 0 2
30311: PPUSH
30312: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30316: LD_VAR 0 2
30320: PPUSH
30321: LD_INT 26
30323: PPUSH
30324: CALL_OW 308
30328: NOT
30329: IFFALSE 30345
// AddComMoveToArea ( i , allianceEscapeArea ) else
30331: LD_VAR 0 2
30335: PPUSH
30336: LD_INT 26
30338: PPUSH
30339: CALL_OW 173
30343: GO 30354
// RemoveUnit ( i ) ;
30345: LD_VAR 0 2
30349: PPUSH
30350: CALL_OW 64
// end ;
30354: GO 30273
30356: POP
30357: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30358: LD_INT 22
30360: PUSH
30361: LD_INT 7
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 21
30370: PUSH
30371: LD_INT 1
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PPUSH
30382: CALL_OW 69
30386: NOT
30387: IFFALSE 30232
// end ;
30389: PPOPN 2
30391: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
// if not unit then
30396: LD_VAR 0 1
30400: NOT
30401: IFFALSE 30405
// exit ;
30403: GO 31903
// DoNotAttack ( 7 , unit ) ;
30405: LD_INT 7
30407: PPUSH
30408: LD_VAR 0 1
30412: PPUSH
30413: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30417: LD_VAR 0 1
30421: PPUSH
30422: LD_INT 260
30424: PPUSH
30425: LD_INT 235
30427: PPUSH
30428: LD_INT 3
30430: PPUSH
30431: LD_INT 1
30433: PPUSH
30434: CALL_OW 483
// SetSide ( unit , 4 ) ;
30438: LD_VAR 0 1
30442: PPUSH
30443: LD_INT 4
30445: PPUSH
30446: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30450: LD_ADDR_EXP 34
30454: PUSH
30455: LD_EXP 34
30459: PUSH
30460: LD_INT 1
30462: PLUS
30463: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30464: LD_INT 70
30466: PPUSH
30467: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30471: LD_INT 260
30473: PPUSH
30474: LD_INT 235
30476: PPUSH
30477: LD_INT 1
30479: PPUSH
30480: LD_INT 8
30482: NEG
30483: PPUSH
30484: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30488: LD_VAR 0 1
30492: PPUSH
30493: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30497: LD_VAR 0 1
30501: PPUSH
30502: LD_EXP 73
30506: PPUSH
30507: CALL_OW 119
// DialogueOn ;
30511: CALL_OW 6
// case unit of JMM :
30515: LD_VAR 0 1
30519: PUSH
30520: LD_EXP 38
30524: DOUBLE
30525: EQUAL
30526: IFTRUE 30530
30528: GO 30545
30530: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30531: LD_EXP 38
30535: PPUSH
30536: LD_STRING DA1-JMM-1
30538: PPUSH
30539: CALL_OW 91
30543: GO 30987
30545: LD_EXP 39
30549: DOUBLE
30550: EQUAL
30551: IFTRUE 30555
30553: GO 30570
30555: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30556: LD_EXP 39
30560: PPUSH
30561: LD_STRING DA1-Joan-1
30563: PPUSH
30564: CALL_OW 91
30568: GO 30987
30570: LD_EXP 41
30574: DOUBLE
30575: EQUAL
30576: IFTRUE 30580
30578: GO 30595
30580: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30581: LD_EXP 41
30585: PPUSH
30586: LD_STRING DA1-Lisa-1
30588: PPUSH
30589: CALL_OW 91
30593: GO 30987
30595: LD_EXP 42
30599: DOUBLE
30600: EQUAL
30601: IFTRUE 30605
30603: GO 30620
30605: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30606: LD_EXP 42
30610: PPUSH
30611: LD_STRING DA1-Don-1
30613: PPUSH
30614: CALL_OW 91
30618: GO 30987
30620: LD_EXP 49
30624: DOUBLE
30625: EQUAL
30626: IFTRUE 30630
30628: GO 30645
30630: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30631: LD_EXP 49
30635: PPUSH
30636: LD_STRING DA1-Corn-1
30638: PPUSH
30639: CALL_OW 91
30643: GO 30987
30645: LD_EXP 45
30649: DOUBLE
30650: EQUAL
30651: IFTRUE 30655
30653: GO 30670
30655: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30656: LD_EXP 45
30660: PPUSH
30661: LD_STRING DA1-Den-1
30663: PPUSH
30664: CALL_OW 91
30668: GO 30987
30670: LD_EXP 43
30674: DOUBLE
30675: EQUAL
30676: IFTRUE 30680
30678: GO 30695
30680: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30681: LD_EXP 43
30685: PPUSH
30686: LD_STRING DA1-Bobby-1
30688: PPUSH
30689: CALL_OW 91
30693: GO 30987
30695: LD_EXP 47
30699: DOUBLE
30700: EQUAL
30701: IFTRUE 30705
30703: GO 30720
30705: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30706: LD_EXP 47
30710: PPUSH
30711: LD_STRING DA1-Glad-1
30713: PPUSH
30714: CALL_OW 91
30718: GO 30987
30720: LD_EXP 44
30724: DOUBLE
30725: EQUAL
30726: IFTRUE 30730
30728: GO 30745
30730: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30731: LD_EXP 44
30735: PPUSH
30736: LD_STRING DA1-Cyrus-1
30738: PPUSH
30739: CALL_OW 91
30743: GO 30987
30745: LD_EXP 40
30749: DOUBLE
30750: EQUAL
30751: IFTRUE 30755
30753: GO 30770
30755: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30756: LD_EXP 40
30760: PPUSH
30761: LD_STRING DA1-Huck-1
30763: PPUSH
30764: CALL_OW 91
30768: GO 30987
30770: LD_EXP 54
30774: DOUBLE
30775: EQUAL
30776: IFTRUE 30780
30778: GO 30795
30780: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30781: LD_EXP 54
30785: PPUSH
30786: LD_STRING DA1-Huck-1
30788: PPUSH
30789: CALL_OW 91
30793: GO 30987
30795: LD_EXP 46
30799: DOUBLE
30800: EQUAL
30801: IFTRUE 30805
30803: GO 30820
30805: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30806: LD_EXP 46
30810: PPUSH
30811: LD_STRING DA1-Brown-1
30813: PPUSH
30814: CALL_OW 91
30818: GO 30987
30820: LD_EXP 50
30824: DOUBLE
30825: EQUAL
30826: IFTRUE 30830
30828: GO 30845
30830: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30831: LD_EXP 50
30835: PPUSH
30836: LD_STRING DA1-Gary-1
30838: PPUSH
30839: CALL_OW 91
30843: GO 30987
30845: LD_EXP 53
30849: DOUBLE
30850: EQUAL
30851: IFTRUE 30855
30853: GO 30870
30855: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30856: LD_EXP 53
30860: PPUSH
30861: LD_STRING DA1-Con-1
30863: PPUSH
30864: CALL_OW 91
30868: GO 30987
30870: LD_EXP 59
30874: DOUBLE
30875: EQUAL
30876: IFTRUE 30880
30878: GO 30895
30880: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30881: LD_EXP 59
30885: PPUSH
30886: LD_STRING DA1-Kurt-1
30888: PPUSH
30889: CALL_OW 91
30893: GO 30987
30895: LD_EXP 52
30899: DOUBLE
30900: EQUAL
30901: IFTRUE 30905
30903: GO 30920
30905: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30906: LD_EXP 52
30910: PPUSH
30911: LD_STRING DA1-Yam-1
30913: PPUSH
30914: CALL_OW 91
30918: GO 30987
30920: LD_EXP 51
30924: DOUBLE
30925: EQUAL
30926: IFTRUE 30930
30928: GO 30945
30930: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30931: LD_EXP 51
30935: PPUSH
30936: LD_STRING DA1-Frank-1
30938: PPUSH
30939: CALL_OW 91
30943: GO 30987
30945: POP
// begin if GetSex ( unit ) = sex_male then
30946: LD_VAR 0 1
30950: PPUSH
30951: CALL_OW 258
30955: PUSH
30956: LD_INT 1
30958: EQUAL
30959: IFFALSE 30975
// ForceSay ( unit , DA1-Sol1-1 ) else
30961: LD_VAR 0 1
30965: PPUSH
30966: LD_STRING DA1-Sol1-1
30968: PPUSH
30969: CALL_OW 91
30973: GO 30987
// ForceSay ( unit , DA1-FSol1-1 ) ;
30975: LD_VAR 0 1
30979: PPUSH
30980: LD_STRING DA1-FSol1-1
30982: PPUSH
30983: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30987: LD_EXP 73
30991: PPUSH
30992: LD_STRING DA-Roth-1
30994: PPUSH
30995: CALL_OW 88
// if capturedUnit = 1 then
30999: LD_EXP 34
31003: PUSH
31004: LD_INT 1
31006: EQUAL
31007: IFFALSE 31035
// begin Say ( Simms , DA-Sim-1 ) ;
31009: LD_EXP 74
31013: PPUSH
31014: LD_STRING DA-Sim-1
31016: PPUSH
31017: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31021: LD_EXP 73
31025: PPUSH
31026: LD_STRING DA-Roth-2
31028: PPUSH
31029: CALL_OW 88
// end else
31033: GO 31047
// Say ( Simms , DA-Sim-2 ) ;
31035: LD_EXP 74
31039: PPUSH
31040: LD_STRING DA-Sim-2
31042: PPUSH
31043: CALL_OW 88
// case unit of JMM :
31047: LD_VAR 0 1
31051: PUSH
31052: LD_EXP 38
31056: DOUBLE
31057: EQUAL
31058: IFTRUE 31062
31060: GO 31077
31062: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31063: LD_EXP 38
31067: PPUSH
31068: LD_STRING DA1-JMM-1a
31070: PPUSH
31071: CALL_OW 91
31075: GO 31584
31077: LD_EXP 39
31081: DOUBLE
31082: EQUAL
31083: IFTRUE 31087
31085: GO 31102
31087: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31088: LD_EXP 39
31092: PPUSH
31093: LD_STRING DA1-Joan-1a
31095: PPUSH
31096: CALL_OW 91
31100: GO 31584
31102: LD_EXP 41
31106: DOUBLE
31107: EQUAL
31108: IFTRUE 31112
31110: GO 31127
31112: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31113: LD_EXP 41
31117: PPUSH
31118: LD_STRING DA1-Lisa-1a
31120: PPUSH
31121: CALL_OW 91
31125: GO 31584
31127: LD_EXP 42
31131: DOUBLE
31132: EQUAL
31133: IFTRUE 31137
31135: GO 31152
31137: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31138: LD_EXP 42
31142: PPUSH
31143: LD_STRING DA1-Don-1a
31145: PPUSH
31146: CALL_OW 91
31150: GO 31584
31152: LD_EXP 49
31156: DOUBLE
31157: EQUAL
31158: IFTRUE 31162
31160: GO 31177
31162: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31163: LD_EXP 49
31167: PPUSH
31168: LD_STRING DA1-Corn-1a
31170: PPUSH
31171: CALL_OW 91
31175: GO 31584
31177: LD_EXP 45
31181: DOUBLE
31182: EQUAL
31183: IFTRUE 31187
31185: GO 31202
31187: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31188: LD_EXP 45
31192: PPUSH
31193: LD_STRING DA1-Den-1a
31195: PPUSH
31196: CALL_OW 91
31200: GO 31584
31202: LD_EXP 43
31206: DOUBLE
31207: EQUAL
31208: IFTRUE 31212
31210: GO 31227
31212: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31213: LD_EXP 43
31217: PPUSH
31218: LD_STRING DA1-Bobby-1a
31220: PPUSH
31221: CALL_OW 91
31225: GO 31584
31227: LD_EXP 47
31231: DOUBLE
31232: EQUAL
31233: IFTRUE 31237
31235: GO 31252
31237: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31238: LD_EXP 47
31242: PPUSH
31243: LD_STRING DA1-Glad-1a
31245: PPUSH
31246: CALL_OW 91
31250: GO 31584
31252: LD_EXP 44
31256: DOUBLE
31257: EQUAL
31258: IFTRUE 31262
31260: GO 31277
31262: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31263: LD_EXP 44
31267: PPUSH
31268: LD_STRING DA1-Cyrus-1a
31270: PPUSH
31271: CALL_OW 91
31275: GO 31584
31277: LD_EXP 40
31281: DOUBLE
31282: EQUAL
31283: IFTRUE 31287
31285: GO 31302
31287: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31288: LD_EXP 40
31292: PPUSH
31293: LD_STRING DA1-Huck-1a
31295: PPUSH
31296: CALL_OW 91
31300: GO 31584
31302: LD_EXP 54
31306: DOUBLE
31307: EQUAL
31308: IFTRUE 31312
31310: GO 31327
31312: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31313: LD_EXP 54
31317: PPUSH
31318: LD_STRING DA1-Huck-1a
31320: PPUSH
31321: CALL_OW 91
31325: GO 31584
31327: LD_EXP 46
31331: DOUBLE
31332: EQUAL
31333: IFTRUE 31337
31335: GO 31352
31337: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31338: LD_EXP 46
31342: PPUSH
31343: LD_STRING DA1-Brown-1a
31345: PPUSH
31346: CALL_OW 91
31350: GO 31584
31352: LD_EXP 50
31356: DOUBLE
31357: EQUAL
31358: IFTRUE 31362
31360: GO 31377
31362: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31363: LD_EXP 50
31367: PPUSH
31368: LD_STRING DA1-Gary-1a
31370: PPUSH
31371: CALL_OW 91
31375: GO 31584
31377: LD_EXP 53
31381: DOUBLE
31382: EQUAL
31383: IFTRUE 31387
31385: GO 31402
31387: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31388: LD_EXP 53
31392: PPUSH
31393: LD_STRING DA1-Con-1a
31395: PPUSH
31396: CALL_OW 91
31400: GO 31584
31402: LD_EXP 59
31406: DOUBLE
31407: EQUAL
31408: IFTRUE 31412
31410: GO 31427
31412: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31413: LD_EXP 59
31417: PPUSH
31418: LD_STRING DA1-Kurt-1a
31420: PPUSH
31421: CALL_OW 91
31425: GO 31584
31427: LD_EXP 52
31431: DOUBLE
31432: EQUAL
31433: IFTRUE 31437
31435: GO 31452
31437: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31438: LD_EXP 52
31442: PPUSH
31443: LD_STRING DA1-Yam-1a
31445: PPUSH
31446: CALL_OW 91
31450: GO 31584
31452: LD_EXP 51
31456: DOUBLE
31457: EQUAL
31458: IFTRUE 31462
31460: GO 31477
31462: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31463: LD_EXP 51
31467: PPUSH
31468: LD_STRING DA1-Frank-1a
31470: PPUSH
31471: CALL_OW 91
31475: GO 31584
31477: POP
// begin join := rand ( 0 , 1 ) ;
31478: LD_ADDR_VAR 0 3
31482: PUSH
31483: LD_INT 0
31485: PPUSH
31486: LD_INT 1
31488: PPUSH
31489: CALL_OW 12
31493: ST_TO_ADDR
// if join then
31494: LD_VAR 0 3
31498: IFFALSE 31543
// begin if GetSex ( unit ) = sex_male then
31500: LD_VAR 0 1
31504: PPUSH
31505: CALL_OW 258
31509: PUSH
31510: LD_INT 1
31512: EQUAL
31513: IFFALSE 31529
// ForceSay ( unit , DA1-Sol1-1b ) else
31515: LD_VAR 0 1
31519: PPUSH
31520: LD_STRING DA1-Sol1-1b
31522: PPUSH
31523: CALL_OW 91
31527: GO 31541
// ForceSay ( unit , DA1-FSol1-1b ) ;
31529: LD_VAR 0 1
31533: PPUSH
31534: LD_STRING DA1-FSol1-1b
31536: PPUSH
31537: CALL_OW 91
// end else
31541: GO 31584
// begin if GetSex ( unit ) = sex_male then
31543: LD_VAR 0 1
31547: PPUSH
31548: CALL_OW 258
31552: PUSH
31553: LD_INT 1
31555: EQUAL
31556: IFFALSE 31572
// ForceSay ( unit , DA1-Sol1-1a ) else
31558: LD_VAR 0 1
31562: PPUSH
31563: LD_STRING DA1-Sol1-1a
31565: PPUSH
31566: CALL_OW 91
31570: GO 31584
// ForceSay ( unit , DA1-FSol1-1a ) ;
31572: LD_VAR 0 1
31576: PPUSH
31577: LD_STRING DA1-FSol1-1a
31579: PPUSH
31580: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31584: LD_VAR 0 1
31588: PUSH
31589: LD_EXP 38
31593: EQUAL
31594: IFFALSE 31605
// begin YouLost ( JMMCaptured ) ;
31596: LD_STRING JMMCaptured
31598: PPUSH
31599: CALL_OW 104
// exit ;
31603: GO 31903
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31605: LD_VAR 0 1
31609: PUSH
31610: LD_EXP 42
31614: PUSH
31615: LD_EXP 45
31619: PUSH
31620: LD_EXP 43
31624: PUSH
31625: LD_EXP 40
31629: PUSH
31630: LD_EXP 54
31634: PUSH
31635: LD_EXP 46
31639: PUSH
31640: LD_EXP 52
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: IN
31654: PUSH
31655: LD_VAR 0 3
31659: OR
31660: IFFALSE 31759
// begin Say ( Roth , DA-Roth-3 ) ;
31662: LD_EXP 73
31666: PPUSH
31667: LD_STRING DA-Roth-3
31669: PPUSH
31670: CALL_OW 88
// SetSide ( unit , 7 ) ;
31674: LD_VAR 0 1
31678: PPUSH
31679: LD_INT 7
31681: PPUSH
31682: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31686: LD_ADDR_EXP 101
31690: PUSH
31691: LD_EXP 101
31695: PPUSH
31696: LD_INT 1
31698: PPUSH
31699: LD_EXP 101
31703: PUSH
31704: LD_INT 1
31706: ARRAY
31707: PUSH
31708: LD_VAR 0 1
31712: ADD
31713: PPUSH
31714: CALL_OW 1
31718: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31719: LD_INT 260
31721: PPUSH
31722: LD_INT 235
31724: PPUSH
31725: LD_INT 1
31727: PPUSH
31728: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31732: LD_VAR 0 1
31736: PPUSH
31737: LD_INT 1000
31739: PPUSH
31740: CALL_OW 234
// DialogueOff ;
31744: CALL_OW 7
// ComFree ( unit ) ;
31748: LD_VAR 0 1
31752: PPUSH
31753: CALL_OW 139
// end else
31757: GO 31840
// begin Say ( Roth , DA-Roth-3a ) ;
31759: LD_EXP 73
31763: PPUSH
31764: LD_STRING DA-Roth-3a
31766: PPUSH
31767: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31771: LD_ADDR_EXP 35
31775: PUSH
31776: LD_EXP 35
31780: PUSH
31781: LD_VAR 0 1
31785: ADD
31786: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31787: LD_INT 260
31789: PPUSH
31790: LD_INT 235
31792: PPUSH
31793: LD_INT 1
31795: PPUSH
31796: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31800: LD_VAR 0 1
31804: PPUSH
31805: LD_INT 1000
31807: PPUSH
31808: CALL_OW 234
// DialogueOff ;
31812: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31816: LD_VAR 0 1
31820: PPUSH
31821: LD_INT 272
31823: PPUSH
31824: LD_INT 254
31826: PPUSH
31827: CALL_OW 111
// AddComHold ( unit ) ;
31831: LD_VAR 0 1
31835: PPUSH
31836: CALL_OW 200
// end ; if capturedUnit = 1 then
31840: LD_EXP 34
31844: PUSH
31845: LD_INT 1
31847: EQUAL
31848: IFFALSE 31903
// begin DialogueOn ;
31850: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31854: LD_EXP 38
31858: PPUSH
31859: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31863: LD_EXP 38
31867: PPUSH
31868: LD_STRING DAa-JMM-1
31870: PPUSH
31871: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31875: LD_EXP 38
31879: PPUSH
31880: LD_STRING DAa-JMM-1a
31882: PPUSH
31883: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31887: LD_EXP 38
31891: PPUSH
31892: LD_STRING DAa-JMM-1b
31894: PPUSH
31895: CALL_OW 88
// DialogueOff ;
31899: CALL_OW 7
// end ; end ;
31903: LD_VAR 0 2
31907: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31908: LD_EXP 15
31912: PUSH
31913: LD_INT 13
31915: GREATEREQUAL
31916: PUSH
31917: LD_INT 22
31919: PUSH
31920: LD_INT 2
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 21
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PPUSH
31941: CALL_OW 69
31945: PUSH
31946: LD_INT 0
31948: EQUAL
31949: AND
31950: PUSH
31951: LD_INT 22
31953: PUSH
31954: LD_INT 2
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 21
31963: PUSH
31964: LD_INT 2
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 50
31973: PUSH
31974: EMPTY
31975: LIST
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: LIST
31981: PPUSH
31982: CALL_OW 69
31986: PUSH
31987: LD_INT 0
31989: EQUAL
31990: AND
31991: PUSH
31992: LD_EXP 21
31996: AND
31997: PUSH
31998: LD_EXP 22
32002: AND
32003: PUSH
32004: LD_EXP 23
32008: AND
32009: IFFALSE 32651
32011: GO 32013
32013: DISABLE
32014: LD_INT 0
32016: PPUSH
32017: PPUSH
32018: PPUSH
// begin m1 := false ;
32019: LD_ADDR_VAR 0 1
32023: PUSH
32024: LD_INT 0
32026: ST_TO_ADDR
// m2 := false ;
32027: LD_ADDR_VAR 0 2
32031: PUSH
32032: LD_INT 0
32034: ST_TO_ADDR
// m3 := false ;
32035: LD_ADDR_VAR 0 3
32039: PUSH
32040: LD_INT 0
32042: ST_TO_ADDR
// if not bombExploded then
32043: LD_EXP 37
32047: NOT
32048: IFFALSE 32057
// SetAchievement ( ACH_SIBROCKET ) ;
32050: LD_STRING ACH_SIBROCKET
32052: PPUSH
32053: CALL_OW 543
// if tick <= 120 120$00 then
32057: LD_OWVAR 1
32061: PUSH
32062: LD_INT 252000
32064: LESSEQUAL
32065: IFFALSE 32081
// begin wait ( 3 ) ;
32067: LD_INT 3
32069: PPUSH
32070: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32074: LD_STRING ACH_ASPEED_15
32076: PPUSH
32077: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32081: LD_EXP 38
32085: PPUSH
32086: CALL_OW 87
// music_class := 5 ;
32090: LD_ADDR_OWVAR 72
32094: PUSH
32095: LD_INT 5
32097: ST_TO_ADDR
// music_nat := 5 ;
32098: LD_ADDR_OWVAR 71
32102: PUSH
32103: LD_INT 5
32105: ST_TO_ADDR
// DialogueOn ;
32106: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32110: LD_EXP 38
32114: PPUSH
32115: LD_STRING D20-JMM-1
32117: PPUSH
32118: CALL_OW 88
// if IsOK ( Joan ) then
32122: LD_EXP 39
32126: PPUSH
32127: CALL_OW 302
32131: IFFALSE 32145
// Say ( Joan , D20-Joan-1 ) ;
32133: LD_EXP 39
32137: PPUSH
32138: LD_STRING D20-Joan-1
32140: PPUSH
32141: CALL_OW 88
// if IsOk ( Lisa ) then
32145: LD_EXP 41
32149: PPUSH
32150: CALL_OW 302
32154: IFFALSE 32168
// Say ( Lisa , D20-Lisa-1 ) ;
32156: LD_EXP 41
32160: PPUSH
32161: LD_STRING D20-Lisa-1
32163: PPUSH
32164: CALL_OW 88
// if IsOk ( Donaldson ) then
32168: LD_EXP 42
32172: PPUSH
32173: CALL_OW 302
32177: IFFALSE 32191
// Say ( Donaldson , D20-Don-1 ) ;
32179: LD_EXP 42
32183: PPUSH
32184: LD_STRING D20-Don-1
32186: PPUSH
32187: CALL_OW 88
// if IsOK ( Cornel ) then
32191: LD_EXP 49
32195: PPUSH
32196: CALL_OW 302
32200: IFFALSE 32214
// Say ( Cornel , D20-Corn-1 ) ;
32202: LD_EXP 49
32206: PPUSH
32207: LD_STRING D20-Corn-1
32209: PPUSH
32210: CALL_OW 88
// if IsOk ( Denis ) then
32214: LD_EXP 45
32218: PPUSH
32219: CALL_OW 302
32223: IFFALSE 32237
// Say ( Denis , D20-Den-1 ) ;
32225: LD_EXP 45
32229: PPUSH
32230: LD_STRING D20-Den-1
32232: PPUSH
32233: CALL_OW 88
// if IsOk ( Bobby ) then
32237: LD_EXP 43
32241: PPUSH
32242: CALL_OW 302
32246: IFFALSE 32260
// Say ( Bobby , D20-Bobby-1 ) ;
32248: LD_EXP 43
32252: PPUSH
32253: LD_STRING D20-Bobby-1
32255: PPUSH
32256: CALL_OW 88
// if IsOk ( Gladstone ) then
32260: LD_EXP 47
32264: PPUSH
32265: CALL_OW 302
32269: IFFALSE 32283
// Say ( Gladstone , D20-Glad-1 ) ;
32271: LD_EXP 47
32275: PPUSH
32276: LD_STRING D20-Glad-1
32278: PPUSH
32279: CALL_OW 88
// if IsOk ( Cyrus ) then
32283: LD_EXP 44
32287: PPUSH
32288: CALL_OW 302
32292: IFFALSE 32306
// Say ( Cyrus , D20-Cyrus-1 ) ;
32294: LD_EXP 44
32298: PPUSH
32299: LD_STRING D20-Cyrus-1
32301: PPUSH
32302: CALL_OW 88
// if IsOk ( Stevens ) then
32306: LD_EXP 40
32310: PPUSH
32311: CALL_OW 302
32315: IFFALSE 32329
// Say ( Stevens , D20-Huck-1 ) ;
32317: LD_EXP 40
32321: PPUSH
32322: LD_STRING D20-Huck-1
32324: PPUSH
32325: CALL_OW 88
// if IsOk ( Brown ) then
32329: LD_EXP 46
32333: PPUSH
32334: CALL_OW 302
32338: IFFALSE 32352
// Say ( Brown , D20-Brown-1 ) ;
32340: LD_EXP 46
32344: PPUSH
32345: LD_STRING D20-Brown-1
32347: PPUSH
32348: CALL_OW 88
// if IsOk ( Gary ) then
32352: LD_EXP 50
32356: PPUSH
32357: CALL_OW 302
32361: IFFALSE 32375
// Say ( Gary , D20-Gary-1 ) ;
32363: LD_EXP 50
32367: PPUSH
32368: LD_STRING D20-Gary-1
32370: PPUSH
32371: CALL_OW 88
// if IsOk ( Connie ) then
32375: LD_EXP 53
32379: PPUSH
32380: CALL_OW 302
32384: IFFALSE 32398
// Say ( Connie , D20-Con-1 ) ;
32386: LD_EXP 53
32390: PPUSH
32391: LD_STRING D20-Con-1
32393: PPUSH
32394: CALL_OW 88
// if IsOk ( Kurt ) then
32398: LD_EXP 59
32402: PPUSH
32403: CALL_OW 302
32407: IFFALSE 32421
// Say ( Kurt , D20-Kurt-1 ) ;
32409: LD_EXP 59
32413: PPUSH
32414: LD_STRING D20-Kurt-1
32416: PPUSH
32417: CALL_OW 88
// if IsOk ( Kikuchi ) then
32421: LD_EXP 52
32425: PPUSH
32426: CALL_OW 302
32430: IFFALSE 32444
// Say ( Kikuchi , D20-Yam-1 ) ;
32432: LD_EXP 52
32436: PPUSH
32437: LD_STRING D20-Yam-1
32439: PPUSH
32440: CALL_OW 88
// if IsOk ( Frank ) then
32444: LD_EXP 51
32448: PPUSH
32449: CALL_OW 302
32453: IFFALSE 32467
// Say ( Frank , D20-Frank-1 ) ;
32455: LD_EXP 51
32459: PPUSH
32460: LD_STRING D20-Frank-1
32462: PPUSH
32463: CALL_OW 88
// DialogueOff ;
32467: CALL_OW 7
// if RothCaptured then
32471: LD_EXP 33
32475: IFFALSE 32497
// begin m1 := true ;
32477: LD_ADDR_VAR 0 1
32481: PUSH
32482: LD_INT 1
32484: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32485: LD_STRING Roth
32487: PPUSH
32488: LD_INT 1
32490: PPUSH
32491: CALL_OW 101
// end else
32495: GO 32508
// AddMedal ( Roth , - 1 ) ;
32497: LD_STRING Roth
32499: PPUSH
32500: LD_INT 1
32502: NEG
32503: PPUSH
32504: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32508: LD_EXP 27
32512: IFFALSE 32534
// begin m2 := true ;
32514: LD_ADDR_VAR 0 2
32518: PUSH
32519: LD_INT 1
32521: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32522: LD_STRING Project
32524: PPUSH
32525: LD_INT 1
32527: PPUSH
32528: CALL_OW 101
// end else
32532: GO 32545
// AddMedal ( Project , - 1 ) ;
32534: LD_STRING Project
32536: PPUSH
32537: LD_INT 1
32539: NEG
32540: PPUSH
32541: CALL_OW 101
// if lostCounter = 0 then
32545: LD_EXP 32
32549: PUSH
32550: LD_INT 0
32552: EQUAL
32553: IFFALSE 32575
// begin m3 := true ;
32555: LD_ADDR_VAR 0 3
32559: PUSH
32560: LD_INT 1
32562: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32563: LD_STRING NoLosses
32565: PPUSH
32566: LD_INT 1
32568: PPUSH
32569: CALL_OW 101
// end else
32573: GO 32586
// AddMedal ( NoLosses , - 1 ) ;
32575: LD_STRING NoLosses
32577: PPUSH
32578: LD_INT 1
32580: NEG
32581: PPUSH
32582: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32586: LD_VAR 0 1
32590: PUSH
32591: LD_VAR 0 2
32595: AND
32596: PUSH
32597: LD_VAR 0 3
32601: AND
32602: PUSH
32603: LD_OWVAR 67
32607: PUSH
32608: LD_INT 3
32610: EQUAL
32611: AND
32612: IFFALSE 32624
// SetAchievementEX ( ACH_AMER , 15 ) ;
32614: LD_STRING ACH_AMER
32616: PPUSH
32617: LD_INT 15
32619: PPUSH
32620: CALL_OW 564
// GiveMedals ( MAIN ) ;
32624: LD_STRING MAIN
32626: PPUSH
32627: CALL_OW 102
// music_class := 4 ;
32631: LD_ADDR_OWVAR 72
32635: PUSH
32636: LD_INT 4
32638: ST_TO_ADDR
// music_nat := 1 ;
32639: LD_ADDR_OWVAR 71
32643: PUSH
32644: LD_INT 1
32646: ST_TO_ADDR
// YouWin ;
32647: CALL_OW 103
// end ; end_of_file
32651: PPOPN 3
32653: END
// export function CustomEvent ( event ) ; begin
32654: LD_INT 0
32656: PPUSH
// end ;
32657: LD_VAR 0 2
32661: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32662: LD_VAR 0 1
32666: PUSH
32667: LD_INT 1
32669: EQUAL
32670: PUSH
32671: LD_VAR 0 2
32675: PUSH
32676: LD_INT 4
32678: EQUAL
32679: AND
32680: PUSH
32681: LD_EXP 57
32685: PPUSH
32686: CALL_OW 300
32690: AND
32691: IFFALSE 32707
// begin wait ( 0 0$2 ) ;
32693: LD_INT 70
32695: PPUSH
32696: CALL_OW 67
// YouLost ( Dismissed ) ;
32700: LD_STRING Dismissed
32702: PPUSH
32703: CALL_OW 104
// end ; end ;
32707: PPOPN 2
32709: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32710: LD_VAR 0 2
32714: PPUSH
32715: LD_VAR 0 3
32719: PPUSH
32720: LD_INT 18
32722: PPUSH
32723: CALL_OW 309
32727: IFFALSE 32736
// YouLost ( Motherlode3 ) ;
32729: LD_STRING Motherlode3
32731: PPUSH
32732: CALL_OW 104
// end ;
32736: PPOPN 3
32738: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32739: LD_EXP 27
32743: NOT
32744: IFFALSE 32754
// behemothDone := true ;
32746: LD_ADDR_EXP 28
32750: PUSH
32751: LD_INT 1
32753: ST_TO_ADDR
// end ;
32754: PPOPN 1
32756: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32757: LD_VAR 0 1
32761: PPUSH
32762: CALL_OW 255
32766: PUSH
32767: LD_INT 1
32769: EQUAL
32770: IFFALSE 32780
// bombExploded := true ;
32772: LD_ADDR_EXP 37
32776: PUSH
32777: LD_INT 1
32779: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32780: LD_VAR 0 1
32784: PPUSH
32785: CALL_OW 255
32789: PUSH
32790: LD_INT 1
32792: EQUAL
32793: PUSH
32794: LD_EXP 30
32798: AND
32799: PUSH
32800: LD_INT 22
32802: PUSH
32803: LD_INT 3
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 34
32812: PUSH
32813: LD_INT 48
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PPUSH
32824: CALL_OW 69
32828: AND
32829: PUSH
32830: LD_INT 22
32832: PUSH
32833: LD_INT 1
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 34
32842: PUSH
32843: LD_INT 8
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PPUSH
32854: CALL_OW 69
32858: NOT
32859: AND
32860: IFFALSE 32912
// begin wait ( 0 0$5 ) ;
32862: LD_INT 175
32864: PPUSH
32865: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32869: LD_INT 22
32871: PUSH
32872: LD_INT 3
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 34
32881: PUSH
32882: LD_INT 48
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PPUSH
32893: CALL_OW 69
32897: PUSH
32898: LD_INT 1
32900: ARRAY
32901: PPUSH
32902: LD_INT 60
32904: PPUSH
32905: LD_INT 95
32907: PPUSH
32908: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32912: LD_VAR 0 2
32916: PPUSH
32917: LD_VAR 0 3
32921: PPUSH
32922: LD_INT 18
32924: PPUSH
32925: CALL_OW 309
32929: IFFALSE 32989
// begin if GetSide ( unit ) = 1 then
32931: LD_VAR 0 1
32935: PPUSH
32936: CALL_OW 255
32940: PUSH
32941: LD_INT 1
32943: EQUAL
32944: IFFALSE 32960
// begin wait ( 0 0$6 ) ;
32946: LD_INT 210
32948: PPUSH
32949: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32953: LD_STRING Motherlode2
32955: PPUSH
32956: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32960: LD_VAR 0 1
32964: PPUSH
32965: CALL_OW 255
32969: PUSH
32970: LD_INT 8
32972: EQUAL
32973: IFFALSE 32989
// begin wait ( 0 0$6 ) ;
32975: LD_INT 210
32977: PPUSH
32978: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32982: LD_STRING Motherlode1
32984: PPUSH
32985: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32989: LD_VAR 0 1
32993: PPUSH
32994: CALL_OW 255
32998: PUSH
32999: LD_INT 3
33001: EQUAL
33002: IFFALSE 33023
// begin wait ( 0 0$5 ) ;
33004: LD_INT 175
33006: PPUSH
33007: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33011: LD_EXP 63
33015: PPUSH
33016: LD_STRING D18-Pla-1
33018: PPUSH
33019: CALL_OW 94
// end ; end ;
33023: PPOPN 3
33025: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33026: LD_VAR 0 1
33030: PUSH
33031: LD_EXP 72
33035: IN
33036: IFFALSE 33056
// begin behemothBuilders := behemothBuilders diff un ;
33038: LD_ADDR_EXP 72
33042: PUSH
33043: LD_EXP 72
33047: PUSH
33048: LD_VAR 0 1
33052: DIFF
33053: ST_TO_ADDR
// exit ;
33054: GO 33154
// end ; if un = JMM then
33056: LD_VAR 0 1
33060: PUSH
33061: LD_EXP 38
33065: EQUAL
33066: IFFALSE 33077
// begin YouLost ( JMM ) ;
33068: LD_STRING JMM
33070: PPUSH
33071: CALL_OW 104
// exit ;
33075: GO 33154
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33077: LD_VAR 0 1
33081: PUSH
33082: LD_INT 22
33084: PUSH
33085: LD_INT 1
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 3
33094: PUSH
33095: LD_INT 25
33097: PUSH
33098: LD_INT 16
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 25
33107: PUSH
33108: LD_INT 12
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: LIST
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PPUSH
33124: CALL_OW 69
33128: IN
33129: IFFALSE 33145
// lostCounter := lostCounter + 1 ;
33131: LD_ADDR_EXP 32
33135: PUSH
33136: LD_EXP 32
33140: PUSH
33141: LD_INT 1
33143: PLUS
33144: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33145: LD_VAR 0 1
33149: PPUSH
33150: CALL 61334 0 1
// end ;
33154: PPOPN 1
33156: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33157: LD_VAR 0 1
33161: PPUSH
33162: LD_VAR 0 2
33166: PPUSH
33167: CALL 63668 0 2
// end ;
33171: PPOPN 2
33173: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33174: LD_VAR 0 1
33178: PPUSH
33179: CALL 62736 0 1
// end ;
33183: PPOPN 1
33185: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33186: LD_VAR 0 1
33190: PUSH
33191: LD_INT 22
33193: PUSH
33194: LD_INT 8
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 30
33203: PUSH
33204: LD_INT 2
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 23
33213: PUSH
33214: LD_INT 3
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: LIST
33225: PPUSH
33226: CALL_OW 69
33230: IN
33231: IFFALSE 33258
// begin ComUpgrade ( building ) ;
33233: LD_VAR 0 1
33237: PPUSH
33238: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33242: LD_EXP 60
33246: PPUSH
33247: LD_VAR 0 1
33251: PPUSH
33252: CALL 74374 0 2
// exit ;
33256: GO 33267
// end ; MCE_BuildingComplete ( building ) ;
33258: LD_VAR 0 1
33262: PPUSH
33263: CALL 62977 0 1
// end ;
33267: PPOPN 1
33269: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33270: LD_VAR 0 1
33274: PPUSH
33275: LD_VAR 0 2
33279: PPUSH
33280: CALL 61030 0 2
// end ;
33284: PPOPN 2
33286: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33287: LD_VAR 0 1
33291: PPUSH
33292: LD_VAR 0 2
33296: PPUSH
33297: LD_VAR 0 3
33301: PPUSH
33302: LD_VAR 0 4
33306: PPUSH
33307: LD_VAR 0 5
33311: PPUSH
33312: CALL 60650 0 5
// end ;
33316: PPOPN 5
33318: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33319: LD_VAR 0 1
33323: PPUSH
33324: LD_VAR 0 2
33328: PPUSH
33329: CALL 60246 0 2
// end ;
33333: PPOPN 2
33335: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33336: LD_VAR 0 1
33340: PPUSH
33341: LD_VAR 0 2
33345: PPUSH
33346: LD_VAR 0 3
33350: PPUSH
33351: LD_VAR 0 4
33355: PPUSH
33356: CALL 60084 0 4
// end ;
33360: PPOPN 4
33362: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33363: LD_VAR 0 1
33367: PPUSH
33368: LD_VAR 0 2
33372: PPUSH
33373: LD_VAR 0 3
33377: PPUSH
33378: CALL 59859 0 3
// end ;
33382: PPOPN 3
33384: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33385: LD_VAR 0 1
33389: PPUSH
33390: LD_VAR 0 2
33394: PPUSH
33395: CALL 59744 0 2
// end ;
33399: PPOPN 2
33401: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33402: LD_VAR 0 1
33406: PPUSH
33407: LD_VAR 0 2
33411: PPUSH
33412: CALL 63929 0 2
// end ;
33416: PPOPN 2
33418: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33419: LD_VAR 0 1
33423: PPUSH
33424: CALL_OW 255
33428: PUSH
33429: LD_INT 4
33431: EQUAL
33432: PUSH
33433: LD_VAR 0 1
33437: PUSH
33438: LD_EXP 18
33442: PUSH
33443: LD_INT 1
33445: ARRAY
33446: IN
33447: AND
33448: PUSH
33449: LD_EXP 19
33453: AND
33454: IFFALSE 33473
// begin ComMoveXY ( driver , 61 , 93 ) ;
33456: LD_VAR 0 1
33460: PPUSH
33461: LD_INT 61
33463: PPUSH
33464: LD_INT 93
33466: PPUSH
33467: CALL_OW 111
// exit ;
33471: GO 33497
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 2
33482: PPUSH
33483: LD_VAR 0 3
33487: PPUSH
33488: LD_VAR 0 4
33492: PPUSH
33493: CALL 64145 0 4
// end ;
33497: PPOPN 4
33499: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33500: LD_VAR 0 1
33504: PPUSH
33505: LD_VAR 0 2
33509: PPUSH
33510: CALL 59553 0 2
// end ;
33514: PPOPN 2
33516: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33517: LD_VAR 0 1
33521: PPUSH
33522: CALL 107549 0 1
// end ; end_of_file
33526: PPOPN 1
33528: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33529: LD_EXP 15
33533: PUSH
33534: LD_INT 2
33536: EQUAL
33537: IFFALSE 34016
33539: GO 33541
33541: DISABLE
33542: LD_INT 0
33544: PPUSH
// begin time := 0 0$40 ;
33545: LD_ADDR_VAR 0 1
33549: PUSH
33550: LD_INT 1400
33552: ST_TO_ADDR
// repeat wait ( time ) ;
33553: LD_VAR 0 1
33557: PPUSH
33558: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33562: LD_INT 1
33564: PPUSH
33565: LD_INT 5
33567: PPUSH
33568: CALL_OW 12
33572: PPUSH
33573: LD_INT 106
33575: PPUSH
33576: LD_INT 150
33578: PPUSH
33579: LD_INT 19
33581: PPUSH
33582: LD_INT 1
33584: PPUSH
33585: CALL_OW 56
// time := time + 0 0$9 ;
33589: LD_ADDR_VAR 0 1
33593: PUSH
33594: LD_VAR 0 1
33598: PUSH
33599: LD_INT 315
33601: PLUS
33602: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33603: LD_INT 455
33605: PPUSH
33606: LD_INT 840
33608: PPUSH
33609: CALL_OW 12
33613: PPUSH
33614: CALL_OW 67
// if Prob ( 50 ) then
33618: LD_INT 50
33620: PPUSH
33621: CALL_OW 13
33625: IFFALSE 33654
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33627: LD_INT 1
33629: PPUSH
33630: LD_INT 5
33632: PPUSH
33633: CALL_OW 12
33637: PPUSH
33638: LD_INT 62
33640: PPUSH
33641: LD_INT 108
33643: PPUSH
33644: LD_INT 10
33646: PPUSH
33647: LD_INT 1
33649: PPUSH
33650: CALL_OW 56
// until missionStage > 4 ;
33654: LD_EXP 15
33658: PUSH
33659: LD_INT 4
33661: GREATER
33662: IFFALSE 33553
// repeat wait ( 0 0$1 ) ;
33664: LD_INT 35
33666: PPUSH
33667: CALL_OW 67
// until missionStage = 6 ;
33671: LD_EXP 15
33675: PUSH
33676: LD_INT 6
33678: EQUAL
33679: IFFALSE 33664
// time := 0 0$50 ;
33681: LD_ADDR_VAR 0 1
33685: PUSH
33686: LD_INT 1750
33688: ST_TO_ADDR
// repeat wait ( time ) ;
33689: LD_VAR 0 1
33693: PPUSH
33694: CALL_OW 67
// if Prob ( 50 ) then
33698: LD_INT 50
33700: PPUSH
33701: CALL_OW 13
33705: IFFALSE 33734
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33707: LD_INT 1
33709: PPUSH
33710: LD_INT 5
33712: PPUSH
33713: CALL_OW 12
33717: PPUSH
33718: LD_INT 106
33720: PPUSH
33721: LD_INT 89
33723: PPUSH
33724: LD_INT 45
33726: PPUSH
33727: LD_INT 1
33729: PPUSH
33730: CALL_OW 56
// time := time + 0 0$3 ;
33734: LD_ADDR_VAR 0 1
33738: PUSH
33739: LD_VAR 0 1
33743: PUSH
33744: LD_INT 105
33746: PLUS
33747: ST_TO_ADDR
// if Prob ( 30 ) then
33748: LD_INT 30
33750: PPUSH
33751: CALL_OW 13
33755: IFFALSE 33801
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33757: LD_INT 525
33759: PPUSH
33760: LD_INT 735
33762: PPUSH
33763: CALL_OW 12
33767: PPUSH
33768: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33772: LD_INT 1
33774: PPUSH
33775: LD_INT 5
33777: PPUSH
33778: CALL_OW 12
33782: PPUSH
33783: LD_INT 21
33785: PPUSH
33786: LD_INT 26
33788: PPUSH
33789: LD_INT 12
33791: PPUSH
33792: LD_INT 1
33794: PPUSH
33795: CALL_OW 56
// end else
33799: GO 33837
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33801: LD_INT 700
33803: PPUSH
33804: LD_INT 1225
33806: PPUSH
33807: CALL_OW 12
33811: PPUSH
33812: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33816: LD_INT 1
33818: PPUSH
33819: LD_INT 5
33821: PPUSH
33822: CALL_OW 12
33826: PPUSH
33827: LD_INT 16
33829: PPUSH
33830: LD_INT 1
33832: PPUSH
33833: CALL_OW 55
// end ; if Prob ( 50 ) then
33837: LD_INT 50
33839: PPUSH
33840: CALL_OW 13
33844: IFFALSE 33890
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33846: LD_INT 700
33848: PPUSH
33849: LD_INT 1050
33851: PPUSH
33852: CALL_OW 12
33856: PPUSH
33857: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33861: LD_INT 1
33863: PPUSH
33864: LD_INT 5
33866: PPUSH
33867: CALL_OW 12
33871: PPUSH
33872: LD_INT 181
33874: PPUSH
33875: LD_INT 218
33877: PPUSH
33878: LD_INT 16
33880: PPUSH
33881: LD_INT 1
33883: PPUSH
33884: CALL_OW 56
// end else
33888: GO 33926
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33890: LD_INT 350
33892: PPUSH
33893: LD_INT 525
33895: PPUSH
33896: CALL_OW 12
33900: PPUSH
33901: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33905: LD_INT 1
33907: PPUSH
33908: LD_INT 5
33910: PPUSH
33911: CALL_OW 12
33915: PPUSH
33916: LD_INT 15
33918: PPUSH
33919: LD_INT 1
33921: PPUSH
33922: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33926: LD_INT 45
33928: PUSH
33929: LD_INT 32
33931: PUSH
33932: LD_INT 25
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: LIST
33939: PUSH
33940: LD_OWVAR 67
33944: ARRAY
33945: PPUSH
33946: CALL_OW 13
33950: IFFALSE 33994
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33952: LD_INT 525
33954: PPUSH
33955: LD_INT 875
33957: PPUSH
33958: CALL_OW 12
33962: PPUSH
33963: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33967: LD_INT 1
33969: PPUSH
33970: LD_INT 5
33972: PPUSH
33973: CALL_OW 12
33977: PPUSH
33978: LD_INT 103
33980: PPUSH
33981: LD_INT 140
33983: PPUSH
33984: LD_INT 20
33986: PPUSH
33987: LD_INT 1
33989: PPUSH
33990: CALL_OW 56
// end ; if time > 2 2$20 then
33994: LD_VAR 0 1
33998: PUSH
33999: LD_INT 4900
34001: GREATER
34002: IFFALSE 34012
// time := 0 0$50 ;
34004: LD_ADDR_VAR 0 1
34008: PUSH
34009: LD_INT 1750
34011: ST_TO_ADDR
// until false ;
34012: LD_INT 0
34014: IFFALSE 33689
// end ; end_of_file
34016: PPOPN 1
34018: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34019: LD_EXP 13
34023: PUSH
34024: LD_EXP 15
34028: PUSH
34029: LD_INT 6
34031: GREATEREQUAL
34032: AND
34033: IFFALSE 34070
34035: GO 34037
34037: DISABLE
// begin enable ;
34038: ENABLE
// missionTime := missionTime + 0 0$1 ;
34039: LD_ADDR_EXP 14
34043: PUSH
34044: LD_EXP 14
34048: PUSH
34049: LD_INT 35
34051: PLUS
34052: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34053: LD_ADDR_OWVAR 47
34057: PUSH
34058: LD_STRING #Am15-1
34060: PUSH
34061: LD_EXP 14
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: ST_TO_ADDR
// end ; end_of_file
34070: END
// export function InitNature ; begin
34071: LD_INT 0
34073: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34074: LD_INT 3
34076: PPUSH
34077: LD_INT 3
34079: PPUSH
34080: LD_INT 2
34082: PPUSH
34083: LD_INT 1
34085: PPUSH
34086: LD_INT 1
34088: PPUSH
34089: LD_INT 0
34091: PPUSH
34092: LD_INT 0
34094: PPUSH
34095: LD_INT 20
34097: PPUSH
34098: LD_INT 0
34100: PPUSH
34101: CALL 99192 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34105: LD_INT 2
34107: PPUSH
34108: LD_INT 1
34110: PPUSH
34111: LD_INT 1
34113: PPUSH
34114: LD_INT 1
34116: PPUSH
34117: LD_INT 1
34119: PPUSH
34120: LD_INT 0
34122: PPUSH
34123: LD_INT 0
34125: PPUSH
34126: LD_INT 21
34128: PPUSH
34129: LD_INT 0
34131: PPUSH
34132: CALL 99192 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34136: LD_INT 4
34138: PPUSH
34139: LD_INT 1
34141: PPUSH
34142: LD_INT 2
34144: PPUSH
34145: LD_INT 4
34147: PPUSH
34148: LD_INT 2
34150: PPUSH
34151: LD_INT 1
34153: PPUSH
34154: LD_INT 0
34156: PPUSH
34157: LD_INT 22
34159: PPUSH
34160: LD_INT 0
34162: PPUSH
34163: CALL 99192 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34167: LD_INT 0
34169: PPUSH
34170: LD_INT 0
34172: PPUSH
34173: LD_INT 0
34175: PPUSH
34176: LD_INT 0
34178: PPUSH
34179: LD_INT 0
34181: PPUSH
34182: LD_INT 0
34184: PPUSH
34185: LD_INT 9
34187: PPUSH
34188: LD_INT 0
34190: PPUSH
34191: LD_INT 23
34193: PPUSH
34194: CALL 99192 0 9
// end ; end_of_file
34198: LD_VAR 0 1
34202: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34203: GO 34205
34205: DISABLE
// begin ru_radar := 98 ;
34206: LD_ADDR_EXP 94
34210: PUSH
34211: LD_INT 98
34213: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34214: LD_ADDR_EXP 95
34218: PUSH
34219: LD_INT 89
34221: ST_TO_ADDR
// us_hack := 99 ;
34222: LD_ADDR_EXP 96
34226: PUSH
34227: LD_INT 99
34229: ST_TO_ADDR
// us_artillery := 97 ;
34230: LD_ADDR_EXP 97
34234: PUSH
34235: LD_INT 97
34237: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34238: LD_ADDR_EXP 98
34242: PUSH
34243: LD_INT 91
34245: ST_TO_ADDR
// end ; end_of_file
34246: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34247: LD_INT 0
34249: PPUSH
34250: PPUSH
// skirmish := false ;
34251: LD_ADDR_EXP 99
34255: PUSH
34256: LD_INT 0
34258: ST_TO_ADDR
// debug_mc := false ;
34259: LD_ADDR_EXP 100
34263: PUSH
34264: LD_INT 0
34266: ST_TO_ADDR
// mc_bases := [ ] ;
34267: LD_ADDR_EXP 101
34271: PUSH
34272: EMPTY
34273: ST_TO_ADDR
// mc_sides := [ ] ;
34274: LD_ADDR_EXP 127
34278: PUSH
34279: EMPTY
34280: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34281: LD_ADDR_EXP 102
34285: PUSH
34286: EMPTY
34287: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34288: LD_ADDR_EXP 103
34292: PUSH
34293: EMPTY
34294: ST_TO_ADDR
// mc_need_heal := [ ] ;
34295: LD_ADDR_EXP 104
34299: PUSH
34300: EMPTY
34301: ST_TO_ADDR
// mc_healers := [ ] ;
34302: LD_ADDR_EXP 105
34306: PUSH
34307: EMPTY
34308: ST_TO_ADDR
// mc_build_list := [ ] ;
34309: LD_ADDR_EXP 106
34313: PUSH
34314: EMPTY
34315: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34316: LD_ADDR_EXP 133
34320: PUSH
34321: EMPTY
34322: ST_TO_ADDR
// mc_builders := [ ] ;
34323: LD_ADDR_EXP 107
34327: PUSH
34328: EMPTY
34329: ST_TO_ADDR
// mc_construct_list := [ ] ;
34330: LD_ADDR_EXP 108
34334: PUSH
34335: EMPTY
34336: ST_TO_ADDR
// mc_turret_list := [ ] ;
34337: LD_ADDR_EXP 109
34341: PUSH
34342: EMPTY
34343: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34344: LD_ADDR_EXP 110
34348: PUSH
34349: EMPTY
34350: ST_TO_ADDR
// mc_miners := [ ] ;
34351: LD_ADDR_EXP 115
34355: PUSH
34356: EMPTY
34357: ST_TO_ADDR
// mc_mines := [ ] ;
34358: LD_ADDR_EXP 114
34362: PUSH
34363: EMPTY
34364: ST_TO_ADDR
// mc_minefields := [ ] ;
34365: LD_ADDR_EXP 116
34369: PUSH
34370: EMPTY
34371: ST_TO_ADDR
// mc_crates := [ ] ;
34372: LD_ADDR_EXP 117
34376: PUSH
34377: EMPTY
34378: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34379: LD_ADDR_EXP 118
34383: PUSH
34384: EMPTY
34385: ST_TO_ADDR
// mc_crates_area := [ ] ;
34386: LD_ADDR_EXP 119
34390: PUSH
34391: EMPTY
34392: ST_TO_ADDR
// mc_vehicles := [ ] ;
34393: LD_ADDR_EXP 120
34397: PUSH
34398: EMPTY
34399: ST_TO_ADDR
// mc_attack := [ ] ;
34400: LD_ADDR_EXP 121
34404: PUSH
34405: EMPTY
34406: ST_TO_ADDR
// mc_produce := [ ] ;
34407: LD_ADDR_EXP 122
34411: PUSH
34412: EMPTY
34413: ST_TO_ADDR
// mc_defender := [ ] ;
34414: LD_ADDR_EXP 123
34418: PUSH
34419: EMPTY
34420: ST_TO_ADDR
// mc_parking := [ ] ;
34421: LD_ADDR_EXP 125
34425: PUSH
34426: EMPTY
34427: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34428: LD_ADDR_EXP 111
34432: PUSH
34433: EMPTY
34434: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34435: LD_ADDR_EXP 113
34439: PUSH
34440: EMPTY
34441: ST_TO_ADDR
// mc_scan := [ ] ;
34442: LD_ADDR_EXP 124
34446: PUSH
34447: EMPTY
34448: ST_TO_ADDR
// mc_scan_area := [ ] ;
34449: LD_ADDR_EXP 126
34453: PUSH
34454: EMPTY
34455: ST_TO_ADDR
// mc_tech := [ ] ;
34456: LD_ADDR_EXP 128
34460: PUSH
34461: EMPTY
34462: ST_TO_ADDR
// mc_class := [ ] ;
34463: LD_ADDR_EXP 142
34467: PUSH
34468: EMPTY
34469: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34470: LD_ADDR_EXP 143
34474: PUSH
34475: EMPTY
34476: ST_TO_ADDR
// end ;
34477: LD_VAR 0 1
34481: RET
// export function MC_Kill ( base ) ; begin
34482: LD_INT 0
34484: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34485: LD_ADDR_EXP 101
34489: PUSH
34490: LD_EXP 101
34494: PPUSH
34495: LD_VAR 0 1
34499: PPUSH
34500: EMPTY
34501: PPUSH
34502: CALL_OW 1
34506: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34507: LD_ADDR_EXP 102
34511: PUSH
34512: LD_EXP 102
34516: PPUSH
34517: LD_VAR 0 1
34521: PPUSH
34522: EMPTY
34523: PPUSH
34524: CALL_OW 1
34528: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34529: LD_ADDR_EXP 103
34533: PUSH
34534: LD_EXP 103
34538: PPUSH
34539: LD_VAR 0 1
34543: PPUSH
34544: EMPTY
34545: PPUSH
34546: CALL_OW 1
34550: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34551: LD_ADDR_EXP 104
34555: PUSH
34556: LD_EXP 104
34560: PPUSH
34561: LD_VAR 0 1
34565: PPUSH
34566: EMPTY
34567: PPUSH
34568: CALL_OW 1
34572: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34573: LD_ADDR_EXP 105
34577: PUSH
34578: LD_EXP 105
34582: PPUSH
34583: LD_VAR 0 1
34587: PPUSH
34588: EMPTY
34589: PPUSH
34590: CALL_OW 1
34594: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34595: LD_ADDR_EXP 106
34599: PUSH
34600: LD_EXP 106
34604: PPUSH
34605: LD_VAR 0 1
34609: PPUSH
34610: EMPTY
34611: PPUSH
34612: CALL_OW 1
34616: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34617: LD_ADDR_EXP 107
34621: PUSH
34622: LD_EXP 107
34626: PPUSH
34627: LD_VAR 0 1
34631: PPUSH
34632: EMPTY
34633: PPUSH
34634: CALL_OW 1
34638: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34639: LD_ADDR_EXP 108
34643: PUSH
34644: LD_EXP 108
34648: PPUSH
34649: LD_VAR 0 1
34653: PPUSH
34654: EMPTY
34655: PPUSH
34656: CALL_OW 1
34660: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34661: LD_ADDR_EXP 109
34665: PUSH
34666: LD_EXP 109
34670: PPUSH
34671: LD_VAR 0 1
34675: PPUSH
34676: EMPTY
34677: PPUSH
34678: CALL_OW 1
34682: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34683: LD_ADDR_EXP 110
34687: PUSH
34688: LD_EXP 110
34692: PPUSH
34693: LD_VAR 0 1
34697: PPUSH
34698: EMPTY
34699: PPUSH
34700: CALL_OW 1
34704: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34705: LD_ADDR_EXP 111
34709: PUSH
34710: LD_EXP 111
34714: PPUSH
34715: LD_VAR 0 1
34719: PPUSH
34720: EMPTY
34721: PPUSH
34722: CALL_OW 1
34726: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34727: LD_ADDR_EXP 112
34731: PUSH
34732: LD_EXP 112
34736: PPUSH
34737: LD_VAR 0 1
34741: PPUSH
34742: LD_INT 0
34744: PPUSH
34745: CALL_OW 1
34749: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34750: LD_ADDR_EXP 113
34754: PUSH
34755: LD_EXP 113
34759: PPUSH
34760: LD_VAR 0 1
34764: PPUSH
34765: EMPTY
34766: PPUSH
34767: CALL_OW 1
34771: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34772: LD_ADDR_EXP 114
34776: PUSH
34777: LD_EXP 114
34781: PPUSH
34782: LD_VAR 0 1
34786: PPUSH
34787: EMPTY
34788: PPUSH
34789: CALL_OW 1
34793: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34794: LD_ADDR_EXP 115
34798: PUSH
34799: LD_EXP 115
34803: PPUSH
34804: LD_VAR 0 1
34808: PPUSH
34809: EMPTY
34810: PPUSH
34811: CALL_OW 1
34815: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34816: LD_ADDR_EXP 116
34820: PUSH
34821: LD_EXP 116
34825: PPUSH
34826: LD_VAR 0 1
34830: PPUSH
34831: EMPTY
34832: PPUSH
34833: CALL_OW 1
34837: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34838: LD_ADDR_EXP 117
34842: PUSH
34843: LD_EXP 117
34847: PPUSH
34848: LD_VAR 0 1
34852: PPUSH
34853: EMPTY
34854: PPUSH
34855: CALL_OW 1
34859: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34860: LD_ADDR_EXP 118
34864: PUSH
34865: LD_EXP 118
34869: PPUSH
34870: LD_VAR 0 1
34874: PPUSH
34875: EMPTY
34876: PPUSH
34877: CALL_OW 1
34881: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34882: LD_ADDR_EXP 119
34886: PUSH
34887: LD_EXP 119
34891: PPUSH
34892: LD_VAR 0 1
34896: PPUSH
34897: EMPTY
34898: PPUSH
34899: CALL_OW 1
34903: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34904: LD_ADDR_EXP 120
34908: PUSH
34909: LD_EXP 120
34913: PPUSH
34914: LD_VAR 0 1
34918: PPUSH
34919: EMPTY
34920: PPUSH
34921: CALL_OW 1
34925: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34926: LD_ADDR_EXP 121
34930: PUSH
34931: LD_EXP 121
34935: PPUSH
34936: LD_VAR 0 1
34940: PPUSH
34941: EMPTY
34942: PPUSH
34943: CALL_OW 1
34947: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34948: LD_ADDR_EXP 122
34952: PUSH
34953: LD_EXP 122
34957: PPUSH
34958: LD_VAR 0 1
34962: PPUSH
34963: EMPTY
34964: PPUSH
34965: CALL_OW 1
34969: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34970: LD_ADDR_EXP 123
34974: PUSH
34975: LD_EXP 123
34979: PPUSH
34980: LD_VAR 0 1
34984: PPUSH
34985: EMPTY
34986: PPUSH
34987: CALL_OW 1
34991: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34992: LD_ADDR_EXP 124
34996: PUSH
34997: LD_EXP 124
35001: PPUSH
35002: LD_VAR 0 1
35006: PPUSH
35007: EMPTY
35008: PPUSH
35009: CALL_OW 1
35013: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35014: LD_ADDR_EXP 125
35018: PUSH
35019: LD_EXP 125
35023: PPUSH
35024: LD_VAR 0 1
35028: PPUSH
35029: EMPTY
35030: PPUSH
35031: CALL_OW 1
35035: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35036: LD_ADDR_EXP 126
35040: PUSH
35041: LD_EXP 126
35045: PPUSH
35046: LD_VAR 0 1
35050: PPUSH
35051: EMPTY
35052: PPUSH
35053: CALL_OW 1
35057: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35058: LD_ADDR_EXP 128
35062: PUSH
35063: LD_EXP 128
35067: PPUSH
35068: LD_VAR 0 1
35072: PPUSH
35073: EMPTY
35074: PPUSH
35075: CALL_OW 1
35079: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35080: LD_ADDR_EXP 130
35084: PUSH
35085: LD_EXP 130
35089: PPUSH
35090: LD_VAR 0 1
35094: PPUSH
35095: EMPTY
35096: PPUSH
35097: CALL_OW 1
35101: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35102: LD_ADDR_EXP 131
35106: PUSH
35107: LD_EXP 131
35111: PPUSH
35112: LD_VAR 0 1
35116: PPUSH
35117: EMPTY
35118: PPUSH
35119: CALL_OW 1
35123: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35124: LD_ADDR_EXP 132
35128: PUSH
35129: LD_EXP 132
35133: PPUSH
35134: LD_VAR 0 1
35138: PPUSH
35139: EMPTY
35140: PPUSH
35141: CALL_OW 1
35145: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35146: LD_ADDR_EXP 133
35150: PUSH
35151: LD_EXP 133
35155: PPUSH
35156: LD_VAR 0 1
35160: PPUSH
35161: EMPTY
35162: PPUSH
35163: CALL_OW 1
35167: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35168: LD_ADDR_EXP 134
35172: PUSH
35173: LD_EXP 134
35177: PPUSH
35178: LD_VAR 0 1
35182: PPUSH
35183: EMPTY
35184: PPUSH
35185: CALL_OW 1
35189: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35190: LD_ADDR_EXP 135
35194: PUSH
35195: LD_EXP 135
35199: PPUSH
35200: LD_VAR 0 1
35204: PPUSH
35205: EMPTY
35206: PPUSH
35207: CALL_OW 1
35211: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35212: LD_ADDR_EXP 136
35216: PUSH
35217: LD_EXP 136
35221: PPUSH
35222: LD_VAR 0 1
35226: PPUSH
35227: EMPTY
35228: PPUSH
35229: CALL_OW 1
35233: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35234: LD_ADDR_EXP 137
35238: PUSH
35239: LD_EXP 137
35243: PPUSH
35244: LD_VAR 0 1
35248: PPUSH
35249: EMPTY
35250: PPUSH
35251: CALL_OW 1
35255: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35256: LD_ADDR_EXP 138
35260: PUSH
35261: LD_EXP 138
35265: PPUSH
35266: LD_VAR 0 1
35270: PPUSH
35271: EMPTY
35272: PPUSH
35273: CALL_OW 1
35277: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35278: LD_ADDR_EXP 139
35282: PUSH
35283: LD_EXP 139
35287: PPUSH
35288: LD_VAR 0 1
35292: PPUSH
35293: EMPTY
35294: PPUSH
35295: CALL_OW 1
35299: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35300: LD_ADDR_EXP 140
35304: PUSH
35305: LD_EXP 140
35309: PPUSH
35310: LD_VAR 0 1
35314: PPUSH
35315: EMPTY
35316: PPUSH
35317: CALL_OW 1
35321: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35322: LD_ADDR_EXP 141
35326: PUSH
35327: LD_EXP 141
35331: PPUSH
35332: LD_VAR 0 1
35336: PPUSH
35337: EMPTY
35338: PPUSH
35339: CALL_OW 1
35343: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35344: LD_ADDR_EXP 142
35348: PUSH
35349: LD_EXP 142
35353: PPUSH
35354: LD_VAR 0 1
35358: PPUSH
35359: EMPTY
35360: PPUSH
35361: CALL_OW 1
35365: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35366: LD_ADDR_EXP 143
35370: PUSH
35371: LD_EXP 143
35375: PPUSH
35376: LD_VAR 0 1
35380: PPUSH
35381: LD_INT 0
35383: PPUSH
35384: CALL_OW 1
35388: ST_TO_ADDR
// end ;
35389: LD_VAR 0 2
35393: RET
// export function MC_Add ( side , units ) ; var base ; begin
35394: LD_INT 0
35396: PPUSH
35397: PPUSH
// base := mc_bases + 1 ;
35398: LD_ADDR_VAR 0 4
35402: PUSH
35403: LD_EXP 101
35407: PUSH
35408: LD_INT 1
35410: PLUS
35411: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35412: LD_ADDR_EXP 127
35416: PUSH
35417: LD_EXP 127
35421: PPUSH
35422: LD_VAR 0 4
35426: PPUSH
35427: LD_VAR 0 1
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35437: LD_ADDR_EXP 101
35441: PUSH
35442: LD_EXP 101
35446: PPUSH
35447: LD_VAR 0 4
35451: PPUSH
35452: LD_VAR 0 2
35456: PPUSH
35457: CALL_OW 1
35461: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35462: LD_ADDR_EXP 102
35466: PUSH
35467: LD_EXP 102
35471: PPUSH
35472: LD_VAR 0 4
35476: PPUSH
35477: EMPTY
35478: PPUSH
35479: CALL_OW 1
35483: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35484: LD_ADDR_EXP 103
35488: PUSH
35489: LD_EXP 103
35493: PPUSH
35494: LD_VAR 0 4
35498: PPUSH
35499: EMPTY
35500: PPUSH
35501: CALL_OW 1
35505: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35506: LD_ADDR_EXP 104
35510: PUSH
35511: LD_EXP 104
35515: PPUSH
35516: LD_VAR 0 4
35520: PPUSH
35521: EMPTY
35522: PPUSH
35523: CALL_OW 1
35527: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35528: LD_ADDR_EXP 105
35532: PUSH
35533: LD_EXP 105
35537: PPUSH
35538: LD_VAR 0 4
35542: PPUSH
35543: EMPTY
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35550: LD_ADDR_EXP 106
35554: PUSH
35555: LD_EXP 106
35559: PPUSH
35560: LD_VAR 0 4
35564: PPUSH
35565: EMPTY
35566: PPUSH
35567: CALL_OW 1
35571: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35572: LD_ADDR_EXP 107
35576: PUSH
35577: LD_EXP 107
35581: PPUSH
35582: LD_VAR 0 4
35586: PPUSH
35587: EMPTY
35588: PPUSH
35589: CALL_OW 1
35593: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35594: LD_ADDR_EXP 108
35598: PUSH
35599: LD_EXP 108
35603: PPUSH
35604: LD_VAR 0 4
35608: PPUSH
35609: EMPTY
35610: PPUSH
35611: CALL_OW 1
35615: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35616: LD_ADDR_EXP 109
35620: PUSH
35621: LD_EXP 109
35625: PPUSH
35626: LD_VAR 0 4
35630: PPUSH
35631: EMPTY
35632: PPUSH
35633: CALL_OW 1
35637: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35638: LD_ADDR_EXP 110
35642: PUSH
35643: LD_EXP 110
35647: PPUSH
35648: LD_VAR 0 4
35652: PPUSH
35653: EMPTY
35654: PPUSH
35655: CALL_OW 1
35659: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35660: LD_ADDR_EXP 111
35664: PUSH
35665: LD_EXP 111
35669: PPUSH
35670: LD_VAR 0 4
35674: PPUSH
35675: EMPTY
35676: PPUSH
35677: CALL_OW 1
35681: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35682: LD_ADDR_EXP 112
35686: PUSH
35687: LD_EXP 112
35691: PPUSH
35692: LD_VAR 0 4
35696: PPUSH
35697: LD_INT 0
35699: PPUSH
35700: CALL_OW 1
35704: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35705: LD_ADDR_EXP 113
35709: PUSH
35710: LD_EXP 113
35714: PPUSH
35715: LD_VAR 0 4
35719: PPUSH
35720: EMPTY
35721: PPUSH
35722: CALL_OW 1
35726: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35727: LD_ADDR_EXP 114
35731: PUSH
35732: LD_EXP 114
35736: PPUSH
35737: LD_VAR 0 4
35741: PPUSH
35742: EMPTY
35743: PPUSH
35744: CALL_OW 1
35748: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35749: LD_ADDR_EXP 115
35753: PUSH
35754: LD_EXP 115
35758: PPUSH
35759: LD_VAR 0 4
35763: PPUSH
35764: EMPTY
35765: PPUSH
35766: CALL_OW 1
35770: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35771: LD_ADDR_EXP 116
35775: PUSH
35776: LD_EXP 116
35780: PPUSH
35781: LD_VAR 0 4
35785: PPUSH
35786: EMPTY
35787: PPUSH
35788: CALL_OW 1
35792: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35793: LD_ADDR_EXP 117
35797: PUSH
35798: LD_EXP 117
35802: PPUSH
35803: LD_VAR 0 4
35807: PPUSH
35808: EMPTY
35809: PPUSH
35810: CALL_OW 1
35814: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35815: LD_ADDR_EXP 118
35819: PUSH
35820: LD_EXP 118
35824: PPUSH
35825: LD_VAR 0 4
35829: PPUSH
35830: EMPTY
35831: PPUSH
35832: CALL_OW 1
35836: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35837: LD_ADDR_EXP 119
35841: PUSH
35842: LD_EXP 119
35846: PPUSH
35847: LD_VAR 0 4
35851: PPUSH
35852: EMPTY
35853: PPUSH
35854: CALL_OW 1
35858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35859: LD_ADDR_EXP 120
35863: PUSH
35864: LD_EXP 120
35868: PPUSH
35869: LD_VAR 0 4
35873: PPUSH
35874: EMPTY
35875: PPUSH
35876: CALL_OW 1
35880: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35881: LD_ADDR_EXP 121
35885: PUSH
35886: LD_EXP 121
35890: PPUSH
35891: LD_VAR 0 4
35895: PPUSH
35896: EMPTY
35897: PPUSH
35898: CALL_OW 1
35902: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35903: LD_ADDR_EXP 122
35907: PUSH
35908: LD_EXP 122
35912: PPUSH
35913: LD_VAR 0 4
35917: PPUSH
35918: EMPTY
35919: PPUSH
35920: CALL_OW 1
35924: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35925: LD_ADDR_EXP 123
35929: PUSH
35930: LD_EXP 123
35934: PPUSH
35935: LD_VAR 0 4
35939: PPUSH
35940: EMPTY
35941: PPUSH
35942: CALL_OW 1
35946: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35947: LD_ADDR_EXP 124
35951: PUSH
35952: LD_EXP 124
35956: PPUSH
35957: LD_VAR 0 4
35961: PPUSH
35962: EMPTY
35963: PPUSH
35964: CALL_OW 1
35968: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35969: LD_ADDR_EXP 125
35973: PUSH
35974: LD_EXP 125
35978: PPUSH
35979: LD_VAR 0 4
35983: PPUSH
35984: EMPTY
35985: PPUSH
35986: CALL_OW 1
35990: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35991: LD_ADDR_EXP 126
35995: PUSH
35996: LD_EXP 126
36000: PPUSH
36001: LD_VAR 0 4
36005: PPUSH
36006: EMPTY
36007: PPUSH
36008: CALL_OW 1
36012: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36013: LD_ADDR_EXP 128
36017: PUSH
36018: LD_EXP 128
36022: PPUSH
36023: LD_VAR 0 4
36027: PPUSH
36028: EMPTY
36029: PPUSH
36030: CALL_OW 1
36034: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36035: LD_ADDR_EXP 130
36039: PUSH
36040: LD_EXP 130
36044: PPUSH
36045: LD_VAR 0 4
36049: PPUSH
36050: EMPTY
36051: PPUSH
36052: CALL_OW 1
36056: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36057: LD_ADDR_EXP 131
36061: PUSH
36062: LD_EXP 131
36066: PPUSH
36067: LD_VAR 0 4
36071: PPUSH
36072: EMPTY
36073: PPUSH
36074: CALL_OW 1
36078: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36079: LD_ADDR_EXP 132
36083: PUSH
36084: LD_EXP 132
36088: PPUSH
36089: LD_VAR 0 4
36093: PPUSH
36094: EMPTY
36095: PPUSH
36096: CALL_OW 1
36100: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36101: LD_ADDR_EXP 133
36105: PUSH
36106: LD_EXP 133
36110: PPUSH
36111: LD_VAR 0 4
36115: PPUSH
36116: EMPTY
36117: PPUSH
36118: CALL_OW 1
36122: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36123: LD_ADDR_EXP 134
36127: PUSH
36128: LD_EXP 134
36132: PPUSH
36133: LD_VAR 0 4
36137: PPUSH
36138: EMPTY
36139: PPUSH
36140: CALL_OW 1
36144: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36145: LD_ADDR_EXP 135
36149: PUSH
36150: LD_EXP 135
36154: PPUSH
36155: LD_VAR 0 4
36159: PPUSH
36160: EMPTY
36161: PPUSH
36162: CALL_OW 1
36166: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36167: LD_ADDR_EXP 136
36171: PUSH
36172: LD_EXP 136
36176: PPUSH
36177: LD_VAR 0 4
36181: PPUSH
36182: EMPTY
36183: PPUSH
36184: CALL_OW 1
36188: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36189: LD_ADDR_EXP 137
36193: PUSH
36194: LD_EXP 137
36198: PPUSH
36199: LD_VAR 0 4
36203: PPUSH
36204: EMPTY
36205: PPUSH
36206: CALL_OW 1
36210: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36211: LD_ADDR_EXP 138
36215: PUSH
36216: LD_EXP 138
36220: PPUSH
36221: LD_VAR 0 4
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL_OW 1
36232: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36233: LD_ADDR_EXP 139
36237: PUSH
36238: LD_EXP 139
36242: PPUSH
36243: LD_VAR 0 4
36247: PPUSH
36248: EMPTY
36249: PPUSH
36250: CALL_OW 1
36254: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36255: LD_ADDR_EXP 140
36259: PUSH
36260: LD_EXP 140
36264: PPUSH
36265: LD_VAR 0 4
36269: PPUSH
36270: EMPTY
36271: PPUSH
36272: CALL_OW 1
36276: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36277: LD_ADDR_EXP 141
36281: PUSH
36282: LD_EXP 141
36286: PPUSH
36287: LD_VAR 0 4
36291: PPUSH
36292: EMPTY
36293: PPUSH
36294: CALL_OW 1
36298: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36299: LD_ADDR_EXP 142
36303: PUSH
36304: LD_EXP 142
36308: PPUSH
36309: LD_VAR 0 4
36313: PPUSH
36314: EMPTY
36315: PPUSH
36316: CALL_OW 1
36320: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36321: LD_ADDR_EXP 143
36325: PUSH
36326: LD_EXP 143
36330: PPUSH
36331: LD_VAR 0 4
36335: PPUSH
36336: LD_INT 0
36338: PPUSH
36339: CALL_OW 1
36343: ST_TO_ADDR
// result := base ;
36344: LD_ADDR_VAR 0 3
36348: PUSH
36349: LD_VAR 0 4
36353: ST_TO_ADDR
// end ;
36354: LD_VAR 0 3
36358: RET
// export function MC_Start ( ) ; var i ; begin
36359: LD_INT 0
36361: PPUSH
36362: PPUSH
// for i = 1 to mc_bases do
36363: LD_ADDR_VAR 0 2
36367: PUSH
36368: DOUBLE
36369: LD_INT 1
36371: DEC
36372: ST_TO_ADDR
36373: LD_EXP 101
36377: PUSH
36378: FOR_TO
36379: IFFALSE 37456
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36381: LD_ADDR_EXP 101
36385: PUSH
36386: LD_EXP 101
36390: PPUSH
36391: LD_VAR 0 2
36395: PPUSH
36396: LD_EXP 101
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: PUSH
36407: LD_INT 0
36409: DIFF
36410: PPUSH
36411: CALL_OW 1
36415: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36416: LD_ADDR_EXP 102
36420: PUSH
36421: LD_EXP 102
36425: PPUSH
36426: LD_VAR 0 2
36430: PPUSH
36431: EMPTY
36432: PPUSH
36433: CALL_OW 1
36437: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36438: LD_ADDR_EXP 103
36442: PUSH
36443: LD_EXP 103
36447: PPUSH
36448: LD_VAR 0 2
36452: PPUSH
36453: EMPTY
36454: PPUSH
36455: CALL_OW 1
36459: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36460: LD_ADDR_EXP 104
36464: PUSH
36465: LD_EXP 104
36469: PPUSH
36470: LD_VAR 0 2
36474: PPUSH
36475: EMPTY
36476: PPUSH
36477: CALL_OW 1
36481: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36482: LD_ADDR_EXP 105
36486: PUSH
36487: LD_EXP 105
36491: PPUSH
36492: LD_VAR 0 2
36496: PPUSH
36497: EMPTY
36498: PUSH
36499: EMPTY
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PPUSH
36505: CALL_OW 1
36509: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36510: LD_ADDR_EXP 106
36514: PUSH
36515: LD_EXP 106
36519: PPUSH
36520: LD_VAR 0 2
36524: PPUSH
36525: EMPTY
36526: PPUSH
36527: CALL_OW 1
36531: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36532: LD_ADDR_EXP 133
36536: PUSH
36537: LD_EXP 133
36541: PPUSH
36542: LD_VAR 0 2
36546: PPUSH
36547: EMPTY
36548: PPUSH
36549: CALL_OW 1
36553: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36554: LD_ADDR_EXP 107
36558: PUSH
36559: LD_EXP 107
36563: PPUSH
36564: LD_VAR 0 2
36568: PPUSH
36569: EMPTY
36570: PPUSH
36571: CALL_OW 1
36575: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36576: LD_ADDR_EXP 108
36580: PUSH
36581: LD_EXP 108
36585: PPUSH
36586: LD_VAR 0 2
36590: PPUSH
36591: EMPTY
36592: PPUSH
36593: CALL_OW 1
36597: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36598: LD_ADDR_EXP 109
36602: PUSH
36603: LD_EXP 109
36607: PPUSH
36608: LD_VAR 0 2
36612: PPUSH
36613: LD_EXP 101
36617: PUSH
36618: LD_VAR 0 2
36622: ARRAY
36623: PPUSH
36624: LD_INT 2
36626: PUSH
36627: LD_INT 30
36629: PUSH
36630: LD_INT 32
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 30
36639: PUSH
36640: LD_INT 33
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: LIST
36651: PPUSH
36652: CALL_OW 72
36656: PPUSH
36657: CALL_OW 1
36661: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36662: LD_ADDR_EXP 110
36666: PUSH
36667: LD_EXP 110
36671: PPUSH
36672: LD_VAR 0 2
36676: PPUSH
36677: LD_EXP 101
36681: PUSH
36682: LD_VAR 0 2
36686: ARRAY
36687: PPUSH
36688: LD_INT 2
36690: PUSH
36691: LD_INT 30
36693: PUSH
36694: LD_INT 32
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 30
36703: PUSH
36704: LD_INT 31
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 58
36718: PUSH
36719: EMPTY
36720: LIST
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PPUSH
36726: CALL_OW 72
36730: PPUSH
36731: CALL_OW 1
36735: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36736: LD_ADDR_EXP 111
36740: PUSH
36741: LD_EXP 111
36745: PPUSH
36746: LD_VAR 0 2
36750: PPUSH
36751: EMPTY
36752: PPUSH
36753: CALL_OW 1
36757: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36758: LD_ADDR_EXP 115
36762: PUSH
36763: LD_EXP 115
36767: PPUSH
36768: LD_VAR 0 2
36772: PPUSH
36773: EMPTY
36774: PPUSH
36775: CALL_OW 1
36779: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36780: LD_ADDR_EXP 114
36784: PUSH
36785: LD_EXP 114
36789: PPUSH
36790: LD_VAR 0 2
36794: PPUSH
36795: EMPTY
36796: PPUSH
36797: CALL_OW 1
36801: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36802: LD_ADDR_EXP 116
36806: PUSH
36807: LD_EXP 116
36811: PPUSH
36812: LD_VAR 0 2
36816: PPUSH
36817: EMPTY
36818: PPUSH
36819: CALL_OW 1
36823: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36824: LD_ADDR_EXP 117
36828: PUSH
36829: LD_EXP 117
36833: PPUSH
36834: LD_VAR 0 2
36838: PPUSH
36839: EMPTY
36840: PPUSH
36841: CALL_OW 1
36845: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36846: LD_ADDR_EXP 118
36850: PUSH
36851: LD_EXP 118
36855: PPUSH
36856: LD_VAR 0 2
36860: PPUSH
36861: EMPTY
36862: PPUSH
36863: CALL_OW 1
36867: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36868: LD_ADDR_EXP 119
36872: PUSH
36873: LD_EXP 119
36877: PPUSH
36878: LD_VAR 0 2
36882: PPUSH
36883: EMPTY
36884: PPUSH
36885: CALL_OW 1
36889: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36890: LD_ADDR_EXP 120
36894: PUSH
36895: LD_EXP 120
36899: PPUSH
36900: LD_VAR 0 2
36904: PPUSH
36905: EMPTY
36906: PPUSH
36907: CALL_OW 1
36911: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36912: LD_ADDR_EXP 121
36916: PUSH
36917: LD_EXP 121
36921: PPUSH
36922: LD_VAR 0 2
36926: PPUSH
36927: EMPTY
36928: PPUSH
36929: CALL_OW 1
36933: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36934: LD_ADDR_EXP 122
36938: PUSH
36939: LD_EXP 122
36943: PPUSH
36944: LD_VAR 0 2
36948: PPUSH
36949: EMPTY
36950: PPUSH
36951: CALL_OW 1
36955: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36956: LD_ADDR_EXP 123
36960: PUSH
36961: LD_EXP 123
36965: PPUSH
36966: LD_VAR 0 2
36970: PPUSH
36971: EMPTY
36972: PPUSH
36973: CALL_OW 1
36977: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36978: LD_ADDR_EXP 112
36982: PUSH
36983: LD_EXP 112
36987: PPUSH
36988: LD_VAR 0 2
36992: PPUSH
36993: LD_INT 0
36995: PPUSH
36996: CALL_OW 1
37000: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37001: LD_ADDR_EXP 125
37005: PUSH
37006: LD_EXP 125
37010: PPUSH
37011: LD_VAR 0 2
37015: PPUSH
37016: LD_INT 0
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37024: LD_ADDR_EXP 113
37028: PUSH
37029: LD_EXP 113
37033: PPUSH
37034: LD_VAR 0 2
37038: PPUSH
37039: EMPTY
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37046: LD_ADDR_EXP 124
37050: PUSH
37051: LD_EXP 124
37055: PPUSH
37056: LD_VAR 0 2
37060: PPUSH
37061: LD_INT 0
37063: PPUSH
37064: CALL_OW 1
37068: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37069: LD_ADDR_EXP 126
37073: PUSH
37074: LD_EXP 126
37078: PPUSH
37079: LD_VAR 0 2
37083: PPUSH
37084: EMPTY
37085: PPUSH
37086: CALL_OW 1
37090: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37091: LD_ADDR_EXP 129
37095: PUSH
37096: LD_EXP 129
37100: PPUSH
37101: LD_VAR 0 2
37105: PPUSH
37106: LD_INT 0
37108: PPUSH
37109: CALL_OW 1
37113: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37114: LD_ADDR_EXP 130
37118: PUSH
37119: LD_EXP 130
37123: PPUSH
37124: LD_VAR 0 2
37128: PPUSH
37129: EMPTY
37130: PPUSH
37131: CALL_OW 1
37135: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37136: LD_ADDR_EXP 131
37140: PUSH
37141: LD_EXP 131
37145: PPUSH
37146: LD_VAR 0 2
37150: PPUSH
37151: EMPTY
37152: PPUSH
37153: CALL_OW 1
37157: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37158: LD_ADDR_EXP 132
37162: PUSH
37163: LD_EXP 132
37167: PPUSH
37168: LD_VAR 0 2
37172: PPUSH
37173: EMPTY
37174: PPUSH
37175: CALL_OW 1
37179: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37180: LD_ADDR_EXP 134
37184: PUSH
37185: LD_EXP 134
37189: PPUSH
37190: LD_VAR 0 2
37194: PPUSH
37195: LD_EXP 101
37199: PUSH
37200: LD_VAR 0 2
37204: ARRAY
37205: PPUSH
37206: LD_INT 2
37208: PUSH
37209: LD_INT 30
37211: PUSH
37212: LD_INT 6
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 30
37221: PUSH
37222: LD_INT 7
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 30
37231: PUSH
37232: LD_INT 8
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: PPUSH
37245: CALL_OW 72
37249: PPUSH
37250: CALL_OW 1
37254: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37255: LD_ADDR_EXP 135
37259: PUSH
37260: LD_EXP 135
37264: PPUSH
37265: LD_VAR 0 2
37269: PPUSH
37270: EMPTY
37271: PPUSH
37272: CALL_OW 1
37276: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37277: LD_ADDR_EXP 136
37281: PUSH
37282: LD_EXP 136
37286: PPUSH
37287: LD_VAR 0 2
37291: PPUSH
37292: EMPTY
37293: PPUSH
37294: CALL_OW 1
37298: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37299: LD_ADDR_EXP 137
37303: PUSH
37304: LD_EXP 137
37308: PPUSH
37309: LD_VAR 0 2
37313: PPUSH
37314: EMPTY
37315: PPUSH
37316: CALL_OW 1
37320: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37321: LD_ADDR_EXP 138
37325: PUSH
37326: LD_EXP 138
37330: PPUSH
37331: LD_VAR 0 2
37335: PPUSH
37336: EMPTY
37337: PPUSH
37338: CALL_OW 1
37342: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37343: LD_ADDR_EXP 139
37347: PUSH
37348: LD_EXP 139
37352: PPUSH
37353: LD_VAR 0 2
37357: PPUSH
37358: EMPTY
37359: PPUSH
37360: CALL_OW 1
37364: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37365: LD_ADDR_EXP 140
37369: PUSH
37370: LD_EXP 140
37374: PPUSH
37375: LD_VAR 0 2
37379: PPUSH
37380: EMPTY
37381: PPUSH
37382: CALL_OW 1
37386: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37387: LD_ADDR_EXP 141
37391: PUSH
37392: LD_EXP 141
37396: PPUSH
37397: LD_VAR 0 2
37401: PPUSH
37402: EMPTY
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37409: LD_ADDR_EXP 142
37413: PUSH
37414: LD_EXP 142
37418: PPUSH
37419: LD_VAR 0 2
37423: PPUSH
37424: EMPTY
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37431: LD_ADDR_EXP 143
37435: PUSH
37436: LD_EXP 143
37440: PPUSH
37441: LD_VAR 0 2
37445: PPUSH
37446: LD_INT 0
37448: PPUSH
37449: CALL_OW 1
37453: ST_TO_ADDR
// end ;
37454: GO 36378
37456: POP
37457: POP
// MC_InitSides ( ) ;
37458: CALL 37744 0 0
// MC_InitResearch ( ) ;
37462: CALL 37483 0 0
// CustomInitMacro ( ) ;
37466: CALL 460 0 0
// skirmish := true ;
37470: LD_ADDR_EXP 99
37474: PUSH
37475: LD_INT 1
37477: ST_TO_ADDR
// end ;
37478: LD_VAR 0 1
37482: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37483: LD_INT 0
37485: PPUSH
37486: PPUSH
37487: PPUSH
37488: PPUSH
37489: PPUSH
37490: PPUSH
// if not mc_bases then
37491: LD_EXP 101
37495: NOT
37496: IFFALSE 37500
// exit ;
37498: GO 37739
// for i = 1 to 8 do
37500: LD_ADDR_VAR 0 2
37504: PUSH
37505: DOUBLE
37506: LD_INT 1
37508: DEC
37509: ST_TO_ADDR
37510: LD_INT 8
37512: PUSH
37513: FOR_TO
37514: IFFALSE 37540
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37516: LD_ADDR_EXP 128
37520: PUSH
37521: LD_EXP 128
37525: PPUSH
37526: LD_VAR 0 2
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL_OW 1
37537: ST_TO_ADDR
37538: GO 37513
37540: POP
37541: POP
// tmp := [ ] ;
37542: LD_ADDR_VAR 0 5
37546: PUSH
37547: EMPTY
37548: ST_TO_ADDR
// for i = 1 to mc_sides do
37549: LD_ADDR_VAR 0 2
37553: PUSH
37554: DOUBLE
37555: LD_INT 1
37557: DEC
37558: ST_TO_ADDR
37559: LD_EXP 127
37563: PUSH
37564: FOR_TO
37565: IFFALSE 37623
// if not mc_sides [ i ] in tmp then
37567: LD_EXP 127
37571: PUSH
37572: LD_VAR 0 2
37576: ARRAY
37577: PUSH
37578: LD_VAR 0 5
37582: IN
37583: NOT
37584: IFFALSE 37621
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37586: LD_ADDR_VAR 0 5
37590: PUSH
37591: LD_VAR 0 5
37595: PPUSH
37596: LD_VAR 0 5
37600: PUSH
37601: LD_INT 1
37603: PLUS
37604: PPUSH
37605: LD_EXP 127
37609: PUSH
37610: LD_VAR 0 2
37614: ARRAY
37615: PPUSH
37616: CALL_OW 2
37620: ST_TO_ADDR
37621: GO 37564
37623: POP
37624: POP
// if not tmp then
37625: LD_VAR 0 5
37629: NOT
37630: IFFALSE 37634
// exit ;
37632: GO 37739
// for j in tmp do
37634: LD_ADDR_VAR 0 3
37638: PUSH
37639: LD_VAR 0 5
37643: PUSH
37644: FOR_IN
37645: IFFALSE 37737
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37647: LD_ADDR_VAR 0 6
37651: PUSH
37652: LD_INT 22
37654: PUSH
37655: LD_VAR 0 3
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PPUSH
37664: CALL_OW 69
37668: ST_TO_ADDR
// if not un then
37669: LD_VAR 0 6
37673: NOT
37674: IFFALSE 37678
// continue ;
37676: GO 37644
// nation := GetNation ( un [ 1 ] ) ;
37678: LD_ADDR_VAR 0 4
37682: PUSH
37683: LD_VAR 0 6
37687: PUSH
37688: LD_INT 1
37690: ARRAY
37691: PPUSH
37692: CALL_OW 248
37696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37697: LD_ADDR_EXP 128
37701: PUSH
37702: LD_EXP 128
37706: PPUSH
37707: LD_VAR 0 3
37711: PPUSH
37712: LD_VAR 0 3
37716: PPUSH
37717: LD_VAR 0 4
37721: PPUSH
37722: LD_INT 1
37724: PPUSH
37725: CALL 64349 0 3
37729: PPUSH
37730: CALL_OW 1
37734: ST_TO_ADDR
// end ;
37735: GO 37644
37737: POP
37738: POP
// end ;
37739: LD_VAR 0 1
37743: RET
// export function MC_InitSides ( ) ; var i ; begin
37744: LD_INT 0
37746: PPUSH
37747: PPUSH
// if not mc_bases then
37748: LD_EXP 101
37752: NOT
37753: IFFALSE 37757
// exit ;
37755: GO 37831
// for i = 1 to mc_bases do
37757: LD_ADDR_VAR 0 2
37761: PUSH
37762: DOUBLE
37763: LD_INT 1
37765: DEC
37766: ST_TO_ADDR
37767: LD_EXP 101
37771: PUSH
37772: FOR_TO
37773: IFFALSE 37829
// if mc_bases [ i ] then
37775: LD_EXP 101
37779: PUSH
37780: LD_VAR 0 2
37784: ARRAY
37785: IFFALSE 37827
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37787: LD_ADDR_EXP 127
37791: PUSH
37792: LD_EXP 127
37796: PPUSH
37797: LD_VAR 0 2
37801: PPUSH
37802: LD_EXP 101
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_INT 1
37815: ARRAY
37816: PPUSH
37817: CALL_OW 255
37821: PPUSH
37822: CALL_OW 1
37826: ST_TO_ADDR
37827: GO 37772
37829: POP
37830: POP
// end ;
37831: LD_VAR 0 1
37835: RET
// every 0 0$01 trigger skirmish do
37836: LD_EXP 99
37840: IFFALSE 37994
37842: GO 37844
37844: DISABLE
// begin enable ;
37845: ENABLE
// MC_CheckBuildings ( ) ;
37846: CALL 42492 0 0
// MC_CheckPeopleLife ( ) ;
37850: CALL 42617 0 0
// RaiseSailEvent ( 100 ) ;
37854: LD_INT 100
37856: PPUSH
37857: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37861: LD_INT 103
37863: PPUSH
37864: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37868: LD_INT 104
37870: PPUSH
37871: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37875: LD_INT 105
37877: PPUSH
37878: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37882: LD_INT 106
37884: PPUSH
37885: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37889: LD_INT 107
37891: PPUSH
37892: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37896: LD_INT 108
37898: PPUSH
37899: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37903: LD_INT 109
37905: PPUSH
37906: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37910: LD_INT 110
37912: PPUSH
37913: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37917: LD_INT 111
37919: PPUSH
37920: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37924: LD_INT 112
37926: PPUSH
37927: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37931: LD_INT 113
37933: PPUSH
37934: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37938: LD_INT 120
37940: PPUSH
37941: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37945: LD_INT 121
37947: PPUSH
37948: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37952: LD_INT 122
37954: PPUSH
37955: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37959: LD_INT 123
37961: PPUSH
37962: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37966: LD_INT 124
37968: PPUSH
37969: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37973: LD_INT 125
37975: PPUSH
37976: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37980: LD_INT 126
37982: PPUSH
37983: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37987: LD_INT 200
37989: PPUSH
37990: CALL_OW 427
// end ;
37994: END
// on SailEvent ( event ) do begin if event < 100 then
37995: LD_VAR 0 1
37999: PUSH
38000: LD_INT 100
38002: LESS
38003: IFFALSE 38014
// CustomEvent ( event ) ;
38005: LD_VAR 0 1
38009: PPUSH
38010: CALL 32654 0 1
// if event = 100 then
38014: LD_VAR 0 1
38018: PUSH
38019: LD_INT 100
38021: EQUAL
38022: IFFALSE 38028
// MC_ClassManager ( ) ;
38024: CALL 38420 0 0
// if event = 101 then
38028: LD_VAR 0 1
38032: PUSH
38033: LD_INT 101
38035: EQUAL
38036: IFFALSE 38042
// MC_RepairBuildings ( ) ;
38038: CALL 43213 0 0
// if event = 102 then
38042: LD_VAR 0 1
38046: PUSH
38047: LD_INT 102
38049: EQUAL
38050: IFFALSE 38056
// MC_Heal ( ) ;
38052: CALL 44077 0 0
// if event = 103 then
38056: LD_VAR 0 1
38060: PUSH
38061: LD_INT 103
38063: EQUAL
38064: IFFALSE 38070
// MC_Build ( ) ;
38066: CALL 44499 0 0
// if event = 104 then
38070: LD_VAR 0 1
38074: PUSH
38075: LD_INT 104
38077: EQUAL
38078: IFFALSE 38084
// MC_TurretWeapon ( ) ;
38080: CALL 46112 0 0
// if event = 105 then
38084: LD_VAR 0 1
38088: PUSH
38089: LD_INT 105
38091: EQUAL
38092: IFFALSE 38098
// MC_BuildUpgrade ( ) ;
38094: CALL 45663 0 0
// if event = 106 then
38098: LD_VAR 0 1
38102: PUSH
38103: LD_INT 106
38105: EQUAL
38106: IFFALSE 38112
// MC_PlantMines ( ) ;
38108: CALL 46542 0 0
// if event = 107 then
38112: LD_VAR 0 1
38116: PUSH
38117: LD_INT 107
38119: EQUAL
38120: IFFALSE 38126
// MC_CollectCrates ( ) ;
38122: CALL 47340 0 0
// if event = 108 then
38126: LD_VAR 0 1
38130: PUSH
38131: LD_INT 108
38133: EQUAL
38134: IFFALSE 38140
// MC_LinkRemoteControl ( ) ;
38136: CALL 49116 0 0
// if event = 109 then
38140: LD_VAR 0 1
38144: PUSH
38145: LD_INT 109
38147: EQUAL
38148: IFFALSE 38154
// MC_ProduceVehicle ( ) ;
38150: CALL 49297 0 0
// if event = 110 then
38154: LD_VAR 0 1
38158: PUSH
38159: LD_INT 110
38161: EQUAL
38162: IFFALSE 38168
// MC_SendAttack ( ) ;
38164: CALL 49763 0 0
// if event = 111 then
38168: LD_VAR 0 1
38172: PUSH
38173: LD_INT 111
38175: EQUAL
38176: IFFALSE 38182
// MC_Defend ( ) ;
38178: CALL 49871 0 0
// if event = 112 then
38182: LD_VAR 0 1
38186: PUSH
38187: LD_INT 112
38189: EQUAL
38190: IFFALSE 38196
// MC_Research ( ) ;
38192: CALL 50476 0 0
// if event = 113 then
38196: LD_VAR 0 1
38200: PUSH
38201: LD_INT 113
38203: EQUAL
38204: IFFALSE 38210
// MC_MinesTrigger ( ) ;
38206: CALL 51590 0 0
// if event = 120 then
38210: LD_VAR 0 1
38214: PUSH
38215: LD_INT 120
38217: EQUAL
38218: IFFALSE 38224
// MC_RepairVehicle ( ) ;
38220: CALL 51689 0 0
// if event = 121 then
38224: LD_VAR 0 1
38228: PUSH
38229: LD_INT 121
38231: EQUAL
38232: IFFALSE 38238
// MC_TameApe ( ) ;
38234: CALL 52419 0 0
// if event = 122 then
38238: LD_VAR 0 1
38242: PUSH
38243: LD_INT 122
38245: EQUAL
38246: IFFALSE 38252
// MC_ChangeApeClass ( ) ;
38248: CALL 53248 0 0
// if event = 123 then
38252: LD_VAR 0 1
38256: PUSH
38257: LD_INT 123
38259: EQUAL
38260: IFFALSE 38266
// MC_Bazooka ( ) ;
38262: CALL 53898 0 0
// if event = 124 then
38266: LD_VAR 0 1
38270: PUSH
38271: LD_INT 124
38273: EQUAL
38274: IFFALSE 38280
// MC_TeleportExit ( ) ;
38276: CALL 54096 0 0
// if event = 125 then
38280: LD_VAR 0 1
38284: PUSH
38285: LD_INT 125
38287: EQUAL
38288: IFFALSE 38294
// MC_Deposits ( ) ;
38290: CALL 54743 0 0
// if event = 126 then
38294: LD_VAR 0 1
38298: PUSH
38299: LD_INT 126
38301: EQUAL
38302: IFFALSE 38308
// MC_RemoteDriver ( ) ;
38304: CALL 55368 0 0
// if event = 200 then
38308: LD_VAR 0 1
38312: PUSH
38313: LD_INT 200
38315: EQUAL
38316: IFFALSE 38322
// MC_Idle ( ) ;
38318: CALL 57317 0 0
// end ;
38322: PPOPN 1
38324: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38325: LD_INT 0
38327: PPUSH
38328: PPUSH
// if not mc_bases [ base ] or not tag then
38329: LD_EXP 101
38333: PUSH
38334: LD_VAR 0 1
38338: ARRAY
38339: NOT
38340: PUSH
38341: LD_VAR 0 2
38345: NOT
38346: OR
38347: IFFALSE 38351
// exit ;
38349: GO 38415
// for i in mc_bases [ base ] union mc_ape [ base ] do
38351: LD_ADDR_VAR 0 4
38355: PUSH
38356: LD_EXP 101
38360: PUSH
38361: LD_VAR 0 1
38365: ARRAY
38366: PUSH
38367: LD_EXP 130
38371: PUSH
38372: LD_VAR 0 1
38376: ARRAY
38377: UNION
38378: PUSH
38379: FOR_IN
38380: IFFALSE 38413
// if GetTag ( i ) = tag then
38382: LD_VAR 0 4
38386: PPUSH
38387: CALL_OW 110
38391: PUSH
38392: LD_VAR 0 2
38396: EQUAL
38397: IFFALSE 38411
// SetTag ( i , 0 ) ;
38399: LD_VAR 0 4
38403: PPUSH
38404: LD_INT 0
38406: PPUSH
38407: CALL_OW 109
38411: GO 38379
38413: POP
38414: POP
// end ;
38415: LD_VAR 0 3
38419: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38420: LD_INT 0
38422: PPUSH
38423: PPUSH
38424: PPUSH
38425: PPUSH
38426: PPUSH
38427: PPUSH
38428: PPUSH
38429: PPUSH
// if not mc_bases then
38430: LD_EXP 101
38434: NOT
38435: IFFALSE 38439
// exit ;
38437: GO 38897
// for i = 1 to mc_bases do
38439: LD_ADDR_VAR 0 2
38443: PUSH
38444: DOUBLE
38445: LD_INT 1
38447: DEC
38448: ST_TO_ADDR
38449: LD_EXP 101
38453: PUSH
38454: FOR_TO
38455: IFFALSE 38895
// begin tmp := MC_ClassCheckReq ( i ) ;
38457: LD_ADDR_VAR 0 4
38461: PUSH
38462: LD_VAR 0 2
38466: PPUSH
38467: CALL 38902 0 1
38471: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38472: LD_ADDR_EXP 142
38476: PUSH
38477: LD_EXP 142
38481: PPUSH
38482: LD_VAR 0 2
38486: PPUSH
38487: LD_VAR 0 4
38491: PPUSH
38492: CALL_OW 1
38496: ST_TO_ADDR
// if not tmp then
38497: LD_VAR 0 4
38501: NOT
38502: IFFALSE 38506
// continue ;
38504: GO 38454
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38506: LD_ADDR_VAR 0 6
38510: PUSH
38511: LD_EXP 101
38515: PUSH
38516: LD_VAR 0 2
38520: ARRAY
38521: PPUSH
38522: LD_INT 2
38524: PUSH
38525: LD_INT 30
38527: PUSH
38528: LD_INT 4
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 30
38537: PUSH
38538: LD_INT 5
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: LIST
38549: PPUSH
38550: CALL_OW 72
38554: PUSH
38555: LD_EXP 101
38559: PUSH
38560: LD_VAR 0 2
38564: ARRAY
38565: PPUSH
38566: LD_INT 2
38568: PUSH
38569: LD_INT 30
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 30
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: LIST
38593: PPUSH
38594: CALL_OW 72
38598: PUSH
38599: LD_EXP 101
38603: PUSH
38604: LD_VAR 0 2
38608: ARRAY
38609: PPUSH
38610: LD_INT 30
38612: PUSH
38613: LD_INT 3
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PPUSH
38620: CALL_OW 72
38624: PUSH
38625: LD_EXP 101
38629: PUSH
38630: LD_VAR 0 2
38634: ARRAY
38635: PPUSH
38636: LD_INT 2
38638: PUSH
38639: LD_INT 30
38641: PUSH
38642: LD_INT 6
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 30
38651: PUSH
38652: LD_INT 7
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 30
38661: PUSH
38662: LD_INT 8
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: PPUSH
38675: CALL_OW 72
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: ST_TO_ADDR
// for j = 1 to 4 do
38686: LD_ADDR_VAR 0 3
38690: PUSH
38691: DOUBLE
38692: LD_INT 1
38694: DEC
38695: ST_TO_ADDR
38696: LD_INT 4
38698: PUSH
38699: FOR_TO
38700: IFFALSE 38891
// begin if not tmp [ j ] then
38702: LD_VAR 0 4
38706: PUSH
38707: LD_VAR 0 3
38711: ARRAY
38712: NOT
38713: IFFALSE 38717
// continue ;
38715: GO 38699
// for p in tmp [ j ] do
38717: LD_ADDR_VAR 0 5
38721: PUSH
38722: LD_VAR 0 4
38726: PUSH
38727: LD_VAR 0 3
38731: ARRAY
38732: PUSH
38733: FOR_IN
38734: IFFALSE 38887
// begin if not b [ j ] then
38736: LD_VAR 0 6
38740: PUSH
38741: LD_VAR 0 3
38745: ARRAY
38746: NOT
38747: IFFALSE 38751
// break ;
38749: GO 38887
// e := 0 ;
38751: LD_ADDR_VAR 0 7
38755: PUSH
38756: LD_INT 0
38758: ST_TO_ADDR
// for k in b [ j ] do
38759: LD_ADDR_VAR 0 8
38763: PUSH
38764: LD_VAR 0 6
38768: PUSH
38769: LD_VAR 0 3
38773: ARRAY
38774: PUSH
38775: FOR_IN
38776: IFFALSE 38803
// if IsNotFull ( k ) then
38778: LD_VAR 0 8
38782: PPUSH
38783: CALL 68789 0 1
38787: IFFALSE 38801
// begin e := k ;
38789: LD_ADDR_VAR 0 7
38793: PUSH
38794: LD_VAR 0 8
38798: ST_TO_ADDR
// break ;
38799: GO 38803
// end ;
38801: GO 38775
38803: POP
38804: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38805: LD_VAR 0 7
38809: PUSH
38810: LD_VAR 0 5
38814: PPUSH
38815: LD_VAR 0 7
38819: PPUSH
38820: CALL 105911 0 2
38824: NOT
38825: AND
38826: IFFALSE 38885
// begin if IsInUnit ( p ) then
38828: LD_VAR 0 5
38832: PPUSH
38833: CALL_OW 310
38837: IFFALSE 38848
// ComExitBuilding ( p ) ;
38839: LD_VAR 0 5
38843: PPUSH
38844: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38848: LD_VAR 0 5
38852: PPUSH
38853: LD_VAR 0 7
38857: PPUSH
38858: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38862: LD_VAR 0 5
38866: PPUSH
38867: LD_VAR 0 3
38871: PPUSH
38872: CALL_OW 183
// AddComExitBuilding ( p ) ;
38876: LD_VAR 0 5
38880: PPUSH
38881: CALL_OW 182
// end ; end ;
38885: GO 38733
38887: POP
38888: POP
// end ;
38889: GO 38699
38891: POP
38892: POP
// end ;
38893: GO 38454
38895: POP
38896: POP
// end ;
38897: LD_VAR 0 1
38901: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38902: LD_INT 0
38904: PPUSH
38905: PPUSH
38906: PPUSH
38907: PPUSH
38908: PPUSH
38909: PPUSH
38910: PPUSH
38911: PPUSH
38912: PPUSH
38913: PPUSH
38914: PPUSH
38915: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38916: LD_VAR 0 1
38920: NOT
38921: PUSH
38922: LD_EXP 101
38926: PUSH
38927: LD_VAR 0 1
38931: ARRAY
38932: NOT
38933: OR
38934: PUSH
38935: LD_EXP 101
38939: PUSH
38940: LD_VAR 0 1
38944: ARRAY
38945: PPUSH
38946: LD_INT 2
38948: PUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 30
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: LIST
38973: PPUSH
38974: CALL_OW 72
38978: NOT
38979: OR
38980: IFFALSE 38984
// exit ;
38982: GO 42487
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38984: LD_ADDR_VAR 0 4
38988: PUSH
38989: LD_EXP 101
38993: PUSH
38994: LD_VAR 0 1
38998: ARRAY
38999: PPUSH
39000: LD_INT 2
39002: PUSH
39003: LD_INT 25
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 25
39015: PUSH
39016: LD_INT 2
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 25
39025: PUSH
39026: LD_INT 3
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 25
39035: PUSH
39036: LD_INT 4
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 25
39045: PUSH
39046: LD_INT 5
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: LD_INT 25
39055: PUSH
39056: LD_INT 8
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 25
39065: PUSH
39066: LD_INT 9
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: PPUSH
39083: CALL_OW 72
39087: ST_TO_ADDR
// if not tmp then
39088: LD_VAR 0 4
39092: NOT
39093: IFFALSE 39097
// exit ;
39095: GO 42487
// for i in tmp do
39097: LD_ADDR_VAR 0 3
39101: PUSH
39102: LD_VAR 0 4
39106: PUSH
39107: FOR_IN
39108: IFFALSE 39139
// if GetTag ( i ) then
39110: LD_VAR 0 3
39114: PPUSH
39115: CALL_OW 110
39119: IFFALSE 39137
// tmp := tmp diff i ;
39121: LD_ADDR_VAR 0 4
39125: PUSH
39126: LD_VAR 0 4
39130: PUSH
39131: LD_VAR 0 3
39135: DIFF
39136: ST_TO_ADDR
39137: GO 39107
39139: POP
39140: POP
// if not tmp then
39141: LD_VAR 0 4
39145: NOT
39146: IFFALSE 39150
// exit ;
39148: GO 42487
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39150: LD_ADDR_VAR 0 5
39154: PUSH
39155: LD_EXP 101
39159: PUSH
39160: LD_VAR 0 1
39164: ARRAY
39165: PPUSH
39166: LD_INT 2
39168: PUSH
39169: LD_INT 25
39171: PUSH
39172: LD_INT 1
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 25
39181: PUSH
39182: LD_INT 5
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 25
39191: PUSH
39192: LD_INT 8
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 25
39201: PUSH
39202: LD_INT 9
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: LIST
39213: LIST
39214: LIST
39215: PPUSH
39216: CALL_OW 72
39220: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39221: LD_ADDR_VAR 0 6
39225: PUSH
39226: LD_EXP 101
39230: PUSH
39231: LD_VAR 0 1
39235: ARRAY
39236: PPUSH
39237: LD_INT 25
39239: PUSH
39240: LD_INT 2
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PPUSH
39247: CALL_OW 72
39251: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39252: LD_ADDR_VAR 0 7
39256: PUSH
39257: LD_EXP 101
39261: PUSH
39262: LD_VAR 0 1
39266: ARRAY
39267: PPUSH
39268: LD_INT 25
39270: PUSH
39271: LD_INT 3
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PPUSH
39278: CALL_OW 72
39282: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39283: LD_ADDR_VAR 0 8
39287: PUSH
39288: LD_EXP 101
39292: PUSH
39293: LD_VAR 0 1
39297: ARRAY
39298: PPUSH
39299: LD_INT 25
39301: PUSH
39302: LD_INT 4
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 24
39311: PUSH
39312: LD_INT 251
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PPUSH
39323: CALL_OW 72
39327: ST_TO_ADDR
// if mc_scan [ base ] then
39328: LD_EXP 124
39332: PUSH
39333: LD_VAR 0 1
39337: ARRAY
39338: IFFALSE 39799
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39340: LD_ADDR_EXP 143
39344: PUSH
39345: LD_EXP 143
39349: PPUSH
39350: LD_VAR 0 1
39354: PPUSH
39355: LD_INT 4
39357: PPUSH
39358: CALL_OW 1
39362: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39363: LD_ADDR_VAR 0 12
39367: PUSH
39368: LD_EXP 101
39372: PUSH
39373: LD_VAR 0 1
39377: ARRAY
39378: PPUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 30
39384: PUSH
39385: LD_INT 4
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 30
39394: PUSH
39395: LD_INT 5
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: LIST
39406: PPUSH
39407: CALL_OW 72
39411: ST_TO_ADDR
// if not b then
39412: LD_VAR 0 12
39416: NOT
39417: IFFALSE 39421
// exit ;
39419: GO 42487
// p := [ ] ;
39421: LD_ADDR_VAR 0 11
39425: PUSH
39426: EMPTY
39427: ST_TO_ADDR
// if sci >= 2 then
39428: LD_VAR 0 8
39432: PUSH
39433: LD_INT 2
39435: GREATEREQUAL
39436: IFFALSE 39467
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39438: LD_ADDR_VAR 0 8
39442: PUSH
39443: LD_VAR 0 8
39447: PUSH
39448: LD_INT 1
39450: ARRAY
39451: PUSH
39452: LD_VAR 0 8
39456: PUSH
39457: LD_INT 2
39459: ARRAY
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: ST_TO_ADDR
39465: GO 39528
// if sci = 1 then
39467: LD_VAR 0 8
39471: PUSH
39472: LD_INT 1
39474: EQUAL
39475: IFFALSE 39496
// sci := [ sci [ 1 ] ] else
39477: LD_ADDR_VAR 0 8
39481: PUSH
39482: LD_VAR 0 8
39486: PUSH
39487: LD_INT 1
39489: ARRAY
39490: PUSH
39491: EMPTY
39492: LIST
39493: ST_TO_ADDR
39494: GO 39528
// if sci = 0 then
39496: LD_VAR 0 8
39500: PUSH
39501: LD_INT 0
39503: EQUAL
39504: IFFALSE 39528
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39506: LD_ADDR_VAR 0 11
39510: PUSH
39511: LD_VAR 0 4
39515: PPUSH
39516: LD_INT 4
39518: PPUSH
39519: CALL 105774 0 2
39523: PUSH
39524: LD_INT 1
39526: ARRAY
39527: ST_TO_ADDR
// if eng > 4 then
39528: LD_VAR 0 6
39532: PUSH
39533: LD_INT 4
39535: GREATER
39536: IFFALSE 39582
// for i = eng downto 4 do
39538: LD_ADDR_VAR 0 3
39542: PUSH
39543: DOUBLE
39544: LD_VAR 0 6
39548: INC
39549: ST_TO_ADDR
39550: LD_INT 4
39552: PUSH
39553: FOR_DOWNTO
39554: IFFALSE 39580
// eng := eng diff eng [ i ] ;
39556: LD_ADDR_VAR 0 6
39560: PUSH
39561: LD_VAR 0 6
39565: PUSH
39566: LD_VAR 0 6
39570: PUSH
39571: LD_VAR 0 3
39575: ARRAY
39576: DIFF
39577: ST_TO_ADDR
39578: GO 39553
39580: POP
39581: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39582: LD_ADDR_VAR 0 4
39586: PUSH
39587: LD_VAR 0 4
39591: PUSH
39592: LD_VAR 0 5
39596: PUSH
39597: LD_VAR 0 6
39601: UNION
39602: PUSH
39603: LD_VAR 0 7
39607: UNION
39608: PUSH
39609: LD_VAR 0 8
39613: UNION
39614: DIFF
39615: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39616: LD_ADDR_VAR 0 13
39620: PUSH
39621: LD_EXP 101
39625: PUSH
39626: LD_VAR 0 1
39630: ARRAY
39631: PPUSH
39632: LD_INT 2
39634: PUSH
39635: LD_INT 30
39637: PUSH
39638: LD_INT 32
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 30
39647: PUSH
39648: LD_INT 31
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: LIST
39659: PPUSH
39660: CALL_OW 72
39664: PUSH
39665: LD_EXP 101
39669: PUSH
39670: LD_VAR 0 1
39674: ARRAY
39675: PPUSH
39676: LD_INT 2
39678: PUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 4
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 30
39691: PUSH
39692: LD_INT 5
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: LIST
39703: PPUSH
39704: CALL_OW 72
39708: PUSH
39709: LD_INT 6
39711: MUL
39712: PLUS
39713: ST_TO_ADDR
// if bcount < tmp then
39714: LD_VAR 0 13
39718: PUSH
39719: LD_VAR 0 4
39723: LESS
39724: IFFALSE 39770
// for i = tmp downto bcount do
39726: LD_ADDR_VAR 0 3
39730: PUSH
39731: DOUBLE
39732: LD_VAR 0 4
39736: INC
39737: ST_TO_ADDR
39738: LD_VAR 0 13
39742: PUSH
39743: FOR_DOWNTO
39744: IFFALSE 39768
// tmp := Delete ( tmp , tmp ) ;
39746: LD_ADDR_VAR 0 4
39750: PUSH
39751: LD_VAR 0 4
39755: PPUSH
39756: LD_VAR 0 4
39760: PPUSH
39761: CALL_OW 3
39765: ST_TO_ADDR
39766: GO 39743
39768: POP
39769: POP
// result := [ tmp , 0 , 0 , p ] ;
39770: LD_ADDR_VAR 0 2
39774: PUSH
39775: LD_VAR 0 4
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: LD_VAR 0 11
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: ST_TO_ADDR
// exit ;
39797: GO 42487
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39799: LD_EXP 101
39803: PUSH
39804: LD_VAR 0 1
39808: ARRAY
39809: PPUSH
39810: LD_INT 2
39812: PUSH
39813: LD_INT 30
39815: PUSH
39816: LD_INT 6
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 30
39825: PUSH
39826: LD_INT 7
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 30
39835: PUSH
39836: LD_INT 8
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: PPUSH
39849: CALL_OW 72
39853: NOT
39854: PUSH
39855: LD_EXP 101
39859: PUSH
39860: LD_VAR 0 1
39864: ARRAY
39865: PPUSH
39866: LD_INT 30
39868: PUSH
39869: LD_INT 3
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PPUSH
39876: CALL_OW 72
39880: NOT
39881: AND
39882: IFFALSE 39954
// begin if eng = tmp then
39884: LD_VAR 0 6
39888: PUSH
39889: LD_VAR 0 4
39893: EQUAL
39894: IFFALSE 39898
// exit ;
39896: GO 42487
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39898: LD_ADDR_EXP 143
39902: PUSH
39903: LD_EXP 143
39907: PPUSH
39908: LD_VAR 0 1
39912: PPUSH
39913: LD_INT 1
39915: PPUSH
39916: CALL_OW 1
39920: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39921: LD_ADDR_VAR 0 2
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_VAR 0 4
39933: PUSH
39934: LD_VAR 0 6
39938: DIFF
39939: PUSH
39940: LD_INT 0
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: ST_TO_ADDR
// exit ;
39952: GO 42487
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39954: LD_EXP 128
39958: PUSH
39959: LD_EXP 127
39963: PUSH
39964: LD_VAR 0 1
39968: ARRAY
39969: ARRAY
39970: PUSH
39971: LD_EXP 101
39975: PUSH
39976: LD_VAR 0 1
39980: ARRAY
39981: PPUSH
39982: LD_INT 2
39984: PUSH
39985: LD_INT 30
39987: PUSH
39988: LD_INT 6
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 30
39997: PUSH
39998: LD_INT 7
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 30
40007: PUSH
40008: LD_INT 8
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: PPUSH
40021: CALL_OW 72
40025: AND
40026: PUSH
40027: LD_EXP 101
40031: PUSH
40032: LD_VAR 0 1
40036: ARRAY
40037: PPUSH
40038: LD_INT 30
40040: PUSH
40041: LD_INT 3
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PPUSH
40048: CALL_OW 72
40052: NOT
40053: AND
40054: IFFALSE 40268
// begin if sci >= 6 then
40056: LD_VAR 0 8
40060: PUSH
40061: LD_INT 6
40063: GREATEREQUAL
40064: IFFALSE 40068
// exit ;
40066: GO 42487
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40068: LD_ADDR_EXP 143
40072: PUSH
40073: LD_EXP 143
40077: PPUSH
40078: LD_VAR 0 1
40082: PPUSH
40083: LD_INT 2
40085: PPUSH
40086: CALL_OW 1
40090: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40091: LD_ADDR_VAR 0 9
40095: PUSH
40096: LD_VAR 0 4
40100: PUSH
40101: LD_VAR 0 8
40105: DIFF
40106: PPUSH
40107: LD_INT 4
40109: PPUSH
40110: CALL 105774 0 2
40114: ST_TO_ADDR
// p := [ ] ;
40115: LD_ADDR_VAR 0 11
40119: PUSH
40120: EMPTY
40121: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40122: LD_VAR 0 8
40126: PUSH
40127: LD_INT 6
40129: LESS
40130: PUSH
40131: LD_VAR 0 9
40135: PUSH
40136: LD_INT 6
40138: GREATER
40139: AND
40140: IFFALSE 40221
// begin for i = 1 to 6 - sci do
40142: LD_ADDR_VAR 0 3
40146: PUSH
40147: DOUBLE
40148: LD_INT 1
40150: DEC
40151: ST_TO_ADDR
40152: LD_INT 6
40154: PUSH
40155: LD_VAR 0 8
40159: MINUS
40160: PUSH
40161: FOR_TO
40162: IFFALSE 40217
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40164: LD_ADDR_VAR 0 11
40168: PUSH
40169: LD_VAR 0 11
40173: PPUSH
40174: LD_VAR 0 11
40178: PUSH
40179: LD_INT 1
40181: PLUS
40182: PPUSH
40183: LD_VAR 0 9
40187: PUSH
40188: LD_INT 1
40190: ARRAY
40191: PPUSH
40192: CALL_OW 2
40196: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40197: LD_ADDR_VAR 0 9
40201: PUSH
40202: LD_VAR 0 9
40206: PPUSH
40207: LD_INT 1
40209: PPUSH
40210: CALL_OW 3
40214: ST_TO_ADDR
// end ;
40215: GO 40161
40217: POP
40218: POP
// end else
40219: GO 40241
// if sort then
40221: LD_VAR 0 9
40225: IFFALSE 40241
// p := sort [ 1 ] ;
40227: LD_ADDR_VAR 0 11
40231: PUSH
40232: LD_VAR 0 9
40236: PUSH
40237: LD_INT 1
40239: ARRAY
40240: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40241: LD_ADDR_VAR 0 2
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: LD_INT 0
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: LD_VAR 0 11
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: ST_TO_ADDR
// exit ;
40266: GO 42487
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40268: LD_EXP 128
40272: PUSH
40273: LD_EXP 127
40277: PUSH
40278: LD_VAR 0 1
40282: ARRAY
40283: ARRAY
40284: PUSH
40285: LD_EXP 101
40289: PUSH
40290: LD_VAR 0 1
40294: ARRAY
40295: PPUSH
40296: LD_INT 2
40298: PUSH
40299: LD_INT 30
40301: PUSH
40302: LD_INT 6
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 30
40311: PUSH
40312: LD_INT 7
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 30
40321: PUSH
40322: LD_INT 8
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: PPUSH
40335: CALL_OW 72
40339: AND
40340: PUSH
40341: LD_EXP 101
40345: PUSH
40346: LD_VAR 0 1
40350: ARRAY
40351: PPUSH
40352: LD_INT 30
40354: PUSH
40355: LD_INT 3
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PPUSH
40362: CALL_OW 72
40366: AND
40367: IFFALSE 41101
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40369: LD_ADDR_EXP 143
40373: PUSH
40374: LD_EXP 143
40378: PPUSH
40379: LD_VAR 0 1
40383: PPUSH
40384: LD_INT 3
40386: PPUSH
40387: CALL_OW 1
40391: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40392: LD_ADDR_VAR 0 2
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: LD_INT 0
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: ST_TO_ADDR
// if not eng then
40415: LD_VAR 0 6
40419: NOT
40420: IFFALSE 40483
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40422: LD_ADDR_VAR 0 11
40426: PUSH
40427: LD_VAR 0 4
40431: PPUSH
40432: LD_INT 2
40434: PPUSH
40435: CALL 105774 0 2
40439: PUSH
40440: LD_INT 1
40442: ARRAY
40443: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40444: LD_ADDR_VAR 0 2
40448: PUSH
40449: LD_VAR 0 2
40453: PPUSH
40454: LD_INT 2
40456: PPUSH
40457: LD_VAR 0 11
40461: PPUSH
40462: CALL_OW 1
40466: ST_TO_ADDR
// tmp := tmp diff p ;
40467: LD_ADDR_VAR 0 4
40471: PUSH
40472: LD_VAR 0 4
40476: PUSH
40477: LD_VAR 0 11
40481: DIFF
40482: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40483: LD_VAR 0 4
40487: PUSH
40488: LD_VAR 0 8
40492: PUSH
40493: LD_INT 6
40495: LESS
40496: AND
40497: IFFALSE 40685
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40499: LD_ADDR_VAR 0 9
40503: PUSH
40504: LD_VAR 0 4
40508: PUSH
40509: LD_VAR 0 8
40513: PUSH
40514: LD_VAR 0 7
40518: UNION
40519: DIFF
40520: PPUSH
40521: LD_INT 4
40523: PPUSH
40524: CALL 105774 0 2
40528: ST_TO_ADDR
// p := [ ] ;
40529: LD_ADDR_VAR 0 11
40533: PUSH
40534: EMPTY
40535: ST_TO_ADDR
// if sort then
40536: LD_VAR 0 9
40540: IFFALSE 40656
// for i = 1 to 6 - sci do
40542: LD_ADDR_VAR 0 3
40546: PUSH
40547: DOUBLE
40548: LD_INT 1
40550: DEC
40551: ST_TO_ADDR
40552: LD_INT 6
40554: PUSH
40555: LD_VAR 0 8
40559: MINUS
40560: PUSH
40561: FOR_TO
40562: IFFALSE 40654
// begin if i = sort then
40564: LD_VAR 0 3
40568: PUSH
40569: LD_VAR 0 9
40573: EQUAL
40574: IFFALSE 40578
// break ;
40576: GO 40654
// if GetClass ( i ) = 4 then
40578: LD_VAR 0 3
40582: PPUSH
40583: CALL_OW 257
40587: PUSH
40588: LD_INT 4
40590: EQUAL
40591: IFFALSE 40595
// continue ;
40593: GO 40561
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40595: LD_ADDR_VAR 0 11
40599: PUSH
40600: LD_VAR 0 11
40604: PPUSH
40605: LD_VAR 0 11
40609: PUSH
40610: LD_INT 1
40612: PLUS
40613: PPUSH
40614: LD_VAR 0 9
40618: PUSH
40619: LD_VAR 0 3
40623: ARRAY
40624: PPUSH
40625: CALL_OW 2
40629: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40630: LD_ADDR_VAR 0 4
40634: PUSH
40635: LD_VAR 0 4
40639: PUSH
40640: LD_VAR 0 9
40644: PUSH
40645: LD_VAR 0 3
40649: ARRAY
40650: DIFF
40651: ST_TO_ADDR
// end ;
40652: GO 40561
40654: POP
40655: POP
// if p then
40656: LD_VAR 0 11
40660: IFFALSE 40685
// result := Replace ( result , 4 , p ) ;
40662: LD_ADDR_VAR 0 2
40666: PUSH
40667: LD_VAR 0 2
40671: PPUSH
40672: LD_INT 4
40674: PPUSH
40675: LD_VAR 0 11
40679: PPUSH
40680: CALL_OW 1
40684: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40685: LD_VAR 0 4
40689: PUSH
40690: LD_VAR 0 7
40694: PUSH
40695: LD_INT 6
40697: LESS
40698: AND
40699: IFFALSE 40887
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40701: LD_ADDR_VAR 0 9
40705: PUSH
40706: LD_VAR 0 4
40710: PUSH
40711: LD_VAR 0 8
40715: PUSH
40716: LD_VAR 0 7
40720: UNION
40721: DIFF
40722: PPUSH
40723: LD_INT 3
40725: PPUSH
40726: CALL 105774 0 2
40730: ST_TO_ADDR
// p := [ ] ;
40731: LD_ADDR_VAR 0 11
40735: PUSH
40736: EMPTY
40737: ST_TO_ADDR
// if sort then
40738: LD_VAR 0 9
40742: IFFALSE 40858
// for i = 1 to 6 - mech do
40744: LD_ADDR_VAR 0 3
40748: PUSH
40749: DOUBLE
40750: LD_INT 1
40752: DEC
40753: ST_TO_ADDR
40754: LD_INT 6
40756: PUSH
40757: LD_VAR 0 7
40761: MINUS
40762: PUSH
40763: FOR_TO
40764: IFFALSE 40856
// begin if i = sort then
40766: LD_VAR 0 3
40770: PUSH
40771: LD_VAR 0 9
40775: EQUAL
40776: IFFALSE 40780
// break ;
40778: GO 40856
// if GetClass ( i ) = 3 then
40780: LD_VAR 0 3
40784: PPUSH
40785: CALL_OW 257
40789: PUSH
40790: LD_INT 3
40792: EQUAL
40793: IFFALSE 40797
// continue ;
40795: GO 40763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40797: LD_ADDR_VAR 0 11
40801: PUSH
40802: LD_VAR 0 11
40806: PPUSH
40807: LD_VAR 0 11
40811: PUSH
40812: LD_INT 1
40814: PLUS
40815: PPUSH
40816: LD_VAR 0 9
40820: PUSH
40821: LD_VAR 0 3
40825: ARRAY
40826: PPUSH
40827: CALL_OW 2
40831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40832: LD_ADDR_VAR 0 4
40836: PUSH
40837: LD_VAR 0 4
40841: PUSH
40842: LD_VAR 0 9
40846: PUSH
40847: LD_VAR 0 3
40851: ARRAY
40852: DIFF
40853: ST_TO_ADDR
// end ;
40854: GO 40763
40856: POP
40857: POP
// if p then
40858: LD_VAR 0 11
40862: IFFALSE 40887
// result := Replace ( result , 3 , p ) ;
40864: LD_ADDR_VAR 0 2
40868: PUSH
40869: LD_VAR 0 2
40873: PPUSH
40874: LD_INT 3
40876: PPUSH
40877: LD_VAR 0 11
40881: PPUSH
40882: CALL_OW 1
40886: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40887: LD_VAR 0 4
40891: PUSH
40892: LD_INT 6
40894: GREATER
40895: PUSH
40896: LD_VAR 0 6
40900: PUSH
40901: LD_INT 6
40903: LESS
40904: AND
40905: IFFALSE 41099
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40907: LD_ADDR_VAR 0 9
40911: PUSH
40912: LD_VAR 0 4
40916: PUSH
40917: LD_VAR 0 8
40921: PUSH
40922: LD_VAR 0 7
40926: UNION
40927: PUSH
40928: LD_VAR 0 6
40932: UNION
40933: DIFF
40934: PPUSH
40935: LD_INT 2
40937: PPUSH
40938: CALL 105774 0 2
40942: ST_TO_ADDR
// p := [ ] ;
40943: LD_ADDR_VAR 0 11
40947: PUSH
40948: EMPTY
40949: ST_TO_ADDR
// if sort then
40950: LD_VAR 0 9
40954: IFFALSE 41070
// for i = 1 to 6 - eng do
40956: LD_ADDR_VAR 0 3
40960: PUSH
40961: DOUBLE
40962: LD_INT 1
40964: DEC
40965: ST_TO_ADDR
40966: LD_INT 6
40968: PUSH
40969: LD_VAR 0 6
40973: MINUS
40974: PUSH
40975: FOR_TO
40976: IFFALSE 41068
// begin if i = sort then
40978: LD_VAR 0 3
40982: PUSH
40983: LD_VAR 0 9
40987: EQUAL
40988: IFFALSE 40992
// break ;
40990: GO 41068
// if GetClass ( i ) = 2 then
40992: LD_VAR 0 3
40996: PPUSH
40997: CALL_OW 257
41001: PUSH
41002: LD_INT 2
41004: EQUAL
41005: IFFALSE 41009
// continue ;
41007: GO 40975
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41009: LD_ADDR_VAR 0 11
41013: PUSH
41014: LD_VAR 0 11
41018: PPUSH
41019: LD_VAR 0 11
41023: PUSH
41024: LD_INT 1
41026: PLUS
41027: PPUSH
41028: LD_VAR 0 9
41032: PUSH
41033: LD_VAR 0 3
41037: ARRAY
41038: PPUSH
41039: CALL_OW 2
41043: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41044: LD_ADDR_VAR 0 4
41048: PUSH
41049: LD_VAR 0 4
41053: PUSH
41054: LD_VAR 0 9
41058: PUSH
41059: LD_VAR 0 3
41063: ARRAY
41064: DIFF
41065: ST_TO_ADDR
// end ;
41066: GO 40975
41068: POP
41069: POP
// if p then
41070: LD_VAR 0 11
41074: IFFALSE 41099
// result := Replace ( result , 2 , p ) ;
41076: LD_ADDR_VAR 0 2
41080: PUSH
41081: LD_VAR 0 2
41085: PPUSH
41086: LD_INT 2
41088: PPUSH
41089: LD_VAR 0 11
41093: PPUSH
41094: CALL_OW 1
41098: ST_TO_ADDR
// end ; exit ;
41099: GO 42487
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41101: LD_EXP 128
41105: PUSH
41106: LD_EXP 127
41110: PUSH
41111: LD_VAR 0 1
41115: ARRAY
41116: ARRAY
41117: NOT
41118: PUSH
41119: LD_EXP 101
41123: PUSH
41124: LD_VAR 0 1
41128: ARRAY
41129: PPUSH
41130: LD_INT 30
41132: PUSH
41133: LD_INT 3
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PPUSH
41140: CALL_OW 72
41144: AND
41145: PUSH
41146: LD_EXP 106
41150: PUSH
41151: LD_VAR 0 1
41155: ARRAY
41156: AND
41157: IFFALSE 41765
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41159: LD_ADDR_EXP 143
41163: PUSH
41164: LD_EXP 143
41168: PPUSH
41169: LD_VAR 0 1
41173: PPUSH
41174: LD_INT 5
41176: PPUSH
41177: CALL_OW 1
41181: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41182: LD_ADDR_VAR 0 2
41186: PUSH
41187: LD_INT 0
41189: PUSH
41190: LD_INT 0
41192: PUSH
41193: LD_INT 0
41195: PUSH
41196: LD_INT 0
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: ST_TO_ADDR
// if sci > 1 then
41205: LD_VAR 0 8
41209: PUSH
41210: LD_INT 1
41212: GREATER
41213: IFFALSE 41241
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41215: LD_ADDR_VAR 0 4
41219: PUSH
41220: LD_VAR 0 4
41224: PUSH
41225: LD_VAR 0 8
41229: PUSH
41230: LD_VAR 0 8
41234: PUSH
41235: LD_INT 1
41237: ARRAY
41238: DIFF
41239: DIFF
41240: ST_TO_ADDR
// if tmp and not sci then
41241: LD_VAR 0 4
41245: PUSH
41246: LD_VAR 0 8
41250: NOT
41251: AND
41252: IFFALSE 41321
// begin sort := SortBySkill ( tmp , 4 ) ;
41254: LD_ADDR_VAR 0 9
41258: PUSH
41259: LD_VAR 0 4
41263: PPUSH
41264: LD_INT 4
41266: PPUSH
41267: CALL 105774 0 2
41271: ST_TO_ADDR
// if sort then
41272: LD_VAR 0 9
41276: IFFALSE 41292
// p := sort [ 1 ] ;
41278: LD_ADDR_VAR 0 11
41282: PUSH
41283: LD_VAR 0 9
41287: PUSH
41288: LD_INT 1
41290: ARRAY
41291: ST_TO_ADDR
// if p then
41292: LD_VAR 0 11
41296: IFFALSE 41321
// result := Replace ( result , 4 , p ) ;
41298: LD_ADDR_VAR 0 2
41302: PUSH
41303: LD_VAR 0 2
41307: PPUSH
41308: LD_INT 4
41310: PPUSH
41311: LD_VAR 0 11
41315: PPUSH
41316: CALL_OW 1
41320: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41321: LD_ADDR_VAR 0 4
41325: PUSH
41326: LD_VAR 0 4
41330: PUSH
41331: LD_VAR 0 7
41335: DIFF
41336: ST_TO_ADDR
// if tmp and mech < 6 then
41337: LD_VAR 0 4
41341: PUSH
41342: LD_VAR 0 7
41346: PUSH
41347: LD_INT 6
41349: LESS
41350: AND
41351: IFFALSE 41539
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41353: LD_ADDR_VAR 0 9
41357: PUSH
41358: LD_VAR 0 4
41362: PUSH
41363: LD_VAR 0 8
41367: PUSH
41368: LD_VAR 0 7
41372: UNION
41373: DIFF
41374: PPUSH
41375: LD_INT 3
41377: PPUSH
41378: CALL 105774 0 2
41382: ST_TO_ADDR
// p := [ ] ;
41383: LD_ADDR_VAR 0 11
41387: PUSH
41388: EMPTY
41389: ST_TO_ADDR
// if sort then
41390: LD_VAR 0 9
41394: IFFALSE 41510
// for i = 1 to 6 - mech do
41396: LD_ADDR_VAR 0 3
41400: PUSH
41401: DOUBLE
41402: LD_INT 1
41404: DEC
41405: ST_TO_ADDR
41406: LD_INT 6
41408: PUSH
41409: LD_VAR 0 7
41413: MINUS
41414: PUSH
41415: FOR_TO
41416: IFFALSE 41508
// begin if i = sort then
41418: LD_VAR 0 3
41422: PUSH
41423: LD_VAR 0 9
41427: EQUAL
41428: IFFALSE 41432
// break ;
41430: GO 41508
// if GetClass ( i ) = 3 then
41432: LD_VAR 0 3
41436: PPUSH
41437: CALL_OW 257
41441: PUSH
41442: LD_INT 3
41444: EQUAL
41445: IFFALSE 41449
// continue ;
41447: GO 41415
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41449: LD_ADDR_VAR 0 11
41453: PUSH
41454: LD_VAR 0 11
41458: PPUSH
41459: LD_VAR 0 11
41463: PUSH
41464: LD_INT 1
41466: PLUS
41467: PPUSH
41468: LD_VAR 0 9
41472: PUSH
41473: LD_VAR 0 3
41477: ARRAY
41478: PPUSH
41479: CALL_OW 2
41483: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41484: LD_ADDR_VAR 0 4
41488: PUSH
41489: LD_VAR 0 4
41493: PUSH
41494: LD_VAR 0 9
41498: PUSH
41499: LD_VAR 0 3
41503: ARRAY
41504: DIFF
41505: ST_TO_ADDR
// end ;
41506: GO 41415
41508: POP
41509: POP
// if p then
41510: LD_VAR 0 11
41514: IFFALSE 41539
// result := Replace ( result , 3 , p ) ;
41516: LD_ADDR_VAR 0 2
41520: PUSH
41521: LD_VAR 0 2
41525: PPUSH
41526: LD_INT 3
41528: PPUSH
41529: LD_VAR 0 11
41533: PPUSH
41534: CALL_OW 1
41538: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41539: LD_ADDR_VAR 0 4
41543: PUSH
41544: LD_VAR 0 4
41548: PUSH
41549: LD_VAR 0 6
41553: DIFF
41554: ST_TO_ADDR
// if tmp and eng < 6 then
41555: LD_VAR 0 4
41559: PUSH
41560: LD_VAR 0 6
41564: PUSH
41565: LD_INT 6
41567: LESS
41568: AND
41569: IFFALSE 41763
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41571: LD_ADDR_VAR 0 9
41575: PUSH
41576: LD_VAR 0 4
41580: PUSH
41581: LD_VAR 0 8
41585: PUSH
41586: LD_VAR 0 7
41590: UNION
41591: PUSH
41592: LD_VAR 0 6
41596: UNION
41597: DIFF
41598: PPUSH
41599: LD_INT 2
41601: PPUSH
41602: CALL 105774 0 2
41606: ST_TO_ADDR
// p := [ ] ;
41607: LD_ADDR_VAR 0 11
41611: PUSH
41612: EMPTY
41613: ST_TO_ADDR
// if sort then
41614: LD_VAR 0 9
41618: IFFALSE 41734
// for i = 1 to 6 - eng do
41620: LD_ADDR_VAR 0 3
41624: PUSH
41625: DOUBLE
41626: LD_INT 1
41628: DEC
41629: ST_TO_ADDR
41630: LD_INT 6
41632: PUSH
41633: LD_VAR 0 6
41637: MINUS
41638: PUSH
41639: FOR_TO
41640: IFFALSE 41732
// begin if i = sort then
41642: LD_VAR 0 3
41646: PUSH
41647: LD_VAR 0 9
41651: EQUAL
41652: IFFALSE 41656
// break ;
41654: GO 41732
// if GetClass ( i ) = 2 then
41656: LD_VAR 0 3
41660: PPUSH
41661: CALL_OW 257
41665: PUSH
41666: LD_INT 2
41668: EQUAL
41669: IFFALSE 41673
// continue ;
41671: GO 41639
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41673: LD_ADDR_VAR 0 11
41677: PUSH
41678: LD_VAR 0 11
41682: PPUSH
41683: LD_VAR 0 11
41687: PUSH
41688: LD_INT 1
41690: PLUS
41691: PPUSH
41692: LD_VAR 0 9
41696: PUSH
41697: LD_VAR 0 3
41701: ARRAY
41702: PPUSH
41703: CALL_OW 2
41707: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41708: LD_ADDR_VAR 0 4
41712: PUSH
41713: LD_VAR 0 4
41717: PUSH
41718: LD_VAR 0 9
41722: PUSH
41723: LD_VAR 0 3
41727: ARRAY
41728: DIFF
41729: ST_TO_ADDR
// end ;
41730: GO 41639
41732: POP
41733: POP
// if p then
41734: LD_VAR 0 11
41738: IFFALSE 41763
// result := Replace ( result , 2 , p ) ;
41740: LD_ADDR_VAR 0 2
41744: PUSH
41745: LD_VAR 0 2
41749: PPUSH
41750: LD_INT 2
41752: PPUSH
41753: LD_VAR 0 11
41757: PPUSH
41758: CALL_OW 1
41762: ST_TO_ADDR
// end ; exit ;
41763: GO 42487
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41765: LD_EXP 128
41769: PUSH
41770: LD_EXP 127
41774: PUSH
41775: LD_VAR 0 1
41779: ARRAY
41780: ARRAY
41781: NOT
41782: PUSH
41783: LD_EXP 101
41787: PUSH
41788: LD_VAR 0 1
41792: ARRAY
41793: PPUSH
41794: LD_INT 30
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PPUSH
41804: CALL_OW 72
41808: AND
41809: PUSH
41810: LD_EXP 106
41814: PUSH
41815: LD_VAR 0 1
41819: ARRAY
41820: NOT
41821: AND
41822: IFFALSE 42487
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41824: LD_ADDR_EXP 143
41828: PUSH
41829: LD_EXP 143
41833: PPUSH
41834: LD_VAR 0 1
41838: PPUSH
41839: LD_INT 6
41841: PPUSH
41842: CALL_OW 1
41846: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41847: LD_ADDR_VAR 0 2
41851: PUSH
41852: LD_INT 0
41854: PUSH
41855: LD_INT 0
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: LD_INT 0
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: LIST
41868: LIST
41869: ST_TO_ADDR
// if sci >= 1 then
41870: LD_VAR 0 8
41874: PUSH
41875: LD_INT 1
41877: GREATEREQUAL
41878: IFFALSE 41900
// tmp := tmp diff sci [ 1 ] ;
41880: LD_ADDR_VAR 0 4
41884: PUSH
41885: LD_VAR 0 4
41889: PUSH
41890: LD_VAR 0 8
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: DIFF
41899: ST_TO_ADDR
// if tmp and not sci then
41900: LD_VAR 0 4
41904: PUSH
41905: LD_VAR 0 8
41909: NOT
41910: AND
41911: IFFALSE 41980
// begin sort := SortBySkill ( tmp , 4 ) ;
41913: LD_ADDR_VAR 0 9
41917: PUSH
41918: LD_VAR 0 4
41922: PPUSH
41923: LD_INT 4
41925: PPUSH
41926: CALL 105774 0 2
41930: ST_TO_ADDR
// if sort then
41931: LD_VAR 0 9
41935: IFFALSE 41951
// p := sort [ 1 ] ;
41937: LD_ADDR_VAR 0 11
41941: PUSH
41942: LD_VAR 0 9
41946: PUSH
41947: LD_INT 1
41949: ARRAY
41950: ST_TO_ADDR
// if p then
41951: LD_VAR 0 11
41955: IFFALSE 41980
// result := Replace ( result , 4 , p ) ;
41957: LD_ADDR_VAR 0 2
41961: PUSH
41962: LD_VAR 0 2
41966: PPUSH
41967: LD_INT 4
41969: PPUSH
41970: LD_VAR 0 11
41974: PPUSH
41975: CALL_OW 1
41979: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41980: LD_ADDR_VAR 0 4
41984: PUSH
41985: LD_VAR 0 4
41989: PUSH
41990: LD_VAR 0 7
41994: DIFF
41995: ST_TO_ADDR
// if tmp and mech < 6 then
41996: LD_VAR 0 4
42000: PUSH
42001: LD_VAR 0 7
42005: PUSH
42006: LD_INT 6
42008: LESS
42009: AND
42010: IFFALSE 42192
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42012: LD_ADDR_VAR 0 9
42016: PUSH
42017: LD_VAR 0 4
42021: PUSH
42022: LD_VAR 0 7
42026: DIFF
42027: PPUSH
42028: LD_INT 3
42030: PPUSH
42031: CALL 105774 0 2
42035: ST_TO_ADDR
// p := [ ] ;
42036: LD_ADDR_VAR 0 11
42040: PUSH
42041: EMPTY
42042: ST_TO_ADDR
// if sort then
42043: LD_VAR 0 9
42047: IFFALSE 42163
// for i = 1 to 6 - mech do
42049: LD_ADDR_VAR 0 3
42053: PUSH
42054: DOUBLE
42055: LD_INT 1
42057: DEC
42058: ST_TO_ADDR
42059: LD_INT 6
42061: PUSH
42062: LD_VAR 0 7
42066: MINUS
42067: PUSH
42068: FOR_TO
42069: IFFALSE 42161
// begin if i = sort then
42071: LD_VAR 0 3
42075: PUSH
42076: LD_VAR 0 9
42080: EQUAL
42081: IFFALSE 42085
// break ;
42083: GO 42161
// if GetClass ( i ) = 3 then
42085: LD_VAR 0 3
42089: PPUSH
42090: CALL_OW 257
42094: PUSH
42095: LD_INT 3
42097: EQUAL
42098: IFFALSE 42102
// continue ;
42100: GO 42068
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42102: LD_ADDR_VAR 0 11
42106: PUSH
42107: LD_VAR 0 11
42111: PPUSH
42112: LD_VAR 0 11
42116: PUSH
42117: LD_INT 1
42119: PLUS
42120: PPUSH
42121: LD_VAR 0 9
42125: PUSH
42126: LD_VAR 0 3
42130: ARRAY
42131: PPUSH
42132: CALL_OW 2
42136: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42137: LD_ADDR_VAR 0 4
42141: PUSH
42142: LD_VAR 0 4
42146: PUSH
42147: LD_VAR 0 9
42151: PUSH
42152: LD_VAR 0 3
42156: ARRAY
42157: DIFF
42158: ST_TO_ADDR
// end ;
42159: GO 42068
42161: POP
42162: POP
// if p then
42163: LD_VAR 0 11
42167: IFFALSE 42192
// result := Replace ( result , 3 , p ) ;
42169: LD_ADDR_VAR 0 2
42173: PUSH
42174: LD_VAR 0 2
42178: PPUSH
42179: LD_INT 3
42181: PPUSH
42182: LD_VAR 0 11
42186: PPUSH
42187: CALL_OW 1
42191: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42192: LD_ADDR_VAR 0 4
42196: PUSH
42197: LD_VAR 0 4
42201: PUSH
42202: LD_VAR 0 6
42206: DIFF
42207: ST_TO_ADDR
// if tmp and eng < 4 then
42208: LD_VAR 0 4
42212: PUSH
42213: LD_VAR 0 6
42217: PUSH
42218: LD_INT 4
42220: LESS
42221: AND
42222: IFFALSE 42412
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42224: LD_ADDR_VAR 0 9
42228: PUSH
42229: LD_VAR 0 4
42233: PUSH
42234: LD_VAR 0 7
42238: PUSH
42239: LD_VAR 0 6
42243: UNION
42244: DIFF
42245: PPUSH
42246: LD_INT 2
42248: PPUSH
42249: CALL 105774 0 2
42253: ST_TO_ADDR
// p := [ ] ;
42254: LD_ADDR_VAR 0 11
42258: PUSH
42259: EMPTY
42260: ST_TO_ADDR
// if sort then
42261: LD_VAR 0 9
42265: IFFALSE 42381
// for i = 1 to 4 - eng do
42267: LD_ADDR_VAR 0 3
42271: PUSH
42272: DOUBLE
42273: LD_INT 1
42275: DEC
42276: ST_TO_ADDR
42277: LD_INT 4
42279: PUSH
42280: LD_VAR 0 6
42284: MINUS
42285: PUSH
42286: FOR_TO
42287: IFFALSE 42379
// begin if i = sort then
42289: LD_VAR 0 3
42293: PUSH
42294: LD_VAR 0 9
42298: EQUAL
42299: IFFALSE 42303
// break ;
42301: GO 42379
// if GetClass ( i ) = 2 then
42303: LD_VAR 0 3
42307: PPUSH
42308: CALL_OW 257
42312: PUSH
42313: LD_INT 2
42315: EQUAL
42316: IFFALSE 42320
// continue ;
42318: GO 42286
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42320: LD_ADDR_VAR 0 11
42324: PUSH
42325: LD_VAR 0 11
42329: PPUSH
42330: LD_VAR 0 11
42334: PUSH
42335: LD_INT 1
42337: PLUS
42338: PPUSH
42339: LD_VAR 0 9
42343: PUSH
42344: LD_VAR 0 3
42348: ARRAY
42349: PPUSH
42350: CALL_OW 2
42354: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42355: LD_ADDR_VAR 0 4
42359: PUSH
42360: LD_VAR 0 4
42364: PUSH
42365: LD_VAR 0 9
42369: PUSH
42370: LD_VAR 0 3
42374: ARRAY
42375: DIFF
42376: ST_TO_ADDR
// end ;
42377: GO 42286
42379: POP
42380: POP
// if p then
42381: LD_VAR 0 11
42385: IFFALSE 42410
// result := Replace ( result , 2 , p ) ;
42387: LD_ADDR_VAR 0 2
42391: PUSH
42392: LD_VAR 0 2
42396: PPUSH
42397: LD_INT 2
42399: PPUSH
42400: LD_VAR 0 11
42404: PPUSH
42405: CALL_OW 1
42409: ST_TO_ADDR
// end else
42410: GO 42456
// for i = eng downto 5 do
42412: LD_ADDR_VAR 0 3
42416: PUSH
42417: DOUBLE
42418: LD_VAR 0 6
42422: INC
42423: ST_TO_ADDR
42424: LD_INT 5
42426: PUSH
42427: FOR_DOWNTO
42428: IFFALSE 42454
// tmp := tmp union eng [ i ] ;
42430: LD_ADDR_VAR 0 4
42434: PUSH
42435: LD_VAR 0 4
42439: PUSH
42440: LD_VAR 0 6
42444: PUSH
42445: LD_VAR 0 3
42449: ARRAY
42450: UNION
42451: ST_TO_ADDR
42452: GO 42427
42454: POP
42455: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42456: LD_ADDR_VAR 0 2
42460: PUSH
42461: LD_VAR 0 2
42465: PPUSH
42466: LD_INT 1
42468: PPUSH
42469: LD_VAR 0 4
42473: PUSH
42474: LD_VAR 0 5
42478: DIFF
42479: PPUSH
42480: CALL_OW 1
42484: ST_TO_ADDR
// exit ;
42485: GO 42487
// end ; end ;
42487: LD_VAR 0 2
42491: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42492: LD_INT 0
42494: PPUSH
42495: PPUSH
42496: PPUSH
// if not mc_bases then
42497: LD_EXP 101
42501: NOT
42502: IFFALSE 42506
// exit ;
42504: GO 42612
// for i = 1 to mc_bases do
42506: LD_ADDR_VAR 0 2
42510: PUSH
42511: DOUBLE
42512: LD_INT 1
42514: DEC
42515: ST_TO_ADDR
42516: LD_EXP 101
42520: PUSH
42521: FOR_TO
42522: IFFALSE 42603
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42524: LD_ADDR_VAR 0 3
42528: PUSH
42529: LD_EXP 101
42533: PUSH
42534: LD_VAR 0 2
42538: ARRAY
42539: PPUSH
42540: LD_INT 21
42542: PUSH
42543: LD_INT 3
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PUSH
42550: LD_INT 3
42552: PUSH
42553: LD_INT 24
42555: PUSH
42556: LD_INT 1000
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PPUSH
42571: CALL_OW 72
42575: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42576: LD_ADDR_EXP 102
42580: PUSH
42581: LD_EXP 102
42585: PPUSH
42586: LD_VAR 0 2
42590: PPUSH
42591: LD_VAR 0 3
42595: PPUSH
42596: CALL_OW 1
42600: ST_TO_ADDR
// end ;
42601: GO 42521
42603: POP
42604: POP
// RaiseSailEvent ( 101 ) ;
42605: LD_INT 101
42607: PPUSH
42608: CALL_OW 427
// end ;
42612: LD_VAR 0 1
42616: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42617: LD_INT 0
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
42623: PPUSH
42624: PPUSH
42625: PPUSH
// if not mc_bases then
42626: LD_EXP 101
42630: NOT
42631: IFFALSE 42635
// exit ;
42633: GO 43208
// for i = 1 to mc_bases do
42635: LD_ADDR_VAR 0 2
42639: PUSH
42640: DOUBLE
42641: LD_INT 1
42643: DEC
42644: ST_TO_ADDR
42645: LD_EXP 101
42649: PUSH
42650: FOR_TO
42651: IFFALSE 43199
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42653: LD_ADDR_VAR 0 5
42657: PUSH
42658: LD_EXP 101
42662: PUSH
42663: LD_VAR 0 2
42667: ARRAY
42668: PUSH
42669: LD_EXP 130
42673: PUSH
42674: LD_VAR 0 2
42678: ARRAY
42679: UNION
42680: PPUSH
42681: LD_INT 21
42683: PUSH
42684: LD_INT 1
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: LD_INT 54
42699: PUSH
42700: EMPTY
42701: LIST
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 3
42709: PUSH
42710: LD_INT 24
42712: PUSH
42713: LD_INT 800
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: LIST
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PPUSH
42733: CALL_OW 72
42737: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42738: LD_ADDR_VAR 0 6
42742: PUSH
42743: LD_EXP 101
42747: PUSH
42748: LD_VAR 0 2
42752: ARRAY
42753: PPUSH
42754: LD_INT 21
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: LD_INT 3
42769: PUSH
42770: LD_INT 54
42772: PUSH
42773: EMPTY
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: LD_INT 24
42785: PUSH
42786: LD_INT 250
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: LIST
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PPUSH
42806: CALL_OW 72
42810: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42811: LD_ADDR_VAR 0 7
42815: PUSH
42816: LD_VAR 0 5
42820: PUSH
42821: LD_VAR 0 6
42825: DIFF
42826: ST_TO_ADDR
// if not need_heal_1 then
42827: LD_VAR 0 6
42831: NOT
42832: IFFALSE 42865
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42834: LD_ADDR_EXP 104
42838: PUSH
42839: LD_EXP 104
42843: PPUSH
42844: LD_VAR 0 2
42848: PUSH
42849: LD_INT 1
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PPUSH
42856: EMPTY
42857: PPUSH
42858: CALL 71523 0 3
42862: ST_TO_ADDR
42863: GO 42935
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42865: LD_ADDR_EXP 104
42869: PUSH
42870: LD_EXP 104
42874: PPUSH
42875: LD_VAR 0 2
42879: PUSH
42880: LD_INT 1
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PPUSH
42887: LD_EXP 104
42891: PUSH
42892: LD_VAR 0 2
42896: ARRAY
42897: PUSH
42898: LD_INT 1
42900: ARRAY
42901: PPUSH
42902: LD_INT 3
42904: PUSH
42905: LD_INT 24
42907: PUSH
42908: LD_INT 1000
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PPUSH
42919: CALL_OW 72
42923: PUSH
42924: LD_VAR 0 6
42928: UNION
42929: PPUSH
42930: CALL 71523 0 3
42934: ST_TO_ADDR
// if not need_heal_2 then
42935: LD_VAR 0 7
42939: NOT
42940: IFFALSE 42973
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42942: LD_ADDR_EXP 104
42946: PUSH
42947: LD_EXP 104
42951: PPUSH
42952: LD_VAR 0 2
42956: PUSH
42957: LD_INT 2
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PPUSH
42964: EMPTY
42965: PPUSH
42966: CALL 71523 0 3
42970: ST_TO_ADDR
42971: GO 43005
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42973: LD_ADDR_EXP 104
42977: PUSH
42978: LD_EXP 104
42982: PPUSH
42983: LD_VAR 0 2
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PPUSH
42995: LD_VAR 0 7
42999: PPUSH
43000: CALL 71523 0 3
43004: ST_TO_ADDR
// if need_heal_2 then
43005: LD_VAR 0 7
43009: IFFALSE 43181
// for j in need_heal_2 do
43011: LD_ADDR_VAR 0 3
43015: PUSH
43016: LD_VAR 0 7
43020: PUSH
43021: FOR_IN
43022: IFFALSE 43179
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43024: LD_ADDR_VAR 0 5
43028: PUSH
43029: LD_EXP 101
43033: PUSH
43034: LD_VAR 0 2
43038: ARRAY
43039: PPUSH
43040: LD_INT 2
43042: PUSH
43043: LD_INT 30
43045: PUSH
43046: LD_INT 6
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 30
43055: PUSH
43056: LD_INT 7
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 30
43065: PUSH
43066: LD_INT 8
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 30
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 30
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 25
43095: PUSH
43096: LD_INT 4
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: PPUSH
43112: CALL_OW 72
43116: ST_TO_ADDR
// if tmp then
43117: LD_VAR 0 5
43121: IFFALSE 43177
// begin k := NearestUnitToUnit ( tmp , j ) ;
43123: LD_ADDR_VAR 0 4
43127: PUSH
43128: LD_VAR 0 5
43132: PPUSH
43133: LD_VAR 0 3
43137: PPUSH
43138: CALL_OW 74
43142: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43143: LD_VAR 0 3
43147: PPUSH
43148: LD_VAR 0 4
43152: PPUSH
43153: CALL_OW 296
43157: PUSH
43158: LD_INT 7
43160: GREATER
43161: IFFALSE 43177
// ComMoveUnit ( j , k ) ;
43163: LD_VAR 0 3
43167: PPUSH
43168: LD_VAR 0 4
43172: PPUSH
43173: CALL_OW 112
// end ; end ;
43177: GO 43021
43179: POP
43180: POP
// if not need_heal_1 and not need_heal_2 then
43181: LD_VAR 0 6
43185: NOT
43186: PUSH
43187: LD_VAR 0 7
43191: NOT
43192: AND
43193: IFFALSE 43197
// continue ;
43195: GO 42650
// end ;
43197: GO 42650
43199: POP
43200: POP
// RaiseSailEvent ( 102 ) ;
43201: LD_INT 102
43203: PPUSH
43204: CALL_OW 427
// end ;
43208: LD_VAR 0 1
43212: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43213: LD_INT 0
43215: PPUSH
43216: PPUSH
43217: PPUSH
43218: PPUSH
43219: PPUSH
43220: PPUSH
43221: PPUSH
43222: PPUSH
// if not mc_bases then
43223: LD_EXP 101
43227: NOT
43228: IFFALSE 43232
// exit ;
43230: GO 44072
// for i = 1 to mc_bases do
43232: LD_ADDR_VAR 0 2
43236: PUSH
43237: DOUBLE
43238: LD_INT 1
43240: DEC
43241: ST_TO_ADDR
43242: LD_EXP 101
43246: PUSH
43247: FOR_TO
43248: IFFALSE 44070
// begin if not mc_building_need_repair [ i ] then
43250: LD_EXP 102
43254: PUSH
43255: LD_VAR 0 2
43259: ARRAY
43260: NOT
43261: IFFALSE 43435
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43263: LD_ADDR_VAR 0 6
43267: PUSH
43268: LD_EXP 120
43272: PUSH
43273: LD_VAR 0 2
43277: ARRAY
43278: PPUSH
43279: LD_INT 3
43281: PUSH
43282: LD_INT 24
43284: PUSH
43285: LD_INT 1000
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: PUSH
43299: LD_INT 34
43301: PUSH
43302: LD_INT 13
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 34
43311: PUSH
43312: LD_INT 52
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: LIST
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PPUSH
43328: CALL_OW 72
43332: ST_TO_ADDR
// if cranes then
43333: LD_VAR 0 6
43337: IFFALSE 43399
// for j in cranes do
43339: LD_ADDR_VAR 0 3
43343: PUSH
43344: LD_VAR 0 6
43348: PUSH
43349: FOR_IN
43350: IFFALSE 43397
// if not IsInArea ( j , mc_parking [ i ] ) then
43352: LD_VAR 0 3
43356: PPUSH
43357: LD_EXP 125
43361: PUSH
43362: LD_VAR 0 2
43366: ARRAY
43367: PPUSH
43368: CALL_OW 308
43372: NOT
43373: IFFALSE 43395
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43375: LD_VAR 0 3
43379: PPUSH
43380: LD_EXP 125
43384: PUSH
43385: LD_VAR 0 2
43389: ARRAY
43390: PPUSH
43391: CALL_OW 113
43395: GO 43349
43397: POP
43398: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43399: LD_ADDR_EXP 103
43403: PUSH
43404: LD_EXP 103
43408: PPUSH
43409: LD_VAR 0 2
43413: PPUSH
43414: EMPTY
43415: PPUSH
43416: CALL_OW 1
43420: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43421: LD_VAR 0 2
43425: PPUSH
43426: LD_INT 101
43428: PPUSH
43429: CALL 38325 0 2
// continue ;
43433: GO 43247
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43435: LD_ADDR_EXP 107
43439: PUSH
43440: LD_EXP 107
43444: PPUSH
43445: LD_VAR 0 2
43449: PPUSH
43450: EMPTY
43451: PPUSH
43452: CALL_OW 1
43456: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43457: LD_VAR 0 2
43461: PPUSH
43462: LD_INT 103
43464: PPUSH
43465: CALL 38325 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43469: LD_ADDR_VAR 0 5
43473: PUSH
43474: LD_EXP 101
43478: PUSH
43479: LD_VAR 0 2
43483: ARRAY
43484: PUSH
43485: LD_EXP 130
43489: PUSH
43490: LD_VAR 0 2
43494: ARRAY
43495: UNION
43496: PPUSH
43497: LD_INT 2
43499: PUSH
43500: LD_INT 25
43502: PUSH
43503: LD_INT 2
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 25
43512: PUSH
43513: LD_INT 16
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: LIST
43524: PUSH
43525: EMPTY
43526: LIST
43527: PPUSH
43528: CALL_OW 72
43532: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43533: LD_ADDR_VAR 0 6
43537: PUSH
43538: LD_EXP 120
43542: PUSH
43543: LD_VAR 0 2
43547: ARRAY
43548: PPUSH
43549: LD_INT 2
43551: PUSH
43552: LD_INT 34
43554: PUSH
43555: LD_INT 13
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 34
43564: PUSH
43565: LD_INT 52
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: LIST
43576: PPUSH
43577: CALL_OW 72
43581: ST_TO_ADDR
// if cranes then
43582: LD_VAR 0 6
43586: IFFALSE 43722
// begin for j in cranes do
43588: LD_ADDR_VAR 0 3
43592: PUSH
43593: LD_VAR 0 6
43597: PUSH
43598: FOR_IN
43599: IFFALSE 43720
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43601: LD_VAR 0 3
43605: PPUSH
43606: CALL_OW 256
43610: PUSH
43611: LD_INT 500
43613: GREATEREQUAL
43614: PUSH
43615: LD_VAR 0 3
43619: PPUSH
43620: CALL_OW 314
43624: NOT
43625: AND
43626: IFFALSE 43660
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43628: LD_VAR 0 3
43632: PPUSH
43633: LD_EXP 102
43637: PUSH
43638: LD_VAR 0 2
43642: ARRAY
43643: PPUSH
43644: LD_VAR 0 3
43648: PPUSH
43649: CALL_OW 74
43653: PPUSH
43654: CALL_OW 130
43658: GO 43718
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43660: LD_VAR 0 3
43664: PPUSH
43665: CALL_OW 256
43669: PUSH
43670: LD_INT 500
43672: LESS
43673: PUSH
43674: LD_VAR 0 3
43678: PPUSH
43679: LD_EXP 125
43683: PUSH
43684: LD_VAR 0 2
43688: ARRAY
43689: PPUSH
43690: CALL_OW 308
43694: NOT
43695: AND
43696: IFFALSE 43718
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43698: LD_VAR 0 3
43702: PPUSH
43703: LD_EXP 125
43707: PUSH
43708: LD_VAR 0 2
43712: ARRAY
43713: PPUSH
43714: CALL_OW 113
43718: GO 43598
43720: POP
43721: POP
// end ; if not tmp then
43722: LD_VAR 0 5
43726: NOT
43727: IFFALSE 43731
// continue ;
43729: GO 43247
// for j in tmp do
43731: LD_ADDR_VAR 0 3
43735: PUSH
43736: LD_VAR 0 5
43740: PUSH
43741: FOR_IN
43742: IFFALSE 44066
// begin if mc_need_heal [ i ] then
43744: LD_EXP 104
43748: PUSH
43749: LD_VAR 0 2
43753: ARRAY
43754: IFFALSE 43802
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43756: LD_VAR 0 3
43760: PUSH
43761: LD_EXP 104
43765: PUSH
43766: LD_VAR 0 2
43770: ARRAY
43771: PUSH
43772: LD_INT 1
43774: ARRAY
43775: IN
43776: PUSH
43777: LD_VAR 0 3
43781: PUSH
43782: LD_EXP 104
43786: PUSH
43787: LD_VAR 0 2
43791: ARRAY
43792: PUSH
43793: LD_INT 2
43795: ARRAY
43796: IN
43797: OR
43798: IFFALSE 43802
// continue ;
43800: GO 43741
// if IsInUnit ( j ) then
43802: LD_VAR 0 3
43806: PPUSH
43807: CALL_OW 310
43811: IFFALSE 43822
// ComExitBuilding ( j ) ;
43813: LD_VAR 0 3
43817: PPUSH
43818: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43822: LD_VAR 0 3
43826: PUSH
43827: LD_EXP 103
43831: PUSH
43832: LD_VAR 0 2
43836: ARRAY
43837: IN
43838: NOT
43839: IFFALSE 43897
// begin SetTag ( j , 101 ) ;
43841: LD_VAR 0 3
43845: PPUSH
43846: LD_INT 101
43848: PPUSH
43849: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43853: LD_ADDR_EXP 103
43857: PUSH
43858: LD_EXP 103
43862: PPUSH
43863: LD_VAR 0 2
43867: PUSH
43868: LD_EXP 103
43872: PUSH
43873: LD_VAR 0 2
43877: ARRAY
43878: PUSH
43879: LD_INT 1
43881: PLUS
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PPUSH
43887: LD_VAR 0 3
43891: PPUSH
43892: CALL 71523 0 3
43896: ST_TO_ADDR
// end ; wait ( 1 ) ;
43897: LD_INT 1
43899: PPUSH
43900: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
43904: LD_ADDR_VAR 0 7
43908: PUSH
43909: LD_EXP 102
43913: PUSH
43914: LD_VAR 0 2
43918: ARRAY
43919: ST_TO_ADDR
// if mc_scan [ i ] then
43920: LD_EXP 124
43924: PUSH
43925: LD_VAR 0 2
43929: ARRAY
43930: IFFALSE 43999
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
43932: LD_ADDR_VAR 0 7
43936: PUSH
43937: LD_EXP 102
43941: PUSH
43942: LD_VAR 0 2
43946: ARRAY
43947: PPUSH
43948: LD_INT 3
43950: PUSH
43951: LD_INT 2
43953: PUSH
43954: LD_INT 30
43956: PUSH
43957: LD_INT 32
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 30
43966: PUSH
43967: LD_INT 33
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 30
43976: PUSH
43977: LD_INT 31
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PPUSH
43994: CALL_OW 72
43998: ST_TO_ADDR
// if not to_repair_tmp then
43999: LD_VAR 0 7
44003: NOT
44004: IFFALSE 44008
// continue ;
44006: GO 43741
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44008: LD_ADDR_VAR 0 8
44012: PUSH
44013: LD_VAR 0 7
44017: PPUSH
44018: LD_VAR 0 3
44022: PPUSH
44023: CALL_OW 74
44027: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44028: LD_VAR 0 8
44032: PPUSH
44033: LD_INT 14
44035: PPUSH
44036: CALL 74116 0 2
44040: PUSH
44041: LD_INT 4
44043: ARRAY
44044: PUSH
44045: LD_INT 5
44047: LESS
44048: IFFALSE 44064
// ComRepairBuilding ( j , to_repair ) ;
44050: LD_VAR 0 3
44054: PPUSH
44055: LD_VAR 0 8
44059: PPUSH
44060: CALL_OW 130
// end ;
44064: GO 43741
44066: POP
44067: POP
// end ;
44068: GO 43247
44070: POP
44071: POP
// end ;
44072: LD_VAR 0 1
44076: RET
// export function MC_Heal ; var i , j , tmp ; begin
44077: LD_INT 0
44079: PPUSH
44080: PPUSH
44081: PPUSH
44082: PPUSH
// if not mc_bases then
44083: LD_EXP 101
44087: NOT
44088: IFFALSE 44092
// exit ;
44090: GO 44494
// for i = 1 to mc_bases do
44092: LD_ADDR_VAR 0 2
44096: PUSH
44097: DOUBLE
44098: LD_INT 1
44100: DEC
44101: ST_TO_ADDR
44102: LD_EXP 101
44106: PUSH
44107: FOR_TO
44108: IFFALSE 44492
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44110: LD_EXP 104
44114: PUSH
44115: LD_VAR 0 2
44119: ARRAY
44120: PUSH
44121: LD_INT 1
44123: ARRAY
44124: NOT
44125: PUSH
44126: LD_EXP 104
44130: PUSH
44131: LD_VAR 0 2
44135: ARRAY
44136: PUSH
44137: LD_INT 2
44139: ARRAY
44140: NOT
44141: AND
44142: IFFALSE 44180
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44144: LD_ADDR_EXP 105
44148: PUSH
44149: LD_EXP 105
44153: PPUSH
44154: LD_VAR 0 2
44158: PPUSH
44159: EMPTY
44160: PPUSH
44161: CALL_OW 1
44165: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44166: LD_VAR 0 2
44170: PPUSH
44171: LD_INT 102
44173: PPUSH
44174: CALL 38325 0 2
// continue ;
44178: GO 44107
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44180: LD_ADDR_VAR 0 4
44184: PUSH
44185: LD_EXP 101
44189: PUSH
44190: LD_VAR 0 2
44194: ARRAY
44195: PPUSH
44196: LD_INT 25
44198: PUSH
44199: LD_INT 4
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: PPUSH
44206: CALL_OW 72
44210: ST_TO_ADDR
// if not tmp then
44211: LD_VAR 0 4
44215: NOT
44216: IFFALSE 44220
// continue ;
44218: GO 44107
// if mc_taming [ i ] then
44220: LD_EXP 132
44224: PUSH
44225: LD_VAR 0 2
44229: ARRAY
44230: IFFALSE 44254
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44232: LD_ADDR_EXP 132
44236: PUSH
44237: LD_EXP 132
44241: PPUSH
44242: LD_VAR 0 2
44246: PPUSH
44247: EMPTY
44248: PPUSH
44249: CALL_OW 1
44253: ST_TO_ADDR
// for j in tmp do
44254: LD_ADDR_VAR 0 3
44258: PUSH
44259: LD_VAR 0 4
44263: PUSH
44264: FOR_IN
44265: IFFALSE 44488
// begin if IsInUnit ( j ) then
44267: LD_VAR 0 3
44271: PPUSH
44272: CALL_OW 310
44276: IFFALSE 44287
// ComExitBuilding ( j ) ;
44278: LD_VAR 0 3
44282: PPUSH
44283: CALL_OW 122
// if not j in mc_healers [ i ] then
44287: LD_VAR 0 3
44291: PUSH
44292: LD_EXP 105
44296: PUSH
44297: LD_VAR 0 2
44301: ARRAY
44302: IN
44303: NOT
44304: IFFALSE 44350
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44306: LD_ADDR_EXP 105
44310: PUSH
44311: LD_EXP 105
44315: PPUSH
44316: LD_VAR 0 2
44320: PUSH
44321: LD_EXP 105
44325: PUSH
44326: LD_VAR 0 2
44330: ARRAY
44331: PUSH
44332: LD_INT 1
44334: PLUS
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PPUSH
44340: LD_VAR 0 3
44344: PPUSH
44345: CALL 71523 0 3
44349: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44350: LD_VAR 0 3
44354: PPUSH
44355: CALL_OW 110
44359: PUSH
44360: LD_INT 102
44362: NONEQUAL
44363: IFFALSE 44377
// SetTag ( j , 102 ) ;
44365: LD_VAR 0 3
44369: PPUSH
44370: LD_INT 102
44372: PPUSH
44373: CALL_OW 109
// Wait ( 3 ) ;
44377: LD_INT 3
44379: PPUSH
44380: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44384: LD_EXP 104
44388: PUSH
44389: LD_VAR 0 2
44393: ARRAY
44394: PUSH
44395: LD_INT 1
44397: ARRAY
44398: IFFALSE 44430
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44400: LD_VAR 0 3
44404: PPUSH
44405: LD_EXP 104
44409: PUSH
44410: LD_VAR 0 2
44414: ARRAY
44415: PUSH
44416: LD_INT 1
44418: ARRAY
44419: PUSH
44420: LD_INT 1
44422: ARRAY
44423: PPUSH
44424: CALL_OW 128
44428: GO 44486
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44430: LD_VAR 0 3
44434: PPUSH
44435: CALL_OW 314
44439: NOT
44440: PUSH
44441: LD_EXP 104
44445: PUSH
44446: LD_VAR 0 2
44450: ARRAY
44451: PUSH
44452: LD_INT 2
44454: ARRAY
44455: AND
44456: IFFALSE 44486
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44458: LD_VAR 0 3
44462: PPUSH
44463: LD_EXP 104
44467: PUSH
44468: LD_VAR 0 2
44472: ARRAY
44473: PUSH
44474: LD_INT 2
44476: ARRAY
44477: PUSH
44478: LD_INT 1
44480: ARRAY
44481: PPUSH
44482: CALL_OW 128
// end ;
44486: GO 44264
44488: POP
44489: POP
// end ;
44490: GO 44107
44492: POP
44493: POP
// end ;
44494: LD_VAR 0 1
44498: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44499: LD_INT 0
44501: PPUSH
44502: PPUSH
44503: PPUSH
44504: PPUSH
44505: PPUSH
// if not mc_bases then
44506: LD_EXP 101
44510: NOT
44511: IFFALSE 44515
// exit ;
44513: GO 45658
// for i = 1 to mc_bases do
44515: LD_ADDR_VAR 0 2
44519: PUSH
44520: DOUBLE
44521: LD_INT 1
44523: DEC
44524: ST_TO_ADDR
44525: LD_EXP 101
44529: PUSH
44530: FOR_TO
44531: IFFALSE 45656
// begin if mc_scan [ i ] then
44533: LD_EXP 124
44537: PUSH
44538: LD_VAR 0 2
44542: ARRAY
44543: IFFALSE 44547
// continue ;
44545: GO 44530
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44547: LD_EXP 106
44551: PUSH
44552: LD_VAR 0 2
44556: ARRAY
44557: NOT
44558: PUSH
44559: LD_EXP 108
44563: PUSH
44564: LD_VAR 0 2
44568: ARRAY
44569: NOT
44570: AND
44571: PUSH
44572: LD_EXP 107
44576: PUSH
44577: LD_VAR 0 2
44581: ARRAY
44582: AND
44583: IFFALSE 44621
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44585: LD_ADDR_EXP 107
44589: PUSH
44590: LD_EXP 107
44594: PPUSH
44595: LD_VAR 0 2
44599: PPUSH
44600: EMPTY
44601: PPUSH
44602: CALL_OW 1
44606: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44607: LD_VAR 0 2
44611: PPUSH
44612: LD_INT 103
44614: PPUSH
44615: CALL 38325 0 2
// continue ;
44619: GO 44530
// end ; if mc_construct_list [ i ] then
44621: LD_EXP 108
44625: PUSH
44626: LD_VAR 0 2
44630: ARRAY
44631: IFFALSE 44851
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44633: LD_ADDR_VAR 0 4
44637: PUSH
44638: LD_EXP 101
44642: PUSH
44643: LD_VAR 0 2
44647: ARRAY
44648: PPUSH
44649: LD_INT 25
44651: PUSH
44652: LD_INT 2
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PPUSH
44659: CALL_OW 72
44663: PUSH
44664: LD_EXP 103
44668: PUSH
44669: LD_VAR 0 2
44673: ARRAY
44674: DIFF
44675: ST_TO_ADDR
// if not tmp then
44676: LD_VAR 0 4
44680: NOT
44681: IFFALSE 44685
// continue ;
44683: GO 44530
// for j in tmp do
44685: LD_ADDR_VAR 0 3
44689: PUSH
44690: LD_VAR 0 4
44694: PUSH
44695: FOR_IN
44696: IFFALSE 44847
// begin if not mc_builders [ i ] then
44698: LD_EXP 107
44702: PUSH
44703: LD_VAR 0 2
44707: ARRAY
44708: NOT
44709: IFFALSE 44767
// begin SetTag ( j , 103 ) ;
44711: LD_VAR 0 3
44715: PPUSH
44716: LD_INT 103
44718: PPUSH
44719: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44723: LD_ADDR_EXP 107
44727: PUSH
44728: LD_EXP 107
44732: PPUSH
44733: LD_VAR 0 2
44737: PUSH
44738: LD_EXP 107
44742: PUSH
44743: LD_VAR 0 2
44747: ARRAY
44748: PUSH
44749: LD_INT 1
44751: PLUS
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PPUSH
44757: LD_VAR 0 3
44761: PPUSH
44762: CALL 71523 0 3
44766: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44767: LD_VAR 0 3
44771: PPUSH
44772: CALL_OW 310
44776: IFFALSE 44787
// ComExitBuilding ( j ) ;
44778: LD_VAR 0 3
44782: PPUSH
44783: CALL_OW 122
// wait ( 3 ) ;
44787: LD_INT 3
44789: PPUSH
44790: CALL_OW 67
// if not mc_construct_list [ i ] then
44794: LD_EXP 108
44798: PUSH
44799: LD_VAR 0 2
44803: ARRAY
44804: NOT
44805: IFFALSE 44809
// break ;
44807: GO 44847
// if not HasTask ( j ) then
44809: LD_VAR 0 3
44813: PPUSH
44814: CALL_OW 314
44818: NOT
44819: IFFALSE 44845
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44821: LD_VAR 0 3
44825: PPUSH
44826: LD_EXP 108
44830: PUSH
44831: LD_VAR 0 2
44835: ARRAY
44836: PUSH
44837: LD_INT 1
44839: ARRAY
44840: PPUSH
44841: CALL 74374 0 2
// end ;
44845: GO 44695
44847: POP
44848: POP
// end else
44849: GO 45654
// if mc_build_list [ i ] then
44851: LD_EXP 106
44855: PUSH
44856: LD_VAR 0 2
44860: ARRAY
44861: IFFALSE 45654
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44863: LD_ADDR_VAR 0 5
44867: PUSH
44868: LD_EXP 101
44872: PUSH
44873: LD_VAR 0 2
44877: ARRAY
44878: PPUSH
44879: LD_INT 2
44881: PUSH
44882: LD_INT 30
44884: PUSH
44885: LD_INT 0
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 30
44894: PUSH
44895: LD_INT 1
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: LIST
44906: PPUSH
44907: CALL_OW 72
44911: ST_TO_ADDR
// if depot then
44912: LD_VAR 0 5
44916: IFFALSE 44934
// depot := depot [ 1 ] else
44918: LD_ADDR_VAR 0 5
44922: PUSH
44923: LD_VAR 0 5
44927: PUSH
44928: LD_INT 1
44930: ARRAY
44931: ST_TO_ADDR
44932: GO 44942
// depot := 0 ;
44934: LD_ADDR_VAR 0 5
44938: PUSH
44939: LD_INT 0
44941: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44942: LD_EXP 106
44946: PUSH
44947: LD_VAR 0 2
44951: ARRAY
44952: PUSH
44953: LD_INT 1
44955: ARRAY
44956: PUSH
44957: LD_INT 1
44959: ARRAY
44960: PPUSH
44961: CALL 74204 0 1
44965: PUSH
44966: LD_EXP 101
44970: PUSH
44971: LD_VAR 0 2
44975: ARRAY
44976: PPUSH
44977: LD_INT 2
44979: PUSH
44980: LD_INT 30
44982: PUSH
44983: LD_INT 2
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 30
44992: PUSH
44993: LD_INT 3
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: LIST
45004: PPUSH
45005: CALL_OW 72
45009: NOT
45010: AND
45011: IFFALSE 45116
// begin for j = 1 to mc_build_list [ i ] do
45013: LD_ADDR_VAR 0 3
45017: PUSH
45018: DOUBLE
45019: LD_INT 1
45021: DEC
45022: ST_TO_ADDR
45023: LD_EXP 106
45027: PUSH
45028: LD_VAR 0 2
45032: ARRAY
45033: PUSH
45034: FOR_TO
45035: IFFALSE 45114
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45037: LD_EXP 106
45041: PUSH
45042: LD_VAR 0 2
45046: ARRAY
45047: PUSH
45048: LD_VAR 0 3
45052: ARRAY
45053: PUSH
45054: LD_INT 1
45056: ARRAY
45057: PUSH
45058: LD_INT 2
45060: EQUAL
45061: IFFALSE 45112
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45063: LD_ADDR_EXP 106
45067: PUSH
45068: LD_EXP 106
45072: PPUSH
45073: LD_VAR 0 2
45077: PPUSH
45078: LD_EXP 106
45082: PUSH
45083: LD_VAR 0 2
45087: ARRAY
45088: PPUSH
45089: LD_VAR 0 3
45093: PPUSH
45094: LD_INT 1
45096: PPUSH
45097: LD_INT 0
45099: PPUSH
45100: CALL 70941 0 4
45104: PPUSH
45105: CALL_OW 1
45109: ST_TO_ADDR
// break ;
45110: GO 45114
// end ;
45112: GO 45034
45114: POP
45115: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45116: LD_EXP 106
45120: PUSH
45121: LD_VAR 0 2
45125: ARRAY
45126: PUSH
45127: LD_INT 1
45129: ARRAY
45130: PUSH
45131: LD_INT 1
45133: ARRAY
45134: PUSH
45135: LD_INT 0
45137: EQUAL
45138: PUSH
45139: LD_VAR 0 5
45143: PUSH
45144: LD_VAR 0 5
45148: PPUSH
45149: LD_EXP 106
45153: PUSH
45154: LD_VAR 0 2
45158: ARRAY
45159: PUSH
45160: LD_INT 1
45162: ARRAY
45163: PUSH
45164: LD_INT 1
45166: ARRAY
45167: PPUSH
45168: LD_EXP 106
45172: PUSH
45173: LD_VAR 0 2
45177: ARRAY
45178: PUSH
45179: LD_INT 1
45181: ARRAY
45182: PUSH
45183: LD_INT 2
45185: ARRAY
45186: PPUSH
45187: LD_EXP 106
45191: PUSH
45192: LD_VAR 0 2
45196: ARRAY
45197: PUSH
45198: LD_INT 1
45200: ARRAY
45201: PUSH
45202: LD_INT 3
45204: ARRAY
45205: PPUSH
45206: LD_EXP 106
45210: PUSH
45211: LD_VAR 0 2
45215: ARRAY
45216: PUSH
45217: LD_INT 1
45219: ARRAY
45220: PUSH
45221: LD_INT 4
45223: ARRAY
45224: PPUSH
45225: CALL 78938 0 5
45229: AND
45230: OR
45231: IFFALSE 45512
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45233: LD_ADDR_VAR 0 4
45237: PUSH
45238: LD_EXP 101
45242: PUSH
45243: LD_VAR 0 2
45247: ARRAY
45248: PPUSH
45249: LD_INT 25
45251: PUSH
45252: LD_INT 2
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PPUSH
45259: CALL_OW 72
45263: PUSH
45264: LD_EXP 103
45268: PUSH
45269: LD_VAR 0 2
45273: ARRAY
45274: DIFF
45275: ST_TO_ADDR
// if not tmp then
45276: LD_VAR 0 4
45280: NOT
45281: IFFALSE 45285
// continue ;
45283: GO 44530
// for j in tmp do
45285: LD_ADDR_VAR 0 3
45289: PUSH
45290: LD_VAR 0 4
45294: PUSH
45295: FOR_IN
45296: IFFALSE 45508
// begin if not mc_builders [ i ] then
45298: LD_EXP 107
45302: PUSH
45303: LD_VAR 0 2
45307: ARRAY
45308: NOT
45309: IFFALSE 45367
// begin SetTag ( j , 103 ) ;
45311: LD_VAR 0 3
45315: PPUSH
45316: LD_INT 103
45318: PPUSH
45319: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45323: LD_ADDR_EXP 107
45327: PUSH
45328: LD_EXP 107
45332: PPUSH
45333: LD_VAR 0 2
45337: PUSH
45338: LD_EXP 107
45342: PUSH
45343: LD_VAR 0 2
45347: ARRAY
45348: PUSH
45349: LD_INT 1
45351: PLUS
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PPUSH
45357: LD_VAR 0 3
45361: PPUSH
45362: CALL 71523 0 3
45366: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45367: LD_VAR 0 3
45371: PPUSH
45372: CALL_OW 310
45376: IFFALSE 45387
// ComExitBuilding ( j ) ;
45378: LD_VAR 0 3
45382: PPUSH
45383: CALL_OW 122
// wait ( 3 ) ;
45387: LD_INT 3
45389: PPUSH
45390: CALL_OW 67
// if not mc_build_list [ i ] then
45394: LD_EXP 106
45398: PUSH
45399: LD_VAR 0 2
45403: ARRAY
45404: NOT
45405: IFFALSE 45409
// break ;
45407: GO 45508
// if not HasTask ( j ) then
45409: LD_VAR 0 3
45413: PPUSH
45414: CALL_OW 314
45418: NOT
45419: IFFALSE 45506
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45421: LD_VAR 0 3
45425: PPUSH
45426: LD_EXP 106
45430: PUSH
45431: LD_VAR 0 2
45435: ARRAY
45436: PUSH
45437: LD_INT 1
45439: ARRAY
45440: PUSH
45441: LD_INT 1
45443: ARRAY
45444: PPUSH
45445: LD_EXP 106
45449: PUSH
45450: LD_VAR 0 2
45454: ARRAY
45455: PUSH
45456: LD_INT 1
45458: ARRAY
45459: PUSH
45460: LD_INT 2
45462: ARRAY
45463: PPUSH
45464: LD_EXP 106
45468: PUSH
45469: LD_VAR 0 2
45473: ARRAY
45474: PUSH
45475: LD_INT 1
45477: ARRAY
45478: PUSH
45479: LD_INT 3
45481: ARRAY
45482: PPUSH
45483: LD_EXP 106
45487: PUSH
45488: LD_VAR 0 2
45492: ARRAY
45493: PUSH
45494: LD_INT 1
45496: ARRAY
45497: PUSH
45498: LD_INT 4
45500: ARRAY
45501: PPUSH
45502: CALL_OW 145
// end ;
45506: GO 45295
45508: POP
45509: POP
// end else
45510: GO 45654
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45512: LD_EXP 101
45516: PUSH
45517: LD_VAR 0 2
45521: ARRAY
45522: PPUSH
45523: LD_EXP 106
45527: PUSH
45528: LD_VAR 0 2
45532: ARRAY
45533: PUSH
45534: LD_INT 1
45536: ARRAY
45537: PUSH
45538: LD_INT 1
45540: ARRAY
45541: PPUSH
45542: LD_EXP 106
45546: PUSH
45547: LD_VAR 0 2
45551: ARRAY
45552: PUSH
45553: LD_INT 1
45555: ARRAY
45556: PUSH
45557: LD_INT 2
45559: ARRAY
45560: PPUSH
45561: LD_EXP 106
45565: PUSH
45566: LD_VAR 0 2
45570: ARRAY
45571: PUSH
45572: LD_INT 1
45574: ARRAY
45575: PUSH
45576: LD_INT 3
45578: ARRAY
45579: PPUSH
45580: LD_EXP 106
45584: PUSH
45585: LD_VAR 0 2
45589: ARRAY
45590: PUSH
45591: LD_INT 1
45593: ARRAY
45594: PUSH
45595: LD_INT 4
45597: ARRAY
45598: PPUSH
45599: CALL 78274 0 5
45603: NOT
45604: IFFALSE 45654
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45606: LD_ADDR_EXP 106
45610: PUSH
45611: LD_EXP 106
45615: PPUSH
45616: LD_VAR 0 2
45620: PPUSH
45621: LD_EXP 106
45625: PUSH
45626: LD_VAR 0 2
45630: ARRAY
45631: PPUSH
45632: LD_INT 1
45634: PPUSH
45635: LD_INT 1
45637: NEG
45638: PPUSH
45639: LD_INT 0
45641: PPUSH
45642: CALL 70941 0 4
45646: PPUSH
45647: CALL_OW 1
45651: ST_TO_ADDR
// continue ;
45652: GO 44530
// end ; end ; end ;
45654: GO 44530
45656: POP
45657: POP
// end ;
45658: LD_VAR 0 1
45662: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45663: LD_INT 0
45665: PPUSH
45666: PPUSH
45667: PPUSH
45668: PPUSH
45669: PPUSH
45670: PPUSH
// if not mc_bases then
45671: LD_EXP 101
45675: NOT
45676: IFFALSE 45680
// exit ;
45678: GO 46107
// for i = 1 to mc_bases do
45680: LD_ADDR_VAR 0 2
45684: PUSH
45685: DOUBLE
45686: LD_INT 1
45688: DEC
45689: ST_TO_ADDR
45690: LD_EXP 101
45694: PUSH
45695: FOR_TO
45696: IFFALSE 46105
// begin tmp := mc_build_upgrade [ i ] ;
45698: LD_ADDR_VAR 0 4
45702: PUSH
45703: LD_EXP 133
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45714: LD_ADDR_VAR 0 6
45718: PUSH
45719: LD_EXP 134
45723: PUSH
45724: LD_VAR 0 2
45728: ARRAY
45729: PPUSH
45730: LD_INT 2
45732: PUSH
45733: LD_INT 30
45735: PUSH
45736: LD_INT 6
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: PUSH
45743: LD_INT 30
45745: PUSH
45746: LD_INT 7
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: LIST
45757: PPUSH
45758: CALL_OW 72
45762: ST_TO_ADDR
// if not tmp and not lab then
45763: LD_VAR 0 4
45767: NOT
45768: PUSH
45769: LD_VAR 0 6
45773: NOT
45774: AND
45775: IFFALSE 45779
// continue ;
45777: GO 45695
// if tmp then
45779: LD_VAR 0 4
45783: IFFALSE 45903
// for j in tmp do
45785: LD_ADDR_VAR 0 3
45789: PUSH
45790: LD_VAR 0 4
45794: PUSH
45795: FOR_IN
45796: IFFALSE 45901
// begin if UpgradeCost ( j ) then
45798: LD_VAR 0 3
45802: PPUSH
45803: CALL 77934 0 1
45807: IFFALSE 45899
// begin ComUpgrade ( j ) ;
45809: LD_VAR 0 3
45813: PPUSH
45814: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45818: LD_ADDR_EXP 133
45822: PUSH
45823: LD_EXP 133
45827: PPUSH
45828: LD_VAR 0 2
45832: PPUSH
45833: LD_EXP 133
45837: PUSH
45838: LD_VAR 0 2
45842: ARRAY
45843: PUSH
45844: LD_VAR 0 3
45848: DIFF
45849: PPUSH
45850: CALL_OW 1
45854: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45855: LD_ADDR_EXP 108
45859: PUSH
45860: LD_EXP 108
45864: PPUSH
45865: LD_VAR 0 2
45869: PUSH
45870: LD_EXP 108
45874: PUSH
45875: LD_VAR 0 2
45879: ARRAY
45880: PUSH
45881: LD_INT 1
45883: PLUS
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PPUSH
45889: LD_VAR 0 3
45893: PPUSH
45894: CALL 71523 0 3
45898: ST_TO_ADDR
// end ; end ;
45899: GO 45795
45901: POP
45902: POP
// if not lab or not mc_lab_upgrade [ i ] then
45903: LD_VAR 0 6
45907: NOT
45908: PUSH
45909: LD_EXP 135
45913: PUSH
45914: LD_VAR 0 2
45918: ARRAY
45919: NOT
45920: OR
45921: IFFALSE 45925
// continue ;
45923: GO 45695
// for j in lab do
45925: LD_ADDR_VAR 0 3
45929: PUSH
45930: LD_VAR 0 6
45934: PUSH
45935: FOR_IN
45936: IFFALSE 46101
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45938: LD_VAR 0 3
45942: PPUSH
45943: CALL_OW 266
45947: PUSH
45948: LD_INT 6
45950: PUSH
45951: LD_INT 7
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: IN
45958: PUSH
45959: LD_VAR 0 3
45963: PPUSH
45964: CALL_OW 461
45968: PUSH
45969: LD_INT 1
45971: NONEQUAL
45972: AND
45973: IFFALSE 46099
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45975: LD_VAR 0 3
45979: PPUSH
45980: LD_EXP 135
45984: PUSH
45985: LD_VAR 0 2
45989: ARRAY
45990: PUSH
45991: LD_INT 1
45993: ARRAY
45994: PPUSH
45995: CALL 78139 0 2
45999: IFFALSE 46099
// begin ComCancel ( j ) ;
46001: LD_VAR 0 3
46005: PPUSH
46006: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46010: LD_VAR 0 3
46014: PPUSH
46015: LD_EXP 135
46019: PUSH
46020: LD_VAR 0 2
46024: ARRAY
46025: PUSH
46026: LD_INT 1
46028: ARRAY
46029: PPUSH
46030: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46034: LD_VAR 0 3
46038: PUSH
46039: LD_EXP 108
46043: PUSH
46044: LD_VAR 0 2
46048: ARRAY
46049: IN
46050: NOT
46051: IFFALSE 46097
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46053: LD_ADDR_EXP 108
46057: PUSH
46058: LD_EXP 108
46062: PPUSH
46063: LD_VAR 0 2
46067: PUSH
46068: LD_EXP 108
46072: PUSH
46073: LD_VAR 0 2
46077: ARRAY
46078: PUSH
46079: LD_INT 1
46081: PLUS
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PPUSH
46087: LD_VAR 0 3
46091: PPUSH
46092: CALL 71523 0 3
46096: ST_TO_ADDR
// break ;
46097: GO 46101
// end ; end ; end ;
46099: GO 45935
46101: POP
46102: POP
// end ;
46103: GO 45695
46105: POP
46106: POP
// end ;
46107: LD_VAR 0 1
46111: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46112: LD_INT 0
46114: PPUSH
46115: PPUSH
46116: PPUSH
46117: PPUSH
46118: PPUSH
46119: PPUSH
46120: PPUSH
46121: PPUSH
46122: PPUSH
// if not mc_bases then
46123: LD_EXP 101
46127: NOT
46128: IFFALSE 46132
// exit ;
46130: GO 46537
// for i = 1 to mc_bases do
46132: LD_ADDR_VAR 0 2
46136: PUSH
46137: DOUBLE
46138: LD_INT 1
46140: DEC
46141: ST_TO_ADDR
46142: LD_EXP 101
46146: PUSH
46147: FOR_TO
46148: IFFALSE 46535
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46150: LD_EXP 109
46154: PUSH
46155: LD_VAR 0 2
46159: ARRAY
46160: NOT
46161: PUSH
46162: LD_EXP 101
46166: PUSH
46167: LD_VAR 0 2
46171: ARRAY
46172: PPUSH
46173: LD_INT 30
46175: PUSH
46176: LD_INT 3
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PPUSH
46183: CALL_OW 72
46187: NOT
46188: OR
46189: IFFALSE 46193
// continue ;
46191: GO 46147
// busy := false ;
46193: LD_ADDR_VAR 0 8
46197: PUSH
46198: LD_INT 0
46200: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46201: LD_ADDR_VAR 0 4
46205: PUSH
46206: LD_EXP 101
46210: PUSH
46211: LD_VAR 0 2
46215: ARRAY
46216: PPUSH
46217: LD_INT 30
46219: PUSH
46220: LD_INT 3
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PPUSH
46227: CALL_OW 72
46231: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46232: LD_ADDR_VAR 0 6
46236: PUSH
46237: LD_EXP 109
46241: PUSH
46242: LD_VAR 0 2
46246: ARRAY
46247: PPUSH
46248: LD_INT 2
46250: PUSH
46251: LD_INT 30
46253: PUSH
46254: LD_INT 32
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 30
46263: PUSH
46264: LD_INT 33
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: EMPTY
46272: LIST
46273: LIST
46274: LIST
46275: PPUSH
46276: CALL_OW 72
46280: ST_TO_ADDR
// if not t then
46281: LD_VAR 0 6
46285: NOT
46286: IFFALSE 46290
// continue ;
46288: GO 46147
// for j in tmp do
46290: LD_ADDR_VAR 0 3
46294: PUSH
46295: LD_VAR 0 4
46299: PUSH
46300: FOR_IN
46301: IFFALSE 46331
// if not BuildingStatus ( j ) = bs_idle then
46303: LD_VAR 0 3
46307: PPUSH
46308: CALL_OW 461
46312: PUSH
46313: LD_INT 2
46315: EQUAL
46316: NOT
46317: IFFALSE 46329
// begin busy := true ;
46319: LD_ADDR_VAR 0 8
46323: PUSH
46324: LD_INT 1
46326: ST_TO_ADDR
// break ;
46327: GO 46331
// end ;
46329: GO 46300
46331: POP
46332: POP
// if busy then
46333: LD_VAR 0 8
46337: IFFALSE 46341
// continue ;
46339: GO 46147
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46341: LD_ADDR_VAR 0 7
46345: PUSH
46346: LD_VAR 0 6
46350: PPUSH
46351: LD_INT 35
46353: PUSH
46354: LD_INT 0
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PPUSH
46361: CALL_OW 72
46365: ST_TO_ADDR
// if tw then
46366: LD_VAR 0 7
46370: IFFALSE 46447
// begin tw := tw [ 1 ] ;
46372: LD_ADDR_VAR 0 7
46376: PUSH
46377: LD_VAR 0 7
46381: PUSH
46382: LD_INT 1
46384: ARRAY
46385: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46386: LD_ADDR_VAR 0 9
46390: PUSH
46391: LD_VAR 0 7
46395: PPUSH
46396: LD_EXP 126
46400: PUSH
46401: LD_VAR 0 2
46405: ARRAY
46406: PPUSH
46407: CALL 76493 0 2
46411: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46412: LD_EXP 140
46416: PUSH
46417: LD_VAR 0 2
46421: ARRAY
46422: IFFALSE 46445
// if not weapon in mc_allowed_tower_weapons [ i ] then
46424: LD_VAR 0 9
46428: PUSH
46429: LD_EXP 140
46433: PUSH
46434: LD_VAR 0 2
46438: ARRAY
46439: IN
46440: NOT
46441: IFFALSE 46445
// continue ;
46443: GO 46147
// end else
46445: GO 46510
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46447: LD_ADDR_VAR 0 5
46451: PUSH
46452: LD_EXP 109
46456: PUSH
46457: LD_VAR 0 2
46461: ARRAY
46462: PPUSH
46463: LD_VAR 0 4
46467: PPUSH
46468: CALL 106697 0 2
46472: ST_TO_ADDR
// if not tmp2 then
46473: LD_VAR 0 5
46477: NOT
46478: IFFALSE 46482
// continue ;
46480: GO 46147
// tw := tmp2 [ 1 ] ;
46482: LD_ADDR_VAR 0 7
46486: PUSH
46487: LD_VAR 0 5
46491: PUSH
46492: LD_INT 1
46494: ARRAY
46495: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46496: LD_ADDR_VAR 0 9
46500: PUSH
46501: LD_VAR 0 5
46505: PUSH
46506: LD_INT 2
46508: ARRAY
46509: ST_TO_ADDR
// end ; if not weapon then
46510: LD_VAR 0 9
46514: NOT
46515: IFFALSE 46519
// continue ;
46517: GO 46147
// ComPlaceWeapon ( tw , weapon ) ;
46519: LD_VAR 0 7
46523: PPUSH
46524: LD_VAR 0 9
46528: PPUSH
46529: CALL_OW 148
// end ;
46533: GO 46147
46535: POP
46536: POP
// end ;
46537: LD_VAR 0 1
46541: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46542: LD_INT 0
46544: PPUSH
46545: PPUSH
46546: PPUSH
46547: PPUSH
46548: PPUSH
46549: PPUSH
// if not mc_bases then
46550: LD_EXP 101
46554: NOT
46555: IFFALSE 46559
// exit ;
46557: GO 47335
// for i = 1 to mc_bases do
46559: LD_ADDR_VAR 0 2
46563: PUSH
46564: DOUBLE
46565: LD_INT 1
46567: DEC
46568: ST_TO_ADDR
46569: LD_EXP 101
46573: PUSH
46574: FOR_TO
46575: IFFALSE 47333
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
46577: LD_EXP 114
46581: PUSH
46582: LD_VAR 0 2
46586: ARRAY
46587: NOT
46588: PUSH
46589: LD_EXP 114
46593: PUSH
46594: LD_VAR 0 2
46598: ARRAY
46599: PUSH
46600: LD_EXP 115
46604: PUSH
46605: LD_VAR 0 2
46609: ARRAY
46610: EQUAL
46611: OR
46612: PUSH
46613: LD_EXP 124
46617: PUSH
46618: LD_VAR 0 2
46622: ARRAY
46623: OR
46624: IFFALSE 46628
// continue ;
46626: GO 46574
// if mc_miners [ i ] then
46628: LD_EXP 115
46632: PUSH
46633: LD_VAR 0 2
46637: ARRAY
46638: IFFALSE 47020
// begin for j = mc_miners [ i ] downto 1 do
46640: LD_ADDR_VAR 0 3
46644: PUSH
46645: DOUBLE
46646: LD_EXP 115
46650: PUSH
46651: LD_VAR 0 2
46655: ARRAY
46656: INC
46657: ST_TO_ADDR
46658: LD_INT 1
46660: PUSH
46661: FOR_DOWNTO
46662: IFFALSE 47018
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46664: LD_EXP 115
46668: PUSH
46669: LD_VAR 0 2
46673: ARRAY
46674: PUSH
46675: LD_VAR 0 3
46679: ARRAY
46680: PPUSH
46681: CALL_OW 301
46685: PUSH
46686: LD_EXP 115
46690: PUSH
46691: LD_VAR 0 2
46695: ARRAY
46696: PUSH
46697: LD_VAR 0 3
46701: ARRAY
46702: PPUSH
46703: CALL_OW 257
46707: PUSH
46708: LD_INT 1
46710: NONEQUAL
46711: OR
46712: IFFALSE 46775
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46714: LD_ADDR_VAR 0 5
46718: PUSH
46719: LD_EXP 115
46723: PUSH
46724: LD_VAR 0 2
46728: ARRAY
46729: PUSH
46730: LD_EXP 115
46734: PUSH
46735: LD_VAR 0 2
46739: ARRAY
46740: PUSH
46741: LD_VAR 0 3
46745: ARRAY
46746: DIFF
46747: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46748: LD_ADDR_EXP 115
46752: PUSH
46753: LD_EXP 115
46757: PPUSH
46758: LD_VAR 0 2
46762: PPUSH
46763: LD_VAR 0 5
46767: PPUSH
46768: CALL_OW 1
46772: ST_TO_ADDR
// continue ;
46773: GO 46661
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
46775: LD_EXP 115
46779: PUSH
46780: LD_VAR 0 2
46784: ARRAY
46785: PUSH
46786: LD_VAR 0 3
46790: ARRAY
46791: PPUSH
46792: CALL_OW 257
46796: PUSH
46797: LD_INT 1
46799: EQUAL
46800: PUSH
46801: LD_EXP 115
46805: PUSH
46806: LD_VAR 0 2
46810: ARRAY
46811: PUSH
46812: LD_VAR 0 3
46816: ARRAY
46817: PPUSH
46818: CALL_OW 459
46822: NOT
46823: AND
46824: PUSH
46825: LD_EXP 115
46829: PUSH
46830: LD_VAR 0 2
46834: ARRAY
46835: PUSH
46836: LD_VAR 0 3
46840: ARRAY
46841: PPUSH
46842: CALL_OW 314
46846: NOT
46847: AND
46848: IFFALSE 47016
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46850: LD_EXP 115
46854: PUSH
46855: LD_VAR 0 2
46859: ARRAY
46860: PUSH
46861: LD_VAR 0 3
46865: ARRAY
46866: PPUSH
46867: CALL_OW 310
46871: IFFALSE 46894
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46873: LD_EXP 115
46877: PUSH
46878: LD_VAR 0 2
46882: ARRAY
46883: PUSH
46884: LD_VAR 0 3
46888: ARRAY
46889: PPUSH
46890: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46894: LD_EXP 115
46898: PUSH
46899: LD_VAR 0 2
46903: ARRAY
46904: PUSH
46905: LD_VAR 0 3
46909: ARRAY
46910: PPUSH
46911: CALL_OW 314
46915: NOT
46916: IFFALSE 47016
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
46918: LD_EXP 115
46922: PUSH
46923: LD_VAR 0 2
46927: ARRAY
46928: PUSH
46929: LD_VAR 0 3
46933: ARRAY
46934: PPUSH
46935: LD_EXP 114
46939: PUSH
46940: LD_VAR 0 2
46944: ARRAY
46945: PUSH
46946: LD_VAR 0 3
46950: PUSH
46951: LD_EXP 114
46955: PUSH
46956: LD_VAR 0 2
46960: ARRAY
46961: MOD
46962: PUSH
46963: LD_INT 1
46965: PLUS
46966: ARRAY
46967: PUSH
46968: LD_INT 1
46970: ARRAY
46971: PPUSH
46972: LD_EXP 114
46976: PUSH
46977: LD_VAR 0 2
46981: ARRAY
46982: PUSH
46983: LD_VAR 0 3
46987: PUSH
46988: LD_EXP 114
46992: PUSH
46993: LD_VAR 0 2
46997: ARRAY
46998: MOD
46999: PUSH
47000: LD_INT 1
47002: PLUS
47003: ARRAY
47004: PUSH
47005: LD_INT 2
47007: ARRAY
47008: PPUSH
47009: LD_INT 0
47011: PPUSH
47012: CALL_OW 193
// end ; end ;
47016: GO 46661
47018: POP
47019: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47020: LD_ADDR_VAR 0 5
47024: PUSH
47025: LD_EXP 101
47029: PUSH
47030: LD_VAR 0 2
47034: ARRAY
47035: PPUSH
47036: LD_INT 2
47038: PUSH
47039: LD_INT 30
47041: PUSH
47042: LD_INT 4
47044: PUSH
47045: EMPTY
47046: LIST
47047: LIST
47048: PUSH
47049: LD_INT 30
47051: PUSH
47052: LD_INT 5
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: PUSH
47059: LD_INT 30
47061: PUSH
47062: LD_INT 32
47064: PUSH
47065: EMPTY
47066: LIST
47067: LIST
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: PPUSH
47075: CALL_OW 72
47079: ST_TO_ADDR
// if not tmp then
47080: LD_VAR 0 5
47084: NOT
47085: IFFALSE 47089
// continue ;
47087: GO 46574
// list := [ ] ;
47089: LD_ADDR_VAR 0 6
47093: PUSH
47094: EMPTY
47095: ST_TO_ADDR
// for j in tmp do
47096: LD_ADDR_VAR 0 3
47100: PUSH
47101: LD_VAR 0 5
47105: PUSH
47106: FOR_IN
47107: IFFALSE 47176
// begin for k in UnitsInside ( j ) do
47109: LD_ADDR_VAR 0 4
47113: PUSH
47114: LD_VAR 0 3
47118: PPUSH
47119: CALL_OW 313
47123: PUSH
47124: FOR_IN
47125: IFFALSE 47172
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47127: LD_VAR 0 4
47131: PPUSH
47132: CALL_OW 257
47136: PUSH
47137: LD_INT 1
47139: EQUAL
47140: PUSH
47141: LD_VAR 0 4
47145: PPUSH
47146: CALL_OW 459
47150: NOT
47151: AND
47152: IFFALSE 47170
// list := list ^ k ;
47154: LD_ADDR_VAR 0 6
47158: PUSH
47159: LD_VAR 0 6
47163: PUSH
47164: LD_VAR 0 4
47168: ADD
47169: ST_TO_ADDR
47170: GO 47124
47172: POP
47173: POP
// end ;
47174: GO 47106
47176: POP
47177: POP
// list := list diff mc_miners [ i ] ;
47178: LD_ADDR_VAR 0 6
47182: PUSH
47183: LD_VAR 0 6
47187: PUSH
47188: LD_EXP 115
47192: PUSH
47193: LD_VAR 0 2
47197: ARRAY
47198: DIFF
47199: ST_TO_ADDR
// if not list then
47200: LD_VAR 0 6
47204: NOT
47205: IFFALSE 47209
// continue ;
47207: GO 46574
// k := mc_mines [ i ] - mc_miners [ i ] ;
47209: LD_ADDR_VAR 0 4
47213: PUSH
47214: LD_EXP 114
47218: PUSH
47219: LD_VAR 0 2
47223: ARRAY
47224: PUSH
47225: LD_EXP 115
47229: PUSH
47230: LD_VAR 0 2
47234: ARRAY
47235: MINUS
47236: ST_TO_ADDR
// if k > list then
47237: LD_VAR 0 4
47241: PUSH
47242: LD_VAR 0 6
47246: GREATER
47247: IFFALSE 47259
// k := list ;
47249: LD_ADDR_VAR 0 4
47253: PUSH
47254: LD_VAR 0 6
47258: ST_TO_ADDR
// for j = 1 to k do
47259: LD_ADDR_VAR 0 3
47263: PUSH
47264: DOUBLE
47265: LD_INT 1
47267: DEC
47268: ST_TO_ADDR
47269: LD_VAR 0 4
47273: PUSH
47274: FOR_TO
47275: IFFALSE 47329
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47277: LD_ADDR_EXP 115
47281: PUSH
47282: LD_EXP 115
47286: PPUSH
47287: LD_VAR 0 2
47291: PUSH
47292: LD_EXP 115
47296: PUSH
47297: LD_VAR 0 2
47301: ARRAY
47302: PUSH
47303: LD_INT 1
47305: PLUS
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PPUSH
47311: LD_VAR 0 6
47315: PUSH
47316: LD_VAR 0 3
47320: ARRAY
47321: PPUSH
47322: CALL 71523 0 3
47326: ST_TO_ADDR
47327: GO 47274
47329: POP
47330: POP
// end ;
47331: GO 46574
47333: POP
47334: POP
// end ;
47335: LD_VAR 0 1
47339: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47340: LD_INT 0
47342: PPUSH
47343: PPUSH
47344: PPUSH
47345: PPUSH
47346: PPUSH
47347: PPUSH
47348: PPUSH
47349: PPUSH
47350: PPUSH
47351: PPUSH
// if not mc_bases then
47352: LD_EXP 101
47356: NOT
47357: IFFALSE 47361
// exit ;
47359: GO 49111
// for i = 1 to mc_bases do
47361: LD_ADDR_VAR 0 2
47365: PUSH
47366: DOUBLE
47367: LD_INT 1
47369: DEC
47370: ST_TO_ADDR
47371: LD_EXP 101
47375: PUSH
47376: FOR_TO
47377: IFFALSE 49109
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47379: LD_EXP 101
47383: PUSH
47384: LD_VAR 0 2
47388: ARRAY
47389: NOT
47390: PUSH
47391: LD_EXP 108
47395: PUSH
47396: LD_VAR 0 2
47400: ARRAY
47401: OR
47402: IFFALSE 47406
// continue ;
47404: GO 47376
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47406: LD_EXP 117
47410: PUSH
47411: LD_VAR 0 2
47415: ARRAY
47416: NOT
47417: PUSH
47418: LD_EXP 118
47422: PUSH
47423: LD_VAR 0 2
47427: ARRAY
47428: AND
47429: IFFALSE 47467
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47431: LD_ADDR_EXP 118
47435: PUSH
47436: LD_EXP 118
47440: PPUSH
47441: LD_VAR 0 2
47445: PPUSH
47446: EMPTY
47447: PPUSH
47448: CALL_OW 1
47452: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47453: LD_VAR 0 2
47457: PPUSH
47458: LD_INT 107
47460: PPUSH
47461: CALL 38325 0 2
// continue ;
47465: GO 47376
// end ; target := [ ] ;
47467: LD_ADDR_VAR 0 6
47471: PUSH
47472: EMPTY
47473: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47474: LD_ADDR_VAR 0 3
47478: PUSH
47479: DOUBLE
47480: LD_EXP 117
47484: PUSH
47485: LD_VAR 0 2
47489: ARRAY
47490: INC
47491: ST_TO_ADDR
47492: LD_INT 1
47494: PUSH
47495: FOR_DOWNTO
47496: IFFALSE 47756
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47498: LD_EXP 117
47502: PUSH
47503: LD_VAR 0 2
47507: ARRAY
47508: PUSH
47509: LD_VAR 0 3
47513: ARRAY
47514: PUSH
47515: LD_INT 2
47517: ARRAY
47518: PPUSH
47519: LD_EXP 117
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: PUSH
47530: LD_VAR 0 3
47534: ARRAY
47535: PUSH
47536: LD_INT 3
47538: ARRAY
47539: PPUSH
47540: CALL_OW 488
47544: PUSH
47545: LD_EXP 117
47549: PUSH
47550: LD_VAR 0 2
47554: ARRAY
47555: PUSH
47556: LD_VAR 0 3
47560: ARRAY
47561: PUSH
47562: LD_INT 2
47564: ARRAY
47565: PPUSH
47566: LD_EXP 117
47570: PUSH
47571: LD_VAR 0 2
47575: ARRAY
47576: PUSH
47577: LD_VAR 0 3
47581: ARRAY
47582: PUSH
47583: LD_INT 3
47585: ARRAY
47586: PPUSH
47587: CALL_OW 284
47591: PUSH
47592: LD_INT 0
47594: EQUAL
47595: AND
47596: IFFALSE 47651
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47598: LD_ADDR_VAR 0 5
47602: PUSH
47603: LD_EXP 117
47607: PUSH
47608: LD_VAR 0 2
47612: ARRAY
47613: PPUSH
47614: LD_VAR 0 3
47618: PPUSH
47619: CALL_OW 3
47623: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47624: LD_ADDR_EXP 117
47628: PUSH
47629: LD_EXP 117
47633: PPUSH
47634: LD_VAR 0 2
47638: PPUSH
47639: LD_VAR 0 5
47643: PPUSH
47644: CALL_OW 1
47648: ST_TO_ADDR
// continue ;
47649: GO 47495
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47651: LD_EXP 101
47655: PUSH
47656: LD_VAR 0 2
47660: ARRAY
47661: PUSH
47662: LD_INT 1
47664: ARRAY
47665: PPUSH
47666: CALL_OW 255
47670: PPUSH
47671: LD_EXP 117
47675: PUSH
47676: LD_VAR 0 2
47680: ARRAY
47681: PUSH
47682: LD_VAR 0 3
47686: ARRAY
47687: PUSH
47688: LD_INT 2
47690: ARRAY
47691: PPUSH
47692: LD_EXP 117
47696: PUSH
47697: LD_VAR 0 2
47701: ARRAY
47702: PUSH
47703: LD_VAR 0 3
47707: ARRAY
47708: PUSH
47709: LD_INT 3
47711: ARRAY
47712: PPUSH
47713: LD_INT 30
47715: PPUSH
47716: CALL 72419 0 4
47720: PUSH
47721: LD_INT 4
47723: ARRAY
47724: PUSH
47725: LD_INT 0
47727: EQUAL
47728: IFFALSE 47754
// begin target := mc_crates [ i ] [ j ] ;
47730: LD_ADDR_VAR 0 6
47734: PUSH
47735: LD_EXP 117
47739: PUSH
47740: LD_VAR 0 2
47744: ARRAY
47745: PUSH
47746: LD_VAR 0 3
47750: ARRAY
47751: ST_TO_ADDR
// break ;
47752: GO 47756
// end ; end ;
47754: GO 47495
47756: POP
47757: POP
// if not target then
47758: LD_VAR 0 6
47762: NOT
47763: IFFALSE 47767
// continue ;
47765: GO 47376
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47767: LD_ADDR_VAR 0 7
47771: PUSH
47772: LD_EXP 120
47776: PUSH
47777: LD_VAR 0 2
47781: ARRAY
47782: PPUSH
47783: LD_INT 2
47785: PUSH
47786: LD_INT 3
47788: PUSH
47789: LD_INT 58
47791: PUSH
47792: EMPTY
47793: LIST
47794: PUSH
47795: EMPTY
47796: LIST
47797: LIST
47798: PUSH
47799: LD_INT 61
47801: PUSH
47802: EMPTY
47803: LIST
47804: PUSH
47805: LD_INT 33
47807: PUSH
47808: LD_INT 5
47810: PUSH
47811: EMPTY
47812: LIST
47813: LIST
47814: PUSH
47815: LD_INT 33
47817: PUSH
47818: LD_INT 3
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: PUSH
47832: LD_INT 2
47834: PUSH
47835: LD_INT 34
47837: PUSH
47838: LD_INT 32
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PUSH
47845: LD_INT 34
47847: PUSH
47848: LD_INT 51
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 34
47857: PUSH
47858: LD_INT 12
47860: PUSH
47861: EMPTY
47862: LIST
47863: LIST
47864: PUSH
47865: EMPTY
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: PUSH
47871: EMPTY
47872: LIST
47873: LIST
47874: PPUSH
47875: CALL_OW 72
47879: ST_TO_ADDR
// if not cargo then
47880: LD_VAR 0 7
47884: NOT
47885: IFFALSE 48528
// begin if mc_crates_collector [ i ] < 5 then
47887: LD_EXP 118
47891: PUSH
47892: LD_VAR 0 2
47896: ARRAY
47897: PUSH
47898: LD_INT 5
47900: LESS
47901: IFFALSE 48267
// begin if mc_ape [ i ] then
47903: LD_EXP 130
47907: PUSH
47908: LD_VAR 0 2
47912: ARRAY
47913: IFFALSE 47960
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47915: LD_ADDR_VAR 0 5
47919: PUSH
47920: LD_EXP 130
47924: PUSH
47925: LD_VAR 0 2
47929: ARRAY
47930: PPUSH
47931: LD_INT 25
47933: PUSH
47934: LD_INT 16
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PUSH
47941: LD_INT 24
47943: PUSH
47944: LD_INT 750
47946: PUSH
47947: EMPTY
47948: LIST
47949: LIST
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PPUSH
47955: CALL_OW 72
47959: ST_TO_ADDR
// if not tmp then
47960: LD_VAR 0 5
47964: NOT
47965: IFFALSE 48012
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47967: LD_ADDR_VAR 0 5
47971: PUSH
47972: LD_EXP 101
47976: PUSH
47977: LD_VAR 0 2
47981: ARRAY
47982: PPUSH
47983: LD_INT 25
47985: PUSH
47986: LD_INT 2
47988: PUSH
47989: EMPTY
47990: LIST
47991: LIST
47992: PUSH
47993: LD_INT 24
47995: PUSH
47996: LD_INT 750
47998: PUSH
47999: EMPTY
48000: LIST
48001: LIST
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PPUSH
48007: CALL_OW 72
48011: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48012: LD_EXP 130
48016: PUSH
48017: LD_VAR 0 2
48021: ARRAY
48022: PUSH
48023: LD_EXP 101
48027: PUSH
48028: LD_VAR 0 2
48032: ARRAY
48033: PPUSH
48034: LD_INT 25
48036: PUSH
48037: LD_INT 2
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 24
48046: PUSH
48047: LD_INT 750
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PPUSH
48058: CALL_OW 72
48062: AND
48063: PUSH
48064: LD_VAR 0 5
48068: PUSH
48069: LD_INT 5
48071: LESS
48072: AND
48073: IFFALSE 48155
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48075: LD_ADDR_VAR 0 3
48079: PUSH
48080: LD_EXP 101
48084: PUSH
48085: LD_VAR 0 2
48089: ARRAY
48090: PPUSH
48091: LD_INT 25
48093: PUSH
48094: LD_INT 2
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: PUSH
48101: LD_INT 24
48103: PUSH
48104: LD_INT 750
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PUSH
48111: EMPTY
48112: LIST
48113: LIST
48114: PPUSH
48115: CALL_OW 72
48119: PUSH
48120: FOR_IN
48121: IFFALSE 48153
// begin tmp := tmp union j ;
48123: LD_ADDR_VAR 0 5
48127: PUSH
48128: LD_VAR 0 5
48132: PUSH
48133: LD_VAR 0 3
48137: UNION
48138: ST_TO_ADDR
// if tmp >= 5 then
48139: LD_VAR 0 5
48143: PUSH
48144: LD_INT 5
48146: GREATEREQUAL
48147: IFFALSE 48151
// break ;
48149: GO 48153
// end ;
48151: GO 48120
48153: POP
48154: POP
// end ; if not tmp then
48155: LD_VAR 0 5
48159: NOT
48160: IFFALSE 48164
// continue ;
48162: GO 47376
// for j in tmp do
48164: LD_ADDR_VAR 0 3
48168: PUSH
48169: LD_VAR 0 5
48173: PUSH
48174: FOR_IN
48175: IFFALSE 48265
// if not GetTag ( j ) then
48177: LD_VAR 0 3
48181: PPUSH
48182: CALL_OW 110
48186: NOT
48187: IFFALSE 48263
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48189: LD_ADDR_EXP 118
48193: PUSH
48194: LD_EXP 118
48198: PPUSH
48199: LD_VAR 0 2
48203: PUSH
48204: LD_EXP 118
48208: PUSH
48209: LD_VAR 0 2
48213: ARRAY
48214: PUSH
48215: LD_INT 1
48217: PLUS
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PPUSH
48223: LD_VAR 0 3
48227: PPUSH
48228: CALL 71523 0 3
48232: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48233: LD_VAR 0 3
48237: PPUSH
48238: LD_INT 107
48240: PPUSH
48241: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48245: LD_EXP 118
48249: PUSH
48250: LD_VAR 0 2
48254: ARRAY
48255: PUSH
48256: LD_INT 5
48258: GREATEREQUAL
48259: IFFALSE 48263
// break ;
48261: GO 48265
// end ;
48263: GO 48174
48265: POP
48266: POP
// end ; if mc_crates_collector [ i ] and target then
48267: LD_EXP 118
48271: PUSH
48272: LD_VAR 0 2
48276: ARRAY
48277: PUSH
48278: LD_VAR 0 6
48282: AND
48283: IFFALSE 48526
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48285: LD_EXP 118
48289: PUSH
48290: LD_VAR 0 2
48294: ARRAY
48295: PUSH
48296: LD_VAR 0 6
48300: PUSH
48301: LD_INT 1
48303: ARRAY
48304: LESS
48305: IFFALSE 48325
// tmp := mc_crates_collector [ i ] else
48307: LD_ADDR_VAR 0 5
48311: PUSH
48312: LD_EXP 118
48316: PUSH
48317: LD_VAR 0 2
48321: ARRAY
48322: ST_TO_ADDR
48323: GO 48339
// tmp := target [ 1 ] ;
48325: LD_ADDR_VAR 0 5
48329: PUSH
48330: LD_VAR 0 6
48334: PUSH
48335: LD_INT 1
48337: ARRAY
48338: ST_TO_ADDR
// k := 0 ;
48339: LD_ADDR_VAR 0 4
48343: PUSH
48344: LD_INT 0
48346: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48347: LD_ADDR_VAR 0 3
48351: PUSH
48352: LD_EXP 118
48356: PUSH
48357: LD_VAR 0 2
48361: ARRAY
48362: PUSH
48363: FOR_IN
48364: IFFALSE 48524
// begin k := k + 1 ;
48366: LD_ADDR_VAR 0 4
48370: PUSH
48371: LD_VAR 0 4
48375: PUSH
48376: LD_INT 1
48378: PLUS
48379: ST_TO_ADDR
// if k > tmp then
48380: LD_VAR 0 4
48384: PUSH
48385: LD_VAR 0 5
48389: GREATER
48390: IFFALSE 48394
// break ;
48392: GO 48524
// if not GetClass ( j ) in [ 2 , 16 ] then
48394: LD_VAR 0 3
48398: PPUSH
48399: CALL_OW 257
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 16
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: IN
48414: NOT
48415: IFFALSE 48468
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48417: LD_ADDR_EXP 118
48421: PUSH
48422: LD_EXP 118
48426: PPUSH
48427: LD_VAR 0 2
48431: PPUSH
48432: LD_EXP 118
48436: PUSH
48437: LD_VAR 0 2
48441: ARRAY
48442: PUSH
48443: LD_VAR 0 3
48447: DIFF
48448: PPUSH
48449: CALL_OW 1
48453: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48454: LD_VAR 0 3
48458: PPUSH
48459: LD_INT 0
48461: PPUSH
48462: CALL_OW 109
// continue ;
48466: GO 48363
// end ; if IsInUnit ( j ) then
48468: LD_VAR 0 3
48472: PPUSH
48473: CALL_OW 310
48477: IFFALSE 48488
// ComExitBuilding ( j ) ;
48479: LD_VAR 0 3
48483: PPUSH
48484: CALL_OW 122
// wait ( 3 ) ;
48488: LD_INT 3
48490: PPUSH
48491: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48495: LD_VAR 0 3
48499: PPUSH
48500: LD_VAR 0 6
48504: PUSH
48505: LD_INT 2
48507: ARRAY
48508: PPUSH
48509: LD_VAR 0 6
48513: PUSH
48514: LD_INT 3
48516: ARRAY
48517: PPUSH
48518: CALL_OW 117
// end ;
48522: GO 48363
48524: POP
48525: POP
// end ; end else
48526: GO 49107
// begin for j in cargo do
48528: LD_ADDR_VAR 0 3
48532: PUSH
48533: LD_VAR 0 7
48537: PUSH
48538: FOR_IN
48539: IFFALSE 49105
// begin if GetTag ( j ) <> 0 then
48541: LD_VAR 0 3
48545: PPUSH
48546: CALL_OW 110
48550: PUSH
48551: LD_INT 0
48553: NONEQUAL
48554: IFFALSE 48558
// continue ;
48556: GO 48538
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48558: LD_VAR 0 3
48562: PPUSH
48563: CALL_OW 256
48567: PUSH
48568: LD_INT 1000
48570: LESS
48571: PUSH
48572: LD_VAR 0 3
48576: PPUSH
48577: LD_EXP 125
48581: PUSH
48582: LD_VAR 0 2
48586: ARRAY
48587: PPUSH
48588: CALL_OW 308
48592: NOT
48593: AND
48594: IFFALSE 48616
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48596: LD_VAR 0 3
48600: PPUSH
48601: LD_EXP 125
48605: PUSH
48606: LD_VAR 0 2
48610: ARRAY
48611: PPUSH
48612: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48616: LD_VAR 0 3
48620: PPUSH
48621: CALL_OW 256
48625: PUSH
48626: LD_INT 1000
48628: LESS
48629: PUSH
48630: LD_VAR 0 3
48634: PPUSH
48635: LD_EXP 125
48639: PUSH
48640: LD_VAR 0 2
48644: ARRAY
48645: PPUSH
48646: CALL_OW 308
48650: AND
48651: IFFALSE 48655
// continue ;
48653: GO 48538
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48655: LD_VAR 0 3
48659: PPUSH
48660: CALL_OW 262
48664: PUSH
48665: LD_INT 2
48667: EQUAL
48668: PUSH
48669: LD_VAR 0 3
48673: PPUSH
48674: CALL_OW 261
48678: PUSH
48679: LD_INT 15
48681: LESS
48682: AND
48683: IFFALSE 48687
// continue ;
48685: GO 48538
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48687: LD_VAR 0 3
48691: PPUSH
48692: CALL_OW 262
48696: PUSH
48697: LD_INT 1
48699: EQUAL
48700: PUSH
48701: LD_VAR 0 3
48705: PPUSH
48706: CALL_OW 261
48710: PUSH
48711: LD_INT 10
48713: LESS
48714: AND
48715: IFFALSE 49044
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48717: LD_ADDR_VAR 0 8
48721: PUSH
48722: LD_EXP 101
48726: PUSH
48727: LD_VAR 0 2
48731: ARRAY
48732: PPUSH
48733: LD_INT 2
48735: PUSH
48736: LD_INT 30
48738: PUSH
48739: LD_INT 0
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: LD_INT 30
48748: PUSH
48749: LD_INT 1
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: LIST
48760: PPUSH
48761: CALL_OW 72
48765: ST_TO_ADDR
// if not depot then
48766: LD_VAR 0 8
48770: NOT
48771: IFFALSE 48775
// continue ;
48773: GO 48538
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48775: LD_VAR 0 3
48779: PPUSH
48780: LD_VAR 0 8
48784: PPUSH
48785: LD_VAR 0 3
48789: PPUSH
48790: CALL_OW 74
48794: PPUSH
48795: CALL_OW 296
48799: PUSH
48800: LD_INT 6
48802: LESS
48803: IFFALSE 48819
// SetFuel ( j , 100 ) else
48805: LD_VAR 0 3
48809: PPUSH
48810: LD_INT 100
48812: PPUSH
48813: CALL_OW 240
48817: GO 49044
// if GetFuel ( j ) = 0 then
48819: LD_VAR 0 3
48823: PPUSH
48824: CALL_OW 261
48828: PUSH
48829: LD_INT 0
48831: EQUAL
48832: IFFALSE 49044
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48834: LD_ADDR_EXP 120
48838: PUSH
48839: LD_EXP 120
48843: PPUSH
48844: LD_VAR 0 2
48848: PPUSH
48849: LD_EXP 120
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PUSH
48860: LD_VAR 0 3
48864: DIFF
48865: PPUSH
48866: CALL_OW 1
48870: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48871: LD_VAR 0 3
48875: PPUSH
48876: CALL_OW 263
48880: PUSH
48881: LD_INT 1
48883: EQUAL
48884: IFFALSE 48900
// ComExitVehicle ( IsInUnit ( j ) ) ;
48886: LD_VAR 0 3
48890: PPUSH
48891: CALL_OW 310
48895: PPUSH
48896: CALL_OW 121
// if GetControl ( j ) = control_remote then
48900: LD_VAR 0 3
48904: PPUSH
48905: CALL_OW 263
48909: PUSH
48910: LD_INT 2
48912: EQUAL
48913: IFFALSE 48924
// ComUnlink ( j ) ;
48915: LD_VAR 0 3
48919: PPUSH
48920: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48924: LD_ADDR_VAR 0 9
48928: PUSH
48929: LD_VAR 0 2
48933: PPUSH
48934: LD_INT 3
48936: PPUSH
48937: CALL 58397 0 2
48941: ST_TO_ADDR
// if fac then
48942: LD_VAR 0 9
48946: IFFALSE 49042
// begin for k in fac do
48948: LD_ADDR_VAR 0 4
48952: PUSH
48953: LD_VAR 0 9
48957: PUSH
48958: FOR_IN
48959: IFFALSE 49040
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48961: LD_ADDR_VAR 0 10
48965: PUSH
48966: LD_VAR 0 9
48970: PPUSH
48971: LD_VAR 0 3
48975: PPUSH
48976: CALL_OW 265
48980: PPUSH
48981: LD_VAR 0 3
48985: PPUSH
48986: CALL_OW 262
48990: PPUSH
48991: LD_VAR 0 3
48995: PPUSH
48996: CALL_OW 263
49000: PPUSH
49001: LD_VAR 0 3
49005: PPUSH
49006: CALL_OW 264
49010: PPUSH
49011: CALL 69055 0 5
49015: ST_TO_ADDR
// if components then
49016: LD_VAR 0 10
49020: IFFALSE 49038
// begin MC_InsertProduceList ( i , components ) ;
49022: LD_VAR 0 2
49026: PPUSH
49027: LD_VAR 0 10
49031: PPUSH
49032: CALL 57942 0 2
// break ;
49036: GO 49040
// end ; end ;
49038: GO 48958
49040: POP
49041: POP
// end ; continue ;
49042: GO 48538
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49044: LD_VAR 0 3
49048: PPUSH
49049: LD_INT 1
49051: PPUSH
49052: CALL_OW 289
49056: PUSH
49057: LD_INT 100
49059: LESS
49060: PUSH
49061: LD_VAR 0 3
49065: PPUSH
49066: CALL_OW 314
49070: NOT
49071: AND
49072: IFFALSE 49101
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49074: LD_VAR 0 3
49078: PPUSH
49079: LD_VAR 0 6
49083: PUSH
49084: LD_INT 2
49086: ARRAY
49087: PPUSH
49088: LD_VAR 0 6
49092: PUSH
49093: LD_INT 3
49095: ARRAY
49096: PPUSH
49097: CALL_OW 117
// break ;
49101: GO 49105
// end ;
49103: GO 48538
49105: POP
49106: POP
// end ; end ;
49107: GO 47376
49109: POP
49110: POP
// end ;
49111: LD_VAR 0 1
49115: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49116: LD_INT 0
49118: PPUSH
49119: PPUSH
49120: PPUSH
49121: PPUSH
// if not mc_bases then
49122: LD_EXP 101
49126: NOT
49127: IFFALSE 49131
// exit ;
49129: GO 49292
// for i = 1 to mc_bases do
49131: LD_ADDR_VAR 0 2
49135: PUSH
49136: DOUBLE
49137: LD_INT 1
49139: DEC
49140: ST_TO_ADDR
49141: LD_EXP 101
49145: PUSH
49146: FOR_TO
49147: IFFALSE 49290
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49149: LD_ADDR_VAR 0 4
49153: PUSH
49154: LD_EXP 120
49158: PUSH
49159: LD_VAR 0 2
49163: ARRAY
49164: PUSH
49165: LD_EXP 123
49169: PUSH
49170: LD_VAR 0 2
49174: ARRAY
49175: UNION
49176: PPUSH
49177: LD_INT 33
49179: PUSH
49180: LD_INT 2
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: PPUSH
49187: CALL_OW 72
49191: ST_TO_ADDR
// if tmp then
49192: LD_VAR 0 4
49196: IFFALSE 49288
// for j in tmp do
49198: LD_ADDR_VAR 0 3
49202: PUSH
49203: LD_VAR 0 4
49207: PUSH
49208: FOR_IN
49209: IFFALSE 49286
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49211: LD_VAR 0 3
49215: PPUSH
49216: CALL_OW 312
49220: NOT
49221: PUSH
49222: LD_VAR 0 3
49226: PPUSH
49227: CALL_OW 256
49231: PUSH
49232: LD_INT 250
49234: GREATEREQUAL
49235: AND
49236: IFFALSE 49249
// Connect ( j ) else
49238: LD_VAR 0 3
49242: PPUSH
49243: CALL 74456 0 1
49247: GO 49284
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49249: LD_VAR 0 3
49253: PPUSH
49254: CALL_OW 256
49258: PUSH
49259: LD_INT 250
49261: LESS
49262: PUSH
49263: LD_VAR 0 3
49267: PPUSH
49268: CALL_OW 312
49272: AND
49273: IFFALSE 49284
// ComUnlink ( j ) ;
49275: LD_VAR 0 3
49279: PPUSH
49280: CALL_OW 136
49284: GO 49208
49286: POP
49287: POP
// end ;
49288: GO 49146
49290: POP
49291: POP
// end ;
49292: LD_VAR 0 1
49296: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49297: LD_INT 0
49299: PPUSH
49300: PPUSH
49301: PPUSH
49302: PPUSH
49303: PPUSH
// if not mc_bases then
49304: LD_EXP 101
49308: NOT
49309: IFFALSE 49313
// exit ;
49311: GO 49758
// for i = 1 to mc_bases do
49313: LD_ADDR_VAR 0 2
49317: PUSH
49318: DOUBLE
49319: LD_INT 1
49321: DEC
49322: ST_TO_ADDR
49323: LD_EXP 101
49327: PUSH
49328: FOR_TO
49329: IFFALSE 49756
// begin if not mc_produce [ i ] then
49331: LD_EXP 122
49335: PUSH
49336: LD_VAR 0 2
49340: ARRAY
49341: NOT
49342: IFFALSE 49346
// continue ;
49344: GO 49328
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49346: LD_ADDR_VAR 0 5
49350: PUSH
49351: LD_EXP 101
49355: PUSH
49356: LD_VAR 0 2
49360: ARRAY
49361: PPUSH
49362: LD_INT 30
49364: PUSH
49365: LD_INT 3
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PPUSH
49372: CALL_OW 72
49376: ST_TO_ADDR
// if not fac then
49377: LD_VAR 0 5
49381: NOT
49382: IFFALSE 49386
// continue ;
49384: GO 49328
// for j in fac do
49386: LD_ADDR_VAR 0 3
49390: PUSH
49391: LD_VAR 0 5
49395: PUSH
49396: FOR_IN
49397: IFFALSE 49752
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49399: LD_VAR 0 3
49403: PPUSH
49404: CALL_OW 461
49408: PUSH
49409: LD_INT 2
49411: NONEQUAL
49412: PUSH
49413: LD_VAR 0 3
49417: PPUSH
49418: LD_INT 15
49420: PPUSH
49421: CALL 74116 0 2
49425: PUSH
49426: LD_INT 4
49428: ARRAY
49429: OR
49430: IFFALSE 49434
// continue ;
49432: GO 49396
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49434: LD_VAR 0 3
49438: PPUSH
49439: LD_EXP 122
49443: PUSH
49444: LD_VAR 0 2
49448: ARRAY
49449: PUSH
49450: LD_INT 1
49452: ARRAY
49453: PUSH
49454: LD_INT 1
49456: ARRAY
49457: PPUSH
49458: LD_EXP 122
49462: PUSH
49463: LD_VAR 0 2
49467: ARRAY
49468: PUSH
49469: LD_INT 1
49471: ARRAY
49472: PUSH
49473: LD_INT 2
49475: ARRAY
49476: PPUSH
49477: LD_EXP 122
49481: PUSH
49482: LD_VAR 0 2
49486: ARRAY
49487: PUSH
49488: LD_INT 1
49490: ARRAY
49491: PUSH
49492: LD_INT 3
49494: ARRAY
49495: PPUSH
49496: LD_EXP 122
49500: PUSH
49501: LD_VAR 0 2
49505: ARRAY
49506: PUSH
49507: LD_INT 1
49509: ARRAY
49510: PUSH
49511: LD_INT 4
49513: ARRAY
49514: PPUSH
49515: CALL_OW 448
49519: PUSH
49520: LD_VAR 0 3
49524: PPUSH
49525: LD_EXP 122
49529: PUSH
49530: LD_VAR 0 2
49534: ARRAY
49535: PUSH
49536: LD_INT 1
49538: ARRAY
49539: PUSH
49540: LD_INT 1
49542: ARRAY
49543: PUSH
49544: LD_EXP 122
49548: PUSH
49549: LD_VAR 0 2
49553: ARRAY
49554: PUSH
49555: LD_INT 1
49557: ARRAY
49558: PUSH
49559: LD_INT 2
49561: ARRAY
49562: PUSH
49563: LD_EXP 122
49567: PUSH
49568: LD_VAR 0 2
49572: ARRAY
49573: PUSH
49574: LD_INT 1
49576: ARRAY
49577: PUSH
49578: LD_INT 3
49580: ARRAY
49581: PUSH
49582: LD_EXP 122
49586: PUSH
49587: LD_VAR 0 2
49591: ARRAY
49592: PUSH
49593: LD_INT 1
49595: ARRAY
49596: PUSH
49597: LD_INT 4
49599: ARRAY
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: PPUSH
49607: CALL 77787 0 2
49611: AND
49612: IFFALSE 49750
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49614: LD_VAR 0 3
49618: PPUSH
49619: LD_EXP 122
49623: PUSH
49624: LD_VAR 0 2
49628: ARRAY
49629: PUSH
49630: LD_INT 1
49632: ARRAY
49633: PUSH
49634: LD_INT 1
49636: ARRAY
49637: PPUSH
49638: LD_EXP 122
49642: PUSH
49643: LD_VAR 0 2
49647: ARRAY
49648: PUSH
49649: LD_INT 1
49651: ARRAY
49652: PUSH
49653: LD_INT 2
49655: ARRAY
49656: PPUSH
49657: LD_EXP 122
49661: PUSH
49662: LD_VAR 0 2
49666: ARRAY
49667: PUSH
49668: LD_INT 1
49670: ARRAY
49671: PUSH
49672: LD_INT 3
49674: ARRAY
49675: PPUSH
49676: LD_EXP 122
49680: PUSH
49681: LD_VAR 0 2
49685: ARRAY
49686: PUSH
49687: LD_INT 1
49689: ARRAY
49690: PUSH
49691: LD_INT 4
49693: ARRAY
49694: PPUSH
49695: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49699: LD_ADDR_VAR 0 4
49703: PUSH
49704: LD_EXP 122
49708: PUSH
49709: LD_VAR 0 2
49713: ARRAY
49714: PPUSH
49715: LD_INT 1
49717: PPUSH
49718: CALL_OW 3
49722: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49723: LD_ADDR_EXP 122
49727: PUSH
49728: LD_EXP 122
49732: PPUSH
49733: LD_VAR 0 2
49737: PPUSH
49738: LD_VAR 0 4
49742: PPUSH
49743: CALL_OW 1
49747: ST_TO_ADDR
// break ;
49748: GO 49752
// end ; end ;
49750: GO 49396
49752: POP
49753: POP
// end ;
49754: GO 49328
49756: POP
49757: POP
// end ;
49758: LD_VAR 0 1
49762: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49763: LD_INT 0
49765: PPUSH
49766: PPUSH
49767: PPUSH
// if not mc_bases then
49768: LD_EXP 101
49772: NOT
49773: IFFALSE 49777
// exit ;
49775: GO 49866
// for i = 1 to mc_bases do
49777: LD_ADDR_VAR 0 2
49781: PUSH
49782: DOUBLE
49783: LD_INT 1
49785: DEC
49786: ST_TO_ADDR
49787: LD_EXP 101
49791: PUSH
49792: FOR_TO
49793: IFFALSE 49864
// begin if mc_attack [ i ] then
49795: LD_EXP 121
49799: PUSH
49800: LD_VAR 0 2
49804: ARRAY
49805: IFFALSE 49862
// begin tmp := mc_attack [ i ] [ 1 ] ;
49807: LD_ADDR_VAR 0 3
49811: PUSH
49812: LD_EXP 121
49816: PUSH
49817: LD_VAR 0 2
49821: ARRAY
49822: PUSH
49823: LD_INT 1
49825: ARRAY
49826: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49827: LD_ADDR_EXP 121
49831: PUSH
49832: LD_EXP 121
49836: PPUSH
49837: LD_VAR 0 2
49841: PPUSH
49842: EMPTY
49843: PPUSH
49844: CALL_OW 1
49848: ST_TO_ADDR
// Attack ( tmp ) ;
49849: LD_VAR 0 3
49853: PPUSH
49854: CALL 99977 0 1
// exit ;
49858: POP
49859: POP
49860: GO 49866
// end ; end ;
49862: GO 49792
49864: POP
49865: POP
// end ;
49866: LD_VAR 0 1
49870: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49871: LD_INT 0
49873: PPUSH
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
49878: PPUSH
49879: PPUSH
// if not mc_bases then
49880: LD_EXP 101
49884: NOT
49885: IFFALSE 49889
// exit ;
49887: GO 50471
// for i = 1 to mc_bases do
49889: LD_ADDR_VAR 0 2
49893: PUSH
49894: DOUBLE
49895: LD_INT 1
49897: DEC
49898: ST_TO_ADDR
49899: LD_EXP 101
49903: PUSH
49904: FOR_TO
49905: IFFALSE 50469
// begin if not mc_bases [ i ] then
49907: LD_EXP 101
49911: PUSH
49912: LD_VAR 0 2
49916: ARRAY
49917: NOT
49918: IFFALSE 49922
// continue ;
49920: GO 49904
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49922: LD_ADDR_VAR 0 7
49926: PUSH
49927: LD_EXP 101
49931: PUSH
49932: LD_VAR 0 2
49936: ARRAY
49937: PUSH
49938: LD_INT 1
49940: ARRAY
49941: PPUSH
49942: CALL 68359 0 1
49946: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49947: LD_ADDR_EXP 124
49951: PUSH
49952: LD_EXP 124
49956: PPUSH
49957: LD_VAR 0 2
49961: PPUSH
49962: LD_EXP 101
49966: PUSH
49967: LD_VAR 0 2
49971: ARRAY
49972: PUSH
49973: LD_INT 1
49975: ARRAY
49976: PPUSH
49977: CALL_OW 255
49981: PPUSH
49982: LD_EXP 126
49986: PUSH
49987: LD_VAR 0 2
49991: ARRAY
49992: PPUSH
49993: CALL 65913 0 2
49997: PPUSH
49998: CALL_OW 1
50002: ST_TO_ADDR
// if not mc_scan [ i ] then
50003: LD_EXP 124
50007: PUSH
50008: LD_VAR 0 2
50012: ARRAY
50013: NOT
50014: IFFALSE 50169
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50016: LD_ADDR_VAR 0 4
50020: PUSH
50021: LD_EXP 101
50025: PUSH
50026: LD_VAR 0 2
50030: ARRAY
50031: PPUSH
50032: LD_INT 2
50034: PUSH
50035: LD_INT 25
50037: PUSH
50038: LD_INT 5
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 25
50047: PUSH
50048: LD_INT 8
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: LD_INT 25
50057: PUSH
50058: LD_INT 9
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: PUSH
50065: EMPTY
50066: LIST
50067: LIST
50068: LIST
50069: LIST
50070: PPUSH
50071: CALL_OW 72
50075: ST_TO_ADDR
// if not tmp then
50076: LD_VAR 0 4
50080: NOT
50081: IFFALSE 50085
// continue ;
50083: GO 49904
// for j in tmp do
50085: LD_ADDR_VAR 0 3
50089: PUSH
50090: LD_VAR 0 4
50094: PUSH
50095: FOR_IN
50096: IFFALSE 50167
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50098: LD_VAR 0 3
50102: PPUSH
50103: CALL_OW 310
50107: PPUSH
50108: CALL_OW 266
50112: PUSH
50113: LD_INT 5
50115: EQUAL
50116: PUSH
50117: LD_VAR 0 3
50121: PPUSH
50122: CALL_OW 257
50126: PUSH
50127: LD_INT 1
50129: EQUAL
50130: AND
50131: PUSH
50132: LD_VAR 0 3
50136: PPUSH
50137: CALL_OW 459
50141: NOT
50142: AND
50143: PUSH
50144: LD_VAR 0 7
50148: AND
50149: IFFALSE 50165
// ComChangeProfession ( j , class ) ;
50151: LD_VAR 0 3
50155: PPUSH
50156: LD_VAR 0 7
50160: PPUSH
50161: CALL_OW 123
50165: GO 50095
50167: POP
50168: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50169: LD_EXP 124
50173: PUSH
50174: LD_VAR 0 2
50178: ARRAY
50179: PUSH
50180: LD_EXP 123
50184: PUSH
50185: LD_VAR 0 2
50189: ARRAY
50190: NOT
50191: AND
50192: PUSH
50193: LD_EXP 101
50197: PUSH
50198: LD_VAR 0 2
50202: ARRAY
50203: PPUSH
50204: LD_INT 30
50206: PUSH
50207: LD_INT 32
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PPUSH
50214: CALL_OW 72
50218: NOT
50219: AND
50220: PUSH
50221: LD_EXP 101
50225: PUSH
50226: LD_VAR 0 2
50230: ARRAY
50231: PPUSH
50232: LD_INT 2
50234: PUSH
50235: LD_INT 30
50237: PUSH
50238: LD_INT 4
50240: PUSH
50241: EMPTY
50242: LIST
50243: LIST
50244: PUSH
50245: LD_INT 30
50247: PUSH
50248: LD_INT 5
50250: PUSH
50251: EMPTY
50252: LIST
50253: LIST
50254: PUSH
50255: EMPTY
50256: LIST
50257: LIST
50258: LIST
50259: PPUSH
50260: CALL_OW 72
50264: NOT
50265: AND
50266: IFFALSE 50398
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50268: LD_ADDR_VAR 0 4
50272: PUSH
50273: LD_EXP 101
50277: PUSH
50278: LD_VAR 0 2
50282: ARRAY
50283: PPUSH
50284: LD_INT 2
50286: PUSH
50287: LD_INT 25
50289: PUSH
50290: LD_INT 1
50292: PUSH
50293: EMPTY
50294: LIST
50295: LIST
50296: PUSH
50297: LD_INT 25
50299: PUSH
50300: LD_INT 5
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 25
50309: PUSH
50310: LD_INT 8
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 25
50319: PUSH
50320: LD_INT 9
50322: PUSH
50323: EMPTY
50324: LIST
50325: LIST
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: LIST
50331: LIST
50332: LIST
50333: PPUSH
50334: CALL_OW 72
50338: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50339: LD_ADDR_VAR 0 4
50343: PUSH
50344: LD_VAR 0 4
50348: PUSH
50349: LD_VAR 0 4
50353: PPUSH
50354: LD_INT 18
50356: PPUSH
50357: CALL 104786 0 2
50361: DIFF
50362: ST_TO_ADDR
// if tmp then
50363: LD_VAR 0 4
50367: IFFALSE 50398
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50369: LD_VAR 0 2
50373: PPUSH
50374: LD_VAR 0 4
50378: PPUSH
50379: LD_EXP 126
50383: PUSH
50384: LD_VAR 0 2
50388: ARRAY
50389: PPUSH
50390: CALL 65948 0 3
// exit ;
50394: POP
50395: POP
50396: GO 50471
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50398: LD_EXP 124
50402: PUSH
50403: LD_VAR 0 2
50407: ARRAY
50408: PUSH
50409: LD_EXP 123
50413: PUSH
50414: LD_VAR 0 2
50418: ARRAY
50419: AND
50420: IFFALSE 50467
// begin tmp := mc_defender [ i ] ;
50422: LD_ADDR_VAR 0 4
50426: PUSH
50427: LD_EXP 123
50431: PUSH
50432: LD_VAR 0 2
50436: ARRAY
50437: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50438: LD_VAR 0 2
50442: PPUSH
50443: LD_VAR 0 4
50447: PPUSH
50448: LD_EXP 124
50452: PUSH
50453: LD_VAR 0 2
50457: ARRAY
50458: PPUSH
50459: CALL 66509 0 3
// exit ;
50463: POP
50464: POP
50465: GO 50471
// end ; end ;
50467: GO 49904
50469: POP
50470: POP
// end ;
50471: LD_VAR 0 1
50475: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50476: LD_INT 0
50478: PPUSH
50479: PPUSH
50480: PPUSH
50481: PPUSH
50482: PPUSH
50483: PPUSH
50484: PPUSH
50485: PPUSH
50486: PPUSH
50487: PPUSH
50488: PPUSH
// if not mc_bases then
50489: LD_EXP 101
50493: NOT
50494: IFFALSE 50498
// exit ;
50496: GO 51585
// for i = 1 to mc_bases do
50498: LD_ADDR_VAR 0 2
50502: PUSH
50503: DOUBLE
50504: LD_INT 1
50506: DEC
50507: ST_TO_ADDR
50508: LD_EXP 101
50512: PUSH
50513: FOR_TO
50514: IFFALSE 51583
// begin tmp := mc_lab [ i ] ;
50516: LD_ADDR_VAR 0 6
50520: PUSH
50521: LD_EXP 134
50525: PUSH
50526: LD_VAR 0 2
50530: ARRAY
50531: ST_TO_ADDR
// if not tmp then
50532: LD_VAR 0 6
50536: NOT
50537: IFFALSE 50541
// continue ;
50539: GO 50513
// idle_lab := 0 ;
50541: LD_ADDR_VAR 0 11
50545: PUSH
50546: LD_INT 0
50548: ST_TO_ADDR
// for j in tmp do
50549: LD_ADDR_VAR 0 3
50553: PUSH
50554: LD_VAR 0 6
50558: PUSH
50559: FOR_IN
50560: IFFALSE 51579
// begin researching := false ;
50562: LD_ADDR_VAR 0 10
50566: PUSH
50567: LD_INT 0
50569: ST_TO_ADDR
// side := GetSide ( j ) ;
50570: LD_ADDR_VAR 0 4
50574: PUSH
50575: LD_VAR 0 3
50579: PPUSH
50580: CALL_OW 255
50584: ST_TO_ADDR
// if not mc_tech [ side ] then
50585: LD_EXP 128
50589: PUSH
50590: LD_VAR 0 4
50594: ARRAY
50595: NOT
50596: IFFALSE 50600
// continue ;
50598: GO 50559
// if BuildingStatus ( j ) = bs_idle then
50600: LD_VAR 0 3
50604: PPUSH
50605: CALL_OW 461
50609: PUSH
50610: LD_INT 2
50612: EQUAL
50613: IFFALSE 50801
// begin if idle_lab and UnitsInside ( j ) < 6 then
50615: LD_VAR 0 11
50619: PUSH
50620: LD_VAR 0 3
50624: PPUSH
50625: CALL_OW 313
50629: PUSH
50630: LD_INT 6
50632: LESS
50633: AND
50634: IFFALSE 50705
// begin tmp2 := UnitsInside ( idle_lab ) ;
50636: LD_ADDR_VAR 0 9
50640: PUSH
50641: LD_VAR 0 11
50645: PPUSH
50646: CALL_OW 313
50650: ST_TO_ADDR
// if tmp2 then
50651: LD_VAR 0 9
50655: IFFALSE 50697
// for x in tmp2 do
50657: LD_ADDR_VAR 0 7
50661: PUSH
50662: LD_VAR 0 9
50666: PUSH
50667: FOR_IN
50668: IFFALSE 50695
// begin ComExitBuilding ( x ) ;
50670: LD_VAR 0 7
50674: PPUSH
50675: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50679: LD_VAR 0 7
50683: PPUSH
50684: LD_VAR 0 3
50688: PPUSH
50689: CALL_OW 180
// end ;
50693: GO 50667
50695: POP
50696: POP
// idle_lab := 0 ;
50697: LD_ADDR_VAR 0 11
50701: PUSH
50702: LD_INT 0
50704: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50705: LD_ADDR_VAR 0 5
50709: PUSH
50710: LD_EXP 128
50714: PUSH
50715: LD_VAR 0 4
50719: ARRAY
50720: PUSH
50721: FOR_IN
50722: IFFALSE 50782
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50724: LD_VAR 0 3
50728: PPUSH
50729: LD_VAR 0 5
50733: PPUSH
50734: CALL_OW 430
50738: PUSH
50739: LD_VAR 0 4
50743: PPUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: CALL 65018 0 2
50753: AND
50754: IFFALSE 50780
// begin researching := true ;
50756: LD_ADDR_VAR 0 10
50760: PUSH
50761: LD_INT 1
50763: ST_TO_ADDR
// ComResearch ( j , t ) ;
50764: LD_VAR 0 3
50768: PPUSH
50769: LD_VAR 0 5
50773: PPUSH
50774: CALL_OW 124
// break ;
50778: GO 50782
// end ;
50780: GO 50721
50782: POP
50783: POP
// if not researching then
50784: LD_VAR 0 10
50788: NOT
50789: IFFALSE 50801
// idle_lab := j ;
50791: LD_ADDR_VAR 0 11
50795: PUSH
50796: LD_VAR 0 3
50800: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50801: LD_VAR 0 3
50805: PPUSH
50806: CALL_OW 461
50810: PUSH
50811: LD_INT 10
50813: EQUAL
50814: IFFALSE 51402
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50816: LD_EXP 130
50820: PUSH
50821: LD_VAR 0 2
50825: ARRAY
50826: NOT
50827: PUSH
50828: LD_EXP 131
50832: PUSH
50833: LD_VAR 0 2
50837: ARRAY
50838: NOT
50839: AND
50840: PUSH
50841: LD_EXP 128
50845: PUSH
50846: LD_VAR 0 4
50850: ARRAY
50851: PUSH
50852: LD_INT 1
50854: GREATER
50855: AND
50856: IFFALSE 50987
// begin ComCancel ( j ) ;
50858: LD_VAR 0 3
50862: PPUSH
50863: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50867: LD_ADDR_EXP 128
50871: PUSH
50872: LD_EXP 128
50876: PPUSH
50877: LD_VAR 0 4
50881: PPUSH
50882: LD_EXP 128
50886: PUSH
50887: LD_VAR 0 4
50891: ARRAY
50892: PPUSH
50893: LD_EXP 128
50897: PUSH
50898: LD_VAR 0 4
50902: ARRAY
50903: PUSH
50904: LD_INT 1
50906: MINUS
50907: PPUSH
50908: LD_EXP 128
50912: PUSH
50913: LD_VAR 0 4
50917: ARRAY
50918: PPUSH
50919: LD_INT 0
50921: PPUSH
50922: CALL 70941 0 4
50926: PPUSH
50927: CALL_OW 1
50931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50932: LD_ADDR_EXP 128
50936: PUSH
50937: LD_EXP 128
50941: PPUSH
50942: LD_VAR 0 4
50946: PPUSH
50947: LD_EXP 128
50951: PUSH
50952: LD_VAR 0 4
50956: ARRAY
50957: PPUSH
50958: LD_EXP 128
50962: PUSH
50963: LD_VAR 0 4
50967: ARRAY
50968: PPUSH
50969: LD_INT 1
50971: PPUSH
50972: LD_INT 0
50974: PPUSH
50975: CALL 70941 0 4
50979: PPUSH
50980: CALL_OW 1
50984: ST_TO_ADDR
// continue ;
50985: GO 50559
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50987: LD_EXP 130
50991: PUSH
50992: LD_VAR 0 2
50996: ARRAY
50997: PUSH
50998: LD_EXP 131
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: NOT
51009: AND
51010: IFFALSE 51137
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51012: LD_ADDR_EXP 131
51016: PUSH
51017: LD_EXP 131
51021: PPUSH
51022: LD_VAR 0 2
51026: PUSH
51027: LD_EXP 131
51031: PUSH
51032: LD_VAR 0 2
51036: ARRAY
51037: PUSH
51038: LD_INT 1
51040: PLUS
51041: PUSH
51042: EMPTY
51043: LIST
51044: LIST
51045: PPUSH
51046: LD_EXP 130
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: PUSH
51057: LD_INT 1
51059: ARRAY
51060: PPUSH
51061: CALL 71523 0 3
51065: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51066: LD_EXP 130
51070: PUSH
51071: LD_VAR 0 2
51075: ARRAY
51076: PUSH
51077: LD_INT 1
51079: ARRAY
51080: PPUSH
51081: LD_INT 112
51083: PPUSH
51084: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51088: LD_ADDR_VAR 0 9
51092: PUSH
51093: LD_EXP 130
51097: PUSH
51098: LD_VAR 0 2
51102: ARRAY
51103: PPUSH
51104: LD_INT 1
51106: PPUSH
51107: CALL_OW 3
51111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51112: LD_ADDR_EXP 130
51116: PUSH
51117: LD_EXP 130
51121: PPUSH
51122: LD_VAR 0 2
51126: PPUSH
51127: LD_VAR 0 9
51131: PPUSH
51132: CALL_OW 1
51136: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51137: LD_EXP 130
51141: PUSH
51142: LD_VAR 0 2
51146: ARRAY
51147: PUSH
51148: LD_EXP 131
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: AND
51159: PUSH
51160: LD_EXP 131
51164: PUSH
51165: LD_VAR 0 2
51169: ARRAY
51170: PUSH
51171: LD_INT 1
51173: ARRAY
51174: PPUSH
51175: CALL_OW 310
51179: NOT
51180: AND
51181: PUSH
51182: LD_VAR 0 3
51186: PPUSH
51187: CALL_OW 313
51191: PUSH
51192: LD_INT 6
51194: EQUAL
51195: AND
51196: IFFALSE 51252
// begin tmp2 := UnitsInside ( j ) ;
51198: LD_ADDR_VAR 0 9
51202: PUSH
51203: LD_VAR 0 3
51207: PPUSH
51208: CALL_OW 313
51212: ST_TO_ADDR
// if tmp2 = 6 then
51213: LD_VAR 0 9
51217: PUSH
51218: LD_INT 6
51220: EQUAL
51221: IFFALSE 51252
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51223: LD_VAR 0 9
51227: PUSH
51228: LD_INT 1
51230: ARRAY
51231: PPUSH
51232: LD_INT 112
51234: PPUSH
51235: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51239: LD_VAR 0 9
51243: PUSH
51244: LD_INT 1
51246: ARRAY
51247: PPUSH
51248: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51252: LD_EXP 131
51256: PUSH
51257: LD_VAR 0 2
51261: ARRAY
51262: PUSH
51263: LD_EXP 131
51267: PUSH
51268: LD_VAR 0 2
51272: ARRAY
51273: PUSH
51274: LD_INT 1
51276: ARRAY
51277: PPUSH
51278: CALL_OW 314
51282: NOT
51283: AND
51284: PUSH
51285: LD_EXP 131
51289: PUSH
51290: LD_VAR 0 2
51294: ARRAY
51295: PUSH
51296: LD_INT 1
51298: ARRAY
51299: PPUSH
51300: CALL_OW 310
51304: NOT
51305: AND
51306: IFFALSE 51332
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51308: LD_EXP 131
51312: PUSH
51313: LD_VAR 0 2
51317: ARRAY
51318: PUSH
51319: LD_INT 1
51321: ARRAY
51322: PPUSH
51323: LD_VAR 0 3
51327: PPUSH
51328: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51332: LD_EXP 131
51336: PUSH
51337: LD_VAR 0 2
51341: ARRAY
51342: PUSH
51343: LD_INT 1
51345: ARRAY
51346: PPUSH
51347: CALL_OW 310
51351: PUSH
51352: LD_EXP 131
51356: PUSH
51357: LD_VAR 0 2
51361: ARRAY
51362: PUSH
51363: LD_INT 1
51365: ARRAY
51366: PPUSH
51367: CALL_OW 310
51371: PPUSH
51372: CALL_OW 461
51376: PUSH
51377: LD_INT 3
51379: NONEQUAL
51380: AND
51381: IFFALSE 51402
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51383: LD_EXP 131
51387: PUSH
51388: LD_VAR 0 2
51392: ARRAY
51393: PUSH
51394: LD_INT 1
51396: ARRAY
51397: PPUSH
51398: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51402: LD_VAR 0 3
51406: PPUSH
51407: CALL_OW 461
51411: PUSH
51412: LD_INT 6
51414: EQUAL
51415: PUSH
51416: LD_VAR 0 6
51420: PUSH
51421: LD_INT 1
51423: GREATER
51424: AND
51425: IFFALSE 51577
// begin sci := [ ] ;
51427: LD_ADDR_VAR 0 8
51431: PUSH
51432: EMPTY
51433: ST_TO_ADDR
// for x in ( tmp diff j ) do
51434: LD_ADDR_VAR 0 7
51438: PUSH
51439: LD_VAR 0 6
51443: PUSH
51444: LD_VAR 0 3
51448: DIFF
51449: PUSH
51450: FOR_IN
51451: IFFALSE 51503
// begin if sci = 6 then
51453: LD_VAR 0 8
51457: PUSH
51458: LD_INT 6
51460: EQUAL
51461: IFFALSE 51465
// break ;
51463: GO 51503
// if BuildingStatus ( x ) = bs_idle then
51465: LD_VAR 0 7
51469: PPUSH
51470: CALL_OW 461
51474: PUSH
51475: LD_INT 2
51477: EQUAL
51478: IFFALSE 51501
// sci := sci ^ UnitsInside ( x ) ;
51480: LD_ADDR_VAR 0 8
51484: PUSH
51485: LD_VAR 0 8
51489: PUSH
51490: LD_VAR 0 7
51494: PPUSH
51495: CALL_OW 313
51499: ADD
51500: ST_TO_ADDR
// end ;
51501: GO 51450
51503: POP
51504: POP
// if not sci then
51505: LD_VAR 0 8
51509: NOT
51510: IFFALSE 51514
// continue ;
51512: GO 50559
// for x in sci do
51514: LD_ADDR_VAR 0 7
51518: PUSH
51519: LD_VAR 0 8
51523: PUSH
51524: FOR_IN
51525: IFFALSE 51575
// if IsInUnit ( x ) and not HasTask ( x ) then
51527: LD_VAR 0 7
51531: PPUSH
51532: CALL_OW 310
51536: PUSH
51537: LD_VAR 0 7
51541: PPUSH
51542: CALL_OW 314
51546: NOT
51547: AND
51548: IFFALSE 51573
// begin ComExitBuilding ( x ) ;
51550: LD_VAR 0 7
51554: PPUSH
51555: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51559: LD_VAR 0 7
51563: PPUSH
51564: LD_VAR 0 3
51568: PPUSH
51569: CALL_OW 180
// end ;
51573: GO 51524
51575: POP
51576: POP
// end ; end ;
51577: GO 50559
51579: POP
51580: POP
// end ;
51581: GO 50513
51583: POP
51584: POP
// end ;
51585: LD_VAR 0 1
51589: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51590: LD_INT 0
51592: PPUSH
51593: PPUSH
// if not mc_bases then
51594: LD_EXP 101
51598: NOT
51599: IFFALSE 51603
// exit ;
51601: GO 51684
// for i = 1 to mc_bases do
51603: LD_ADDR_VAR 0 2
51607: PUSH
51608: DOUBLE
51609: LD_INT 1
51611: DEC
51612: ST_TO_ADDR
51613: LD_EXP 101
51617: PUSH
51618: FOR_TO
51619: IFFALSE 51682
// if mc_mines [ i ] and mc_miners [ i ] then
51621: LD_EXP 114
51625: PUSH
51626: LD_VAR 0 2
51630: ARRAY
51631: PUSH
51632: LD_EXP 115
51636: PUSH
51637: LD_VAR 0 2
51641: ARRAY
51642: AND
51643: IFFALSE 51680
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51645: LD_EXP 115
51649: PUSH
51650: LD_VAR 0 2
51654: ARRAY
51655: PUSH
51656: LD_INT 1
51658: ARRAY
51659: PPUSH
51660: CALL_OW 255
51664: PPUSH
51665: LD_EXP 114
51669: PUSH
51670: LD_VAR 0 2
51674: ARRAY
51675: PPUSH
51676: CALL 68512 0 2
51680: GO 51618
51682: POP
51683: POP
// end ;
51684: LD_VAR 0 1
51688: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
51698: PPUSH
// if not mc_bases or not mc_parking then
51699: LD_EXP 101
51703: NOT
51704: PUSH
51705: LD_EXP 125
51709: NOT
51710: OR
51711: IFFALSE 51715
// exit ;
51713: GO 52414
// for i = 1 to mc_bases do
51715: LD_ADDR_VAR 0 2
51719: PUSH
51720: DOUBLE
51721: LD_INT 1
51723: DEC
51724: ST_TO_ADDR
51725: LD_EXP 101
51729: PUSH
51730: FOR_TO
51731: IFFALSE 52412
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51733: LD_EXP 101
51737: PUSH
51738: LD_VAR 0 2
51742: ARRAY
51743: NOT
51744: PUSH
51745: LD_EXP 125
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: NOT
51756: OR
51757: IFFALSE 51761
// continue ;
51759: GO 51730
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51761: LD_ADDR_VAR 0 5
51765: PUSH
51766: LD_EXP 101
51770: PUSH
51771: LD_VAR 0 2
51775: ARRAY
51776: PUSH
51777: LD_INT 1
51779: ARRAY
51780: PPUSH
51781: CALL_OW 255
51785: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51786: LD_ADDR_VAR 0 6
51790: PUSH
51791: LD_EXP 101
51795: PUSH
51796: LD_VAR 0 2
51800: ARRAY
51801: PPUSH
51802: LD_INT 30
51804: PUSH
51805: LD_INT 3
51807: PUSH
51808: EMPTY
51809: LIST
51810: LIST
51811: PPUSH
51812: CALL_OW 72
51816: ST_TO_ADDR
// if not fac then
51817: LD_VAR 0 6
51821: NOT
51822: IFFALSE 51873
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51824: LD_ADDR_VAR 0 6
51828: PUSH
51829: LD_EXP 101
51833: PUSH
51834: LD_VAR 0 2
51838: ARRAY
51839: PPUSH
51840: LD_INT 2
51842: PUSH
51843: LD_INT 30
51845: PUSH
51846: LD_INT 0
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: PUSH
51853: LD_INT 30
51855: PUSH
51856: LD_INT 1
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PUSH
51863: EMPTY
51864: LIST
51865: LIST
51866: LIST
51867: PPUSH
51868: CALL_OW 72
51872: ST_TO_ADDR
// if not fac then
51873: LD_VAR 0 6
51877: NOT
51878: IFFALSE 51882
// continue ;
51880: GO 51730
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51882: LD_ADDR_VAR 0 7
51886: PUSH
51887: LD_EXP 125
51891: PUSH
51892: LD_VAR 0 2
51896: ARRAY
51897: PPUSH
51898: LD_INT 22
51900: PUSH
51901: LD_VAR 0 5
51905: PUSH
51906: EMPTY
51907: LIST
51908: LIST
51909: PUSH
51910: LD_INT 21
51912: PUSH
51913: LD_INT 2
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 3
51922: PUSH
51923: LD_INT 24
51925: PUSH
51926: LD_INT 1000
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: PUSH
51933: EMPTY
51934: LIST
51935: LIST
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: LIST
51941: PPUSH
51942: CALL_OW 70
51946: ST_TO_ADDR
// for j in fac do
51947: LD_ADDR_VAR 0 3
51951: PUSH
51952: LD_VAR 0 6
51956: PUSH
51957: FOR_IN
51958: IFFALSE 52039
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51960: LD_ADDR_VAR 0 7
51964: PUSH
51965: LD_VAR 0 7
51969: PUSH
51970: LD_INT 22
51972: PUSH
51973: LD_VAR 0 5
51977: PUSH
51978: EMPTY
51979: LIST
51980: LIST
51981: PUSH
51982: LD_INT 91
51984: PUSH
51985: LD_VAR 0 3
51989: PUSH
51990: LD_INT 15
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: LIST
51997: PUSH
51998: LD_INT 21
52000: PUSH
52001: LD_INT 2
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: PUSH
52008: LD_INT 3
52010: PUSH
52011: LD_INT 24
52013: PUSH
52014: LD_INT 1000
52016: PUSH
52017: EMPTY
52018: LIST
52019: LIST
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: PPUSH
52031: CALL_OW 69
52035: UNION
52036: ST_TO_ADDR
52037: GO 51957
52039: POP
52040: POP
// if not vehs then
52041: LD_VAR 0 7
52045: NOT
52046: IFFALSE 52072
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52048: LD_ADDR_EXP 113
52052: PUSH
52053: LD_EXP 113
52057: PPUSH
52058: LD_VAR 0 2
52062: PPUSH
52063: EMPTY
52064: PPUSH
52065: CALL_OW 1
52069: ST_TO_ADDR
// continue ;
52070: GO 51730
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52072: LD_ADDR_VAR 0 8
52076: PUSH
52077: LD_EXP 101
52081: PUSH
52082: LD_VAR 0 2
52086: ARRAY
52087: PPUSH
52088: LD_INT 30
52090: PUSH
52091: LD_INT 3
52093: PUSH
52094: EMPTY
52095: LIST
52096: LIST
52097: PPUSH
52098: CALL_OW 72
52102: ST_TO_ADDR
// if tmp then
52103: LD_VAR 0 8
52107: IFFALSE 52210
// begin for j in tmp do
52109: LD_ADDR_VAR 0 3
52113: PUSH
52114: LD_VAR 0 8
52118: PUSH
52119: FOR_IN
52120: IFFALSE 52208
// for k in UnitsInside ( j ) do
52122: LD_ADDR_VAR 0 4
52126: PUSH
52127: LD_VAR 0 3
52131: PPUSH
52132: CALL_OW 313
52136: PUSH
52137: FOR_IN
52138: IFFALSE 52204
// if k then
52140: LD_VAR 0 4
52144: IFFALSE 52202
// if not k in mc_repair_vehicle [ i ] then
52146: LD_VAR 0 4
52150: PUSH
52151: LD_EXP 113
52155: PUSH
52156: LD_VAR 0 2
52160: ARRAY
52161: IN
52162: NOT
52163: IFFALSE 52202
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52165: LD_ADDR_EXP 113
52169: PUSH
52170: LD_EXP 113
52174: PPUSH
52175: LD_VAR 0 2
52179: PPUSH
52180: LD_EXP 113
52184: PUSH
52185: LD_VAR 0 2
52189: ARRAY
52190: PUSH
52191: LD_VAR 0 4
52195: UNION
52196: PPUSH
52197: CALL_OW 1
52201: ST_TO_ADDR
52202: GO 52137
52204: POP
52205: POP
52206: GO 52119
52208: POP
52209: POP
// end ; if not mc_repair_vehicle [ i ] then
52210: LD_EXP 113
52214: PUSH
52215: LD_VAR 0 2
52219: ARRAY
52220: NOT
52221: IFFALSE 52225
// continue ;
52223: GO 51730
// for j in mc_repair_vehicle [ i ] do
52225: LD_ADDR_VAR 0 3
52229: PUSH
52230: LD_EXP 113
52234: PUSH
52235: LD_VAR 0 2
52239: ARRAY
52240: PUSH
52241: FOR_IN
52242: IFFALSE 52408
// begin if GetClass ( j ) <> 3 then
52244: LD_VAR 0 3
52248: PPUSH
52249: CALL_OW 257
52253: PUSH
52254: LD_INT 3
52256: NONEQUAL
52257: IFFALSE 52298
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52259: LD_ADDR_EXP 113
52263: PUSH
52264: LD_EXP 113
52268: PPUSH
52269: LD_VAR 0 2
52273: PPUSH
52274: LD_EXP 113
52278: PUSH
52279: LD_VAR 0 2
52283: ARRAY
52284: PUSH
52285: LD_VAR 0 3
52289: DIFF
52290: PPUSH
52291: CALL_OW 1
52295: ST_TO_ADDR
// continue ;
52296: GO 52241
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52298: LD_VAR 0 3
52302: PPUSH
52303: CALL_OW 311
52307: NOT
52308: PUSH
52309: LD_VAR 0 3
52313: PUSH
52314: LD_EXP 104
52318: PUSH
52319: LD_VAR 0 2
52323: ARRAY
52324: PUSH
52325: LD_INT 1
52327: ARRAY
52328: IN
52329: NOT
52330: AND
52331: PUSH
52332: LD_VAR 0 3
52336: PUSH
52337: LD_EXP 104
52341: PUSH
52342: LD_VAR 0 2
52346: ARRAY
52347: PUSH
52348: LD_INT 2
52350: ARRAY
52351: IN
52352: NOT
52353: AND
52354: IFFALSE 52406
// begin if IsInUnit ( j ) then
52356: LD_VAR 0 3
52360: PPUSH
52361: CALL_OW 310
52365: IFFALSE 52376
// ComExitBuilding ( j ) ;
52367: LD_VAR 0 3
52371: PPUSH
52372: CALL_OW 122
// if not HasTask ( j ) then
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL_OW 314
52385: NOT
52386: IFFALSE 52406
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52388: LD_VAR 0 3
52392: PPUSH
52393: LD_VAR 0 7
52397: PUSH
52398: LD_INT 1
52400: ARRAY
52401: PPUSH
52402: CALL_OW 189
// end ; end ;
52406: GO 52241
52408: POP
52409: POP
// end ;
52410: GO 51730
52412: POP
52413: POP
// end ;
52414: LD_VAR 0 1
52418: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52419: LD_INT 0
52421: PPUSH
52422: PPUSH
52423: PPUSH
52424: PPUSH
52425: PPUSH
52426: PPUSH
52427: PPUSH
52428: PPUSH
52429: PPUSH
52430: PPUSH
52431: PPUSH
// if not mc_bases then
52432: LD_EXP 101
52436: NOT
52437: IFFALSE 52441
// exit ;
52439: GO 53243
// for i = 1 to mc_bases do
52441: LD_ADDR_VAR 0 2
52445: PUSH
52446: DOUBLE
52447: LD_INT 1
52449: DEC
52450: ST_TO_ADDR
52451: LD_EXP 101
52455: PUSH
52456: FOR_TO
52457: IFFALSE 53241
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52459: LD_EXP 129
52463: PUSH
52464: LD_VAR 0 2
52468: ARRAY
52469: NOT
52470: PUSH
52471: LD_EXP 104
52475: PUSH
52476: LD_VAR 0 2
52480: ARRAY
52481: PUSH
52482: LD_INT 1
52484: ARRAY
52485: OR
52486: PUSH
52487: LD_EXP 104
52491: PUSH
52492: LD_VAR 0 2
52496: ARRAY
52497: PUSH
52498: LD_INT 2
52500: ARRAY
52501: OR
52502: PUSH
52503: LD_EXP 127
52507: PUSH
52508: LD_VAR 0 2
52512: ARRAY
52513: PPUSH
52514: LD_INT 1
52516: PPUSH
52517: CALL_OW 325
52521: NOT
52522: OR
52523: PUSH
52524: LD_EXP 124
52528: PUSH
52529: LD_VAR 0 2
52533: ARRAY
52534: OR
52535: IFFALSE 52539
// continue ;
52537: GO 52456
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52539: LD_ADDR_VAR 0 8
52543: PUSH
52544: LD_EXP 101
52548: PUSH
52549: LD_VAR 0 2
52553: ARRAY
52554: PPUSH
52555: LD_INT 25
52557: PUSH
52558: LD_INT 4
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: PUSH
52565: LD_INT 50
52567: PUSH
52568: EMPTY
52569: LIST
52570: PUSH
52571: LD_INT 3
52573: PUSH
52574: LD_INT 60
52576: PUSH
52577: EMPTY
52578: LIST
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: LIST
52588: PPUSH
52589: CALL_OW 72
52593: PUSH
52594: LD_EXP 105
52598: PUSH
52599: LD_VAR 0 2
52603: ARRAY
52604: DIFF
52605: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52606: LD_ADDR_VAR 0 9
52610: PUSH
52611: LD_EXP 101
52615: PUSH
52616: LD_VAR 0 2
52620: ARRAY
52621: PPUSH
52622: LD_INT 2
52624: PUSH
52625: LD_INT 30
52627: PUSH
52628: LD_INT 0
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PUSH
52635: LD_INT 30
52637: PUSH
52638: LD_INT 1
52640: PUSH
52641: EMPTY
52642: LIST
52643: LIST
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: LIST
52649: PPUSH
52650: CALL_OW 72
52654: ST_TO_ADDR
// if not tmp or not dep then
52655: LD_VAR 0 8
52659: NOT
52660: PUSH
52661: LD_VAR 0 9
52665: NOT
52666: OR
52667: IFFALSE 52671
// continue ;
52669: GO 52456
// side := GetSide ( tmp [ 1 ] ) ;
52671: LD_ADDR_VAR 0 11
52675: PUSH
52676: LD_VAR 0 8
52680: PUSH
52681: LD_INT 1
52683: ARRAY
52684: PPUSH
52685: CALL_OW 255
52689: ST_TO_ADDR
// dep := dep [ 1 ] ;
52690: LD_ADDR_VAR 0 9
52694: PUSH
52695: LD_VAR 0 9
52699: PUSH
52700: LD_INT 1
52702: ARRAY
52703: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52704: LD_ADDR_VAR 0 7
52708: PUSH
52709: LD_EXP 129
52713: PUSH
52714: LD_VAR 0 2
52718: ARRAY
52719: PPUSH
52720: LD_INT 22
52722: PUSH
52723: LD_INT 0
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: LD_INT 25
52732: PUSH
52733: LD_INT 12
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 70
52748: PUSH
52749: LD_INT 22
52751: PUSH
52752: LD_INT 0
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: LD_INT 25
52761: PUSH
52762: LD_INT 12
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: PUSH
52769: LD_INT 91
52771: PUSH
52772: LD_VAR 0 9
52776: PUSH
52777: LD_INT 20
52779: PUSH
52780: EMPTY
52781: LIST
52782: LIST
52783: LIST
52784: PUSH
52785: EMPTY
52786: LIST
52787: LIST
52788: LIST
52789: PPUSH
52790: CALL_OW 69
52794: UNION
52795: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52796: LD_ADDR_VAR 0 10
52800: PUSH
52801: LD_EXP 129
52805: PUSH
52806: LD_VAR 0 2
52810: ARRAY
52811: PPUSH
52812: LD_INT 81
52814: PUSH
52815: LD_VAR 0 11
52819: PUSH
52820: EMPTY
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 70
52828: ST_TO_ADDR
// if not apes or danger_at_area then
52829: LD_VAR 0 7
52833: NOT
52834: PUSH
52835: LD_VAR 0 10
52839: OR
52840: IFFALSE 52890
// begin if mc_taming [ i ] then
52842: LD_EXP 132
52846: PUSH
52847: LD_VAR 0 2
52851: ARRAY
52852: IFFALSE 52888
// begin MC_Reset ( i , 121 ) ;
52854: LD_VAR 0 2
52858: PPUSH
52859: LD_INT 121
52861: PPUSH
52862: CALL 38325 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52866: LD_ADDR_EXP 132
52870: PUSH
52871: LD_EXP 132
52875: PPUSH
52876: LD_VAR 0 2
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// end ; continue ;
52888: GO 52456
// end ; for j in tmp do
52890: LD_ADDR_VAR 0 3
52894: PUSH
52895: LD_VAR 0 8
52899: PUSH
52900: FOR_IN
52901: IFFALSE 53237
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52903: LD_VAR 0 3
52907: PUSH
52908: LD_EXP 132
52912: PUSH
52913: LD_VAR 0 2
52917: ARRAY
52918: IN
52919: NOT
52920: PUSH
52921: LD_EXP 132
52925: PUSH
52926: LD_VAR 0 2
52930: ARRAY
52931: PUSH
52932: LD_INT 3
52934: LESS
52935: AND
52936: IFFALSE 52994
// begin SetTag ( j , 121 ) ;
52938: LD_VAR 0 3
52942: PPUSH
52943: LD_INT 121
52945: PPUSH
52946: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52950: LD_ADDR_EXP 132
52954: PUSH
52955: LD_EXP 132
52959: PPUSH
52960: LD_VAR 0 2
52964: PUSH
52965: LD_EXP 132
52969: PUSH
52970: LD_VAR 0 2
52974: ARRAY
52975: PUSH
52976: LD_INT 1
52978: PLUS
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: PPUSH
52984: LD_VAR 0 3
52988: PPUSH
52989: CALL 71523 0 3
52993: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52994: LD_VAR 0 3
52998: PUSH
52999: LD_EXP 132
53003: PUSH
53004: LD_VAR 0 2
53008: ARRAY
53009: IN
53010: IFFALSE 53235
// begin if GetClass ( j ) <> 4 then
53012: LD_VAR 0 3
53016: PPUSH
53017: CALL_OW 257
53021: PUSH
53022: LD_INT 4
53024: NONEQUAL
53025: IFFALSE 53078
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53027: LD_ADDR_EXP 132
53031: PUSH
53032: LD_EXP 132
53036: PPUSH
53037: LD_VAR 0 2
53041: PPUSH
53042: LD_EXP 132
53046: PUSH
53047: LD_VAR 0 2
53051: ARRAY
53052: PUSH
53053: LD_VAR 0 3
53057: DIFF
53058: PPUSH
53059: CALL_OW 1
53063: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53064: LD_VAR 0 3
53068: PPUSH
53069: LD_INT 0
53071: PPUSH
53072: CALL_OW 109
// continue ;
53076: GO 52900
// end ; if IsInUnit ( j ) then
53078: LD_VAR 0 3
53082: PPUSH
53083: CALL_OW 310
53087: IFFALSE 53098
// ComExitBuilding ( j ) ;
53089: LD_VAR 0 3
53093: PPUSH
53094: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53098: LD_ADDR_VAR 0 6
53102: PUSH
53103: LD_VAR 0 7
53107: PPUSH
53108: LD_VAR 0 3
53112: PPUSH
53113: CALL_OW 74
53117: ST_TO_ADDR
// if not ape then
53118: LD_VAR 0 6
53122: NOT
53123: IFFALSE 53127
// break ;
53125: GO 53237
// x := GetX ( ape ) ;
53127: LD_ADDR_VAR 0 4
53131: PUSH
53132: LD_VAR 0 6
53136: PPUSH
53137: CALL_OW 250
53141: ST_TO_ADDR
// y := GetY ( ape ) ;
53142: LD_ADDR_VAR 0 5
53146: PUSH
53147: LD_VAR 0 6
53151: PPUSH
53152: CALL_OW 251
53156: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53157: LD_VAR 0 4
53161: PPUSH
53162: LD_VAR 0 5
53166: PPUSH
53167: CALL_OW 488
53171: NOT
53172: PUSH
53173: LD_VAR 0 11
53177: PPUSH
53178: LD_VAR 0 4
53182: PPUSH
53183: LD_VAR 0 5
53187: PPUSH
53188: LD_INT 20
53190: PPUSH
53191: CALL 72419 0 4
53195: PUSH
53196: LD_INT 4
53198: ARRAY
53199: OR
53200: IFFALSE 53204
// break ;
53202: GO 53237
// if not HasTask ( j ) then
53204: LD_VAR 0 3
53208: PPUSH
53209: CALL_OW 314
53213: NOT
53214: IFFALSE 53235
// ComTameXY ( j , x , y ) ;
53216: LD_VAR 0 3
53220: PPUSH
53221: LD_VAR 0 4
53225: PPUSH
53226: LD_VAR 0 5
53230: PPUSH
53231: CALL_OW 131
// end ; end ;
53235: GO 52900
53237: POP
53238: POP
// end ;
53239: GO 52456
53241: POP
53242: POP
// end ;
53243: LD_VAR 0 1
53247: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53248: LD_INT 0
53250: PPUSH
53251: PPUSH
53252: PPUSH
53253: PPUSH
53254: PPUSH
53255: PPUSH
53256: PPUSH
53257: PPUSH
// if not mc_bases then
53258: LD_EXP 101
53262: NOT
53263: IFFALSE 53267
// exit ;
53265: GO 53893
// for i = 1 to mc_bases do
53267: LD_ADDR_VAR 0 2
53271: PUSH
53272: DOUBLE
53273: LD_INT 1
53275: DEC
53276: ST_TO_ADDR
53277: LD_EXP 101
53281: PUSH
53282: FOR_TO
53283: IFFALSE 53891
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53285: LD_EXP 130
53289: PUSH
53290: LD_VAR 0 2
53294: ARRAY
53295: NOT
53296: PUSH
53297: LD_EXP 130
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PPUSH
53308: LD_INT 25
53310: PUSH
53311: LD_INT 12
53313: PUSH
53314: EMPTY
53315: LIST
53316: LIST
53317: PPUSH
53318: CALL_OW 72
53322: NOT
53323: OR
53324: IFFALSE 53328
// continue ;
53326: GO 53282
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53328: LD_ADDR_VAR 0 5
53332: PUSH
53333: LD_EXP 130
53337: PUSH
53338: LD_VAR 0 2
53342: ARRAY
53343: PUSH
53344: LD_INT 1
53346: ARRAY
53347: PPUSH
53348: CALL_OW 255
53352: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53353: LD_VAR 0 5
53357: PPUSH
53358: LD_INT 2
53360: PPUSH
53361: CALL_OW 325
53365: IFFALSE 53618
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53367: LD_ADDR_VAR 0 4
53371: PUSH
53372: LD_EXP 130
53376: PUSH
53377: LD_VAR 0 2
53381: ARRAY
53382: PPUSH
53383: LD_INT 25
53385: PUSH
53386: LD_INT 16
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: PPUSH
53393: CALL_OW 72
53397: ST_TO_ADDR
// if tmp < 6 then
53398: LD_VAR 0 4
53402: PUSH
53403: LD_INT 6
53405: LESS
53406: IFFALSE 53618
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53408: LD_ADDR_VAR 0 6
53412: PUSH
53413: LD_EXP 101
53417: PUSH
53418: LD_VAR 0 2
53422: ARRAY
53423: PPUSH
53424: LD_INT 2
53426: PUSH
53427: LD_INT 30
53429: PUSH
53430: LD_INT 0
53432: PUSH
53433: EMPTY
53434: LIST
53435: LIST
53436: PUSH
53437: LD_INT 30
53439: PUSH
53440: LD_INT 1
53442: PUSH
53443: EMPTY
53444: LIST
53445: LIST
53446: PUSH
53447: EMPTY
53448: LIST
53449: LIST
53450: LIST
53451: PPUSH
53452: CALL_OW 72
53456: ST_TO_ADDR
// if depot then
53457: LD_VAR 0 6
53461: IFFALSE 53618
// begin selected := 0 ;
53463: LD_ADDR_VAR 0 7
53467: PUSH
53468: LD_INT 0
53470: ST_TO_ADDR
// for j in depot do
53471: LD_ADDR_VAR 0 3
53475: PUSH
53476: LD_VAR 0 6
53480: PUSH
53481: FOR_IN
53482: IFFALSE 53513
// begin if UnitsInside ( j ) < 6 then
53484: LD_VAR 0 3
53488: PPUSH
53489: CALL_OW 313
53493: PUSH
53494: LD_INT 6
53496: LESS
53497: IFFALSE 53511
// begin selected := j ;
53499: LD_ADDR_VAR 0 7
53503: PUSH
53504: LD_VAR 0 3
53508: ST_TO_ADDR
// break ;
53509: GO 53513
// end ; end ;
53511: GO 53481
53513: POP
53514: POP
// if selected then
53515: LD_VAR 0 7
53519: IFFALSE 53618
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53521: LD_ADDR_VAR 0 3
53525: PUSH
53526: LD_EXP 130
53530: PUSH
53531: LD_VAR 0 2
53535: ARRAY
53536: PPUSH
53537: LD_INT 25
53539: PUSH
53540: LD_INT 12
53542: PUSH
53543: EMPTY
53544: LIST
53545: LIST
53546: PPUSH
53547: CALL_OW 72
53551: PUSH
53552: FOR_IN
53553: IFFALSE 53616
// if not HasTask ( j ) then
53555: LD_VAR 0 3
53559: PPUSH
53560: CALL_OW 314
53564: NOT
53565: IFFALSE 53614
// begin if not IsInUnit ( j ) then
53567: LD_VAR 0 3
53571: PPUSH
53572: CALL_OW 310
53576: NOT
53577: IFFALSE 53593
// ComEnterUnit ( j , selected ) ;
53579: LD_VAR 0 3
53583: PPUSH
53584: LD_VAR 0 7
53588: PPUSH
53589: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53593: LD_VAR 0 3
53597: PPUSH
53598: LD_INT 16
53600: PPUSH
53601: CALL_OW 183
// AddComExitBuilding ( j ) ;
53605: LD_VAR 0 3
53609: PPUSH
53610: CALL_OW 182
// end ;
53614: GO 53552
53616: POP
53617: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53618: LD_VAR 0 5
53622: PPUSH
53623: LD_INT 11
53625: PPUSH
53626: CALL_OW 325
53630: IFFALSE 53889
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53632: LD_ADDR_VAR 0 4
53636: PUSH
53637: LD_EXP 130
53641: PUSH
53642: LD_VAR 0 2
53646: ARRAY
53647: PPUSH
53648: LD_INT 25
53650: PUSH
53651: LD_INT 16
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: PPUSH
53658: CALL_OW 72
53662: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53663: LD_VAR 0 4
53667: PUSH
53668: LD_INT 6
53670: GREATEREQUAL
53671: PUSH
53672: LD_VAR 0 5
53676: PPUSH
53677: LD_INT 2
53679: PPUSH
53680: CALL_OW 325
53684: NOT
53685: OR
53686: IFFALSE 53889
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53688: LD_ADDR_VAR 0 8
53692: PUSH
53693: LD_EXP 101
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: PPUSH
53704: LD_INT 2
53706: PUSH
53707: LD_INT 30
53709: PUSH
53710: LD_INT 4
53712: PUSH
53713: EMPTY
53714: LIST
53715: LIST
53716: PUSH
53717: LD_INT 30
53719: PUSH
53720: LD_INT 5
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PUSH
53727: EMPTY
53728: LIST
53729: LIST
53730: LIST
53731: PPUSH
53732: CALL_OW 72
53736: ST_TO_ADDR
// if barracks then
53737: LD_VAR 0 8
53741: IFFALSE 53889
// begin selected := 0 ;
53743: LD_ADDR_VAR 0 7
53747: PUSH
53748: LD_INT 0
53750: ST_TO_ADDR
// for j in barracks do
53751: LD_ADDR_VAR 0 3
53755: PUSH
53756: LD_VAR 0 8
53760: PUSH
53761: FOR_IN
53762: IFFALSE 53793
// begin if UnitsInside ( j ) < 6 then
53764: LD_VAR 0 3
53768: PPUSH
53769: CALL_OW 313
53773: PUSH
53774: LD_INT 6
53776: LESS
53777: IFFALSE 53791
// begin selected := j ;
53779: LD_ADDR_VAR 0 7
53783: PUSH
53784: LD_VAR 0 3
53788: ST_TO_ADDR
// break ;
53789: GO 53793
// end ; end ;
53791: GO 53761
53793: POP
53794: POP
// if selected then
53795: LD_VAR 0 7
53799: IFFALSE 53889
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53801: LD_ADDR_VAR 0 3
53805: PUSH
53806: LD_EXP 130
53810: PUSH
53811: LD_VAR 0 2
53815: ARRAY
53816: PPUSH
53817: LD_INT 25
53819: PUSH
53820: LD_INT 12
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PPUSH
53827: CALL_OW 72
53831: PUSH
53832: FOR_IN
53833: IFFALSE 53887
// if not IsInUnit ( j ) and not HasTask ( j ) then
53835: LD_VAR 0 3
53839: PPUSH
53840: CALL_OW 310
53844: NOT
53845: PUSH
53846: LD_VAR 0 3
53850: PPUSH
53851: CALL_OW 314
53855: NOT
53856: AND
53857: IFFALSE 53885
// begin ComEnterUnit ( j , selected ) ;
53859: LD_VAR 0 3
53863: PPUSH
53864: LD_VAR 0 7
53868: PPUSH
53869: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53873: LD_VAR 0 3
53877: PPUSH
53878: LD_INT 15
53880: PPUSH
53881: CALL_OW 183
// end ;
53885: GO 53832
53887: POP
53888: POP
// end ; end ; end ; end ; end ;
53889: GO 53282
53891: POP
53892: POP
// end ;
53893: LD_VAR 0 1
53897: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53898: LD_INT 0
53900: PPUSH
53901: PPUSH
53902: PPUSH
53903: PPUSH
// if not mc_bases then
53904: LD_EXP 101
53908: NOT
53909: IFFALSE 53913
// exit ;
53911: GO 54091
// for i = 1 to mc_bases do
53913: LD_ADDR_VAR 0 2
53917: PUSH
53918: DOUBLE
53919: LD_INT 1
53921: DEC
53922: ST_TO_ADDR
53923: LD_EXP 101
53927: PUSH
53928: FOR_TO
53929: IFFALSE 54089
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53931: LD_ADDR_VAR 0 4
53935: PUSH
53936: LD_EXP 101
53940: PUSH
53941: LD_VAR 0 2
53945: ARRAY
53946: PPUSH
53947: LD_INT 25
53949: PUSH
53950: LD_INT 9
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PPUSH
53957: CALL_OW 72
53961: ST_TO_ADDR
// if not tmp then
53962: LD_VAR 0 4
53966: NOT
53967: IFFALSE 53971
// continue ;
53969: GO 53928
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53971: LD_EXP 127
53975: PUSH
53976: LD_VAR 0 2
53980: ARRAY
53981: PPUSH
53982: LD_INT 29
53984: PPUSH
53985: CALL_OW 325
53989: NOT
53990: PUSH
53991: LD_EXP 127
53995: PUSH
53996: LD_VAR 0 2
54000: ARRAY
54001: PPUSH
54002: LD_INT 28
54004: PPUSH
54005: CALL_OW 325
54009: NOT
54010: AND
54011: IFFALSE 54015
// continue ;
54013: GO 53928
// for j in tmp do
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_VAR 0 4
54024: PUSH
54025: FOR_IN
54026: IFFALSE 54085
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54028: LD_VAR 0 3
54032: PUSH
54033: LD_EXP 104
54037: PUSH
54038: LD_VAR 0 2
54042: ARRAY
54043: PUSH
54044: LD_INT 1
54046: ARRAY
54047: IN
54048: NOT
54049: PUSH
54050: LD_VAR 0 3
54054: PUSH
54055: LD_EXP 104
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: PUSH
54066: LD_INT 2
54068: ARRAY
54069: IN
54070: NOT
54071: AND
54072: IFFALSE 54083
// ComSpaceTimeShoot ( j ) ;
54074: LD_VAR 0 3
54078: PPUSH
54079: CALL 65109 0 1
54083: GO 54025
54085: POP
54086: POP
// end ;
54087: GO 53928
54089: POP
54090: POP
// end ;
54091: LD_VAR 0 1
54095: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54096: LD_INT 0
54098: PPUSH
54099: PPUSH
54100: PPUSH
54101: PPUSH
54102: PPUSH
54103: PPUSH
54104: PPUSH
54105: PPUSH
54106: PPUSH
// if not mc_bases then
54107: LD_EXP 101
54111: NOT
54112: IFFALSE 54116
// exit ;
54114: GO 54738
// for i = 1 to mc_bases do
54116: LD_ADDR_VAR 0 2
54120: PUSH
54121: DOUBLE
54122: LD_INT 1
54124: DEC
54125: ST_TO_ADDR
54126: LD_EXP 101
54130: PUSH
54131: FOR_TO
54132: IFFALSE 54736
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54134: LD_EXP 136
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: NOT
54145: PUSH
54146: LD_INT 38
54148: PPUSH
54149: LD_EXP 127
54153: PUSH
54154: LD_VAR 0 2
54158: ARRAY
54159: PPUSH
54160: CALL_OW 321
54164: PUSH
54165: LD_INT 2
54167: NONEQUAL
54168: OR
54169: IFFALSE 54173
// continue ;
54171: GO 54131
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54173: LD_ADDR_VAR 0 8
54177: PUSH
54178: LD_EXP 101
54182: PUSH
54183: LD_VAR 0 2
54187: ARRAY
54188: PPUSH
54189: LD_INT 30
54191: PUSH
54192: LD_INT 34
54194: PUSH
54195: EMPTY
54196: LIST
54197: LIST
54198: PPUSH
54199: CALL_OW 72
54203: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54204: LD_ADDR_VAR 0 9
54208: PUSH
54209: LD_EXP 101
54213: PUSH
54214: LD_VAR 0 2
54218: ARRAY
54219: PPUSH
54220: LD_INT 25
54222: PUSH
54223: LD_INT 4
54225: PUSH
54226: EMPTY
54227: LIST
54228: LIST
54229: PPUSH
54230: CALL_OW 72
54234: PPUSH
54235: LD_INT 0
54237: PPUSH
54238: CALL 104786 0 2
54242: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54243: LD_VAR 0 9
54247: NOT
54248: PUSH
54249: LD_VAR 0 8
54253: NOT
54254: OR
54255: PUSH
54256: LD_EXP 101
54260: PUSH
54261: LD_VAR 0 2
54265: ARRAY
54266: PPUSH
54267: LD_INT 124
54269: PPUSH
54270: CALL 104786 0 2
54274: OR
54275: IFFALSE 54279
// continue ;
54277: GO 54131
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54279: LD_EXP 137
54283: PUSH
54284: LD_VAR 0 2
54288: ARRAY
54289: PUSH
54290: LD_EXP 136
54294: PUSH
54295: LD_VAR 0 2
54299: ARRAY
54300: LESS
54301: PUSH
54302: LD_EXP 137
54306: PUSH
54307: LD_VAR 0 2
54311: ARRAY
54312: PUSH
54313: LD_VAR 0 8
54317: LESS
54318: AND
54319: IFFALSE 54734
// begin tmp := sci [ 1 ] ;
54321: LD_ADDR_VAR 0 7
54325: PUSH
54326: LD_VAR 0 9
54330: PUSH
54331: LD_INT 1
54333: ARRAY
54334: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54335: LD_VAR 0 7
54339: PPUSH
54340: LD_INT 124
54342: PPUSH
54343: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54347: LD_ADDR_VAR 0 3
54351: PUSH
54352: DOUBLE
54353: LD_EXP 136
54357: PUSH
54358: LD_VAR 0 2
54362: ARRAY
54363: INC
54364: ST_TO_ADDR
54365: LD_EXP 136
54369: PUSH
54370: LD_VAR 0 2
54374: ARRAY
54375: PUSH
54376: FOR_DOWNTO
54377: IFFALSE 54720
// begin if IsInUnit ( tmp ) then
54379: LD_VAR 0 7
54383: PPUSH
54384: CALL_OW 310
54388: IFFALSE 54399
// ComExitBuilding ( tmp ) ;
54390: LD_VAR 0 7
54394: PPUSH
54395: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54399: LD_INT 35
54401: PPUSH
54402: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54406: LD_VAR 0 7
54410: PPUSH
54411: CALL_OW 310
54415: NOT
54416: PUSH
54417: LD_VAR 0 7
54421: PPUSH
54422: CALL_OW 314
54426: NOT
54427: AND
54428: IFFALSE 54399
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54430: LD_ADDR_VAR 0 6
54434: PUSH
54435: LD_VAR 0 7
54439: PPUSH
54440: CALL_OW 250
54444: PUSH
54445: LD_VAR 0 7
54449: PPUSH
54450: CALL_OW 251
54454: PUSH
54455: EMPTY
54456: LIST
54457: LIST
54458: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54459: LD_INT 35
54461: PPUSH
54462: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54466: LD_ADDR_VAR 0 4
54470: PUSH
54471: LD_EXP 136
54475: PUSH
54476: LD_VAR 0 2
54480: ARRAY
54481: PUSH
54482: LD_VAR 0 3
54486: ARRAY
54487: PUSH
54488: LD_INT 1
54490: ARRAY
54491: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54492: LD_ADDR_VAR 0 5
54496: PUSH
54497: LD_EXP 136
54501: PUSH
54502: LD_VAR 0 2
54506: ARRAY
54507: PUSH
54508: LD_VAR 0 3
54512: ARRAY
54513: PUSH
54514: LD_INT 2
54516: ARRAY
54517: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54518: LD_VAR 0 7
54522: PPUSH
54523: LD_INT 10
54525: PPUSH
54526: CALL 74116 0 2
54530: PUSH
54531: LD_INT 4
54533: ARRAY
54534: IFFALSE 54572
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54536: LD_VAR 0 7
54540: PPUSH
54541: LD_VAR 0 6
54545: PUSH
54546: LD_INT 1
54548: ARRAY
54549: PPUSH
54550: LD_VAR 0 6
54554: PUSH
54555: LD_INT 2
54557: ARRAY
54558: PPUSH
54559: CALL_OW 111
// wait ( 0 0$10 ) ;
54563: LD_INT 350
54565: PPUSH
54566: CALL_OW 67
// end else
54570: GO 54598
// begin ComMoveXY ( tmp , x , y ) ;
54572: LD_VAR 0 7
54576: PPUSH
54577: LD_VAR 0 4
54581: PPUSH
54582: LD_VAR 0 5
54586: PPUSH
54587: CALL_OW 111
// wait ( 0 0$3 ) ;
54591: LD_INT 105
54593: PPUSH
54594: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54598: LD_VAR 0 7
54602: PPUSH
54603: LD_VAR 0 4
54607: PPUSH
54608: LD_VAR 0 5
54612: PPUSH
54613: CALL_OW 307
54617: IFFALSE 54459
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54619: LD_VAR 0 7
54623: PPUSH
54624: LD_VAR 0 4
54628: PPUSH
54629: LD_VAR 0 5
54633: PPUSH
54634: LD_VAR 0 8
54638: PUSH
54639: LD_VAR 0 3
54643: ARRAY
54644: PPUSH
54645: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54649: LD_INT 35
54651: PPUSH
54652: CALL_OW 67
// until not HasTask ( tmp ) ;
54656: LD_VAR 0 7
54660: PPUSH
54661: CALL_OW 314
54665: NOT
54666: IFFALSE 54649
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54668: LD_ADDR_EXP 137
54672: PUSH
54673: LD_EXP 137
54677: PPUSH
54678: LD_VAR 0 2
54682: PUSH
54683: LD_EXP 137
54687: PUSH
54688: LD_VAR 0 2
54692: ARRAY
54693: PUSH
54694: LD_INT 1
54696: PLUS
54697: PUSH
54698: EMPTY
54699: LIST
54700: LIST
54701: PPUSH
54702: LD_VAR 0 8
54706: PUSH
54707: LD_VAR 0 3
54711: ARRAY
54712: PPUSH
54713: CALL 71523 0 3
54717: ST_TO_ADDR
// end ;
54718: GO 54376
54720: POP
54721: POP
// MC_Reset ( i , 124 ) ;
54722: LD_VAR 0 2
54726: PPUSH
54727: LD_INT 124
54729: PPUSH
54730: CALL 38325 0 2
// end ; end ;
54734: GO 54131
54736: POP
54737: POP
// end ;
54738: LD_VAR 0 1
54742: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54743: LD_INT 0
54745: PPUSH
54746: PPUSH
54747: PPUSH
// if not mc_bases then
54748: LD_EXP 101
54752: NOT
54753: IFFALSE 54757
// exit ;
54755: GO 55363
// for i = 1 to mc_bases do
54757: LD_ADDR_VAR 0 2
54761: PUSH
54762: DOUBLE
54763: LD_INT 1
54765: DEC
54766: ST_TO_ADDR
54767: LD_EXP 101
54771: PUSH
54772: FOR_TO
54773: IFFALSE 55361
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54775: LD_ADDR_VAR 0 3
54779: PUSH
54780: LD_EXP 101
54784: PUSH
54785: LD_VAR 0 2
54789: ARRAY
54790: PPUSH
54791: LD_INT 25
54793: PUSH
54794: LD_INT 4
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: PPUSH
54801: CALL_OW 72
54805: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54806: LD_VAR 0 3
54810: NOT
54811: PUSH
54812: LD_EXP 138
54816: PUSH
54817: LD_VAR 0 2
54821: ARRAY
54822: NOT
54823: OR
54824: PUSH
54825: LD_EXP 101
54829: PUSH
54830: LD_VAR 0 2
54834: ARRAY
54835: PPUSH
54836: LD_INT 2
54838: PUSH
54839: LD_INT 30
54841: PUSH
54842: LD_INT 0
54844: PUSH
54845: EMPTY
54846: LIST
54847: LIST
54848: PUSH
54849: LD_INT 30
54851: PUSH
54852: LD_INT 1
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: PPUSH
54864: CALL_OW 72
54868: NOT
54869: OR
54870: IFFALSE 54920
// begin if mc_deposits_finder [ i ] then
54872: LD_EXP 139
54876: PUSH
54877: LD_VAR 0 2
54881: ARRAY
54882: IFFALSE 54918
// begin MC_Reset ( i , 125 ) ;
54884: LD_VAR 0 2
54888: PPUSH
54889: LD_INT 125
54891: PPUSH
54892: CALL 38325 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54896: LD_ADDR_EXP 139
54900: PUSH
54901: LD_EXP 139
54905: PPUSH
54906: LD_VAR 0 2
54910: PPUSH
54911: EMPTY
54912: PPUSH
54913: CALL_OW 1
54917: ST_TO_ADDR
// end ; continue ;
54918: GO 54772
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54920: LD_EXP 138
54924: PUSH
54925: LD_VAR 0 2
54929: ARRAY
54930: PUSH
54931: LD_INT 1
54933: ARRAY
54934: PUSH
54935: LD_INT 3
54937: ARRAY
54938: PUSH
54939: LD_INT 1
54941: EQUAL
54942: PUSH
54943: LD_INT 20
54945: PPUSH
54946: LD_EXP 127
54950: PUSH
54951: LD_VAR 0 2
54955: ARRAY
54956: PPUSH
54957: CALL_OW 321
54961: PUSH
54962: LD_INT 2
54964: NONEQUAL
54965: AND
54966: IFFALSE 55016
// begin if mc_deposits_finder [ i ] then
54968: LD_EXP 139
54972: PUSH
54973: LD_VAR 0 2
54977: ARRAY
54978: IFFALSE 55014
// begin MC_Reset ( i , 125 ) ;
54980: LD_VAR 0 2
54984: PPUSH
54985: LD_INT 125
54987: PPUSH
54988: CALL 38325 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54992: LD_ADDR_EXP 139
54996: PUSH
54997: LD_EXP 139
55001: PPUSH
55002: LD_VAR 0 2
55006: PPUSH
55007: EMPTY
55008: PPUSH
55009: CALL_OW 1
55013: ST_TO_ADDR
// end ; continue ;
55014: GO 54772
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55016: LD_EXP 138
55020: PUSH
55021: LD_VAR 0 2
55025: ARRAY
55026: PUSH
55027: LD_INT 1
55029: ARRAY
55030: PUSH
55031: LD_INT 1
55033: ARRAY
55034: PPUSH
55035: LD_EXP 138
55039: PUSH
55040: LD_VAR 0 2
55044: ARRAY
55045: PUSH
55046: LD_INT 1
55048: ARRAY
55049: PUSH
55050: LD_INT 2
55052: ARRAY
55053: PPUSH
55054: LD_EXP 127
55058: PUSH
55059: LD_VAR 0 2
55063: ARRAY
55064: PPUSH
55065: CALL_OW 440
55069: IFFALSE 55112
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55071: LD_ADDR_EXP 138
55075: PUSH
55076: LD_EXP 138
55080: PPUSH
55081: LD_VAR 0 2
55085: PPUSH
55086: LD_EXP 138
55090: PUSH
55091: LD_VAR 0 2
55095: ARRAY
55096: PPUSH
55097: LD_INT 1
55099: PPUSH
55100: CALL_OW 3
55104: PPUSH
55105: CALL_OW 1
55109: ST_TO_ADDR
55110: GO 55359
// begin if not mc_deposits_finder [ i ] then
55112: LD_EXP 139
55116: PUSH
55117: LD_VAR 0 2
55121: ARRAY
55122: NOT
55123: IFFALSE 55175
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55125: LD_ADDR_EXP 139
55129: PUSH
55130: LD_EXP 139
55134: PPUSH
55135: LD_VAR 0 2
55139: PPUSH
55140: LD_VAR 0 3
55144: PUSH
55145: LD_INT 1
55147: ARRAY
55148: PUSH
55149: EMPTY
55150: LIST
55151: PPUSH
55152: CALL_OW 1
55156: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55157: LD_VAR 0 3
55161: PUSH
55162: LD_INT 1
55164: ARRAY
55165: PPUSH
55166: LD_INT 125
55168: PPUSH
55169: CALL_OW 109
// end else
55173: GO 55359
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55175: LD_EXP 139
55179: PUSH
55180: LD_VAR 0 2
55184: ARRAY
55185: PUSH
55186: LD_INT 1
55188: ARRAY
55189: PPUSH
55190: CALL_OW 310
55194: IFFALSE 55217
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55196: LD_EXP 139
55200: PUSH
55201: LD_VAR 0 2
55205: ARRAY
55206: PUSH
55207: LD_INT 1
55209: ARRAY
55210: PPUSH
55211: CALL_OW 122
55215: GO 55359
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55217: LD_EXP 139
55221: PUSH
55222: LD_VAR 0 2
55226: ARRAY
55227: PUSH
55228: LD_INT 1
55230: ARRAY
55231: PPUSH
55232: CALL_OW 314
55236: NOT
55237: PUSH
55238: LD_EXP 139
55242: PUSH
55243: LD_VAR 0 2
55247: ARRAY
55248: PUSH
55249: LD_INT 1
55251: ARRAY
55252: PPUSH
55253: LD_EXP 138
55257: PUSH
55258: LD_VAR 0 2
55262: ARRAY
55263: PUSH
55264: LD_INT 1
55266: ARRAY
55267: PUSH
55268: LD_INT 1
55270: ARRAY
55271: PPUSH
55272: LD_EXP 138
55276: PUSH
55277: LD_VAR 0 2
55281: ARRAY
55282: PUSH
55283: LD_INT 1
55285: ARRAY
55286: PUSH
55287: LD_INT 2
55289: ARRAY
55290: PPUSH
55291: CALL_OW 297
55295: PUSH
55296: LD_INT 6
55298: GREATER
55299: AND
55300: IFFALSE 55359
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55302: LD_EXP 139
55306: PUSH
55307: LD_VAR 0 2
55311: ARRAY
55312: PUSH
55313: LD_INT 1
55315: ARRAY
55316: PPUSH
55317: LD_EXP 138
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PUSH
55328: LD_INT 1
55330: ARRAY
55331: PUSH
55332: LD_INT 1
55334: ARRAY
55335: PPUSH
55336: LD_EXP 138
55340: PUSH
55341: LD_VAR 0 2
55345: ARRAY
55346: PUSH
55347: LD_INT 1
55349: ARRAY
55350: PUSH
55351: LD_INT 2
55353: ARRAY
55354: PPUSH
55355: CALL_OW 111
// end ; end ; end ;
55359: GO 54772
55361: POP
55362: POP
// end ;
55363: LD_VAR 0 1
55367: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55368: LD_INT 0
55370: PPUSH
55371: PPUSH
55372: PPUSH
55373: PPUSH
55374: PPUSH
55375: PPUSH
55376: PPUSH
55377: PPUSH
55378: PPUSH
55379: PPUSH
55380: PPUSH
// if not mc_bases then
55381: LD_EXP 101
55385: NOT
55386: IFFALSE 55390
// exit ;
55388: GO 56330
// for i = 1 to mc_bases do
55390: LD_ADDR_VAR 0 2
55394: PUSH
55395: DOUBLE
55396: LD_INT 1
55398: DEC
55399: ST_TO_ADDR
55400: LD_EXP 101
55404: PUSH
55405: FOR_TO
55406: IFFALSE 56328
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55408: LD_EXP 101
55412: PUSH
55413: LD_VAR 0 2
55417: ARRAY
55418: NOT
55419: PUSH
55420: LD_EXP 124
55424: PUSH
55425: LD_VAR 0 2
55429: ARRAY
55430: OR
55431: IFFALSE 55435
// continue ;
55433: GO 55405
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55435: LD_ADDR_VAR 0 7
55439: PUSH
55440: LD_EXP 101
55444: PUSH
55445: LD_VAR 0 2
55449: ARRAY
55450: PUSH
55451: LD_INT 1
55453: ARRAY
55454: PPUSH
55455: CALL_OW 248
55459: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55460: LD_VAR 0 7
55464: PUSH
55465: LD_INT 3
55467: EQUAL
55468: PUSH
55469: LD_EXP 120
55473: PUSH
55474: LD_VAR 0 2
55478: ARRAY
55479: PUSH
55480: LD_EXP 123
55484: PUSH
55485: LD_VAR 0 2
55489: ARRAY
55490: UNION
55491: PPUSH
55492: LD_INT 33
55494: PUSH
55495: LD_INT 2
55497: PUSH
55498: EMPTY
55499: LIST
55500: LIST
55501: PPUSH
55502: CALL_OW 72
55506: NOT
55507: OR
55508: IFFALSE 55512
// continue ;
55510: GO 55405
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55512: LD_ADDR_VAR 0 9
55516: PUSH
55517: LD_EXP 101
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PPUSH
55528: LD_INT 30
55530: PUSH
55531: LD_INT 36
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: PPUSH
55538: CALL_OW 72
55542: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55543: LD_ADDR_VAR 0 10
55547: PUSH
55548: LD_EXP 120
55552: PUSH
55553: LD_VAR 0 2
55557: ARRAY
55558: PPUSH
55559: LD_INT 34
55561: PUSH
55562: LD_INT 31
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: PPUSH
55569: CALL_OW 72
55573: ST_TO_ADDR
// if not cts and not mcts then
55574: LD_VAR 0 9
55578: NOT
55579: PUSH
55580: LD_VAR 0 10
55584: NOT
55585: AND
55586: IFFALSE 55590
// continue ;
55588: GO 55405
// x := cts ;
55590: LD_ADDR_VAR 0 11
55594: PUSH
55595: LD_VAR 0 9
55599: ST_TO_ADDR
// if not x then
55600: LD_VAR 0 11
55604: NOT
55605: IFFALSE 55617
// x := mcts ;
55607: LD_ADDR_VAR 0 11
55611: PUSH
55612: LD_VAR 0 10
55616: ST_TO_ADDR
// if not x then
55617: LD_VAR 0 11
55621: NOT
55622: IFFALSE 55626
// continue ;
55624: GO 55405
// if mc_remote_driver [ i ] then
55626: LD_EXP 141
55630: PUSH
55631: LD_VAR 0 2
55635: ARRAY
55636: IFFALSE 56023
// for j in mc_remote_driver [ i ] do
55638: LD_ADDR_VAR 0 3
55642: PUSH
55643: LD_EXP 141
55647: PUSH
55648: LD_VAR 0 2
55652: ARRAY
55653: PUSH
55654: FOR_IN
55655: IFFALSE 56021
// begin if GetClass ( j ) <> 3 then
55657: LD_VAR 0 3
55661: PPUSH
55662: CALL_OW 257
55666: PUSH
55667: LD_INT 3
55669: NONEQUAL
55670: IFFALSE 55723
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55672: LD_ADDR_EXP 141
55676: PUSH
55677: LD_EXP 141
55681: PPUSH
55682: LD_VAR 0 2
55686: PPUSH
55687: LD_EXP 141
55691: PUSH
55692: LD_VAR 0 2
55696: ARRAY
55697: PUSH
55698: LD_VAR 0 3
55702: DIFF
55703: PPUSH
55704: CALL_OW 1
55708: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55709: LD_VAR 0 3
55713: PPUSH
55714: LD_INT 0
55716: PPUSH
55717: CALL_OW 109
// continue ;
55721: GO 55654
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55723: LD_EXP 120
55727: PUSH
55728: LD_VAR 0 2
55732: ARRAY
55733: PPUSH
55734: LD_INT 34
55736: PUSH
55737: LD_INT 31
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: PUSH
55744: LD_INT 58
55746: PUSH
55747: EMPTY
55748: LIST
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: PPUSH
55754: CALL_OW 72
55758: PUSH
55759: LD_VAR 0 3
55763: PPUSH
55764: CALL 104874 0 1
55768: NOT
55769: AND
55770: IFFALSE 55841
// begin if IsInUnit ( j ) then
55772: LD_VAR 0 3
55776: PPUSH
55777: CALL_OW 310
55781: IFFALSE 55792
// ComExitBuilding ( j ) ;
55783: LD_VAR 0 3
55787: PPUSH
55788: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55792: LD_VAR 0 3
55796: PPUSH
55797: LD_EXP 120
55801: PUSH
55802: LD_VAR 0 2
55806: ARRAY
55807: PPUSH
55808: LD_INT 34
55810: PUSH
55811: LD_INT 31
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: PUSH
55818: LD_INT 58
55820: PUSH
55821: EMPTY
55822: LIST
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: PPUSH
55828: CALL_OW 72
55832: PUSH
55833: LD_INT 1
55835: ARRAY
55836: PPUSH
55837: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55841: LD_VAR 0 3
55845: PPUSH
55846: CALL_OW 310
55850: NOT
55851: PUSH
55852: LD_VAR 0 3
55856: PPUSH
55857: CALL_OW 310
55861: PPUSH
55862: CALL_OW 266
55866: PUSH
55867: LD_INT 36
55869: NONEQUAL
55870: PUSH
55871: LD_VAR 0 3
55875: PPUSH
55876: CALL 104874 0 1
55880: NOT
55881: AND
55882: OR
55883: IFFALSE 56019
// begin if IsInUnit ( j ) then
55885: LD_VAR 0 3
55889: PPUSH
55890: CALL_OW 310
55894: IFFALSE 55905
// ComExitBuilding ( j ) ;
55896: LD_VAR 0 3
55900: PPUSH
55901: CALL_OW 122
// ct := 0 ;
55905: LD_ADDR_VAR 0 8
55909: PUSH
55910: LD_INT 0
55912: ST_TO_ADDR
// for k in x do
55913: LD_ADDR_VAR 0 4
55917: PUSH
55918: LD_VAR 0 11
55922: PUSH
55923: FOR_IN
55924: IFFALSE 55997
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55926: LD_VAR 0 4
55930: PPUSH
55931: CALL_OW 264
55935: PUSH
55936: LD_INT 31
55938: EQUAL
55939: PUSH
55940: LD_VAR 0 4
55944: PPUSH
55945: CALL_OW 311
55949: NOT
55950: AND
55951: PUSH
55952: LD_VAR 0 4
55956: PPUSH
55957: CALL_OW 266
55961: PUSH
55962: LD_INT 36
55964: EQUAL
55965: PUSH
55966: LD_VAR 0 4
55970: PPUSH
55971: CALL_OW 313
55975: PUSH
55976: LD_INT 3
55978: LESS
55979: AND
55980: OR
55981: IFFALSE 55995
// begin ct := k ;
55983: LD_ADDR_VAR 0 8
55987: PUSH
55988: LD_VAR 0 4
55992: ST_TO_ADDR
// break ;
55993: GO 55997
// end ;
55995: GO 55923
55997: POP
55998: POP
// if ct then
55999: LD_VAR 0 8
56003: IFFALSE 56019
// ComEnterUnit ( j , ct ) ;
56005: LD_VAR 0 3
56009: PPUSH
56010: LD_VAR 0 8
56014: PPUSH
56015: CALL_OW 120
// end ; end ;
56019: GO 55654
56021: POP
56022: POP
// places := 0 ;
56023: LD_ADDR_VAR 0 5
56027: PUSH
56028: LD_INT 0
56030: ST_TO_ADDR
// for j = 1 to x do
56031: LD_ADDR_VAR 0 3
56035: PUSH
56036: DOUBLE
56037: LD_INT 1
56039: DEC
56040: ST_TO_ADDR
56041: LD_VAR 0 11
56045: PUSH
56046: FOR_TO
56047: IFFALSE 56123
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56049: LD_VAR 0 11
56053: PUSH
56054: LD_VAR 0 3
56058: ARRAY
56059: PPUSH
56060: CALL_OW 264
56064: PUSH
56065: LD_INT 31
56067: EQUAL
56068: IFFALSE 56086
// places := places + 1 else
56070: LD_ADDR_VAR 0 5
56074: PUSH
56075: LD_VAR 0 5
56079: PUSH
56080: LD_INT 1
56082: PLUS
56083: ST_TO_ADDR
56084: GO 56121
// if GetBType ( x [ j ] ) = b_control_tower then
56086: LD_VAR 0 11
56090: PUSH
56091: LD_VAR 0 3
56095: ARRAY
56096: PPUSH
56097: CALL_OW 266
56101: PUSH
56102: LD_INT 36
56104: EQUAL
56105: IFFALSE 56121
// places := places + 3 ;
56107: LD_ADDR_VAR 0 5
56111: PUSH
56112: LD_VAR 0 5
56116: PUSH
56117: LD_INT 3
56119: PLUS
56120: ST_TO_ADDR
56121: GO 56046
56123: POP
56124: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56125: LD_VAR 0 5
56129: PUSH
56130: LD_INT 0
56132: EQUAL
56133: PUSH
56134: LD_VAR 0 5
56138: PUSH
56139: LD_EXP 141
56143: PUSH
56144: LD_VAR 0 2
56148: ARRAY
56149: LESSEQUAL
56150: OR
56151: IFFALSE 56155
// continue ;
56153: GO 55405
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56155: LD_ADDR_VAR 0 6
56159: PUSH
56160: LD_EXP 101
56164: PUSH
56165: LD_VAR 0 2
56169: ARRAY
56170: PPUSH
56171: LD_INT 25
56173: PUSH
56174: LD_INT 3
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: PPUSH
56181: CALL_OW 72
56185: PUSH
56186: LD_EXP 141
56190: PUSH
56191: LD_VAR 0 2
56195: ARRAY
56196: DIFF
56197: PPUSH
56198: LD_INT 3
56200: PPUSH
56201: CALL 105774 0 2
56205: ST_TO_ADDR
// for j in tmp do
56206: LD_ADDR_VAR 0 3
56210: PUSH
56211: LD_VAR 0 6
56215: PUSH
56216: FOR_IN
56217: IFFALSE 56252
// if GetTag ( j ) > 0 then
56219: LD_VAR 0 3
56223: PPUSH
56224: CALL_OW 110
56228: PUSH
56229: LD_INT 0
56231: GREATER
56232: IFFALSE 56250
// tmp := tmp diff j ;
56234: LD_ADDR_VAR 0 6
56238: PUSH
56239: LD_VAR 0 6
56243: PUSH
56244: LD_VAR 0 3
56248: DIFF
56249: ST_TO_ADDR
56250: GO 56216
56252: POP
56253: POP
// if not tmp then
56254: LD_VAR 0 6
56258: NOT
56259: IFFALSE 56263
// continue ;
56261: GO 55405
// if places then
56263: LD_VAR 0 5
56267: IFFALSE 56326
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56269: LD_ADDR_EXP 141
56273: PUSH
56274: LD_EXP 141
56278: PPUSH
56279: LD_VAR 0 2
56283: PPUSH
56284: LD_EXP 141
56288: PUSH
56289: LD_VAR 0 2
56293: ARRAY
56294: PUSH
56295: LD_VAR 0 6
56299: PUSH
56300: LD_INT 1
56302: ARRAY
56303: UNION
56304: PPUSH
56305: CALL_OW 1
56309: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56310: LD_VAR 0 6
56314: PUSH
56315: LD_INT 1
56317: ARRAY
56318: PPUSH
56319: LD_INT 126
56321: PPUSH
56322: CALL_OW 109
// end ; end ;
56326: GO 55405
56328: POP
56329: POP
// end ;
56330: LD_VAR 0 1
56334: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56335: LD_INT 0
56337: PPUSH
56338: PPUSH
56339: PPUSH
56340: PPUSH
56341: PPUSH
56342: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56343: LD_VAR 0 1
56347: NOT
56348: PUSH
56349: LD_VAR 0 2
56353: NOT
56354: OR
56355: PUSH
56356: LD_VAR 0 3
56360: NOT
56361: OR
56362: PUSH
56363: LD_VAR 0 4
56367: PUSH
56368: LD_INT 1
56370: PUSH
56371: LD_INT 2
56373: PUSH
56374: LD_INT 3
56376: PUSH
56377: LD_INT 4
56379: PUSH
56380: LD_INT 5
56382: PUSH
56383: LD_INT 8
56385: PUSH
56386: LD_INT 9
56388: PUSH
56389: LD_INT 15
56391: PUSH
56392: LD_INT 16
56394: PUSH
56395: EMPTY
56396: LIST
56397: LIST
56398: LIST
56399: LIST
56400: LIST
56401: LIST
56402: LIST
56403: LIST
56404: LIST
56405: IN
56406: NOT
56407: OR
56408: IFFALSE 56412
// exit ;
56410: GO 57312
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56412: LD_ADDR_VAR 0 2
56416: PUSH
56417: LD_VAR 0 2
56421: PPUSH
56422: LD_INT 21
56424: PUSH
56425: LD_INT 3
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: PUSH
56432: LD_INT 24
56434: PUSH
56435: LD_INT 250
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: PPUSH
56446: CALL_OW 72
56450: ST_TO_ADDR
// case class of 1 , 15 :
56451: LD_VAR 0 4
56455: PUSH
56456: LD_INT 1
56458: DOUBLE
56459: EQUAL
56460: IFTRUE 56470
56462: LD_INT 15
56464: DOUBLE
56465: EQUAL
56466: IFTRUE 56470
56468: GO 56555
56470: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56471: LD_ADDR_VAR 0 8
56475: PUSH
56476: LD_VAR 0 2
56480: PPUSH
56481: LD_INT 2
56483: PUSH
56484: LD_INT 30
56486: PUSH
56487: LD_INT 32
56489: PUSH
56490: EMPTY
56491: LIST
56492: LIST
56493: PUSH
56494: LD_INT 30
56496: PUSH
56497: LD_INT 31
56499: PUSH
56500: EMPTY
56501: LIST
56502: LIST
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: LIST
56508: PPUSH
56509: CALL_OW 72
56513: PUSH
56514: LD_VAR 0 2
56518: PPUSH
56519: LD_INT 2
56521: PUSH
56522: LD_INT 30
56524: PUSH
56525: LD_INT 4
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PUSH
56532: LD_INT 30
56534: PUSH
56535: LD_INT 5
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: LIST
56546: PPUSH
56547: CALL_OW 72
56551: ADD
56552: ST_TO_ADDR
56553: GO 56801
56555: LD_INT 2
56557: DOUBLE
56558: EQUAL
56559: IFTRUE 56569
56561: LD_INT 16
56563: DOUBLE
56564: EQUAL
56565: IFTRUE 56569
56567: GO 56615
56569: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56570: LD_ADDR_VAR 0 8
56574: PUSH
56575: LD_VAR 0 2
56579: PPUSH
56580: LD_INT 2
56582: PUSH
56583: LD_INT 30
56585: PUSH
56586: LD_INT 0
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: PUSH
56593: LD_INT 30
56595: PUSH
56596: LD_INT 1
56598: PUSH
56599: EMPTY
56600: LIST
56601: LIST
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: LIST
56607: PPUSH
56608: CALL_OW 72
56612: ST_TO_ADDR
56613: GO 56801
56615: LD_INT 3
56617: DOUBLE
56618: EQUAL
56619: IFTRUE 56623
56621: GO 56669
56623: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56624: LD_ADDR_VAR 0 8
56628: PUSH
56629: LD_VAR 0 2
56633: PPUSH
56634: LD_INT 2
56636: PUSH
56637: LD_INT 30
56639: PUSH
56640: LD_INT 2
56642: PUSH
56643: EMPTY
56644: LIST
56645: LIST
56646: PUSH
56647: LD_INT 30
56649: PUSH
56650: LD_INT 3
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: PUSH
56657: EMPTY
56658: LIST
56659: LIST
56660: LIST
56661: PPUSH
56662: CALL_OW 72
56666: ST_TO_ADDR
56667: GO 56801
56669: LD_INT 4
56671: DOUBLE
56672: EQUAL
56673: IFTRUE 56677
56675: GO 56734
56677: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56678: LD_ADDR_VAR 0 8
56682: PUSH
56683: LD_VAR 0 2
56687: PPUSH
56688: LD_INT 2
56690: PUSH
56691: LD_INT 30
56693: PUSH
56694: LD_INT 6
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: PUSH
56701: LD_INT 30
56703: PUSH
56704: LD_INT 7
56706: PUSH
56707: EMPTY
56708: LIST
56709: LIST
56710: PUSH
56711: LD_INT 30
56713: PUSH
56714: LD_INT 8
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: PUSH
56721: EMPTY
56722: LIST
56723: LIST
56724: LIST
56725: LIST
56726: PPUSH
56727: CALL_OW 72
56731: ST_TO_ADDR
56732: GO 56801
56734: LD_INT 5
56736: DOUBLE
56737: EQUAL
56738: IFTRUE 56754
56740: LD_INT 8
56742: DOUBLE
56743: EQUAL
56744: IFTRUE 56754
56746: LD_INT 9
56748: DOUBLE
56749: EQUAL
56750: IFTRUE 56754
56752: GO 56800
56754: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56755: LD_ADDR_VAR 0 8
56759: PUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: LD_INT 2
56767: PUSH
56768: LD_INT 30
56770: PUSH
56771: LD_INT 4
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: PUSH
56778: LD_INT 30
56780: PUSH
56781: LD_INT 5
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: LIST
56792: PPUSH
56793: CALL_OW 72
56797: ST_TO_ADDR
56798: GO 56801
56800: POP
// if not tmp then
56801: LD_VAR 0 8
56805: NOT
56806: IFFALSE 56810
// exit ;
56808: GO 57312
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56810: LD_VAR 0 4
56814: PUSH
56815: LD_INT 1
56817: PUSH
56818: LD_INT 15
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: IN
56825: PUSH
56826: LD_EXP 110
56830: PUSH
56831: LD_VAR 0 1
56835: ARRAY
56836: AND
56837: IFFALSE 56993
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56839: LD_ADDR_VAR 0 9
56843: PUSH
56844: LD_EXP 110
56848: PUSH
56849: LD_VAR 0 1
56853: ARRAY
56854: PUSH
56855: LD_INT 1
56857: ARRAY
56858: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56859: LD_VAR 0 9
56863: PUSH
56864: LD_EXP 111
56868: PUSH
56869: LD_VAR 0 1
56873: ARRAY
56874: IN
56875: NOT
56876: IFFALSE 56991
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56878: LD_ADDR_EXP 111
56882: PUSH
56883: LD_EXP 111
56887: PPUSH
56888: LD_VAR 0 1
56892: PUSH
56893: LD_EXP 111
56897: PUSH
56898: LD_VAR 0 1
56902: ARRAY
56903: PUSH
56904: LD_INT 1
56906: PLUS
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PPUSH
56912: LD_VAR 0 9
56916: PPUSH
56917: CALL 71523 0 3
56921: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56922: LD_ADDR_EXP 110
56926: PUSH
56927: LD_EXP 110
56931: PPUSH
56932: LD_VAR 0 1
56936: PPUSH
56937: LD_EXP 110
56941: PUSH
56942: LD_VAR 0 1
56946: ARRAY
56947: PUSH
56948: LD_VAR 0 9
56952: DIFF
56953: PPUSH
56954: CALL_OW 1
56958: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56959: LD_VAR 0 3
56963: PPUSH
56964: LD_EXP 111
56968: PUSH
56969: LD_VAR 0 1
56973: ARRAY
56974: PUSH
56975: LD_EXP 111
56979: PUSH
56980: LD_VAR 0 1
56984: ARRAY
56985: ARRAY
56986: PPUSH
56987: CALL_OW 120
// end ; exit ;
56991: GO 57312
// end ; if tmp > 1 then
56993: LD_VAR 0 8
56997: PUSH
56998: LD_INT 1
57000: GREATER
57001: IFFALSE 57105
// for i = 2 to tmp do
57003: LD_ADDR_VAR 0 6
57007: PUSH
57008: DOUBLE
57009: LD_INT 2
57011: DEC
57012: ST_TO_ADDR
57013: LD_VAR 0 8
57017: PUSH
57018: FOR_TO
57019: IFFALSE 57103
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57021: LD_VAR 0 8
57025: PUSH
57026: LD_VAR 0 6
57030: ARRAY
57031: PPUSH
57032: CALL_OW 461
57036: PUSH
57037: LD_INT 6
57039: EQUAL
57040: IFFALSE 57101
// begin x := tmp [ i ] ;
57042: LD_ADDR_VAR 0 9
57046: PUSH
57047: LD_VAR 0 8
57051: PUSH
57052: LD_VAR 0 6
57056: ARRAY
57057: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57058: LD_ADDR_VAR 0 8
57062: PUSH
57063: LD_VAR 0 8
57067: PPUSH
57068: LD_VAR 0 6
57072: PPUSH
57073: CALL_OW 3
57077: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57078: LD_ADDR_VAR 0 8
57082: PUSH
57083: LD_VAR 0 8
57087: PPUSH
57088: LD_INT 1
57090: PPUSH
57091: LD_VAR 0 9
57095: PPUSH
57096: CALL_OW 2
57100: ST_TO_ADDR
// end ;
57101: GO 57018
57103: POP
57104: POP
// for i in tmp do
57105: LD_ADDR_VAR 0 6
57109: PUSH
57110: LD_VAR 0 8
57114: PUSH
57115: FOR_IN
57116: IFFALSE 57185
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57118: LD_VAR 0 6
57122: PPUSH
57123: CALL_OW 313
57127: PUSH
57128: LD_INT 6
57130: LESS
57131: PUSH
57132: LD_VAR 0 6
57136: PPUSH
57137: CALL_OW 266
57141: PUSH
57142: LD_INT 31
57144: PUSH
57145: LD_INT 32
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: IN
57152: NOT
57153: AND
57154: PUSH
57155: LD_VAR 0 6
57159: PPUSH
57160: CALL_OW 313
57164: PUSH
57165: LD_INT 0
57167: EQUAL
57168: OR
57169: IFFALSE 57183
// begin j := i ;
57171: LD_ADDR_VAR 0 7
57175: PUSH
57176: LD_VAR 0 6
57180: ST_TO_ADDR
// break ;
57181: GO 57185
// end ; end ;
57183: GO 57115
57185: POP
57186: POP
// if j then
57187: LD_VAR 0 7
57191: IFFALSE 57209
// ComEnterUnit ( unit , j ) else
57193: LD_VAR 0 3
57197: PPUSH
57198: LD_VAR 0 7
57202: PPUSH
57203: CALL_OW 120
57207: GO 57312
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57209: LD_ADDR_VAR 0 10
57213: PUSH
57214: LD_VAR 0 2
57218: PPUSH
57219: LD_INT 2
57221: PUSH
57222: LD_INT 30
57224: PUSH
57225: LD_INT 0
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 30
57234: PUSH
57235: LD_INT 1
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: PUSH
57242: EMPTY
57243: LIST
57244: LIST
57245: LIST
57246: PPUSH
57247: CALL_OW 72
57251: ST_TO_ADDR
// if depot then
57252: LD_VAR 0 10
57256: IFFALSE 57312
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57258: LD_ADDR_VAR 0 10
57262: PUSH
57263: LD_VAR 0 10
57267: PPUSH
57268: LD_VAR 0 3
57272: PPUSH
57273: CALL_OW 74
57277: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57278: LD_VAR 0 3
57282: PPUSH
57283: LD_VAR 0 10
57287: PPUSH
57288: CALL_OW 296
57292: PUSH
57293: LD_INT 10
57295: GREATER
57296: IFFALSE 57312
// ComStandNearbyBuilding ( unit , depot ) ;
57298: LD_VAR 0 3
57302: PPUSH
57303: LD_VAR 0 10
57307: PPUSH
57308: CALL 65726 0 2
// end ; end ; end ;
57312: LD_VAR 0 5
57316: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57317: LD_INT 0
57319: PPUSH
57320: PPUSH
57321: PPUSH
57322: PPUSH
// if not mc_bases then
57323: LD_EXP 101
57327: NOT
57328: IFFALSE 57332
// exit ;
57330: GO 57571
// for i = 1 to mc_bases do
57332: LD_ADDR_VAR 0 2
57336: PUSH
57337: DOUBLE
57338: LD_INT 1
57340: DEC
57341: ST_TO_ADDR
57342: LD_EXP 101
57346: PUSH
57347: FOR_TO
57348: IFFALSE 57569
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57350: LD_ADDR_VAR 0 4
57354: PUSH
57355: LD_EXP 101
57359: PUSH
57360: LD_VAR 0 2
57364: ARRAY
57365: PPUSH
57366: LD_INT 21
57368: PUSH
57369: LD_INT 1
57371: PUSH
57372: EMPTY
57373: LIST
57374: LIST
57375: PPUSH
57376: CALL_OW 72
57380: PUSH
57381: LD_EXP 130
57385: PUSH
57386: LD_VAR 0 2
57390: ARRAY
57391: UNION
57392: ST_TO_ADDR
// if not tmp then
57393: LD_VAR 0 4
57397: NOT
57398: IFFALSE 57402
// continue ;
57400: GO 57347
// for j in tmp do
57402: LD_ADDR_VAR 0 3
57406: PUSH
57407: LD_VAR 0 4
57411: PUSH
57412: FOR_IN
57413: IFFALSE 57565
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57415: LD_VAR 0 3
57419: PPUSH
57420: CALL_OW 110
57424: NOT
57425: PUSH
57426: LD_VAR 0 3
57430: PPUSH
57431: CALL_OW 314
57435: NOT
57436: AND
57437: PUSH
57438: LD_VAR 0 3
57442: PPUSH
57443: CALL_OW 311
57447: NOT
57448: AND
57449: PUSH
57450: LD_VAR 0 3
57454: PPUSH
57455: CALL_OW 310
57459: NOT
57460: AND
57461: PUSH
57462: LD_VAR 0 3
57466: PUSH
57467: LD_EXP 104
57471: PUSH
57472: LD_VAR 0 2
57476: ARRAY
57477: PUSH
57478: LD_INT 1
57480: ARRAY
57481: IN
57482: NOT
57483: AND
57484: PUSH
57485: LD_VAR 0 3
57489: PUSH
57490: LD_EXP 104
57494: PUSH
57495: LD_VAR 0 2
57499: ARRAY
57500: PUSH
57501: LD_INT 2
57503: ARRAY
57504: IN
57505: NOT
57506: AND
57507: PUSH
57508: LD_VAR 0 3
57512: PUSH
57513: LD_EXP 113
57517: PUSH
57518: LD_VAR 0 2
57522: ARRAY
57523: IN
57524: NOT
57525: AND
57526: IFFALSE 57563
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57528: LD_VAR 0 2
57532: PPUSH
57533: LD_EXP 101
57537: PUSH
57538: LD_VAR 0 2
57542: ARRAY
57543: PPUSH
57544: LD_VAR 0 3
57548: PPUSH
57549: LD_VAR 0 3
57553: PPUSH
57554: CALL_OW 257
57558: PPUSH
57559: CALL 56335 0 4
// end ;
57563: GO 57412
57565: POP
57566: POP
// end ;
57567: GO 57347
57569: POP
57570: POP
// end ;
57571: LD_VAR 0 1
57575: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57576: LD_INT 0
57578: PPUSH
57579: PPUSH
57580: PPUSH
57581: PPUSH
57582: PPUSH
57583: PPUSH
// if not mc_bases [ base ] then
57584: LD_EXP 101
57588: PUSH
57589: LD_VAR 0 1
57593: ARRAY
57594: NOT
57595: IFFALSE 57599
// exit ;
57597: GO 57781
// tmp := [ ] ;
57599: LD_ADDR_VAR 0 6
57603: PUSH
57604: EMPTY
57605: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57606: LD_ADDR_VAR 0 7
57610: PUSH
57611: LD_VAR 0 3
57615: PPUSH
57616: LD_INT 0
57618: PPUSH
57619: CALL_OW 517
57623: ST_TO_ADDR
// if not list then
57624: LD_VAR 0 7
57628: NOT
57629: IFFALSE 57633
// exit ;
57631: GO 57781
// for i = 1 to amount do
57633: LD_ADDR_VAR 0 5
57637: PUSH
57638: DOUBLE
57639: LD_INT 1
57641: DEC
57642: ST_TO_ADDR
57643: LD_VAR 0 2
57647: PUSH
57648: FOR_TO
57649: IFFALSE 57729
// begin x := rand ( 1 , list [ 1 ] ) ;
57651: LD_ADDR_VAR 0 8
57655: PUSH
57656: LD_INT 1
57658: PPUSH
57659: LD_VAR 0 7
57663: PUSH
57664: LD_INT 1
57666: ARRAY
57667: PPUSH
57668: CALL_OW 12
57672: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57673: LD_ADDR_VAR 0 6
57677: PUSH
57678: LD_VAR 0 6
57682: PPUSH
57683: LD_VAR 0 5
57687: PPUSH
57688: LD_VAR 0 7
57692: PUSH
57693: LD_INT 1
57695: ARRAY
57696: PUSH
57697: LD_VAR 0 8
57701: ARRAY
57702: PUSH
57703: LD_VAR 0 7
57707: PUSH
57708: LD_INT 2
57710: ARRAY
57711: PUSH
57712: LD_VAR 0 8
57716: ARRAY
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// end ;
57727: GO 57648
57729: POP
57730: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57731: LD_ADDR_EXP 114
57735: PUSH
57736: LD_EXP 114
57740: PPUSH
57741: LD_VAR 0 1
57745: PPUSH
57746: LD_VAR 0 6
57750: PPUSH
57751: CALL_OW 1
57755: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57756: LD_ADDR_EXP 116
57760: PUSH
57761: LD_EXP 116
57765: PPUSH
57766: LD_VAR 0 1
57770: PPUSH
57771: LD_VAR 0 3
57775: PPUSH
57776: CALL_OW 1
57780: ST_TO_ADDR
// end ;
57781: LD_VAR 0 4
57785: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57786: LD_INT 0
57788: PPUSH
// if not mc_bases [ base ] then
57789: LD_EXP 101
57793: PUSH
57794: LD_VAR 0 1
57798: ARRAY
57799: NOT
57800: IFFALSE 57804
// exit ;
57802: GO 57829
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57804: LD_ADDR_EXP 106
57808: PUSH
57809: LD_EXP 106
57813: PPUSH
57814: LD_VAR 0 1
57818: PPUSH
57819: LD_VAR 0 2
57823: PPUSH
57824: CALL_OW 1
57828: ST_TO_ADDR
// end ;
57829: LD_VAR 0 3
57833: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57834: LD_INT 0
57836: PPUSH
// if not mc_bases [ base ] then
57837: LD_EXP 101
57841: PUSH
57842: LD_VAR 0 1
57846: ARRAY
57847: NOT
57848: IFFALSE 57852
// exit ;
57850: GO 57889
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57852: LD_ADDR_EXP 106
57856: PUSH
57857: LD_EXP 106
57861: PPUSH
57862: LD_VAR 0 1
57866: PPUSH
57867: LD_EXP 106
57871: PUSH
57872: LD_VAR 0 1
57876: ARRAY
57877: PUSH
57878: LD_VAR 0 2
57882: UNION
57883: PPUSH
57884: CALL_OW 1
57888: ST_TO_ADDR
// end ;
57889: LD_VAR 0 3
57893: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57894: LD_INT 0
57896: PPUSH
// if not mc_bases [ base ] then
57897: LD_EXP 101
57901: PUSH
57902: LD_VAR 0 1
57906: ARRAY
57907: NOT
57908: IFFALSE 57912
// exit ;
57910: GO 57937
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57912: LD_ADDR_EXP 122
57916: PUSH
57917: LD_EXP 122
57921: PPUSH
57922: LD_VAR 0 1
57926: PPUSH
57927: LD_VAR 0 2
57931: PPUSH
57932: CALL_OW 1
57936: ST_TO_ADDR
// end ;
57937: LD_VAR 0 3
57941: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57942: LD_INT 0
57944: PPUSH
// if not mc_bases [ base ] then
57945: LD_EXP 101
57949: PUSH
57950: LD_VAR 0 1
57954: ARRAY
57955: NOT
57956: IFFALSE 57960
// exit ;
57958: GO 57997
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57960: LD_ADDR_EXP 122
57964: PUSH
57965: LD_EXP 122
57969: PPUSH
57970: LD_VAR 0 1
57974: PPUSH
57975: LD_EXP 122
57979: PUSH
57980: LD_VAR 0 1
57984: ARRAY
57985: PUSH
57986: LD_VAR 0 2
57990: ADD
57991: PPUSH
57992: CALL_OW 1
57996: ST_TO_ADDR
// end ;
57997: LD_VAR 0 3
58001: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58002: LD_INT 0
58004: PPUSH
// if not mc_bases [ base ] then
58005: LD_EXP 101
58009: PUSH
58010: LD_VAR 0 1
58014: ARRAY
58015: NOT
58016: IFFALSE 58020
// exit ;
58018: GO 58074
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58020: LD_ADDR_EXP 123
58024: PUSH
58025: LD_EXP 123
58029: PPUSH
58030: LD_VAR 0 1
58034: PPUSH
58035: LD_VAR 0 2
58039: PPUSH
58040: CALL_OW 1
58044: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58045: LD_ADDR_EXP 112
58049: PUSH
58050: LD_EXP 112
58054: PPUSH
58055: LD_VAR 0 1
58059: PPUSH
58060: LD_VAR 0 2
58064: PUSH
58065: LD_INT 0
58067: PLUS
58068: PPUSH
58069: CALL_OW 1
58073: ST_TO_ADDR
// end ;
58074: LD_VAR 0 3
58078: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58079: LD_INT 0
58081: PPUSH
// if not mc_bases [ base ] then
58082: LD_EXP 101
58086: PUSH
58087: LD_VAR 0 1
58091: ARRAY
58092: NOT
58093: IFFALSE 58097
// exit ;
58095: GO 58122
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58097: LD_ADDR_EXP 112
58101: PUSH
58102: LD_EXP 112
58106: PPUSH
58107: LD_VAR 0 1
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: CALL_OW 1
58121: ST_TO_ADDR
// end ;
58122: LD_VAR 0 3
58126: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58127: LD_INT 0
58129: PPUSH
58130: PPUSH
58131: PPUSH
58132: PPUSH
// if not mc_bases [ base ] then
58133: LD_EXP 101
58137: PUSH
58138: LD_VAR 0 1
58142: ARRAY
58143: NOT
58144: IFFALSE 58148
// exit ;
58146: GO 58213
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58148: LD_ADDR_EXP 121
58152: PUSH
58153: LD_EXP 121
58157: PPUSH
58158: LD_VAR 0 1
58162: PUSH
58163: LD_EXP 121
58167: PUSH
58168: LD_VAR 0 1
58172: ARRAY
58173: PUSH
58174: LD_INT 1
58176: PLUS
58177: PUSH
58178: EMPTY
58179: LIST
58180: LIST
58181: PPUSH
58182: LD_VAR 0 1
58186: PUSH
58187: LD_VAR 0 2
58191: PUSH
58192: LD_VAR 0 3
58196: PUSH
58197: LD_VAR 0 4
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: LIST
58206: LIST
58207: PPUSH
58208: CALL 71523 0 3
58212: ST_TO_ADDR
// end ;
58213: LD_VAR 0 5
58217: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58218: LD_INT 0
58220: PPUSH
// if not mc_bases [ base ] then
58221: LD_EXP 101
58225: PUSH
58226: LD_VAR 0 1
58230: ARRAY
58231: NOT
58232: IFFALSE 58236
// exit ;
58234: GO 58261
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58236: LD_ADDR_EXP 138
58240: PUSH
58241: LD_EXP 138
58245: PPUSH
58246: LD_VAR 0 1
58250: PPUSH
58251: LD_VAR 0 2
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// end ;
58261: LD_VAR 0 3
58265: RET
// export function MC_GetMinesField ( base ) ; begin
58266: LD_INT 0
58268: PPUSH
// result := mc_mines [ base ] ;
58269: LD_ADDR_VAR 0 2
58273: PUSH
58274: LD_EXP 114
58278: PUSH
58279: LD_VAR 0 1
58283: ARRAY
58284: ST_TO_ADDR
// end ;
58285: LD_VAR 0 2
58289: RET
// export function MC_GetProduceList ( base ) ; begin
58290: LD_INT 0
58292: PPUSH
// result := mc_produce [ base ] ;
58293: LD_ADDR_VAR 0 2
58297: PUSH
58298: LD_EXP 122
58302: PUSH
58303: LD_VAR 0 1
58307: ARRAY
58308: ST_TO_ADDR
// end ;
58309: LD_VAR 0 2
58313: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58314: LD_INT 0
58316: PPUSH
58317: PPUSH
// if not mc_bases then
58318: LD_EXP 101
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58392
// if mc_bases [ base ] then
58327: LD_EXP 101
58331: PUSH
58332: LD_VAR 0 1
58336: ARRAY
58337: IFFALSE 58392
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58339: LD_ADDR_VAR 0 3
58343: PUSH
58344: LD_EXP 101
58348: PUSH
58349: LD_VAR 0 1
58353: ARRAY
58354: PPUSH
58355: LD_INT 30
58357: PUSH
58358: LD_VAR 0 2
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PPUSH
58367: CALL_OW 72
58371: ST_TO_ADDR
// if result then
58372: LD_VAR 0 3
58376: IFFALSE 58392
// result := result [ 1 ] ;
58378: LD_ADDR_VAR 0 3
58382: PUSH
58383: LD_VAR 0 3
58387: PUSH
58388: LD_INT 1
58390: ARRAY
58391: ST_TO_ADDR
// end ; end ;
58392: LD_VAR 0 3
58396: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58397: LD_INT 0
58399: PPUSH
58400: PPUSH
// if not mc_bases then
58401: LD_EXP 101
58405: NOT
58406: IFFALSE 58410
// exit ;
58408: GO 58455
// if mc_bases [ base ] then
58410: LD_EXP 101
58414: PUSH
58415: LD_VAR 0 1
58419: ARRAY
58420: IFFALSE 58455
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58422: LD_ADDR_VAR 0 3
58426: PUSH
58427: LD_EXP 101
58431: PUSH
58432: LD_VAR 0 1
58436: ARRAY
58437: PPUSH
58438: LD_INT 30
58440: PUSH
58441: LD_VAR 0 2
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PPUSH
58450: CALL_OW 72
58454: ST_TO_ADDR
// end ;
58455: LD_VAR 0 3
58459: RET
// export function MC_SetTame ( base , area ) ; begin
58460: LD_INT 0
58462: PPUSH
// if not mc_bases or not base then
58463: LD_EXP 101
58467: NOT
58468: PUSH
58469: LD_VAR 0 1
58473: NOT
58474: OR
58475: IFFALSE 58479
// exit ;
58477: GO 58504
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58479: LD_ADDR_EXP 129
58483: PUSH
58484: LD_EXP 129
58488: PPUSH
58489: LD_VAR 0 1
58493: PPUSH
58494: LD_VAR 0 2
58498: PPUSH
58499: CALL_OW 1
58503: ST_TO_ADDR
// end ;
58504: LD_VAR 0 3
58508: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58509: LD_INT 0
58511: PPUSH
58512: PPUSH
// if not mc_bases or not base then
58513: LD_EXP 101
58517: NOT
58518: PUSH
58519: LD_VAR 0 1
58523: NOT
58524: OR
58525: IFFALSE 58529
// exit ;
58527: GO 58631
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58529: LD_ADDR_VAR 0 4
58533: PUSH
58534: LD_EXP 101
58538: PUSH
58539: LD_VAR 0 1
58543: ARRAY
58544: PPUSH
58545: LD_INT 30
58547: PUSH
58548: LD_VAR 0 2
58552: PUSH
58553: EMPTY
58554: LIST
58555: LIST
58556: PPUSH
58557: CALL_OW 72
58561: ST_TO_ADDR
// if not tmp then
58562: LD_VAR 0 4
58566: NOT
58567: IFFALSE 58571
// exit ;
58569: GO 58631
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58571: LD_ADDR_EXP 133
58575: PUSH
58576: LD_EXP 133
58580: PPUSH
58581: LD_VAR 0 1
58585: PPUSH
58586: LD_EXP 133
58590: PUSH
58591: LD_VAR 0 1
58595: ARRAY
58596: PPUSH
58597: LD_EXP 133
58601: PUSH
58602: LD_VAR 0 1
58606: ARRAY
58607: PUSH
58608: LD_INT 1
58610: PLUS
58611: PPUSH
58612: LD_VAR 0 4
58616: PUSH
58617: LD_INT 1
58619: ARRAY
58620: PPUSH
58621: CALL_OW 2
58625: PPUSH
58626: CALL_OW 1
58630: ST_TO_ADDR
// end ;
58631: LD_VAR 0 3
58635: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58636: LD_INT 0
58638: PPUSH
58639: PPUSH
// if not mc_bases or not base or not kinds then
58640: LD_EXP 101
58644: NOT
58645: PUSH
58646: LD_VAR 0 1
58650: NOT
58651: OR
58652: PUSH
58653: LD_VAR 0 2
58657: NOT
58658: OR
58659: IFFALSE 58663
// exit ;
58661: GO 58724
// for i in kinds do
58663: LD_ADDR_VAR 0 4
58667: PUSH
58668: LD_VAR 0 2
58672: PUSH
58673: FOR_IN
58674: IFFALSE 58722
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58676: LD_ADDR_EXP 135
58680: PUSH
58681: LD_EXP 135
58685: PPUSH
58686: LD_VAR 0 1
58690: PUSH
58691: LD_EXP 135
58695: PUSH
58696: LD_VAR 0 1
58700: ARRAY
58701: PUSH
58702: LD_INT 1
58704: PLUS
58705: PUSH
58706: EMPTY
58707: LIST
58708: LIST
58709: PPUSH
58710: LD_VAR 0 4
58714: PPUSH
58715: CALL 71523 0 3
58719: ST_TO_ADDR
58720: GO 58673
58722: POP
58723: POP
// end ;
58724: LD_VAR 0 3
58728: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58729: LD_INT 0
58731: PPUSH
// if not mc_bases or not base or not areas then
58732: LD_EXP 101
58736: NOT
58737: PUSH
58738: LD_VAR 0 1
58742: NOT
58743: OR
58744: PUSH
58745: LD_VAR 0 2
58749: NOT
58750: OR
58751: IFFALSE 58755
// exit ;
58753: GO 58780
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58755: LD_ADDR_EXP 119
58759: PUSH
58760: LD_EXP 119
58764: PPUSH
58765: LD_VAR 0 1
58769: PPUSH
58770: LD_VAR 0 2
58774: PPUSH
58775: CALL_OW 1
58779: ST_TO_ADDR
// end ;
58780: LD_VAR 0 3
58784: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58785: LD_INT 0
58787: PPUSH
// if not mc_bases or not base or not teleports_exit then
58788: LD_EXP 101
58792: NOT
58793: PUSH
58794: LD_VAR 0 1
58798: NOT
58799: OR
58800: PUSH
58801: LD_VAR 0 2
58805: NOT
58806: OR
58807: IFFALSE 58811
// exit ;
58809: GO 58836
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58811: LD_ADDR_EXP 136
58815: PUSH
58816: LD_EXP 136
58820: PPUSH
58821: LD_VAR 0 1
58825: PPUSH
58826: LD_VAR 0 2
58830: PPUSH
58831: CALL_OW 1
58835: ST_TO_ADDR
// end ;
58836: LD_VAR 0 3
58840: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58841: LD_INT 0
58843: PPUSH
58844: PPUSH
58845: PPUSH
// if not mc_bases or not base or not ext_list then
58846: LD_EXP 101
58850: NOT
58851: PUSH
58852: LD_VAR 0 1
58856: NOT
58857: OR
58858: PUSH
58859: LD_VAR 0 5
58863: NOT
58864: OR
58865: IFFALSE 58869
// exit ;
58867: GO 59042
// tmp := GetFacExtXYD ( x , y , d ) ;
58869: LD_ADDR_VAR 0 8
58873: PUSH
58874: LD_VAR 0 2
58878: PPUSH
58879: LD_VAR 0 3
58883: PPUSH
58884: LD_VAR 0 4
58888: PPUSH
58889: CALL 104904 0 3
58893: ST_TO_ADDR
// if not tmp then
58894: LD_VAR 0 8
58898: NOT
58899: IFFALSE 58903
// exit ;
58901: GO 59042
// for i in tmp do
58903: LD_ADDR_VAR 0 7
58907: PUSH
58908: LD_VAR 0 8
58912: PUSH
58913: FOR_IN
58914: IFFALSE 59040
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58916: LD_ADDR_EXP 106
58920: PUSH
58921: LD_EXP 106
58925: PPUSH
58926: LD_VAR 0 1
58930: PPUSH
58931: LD_EXP 106
58935: PUSH
58936: LD_VAR 0 1
58940: ARRAY
58941: PPUSH
58942: LD_EXP 106
58946: PUSH
58947: LD_VAR 0 1
58951: ARRAY
58952: PUSH
58953: LD_INT 1
58955: PLUS
58956: PPUSH
58957: LD_VAR 0 5
58961: PUSH
58962: LD_INT 1
58964: ARRAY
58965: PUSH
58966: LD_VAR 0 7
58970: PUSH
58971: LD_INT 1
58973: ARRAY
58974: PUSH
58975: LD_VAR 0 7
58979: PUSH
58980: LD_INT 2
58982: ARRAY
58983: PUSH
58984: LD_VAR 0 7
58988: PUSH
58989: LD_INT 3
58991: ARRAY
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: LIST
58997: LIST
58998: PPUSH
58999: CALL_OW 2
59003: PPUSH
59004: CALL_OW 1
59008: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59009: LD_ADDR_VAR 0 5
59013: PUSH
59014: LD_VAR 0 5
59018: PPUSH
59019: LD_INT 1
59021: PPUSH
59022: CALL_OW 3
59026: ST_TO_ADDR
// if not ext_list then
59027: LD_VAR 0 5
59031: NOT
59032: IFFALSE 59038
// exit ;
59034: POP
59035: POP
59036: GO 59042
// end ;
59038: GO 58913
59040: POP
59041: POP
// end ;
59042: LD_VAR 0 6
59046: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59047: LD_INT 0
59049: PPUSH
// if not mc_bases or not base or not weapon_list then
59050: LD_EXP 101
59054: NOT
59055: PUSH
59056: LD_VAR 0 1
59060: NOT
59061: OR
59062: PUSH
59063: LD_VAR 0 2
59067: NOT
59068: OR
59069: IFFALSE 59073
// exit ;
59071: GO 59098
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59073: LD_ADDR_EXP 140
59077: PUSH
59078: LD_EXP 140
59082: PPUSH
59083: LD_VAR 0 1
59087: PPUSH
59088: LD_VAR 0 2
59092: PPUSH
59093: CALL_OW 1
59097: ST_TO_ADDR
// end ;
59098: LD_VAR 0 3
59102: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59103: LD_INT 0
59105: PPUSH
// if not mc_bases or not base or not tech_list then
59106: LD_EXP 101
59110: NOT
59111: PUSH
59112: LD_VAR 0 1
59116: NOT
59117: OR
59118: PUSH
59119: LD_VAR 0 2
59123: NOT
59124: OR
59125: IFFALSE 59129
// exit ;
59127: GO 59154
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59129: LD_ADDR_EXP 128
59133: PUSH
59134: LD_EXP 128
59138: PPUSH
59139: LD_VAR 0 1
59143: PPUSH
59144: LD_VAR 0 2
59148: PPUSH
59149: CALL_OW 1
59153: ST_TO_ADDR
// end ;
59154: LD_VAR 0 3
59158: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59159: LD_INT 0
59161: PPUSH
// if not mc_bases or not parking_area or not base then
59162: LD_EXP 101
59166: NOT
59167: PUSH
59168: LD_VAR 0 2
59172: NOT
59173: OR
59174: PUSH
59175: LD_VAR 0 1
59179: NOT
59180: OR
59181: IFFALSE 59185
// exit ;
59183: GO 59210
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59185: LD_ADDR_EXP 125
59189: PUSH
59190: LD_EXP 125
59194: PPUSH
59195: LD_VAR 0 1
59199: PPUSH
59200: LD_VAR 0 2
59204: PPUSH
59205: CALL_OW 1
59209: ST_TO_ADDR
// end ;
59210: LD_VAR 0 3
59214: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59215: LD_INT 0
59217: PPUSH
// if not mc_bases or not base or not scan_area then
59218: LD_EXP 101
59222: NOT
59223: PUSH
59224: LD_VAR 0 1
59228: NOT
59229: OR
59230: PUSH
59231: LD_VAR 0 2
59235: NOT
59236: OR
59237: IFFALSE 59241
// exit ;
59239: GO 59266
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59241: LD_ADDR_EXP 126
59245: PUSH
59246: LD_EXP 126
59250: PPUSH
59251: LD_VAR 0 1
59255: PPUSH
59256: LD_VAR 0 2
59260: PPUSH
59261: CALL_OW 1
59265: ST_TO_ADDR
// end ;
59266: LD_VAR 0 3
59270: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59271: LD_INT 0
59273: PPUSH
59274: PPUSH
// if not mc_bases or not base then
59275: LD_EXP 101
59279: NOT
59280: PUSH
59281: LD_VAR 0 1
59285: NOT
59286: OR
59287: IFFALSE 59291
// exit ;
59289: GO 59355
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59291: LD_ADDR_VAR 0 3
59295: PUSH
59296: LD_INT 1
59298: PUSH
59299: LD_INT 2
59301: PUSH
59302: LD_INT 3
59304: PUSH
59305: LD_INT 4
59307: PUSH
59308: LD_INT 11
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: LIST
59315: LIST
59316: LIST
59317: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59318: LD_ADDR_EXP 128
59322: PUSH
59323: LD_EXP 128
59327: PPUSH
59328: LD_VAR 0 1
59332: PPUSH
59333: LD_EXP 128
59337: PUSH
59338: LD_VAR 0 1
59342: ARRAY
59343: PUSH
59344: LD_VAR 0 3
59348: DIFF
59349: PPUSH
59350: CALL_OW 1
59354: ST_TO_ADDR
// end ;
59355: LD_VAR 0 2
59359: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59360: LD_INT 0
59362: PPUSH
// result := mc_vehicles [ base ] ;
59363: LD_ADDR_VAR 0 3
59367: PUSH
59368: LD_EXP 120
59372: PUSH
59373: LD_VAR 0 1
59377: ARRAY
59378: ST_TO_ADDR
// if onlyCombat then
59379: LD_VAR 0 2
59383: IFFALSE 59548
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59385: LD_ADDR_VAR 0 3
59389: PUSH
59390: LD_VAR 0 3
59394: PUSH
59395: LD_VAR 0 3
59399: PPUSH
59400: LD_INT 2
59402: PUSH
59403: LD_INT 34
59405: PUSH
59406: LD_INT 12
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: LD_INT 34
59415: PUSH
59416: LD_INT 51
59418: PUSH
59419: EMPTY
59420: LIST
59421: LIST
59422: PUSH
59423: LD_INT 34
59425: PUSH
59426: LD_EXP 95
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: PUSH
59435: LD_INT 34
59437: PUSH
59438: LD_INT 32
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PUSH
59445: LD_INT 34
59447: PUSH
59448: LD_INT 13
59450: PUSH
59451: EMPTY
59452: LIST
59453: LIST
59454: PUSH
59455: LD_INT 34
59457: PUSH
59458: LD_INT 52
59460: PUSH
59461: EMPTY
59462: LIST
59463: LIST
59464: PUSH
59465: LD_INT 34
59467: PUSH
59468: LD_INT 14
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: PUSH
59475: LD_INT 34
59477: PUSH
59478: LD_INT 53
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: LD_INT 34
59487: PUSH
59488: LD_EXP 94
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 34
59499: PUSH
59500: LD_INT 31
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: LD_INT 34
59509: PUSH
59510: LD_INT 48
59512: PUSH
59513: EMPTY
59514: LIST
59515: LIST
59516: PUSH
59517: LD_INT 34
59519: PUSH
59520: LD_INT 8
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: LIST
59531: LIST
59532: LIST
59533: LIST
59534: LIST
59535: LIST
59536: LIST
59537: LIST
59538: LIST
59539: LIST
59540: LIST
59541: PPUSH
59542: CALL_OW 72
59546: DIFF
59547: ST_TO_ADDR
// end ; end_of_file
59548: LD_VAR 0 3
59552: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59553: LD_INT 0
59555: PPUSH
59556: PPUSH
59557: PPUSH
// if not mc_bases or not skirmish then
59558: LD_EXP 101
59562: NOT
59563: PUSH
59564: LD_EXP 99
59568: NOT
59569: OR
59570: IFFALSE 59574
// exit ;
59572: GO 59739
// for i = 1 to mc_bases do
59574: LD_ADDR_VAR 0 4
59578: PUSH
59579: DOUBLE
59580: LD_INT 1
59582: DEC
59583: ST_TO_ADDR
59584: LD_EXP 101
59588: PUSH
59589: FOR_TO
59590: IFFALSE 59737
// begin if sci in mc_bases [ i ] then
59592: LD_VAR 0 2
59596: PUSH
59597: LD_EXP 101
59601: PUSH
59602: LD_VAR 0 4
59606: ARRAY
59607: IN
59608: IFFALSE 59735
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59610: LD_ADDR_EXP 130
59614: PUSH
59615: LD_EXP 130
59619: PPUSH
59620: LD_VAR 0 4
59624: PUSH
59625: LD_EXP 130
59629: PUSH
59630: LD_VAR 0 4
59634: ARRAY
59635: PUSH
59636: LD_INT 1
59638: PLUS
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: PPUSH
59644: LD_VAR 0 1
59648: PPUSH
59649: CALL 71523 0 3
59653: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59654: LD_ADDR_VAR 0 5
59658: PUSH
59659: LD_EXP 101
59663: PUSH
59664: LD_VAR 0 4
59668: ARRAY
59669: PPUSH
59670: LD_INT 2
59672: PUSH
59673: LD_INT 30
59675: PUSH
59676: LD_INT 0
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: PUSH
59683: LD_INT 30
59685: PUSH
59686: LD_INT 1
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: LIST
59697: PPUSH
59698: CALL_OW 72
59702: PPUSH
59703: LD_VAR 0 1
59707: PPUSH
59708: CALL_OW 74
59712: ST_TO_ADDR
// if tmp then
59713: LD_VAR 0 5
59717: IFFALSE 59733
// ComStandNearbyBuilding ( ape , tmp ) ;
59719: LD_VAR 0 1
59723: PPUSH
59724: LD_VAR 0 5
59728: PPUSH
59729: CALL 65726 0 2
// break ;
59733: GO 59737
// end ; end ;
59735: GO 59589
59737: POP
59738: POP
// end ;
59739: LD_VAR 0 3
59743: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59744: LD_INT 0
59746: PPUSH
59747: PPUSH
59748: PPUSH
// if not mc_bases or not skirmish then
59749: LD_EXP 101
59753: NOT
59754: PUSH
59755: LD_EXP 99
59759: NOT
59760: OR
59761: IFFALSE 59765
// exit ;
59763: GO 59854
// for i = 1 to mc_bases do
59765: LD_ADDR_VAR 0 4
59769: PUSH
59770: DOUBLE
59771: LD_INT 1
59773: DEC
59774: ST_TO_ADDR
59775: LD_EXP 101
59779: PUSH
59780: FOR_TO
59781: IFFALSE 59852
// begin if building in mc_busy_turret_list [ i ] then
59783: LD_VAR 0 1
59787: PUSH
59788: LD_EXP 111
59792: PUSH
59793: LD_VAR 0 4
59797: ARRAY
59798: IN
59799: IFFALSE 59850
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59801: LD_ADDR_VAR 0 5
59805: PUSH
59806: LD_EXP 111
59810: PUSH
59811: LD_VAR 0 4
59815: ARRAY
59816: PUSH
59817: LD_VAR 0 1
59821: DIFF
59822: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59823: LD_ADDR_EXP 111
59827: PUSH
59828: LD_EXP 111
59832: PPUSH
59833: LD_VAR 0 4
59837: PPUSH
59838: LD_VAR 0 5
59842: PPUSH
59843: CALL_OW 1
59847: ST_TO_ADDR
// break ;
59848: GO 59852
// end ; end ;
59850: GO 59780
59852: POP
59853: POP
// end ;
59854: LD_VAR 0 3
59858: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59859: LD_INT 0
59861: PPUSH
59862: PPUSH
59863: PPUSH
// if not mc_bases or not skirmish then
59864: LD_EXP 101
59868: NOT
59869: PUSH
59870: LD_EXP 99
59874: NOT
59875: OR
59876: IFFALSE 59880
// exit ;
59878: GO 60079
// for i = 1 to mc_bases do
59880: LD_ADDR_VAR 0 5
59884: PUSH
59885: DOUBLE
59886: LD_INT 1
59888: DEC
59889: ST_TO_ADDR
59890: LD_EXP 101
59894: PUSH
59895: FOR_TO
59896: IFFALSE 60077
// if building in mc_bases [ i ] then
59898: LD_VAR 0 1
59902: PUSH
59903: LD_EXP 101
59907: PUSH
59908: LD_VAR 0 5
59912: ARRAY
59913: IN
59914: IFFALSE 60075
// begin tmp := mc_bases [ i ] diff building ;
59916: LD_ADDR_VAR 0 6
59920: PUSH
59921: LD_EXP 101
59925: PUSH
59926: LD_VAR 0 5
59930: ARRAY
59931: PUSH
59932: LD_VAR 0 1
59936: DIFF
59937: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59938: LD_ADDR_EXP 101
59942: PUSH
59943: LD_EXP 101
59947: PPUSH
59948: LD_VAR 0 5
59952: PPUSH
59953: LD_VAR 0 6
59957: PPUSH
59958: CALL_OW 1
59962: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59963: LD_VAR 0 1
59967: PUSH
59968: LD_EXP 109
59972: PUSH
59973: LD_VAR 0 5
59977: ARRAY
59978: IN
59979: IFFALSE 60018
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59981: LD_ADDR_EXP 109
59985: PUSH
59986: LD_EXP 109
59990: PPUSH
59991: LD_VAR 0 5
59995: PPUSH
59996: LD_EXP 109
60000: PUSH
60001: LD_VAR 0 5
60005: ARRAY
60006: PUSH
60007: LD_VAR 0 1
60011: DIFF
60012: PPUSH
60013: CALL_OW 1
60017: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60018: LD_VAR 0 1
60022: PUSH
60023: LD_EXP 110
60027: PUSH
60028: LD_VAR 0 5
60032: ARRAY
60033: IN
60034: IFFALSE 60073
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60036: LD_ADDR_EXP 110
60040: PUSH
60041: LD_EXP 110
60045: PPUSH
60046: LD_VAR 0 5
60050: PPUSH
60051: LD_EXP 110
60055: PUSH
60056: LD_VAR 0 5
60060: ARRAY
60061: PUSH
60062: LD_VAR 0 1
60066: DIFF
60067: PPUSH
60068: CALL_OW 1
60072: ST_TO_ADDR
// break ;
60073: GO 60077
// end ;
60075: GO 59895
60077: POP
60078: POP
// end ;
60079: LD_VAR 0 4
60083: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60084: LD_INT 0
60086: PPUSH
60087: PPUSH
60088: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60089: LD_EXP 101
60093: NOT
60094: PUSH
60095: LD_EXP 99
60099: NOT
60100: OR
60101: PUSH
60102: LD_VAR 0 3
60106: PUSH
60107: LD_EXP 127
60111: IN
60112: NOT
60113: OR
60114: IFFALSE 60118
// exit ;
60116: GO 60241
// for i = 1 to mc_vehicles do
60118: LD_ADDR_VAR 0 6
60122: PUSH
60123: DOUBLE
60124: LD_INT 1
60126: DEC
60127: ST_TO_ADDR
60128: LD_EXP 120
60132: PUSH
60133: FOR_TO
60134: IFFALSE 60239
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60136: LD_VAR 0 2
60140: PUSH
60141: LD_EXP 120
60145: PUSH
60146: LD_VAR 0 6
60150: ARRAY
60151: IN
60152: PUSH
60153: LD_VAR 0 1
60157: PUSH
60158: LD_EXP 120
60162: PUSH
60163: LD_VAR 0 6
60167: ARRAY
60168: IN
60169: OR
60170: IFFALSE 60237
// begin tmp := mc_vehicles [ i ] diff old ;
60172: LD_ADDR_VAR 0 7
60176: PUSH
60177: LD_EXP 120
60181: PUSH
60182: LD_VAR 0 6
60186: ARRAY
60187: PUSH
60188: LD_VAR 0 2
60192: DIFF
60193: ST_TO_ADDR
// tmp := tmp diff new ;
60194: LD_ADDR_VAR 0 7
60198: PUSH
60199: LD_VAR 0 7
60203: PUSH
60204: LD_VAR 0 1
60208: DIFF
60209: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60210: LD_ADDR_EXP 120
60214: PUSH
60215: LD_EXP 120
60219: PPUSH
60220: LD_VAR 0 6
60224: PPUSH
60225: LD_VAR 0 7
60229: PPUSH
60230: CALL_OW 1
60234: ST_TO_ADDR
// break ;
60235: GO 60239
// end ;
60237: GO 60133
60239: POP
60240: POP
// end ;
60241: LD_VAR 0 5
60245: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60246: LD_INT 0
60248: PPUSH
60249: PPUSH
60250: PPUSH
60251: PPUSH
// if not mc_bases or not skirmish then
60252: LD_EXP 101
60256: NOT
60257: PUSH
60258: LD_EXP 99
60262: NOT
60263: OR
60264: IFFALSE 60268
// exit ;
60266: GO 60645
// side := GetSide ( vehicle ) ;
60268: LD_ADDR_VAR 0 5
60272: PUSH
60273: LD_VAR 0 1
60277: PPUSH
60278: CALL_OW 255
60282: ST_TO_ADDR
// for i = 1 to mc_bases do
60283: LD_ADDR_VAR 0 4
60287: PUSH
60288: DOUBLE
60289: LD_INT 1
60291: DEC
60292: ST_TO_ADDR
60293: LD_EXP 101
60297: PUSH
60298: FOR_TO
60299: IFFALSE 60643
// begin if factory in mc_bases [ i ] then
60301: LD_VAR 0 2
60305: PUSH
60306: LD_EXP 101
60310: PUSH
60311: LD_VAR 0 4
60315: ARRAY
60316: IN
60317: IFFALSE 60641
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60319: LD_EXP 123
60323: PUSH
60324: LD_VAR 0 4
60328: ARRAY
60329: PUSH
60330: LD_EXP 112
60334: PUSH
60335: LD_VAR 0 4
60339: ARRAY
60340: LESS
60341: PUSH
60342: LD_VAR 0 1
60346: PPUSH
60347: CALL_OW 264
60351: PUSH
60352: LD_INT 31
60354: PUSH
60355: LD_INT 32
60357: PUSH
60358: LD_INT 51
60360: PUSH
60361: LD_EXP 95
60365: PUSH
60366: LD_INT 12
60368: PUSH
60369: LD_INT 30
60371: PUSH
60372: LD_EXP 94
60376: PUSH
60377: LD_INT 11
60379: PUSH
60380: LD_INT 53
60382: PUSH
60383: LD_INT 14
60385: PUSH
60386: LD_EXP 98
60390: PUSH
60391: LD_INT 29
60393: PUSH
60394: LD_EXP 96
60398: PUSH
60399: LD_INT 13
60401: PUSH
60402: LD_INT 52
60404: PUSH
60405: LD_INT 48
60407: PUSH
60408: LD_INT 8
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: LIST
60415: LIST
60416: LIST
60417: LIST
60418: LIST
60419: LIST
60420: LIST
60421: LIST
60422: LIST
60423: LIST
60424: LIST
60425: LIST
60426: LIST
60427: LIST
60428: LIST
60429: IN
60430: NOT
60431: AND
60432: IFFALSE 60480
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60434: LD_ADDR_EXP 123
60438: PUSH
60439: LD_EXP 123
60443: PPUSH
60444: LD_VAR 0 4
60448: PUSH
60449: LD_EXP 123
60453: PUSH
60454: LD_VAR 0 4
60458: ARRAY
60459: PUSH
60460: LD_INT 1
60462: PLUS
60463: PUSH
60464: EMPTY
60465: LIST
60466: LIST
60467: PPUSH
60468: LD_VAR 0 1
60472: PPUSH
60473: CALL 71523 0 3
60477: ST_TO_ADDR
60478: GO 60524
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60480: LD_ADDR_EXP 120
60484: PUSH
60485: LD_EXP 120
60489: PPUSH
60490: LD_VAR 0 4
60494: PUSH
60495: LD_EXP 120
60499: PUSH
60500: LD_VAR 0 4
60504: ARRAY
60505: PUSH
60506: LD_INT 1
60508: PLUS
60509: PUSH
60510: EMPTY
60511: LIST
60512: LIST
60513: PPUSH
60514: LD_VAR 0 1
60518: PPUSH
60519: CALL 71523 0 3
60523: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60524: LD_VAR 0 1
60528: PPUSH
60529: CALL_OW 263
60533: PUSH
60534: LD_INT 2
60536: EQUAL
60537: IFFALSE 60557
// begin repeat wait ( 0 0$1 ) ;
60539: LD_INT 35
60541: PPUSH
60542: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60546: LD_VAR 0 1
60550: PPUSH
60551: CALL_OW 312
60555: IFFALSE 60539
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60557: LD_VAR 0 1
60561: PPUSH
60562: LD_EXP 125
60566: PUSH
60567: LD_VAR 0 4
60571: ARRAY
60572: PPUSH
60573: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60577: LD_VAR 0 1
60581: PPUSH
60582: CALL_OW 263
60586: PUSH
60587: LD_INT 1
60589: NONEQUAL
60590: IFFALSE 60594
// break ;
60592: GO 60643
// repeat wait ( 0 0$1 ) ;
60594: LD_INT 35
60596: PPUSH
60597: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60601: LD_VAR 0 1
60605: PPUSH
60606: LD_EXP 125
60610: PUSH
60611: LD_VAR 0 4
60615: ARRAY
60616: PPUSH
60617: CALL_OW 308
60621: IFFALSE 60594
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60623: LD_VAR 0 1
60627: PPUSH
60628: CALL_OW 311
60632: PPUSH
60633: CALL_OW 121
// exit ;
60637: POP
60638: POP
60639: GO 60645
// end ; end ;
60641: GO 60298
60643: POP
60644: POP
// end ;
60645: LD_VAR 0 3
60649: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60650: LD_INT 0
60652: PPUSH
60653: PPUSH
60654: PPUSH
60655: PPUSH
// if not mc_bases or not skirmish then
60656: LD_EXP 101
60660: NOT
60661: PUSH
60662: LD_EXP 99
60666: NOT
60667: OR
60668: IFFALSE 60672
// exit ;
60670: GO 61025
// repeat wait ( 0 0$1 ) ;
60672: LD_INT 35
60674: PPUSH
60675: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60679: LD_VAR 0 2
60683: PPUSH
60684: LD_VAR 0 3
60688: PPUSH
60689: CALL_OW 284
60693: IFFALSE 60672
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60695: LD_VAR 0 2
60699: PPUSH
60700: LD_VAR 0 3
60704: PPUSH
60705: CALL_OW 283
60709: PUSH
60710: LD_INT 4
60712: EQUAL
60713: IFFALSE 60717
// exit ;
60715: GO 61025
// for i = 1 to mc_bases do
60717: LD_ADDR_VAR 0 7
60721: PUSH
60722: DOUBLE
60723: LD_INT 1
60725: DEC
60726: ST_TO_ADDR
60727: LD_EXP 101
60731: PUSH
60732: FOR_TO
60733: IFFALSE 61023
// begin if mc_crates_area [ i ] then
60735: LD_EXP 119
60739: PUSH
60740: LD_VAR 0 7
60744: ARRAY
60745: IFFALSE 60856
// for j in mc_crates_area [ i ] do
60747: LD_ADDR_VAR 0 8
60751: PUSH
60752: LD_EXP 119
60756: PUSH
60757: LD_VAR 0 7
60761: ARRAY
60762: PUSH
60763: FOR_IN
60764: IFFALSE 60854
// if InArea ( x , y , j ) then
60766: LD_VAR 0 2
60770: PPUSH
60771: LD_VAR 0 3
60775: PPUSH
60776: LD_VAR 0 8
60780: PPUSH
60781: CALL_OW 309
60785: IFFALSE 60852
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60787: LD_ADDR_EXP 117
60791: PUSH
60792: LD_EXP 117
60796: PPUSH
60797: LD_VAR 0 7
60801: PUSH
60802: LD_EXP 117
60806: PUSH
60807: LD_VAR 0 7
60811: ARRAY
60812: PUSH
60813: LD_INT 1
60815: PLUS
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PPUSH
60821: LD_VAR 0 4
60825: PUSH
60826: LD_VAR 0 2
60830: PUSH
60831: LD_VAR 0 3
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: LIST
60840: PPUSH
60841: CALL 71523 0 3
60845: ST_TO_ADDR
// exit ;
60846: POP
60847: POP
60848: POP
60849: POP
60850: GO 61025
// end ;
60852: GO 60763
60854: POP
60855: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60856: LD_ADDR_VAR 0 9
60860: PUSH
60861: LD_EXP 101
60865: PUSH
60866: LD_VAR 0 7
60870: ARRAY
60871: PPUSH
60872: LD_INT 2
60874: PUSH
60875: LD_INT 30
60877: PUSH
60878: LD_INT 0
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PUSH
60885: LD_INT 30
60887: PUSH
60888: LD_INT 1
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: PUSH
60895: EMPTY
60896: LIST
60897: LIST
60898: LIST
60899: PPUSH
60900: CALL_OW 72
60904: ST_TO_ADDR
// if not depot then
60905: LD_VAR 0 9
60909: NOT
60910: IFFALSE 60914
// continue ;
60912: GO 60732
// for j in depot do
60914: LD_ADDR_VAR 0 8
60918: PUSH
60919: LD_VAR 0 9
60923: PUSH
60924: FOR_IN
60925: IFFALSE 61019
// if GetDistUnitXY ( j , x , y ) < 30 then
60927: LD_VAR 0 8
60931: PPUSH
60932: LD_VAR 0 2
60936: PPUSH
60937: LD_VAR 0 3
60941: PPUSH
60942: CALL_OW 297
60946: PUSH
60947: LD_INT 30
60949: LESS
60950: IFFALSE 61017
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60952: LD_ADDR_EXP 117
60956: PUSH
60957: LD_EXP 117
60961: PPUSH
60962: LD_VAR 0 7
60966: PUSH
60967: LD_EXP 117
60971: PUSH
60972: LD_VAR 0 7
60976: ARRAY
60977: PUSH
60978: LD_INT 1
60980: PLUS
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: PPUSH
60986: LD_VAR 0 4
60990: PUSH
60991: LD_VAR 0 2
60995: PUSH
60996: LD_VAR 0 3
61000: PUSH
61001: EMPTY
61002: LIST
61003: LIST
61004: LIST
61005: PPUSH
61006: CALL 71523 0 3
61010: ST_TO_ADDR
// exit ;
61011: POP
61012: POP
61013: POP
61014: POP
61015: GO 61025
// end ;
61017: GO 60924
61019: POP
61020: POP
// end ;
61021: GO 60732
61023: POP
61024: POP
// end ;
61025: LD_VAR 0 6
61029: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61030: LD_INT 0
61032: PPUSH
61033: PPUSH
61034: PPUSH
61035: PPUSH
// if not mc_bases or not skirmish then
61036: LD_EXP 101
61040: NOT
61041: PUSH
61042: LD_EXP 99
61046: NOT
61047: OR
61048: IFFALSE 61052
// exit ;
61050: GO 61329
// side := GetSide ( lab ) ;
61052: LD_ADDR_VAR 0 4
61056: PUSH
61057: LD_VAR 0 2
61061: PPUSH
61062: CALL_OW 255
61066: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61067: LD_VAR 0 4
61071: PUSH
61072: LD_EXP 127
61076: IN
61077: NOT
61078: PUSH
61079: LD_EXP 128
61083: NOT
61084: OR
61085: PUSH
61086: LD_EXP 101
61090: NOT
61091: OR
61092: IFFALSE 61096
// exit ;
61094: GO 61329
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61096: LD_ADDR_EXP 128
61100: PUSH
61101: LD_EXP 128
61105: PPUSH
61106: LD_VAR 0 4
61110: PPUSH
61111: LD_EXP 128
61115: PUSH
61116: LD_VAR 0 4
61120: ARRAY
61121: PUSH
61122: LD_VAR 0 1
61126: DIFF
61127: PPUSH
61128: CALL_OW 1
61132: ST_TO_ADDR
// for i = 1 to mc_bases do
61133: LD_ADDR_VAR 0 5
61137: PUSH
61138: DOUBLE
61139: LD_INT 1
61141: DEC
61142: ST_TO_ADDR
61143: LD_EXP 101
61147: PUSH
61148: FOR_TO
61149: IFFALSE 61327
// begin if lab in mc_bases [ i ] then
61151: LD_VAR 0 2
61155: PUSH
61156: LD_EXP 101
61160: PUSH
61161: LD_VAR 0 5
61165: ARRAY
61166: IN
61167: IFFALSE 61325
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61169: LD_VAR 0 1
61173: PUSH
61174: LD_INT 11
61176: PUSH
61177: LD_INT 4
61179: PUSH
61180: LD_INT 3
61182: PUSH
61183: LD_INT 2
61185: PUSH
61186: EMPTY
61187: LIST
61188: LIST
61189: LIST
61190: LIST
61191: IN
61192: PUSH
61193: LD_EXP 131
61197: PUSH
61198: LD_VAR 0 5
61202: ARRAY
61203: AND
61204: IFFALSE 61325
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61206: LD_ADDR_VAR 0 6
61210: PUSH
61211: LD_EXP 131
61215: PUSH
61216: LD_VAR 0 5
61220: ARRAY
61221: PUSH
61222: LD_INT 1
61224: ARRAY
61225: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61226: LD_ADDR_EXP 131
61230: PUSH
61231: LD_EXP 131
61235: PPUSH
61236: LD_VAR 0 5
61240: PPUSH
61241: EMPTY
61242: PPUSH
61243: CALL_OW 1
61247: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61248: LD_VAR 0 6
61252: PPUSH
61253: LD_INT 0
61255: PPUSH
61256: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61260: LD_VAR 0 6
61264: PPUSH
61265: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61269: LD_ADDR_EXP 130
61273: PUSH
61274: LD_EXP 130
61278: PPUSH
61279: LD_VAR 0 5
61283: PPUSH
61284: LD_EXP 130
61288: PUSH
61289: LD_VAR 0 5
61293: ARRAY
61294: PPUSH
61295: LD_INT 1
61297: PPUSH
61298: LD_VAR 0 6
61302: PPUSH
61303: CALL_OW 2
61307: PPUSH
61308: CALL_OW 1
61312: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61313: LD_VAR 0 5
61317: PPUSH
61318: LD_INT 112
61320: PPUSH
61321: CALL 38325 0 2
// end ; end ; end ;
61325: GO 61148
61327: POP
61328: POP
// end ;
61329: LD_VAR 0 3
61333: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61334: LD_INT 0
61336: PPUSH
61337: PPUSH
61338: PPUSH
61339: PPUSH
61340: PPUSH
61341: PPUSH
61342: PPUSH
61343: PPUSH
// if not mc_bases or not skirmish then
61344: LD_EXP 101
61348: NOT
61349: PUSH
61350: LD_EXP 99
61354: NOT
61355: OR
61356: IFFALSE 61360
// exit ;
61358: GO 62731
// for i = 1 to mc_bases do
61360: LD_ADDR_VAR 0 3
61364: PUSH
61365: DOUBLE
61366: LD_INT 1
61368: DEC
61369: ST_TO_ADDR
61370: LD_EXP 101
61374: PUSH
61375: FOR_TO
61376: IFFALSE 62729
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61378: LD_VAR 0 1
61382: PUSH
61383: LD_EXP 101
61387: PUSH
61388: LD_VAR 0 3
61392: ARRAY
61393: IN
61394: PUSH
61395: LD_VAR 0 1
61399: PUSH
61400: LD_EXP 108
61404: PUSH
61405: LD_VAR 0 3
61409: ARRAY
61410: IN
61411: OR
61412: PUSH
61413: LD_VAR 0 1
61417: PUSH
61418: LD_EXP 123
61422: PUSH
61423: LD_VAR 0 3
61427: ARRAY
61428: IN
61429: OR
61430: PUSH
61431: LD_VAR 0 1
61435: PUSH
61436: LD_EXP 120
61440: PUSH
61441: LD_VAR 0 3
61445: ARRAY
61446: IN
61447: OR
61448: PUSH
61449: LD_VAR 0 1
61453: PUSH
61454: LD_EXP 130
61458: PUSH
61459: LD_VAR 0 3
61463: ARRAY
61464: IN
61465: OR
61466: PUSH
61467: LD_VAR 0 1
61471: PUSH
61472: LD_EXP 131
61476: PUSH
61477: LD_VAR 0 3
61481: ARRAY
61482: IN
61483: OR
61484: IFFALSE 62727
// begin if un in mc_ape [ i ] then
61486: LD_VAR 0 1
61490: PUSH
61491: LD_EXP 130
61495: PUSH
61496: LD_VAR 0 3
61500: ARRAY
61501: IN
61502: IFFALSE 61541
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61504: LD_ADDR_EXP 130
61508: PUSH
61509: LD_EXP 130
61513: PPUSH
61514: LD_VAR 0 3
61518: PPUSH
61519: LD_EXP 130
61523: PUSH
61524: LD_VAR 0 3
61528: ARRAY
61529: PUSH
61530: LD_VAR 0 1
61534: DIFF
61535: PPUSH
61536: CALL_OW 1
61540: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61541: LD_VAR 0 1
61545: PUSH
61546: LD_EXP 131
61550: PUSH
61551: LD_VAR 0 3
61555: ARRAY
61556: IN
61557: IFFALSE 61581
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61559: LD_ADDR_EXP 131
61563: PUSH
61564: LD_EXP 131
61568: PPUSH
61569: LD_VAR 0 3
61573: PPUSH
61574: EMPTY
61575: PPUSH
61576: CALL_OW 1
61580: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61581: LD_VAR 0 1
61585: PPUSH
61586: CALL_OW 247
61590: PUSH
61591: LD_INT 2
61593: EQUAL
61594: PUSH
61595: LD_VAR 0 1
61599: PPUSH
61600: CALL_OW 110
61604: PUSH
61605: LD_INT 20
61607: EQUAL
61608: PUSH
61609: LD_VAR 0 1
61613: PUSH
61614: LD_EXP 123
61618: PUSH
61619: LD_VAR 0 3
61623: ARRAY
61624: IN
61625: OR
61626: PUSH
61627: LD_VAR 0 1
61631: PPUSH
61632: CALL_OW 264
61636: PUSH
61637: LD_INT 12
61639: PUSH
61640: LD_INT 51
61642: PUSH
61643: LD_EXP 95
61647: PUSH
61648: LD_INT 32
61650: PUSH
61651: LD_INT 13
61653: PUSH
61654: LD_INT 52
61656: PUSH
61657: LD_INT 31
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: LIST
61664: LIST
61665: LIST
61666: LIST
61667: LIST
61668: IN
61669: OR
61670: AND
61671: IFFALSE 61979
// begin if un in mc_defender [ i ] then
61673: LD_VAR 0 1
61677: PUSH
61678: LD_EXP 123
61682: PUSH
61683: LD_VAR 0 3
61687: ARRAY
61688: IN
61689: IFFALSE 61728
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61691: LD_ADDR_EXP 123
61695: PUSH
61696: LD_EXP 123
61700: PPUSH
61701: LD_VAR 0 3
61705: PPUSH
61706: LD_EXP 123
61710: PUSH
61711: LD_VAR 0 3
61715: ARRAY
61716: PUSH
61717: LD_VAR 0 1
61721: DIFF
61722: PPUSH
61723: CALL_OW 1
61727: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61728: LD_ADDR_VAR 0 8
61732: PUSH
61733: LD_VAR 0 3
61737: PPUSH
61738: LD_INT 3
61740: PPUSH
61741: CALL 58397 0 2
61745: ST_TO_ADDR
// if fac then
61746: LD_VAR 0 8
61750: IFFALSE 61979
// begin for j in fac do
61752: LD_ADDR_VAR 0 4
61756: PUSH
61757: LD_VAR 0 8
61761: PUSH
61762: FOR_IN
61763: IFFALSE 61977
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61765: LD_ADDR_VAR 0 9
61769: PUSH
61770: LD_VAR 0 8
61774: PPUSH
61775: LD_VAR 0 1
61779: PPUSH
61780: CALL_OW 265
61784: PPUSH
61785: LD_VAR 0 1
61789: PPUSH
61790: CALL_OW 262
61794: PPUSH
61795: LD_VAR 0 1
61799: PPUSH
61800: CALL_OW 263
61804: PPUSH
61805: LD_VAR 0 1
61809: PPUSH
61810: CALL_OW 264
61814: PPUSH
61815: CALL 69055 0 5
61819: ST_TO_ADDR
// if components then
61820: LD_VAR 0 9
61824: IFFALSE 61975
// begin if GetWeapon ( un ) = ar_control_tower then
61826: LD_VAR 0 1
61830: PPUSH
61831: CALL_OW 264
61835: PUSH
61836: LD_INT 31
61838: EQUAL
61839: IFFALSE 61956
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61841: LD_VAR 0 1
61845: PPUSH
61846: CALL_OW 311
61850: PPUSH
61851: LD_INT 0
61853: PPUSH
61854: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61858: LD_ADDR_EXP 141
61862: PUSH
61863: LD_EXP 141
61867: PPUSH
61868: LD_VAR 0 3
61872: PPUSH
61873: LD_EXP 141
61877: PUSH
61878: LD_VAR 0 3
61882: ARRAY
61883: PUSH
61884: LD_VAR 0 1
61888: PPUSH
61889: CALL_OW 311
61893: DIFF
61894: PPUSH
61895: CALL_OW 1
61899: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61900: LD_ADDR_VAR 0 7
61904: PUSH
61905: LD_EXP 122
61909: PUSH
61910: LD_VAR 0 3
61914: ARRAY
61915: PPUSH
61916: LD_INT 1
61918: PPUSH
61919: LD_VAR 0 9
61923: PPUSH
61924: CALL_OW 2
61928: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61929: LD_ADDR_EXP 122
61933: PUSH
61934: LD_EXP 122
61938: PPUSH
61939: LD_VAR 0 3
61943: PPUSH
61944: LD_VAR 0 7
61948: PPUSH
61949: CALL_OW 1
61953: ST_TO_ADDR
// end else
61954: GO 61973
// MC_InsertProduceList ( i , [ components ] ) ;
61956: LD_VAR 0 3
61960: PPUSH
61961: LD_VAR 0 9
61965: PUSH
61966: EMPTY
61967: LIST
61968: PPUSH
61969: CALL 57942 0 2
// break ;
61973: GO 61977
// end ; end ;
61975: GO 61762
61977: POP
61978: POP
// end ; end ; if GetType ( un ) = unit_building then
61979: LD_VAR 0 1
61983: PPUSH
61984: CALL_OW 247
61988: PUSH
61989: LD_INT 3
61991: EQUAL
61992: IFFALSE 62395
// begin btype := GetBType ( un ) ;
61994: LD_ADDR_VAR 0 5
61998: PUSH
61999: LD_VAR 0 1
62003: PPUSH
62004: CALL_OW 266
62008: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62009: LD_VAR 0 5
62013: PUSH
62014: LD_INT 29
62016: PUSH
62017: LD_INT 30
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: IN
62024: IFFALSE 62097
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62026: LD_VAR 0 1
62030: PPUSH
62031: CALL_OW 250
62035: PPUSH
62036: LD_VAR 0 1
62040: PPUSH
62041: CALL_OW 251
62045: PPUSH
62046: LD_VAR 0 1
62050: PPUSH
62051: CALL_OW 255
62055: PPUSH
62056: CALL_OW 440
62060: NOT
62061: IFFALSE 62097
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62063: LD_VAR 0 1
62067: PPUSH
62068: CALL_OW 250
62072: PPUSH
62073: LD_VAR 0 1
62077: PPUSH
62078: CALL_OW 251
62082: PPUSH
62083: LD_VAR 0 1
62087: PPUSH
62088: CALL_OW 255
62092: PPUSH
62093: CALL_OW 441
// end ; if btype = b_warehouse then
62097: LD_VAR 0 5
62101: PUSH
62102: LD_INT 1
62104: EQUAL
62105: IFFALSE 62123
// begin btype := b_depot ;
62107: LD_ADDR_VAR 0 5
62111: PUSH
62112: LD_INT 0
62114: ST_TO_ADDR
// pos := 1 ;
62115: LD_ADDR_VAR 0 6
62119: PUSH
62120: LD_INT 1
62122: ST_TO_ADDR
// end ; if btype = b_factory then
62123: LD_VAR 0 5
62127: PUSH
62128: LD_INT 3
62130: EQUAL
62131: IFFALSE 62149
// begin btype := b_workshop ;
62133: LD_ADDR_VAR 0 5
62137: PUSH
62138: LD_INT 2
62140: ST_TO_ADDR
// pos := 1 ;
62141: LD_ADDR_VAR 0 6
62145: PUSH
62146: LD_INT 1
62148: ST_TO_ADDR
// end ; if btype = b_barracks then
62149: LD_VAR 0 5
62153: PUSH
62154: LD_INT 5
62156: EQUAL
62157: IFFALSE 62167
// btype := b_armoury ;
62159: LD_ADDR_VAR 0 5
62163: PUSH
62164: LD_INT 4
62166: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62167: LD_VAR 0 5
62171: PUSH
62172: LD_INT 7
62174: PUSH
62175: LD_INT 8
62177: PUSH
62178: EMPTY
62179: LIST
62180: LIST
62181: IN
62182: IFFALSE 62192
// btype := b_lab ;
62184: LD_ADDR_VAR 0 5
62188: PUSH
62189: LD_INT 6
62191: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62192: LD_ADDR_EXP 106
62196: PUSH
62197: LD_EXP 106
62201: PPUSH
62202: LD_VAR 0 3
62206: PUSH
62207: LD_EXP 106
62211: PUSH
62212: LD_VAR 0 3
62216: ARRAY
62217: PUSH
62218: LD_INT 1
62220: PLUS
62221: PUSH
62222: EMPTY
62223: LIST
62224: LIST
62225: PPUSH
62226: LD_VAR 0 5
62230: PUSH
62231: LD_VAR 0 1
62235: PPUSH
62236: CALL_OW 250
62240: PUSH
62241: LD_VAR 0 1
62245: PPUSH
62246: CALL_OW 251
62250: PUSH
62251: LD_VAR 0 1
62255: PPUSH
62256: CALL_OW 254
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: LIST
62265: LIST
62266: PPUSH
62267: CALL 71523 0 3
62271: ST_TO_ADDR
// if pos = 1 then
62272: LD_VAR 0 6
62276: PUSH
62277: LD_INT 1
62279: EQUAL
62280: IFFALSE 62395
// begin tmp := mc_build_list [ i ] ;
62282: LD_ADDR_VAR 0 7
62286: PUSH
62287: LD_EXP 106
62291: PUSH
62292: LD_VAR 0 3
62296: ARRAY
62297: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62298: LD_VAR 0 7
62302: PPUSH
62303: LD_INT 2
62305: PUSH
62306: LD_INT 30
62308: PUSH
62309: LD_INT 0
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: PUSH
62316: LD_INT 30
62318: PUSH
62319: LD_INT 1
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: PUSH
62326: EMPTY
62327: LIST
62328: LIST
62329: LIST
62330: PPUSH
62331: CALL_OW 72
62335: IFFALSE 62345
// pos := 2 ;
62337: LD_ADDR_VAR 0 6
62341: PUSH
62342: LD_INT 2
62344: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62345: LD_ADDR_VAR 0 7
62349: PUSH
62350: LD_VAR 0 7
62354: PPUSH
62355: LD_VAR 0 6
62359: PPUSH
62360: LD_VAR 0 7
62364: PPUSH
62365: CALL 71849 0 3
62369: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62370: LD_ADDR_EXP 106
62374: PUSH
62375: LD_EXP 106
62379: PPUSH
62380: LD_VAR 0 3
62384: PPUSH
62385: LD_VAR 0 7
62389: PPUSH
62390: CALL_OW 1
62394: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62395: LD_VAR 0 1
62399: PUSH
62400: LD_EXP 101
62404: PUSH
62405: LD_VAR 0 3
62409: ARRAY
62410: IN
62411: IFFALSE 62450
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62413: LD_ADDR_EXP 101
62417: PUSH
62418: LD_EXP 101
62422: PPUSH
62423: LD_VAR 0 3
62427: PPUSH
62428: LD_EXP 101
62432: PUSH
62433: LD_VAR 0 3
62437: ARRAY
62438: PUSH
62439: LD_VAR 0 1
62443: DIFF
62444: PPUSH
62445: CALL_OW 1
62449: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62450: LD_VAR 0 1
62454: PUSH
62455: LD_EXP 108
62459: PUSH
62460: LD_VAR 0 3
62464: ARRAY
62465: IN
62466: IFFALSE 62505
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62468: LD_ADDR_EXP 108
62472: PUSH
62473: LD_EXP 108
62477: PPUSH
62478: LD_VAR 0 3
62482: PPUSH
62483: LD_EXP 108
62487: PUSH
62488: LD_VAR 0 3
62492: ARRAY
62493: PUSH
62494: LD_VAR 0 1
62498: DIFF
62499: PPUSH
62500: CALL_OW 1
62504: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62505: LD_VAR 0 1
62509: PUSH
62510: LD_EXP 120
62514: PUSH
62515: LD_VAR 0 3
62519: ARRAY
62520: IN
62521: IFFALSE 62560
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62523: LD_ADDR_EXP 120
62527: PUSH
62528: LD_EXP 120
62532: PPUSH
62533: LD_VAR 0 3
62537: PPUSH
62538: LD_EXP 120
62542: PUSH
62543: LD_VAR 0 3
62547: ARRAY
62548: PUSH
62549: LD_VAR 0 1
62553: DIFF
62554: PPUSH
62555: CALL_OW 1
62559: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62560: LD_VAR 0 1
62564: PUSH
62565: LD_EXP 123
62569: PUSH
62570: LD_VAR 0 3
62574: ARRAY
62575: IN
62576: IFFALSE 62615
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62578: LD_ADDR_EXP 123
62582: PUSH
62583: LD_EXP 123
62587: PPUSH
62588: LD_VAR 0 3
62592: PPUSH
62593: LD_EXP 123
62597: PUSH
62598: LD_VAR 0 3
62602: ARRAY
62603: PUSH
62604: LD_VAR 0 1
62608: DIFF
62609: PPUSH
62610: CALL_OW 1
62614: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62615: LD_VAR 0 1
62619: PUSH
62620: LD_EXP 110
62624: PUSH
62625: LD_VAR 0 3
62629: ARRAY
62630: IN
62631: IFFALSE 62670
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62633: LD_ADDR_EXP 110
62637: PUSH
62638: LD_EXP 110
62642: PPUSH
62643: LD_VAR 0 3
62647: PPUSH
62648: LD_EXP 110
62652: PUSH
62653: LD_VAR 0 3
62657: ARRAY
62658: PUSH
62659: LD_VAR 0 1
62663: DIFF
62664: PPUSH
62665: CALL_OW 1
62669: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62670: LD_VAR 0 1
62674: PUSH
62675: LD_EXP 109
62679: PUSH
62680: LD_VAR 0 3
62684: ARRAY
62685: IN
62686: IFFALSE 62725
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62688: LD_ADDR_EXP 109
62692: PUSH
62693: LD_EXP 109
62697: PPUSH
62698: LD_VAR 0 3
62702: PPUSH
62703: LD_EXP 109
62707: PUSH
62708: LD_VAR 0 3
62712: ARRAY
62713: PUSH
62714: LD_VAR 0 1
62718: DIFF
62719: PPUSH
62720: CALL_OW 1
62724: ST_TO_ADDR
// end ; break ;
62725: GO 62729
// end ;
62727: GO 61375
62729: POP
62730: POP
// end ;
62731: LD_VAR 0 2
62735: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62736: LD_INT 0
62738: PPUSH
62739: PPUSH
62740: PPUSH
// if not mc_bases or not skirmish then
62741: LD_EXP 101
62745: NOT
62746: PUSH
62747: LD_EXP 99
62751: NOT
62752: OR
62753: IFFALSE 62757
// exit ;
62755: GO 62972
// for i = 1 to mc_bases do
62757: LD_ADDR_VAR 0 3
62761: PUSH
62762: DOUBLE
62763: LD_INT 1
62765: DEC
62766: ST_TO_ADDR
62767: LD_EXP 101
62771: PUSH
62772: FOR_TO
62773: IFFALSE 62970
// begin if building in mc_construct_list [ i ] then
62775: LD_VAR 0 1
62779: PUSH
62780: LD_EXP 108
62784: PUSH
62785: LD_VAR 0 3
62789: ARRAY
62790: IN
62791: IFFALSE 62968
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62793: LD_ADDR_EXP 108
62797: PUSH
62798: LD_EXP 108
62802: PPUSH
62803: LD_VAR 0 3
62807: PPUSH
62808: LD_EXP 108
62812: PUSH
62813: LD_VAR 0 3
62817: ARRAY
62818: PUSH
62819: LD_VAR 0 1
62823: DIFF
62824: PPUSH
62825: CALL_OW 1
62829: ST_TO_ADDR
// if building in mc_lab [ i ] then
62830: LD_VAR 0 1
62834: PUSH
62835: LD_EXP 134
62839: PUSH
62840: LD_VAR 0 3
62844: ARRAY
62845: IN
62846: IFFALSE 62901
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62848: LD_ADDR_EXP 135
62852: PUSH
62853: LD_EXP 135
62857: PPUSH
62858: LD_VAR 0 3
62862: PPUSH
62863: LD_EXP 135
62867: PUSH
62868: LD_VAR 0 3
62872: ARRAY
62873: PPUSH
62874: LD_INT 1
62876: PPUSH
62877: LD_EXP 135
62881: PUSH
62882: LD_VAR 0 3
62886: ARRAY
62887: PPUSH
62888: LD_INT 0
62890: PPUSH
62891: CALL 70941 0 4
62895: PPUSH
62896: CALL_OW 1
62900: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62901: LD_VAR 0 1
62905: PUSH
62906: LD_EXP 101
62910: PUSH
62911: LD_VAR 0 3
62915: ARRAY
62916: IN
62917: NOT
62918: IFFALSE 62964
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62920: LD_ADDR_EXP 101
62924: PUSH
62925: LD_EXP 101
62929: PPUSH
62930: LD_VAR 0 3
62934: PUSH
62935: LD_EXP 101
62939: PUSH
62940: LD_VAR 0 3
62944: ARRAY
62945: PUSH
62946: LD_INT 1
62948: PLUS
62949: PUSH
62950: EMPTY
62951: LIST
62952: LIST
62953: PPUSH
62954: LD_VAR 0 1
62958: PPUSH
62959: CALL 71523 0 3
62963: ST_TO_ADDR
// exit ;
62964: POP
62965: POP
62966: GO 62972
// end ; end ;
62968: GO 62772
62970: POP
62971: POP
// end ;
62972: LD_VAR 0 2
62976: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62977: LD_INT 0
62979: PPUSH
62980: PPUSH
62981: PPUSH
62982: PPUSH
62983: PPUSH
62984: PPUSH
62985: PPUSH
// if not mc_bases or not skirmish then
62986: LD_EXP 101
62990: NOT
62991: PUSH
62992: LD_EXP 99
62996: NOT
62997: OR
62998: IFFALSE 63002
// exit ;
63000: GO 63663
// for i = 1 to mc_bases do
63002: LD_ADDR_VAR 0 3
63006: PUSH
63007: DOUBLE
63008: LD_INT 1
63010: DEC
63011: ST_TO_ADDR
63012: LD_EXP 101
63016: PUSH
63017: FOR_TO
63018: IFFALSE 63661
// begin if building in mc_construct_list [ i ] then
63020: LD_VAR 0 1
63024: PUSH
63025: LD_EXP 108
63029: PUSH
63030: LD_VAR 0 3
63034: ARRAY
63035: IN
63036: IFFALSE 63659
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63038: LD_ADDR_EXP 108
63042: PUSH
63043: LD_EXP 108
63047: PPUSH
63048: LD_VAR 0 3
63052: PPUSH
63053: LD_EXP 108
63057: PUSH
63058: LD_VAR 0 3
63062: ARRAY
63063: PUSH
63064: LD_VAR 0 1
63068: DIFF
63069: PPUSH
63070: CALL_OW 1
63074: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63075: LD_ADDR_EXP 101
63079: PUSH
63080: LD_EXP 101
63084: PPUSH
63085: LD_VAR 0 3
63089: PUSH
63090: LD_EXP 101
63094: PUSH
63095: LD_VAR 0 3
63099: ARRAY
63100: PUSH
63101: LD_INT 1
63103: PLUS
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PPUSH
63109: LD_VAR 0 1
63113: PPUSH
63114: CALL 71523 0 3
63118: ST_TO_ADDR
// btype := GetBType ( building ) ;
63119: LD_ADDR_VAR 0 5
63123: PUSH
63124: LD_VAR 0 1
63128: PPUSH
63129: CALL_OW 266
63133: ST_TO_ADDR
// side := GetSide ( building ) ;
63134: LD_ADDR_VAR 0 8
63138: PUSH
63139: LD_VAR 0 1
63143: PPUSH
63144: CALL_OW 255
63148: ST_TO_ADDR
// if btype = b_lab then
63149: LD_VAR 0 5
63153: PUSH
63154: LD_INT 6
63156: EQUAL
63157: IFFALSE 63207
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63159: LD_ADDR_EXP 134
63163: PUSH
63164: LD_EXP 134
63168: PPUSH
63169: LD_VAR 0 3
63173: PUSH
63174: LD_EXP 134
63178: PUSH
63179: LD_VAR 0 3
63183: ARRAY
63184: PUSH
63185: LD_INT 1
63187: PLUS
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PPUSH
63193: LD_VAR 0 1
63197: PPUSH
63198: CALL 71523 0 3
63202: ST_TO_ADDR
// exit ;
63203: POP
63204: POP
63205: GO 63663
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63207: LD_VAR 0 5
63211: PUSH
63212: LD_INT 0
63214: PUSH
63215: LD_INT 2
63217: PUSH
63218: LD_INT 4
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: LIST
63225: IN
63226: IFFALSE 63350
// begin if btype = b_armoury then
63228: LD_VAR 0 5
63232: PUSH
63233: LD_INT 4
63235: EQUAL
63236: IFFALSE 63246
// btype := b_barracks ;
63238: LD_ADDR_VAR 0 5
63242: PUSH
63243: LD_INT 5
63245: ST_TO_ADDR
// if btype = b_depot then
63246: LD_VAR 0 5
63250: PUSH
63251: LD_INT 0
63253: EQUAL
63254: IFFALSE 63264
// btype := b_warehouse ;
63256: LD_ADDR_VAR 0 5
63260: PUSH
63261: LD_INT 1
63263: ST_TO_ADDR
// if btype = b_workshop then
63264: LD_VAR 0 5
63268: PUSH
63269: LD_INT 2
63271: EQUAL
63272: IFFALSE 63282
// btype := b_factory ;
63274: LD_ADDR_VAR 0 5
63278: PUSH
63279: LD_INT 3
63281: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63282: LD_VAR 0 5
63286: PPUSH
63287: LD_VAR 0 8
63291: PPUSH
63292: CALL_OW 323
63296: PUSH
63297: LD_INT 1
63299: EQUAL
63300: IFFALSE 63346
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63302: LD_ADDR_EXP 133
63306: PUSH
63307: LD_EXP 133
63311: PPUSH
63312: LD_VAR 0 3
63316: PUSH
63317: LD_EXP 133
63321: PUSH
63322: LD_VAR 0 3
63326: ARRAY
63327: PUSH
63328: LD_INT 1
63330: PLUS
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PPUSH
63336: LD_VAR 0 1
63340: PPUSH
63341: CALL 71523 0 3
63345: ST_TO_ADDR
// exit ;
63346: POP
63347: POP
63348: GO 63663
// end ; if btype in [ b_bunker , b_turret ] then
63350: LD_VAR 0 5
63354: PUSH
63355: LD_INT 32
63357: PUSH
63358: LD_INT 33
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: IN
63365: IFFALSE 63655
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63367: LD_ADDR_EXP 109
63371: PUSH
63372: LD_EXP 109
63376: PPUSH
63377: LD_VAR 0 3
63381: PUSH
63382: LD_EXP 109
63386: PUSH
63387: LD_VAR 0 3
63391: ARRAY
63392: PUSH
63393: LD_INT 1
63395: PLUS
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PPUSH
63401: LD_VAR 0 1
63405: PPUSH
63406: CALL 71523 0 3
63410: ST_TO_ADDR
// if btype = b_bunker then
63411: LD_VAR 0 5
63415: PUSH
63416: LD_INT 32
63418: EQUAL
63419: IFFALSE 63655
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63421: LD_ADDR_EXP 110
63425: PUSH
63426: LD_EXP 110
63430: PPUSH
63431: LD_VAR 0 3
63435: PUSH
63436: LD_EXP 110
63440: PUSH
63441: LD_VAR 0 3
63445: ARRAY
63446: PUSH
63447: LD_INT 1
63449: PLUS
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PPUSH
63455: LD_VAR 0 1
63459: PPUSH
63460: CALL 71523 0 3
63464: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63465: LD_ADDR_VAR 0 6
63469: PUSH
63470: LD_EXP 101
63474: PUSH
63475: LD_VAR 0 3
63479: ARRAY
63480: PPUSH
63481: LD_INT 25
63483: PUSH
63484: LD_INT 1
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 3
63493: PUSH
63494: LD_INT 54
63496: PUSH
63497: EMPTY
63498: LIST
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: PPUSH
63508: CALL_OW 72
63512: ST_TO_ADDR
// if tmp then
63513: LD_VAR 0 6
63517: IFFALSE 63523
// exit ;
63519: POP
63520: POP
63521: GO 63663
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63523: LD_ADDR_VAR 0 6
63527: PUSH
63528: LD_EXP 101
63532: PUSH
63533: LD_VAR 0 3
63537: ARRAY
63538: PPUSH
63539: LD_INT 2
63541: PUSH
63542: LD_INT 30
63544: PUSH
63545: LD_INT 4
63547: PUSH
63548: EMPTY
63549: LIST
63550: LIST
63551: PUSH
63552: LD_INT 30
63554: PUSH
63555: LD_INT 5
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: LIST
63566: PPUSH
63567: CALL_OW 72
63571: ST_TO_ADDR
// if not tmp then
63572: LD_VAR 0 6
63576: NOT
63577: IFFALSE 63583
// exit ;
63579: POP
63580: POP
63581: GO 63663
// for j in tmp do
63583: LD_ADDR_VAR 0 4
63587: PUSH
63588: LD_VAR 0 6
63592: PUSH
63593: FOR_IN
63594: IFFALSE 63653
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63596: LD_ADDR_VAR 0 7
63600: PUSH
63601: LD_VAR 0 4
63605: PPUSH
63606: CALL_OW 313
63610: PPUSH
63611: LD_INT 25
63613: PUSH
63614: LD_INT 1
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: PPUSH
63621: CALL_OW 72
63625: ST_TO_ADDR
// if units then
63626: LD_VAR 0 7
63630: IFFALSE 63651
// begin ComExitBuilding ( units [ 1 ] ) ;
63632: LD_VAR 0 7
63636: PUSH
63637: LD_INT 1
63639: ARRAY
63640: PPUSH
63641: CALL_OW 122
// exit ;
63645: POP
63646: POP
63647: POP
63648: POP
63649: GO 63663
// end ; end ;
63651: GO 63593
63653: POP
63654: POP
// end ; end ; exit ;
63655: POP
63656: POP
63657: GO 63663
// end ; end ;
63659: GO 63017
63661: POP
63662: POP
// end ;
63663: LD_VAR 0 2
63667: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63668: LD_INT 0
63670: PPUSH
63671: PPUSH
63672: PPUSH
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
// if not mc_bases or not skirmish then
63677: LD_EXP 101
63681: NOT
63682: PUSH
63683: LD_EXP 99
63687: NOT
63688: OR
63689: IFFALSE 63693
// exit ;
63691: GO 63924
// btype := GetBType ( building ) ;
63693: LD_ADDR_VAR 0 6
63697: PUSH
63698: LD_VAR 0 1
63702: PPUSH
63703: CALL_OW 266
63707: ST_TO_ADDR
// x := GetX ( building ) ;
63708: LD_ADDR_VAR 0 7
63712: PUSH
63713: LD_VAR 0 1
63717: PPUSH
63718: CALL_OW 250
63722: ST_TO_ADDR
// y := GetY ( building ) ;
63723: LD_ADDR_VAR 0 8
63727: PUSH
63728: LD_VAR 0 1
63732: PPUSH
63733: CALL_OW 251
63737: ST_TO_ADDR
// d := GetDir ( building ) ;
63738: LD_ADDR_VAR 0 9
63742: PUSH
63743: LD_VAR 0 1
63747: PPUSH
63748: CALL_OW 254
63752: ST_TO_ADDR
// for i = 1 to mc_bases do
63753: LD_ADDR_VAR 0 4
63757: PUSH
63758: DOUBLE
63759: LD_INT 1
63761: DEC
63762: ST_TO_ADDR
63763: LD_EXP 101
63767: PUSH
63768: FOR_TO
63769: IFFALSE 63922
// begin if not mc_build_list [ i ] then
63771: LD_EXP 106
63775: PUSH
63776: LD_VAR 0 4
63780: ARRAY
63781: NOT
63782: IFFALSE 63786
// continue ;
63784: GO 63768
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63786: LD_VAR 0 6
63790: PUSH
63791: LD_VAR 0 7
63795: PUSH
63796: LD_VAR 0 8
63800: PUSH
63801: LD_VAR 0 9
63805: PUSH
63806: EMPTY
63807: LIST
63808: LIST
63809: LIST
63810: LIST
63811: PPUSH
63812: LD_EXP 106
63816: PUSH
63817: LD_VAR 0 4
63821: ARRAY
63822: PUSH
63823: LD_INT 1
63825: ARRAY
63826: PPUSH
63827: CALL 77692 0 2
63831: IFFALSE 63920
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63833: LD_ADDR_EXP 106
63837: PUSH
63838: LD_EXP 106
63842: PPUSH
63843: LD_VAR 0 4
63847: PPUSH
63848: LD_EXP 106
63852: PUSH
63853: LD_VAR 0 4
63857: ARRAY
63858: PPUSH
63859: LD_INT 1
63861: PPUSH
63862: CALL_OW 3
63866: PPUSH
63867: CALL_OW 1
63871: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63872: LD_ADDR_EXP 108
63876: PUSH
63877: LD_EXP 108
63881: PPUSH
63882: LD_VAR 0 4
63886: PUSH
63887: LD_EXP 108
63891: PUSH
63892: LD_VAR 0 4
63896: ARRAY
63897: PUSH
63898: LD_INT 1
63900: PLUS
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PPUSH
63906: LD_VAR 0 1
63910: PPUSH
63911: CALL 71523 0 3
63915: ST_TO_ADDR
// exit ;
63916: POP
63917: POP
63918: GO 63924
// end ; end ;
63920: GO 63768
63922: POP
63923: POP
// end ;
63924: LD_VAR 0 3
63928: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63929: LD_INT 0
63931: PPUSH
63932: PPUSH
63933: PPUSH
// if not mc_bases or not skirmish then
63934: LD_EXP 101
63938: NOT
63939: PUSH
63940: LD_EXP 99
63944: NOT
63945: OR
63946: IFFALSE 63950
// exit ;
63948: GO 64140
// for i = 1 to mc_bases do
63950: LD_ADDR_VAR 0 4
63954: PUSH
63955: DOUBLE
63956: LD_INT 1
63958: DEC
63959: ST_TO_ADDR
63960: LD_EXP 101
63964: PUSH
63965: FOR_TO
63966: IFFALSE 64053
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63968: LD_VAR 0 1
63972: PUSH
63973: LD_EXP 109
63977: PUSH
63978: LD_VAR 0 4
63982: ARRAY
63983: IN
63984: PUSH
63985: LD_VAR 0 1
63989: PUSH
63990: LD_EXP 110
63994: PUSH
63995: LD_VAR 0 4
63999: ARRAY
64000: IN
64001: NOT
64002: AND
64003: IFFALSE 64051
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64005: LD_ADDR_EXP 110
64009: PUSH
64010: LD_EXP 110
64014: PPUSH
64015: LD_VAR 0 4
64019: PUSH
64020: LD_EXP 110
64024: PUSH
64025: LD_VAR 0 4
64029: ARRAY
64030: PUSH
64031: LD_INT 1
64033: PLUS
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PPUSH
64039: LD_VAR 0 1
64043: PPUSH
64044: CALL 71523 0 3
64048: ST_TO_ADDR
// break ;
64049: GO 64053
// end ; end ;
64051: GO 63965
64053: POP
64054: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64055: LD_VAR 0 1
64059: PPUSH
64060: CALL_OW 257
64064: PUSH
64065: LD_EXP 127
64069: IN
64070: PUSH
64071: LD_VAR 0 1
64075: PPUSH
64076: CALL_OW 266
64080: PUSH
64081: LD_INT 5
64083: EQUAL
64084: AND
64085: PUSH
64086: LD_VAR 0 2
64090: PPUSH
64091: CALL_OW 110
64095: PUSH
64096: LD_INT 18
64098: NONEQUAL
64099: AND
64100: IFFALSE 64140
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64102: LD_VAR 0 2
64106: PPUSH
64107: CALL_OW 257
64111: PUSH
64112: LD_INT 5
64114: PUSH
64115: LD_INT 8
64117: PUSH
64118: LD_INT 9
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: LIST
64125: IN
64126: IFFALSE 64140
// SetClass ( unit , 1 ) ;
64128: LD_VAR 0 2
64132: PPUSH
64133: LD_INT 1
64135: PPUSH
64136: CALL_OW 336
// end ;
64140: LD_VAR 0 3
64144: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64145: LD_INT 0
64147: PPUSH
64148: PPUSH
// if not mc_bases or not skirmish then
64149: LD_EXP 101
64153: NOT
64154: PUSH
64155: LD_EXP 99
64159: NOT
64160: OR
64161: IFFALSE 64165
// exit ;
64163: GO 64281
// if GetLives ( abandoned_vehicle ) > 250 then
64165: LD_VAR 0 2
64169: PPUSH
64170: CALL_OW 256
64174: PUSH
64175: LD_INT 250
64177: GREATER
64178: IFFALSE 64182
// exit ;
64180: GO 64281
// for i = 1 to mc_bases do
64182: LD_ADDR_VAR 0 6
64186: PUSH
64187: DOUBLE
64188: LD_INT 1
64190: DEC
64191: ST_TO_ADDR
64192: LD_EXP 101
64196: PUSH
64197: FOR_TO
64198: IFFALSE 64279
// begin if driver in mc_bases [ i ] then
64200: LD_VAR 0 1
64204: PUSH
64205: LD_EXP 101
64209: PUSH
64210: LD_VAR 0 6
64214: ARRAY
64215: IN
64216: IFFALSE 64277
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64218: LD_VAR 0 1
64222: PPUSH
64223: LD_EXP 101
64227: PUSH
64228: LD_VAR 0 6
64232: ARRAY
64233: PPUSH
64234: LD_INT 2
64236: PUSH
64237: LD_INT 30
64239: PUSH
64240: LD_INT 0
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: PUSH
64247: LD_INT 30
64249: PUSH
64250: LD_INT 1
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: LIST
64261: PPUSH
64262: CALL_OW 72
64266: PUSH
64267: LD_INT 1
64269: ARRAY
64270: PPUSH
64271: CALL_OW 112
// break ;
64275: GO 64279
// end ; end ;
64277: GO 64197
64279: POP
64280: POP
// end ; end_of_file
64281: LD_VAR 0 5
64285: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64286: LD_INT 0
64288: PPUSH
64289: PPUSH
// if exist_mode then
64290: LD_VAR 0 2
64294: IFFALSE 64319
// unit := CreateCharacter ( prefix & ident ) else
64296: LD_ADDR_VAR 0 5
64300: PUSH
64301: LD_VAR 0 3
64305: PUSH
64306: LD_VAR 0 1
64310: STR
64311: PPUSH
64312: CALL_OW 34
64316: ST_TO_ADDR
64317: GO 64334
// unit := NewCharacter ( ident ) ;
64319: LD_ADDR_VAR 0 5
64323: PUSH
64324: LD_VAR 0 1
64328: PPUSH
64329: CALL_OW 25
64333: ST_TO_ADDR
// result := unit ;
64334: LD_ADDR_VAR 0 4
64338: PUSH
64339: LD_VAR 0 5
64343: ST_TO_ADDR
// end ;
64344: LD_VAR 0 4
64348: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64349: LD_INT 0
64351: PPUSH
64352: PPUSH
// if not side or not nation then
64353: LD_VAR 0 1
64357: NOT
64358: PUSH
64359: LD_VAR 0 2
64363: NOT
64364: OR
64365: IFFALSE 64369
// exit ;
64367: GO 65013
// case nation of nation_american :
64369: LD_VAR 0 2
64373: PUSH
64374: LD_INT 1
64376: DOUBLE
64377: EQUAL
64378: IFTRUE 64382
64380: GO 64556
64382: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64383: LD_ADDR_VAR 0 4
64387: PUSH
64388: LD_INT 35
64390: PUSH
64391: LD_INT 45
64393: PUSH
64394: LD_INT 46
64396: PUSH
64397: LD_INT 47
64399: PUSH
64400: LD_INT 1
64402: PUSH
64403: LD_INT 2
64405: PUSH
64406: LD_INT 6
64408: PUSH
64409: LD_INT 15
64411: PUSH
64412: LD_INT 16
64414: PUSH
64415: LD_INT 7
64417: PUSH
64418: LD_INT 12
64420: PUSH
64421: LD_INT 13
64423: PUSH
64424: LD_INT 10
64426: PUSH
64427: LD_INT 14
64429: PUSH
64430: LD_INT 20
64432: PUSH
64433: LD_INT 21
64435: PUSH
64436: LD_INT 22
64438: PUSH
64439: LD_INT 25
64441: PUSH
64442: LD_INT 32
64444: PUSH
64445: LD_INT 27
64447: PUSH
64448: LD_INT 36
64450: PUSH
64451: LD_INT 69
64453: PUSH
64454: LD_INT 39
64456: PUSH
64457: LD_INT 34
64459: PUSH
64460: LD_INT 40
64462: PUSH
64463: LD_INT 48
64465: PUSH
64466: LD_INT 49
64468: PUSH
64469: LD_INT 50
64471: PUSH
64472: LD_INT 51
64474: PUSH
64475: LD_INT 52
64477: PUSH
64478: LD_INT 53
64480: PUSH
64481: LD_INT 54
64483: PUSH
64484: LD_INT 55
64486: PUSH
64487: LD_INT 56
64489: PUSH
64490: LD_INT 57
64492: PUSH
64493: LD_INT 58
64495: PUSH
64496: LD_INT 59
64498: PUSH
64499: LD_INT 60
64501: PUSH
64502: LD_INT 61
64504: PUSH
64505: LD_INT 62
64507: PUSH
64508: LD_INT 80
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: LIST
64553: ST_TO_ADDR
64554: GO 64937
64556: LD_INT 2
64558: DOUBLE
64559: EQUAL
64560: IFTRUE 64564
64562: GO 64746
64564: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64565: LD_ADDR_VAR 0 4
64569: PUSH
64570: LD_INT 35
64572: PUSH
64573: LD_INT 45
64575: PUSH
64576: LD_INT 46
64578: PUSH
64579: LD_INT 47
64581: PUSH
64582: LD_INT 70
64584: PUSH
64585: LD_INT 1
64587: PUSH
64588: LD_INT 11
64590: PUSH
64591: LD_INT 3
64593: PUSH
64594: LD_INT 4
64596: PUSH
64597: LD_INT 5
64599: PUSH
64600: LD_INT 6
64602: PUSH
64603: LD_INT 15
64605: PUSH
64606: LD_INT 18
64608: PUSH
64609: LD_INT 7
64611: PUSH
64612: LD_INT 17
64614: PUSH
64615: LD_INT 8
64617: PUSH
64618: LD_INT 20
64620: PUSH
64621: LD_INT 21
64623: PUSH
64624: LD_INT 22
64626: PUSH
64627: LD_INT 72
64629: PUSH
64630: LD_INT 26
64632: PUSH
64633: LD_INT 69
64635: PUSH
64636: LD_INT 39
64638: PUSH
64639: LD_INT 40
64641: PUSH
64642: LD_INT 41
64644: PUSH
64645: LD_INT 42
64647: PUSH
64648: LD_INT 43
64650: PUSH
64651: LD_INT 48
64653: PUSH
64654: LD_INT 49
64656: PUSH
64657: LD_INT 50
64659: PUSH
64660: LD_INT 51
64662: PUSH
64663: LD_INT 52
64665: PUSH
64666: LD_INT 53
64668: PUSH
64669: LD_INT 54
64671: PUSH
64672: LD_INT 55
64674: PUSH
64675: LD_INT 56
64677: PUSH
64678: LD_INT 60
64680: PUSH
64681: LD_INT 61
64683: PUSH
64684: LD_INT 62
64686: PUSH
64687: LD_INT 66
64689: PUSH
64690: LD_INT 67
64692: PUSH
64693: LD_INT 68
64695: PUSH
64696: LD_INT 81
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: LIST
64740: LIST
64741: LIST
64742: LIST
64743: ST_TO_ADDR
64744: GO 64937
64746: LD_INT 3
64748: DOUBLE
64749: EQUAL
64750: IFTRUE 64754
64752: GO 64936
64754: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64755: LD_ADDR_VAR 0 4
64759: PUSH
64760: LD_INT 46
64762: PUSH
64763: LD_INT 47
64765: PUSH
64766: LD_INT 1
64768: PUSH
64769: LD_INT 2
64771: PUSH
64772: LD_INT 11
64774: PUSH
64775: LD_INT 9
64777: PUSH
64778: LD_INT 20
64780: PUSH
64781: LD_INT 19
64783: PUSH
64784: LD_INT 21
64786: PUSH
64787: LD_INT 24
64789: PUSH
64790: LD_INT 22
64792: PUSH
64793: LD_INT 25
64795: PUSH
64796: LD_INT 28
64798: PUSH
64799: LD_INT 29
64801: PUSH
64802: LD_INT 30
64804: PUSH
64805: LD_INT 31
64807: PUSH
64808: LD_INT 37
64810: PUSH
64811: LD_INT 38
64813: PUSH
64814: LD_INT 32
64816: PUSH
64817: LD_INT 27
64819: PUSH
64820: LD_INT 33
64822: PUSH
64823: LD_INT 69
64825: PUSH
64826: LD_INT 39
64828: PUSH
64829: LD_INT 34
64831: PUSH
64832: LD_INT 40
64834: PUSH
64835: LD_INT 71
64837: PUSH
64838: LD_INT 23
64840: PUSH
64841: LD_INT 44
64843: PUSH
64844: LD_INT 48
64846: PUSH
64847: LD_INT 49
64849: PUSH
64850: LD_INT 50
64852: PUSH
64853: LD_INT 51
64855: PUSH
64856: LD_INT 52
64858: PUSH
64859: LD_INT 53
64861: PUSH
64862: LD_INT 54
64864: PUSH
64865: LD_INT 55
64867: PUSH
64868: LD_INT 56
64870: PUSH
64871: LD_INT 57
64873: PUSH
64874: LD_INT 58
64876: PUSH
64877: LD_INT 59
64879: PUSH
64880: LD_INT 63
64882: PUSH
64883: LD_INT 64
64885: PUSH
64886: LD_INT 65
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: ST_TO_ADDR
64934: GO 64937
64936: POP
// if state > - 1 and state < 3 then
64937: LD_VAR 0 3
64941: PUSH
64942: LD_INT 1
64944: NEG
64945: GREATER
64946: PUSH
64947: LD_VAR 0 3
64951: PUSH
64952: LD_INT 3
64954: LESS
64955: AND
64956: IFFALSE 65013
// for i in result do
64958: LD_ADDR_VAR 0 5
64962: PUSH
64963: LD_VAR 0 4
64967: PUSH
64968: FOR_IN
64969: IFFALSE 65011
// if GetTech ( i , side ) <> state then
64971: LD_VAR 0 5
64975: PPUSH
64976: LD_VAR 0 1
64980: PPUSH
64981: CALL_OW 321
64985: PUSH
64986: LD_VAR 0 3
64990: NONEQUAL
64991: IFFALSE 65009
// result := result diff i ;
64993: LD_ADDR_VAR 0 4
64997: PUSH
64998: LD_VAR 0 4
65002: PUSH
65003: LD_VAR 0 5
65007: DIFF
65008: ST_TO_ADDR
65009: GO 64968
65011: POP
65012: POP
// end ;
65013: LD_VAR 0 4
65017: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65018: LD_INT 0
65020: PPUSH
65021: PPUSH
65022: PPUSH
// result := true ;
65023: LD_ADDR_VAR 0 3
65027: PUSH
65028: LD_INT 1
65030: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65031: LD_ADDR_VAR 0 5
65035: PUSH
65036: LD_VAR 0 2
65040: PPUSH
65041: CALL_OW 480
65045: ST_TO_ADDR
// if not tmp then
65046: LD_VAR 0 5
65050: NOT
65051: IFFALSE 65055
// exit ;
65053: GO 65104
// for i in tmp do
65055: LD_ADDR_VAR 0 4
65059: PUSH
65060: LD_VAR 0 5
65064: PUSH
65065: FOR_IN
65066: IFFALSE 65102
// if GetTech ( i , side ) <> state_researched then
65068: LD_VAR 0 4
65072: PPUSH
65073: LD_VAR 0 1
65077: PPUSH
65078: CALL_OW 321
65082: PUSH
65083: LD_INT 2
65085: NONEQUAL
65086: IFFALSE 65100
// begin result := false ;
65088: LD_ADDR_VAR 0 3
65092: PUSH
65093: LD_INT 0
65095: ST_TO_ADDR
// exit ;
65096: POP
65097: POP
65098: GO 65104
// end ;
65100: GO 65065
65102: POP
65103: POP
// end ;
65104: LD_VAR 0 3
65108: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65109: LD_INT 0
65111: PPUSH
65112: PPUSH
65113: PPUSH
65114: PPUSH
65115: PPUSH
65116: PPUSH
65117: PPUSH
65118: PPUSH
65119: PPUSH
65120: PPUSH
65121: PPUSH
65122: PPUSH
65123: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65124: LD_VAR 0 1
65128: NOT
65129: PUSH
65130: LD_VAR 0 1
65134: PPUSH
65135: CALL_OW 257
65139: PUSH
65140: LD_INT 9
65142: NONEQUAL
65143: OR
65144: IFFALSE 65148
// exit ;
65146: GO 65721
// side := GetSide ( unit ) ;
65148: LD_ADDR_VAR 0 9
65152: PUSH
65153: LD_VAR 0 1
65157: PPUSH
65158: CALL_OW 255
65162: ST_TO_ADDR
// tech_space := tech_spacanom ;
65163: LD_ADDR_VAR 0 12
65167: PUSH
65168: LD_INT 29
65170: ST_TO_ADDR
// tech_time := tech_taurad ;
65171: LD_ADDR_VAR 0 13
65175: PUSH
65176: LD_INT 28
65178: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65179: LD_ADDR_VAR 0 11
65183: PUSH
65184: LD_VAR 0 1
65188: PPUSH
65189: CALL_OW 310
65193: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65194: LD_VAR 0 11
65198: PPUSH
65199: CALL_OW 247
65203: PUSH
65204: LD_INT 2
65206: EQUAL
65207: IFFALSE 65211
// exit ;
65209: GO 65721
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65211: LD_ADDR_VAR 0 8
65215: PUSH
65216: LD_INT 81
65218: PUSH
65219: LD_VAR 0 9
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: LD_INT 3
65230: PUSH
65231: LD_INT 21
65233: PUSH
65234: LD_INT 3
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: PPUSH
65249: CALL_OW 69
65253: ST_TO_ADDR
// if not tmp then
65254: LD_VAR 0 8
65258: NOT
65259: IFFALSE 65263
// exit ;
65261: GO 65721
// if in_unit then
65263: LD_VAR 0 11
65267: IFFALSE 65291
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65269: LD_ADDR_VAR 0 10
65273: PUSH
65274: LD_VAR 0 8
65278: PPUSH
65279: LD_VAR 0 11
65283: PPUSH
65284: CALL_OW 74
65288: ST_TO_ADDR
65289: GO 65311
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65291: LD_ADDR_VAR 0 10
65295: PUSH
65296: LD_VAR 0 8
65300: PPUSH
65301: LD_VAR 0 1
65305: PPUSH
65306: CALL_OW 74
65310: ST_TO_ADDR
// if not enemy then
65311: LD_VAR 0 10
65315: NOT
65316: IFFALSE 65320
// exit ;
65318: GO 65721
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65320: LD_VAR 0 11
65324: PUSH
65325: LD_VAR 0 11
65329: PPUSH
65330: LD_VAR 0 10
65334: PPUSH
65335: CALL_OW 296
65339: PUSH
65340: LD_INT 13
65342: GREATER
65343: AND
65344: PUSH
65345: LD_VAR 0 1
65349: PPUSH
65350: LD_VAR 0 10
65354: PPUSH
65355: CALL_OW 296
65359: PUSH
65360: LD_INT 12
65362: GREATER
65363: OR
65364: IFFALSE 65368
// exit ;
65366: GO 65721
// missile := [ 1 ] ;
65368: LD_ADDR_VAR 0 14
65372: PUSH
65373: LD_INT 1
65375: PUSH
65376: EMPTY
65377: LIST
65378: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65379: LD_VAR 0 9
65383: PPUSH
65384: LD_VAR 0 12
65388: PPUSH
65389: CALL_OW 325
65393: IFFALSE 65422
// missile := Insert ( missile , missile + 1 , 2 ) ;
65395: LD_ADDR_VAR 0 14
65399: PUSH
65400: LD_VAR 0 14
65404: PPUSH
65405: LD_VAR 0 14
65409: PUSH
65410: LD_INT 1
65412: PLUS
65413: PPUSH
65414: LD_INT 2
65416: PPUSH
65417: CALL_OW 2
65421: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65422: LD_VAR 0 9
65426: PPUSH
65427: LD_VAR 0 13
65431: PPUSH
65432: CALL_OW 325
65436: PUSH
65437: LD_VAR 0 10
65441: PPUSH
65442: CALL_OW 255
65446: PPUSH
65447: LD_VAR 0 13
65451: PPUSH
65452: CALL_OW 325
65456: NOT
65457: AND
65458: IFFALSE 65487
// missile := Insert ( missile , missile + 1 , 3 ) ;
65460: LD_ADDR_VAR 0 14
65464: PUSH
65465: LD_VAR 0 14
65469: PPUSH
65470: LD_VAR 0 14
65474: PUSH
65475: LD_INT 1
65477: PLUS
65478: PPUSH
65479: LD_INT 3
65481: PPUSH
65482: CALL_OW 2
65486: ST_TO_ADDR
// if missile < 2 then
65487: LD_VAR 0 14
65491: PUSH
65492: LD_INT 2
65494: LESS
65495: IFFALSE 65499
// exit ;
65497: GO 65721
// x := GetX ( enemy ) ;
65499: LD_ADDR_VAR 0 4
65503: PUSH
65504: LD_VAR 0 10
65508: PPUSH
65509: CALL_OW 250
65513: ST_TO_ADDR
// y := GetY ( enemy ) ;
65514: LD_ADDR_VAR 0 5
65518: PUSH
65519: LD_VAR 0 10
65523: PPUSH
65524: CALL_OW 251
65528: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65529: LD_ADDR_VAR 0 6
65533: PUSH
65534: LD_VAR 0 4
65538: PUSH
65539: LD_INT 1
65541: NEG
65542: PPUSH
65543: LD_INT 1
65545: PPUSH
65546: CALL_OW 12
65550: PLUS
65551: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65552: LD_ADDR_VAR 0 7
65556: PUSH
65557: LD_VAR 0 5
65561: PUSH
65562: LD_INT 1
65564: NEG
65565: PPUSH
65566: LD_INT 1
65568: PPUSH
65569: CALL_OW 12
65573: PLUS
65574: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65575: LD_VAR 0 6
65579: PPUSH
65580: LD_VAR 0 7
65584: PPUSH
65585: CALL_OW 488
65589: NOT
65590: IFFALSE 65612
// begin _x := x ;
65592: LD_ADDR_VAR 0 6
65596: PUSH
65597: LD_VAR 0 4
65601: ST_TO_ADDR
// _y := y ;
65602: LD_ADDR_VAR 0 7
65606: PUSH
65607: LD_VAR 0 5
65611: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65612: LD_ADDR_VAR 0 3
65616: PUSH
65617: LD_INT 1
65619: PPUSH
65620: LD_VAR 0 14
65624: PPUSH
65625: CALL_OW 12
65629: ST_TO_ADDR
// case i of 1 :
65630: LD_VAR 0 3
65634: PUSH
65635: LD_INT 1
65637: DOUBLE
65638: EQUAL
65639: IFTRUE 65643
65641: GO 65660
65643: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65644: LD_VAR 0 1
65648: PPUSH
65649: LD_VAR 0 10
65653: PPUSH
65654: CALL_OW 115
65658: GO 65721
65660: LD_INT 2
65662: DOUBLE
65663: EQUAL
65664: IFTRUE 65668
65666: GO 65690
65668: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65669: LD_VAR 0 1
65673: PPUSH
65674: LD_VAR 0 6
65678: PPUSH
65679: LD_VAR 0 7
65683: PPUSH
65684: CALL_OW 153
65688: GO 65721
65690: LD_INT 3
65692: DOUBLE
65693: EQUAL
65694: IFTRUE 65698
65696: GO 65720
65698: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65699: LD_VAR 0 1
65703: PPUSH
65704: LD_VAR 0 6
65708: PPUSH
65709: LD_VAR 0 7
65713: PPUSH
65714: CALL_OW 154
65718: GO 65721
65720: POP
// end ;
65721: LD_VAR 0 2
65725: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65726: LD_INT 0
65728: PPUSH
65729: PPUSH
65730: PPUSH
65731: PPUSH
65732: PPUSH
65733: PPUSH
// if not unit or not building then
65734: LD_VAR 0 1
65738: NOT
65739: PUSH
65740: LD_VAR 0 2
65744: NOT
65745: OR
65746: IFFALSE 65750
// exit ;
65748: GO 65908
// x := GetX ( building ) ;
65750: LD_ADDR_VAR 0 5
65754: PUSH
65755: LD_VAR 0 2
65759: PPUSH
65760: CALL_OW 250
65764: ST_TO_ADDR
// y := GetY ( building ) ;
65765: LD_ADDR_VAR 0 6
65769: PUSH
65770: LD_VAR 0 2
65774: PPUSH
65775: CALL_OW 251
65779: ST_TO_ADDR
// for i = 0 to 5 do
65780: LD_ADDR_VAR 0 4
65784: PUSH
65785: DOUBLE
65786: LD_INT 0
65788: DEC
65789: ST_TO_ADDR
65790: LD_INT 5
65792: PUSH
65793: FOR_TO
65794: IFFALSE 65906
// begin _x := ShiftX ( x , i , 3 ) ;
65796: LD_ADDR_VAR 0 7
65800: PUSH
65801: LD_VAR 0 5
65805: PPUSH
65806: LD_VAR 0 4
65810: PPUSH
65811: LD_INT 3
65813: PPUSH
65814: CALL_OW 272
65818: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65819: LD_ADDR_VAR 0 8
65823: PUSH
65824: LD_VAR 0 6
65828: PPUSH
65829: LD_VAR 0 4
65833: PPUSH
65834: LD_INT 3
65836: PPUSH
65837: CALL_OW 273
65841: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65842: LD_VAR 0 7
65846: PPUSH
65847: LD_VAR 0 8
65851: PPUSH
65852: CALL_OW 488
65856: NOT
65857: IFFALSE 65861
// continue ;
65859: GO 65793
// if HexInfo ( _x , _y ) = 0 then
65861: LD_VAR 0 7
65865: PPUSH
65866: LD_VAR 0 8
65870: PPUSH
65871: CALL_OW 428
65875: PUSH
65876: LD_INT 0
65878: EQUAL
65879: IFFALSE 65904
// begin ComMoveXY ( unit , _x , _y ) ;
65881: LD_VAR 0 1
65885: PPUSH
65886: LD_VAR 0 7
65890: PPUSH
65891: LD_VAR 0 8
65895: PPUSH
65896: CALL_OW 111
// exit ;
65900: POP
65901: POP
65902: GO 65908
// end ; end ;
65904: GO 65793
65906: POP
65907: POP
// end ;
65908: LD_VAR 0 3
65912: RET
// export function ScanBase ( side , base_area ) ; begin
65913: LD_INT 0
65915: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65916: LD_ADDR_VAR 0 3
65920: PUSH
65921: LD_VAR 0 2
65925: PPUSH
65926: LD_INT 81
65928: PUSH
65929: LD_VAR 0 1
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PPUSH
65938: CALL_OW 70
65942: ST_TO_ADDR
// end ;
65943: LD_VAR 0 3
65947: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65948: LD_INT 0
65950: PPUSH
65951: PPUSH
65952: PPUSH
65953: PPUSH
65954: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65955: LD_VAR 0 1
65959: NOT
65960: PUSH
65961: LD_EXP 101
65965: PUSH
65966: LD_VAR 0 1
65970: ARRAY
65971: NOT
65972: OR
65973: PUSH
65974: LD_VAR 0 2
65978: NOT
65979: OR
65980: PUSH
65981: LD_VAR 0 3
65985: NOT
65986: OR
65987: IFFALSE 65991
// exit ;
65989: GO 66504
// side := mc_sides [ base ] ;
65991: LD_ADDR_VAR 0 6
65995: PUSH
65996: LD_EXP 127
66000: PUSH
66001: LD_VAR 0 1
66005: ARRAY
66006: ST_TO_ADDR
// if not side then
66007: LD_VAR 0 6
66011: NOT
66012: IFFALSE 66016
// exit ;
66014: GO 66504
// for i in solds do
66016: LD_ADDR_VAR 0 7
66020: PUSH
66021: LD_VAR 0 2
66025: PUSH
66026: FOR_IN
66027: IFFALSE 66088
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66029: LD_VAR 0 7
66033: PPUSH
66034: CALL_OW 310
66038: PPUSH
66039: CALL_OW 266
66043: PUSH
66044: LD_INT 32
66046: PUSH
66047: LD_INT 31
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: IN
66054: IFFALSE 66074
// solds := solds diff i else
66056: LD_ADDR_VAR 0 2
66060: PUSH
66061: LD_VAR 0 2
66065: PUSH
66066: LD_VAR 0 7
66070: DIFF
66071: ST_TO_ADDR
66072: GO 66086
// SetTag ( i , 18 ) ;
66074: LD_VAR 0 7
66078: PPUSH
66079: LD_INT 18
66081: PPUSH
66082: CALL_OW 109
66086: GO 66026
66088: POP
66089: POP
// if not solds then
66090: LD_VAR 0 2
66094: NOT
66095: IFFALSE 66099
// exit ;
66097: GO 66504
// repeat wait ( 0 0$1 ) ;
66099: LD_INT 35
66101: PPUSH
66102: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66106: LD_ADDR_VAR 0 5
66110: PUSH
66111: LD_VAR 0 6
66115: PPUSH
66116: LD_VAR 0 3
66120: PPUSH
66121: CALL 65913 0 2
66125: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66126: LD_EXP 101
66130: PUSH
66131: LD_VAR 0 1
66135: ARRAY
66136: NOT
66137: PUSH
66138: LD_EXP 101
66142: PUSH
66143: LD_VAR 0 1
66147: ARRAY
66148: PUSH
66149: EMPTY
66150: EQUAL
66151: OR
66152: IFFALSE 66189
// begin for i in solds do
66154: LD_ADDR_VAR 0 7
66158: PUSH
66159: LD_VAR 0 2
66163: PUSH
66164: FOR_IN
66165: IFFALSE 66178
// ComStop ( i ) ;
66167: LD_VAR 0 7
66171: PPUSH
66172: CALL_OW 141
66176: GO 66164
66178: POP
66179: POP
// solds := [ ] ;
66180: LD_ADDR_VAR 0 2
66184: PUSH
66185: EMPTY
66186: ST_TO_ADDR
// exit ;
66187: GO 66504
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66189: LD_VAR 0 5
66193: NOT
66194: PUSH
66195: LD_VAR 0 5
66199: PUSH
66200: LD_INT 3
66202: GREATER
66203: OR
66204: PUSH
66205: LD_EXP 123
66209: PUSH
66210: LD_VAR 0 1
66214: ARRAY
66215: OR
66216: IFFALSE 66257
// begin for i in solds do
66218: LD_ADDR_VAR 0 7
66222: PUSH
66223: LD_VAR 0 2
66227: PUSH
66228: FOR_IN
66229: IFFALSE 66253
// if HasTask ( i ) then
66231: LD_VAR 0 7
66235: PPUSH
66236: CALL_OW 314
66240: IFFALSE 66251
// ComStop ( i ) ;
66242: LD_VAR 0 7
66246: PPUSH
66247: CALL_OW 141
66251: GO 66228
66253: POP
66254: POP
// break ;
66255: GO 66492
// end ; for i in solds do
66257: LD_ADDR_VAR 0 7
66261: PUSH
66262: LD_VAR 0 2
66266: PUSH
66267: FOR_IN
66268: IFFALSE 66484
// begin if IsInUnit ( i ) then
66270: LD_VAR 0 7
66274: PPUSH
66275: CALL_OW 310
66279: IFFALSE 66290
// ComExitBuilding ( i ) ;
66281: LD_VAR 0 7
66285: PPUSH
66286: CALL_OW 122
// if GetLives ( i ) > 333 then
66290: LD_VAR 0 7
66294: PPUSH
66295: CALL_OW 256
66299: PUSH
66300: LD_INT 333
66302: GREATER
66303: IFFALSE 66331
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66305: LD_VAR 0 7
66309: PPUSH
66310: LD_VAR 0 5
66314: PPUSH
66315: LD_VAR 0 7
66319: PPUSH
66320: CALL_OW 74
66324: PPUSH
66325: CALL_OW 115
66329: GO 66482
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66331: LD_ADDR_VAR 0 8
66335: PUSH
66336: LD_EXP 101
66340: PUSH
66341: LD_VAR 0 1
66345: ARRAY
66346: PPUSH
66347: LD_INT 2
66349: PUSH
66350: LD_INT 30
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 30
66362: PUSH
66363: LD_INT 1
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 30
66372: PUSH
66373: LD_INT 6
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: PPUSH
66386: CALL_OW 72
66390: PPUSH
66391: LD_VAR 0 7
66395: PPUSH
66396: CALL_OW 74
66400: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66401: LD_VAR 0 7
66405: PPUSH
66406: LD_VAR 0 8
66410: PPUSH
66411: CALL_OW 250
66415: PPUSH
66416: LD_INT 3
66418: PPUSH
66419: LD_INT 5
66421: PPUSH
66422: CALL_OW 272
66426: PPUSH
66427: LD_VAR 0 8
66431: PPUSH
66432: CALL_OW 251
66436: PPUSH
66437: LD_INT 3
66439: PPUSH
66440: LD_INT 5
66442: PPUSH
66443: CALL_OW 273
66447: PPUSH
66448: CALL_OW 111
// SetTag ( i , 0 ) ;
66452: LD_VAR 0 7
66456: PPUSH
66457: LD_INT 0
66459: PPUSH
66460: CALL_OW 109
// solds := solds diff i ;
66464: LD_ADDR_VAR 0 2
66468: PUSH
66469: LD_VAR 0 2
66473: PUSH
66474: LD_VAR 0 7
66478: DIFF
66479: ST_TO_ADDR
// continue ;
66480: GO 66267
// end ; end ;
66482: GO 66267
66484: POP
66485: POP
// until solds ;
66486: LD_VAR 0 2
66490: IFFALSE 66099
// MC_Reset ( base , 18 ) ;
66492: LD_VAR 0 1
66496: PPUSH
66497: LD_INT 18
66499: PPUSH
66500: CALL 38325 0 2
// end ;
66504: LD_VAR 0 4
66508: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66509: LD_INT 0
66511: PPUSH
66512: PPUSH
66513: PPUSH
66514: PPUSH
66515: PPUSH
66516: PPUSH
66517: PPUSH
66518: PPUSH
66519: PPUSH
66520: PPUSH
66521: PPUSH
66522: PPUSH
66523: PPUSH
66524: PPUSH
66525: PPUSH
66526: PPUSH
66527: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66528: LD_ADDR_VAR 0 13
66532: PUSH
66533: LD_EXP 101
66537: PUSH
66538: LD_VAR 0 1
66542: ARRAY
66543: PPUSH
66544: LD_INT 25
66546: PUSH
66547: LD_INT 3
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PPUSH
66554: CALL_OW 72
66558: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66559: LD_EXP 141
66563: PUSH
66564: LD_VAR 0 1
66568: ARRAY
66569: IFFALSE 66593
// mechs := mechs diff mc_remote_driver [ base ] ;
66571: LD_ADDR_VAR 0 13
66575: PUSH
66576: LD_VAR 0 13
66580: PUSH
66581: LD_EXP 141
66585: PUSH
66586: LD_VAR 0 1
66590: ARRAY
66591: DIFF
66592: ST_TO_ADDR
// for i in mechs do
66593: LD_ADDR_VAR 0 5
66597: PUSH
66598: LD_VAR 0 13
66602: PUSH
66603: FOR_IN
66604: IFFALSE 66639
// if GetTag ( i ) > 0 then
66606: LD_VAR 0 5
66610: PPUSH
66611: CALL_OW 110
66615: PUSH
66616: LD_INT 0
66618: GREATER
66619: IFFALSE 66637
// mechs := mechs diff i ;
66621: LD_ADDR_VAR 0 13
66625: PUSH
66626: LD_VAR 0 13
66630: PUSH
66631: LD_VAR 0 5
66635: DIFF
66636: ST_TO_ADDR
66637: GO 66603
66639: POP
66640: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66641: LD_ADDR_VAR 0 9
66645: PUSH
66646: LD_EXP 101
66650: PUSH
66651: LD_VAR 0 1
66655: ARRAY
66656: PPUSH
66657: LD_INT 2
66659: PUSH
66660: LD_INT 25
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 25
66672: PUSH
66673: LD_INT 5
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 25
66682: PUSH
66683: LD_INT 8
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: LD_INT 25
66692: PUSH
66693: LD_INT 9
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: PPUSH
66707: CALL_OW 72
66711: ST_TO_ADDR
// if not defenders and not solds then
66712: LD_VAR 0 2
66716: NOT
66717: PUSH
66718: LD_VAR 0 9
66722: NOT
66723: AND
66724: IFFALSE 66728
// exit ;
66726: GO 68354
// depot_under_attack := false ;
66728: LD_ADDR_VAR 0 17
66732: PUSH
66733: LD_INT 0
66735: ST_TO_ADDR
// sold_defenders := [ ] ;
66736: LD_ADDR_VAR 0 18
66740: PUSH
66741: EMPTY
66742: ST_TO_ADDR
// if mechs then
66743: LD_VAR 0 13
66747: IFFALSE 66876
// for i in defenders do
66749: LD_ADDR_VAR 0 5
66753: PUSH
66754: LD_VAR 0 2
66758: PUSH
66759: FOR_IN
66760: IFFALSE 66874
// begin SetTag ( i , 20 ) ;
66762: LD_VAR 0 5
66766: PPUSH
66767: LD_INT 20
66769: PPUSH
66770: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66774: LD_VAR 0 5
66778: PPUSH
66779: CALL_OW 263
66783: PUSH
66784: LD_INT 1
66786: EQUAL
66787: PUSH
66788: LD_VAR 0 5
66792: PPUSH
66793: CALL_OW 311
66797: NOT
66798: AND
66799: PUSH
66800: LD_VAR 0 13
66804: AND
66805: IFFALSE 66872
// begin un := mechs [ 1 ] ;
66807: LD_ADDR_VAR 0 11
66811: PUSH
66812: LD_VAR 0 13
66816: PUSH
66817: LD_INT 1
66819: ARRAY
66820: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66821: LD_VAR 0 11
66825: PPUSH
66826: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66830: LD_VAR 0 11
66834: PPUSH
66835: LD_VAR 0 5
66839: PPUSH
66840: CALL_OW 180
// SetTag ( un , 19 ) ;
66844: LD_VAR 0 11
66848: PPUSH
66849: LD_INT 19
66851: PPUSH
66852: CALL_OW 109
// mechs := mechs diff un ;
66856: LD_ADDR_VAR 0 13
66860: PUSH
66861: LD_VAR 0 13
66865: PUSH
66866: LD_VAR 0 11
66870: DIFF
66871: ST_TO_ADDR
// end ; end ;
66872: GO 66759
66874: POP
66875: POP
// if solds then
66876: LD_VAR 0 9
66880: IFFALSE 66939
// for i in solds do
66882: LD_ADDR_VAR 0 5
66886: PUSH
66887: LD_VAR 0 9
66891: PUSH
66892: FOR_IN
66893: IFFALSE 66937
// if not GetTag ( i ) then
66895: LD_VAR 0 5
66899: PPUSH
66900: CALL_OW 110
66904: NOT
66905: IFFALSE 66935
// begin defenders := defenders union i ;
66907: LD_ADDR_VAR 0 2
66911: PUSH
66912: LD_VAR 0 2
66916: PUSH
66917: LD_VAR 0 5
66921: UNION
66922: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66923: LD_VAR 0 5
66927: PPUSH
66928: LD_INT 18
66930: PPUSH
66931: CALL_OW 109
// end ;
66935: GO 66892
66937: POP
66938: POP
// repeat wait ( 0 0$1 ) ;
66939: LD_INT 35
66941: PPUSH
66942: CALL_OW 67
// enemy := mc_scan [ base ] ;
66946: LD_ADDR_VAR 0 3
66950: PUSH
66951: LD_EXP 124
66955: PUSH
66956: LD_VAR 0 1
66960: ARRAY
66961: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66962: LD_EXP 101
66966: PUSH
66967: LD_VAR 0 1
66971: ARRAY
66972: NOT
66973: PUSH
66974: LD_EXP 101
66978: PUSH
66979: LD_VAR 0 1
66983: ARRAY
66984: PUSH
66985: EMPTY
66986: EQUAL
66987: OR
66988: IFFALSE 67025
// begin for i in defenders do
66990: LD_ADDR_VAR 0 5
66994: PUSH
66995: LD_VAR 0 2
66999: PUSH
67000: FOR_IN
67001: IFFALSE 67014
// ComStop ( i ) ;
67003: LD_VAR 0 5
67007: PPUSH
67008: CALL_OW 141
67012: GO 67000
67014: POP
67015: POP
// defenders := [ ] ;
67016: LD_ADDR_VAR 0 2
67020: PUSH
67021: EMPTY
67022: ST_TO_ADDR
// exit ;
67023: GO 68354
// end ; for i in defenders do
67025: LD_ADDR_VAR 0 5
67029: PUSH
67030: LD_VAR 0 2
67034: PUSH
67035: FOR_IN
67036: IFFALSE 67854
// begin e := NearestUnitToUnit ( enemy , i ) ;
67038: LD_ADDR_VAR 0 14
67042: PUSH
67043: LD_VAR 0 3
67047: PPUSH
67048: LD_VAR 0 5
67052: PPUSH
67053: CALL_OW 74
67057: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67058: LD_ADDR_VAR 0 8
67062: PUSH
67063: LD_EXP 101
67067: PUSH
67068: LD_VAR 0 1
67072: ARRAY
67073: PPUSH
67074: LD_INT 2
67076: PUSH
67077: LD_INT 30
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 30
67089: PUSH
67090: LD_INT 1
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: LIST
67101: PPUSH
67102: CALL_OW 72
67106: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67107: LD_ADDR_VAR 0 17
67111: PUSH
67112: LD_VAR 0 8
67116: NOT
67117: PUSH
67118: LD_VAR 0 8
67122: PPUSH
67123: LD_INT 3
67125: PUSH
67126: LD_INT 24
67128: PUSH
67129: LD_INT 600
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PPUSH
67140: CALL_OW 72
67144: OR
67145: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67146: LD_VAR 0 5
67150: PPUSH
67151: CALL_OW 247
67155: PUSH
67156: LD_INT 2
67158: DOUBLE
67159: EQUAL
67160: IFTRUE 67164
67162: GO 67560
67164: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67165: LD_VAR 0 5
67169: PPUSH
67170: CALL_OW 256
67174: PUSH
67175: LD_INT 650
67177: GREATER
67178: PUSH
67179: LD_VAR 0 5
67183: PPUSH
67184: LD_VAR 0 14
67188: PPUSH
67189: CALL_OW 296
67193: PUSH
67194: LD_INT 40
67196: LESS
67197: PUSH
67198: LD_VAR 0 14
67202: PPUSH
67203: LD_EXP 126
67207: PUSH
67208: LD_VAR 0 1
67212: ARRAY
67213: PPUSH
67214: CALL_OW 308
67218: OR
67219: AND
67220: IFFALSE 67342
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67222: LD_VAR 0 5
67226: PPUSH
67227: CALL_OW 262
67231: PUSH
67232: LD_INT 1
67234: EQUAL
67235: PUSH
67236: LD_VAR 0 5
67240: PPUSH
67241: CALL_OW 261
67245: PUSH
67246: LD_INT 30
67248: LESS
67249: AND
67250: PUSH
67251: LD_VAR 0 8
67255: AND
67256: IFFALSE 67326
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67258: LD_VAR 0 5
67262: PPUSH
67263: LD_VAR 0 8
67267: PPUSH
67268: LD_VAR 0 5
67272: PPUSH
67273: CALL_OW 74
67277: PPUSH
67278: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67282: LD_VAR 0 5
67286: PPUSH
67287: LD_VAR 0 8
67291: PPUSH
67292: LD_VAR 0 5
67296: PPUSH
67297: CALL_OW 74
67301: PPUSH
67302: CALL_OW 296
67306: PUSH
67307: LD_INT 6
67309: LESS
67310: IFFALSE 67324
// SetFuel ( i , 100 ) ;
67312: LD_VAR 0 5
67316: PPUSH
67317: LD_INT 100
67319: PPUSH
67320: CALL_OW 240
// end else
67324: GO 67340
// ComAttackUnit ( i , e ) ;
67326: LD_VAR 0 5
67330: PPUSH
67331: LD_VAR 0 14
67335: PPUSH
67336: CALL_OW 115
// end else
67340: GO 67443
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67342: LD_VAR 0 14
67346: PPUSH
67347: LD_EXP 126
67351: PUSH
67352: LD_VAR 0 1
67356: ARRAY
67357: PPUSH
67358: CALL_OW 308
67362: NOT
67363: PUSH
67364: LD_VAR 0 5
67368: PPUSH
67369: LD_VAR 0 14
67373: PPUSH
67374: CALL_OW 296
67378: PUSH
67379: LD_INT 40
67381: GREATEREQUAL
67382: AND
67383: PUSH
67384: LD_VAR 0 5
67388: PPUSH
67389: CALL_OW 256
67393: PUSH
67394: LD_INT 650
67396: LESSEQUAL
67397: OR
67398: PUSH
67399: LD_VAR 0 5
67403: PPUSH
67404: LD_EXP 125
67408: PUSH
67409: LD_VAR 0 1
67413: ARRAY
67414: PPUSH
67415: CALL_OW 308
67419: NOT
67420: AND
67421: IFFALSE 67443
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67423: LD_VAR 0 5
67427: PPUSH
67428: LD_EXP 125
67432: PUSH
67433: LD_VAR 0 1
67437: ARRAY
67438: PPUSH
67439: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67443: LD_VAR 0 5
67447: PPUSH
67448: CALL_OW 256
67452: PUSH
67453: LD_INT 998
67455: LESS
67456: PUSH
67457: LD_VAR 0 5
67461: PPUSH
67462: CALL_OW 263
67466: PUSH
67467: LD_INT 1
67469: EQUAL
67470: AND
67471: PUSH
67472: LD_VAR 0 5
67476: PPUSH
67477: CALL_OW 311
67481: AND
67482: PUSH
67483: LD_VAR 0 5
67487: PPUSH
67488: LD_EXP 125
67492: PUSH
67493: LD_VAR 0 1
67497: ARRAY
67498: PPUSH
67499: CALL_OW 308
67503: AND
67504: IFFALSE 67558
// begin mech := IsDrivenBy ( i ) ;
67506: LD_ADDR_VAR 0 10
67510: PUSH
67511: LD_VAR 0 5
67515: PPUSH
67516: CALL_OW 311
67520: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67521: LD_VAR 0 10
67525: PPUSH
67526: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67530: LD_VAR 0 10
67534: PPUSH
67535: LD_VAR 0 5
67539: PPUSH
67540: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67544: LD_VAR 0 10
67548: PPUSH
67549: LD_VAR 0 5
67553: PPUSH
67554: CALL_OW 180
// end ; end ; unit_human :
67558: GO 67825
67560: LD_INT 1
67562: DOUBLE
67563: EQUAL
67564: IFTRUE 67568
67566: GO 67824
67568: POP
// begin b := IsInUnit ( i ) ;
67569: LD_ADDR_VAR 0 19
67573: PUSH
67574: LD_VAR 0 5
67578: PPUSH
67579: CALL_OW 310
67583: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67584: LD_ADDR_VAR 0 20
67588: PUSH
67589: LD_VAR 0 19
67593: NOT
67594: PUSH
67595: LD_VAR 0 19
67599: PPUSH
67600: CALL_OW 266
67604: PUSH
67605: LD_INT 32
67607: PUSH
67608: LD_INT 31
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: IN
67615: OR
67616: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67617: LD_VAR 0 17
67621: PUSH
67622: LD_VAR 0 2
67626: PPUSH
67627: LD_INT 21
67629: PUSH
67630: LD_INT 2
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PPUSH
67637: CALL_OW 72
67641: PUSH
67642: LD_INT 1
67644: LESSEQUAL
67645: OR
67646: PUSH
67647: LD_VAR 0 20
67651: AND
67652: PUSH
67653: LD_VAR 0 5
67657: PUSH
67658: LD_VAR 0 18
67662: IN
67663: NOT
67664: AND
67665: IFFALSE 67758
// begin if b then
67667: LD_VAR 0 19
67671: IFFALSE 67720
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67673: LD_VAR 0 19
67677: PPUSH
67678: LD_VAR 0 3
67682: PPUSH
67683: LD_VAR 0 19
67687: PPUSH
67688: CALL_OW 74
67692: PPUSH
67693: CALL_OW 296
67697: PUSH
67698: LD_INT 10
67700: LESS
67701: PUSH
67702: LD_VAR 0 19
67706: PPUSH
67707: CALL_OW 461
67711: PUSH
67712: LD_INT 7
67714: NONEQUAL
67715: AND
67716: IFFALSE 67720
// continue ;
67718: GO 67035
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67720: LD_ADDR_VAR 0 18
67724: PUSH
67725: LD_VAR 0 18
67729: PPUSH
67730: LD_VAR 0 18
67734: PUSH
67735: LD_INT 1
67737: PLUS
67738: PPUSH
67739: LD_VAR 0 5
67743: PPUSH
67744: CALL_OW 1
67748: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67749: LD_VAR 0 5
67753: PPUSH
67754: CALL_OW 122
// end ; if sold_defenders then
67758: LD_VAR 0 18
67762: IFFALSE 67822
// if i in sold_defenders then
67764: LD_VAR 0 5
67768: PUSH
67769: LD_VAR 0 18
67773: IN
67774: IFFALSE 67822
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67776: LD_VAR 0 5
67780: PPUSH
67781: CALL_OW 314
67785: NOT
67786: PUSH
67787: LD_VAR 0 5
67791: PPUSH
67792: LD_VAR 0 14
67796: PPUSH
67797: CALL_OW 296
67801: PUSH
67802: LD_INT 30
67804: LESS
67805: AND
67806: IFFALSE 67822
// ComAttackUnit ( i , e ) ;
67808: LD_VAR 0 5
67812: PPUSH
67813: LD_VAR 0 14
67817: PPUSH
67818: CALL_OW 115
// end ; end ; end ;
67822: GO 67825
67824: POP
// if IsDead ( i ) then
67825: LD_VAR 0 5
67829: PPUSH
67830: CALL_OW 301
67834: IFFALSE 67852
// defenders := defenders diff i ;
67836: LD_ADDR_VAR 0 2
67840: PUSH
67841: LD_VAR 0 2
67845: PUSH
67846: LD_VAR 0 5
67850: DIFF
67851: ST_TO_ADDR
// end ;
67852: GO 67035
67854: POP
67855: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67856: LD_VAR 0 3
67860: NOT
67861: PUSH
67862: LD_VAR 0 2
67866: NOT
67867: OR
67868: PUSH
67869: LD_EXP 101
67873: PUSH
67874: LD_VAR 0 1
67878: ARRAY
67879: NOT
67880: OR
67881: IFFALSE 66939
// MC_Reset ( base , 18 ) ;
67883: LD_VAR 0 1
67887: PPUSH
67888: LD_INT 18
67890: PPUSH
67891: CALL 38325 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67895: LD_ADDR_VAR 0 2
67899: PUSH
67900: LD_VAR 0 2
67904: PUSH
67905: LD_VAR 0 2
67909: PPUSH
67910: LD_INT 2
67912: PUSH
67913: LD_INT 25
67915: PUSH
67916: LD_INT 1
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: PUSH
67923: LD_INT 25
67925: PUSH
67926: LD_INT 5
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 25
67935: PUSH
67936: LD_INT 8
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 25
67945: PUSH
67946: LD_INT 9
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: PPUSH
67960: CALL_OW 72
67964: DIFF
67965: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67966: LD_VAR 0 3
67970: NOT
67971: PUSH
67972: LD_VAR 0 2
67976: PPUSH
67977: LD_INT 21
67979: PUSH
67980: LD_INT 2
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PPUSH
67987: CALL_OW 72
67991: AND
67992: IFFALSE 68330
// begin tmp := FilterByTag ( defenders , 19 ) ;
67994: LD_ADDR_VAR 0 12
67998: PUSH
67999: LD_VAR 0 2
68003: PPUSH
68004: LD_INT 19
68006: PPUSH
68007: CALL 104786 0 2
68011: ST_TO_ADDR
// if tmp then
68012: LD_VAR 0 12
68016: IFFALSE 68086
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68018: LD_ADDR_VAR 0 12
68022: PUSH
68023: LD_VAR 0 12
68027: PPUSH
68028: LD_INT 25
68030: PUSH
68031: LD_INT 3
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PPUSH
68038: CALL_OW 72
68042: ST_TO_ADDR
// if tmp then
68043: LD_VAR 0 12
68047: IFFALSE 68086
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68049: LD_ADDR_EXP 113
68053: PUSH
68054: LD_EXP 113
68058: PPUSH
68059: LD_VAR 0 1
68063: PPUSH
68064: LD_EXP 113
68068: PUSH
68069: LD_VAR 0 1
68073: ARRAY
68074: PUSH
68075: LD_VAR 0 12
68079: UNION
68080: PPUSH
68081: CALL_OW 1
68085: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68086: LD_VAR 0 1
68090: PPUSH
68091: LD_INT 19
68093: PPUSH
68094: CALL 38325 0 2
// repeat wait ( 0 0$1 ) ;
68098: LD_INT 35
68100: PPUSH
68101: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68105: LD_EXP 101
68109: PUSH
68110: LD_VAR 0 1
68114: ARRAY
68115: NOT
68116: PUSH
68117: LD_EXP 101
68121: PUSH
68122: LD_VAR 0 1
68126: ARRAY
68127: PUSH
68128: EMPTY
68129: EQUAL
68130: OR
68131: IFFALSE 68168
// begin for i in defenders do
68133: LD_ADDR_VAR 0 5
68137: PUSH
68138: LD_VAR 0 2
68142: PUSH
68143: FOR_IN
68144: IFFALSE 68157
// ComStop ( i ) ;
68146: LD_VAR 0 5
68150: PPUSH
68151: CALL_OW 141
68155: GO 68143
68157: POP
68158: POP
// defenders := [ ] ;
68159: LD_ADDR_VAR 0 2
68163: PUSH
68164: EMPTY
68165: ST_TO_ADDR
// exit ;
68166: GO 68354
// end ; for i in defenders do
68168: LD_ADDR_VAR 0 5
68172: PUSH
68173: LD_VAR 0 2
68177: PUSH
68178: FOR_IN
68179: IFFALSE 68268
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68181: LD_VAR 0 5
68185: PPUSH
68186: LD_EXP 125
68190: PUSH
68191: LD_VAR 0 1
68195: ARRAY
68196: PPUSH
68197: CALL_OW 308
68201: NOT
68202: IFFALSE 68226
// ComMoveToArea ( i , mc_parking [ base ] ) else
68204: LD_VAR 0 5
68208: PPUSH
68209: LD_EXP 125
68213: PUSH
68214: LD_VAR 0 1
68218: ARRAY
68219: PPUSH
68220: CALL_OW 113
68224: GO 68266
// if GetControl ( i ) = control_manual then
68226: LD_VAR 0 5
68230: PPUSH
68231: CALL_OW 263
68235: PUSH
68236: LD_INT 1
68238: EQUAL
68239: IFFALSE 68266
// if IsDrivenBy ( i ) then
68241: LD_VAR 0 5
68245: PPUSH
68246: CALL_OW 311
68250: IFFALSE 68266
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68252: LD_VAR 0 5
68256: PPUSH
68257: CALL_OW 311
68261: PPUSH
68262: CALL_OW 121
// end ;
68266: GO 68178
68268: POP
68269: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68270: LD_VAR 0 2
68274: PPUSH
68275: LD_INT 95
68277: PUSH
68278: LD_EXP 125
68282: PUSH
68283: LD_VAR 0 1
68287: ARRAY
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PPUSH
68293: CALL_OW 72
68297: PUSH
68298: LD_VAR 0 2
68302: EQUAL
68303: PUSH
68304: LD_EXP 124
68308: PUSH
68309: LD_VAR 0 1
68313: ARRAY
68314: OR
68315: PUSH
68316: LD_EXP 101
68320: PUSH
68321: LD_VAR 0 1
68325: ARRAY
68326: NOT
68327: OR
68328: IFFALSE 68098
// end ; MC_Reset ( base , 19 ) ;
68330: LD_VAR 0 1
68334: PPUSH
68335: LD_INT 19
68337: PPUSH
68338: CALL 38325 0 2
// MC_Reset ( base , 20 ) ;
68342: LD_VAR 0 1
68346: PPUSH
68347: LD_INT 20
68349: PPUSH
68350: CALL 38325 0 2
// end ;
68354: LD_VAR 0 4
68358: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68359: LD_INT 0
68361: PPUSH
68362: PPUSH
68363: PPUSH
68364: PPUSH
// result := false ;
68365: LD_ADDR_VAR 0 2
68369: PUSH
68370: LD_INT 0
68372: ST_TO_ADDR
// side := GetSide ( unit ) ;
68373: LD_ADDR_VAR 0 3
68377: PUSH
68378: LD_VAR 0 1
68382: PPUSH
68383: CALL_OW 255
68387: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68388: LD_ADDR_VAR 0 4
68392: PUSH
68393: LD_VAR 0 1
68397: PPUSH
68398: CALL_OW 248
68402: ST_TO_ADDR
// case nat of 1 :
68403: LD_VAR 0 4
68407: PUSH
68408: LD_INT 1
68410: DOUBLE
68411: EQUAL
68412: IFTRUE 68416
68414: GO 68427
68416: POP
// tech := tech_lassight ; 2 :
68417: LD_ADDR_VAR 0 5
68421: PUSH
68422: LD_INT 12
68424: ST_TO_ADDR
68425: GO 68466
68427: LD_INT 2
68429: DOUBLE
68430: EQUAL
68431: IFTRUE 68435
68433: GO 68446
68435: POP
// tech := tech_mortar ; 3 :
68436: LD_ADDR_VAR 0 5
68440: PUSH
68441: LD_INT 41
68443: ST_TO_ADDR
68444: GO 68466
68446: LD_INT 3
68448: DOUBLE
68449: EQUAL
68450: IFTRUE 68454
68452: GO 68465
68454: POP
// tech := tech_bazooka ; end ;
68455: LD_ADDR_VAR 0 5
68459: PUSH
68460: LD_INT 44
68462: ST_TO_ADDR
68463: GO 68466
68465: POP
// if Researched ( side , tech ) then
68466: LD_VAR 0 3
68470: PPUSH
68471: LD_VAR 0 5
68475: PPUSH
68476: CALL_OW 325
68480: IFFALSE 68507
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68482: LD_ADDR_VAR 0 2
68486: PUSH
68487: LD_INT 5
68489: PUSH
68490: LD_INT 8
68492: PUSH
68493: LD_INT 9
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: LIST
68500: PUSH
68501: LD_VAR 0 4
68505: ARRAY
68506: ST_TO_ADDR
// end ;
68507: LD_VAR 0 2
68511: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68512: LD_INT 0
68514: PPUSH
68515: PPUSH
68516: PPUSH
// if not mines then
68517: LD_VAR 0 2
68521: NOT
68522: IFFALSE 68526
// exit ;
68524: GO 68670
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68526: LD_ADDR_VAR 0 5
68530: PUSH
68531: LD_INT 81
68533: PUSH
68534: LD_VAR 0 1
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 3
68545: PUSH
68546: LD_INT 21
68548: PUSH
68549: LD_INT 3
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PPUSH
68564: CALL_OW 69
68568: ST_TO_ADDR
// for i in mines do
68569: LD_ADDR_VAR 0 4
68573: PUSH
68574: LD_VAR 0 2
68578: PUSH
68579: FOR_IN
68580: IFFALSE 68668
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68582: LD_VAR 0 4
68586: PUSH
68587: LD_INT 1
68589: ARRAY
68590: PPUSH
68591: LD_VAR 0 4
68595: PUSH
68596: LD_INT 2
68598: ARRAY
68599: PPUSH
68600: CALL_OW 458
68604: NOT
68605: IFFALSE 68609
// continue ;
68607: GO 68579
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68609: LD_VAR 0 4
68613: PUSH
68614: LD_INT 1
68616: ARRAY
68617: PPUSH
68618: LD_VAR 0 4
68622: PUSH
68623: LD_INT 2
68625: ARRAY
68626: PPUSH
68627: CALL_OW 428
68631: PUSH
68632: LD_VAR 0 5
68636: IN
68637: IFFALSE 68666
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68639: LD_VAR 0 4
68643: PUSH
68644: LD_INT 1
68646: ARRAY
68647: PPUSH
68648: LD_VAR 0 4
68652: PUSH
68653: LD_INT 2
68655: ARRAY
68656: PPUSH
68657: LD_VAR 0 1
68661: PPUSH
68662: CALL_OW 456
// end ;
68666: GO 68579
68668: POP
68669: POP
// end ;
68670: LD_VAR 0 3
68674: RET
// export function Count ( array ) ; var i ; begin
68675: LD_INT 0
68677: PPUSH
68678: PPUSH
// result := 0 ;
68679: LD_ADDR_VAR 0 2
68683: PUSH
68684: LD_INT 0
68686: ST_TO_ADDR
// for i in array do
68687: LD_ADDR_VAR 0 3
68691: PUSH
68692: LD_VAR 0 1
68696: PUSH
68697: FOR_IN
68698: IFFALSE 68722
// if i then
68700: LD_VAR 0 3
68704: IFFALSE 68720
// result := result + 1 ;
68706: LD_ADDR_VAR 0 2
68710: PUSH
68711: LD_VAR 0 2
68715: PUSH
68716: LD_INT 1
68718: PLUS
68719: ST_TO_ADDR
68720: GO 68697
68722: POP
68723: POP
// end ;
68724: LD_VAR 0 2
68728: RET
// export function IsEmpty ( building ) ; begin
68729: LD_INT 0
68731: PPUSH
// if not building then
68732: LD_VAR 0 1
68736: NOT
68737: IFFALSE 68741
// exit ;
68739: GO 68784
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68741: LD_ADDR_VAR 0 2
68745: PUSH
68746: LD_VAR 0 1
68750: PUSH
68751: LD_INT 22
68753: PUSH
68754: LD_VAR 0 1
68758: PPUSH
68759: CALL_OW 255
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 58
68770: PUSH
68771: EMPTY
68772: LIST
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PPUSH
68778: CALL_OW 69
68782: IN
68783: ST_TO_ADDR
// end ;
68784: LD_VAR 0 2
68788: RET
// export function IsNotFull ( building ) ; begin
68789: LD_INT 0
68791: PPUSH
// if not building then
68792: LD_VAR 0 1
68796: NOT
68797: IFFALSE 68801
// exit ;
68799: GO 68820
// result := UnitsInside ( building ) < 6 ;
68801: LD_ADDR_VAR 0 2
68805: PUSH
68806: LD_VAR 0 1
68810: PPUSH
68811: CALL_OW 313
68815: PUSH
68816: LD_INT 6
68818: LESS
68819: ST_TO_ADDR
// end ;
68820: LD_VAR 0 2
68824: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68825: LD_INT 0
68827: PPUSH
68828: PPUSH
68829: PPUSH
68830: PPUSH
// tmp := [ ] ;
68831: LD_ADDR_VAR 0 3
68835: PUSH
68836: EMPTY
68837: ST_TO_ADDR
// list := [ ] ;
68838: LD_ADDR_VAR 0 5
68842: PUSH
68843: EMPTY
68844: ST_TO_ADDR
// for i = 16 to 25 do
68845: LD_ADDR_VAR 0 4
68849: PUSH
68850: DOUBLE
68851: LD_INT 16
68853: DEC
68854: ST_TO_ADDR
68855: LD_INT 25
68857: PUSH
68858: FOR_TO
68859: IFFALSE 68932
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68861: LD_ADDR_VAR 0 3
68865: PUSH
68866: LD_VAR 0 3
68870: PUSH
68871: LD_INT 22
68873: PUSH
68874: LD_VAR 0 1
68878: PPUSH
68879: CALL_OW 255
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 91
68890: PUSH
68891: LD_VAR 0 1
68895: PUSH
68896: LD_INT 6
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 30
68906: PUSH
68907: LD_VAR 0 4
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: LIST
68920: PUSH
68921: EMPTY
68922: LIST
68923: PPUSH
68924: CALL_OW 69
68928: ADD
68929: ST_TO_ADDR
68930: GO 68858
68932: POP
68933: POP
// for i = 1 to tmp do
68934: LD_ADDR_VAR 0 4
68938: PUSH
68939: DOUBLE
68940: LD_INT 1
68942: DEC
68943: ST_TO_ADDR
68944: LD_VAR 0 3
68948: PUSH
68949: FOR_TO
68950: IFFALSE 69038
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68952: LD_ADDR_VAR 0 5
68956: PUSH
68957: LD_VAR 0 5
68961: PUSH
68962: LD_VAR 0 3
68966: PUSH
68967: LD_VAR 0 4
68971: ARRAY
68972: PPUSH
68973: CALL_OW 266
68977: PUSH
68978: LD_VAR 0 3
68982: PUSH
68983: LD_VAR 0 4
68987: ARRAY
68988: PPUSH
68989: CALL_OW 250
68993: PUSH
68994: LD_VAR 0 3
68998: PUSH
68999: LD_VAR 0 4
69003: ARRAY
69004: PPUSH
69005: CALL_OW 251
69009: PUSH
69010: LD_VAR 0 3
69014: PUSH
69015: LD_VAR 0 4
69019: ARRAY
69020: PPUSH
69021: CALL_OW 254
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: PUSH
69032: EMPTY
69033: LIST
69034: ADD
69035: ST_TO_ADDR
69036: GO 68949
69038: POP
69039: POP
// result := list ;
69040: LD_ADDR_VAR 0 2
69044: PUSH
69045: LD_VAR 0 5
69049: ST_TO_ADDR
// end ;
69050: LD_VAR 0 2
69054: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69055: LD_INT 0
69057: PPUSH
69058: PPUSH
69059: PPUSH
69060: PPUSH
69061: PPUSH
69062: PPUSH
69063: PPUSH
// if not factory then
69064: LD_VAR 0 1
69068: NOT
69069: IFFALSE 69073
// exit ;
69071: GO 69666
// if control = control_apeman then
69073: LD_VAR 0 4
69077: PUSH
69078: LD_INT 5
69080: EQUAL
69081: IFFALSE 69190
// begin tmp := UnitsInside ( factory ) ;
69083: LD_ADDR_VAR 0 8
69087: PUSH
69088: LD_VAR 0 1
69092: PPUSH
69093: CALL_OW 313
69097: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69098: LD_VAR 0 8
69102: PPUSH
69103: LD_INT 25
69105: PUSH
69106: LD_INT 12
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PPUSH
69113: CALL_OW 72
69117: NOT
69118: IFFALSE 69128
// control := control_manual ;
69120: LD_ADDR_VAR 0 4
69124: PUSH
69125: LD_INT 1
69127: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69128: LD_ADDR_VAR 0 8
69132: PUSH
69133: LD_VAR 0 1
69137: PPUSH
69138: CALL 68825 0 1
69142: ST_TO_ADDR
// if tmp then
69143: LD_VAR 0 8
69147: IFFALSE 69190
// begin for i in tmp do
69149: LD_ADDR_VAR 0 7
69153: PUSH
69154: LD_VAR 0 8
69158: PUSH
69159: FOR_IN
69160: IFFALSE 69188
// if i [ 1 ] = b_ext_radio then
69162: LD_VAR 0 7
69166: PUSH
69167: LD_INT 1
69169: ARRAY
69170: PUSH
69171: LD_INT 22
69173: EQUAL
69174: IFFALSE 69186
// begin control := control_remote ;
69176: LD_ADDR_VAR 0 4
69180: PUSH
69181: LD_INT 2
69183: ST_TO_ADDR
// break ;
69184: GO 69188
// end ;
69186: GO 69159
69188: POP
69189: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69190: LD_VAR 0 1
69194: PPUSH
69195: LD_VAR 0 2
69199: PPUSH
69200: LD_VAR 0 3
69204: PPUSH
69205: LD_VAR 0 4
69209: PPUSH
69210: LD_VAR 0 5
69214: PPUSH
69215: CALL_OW 448
69219: IFFALSE 69254
// begin result := [ chassis , engine , control , weapon ] ;
69221: LD_ADDR_VAR 0 6
69225: PUSH
69226: LD_VAR 0 2
69230: PUSH
69231: LD_VAR 0 3
69235: PUSH
69236: LD_VAR 0 4
69240: PUSH
69241: LD_VAR 0 5
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: ST_TO_ADDR
// exit ;
69252: GO 69666
// end ; _chassis := AvailableChassisList ( factory ) ;
69254: LD_ADDR_VAR 0 9
69258: PUSH
69259: LD_VAR 0 1
69263: PPUSH
69264: CALL_OW 475
69268: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69269: LD_ADDR_VAR 0 11
69273: PUSH
69274: LD_VAR 0 1
69278: PPUSH
69279: CALL_OW 476
69283: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69284: LD_ADDR_VAR 0 12
69288: PUSH
69289: LD_VAR 0 1
69293: PPUSH
69294: CALL_OW 477
69298: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69299: LD_ADDR_VAR 0 10
69303: PUSH
69304: LD_VAR 0 1
69308: PPUSH
69309: CALL_OW 478
69313: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69314: LD_VAR 0 9
69318: NOT
69319: PUSH
69320: LD_VAR 0 11
69324: NOT
69325: OR
69326: PUSH
69327: LD_VAR 0 12
69331: NOT
69332: OR
69333: PUSH
69334: LD_VAR 0 10
69338: NOT
69339: OR
69340: IFFALSE 69375
// begin result := [ chassis , engine , control , weapon ] ;
69342: LD_ADDR_VAR 0 6
69346: PUSH
69347: LD_VAR 0 2
69351: PUSH
69352: LD_VAR 0 3
69356: PUSH
69357: LD_VAR 0 4
69361: PUSH
69362: LD_VAR 0 5
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
// exit ;
69373: GO 69666
// end ; if not chassis in _chassis then
69375: LD_VAR 0 2
69379: PUSH
69380: LD_VAR 0 9
69384: IN
69385: NOT
69386: IFFALSE 69412
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69388: LD_ADDR_VAR 0 2
69392: PUSH
69393: LD_VAR 0 9
69397: PUSH
69398: LD_INT 1
69400: PPUSH
69401: LD_VAR 0 9
69405: PPUSH
69406: CALL_OW 12
69410: ARRAY
69411: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69412: LD_VAR 0 2
69416: PPUSH
69417: LD_VAR 0 3
69421: PPUSH
69422: CALL 69671 0 2
69426: NOT
69427: IFFALSE 69486
// repeat engine := _engine [ 1 ] ;
69429: LD_ADDR_VAR 0 3
69433: PUSH
69434: LD_VAR 0 11
69438: PUSH
69439: LD_INT 1
69441: ARRAY
69442: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69443: LD_ADDR_VAR 0 11
69447: PUSH
69448: LD_VAR 0 11
69452: PPUSH
69453: LD_INT 1
69455: PPUSH
69456: CALL_OW 3
69460: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69461: LD_VAR 0 2
69465: PPUSH
69466: LD_VAR 0 3
69470: PPUSH
69471: CALL 69671 0 2
69475: PUSH
69476: LD_VAR 0 11
69480: PUSH
69481: EMPTY
69482: EQUAL
69483: OR
69484: IFFALSE 69429
// if not control in _control then
69486: LD_VAR 0 4
69490: PUSH
69491: LD_VAR 0 12
69495: IN
69496: NOT
69497: IFFALSE 69523
// control := _control [ rand ( 1 , _control ) ] ;
69499: LD_ADDR_VAR 0 4
69503: PUSH
69504: LD_VAR 0 12
69508: PUSH
69509: LD_INT 1
69511: PPUSH
69512: LD_VAR 0 12
69516: PPUSH
69517: CALL_OW 12
69521: ARRAY
69522: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69523: LD_VAR 0 2
69527: PPUSH
69528: LD_VAR 0 5
69532: PPUSH
69533: CALL 69891 0 2
69537: NOT
69538: IFFALSE 69597
// repeat weapon := _weapon [ 1 ] ;
69540: LD_ADDR_VAR 0 5
69544: PUSH
69545: LD_VAR 0 10
69549: PUSH
69550: LD_INT 1
69552: ARRAY
69553: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69554: LD_ADDR_VAR 0 10
69558: PUSH
69559: LD_VAR 0 10
69563: PPUSH
69564: LD_INT 1
69566: PPUSH
69567: CALL_OW 3
69571: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69572: LD_VAR 0 2
69576: PPUSH
69577: LD_VAR 0 5
69581: PPUSH
69582: CALL 69891 0 2
69586: PUSH
69587: LD_VAR 0 10
69591: PUSH
69592: EMPTY
69593: EQUAL
69594: OR
69595: IFFALSE 69540
// result := [ ] ;
69597: LD_ADDR_VAR 0 6
69601: PUSH
69602: EMPTY
69603: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69604: LD_VAR 0 1
69608: PPUSH
69609: LD_VAR 0 2
69613: PPUSH
69614: LD_VAR 0 3
69618: PPUSH
69619: LD_VAR 0 4
69623: PPUSH
69624: LD_VAR 0 5
69628: PPUSH
69629: CALL_OW 448
69633: IFFALSE 69666
// result := [ chassis , engine , control , weapon ] ;
69635: LD_ADDR_VAR 0 6
69639: PUSH
69640: LD_VAR 0 2
69644: PUSH
69645: LD_VAR 0 3
69649: PUSH
69650: LD_VAR 0 4
69654: PUSH
69655: LD_VAR 0 5
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: ST_TO_ADDR
// end ;
69666: LD_VAR 0 6
69670: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69671: LD_INT 0
69673: PPUSH
// if not chassis or not engine then
69674: LD_VAR 0 1
69678: NOT
69679: PUSH
69680: LD_VAR 0 2
69684: NOT
69685: OR
69686: IFFALSE 69690
// exit ;
69688: GO 69886
// case engine of engine_solar :
69690: LD_VAR 0 2
69694: PUSH
69695: LD_INT 2
69697: DOUBLE
69698: EQUAL
69699: IFTRUE 69703
69701: GO 69741
69703: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69704: LD_ADDR_VAR 0 3
69708: PUSH
69709: LD_INT 11
69711: PUSH
69712: LD_INT 12
69714: PUSH
69715: LD_INT 13
69717: PUSH
69718: LD_INT 14
69720: PUSH
69721: LD_INT 1
69723: PUSH
69724: LD_INT 2
69726: PUSH
69727: LD_INT 3
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: ST_TO_ADDR
69739: GO 69870
69741: LD_INT 1
69743: DOUBLE
69744: EQUAL
69745: IFTRUE 69749
69747: GO 69811
69749: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69750: LD_ADDR_VAR 0 3
69754: PUSH
69755: LD_INT 11
69757: PUSH
69758: LD_INT 12
69760: PUSH
69761: LD_INT 13
69763: PUSH
69764: LD_INT 14
69766: PUSH
69767: LD_INT 1
69769: PUSH
69770: LD_INT 2
69772: PUSH
69773: LD_INT 3
69775: PUSH
69776: LD_INT 4
69778: PUSH
69779: LD_INT 5
69781: PUSH
69782: LD_INT 21
69784: PUSH
69785: LD_INT 23
69787: PUSH
69788: LD_INT 22
69790: PUSH
69791: LD_INT 24
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: ST_TO_ADDR
69809: GO 69870
69811: LD_INT 3
69813: DOUBLE
69814: EQUAL
69815: IFTRUE 69819
69817: GO 69869
69819: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69820: LD_ADDR_VAR 0 3
69824: PUSH
69825: LD_INT 13
69827: PUSH
69828: LD_INT 14
69830: PUSH
69831: LD_INT 2
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: LD_INT 4
69839: PUSH
69840: LD_INT 5
69842: PUSH
69843: LD_INT 21
69845: PUSH
69846: LD_INT 22
69848: PUSH
69849: LD_INT 23
69851: PUSH
69852: LD_INT 24
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: ST_TO_ADDR
69867: GO 69870
69869: POP
// result := ( chassis in result ) ;
69870: LD_ADDR_VAR 0 3
69874: PUSH
69875: LD_VAR 0 1
69879: PUSH
69880: LD_VAR 0 3
69884: IN
69885: ST_TO_ADDR
// end ;
69886: LD_VAR 0 3
69890: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69891: LD_INT 0
69893: PPUSH
// if not chassis or not weapon then
69894: LD_VAR 0 1
69898: NOT
69899: PUSH
69900: LD_VAR 0 2
69904: NOT
69905: OR
69906: IFFALSE 69910
// exit ;
69908: GO 70936
// case weapon of us_machine_gun :
69910: LD_VAR 0 2
69914: PUSH
69915: LD_INT 2
69917: DOUBLE
69918: EQUAL
69919: IFTRUE 69923
69921: GO 69953
69923: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69924: LD_ADDR_VAR 0 3
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: LD_INT 2
69934: PUSH
69935: LD_INT 3
69937: PUSH
69938: LD_INT 4
69940: PUSH
69941: LD_INT 5
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: ST_TO_ADDR
69951: GO 70920
69953: LD_INT 3
69955: DOUBLE
69956: EQUAL
69957: IFTRUE 69961
69959: GO 69991
69961: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69962: LD_ADDR_VAR 0 3
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: LD_INT 2
69972: PUSH
69973: LD_INT 3
69975: PUSH
69976: LD_INT 4
69978: PUSH
69979: LD_INT 5
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: LIST
69988: ST_TO_ADDR
69989: GO 70920
69991: LD_INT 11
69993: DOUBLE
69994: EQUAL
69995: IFTRUE 69999
69997: GO 70029
69999: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70000: LD_ADDR_VAR 0 3
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: LD_INT 3
70013: PUSH
70014: LD_INT 4
70016: PUSH
70017: LD_INT 5
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: ST_TO_ADDR
70027: GO 70920
70029: LD_INT 4
70031: DOUBLE
70032: EQUAL
70033: IFTRUE 70037
70035: GO 70063
70037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70038: LD_ADDR_VAR 0 3
70042: PUSH
70043: LD_INT 2
70045: PUSH
70046: LD_INT 3
70048: PUSH
70049: LD_INT 4
70051: PUSH
70052: LD_INT 5
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: ST_TO_ADDR
70061: GO 70920
70063: LD_INT 5
70065: DOUBLE
70066: EQUAL
70067: IFTRUE 70071
70069: GO 70097
70071: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70072: LD_ADDR_VAR 0 3
70076: PUSH
70077: LD_INT 2
70079: PUSH
70080: LD_INT 3
70082: PUSH
70083: LD_INT 4
70085: PUSH
70086: LD_INT 5
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: ST_TO_ADDR
70095: GO 70920
70097: LD_INT 9
70099: DOUBLE
70100: EQUAL
70101: IFTRUE 70105
70103: GO 70131
70105: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70106: LD_ADDR_VAR 0 3
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 3
70116: PUSH
70117: LD_INT 4
70119: PUSH
70120: LD_INT 5
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: ST_TO_ADDR
70129: GO 70920
70131: LD_INT 7
70133: DOUBLE
70134: EQUAL
70135: IFTRUE 70139
70137: GO 70165
70139: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70140: LD_ADDR_VAR 0 3
70144: PUSH
70145: LD_INT 2
70147: PUSH
70148: LD_INT 3
70150: PUSH
70151: LD_INT 4
70153: PUSH
70154: LD_INT 5
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: ST_TO_ADDR
70163: GO 70920
70165: LD_INT 12
70167: DOUBLE
70168: EQUAL
70169: IFTRUE 70173
70171: GO 70199
70173: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70174: LD_ADDR_VAR 0 3
70178: PUSH
70179: LD_INT 2
70181: PUSH
70182: LD_INT 3
70184: PUSH
70185: LD_INT 4
70187: PUSH
70188: LD_INT 5
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: ST_TO_ADDR
70197: GO 70920
70199: LD_INT 13
70201: DOUBLE
70202: EQUAL
70203: IFTRUE 70207
70205: GO 70233
70207: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70208: LD_ADDR_VAR 0 3
70212: PUSH
70213: LD_INT 2
70215: PUSH
70216: LD_INT 3
70218: PUSH
70219: LD_INT 4
70221: PUSH
70222: LD_INT 5
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: ST_TO_ADDR
70231: GO 70920
70233: LD_INT 14
70235: DOUBLE
70236: EQUAL
70237: IFTRUE 70241
70239: GO 70259
70241: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70242: LD_ADDR_VAR 0 3
70246: PUSH
70247: LD_INT 4
70249: PUSH
70250: LD_INT 5
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: ST_TO_ADDR
70257: GO 70920
70259: LD_INT 6
70261: DOUBLE
70262: EQUAL
70263: IFTRUE 70267
70265: GO 70285
70267: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70268: LD_ADDR_VAR 0 3
70272: PUSH
70273: LD_INT 4
70275: PUSH
70276: LD_INT 5
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: ST_TO_ADDR
70283: GO 70920
70285: LD_INT 10
70287: DOUBLE
70288: EQUAL
70289: IFTRUE 70293
70291: GO 70311
70293: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70294: LD_ADDR_VAR 0 3
70298: PUSH
70299: LD_INT 4
70301: PUSH
70302: LD_INT 5
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: ST_TO_ADDR
70309: GO 70920
70311: LD_INT 22
70313: DOUBLE
70314: EQUAL
70315: IFTRUE 70319
70317: GO 70345
70319: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70320: LD_ADDR_VAR 0 3
70324: PUSH
70325: LD_INT 11
70327: PUSH
70328: LD_INT 12
70330: PUSH
70331: LD_INT 13
70333: PUSH
70334: LD_INT 14
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: ST_TO_ADDR
70343: GO 70920
70345: LD_INT 23
70347: DOUBLE
70348: EQUAL
70349: IFTRUE 70353
70351: GO 70379
70353: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70354: LD_ADDR_VAR 0 3
70358: PUSH
70359: LD_INT 11
70361: PUSH
70362: LD_INT 12
70364: PUSH
70365: LD_INT 13
70367: PUSH
70368: LD_INT 14
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: ST_TO_ADDR
70377: GO 70920
70379: LD_INT 24
70381: DOUBLE
70382: EQUAL
70383: IFTRUE 70387
70385: GO 70413
70387: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70388: LD_ADDR_VAR 0 3
70392: PUSH
70393: LD_INT 11
70395: PUSH
70396: LD_INT 12
70398: PUSH
70399: LD_INT 13
70401: PUSH
70402: LD_INT 14
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: ST_TO_ADDR
70411: GO 70920
70413: LD_INT 30
70415: DOUBLE
70416: EQUAL
70417: IFTRUE 70421
70419: GO 70447
70421: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70422: LD_ADDR_VAR 0 3
70426: PUSH
70427: LD_INT 11
70429: PUSH
70430: LD_INT 12
70432: PUSH
70433: LD_INT 13
70435: PUSH
70436: LD_INT 14
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: ST_TO_ADDR
70445: GO 70920
70447: LD_INT 25
70449: DOUBLE
70450: EQUAL
70451: IFTRUE 70455
70453: GO 70473
70455: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70456: LD_ADDR_VAR 0 3
70460: PUSH
70461: LD_INT 13
70463: PUSH
70464: LD_INT 14
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: ST_TO_ADDR
70471: GO 70920
70473: LD_INT 27
70475: DOUBLE
70476: EQUAL
70477: IFTRUE 70481
70479: GO 70499
70481: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70482: LD_ADDR_VAR 0 3
70486: PUSH
70487: LD_INT 13
70489: PUSH
70490: LD_INT 14
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: ST_TO_ADDR
70497: GO 70920
70499: LD_INT 28
70501: DOUBLE
70502: EQUAL
70503: IFTRUE 70507
70505: GO 70525
70507: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70508: LD_ADDR_VAR 0 3
70512: PUSH
70513: LD_INT 13
70515: PUSH
70516: LD_INT 14
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: ST_TO_ADDR
70523: GO 70920
70525: LD_INT 29
70527: DOUBLE
70528: EQUAL
70529: IFTRUE 70533
70531: GO 70551
70533: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70534: LD_ADDR_VAR 0 3
70538: PUSH
70539: LD_INT 13
70541: PUSH
70542: LD_INT 14
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: ST_TO_ADDR
70549: GO 70920
70551: LD_INT 31
70553: DOUBLE
70554: EQUAL
70555: IFTRUE 70559
70557: GO 70577
70559: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70560: LD_ADDR_VAR 0 3
70564: PUSH
70565: LD_INT 13
70567: PUSH
70568: LD_INT 14
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: ST_TO_ADDR
70575: GO 70920
70577: LD_INT 26
70579: DOUBLE
70580: EQUAL
70581: IFTRUE 70585
70583: GO 70603
70585: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70586: LD_ADDR_VAR 0 3
70590: PUSH
70591: LD_INT 13
70593: PUSH
70594: LD_INT 14
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: ST_TO_ADDR
70601: GO 70920
70603: LD_INT 42
70605: DOUBLE
70606: EQUAL
70607: IFTRUE 70611
70609: GO 70637
70611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70612: LD_ADDR_VAR 0 3
70616: PUSH
70617: LD_INT 21
70619: PUSH
70620: LD_INT 22
70622: PUSH
70623: LD_INT 23
70625: PUSH
70626: LD_INT 24
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: ST_TO_ADDR
70635: GO 70920
70637: LD_INT 43
70639: DOUBLE
70640: EQUAL
70641: IFTRUE 70645
70643: GO 70671
70645: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70646: LD_ADDR_VAR 0 3
70650: PUSH
70651: LD_INT 21
70653: PUSH
70654: LD_INT 22
70656: PUSH
70657: LD_INT 23
70659: PUSH
70660: LD_INT 24
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: ST_TO_ADDR
70669: GO 70920
70671: LD_INT 44
70673: DOUBLE
70674: EQUAL
70675: IFTRUE 70679
70677: GO 70705
70679: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70680: LD_ADDR_VAR 0 3
70684: PUSH
70685: LD_INT 21
70687: PUSH
70688: LD_INT 22
70690: PUSH
70691: LD_INT 23
70693: PUSH
70694: LD_INT 24
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: ST_TO_ADDR
70703: GO 70920
70705: LD_INT 45
70707: DOUBLE
70708: EQUAL
70709: IFTRUE 70713
70711: GO 70739
70713: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70714: LD_ADDR_VAR 0 3
70718: PUSH
70719: LD_INT 21
70721: PUSH
70722: LD_INT 22
70724: PUSH
70725: LD_INT 23
70727: PUSH
70728: LD_INT 24
70730: PUSH
70731: EMPTY
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: ST_TO_ADDR
70737: GO 70920
70739: LD_INT 49
70741: DOUBLE
70742: EQUAL
70743: IFTRUE 70747
70745: GO 70773
70747: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70748: LD_ADDR_VAR 0 3
70752: PUSH
70753: LD_INT 21
70755: PUSH
70756: LD_INT 22
70758: PUSH
70759: LD_INT 23
70761: PUSH
70762: LD_INT 24
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: ST_TO_ADDR
70771: GO 70920
70773: LD_INT 51
70775: DOUBLE
70776: EQUAL
70777: IFTRUE 70781
70779: GO 70807
70781: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70782: LD_ADDR_VAR 0 3
70786: PUSH
70787: LD_INT 21
70789: PUSH
70790: LD_INT 22
70792: PUSH
70793: LD_INT 23
70795: PUSH
70796: LD_INT 24
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: ST_TO_ADDR
70805: GO 70920
70807: LD_INT 52
70809: DOUBLE
70810: EQUAL
70811: IFTRUE 70815
70813: GO 70841
70815: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70816: LD_ADDR_VAR 0 3
70820: PUSH
70821: LD_INT 21
70823: PUSH
70824: LD_INT 22
70826: PUSH
70827: LD_INT 23
70829: PUSH
70830: LD_INT 24
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: LIST
70837: LIST
70838: ST_TO_ADDR
70839: GO 70920
70841: LD_INT 53
70843: DOUBLE
70844: EQUAL
70845: IFTRUE 70849
70847: GO 70867
70849: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70850: LD_ADDR_VAR 0 3
70854: PUSH
70855: LD_INT 23
70857: PUSH
70858: LD_INT 24
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: ST_TO_ADDR
70865: GO 70920
70867: LD_INT 46
70869: DOUBLE
70870: EQUAL
70871: IFTRUE 70875
70873: GO 70893
70875: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70876: LD_ADDR_VAR 0 3
70880: PUSH
70881: LD_INT 23
70883: PUSH
70884: LD_INT 24
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: ST_TO_ADDR
70891: GO 70920
70893: LD_INT 47
70895: DOUBLE
70896: EQUAL
70897: IFTRUE 70901
70899: GO 70919
70901: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70902: LD_ADDR_VAR 0 3
70906: PUSH
70907: LD_INT 23
70909: PUSH
70910: LD_INT 24
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: ST_TO_ADDR
70917: GO 70920
70919: POP
// result := ( chassis in result ) ;
70920: LD_ADDR_VAR 0 3
70924: PUSH
70925: LD_VAR 0 1
70929: PUSH
70930: LD_VAR 0 3
70934: IN
70935: ST_TO_ADDR
// end ;
70936: LD_VAR 0 3
70940: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70941: LD_INT 0
70943: PPUSH
70944: PPUSH
70945: PPUSH
70946: PPUSH
70947: PPUSH
70948: PPUSH
70949: PPUSH
// result := array ;
70950: LD_ADDR_VAR 0 5
70954: PUSH
70955: LD_VAR 0 1
70959: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70960: LD_VAR 0 1
70964: NOT
70965: PUSH
70966: LD_VAR 0 2
70970: NOT
70971: OR
70972: PUSH
70973: LD_VAR 0 3
70977: NOT
70978: OR
70979: PUSH
70980: LD_VAR 0 2
70984: PUSH
70985: LD_VAR 0 1
70989: GREATER
70990: OR
70991: PUSH
70992: LD_VAR 0 3
70996: PUSH
70997: LD_VAR 0 1
71001: GREATER
71002: OR
71003: IFFALSE 71007
// exit ;
71005: GO 71303
// if direction then
71007: LD_VAR 0 4
71011: IFFALSE 71075
// begin d := 1 ;
71013: LD_ADDR_VAR 0 9
71017: PUSH
71018: LD_INT 1
71020: ST_TO_ADDR
// if i_from > i_to then
71021: LD_VAR 0 2
71025: PUSH
71026: LD_VAR 0 3
71030: GREATER
71031: IFFALSE 71057
// length := ( array - i_from ) + i_to else
71033: LD_ADDR_VAR 0 11
71037: PUSH
71038: LD_VAR 0 1
71042: PUSH
71043: LD_VAR 0 2
71047: MINUS
71048: PUSH
71049: LD_VAR 0 3
71053: PLUS
71054: ST_TO_ADDR
71055: GO 71073
// length := i_to - i_from ;
71057: LD_ADDR_VAR 0 11
71061: PUSH
71062: LD_VAR 0 3
71066: PUSH
71067: LD_VAR 0 2
71071: MINUS
71072: ST_TO_ADDR
// end else
71073: GO 71136
// begin d := - 1 ;
71075: LD_ADDR_VAR 0 9
71079: PUSH
71080: LD_INT 1
71082: NEG
71083: ST_TO_ADDR
// if i_from > i_to then
71084: LD_VAR 0 2
71088: PUSH
71089: LD_VAR 0 3
71093: GREATER
71094: IFFALSE 71114
// length := i_from - i_to else
71096: LD_ADDR_VAR 0 11
71100: PUSH
71101: LD_VAR 0 2
71105: PUSH
71106: LD_VAR 0 3
71110: MINUS
71111: ST_TO_ADDR
71112: GO 71136
// length := ( array - i_to ) + i_from ;
71114: LD_ADDR_VAR 0 11
71118: PUSH
71119: LD_VAR 0 1
71123: PUSH
71124: LD_VAR 0 3
71128: MINUS
71129: PUSH
71130: LD_VAR 0 2
71134: PLUS
71135: ST_TO_ADDR
// end ; if not length then
71136: LD_VAR 0 11
71140: NOT
71141: IFFALSE 71145
// exit ;
71143: GO 71303
// tmp := array ;
71145: LD_ADDR_VAR 0 10
71149: PUSH
71150: LD_VAR 0 1
71154: ST_TO_ADDR
// for i = 1 to length do
71155: LD_ADDR_VAR 0 6
71159: PUSH
71160: DOUBLE
71161: LD_INT 1
71163: DEC
71164: ST_TO_ADDR
71165: LD_VAR 0 11
71169: PUSH
71170: FOR_TO
71171: IFFALSE 71291
// begin for j = 1 to array do
71173: LD_ADDR_VAR 0 7
71177: PUSH
71178: DOUBLE
71179: LD_INT 1
71181: DEC
71182: ST_TO_ADDR
71183: LD_VAR 0 1
71187: PUSH
71188: FOR_TO
71189: IFFALSE 71277
// begin k := j + d ;
71191: LD_ADDR_VAR 0 8
71195: PUSH
71196: LD_VAR 0 7
71200: PUSH
71201: LD_VAR 0 9
71205: PLUS
71206: ST_TO_ADDR
// if k > array then
71207: LD_VAR 0 8
71211: PUSH
71212: LD_VAR 0 1
71216: GREATER
71217: IFFALSE 71227
// k := 1 ;
71219: LD_ADDR_VAR 0 8
71223: PUSH
71224: LD_INT 1
71226: ST_TO_ADDR
// if not k then
71227: LD_VAR 0 8
71231: NOT
71232: IFFALSE 71244
// k := array ;
71234: LD_ADDR_VAR 0 8
71238: PUSH
71239: LD_VAR 0 1
71243: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71244: LD_ADDR_VAR 0 10
71248: PUSH
71249: LD_VAR 0 10
71253: PPUSH
71254: LD_VAR 0 8
71258: PPUSH
71259: LD_VAR 0 1
71263: PUSH
71264: LD_VAR 0 7
71268: ARRAY
71269: PPUSH
71270: CALL_OW 1
71274: ST_TO_ADDR
// end ;
71275: GO 71188
71277: POP
71278: POP
// array := tmp ;
71279: LD_ADDR_VAR 0 1
71283: PUSH
71284: LD_VAR 0 10
71288: ST_TO_ADDR
// end ;
71289: GO 71170
71291: POP
71292: POP
// result := array ;
71293: LD_ADDR_VAR 0 5
71297: PUSH
71298: LD_VAR 0 1
71302: ST_TO_ADDR
// end ;
71303: LD_VAR 0 5
71307: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71308: LD_INT 0
71310: PPUSH
71311: PPUSH
// result := 0 ;
71312: LD_ADDR_VAR 0 3
71316: PUSH
71317: LD_INT 0
71319: ST_TO_ADDR
// if not array or not value in array then
71320: LD_VAR 0 1
71324: NOT
71325: PUSH
71326: LD_VAR 0 2
71330: PUSH
71331: LD_VAR 0 1
71335: IN
71336: NOT
71337: OR
71338: IFFALSE 71342
// exit ;
71340: GO 71396
// for i = 1 to array do
71342: LD_ADDR_VAR 0 4
71346: PUSH
71347: DOUBLE
71348: LD_INT 1
71350: DEC
71351: ST_TO_ADDR
71352: LD_VAR 0 1
71356: PUSH
71357: FOR_TO
71358: IFFALSE 71394
// if value = array [ i ] then
71360: LD_VAR 0 2
71364: PUSH
71365: LD_VAR 0 1
71369: PUSH
71370: LD_VAR 0 4
71374: ARRAY
71375: EQUAL
71376: IFFALSE 71392
// begin result := i ;
71378: LD_ADDR_VAR 0 3
71382: PUSH
71383: LD_VAR 0 4
71387: ST_TO_ADDR
// exit ;
71388: POP
71389: POP
71390: GO 71396
// end ;
71392: GO 71357
71394: POP
71395: POP
// end ;
71396: LD_VAR 0 3
71400: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71401: LD_INT 0
71403: PPUSH
// vc_chassis := chassis ;
71404: LD_ADDR_OWVAR 37
71408: PUSH
71409: LD_VAR 0 1
71413: ST_TO_ADDR
// vc_engine := engine ;
71414: LD_ADDR_OWVAR 39
71418: PUSH
71419: LD_VAR 0 2
71423: ST_TO_ADDR
// vc_control := control ;
71424: LD_ADDR_OWVAR 38
71428: PUSH
71429: LD_VAR 0 3
71433: ST_TO_ADDR
// vc_weapon := weapon ;
71434: LD_ADDR_OWVAR 40
71438: PUSH
71439: LD_VAR 0 4
71443: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71444: LD_ADDR_OWVAR 41
71448: PUSH
71449: LD_VAR 0 5
71453: ST_TO_ADDR
// end ;
71454: LD_VAR 0 6
71458: RET
// export function WantPlant ( unit ) ; var task ; begin
71459: LD_INT 0
71461: PPUSH
71462: PPUSH
// result := false ;
71463: LD_ADDR_VAR 0 2
71467: PUSH
71468: LD_INT 0
71470: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71471: LD_ADDR_VAR 0 3
71475: PUSH
71476: LD_VAR 0 1
71480: PPUSH
71481: CALL_OW 437
71485: ST_TO_ADDR
// if task then
71486: LD_VAR 0 3
71490: IFFALSE 71518
// if task [ 1 ] [ 1 ] = p then
71492: LD_VAR 0 3
71496: PUSH
71497: LD_INT 1
71499: ARRAY
71500: PUSH
71501: LD_INT 1
71503: ARRAY
71504: PUSH
71505: LD_STRING p
71507: EQUAL
71508: IFFALSE 71518
// result := true ;
71510: LD_ADDR_VAR 0 2
71514: PUSH
71515: LD_INT 1
71517: ST_TO_ADDR
// end ;
71518: LD_VAR 0 2
71522: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71523: LD_INT 0
71525: PPUSH
71526: PPUSH
71527: PPUSH
71528: PPUSH
// if pos < 1 then
71529: LD_VAR 0 2
71533: PUSH
71534: LD_INT 1
71536: LESS
71537: IFFALSE 71541
// exit ;
71539: GO 71844
// if pos = 1 then
71541: LD_VAR 0 2
71545: PUSH
71546: LD_INT 1
71548: EQUAL
71549: IFFALSE 71582
// result := Replace ( arr , pos [ 1 ] , value ) else
71551: LD_ADDR_VAR 0 4
71555: PUSH
71556: LD_VAR 0 1
71560: PPUSH
71561: LD_VAR 0 2
71565: PUSH
71566: LD_INT 1
71568: ARRAY
71569: PPUSH
71570: LD_VAR 0 3
71574: PPUSH
71575: CALL_OW 1
71579: ST_TO_ADDR
71580: GO 71844
// begin tmp := arr ;
71582: LD_ADDR_VAR 0 6
71586: PUSH
71587: LD_VAR 0 1
71591: ST_TO_ADDR
// s_arr := [ tmp ] ;
71592: LD_ADDR_VAR 0 7
71596: PUSH
71597: LD_VAR 0 6
71601: PUSH
71602: EMPTY
71603: LIST
71604: ST_TO_ADDR
// for i = 1 to pos - 1 do
71605: LD_ADDR_VAR 0 5
71609: PUSH
71610: DOUBLE
71611: LD_INT 1
71613: DEC
71614: ST_TO_ADDR
71615: LD_VAR 0 2
71619: PUSH
71620: LD_INT 1
71622: MINUS
71623: PUSH
71624: FOR_TO
71625: IFFALSE 71670
// begin tmp := tmp [ pos [ i ] ] ;
71627: LD_ADDR_VAR 0 6
71631: PUSH
71632: LD_VAR 0 6
71636: PUSH
71637: LD_VAR 0 2
71641: PUSH
71642: LD_VAR 0 5
71646: ARRAY
71647: ARRAY
71648: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71649: LD_ADDR_VAR 0 7
71653: PUSH
71654: LD_VAR 0 7
71658: PUSH
71659: LD_VAR 0 6
71663: PUSH
71664: EMPTY
71665: LIST
71666: ADD
71667: ST_TO_ADDR
// end ;
71668: GO 71624
71670: POP
71671: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71672: LD_ADDR_VAR 0 6
71676: PUSH
71677: LD_VAR 0 6
71681: PPUSH
71682: LD_VAR 0 2
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: PPUSH
71693: LD_VAR 0 3
71697: PPUSH
71698: CALL_OW 1
71702: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71703: LD_ADDR_VAR 0 7
71707: PUSH
71708: LD_VAR 0 7
71712: PPUSH
71713: LD_VAR 0 7
71717: PPUSH
71718: LD_VAR 0 6
71722: PPUSH
71723: CALL_OW 1
71727: ST_TO_ADDR
// for i = s_arr downto 2 do
71728: LD_ADDR_VAR 0 5
71732: PUSH
71733: DOUBLE
71734: LD_VAR 0 7
71738: INC
71739: ST_TO_ADDR
71740: LD_INT 2
71742: PUSH
71743: FOR_DOWNTO
71744: IFFALSE 71828
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71746: LD_ADDR_VAR 0 6
71750: PUSH
71751: LD_VAR 0 7
71755: PUSH
71756: LD_VAR 0 5
71760: PUSH
71761: LD_INT 1
71763: MINUS
71764: ARRAY
71765: PPUSH
71766: LD_VAR 0 2
71770: PUSH
71771: LD_VAR 0 5
71775: PUSH
71776: LD_INT 1
71778: MINUS
71779: ARRAY
71780: PPUSH
71781: LD_VAR 0 7
71785: PUSH
71786: LD_VAR 0 5
71790: ARRAY
71791: PPUSH
71792: CALL_OW 1
71796: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71797: LD_ADDR_VAR 0 7
71801: PUSH
71802: LD_VAR 0 7
71806: PPUSH
71807: LD_VAR 0 5
71811: PUSH
71812: LD_INT 1
71814: MINUS
71815: PPUSH
71816: LD_VAR 0 6
71820: PPUSH
71821: CALL_OW 1
71825: ST_TO_ADDR
// end ;
71826: GO 71743
71828: POP
71829: POP
// result := s_arr [ 1 ] ;
71830: LD_ADDR_VAR 0 4
71834: PUSH
71835: LD_VAR 0 7
71839: PUSH
71840: LD_INT 1
71842: ARRAY
71843: ST_TO_ADDR
// end ; end ;
71844: LD_VAR 0 4
71848: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71849: LD_INT 0
71851: PPUSH
71852: PPUSH
// if not list then
71853: LD_VAR 0 1
71857: NOT
71858: IFFALSE 71862
// exit ;
71860: GO 71953
// i := list [ pos1 ] ;
71862: LD_ADDR_VAR 0 5
71866: PUSH
71867: LD_VAR 0 1
71871: PUSH
71872: LD_VAR 0 2
71876: ARRAY
71877: ST_TO_ADDR
// if not i then
71878: LD_VAR 0 5
71882: NOT
71883: IFFALSE 71887
// exit ;
71885: GO 71953
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71887: LD_ADDR_VAR 0 1
71891: PUSH
71892: LD_VAR 0 1
71896: PPUSH
71897: LD_VAR 0 2
71901: PPUSH
71902: LD_VAR 0 1
71906: PUSH
71907: LD_VAR 0 3
71911: ARRAY
71912: PPUSH
71913: CALL_OW 1
71917: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71918: LD_ADDR_VAR 0 1
71922: PUSH
71923: LD_VAR 0 1
71927: PPUSH
71928: LD_VAR 0 3
71932: PPUSH
71933: LD_VAR 0 5
71937: PPUSH
71938: CALL_OW 1
71942: ST_TO_ADDR
// result := list ;
71943: LD_ADDR_VAR 0 4
71947: PUSH
71948: LD_VAR 0 1
71952: ST_TO_ADDR
// end ;
71953: LD_VAR 0 4
71957: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71958: LD_INT 0
71960: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71961: LD_ADDR_VAR 0 5
71965: PUSH
71966: LD_VAR 0 1
71970: PPUSH
71971: CALL_OW 250
71975: PPUSH
71976: LD_VAR 0 1
71980: PPUSH
71981: CALL_OW 251
71985: PPUSH
71986: LD_VAR 0 2
71990: PPUSH
71991: LD_VAR 0 3
71995: PPUSH
71996: LD_VAR 0 4
72000: PPUSH
72001: CALL 72011 0 5
72005: ST_TO_ADDR
// end ;
72006: LD_VAR 0 5
72010: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72011: LD_INT 0
72013: PPUSH
72014: PPUSH
72015: PPUSH
72016: PPUSH
// if not list then
72017: LD_VAR 0 3
72021: NOT
72022: IFFALSE 72026
// exit ;
72024: GO 72414
// result := [ ] ;
72026: LD_ADDR_VAR 0 6
72030: PUSH
72031: EMPTY
72032: ST_TO_ADDR
// for i in list do
72033: LD_ADDR_VAR 0 7
72037: PUSH
72038: LD_VAR 0 3
72042: PUSH
72043: FOR_IN
72044: IFFALSE 72246
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72046: LD_ADDR_VAR 0 9
72050: PUSH
72051: LD_VAR 0 7
72055: PPUSH
72056: LD_VAR 0 1
72060: PPUSH
72061: LD_VAR 0 2
72065: PPUSH
72066: CALL_OW 297
72070: ST_TO_ADDR
// if not result then
72071: LD_VAR 0 6
72075: NOT
72076: IFFALSE 72102
// result := [ [ i , tmp ] ] else
72078: LD_ADDR_VAR 0 6
72082: PUSH
72083: LD_VAR 0 7
72087: PUSH
72088: LD_VAR 0 9
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: EMPTY
72098: LIST
72099: ST_TO_ADDR
72100: GO 72244
// begin if result [ result ] [ 2 ] < tmp then
72102: LD_VAR 0 6
72106: PUSH
72107: LD_VAR 0 6
72111: ARRAY
72112: PUSH
72113: LD_INT 2
72115: ARRAY
72116: PUSH
72117: LD_VAR 0 9
72121: LESS
72122: IFFALSE 72164
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72124: LD_ADDR_VAR 0 6
72128: PUSH
72129: LD_VAR 0 6
72133: PPUSH
72134: LD_VAR 0 6
72138: PUSH
72139: LD_INT 1
72141: PLUS
72142: PPUSH
72143: LD_VAR 0 7
72147: PUSH
72148: LD_VAR 0 9
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PPUSH
72157: CALL_OW 2
72161: ST_TO_ADDR
72162: GO 72244
// for j = 1 to result do
72164: LD_ADDR_VAR 0 8
72168: PUSH
72169: DOUBLE
72170: LD_INT 1
72172: DEC
72173: ST_TO_ADDR
72174: LD_VAR 0 6
72178: PUSH
72179: FOR_TO
72180: IFFALSE 72242
// begin if tmp < result [ j ] [ 2 ] then
72182: LD_VAR 0 9
72186: PUSH
72187: LD_VAR 0 6
72191: PUSH
72192: LD_VAR 0 8
72196: ARRAY
72197: PUSH
72198: LD_INT 2
72200: ARRAY
72201: LESS
72202: IFFALSE 72240
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72204: LD_ADDR_VAR 0 6
72208: PUSH
72209: LD_VAR 0 6
72213: PPUSH
72214: LD_VAR 0 8
72218: PPUSH
72219: LD_VAR 0 7
72223: PUSH
72224: LD_VAR 0 9
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PPUSH
72233: CALL_OW 2
72237: ST_TO_ADDR
// break ;
72238: GO 72242
// end ; end ;
72240: GO 72179
72242: POP
72243: POP
// end ; end ;
72244: GO 72043
72246: POP
72247: POP
// if result and not asc then
72248: LD_VAR 0 6
72252: PUSH
72253: LD_VAR 0 4
72257: NOT
72258: AND
72259: IFFALSE 72334
// begin tmp := result ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_VAR 0 6
72270: ST_TO_ADDR
// for i = tmp downto 1 do
72271: LD_ADDR_VAR 0 7
72275: PUSH
72276: DOUBLE
72277: LD_VAR 0 9
72281: INC
72282: ST_TO_ADDR
72283: LD_INT 1
72285: PUSH
72286: FOR_DOWNTO
72287: IFFALSE 72332
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72289: LD_ADDR_VAR 0 6
72293: PUSH
72294: LD_VAR 0 6
72298: PPUSH
72299: LD_VAR 0 9
72303: PUSH
72304: LD_VAR 0 7
72308: MINUS
72309: PUSH
72310: LD_INT 1
72312: PLUS
72313: PPUSH
72314: LD_VAR 0 9
72318: PUSH
72319: LD_VAR 0 7
72323: ARRAY
72324: PPUSH
72325: CALL_OW 1
72329: ST_TO_ADDR
72330: GO 72286
72332: POP
72333: POP
// end ; tmp := [ ] ;
72334: LD_ADDR_VAR 0 9
72338: PUSH
72339: EMPTY
72340: ST_TO_ADDR
// if mode then
72341: LD_VAR 0 5
72345: IFFALSE 72414
// begin for i = 1 to result do
72347: LD_ADDR_VAR 0 7
72351: PUSH
72352: DOUBLE
72353: LD_INT 1
72355: DEC
72356: ST_TO_ADDR
72357: LD_VAR 0 6
72361: PUSH
72362: FOR_TO
72363: IFFALSE 72402
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72365: LD_ADDR_VAR 0 9
72369: PUSH
72370: LD_VAR 0 9
72374: PPUSH
72375: LD_VAR 0 7
72379: PPUSH
72380: LD_VAR 0 6
72384: PUSH
72385: LD_VAR 0 7
72389: ARRAY
72390: PUSH
72391: LD_INT 1
72393: ARRAY
72394: PPUSH
72395: CALL_OW 1
72399: ST_TO_ADDR
72400: GO 72362
72402: POP
72403: POP
// result := tmp ;
72404: LD_ADDR_VAR 0 6
72408: PUSH
72409: LD_VAR 0 9
72413: ST_TO_ADDR
// end ; end ;
72414: LD_VAR 0 6
72418: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72419: LD_INT 0
72421: PPUSH
72422: PPUSH
72423: PPUSH
72424: PPUSH
72425: PPUSH
72426: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72427: LD_ADDR_VAR 0 5
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: LD_INT 0
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: EMPTY
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: ST_TO_ADDR
// if not x or not y then
72449: LD_VAR 0 2
72453: NOT
72454: PUSH
72455: LD_VAR 0 3
72459: NOT
72460: OR
72461: IFFALSE 72465
// exit ;
72463: GO 74111
// if not range then
72465: LD_VAR 0 4
72469: NOT
72470: IFFALSE 72480
// range := 10 ;
72472: LD_ADDR_VAR 0 4
72476: PUSH
72477: LD_INT 10
72479: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72480: LD_ADDR_VAR 0 8
72484: PUSH
72485: LD_INT 81
72487: PUSH
72488: LD_VAR 0 1
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 92
72499: PUSH
72500: LD_VAR 0 2
72504: PUSH
72505: LD_VAR 0 3
72509: PUSH
72510: LD_VAR 0 4
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 3
72523: PUSH
72524: LD_INT 21
72526: PUSH
72527: LD_INT 3
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: LIST
72542: PPUSH
72543: CALL_OW 69
72547: ST_TO_ADDR
// if not tmp then
72548: LD_VAR 0 8
72552: NOT
72553: IFFALSE 72557
// exit ;
72555: GO 74111
// for i in tmp do
72557: LD_ADDR_VAR 0 6
72561: PUSH
72562: LD_VAR 0 8
72566: PUSH
72567: FOR_IN
72568: IFFALSE 74086
// begin points := [ 0 , 0 , 0 ] ;
72570: LD_ADDR_VAR 0 9
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: LIST
72588: ST_TO_ADDR
// bpoints := 1 ;
72589: LD_ADDR_VAR 0 10
72593: PUSH
72594: LD_INT 1
72596: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72597: LD_VAR 0 6
72601: PPUSH
72602: CALL_OW 247
72606: PUSH
72607: LD_INT 1
72609: DOUBLE
72610: EQUAL
72611: IFTRUE 72615
72613: GO 73193
72615: POP
// begin if GetClass ( i ) = 1 then
72616: LD_VAR 0 6
72620: PPUSH
72621: CALL_OW 257
72625: PUSH
72626: LD_INT 1
72628: EQUAL
72629: IFFALSE 72650
// points := [ 10 , 5 , 3 ] ;
72631: LD_ADDR_VAR 0 9
72635: PUSH
72636: LD_INT 10
72638: PUSH
72639: LD_INT 5
72641: PUSH
72642: LD_INT 3
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: LIST
72649: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72650: LD_VAR 0 6
72654: PPUSH
72655: CALL_OW 257
72659: PUSH
72660: LD_INT 2
72662: PUSH
72663: LD_INT 3
72665: PUSH
72666: LD_INT 4
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: LIST
72673: IN
72674: IFFALSE 72695
// points := [ 3 , 2 , 1 ] ;
72676: LD_ADDR_VAR 0 9
72680: PUSH
72681: LD_INT 3
72683: PUSH
72684: LD_INT 2
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: LIST
72694: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72695: LD_VAR 0 6
72699: PPUSH
72700: CALL_OW 257
72704: PUSH
72705: LD_INT 5
72707: EQUAL
72708: IFFALSE 72729
// points := [ 130 , 5 , 2 ] ;
72710: LD_ADDR_VAR 0 9
72714: PUSH
72715: LD_INT 130
72717: PUSH
72718: LD_INT 5
72720: PUSH
72721: LD_INT 2
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: LIST
72728: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72729: LD_VAR 0 6
72733: PPUSH
72734: CALL_OW 257
72738: PUSH
72739: LD_INT 8
72741: EQUAL
72742: IFFALSE 72763
// points := [ 35 , 35 , 30 ] ;
72744: LD_ADDR_VAR 0 9
72748: PUSH
72749: LD_INT 35
72751: PUSH
72752: LD_INT 35
72754: PUSH
72755: LD_INT 30
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: LIST
72762: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72763: LD_VAR 0 6
72767: PPUSH
72768: CALL_OW 257
72772: PUSH
72773: LD_INT 9
72775: EQUAL
72776: IFFALSE 72797
// points := [ 20 , 55 , 40 ] ;
72778: LD_ADDR_VAR 0 9
72782: PUSH
72783: LD_INT 20
72785: PUSH
72786: LD_INT 55
72788: PUSH
72789: LD_INT 40
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: LIST
72796: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72797: LD_VAR 0 6
72801: PPUSH
72802: CALL_OW 257
72806: PUSH
72807: LD_INT 12
72809: PUSH
72810: LD_INT 16
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: IN
72817: IFFALSE 72838
// points := [ 5 , 3 , 2 ] ;
72819: LD_ADDR_VAR 0 9
72823: PUSH
72824: LD_INT 5
72826: PUSH
72827: LD_INT 3
72829: PUSH
72830: LD_INT 2
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: LIST
72837: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72838: LD_VAR 0 6
72842: PPUSH
72843: CALL_OW 257
72847: PUSH
72848: LD_INT 17
72850: EQUAL
72851: IFFALSE 72872
// points := [ 100 , 50 , 75 ] ;
72853: LD_ADDR_VAR 0 9
72857: PUSH
72858: LD_INT 100
72860: PUSH
72861: LD_INT 50
72863: PUSH
72864: LD_INT 75
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: LIST
72871: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72872: LD_VAR 0 6
72876: PPUSH
72877: CALL_OW 257
72881: PUSH
72882: LD_INT 15
72884: EQUAL
72885: IFFALSE 72906
// points := [ 10 , 5 , 3 ] ;
72887: LD_ADDR_VAR 0 9
72891: PUSH
72892: LD_INT 10
72894: PUSH
72895: LD_INT 5
72897: PUSH
72898: LD_INT 3
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: LIST
72905: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72906: LD_VAR 0 6
72910: PPUSH
72911: CALL_OW 257
72915: PUSH
72916: LD_INT 14
72918: EQUAL
72919: IFFALSE 72940
// points := [ 10 , 0 , 0 ] ;
72921: LD_ADDR_VAR 0 9
72925: PUSH
72926: LD_INT 10
72928: PUSH
72929: LD_INT 0
72931: PUSH
72932: LD_INT 0
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: LIST
72939: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72940: LD_VAR 0 6
72944: PPUSH
72945: CALL_OW 257
72949: PUSH
72950: LD_INT 11
72952: EQUAL
72953: IFFALSE 72974
// points := [ 30 , 10 , 5 ] ;
72955: LD_ADDR_VAR 0 9
72959: PUSH
72960: LD_INT 30
72962: PUSH
72963: LD_INT 10
72965: PUSH
72966: LD_INT 5
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: LIST
72973: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72974: LD_VAR 0 1
72978: PPUSH
72979: LD_INT 5
72981: PPUSH
72982: CALL_OW 321
72986: PUSH
72987: LD_INT 2
72989: EQUAL
72990: IFFALSE 73007
// bpoints := bpoints * 1.8 ;
72992: LD_ADDR_VAR 0 10
72996: PUSH
72997: LD_VAR 0 10
73001: PUSH
73002: LD_REAL  1.80000000000000E+0000
73005: MUL
73006: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73007: LD_VAR 0 6
73011: PPUSH
73012: CALL_OW 257
73016: PUSH
73017: LD_INT 1
73019: PUSH
73020: LD_INT 2
73022: PUSH
73023: LD_INT 3
73025: PUSH
73026: LD_INT 4
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: LIST
73033: LIST
73034: IN
73035: PUSH
73036: LD_VAR 0 1
73040: PPUSH
73041: LD_INT 51
73043: PPUSH
73044: CALL_OW 321
73048: PUSH
73049: LD_INT 2
73051: EQUAL
73052: AND
73053: IFFALSE 73070
// bpoints := bpoints * 1.2 ;
73055: LD_ADDR_VAR 0 10
73059: PUSH
73060: LD_VAR 0 10
73064: PUSH
73065: LD_REAL  1.20000000000000E+0000
73068: MUL
73069: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73070: LD_VAR 0 6
73074: PPUSH
73075: CALL_OW 257
73079: PUSH
73080: LD_INT 5
73082: PUSH
73083: LD_INT 7
73085: PUSH
73086: LD_INT 9
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: LIST
73093: IN
73094: PUSH
73095: LD_VAR 0 1
73099: PPUSH
73100: LD_INT 52
73102: PPUSH
73103: CALL_OW 321
73107: PUSH
73108: LD_INT 2
73110: EQUAL
73111: AND
73112: IFFALSE 73129
// bpoints := bpoints * 1.5 ;
73114: LD_ADDR_VAR 0 10
73118: PUSH
73119: LD_VAR 0 10
73123: PUSH
73124: LD_REAL  1.50000000000000E+0000
73127: MUL
73128: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73129: LD_VAR 0 1
73133: PPUSH
73134: LD_INT 66
73136: PPUSH
73137: CALL_OW 321
73141: PUSH
73142: LD_INT 2
73144: EQUAL
73145: IFFALSE 73162
// bpoints := bpoints * 1.1 ;
73147: LD_ADDR_VAR 0 10
73151: PUSH
73152: LD_VAR 0 10
73156: PUSH
73157: LD_REAL  1.10000000000000E+0000
73160: MUL
73161: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73162: LD_ADDR_VAR 0 10
73166: PUSH
73167: LD_VAR 0 10
73171: PUSH
73172: LD_VAR 0 6
73176: PPUSH
73177: LD_INT 1
73179: PPUSH
73180: CALL_OW 259
73184: PUSH
73185: LD_REAL  1.15000000000000E+0000
73188: MUL
73189: MUL
73190: ST_TO_ADDR
// end ; unit_vehicle :
73191: GO 74015
73193: LD_INT 2
73195: DOUBLE
73196: EQUAL
73197: IFTRUE 73201
73199: GO 74003
73201: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73202: LD_VAR 0 6
73206: PPUSH
73207: CALL_OW 264
73211: PUSH
73212: LD_INT 2
73214: PUSH
73215: LD_INT 42
73217: PUSH
73218: LD_INT 24
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: LIST
73225: IN
73226: IFFALSE 73247
// points := [ 25 , 5 , 3 ] ;
73228: LD_ADDR_VAR 0 9
73232: PUSH
73233: LD_INT 25
73235: PUSH
73236: LD_INT 5
73238: PUSH
73239: LD_INT 3
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: LIST
73246: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73247: LD_VAR 0 6
73251: PPUSH
73252: CALL_OW 264
73256: PUSH
73257: LD_INT 4
73259: PUSH
73260: LD_INT 43
73262: PUSH
73263: LD_INT 25
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: LIST
73270: IN
73271: IFFALSE 73292
// points := [ 40 , 15 , 5 ] ;
73273: LD_ADDR_VAR 0 9
73277: PUSH
73278: LD_INT 40
73280: PUSH
73281: LD_INT 15
73283: PUSH
73284: LD_INT 5
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: LIST
73291: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73292: LD_VAR 0 6
73296: PPUSH
73297: CALL_OW 264
73301: PUSH
73302: LD_INT 3
73304: PUSH
73305: LD_INT 23
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: IN
73312: IFFALSE 73333
// points := [ 7 , 25 , 8 ] ;
73314: LD_ADDR_VAR 0 9
73318: PUSH
73319: LD_INT 7
73321: PUSH
73322: LD_INT 25
73324: PUSH
73325: LD_INT 8
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: LIST
73332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73333: LD_VAR 0 6
73337: PPUSH
73338: CALL_OW 264
73342: PUSH
73343: LD_INT 5
73345: PUSH
73346: LD_INT 27
73348: PUSH
73349: LD_INT 44
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: LIST
73356: IN
73357: IFFALSE 73378
// points := [ 14 , 50 , 16 ] ;
73359: LD_ADDR_VAR 0 9
73363: PUSH
73364: LD_INT 14
73366: PUSH
73367: LD_INT 50
73369: PUSH
73370: LD_INT 16
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: LIST
73377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73378: LD_VAR 0 6
73382: PPUSH
73383: CALL_OW 264
73387: PUSH
73388: LD_INT 6
73390: PUSH
73391: LD_INT 46
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: IN
73398: IFFALSE 73419
// points := [ 32 , 120 , 70 ] ;
73400: LD_ADDR_VAR 0 9
73404: PUSH
73405: LD_INT 32
73407: PUSH
73408: LD_INT 120
73410: PUSH
73411: LD_INT 70
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: LIST
73418: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73419: LD_VAR 0 6
73423: PPUSH
73424: CALL_OW 264
73428: PUSH
73429: LD_INT 7
73431: PUSH
73432: LD_INT 28
73434: PUSH
73435: LD_INT 45
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: LIST
73442: IN
73443: IFFALSE 73464
// points := [ 35 , 20 , 45 ] ;
73445: LD_ADDR_VAR 0 9
73449: PUSH
73450: LD_INT 35
73452: PUSH
73453: LD_INT 20
73455: PUSH
73456: LD_INT 45
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73464: LD_VAR 0 6
73468: PPUSH
73469: CALL_OW 264
73473: PUSH
73474: LD_INT 47
73476: PUSH
73477: EMPTY
73478: LIST
73479: IN
73480: IFFALSE 73501
// points := [ 67 , 45 , 75 ] ;
73482: LD_ADDR_VAR 0 9
73486: PUSH
73487: LD_INT 67
73489: PUSH
73490: LD_INT 45
73492: PUSH
73493: LD_INT 75
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: LIST
73500: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73501: LD_VAR 0 6
73505: PPUSH
73506: CALL_OW 264
73510: PUSH
73511: LD_INT 26
73513: PUSH
73514: EMPTY
73515: LIST
73516: IN
73517: IFFALSE 73538
// points := [ 120 , 30 , 80 ] ;
73519: LD_ADDR_VAR 0 9
73523: PUSH
73524: LD_INT 120
73526: PUSH
73527: LD_INT 30
73529: PUSH
73530: LD_INT 80
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73538: LD_VAR 0 6
73542: PPUSH
73543: CALL_OW 264
73547: PUSH
73548: LD_INT 22
73550: PUSH
73551: EMPTY
73552: LIST
73553: IN
73554: IFFALSE 73575
// points := [ 40 , 1 , 1 ] ;
73556: LD_ADDR_VAR 0 9
73560: PUSH
73561: LD_INT 40
73563: PUSH
73564: LD_INT 1
73566: PUSH
73567: LD_INT 1
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: LIST
73574: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73575: LD_VAR 0 6
73579: PPUSH
73580: CALL_OW 264
73584: PUSH
73585: LD_INT 29
73587: PUSH
73588: EMPTY
73589: LIST
73590: IN
73591: IFFALSE 73612
// points := [ 70 , 200 , 400 ] ;
73593: LD_ADDR_VAR 0 9
73597: PUSH
73598: LD_INT 70
73600: PUSH
73601: LD_INT 200
73603: PUSH
73604: LD_INT 400
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: LIST
73611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73612: LD_VAR 0 6
73616: PPUSH
73617: CALL_OW 264
73621: PUSH
73622: LD_INT 14
73624: PUSH
73625: LD_INT 53
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: IN
73632: IFFALSE 73653
// points := [ 40 , 10 , 20 ] ;
73634: LD_ADDR_VAR 0 9
73638: PUSH
73639: LD_INT 40
73641: PUSH
73642: LD_INT 10
73644: PUSH
73645: LD_INT 20
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73653: LD_VAR 0 6
73657: PPUSH
73658: CALL_OW 264
73662: PUSH
73663: LD_INT 9
73665: PUSH
73666: EMPTY
73667: LIST
73668: IN
73669: IFFALSE 73690
// points := [ 5 , 70 , 20 ] ;
73671: LD_ADDR_VAR 0 9
73675: PUSH
73676: LD_INT 5
73678: PUSH
73679: LD_INT 70
73681: PUSH
73682: LD_INT 20
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: LIST
73689: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73690: LD_VAR 0 6
73694: PPUSH
73695: CALL_OW 264
73699: PUSH
73700: LD_INT 10
73702: PUSH
73703: EMPTY
73704: LIST
73705: IN
73706: IFFALSE 73727
// points := [ 35 , 110 , 70 ] ;
73708: LD_ADDR_VAR 0 9
73712: PUSH
73713: LD_INT 35
73715: PUSH
73716: LD_INT 110
73718: PUSH
73719: LD_INT 70
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: LIST
73726: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73727: LD_VAR 0 6
73731: PPUSH
73732: CALL_OW 265
73736: PUSH
73737: LD_INT 25
73739: EQUAL
73740: IFFALSE 73761
// points := [ 80 , 65 , 100 ] ;
73742: LD_ADDR_VAR 0 9
73746: PUSH
73747: LD_INT 80
73749: PUSH
73750: LD_INT 65
73752: PUSH
73753: LD_INT 100
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: LIST
73760: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73761: LD_VAR 0 6
73765: PPUSH
73766: CALL_OW 263
73770: PUSH
73771: LD_INT 1
73773: EQUAL
73774: IFFALSE 73809
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73776: LD_ADDR_VAR 0 10
73780: PUSH
73781: LD_VAR 0 10
73785: PUSH
73786: LD_VAR 0 6
73790: PPUSH
73791: CALL_OW 311
73795: PPUSH
73796: LD_INT 3
73798: PPUSH
73799: CALL_OW 259
73803: PUSH
73804: LD_INT 4
73806: MUL
73807: MUL
73808: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73809: LD_VAR 0 6
73813: PPUSH
73814: CALL_OW 263
73818: PUSH
73819: LD_INT 2
73821: EQUAL
73822: IFFALSE 73873
// begin j := IsControledBy ( i ) ;
73824: LD_ADDR_VAR 0 7
73828: PUSH
73829: LD_VAR 0 6
73833: PPUSH
73834: CALL_OW 312
73838: ST_TO_ADDR
// if j then
73839: LD_VAR 0 7
73843: IFFALSE 73873
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73845: LD_ADDR_VAR 0 10
73849: PUSH
73850: LD_VAR 0 10
73854: PUSH
73855: LD_VAR 0 7
73859: PPUSH
73860: LD_INT 3
73862: PPUSH
73863: CALL_OW 259
73867: PUSH
73868: LD_INT 3
73870: MUL
73871: MUL
73872: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73873: LD_VAR 0 6
73877: PPUSH
73878: CALL_OW 264
73882: PUSH
73883: LD_INT 5
73885: PUSH
73886: LD_INT 6
73888: PUSH
73889: LD_INT 46
73891: PUSH
73892: LD_INT 44
73894: PUSH
73895: LD_INT 47
73897: PUSH
73898: LD_INT 45
73900: PUSH
73901: LD_INT 28
73903: PUSH
73904: LD_INT 7
73906: PUSH
73907: LD_INT 27
73909: PUSH
73910: LD_INT 29
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: IN
73925: PUSH
73926: LD_VAR 0 1
73930: PPUSH
73931: LD_INT 52
73933: PPUSH
73934: CALL_OW 321
73938: PUSH
73939: LD_INT 2
73941: EQUAL
73942: AND
73943: IFFALSE 73960
// bpoints := bpoints * 1.2 ;
73945: LD_ADDR_VAR 0 10
73949: PUSH
73950: LD_VAR 0 10
73954: PUSH
73955: LD_REAL  1.20000000000000E+0000
73958: MUL
73959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73960: LD_VAR 0 6
73964: PPUSH
73965: CALL_OW 264
73969: PUSH
73970: LD_INT 6
73972: PUSH
73973: LD_INT 46
73975: PUSH
73976: LD_INT 47
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: LIST
73983: IN
73984: IFFALSE 74001
// bpoints := bpoints * 1.2 ;
73986: LD_ADDR_VAR 0 10
73990: PUSH
73991: LD_VAR 0 10
73995: PUSH
73996: LD_REAL  1.20000000000000E+0000
73999: MUL
74000: ST_TO_ADDR
// end ; unit_building :
74001: GO 74015
74003: LD_INT 3
74005: DOUBLE
74006: EQUAL
74007: IFTRUE 74011
74009: GO 74014
74011: POP
// ; end ;
74012: GO 74015
74014: POP
// for j = 1 to 3 do
74015: LD_ADDR_VAR 0 7
74019: PUSH
74020: DOUBLE
74021: LD_INT 1
74023: DEC
74024: ST_TO_ADDR
74025: LD_INT 3
74027: PUSH
74028: FOR_TO
74029: IFFALSE 74082
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74031: LD_ADDR_VAR 0 5
74035: PUSH
74036: LD_VAR 0 5
74040: PPUSH
74041: LD_VAR 0 7
74045: PPUSH
74046: LD_VAR 0 5
74050: PUSH
74051: LD_VAR 0 7
74055: ARRAY
74056: PUSH
74057: LD_VAR 0 9
74061: PUSH
74062: LD_VAR 0 7
74066: ARRAY
74067: PUSH
74068: LD_VAR 0 10
74072: MUL
74073: PLUS
74074: PPUSH
74075: CALL_OW 1
74079: ST_TO_ADDR
74080: GO 74028
74082: POP
74083: POP
// end ;
74084: GO 72567
74086: POP
74087: POP
// result := Replace ( result , 4 , tmp ) ;
74088: LD_ADDR_VAR 0 5
74092: PUSH
74093: LD_VAR 0 5
74097: PPUSH
74098: LD_INT 4
74100: PPUSH
74101: LD_VAR 0 8
74105: PPUSH
74106: CALL_OW 1
74110: ST_TO_ADDR
// end ;
74111: LD_VAR 0 5
74115: RET
// export function DangerAtRange ( unit , range ) ; begin
74116: LD_INT 0
74118: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74119: LD_ADDR_VAR 0 3
74123: PUSH
74124: LD_VAR 0 1
74128: PPUSH
74129: CALL_OW 255
74133: PPUSH
74134: LD_VAR 0 1
74138: PPUSH
74139: CALL_OW 250
74143: PPUSH
74144: LD_VAR 0 1
74148: PPUSH
74149: CALL_OW 251
74153: PPUSH
74154: LD_VAR 0 2
74158: PPUSH
74159: CALL 72419 0 4
74163: ST_TO_ADDR
// end ;
74164: LD_VAR 0 3
74168: RET
// export function DangerInArea ( side , area ) ; begin
74169: LD_INT 0
74171: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74172: LD_ADDR_VAR 0 3
74176: PUSH
74177: LD_VAR 0 2
74181: PPUSH
74182: LD_INT 81
74184: PUSH
74185: LD_VAR 0 1
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: PPUSH
74194: CALL_OW 70
74198: ST_TO_ADDR
// end ;
74199: LD_VAR 0 3
74203: RET
// export function IsExtension ( b ) ; begin
74204: LD_INT 0
74206: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74207: LD_ADDR_VAR 0 2
74211: PUSH
74212: LD_VAR 0 1
74216: PUSH
74217: LD_INT 23
74219: PUSH
74220: LD_INT 20
74222: PUSH
74223: LD_INT 22
74225: PUSH
74226: LD_INT 17
74228: PUSH
74229: LD_INT 24
74231: PUSH
74232: LD_INT 21
74234: PUSH
74235: LD_INT 19
74237: PUSH
74238: LD_INT 16
74240: PUSH
74241: LD_INT 25
74243: PUSH
74244: LD_INT 18
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: IN
74259: ST_TO_ADDR
// end ;
74260: LD_VAR 0 2
74264: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74265: LD_INT 0
74267: PPUSH
74268: PPUSH
74269: PPUSH
// result := [ ] ;
74270: LD_ADDR_VAR 0 3
74274: PUSH
74275: EMPTY
74276: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74277: LD_ADDR_VAR 0 4
74281: PUSH
74282: LD_VAR 0 2
74286: PPUSH
74287: LD_INT 21
74289: PUSH
74290: LD_INT 3
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PPUSH
74297: CALL_OW 70
74301: ST_TO_ADDR
// if not tmp then
74302: LD_VAR 0 4
74306: NOT
74307: IFFALSE 74311
// exit ;
74309: GO 74369
// for i in tmp do
74311: LD_ADDR_VAR 0 5
74315: PUSH
74316: LD_VAR 0 4
74320: PUSH
74321: FOR_IN
74322: IFFALSE 74357
// if GetBase ( i ) <> base then
74324: LD_VAR 0 5
74328: PPUSH
74329: CALL_OW 274
74333: PUSH
74334: LD_VAR 0 1
74338: NONEQUAL
74339: IFFALSE 74355
// ComLinkToBase ( base , i ) ;
74341: LD_VAR 0 1
74345: PPUSH
74346: LD_VAR 0 5
74350: PPUSH
74351: CALL_OW 169
74355: GO 74321
74357: POP
74358: POP
// result := tmp ;
74359: LD_ADDR_VAR 0 3
74363: PUSH
74364: LD_VAR 0 4
74368: ST_TO_ADDR
// end ;
74369: LD_VAR 0 3
74373: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74374: LD_INT 0
74376: PPUSH
74377: PPUSH
// if BuildingStatus ( b ) = bs_build then
74378: LD_VAR 0 2
74382: PPUSH
74383: CALL_OW 461
74387: PUSH
74388: LD_INT 1
74390: EQUAL
74391: IFFALSE 74451
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74393: LD_VAR 0 1
74397: PPUSH
74398: LD_STRING h
74400: PUSH
74401: LD_VAR 0 2
74405: PPUSH
74406: CALL_OW 250
74410: PUSH
74411: LD_VAR 0 2
74415: PPUSH
74416: CALL_OW 251
74420: PUSH
74421: LD_VAR 0 2
74425: PUSH
74426: LD_INT 0
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: LD_INT 0
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: PUSH
74444: EMPTY
74445: LIST
74446: PPUSH
74447: CALL_OW 446
// end ;
74451: LD_VAR 0 3
74455: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74456: LD_INT 0
74458: PPUSH
74459: PPUSH
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74464: LD_VAR 0 1
74468: NOT
74469: PUSH
74470: LD_VAR 0 1
74474: PPUSH
74475: CALL_OW 263
74479: PUSH
74480: LD_INT 2
74482: EQUAL
74483: NOT
74484: OR
74485: IFFALSE 74489
// exit ;
74487: GO 74805
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74489: LD_ADDR_VAR 0 6
74493: PUSH
74494: LD_INT 22
74496: PUSH
74497: LD_VAR 0 1
74501: PPUSH
74502: CALL_OW 255
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 2
74513: PUSH
74514: LD_INT 30
74516: PUSH
74517: LD_INT 36
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 34
74526: PUSH
74527: LD_INT 31
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: LIST
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PPUSH
74543: CALL_OW 69
74547: ST_TO_ADDR
// if not tmp then
74548: LD_VAR 0 6
74552: NOT
74553: IFFALSE 74557
// exit ;
74555: GO 74805
// result := [ ] ;
74557: LD_ADDR_VAR 0 2
74561: PUSH
74562: EMPTY
74563: ST_TO_ADDR
// for i in tmp do
74564: LD_ADDR_VAR 0 3
74568: PUSH
74569: LD_VAR 0 6
74573: PUSH
74574: FOR_IN
74575: IFFALSE 74646
// begin t := UnitsInside ( i ) ;
74577: LD_ADDR_VAR 0 4
74581: PUSH
74582: LD_VAR 0 3
74586: PPUSH
74587: CALL_OW 313
74591: ST_TO_ADDR
// if t then
74592: LD_VAR 0 4
74596: IFFALSE 74644
// for j in t do
74598: LD_ADDR_VAR 0 7
74602: PUSH
74603: LD_VAR 0 4
74607: PUSH
74608: FOR_IN
74609: IFFALSE 74642
// result := Insert ( result , result + 1 , j ) ;
74611: LD_ADDR_VAR 0 2
74615: PUSH
74616: LD_VAR 0 2
74620: PPUSH
74621: LD_VAR 0 2
74625: PUSH
74626: LD_INT 1
74628: PLUS
74629: PPUSH
74630: LD_VAR 0 7
74634: PPUSH
74635: CALL_OW 2
74639: ST_TO_ADDR
74640: GO 74608
74642: POP
74643: POP
// end ;
74644: GO 74574
74646: POP
74647: POP
// if not result then
74648: LD_VAR 0 2
74652: NOT
74653: IFFALSE 74657
// exit ;
74655: GO 74805
// mech := result [ 1 ] ;
74657: LD_ADDR_VAR 0 5
74661: PUSH
74662: LD_VAR 0 2
74666: PUSH
74667: LD_INT 1
74669: ARRAY
74670: ST_TO_ADDR
// if result > 1 then
74671: LD_VAR 0 2
74675: PUSH
74676: LD_INT 1
74678: GREATER
74679: IFFALSE 74791
// for i = 2 to result do
74681: LD_ADDR_VAR 0 3
74685: PUSH
74686: DOUBLE
74687: LD_INT 2
74689: DEC
74690: ST_TO_ADDR
74691: LD_VAR 0 2
74695: PUSH
74696: FOR_TO
74697: IFFALSE 74789
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74699: LD_ADDR_VAR 0 4
74703: PUSH
74704: LD_VAR 0 2
74708: PUSH
74709: LD_VAR 0 3
74713: ARRAY
74714: PPUSH
74715: LD_INT 3
74717: PPUSH
74718: CALL_OW 259
74722: PUSH
74723: LD_VAR 0 2
74727: PUSH
74728: LD_VAR 0 3
74732: ARRAY
74733: PPUSH
74734: CALL_OW 432
74738: MINUS
74739: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74740: LD_VAR 0 4
74744: PUSH
74745: LD_VAR 0 5
74749: PPUSH
74750: LD_INT 3
74752: PPUSH
74753: CALL_OW 259
74757: PUSH
74758: LD_VAR 0 5
74762: PPUSH
74763: CALL_OW 432
74767: MINUS
74768: GREATEREQUAL
74769: IFFALSE 74787
// mech := result [ i ] ;
74771: LD_ADDR_VAR 0 5
74775: PUSH
74776: LD_VAR 0 2
74780: PUSH
74781: LD_VAR 0 3
74785: ARRAY
74786: ST_TO_ADDR
// end ;
74787: GO 74696
74789: POP
74790: POP
// ComLinkTo ( vehicle , mech ) ;
74791: LD_VAR 0 1
74795: PPUSH
74796: LD_VAR 0 5
74800: PPUSH
74801: CALL_OW 135
// end ;
74805: LD_VAR 0 2
74809: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74810: LD_INT 0
74812: PPUSH
74813: PPUSH
74814: PPUSH
74815: PPUSH
74816: PPUSH
74817: PPUSH
74818: PPUSH
74819: PPUSH
74820: PPUSH
74821: PPUSH
74822: PPUSH
74823: PPUSH
74824: PPUSH
// result := [ ] ;
74825: LD_ADDR_VAR 0 7
74829: PUSH
74830: EMPTY
74831: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74832: LD_VAR 0 1
74836: PPUSH
74837: CALL_OW 266
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: IN
74852: NOT
74853: IFFALSE 74857
// exit ;
74855: GO 76488
// if name then
74857: LD_VAR 0 3
74861: IFFALSE 74877
// SetBName ( base_dep , name ) ;
74863: LD_VAR 0 1
74867: PPUSH
74868: LD_VAR 0 3
74872: PPUSH
74873: CALL_OW 500
// base := GetBase ( base_dep ) ;
74877: LD_ADDR_VAR 0 15
74881: PUSH
74882: LD_VAR 0 1
74886: PPUSH
74887: CALL_OW 274
74891: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74892: LD_ADDR_VAR 0 16
74896: PUSH
74897: LD_VAR 0 1
74901: PPUSH
74902: CALL_OW 255
74906: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74907: LD_ADDR_VAR 0 17
74911: PUSH
74912: LD_VAR 0 1
74916: PPUSH
74917: CALL_OW 248
74921: ST_TO_ADDR
// if sources then
74922: LD_VAR 0 5
74926: IFFALSE 74973
// for i = 1 to 3 do
74928: LD_ADDR_VAR 0 8
74932: PUSH
74933: DOUBLE
74934: LD_INT 1
74936: DEC
74937: ST_TO_ADDR
74938: LD_INT 3
74940: PUSH
74941: FOR_TO
74942: IFFALSE 74971
// AddResourceType ( base , i , sources [ i ] ) ;
74944: LD_VAR 0 15
74948: PPUSH
74949: LD_VAR 0 8
74953: PPUSH
74954: LD_VAR 0 5
74958: PUSH
74959: LD_VAR 0 8
74963: ARRAY
74964: PPUSH
74965: CALL_OW 276
74969: GO 74941
74971: POP
74972: POP
// buildings := GetBaseBuildings ( base , area ) ;
74973: LD_ADDR_VAR 0 18
74977: PUSH
74978: LD_VAR 0 15
74982: PPUSH
74983: LD_VAR 0 2
74987: PPUSH
74988: CALL 74265 0 2
74992: ST_TO_ADDR
// InitHc ;
74993: CALL_OW 19
// InitUc ;
74997: CALL_OW 18
// uc_side := side ;
75001: LD_ADDR_OWVAR 20
75005: PUSH
75006: LD_VAR 0 16
75010: ST_TO_ADDR
// uc_nation := nation ;
75011: LD_ADDR_OWVAR 21
75015: PUSH
75016: LD_VAR 0 17
75020: ST_TO_ADDR
// if buildings then
75021: LD_VAR 0 18
75025: IFFALSE 76347
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75027: LD_ADDR_VAR 0 19
75031: PUSH
75032: LD_VAR 0 18
75036: PPUSH
75037: LD_INT 2
75039: PUSH
75040: LD_INT 30
75042: PUSH
75043: LD_INT 29
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 30
75052: PUSH
75053: LD_INT 30
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: LIST
75064: PPUSH
75065: CALL_OW 72
75069: ST_TO_ADDR
// if tmp then
75070: LD_VAR 0 19
75074: IFFALSE 75122
// for i in tmp do
75076: LD_ADDR_VAR 0 8
75080: PUSH
75081: LD_VAR 0 19
75085: PUSH
75086: FOR_IN
75087: IFFALSE 75120
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75089: LD_VAR 0 8
75093: PPUSH
75094: CALL_OW 250
75098: PPUSH
75099: LD_VAR 0 8
75103: PPUSH
75104: CALL_OW 251
75108: PPUSH
75109: LD_VAR 0 16
75113: PPUSH
75114: CALL_OW 441
75118: GO 75086
75120: POP
75121: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75122: LD_VAR 0 18
75126: PPUSH
75127: LD_INT 2
75129: PUSH
75130: LD_INT 30
75132: PUSH
75133: LD_INT 32
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 30
75142: PUSH
75143: LD_INT 33
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: LIST
75154: PPUSH
75155: CALL_OW 72
75159: IFFALSE 75247
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75161: LD_ADDR_VAR 0 8
75165: PUSH
75166: LD_VAR 0 18
75170: PPUSH
75171: LD_INT 2
75173: PUSH
75174: LD_INT 30
75176: PUSH
75177: LD_INT 32
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 30
75186: PUSH
75187: LD_INT 33
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: LIST
75198: PPUSH
75199: CALL_OW 72
75203: PUSH
75204: FOR_IN
75205: IFFALSE 75245
// begin if not GetBWeapon ( i ) then
75207: LD_VAR 0 8
75211: PPUSH
75212: CALL_OW 269
75216: NOT
75217: IFFALSE 75243
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75219: LD_VAR 0 8
75223: PPUSH
75224: LD_VAR 0 8
75228: PPUSH
75229: LD_VAR 0 2
75233: PPUSH
75234: CALL 76493 0 2
75238: PPUSH
75239: CALL_OW 431
// end ;
75243: GO 75204
75245: POP
75246: POP
// end ; for i = 1 to personel do
75247: LD_ADDR_VAR 0 8
75251: PUSH
75252: DOUBLE
75253: LD_INT 1
75255: DEC
75256: ST_TO_ADDR
75257: LD_VAR 0 6
75261: PUSH
75262: FOR_TO
75263: IFFALSE 76327
// begin if i > 4 then
75265: LD_VAR 0 8
75269: PUSH
75270: LD_INT 4
75272: GREATER
75273: IFFALSE 75277
// break ;
75275: GO 76327
// case i of 1 :
75277: LD_VAR 0 8
75281: PUSH
75282: LD_INT 1
75284: DOUBLE
75285: EQUAL
75286: IFTRUE 75290
75288: GO 75370
75290: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75291: LD_ADDR_VAR 0 12
75295: PUSH
75296: LD_VAR 0 18
75300: PPUSH
75301: LD_INT 22
75303: PUSH
75304: LD_VAR 0 16
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 58
75315: PUSH
75316: EMPTY
75317: LIST
75318: PUSH
75319: LD_INT 2
75321: PUSH
75322: LD_INT 30
75324: PUSH
75325: LD_INT 32
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 30
75334: PUSH
75335: LD_INT 4
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: LD_INT 30
75344: PUSH
75345: LD_INT 5
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: LIST
75362: PPUSH
75363: CALL_OW 72
75367: ST_TO_ADDR
75368: GO 75592
75370: LD_INT 2
75372: DOUBLE
75373: EQUAL
75374: IFTRUE 75378
75376: GO 75440
75378: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75379: LD_ADDR_VAR 0 12
75383: PUSH
75384: LD_VAR 0 18
75388: PPUSH
75389: LD_INT 22
75391: PUSH
75392: LD_VAR 0 16
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 2
75403: PUSH
75404: LD_INT 30
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: LD_INT 30
75416: PUSH
75417: LD_INT 1
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: LIST
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PPUSH
75433: CALL_OW 72
75437: ST_TO_ADDR
75438: GO 75592
75440: LD_INT 3
75442: DOUBLE
75443: EQUAL
75444: IFTRUE 75448
75446: GO 75510
75448: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75449: LD_ADDR_VAR 0 12
75453: PUSH
75454: LD_VAR 0 18
75458: PPUSH
75459: LD_INT 22
75461: PUSH
75462: LD_VAR 0 16
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 2
75473: PUSH
75474: LD_INT 30
75476: PUSH
75477: LD_INT 2
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 30
75486: PUSH
75487: LD_INT 3
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: LIST
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PPUSH
75503: CALL_OW 72
75507: ST_TO_ADDR
75508: GO 75592
75510: LD_INT 4
75512: DOUBLE
75513: EQUAL
75514: IFTRUE 75518
75516: GO 75591
75518: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75519: LD_ADDR_VAR 0 12
75523: PUSH
75524: LD_VAR 0 18
75528: PPUSH
75529: LD_INT 22
75531: PUSH
75532: LD_VAR 0 16
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 2
75543: PUSH
75544: LD_INT 30
75546: PUSH
75547: LD_INT 6
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 30
75556: PUSH
75557: LD_INT 7
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 30
75566: PUSH
75567: LD_INT 8
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: PPUSH
75584: CALL_OW 72
75588: ST_TO_ADDR
75589: GO 75592
75591: POP
// if i = 1 then
75592: LD_VAR 0 8
75596: PUSH
75597: LD_INT 1
75599: EQUAL
75600: IFFALSE 75711
// begin tmp := [ ] ;
75602: LD_ADDR_VAR 0 19
75606: PUSH
75607: EMPTY
75608: ST_TO_ADDR
// for j in f do
75609: LD_ADDR_VAR 0 9
75613: PUSH
75614: LD_VAR 0 12
75618: PUSH
75619: FOR_IN
75620: IFFALSE 75693
// if GetBType ( j ) = b_bunker then
75622: LD_VAR 0 9
75626: PPUSH
75627: CALL_OW 266
75631: PUSH
75632: LD_INT 32
75634: EQUAL
75635: IFFALSE 75662
// tmp := Insert ( tmp , 1 , j ) else
75637: LD_ADDR_VAR 0 19
75641: PUSH
75642: LD_VAR 0 19
75646: PPUSH
75647: LD_INT 1
75649: PPUSH
75650: LD_VAR 0 9
75654: PPUSH
75655: CALL_OW 2
75659: ST_TO_ADDR
75660: GO 75691
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75662: LD_ADDR_VAR 0 19
75666: PUSH
75667: LD_VAR 0 19
75671: PPUSH
75672: LD_VAR 0 19
75676: PUSH
75677: LD_INT 1
75679: PLUS
75680: PPUSH
75681: LD_VAR 0 9
75685: PPUSH
75686: CALL_OW 2
75690: ST_TO_ADDR
75691: GO 75619
75693: POP
75694: POP
// if tmp then
75695: LD_VAR 0 19
75699: IFFALSE 75711
// f := tmp ;
75701: LD_ADDR_VAR 0 12
75705: PUSH
75706: LD_VAR 0 19
75710: ST_TO_ADDR
// end ; x := personel [ i ] ;
75711: LD_ADDR_VAR 0 13
75715: PUSH
75716: LD_VAR 0 6
75720: PUSH
75721: LD_VAR 0 8
75725: ARRAY
75726: ST_TO_ADDR
// if x = - 1 then
75727: LD_VAR 0 13
75731: PUSH
75732: LD_INT 1
75734: NEG
75735: EQUAL
75736: IFFALSE 75945
// begin for j in f do
75738: LD_ADDR_VAR 0 9
75742: PUSH
75743: LD_VAR 0 12
75747: PUSH
75748: FOR_IN
75749: IFFALSE 75941
// repeat InitHc ;
75751: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75755: LD_VAR 0 9
75759: PPUSH
75760: CALL_OW 266
75764: PUSH
75765: LD_INT 5
75767: EQUAL
75768: IFFALSE 75838
// begin if UnitsInside ( j ) < 3 then
75770: LD_VAR 0 9
75774: PPUSH
75775: CALL_OW 313
75779: PUSH
75780: LD_INT 3
75782: LESS
75783: IFFALSE 75819
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75785: LD_INT 0
75787: PPUSH
75788: LD_INT 5
75790: PUSH
75791: LD_INT 8
75793: PUSH
75794: LD_INT 9
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: LIST
75801: PUSH
75802: LD_VAR 0 17
75806: ARRAY
75807: PPUSH
75808: LD_VAR 0 4
75812: PPUSH
75813: CALL_OW 380
75817: GO 75836
// PrepareHuman ( false , i , skill ) ;
75819: LD_INT 0
75821: PPUSH
75822: LD_VAR 0 8
75826: PPUSH
75827: LD_VAR 0 4
75831: PPUSH
75832: CALL_OW 380
// end else
75836: GO 75855
// PrepareHuman ( false , i , skill ) ;
75838: LD_INT 0
75840: PPUSH
75841: LD_VAR 0 8
75845: PPUSH
75846: LD_VAR 0 4
75850: PPUSH
75851: CALL_OW 380
// un := CreateHuman ;
75855: LD_ADDR_VAR 0 14
75859: PUSH
75860: CALL_OW 44
75864: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75865: LD_ADDR_VAR 0 7
75869: PUSH
75870: LD_VAR 0 7
75874: PPUSH
75875: LD_INT 1
75877: PPUSH
75878: LD_VAR 0 14
75882: PPUSH
75883: CALL_OW 2
75887: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75888: LD_VAR 0 14
75892: PPUSH
75893: LD_VAR 0 9
75897: PPUSH
75898: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75902: LD_VAR 0 9
75906: PPUSH
75907: CALL_OW 313
75911: PUSH
75912: LD_INT 6
75914: EQUAL
75915: PUSH
75916: LD_VAR 0 9
75920: PPUSH
75921: CALL_OW 266
75925: PUSH
75926: LD_INT 32
75928: PUSH
75929: LD_INT 31
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: IN
75936: OR
75937: IFFALSE 75751
75939: GO 75748
75941: POP
75942: POP
// end else
75943: GO 76325
// for j = 1 to x do
75945: LD_ADDR_VAR 0 9
75949: PUSH
75950: DOUBLE
75951: LD_INT 1
75953: DEC
75954: ST_TO_ADDR
75955: LD_VAR 0 13
75959: PUSH
75960: FOR_TO
75961: IFFALSE 76323
// begin InitHc ;
75963: CALL_OW 19
// if not f then
75967: LD_VAR 0 12
75971: NOT
75972: IFFALSE 76061
// begin PrepareHuman ( false , i , skill ) ;
75974: LD_INT 0
75976: PPUSH
75977: LD_VAR 0 8
75981: PPUSH
75982: LD_VAR 0 4
75986: PPUSH
75987: CALL_OW 380
// un := CreateHuman ;
75991: LD_ADDR_VAR 0 14
75995: PUSH
75996: CALL_OW 44
76000: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76001: LD_ADDR_VAR 0 7
76005: PUSH
76006: LD_VAR 0 7
76010: PPUSH
76011: LD_INT 1
76013: PPUSH
76014: LD_VAR 0 14
76018: PPUSH
76019: CALL_OW 2
76023: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76024: LD_VAR 0 14
76028: PPUSH
76029: LD_VAR 0 1
76033: PPUSH
76034: CALL_OW 250
76038: PPUSH
76039: LD_VAR 0 1
76043: PPUSH
76044: CALL_OW 251
76048: PPUSH
76049: LD_INT 10
76051: PPUSH
76052: LD_INT 0
76054: PPUSH
76055: CALL_OW 50
// continue ;
76059: GO 75960
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76061: LD_VAR 0 12
76065: PUSH
76066: LD_INT 1
76068: ARRAY
76069: PPUSH
76070: CALL_OW 313
76074: PUSH
76075: LD_VAR 0 12
76079: PUSH
76080: LD_INT 1
76082: ARRAY
76083: PPUSH
76084: CALL_OW 266
76088: PUSH
76089: LD_INT 32
76091: PUSH
76092: LD_INT 31
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: IN
76099: AND
76100: PUSH
76101: LD_VAR 0 12
76105: PUSH
76106: LD_INT 1
76108: ARRAY
76109: PPUSH
76110: CALL_OW 313
76114: PUSH
76115: LD_INT 6
76117: EQUAL
76118: OR
76119: IFFALSE 76139
// f := Delete ( f , 1 ) ;
76121: LD_ADDR_VAR 0 12
76125: PUSH
76126: LD_VAR 0 12
76130: PPUSH
76131: LD_INT 1
76133: PPUSH
76134: CALL_OW 3
76138: ST_TO_ADDR
// if not f then
76139: LD_VAR 0 12
76143: NOT
76144: IFFALSE 76162
// begin x := x + 2 ;
76146: LD_ADDR_VAR 0 13
76150: PUSH
76151: LD_VAR 0 13
76155: PUSH
76156: LD_INT 2
76158: PLUS
76159: ST_TO_ADDR
// continue ;
76160: GO 75960
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76162: LD_VAR 0 12
76166: PUSH
76167: LD_INT 1
76169: ARRAY
76170: PPUSH
76171: CALL_OW 266
76175: PUSH
76176: LD_INT 5
76178: EQUAL
76179: IFFALSE 76253
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76181: LD_VAR 0 12
76185: PUSH
76186: LD_INT 1
76188: ARRAY
76189: PPUSH
76190: CALL_OW 313
76194: PUSH
76195: LD_INT 3
76197: LESS
76198: IFFALSE 76234
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76200: LD_INT 0
76202: PPUSH
76203: LD_INT 5
76205: PUSH
76206: LD_INT 8
76208: PUSH
76209: LD_INT 9
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: LIST
76216: PUSH
76217: LD_VAR 0 17
76221: ARRAY
76222: PPUSH
76223: LD_VAR 0 4
76227: PPUSH
76228: CALL_OW 380
76232: GO 76251
// PrepareHuman ( false , i , skill ) ;
76234: LD_INT 0
76236: PPUSH
76237: LD_VAR 0 8
76241: PPUSH
76242: LD_VAR 0 4
76246: PPUSH
76247: CALL_OW 380
// end else
76251: GO 76270
// PrepareHuman ( false , i , skill ) ;
76253: LD_INT 0
76255: PPUSH
76256: LD_VAR 0 8
76260: PPUSH
76261: LD_VAR 0 4
76265: PPUSH
76266: CALL_OW 380
// un := CreateHuman ;
76270: LD_ADDR_VAR 0 14
76274: PUSH
76275: CALL_OW 44
76279: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76280: LD_ADDR_VAR 0 7
76284: PUSH
76285: LD_VAR 0 7
76289: PPUSH
76290: LD_INT 1
76292: PPUSH
76293: LD_VAR 0 14
76297: PPUSH
76298: CALL_OW 2
76302: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76303: LD_VAR 0 14
76307: PPUSH
76308: LD_VAR 0 12
76312: PUSH
76313: LD_INT 1
76315: ARRAY
76316: PPUSH
76317: CALL_OW 52
// end ;
76321: GO 75960
76323: POP
76324: POP
// end ;
76325: GO 75262
76327: POP
76328: POP
// result := result ^ buildings ;
76329: LD_ADDR_VAR 0 7
76333: PUSH
76334: LD_VAR 0 7
76338: PUSH
76339: LD_VAR 0 18
76343: ADD
76344: ST_TO_ADDR
// end else
76345: GO 76488
// begin for i = 1 to personel do
76347: LD_ADDR_VAR 0 8
76351: PUSH
76352: DOUBLE
76353: LD_INT 1
76355: DEC
76356: ST_TO_ADDR
76357: LD_VAR 0 6
76361: PUSH
76362: FOR_TO
76363: IFFALSE 76486
// begin if i > 4 then
76365: LD_VAR 0 8
76369: PUSH
76370: LD_INT 4
76372: GREATER
76373: IFFALSE 76377
// break ;
76375: GO 76486
// x := personel [ i ] ;
76377: LD_ADDR_VAR 0 13
76381: PUSH
76382: LD_VAR 0 6
76386: PUSH
76387: LD_VAR 0 8
76391: ARRAY
76392: ST_TO_ADDR
// if x = - 1 then
76393: LD_VAR 0 13
76397: PUSH
76398: LD_INT 1
76400: NEG
76401: EQUAL
76402: IFFALSE 76406
// continue ;
76404: GO 76362
// PrepareHuman ( false , i , skill ) ;
76406: LD_INT 0
76408: PPUSH
76409: LD_VAR 0 8
76413: PPUSH
76414: LD_VAR 0 4
76418: PPUSH
76419: CALL_OW 380
// un := CreateHuman ;
76423: LD_ADDR_VAR 0 14
76427: PUSH
76428: CALL_OW 44
76432: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76433: LD_VAR 0 14
76437: PPUSH
76438: LD_VAR 0 1
76442: PPUSH
76443: CALL_OW 250
76447: PPUSH
76448: LD_VAR 0 1
76452: PPUSH
76453: CALL_OW 251
76457: PPUSH
76458: LD_INT 10
76460: PPUSH
76461: LD_INT 0
76463: PPUSH
76464: CALL_OW 50
// result := result ^ un ;
76468: LD_ADDR_VAR 0 7
76472: PUSH
76473: LD_VAR 0 7
76477: PUSH
76478: LD_VAR 0 14
76482: ADD
76483: ST_TO_ADDR
// end ;
76484: GO 76362
76486: POP
76487: POP
// end ; end ;
76488: LD_VAR 0 7
76492: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76493: LD_INT 0
76495: PPUSH
76496: PPUSH
76497: PPUSH
76498: PPUSH
76499: PPUSH
76500: PPUSH
76501: PPUSH
76502: PPUSH
76503: PPUSH
76504: PPUSH
76505: PPUSH
76506: PPUSH
76507: PPUSH
76508: PPUSH
76509: PPUSH
76510: PPUSH
// result := false ;
76511: LD_ADDR_VAR 0 3
76515: PUSH
76516: LD_INT 0
76518: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76519: LD_VAR 0 1
76523: NOT
76524: PUSH
76525: LD_VAR 0 1
76529: PPUSH
76530: CALL_OW 266
76534: PUSH
76535: LD_INT 32
76537: PUSH
76538: LD_INT 33
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: IN
76545: NOT
76546: OR
76547: IFFALSE 76551
// exit ;
76549: GO 77687
// nat := GetNation ( tower ) ;
76551: LD_ADDR_VAR 0 12
76555: PUSH
76556: LD_VAR 0 1
76560: PPUSH
76561: CALL_OW 248
76565: ST_TO_ADDR
// side := GetSide ( tower ) ;
76566: LD_ADDR_VAR 0 16
76570: PUSH
76571: LD_VAR 0 1
76575: PPUSH
76576: CALL_OW 255
76580: ST_TO_ADDR
// x := GetX ( tower ) ;
76581: LD_ADDR_VAR 0 10
76585: PUSH
76586: LD_VAR 0 1
76590: PPUSH
76591: CALL_OW 250
76595: ST_TO_ADDR
// y := GetY ( tower ) ;
76596: LD_ADDR_VAR 0 11
76600: PUSH
76601: LD_VAR 0 1
76605: PPUSH
76606: CALL_OW 251
76610: ST_TO_ADDR
// if not x or not y then
76611: LD_VAR 0 10
76615: NOT
76616: PUSH
76617: LD_VAR 0 11
76621: NOT
76622: OR
76623: IFFALSE 76627
// exit ;
76625: GO 77687
// weapon := 0 ;
76627: LD_ADDR_VAR 0 18
76631: PUSH
76632: LD_INT 0
76634: ST_TO_ADDR
// fac_list := [ ] ;
76635: LD_ADDR_VAR 0 17
76639: PUSH
76640: EMPTY
76641: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76642: LD_ADDR_VAR 0 6
76646: PUSH
76647: LD_VAR 0 1
76651: PPUSH
76652: CALL_OW 274
76656: PPUSH
76657: LD_VAR 0 2
76661: PPUSH
76662: CALL 74265 0 2
76666: PPUSH
76667: LD_INT 30
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PPUSH
76677: CALL_OW 72
76681: ST_TO_ADDR
// if not factories then
76682: LD_VAR 0 6
76686: NOT
76687: IFFALSE 76691
// exit ;
76689: GO 77687
// for i in factories do
76691: LD_ADDR_VAR 0 8
76695: PUSH
76696: LD_VAR 0 6
76700: PUSH
76701: FOR_IN
76702: IFFALSE 76727
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76704: LD_ADDR_VAR 0 17
76708: PUSH
76709: LD_VAR 0 17
76713: PUSH
76714: LD_VAR 0 8
76718: PPUSH
76719: CALL_OW 478
76723: UNION
76724: ST_TO_ADDR
76725: GO 76701
76727: POP
76728: POP
// if not fac_list then
76729: LD_VAR 0 17
76733: NOT
76734: IFFALSE 76738
// exit ;
76736: GO 77687
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76738: LD_ADDR_VAR 0 5
76742: PUSH
76743: LD_INT 4
76745: PUSH
76746: LD_INT 5
76748: PUSH
76749: LD_INT 9
76751: PUSH
76752: LD_INT 10
76754: PUSH
76755: LD_INT 6
76757: PUSH
76758: LD_INT 7
76760: PUSH
76761: LD_INT 11
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 27
76775: PUSH
76776: LD_INT 28
76778: PUSH
76779: LD_INT 26
76781: PUSH
76782: LD_INT 30
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: PUSH
76791: LD_INT 43
76793: PUSH
76794: LD_INT 44
76796: PUSH
76797: LD_INT 46
76799: PUSH
76800: LD_INT 45
76802: PUSH
76803: LD_INT 47
76805: PUSH
76806: LD_INT 49
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: PUSH
76817: EMPTY
76818: LIST
76819: LIST
76820: LIST
76821: PUSH
76822: LD_VAR 0 12
76826: ARRAY
76827: ST_TO_ADDR
// for i in list do
76828: LD_ADDR_VAR 0 8
76832: PUSH
76833: LD_VAR 0 5
76837: PUSH
76838: FOR_IN
76839: IFFALSE 76872
// if not i in fac_list then
76841: LD_VAR 0 8
76845: PUSH
76846: LD_VAR 0 17
76850: IN
76851: NOT
76852: IFFALSE 76870
// list := list diff i ;
76854: LD_ADDR_VAR 0 5
76858: PUSH
76859: LD_VAR 0 5
76863: PUSH
76864: LD_VAR 0 8
76868: DIFF
76869: ST_TO_ADDR
76870: GO 76838
76872: POP
76873: POP
// if not list then
76874: LD_VAR 0 5
76878: NOT
76879: IFFALSE 76883
// exit ;
76881: GO 77687
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76883: LD_VAR 0 12
76887: PUSH
76888: LD_INT 3
76890: EQUAL
76891: PUSH
76892: LD_INT 49
76894: PUSH
76895: LD_VAR 0 5
76899: IN
76900: AND
76901: PUSH
76902: LD_INT 31
76904: PPUSH
76905: LD_VAR 0 16
76909: PPUSH
76910: CALL_OW 321
76914: PUSH
76915: LD_INT 2
76917: EQUAL
76918: AND
76919: IFFALSE 76979
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76921: LD_INT 22
76923: PUSH
76924: LD_VAR 0 16
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: LD_INT 35
76935: PUSH
76936: LD_INT 49
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: LD_INT 91
76945: PUSH
76946: LD_VAR 0 1
76950: PUSH
76951: LD_INT 10
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: LIST
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: LIST
76963: PPUSH
76964: CALL_OW 69
76968: NOT
76969: IFFALSE 76979
// weapon := ru_time_lapser ;
76971: LD_ADDR_VAR 0 18
76975: PUSH
76976: LD_INT 49
76978: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76979: LD_VAR 0 12
76983: PUSH
76984: LD_INT 1
76986: PUSH
76987: LD_INT 2
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: IN
76994: PUSH
76995: LD_INT 11
76997: PUSH
76998: LD_VAR 0 5
77002: IN
77003: PUSH
77004: LD_INT 30
77006: PUSH
77007: LD_VAR 0 5
77011: IN
77012: OR
77013: AND
77014: PUSH
77015: LD_INT 6
77017: PPUSH
77018: LD_VAR 0 16
77022: PPUSH
77023: CALL_OW 321
77027: PUSH
77028: LD_INT 2
77030: EQUAL
77031: AND
77032: IFFALSE 77197
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77034: LD_INT 22
77036: PUSH
77037: LD_VAR 0 16
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 35
77051: PUSH
77052: LD_INT 11
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 35
77061: PUSH
77062: LD_INT 30
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 91
77076: PUSH
77077: LD_VAR 0 1
77081: PUSH
77082: LD_INT 18
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: LIST
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: LIST
77094: PPUSH
77095: CALL_OW 69
77099: NOT
77100: PUSH
77101: LD_INT 22
77103: PUSH
77104: LD_VAR 0 16
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 2
77115: PUSH
77116: LD_INT 30
77118: PUSH
77119: LD_INT 32
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 30
77128: PUSH
77129: LD_INT 33
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 91
77143: PUSH
77144: LD_VAR 0 1
77148: PUSH
77149: LD_INT 12
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: LIST
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: PUSH
77162: EMPTY
77163: LIST
77164: PPUSH
77165: CALL_OW 69
77169: PUSH
77170: LD_INT 2
77172: GREATER
77173: AND
77174: IFFALSE 77197
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77176: LD_ADDR_VAR 0 18
77180: PUSH
77181: LD_INT 11
77183: PUSH
77184: LD_INT 30
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_VAR 0 12
77195: ARRAY
77196: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77197: LD_VAR 0 18
77201: NOT
77202: PUSH
77203: LD_INT 40
77205: PPUSH
77206: LD_VAR 0 16
77210: PPUSH
77211: CALL_OW 321
77215: PUSH
77216: LD_INT 2
77218: EQUAL
77219: AND
77220: PUSH
77221: LD_INT 7
77223: PUSH
77224: LD_VAR 0 5
77228: IN
77229: PUSH
77230: LD_INT 28
77232: PUSH
77233: LD_VAR 0 5
77237: IN
77238: OR
77239: PUSH
77240: LD_INT 45
77242: PUSH
77243: LD_VAR 0 5
77247: IN
77248: OR
77249: AND
77250: IFFALSE 77504
// begin hex := GetHexInfo ( x , y ) ;
77252: LD_ADDR_VAR 0 4
77256: PUSH
77257: LD_VAR 0 10
77261: PPUSH
77262: LD_VAR 0 11
77266: PPUSH
77267: CALL_OW 546
77271: ST_TO_ADDR
// if hex [ 1 ] then
77272: LD_VAR 0 4
77276: PUSH
77277: LD_INT 1
77279: ARRAY
77280: IFFALSE 77284
// exit ;
77282: GO 77687
// height := hex [ 2 ] ;
77284: LD_ADDR_VAR 0 15
77288: PUSH
77289: LD_VAR 0 4
77293: PUSH
77294: LD_INT 2
77296: ARRAY
77297: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77298: LD_ADDR_VAR 0 14
77302: PUSH
77303: LD_INT 0
77305: PUSH
77306: LD_INT 2
77308: PUSH
77309: LD_INT 3
77311: PUSH
77312: LD_INT 5
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: ST_TO_ADDR
// for i in tmp do
77321: LD_ADDR_VAR 0 8
77325: PUSH
77326: LD_VAR 0 14
77330: PUSH
77331: FOR_IN
77332: IFFALSE 77502
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77334: LD_ADDR_VAR 0 9
77338: PUSH
77339: LD_VAR 0 10
77343: PPUSH
77344: LD_VAR 0 8
77348: PPUSH
77349: LD_INT 5
77351: PPUSH
77352: CALL_OW 272
77356: PUSH
77357: LD_VAR 0 11
77361: PPUSH
77362: LD_VAR 0 8
77366: PPUSH
77367: LD_INT 5
77369: PPUSH
77370: CALL_OW 273
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77379: LD_VAR 0 9
77383: PUSH
77384: LD_INT 1
77386: ARRAY
77387: PPUSH
77388: LD_VAR 0 9
77392: PUSH
77393: LD_INT 2
77395: ARRAY
77396: PPUSH
77397: CALL_OW 488
77401: IFFALSE 77500
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77403: LD_ADDR_VAR 0 4
77407: PUSH
77408: LD_VAR 0 9
77412: PUSH
77413: LD_INT 1
77415: ARRAY
77416: PPUSH
77417: LD_VAR 0 9
77421: PUSH
77422: LD_INT 2
77424: ARRAY
77425: PPUSH
77426: CALL_OW 546
77430: ST_TO_ADDR
// if hex [ 1 ] then
77431: LD_VAR 0 4
77435: PUSH
77436: LD_INT 1
77438: ARRAY
77439: IFFALSE 77443
// continue ;
77441: GO 77331
// h := hex [ 2 ] ;
77443: LD_ADDR_VAR 0 13
77447: PUSH
77448: LD_VAR 0 4
77452: PUSH
77453: LD_INT 2
77455: ARRAY
77456: ST_TO_ADDR
// if h + 7 < height then
77457: LD_VAR 0 13
77461: PUSH
77462: LD_INT 7
77464: PLUS
77465: PUSH
77466: LD_VAR 0 15
77470: LESS
77471: IFFALSE 77500
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77473: LD_ADDR_VAR 0 18
77477: PUSH
77478: LD_INT 7
77480: PUSH
77481: LD_INT 28
77483: PUSH
77484: LD_INT 45
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: LIST
77491: PUSH
77492: LD_VAR 0 12
77496: ARRAY
77497: ST_TO_ADDR
// break ;
77498: GO 77502
// end ; end ; end ;
77500: GO 77331
77502: POP
77503: POP
// end ; if not weapon then
77504: LD_VAR 0 18
77508: NOT
77509: IFFALSE 77569
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77511: LD_ADDR_VAR 0 5
77515: PUSH
77516: LD_VAR 0 5
77520: PUSH
77521: LD_INT 11
77523: PUSH
77524: LD_INT 30
77526: PUSH
77527: LD_INT 49
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: LIST
77534: DIFF
77535: ST_TO_ADDR
// if not list then
77536: LD_VAR 0 5
77540: NOT
77541: IFFALSE 77545
// exit ;
77543: GO 77687
// weapon := list [ rand ( 1 , list ) ] ;
77545: LD_ADDR_VAR 0 18
77549: PUSH
77550: LD_VAR 0 5
77554: PUSH
77555: LD_INT 1
77557: PPUSH
77558: LD_VAR 0 5
77562: PPUSH
77563: CALL_OW 12
77567: ARRAY
77568: ST_TO_ADDR
// end ; if weapon then
77569: LD_VAR 0 18
77573: IFFALSE 77687
// begin tmp := CostOfWeapon ( weapon ) ;
77575: LD_ADDR_VAR 0 14
77579: PUSH
77580: LD_VAR 0 18
77584: PPUSH
77585: CALL_OW 451
77589: ST_TO_ADDR
// j := GetBase ( tower ) ;
77590: LD_ADDR_VAR 0 9
77594: PUSH
77595: LD_VAR 0 1
77599: PPUSH
77600: CALL_OW 274
77604: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77605: LD_VAR 0 9
77609: PPUSH
77610: LD_INT 1
77612: PPUSH
77613: CALL_OW 275
77617: PUSH
77618: LD_VAR 0 14
77622: PUSH
77623: LD_INT 1
77625: ARRAY
77626: GREATEREQUAL
77627: PUSH
77628: LD_VAR 0 9
77632: PPUSH
77633: LD_INT 2
77635: PPUSH
77636: CALL_OW 275
77640: PUSH
77641: LD_VAR 0 14
77645: PUSH
77646: LD_INT 2
77648: ARRAY
77649: GREATEREQUAL
77650: AND
77651: PUSH
77652: LD_VAR 0 9
77656: PPUSH
77657: LD_INT 3
77659: PPUSH
77660: CALL_OW 275
77664: PUSH
77665: LD_VAR 0 14
77669: PUSH
77670: LD_INT 3
77672: ARRAY
77673: GREATEREQUAL
77674: AND
77675: IFFALSE 77687
// result := weapon ;
77677: LD_ADDR_VAR 0 3
77681: PUSH
77682: LD_VAR 0 18
77686: ST_TO_ADDR
// end ; end ;
77687: LD_VAR 0 3
77691: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77692: LD_INT 0
77694: PPUSH
77695: PPUSH
// result := true ;
77696: LD_ADDR_VAR 0 3
77700: PUSH
77701: LD_INT 1
77703: ST_TO_ADDR
// if array1 = array2 then
77704: LD_VAR 0 1
77708: PUSH
77709: LD_VAR 0 2
77713: EQUAL
77714: IFFALSE 77774
// begin for i = 1 to array1 do
77716: LD_ADDR_VAR 0 4
77720: PUSH
77721: DOUBLE
77722: LD_INT 1
77724: DEC
77725: ST_TO_ADDR
77726: LD_VAR 0 1
77730: PUSH
77731: FOR_TO
77732: IFFALSE 77770
// if array1 [ i ] <> array2 [ i ] then
77734: LD_VAR 0 1
77738: PUSH
77739: LD_VAR 0 4
77743: ARRAY
77744: PUSH
77745: LD_VAR 0 2
77749: PUSH
77750: LD_VAR 0 4
77754: ARRAY
77755: NONEQUAL
77756: IFFALSE 77768
// begin result := false ;
77758: LD_ADDR_VAR 0 3
77762: PUSH
77763: LD_INT 0
77765: ST_TO_ADDR
// break ;
77766: GO 77770
// end ;
77768: GO 77731
77770: POP
77771: POP
// end else
77772: GO 77782
// result := false ;
77774: LD_ADDR_VAR 0 3
77778: PUSH
77779: LD_INT 0
77781: ST_TO_ADDR
// end ;
77782: LD_VAR 0 3
77786: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77787: LD_INT 0
77789: PPUSH
77790: PPUSH
77791: PPUSH
// pom := GetBase ( fac ) ;
77792: LD_ADDR_VAR 0 5
77796: PUSH
77797: LD_VAR 0 1
77801: PPUSH
77802: CALL_OW 274
77806: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77807: LD_ADDR_VAR 0 4
77811: PUSH
77812: LD_VAR 0 2
77816: PUSH
77817: LD_INT 1
77819: ARRAY
77820: PPUSH
77821: LD_VAR 0 2
77825: PUSH
77826: LD_INT 2
77828: ARRAY
77829: PPUSH
77830: LD_VAR 0 2
77834: PUSH
77835: LD_INT 3
77837: ARRAY
77838: PPUSH
77839: LD_VAR 0 2
77843: PUSH
77844: LD_INT 4
77846: ARRAY
77847: PPUSH
77848: CALL_OW 449
77852: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77853: LD_ADDR_VAR 0 3
77857: PUSH
77858: LD_VAR 0 5
77862: PPUSH
77863: LD_INT 1
77865: PPUSH
77866: CALL_OW 275
77870: PUSH
77871: LD_VAR 0 4
77875: PUSH
77876: LD_INT 1
77878: ARRAY
77879: GREATEREQUAL
77880: PUSH
77881: LD_VAR 0 5
77885: PPUSH
77886: LD_INT 2
77888: PPUSH
77889: CALL_OW 275
77893: PUSH
77894: LD_VAR 0 4
77898: PUSH
77899: LD_INT 2
77901: ARRAY
77902: GREATEREQUAL
77903: AND
77904: PUSH
77905: LD_VAR 0 5
77909: PPUSH
77910: LD_INT 3
77912: PPUSH
77913: CALL_OW 275
77917: PUSH
77918: LD_VAR 0 4
77922: PUSH
77923: LD_INT 3
77925: ARRAY
77926: GREATEREQUAL
77927: AND
77928: ST_TO_ADDR
// end ;
77929: LD_VAR 0 3
77933: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77934: LD_INT 0
77936: PPUSH
77937: PPUSH
77938: PPUSH
77939: PPUSH
// pom := GetBase ( building ) ;
77940: LD_ADDR_VAR 0 3
77944: PUSH
77945: LD_VAR 0 1
77949: PPUSH
77950: CALL_OW 274
77954: ST_TO_ADDR
// if not pom then
77955: LD_VAR 0 3
77959: NOT
77960: IFFALSE 77964
// exit ;
77962: GO 78134
// btype := GetBType ( building ) ;
77964: LD_ADDR_VAR 0 5
77968: PUSH
77969: LD_VAR 0 1
77973: PPUSH
77974: CALL_OW 266
77978: ST_TO_ADDR
// if btype = b_armoury then
77979: LD_VAR 0 5
77983: PUSH
77984: LD_INT 4
77986: EQUAL
77987: IFFALSE 77997
// btype := b_barracks ;
77989: LD_ADDR_VAR 0 5
77993: PUSH
77994: LD_INT 5
77996: ST_TO_ADDR
// if btype = b_depot then
77997: LD_VAR 0 5
78001: PUSH
78002: LD_INT 0
78004: EQUAL
78005: IFFALSE 78015
// btype := b_warehouse ;
78007: LD_ADDR_VAR 0 5
78011: PUSH
78012: LD_INT 1
78014: ST_TO_ADDR
// if btype = b_workshop then
78015: LD_VAR 0 5
78019: PUSH
78020: LD_INT 2
78022: EQUAL
78023: IFFALSE 78033
// btype := b_factory ;
78025: LD_ADDR_VAR 0 5
78029: PUSH
78030: LD_INT 3
78032: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78033: LD_ADDR_VAR 0 4
78037: PUSH
78038: LD_VAR 0 5
78042: PPUSH
78043: LD_VAR 0 1
78047: PPUSH
78048: CALL_OW 248
78052: PPUSH
78053: CALL_OW 450
78057: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78058: LD_ADDR_VAR 0 2
78062: PUSH
78063: LD_VAR 0 3
78067: PPUSH
78068: LD_INT 1
78070: PPUSH
78071: CALL_OW 275
78075: PUSH
78076: LD_VAR 0 4
78080: PUSH
78081: LD_INT 1
78083: ARRAY
78084: GREATEREQUAL
78085: PUSH
78086: LD_VAR 0 3
78090: PPUSH
78091: LD_INT 2
78093: PPUSH
78094: CALL_OW 275
78098: PUSH
78099: LD_VAR 0 4
78103: PUSH
78104: LD_INT 2
78106: ARRAY
78107: GREATEREQUAL
78108: AND
78109: PUSH
78110: LD_VAR 0 3
78114: PPUSH
78115: LD_INT 3
78117: PPUSH
78118: CALL_OW 275
78122: PUSH
78123: LD_VAR 0 4
78127: PUSH
78128: LD_INT 3
78130: ARRAY
78131: GREATEREQUAL
78132: AND
78133: ST_TO_ADDR
// end ;
78134: LD_VAR 0 2
78138: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78139: LD_INT 0
78141: PPUSH
78142: PPUSH
78143: PPUSH
// pom := GetBase ( building ) ;
78144: LD_ADDR_VAR 0 4
78148: PUSH
78149: LD_VAR 0 1
78153: PPUSH
78154: CALL_OW 274
78158: ST_TO_ADDR
// if not pom then
78159: LD_VAR 0 4
78163: NOT
78164: IFFALSE 78168
// exit ;
78166: GO 78269
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78168: LD_ADDR_VAR 0 5
78172: PUSH
78173: LD_VAR 0 2
78177: PPUSH
78178: LD_VAR 0 1
78182: PPUSH
78183: CALL_OW 248
78187: PPUSH
78188: CALL_OW 450
78192: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78193: LD_ADDR_VAR 0 3
78197: PUSH
78198: LD_VAR 0 4
78202: PPUSH
78203: LD_INT 1
78205: PPUSH
78206: CALL_OW 275
78210: PUSH
78211: LD_VAR 0 5
78215: PUSH
78216: LD_INT 1
78218: ARRAY
78219: GREATEREQUAL
78220: PUSH
78221: LD_VAR 0 4
78225: PPUSH
78226: LD_INT 2
78228: PPUSH
78229: CALL_OW 275
78233: PUSH
78234: LD_VAR 0 5
78238: PUSH
78239: LD_INT 2
78241: ARRAY
78242: GREATEREQUAL
78243: AND
78244: PUSH
78245: LD_VAR 0 4
78249: PPUSH
78250: LD_INT 3
78252: PPUSH
78253: CALL_OW 275
78257: PUSH
78258: LD_VAR 0 5
78262: PUSH
78263: LD_INT 3
78265: ARRAY
78266: GREATEREQUAL
78267: AND
78268: ST_TO_ADDR
// end ;
78269: LD_VAR 0 3
78273: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78274: LD_INT 0
78276: PPUSH
78277: PPUSH
78278: PPUSH
78279: PPUSH
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
// result := false ;
78286: LD_ADDR_VAR 0 6
78290: PUSH
78291: LD_INT 0
78293: ST_TO_ADDR
// if not base or not btype or not x or not y then
78294: LD_VAR 0 1
78298: NOT
78299: PUSH
78300: LD_VAR 0 2
78304: NOT
78305: OR
78306: PUSH
78307: LD_VAR 0 3
78311: NOT
78312: OR
78313: PUSH
78314: LD_VAR 0 4
78318: NOT
78319: OR
78320: IFFALSE 78324
// exit ;
78322: GO 78933
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78324: LD_ADDR_VAR 0 12
78328: PUSH
78329: LD_VAR 0 2
78333: PPUSH
78334: LD_VAR 0 3
78338: PPUSH
78339: LD_VAR 0 4
78343: PPUSH
78344: LD_VAR 0 5
78348: PPUSH
78349: LD_VAR 0 1
78353: PUSH
78354: LD_INT 1
78356: ARRAY
78357: PPUSH
78358: CALL_OW 248
78362: PPUSH
78363: LD_INT 0
78365: PPUSH
78366: CALL 79770 0 6
78370: ST_TO_ADDR
// if not hexes then
78371: LD_VAR 0 12
78375: NOT
78376: IFFALSE 78380
// exit ;
78378: GO 78933
// for i = 1 to hexes do
78380: LD_ADDR_VAR 0 7
78384: PUSH
78385: DOUBLE
78386: LD_INT 1
78388: DEC
78389: ST_TO_ADDR
78390: LD_VAR 0 12
78394: PUSH
78395: FOR_TO
78396: IFFALSE 78931
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78398: LD_ADDR_VAR 0 11
78402: PUSH
78403: LD_VAR 0 12
78407: PUSH
78408: LD_VAR 0 7
78412: ARRAY
78413: PUSH
78414: LD_INT 1
78416: ARRAY
78417: PPUSH
78418: LD_VAR 0 12
78422: PUSH
78423: LD_VAR 0 7
78427: ARRAY
78428: PUSH
78429: LD_INT 2
78431: ARRAY
78432: PPUSH
78433: CALL_OW 428
78437: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78438: LD_VAR 0 12
78442: PUSH
78443: LD_VAR 0 7
78447: ARRAY
78448: PUSH
78449: LD_INT 1
78451: ARRAY
78452: PPUSH
78453: LD_VAR 0 12
78457: PUSH
78458: LD_VAR 0 7
78462: ARRAY
78463: PUSH
78464: LD_INT 2
78466: ARRAY
78467: PPUSH
78468: CALL_OW 351
78472: PUSH
78473: LD_VAR 0 12
78477: PUSH
78478: LD_VAR 0 7
78482: ARRAY
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: PPUSH
78488: LD_VAR 0 12
78492: PUSH
78493: LD_VAR 0 7
78497: ARRAY
78498: PUSH
78499: LD_INT 2
78501: ARRAY
78502: PPUSH
78503: CALL_OW 488
78507: NOT
78508: OR
78509: PUSH
78510: LD_VAR 0 11
78514: PPUSH
78515: CALL_OW 247
78519: PUSH
78520: LD_INT 3
78522: EQUAL
78523: OR
78524: IFFALSE 78530
// exit ;
78526: POP
78527: POP
78528: GO 78933
// if not tmp or not tmp in base then
78530: LD_VAR 0 11
78534: NOT
78535: PUSH
78536: LD_VAR 0 11
78540: PUSH
78541: LD_VAR 0 1
78545: IN
78546: NOT
78547: OR
78548: IFFALSE 78552
// continue ;
78550: GO 78395
// result := true ;
78552: LD_ADDR_VAR 0 6
78556: PUSH
78557: LD_INT 1
78559: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78560: LD_ADDR_VAR 0 15
78564: PUSH
78565: LD_VAR 0 1
78569: PPUSH
78570: LD_INT 22
78572: PUSH
78573: LD_VAR 0 11
78577: PPUSH
78578: CALL_OW 255
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 2
78589: PUSH
78590: LD_INT 30
78592: PUSH
78593: LD_INT 0
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 30
78602: PUSH
78603: LD_INT 1
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: LIST
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PPUSH
78619: CALL_OW 72
78623: ST_TO_ADDR
// if dep then
78624: LD_VAR 0 15
78628: IFFALSE 78764
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78630: LD_ADDR_VAR 0 14
78634: PUSH
78635: LD_VAR 0 15
78639: PUSH
78640: LD_INT 1
78642: ARRAY
78643: PPUSH
78644: CALL_OW 250
78648: PPUSH
78649: LD_VAR 0 15
78653: PUSH
78654: LD_INT 1
78656: ARRAY
78657: PPUSH
78658: CALL_OW 254
78662: PPUSH
78663: LD_INT 5
78665: PPUSH
78666: CALL_OW 272
78670: PUSH
78671: LD_VAR 0 15
78675: PUSH
78676: LD_INT 1
78678: ARRAY
78679: PPUSH
78680: CALL_OW 251
78684: PPUSH
78685: LD_VAR 0 15
78689: PUSH
78690: LD_INT 1
78692: ARRAY
78693: PPUSH
78694: CALL_OW 254
78698: PPUSH
78699: LD_INT 5
78701: PPUSH
78702: CALL_OW 273
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78711: LD_VAR 0 14
78715: PUSH
78716: LD_INT 1
78718: ARRAY
78719: PPUSH
78720: LD_VAR 0 14
78724: PUSH
78725: LD_INT 2
78727: ARRAY
78728: PPUSH
78729: CALL_OW 488
78733: IFFALSE 78764
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78735: LD_VAR 0 11
78739: PPUSH
78740: LD_VAR 0 14
78744: PUSH
78745: LD_INT 1
78747: ARRAY
78748: PPUSH
78749: LD_VAR 0 14
78753: PUSH
78754: LD_INT 2
78756: ARRAY
78757: PPUSH
78758: CALL_OW 111
// continue ;
78762: GO 78395
// end ; end ; r := GetDir ( tmp ) ;
78764: LD_ADDR_VAR 0 13
78768: PUSH
78769: LD_VAR 0 11
78773: PPUSH
78774: CALL_OW 254
78778: ST_TO_ADDR
// if r = 5 then
78779: LD_VAR 0 13
78783: PUSH
78784: LD_INT 5
78786: EQUAL
78787: IFFALSE 78797
// r := 0 ;
78789: LD_ADDR_VAR 0 13
78793: PUSH
78794: LD_INT 0
78796: ST_TO_ADDR
// for j = r to 5 do
78797: LD_ADDR_VAR 0 8
78801: PUSH
78802: DOUBLE
78803: LD_VAR 0 13
78807: DEC
78808: ST_TO_ADDR
78809: LD_INT 5
78811: PUSH
78812: FOR_TO
78813: IFFALSE 78927
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78815: LD_ADDR_VAR 0 9
78819: PUSH
78820: LD_VAR 0 11
78824: PPUSH
78825: CALL_OW 250
78829: PPUSH
78830: LD_VAR 0 8
78834: PPUSH
78835: LD_INT 2
78837: PPUSH
78838: CALL_OW 272
78842: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78843: LD_ADDR_VAR 0 10
78847: PUSH
78848: LD_VAR 0 11
78852: PPUSH
78853: CALL_OW 251
78857: PPUSH
78858: LD_VAR 0 8
78862: PPUSH
78863: LD_INT 2
78865: PPUSH
78866: CALL_OW 273
78870: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78871: LD_VAR 0 9
78875: PPUSH
78876: LD_VAR 0 10
78880: PPUSH
78881: CALL_OW 488
78885: PUSH
78886: LD_VAR 0 9
78890: PPUSH
78891: LD_VAR 0 10
78895: PPUSH
78896: CALL_OW 428
78900: NOT
78901: AND
78902: IFFALSE 78925
// begin ComMoveXY ( tmp , _x , _y ) ;
78904: LD_VAR 0 11
78908: PPUSH
78909: LD_VAR 0 9
78913: PPUSH
78914: LD_VAR 0 10
78918: PPUSH
78919: CALL_OW 111
// break ;
78923: GO 78927
// end ; end ;
78925: GO 78812
78927: POP
78928: POP
// end ;
78929: GO 78395
78931: POP
78932: POP
// end ;
78933: LD_VAR 0 6
78937: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78938: LD_INT 0
78940: PPUSH
78941: PPUSH
78942: PPUSH
78943: PPUSH
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
// result := false ;
78950: LD_ADDR_VAR 0 6
78954: PUSH
78955: LD_INT 0
78957: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78958: LD_VAR 0 1
78962: NOT
78963: PUSH
78964: LD_VAR 0 1
78968: PPUSH
78969: CALL_OW 266
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: IN
78984: NOT
78985: OR
78986: PUSH
78987: LD_VAR 0 2
78991: NOT
78992: OR
78993: PUSH
78994: LD_VAR 0 5
78998: PUSH
78999: LD_INT 0
79001: PUSH
79002: LD_INT 1
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: LD_INT 3
79010: PUSH
79011: LD_INT 4
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: IN
79025: NOT
79026: OR
79027: PUSH
79028: LD_VAR 0 3
79032: PPUSH
79033: LD_VAR 0 4
79037: PPUSH
79038: CALL_OW 488
79042: NOT
79043: OR
79044: IFFALSE 79048
// exit ;
79046: GO 79765
// pom := GetBase ( depot ) ;
79048: LD_ADDR_VAR 0 10
79052: PUSH
79053: LD_VAR 0 1
79057: PPUSH
79058: CALL_OW 274
79062: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79063: LD_ADDR_VAR 0 11
79067: PUSH
79068: LD_VAR 0 2
79072: PPUSH
79073: LD_VAR 0 1
79077: PPUSH
79078: CALL_OW 248
79082: PPUSH
79083: CALL_OW 450
79087: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79088: LD_VAR 0 10
79092: PPUSH
79093: LD_INT 1
79095: PPUSH
79096: CALL_OW 275
79100: PUSH
79101: LD_VAR 0 11
79105: PUSH
79106: LD_INT 1
79108: ARRAY
79109: GREATEREQUAL
79110: PUSH
79111: LD_VAR 0 10
79115: PPUSH
79116: LD_INT 2
79118: PPUSH
79119: CALL_OW 275
79123: PUSH
79124: LD_VAR 0 11
79128: PUSH
79129: LD_INT 2
79131: ARRAY
79132: GREATEREQUAL
79133: AND
79134: PUSH
79135: LD_VAR 0 10
79139: PPUSH
79140: LD_INT 3
79142: PPUSH
79143: CALL_OW 275
79147: PUSH
79148: LD_VAR 0 11
79152: PUSH
79153: LD_INT 3
79155: ARRAY
79156: GREATEREQUAL
79157: AND
79158: NOT
79159: IFFALSE 79163
// exit ;
79161: GO 79765
// if GetBType ( depot ) = b_depot then
79163: LD_VAR 0 1
79167: PPUSH
79168: CALL_OW 266
79172: PUSH
79173: LD_INT 0
79175: EQUAL
79176: IFFALSE 79188
// dist := 28 else
79178: LD_ADDR_VAR 0 14
79182: PUSH
79183: LD_INT 28
79185: ST_TO_ADDR
79186: GO 79196
// dist := 36 ;
79188: LD_ADDR_VAR 0 14
79192: PUSH
79193: LD_INT 36
79195: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79196: LD_VAR 0 1
79200: PPUSH
79201: LD_VAR 0 3
79205: PPUSH
79206: LD_VAR 0 4
79210: PPUSH
79211: CALL_OW 297
79215: PUSH
79216: LD_VAR 0 14
79220: GREATER
79221: IFFALSE 79225
// exit ;
79223: GO 79765
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79225: LD_ADDR_VAR 0 12
79229: PUSH
79230: LD_VAR 0 2
79234: PPUSH
79235: LD_VAR 0 3
79239: PPUSH
79240: LD_VAR 0 4
79244: PPUSH
79245: LD_VAR 0 5
79249: PPUSH
79250: LD_VAR 0 1
79254: PPUSH
79255: CALL_OW 248
79259: PPUSH
79260: LD_INT 0
79262: PPUSH
79263: CALL 79770 0 6
79267: ST_TO_ADDR
// if not hexes then
79268: LD_VAR 0 12
79272: NOT
79273: IFFALSE 79277
// exit ;
79275: GO 79765
// hex := GetHexInfo ( x , y ) ;
79277: LD_ADDR_VAR 0 15
79281: PUSH
79282: LD_VAR 0 3
79286: PPUSH
79287: LD_VAR 0 4
79291: PPUSH
79292: CALL_OW 546
79296: ST_TO_ADDR
// if hex [ 1 ] then
79297: LD_VAR 0 15
79301: PUSH
79302: LD_INT 1
79304: ARRAY
79305: IFFALSE 79309
// exit ;
79307: GO 79765
// height := hex [ 2 ] ;
79309: LD_ADDR_VAR 0 13
79313: PUSH
79314: LD_VAR 0 15
79318: PUSH
79319: LD_INT 2
79321: ARRAY
79322: ST_TO_ADDR
// for i = 1 to hexes do
79323: LD_ADDR_VAR 0 7
79327: PUSH
79328: DOUBLE
79329: LD_INT 1
79331: DEC
79332: ST_TO_ADDR
79333: LD_VAR 0 12
79337: PUSH
79338: FOR_TO
79339: IFFALSE 79669
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79341: LD_VAR 0 12
79345: PUSH
79346: LD_VAR 0 7
79350: ARRAY
79351: PUSH
79352: LD_INT 1
79354: ARRAY
79355: PPUSH
79356: LD_VAR 0 12
79360: PUSH
79361: LD_VAR 0 7
79365: ARRAY
79366: PUSH
79367: LD_INT 2
79369: ARRAY
79370: PPUSH
79371: CALL_OW 488
79375: NOT
79376: PUSH
79377: LD_VAR 0 12
79381: PUSH
79382: LD_VAR 0 7
79386: ARRAY
79387: PUSH
79388: LD_INT 1
79390: ARRAY
79391: PPUSH
79392: LD_VAR 0 12
79396: PUSH
79397: LD_VAR 0 7
79401: ARRAY
79402: PUSH
79403: LD_INT 2
79405: ARRAY
79406: PPUSH
79407: CALL_OW 428
79411: PUSH
79412: LD_INT 0
79414: GREATER
79415: OR
79416: PUSH
79417: LD_VAR 0 12
79421: PUSH
79422: LD_VAR 0 7
79426: ARRAY
79427: PUSH
79428: LD_INT 1
79430: ARRAY
79431: PPUSH
79432: LD_VAR 0 12
79436: PUSH
79437: LD_VAR 0 7
79441: ARRAY
79442: PUSH
79443: LD_INT 2
79445: ARRAY
79446: PPUSH
79447: CALL_OW 351
79451: OR
79452: IFFALSE 79458
// exit ;
79454: POP
79455: POP
79456: GO 79765
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79458: LD_ADDR_VAR 0 8
79462: PUSH
79463: LD_VAR 0 12
79467: PUSH
79468: LD_VAR 0 7
79472: ARRAY
79473: PUSH
79474: LD_INT 1
79476: ARRAY
79477: PPUSH
79478: LD_VAR 0 12
79482: PUSH
79483: LD_VAR 0 7
79487: ARRAY
79488: PUSH
79489: LD_INT 2
79491: ARRAY
79492: PPUSH
79493: CALL_OW 546
79497: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79498: LD_VAR 0 8
79502: PUSH
79503: LD_INT 1
79505: ARRAY
79506: PUSH
79507: LD_VAR 0 8
79511: PUSH
79512: LD_INT 2
79514: ARRAY
79515: PUSH
79516: LD_VAR 0 13
79520: PUSH
79521: LD_INT 2
79523: PLUS
79524: GREATER
79525: OR
79526: PUSH
79527: LD_VAR 0 8
79531: PUSH
79532: LD_INT 2
79534: ARRAY
79535: PUSH
79536: LD_VAR 0 13
79540: PUSH
79541: LD_INT 2
79543: MINUS
79544: LESS
79545: OR
79546: PUSH
79547: LD_VAR 0 8
79551: PUSH
79552: LD_INT 3
79554: ARRAY
79555: PUSH
79556: LD_INT 0
79558: PUSH
79559: LD_INT 8
79561: PUSH
79562: LD_INT 9
79564: PUSH
79565: LD_INT 10
79567: PUSH
79568: LD_INT 11
79570: PUSH
79571: LD_INT 12
79573: PUSH
79574: LD_INT 13
79576: PUSH
79577: LD_INT 16
79579: PUSH
79580: LD_INT 17
79582: PUSH
79583: LD_INT 18
79585: PUSH
79586: LD_INT 19
79588: PUSH
79589: LD_INT 20
79591: PUSH
79592: LD_INT 21
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: IN
79610: NOT
79611: OR
79612: PUSH
79613: LD_VAR 0 8
79617: PUSH
79618: LD_INT 5
79620: ARRAY
79621: NOT
79622: OR
79623: PUSH
79624: LD_VAR 0 8
79628: PUSH
79629: LD_INT 6
79631: ARRAY
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: LD_INT 2
79638: PUSH
79639: LD_INT 7
79641: PUSH
79642: LD_INT 9
79644: PUSH
79645: LD_INT 10
79647: PUSH
79648: LD_INT 11
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: IN
79659: NOT
79660: OR
79661: IFFALSE 79667
// exit ;
79663: POP
79664: POP
79665: GO 79765
// end ;
79667: GO 79338
79669: POP
79670: POP
// side := GetSide ( depot ) ;
79671: LD_ADDR_VAR 0 9
79675: PUSH
79676: LD_VAR 0 1
79680: PPUSH
79681: CALL_OW 255
79685: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79686: LD_VAR 0 9
79690: PPUSH
79691: LD_VAR 0 3
79695: PPUSH
79696: LD_VAR 0 4
79700: PPUSH
79701: LD_INT 20
79703: PPUSH
79704: CALL 72419 0 4
79708: PUSH
79709: LD_INT 4
79711: ARRAY
79712: IFFALSE 79716
// exit ;
79714: GO 79765
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79716: LD_VAR 0 2
79720: PUSH
79721: LD_INT 29
79723: PUSH
79724: LD_INT 30
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: IN
79731: PUSH
79732: LD_VAR 0 3
79736: PPUSH
79737: LD_VAR 0 4
79741: PPUSH
79742: LD_VAR 0 9
79746: PPUSH
79747: CALL_OW 440
79751: NOT
79752: AND
79753: IFFALSE 79757
// exit ;
79755: GO 79765
// result := true ;
79757: LD_ADDR_VAR 0 6
79761: PUSH
79762: LD_INT 1
79764: ST_TO_ADDR
// end ;
79765: LD_VAR 0 6
79769: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79770: LD_INT 0
79772: PPUSH
79773: PPUSH
79774: PPUSH
79775: PPUSH
79776: PPUSH
79777: PPUSH
79778: PPUSH
79779: PPUSH
79780: PPUSH
79781: PPUSH
79782: PPUSH
79783: PPUSH
79784: PPUSH
79785: PPUSH
79786: PPUSH
79787: PPUSH
79788: PPUSH
79789: PPUSH
79790: PPUSH
79791: PPUSH
79792: PPUSH
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
79805: PPUSH
79806: PPUSH
79807: PPUSH
79808: PPUSH
79809: PPUSH
79810: PPUSH
79811: PPUSH
79812: PPUSH
79813: PPUSH
79814: PPUSH
79815: PPUSH
79816: PPUSH
79817: PPUSH
79818: PPUSH
79819: PPUSH
79820: PPUSH
79821: PPUSH
79822: PPUSH
79823: PPUSH
79824: PPUSH
79825: PPUSH
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
// result = [ ] ;
79830: LD_ADDR_VAR 0 7
79834: PUSH
79835: EMPTY
79836: ST_TO_ADDR
// temp_list = [ ] ;
79837: LD_ADDR_VAR 0 9
79841: PUSH
79842: EMPTY
79843: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79844: LD_VAR 0 4
79848: PUSH
79849: LD_INT 0
79851: PUSH
79852: LD_INT 1
79854: PUSH
79855: LD_INT 2
79857: PUSH
79858: LD_INT 3
79860: PUSH
79861: LD_INT 4
79863: PUSH
79864: LD_INT 5
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: IN
79875: NOT
79876: PUSH
79877: LD_VAR 0 1
79881: PUSH
79882: LD_INT 0
79884: PUSH
79885: LD_INT 1
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: IN
79892: PUSH
79893: LD_VAR 0 5
79897: PUSH
79898: LD_INT 1
79900: PUSH
79901: LD_INT 2
79903: PUSH
79904: LD_INT 3
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: LIST
79911: IN
79912: NOT
79913: AND
79914: OR
79915: IFFALSE 79919
// exit ;
79917: GO 98310
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79919: LD_VAR 0 1
79923: PUSH
79924: LD_INT 6
79926: PUSH
79927: LD_INT 7
79929: PUSH
79930: LD_INT 8
79932: PUSH
79933: LD_INT 13
79935: PUSH
79936: LD_INT 12
79938: PUSH
79939: LD_INT 15
79941: PUSH
79942: LD_INT 11
79944: PUSH
79945: LD_INT 14
79947: PUSH
79948: LD_INT 10
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: IN
79962: IFFALSE 79972
// btype = b_lab ;
79964: LD_ADDR_VAR 0 1
79968: PUSH
79969: LD_INT 6
79971: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79972: LD_VAR 0 6
79976: PUSH
79977: LD_INT 0
79979: PUSH
79980: LD_INT 1
79982: PUSH
79983: LD_INT 2
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: LIST
79990: IN
79991: NOT
79992: PUSH
79993: LD_VAR 0 1
79997: PUSH
79998: LD_INT 0
80000: PUSH
80001: LD_INT 1
80003: PUSH
80004: LD_INT 2
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 6
80012: PUSH
80013: LD_INT 36
80015: PUSH
80016: LD_INT 4
80018: PUSH
80019: LD_INT 5
80021: PUSH
80022: LD_INT 31
80024: PUSH
80025: LD_INT 32
80027: PUSH
80028: LD_INT 33
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: IN
80044: NOT
80045: PUSH
80046: LD_VAR 0 6
80050: PUSH
80051: LD_INT 1
80053: EQUAL
80054: AND
80055: OR
80056: PUSH
80057: LD_VAR 0 1
80061: PUSH
80062: LD_INT 2
80064: PUSH
80065: LD_INT 3
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: IN
80072: NOT
80073: PUSH
80074: LD_VAR 0 6
80078: PUSH
80079: LD_INT 2
80081: EQUAL
80082: AND
80083: OR
80084: IFFALSE 80094
// mode = 0 ;
80086: LD_ADDR_VAR 0 6
80090: PUSH
80091: LD_INT 0
80093: ST_TO_ADDR
// case mode of 0 :
80094: LD_VAR 0 6
80098: PUSH
80099: LD_INT 0
80101: DOUBLE
80102: EQUAL
80103: IFTRUE 80107
80105: GO 91560
80107: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80108: LD_ADDR_VAR 0 11
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: LD_INT 1
80128: NEG
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 1
80136: PUSH
80137: LD_INT 0
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 1
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 0
80156: PUSH
80157: LD_INT 1
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 1
80166: NEG
80167: PUSH
80168: LD_INT 0
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: LD_INT 1
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: LD_INT 2
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 0
80201: PUSH
80202: LD_INT 2
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 2
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 0
80233: PUSH
80234: LD_INT 2
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 1
80243: NEG
80244: PUSH
80245: LD_INT 1
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 3
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 0
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: NEG
80275: PUSH
80276: LD_INT 2
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80301: LD_ADDR_VAR 0 12
80305: PUSH
80306: LD_INT 0
80308: PUSH
80309: LD_INT 0
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: LD_INT 1
80321: NEG
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 1
80329: PUSH
80330: LD_INT 0
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 1
80339: PUSH
80340: LD_INT 1
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 0
80349: PUSH
80350: LD_INT 1
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: NEG
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 1
80370: NEG
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 1
80382: PUSH
80383: LD_INT 1
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 2
80393: PUSH
80394: LD_INT 0
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 1
80413: NEG
80414: PUSH
80415: LD_INT 1
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: LD_INT 2
80424: NEG
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 2
80435: NEG
80436: PUSH
80437: LD_INT 1
80439: NEG
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 2
80447: NEG
80448: PUSH
80449: LD_INT 1
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 3
80458: NEG
80459: PUSH
80460: LD_INT 0
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 3
80469: NEG
80470: PUSH
80471: LD_INT 1
80473: NEG
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80497: LD_ADDR_VAR 0 13
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: LD_INT 1
80517: NEG
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: LD_INT 0
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 1
80535: PUSH
80536: LD_INT 1
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: LD_INT 1
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: NEG
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 1
80566: NEG
80567: PUSH
80568: LD_INT 1
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 1
80578: NEG
80579: PUSH
80580: LD_INT 2
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 2
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 2
80600: PUSH
80601: LD_INT 2
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 1
80610: PUSH
80611: LD_INT 2
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 2
80620: NEG
80621: PUSH
80622: LD_INT 1
80624: NEG
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 2
80632: NEG
80633: PUSH
80634: LD_INT 2
80636: NEG
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 2
80644: NEG
80645: PUSH
80646: LD_INT 3
80648: NEG
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 3
80656: NEG
80657: PUSH
80658: LD_INT 2
80660: NEG
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 3
80668: NEG
80669: PUSH
80670: LD_INT 3
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80696: LD_ADDR_VAR 0 14
80700: PUSH
80701: LD_INT 0
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 0
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: LD_INT 0
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: LD_INT 1
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 0
80744: PUSH
80745: LD_INT 1
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 1
80754: NEG
80755: PUSH
80756: LD_INT 0
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 1
80765: NEG
80766: PUSH
80767: LD_INT 1
80769: NEG
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 1
80777: NEG
80778: PUSH
80779: LD_INT 2
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 2
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 1
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: LD_INT 2
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 0
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 1
80831: NEG
80832: PUSH
80833: LD_INT 1
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: NEG
80843: PUSH
80844: LD_INT 3
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 0
80854: PUSH
80855: LD_INT 3
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 1
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80892: LD_ADDR_VAR 0 15
80896: PUSH
80897: LD_INT 0
80899: PUSH
80900: LD_INT 0
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 0
80909: PUSH
80910: LD_INT 1
80912: NEG
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 1
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 1
80930: PUSH
80931: LD_INT 1
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 0
80940: PUSH
80941: LD_INT 1
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 1
80950: NEG
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 1
80961: NEG
80962: PUSH
80963: LD_INT 1
80965: NEG
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: LD_INT 1
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 2
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 1
81004: NEG
81005: PUSH
81006: LD_INT 1
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 2
81015: NEG
81016: PUSH
81017: LD_INT 0
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 2
81026: NEG
81027: PUSH
81028: LD_INT 1
81030: NEG
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 2
81038: PUSH
81039: LD_INT 1
81041: NEG
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 3
81049: PUSH
81050: LD_INT 0
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 3
81059: PUSH
81060: LD_INT 1
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81085: LD_ADDR_VAR 0 16
81089: PUSH
81090: LD_INT 0
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: LD_INT 1
81105: NEG
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 1
81113: PUSH
81114: LD_INT 0
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 1
81123: PUSH
81124: LD_INT 1
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 0
81133: PUSH
81134: LD_INT 1
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: LD_INT 0
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 1
81154: NEG
81155: PUSH
81156: LD_INT 1
81158: NEG
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 1
81166: NEG
81167: PUSH
81168: LD_INT 2
81170: NEG
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 2
81178: PUSH
81179: LD_INT 1
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 2
81188: PUSH
81189: LD_INT 2
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 1
81198: PUSH
81199: LD_INT 2
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 2
81208: NEG
81209: PUSH
81210: LD_INT 1
81212: NEG
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 2
81220: NEG
81221: PUSH
81222: LD_INT 2
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 3
81232: PUSH
81233: LD_INT 2
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 3
81242: PUSH
81243: LD_INT 3
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 2
81252: PUSH
81253: LD_INT 3
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81278: LD_ADDR_VAR 0 17
81282: PUSH
81283: LD_INT 0
81285: PUSH
81286: LD_INT 0
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: LD_INT 1
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 1
81306: PUSH
81307: LD_INT 0
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 1
81316: PUSH
81317: LD_INT 1
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: LD_INT 1
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 1
81336: NEG
81337: PUSH
81338: LD_INT 0
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: LD_INT 1
81351: NEG
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 1
81359: NEG
81360: PUSH
81361: LD_INT 2
81363: NEG
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: LD_INT 2
81374: NEG
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 1
81382: PUSH
81383: LD_INT 1
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 2
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: LD_INT 1
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 2
81413: PUSH
81414: LD_INT 2
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 1
81423: PUSH
81424: LD_INT 2
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: LD_INT 2
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: NEG
81444: PUSH
81445: LD_INT 1
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 2
81454: NEG
81455: PUSH
81456: LD_INT 0
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 2
81465: NEG
81466: PUSH
81467: LD_INT 1
81469: NEG
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 2
81477: NEG
81478: PUSH
81479: LD_INT 2
81481: NEG
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81508: LD_ADDR_VAR 0 18
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: LD_INT 0
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: LD_INT 1
81528: NEG
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: LD_INT 0
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 1
81546: PUSH
81547: LD_INT 1
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: LD_INT 1
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 1
81566: NEG
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 1
81581: NEG
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: LD_INT 2
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: LD_INT 2
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 1
81612: PUSH
81613: LD_INT 1
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 2
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 2
81643: PUSH
81644: LD_INT 2
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: LD_INT 2
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 0
81663: PUSH
81664: LD_INT 2
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 1
81673: NEG
81674: PUSH
81675: LD_INT 1
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 2
81684: NEG
81685: PUSH
81686: LD_INT 0
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 2
81695: NEG
81696: PUSH
81697: LD_INT 1
81699: NEG
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 2
81707: NEG
81708: PUSH
81709: LD_INT 2
81711: NEG
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81738: LD_ADDR_VAR 0 19
81742: PUSH
81743: LD_INT 0
81745: PUSH
81746: LD_INT 0
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: LD_INT 1
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: LD_INT 1
81796: NEG
81797: PUSH
81798: LD_INT 0
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 1
81807: NEG
81808: PUSH
81809: LD_INT 1
81811: NEG
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: LD_INT 2
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 2
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 1
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 2
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 1
81883: PUSH
81884: LD_INT 2
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 1
81903: NEG
81904: PUSH
81905: LD_INT 1
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 2
81914: NEG
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 2
81925: NEG
81926: PUSH
81927: LD_INT 1
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: LD_INT 2
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81968: LD_ADDR_VAR 0 20
81972: PUSH
81973: LD_INT 0
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: LD_INT 1
81988: NEG
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 1
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: LD_INT 1
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 1
82037: NEG
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: LD_INT 2
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 2
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 2
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 2
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: LD_INT 2
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: LD_INT 0
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82198: LD_ADDR_VAR 0 21
82202: PUSH
82203: LD_INT 0
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 1
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 1
82256: NEG
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: NEG
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 2
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 2
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 1
82363: NEG
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: NEG
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 2
82401: NEG
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82428: LD_ADDR_VAR 0 22
82432: PUSH
82433: LD_INT 0
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: LD_INT 1
82448: NEG
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: LD_INT 1
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: LD_INT 1
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 1
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: LD_INT 2
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 1
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 2
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: LD_INT 2
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: LD_INT 2
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: LD_INT 2
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 1
82593: NEG
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: NEG
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: NEG
82616: PUSH
82617: LD_INT 1
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 2
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82658: LD_ADDR_VAR 0 23
82662: PUSH
82663: LD_INT 0
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 0
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: NEG
82728: PUSH
82729: LD_INT 1
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 1
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 1
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 2
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: NEG
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 2
82845: NEG
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 2
82857: NEG
82858: PUSH
82859: LD_INT 2
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 2
82869: NEG
82870: PUSH
82871: LD_INT 3
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: LD_INT 3
82885: NEG
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 2
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 2
82904: PUSH
82905: LD_INT 1
82907: NEG
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82938: LD_ADDR_VAR 0 24
82942: PUSH
82943: LD_INT 0
82945: PUSH
82946: LD_INT 0
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 0
82955: PUSH
82956: LD_INT 1
82958: NEG
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 1
82966: PUSH
82967: LD_INT 0
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 1
82976: PUSH
82977: LD_INT 1
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: LD_INT 1
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 0
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 1
83007: NEG
83008: PUSH
83009: LD_INT 1
83011: NEG
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: LD_INT 2
83034: NEG
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 1
83042: PUSH
83043: LD_INT 1
83045: NEG
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 2
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 2
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PUSH
83071: LD_INT 2
83073: PUSH
83074: LD_INT 2
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: PUSH
83081: LD_INT 1
83083: PUSH
83084: LD_INT 2
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: PUSH
83091: LD_INT 0
83093: PUSH
83094: LD_INT 2
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: LD_INT 1
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: LD_INT 2
83114: NEG
83115: PUSH
83116: LD_INT 0
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 2
83125: NEG
83126: PUSH
83127: LD_INT 1
83129: NEG
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 2
83137: NEG
83138: PUSH
83139: LD_INT 2
83141: NEG
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 1
83149: PUSH
83150: LD_INT 2
83152: NEG
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 2
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 3
83171: PUSH
83172: LD_INT 1
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 3
83181: PUSH
83182: LD_INT 2
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83214: LD_ADDR_VAR 0 25
83218: PUSH
83219: LD_INT 0
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: LD_INT 1
83234: NEG
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: PUSH
83240: LD_INT 1
83242: PUSH
83243: LD_INT 0
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: LD_INT 1
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 0
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 1
83272: NEG
83273: PUSH
83274: LD_INT 0
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: LD_INT 1
83287: NEG
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: LD_INT 2
83299: NEG
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: LD_INT 2
83310: NEG
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: LD_INT 1
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 2
83349: PUSH
83350: LD_INT 2
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 1
83359: PUSH
83360: LD_INT 2
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 0
83369: PUSH
83370: LD_INT 2
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: NEG
83380: PUSH
83381: LD_INT 1
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 2
83390: NEG
83391: PUSH
83392: LD_INT 0
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 2
83401: NEG
83402: PUSH
83403: LD_INT 1
83405: NEG
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 2
83413: NEG
83414: PUSH
83415: LD_INT 2
83417: NEG
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 3
83425: PUSH
83426: LD_INT 1
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 3
83435: PUSH
83436: LD_INT 2
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 2
83445: PUSH
83446: LD_INT 3
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 1
83455: PUSH
83456: LD_INT 3
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83488: LD_ADDR_VAR 0 26
83492: PUSH
83493: LD_INT 0
83495: PUSH
83496: LD_INT 0
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: LD_INT 1
83508: NEG
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: LD_INT 0
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 0
83536: PUSH
83537: LD_INT 1
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: PUSH
83544: LD_INT 1
83546: NEG
83547: PUSH
83548: LD_INT 0
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: LD_INT 1
83561: NEG
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 1
83569: NEG
83570: PUSH
83571: LD_INT 2
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: LD_INT 2
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: PUSH
83593: LD_INT 1
83595: NEG
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 2
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 2
83613: PUSH
83614: LD_INT 1
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 2
83623: PUSH
83624: LD_INT 2
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 1
83633: PUSH
83634: LD_INT 2
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: LD_INT 0
83643: PUSH
83644: LD_INT 2
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 1
83653: NEG
83654: PUSH
83655: LD_INT 1
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PUSH
83662: LD_INT 2
83664: NEG
83665: PUSH
83666: LD_INT 0
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: LD_INT 1
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 2
83687: NEG
83688: PUSH
83689: LD_INT 2
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 2
83699: PUSH
83700: LD_INT 3
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: LD_INT 3
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 1
83719: NEG
83720: PUSH
83721: LD_INT 2
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 2
83730: NEG
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83764: LD_ADDR_VAR 0 27
83768: PUSH
83769: LD_INT 0
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 1
83784: NEG
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 1
83802: PUSH
83803: LD_INT 1
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 0
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 1
83822: NEG
83823: PUSH
83824: LD_INT 0
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 1
83833: NEG
83834: PUSH
83835: LD_INT 1
83837: NEG
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 1
83845: NEG
83846: PUSH
83847: LD_INT 2
83849: NEG
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: LD_INT 2
83860: NEG
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 1
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 2
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 2
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 2
83899: PUSH
83900: LD_INT 2
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 1
83909: PUSH
83910: LD_INT 2
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: LD_INT 2
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 1
83929: NEG
83930: PUSH
83931: LD_INT 1
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 2
83940: NEG
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: LD_INT 1
83955: NEG
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 2
83963: NEG
83964: PUSH
83965: LD_INT 2
83967: NEG
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 1
83975: NEG
83976: PUSH
83977: LD_INT 2
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 2
83986: NEG
83987: PUSH
83988: LD_INT 1
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 3
83997: NEG
83998: PUSH
83999: LD_INT 1
84001: NEG
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 3
84009: NEG
84010: PUSH
84011: LD_INT 2
84013: NEG
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84044: LD_ADDR_VAR 0 28
84048: PUSH
84049: LD_INT 0
84051: PUSH
84052: LD_INT 0
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: LD_INT 1
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: LD_INT 0
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: LD_INT 1
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 0
84092: PUSH
84093: LD_INT 1
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 1
84102: NEG
84103: PUSH
84104: LD_INT 0
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 1
84113: NEG
84114: PUSH
84115: LD_INT 1
84117: NEG
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: LD_INT 2
84129: NEG
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 0
84137: PUSH
84138: LD_INT 2
84140: NEG
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 1
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 2
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 2
84169: PUSH
84170: LD_INT 1
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 2
84179: PUSH
84180: LD_INT 2
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: LD_INT 2
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 0
84199: PUSH
84200: LD_INT 2
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: PUSH
84207: LD_INT 1
84209: NEG
84210: PUSH
84211: LD_INT 1
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: LD_INT 2
84220: NEG
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 2
84231: NEG
84232: PUSH
84233: LD_INT 1
84235: NEG
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 2
84243: NEG
84244: PUSH
84245: LD_INT 2
84247: NEG
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 2
84255: NEG
84256: PUSH
84257: LD_INT 3
84259: NEG
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: LD_INT 1
84267: NEG
84268: PUSH
84269: LD_INT 3
84271: NEG
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 3
84279: NEG
84280: PUSH
84281: LD_INT 1
84283: NEG
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 3
84291: NEG
84292: PUSH
84293: LD_INT 2
84295: NEG
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84326: LD_ADDR_VAR 0 29
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: LD_INT 0
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 1
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: LD_INT 0
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 1
84395: NEG
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: NEG
84408: PUSH
84409: LD_INT 2
84411: NEG
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: LD_INT 2
84422: NEG
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 1
84430: PUSH
84431: LD_INT 1
84433: NEG
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: LD_INT 1
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 1
84461: PUSH
84462: LD_INT 2
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 0
84471: PUSH
84472: LD_INT 2
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: LD_INT 1
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 2
84492: NEG
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 2
84504: NEG
84505: PUSH
84506: LD_INT 2
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 2
84516: NEG
84517: PUSH
84518: LD_INT 3
84520: NEG
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 2
84528: PUSH
84529: LD_INT 1
84531: NEG
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 3
84539: PUSH
84540: LD_INT 1
84542: PUSH
84543: EMPTY
84544: LIST
84545: LIST
84546: PUSH
84547: LD_INT 1
84549: PUSH
84550: LD_INT 3
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: PUSH
84557: LD_INT 1
84559: NEG
84560: PUSH
84561: LD_INT 2
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 3
84570: NEG
84571: PUSH
84572: LD_INT 2
84574: NEG
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84605: LD_ADDR_VAR 0 30
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: LD_INT 1
84625: NEG
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 1
84633: PUSH
84634: LD_INT 0
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 1
84643: PUSH
84644: LD_INT 1
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 0
84653: PUSH
84654: LD_INT 1
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: NEG
84664: PUSH
84665: LD_INT 0
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 1
84674: NEG
84675: PUSH
84676: LD_INT 1
84678: NEG
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 1
84686: NEG
84687: PUSH
84688: LD_INT 2
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: LD_INT 2
84701: NEG
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: LD_INT 1
84712: NEG
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: LD_INT 2
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 2
84730: PUSH
84731: LD_INT 1
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: LD_INT 2
84740: PUSH
84741: LD_INT 2
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: LD_INT 2
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: LD_INT 1
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 2
84771: NEG
84772: PUSH
84773: LD_INT 0
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 2
84782: NEG
84783: PUSH
84784: LD_INT 1
84786: NEG
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: LD_INT 3
84798: NEG
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 2
84809: NEG
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 3
84817: PUSH
84818: LD_INT 2
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: PUSH
84828: LD_INT 3
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 2
84837: NEG
84838: PUSH
84839: LD_INT 1
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 3
84848: NEG
84849: PUSH
84850: LD_INT 1
84852: NEG
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84883: LD_ADDR_VAR 0 31
84887: PUSH
84888: LD_INT 0
84890: PUSH
84891: LD_INT 0
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: PUSH
84898: LD_INT 0
84900: PUSH
84901: LD_INT 1
84903: NEG
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 1
84911: PUSH
84912: LD_INT 0
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 1
84921: PUSH
84922: LD_INT 1
84924: PUSH
84925: EMPTY
84926: LIST
84927: LIST
84928: PUSH
84929: LD_INT 0
84931: PUSH
84932: LD_INT 1
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: NEG
84942: PUSH
84943: LD_INT 0
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 1
84952: NEG
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 1
84964: NEG
84965: PUSH
84966: LD_INT 2
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 1
84976: PUSH
84977: LD_INT 1
84979: NEG
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: LD_INT 0
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: LD_INT 1
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: LD_INT 2
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 1
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 0
85027: PUSH
85028: LD_INT 2
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 1
85037: NEG
85038: PUSH
85039: LD_INT 1
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 2
85048: NEG
85049: PUSH
85050: LD_INT 1
85052: NEG
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: LD_INT 2
85060: NEG
85061: PUSH
85062: LD_INT 2
85064: NEG
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 2
85072: NEG
85073: PUSH
85074: LD_INT 3
85076: NEG
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 2
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 3
85095: PUSH
85096: LD_INT 1
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 1
85105: PUSH
85106: LD_INT 3
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_INT 1
85115: NEG
85116: PUSH
85117: LD_INT 2
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 3
85126: NEG
85127: PUSH
85128: LD_INT 2
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85161: LD_ADDR_VAR 0 32
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 0
85178: PUSH
85179: LD_INT 1
85181: NEG
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 1
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: LD_INT 1
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 0
85209: PUSH
85210: LD_INT 1
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: NEG
85231: PUSH
85232: LD_INT 1
85234: NEG
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 1
85242: NEG
85243: PUSH
85244: LD_INT 2
85246: NEG
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 0
85254: PUSH
85255: LD_INT 2
85257: NEG
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 1
85265: PUSH
85266: LD_INT 1
85268: NEG
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: PUSH
85274: LD_INT 2
85276: PUSH
85277: LD_INT 1
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 2
85286: PUSH
85287: LD_INT 2
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 1
85296: PUSH
85297: LD_INT 2
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: LD_INT 2
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: LD_INT 1
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 2
85327: NEG
85328: PUSH
85329: LD_INT 0
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 2
85338: NEG
85339: PUSH
85340: LD_INT 1
85342: NEG
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 1
85350: NEG
85351: PUSH
85352: LD_INT 3
85354: NEG
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: PUSH
85363: LD_INT 2
85365: NEG
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 3
85373: PUSH
85374: LD_INT 2
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: PUSH
85384: LD_INT 3
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 2
85393: NEG
85394: PUSH
85395: LD_INT 1
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: PUSH
85402: LD_INT 3
85404: NEG
85405: PUSH
85406: LD_INT 1
85408: NEG
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85439: LD_ADDR_VAR 0 33
85443: PUSH
85444: LD_INT 0
85446: PUSH
85447: LD_INT 0
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 1
85467: PUSH
85468: LD_INT 0
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 1
85477: PUSH
85478: LD_INT 1
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 0
85487: PUSH
85488: LD_INT 1
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 1
85497: NEG
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 1
85508: NEG
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 1
85520: NEG
85521: PUSH
85522: LD_INT 2
85524: NEG
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 1
85532: PUSH
85533: LD_INT 1
85535: NEG
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 2
85543: PUSH
85544: LD_INT 0
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: LD_INT 1
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 1
85563: PUSH
85564: LD_INT 2
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 0
85573: PUSH
85574: LD_INT 2
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: LD_INT 1
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 2
85594: NEG
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: LD_INT 2
85605: NEG
85606: PUSH
85607: LD_INT 1
85609: NEG
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 2
85617: NEG
85618: PUSH
85619: LD_INT 2
85621: NEG
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 2
85629: NEG
85630: PUSH
85631: LD_INT 3
85633: NEG
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 2
85641: PUSH
85642: LD_INT 1
85644: NEG
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 3
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: PUSH
85663: LD_INT 3
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: NEG
85673: PUSH
85674: LD_INT 2
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 3
85683: NEG
85684: PUSH
85685: LD_INT 2
85687: NEG
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85718: LD_ADDR_VAR 0 34
85722: PUSH
85723: LD_INT 0
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 0
85735: PUSH
85736: LD_INT 1
85738: NEG
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 1
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 1
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: LD_INT 1
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: NEG
85777: PUSH
85778: LD_INT 0
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 1
85787: NEG
85788: PUSH
85789: LD_INT 1
85791: NEG
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: PUSH
85797: LD_INT 1
85799: NEG
85800: PUSH
85801: LD_INT 2
85803: NEG
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 2
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: PUSH
85823: LD_INT 1
85825: NEG
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 2
85833: PUSH
85834: LD_INT 1
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 2
85843: PUSH
85844: LD_INT 2
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: LD_INT 1
85853: PUSH
85854: LD_INT 2
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: LD_INT 1
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PUSH
85872: LD_INT 2
85874: NEG
85875: PUSH
85876: LD_INT 0
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 2
85885: NEG
85886: PUSH
85887: LD_INT 1
85889: NEG
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 2
85897: NEG
85898: PUSH
85899: LD_INT 2
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: NEG
85910: PUSH
85911: LD_INT 3
85913: NEG
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 1
85921: PUSH
85922: LD_INT 2
85924: NEG
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 3
85932: PUSH
85933: LD_INT 2
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_INT 2
85942: PUSH
85943: LD_INT 3
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 2
85952: NEG
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: NEG
85964: PUSH
85965: LD_INT 1
85967: NEG
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85998: LD_ADDR_VAR 0 35
86002: PUSH
86003: LD_INT 0
86005: PUSH
86006: LD_INT 0
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 0
86015: PUSH
86016: LD_INT 1
86018: NEG
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: LD_INT 0
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: LD_INT 1
86036: PUSH
86037: LD_INT 1
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 0
86046: PUSH
86047: LD_INT 1
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: NEG
86057: PUSH
86058: LD_INT 0
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 1
86067: NEG
86068: PUSH
86069: LD_INT 1
86071: NEG
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 2
86079: PUSH
86080: LD_INT 1
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 2
86089: NEG
86090: PUSH
86091: LD_INT 1
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86110: LD_ADDR_VAR 0 36
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: LD_INT 0
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 0
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: LD_INT 0
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: LD_INT 1
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: LD_INT 1
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 1
86168: NEG
86169: PUSH
86170: LD_INT 0
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 1
86179: NEG
86180: PUSH
86181: LD_INT 1
86183: NEG
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: LD_INT 2
86195: NEG
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: LD_INT 2
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86222: LD_ADDR_VAR 0 37
86226: PUSH
86227: LD_INT 0
86229: PUSH
86230: LD_INT 0
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 0
86239: PUSH
86240: LD_INT 1
86242: NEG
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 1
86250: PUSH
86251: LD_INT 0
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 1
86260: PUSH
86261: LD_INT 1
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 1
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: NEG
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: NEG
86292: PUSH
86293: LD_INT 1
86295: NEG
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 1
86303: PUSH
86304: LD_INT 1
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: LD_INT 1
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86334: LD_ADDR_VAR 0 38
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 0
86351: PUSH
86352: LD_INT 1
86354: NEG
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: PUSH
86363: LD_INT 0
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 1
86372: PUSH
86373: LD_INT 1
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 0
86382: PUSH
86383: LD_INT 1
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 1
86392: NEG
86393: PUSH
86394: LD_INT 0
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: LD_INT 1
86407: NEG
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: PUSH
86413: LD_INT 2
86415: PUSH
86416: LD_INT 1
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 2
86425: NEG
86426: PUSH
86427: LD_INT 1
86429: NEG
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86446: LD_ADDR_VAR 0 39
86450: PUSH
86451: LD_INT 0
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 0
86463: PUSH
86464: LD_INT 1
86466: NEG
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: LD_INT 0
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: LD_INT 1
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 0
86494: PUSH
86495: LD_INT 1
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: LD_INT 0
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: LD_INT 1
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 1
86527: NEG
86528: PUSH
86529: LD_INT 2
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 1
86539: PUSH
86540: LD_INT 2
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86558: LD_ADDR_VAR 0 40
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: LD_INT 1
86578: NEG
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: LD_INT 0
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: LD_INT 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 1
86616: NEG
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: NEG
86628: PUSH
86629: LD_INT 1
86631: NEG
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 1
86639: PUSH
86640: LD_INT 1
86642: NEG
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 1
86650: NEG
86651: PUSH
86652: LD_INT 1
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86670: LD_ADDR_VAR 0 41
86674: PUSH
86675: LD_INT 0
86677: PUSH
86678: LD_INT 0
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 0
86687: PUSH
86688: LD_INT 1
86690: NEG
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 1
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: PUSH
86706: LD_INT 1
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 0
86718: PUSH
86719: LD_INT 1
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 1
86728: NEG
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: EMPTY
86734: LIST
86735: LIST
86736: PUSH
86737: LD_INT 1
86739: NEG
86740: PUSH
86741: LD_INT 1
86743: NEG
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 1
86751: NEG
86752: PUSH
86753: LD_INT 2
86755: NEG
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 1
86763: PUSH
86764: LD_INT 1
86766: NEG
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 2
86774: PUSH
86775: LD_INT 0
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 2
86784: PUSH
86785: LD_INT 1
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 2
86794: PUSH
86795: LD_INT 2
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 1
86804: PUSH
86805: LD_INT 2
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: LD_INT 1
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 2
86825: NEG
86826: PUSH
86827: LD_INT 0
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 2
86836: NEG
86837: PUSH
86838: LD_INT 1
86840: NEG
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 2
86848: NEG
86849: PUSH
86850: LD_INT 2
86852: NEG
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 2
86860: NEG
86861: PUSH
86862: LD_INT 3
86864: NEG
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 2
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 3
86883: PUSH
86884: LD_INT 0
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 3
86893: PUSH
86894: LD_INT 1
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 3
86903: PUSH
86904: LD_INT 2
86906: PUSH
86907: EMPTY
86908: LIST
86909: LIST
86910: PUSH
86911: LD_INT 3
86913: PUSH
86914: LD_INT 3
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 2
86923: PUSH
86924: LD_INT 3
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 2
86933: NEG
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 3
86944: NEG
86945: PUSH
86946: LD_INT 0
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 3
86955: NEG
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 3
86967: NEG
86968: PUSH
86969: LD_INT 2
86971: NEG
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 3
86979: NEG
86980: PUSH
86981: LD_INT 3
86983: NEG
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87020: LD_ADDR_VAR 0 42
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 0
87068: PUSH
87069: LD_INT 1
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 1
87078: NEG
87079: PUSH
87080: LD_INT 0
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 1
87093: NEG
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 1
87101: NEG
87102: PUSH
87103: LD_INT 2
87105: NEG
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 0
87113: PUSH
87114: LD_INT 2
87116: NEG
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 1
87124: PUSH
87125: LD_INT 1
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: LD_INT 1
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 2
87145: PUSH
87146: LD_INT 2
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: LD_INT 1
87155: PUSH
87156: LD_INT 2
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 0
87165: PUSH
87166: LD_INT 2
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: LD_INT 1
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 2
87186: NEG
87187: PUSH
87188: LD_INT 1
87190: NEG
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 2
87198: NEG
87199: PUSH
87200: LD_INT 2
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 2
87210: NEG
87211: PUSH
87212: LD_INT 3
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: NEG
87223: PUSH
87224: LD_INT 3
87226: NEG
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 0
87234: PUSH
87235: LD_INT 3
87237: NEG
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 1
87245: PUSH
87246: LD_INT 2
87248: NEG
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 3
87256: PUSH
87257: LD_INT 2
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 3
87266: PUSH
87267: LD_INT 3
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 2
87276: PUSH
87277: LD_INT 3
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 1
87286: PUSH
87287: LD_INT 3
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: LD_INT 3
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 2
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 3
87317: NEG
87318: PUSH
87319: LD_INT 2
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 3
87329: NEG
87330: PUSH
87331: LD_INT 3
87333: NEG
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87370: LD_ADDR_VAR 0 43
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 0
87387: PUSH
87388: LD_INT 1
87390: NEG
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: LD_INT 0
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 1
87408: PUSH
87409: LD_INT 1
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 0
87418: PUSH
87419: LD_INT 1
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 1
87428: NEG
87429: PUSH
87430: LD_INT 0
87432: PUSH
87433: EMPTY
87434: LIST
87435: LIST
87436: PUSH
87437: LD_INT 1
87439: NEG
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: LD_INT 2
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: LD_INT 2
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 1
87474: PUSH
87475: LD_INT 1
87477: NEG
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 2
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 2
87495: PUSH
87496: LD_INT 1
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 1
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: LD_INT 1
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 2
87536: NEG
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: NEG
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 1
87559: NEG
87560: PUSH
87561: LD_INT 3
87563: NEG
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 3
87574: NEG
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: LD_INT 2
87585: NEG
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 2
87593: PUSH
87594: LD_INT 1
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 3
87604: PUSH
87605: LD_INT 0
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 3
87614: PUSH
87615: LD_INT 1
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: LD_INT 1
87624: PUSH
87625: LD_INT 3
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 0
87634: PUSH
87635: LD_INT 3
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 1
87644: NEG
87645: PUSH
87646: LD_INT 2
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: LD_INT 1
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 3
87666: NEG
87667: PUSH
87668: LD_INT 0
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 3
87677: NEG
87678: PUSH
87679: LD_INT 1
87681: NEG
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87718: LD_ADDR_VAR 0 44
87722: PUSH
87723: LD_INT 0
87725: PUSH
87726: LD_INT 0
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 0
87735: PUSH
87736: LD_INT 1
87738: NEG
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 1
87746: PUSH
87747: LD_INT 0
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 1
87756: PUSH
87757: LD_INT 1
87759: PUSH
87760: EMPTY
87761: LIST
87762: LIST
87763: PUSH
87764: LD_INT 0
87766: PUSH
87767: LD_INT 1
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: LD_INT 1
87776: NEG
87777: PUSH
87778: LD_INT 0
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: PUSH
87785: LD_INT 1
87787: NEG
87788: PUSH
87789: LD_INT 1
87791: NEG
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 1
87799: NEG
87800: PUSH
87801: LD_INT 2
87803: NEG
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 1
87811: PUSH
87812: LD_INT 1
87814: NEG
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 2
87822: PUSH
87823: LD_INT 0
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PUSH
87830: LD_INT 2
87832: PUSH
87833: LD_INT 1
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 2
87842: PUSH
87843: LD_INT 2
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: PUSH
87850: LD_INT 1
87852: PUSH
87853: LD_INT 2
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: LD_INT 1
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 2
87873: NEG
87874: PUSH
87875: LD_INT 0
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 2
87884: NEG
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 2
87896: NEG
87897: PUSH
87898: LD_INT 2
87900: NEG
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 2
87908: NEG
87909: PUSH
87910: LD_INT 3
87912: NEG
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 3
87931: PUSH
87932: LD_INT 0
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 3
87941: PUSH
87942: LD_INT 1
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 3
87951: PUSH
87952: LD_INT 2
87954: PUSH
87955: EMPTY
87956: LIST
87957: LIST
87958: PUSH
87959: LD_INT 3
87961: PUSH
87962: LD_INT 3
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: LD_INT 3
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 2
87981: NEG
87982: PUSH
87983: LD_INT 1
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 3
87992: NEG
87993: PUSH
87994: LD_INT 0
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 3
88003: NEG
88004: PUSH
88005: LD_INT 1
88007: NEG
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 3
88015: NEG
88016: PUSH
88017: LD_INT 2
88019: NEG
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 3
88027: NEG
88028: PUSH
88029: LD_INT 3
88031: NEG
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88068: LD_ADDR_VAR 0 45
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: LD_INT 0
88078: PUSH
88079: EMPTY
88080: LIST
88081: LIST
88082: PUSH
88083: LD_INT 0
88085: PUSH
88086: LD_INT 1
88088: NEG
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 1
88096: PUSH
88097: LD_INT 0
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 1
88106: PUSH
88107: LD_INT 1
88109: PUSH
88110: EMPTY
88111: LIST
88112: LIST
88113: PUSH
88114: LD_INT 0
88116: PUSH
88117: LD_INT 1
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 1
88126: NEG
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 1
88137: NEG
88138: PUSH
88139: LD_INT 1
88141: NEG
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 1
88149: NEG
88150: PUSH
88151: LD_INT 2
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 0
88161: PUSH
88162: LD_INT 2
88164: NEG
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 1
88172: PUSH
88173: LD_INT 1
88175: NEG
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 2
88183: PUSH
88184: LD_INT 1
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 2
88193: PUSH
88194: LD_INT 2
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 1
88203: PUSH
88204: LD_INT 2
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: LD_INT 2
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: LD_INT 1
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 2
88234: NEG
88235: PUSH
88236: LD_INT 1
88238: NEG
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: PUSH
88244: LD_INT 2
88246: NEG
88247: PUSH
88248: LD_INT 2
88250: NEG
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 2
88258: NEG
88259: PUSH
88260: LD_INT 3
88262: NEG
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 1
88270: NEG
88271: PUSH
88272: LD_INT 3
88274: NEG
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 0
88282: PUSH
88283: LD_INT 3
88285: NEG
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: PUSH
88294: LD_INT 2
88296: NEG
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 3
88304: PUSH
88305: LD_INT 2
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 3
88314: PUSH
88315: LD_INT 3
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 3
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: LD_INT 3
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 3
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: LD_INT 2
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 3
88365: NEG
88366: PUSH
88367: LD_INT 2
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 3
88377: NEG
88378: PUSH
88379: LD_INT 3
88381: NEG
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88418: LD_ADDR_VAR 0 46
88422: PUSH
88423: LD_INT 0
88425: PUSH
88426: LD_INT 0
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 0
88435: PUSH
88436: LD_INT 1
88438: NEG
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: LD_INT 0
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 1
88456: PUSH
88457: LD_INT 1
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: LD_INT 0
88466: PUSH
88467: LD_INT 1
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 1
88487: NEG
88488: PUSH
88489: LD_INT 1
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: LD_INT 2
88514: NEG
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 1
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 2
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: LD_INT 1
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PUSH
88551: LD_INT 1
88553: PUSH
88554: LD_INT 2
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: LD_INT 2
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: LD_INT 1
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 2
88584: NEG
88585: PUSH
88586: LD_INT 0
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 2
88595: NEG
88596: PUSH
88597: LD_INT 1
88599: NEG
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: LD_INT 3
88611: NEG
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: LD_INT 3
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: PUSH
88631: LD_INT 2
88633: NEG
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: LD_INT 1
88644: NEG
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 3
88652: PUSH
88653: LD_INT 0
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 3
88662: PUSH
88663: LD_INT 1
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: PUSH
88673: LD_INT 3
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: LD_INT 3
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: LD_INT 2
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PUSH
88701: LD_INT 2
88703: NEG
88704: PUSH
88705: LD_INT 1
88707: PUSH
88708: EMPTY
88709: LIST
88710: LIST
88711: PUSH
88712: LD_INT 3
88714: NEG
88715: PUSH
88716: LD_INT 0
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 3
88725: NEG
88726: PUSH
88727: LD_INT 1
88729: NEG
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88766: LD_ADDR_VAR 0 47
88770: PUSH
88771: LD_INT 0
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: PUSH
88781: LD_INT 0
88783: PUSH
88784: LD_INT 1
88786: NEG
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: LD_INT 0
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 1
88804: PUSH
88805: LD_INT 1
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 0
88814: PUSH
88815: LD_INT 1
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: LD_INT 0
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: PUSH
88833: LD_INT 1
88835: NEG
88836: PUSH
88837: LD_INT 1
88839: NEG
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 1
88847: NEG
88848: PUSH
88849: LD_INT 2
88851: NEG
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 0
88859: PUSH
88860: LD_INT 2
88862: NEG
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 1
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 2
88881: NEG
88882: PUSH
88883: LD_INT 1
88885: NEG
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 2
88893: NEG
88894: PUSH
88895: LD_INT 2
88897: NEG
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88917: LD_ADDR_VAR 0 48
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 0
88934: PUSH
88935: LD_INT 1
88937: NEG
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 1
88945: PUSH
88946: LD_INT 0
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: LD_INT 1
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: LD_INT 1
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 1
88975: NEG
88976: PUSH
88977: LD_INT 0
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 1
88986: NEG
88987: PUSH
88988: LD_INT 1
88990: NEG
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PUSH
88996: LD_INT 1
88998: NEG
88999: PUSH
89000: LD_INT 2
89002: NEG
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 2
89013: NEG
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 1
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 2
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 2
89042: PUSH
89043: LD_INT 1
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89064: LD_ADDR_VAR 0 49
89068: PUSH
89069: LD_INT 0
89071: PUSH
89072: LD_INT 0
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 0
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 1
89092: PUSH
89093: LD_INT 0
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: LD_INT 1
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: LD_INT 1
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 1
89122: NEG
89123: PUSH
89124: LD_INT 0
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 1
89133: NEG
89134: PUSH
89135: LD_INT 1
89137: NEG
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: PUSH
89143: LD_INT 1
89145: PUSH
89146: LD_INT 1
89148: NEG
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 2
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 2
89166: PUSH
89167: LD_INT 1
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: LD_INT 2
89176: PUSH
89177: LD_INT 2
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 1
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89208: LD_ADDR_VAR 0 50
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: LD_INT 0
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 0
89225: PUSH
89226: LD_INT 1
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 0
89256: PUSH
89257: LD_INT 1
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 0
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 1
89277: NEG
89278: PUSH
89279: LD_INT 1
89281: NEG
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 2
89299: PUSH
89300: LD_INT 2
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 1
89309: PUSH
89310: LD_INT 2
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 0
89319: PUSH
89320: LD_INT 2
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: LD_INT 1
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89352: LD_ADDR_VAR 0 51
89356: PUSH
89357: LD_INT 0
89359: PUSH
89360: LD_INT 0
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 0
89369: PUSH
89370: LD_INT 1
89372: NEG
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 1
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 1
89390: PUSH
89391: LD_INT 1
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 1
89410: NEG
89411: PUSH
89412: LD_INT 0
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: LD_INT 1
89425: NEG
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 1
89433: PUSH
89434: LD_INT 2
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: LD_INT 2
89446: PUSH
89447: EMPTY
89448: LIST
89449: LIST
89450: PUSH
89451: LD_INT 1
89453: NEG
89454: PUSH
89455: LD_INT 1
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 2
89464: NEG
89465: PUSH
89466: LD_INT 0
89468: PUSH
89469: EMPTY
89470: LIST
89471: LIST
89472: PUSH
89473: LD_INT 2
89475: NEG
89476: PUSH
89477: LD_INT 1
89479: NEG
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89499: LD_ADDR_VAR 0 52
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: LD_INT 0
89509: PUSH
89510: EMPTY
89511: LIST
89512: LIST
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: LD_INT 1
89519: NEG
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 1
89527: PUSH
89528: LD_INT 0
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: LD_INT 1
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: LD_INT 1
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 1
89557: NEG
89558: PUSH
89559: LD_INT 0
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 1
89568: NEG
89569: PUSH
89570: LD_INT 1
89572: NEG
89573: PUSH
89574: EMPTY
89575: LIST
89576: LIST
89577: PUSH
89578: LD_INT 1
89580: NEG
89581: PUSH
89582: LD_INT 2
89584: NEG
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 2
89603: NEG
89604: PUSH
89605: LD_INT 0
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 2
89614: NEG
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: NEG
89627: PUSH
89628: LD_INT 2
89630: NEG
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89650: LD_ADDR_VAR 0 53
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 0
89667: PUSH
89668: LD_INT 1
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 1
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: LD_INT 0
89698: PUSH
89699: LD_INT 1
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 1
89708: NEG
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 1
89719: NEG
89720: PUSH
89721: LD_INT 1
89723: NEG
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 1
89731: NEG
89732: PUSH
89733: LD_INT 2
89735: NEG
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: LD_INT 2
89746: NEG
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 1
89754: PUSH
89755: LD_INT 1
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 2
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 2
89775: PUSH
89776: LD_INT 1
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 2
89785: PUSH
89786: LD_INT 2
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 0
89805: PUSH
89806: LD_INT 2
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 1
89815: NEG
89816: PUSH
89817: LD_INT 1
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 2
89826: NEG
89827: PUSH
89828: LD_INT 0
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 2
89837: NEG
89838: PUSH
89839: LD_INT 1
89841: NEG
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 2
89849: NEG
89850: PUSH
89851: LD_INT 2
89853: NEG
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89880: LD_ADDR_VAR 0 54
89884: PUSH
89885: LD_INT 0
89887: PUSH
89888: LD_INT 0
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 0
89897: PUSH
89898: LD_INT 1
89900: NEG
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 1
89908: PUSH
89909: LD_INT 0
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PUSH
89916: LD_INT 1
89918: PUSH
89919: LD_INT 1
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 1
89938: NEG
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: LD_INT 1
89953: NEG
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 1
89961: NEG
89962: PUSH
89963: LD_INT 2
89965: NEG
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: LD_INT 2
89976: NEG
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: PUSH
89985: LD_INT 1
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 2
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 2
90005: PUSH
90006: LD_INT 1
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 2
90015: PUSH
90016: LD_INT 2
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: LD_INT 2
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 0
90035: PUSH
90036: LD_INT 2
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 1
90045: NEG
90046: PUSH
90047: LD_INT 1
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 2
90056: NEG
90057: PUSH
90058: LD_INT 0
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 2
90067: NEG
90068: PUSH
90069: LD_INT 1
90071: NEG
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PUSH
90077: LD_INT 2
90079: NEG
90080: PUSH
90081: LD_INT 2
90083: NEG
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90110: LD_ADDR_VAR 0 55
90114: PUSH
90115: LD_INT 0
90117: PUSH
90118: LD_INT 0
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: LD_INT 1
90130: NEG
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: LD_INT 1
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: LD_INT 1
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 1
90168: NEG
90169: PUSH
90170: LD_INT 0
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 1
90179: NEG
90180: PUSH
90181: LD_INT 1
90183: NEG
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 1
90191: NEG
90192: PUSH
90193: LD_INT 2
90195: NEG
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: LD_INT 2
90206: NEG
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 1
90214: PUSH
90215: LD_INT 1
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 2
90235: PUSH
90236: LD_INT 1
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 2
90245: PUSH
90246: LD_INT 2
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 1
90255: PUSH
90256: LD_INT 2
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 0
90265: PUSH
90266: LD_INT 2
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: LD_INT 1
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 2
90286: NEG
90287: PUSH
90288: LD_INT 0
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 2
90297: NEG
90298: PUSH
90299: LD_INT 1
90301: NEG
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 2
90309: NEG
90310: PUSH
90311: LD_INT 2
90313: NEG
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90340: LD_ADDR_VAR 0 56
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: LD_INT 1
90360: NEG
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 1
90378: PUSH
90379: LD_INT 1
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 1
90398: NEG
90399: PUSH
90400: LD_INT 0
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: LD_INT 1
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: NEG
90422: PUSH
90423: LD_INT 2
90425: NEG
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 2
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 2
90475: PUSH
90476: LD_INT 2
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 2
90516: NEG
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 2
90527: NEG
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 2
90539: NEG
90540: PUSH
90541: LD_INT 2
90543: NEG
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90570: LD_ADDR_VAR 0 57
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 1
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 1
90628: NEG
90629: PUSH
90630: LD_INT 0
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 1
90639: NEG
90640: PUSH
90641: LD_INT 1
90643: NEG
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: LD_INT 2
90655: NEG
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: LD_INT 2
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 2
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 2
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 2
90705: PUSH
90706: LD_INT 2
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: LD_INT 2
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: LD_INT 2
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 2
90746: NEG
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 2
90757: NEG
90758: PUSH
90759: LD_INT 1
90761: NEG
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90800: LD_ADDR_VAR 0 58
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: PUSH
90839: LD_INT 1
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: PUSH
90846: LD_INT 0
90848: PUSH
90849: LD_INT 1
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 1
90858: NEG
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 1
90869: NEG
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: NEG
90882: PUSH
90883: LD_INT 2
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 0
90893: PUSH
90894: LD_INT 2
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 1
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 2
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 2
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 2
90935: PUSH
90936: LD_INT 2
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 1
90945: PUSH
90946: LD_INT 2
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: LD_INT 2
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 1
90965: NEG
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 2
90976: NEG
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 2
90987: NEG
90988: PUSH
90989: LD_INT 1
90991: NEG
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 2
90999: NEG
91000: PUSH
91001: LD_INT 2
91003: NEG
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91030: LD_ADDR_VAR 0 59
91034: PUSH
91035: LD_INT 0
91037: PUSH
91038: LD_INT 0
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 0
91047: PUSH
91048: LD_INT 1
91050: NEG
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 1
91068: PUSH
91069: LD_INT 1
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 0
91078: PUSH
91079: LD_INT 1
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: LD_INT 1
91103: NEG
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91118: LD_ADDR_VAR 0 60
91122: PUSH
91123: LD_INT 0
91125: PUSH
91126: LD_INT 0
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 0
91135: PUSH
91136: LD_INT 1
91138: NEG
91139: PUSH
91140: EMPTY
91141: LIST
91142: LIST
91143: PUSH
91144: LD_INT 1
91146: PUSH
91147: LD_INT 0
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 1
91156: PUSH
91157: LD_INT 1
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: LD_INT 0
91166: PUSH
91167: LD_INT 1
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 1
91176: NEG
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 1
91187: NEG
91188: PUSH
91189: LD_INT 1
91191: NEG
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91206: LD_ADDR_VAR 0 61
91210: PUSH
91211: LD_INT 0
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 0
91223: PUSH
91224: LD_INT 1
91226: NEG
91227: PUSH
91228: EMPTY
91229: LIST
91230: LIST
91231: PUSH
91232: LD_INT 1
91234: PUSH
91235: LD_INT 0
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: PUSH
91242: LD_INT 1
91244: PUSH
91245: LD_INT 1
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 0
91254: PUSH
91255: LD_INT 1
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 1
91264: NEG
91265: PUSH
91266: LD_INT 0
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 1
91275: NEG
91276: PUSH
91277: LD_INT 1
91279: NEG
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: EMPTY
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91294: LD_ADDR_VAR 0 62
91298: PUSH
91299: LD_INT 0
91301: PUSH
91302: LD_INT 0
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 0
91311: PUSH
91312: LD_INT 1
91314: NEG
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 1
91322: PUSH
91323: LD_INT 0
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 1
91332: PUSH
91333: LD_INT 1
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 0
91342: PUSH
91343: LD_INT 1
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: PUSH
91350: LD_INT 1
91352: NEG
91353: PUSH
91354: LD_INT 0
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 1
91363: NEG
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91382: LD_ADDR_VAR 0 63
91386: PUSH
91387: LD_INT 0
91389: PUSH
91390: LD_INT 0
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: LD_INT 1
91402: NEG
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 1
91410: PUSH
91411: LD_INT 0
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: LD_INT 1
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 0
91430: PUSH
91431: LD_INT 1
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 1
91440: NEG
91441: PUSH
91442: LD_INT 0
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 1
91451: NEG
91452: PUSH
91453: LD_INT 1
91455: NEG
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91470: LD_ADDR_VAR 0 64
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 1
91490: NEG
91491: PUSH
91492: EMPTY
91493: LIST
91494: LIST
91495: PUSH
91496: LD_INT 1
91498: PUSH
91499: LD_INT 0
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: LD_INT 1
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 0
91518: PUSH
91519: LD_INT 1
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 1
91528: NEG
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 1
91539: NEG
91540: PUSH
91541: LD_INT 1
91543: NEG
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: ST_TO_ADDR
// end ; 1 :
91558: GO 97455
91560: LD_INT 1
91562: DOUBLE
91563: EQUAL
91564: IFTRUE 91568
91566: GO 94191
91568: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91569: LD_ADDR_VAR 0 11
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: LD_INT 3
91580: NEG
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: LD_INT 3
91591: NEG
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PUSH
91597: LD_INT 1
91599: PUSH
91600: LD_INT 2
91602: NEG
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: LIST
91612: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91613: LD_ADDR_VAR 0 12
91617: PUSH
91618: LD_INT 2
91620: PUSH
91621: LD_INT 1
91623: NEG
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 3
91631: PUSH
91632: LD_INT 0
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 3
91641: PUSH
91642: LD_INT 1
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: LIST
91653: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91654: LD_ADDR_VAR 0 13
91658: PUSH
91659: LD_INT 3
91661: PUSH
91662: LD_INT 2
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 3
91671: PUSH
91672: LD_INT 3
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 2
91681: PUSH
91682: LD_INT 3
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: LIST
91693: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91694: LD_ADDR_VAR 0 14
91698: PUSH
91699: LD_INT 1
91701: PUSH
91702: LD_INT 3
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 0
91711: PUSH
91712: LD_INT 3
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PUSH
91719: LD_INT 1
91721: NEG
91722: PUSH
91723: LD_INT 2
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: LIST
91734: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91735: LD_ADDR_VAR 0 15
91739: PUSH
91740: LD_INT 2
91742: NEG
91743: PUSH
91744: LD_INT 1
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 3
91753: NEG
91754: PUSH
91755: LD_INT 0
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: LD_INT 1
91768: NEG
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91779: LD_ADDR_VAR 0 16
91783: PUSH
91784: LD_INT 2
91786: NEG
91787: PUSH
91788: LD_INT 3
91790: NEG
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 3
91798: NEG
91799: PUSH
91800: LD_INT 2
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 3
91810: NEG
91811: PUSH
91812: LD_INT 3
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: LIST
91824: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91825: LD_ADDR_VAR 0 17
91829: PUSH
91830: LD_INT 1
91832: NEG
91833: PUSH
91834: LD_INT 3
91836: NEG
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 0
91844: PUSH
91845: LD_INT 3
91847: NEG
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 1
91855: PUSH
91856: LD_INT 2
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: LIST
91868: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91869: LD_ADDR_VAR 0 18
91873: PUSH
91874: LD_INT 2
91876: PUSH
91877: LD_INT 1
91879: NEG
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: LD_INT 0
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 3
91897: PUSH
91898: LD_INT 1
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: LIST
91909: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91910: LD_ADDR_VAR 0 19
91914: PUSH
91915: LD_INT 3
91917: PUSH
91918: LD_INT 2
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 3
91927: PUSH
91928: LD_INT 3
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 2
91937: PUSH
91938: LD_INT 3
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: LIST
91949: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91950: LD_ADDR_VAR 0 20
91954: PUSH
91955: LD_INT 1
91957: PUSH
91958: LD_INT 3
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: PUSH
91965: LD_INT 0
91967: PUSH
91968: LD_INT 3
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 1
91977: NEG
91978: PUSH
91979: LD_INT 2
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: LIST
91990: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91991: LD_ADDR_VAR 0 21
91995: PUSH
91996: LD_INT 2
91998: NEG
91999: PUSH
92000: LD_INT 1
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: PUSH
92007: LD_INT 3
92009: NEG
92010: PUSH
92011: LD_INT 0
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 3
92020: NEG
92021: PUSH
92022: LD_INT 1
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: LIST
92034: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92035: LD_ADDR_VAR 0 22
92039: PUSH
92040: LD_INT 2
92042: NEG
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 3
92054: NEG
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 3
92066: NEG
92067: PUSH
92068: LD_INT 3
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: EMPTY
92077: LIST
92078: LIST
92079: LIST
92080: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92081: LD_ADDR_VAR 0 23
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 1
92099: NEG
92100: PUSH
92101: LD_INT 4
92103: NEG
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: LD_INT 1
92111: PUSH
92112: LD_INT 3
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92125: LD_ADDR_VAR 0 24
92129: PUSH
92130: LD_INT 3
92132: PUSH
92133: LD_INT 0
92135: PUSH
92136: EMPTY
92137: LIST
92138: LIST
92139: PUSH
92140: LD_INT 3
92142: PUSH
92143: LD_INT 1
92145: NEG
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 4
92153: PUSH
92154: LD_INT 1
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: LIST
92165: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92166: LD_ADDR_VAR 0 25
92170: PUSH
92171: LD_INT 3
92173: PUSH
92174: LD_INT 3
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 4
92183: PUSH
92184: LD_INT 3
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 3
92193: PUSH
92194: LD_INT 4
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: LIST
92205: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92206: LD_ADDR_VAR 0 26
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: LD_INT 3
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: LD_INT 1
92223: PUSH
92224: LD_INT 4
92226: PUSH
92227: EMPTY
92228: LIST
92229: LIST
92230: PUSH
92231: LD_INT 1
92233: NEG
92234: PUSH
92235: LD_INT 3
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: LIST
92246: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92247: LD_ADDR_VAR 0 27
92251: PUSH
92252: LD_INT 3
92254: NEG
92255: PUSH
92256: LD_INT 0
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 3
92265: NEG
92266: PUSH
92267: LD_INT 1
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 4
92276: NEG
92277: PUSH
92278: LD_INT 1
92280: NEG
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: LIST
92290: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92291: LD_ADDR_VAR 0 28
92295: PUSH
92296: LD_INT 3
92298: NEG
92299: PUSH
92300: LD_INT 3
92302: NEG
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: LD_INT 4
92314: NEG
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 4
92322: NEG
92323: PUSH
92324: LD_INT 3
92326: NEG
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: LIST
92336: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92337: LD_ADDR_VAR 0 29
92341: PUSH
92342: LD_INT 1
92344: NEG
92345: PUSH
92346: LD_INT 3
92348: NEG
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 0
92356: PUSH
92357: LD_INT 3
92359: NEG
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: LD_INT 1
92367: PUSH
92368: LD_INT 2
92370: NEG
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 1
92378: NEG
92379: PUSH
92380: LD_INT 4
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 0
92390: PUSH
92391: LD_INT 4
92393: NEG
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 1
92401: PUSH
92402: LD_INT 3
92404: NEG
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: PUSH
92410: LD_INT 1
92412: NEG
92413: PUSH
92414: LD_INT 5
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 0
92424: PUSH
92425: LD_INT 5
92427: NEG
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 1
92435: PUSH
92436: LD_INT 4
92438: NEG
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 1
92446: NEG
92447: PUSH
92448: LD_INT 6
92450: NEG
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 0
92458: PUSH
92459: LD_INT 6
92461: NEG
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 1
92469: PUSH
92470: LD_INT 5
92472: NEG
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92492: LD_ADDR_VAR 0 30
92496: PUSH
92497: LD_INT 2
92499: PUSH
92500: LD_INT 1
92502: NEG
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 3
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 3
92520: PUSH
92521: LD_INT 1
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 3
92530: PUSH
92531: LD_INT 1
92533: NEG
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 4
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: PUSH
92549: LD_INT 4
92551: PUSH
92552: LD_INT 1
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 4
92561: PUSH
92562: LD_INT 1
92564: NEG
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 5
92572: PUSH
92573: LD_INT 0
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 5
92582: PUSH
92583: LD_INT 1
92585: PUSH
92586: EMPTY
92587: LIST
92588: LIST
92589: PUSH
92590: LD_INT 5
92592: PUSH
92593: LD_INT 1
92595: NEG
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 6
92603: PUSH
92604: LD_INT 0
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 6
92613: PUSH
92614: LD_INT 1
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92635: LD_ADDR_VAR 0 31
92639: PUSH
92640: LD_INT 3
92642: PUSH
92643: LD_INT 2
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 3
92652: PUSH
92653: LD_INT 3
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 2
92662: PUSH
92663: LD_INT 3
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 4
92672: PUSH
92673: LD_INT 3
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 4
92682: PUSH
92683: LD_INT 4
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 3
92692: PUSH
92693: LD_INT 4
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 5
92702: PUSH
92703: LD_INT 4
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 5
92712: PUSH
92713: LD_INT 5
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 4
92722: PUSH
92723: LD_INT 5
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 6
92732: PUSH
92733: LD_INT 5
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 6
92742: PUSH
92743: LD_INT 6
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 5
92752: PUSH
92753: LD_INT 6
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92774: LD_ADDR_VAR 0 32
92778: PUSH
92779: LD_INT 1
92781: PUSH
92782: LD_INT 3
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 0
92791: PUSH
92792: LD_INT 3
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 1
92801: NEG
92802: PUSH
92803: LD_INT 2
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 1
92812: PUSH
92813: LD_INT 4
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: LD_INT 0
92822: PUSH
92823: LD_INT 4
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 1
92832: NEG
92833: PUSH
92834: LD_INT 3
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 1
92843: PUSH
92844: LD_INT 5
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: LD_INT 0
92853: PUSH
92854: LD_INT 5
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: NEG
92864: PUSH
92865: LD_INT 4
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 1
92874: PUSH
92875: LD_INT 6
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 0
92884: PUSH
92885: LD_INT 6
92887: PUSH
92888: EMPTY
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 1
92894: NEG
92895: PUSH
92896: LD_INT 5
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92917: LD_ADDR_VAR 0 33
92921: PUSH
92922: LD_INT 2
92924: NEG
92925: PUSH
92926: LD_INT 1
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 3
92935: NEG
92936: PUSH
92937: LD_INT 0
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PUSH
92944: LD_INT 3
92946: NEG
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: EMPTY
92953: LIST
92954: LIST
92955: PUSH
92956: LD_INT 3
92958: NEG
92959: PUSH
92960: LD_INT 1
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PUSH
92967: LD_INT 4
92969: NEG
92970: PUSH
92971: LD_INT 0
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 4
92980: NEG
92981: PUSH
92982: LD_INT 1
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 4
92992: NEG
92993: PUSH
92994: LD_INT 1
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 5
93003: NEG
93004: PUSH
93005: LD_INT 0
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 5
93014: NEG
93015: PUSH
93016: LD_INT 1
93018: NEG
93019: PUSH
93020: EMPTY
93021: LIST
93022: LIST
93023: PUSH
93024: LD_INT 5
93026: NEG
93027: PUSH
93028: LD_INT 1
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 6
93037: NEG
93038: PUSH
93039: LD_INT 0
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 6
93048: NEG
93049: PUSH
93050: LD_INT 1
93052: NEG
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93072: LD_ADDR_VAR 0 34
93076: PUSH
93077: LD_INT 2
93079: NEG
93080: PUSH
93081: LD_INT 3
93083: NEG
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 3
93091: NEG
93092: PUSH
93093: LD_INT 2
93095: NEG
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 3
93103: NEG
93104: PUSH
93105: LD_INT 3
93107: NEG
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 3
93115: NEG
93116: PUSH
93117: LD_INT 4
93119: NEG
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 4
93127: NEG
93128: PUSH
93129: LD_INT 3
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 4
93139: NEG
93140: PUSH
93141: LD_INT 4
93143: NEG
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 4
93151: NEG
93152: PUSH
93153: LD_INT 5
93155: NEG
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 5
93163: NEG
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 5
93175: NEG
93176: PUSH
93177: LD_INT 5
93179: NEG
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 5
93187: NEG
93188: PUSH
93189: LD_INT 6
93191: NEG
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 6
93199: NEG
93200: PUSH
93201: LD_INT 5
93203: NEG
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 6
93211: NEG
93212: PUSH
93213: LD_INT 6
93215: NEG
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93235: LD_ADDR_VAR 0 41
93239: PUSH
93240: LD_INT 0
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 1
93253: NEG
93254: PUSH
93255: LD_INT 3
93257: NEG
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: PUSH
93263: LD_INT 1
93265: PUSH
93266: LD_INT 2
93268: NEG
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: LIST
93278: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93279: LD_ADDR_VAR 0 42
93283: PUSH
93284: LD_INT 2
93286: PUSH
93287: LD_INT 0
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 2
93296: PUSH
93297: LD_INT 1
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 3
93307: PUSH
93308: LD_INT 1
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: LIST
93319: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93320: LD_ADDR_VAR 0 43
93324: PUSH
93325: LD_INT 2
93327: PUSH
93328: LD_INT 2
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: LD_INT 2
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 2
93347: PUSH
93348: LD_INT 3
93350: PUSH
93351: EMPTY
93352: LIST
93353: LIST
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: LIST
93359: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93360: LD_ADDR_VAR 0 44
93364: PUSH
93365: LD_INT 0
93367: PUSH
93368: LD_INT 2
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: LD_INT 1
93377: PUSH
93378: LD_INT 3
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 1
93387: NEG
93388: PUSH
93389: LD_INT 2
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: LIST
93400: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93401: LD_ADDR_VAR 0 45
93405: PUSH
93406: LD_INT 2
93408: NEG
93409: PUSH
93410: LD_INT 0
93412: PUSH
93413: EMPTY
93414: LIST
93415: LIST
93416: PUSH
93417: LD_INT 2
93419: NEG
93420: PUSH
93421: LD_INT 1
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: LD_INT 3
93430: NEG
93431: PUSH
93432: LD_INT 1
93434: NEG
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: LIST
93444: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93445: LD_ADDR_VAR 0 46
93449: PUSH
93450: LD_INT 2
93452: NEG
93453: PUSH
93454: LD_INT 2
93456: NEG
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 2
93464: NEG
93465: PUSH
93466: LD_INT 3
93468: NEG
93469: PUSH
93470: EMPTY
93471: LIST
93472: LIST
93473: PUSH
93474: LD_INT 3
93476: NEG
93477: PUSH
93478: LD_INT 2
93480: NEG
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: LIST
93490: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93491: LD_ADDR_VAR 0 47
93495: PUSH
93496: LD_INT 2
93498: NEG
93499: PUSH
93500: LD_INT 3
93502: NEG
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 1
93510: NEG
93511: PUSH
93512: LD_INT 3
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93524: LD_ADDR_VAR 0 48
93528: PUSH
93529: LD_INT 1
93531: PUSH
93532: LD_INT 2
93534: NEG
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 2
93542: PUSH
93543: LD_INT 1
93545: NEG
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93555: LD_ADDR_VAR 0 49
93559: PUSH
93560: LD_INT 3
93562: PUSH
93563: LD_INT 1
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 3
93572: PUSH
93573: LD_INT 2
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93584: LD_ADDR_VAR 0 50
93588: PUSH
93589: LD_INT 2
93591: PUSH
93592: LD_INT 3
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 1
93601: PUSH
93602: LD_INT 3
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93613: LD_ADDR_VAR 0 51
93617: PUSH
93618: LD_INT 1
93620: NEG
93621: PUSH
93622: LD_INT 2
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 2
93631: NEG
93632: PUSH
93633: LD_INT 1
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93644: LD_ADDR_VAR 0 52
93648: PUSH
93649: LD_INT 3
93651: NEG
93652: PUSH
93653: LD_INT 1
93655: NEG
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 3
93663: NEG
93664: PUSH
93665: LD_INT 2
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93677: LD_ADDR_VAR 0 53
93681: PUSH
93682: LD_INT 1
93684: NEG
93685: PUSH
93686: LD_INT 3
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 1
93707: PUSH
93708: LD_INT 2
93710: NEG
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: LIST
93720: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93721: LD_ADDR_VAR 0 54
93725: PUSH
93726: LD_INT 2
93728: PUSH
93729: LD_INT 1
93731: NEG
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: LD_INT 3
93739: PUSH
93740: LD_INT 0
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: PUSH
93750: LD_INT 1
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: LIST
93761: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93762: LD_ADDR_VAR 0 55
93766: PUSH
93767: LD_INT 3
93769: PUSH
93770: LD_INT 2
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PUSH
93777: LD_INT 3
93779: PUSH
93780: LD_INT 3
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 2
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: LIST
93801: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93802: LD_ADDR_VAR 0 56
93806: PUSH
93807: LD_INT 1
93809: PUSH
93810: LD_INT 3
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 1
93829: NEG
93830: PUSH
93831: LD_INT 2
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: LIST
93842: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93843: LD_ADDR_VAR 0 57
93847: PUSH
93848: LD_INT 2
93850: NEG
93851: PUSH
93852: LD_INT 1
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 3
93861: NEG
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 3
93872: NEG
93873: PUSH
93874: LD_INT 1
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93887: LD_ADDR_VAR 0 58
93891: PUSH
93892: LD_INT 2
93894: NEG
93895: PUSH
93896: LD_INT 3
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 3
93906: NEG
93907: PUSH
93908: LD_INT 2
93910: NEG
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: NEG
93919: PUSH
93920: LD_INT 3
93922: NEG
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: LIST
93932: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93933: LD_ADDR_VAR 0 59
93937: PUSH
93938: LD_INT 1
93940: NEG
93941: PUSH
93942: LD_INT 2
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 0
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: LD_INT 1
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: LIST
93976: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93977: LD_ADDR_VAR 0 60
93981: PUSH
93982: LD_INT 1
93984: PUSH
93985: LD_INT 1
93987: NEG
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: LD_INT 0
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 2
94005: PUSH
94006: LD_INT 1
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: LIST
94017: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94018: LD_ADDR_VAR 0 61
94022: PUSH
94023: LD_INT 2
94025: PUSH
94026: LD_INT 1
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 2
94035: PUSH
94036: LD_INT 2
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 1
94045: PUSH
94046: LD_INT 2
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: LIST
94057: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94058: LD_ADDR_VAR 0 62
94062: PUSH
94063: LD_INT 1
94065: PUSH
94066: LD_INT 2
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 0
94075: PUSH
94076: LD_INT 2
94078: PUSH
94079: EMPTY
94080: LIST
94081: LIST
94082: PUSH
94083: LD_INT 1
94085: NEG
94086: PUSH
94087: LD_INT 1
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: LIST
94098: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94099: LD_ADDR_VAR 0 63
94103: PUSH
94104: LD_INT 1
94106: NEG
94107: PUSH
94108: LD_INT 1
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 2
94117: NEG
94118: PUSH
94119: LD_INT 0
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 2
94128: NEG
94129: PUSH
94130: LD_INT 1
94132: NEG
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: LIST
94142: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94143: LD_ADDR_VAR 0 64
94147: PUSH
94148: LD_INT 1
94150: NEG
94151: PUSH
94152: LD_INT 2
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 2
94162: NEG
94163: PUSH
94164: LD_INT 1
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 2
94174: NEG
94175: PUSH
94176: LD_INT 2
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: ST_TO_ADDR
// end ; 2 :
94189: GO 97455
94191: LD_INT 2
94193: DOUBLE
94194: EQUAL
94195: IFTRUE 94199
94197: GO 97454
94199: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94200: LD_ADDR_VAR 0 29
94204: PUSH
94205: LD_INT 4
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 4
94217: PUSH
94218: LD_INT 1
94220: NEG
94221: PUSH
94222: EMPTY
94223: LIST
94224: LIST
94225: PUSH
94226: LD_INT 5
94228: PUSH
94229: LD_INT 0
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PUSH
94236: LD_INT 5
94238: PUSH
94239: LD_INT 1
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 4
94248: PUSH
94249: LD_INT 1
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 3
94258: PUSH
94259: LD_INT 0
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: PUSH
94269: LD_INT 1
94271: NEG
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 3
94279: PUSH
94280: LD_INT 2
94282: NEG
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 5
94290: PUSH
94291: LD_INT 2
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: LD_INT 3
94300: PUSH
94301: LD_INT 3
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 3
94310: PUSH
94311: LD_INT 2
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 4
94320: PUSH
94321: LD_INT 3
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: LD_INT 4
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 3
94340: PUSH
94341: LD_INT 4
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 2
94350: PUSH
94351: LD_INT 3
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 2
94360: PUSH
94361: LD_INT 2
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 4
94370: PUSH
94371: LD_INT 2
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 2
94380: PUSH
94381: LD_INT 4
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 0
94390: PUSH
94391: LD_INT 4
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 0
94400: PUSH
94401: LD_INT 3
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: PUSH
94408: LD_INT 1
94410: PUSH
94411: LD_INT 4
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: PUSH
94418: LD_INT 1
94420: PUSH
94421: LD_INT 5
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: PUSH
94428: LD_INT 0
94430: PUSH
94431: LD_INT 5
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PUSH
94438: LD_INT 1
94440: NEG
94441: PUSH
94442: LD_INT 4
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 1
94451: NEG
94452: PUSH
94453: LD_INT 3
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 2
94462: PUSH
94463: LD_INT 5
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 2
94472: NEG
94473: PUSH
94474: LD_INT 3
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 3
94483: NEG
94484: PUSH
94485: LD_INT 0
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 3
94494: NEG
94495: PUSH
94496: LD_INT 1
94498: NEG
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: LD_INT 2
94506: NEG
94507: PUSH
94508: LD_INT 0
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 2
94517: NEG
94518: PUSH
94519: LD_INT 1
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 3
94528: NEG
94529: PUSH
94530: LD_INT 1
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 4
94539: NEG
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 4
94550: NEG
94551: PUSH
94552: LD_INT 1
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 4
94562: NEG
94563: PUSH
94564: LD_INT 2
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 2
94574: NEG
94575: PUSH
94576: LD_INT 2
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 4
94585: NEG
94586: PUSH
94587: LD_INT 4
94589: NEG
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: PUSH
94595: LD_INT 4
94597: NEG
94598: PUSH
94599: LD_INT 5
94601: NEG
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 3
94609: NEG
94610: PUSH
94611: LD_INT 4
94613: NEG
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: PUSH
94619: LD_INT 3
94621: NEG
94622: PUSH
94623: LD_INT 3
94625: NEG
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 4
94633: NEG
94634: PUSH
94635: LD_INT 3
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 5
94645: NEG
94646: PUSH
94647: LD_INT 4
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 5
94657: NEG
94658: PUSH
94659: LD_INT 5
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 3
94669: NEG
94670: PUSH
94671: LD_INT 5
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 5
94681: NEG
94682: PUSH
94683: LD_INT 3
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94738: LD_ADDR_VAR 0 30
94742: PUSH
94743: LD_INT 4
94745: PUSH
94746: LD_INT 4
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 4
94755: PUSH
94756: LD_INT 3
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 5
94765: PUSH
94766: LD_INT 4
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 5
94775: PUSH
94776: LD_INT 5
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: LD_INT 5
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: LD_INT 4
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 3
94805: PUSH
94806: LD_INT 3
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: LD_INT 3
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 3
94825: PUSH
94826: LD_INT 5
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 0
94835: PUSH
94836: LD_INT 3
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 0
94845: PUSH
94846: LD_INT 2
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 1
94855: PUSH
94856: LD_INT 3
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: PUSH
94863: LD_INT 1
94865: PUSH
94866: LD_INT 4
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 0
94875: PUSH
94876: LD_INT 4
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 1
94885: NEG
94886: PUSH
94887: LD_INT 3
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 1
94896: NEG
94897: PUSH
94898: LD_INT 2
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 2
94907: PUSH
94908: LD_INT 4
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 2
94917: NEG
94918: PUSH
94919: LD_INT 2
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 4
94928: NEG
94929: PUSH
94930: LD_INT 0
94932: PUSH
94933: EMPTY
94934: LIST
94935: LIST
94936: PUSH
94937: LD_INT 4
94939: NEG
94940: PUSH
94941: LD_INT 1
94943: NEG
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 3
94951: NEG
94952: PUSH
94953: LD_INT 0
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: LD_INT 3
94962: NEG
94963: PUSH
94964: LD_INT 1
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 4
94973: NEG
94974: PUSH
94975: LD_INT 1
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 5
94995: NEG
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 5
95007: NEG
95008: PUSH
95009: LD_INT 2
95011: NEG
95012: PUSH
95013: EMPTY
95014: LIST
95015: LIST
95016: PUSH
95017: LD_INT 3
95019: NEG
95020: PUSH
95021: LD_INT 2
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 3
95030: NEG
95031: PUSH
95032: LD_INT 3
95034: NEG
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 3
95042: NEG
95043: PUSH
95044: LD_INT 4
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 2
95054: NEG
95055: PUSH
95056: LD_INT 3
95058: NEG
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 2
95066: NEG
95067: PUSH
95068: LD_INT 2
95070: NEG
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 3
95078: NEG
95079: PUSH
95080: LD_INT 2
95082: NEG
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 4
95090: NEG
95091: PUSH
95092: LD_INT 3
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 4
95102: NEG
95103: PUSH
95104: LD_INT 4
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: LD_INT 4
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 4
95126: NEG
95127: PUSH
95128: LD_INT 2
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 0
95138: PUSH
95139: LD_INT 4
95141: NEG
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: LD_INT 0
95149: PUSH
95150: LD_INT 5
95152: NEG
95153: PUSH
95154: EMPTY
95155: LIST
95156: LIST
95157: PUSH
95158: LD_INT 1
95160: PUSH
95161: LD_INT 4
95163: NEG
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: PUSH
95169: LD_INT 1
95171: PUSH
95172: LD_INT 3
95174: NEG
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 0
95182: PUSH
95183: LD_INT 3
95185: NEG
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PUSH
95191: LD_INT 1
95193: NEG
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 1
95205: NEG
95206: PUSH
95207: LD_INT 5
95209: NEG
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 2
95217: PUSH
95218: LD_INT 3
95220: NEG
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 2
95228: NEG
95229: PUSH
95230: LD_INT 5
95232: NEG
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95285: LD_ADDR_VAR 0 31
95289: PUSH
95290: LD_INT 0
95292: PUSH
95293: LD_INT 4
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 0
95302: PUSH
95303: LD_INT 3
95305: PUSH
95306: EMPTY
95307: LIST
95308: LIST
95309: PUSH
95310: LD_INT 1
95312: PUSH
95313: LD_INT 4
95315: PUSH
95316: EMPTY
95317: LIST
95318: LIST
95319: PUSH
95320: LD_INT 1
95322: PUSH
95323: LD_INT 5
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: PUSH
95330: LD_INT 0
95332: PUSH
95333: LD_INT 5
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 1
95342: NEG
95343: PUSH
95344: LD_INT 4
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: PUSH
95351: LD_INT 1
95353: NEG
95354: PUSH
95355: LD_INT 3
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 2
95364: PUSH
95365: LD_INT 5
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: LD_INT 2
95374: NEG
95375: PUSH
95376: LD_INT 3
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 3
95385: NEG
95386: PUSH
95387: LD_INT 0
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: PUSH
95394: LD_INT 3
95396: NEG
95397: PUSH
95398: LD_INT 1
95400: NEG
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 2
95408: NEG
95409: PUSH
95410: LD_INT 0
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 2
95419: NEG
95420: PUSH
95421: LD_INT 1
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 3
95430: NEG
95431: PUSH
95432: LD_INT 1
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 4
95441: NEG
95442: PUSH
95443: LD_INT 0
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 4
95452: NEG
95453: PUSH
95454: LD_INT 1
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 4
95464: NEG
95465: PUSH
95466: LD_INT 2
95468: NEG
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 2
95476: NEG
95477: PUSH
95478: LD_INT 2
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 4
95487: NEG
95488: PUSH
95489: LD_INT 4
95491: NEG
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 4
95499: NEG
95500: PUSH
95501: LD_INT 5
95503: NEG
95504: PUSH
95505: EMPTY
95506: LIST
95507: LIST
95508: PUSH
95509: LD_INT 3
95511: NEG
95512: PUSH
95513: LD_INT 4
95515: NEG
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 3
95523: NEG
95524: PUSH
95525: LD_INT 3
95527: NEG
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 4
95535: NEG
95536: PUSH
95537: LD_INT 3
95539: NEG
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 5
95547: NEG
95548: PUSH
95549: LD_INT 4
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 5
95559: NEG
95560: PUSH
95561: LD_INT 5
95563: NEG
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 3
95571: NEG
95572: PUSH
95573: LD_INT 5
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 5
95583: NEG
95584: PUSH
95585: LD_INT 3
95587: NEG
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 0
95595: PUSH
95596: LD_INT 3
95598: NEG
95599: PUSH
95600: EMPTY
95601: LIST
95602: LIST
95603: PUSH
95604: LD_INT 0
95606: PUSH
95607: LD_INT 4
95609: NEG
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: LD_INT 1
95617: PUSH
95618: LD_INT 3
95620: NEG
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 1
95628: PUSH
95629: LD_INT 2
95631: NEG
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 0
95639: PUSH
95640: LD_INT 2
95642: NEG
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 1
95650: NEG
95651: PUSH
95652: LD_INT 3
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 1
95662: NEG
95663: PUSH
95664: LD_INT 4
95666: NEG
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 2
95674: PUSH
95675: LD_INT 2
95677: NEG
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 2
95685: NEG
95686: PUSH
95687: LD_INT 4
95689: NEG
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 4
95697: PUSH
95698: LD_INT 0
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 4
95707: PUSH
95708: LD_INT 1
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 5
95718: PUSH
95719: LD_INT 0
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 5
95728: PUSH
95729: LD_INT 1
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 4
95738: PUSH
95739: LD_INT 1
95741: PUSH
95742: EMPTY
95743: LIST
95744: LIST
95745: PUSH
95746: LD_INT 3
95748: PUSH
95749: LD_INT 0
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 3
95758: PUSH
95759: LD_INT 1
95761: NEG
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 3
95769: PUSH
95770: LD_INT 2
95772: NEG
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 5
95780: PUSH
95781: LD_INT 2
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95835: LD_ADDR_VAR 0 32
95839: PUSH
95840: LD_INT 4
95842: NEG
95843: PUSH
95844: LD_INT 0
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PUSH
95851: LD_INT 4
95853: NEG
95854: PUSH
95855: LD_INT 1
95857: NEG
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 3
95865: NEG
95866: PUSH
95867: LD_INT 0
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: LD_INT 3
95876: NEG
95877: PUSH
95878: LD_INT 1
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 4
95887: NEG
95888: PUSH
95889: LD_INT 1
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 5
95898: NEG
95899: PUSH
95900: LD_INT 0
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 5
95909: NEG
95910: PUSH
95911: LD_INT 1
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 5
95921: NEG
95922: PUSH
95923: LD_INT 2
95925: NEG
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 3
95933: NEG
95934: PUSH
95935: LD_INT 2
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 3
95944: NEG
95945: PUSH
95946: LD_INT 3
95948: NEG
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 3
95956: NEG
95957: PUSH
95958: LD_INT 4
95960: NEG
95961: PUSH
95962: EMPTY
95963: LIST
95964: LIST
95965: PUSH
95966: LD_INT 2
95968: NEG
95969: PUSH
95970: LD_INT 3
95972: NEG
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 2
95980: NEG
95981: PUSH
95982: LD_INT 2
95984: NEG
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 3
95992: NEG
95993: PUSH
95994: LD_INT 2
95996: NEG
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 4
96004: NEG
96005: PUSH
96006: LD_INT 3
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 4
96016: NEG
96017: PUSH
96018: LD_INT 4
96020: NEG
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: NEG
96029: PUSH
96030: LD_INT 4
96032: NEG
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: LD_INT 4
96040: NEG
96041: PUSH
96042: LD_INT 2
96044: NEG
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 0
96052: PUSH
96053: LD_INT 4
96055: NEG
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: PUSH
96061: LD_INT 0
96063: PUSH
96064: LD_INT 5
96066: NEG
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: PUSH
96072: LD_INT 1
96074: PUSH
96075: LD_INT 4
96077: NEG
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 1
96085: PUSH
96086: LD_INT 3
96088: NEG
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 0
96096: PUSH
96097: LD_INT 3
96099: NEG
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: LD_INT 1
96107: NEG
96108: PUSH
96109: LD_INT 4
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 1
96119: NEG
96120: PUSH
96121: LD_INT 5
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 2
96131: PUSH
96132: LD_INT 3
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 2
96142: NEG
96143: PUSH
96144: LD_INT 5
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 3
96154: PUSH
96155: LD_INT 0
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: PUSH
96162: LD_INT 3
96164: PUSH
96165: LD_INT 1
96167: NEG
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 4
96175: PUSH
96176: LD_INT 0
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: LD_INT 4
96185: PUSH
96186: LD_INT 1
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 3
96195: PUSH
96196: LD_INT 1
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 2
96205: PUSH
96206: LD_INT 0
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 2
96215: PUSH
96216: LD_INT 1
96218: NEG
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 2
96226: PUSH
96227: LD_INT 2
96229: NEG
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PUSH
96235: LD_INT 4
96237: PUSH
96238: LD_INT 2
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: PUSH
96245: LD_INT 4
96247: PUSH
96248: LD_INT 4
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: PUSH
96255: LD_INT 4
96257: PUSH
96258: LD_INT 3
96260: PUSH
96261: EMPTY
96262: LIST
96263: LIST
96264: PUSH
96265: LD_INT 5
96267: PUSH
96268: LD_INT 4
96270: PUSH
96271: EMPTY
96272: LIST
96273: LIST
96274: PUSH
96275: LD_INT 5
96277: PUSH
96278: LD_INT 5
96280: PUSH
96281: EMPTY
96282: LIST
96283: LIST
96284: PUSH
96285: LD_INT 4
96287: PUSH
96288: LD_INT 5
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 3
96297: PUSH
96298: LD_INT 4
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 3
96307: PUSH
96308: LD_INT 3
96310: PUSH
96311: EMPTY
96312: LIST
96313: LIST
96314: PUSH
96315: LD_INT 5
96317: PUSH
96318: LD_INT 3
96320: PUSH
96321: EMPTY
96322: LIST
96323: LIST
96324: PUSH
96325: LD_INT 3
96327: PUSH
96328: LD_INT 5
96330: PUSH
96331: EMPTY
96332: LIST
96333: LIST
96334: PUSH
96335: EMPTY
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96382: LD_ADDR_VAR 0 33
96386: PUSH
96387: LD_INT 4
96389: NEG
96390: PUSH
96391: LD_INT 4
96393: NEG
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 4
96401: NEG
96402: PUSH
96403: LD_INT 5
96405: NEG
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 3
96413: NEG
96414: PUSH
96415: LD_INT 4
96417: NEG
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 3
96425: NEG
96426: PUSH
96427: LD_INT 3
96429: NEG
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 3
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 5
96449: NEG
96450: PUSH
96451: LD_INT 4
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 5
96461: NEG
96462: PUSH
96463: LD_INT 5
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 5
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 5
96485: NEG
96486: PUSH
96487: LD_INT 3
96489: NEG
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 0
96497: PUSH
96498: LD_INT 3
96500: NEG
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 0
96508: PUSH
96509: LD_INT 4
96511: NEG
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 1
96519: PUSH
96520: LD_INT 3
96522: NEG
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 1
96530: PUSH
96531: LD_INT 2
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 0
96541: PUSH
96542: LD_INT 2
96544: NEG
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 1
96552: NEG
96553: PUSH
96554: LD_INT 3
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 1
96564: NEG
96565: PUSH
96566: LD_INT 4
96568: NEG
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 2
96576: PUSH
96577: LD_INT 2
96579: NEG
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 2
96587: NEG
96588: PUSH
96589: LD_INT 4
96591: NEG
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 4
96599: PUSH
96600: LD_INT 0
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 4
96609: PUSH
96610: LD_INT 1
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 5
96620: PUSH
96621: LD_INT 0
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PUSH
96628: LD_INT 5
96630: PUSH
96631: LD_INT 1
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 4
96640: PUSH
96641: LD_INT 1
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 3
96650: PUSH
96651: LD_INT 0
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 3
96660: PUSH
96661: LD_INT 1
96663: NEG
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 3
96671: PUSH
96672: LD_INT 2
96674: NEG
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 5
96682: PUSH
96683: LD_INT 2
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 3
96692: PUSH
96693: LD_INT 3
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 3
96702: PUSH
96703: LD_INT 2
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PUSH
96710: LD_INT 4
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 4
96722: PUSH
96723: LD_INT 4
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: LD_INT 3
96732: PUSH
96733: LD_INT 4
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 2
96742: PUSH
96743: LD_INT 3
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 2
96752: PUSH
96753: LD_INT 2
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: LD_INT 4
96762: PUSH
96763: LD_INT 2
96765: PUSH
96766: EMPTY
96767: LIST
96768: LIST
96769: PUSH
96770: LD_INT 2
96772: PUSH
96773: LD_INT 4
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: PUSH
96780: LD_INT 0
96782: PUSH
96783: LD_INT 4
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PUSH
96790: LD_INT 0
96792: PUSH
96793: LD_INT 3
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: PUSH
96800: LD_INT 1
96802: PUSH
96803: LD_INT 4
96805: PUSH
96806: EMPTY
96807: LIST
96808: LIST
96809: PUSH
96810: LD_INT 1
96812: PUSH
96813: LD_INT 5
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PUSH
96820: LD_INT 0
96822: PUSH
96823: LD_INT 5
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PUSH
96830: LD_INT 1
96832: NEG
96833: PUSH
96834: LD_INT 4
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 1
96843: NEG
96844: PUSH
96845: LD_INT 3
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 2
96854: PUSH
96855: LD_INT 5
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 2
96864: NEG
96865: PUSH
96866: LD_INT 3
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96920: LD_ADDR_VAR 0 34
96924: PUSH
96925: LD_INT 0
96927: PUSH
96928: LD_INT 4
96930: NEG
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 0
96938: PUSH
96939: LD_INT 5
96941: NEG
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: LD_INT 1
96949: PUSH
96950: LD_INT 4
96952: NEG
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 1
96960: PUSH
96961: LD_INT 3
96963: NEG
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 0
96971: PUSH
96972: LD_INT 3
96974: NEG
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: PUSH
96980: LD_INT 1
96982: NEG
96983: PUSH
96984: LD_INT 4
96986: NEG
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 1
96994: NEG
96995: PUSH
96996: LD_INT 5
96998: NEG
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 2
97006: PUSH
97007: LD_INT 3
97009: NEG
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 2
97017: NEG
97018: PUSH
97019: LD_INT 5
97021: NEG
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 3
97029: PUSH
97030: LD_INT 0
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: LD_INT 3
97039: PUSH
97040: LD_INT 1
97042: NEG
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 4
97050: PUSH
97051: LD_INT 0
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PUSH
97058: LD_INT 4
97060: PUSH
97061: LD_INT 1
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 3
97070: PUSH
97071: LD_INT 1
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 2
97080: PUSH
97081: LD_INT 0
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 2
97090: PUSH
97091: LD_INT 1
97093: NEG
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 2
97101: PUSH
97102: LD_INT 2
97104: NEG
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: PUSH
97110: LD_INT 4
97112: PUSH
97113: LD_INT 2
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: PUSH
97120: LD_INT 4
97122: PUSH
97123: LD_INT 4
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 4
97132: PUSH
97133: LD_INT 3
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 5
97142: PUSH
97143: LD_INT 4
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PUSH
97150: LD_INT 5
97152: PUSH
97153: LD_INT 5
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PUSH
97160: LD_INT 4
97162: PUSH
97163: LD_INT 5
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 3
97172: PUSH
97173: LD_INT 4
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PUSH
97180: LD_INT 3
97182: PUSH
97183: LD_INT 3
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: PUSH
97190: LD_INT 5
97192: PUSH
97193: LD_INT 3
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: PUSH
97200: LD_INT 3
97202: PUSH
97203: LD_INT 5
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: PUSH
97210: LD_INT 0
97212: PUSH
97213: LD_INT 3
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 0
97222: PUSH
97223: LD_INT 2
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 1
97232: PUSH
97233: LD_INT 3
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 1
97242: PUSH
97243: LD_INT 4
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: LD_INT 0
97252: PUSH
97253: LD_INT 4
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PUSH
97260: LD_INT 1
97262: NEG
97263: PUSH
97264: LD_INT 3
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 1
97273: NEG
97274: PUSH
97275: LD_INT 2
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PUSH
97282: LD_INT 2
97284: PUSH
97285: LD_INT 4
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 2
97294: NEG
97295: PUSH
97296: LD_INT 2
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: PUSH
97303: LD_INT 4
97305: NEG
97306: PUSH
97307: LD_INT 0
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: LD_INT 4
97316: NEG
97317: PUSH
97318: LD_INT 1
97320: NEG
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 3
97328: NEG
97329: PUSH
97330: LD_INT 0
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 3
97339: NEG
97340: PUSH
97341: LD_INT 1
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 4
97350: NEG
97351: PUSH
97352: LD_INT 1
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 5
97361: NEG
97362: PUSH
97363: LD_INT 0
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 5
97372: NEG
97373: PUSH
97374: LD_INT 1
97376: NEG
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 5
97384: NEG
97385: PUSH
97386: LD_INT 2
97388: NEG
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: PUSH
97394: LD_INT 3
97396: NEG
97397: PUSH
97398: LD_INT 2
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: PUSH
97405: EMPTY
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: ST_TO_ADDR
// end ; end ;
97452: GO 97455
97454: POP
// case btype of b_depot , b_warehouse :
97455: LD_VAR 0 1
97459: PUSH
97460: LD_INT 0
97462: DOUBLE
97463: EQUAL
97464: IFTRUE 97474
97466: LD_INT 1
97468: DOUBLE
97469: EQUAL
97470: IFTRUE 97474
97472: GO 97675
97474: POP
// case nation of nation_american :
97475: LD_VAR 0 5
97479: PUSH
97480: LD_INT 1
97482: DOUBLE
97483: EQUAL
97484: IFTRUE 97488
97486: GO 97544
97488: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97489: LD_ADDR_VAR 0 9
97493: PUSH
97494: LD_VAR 0 11
97498: PUSH
97499: LD_VAR 0 12
97503: PUSH
97504: LD_VAR 0 13
97508: PUSH
97509: LD_VAR 0 14
97513: PUSH
97514: LD_VAR 0 15
97518: PUSH
97519: LD_VAR 0 16
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: PUSH
97532: LD_VAR 0 4
97536: PUSH
97537: LD_INT 1
97539: PLUS
97540: ARRAY
97541: ST_TO_ADDR
97542: GO 97673
97544: LD_INT 2
97546: DOUBLE
97547: EQUAL
97548: IFTRUE 97552
97550: GO 97608
97552: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97553: LD_ADDR_VAR 0 9
97557: PUSH
97558: LD_VAR 0 17
97562: PUSH
97563: LD_VAR 0 18
97567: PUSH
97568: LD_VAR 0 19
97572: PUSH
97573: LD_VAR 0 20
97577: PUSH
97578: LD_VAR 0 21
97582: PUSH
97583: LD_VAR 0 22
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: PUSH
97596: LD_VAR 0 4
97600: PUSH
97601: LD_INT 1
97603: PLUS
97604: ARRAY
97605: ST_TO_ADDR
97606: GO 97673
97608: LD_INT 3
97610: DOUBLE
97611: EQUAL
97612: IFTRUE 97616
97614: GO 97672
97616: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97617: LD_ADDR_VAR 0 9
97621: PUSH
97622: LD_VAR 0 23
97626: PUSH
97627: LD_VAR 0 24
97631: PUSH
97632: LD_VAR 0 25
97636: PUSH
97637: LD_VAR 0 26
97641: PUSH
97642: LD_VAR 0 27
97646: PUSH
97647: LD_VAR 0 28
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: PUSH
97660: LD_VAR 0 4
97664: PUSH
97665: LD_INT 1
97667: PLUS
97668: ARRAY
97669: ST_TO_ADDR
97670: GO 97673
97672: POP
97673: GO 98228
97675: LD_INT 2
97677: DOUBLE
97678: EQUAL
97679: IFTRUE 97689
97681: LD_INT 3
97683: DOUBLE
97684: EQUAL
97685: IFTRUE 97689
97687: GO 97745
97689: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97690: LD_ADDR_VAR 0 9
97694: PUSH
97695: LD_VAR 0 29
97699: PUSH
97700: LD_VAR 0 30
97704: PUSH
97705: LD_VAR 0 31
97709: PUSH
97710: LD_VAR 0 32
97714: PUSH
97715: LD_VAR 0 33
97719: PUSH
97720: LD_VAR 0 34
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: PUSH
97733: LD_VAR 0 4
97737: PUSH
97738: LD_INT 1
97740: PLUS
97741: ARRAY
97742: ST_TO_ADDR
97743: GO 98228
97745: LD_INT 16
97747: DOUBLE
97748: EQUAL
97749: IFTRUE 97807
97751: LD_INT 17
97753: DOUBLE
97754: EQUAL
97755: IFTRUE 97807
97757: LD_INT 18
97759: DOUBLE
97760: EQUAL
97761: IFTRUE 97807
97763: LD_INT 19
97765: DOUBLE
97766: EQUAL
97767: IFTRUE 97807
97769: LD_INT 22
97771: DOUBLE
97772: EQUAL
97773: IFTRUE 97807
97775: LD_INT 20
97777: DOUBLE
97778: EQUAL
97779: IFTRUE 97807
97781: LD_INT 21
97783: DOUBLE
97784: EQUAL
97785: IFTRUE 97807
97787: LD_INT 23
97789: DOUBLE
97790: EQUAL
97791: IFTRUE 97807
97793: LD_INT 24
97795: DOUBLE
97796: EQUAL
97797: IFTRUE 97807
97799: LD_INT 25
97801: DOUBLE
97802: EQUAL
97803: IFTRUE 97807
97805: GO 97863
97807: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97808: LD_ADDR_VAR 0 9
97812: PUSH
97813: LD_VAR 0 35
97817: PUSH
97818: LD_VAR 0 36
97822: PUSH
97823: LD_VAR 0 37
97827: PUSH
97828: LD_VAR 0 38
97832: PUSH
97833: LD_VAR 0 39
97837: PUSH
97838: LD_VAR 0 40
97842: PUSH
97843: EMPTY
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: PUSH
97851: LD_VAR 0 4
97855: PUSH
97856: LD_INT 1
97858: PLUS
97859: ARRAY
97860: ST_TO_ADDR
97861: GO 98228
97863: LD_INT 6
97865: DOUBLE
97866: EQUAL
97867: IFTRUE 97919
97869: LD_INT 7
97871: DOUBLE
97872: EQUAL
97873: IFTRUE 97919
97875: LD_INT 8
97877: DOUBLE
97878: EQUAL
97879: IFTRUE 97919
97881: LD_INT 13
97883: DOUBLE
97884: EQUAL
97885: IFTRUE 97919
97887: LD_INT 12
97889: DOUBLE
97890: EQUAL
97891: IFTRUE 97919
97893: LD_INT 15
97895: DOUBLE
97896: EQUAL
97897: IFTRUE 97919
97899: LD_INT 11
97901: DOUBLE
97902: EQUAL
97903: IFTRUE 97919
97905: LD_INT 14
97907: DOUBLE
97908: EQUAL
97909: IFTRUE 97919
97911: LD_INT 10
97913: DOUBLE
97914: EQUAL
97915: IFTRUE 97919
97917: GO 97975
97919: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97920: LD_ADDR_VAR 0 9
97924: PUSH
97925: LD_VAR 0 41
97929: PUSH
97930: LD_VAR 0 42
97934: PUSH
97935: LD_VAR 0 43
97939: PUSH
97940: LD_VAR 0 44
97944: PUSH
97945: LD_VAR 0 45
97949: PUSH
97950: LD_VAR 0 46
97954: PUSH
97955: EMPTY
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: PUSH
97963: LD_VAR 0 4
97967: PUSH
97968: LD_INT 1
97970: PLUS
97971: ARRAY
97972: ST_TO_ADDR
97973: GO 98228
97975: LD_INT 36
97977: DOUBLE
97978: EQUAL
97979: IFTRUE 97983
97981: GO 98039
97983: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97984: LD_ADDR_VAR 0 9
97988: PUSH
97989: LD_VAR 0 47
97993: PUSH
97994: LD_VAR 0 48
97998: PUSH
97999: LD_VAR 0 49
98003: PUSH
98004: LD_VAR 0 50
98008: PUSH
98009: LD_VAR 0 51
98013: PUSH
98014: LD_VAR 0 52
98018: PUSH
98019: EMPTY
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: PUSH
98027: LD_VAR 0 4
98031: PUSH
98032: LD_INT 1
98034: PLUS
98035: ARRAY
98036: ST_TO_ADDR
98037: GO 98228
98039: LD_INT 4
98041: DOUBLE
98042: EQUAL
98043: IFTRUE 98065
98045: LD_INT 5
98047: DOUBLE
98048: EQUAL
98049: IFTRUE 98065
98051: LD_INT 34
98053: DOUBLE
98054: EQUAL
98055: IFTRUE 98065
98057: LD_INT 37
98059: DOUBLE
98060: EQUAL
98061: IFTRUE 98065
98063: GO 98121
98065: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98066: LD_ADDR_VAR 0 9
98070: PUSH
98071: LD_VAR 0 53
98075: PUSH
98076: LD_VAR 0 54
98080: PUSH
98081: LD_VAR 0 55
98085: PUSH
98086: LD_VAR 0 56
98090: PUSH
98091: LD_VAR 0 57
98095: PUSH
98096: LD_VAR 0 58
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: PUSH
98109: LD_VAR 0 4
98113: PUSH
98114: LD_INT 1
98116: PLUS
98117: ARRAY
98118: ST_TO_ADDR
98119: GO 98228
98121: LD_INT 31
98123: DOUBLE
98124: EQUAL
98125: IFTRUE 98171
98127: LD_INT 32
98129: DOUBLE
98130: EQUAL
98131: IFTRUE 98171
98133: LD_INT 33
98135: DOUBLE
98136: EQUAL
98137: IFTRUE 98171
98139: LD_INT 27
98141: DOUBLE
98142: EQUAL
98143: IFTRUE 98171
98145: LD_INT 26
98147: DOUBLE
98148: EQUAL
98149: IFTRUE 98171
98151: LD_INT 28
98153: DOUBLE
98154: EQUAL
98155: IFTRUE 98171
98157: LD_INT 29
98159: DOUBLE
98160: EQUAL
98161: IFTRUE 98171
98163: LD_INT 30
98165: DOUBLE
98166: EQUAL
98167: IFTRUE 98171
98169: GO 98227
98171: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98172: LD_ADDR_VAR 0 9
98176: PUSH
98177: LD_VAR 0 59
98181: PUSH
98182: LD_VAR 0 60
98186: PUSH
98187: LD_VAR 0 61
98191: PUSH
98192: LD_VAR 0 62
98196: PUSH
98197: LD_VAR 0 63
98201: PUSH
98202: LD_VAR 0 64
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: PUSH
98215: LD_VAR 0 4
98219: PUSH
98220: LD_INT 1
98222: PLUS
98223: ARRAY
98224: ST_TO_ADDR
98225: GO 98228
98227: POP
// temp_list2 = [ ] ;
98228: LD_ADDR_VAR 0 10
98232: PUSH
98233: EMPTY
98234: ST_TO_ADDR
// for i in temp_list do
98235: LD_ADDR_VAR 0 8
98239: PUSH
98240: LD_VAR 0 9
98244: PUSH
98245: FOR_IN
98246: IFFALSE 98298
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98248: LD_ADDR_VAR 0 10
98252: PUSH
98253: LD_VAR 0 10
98257: PUSH
98258: LD_VAR 0 8
98262: PUSH
98263: LD_INT 1
98265: ARRAY
98266: PUSH
98267: LD_VAR 0 2
98271: PLUS
98272: PUSH
98273: LD_VAR 0 8
98277: PUSH
98278: LD_INT 2
98280: ARRAY
98281: PUSH
98282: LD_VAR 0 3
98286: PLUS
98287: PUSH
98288: EMPTY
98289: LIST
98290: LIST
98291: PUSH
98292: EMPTY
98293: LIST
98294: ADD
98295: ST_TO_ADDR
98296: GO 98245
98298: POP
98299: POP
// result = temp_list2 ;
98300: LD_ADDR_VAR 0 7
98304: PUSH
98305: LD_VAR 0 10
98309: ST_TO_ADDR
// end ;
98310: LD_VAR 0 7
98314: RET
// export function EnemyInRange ( unit , dist ) ; begin
98315: LD_INT 0
98317: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98318: LD_ADDR_VAR 0 3
98322: PUSH
98323: LD_VAR 0 1
98327: PPUSH
98328: CALL_OW 255
98332: PPUSH
98333: LD_VAR 0 1
98337: PPUSH
98338: CALL_OW 250
98342: PPUSH
98343: LD_VAR 0 1
98347: PPUSH
98348: CALL_OW 251
98352: PPUSH
98353: LD_VAR 0 2
98357: PPUSH
98358: CALL 72419 0 4
98362: PUSH
98363: LD_INT 4
98365: ARRAY
98366: ST_TO_ADDR
// end ;
98367: LD_VAR 0 3
98371: RET
// export function PlayerSeeMe ( unit ) ; begin
98372: LD_INT 0
98374: PPUSH
// result := See ( your_side , unit ) ;
98375: LD_ADDR_VAR 0 2
98379: PUSH
98380: LD_OWVAR 2
98384: PPUSH
98385: LD_VAR 0 1
98389: PPUSH
98390: CALL_OW 292
98394: ST_TO_ADDR
// end ;
98395: LD_VAR 0 2
98399: RET
// export function ReverseDir ( unit ) ; begin
98400: LD_INT 0
98402: PPUSH
// if not unit then
98403: LD_VAR 0 1
98407: NOT
98408: IFFALSE 98412
// exit ;
98410: GO 98435
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98412: LD_ADDR_VAR 0 2
98416: PUSH
98417: LD_VAR 0 1
98421: PPUSH
98422: CALL_OW 254
98426: PUSH
98427: LD_INT 3
98429: PLUS
98430: PUSH
98431: LD_INT 6
98433: MOD
98434: ST_TO_ADDR
// end ;
98435: LD_VAR 0 2
98439: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98440: LD_INT 0
98442: PPUSH
98443: PPUSH
98444: PPUSH
98445: PPUSH
98446: PPUSH
// if not hexes then
98447: LD_VAR 0 2
98451: NOT
98452: IFFALSE 98456
// exit ;
98454: GO 98604
// dist := 9999 ;
98456: LD_ADDR_VAR 0 5
98460: PUSH
98461: LD_INT 9999
98463: ST_TO_ADDR
// for i = 1 to hexes do
98464: LD_ADDR_VAR 0 4
98468: PUSH
98469: DOUBLE
98470: LD_INT 1
98472: DEC
98473: ST_TO_ADDR
98474: LD_VAR 0 2
98478: PUSH
98479: FOR_TO
98480: IFFALSE 98592
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98482: LD_VAR 0 1
98486: PPUSH
98487: LD_VAR 0 2
98491: PUSH
98492: LD_VAR 0 4
98496: ARRAY
98497: PUSH
98498: LD_INT 1
98500: ARRAY
98501: PPUSH
98502: LD_VAR 0 2
98506: PUSH
98507: LD_VAR 0 4
98511: ARRAY
98512: PUSH
98513: LD_INT 2
98515: ARRAY
98516: PPUSH
98517: CALL_OW 297
98521: PUSH
98522: LD_VAR 0 5
98526: LESS
98527: IFFALSE 98590
// begin hex := hexes [ i ] ;
98529: LD_ADDR_VAR 0 7
98533: PUSH
98534: LD_VAR 0 2
98538: PUSH
98539: LD_VAR 0 4
98543: ARRAY
98544: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98545: LD_ADDR_VAR 0 5
98549: PUSH
98550: LD_VAR 0 1
98554: PPUSH
98555: LD_VAR 0 2
98559: PUSH
98560: LD_VAR 0 4
98564: ARRAY
98565: PUSH
98566: LD_INT 1
98568: ARRAY
98569: PPUSH
98570: LD_VAR 0 2
98574: PUSH
98575: LD_VAR 0 4
98579: ARRAY
98580: PUSH
98581: LD_INT 2
98583: ARRAY
98584: PPUSH
98585: CALL_OW 297
98589: ST_TO_ADDR
// end ; end ;
98590: GO 98479
98592: POP
98593: POP
// result := hex ;
98594: LD_ADDR_VAR 0 3
98598: PUSH
98599: LD_VAR 0 7
98603: ST_TO_ADDR
// end ;
98604: LD_VAR 0 3
98608: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98609: LD_INT 0
98611: PPUSH
98612: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98613: LD_VAR 0 1
98617: NOT
98618: PUSH
98619: LD_VAR 0 1
98623: PUSH
98624: LD_INT 21
98626: PUSH
98627: LD_INT 2
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: LD_INT 23
98636: PUSH
98637: LD_INT 2
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PPUSH
98648: CALL_OW 69
98652: IN
98653: NOT
98654: OR
98655: IFFALSE 98659
// exit ;
98657: GO 98706
// for i = 1 to 3 do
98659: LD_ADDR_VAR 0 3
98663: PUSH
98664: DOUBLE
98665: LD_INT 1
98667: DEC
98668: ST_TO_ADDR
98669: LD_INT 3
98671: PUSH
98672: FOR_TO
98673: IFFALSE 98704
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98675: LD_VAR 0 1
98679: PPUSH
98680: CALL_OW 250
98684: PPUSH
98685: LD_VAR 0 1
98689: PPUSH
98690: CALL_OW 251
98694: PPUSH
98695: LD_INT 1
98697: PPUSH
98698: CALL_OW 453
98702: GO 98672
98704: POP
98705: POP
// end ;
98706: LD_VAR 0 2
98710: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98711: LD_INT 0
98713: PPUSH
98714: PPUSH
98715: PPUSH
98716: PPUSH
98717: PPUSH
98718: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98719: LD_VAR 0 1
98723: NOT
98724: PUSH
98725: LD_VAR 0 2
98729: NOT
98730: OR
98731: PUSH
98732: LD_VAR 0 1
98736: PPUSH
98737: CALL_OW 314
98741: OR
98742: IFFALSE 98746
// exit ;
98744: GO 99187
// x := GetX ( enemy_unit ) ;
98746: LD_ADDR_VAR 0 7
98750: PUSH
98751: LD_VAR 0 2
98755: PPUSH
98756: CALL_OW 250
98760: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98761: LD_ADDR_VAR 0 8
98765: PUSH
98766: LD_VAR 0 2
98770: PPUSH
98771: CALL_OW 251
98775: ST_TO_ADDR
// if not x or not y then
98776: LD_VAR 0 7
98780: NOT
98781: PUSH
98782: LD_VAR 0 8
98786: NOT
98787: OR
98788: IFFALSE 98792
// exit ;
98790: GO 99187
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98792: LD_ADDR_VAR 0 6
98796: PUSH
98797: LD_VAR 0 7
98801: PPUSH
98802: LD_INT 0
98804: PPUSH
98805: LD_INT 4
98807: PPUSH
98808: CALL_OW 272
98812: PUSH
98813: LD_VAR 0 8
98817: PPUSH
98818: LD_INT 0
98820: PPUSH
98821: LD_INT 4
98823: PPUSH
98824: CALL_OW 273
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: PUSH
98833: LD_VAR 0 7
98837: PPUSH
98838: LD_INT 1
98840: PPUSH
98841: LD_INT 4
98843: PPUSH
98844: CALL_OW 272
98848: PUSH
98849: LD_VAR 0 8
98853: PPUSH
98854: LD_INT 1
98856: PPUSH
98857: LD_INT 4
98859: PPUSH
98860: CALL_OW 273
98864: PUSH
98865: EMPTY
98866: LIST
98867: LIST
98868: PUSH
98869: LD_VAR 0 7
98873: PPUSH
98874: LD_INT 2
98876: PPUSH
98877: LD_INT 4
98879: PPUSH
98880: CALL_OW 272
98884: PUSH
98885: LD_VAR 0 8
98889: PPUSH
98890: LD_INT 2
98892: PPUSH
98893: LD_INT 4
98895: PPUSH
98896: CALL_OW 273
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: LD_VAR 0 7
98909: PPUSH
98910: LD_INT 3
98912: PPUSH
98913: LD_INT 4
98915: PPUSH
98916: CALL_OW 272
98920: PUSH
98921: LD_VAR 0 8
98925: PPUSH
98926: LD_INT 3
98928: PPUSH
98929: LD_INT 4
98931: PPUSH
98932: CALL_OW 273
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: PUSH
98941: LD_VAR 0 7
98945: PPUSH
98946: LD_INT 4
98948: PPUSH
98949: LD_INT 4
98951: PPUSH
98952: CALL_OW 272
98956: PUSH
98957: LD_VAR 0 8
98961: PPUSH
98962: LD_INT 4
98964: PPUSH
98965: LD_INT 4
98967: PPUSH
98968: CALL_OW 273
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PUSH
98977: LD_VAR 0 7
98981: PPUSH
98982: LD_INT 5
98984: PPUSH
98985: LD_INT 4
98987: PPUSH
98988: CALL_OW 272
98992: PUSH
98993: LD_VAR 0 8
98997: PPUSH
98998: LD_INT 5
99000: PPUSH
99001: LD_INT 4
99003: PPUSH
99004: CALL_OW 273
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: ST_TO_ADDR
// for i = tmp downto 1 do
99021: LD_ADDR_VAR 0 4
99025: PUSH
99026: DOUBLE
99027: LD_VAR 0 6
99031: INC
99032: ST_TO_ADDR
99033: LD_INT 1
99035: PUSH
99036: FOR_DOWNTO
99037: IFFALSE 99138
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99039: LD_VAR 0 6
99043: PUSH
99044: LD_VAR 0 4
99048: ARRAY
99049: PUSH
99050: LD_INT 1
99052: ARRAY
99053: PPUSH
99054: LD_VAR 0 6
99058: PUSH
99059: LD_VAR 0 4
99063: ARRAY
99064: PUSH
99065: LD_INT 2
99067: ARRAY
99068: PPUSH
99069: CALL_OW 488
99073: NOT
99074: PUSH
99075: LD_VAR 0 6
99079: PUSH
99080: LD_VAR 0 4
99084: ARRAY
99085: PUSH
99086: LD_INT 1
99088: ARRAY
99089: PPUSH
99090: LD_VAR 0 6
99094: PUSH
99095: LD_VAR 0 4
99099: ARRAY
99100: PUSH
99101: LD_INT 2
99103: ARRAY
99104: PPUSH
99105: CALL_OW 428
99109: PUSH
99110: LD_INT 0
99112: NONEQUAL
99113: OR
99114: IFFALSE 99136
// tmp := Delete ( tmp , i ) ;
99116: LD_ADDR_VAR 0 6
99120: PUSH
99121: LD_VAR 0 6
99125: PPUSH
99126: LD_VAR 0 4
99130: PPUSH
99131: CALL_OW 3
99135: ST_TO_ADDR
99136: GO 99036
99138: POP
99139: POP
// j := GetClosestHex ( unit , tmp ) ;
99140: LD_ADDR_VAR 0 5
99144: PUSH
99145: LD_VAR 0 1
99149: PPUSH
99150: LD_VAR 0 6
99154: PPUSH
99155: CALL 98440 0 2
99159: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99160: LD_VAR 0 1
99164: PPUSH
99165: LD_VAR 0 5
99169: PUSH
99170: LD_INT 1
99172: ARRAY
99173: PPUSH
99174: LD_VAR 0 5
99178: PUSH
99179: LD_INT 2
99181: ARRAY
99182: PPUSH
99183: CALL_OW 111
// end ;
99187: LD_VAR 0 3
99191: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99192: LD_INT 0
99194: PPUSH
99195: PPUSH
99196: PPUSH
// uc_side = 0 ;
99197: LD_ADDR_OWVAR 20
99201: PUSH
99202: LD_INT 0
99204: ST_TO_ADDR
// uc_nation = 0 ;
99205: LD_ADDR_OWVAR 21
99209: PUSH
99210: LD_INT 0
99212: ST_TO_ADDR
// InitHc ;
99213: CALL_OW 19
// InitVc ;
99217: CALL_OW 20
// if mastodonts then
99221: LD_VAR 0 6
99225: IFFALSE 99292
// for i = 1 to mastodonts do
99227: LD_ADDR_VAR 0 11
99231: PUSH
99232: DOUBLE
99233: LD_INT 1
99235: DEC
99236: ST_TO_ADDR
99237: LD_VAR 0 6
99241: PUSH
99242: FOR_TO
99243: IFFALSE 99290
// begin vc_chassis := 31 ;
99245: LD_ADDR_OWVAR 37
99249: PUSH
99250: LD_INT 31
99252: ST_TO_ADDR
// vc_control := control_rider ;
99253: LD_ADDR_OWVAR 38
99257: PUSH
99258: LD_INT 4
99260: ST_TO_ADDR
// animal := CreateVehicle ;
99261: LD_ADDR_VAR 0 12
99265: PUSH
99266: CALL_OW 45
99270: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99271: LD_VAR 0 12
99275: PPUSH
99276: LD_VAR 0 8
99280: PPUSH
99281: LD_INT 0
99283: PPUSH
99284: CALL 106063 0 3
// end ;
99288: GO 99242
99290: POP
99291: POP
// if horses then
99292: LD_VAR 0 5
99296: IFFALSE 99363
// for i = 1 to horses do
99298: LD_ADDR_VAR 0 11
99302: PUSH
99303: DOUBLE
99304: LD_INT 1
99306: DEC
99307: ST_TO_ADDR
99308: LD_VAR 0 5
99312: PUSH
99313: FOR_TO
99314: IFFALSE 99361
// begin hc_class := 21 ;
99316: LD_ADDR_OWVAR 28
99320: PUSH
99321: LD_INT 21
99323: ST_TO_ADDR
// hc_gallery :=  ;
99324: LD_ADDR_OWVAR 33
99328: PUSH
99329: LD_STRING 
99331: ST_TO_ADDR
// animal := CreateHuman ;
99332: LD_ADDR_VAR 0 12
99336: PUSH
99337: CALL_OW 44
99341: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99342: LD_VAR 0 12
99346: PPUSH
99347: LD_VAR 0 8
99351: PPUSH
99352: LD_INT 0
99354: PPUSH
99355: CALL 106063 0 3
// end ;
99359: GO 99313
99361: POP
99362: POP
// if birds then
99363: LD_VAR 0 1
99367: IFFALSE 99434
// for i = 1 to birds do
99369: LD_ADDR_VAR 0 11
99373: PUSH
99374: DOUBLE
99375: LD_INT 1
99377: DEC
99378: ST_TO_ADDR
99379: LD_VAR 0 1
99383: PUSH
99384: FOR_TO
99385: IFFALSE 99432
// begin hc_class = 18 ;
99387: LD_ADDR_OWVAR 28
99391: PUSH
99392: LD_INT 18
99394: ST_TO_ADDR
// hc_gallery =  ;
99395: LD_ADDR_OWVAR 33
99399: PUSH
99400: LD_STRING 
99402: ST_TO_ADDR
// animal := CreateHuman ;
99403: LD_ADDR_VAR 0 12
99407: PUSH
99408: CALL_OW 44
99412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99413: LD_VAR 0 12
99417: PPUSH
99418: LD_VAR 0 8
99422: PPUSH
99423: LD_INT 0
99425: PPUSH
99426: CALL 106063 0 3
// end ;
99430: GO 99384
99432: POP
99433: POP
// if tigers then
99434: LD_VAR 0 2
99438: IFFALSE 99522
// for i = 1 to tigers do
99440: LD_ADDR_VAR 0 11
99444: PUSH
99445: DOUBLE
99446: LD_INT 1
99448: DEC
99449: ST_TO_ADDR
99450: LD_VAR 0 2
99454: PUSH
99455: FOR_TO
99456: IFFALSE 99520
// begin hc_class = class_tiger ;
99458: LD_ADDR_OWVAR 28
99462: PUSH
99463: LD_INT 14
99465: ST_TO_ADDR
// hc_gallery =  ;
99466: LD_ADDR_OWVAR 33
99470: PUSH
99471: LD_STRING 
99473: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99474: LD_ADDR_OWVAR 35
99478: PUSH
99479: LD_INT 7
99481: NEG
99482: PPUSH
99483: LD_INT 7
99485: PPUSH
99486: CALL_OW 12
99490: ST_TO_ADDR
// animal := CreateHuman ;
99491: LD_ADDR_VAR 0 12
99495: PUSH
99496: CALL_OW 44
99500: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99501: LD_VAR 0 12
99505: PPUSH
99506: LD_VAR 0 8
99510: PPUSH
99511: LD_INT 0
99513: PPUSH
99514: CALL 106063 0 3
// end ;
99518: GO 99455
99520: POP
99521: POP
// if apemans then
99522: LD_VAR 0 3
99526: IFFALSE 99649
// for i = 1 to apemans do
99528: LD_ADDR_VAR 0 11
99532: PUSH
99533: DOUBLE
99534: LD_INT 1
99536: DEC
99537: ST_TO_ADDR
99538: LD_VAR 0 3
99542: PUSH
99543: FOR_TO
99544: IFFALSE 99647
// begin hc_class = class_apeman ;
99546: LD_ADDR_OWVAR 28
99550: PUSH
99551: LD_INT 12
99553: ST_TO_ADDR
// hc_gallery =  ;
99554: LD_ADDR_OWVAR 33
99558: PUSH
99559: LD_STRING 
99561: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99562: LD_ADDR_OWVAR 35
99566: PUSH
99567: LD_INT 5
99569: NEG
99570: PPUSH
99571: LD_INT 5
99573: PPUSH
99574: CALL_OW 12
99578: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99579: LD_ADDR_OWVAR 31
99583: PUSH
99584: LD_INT 1
99586: PPUSH
99587: LD_INT 3
99589: PPUSH
99590: CALL_OW 12
99594: PUSH
99595: LD_INT 1
99597: PPUSH
99598: LD_INT 3
99600: PPUSH
99601: CALL_OW 12
99605: PUSH
99606: LD_INT 0
99608: PUSH
99609: LD_INT 0
99611: PUSH
99612: EMPTY
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: ST_TO_ADDR
// animal := CreateHuman ;
99618: LD_ADDR_VAR 0 12
99622: PUSH
99623: CALL_OW 44
99627: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99628: LD_VAR 0 12
99632: PPUSH
99633: LD_VAR 0 8
99637: PPUSH
99638: LD_INT 0
99640: PPUSH
99641: CALL 106063 0 3
// end ;
99645: GO 99543
99647: POP
99648: POP
// if enchidnas then
99649: LD_VAR 0 4
99653: IFFALSE 99720
// for i = 1 to enchidnas do
99655: LD_ADDR_VAR 0 11
99659: PUSH
99660: DOUBLE
99661: LD_INT 1
99663: DEC
99664: ST_TO_ADDR
99665: LD_VAR 0 4
99669: PUSH
99670: FOR_TO
99671: IFFALSE 99718
// begin hc_class = 13 ;
99673: LD_ADDR_OWVAR 28
99677: PUSH
99678: LD_INT 13
99680: ST_TO_ADDR
// hc_gallery =  ;
99681: LD_ADDR_OWVAR 33
99685: PUSH
99686: LD_STRING 
99688: ST_TO_ADDR
// animal := CreateHuman ;
99689: LD_ADDR_VAR 0 12
99693: PUSH
99694: CALL_OW 44
99698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99699: LD_VAR 0 12
99703: PPUSH
99704: LD_VAR 0 8
99708: PPUSH
99709: LD_INT 0
99711: PPUSH
99712: CALL 106063 0 3
// end ;
99716: GO 99670
99718: POP
99719: POP
// if fishes then
99720: LD_VAR 0 7
99724: IFFALSE 99791
// for i = 1 to fishes do
99726: LD_ADDR_VAR 0 11
99730: PUSH
99731: DOUBLE
99732: LD_INT 1
99734: DEC
99735: ST_TO_ADDR
99736: LD_VAR 0 7
99740: PUSH
99741: FOR_TO
99742: IFFALSE 99789
// begin hc_class = 20 ;
99744: LD_ADDR_OWVAR 28
99748: PUSH
99749: LD_INT 20
99751: ST_TO_ADDR
// hc_gallery =  ;
99752: LD_ADDR_OWVAR 33
99756: PUSH
99757: LD_STRING 
99759: ST_TO_ADDR
// animal := CreateHuman ;
99760: LD_ADDR_VAR 0 12
99764: PUSH
99765: CALL_OW 44
99769: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99770: LD_VAR 0 12
99774: PPUSH
99775: LD_VAR 0 9
99779: PPUSH
99780: LD_INT 0
99782: PPUSH
99783: CALL 106063 0 3
// end ;
99787: GO 99741
99789: POP
99790: POP
// end ;
99791: LD_VAR 0 10
99795: RET
// export function WantHeal ( sci , unit ) ; begin
99796: LD_INT 0
99798: PPUSH
// if GetTaskList ( sci ) > 0 then
99799: LD_VAR 0 1
99803: PPUSH
99804: CALL_OW 437
99808: PUSH
99809: LD_INT 0
99811: GREATER
99812: IFFALSE 99882
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99814: LD_VAR 0 1
99818: PPUSH
99819: CALL_OW 437
99823: PUSH
99824: LD_INT 1
99826: ARRAY
99827: PUSH
99828: LD_INT 1
99830: ARRAY
99831: PUSH
99832: LD_STRING l
99834: EQUAL
99835: PUSH
99836: LD_VAR 0 1
99840: PPUSH
99841: CALL_OW 437
99845: PUSH
99846: LD_INT 1
99848: ARRAY
99849: PUSH
99850: LD_INT 4
99852: ARRAY
99853: PUSH
99854: LD_VAR 0 2
99858: EQUAL
99859: AND
99860: IFFALSE 99872
// result := true else
99862: LD_ADDR_VAR 0 3
99866: PUSH
99867: LD_INT 1
99869: ST_TO_ADDR
99870: GO 99880
// result := false ;
99872: LD_ADDR_VAR 0 3
99876: PUSH
99877: LD_INT 0
99879: ST_TO_ADDR
// end else
99880: GO 99890
// result := false ;
99882: LD_ADDR_VAR 0 3
99886: PUSH
99887: LD_INT 0
99889: ST_TO_ADDR
// end ;
99890: LD_VAR 0 3
99894: RET
// export function HealTarget ( sci ) ; begin
99895: LD_INT 0
99897: PPUSH
// if not sci then
99898: LD_VAR 0 1
99902: NOT
99903: IFFALSE 99907
// exit ;
99905: GO 99972
// result := 0 ;
99907: LD_ADDR_VAR 0 2
99911: PUSH
99912: LD_INT 0
99914: ST_TO_ADDR
// if GetTaskList ( sci ) then
99915: LD_VAR 0 1
99919: PPUSH
99920: CALL_OW 437
99924: IFFALSE 99972
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99926: LD_VAR 0 1
99930: PPUSH
99931: CALL_OW 437
99935: PUSH
99936: LD_INT 1
99938: ARRAY
99939: PUSH
99940: LD_INT 1
99942: ARRAY
99943: PUSH
99944: LD_STRING l
99946: EQUAL
99947: IFFALSE 99972
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99949: LD_ADDR_VAR 0 2
99953: PUSH
99954: LD_VAR 0 1
99958: PPUSH
99959: CALL_OW 437
99963: PUSH
99964: LD_INT 1
99966: ARRAY
99967: PUSH
99968: LD_INT 4
99970: ARRAY
99971: ST_TO_ADDR
// end ;
99972: LD_VAR 0 2
99976: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99977: LD_INT 0
99979: PPUSH
99980: PPUSH
99981: PPUSH
99982: PPUSH
99983: PPUSH
99984: PPUSH
99985: PPUSH
99986: PPUSH
99987: PPUSH
99988: PPUSH
99989: PPUSH
99990: PPUSH
99991: PPUSH
99992: PPUSH
99993: PPUSH
99994: PPUSH
99995: PPUSH
99996: PPUSH
99997: PPUSH
99998: PPUSH
99999: PPUSH
100000: PPUSH
100001: PPUSH
100002: PPUSH
100003: PPUSH
100004: PPUSH
100005: PPUSH
100006: PPUSH
100007: PPUSH
100008: PPUSH
100009: PPUSH
100010: PPUSH
100011: PPUSH
100012: PPUSH
// if not list then
100013: LD_VAR 0 1
100017: NOT
100018: IFFALSE 100022
// exit ;
100020: GO 104674
// base := list [ 1 ] ;
100022: LD_ADDR_VAR 0 3
100026: PUSH
100027: LD_VAR 0 1
100031: PUSH
100032: LD_INT 1
100034: ARRAY
100035: ST_TO_ADDR
// group := list [ 2 ] ;
100036: LD_ADDR_VAR 0 4
100040: PUSH
100041: LD_VAR 0 1
100045: PUSH
100046: LD_INT 2
100048: ARRAY
100049: ST_TO_ADDR
// path := list [ 3 ] ;
100050: LD_ADDR_VAR 0 5
100054: PUSH
100055: LD_VAR 0 1
100059: PUSH
100060: LD_INT 3
100062: ARRAY
100063: ST_TO_ADDR
// flags := list [ 4 ] ;
100064: LD_ADDR_VAR 0 6
100068: PUSH
100069: LD_VAR 0 1
100073: PUSH
100074: LD_INT 4
100076: ARRAY
100077: ST_TO_ADDR
// mined := [ ] ;
100078: LD_ADDR_VAR 0 27
100082: PUSH
100083: EMPTY
100084: ST_TO_ADDR
// bombed := [ ] ;
100085: LD_ADDR_VAR 0 28
100089: PUSH
100090: EMPTY
100091: ST_TO_ADDR
// healers := [ ] ;
100092: LD_ADDR_VAR 0 31
100096: PUSH
100097: EMPTY
100098: ST_TO_ADDR
// to_heal := [ ] ;
100099: LD_ADDR_VAR 0 30
100103: PUSH
100104: EMPTY
100105: ST_TO_ADDR
// repairs := [ ] ;
100106: LD_ADDR_VAR 0 33
100110: PUSH
100111: EMPTY
100112: ST_TO_ADDR
// to_repair := [ ] ;
100113: LD_ADDR_VAR 0 32
100117: PUSH
100118: EMPTY
100119: ST_TO_ADDR
// if not group or not path then
100120: LD_VAR 0 4
100124: NOT
100125: PUSH
100126: LD_VAR 0 5
100130: NOT
100131: OR
100132: IFFALSE 100136
// exit ;
100134: GO 104674
// side := GetSide ( group [ 1 ] ) ;
100136: LD_ADDR_VAR 0 35
100140: PUSH
100141: LD_VAR 0 4
100145: PUSH
100146: LD_INT 1
100148: ARRAY
100149: PPUSH
100150: CALL_OW 255
100154: ST_TO_ADDR
// if flags then
100155: LD_VAR 0 6
100159: IFFALSE 100303
// begin f_ignore_area := flags [ 1 ] ;
100161: LD_ADDR_VAR 0 17
100165: PUSH
100166: LD_VAR 0 6
100170: PUSH
100171: LD_INT 1
100173: ARRAY
100174: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100175: LD_ADDR_VAR 0 18
100179: PUSH
100180: LD_VAR 0 6
100184: PUSH
100185: LD_INT 2
100187: ARRAY
100188: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100189: LD_ADDR_VAR 0 19
100193: PUSH
100194: LD_VAR 0 6
100198: PUSH
100199: LD_INT 3
100201: ARRAY
100202: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100203: LD_ADDR_VAR 0 20
100207: PUSH
100208: LD_VAR 0 6
100212: PUSH
100213: LD_INT 4
100215: ARRAY
100216: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100217: LD_ADDR_VAR 0 21
100221: PUSH
100222: LD_VAR 0 6
100226: PUSH
100227: LD_INT 5
100229: ARRAY
100230: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100231: LD_ADDR_VAR 0 22
100235: PUSH
100236: LD_VAR 0 6
100240: PUSH
100241: LD_INT 6
100243: ARRAY
100244: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100245: LD_ADDR_VAR 0 23
100249: PUSH
100250: LD_VAR 0 6
100254: PUSH
100255: LD_INT 7
100257: ARRAY
100258: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100259: LD_ADDR_VAR 0 24
100263: PUSH
100264: LD_VAR 0 6
100268: PUSH
100269: LD_INT 8
100271: ARRAY
100272: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100273: LD_ADDR_VAR 0 25
100277: PUSH
100278: LD_VAR 0 6
100282: PUSH
100283: LD_INT 9
100285: ARRAY
100286: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100287: LD_ADDR_VAR 0 26
100291: PUSH
100292: LD_VAR 0 6
100296: PUSH
100297: LD_INT 10
100299: ARRAY
100300: ST_TO_ADDR
// end else
100301: GO 100383
// begin f_ignore_area := false ;
100303: LD_ADDR_VAR 0 17
100307: PUSH
100308: LD_INT 0
100310: ST_TO_ADDR
// f_capture := false ;
100311: LD_ADDR_VAR 0 18
100315: PUSH
100316: LD_INT 0
100318: ST_TO_ADDR
// f_ignore_civ := false ;
100319: LD_ADDR_VAR 0 19
100323: PUSH
100324: LD_INT 0
100326: ST_TO_ADDR
// f_murder := false ;
100327: LD_ADDR_VAR 0 20
100331: PUSH
100332: LD_INT 0
100334: ST_TO_ADDR
// f_mines := false ;
100335: LD_ADDR_VAR 0 21
100339: PUSH
100340: LD_INT 0
100342: ST_TO_ADDR
// f_repair := false ;
100343: LD_ADDR_VAR 0 22
100347: PUSH
100348: LD_INT 0
100350: ST_TO_ADDR
// f_heal := false ;
100351: LD_ADDR_VAR 0 23
100355: PUSH
100356: LD_INT 0
100358: ST_TO_ADDR
// f_spacetime := false ;
100359: LD_ADDR_VAR 0 24
100363: PUSH
100364: LD_INT 0
100366: ST_TO_ADDR
// f_attack_depot := false ;
100367: LD_ADDR_VAR 0 25
100371: PUSH
100372: LD_INT 0
100374: ST_TO_ADDR
// f_crawl := false ;
100375: LD_ADDR_VAR 0 26
100379: PUSH
100380: LD_INT 0
100382: ST_TO_ADDR
// end ; if f_heal then
100383: LD_VAR 0 23
100387: IFFALSE 100414
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100389: LD_ADDR_VAR 0 31
100393: PUSH
100394: LD_VAR 0 4
100398: PPUSH
100399: LD_INT 25
100401: PUSH
100402: LD_INT 4
100404: PUSH
100405: EMPTY
100406: LIST
100407: LIST
100408: PPUSH
100409: CALL_OW 72
100413: ST_TO_ADDR
// if f_repair then
100414: LD_VAR 0 22
100418: IFFALSE 100445
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100420: LD_ADDR_VAR 0 33
100424: PUSH
100425: LD_VAR 0 4
100429: PPUSH
100430: LD_INT 25
100432: PUSH
100433: LD_INT 3
100435: PUSH
100436: EMPTY
100437: LIST
100438: LIST
100439: PPUSH
100440: CALL_OW 72
100444: ST_TO_ADDR
// units_path := [ ] ;
100445: LD_ADDR_VAR 0 16
100449: PUSH
100450: EMPTY
100451: ST_TO_ADDR
// for i = 1 to group do
100452: LD_ADDR_VAR 0 7
100456: PUSH
100457: DOUBLE
100458: LD_INT 1
100460: DEC
100461: ST_TO_ADDR
100462: LD_VAR 0 4
100466: PUSH
100467: FOR_TO
100468: IFFALSE 100497
// units_path := Replace ( units_path , i , path ) ;
100470: LD_ADDR_VAR 0 16
100474: PUSH
100475: LD_VAR 0 16
100479: PPUSH
100480: LD_VAR 0 7
100484: PPUSH
100485: LD_VAR 0 5
100489: PPUSH
100490: CALL_OW 1
100494: ST_TO_ADDR
100495: GO 100467
100497: POP
100498: POP
// repeat for i = group downto 1 do
100499: LD_ADDR_VAR 0 7
100503: PUSH
100504: DOUBLE
100505: LD_VAR 0 4
100509: INC
100510: ST_TO_ADDR
100511: LD_INT 1
100513: PUSH
100514: FOR_DOWNTO
100515: IFFALSE 104637
// begin wait ( 5 ) ;
100517: LD_INT 5
100519: PPUSH
100520: CALL_OW 67
// tmp := [ ] ;
100524: LD_ADDR_VAR 0 14
100528: PUSH
100529: EMPTY
100530: ST_TO_ADDR
// attacking := false ;
100531: LD_ADDR_VAR 0 29
100535: PUSH
100536: LD_INT 0
100538: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100539: LD_VAR 0 4
100543: PUSH
100544: LD_VAR 0 7
100548: ARRAY
100549: PPUSH
100550: CALL_OW 301
100554: PUSH
100555: LD_VAR 0 4
100559: PUSH
100560: LD_VAR 0 7
100564: ARRAY
100565: NOT
100566: OR
100567: IFFALSE 100676
// begin if GetType ( group [ i ] ) = unit_human then
100569: LD_VAR 0 4
100573: PUSH
100574: LD_VAR 0 7
100578: ARRAY
100579: PPUSH
100580: CALL_OW 247
100584: PUSH
100585: LD_INT 1
100587: EQUAL
100588: IFFALSE 100634
// begin to_heal := to_heal diff group [ i ] ;
100590: LD_ADDR_VAR 0 30
100594: PUSH
100595: LD_VAR 0 30
100599: PUSH
100600: LD_VAR 0 4
100604: PUSH
100605: LD_VAR 0 7
100609: ARRAY
100610: DIFF
100611: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100612: LD_ADDR_VAR 0 31
100616: PUSH
100617: LD_VAR 0 31
100621: PUSH
100622: LD_VAR 0 4
100626: PUSH
100627: LD_VAR 0 7
100631: ARRAY
100632: DIFF
100633: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100634: LD_ADDR_VAR 0 4
100638: PUSH
100639: LD_VAR 0 4
100643: PPUSH
100644: LD_VAR 0 7
100648: PPUSH
100649: CALL_OW 3
100653: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100654: LD_ADDR_VAR 0 16
100658: PUSH
100659: LD_VAR 0 16
100663: PPUSH
100664: LD_VAR 0 7
100668: PPUSH
100669: CALL_OW 3
100673: ST_TO_ADDR
// continue ;
100674: GO 100514
// end ; if f_repair then
100676: LD_VAR 0 22
100680: IFFALSE 101169
// begin if GetType ( group [ i ] ) = unit_vehicle then
100682: LD_VAR 0 4
100686: PUSH
100687: LD_VAR 0 7
100691: ARRAY
100692: PPUSH
100693: CALL_OW 247
100697: PUSH
100698: LD_INT 2
100700: EQUAL
100701: IFFALSE 100891
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100703: LD_VAR 0 4
100707: PUSH
100708: LD_VAR 0 7
100712: ARRAY
100713: PPUSH
100714: CALL_OW 256
100718: PUSH
100719: LD_INT 700
100721: LESS
100722: PUSH
100723: LD_VAR 0 4
100727: PUSH
100728: LD_VAR 0 7
100732: ARRAY
100733: PUSH
100734: LD_VAR 0 32
100738: IN
100739: NOT
100740: AND
100741: IFFALSE 100765
// to_repair := to_repair union group [ i ] ;
100743: LD_ADDR_VAR 0 32
100747: PUSH
100748: LD_VAR 0 32
100752: PUSH
100753: LD_VAR 0 4
100757: PUSH
100758: LD_VAR 0 7
100762: ARRAY
100763: UNION
100764: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100765: LD_VAR 0 4
100769: PUSH
100770: LD_VAR 0 7
100774: ARRAY
100775: PPUSH
100776: CALL_OW 256
100780: PUSH
100781: LD_INT 1000
100783: EQUAL
100784: PUSH
100785: LD_VAR 0 4
100789: PUSH
100790: LD_VAR 0 7
100794: ARRAY
100795: PUSH
100796: LD_VAR 0 32
100800: IN
100801: AND
100802: IFFALSE 100826
// to_repair := to_repair diff group [ i ] ;
100804: LD_ADDR_VAR 0 32
100808: PUSH
100809: LD_VAR 0 32
100813: PUSH
100814: LD_VAR 0 4
100818: PUSH
100819: LD_VAR 0 7
100823: ARRAY
100824: DIFF
100825: ST_TO_ADDR
// if group [ i ] in to_repair then
100826: LD_VAR 0 4
100830: PUSH
100831: LD_VAR 0 7
100835: ARRAY
100836: PUSH
100837: LD_VAR 0 32
100841: IN
100842: IFFALSE 100889
// begin if not IsInArea ( group [ i ] , f_repair ) then
100844: LD_VAR 0 4
100848: PUSH
100849: LD_VAR 0 7
100853: ARRAY
100854: PPUSH
100855: LD_VAR 0 22
100859: PPUSH
100860: CALL_OW 308
100864: NOT
100865: IFFALSE 100887
// ComMoveToArea ( group [ i ] , f_repair ) ;
100867: LD_VAR 0 4
100871: PUSH
100872: LD_VAR 0 7
100876: ARRAY
100877: PPUSH
100878: LD_VAR 0 22
100882: PPUSH
100883: CALL_OW 113
// continue ;
100887: GO 100514
// end ; end else
100889: GO 101169
// if group [ i ] in repairs then
100891: LD_VAR 0 4
100895: PUSH
100896: LD_VAR 0 7
100900: ARRAY
100901: PUSH
100902: LD_VAR 0 33
100906: IN
100907: IFFALSE 101169
// begin if IsInUnit ( group [ i ] ) then
100909: LD_VAR 0 4
100913: PUSH
100914: LD_VAR 0 7
100918: ARRAY
100919: PPUSH
100920: CALL_OW 310
100924: IFFALSE 100992
// begin z := IsInUnit ( group [ i ] ) ;
100926: LD_ADDR_VAR 0 13
100930: PUSH
100931: LD_VAR 0 4
100935: PUSH
100936: LD_VAR 0 7
100940: ARRAY
100941: PPUSH
100942: CALL_OW 310
100946: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100947: LD_VAR 0 13
100951: PUSH
100952: LD_VAR 0 32
100956: IN
100957: PUSH
100958: LD_VAR 0 13
100962: PPUSH
100963: LD_VAR 0 22
100967: PPUSH
100968: CALL_OW 308
100972: AND
100973: IFFALSE 100990
// ComExitVehicle ( group [ i ] ) ;
100975: LD_VAR 0 4
100979: PUSH
100980: LD_VAR 0 7
100984: ARRAY
100985: PPUSH
100986: CALL_OW 121
// end else
100990: GO 101169
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100992: LD_ADDR_VAR 0 13
100996: PUSH
100997: LD_VAR 0 4
101001: PPUSH
101002: LD_INT 95
101004: PUSH
101005: LD_VAR 0 22
101009: PUSH
101010: EMPTY
101011: LIST
101012: LIST
101013: PUSH
101014: LD_INT 58
101016: PUSH
101017: EMPTY
101018: LIST
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: PPUSH
101024: CALL_OW 72
101028: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101029: LD_VAR 0 4
101033: PUSH
101034: LD_VAR 0 7
101038: ARRAY
101039: PPUSH
101040: CALL_OW 314
101044: NOT
101045: IFFALSE 101167
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101047: LD_ADDR_VAR 0 10
101051: PUSH
101052: LD_VAR 0 13
101056: PPUSH
101057: LD_VAR 0 4
101061: PUSH
101062: LD_VAR 0 7
101066: ARRAY
101067: PPUSH
101068: CALL_OW 74
101072: ST_TO_ADDR
// if not x then
101073: LD_VAR 0 10
101077: NOT
101078: IFFALSE 101082
// continue ;
101080: GO 100514
// if GetLives ( x ) < 1000 then
101082: LD_VAR 0 10
101086: PPUSH
101087: CALL_OW 256
101091: PUSH
101092: LD_INT 1000
101094: LESS
101095: IFFALSE 101119
// ComRepairVehicle ( group [ i ] , x ) else
101097: LD_VAR 0 4
101101: PUSH
101102: LD_VAR 0 7
101106: ARRAY
101107: PPUSH
101108: LD_VAR 0 10
101112: PPUSH
101113: CALL_OW 129
101117: GO 101167
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101119: LD_VAR 0 23
101123: PUSH
101124: LD_VAR 0 4
101128: PUSH
101129: LD_VAR 0 7
101133: ARRAY
101134: PPUSH
101135: CALL_OW 256
101139: PUSH
101140: LD_INT 1000
101142: LESS
101143: AND
101144: NOT
101145: IFFALSE 101167
// ComEnterUnit ( group [ i ] , x ) ;
101147: LD_VAR 0 4
101151: PUSH
101152: LD_VAR 0 7
101156: ARRAY
101157: PPUSH
101158: LD_VAR 0 10
101162: PPUSH
101163: CALL_OW 120
// end ; continue ;
101167: GO 100514
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101169: LD_VAR 0 23
101173: PUSH
101174: LD_VAR 0 4
101178: PUSH
101179: LD_VAR 0 7
101183: ARRAY
101184: PPUSH
101185: CALL_OW 247
101189: PUSH
101190: LD_INT 1
101192: EQUAL
101193: AND
101194: IFFALSE 101672
// begin if group [ i ] in healers then
101196: LD_VAR 0 4
101200: PUSH
101201: LD_VAR 0 7
101205: ARRAY
101206: PUSH
101207: LD_VAR 0 31
101211: IN
101212: IFFALSE 101485
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101214: LD_VAR 0 4
101218: PUSH
101219: LD_VAR 0 7
101223: ARRAY
101224: PPUSH
101225: LD_VAR 0 23
101229: PPUSH
101230: CALL_OW 308
101234: NOT
101235: PUSH
101236: LD_VAR 0 4
101240: PUSH
101241: LD_VAR 0 7
101245: ARRAY
101246: PPUSH
101247: CALL_OW 314
101251: NOT
101252: AND
101253: IFFALSE 101277
// ComMoveToArea ( group [ i ] , f_heal ) else
101255: LD_VAR 0 4
101259: PUSH
101260: LD_VAR 0 7
101264: ARRAY
101265: PPUSH
101266: LD_VAR 0 23
101270: PPUSH
101271: CALL_OW 113
101275: GO 101483
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101277: LD_VAR 0 4
101281: PUSH
101282: LD_VAR 0 7
101286: ARRAY
101287: PPUSH
101288: CALL 99895 0 1
101292: PPUSH
101293: CALL_OW 256
101297: PUSH
101298: LD_INT 1000
101300: EQUAL
101301: IFFALSE 101320
// ComStop ( group [ i ] ) else
101303: LD_VAR 0 4
101307: PUSH
101308: LD_VAR 0 7
101312: ARRAY
101313: PPUSH
101314: CALL_OW 141
101318: GO 101483
// if not HasTask ( group [ i ] ) and to_heal then
101320: LD_VAR 0 4
101324: PUSH
101325: LD_VAR 0 7
101329: ARRAY
101330: PPUSH
101331: CALL_OW 314
101335: NOT
101336: PUSH
101337: LD_VAR 0 30
101341: AND
101342: IFFALSE 101483
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101344: LD_ADDR_VAR 0 13
101348: PUSH
101349: LD_VAR 0 30
101353: PPUSH
101354: LD_INT 3
101356: PUSH
101357: LD_INT 54
101359: PUSH
101360: EMPTY
101361: LIST
101362: PUSH
101363: EMPTY
101364: LIST
101365: LIST
101366: PPUSH
101367: CALL_OW 72
101371: PPUSH
101372: LD_VAR 0 4
101376: PUSH
101377: LD_VAR 0 7
101381: ARRAY
101382: PPUSH
101383: CALL_OW 74
101387: ST_TO_ADDR
// if z then
101388: LD_VAR 0 13
101392: IFFALSE 101483
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101394: LD_INT 91
101396: PUSH
101397: LD_VAR 0 13
101401: PUSH
101402: LD_INT 10
101404: PUSH
101405: EMPTY
101406: LIST
101407: LIST
101408: LIST
101409: PUSH
101410: LD_INT 81
101412: PUSH
101413: LD_VAR 0 13
101417: PPUSH
101418: CALL_OW 255
101422: PUSH
101423: EMPTY
101424: LIST
101425: LIST
101426: PUSH
101427: EMPTY
101428: LIST
101429: LIST
101430: PPUSH
101431: CALL_OW 69
101435: PUSH
101436: LD_INT 0
101438: EQUAL
101439: IFFALSE 101463
// ComHeal ( group [ i ] , z ) else
101441: LD_VAR 0 4
101445: PUSH
101446: LD_VAR 0 7
101450: ARRAY
101451: PPUSH
101452: LD_VAR 0 13
101456: PPUSH
101457: CALL_OW 128
101461: GO 101483
// ComMoveToArea ( group [ i ] , f_heal ) ;
101463: LD_VAR 0 4
101467: PUSH
101468: LD_VAR 0 7
101472: ARRAY
101473: PPUSH
101474: LD_VAR 0 23
101478: PPUSH
101479: CALL_OW 113
// end ; continue ;
101483: GO 100514
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101485: LD_VAR 0 4
101489: PUSH
101490: LD_VAR 0 7
101494: ARRAY
101495: PPUSH
101496: CALL_OW 256
101500: PUSH
101501: LD_INT 700
101503: LESS
101504: PUSH
101505: LD_VAR 0 4
101509: PUSH
101510: LD_VAR 0 7
101514: ARRAY
101515: PUSH
101516: LD_VAR 0 30
101520: IN
101521: NOT
101522: AND
101523: IFFALSE 101547
// to_heal := to_heal union group [ i ] ;
101525: LD_ADDR_VAR 0 30
101529: PUSH
101530: LD_VAR 0 30
101534: PUSH
101535: LD_VAR 0 4
101539: PUSH
101540: LD_VAR 0 7
101544: ARRAY
101545: UNION
101546: ST_TO_ADDR
// if group [ i ] in to_heal then
101547: LD_VAR 0 4
101551: PUSH
101552: LD_VAR 0 7
101556: ARRAY
101557: PUSH
101558: LD_VAR 0 30
101562: IN
101563: IFFALSE 101672
// begin if GetLives ( group [ i ] ) = 1000 then
101565: LD_VAR 0 4
101569: PUSH
101570: LD_VAR 0 7
101574: ARRAY
101575: PPUSH
101576: CALL_OW 256
101580: PUSH
101581: LD_INT 1000
101583: EQUAL
101584: IFFALSE 101610
// to_heal := to_heal diff group [ i ] else
101586: LD_ADDR_VAR 0 30
101590: PUSH
101591: LD_VAR 0 30
101595: PUSH
101596: LD_VAR 0 4
101600: PUSH
101601: LD_VAR 0 7
101605: ARRAY
101606: DIFF
101607: ST_TO_ADDR
101608: GO 101672
// begin if not IsInArea ( group [ i ] , to_heal ) then
101610: LD_VAR 0 4
101614: PUSH
101615: LD_VAR 0 7
101619: ARRAY
101620: PPUSH
101621: LD_VAR 0 30
101625: PPUSH
101626: CALL_OW 308
101630: NOT
101631: IFFALSE 101655
// ComMoveToArea ( group [ i ] , f_heal ) else
101633: LD_VAR 0 4
101637: PUSH
101638: LD_VAR 0 7
101642: ARRAY
101643: PPUSH
101644: LD_VAR 0 23
101648: PPUSH
101649: CALL_OW 113
101653: GO 101670
// ComHold ( group [ i ] ) ;
101655: LD_VAR 0 4
101659: PUSH
101660: LD_VAR 0 7
101664: ARRAY
101665: PPUSH
101666: CALL_OW 140
// continue ;
101670: GO 100514
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101672: LD_VAR 0 4
101676: PUSH
101677: LD_VAR 0 7
101681: ARRAY
101682: PPUSH
101683: LD_INT 10
101685: PPUSH
101686: CALL 98315 0 2
101690: NOT
101691: PUSH
101692: LD_VAR 0 16
101696: PUSH
101697: LD_VAR 0 7
101701: ARRAY
101702: PUSH
101703: EMPTY
101704: EQUAL
101705: NOT
101706: AND
101707: IFFALSE 101973
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101709: LD_VAR 0 4
101713: PUSH
101714: LD_VAR 0 7
101718: ARRAY
101719: PPUSH
101720: CALL_OW 262
101724: PUSH
101725: LD_INT 1
101727: PUSH
101728: LD_INT 2
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: IN
101735: IFFALSE 101776
// if GetFuel ( group [ i ] ) < 10 then
101737: LD_VAR 0 4
101741: PUSH
101742: LD_VAR 0 7
101746: ARRAY
101747: PPUSH
101748: CALL_OW 261
101752: PUSH
101753: LD_INT 10
101755: LESS
101756: IFFALSE 101776
// SetFuel ( group [ i ] , 12 ) ;
101758: LD_VAR 0 4
101762: PUSH
101763: LD_VAR 0 7
101767: ARRAY
101768: PPUSH
101769: LD_INT 12
101771: PPUSH
101772: CALL_OW 240
// if units_path [ i ] then
101776: LD_VAR 0 16
101780: PUSH
101781: LD_VAR 0 7
101785: ARRAY
101786: IFFALSE 101971
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101788: LD_VAR 0 4
101792: PUSH
101793: LD_VAR 0 7
101797: ARRAY
101798: PPUSH
101799: LD_VAR 0 16
101803: PUSH
101804: LD_VAR 0 7
101808: ARRAY
101809: PUSH
101810: LD_INT 1
101812: ARRAY
101813: PUSH
101814: LD_INT 1
101816: ARRAY
101817: PPUSH
101818: LD_VAR 0 16
101822: PUSH
101823: LD_VAR 0 7
101827: ARRAY
101828: PUSH
101829: LD_INT 1
101831: ARRAY
101832: PUSH
101833: LD_INT 2
101835: ARRAY
101836: PPUSH
101837: CALL_OW 297
101841: PUSH
101842: LD_INT 6
101844: GREATER
101845: IFFALSE 101920
// begin if not HasTask ( group [ i ] ) then
101847: LD_VAR 0 4
101851: PUSH
101852: LD_VAR 0 7
101856: ARRAY
101857: PPUSH
101858: CALL_OW 314
101862: NOT
101863: IFFALSE 101918
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101865: LD_VAR 0 4
101869: PUSH
101870: LD_VAR 0 7
101874: ARRAY
101875: PPUSH
101876: LD_VAR 0 16
101880: PUSH
101881: LD_VAR 0 7
101885: ARRAY
101886: PUSH
101887: LD_INT 1
101889: ARRAY
101890: PUSH
101891: LD_INT 1
101893: ARRAY
101894: PPUSH
101895: LD_VAR 0 16
101899: PUSH
101900: LD_VAR 0 7
101904: ARRAY
101905: PUSH
101906: LD_INT 1
101908: ARRAY
101909: PUSH
101910: LD_INT 2
101912: ARRAY
101913: PPUSH
101914: CALL_OW 114
// end else
101918: GO 101971
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101920: LD_ADDR_VAR 0 15
101924: PUSH
101925: LD_VAR 0 16
101929: PUSH
101930: LD_VAR 0 7
101934: ARRAY
101935: PPUSH
101936: LD_INT 1
101938: PPUSH
101939: CALL_OW 3
101943: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101944: LD_ADDR_VAR 0 16
101948: PUSH
101949: LD_VAR 0 16
101953: PPUSH
101954: LD_VAR 0 7
101958: PPUSH
101959: LD_VAR 0 15
101963: PPUSH
101964: CALL_OW 1
101968: ST_TO_ADDR
// continue ;
101969: GO 100514
// end ; end ; end else
101971: GO 104635
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101973: LD_ADDR_VAR 0 14
101977: PUSH
101978: LD_INT 81
101980: PUSH
101981: LD_VAR 0 4
101985: PUSH
101986: LD_VAR 0 7
101990: ARRAY
101991: PPUSH
101992: CALL_OW 255
101996: PUSH
101997: EMPTY
101998: LIST
101999: LIST
102000: PPUSH
102001: CALL_OW 69
102005: ST_TO_ADDR
// if not tmp then
102006: LD_VAR 0 14
102010: NOT
102011: IFFALSE 102015
// continue ;
102013: GO 100514
// if f_ignore_area then
102015: LD_VAR 0 17
102019: IFFALSE 102107
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102021: LD_ADDR_VAR 0 15
102025: PUSH
102026: LD_VAR 0 14
102030: PPUSH
102031: LD_INT 3
102033: PUSH
102034: LD_INT 92
102036: PUSH
102037: LD_VAR 0 17
102041: PUSH
102042: LD_INT 1
102044: ARRAY
102045: PUSH
102046: LD_VAR 0 17
102050: PUSH
102051: LD_INT 2
102053: ARRAY
102054: PUSH
102055: LD_VAR 0 17
102059: PUSH
102060: LD_INT 3
102062: ARRAY
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: LIST
102068: LIST
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: PPUSH
102074: CALL_OW 72
102078: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102079: LD_VAR 0 14
102083: PUSH
102084: LD_VAR 0 15
102088: DIFF
102089: IFFALSE 102107
// tmp := tmp diff tmp2 ;
102091: LD_ADDR_VAR 0 14
102095: PUSH
102096: LD_VAR 0 14
102100: PUSH
102101: LD_VAR 0 15
102105: DIFF
102106: ST_TO_ADDR
// end ; if not f_murder then
102107: LD_VAR 0 20
102111: NOT
102112: IFFALSE 102170
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102114: LD_ADDR_VAR 0 15
102118: PUSH
102119: LD_VAR 0 14
102123: PPUSH
102124: LD_INT 3
102126: PUSH
102127: LD_INT 50
102129: PUSH
102130: EMPTY
102131: LIST
102132: PUSH
102133: EMPTY
102134: LIST
102135: LIST
102136: PPUSH
102137: CALL_OW 72
102141: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102142: LD_VAR 0 14
102146: PUSH
102147: LD_VAR 0 15
102151: DIFF
102152: IFFALSE 102170
// tmp := tmp diff tmp2 ;
102154: LD_ADDR_VAR 0 14
102158: PUSH
102159: LD_VAR 0 14
102163: PUSH
102164: LD_VAR 0 15
102168: DIFF
102169: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102170: LD_ADDR_VAR 0 14
102174: PUSH
102175: LD_VAR 0 4
102179: PUSH
102180: LD_VAR 0 7
102184: ARRAY
102185: PPUSH
102186: LD_VAR 0 14
102190: PPUSH
102191: LD_INT 1
102193: PPUSH
102194: LD_INT 1
102196: PPUSH
102197: CALL 71958 0 4
102201: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102202: LD_VAR 0 4
102206: PUSH
102207: LD_VAR 0 7
102211: ARRAY
102212: PPUSH
102213: CALL_OW 257
102217: PUSH
102218: LD_INT 1
102220: EQUAL
102221: IFFALSE 102669
// begin if WantPlant ( group [ i ] ) then
102223: LD_VAR 0 4
102227: PUSH
102228: LD_VAR 0 7
102232: ARRAY
102233: PPUSH
102234: CALL 71459 0 1
102238: IFFALSE 102242
// continue ;
102240: GO 100514
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102242: LD_VAR 0 18
102246: PUSH
102247: LD_VAR 0 4
102251: PUSH
102252: LD_VAR 0 7
102256: ARRAY
102257: PPUSH
102258: CALL_OW 310
102262: NOT
102263: AND
102264: PUSH
102265: LD_VAR 0 14
102269: PUSH
102270: LD_INT 1
102272: ARRAY
102273: PUSH
102274: LD_VAR 0 14
102278: PPUSH
102279: LD_INT 21
102281: PUSH
102282: LD_INT 2
102284: PUSH
102285: EMPTY
102286: LIST
102287: LIST
102288: PUSH
102289: LD_INT 58
102291: PUSH
102292: EMPTY
102293: LIST
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: PPUSH
102299: CALL_OW 72
102303: IN
102304: AND
102305: IFFALSE 102341
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102307: LD_VAR 0 4
102311: PUSH
102312: LD_VAR 0 7
102316: ARRAY
102317: PPUSH
102318: LD_VAR 0 14
102322: PUSH
102323: LD_INT 1
102325: ARRAY
102326: PPUSH
102327: CALL_OW 120
// attacking := true ;
102331: LD_ADDR_VAR 0 29
102335: PUSH
102336: LD_INT 1
102338: ST_TO_ADDR
// continue ;
102339: GO 100514
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102341: LD_VAR 0 26
102345: PUSH
102346: LD_VAR 0 4
102350: PUSH
102351: LD_VAR 0 7
102355: ARRAY
102356: PPUSH
102357: CALL_OW 257
102361: PUSH
102362: LD_INT 1
102364: EQUAL
102365: AND
102366: PUSH
102367: LD_VAR 0 4
102371: PUSH
102372: LD_VAR 0 7
102376: ARRAY
102377: PPUSH
102378: CALL_OW 256
102382: PUSH
102383: LD_INT 800
102385: LESS
102386: AND
102387: PUSH
102388: LD_VAR 0 4
102392: PUSH
102393: LD_VAR 0 7
102397: ARRAY
102398: PPUSH
102399: CALL_OW 318
102403: NOT
102404: AND
102405: IFFALSE 102422
// ComCrawl ( group [ i ] ) ;
102407: LD_VAR 0 4
102411: PUSH
102412: LD_VAR 0 7
102416: ARRAY
102417: PPUSH
102418: CALL_OW 137
// if f_mines then
102422: LD_VAR 0 21
102426: IFFALSE 102669
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102428: LD_VAR 0 14
102432: PUSH
102433: LD_INT 1
102435: ARRAY
102436: PPUSH
102437: CALL_OW 247
102441: PUSH
102442: LD_INT 3
102444: EQUAL
102445: PUSH
102446: LD_VAR 0 14
102450: PUSH
102451: LD_INT 1
102453: ARRAY
102454: PUSH
102455: LD_VAR 0 27
102459: IN
102460: NOT
102461: AND
102462: IFFALSE 102669
// begin x := GetX ( tmp [ 1 ] ) ;
102464: LD_ADDR_VAR 0 10
102468: PUSH
102469: LD_VAR 0 14
102473: PUSH
102474: LD_INT 1
102476: ARRAY
102477: PPUSH
102478: CALL_OW 250
102482: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102483: LD_ADDR_VAR 0 11
102487: PUSH
102488: LD_VAR 0 14
102492: PUSH
102493: LD_INT 1
102495: ARRAY
102496: PPUSH
102497: CALL_OW 251
102501: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102502: LD_ADDR_VAR 0 12
102506: PUSH
102507: LD_VAR 0 4
102511: PUSH
102512: LD_VAR 0 7
102516: ARRAY
102517: PPUSH
102518: CALL 98400 0 1
102522: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102523: LD_VAR 0 4
102527: PUSH
102528: LD_VAR 0 7
102532: ARRAY
102533: PPUSH
102534: LD_VAR 0 10
102538: PPUSH
102539: LD_VAR 0 11
102543: PPUSH
102544: LD_VAR 0 14
102548: PUSH
102549: LD_INT 1
102551: ARRAY
102552: PPUSH
102553: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102557: LD_VAR 0 4
102561: PUSH
102562: LD_VAR 0 7
102566: ARRAY
102567: PPUSH
102568: LD_VAR 0 10
102572: PPUSH
102573: LD_VAR 0 12
102577: PPUSH
102578: LD_INT 7
102580: PPUSH
102581: CALL_OW 272
102585: PPUSH
102586: LD_VAR 0 11
102590: PPUSH
102591: LD_VAR 0 12
102595: PPUSH
102596: LD_INT 7
102598: PPUSH
102599: CALL_OW 273
102603: PPUSH
102604: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102608: LD_VAR 0 4
102612: PUSH
102613: LD_VAR 0 7
102617: ARRAY
102618: PPUSH
102619: LD_INT 71
102621: PPUSH
102622: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102626: LD_ADDR_VAR 0 27
102630: PUSH
102631: LD_VAR 0 27
102635: PPUSH
102636: LD_VAR 0 27
102640: PUSH
102641: LD_INT 1
102643: PLUS
102644: PPUSH
102645: LD_VAR 0 14
102649: PUSH
102650: LD_INT 1
102652: ARRAY
102653: PPUSH
102654: CALL_OW 1
102658: ST_TO_ADDR
// attacking := true ;
102659: LD_ADDR_VAR 0 29
102663: PUSH
102664: LD_INT 1
102666: ST_TO_ADDR
// continue ;
102667: GO 100514
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102669: LD_VAR 0 4
102673: PUSH
102674: LD_VAR 0 7
102678: ARRAY
102679: PPUSH
102680: CALL_OW 257
102684: PUSH
102685: LD_INT 17
102687: EQUAL
102688: PUSH
102689: LD_VAR 0 4
102693: PUSH
102694: LD_VAR 0 7
102698: ARRAY
102699: PPUSH
102700: CALL_OW 110
102704: PUSH
102705: LD_INT 71
102707: EQUAL
102708: NOT
102709: AND
102710: IFFALSE 102856
// begin attacking := false ;
102712: LD_ADDR_VAR 0 29
102716: PUSH
102717: LD_INT 0
102719: ST_TO_ADDR
// k := 5 ;
102720: LD_ADDR_VAR 0 9
102724: PUSH
102725: LD_INT 5
102727: ST_TO_ADDR
// if tmp < k then
102728: LD_VAR 0 14
102732: PUSH
102733: LD_VAR 0 9
102737: LESS
102738: IFFALSE 102750
// k := tmp ;
102740: LD_ADDR_VAR 0 9
102744: PUSH
102745: LD_VAR 0 14
102749: ST_TO_ADDR
// for j = 1 to k do
102750: LD_ADDR_VAR 0 8
102754: PUSH
102755: DOUBLE
102756: LD_INT 1
102758: DEC
102759: ST_TO_ADDR
102760: LD_VAR 0 9
102764: PUSH
102765: FOR_TO
102766: IFFALSE 102854
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102768: LD_VAR 0 14
102772: PUSH
102773: LD_VAR 0 8
102777: ARRAY
102778: PUSH
102779: LD_VAR 0 14
102783: PPUSH
102784: LD_INT 58
102786: PUSH
102787: EMPTY
102788: LIST
102789: PPUSH
102790: CALL_OW 72
102794: IN
102795: NOT
102796: IFFALSE 102852
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102798: LD_VAR 0 4
102802: PUSH
102803: LD_VAR 0 7
102807: ARRAY
102808: PPUSH
102809: LD_VAR 0 14
102813: PUSH
102814: LD_VAR 0 8
102818: ARRAY
102819: PPUSH
102820: CALL_OW 115
// attacking := true ;
102824: LD_ADDR_VAR 0 29
102828: PUSH
102829: LD_INT 1
102831: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102832: LD_VAR 0 4
102836: PUSH
102837: LD_VAR 0 7
102841: ARRAY
102842: PPUSH
102843: LD_INT 71
102845: PPUSH
102846: CALL_OW 109
// continue ;
102850: GO 102765
// end ; end ;
102852: GO 102765
102854: POP
102855: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102856: LD_VAR 0 4
102860: PUSH
102861: LD_VAR 0 7
102865: ARRAY
102866: PPUSH
102867: CALL_OW 257
102871: PUSH
102872: LD_INT 8
102874: EQUAL
102875: PUSH
102876: LD_VAR 0 4
102880: PUSH
102881: LD_VAR 0 7
102885: ARRAY
102886: PPUSH
102887: CALL_OW 264
102891: PUSH
102892: LD_INT 28
102894: PUSH
102895: LD_INT 45
102897: PUSH
102898: LD_INT 7
102900: PUSH
102901: LD_INT 47
102903: PUSH
102904: EMPTY
102905: LIST
102906: LIST
102907: LIST
102908: LIST
102909: IN
102910: OR
102911: IFFALSE 103167
// begin attacking := false ;
102913: LD_ADDR_VAR 0 29
102917: PUSH
102918: LD_INT 0
102920: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102921: LD_VAR 0 14
102925: PUSH
102926: LD_INT 1
102928: ARRAY
102929: PPUSH
102930: CALL_OW 266
102934: PUSH
102935: LD_INT 32
102937: PUSH
102938: LD_INT 31
102940: PUSH
102941: LD_INT 33
102943: PUSH
102944: LD_INT 4
102946: PUSH
102947: LD_INT 5
102949: PUSH
102950: EMPTY
102951: LIST
102952: LIST
102953: LIST
102954: LIST
102955: LIST
102956: IN
102957: IFFALSE 103143
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102959: LD_ADDR_VAR 0 9
102963: PUSH
102964: LD_VAR 0 14
102968: PUSH
102969: LD_INT 1
102971: ARRAY
102972: PPUSH
102973: CALL_OW 266
102977: PPUSH
102978: LD_VAR 0 14
102982: PUSH
102983: LD_INT 1
102985: ARRAY
102986: PPUSH
102987: CALL_OW 250
102991: PPUSH
102992: LD_VAR 0 14
102996: PUSH
102997: LD_INT 1
102999: ARRAY
103000: PPUSH
103001: CALL_OW 251
103005: PPUSH
103006: LD_VAR 0 14
103010: PUSH
103011: LD_INT 1
103013: ARRAY
103014: PPUSH
103015: CALL_OW 254
103019: PPUSH
103020: LD_VAR 0 14
103024: PUSH
103025: LD_INT 1
103027: ARRAY
103028: PPUSH
103029: CALL_OW 248
103033: PPUSH
103034: LD_INT 0
103036: PPUSH
103037: CALL 79770 0 6
103041: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103042: LD_ADDR_VAR 0 8
103046: PUSH
103047: LD_VAR 0 4
103051: PUSH
103052: LD_VAR 0 7
103056: ARRAY
103057: PPUSH
103058: LD_VAR 0 9
103062: PPUSH
103063: CALL 98440 0 2
103067: ST_TO_ADDR
// if j then
103068: LD_VAR 0 8
103072: IFFALSE 103141
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103074: LD_VAR 0 8
103078: PUSH
103079: LD_INT 1
103081: ARRAY
103082: PPUSH
103083: LD_VAR 0 8
103087: PUSH
103088: LD_INT 2
103090: ARRAY
103091: PPUSH
103092: CALL_OW 488
103096: IFFALSE 103141
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103098: LD_VAR 0 4
103102: PUSH
103103: LD_VAR 0 7
103107: ARRAY
103108: PPUSH
103109: LD_VAR 0 8
103113: PUSH
103114: LD_INT 1
103116: ARRAY
103117: PPUSH
103118: LD_VAR 0 8
103122: PUSH
103123: LD_INT 2
103125: ARRAY
103126: PPUSH
103127: CALL_OW 116
// attacking := true ;
103131: LD_ADDR_VAR 0 29
103135: PUSH
103136: LD_INT 1
103138: ST_TO_ADDR
// continue ;
103139: GO 100514
// end ; end else
103141: GO 103167
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103143: LD_VAR 0 4
103147: PUSH
103148: LD_VAR 0 7
103152: ARRAY
103153: PPUSH
103154: LD_VAR 0 14
103158: PUSH
103159: LD_INT 1
103161: ARRAY
103162: PPUSH
103163: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103167: LD_VAR 0 4
103171: PUSH
103172: LD_VAR 0 7
103176: ARRAY
103177: PPUSH
103178: CALL_OW 265
103182: PUSH
103183: LD_INT 11
103185: EQUAL
103186: IFFALSE 103464
// begin k := 10 ;
103188: LD_ADDR_VAR 0 9
103192: PUSH
103193: LD_INT 10
103195: ST_TO_ADDR
// x := 0 ;
103196: LD_ADDR_VAR 0 10
103200: PUSH
103201: LD_INT 0
103203: ST_TO_ADDR
// if tmp < k then
103204: LD_VAR 0 14
103208: PUSH
103209: LD_VAR 0 9
103213: LESS
103214: IFFALSE 103226
// k := tmp ;
103216: LD_ADDR_VAR 0 9
103220: PUSH
103221: LD_VAR 0 14
103225: ST_TO_ADDR
// for j = k downto 1 do
103226: LD_ADDR_VAR 0 8
103230: PUSH
103231: DOUBLE
103232: LD_VAR 0 9
103236: INC
103237: ST_TO_ADDR
103238: LD_INT 1
103240: PUSH
103241: FOR_DOWNTO
103242: IFFALSE 103317
// begin if GetType ( tmp [ j ] ) = unit_human then
103244: LD_VAR 0 14
103248: PUSH
103249: LD_VAR 0 8
103253: ARRAY
103254: PPUSH
103255: CALL_OW 247
103259: PUSH
103260: LD_INT 1
103262: EQUAL
103263: IFFALSE 103315
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103265: LD_VAR 0 4
103269: PUSH
103270: LD_VAR 0 7
103274: ARRAY
103275: PPUSH
103276: LD_VAR 0 14
103280: PUSH
103281: LD_VAR 0 8
103285: ARRAY
103286: PPUSH
103287: CALL 98711 0 2
// x := tmp [ j ] ;
103291: LD_ADDR_VAR 0 10
103295: PUSH
103296: LD_VAR 0 14
103300: PUSH
103301: LD_VAR 0 8
103305: ARRAY
103306: ST_TO_ADDR
// attacking := true ;
103307: LD_ADDR_VAR 0 29
103311: PUSH
103312: LD_INT 1
103314: ST_TO_ADDR
// end ; end ;
103315: GO 103241
103317: POP
103318: POP
// if not x then
103319: LD_VAR 0 10
103323: NOT
103324: IFFALSE 103464
// begin attacking := true ;
103326: LD_ADDR_VAR 0 29
103330: PUSH
103331: LD_INT 1
103333: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103334: LD_VAR 0 4
103338: PUSH
103339: LD_VAR 0 7
103343: ARRAY
103344: PPUSH
103345: CALL_OW 250
103349: PPUSH
103350: LD_VAR 0 4
103354: PUSH
103355: LD_VAR 0 7
103359: ARRAY
103360: PPUSH
103361: CALL_OW 251
103365: PPUSH
103366: CALL_OW 546
103370: PUSH
103371: LD_INT 2
103373: ARRAY
103374: PUSH
103375: LD_VAR 0 14
103379: PUSH
103380: LD_INT 1
103382: ARRAY
103383: PPUSH
103384: CALL_OW 250
103388: PPUSH
103389: LD_VAR 0 14
103393: PUSH
103394: LD_INT 1
103396: ARRAY
103397: PPUSH
103398: CALL_OW 251
103402: PPUSH
103403: CALL_OW 546
103407: PUSH
103408: LD_INT 2
103410: ARRAY
103411: EQUAL
103412: IFFALSE 103440
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103414: LD_VAR 0 4
103418: PUSH
103419: LD_VAR 0 7
103423: ARRAY
103424: PPUSH
103425: LD_VAR 0 14
103429: PUSH
103430: LD_INT 1
103432: ARRAY
103433: PPUSH
103434: CALL 98711 0 2
103438: GO 103464
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103440: LD_VAR 0 4
103444: PUSH
103445: LD_VAR 0 7
103449: ARRAY
103450: PPUSH
103451: LD_VAR 0 14
103455: PUSH
103456: LD_INT 1
103458: ARRAY
103459: PPUSH
103460: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103464: LD_VAR 0 4
103468: PUSH
103469: LD_VAR 0 7
103473: ARRAY
103474: PPUSH
103475: CALL_OW 264
103479: PUSH
103480: LD_INT 29
103482: EQUAL
103483: IFFALSE 103849
// begin if WantsToAttack ( group [ i ] ) in bombed then
103485: LD_VAR 0 4
103489: PUSH
103490: LD_VAR 0 7
103494: ARRAY
103495: PPUSH
103496: CALL_OW 319
103500: PUSH
103501: LD_VAR 0 28
103505: IN
103506: IFFALSE 103510
// continue ;
103508: GO 100514
// k := 8 ;
103510: LD_ADDR_VAR 0 9
103514: PUSH
103515: LD_INT 8
103517: ST_TO_ADDR
// x := 0 ;
103518: LD_ADDR_VAR 0 10
103522: PUSH
103523: LD_INT 0
103525: ST_TO_ADDR
// if tmp < k then
103526: LD_VAR 0 14
103530: PUSH
103531: LD_VAR 0 9
103535: LESS
103536: IFFALSE 103548
// k := tmp ;
103538: LD_ADDR_VAR 0 9
103542: PUSH
103543: LD_VAR 0 14
103547: ST_TO_ADDR
// for j = 1 to k do
103548: LD_ADDR_VAR 0 8
103552: PUSH
103553: DOUBLE
103554: LD_INT 1
103556: DEC
103557: ST_TO_ADDR
103558: LD_VAR 0 9
103562: PUSH
103563: FOR_TO
103564: IFFALSE 103696
// begin if GetType ( tmp [ j ] ) = unit_building then
103566: LD_VAR 0 14
103570: PUSH
103571: LD_VAR 0 8
103575: ARRAY
103576: PPUSH
103577: CALL_OW 247
103581: PUSH
103582: LD_INT 3
103584: EQUAL
103585: IFFALSE 103694
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103587: LD_VAR 0 14
103591: PUSH
103592: LD_VAR 0 8
103596: ARRAY
103597: PUSH
103598: LD_VAR 0 28
103602: IN
103603: NOT
103604: PUSH
103605: LD_VAR 0 14
103609: PUSH
103610: LD_VAR 0 8
103614: ARRAY
103615: PPUSH
103616: CALL_OW 313
103620: AND
103621: IFFALSE 103694
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103623: LD_VAR 0 4
103627: PUSH
103628: LD_VAR 0 7
103632: ARRAY
103633: PPUSH
103634: LD_VAR 0 14
103638: PUSH
103639: LD_VAR 0 8
103643: ARRAY
103644: PPUSH
103645: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103649: LD_ADDR_VAR 0 28
103653: PUSH
103654: LD_VAR 0 28
103658: PPUSH
103659: LD_VAR 0 28
103663: PUSH
103664: LD_INT 1
103666: PLUS
103667: PPUSH
103668: LD_VAR 0 14
103672: PUSH
103673: LD_VAR 0 8
103677: ARRAY
103678: PPUSH
103679: CALL_OW 1
103683: ST_TO_ADDR
// attacking := true ;
103684: LD_ADDR_VAR 0 29
103688: PUSH
103689: LD_INT 1
103691: ST_TO_ADDR
// break ;
103692: GO 103696
// end ; end ;
103694: GO 103563
103696: POP
103697: POP
// if not attacking and f_attack_depot then
103698: LD_VAR 0 29
103702: NOT
103703: PUSH
103704: LD_VAR 0 25
103708: AND
103709: IFFALSE 103804
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103711: LD_ADDR_VAR 0 13
103715: PUSH
103716: LD_VAR 0 14
103720: PPUSH
103721: LD_INT 2
103723: PUSH
103724: LD_INT 30
103726: PUSH
103727: LD_INT 0
103729: PUSH
103730: EMPTY
103731: LIST
103732: LIST
103733: PUSH
103734: LD_INT 30
103736: PUSH
103737: LD_INT 1
103739: PUSH
103740: EMPTY
103741: LIST
103742: LIST
103743: PUSH
103744: EMPTY
103745: LIST
103746: LIST
103747: LIST
103748: PPUSH
103749: CALL_OW 72
103753: ST_TO_ADDR
// if z then
103754: LD_VAR 0 13
103758: IFFALSE 103804
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103760: LD_VAR 0 4
103764: PUSH
103765: LD_VAR 0 7
103769: ARRAY
103770: PPUSH
103771: LD_VAR 0 13
103775: PPUSH
103776: LD_VAR 0 4
103780: PUSH
103781: LD_VAR 0 7
103785: ARRAY
103786: PPUSH
103787: CALL_OW 74
103791: PPUSH
103792: CALL_OW 115
// attacking := true ;
103796: LD_ADDR_VAR 0 29
103800: PUSH
103801: LD_INT 1
103803: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103804: LD_VAR 0 4
103808: PUSH
103809: LD_VAR 0 7
103813: ARRAY
103814: PPUSH
103815: CALL_OW 256
103819: PUSH
103820: LD_INT 500
103822: LESS
103823: IFFALSE 103849
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103825: LD_VAR 0 4
103829: PUSH
103830: LD_VAR 0 7
103834: ARRAY
103835: PPUSH
103836: LD_VAR 0 14
103840: PUSH
103841: LD_INT 1
103843: ARRAY
103844: PPUSH
103845: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103849: LD_VAR 0 4
103853: PUSH
103854: LD_VAR 0 7
103858: ARRAY
103859: PPUSH
103860: CALL_OW 264
103864: PUSH
103865: LD_INT 49
103867: EQUAL
103868: IFFALSE 103989
// begin if not HasTask ( group [ i ] ) then
103870: LD_VAR 0 4
103874: PUSH
103875: LD_VAR 0 7
103879: ARRAY
103880: PPUSH
103881: CALL_OW 314
103885: NOT
103886: IFFALSE 103989
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103888: LD_ADDR_VAR 0 9
103892: PUSH
103893: LD_INT 81
103895: PUSH
103896: LD_VAR 0 4
103900: PUSH
103901: LD_VAR 0 7
103905: ARRAY
103906: PPUSH
103907: CALL_OW 255
103911: PUSH
103912: EMPTY
103913: LIST
103914: LIST
103915: PPUSH
103916: CALL_OW 69
103920: PPUSH
103921: LD_VAR 0 4
103925: PUSH
103926: LD_VAR 0 7
103930: ARRAY
103931: PPUSH
103932: CALL_OW 74
103936: ST_TO_ADDR
// if k then
103937: LD_VAR 0 9
103941: IFFALSE 103989
// if GetDistUnits ( group [ i ] , k ) > 10 then
103943: LD_VAR 0 4
103947: PUSH
103948: LD_VAR 0 7
103952: ARRAY
103953: PPUSH
103954: LD_VAR 0 9
103958: PPUSH
103959: CALL_OW 296
103963: PUSH
103964: LD_INT 10
103966: GREATER
103967: IFFALSE 103989
// ComMoveUnit ( group [ i ] , k ) ;
103969: LD_VAR 0 4
103973: PUSH
103974: LD_VAR 0 7
103978: ARRAY
103979: PPUSH
103980: LD_VAR 0 9
103984: PPUSH
103985: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103989: LD_VAR 0 4
103993: PUSH
103994: LD_VAR 0 7
103998: ARRAY
103999: PPUSH
104000: CALL_OW 256
104004: PUSH
104005: LD_INT 250
104007: LESS
104008: PUSH
104009: LD_VAR 0 4
104013: PUSH
104014: LD_VAR 0 7
104018: ARRAY
104019: PUSH
104020: LD_INT 21
104022: PUSH
104023: LD_INT 2
104025: PUSH
104026: EMPTY
104027: LIST
104028: LIST
104029: PUSH
104030: LD_INT 23
104032: PUSH
104033: LD_INT 2
104035: PUSH
104036: EMPTY
104037: LIST
104038: LIST
104039: PUSH
104040: EMPTY
104041: LIST
104042: LIST
104043: PPUSH
104044: CALL_OW 69
104048: IN
104049: AND
104050: IFFALSE 104175
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104052: LD_ADDR_VAR 0 9
104056: PUSH
104057: LD_OWVAR 3
104061: PUSH
104062: LD_VAR 0 4
104066: PUSH
104067: LD_VAR 0 7
104071: ARRAY
104072: DIFF
104073: PPUSH
104074: LD_VAR 0 4
104078: PUSH
104079: LD_VAR 0 7
104083: ARRAY
104084: PPUSH
104085: CALL_OW 74
104089: ST_TO_ADDR
// if not k then
104090: LD_VAR 0 9
104094: NOT
104095: IFFALSE 104099
// continue ;
104097: GO 100514
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104099: LD_VAR 0 9
104103: PUSH
104104: LD_INT 81
104106: PUSH
104107: LD_VAR 0 4
104111: PUSH
104112: LD_VAR 0 7
104116: ARRAY
104117: PPUSH
104118: CALL_OW 255
104122: PUSH
104123: EMPTY
104124: LIST
104125: LIST
104126: PPUSH
104127: CALL_OW 69
104131: IN
104132: PUSH
104133: LD_VAR 0 9
104137: PPUSH
104138: LD_VAR 0 4
104142: PUSH
104143: LD_VAR 0 7
104147: ARRAY
104148: PPUSH
104149: CALL_OW 296
104153: PUSH
104154: LD_INT 5
104156: LESS
104157: AND
104158: IFFALSE 104175
// ComAutodestruct ( group [ i ] ) ;
104160: LD_VAR 0 4
104164: PUSH
104165: LD_VAR 0 7
104169: ARRAY
104170: PPUSH
104171: CALL 98609 0 1
// end ; if f_attack_depot then
104175: LD_VAR 0 25
104179: IFFALSE 104291
// begin k := 6 ;
104181: LD_ADDR_VAR 0 9
104185: PUSH
104186: LD_INT 6
104188: ST_TO_ADDR
// if tmp < k then
104189: LD_VAR 0 14
104193: PUSH
104194: LD_VAR 0 9
104198: LESS
104199: IFFALSE 104211
// k := tmp ;
104201: LD_ADDR_VAR 0 9
104205: PUSH
104206: LD_VAR 0 14
104210: ST_TO_ADDR
// for j = 1 to k do
104211: LD_ADDR_VAR 0 8
104215: PUSH
104216: DOUBLE
104217: LD_INT 1
104219: DEC
104220: ST_TO_ADDR
104221: LD_VAR 0 9
104225: PUSH
104226: FOR_TO
104227: IFFALSE 104289
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104229: LD_VAR 0 8
104233: PPUSH
104234: CALL_OW 266
104238: PUSH
104239: LD_INT 0
104241: PUSH
104242: LD_INT 1
104244: PUSH
104245: EMPTY
104246: LIST
104247: LIST
104248: IN
104249: IFFALSE 104287
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104251: LD_VAR 0 4
104255: PUSH
104256: LD_VAR 0 7
104260: ARRAY
104261: PPUSH
104262: LD_VAR 0 14
104266: PUSH
104267: LD_VAR 0 8
104271: ARRAY
104272: PPUSH
104273: CALL_OW 115
// attacking := true ;
104277: LD_ADDR_VAR 0 29
104281: PUSH
104282: LD_INT 1
104284: ST_TO_ADDR
// break ;
104285: GO 104289
// end ;
104287: GO 104226
104289: POP
104290: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104291: LD_VAR 0 4
104295: PUSH
104296: LD_VAR 0 7
104300: ARRAY
104301: PPUSH
104302: CALL_OW 302
104306: PUSH
104307: LD_VAR 0 29
104311: NOT
104312: AND
104313: IFFALSE 104635
// begin if GetTag ( group [ i ] ) = 71 then
104315: LD_VAR 0 4
104319: PUSH
104320: LD_VAR 0 7
104324: ARRAY
104325: PPUSH
104326: CALL_OW 110
104330: PUSH
104331: LD_INT 71
104333: EQUAL
104334: IFFALSE 104375
// begin if HasTask ( group [ i ] ) then
104336: LD_VAR 0 4
104340: PUSH
104341: LD_VAR 0 7
104345: ARRAY
104346: PPUSH
104347: CALL_OW 314
104351: IFFALSE 104357
// continue else
104353: GO 100514
104355: GO 104375
// SetTag ( group [ i ] , 0 ) ;
104357: LD_VAR 0 4
104361: PUSH
104362: LD_VAR 0 7
104366: ARRAY
104367: PPUSH
104368: LD_INT 0
104370: PPUSH
104371: CALL_OW 109
// end ; k := 8 ;
104375: LD_ADDR_VAR 0 9
104379: PUSH
104380: LD_INT 8
104382: ST_TO_ADDR
// x := 0 ;
104383: LD_ADDR_VAR 0 10
104387: PUSH
104388: LD_INT 0
104390: ST_TO_ADDR
// if tmp < k then
104391: LD_VAR 0 14
104395: PUSH
104396: LD_VAR 0 9
104400: LESS
104401: IFFALSE 104413
// k := tmp ;
104403: LD_ADDR_VAR 0 9
104407: PUSH
104408: LD_VAR 0 14
104412: ST_TO_ADDR
// for j = 1 to k do
104413: LD_ADDR_VAR 0 8
104417: PUSH
104418: DOUBLE
104419: LD_INT 1
104421: DEC
104422: ST_TO_ADDR
104423: LD_VAR 0 9
104427: PUSH
104428: FOR_TO
104429: IFFALSE 104527
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104431: LD_VAR 0 14
104435: PUSH
104436: LD_VAR 0 8
104440: ARRAY
104441: PPUSH
104442: CALL_OW 247
104446: PUSH
104447: LD_INT 1
104449: EQUAL
104450: PUSH
104451: LD_VAR 0 14
104455: PUSH
104456: LD_VAR 0 8
104460: ARRAY
104461: PPUSH
104462: CALL_OW 256
104466: PUSH
104467: LD_INT 250
104469: LESS
104470: PUSH
104471: LD_VAR 0 20
104475: AND
104476: PUSH
104477: LD_VAR 0 20
104481: NOT
104482: PUSH
104483: LD_VAR 0 14
104487: PUSH
104488: LD_VAR 0 8
104492: ARRAY
104493: PPUSH
104494: CALL_OW 256
104498: PUSH
104499: LD_INT 250
104501: GREATEREQUAL
104502: AND
104503: OR
104504: AND
104505: IFFALSE 104525
// begin x := tmp [ j ] ;
104507: LD_ADDR_VAR 0 10
104511: PUSH
104512: LD_VAR 0 14
104516: PUSH
104517: LD_VAR 0 8
104521: ARRAY
104522: ST_TO_ADDR
// break ;
104523: GO 104527
// end ;
104525: GO 104428
104527: POP
104528: POP
// if x then
104529: LD_VAR 0 10
104533: IFFALSE 104557
// ComAttackUnit ( group [ i ] , x ) else
104535: LD_VAR 0 4
104539: PUSH
104540: LD_VAR 0 7
104544: ARRAY
104545: PPUSH
104546: LD_VAR 0 10
104550: PPUSH
104551: CALL_OW 115
104555: GO 104581
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104557: LD_VAR 0 4
104561: PUSH
104562: LD_VAR 0 7
104566: ARRAY
104567: PPUSH
104568: LD_VAR 0 14
104572: PUSH
104573: LD_INT 1
104575: ARRAY
104576: PPUSH
104577: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104581: LD_VAR 0 4
104585: PUSH
104586: LD_VAR 0 7
104590: ARRAY
104591: PPUSH
104592: CALL_OW 314
104596: NOT
104597: IFFALSE 104635
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104599: LD_VAR 0 4
104603: PUSH
104604: LD_VAR 0 7
104608: ARRAY
104609: PPUSH
104610: LD_VAR 0 14
104614: PPUSH
104615: LD_VAR 0 4
104619: PUSH
104620: LD_VAR 0 7
104624: ARRAY
104625: PPUSH
104626: CALL_OW 74
104630: PPUSH
104631: CALL_OW 115
// end ; end ; end ;
104635: GO 100514
104637: POP
104638: POP
// wait ( 0 0$1 ) ;
104639: LD_INT 35
104641: PPUSH
104642: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104646: LD_VAR 0 4
104650: PUSH
104651: EMPTY
104652: EQUAL
104653: PUSH
104654: LD_INT 81
104656: PUSH
104657: LD_VAR 0 35
104661: PUSH
104662: EMPTY
104663: LIST
104664: LIST
104665: PPUSH
104666: CALL_OW 69
104670: NOT
104671: OR
104672: IFFALSE 100499
// end ;
104674: LD_VAR 0 2
104678: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104679: LD_INT 0
104681: PPUSH
104682: PPUSH
104683: PPUSH
104684: PPUSH
// if not base_units then
104685: LD_VAR 0 1
104689: NOT
104690: IFFALSE 104694
// exit ;
104692: GO 104781
// result := false ;
104694: LD_ADDR_VAR 0 2
104698: PUSH
104699: LD_INT 0
104701: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104702: LD_ADDR_VAR 0 5
104706: PUSH
104707: LD_VAR 0 1
104711: PPUSH
104712: LD_INT 21
104714: PUSH
104715: LD_INT 3
104717: PUSH
104718: EMPTY
104719: LIST
104720: LIST
104721: PPUSH
104722: CALL_OW 72
104726: ST_TO_ADDR
// if not tmp then
104727: LD_VAR 0 5
104731: NOT
104732: IFFALSE 104736
// exit ;
104734: GO 104781
// for i in tmp do
104736: LD_ADDR_VAR 0 3
104740: PUSH
104741: LD_VAR 0 5
104745: PUSH
104746: FOR_IN
104747: IFFALSE 104779
// begin result := EnemyInRange ( i , 22 ) ;
104749: LD_ADDR_VAR 0 2
104753: PUSH
104754: LD_VAR 0 3
104758: PPUSH
104759: LD_INT 22
104761: PPUSH
104762: CALL 98315 0 2
104766: ST_TO_ADDR
// if result then
104767: LD_VAR 0 2
104771: IFFALSE 104777
// exit ;
104773: POP
104774: POP
104775: GO 104781
// end ;
104777: GO 104746
104779: POP
104780: POP
// end ;
104781: LD_VAR 0 2
104785: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104786: LD_INT 0
104788: PPUSH
104789: PPUSH
// if not units then
104790: LD_VAR 0 1
104794: NOT
104795: IFFALSE 104799
// exit ;
104797: GO 104869
// result := [ ] ;
104799: LD_ADDR_VAR 0 3
104803: PUSH
104804: EMPTY
104805: ST_TO_ADDR
// for i in units do
104806: LD_ADDR_VAR 0 4
104810: PUSH
104811: LD_VAR 0 1
104815: PUSH
104816: FOR_IN
104817: IFFALSE 104867
// if GetTag ( i ) = tag then
104819: LD_VAR 0 4
104823: PPUSH
104824: CALL_OW 110
104828: PUSH
104829: LD_VAR 0 2
104833: EQUAL
104834: IFFALSE 104865
// result := Insert ( result , result + 1 , i ) ;
104836: LD_ADDR_VAR 0 3
104840: PUSH
104841: LD_VAR 0 3
104845: PPUSH
104846: LD_VAR 0 3
104850: PUSH
104851: LD_INT 1
104853: PLUS
104854: PPUSH
104855: LD_VAR 0 4
104859: PPUSH
104860: CALL_OW 2
104864: ST_TO_ADDR
104865: GO 104816
104867: POP
104868: POP
// end ;
104869: LD_VAR 0 3
104873: RET
// export function IsDriver ( un ) ; begin
104874: LD_INT 0
104876: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104877: LD_ADDR_VAR 0 2
104881: PUSH
104882: LD_VAR 0 1
104886: PUSH
104887: LD_INT 55
104889: PUSH
104890: EMPTY
104891: LIST
104892: PPUSH
104893: CALL_OW 69
104897: IN
104898: ST_TO_ADDR
// end ;
104899: LD_VAR 0 2
104903: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104904: LD_INT 0
104906: PPUSH
104907: PPUSH
// list := [ ] ;
104908: LD_ADDR_VAR 0 5
104912: PUSH
104913: EMPTY
104914: ST_TO_ADDR
// case d of 0 :
104915: LD_VAR 0 3
104919: PUSH
104920: LD_INT 0
104922: DOUBLE
104923: EQUAL
104924: IFTRUE 104928
104926: GO 105061
104928: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104929: LD_ADDR_VAR 0 5
104933: PUSH
104934: LD_VAR 0 1
104938: PUSH
104939: LD_INT 4
104941: MINUS
104942: PUSH
104943: LD_VAR 0 2
104947: PUSH
104948: LD_INT 4
104950: MINUS
104951: PUSH
104952: LD_INT 2
104954: PUSH
104955: EMPTY
104956: LIST
104957: LIST
104958: LIST
104959: PUSH
104960: LD_VAR 0 1
104964: PUSH
104965: LD_INT 3
104967: MINUS
104968: PUSH
104969: LD_VAR 0 2
104973: PUSH
104974: LD_INT 1
104976: PUSH
104977: EMPTY
104978: LIST
104979: LIST
104980: LIST
104981: PUSH
104982: LD_VAR 0 1
104986: PUSH
104987: LD_INT 4
104989: PLUS
104990: PUSH
104991: LD_VAR 0 2
104995: PUSH
104996: LD_INT 4
104998: PUSH
104999: EMPTY
105000: LIST
105001: LIST
105002: LIST
105003: PUSH
105004: LD_VAR 0 1
105008: PUSH
105009: LD_INT 3
105011: PLUS
105012: PUSH
105013: LD_VAR 0 2
105017: PUSH
105018: LD_INT 3
105020: PLUS
105021: PUSH
105022: LD_INT 5
105024: PUSH
105025: EMPTY
105026: LIST
105027: LIST
105028: LIST
105029: PUSH
105030: LD_VAR 0 1
105034: PUSH
105035: LD_VAR 0 2
105039: PUSH
105040: LD_INT 4
105042: PLUS
105043: PUSH
105044: LD_INT 0
105046: PUSH
105047: EMPTY
105048: LIST
105049: LIST
105050: LIST
105051: PUSH
105052: EMPTY
105053: LIST
105054: LIST
105055: LIST
105056: LIST
105057: LIST
105058: ST_TO_ADDR
// end ; 1 :
105059: GO 105759
105061: LD_INT 1
105063: DOUBLE
105064: EQUAL
105065: IFTRUE 105069
105067: GO 105202
105069: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105070: LD_ADDR_VAR 0 5
105074: PUSH
105075: LD_VAR 0 1
105079: PUSH
105080: LD_VAR 0 2
105084: PUSH
105085: LD_INT 4
105087: MINUS
105088: PUSH
105089: LD_INT 3
105091: PUSH
105092: EMPTY
105093: LIST
105094: LIST
105095: LIST
105096: PUSH
105097: LD_VAR 0 1
105101: PUSH
105102: LD_INT 3
105104: MINUS
105105: PUSH
105106: LD_VAR 0 2
105110: PUSH
105111: LD_INT 3
105113: MINUS
105114: PUSH
105115: LD_INT 2
105117: PUSH
105118: EMPTY
105119: LIST
105120: LIST
105121: LIST
105122: PUSH
105123: LD_VAR 0 1
105127: PUSH
105128: LD_INT 4
105130: MINUS
105131: PUSH
105132: LD_VAR 0 2
105136: PUSH
105137: LD_INT 1
105139: PUSH
105140: EMPTY
105141: LIST
105142: LIST
105143: LIST
105144: PUSH
105145: LD_VAR 0 1
105149: PUSH
105150: LD_VAR 0 2
105154: PUSH
105155: LD_INT 3
105157: PLUS
105158: PUSH
105159: LD_INT 0
105161: PUSH
105162: EMPTY
105163: LIST
105164: LIST
105165: LIST
105166: PUSH
105167: LD_VAR 0 1
105171: PUSH
105172: LD_INT 4
105174: PLUS
105175: PUSH
105176: LD_VAR 0 2
105180: PUSH
105181: LD_INT 4
105183: PLUS
105184: PUSH
105185: LD_INT 5
105187: PUSH
105188: EMPTY
105189: LIST
105190: LIST
105191: LIST
105192: PUSH
105193: EMPTY
105194: LIST
105195: LIST
105196: LIST
105197: LIST
105198: LIST
105199: ST_TO_ADDR
// end ; 2 :
105200: GO 105759
105202: LD_INT 2
105204: DOUBLE
105205: EQUAL
105206: IFTRUE 105210
105208: GO 105339
105210: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105211: LD_ADDR_VAR 0 5
105215: PUSH
105216: LD_VAR 0 1
105220: PUSH
105221: LD_VAR 0 2
105225: PUSH
105226: LD_INT 3
105228: MINUS
105229: PUSH
105230: LD_INT 3
105232: PUSH
105233: EMPTY
105234: LIST
105235: LIST
105236: LIST
105237: PUSH
105238: LD_VAR 0 1
105242: PUSH
105243: LD_INT 4
105245: PLUS
105246: PUSH
105247: LD_VAR 0 2
105251: PUSH
105252: LD_INT 4
105254: PUSH
105255: EMPTY
105256: LIST
105257: LIST
105258: LIST
105259: PUSH
105260: LD_VAR 0 1
105264: PUSH
105265: LD_VAR 0 2
105269: PUSH
105270: LD_INT 4
105272: PLUS
105273: PUSH
105274: LD_INT 0
105276: PUSH
105277: EMPTY
105278: LIST
105279: LIST
105280: LIST
105281: PUSH
105282: LD_VAR 0 1
105286: PUSH
105287: LD_INT 3
105289: MINUS
105290: PUSH
105291: LD_VAR 0 2
105295: PUSH
105296: LD_INT 1
105298: PUSH
105299: EMPTY
105300: LIST
105301: LIST
105302: LIST
105303: PUSH
105304: LD_VAR 0 1
105308: PUSH
105309: LD_INT 4
105311: MINUS
105312: PUSH
105313: LD_VAR 0 2
105317: PUSH
105318: LD_INT 4
105320: MINUS
105321: PUSH
105322: LD_INT 2
105324: PUSH
105325: EMPTY
105326: LIST
105327: LIST
105328: LIST
105329: PUSH
105330: EMPTY
105331: LIST
105332: LIST
105333: LIST
105334: LIST
105335: LIST
105336: ST_TO_ADDR
// end ; 3 :
105337: GO 105759
105339: LD_INT 3
105341: DOUBLE
105342: EQUAL
105343: IFTRUE 105347
105345: GO 105480
105347: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105348: LD_ADDR_VAR 0 5
105352: PUSH
105353: LD_VAR 0 1
105357: PUSH
105358: LD_INT 3
105360: PLUS
105361: PUSH
105362: LD_VAR 0 2
105366: PUSH
105367: LD_INT 4
105369: PUSH
105370: EMPTY
105371: LIST
105372: LIST
105373: LIST
105374: PUSH
105375: LD_VAR 0 1
105379: PUSH
105380: LD_INT 4
105382: PLUS
105383: PUSH
105384: LD_VAR 0 2
105388: PUSH
105389: LD_INT 4
105391: PLUS
105392: PUSH
105393: LD_INT 5
105395: PUSH
105396: EMPTY
105397: LIST
105398: LIST
105399: LIST
105400: PUSH
105401: LD_VAR 0 1
105405: PUSH
105406: LD_INT 4
105408: MINUS
105409: PUSH
105410: LD_VAR 0 2
105414: PUSH
105415: LD_INT 1
105417: PUSH
105418: EMPTY
105419: LIST
105420: LIST
105421: LIST
105422: PUSH
105423: LD_VAR 0 1
105427: PUSH
105428: LD_VAR 0 2
105432: PUSH
105433: LD_INT 4
105435: MINUS
105436: PUSH
105437: LD_INT 3
105439: PUSH
105440: EMPTY
105441: LIST
105442: LIST
105443: LIST
105444: PUSH
105445: LD_VAR 0 1
105449: PUSH
105450: LD_INT 3
105452: MINUS
105453: PUSH
105454: LD_VAR 0 2
105458: PUSH
105459: LD_INT 3
105461: MINUS
105462: PUSH
105463: LD_INT 2
105465: PUSH
105466: EMPTY
105467: LIST
105468: LIST
105469: LIST
105470: PUSH
105471: EMPTY
105472: LIST
105473: LIST
105474: LIST
105475: LIST
105476: LIST
105477: ST_TO_ADDR
// end ; 4 :
105478: GO 105759
105480: LD_INT 4
105482: DOUBLE
105483: EQUAL
105484: IFTRUE 105488
105486: GO 105621
105488: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105489: LD_ADDR_VAR 0 5
105493: PUSH
105494: LD_VAR 0 1
105498: PUSH
105499: LD_VAR 0 2
105503: PUSH
105504: LD_INT 4
105506: PLUS
105507: PUSH
105508: LD_INT 0
105510: PUSH
105511: EMPTY
105512: LIST
105513: LIST
105514: LIST
105515: PUSH
105516: LD_VAR 0 1
105520: PUSH
105521: LD_INT 3
105523: PLUS
105524: PUSH
105525: LD_VAR 0 2
105529: PUSH
105530: LD_INT 3
105532: PLUS
105533: PUSH
105534: LD_INT 5
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: LIST
105541: PUSH
105542: LD_VAR 0 1
105546: PUSH
105547: LD_INT 4
105549: PLUS
105550: PUSH
105551: LD_VAR 0 2
105555: PUSH
105556: LD_INT 4
105558: PUSH
105559: EMPTY
105560: LIST
105561: LIST
105562: LIST
105563: PUSH
105564: LD_VAR 0 1
105568: PUSH
105569: LD_VAR 0 2
105573: PUSH
105574: LD_INT 3
105576: MINUS
105577: PUSH
105578: LD_INT 3
105580: PUSH
105581: EMPTY
105582: LIST
105583: LIST
105584: LIST
105585: PUSH
105586: LD_VAR 0 1
105590: PUSH
105591: LD_INT 4
105593: MINUS
105594: PUSH
105595: LD_VAR 0 2
105599: PUSH
105600: LD_INT 4
105602: MINUS
105603: PUSH
105604: LD_INT 2
105606: PUSH
105607: EMPTY
105608: LIST
105609: LIST
105610: LIST
105611: PUSH
105612: EMPTY
105613: LIST
105614: LIST
105615: LIST
105616: LIST
105617: LIST
105618: ST_TO_ADDR
// end ; 5 :
105619: GO 105759
105621: LD_INT 5
105623: DOUBLE
105624: EQUAL
105625: IFTRUE 105629
105627: GO 105758
105629: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105630: LD_ADDR_VAR 0 5
105634: PUSH
105635: LD_VAR 0 1
105639: PUSH
105640: LD_INT 4
105642: MINUS
105643: PUSH
105644: LD_VAR 0 2
105648: PUSH
105649: LD_INT 1
105651: PUSH
105652: EMPTY
105653: LIST
105654: LIST
105655: LIST
105656: PUSH
105657: LD_VAR 0 1
105661: PUSH
105662: LD_VAR 0 2
105666: PUSH
105667: LD_INT 4
105669: MINUS
105670: PUSH
105671: LD_INT 3
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: LIST
105678: PUSH
105679: LD_VAR 0 1
105683: PUSH
105684: LD_INT 4
105686: PLUS
105687: PUSH
105688: LD_VAR 0 2
105692: PUSH
105693: LD_INT 4
105695: PLUS
105696: PUSH
105697: LD_INT 5
105699: PUSH
105700: EMPTY
105701: LIST
105702: LIST
105703: LIST
105704: PUSH
105705: LD_VAR 0 1
105709: PUSH
105710: LD_INT 3
105712: PLUS
105713: PUSH
105714: LD_VAR 0 2
105718: PUSH
105719: LD_INT 4
105721: PUSH
105722: EMPTY
105723: LIST
105724: LIST
105725: LIST
105726: PUSH
105727: LD_VAR 0 1
105731: PUSH
105732: LD_VAR 0 2
105736: PUSH
105737: LD_INT 3
105739: PLUS
105740: PUSH
105741: LD_INT 0
105743: PUSH
105744: EMPTY
105745: LIST
105746: LIST
105747: LIST
105748: PUSH
105749: EMPTY
105750: LIST
105751: LIST
105752: LIST
105753: LIST
105754: LIST
105755: ST_TO_ADDR
// end ; end ;
105756: GO 105759
105758: POP
// result := list ;
105759: LD_ADDR_VAR 0 4
105763: PUSH
105764: LD_VAR 0 5
105768: ST_TO_ADDR
// end ;
105769: LD_VAR 0 4
105773: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105774: LD_INT 0
105776: PPUSH
105777: PPUSH
105778: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105779: LD_VAR 0 1
105783: NOT
105784: PUSH
105785: LD_VAR 0 2
105789: PUSH
105790: LD_INT 1
105792: PUSH
105793: LD_INT 2
105795: PUSH
105796: LD_INT 3
105798: PUSH
105799: LD_INT 4
105801: PUSH
105802: EMPTY
105803: LIST
105804: LIST
105805: LIST
105806: LIST
105807: IN
105808: NOT
105809: OR
105810: IFFALSE 105814
// exit ;
105812: GO 105906
// tmp := [ ] ;
105814: LD_ADDR_VAR 0 5
105818: PUSH
105819: EMPTY
105820: ST_TO_ADDR
// for i in units do
105821: LD_ADDR_VAR 0 4
105825: PUSH
105826: LD_VAR 0 1
105830: PUSH
105831: FOR_IN
105832: IFFALSE 105875
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105834: LD_ADDR_VAR 0 5
105838: PUSH
105839: LD_VAR 0 5
105843: PPUSH
105844: LD_VAR 0 5
105848: PUSH
105849: LD_INT 1
105851: PLUS
105852: PPUSH
105853: LD_VAR 0 4
105857: PPUSH
105858: LD_VAR 0 2
105862: PPUSH
105863: CALL_OW 259
105867: PPUSH
105868: CALL_OW 2
105872: ST_TO_ADDR
105873: GO 105831
105875: POP
105876: POP
// if not tmp then
105877: LD_VAR 0 5
105881: NOT
105882: IFFALSE 105886
// exit ;
105884: GO 105906
// result := SortListByListDesc ( units , tmp ) ;
105886: LD_ADDR_VAR 0 3
105890: PUSH
105891: LD_VAR 0 1
105895: PPUSH
105896: LD_VAR 0 5
105900: PPUSH
105901: CALL_OW 77
105905: ST_TO_ADDR
// end ;
105906: LD_VAR 0 3
105910: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105911: LD_INT 0
105913: PPUSH
105914: PPUSH
105915: PPUSH
// x := GetX ( building ) ;
105916: LD_ADDR_VAR 0 4
105920: PUSH
105921: LD_VAR 0 2
105925: PPUSH
105926: CALL_OW 250
105930: ST_TO_ADDR
// y := GetY ( building ) ;
105931: LD_ADDR_VAR 0 5
105935: PUSH
105936: LD_VAR 0 2
105940: PPUSH
105941: CALL_OW 251
105945: ST_TO_ADDR
// if GetTaskList ( unit ) then
105946: LD_VAR 0 1
105950: PPUSH
105951: CALL_OW 437
105955: IFFALSE 106050
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105957: LD_STRING e
105959: PUSH
105960: LD_VAR 0 1
105964: PPUSH
105965: CALL_OW 437
105969: PUSH
105970: LD_INT 1
105972: ARRAY
105973: PUSH
105974: LD_INT 1
105976: ARRAY
105977: EQUAL
105978: PUSH
105979: LD_VAR 0 4
105983: PUSH
105984: LD_VAR 0 1
105988: PPUSH
105989: CALL_OW 437
105993: PUSH
105994: LD_INT 1
105996: ARRAY
105997: PUSH
105998: LD_INT 2
106000: ARRAY
106001: EQUAL
106002: AND
106003: PUSH
106004: LD_VAR 0 5
106008: PUSH
106009: LD_VAR 0 1
106013: PPUSH
106014: CALL_OW 437
106018: PUSH
106019: LD_INT 1
106021: ARRAY
106022: PUSH
106023: LD_INT 3
106025: ARRAY
106026: EQUAL
106027: AND
106028: IFFALSE 106040
// result := true else
106030: LD_ADDR_VAR 0 3
106034: PUSH
106035: LD_INT 1
106037: ST_TO_ADDR
106038: GO 106048
// result := false ;
106040: LD_ADDR_VAR 0 3
106044: PUSH
106045: LD_INT 0
106047: ST_TO_ADDR
// end else
106048: GO 106058
// result := false ;
106050: LD_ADDR_VAR 0 3
106054: PUSH
106055: LD_INT 0
106057: ST_TO_ADDR
// end ;
106058: LD_VAR 0 3
106062: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106063: LD_INT 0
106065: PPUSH
106066: PPUSH
106067: PPUSH
106068: PPUSH
// if not unit or not area then
106069: LD_VAR 0 1
106073: NOT
106074: PUSH
106075: LD_VAR 0 2
106079: NOT
106080: OR
106081: IFFALSE 106085
// exit ;
106083: GO 106249
// tmp := AreaToList ( area , i ) ;
106085: LD_ADDR_VAR 0 6
106089: PUSH
106090: LD_VAR 0 2
106094: PPUSH
106095: LD_VAR 0 5
106099: PPUSH
106100: CALL_OW 517
106104: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106105: LD_ADDR_VAR 0 5
106109: PUSH
106110: DOUBLE
106111: LD_INT 1
106113: DEC
106114: ST_TO_ADDR
106115: LD_VAR 0 6
106119: PUSH
106120: LD_INT 1
106122: ARRAY
106123: PUSH
106124: FOR_TO
106125: IFFALSE 106247
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106127: LD_ADDR_VAR 0 7
106131: PUSH
106132: LD_VAR 0 6
106136: PUSH
106137: LD_INT 1
106139: ARRAY
106140: PUSH
106141: LD_VAR 0 5
106145: ARRAY
106146: PUSH
106147: LD_VAR 0 6
106151: PUSH
106152: LD_INT 2
106154: ARRAY
106155: PUSH
106156: LD_VAR 0 5
106160: ARRAY
106161: PUSH
106162: EMPTY
106163: LIST
106164: LIST
106165: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106166: LD_VAR 0 7
106170: PUSH
106171: LD_INT 1
106173: ARRAY
106174: PPUSH
106175: LD_VAR 0 7
106179: PUSH
106180: LD_INT 2
106182: ARRAY
106183: PPUSH
106184: CALL_OW 428
106188: PUSH
106189: LD_INT 0
106191: EQUAL
106192: IFFALSE 106245
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106194: LD_VAR 0 1
106198: PPUSH
106199: LD_VAR 0 7
106203: PUSH
106204: LD_INT 1
106206: ARRAY
106207: PPUSH
106208: LD_VAR 0 7
106212: PUSH
106213: LD_INT 2
106215: ARRAY
106216: PPUSH
106217: LD_VAR 0 3
106221: PPUSH
106222: CALL_OW 48
// result := IsPlaced ( unit ) ;
106226: LD_ADDR_VAR 0 4
106230: PUSH
106231: LD_VAR 0 1
106235: PPUSH
106236: CALL_OW 305
106240: ST_TO_ADDR
// exit ;
106241: POP
106242: POP
106243: GO 106249
// end ; end ;
106245: GO 106124
106247: POP
106248: POP
// end ;
106249: LD_VAR 0 4
106253: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106254: LD_INT 0
106256: PPUSH
106257: PPUSH
106258: PPUSH
// if not side or side > 8 then
106259: LD_VAR 0 1
106263: NOT
106264: PUSH
106265: LD_VAR 0 1
106269: PUSH
106270: LD_INT 8
106272: GREATER
106273: OR
106274: IFFALSE 106278
// exit ;
106276: GO 106465
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106278: LD_ADDR_VAR 0 4
106282: PUSH
106283: LD_INT 22
106285: PUSH
106286: LD_VAR 0 1
106290: PUSH
106291: EMPTY
106292: LIST
106293: LIST
106294: PUSH
106295: LD_INT 21
106297: PUSH
106298: LD_INT 3
106300: PUSH
106301: EMPTY
106302: LIST
106303: LIST
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: PPUSH
106309: CALL_OW 69
106313: ST_TO_ADDR
// if not tmp then
106314: LD_VAR 0 4
106318: NOT
106319: IFFALSE 106323
// exit ;
106321: GO 106465
// enable_addtolog := true ;
106323: LD_ADDR_OWVAR 81
106327: PUSH
106328: LD_INT 1
106330: ST_TO_ADDR
// AddToLog ( [ ) ;
106331: LD_STRING [
106333: PPUSH
106334: CALL_OW 561
// for i in tmp do
106338: LD_ADDR_VAR 0 3
106342: PUSH
106343: LD_VAR 0 4
106347: PUSH
106348: FOR_IN
106349: IFFALSE 106456
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106351: LD_STRING [
106353: PUSH
106354: LD_VAR 0 3
106358: PPUSH
106359: CALL_OW 266
106363: STR
106364: PUSH
106365: LD_STRING , 
106367: STR
106368: PUSH
106369: LD_VAR 0 3
106373: PPUSH
106374: CALL_OW 250
106378: STR
106379: PUSH
106380: LD_STRING , 
106382: STR
106383: PUSH
106384: LD_VAR 0 3
106388: PPUSH
106389: CALL_OW 251
106393: STR
106394: PUSH
106395: LD_STRING , 
106397: STR
106398: PUSH
106399: LD_VAR 0 3
106403: PPUSH
106404: CALL_OW 254
106408: STR
106409: PUSH
106410: LD_STRING , 
106412: STR
106413: PUSH
106414: LD_VAR 0 3
106418: PPUSH
106419: LD_INT 1
106421: PPUSH
106422: CALL_OW 268
106426: STR
106427: PUSH
106428: LD_STRING , 
106430: STR
106431: PUSH
106432: LD_VAR 0 3
106436: PPUSH
106437: LD_INT 2
106439: PPUSH
106440: CALL_OW 268
106444: STR
106445: PUSH
106446: LD_STRING ],
106448: STR
106449: PPUSH
106450: CALL_OW 561
// end ;
106454: GO 106348
106456: POP
106457: POP
// AddToLog ( ]; ) ;
106458: LD_STRING ];
106460: PPUSH
106461: CALL_OW 561
// end ;
106465: LD_VAR 0 2
106469: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106470: LD_INT 0
106472: PPUSH
106473: PPUSH
106474: PPUSH
106475: PPUSH
106476: PPUSH
// if not area or not rate or not max then
106477: LD_VAR 0 1
106481: NOT
106482: PUSH
106483: LD_VAR 0 2
106487: NOT
106488: OR
106489: PUSH
106490: LD_VAR 0 4
106494: NOT
106495: OR
106496: IFFALSE 106500
// exit ;
106498: GO 106692
// while 1 do
106500: LD_INT 1
106502: IFFALSE 106692
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106504: LD_ADDR_VAR 0 9
106508: PUSH
106509: LD_VAR 0 1
106513: PPUSH
106514: LD_INT 1
106516: PPUSH
106517: CALL_OW 287
106521: PUSH
106522: LD_INT 10
106524: MUL
106525: ST_TO_ADDR
// r := rate / 10 ;
106526: LD_ADDR_VAR 0 7
106530: PUSH
106531: LD_VAR 0 2
106535: PUSH
106536: LD_INT 10
106538: DIVREAL
106539: ST_TO_ADDR
// time := 1 1$00 ;
106540: LD_ADDR_VAR 0 8
106544: PUSH
106545: LD_INT 2100
106547: ST_TO_ADDR
// if amount < min then
106548: LD_VAR 0 9
106552: PUSH
106553: LD_VAR 0 3
106557: LESS
106558: IFFALSE 106576
// r := r * 2 else
106560: LD_ADDR_VAR 0 7
106564: PUSH
106565: LD_VAR 0 7
106569: PUSH
106570: LD_INT 2
106572: MUL
106573: ST_TO_ADDR
106574: GO 106602
// if amount > max then
106576: LD_VAR 0 9
106580: PUSH
106581: LD_VAR 0 4
106585: GREATER
106586: IFFALSE 106602
// r := r / 2 ;
106588: LD_ADDR_VAR 0 7
106592: PUSH
106593: LD_VAR 0 7
106597: PUSH
106598: LD_INT 2
106600: DIVREAL
106601: ST_TO_ADDR
// time := time / r ;
106602: LD_ADDR_VAR 0 8
106606: PUSH
106607: LD_VAR 0 8
106611: PUSH
106612: LD_VAR 0 7
106616: DIVREAL
106617: ST_TO_ADDR
// if time < 0 then
106618: LD_VAR 0 8
106622: PUSH
106623: LD_INT 0
106625: LESS
106626: IFFALSE 106643
// time := time * - 1 ;
106628: LD_ADDR_VAR 0 8
106632: PUSH
106633: LD_VAR 0 8
106637: PUSH
106638: LD_INT 1
106640: NEG
106641: MUL
106642: ST_TO_ADDR
// wait ( time ) ;
106643: LD_VAR 0 8
106647: PPUSH
106648: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106652: LD_INT 35
106654: PPUSH
106655: LD_INT 875
106657: PPUSH
106658: CALL_OW 12
106662: PPUSH
106663: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106667: LD_INT 1
106669: PPUSH
106670: LD_INT 5
106672: PPUSH
106673: CALL_OW 12
106677: PPUSH
106678: LD_VAR 0 1
106682: PPUSH
106683: LD_INT 1
106685: PPUSH
106686: CALL_OW 55
// end ;
106690: GO 106500
// end ;
106692: LD_VAR 0 5
106696: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106697: LD_INT 0
106699: PPUSH
106700: PPUSH
106701: PPUSH
106702: PPUSH
106703: PPUSH
106704: PPUSH
106705: PPUSH
106706: PPUSH
// if not turrets or not factories then
106707: LD_VAR 0 1
106711: NOT
106712: PUSH
106713: LD_VAR 0 2
106717: NOT
106718: OR
106719: IFFALSE 106723
// exit ;
106721: GO 107030
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106723: LD_ADDR_VAR 0 10
106727: PUSH
106728: LD_INT 5
106730: PUSH
106731: LD_INT 6
106733: PUSH
106734: EMPTY
106735: LIST
106736: LIST
106737: PUSH
106738: LD_INT 2
106740: PUSH
106741: LD_INT 4
106743: PUSH
106744: EMPTY
106745: LIST
106746: LIST
106747: PUSH
106748: LD_INT 3
106750: PUSH
106751: LD_INT 5
106753: PUSH
106754: EMPTY
106755: LIST
106756: LIST
106757: PUSH
106758: EMPTY
106759: LIST
106760: LIST
106761: LIST
106762: PUSH
106763: LD_INT 24
106765: PUSH
106766: LD_INT 25
106768: PUSH
106769: EMPTY
106770: LIST
106771: LIST
106772: PUSH
106773: LD_INT 23
106775: PUSH
106776: LD_INT 27
106778: PUSH
106779: EMPTY
106780: LIST
106781: LIST
106782: PUSH
106783: EMPTY
106784: LIST
106785: LIST
106786: PUSH
106787: LD_INT 42
106789: PUSH
106790: LD_INT 43
106792: PUSH
106793: EMPTY
106794: LIST
106795: LIST
106796: PUSH
106797: LD_INT 44
106799: PUSH
106800: LD_INT 46
106802: PUSH
106803: EMPTY
106804: LIST
106805: LIST
106806: PUSH
106807: LD_INT 45
106809: PUSH
106810: LD_INT 47
106812: PUSH
106813: EMPTY
106814: LIST
106815: LIST
106816: PUSH
106817: EMPTY
106818: LIST
106819: LIST
106820: LIST
106821: PUSH
106822: EMPTY
106823: LIST
106824: LIST
106825: LIST
106826: ST_TO_ADDR
// result := [ ] ;
106827: LD_ADDR_VAR 0 3
106831: PUSH
106832: EMPTY
106833: ST_TO_ADDR
// for i in turrets do
106834: LD_ADDR_VAR 0 4
106838: PUSH
106839: LD_VAR 0 1
106843: PUSH
106844: FOR_IN
106845: IFFALSE 107028
// begin nat := GetNation ( i ) ;
106847: LD_ADDR_VAR 0 7
106851: PUSH
106852: LD_VAR 0 4
106856: PPUSH
106857: CALL_OW 248
106861: ST_TO_ADDR
// weapon := 0 ;
106862: LD_ADDR_VAR 0 8
106866: PUSH
106867: LD_INT 0
106869: ST_TO_ADDR
// if not nat then
106870: LD_VAR 0 7
106874: NOT
106875: IFFALSE 106879
// continue ;
106877: GO 106844
// for j in list [ nat ] do
106879: LD_ADDR_VAR 0 5
106883: PUSH
106884: LD_VAR 0 10
106888: PUSH
106889: LD_VAR 0 7
106893: ARRAY
106894: PUSH
106895: FOR_IN
106896: IFFALSE 106937
// if GetBWeapon ( i ) = j [ 1 ] then
106898: LD_VAR 0 4
106902: PPUSH
106903: CALL_OW 269
106907: PUSH
106908: LD_VAR 0 5
106912: PUSH
106913: LD_INT 1
106915: ARRAY
106916: EQUAL
106917: IFFALSE 106935
// begin weapon := j [ 2 ] ;
106919: LD_ADDR_VAR 0 8
106923: PUSH
106924: LD_VAR 0 5
106928: PUSH
106929: LD_INT 2
106931: ARRAY
106932: ST_TO_ADDR
// break ;
106933: GO 106937
// end ;
106935: GO 106895
106937: POP
106938: POP
// if not weapon then
106939: LD_VAR 0 8
106943: NOT
106944: IFFALSE 106948
// continue ;
106946: GO 106844
// for k in factories do
106948: LD_ADDR_VAR 0 6
106952: PUSH
106953: LD_VAR 0 2
106957: PUSH
106958: FOR_IN
106959: IFFALSE 107024
// begin weapons := AvailableWeaponList ( k ) ;
106961: LD_ADDR_VAR 0 9
106965: PUSH
106966: LD_VAR 0 6
106970: PPUSH
106971: CALL_OW 478
106975: ST_TO_ADDR
// if not weapons then
106976: LD_VAR 0 9
106980: NOT
106981: IFFALSE 106985
// continue ;
106983: GO 106958
// if weapon in weapons then
106985: LD_VAR 0 8
106989: PUSH
106990: LD_VAR 0 9
106994: IN
106995: IFFALSE 107022
// begin result := [ i , weapon ] ;
106997: LD_ADDR_VAR 0 3
107001: PUSH
107002: LD_VAR 0 4
107006: PUSH
107007: LD_VAR 0 8
107011: PUSH
107012: EMPTY
107013: LIST
107014: LIST
107015: ST_TO_ADDR
// exit ;
107016: POP
107017: POP
107018: POP
107019: POP
107020: GO 107030
// end ; end ;
107022: GO 106958
107024: POP
107025: POP
// end ;
107026: GO 106844
107028: POP
107029: POP
// end ;
107030: LD_VAR 0 3
107034: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107035: LD_INT 0
107037: PPUSH
// if not side or side > 8 then
107038: LD_VAR 0 3
107042: NOT
107043: PUSH
107044: LD_VAR 0 3
107048: PUSH
107049: LD_INT 8
107051: GREATER
107052: OR
107053: IFFALSE 107057
// exit ;
107055: GO 107116
// if not range then
107057: LD_VAR 0 4
107061: NOT
107062: IFFALSE 107073
// range := - 12 ;
107064: LD_ADDR_VAR 0 4
107068: PUSH
107069: LD_INT 12
107071: NEG
107072: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107073: LD_VAR 0 1
107077: PPUSH
107078: LD_VAR 0 2
107082: PPUSH
107083: LD_VAR 0 3
107087: PPUSH
107088: LD_VAR 0 4
107092: PPUSH
107093: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107097: LD_VAR 0 1
107101: PPUSH
107102: LD_VAR 0 2
107106: PPUSH
107107: LD_VAR 0 3
107111: PPUSH
107112: CALL_OW 331
// end ;
107116: LD_VAR 0 5
107120: RET
// export function Video ( mode ) ; begin
107121: LD_INT 0
107123: PPUSH
// ingame_video = mode ;
107124: LD_ADDR_OWVAR 52
107128: PUSH
107129: LD_VAR 0 1
107133: ST_TO_ADDR
// interface_hidden = mode ;
107134: LD_ADDR_OWVAR 54
107138: PUSH
107139: LD_VAR 0 1
107143: ST_TO_ADDR
// end ;
107144: LD_VAR 0 2
107148: RET
// export function Join ( array , element ) ; begin
107149: LD_INT 0
107151: PPUSH
// result := array ^ element ;
107152: LD_ADDR_VAR 0 3
107156: PUSH
107157: LD_VAR 0 1
107161: PUSH
107162: LD_VAR 0 2
107166: ADD
107167: ST_TO_ADDR
// end ;
107168: LD_VAR 0 3
107172: RET
// export function JoinUnion ( array , element ) ; begin
107173: LD_INT 0
107175: PPUSH
// result := array union element ;
107176: LD_ADDR_VAR 0 3
107180: PUSH
107181: LD_VAR 0 1
107185: PUSH
107186: LD_VAR 0 2
107190: UNION
107191: ST_TO_ADDR
// end ;
107192: LD_VAR 0 3
107196: RET
// export function GetBehemoths ( side ) ; begin
107197: LD_INT 0
107199: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107200: LD_ADDR_VAR 0 2
107204: PUSH
107205: LD_INT 22
107207: PUSH
107208: LD_VAR 0 1
107212: PUSH
107213: EMPTY
107214: LIST
107215: LIST
107216: PUSH
107217: LD_INT 31
107219: PUSH
107220: LD_INT 25
107222: PUSH
107223: EMPTY
107224: LIST
107225: LIST
107226: PUSH
107227: EMPTY
107228: LIST
107229: LIST
107230: PPUSH
107231: CALL_OW 69
107235: ST_TO_ADDR
// end ;
107236: LD_VAR 0 2
107240: RET
// export function Shuffle ( array ) ; var i , index ; begin
107241: LD_INT 0
107243: PPUSH
107244: PPUSH
107245: PPUSH
// result := [ ] ;
107246: LD_ADDR_VAR 0 2
107250: PUSH
107251: EMPTY
107252: ST_TO_ADDR
// if not array then
107253: LD_VAR 0 1
107257: NOT
107258: IFFALSE 107262
// exit ;
107260: GO 107361
// Randomize ;
107262: CALL_OW 10
// for i = array downto 1 do
107266: LD_ADDR_VAR 0 3
107270: PUSH
107271: DOUBLE
107272: LD_VAR 0 1
107276: INC
107277: ST_TO_ADDR
107278: LD_INT 1
107280: PUSH
107281: FOR_DOWNTO
107282: IFFALSE 107359
// begin index := rand ( 1 , array ) ;
107284: LD_ADDR_VAR 0 4
107288: PUSH
107289: LD_INT 1
107291: PPUSH
107292: LD_VAR 0 1
107296: PPUSH
107297: CALL_OW 12
107301: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107302: LD_ADDR_VAR 0 2
107306: PUSH
107307: LD_VAR 0 2
107311: PPUSH
107312: LD_VAR 0 2
107316: PUSH
107317: LD_INT 1
107319: PLUS
107320: PPUSH
107321: LD_VAR 0 1
107325: PUSH
107326: LD_VAR 0 4
107330: ARRAY
107331: PPUSH
107332: CALL_OW 2
107336: ST_TO_ADDR
// array := Delete ( array , index ) ;
107337: LD_ADDR_VAR 0 1
107341: PUSH
107342: LD_VAR 0 1
107346: PPUSH
107347: LD_VAR 0 4
107351: PPUSH
107352: CALL_OW 3
107356: ST_TO_ADDR
// end ;
107357: GO 107281
107359: POP
107360: POP
// end ;
107361: LD_VAR 0 2
107365: RET
// export function GetBaseMaterials ( base ) ; begin
107366: LD_INT 0
107368: PPUSH
// result := [ 0 , 0 , 0 ] ;
107369: LD_ADDR_VAR 0 2
107373: PUSH
107374: LD_INT 0
107376: PUSH
107377: LD_INT 0
107379: PUSH
107380: LD_INT 0
107382: PUSH
107383: EMPTY
107384: LIST
107385: LIST
107386: LIST
107387: ST_TO_ADDR
// if not base then
107388: LD_VAR 0 1
107392: NOT
107393: IFFALSE 107397
// exit ;
107395: GO 107446
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107397: LD_ADDR_VAR 0 2
107401: PUSH
107402: LD_VAR 0 1
107406: PPUSH
107407: LD_INT 1
107409: PPUSH
107410: CALL_OW 275
107414: PUSH
107415: LD_VAR 0 1
107419: PPUSH
107420: LD_INT 2
107422: PPUSH
107423: CALL_OW 275
107427: PUSH
107428: LD_VAR 0 1
107432: PPUSH
107433: LD_INT 3
107435: PPUSH
107436: CALL_OW 275
107440: PUSH
107441: EMPTY
107442: LIST
107443: LIST
107444: LIST
107445: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107446: LD_VAR 0 2
107450: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107451: LD_INT 0
107453: PPUSH
107454: PPUSH
107455: PPUSH
107456: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107457: LD_VAR 0 1
107461: PPUSH
107462: CALL_OW 264
107466: PUSH
107467: LD_EXP 98
107471: EQUAL
107472: IFFALSE 107544
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107474: LD_INT 68
107476: PPUSH
107477: LD_VAR 0 1
107481: PPUSH
107482: CALL_OW 255
107486: PPUSH
107487: CALL_OW 321
107491: PUSH
107492: LD_INT 2
107494: EQUAL
107495: IFFALSE 107507
// eff := 70 else
107497: LD_ADDR_VAR 0 6
107501: PUSH
107502: LD_INT 70
107504: ST_TO_ADDR
107505: GO 107515
// eff := 30 ;
107507: LD_ADDR_VAR 0 6
107511: PUSH
107512: LD_INT 30
107514: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107515: LD_VAR 0 1
107519: PPUSH
107520: CALL_OW 250
107524: PPUSH
107525: LD_VAR 0 1
107529: PPUSH
107530: CALL_OW 251
107534: PPUSH
107535: LD_VAR 0 6
107539: PPUSH
107540: CALL_OW 495
// end ; end ;
107544: LD_VAR 0 4
107548: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107549: LD_INT 0
107551: PPUSH
107552: PPUSH
107553: PPUSH
107554: PPUSH
107555: PPUSH
107556: PPUSH
// if cmd = 124 then
107557: LD_VAR 0 1
107561: PUSH
107562: LD_INT 124
107564: EQUAL
107565: IFFALSE 107771
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107567: LD_ADDR_VAR 0 5
107571: PUSH
107572: LD_INT 2
107574: PUSH
107575: LD_INT 34
107577: PUSH
107578: LD_INT 53
107580: PUSH
107581: EMPTY
107582: LIST
107583: LIST
107584: PUSH
107585: LD_INT 34
107587: PUSH
107588: LD_INT 14
107590: PUSH
107591: EMPTY
107592: LIST
107593: LIST
107594: PUSH
107595: EMPTY
107596: LIST
107597: LIST
107598: LIST
107599: PPUSH
107600: CALL_OW 69
107604: ST_TO_ADDR
// if not tmp then
107605: LD_VAR 0 5
107609: NOT
107610: IFFALSE 107614
// exit ;
107612: GO 107771
// for i in tmp do
107614: LD_ADDR_VAR 0 3
107618: PUSH
107619: LD_VAR 0 5
107623: PUSH
107624: FOR_IN
107625: IFFALSE 107769
// begin taskList := GetTaskList ( i ) ;
107627: LD_ADDR_VAR 0 6
107631: PUSH
107632: LD_VAR 0 3
107636: PPUSH
107637: CALL_OW 437
107641: ST_TO_ADDR
// if not taskList then
107642: LD_VAR 0 6
107646: NOT
107647: IFFALSE 107651
// continue ;
107649: GO 107624
// for j = 1 to taskList do
107651: LD_ADDR_VAR 0 4
107655: PUSH
107656: DOUBLE
107657: LD_INT 1
107659: DEC
107660: ST_TO_ADDR
107661: LD_VAR 0 6
107665: PUSH
107666: FOR_TO
107667: IFFALSE 107765
// if taskList [ j ] [ 1 ] = | then
107669: LD_VAR 0 6
107673: PUSH
107674: LD_VAR 0 4
107678: ARRAY
107679: PUSH
107680: LD_INT 1
107682: ARRAY
107683: PUSH
107684: LD_STRING |
107686: EQUAL
107687: IFFALSE 107763
// begin _taskList := Delete ( taskList , 1 ) ;
107689: LD_ADDR_VAR 0 7
107693: PUSH
107694: LD_VAR 0 6
107698: PPUSH
107699: LD_INT 1
107701: PPUSH
107702: CALL_OW 3
107706: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107707: LD_VAR 0 3
107711: PPUSH
107712: LD_VAR 0 7
107716: PPUSH
107717: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107721: LD_VAR 0 3
107725: PPUSH
107726: LD_VAR 0 6
107730: PUSH
107731: LD_VAR 0 4
107735: ARRAY
107736: PUSH
107737: LD_INT 2
107739: ARRAY
107740: PPUSH
107741: LD_VAR 0 6
107745: PUSH
107746: LD_VAR 0 4
107750: ARRAY
107751: PUSH
107752: LD_INT 3
107754: ARRAY
107755: PPUSH
107756: LD_INT 8
107758: PPUSH
107759: CALL 107776 0 4
// end ;
107763: GO 107666
107765: POP
107766: POP
// end ;
107767: GO 107624
107769: POP
107770: POP
// end ; end ;
107771: LD_VAR 0 2
107775: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107776: LD_INT 0
107778: PPUSH
107779: PPUSH
107780: PPUSH
107781: PPUSH
107782: PPUSH
107783: PPUSH
107784: PPUSH
107785: PPUSH
107786: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107787: LD_VAR 0 1
107791: NOT
107792: PUSH
107793: LD_VAR 0 2
107797: PPUSH
107798: LD_VAR 0 3
107802: PPUSH
107803: CALL_OW 488
107807: NOT
107808: OR
107809: PUSH
107810: LD_VAR 0 4
107814: NOT
107815: OR
107816: IFFALSE 107820
// exit ;
107818: GO 108160
// list := [ ] ;
107820: LD_ADDR_VAR 0 13
107824: PUSH
107825: EMPTY
107826: ST_TO_ADDR
// if x - r < 0 then
107827: LD_VAR 0 2
107831: PUSH
107832: LD_VAR 0 4
107836: MINUS
107837: PUSH
107838: LD_INT 0
107840: LESS
107841: IFFALSE 107853
// min_x := 0 else
107843: LD_ADDR_VAR 0 7
107847: PUSH
107848: LD_INT 0
107850: ST_TO_ADDR
107851: GO 107869
// min_x := x - r ;
107853: LD_ADDR_VAR 0 7
107857: PUSH
107858: LD_VAR 0 2
107862: PUSH
107863: LD_VAR 0 4
107867: MINUS
107868: ST_TO_ADDR
// if y - r < 0 then
107869: LD_VAR 0 3
107873: PUSH
107874: LD_VAR 0 4
107878: MINUS
107879: PUSH
107880: LD_INT 0
107882: LESS
107883: IFFALSE 107895
// min_y := 0 else
107885: LD_ADDR_VAR 0 8
107889: PUSH
107890: LD_INT 0
107892: ST_TO_ADDR
107893: GO 107911
// min_y := y - r ;
107895: LD_ADDR_VAR 0 8
107899: PUSH
107900: LD_VAR 0 3
107904: PUSH
107905: LD_VAR 0 4
107909: MINUS
107910: ST_TO_ADDR
// max_x := x + r ;
107911: LD_ADDR_VAR 0 9
107915: PUSH
107916: LD_VAR 0 2
107920: PUSH
107921: LD_VAR 0 4
107925: PLUS
107926: ST_TO_ADDR
// max_y := y + r ;
107927: LD_ADDR_VAR 0 10
107931: PUSH
107932: LD_VAR 0 3
107936: PUSH
107937: LD_VAR 0 4
107941: PLUS
107942: ST_TO_ADDR
// for _x = min_x to max_x do
107943: LD_ADDR_VAR 0 11
107947: PUSH
107948: DOUBLE
107949: LD_VAR 0 7
107953: DEC
107954: ST_TO_ADDR
107955: LD_VAR 0 9
107959: PUSH
107960: FOR_TO
107961: IFFALSE 108078
// for _y = min_y to max_y do
107963: LD_ADDR_VAR 0 12
107967: PUSH
107968: DOUBLE
107969: LD_VAR 0 8
107973: DEC
107974: ST_TO_ADDR
107975: LD_VAR 0 10
107979: PUSH
107980: FOR_TO
107981: IFFALSE 108074
// begin if not ValidHex ( _x , _y ) then
107983: LD_VAR 0 11
107987: PPUSH
107988: LD_VAR 0 12
107992: PPUSH
107993: CALL_OW 488
107997: NOT
107998: IFFALSE 108002
// continue ;
108000: GO 107980
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108002: LD_VAR 0 11
108006: PPUSH
108007: LD_VAR 0 12
108011: PPUSH
108012: CALL_OW 351
108016: PUSH
108017: LD_VAR 0 11
108021: PPUSH
108022: LD_VAR 0 12
108026: PPUSH
108027: CALL_OW 554
108031: AND
108032: IFFALSE 108072
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108034: LD_ADDR_VAR 0 13
108038: PUSH
108039: LD_VAR 0 13
108043: PPUSH
108044: LD_VAR 0 13
108048: PUSH
108049: LD_INT 1
108051: PLUS
108052: PPUSH
108053: LD_VAR 0 11
108057: PUSH
108058: LD_VAR 0 12
108062: PUSH
108063: EMPTY
108064: LIST
108065: LIST
108066: PPUSH
108067: CALL_OW 2
108071: ST_TO_ADDR
// end ;
108072: GO 107980
108074: POP
108075: POP
108076: GO 107960
108078: POP
108079: POP
// if not list then
108080: LD_VAR 0 13
108084: NOT
108085: IFFALSE 108089
// exit ;
108087: GO 108160
// for i in list do
108089: LD_ADDR_VAR 0 6
108093: PUSH
108094: LD_VAR 0 13
108098: PUSH
108099: FOR_IN
108100: IFFALSE 108158
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108102: LD_VAR 0 1
108106: PPUSH
108107: LD_STRING M
108109: PUSH
108110: LD_VAR 0 6
108114: PUSH
108115: LD_INT 1
108117: ARRAY
108118: PUSH
108119: LD_VAR 0 6
108123: PUSH
108124: LD_INT 2
108126: ARRAY
108127: PUSH
108128: LD_INT 0
108130: PUSH
108131: LD_INT 0
108133: PUSH
108134: LD_INT 0
108136: PUSH
108137: LD_INT 0
108139: PUSH
108140: EMPTY
108141: LIST
108142: LIST
108143: LIST
108144: LIST
108145: LIST
108146: LIST
108147: LIST
108148: PUSH
108149: EMPTY
108150: LIST
108151: PPUSH
108152: CALL_OW 447
108156: GO 108099
108158: POP
108159: POP
// end ;
108160: LD_VAR 0 5
108164: RET
